# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup
.end
### .include 'gen/nqp-how.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1295994641.609")
.annotate 'line', 0
    get_hll_global $P918, ["NQPMu"], "_block917" 
    capture_lex $P918
    get_hll_global $P878, ["NQPAttribute"], "_block877" 
    capture_lex $P878
    get_hll_global $P44, ["NQPClassHOW"], "_block43" 
    capture_lex $P44
    get_hll_global $P18, ["KnowHOWAttribute"], "_block17" 
    capture_lex $P18
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, "NQPMu"
    get_hll_global $P14, "NQPAttribute"
    get_hll_global $P15, "NQPClassHOW"
    get_hll_global $P16, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P18, ["KnowHOWAttribute"], "_block17" 
    capture_lex $P18
    $P18()
.annotate 'line', 26
    get_hll_global $P44, ["NQPClassHOW"], "_block43" 
    capture_lex $P44
    $P44()
.annotate 'line', 394
    get_hll_global $P878, ["NQPAttribute"], "_block877" 
    capture_lex $P878
    $P878()
.annotate 'line', 413
    get_hll_global $P918, ["NQPMu"], "_block917" 
    capture_lex $P918
    $P960 = $P918()
.annotate 'line', 1
    .return ($P960)
    .const 'Sub' $P962 = "70_1295994641.609" 
    .return ($P962)
.end


.namespace ["KnowHOWAttribute"]
.sub "_block17"  :subid("11_1295994641.609") :outer("10_1295994641.609")
.annotate 'line', 10
    .const 'Sub' $P34 = "14_1295994641.609" 
    capture_lex $P34
    .const 'Sub' $P28 = "13_1295994641.609" 
    capture_lex $P28
    .const 'Sub' $P20 = "12_1295994641.609" 
    capture_lex $P20
    get_global $P19, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P28 = "13_1295994641.609" 
    newclosure $P32, $P28
.annotate 'line', 10
    .return ($P32)
.end


.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post71") :outer("11_1295994641.609")
.annotate 'line', 10
    get_hll_global $P18, ["KnowHOWAttribute"], "_block17" 
    .local pmc block
    set block, $P18
    .const 'Sub' $P34 = "14_1295994641.609" 
    capture_lex $P34
    $P34()
.end


.namespace ["KnowHOWAttribute"]
.sub "_block33"  :anon :subid("14_1295994641.609") :outer("11_1295994641.609")
.annotate 'line', 10
    get_hll_global $P35, "KnowHOW"
    $P36 = $P35."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P36
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P37, type_obj
    .const 'Sub' $P38 = "12_1295994641.609" 
    $P37."add_method"(type_obj, "new", $P38)
    get_how $P39, type_obj
    .const 'Sub' $P40 = "13_1295994641.609" 
    $P39."add_method"(type_obj, "name", $P40)
    get_how $P41, type_obj
    $P42 = $P41."compose"(type_obj)
    .return ($P42)
.end


.namespace ["KnowHOWAttribute"]
.sub "new"  :subid("12_1295994641.609") :outer("11_1295994641.609")
    .param pmc param_21
    .param pmc param_22 :optional :named("name")
    .param int has_param_22 :opt_flag
.annotate 'line', 11
    .lex "self", param_21
    if has_param_22, optparam_72
    new $P23, "Undef"
    set param_22, $P23
  optparam_72:
    .lex "$name", param_22
.annotate 'line', 12
    find_lex $P24, "$name"
    set $S25, $P24
    get_hll_global $P26, "KnowHOWAttribute"
    repr_box_str $P27, $S25, $P26
.annotate 'line', 11
    .return ($P27)
.end


.namespace ["KnowHOWAttribute"]
.sub "name"  :subid("13_1295994641.609") :outer("11_1295994641.609")
    .param pmc param_29
.annotate 'line', 14
    .lex "self", param_29
.annotate 'line', 15
    find_lex $P30, "self"
    repr_unbox_str $S31, $P30
.annotate 'line', 14
    .return ($S31)
.end


.namespace ["NQPClassHOW"]
.sub "_block43"  :subid("15_1295994641.609") :outer("10_1295994641.609")
.annotate 'line', 26
    .const 'Sub' $P797 = "58_1295994641.609" 
    capture_lex $P797
    .const 'Sub' $P760 = "56_1295994641.609" 
    capture_lex $P760
    .const 'Sub' $P724 = "54_1295994641.609" 
    capture_lex $P724
    .const 'Sub' $P690 = "53_1295994641.609" 
    capture_lex $P690
    .const 'Sub' $P653 = "52_1295994641.609" 
    capture_lex $P653
    .const 'Sub' $P630 = "50_1295994641.609" 
    capture_lex $P630
    .const 'Sub' $P624 = "49_1295994641.609" 
    capture_lex $P624
    .const 'Sub' $P618 = "48_1295994641.609" 
    capture_lex $P618
    .const 'Sub' $P595 = "46_1295994641.609" 
    capture_lex $P595
    .const 'Sub' $P588 = "45_1295994641.609" 
    capture_lex $P588
    .const 'Sub' $P574 = "44_1295994641.609" 
    capture_lex $P574
    .const 'Sub' $P529 = "41_1295994641.609" 
    capture_lex $P529
    .const 'Sub' $P522 = "40_1295994641.609" 
    capture_lex $P522
    .const 'Sub' $P392 = "35_1295994641.609" 
    capture_lex $P392
    .const 'Sub' $P355 = "34_1295994641.609" 
    capture_lex $P355
    .const 'Sub' $P317 = "32_1295994641.609" 
    capture_lex $P317
    .const 'Sub' $P296 = "31_1295994641.609" 
    capture_lex $P296
    .const 'Sub' $P275 = "30_1295994641.609" 
    capture_lex $P275
    .const 'Sub' $P256 = "29_1295994641.609" 
    capture_lex $P256
    .const 'Sub' $P242 = "28_1295994641.609" 
    capture_lex $P242
    .const 'Sub' $P235 = "27_1295994641.609" 
    capture_lex $P235
    .const 'Sub' $P225 = "26_1295994641.609" 
    capture_lex $P225
    .const 'Sub' $P88 = "19_1295994641.609" 
    capture_lex $P88
    .const 'Sub' $P46 = "16_1295994641.609" 
    capture_lex $P46
    get_global $P45, "$?CLASS"
.annotate 'line', 196
    .const 'Sub' $P46 = "16_1295994641.609" 
    newclosure $P87, $P46
    .lex "compute_c3_mro", $P87
.annotate 'line', 218
    .const 'Sub' $P88 = "19_1295994641.609" 
    newclosure $P224, $P88
    .lex "c3_merge", $P224
.annotate 'line', 142
    find_lex $P520, "compute_c3_mro"
    find_lex $P521, "c3_merge"
.annotate 'line', 381
    .const 'Sub' $P760 = "56_1295994641.609" 
    newclosure $P795, $P760
.annotate 'line', 26
    .return ($P795)
.end


.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post73") :outer("15_1295994641.609")
.annotate 'line', 26
    get_hll_global $P44, ["NQPClassHOW"], "_block43" 
    .local pmc block
    set block, $P44
    .const 'Sub' $P797 = "58_1295994641.609" 
    capture_lex $P797
    $P797()
.end


.namespace ["NQPClassHOW"]
.sub "_block796"  :anon :subid("58_1295994641.609") :outer("15_1295994641.609")
.annotate 'line', 26
    get_hll_global $P798, "KnowHOW"
    $P799 = $P798."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P799
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P800, type_obj
    get_hll_global $P801, "KnowHOWAttribute"
    $P802 = $P801."new"("$!name" :named("name"))
    $P800."add_attribute"(type_obj, $P802)
    get_how $P803, type_obj
    get_hll_global $P804, "KnowHOWAttribute"
    $P805 = $P804."new"("%!attributes" :named("name"))
    $P803."add_attribute"(type_obj, $P805)
    get_how $P806, type_obj
    get_hll_global $P807, "KnowHOWAttribute"
    $P808 = $P807."new"("%!methods" :named("name"))
    $P806."add_attribute"(type_obj, $P808)
    get_how $P809, type_obj
    get_hll_global $P810, "KnowHOWAttribute"
    $P811 = $P810."new"("@!multi_methods_to_incorporate" :named("name"))
    $P809."add_attribute"(type_obj, $P811)
    get_how $P812, type_obj
    get_hll_global $P813, "KnowHOWAttribute"
    $P814 = $P813."new"("@!parents" :named("name"))
    $P812."add_attribute"(type_obj, $P814)
    get_how $P815, type_obj
    get_hll_global $P816, "KnowHOWAttribute"
    $P817 = $P816."new"("@!roles" :named("name"))
    $P815."add_attribute"(type_obj, $P817)
    get_how $P818, type_obj
    get_hll_global $P819, "KnowHOWAttribute"
    $P820 = $P819."new"("@!vtable" :named("name"))
    $P818."add_attribute"(type_obj, $P820)
    get_how $P821, type_obj
    get_hll_global $P822, "KnowHOWAttribute"
    $P823 = $P822."new"("%!method-vtable-slots" :named("name"))
    $P821."add_attribute"(type_obj, $P823)
    get_how $P824, type_obj
    get_hll_global $P825, "KnowHOWAttribute"
    $P826 = $P825."new"("$!composed" :named("name"))
    $P824."add_attribute"(type_obj, $P826)
    get_how $P827, type_obj
    get_hll_global $P828, "KnowHOWAttribute"
    $P829 = $P828."new"("@!mro" :named("name"))
    $P827."add_attribute"(type_obj, $P829)
    get_how $P830, type_obj
    get_hll_global $P831, "KnowHOWAttribute"
    $P832 = $P831."new"("@!done" :named("name"))
    $P830."add_attribute"(type_obj, $P832)
    get_how $P833, type_obj
    .const 'Sub' $P834 = "26_1295994641.609" 
    $P833."add_method"(type_obj, "new", $P834)
    get_how $P835, type_obj
    .const 'Sub' $P836 = "27_1295994641.609" 
    $P835."add_method"(type_obj, "BUILD", $P836)
    get_how $P837, type_obj
    .const 'Sub' $P838 = "28_1295994641.609" 
    $P837."add_method"(type_obj, "new_type", $P838)
    get_how $P839, type_obj
    .const 'Sub' $P840 = "29_1295994641.609" 
    $P839."add_method"(type_obj, "add_method", $P840)
    get_how $P841, type_obj
    .const 'Sub' $P842 = "30_1295994641.609" 
    $P841."add_method"(type_obj, "add_multi_method", $P842)
    get_how $P843, type_obj
    .const 'Sub' $P844 = "31_1295994641.609" 
    $P843."add_method"(type_obj, "add_attribute", $P844)
    get_how $P845, type_obj
    .const 'Sub' $P846 = "32_1295994641.609" 
    $P845."add_method"(type_obj, "add_parent", $P846)
    get_how $P847, type_obj
    .const 'Sub' $P848 = "34_1295994641.609" 
    $P847."add_method"(type_obj, "compose", $P848)
    get_how $P849, type_obj
    .const 'Sub' $P850 = "35_1295994641.609" 
    $P849."add_method"(type_obj, "incorporate_multi_candidates", $P850)
    get_how $P851, type_obj
    .const 'Sub' $P852 = "40_1295994641.609" 
    $P851."add_method"(type_obj, "publish_type_cache", $P852)
    get_how $P853, type_obj
    .const 'Sub' $P854 = "41_1295994641.609" 
    $P853."add_method"(type_obj, "publish_method_cache", $P854)
    get_how $P855, type_obj
    .const 'Sub' $P856 = "44_1295994641.609" 
    $P855."add_method"(type_obj, "parents", $P856)
    get_how $P857, type_obj
    .const 'Sub' $P858 = "45_1295994641.609" 
    $P857."add_method"(type_obj, "roles", $P858)
    get_how $P859, type_obj
    .const 'Sub' $P860 = "46_1295994641.609" 
    $P859."add_method"(type_obj, "methods", $P860)
    get_how $P861, type_obj
    .const 'Sub' $P862 = "48_1295994641.609" 
    $P861."add_method"(type_obj, "method_table", $P862)
    get_how $P863, type_obj
    .const 'Sub' $P864 = "49_1295994641.609" 
    $P863."add_method"(type_obj, "name", $P864)
    get_how $P865, type_obj
    .const 'Sub' $P866 = "50_1295994641.609" 
    $P865."add_method"(type_obj, "attributes", $P866)
    get_how $P867, type_obj
    .const 'Sub' $P868 = "52_1295994641.609" 
    $P867."add_method"(type_obj, "isa", $P868)
    get_how $P869, type_obj
    .const 'Sub' $P870 = "53_1295994641.609" 
    $P869."add_method"(type_obj, "does", $P870)
    get_how $P871, type_obj
    .const 'Sub' $P872 = "54_1295994641.609" 
    $P871."add_method"(type_obj, "can", $P872)
    get_how $P873, type_obj
    .const 'Sub' $P874 = "56_1295994641.609" 
    $P873."add_method"(type_obj, "find_method", $P874)
    get_how $P875, type_obj
    $P876 = $P875."compose"(type_obj)
    .return ($P876)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_49
.annotate 'line', 196
    .const 'Sub' $P61 = "17_1295994641.609" 
    capture_lex $P61
    new $P48, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P48, control_47
    push_eh $P48
    .lex "$class", param_49
.annotate 'line', 197
    $P50 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P50
.annotate 'line', 200
    $P51 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P51
.annotate 'line', 197
    find_lex $P52, "$class"
    get_how $P53, $P52
    find_lex $P54, "$class"
    $P55 = $P53."parents"($P54, 1 :named("local"))
    store_lex "@immediate_parents", $P55
    find_lex $P56, "@result"
.annotate 'line', 201
    find_lex $P58, "@immediate_parents"
    set $N59, $P58
    unless $N59, if_57_end
    .const 'Sub' $P61 = "17_1295994641.609" 
    capture_lex $P61
    $P61()
  if_57_end:
.annotate 'line', 213
    find_lex $P82, "@result"
    find_lex $P83, "$class"
    $P82."unshift"($P83)
.annotate 'line', 214
    new $P84, "Exception"
    set $P84['type'], .CONTROL_RETURN
    find_lex $P85, "@result"
    setattribute $P84, 'payload', $P85
    throw $P84
.annotate 'line', 196
    .return ()
  control_47:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P86, exception, "payload"
    .return ($P86)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block60"  :anon :subid("17_1295994641.609") :outer("16_1295994641.609")
.annotate 'line', 201
    .const 'Sub' $P69 = "18_1295994641.609" 
    capture_lex $P69
.annotate 'line', 204
    $P62 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P62
.annotate 'line', 201
    find_lex $P63, "@merge_list"
.annotate 'line', 205
    find_lex $P65, "@immediate_parents"
    defined $I66, $P65
    unless $I66, for_undef_74
    iter $P64, $P65
    new $P76, 'ExceptionHandler'
    set_addr $P76, loop75_handler
    $P76."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P76
  loop75_test:
    unless $P64, loop75_done
    shift $P67, $P64
  loop75_redo:
    .const 'Sub' $P69 = "18_1295994641.609" 
    capture_lex $P69
    $P69($P67)
  loop75_next:
    goto loop75_test
  loop75_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P77, exception, 'type'
    eq $P77, .CONTROL_LOOP_NEXT, loop75_next
    eq $P77, .CONTROL_LOOP_REDO, loop75_redo
  loop75_done:
    pop_eh 
  for_undef_74:
.annotate 'line', 208
    find_lex $P78, "@merge_list"
    find_lex $P79, "@immediate_parents"
    $P78."push"($P79)
.annotate 'line', 209
    find_lex $P80, "@merge_list"
    $P81 = "c3_merge"($P80)
    store_lex "@result", $P81
.annotate 'line', 201
    .return ($P81)
.end


.namespace ["NQPClassHOW"]
.sub "_block68"  :anon :subid("18_1295994641.609") :outer("17_1295994641.609")
    .param pmc param_70
.annotate 'line', 205
    .lex "$_", param_70
.annotate 'line', 206
    find_lex $P71, "@merge_list"
    find_lex $P72, "$_"
    $P73 = "compute_c3_mro"($P72)
    $P74 = $P71."push"($P73)
.annotate 'line', 205
    .return ($P74)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_91
.annotate 'line', 218
    .const 'Sub' $P184 = "24_1295994641.609" 
    capture_lex $P184
    .const 'Sub' $P106 = "20_1295994641.609" 
    capture_lex $P106
    new $P90, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P90, control_89
    push_eh $P90
    .lex "@merge_list", param_91
.annotate 'line', 219
    $P92 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P92
.annotate 'line', 220
    new $P93, "Undef"
    .lex "$accepted", $P93
.annotate 'line', 221
    new $P94, "Undef"
    .lex "$something_accepted", $P94
.annotate 'line', 222
    new $P95, "Undef"
    .lex "$cand_count", $P95
.annotate 'line', 265
    new $P96, "Undef"
    .lex "$i", $P96
.annotate 'line', 218
    find_lex $P97, "@result"
    find_lex $P98, "$accepted"
.annotate 'line', 221
    new $P99, "Integer"
    assign $P99, 0
    store_lex "$something_accepted", $P99
.annotate 'line', 222
    new $P100, "Integer"
    assign $P100, 0
    store_lex "$cand_count", $P100
.annotate 'line', 225
    find_lex $P102, "@merge_list"
    defined $I103, $P102
    unless $I103, for_undef_75
    iter $P101, $P102
    new $P167, 'ExceptionHandler'
    set_addr $P167, loop166_handler
    $P167."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P167
  loop166_test:
    unless $P101, loop166_done
    shift $P104, $P101
  loop166_redo:
    .const 'Sub' $P106 = "20_1295994641.609" 
    capture_lex $P106
    $P106($P104)
  loop166_next:
    goto loop166_test
  loop166_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P168, exception, 'type'
    eq $P168, .CONTROL_LOOP_NEXT, loop166_next
    eq $P168, .CONTROL_LOOP_REDO, loop166_redo
  loop166_done:
    pop_eh 
  for_undef_75:
.annotate 'line', 255
    find_lex $P170, "$cand_count"
    set $N171, $P170
    iseq $I172, $N171, 0.0
    unless $I172, if_169_end
.annotate 'line', 256
    new $P173, "Exception"
    set $P173['type'], .CONTROL_RETURN
    find_lex $P174, "@result"
    setattribute $P173, 'payload', $P174
    throw $P173
  if_169_end:
.annotate 'line', 260
    find_lex $P176, "$something_accepted"
    if $P176, unless_175_end
.annotate 'line', 261
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_175_end:
.annotate 'line', 265
    new $P177, "Integer"
    assign $P177, 0
    store_lex "$i", $P177
.annotate 'line', 266
    new $P215, 'ExceptionHandler'
    set_addr $P215, loop214_handler
    $P215."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P215
  loop214_test:
    find_lex $P178, "$i"
    set $N179, $P178
    find_lex $P180, "@merge_list"
    set $N181, $P180
    islt $I182, $N179, $N181
    unless $I182, loop214_done
  loop214_redo:
    .const 'Sub' $P184 = "24_1295994641.609" 
    capture_lex $P184
    $P184()
  loop214_next:
    goto loop214_test
  loop214_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P216, exception, 'type'
    eq $P216, .CONTROL_LOOP_NEXT, loop214_next
    eq $P216, .CONTROL_LOOP_REDO, loop214_redo
  loop214_done:
    pop_eh 
.annotate 'line', 279
    find_lex $P217, "@merge_list"
    $P218 = "c3_merge"($P217)
    store_lex "@result", $P218
.annotate 'line', 280
    find_lex $P219, "@result"
    find_lex $P220, "$accepted"
    $P219."unshift"($P220)
.annotate 'line', 281
    new $P221, "Exception"
    set $P221['type'], .CONTROL_RETURN
    find_lex $P222, "@result"
    setattribute $P221, 'payload', $P222
    throw $P221
.annotate 'line', 218
    .return ()
  control_89:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P223, exception, "payload"
    .return ($P223)
.end


.namespace ["NQPClassHOW"]
.sub "_block105"  :anon :subid("20_1295994641.609") :outer("19_1295994641.609")
    .param pmc param_108
.annotate 'line', 225
    .const 'Sub' $P115 = "21_1295994641.609" 
    capture_lex $P115
.annotate 'line', 226
    $P107 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P107
    .lex "$_", param_108
    find_lex $P109, "$_"
    store_lex "@cand_list", $P109
.annotate 'line', 227
    find_lex $P112, "@cand_list"
    set $N113, $P112
    if $N113, if_111
    new $P110, 'Float'
    set $P110, $N113
    goto if_111_end
  if_111:
    .const 'Sub' $P115 = "21_1295994641.609" 
    capture_lex $P115
    $P165 = $P115()
    set $P110, $P165
  if_111_end:
.annotate 'line', 225
    .return ($P110)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block114"  :anon :subid("21_1295994641.609") :outer("20_1295994641.609")
.annotate 'line', 227
    .const 'Sub' $P128 = "22_1295994641.609" 
    capture_lex $P128
.annotate 'line', 228
    new $P116, "Undef"
    .lex "$rejected", $P116
.annotate 'line', 229
    new $P117, "Undef"
    .lex "$cand_class", $P117
.annotate 'line', 228
    new $P118, "Integer"
    assign $P118, 0
    store_lex "$rejected", $P118
.annotate 'line', 229
    find_lex $P119, "@cand_list"
    unless_null $P119, vivify_76
    $P119 = root_new ['parrot';'ResizablePMCArray']
  vivify_76:
    set $P120, $P119[0]
    unless_null $P120, vivify_77
    new $P120, "Undef"
  vivify_77:
    store_lex "$cand_class", $P120
.annotate 'line', 230
    find_lex $P121, "$cand_count"
    add $P122, $P121, 1
    store_lex "$cand_count", $P122
.annotate 'line', 231
    find_lex $P124, "@merge_list"
    defined $I125, $P124
    unless $I125, for_undef_78
    iter $P123, $P124
    new $P163, 'ExceptionHandler'
    set_addr $P163, loop162_handler
    $P163."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P163
  loop162_test:
    unless $P123, loop162_done
    shift $P126, $P123
  loop162_redo:
    .const 'Sub' $P128 = "22_1295994641.609" 
    capture_lex $P128
    $P128($P126)
  loop162_next:
    goto loop162_test
  loop162_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P164, exception, 'type'
    eq $P164, .CONTROL_LOOP_NEXT, loop162_next
    eq $P164, .CONTROL_LOOP_REDO, loop162_redo
  loop162_done:
    pop_eh 
  for_undef_78:
.annotate 'line', 227
    .return ($P123)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block127"  :anon :subid("22_1295994641.609") :outer("21_1295994641.609")
    .param pmc param_129
.annotate 'line', 231
    .const 'Sub' $P135 = "23_1295994641.609" 
    capture_lex $P135
    .lex "$_", param_129
.annotate 'line', 233
    find_lex $P131, "$_"
    find_lex $P132, "@cand_list"
    issame $I133, $P131, $P132
    if $I133, unless_130_end
    .const 'Sub' $P135 = "23_1295994641.609" 
    capture_lex $P135
    $P135()
  unless_130_end:
.annotate 'line', 245
    find_lex $P158, "$rejected"
    unless $P158, unless_157
    set $P156, $P158
    goto unless_157_end
  unless_157:
.annotate 'line', 246
    find_lex $P159, "$cand_class"
    store_lex "$accepted", $P159
.annotate 'line', 247
    new $P160, "Integer"
    assign $P160, 1
    store_lex "$something_accepted", $P160
.annotate 'line', 248
    set $I161, .CONTROL_LOOP_LAST
    die 0, $I161
  unless_157_end:
.annotate 'line', 231
    .return ($P156)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block134"  :anon :subid("23_1295994641.609") :outer("22_1295994641.609")
.annotate 'line', 235
    new $P136, "Undef"
    .lex "$cur_pos", $P136
    new $P137, "Integer"
    assign $P137, 1
    store_lex "$cur_pos", $P137
.annotate 'line', 236
    new $P154, 'ExceptionHandler'
    set_addr $P154, loop153_handler
    $P154."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P154
  loop153_test:
    find_lex $P138, "$cur_pos"
    set $N139, $P138
    find_lex $P140, "$_"
    set $N141, $P140
    isle $I142, $N139, $N141
    unless $I142, loop153_done
  loop153_redo:
.annotate 'line', 237
    find_lex $P144, "$cur_pos"
    set $I145, $P144
    find_lex $P146, "$_"
    unless_null $P146, vivify_79
    $P146 = root_new ['parrot';'ResizablePMCArray']
  vivify_79:
    set $P147, $P146[$I145]
    unless_null $P147, vivify_80
    new $P147, "Undef"
  vivify_80:
    find_lex $P148, "$cand_class"
    issame $I149, $P147, $P148
    unless $I149, if_143_end
.annotate 'line', 238
    new $P150, "Integer"
    assign $P150, 1
    store_lex "$rejected", $P150
  if_143_end:
.annotate 'line', 240
    find_lex $P151, "$cur_pos"
    add $P152, $P151, 1
    store_lex "$cur_pos", $P152
  loop153_next:
.annotate 'line', 236
    goto loop153_test
  loop153_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P155, exception, 'type'
    eq $P155, .CONTROL_LOOP_NEXT, loop153_next
    eq $P155, .CONTROL_LOOP_REDO, loop153_redo
  loop153_done:
    pop_eh 
.annotate 'line', 233
    .return ($I142)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block183"  :anon :subid("24_1295994641.609") :outer("19_1295994641.609")
.annotate 'line', 266
    .const 'Sub' $P195 = "25_1295994641.609" 
    capture_lex $P195
.annotate 'line', 267
    $P185 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P185
.annotate 'line', 266
    find_lex $P186, "@new_list"
.annotate 'line', 268
    find_lex $P188, "$i"
    set $I189, $P188
    find_lex $P190, "@merge_list"
    unless_null $P190, vivify_81
    $P190 = root_new ['parrot';'ResizablePMCArray']
  vivify_81:
    set $P191, $P190[$I189]
    unless_null $P191, vivify_82
    new $P191, "Undef"
  vivify_82:
    defined $I192, $P191
    unless $I192, for_undef_83
    iter $P187, $P191
    new $P206, 'ExceptionHandler'
    set_addr $P206, loop205_handler
    $P206."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P206
  loop205_test:
    unless $P187, loop205_done
    shift $P193, $P187
  loop205_redo:
    .const 'Sub' $P195 = "25_1295994641.609" 
    capture_lex $P195
    $P195($P193)
  loop205_next:
    goto loop205_test
  loop205_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P207, exception, 'type'
    eq $P207, .CONTROL_LOOP_NEXT, loop205_next
    eq $P207, .CONTROL_LOOP_REDO, loop205_redo
  loop205_done:
    pop_eh 
  for_undef_83:
.annotate 'line', 273
    find_lex $P208, "@new_list"
    find_lex $P209, "$i"
    set $I210, $P209
    find_lex $P211, "@merge_list"
    unless_null $P211, vivify_84
    $P211 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P211
  vivify_84:
    set $P211[$I210], $P208
.annotate 'line', 274
    find_lex $P212, "$i"
    add $P213, $P212, 1
    store_lex "$i", $P213
.annotate 'line', 266
    .return ($P213)
.end


.namespace ["NQPClassHOW"]
.sub "_block194"  :anon :subid("25_1295994641.609") :outer("24_1295994641.609")
    .param pmc param_196
.annotate 'line', 268
    .lex "$_", param_196
.annotate 'line', 269
    find_lex $P199, "$_"
    find_lex $P200, "$accepted"
    issame $I201, $P199, $P200
    unless $I201, unless_198
    new $P197, 'Integer'
    set $P197, $I201
    goto unless_198_end
  unless_198:
.annotate 'line', 270
    find_lex $P202, "@new_list"
    find_lex $P203, "$_"
    $P204 = $P202."push"($P203)
.annotate 'line', 269
    set $P197, $P204
  unless_198_end:
.annotate 'line', 268
    .return ($P197)
.end


.namespace ["NQPClassHOW"]
.sub "new"  :subid("26_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_226
    .param pmc param_227 :optional :named("name")
    .param int has_param_227 :opt_flag
.annotate 'line', 59
    .lex "self", param_226
    if has_param_227, optparam_85
    new $P228, "Undef"
    set param_227, $P228
  optparam_85:
    .lex "$name", param_227
.annotate 'line', 60
    new $P229, "Undef"
    .lex "$obj", $P229
    find_lex $P230, "self"
    repr_instance_of $P231, $P230
    store_lex "$obj", $P231
.annotate 'line', 61
    find_lex $P232, "$obj"
    find_lex $P233, "$name"
    $P232."BUILD"($P233 :named("name"))
    find_lex $P234, "$obj"
.annotate 'line', 59
    .return ($P234)
.end


.namespace ["NQPClassHOW"]
.sub "BUILD"  :subid("27_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_236
    .param pmc param_237 :optional :named("name")
    .param int has_param_237 :opt_flag
.annotate 'line', 65
    .lex "self", param_236
    if has_param_237, optparam_86
    new $P238, "Undef"
    set param_237, $P238
  optparam_86:
    .lex "$name", param_237
.annotate 'line', 66
    find_lex $P239, "$name"
    find_lex $P240, "self"
    get_global $P241, "$?CLASS"
    setattribute $P240, $P241, "$!name", $P239
.annotate 'line', 65
    .return ($P239)
.end


.namespace ["NQPClassHOW"]
.sub "new_type"  :subid("28_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_243
    .param pmc param_244 :optional :named("name")
    .param int has_param_244 :opt_flag
    .param pmc param_246 :optional :named("repr")
    .param int has_param_246 :opt_flag
.annotate 'line', 71
    .lex "self", param_243
    if has_param_244, optparam_87
    new $P245, "String"
    assign $P245, "<anon>"
    set param_244, $P245
  optparam_87:
    .lex "$name", param_244
    if has_param_246, optparam_88
    new $P247, "String"
    assign $P247, "P6opaque"
    set param_246, $P247
  optparam_88:
    .lex "$repr", param_246
.annotate 'line', 72
    new $P248, "Undef"
    .lex "$metaclass", $P248
    find_lex $P249, "self"
    find_lex $P250, "$name"
    $P251 = $P249."new"($P250 :named("name"))
    store_lex "$metaclass", $P251
.annotate 'line', 73
    find_lex $P252, "$metaclass"
    find_lex $P253, "$repr"
    set $S254, $P253
    repr_type_object_for $P255, $P252, $S254
.annotate 'line', 71
    .return ($P255)
.end


.namespace ["NQPClassHOW"]
.sub "add_method"  :subid("29_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_257
    .param pmc param_258
    .param pmc param_259
    .param pmc param_260
.annotate 'line', 76
    .lex "self", param_257
    .lex "$obj", param_258
    .lex "$name", param_259
    .lex "$code_obj", param_260
.annotate 'line', 77
    find_lex $P262, "$name"
    find_lex $P263, "self"
    get_global $P264, "$?CLASS"
    getattribute $P265, $P263, $P264, "%!methods"
    unless_null $P265, vivify_89
    $P265 = root_new ['parrot';'Hash']
  vivify_89:
    set $P266, $P265[$P262]
    unless_null $P266, vivify_90
    new $P266, "Undef"
  vivify_90:
    unless $P266, if_261_end
.annotate 'line', 78
    new $P267, "String"
    assign $P267, "This class already has a method named "
    find_lex $P268, "$name"
    concat $P269, $P267, $P268
    die $P269
  if_261_end:
.annotate 'line', 80
    find_lex $P270, "$code_obj"
    find_lex $P271, "$name"
    find_lex $P272, "self"
    get_global $P273, "$?CLASS"
    getattribute $P274, $P272, $P273, "%!methods"
    unless_null $P274, vivify_91
    $P274 = root_new ['parrot';'Hash']
    setattribute $P272, $P273, "%!methods", $P274
  vivify_91:
    set $P274[$P271], $P270
.annotate 'line', 76
    .return ($P270)
.end


.namespace ["NQPClassHOW"]
.sub "add_multi_method"  :subid("30_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_276
    .param pmc param_277
    .param pmc param_278
    .param pmc param_279
.annotate 'line', 83
    .lex "self", param_276
    .lex "$obj", param_277
    .lex "$name", param_278
    .lex "$code_obj", param_279
.annotate 'line', 89
    $P280 = root_new ['parrot';'Hash']
    .lex "%todo", $P280
.annotate 'line', 83
    find_lex $P281, "%todo"
.annotate 'line', 90
    find_lex $P282, "$name"
    find_lex $P283, "%todo"
    unless_null $P283, vivify_92
    $P283 = root_new ['parrot';'Hash']
    store_lex "%todo", $P283
  vivify_92:
    set $P283["name"], $P282
.annotate 'line', 91
    find_lex $P284, "$code_obj"
    find_lex $P285, "%todo"
    unless_null $P285, vivify_93
    $P285 = root_new ['parrot';'Hash']
    store_lex "%todo", $P285
  vivify_93:
    set $P285["code"], $P284
.annotate 'line', 92
    find_lex $P286, "%todo"
    find_lex $P287, "self"
    get_global $P288, "$?CLASS"
    getattribute $P289, $P287, $P288, "@!multi_methods_to_incorporate"
    unless_null $P289, vivify_94
    $P289 = root_new ['parrot';'ResizablePMCArray']
  vivify_94:
    set $N290, $P289
    set $I291, $N290
    find_lex $P292, "self"
    get_global $P293, "$?CLASS"
    getattribute $P294, $P292, $P293, "@!multi_methods_to_incorporate"
    unless_null $P294, vivify_95
    $P294 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P292, $P293, "@!multi_methods_to_incorporate", $P294
  vivify_95:
    set $P294[$I291], $P286
    find_lex $P295, "$code_obj"
.annotate 'line', 83
    .return ($P295)
.end


.namespace ["NQPClassHOW"]
.sub "add_attribute"  :subid("31_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_297
    .param pmc param_298
    .param pmc param_299
.annotate 'line', 96
    .lex "self", param_297
    .lex "$obj", param_298
    .lex "$meta_attr", param_299
.annotate 'line', 97
    new $P300, "Undef"
    .lex "$name", $P300
    find_lex $P301, "$meta_attr"
    $P302 = $P301."name"()
    store_lex "$name", $P302
.annotate 'line', 98
    find_lex $P304, "$name"
    find_lex $P305, "self"
    get_global $P306, "$?CLASS"
    getattribute $P307, $P305, $P306, "%!attributes"
    unless_null $P307, vivify_96
    $P307 = root_new ['parrot';'Hash']
  vivify_96:
    set $P308, $P307[$P304]
    unless_null $P308, vivify_97
    new $P308, "Undef"
  vivify_97:
    unless $P308, if_303_end
.annotate 'line', 99
    new $P309, "String"
    assign $P309, "This class already has an attribute named "
    find_lex $P310, "$name"
    concat $P311, $P309, $P310
    die $P311
  if_303_end:
.annotate 'line', 101
    find_lex $P312, "$meta_attr"
    find_lex $P313, "$name"
    find_lex $P314, "self"
    get_global $P315, "$?CLASS"
    getattribute $P316, $P314, $P315, "%!attributes"
    unless_null $P316, vivify_98
    $P316 = root_new ['parrot';'Hash']
    setattribute $P314, $P315, "%!attributes", $P316
  vivify_98:
    set $P316[$P313], $P312
.annotate 'line', 96
    .return ($P312)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_318
    .param pmc param_319
    .param pmc param_320
.annotate 'line', 104
    .const 'Sub' $P332 = "33_1295994641.609" 
    capture_lex $P332
    .lex "self", param_318
    .lex "$obj", param_319
    .lex "$parent", param_320
.annotate 'line', 105
    find_lex $P322, "self"
    get_global $P323, "$?CLASS"
    getattribute $P324, $P322, $P323, "$!composed"
    unless_null $P324, vivify_99
    new $P324, "Undef"
  vivify_99:
    unless $P324, if_321_end
.annotate 'line', 106
    die "NQPClassHOW does not support adding parents after being composed."
  if_321_end:
.annotate 'line', 108
    find_lex $P326, "self"
    get_global $P327, "$?CLASS"
    getattribute $P328, $P326, $P327, "@!parents"
    unless_null $P328, vivify_100
    $P328 = root_new ['parrot';'ResizablePMCArray']
  vivify_100:
    defined $I329, $P328
    unless $I329, for_undef_101
    iter $P325, $P328
    new $P344, 'ExceptionHandler'
    set_addr $P344, loop343_handler
    $P344."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P344
  loop343_test:
    unless $P325, loop343_done
    shift $P330, $P325
  loop343_redo:
    .const 'Sub' $P332 = "33_1295994641.609" 
    capture_lex $P332
    $P332($P330)
  loop343_next:
    goto loop343_test
  loop343_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P345, exception, 'type'
    eq $P345, .CONTROL_LOOP_NEXT, loop343_next
    eq $P345, .CONTROL_LOOP_REDO, loop343_redo
  loop343_done:
    pop_eh 
  for_undef_101:
.annotate 'line', 113
    find_lex $P346, "$parent"
    find_lex $P347, "self"
    get_global $P348, "$?CLASS"
    getattribute $P349, $P347, $P348, "@!parents"
    unless_null $P349, vivify_102
    $P349 = root_new ['parrot';'ResizablePMCArray']
  vivify_102:
    set $N350, $P349
    set $I351, $N350
    find_lex $P352, "self"
    get_global $P353, "$?CLASS"
    getattribute $P354, $P352, $P353, "@!parents"
    unless_null $P354, vivify_103
    $P354 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P352, $P353, "@!parents", $P354
  vivify_103:
    set $P354[$I351], $P346
.annotate 'line', 104
    .return ($P346)
.end


.namespace ["NQPClassHOW"]
.sub "_block331"  :anon :subid("33_1295994641.609") :outer("32_1295994641.609")
    .param pmc param_333
.annotate 'line', 108
    .lex "$_", param_333
.annotate 'line', 109
    find_lex $P336, "$_"
    find_lex $P337, "$parent"
    issame $I338, $P336, $P337
    if $I338, if_335
    new $P334, 'Integer'
    set $P334, $I338
    goto if_335_end
  if_335:
.annotate 'line', 110
    new $P339, "String"
    assign $P339, "Already have "
    find_lex $P340, "$parent"
    concat $P341, $P339, $P340
    concat $P342, $P341, " as a parent class."
    die $P342
  if_335_end:
.annotate 'line', 108
    .return ($P334)
.end


.namespace ["NQPClassHOW"]
.sub "compose"  :subid("34_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_356
    .param pmc param_357
.annotate 'line', 116
    .lex "self", param_356
    .lex "$obj", param_357
.annotate 'line', 121
    find_lex $P361, "self"
    get_global $P362, "$?CLASS"
    getattribute $P363, $P361, $P362, "@!parents"
    unless_null $P363, vivify_104
    $P363 = root_new ['parrot';'ResizablePMCArray']
  vivify_104:
    set $N364, $P363
    iseq $I365, $N364, 0.0
    if $I365, if_360
    new $P359, 'Integer'
    set $P359, $I365
    goto if_360_end
  if_360:
    find_lex $P366, "self"
    get_global $P367, "$?CLASS"
    getattribute $P368, $P366, $P367, "$!name"
    unless_null $P368, vivify_105
    new $P368, "Undef"
  vivify_105:
    set $S369, $P368
    isne $I370, $S369, "NQPMu"
    new $P359, 'Integer'
    set $P359, $I370
  if_360_end:
    unless $P359, if_358_end
.annotate 'line', 122
    find_lex $P371, "self"
    find_lex $P372, "$obj"
    get_hll_global $P373, "NQPMu"
    $P371."add_parent"($P372, $P373)
  if_358_end:
.annotate 'line', 127
    find_lex $P375, "self"
    get_global $P376, "$?CLASS"
    getattribute $P377, $P375, $P376, "$!composed"
    unless_null $P377, vivify_106
    new $P377, "Undef"
  vivify_106:
    if $P377, unless_374_end
.annotate 'line', 128
    find_lex $P378, "$obj"
    $P379 = "compute_c3_mro"($P378)
    find_lex $P380, "self"
    get_global $P381, "$?CLASS"
    setattribute $P380, $P381, "@!mro", $P379
.annotate 'line', 129
    new $P382, "Integer"
    assign $P382, 1
    find_lex $P383, "self"
    get_global $P384, "$?CLASS"
    setattribute $P383, $P384, "$!composed", $P382
  unless_374_end:
.annotate 'line', 133
    find_lex $P385, "self"
    find_lex $P386, "$obj"
    $P385."incorporate_multi_candidates"($P386)
.annotate 'line', 136
    find_lex $P387, "self"
    find_lex $P388, "$obj"
    $P387."publish_type_cache"($P388)
.annotate 'line', 137
    find_lex $P389, "self"
    find_lex $P390, "$obj"
    $P389."publish_method_cache"($P390)
    find_lex $P391, "$obj"
.annotate 'line', 116
    .return ($P391)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("35_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_393
    .param pmc param_394
.annotate 'line', 142
    .const 'Sub' $P409 = "36_1295994641.609" 
    capture_lex $P409
    .lex "self", param_393
    .lex "$obj", param_394
.annotate 'line', 143
    new $P395, "Undef"
    .lex "$num_todo", $P395
.annotate 'line', 144
    new $P396, "Undef"
    .lex "$i", $P396
.annotate 'line', 143
    find_lex $P397, "self"
    get_global $P398, "$?CLASS"
    getattribute $P399, $P397, $P398, "@!multi_methods_to_incorporate"
    unless_null $P399, vivify_107
    $P399 = root_new ['parrot';'ResizablePMCArray']
  vivify_107:
    set $N400, $P399
    new $P401, 'Float'
    set $P401, $N400
    store_lex "$num_todo", $P401
.annotate 'line', 144
    new $P402, "Integer"
    assign $P402, 0
    store_lex "$i", $P402
.annotate 'line', 145
    new $P518, 'ExceptionHandler'
    set_addr $P518, loop517_handler
    $P518."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P518
  loop517_test:
    find_lex $P403, "$i"
    set $N404, $P403
    find_lex $P405, "$num_todo"
    set $N406, $P405
    isne $I407, $N404, $N406
    unless $I407, loop517_done
  loop517_redo:
    .const 'Sub' $P409 = "36_1295994641.609" 
    capture_lex $P409
    $P409()
  loop517_next:
    goto loop517_test
  loop517_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P519, exception, 'type'
    eq $P519, .CONTROL_LOOP_NEXT, loop517_next
    eq $P519, .CONTROL_LOOP_REDO, loop517_redo
  loop517_done:
    pop_eh 
.annotate 'line', 142
    .return ($I407)
.end


.namespace ["NQPClassHOW"]
.sub "_block408"  :anon :subid("36_1295994641.609") :outer("35_1295994641.609")
.annotate 'line', 145
    .const 'Sub' $P445 = "37_1295994641.609" 
    capture_lex $P445
.annotate 'line', 147
    new $P410, "Undef"
    .lex "$name", $P410
.annotate 'line', 148
    new $P411, "Undef"
    .lex "$code", $P411
.annotate 'line', 152
    new $P412, "Undef"
    .lex "$dispatcher", $P412
.annotate 'line', 147
    find_lex $P413, "$i"
    set $I414, $P413
    find_lex $P415, "self"
    get_global $P416, "$?CLASS"
    getattribute $P417, $P415, $P416, "@!multi_methods_to_incorporate"
    unless_null $P417, vivify_108
    $P417 = root_new ['parrot';'ResizablePMCArray']
  vivify_108:
    set $P418, $P417[$I414]
    unless_null $P418, vivify_109
    $P418 = root_new ['parrot';'Hash']
  vivify_109:
    set $P419, $P418["name"]
    unless_null $P419, vivify_110
    new $P419, "Undef"
  vivify_110:
    store_lex "$name", $P419
.annotate 'line', 148
    find_lex $P420, "$i"
    set $I421, $P420
    find_lex $P422, "self"
    get_global $P423, "$?CLASS"
    getattribute $P424, $P422, $P423, "@!multi_methods_to_incorporate"
    unless_null $P424, vivify_111
    $P424 = root_new ['parrot';'ResizablePMCArray']
  vivify_111:
    set $P425, $P424[$I421]
    unless_null $P425, vivify_112
    $P425 = root_new ['parrot';'Hash']
  vivify_112:
    set $P426, $P425["code"]
    unless_null $P426, vivify_113
    new $P426, "Undef"
  vivify_113:
    store_lex "$code", $P426
.annotate 'line', 152
    find_lex $P427, "$name"
    find_lex $P428, "self"
    get_global $P429, "$?CLASS"
    getattribute $P430, $P428, $P429, "%!methods"
    unless_null $P430, vivify_114
    $P430 = root_new ['parrot';'Hash']
  vivify_114:
    set $P431, $P430[$P427]
    unless_null $P431, vivify_115
    new $P431, "Undef"
  vivify_115:
    store_lex "$dispatcher", $P431
.annotate 'line', 153
    find_lex $P433, "$dispatcher"
    defined $I434, $P433
    if $I434, if_432
.annotate 'line', 163
    .const 'Sub' $P445 = "37_1295994641.609" 
    capture_lex $P445
    $P445()
    goto if_432_end
  if_432:
.annotate 'line', 156
    find_lex $P436, "$dispatcher"
    is_dispatcher $I437, $P436
    if $I437, if_435
.annotate 'line', 160
    new $P440, 'String'
    set $P440, "Cannot have a multi candidate for "
    find_lex $P441, "$name"
    concat $P442, $P440, $P441
    concat $P443, $P442, " when an only method is also in the class"
    die $P443
.annotate 'line', 159
    goto if_435_end
  if_435:
.annotate 'line', 157
    find_lex $P438, "$dispatcher"
    find_lex $P439, "$code"
    push_dispatchee $P438, $P439
  if_435_end:
  if_432_end:
.annotate 'line', 191
    find_lex $P515, "$i"
    add $P516, $P515, 1
    store_lex "$i", $P516
.annotate 'line', 145
    .return ($P516)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block444"  :anon :subid("37_1295994641.609") :outer("36_1295994641.609")
.annotate 'line', 163
    .const 'Sub' $P462 = "38_1295994641.609" 
    capture_lex $P462
.annotate 'line', 165
    new $P446, "Undef"
    .lex "$j", $P446
.annotate 'line', 166
    new $P447, "Undef"
    .lex "$found", $P447
.annotate 'line', 165
    new $P448, "Integer"
    assign $P448, 1
    store_lex "$j", $P448
.annotate 'line', 166
    new $P449, "Integer"
    assign $P449, 0
    store_lex "$found", $P449
.annotate 'line', 167
    new $P506, 'ExceptionHandler'
    set_addr $P506, loop505_handler
    $P506."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P506
  loop505_test:
    find_lex $P452, "$j"
    set $N453, $P452
    find_lex $P454, "self"
    get_global $P455, "$?CLASS"
    getattribute $P456, $P454, $P455, "@!mro"
    unless_null $P456, vivify_116
    $P456 = root_new ['parrot';'ResizablePMCArray']
  vivify_116:
    set $N457, $P456
    isne $I458, $N453, $N457
    if $I458, if_451
    new $P450, 'Integer'
    set $P450, $I458
    goto if_451_end
  if_451:
    find_lex $P459, "$found"
    isfalse $I460, $P459
    new $P450, 'Integer'
    set $P450, $I460
  if_451_end:
    unless $P450, loop505_done
  loop505_redo:
    .const 'Sub' $P462 = "38_1295994641.609" 
    capture_lex $P462
    $P462()
  loop505_next:
    goto loop505_test
  loop505_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P507, exception, 'type'
    eq $P507, .CONTROL_LOOP_NEXT, loop505_next
    eq $P507, .CONTROL_LOOP_REDO, loop505_redo
  loop505_done:
    pop_eh 
.annotate 'line', 187
    find_lex $P510, "$found"
    unless $P510, unless_509
    set $P508, $P510
    goto unless_509_end
  unless_509:
.annotate 'line', 188
    new $P511, 'String'
    set $P511, "Could not find a proto for multi "
    find_lex $P512, "$name"
    concat $P513, $P511, $P512
    concat $P514, $P513, ", and proto generation is NYI"
    die $P514
  unless_509_end:
.annotate 'line', 163
    .return ($P508)
.end


.namespace ["NQPClassHOW"]
.sub "_block461"  :anon :subid("38_1295994641.609") :outer("37_1295994641.609")
.annotate 'line', 167
    .const 'Sub' $P486 = "39_1295994641.609" 
    capture_lex $P486
.annotate 'line', 168
    new $P463, "Undef"
    .lex "$parent", $P463
.annotate 'line', 169
    $P464 = root_new ['parrot';'Hash']
    .lex "%meths", $P464
.annotate 'line', 170
    new $P465, "Undef"
    .lex "$dispatcher", $P465
.annotate 'line', 168
    find_lex $P466, "$j"
    set $I467, $P466
    find_lex $P468, "self"
    get_global $P469, "$?CLASS"
    getattribute $P470, $P468, $P469, "@!mro"
    unless_null $P470, vivify_117
    $P470 = root_new ['parrot';'ResizablePMCArray']
  vivify_117:
    set $P471, $P470[$I467]
    unless_null $P471, vivify_118
    new $P471, "Undef"
  vivify_118:
    store_lex "$parent", $P471
.annotate 'line', 169
    find_lex $P472, "$parent"
    get_how $P473, $P472
    find_lex $P474, "$parent"
    $P475 = $P473."method_table"($P474)
    store_lex "%meths", $P475
.annotate 'line', 170
    find_lex $P476, "$name"
    find_lex $P477, "%meths"
    unless_null $P477, vivify_119
    $P477 = root_new ['parrot';'Hash']
  vivify_119:
    set $P478, $P477[$P476]
    unless_null $P478, vivify_120
    new $P478, "Undef"
  vivify_120:
    store_lex "$dispatcher", $P478
.annotate 'line', 171
    find_lex $P480, "$dispatcher"
    defined $I481, $P480
    unless $I481, if_479_end
.annotate 'line', 174
    find_lex $P483, "$dispatcher"
    is_dispatcher $I484, $P483
    if $I484, if_482
.annotate 'line', 182
    new $P499, 'String'
    set $P499, "Could not find a proto for multi "
    find_lex $P500, "$name"
    concat $P501, $P499, $P500
    concat $P502, $P501, " (it may exist, but an only is hiding it if so)"
    die $P502
.annotate 'line', 181
    goto if_482_end
  if_482:
.annotate 'line', 174
    .const 'Sub' $P486 = "39_1295994641.609" 
    capture_lex $P486
    $P486()
  if_482_end:
  if_479_end:
.annotate 'line', 185
    find_lex $P503, "$j"
    add $P504, $P503, 1
    store_lex "$j", $P504
.annotate 'line', 167
    .return ($P504)
.end


.namespace ["NQPClassHOW"]
.sub "_block485"  :anon :subid("39_1295994641.609") :outer("38_1295994641.609")
.annotate 'line', 176
    $P487 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P487
.annotate 'line', 174
    find_lex $P488, "@new_dispatchees"
.annotate 'line', 177
    find_lex $P489, "$code"
    find_lex $P490, "@new_dispatchees"
    unless_null $P490, vivify_121
    $P490 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P490
  vivify_121:
    set $P490[0], $P489
.annotate 'line', 178
    find_lex $P491, "$dispatcher"
    find_lex $P492, "@new_dispatchees"
    create_dispatch_and_add_candidates $P493, $P491, $P492
    find_lex $P494, "$name"
    find_lex $P495, "self"
    get_global $P496, "$?CLASS"
    getattribute $P497, $P495, $P496, "%!methods"
    unless_null $P497, vivify_122
    $P497 = root_new ['parrot';'Hash']
    setattribute $P495, $P496, "%!methods", $P497
  vivify_122:
    set $P497[$P494], $P493
.annotate 'line', 179
    new $P498, "Integer"
    assign $P498, 1
    store_lex "$found", $P498
.annotate 'line', 174
    .return ($P498)
.end


.namespace ["NQPClassHOW"]
.sub "publish_type_cache"  :subid("40_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_523
    .param pmc param_524
.annotate 'line', 284
    .lex "self", param_523
    .lex "$obj", param_524
.annotate 'line', 286
    find_lex $P525, "$obj"
    find_lex $P526, "self"
    get_global $P527, "$?CLASS"
    getattribute $P528, $P526, $P527, "@!mro"
    unless_null $P528, vivify_123
    $P528 = root_new ['parrot';'ResizablePMCArray']
  vivify_123:
    publish_type_check_cache $P525, $P528
.annotate 'line', 284
    .return ()
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("41_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_530
    .param pmc param_531
.annotate 'line', 289
    .const 'Sub' $P541 = "42_1295994641.609" 
    capture_lex $P541
    .lex "self", param_530
    .lex "$obj", param_531
.annotate 'line', 292
    $P532 = root_new ['parrot';'Hash']
    .lex "%cache", $P532
.annotate 'line', 289
    find_lex $P533, "%cache"
.annotate 'line', 293
    find_lex $P535, "self"
    get_global $P536, "$?CLASS"
    getattribute $P537, $P535, $P536, "@!mro"
    unless_null $P537, vivify_124
    $P537 = root_new ['parrot';'ResizablePMCArray']
  vivify_124:
    defined $I538, $P537
    unless $I538, for_undef_125
    iter $P534, $P537
    new $P570, 'ExceptionHandler'
    set_addr $P570, loop569_handler
    $P570."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P570
  loop569_test:
    unless $P534, loop569_done
    shift $P539, $P534
  loop569_redo:
    .const 'Sub' $P541 = "42_1295994641.609" 
    capture_lex $P541
    $P541($P539)
  loop569_next:
    goto loop569_test
  loop569_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P571, exception, 'type'
    eq $P571, .CONTROL_LOOP_NEXT, loop569_next
    eq $P571, .CONTROL_LOOP_REDO, loop569_redo
  loop569_done:
    pop_eh 
  for_undef_125:
.annotate 'line', 301
    find_lex $P572, "$obj"
    find_lex $P573, "%cache"
    publish_method_cache $P572, $P573
.annotate 'line', 289
    .return ()
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block540"  :anon :subid("42_1295994641.609") :outer("41_1295994641.609")
    .param pmc param_543
.annotate 'line', 293
    .const 'Sub' $P553 = "43_1295994641.609" 
    capture_lex $P553
.annotate 'line', 294
    $P542 = root_new ['parrot';'Hash']
    .lex "%methods", $P542
    .lex "$_", param_543
    find_lex $P544, "$_"
    get_how $P545, $P544
    find_lex $P546, "$_"
    $P547 = $P545."method_table"($P546)
    store_lex "%methods", $P547
.annotate 'line', 295
    find_lex $P549, "%methods"
    defined $I550, $P549
    unless $I550, for_undef_126
    iter $P548, $P549
    new $P567, 'ExceptionHandler'
    set_addr $P567, loop566_handler
    $P567."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P567
  loop566_test:
    unless $P548, loop566_done
    shift $P551, $P548
  loop566_redo:
    .const 'Sub' $P553 = "43_1295994641.609" 
    capture_lex $P553
    $P553($P551)
  loop566_next:
    goto loop566_test
  loop566_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P568, exception, 'type'
    eq $P568, .CONTROL_LOOP_NEXT, loop566_next
    eq $P568, .CONTROL_LOOP_REDO, loop566_redo
  loop566_done:
    pop_eh 
  for_undef_126:
.annotate 'line', 293
    .return ($P548)
.end


.namespace ["NQPClassHOW"]
.sub "_block552"  :anon :subid("43_1295994641.609") :outer("42_1295994641.609")
    .param pmc param_554
.annotate 'line', 295
    .lex "$_", param_554
.annotate 'line', 296
    find_lex $P557, "$_"
    $P558 = $P557."key"()
    find_lex $P559, "%cache"
    unless_null $P559, vivify_127
    $P559 = root_new ['parrot';'Hash']
  vivify_127:
    set $P560, $P559[$P558]
    unless_null $P560, vivify_128
    new $P560, "Undef"
  vivify_128:
    unless $P560, unless_556
    set $P555, $P560
    goto unless_556_end
  unless_556:
.annotate 'line', 297
    find_lex $P561, "$_"
    $P562 = $P561."value"()
    find_lex $P563, "$_"
    $P564 = $P563."key"()
    find_lex $P565, "%cache"
    unless_null $P565, vivify_129
    $P565 = root_new ['parrot';'Hash']
    store_lex "%cache", $P565
  vivify_129:
    set $P565[$P564], $P562
.annotate 'line', 296
    set $P555, $P562
  unless_556_end:
.annotate 'line', 295
    .return ($P555)
.end


.namespace ["NQPClassHOW"]
.sub "parents"  :subid("44_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_575
    .param pmc param_576
    .param pmc param_577 :optional :named("local")
    .param int has_param_577 :opt_flag
.annotate 'line', 308
    .lex "self", param_575
    .lex "$obj", param_576
    if has_param_577, optparam_130
    new $P578, "Undef"
    set param_577, $P578
  optparam_130:
    .lex "$local", param_577
.annotate 'line', 309
    find_lex $P581, "$local"
    if $P581, if_580
    find_lex $P585, "self"
    get_global $P586, "$?CLASS"
    getattribute $P587, $P585, $P586, "@!mro"
    unless_null $P587, vivify_131
    $P587 = root_new ['parrot';'ResizablePMCArray']
  vivify_131:
    set $P579, $P587
    goto if_580_end
  if_580:
    find_lex $P582, "self"
    get_global $P583, "$?CLASS"
    getattribute $P584, $P582, $P583, "@!parents"
    unless_null $P584, vivify_132
    $P584 = root_new ['parrot';'ResizablePMCArray']
  vivify_132:
    set $P579, $P584
  if_580_end:
.annotate 'line', 308
    .return ($P579)
.end


.namespace ["NQPClassHOW"]
.sub "roles"  :subid("45_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_589
    .param pmc param_590
    .param pmc param_591 :named("local")
.annotate 'line', 312
    .lex "self", param_589
    .lex "$obj", param_590
    .lex "$local", param_591
    find_lex $P592, "self"
    get_global $P593, "$?CLASS"
    getattribute $P594, $P592, $P593, "@!roles"
    unless_null $P594, vivify_133
    $P594 = root_new ['parrot';'ResizablePMCArray']
  vivify_133:
    .return ($P594)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("46_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_596
    .param pmc param_597
    .param pmc param_598 :named("local")
.annotate 'line', 316
    .const 'Sub' $P608 = "47_1295994641.609" 
    capture_lex $P608
    .lex "self", param_596
    .lex "$obj", param_597
    .lex "$local", param_598
.annotate 'line', 317
    $P599 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P599
.annotate 'line', 316
    find_lex $P600, "@meths"
.annotate 'line', 318
    find_lex $P602, "self"
    get_global $P603, "$?CLASS"
    getattribute $P604, $P602, $P603, "%!methods"
    unless_null $P604, vivify_134
    $P604 = root_new ['parrot';'Hash']
  vivify_134:
    defined $I605, $P604
    unless $I605, for_undef_135
    iter $P601, $P604
    new $P615, 'ExceptionHandler'
    set_addr $P615, loop614_handler
    $P615."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P615
  loop614_test:
    unless $P601, loop614_done
    shift $P606, $P601
  loop614_redo:
    .const 'Sub' $P608 = "47_1295994641.609" 
    capture_lex $P608
    $P608($P606)
  loop614_next:
    goto loop614_test
  loop614_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P616, exception, 'type'
    eq $P616, .CONTROL_LOOP_NEXT, loop614_next
    eq $P616, .CONTROL_LOOP_REDO, loop614_redo
  loop614_done:
    pop_eh 
  for_undef_135:
    find_lex $P617, "@meths"
.annotate 'line', 316
    .return ($P617)
.end


.namespace ["NQPClassHOW"]
.sub "_block607"  :anon :subid("47_1295994641.609") :outer("46_1295994641.609")
    .param pmc param_609
.annotate 'line', 318
    .lex "$_", param_609
.annotate 'line', 319
    find_lex $P610, "@meths"
    find_lex $P611, "$_"
    $P612 = $P611."value"()
    $P613 = $P610."push"($P612)
.annotate 'line', 318
    .return ($P613)
.end


.namespace ["NQPClassHOW"]
.sub "method_table"  :subid("48_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_619
    .param pmc param_620
.annotate 'line', 324
    .lex "self", param_619
    .lex "$obj", param_620
    find_lex $P621, "self"
    get_global $P622, "$?CLASS"
    getattribute $P623, $P621, $P622, "%!methods"
    unless_null $P623, vivify_136
    $P623 = root_new ['parrot';'Hash']
  vivify_136:
    .return ($P623)
.end


.namespace ["NQPClassHOW"]
.sub "name"  :subid("49_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_625
    .param pmc param_626
.annotate 'line', 328
    .lex "self", param_625
    .lex "$obj", param_626
    find_lex $P627, "self"
    get_global $P628, "$?CLASS"
    getattribute $P629, $P627, $P628, "$!name"
    unless_null $P629, vivify_137
    new $P629, "Undef"
  vivify_137:
    .return ($P629)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("50_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_631
    .param pmc param_632
    .param pmc param_633 :named("local")
.annotate 'line', 332
    .const 'Sub' $P643 = "51_1295994641.609" 
    capture_lex $P643
    .lex "self", param_631
    .lex "$obj", param_632
    .lex "$local", param_633
.annotate 'line', 333
    $P634 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P634
.annotate 'line', 332
    find_lex $P635, "@attrs"
.annotate 'line', 334
    find_lex $P637, "self"
    get_global $P638, "$?CLASS"
    getattribute $P639, $P637, $P638, "%!attributes"
    unless_null $P639, vivify_138
    $P639 = root_new ['parrot';'Hash']
  vivify_138:
    defined $I640, $P639
    unless $I640, for_undef_139
    iter $P636, $P639
    new $P650, 'ExceptionHandler'
    set_addr $P650, loop649_handler
    $P650."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P650
  loop649_test:
    unless $P636, loop649_done
    shift $P641, $P636
  loop649_redo:
    .const 'Sub' $P643 = "51_1295994641.609" 
    capture_lex $P643
    $P643($P641)
  loop649_next:
    goto loop649_test
  loop649_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P651, exception, 'type'
    eq $P651, .CONTROL_LOOP_NEXT, loop649_next
    eq $P651, .CONTROL_LOOP_REDO, loop649_redo
  loop649_done:
    pop_eh 
  for_undef_139:
    find_lex $P652, "@attrs"
.annotate 'line', 332
    .return ($P652)
.end


.namespace ["NQPClassHOW"]
.sub "_block642"  :anon :subid("51_1295994641.609") :outer("50_1295994641.609")
    .param pmc param_644
.annotate 'line', 334
    .lex "$_", param_644
.annotate 'line', 335
    find_lex $P645, "@attrs"
    find_lex $P646, "$_"
    $P647 = $P646."value"()
    $P648 = $P645."push"($P647)
.annotate 'line', 334
    .return ($P648)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("52_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_656
    .param pmc param_657
    .param pmc param_658
.annotate 'line', 344
    new $P655, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P655, control_654
    push_eh $P655
    .lex "self", param_656
    .lex "$obj", param_657
    .lex "$check", param_658
.annotate 'line', 345
    new $P659, "Undef"
    .lex "$check-class", $P659
.annotate 'line', 346
    new $P660, "Undef"
    .lex "$i", $P660
.annotate 'line', 345
    find_lex $P661, "$check"
    get_what $P662, $P661
    store_lex "$check-class", $P662
.annotate 'line', 346
    find_lex $P663, "self"
    get_global $P664, "$?CLASS"
    getattribute $P665, $P663, $P664, "@!mro"
    unless_null $P665, vivify_140
    $P665 = root_new ['parrot';'ResizablePMCArray']
  vivify_140:
    set $N666, $P665
    new $P667, 'Float'
    set $P667, $N666
    store_lex "$i", $P667
.annotate 'line', 347
    new $P685, 'ExceptionHandler'
    set_addr $P685, loop684_handler
    $P685."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P685
  loop684_test:
    find_lex $P668, "$i"
    set $N669, $P668
    isgt $I670, $N669, 0.0
    unless $I670, loop684_done
  loop684_redo:
.annotate 'line', 348
    find_lex $P671, "$i"
    sub $P672, $P671, 1
    store_lex "$i", $P672
.annotate 'line', 349
    find_lex $P674, "$i"
    set $I675, $P674
    find_lex $P676, "self"
    get_global $P677, "$?CLASS"
    getattribute $P678, $P676, $P677, "@!mro"
    unless_null $P678, vivify_141
    $P678 = root_new ['parrot';'ResizablePMCArray']
  vivify_141:
    set $P679, $P678[$I675]
    unless_null $P679, vivify_142
    new $P679, "Undef"
  vivify_142:
    find_lex $P680, "$check-class"
    issame $I681, $P679, $P680
    unless $I681, if_673_end
.annotate 'line', 350
    new $P682, "Exception"
    set $P682['type'], .CONTROL_RETURN
    new $P683, "Integer"
    assign $P683, 1
    setattribute $P682, 'payload', $P683
    throw $P682
  if_673_end:
  loop684_next:
.annotate 'line', 347
    goto loop684_test
  loop684_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P686, exception, 'type'
    eq $P686, .CONTROL_LOOP_NEXT, loop684_next
    eq $P686, .CONTROL_LOOP_REDO, loop684_redo
  loop684_done:
    pop_eh 
.annotate 'line', 353
    new $P687, "Exception"
    set $P687['type'], .CONTROL_RETURN
    new $P688, "Integer"
    assign $P688, 0
    setattribute $P687, 'payload', $P688
    throw $P687
.annotate 'line', 344
    .return ()
  control_654:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P689, exception, "payload"
    .return ($P689)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("53_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_693
    .param pmc param_694
    .param pmc param_695
.annotate 'line', 356
    new $P692, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P692, control_691
    push_eh $P692
    .lex "self", param_693
    .lex "$obj", param_694
    .lex "$check", param_695
.annotate 'line', 357
    new $P696, "Undef"
    .lex "$i", $P696
    find_lex $P697, "self"
    get_global $P698, "$?CLASS"
    getattribute $P699, $P697, $P698, "@!done"
    unless_null $P699, vivify_143
    $P699 = root_new ['parrot';'ResizablePMCArray']
  vivify_143:
    set $N700, $P699
    new $P701, 'Float'
    set $P701, $N700
    store_lex "$i", $P701
.annotate 'line', 358
    new $P719, 'ExceptionHandler'
    set_addr $P719, loop718_handler
    $P719."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P719
  loop718_test:
    find_lex $P702, "$i"
    set $N703, $P702
    isgt $I704, $N703, 0.0
    unless $I704, loop718_done
  loop718_redo:
.annotate 'line', 359
    find_lex $P705, "$i"
    sub $P706, $P705, 1
    store_lex "$i", $P706
.annotate 'line', 360
    find_lex $P708, "$i"
    set $I709, $P708
    find_lex $P710, "self"
    get_global $P711, "$?CLASS"
    getattribute $P712, $P710, $P711, "@!done"
    unless_null $P712, vivify_144
    $P712 = root_new ['parrot';'ResizablePMCArray']
  vivify_144:
    set $P713, $P712[$I709]
    unless_null $P713, vivify_145
    new $P713, "Undef"
  vivify_145:
    find_lex $P714, "$check"
    issame $I715, $P713, $P714
    unless $I715, if_707_end
.annotate 'line', 361
    new $P716, "Exception"
    set $P716['type'], .CONTROL_RETURN
    new $P717, "Integer"
    assign $P717, 1
    setattribute $P716, 'payload', $P717
    throw $P716
  if_707_end:
  loop718_next:
.annotate 'line', 358
    goto loop718_test
  loop718_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P720, exception, 'type'
    eq $P720, .CONTROL_LOOP_NEXT, loop718_next
    eq $P720, .CONTROL_LOOP_REDO, loop718_redo
  loop718_done:
    pop_eh 
.annotate 'line', 364
    new $P721, "Exception"
    set $P721['type'], .CONTROL_RETURN
    new $P722, "Integer"
    assign $P722, 0
    setattribute $P721, 'payload', $P722
    throw $P721
.annotate 'line', 356
    .return ()
  control_691:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P723, exception, "payload"
    .return ($P723)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("54_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_727
    .param pmc param_728
    .param pmc param_729
.annotate 'line', 367
    .const 'Sub' $P737 = "55_1295994641.609" 
    capture_lex $P737
    new $P726, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P726, control_725
    push_eh $P726
    .lex "self", param_727
    .lex "$obj", param_728
    .lex "$name", param_729
.annotate 'line', 368
    find_lex $P731, "self"
    get_global $P732, "$?CLASS"
    getattribute $P733, $P731, $P732, "@!mro"
    unless_null $P733, vivify_146
    $P733 = root_new ['parrot';'ResizablePMCArray']
  vivify_146:
    defined $I734, $P733
    unless $I734, for_undef_147
    iter $P730, $P733
    new $P755, 'ExceptionHandler'
    set_addr $P755, loop754_handler
    $P755."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P755
  loop754_test:
    unless $P730, loop754_done
    shift $P735, $P730
  loop754_redo:
    .const 'Sub' $P737 = "55_1295994641.609" 
    capture_lex $P737
    $P737($P735)
  loop754_next:
    goto loop754_test
  loop754_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P756, exception, 'type'
    eq $P756, .CONTROL_LOOP_NEXT, loop754_next
    eq $P756, .CONTROL_LOOP_REDO, loop754_redo
  loop754_done:
    pop_eh 
  for_undef_147:
.annotate 'line', 375
    new $P757, "Exception"
    set $P757['type'], .CONTROL_RETURN
    new $P758, "Integer"
    assign $P758, 0
    setattribute $P757, 'payload', $P758
    throw $P757
.annotate 'line', 367
    .return ()
  control_725:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P759, exception, "payload"
    .return ($P759)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block736"  :anon :subid("55_1295994641.609") :outer("54_1295994641.609")
    .param pmc param_740
.annotate 'line', 369
    $P738 = root_new ['parrot';'Hash']
    .lex "%meths", $P738
.annotate 'line', 370
    new $P739, "Undef"
    .lex "$can", $P739
    .lex "$_", param_740
.annotate 'line', 369
    find_lex $P741, "$_"
    get_how $P742, $P741
    find_lex $P743, "$obj"
    $P744 = $P742."method_table"($P743)
    store_lex "%meths", $P744
.annotate 'line', 370
    find_lex $P745, "$name"
    find_lex $P746, "%meths"
    unless_null $P746, vivify_148
    $P746 = root_new ['parrot';'Hash']
  vivify_148:
    set $P747, $P746[$P745]
    unless_null $P747, vivify_149
    new $P747, "Undef"
  vivify_149:
    store_lex "$can", $P747
.annotate 'line', 371
    find_lex $P750, "$can"
    defined $I751, $P750
    if $I751, if_749
    new $P748, 'Integer'
    set $P748, $I751
    goto if_749_end
  if_749:
.annotate 'line', 372
    new $P752, "Exception"
    set $P752['type'], .CONTROL_RETURN
    find_lex $P753, "$can"
    setattribute $P752, 'payload', $P753
    throw $P752
  if_749_end:
.annotate 'line', 368
    .return ($P748)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("56_1295994641.609") :outer("15_1295994641.609")
    .param pmc param_763
    .param pmc param_764
    .param pmc param_765
.annotate 'line', 381
    .const 'Sub' $P773 = "57_1295994641.609" 
    capture_lex $P773
    new $P762, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P762, control_761
    push_eh $P762
    .lex "self", param_763
    .lex "$obj", param_764
    .lex "$name", param_765
.annotate 'line', 382
    find_lex $P767, "self"
    get_global $P768, "$?CLASS"
    getattribute $P769, $P767, $P768, "@!mro"
    unless_null $P769, vivify_150
    $P769 = root_new ['parrot';'ResizablePMCArray']
  vivify_150:
    defined $I770, $P769
    unless $I770, for_undef_151
    iter $P766, $P769
    new $P791, 'ExceptionHandler'
    set_addr $P791, loop790_handler
    $P791."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P791
  loop790_test:
    unless $P766, loop790_done
    shift $P771, $P766
  loop790_redo:
    .const 'Sub' $P773 = "57_1295994641.609" 
    capture_lex $P773
    $P773($P771)
  loop790_next:
    goto loop790_test
  loop790_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P792, exception, 'type'
    eq $P792, .CONTROL_LOOP_NEXT, loop790_next
    eq $P792, .CONTROL_LOOP_REDO, loop790_redo
  loop790_done:
    pop_eh 
  for_undef_151:
.annotate 'line', 389
    null $P793
.annotate 'line', 381
    .return ($P793)
  control_761:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P794, exception, "payload"
    .return ($P794)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block772"  :anon :subid("57_1295994641.609") :outer("56_1295994641.609")
    .param pmc param_776
.annotate 'line', 383
    $P774 = root_new ['parrot';'Hash']
    .lex "%meths", $P774
.annotate 'line', 384
    new $P775, "Undef"
    .lex "$found", $P775
    .lex "$_", param_776
.annotate 'line', 383
    find_lex $P777, "$_"
    get_how $P778, $P777
    find_lex $P779, "$obj"
    $P780 = $P778."method_table"($P779)
    store_lex "%meths", $P780
.annotate 'line', 384
    find_lex $P781, "$name"
    find_lex $P782, "%meths"
    unless_null $P782, vivify_152
    $P782 = root_new ['parrot';'Hash']
  vivify_152:
    set $P783, $P782[$P781]
    unless_null $P783, vivify_153
    new $P783, "Undef"
  vivify_153:
    store_lex "$found", $P783
.annotate 'line', 385
    find_lex $P786, "$found"
    defined $I787, $P786
    if $I787, if_785
    new $P784, 'Integer'
    set $P784, $I787
    goto if_785_end
  if_785:
.annotate 'line', 386
    new $P788, "Exception"
    set $P788['type'], .CONTROL_RETURN
    find_lex $P789, "$found"
    setattribute $P788, 'payload', $P789
    throw $P788
  if_785_end:
.annotate 'line', 382
    .return ($P784)
.end


.namespace ["NQPAttribute"]
.sub "_block877"  :subid("59_1295994641.609") :outer("10_1295994641.609")
.annotate 'line', 394
    .const 'Sub' $P903 = "63_1295994641.609" 
    capture_lex $P903
    .const 'Sub' $P896 = "62_1295994641.609" 
    capture_lex $P896
    .const 'Sub' $P889 = "61_1295994641.609" 
    capture_lex $P889
    .const 'Sub' $P880 = "60_1295994641.609" 
    capture_lex $P880
    get_global $P879, "$?CLASS"
.annotate 'line', 407
    .const 'Sub' $P896 = "62_1295994641.609" 
    newclosure $P901, $P896
.annotate 'line', 394
    .return ($P901)
.end


.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post154") :outer("59_1295994641.609")
.annotate 'line', 394
    get_hll_global $P878, ["NQPAttribute"], "_block877" 
    .local pmc block
    set block, $P878
    .const 'Sub' $P903 = "63_1295994641.609" 
    capture_lex $P903
    $P903()
.end


.namespace ["NQPAttribute"]
.sub "_block902"  :anon :subid("63_1295994641.609") :outer("59_1295994641.609")
.annotate 'line', 394
    get_hll_global $P904, "KnowHOW"
    $P905 = $P904."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P905
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P906, type_obj
    get_hll_global $P907, "KnowHOWAttribute"
    $P908 = $P907."new"("$!name" :named("name"))
    $P906."add_attribute"(type_obj, $P908)
    get_how $P909, type_obj
    .const 'Sub' $P910 = "60_1295994641.609" 
    $P909."add_method"(type_obj, "new", $P910)
    get_how $P911, type_obj
    .const 'Sub' $P912 = "61_1295994641.609" 
    $P911."add_method"(type_obj, "BUILD", $P912)
    get_how $P913, type_obj
    .const 'Sub' $P914 = "62_1295994641.609" 
    $P913."add_method"(type_obj, "name", $P914)
    get_how $P915, type_obj
    $P916 = $P915."compose"(type_obj)
    .return ($P916)
.end


.namespace ["NQPAttribute"]
.sub "new"  :subid("60_1295994641.609") :outer("59_1295994641.609")
    .param pmc param_881
    .param pmc param_882 :named("name")
.annotate 'line', 397
    .lex "self", param_881
    .lex "$name", param_882
.annotate 'line', 398
    new $P883, "Undef"
    .lex "$attr", $P883
    find_lex $P884, "self"
    repr_instance_of $P885, $P884
    store_lex "$attr", $P885
.annotate 'line', 399
    find_lex $P886, "$attr"
    find_lex $P887, "$name"
    $P886."BUILD"($P887 :named("name"))
    find_lex $P888, "$attr"
.annotate 'line', 397
    .return ($P888)
.end


.namespace ["NQPAttribute"]
.sub "BUILD"  :subid("61_1295994641.609") :outer("59_1295994641.609")
    .param pmc param_890
    .param pmc param_891 :optional :named("name")
    .param int has_param_891 :opt_flag
.annotate 'line', 403
    .lex "self", param_890
    if has_param_891, optparam_155
    new $P892, "Undef"
    set param_891, $P892
  optparam_155:
    .lex "$name", param_891
.annotate 'line', 404
    find_lex $P893, "$name"
    find_lex $P894, "self"
    get_global $P895, "$?CLASS"
    setattribute $P894, $P895, "$!name", $P893
.annotate 'line', 403
    .return ($P893)
.end


.namespace ["NQPAttribute"]
.sub "name"  :subid("62_1295994641.609") :outer("59_1295994641.609")
    .param pmc param_897
.annotate 'line', 407
    .lex "self", param_897
    find_lex $P898, "self"
    get_global $P899, "$?CLASS"
    getattribute $P900, $P898, $P899, "$!name"
    unless_null $P900, vivify_156
    new $P900, "Undef"
  vivify_156:
    .return ($P900)
.end


.namespace ["NQPMu"]
.sub "_block917"  :subid("64_1295994641.609") :outer("10_1295994641.609")
.annotate 'line', 413
    .const 'Sub' $P946 = "69_1295994641.609" 
    capture_lex $P946
    .const 'Sub' $P932 = "68_1295994641.609" 
    capture_lex $P932
    .const 'Sub' $P928 = "67_1295994641.609" 
    capture_lex $P928
    .const 'Sub' $P924 = "66_1295994641.609" 
    capture_lex $P924
    .const 'Sub' $P920 = "65_1295994641.609" 
    capture_lex $P920
    get_global $P919, "$?CLASS"
.annotate 'line', 423
    .const 'Sub' $P932 = "68_1295994641.609" 
    newclosure $P944, $P932
.annotate 'line', 413
    .return ($P944)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post157") :outer("64_1295994641.609")
.annotate 'line', 413
    get_hll_global $P918, ["NQPMu"], "_block917" 
    .local pmc block
    set block, $P918
    .const 'Sub' $P946 = "69_1295994641.609" 
    capture_lex $P946
    $P946()
.end


.namespace ["NQPMu"]
.sub "_block945"  :anon :subid("69_1295994641.609") :outer("64_1295994641.609")
.annotate 'line', 413
    get_hll_global $P947, "NQPClassHOW"
    $P948 = $P947."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P948
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P949, type_obj
    .const 'Sub' $P950 = "65_1295994641.609" 
    $P949."add_method"(type_obj, "CREATE", $P950)
    get_how $P951, type_obj
    .const 'Sub' $P952 = "66_1295994641.609" 
    $P951."add_method"(type_obj, "new", $P952)
    get_how $P953, type_obj
    .const 'Sub' $P954 = "67_1295994641.609" 
    new $P955, "ResizablePMCArray"
    set_dispatchees $P954, $P955
    $P953."add_method"(type_obj, "ACCEPTS", $P954)
    get_how $P956, type_obj
    .const 'Sub' $P957 = "68_1295994641.609" 
    $P956."add_multi_method"(type_obj, "ACCEPTS", $P957)
    get_how $P958, type_obj
    $P959 = $P958."compose"(type_obj)
    .return ($P959)
.end


.namespace ["NQPMu"]
.sub "CREATE"  :subid("65_1295994641.609") :outer("64_1295994641.609")
    .param pmc param_921
.annotate 'line', 414
    .lex "self", param_921
.annotate 'line', 415
    find_lex $P922, "self"
    repr_instance_of $P923, $P922
.annotate 'line', 414
    .return ($P923)
.end


.namespace ["NQPMu"]
.sub "new"  :subid("66_1295994641.609") :outer("64_1295994641.609")
    .param pmc param_925
.annotate 'line', 418
    .lex "self", param_925
.annotate 'line', 419
    find_lex $P926, "self"
    $P927 = $P926."CREATE"()
.annotate 'line', 418
    .return ($P927)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("67_1295994641.609") :outer("64_1295994641.609")
    .param pmc param_929
    .param pmc param_930
.annotate 'line', 418
    .lex "self", param_929
.annotate 'line', 422
    .lex "$topic", param_930
.annotate 'line', 418
    multi_dispatch_over_lexical_candidates $P931
    .return ($P931)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS"  :subid("68_1295994641.609") :outer("64_1295994641.609")
    .param pmc param_933
    .param pmc param_935
.annotate 'line', 423
    .lex "$self", param_933
    find_lex $P934, "$self"
    .lex "self", $P934
    .lex "$topic", param_935
.annotate 'line', 424
    find_lex $P936, "$topic"
    find_lex $P937, "self"
    get_what $P938, $P937
    type_check $I939, $P936, $P938
.annotate 'line', 423
    .return ($I939)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post158") :outer("68_1295994641.609")
.annotate 'line', 423
    .const 'Sub' $P932 = "68_1295994641.609" 
    .local pmc block
    set block, $P932
    get_hll_global $P940, "NQPMu"
    null $P941
    new $P942, "ResizablePMCArray"
    push $P942, $P940
    push $P942, $P941
    new $P943, "ResizablePMCArray"
    push $P943, 2
    push $P943, 0
    set_sub_multisig block, $P942, $P943
.end


.namespace []
.sub "_block961" :load :anon :subid("70_1295994641.609")
.annotate 'line', 1
    .const 'Sub' $P963 = "10_1295994641.609" 
    $P964 = $P963()
    .return ($P964)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
.end

### .include 'gen/nqp-grammar.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1295994649.593")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
    $P2379 = $P15()
.annotate 'line', 1
    .return ($P2379)
    .const 'Sub' $P2381 = "398_1295994649.593" 
    .return ($P2381)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block14"  :subid("11_1295994649.593") :outer("10_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P1672 = "397_1295994649.593" 
    capture_lex $P1672
    get_hll_global $P1563, ["NQP";"Regex"], "_block1562" 
    capture_lex $P1563
    .const 'Sub' $P1551 = "373_1295994649.593" 
    capture_lex $P1551
    .const 'Sub' $P1545 = "371_1295994649.593" 
    capture_lex $P1545
    .const 'Sub' $P1539 = "369_1295994649.593" 
    capture_lex $P1539
    .const 'Sub' $P1533 = "367_1295994649.593" 
    capture_lex $P1533
    .const 'Sub' $P1527 = "365_1295994649.593" 
    capture_lex $P1527
    .const 'Sub' $P1515 = "362_1295994649.593" 
    capture_lex $P1515
    .const 'Sub' $P1508 = "360_1295994649.593" 
    capture_lex $P1508
    .const 'Sub' $P1501 = "358_1295994649.593" 
    capture_lex $P1501
    .const 'Sub' $P1494 = "356_1295994649.593" 
    capture_lex $P1494
    .const 'Sub' $P1487 = "354_1295994649.593" 
    capture_lex $P1487
    .const 'Sub' $P1481 = "352_1295994649.593" 
    capture_lex $P1481
    .const 'Sub' $P1474 = "350_1295994649.593" 
    capture_lex $P1474
    .const 'Sub' $P1467 = "348_1295994649.593" 
    capture_lex $P1467
    .const 'Sub' $P1460 = "346_1295994649.593" 
    capture_lex $P1460
    .const 'Sub' $P1453 = "344_1295994649.593" 
    capture_lex $P1453
    .const 'Sub' $P1446 = "342_1295994649.593" 
    capture_lex $P1446
    .const 'Sub' $P1439 = "340_1295994649.593" 
    capture_lex $P1439
    .const 'Sub' $P1432 = "338_1295994649.593" 
    capture_lex $P1432
    .const 'Sub' $P1425 = "336_1295994649.593" 
    capture_lex $P1425
    .const 'Sub' $P1418 = "334_1295994649.593" 
    capture_lex $P1418
    .const 'Sub' $P1411 = "332_1295994649.593" 
    capture_lex $P1411
    .const 'Sub' $P1404 = "330_1295994649.593" 
    capture_lex $P1404
    .const 'Sub' $P1397 = "328_1295994649.593" 
    capture_lex $P1397
    .const 'Sub' $P1390 = "326_1295994649.593" 
    capture_lex $P1390
    .const 'Sub' $P1383 = "324_1295994649.593" 
    capture_lex $P1383
    .const 'Sub' $P1376 = "322_1295994649.593" 
    capture_lex $P1376
    .const 'Sub' $P1369 = "320_1295994649.593" 
    capture_lex $P1369
    .const 'Sub' $P1362 = "318_1295994649.593" 
    capture_lex $P1362
    .const 'Sub' $P1355 = "316_1295994649.593" 
    capture_lex $P1355
    .const 'Sub' $P1348 = "314_1295994649.593" 
    capture_lex $P1348
    .const 'Sub' $P1341 = "312_1295994649.593" 
    capture_lex $P1341
    .const 'Sub' $P1334 = "310_1295994649.593" 
    capture_lex $P1334
    .const 'Sub' $P1327 = "308_1295994649.593" 
    capture_lex $P1327
    .const 'Sub' $P1320 = "306_1295994649.593" 
    capture_lex $P1320
    .const 'Sub' $P1313 = "304_1295994649.593" 
    capture_lex $P1313
    .const 'Sub' $P1306 = "302_1295994649.593" 
    capture_lex $P1306
    .const 'Sub' $P1299 = "300_1295994649.593" 
    capture_lex $P1299
    .const 'Sub' $P1292 = "298_1295994649.593" 
    capture_lex $P1292
    .const 'Sub' $P1285 = "296_1295994649.593" 
    capture_lex $P1285
    .const 'Sub' $P1278 = "294_1295994649.593" 
    capture_lex $P1278
    .const 'Sub' $P1272 = "292_1295994649.593" 
    capture_lex $P1272
    .const 'Sub' $P1265 = "290_1295994649.593" 
    capture_lex $P1265
    .const 'Sub' $P1258 = "288_1295994649.593" 
    capture_lex $P1258
    .const 'Sub' $P1251 = "286_1295994649.593" 
    capture_lex $P1251
    .const 'Sub' $P1244 = "284_1295994649.593" 
    capture_lex $P1244
    .const 'Sub' $P1237 = "282_1295994649.593" 
    capture_lex $P1237
    .const 'Sub' $P1230 = "280_1295994649.593" 
    capture_lex $P1230
    .const 'Sub' $P1223 = "278_1295994649.593" 
    capture_lex $P1223
    .const 'Sub' $P1217 = "276_1295994649.593" 
    capture_lex $P1217
    .const 'Sub' $P1211 = "274_1295994649.593" 
    capture_lex $P1211
    .const 'Sub' $P1206 = "272_1295994649.593" 
    capture_lex $P1206
    .const 'Sub' $P1200 = "270_1295994649.593" 
    capture_lex $P1200
    .const 'Sub' $P1194 = "268_1295994649.593" 
    capture_lex $P1194
    .const 'Sub' $P1189 = "266_1295994649.593" 
    capture_lex $P1189
    .const 'Sub' $P1184 = "264_1295994649.593" 
    capture_lex $P1184
    .const 'Sub' $P1168 = "263_1295994649.593" 
    capture_lex $P1168
    .const 'Sub' $P1159 = "261_1295994649.593" 
    capture_lex $P1159
    .const 'Sub' $P1150 = "259_1295994649.593" 
    capture_lex $P1150
    .const 'Sub' $P1145 = "257_1295994649.593" 
    capture_lex $P1145
    .const 'Sub' $P1140 = "255_1295994649.593" 
    capture_lex $P1140
    .const 'Sub' $P1135 = "253_1295994649.593" 
    capture_lex $P1135
    .const 'Sub' $P1127 = "251_1295994649.593" 
    capture_lex $P1127
    .const 'Sub' $P1119 = "249_1295994649.593" 
    capture_lex $P1119
    .const 'Sub' $P1114 = "247_1295994649.593" 
    capture_lex $P1114
    .const 'Sub' $P1109 = "245_1295994649.593" 
    capture_lex $P1109
    .const 'Sub' $P1104 = "243_1295994649.593" 
    capture_lex $P1104
    .const 'Sub' $P1098 = "241_1295994649.593" 
    capture_lex $P1098
    .const 'Sub' $P1092 = "239_1295994649.593" 
    capture_lex $P1092
    .const 'Sub' $P1086 = "237_1295994649.593" 
    capture_lex $P1086
    .const 'Sub' $P1080 = "235_1295994649.593" 
    capture_lex $P1080
    .const 'Sub' $P1074 = "233_1295994649.593" 
    capture_lex $P1074
    .const 'Sub' $P1069 = "231_1295994649.593" 
    capture_lex $P1069
    .const 'Sub' $P1064 = "229_1295994649.593" 
    capture_lex $P1064
    .const 'Sub' $P1050 = "225_1295994649.593" 
    capture_lex $P1050
    .const 'Sub' $P1042 = "223_1295994649.593" 
    capture_lex $P1042
    .const 'Sub' $P1036 = "221_1295994649.593" 
    capture_lex $P1036
    .const 'Sub' $P1029 = "219_1295994649.593" 
    capture_lex $P1029
    .const 'Sub' $P1023 = "217_1295994649.593" 
    capture_lex $P1023
    .const 'Sub' $P1009 = "214_1295994649.593" 
    capture_lex $P1009
    .const 'Sub' $P1001 = "212_1295994649.593" 
    capture_lex $P1001
    .const 'Sub' $P993 = "210_1295994649.593" 
    capture_lex $P993
    .const 'Sub' $P987 = "208_1295994649.593" 
    capture_lex $P987
    .const 'Sub' $P981 = "206_1295994649.593" 
    capture_lex $P981
    .const 'Sub' $P965 = "202_1295994649.593" 
    capture_lex $P965
    .const 'Sub' $P928 = "200_1295994649.593" 
    capture_lex $P928
    .const 'Sub' $P917 = "198_1295994649.593" 
    capture_lex $P917
    .const 'Sub' $P903 = "194_1295994649.593" 
    capture_lex $P903
    .const 'Sub' $P894 = "192_1295994649.593" 
    capture_lex $P894
    .const 'Sub' $P888 = "190_1295994649.593" 
    capture_lex $P888
    .const 'Sub' $P878 = "188_1295994649.593" 
    capture_lex $P878
    .const 'Sub' $P863 = "186_1295994649.593" 
    capture_lex $P863
    .const 'Sub' $P849 = "183_1295994649.593" 
    capture_lex $P849
    .const 'Sub' $P841 = "181_1295994649.593" 
    capture_lex $P841
    .const 'Sub' $P831 = "179_1295994649.593" 
    capture_lex $P831
    .const 'Sub' $P821 = "177_1295994649.593" 
    capture_lex $P821
    .const 'Sub' $P802 = "172_1295994649.593" 
    capture_lex $P802
    .const 'Sub' $P758 = "169_1295994649.593" 
    capture_lex $P758
    .const 'Sub' $P724 = "167_1295994649.593" 
    capture_lex $P724
    .const 'Sub' $P717 = "165_1295994649.593" 
    capture_lex $P717
    .const 'Sub' $P710 = "163_1295994649.593" 
    capture_lex $P710
    .const 'Sub' $P698 = "159_1295994649.593" 
    capture_lex $P698
    .const 'Sub' $P690 = "157_1295994649.593" 
    capture_lex $P690
    .const 'Sub' $P684 = "155_1295994649.593" 
    capture_lex $P684
    .const 'Sub' $P671 = "153_1295994649.593" 
    capture_lex $P671
    .const 'Sub' $P664 = "151_1295994649.593" 
    capture_lex $P664
    .const 'Sub' $P657 = "149_1295994649.593" 
    capture_lex $P657
    .const 'Sub' $P650 = "147_1295994649.593" 
    capture_lex $P650
    .const 'Sub' $P614 = "143_1295994649.593" 
    capture_lex $P614
    .const 'Sub' $P602 = "141_1295994649.593" 
    capture_lex $P602
    .const 'Sub' $P590 = "139_1295994649.593" 
    capture_lex $P590
    .const 'Sub' $P578 = "137_1295994649.593" 
    capture_lex $P578
    .const 'Sub' $P566 = "135_1295994649.593" 
    capture_lex $P566
    .const 'Sub' $P559 = "133_1295994649.593" 
    capture_lex $P559
    .const 'Sub' $P548 = "129_1295994649.593" 
    capture_lex $P548
    .const 'Sub' $P543 = "127_1295994649.593" 
    capture_lex $P543
    .const 'Sub' $P531 = "125_1295994649.593" 
    capture_lex $P531
    .const 'Sub' $P519 = "123_1295994649.593" 
    capture_lex $P519
    .const 'Sub' $P512 = "121_1295994649.593" 
    capture_lex $P512
    .const 'Sub' $P507 = "119_1295994649.593" 
    capture_lex $P507
    .const 'Sub' $P501 = "117_1295994649.593" 
    capture_lex $P501
    .const 'Sub' $P495 = "115_1295994649.593" 
    capture_lex $P495
    .const 'Sub' $P480 = "111_1295994649.593" 
    capture_lex $P480
    .const 'Sub' $P474 = "109_1295994649.593" 
    capture_lex $P474
    .const 'Sub' $P468 = "107_1295994649.593" 
    capture_lex $P468
    .const 'Sub' $P462 = "105_1295994649.593" 
    capture_lex $P462
    .const 'Sub' $P456 = "103_1295994649.593" 
    capture_lex $P456
    .const 'Sub' $P450 = "101_1295994649.593" 
    capture_lex $P450
    .const 'Sub' $P444 = "99_1295994649.593" 
    capture_lex $P444
    .const 'Sub' $P435 = "97_1295994649.593" 
    capture_lex $P435
    .const 'Sub' $P426 = "95_1295994649.593" 
    capture_lex $P426
    .const 'Sub' $P417 = "93_1295994649.593" 
    capture_lex $P417
    .const 'Sub' $P402 = "89_1295994649.593" 
    capture_lex $P402
    .const 'Sub' $P393 = "87_1295994649.593" 
    capture_lex $P393
    .const 'Sub' $P381 = "83_1295994649.593" 
    capture_lex $P381
    .const 'Sub' $P374 = "81_1295994649.593" 
    capture_lex $P374
    .const 'Sub' $P367 = "79_1295994649.593" 
    capture_lex $P367
    .const 'Sub' $P353 = "75_1295994649.593" 
    capture_lex $P353
    .const 'Sub' $P345 = "73_1295994649.593" 
    capture_lex $P345
    .const 'Sub' $P337 = "71_1295994649.593" 
    capture_lex $P337
    .const 'Sub' $P317 = "69_1295994649.593" 
    capture_lex $P317
    .const 'Sub' $P308 = "67_1295994649.593" 
    capture_lex $P308
    .const 'Sub' $P290 = "64_1295994649.593" 
    capture_lex $P290
    .const 'Sub' $P272 = "62_1295994649.593" 
    capture_lex $P272
    .const 'Sub' $P261 = "58_1295994649.593" 
    capture_lex $P261
    .const 'Sub' $P256 = "56_1295994649.593" 
    capture_lex $P256
    .const 'Sub' $P245 = "52_1295994649.593" 
    capture_lex $P245
    .const 'Sub' $P240 = "50_1295994649.593" 
    capture_lex $P240
    .const 'Sub' $P235 = "48_1295994649.593" 
    capture_lex $P235
    .const 'Sub' $P226 = "46_1295994649.593" 
    capture_lex $P226
    .const 'Sub' $P219 = "44_1295994649.593" 
    capture_lex $P219
    .const 'Sub' $P213 = "42_1295994649.593" 
    capture_lex $P213
    .const 'Sub' $P205 = "40_1295994649.593" 
    capture_lex $P205
    .const 'Sub' $P199 = "38_1295994649.593" 
    capture_lex $P199
    .const 'Sub' $P193 = "36_1295994649.593" 
    capture_lex $P193
    .const 'Sub' $P178 = "33_1295994649.593" 
    capture_lex $P178
    .const 'Sub' $P164 = "31_1295994649.593" 
    capture_lex $P164
    .const 'Sub' $P157 = "29_1295994649.593" 
    capture_lex $P157
    .const 'Sub' $P118 = "26_1295994649.593" 
    capture_lex $P118
    .const 'Sub' $P103 = "23_1295994649.593" 
    capture_lex $P103
    .const 'Sub' $P92 = "21_1295994649.593" 
    capture_lex $P92
    .const 'Sub' $P80 = "19_1295994649.593" 
    capture_lex $P80
    .const 'Sub' $P72 = "17_1295994649.593" 
    capture_lex $P72
    .const 'Sub' $P65 = "15_1295994649.593" 
    capture_lex $P65
    .const 'Sub' $P58 = "13_1295994649.593" 
    capture_lex $P58
    .const 'Sub' $P18 = "12_1295994649.593" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1168 = "263_1295994649.593" 
    capture_lex $P1168
    $P1168()
.annotate 'line', 645
    get_hll_global $P1563, ["NQP";"Regex"], "_block1562" 
    capture_lex $P1563
    $P1666 = $P1563()
.annotate 'line', 4
    .return ($P1666)
    .const 'Sub' $P1668 = "396_1295994649.593" 
    .return ($P1668)
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post399") :outer("11_1295994649.593")
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P1672 = "397_1295994649.593" 
    capture_lex $P1672
    $P1672()
.end


.namespace ["NQP";"Grammar"]
.sub "_block1671"  :anon :subid("397_1295994649.593") :outer("11_1295994649.593")
.annotate 'line', 4
    get_hll_global $P1673, "NQPClassHOW"
    $P1674 = $P1673."new_type"("Grammar" :named("name"))
    .local pmc type_obj
    set type_obj, $P1674
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1675, type_obj
    .const 'Sub' $P1676 = "12_1295994649.593" 
    $P1675."add_method"(type_obj, "TOP", $P1676)
    get_how $P1677, type_obj
    .const 'Sub' $P1678 = "13_1295994649.593" 
    $P1677."add_method"(type_obj, "identifier", $P1678)
    get_how $P1679, type_obj
    get_global $P1680, "!PREFIX__identifier"
    $P1679."add_method"(type_obj, "!PREFIX__identifier", $P1680)
    get_how $P1681, type_obj
    .const 'Sub' $P1682 = "15_1295994649.593" 
    $P1681."add_method"(type_obj, "name", $P1682)
    get_how $P1683, type_obj
    get_global $P1684, "!PREFIX__name"
    $P1683."add_method"(type_obj, "!PREFIX__name", $P1684)
    get_how $P1685, type_obj
    .const 'Sub' $P1686 = "17_1295994649.593" 
    $P1685."add_method"(type_obj, "deflongname", $P1686)
    get_how $P1687, type_obj
    get_global $P1688, "!PREFIX__deflongname"
    $P1687."add_method"(type_obj, "!PREFIX__deflongname", $P1688)
    get_how $P1689, type_obj
    .const 'Sub' $P1690 = "19_1295994649.593" 
    $P1689."add_method"(type_obj, "ENDSTMT", $P1690)
    get_how $P1691, type_obj
    get_global $P1692, "!PREFIX__ENDSTMT"
    $P1691."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1692)
    get_how $P1693, type_obj
    .const 'Sub' $P1694 = "21_1295994649.593" 
    $P1693."add_method"(type_obj, "ws", $P1694)
    get_how $P1695, type_obj
    get_global $P1696, "!PREFIX__ws"
    $P1695."add_method"(type_obj, "!PREFIX__ws", $P1696)
    get_how $P1697, type_obj
    .const 'Sub' $P1698 = "23_1295994649.593" 
    $P1697."add_method"(type_obj, "unv", $P1698)
    get_how $P1699, type_obj
    get_global $P1700, "!PREFIX__unv"
    $P1699."add_method"(type_obj, "!PREFIX__unv", $P1700)
    get_how $P1701, type_obj
    .const 'Sub' $P1702 = "26_1295994649.593" 
    $P1701."add_method"(type_obj, "pod_comment", $P1702)
    get_how $P1703, type_obj
    get_global $P1704, "!PREFIX__pod_comment"
    $P1703."add_method"(type_obj, "!PREFIX__pod_comment", $P1704)
    get_how $P1705, type_obj
    .const 'Sub' $P1706 = "29_1295994649.593" 
    $P1705."add_method"(type_obj, "comp_unit", $P1706)
    get_how $P1707, type_obj
    get_global $P1708, "!PREFIX__comp_unit"
    $P1707."add_method"(type_obj, "!PREFIX__comp_unit", $P1708)
    get_how $P1709, type_obj
    .const 'Sub' $P1710 = "31_1295994649.593" 
    $P1709."add_method"(type_obj, "statementlist", $P1710)
    get_how $P1711, type_obj
    get_global $P1712, "!PREFIX__statementlist"
    $P1711."add_method"(type_obj, "!PREFIX__statementlist", $P1712)
    get_how $P1713, type_obj
    .const 'Sub' $P1714 = "33_1295994649.593" 
    $P1713."add_method"(type_obj, "statement", $P1714)
    get_how $P1715, type_obj
    get_global $P1716, "!PREFIX__statement"
    $P1715."add_method"(type_obj, "!PREFIX__statement", $P1716)
    get_how $P1717, type_obj
    .const 'Sub' $P1718 = "36_1295994649.593" 
    $P1717."add_method"(type_obj, "eat_terminator", $P1718)
    get_how $P1719, type_obj
    get_global $P1720, "!PREFIX__eat_terminator"
    $P1719."add_method"(type_obj, "!PREFIX__eat_terminator", $P1720)
    get_how $P1721, type_obj
    .const 'Sub' $P1722 = "38_1295994649.593" 
    $P1721."add_method"(type_obj, "xblock", $P1722)
    get_how $P1723, type_obj
    get_global $P1724, "!PREFIX__xblock"
    $P1723."add_method"(type_obj, "!PREFIX__xblock", $P1724)
    get_how $P1725, type_obj
    .const 'Sub' $P1726 = "40_1295994649.593" 
    $P1725."add_method"(type_obj, "pblock", $P1726)
    get_how $P1727, type_obj
    get_global $P1728, "!PREFIX__pblock"
    $P1727."add_method"(type_obj, "!PREFIX__pblock", $P1728)
    get_how $P1729, type_obj
    .const 'Sub' $P1730 = "42_1295994649.593" 
    $P1729."add_method"(type_obj, "lambda", $P1730)
    get_how $P1731, type_obj
    get_global $P1732, "!PREFIX__lambda"
    $P1731."add_method"(type_obj, "!PREFIX__lambda", $P1732)
    get_how $P1733, type_obj
    .const 'Sub' $P1734 = "44_1295994649.593" 
    $P1733."add_method"(type_obj, "block", $P1734)
    get_how $P1735, type_obj
    get_global $P1736, "!PREFIX__block"
    $P1735."add_method"(type_obj, "!PREFIX__block", $P1736)
    get_how $P1737, type_obj
    .const 'Sub' $P1738 = "46_1295994649.593" 
    $P1737."add_method"(type_obj, "blockoid", $P1738)
    get_how $P1739, type_obj
    get_global $P1740, "!PREFIX__blockoid"
    $P1739."add_method"(type_obj, "!PREFIX__blockoid", $P1740)
    get_how $P1741, type_obj
    .const 'Sub' $P1742 = "48_1295994649.593" 
    $P1741."add_method"(type_obj, "newpad", $P1742)
    get_how $P1743, type_obj
    get_global $P1744, "!PREFIX__newpad"
    $P1743."add_method"(type_obj, "!PREFIX__newpad", $P1744)
    get_how $P1745, type_obj
    .const 'Sub' $P1746 = "50_1295994649.593" 
    $P1745."add_method"(type_obj, "outerctx", $P1746)
    get_how $P1747, type_obj
    get_global $P1748, "!PREFIX__outerctx"
    $P1747."add_method"(type_obj, "!PREFIX__outerctx", $P1748)
    get_how $P1749, type_obj
    .const 'Sub' $P1750 = "52_1295994649.593" 
    $P1749."add_method"(type_obj, "finishpad", $P1750)
    get_how $P1751, type_obj
    get_global $P1752, "!PREFIX__finishpad"
    $P1751."add_method"(type_obj, "!PREFIX__finishpad", $P1752)
    get_how $P1753, type_obj
    .const 'Sub' $P1754 = "54_1295994649.593" 
    $P1753."add_method"(type_obj, "terminator", $P1754)
    get_how $P1755, type_obj
    .const 'Sub' $P1756 = "55_1295994649.593" 
    $P1755."add_method"(type_obj, "!PREFIX__terminator", $P1756)
    get_how $P1757, type_obj
    .const 'Sub' $P1758 = "56_1295994649.593" 
    $P1757."add_method"(type_obj, "terminator:sym<;>", $P1758)
    get_how $P1759, type_obj
    get_global $P1760, "!PREFIX__terminator:sym<;>"
    $P1759."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1760)
    get_how $P1761, type_obj
    .const 'Sub' $P1762 = "58_1295994649.593" 
    $P1761."add_method"(type_obj, "terminator:sym<}>", $P1762)
    get_how $P1763, type_obj
    get_global $P1764, "!PREFIX__terminator:sym<}>"
    $P1763."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1764)
    get_how $P1765, type_obj
    .const 'Sub' $P1766 = "60_1295994649.593" 
    $P1765."add_method"(type_obj, "statement_control", $P1766)
    get_how $P1767, type_obj
    .const 'Sub' $P1768 = "61_1295994649.593" 
    $P1767."add_method"(type_obj, "!PREFIX__statement_control", $P1768)
    get_how $P1769, type_obj
    .const 'Sub' $P1770 = "62_1295994649.593" 
    $P1769."add_method"(type_obj, "statement_control:sym<if>", $P1770)
    get_how $P1771, type_obj
    get_global $P1772, "!PREFIX__statement_control:sym<if>"
    $P1771."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1772)
    get_how $P1773, type_obj
    .const 'Sub' $P1774 = "64_1295994649.593" 
    $P1773."add_method"(type_obj, "statement_control:sym<unless>", $P1774)
    get_how $P1775, type_obj
    get_global $P1776, "!PREFIX__statement_control:sym<unless>"
    $P1775."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1776)
    get_how $P1777, type_obj
    .const 'Sub' $P1778 = "67_1295994649.593" 
    $P1777."add_method"(type_obj, "statement_control:sym<while>", $P1778)
    get_how $P1779, type_obj
    get_global $P1780, "!PREFIX__statement_control:sym<while>"
    $P1779."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1780)
    get_how $P1781, type_obj
    .const 'Sub' $P1782 = "69_1295994649.593" 
    $P1781."add_method"(type_obj, "statement_control:sym<repeat>", $P1782)
    get_how $P1783, type_obj
    get_global $P1784, "!PREFIX__statement_control:sym<repeat>"
    $P1783."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1784)
    get_how $P1785, type_obj
    .const 'Sub' $P1786 = "71_1295994649.593" 
    $P1785."add_method"(type_obj, "statement_control:sym<for>", $P1786)
    get_how $P1787, type_obj
    get_global $P1788, "!PREFIX__statement_control:sym<for>"
    $P1787."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1788)
    get_how $P1789, type_obj
    .const 'Sub' $P1790 = "73_1295994649.593" 
    $P1789."add_method"(type_obj, "statement_control:sym<CATCH>", $P1790)
    get_how $P1791, type_obj
    get_global $P1792, "!PREFIX__statement_control:sym<CATCH>"
    $P1791."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1792)
    get_how $P1793, type_obj
    .const 'Sub' $P1794 = "75_1295994649.593" 
    $P1793."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1794)
    get_how $P1795, type_obj
    get_global $P1796, "!PREFIX__statement_control:sym<CONTROL>"
    $P1795."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1796)
    get_how $P1797, type_obj
    .const 'Sub' $P1798 = "77_1295994649.593" 
    $P1797."add_method"(type_obj, "statement_prefix", $P1798)
    get_how $P1799, type_obj
    .const 'Sub' $P1800 = "78_1295994649.593" 
    $P1799."add_method"(type_obj, "!PREFIX__statement_prefix", $P1800)
    get_how $P1801, type_obj
    .const 'Sub' $P1802 = "79_1295994649.593" 
    $P1801."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1802)
    get_how $P1803, type_obj
    get_global $P1804, "!PREFIX__statement_prefix:sym<INIT>"
    $P1803."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1804)
    get_how $P1805, type_obj
    .const 'Sub' $P1806 = "81_1295994649.593" 
    $P1805."add_method"(type_obj, "statement_prefix:sym<try>", $P1806)
    get_how $P1807, type_obj
    get_global $P1808, "!PREFIX__statement_prefix:sym<try>"
    $P1807."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1808)
    get_how $P1809, type_obj
    .const 'Sub' $P1810 = "83_1295994649.593" 
    $P1809."add_method"(type_obj, "blorst", $P1810)
    get_how $P1811, type_obj
    get_global $P1812, "!PREFIX__blorst"
    $P1811."add_method"(type_obj, "!PREFIX__blorst", $P1812)
    get_how $P1813, type_obj
    .const 'Sub' $P1814 = "85_1295994649.593" 
    $P1813."add_method"(type_obj, "statement_mod_cond", $P1814)
    get_how $P1815, type_obj
    .const 'Sub' $P1816 = "86_1295994649.593" 
    $P1815."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1816)
    get_how $P1817, type_obj
    .const 'Sub' $P1818 = "87_1295994649.593" 
    $P1817."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1818)
    get_how $P1819, type_obj
    get_global $P1820, "!PREFIX__statement_mod_cond:sym<if>"
    $P1819."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1820)
    get_how $P1821, type_obj
    .const 'Sub' $P1822 = "89_1295994649.593" 
    $P1821."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1822)
    get_how $P1823, type_obj
    get_global $P1824, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1823."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1824)
    get_how $P1825, type_obj
    .const 'Sub' $P1826 = "91_1295994649.593" 
    $P1825."add_method"(type_obj, "statement_mod_loop", $P1826)
    get_how $P1827, type_obj
    .const 'Sub' $P1828 = "92_1295994649.593" 
    $P1827."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1828)
    get_how $P1829, type_obj
    .const 'Sub' $P1830 = "93_1295994649.593" 
    $P1829."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1830)
    get_how $P1831, type_obj
    get_global $P1832, "!PREFIX__statement_mod_loop:sym<while>"
    $P1831."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1832)
    get_how $P1833, type_obj
    .const 'Sub' $P1834 = "95_1295994649.593" 
    $P1833."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1834)
    get_how $P1835, type_obj
    get_global $P1836, "!PREFIX__statement_mod_loop:sym<until>"
    $P1835."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1836)
    get_how $P1837, type_obj
    .const 'Sub' $P1838 = "97_1295994649.593" 
    $P1837."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1838)
    get_how $P1839, type_obj
    get_global $P1840, "!PREFIX__statement_mod_loop:sym<for>"
    $P1839."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1840)
    get_how $P1841, type_obj
    .const 'Sub' $P1842 = "99_1295994649.593" 
    $P1841."add_method"(type_obj, "term:sym<fatarrow>", $P1842)
    get_how $P1843, type_obj
    get_global $P1844, "!PREFIX__term:sym<fatarrow>"
    $P1843."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1844)
    get_how $P1845, type_obj
    .const 'Sub' $P1846 = "101_1295994649.593" 
    $P1845."add_method"(type_obj, "term:sym<colonpair>", $P1846)
    get_how $P1847, type_obj
    get_global $P1848, "!PREFIX__term:sym<colonpair>"
    $P1847."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1848)
    get_how $P1849, type_obj
    .const 'Sub' $P1850 = "103_1295994649.593" 
    $P1849."add_method"(type_obj, "term:sym<variable>", $P1850)
    get_how $P1851, type_obj
    get_global $P1852, "!PREFIX__term:sym<variable>"
    $P1851."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1852)
    get_how $P1853, type_obj
    .const 'Sub' $P1854 = "105_1295994649.593" 
    $P1853."add_method"(type_obj, "term:sym<package_declarator>", $P1854)
    get_how $P1855, type_obj
    get_global $P1856, "!PREFIX__term:sym<package_declarator>"
    $P1855."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1856)
    get_how $P1857, type_obj
    .const 'Sub' $P1858 = "107_1295994649.593" 
    $P1857."add_method"(type_obj, "term:sym<scope_declarator>", $P1858)
    get_how $P1859, type_obj
    get_global $P1860, "!PREFIX__term:sym<scope_declarator>"
    $P1859."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1860)
    get_how $P1861, type_obj
    .const 'Sub' $P1862 = "109_1295994649.593" 
    $P1861."add_method"(type_obj, "term:sym<routine_declarator>", $P1862)
    get_how $P1863, type_obj
    get_global $P1864, "!PREFIX__term:sym<routine_declarator>"
    $P1863."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1864)
    get_how $P1865, type_obj
    .const 'Sub' $P1866 = "111_1295994649.593" 
    $P1865."add_method"(type_obj, "term:sym<multi_declarator>", $P1866)
    get_how $P1867, type_obj
    get_global $P1868, "!PREFIX__term:sym<multi_declarator>"
    $P1867."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1868)
    get_how $P1869, type_obj
    .const 'Sub' $P1870 = "115_1295994649.593" 
    $P1869."add_method"(type_obj, "term:sym<regex_declarator>", $P1870)
    get_how $P1871, type_obj
    get_global $P1872, "!PREFIX__term:sym<regex_declarator>"
    $P1871."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1872)
    get_how $P1873, type_obj
    .const 'Sub' $P1874 = "117_1295994649.593" 
    $P1873."add_method"(type_obj, "term:sym<statement_prefix>", $P1874)
    get_how $P1875, type_obj
    get_global $P1876, "!PREFIX__term:sym<statement_prefix>"
    $P1875."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1876)
    get_how $P1877, type_obj
    .const 'Sub' $P1878 = "119_1295994649.593" 
    $P1877."add_method"(type_obj, "term:sym<lambda>", $P1878)
    get_how $P1879, type_obj
    get_global $P1880, "!PREFIX__term:sym<lambda>"
    $P1879."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1880)
    get_how $P1881, type_obj
    .const 'Sub' $P1882 = "121_1295994649.593" 
    $P1881."add_method"(type_obj, "fatarrow", $P1882)
    get_how $P1883, type_obj
    get_global $P1884, "!PREFIX__fatarrow"
    $P1883."add_method"(type_obj, "!PREFIX__fatarrow", $P1884)
    get_how $P1885, type_obj
    .const 'Sub' $P1886 = "123_1295994649.593" 
    $P1885."add_method"(type_obj, "colonpair", $P1886)
    get_how $P1887, type_obj
    get_global $P1888, "!PREFIX__colonpair"
    $P1887."add_method"(type_obj, "!PREFIX__colonpair", $P1888)
    get_how $P1889, type_obj
    .const 'Sub' $P1890 = "125_1295994649.593" 
    $P1889."add_method"(type_obj, "variable", $P1890)
    get_how $P1891, type_obj
    get_global $P1892, "!PREFIX__variable"
    $P1891."add_method"(type_obj, "!PREFIX__variable", $P1892)
    get_how $P1893, type_obj
    .const 'Sub' $P1894 = "127_1295994649.593" 
    $P1893."add_method"(type_obj, "sigil", $P1894)
    get_how $P1895, type_obj
    get_global $P1896, "!PREFIX__sigil"
    $P1895."add_method"(type_obj, "!PREFIX__sigil", $P1896)
    get_how $P1897, type_obj
    .const 'Sub' $P1898 = "129_1295994649.593" 
    $P1897."add_method"(type_obj, "twigil", $P1898)
    get_how $P1899, type_obj
    get_global $P1900, "!PREFIX__twigil"
    $P1899."add_method"(type_obj, "!PREFIX__twigil", $P1900)
    get_how $P1901, type_obj
    .const 'Sub' $P1902 = "131_1295994649.593" 
    $P1901."add_method"(type_obj, "package_declarator", $P1902)
    get_how $P1903, type_obj
    .const 'Sub' $P1904 = "132_1295994649.593" 
    $P1903."add_method"(type_obj, "!PREFIX__package_declarator", $P1904)
    get_how $P1905, type_obj
    .const 'Sub' $P1906 = "133_1295994649.593" 
    $P1905."add_method"(type_obj, "package_declarator:sym<module>", $P1906)
    get_how $P1907, type_obj
    get_global $P1908, "!PREFIX__package_declarator:sym<module>"
    $P1907."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1908)
    get_how $P1909, type_obj
    .const 'Sub' $P1910 = "135_1295994649.593" 
    $P1909."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1910)
    get_how $P1911, type_obj
    get_global $P1912, "!PREFIX__package_declarator:sym<knowhow>"
    $P1911."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1912)
    get_how $P1913, type_obj
    .const 'Sub' $P1914 = "137_1295994649.593" 
    $P1913."add_method"(type_obj, "package_declarator:sym<class>", $P1914)
    get_how $P1915, type_obj
    get_global $P1916, "!PREFIX__package_declarator:sym<class>"
    $P1915."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1916)
    get_how $P1917, type_obj
    .const 'Sub' $P1918 = "139_1295994649.593" 
    $P1917."add_method"(type_obj, "package_declarator:sym<grammar>", $P1918)
    get_how $P1919, type_obj
    get_global $P1920, "!PREFIX__package_declarator:sym<grammar>"
    $P1919."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1920)
    get_how $P1921, type_obj
    .const 'Sub' $P1922 = "141_1295994649.593" 
    $P1921."add_method"(type_obj, "package_declarator:sym<role>", $P1922)
    get_how $P1923, type_obj
    get_global $P1924, "!PREFIX__package_declarator:sym<role>"
    $P1923."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1924)
    get_how $P1925, type_obj
    .const 'Sub' $P1926 = "143_1295994649.593" 
    $P1925."add_method"(type_obj, "package_def", $P1926)
    get_how $P1927, type_obj
    get_global $P1928, "!PREFIX__package_def"
    $P1927."add_method"(type_obj, "!PREFIX__package_def", $P1928)
    get_how $P1929, type_obj
    .const 'Sub' $P1930 = "145_1295994649.593" 
    $P1929."add_method"(type_obj, "scope_declarator", $P1930)
    get_how $P1931, type_obj
    .const 'Sub' $P1932 = "146_1295994649.593" 
    $P1931."add_method"(type_obj, "!PREFIX__scope_declarator", $P1932)
    get_how $P1933, type_obj
    .const 'Sub' $P1934 = "147_1295994649.593" 
    $P1933."add_method"(type_obj, "scope_declarator:sym<my>", $P1934)
    get_how $P1935, type_obj
    get_global $P1936, "!PREFIX__scope_declarator:sym<my>"
    $P1935."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1936)
    get_how $P1937, type_obj
    .const 'Sub' $P1938 = "149_1295994649.593" 
    $P1937."add_method"(type_obj, "scope_declarator:sym<our>", $P1938)
    get_how $P1939, type_obj
    get_global $P1940, "!PREFIX__scope_declarator:sym<our>"
    $P1939."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1940)
    get_how $P1941, type_obj
    .const 'Sub' $P1942 = "151_1295994649.593" 
    $P1941."add_method"(type_obj, "scope_declarator:sym<has>", $P1942)
    get_how $P1943, type_obj
    get_global $P1944, "!PREFIX__scope_declarator:sym<has>"
    $P1943."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1944)
    get_how $P1945, type_obj
    .const 'Sub' $P1946 = "153_1295994649.593" 
    $P1945."add_method"(type_obj, "scoped", $P1946)
    get_how $P1947, type_obj
    get_global $P1948, "!PREFIX__scoped"
    $P1947."add_method"(type_obj, "!PREFIX__scoped", $P1948)
    get_how $P1949, type_obj
    .const 'Sub' $P1950 = "155_1295994649.593" 
    $P1949."add_method"(type_obj, "typename", $P1950)
    get_how $P1951, type_obj
    get_global $P1952, "!PREFIX__typename"
    $P1951."add_method"(type_obj, "!PREFIX__typename", $P1952)
    get_how $P1953, type_obj
    .const 'Sub' $P1954 = "157_1295994649.593" 
    $P1953."add_method"(type_obj, "declarator", $P1954)
    get_how $P1955, type_obj
    get_global $P1956, "!PREFIX__declarator"
    $P1955."add_method"(type_obj, "!PREFIX__declarator", $P1956)
    get_how $P1957, type_obj
    .const 'Sub' $P1958 = "159_1295994649.593" 
    $P1957."add_method"(type_obj, "variable_declarator", $P1958)
    get_how $P1959, type_obj
    get_global $P1960, "!PREFIX__variable_declarator"
    $P1959."add_method"(type_obj, "!PREFIX__variable_declarator", $P1960)
    get_how $P1961, type_obj
    .const 'Sub' $P1962 = "161_1295994649.593" 
    $P1961."add_method"(type_obj, "routine_declarator", $P1962)
    get_how $P1963, type_obj
    .const 'Sub' $P1964 = "162_1295994649.593" 
    $P1963."add_method"(type_obj, "!PREFIX__routine_declarator", $P1964)
    get_how $P1965, type_obj
    .const 'Sub' $P1966 = "163_1295994649.593" 
    $P1965."add_method"(type_obj, "routine_declarator:sym<sub>", $P1966)
    get_how $P1967, type_obj
    get_global $P1968, "!PREFIX__routine_declarator:sym<sub>"
    $P1967."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P1968)
    get_how $P1969, type_obj
    .const 'Sub' $P1970 = "165_1295994649.593" 
    $P1969."add_method"(type_obj, "routine_declarator:sym<method>", $P1970)
    get_how $P1971, type_obj
    get_global $P1972, "!PREFIX__routine_declarator:sym<method>"
    $P1971."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P1972)
    get_how $P1973, type_obj
    .const 'Sub' $P1974 = "167_1295994649.593" 
    $P1973."add_method"(type_obj, "routine_def", $P1974)
    get_how $P1975, type_obj
    get_global $P1976, "!PREFIX__routine_def"
    $P1975."add_method"(type_obj, "!PREFIX__routine_def", $P1976)
    get_how $P1977, type_obj
    .const 'Sub' $P1978 = "169_1295994649.593" 
    $P1977."add_method"(type_obj, "method_def", $P1978)
    get_how $P1979, type_obj
    get_global $P1980, "!PREFIX__method_def"
    $P1979."add_method"(type_obj, "!PREFIX__method_def", $P1980)
    get_how $P1981, type_obj
    .const 'Sub' $P1982 = "172_1295994649.593" 
    $P1981."add_method"(type_obj, "onlystar", $P1982)
    get_how $P1983, type_obj
    get_global $P1984, "!PREFIX__onlystar"
    $P1983."add_method"(type_obj, "!PREFIX__onlystar", $P1984)
    get_how $P1985, type_obj
    .const 'Sub' $P1986 = "175_1295994649.593" 
    $P1985."add_method"(type_obj, "multi_declarator", $P1986)
    get_how $P1987, type_obj
    .const 'Sub' $P1988 = "176_1295994649.593" 
    $P1987."add_method"(type_obj, "!PREFIX__multi_declarator", $P1988)
    get_how $P1989, type_obj
    .const 'Sub' $P1990 = "177_1295994649.593" 
    $P1989."add_method"(type_obj, "multi_declarator:sym<multi>", $P1990)
    get_how $P1991, type_obj
    get_global $P1992, "!PREFIX__multi_declarator:sym<multi>"
    $P1991."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P1992)
    get_how $P1993, type_obj
    .const 'Sub' $P1994 = "179_1295994649.593" 
    $P1993."add_method"(type_obj, "multi_declarator:sym<proto>", $P1994)
    get_how $P1995, type_obj
    get_global $P1996, "!PREFIX__multi_declarator:sym<proto>"
    $P1995."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P1996)
    get_how $P1997, type_obj
    .const 'Sub' $P1998 = "181_1295994649.593" 
    $P1997."add_method"(type_obj, "multi_declarator:sym<null>", $P1998)
    get_how $P1999, type_obj
    get_global $P2000, "!PREFIX__multi_declarator:sym<null>"
    $P1999."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2000)
    get_how $P2001, type_obj
    .const 'Sub' $P2002 = "183_1295994649.593" 
    $P2001."add_method"(type_obj, "signature", $P2002)
    get_how $P2003, type_obj
    get_global $P2004, "!PREFIX__signature"
    $P2003."add_method"(type_obj, "!PREFIX__signature", $P2004)
    get_how $P2005, type_obj
    .const 'Sub' $P2006 = "186_1295994649.593" 
    $P2005."add_method"(type_obj, "parameter", $P2006)
    get_how $P2007, type_obj
    get_global $P2008, "!PREFIX__parameter"
    $P2007."add_method"(type_obj, "!PREFIX__parameter", $P2008)
    get_how $P2009, type_obj
    .const 'Sub' $P2010 = "188_1295994649.593" 
    $P2009."add_method"(type_obj, "param_var", $P2010)
    get_how $P2011, type_obj
    get_global $P2012, "!PREFIX__param_var"
    $P2011."add_method"(type_obj, "!PREFIX__param_var", $P2012)
    get_how $P2013, type_obj
    .const 'Sub' $P2014 = "190_1295994649.593" 
    $P2013."add_method"(type_obj, "named_param", $P2014)
    get_how $P2015, type_obj
    get_global $P2016, "!PREFIX__named_param"
    $P2015."add_method"(type_obj, "!PREFIX__named_param", $P2016)
    get_how $P2017, type_obj
    .const 'Sub' $P2018 = "192_1295994649.593" 
    $P2017."add_method"(type_obj, "default_value", $P2018)
    get_how $P2019, type_obj
    get_global $P2020, "!PREFIX__default_value"
    $P2019."add_method"(type_obj, "!PREFIX__default_value", $P2020)
    get_how $P2021, type_obj
    .const 'Sub' $P2022 = "194_1295994649.593" 
    $P2021."add_method"(type_obj, "trait", $P2022)
    get_how $P2023, type_obj
    get_global $P2024, "!PREFIX__trait"
    $P2023."add_method"(type_obj, "!PREFIX__trait", $P2024)
    get_how $P2025, type_obj
    .const 'Sub' $P2026 = "196_1295994649.593" 
    $P2025."add_method"(type_obj, "trait_mod", $P2026)
    get_how $P2027, type_obj
    .const 'Sub' $P2028 = "197_1295994649.593" 
    $P2027."add_method"(type_obj, "!PREFIX__trait_mod", $P2028)
    get_how $P2029, type_obj
    .const 'Sub' $P2030 = "198_1295994649.593" 
    $P2029."add_method"(type_obj, "trait_mod:sym<is>", $P2030)
    get_how $P2031, type_obj
    get_global $P2032, "!PREFIX__trait_mod:sym<is>"
    $P2031."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2032)
    get_how $P2033, type_obj
    .const 'Sub' $P2034 = "200_1295994649.593" 
    $P2033."add_method"(type_obj, "regex_declarator", $P2034)
    get_how $P2035, type_obj
    get_global $P2036, "!PREFIX__regex_declarator"
    $P2035."add_method"(type_obj, "!PREFIX__regex_declarator", $P2036)
    get_how $P2037, type_obj
    .const 'Sub' $P2038 = "202_1295994649.593" 
    $P2037."add_method"(type_obj, "dotty", $P2038)
    get_how $P2039, type_obj
    get_global $P2040, "!PREFIX__dotty"
    $P2039."add_method"(type_obj, "!PREFIX__dotty", $P2040)
    get_how $P2041, type_obj
    .const 'Sub' $P2042 = "204_1295994649.593" 
    $P2041."add_method"(type_obj, "term", $P2042)
    get_how $P2043, type_obj
    .const 'Sub' $P2044 = "205_1295994649.593" 
    $P2043."add_method"(type_obj, "!PREFIX__term", $P2044)
    get_how $P2045, type_obj
    .const 'Sub' $P2046 = "206_1295994649.593" 
    $P2045."add_method"(type_obj, "term:sym<self>", $P2046)
    get_how $P2047, type_obj
    get_global $P2048, "!PREFIX__term:sym<self>"
    $P2047."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2048)
    get_how $P2049, type_obj
    .const 'Sub' $P2050 = "208_1295994649.593" 
    $P2049."add_method"(type_obj, "term:sym<identifier>", $P2050)
    get_how $P2051, type_obj
    get_global $P2052, "!PREFIX__term:sym<identifier>"
    $P2051."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2052)
    get_how $P2053, type_obj
    .const 'Sub' $P2054 = "210_1295994649.593" 
    $P2053."add_method"(type_obj, "term:sym<name>", $P2054)
    get_how $P2055, type_obj
    get_global $P2056, "!PREFIX__term:sym<name>"
    $P2055."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2056)
    get_how $P2057, type_obj
    .const 'Sub' $P2058 = "212_1295994649.593" 
    $P2057."add_method"(type_obj, "term:sym<pir::op>", $P2058)
    get_how $P2059, type_obj
    get_global $P2060, "!PREFIX__term:sym<pir::op>"
    $P2059."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2060)
    get_how $P2061, type_obj
    .const 'Sub' $P2062 = "214_1295994649.593" 
    $P2061."add_method"(type_obj, "term:sym<onlystar>", $P2062)
    get_how $P2063, type_obj
    get_global $P2064, "!PREFIX__term:sym<onlystar>"
    $P2063."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2064)
    get_how $P2065, type_obj
    .const 'Sub' $P2066 = "217_1295994649.593" 
    $P2065."add_method"(type_obj, "args", $P2066)
    get_how $P2067, type_obj
    get_global $P2068, "!PREFIX__args"
    $P2067."add_method"(type_obj, "!PREFIX__args", $P2068)
    get_how $P2069, type_obj
    .const 'Sub' $P2070 = "219_1295994649.593" 
    $P2069."add_method"(type_obj, "arglist", $P2070)
    get_how $P2071, type_obj
    get_global $P2072, "!PREFIX__arglist"
    $P2071."add_method"(type_obj, "!PREFIX__arglist", $P2072)
    get_how $P2073, type_obj
    .const 'Sub' $P2074 = "221_1295994649.593" 
    $P2073."add_method"(type_obj, "term:sym<value>", $P2074)
    get_how $P2075, type_obj
    get_global $P2076, "!PREFIX__term:sym<value>"
    $P2075."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2076)
    get_how $P2077, type_obj
    .const 'Sub' $P2078 = "223_1295994649.593" 
    $P2077."add_method"(type_obj, "value", $P2078)
    get_how $P2079, type_obj
    get_global $P2080, "!PREFIX__value"
    $P2079."add_method"(type_obj, "!PREFIX__value", $P2080)
    get_how $P2081, type_obj
    .const 'Sub' $P2082 = "225_1295994649.593" 
    $P2081."add_method"(type_obj, "number", $P2082)
    get_how $P2083, type_obj
    get_global $P2084, "!PREFIX__number"
    $P2083."add_method"(type_obj, "!PREFIX__number", $P2084)
    get_how $P2085, type_obj
    .const 'Sub' $P2086 = "227_1295994649.593" 
    $P2085."add_method"(type_obj, "quote", $P2086)
    get_how $P2087, type_obj
    .const 'Sub' $P2088 = "228_1295994649.593" 
    $P2087."add_method"(type_obj, "!PREFIX__quote", $P2088)
    get_how $P2089, type_obj
    .const 'Sub' $P2090 = "229_1295994649.593" 
    $P2089."add_method"(type_obj, "quote:sym<apos>", $P2090)
    get_how $P2091, type_obj
    get_global $P2092, "!PREFIX__quote:sym<apos>"
    $P2091."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2092)
    get_how $P2093, type_obj
    .const 'Sub' $P2094 = "231_1295994649.593" 
    $P2093."add_method"(type_obj, "quote:sym<dblq>", $P2094)
    get_how $P2095, type_obj
    get_global $P2096, "!PREFIX__quote:sym<dblq>"
    $P2095."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2096)
    get_how $P2097, type_obj
    .const 'Sub' $P2098 = "233_1295994649.593" 
    $P2097."add_method"(type_obj, "quote:sym<q>", $P2098)
    get_how $P2099, type_obj
    get_global $P2100, "!PREFIX__quote:sym<q>"
    $P2099."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2100)
    get_how $P2101, type_obj
    .const 'Sub' $P2102 = "235_1295994649.593" 
    $P2101."add_method"(type_obj, "quote:sym<qq>", $P2102)
    get_how $P2103, type_obj
    get_global $P2104, "!PREFIX__quote:sym<qq>"
    $P2103."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2104)
    get_how $P2105, type_obj
    .const 'Sub' $P2106 = "237_1295994649.593" 
    $P2105."add_method"(type_obj, "quote:sym<Q>", $P2106)
    get_how $P2107, type_obj
    get_global $P2108, "!PREFIX__quote:sym<Q>"
    $P2107."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2108)
    get_how $P2109, type_obj
    .const 'Sub' $P2110 = "239_1295994649.593" 
    $P2109."add_method"(type_obj, "quote:sym<Q:PIR>", $P2110)
    get_how $P2111, type_obj
    get_global $P2112, "!PREFIX__quote:sym<Q:PIR>"
    $P2111."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2112)
    get_how $P2113, type_obj
    .const 'Sub' $P2114 = "241_1295994649.593" 
    $P2113."add_method"(type_obj, "quote:sym</ />", $P2114)
    get_how $P2115, type_obj
    get_global $P2116, "!PREFIX__quote:sym</ />"
    $P2115."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2116)
    get_how $P2117, type_obj
    .const 'Sub' $P2118 = "243_1295994649.593" 
    $P2117."add_method"(type_obj, "quote_escape:sym<$>", $P2118)
    get_how $P2119, type_obj
    get_global $P2120, "!PREFIX__quote_escape:sym<$>"
    $P2119."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2120)
    get_how $P2121, type_obj
    .const 'Sub' $P2122 = "245_1295994649.593" 
    $P2121."add_method"(type_obj, "quote_escape:sym<{ }>", $P2122)
    get_how $P2123, type_obj
    get_global $P2124, "!PREFIX__quote_escape:sym<{ }>"
    $P2123."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2124)
    get_how $P2125, type_obj
    .const 'Sub' $P2126 = "247_1295994649.593" 
    $P2125."add_method"(type_obj, "quote_escape:sym<esc>", $P2126)
    get_how $P2127, type_obj
    get_global $P2128, "!PREFIX__quote_escape:sym<esc>"
    $P2127."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2128)
    get_how $P2129, type_obj
    .const 'Sub' $P2130 = "249_1295994649.593" 
    $P2129."add_method"(type_obj, "circumfix:sym<( )>", $P2130)
    get_how $P2131, type_obj
    get_global $P2132, "!PREFIX__circumfix:sym<( )>"
    $P2131."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2132)
    get_how $P2133, type_obj
    .const 'Sub' $P2134 = "251_1295994649.593" 
    $P2133."add_method"(type_obj, "circumfix:sym<[ ]>", $P2134)
    get_how $P2135, type_obj
    get_global $P2136, "!PREFIX__circumfix:sym<[ ]>"
    $P2135."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2136)
    get_how $P2137, type_obj
    .const 'Sub' $P2138 = "253_1295994649.593" 
    $P2137."add_method"(type_obj, "circumfix:sym<ang>", $P2138)
    get_how $P2139, type_obj
    get_global $P2140, "!PREFIX__circumfix:sym<ang>"
    $P2139."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2140)
    get_how $P2141, type_obj
    .const 'Sub' $P2142 = "255_1295994649.593" 
    $P2141."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2142)
    get_how $P2143, type_obj
    get_global $P2144, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2143."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2144)
    get_how $P2145, type_obj
    .const 'Sub' $P2146 = "257_1295994649.593" 
    $P2145."add_method"(type_obj, "circumfix:sym<{ }>", $P2146)
    get_how $P2147, type_obj
    get_global $P2148, "!PREFIX__circumfix:sym<{ }>"
    $P2147."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2148)
    get_how $P2149, type_obj
    .const 'Sub' $P2150 = "259_1295994649.593" 
    $P2149."add_method"(type_obj, "circumfix:sym<sigil>", $P2150)
    get_how $P2151, type_obj
    get_global $P2152, "!PREFIX__circumfix:sym<sigil>"
    $P2151."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2152)
    get_how $P2153, type_obj
    .const 'Sub' $P2154 = "261_1295994649.593" 
    $P2153."add_method"(type_obj, "semilist", $P2154)
    get_how $P2155, type_obj
    get_global $P2156, "!PREFIX__semilist"
    $P2155."add_method"(type_obj, "!PREFIX__semilist", $P2156)
    get_how $P2157, type_obj
    .const 'Sub' $P2158 = "264_1295994649.593" 
    $P2157."add_method"(type_obj, "infixish", $P2158)
    get_how $P2159, type_obj
    get_global $P2160, "!PREFIX__infixish"
    $P2159."add_method"(type_obj, "!PREFIX__infixish", $P2160)
    get_how $P2161, type_obj
    .const 'Sub' $P2162 = "266_1295994649.593" 
    $P2161."add_method"(type_obj, "infixstopper", $P2162)
    get_how $P2163, type_obj
    get_global $P2164, "!PREFIX__infixstopper"
    $P2163."add_method"(type_obj, "!PREFIX__infixstopper", $P2164)
    get_how $P2165, type_obj
    .const 'Sub' $P2166 = "268_1295994649.593" 
    $P2165."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2166)
    get_how $P2167, type_obj
    get_global $P2168, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2167."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2168)
    get_how $P2169, type_obj
    .const 'Sub' $P2170 = "270_1295994649.593" 
    $P2169."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2170)
    get_how $P2171, type_obj
    get_global $P2172, "!PREFIX__postcircumfix:sym<{ }>"
    $P2171."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2172)
    get_how $P2173, type_obj
    .const 'Sub' $P2174 = "272_1295994649.593" 
    $P2173."add_method"(type_obj, "postcircumfix:sym<ang>", $P2174)
    get_how $P2175, type_obj
    get_global $P2176, "!PREFIX__postcircumfix:sym<ang>"
    $P2175."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2176)
    get_how $P2177, type_obj
    .const 'Sub' $P2178 = "274_1295994649.593" 
    $P2177."add_method"(type_obj, "postcircumfix:sym<( )>", $P2178)
    get_how $P2179, type_obj
    get_global $P2180, "!PREFIX__postcircumfix:sym<( )>"
    $P2179."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2180)
    get_how $P2181, type_obj
    .const 'Sub' $P2182 = "276_1295994649.593" 
    $P2181."add_method"(type_obj, "postfix:sym<.>", $P2182)
    get_how $P2183, type_obj
    get_global $P2184, "!PREFIX__postfix:sym<.>"
    $P2183."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2184)
    get_how $P2185, type_obj
    .const 'Sub' $P2186 = "278_1295994649.593" 
    $P2185."add_method"(type_obj, "prefix:sym<++>", $P2186)
    get_how $P2187, type_obj
    get_global $P2188, "!PREFIX__prefix:sym<++>"
    $P2187."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2188)
    get_how $P2189, type_obj
    .const 'Sub' $P2190 = "280_1295994649.593" 
    $P2189."add_method"(type_obj, "prefix:sym<-->", $P2190)
    get_how $P2191, type_obj
    get_global $P2192, "!PREFIX__prefix:sym<-->"
    $P2191."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2192)
    get_how $P2193, type_obj
    .const 'Sub' $P2194 = "282_1295994649.593" 
    $P2193."add_method"(type_obj, "postfix:sym<++>", $P2194)
    get_how $P2195, type_obj
    get_global $P2196, "!PREFIX__postfix:sym<++>"
    $P2195."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2196)
    get_how $P2197, type_obj
    .const 'Sub' $P2198 = "284_1295994649.593" 
    $P2197."add_method"(type_obj, "postfix:sym<-->", $P2198)
    get_how $P2199, type_obj
    get_global $P2200, "!PREFIX__postfix:sym<-->"
    $P2199."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2200)
    get_how $P2201, type_obj
    .const 'Sub' $P2202 = "286_1295994649.593" 
    $P2201."add_method"(type_obj, "infix:sym<**>", $P2202)
    get_how $P2203, type_obj
    get_global $P2204, "!PREFIX__infix:sym<**>"
    $P2203."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2204)
    get_how $P2205, type_obj
    .const 'Sub' $P2206 = "288_1295994649.593" 
    $P2205."add_method"(type_obj, "prefix:sym<+>", $P2206)
    get_how $P2207, type_obj
    get_global $P2208, "!PREFIX__prefix:sym<+>"
    $P2207."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2208)
    get_how $P2209, type_obj
    .const 'Sub' $P2210 = "290_1295994649.593" 
    $P2209."add_method"(type_obj, "prefix:sym<~>", $P2210)
    get_how $P2211, type_obj
    get_global $P2212, "!PREFIX__prefix:sym<~>"
    $P2211."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2212)
    get_how $P2213, type_obj
    .const 'Sub' $P2214 = "292_1295994649.593" 
    $P2213."add_method"(type_obj, "prefix:sym<->", $P2214)
    get_how $P2215, type_obj
    get_global $P2216, "!PREFIX__prefix:sym<->"
    $P2215."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2216)
    get_how $P2217, type_obj
    .const 'Sub' $P2218 = "294_1295994649.593" 
    $P2217."add_method"(type_obj, "prefix:sym<?>", $P2218)
    get_how $P2219, type_obj
    get_global $P2220, "!PREFIX__prefix:sym<?>"
    $P2219."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2220)
    get_how $P2221, type_obj
    .const 'Sub' $P2222 = "296_1295994649.593" 
    $P2221."add_method"(type_obj, "prefix:sym<!>", $P2222)
    get_how $P2223, type_obj
    get_global $P2224, "!PREFIX__prefix:sym<!>"
    $P2223."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2224)
    get_how $P2225, type_obj
    .const 'Sub' $P2226 = "298_1295994649.593" 
    $P2225."add_method"(type_obj, "prefix:sym<|>", $P2226)
    get_how $P2227, type_obj
    get_global $P2228, "!PREFIX__prefix:sym<|>"
    $P2227."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2228)
    get_how $P2229, type_obj
    .const 'Sub' $P2230 = "300_1295994649.593" 
    $P2229."add_method"(type_obj, "infix:sym<*>", $P2230)
    get_how $P2231, type_obj
    get_global $P2232, "!PREFIX__infix:sym<*>"
    $P2231."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2232)
    get_how $P2233, type_obj
    .const 'Sub' $P2234 = "302_1295994649.593" 
    $P2233."add_method"(type_obj, "infix:sym</>", $P2234)
    get_how $P2235, type_obj
    get_global $P2236, "!PREFIX__infix:sym</>"
    $P2235."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2236)
    get_how $P2237, type_obj
    .const 'Sub' $P2238 = "304_1295994649.593" 
    $P2237."add_method"(type_obj, "infix:sym<%>", $P2238)
    get_how $P2239, type_obj
    get_global $P2240, "!PREFIX__infix:sym<%>"
    $P2239."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2240)
    get_how $P2241, type_obj
    .const 'Sub' $P2242 = "306_1295994649.593" 
    $P2241."add_method"(type_obj, "infix:sym<+&>", $P2242)
    get_how $P2243, type_obj
    get_global $P2244, "!PREFIX__infix:sym<+&>"
    $P2243."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2244)
    get_how $P2245, type_obj
    .const 'Sub' $P2246 = "308_1295994649.593" 
    $P2245."add_method"(type_obj, "infix:sym<+>", $P2246)
    get_how $P2247, type_obj
    get_global $P2248, "!PREFIX__infix:sym<+>"
    $P2247."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2248)
    get_how $P2249, type_obj
    .const 'Sub' $P2250 = "310_1295994649.593" 
    $P2249."add_method"(type_obj, "infix:sym<->", $P2250)
    get_how $P2251, type_obj
    get_global $P2252, "!PREFIX__infix:sym<->"
    $P2251."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2252)
    get_how $P2253, type_obj
    .const 'Sub' $P2254 = "312_1295994649.593" 
    $P2253."add_method"(type_obj, "infix:sym<+|>", $P2254)
    get_how $P2255, type_obj
    get_global $P2256, "!PREFIX__infix:sym<+|>"
    $P2255."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2256)
    get_how $P2257, type_obj
    .const 'Sub' $P2258 = "314_1295994649.593" 
    $P2257."add_method"(type_obj, "infix:sym<+^>", $P2258)
    get_how $P2259, type_obj
    get_global $P2260, "!PREFIX__infix:sym<+^>"
    $P2259."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2260)
    get_how $P2261, type_obj
    .const 'Sub' $P2262 = "316_1295994649.593" 
    $P2261."add_method"(type_obj, "infix:sym<~>", $P2262)
    get_how $P2263, type_obj
    get_global $P2264, "!PREFIX__infix:sym<~>"
    $P2263."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2264)
    get_how $P2265, type_obj
    .const 'Sub' $P2266 = "318_1295994649.593" 
    $P2265."add_method"(type_obj, "infix:sym<==>", $P2266)
    get_how $P2267, type_obj
    get_global $P2268, "!PREFIX__infix:sym<==>"
    $P2267."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2268)
    get_how $P2269, type_obj
    .const 'Sub' $P2270 = "320_1295994649.593" 
    $P2269."add_method"(type_obj, "infix:sym<!=>", $P2270)
    get_how $P2271, type_obj
    get_global $P2272, "!PREFIX__infix:sym<!=>"
    $P2271."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2272)
    get_how $P2273, type_obj
    .const 'Sub' $P2274 = "322_1295994649.593" 
    $P2273."add_method"(type_obj, "infix:sym<<=>", $P2274)
    get_how $P2275, type_obj
    get_global $P2276, "!PREFIX__infix:sym<<=>"
    $P2275."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2276)
    get_how $P2277, type_obj
    .const 'Sub' $P2278 = "324_1295994649.593" 
    $P2277."add_method"(type_obj, "infix:sym<>=>", $P2278)
    get_how $P2279, type_obj
    get_global $P2280, "!PREFIX__infix:sym<>=>"
    $P2279."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2280)
    get_how $P2281, type_obj
    .const 'Sub' $P2282 = "326_1295994649.593" 
    $P2281."add_method"(type_obj, "infix:sym<<>", $P2282)
    get_how $P2283, type_obj
    get_global $P2284, "!PREFIX__infix:sym<<>"
    $P2283."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2284)
    get_how $P2285, type_obj
    .const 'Sub' $P2286 = "328_1295994649.593" 
    $P2285."add_method"(type_obj, "infix:sym<>>", $P2286)
    get_how $P2287, type_obj
    get_global $P2288, "!PREFIX__infix:sym<>>"
    $P2287."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2288)
    get_how $P2289, type_obj
    .const 'Sub' $P2290 = "330_1295994649.593" 
    $P2289."add_method"(type_obj, "infix:sym<eq>", $P2290)
    get_how $P2291, type_obj
    get_global $P2292, "!PREFIX__infix:sym<eq>"
    $P2291."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2292)
    get_how $P2293, type_obj
    .const 'Sub' $P2294 = "332_1295994649.593" 
    $P2293."add_method"(type_obj, "infix:sym<ne>", $P2294)
    get_how $P2295, type_obj
    get_global $P2296, "!PREFIX__infix:sym<ne>"
    $P2295."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2296)
    get_how $P2297, type_obj
    .const 'Sub' $P2298 = "334_1295994649.593" 
    $P2297."add_method"(type_obj, "infix:sym<le>", $P2298)
    get_how $P2299, type_obj
    get_global $P2300, "!PREFIX__infix:sym<le>"
    $P2299."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2300)
    get_how $P2301, type_obj
    .const 'Sub' $P2302 = "336_1295994649.593" 
    $P2301."add_method"(type_obj, "infix:sym<ge>", $P2302)
    get_how $P2303, type_obj
    get_global $P2304, "!PREFIX__infix:sym<ge>"
    $P2303."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2304)
    get_how $P2305, type_obj
    .const 'Sub' $P2306 = "338_1295994649.593" 
    $P2305."add_method"(type_obj, "infix:sym<lt>", $P2306)
    get_how $P2307, type_obj
    get_global $P2308, "!PREFIX__infix:sym<lt>"
    $P2307."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2308)
    get_how $P2309, type_obj
    .const 'Sub' $P2310 = "340_1295994649.593" 
    $P2309."add_method"(type_obj, "infix:sym<gt>", $P2310)
    get_how $P2311, type_obj
    get_global $P2312, "!PREFIX__infix:sym<gt>"
    $P2311."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2312)
    get_how $P2313, type_obj
    .const 'Sub' $P2314 = "342_1295994649.593" 
    $P2313."add_method"(type_obj, "infix:sym<=:=>", $P2314)
    get_how $P2315, type_obj
    get_global $P2316, "!PREFIX__infix:sym<=:=>"
    $P2315."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2316)
    get_how $P2317, type_obj
    .const 'Sub' $P2318 = "344_1295994649.593" 
    $P2317."add_method"(type_obj, "infix:sym<~~>", $P2318)
    get_how $P2319, type_obj
    get_global $P2320, "!PREFIX__infix:sym<~~>"
    $P2319."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2320)
    get_how $P2321, type_obj
    .const 'Sub' $P2322 = "346_1295994649.593" 
    $P2321."add_method"(type_obj, "infix:sym<&&>", $P2322)
    get_how $P2323, type_obj
    get_global $P2324, "!PREFIX__infix:sym<&&>"
    $P2323."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2324)
    get_how $P2325, type_obj
    .const 'Sub' $P2326 = "348_1295994649.593" 
    $P2325."add_method"(type_obj, "infix:sym<||>", $P2326)
    get_how $P2327, type_obj
    get_global $P2328, "!PREFIX__infix:sym<||>"
    $P2327."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2328)
    get_how $P2329, type_obj
    .const 'Sub' $P2330 = "350_1295994649.593" 
    $P2329."add_method"(type_obj, "infix:sym<//>", $P2330)
    get_how $P2331, type_obj
    get_global $P2332, "!PREFIX__infix:sym<//>"
    $P2331."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2332)
    get_how $P2333, type_obj
    .const 'Sub' $P2334 = "352_1295994649.593" 
    $P2333."add_method"(type_obj, "infix:sym<?? !!>", $P2334)
    get_how $P2335, type_obj
    get_global $P2336, "!PREFIX__infix:sym<?? !!>"
    $P2335."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2336)
    get_how $P2337, type_obj
    .const 'Sub' $P2338 = "354_1295994649.593" 
    $P2337."add_method"(type_obj, "infix:sym<=>", $P2338)
    get_how $P2339, type_obj
    get_global $P2340, "!PREFIX__infix:sym<=>"
    $P2339."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2340)
    get_how $P2341, type_obj
    .const 'Sub' $P2342 = "356_1295994649.593" 
    $P2341."add_method"(type_obj, "infix:sym<:=>", $P2342)
    get_how $P2343, type_obj
    get_global $P2344, "!PREFIX__infix:sym<:=>"
    $P2343."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2344)
    get_how $P2345, type_obj
    .const 'Sub' $P2346 = "358_1295994649.593" 
    $P2345."add_method"(type_obj, "infix:sym<::=>", $P2346)
    get_how $P2347, type_obj
    get_global $P2348, "!PREFIX__infix:sym<::=>"
    $P2347."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2348)
    get_how $P2349, type_obj
    .const 'Sub' $P2350 = "360_1295994649.593" 
    $P2349."add_method"(type_obj, "infix:sym<,>", $P2350)
    get_how $P2351, type_obj
    get_global $P2352, "!PREFIX__infix:sym<,>"
    $P2351."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2352)
    get_how $P2353, type_obj
    .const 'Sub' $P2354 = "362_1295994649.593" 
    $P2353."add_method"(type_obj, "prefix:sym<return>", $P2354)
    get_how $P2355, type_obj
    get_global $P2356, "!PREFIX__prefix:sym<return>"
    $P2355."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2356)
    get_how $P2357, type_obj
    .const 'Sub' $P2358 = "365_1295994649.593" 
    $P2357."add_method"(type_obj, "prefix:sym<make>", $P2358)
    get_how $P2359, type_obj
    get_global $P2360, "!PREFIX__prefix:sym<make>"
    $P2359."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2360)
    get_how $P2361, type_obj
    .const 'Sub' $P2362 = "367_1295994649.593" 
    $P2361."add_method"(type_obj, "term:sym<last>", $P2362)
    get_how $P2363, type_obj
    get_global $P2364, "!PREFIX__term:sym<last>"
    $P2363."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2364)
    get_how $P2365, type_obj
    .const 'Sub' $P2366 = "369_1295994649.593" 
    $P2365."add_method"(type_obj, "term:sym<next>", $P2366)
    get_how $P2367, type_obj
    get_global $P2368, "!PREFIX__term:sym<next>"
    $P2367."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2368)
    get_how $P2369, type_obj
    .const 'Sub' $P2370 = "371_1295994649.593" 
    $P2369."add_method"(type_obj, "term:sym<redo>", $P2370)
    get_how $P2371, type_obj
    get_global $P2372, "!PREFIX__term:sym<redo>"
    $P2371."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2372)
    get_how $P2373, type_obj
    .const 'Sub' $P2374 = "373_1295994649.593" 
    $P2373."add_method"(type_obj, "smartmatch", $P2374)
    get_how $P2375, type_obj
    get_hll_global $P2376, ["HLL"], "Grammar"
    $P2375."add_parent"(type_obj, $P2376)
    get_how $P2377, type_obj
    $P2378 = $P2377."compose"(type_obj)
    .return ($P2378)
.end


.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1295994649.593") :outer("11_1295994649.593")
    .param pmc param_19
.annotate 'line', 4
    .lex "self", param_19
.annotate 'line', 5
    $P20 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P20
.annotate 'line', 12
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P21
.annotate 'line', 19
    new $P22, "Undef"
    .lex "$*DEFAULT-METAATTR", $P22
.annotate 'line', 20
    $P23 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P23
.annotate 'line', 23
    new $P24, "Undef"
    .lex "$*SCOPE", $P24
.annotate 'line', 24
    new $P25, "Undef"
    .lex "$*MULTINESS", $P25
.annotate 'line', 25
    new $P26, "Undef"
    .lex "$*INVOCANT_OK", $P26
.annotate 'line', 26
    new $P27, "Undef"
    .lex "$*RETURN_USED", $P27
.annotate 'line', 27
    new $P28, "Undef"
    .lex "$*PACKAGE-SETUP", $P28
.annotate 'line', 4
    find_lex $P29, "%*LANG"
    unless_null $P29, vivify_400
    get_hll_global $P29, "%LANG"
    unless_null $P29, vivify_401
    die "Contextual %*LANG not found"
  vivify_401:
  vivify_400:
.annotate 'line', 6
    get_hll_global $P30, ["NQP"], "Regex"
    find_lex $P31, "%*LANG"
    unless_null $P31, vivify_402
    get_hll_global $P31, "%LANG"
    unless_null $P31, vivify_403
    die "Contextual %*LANG not found"
  vivify_403:
    store_lex "%*LANG", $P31
  vivify_402:
    set $P31["Regex"], $P30
.annotate 'line', 7
    get_hll_global $P32, ["NQP"], "RegexActions"
    find_lex $P33, "%*LANG"
    unless_null $P33, vivify_404
    get_hll_global $P33, "%LANG"
    unless_null $P33, vivify_405
    die "Contextual %*LANG not found"
  vivify_405:
    store_lex "%*LANG", $P33
  vivify_404:
    set $P33["Regex-actions"], $P32
.annotate 'line', 8
    get_hll_global $P34, ["NQP"], "Grammar"
    find_lex $P35, "%*LANG"
    unless_null $P35, vivify_406
    get_hll_global $P35, "%LANG"
    unless_null $P35, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
    store_lex "%*LANG", $P35
  vivify_406:
    set $P35["MAIN"], $P34
.annotate 'line', 9
    get_hll_global $P36, ["NQP"], "Actions"
    find_lex $P37, "%*LANG"
    unless_null $P37, vivify_408
    get_hll_global $P37, "%LANG"
    unless_null $P37, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P37
  vivify_408:
    set $P37["MAIN-actions"], $P36
    find_lex $P38, "%*HOW"
    unless_null $P38, vivify_410
    get_hll_global $P38, "%HOW"
    unless_null $P38, vivify_411
    die "Contextual %*HOW not found"
  vivify_411:
  vivify_410:
.annotate 'line', 13
    new $P39, "String"
    assign $P39, "KnowHOW"
    find_lex $P40, "%*HOW"
    unless_null $P40, vivify_412
    get_hll_global $P40, "%HOW"
    unless_null $P40, vivify_413
    die "Contextual %*HOW not found"
  vivify_413:
    store_lex "%*HOW", $P40
  vivify_412:
    set $P40["knowhow"], $P39
.annotate 'line', 14
    new $P41, "String"
    assign $P41, "NQPClassHOW"
    find_lex $P42, "%*HOW"
    unless_null $P42, vivify_414
    get_hll_global $P42, "%HOW"
    unless_null $P42, vivify_415
    die "Contextual %*HOW not found"
  vivify_415:
    store_lex "%*HOW", $P42
  vivify_414:
    set $P42["class"], $P41
.annotate 'line', 15
    new $P43, "String"
    assign $P43, "NQPClassHOW"
    find_lex $P44, "%*HOW"
    unless_null $P44, vivify_416
    get_hll_global $P44, "%HOW"
    unless_null $P44, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
    store_lex "%*HOW", $P44
  vivify_416:
    set $P44["grammar"], $P43
.annotate 'line', 16
    new $P45, "String"
    assign $P45, "NQPRoleHOW"
    find_lex $P46, "%*HOW"
    unless_null $P46, vivify_418
    get_hll_global $P46, "%HOW"
    unless_null $P46, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P46
  vivify_418:
    set $P46["role"], $P45
.annotate 'line', 19
    new $P47, "String"
    assign $P47, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P47
    find_lex $P48, "%*HOW-METAATTR"
    unless_null $P48, vivify_420
    get_hll_global $P48, "%HOW-METAATTR"
    unless_null $P48, vivify_421
    die "Contextual %*HOW-METAATTR not found"
  vivify_421:
  vivify_420:
.annotate 'line', 21
    new $P49, "String"
    assign $P49, "KnowHOWAttribute"
    find_lex $P50, "%*HOW-METAATTR"
    unless_null $P50, vivify_422
    get_hll_global $P50, "%HOW-METAATTR"
    unless_null $P50, vivify_423
    die "Contextual %*HOW-METAATTR not found"
  vivify_423:
    store_lex "%*HOW-METAATTR", $P50
  vivify_422:
    set $P50["knowhow"], $P49
.annotate 'line', 23
    new $P51, "String"
    assign $P51, ""
    store_lex "$*SCOPE", $P51
.annotate 'line', 24
    new $P52, "String"
    assign $P52, ""
    store_lex "$*MULTINESS", $P52
.annotate 'line', 25
    new $P53, "Integer"
    assign $P53, 0
    store_lex "$*INVOCANT_OK", $P53
.annotate 'line', 26
    new $P54, "Integer"
    assign $P54, 0
    store_lex "$*RETURN_USED", $P54
    find_lex $P55, "$*PACKAGE-SETUP"
    unless_null $P55, vivify_424
    get_hll_global $P55, "$PACKAGE-SETUP"
    unless_null $P55, vivify_425
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_425:
  vivify_424:
.annotate 'line', 28
    find_lex $P56, "self"
    $P57 = $P56."comp_unit"()
.annotate 'line', 4
    .return ($P57)
.end


.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx59_tgt
    .local int rx59_pos
    .local int rx59_off
    .local int rx59_eos
    .local int rx59_rep
    .local pmc rx59_cur
    .local pmc rx59_debug
    (rx59_cur, rx59_pos, rx59_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx59_cur
    .local pmc match
    .lex "$/", match
    length rx59_eos, rx59_tgt
    gt rx59_pos, rx59_eos, rx59_done
    set rx59_off, 0
    lt rx59_pos, 2, rx59_start
    sub rx59_off, rx59_pos, 1
    substr rx59_tgt, rx59_tgt, rx59_off
  rx59_start:
    eq $I10, 1, rx59_restart
    if_null rx59_debug, debug_426
    rx59_cur."!cursor_debug"("START", "identifier")
  debug_426:
    $I10 = self.'from'()
    ne $I10, -1, rxscan63_done
    goto rxscan63_scan
  rxscan63_loop:
    ($P10) = rx59_cur."from"()
    inc $P10
    set rx59_pos, $P10
    ge rx59_pos, rx59_eos, rxscan63_done
  rxscan63_scan:
    set_addr $I10, rxscan63_loop
    rx59_cur."!mark_push"(0, rx59_pos, $I10)
  rxscan63_done:
.annotate 'line', 33
  # rx subrule "ident" subtype=method negate=
    rx59_cur."!cursor_pos"(rx59_pos)
    $P10 = rx59_cur."ident"()
    unless $P10, rx59_fail
    rx59_pos = $P10."pos"()
  # rx rxquantr64 ** 0..*
    set_addr $I10, rxquantr64_done
    rx59_cur."!mark_push"(0, rx59_pos, $I10)
  rxquantr64_loop:
  # rx enumcharlist negate=0 
    ge rx59_pos, rx59_eos, rx59_fail
    sub $I10, rx59_pos, rx59_off
    substr $S10, rx59_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx59_fail
    inc rx59_pos
  # rx subrule "ident" subtype=method negate=
    rx59_cur."!cursor_pos"(rx59_pos)
    $P10 = rx59_cur."ident"()
    unless $P10, rx59_fail
    rx59_pos = $P10."pos"()
    set_addr $I10, rxquantr64_done
    (rx59_rep) = rx59_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr64_done
    rx59_cur."!mark_push"(rx59_rep, rx59_pos, $I10)
    goto rxquantr64_loop
  rxquantr64_done:
  # rx pass
    rx59_cur."!cursor_pass"(rx59_pos, "identifier")
    if_null rx59_debug, debug_427
    rx59_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx59_pos)
  debug_427:
    .return (rx59_cur)
  rx59_restart:
.annotate 'line', 4
    if_null rx59_debug, debug_428
    rx59_cur."!cursor_debug"("NEXT", "identifier")
  debug_428:
  rx59_fail:
    (rx59_rep, rx59_pos, $I10, $P10) = rx59_cur."!mark_fail"(0)
    lt rx59_pos, -1, rx59_done
    eq rx59_pos, -1, rx59_fail
    jump $I10
  rx59_done:
    rx59_cur."!cursor_fail"()
    if_null rx59_debug, debug_429
    rx59_cur."!cursor_debug"("FAIL", "identifier")
  debug_429:
    .return (rx59_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1295994649.593") :method
.annotate 'line', 4
    $P61 = self."!PREFIX__!subrule"("ident", "")
    new $P62, "ResizablePMCArray"
    push $P62, $P61
    .return ($P62)
.end


.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx66_tgt
    .local int rx66_pos
    .local int rx66_off
    .local int rx66_eos
    .local int rx66_rep
    .local pmc rx66_cur
    .local pmc rx66_debug
    (rx66_cur, rx66_pos, rx66_tgt, $I10) = self."!cursor_start"()
    rx66_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx66_cur
    .local pmc match
    .lex "$/", match
    length rx66_eos, rx66_tgt
    gt rx66_pos, rx66_eos, rx66_done
    set rx66_off, 0
    lt rx66_pos, 2, rx66_start
    sub rx66_off, rx66_pos, 1
    substr rx66_tgt, rx66_tgt, rx66_off
  rx66_start:
    eq $I10, 1, rx66_restart
    if_null rx66_debug, debug_430
    rx66_cur."!cursor_debug"("START", "name")
  debug_430:
    $I10 = self.'from'()
    ne $I10, -1, rxscan69_done
    goto rxscan69_scan
  rxscan69_loop:
    ($P10) = rx66_cur."from"()
    inc $P10
    set rx66_pos, $P10
    ge rx66_pos, rx66_eos, rxscan69_done
  rxscan69_scan:
    set_addr $I10, rxscan69_loop
    rx66_cur."!mark_push"(0, rx66_pos, $I10)
  rxscan69_done:
.annotate 'line', 35
  # rx rxquantr70 ** 1..*
    set_addr $I10, rxquantr70_done
    rx66_cur."!mark_push"(0, -1, $I10)
  rxquantr70_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx66_cur."!cursor_pos"(rx66_pos)
    $P10 = rx66_cur."identifier"()
    unless $P10, rx66_fail
    goto rxsubrule71_pass
  rxsubrule71_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx66_fail
  rxsubrule71_pass:
    set_addr $I10, rxsubrule71_back
    rx66_cur."!mark_push"(0, rx66_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx66_pos = $P10."pos"()
    set_addr $I10, rxquantr70_done
    (rx66_rep) = rx66_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr70_done
    rx66_cur."!mark_push"(rx66_rep, rx66_pos, $I10)
  # rx literal  "::"
    add $I11, rx66_pos, 2
    gt $I11, rx66_eos, rx66_fail
    sub $I11, rx66_pos, rx66_off
    substr $S10, rx66_tgt, $I11, 2
    ne $S10, "::", rx66_fail
    add rx66_pos, 2
    goto rxquantr70_loop
  rxquantr70_done:
  # rx pass
    rx66_cur."!cursor_pass"(rx66_pos, "name")
    if_null rx66_debug, debug_431
    rx66_cur."!cursor_debug"("PASS", "name", " at pos=", rx66_pos)
  debug_431:
    .return (rx66_cur)
  rx66_restart:
.annotate 'line', 4
    if_null rx66_debug, debug_432
    rx66_cur."!cursor_debug"("NEXT", "name")
  debug_432:
  rx66_fail:
    (rx66_rep, rx66_pos, $I10, $P10) = rx66_cur."!mark_fail"(0)
    lt rx66_pos, -1, rx66_done
    eq rx66_pos, -1, rx66_fail
    jump $I10
  rx66_done:
    rx66_cur."!cursor_fail"()
    if_null rx66_debug, debug_433
    rx66_cur."!cursor_debug"("FAIL", "name")
  debug_433:
    .return (rx66_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1295994649.593") :method
.annotate 'line', 4
    new $P68, "ResizablePMCArray"
    push $P68, ""
    .return ($P68)
.end


.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx73_tgt
    .local int rx73_pos
    .local int rx73_off
    .local int rx73_eos
    .local int rx73_rep
    .local pmc rx73_cur
    .local pmc rx73_debug
    (rx73_cur, rx73_pos, rx73_tgt, $I10) = self."!cursor_start"()
    rx73_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx73_cur
    .local pmc match
    .lex "$/", match
    length rx73_eos, rx73_tgt
    gt rx73_pos, rx73_eos, rx73_done
    set rx73_off, 0
    lt rx73_pos, 2, rx73_start
    sub rx73_off, rx73_pos, 1
    substr rx73_tgt, rx73_tgt, rx73_off
  rx73_start:
    eq $I10, 1, rx73_restart
    if_null rx73_debug, debug_434
    rx73_cur."!cursor_debug"("START", "deflongname")
  debug_434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan77_done
    goto rxscan77_scan
  rxscan77_loop:
    ($P10) = rx73_cur."from"()
    inc $P10
    set rx73_pos, $P10
    ge rx73_pos, rx73_eos, rxscan77_done
  rxscan77_scan:
    set_addr $I10, rxscan77_loop
    rx73_cur."!mark_push"(0, rx73_pos, $I10)
  rxscan77_done:
.annotate 'line', 38
  # rx subrule "identifier" subtype=capture negate=
    rx73_cur."!cursor_pos"(rx73_pos)
    $P10 = rx73_cur."identifier"()
    unless $P10, rx73_fail
    rx73_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx73_pos = $P10."pos"()
  # rx rxquantr78 ** 0..1
    set_addr $I10, rxquantr78_done
    rx73_cur."!mark_push"(0, rx73_pos, $I10)
  rxquantr78_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx73_cur."!cursor_pos"(rx73_pos)
    $P10 = rx73_cur."colonpair"()
    unless $P10, rx73_fail
    goto rxsubrule79_pass
  rxsubrule79_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx73_fail
  rxsubrule79_pass:
    set_addr $I10, rxsubrule79_back
    rx73_cur."!mark_push"(0, rx73_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx73_pos = $P10."pos"()
    set_addr $I10, rxquantr78_done
    (rx73_rep) = rx73_cur."!mark_commit"($I10)
  rxquantr78_done:
.annotate 'line', 37
  # rx pass
    rx73_cur."!cursor_pass"(rx73_pos, "deflongname")
    if_null rx73_debug, debug_435
    rx73_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx73_pos)
  debug_435:
    .return (rx73_cur)
  rx73_restart:
.annotate 'line', 4
    if_null rx73_debug, debug_436
    rx73_cur."!cursor_debug"("NEXT", "deflongname")
  debug_436:
  rx73_fail:
    (rx73_rep, rx73_pos, $I10, $P10) = rx73_cur."!mark_fail"(0)
    lt rx73_pos, -1, rx73_done
    eq rx73_pos, -1, rx73_fail
    jump $I10
  rx73_done:
    rx73_cur."!cursor_fail"()
    if_null rx73_debug, debug_437
    rx73_cur."!cursor_debug"("FAIL", "deflongname")
  debug_437:
    .return (rx73_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1295994649.593") :method
.annotate 'line', 4
    $P75 = self."!PREFIX__!subrule"("identifier", "")
    new $P76, "ResizablePMCArray"
    push $P76, $P75
    .return ($P76)
.end


.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx81_tgt
    .local int rx81_pos
    .local int rx81_off
    .local int rx81_eos
    .local int rx81_rep
    .local pmc rx81_cur
    .local pmc rx81_debug
    (rx81_cur, rx81_pos, rx81_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx81_cur
    .local pmc match
    .lex "$/", match
    length rx81_eos, rx81_tgt
    gt rx81_pos, rx81_eos, rx81_done
    set rx81_off, 0
    lt rx81_pos, 2, rx81_start
    sub rx81_off, rx81_pos, 1
    substr rx81_tgt, rx81_tgt, rx81_off
  rx81_start:
    eq $I10, 1, rx81_restart
    if_null rx81_debug, debug_438
    rx81_cur."!cursor_debug"("START", "ENDSTMT")
  debug_438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan84_done
    goto rxscan84_scan
  rxscan84_loop:
    ($P10) = rx81_cur."from"()
    inc $P10
    set rx81_pos, $P10
    ge rx81_pos, rx81_eos, rxscan84_done
  rxscan84_scan:
    set_addr $I10, rxscan84_loop
    rx81_cur."!mark_push"(0, rx81_pos, $I10)
  rxscan84_done:
.annotate 'line', 45
  # rx rxquantr85 ** 0..1
    set_addr $I10, rxquantr85_done
    rx81_cur."!mark_push"(0, rx81_pos, $I10)
  rxquantr85_loop:
  alt86_0:
.annotate 'line', 42
    set_addr $I10, alt86_1
    rx81_cur."!mark_push"(0, rx81_pos, $I10)
.annotate 'line', 43
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx81_pos, rx81_off
    set rx81_rep, 0
    sub $I12, rx81_eos, rx81_pos
  rxenumcharlistq87_loop:
    le $I12, 0, rxenumcharlistq87_done
    substr $S10, rx81_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq87_done
    inc rx81_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq87_loop
  rxenumcharlistq87_done:
    add rx81_pos, rx81_pos, rx81_rep
  # rxanchor eol
    sub $I10, rx81_pos, rx81_off
    is_cclass $I11, 4096, rx81_tgt, $I10
    if $I11, rxanchor88_done
    ne rx81_pos, rx81_eos, rx81_fail
    eq rx81_pos, 0, rxanchor88_done
    dec $I10
    is_cclass $I11, 4096, rx81_tgt, $I10
    if $I11, rx81_fail
  rxanchor88_done:
  # rx subrule "ws" subtype=method negate=
    rx81_cur."!cursor_pos"(rx81_pos)
    $P10 = rx81_cur."ws"()
    unless $P10, rx81_fail
    rx81_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx81_cur."!cursor_pos"(rx81_pos)
    $P10 = rx81_cur."MARKER"("endstmt")
    unless $P10, rx81_fail
    goto alt86_end
  alt86_1:
.annotate 'line', 44
  # rx rxquantr89 ** 0..1
    set_addr $I10, rxquantr89_done
    rx81_cur."!mark_push"(0, rx81_pos, $I10)
  rxquantr89_loop:
  # rx subrule "unv" subtype=method negate=
    rx81_cur."!cursor_pos"(rx81_pos)
    $P10 = rx81_cur."unv"()
    unless $P10, rx81_fail
    goto rxsubrule90_pass
  rxsubrule90_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx81_fail
  rxsubrule90_pass:
    set_addr $I10, rxsubrule90_back
    rx81_cur."!mark_push"(0, rx81_pos, $I10, $P10)
    rx81_pos = $P10."pos"()
    set_addr $I10, rxquantr89_done
    (rx81_rep) = rx81_cur."!mark_commit"($I10)
  rxquantr89_done:
  # rxanchor eol
    sub $I10, rx81_pos, rx81_off
    is_cclass $I11, 4096, rx81_tgt, $I10
    if $I11, rxanchor91_done
    ne rx81_pos, rx81_eos, rx81_fail
    eq rx81_pos, 0, rxanchor91_done
    dec $I10
    is_cclass $I11, 4096, rx81_tgt, $I10
    if $I11, rx81_fail
  rxanchor91_done:
  # rx subrule "ws" subtype=method negate=
    rx81_cur."!cursor_pos"(rx81_pos)
    $P10 = rx81_cur."ws"()
    unless $P10, rx81_fail
    rx81_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx81_cur."!cursor_pos"(rx81_pos)
    $P10 = rx81_cur."MARKER"("endstmt")
    unless $P10, rx81_fail
  alt86_end:
.annotate 'line', 45
    set_addr $I10, rxquantr85_done
    (rx81_rep) = rx81_cur."!mark_commit"($I10)
  rxquantr85_done:
.annotate 'line', 41
  # rx pass
    rx81_cur."!cursor_pass"(rx81_pos, "ENDSTMT")
    if_null rx81_debug, debug_439
    rx81_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx81_pos)
  debug_439:
    .return (rx81_cur)
  rx81_restart:
.annotate 'line', 4
    if_null rx81_debug, debug_440
    rx81_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_440:
  rx81_fail:
    (rx81_rep, rx81_pos, $I10, $P10) = rx81_cur."!mark_fail"(0)
    lt rx81_pos, -1, rx81_done
    eq rx81_pos, -1, rx81_fail
    jump $I10
  rx81_done:
    rx81_cur."!cursor_fail"()
    if_null rx81_debug, debug_441
    rx81_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_441:
    .return (rx81_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1295994649.593") :method
.annotate 'line', 4
    new $P83, "ResizablePMCArray"
    push $P83, ""
    .return ($P83)
.end


.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx93_tgt
    .local int rx93_pos
    .local int rx93_off
    .local int rx93_eos
    .local int rx93_rep
    .local pmc rx93_cur
    .local pmc rx93_debug
    (rx93_cur, rx93_pos, rx93_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx93_cur
    .local pmc match
    .lex "$/", match
    length rx93_eos, rx93_tgt
    gt rx93_pos, rx93_eos, rx93_done
    set rx93_off, 0
    lt rx93_pos, 2, rx93_start
    sub rx93_off, rx93_pos, 1
    substr rx93_tgt, rx93_tgt, rx93_off
  rx93_start:
    eq $I10, 1, rx93_restart
    if_null rx93_debug, debug_442
    rx93_cur."!cursor_debug"("START", "ws")
  debug_442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan96_done
    goto rxscan96_scan
  rxscan96_loop:
    ($P10) = rx93_cur."from"()
    inc $P10
    set rx93_pos, $P10
    ge rx93_pos, rx93_eos, rxscan96_done
  rxscan96_scan:
    set_addr $I10, rxscan96_loop
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
  rxscan96_done:
  alt97_0:
.annotate 'line', 48
    set_addr $I10, alt97_1
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
.annotate 'line', 49
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx93_cur."!cursor_pos"(rx93_pos)
    $P10 = rx93_cur."MARKED"("ws")
    unless $P10, rx93_fail
    goto alt97_end
  alt97_1:
.annotate 'line', 50
  # rx subrule "ww" subtype=zerowidth negate=1
    rx93_cur."!cursor_pos"(rx93_pos)
    $P10 = rx93_cur."ww"()
    if $P10, rx93_fail
.annotate 'line', 55
  # rx rxquantr98 ** 0..*
    set_addr $I10, rxquantr98_done
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
  rxquantr98_loop:
  alt99_0:
.annotate 'line', 51
    set_addr $I10, alt99_1
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx93_pos, rx93_off
    set rx93_rep, 0
    sub $I12, rx93_eos, rx93_pos
  rxenumcharlistq100_loop:
    le $I12, 0, rxenumcharlistq100_done
    substr $S10, rx93_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq100_done
    inc rx93_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq100_loop
  rxenumcharlistq100_done:
    lt rx93_rep, 1, rx93_fail
    add rx93_pos, rx93_pos, rx93_rep
    goto alt99_end
  alt99_1:
    set_addr $I10, alt99_2
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
.annotate 'line', 52
  # rx literal  "#"
    add $I11, rx93_pos, 1
    gt $I11, rx93_eos, rx93_fail
    sub $I11, rx93_pos, rx93_off
    ord $I11, rx93_tgt, $I11
    ne $I11, 35, rx93_fail
    add rx93_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx93_pos, rx93_off
    find_cclass $I11, 4096, rx93_tgt, $I10, rx93_eos
    add rx93_pos, rx93_off, $I11
    goto alt99_end
  alt99_2:
    set_addr $I10, alt99_3
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
.annotate 'line', 53
  # rxanchor bol
    eq rx93_pos, 0, rxanchor101_done
    ge rx93_pos, rx93_eos, rx93_fail
    sub $I10, rx93_pos, rx93_off
    dec $I10
    is_cclass $I11, 4096, rx93_tgt, $I10
    unless $I11, rx93_fail
  rxanchor101_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx93_cur."!cursor_pos"(rx93_pos)
    $P10 = rx93_cur."pod_comment"()
    unless $P10, rx93_fail
    rx93_pos = $P10."pos"()
    goto alt99_end
  alt99_3:
.annotate 'line', 54
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx93_pos, rx93_off
    set rx93_rep, 0
    sub $I12, rx93_eos, rx93_pos
  rxenumcharlistq102_loop:
    le $I12, 0, rxenumcharlistq102_done
    substr $S10, rx93_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq102_done
    inc rx93_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq102_loop
  rxenumcharlistq102_done:
    lt rx93_rep, 1, rx93_fail
    add rx93_pos, rx93_pos, rx93_rep
  alt99_end:
.annotate 'line', 55
    set_addr $I10, rxquantr98_done
    (rx93_rep) = rx93_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr98_done
    rx93_cur."!mark_push"(rx93_rep, rx93_pos, $I10)
    goto rxquantr98_loop
  rxquantr98_done:
.annotate 'line', 56
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx93_cur."!cursor_pos"(rx93_pos)
    $P10 = rx93_cur."MARKER"("ws")
    unless $P10, rx93_fail
  alt97_end:
.annotate 'line', 48
  # rx pass
    rx93_cur."!cursor_pass"(rx93_pos, "ws")
    if_null rx93_debug, debug_443
    rx93_cur."!cursor_debug"("PASS", "ws", " at pos=", rx93_pos)
  debug_443:
    .return (rx93_cur)
  rx93_restart:
.annotate 'line', 4
    if_null rx93_debug, debug_444
    rx93_cur."!cursor_debug"("NEXT", "ws")
  debug_444:
  rx93_fail:
    (rx93_rep, rx93_pos, $I10, $P10) = rx93_cur."!mark_fail"(0)
    lt rx93_pos, -1, rx93_done
    eq rx93_pos, -1, rx93_fail
    jump $I10
  rx93_done:
    rx93_cur."!cursor_fail"()
    if_null rx93_debug, debug_445
    rx93_cur."!cursor_debug"("FAIL", "ws")
  debug_445:
    .return (rx93_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1295994649.593") :method
.annotate 'line', 4
    new $P95, "ResizablePMCArray"
    push $P95, ""
    push $P95, ""
    .return ($P95)
.end


.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P111 = "25_1295994649.593" 
    capture_lex $P111
    .local string rx104_tgt
    .local int rx104_pos
    .local int rx104_off
    .local int rx104_eos
    .local int rx104_rep
    .local pmc rx104_cur
    .local pmc rx104_debug
    (rx104_cur, rx104_pos, rx104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx104_cur
    .local pmc match
    .lex "$/", match
    length rx104_eos, rx104_tgt
    gt rx104_pos, rx104_eos, rx104_done
    set rx104_off, 0
    lt rx104_pos, 2, rx104_start
    sub rx104_off, rx104_pos, 1
    substr rx104_tgt, rx104_tgt, rx104_off
  rx104_start:
    eq $I10, 1, rx104_restart
    if_null rx104_debug, debug_446
    rx104_cur."!cursor_debug"("START", "unv")
  debug_446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan107_done
    goto rxscan107_scan
  rxscan107_loop:
    ($P10) = rx104_cur."from"()
    inc $P10
    set rx104_pos, $P10
    ge rx104_pos, rx104_eos, rxscan107_done
  rxscan107_scan:
    set_addr $I10, rxscan107_loop
    rx104_cur."!mark_push"(0, rx104_pos, $I10)
  rxscan107_done:
  alt108_0:
.annotate 'line', 61
    set_addr $I10, alt108_1
    rx104_cur."!mark_push"(0, rx104_pos, $I10)
.annotate 'line', 62
  # rxanchor bol
    eq rx104_pos, 0, rxanchor109_done
    ge rx104_pos, rx104_eos, rx104_fail
    sub $I10, rx104_pos, rx104_off
    dec $I10
    is_cclass $I11, 4096, rx104_tgt, $I10
    unless $I11, rx104_fail
  rxanchor109_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx104_cur."!cursor_pos"(rx104_pos)
    .const 'Sub' $P111 = "25_1295994649.593" 
    capture_lex $P111
    $P10 = rx104_cur."before"($P111)
    unless $P10, rx104_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx104_cur."!cursor_pos"(rx104_pos)
    $P10 = rx104_cur."pod_comment"()
    unless $P10, rx104_fail
    rx104_pos = $P10."pos"()
    goto alt108_end
  alt108_1:
    set_addr $I10, alt108_2
    rx104_cur."!mark_push"(0, rx104_pos, $I10)
.annotate 'line', 63
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx104_pos, rx104_off
    set rx104_rep, 0
    sub $I12, rx104_eos, rx104_pos
  rxenumcharlistq116_loop:
    le $I12, 0, rxenumcharlistq116_done
    substr $S10, rx104_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq116_done
    inc rx104_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq116_loop
  rxenumcharlistq116_done:
    add rx104_pos, rx104_pos, rx104_rep
  # rx literal  "#"
    add $I11, rx104_pos, 1
    gt $I11, rx104_eos, rx104_fail
    sub $I11, rx104_pos, rx104_off
    ord $I11, rx104_tgt, $I11
    ne $I11, 35, rx104_fail
    add rx104_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx104_pos, rx104_off
    find_cclass $I11, 4096, rx104_tgt, $I10, rx104_eos
    add rx104_pos, rx104_off, $I11
    goto alt108_end
  alt108_2:
.annotate 'line', 64
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx104_pos, rx104_off
    set rx104_rep, 0
    sub $I12, rx104_eos, rx104_pos
  rxenumcharlistq117_loop:
    le $I12, 0, rxenumcharlistq117_done
    substr $S10, rx104_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq117_done
    inc rx104_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq117_loop
  rxenumcharlistq117_done:
    lt rx104_rep, 1, rx104_fail
    add rx104_pos, rx104_pos, rx104_rep
  alt108_end:
.annotate 'line', 59
  # rx pass
    rx104_cur."!cursor_pass"(rx104_pos, "unv")
    if_null rx104_debug, debug_451
    rx104_cur."!cursor_debug"("PASS", "unv", " at pos=", rx104_pos)
  debug_451:
    .return (rx104_cur)
  rx104_restart:
.annotate 'line', 4
    if_null rx104_debug, debug_452
    rx104_cur."!cursor_debug"("NEXT", "unv")
  debug_452:
  rx104_fail:
    (rx104_rep, rx104_pos, $I10, $P10) = rx104_cur."!mark_fail"(0)
    lt rx104_pos, -1, rx104_done
    eq rx104_pos, -1, rx104_fail
    jump $I10
  rx104_done:
    rx104_cur."!cursor_fail"()
    if_null rx104_debug, debug_453
    rx104_cur."!cursor_debug"("FAIL", "unv")
  debug_453:
    .return (rx104_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1295994649.593") :method
.annotate 'line', 4
    new $P106, "ResizablePMCArray"
    push $P106, ""
    push $P106, ""
    push $P106, ""
    .return ($P106)
.end


.namespace ["NQP";"Grammar"]
.sub "_block110"  :anon :subid("25_1295994649.593") :method :outer("23_1295994649.593")
.annotate 'line', 62
    .local string rx112_tgt
    .local int rx112_pos
    .local int rx112_off
    .local int rx112_eos
    .local int rx112_rep
    .local pmc rx112_cur
    .local pmc rx112_debug
    (rx112_cur, rx112_pos, rx112_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx112_cur
    .local pmc match
    .lex "$/", match
    length rx112_eos, rx112_tgt
    gt rx112_pos, rx112_eos, rx112_done
    set rx112_off, 0
    lt rx112_pos, 2, rx112_start
    sub rx112_off, rx112_pos, 1
    substr rx112_tgt, rx112_tgt, rx112_off
  rx112_start:
    eq $I10, 1, rx112_restart
    if_null rx112_debug, debug_447
    rx112_cur."!cursor_debug"("START", "")
  debug_447:
    $I10 = self.'from'()
    ne $I10, -1, rxscan113_done
    goto rxscan113_scan
  rxscan113_loop:
    ($P10) = rx112_cur."from"()
    inc $P10
    set rx112_pos, $P10
    ge rx112_pos, rx112_eos, rxscan113_done
  rxscan113_scan:
    set_addr $I10, rxscan113_loop
    rx112_cur."!mark_push"(0, rx112_pos, $I10)
  rxscan113_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx112_pos, rx112_off
    set rx112_rep, 0
    sub $I12, rx112_eos, rx112_pos
  rxenumcharlistq114_loop:
    le $I12, 0, rxenumcharlistq114_done
    substr $S10, rx112_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq114_done
    inc rx112_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq114_loop
  rxenumcharlistq114_done:
    add rx112_pos, rx112_pos, rx112_rep
  # rx literal  "="
    add $I11, rx112_pos, 1
    gt $I11, rx112_eos, rx112_fail
    sub $I11, rx112_pos, rx112_off
    ord $I11, rx112_tgt, $I11
    ne $I11, 61, rx112_fail
    add rx112_pos, 1
  alt115_0:
    set_addr $I10, alt115_1
    rx112_cur."!mark_push"(0, rx112_pos, $I10)
  # rx charclass w
    ge rx112_pos, rx112_eos, rx112_fail
    sub $I10, rx112_pos, rx112_off
    is_cclass $I11, 8192, rx112_tgt, $I10
    unless $I11, rx112_fail
    inc rx112_pos
    goto alt115_end
  alt115_1:
  # rx literal  "\\"
    add $I11, rx112_pos, 1
    gt $I11, rx112_eos, rx112_fail
    sub $I11, rx112_pos, rx112_off
    ord $I11, rx112_tgt, $I11
    ne $I11, 92, rx112_fail
    add rx112_pos, 1
  alt115_end:
  # rx pass
    rx112_cur."!cursor_pass"(rx112_pos, "")
    if_null rx112_debug, debug_448
    rx112_cur."!cursor_debug"("PASS", "", " at pos=", rx112_pos)
  debug_448:
    .return (rx112_cur)
  rx112_restart:
    if_null rx112_debug, debug_449
    rx112_cur."!cursor_debug"("NEXT", "")
  debug_449:
  rx112_fail:
    (rx112_rep, rx112_pos, $I10, $P10) = rx112_cur."!mark_fail"(0)
    lt rx112_pos, -1, rx112_done
    eq rx112_pos, -1, rx112_fail
    jump $I10
  rx112_done:
    rx112_cur."!cursor_fail"()
    if_null rx112_debug, debug_450
    rx112_cur."!cursor_debug"("FAIL", "")
  debug_450:
    .return (rx112_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P150 = "28_1295994649.593" 
    capture_lex $P150
    .local string rx119_tgt
    .local int rx119_pos
    .local int rx119_off
    .local int rx119_eos
    .local int rx119_rep
    .local pmc rx119_cur
    .local pmc rx119_debug
    (rx119_cur, rx119_pos, rx119_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx119_cur
    .local pmc match
    .lex "$/", match
    length rx119_eos, rx119_tgt
    gt rx119_pos, rx119_eos, rx119_done
    set rx119_off, 0
    lt rx119_pos, 2, rx119_start
    sub rx119_off, rx119_pos, 1
    substr rx119_tgt, rx119_tgt, rx119_off
  rx119_start:
    eq $I10, 1, rx119_restart
    if_null rx119_debug, debug_454
    rx119_cur."!cursor_debug"("START", "pod_comment")
  debug_454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan122_done
    goto rxscan122_scan
  rxscan122_loop:
    ($P10) = rx119_cur."from"()
    inc $P10
    set rx119_pos, $P10
    ge rx119_pos, rx119_eos, rxscan122_done
  rxscan122_scan:
    set_addr $I10, rxscan122_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  rxscan122_done:
.annotate 'line', 69
  # rxanchor bol
    eq rx119_pos, 0, rxanchor123_done
    ge rx119_pos, rx119_eos, rx119_fail
    sub $I10, rx119_pos, rx119_off
    dec $I10
    is_cclass $I11, 4096, rx119_tgt, $I10
    unless $I11, rx119_fail
  rxanchor123_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq124_loop:
    le $I12, 0, rxenumcharlistq124_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq124_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq124_loop
  rxenumcharlistq124_done:
    add rx119_pos, rx119_pos, rx119_rep
  # rx literal  "="
    add $I11, rx119_pos, 1
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    ord $I11, rx119_tgt, $I11
    ne $I11, 61, rx119_fail
    add rx119_pos, 1
  alt125_0:
.annotate 'line', 70
    set_addr $I10, alt125_1
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
.annotate 'line', 71
  # rx literal  "begin"
    add $I11, rx119_pos, 5
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    substr $S10, rx119_tgt, $I11, 5
    ne $S10, "begin", rx119_fail
    add rx119_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq126_loop:
    le $I12, 0, rxenumcharlistq126_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq126_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq126_loop
  rxenumcharlistq126_done:
    lt rx119_rep, 1, rx119_fail
    add rx119_pos, rx119_pos, rx119_rep
  # rx literal  "END"
    add $I11, rx119_pos, 3
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    substr $S10, rx119_tgt, $I11, 3
    ne $S10, "END", rx119_fail
    add rx119_pos, 3
  # rxanchor rwb
    le rx119_pos, 0, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 8192, rx119_tgt, $I10
    if $I11, rx119_fail
    dec $I10
    is_cclass $I11, 8192, rx119_tgt, $I10
    unless $I11, rx119_fail
  alt127_0:
.annotate 'line', 72
    set_addr $I10, alt127_1
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  # rx rxquantf128 ** 0..*
    set_addr $I10, rxquantf128_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
    goto rxquantf128_done
  rxquantf128_loop:
  # rx charclass .
    ge rx119_pos, rx119_eos, rx119_fail
    inc rx119_pos
    set_addr $I10, rxquantf128_loop
    rx119_cur."!mark_push"(rx119_rep, rx119_pos, $I10)
  rxquantf128_done:
  # rx charclass nl
    ge rx119_pos, rx119_eos, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 4096, rx119_tgt, $I10
    unless $I11, rx119_fail
    substr $S10, rx119_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx119_pos, $I11
    inc rx119_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq130_loop:
    le $I12, 0, rxenumcharlistq130_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq130_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq130_loop
  rxenumcharlistq130_done:
    add rx119_pos, rx119_pos, rx119_rep
  # rx literal  "=end"
    add $I11, rx119_pos, 4
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    substr $S10, rx119_tgt, $I11, 4
    ne $S10, "=end", rx119_fail
    add rx119_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq131_loop:
    le $I12, 0, rxenumcharlistq131_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq131_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq131_loop
  rxenumcharlistq131_done:
    lt rx119_rep, 1, rx119_fail
    add rx119_pos, rx119_pos, rx119_rep
  # rx literal  "END"
    add $I11, rx119_pos, 3
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    substr $S10, rx119_tgt, $I11, 3
    ne $S10, "END", rx119_fail
    add rx119_pos, 3
  # rxanchor rwb
    le rx119_pos, 0, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 8192, rx119_tgt, $I10
    if $I11, rx119_fail
    dec $I10
    is_cclass $I11, 8192, rx119_tgt, $I10
    unless $I11, rx119_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx119_pos, rx119_off
    find_cclass $I11, 4096, rx119_tgt, $I10, rx119_eos
    add rx119_pos, rx119_off, $I11
    goto alt127_end
  alt127_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx119_pos, rx119_off
    find_not_cclass $I11, 65535, rx119_tgt, $I10, rx119_eos
    add rx119_pos, rx119_off, $I11
  alt127_end:
.annotate 'line', 71
    goto alt125_end
  alt125_1:
    set_addr $I10, alt125_2
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
.annotate 'line', 73
  # rx literal  "begin"
    add $I11, rx119_pos, 5
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    substr $S10, rx119_tgt, $I11, 5
    ne $S10, "begin", rx119_fail
    add rx119_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq132_loop:
    le $I12, 0, rxenumcharlistq132_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq132_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq132_loop
  rxenumcharlistq132_done:
    lt rx119_rep, 1, rx119_fail
    add rx119_pos, rx119_pos, rx119_rep
  # rx subrule "identifier" subtype=capture negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."identifier"()
    unless $P10, rx119_fail
    rx119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx119_pos = $P10."pos"()
  alt133_0:
.annotate 'line', 74
    set_addr $I10, alt133_1
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
.annotate 'line', 75
  # rx rxquantf134 ** 0..*
    set_addr $I10, rxquantf134_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
    goto rxquantf134_done
  rxquantf134_loop:
  # rx charclass .
    ge rx119_pos, rx119_eos, rx119_fail
    inc rx119_pos
    set_addr $I10, rxquantf134_loop
    rx119_cur."!mark_push"(rx119_rep, rx119_pos, $I10)
  rxquantf134_done:
  # rx charclass nl
    ge rx119_pos, rx119_eos, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 4096, rx119_tgt, $I10
    unless $I11, rx119_fail
    substr $S10, rx119_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx119_pos, $I11
    inc rx119_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq136_loop:
    le $I12, 0, rxenumcharlistq136_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq136_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq136_loop
  rxenumcharlistq136_done:
    add rx119_pos, rx119_pos, rx119_rep
  # rx literal  "=end"
    add $I11, rx119_pos, 4
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    substr $S10, rx119_tgt, $I11, 4
    ne $S10, "=end", rx119_fail
    add rx119_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq137_loop:
    le $I12, 0, rxenumcharlistq137_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq137_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq137_loop
  rxenumcharlistq137_done:
    lt rx119_rep, 1, rx119_fail
    add rx119_pos, rx119_pos, rx119_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."!BACKREF"("identifier")
    unless $P10, rx119_fail
    rx119_pos = $P10."pos"()
  # rxanchor rwb
    le rx119_pos, 0, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 8192, rx119_tgt, $I10
    if $I11, rx119_fail
    dec $I10
    is_cclass $I11, 8192, rx119_tgt, $I10
    unless $I11, rx119_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx119_pos, rx119_off
    find_cclass $I11, 4096, rx119_tgt, $I10, rx119_eos
    add rx119_pos, rx119_off, $I11
    goto alt133_end
  alt133_1:
.annotate 'line', 76
  # rx subrule "panic" subtype=method negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."panic"("=begin without matching =end")
    unless $P10, rx119_fail
    rx119_pos = $P10."pos"()
  alt133_end:
.annotate 'line', 73
    goto alt125_end
  alt125_2:
    set_addr $I10, alt125_3
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
.annotate 'line', 78
  # rx literal  "begin"
    add $I11, rx119_pos, 5
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    substr $S10, rx119_tgt, $I11, 5
    ne $S10, "begin", rx119_fail
    add rx119_pos, 5
  # rxanchor rwb
    le rx119_pos, 0, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 8192, rx119_tgt, $I10
    if $I11, rx119_fail
    dec $I10
    is_cclass $I11, 8192, rx119_tgt, $I10
    unless $I11, rx119_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq139_loop:
    le $I12, 0, rxenumcharlistq139_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq139_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq139_loop
  rxenumcharlistq139_done:
    add rx119_pos, rx119_pos, rx119_rep
  alt140_0:
.annotate 'line', 79
    set_addr $I10, alt140_1
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  # rxanchor eol
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 4096, rx119_tgt, $I10
    if $I11, rxanchor141_done
    ne rx119_pos, rx119_eos, rx119_fail
    eq rx119_pos, 0, rxanchor141_done
    dec $I10
    is_cclass $I11, 4096, rx119_tgt, $I10
    if $I11, rx119_fail
  rxanchor141_done:
    goto alt140_end
  alt140_1:
    set_addr $I10, alt140_2
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  # rx literal  "#"
    add $I11, rx119_pos, 1
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    ord $I11, rx119_tgt, $I11
    ne $I11, 35, rx119_fail
    add rx119_pos, 1
    goto alt140_end
  alt140_2:
  # rx subrule "panic" subtype=method negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx119_fail
    rx119_pos = $P10."pos"()
  alt140_end:
  alt142_0:
.annotate 'line', 80
    set_addr $I10, alt142_1
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
.annotate 'line', 81
  # rx rxquantf143 ** 0..*
    set_addr $I10, rxquantf143_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
    goto rxquantf143_done
  rxquantf143_loop:
  # rx charclass .
    ge rx119_pos, rx119_eos, rx119_fail
    inc rx119_pos
    set_addr $I10, rxquantf143_loop
    rx119_cur."!mark_push"(rx119_rep, rx119_pos, $I10)
  rxquantf143_done:
  # rx charclass nl
    ge rx119_pos, rx119_eos, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 4096, rx119_tgt, $I10
    unless $I11, rx119_fail
    substr $S10, rx119_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx119_pos, $I11
    inc rx119_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx119_pos, rx119_off
    set rx119_rep, 0
    sub $I12, rx119_eos, rx119_pos
  rxenumcharlistq145_loop:
    le $I12, 0, rxenumcharlistq145_done
    substr $S10, rx119_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq145_done
    inc rx119_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq145_loop
  rxenumcharlistq145_done:
    add rx119_pos, rx119_pos, rx119_rep
  # rx literal  "=end"
    add $I11, rx119_pos, 4
    gt $I11, rx119_eos, rx119_fail
    sub $I11, rx119_pos, rx119_off
    substr $S10, rx119_tgt, $I11, 4
    ne $S10, "=end", rx119_fail
    add rx119_pos, 4
  # rxanchor rwb
    le rx119_pos, 0, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 8192, rx119_tgt, $I10
    if $I11, rx119_fail
    dec $I10
    is_cclass $I11, 8192, rx119_tgt, $I10
    unless $I11, rx119_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx119_pos, rx119_off
    find_cclass $I11, 4096, rx119_tgt, $I10, rx119_eos
    add rx119_pos, rx119_off, $I11
    goto alt142_end
  alt142_1:
.annotate 'line', 82
  # rx subrule "panic" subtype=method negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."panic"("=begin without matching =end")
    unless $P10, rx119_fail
    rx119_pos = $P10."pos"()
  alt142_end:
.annotate 'line', 78
    goto alt125_end
  alt125_3:
    set_addr $I10, alt125_4
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
.annotate 'line', 84
  # rx subrule "identifier" subtype=capture negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."identifier"()
    unless $P10, rx119_fail
    rx119_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx119_pos = $P10."pos"()
.annotate 'line', 85
  # rx rxquantf146 ** 0..*
    set_addr $I10, rxquantf146_loop
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
    goto rxquantf146_done
  rxquantf146_loop:
  # rx charclass .
    ge rx119_pos, rx119_eos, rx119_fail
    inc rx119_pos
    set_addr $I10, rxquantf146_loop
    rx119_cur."!mark_push"(rx119_rep, rx119_pos, $I10)
  rxquantf146_done:
  # rxanchor bol
    eq rx119_pos, 0, rxanchor148_done
    ge rx119_pos, rx119_eos, rx119_fail
    sub $I10, rx119_pos, rx119_off
    dec $I10
    is_cclass $I11, 4096, rx119_tgt, $I10
    unless $I11, rx119_fail
  rxanchor148_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    .const 'Sub' $P150 = "28_1295994649.593" 
    capture_lex $P150
    $P10 = rx119_cur."before"($P150)
    unless $P10, rx119_fail
.annotate 'line', 84
    goto alt125_end
  alt125_4:
  alt156_0:
.annotate 'line', 91
    set_addr $I10, alt156_1
    rx119_cur."!mark_push"(0, rx119_pos, $I10)
  # rx charclass s
    ge rx119_pos, rx119_eos, rx119_fail
    sub $I10, rx119_pos, rx119_off
    is_cclass $I11, 32, rx119_tgt, $I10
    unless $I11, rx119_fail
    inc rx119_pos
    goto alt156_end
  alt156_1:
  # rx subrule "panic" subtype=method negate=
    rx119_cur."!cursor_pos"(rx119_pos)
    $P10 = rx119_cur."panic"("Illegal pod directive")
    unless $P10, rx119_fail
    rx119_pos = $P10."pos"()
  alt156_end:
.annotate 'line', 92
  # rx charclass_q N r 0..-1
    sub $I10, rx119_pos, rx119_off
    find_cclass $I11, 4096, rx119_tgt, $I10, rx119_eos
    add rx119_pos, rx119_off, $I11
  alt125_end:
.annotate 'line', 68
  # rx pass
    rx119_cur."!cursor_pass"(rx119_pos, "pod_comment")
    if_null rx119_debug, debug_459
    rx119_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx119_pos)
  debug_459:
    .return (rx119_cur)
  rx119_restart:
.annotate 'line', 4
    if_null rx119_debug, debug_460
    rx119_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_460:
  rx119_fail:
    (rx119_rep, rx119_pos, $I10, $P10) = rx119_cur."!mark_fail"(0)
    lt rx119_pos, -1, rx119_done
    eq rx119_pos, -1, rx119_fail
    jump $I10
  rx119_done:
    rx119_cur."!cursor_fail"()
    if_null rx119_debug, debug_461
    rx119_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_461:
    .return (rx119_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1295994649.593") :method
.annotate 'line', 4
    new $P121, "ResizablePMCArray"
    push $P121, ""
    .return ($P121)
.end


.namespace ["NQP";"Grammar"]
.sub "_block149"  :anon :subid("28_1295994649.593") :method :outer("26_1295994649.593")
.annotate 'line', 85
    .local string rx151_tgt
    .local int rx151_pos
    .local int rx151_off
    .local int rx151_eos
    .local int rx151_rep
    .local pmc rx151_cur
    .local pmc rx151_debug
    (rx151_cur, rx151_pos, rx151_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx151_cur
    .local pmc match
    .lex "$/", match
    length rx151_eos, rx151_tgt
    gt rx151_pos, rx151_eos, rx151_done
    set rx151_off, 0
    lt rx151_pos, 2, rx151_start
    sub rx151_off, rx151_pos, 1
    substr rx151_tgt, rx151_tgt, rx151_off
  rx151_start:
    eq $I10, 1, rx151_restart
    if_null rx151_debug, debug_455
    rx151_cur."!cursor_debug"("START", "")
  debug_455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan152_done
    goto rxscan152_scan
  rxscan152_loop:
    ($P10) = rx151_cur."from"()
    inc $P10
    set rx151_pos, $P10
    ge rx151_pos, rx151_eos, rxscan152_done
  rxscan152_scan:
    set_addr $I10, rxscan152_loop
    rx151_cur."!mark_push"(0, rx151_pos, $I10)
  rxscan152_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx151_pos, rx151_off
    set rx151_rep, 0
    sub $I12, rx151_eos, rx151_pos
  rxenumcharlistq153_loop:
    le $I12, 0, rxenumcharlistq153_done
    substr $S10, rx151_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq153_done
    inc rx151_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq153_loop
  rxenumcharlistq153_done:
    add rx151_pos, rx151_pos, rx151_rep
  alt154_0:
    set_addr $I10, alt154_1
    rx151_cur."!mark_push"(0, rx151_pos, $I10)
.annotate 'line', 86
  # rx literal  "="
    add $I11, rx151_pos, 1
    gt $I11, rx151_eos, rx151_fail
    sub $I11, rx151_pos, rx151_off
    ord $I11, rx151_tgt, $I11
    ne $I11, 61, rx151_fail
    add rx151_pos, 1
.annotate 'line', 88
  # rx rxquantr155 ** 0..1
    set_addr $I10, rxquantr155_done
    rx151_cur."!mark_push"(0, rx151_pos, $I10)
  rxquantr155_loop:
.annotate 'line', 87
  # rx literal  "cut"
    add $I11, rx151_pos, 3
    gt $I11, rx151_eos, rx151_fail
    sub $I11, rx151_pos, rx151_off
    substr $S10, rx151_tgt, $I11, 3
    ne $S10, "cut", rx151_fail
    add rx151_pos, 3
  # rxanchor rwb
    le rx151_pos, 0, rx151_fail
    sub $I10, rx151_pos, rx151_off
    is_cclass $I11, 8192, rx151_tgt, $I10
    if $I11, rx151_fail
    dec $I10
    is_cclass $I11, 8192, rx151_tgt, $I10
    unless $I11, rx151_fail
.annotate 'line', 88
  # rx subrule "panic" subtype=method negate=
    rx151_cur."!cursor_pos"(rx151_pos)
    $P10 = rx151_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx151_fail
    rx151_pos = $P10."pos"()
    set_addr $I10, rxquantr155_done
    (rx151_rep) = rx151_cur."!mark_commit"($I10)
  rxquantr155_done:
.annotate 'line', 85
    goto alt154_end
  alt154_1:
.annotate 'line', 89
  # rx charclass nl
    ge rx151_pos, rx151_eos, rx151_fail
    sub $I10, rx151_pos, rx151_off
    is_cclass $I11, 4096, rx151_tgt, $I10
    unless $I11, rx151_fail
    substr $S10, rx151_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx151_pos, $I11
    inc rx151_pos
  alt154_end:
.annotate 'line', 85
  # rx pass
    rx151_cur."!cursor_pass"(rx151_pos, "")
    if_null rx151_debug, debug_456
    rx151_cur."!cursor_debug"("PASS", "", " at pos=", rx151_pos)
  debug_456:
    .return (rx151_cur)
  rx151_restart:
    if_null rx151_debug, debug_457
    rx151_cur."!cursor_debug"("NEXT", "")
  debug_457:
  rx151_fail:
    (rx151_rep, rx151_pos, $I10, $P10) = rx151_cur."!mark_fail"(0)
    lt rx151_pos, -1, rx151_done
    eq rx151_pos, -1, rx151_fail
    jump $I10
  rx151_done:
    rx151_cur."!cursor_fail"()
    if_null rx151_debug, debug_458
    rx151_cur."!cursor_debug"("FAIL", "")
  debug_458:
    .return (rx151_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx158_tgt
    .local int rx158_pos
    .local int rx158_off
    .local int rx158_eos
    .local int rx158_rep
    .local pmc rx158_cur
    .local pmc rx158_debug
    (rx158_cur, rx158_pos, rx158_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx158_cur
    .local pmc match
    .lex "$/", match
    length rx158_eos, rx158_tgt
    gt rx158_pos, rx158_eos, rx158_done
    set rx158_off, 0
    lt rx158_pos, 2, rx158_start
    sub rx158_off, rx158_pos, 1
    substr rx158_tgt, rx158_tgt, rx158_off
  rx158_start:
    eq $I10, 1, rx158_restart
    if_null rx158_debug, debug_462
    rx158_cur."!cursor_debug"("START", "comp_unit")
  debug_462:
    $I10 = self.'from'()
    ne $I10, -1, rxscan162_done
    goto rxscan162_scan
  rxscan162_loop:
    ($P10) = rx158_cur."from"()
    inc $P10
    set rx158_pos, $P10
    ge rx158_pos, rx158_eos, rxscan162_done
  rxscan162_scan:
    set_addr $I10, rxscan162_loop
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
  rxscan162_done:
.annotate 'line', 100
  # rx subrule "newpad" subtype=method negate=
    rx158_cur."!cursor_pos"(rx158_pos)
    $P10 = rx158_cur."newpad"()
    unless $P10, rx158_fail
    rx158_pos = $P10."pos"()
.annotate 'line', 101
  # rx subrule "outerctx" subtype=method negate=
    rx158_cur."!cursor_pos"(rx158_pos)
    $P10 = rx158_cur."outerctx"()
    unless $P10, rx158_fail
    rx158_pos = $P10."pos"()
.annotate 'line', 102
  # rx subrule "statementlist" subtype=capture negate=
    rx158_cur."!cursor_pos"(rx158_pos)
    $P10 = rx158_cur."statementlist"()
    unless $P10, rx158_fail
    rx158_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx158_pos = $P10."pos"()
  alt163_0:
.annotate 'line', 103
    set_addr $I10, alt163_1
    rx158_cur."!mark_push"(0, rx158_pos, $I10)
  # rxanchor eos
    ne rx158_pos, rx158_eos, rx158_fail
    goto alt163_end
  alt163_1:
  # rx subrule "panic" subtype=method negate=
    rx158_cur."!cursor_pos"(rx158_pos)
    $P10 = rx158_cur."panic"("Confused")
    unless $P10, rx158_fail
    rx158_pos = $P10."pos"()
  alt163_end:
.annotate 'line', 99
  # rx pass
    rx158_cur."!cursor_pass"(rx158_pos, "comp_unit")
    if_null rx158_debug, debug_463
    rx158_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx158_pos)
  debug_463:
    .return (rx158_cur)
  rx158_restart:
.annotate 'line', 4
    if_null rx158_debug, debug_464
    rx158_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_464:
  rx158_fail:
    (rx158_rep, rx158_pos, $I10, $P10) = rx158_cur."!mark_fail"(0)
    lt rx158_pos, -1, rx158_done
    eq rx158_pos, -1, rx158_fail
    jump $I10
  rx158_done:
    rx158_cur."!cursor_fail"()
    if_null rx158_debug, debug_465
    rx158_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_465:
    .return (rx158_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1295994649.593") :method
.annotate 'line', 4
    $P160 = self."!PREFIX__!subrule"("newpad", "")
    new $P161, "ResizablePMCArray"
    push $P161, $P160
    .return ($P161)
.end


.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx165_tgt
    .local int rx165_pos
    .local int rx165_off
    .local int rx165_eos
    .local int rx165_rep
    .local pmc rx165_cur
    .local pmc rx165_debug
    (rx165_cur, rx165_pos, rx165_tgt, $I10) = self."!cursor_start"()
    rx165_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx165_cur
    .local pmc match
    .lex "$/", match
    length rx165_eos, rx165_tgt
    gt rx165_pos, rx165_eos, rx165_done
    set rx165_off, 0
    lt rx165_pos, 2, rx165_start
    sub rx165_off, rx165_pos, 1
    substr rx165_tgt, rx165_tgt, rx165_off
  rx165_start:
    eq $I10, 1, rx165_restart
    if_null rx165_debug, debug_466
    rx165_cur."!cursor_debug"("START", "statementlist")
  debug_466:
    $I10 = self.'from'()
    ne $I10, -1, rxscan170_done
    goto rxscan170_scan
  rxscan170_loop:
    ($P10) = rx165_cur."from"()
    inc $P10
    set rx165_pos, $P10
    ge rx165_pos, rx165_eos, rxscan170_done
  rxscan170_scan:
    set_addr $I10, rxscan170_loop
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  rxscan170_done:
  alt171_0:
.annotate 'line', 106
    set_addr $I10, alt171_1
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
.annotate 'line', 107
  # rx subrule "ws" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."ws"()
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  # rxanchor eos
    ne rx165_pos, rx165_eos, rx165_fail
  # rx subrule "ws" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."ws"()
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
    goto alt171_end
  alt171_1:
.annotate 'line', 108
  # rx subrule "ws" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."ws"()
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  # rx rxquantr175 ** 0..*
    set_addr $I10, rxquantr175_done
    rx165_cur."!mark_push"(0, rx165_pos, $I10)
  rxquantr175_loop:
  # rx subrule "statement" subtype=capture negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."statement"()
    unless $P10, rx165_fail
    rx165_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx165_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."eat_terminator"()
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."ws"()
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
    set_addr $I10, rxquantr175_done
    (rx165_rep) = rx165_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr175_done
    rx165_cur."!mark_push"(rx165_rep, rx165_pos, $I10)
    goto rxquantr175_loop
  rxquantr175_done:
  # rx subrule "ws" subtype=method negate=
    rx165_cur."!cursor_pos"(rx165_pos)
    $P10 = rx165_cur."ws"()
    unless $P10, rx165_fail
    rx165_pos = $P10."pos"()
  alt171_end:
.annotate 'line', 106
  # rx pass
    rx165_cur."!cursor_pass"(rx165_pos, "statementlist")
    if_null rx165_debug, debug_467
    rx165_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx165_pos)
  debug_467:
    .return (rx165_cur)
  rx165_restart:
.annotate 'line', 4
    if_null rx165_debug, debug_468
    rx165_cur."!cursor_debug"("NEXT", "statementlist")
  debug_468:
  rx165_fail:
    (rx165_rep, rx165_pos, $I10, $P10) = rx165_cur."!mark_fail"(0)
    lt rx165_pos, -1, rx165_done
    eq rx165_pos, -1, rx165_fail
    jump $I10
  rx165_done:
    rx165_cur."!cursor_fail"()
    if_null rx165_debug, debug_469
    rx165_cur."!cursor_debug"("FAIL", "statementlist")
  debug_469:
    .return (rx165_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1295994649.593") :method
.annotate 'line', 4
    $P167 = self."!PREFIX__!subrule"("ws", "")
    $P168 = self."!PREFIX__!subrule"("ws", "")
    new $P169, "ResizablePMCArray"
    push $P169, $P167
    push $P169, $P168
    .return ($P169)
.end


.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P184 = "35_1295994649.593" 
    capture_lex $P184
    .local string rx179_tgt
    .local int rx179_pos
    .local int rx179_off
    .local int rx179_eos
    .local int rx179_rep
    .local pmc rx179_cur
    .local pmc rx179_debug
    (rx179_cur, rx179_pos, rx179_tgt, $I10) = self."!cursor_start"()
    rx179_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx179_cur
    .local pmc match
    .lex "$/", match
    length rx179_eos, rx179_tgt
    gt rx179_pos, rx179_eos, rx179_done
    set rx179_off, 0
    lt rx179_pos, 2, rx179_start
    sub rx179_off, rx179_pos, 1
    substr rx179_tgt, rx179_tgt, rx179_off
  rx179_start:
    eq $I10, 1, rx179_restart
    if_null rx179_debug, debug_470
    rx179_cur."!cursor_debug"("START", "statement")
  debug_470:
    $I10 = self.'from'()
    ne $I10, -1, rxscan182_done
    goto rxscan182_scan
  rxscan182_loop:
    ($P10) = rx179_cur."from"()
    inc $P10
    set rx179_pos, $P10
    ge rx179_pos, rx179_eos, rxscan182_done
  rxscan182_scan:
    set_addr $I10, rxscan182_loop
    rx179_cur."!mark_push"(0, rx179_pos, $I10)
  rxscan182_done:
.annotate 'line', 112
  # rx subrule "before" subtype=zerowidth negate=1
    rx179_cur."!cursor_pos"(rx179_pos)
    .const 'Sub' $P184 = "35_1295994649.593" 
    capture_lex $P184
    $P10 = rx179_cur."before"($P184)
    if $P10, rx179_fail
  alt188_0:
.annotate 'line', 113
    set_addr $I10, alt188_1
    rx179_cur."!mark_push"(0, rx179_pos, $I10)
.annotate 'line', 114
  # rx subrule "statement_control" subtype=capture negate=
    rx179_cur."!cursor_pos"(rx179_pos)
    $P10 = rx179_cur."statement_control"()
    unless $P10, rx179_fail
    rx179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx179_pos = $P10."pos"()
    goto alt188_end
  alt188_1:
.annotate 'line', 115
  # rx subrule "EXPR" subtype=capture negate=
    rx179_cur."!cursor_pos"(rx179_pos)
    $P10 = rx179_cur."EXPR"()
    unless $P10, rx179_fail
    rx179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx179_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx179_cur."!cursor_pos"(rx179_pos)
    $P10 = rx179_cur."ws"()
    unless $P10, rx179_fail
    rx179_pos = $P10."pos"()
.annotate 'line', 120
  # rx rxquantr189 ** 0..1
    set_addr $I10, rxquantr189_done
    rx179_cur."!mark_push"(0, rx179_pos, $I10)
  rxquantr189_loop:
  alt190_0:
.annotate 'line', 116
    set_addr $I10, alt190_1
    rx179_cur."!mark_push"(0, rx179_pos, $I10)
.annotate 'line', 117
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx179_cur."!cursor_pos"(rx179_pos)
    $P10 = rx179_cur."MARKED"("endstmt")
    unless $P10, rx179_fail
    goto alt190_end
  alt190_1:
    set_addr $I10, alt190_2
    rx179_cur."!mark_push"(0, rx179_pos, $I10)
.annotate 'line', 118
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx179_cur."!cursor_pos"(rx179_pos)
    $P10 = rx179_cur."statement_mod_cond"()
    unless $P10, rx179_fail
    rx179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx179_pos = $P10."pos"()
  # rx rxquantr191 ** 0..1
    set_addr $I10, rxquantr191_done
    rx179_cur."!mark_push"(0, rx179_pos, $I10)
  rxquantr191_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx179_cur."!cursor_pos"(rx179_pos)
    $P10 = rx179_cur."statement_mod_loop"()
    unless $P10, rx179_fail
    goto rxsubrule192_pass
  rxsubrule192_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx179_fail
  rxsubrule192_pass:
    set_addr $I10, rxsubrule192_back
    rx179_cur."!mark_push"(0, rx179_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx179_pos = $P10."pos"()
    set_addr $I10, rxquantr191_done
    (rx179_rep) = rx179_cur."!mark_commit"($I10)
  rxquantr191_done:
    goto alt190_end
  alt190_2:
.annotate 'line', 119
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx179_cur."!cursor_pos"(rx179_pos)
    $P10 = rx179_cur."statement_mod_loop"()
    unless $P10, rx179_fail
    rx179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx179_pos = $P10."pos"()
  alt190_end:
.annotate 'line', 120
    set_addr $I10, rxquantr189_done
    (rx179_rep) = rx179_cur."!mark_commit"($I10)
  rxquantr189_done:
  alt188_end:
.annotate 'line', 111
  # rx pass
    rx179_cur."!cursor_pass"(rx179_pos, "statement")
    if_null rx179_debug, debug_475
    rx179_cur."!cursor_debug"("PASS", "statement", " at pos=", rx179_pos)
  debug_475:
    .return (rx179_cur)
  rx179_restart:
.annotate 'line', 4
    if_null rx179_debug, debug_476
    rx179_cur."!cursor_debug"("NEXT", "statement")
  debug_476:
  rx179_fail:
    (rx179_rep, rx179_pos, $I10, $P10) = rx179_cur."!mark_fail"(0)
    lt rx179_pos, -1, rx179_done
    eq rx179_pos, -1, rx179_fail
    jump $I10
  rx179_done:
    rx179_cur."!cursor_fail"()
    if_null rx179_debug, debug_477
    rx179_cur."!cursor_debug"("FAIL", "statement")
  debug_477:
    .return (rx179_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1295994649.593") :method
.annotate 'line', 4
    new $P181, "ResizablePMCArray"
    push $P181, ""
    .return ($P181)
.end


.namespace ["NQP";"Grammar"]
.sub "_block183"  :anon :subid("35_1295994649.593") :method :outer("33_1295994649.593")
.annotate 'line', 112
    .local string rx185_tgt
    .local int rx185_pos
    .local int rx185_off
    .local int rx185_eos
    .local int rx185_rep
    .local pmc rx185_cur
    .local pmc rx185_debug
    (rx185_cur, rx185_pos, rx185_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx185_cur
    .local pmc match
    .lex "$/", match
    length rx185_eos, rx185_tgt
    gt rx185_pos, rx185_eos, rx185_done
    set rx185_off, 0
    lt rx185_pos, 2, rx185_start
    sub rx185_off, rx185_pos, 1
    substr rx185_tgt, rx185_tgt, rx185_off
  rx185_start:
    eq $I10, 1, rx185_restart
    if_null rx185_debug, debug_471
    rx185_cur."!cursor_debug"("START", "")
  debug_471:
    $I10 = self.'from'()
    ne $I10, -1, rxscan186_done
    goto rxscan186_scan
  rxscan186_loop:
    ($P10) = rx185_cur."from"()
    inc $P10
    set rx185_pos, $P10
    ge rx185_pos, rx185_eos, rxscan186_done
  rxscan186_scan:
    set_addr $I10, rxscan186_loop
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxscan186_done:
  alt187_0:
    set_addr $I10, alt187_1
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx185_pos, rx185_eos, rx185_fail
    sub $I10, rx185_pos, rx185_off
    substr $S10, rx185_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx185_fail
    inc rx185_pos
    goto alt187_end
  alt187_1:
  # rxanchor eos
    ne rx185_pos, rx185_eos, rx185_fail
  alt187_end:
  # rx pass
    rx185_cur."!cursor_pass"(rx185_pos, "")
    if_null rx185_debug, debug_472
    rx185_cur."!cursor_debug"("PASS", "", " at pos=", rx185_pos)
  debug_472:
    .return (rx185_cur)
  rx185_restart:
    if_null rx185_debug, debug_473
    rx185_cur."!cursor_debug"("NEXT", "")
  debug_473:
  rx185_fail:
    (rx185_rep, rx185_pos, $I10, $P10) = rx185_cur."!mark_fail"(0)
    lt rx185_pos, -1, rx185_done
    eq rx185_pos, -1, rx185_fail
    jump $I10
  rx185_done:
    rx185_cur."!cursor_fail"()
    if_null rx185_debug, debug_474
    rx185_cur."!cursor_debug"("FAIL", "")
  debug_474:
    .return (rx185_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx194_tgt
    .local int rx194_pos
    .local int rx194_off
    .local int rx194_eos
    .local int rx194_rep
    .local pmc rx194_cur
    .local pmc rx194_debug
    (rx194_cur, rx194_pos, rx194_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx194_cur
    .local pmc match
    .lex "$/", match
    length rx194_eos, rx194_tgt
    gt rx194_pos, rx194_eos, rx194_done
    set rx194_off, 0
    lt rx194_pos, 2, rx194_start
    sub rx194_off, rx194_pos, 1
    substr rx194_tgt, rx194_tgt, rx194_off
  rx194_start:
    eq $I10, 1, rx194_restart
    if_null rx194_debug, debug_478
    rx194_cur."!cursor_debug"("START", "eat_terminator")
  debug_478:
    $I10 = self.'from'()
    ne $I10, -1, rxscan197_done
    goto rxscan197_scan
  rxscan197_loop:
    ($P10) = rx194_cur."from"()
    inc $P10
    set rx194_pos, $P10
    ge rx194_pos, rx194_eos, rxscan197_done
  rxscan197_scan:
    set_addr $I10, rxscan197_loop
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
  rxscan197_done:
  alt198_0:
.annotate 'line', 124
    set_addr $I10, alt198_1
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
.annotate 'line', 125
  # rx literal  ";"
    add $I11, rx194_pos, 1
    gt $I11, rx194_eos, rx194_fail
    sub $I11, rx194_pos, rx194_off
    ord $I11, rx194_tgt, $I11
    ne $I11, 59, rx194_fail
    add rx194_pos, 1
    goto alt198_end
  alt198_1:
    set_addr $I10, alt198_2
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
.annotate 'line', 126
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."MARKED"("endstmt")
    unless $P10, rx194_fail
    goto alt198_end
  alt198_2:
    set_addr $I10, alt198_3
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
.annotate 'line', 127
  # rx subrule "terminator" subtype=zerowidth negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."terminator"()
    unless $P10, rx194_fail
    goto alt198_end
  alt198_3:
.annotate 'line', 128
  # rxanchor eos
    ne rx194_pos, rx194_eos, rx194_fail
  alt198_end:
.annotate 'line', 124
  # rx pass
    rx194_cur."!cursor_pass"(rx194_pos, "eat_terminator")
    if_null rx194_debug, debug_479
    rx194_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx194_pos)
  debug_479:
    .return (rx194_cur)
  rx194_restart:
.annotate 'line', 4
    if_null rx194_debug, debug_480
    rx194_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_480:
  rx194_fail:
    (rx194_rep, rx194_pos, $I10, $P10) = rx194_cur."!mark_fail"(0)
    lt rx194_pos, -1, rx194_done
    eq rx194_pos, -1, rx194_fail
    jump $I10
  rx194_done:
    rx194_cur."!cursor_fail"()
    if_null rx194_debug, debug_481
    rx194_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_481:
    .return (rx194_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1295994649.593") :method
.annotate 'line', 4
    new $P196, "ResizablePMCArray"
    push $P196, ""
    push $P196, ""
    push $P196, ""
    push $P196, ";"
    .return ($P196)
.end


.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_482
    rx200_cur."!cursor_debug"("START", "xblock")
  debug_482:
    $I10 = self.'from'()
    ne $I10, -1, rxscan204_done
    goto rxscan204_scan
  rxscan204_loop:
    ($P10) = rx200_cur."from"()
    inc $P10
    set rx200_pos, $P10
    ge rx200_pos, rx200_eos, rxscan204_done
  rxscan204_scan:
    set_addr $I10, rxscan204_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan204_done:
.annotate 'line', 132
  # rx subrule "EXPR" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."EXPR"()
    unless $P10, rx200_fail
    rx200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx200_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."pblock"()
    unless $P10, rx200_fail
    rx200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx200_pos = $P10."pos"()
.annotate 'line', 131
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "xblock")
    if_null rx200_debug, debug_483
    rx200_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx200_pos)
  debug_483:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 4
    if_null rx200_debug, debug_484
    rx200_cur."!cursor_debug"("NEXT", "xblock")
  debug_484:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_485
    rx200_cur."!cursor_debug"("FAIL", "xblock")
  debug_485:
    .return (rx200_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1295994649.593") :method
.annotate 'line', 4
    $P202 = self."!PREFIX__!subrule"("EXPR", "")
    new $P203, "ResizablePMCArray"
    push $P203, $P202
    .return ($P203)
.end


.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx206_tgt
    .local int rx206_pos
    .local int rx206_off
    .local int rx206_eos
    .local int rx206_rep
    .local pmc rx206_cur
    .local pmc rx206_debug
    (rx206_cur, rx206_pos, rx206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx206_cur
    .local pmc match
    .lex "$/", match
    length rx206_eos, rx206_tgt
    gt rx206_pos, rx206_eos, rx206_done
    set rx206_off, 0
    lt rx206_pos, 2, rx206_start
    sub rx206_off, rx206_pos, 1
    substr rx206_tgt, rx206_tgt, rx206_off
  rx206_start:
    eq $I10, 1, rx206_restart
    if_null rx206_debug, debug_486
    rx206_cur."!cursor_debug"("START", "pblock")
  debug_486:
    $I10 = self.'from'()
    ne $I10, -1, rxscan211_done
    goto rxscan211_scan
  rxscan211_loop:
    ($P10) = rx206_cur."from"()
    inc $P10
    set rx206_pos, $P10
    ge rx206_pos, rx206_eos, rxscan211_done
  rxscan211_scan:
    set_addr $I10, rxscan211_loop
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
  rxscan211_done:
  alt212_0:
.annotate 'line', 135
    set_addr $I10, alt212_1
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
.annotate 'line', 136
  # rx subrule "lambda" subtype=method negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."lambda"()
    unless $P10, rx206_fail
    rx206_pos = $P10."pos"()
.annotate 'line', 137
  # rx subrule "newpad" subtype=method negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."newpad"()
    unless $P10, rx206_fail
    rx206_pos = $P10."pos"()
.annotate 'line', 138
  # rx subrule "signature" subtype=capture negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."signature"()
    unless $P10, rx206_fail
    rx206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx206_pos = $P10."pos"()
.annotate 'line', 139
  # rx subrule "blockoid" subtype=capture negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."blockoid"()
    unless $P10, rx206_fail
    rx206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx206_pos = $P10."pos"()
.annotate 'line', 136
    goto alt212_end
  alt212_1:
    set_addr $I10, alt212_2
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
.annotate 'line', 140
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx206_pos, rx206_off
    substr $S10, rx206_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx206_fail
.annotate 'line', 141
  # rx subrule "newpad" subtype=method negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."newpad"()
    unless $P10, rx206_fail
    rx206_pos = $P10."pos"()
.annotate 'line', 142
  # rx subrule "blockoid" subtype=capture negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."blockoid"()
    unless $P10, rx206_fail
    rx206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx206_pos = $P10."pos"()
.annotate 'line', 140
    goto alt212_end
  alt212_2:
.annotate 'line', 143
  # rx subrule "panic" subtype=method negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."panic"("Missing block")
    unless $P10, rx206_fail
    rx206_pos = $P10."pos"()
  alt212_end:
.annotate 'line', 135
  # rx pass
    rx206_cur."!cursor_pass"(rx206_pos, "pblock")
    if_null rx206_debug, debug_487
    rx206_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx206_pos)
  debug_487:
    .return (rx206_cur)
  rx206_restart:
.annotate 'line', 4
    if_null rx206_debug, debug_488
    rx206_cur."!cursor_debug"("NEXT", "pblock")
  debug_488:
  rx206_fail:
    (rx206_rep, rx206_pos, $I10, $P10) = rx206_cur."!mark_fail"(0)
    lt rx206_pos, -1, rx206_done
    eq rx206_pos, -1, rx206_fail
    jump $I10
  rx206_done:
    rx206_cur."!cursor_fail"()
    if_null rx206_debug, debug_489
    rx206_cur."!cursor_debug"("FAIL", "pblock")
  debug_489:
    .return (rx206_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1295994649.593") :method
.annotate 'line', 4
    $P208 = self."!PREFIX__!subrule"("panic", "")
    $P209 = self."!PREFIX__!subrule"("lambda", "")
    new $P210, "ResizablePMCArray"
    push $P210, $P208
    push $P210, "{"
    push $P210, $P209
    .return ($P210)
.end


.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx214_tgt
    .local int rx214_pos
    .local int rx214_off
    .local int rx214_eos
    .local int rx214_rep
    .local pmc rx214_cur
    .local pmc rx214_debug
    (rx214_cur, rx214_pos, rx214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx214_cur
    .local pmc match
    .lex "$/", match
    length rx214_eos, rx214_tgt
    gt rx214_pos, rx214_eos, rx214_done
    set rx214_off, 0
    lt rx214_pos, 2, rx214_start
    sub rx214_off, rx214_pos, 1
    substr rx214_tgt, rx214_tgt, rx214_off
  rx214_start:
    eq $I10, 1, rx214_restart
    if_null rx214_debug, debug_490
    rx214_cur."!cursor_debug"("START", "lambda")
  debug_490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    ($P10) = rx214_cur."from"()
    inc $P10
    set rx214_pos, $P10
    ge rx214_pos, rx214_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  rxscan217_done:
  alt218_0:
.annotate 'line', 146
    set_addr $I10, alt218_1
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  # rx literal  "->"
    add $I11, rx214_pos, 2
    gt $I11, rx214_eos, rx214_fail
    sub $I11, rx214_pos, rx214_off
    substr $S10, rx214_tgt, $I11, 2
    ne $S10, "->", rx214_fail
    add rx214_pos, 2
    goto alt218_end
  alt218_1:
  # rx literal  "<->"
    add $I11, rx214_pos, 3
    gt $I11, rx214_eos, rx214_fail
    sub $I11, rx214_pos, rx214_off
    substr $S10, rx214_tgt, $I11, 3
    ne $S10, "<->", rx214_fail
    add rx214_pos, 3
  alt218_end:
  # rx pass
    rx214_cur."!cursor_pass"(rx214_pos, "lambda")
    if_null rx214_debug, debug_491
    rx214_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx214_pos)
  debug_491:
    .return (rx214_cur)
  rx214_restart:
.annotate 'line', 4
    if_null rx214_debug, debug_492
    rx214_cur."!cursor_debug"("NEXT", "lambda")
  debug_492:
  rx214_fail:
    (rx214_rep, rx214_pos, $I10, $P10) = rx214_cur."!mark_fail"(0)
    lt rx214_pos, -1, rx214_done
    eq rx214_pos, -1, rx214_fail
    jump $I10
  rx214_done:
    rx214_cur."!cursor_fail"()
    if_null rx214_debug, debug_493
    rx214_cur."!cursor_debug"("FAIL", "lambda")
  debug_493:
    .return (rx214_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1295994649.593") :method
.annotate 'line', 4
    new $P216, "ResizablePMCArray"
    push $P216, "<->"
    push $P216, "->"
    .return ($P216)
.end


.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx220_tgt
    .local int rx220_pos
    .local int rx220_off
    .local int rx220_eos
    .local int rx220_rep
    .local pmc rx220_cur
    .local pmc rx220_debug
    (rx220_cur, rx220_pos, rx220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx220_cur
    .local pmc match
    .lex "$/", match
    length rx220_eos, rx220_tgt
    gt rx220_pos, rx220_eos, rx220_done
    set rx220_off, 0
    lt rx220_pos, 2, rx220_start
    sub rx220_off, rx220_pos, 1
    substr rx220_tgt, rx220_tgt, rx220_off
  rx220_start:
    eq $I10, 1, rx220_restart
    if_null rx220_debug, debug_494
    rx220_cur."!cursor_debug"("START", "block")
  debug_494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan224_done
    goto rxscan224_scan
  rxscan224_loop:
    ($P10) = rx220_cur."from"()
    inc $P10
    set rx220_pos, $P10
    ge rx220_pos, rx220_eos, rxscan224_done
  rxscan224_scan:
    set_addr $I10, rxscan224_loop
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxscan224_done:
  alt225_0:
.annotate 'line', 149
    set_addr $I10, alt225_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx220_pos, rx220_off
    substr $S10, rx220_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx220_fail
    goto alt225_end
  alt225_1:
  # rx subrule "panic" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."panic"("Missing block")
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
  alt225_end:
.annotate 'line', 150
  # rx subrule "newpad" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."newpad"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
.annotate 'line', 151
  # rx subrule "blockoid" subtype=capture negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."blockoid"()
    unless $P10, rx220_fail
    rx220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx220_pos = $P10."pos"()
.annotate 'line', 148
  # rx pass
    rx220_cur."!cursor_pass"(rx220_pos, "block")
    if_null rx220_debug, debug_495
    rx220_cur."!cursor_debug"("PASS", "block", " at pos=", rx220_pos)
  debug_495:
    .return (rx220_cur)
  rx220_restart:
.annotate 'line', 4
    if_null rx220_debug, debug_496
    rx220_cur."!cursor_debug"("NEXT", "block")
  debug_496:
  rx220_fail:
    (rx220_rep, rx220_pos, $I10, $P10) = rx220_cur."!mark_fail"(0)
    lt rx220_pos, -1, rx220_done
    eq rx220_pos, -1, rx220_fail
    jump $I10
  rx220_done:
    rx220_cur."!cursor_fail"()
    if_null rx220_debug, debug_497
    rx220_cur."!cursor_debug"("FAIL", "block")
  debug_497:
    .return (rx220_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1295994649.593") :method
.annotate 'line', 4
    $P222 = self."!PREFIX__!subrule"("panic", "")
    new $P223, "ResizablePMCArray"
    push $P223, $P222
    push $P223, "{"
    .return ($P223)
.end


.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx227_tgt
    .local int rx227_pos
    .local int rx227_off
    .local int rx227_eos
    .local int rx227_rep
    .local pmc rx227_cur
    .local pmc rx227_debug
    (rx227_cur, rx227_pos, rx227_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx227_cur
    .local pmc match
    .lex "$/", match
    length rx227_eos, rx227_tgt
    gt rx227_pos, rx227_eos, rx227_done
    set rx227_off, 0
    lt rx227_pos, 2, rx227_start
    sub rx227_off, rx227_pos, 1
    substr rx227_tgt, rx227_tgt, rx227_off
  rx227_start:
    eq $I10, 1, rx227_restart
    if_null rx227_debug, debug_498
    rx227_cur."!cursor_debug"("START", "blockoid")
  debug_498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan231_done
    goto rxscan231_scan
  rxscan231_loop:
    ($P10) = rx227_cur."from"()
    inc $P10
    set rx227_pos, $P10
    ge rx227_pos, rx227_eos, rxscan231_done
  rxscan231_scan:
    set_addr $I10, rxscan231_loop
    rx227_cur."!mark_push"(0, rx227_pos, $I10)
  rxscan231_done:
.annotate 'line', 155
  # rx subrule "finishpad" subtype=method negate=
    rx227_cur."!cursor_pos"(rx227_pos)
    $P10 = rx227_cur."finishpad"()
    unless $P10, rx227_fail
    rx227_pos = $P10."pos"()
.annotate 'line', 156
  # rx literal  "{"
    add $I11, rx227_pos, 1
    gt $I11, rx227_eos, rx227_fail
    sub $I11, rx227_pos, rx227_off
    ord $I11, rx227_tgt, $I11
    ne $I11, 123, rx227_fail
    add rx227_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx227_cur."!cursor_pos"(rx227_pos)
    $P10 = rx227_cur."statementlist"()
    unless $P10, rx227_fail
    rx227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx227_pos = $P10."pos"()
  alt232_0:
    set_addr $I10, alt232_1
    rx227_cur."!mark_push"(0, rx227_pos, $I10)
  # rx literal  "}"
    add $I11, rx227_pos, 1
    gt $I11, rx227_eos, rx227_fail
    sub $I11, rx227_pos, rx227_off
    ord $I11, rx227_tgt, $I11
    ne $I11, 125, rx227_fail
    add rx227_pos, 1
    goto alt232_end
  alt232_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx227_cur."!cursor_pos"(rx227_pos)
    $P10 = rx227_cur."FAILGOAL"("'}'")
    unless $P10, rx227_fail
    goto rxsubrule234_pass
  rxsubrule234_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx227_fail
  rxsubrule234_pass:
    set_addr $I10, rxsubrule234_back
    rx227_cur."!mark_push"(0, rx227_pos, $I10, $P10)
    rx227_pos = $P10."pos"()
  alt232_end:
.annotate 'line', 157
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx227_cur."!cursor_pos"(rx227_pos)
    $P10 = rx227_cur."ENDSTMT"()
    unless $P10, rx227_fail
.annotate 'line', 154
  # rx pass
    rx227_cur."!cursor_pass"(rx227_pos, "blockoid")
    if_null rx227_debug, debug_499
    rx227_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx227_pos)
  debug_499:
    .return (rx227_cur)
  rx227_restart:
.annotate 'line', 4
    if_null rx227_debug, debug_500
    rx227_cur."!cursor_debug"("NEXT", "blockoid")
  debug_500:
  rx227_fail:
    (rx227_rep, rx227_pos, $I10, $P10) = rx227_cur."!mark_fail"(0)
    lt rx227_pos, -1, rx227_done
    eq rx227_pos, -1, rx227_fail
    jump $I10
  rx227_done:
    rx227_cur."!cursor_fail"()
    if_null rx227_debug, debug_501
    rx227_cur."!cursor_debug"("FAIL", "blockoid")
  debug_501:
    .return (rx227_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1295994649.593") :method
.annotate 'line', 4
    $P229 = self."!PREFIX__!subrule"("finishpad", "")
    new $P230, "ResizablePMCArray"
    push $P230, $P229
    .return ($P230)
.end


.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx236_tgt
    .local int rx236_pos
    .local int rx236_off
    .local int rx236_eos
    .local int rx236_rep
    .local pmc rx236_cur
    .local pmc rx236_debug
    (rx236_cur, rx236_pos, rx236_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx236_cur
    .local pmc match
    .lex "$/", match
    length rx236_eos, rx236_tgt
    gt rx236_pos, rx236_eos, rx236_done
    set rx236_off, 0
    lt rx236_pos, 2, rx236_start
    sub rx236_off, rx236_pos, 1
    substr rx236_tgt, rx236_tgt, rx236_off
  rx236_start:
    eq $I10, 1, rx236_restart
    if_null rx236_debug, debug_502
    rx236_cur."!cursor_debug"("START", "newpad")
  debug_502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan239_done
    goto rxscan239_scan
  rxscan239_loop:
    ($P10) = rx236_cur."from"()
    inc $P10
    set rx236_pos, $P10
    ge rx236_pos, rx236_eos, rxscan239_done
  rxscan239_scan:
    set_addr $I10, rxscan239_loop
    rx236_cur."!mark_push"(0, rx236_pos, $I10)
  rxscan239_done:
.annotate 'line', 160
  # rx pass
    rx236_cur."!cursor_pass"(rx236_pos, "newpad")
    if_null rx236_debug, debug_503
    rx236_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx236_pos)
  debug_503:
    .return (rx236_cur)
  rx236_restart:
.annotate 'line', 4
    if_null rx236_debug, debug_504
    rx236_cur."!cursor_debug"("NEXT", "newpad")
  debug_504:
  rx236_fail:
    (rx236_rep, rx236_pos, $I10, $P10) = rx236_cur."!mark_fail"(0)
    lt rx236_pos, -1, rx236_done
    eq rx236_pos, -1, rx236_fail
    jump $I10
  rx236_done:
    rx236_cur."!cursor_fail"()
    if_null rx236_debug, debug_505
    rx236_cur."!cursor_debug"("FAIL", "newpad")
  debug_505:
    .return (rx236_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1295994649.593") :method
.annotate 'line', 4
    new $P238, "ResizablePMCArray"
    push $P238, ""
    .return ($P238)
.end


.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx241_tgt
    .local int rx241_pos
    .local int rx241_off
    .local int rx241_eos
    .local int rx241_rep
    .local pmc rx241_cur
    .local pmc rx241_debug
    (rx241_cur, rx241_pos, rx241_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx241_cur
    .local pmc match
    .lex "$/", match
    length rx241_eos, rx241_tgt
    gt rx241_pos, rx241_eos, rx241_done
    set rx241_off, 0
    lt rx241_pos, 2, rx241_start
    sub rx241_off, rx241_pos, 1
    substr rx241_tgt, rx241_tgt, rx241_off
  rx241_start:
    eq $I10, 1, rx241_restart
    if_null rx241_debug, debug_506
    rx241_cur."!cursor_debug"("START", "outerctx")
  debug_506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan244_done
    goto rxscan244_scan
  rxscan244_loop:
    ($P10) = rx241_cur."from"()
    inc $P10
    set rx241_pos, $P10
    ge rx241_pos, rx241_eos, rxscan244_done
  rxscan244_scan:
    set_addr $I10, rxscan244_loop
    rx241_cur."!mark_push"(0, rx241_pos, $I10)
  rxscan244_done:
.annotate 'line', 161
  # rx pass
    rx241_cur."!cursor_pass"(rx241_pos, "outerctx")
    if_null rx241_debug, debug_507
    rx241_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx241_pos)
  debug_507:
    .return (rx241_cur)
  rx241_restart:
.annotate 'line', 4
    if_null rx241_debug, debug_508
    rx241_cur."!cursor_debug"("NEXT", "outerctx")
  debug_508:
  rx241_fail:
    (rx241_rep, rx241_pos, $I10, $P10) = rx241_cur."!mark_fail"(0)
    lt rx241_pos, -1, rx241_done
    eq rx241_pos, -1, rx241_fail
    jump $I10
  rx241_done:
    rx241_cur."!cursor_fail"()
    if_null rx241_debug, debug_509
    rx241_cur."!cursor_debug"("FAIL", "outerctx")
  debug_509:
    .return (rx241_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1295994649.593") :method
.annotate 'line', 4
    new $P243, "ResizablePMCArray"
    push $P243, ""
    .return ($P243)
.end


.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx246_tgt
    .local int rx246_pos
    .local int rx246_off
    .local int rx246_eos
    .local int rx246_rep
    .local pmc rx246_cur
    .local pmc rx246_debug
    (rx246_cur, rx246_pos, rx246_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx246_cur
    .local pmc match
    .lex "$/", match
    length rx246_eos, rx246_tgt
    gt rx246_pos, rx246_eos, rx246_done
    set rx246_off, 0
    lt rx246_pos, 2, rx246_start
    sub rx246_off, rx246_pos, 1
    substr rx246_tgt, rx246_tgt, rx246_off
  rx246_start:
    eq $I10, 1, rx246_restart
    if_null rx246_debug, debug_510
    rx246_cur."!cursor_debug"("START", "finishpad")
  debug_510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan249_done
    goto rxscan249_scan
  rxscan249_loop:
    ($P10) = rx246_cur."from"()
    inc $P10
    set rx246_pos, $P10
    ge rx246_pos, rx246_eos, rxscan249_done
  rxscan249_scan:
    set_addr $I10, rxscan249_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  rxscan249_done:
.annotate 'line', 162
  # rx pass
    rx246_cur."!cursor_pass"(rx246_pos, "finishpad")
    if_null rx246_debug, debug_511
    rx246_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx246_pos)
  debug_511:
    .return (rx246_cur)
  rx246_restart:
.annotate 'line', 4
    if_null rx246_debug, debug_512
    rx246_cur."!cursor_debug"("NEXT", "finishpad")
  debug_512:
  rx246_fail:
    (rx246_rep, rx246_pos, $I10, $P10) = rx246_cur."!mark_fail"(0)
    lt rx246_pos, -1, rx246_done
    eq rx246_pos, -1, rx246_fail
    jump $I10
  rx246_done:
    rx246_cur."!cursor_fail"()
    if_null rx246_debug, debug_513
    rx246_cur."!cursor_debug"("FAIL", "finishpad")
  debug_513:
    .return (rx246_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1295994649.593") :method
.annotate 'line', 4
    new $P248, "ResizablePMCArray"
    push $P248, ""
    .return ($P248)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("54_1295994649.593")
    .param pmc param_251
.annotate 'line', 164
    .lex "self", param_251
    $P252 = param_251."!protoregex"("terminator")
    .return ($P252)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("55_1295994649.593")
    .param pmc param_254
.annotate 'line', 164
    .lex "self", param_254
    $P255 = param_254."!PREFIX__!protoregex"("terminator")
    .return ($P255)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("56_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx257_tgt
    .local int rx257_pos
    .local int rx257_off
    .local int rx257_eos
    .local int rx257_rep
    .local pmc rx257_cur
    .local pmc rx257_debug
    (rx257_cur, rx257_pos, rx257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx257_cur
    .local pmc match
    .lex "$/", match
    length rx257_eos, rx257_tgt
    gt rx257_pos, rx257_eos, rx257_done
    set rx257_off, 0
    lt rx257_pos, 2, rx257_start
    sub rx257_off, rx257_pos, 1
    substr rx257_tgt, rx257_tgt, rx257_off
  rx257_start:
    eq $I10, 1, rx257_restart
    if_null rx257_debug, debug_514
    rx257_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan260_done
    goto rxscan260_scan
  rxscan260_loop:
    ($P10) = rx257_cur."from"()
    inc $P10
    set rx257_pos, $P10
    ge rx257_pos, rx257_eos, rxscan260_done
  rxscan260_scan:
    set_addr $I10, rxscan260_loop
    rx257_cur."!mark_push"(0, rx257_pos, $I10)
  rxscan260_done:
.annotate 'line', 166
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx257_pos, rx257_off
    substr $S10, rx257_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx257_fail
  # rx pass
    rx257_cur."!cursor_pass"(rx257_pos, "terminator:sym<;>")
    if_null rx257_debug, debug_515
    rx257_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx257_pos)
  debug_515:
    .return (rx257_cur)
  rx257_restart:
.annotate 'line', 4
    if_null rx257_debug, debug_516
    rx257_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_516:
  rx257_fail:
    (rx257_rep, rx257_pos, $I10, $P10) = rx257_cur."!mark_fail"(0)
    lt rx257_pos, -1, rx257_done
    eq rx257_pos, -1, rx257_fail
    jump $I10
  rx257_done:
    rx257_cur."!cursor_fail"()
    if_null rx257_debug, debug_517
    rx257_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_517:
    .return (rx257_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("57_1295994649.593") :method
.annotate 'line', 4
    new $P259, "ResizablePMCArray"
    push $P259, ";"
    .return ($P259)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("58_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx262_tgt
    .local int rx262_pos
    .local int rx262_off
    .local int rx262_eos
    .local int rx262_rep
    .local pmc rx262_cur
    .local pmc rx262_debug
    (rx262_cur, rx262_pos, rx262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx262_cur
    .local pmc match
    .lex "$/", match
    length rx262_eos, rx262_tgt
    gt rx262_pos, rx262_eos, rx262_done
    set rx262_off, 0
    lt rx262_pos, 2, rx262_start
    sub rx262_off, rx262_pos, 1
    substr rx262_tgt, rx262_tgt, rx262_off
  rx262_start:
    eq $I10, 1, rx262_restart
    if_null rx262_debug, debug_518
    rx262_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan265_done
    goto rxscan265_scan
  rxscan265_loop:
    ($P10) = rx262_cur."from"()
    inc $P10
    set rx262_pos, $P10
    ge rx262_pos, rx262_eos, rxscan265_done
  rxscan265_scan:
    set_addr $I10, rxscan265_loop
    rx262_cur."!mark_push"(0, rx262_pos, $I10)
  rxscan265_done:
.annotate 'line', 167
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx262_pos, rx262_off
    substr $S10, rx262_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx262_fail
  # rx pass
    rx262_cur."!cursor_pass"(rx262_pos, "terminator:sym<}>")
    if_null rx262_debug, debug_519
    rx262_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx262_pos)
  debug_519:
    .return (rx262_cur)
  rx262_restart:
.annotate 'line', 4
    if_null rx262_debug, debug_520
    rx262_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_520:
  rx262_fail:
    (rx262_rep, rx262_pos, $I10, $P10) = rx262_cur."!mark_fail"(0)
    lt rx262_pos, -1, rx262_done
    eq rx262_pos, -1, rx262_fail
    jump $I10
  rx262_done:
    rx262_cur."!cursor_fail"()
    if_null rx262_debug, debug_521
    rx262_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_521:
    .return (rx262_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("59_1295994649.593") :method
.annotate 'line', 4
    new $P264, "ResizablePMCArray"
    push $P264, "}"
    .return ($P264)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("60_1295994649.593")
    .param pmc param_267
.annotate 'line', 171
    .lex "self", param_267
    $P268 = param_267."!protoregex"("statement_control")
    .return ($P268)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("61_1295994649.593")
    .param pmc param_270
.annotate 'line', 171
    .lex "self", param_270
    $P271 = param_270."!PREFIX__!protoregex"("statement_control")
    .return ($P271)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("62_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx273_tgt
    .local int rx273_pos
    .local int rx273_off
    .local int rx273_eos
    .local int rx273_rep
    .local pmc rx273_cur
    .local pmc rx273_debug
    (rx273_cur, rx273_pos, rx273_tgt, $I10) = self."!cursor_start"()
    rx273_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx273_cur
    .local pmc match
    .lex "$/", match
    length rx273_eos, rx273_tgt
    gt rx273_pos, rx273_eos, rx273_done
    set rx273_off, 0
    lt rx273_pos, 2, rx273_start
    sub rx273_off, rx273_pos, 1
    substr rx273_tgt, rx273_tgt, rx273_off
  rx273_start:
    eq $I10, 1, rx273_restart
    if_null rx273_debug, debug_522
    rx273_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan276_done
    goto rxscan276_scan
  rxscan276_loop:
    ($P10) = rx273_cur."from"()
    inc $P10
    set rx273_pos, $P10
    ge rx273_pos, rx273_eos, rxscan276_done
  rxscan276_scan:
    set_addr $I10, rxscan276_loop
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  rxscan276_done:
.annotate 'line', 174
  # rx subcapture "sym"
    set_addr $I10, rxcap_277_fail
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  # rx literal  "if"
    add $I11, rx273_pos, 2
    gt $I11, rx273_eos, rx273_fail
    sub $I11, rx273_pos, rx273_off
    substr $S10, rx273_tgt, $I11, 2
    ne $S10, "if", rx273_fail
    add rx273_pos, 2
    set_addr $I10, rxcap_277_fail
    ($I12, $I11) = rx273_cur."!mark_peek"($I10)
    rx273_cur."!cursor_pos"($I11)
    ($P10) = rx273_cur."!cursor_start"()
    $P10."!cursor_pass"(rx273_pos, "")
    rx273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_277_done
  rxcap_277_fail:
    goto rx273_fail
  rxcap_277_done:
  # rx charclass s
    ge rx273_pos, rx273_eos, rx273_fail
    sub $I10, rx273_pos, rx273_off
    is_cclass $I11, 32, rx273_tgt, $I10
    unless $I11, rx273_fail
    inc rx273_pos
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
.annotate 'line', 175
  # rx subrule "xblock" subtype=capture negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."xblock"()
    unless $P10, rx273_fail
    rx273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx273_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
.annotate 'line', 176
  # rx rxquantr280 ** 0..*
    set_addr $I10, rxquantr280_done
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  rxquantr280_loop:
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx273_pos, 5
    gt $I11, rx273_eos, rx273_fail
    sub $I11, rx273_pos, rx273_off
    substr $S10, rx273_tgt, $I11, 5
    ne $S10, "elsif", rx273_fail
    add rx273_pos, 5
  # rx charclass s
    ge rx273_pos, rx273_eos, rx273_fail
    sub $I10, rx273_pos, rx273_off
    is_cclass $I11, 32, rx273_tgt, $I10
    unless $I11, rx273_fail
    inc rx273_pos
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."xblock"()
    unless $P10, rx273_fail
    rx273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx273_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
    set_addr $I10, rxquantr280_done
    (rx273_rep) = rx273_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr280_done
    rx273_cur."!mark_push"(rx273_rep, rx273_pos, $I10)
    goto rxquantr280_loop
  rxquantr280_done:
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
.annotate 'line', 177
  # rx rxquantr285 ** 0..1
    set_addr $I10, rxquantr285_done
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  rxquantr285_loop:
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx273_pos, 4
    gt $I11, rx273_eos, rx273_fail
    sub $I11, rx273_pos, rx273_off
    substr $S10, rx273_tgt, $I11, 4
    ne $S10, "else", rx273_fail
    add rx273_pos, 4
  # rx charclass s
    ge rx273_pos, rx273_eos, rx273_fail
    sub $I10, rx273_pos, rx273_off
    is_cclass $I11, 32, rx273_tgt, $I10
    unless $I11, rx273_fail
    inc rx273_pos
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."pblock"()
    unless $P10, rx273_fail
    rx273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx273_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
    set_addr $I10, rxquantr285_done
    (rx273_rep) = rx273_cur."!mark_commit"($I10)
  rxquantr285_done:
  # rx subrule "ws" subtype=method negate=
    rx273_cur."!cursor_pos"(rx273_pos)
    $P10 = rx273_cur."ws"()
    unless $P10, rx273_fail
    rx273_pos = $P10."pos"()
.annotate 'line', 173
  # rx pass
    rx273_cur."!cursor_pass"(rx273_pos, "statement_control:sym<if>")
    if_null rx273_debug, debug_523
    rx273_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx273_pos)
  debug_523:
    .return (rx273_cur)
  rx273_restart:
.annotate 'line', 4
    if_null rx273_debug, debug_524
    rx273_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_524:
  rx273_fail:
    (rx273_rep, rx273_pos, $I10, $P10) = rx273_cur."!mark_fail"(0)
    lt rx273_pos, -1, rx273_done
    eq rx273_pos, -1, rx273_fail
    jump $I10
  rx273_done:
    rx273_cur."!cursor_fail"()
    if_null rx273_debug, debug_525
    rx273_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_525:
    .return (rx273_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("63_1295994649.593") :method
.annotate 'line', 4
    new $P275, "ResizablePMCArray"
    push $P275, "if"
    .return ($P275)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("64_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P301 = "66_1295994649.593" 
    capture_lex $P301
    .local string rx291_tgt
    .local int rx291_pos
    .local int rx291_off
    .local int rx291_eos
    .local int rx291_rep
    .local pmc rx291_cur
    .local pmc rx291_debug
    (rx291_cur, rx291_pos, rx291_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx291_cur
    .local pmc match
    .lex "$/", match
    length rx291_eos, rx291_tgt
    gt rx291_pos, rx291_eos, rx291_done
    set rx291_off, 0
    lt rx291_pos, 2, rx291_start
    sub rx291_off, rx291_pos, 1
    substr rx291_tgt, rx291_tgt, rx291_off
  rx291_start:
    eq $I10, 1, rx291_restart
    if_null rx291_debug, debug_526
    rx291_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan294_done
    goto rxscan294_scan
  rxscan294_loop:
    ($P10) = rx291_cur."from"()
    inc $P10
    set rx291_pos, $P10
    ge rx291_pos, rx291_eos, rxscan294_done
  rxscan294_scan:
    set_addr $I10, rxscan294_loop
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  rxscan294_done:
.annotate 'line', 181
  # rx subcapture "sym"
    set_addr $I10, rxcap_295_fail
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  # rx literal  "unless"
    add $I11, rx291_pos, 6
    gt $I11, rx291_eos, rx291_fail
    sub $I11, rx291_pos, rx291_off
    substr $S10, rx291_tgt, $I11, 6
    ne $S10, "unless", rx291_fail
    add rx291_pos, 6
    set_addr $I10, rxcap_295_fail
    ($I12, $I11) = rx291_cur."!mark_peek"($I10)
    rx291_cur."!cursor_pos"($I11)
    ($P10) = rx291_cur."!cursor_start"()
    $P10."!cursor_pass"(rx291_pos, "")
    rx291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_295_done
  rxcap_295_fail:
    goto rx291_fail
  rxcap_295_done:
  # rx charclass s
    ge rx291_pos, rx291_eos, rx291_fail
    sub $I10, rx291_pos, rx291_off
    is_cclass $I11, 32, rx291_tgt, $I10
    unless $I11, rx291_fail
    inc rx291_pos
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
.annotate 'line', 182
  # rx subrule "xblock" subtype=capture negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."xblock"()
    unless $P10, rx291_fail
    rx291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx291_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  alt298_0:
.annotate 'line', 183
    set_addr $I10, alt298_1
    rx291_cur."!mark_push"(0, rx291_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx291_cur."!cursor_pos"(rx291_pos)
    .const 'Sub' $P301 = "66_1295994649.593" 
    capture_lex $P301
    $P10 = rx291_cur."before"($P301)
    if $P10, rx291_fail
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
    goto alt298_end
  alt298_1:
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
  alt298_end:
  # rx subrule "ws" subtype=method negate=
    rx291_cur."!cursor_pos"(rx291_pos)
    $P10 = rx291_cur."ws"()
    unless $P10, rx291_fail
    rx291_pos = $P10."pos"()
.annotate 'line', 180
  # rx pass
    rx291_cur."!cursor_pass"(rx291_pos, "statement_control:sym<unless>")
    if_null rx291_debug, debug_531
    rx291_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx291_pos)
  debug_531:
    .return (rx291_cur)
  rx291_restart:
.annotate 'line', 4
    if_null rx291_debug, debug_532
    rx291_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_532:
  rx291_fail:
    (rx291_rep, rx291_pos, $I10, $P10) = rx291_cur."!mark_fail"(0)
    lt rx291_pos, -1, rx291_done
    eq rx291_pos, -1, rx291_fail
    jump $I10
  rx291_done:
    rx291_cur."!cursor_fail"()
    if_null rx291_debug, debug_533
    rx291_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_533:
    .return (rx291_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("65_1295994649.593") :method
.annotate 'line', 4
    new $P293, "ResizablePMCArray"
    push $P293, "unless"
    .return ($P293)
.end


.namespace ["NQP";"Grammar"]
.sub "_block300"  :anon :subid("66_1295994649.593") :method :outer("64_1295994649.593")
.annotate 'line', 183
    .local string rx302_tgt
    .local int rx302_pos
    .local int rx302_off
    .local int rx302_eos
    .local int rx302_rep
    .local pmc rx302_cur
    .local pmc rx302_debug
    (rx302_cur, rx302_pos, rx302_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx302_cur
    .local pmc match
    .lex "$/", match
    length rx302_eos, rx302_tgt
    gt rx302_pos, rx302_eos, rx302_done
    set rx302_off, 0
    lt rx302_pos, 2, rx302_start
    sub rx302_off, rx302_pos, 1
    substr rx302_tgt, rx302_tgt, rx302_off
  rx302_start:
    eq $I10, 1, rx302_restart
    if_null rx302_debug, debug_527
    rx302_cur."!cursor_debug"("START", "")
  debug_527:
    $I10 = self.'from'()
    ne $I10, -1, rxscan303_done
    goto rxscan303_scan
  rxscan303_loop:
    ($P10) = rx302_cur."from"()
    inc $P10
    set rx302_pos, $P10
    ge rx302_pos, rx302_eos, rxscan303_done
  rxscan303_scan:
    set_addr $I10, rxscan303_loop
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxscan303_done:
  # rx literal  "else"
    add $I11, rx302_pos, 4
    gt $I11, rx302_eos, rx302_fail
    sub $I11, rx302_pos, rx302_off
    substr $S10, rx302_tgt, $I11, 4
    ne $S10, "else", rx302_fail
    add rx302_pos, 4
  # rx pass
    rx302_cur."!cursor_pass"(rx302_pos, "")
    if_null rx302_debug, debug_528
    rx302_cur."!cursor_debug"("PASS", "", " at pos=", rx302_pos)
  debug_528:
    .return (rx302_cur)
  rx302_restart:
    if_null rx302_debug, debug_529
    rx302_cur."!cursor_debug"("NEXT", "")
  debug_529:
  rx302_fail:
    (rx302_rep, rx302_pos, $I10, $P10) = rx302_cur."!mark_fail"(0)
    lt rx302_pos, -1, rx302_done
    eq rx302_pos, -1, rx302_fail
    jump $I10
  rx302_done:
    rx302_cur."!cursor_fail"()
    if_null rx302_debug, debug_530
    rx302_cur."!cursor_debug"("FAIL", "")
  debug_530:
    .return (rx302_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("67_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx309_tgt
    .local int rx309_pos
    .local int rx309_off
    .local int rx309_eos
    .local int rx309_rep
    .local pmc rx309_cur
    .local pmc rx309_debug
    (rx309_cur, rx309_pos, rx309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx309_cur
    .local pmc match
    .lex "$/", match
    length rx309_eos, rx309_tgt
    gt rx309_pos, rx309_eos, rx309_done
    set rx309_off, 0
    lt rx309_pos, 2, rx309_start
    sub rx309_off, rx309_pos, 1
    substr rx309_tgt, rx309_tgt, rx309_off
  rx309_start:
    eq $I10, 1, rx309_restart
    if_null rx309_debug, debug_534
    rx309_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_534:
    $I10 = self.'from'()
    ne $I10, -1, rxscan312_done
    goto rxscan312_scan
  rxscan312_loop:
    ($P10) = rx309_cur."from"()
    inc $P10
    set rx309_pos, $P10
    ge rx309_pos, rx309_eos, rxscan312_done
  rxscan312_scan:
    set_addr $I10, rxscan312_loop
    rx309_cur."!mark_push"(0, rx309_pos, $I10)
  rxscan312_done:
.annotate 'line', 187
  # rx subcapture "sym"
    set_addr $I10, rxcap_314_fail
    rx309_cur."!mark_push"(0, rx309_pos, $I10)
  alt313_0:
    set_addr $I10, alt313_1
    rx309_cur."!mark_push"(0, rx309_pos, $I10)
  # rx literal  "while"
    add $I11, rx309_pos, 5
    gt $I11, rx309_eos, rx309_fail
    sub $I11, rx309_pos, rx309_off
    substr $S10, rx309_tgt, $I11, 5
    ne $S10, "while", rx309_fail
    add rx309_pos, 5
    goto alt313_end
  alt313_1:
  # rx literal  "until"
    add $I11, rx309_pos, 5
    gt $I11, rx309_eos, rx309_fail
    sub $I11, rx309_pos, rx309_off
    substr $S10, rx309_tgt, $I11, 5
    ne $S10, "until", rx309_fail
    add rx309_pos, 5
  alt313_end:
    set_addr $I10, rxcap_314_fail
    ($I12, $I11) = rx309_cur."!mark_peek"($I10)
    rx309_cur."!cursor_pos"($I11)
    ($P10) = rx309_cur."!cursor_start"()
    $P10."!cursor_pass"(rx309_pos, "")
    rx309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_314_done
  rxcap_314_fail:
    goto rx309_fail
  rxcap_314_done:
  # rx charclass s
    ge rx309_pos, rx309_eos, rx309_fail
    sub $I10, rx309_pos, rx309_off
    is_cclass $I11, 32, rx309_tgt, $I10
    unless $I11, rx309_fail
    inc rx309_pos
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
.annotate 'line', 188
  # rx subrule "xblock" subtype=capture negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."xblock"()
    unless $P10, rx309_fail
    rx309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx309_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx309_cur."!cursor_pos"(rx309_pos)
    $P10 = rx309_cur."ws"()
    unless $P10, rx309_fail
    rx309_pos = $P10."pos"()
.annotate 'line', 186
  # rx pass
    rx309_cur."!cursor_pass"(rx309_pos, "statement_control:sym<while>")
    if_null rx309_debug, debug_535
    rx309_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx309_pos)
  debug_535:
    .return (rx309_cur)
  rx309_restart:
.annotate 'line', 4
    if_null rx309_debug, debug_536
    rx309_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_536:
  rx309_fail:
    (rx309_rep, rx309_pos, $I10, $P10) = rx309_cur."!mark_fail"(0)
    lt rx309_pos, -1, rx309_done
    eq rx309_pos, -1, rx309_fail
    jump $I10
  rx309_done:
    rx309_cur."!cursor_fail"()
    if_null rx309_debug, debug_537
    rx309_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_537:
    .return (rx309_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("68_1295994649.593") :method
.annotate 'line', 4
    new $P311, "ResizablePMCArray"
    push $P311, "until"
    push $P311, "while"
    .return ($P311)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("69_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx318_tgt
    .local int rx318_pos
    .local int rx318_off
    .local int rx318_eos
    .local int rx318_rep
    .local pmc rx318_cur
    .local pmc rx318_debug
    (rx318_cur, rx318_pos, rx318_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx318_cur
    .local pmc match
    .lex "$/", match
    length rx318_eos, rx318_tgt
    gt rx318_pos, rx318_eos, rx318_done
    set rx318_off, 0
    lt rx318_pos, 2, rx318_start
    sub rx318_off, rx318_pos, 1
    substr rx318_tgt, rx318_tgt, rx318_off
  rx318_start:
    eq $I10, 1, rx318_restart
    if_null rx318_debug, debug_538
    rx318_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan321_done
    goto rxscan321_scan
  rxscan321_loop:
    ($P10) = rx318_cur."from"()
    inc $P10
    set rx318_pos, $P10
    ge rx318_pos, rx318_eos, rxscan321_done
  rxscan321_scan:
    set_addr $I10, rxscan321_loop
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxscan321_done:
.annotate 'line', 192
  # rx subcapture "sym"
    set_addr $I10, rxcap_322_fail
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx318_pos, 6
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 6
    ne $S10, "repeat", rx318_fail
    add rx318_pos, 6
    set_addr $I10, rxcap_322_fail
    ($I12, $I11) = rx318_cur."!mark_peek"($I10)
    rx318_cur."!cursor_pos"($I11)
    ($P10) = rx318_cur."!cursor_start"()
    $P10."!cursor_pass"(rx318_pos, "")
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_322_done
  rxcap_322_fail:
    goto rx318_fail
  rxcap_322_done:
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  alt324_0:
.annotate 'line', 193
    set_addr $I10, alt324_1
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
.annotate 'line', 194
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_327_fail
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  alt326_0:
    set_addr $I10, alt326_1
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  # rx literal  "while"
    add $I11, rx318_pos, 5
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 5
    ne $S10, "while", rx318_fail
    add rx318_pos, 5
    goto alt326_end
  alt326_1:
  # rx literal  "until"
    add $I11, rx318_pos, 5
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 5
    ne $S10, "until", rx318_fail
    add rx318_pos, 5
  alt326_end:
    set_addr $I10, rxcap_327_fail
    ($I12, $I11) = rx318_cur."!mark_peek"($I10)
    rx318_cur."!cursor_pos"($I11)
    ($P10) = rx318_cur."!cursor_start"()
    $P10."!cursor_pass"(rx318_pos, "")
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_327_done
  rxcap_327_fail:
    goto rx318_fail
  rxcap_327_done:
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."xblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
    goto alt324_end
  alt324_1:
.annotate 'line', 195
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."pblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_333_fail
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  alt332_0:
    set_addr $I10, alt332_1
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  # rx literal  "while"
    add $I11, rx318_pos, 5
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 5
    ne $S10, "while", rx318_fail
    add rx318_pos, 5
    goto alt332_end
  alt332_1:
  # rx literal  "until"
    add $I11, rx318_pos, 5
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 5
    ne $S10, "until", rx318_fail
    add rx318_pos, 5
  alt332_end:
    set_addr $I10, rxcap_333_fail
    ($I12, $I11) = rx318_cur."!mark_peek"($I10)
    rx318_cur."!cursor_pos"($I11)
    ($P10) = rx318_cur."!cursor_start"()
    $P10."!cursor_pass"(rx318_pos, "")
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_333_done
  rxcap_333_fail:
    goto rx318_fail
  rxcap_333_done:
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."EXPR"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  alt324_end:
.annotate 'line', 196
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 191
  # rx pass
    rx318_cur."!cursor_pass"(rx318_pos, "statement_control:sym<repeat>")
    if_null rx318_debug, debug_539
    rx318_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx318_pos)
  debug_539:
    .return (rx318_cur)
  rx318_restart:
.annotate 'line', 4
    if_null rx318_debug, debug_540
    rx318_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_540:
  rx318_fail:
    (rx318_rep, rx318_pos, $I10, $P10) = rx318_cur."!mark_fail"(0)
    lt rx318_pos, -1, rx318_done
    eq rx318_pos, -1, rx318_fail
    jump $I10
  rx318_done:
    rx318_cur."!cursor_fail"()
    if_null rx318_debug, debug_541
    rx318_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_541:
    .return (rx318_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("70_1295994649.593") :method
.annotate 'line', 4
    new $P320, "ResizablePMCArray"
    push $P320, "repeat"
    .return ($P320)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("71_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx338_tgt
    .local int rx338_pos
    .local int rx338_off
    .local int rx338_eos
    .local int rx338_rep
    .local pmc rx338_cur
    .local pmc rx338_debug
    (rx338_cur, rx338_pos, rx338_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx338_cur
    .local pmc match
    .lex "$/", match
    length rx338_eos, rx338_tgt
    gt rx338_pos, rx338_eos, rx338_done
    set rx338_off, 0
    lt rx338_pos, 2, rx338_start
    sub rx338_off, rx338_pos, 1
    substr rx338_tgt, rx338_tgt, rx338_off
  rx338_start:
    eq $I10, 1, rx338_restart
    if_null rx338_debug, debug_542
    rx338_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_542:
    $I10 = self.'from'()
    ne $I10, -1, rxscan341_done
    goto rxscan341_scan
  rxscan341_loop:
    ($P10) = rx338_cur."from"()
    inc $P10
    set rx338_pos, $P10
    ge rx338_pos, rx338_eos, rxscan341_done
  rxscan341_scan:
    set_addr $I10, rxscan341_loop
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  rxscan341_done:
.annotate 'line', 200
  # rx subcapture "sym"
    set_addr $I10, rxcap_342_fail
    rx338_cur."!mark_push"(0, rx338_pos, $I10)
  # rx literal  "for"
    add $I11, rx338_pos, 3
    gt $I11, rx338_eos, rx338_fail
    sub $I11, rx338_pos, rx338_off
    substr $S10, rx338_tgt, $I11, 3
    ne $S10, "for", rx338_fail
    add rx338_pos, 3
    set_addr $I10, rxcap_342_fail
    ($I12, $I11) = rx338_cur."!mark_peek"($I10)
    rx338_cur."!cursor_pos"($I11)
    ($P10) = rx338_cur."!cursor_start"()
    $P10."!cursor_pass"(rx338_pos, "")
    rx338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_342_done
  rxcap_342_fail:
    goto rx338_fail
  rxcap_342_done:
  # rx charclass s
    ge rx338_pos, rx338_eos, rx338_fail
    sub $I10, rx338_pos, rx338_off
    is_cclass $I11, 32, rx338_tgt, $I10
    unless $I11, rx338_fail
    inc rx338_pos
  # rx subrule "ws" subtype=method negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."ws"()
    unless $P10, rx338_fail
    rx338_pos = $P10."pos"()
.annotate 'line', 201
  # rx subrule "xblock" subtype=capture negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."xblock"()
    unless $P10, rx338_fail
    rx338_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx338_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx338_cur."!cursor_pos"(rx338_pos)
    $P10 = rx338_cur."ws"()
    unless $P10, rx338_fail
    rx338_pos = $P10."pos"()
.annotate 'line', 199
  # rx pass
    rx338_cur."!cursor_pass"(rx338_pos, "statement_control:sym<for>")
    if_null rx338_debug, debug_543
    rx338_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx338_pos)
  debug_543:
    .return (rx338_cur)
  rx338_restart:
.annotate 'line', 4
    if_null rx338_debug, debug_544
    rx338_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_544:
  rx338_fail:
    (rx338_rep, rx338_pos, $I10, $P10) = rx338_cur."!mark_fail"(0)
    lt rx338_pos, -1, rx338_done
    eq rx338_pos, -1, rx338_fail
    jump $I10
  rx338_done:
    rx338_cur."!cursor_fail"()
    if_null rx338_debug, debug_545
    rx338_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_545:
    .return (rx338_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("72_1295994649.593") :method
.annotate 'line', 4
    new $P340, "ResizablePMCArray"
    push $P340, "for"
    .return ($P340)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("73_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx346_tgt
    .local int rx346_pos
    .local int rx346_off
    .local int rx346_eos
    .local int rx346_rep
    .local pmc rx346_cur
    .local pmc rx346_debug
    (rx346_cur, rx346_pos, rx346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx346_cur
    .local pmc match
    .lex "$/", match
    length rx346_eos, rx346_tgt
    gt rx346_pos, rx346_eos, rx346_done
    set rx346_off, 0
    lt rx346_pos, 2, rx346_start
    sub rx346_off, rx346_pos, 1
    substr rx346_tgt, rx346_tgt, rx346_off
  rx346_start:
    eq $I10, 1, rx346_restart
    if_null rx346_debug, debug_546
    rx346_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan349_done
    goto rxscan349_scan
  rxscan349_loop:
    ($P10) = rx346_cur."from"()
    inc $P10
    set rx346_pos, $P10
    ge rx346_pos, rx346_eos, rxscan349_done
  rxscan349_scan:
    set_addr $I10, rxscan349_loop
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  rxscan349_done:
.annotate 'line', 205
  # rx subcapture "sym"
    set_addr $I10, rxcap_350_fail
    rx346_cur."!mark_push"(0, rx346_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx346_pos, 5
    gt $I11, rx346_eos, rx346_fail
    sub $I11, rx346_pos, rx346_off
    substr $S10, rx346_tgt, $I11, 5
    ne $S10, "CATCH", rx346_fail
    add rx346_pos, 5
    set_addr $I10, rxcap_350_fail
    ($I12, $I11) = rx346_cur."!mark_peek"($I10)
    rx346_cur."!cursor_pos"($I11)
    ($P10) = rx346_cur."!cursor_start"()
    $P10."!cursor_pass"(rx346_pos, "")
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_350_done
  rxcap_350_fail:
    goto rx346_fail
  rxcap_350_done:
  # rx charclass s
    ge rx346_pos, rx346_eos, rx346_fail
    sub $I10, rx346_pos, rx346_off
    is_cclass $I11, 32, rx346_tgt, $I10
    unless $I11, rx346_fail
    inc rx346_pos
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 206
  # rx subrule "block" subtype=capture negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."block"()
    unless $P10, rx346_fail
    rx346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx346_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx346_cur."!cursor_pos"(rx346_pos)
    $P10 = rx346_cur."ws"()
    unless $P10, rx346_fail
    rx346_pos = $P10."pos"()
.annotate 'line', 204
  # rx pass
    rx346_cur."!cursor_pass"(rx346_pos, "statement_control:sym<CATCH>")
    if_null rx346_debug, debug_547
    rx346_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx346_pos)
  debug_547:
    .return (rx346_cur)
  rx346_restart:
.annotate 'line', 4
    if_null rx346_debug, debug_548
    rx346_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_548:
  rx346_fail:
    (rx346_rep, rx346_pos, $I10, $P10) = rx346_cur."!mark_fail"(0)
    lt rx346_pos, -1, rx346_done
    eq rx346_pos, -1, rx346_fail
    jump $I10
  rx346_done:
    rx346_cur."!cursor_fail"()
    if_null rx346_debug, debug_549
    rx346_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_549:
    .return (rx346_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("74_1295994649.593") :method
.annotate 'line', 4
    new $P348, "ResizablePMCArray"
    push $P348, "CATCH"
    .return ($P348)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("75_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx354_tgt
    .local int rx354_pos
    .local int rx354_off
    .local int rx354_eos
    .local int rx354_rep
    .local pmc rx354_cur
    .local pmc rx354_debug
    (rx354_cur, rx354_pos, rx354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx354_cur
    .local pmc match
    .lex "$/", match
    length rx354_eos, rx354_tgt
    gt rx354_pos, rx354_eos, rx354_done
    set rx354_off, 0
    lt rx354_pos, 2, rx354_start
    sub rx354_off, rx354_pos, 1
    substr rx354_tgt, rx354_tgt, rx354_off
  rx354_start:
    eq $I10, 1, rx354_restart
    if_null rx354_debug, debug_550
    rx354_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_550:
    $I10 = self.'from'()
    ne $I10, -1, rxscan357_done
    goto rxscan357_scan
  rxscan357_loop:
    ($P10) = rx354_cur."from"()
    inc $P10
    set rx354_pos, $P10
    ge rx354_pos, rx354_eos, rxscan357_done
  rxscan357_scan:
    set_addr $I10, rxscan357_loop
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  rxscan357_done:
.annotate 'line', 210
  # rx subcapture "sym"
    set_addr $I10, rxcap_358_fail
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx354_pos, 7
    gt $I11, rx354_eos, rx354_fail
    sub $I11, rx354_pos, rx354_off
    substr $S10, rx354_tgt, $I11, 7
    ne $S10, "CONTROL", rx354_fail
    add rx354_pos, 7
    set_addr $I10, rxcap_358_fail
    ($I12, $I11) = rx354_cur."!mark_peek"($I10)
    rx354_cur."!cursor_pos"($I11)
    ($P10) = rx354_cur."!cursor_start"()
    $P10."!cursor_pass"(rx354_pos, "")
    rx354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_358_done
  rxcap_358_fail:
    goto rx354_fail
  rxcap_358_done:
  # rx charclass s
    ge rx354_pos, rx354_eos, rx354_fail
    sub $I10, rx354_pos, rx354_off
    is_cclass $I11, 32, rx354_tgt, $I10
    unless $I11, rx354_fail
    inc rx354_pos
  # rx subrule "ws" subtype=method negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."ws"()
    unless $P10, rx354_fail
    rx354_pos = $P10."pos"()
.annotate 'line', 211
  # rx subrule "block" subtype=capture negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."block"()
    unless $P10, rx354_fail
    rx354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx354_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."ws"()
    unless $P10, rx354_fail
    rx354_pos = $P10."pos"()
.annotate 'line', 209
  # rx pass
    rx354_cur."!cursor_pass"(rx354_pos, "statement_control:sym<CONTROL>")
    if_null rx354_debug, debug_551
    rx354_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx354_pos)
  debug_551:
    .return (rx354_cur)
  rx354_restart:
.annotate 'line', 4
    if_null rx354_debug, debug_552
    rx354_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_552:
  rx354_fail:
    (rx354_rep, rx354_pos, $I10, $P10) = rx354_cur."!mark_fail"(0)
    lt rx354_pos, -1, rx354_done
    eq rx354_pos, -1, rx354_fail
    jump $I10
  rx354_done:
    rx354_cur."!cursor_fail"()
    if_null rx354_debug, debug_553
    rx354_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_553:
    .return (rx354_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("76_1295994649.593") :method
.annotate 'line', 4
    new $P356, "ResizablePMCArray"
    push $P356, "CONTROL"
    .return ($P356)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("77_1295994649.593")
    .param pmc param_362
.annotate 'line', 214
    .lex "self", param_362
    $P363 = param_362."!protoregex"("statement_prefix")
    .return ($P363)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("78_1295994649.593")
    .param pmc param_365
.annotate 'line', 214
    .lex "self", param_365
    $P366 = param_365."!PREFIX__!protoregex"("statement_prefix")
    .return ($P366)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("79_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx368_tgt
    .local int rx368_pos
    .local int rx368_off
    .local int rx368_eos
    .local int rx368_rep
    .local pmc rx368_cur
    .local pmc rx368_debug
    (rx368_cur, rx368_pos, rx368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx368_cur
    .local pmc match
    .lex "$/", match
    length rx368_eos, rx368_tgt
    gt rx368_pos, rx368_eos, rx368_done
    set rx368_off, 0
    lt rx368_pos, 2, rx368_start
    sub rx368_off, rx368_pos, 1
    substr rx368_tgt, rx368_tgt, rx368_off
  rx368_start:
    eq $I10, 1, rx368_restart
    if_null rx368_debug, debug_554
    rx368_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan372_done
    goto rxscan372_scan
  rxscan372_loop:
    ($P10) = rx368_cur."from"()
    inc $P10
    set rx368_pos, $P10
    ge rx368_pos, rx368_eos, rxscan372_done
  rxscan372_scan:
    set_addr $I10, rxscan372_loop
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
  rxscan372_done:
.annotate 'line', 215
  # rx subcapture "sym"
    set_addr $I10, rxcap_373_fail
    rx368_cur."!mark_push"(0, rx368_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx368_pos, 4
    gt $I11, rx368_eos, rx368_fail
    sub $I11, rx368_pos, rx368_off
    substr $S10, rx368_tgt, $I11, 4
    ne $S10, "INIT", rx368_fail
    add rx368_pos, 4
    set_addr $I10, rxcap_373_fail
    ($I12, $I11) = rx368_cur."!mark_peek"($I10)
    rx368_cur."!cursor_pos"($I11)
    ($P10) = rx368_cur."!cursor_start"()
    $P10."!cursor_pass"(rx368_pos, "")
    rx368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_373_done
  rxcap_373_fail:
    goto rx368_fail
  rxcap_373_done:
  # rx subrule "blorst" subtype=capture negate=
    rx368_cur."!cursor_pos"(rx368_pos)
    $P10 = rx368_cur."blorst"()
    unless $P10, rx368_fail
    rx368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx368_pos = $P10."pos"()
  # rx pass
    rx368_cur."!cursor_pass"(rx368_pos, "statement_prefix:sym<INIT>")
    if_null rx368_debug, debug_555
    rx368_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx368_pos)
  debug_555:
    .return (rx368_cur)
  rx368_restart:
.annotate 'line', 4
    if_null rx368_debug, debug_556
    rx368_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_556:
  rx368_fail:
    (rx368_rep, rx368_pos, $I10, $P10) = rx368_cur."!mark_fail"(0)
    lt rx368_pos, -1, rx368_done
    eq rx368_pos, -1, rx368_fail
    jump $I10
  rx368_done:
    rx368_cur."!cursor_fail"()
    if_null rx368_debug, debug_557
    rx368_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_557:
    .return (rx368_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("80_1295994649.593") :method
.annotate 'line', 4
    $P370 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P371, "ResizablePMCArray"
    push $P371, $P370
    .return ($P371)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("81_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx375_tgt
    .local int rx375_pos
    .local int rx375_off
    .local int rx375_eos
    .local int rx375_rep
    .local pmc rx375_cur
    .local pmc rx375_debug
    (rx375_cur, rx375_pos, rx375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx375_cur
    .local pmc match
    .lex "$/", match
    length rx375_eos, rx375_tgt
    gt rx375_pos, rx375_eos, rx375_done
    set rx375_off, 0
    lt rx375_pos, 2, rx375_start
    sub rx375_off, rx375_pos, 1
    substr rx375_tgt, rx375_tgt, rx375_off
  rx375_start:
    eq $I10, 1, rx375_restart
    if_null rx375_debug, debug_558
    rx375_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan379_done
    goto rxscan379_scan
  rxscan379_loop:
    ($P10) = rx375_cur."from"()
    inc $P10
    set rx375_pos, $P10
    ge rx375_pos, rx375_eos, rxscan379_done
  rxscan379_scan:
    set_addr $I10, rxscan379_loop
    rx375_cur."!mark_push"(0, rx375_pos, $I10)
  rxscan379_done:
.annotate 'line', 218
  # rx subcapture "sym"
    set_addr $I10, rxcap_380_fail
    rx375_cur."!mark_push"(0, rx375_pos, $I10)
  # rx literal  "try"
    add $I11, rx375_pos, 3
    gt $I11, rx375_eos, rx375_fail
    sub $I11, rx375_pos, rx375_off
    substr $S10, rx375_tgt, $I11, 3
    ne $S10, "try", rx375_fail
    add rx375_pos, 3
    set_addr $I10, rxcap_380_fail
    ($I12, $I11) = rx375_cur."!mark_peek"($I10)
    rx375_cur."!cursor_pos"($I11)
    ($P10) = rx375_cur."!cursor_start"()
    $P10."!cursor_pass"(rx375_pos, "")
    rx375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_380_done
  rxcap_380_fail:
    goto rx375_fail
  rxcap_380_done:
.annotate 'line', 219
  # rx subrule "blorst" subtype=capture negate=
    rx375_cur."!cursor_pos"(rx375_pos)
    $P10 = rx375_cur."blorst"()
    unless $P10, rx375_fail
    rx375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx375_pos = $P10."pos"()
.annotate 'line', 217
  # rx pass
    rx375_cur."!cursor_pass"(rx375_pos, "statement_prefix:sym<try>")
    if_null rx375_debug, debug_559
    rx375_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx375_pos)
  debug_559:
    .return (rx375_cur)
  rx375_restart:
.annotate 'line', 4
    if_null rx375_debug, debug_560
    rx375_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_560:
  rx375_fail:
    (rx375_rep, rx375_pos, $I10, $P10) = rx375_cur."!mark_fail"(0)
    lt rx375_pos, -1, rx375_done
    eq rx375_pos, -1, rx375_fail
    jump $I10
  rx375_done:
    rx375_cur."!cursor_fail"()
    if_null rx375_debug, debug_561
    rx375_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_561:
    .return (rx375_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("82_1295994649.593") :method
.annotate 'line', 4
    $P377 = self."!PREFIX__!subrule"("blorst", "try")
    new $P378, "ResizablePMCArray"
    push $P378, $P377
    .return ($P378)
.end


.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("83_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx382_tgt
    .local int rx382_pos
    .local int rx382_off
    .local int rx382_eos
    .local int rx382_rep
    .local pmc rx382_cur
    .local pmc rx382_debug
    (rx382_cur, rx382_pos, rx382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx382_cur
    .local pmc match
    .lex "$/", match
    length rx382_eos, rx382_tgt
    gt rx382_pos, rx382_eos, rx382_done
    set rx382_off, 0
    lt rx382_pos, 2, rx382_start
    sub rx382_off, rx382_pos, 1
    substr rx382_tgt, rx382_tgt, rx382_off
  rx382_start:
    eq $I10, 1, rx382_restart
    if_null rx382_debug, debug_562
    rx382_cur."!cursor_debug"("START", "blorst")
  debug_562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan385_done
    goto rxscan385_scan
  rxscan385_loop:
    ($P10) = rx382_cur."from"()
    inc $P10
    set rx382_pos, $P10
    ge rx382_pos, rx382_eos, rxscan385_done
  rxscan385_scan:
    set_addr $I10, rxscan385_loop
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  rxscan385_done:
.annotate 'line', 223
  # rx charclass s
    ge rx382_pos, rx382_eos, rx382_fail
    sub $I10, rx382_pos, rx382_off
    is_cclass $I11, 32, rx382_tgt, $I10
    unless $I11, rx382_fail
    inc rx382_pos
  # rx subrule "ws" subtype=method negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."ws"()
    unless $P10, rx382_fail
    rx382_pos = $P10."pos"()
  alt386_0:
    set_addr $I10, alt386_1
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx382_pos, rx382_off
    substr $S10, rx382_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx382_fail
  # rx subrule "block" subtype=capture negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."block"()
    unless $P10, rx382_fail
    rx382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx382_pos = $P10."pos"()
    goto alt386_end
  alt386_1:
  # rx subrule "statement" subtype=capture negate=
    rx382_cur."!cursor_pos"(rx382_pos)
    $P10 = rx382_cur."statement"()
    unless $P10, rx382_fail
    rx382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx382_pos = $P10."pos"()
  alt386_end:
.annotate 'line', 222
  # rx pass
    rx382_cur."!cursor_pass"(rx382_pos, "blorst")
    if_null rx382_debug, debug_563
    rx382_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx382_pos)
  debug_563:
    .return (rx382_cur)
  rx382_restart:
.annotate 'line', 4
    if_null rx382_debug, debug_564
    rx382_cur."!cursor_debug"("NEXT", "blorst")
  debug_564:
  rx382_fail:
    (rx382_rep, rx382_pos, $I10, $P10) = rx382_cur."!mark_fail"(0)
    lt rx382_pos, -1, rx382_done
    eq rx382_pos, -1, rx382_fail
    jump $I10
  rx382_done:
    rx382_cur."!cursor_fail"()
    if_null rx382_debug, debug_565
    rx382_cur."!cursor_debug"("FAIL", "blorst")
  debug_565:
    .return (rx382_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("84_1295994649.593") :method
.annotate 'line', 4
    new $P384, "ResizablePMCArray"
    push $P384, ""
    .return ($P384)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("85_1295994649.593")
    .param pmc param_388
.annotate 'line', 228
    .lex "self", param_388
    $P389 = param_388."!protoregex"("statement_mod_cond")
    .return ($P389)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("86_1295994649.593")
    .param pmc param_391
.annotate 'line', 228
    .lex "self", param_391
    $P392 = param_391."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P392)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("87_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx394_tgt
    .local int rx394_pos
    .local int rx394_off
    .local int rx394_eos
    .local int rx394_rep
    .local pmc rx394_cur
    .local pmc rx394_debug
    (rx394_cur, rx394_pos, rx394_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx394_cur
    .local pmc match
    .lex "$/", match
    length rx394_eos, rx394_tgt
    gt rx394_pos, rx394_eos, rx394_done
    set rx394_off, 0
    lt rx394_pos, 2, rx394_start
    sub rx394_off, rx394_pos, 1
    substr rx394_tgt, rx394_tgt, rx394_off
  rx394_start:
    eq $I10, 1, rx394_restart
    if_null rx394_debug, debug_566
    rx394_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan398_done
    goto rxscan398_scan
  rxscan398_loop:
    ($P10) = rx394_cur."from"()
    inc $P10
    set rx394_pos, $P10
    ge rx394_pos, rx394_eos, rxscan398_done
  rxscan398_scan:
    set_addr $I10, rxscan398_loop
    rx394_cur."!mark_push"(0, rx394_pos, $I10)
  rxscan398_done:
.annotate 'line', 230
  # rx subcapture "sym"
    set_addr $I10, rxcap_399_fail
    rx394_cur."!mark_push"(0, rx394_pos, $I10)
  # rx literal  "if"
    add $I11, rx394_pos, 2
    gt $I11, rx394_eos, rx394_fail
    sub $I11, rx394_pos, rx394_off
    substr $S10, rx394_tgt, $I11, 2
    ne $S10, "if", rx394_fail
    add rx394_pos, 2
    set_addr $I10, rxcap_399_fail
    ($I12, $I11) = rx394_cur."!mark_peek"($I10)
    rx394_cur."!cursor_pos"($I11)
    ($P10) = rx394_cur."!cursor_start"()
    $P10."!cursor_pass"(rx394_pos, "")
    rx394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_399_done
  rxcap_399_fail:
    goto rx394_fail
  rxcap_399_done:
  # rx subrule "ws" subtype=method negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."ws"()
    unless $P10, rx394_fail
    rx394_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."EXPR"()
    unless $P10, rx394_fail
    rx394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx394_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."ws"()
    unless $P10, rx394_fail
    rx394_pos = $P10."pos"()
  # rx pass
    rx394_cur."!cursor_pass"(rx394_pos, "statement_mod_cond:sym<if>")
    if_null rx394_debug, debug_567
    rx394_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx394_pos)
  debug_567:
    .return (rx394_cur)
  rx394_restart:
.annotate 'line', 4
    if_null rx394_debug, debug_568
    rx394_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_568:
  rx394_fail:
    (rx394_rep, rx394_pos, $I10, $P10) = rx394_cur."!mark_fail"(0)
    lt rx394_pos, -1, rx394_done
    eq rx394_pos, -1, rx394_fail
    jump $I10
  rx394_done:
    rx394_cur."!cursor_fail"()
    if_null rx394_debug, debug_569
    rx394_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_569:
    .return (rx394_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("88_1295994649.593") :method
.annotate 'line', 4
    $P396 = self."!PREFIX__!subrule"("ws", "if")
    new $P397, "ResizablePMCArray"
    push $P397, $P396
    .return ($P397)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("89_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx403_tgt
    .local int rx403_pos
    .local int rx403_off
    .local int rx403_eos
    .local int rx403_rep
    .local pmc rx403_cur
    .local pmc rx403_debug
    (rx403_cur, rx403_pos, rx403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx403_cur
    .local pmc match
    .lex "$/", match
    length rx403_eos, rx403_tgt
    gt rx403_pos, rx403_eos, rx403_done
    set rx403_off, 0
    lt rx403_pos, 2, rx403_start
    sub rx403_off, rx403_pos, 1
    substr rx403_tgt, rx403_tgt, rx403_off
  rx403_start:
    eq $I10, 1, rx403_restart
    if_null rx403_debug, debug_570
    rx403_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan407_done
    goto rxscan407_scan
  rxscan407_loop:
    ($P10) = rx403_cur."from"()
    inc $P10
    set rx403_pos, $P10
    ge rx403_pos, rx403_eos, rxscan407_done
  rxscan407_scan:
    set_addr $I10, rxscan407_loop
    rx403_cur."!mark_push"(0, rx403_pos, $I10)
  rxscan407_done:
.annotate 'line', 231
  # rx subcapture "sym"
    set_addr $I10, rxcap_408_fail
    rx403_cur."!mark_push"(0, rx403_pos, $I10)
  # rx literal  "unless"
    add $I11, rx403_pos, 6
    gt $I11, rx403_eos, rx403_fail
    sub $I11, rx403_pos, rx403_off
    substr $S10, rx403_tgt, $I11, 6
    ne $S10, "unless", rx403_fail
    add rx403_pos, 6
    set_addr $I10, rxcap_408_fail
    ($I12, $I11) = rx403_cur."!mark_peek"($I10)
    rx403_cur."!cursor_pos"($I11)
    ($P10) = rx403_cur."!cursor_start"()
    $P10."!cursor_pass"(rx403_pos, "")
    rx403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_408_done
  rxcap_408_fail:
    goto rx403_fail
  rxcap_408_done:
  # rx subrule "ws" subtype=method negate=
    rx403_cur."!cursor_pos"(rx403_pos)
    $P10 = rx403_cur."ws"()
    unless $P10, rx403_fail
    rx403_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx403_cur."!cursor_pos"(rx403_pos)
    $P10 = rx403_cur."EXPR"()
    unless $P10, rx403_fail
    rx403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx403_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx403_cur."!cursor_pos"(rx403_pos)
    $P10 = rx403_cur."ws"()
    unless $P10, rx403_fail
    rx403_pos = $P10."pos"()
  # rx pass
    rx403_cur."!cursor_pass"(rx403_pos, "statement_mod_cond:sym<unless>")
    if_null rx403_debug, debug_571
    rx403_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx403_pos)
  debug_571:
    .return (rx403_cur)
  rx403_restart:
.annotate 'line', 4
    if_null rx403_debug, debug_572
    rx403_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_572:
  rx403_fail:
    (rx403_rep, rx403_pos, $I10, $P10) = rx403_cur."!mark_fail"(0)
    lt rx403_pos, -1, rx403_done
    eq rx403_pos, -1, rx403_fail
    jump $I10
  rx403_done:
    rx403_cur."!cursor_fail"()
    if_null rx403_debug, debug_573
    rx403_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_573:
    .return (rx403_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("90_1295994649.593") :method
.annotate 'line', 4
    $P405 = self."!PREFIX__!subrule"("ws", "unless")
    new $P406, "ResizablePMCArray"
    push $P406, $P405
    .return ($P406)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("91_1295994649.593")
    .param pmc param_412
.annotate 'line', 233
    .lex "self", param_412
    $P413 = param_412."!protoregex"("statement_mod_loop")
    .return ($P413)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("92_1295994649.593")
    .param pmc param_415
.annotate 'line', 233
    .lex "self", param_415
    $P416 = param_415."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P416)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("93_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx418_tgt
    .local int rx418_pos
    .local int rx418_off
    .local int rx418_eos
    .local int rx418_rep
    .local pmc rx418_cur
    .local pmc rx418_debug
    (rx418_cur, rx418_pos, rx418_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx418_cur
    .local pmc match
    .lex "$/", match
    length rx418_eos, rx418_tgt
    gt rx418_pos, rx418_eos, rx418_done
    set rx418_off, 0
    lt rx418_pos, 2, rx418_start
    sub rx418_off, rx418_pos, 1
    substr rx418_tgt, rx418_tgt, rx418_off
  rx418_start:
    eq $I10, 1, rx418_restart
    if_null rx418_debug, debug_574
    rx418_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan422_done
    goto rxscan422_scan
  rxscan422_loop:
    ($P10) = rx418_cur."from"()
    inc $P10
    set rx418_pos, $P10
    ge rx418_pos, rx418_eos, rxscan422_done
  rxscan422_scan:
    set_addr $I10, rxscan422_loop
    rx418_cur."!mark_push"(0, rx418_pos, $I10)
  rxscan422_done:
.annotate 'line', 235
  # rx subcapture "sym"
    set_addr $I10, rxcap_423_fail
    rx418_cur."!mark_push"(0, rx418_pos, $I10)
  # rx literal  "while"
    add $I11, rx418_pos, 5
    gt $I11, rx418_eos, rx418_fail
    sub $I11, rx418_pos, rx418_off
    substr $S10, rx418_tgt, $I11, 5
    ne $S10, "while", rx418_fail
    add rx418_pos, 5
    set_addr $I10, rxcap_423_fail
    ($I12, $I11) = rx418_cur."!mark_peek"($I10)
    rx418_cur."!cursor_pos"($I11)
    ($P10) = rx418_cur."!cursor_start"()
    $P10."!cursor_pass"(rx418_pos, "")
    rx418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_423_done
  rxcap_423_fail:
    goto rx418_fail
  rxcap_423_done:
  # rx subrule "ws" subtype=method negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."ws"()
    unless $P10, rx418_fail
    rx418_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."EXPR"()
    unless $P10, rx418_fail
    rx418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx418_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx418_cur."!cursor_pos"(rx418_pos)
    $P10 = rx418_cur."ws"()
    unless $P10, rx418_fail
    rx418_pos = $P10."pos"()
  # rx pass
    rx418_cur."!cursor_pass"(rx418_pos, "statement_mod_loop:sym<while>")
    if_null rx418_debug, debug_575
    rx418_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx418_pos)
  debug_575:
    .return (rx418_cur)
  rx418_restart:
.annotate 'line', 4
    if_null rx418_debug, debug_576
    rx418_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_576:
  rx418_fail:
    (rx418_rep, rx418_pos, $I10, $P10) = rx418_cur."!mark_fail"(0)
    lt rx418_pos, -1, rx418_done
    eq rx418_pos, -1, rx418_fail
    jump $I10
  rx418_done:
    rx418_cur."!cursor_fail"()
    if_null rx418_debug, debug_577
    rx418_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_577:
    .return (rx418_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("94_1295994649.593") :method
.annotate 'line', 4
    $P420 = self."!PREFIX__!subrule"("ws", "while")
    new $P421, "ResizablePMCArray"
    push $P421, $P420
    .return ($P421)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("95_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx427_tgt
    .local int rx427_pos
    .local int rx427_off
    .local int rx427_eos
    .local int rx427_rep
    .local pmc rx427_cur
    .local pmc rx427_debug
    (rx427_cur, rx427_pos, rx427_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx427_cur
    .local pmc match
    .lex "$/", match
    length rx427_eos, rx427_tgt
    gt rx427_pos, rx427_eos, rx427_done
    set rx427_off, 0
    lt rx427_pos, 2, rx427_start
    sub rx427_off, rx427_pos, 1
    substr rx427_tgt, rx427_tgt, rx427_off
  rx427_start:
    eq $I10, 1, rx427_restart
    if_null rx427_debug, debug_578
    rx427_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan431_done
    goto rxscan431_scan
  rxscan431_loop:
    ($P10) = rx427_cur."from"()
    inc $P10
    set rx427_pos, $P10
    ge rx427_pos, rx427_eos, rxscan431_done
  rxscan431_scan:
    set_addr $I10, rxscan431_loop
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxscan431_done:
.annotate 'line', 236
  # rx subcapture "sym"
    set_addr $I10, rxcap_432_fail
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  # rx literal  "until"
    add $I11, rx427_pos, 5
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 5
    ne $S10, "until", rx427_fail
    add rx427_pos, 5
    set_addr $I10, rxcap_432_fail
    ($I12, $I11) = rx427_cur."!mark_peek"($I10)
    rx427_cur."!cursor_pos"($I11)
    ($P10) = rx427_cur."!cursor_start"()
    $P10."!cursor_pass"(rx427_pos, "")
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_432_done
  rxcap_432_fail:
    goto rx427_fail
  rxcap_432_done:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."EXPR"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx pass
    rx427_cur."!cursor_pass"(rx427_pos, "statement_mod_loop:sym<until>")
    if_null rx427_debug, debug_579
    rx427_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx427_pos)
  debug_579:
    .return (rx427_cur)
  rx427_restart:
.annotate 'line', 4
    if_null rx427_debug, debug_580
    rx427_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_580:
  rx427_fail:
    (rx427_rep, rx427_pos, $I10, $P10) = rx427_cur."!mark_fail"(0)
    lt rx427_pos, -1, rx427_done
    eq rx427_pos, -1, rx427_fail
    jump $I10
  rx427_done:
    rx427_cur."!cursor_fail"()
    if_null rx427_debug, debug_581
    rx427_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_581:
    .return (rx427_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("96_1295994649.593") :method
.annotate 'line', 4
    $P429 = self."!PREFIX__!subrule"("ws", "until")
    new $P430, "ResizablePMCArray"
    push $P430, $P429
    .return ($P430)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("97_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx436_tgt
    .local int rx436_pos
    .local int rx436_off
    .local int rx436_eos
    .local int rx436_rep
    .local pmc rx436_cur
    .local pmc rx436_debug
    (rx436_cur, rx436_pos, rx436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx436_cur
    .local pmc match
    .lex "$/", match
    length rx436_eos, rx436_tgt
    gt rx436_pos, rx436_eos, rx436_done
    set rx436_off, 0
    lt rx436_pos, 2, rx436_start
    sub rx436_off, rx436_pos, 1
    substr rx436_tgt, rx436_tgt, rx436_off
  rx436_start:
    eq $I10, 1, rx436_restart
    if_null rx436_debug, debug_582
    rx436_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan440_done
    goto rxscan440_scan
  rxscan440_loop:
    ($P10) = rx436_cur."from"()
    inc $P10
    set rx436_pos, $P10
    ge rx436_pos, rx436_eos, rxscan440_done
  rxscan440_scan:
    set_addr $I10, rxscan440_loop
    rx436_cur."!mark_push"(0, rx436_pos, $I10)
  rxscan440_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_441_fail
    rx436_cur."!mark_push"(0, rx436_pos, $I10)
  # rx literal  "for"
    add $I11, rx436_pos, 3
    gt $I11, rx436_eos, rx436_fail
    sub $I11, rx436_pos, rx436_off
    substr $S10, rx436_tgt, $I11, 3
    ne $S10, "for", rx436_fail
    add rx436_pos, 3
    set_addr $I10, rxcap_441_fail
    ($I12, $I11) = rx436_cur."!mark_peek"($I10)
    rx436_cur."!cursor_pos"($I11)
    ($P10) = rx436_cur."!cursor_start"()
    $P10."!cursor_pass"(rx436_pos, "")
    rx436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_441_done
  rxcap_441_fail:
    goto rx436_fail
  rxcap_441_done:
  # rx subrule "ws" subtype=method negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."ws"()
    unless $P10, rx436_fail
    rx436_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."EXPR"()
    unless $P10, rx436_fail
    rx436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx436_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx436_cur."!cursor_pos"(rx436_pos)
    $P10 = rx436_cur."ws"()
    unless $P10, rx436_fail
    rx436_pos = $P10."pos"()
  # rx pass
    rx436_cur."!cursor_pass"(rx436_pos, "statement_mod_loop:sym<for>")
    if_null rx436_debug, debug_583
    rx436_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx436_pos)
  debug_583:
    .return (rx436_cur)
  rx436_restart:
.annotate 'line', 4
    if_null rx436_debug, debug_584
    rx436_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_584:
  rx436_fail:
    (rx436_rep, rx436_pos, $I10, $P10) = rx436_cur."!mark_fail"(0)
    lt rx436_pos, -1, rx436_done
    eq rx436_pos, -1, rx436_fail
    jump $I10
  rx436_done:
    rx436_cur."!cursor_fail"()
    if_null rx436_debug, debug_585
    rx436_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_585:
    .return (rx436_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("98_1295994649.593") :method
.annotate 'line', 4
    $P438 = self."!PREFIX__!subrule"("ws", "for")
    new $P439, "ResizablePMCArray"
    push $P439, $P438
    .return ($P439)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("99_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx445_tgt
    .local int rx445_pos
    .local int rx445_off
    .local int rx445_eos
    .local int rx445_rep
    .local pmc rx445_cur
    .local pmc rx445_debug
    (rx445_cur, rx445_pos, rx445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx445_cur
    .local pmc match
    .lex "$/", match
    length rx445_eos, rx445_tgt
    gt rx445_pos, rx445_eos, rx445_done
    set rx445_off, 0
    lt rx445_pos, 2, rx445_start
    sub rx445_off, rx445_pos, 1
    substr rx445_tgt, rx445_tgt, rx445_off
  rx445_start:
    eq $I10, 1, rx445_restart
    if_null rx445_debug, debug_586
    rx445_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan449_done
    goto rxscan449_scan
  rxscan449_loop:
    ($P10) = rx445_cur."from"()
    inc $P10
    set rx445_pos, $P10
    ge rx445_pos, rx445_eos, rxscan449_done
  rxscan449_scan:
    set_addr $I10, rxscan449_loop
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  rxscan449_done:
.annotate 'line', 241
  # rx subrule "fatarrow" subtype=capture negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."fatarrow"()
    unless $P10, rx445_fail
    rx445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx445_pos = $P10."pos"()
  # rx pass
    rx445_cur."!cursor_pass"(rx445_pos, "term:sym<fatarrow>")
    if_null rx445_debug, debug_587
    rx445_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx445_pos)
  debug_587:
    .return (rx445_cur)
  rx445_restart:
.annotate 'line', 4
    if_null rx445_debug, debug_588
    rx445_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_588:
  rx445_fail:
    (rx445_rep, rx445_pos, $I10, $P10) = rx445_cur."!mark_fail"(0)
    lt rx445_pos, -1, rx445_done
    eq rx445_pos, -1, rx445_fail
    jump $I10
  rx445_done:
    rx445_cur."!cursor_fail"()
    if_null rx445_debug, debug_589
    rx445_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_589:
    .return (rx445_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("100_1295994649.593") :method
.annotate 'line', 4
    $P447 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P448, "ResizablePMCArray"
    push $P448, $P447
    .return ($P448)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("101_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx451_tgt
    .local int rx451_pos
    .local int rx451_off
    .local int rx451_eos
    .local int rx451_rep
    .local pmc rx451_cur
    .local pmc rx451_debug
    (rx451_cur, rx451_pos, rx451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx451_cur
    .local pmc match
    .lex "$/", match
    length rx451_eos, rx451_tgt
    gt rx451_pos, rx451_eos, rx451_done
    set rx451_off, 0
    lt rx451_pos, 2, rx451_start
    sub rx451_off, rx451_pos, 1
    substr rx451_tgt, rx451_tgt, rx451_off
  rx451_start:
    eq $I10, 1, rx451_restart
    if_null rx451_debug, debug_590
    rx451_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan455_done
    goto rxscan455_scan
  rxscan455_loop:
    ($P10) = rx451_cur."from"()
    inc $P10
    set rx451_pos, $P10
    ge rx451_pos, rx451_eos, rxscan455_done
  rxscan455_scan:
    set_addr $I10, rxscan455_loop
    rx451_cur."!mark_push"(0, rx451_pos, $I10)
  rxscan455_done:
.annotate 'line', 242
  # rx subrule "colonpair" subtype=capture negate=
    rx451_cur."!cursor_pos"(rx451_pos)
    $P10 = rx451_cur."colonpair"()
    unless $P10, rx451_fail
    rx451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx451_pos = $P10."pos"()
  # rx pass
    rx451_cur."!cursor_pass"(rx451_pos, "term:sym<colonpair>")
    if_null rx451_debug, debug_591
    rx451_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx451_pos)
  debug_591:
    .return (rx451_cur)
  rx451_restart:
.annotate 'line', 4
    if_null rx451_debug, debug_592
    rx451_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_592:
  rx451_fail:
    (rx451_rep, rx451_pos, $I10, $P10) = rx451_cur."!mark_fail"(0)
    lt rx451_pos, -1, rx451_done
    eq rx451_pos, -1, rx451_fail
    jump $I10
  rx451_done:
    rx451_cur."!cursor_fail"()
    if_null rx451_debug, debug_593
    rx451_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_593:
    .return (rx451_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("102_1295994649.593") :method
.annotate 'line', 4
    $P453 = self."!PREFIX__!subrule"("colonpair", "")
    new $P454, "ResizablePMCArray"
    push $P454, $P453
    .return ($P454)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("103_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx457_tgt
    .local int rx457_pos
    .local int rx457_off
    .local int rx457_eos
    .local int rx457_rep
    .local pmc rx457_cur
    .local pmc rx457_debug
    (rx457_cur, rx457_pos, rx457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx457_cur
    .local pmc match
    .lex "$/", match
    length rx457_eos, rx457_tgt
    gt rx457_pos, rx457_eos, rx457_done
    set rx457_off, 0
    lt rx457_pos, 2, rx457_start
    sub rx457_off, rx457_pos, 1
    substr rx457_tgt, rx457_tgt, rx457_off
  rx457_start:
    eq $I10, 1, rx457_restart
    if_null rx457_debug, debug_594
    rx457_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan461_done
    goto rxscan461_scan
  rxscan461_loop:
    ($P10) = rx457_cur."from"()
    inc $P10
    set rx457_pos, $P10
    ge rx457_pos, rx457_eos, rxscan461_done
  rxscan461_scan:
    set_addr $I10, rxscan461_loop
    rx457_cur."!mark_push"(0, rx457_pos, $I10)
  rxscan461_done:
.annotate 'line', 243
  # rx subrule "variable" subtype=capture negate=
    rx457_cur."!cursor_pos"(rx457_pos)
    $P10 = rx457_cur."variable"()
    unless $P10, rx457_fail
    rx457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx457_pos = $P10."pos"()
  # rx pass
    rx457_cur."!cursor_pass"(rx457_pos, "term:sym<variable>")
    if_null rx457_debug, debug_595
    rx457_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx457_pos)
  debug_595:
    .return (rx457_cur)
  rx457_restart:
.annotate 'line', 4
    if_null rx457_debug, debug_596
    rx457_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_596:
  rx457_fail:
    (rx457_rep, rx457_pos, $I10, $P10) = rx457_cur."!mark_fail"(0)
    lt rx457_pos, -1, rx457_done
    eq rx457_pos, -1, rx457_fail
    jump $I10
  rx457_done:
    rx457_cur."!cursor_fail"()
    if_null rx457_debug, debug_597
    rx457_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_597:
    .return (rx457_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("104_1295994649.593") :method
.annotate 'line', 4
    $P459 = self."!PREFIX__!subrule"("variable", "")
    new $P460, "ResizablePMCArray"
    push $P460, $P459
    .return ($P460)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("105_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_598
    rx463_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan467_done
    goto rxscan467_scan
  rxscan467_loop:
    ($P10) = rx463_cur."from"()
    inc $P10
    set rx463_pos, $P10
    ge rx463_pos, rx463_eos, rxscan467_done
  rxscan467_scan:
    set_addr $I10, rxscan467_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan467_done:
.annotate 'line', 244
  # rx subrule "package_declarator" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."package_declarator"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx463_pos = $P10."pos"()
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "term:sym<package_declarator>")
    if_null rx463_debug, debug_599
    rx463_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx463_pos)
  debug_599:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 4
    if_null rx463_debug, debug_600
    rx463_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_600:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_601
    rx463_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_601:
    .return (rx463_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("106_1295994649.593") :method
.annotate 'line', 4
    $P465 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P466, "ResizablePMCArray"
    push $P466, $P465
    .return ($P466)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("107_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx469_tgt
    .local int rx469_pos
    .local int rx469_off
    .local int rx469_eos
    .local int rx469_rep
    .local pmc rx469_cur
    .local pmc rx469_debug
    (rx469_cur, rx469_pos, rx469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx469_cur
    .local pmc match
    .lex "$/", match
    length rx469_eos, rx469_tgt
    gt rx469_pos, rx469_eos, rx469_done
    set rx469_off, 0
    lt rx469_pos, 2, rx469_start
    sub rx469_off, rx469_pos, 1
    substr rx469_tgt, rx469_tgt, rx469_off
  rx469_start:
    eq $I10, 1, rx469_restart
    if_null rx469_debug, debug_602
    rx469_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan473_done
    goto rxscan473_scan
  rxscan473_loop:
    ($P10) = rx469_cur."from"()
    inc $P10
    set rx469_pos, $P10
    ge rx469_pos, rx469_eos, rxscan473_done
  rxscan473_scan:
    set_addr $I10, rxscan473_loop
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  rxscan473_done:
.annotate 'line', 245
  # rx subrule "scope_declarator" subtype=capture negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."scope_declarator"()
    unless $P10, rx469_fail
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx469_pos = $P10."pos"()
  # rx pass
    rx469_cur."!cursor_pass"(rx469_pos, "term:sym<scope_declarator>")
    if_null rx469_debug, debug_603
    rx469_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx469_pos)
  debug_603:
    .return (rx469_cur)
  rx469_restart:
.annotate 'line', 4
    if_null rx469_debug, debug_604
    rx469_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_604:
  rx469_fail:
    (rx469_rep, rx469_pos, $I10, $P10) = rx469_cur."!mark_fail"(0)
    lt rx469_pos, -1, rx469_done
    eq rx469_pos, -1, rx469_fail
    jump $I10
  rx469_done:
    rx469_cur."!cursor_fail"()
    if_null rx469_debug, debug_605
    rx469_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_605:
    .return (rx469_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("108_1295994649.593") :method
.annotate 'line', 4
    $P471 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P472, "ResizablePMCArray"
    push $P472, $P471
    .return ($P472)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("109_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx475_tgt
    .local int rx475_pos
    .local int rx475_off
    .local int rx475_eos
    .local int rx475_rep
    .local pmc rx475_cur
    .local pmc rx475_debug
    (rx475_cur, rx475_pos, rx475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx475_cur
    .local pmc match
    .lex "$/", match
    length rx475_eos, rx475_tgt
    gt rx475_pos, rx475_eos, rx475_done
    set rx475_off, 0
    lt rx475_pos, 2, rx475_start
    sub rx475_off, rx475_pos, 1
    substr rx475_tgt, rx475_tgt, rx475_off
  rx475_start:
    eq $I10, 1, rx475_restart
    if_null rx475_debug, debug_606
    rx475_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan479_done
    goto rxscan479_scan
  rxscan479_loop:
    ($P10) = rx475_cur."from"()
    inc $P10
    set rx475_pos, $P10
    ge rx475_pos, rx475_eos, rxscan479_done
  rxscan479_scan:
    set_addr $I10, rxscan479_loop
    rx475_cur."!mark_push"(0, rx475_pos, $I10)
  rxscan479_done:
.annotate 'line', 246
  # rx subrule "routine_declarator" subtype=capture negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."routine_declarator"()
    unless $P10, rx475_fail
    rx475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx475_pos = $P10."pos"()
  # rx pass
    rx475_cur."!cursor_pass"(rx475_pos, "term:sym<routine_declarator>")
    if_null rx475_debug, debug_607
    rx475_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx475_pos)
  debug_607:
    .return (rx475_cur)
  rx475_restart:
.annotate 'line', 4
    if_null rx475_debug, debug_608
    rx475_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_608:
  rx475_fail:
    (rx475_rep, rx475_pos, $I10, $P10) = rx475_cur."!mark_fail"(0)
    lt rx475_pos, -1, rx475_done
    eq rx475_pos, -1, rx475_fail
    jump $I10
  rx475_done:
    rx475_cur."!cursor_fail"()
    if_null rx475_debug, debug_609
    rx475_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_609:
    .return (rx475_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("110_1295994649.593") :method
.annotate 'line', 4
    $P477 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P478, "ResizablePMCArray"
    push $P478, $P477
    .return ($P478)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("111_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P491 = "114_1295994649.593" 
    capture_lex $P491
    .const 'Sub' $P486 = "113_1295994649.593" 
    capture_lex $P486
    .local string rx481_tgt
    .local int rx481_pos
    .local int rx481_off
    .local int rx481_eos
    .local int rx481_rep
    .local pmc rx481_cur
    .local pmc rx481_debug
    (rx481_cur, rx481_pos, rx481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx481_cur
    .local pmc match
    .lex "$/", match
    length rx481_eos, rx481_tgt
    gt rx481_pos, rx481_eos, rx481_done
    set rx481_off, 0
    lt rx481_pos, 2, rx481_start
    sub rx481_off, rx481_pos, 1
    substr rx481_tgt, rx481_tgt, rx481_off
  rx481_start:
    eq $I10, 1, rx481_restart
    if_null rx481_debug, debug_610
    rx481_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan484_done
    goto rxscan484_scan
  rxscan484_loop:
    ($P10) = rx481_cur."from"()
    inc $P10
    set rx481_pos, $P10
    ge rx481_pos, rx481_eos, rxscan484_done
  rxscan484_scan:
    set_addr $I10, rxscan484_loop
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  rxscan484_done:
.annotate 'line', 248
  # rx subrule "before" subtype=zerowidth negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    .const 'Sub' $P486 = "113_1295994649.593" 
    capture_lex $P486
    $P10 = rx481_cur."before"($P486)
    unless $P10, rx481_fail
.annotate 'line', 249
  # rx subrule "before" subtype=zerowidth negate=1
    rx481_cur."!cursor_pos"(rx481_pos)
    .const 'Sub' $P491 = "114_1295994649.593" 
    capture_lex $P491
    $P10 = rx481_cur."before"($P491)
    if $P10, rx481_fail
.annotate 'line', 250
  # rx subrule "multi_declarator" subtype=capture negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."multi_declarator"()
    unless $P10, rx481_fail
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx481_pos = $P10."pos"()
.annotate 'line', 247
  # rx pass
    rx481_cur."!cursor_pass"(rx481_pos, "term:sym<multi_declarator>")
    if_null rx481_debug, debug_619
    rx481_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx481_pos)
  debug_619:
    .return (rx481_cur)
  rx481_restart:
.annotate 'line', 4
    if_null rx481_debug, debug_620
    rx481_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_620:
  rx481_fail:
    (rx481_rep, rx481_pos, $I10, $P10) = rx481_cur."!mark_fail"(0)
    lt rx481_pos, -1, rx481_done
    eq rx481_pos, -1, rx481_fail
    jump $I10
  rx481_done:
    rx481_cur."!cursor_fail"()
    if_null rx481_debug, debug_621
    rx481_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_621:
    .return (rx481_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("112_1295994649.593") :method
.annotate 'line', 4
    new $P483, "ResizablePMCArray"
    push $P483, ""
    .return ($P483)
.end


.namespace ["NQP";"Grammar"]
.sub "_block485"  :anon :subid("113_1295994649.593") :method :outer("111_1295994649.593")
.annotate 'line', 248
    .local string rx487_tgt
    .local int rx487_pos
    .local int rx487_off
    .local int rx487_eos
    .local int rx487_rep
    .local pmc rx487_cur
    .local pmc rx487_debug
    (rx487_cur, rx487_pos, rx487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx487_cur
    .local pmc match
    .lex "$/", match
    length rx487_eos, rx487_tgt
    gt rx487_pos, rx487_eos, rx487_done
    set rx487_off, 0
    lt rx487_pos, 2, rx487_start
    sub rx487_off, rx487_pos, 1
    substr rx487_tgt, rx487_tgt, rx487_off
  rx487_start:
    eq $I10, 1, rx487_restart
    if_null rx487_debug, debug_611
    rx487_cur."!cursor_debug"("START", "")
  debug_611:
    $I10 = self.'from'()
    ne $I10, -1, rxscan488_done
    goto rxscan488_scan
  rxscan488_loop:
    ($P10) = rx487_cur."from"()
    inc $P10
    set rx487_pos, $P10
    ge rx487_pos, rx487_eos, rxscan488_done
  rxscan488_scan:
    set_addr $I10, rxscan488_loop
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  rxscan488_done:
  alt489_0:
    set_addr $I10, alt489_1
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  # rx literal  "multi"
    add $I11, rx487_pos, 5
    gt $I11, rx487_eos, rx487_fail
    sub $I11, rx487_pos, rx487_off
    substr $S10, rx487_tgt, $I11, 5
    ne $S10, "multi", rx487_fail
    add rx487_pos, 5
    goto alt489_end
  alt489_1:
    set_addr $I10, alt489_2
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  # rx literal  "proto"
    add $I11, rx487_pos, 5
    gt $I11, rx487_eos, rx487_fail
    sub $I11, rx487_pos, rx487_off
    substr $S10, rx487_tgt, $I11, 5
    ne $S10, "proto", rx487_fail
    add rx487_pos, 5
    goto alt489_end
  alt489_2:
  # rx literal  "only"
    add $I11, rx487_pos, 4
    gt $I11, rx487_eos, rx487_fail
    sub $I11, rx487_pos, rx487_off
    substr $S10, rx487_tgt, $I11, 4
    ne $S10, "only", rx487_fail
    add rx487_pos, 4
  alt489_end:
  # rx pass
    rx487_cur."!cursor_pass"(rx487_pos, "")
    if_null rx487_debug, debug_612
    rx487_cur."!cursor_debug"("PASS", "", " at pos=", rx487_pos)
  debug_612:
    .return (rx487_cur)
  rx487_restart:
    if_null rx487_debug, debug_613
    rx487_cur."!cursor_debug"("NEXT", "")
  debug_613:
  rx487_fail:
    (rx487_rep, rx487_pos, $I10, $P10) = rx487_cur."!mark_fail"(0)
    lt rx487_pos, -1, rx487_done
    eq rx487_pos, -1, rx487_fail
    jump $I10
  rx487_done:
    rx487_cur."!cursor_fail"()
    if_null rx487_debug, debug_614
    rx487_cur."!cursor_debug"("FAIL", "")
  debug_614:
    .return (rx487_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "_block490"  :anon :subid("114_1295994649.593") :method :outer("111_1295994649.593")
.annotate 'line', 249
    .local string rx492_tgt
    .local int rx492_pos
    .local int rx492_off
    .local int rx492_eos
    .local int rx492_rep
    .local pmc rx492_cur
    .local pmc rx492_debug
    (rx492_cur, rx492_pos, rx492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx492_cur
    .local pmc match
    .lex "$/", match
    length rx492_eos, rx492_tgt
    gt rx492_pos, rx492_eos, rx492_done
    set rx492_off, 0
    lt rx492_pos, 2, rx492_start
    sub rx492_off, rx492_pos, 1
    substr rx492_tgt, rx492_tgt, rx492_off
  rx492_start:
    eq $I10, 1, rx492_restart
    if_null rx492_debug, debug_615
    rx492_cur."!cursor_debug"("START", "")
  debug_615:
    $I10 = self.'from'()
    ne $I10, -1, rxscan493_done
    goto rxscan493_scan
  rxscan493_loop:
    ($P10) = rx492_cur."from"()
    inc $P10
    set rx492_pos, $P10
    ge rx492_pos, rx492_eos, rxscan493_done
  rxscan493_scan:
    set_addr $I10, rxscan493_loop
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  rxscan493_done:
  # rx literal  "proto"
    add $I11, rx492_pos, 5
    gt $I11, rx492_eos, rx492_fail
    sub $I11, rx492_pos, rx492_off
    substr $S10, rx492_tgt, $I11, 5
    ne $S10, "proto", rx492_fail
    add rx492_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."ws"()
    unless $P10, rx492_fail
    rx492_pos = $P10."pos"()
  alt494_0:
    set_addr $I10, alt494_1
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  # rx literal  "regex"
    add $I11, rx492_pos, 5
    gt $I11, rx492_eos, rx492_fail
    sub $I11, rx492_pos, rx492_off
    substr $S10, rx492_tgt, $I11, 5
    ne $S10, "regex", rx492_fail
    add rx492_pos, 5
    goto alt494_end
  alt494_1:
    set_addr $I10, alt494_2
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  # rx literal  "token"
    add $I11, rx492_pos, 5
    gt $I11, rx492_eos, rx492_fail
    sub $I11, rx492_pos, rx492_off
    substr $S10, rx492_tgt, $I11, 5
    ne $S10, "token", rx492_fail
    add rx492_pos, 5
    goto alt494_end
  alt494_2:
  # rx literal  "rule"
    add $I11, rx492_pos, 4
    gt $I11, rx492_eos, rx492_fail
    sub $I11, rx492_pos, rx492_off
    substr $S10, rx492_tgt, $I11, 4
    ne $S10, "rule", rx492_fail
    add rx492_pos, 4
  alt494_end:
  # rx pass
    rx492_cur."!cursor_pass"(rx492_pos, "")
    if_null rx492_debug, debug_616
    rx492_cur."!cursor_debug"("PASS", "", " at pos=", rx492_pos)
  debug_616:
    .return (rx492_cur)
  rx492_restart:
    if_null rx492_debug, debug_617
    rx492_cur."!cursor_debug"("NEXT", "")
  debug_617:
  rx492_fail:
    (rx492_rep, rx492_pos, $I10, $P10) = rx492_cur."!mark_fail"(0)
    lt rx492_pos, -1, rx492_done
    eq rx492_pos, -1, rx492_fail
    jump $I10
  rx492_done:
    rx492_cur."!cursor_fail"()
    if_null rx492_debug, debug_618
    rx492_cur."!cursor_debug"("FAIL", "")
  debug_618:
    .return (rx492_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("115_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx496_tgt
    .local int rx496_pos
    .local int rx496_off
    .local int rx496_eos
    .local int rx496_rep
    .local pmc rx496_cur
    .local pmc rx496_debug
    (rx496_cur, rx496_pos, rx496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx496_cur
    .local pmc match
    .lex "$/", match
    length rx496_eos, rx496_tgt
    gt rx496_pos, rx496_eos, rx496_done
    set rx496_off, 0
    lt rx496_pos, 2, rx496_start
    sub rx496_off, rx496_pos, 1
    substr rx496_tgt, rx496_tgt, rx496_off
  rx496_start:
    eq $I10, 1, rx496_restart
    if_null rx496_debug, debug_622
    rx496_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan500_done
    goto rxscan500_scan
  rxscan500_loop:
    ($P10) = rx496_cur."from"()
    inc $P10
    set rx496_pos, $P10
    ge rx496_pos, rx496_eos, rxscan500_done
  rxscan500_scan:
    set_addr $I10, rxscan500_loop
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  rxscan500_done:
.annotate 'line', 252
  # rx subrule "regex_declarator" subtype=capture negate=
    rx496_cur."!cursor_pos"(rx496_pos)
    $P10 = rx496_cur."regex_declarator"()
    unless $P10, rx496_fail
    rx496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx496_pos = $P10."pos"()
  # rx pass
    rx496_cur."!cursor_pass"(rx496_pos, "term:sym<regex_declarator>")
    if_null rx496_debug, debug_623
    rx496_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx496_pos)
  debug_623:
    .return (rx496_cur)
  rx496_restart:
.annotate 'line', 4
    if_null rx496_debug, debug_624
    rx496_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_624:
  rx496_fail:
    (rx496_rep, rx496_pos, $I10, $P10) = rx496_cur."!mark_fail"(0)
    lt rx496_pos, -1, rx496_done
    eq rx496_pos, -1, rx496_fail
    jump $I10
  rx496_done:
    rx496_cur."!cursor_fail"()
    if_null rx496_debug, debug_625
    rx496_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_625:
    .return (rx496_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("116_1295994649.593") :method
.annotate 'line', 4
    $P498 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P499, "ResizablePMCArray"
    push $P499, $P498
    .return ($P499)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("117_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx502_tgt
    .local int rx502_pos
    .local int rx502_off
    .local int rx502_eos
    .local int rx502_rep
    .local pmc rx502_cur
    .local pmc rx502_debug
    (rx502_cur, rx502_pos, rx502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx502_cur
    .local pmc match
    .lex "$/", match
    length rx502_eos, rx502_tgt
    gt rx502_pos, rx502_eos, rx502_done
    set rx502_off, 0
    lt rx502_pos, 2, rx502_start
    sub rx502_off, rx502_pos, 1
    substr rx502_tgt, rx502_tgt, rx502_off
  rx502_start:
    eq $I10, 1, rx502_restart
    if_null rx502_debug, debug_626
    rx502_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan506_done
    goto rxscan506_scan
  rxscan506_loop:
    ($P10) = rx502_cur."from"()
    inc $P10
    set rx502_pos, $P10
    ge rx502_pos, rx502_eos, rxscan506_done
  rxscan506_scan:
    set_addr $I10, rxscan506_loop
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  rxscan506_done:
.annotate 'line', 253
  # rx subrule "statement_prefix" subtype=capture negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."statement_prefix"()
    unless $P10, rx502_fail
    rx502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx502_pos = $P10."pos"()
  # rx pass
    rx502_cur."!cursor_pass"(rx502_pos, "term:sym<statement_prefix>")
    if_null rx502_debug, debug_627
    rx502_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx502_pos)
  debug_627:
    .return (rx502_cur)
  rx502_restart:
.annotate 'line', 4
    if_null rx502_debug, debug_628
    rx502_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_628:
  rx502_fail:
    (rx502_rep, rx502_pos, $I10, $P10) = rx502_cur."!mark_fail"(0)
    lt rx502_pos, -1, rx502_done
    eq rx502_pos, -1, rx502_fail
    jump $I10
  rx502_done:
    rx502_cur."!cursor_fail"()
    if_null rx502_debug, debug_629
    rx502_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_629:
    .return (rx502_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("118_1295994649.593") :method
.annotate 'line', 4
    $P504 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P505, "ResizablePMCArray"
    push $P505, $P504
    .return ($P505)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("119_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_630
    rx508_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan511_done
    goto rxscan511_scan
  rxscan511_loop:
    ($P10) = rx508_cur."from"()
    inc $P10
    set rx508_pos, $P10
    ge rx508_pos, rx508_eos, rxscan511_done
  rxscan511_scan:
    set_addr $I10, rxscan511_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan511_done:
.annotate 'line', 254
  # rx subrule "lambda" subtype=zerowidth negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."lambda"()
    unless $P10, rx508_fail
  # rx subrule "pblock" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."pblock"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx508_pos = $P10."pos"()
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "term:sym<lambda>")
    if_null rx508_debug, debug_631
    rx508_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx508_pos)
  debug_631:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 4
    if_null rx508_debug, debug_632
    rx508_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_632:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_633
    rx508_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_633:
    .return (rx508_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("120_1295994649.593") :method
.annotate 'line', 4
    new $P510, "ResizablePMCArray"
    push $P510, ""
    .return ($P510)
.end


.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("121_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx513_tgt
    .local int rx513_pos
    .local int rx513_off
    .local int rx513_eos
    .local int rx513_rep
    .local pmc rx513_cur
    .local pmc rx513_debug
    (rx513_cur, rx513_pos, rx513_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx513_cur
    .local pmc match
    .lex "$/", match
    length rx513_eos, rx513_tgt
    gt rx513_pos, rx513_eos, rx513_done
    set rx513_off, 0
    lt rx513_pos, 2, rx513_start
    sub rx513_off, rx513_pos, 1
    substr rx513_tgt, rx513_tgt, rx513_off
  rx513_start:
    eq $I10, 1, rx513_restart
    if_null rx513_debug, debug_634
    rx513_cur."!cursor_debug"("START", "fatarrow")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan517_done
    goto rxscan517_scan
  rxscan517_loop:
    ($P10) = rx513_cur."from"()
    inc $P10
    set rx513_pos, $P10
    ge rx513_pos, rx513_eos, rxscan517_done
  rxscan517_scan:
    set_addr $I10, rxscan517_loop
    rx513_cur."!mark_push"(0, rx513_pos, $I10)
  rxscan517_done:
.annotate 'line', 257
  # rx subrule "identifier" subtype=capture negate=
    rx513_cur."!cursor_pos"(rx513_pos)
    $P10 = rx513_cur."identifier"()
    unless $P10, rx513_fail
    rx513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx513_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx513_pos, rx513_off
    set rx513_rep, 0
    sub $I12, rx513_eos, rx513_pos
  rxenumcharlistq518_loop:
    le $I12, 0, rxenumcharlistq518_done
    substr $S10, rx513_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq518_done
    inc rx513_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq518_loop
  rxenumcharlistq518_done:
    add rx513_pos, rx513_pos, rx513_rep
  # rx literal  "=>"
    add $I11, rx513_pos, 2
    gt $I11, rx513_eos, rx513_fail
    sub $I11, rx513_pos, rx513_off
    substr $S10, rx513_tgt, $I11, 2
    ne $S10, "=>", rx513_fail
    add rx513_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx513_cur."!cursor_pos"(rx513_pos)
    $P10 = rx513_cur."ws"()
    unless $P10, rx513_fail
    rx513_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx513_cur."!cursor_pos"(rx513_pos)
    $P10 = rx513_cur."EXPR"("i=")
    unless $P10, rx513_fail
    rx513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx513_pos = $P10."pos"()
.annotate 'line', 256
  # rx pass
    rx513_cur."!cursor_pass"(rx513_pos, "fatarrow")
    if_null rx513_debug, debug_635
    rx513_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx513_pos)
  debug_635:
    .return (rx513_cur)
  rx513_restart:
.annotate 'line', 4
    if_null rx513_debug, debug_636
    rx513_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_636:
  rx513_fail:
    (rx513_rep, rx513_pos, $I10, $P10) = rx513_cur."!mark_fail"(0)
    lt rx513_pos, -1, rx513_done
    eq rx513_pos, -1, rx513_fail
    jump $I10
  rx513_done:
    rx513_cur."!cursor_fail"()
    if_null rx513_debug, debug_637
    rx513_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_637:
    .return (rx513_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("122_1295994649.593") :method
.annotate 'line', 4
    $P515 = self."!PREFIX__!subrule"("identifier", "")
    new $P516, "ResizablePMCArray"
    push $P516, $P515
    .return ($P516)
.end


.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("123_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx520_tgt
    .local int rx520_pos
    .local int rx520_off
    .local int rx520_eos
    .local int rx520_rep
    .local pmc rx520_cur
    .local pmc rx520_debug
    (rx520_cur, rx520_pos, rx520_tgt, $I10) = self."!cursor_start"()
    rx520_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx520_cur
    .local pmc match
    .lex "$/", match
    length rx520_eos, rx520_tgt
    gt rx520_pos, rx520_eos, rx520_done
    set rx520_off, 0
    lt rx520_pos, 2, rx520_start
    sub rx520_off, rx520_pos, 1
    substr rx520_tgt, rx520_tgt, rx520_off
  rx520_start:
    eq $I10, 1, rx520_restart
    if_null rx520_debug, debug_638
    rx520_cur."!cursor_debug"("START", "colonpair")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan526_done
    goto rxscan526_scan
  rxscan526_loop:
    ($P10) = rx520_cur."from"()
    inc $P10
    set rx520_pos, $P10
    ge rx520_pos, rx520_eos, rxscan526_done
  rxscan526_scan:
    set_addr $I10, rxscan526_loop
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  rxscan526_done:
.annotate 'line', 261
  # rx literal  ":"
    add $I11, rx520_pos, 1
    gt $I11, rx520_eos, rx520_fail
    sub $I11, rx520_pos, rx520_off
    ord $I11, rx520_tgt, $I11
    ne $I11, 58, rx520_fail
    add rx520_pos, 1
  alt527_0:
.annotate 'line', 262
    set_addr $I10, alt527_1
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
.annotate 'line', 263
  # rx subcapture "not"
    set_addr $I10, rxcap_528_fail
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  # rx literal  "!"
    add $I11, rx520_pos, 1
    gt $I11, rx520_eos, rx520_fail
    sub $I11, rx520_pos, rx520_off
    ord $I11, rx520_tgt, $I11
    ne $I11, 33, rx520_fail
    add rx520_pos, 1
    set_addr $I10, rxcap_528_fail
    ($I12, $I11) = rx520_cur."!mark_peek"($I10)
    rx520_cur."!cursor_pos"($I11)
    ($P10) = rx520_cur."!cursor_start"()
    $P10."!cursor_pass"(rx520_pos, "")
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_528_done
  rxcap_528_fail:
    goto rx520_fail
  rxcap_528_done:
  # rx subrule "identifier" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."identifier"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx520_pos = $P10."pos"()
    goto alt527_end
  alt527_1:
    set_addr $I10, alt527_2
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
.annotate 'line', 264
  # rx subrule "identifier" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."identifier"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx520_pos = $P10."pos"()
  # rx rxquantr529 ** 0..1
    set_addr $I10, rxquantr529_done
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  rxquantr529_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."circumfix"()
    unless $P10, rx520_fail
    goto rxsubrule530_pass
  rxsubrule530_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx520_fail
  rxsubrule530_pass:
    set_addr $I10, rxsubrule530_back
    rx520_cur."!mark_push"(0, rx520_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx520_pos = $P10."pos"()
    set_addr $I10, rxquantr529_done
    (rx520_rep) = rx520_cur."!mark_commit"($I10)
  rxquantr529_done:
    goto alt527_end
  alt527_2:
.annotate 'line', 265
  # rx subrule "circumfix" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."circumfix"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx520_pos = $P10."pos"()
  alt527_end:
.annotate 'line', 260
  # rx pass
    rx520_cur."!cursor_pass"(rx520_pos, "colonpair")
    if_null rx520_debug, debug_639
    rx520_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx520_pos)
  debug_639:
    .return (rx520_cur)
  rx520_restart:
.annotate 'line', 4
    if_null rx520_debug, debug_640
    rx520_cur."!cursor_debug"("NEXT", "colonpair")
  debug_640:
  rx520_fail:
    (rx520_rep, rx520_pos, $I10, $P10) = rx520_cur."!mark_fail"(0)
    lt rx520_pos, -1, rx520_done
    eq rx520_pos, -1, rx520_fail
    jump $I10
  rx520_done:
    rx520_cur."!cursor_fail"()
    if_null rx520_debug, debug_641
    rx520_cur."!cursor_debug"("FAIL", "colonpair")
  debug_641:
    .return (rx520_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("124_1295994649.593") :method
.annotate 'line', 4
    $P522 = self."!PREFIX__!subrule"("circumfix", ":")
    $P523 = self."!PREFIX__!subrule"("identifier", ":")
    $P524 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P525, "ResizablePMCArray"
    push $P525, $P522
    push $P525, $P523
    push $P525, $P524
    .return ($P525)
.end


.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("125_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx532_tgt
    .local int rx532_pos
    .local int rx532_off
    .local int rx532_eos
    .local int rx532_rep
    .local pmc rx532_cur
    .local pmc rx532_debug
    (rx532_cur, rx532_pos, rx532_tgt, $I10) = self."!cursor_start"()
    rx532_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx532_cur
    .local pmc match
    .lex "$/", match
    length rx532_eos, rx532_tgt
    gt rx532_pos, rx532_eos, rx532_done
    set rx532_off, 0
    lt rx532_pos, 2, rx532_start
    sub rx532_off, rx532_pos, 1
    substr rx532_tgt, rx532_tgt, rx532_off
  rx532_start:
    eq $I10, 1, rx532_restart
    if_null rx532_debug, debug_642
    rx532_cur."!cursor_debug"("START", "variable")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan537_done
    goto rxscan537_scan
  rxscan537_loop:
    ($P10) = rx532_cur."from"()
    inc $P10
    set rx532_pos, $P10
    ge rx532_pos, rx532_eos, rxscan537_done
  rxscan537_scan:
    set_addr $I10, rxscan537_loop
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxscan537_done:
  alt538_0:
.annotate 'line', 269
    set_addr $I10, alt538_1
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
.annotate 'line', 270
  # rx subrule "sigil" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."sigil"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx532_pos = $P10."pos"()
  # rx rxquantr539 ** 0..1
    set_addr $I10, rxquantr539_done
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxquantr539_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."twigil"()
    unless $P10, rx532_fail
    goto rxsubrule540_pass
  rxsubrule540_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx532_fail
  rxsubrule540_pass:
    set_addr $I10, rxsubrule540_back
    rx532_cur."!mark_push"(0, rx532_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx532_pos = $P10."pos"()
    set_addr $I10, rxquantr539_done
    (rx532_rep) = rx532_cur."!mark_commit"($I10)
  rxquantr539_done:
  # rx subrule "name" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."name"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx532_pos = $P10."pos"()
    goto alt538_end
  alt538_1:
    set_addr $I10, alt538_2
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
.annotate 'line', 271
  # rx subrule "sigil" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."sigil"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx532_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx532_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."postcircumfix"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx532_pos = $P10."pos"()
    goto alt538_end
  alt538_2:
.annotate 'line', 272
  # rx subcapture "sigil"
    set_addr $I10, rxcap_541_fail
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "$"
    add $I11, rx532_pos, 1
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    ord $I11, rx532_tgt, $I11
    ne $I11, 36, rx532_fail
    add rx532_pos, 1
    set_addr $I10, rxcap_541_fail
    ($I12, $I11) = rx532_cur."!mark_peek"($I10)
    rx532_cur."!cursor_pos"($I11)
    ($P10) = rx532_cur."!cursor_start"()
    $P10."!cursor_pass"(rx532_pos, "")
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_541_done
  rxcap_541_fail:
    goto rx532_fail
  rxcap_541_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_542_fail
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx532_pos, rx532_eos, rx532_fail
    sub $I10, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx532_fail
    inc rx532_pos
    set_addr $I10, rxcap_542_fail
    ($I12, $I11) = rx532_cur."!mark_peek"($I10)
    rx532_cur."!cursor_pos"($I11)
    ($P10) = rx532_cur."!cursor_start"()
    $P10."!cursor_pass"(rx532_pos, "")
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_542_done
  rxcap_542_fail:
    goto rx532_fail
  rxcap_542_done:
  alt538_end:
.annotate 'line', 269
  # rx pass
    rx532_cur."!cursor_pass"(rx532_pos, "variable")
    if_null rx532_debug, debug_643
    rx532_cur."!cursor_debug"("PASS", "variable", " at pos=", rx532_pos)
  debug_643:
    .return (rx532_cur)
  rx532_restart:
.annotate 'line', 4
    if_null rx532_debug, debug_644
    rx532_cur."!cursor_debug"("NEXT", "variable")
  debug_644:
  rx532_fail:
    (rx532_rep, rx532_pos, $I10, $P10) = rx532_cur."!mark_fail"(0)
    lt rx532_pos, -1, rx532_done
    eq rx532_pos, -1, rx532_fail
    jump $I10
  rx532_done:
    rx532_cur."!cursor_fail"()
    if_null rx532_debug, debug_645
    rx532_cur."!cursor_debug"("FAIL", "variable")
  debug_645:
    .return (rx532_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("126_1295994649.593") :method
.annotate 'line', 4
    $P534 = self."!PREFIX__!subrule"("sigil", "")
    $P535 = self."!PREFIX__!subrule"("sigil", "")
    new $P536, "ResizablePMCArray"
    push $P536, "$!"
    push $P536, "$_"
    push $P536, "$/"
    push $P536, $P534
    push $P536, $P535
    .return ($P536)
.end


.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("127_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx544_tgt
    .local int rx544_pos
    .local int rx544_off
    .local int rx544_eos
    .local int rx544_rep
    .local pmc rx544_cur
    .local pmc rx544_debug
    (rx544_cur, rx544_pos, rx544_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx544_cur
    .local pmc match
    .lex "$/", match
    length rx544_eos, rx544_tgt
    gt rx544_pos, rx544_eos, rx544_done
    set rx544_off, 0
    lt rx544_pos, 2, rx544_start
    sub rx544_off, rx544_pos, 1
    substr rx544_tgt, rx544_tgt, rx544_off
  rx544_start:
    eq $I10, 1, rx544_restart
    if_null rx544_debug, debug_646
    rx544_cur."!cursor_debug"("START", "sigil")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan547_done
    goto rxscan547_scan
  rxscan547_loop:
    ($P10) = rx544_cur."from"()
    inc $P10
    set rx544_pos, $P10
    ge rx544_pos, rx544_eos, rxscan547_done
  rxscan547_scan:
    set_addr $I10, rxscan547_loop
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  rxscan547_done:
.annotate 'line', 275
  # rx enumcharlist negate=0 
    ge rx544_pos, rx544_eos, rx544_fail
    sub $I10, rx544_pos, rx544_off
    substr $S10, rx544_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx544_fail
    inc rx544_pos
  # rx pass
    rx544_cur."!cursor_pass"(rx544_pos, "sigil")
    if_null rx544_debug, debug_647
    rx544_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx544_pos)
  debug_647:
    .return (rx544_cur)
  rx544_restart:
.annotate 'line', 4
    if_null rx544_debug, debug_648
    rx544_cur."!cursor_debug"("NEXT", "sigil")
  debug_648:
  rx544_fail:
    (rx544_rep, rx544_pos, $I10, $P10) = rx544_cur."!mark_fail"(0)
    lt rx544_pos, -1, rx544_done
    eq rx544_pos, -1, rx544_fail
    jump $I10
  rx544_done:
    rx544_cur."!cursor_fail"()
    if_null rx544_debug, debug_649
    rx544_cur."!cursor_debug"("FAIL", "sigil")
  debug_649:
    .return (rx544_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("128_1295994649.593") :method
.annotate 'line', 4
    new $P546, "ResizablePMCArray"
    push $P546, "&"
    push $P546, "%"
    push $P546, "@"
    push $P546, "$"
    .return ($P546)
.end


.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("129_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx549_tgt
    .local int rx549_pos
    .local int rx549_off
    .local int rx549_eos
    .local int rx549_rep
    .local pmc rx549_cur
    .local pmc rx549_debug
    (rx549_cur, rx549_pos, rx549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx549_cur
    .local pmc match
    .lex "$/", match
    length rx549_eos, rx549_tgt
    gt rx549_pos, rx549_eos, rx549_done
    set rx549_off, 0
    lt rx549_pos, 2, rx549_start
    sub rx549_off, rx549_pos, 1
    substr rx549_tgt, rx549_tgt, rx549_off
  rx549_start:
    eq $I10, 1, rx549_restart
    if_null rx549_debug, debug_650
    rx549_cur."!cursor_debug"("START", "twigil")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan552_done
    goto rxscan552_scan
  rxscan552_loop:
    ($P10) = rx549_cur."from"()
    inc $P10
    set rx549_pos, $P10
    ge rx549_pos, rx549_eos, rxscan552_done
  rxscan552_scan:
    set_addr $I10, rxscan552_loop
    rx549_cur."!mark_push"(0, rx549_pos, $I10)
  rxscan552_done:
.annotate 'line', 277
  # rx enumcharlist negate=0 
    ge rx549_pos, rx549_eos, rx549_fail
    sub $I10, rx549_pos, rx549_off
    substr $S10, rx549_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx549_fail
    inc rx549_pos
  # rx pass
    rx549_cur."!cursor_pass"(rx549_pos, "twigil")
    if_null rx549_debug, debug_651
    rx549_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx549_pos)
  debug_651:
    .return (rx549_cur)
  rx549_restart:
.annotate 'line', 4
    if_null rx549_debug, debug_652
    rx549_cur."!cursor_debug"("NEXT", "twigil")
  debug_652:
  rx549_fail:
    (rx549_rep, rx549_pos, $I10, $P10) = rx549_cur."!mark_fail"(0)
    lt rx549_pos, -1, rx549_done
    eq rx549_pos, -1, rx549_fail
    jump $I10
  rx549_done:
    rx549_cur."!cursor_fail"()
    if_null rx549_debug, debug_653
    rx549_cur."!cursor_debug"("FAIL", "twigil")
  debug_653:
    .return (rx549_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("130_1295994649.593") :method
.annotate 'line', 4
    new $P551, "ResizablePMCArray"
    push $P551, "?"
    push $P551, "!"
    push $P551, "*"
    .return ($P551)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("131_1295994649.593")
    .param pmc param_554
.annotate 'line', 279
    .lex "self", param_554
    $P555 = param_554."!protoregex"("package_declarator")
    .return ($P555)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("132_1295994649.593")
    .param pmc param_557
.annotate 'line', 279
    .lex "self", param_557
    $P558 = param_557."!PREFIX__!protoregex"("package_declarator")
    .return ($P558)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("133_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx560_tgt
    .local int rx560_pos
    .local int rx560_off
    .local int rx560_eos
    .local int rx560_rep
    .local pmc rx560_cur
    .local pmc rx560_debug
    (rx560_cur, rx560_pos, rx560_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx560_cur
    .local pmc match
    .lex "$/", match
    length rx560_eos, rx560_tgt
    gt rx560_pos, rx560_eos, rx560_done
    set rx560_off, 0
    lt rx560_pos, 2, rx560_start
    sub rx560_off, rx560_pos, 1
    substr rx560_tgt, rx560_tgt, rx560_off
  rx560_start:
    eq $I10, 1, rx560_restart
    if_null rx560_debug, debug_654
    rx560_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan564_done
    goto rxscan564_scan
  rxscan564_loop:
    ($P10) = rx560_cur."from"()
    inc $P10
    set rx560_pos, $P10
    ge rx560_pos, rx560_eos, rxscan564_done
  rxscan564_scan:
    set_addr $I10, rxscan564_loop
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  rxscan564_done:
.annotate 'line', 280
  # rx subcapture "sym"
    set_addr $I10, rxcap_565_fail
    rx560_cur."!mark_push"(0, rx560_pos, $I10)
  # rx literal  "module"
    add $I11, rx560_pos, 6
    gt $I11, rx560_eos, rx560_fail
    sub $I11, rx560_pos, rx560_off
    substr $S10, rx560_tgt, $I11, 6
    ne $S10, "module", rx560_fail
    add rx560_pos, 6
    set_addr $I10, rxcap_565_fail
    ($I12, $I11) = rx560_cur."!mark_peek"($I10)
    rx560_cur."!cursor_pos"($I11)
    ($P10) = rx560_cur."!cursor_start"()
    $P10."!cursor_pass"(rx560_pos, "")
    rx560_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_565_done
  rxcap_565_fail:
    goto rx560_fail
  rxcap_565_done:
  # rx subrule "package_def" subtype=capture negate=
    rx560_cur."!cursor_pos"(rx560_pos)
    $P10 = rx560_cur."package_def"()
    unless $P10, rx560_fail
    rx560_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx560_pos = $P10."pos"()
  # rx pass
    rx560_cur."!cursor_pass"(rx560_pos, "package_declarator:sym<module>")
    if_null rx560_debug, debug_655
    rx560_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx560_pos)
  debug_655:
    .return (rx560_cur)
  rx560_restart:
.annotate 'line', 4
    if_null rx560_debug, debug_656
    rx560_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_656:
  rx560_fail:
    (rx560_rep, rx560_pos, $I10, $P10) = rx560_cur."!mark_fail"(0)
    lt rx560_pos, -1, rx560_done
    eq rx560_pos, -1, rx560_fail
    jump $I10
  rx560_done:
    rx560_cur."!cursor_fail"()
    if_null rx560_debug, debug_657
    rx560_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_657:
    .return (rx560_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("134_1295994649.593") :method
.annotate 'line', 4
    $P562 = self."!PREFIX__!subrule"("package_def", "module")
    new $P563, "ResizablePMCArray"
    push $P563, $P562
    .return ($P563)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("135_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 282
    new $P567, "Undef"
    .lex "$*PACKAGE-SETUP", $P567
.annotate 'line', 283
    new $P568, "Undef"
    .lex "$*PKGDECL", $P568
.annotate 'line', 4
    .local string rx569_tgt
    .local int rx569_pos
    .local int rx569_off
    .local int rx569_eos
    .local int rx569_rep
    .local pmc rx569_cur
    .local pmc rx569_debug
    (rx569_cur, rx569_pos, rx569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx569_cur
    .local pmc match
    .lex "$/", match
    length rx569_eos, rx569_tgt
    gt rx569_pos, rx569_eos, rx569_done
    set rx569_off, 0
    lt rx569_pos, 2, rx569_start
    sub rx569_off, rx569_pos, 1
    substr rx569_tgt, rx569_tgt, rx569_off
  rx569_start:
    eq $I10, 1, rx569_restart
    if_null rx569_debug, debug_658
    rx569_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan573_done
    goto rxscan573_scan
  rxscan573_loop:
    ($P10) = rx569_cur."from"()
    inc $P10
    set rx569_pos, $P10
    ge rx569_pos, rx569_eos, rxscan573_done
  rxscan573_scan:
    set_addr $I10, rxscan573_loop
    rx569_cur."!mark_push"(0, rx569_pos, $I10)
  rxscan573_done:
.annotate 'line', 282
    rx569_cur."!cursor_pos"(rx569_pos)
    get_hll_global $P574, ["PAST"], "Stmts"
    $P575 = $P574."new"()
    store_lex "$*PACKAGE-SETUP", $P575
.annotate 'line', 283
    rx569_cur."!cursor_pos"(rx569_pos)
    new $P576, "String"
    assign $P576, "knowhow"
    store_lex "$*PKGDECL", $P576
.annotate 'line', 284
  # rx subcapture "sym"
    set_addr $I10, rxcap_577_fail
    rx569_cur."!mark_push"(0, rx569_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx569_pos, 7
    gt $I11, rx569_eos, rx569_fail
    sub $I11, rx569_pos, rx569_off
    substr $S10, rx569_tgt, $I11, 7
    ne $S10, "knowhow", rx569_fail
    add rx569_pos, 7
    set_addr $I10, rxcap_577_fail
    ($I12, $I11) = rx569_cur."!mark_peek"($I10)
    rx569_cur."!cursor_pos"($I11)
    ($P10) = rx569_cur."!cursor_start"()
    $P10."!cursor_pass"(rx569_pos, "")
    rx569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_577_done
  rxcap_577_fail:
    goto rx569_fail
  rxcap_577_done:
  # rx subrule "package_def" subtype=capture negate=
    rx569_cur."!cursor_pos"(rx569_pos)
    $P10 = rx569_cur."package_def"()
    unless $P10, rx569_fail
    rx569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx569_pos = $P10."pos"()
.annotate 'line', 281
  # rx pass
    rx569_cur."!cursor_pass"(rx569_pos, "package_declarator:sym<knowhow>")
    if_null rx569_debug, debug_659
    rx569_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx569_pos)
  debug_659:
    .return (rx569_cur)
  rx569_restart:
.annotate 'line', 4
    if_null rx569_debug, debug_660
    rx569_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_660:
  rx569_fail:
    (rx569_rep, rx569_pos, $I10, $P10) = rx569_cur."!mark_fail"(0)
    lt rx569_pos, -1, rx569_done
    eq rx569_pos, -1, rx569_fail
    jump $I10
  rx569_done:
    rx569_cur."!cursor_fail"()
    if_null rx569_debug, debug_661
    rx569_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_661:
    .return (rx569_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("136_1295994649.593") :method
.annotate 'line', 4
    $P571 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P572, "ResizablePMCArray"
    push $P572, $P571
    .return ($P572)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("137_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 287
    new $P579, "Undef"
    .lex "$*PACKAGE-SETUP", $P579
.annotate 'line', 288
    new $P580, "Undef"
    .lex "$*PKGDECL", $P580
.annotate 'line', 4
    .local string rx581_tgt
    .local int rx581_pos
    .local int rx581_off
    .local int rx581_eos
    .local int rx581_rep
    .local pmc rx581_cur
    .local pmc rx581_debug
    (rx581_cur, rx581_pos, rx581_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx581_cur
    .local pmc match
    .lex "$/", match
    length rx581_eos, rx581_tgt
    gt rx581_pos, rx581_eos, rx581_done
    set rx581_off, 0
    lt rx581_pos, 2, rx581_start
    sub rx581_off, rx581_pos, 1
    substr rx581_tgt, rx581_tgt, rx581_off
  rx581_start:
    eq $I10, 1, rx581_restart
    if_null rx581_debug, debug_662
    rx581_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan585_done
    goto rxscan585_scan
  rxscan585_loop:
    ($P10) = rx581_cur."from"()
    inc $P10
    set rx581_pos, $P10
    ge rx581_pos, rx581_eos, rxscan585_done
  rxscan585_scan:
    set_addr $I10, rxscan585_loop
    rx581_cur."!mark_push"(0, rx581_pos, $I10)
  rxscan585_done:
.annotate 'line', 287
    rx581_cur."!cursor_pos"(rx581_pos)
    get_hll_global $P586, ["PAST"], "Stmts"
    $P587 = $P586."new"()
    store_lex "$*PACKAGE-SETUP", $P587
.annotate 'line', 288
    rx581_cur."!cursor_pos"(rx581_pos)
    new $P588, "String"
    assign $P588, "class"
    store_lex "$*PKGDECL", $P588
.annotate 'line', 289
  # rx subcapture "sym"
    set_addr $I10, rxcap_589_fail
    rx581_cur."!mark_push"(0, rx581_pos, $I10)
  # rx literal  "class"
    add $I11, rx581_pos, 5
    gt $I11, rx581_eos, rx581_fail
    sub $I11, rx581_pos, rx581_off
    substr $S10, rx581_tgt, $I11, 5
    ne $S10, "class", rx581_fail
    add rx581_pos, 5
    set_addr $I10, rxcap_589_fail
    ($I12, $I11) = rx581_cur."!mark_peek"($I10)
    rx581_cur."!cursor_pos"($I11)
    ($P10) = rx581_cur."!cursor_start"()
    $P10."!cursor_pass"(rx581_pos, "")
    rx581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_589_done
  rxcap_589_fail:
    goto rx581_fail
  rxcap_589_done:
  # rx subrule "package_def" subtype=capture negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."package_def"()
    unless $P10, rx581_fail
    rx581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx581_pos = $P10."pos"()
.annotate 'line', 286
  # rx pass
    rx581_cur."!cursor_pass"(rx581_pos, "package_declarator:sym<class>")
    if_null rx581_debug, debug_663
    rx581_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx581_pos)
  debug_663:
    .return (rx581_cur)
  rx581_restart:
.annotate 'line', 4
    if_null rx581_debug, debug_664
    rx581_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_664:
  rx581_fail:
    (rx581_rep, rx581_pos, $I10, $P10) = rx581_cur."!mark_fail"(0)
    lt rx581_pos, -1, rx581_done
    eq rx581_pos, -1, rx581_fail
    jump $I10
  rx581_done:
    rx581_cur."!cursor_fail"()
    if_null rx581_debug, debug_665
    rx581_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_665:
    .return (rx581_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("138_1295994649.593") :method
.annotate 'line', 4
    $P583 = self."!PREFIX__!subrule"("package_def", "class")
    new $P584, "ResizablePMCArray"
    push $P584, $P583
    .return ($P584)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("139_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 292
    new $P591, "Undef"
    .lex "$*PACKAGE-SETUP", $P591
.annotate 'line', 293
    new $P592, "Undef"
    .lex "$*PKGDECL", $P592
.annotate 'line', 4
    .local string rx593_tgt
    .local int rx593_pos
    .local int rx593_off
    .local int rx593_eos
    .local int rx593_rep
    .local pmc rx593_cur
    .local pmc rx593_debug
    (rx593_cur, rx593_pos, rx593_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx593_cur
    .local pmc match
    .lex "$/", match
    length rx593_eos, rx593_tgt
    gt rx593_pos, rx593_eos, rx593_done
    set rx593_off, 0
    lt rx593_pos, 2, rx593_start
    sub rx593_off, rx593_pos, 1
    substr rx593_tgt, rx593_tgt, rx593_off
  rx593_start:
    eq $I10, 1, rx593_restart
    if_null rx593_debug, debug_666
    rx593_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan597_done
    goto rxscan597_scan
  rxscan597_loop:
    ($P10) = rx593_cur."from"()
    inc $P10
    set rx593_pos, $P10
    ge rx593_pos, rx593_eos, rxscan597_done
  rxscan597_scan:
    set_addr $I10, rxscan597_loop
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
  rxscan597_done:
.annotate 'line', 292
    rx593_cur."!cursor_pos"(rx593_pos)
    get_hll_global $P598, ["PAST"], "Stmts"
    $P599 = $P598."new"()
    store_lex "$*PACKAGE-SETUP", $P599
.annotate 'line', 293
    rx593_cur."!cursor_pos"(rx593_pos)
    new $P600, "String"
    assign $P600, "grammar"
    store_lex "$*PKGDECL", $P600
.annotate 'line', 294
  # rx subcapture "sym"
    set_addr $I10, rxcap_601_fail
    rx593_cur."!mark_push"(0, rx593_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx593_pos, 7
    gt $I11, rx593_eos, rx593_fail
    sub $I11, rx593_pos, rx593_off
    substr $S10, rx593_tgt, $I11, 7
    ne $S10, "grammar", rx593_fail
    add rx593_pos, 7
    set_addr $I10, rxcap_601_fail
    ($I12, $I11) = rx593_cur."!mark_peek"($I10)
    rx593_cur."!cursor_pos"($I11)
    ($P10) = rx593_cur."!cursor_start"()
    $P10."!cursor_pass"(rx593_pos, "")
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_601_done
  rxcap_601_fail:
    goto rx593_fail
  rxcap_601_done:
  # rx subrule "package_def" subtype=capture negate=
    rx593_cur."!cursor_pos"(rx593_pos)
    $P10 = rx593_cur."package_def"()
    unless $P10, rx593_fail
    rx593_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx593_pos = $P10."pos"()
.annotate 'line', 291
  # rx pass
    rx593_cur."!cursor_pass"(rx593_pos, "package_declarator:sym<grammar>")
    if_null rx593_debug, debug_667
    rx593_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx593_pos)
  debug_667:
    .return (rx593_cur)
  rx593_restart:
.annotate 'line', 4
    if_null rx593_debug, debug_668
    rx593_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_668:
  rx593_fail:
    (rx593_rep, rx593_pos, $I10, $P10) = rx593_cur."!mark_fail"(0)
    lt rx593_pos, -1, rx593_done
    eq rx593_pos, -1, rx593_fail
    jump $I10
  rx593_done:
    rx593_cur."!cursor_fail"()
    if_null rx593_debug, debug_669
    rx593_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_669:
    .return (rx593_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("140_1295994649.593") :method
.annotate 'line', 4
    $P595 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P596, "ResizablePMCArray"
    push $P596, $P595
    .return ($P596)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("141_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 297
    new $P603, "Undef"
    .lex "$*PACKAGE-SETUP", $P603
.annotate 'line', 298
    new $P604, "Undef"
    .lex "$*PKGDECL", $P604
.annotate 'line', 4
    .local string rx605_tgt
    .local int rx605_pos
    .local int rx605_off
    .local int rx605_eos
    .local int rx605_rep
    .local pmc rx605_cur
    .local pmc rx605_debug
    (rx605_cur, rx605_pos, rx605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx605_cur
    .local pmc match
    .lex "$/", match
    length rx605_eos, rx605_tgt
    gt rx605_pos, rx605_eos, rx605_done
    set rx605_off, 0
    lt rx605_pos, 2, rx605_start
    sub rx605_off, rx605_pos, 1
    substr rx605_tgt, rx605_tgt, rx605_off
  rx605_start:
    eq $I10, 1, rx605_restart
    if_null rx605_debug, debug_670
    rx605_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan609_done
    goto rxscan609_scan
  rxscan609_loop:
    ($P10) = rx605_cur."from"()
    inc $P10
    set rx605_pos, $P10
    ge rx605_pos, rx605_eos, rxscan609_done
  rxscan609_scan:
    set_addr $I10, rxscan609_loop
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxscan609_done:
.annotate 'line', 297
    rx605_cur."!cursor_pos"(rx605_pos)
    get_hll_global $P610, ["PAST"], "Stmts"
    $P611 = $P610."new"()
    store_lex "$*PACKAGE-SETUP", $P611
.annotate 'line', 298
    rx605_cur."!cursor_pos"(rx605_pos)
    new $P612, "String"
    assign $P612, "role"
    store_lex "$*PKGDECL", $P612
.annotate 'line', 299
  # rx subcapture "sym"
    set_addr $I10, rxcap_613_fail
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  # rx literal  "role"
    add $I11, rx605_pos, 4
    gt $I11, rx605_eos, rx605_fail
    sub $I11, rx605_pos, rx605_off
    substr $S10, rx605_tgt, $I11, 4
    ne $S10, "role", rx605_fail
    add rx605_pos, 4
    set_addr $I10, rxcap_613_fail
    ($I12, $I11) = rx605_cur."!mark_peek"($I10)
    rx605_cur."!cursor_pos"($I11)
    ($P10) = rx605_cur."!cursor_start"()
    $P10."!cursor_pass"(rx605_pos, "")
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_613_done
  rxcap_613_fail:
    goto rx605_fail
  rxcap_613_done:
  # rx subrule "package_def" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."package_def"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx605_pos = $P10."pos"()
.annotate 'line', 296
  # rx pass
    rx605_cur."!cursor_pass"(rx605_pos, "package_declarator:sym<role>")
    if_null rx605_debug, debug_671
    rx605_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx605_pos)
  debug_671:
    .return (rx605_cur)
  rx605_restart:
.annotate 'line', 4
    if_null rx605_debug, debug_672
    rx605_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_672:
  rx605_fail:
    (rx605_rep, rx605_pos, $I10, $P10) = rx605_cur."!mark_fail"(0)
    lt rx605_pos, -1, rx605_done
    eq rx605_pos, -1, rx605_fail
    jump $I10
  rx605_done:
    rx605_cur."!cursor_fail"()
    if_null rx605_debug, debug_673
    rx605_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_673:
    .return (rx605_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("142_1295994649.593") :method
.annotate 'line', 4
    $P607 = self."!PREFIX__!subrule"("package_def", "role")
    new $P608, "ResizablePMCArray"
    push $P608, $P607
    .return ($P608)
.end


.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("143_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx615_tgt
    .local int rx615_pos
    .local int rx615_off
    .local int rx615_eos
    .local int rx615_rep
    .local pmc rx615_cur
    .local pmc rx615_debug
    (rx615_cur, rx615_pos, rx615_tgt, $I10) = self."!cursor_start"()
    rx615_cur."!cursor_caparray"("repr", "parent")
    .lex unicode:"$\x{a2}", rx615_cur
    .local pmc match
    .lex "$/", match
    length rx615_eos, rx615_tgt
    gt rx615_pos, rx615_eos, rx615_done
    set rx615_off, 0
    lt rx615_pos, 2, rx615_start
    sub rx615_off, rx615_pos, 1
    substr rx615_tgt, rx615_tgt, rx615_off
  rx615_start:
    eq $I10, 1, rx615_restart
    if_null rx615_debug, debug_674
    rx615_cur."!cursor_debug"("START", "package_def")
  debug_674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan619_done
    goto rxscan619_scan
  rxscan619_loop:
    ($P10) = rx615_cur."from"()
    inc $P10
    set rx615_pos, $P10
    ge rx615_pos, rx615_eos, rxscan619_done
  rxscan619_scan:
    set_addr $I10, rxscan619_loop
    rx615_cur."!mark_push"(0, rx615_pos, $I10)
  rxscan619_done:
.annotate 'line', 302
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
.annotate 'line', 303
  # rx subrule "name" subtype=capture negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."name"()
    unless $P10, rx615_fail
    rx615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx615_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
.annotate 'line', 304
  # rx rxquantr622 ** 0..1
    set_addr $I10, rxquantr622_done
    rx615_cur."!mark_push"(0, rx615_pos, $I10)
  rxquantr622_loop:
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx615_pos, 2
    gt $I11, rx615_eos, rx615_fail
    sub $I11, rx615_pos, rx615_off
    substr $S10, rx615_tgt, $I11, 2
    ne $S10, "is", rx615_fail
    add rx615_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx615_pos, 5
    gt $I11, rx615_eos, rx615_fail
    sub $I11, rx615_pos, rx615_off
    substr $S10, rx615_tgt, $I11, 5
    ne $S10, "repr(", rx615_fail
    add rx615_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."quote_EXPR"()
    unless $P10, rx615_fail
    rx615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx615_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx615_pos, 1
    gt $I11, rx615_eos, rx615_fail
    sub $I11, rx615_pos, rx615_off
    ord $I11, rx615_tgt, $I11
    ne $I11, 41, rx615_fail
    add rx615_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
    set_addr $I10, rxquantr622_done
    (rx615_rep) = rx615_cur."!mark_commit"($I10)
  rxquantr622_done:
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
.annotate 'line', 305
  # rx rxquantr629 ** 0..1
    set_addr $I10, rxquantr629_done
    rx615_cur."!mark_push"(0, rx615_pos, $I10)
  rxquantr629_loop:
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx615_pos, 2
    gt $I11, rx615_eos, rx615_fail
    sub $I11, rx615_pos, rx615_off
    substr $S10, rx615_tgt, $I11, 2
    ne $S10, "is", rx615_fail
    add rx615_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."name"()
    unless $P10, rx615_fail
    rx615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx615_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
    set_addr $I10, rxquantr629_done
    (rx615_rep) = rx615_cur."!mark_commit"($I10)
  rxquantr629_done:
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  alt634_0:
.annotate 'line', 306
    set_addr $I10, alt634_1
    rx615_cur."!mark_push"(0, rx615_pos, $I10)
.annotate 'line', 307
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx615_pos, 1
    gt $I11, rx615_eos, rx615_fail
    sub $I11, rx615_pos, rx615_off
    ord $I11, rx615_tgt, $I11
    ne $I11, 59, rx615_fail
    add rx615_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."comp_unit"()
    unless $P10, rx615_fail
    rx615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx615_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
    goto alt634_end
  alt634_1:
    set_addr $I10, alt634_2
    rx615_cur."!mark_push"(0, rx615_pos, $I10)
.annotate 'line', 308
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx615_pos, rx615_off
    substr $S10, rx615_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx615_fail
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."block"()
    unless $P10, rx615_fail
    rx615_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx615_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
    goto alt634_end
  alt634_2:
.annotate 'line', 309
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."panic"("Malformed package declaration")
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
  alt634_end:
.annotate 'line', 310
  # rx subrule "ws" subtype=method negate=
    rx615_cur."!cursor_pos"(rx615_pos)
    $P10 = rx615_cur."ws"()
    unless $P10, rx615_fail
    rx615_pos = $P10."pos"()
.annotate 'line', 302
  # rx pass
    rx615_cur."!cursor_pass"(rx615_pos, "package_def")
    if_null rx615_debug, debug_675
    rx615_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx615_pos)
  debug_675:
    .return (rx615_cur)
  rx615_restart:
.annotate 'line', 4
    if_null rx615_debug, debug_676
    rx615_cur."!cursor_debug"("NEXT", "package_def")
  debug_676:
  rx615_fail:
    (rx615_rep, rx615_pos, $I10, $P10) = rx615_cur."!mark_fail"(0)
    lt rx615_pos, -1, rx615_done
    eq rx615_pos, -1, rx615_fail
    jump $I10
  rx615_done:
    rx615_cur."!cursor_fail"()
    if_null rx615_debug, debug_677
    rx615_cur."!cursor_debug"("FAIL", "package_def")
  debug_677:
    .return (rx615_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("144_1295994649.593") :method
.annotate 'line', 4
    $P617 = self."!PREFIX__!subrule"("ws", "")
    new $P618, "ResizablePMCArray"
    push $P618, $P617
    .return ($P618)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("145_1295994649.593")
    .param pmc param_645
.annotate 'line', 313
    .lex "self", param_645
    $P646 = param_645."!protoregex"("scope_declarator")
    .return ($P646)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("146_1295994649.593")
    .param pmc param_648
.annotate 'line', 313
    .lex "self", param_648
    $P649 = param_648."!PREFIX__!protoregex"("scope_declarator")
    .return ($P649)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("147_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx651_tgt
    .local int rx651_pos
    .local int rx651_off
    .local int rx651_eos
    .local int rx651_rep
    .local pmc rx651_cur
    .local pmc rx651_debug
    (rx651_cur, rx651_pos, rx651_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx651_cur
    .local pmc match
    .lex "$/", match
    length rx651_eos, rx651_tgt
    gt rx651_pos, rx651_eos, rx651_done
    set rx651_off, 0
    lt rx651_pos, 2, rx651_start
    sub rx651_off, rx651_pos, 1
    substr rx651_tgt, rx651_tgt, rx651_off
  rx651_start:
    eq $I10, 1, rx651_restart
    if_null rx651_debug, debug_678
    rx651_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan655_done
    goto rxscan655_scan
  rxscan655_loop:
    ($P10) = rx651_cur."from"()
    inc $P10
    set rx651_pos, $P10
    ge rx651_pos, rx651_eos, rxscan655_done
  rxscan655_scan:
    set_addr $I10, rxscan655_loop
    rx651_cur."!mark_push"(0, rx651_pos, $I10)
  rxscan655_done:
.annotate 'line', 314
  # rx subcapture "sym"
    set_addr $I10, rxcap_656_fail
    rx651_cur."!mark_push"(0, rx651_pos, $I10)
  # rx literal  "my"
    add $I11, rx651_pos, 2
    gt $I11, rx651_eos, rx651_fail
    sub $I11, rx651_pos, rx651_off
    substr $S10, rx651_tgt, $I11, 2
    ne $S10, "my", rx651_fail
    add rx651_pos, 2
    set_addr $I10, rxcap_656_fail
    ($I12, $I11) = rx651_cur."!mark_peek"($I10)
    rx651_cur."!cursor_pos"($I11)
    ($P10) = rx651_cur."!cursor_start"()
    $P10."!cursor_pass"(rx651_pos, "")
    rx651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_656_done
  rxcap_656_fail:
    goto rx651_fail
  rxcap_656_done:
  # rx subrule "scoped" subtype=capture negate=
    rx651_cur."!cursor_pos"(rx651_pos)
    $P10 = rx651_cur."scoped"("my")
    unless $P10, rx651_fail
    rx651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx651_pos = $P10."pos"()
  # rx pass
    rx651_cur."!cursor_pass"(rx651_pos, "scope_declarator:sym<my>")
    if_null rx651_debug, debug_679
    rx651_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx651_pos)
  debug_679:
    .return (rx651_cur)
  rx651_restart:
.annotate 'line', 4
    if_null rx651_debug, debug_680
    rx651_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_680:
  rx651_fail:
    (rx651_rep, rx651_pos, $I10, $P10) = rx651_cur."!mark_fail"(0)
    lt rx651_pos, -1, rx651_done
    eq rx651_pos, -1, rx651_fail
    jump $I10
  rx651_done:
    rx651_cur."!cursor_fail"()
    if_null rx651_debug, debug_681
    rx651_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_681:
    .return (rx651_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("148_1295994649.593") :method
.annotate 'line', 4
    $P653 = self."!PREFIX__!subrule"("scoped", "my")
    new $P654, "ResizablePMCArray"
    push $P654, $P653
    .return ($P654)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("149_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx658_tgt
    .local int rx658_pos
    .local int rx658_off
    .local int rx658_eos
    .local int rx658_rep
    .local pmc rx658_cur
    .local pmc rx658_debug
    (rx658_cur, rx658_pos, rx658_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx658_cur
    .local pmc match
    .lex "$/", match
    length rx658_eos, rx658_tgt
    gt rx658_pos, rx658_eos, rx658_done
    set rx658_off, 0
    lt rx658_pos, 2, rx658_start
    sub rx658_off, rx658_pos, 1
    substr rx658_tgt, rx658_tgt, rx658_off
  rx658_start:
    eq $I10, 1, rx658_restart
    if_null rx658_debug, debug_682
    rx658_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan662_done
    goto rxscan662_scan
  rxscan662_loop:
    ($P10) = rx658_cur."from"()
    inc $P10
    set rx658_pos, $P10
    ge rx658_pos, rx658_eos, rxscan662_done
  rxscan662_scan:
    set_addr $I10, rxscan662_loop
    rx658_cur."!mark_push"(0, rx658_pos, $I10)
  rxscan662_done:
.annotate 'line', 315
  # rx subcapture "sym"
    set_addr $I10, rxcap_663_fail
    rx658_cur."!mark_push"(0, rx658_pos, $I10)
  # rx literal  "our"
    add $I11, rx658_pos, 3
    gt $I11, rx658_eos, rx658_fail
    sub $I11, rx658_pos, rx658_off
    substr $S10, rx658_tgt, $I11, 3
    ne $S10, "our", rx658_fail
    add rx658_pos, 3
    set_addr $I10, rxcap_663_fail
    ($I12, $I11) = rx658_cur."!mark_peek"($I10)
    rx658_cur."!cursor_pos"($I11)
    ($P10) = rx658_cur."!cursor_start"()
    $P10."!cursor_pass"(rx658_pos, "")
    rx658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_663_done
  rxcap_663_fail:
    goto rx658_fail
  rxcap_663_done:
  # rx subrule "scoped" subtype=capture negate=
    rx658_cur."!cursor_pos"(rx658_pos)
    $P10 = rx658_cur."scoped"("our")
    unless $P10, rx658_fail
    rx658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx658_pos = $P10."pos"()
  # rx pass
    rx658_cur."!cursor_pass"(rx658_pos, "scope_declarator:sym<our>")
    if_null rx658_debug, debug_683
    rx658_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx658_pos)
  debug_683:
    .return (rx658_cur)
  rx658_restart:
.annotate 'line', 4
    if_null rx658_debug, debug_684
    rx658_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_684:
  rx658_fail:
    (rx658_rep, rx658_pos, $I10, $P10) = rx658_cur."!mark_fail"(0)
    lt rx658_pos, -1, rx658_done
    eq rx658_pos, -1, rx658_fail
    jump $I10
  rx658_done:
    rx658_cur."!cursor_fail"()
    if_null rx658_debug, debug_685
    rx658_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_685:
    .return (rx658_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("150_1295994649.593") :method
.annotate 'line', 4
    $P660 = self."!PREFIX__!subrule"("scoped", "our")
    new $P661, "ResizablePMCArray"
    push $P661, $P660
    .return ($P661)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("151_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx665_tgt
    .local int rx665_pos
    .local int rx665_off
    .local int rx665_eos
    .local int rx665_rep
    .local pmc rx665_cur
    .local pmc rx665_debug
    (rx665_cur, rx665_pos, rx665_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx665_cur
    .local pmc match
    .lex "$/", match
    length rx665_eos, rx665_tgt
    gt rx665_pos, rx665_eos, rx665_done
    set rx665_off, 0
    lt rx665_pos, 2, rx665_start
    sub rx665_off, rx665_pos, 1
    substr rx665_tgt, rx665_tgt, rx665_off
  rx665_start:
    eq $I10, 1, rx665_restart
    if_null rx665_debug, debug_686
    rx665_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan669_done
    goto rxscan669_scan
  rxscan669_loop:
    ($P10) = rx665_cur."from"()
    inc $P10
    set rx665_pos, $P10
    ge rx665_pos, rx665_eos, rxscan669_done
  rxscan669_scan:
    set_addr $I10, rxscan669_loop
    rx665_cur."!mark_push"(0, rx665_pos, $I10)
  rxscan669_done:
.annotate 'line', 316
  # rx subcapture "sym"
    set_addr $I10, rxcap_670_fail
    rx665_cur."!mark_push"(0, rx665_pos, $I10)
  # rx literal  "has"
    add $I11, rx665_pos, 3
    gt $I11, rx665_eos, rx665_fail
    sub $I11, rx665_pos, rx665_off
    substr $S10, rx665_tgt, $I11, 3
    ne $S10, "has", rx665_fail
    add rx665_pos, 3
    set_addr $I10, rxcap_670_fail
    ($I12, $I11) = rx665_cur."!mark_peek"($I10)
    rx665_cur."!cursor_pos"($I11)
    ($P10) = rx665_cur."!cursor_start"()
    $P10."!cursor_pass"(rx665_pos, "")
    rx665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_670_done
  rxcap_670_fail:
    goto rx665_fail
  rxcap_670_done:
  # rx subrule "scoped" subtype=capture negate=
    rx665_cur."!cursor_pos"(rx665_pos)
    $P10 = rx665_cur."scoped"("has")
    unless $P10, rx665_fail
    rx665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx665_pos = $P10."pos"()
  # rx pass
    rx665_cur."!cursor_pass"(rx665_pos, "scope_declarator:sym<has>")
    if_null rx665_debug, debug_687
    rx665_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx665_pos)
  debug_687:
    .return (rx665_cur)
  rx665_restart:
.annotate 'line', 4
    if_null rx665_debug, debug_688
    rx665_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_688:
  rx665_fail:
    (rx665_rep, rx665_pos, $I10, $P10) = rx665_cur."!mark_fail"(0)
    lt rx665_pos, -1, rx665_done
    eq rx665_pos, -1, rx665_fail
    jump $I10
  rx665_done:
    rx665_cur."!cursor_fail"()
    if_null rx665_debug, debug_689
    rx665_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_689:
    .return (rx665_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("152_1295994649.593") :method
.annotate 'line', 4
    $P667 = self."!PREFIX__!subrule"("scoped", "has")
    new $P668, "ResizablePMCArray"
    push $P668, $P667
    .return ($P668)
.end


.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("153_1295994649.593") :method :outer("11_1295994649.593")
    .param pmc param_672
.annotate 'line', 318
    .lex "$*SCOPE", param_672
.annotate 'line', 4
    .local string rx673_tgt
    .local int rx673_pos
    .local int rx673_off
    .local int rx673_eos
    .local int rx673_rep
    .local pmc rx673_cur
    .local pmc rx673_debug
    (rx673_cur, rx673_pos, rx673_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx673_cur
    .local pmc match
    .lex "$/", match
    length rx673_eos, rx673_tgt
    gt rx673_pos, rx673_eos, rx673_done
    set rx673_off, 0
    lt rx673_pos, 2, rx673_start
    sub rx673_off, rx673_pos, 1
    substr rx673_tgt, rx673_tgt, rx673_off
  rx673_start:
    eq $I10, 1, rx673_restart
    if_null rx673_debug, debug_690
    rx673_cur."!cursor_debug"("START", "scoped")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan678_done
    goto rxscan678_scan
  rxscan678_loop:
    ($P10) = rx673_cur."from"()
    inc $P10
    set rx673_pos, $P10
    ge rx673_pos, rx673_eos, rxscan678_done
  rxscan678_scan:
    set_addr $I10, rxscan678_loop
    rx673_cur."!mark_push"(0, rx673_pos, $I10)
  rxscan678_done:
  alt679_0:
.annotate 'line', 318
    set_addr $I10, alt679_1
    rx673_cur."!mark_push"(0, rx673_pos, $I10)
.annotate 'line', 319
  # rx subrule "ws" subtype=method negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."ws"()
    unless $P10, rx673_fail
    rx673_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."declarator"()
    unless $P10, rx673_fail
    rx673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx673_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."ws"()
    unless $P10, rx673_fail
    rx673_pos = $P10."pos"()
    goto alt679_end
  alt679_1:
.annotate 'line', 320
  # rx subrule "ws" subtype=method negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."ws"()
    unless $P10, rx673_fail
    rx673_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."multi_declarator"()
    unless $P10, rx673_fail
    rx673_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx673_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx673_cur."!cursor_pos"(rx673_pos)
    $P10 = rx673_cur."ws"()
    unless $P10, rx673_fail
    rx673_pos = $P10."pos"()
  alt679_end:
.annotate 'line', 318
  # rx pass
    rx673_cur."!cursor_pass"(rx673_pos, "scoped")
    if_null rx673_debug, debug_691
    rx673_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx673_pos)
  debug_691:
    .return (rx673_cur)
  rx673_restart:
.annotate 'line', 4
    if_null rx673_debug, debug_692
    rx673_cur."!cursor_debug"("NEXT", "scoped")
  debug_692:
  rx673_fail:
    (rx673_rep, rx673_pos, $I10, $P10) = rx673_cur."!mark_fail"(0)
    lt rx673_pos, -1, rx673_done
    eq rx673_pos, -1, rx673_fail
    jump $I10
  rx673_done:
    rx673_cur."!cursor_fail"()
    if_null rx673_debug, debug_693
    rx673_cur."!cursor_debug"("FAIL", "scoped")
  debug_693:
    .return (rx673_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("154_1295994649.593") :method
.annotate 'line', 4
    $P675 = self."!PREFIX__!subrule"("ws", "")
    $P676 = self."!PREFIX__!subrule"("ws", "")
    new $P677, "ResizablePMCArray"
    push $P677, $P675
    push $P677, $P676
    .return ($P677)
.end


.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("155_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx685_tgt
    .local int rx685_pos
    .local int rx685_off
    .local int rx685_eos
    .local int rx685_rep
    .local pmc rx685_cur
    .local pmc rx685_debug
    (rx685_cur, rx685_pos, rx685_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx685_cur
    .local pmc match
    .lex "$/", match
    length rx685_eos, rx685_tgt
    gt rx685_pos, rx685_eos, rx685_done
    set rx685_off, 0
    lt rx685_pos, 2, rx685_start
    sub rx685_off, rx685_pos, 1
    substr rx685_tgt, rx685_tgt, rx685_off
  rx685_start:
    eq $I10, 1, rx685_restart
    if_null rx685_debug, debug_694
    rx685_cur."!cursor_debug"("START", "typename")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan689_done
    goto rxscan689_scan
  rxscan689_loop:
    ($P10) = rx685_cur."from"()
    inc $P10
    set rx685_pos, $P10
    ge rx685_pos, rx685_eos, rxscan689_done
  rxscan689_scan:
    set_addr $I10, rxscan689_loop
    rx685_cur."!mark_push"(0, rx685_pos, $I10)
  rxscan689_done:
.annotate 'line', 323
  # rx subrule "name" subtype=capture negate=
    rx685_cur."!cursor_pos"(rx685_pos)
    $P10 = rx685_cur."name"()
    unless $P10, rx685_fail
    rx685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx685_pos = $P10."pos"()
  # rx pass
    rx685_cur."!cursor_pass"(rx685_pos, "typename")
    if_null rx685_debug, debug_695
    rx685_cur."!cursor_debug"("PASS", "typename", " at pos=", rx685_pos)
  debug_695:
    .return (rx685_cur)
  rx685_restart:
.annotate 'line', 4
    if_null rx685_debug, debug_696
    rx685_cur."!cursor_debug"("NEXT", "typename")
  debug_696:
  rx685_fail:
    (rx685_rep, rx685_pos, $I10, $P10) = rx685_cur."!mark_fail"(0)
    lt rx685_pos, -1, rx685_done
    eq rx685_pos, -1, rx685_fail
    jump $I10
  rx685_done:
    rx685_cur."!cursor_fail"()
    if_null rx685_debug, debug_697
    rx685_cur."!cursor_debug"("FAIL", "typename")
  debug_697:
    .return (rx685_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("156_1295994649.593") :method
.annotate 'line', 4
    $P687 = self."!PREFIX__!subrule"("name", "")
    new $P688, "ResizablePMCArray"
    push $P688, $P687
    .return ($P688)
.end


.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("157_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx691_tgt
    .local int rx691_pos
    .local int rx691_off
    .local int rx691_eos
    .local int rx691_rep
    .local pmc rx691_cur
    .local pmc rx691_debug
    (rx691_cur, rx691_pos, rx691_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx691_cur
    .local pmc match
    .lex "$/", match
    length rx691_eos, rx691_tgt
    gt rx691_pos, rx691_eos, rx691_done
    set rx691_off, 0
    lt rx691_pos, 2, rx691_start
    sub rx691_off, rx691_pos, 1
    substr rx691_tgt, rx691_tgt, rx691_off
  rx691_start:
    eq $I10, 1, rx691_restart
    if_null rx691_debug, debug_698
    rx691_cur."!cursor_debug"("START", "declarator")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan696_done
    goto rxscan696_scan
  rxscan696_loop:
    ($P10) = rx691_cur."from"()
    inc $P10
    set rx691_pos, $P10
    ge rx691_pos, rx691_eos, rxscan696_done
  rxscan696_scan:
    set_addr $I10, rxscan696_loop
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
  rxscan696_done:
  alt697_0:
.annotate 'line', 325
    set_addr $I10, alt697_1
    rx691_cur."!mark_push"(0, rx691_pos, $I10)
.annotate 'line', 326
  # rx subrule "variable_declarator" subtype=capture negate=
    rx691_cur."!cursor_pos"(rx691_pos)
    $P10 = rx691_cur."variable_declarator"()
    unless $P10, rx691_fail
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx691_pos = $P10."pos"()
    goto alt697_end
  alt697_1:
.annotate 'line', 327
  # rx subrule "routine_declarator" subtype=capture negate=
    rx691_cur."!cursor_pos"(rx691_pos)
    $P10 = rx691_cur."routine_declarator"()
    unless $P10, rx691_fail
    rx691_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx691_pos = $P10."pos"()
  alt697_end:
.annotate 'line', 325
  # rx pass
    rx691_cur."!cursor_pass"(rx691_pos, "declarator")
    if_null rx691_debug, debug_699
    rx691_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx691_pos)
  debug_699:
    .return (rx691_cur)
  rx691_restart:
.annotate 'line', 4
    if_null rx691_debug, debug_700
    rx691_cur."!cursor_debug"("NEXT", "declarator")
  debug_700:
  rx691_fail:
    (rx691_rep, rx691_pos, $I10, $P10) = rx691_cur."!mark_fail"(0)
    lt rx691_pos, -1, rx691_done
    eq rx691_pos, -1, rx691_fail
    jump $I10
  rx691_done:
    rx691_cur."!cursor_fail"()
    if_null rx691_debug, debug_701
    rx691_cur."!cursor_debug"("FAIL", "declarator")
  debug_701:
    .return (rx691_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("158_1295994649.593") :method
.annotate 'line', 4
    $P693 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P694 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P695, "ResizablePMCArray"
    push $P695, $P693
    push $P695, $P694
    .return ($P695)
.end


.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("159_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx699_tgt
    .local int rx699_pos
    .local int rx699_off
    .local int rx699_eos
    .local int rx699_rep
    .local pmc rx699_cur
    .local pmc rx699_debug
    (rx699_cur, rx699_pos, rx699_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx699_cur
    .local pmc match
    .lex "$/", match
    length rx699_eos, rx699_tgt
    gt rx699_pos, rx699_eos, rx699_done
    set rx699_off, 0
    lt rx699_pos, 2, rx699_start
    sub rx699_off, rx699_pos, 1
    substr rx699_tgt, rx699_tgt, rx699_off
  rx699_start:
    eq $I10, 1, rx699_restart
    if_null rx699_debug, debug_702
    rx699_cur."!cursor_debug"("START", "variable_declarator")
  debug_702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan703_done
    goto rxscan703_scan
  rxscan703_loop:
    ($P10) = rx699_cur."from"()
    inc $P10
    set rx699_pos, $P10
    ge rx699_pos, rx699_eos, rxscan703_done
  rxscan703_scan:
    set_addr $I10, rxscan703_loop
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
  rxscan703_done:
.annotate 'line', 330
  # rx subrule "variable" subtype=capture negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."variable"()
    unless $P10, rx699_fail
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx699_pos = $P10."pos"()
  # rx pass
    rx699_cur."!cursor_pass"(rx699_pos, "variable_declarator")
    if_null rx699_debug, debug_703
    rx699_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx699_pos)
  debug_703:
    .return (rx699_cur)
  rx699_restart:
.annotate 'line', 4
    if_null rx699_debug, debug_704
    rx699_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_704:
  rx699_fail:
    (rx699_rep, rx699_pos, $I10, $P10) = rx699_cur."!mark_fail"(0)
    lt rx699_pos, -1, rx699_done
    eq rx699_pos, -1, rx699_fail
    jump $I10
  rx699_done:
    rx699_cur."!cursor_fail"()
    if_null rx699_debug, debug_705
    rx699_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_705:
    .return (rx699_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("160_1295994649.593") :method
.annotate 'line', 4
    $P701 = self."!PREFIX__!subrule"("variable", "")
    new $P702, "ResizablePMCArray"
    push $P702, $P701
    .return ($P702)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("161_1295994649.593")
    .param pmc param_705
.annotate 'line', 332
    .lex "self", param_705
    $P706 = param_705."!protoregex"("routine_declarator")
    .return ($P706)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("162_1295994649.593")
    .param pmc param_708
.annotate 'line', 332
    .lex "self", param_708
    $P709 = param_708."!PREFIX__!protoregex"("routine_declarator")
    .return ($P709)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("163_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx711_tgt
    .local int rx711_pos
    .local int rx711_off
    .local int rx711_eos
    .local int rx711_rep
    .local pmc rx711_cur
    .local pmc rx711_debug
    (rx711_cur, rx711_pos, rx711_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx711_cur
    .local pmc match
    .lex "$/", match
    length rx711_eos, rx711_tgt
    gt rx711_pos, rx711_eos, rx711_done
    set rx711_off, 0
    lt rx711_pos, 2, rx711_start
    sub rx711_off, rx711_pos, 1
    substr rx711_tgt, rx711_tgt, rx711_off
  rx711_start:
    eq $I10, 1, rx711_restart
    if_null rx711_debug, debug_706
    rx711_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan715_done
    goto rxscan715_scan
  rxscan715_loop:
    ($P10) = rx711_cur."from"()
    inc $P10
    set rx711_pos, $P10
    ge rx711_pos, rx711_eos, rxscan715_done
  rxscan715_scan:
    set_addr $I10, rxscan715_loop
    rx711_cur."!mark_push"(0, rx711_pos, $I10)
  rxscan715_done:
.annotate 'line', 333
  # rx subcapture "sym"
    set_addr $I10, rxcap_716_fail
    rx711_cur."!mark_push"(0, rx711_pos, $I10)
  # rx literal  "sub"
    add $I11, rx711_pos, 3
    gt $I11, rx711_eos, rx711_fail
    sub $I11, rx711_pos, rx711_off
    substr $S10, rx711_tgt, $I11, 3
    ne $S10, "sub", rx711_fail
    add rx711_pos, 3
    set_addr $I10, rxcap_716_fail
    ($I12, $I11) = rx711_cur."!mark_peek"($I10)
    rx711_cur."!cursor_pos"($I11)
    ($P10) = rx711_cur."!cursor_start"()
    $P10."!cursor_pass"(rx711_pos, "")
    rx711_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_716_done
  rxcap_716_fail:
    goto rx711_fail
  rxcap_716_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx711_cur."!cursor_pos"(rx711_pos)
    $P10 = rx711_cur."routine_def"()
    unless $P10, rx711_fail
    rx711_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx711_pos = $P10."pos"()
  # rx pass
    rx711_cur."!cursor_pass"(rx711_pos, "routine_declarator:sym<sub>")
    if_null rx711_debug, debug_707
    rx711_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx711_pos)
  debug_707:
    .return (rx711_cur)
  rx711_restart:
.annotate 'line', 4
    if_null rx711_debug, debug_708
    rx711_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_708:
  rx711_fail:
    (rx711_rep, rx711_pos, $I10, $P10) = rx711_cur."!mark_fail"(0)
    lt rx711_pos, -1, rx711_done
    eq rx711_pos, -1, rx711_fail
    jump $I10
  rx711_done:
    rx711_cur."!cursor_fail"()
    if_null rx711_debug, debug_709
    rx711_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_709:
    .return (rx711_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("164_1295994649.593") :method
.annotate 'line', 4
    $P713 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P714, "ResizablePMCArray"
    push $P714, $P713
    .return ($P714)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("165_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx718_tgt
    .local int rx718_pos
    .local int rx718_off
    .local int rx718_eos
    .local int rx718_rep
    .local pmc rx718_cur
    .local pmc rx718_debug
    (rx718_cur, rx718_pos, rx718_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx718_cur
    .local pmc match
    .lex "$/", match
    length rx718_eos, rx718_tgt
    gt rx718_pos, rx718_eos, rx718_done
    set rx718_off, 0
    lt rx718_pos, 2, rx718_start
    sub rx718_off, rx718_pos, 1
    substr rx718_tgt, rx718_tgt, rx718_off
  rx718_start:
    eq $I10, 1, rx718_restart
    if_null rx718_debug, debug_710
    rx718_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan722_done
    goto rxscan722_scan
  rxscan722_loop:
    ($P10) = rx718_cur."from"()
    inc $P10
    set rx718_pos, $P10
    ge rx718_pos, rx718_eos, rxscan722_done
  rxscan722_scan:
    set_addr $I10, rxscan722_loop
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  rxscan722_done:
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_723_fail
    rx718_cur."!mark_push"(0, rx718_pos, $I10)
  # rx literal  "method"
    add $I11, rx718_pos, 6
    gt $I11, rx718_eos, rx718_fail
    sub $I11, rx718_pos, rx718_off
    substr $S10, rx718_tgt, $I11, 6
    ne $S10, "method", rx718_fail
    add rx718_pos, 6
    set_addr $I10, rxcap_723_fail
    ($I12, $I11) = rx718_cur."!mark_peek"($I10)
    rx718_cur."!cursor_pos"($I11)
    ($P10) = rx718_cur."!cursor_start"()
    $P10."!cursor_pass"(rx718_pos, "")
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_723_done
  rxcap_723_fail:
    goto rx718_fail
  rxcap_723_done:
  # rx subrule "method_def" subtype=capture negate=
    rx718_cur."!cursor_pos"(rx718_pos)
    $P10 = rx718_cur."method_def"()
    unless $P10, rx718_fail
    rx718_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx718_pos = $P10."pos"()
  # rx pass
    rx718_cur."!cursor_pass"(rx718_pos, "routine_declarator:sym<method>")
    if_null rx718_debug, debug_711
    rx718_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx718_pos)
  debug_711:
    .return (rx718_cur)
  rx718_restart:
.annotate 'line', 4
    if_null rx718_debug, debug_712
    rx718_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_712:
  rx718_fail:
    (rx718_rep, rx718_pos, $I10, $P10) = rx718_cur."!mark_fail"(0)
    lt rx718_pos, -1, rx718_done
    eq rx718_pos, -1, rx718_fail
    jump $I10
  rx718_done:
    rx718_cur."!cursor_fail"()
    if_null rx718_debug, debug_713
    rx718_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_713:
    .return (rx718_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("166_1295994649.593") :method
.annotate 'line', 4
    $P720 = self."!PREFIX__!subrule"("method_def", "method")
    new $P721, "ResizablePMCArray"
    push $P721, $P720
    .return ($P721)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("167_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 337
    new $P725, "Undef"
    .lex "$*RETURN_USED", $P725
.annotate 'line', 4
    .local string rx726_tgt
    .local int rx726_pos
    .local int rx726_off
    .local int rx726_eos
    .local int rx726_rep
    .local pmc rx726_cur
    .local pmc rx726_debug
    (rx726_cur, rx726_pos, rx726_tgt, $I10) = self."!cursor_start"()
    rx726_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx726_cur
    .local pmc match
    .lex "$/", match
    length rx726_eos, rx726_tgt
    gt rx726_pos, rx726_eos, rx726_done
    set rx726_off, 0
    lt rx726_pos, 2, rx726_start
    sub rx726_off, rx726_pos, 1
    substr rx726_tgt, rx726_tgt, rx726_off
  rx726_start:
    eq $I10, 1, rx726_restart
    if_null rx726_debug, debug_714
    rx726_cur."!cursor_debug"("START", "routine_def")
  debug_714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan730_done
    goto rxscan730_scan
  rxscan730_loop:
    ($P10) = rx726_cur."from"()
    inc $P10
    set rx726_pos, $P10
    ge rx726_pos, rx726_eos, rxscan730_done
  rxscan730_scan:
    set_addr $I10, rxscan730_loop
    rx726_cur."!mark_push"(0, rx726_pos, $I10)
  rxscan730_done:
.annotate 'line', 336
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
.annotate 'line', 337
    rx726_cur."!cursor_pos"(rx726_pos)
    new $P732, "Integer"
    assign $P732, 0
    store_lex "$*RETURN_USED", $P732
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
.annotate 'line', 338
  # rx rxquantr734 ** 0..1
    set_addr $I10, rxquantr734_done
    rx726_cur."!mark_push"(0, rx726_pos, $I10)
  rxquantr734_loop:
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_737_fail
    rx726_cur."!mark_push"(0, rx726_pos, $I10)
  # rx rxquantr736 ** 0..1
    set_addr $I10, rxquantr736_done
    rx726_cur."!mark_push"(0, rx726_pos, $I10)
  rxquantr736_loop:
  # rx literal  "&"
    add $I11, rx726_pos, 1
    gt $I11, rx726_eos, rx726_fail
    sub $I11, rx726_pos, rx726_off
    ord $I11, rx726_tgt, $I11
    ne $I11, 38, rx726_fail
    add rx726_pos, 1
    set_addr $I10, rxquantr736_done
    (rx726_rep) = rx726_cur."!mark_commit"($I10)
  rxquantr736_done:
    set_addr $I10, rxcap_737_fail
    ($I12, $I11) = rx726_cur."!mark_peek"($I10)
    rx726_cur."!cursor_pos"($I11)
    ($P10) = rx726_cur."!cursor_start"()
    $P10."!cursor_pass"(rx726_pos, "")
    rx726_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_737_done
  rxcap_737_fail:
    goto rx726_fail
  rxcap_737_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."deflongname"()
    unless $P10, rx726_fail
    rx726_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
    set_addr $I10, rxquantr734_done
    (rx726_rep) = rx726_cur."!mark_commit"($I10)
  rxquantr734_done:
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
.annotate 'line', 339
  # rx subrule "newpad" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."newpad"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  alt741_0:
.annotate 'line', 340
    set_addr $I10, alt741_1
    rx726_cur."!mark_push"(0, rx726_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx726_pos, 1
    gt $I11, rx726_eos, rx726_fail
    sub $I11, rx726_pos, rx726_off
    ord $I11, rx726_tgt, $I11
    ne $I11, 40, rx726_fail
    add rx726_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."signature"()
    unless $P10, rx726_fail
    rx726_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx726_pos, 1
    gt $I11, rx726_eos, rx726_fail
    sub $I11, rx726_pos, rx726_off
    ord $I11, rx726_tgt, $I11
    ne $I11, 41, rx726_fail
    add rx726_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
    goto alt741_end
  alt741_1:
.annotate 'line', 341
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  alt741_end:
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
.annotate 'line', 342
  # rx rxquantr749 ** 0..*
    set_addr $I10, rxquantr749_done
    rx726_cur."!mark_push"(0, rx726_pos, $I10)
  rxquantr749_loop:
  # rx subrule "trait" subtype=capture negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."trait"()
    unless $P10, rx726_fail
    goto rxsubrule750_pass
  rxsubrule750_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx726_fail
  rxsubrule750_pass:
    set_addr $I10, rxsubrule750_back
    rx726_cur."!mark_push"(0, rx726_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx726_pos = $P10."pos"()
    set_addr $I10, rxquantr749_done
    (rx726_rep) = rx726_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr749_done
    rx726_cur."!mark_push"(rx726_rep, rx726_pos, $I10)
    goto rxquantr749_loop
  rxquantr749_done:
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  alt752_0:
.annotate 'line', 343
    set_addr $I10, alt752_1
    rx726_cur."!mark_push"(0, rx726_pos, $I10)
.annotate 'line', 344
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."onlystar"()
    unless $P10, rx726_fail
    rx726_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
    goto alt752_end
  alt752_1:
.annotate 'line', 345
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."blockoid"()
    unless $P10, rx726_fail
    rx726_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx726_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
  alt752_end:
.annotate 'line', 346
  # rx subrule "ws" subtype=method negate=
    rx726_cur."!cursor_pos"(rx726_pos)
    $P10 = rx726_cur."ws"()
    unless $P10, rx726_fail
    rx726_pos = $P10."pos"()
.annotate 'line', 336
  # rx pass
    rx726_cur."!cursor_pass"(rx726_pos, "routine_def")
    if_null rx726_debug, debug_715
    rx726_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx726_pos)
  debug_715:
    .return (rx726_cur)
  rx726_restart:
.annotate 'line', 4
    if_null rx726_debug, debug_716
    rx726_cur."!cursor_debug"("NEXT", "routine_def")
  debug_716:
  rx726_fail:
    (rx726_rep, rx726_pos, $I10, $P10) = rx726_cur."!mark_fail"(0)
    lt rx726_pos, -1, rx726_done
    eq rx726_pos, -1, rx726_fail
    jump $I10
  rx726_done:
    rx726_cur."!cursor_fail"()
    if_null rx726_debug, debug_717
    rx726_cur."!cursor_debug"("FAIL", "routine_def")
  debug_717:
    .return (rx726_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("168_1295994649.593") :method
.annotate 'line', 4
    $P728 = self."!PREFIX__!subrule"("ws", "")
    new $P729, "ResizablePMCArray"
    push $P729, $P728
    .return ($P729)
.end


.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("169_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P789 = "171_1295994649.593" 
    capture_lex $P789
.annotate 'line', 350
    new $P759, "Undef"
    .lex "$*RETURN_USED", $P759
.annotate 'line', 351
    new $P760, "Undef"
    .lex "$*INVOCANT_OK", $P760
.annotate 'line', 4
    .local string rx761_tgt
    .local int rx761_pos
    .local int rx761_off
    .local int rx761_eos
    .local int rx761_rep
    .local pmc rx761_cur
    .local pmc rx761_debug
    (rx761_cur, rx761_pos, rx761_tgt, $I10) = self."!cursor_start"()
    rx761_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx761_cur
    .local pmc match
    .lex "$/", match
    length rx761_eos, rx761_tgt
    gt rx761_pos, rx761_eos, rx761_done
    set rx761_off, 0
    lt rx761_pos, 2, rx761_start
    sub rx761_off, rx761_pos, 1
    substr rx761_tgt, rx761_tgt, rx761_off
  rx761_start:
    eq $I10, 1, rx761_restart
    if_null rx761_debug, debug_718
    rx761_cur."!cursor_debug"("START", "method_def")
  debug_718:
    $I10 = self.'from'()
    ne $I10, -1, rxscan765_done
    goto rxscan765_scan
  rxscan765_loop:
    ($P10) = rx761_cur."from"()
    inc $P10
    set rx761_pos, $P10
    ge rx761_pos, rx761_eos, rxscan765_done
  rxscan765_scan:
    set_addr $I10, rxscan765_loop
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxscan765_done:
.annotate 'line', 349
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
.annotate 'line', 350
    rx761_cur."!cursor_pos"(rx761_pos)
    new $P767, "Integer"
    assign $P767, 0
    store_lex "$*RETURN_USED", $P767
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
.annotate 'line', 351
    rx761_cur."!cursor_pos"(rx761_pos)
    new $P769, "Integer"
    assign $P769, 1
    store_lex "$*INVOCANT_OK", $P769
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
.annotate 'line', 352
  # rx subcapture "private"
    set_addr $I10, rxcap_772_fail
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  # rx rxquantr771 ** 0..1
    set_addr $I10, rxquantr771_done
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxquantr771_loop:
  # rx literal  "!"
    add $I11, rx761_pos, 1
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    ord $I11, rx761_tgt, $I11
    ne $I11, 33, rx761_fail
    add rx761_pos, 1
    set_addr $I10, rxquantr771_done
    (rx761_rep) = rx761_cur."!mark_commit"($I10)
  rxquantr771_done:
    set_addr $I10, rxcap_772_fail
    ($I12, $I11) = rx761_cur."!mark_peek"($I10)
    rx761_cur."!cursor_pos"($I11)
    ($P10) = rx761_cur."!cursor_start"()
    $P10."!cursor_pass"(rx761_pos, "")
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_772_done
  rxcap_772_fail:
    goto rx761_fail
  rxcap_772_done:
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
.annotate 'line', 353
  # rx rxquantr774 ** 0..1
    set_addr $I10, rxquantr774_done
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxquantr774_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."deflongname"()
    unless $P10, rx761_fail
    goto rxsubrule775_pass
  rxsubrule775_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx761_fail
  rxsubrule775_pass:
    set_addr $I10, rxsubrule775_back
    rx761_cur."!mark_push"(0, rx761_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx761_pos = $P10."pos"()
    set_addr $I10, rxquantr774_done
    (rx761_rep) = rx761_cur."!mark_commit"($I10)
  rxquantr774_done:
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
.annotate 'line', 354
  # rx subrule "newpad" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."newpad"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  alt778_0:
.annotate 'line', 355
    set_addr $I10, alt778_1
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx761_pos, 1
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    ord $I11, rx761_tgt, $I11
    ne $I11, 40, rx761_fail
    add rx761_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."signature"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx761_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx761_pos, 1
    gt $I11, rx761_eos, rx761_fail
    sub $I11, rx761_pos, rx761_off
    ord $I11, rx761_tgt, $I11
    ne $I11, 41, rx761_fail
    add rx761_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
    goto alt778_end
  alt778_1:
.annotate 'line', 356
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  alt778_end:
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
.annotate 'line', 357
    rx761_cur."!cursor_pos"(rx761_pos)
    find_lex $P786, unicode:"$\x{a2}"
    $P787 = $P786."MATCH"()
    store_lex "$/", $P787
    .const 'Sub' $P789 = "171_1295994649.593" 
    capture_lex $P789
    $P791 = $P789()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
.annotate 'line', 358
  # rx rxquantr793 ** 0..*
    set_addr $I10, rxquantr793_done
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
  rxquantr793_loop:
  # rx subrule "trait" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."trait"()
    unless $P10, rx761_fail
    goto rxsubrule794_pass
  rxsubrule794_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx761_fail
  rxsubrule794_pass:
    set_addr $I10, rxsubrule794_back
    rx761_cur."!mark_push"(0, rx761_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx761_pos = $P10."pos"()
    set_addr $I10, rxquantr793_done
    (rx761_rep) = rx761_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr793_done
    rx761_cur."!mark_push"(rx761_rep, rx761_pos, $I10)
    goto rxquantr793_loop
  rxquantr793_done:
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  alt796_0:
.annotate 'line', 359
    set_addr $I10, alt796_1
    rx761_cur."!mark_push"(0, rx761_pos, $I10)
.annotate 'line', 360
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."onlystar"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx761_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
    goto alt796_end
  alt796_1:
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."blockoid"()
    unless $P10, rx761_fail
    rx761_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx761_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
  alt796_end:
.annotate 'line', 362
  # rx subrule "ws" subtype=method negate=
    rx761_cur."!cursor_pos"(rx761_pos)
    $P10 = rx761_cur."ws"()
    unless $P10, rx761_fail
    rx761_pos = $P10."pos"()
.annotate 'line', 349
  # rx pass
    rx761_cur."!cursor_pass"(rx761_pos, "method_def")
    if_null rx761_debug, debug_719
    rx761_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx761_pos)
  debug_719:
    .return (rx761_cur)
  rx761_restart:
.annotate 'line', 4
    if_null rx761_debug, debug_720
    rx761_cur."!cursor_debug"("NEXT", "method_def")
  debug_720:
  rx761_fail:
    (rx761_rep, rx761_pos, $I10, $P10) = rx761_cur."!mark_fail"(0)
    lt rx761_pos, -1, rx761_done
    eq rx761_pos, -1, rx761_fail
    jump $I10
  rx761_done:
    rx761_cur."!cursor_fail"()
    if_null rx761_debug, debug_721
    rx761_cur."!cursor_debug"("FAIL", "method_def")
  debug_721:
    .return (rx761_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("170_1295994649.593") :method
.annotate 'line', 4
    $P763 = self."!PREFIX__!subrule"("ws", "")
    new $P764, "ResizablePMCArray"
    push $P764, $P763
    .return ($P764)
.end


.namespace ["NQP";"Grammar"]
.sub "_block788"  :anon :subid("171_1295994649.593") :outer("169_1295994649.593")
.annotate 'line', 357
    new $P790, "Integer"
    assign $P790, 0
    store_dynamic_lex "$*INVOCANT_OK", $P790
    .return ($P790)
.end


.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("172_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P810 = "174_1295994649.593" 
    capture_lex $P810
    .local string rx803_tgt
    .local int rx803_pos
    .local int rx803_off
    .local int rx803_eos
    .local int rx803_rep
    .local pmc rx803_cur
    .local pmc rx803_debug
    (rx803_cur, rx803_pos, rx803_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx803_cur
    .local pmc match
    .lex "$/", match
    length rx803_eos, rx803_tgt
    gt rx803_pos, rx803_eos, rx803_done
    set rx803_off, 0
    lt rx803_pos, 2, rx803_start
    sub rx803_off, rx803_pos, 1
    substr rx803_tgt, rx803_tgt, rx803_off
  rx803_start:
    eq $I10, 1, rx803_restart
    if_null rx803_debug, debug_722
    rx803_cur."!cursor_debug"("START", "onlystar")
  debug_722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan806_done
    goto rxscan806_scan
  rxscan806_loop:
    ($P10) = rx803_cur."from"()
    inc $P10
    set rx803_pos, $P10
    ge rx803_pos, rx803_eos, rxscan806_done
  rxscan806_scan:
    set_addr $I10, rxscan806_loop
    rx803_cur."!mark_push"(0, rx803_pos, $I10)
  rxscan806_done:
.annotate 'line', 366
    rx803_cur."!cursor_pos"(rx803_pos)
    find_lex $P807, unicode:"$\x{a2}"
    $P808 = $P807."MATCH"()
    store_lex "$/", $P808
    .const 'Sub' $P810 = "174_1295994649.593" 
    capture_lex $P810
    $P814 = $P810()
    unless $P814, rx803_fail
.annotate 'line', 367
  # rx literal  "{"
    add $I11, rx803_pos, 1
    gt $I11, rx803_eos, rx803_fail
    sub $I11, rx803_pos, rx803_off
    ord $I11, rx803_tgt, $I11
    ne $I11, 123, rx803_fail
    add rx803_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx803_cur."!cursor_pos"(rx803_pos)
    $P10 = rx803_cur."ws"()
    unless $P10, rx803_fail
    rx803_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx803_pos, 1
    gt $I11, rx803_eos, rx803_fail
    sub $I11, rx803_pos, rx803_off
    ord $I11, rx803_tgt, $I11
    ne $I11, 42, rx803_fail
    add rx803_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx803_cur."!cursor_pos"(rx803_pos)
    $P10 = rx803_cur."ws"()
    unless $P10, rx803_fail
    rx803_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx803_pos, 1
    gt $I11, rx803_eos, rx803_fail
    sub $I11, rx803_pos, rx803_off
    ord $I11, rx803_tgt, $I11
    ne $I11, 125, rx803_fail
    add rx803_pos, 1
.annotate 'line', 368
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx803_cur."!cursor_pos"(rx803_pos)
    $P10 = rx803_cur."ENDSTMT"()
    unless $P10, rx803_fail
.annotate 'line', 369
  # rx subrule "finishpad" subtype=method negate=
    rx803_cur."!cursor_pos"(rx803_pos)
    $P10 = rx803_cur."finishpad"()
    unless $P10, rx803_fail
    rx803_pos = $P10."pos"()
.annotate 'line', 365
  # rx pass
    rx803_cur."!cursor_pass"(rx803_pos, "onlystar")
    if_null rx803_debug, debug_725
    rx803_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx803_pos)
  debug_725:
    .return (rx803_cur)
  rx803_restart:
.annotate 'line', 4
    if_null rx803_debug, debug_726
    rx803_cur."!cursor_debug"("NEXT", "onlystar")
  debug_726:
  rx803_fail:
    (rx803_rep, rx803_pos, $I10, $P10) = rx803_cur."!mark_fail"(0)
    lt rx803_pos, -1, rx803_done
    eq rx803_pos, -1, rx803_fail
    jump $I10
  rx803_done:
    rx803_cur."!cursor_fail"()
    if_null rx803_debug, debug_727
    rx803_cur."!cursor_debug"("FAIL", "onlystar")
  debug_727:
    .return (rx803_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("173_1295994649.593") :method
.annotate 'line', 4
    new $P805, "ResizablePMCArray"
    push $P805, ""
    .return ($P805)
.end


.namespace ["NQP";"Grammar"]
.sub "_block809"  :anon :subid("174_1295994649.593") :outer("172_1295994649.593")
.annotate 'line', 366
    find_dynamic_lex $P811, "$*MULTINESS"
    unless_null $P811, vivify_723
    get_hll_global $P811, "$MULTINESS"
    unless_null $P811, vivify_724
    die "Contextual $*MULTINESS not found"
  vivify_724:
  vivify_723:
    set $S812, $P811
    iseq $I813, $S812, "proto"
    .return ($I813)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("175_1295994649.593")
    .param pmc param_816
.annotate 'line', 372
    .lex "self", param_816
    $P817 = param_816."!protoregex"("multi_declarator")
    .return ($P817)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("176_1295994649.593")
    .param pmc param_819
.annotate 'line', 372
    .lex "self", param_819
    $P820 = param_819."!PREFIX__!protoregex"("multi_declarator")
    .return ($P820)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("177_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 374
    new $P822, "Undef"
    .lex "$*MULTINESS", $P822
.annotate 'line', 4
    .local string rx823_tgt
    .local int rx823_pos
    .local int rx823_off
    .local int rx823_eos
    .local int rx823_rep
    .local pmc rx823_cur
    .local pmc rx823_debug
    (rx823_cur, rx823_pos, rx823_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx823_cur
    .local pmc match
    .lex "$/", match
    length rx823_eos, rx823_tgt
    gt rx823_pos, rx823_eos, rx823_done
    set rx823_off, 0
    lt rx823_pos, 2, rx823_start
    sub rx823_off, rx823_pos, 1
    substr rx823_tgt, rx823_tgt, rx823_off
  rx823_start:
    eq $I10, 1, rx823_restart
    if_null rx823_debug, debug_728
    rx823_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan827_done
    goto rxscan827_scan
  rxscan827_loop:
    ($P10) = rx823_cur."from"()
    inc $P10
    set rx823_pos, $P10
    ge rx823_pos, rx823_eos, rxscan827_done
  rxscan827_scan:
    set_addr $I10, rxscan827_loop
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  rxscan827_done:
.annotate 'line', 374
    rx823_cur."!cursor_pos"(rx823_pos)
    new $P828, "String"
    assign $P828, "multi"
    store_lex "$*MULTINESS", $P828
.annotate 'line', 375
  # rx subcapture "sym"
    set_addr $I10, rxcap_829_fail
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  # rx literal  "multi"
    add $I11, rx823_pos, 5
    gt $I11, rx823_eos, rx823_fail
    sub $I11, rx823_pos, rx823_off
    substr $S10, rx823_tgt, $I11, 5
    ne $S10, "multi", rx823_fail
    add rx823_pos, 5
    set_addr $I10, rxcap_829_fail
    ($I12, $I11) = rx823_cur."!mark_peek"($I10)
    rx823_cur."!cursor_pos"($I11)
    ($P10) = rx823_cur."!cursor_start"()
    $P10."!cursor_pass"(rx823_pos, "")
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_829_done
  rxcap_829_fail:
    goto rx823_fail
  rxcap_829_done:
.annotate 'line', 376
  # rx subrule "ws" subtype=method negate=
    rx823_cur."!cursor_pos"(rx823_pos)
    $P10 = rx823_cur."ws"()
    unless $P10, rx823_fail
    rx823_pos = $P10."pos"()
  alt830_0:
    set_addr $I10, alt830_1
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx823_cur."!cursor_pos"(rx823_pos)
    $P10 = rx823_cur."declarator"()
    unless $P10, rx823_fail
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx823_pos = $P10."pos"()
    goto alt830_end
  alt830_1:
    set_addr $I10, alt830_2
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx823_cur."!cursor_pos"(rx823_pos)
    $P10 = rx823_cur."routine_def"()
    unless $P10, rx823_fail
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx823_pos = $P10."pos"()
    goto alt830_end
  alt830_2:
  # rx subrule "panic" subtype=method negate=
    rx823_cur."!cursor_pos"(rx823_pos)
    $P10 = rx823_cur."panic"("Malformed multi")
    unless $P10, rx823_fail
    rx823_pos = $P10."pos"()
  alt830_end:
.annotate 'line', 373
  # rx pass
    rx823_cur."!cursor_pass"(rx823_pos, "multi_declarator:sym<multi>")
    if_null rx823_debug, debug_729
    rx823_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx823_pos)
  debug_729:
    .return (rx823_cur)
  rx823_restart:
.annotate 'line', 4
    if_null rx823_debug, debug_730
    rx823_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_730:
  rx823_fail:
    (rx823_rep, rx823_pos, $I10, $P10) = rx823_cur."!mark_fail"(0)
    lt rx823_pos, -1, rx823_done
    eq rx823_pos, -1, rx823_fail
    jump $I10
  rx823_done:
    rx823_cur."!cursor_fail"()
    if_null rx823_debug, debug_731
    rx823_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_731:
    .return (rx823_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("178_1295994649.593") :method
.annotate 'line', 4
    $P825 = self."!PREFIX__!subrule"("ws", "multi")
    new $P826, "ResizablePMCArray"
    push $P826, $P825
    .return ($P826)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("179_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 379
    new $P832, "Undef"
    .lex "$*MULTINESS", $P832
.annotate 'line', 4
    .local string rx833_tgt
    .local int rx833_pos
    .local int rx833_off
    .local int rx833_eos
    .local int rx833_rep
    .local pmc rx833_cur
    .local pmc rx833_debug
    (rx833_cur, rx833_pos, rx833_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx833_cur
    .local pmc match
    .lex "$/", match
    length rx833_eos, rx833_tgt
    gt rx833_pos, rx833_eos, rx833_done
    set rx833_off, 0
    lt rx833_pos, 2, rx833_start
    sub rx833_off, rx833_pos, 1
    substr rx833_tgt, rx833_tgt, rx833_off
  rx833_start:
    eq $I10, 1, rx833_restart
    if_null rx833_debug, debug_732
    rx833_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan837_done
    goto rxscan837_scan
  rxscan837_loop:
    ($P10) = rx833_cur."from"()
    inc $P10
    set rx833_pos, $P10
    ge rx833_pos, rx833_eos, rxscan837_done
  rxscan837_scan:
    set_addr $I10, rxscan837_loop
    rx833_cur."!mark_push"(0, rx833_pos, $I10)
  rxscan837_done:
.annotate 'line', 379
    rx833_cur."!cursor_pos"(rx833_pos)
    new $P838, "String"
    assign $P838, "proto"
    store_lex "$*MULTINESS", $P838
.annotate 'line', 380
  # rx subcapture "sym"
    set_addr $I10, rxcap_839_fail
    rx833_cur."!mark_push"(0, rx833_pos, $I10)
  # rx literal  "proto"
    add $I11, rx833_pos, 5
    gt $I11, rx833_eos, rx833_fail
    sub $I11, rx833_pos, rx833_off
    substr $S10, rx833_tgt, $I11, 5
    ne $S10, "proto", rx833_fail
    add rx833_pos, 5
    set_addr $I10, rxcap_839_fail
    ($I12, $I11) = rx833_cur."!mark_peek"($I10)
    rx833_cur."!cursor_pos"($I11)
    ($P10) = rx833_cur."!cursor_start"()
    $P10."!cursor_pass"(rx833_pos, "")
    rx833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_839_done
  rxcap_839_fail:
    goto rx833_fail
  rxcap_839_done:
.annotate 'line', 381
  # rx subrule "ws" subtype=method negate=
    rx833_cur."!cursor_pos"(rx833_pos)
    $P10 = rx833_cur."ws"()
    unless $P10, rx833_fail
    rx833_pos = $P10."pos"()
  alt840_0:
    set_addr $I10, alt840_1
    rx833_cur."!mark_push"(0, rx833_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx833_cur."!cursor_pos"(rx833_pos)
    $P10 = rx833_cur."declarator"()
    unless $P10, rx833_fail
    rx833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx833_pos = $P10."pos"()
    goto alt840_end
  alt840_1:
    set_addr $I10, alt840_2
    rx833_cur."!mark_push"(0, rx833_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx833_cur."!cursor_pos"(rx833_pos)
    $P10 = rx833_cur."routine_def"()
    unless $P10, rx833_fail
    rx833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx833_pos = $P10."pos"()
    goto alt840_end
  alt840_2:
  # rx subrule "panic" subtype=method negate=
    rx833_cur."!cursor_pos"(rx833_pos)
    $P10 = rx833_cur."panic"("Malformed proto")
    unless $P10, rx833_fail
    rx833_pos = $P10."pos"()
  alt840_end:
.annotate 'line', 378
  # rx pass
    rx833_cur."!cursor_pass"(rx833_pos, "multi_declarator:sym<proto>")
    if_null rx833_debug, debug_733
    rx833_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx833_pos)
  debug_733:
    .return (rx833_cur)
  rx833_restart:
.annotate 'line', 4
    if_null rx833_debug, debug_734
    rx833_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_734:
  rx833_fail:
    (rx833_rep, rx833_pos, $I10, $P10) = rx833_cur."!mark_fail"(0)
    lt rx833_pos, -1, rx833_done
    eq rx833_pos, -1, rx833_fail
    jump $I10
  rx833_done:
    rx833_cur."!cursor_fail"()
    if_null rx833_debug, debug_735
    rx833_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_735:
    .return (rx833_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("180_1295994649.593") :method
.annotate 'line', 4
    $P835 = self."!PREFIX__!subrule"("ws", "proto")
    new $P836, "ResizablePMCArray"
    push $P836, $P835
    .return ($P836)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("181_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 384
    new $P842, "Undef"
    .lex "$*MULTINESS", $P842
.annotate 'line', 4
    .local string rx843_tgt
    .local int rx843_pos
    .local int rx843_off
    .local int rx843_eos
    .local int rx843_rep
    .local pmc rx843_cur
    .local pmc rx843_debug
    (rx843_cur, rx843_pos, rx843_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx843_cur
    .local pmc match
    .lex "$/", match
    length rx843_eos, rx843_tgt
    gt rx843_pos, rx843_eos, rx843_done
    set rx843_off, 0
    lt rx843_pos, 2, rx843_start
    sub rx843_off, rx843_pos, 1
    substr rx843_tgt, rx843_tgt, rx843_off
  rx843_start:
    eq $I10, 1, rx843_restart
    if_null rx843_debug, debug_736
    rx843_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan847_done
    goto rxscan847_scan
  rxscan847_loop:
    ($P10) = rx843_cur."from"()
    inc $P10
    set rx843_pos, $P10
    ge rx843_pos, rx843_eos, rxscan847_done
  rxscan847_scan:
    set_addr $I10, rxscan847_loop
    rx843_cur."!mark_push"(0, rx843_pos, $I10)
  rxscan847_done:
.annotate 'line', 384
    rx843_cur."!cursor_pos"(rx843_pos)
    new $P848, "String"
    assign $P848, ""
    store_lex "$*MULTINESS", $P848
.annotate 'line', 385
  # rx subrule "declarator" subtype=capture negate=
    rx843_cur."!cursor_pos"(rx843_pos)
    $P10 = rx843_cur."declarator"()
    unless $P10, rx843_fail
    rx843_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx843_pos = $P10."pos"()
.annotate 'line', 383
  # rx pass
    rx843_cur."!cursor_pass"(rx843_pos, "multi_declarator:sym<null>")
    if_null rx843_debug, debug_737
    rx843_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx843_pos)
  debug_737:
    .return (rx843_cur)
  rx843_restart:
.annotate 'line', 4
    if_null rx843_debug, debug_738
    rx843_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_738:
  rx843_fail:
    (rx843_rep, rx843_pos, $I10, $P10) = rx843_cur."!mark_fail"(0)
    lt rx843_pos, -1, rx843_done
    eq rx843_pos, -1, rx843_fail
    jump $I10
  rx843_done:
    rx843_cur."!cursor_fail"()
    if_null rx843_debug, debug_739
    rx843_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_739:
    .return (rx843_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("182_1295994649.593") :method
.annotate 'line', 4
    $P845 = self."!PREFIX__!subrule"("declarator", "")
    new $P846, "ResizablePMCArray"
    push $P846, $P845
    .return ($P846)
.end


.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("183_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P858 = "185_1295994649.593" 
    capture_lex $P858
    .local string rx850_tgt
    .local int rx850_pos
    .local int rx850_off
    .local int rx850_eos
    .local int rx850_rep
    .local pmc rx850_cur
    .local pmc rx850_debug
    (rx850_cur, rx850_pos, rx850_tgt, $I10) = self."!cursor_start"()
    rx850_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx850_cur
    .local pmc match
    .lex "$/", match
    length rx850_eos, rx850_tgt
    gt rx850_pos, rx850_eos, rx850_done
    set rx850_off, 0
    lt rx850_pos, 2, rx850_start
    sub rx850_off, rx850_pos, 1
    substr rx850_tgt, rx850_tgt, rx850_off
  rx850_start:
    eq $I10, 1, rx850_restart
    if_null rx850_debug, debug_740
    rx850_cur."!cursor_debug"("START", "signature")
  debug_740:
    $I10 = self.'from'()
    ne $I10, -1, rxscan853_done
    goto rxscan853_scan
  rxscan853_loop:
    ($P10) = rx850_cur."from"()
    inc $P10
    set rx850_pos, $P10
    ge rx850_pos, rx850_eos, rxscan853_done
  rxscan853_scan:
    set_addr $I10, rxscan853_loop
    rx850_cur."!mark_push"(0, rx850_pos, $I10)
  rxscan853_done:
.annotate 'line', 389
  # rx rxquantr854 ** 0..1
    set_addr $I10, rxquantr854_done
    rx850_cur."!mark_push"(0, rx850_pos, $I10)
  rxquantr854_loop:
    rx850_cur."!cursor_pos"(rx850_pos)
    find_lex $P855, unicode:"$\x{a2}"
    $P856 = $P855."MATCH"()
    store_lex "$/", $P856
    .const 'Sub' $P858 = "185_1295994649.593" 
    capture_lex $P858
    $P860 = $P858()
    unless $P860, rx850_fail
  # rx subrule "ws" subtype=method negate=
    rx850_cur."!cursor_pos"(rx850_pos)
    $P10 = rx850_cur."ws"()
    unless $P10, rx850_fail
    rx850_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx850_cur."!cursor_pos"(rx850_pos)
    $P10 = rx850_cur."parameter"()
    unless $P10, rx850_fail
    rx850_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx850_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx850_cur."!cursor_pos"(rx850_pos)
    $P10 = rx850_cur."ws"()
    unless $P10, rx850_fail
    rx850_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx850_pos, 1
    gt $I11, rx850_eos, rx850_fail
    sub $I11, rx850_pos, rx850_off
    ord $I11, rx850_tgt, $I11
    ne $I11, 58, rx850_fail
    add rx850_pos, 1
    set_addr $I10, rxquantr854_done
    (rx850_rep) = rx850_cur."!mark_commit"($I10)
  rxquantr854_done:
.annotate 'line', 390
  # rx rxquantr861 ** 0..1
    set_addr $I10, rxquantr861_done
    rx850_cur."!mark_push"(0, rx850_pos, $I10)
  rxquantr861_loop:
  # rx rxquantr862 ** 1..*
    set_addr $I10, rxquantr862_done
    rx850_cur."!mark_push"(0, -1, $I10)
  rxquantr862_loop:
  # rx subrule "ws" subtype=method negate=
    rx850_cur."!cursor_pos"(rx850_pos)
    $P10 = rx850_cur."ws"()
    unless $P10, rx850_fail
    rx850_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx850_cur."!cursor_pos"(rx850_pos)
    $P10 = rx850_cur."parameter"()
    unless $P10, rx850_fail
    rx850_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx850_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx850_cur."!cursor_pos"(rx850_pos)
    $P10 = rx850_cur."ws"()
    unless $P10, rx850_fail
    rx850_pos = $P10."pos"()
    set_addr $I10, rxquantr862_done
    (rx850_rep) = rx850_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr862_done
    rx850_cur."!mark_push"(rx850_rep, rx850_pos, $I10)
  # rx literal  ","
    add $I11, rx850_pos, 1
    gt $I11, rx850_eos, rx850_fail
    sub $I11, rx850_pos, rx850_off
    ord $I11, rx850_tgt, $I11
    ne $I11, 44, rx850_fail
    add rx850_pos, 1
    goto rxquantr862_loop
  rxquantr862_done:
    set_addr $I10, rxquantr861_done
    (rx850_rep) = rx850_cur."!mark_commit"($I10)
  rxquantr861_done:
.annotate 'line', 388
  # rx pass
    rx850_cur."!cursor_pass"(rx850_pos, "signature")
    if_null rx850_debug, debug_743
    rx850_cur."!cursor_debug"("PASS", "signature", " at pos=", rx850_pos)
  debug_743:
    .return (rx850_cur)
  rx850_restart:
.annotate 'line', 4
    if_null rx850_debug, debug_744
    rx850_cur."!cursor_debug"("NEXT", "signature")
  debug_744:
  rx850_fail:
    (rx850_rep, rx850_pos, $I10, $P10) = rx850_cur."!mark_fail"(0)
    lt rx850_pos, -1, rx850_done
    eq rx850_pos, -1, rx850_fail
    jump $I10
  rx850_done:
    rx850_cur."!cursor_fail"()
    if_null rx850_debug, debug_745
    rx850_cur."!cursor_debug"("FAIL", "signature")
  debug_745:
    .return (rx850_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("184_1295994649.593") :method
.annotate 'line', 4
    new $P852, "ResizablePMCArray"
    push $P852, ""
    .return ($P852)
.end


.namespace ["NQP";"Grammar"]
.sub "_block857"  :anon :subid("185_1295994649.593") :outer("183_1295994649.593")
.annotate 'line', 389
    find_dynamic_lex $P859, "$*INVOCANT_OK"
    unless_null $P859, vivify_741
    get_hll_global $P859, "$INVOCANT_OK"
    unless_null $P859, vivify_742
    die "Contextual $*INVOCANT_OK not found"
  vivify_742:
  vivify_741:
    .return ($P859)
.end


.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("186_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx864_tgt
    .local int rx864_pos
    .local int rx864_off
    .local int rx864_eos
    .local int rx864_rep
    .local pmc rx864_cur
    .local pmc rx864_debug
    (rx864_cur, rx864_pos, rx864_tgt, $I10) = self."!cursor_start"()
    rx864_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx864_cur
    .local pmc match
    .lex "$/", match
    length rx864_eos, rx864_tgt
    gt rx864_pos, rx864_eos, rx864_done
    set rx864_off, 0
    lt rx864_pos, 2, rx864_start
    sub rx864_off, rx864_pos, 1
    substr rx864_tgt, rx864_tgt, rx864_off
  rx864_start:
    eq $I10, 1, rx864_restart
    if_null rx864_debug, debug_746
    rx864_cur."!cursor_debug"("START", "parameter")
  debug_746:
    $I10 = self.'from'()
    ne $I10, -1, rxscan867_done
    goto rxscan867_scan
  rxscan867_loop:
    ($P10) = rx864_cur."from"()
    inc $P10
    set rx864_pos, $P10
    ge rx864_pos, rx864_eos, rxscan867_done
  rxscan867_scan:
    set_addr $I10, rxscan867_loop
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  rxscan867_done:
.annotate 'line', 394
  # rx rxquantr868 ** 0..*
    set_addr $I10, rxquantr868_done
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  rxquantr868_loop:
  # rx subrule "typename" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."typename"()
    unless $P10, rx864_fail
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx864_pos = $P10."pos"()
  # rx rxquantr869 ** 0..1
    set_addr $I10, rxquantr869_done
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  rxquantr869_loop:
  # rx literal  ":"
    add $I11, rx864_pos, 1
    gt $I11, rx864_eos, rx864_fail
    sub $I11, rx864_pos, rx864_off
    ord $I11, rx864_tgt, $I11
    ne $I11, 58, rx864_fail
    add rx864_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_870_fail
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx864_pos, rx864_eos, rx864_fail
    sub $I10, rx864_pos, rx864_off
    substr $S10, rx864_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx864_fail
    inc rx864_pos
    set_addr $I10, rxcap_870_fail
    ($I12, $I11) = rx864_cur."!mark_peek"($I10)
    rx864_cur."!cursor_pos"($I11)
    ($P10) = rx864_cur."!cursor_start"()
    $P10."!cursor_pass"(rx864_pos, "")
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_870_done
  rxcap_870_fail:
    goto rx864_fail
  rxcap_870_done:
    set_addr $I10, rxquantr869_done
    (rx864_rep) = rx864_cur."!mark_commit"($I10)
  rxquantr869_done:
  # rx subrule "ws" subtype=method negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."ws"()
    unless $P10, rx864_fail
    rx864_pos = $P10."pos"()
    set_addr $I10, rxquantr868_done
    (rx864_rep) = rx864_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr868_done
    rx864_cur."!mark_push"(rx864_rep, rx864_pos, $I10)
    goto rxquantr868_loop
  rxquantr868_done:
  alt871_0:
.annotate 'line', 395
    set_addr $I10, alt871_1
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
.annotate 'line', 396
  # rx subcapture "quant"
    set_addr $I10, rxcap_872_fail
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx literal  "*"
    add $I11, rx864_pos, 1
    gt $I11, rx864_eos, rx864_fail
    sub $I11, rx864_pos, rx864_off
    ord $I11, rx864_tgt, $I11
    ne $I11, 42, rx864_fail
    add rx864_pos, 1
    set_addr $I10, rxcap_872_fail
    ($I12, $I11) = rx864_cur."!mark_peek"($I10)
    rx864_cur."!cursor_pos"($I11)
    ($P10) = rx864_cur."!cursor_start"()
    $P10."!cursor_pass"(rx864_pos, "")
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_872_done
  rxcap_872_fail:
    goto rx864_fail
  rxcap_872_done:
  # rx subrule "param_var" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."param_var"()
    unless $P10, rx864_fail
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx864_pos = $P10."pos"()
    goto alt871_end
  alt871_1:
  alt873_0:
.annotate 'line', 397
    set_addr $I10, alt873_1
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."param_var"()
    unless $P10, rx864_fail
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx864_pos = $P10."pos"()
    goto alt873_end
  alt873_1:
  # rx subrule "named_param" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."named_param"()
    unless $P10, rx864_fail
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx864_pos = $P10."pos"()
  alt873_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_875_fail
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  alt874_0:
    set_addr $I10, alt874_1
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx literal  "?"
    add $I11, rx864_pos, 1
    gt $I11, rx864_eos, rx864_fail
    sub $I11, rx864_pos, rx864_off
    ord $I11, rx864_tgt, $I11
    ne $I11, 63, rx864_fail
    add rx864_pos, 1
    goto alt874_end
  alt874_1:
    set_addr $I10, alt874_2
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  # rx literal  "!"
    add $I11, rx864_pos, 1
    gt $I11, rx864_eos, rx864_fail
    sub $I11, rx864_pos, rx864_off
    ord $I11, rx864_tgt, $I11
    ne $I11, 33, rx864_fail
    add rx864_pos, 1
    goto alt874_end
  alt874_2:
  alt874_end:
    set_addr $I10, rxcap_875_fail
    ($I12, $I11) = rx864_cur."!mark_peek"($I10)
    rx864_cur."!cursor_pos"($I11)
    ($P10) = rx864_cur."!cursor_start"()
    $P10."!cursor_pass"(rx864_pos, "")
    rx864_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_875_done
  rxcap_875_fail:
    goto rx864_fail
  rxcap_875_done:
  alt871_end:
.annotate 'line', 399
  # rx rxquantr876 ** 0..1
    set_addr $I10, rxquantr876_done
    rx864_cur."!mark_push"(0, rx864_pos, $I10)
  rxquantr876_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx864_cur."!cursor_pos"(rx864_pos)
    $P10 = rx864_cur."default_value"()
    unless $P10, rx864_fail
    goto rxsubrule877_pass
  rxsubrule877_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx864_fail
  rxsubrule877_pass:
    set_addr $I10, rxsubrule877_back
    rx864_cur."!mark_push"(0, rx864_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx864_pos = $P10."pos"()
    set_addr $I10, rxquantr876_done
    (rx864_rep) = rx864_cur."!mark_commit"($I10)
  rxquantr876_done:
.annotate 'line', 393
  # rx pass
    rx864_cur."!cursor_pass"(rx864_pos, "parameter")
    if_null rx864_debug, debug_747
    rx864_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx864_pos)
  debug_747:
    .return (rx864_cur)
  rx864_restart:
.annotate 'line', 4
    if_null rx864_debug, debug_748
    rx864_cur."!cursor_debug"("NEXT", "parameter")
  debug_748:
  rx864_fail:
    (rx864_rep, rx864_pos, $I10, $P10) = rx864_cur."!mark_fail"(0)
    lt rx864_pos, -1, rx864_done
    eq rx864_pos, -1, rx864_fail
    jump $I10
  rx864_done:
    rx864_cur."!cursor_fail"()
    if_null rx864_debug, debug_749
    rx864_cur."!cursor_debug"("FAIL", "parameter")
  debug_749:
    .return (rx864_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("187_1295994649.593") :method
.annotate 'line', 4
    new $P866, "ResizablePMCArray"
    push $P866, ""
    .return ($P866)
.end


.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("188_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx879_tgt
    .local int rx879_pos
    .local int rx879_off
    .local int rx879_eos
    .local int rx879_rep
    .local pmc rx879_cur
    .local pmc rx879_debug
    (rx879_cur, rx879_pos, rx879_tgt, $I10) = self."!cursor_start"()
    rx879_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx879_cur
    .local pmc match
    .lex "$/", match
    length rx879_eos, rx879_tgt
    gt rx879_pos, rx879_eos, rx879_done
    set rx879_off, 0
    lt rx879_pos, 2, rx879_start
    sub rx879_off, rx879_pos, 1
    substr rx879_tgt, rx879_tgt, rx879_off
  rx879_start:
    eq $I10, 1, rx879_restart
    if_null rx879_debug, debug_750
    rx879_cur."!cursor_debug"("START", "param_var")
  debug_750:
    $I10 = self.'from'()
    ne $I10, -1, rxscan883_done
    goto rxscan883_scan
  rxscan883_loop:
    ($P10) = rx879_cur."from"()
    inc $P10
    set rx879_pos, $P10
    ge rx879_pos, rx879_eos, rxscan883_done
  rxscan883_scan:
    set_addr $I10, rxscan883_loop
    rx879_cur."!mark_push"(0, rx879_pos, $I10)
  rxscan883_done:
.annotate 'line', 403
  # rx subrule "sigil" subtype=capture negate=
    rx879_cur."!cursor_pos"(rx879_pos)
    $P10 = rx879_cur."sigil"()
    unless $P10, rx879_fail
    rx879_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx879_pos = $P10."pos"()
  # rx rxquantr884 ** 0..1
    set_addr $I10, rxquantr884_done
    rx879_cur."!mark_push"(0, rx879_pos, $I10)
  rxquantr884_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx879_cur."!cursor_pos"(rx879_pos)
    $P10 = rx879_cur."twigil"()
    unless $P10, rx879_fail
    goto rxsubrule885_pass
  rxsubrule885_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx879_fail
  rxsubrule885_pass:
    set_addr $I10, rxsubrule885_back
    rx879_cur."!mark_push"(0, rx879_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx879_pos = $P10."pos"()
    set_addr $I10, rxquantr884_done
    (rx879_rep) = rx879_cur."!mark_commit"($I10)
  rxquantr884_done:
  alt886_0:
.annotate 'line', 404
    set_addr $I10, alt886_1
    rx879_cur."!mark_push"(0, rx879_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx879_cur."!cursor_pos"(rx879_pos)
    $P10 = rx879_cur."ident"()
    unless $P10, rx879_fail
    rx879_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx879_pos = $P10."pos"()
    goto alt886_end
  alt886_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_887_fail
    rx879_cur."!mark_push"(0, rx879_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx879_pos, rx879_eos, rx879_fail
    sub $I10, rx879_pos, rx879_off
    substr $S10, rx879_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx879_fail
    inc rx879_pos
    set_addr $I10, rxcap_887_fail
    ($I12, $I11) = rx879_cur."!mark_peek"($I10)
    rx879_cur."!cursor_pos"($I11)
    ($P10) = rx879_cur."!cursor_start"()
    $P10."!cursor_pass"(rx879_pos, "")
    rx879_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_887_done
  rxcap_887_fail:
    goto rx879_fail
  rxcap_887_done:
  alt886_end:
.annotate 'line', 402
  # rx pass
    rx879_cur."!cursor_pass"(rx879_pos, "param_var")
    if_null rx879_debug, debug_751
    rx879_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx879_pos)
  debug_751:
    .return (rx879_cur)
  rx879_restart:
.annotate 'line', 4
    if_null rx879_debug, debug_752
    rx879_cur."!cursor_debug"("NEXT", "param_var")
  debug_752:
  rx879_fail:
    (rx879_rep, rx879_pos, $I10, $P10) = rx879_cur."!mark_fail"(0)
    lt rx879_pos, -1, rx879_done
    eq rx879_pos, -1, rx879_fail
    jump $I10
  rx879_done:
    rx879_cur."!cursor_fail"()
    if_null rx879_debug, debug_753
    rx879_cur."!cursor_debug"("FAIL", "param_var")
  debug_753:
    .return (rx879_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("189_1295994649.593") :method
.annotate 'line', 4
    $P881 = self."!PREFIX__!subrule"("sigil", "")
    new $P882, "ResizablePMCArray"
    push $P882, $P881
    .return ($P882)
.end


.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("190_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx889_tgt
    .local int rx889_pos
    .local int rx889_off
    .local int rx889_eos
    .local int rx889_rep
    .local pmc rx889_cur
    .local pmc rx889_debug
    (rx889_cur, rx889_pos, rx889_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx889_cur
    .local pmc match
    .lex "$/", match
    length rx889_eos, rx889_tgt
    gt rx889_pos, rx889_eos, rx889_done
    set rx889_off, 0
    lt rx889_pos, 2, rx889_start
    sub rx889_off, rx889_pos, 1
    substr rx889_tgt, rx889_tgt, rx889_off
  rx889_start:
    eq $I10, 1, rx889_restart
    if_null rx889_debug, debug_754
    rx889_cur."!cursor_debug"("START", "named_param")
  debug_754:
    $I10 = self.'from'()
    ne $I10, -1, rxscan893_done
    goto rxscan893_scan
  rxscan893_loop:
    ($P10) = rx889_cur."from"()
    inc $P10
    set rx889_pos, $P10
    ge rx889_pos, rx889_eos, rxscan893_done
  rxscan893_scan:
    set_addr $I10, rxscan893_loop
    rx889_cur."!mark_push"(0, rx889_pos, $I10)
  rxscan893_done:
.annotate 'line', 408
  # rx literal  ":"
    add $I11, rx889_pos, 1
    gt $I11, rx889_eos, rx889_fail
    sub $I11, rx889_pos, rx889_off
    ord $I11, rx889_tgt, $I11
    ne $I11, 58, rx889_fail
    add rx889_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."param_var"()
    unless $P10, rx889_fail
    rx889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx889_pos = $P10."pos"()
.annotate 'line', 407
  # rx pass
    rx889_cur."!cursor_pass"(rx889_pos, "named_param")
    if_null rx889_debug, debug_755
    rx889_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx889_pos)
  debug_755:
    .return (rx889_cur)
  rx889_restart:
.annotate 'line', 4
    if_null rx889_debug, debug_756
    rx889_cur."!cursor_debug"("NEXT", "named_param")
  debug_756:
  rx889_fail:
    (rx889_rep, rx889_pos, $I10, $P10) = rx889_cur."!mark_fail"(0)
    lt rx889_pos, -1, rx889_done
    eq rx889_pos, -1, rx889_fail
    jump $I10
  rx889_done:
    rx889_cur."!cursor_fail"()
    if_null rx889_debug, debug_757
    rx889_cur."!cursor_debug"("FAIL", "named_param")
  debug_757:
    .return (rx889_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("191_1295994649.593") :method
.annotate 'line', 4
    $P891 = self."!PREFIX__!subrule"("param_var", ":")
    new $P892, "ResizablePMCArray"
    push $P892, $P891
    .return ($P892)
.end


.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("192_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx895_tgt
    .local int rx895_pos
    .local int rx895_off
    .local int rx895_eos
    .local int rx895_rep
    .local pmc rx895_cur
    .local pmc rx895_debug
    (rx895_cur, rx895_pos, rx895_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx895_cur
    .local pmc match
    .lex "$/", match
    length rx895_eos, rx895_tgt
    gt rx895_pos, rx895_eos, rx895_done
    set rx895_off, 0
    lt rx895_pos, 2, rx895_start
    sub rx895_off, rx895_pos, 1
    substr rx895_tgt, rx895_tgt, rx895_off
  rx895_start:
    eq $I10, 1, rx895_restart
    if_null rx895_debug, debug_758
    rx895_cur."!cursor_debug"("START", "default_value")
  debug_758:
    $I10 = self.'from'()
    ne $I10, -1, rxscan899_done
    goto rxscan899_scan
  rxscan899_loop:
    ($P10) = rx895_cur."from"()
    inc $P10
    set rx895_pos, $P10
    ge rx895_pos, rx895_eos, rxscan899_done
  rxscan899_scan:
    set_addr $I10, rxscan899_loop
    rx895_cur."!mark_push"(0, rx895_pos, $I10)
  rxscan899_done:
.annotate 'line', 411
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx895_pos, 1
    gt $I11, rx895_eos, rx895_fail
    sub $I11, rx895_pos, rx895_off
    ord $I11, rx895_tgt, $I11
    ne $I11, 61, rx895_fail
    add rx895_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."EXPR"("i=")
    unless $P10, rx895_fail
    rx895_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx895_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx895_cur."!cursor_pos"(rx895_pos)
    $P10 = rx895_cur."ws"()
    unless $P10, rx895_fail
    rx895_pos = $P10."pos"()
  # rx pass
    rx895_cur."!cursor_pass"(rx895_pos, "default_value")
    if_null rx895_debug, debug_759
    rx895_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx895_pos)
  debug_759:
    .return (rx895_cur)
  rx895_restart:
.annotate 'line', 4
    if_null rx895_debug, debug_760
    rx895_cur."!cursor_debug"("NEXT", "default_value")
  debug_760:
  rx895_fail:
    (rx895_rep, rx895_pos, $I10, $P10) = rx895_cur."!mark_fail"(0)
    lt rx895_pos, -1, rx895_done
    eq rx895_pos, -1, rx895_fail
    jump $I10
  rx895_done:
    rx895_cur."!cursor_fail"()
    if_null rx895_debug, debug_761
    rx895_cur."!cursor_debug"("FAIL", "default_value")
  debug_761:
    .return (rx895_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("193_1295994649.593") :method
.annotate 'line', 4
    $P897 = self."!PREFIX__!subrule"("ws", "")
    new $P898, "ResizablePMCArray"
    push $P898, $P897
    .return ($P898)
.end


.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("194_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx904_tgt
    .local int rx904_pos
    .local int rx904_off
    .local int rx904_eos
    .local int rx904_rep
    .local pmc rx904_cur
    .local pmc rx904_debug
    (rx904_cur, rx904_pos, rx904_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx904_cur
    .local pmc match
    .lex "$/", match
    length rx904_eos, rx904_tgt
    gt rx904_pos, rx904_eos, rx904_done
    set rx904_off, 0
    lt rx904_pos, 2, rx904_start
    sub rx904_off, rx904_pos, 1
    substr rx904_tgt, rx904_tgt, rx904_off
  rx904_start:
    eq $I10, 1, rx904_restart
    if_null rx904_debug, debug_762
    rx904_cur."!cursor_debug"("START", "trait")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan908_done
    goto rxscan908_scan
  rxscan908_loop:
    ($P10) = rx904_cur."from"()
    inc $P10
    set rx904_pos, $P10
    ge rx904_pos, rx904_eos, rxscan908_done
  rxscan908_scan:
    set_addr $I10, rxscan908_loop
    rx904_cur."!mark_push"(0, rx904_pos, $I10)
  rxscan908_done:
.annotate 'line', 413
  # rx subrule "ws" subtype=method negate=
    rx904_cur."!cursor_pos"(rx904_pos)
    $P10 = rx904_cur."ws"()
    unless $P10, rx904_fail
    rx904_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx904_cur."!cursor_pos"(rx904_pos)
    $P10 = rx904_cur."trait_mod"()
    unless $P10, rx904_fail
    rx904_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx904_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx904_cur."!cursor_pos"(rx904_pos)
    $P10 = rx904_cur."ws"()
    unless $P10, rx904_fail
    rx904_pos = $P10."pos"()
  # rx pass
    rx904_cur."!cursor_pass"(rx904_pos, "trait")
    if_null rx904_debug, debug_763
    rx904_cur."!cursor_debug"("PASS", "trait", " at pos=", rx904_pos)
  debug_763:
    .return (rx904_cur)
  rx904_restart:
.annotate 'line', 4
    if_null rx904_debug, debug_764
    rx904_cur."!cursor_debug"("NEXT", "trait")
  debug_764:
  rx904_fail:
    (rx904_rep, rx904_pos, $I10, $P10) = rx904_cur."!mark_fail"(0)
    lt rx904_pos, -1, rx904_done
    eq rx904_pos, -1, rx904_fail
    jump $I10
  rx904_done:
    rx904_cur."!cursor_fail"()
    if_null rx904_debug, debug_765
    rx904_cur."!cursor_debug"("FAIL", "trait")
  debug_765:
    .return (rx904_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("195_1295994649.593") :method
.annotate 'line', 4
    $P906 = self."!PREFIX__!subrule"("ws", "")
    new $P907, "ResizablePMCArray"
    push $P907, $P906
    .return ($P907)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("196_1295994649.593")
    .param pmc param_912
.annotate 'line', 415
    .lex "self", param_912
    $P913 = param_912."!protoregex"("trait_mod")
    .return ($P913)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("197_1295994649.593")
    .param pmc param_915
.annotate 'line', 415
    .lex "self", param_915
    $P916 = param_915."!PREFIX__!protoregex"("trait_mod")
    .return ($P916)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("198_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx918_tgt
    .local int rx918_pos
    .local int rx918_off
    .local int rx918_eos
    .local int rx918_rep
    .local pmc rx918_cur
    .local pmc rx918_debug
    (rx918_cur, rx918_pos, rx918_tgt, $I10) = self."!cursor_start"()
    rx918_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx918_cur
    .local pmc match
    .lex "$/", match
    length rx918_eos, rx918_tgt
    gt rx918_pos, rx918_eos, rx918_done
    set rx918_off, 0
    lt rx918_pos, 2, rx918_start
    sub rx918_off, rx918_pos, 1
    substr rx918_tgt, rx918_tgt, rx918_off
  rx918_start:
    eq $I10, 1, rx918_restart
    if_null rx918_debug, debug_766
    rx918_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan922_done
    goto rxscan922_scan
  rxscan922_loop:
    ($P10) = rx918_cur."from"()
    inc $P10
    set rx918_pos, $P10
    ge rx918_pos, rx918_eos, rxscan922_done
  rxscan922_scan:
    set_addr $I10, rxscan922_loop
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  rxscan922_done:
.annotate 'line', 416
  # rx subcapture "sym"
    set_addr $I10, rxcap_923_fail
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  # rx literal  "is"
    add $I11, rx918_pos, 2
    gt $I11, rx918_eos, rx918_fail
    sub $I11, rx918_pos, rx918_off
    substr $S10, rx918_tgt, $I11, 2
    ne $S10, "is", rx918_fail
    add rx918_pos, 2
    set_addr $I10, rxcap_923_fail
    ($I12, $I11) = rx918_cur."!mark_peek"($I10)
    rx918_cur."!cursor_pos"($I11)
    ($P10) = rx918_cur."!cursor_start"()
    $P10."!cursor_pass"(rx918_pos, "")
    rx918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_923_done
  rxcap_923_fail:
    goto rx918_fail
  rxcap_923_done:
  # rx subrule "ws" subtype=method negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."ws"()
    unless $P10, rx918_fail
    rx918_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."deflongname"()
    unless $P10, rx918_fail
    rx918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx918_pos = $P10."pos"()
  # rx rxquantr925 ** 0..1
    set_addr $I10, rxquantr925_done
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  rxquantr925_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."circumfix"()
    unless $P10, rx918_fail
    goto rxsubrule926_pass
  rxsubrule926_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx918_fail
  rxsubrule926_pass:
    set_addr $I10, rxsubrule926_back
    rx918_cur."!mark_push"(0, rx918_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx918_pos = $P10."pos"()
    set_addr $I10, rxquantr925_done
    (rx918_rep) = rx918_cur."!mark_commit"($I10)
  rxquantr925_done:
  # rx subrule "ws" subtype=method negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."ws"()
    unless $P10, rx918_fail
    rx918_pos = $P10."pos"()
  # rx pass
    rx918_cur."!cursor_pass"(rx918_pos, "trait_mod:sym<is>")
    if_null rx918_debug, debug_767
    rx918_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx918_pos)
  debug_767:
    .return (rx918_cur)
  rx918_restart:
.annotate 'line', 4
    if_null rx918_debug, debug_768
    rx918_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_768:
  rx918_fail:
    (rx918_rep, rx918_pos, $I10, $P10) = rx918_cur."!mark_fail"(0)
    lt rx918_pos, -1, rx918_done
    eq rx918_pos, -1, rx918_fail
    jump $I10
  rx918_done:
    rx918_cur."!cursor_fail"()
    if_null rx918_debug, debug_769
    rx918_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_769:
    .return (rx918_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("199_1295994649.593") :method
.annotate 'line', 4
    $P920 = self."!PREFIX__!subrule"("ws", "is")
    new $P921, "ResizablePMCArray"
    push $P921, $P920
    .return ($P921)
.end


.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("200_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx929_tgt
    .local int rx929_pos
    .local int rx929_off
    .local int rx929_eos
    .local int rx929_rep
    .local pmc rx929_cur
    .local pmc rx929_debug
    (rx929_cur, rx929_pos, rx929_tgt, $I10) = self."!cursor_start"()
    rx929_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx929_cur
    .local pmc match
    .lex "$/", match
    length rx929_eos, rx929_tgt
    gt rx929_pos, rx929_eos, rx929_done
    set rx929_off, 0
    lt rx929_pos, 2, rx929_start
    sub rx929_off, rx929_pos, 1
    substr rx929_tgt, rx929_tgt, rx929_off
  rx929_start:
    eq $I10, 1, rx929_restart
    if_null rx929_debug, debug_770
    rx929_cur."!cursor_debug"("START", "regex_declarator")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan933_done
    goto rxscan933_scan
  rxscan933_loop:
    ($P10) = rx929_cur."from"()
    inc $P10
    set rx929_pos, $P10
    ge rx929_pos, rx929_eos, rxscan933_done
  rxscan933_scan:
    set_addr $I10, rxscan933_loop
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  rxscan933_done:
.annotate 'line', 418
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  alt935_0:
.annotate 'line', 419
    set_addr $I10, alt935_1
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
.annotate 'line', 420
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_937_fail
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  # rx literal  "proto"
    add $I11, rx929_pos, 5
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 5
    ne $S10, "proto", rx929_fail
    add rx929_pos, 5
    set_addr $I10, rxcap_937_fail
    ($I12, $I11) = rx929_cur."!mark_peek"($I10)
    rx929_cur."!cursor_pos"($I11)
    ($P10) = rx929_cur."!cursor_start"()
    $P10."!cursor_pass"(rx929_pos, "")
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_937_done
  rxcap_937_fail:
    goto rx929_fail
  rxcap_937_done:
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  alt939_0:
    set_addr $I10, alt939_1
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  # rx literal  "regex"
    add $I11, rx929_pos, 5
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 5
    ne $S10, "regex", rx929_fail
    add rx929_pos, 5
    goto alt939_end
  alt939_1:
    set_addr $I10, alt939_2
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  # rx literal  "token"
    add $I11, rx929_pos, 5
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 5
    ne $S10, "token", rx929_fail
    add rx929_pos, 5
    goto alt939_end
  alt939_2:
  # rx literal  "rule"
    add $I11, rx929_pos, 4
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 4
    ne $S10, "rule", rx929_fail
    add rx929_pos, 4
  alt939_end:
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
.annotate 'line', 421
  # rx subrule "deflongname" subtype=capture negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."deflongname"()
    unless $P10, rx929_fail
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx929_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  alt942_0:
.annotate 'line', 422
    set_addr $I10, alt942_1
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx929_pos, 1
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    ord $I11, rx929_tgt, $I11
    ne $I11, 123, rx929_fail
    add rx929_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx929_pos, 5
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 5
    ne $S10, "<...>", rx929_fail
    add rx929_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx929_pos, 1
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    ord $I11, rx929_tgt, $I11
    ne $I11, 125, rx929_fail
    add rx929_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ENDSTMT"()
    unless $P10, rx929_fail
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
    goto alt942_end
  alt942_1:
.annotate 'line', 424
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."panic"("Proto regex body must be <...>")
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  alt942_end:
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
.annotate 'line', 420
    goto alt935_end
  alt935_1:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_952_fail
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  alt951_0:
    set_addr $I10, alt951_1
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  # rx literal  "regex"
    add $I11, rx929_pos, 5
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 5
    ne $S10, "regex", rx929_fail
    add rx929_pos, 5
    goto alt951_end
  alt951_1:
    set_addr $I10, alt951_2
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  # rx literal  "token"
    add $I11, rx929_pos, 5
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 5
    ne $S10, "token", rx929_fail
    add rx929_pos, 5
    goto alt951_end
  alt951_2:
  # rx literal  "rule"
    add $I11, rx929_pos, 4
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    substr $S10, rx929_tgt, $I11, 4
    ne $S10, "rule", rx929_fail
    add rx929_pos, 4
  alt951_end:
    set_addr $I10, rxcap_952_fail
    ($I12, $I11) = rx929_cur."!mark_peek"($I10)
    rx929_cur."!cursor_pos"($I11)
    ($P10) = rx929_cur."!cursor_start"()
    $P10."!cursor_pass"(rx929_pos, "")
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_952_done
  rxcap_952_fail:
    goto rx929_fail
  rxcap_952_done:
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
.annotate 'line', 427
  # rx subrule "deflongname" subtype=capture negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."deflongname"()
    unless $P10, rx929_fail
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx929_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
.annotate 'line', 428
  # rx subrule "newpad" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."newpad"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
.annotate 'line', 429
  # rx rxquantr956 ** 0..1
    set_addr $I10, rxquantr956_done
    rx929_cur."!mark_push"(0, rx929_pos, $I10)
  rxquantr956_loop:
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx929_pos, 1
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    ord $I11, rx929_tgt, $I11
    ne $I11, 40, rx929_fail
    add rx929_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."signature"()
    unless $P10, rx929_fail
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx929_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx929_pos, 1
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    ord $I11, rx929_tgt, $I11
    ne $I11, 41, rx929_fail
    add rx929_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
    set_addr $I10, rxquantr956_done
    (rx929_rep) = rx929_cur."!mark_commit"($I10)
  rxquantr956_done:
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
.annotate 'line', 430
  # rx reduce name="regex_declarator" key="open"
    rx929_cur."!cursor_pos"(rx929_pos)
    rx929_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
.annotate 'line', 431
  # rx literal  "{"
    add $I11, rx929_pos, 1
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    ord $I11, rx929_tgt, $I11
    ne $I11, 123, rx929_fail
    add rx929_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."LANG"("Regex", "nibbler")
    unless $P10, rx929_fail
    rx929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx929_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx929_pos, 1
    gt $I11, rx929_eos, rx929_fail
    sub $I11, rx929_pos, rx929_off
    ord $I11, rx929_tgt, $I11
    ne $I11, 125, rx929_fail
    add rx929_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ENDSTMT"()
    unless $P10, rx929_fail
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
  alt935_end:
.annotate 'line', 432
  # rx subrule "ws" subtype=method negate=
    rx929_cur."!cursor_pos"(rx929_pos)
    $P10 = rx929_cur."ws"()
    unless $P10, rx929_fail
    rx929_pos = $P10."pos"()
.annotate 'line', 418
  # rx pass
    rx929_cur."!cursor_pass"(rx929_pos, "regex_declarator")
    if_null rx929_debug, debug_771
    rx929_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx929_pos)
  debug_771:
    .return (rx929_cur)
  rx929_restart:
.annotate 'line', 4
    if_null rx929_debug, debug_772
    rx929_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_772:
  rx929_fail:
    (rx929_rep, rx929_pos, $I10, $P10) = rx929_cur."!mark_fail"(0)
    lt rx929_pos, -1, rx929_done
    eq rx929_pos, -1, rx929_fail
    jump $I10
  rx929_done:
    rx929_cur."!cursor_fail"()
    if_null rx929_debug, debug_773
    rx929_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_773:
    .return (rx929_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("201_1295994649.593") :method
.annotate 'line', 4
    $P931 = self."!PREFIX__!subrule"("ws", "")
    new $P932, "ResizablePMCArray"
    push $P932, $P931
    .return ($P932)
.end


.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("202_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx966_tgt
    .local int rx966_pos
    .local int rx966_off
    .local int rx966_eos
    .local int rx966_rep
    .local pmc rx966_cur
    .local pmc rx966_debug
    (rx966_cur, rx966_pos, rx966_tgt, $I10) = self."!cursor_start"()
    rx966_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx966_cur
    .local pmc match
    .lex "$/", match
    length rx966_eos, rx966_tgt
    gt rx966_pos, rx966_eos, rx966_done
    set rx966_off, 0
    lt rx966_pos, 2, rx966_start
    sub rx966_off, rx966_pos, 1
    substr rx966_tgt, rx966_tgt, rx966_off
  rx966_start:
    eq $I10, 1, rx966_restart
    if_null rx966_debug, debug_774
    rx966_cur."!cursor_debug"("START", "dotty")
  debug_774:
    $I10 = self.'from'()
    ne $I10, -1, rxscan970_done
    goto rxscan970_scan
  rxscan970_loop:
    ($P10) = rx966_cur."from"()
    inc $P10
    set rx966_pos, $P10
    ge rx966_pos, rx966_eos, rxscan970_done
  rxscan970_scan:
    set_addr $I10, rxscan970_loop
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  rxscan970_done:
.annotate 'line', 436
  # rx literal  "."
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 46, rx966_fail
    add rx966_pos, 1
  alt971_0:
.annotate 'line', 437
    set_addr $I10, alt971_1
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."deflongname"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx966_pos = $P10."pos"()
    goto alt971_end
  alt971_1:
.annotate 'line', 438
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx966_fail
  # rx subrule "quote" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."quote"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx966_pos = $P10."pos"()
  alt972_0:
.annotate 'line', 439
    set_addr $I10, alt972_1
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx966_fail
    goto alt972_end
  alt972_1:
  # rx subrule "panic" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  alt972_end:
  alt971_end:
.annotate 'line', 445
  # rx rxquantr973 ** 0..1
    set_addr $I10, rxquantr973_done
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  rxquantr973_loop:
  alt974_0:
.annotate 'line', 442
    set_addr $I10, alt974_1
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
.annotate 'line', 443
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx966_fail
  # rx subrule "args" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."args"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx966_pos = $P10."pos"()
    goto alt974_end
  alt974_1:
.annotate 'line', 444
  # rx literal  ":"
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 58, rx966_fail
    add rx966_pos, 1
  # rx charclass s
    ge rx966_pos, rx966_eos, rx966_fail
    sub $I10, rx966_pos, rx966_off
    is_cclass $I11, 32, rx966_tgt, $I10
    unless $I11, rx966_fail
    inc rx966_pos
  # rx subrule "arglist" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."arglist"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx966_pos = $P10."pos"()
  alt974_end:
.annotate 'line', 445
    set_addr $I10, rxquantr973_done
    (rx966_rep) = rx966_cur."!mark_commit"($I10)
  rxquantr973_done:
.annotate 'line', 435
  # rx pass
    rx966_cur."!cursor_pass"(rx966_pos, "dotty")
    if_null rx966_debug, debug_775
    rx966_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx966_pos)
  debug_775:
    .return (rx966_cur)
  rx966_restart:
.annotate 'line', 4
    if_null rx966_debug, debug_776
    rx966_cur."!cursor_debug"("NEXT", "dotty")
  debug_776:
  rx966_fail:
    (rx966_rep, rx966_pos, $I10, $P10) = rx966_cur."!mark_fail"(0)
    lt rx966_pos, -1, rx966_done
    eq rx966_pos, -1, rx966_fail
    jump $I10
  rx966_done:
    rx966_cur."!cursor_fail"()
    if_null rx966_debug, debug_777
    rx966_cur."!cursor_debug"("FAIL", "dotty")
  debug_777:
    .return (rx966_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("203_1295994649.593") :method
.annotate 'line', 4
    $P968 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P969, "ResizablePMCArray"
    push $P969, "'"
    push $P969, "\""
    push $P969, $P968
    .return ($P969)
.end


.namespace ["NQP";"Grammar"]
.sub "term"  :subid("204_1295994649.593")
    .param pmc param_976
.annotate 'line', 449
    .lex "self", param_976
    $P977 = param_976."!protoregex"("term")
    .return ($P977)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("205_1295994649.593")
    .param pmc param_979
.annotate 'line', 449
    .lex "self", param_979
    $P980 = param_979."!PREFIX__!protoregex"("term")
    .return ($P980)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("206_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx982_tgt
    .local int rx982_pos
    .local int rx982_off
    .local int rx982_eos
    .local int rx982_rep
    .local pmc rx982_cur
    .local pmc rx982_debug
    (rx982_cur, rx982_pos, rx982_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx982_cur
    .local pmc match
    .lex "$/", match
    length rx982_eos, rx982_tgt
    gt rx982_pos, rx982_eos, rx982_done
    set rx982_off, 0
    lt rx982_pos, 2, rx982_start
    sub rx982_off, rx982_pos, 1
    substr rx982_tgt, rx982_tgt, rx982_off
  rx982_start:
    eq $I10, 1, rx982_restart
    if_null rx982_debug, debug_778
    rx982_cur."!cursor_debug"("START", "term:sym<self>")
  debug_778:
    $I10 = self.'from'()
    ne $I10, -1, rxscan985_done
    goto rxscan985_scan
  rxscan985_loop:
    ($P10) = rx982_cur."from"()
    inc $P10
    set rx982_pos, $P10
    ge rx982_pos, rx982_eos, rxscan985_done
  rxscan985_scan:
    set_addr $I10, rxscan985_loop
    rx982_cur."!mark_push"(0, rx982_pos, $I10)
  rxscan985_done:
.annotate 'line', 451
  # rx subcapture "sym"
    set_addr $I10, rxcap_986_fail
    rx982_cur."!mark_push"(0, rx982_pos, $I10)
  # rx literal  "self"
    add $I11, rx982_pos, 4
    gt $I11, rx982_eos, rx982_fail
    sub $I11, rx982_pos, rx982_off
    substr $S10, rx982_tgt, $I11, 4
    ne $S10, "self", rx982_fail
    add rx982_pos, 4
    set_addr $I10, rxcap_986_fail
    ($I12, $I11) = rx982_cur."!mark_peek"($I10)
    rx982_cur."!cursor_pos"($I11)
    ($P10) = rx982_cur."!cursor_start"()
    $P10."!cursor_pass"(rx982_pos, "")
    rx982_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_986_done
  rxcap_986_fail:
    goto rx982_fail
  rxcap_986_done:
  # rxanchor rwb
    le rx982_pos, 0, rx982_fail
    sub $I10, rx982_pos, rx982_off
    is_cclass $I11, 8192, rx982_tgt, $I10
    if $I11, rx982_fail
    dec $I10
    is_cclass $I11, 8192, rx982_tgt, $I10
    unless $I11, rx982_fail
  # rx pass
    rx982_cur."!cursor_pass"(rx982_pos, "term:sym<self>")
    if_null rx982_debug, debug_779
    rx982_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx982_pos)
  debug_779:
    .return (rx982_cur)
  rx982_restart:
.annotate 'line', 4
    if_null rx982_debug, debug_780
    rx982_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_780:
  rx982_fail:
    (rx982_rep, rx982_pos, $I10, $P10) = rx982_cur."!mark_fail"(0)
    lt rx982_pos, -1, rx982_done
    eq rx982_pos, -1, rx982_fail
    jump $I10
  rx982_done:
    rx982_cur."!cursor_fail"()
    if_null rx982_debug, debug_781
    rx982_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_781:
    .return (rx982_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("207_1295994649.593") :method
.annotate 'line', 4
    new $P984, "ResizablePMCArray"
    push $P984, "self"
    .return ($P984)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("208_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx988_tgt
    .local int rx988_pos
    .local int rx988_off
    .local int rx988_eos
    .local int rx988_rep
    .local pmc rx988_cur
    .local pmc rx988_debug
    (rx988_cur, rx988_pos, rx988_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx988_cur
    .local pmc match
    .lex "$/", match
    length rx988_eos, rx988_tgt
    gt rx988_pos, rx988_eos, rx988_done
    set rx988_off, 0
    lt rx988_pos, 2, rx988_start
    sub rx988_off, rx988_pos, 1
    substr rx988_tgt, rx988_tgt, rx988_off
  rx988_start:
    eq $I10, 1, rx988_restart
    if_null rx988_debug, debug_782
    rx988_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_782:
    $I10 = self.'from'()
    ne $I10, -1, rxscan992_done
    goto rxscan992_scan
  rxscan992_loop:
    ($P10) = rx988_cur."from"()
    inc $P10
    set rx988_pos, $P10
    ge rx988_pos, rx988_eos, rxscan992_done
  rxscan992_scan:
    set_addr $I10, rxscan992_loop
    rx988_cur."!mark_push"(0, rx988_pos, $I10)
  rxscan992_done:
.annotate 'line', 454
  # rx subrule "deflongname" subtype=capture negate=
    rx988_cur."!cursor_pos"(rx988_pos)
    $P10 = rx988_cur."deflongname"()
    unless $P10, rx988_fail
    rx988_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx988_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx988_pos, rx988_off
    substr $S10, rx988_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx988_fail
  # rx subrule "args" subtype=capture negate=
    rx988_cur."!cursor_pos"(rx988_pos)
    $P10 = rx988_cur."args"()
    unless $P10, rx988_fail
    rx988_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx988_pos = $P10."pos"()
.annotate 'line', 453
  # rx pass
    rx988_cur."!cursor_pass"(rx988_pos, "term:sym<identifier>")
    if_null rx988_debug, debug_783
    rx988_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx988_pos)
  debug_783:
    .return (rx988_cur)
  rx988_restart:
.annotate 'line', 4
    if_null rx988_debug, debug_784
    rx988_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_784:
  rx988_fail:
    (rx988_rep, rx988_pos, $I10, $P10) = rx988_cur."!mark_fail"(0)
    lt rx988_pos, -1, rx988_done
    eq rx988_pos, -1, rx988_fail
    jump $I10
  rx988_done:
    rx988_cur."!cursor_fail"()
    if_null rx988_debug, debug_785
    rx988_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_785:
    .return (rx988_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("209_1295994649.593") :method
.annotate 'line', 4
    $P990 = self."!PREFIX__!subrule"("deflongname", "")
    new $P991, "ResizablePMCArray"
    push $P991, $P990
    .return ($P991)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("210_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx994_tgt
    .local int rx994_pos
    .local int rx994_off
    .local int rx994_eos
    .local int rx994_rep
    .local pmc rx994_cur
    .local pmc rx994_debug
    (rx994_cur, rx994_pos, rx994_tgt, $I10) = self."!cursor_start"()
    rx994_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx994_cur
    .local pmc match
    .lex "$/", match
    length rx994_eos, rx994_tgt
    gt rx994_pos, rx994_eos, rx994_done
    set rx994_off, 0
    lt rx994_pos, 2, rx994_start
    sub rx994_off, rx994_pos, 1
    substr rx994_tgt, rx994_tgt, rx994_off
  rx994_start:
    eq $I10, 1, rx994_restart
    if_null rx994_debug, debug_786
    rx994_cur."!cursor_debug"("START", "term:sym<name>")
  debug_786:
    $I10 = self.'from'()
    ne $I10, -1, rxscan998_done
    goto rxscan998_scan
  rxscan998_loop:
    ($P10) = rx994_cur."from"()
    inc $P10
    set rx994_pos, $P10
    ge rx994_pos, rx994_eos, rxscan998_done
  rxscan998_scan:
    set_addr $I10, rxscan998_loop
    rx994_cur."!mark_push"(0, rx994_pos, $I10)
  rxscan998_done:
.annotate 'line', 458
  # rx subrule "name" subtype=capture negate=
    rx994_cur."!cursor_pos"(rx994_pos)
    $P10 = rx994_cur."name"()
    unless $P10, rx994_fail
    rx994_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx994_pos = $P10."pos"()
  # rx rxquantr999 ** 0..1
    set_addr $I10, rxquantr999_done
    rx994_cur."!mark_push"(0, rx994_pos, $I10)
  rxquantr999_loop:
  # rx subrule "args" subtype=capture negate=
    rx994_cur."!cursor_pos"(rx994_pos)
    $P10 = rx994_cur."args"()
    unless $P10, rx994_fail
    goto rxsubrule1000_pass
  rxsubrule1000_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx994_fail
  rxsubrule1000_pass:
    set_addr $I10, rxsubrule1000_back
    rx994_cur."!mark_push"(0, rx994_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx994_pos = $P10."pos"()
    set_addr $I10, rxquantr999_done
    (rx994_rep) = rx994_cur."!mark_commit"($I10)
  rxquantr999_done:
.annotate 'line', 457
  # rx pass
    rx994_cur."!cursor_pass"(rx994_pos, "term:sym<name>")
    if_null rx994_debug, debug_787
    rx994_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx994_pos)
  debug_787:
    .return (rx994_cur)
  rx994_restart:
.annotate 'line', 4
    if_null rx994_debug, debug_788
    rx994_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_788:
  rx994_fail:
    (rx994_rep, rx994_pos, $I10, $P10) = rx994_cur."!mark_fail"(0)
    lt rx994_pos, -1, rx994_done
    eq rx994_pos, -1, rx994_fail
    jump $I10
  rx994_done:
    rx994_cur."!cursor_fail"()
    if_null rx994_debug, debug_789
    rx994_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_789:
    .return (rx994_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("211_1295994649.593") :method
.annotate 'line', 4
    $P996 = self."!PREFIX__!subrule"("name", "")
    new $P997, "ResizablePMCArray"
    push $P997, $P996
    .return ($P997)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("212_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1002_tgt
    .local int rx1002_pos
    .local int rx1002_off
    .local int rx1002_eos
    .local int rx1002_rep
    .local pmc rx1002_cur
    .local pmc rx1002_debug
    (rx1002_cur, rx1002_pos, rx1002_tgt, $I10) = self."!cursor_start"()
    rx1002_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1002_cur
    .local pmc match
    .lex "$/", match
    length rx1002_eos, rx1002_tgt
    gt rx1002_pos, rx1002_eos, rx1002_done
    set rx1002_off, 0
    lt rx1002_pos, 2, rx1002_start
    sub rx1002_off, rx1002_pos, 1
    substr rx1002_tgt, rx1002_tgt, rx1002_off
  rx1002_start:
    eq $I10, 1, rx1002_restart
    if_null rx1002_debug, debug_790
    rx1002_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_790:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1005_done
    goto rxscan1005_scan
  rxscan1005_loop:
    ($P10) = rx1002_cur."from"()
    inc $P10
    set rx1002_pos, $P10
    ge rx1002_pos, rx1002_eos, rxscan1005_done
  rxscan1005_scan:
    set_addr $I10, rxscan1005_loop
    rx1002_cur."!mark_push"(0, rx1002_pos, $I10)
  rxscan1005_done:
.annotate 'line', 462
  # rx literal  "pir::"
    add $I11, rx1002_pos, 5
    gt $I11, rx1002_eos, rx1002_fail
    sub $I11, rx1002_pos, rx1002_off
    substr $S10, rx1002_tgt, $I11, 5
    ne $S10, "pir::", rx1002_fail
    add rx1002_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1006_fail
    rx1002_cur."!mark_push"(0, rx1002_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1002_pos, rx1002_off
    find_not_cclass $I11, 8192, rx1002_tgt, $I10, rx1002_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1002_fail
    add rx1002_pos, rx1002_off, $I11
    set_addr $I10, rxcap_1006_fail
    ($I12, $I11) = rx1002_cur."!mark_peek"($I10)
    rx1002_cur."!cursor_pos"($I11)
    ($P10) = rx1002_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1002_pos, "")
    rx1002_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1006_done
  rxcap_1006_fail:
    goto rx1002_fail
  rxcap_1006_done:
  # rx rxquantr1007 ** 0..1
    set_addr $I10, rxquantr1007_done
    rx1002_cur."!mark_push"(0, rx1002_pos, $I10)
  rxquantr1007_loop:
  # rx subrule "args" subtype=capture negate=
    rx1002_cur."!cursor_pos"(rx1002_pos)
    $P10 = rx1002_cur."args"()
    unless $P10, rx1002_fail
    goto rxsubrule1008_pass
  rxsubrule1008_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1002_fail
  rxsubrule1008_pass:
    set_addr $I10, rxsubrule1008_back
    rx1002_cur."!mark_push"(0, rx1002_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1002_pos = $P10."pos"()
    set_addr $I10, rxquantr1007_done
    (rx1002_rep) = rx1002_cur."!mark_commit"($I10)
  rxquantr1007_done:
.annotate 'line', 461
  # rx pass
    rx1002_cur."!cursor_pass"(rx1002_pos, "term:sym<pir::op>")
    if_null rx1002_debug, debug_791
    rx1002_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1002_pos)
  debug_791:
    .return (rx1002_cur)
  rx1002_restart:
.annotate 'line', 4
    if_null rx1002_debug, debug_792
    rx1002_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_792:
  rx1002_fail:
    (rx1002_rep, rx1002_pos, $I10, $P10) = rx1002_cur."!mark_fail"(0)
    lt rx1002_pos, -1, rx1002_done
    eq rx1002_pos, -1, rx1002_fail
    jump $I10
  rx1002_done:
    rx1002_cur."!cursor_fail"()
    if_null rx1002_debug, debug_793
    rx1002_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_793:
    .return (rx1002_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("213_1295994649.593") :method
.annotate 'line', 4
    new $P1004, "ResizablePMCArray"
    push $P1004, "pir::"
    .return ($P1004)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("214_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P1018 = "216_1295994649.593" 
    capture_lex $P1018
    .local string rx1010_tgt
    .local int rx1010_pos
    .local int rx1010_off
    .local int rx1010_eos
    .local int rx1010_rep
    .local pmc rx1010_cur
    .local pmc rx1010_debug
    (rx1010_cur, rx1010_pos, rx1010_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1010_cur
    .local pmc match
    .lex "$/", match
    length rx1010_eos, rx1010_tgt
    gt rx1010_pos, rx1010_eos, rx1010_done
    set rx1010_off, 0
    lt rx1010_pos, 2, rx1010_start
    sub rx1010_off, rx1010_pos, 1
    substr rx1010_tgt, rx1010_tgt, rx1010_off
  rx1010_start:
    eq $I10, 1, rx1010_restart
    if_null rx1010_debug, debug_794
    rx1010_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1013_done
    goto rxscan1013_scan
  rxscan1013_loop:
    ($P10) = rx1010_cur."from"()
    inc $P10
    set rx1010_pos, $P10
    ge rx1010_pos, rx1010_eos, rxscan1013_done
  rxscan1013_scan:
    set_addr $I10, rxscan1013_loop
    rx1010_cur."!mark_push"(0, rx1010_pos, $I10)
  rxscan1013_done:
.annotate 'line', 466
  # rx literal  "{*}"
    add $I11, rx1010_pos, 3
    gt $I11, rx1010_eos, rx1010_fail
    sub $I11, rx1010_pos, rx1010_off
    substr $S10, rx1010_tgt, $I11, 3
    ne $S10, "{*}", rx1010_fail
    add rx1010_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1010_cur."!cursor_pos"(rx1010_pos)
    $P10 = rx1010_cur."ENDSTMT"()
    unless $P10, rx1010_fail
  alt1014_0:
.annotate 'line', 467
    set_addr $I10, alt1014_1
    rx1010_cur."!mark_push"(0, rx1010_pos, $I10)
    rx1010_cur."!cursor_pos"(rx1010_pos)
    find_lex $P1015, unicode:"$\x{a2}"
    $P1016 = $P1015."MATCH"()
    store_lex "$/", $P1016
    .const 'Sub' $P1018 = "216_1295994649.593" 
    capture_lex $P1018
    $P1022 = $P1018()
    unless $P1022, rx1010_fail
    goto alt1014_end
  alt1014_1:
  # rx subrule "panic" subtype=method negate=
    rx1010_cur."!cursor_pos"(rx1010_pos)
    $P10 = rx1010_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1010_fail
    rx1010_pos = $P10."pos"()
  alt1014_end:
.annotate 'line', 465
  # rx pass
    rx1010_cur."!cursor_pass"(rx1010_pos, "term:sym<onlystar>")
    if_null rx1010_debug, debug_797
    rx1010_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1010_pos)
  debug_797:
    .return (rx1010_cur)
  rx1010_restart:
.annotate 'line', 4
    if_null rx1010_debug, debug_798
    rx1010_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_798:
  rx1010_fail:
    (rx1010_rep, rx1010_pos, $I10, $P10) = rx1010_cur."!mark_fail"(0)
    lt rx1010_pos, -1, rx1010_done
    eq rx1010_pos, -1, rx1010_fail
    jump $I10
  rx1010_done:
    rx1010_cur."!cursor_fail"()
    if_null rx1010_debug, debug_799
    rx1010_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_799:
    .return (rx1010_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("215_1295994649.593") :method
.annotate 'line', 4
    new $P1012, "ResizablePMCArray"
    push $P1012, "{*}"
    .return ($P1012)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1017"  :anon :subid("216_1295994649.593") :outer("214_1295994649.593")
.annotate 'line', 467
    find_dynamic_lex $P1019, "$*MULTINESS"
    unless_null $P1019, vivify_795
    get_hll_global $P1019, "$MULTINESS"
    unless_null $P1019, vivify_796
    die "Contextual $*MULTINESS not found"
  vivify_796:
  vivify_795:
    set $S1020, $P1019
    iseq $I1021, $S1020, "proto"
    .return ($I1021)
.end


.namespace ["NQP";"Grammar"]
.sub "args"  :subid("217_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1024_tgt
    .local int rx1024_pos
    .local int rx1024_off
    .local int rx1024_eos
    .local int rx1024_rep
    .local pmc rx1024_cur
    .local pmc rx1024_debug
    (rx1024_cur, rx1024_pos, rx1024_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1024_cur
    .local pmc match
    .lex "$/", match
    length rx1024_eos, rx1024_tgt
    gt rx1024_pos, rx1024_eos, rx1024_done
    set rx1024_off, 0
    lt rx1024_pos, 2, rx1024_start
    sub rx1024_off, rx1024_pos, 1
    substr rx1024_tgt, rx1024_tgt, rx1024_off
  rx1024_start:
    eq $I10, 1, rx1024_restart
    if_null rx1024_debug, debug_800
    rx1024_cur."!cursor_debug"("START", "args")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1028_done
    goto rxscan1028_scan
  rxscan1028_loop:
    ($P10) = rx1024_cur."from"()
    inc $P10
    set rx1024_pos, $P10
    ge rx1024_pos, rx1024_eos, rxscan1028_done
  rxscan1028_scan:
    set_addr $I10, rxscan1028_loop
    rx1024_cur."!mark_push"(0, rx1024_pos, $I10)
  rxscan1028_done:
.annotate 'line', 471
  # rx literal  "("
    add $I11, rx1024_pos, 1
    gt $I11, rx1024_eos, rx1024_fail
    sub $I11, rx1024_pos, rx1024_off
    ord $I11, rx1024_tgt, $I11
    ne $I11, 40, rx1024_fail
    add rx1024_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1024_cur."!cursor_pos"(rx1024_pos)
    $P10 = rx1024_cur."arglist"()
    unless $P10, rx1024_fail
    rx1024_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1024_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1024_pos, 1
    gt $I11, rx1024_eos, rx1024_fail
    sub $I11, rx1024_pos, rx1024_off
    ord $I11, rx1024_tgt, $I11
    ne $I11, 41, rx1024_fail
    add rx1024_pos, 1
  # rx pass
    rx1024_cur."!cursor_pass"(rx1024_pos, "args")
    if_null rx1024_debug, debug_801
    rx1024_cur."!cursor_debug"("PASS", "args", " at pos=", rx1024_pos)
  debug_801:
    .return (rx1024_cur)
  rx1024_restart:
.annotate 'line', 4
    if_null rx1024_debug, debug_802
    rx1024_cur."!cursor_debug"("NEXT", "args")
  debug_802:
  rx1024_fail:
    (rx1024_rep, rx1024_pos, $I10, $P10) = rx1024_cur."!mark_fail"(0)
    lt rx1024_pos, -1, rx1024_done
    eq rx1024_pos, -1, rx1024_fail
    jump $I10
  rx1024_done:
    rx1024_cur."!cursor_fail"()
    if_null rx1024_debug, debug_803
    rx1024_cur."!cursor_debug"("FAIL", "args")
  debug_803:
    .return (rx1024_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("218_1295994649.593") :method
.annotate 'line', 4
    $P1026 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1027, "ResizablePMCArray"
    push $P1027, $P1026
    .return ($P1027)
.end


.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("219_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1030_tgt
    .local int rx1030_pos
    .local int rx1030_off
    .local int rx1030_eos
    .local int rx1030_rep
    .local pmc rx1030_cur
    .local pmc rx1030_debug
    (rx1030_cur, rx1030_pos, rx1030_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1030_cur
    .local pmc match
    .lex "$/", match
    length rx1030_eos, rx1030_tgt
    gt rx1030_pos, rx1030_eos, rx1030_done
    set rx1030_off, 0
    lt rx1030_pos, 2, rx1030_start
    sub rx1030_off, rx1030_pos, 1
    substr rx1030_tgt, rx1030_tgt, rx1030_off
  rx1030_start:
    eq $I10, 1, rx1030_restart
    if_null rx1030_debug, debug_804
    rx1030_cur."!cursor_debug"("START", "arglist")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1034_done
    goto rxscan1034_scan
  rxscan1034_loop:
    ($P10) = rx1030_cur."from"()
    inc $P10
    set rx1030_pos, $P10
    ge rx1030_pos, rx1030_eos, rxscan1034_done
  rxscan1034_scan:
    set_addr $I10, rxscan1034_loop
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxscan1034_done:
.annotate 'line', 475
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  alt1035_0:
.annotate 'line', 476
    set_addr $I10, alt1035_1
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
.annotate 'line', 477
  # rx subrule "EXPR" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."EXPR"("f=")
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1030_pos = $P10."pos"()
    goto alt1035_end
  alt1035_1:
  alt1035_end:
.annotate 'line', 474
  # rx pass
    rx1030_cur."!cursor_pass"(rx1030_pos, "arglist")
    if_null rx1030_debug, debug_805
    rx1030_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1030_pos)
  debug_805:
    .return (rx1030_cur)
  rx1030_restart:
.annotate 'line', 4
    if_null rx1030_debug, debug_806
    rx1030_cur."!cursor_debug"("NEXT", "arglist")
  debug_806:
  rx1030_fail:
    (rx1030_rep, rx1030_pos, $I10, $P10) = rx1030_cur."!mark_fail"(0)
    lt rx1030_pos, -1, rx1030_done
    eq rx1030_pos, -1, rx1030_fail
    jump $I10
  rx1030_done:
    rx1030_cur."!cursor_fail"()
    if_null rx1030_debug, debug_807
    rx1030_cur."!cursor_debug"("FAIL", "arglist")
  debug_807:
    .return (rx1030_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("220_1295994649.593") :method
.annotate 'line', 4
    $P1032 = self."!PREFIX__!subrule"("ws", "")
    new $P1033, "ResizablePMCArray"
    push $P1033, $P1032
    .return ($P1033)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("221_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1037_tgt
    .local int rx1037_pos
    .local int rx1037_off
    .local int rx1037_eos
    .local int rx1037_rep
    .local pmc rx1037_cur
    .local pmc rx1037_debug
    (rx1037_cur, rx1037_pos, rx1037_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1037_cur
    .local pmc match
    .lex "$/", match
    length rx1037_eos, rx1037_tgt
    gt rx1037_pos, rx1037_eos, rx1037_done
    set rx1037_off, 0
    lt rx1037_pos, 2, rx1037_start
    sub rx1037_off, rx1037_pos, 1
    substr rx1037_tgt, rx1037_tgt, rx1037_off
  rx1037_start:
    eq $I10, 1, rx1037_restart
    if_null rx1037_debug, debug_808
    rx1037_cur."!cursor_debug"("START", "term:sym<value>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1041_done
    goto rxscan1041_scan
  rxscan1041_loop:
    ($P10) = rx1037_cur."from"()
    inc $P10
    set rx1037_pos, $P10
    ge rx1037_pos, rx1037_eos, rxscan1041_done
  rxscan1041_scan:
    set_addr $I10, rxscan1041_loop
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  rxscan1041_done:
.annotate 'line', 483
  # rx subrule "value" subtype=capture negate=
    rx1037_cur."!cursor_pos"(rx1037_pos)
    $P10 = rx1037_cur."value"()
    unless $P10, rx1037_fail
    rx1037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1037_pos = $P10."pos"()
  # rx pass
    rx1037_cur."!cursor_pass"(rx1037_pos, "term:sym<value>")
    if_null rx1037_debug, debug_809
    rx1037_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1037_pos)
  debug_809:
    .return (rx1037_cur)
  rx1037_restart:
.annotate 'line', 4
    if_null rx1037_debug, debug_810
    rx1037_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_810:
  rx1037_fail:
    (rx1037_rep, rx1037_pos, $I10, $P10) = rx1037_cur."!mark_fail"(0)
    lt rx1037_pos, -1, rx1037_done
    eq rx1037_pos, -1, rx1037_fail
    jump $I10
  rx1037_done:
    rx1037_cur."!cursor_fail"()
    if_null rx1037_debug, debug_811
    rx1037_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_811:
    .return (rx1037_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("222_1295994649.593") :method
.annotate 'line', 4
    $P1039 = self."!PREFIX__!subrule"("value", "")
    new $P1040, "ResizablePMCArray"
    push $P1040, $P1039
    .return ($P1040)
.end


.namespace ["NQP";"Grammar"]
.sub "value"  :subid("223_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1043_tgt
    .local int rx1043_pos
    .local int rx1043_off
    .local int rx1043_eos
    .local int rx1043_rep
    .local pmc rx1043_cur
    .local pmc rx1043_debug
    (rx1043_cur, rx1043_pos, rx1043_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1043_cur
    .local pmc match
    .lex "$/", match
    length rx1043_eos, rx1043_tgt
    gt rx1043_pos, rx1043_eos, rx1043_done
    set rx1043_off, 0
    lt rx1043_pos, 2, rx1043_start
    sub rx1043_off, rx1043_pos, 1
    substr rx1043_tgt, rx1043_tgt, rx1043_off
  rx1043_start:
    eq $I10, 1, rx1043_restart
    if_null rx1043_debug, debug_812
    rx1043_cur."!cursor_debug"("START", "value")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1048_done
    goto rxscan1048_scan
  rxscan1048_loop:
    ($P10) = rx1043_cur."from"()
    inc $P10
    set rx1043_pos, $P10
    ge rx1043_pos, rx1043_eos, rxscan1048_done
  rxscan1048_scan:
    set_addr $I10, rxscan1048_loop
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10)
  rxscan1048_done:
  alt1049_0:
.annotate 'line', 485
    set_addr $I10, alt1049_1
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10)
.annotate 'line', 486
  # rx subrule "quote" subtype=capture negate=
    rx1043_cur."!cursor_pos"(rx1043_pos)
    $P10 = rx1043_cur."quote"()
    unless $P10, rx1043_fail
    rx1043_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1043_pos = $P10."pos"()
    goto alt1049_end
  alt1049_1:
.annotate 'line', 487
  # rx subrule "number" subtype=capture negate=
    rx1043_cur."!cursor_pos"(rx1043_pos)
    $P10 = rx1043_cur."number"()
    unless $P10, rx1043_fail
    rx1043_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1043_pos = $P10."pos"()
  alt1049_end:
.annotate 'line', 485
  # rx pass
    rx1043_cur."!cursor_pass"(rx1043_pos, "value")
    if_null rx1043_debug, debug_813
    rx1043_cur."!cursor_debug"("PASS", "value", " at pos=", rx1043_pos)
  debug_813:
    .return (rx1043_cur)
  rx1043_restart:
.annotate 'line', 4
    if_null rx1043_debug, debug_814
    rx1043_cur."!cursor_debug"("NEXT", "value")
  debug_814:
  rx1043_fail:
    (rx1043_rep, rx1043_pos, $I10, $P10) = rx1043_cur."!mark_fail"(0)
    lt rx1043_pos, -1, rx1043_done
    eq rx1043_pos, -1, rx1043_fail
    jump $I10
  rx1043_done:
    rx1043_cur."!cursor_fail"()
    if_null rx1043_debug, debug_815
    rx1043_cur."!cursor_debug"("FAIL", "value")
  debug_815:
    .return (rx1043_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("224_1295994649.593") :method
.annotate 'line', 4
    $P1045 = self."!PREFIX__!subrule"("number", "")
    $P1046 = self."!PREFIX__!subrule"("quote", "")
    new $P1047, "ResizablePMCArray"
    push $P1047, $P1045
    push $P1047, $P1046
    .return ($P1047)
.end


.namespace ["NQP";"Grammar"]
.sub "number"  :subid("225_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1051_tgt
    .local int rx1051_pos
    .local int rx1051_off
    .local int rx1051_eos
    .local int rx1051_rep
    .local pmc rx1051_cur
    .local pmc rx1051_debug
    (rx1051_cur, rx1051_pos, rx1051_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1051_cur
    .local pmc match
    .lex "$/", match
    length rx1051_eos, rx1051_tgt
    gt rx1051_pos, rx1051_eos, rx1051_done
    set rx1051_off, 0
    lt rx1051_pos, 2, rx1051_start
    sub rx1051_off, rx1051_pos, 1
    substr rx1051_tgt, rx1051_tgt, rx1051_off
  rx1051_start:
    eq $I10, 1, rx1051_restart
    if_null rx1051_debug, debug_816
    rx1051_cur."!cursor_debug"("START", "number")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1054_done
    goto rxscan1054_scan
  rxscan1054_loop:
    ($P10) = rx1051_cur."from"()
    inc $P10
    set rx1051_pos, $P10
    ge rx1051_pos, rx1051_eos, rxscan1054_done
  rxscan1054_scan:
    set_addr $I10, rxscan1054_loop
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
  rxscan1054_done:
.annotate 'line', 491
  # rx subcapture "sign"
    set_addr $I10, rxcap_1056_fail
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1051_pos, rx1051_off
    set rx1051_rep, 0
    sub $I12, rx1051_eos, rx1051_pos
    le $I12, 1, rxenumcharlistq1055_loop
    set $I12, 1
  rxenumcharlistq1055_loop:
    le $I12, 0, rxenumcharlistq1055_done
    substr $S10, rx1051_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1055_done
    inc rx1051_rep
  rxenumcharlistq1055_done:
    add rx1051_pos, rx1051_pos, rx1051_rep
    set_addr $I10, rxcap_1056_fail
    ($I12, $I11) = rx1051_cur."!mark_peek"($I10)
    rx1051_cur."!cursor_pos"($I11)
    ($P10) = rx1051_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1051_pos, "")
    rx1051_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1056_done
  rxcap_1056_fail:
    goto rx1051_fail
  rxcap_1056_done:
  alt1057_0:
.annotate 'line', 492
    set_addr $I10, alt1057_1
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1051_cur."!cursor_pos"(rx1051_pos)
    $P10 = rx1051_cur."dec_number"()
    unless $P10, rx1051_fail
    rx1051_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1051_pos = $P10."pos"()
    goto alt1057_end
  alt1057_1:
  # rx subrule "integer" subtype=capture negate=
    rx1051_cur."!cursor_pos"(rx1051_pos)
    $P10 = rx1051_cur."integer"()
    unless $P10, rx1051_fail
    rx1051_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1051_pos = $P10."pos"()
  alt1057_end:
.annotate 'line', 490
  # rx pass
    rx1051_cur."!cursor_pass"(rx1051_pos, "number")
    if_null rx1051_debug, debug_817
    rx1051_cur."!cursor_debug"("PASS", "number", " at pos=", rx1051_pos)
  debug_817:
    .return (rx1051_cur)
  rx1051_restart:
.annotate 'line', 4
    if_null rx1051_debug, debug_818
    rx1051_cur."!cursor_debug"("NEXT", "number")
  debug_818:
  rx1051_fail:
    (rx1051_rep, rx1051_pos, $I10, $P10) = rx1051_cur."!mark_fail"(0)
    lt rx1051_pos, -1, rx1051_done
    eq rx1051_pos, -1, rx1051_fail
    jump $I10
  rx1051_done:
    rx1051_cur."!cursor_fail"()
    if_null rx1051_debug, debug_819
    rx1051_cur."!cursor_debug"("FAIL", "number")
  debug_819:
    .return (rx1051_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("226_1295994649.593") :method
.annotate 'line', 4
    new $P1053, "ResizablePMCArray"
    push $P1053, ""
    .return ($P1053)
.end


.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("227_1295994649.593")
    .param pmc param_1059
.annotate 'line', 495
    .lex "self", param_1059
    $P1060 = param_1059."!protoregex"("quote")
    .return ($P1060)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("228_1295994649.593")
    .param pmc param_1062
.annotate 'line', 495
    .lex "self", param_1062
    $P1063 = param_1062."!PREFIX__!protoregex"("quote")
    .return ($P1063)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("229_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1065_tgt
    .local int rx1065_pos
    .local int rx1065_off
    .local int rx1065_eos
    .local int rx1065_rep
    .local pmc rx1065_cur
    .local pmc rx1065_debug
    (rx1065_cur, rx1065_pos, rx1065_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1065_cur
    .local pmc match
    .lex "$/", match
    length rx1065_eos, rx1065_tgt
    gt rx1065_pos, rx1065_eos, rx1065_done
    set rx1065_off, 0
    lt rx1065_pos, 2, rx1065_start
    sub rx1065_off, rx1065_pos, 1
    substr rx1065_tgt, rx1065_tgt, rx1065_off
  rx1065_start:
    eq $I10, 1, rx1065_restart
    if_null rx1065_debug, debug_820
    rx1065_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1068_done
    goto rxscan1068_scan
  rxscan1068_loop:
    ($P10) = rx1065_cur."from"()
    inc $P10
    set rx1065_pos, $P10
    ge rx1065_pos, rx1065_eos, rxscan1068_done
  rxscan1068_scan:
    set_addr $I10, rxscan1068_loop
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
  rxscan1068_done:
.annotate 'line', 496
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1065_pos, rx1065_off
    substr $S10, rx1065_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1065_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."quote_EXPR"(":q")
    unless $P10, rx1065_fail
    rx1065_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1065_pos = $P10."pos"()
  # rx pass
    rx1065_cur."!cursor_pass"(rx1065_pos, "quote:sym<apos>")
    if_null rx1065_debug, debug_821
    rx1065_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1065_pos)
  debug_821:
    .return (rx1065_cur)
  rx1065_restart:
.annotate 'line', 4
    if_null rx1065_debug, debug_822
    rx1065_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_822:
  rx1065_fail:
    (rx1065_rep, rx1065_pos, $I10, $P10) = rx1065_cur."!mark_fail"(0)
    lt rx1065_pos, -1, rx1065_done
    eq rx1065_pos, -1, rx1065_fail
    jump $I10
  rx1065_done:
    rx1065_cur."!cursor_fail"()
    if_null rx1065_debug, debug_823
    rx1065_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_823:
    .return (rx1065_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("230_1295994649.593") :method
.annotate 'line', 4
    new $P1067, "ResizablePMCArray"
    push $P1067, "'"
    .return ($P1067)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("231_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1070_tgt
    .local int rx1070_pos
    .local int rx1070_off
    .local int rx1070_eos
    .local int rx1070_rep
    .local pmc rx1070_cur
    .local pmc rx1070_debug
    (rx1070_cur, rx1070_pos, rx1070_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1070_cur
    .local pmc match
    .lex "$/", match
    length rx1070_eos, rx1070_tgt
    gt rx1070_pos, rx1070_eos, rx1070_done
    set rx1070_off, 0
    lt rx1070_pos, 2, rx1070_start
    sub rx1070_off, rx1070_pos, 1
    substr rx1070_tgt, rx1070_tgt, rx1070_off
  rx1070_start:
    eq $I10, 1, rx1070_restart
    if_null rx1070_debug, debug_824
    rx1070_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1073_done
    goto rxscan1073_scan
  rxscan1073_loop:
    ($P10) = rx1070_cur."from"()
    inc $P10
    set rx1070_pos, $P10
    ge rx1070_pos, rx1070_eos, rxscan1073_done
  rxscan1073_scan:
    set_addr $I10, rxscan1073_loop
    rx1070_cur."!mark_push"(0, rx1070_pos, $I10)
  rxscan1073_done:
.annotate 'line', 497
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1070_pos, rx1070_off
    substr $S10, rx1070_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1070_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1070_cur."!cursor_pos"(rx1070_pos)
    $P10 = rx1070_cur."quote_EXPR"(":qq")
    unless $P10, rx1070_fail
    rx1070_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1070_pos = $P10."pos"()
  # rx pass
    rx1070_cur."!cursor_pass"(rx1070_pos, "quote:sym<dblq>")
    if_null rx1070_debug, debug_825
    rx1070_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1070_pos)
  debug_825:
    .return (rx1070_cur)
  rx1070_restart:
.annotate 'line', 4
    if_null rx1070_debug, debug_826
    rx1070_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_826:
  rx1070_fail:
    (rx1070_rep, rx1070_pos, $I10, $P10) = rx1070_cur."!mark_fail"(0)
    lt rx1070_pos, -1, rx1070_done
    eq rx1070_pos, -1, rx1070_fail
    jump $I10
  rx1070_done:
    rx1070_cur."!cursor_fail"()
    if_null rx1070_debug, debug_827
    rx1070_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_827:
    .return (rx1070_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("232_1295994649.593") :method
.annotate 'line', 4
    new $P1072, "ResizablePMCArray"
    push $P1072, "\""
    .return ($P1072)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("233_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1075_tgt
    .local int rx1075_pos
    .local int rx1075_off
    .local int rx1075_eos
    .local int rx1075_rep
    .local pmc rx1075_cur
    .local pmc rx1075_debug
    (rx1075_cur, rx1075_pos, rx1075_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1075_cur
    .local pmc match
    .lex "$/", match
    length rx1075_eos, rx1075_tgt
    gt rx1075_pos, rx1075_eos, rx1075_done
    set rx1075_off, 0
    lt rx1075_pos, 2, rx1075_start
    sub rx1075_off, rx1075_pos, 1
    substr rx1075_tgt, rx1075_tgt, rx1075_off
  rx1075_start:
    eq $I10, 1, rx1075_restart
    if_null rx1075_debug, debug_828
    rx1075_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1079_done
    goto rxscan1079_scan
  rxscan1079_loop:
    ($P10) = rx1075_cur."from"()
    inc $P10
    set rx1075_pos, $P10
    ge rx1075_pos, rx1075_eos, rxscan1079_done
  rxscan1079_scan:
    set_addr $I10, rxscan1079_loop
    rx1075_cur."!mark_push"(0, rx1075_pos, $I10)
  rxscan1079_done:
.annotate 'line', 498
  # rx literal  "q"
    add $I11, rx1075_pos, 1
    gt $I11, rx1075_eos, rx1075_fail
    sub $I11, rx1075_pos, rx1075_off
    ord $I11, rx1075_tgt, $I11
    ne $I11, 113, rx1075_fail
    add rx1075_pos, 1
  # rxanchor rwb
    le rx1075_pos, 0, rx1075_fail
    sub $I10, rx1075_pos, rx1075_off
    is_cclass $I11, 8192, rx1075_tgt, $I10
    if $I11, rx1075_fail
    dec $I10
    is_cclass $I11, 8192, rx1075_tgt, $I10
    unless $I11, rx1075_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1075_pos, rx1075_off
    substr $S10, rx1075_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1075_fail
  # rx subrule "ws" subtype=method negate=
    rx1075_cur."!cursor_pos"(rx1075_pos)
    $P10 = rx1075_cur."ws"()
    unless $P10, rx1075_fail
    rx1075_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1075_cur."!cursor_pos"(rx1075_pos)
    $P10 = rx1075_cur."quote_EXPR"(":q")
    unless $P10, rx1075_fail
    rx1075_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1075_pos = $P10."pos"()
  # rx pass
    rx1075_cur."!cursor_pass"(rx1075_pos, "quote:sym<q>")
    if_null rx1075_debug, debug_829
    rx1075_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1075_pos)
  debug_829:
    .return (rx1075_cur)
  rx1075_restart:
.annotate 'line', 4
    if_null rx1075_debug, debug_830
    rx1075_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_830:
  rx1075_fail:
    (rx1075_rep, rx1075_pos, $I10, $P10) = rx1075_cur."!mark_fail"(0)
    lt rx1075_pos, -1, rx1075_done
    eq rx1075_pos, -1, rx1075_fail
    jump $I10
  rx1075_done:
    rx1075_cur."!cursor_fail"()
    if_null rx1075_debug, debug_831
    rx1075_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_831:
    .return (rx1075_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("234_1295994649.593") :method
.annotate 'line', 4
    $P1077 = self."!PREFIX__!subrule"("ws", "q")
    new $P1078, "ResizablePMCArray"
    push $P1078, $P1077
    .return ($P1078)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("235_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1081_tgt
    .local int rx1081_pos
    .local int rx1081_off
    .local int rx1081_eos
    .local int rx1081_rep
    .local pmc rx1081_cur
    .local pmc rx1081_debug
    (rx1081_cur, rx1081_pos, rx1081_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1081_cur
    .local pmc match
    .lex "$/", match
    length rx1081_eos, rx1081_tgt
    gt rx1081_pos, rx1081_eos, rx1081_done
    set rx1081_off, 0
    lt rx1081_pos, 2, rx1081_start
    sub rx1081_off, rx1081_pos, 1
    substr rx1081_tgt, rx1081_tgt, rx1081_off
  rx1081_start:
    eq $I10, 1, rx1081_restart
    if_null rx1081_debug, debug_832
    rx1081_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1085_done
    goto rxscan1085_scan
  rxscan1085_loop:
    ($P10) = rx1081_cur."from"()
    inc $P10
    set rx1081_pos, $P10
    ge rx1081_pos, rx1081_eos, rxscan1085_done
  rxscan1085_scan:
    set_addr $I10, rxscan1085_loop
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  rxscan1085_done:
.annotate 'line', 499
  # rx literal  "qq"
    add $I11, rx1081_pos, 2
    gt $I11, rx1081_eos, rx1081_fail
    sub $I11, rx1081_pos, rx1081_off
    substr $S10, rx1081_tgt, $I11, 2
    ne $S10, "qq", rx1081_fail
    add rx1081_pos, 2
  # rxanchor rwb
    le rx1081_pos, 0, rx1081_fail
    sub $I10, rx1081_pos, rx1081_off
    is_cclass $I11, 8192, rx1081_tgt, $I10
    if $I11, rx1081_fail
    dec $I10
    is_cclass $I11, 8192, rx1081_tgt, $I10
    unless $I11, rx1081_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1081_pos, rx1081_off
    substr $S10, rx1081_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1081_fail
  # rx subrule "ws" subtype=method negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."ws"()
    unless $P10, rx1081_fail
    rx1081_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."quote_EXPR"(":qq")
    unless $P10, rx1081_fail
    rx1081_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1081_pos = $P10."pos"()
  # rx pass
    rx1081_cur."!cursor_pass"(rx1081_pos, "quote:sym<qq>")
    if_null rx1081_debug, debug_833
    rx1081_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1081_pos)
  debug_833:
    .return (rx1081_cur)
  rx1081_restart:
.annotate 'line', 4
    if_null rx1081_debug, debug_834
    rx1081_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_834:
  rx1081_fail:
    (rx1081_rep, rx1081_pos, $I10, $P10) = rx1081_cur."!mark_fail"(0)
    lt rx1081_pos, -1, rx1081_done
    eq rx1081_pos, -1, rx1081_fail
    jump $I10
  rx1081_done:
    rx1081_cur."!cursor_fail"()
    if_null rx1081_debug, debug_835
    rx1081_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_835:
    .return (rx1081_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("236_1295994649.593") :method
.annotate 'line', 4
    $P1083 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1084, "ResizablePMCArray"
    push $P1084, $P1083
    .return ($P1084)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("237_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1087_tgt
    .local int rx1087_pos
    .local int rx1087_off
    .local int rx1087_eos
    .local int rx1087_rep
    .local pmc rx1087_cur
    .local pmc rx1087_debug
    (rx1087_cur, rx1087_pos, rx1087_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1087_cur
    .local pmc match
    .lex "$/", match
    length rx1087_eos, rx1087_tgt
    gt rx1087_pos, rx1087_eos, rx1087_done
    set rx1087_off, 0
    lt rx1087_pos, 2, rx1087_start
    sub rx1087_off, rx1087_pos, 1
    substr rx1087_tgt, rx1087_tgt, rx1087_off
  rx1087_start:
    eq $I10, 1, rx1087_restart
    if_null rx1087_debug, debug_836
    rx1087_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1091_done
    goto rxscan1091_scan
  rxscan1091_loop:
    ($P10) = rx1087_cur."from"()
    inc $P10
    set rx1087_pos, $P10
    ge rx1087_pos, rx1087_eos, rxscan1091_done
  rxscan1091_scan:
    set_addr $I10, rxscan1091_loop
    rx1087_cur."!mark_push"(0, rx1087_pos, $I10)
  rxscan1091_done:
.annotate 'line', 500
  # rx literal  "Q"
    add $I11, rx1087_pos, 1
    gt $I11, rx1087_eos, rx1087_fail
    sub $I11, rx1087_pos, rx1087_off
    ord $I11, rx1087_tgt, $I11
    ne $I11, 81, rx1087_fail
    add rx1087_pos, 1
  # rxanchor rwb
    le rx1087_pos, 0, rx1087_fail
    sub $I10, rx1087_pos, rx1087_off
    is_cclass $I11, 8192, rx1087_tgt, $I10
    if $I11, rx1087_fail
    dec $I10
    is_cclass $I11, 8192, rx1087_tgt, $I10
    unless $I11, rx1087_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1087_pos, rx1087_off
    substr $S10, rx1087_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1087_fail
  # rx subrule "ws" subtype=method negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."ws"()
    unless $P10, rx1087_fail
    rx1087_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1087_cur."!cursor_pos"(rx1087_pos)
    $P10 = rx1087_cur."quote_EXPR"()
    unless $P10, rx1087_fail
    rx1087_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1087_pos = $P10."pos"()
  # rx pass
    rx1087_cur."!cursor_pass"(rx1087_pos, "quote:sym<Q>")
    if_null rx1087_debug, debug_837
    rx1087_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1087_pos)
  debug_837:
    .return (rx1087_cur)
  rx1087_restart:
.annotate 'line', 4
    if_null rx1087_debug, debug_838
    rx1087_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_838:
  rx1087_fail:
    (rx1087_rep, rx1087_pos, $I10, $P10) = rx1087_cur."!mark_fail"(0)
    lt rx1087_pos, -1, rx1087_done
    eq rx1087_pos, -1, rx1087_fail
    jump $I10
  rx1087_done:
    rx1087_cur."!cursor_fail"()
    if_null rx1087_debug, debug_839
    rx1087_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_839:
    .return (rx1087_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("238_1295994649.593") :method
.annotate 'line', 4
    $P1089 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1090, "ResizablePMCArray"
    push $P1090, $P1089
    .return ($P1090)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("239_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1093_tgt
    .local int rx1093_pos
    .local int rx1093_off
    .local int rx1093_eos
    .local int rx1093_rep
    .local pmc rx1093_cur
    .local pmc rx1093_debug
    (rx1093_cur, rx1093_pos, rx1093_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1093_cur
    .local pmc match
    .lex "$/", match
    length rx1093_eos, rx1093_tgt
    gt rx1093_pos, rx1093_eos, rx1093_done
    set rx1093_off, 0
    lt rx1093_pos, 2, rx1093_start
    sub rx1093_off, rx1093_pos, 1
    substr rx1093_tgt, rx1093_tgt, rx1093_off
  rx1093_start:
    eq $I10, 1, rx1093_restart
    if_null rx1093_debug, debug_840
    rx1093_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1097_done
    goto rxscan1097_scan
  rxscan1097_loop:
    ($P10) = rx1093_cur."from"()
    inc $P10
    set rx1093_pos, $P10
    ge rx1093_pos, rx1093_eos, rxscan1097_done
  rxscan1097_scan:
    set_addr $I10, rxscan1097_loop
    rx1093_cur."!mark_push"(0, rx1093_pos, $I10)
  rxscan1097_done:
.annotate 'line', 501
  # rx literal  "Q:PIR"
    add $I11, rx1093_pos, 5
    gt $I11, rx1093_eos, rx1093_fail
    sub $I11, rx1093_pos, rx1093_off
    substr $S10, rx1093_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1093_fail
    add rx1093_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1093_cur."!cursor_pos"(rx1093_pos)
    $P10 = rx1093_cur."ws"()
    unless $P10, rx1093_fail
    rx1093_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1093_cur."!cursor_pos"(rx1093_pos)
    $P10 = rx1093_cur."quote_EXPR"()
    unless $P10, rx1093_fail
    rx1093_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1093_pos = $P10."pos"()
  # rx pass
    rx1093_cur."!cursor_pass"(rx1093_pos, "quote:sym<Q:PIR>")
    if_null rx1093_debug, debug_841
    rx1093_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1093_pos)
  debug_841:
    .return (rx1093_cur)
  rx1093_restart:
.annotate 'line', 4
    if_null rx1093_debug, debug_842
    rx1093_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_842:
  rx1093_fail:
    (rx1093_rep, rx1093_pos, $I10, $P10) = rx1093_cur."!mark_fail"(0)
    lt rx1093_pos, -1, rx1093_done
    eq rx1093_pos, -1, rx1093_fail
    jump $I10
  rx1093_done:
    rx1093_cur."!cursor_fail"()
    if_null rx1093_debug, debug_843
    rx1093_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_843:
    .return (rx1093_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("240_1295994649.593") :method
.annotate 'line', 4
    $P1095 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1096, "ResizablePMCArray"
    push $P1096, $P1095
    .return ($P1096)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("241_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1099_tgt
    .local int rx1099_pos
    .local int rx1099_off
    .local int rx1099_eos
    .local int rx1099_rep
    .local pmc rx1099_cur
    .local pmc rx1099_debug
    (rx1099_cur, rx1099_pos, rx1099_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1099_cur
    .local pmc match
    .lex "$/", match
    length rx1099_eos, rx1099_tgt
    gt rx1099_pos, rx1099_eos, rx1099_done
    set rx1099_off, 0
    lt rx1099_pos, 2, rx1099_start
    sub rx1099_off, rx1099_pos, 1
    substr rx1099_tgt, rx1099_tgt, rx1099_off
  rx1099_start:
    eq $I10, 1, rx1099_restart
    if_null rx1099_debug, debug_844
    rx1099_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1103_done
    goto rxscan1103_scan
  rxscan1103_loop:
    ($P10) = rx1099_cur."from"()
    inc $P10
    set rx1099_pos, $P10
    ge rx1099_pos, rx1099_eos, rxscan1103_done
  rxscan1103_scan:
    set_addr $I10, rxscan1103_loop
    rx1099_cur."!mark_push"(0, rx1099_pos, $I10)
  rxscan1103_done:
.annotate 'line', 503
  # rx literal  "/"
    add $I11, rx1099_pos, 1
    gt $I11, rx1099_eos, rx1099_fail
    sub $I11, rx1099_pos, rx1099_off
    ord $I11, rx1099_tgt, $I11
    ne $I11, 47, rx1099_fail
    add rx1099_pos, 1
.annotate 'line', 504
  # rx subrule "newpad" subtype=method negate=
    rx1099_cur."!cursor_pos"(rx1099_pos)
    $P10 = rx1099_cur."newpad"()
    unless $P10, rx1099_fail
    rx1099_pos = $P10."pos"()
.annotate 'line', 505
  # rx reduce name="quote:sym</ />" key="open"
    rx1099_cur."!cursor_pos"(rx1099_pos)
    rx1099_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 506
  # rx subrule "LANG" subtype=capture negate=
    rx1099_cur."!cursor_pos"(rx1099_pos)
    $P10 = rx1099_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1099_fail
    rx1099_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1099_pos = $P10."pos"()
.annotate 'line', 507
  # rx literal  "/"
    add $I11, rx1099_pos, 1
    gt $I11, rx1099_eos, rx1099_fail
    sub $I11, rx1099_pos, rx1099_off
    ord $I11, rx1099_tgt, $I11
    ne $I11, 47, rx1099_fail
    add rx1099_pos, 1
.annotate 'line', 502
  # rx pass
    rx1099_cur."!cursor_pass"(rx1099_pos, "quote:sym</ />")
    if_null rx1099_debug, debug_845
    rx1099_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1099_pos)
  debug_845:
    .return (rx1099_cur)
  rx1099_restart:
.annotate 'line', 4
    if_null rx1099_debug, debug_846
    rx1099_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_846:
  rx1099_fail:
    (rx1099_rep, rx1099_pos, $I10, $P10) = rx1099_cur."!mark_fail"(0)
    lt rx1099_pos, -1, rx1099_done
    eq rx1099_pos, -1, rx1099_fail
    jump $I10
  rx1099_done:
    rx1099_cur."!cursor_fail"()
    if_null rx1099_debug, debug_847
    rx1099_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_847:
    .return (rx1099_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("242_1295994649.593") :method
.annotate 'line', 4
    $P1101 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1102, "ResizablePMCArray"
    push $P1102, $P1101
    .return ($P1102)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("243_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1105_tgt
    .local int rx1105_pos
    .local int rx1105_off
    .local int rx1105_eos
    .local int rx1105_rep
    .local pmc rx1105_cur
    .local pmc rx1105_debug
    (rx1105_cur, rx1105_pos, rx1105_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1105_cur
    .local pmc match
    .lex "$/", match
    length rx1105_eos, rx1105_tgt
    gt rx1105_pos, rx1105_eos, rx1105_done
    set rx1105_off, 0
    lt rx1105_pos, 2, rx1105_start
    sub rx1105_off, rx1105_pos, 1
    substr rx1105_tgt, rx1105_tgt, rx1105_off
  rx1105_start:
    eq $I10, 1, rx1105_restart
    if_null rx1105_debug, debug_848
    rx1105_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1108_done
    goto rxscan1108_scan
  rxscan1108_loop:
    ($P10) = rx1105_cur."from"()
    inc $P10
    set rx1105_pos, $P10
    ge rx1105_pos, rx1105_eos, rxscan1108_done
  rxscan1108_scan:
    set_addr $I10, rxscan1108_loop
    rx1105_cur."!mark_push"(0, rx1105_pos, $I10)
  rxscan1108_done:
.annotate 'line', 510
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1105_pos, rx1105_off
    substr $S10, rx1105_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1105_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1105_cur."!cursor_pos"(rx1105_pos)
    $P10 = rx1105_cur."quotemod_check"("s")
    unless $P10, rx1105_fail
  # rx subrule "variable" subtype=capture negate=
    rx1105_cur."!cursor_pos"(rx1105_pos)
    $P10 = rx1105_cur."variable"()
    unless $P10, rx1105_fail
    rx1105_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1105_pos = $P10."pos"()
  # rx pass
    rx1105_cur."!cursor_pass"(rx1105_pos, "quote_escape:sym<$>")
    if_null rx1105_debug, debug_849
    rx1105_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1105_pos)
  debug_849:
    .return (rx1105_cur)
  rx1105_restart:
.annotate 'line', 4
    if_null rx1105_debug, debug_850
    rx1105_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_850:
  rx1105_fail:
    (rx1105_rep, rx1105_pos, $I10, $P10) = rx1105_cur."!mark_fail"(0)
    lt rx1105_pos, -1, rx1105_done
    eq rx1105_pos, -1, rx1105_fail
    jump $I10
  rx1105_done:
    rx1105_cur."!cursor_fail"()
    if_null rx1105_debug, debug_851
    rx1105_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_851:
    .return (rx1105_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("244_1295994649.593") :method
.annotate 'line', 4
    new $P1107, "ResizablePMCArray"
    push $P1107, "$"
    .return ($P1107)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("245_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1110_tgt
    .local int rx1110_pos
    .local int rx1110_off
    .local int rx1110_eos
    .local int rx1110_rep
    .local pmc rx1110_cur
    .local pmc rx1110_debug
    (rx1110_cur, rx1110_pos, rx1110_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1110_cur
    .local pmc match
    .lex "$/", match
    length rx1110_eos, rx1110_tgt
    gt rx1110_pos, rx1110_eos, rx1110_done
    set rx1110_off, 0
    lt rx1110_pos, 2, rx1110_start
    sub rx1110_off, rx1110_pos, 1
    substr rx1110_tgt, rx1110_tgt, rx1110_off
  rx1110_start:
    eq $I10, 1, rx1110_restart
    if_null rx1110_debug, debug_852
    rx1110_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1113_done
    goto rxscan1113_scan
  rxscan1113_loop:
    ($P10) = rx1110_cur."from"()
    inc $P10
    set rx1110_pos, $P10
    ge rx1110_pos, rx1110_eos, rxscan1113_done
  rxscan1113_scan:
    set_addr $I10, rxscan1113_loop
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxscan1113_done:
.annotate 'line', 511
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1110_pos, rx1110_off
    substr $S10, rx1110_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1110_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."quotemod_check"("c")
    unless $P10, rx1110_fail
  # rx subrule "block" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."block"()
    unless $P10, rx1110_fail
    rx1110_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1110_pos = $P10."pos"()
  # rx pass
    rx1110_cur."!cursor_pass"(rx1110_pos, "quote_escape:sym<{ }>")
    if_null rx1110_debug, debug_853
    rx1110_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1110_pos)
  debug_853:
    .return (rx1110_cur)
  rx1110_restart:
.annotate 'line', 4
    if_null rx1110_debug, debug_854
    rx1110_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_854:
  rx1110_fail:
    (rx1110_rep, rx1110_pos, $I10, $P10) = rx1110_cur."!mark_fail"(0)
    lt rx1110_pos, -1, rx1110_done
    eq rx1110_pos, -1, rx1110_fail
    jump $I10
  rx1110_done:
    rx1110_cur."!cursor_fail"()
    if_null rx1110_debug, debug_855
    rx1110_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_855:
    .return (rx1110_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("246_1295994649.593") :method
.annotate 'line', 4
    new $P1112, "ResizablePMCArray"
    push $P1112, "{"
    .return ($P1112)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("247_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1115_tgt
    .local int rx1115_pos
    .local int rx1115_off
    .local int rx1115_eos
    .local int rx1115_rep
    .local pmc rx1115_cur
    .local pmc rx1115_debug
    (rx1115_cur, rx1115_pos, rx1115_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1115_cur
    .local pmc match
    .lex "$/", match
    length rx1115_eos, rx1115_tgt
    gt rx1115_pos, rx1115_eos, rx1115_done
    set rx1115_off, 0
    lt rx1115_pos, 2, rx1115_start
    sub rx1115_off, rx1115_pos, 1
    substr rx1115_tgt, rx1115_tgt, rx1115_off
  rx1115_start:
    eq $I10, 1, rx1115_restart
    if_null rx1115_debug, debug_856
    rx1115_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1118_done
    goto rxscan1118_scan
  rxscan1118_loop:
    ($P10) = rx1115_cur."from"()
    inc $P10
    set rx1115_pos, $P10
    ge rx1115_pos, rx1115_eos, rxscan1118_done
  rxscan1118_scan:
    set_addr $I10, rxscan1118_loop
    rx1115_cur."!mark_push"(0, rx1115_pos, $I10)
  rxscan1118_done:
.annotate 'line', 512
  # rx literal  "\\e"
    add $I11, rx1115_pos, 2
    gt $I11, rx1115_eos, rx1115_fail
    sub $I11, rx1115_pos, rx1115_off
    substr $S10, rx1115_tgt, $I11, 2
    ne $S10, "\\e", rx1115_fail
    add rx1115_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1115_cur."!cursor_pos"(rx1115_pos)
    $P10 = rx1115_cur."quotemod_check"("b")
    unless $P10, rx1115_fail
  # rx pass
    rx1115_cur."!cursor_pass"(rx1115_pos, "quote_escape:sym<esc>")
    if_null rx1115_debug, debug_857
    rx1115_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1115_pos)
  debug_857:
    .return (rx1115_cur)
  rx1115_restart:
.annotate 'line', 4
    if_null rx1115_debug, debug_858
    rx1115_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_858:
  rx1115_fail:
    (rx1115_rep, rx1115_pos, $I10, $P10) = rx1115_cur."!mark_fail"(0)
    lt rx1115_pos, -1, rx1115_done
    eq rx1115_pos, -1, rx1115_fail
    jump $I10
  rx1115_done:
    rx1115_cur."!cursor_fail"()
    if_null rx1115_debug, debug_859
    rx1115_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_859:
    .return (rx1115_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("248_1295994649.593") :method
.annotate 'line', 4
    new $P1117, "ResizablePMCArray"
    push $P1117, "\\e"
    .return ($P1117)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("249_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1120_tgt
    .local int rx1120_pos
    .local int rx1120_off
    .local int rx1120_eos
    .local int rx1120_rep
    .local pmc rx1120_cur
    .local pmc rx1120_debug
    (rx1120_cur, rx1120_pos, rx1120_tgt, $I10) = self."!cursor_start"()
    rx1120_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1120_cur
    .local pmc match
    .lex "$/", match
    length rx1120_eos, rx1120_tgt
    gt rx1120_pos, rx1120_eos, rx1120_done
    set rx1120_off, 0
    lt rx1120_pos, 2, rx1120_start
    sub rx1120_off, rx1120_pos, 1
    substr rx1120_tgt, rx1120_tgt, rx1120_off
  rx1120_start:
    eq $I10, 1, rx1120_restart
    if_null rx1120_debug, debug_860
    rx1120_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1124_done
    goto rxscan1124_scan
  rxscan1124_loop:
    ($P10) = rx1120_cur."from"()
    inc $P10
    set rx1120_pos, $P10
    ge rx1120_pos, rx1120_eos, rxscan1124_done
  rxscan1124_scan:
    set_addr $I10, rxscan1124_loop
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10)
  rxscan1124_done:
.annotate 'line', 514
  # rx literal  "("
    add $I11, rx1120_pos, 1
    gt $I11, rx1120_eos, rx1120_fail
    sub $I11, rx1120_pos, rx1120_off
    ord $I11, rx1120_tgt, $I11
    ne $I11, 40, rx1120_fail
    add rx1120_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."ws"()
    unless $P10, rx1120_fail
    rx1120_pos = $P10."pos"()
  # rx rxquantr1125 ** 0..1
    set_addr $I10, rxquantr1125_done
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10)
  rxquantr1125_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1120_cur."!cursor_pos"(rx1120_pos)
    $P10 = rx1120_cur."EXPR"()
    unless $P10, rx1120_fail
    goto rxsubrule1126_pass
  rxsubrule1126_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1120_fail
  rxsubrule1126_pass:
    set_addr $I10, rxsubrule1126_back
    rx1120_cur."!mark_push"(0, rx1120_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1120_pos = $P10."pos"()
    set_addr $I10, rxquantr1125_done
    (rx1120_rep) = rx1120_cur."!mark_commit"($I10)
  rxquantr1125_done:
  # rx literal  ")"
    add $I11, rx1120_pos, 1
    gt $I11, rx1120_eos, rx1120_fail
    sub $I11, rx1120_pos, rx1120_off
    ord $I11, rx1120_tgt, $I11
    ne $I11, 41, rx1120_fail
    add rx1120_pos, 1
  # rx pass
    rx1120_cur."!cursor_pass"(rx1120_pos, "circumfix:sym<( )>")
    if_null rx1120_debug, debug_861
    rx1120_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1120_pos)
  debug_861:
    .return (rx1120_cur)
  rx1120_restart:
.annotate 'line', 4
    if_null rx1120_debug, debug_862
    rx1120_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_862:
  rx1120_fail:
    (rx1120_rep, rx1120_pos, $I10, $P10) = rx1120_cur."!mark_fail"(0)
    lt rx1120_pos, -1, rx1120_done
    eq rx1120_pos, -1, rx1120_fail
    jump $I10
  rx1120_done:
    rx1120_cur."!cursor_fail"()
    if_null rx1120_debug, debug_863
    rx1120_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_863:
    .return (rx1120_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("250_1295994649.593") :method
.annotate 'line', 4
    $P1122 = self."!PREFIX__!subrule"("ws", "(")
    new $P1123, "ResizablePMCArray"
    push $P1123, $P1122
    .return ($P1123)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("251_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1128_tgt
    .local int rx1128_pos
    .local int rx1128_off
    .local int rx1128_eos
    .local int rx1128_rep
    .local pmc rx1128_cur
    .local pmc rx1128_debug
    (rx1128_cur, rx1128_pos, rx1128_tgt, $I10) = self."!cursor_start"()
    rx1128_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1128_cur
    .local pmc match
    .lex "$/", match
    length rx1128_eos, rx1128_tgt
    gt rx1128_pos, rx1128_eos, rx1128_done
    set rx1128_off, 0
    lt rx1128_pos, 2, rx1128_start
    sub rx1128_off, rx1128_pos, 1
    substr rx1128_tgt, rx1128_tgt, rx1128_off
  rx1128_start:
    eq $I10, 1, rx1128_restart
    if_null rx1128_debug, debug_864
    rx1128_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1132_done
    goto rxscan1132_scan
  rxscan1132_loop:
    ($P10) = rx1128_cur."from"()
    inc $P10
    set rx1128_pos, $P10
    ge rx1128_pos, rx1128_eos, rxscan1132_done
  rxscan1132_scan:
    set_addr $I10, rxscan1132_loop
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
  rxscan1132_done:
.annotate 'line', 515
  # rx literal  "["
    add $I11, rx1128_pos, 1
    gt $I11, rx1128_eos, rx1128_fail
    sub $I11, rx1128_pos, rx1128_off
    ord $I11, rx1128_tgt, $I11
    ne $I11, 91, rx1128_fail
    add rx1128_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."ws"()
    unless $P10, rx1128_fail
    rx1128_pos = $P10."pos"()
  # rx rxquantr1133 ** 0..1
    set_addr $I10, rxquantr1133_done
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
  rxquantr1133_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."EXPR"()
    unless $P10, rx1128_fail
    goto rxsubrule1134_pass
  rxsubrule1134_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1128_fail
  rxsubrule1134_pass:
    set_addr $I10, rxsubrule1134_back
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1128_pos = $P10."pos"()
    set_addr $I10, rxquantr1133_done
    (rx1128_rep) = rx1128_cur."!mark_commit"($I10)
  rxquantr1133_done:
  # rx literal  "]"
    add $I11, rx1128_pos, 1
    gt $I11, rx1128_eos, rx1128_fail
    sub $I11, rx1128_pos, rx1128_off
    ord $I11, rx1128_tgt, $I11
    ne $I11, 93, rx1128_fail
    add rx1128_pos, 1
  # rx pass
    rx1128_cur."!cursor_pass"(rx1128_pos, "circumfix:sym<[ ]>")
    if_null rx1128_debug, debug_865
    rx1128_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1128_pos)
  debug_865:
    .return (rx1128_cur)
  rx1128_restart:
.annotate 'line', 4
    if_null rx1128_debug, debug_866
    rx1128_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_866:
  rx1128_fail:
    (rx1128_rep, rx1128_pos, $I10, $P10) = rx1128_cur."!mark_fail"(0)
    lt rx1128_pos, -1, rx1128_done
    eq rx1128_pos, -1, rx1128_fail
    jump $I10
  rx1128_done:
    rx1128_cur."!cursor_fail"()
    if_null rx1128_debug, debug_867
    rx1128_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_867:
    .return (rx1128_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("252_1295994649.593") :method
.annotate 'line', 4
    $P1130 = self."!PREFIX__!subrule"("ws", "[")
    new $P1131, "ResizablePMCArray"
    push $P1131, $P1130
    .return ($P1131)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("253_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1136_tgt
    .local int rx1136_pos
    .local int rx1136_off
    .local int rx1136_eos
    .local int rx1136_rep
    .local pmc rx1136_cur
    .local pmc rx1136_debug
    (rx1136_cur, rx1136_pos, rx1136_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1136_cur
    .local pmc match
    .lex "$/", match
    length rx1136_eos, rx1136_tgt
    gt rx1136_pos, rx1136_eos, rx1136_done
    set rx1136_off, 0
    lt rx1136_pos, 2, rx1136_start
    sub rx1136_off, rx1136_pos, 1
    substr rx1136_tgt, rx1136_tgt, rx1136_off
  rx1136_start:
    eq $I10, 1, rx1136_restart
    if_null rx1136_debug, debug_868
    rx1136_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1139_done
    goto rxscan1139_scan
  rxscan1139_loop:
    ($P10) = rx1136_cur."from"()
    inc $P10
    set rx1136_pos, $P10
    ge rx1136_pos, rx1136_eos, rxscan1139_done
  rxscan1139_scan:
    set_addr $I10, rxscan1139_loop
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxscan1139_done:
.annotate 'line', 516
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1136_pos, rx1136_off
    substr $S10, rx1136_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1136_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1136_fail
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1136_pos = $P10."pos"()
  # rx pass
    rx1136_cur."!cursor_pass"(rx1136_pos, "circumfix:sym<ang>")
    if_null rx1136_debug, debug_869
    rx1136_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1136_pos)
  debug_869:
    .return (rx1136_cur)
  rx1136_restart:
.annotate 'line', 4
    if_null rx1136_debug, debug_870
    rx1136_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_870:
  rx1136_fail:
    (rx1136_rep, rx1136_pos, $I10, $P10) = rx1136_cur."!mark_fail"(0)
    lt rx1136_pos, -1, rx1136_done
    eq rx1136_pos, -1, rx1136_fail
    jump $I10
  rx1136_done:
    rx1136_cur."!cursor_fail"()
    if_null rx1136_debug, debug_871
    rx1136_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_871:
    .return (rx1136_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("254_1295994649.593") :method
.annotate 'line', 4
    new $P1138, "ResizablePMCArray"
    push $P1138, "<"
    .return ($P1138)
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("255_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1141_tgt
    .local int rx1141_pos
    .local int rx1141_off
    .local int rx1141_eos
    .local int rx1141_rep
    .local pmc rx1141_cur
    .local pmc rx1141_debug
    (rx1141_cur, rx1141_pos, rx1141_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1141_cur
    .local pmc match
    .lex "$/", match
    length rx1141_eos, rx1141_tgt
    gt rx1141_pos, rx1141_eos, rx1141_done
    set rx1141_off, 0
    lt rx1141_pos, 2, rx1141_start
    sub rx1141_off, rx1141_pos, 1
    substr rx1141_tgt, rx1141_tgt, rx1141_off
  rx1141_start:
    eq $I10, 1, rx1141_restart
    if_null rx1141_debug, debug_872
    rx1141_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1144_done
    goto rxscan1144_scan
  rxscan1144_loop:
    ($P10) = rx1141_cur."from"()
    inc $P10
    set rx1141_pos, $P10
    ge rx1141_pos, rx1141_eos, rxscan1144_done
  rxscan1144_scan:
    set_addr $I10, rxscan1144_loop
    rx1141_cur."!mark_push"(0, rx1141_pos, $I10)
  rxscan1144_done:
.annotate 'line', 517
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1141_pos, rx1141_off
    substr $S10, rx1141_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1141_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1141_cur."!cursor_pos"(rx1141_pos)
    $P10 = rx1141_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1141_fail
    rx1141_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1141_pos = $P10."pos"()
  # rx pass
    rx1141_cur."!cursor_pass"(rx1141_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1141_debug, debug_873
    rx1141_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1141_pos)
  debug_873:
    .return (rx1141_cur)
  rx1141_restart:
.annotate 'line', 4
    if_null rx1141_debug, debug_874
    rx1141_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_874:
  rx1141_fail:
    (rx1141_rep, rx1141_pos, $I10, $P10) = rx1141_cur."!mark_fail"(0)
    lt rx1141_pos, -1, rx1141_done
    eq rx1141_pos, -1, rx1141_fail
    jump $I10
  rx1141_done:
    rx1141_cur."!cursor_fail"()
    if_null rx1141_debug, debug_875
    rx1141_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_875:
    .return (rx1141_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("256_1295994649.593") :method
.annotate 'line', 4
    new $P1143, "ResizablePMCArray"
    push $P1143, unicode:"\x{ab}"
    .return ($P1143)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("257_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1146_tgt
    .local int rx1146_pos
    .local int rx1146_off
    .local int rx1146_eos
    .local int rx1146_rep
    .local pmc rx1146_cur
    .local pmc rx1146_debug
    (rx1146_cur, rx1146_pos, rx1146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1146_cur
    .local pmc match
    .lex "$/", match
    length rx1146_eos, rx1146_tgt
    gt rx1146_pos, rx1146_eos, rx1146_done
    set rx1146_off, 0
    lt rx1146_pos, 2, rx1146_start
    sub rx1146_off, rx1146_pos, 1
    substr rx1146_tgt, rx1146_tgt, rx1146_off
  rx1146_start:
    eq $I10, 1, rx1146_restart
    if_null rx1146_debug, debug_876
    rx1146_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1149_done
    goto rxscan1149_scan
  rxscan1149_loop:
    ($P10) = rx1146_cur."from"()
    inc $P10
    set rx1146_pos, $P10
    ge rx1146_pos, rx1146_eos, rxscan1149_done
  rxscan1149_scan:
    set_addr $I10, rxscan1149_loop
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  rxscan1149_done:
.annotate 'line', 518
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1146_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."pblock"()
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1146_pos = $P10."pos"()
  # rx pass
    rx1146_cur."!cursor_pass"(rx1146_pos, "circumfix:sym<{ }>")
    if_null rx1146_debug, debug_877
    rx1146_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1146_pos)
  debug_877:
    .return (rx1146_cur)
  rx1146_restart:
.annotate 'line', 4
    if_null rx1146_debug, debug_878
    rx1146_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_878:
  rx1146_fail:
    (rx1146_rep, rx1146_pos, $I10, $P10) = rx1146_cur."!mark_fail"(0)
    lt rx1146_pos, -1, rx1146_done
    eq rx1146_pos, -1, rx1146_fail
    jump $I10
  rx1146_done:
    rx1146_cur."!cursor_fail"()
    if_null rx1146_debug, debug_879
    rx1146_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_879:
    .return (rx1146_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("258_1295994649.593") :method
.annotate 'line', 4
    new $P1148, "ResizablePMCArray"
    push $P1148, "{"
    .return ($P1148)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("259_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1151_tgt
    .local int rx1151_pos
    .local int rx1151_off
    .local int rx1151_eos
    .local int rx1151_rep
    .local pmc rx1151_cur
    .local pmc rx1151_debug
    (rx1151_cur, rx1151_pos, rx1151_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1151_cur
    .local pmc match
    .lex "$/", match
    length rx1151_eos, rx1151_tgt
    gt rx1151_pos, rx1151_eos, rx1151_done
    set rx1151_off, 0
    lt rx1151_pos, 2, rx1151_start
    sub rx1151_off, rx1151_pos, 1
    substr rx1151_tgt, rx1151_tgt, rx1151_off
  rx1151_start:
    eq $I10, 1, rx1151_restart
    if_null rx1151_debug, debug_880
    rx1151_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1155_done
    goto rxscan1155_scan
  rxscan1155_loop:
    ($P10) = rx1151_cur."from"()
    inc $P10
    set rx1151_pos, $P10
    ge rx1151_pos, rx1151_eos, rxscan1155_done
  rxscan1155_scan:
    set_addr $I10, rxscan1155_loop
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  rxscan1155_done:
.annotate 'line', 519
  # rx subrule "sigil" subtype=capture negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."sigil"()
    unless $P10, rx1151_fail
    rx1151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1151_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1151_pos, 1
    gt $I11, rx1151_eos, rx1151_fail
    sub $I11, rx1151_pos, rx1151_off
    ord $I11, rx1151_tgt, $I11
    ne $I11, 40, rx1151_fail
    add rx1151_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."semilist"()
    unless $P10, rx1151_fail
    rx1151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1151_pos = $P10."pos"()
  alt1156_0:
    set_addr $I10, alt1156_1
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  # rx literal  ")"
    add $I11, rx1151_pos, 1
    gt $I11, rx1151_eos, rx1151_fail
    sub $I11, rx1151_pos, rx1151_off
    ord $I11, rx1151_tgt, $I11
    ne $I11, 41, rx1151_fail
    add rx1151_pos, 1
    goto alt1156_end
  alt1156_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."FAILGOAL"("')'")
    unless $P10, rx1151_fail
    goto rxsubrule1158_pass
  rxsubrule1158_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1151_fail
  rxsubrule1158_pass:
    set_addr $I10, rxsubrule1158_back
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10, $P10)
    rx1151_pos = $P10."pos"()
  alt1156_end:
  # rx pass
    rx1151_cur."!cursor_pass"(rx1151_pos, "circumfix:sym<sigil>")
    if_null rx1151_debug, debug_881
    rx1151_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1151_pos)
  debug_881:
    .return (rx1151_cur)
  rx1151_restart:
.annotate 'line', 4
    if_null rx1151_debug, debug_882
    rx1151_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_882:
  rx1151_fail:
    (rx1151_rep, rx1151_pos, $I10, $P10) = rx1151_cur."!mark_fail"(0)
    lt rx1151_pos, -1, rx1151_done
    eq rx1151_pos, -1, rx1151_fail
    jump $I10
  rx1151_done:
    rx1151_cur."!cursor_fail"()
    if_null rx1151_debug, debug_883
    rx1151_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_883:
    .return (rx1151_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("260_1295994649.593") :method
.annotate 'line', 4
    $P1153 = self."!PREFIX__!subrule"("sigil", "")
    new $P1154, "ResizablePMCArray"
    push $P1154, $P1153
    .return ($P1154)
.end


.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("261_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1160_tgt
    .local int rx1160_pos
    .local int rx1160_off
    .local int rx1160_eos
    .local int rx1160_rep
    .local pmc rx1160_cur
    .local pmc rx1160_debug
    (rx1160_cur, rx1160_pos, rx1160_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1160_cur
    .local pmc match
    .lex "$/", match
    length rx1160_eos, rx1160_tgt
    gt rx1160_pos, rx1160_eos, rx1160_done
    set rx1160_off, 0
    lt rx1160_pos, 2, rx1160_start
    sub rx1160_off, rx1160_pos, 1
    substr rx1160_tgt, rx1160_tgt, rx1160_off
  rx1160_start:
    eq $I10, 1, rx1160_restart
    if_null rx1160_debug, debug_884
    rx1160_cur."!cursor_debug"("START", "semilist")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1164_done
    goto rxscan1164_scan
  rxscan1164_loop:
    ($P10) = rx1160_cur."from"()
    inc $P10
    set rx1160_pos, $P10
    ge rx1160_pos, rx1160_eos, rxscan1164_done
  rxscan1164_scan:
    set_addr $I10, rxscan1164_loop
    rx1160_cur."!mark_push"(0, rx1160_pos, $I10)
  rxscan1164_done:
.annotate 'line', 521
  # rx subrule "ws" subtype=method negate=
    rx1160_cur."!cursor_pos"(rx1160_pos)
    $P10 = rx1160_cur."ws"()
    unless $P10, rx1160_fail
    rx1160_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1160_cur."!cursor_pos"(rx1160_pos)
    $P10 = rx1160_cur."statement"()
    unless $P10, rx1160_fail
    rx1160_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1160_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1160_cur."!cursor_pos"(rx1160_pos)
    $P10 = rx1160_cur."ws"()
    unless $P10, rx1160_fail
    rx1160_pos = $P10."pos"()
  # rx pass
    rx1160_cur."!cursor_pass"(rx1160_pos, "semilist")
    if_null rx1160_debug, debug_885
    rx1160_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1160_pos)
  debug_885:
    .return (rx1160_cur)
  rx1160_restart:
.annotate 'line', 4
    if_null rx1160_debug, debug_886
    rx1160_cur."!cursor_debug"("NEXT", "semilist")
  debug_886:
  rx1160_fail:
    (rx1160_rep, rx1160_pos, $I10, $P10) = rx1160_cur."!mark_fail"(0)
    lt rx1160_pos, -1, rx1160_done
    eq rx1160_pos, -1, rx1160_fail
    jump $I10
  rx1160_done:
    rx1160_cur."!cursor_fail"()
    if_null rx1160_debug, debug_887
    rx1160_cur."!cursor_debug"("FAIL", "semilist")
  debug_887:
    .return (rx1160_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("262_1295994649.593") :method
.annotate 'line', 4
    $P1162 = self."!PREFIX__!subrule"("ws", "")
    new $P1163, "ResizablePMCArray"
    push $P1163, $P1162
    .return ($P1163)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1167"  :anon :subid("263_1295994649.593") :outer("11_1295994649.593")
.annotate 'line', 4
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post888") :outer("263_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P1168 = "263_1295994649.593" 
    .local pmc block
    set block, $P1168
.annotate 'line', 526
    get_hll_global $P1169, ["NQP"], "Grammar"
    $P1169."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 527
    get_hll_global $P1170, ["NQP"], "Grammar"
    $P1170."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 528
    get_hll_global $P1171, ["NQP"], "Grammar"
    $P1171."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 529
    get_hll_global $P1172, ["NQP"], "Grammar"
    $P1172."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 530
    get_hll_global $P1173, ["NQP"], "Grammar"
    $P1173."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 531
    get_hll_global $P1174, ["NQP"], "Grammar"
    $P1174."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 532
    get_hll_global $P1175, ["NQP"], "Grammar"
    $P1175."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 533
    get_hll_global $P1176, ["NQP"], "Grammar"
    $P1176."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 534
    get_hll_global $P1177, ["NQP"], "Grammar"
    $P1177."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 535
    get_hll_global $P1178, ["NQP"], "Grammar"
    $P1178."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 536
    get_hll_global $P1179, ["NQP"], "Grammar"
    $P1179."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 537
    get_hll_global $P1180, ["NQP"], "Grammar"
    $P1180."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 538
    get_hll_global $P1181, ["NQP"], "Grammar"
    $P1181."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 539
    get_hll_global $P1182, ["NQP"], "Grammar"
    $P1182."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 540
    get_hll_global $P1183, ["NQP"], "Grammar"
    $P1183."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("264_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1185_tgt
    .local int rx1185_pos
    .local int rx1185_off
    .local int rx1185_eos
    .local int rx1185_rep
    .local pmc rx1185_cur
    .local pmc rx1185_debug
    (rx1185_cur, rx1185_pos, rx1185_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1185_cur
    .local pmc match
    .lex "$/", match
    length rx1185_eos, rx1185_tgt
    gt rx1185_pos, rx1185_eos, rx1185_done
    set rx1185_off, 0
    lt rx1185_pos, 2, rx1185_start
    sub rx1185_off, rx1185_pos, 1
    substr rx1185_tgt, rx1185_tgt, rx1185_off
  rx1185_start:
    eq $I10, 1, rx1185_restart
    if_null rx1185_debug, debug_889
    rx1185_cur."!cursor_debug"("START", "infixish")
  debug_889:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1188_done
    goto rxscan1188_scan
  rxscan1188_loop:
    ($P10) = rx1185_cur."from"()
    inc $P10
    set rx1185_pos, $P10
    ge rx1185_pos, rx1185_eos, rxscan1188_done
  rxscan1188_scan:
    set_addr $I10, rxscan1188_loop
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  rxscan1188_done:
.annotate 'line', 544
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."infixstopper"()
    if $P10, rx1185_fail
  # rx subrule "infix" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."infix"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1185_pos = $P10."pos"()
  # rx pass
    rx1185_cur."!cursor_pass"(rx1185_pos, "infixish")
    if_null rx1185_debug, debug_890
    rx1185_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1185_pos)
  debug_890:
    .return (rx1185_cur)
  rx1185_restart:
.annotate 'line', 4
    if_null rx1185_debug, debug_891
    rx1185_cur."!cursor_debug"("NEXT", "infixish")
  debug_891:
  rx1185_fail:
    (rx1185_rep, rx1185_pos, $I10, $P10) = rx1185_cur."!mark_fail"(0)
    lt rx1185_pos, -1, rx1185_done
    eq rx1185_pos, -1, rx1185_fail
    jump $I10
  rx1185_done:
    rx1185_cur."!cursor_fail"()
    if_null rx1185_debug, debug_892
    rx1185_cur."!cursor_debug"("FAIL", "infixish")
  debug_892:
    .return (rx1185_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("265_1295994649.593") :method
.annotate 'line', 4
    new $P1187, "ResizablePMCArray"
    push $P1187, ""
    .return ($P1187)
.end


.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("266_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1190_tgt
    .local int rx1190_pos
    .local int rx1190_off
    .local int rx1190_eos
    .local int rx1190_rep
    .local pmc rx1190_cur
    .local pmc rx1190_debug
    (rx1190_cur, rx1190_pos, rx1190_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1190_cur
    .local pmc match
    .lex "$/", match
    length rx1190_eos, rx1190_tgt
    gt rx1190_pos, rx1190_eos, rx1190_done
    set rx1190_off, 0
    lt rx1190_pos, 2, rx1190_start
    sub rx1190_off, rx1190_pos, 1
    substr rx1190_tgt, rx1190_tgt, rx1190_off
  rx1190_start:
    eq $I10, 1, rx1190_restart
    if_null rx1190_debug, debug_893
    rx1190_cur."!cursor_debug"("START", "infixstopper")
  debug_893:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1193_done
    goto rxscan1193_scan
  rxscan1193_loop:
    ($P10) = rx1190_cur."from"()
    inc $P10
    set rx1190_pos, $P10
    ge rx1190_pos, rx1190_eos, rxscan1193_done
  rxscan1193_scan:
    set_addr $I10, rxscan1193_loop
    rx1190_cur."!mark_push"(0, rx1190_pos, $I10)
  rxscan1193_done:
.annotate 'line', 545
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1190_cur."!cursor_pos"(rx1190_pos)
    $P10 = rx1190_cur."lambda"()
    unless $P10, rx1190_fail
  # rx pass
    rx1190_cur."!cursor_pass"(rx1190_pos, "infixstopper")
    if_null rx1190_debug, debug_894
    rx1190_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1190_pos)
  debug_894:
    .return (rx1190_cur)
  rx1190_restart:
.annotate 'line', 4
    if_null rx1190_debug, debug_895
    rx1190_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_895:
  rx1190_fail:
    (rx1190_rep, rx1190_pos, $I10, $P10) = rx1190_cur."!mark_fail"(0)
    lt rx1190_pos, -1, rx1190_done
    eq rx1190_pos, -1, rx1190_fail
    jump $I10
  rx1190_done:
    rx1190_cur."!cursor_fail"()
    if_null rx1190_debug, debug_896
    rx1190_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_896:
    .return (rx1190_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("267_1295994649.593") :method
.annotate 'line', 4
    new $P1192, "ResizablePMCArray"
    push $P1192, ""
    .return ($P1192)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("268_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1195_tgt
    .local int rx1195_pos
    .local int rx1195_off
    .local int rx1195_eos
    .local int rx1195_rep
    .local pmc rx1195_cur
    .local pmc rx1195_debug
    (rx1195_cur, rx1195_pos, rx1195_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1195_cur
    .local pmc match
    .lex "$/", match
    length rx1195_eos, rx1195_tgt
    gt rx1195_pos, rx1195_eos, rx1195_done
    set rx1195_off, 0
    lt rx1195_pos, 2, rx1195_start
    sub rx1195_off, rx1195_pos, 1
    substr rx1195_tgt, rx1195_tgt, rx1195_off
  rx1195_start:
    eq $I10, 1, rx1195_restart
    if_null rx1195_debug, debug_897
    rx1195_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_897:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1199_done
    goto rxscan1199_scan
  rxscan1199_loop:
    ($P10) = rx1195_cur."from"()
    inc $P10
    set rx1195_pos, $P10
    ge rx1195_pos, rx1195_eos, rxscan1199_done
  rxscan1199_scan:
    set_addr $I10, rxscan1199_loop
    rx1195_cur."!mark_push"(0, rx1195_pos, $I10)
  rxscan1199_done:
.annotate 'line', 548
  # rx literal  "["
    add $I11, rx1195_pos, 1
    gt $I11, rx1195_eos, rx1195_fail
    sub $I11, rx1195_pos, rx1195_off
    ord $I11, rx1195_tgt, $I11
    ne $I11, 91, rx1195_fail
    add rx1195_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."ws"()
    unless $P10, rx1195_fail
    rx1195_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."EXPR"()
    unless $P10, rx1195_fail
    rx1195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1195_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1195_pos, 1
    gt $I11, rx1195_eos, rx1195_fail
    sub $I11, rx1195_pos, rx1195_off
    ord $I11, rx1195_tgt, $I11
    ne $I11, 93, rx1195_fail
    add rx1195_pos, 1
.annotate 'line', 549
  # rx subrule "O" subtype=capture negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."O"("%methodop")
    unless $P10, rx1195_fail
    rx1195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1195_pos = $P10."pos"()
.annotate 'line', 547
  # rx pass
    rx1195_cur."!cursor_pass"(rx1195_pos, "postcircumfix:sym<[ ]>")
    if_null rx1195_debug, debug_898
    rx1195_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1195_pos)
  debug_898:
    .return (rx1195_cur)
  rx1195_restart:
.annotate 'line', 4
    if_null rx1195_debug, debug_899
    rx1195_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_899:
  rx1195_fail:
    (rx1195_rep, rx1195_pos, $I10, $P10) = rx1195_cur."!mark_fail"(0)
    lt rx1195_pos, -1, rx1195_done
    eq rx1195_pos, -1, rx1195_fail
    jump $I10
  rx1195_done:
    rx1195_cur."!cursor_fail"()
    if_null rx1195_debug, debug_900
    rx1195_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_900:
    .return (rx1195_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("269_1295994649.593") :method
.annotate 'line', 4
    $P1197 = self."!PREFIX__!subrule"("ws", "[")
    new $P1198, "ResizablePMCArray"
    push $P1198, $P1197
    .return ($P1198)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("270_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1201_tgt
    .local int rx1201_pos
    .local int rx1201_off
    .local int rx1201_eos
    .local int rx1201_rep
    .local pmc rx1201_cur
    .local pmc rx1201_debug
    (rx1201_cur, rx1201_pos, rx1201_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1201_cur
    .local pmc match
    .lex "$/", match
    length rx1201_eos, rx1201_tgt
    gt rx1201_pos, rx1201_eos, rx1201_done
    set rx1201_off, 0
    lt rx1201_pos, 2, rx1201_start
    sub rx1201_off, rx1201_pos, 1
    substr rx1201_tgt, rx1201_tgt, rx1201_off
  rx1201_start:
    eq $I10, 1, rx1201_restart
    if_null rx1201_debug, debug_901
    rx1201_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_901:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1205_done
    goto rxscan1205_scan
  rxscan1205_loop:
    ($P10) = rx1201_cur."from"()
    inc $P10
    set rx1201_pos, $P10
    ge rx1201_pos, rx1201_eos, rxscan1205_done
  rxscan1205_scan:
    set_addr $I10, rxscan1205_loop
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  rxscan1205_done:
.annotate 'line', 553
  # rx literal  "{"
    add $I11, rx1201_pos, 1
    gt $I11, rx1201_eos, rx1201_fail
    sub $I11, rx1201_pos, rx1201_off
    ord $I11, rx1201_tgt, $I11
    ne $I11, 123, rx1201_fail
    add rx1201_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."ws"()
    unless $P10, rx1201_fail
    rx1201_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."EXPR"()
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1201_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1201_pos, 1
    gt $I11, rx1201_eos, rx1201_fail
    sub $I11, rx1201_pos, rx1201_off
    ord $I11, rx1201_tgt, $I11
    ne $I11, 125, rx1201_fail
    add rx1201_pos, 1
.annotate 'line', 554
  # rx subrule "O" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."O"("%methodop")
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1201_pos = $P10."pos"()
.annotate 'line', 552
  # rx pass
    rx1201_cur."!cursor_pass"(rx1201_pos, "postcircumfix:sym<{ }>")
    if_null rx1201_debug, debug_902
    rx1201_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1201_pos)
  debug_902:
    .return (rx1201_cur)
  rx1201_restart:
.annotate 'line', 4
    if_null rx1201_debug, debug_903
    rx1201_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_903:
  rx1201_fail:
    (rx1201_rep, rx1201_pos, $I10, $P10) = rx1201_cur."!mark_fail"(0)
    lt rx1201_pos, -1, rx1201_done
    eq rx1201_pos, -1, rx1201_fail
    jump $I10
  rx1201_done:
    rx1201_cur."!cursor_fail"()
    if_null rx1201_debug, debug_904
    rx1201_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_904:
    .return (rx1201_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("271_1295994649.593") :method
.annotate 'line', 4
    $P1203 = self."!PREFIX__!subrule"("ws", "{")
    new $P1204, "ResizablePMCArray"
    push $P1204, $P1203
    .return ($P1204)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("272_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1207_tgt
    .local int rx1207_pos
    .local int rx1207_off
    .local int rx1207_eos
    .local int rx1207_rep
    .local pmc rx1207_cur
    .local pmc rx1207_debug
    (rx1207_cur, rx1207_pos, rx1207_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1207_cur
    .local pmc match
    .lex "$/", match
    length rx1207_eos, rx1207_tgt
    gt rx1207_pos, rx1207_eos, rx1207_done
    set rx1207_off, 0
    lt rx1207_pos, 2, rx1207_start
    sub rx1207_off, rx1207_pos, 1
    substr rx1207_tgt, rx1207_tgt, rx1207_off
  rx1207_start:
    eq $I10, 1, rx1207_restart
    if_null rx1207_debug, debug_905
    rx1207_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1210_done
    goto rxscan1210_scan
  rxscan1210_loop:
    ($P10) = rx1207_cur."from"()
    inc $P10
    set rx1207_pos, $P10
    ge rx1207_pos, rx1207_eos, rxscan1210_done
  rxscan1210_scan:
    set_addr $I10, rxscan1210_loop
    rx1207_cur."!mark_push"(0, rx1207_pos, $I10)
  rxscan1210_done:
.annotate 'line', 558
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1207_pos, rx1207_off
    substr $S10, rx1207_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1207_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1207_cur."!cursor_pos"(rx1207_pos)
    $P10 = rx1207_cur."quote_EXPR"(":q")
    unless $P10, rx1207_fail
    rx1207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1207_pos = $P10."pos"()
.annotate 'line', 559
  # rx subrule "O" subtype=capture negate=
    rx1207_cur."!cursor_pos"(rx1207_pos)
    $P10 = rx1207_cur."O"("%methodop")
    unless $P10, rx1207_fail
    rx1207_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1207_pos = $P10."pos"()
.annotate 'line', 557
  # rx pass
    rx1207_cur."!cursor_pass"(rx1207_pos, "postcircumfix:sym<ang>")
    if_null rx1207_debug, debug_906
    rx1207_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1207_pos)
  debug_906:
    .return (rx1207_cur)
  rx1207_restart:
.annotate 'line', 4
    if_null rx1207_debug, debug_907
    rx1207_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_907:
  rx1207_fail:
    (rx1207_rep, rx1207_pos, $I10, $P10) = rx1207_cur."!mark_fail"(0)
    lt rx1207_pos, -1, rx1207_done
    eq rx1207_pos, -1, rx1207_fail
    jump $I10
  rx1207_done:
    rx1207_cur."!cursor_fail"()
    if_null rx1207_debug, debug_908
    rx1207_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_908:
    .return (rx1207_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("273_1295994649.593") :method
.annotate 'line', 4
    new $P1209, "ResizablePMCArray"
    push $P1209, "<"
    .return ($P1209)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("274_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1212_tgt
    .local int rx1212_pos
    .local int rx1212_off
    .local int rx1212_eos
    .local int rx1212_rep
    .local pmc rx1212_cur
    .local pmc rx1212_debug
    (rx1212_cur, rx1212_pos, rx1212_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1212_cur
    .local pmc match
    .lex "$/", match
    length rx1212_eos, rx1212_tgt
    gt rx1212_pos, rx1212_eos, rx1212_done
    set rx1212_off, 0
    lt rx1212_pos, 2, rx1212_start
    sub rx1212_off, rx1212_pos, 1
    substr rx1212_tgt, rx1212_tgt, rx1212_off
  rx1212_start:
    eq $I10, 1, rx1212_restart
    if_null rx1212_debug, debug_909
    rx1212_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1216_done
    goto rxscan1216_scan
  rxscan1216_loop:
    ($P10) = rx1212_cur."from"()
    inc $P10
    set rx1212_pos, $P10
    ge rx1212_pos, rx1212_eos, rxscan1216_done
  rxscan1216_scan:
    set_addr $I10, rxscan1216_loop
    rx1212_cur."!mark_push"(0, rx1212_pos, $I10)
  rxscan1216_done:
.annotate 'line', 563
  # rx literal  "("
    add $I11, rx1212_pos, 1
    gt $I11, rx1212_eos, rx1212_fail
    sub $I11, rx1212_pos, rx1212_off
    ord $I11, rx1212_tgt, $I11
    ne $I11, 40, rx1212_fail
    add rx1212_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1212_cur."!cursor_pos"(rx1212_pos)
    $P10 = rx1212_cur."ws"()
    unless $P10, rx1212_fail
    rx1212_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1212_cur."!cursor_pos"(rx1212_pos)
    $P10 = rx1212_cur."arglist"()
    unless $P10, rx1212_fail
    rx1212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1212_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1212_pos, 1
    gt $I11, rx1212_eos, rx1212_fail
    sub $I11, rx1212_pos, rx1212_off
    ord $I11, rx1212_tgt, $I11
    ne $I11, 41, rx1212_fail
    add rx1212_pos, 1
.annotate 'line', 564
  # rx subrule "O" subtype=capture negate=
    rx1212_cur."!cursor_pos"(rx1212_pos)
    $P10 = rx1212_cur."O"("%methodop")
    unless $P10, rx1212_fail
    rx1212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1212_pos = $P10."pos"()
.annotate 'line', 562
  # rx pass
    rx1212_cur."!cursor_pass"(rx1212_pos, "postcircumfix:sym<( )>")
    if_null rx1212_debug, debug_910
    rx1212_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1212_pos)
  debug_910:
    .return (rx1212_cur)
  rx1212_restart:
.annotate 'line', 4
    if_null rx1212_debug, debug_911
    rx1212_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_911:
  rx1212_fail:
    (rx1212_rep, rx1212_pos, $I10, $P10) = rx1212_cur."!mark_fail"(0)
    lt rx1212_pos, -1, rx1212_done
    eq rx1212_pos, -1, rx1212_fail
    jump $I10
  rx1212_done:
    rx1212_cur."!cursor_fail"()
    if_null rx1212_debug, debug_912
    rx1212_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_912:
    .return (rx1212_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("275_1295994649.593") :method
.annotate 'line', 4
    $P1214 = self."!PREFIX__!subrule"("ws", "(")
    new $P1215, "ResizablePMCArray"
    push $P1215, $P1214
    .return ($P1215)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("276_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1218_tgt
    .local int rx1218_pos
    .local int rx1218_off
    .local int rx1218_eos
    .local int rx1218_rep
    .local pmc rx1218_cur
    .local pmc rx1218_debug
    (rx1218_cur, rx1218_pos, rx1218_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1218_cur
    .local pmc match
    .lex "$/", match
    length rx1218_eos, rx1218_tgt
    gt rx1218_pos, rx1218_eos, rx1218_done
    set rx1218_off, 0
    lt rx1218_pos, 2, rx1218_start
    sub rx1218_off, rx1218_pos, 1
    substr rx1218_tgt, rx1218_tgt, rx1218_off
  rx1218_start:
    eq $I10, 1, rx1218_restart
    if_null rx1218_debug, debug_913
    rx1218_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1222_done
    goto rxscan1222_scan
  rxscan1222_loop:
    ($P10) = rx1218_cur."from"()
    inc $P10
    set rx1218_pos, $P10
    ge rx1218_pos, rx1218_eos, rxscan1222_done
  rxscan1222_scan:
    set_addr $I10, rxscan1222_loop
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxscan1222_done:
.annotate 'line', 567
  # rx subrule "dotty" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."dotty"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1218_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."O"("%methodop")
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1218_pos = $P10."pos"()
  # rx pass
    rx1218_cur."!cursor_pass"(rx1218_pos, "postfix:sym<.>")
    if_null rx1218_debug, debug_914
    rx1218_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1218_pos)
  debug_914:
    .return (rx1218_cur)
  rx1218_restart:
.annotate 'line', 4
    if_null rx1218_debug, debug_915
    rx1218_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_915:
  rx1218_fail:
    (rx1218_rep, rx1218_pos, $I10, $P10) = rx1218_cur."!mark_fail"(0)
    lt rx1218_pos, -1, rx1218_done
    eq rx1218_pos, -1, rx1218_fail
    jump $I10
  rx1218_done:
    rx1218_cur."!cursor_fail"()
    if_null rx1218_debug, debug_916
    rx1218_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_916:
    .return (rx1218_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("277_1295994649.593") :method
.annotate 'line', 4
    $P1220 = self."!PREFIX__!subrule"("dotty", "")
    new $P1221, "ResizablePMCArray"
    push $P1221, $P1220
    .return ($P1221)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("278_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1224_tgt
    .local int rx1224_pos
    .local int rx1224_off
    .local int rx1224_eos
    .local int rx1224_rep
    .local pmc rx1224_cur
    .local pmc rx1224_debug
    (rx1224_cur, rx1224_pos, rx1224_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1224_cur
    .local pmc match
    .lex "$/", match
    length rx1224_eos, rx1224_tgt
    gt rx1224_pos, rx1224_eos, rx1224_done
    set rx1224_off, 0
    lt rx1224_pos, 2, rx1224_start
    sub rx1224_off, rx1224_pos, 1
    substr rx1224_tgt, rx1224_tgt, rx1224_off
  rx1224_start:
    eq $I10, 1, rx1224_restart
    if_null rx1224_debug, debug_917
    rx1224_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1228_done
    goto rxscan1228_scan
  rxscan1228_loop:
    ($P10) = rx1224_cur."from"()
    inc $P10
    set rx1224_pos, $P10
    ge rx1224_pos, rx1224_eos, rxscan1228_done
  rxscan1228_scan:
    set_addr $I10, rxscan1228_loop
    rx1224_cur."!mark_push"(0, rx1224_pos, $I10)
  rxscan1228_done:
.annotate 'line', 569
  # rx subcapture "sym"
    set_addr $I10, rxcap_1229_fail
    rx1224_cur."!mark_push"(0, rx1224_pos, $I10)
  # rx literal  "++"
    add $I11, rx1224_pos, 2
    gt $I11, rx1224_eos, rx1224_fail
    sub $I11, rx1224_pos, rx1224_off
    substr $S10, rx1224_tgt, $I11, 2
    ne $S10, "++", rx1224_fail
    add rx1224_pos, 2
    set_addr $I10, rxcap_1229_fail
    ($I12, $I11) = rx1224_cur."!mark_peek"($I10)
    rx1224_cur."!cursor_pos"($I11)
    ($P10) = rx1224_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1224_pos, "")
    rx1224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1229_done
  rxcap_1229_fail:
    goto rx1224_fail
  rxcap_1229_done:
  # rx subrule "O" subtype=capture negate=
    rx1224_cur."!cursor_pos"(rx1224_pos)
    $P10 = rx1224_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1224_fail
    rx1224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1224_pos = $P10."pos"()
  # rx pass
    rx1224_cur."!cursor_pass"(rx1224_pos, "prefix:sym<++>")
    if_null rx1224_debug, debug_918
    rx1224_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1224_pos)
  debug_918:
    .return (rx1224_cur)
  rx1224_restart:
.annotate 'line', 4
    if_null rx1224_debug, debug_919
    rx1224_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_919:
  rx1224_fail:
    (rx1224_rep, rx1224_pos, $I10, $P10) = rx1224_cur."!mark_fail"(0)
    lt rx1224_pos, -1, rx1224_done
    eq rx1224_pos, -1, rx1224_fail
    jump $I10
  rx1224_done:
    rx1224_cur."!cursor_fail"()
    if_null rx1224_debug, debug_920
    rx1224_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_920:
    .return (rx1224_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("279_1295994649.593") :method
.annotate 'line', 4
    $P1226 = self."!PREFIX__!subrule"("O", "++")
    new $P1227, "ResizablePMCArray"
    push $P1227, $P1226
    .return ($P1227)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("280_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1231_tgt
    .local int rx1231_pos
    .local int rx1231_off
    .local int rx1231_eos
    .local int rx1231_rep
    .local pmc rx1231_cur
    .local pmc rx1231_debug
    (rx1231_cur, rx1231_pos, rx1231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1231_cur
    .local pmc match
    .lex "$/", match
    length rx1231_eos, rx1231_tgt
    gt rx1231_pos, rx1231_eos, rx1231_done
    set rx1231_off, 0
    lt rx1231_pos, 2, rx1231_start
    sub rx1231_off, rx1231_pos, 1
    substr rx1231_tgt, rx1231_tgt, rx1231_off
  rx1231_start:
    eq $I10, 1, rx1231_restart
    if_null rx1231_debug, debug_921
    rx1231_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1235_done
    goto rxscan1235_scan
  rxscan1235_loop:
    ($P10) = rx1231_cur."from"()
    inc $P10
    set rx1231_pos, $P10
    ge rx1231_pos, rx1231_eos, rxscan1235_done
  rxscan1235_scan:
    set_addr $I10, rxscan1235_loop
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
  rxscan1235_done:
.annotate 'line', 570
  # rx subcapture "sym"
    set_addr $I10, rxcap_1236_fail
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
  # rx literal  "--"
    add $I11, rx1231_pos, 2
    gt $I11, rx1231_eos, rx1231_fail
    sub $I11, rx1231_pos, rx1231_off
    substr $S10, rx1231_tgt, $I11, 2
    ne $S10, "--", rx1231_fail
    add rx1231_pos, 2
    set_addr $I10, rxcap_1236_fail
    ($I12, $I11) = rx1231_cur."!mark_peek"($I10)
    rx1231_cur."!cursor_pos"($I11)
    ($P10) = rx1231_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1231_pos, "")
    rx1231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1236_done
  rxcap_1236_fail:
    goto rx1231_fail
  rxcap_1236_done:
  # rx subrule "O" subtype=capture negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1231_fail
    rx1231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1231_pos = $P10."pos"()
  # rx pass
    rx1231_cur."!cursor_pass"(rx1231_pos, "prefix:sym<-->")
    if_null rx1231_debug, debug_922
    rx1231_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1231_pos)
  debug_922:
    .return (rx1231_cur)
  rx1231_restart:
.annotate 'line', 4
    if_null rx1231_debug, debug_923
    rx1231_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_923:
  rx1231_fail:
    (rx1231_rep, rx1231_pos, $I10, $P10) = rx1231_cur."!mark_fail"(0)
    lt rx1231_pos, -1, rx1231_done
    eq rx1231_pos, -1, rx1231_fail
    jump $I10
  rx1231_done:
    rx1231_cur."!cursor_fail"()
    if_null rx1231_debug, debug_924
    rx1231_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_924:
    .return (rx1231_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("281_1295994649.593") :method
.annotate 'line', 4
    $P1233 = self."!PREFIX__!subrule"("O", "--")
    new $P1234, "ResizablePMCArray"
    push $P1234, $P1233
    .return ($P1234)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("282_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1238_tgt
    .local int rx1238_pos
    .local int rx1238_off
    .local int rx1238_eos
    .local int rx1238_rep
    .local pmc rx1238_cur
    .local pmc rx1238_debug
    (rx1238_cur, rx1238_pos, rx1238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1238_cur
    .local pmc match
    .lex "$/", match
    length rx1238_eos, rx1238_tgt
    gt rx1238_pos, rx1238_eos, rx1238_done
    set rx1238_off, 0
    lt rx1238_pos, 2, rx1238_start
    sub rx1238_off, rx1238_pos, 1
    substr rx1238_tgt, rx1238_tgt, rx1238_off
  rx1238_start:
    eq $I10, 1, rx1238_restart
    if_null rx1238_debug, debug_925
    rx1238_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1242_done
    goto rxscan1242_scan
  rxscan1242_loop:
    ($P10) = rx1238_cur."from"()
    inc $P10
    set rx1238_pos, $P10
    ge rx1238_pos, rx1238_eos, rxscan1242_done
  rxscan1242_scan:
    set_addr $I10, rxscan1242_loop
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  rxscan1242_done:
.annotate 'line', 573
  # rx subcapture "sym"
    set_addr $I10, rxcap_1243_fail
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  # rx literal  "++"
    add $I11, rx1238_pos, 2
    gt $I11, rx1238_eos, rx1238_fail
    sub $I11, rx1238_pos, rx1238_off
    substr $S10, rx1238_tgt, $I11, 2
    ne $S10, "++", rx1238_fail
    add rx1238_pos, 2
    set_addr $I10, rxcap_1243_fail
    ($I12, $I11) = rx1238_cur."!mark_peek"($I10)
    rx1238_cur."!cursor_pos"($I11)
    ($P10) = rx1238_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1238_pos, "")
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1243_done
  rxcap_1243_fail:
    goto rx1238_fail
  rxcap_1243_done:
  # rx subrule "O" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."O"("%autoincrement")
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1238_pos = $P10."pos"()
  # rx pass
    rx1238_cur."!cursor_pass"(rx1238_pos, "postfix:sym<++>")
    if_null rx1238_debug, debug_926
    rx1238_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1238_pos)
  debug_926:
    .return (rx1238_cur)
  rx1238_restart:
.annotate 'line', 4
    if_null rx1238_debug, debug_927
    rx1238_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_927:
  rx1238_fail:
    (rx1238_rep, rx1238_pos, $I10, $P10) = rx1238_cur."!mark_fail"(0)
    lt rx1238_pos, -1, rx1238_done
    eq rx1238_pos, -1, rx1238_fail
    jump $I10
  rx1238_done:
    rx1238_cur."!cursor_fail"()
    if_null rx1238_debug, debug_928
    rx1238_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_928:
    .return (rx1238_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("283_1295994649.593") :method
.annotate 'line', 4
    $P1240 = self."!PREFIX__!subrule"("O", "++")
    new $P1241, "ResizablePMCArray"
    push $P1241, $P1240
    .return ($P1241)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("284_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1245_tgt
    .local int rx1245_pos
    .local int rx1245_off
    .local int rx1245_eos
    .local int rx1245_rep
    .local pmc rx1245_cur
    .local pmc rx1245_debug
    (rx1245_cur, rx1245_pos, rx1245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1245_cur
    .local pmc match
    .lex "$/", match
    length rx1245_eos, rx1245_tgt
    gt rx1245_pos, rx1245_eos, rx1245_done
    set rx1245_off, 0
    lt rx1245_pos, 2, rx1245_start
    sub rx1245_off, rx1245_pos, 1
    substr rx1245_tgt, rx1245_tgt, rx1245_off
  rx1245_start:
    eq $I10, 1, rx1245_restart
    if_null rx1245_debug, debug_929
    rx1245_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_929:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1249_done
    goto rxscan1249_scan
  rxscan1249_loop:
    ($P10) = rx1245_cur."from"()
    inc $P10
    set rx1245_pos, $P10
    ge rx1245_pos, rx1245_eos, rxscan1249_done
  rxscan1249_scan:
    set_addr $I10, rxscan1249_loop
    rx1245_cur."!mark_push"(0, rx1245_pos, $I10)
  rxscan1249_done:
.annotate 'line', 574
  # rx subcapture "sym"
    set_addr $I10, rxcap_1250_fail
    rx1245_cur."!mark_push"(0, rx1245_pos, $I10)
  # rx literal  "--"
    add $I11, rx1245_pos, 2
    gt $I11, rx1245_eos, rx1245_fail
    sub $I11, rx1245_pos, rx1245_off
    substr $S10, rx1245_tgt, $I11, 2
    ne $S10, "--", rx1245_fail
    add rx1245_pos, 2
    set_addr $I10, rxcap_1250_fail
    ($I12, $I11) = rx1245_cur."!mark_peek"($I10)
    rx1245_cur."!cursor_pos"($I11)
    ($P10) = rx1245_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1245_pos, "")
    rx1245_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1250_done
  rxcap_1250_fail:
    goto rx1245_fail
  rxcap_1250_done:
  # rx subrule "O" subtype=capture negate=
    rx1245_cur."!cursor_pos"(rx1245_pos)
    $P10 = rx1245_cur."O"("%autoincrement")
    unless $P10, rx1245_fail
    rx1245_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1245_pos = $P10."pos"()
  # rx pass
    rx1245_cur."!cursor_pass"(rx1245_pos, "postfix:sym<-->")
    if_null rx1245_debug, debug_930
    rx1245_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1245_pos)
  debug_930:
    .return (rx1245_cur)
  rx1245_restart:
.annotate 'line', 4
    if_null rx1245_debug, debug_931
    rx1245_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_931:
  rx1245_fail:
    (rx1245_rep, rx1245_pos, $I10, $P10) = rx1245_cur."!mark_fail"(0)
    lt rx1245_pos, -1, rx1245_done
    eq rx1245_pos, -1, rx1245_fail
    jump $I10
  rx1245_done:
    rx1245_cur."!cursor_fail"()
    if_null rx1245_debug, debug_932
    rx1245_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_932:
    .return (rx1245_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("285_1295994649.593") :method
.annotate 'line', 4
    $P1247 = self."!PREFIX__!subrule"("O", "--")
    new $P1248, "ResizablePMCArray"
    push $P1248, $P1247
    .return ($P1248)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("286_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_933
    rx1252_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1256_done
    goto rxscan1256_scan
  rxscan1256_loop:
    ($P10) = rx1252_cur."from"()
    inc $P10
    set rx1252_pos, $P10
    ge rx1252_pos, rx1252_eos, rxscan1256_done
  rxscan1256_scan:
    set_addr $I10, rxscan1256_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1256_done:
.annotate 'line', 576
  # rx subcapture "sym"
    set_addr $I10, rxcap_1257_fail
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  # rx literal  "**"
    add $I11, rx1252_pos, 2
    gt $I11, rx1252_eos, rx1252_fail
    sub $I11, rx1252_pos, rx1252_off
    substr $S10, rx1252_tgt, $I11, 2
    ne $S10, "**", rx1252_fail
    add rx1252_pos, 2
    set_addr $I10, rxcap_1257_fail
    ($I12, $I11) = rx1252_cur."!mark_peek"($I10)
    rx1252_cur."!cursor_pos"($I11)
    ($P10) = rx1252_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1252_pos, "")
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1257_done
  rxcap_1257_fail:
    goto rx1252_fail
  rxcap_1257_done:
  # rx subrule "O" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1252_pos = $P10."pos"()
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "infix:sym<**>")
    if_null rx1252_debug, debug_934
    rx1252_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1252_pos)
  debug_934:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 4
    if_null rx1252_debug, debug_935
    rx1252_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_935:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_936
    rx1252_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_936:
    .return (rx1252_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("287_1295994649.593") :method
.annotate 'line', 4
    $P1254 = self."!PREFIX__!subrule"("O", "**")
    new $P1255, "ResizablePMCArray"
    push $P1255, $P1254
    .return ($P1255)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("288_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1259_tgt
    .local int rx1259_pos
    .local int rx1259_off
    .local int rx1259_eos
    .local int rx1259_rep
    .local pmc rx1259_cur
    .local pmc rx1259_debug
    (rx1259_cur, rx1259_pos, rx1259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1259_cur
    .local pmc match
    .lex "$/", match
    length rx1259_eos, rx1259_tgt
    gt rx1259_pos, rx1259_eos, rx1259_done
    set rx1259_off, 0
    lt rx1259_pos, 2, rx1259_start
    sub rx1259_off, rx1259_pos, 1
    substr rx1259_tgt, rx1259_tgt, rx1259_off
  rx1259_start:
    eq $I10, 1, rx1259_restart
    if_null rx1259_debug, debug_937
    rx1259_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1263_done
    goto rxscan1263_scan
  rxscan1263_loop:
    ($P10) = rx1259_cur."from"()
    inc $P10
    set rx1259_pos, $P10
    ge rx1259_pos, rx1259_eos, rxscan1263_done
  rxscan1263_scan:
    set_addr $I10, rxscan1263_loop
    rx1259_cur."!mark_push"(0, rx1259_pos, $I10)
  rxscan1263_done:
.annotate 'line', 578
  # rx subcapture "sym"
    set_addr $I10, rxcap_1264_fail
    rx1259_cur."!mark_push"(0, rx1259_pos, $I10)
  # rx literal  "+"
    add $I11, rx1259_pos, 1
    gt $I11, rx1259_eos, rx1259_fail
    sub $I11, rx1259_pos, rx1259_off
    ord $I11, rx1259_tgt, $I11
    ne $I11, 43, rx1259_fail
    add rx1259_pos, 1
    set_addr $I10, rxcap_1264_fail
    ($I12, $I11) = rx1259_cur."!mark_peek"($I10)
    rx1259_cur."!cursor_pos"($I11)
    ($P10) = rx1259_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1259_pos, "")
    rx1259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1264_done
  rxcap_1264_fail:
    goto rx1259_fail
  rxcap_1264_done:
  # rx subrule "O" subtype=capture negate=
    rx1259_cur."!cursor_pos"(rx1259_pos)
    $P10 = rx1259_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1259_fail
    rx1259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1259_pos = $P10."pos"()
  # rx pass
    rx1259_cur."!cursor_pass"(rx1259_pos, "prefix:sym<+>")
    if_null rx1259_debug, debug_938
    rx1259_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1259_pos)
  debug_938:
    .return (rx1259_cur)
  rx1259_restart:
.annotate 'line', 4
    if_null rx1259_debug, debug_939
    rx1259_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_939:
  rx1259_fail:
    (rx1259_rep, rx1259_pos, $I10, $P10) = rx1259_cur."!mark_fail"(0)
    lt rx1259_pos, -1, rx1259_done
    eq rx1259_pos, -1, rx1259_fail
    jump $I10
  rx1259_done:
    rx1259_cur."!cursor_fail"()
    if_null rx1259_debug, debug_940
    rx1259_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_940:
    .return (rx1259_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("289_1295994649.593") :method
.annotate 'line', 4
    $P1261 = self."!PREFIX__!subrule"("O", "+")
    new $P1262, "ResizablePMCArray"
    push $P1262, $P1261
    .return ($P1262)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("290_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1266_tgt
    .local int rx1266_pos
    .local int rx1266_off
    .local int rx1266_eos
    .local int rx1266_rep
    .local pmc rx1266_cur
    .local pmc rx1266_debug
    (rx1266_cur, rx1266_pos, rx1266_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1266_cur
    .local pmc match
    .lex "$/", match
    length rx1266_eos, rx1266_tgt
    gt rx1266_pos, rx1266_eos, rx1266_done
    set rx1266_off, 0
    lt rx1266_pos, 2, rx1266_start
    sub rx1266_off, rx1266_pos, 1
    substr rx1266_tgt, rx1266_tgt, rx1266_off
  rx1266_start:
    eq $I10, 1, rx1266_restart
    if_null rx1266_debug, debug_941
    rx1266_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1270_done
    goto rxscan1270_scan
  rxscan1270_loop:
    ($P10) = rx1266_cur."from"()
    inc $P10
    set rx1266_pos, $P10
    ge rx1266_pos, rx1266_eos, rxscan1270_done
  rxscan1270_scan:
    set_addr $I10, rxscan1270_loop
    rx1266_cur."!mark_push"(0, rx1266_pos, $I10)
  rxscan1270_done:
.annotate 'line', 579
  # rx subcapture "sym"
    set_addr $I10, rxcap_1271_fail
    rx1266_cur."!mark_push"(0, rx1266_pos, $I10)
  # rx literal  "~"
    add $I11, rx1266_pos, 1
    gt $I11, rx1266_eos, rx1266_fail
    sub $I11, rx1266_pos, rx1266_off
    ord $I11, rx1266_tgt, $I11
    ne $I11, 126, rx1266_fail
    add rx1266_pos, 1
    set_addr $I10, rxcap_1271_fail
    ($I12, $I11) = rx1266_cur."!mark_peek"($I10)
    rx1266_cur."!cursor_pos"($I11)
    ($P10) = rx1266_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1266_pos, "")
    rx1266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1271_done
  rxcap_1271_fail:
    goto rx1266_fail
  rxcap_1271_done:
  # rx subrule "O" subtype=capture negate=
    rx1266_cur."!cursor_pos"(rx1266_pos)
    $P10 = rx1266_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1266_fail
    rx1266_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1266_pos = $P10."pos"()
  # rx pass
    rx1266_cur."!cursor_pass"(rx1266_pos, "prefix:sym<~>")
    if_null rx1266_debug, debug_942
    rx1266_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1266_pos)
  debug_942:
    .return (rx1266_cur)
  rx1266_restart:
.annotate 'line', 4
    if_null rx1266_debug, debug_943
    rx1266_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_943:
  rx1266_fail:
    (rx1266_rep, rx1266_pos, $I10, $P10) = rx1266_cur."!mark_fail"(0)
    lt rx1266_pos, -1, rx1266_done
    eq rx1266_pos, -1, rx1266_fail
    jump $I10
  rx1266_done:
    rx1266_cur."!cursor_fail"()
    if_null rx1266_debug, debug_944
    rx1266_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_944:
    .return (rx1266_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("291_1295994649.593") :method
.annotate 'line', 4
    $P1268 = self."!PREFIX__!subrule"("O", "~")
    new $P1269, "ResizablePMCArray"
    push $P1269, $P1268
    .return ($P1269)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("292_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1273_tgt
    .local int rx1273_pos
    .local int rx1273_off
    .local int rx1273_eos
    .local int rx1273_rep
    .local pmc rx1273_cur
    .local pmc rx1273_debug
    (rx1273_cur, rx1273_pos, rx1273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1273_cur
    .local pmc match
    .lex "$/", match
    length rx1273_eos, rx1273_tgt
    gt rx1273_pos, rx1273_eos, rx1273_done
    set rx1273_off, 0
    lt rx1273_pos, 2, rx1273_start
    sub rx1273_off, rx1273_pos, 1
    substr rx1273_tgt, rx1273_tgt, rx1273_off
  rx1273_start:
    eq $I10, 1, rx1273_restart
    if_null rx1273_debug, debug_945
    rx1273_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1276_done
    goto rxscan1276_scan
  rxscan1276_loop:
    ($P10) = rx1273_cur."from"()
    inc $P10
    set rx1273_pos, $P10
    ge rx1273_pos, rx1273_eos, rxscan1276_done
  rxscan1276_scan:
    set_addr $I10, rxscan1276_loop
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  rxscan1276_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1277_fail
    rx1273_cur."!mark_push"(0, rx1273_pos, $I10)
  # rx literal  "-"
    add $I11, rx1273_pos, 1
    gt $I11, rx1273_eos, rx1273_fail
    sub $I11, rx1273_pos, rx1273_off
    ord $I11, rx1273_tgt, $I11
    ne $I11, 45, rx1273_fail
    add rx1273_pos, 1
    set_addr $I10, rxcap_1277_fail
    ($I12, $I11) = rx1273_cur."!mark_peek"($I10)
    rx1273_cur."!cursor_pos"($I11)
    ($P10) = rx1273_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1273_pos, "")
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1277_done
  rxcap_1277_fail:
    goto rx1273_fail
  rxcap_1277_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1273_pos, rx1273_off
    substr $S10, rx1273_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1273_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."number"()
    if $P10, rx1273_fail
  # rx subrule "O" subtype=capture negate=
    rx1273_cur."!cursor_pos"(rx1273_pos)
    $P10 = rx1273_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1273_fail
    rx1273_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1273_pos = $P10."pos"()
  # rx pass
    rx1273_cur."!cursor_pass"(rx1273_pos, "prefix:sym<->")
    if_null rx1273_debug, debug_946
    rx1273_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1273_pos)
  debug_946:
    .return (rx1273_cur)
  rx1273_restart:
.annotate 'line', 4
    if_null rx1273_debug, debug_947
    rx1273_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_947:
  rx1273_fail:
    (rx1273_rep, rx1273_pos, $I10, $P10) = rx1273_cur."!mark_fail"(0)
    lt rx1273_pos, -1, rx1273_done
    eq rx1273_pos, -1, rx1273_fail
    jump $I10
  rx1273_done:
    rx1273_cur."!cursor_fail"()
    if_null rx1273_debug, debug_948
    rx1273_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_948:
    .return (rx1273_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("293_1295994649.593") :method
.annotate 'line', 4
    new $P1275, "ResizablePMCArray"
    push $P1275, "-"
    .return ($P1275)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("294_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1279_tgt
    .local int rx1279_pos
    .local int rx1279_off
    .local int rx1279_eos
    .local int rx1279_rep
    .local pmc rx1279_cur
    .local pmc rx1279_debug
    (rx1279_cur, rx1279_pos, rx1279_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1279_cur
    .local pmc match
    .lex "$/", match
    length rx1279_eos, rx1279_tgt
    gt rx1279_pos, rx1279_eos, rx1279_done
    set rx1279_off, 0
    lt rx1279_pos, 2, rx1279_start
    sub rx1279_off, rx1279_pos, 1
    substr rx1279_tgt, rx1279_tgt, rx1279_off
  rx1279_start:
    eq $I10, 1, rx1279_restart
    if_null rx1279_debug, debug_949
    rx1279_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1283_done
    goto rxscan1283_scan
  rxscan1283_loop:
    ($P10) = rx1279_cur."from"()
    inc $P10
    set rx1279_pos, $P10
    ge rx1279_pos, rx1279_eos, rxscan1283_done
  rxscan1283_scan:
    set_addr $I10, rxscan1283_loop
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxscan1283_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1284_fail
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  # rx literal  "?"
    add $I11, rx1279_pos, 1
    gt $I11, rx1279_eos, rx1279_fail
    sub $I11, rx1279_pos, rx1279_off
    ord $I11, rx1279_tgt, $I11
    ne $I11, 63, rx1279_fail
    add rx1279_pos, 1
    set_addr $I10, rxcap_1284_fail
    ($I12, $I11) = rx1279_cur."!mark_peek"($I10)
    rx1279_cur."!cursor_pos"($I11)
    ($P10) = rx1279_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1279_pos, "")
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1284_done
  rxcap_1284_fail:
    goto rx1279_fail
  rxcap_1284_done:
  # rx subrule "O" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1279_pos = $P10."pos"()
  # rx pass
    rx1279_cur."!cursor_pass"(rx1279_pos, "prefix:sym<?>")
    if_null rx1279_debug, debug_950
    rx1279_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1279_pos)
  debug_950:
    .return (rx1279_cur)
  rx1279_restart:
.annotate 'line', 4
    if_null rx1279_debug, debug_951
    rx1279_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_951:
  rx1279_fail:
    (rx1279_rep, rx1279_pos, $I10, $P10) = rx1279_cur."!mark_fail"(0)
    lt rx1279_pos, -1, rx1279_done
    eq rx1279_pos, -1, rx1279_fail
    jump $I10
  rx1279_done:
    rx1279_cur."!cursor_fail"()
    if_null rx1279_debug, debug_952
    rx1279_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_952:
    .return (rx1279_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("295_1295994649.593") :method
.annotate 'line', 4
    $P1281 = self."!PREFIX__!subrule"("O", "?")
    new $P1282, "ResizablePMCArray"
    push $P1282, $P1281
    .return ($P1282)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("296_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1286_tgt
    .local int rx1286_pos
    .local int rx1286_off
    .local int rx1286_eos
    .local int rx1286_rep
    .local pmc rx1286_cur
    .local pmc rx1286_debug
    (rx1286_cur, rx1286_pos, rx1286_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1286_cur
    .local pmc match
    .lex "$/", match
    length rx1286_eos, rx1286_tgt
    gt rx1286_pos, rx1286_eos, rx1286_done
    set rx1286_off, 0
    lt rx1286_pos, 2, rx1286_start
    sub rx1286_off, rx1286_pos, 1
    substr rx1286_tgt, rx1286_tgt, rx1286_off
  rx1286_start:
    eq $I10, 1, rx1286_restart
    if_null rx1286_debug, debug_953
    rx1286_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1290_done
    goto rxscan1290_scan
  rxscan1290_loop:
    ($P10) = rx1286_cur."from"()
    inc $P10
    set rx1286_pos, $P10
    ge rx1286_pos, rx1286_eos, rxscan1290_done
  rxscan1290_scan:
    set_addr $I10, rxscan1290_loop
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  rxscan1290_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1291_fail
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  # rx literal  "!"
    add $I11, rx1286_pos, 1
    gt $I11, rx1286_eos, rx1286_fail
    sub $I11, rx1286_pos, rx1286_off
    ord $I11, rx1286_tgt, $I11
    ne $I11, 33, rx1286_fail
    add rx1286_pos, 1
    set_addr $I10, rxcap_1291_fail
    ($I12, $I11) = rx1286_cur."!mark_peek"($I10)
    rx1286_cur."!cursor_pos"($I11)
    ($P10) = rx1286_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1286_pos, "")
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1291_done
  rxcap_1291_fail:
    goto rx1286_fail
  rxcap_1291_done:
  # rx subrule "O" subtype=capture negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1286_fail
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1286_pos = $P10."pos"()
  # rx pass
    rx1286_cur."!cursor_pass"(rx1286_pos, "prefix:sym<!>")
    if_null rx1286_debug, debug_954
    rx1286_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1286_pos)
  debug_954:
    .return (rx1286_cur)
  rx1286_restart:
.annotate 'line', 4
    if_null rx1286_debug, debug_955
    rx1286_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_955:
  rx1286_fail:
    (rx1286_rep, rx1286_pos, $I10, $P10) = rx1286_cur."!mark_fail"(0)
    lt rx1286_pos, -1, rx1286_done
    eq rx1286_pos, -1, rx1286_fail
    jump $I10
  rx1286_done:
    rx1286_cur."!cursor_fail"()
    if_null rx1286_debug, debug_956
    rx1286_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_956:
    .return (rx1286_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("297_1295994649.593") :method
.annotate 'line', 4
    $P1288 = self."!PREFIX__!subrule"("O", "!")
    new $P1289, "ResizablePMCArray"
    push $P1289, $P1288
    .return ($P1289)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("298_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1293_tgt
    .local int rx1293_pos
    .local int rx1293_off
    .local int rx1293_eos
    .local int rx1293_rep
    .local pmc rx1293_cur
    .local pmc rx1293_debug
    (rx1293_cur, rx1293_pos, rx1293_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1293_cur
    .local pmc match
    .lex "$/", match
    length rx1293_eos, rx1293_tgt
    gt rx1293_pos, rx1293_eos, rx1293_done
    set rx1293_off, 0
    lt rx1293_pos, 2, rx1293_start
    sub rx1293_off, rx1293_pos, 1
    substr rx1293_tgt, rx1293_tgt, rx1293_off
  rx1293_start:
    eq $I10, 1, rx1293_restart
    if_null rx1293_debug, debug_957
    rx1293_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1297_done
    goto rxscan1297_scan
  rxscan1297_loop:
    ($P10) = rx1293_cur."from"()
    inc $P10
    set rx1293_pos, $P10
    ge rx1293_pos, rx1293_eos, rxscan1297_done
  rxscan1297_scan:
    set_addr $I10, rxscan1297_loop
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  rxscan1297_done:
.annotate 'line', 583
  # rx subcapture "sym"
    set_addr $I10, rxcap_1298_fail
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  # rx literal  "|"
    add $I11, rx1293_pos, 1
    gt $I11, rx1293_eos, rx1293_fail
    sub $I11, rx1293_pos, rx1293_off
    ord $I11, rx1293_tgt, $I11
    ne $I11, 124, rx1293_fail
    add rx1293_pos, 1
    set_addr $I10, rxcap_1298_fail
    ($I12, $I11) = rx1293_cur."!mark_peek"($I10)
    rx1293_cur."!cursor_pos"($I11)
    ($P10) = rx1293_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1293_pos, "")
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1298_done
  rxcap_1298_fail:
    goto rx1293_fail
  rxcap_1298_done:
  # rx subrule "O" subtype=capture negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."O"("%symbolic_unary")
    unless $P10, rx1293_fail
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1293_pos = $P10."pos"()
  # rx pass
    rx1293_cur."!cursor_pass"(rx1293_pos, "prefix:sym<|>")
    if_null rx1293_debug, debug_958
    rx1293_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1293_pos)
  debug_958:
    .return (rx1293_cur)
  rx1293_restart:
.annotate 'line', 4
    if_null rx1293_debug, debug_959
    rx1293_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_959:
  rx1293_fail:
    (rx1293_rep, rx1293_pos, $I10, $P10) = rx1293_cur."!mark_fail"(0)
    lt rx1293_pos, -1, rx1293_done
    eq rx1293_pos, -1, rx1293_fail
    jump $I10
  rx1293_done:
    rx1293_cur."!cursor_fail"()
    if_null rx1293_debug, debug_960
    rx1293_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_960:
    .return (rx1293_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("299_1295994649.593") :method
.annotate 'line', 4
    $P1295 = self."!PREFIX__!subrule"("O", "|")
    new $P1296, "ResizablePMCArray"
    push $P1296, $P1295
    .return ($P1296)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("300_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1300_tgt
    .local int rx1300_pos
    .local int rx1300_off
    .local int rx1300_eos
    .local int rx1300_rep
    .local pmc rx1300_cur
    .local pmc rx1300_debug
    (rx1300_cur, rx1300_pos, rx1300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1300_cur
    .local pmc match
    .lex "$/", match
    length rx1300_eos, rx1300_tgt
    gt rx1300_pos, rx1300_eos, rx1300_done
    set rx1300_off, 0
    lt rx1300_pos, 2, rx1300_start
    sub rx1300_off, rx1300_pos, 1
    substr rx1300_tgt, rx1300_tgt, rx1300_off
  rx1300_start:
    eq $I10, 1, rx1300_restart
    if_null rx1300_debug, debug_961
    rx1300_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1304_done
    goto rxscan1304_scan
  rxscan1304_loop:
    ($P10) = rx1300_cur."from"()
    inc $P10
    set rx1300_pos, $P10
    ge rx1300_pos, rx1300_eos, rxscan1304_done
  rxscan1304_scan:
    set_addr $I10, rxscan1304_loop
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  rxscan1304_done:
.annotate 'line', 585
  # rx subcapture "sym"
    set_addr $I10, rxcap_1305_fail
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  # rx literal  "*"
    add $I11, rx1300_pos, 1
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    ord $I11, rx1300_tgt, $I11
    ne $I11, 42, rx1300_fail
    add rx1300_pos, 1
    set_addr $I10, rxcap_1305_fail
    ($I12, $I11) = rx1300_cur."!mark_peek"($I10)
    rx1300_cur."!cursor_pos"($I11)
    ($P10) = rx1300_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1300_pos, "")
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1305_done
  rxcap_1305_fail:
    goto rx1300_fail
  rxcap_1305_done:
  # rx subrule "O" subtype=capture negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1300_fail
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1300_pos = $P10."pos"()
  # rx pass
    rx1300_cur."!cursor_pass"(rx1300_pos, "infix:sym<*>")
    if_null rx1300_debug, debug_962
    rx1300_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1300_pos)
  debug_962:
    .return (rx1300_cur)
  rx1300_restart:
.annotate 'line', 4
    if_null rx1300_debug, debug_963
    rx1300_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_963:
  rx1300_fail:
    (rx1300_rep, rx1300_pos, $I10, $P10) = rx1300_cur."!mark_fail"(0)
    lt rx1300_pos, -1, rx1300_done
    eq rx1300_pos, -1, rx1300_fail
    jump $I10
  rx1300_done:
    rx1300_cur."!cursor_fail"()
    if_null rx1300_debug, debug_964
    rx1300_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_964:
    .return (rx1300_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("301_1295994649.593") :method
.annotate 'line', 4
    $P1302 = self."!PREFIX__!subrule"("O", "*")
    new $P1303, "ResizablePMCArray"
    push $P1303, $P1302
    .return ($P1303)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("302_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1307_tgt
    .local int rx1307_pos
    .local int rx1307_off
    .local int rx1307_eos
    .local int rx1307_rep
    .local pmc rx1307_cur
    .local pmc rx1307_debug
    (rx1307_cur, rx1307_pos, rx1307_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1307_cur
    .local pmc match
    .lex "$/", match
    length rx1307_eos, rx1307_tgt
    gt rx1307_pos, rx1307_eos, rx1307_done
    set rx1307_off, 0
    lt rx1307_pos, 2, rx1307_start
    sub rx1307_off, rx1307_pos, 1
    substr rx1307_tgt, rx1307_tgt, rx1307_off
  rx1307_start:
    eq $I10, 1, rx1307_restart
    if_null rx1307_debug, debug_965
    rx1307_cur."!cursor_debug"("START", "infix:sym</>")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1311_done
    goto rxscan1311_scan
  rxscan1311_loop:
    ($P10) = rx1307_cur."from"()
    inc $P10
    set rx1307_pos, $P10
    ge rx1307_pos, rx1307_eos, rxscan1311_done
  rxscan1311_scan:
    set_addr $I10, rxscan1311_loop
    rx1307_cur."!mark_push"(0, rx1307_pos, $I10)
  rxscan1311_done:
.annotate 'line', 586
  # rx subcapture "sym"
    set_addr $I10, rxcap_1312_fail
    rx1307_cur."!mark_push"(0, rx1307_pos, $I10)
  # rx literal  "/"
    add $I11, rx1307_pos, 1
    gt $I11, rx1307_eos, rx1307_fail
    sub $I11, rx1307_pos, rx1307_off
    ord $I11, rx1307_tgt, $I11
    ne $I11, 47, rx1307_fail
    add rx1307_pos, 1
    set_addr $I10, rxcap_1312_fail
    ($I12, $I11) = rx1307_cur."!mark_peek"($I10)
    rx1307_cur."!cursor_pos"($I11)
    ($P10) = rx1307_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1307_pos, "")
    rx1307_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1312_done
  rxcap_1312_fail:
    goto rx1307_fail
  rxcap_1312_done:
  # rx subrule "O" subtype=capture negate=
    rx1307_cur."!cursor_pos"(rx1307_pos)
    $P10 = rx1307_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1307_fail
    rx1307_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1307_pos = $P10."pos"()
  # rx pass
    rx1307_cur."!cursor_pass"(rx1307_pos, "infix:sym</>")
    if_null rx1307_debug, debug_966
    rx1307_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1307_pos)
  debug_966:
    .return (rx1307_cur)
  rx1307_restart:
.annotate 'line', 4
    if_null rx1307_debug, debug_967
    rx1307_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_967:
  rx1307_fail:
    (rx1307_rep, rx1307_pos, $I10, $P10) = rx1307_cur."!mark_fail"(0)
    lt rx1307_pos, -1, rx1307_done
    eq rx1307_pos, -1, rx1307_fail
    jump $I10
  rx1307_done:
    rx1307_cur."!cursor_fail"()
    if_null rx1307_debug, debug_968
    rx1307_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_968:
    .return (rx1307_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("303_1295994649.593") :method
.annotate 'line', 4
    $P1309 = self."!PREFIX__!subrule"("O", "/")
    new $P1310, "ResizablePMCArray"
    push $P1310, $P1309
    .return ($P1310)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("304_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1314_tgt
    .local int rx1314_pos
    .local int rx1314_off
    .local int rx1314_eos
    .local int rx1314_rep
    .local pmc rx1314_cur
    .local pmc rx1314_debug
    (rx1314_cur, rx1314_pos, rx1314_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1314_cur
    .local pmc match
    .lex "$/", match
    length rx1314_eos, rx1314_tgt
    gt rx1314_pos, rx1314_eos, rx1314_done
    set rx1314_off, 0
    lt rx1314_pos, 2, rx1314_start
    sub rx1314_off, rx1314_pos, 1
    substr rx1314_tgt, rx1314_tgt, rx1314_off
  rx1314_start:
    eq $I10, 1, rx1314_restart
    if_null rx1314_debug, debug_969
    rx1314_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1318_done
    goto rxscan1318_scan
  rxscan1318_loop:
    ($P10) = rx1314_cur."from"()
    inc $P10
    set rx1314_pos, $P10
    ge rx1314_pos, rx1314_eos, rxscan1318_done
  rxscan1318_scan:
    set_addr $I10, rxscan1318_loop
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  rxscan1318_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1319_fail
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  # rx literal  "%"
    add $I11, rx1314_pos, 1
    gt $I11, rx1314_eos, rx1314_fail
    sub $I11, rx1314_pos, rx1314_off
    ord $I11, rx1314_tgt, $I11
    ne $I11, 37, rx1314_fail
    add rx1314_pos, 1
    set_addr $I10, rxcap_1319_fail
    ($I12, $I11) = rx1314_cur."!mark_peek"($I10)
    rx1314_cur."!cursor_pos"($I11)
    ($P10) = rx1314_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1314_pos, "")
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1319_done
  rxcap_1319_fail:
    goto rx1314_fail
  rxcap_1319_done:
  # rx subrule "O" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1314_pos = $P10."pos"()
  # rx pass
    rx1314_cur."!cursor_pass"(rx1314_pos, "infix:sym<%>")
    if_null rx1314_debug, debug_970
    rx1314_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1314_pos)
  debug_970:
    .return (rx1314_cur)
  rx1314_restart:
.annotate 'line', 4
    if_null rx1314_debug, debug_971
    rx1314_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_971:
  rx1314_fail:
    (rx1314_rep, rx1314_pos, $I10, $P10) = rx1314_cur."!mark_fail"(0)
    lt rx1314_pos, -1, rx1314_done
    eq rx1314_pos, -1, rx1314_fail
    jump $I10
  rx1314_done:
    rx1314_cur."!cursor_fail"()
    if_null rx1314_debug, debug_972
    rx1314_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_972:
    .return (rx1314_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("305_1295994649.593") :method
.annotate 'line', 4
    $P1316 = self."!PREFIX__!subrule"("O", "%")
    new $P1317, "ResizablePMCArray"
    push $P1317, $P1316
    .return ($P1317)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("306_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1321_tgt
    .local int rx1321_pos
    .local int rx1321_off
    .local int rx1321_eos
    .local int rx1321_rep
    .local pmc rx1321_cur
    .local pmc rx1321_debug
    (rx1321_cur, rx1321_pos, rx1321_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1321_cur
    .local pmc match
    .lex "$/", match
    length rx1321_eos, rx1321_tgt
    gt rx1321_pos, rx1321_eos, rx1321_done
    set rx1321_off, 0
    lt rx1321_pos, 2, rx1321_start
    sub rx1321_off, rx1321_pos, 1
    substr rx1321_tgt, rx1321_tgt, rx1321_off
  rx1321_start:
    eq $I10, 1, rx1321_restart
    if_null rx1321_debug, debug_973
    rx1321_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1325_done
    goto rxscan1325_scan
  rxscan1325_loop:
    ($P10) = rx1321_cur."from"()
    inc $P10
    set rx1321_pos, $P10
    ge rx1321_pos, rx1321_eos, rxscan1325_done
  rxscan1325_scan:
    set_addr $I10, rxscan1325_loop
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  rxscan1325_done:
.annotate 'line', 588
  # rx subcapture "sym"
    set_addr $I10, rxcap_1326_fail
    rx1321_cur."!mark_push"(0, rx1321_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1321_pos, 2
    gt $I11, rx1321_eos, rx1321_fail
    sub $I11, rx1321_pos, rx1321_off
    substr $S10, rx1321_tgt, $I11, 2
    ne $S10, "+&", rx1321_fail
    add rx1321_pos, 2
    set_addr $I10, rxcap_1326_fail
    ($I12, $I11) = rx1321_cur."!mark_peek"($I10)
    rx1321_cur."!cursor_pos"($I11)
    ($P10) = rx1321_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1321_pos, "")
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1326_done
  rxcap_1326_fail:
    goto rx1321_fail
  rxcap_1326_done:
  # rx subrule "O" subtype=capture negate=
    rx1321_cur."!cursor_pos"(rx1321_pos)
    $P10 = rx1321_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1321_fail
    rx1321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1321_pos = $P10."pos"()
  # rx pass
    rx1321_cur."!cursor_pass"(rx1321_pos, "infix:sym<+&>")
    if_null rx1321_debug, debug_974
    rx1321_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1321_pos)
  debug_974:
    .return (rx1321_cur)
  rx1321_restart:
.annotate 'line', 4
    if_null rx1321_debug, debug_975
    rx1321_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_975:
  rx1321_fail:
    (rx1321_rep, rx1321_pos, $I10, $P10) = rx1321_cur."!mark_fail"(0)
    lt rx1321_pos, -1, rx1321_done
    eq rx1321_pos, -1, rx1321_fail
    jump $I10
  rx1321_done:
    rx1321_cur."!cursor_fail"()
    if_null rx1321_debug, debug_976
    rx1321_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_976:
    .return (rx1321_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("307_1295994649.593") :method
.annotate 'line', 4
    $P1323 = self."!PREFIX__!subrule"("O", "+&")
    new $P1324, "ResizablePMCArray"
    push $P1324, $P1323
    .return ($P1324)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("308_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1328_tgt
    .local int rx1328_pos
    .local int rx1328_off
    .local int rx1328_eos
    .local int rx1328_rep
    .local pmc rx1328_cur
    .local pmc rx1328_debug
    (rx1328_cur, rx1328_pos, rx1328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1328_cur
    .local pmc match
    .lex "$/", match
    length rx1328_eos, rx1328_tgt
    gt rx1328_pos, rx1328_eos, rx1328_done
    set rx1328_off, 0
    lt rx1328_pos, 2, rx1328_start
    sub rx1328_off, rx1328_pos, 1
    substr rx1328_tgt, rx1328_tgt, rx1328_off
  rx1328_start:
    eq $I10, 1, rx1328_restart
    if_null rx1328_debug, debug_977
    rx1328_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    ($P10) = rx1328_cur."from"()
    inc $P10
    set rx1328_pos, $P10
    ge rx1328_pos, rx1328_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  rxscan1332_done:
.annotate 'line', 590
  # rx subcapture "sym"
    set_addr $I10, rxcap_1333_fail
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  # rx literal  "+"
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 43, rx1328_fail
    add rx1328_pos, 1
    set_addr $I10, rxcap_1333_fail
    ($I12, $I11) = rx1328_cur."!mark_peek"($I10)
    rx1328_cur."!cursor_pos"($I11)
    ($P10) = rx1328_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1328_pos, "")
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1333_done
  rxcap_1333_fail:
    goto rx1328_fail
  rxcap_1333_done:
  # rx subrule "O" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1328_pos = $P10."pos"()
  # rx pass
    rx1328_cur."!cursor_pass"(rx1328_pos, "infix:sym<+>")
    if_null rx1328_debug, debug_978
    rx1328_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1328_pos)
  debug_978:
    .return (rx1328_cur)
  rx1328_restart:
.annotate 'line', 4
    if_null rx1328_debug, debug_979
    rx1328_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_979:
  rx1328_fail:
    (rx1328_rep, rx1328_pos, $I10, $P10) = rx1328_cur."!mark_fail"(0)
    lt rx1328_pos, -1, rx1328_done
    eq rx1328_pos, -1, rx1328_fail
    jump $I10
  rx1328_done:
    rx1328_cur."!cursor_fail"()
    if_null rx1328_debug, debug_980
    rx1328_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_980:
    .return (rx1328_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("309_1295994649.593") :method
.annotate 'line', 4
    $P1330 = self."!PREFIX__!subrule"("O", "+")
    new $P1331, "ResizablePMCArray"
    push $P1331, $P1330
    .return ($P1331)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("310_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1335_tgt
    .local int rx1335_pos
    .local int rx1335_off
    .local int rx1335_eos
    .local int rx1335_rep
    .local pmc rx1335_cur
    .local pmc rx1335_debug
    (rx1335_cur, rx1335_pos, rx1335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1335_cur
    .local pmc match
    .lex "$/", match
    length rx1335_eos, rx1335_tgt
    gt rx1335_pos, rx1335_eos, rx1335_done
    set rx1335_off, 0
    lt rx1335_pos, 2, rx1335_start
    sub rx1335_off, rx1335_pos, 1
    substr rx1335_tgt, rx1335_tgt, rx1335_off
  rx1335_start:
    eq $I10, 1, rx1335_restart
    if_null rx1335_debug, debug_981
    rx1335_cur."!cursor_debug"("START", "infix:sym<->")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1339_done
    goto rxscan1339_scan
  rxscan1339_loop:
    ($P10) = rx1335_cur."from"()
    inc $P10
    set rx1335_pos, $P10
    ge rx1335_pos, rx1335_eos, rxscan1339_done
  rxscan1339_scan:
    set_addr $I10, rxscan1339_loop
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  rxscan1339_done:
.annotate 'line', 591
  # rx subcapture "sym"
    set_addr $I10, rxcap_1340_fail
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  # rx literal  "-"
    add $I11, rx1335_pos, 1
    gt $I11, rx1335_eos, rx1335_fail
    sub $I11, rx1335_pos, rx1335_off
    ord $I11, rx1335_tgt, $I11
    ne $I11, 45, rx1335_fail
    add rx1335_pos, 1
    set_addr $I10, rxcap_1340_fail
    ($I12, $I11) = rx1335_cur."!mark_peek"($I10)
    rx1335_cur."!cursor_pos"($I11)
    ($P10) = rx1335_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1335_pos, "")
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1340_done
  rxcap_1340_fail:
    goto rx1335_fail
  rxcap_1340_done:
  # rx subrule "O" subtype=capture negate=
    rx1335_cur."!cursor_pos"(rx1335_pos)
    $P10 = rx1335_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1335_fail
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1335_pos = $P10."pos"()
  # rx pass
    rx1335_cur."!cursor_pass"(rx1335_pos, "infix:sym<->")
    if_null rx1335_debug, debug_982
    rx1335_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1335_pos)
  debug_982:
    .return (rx1335_cur)
  rx1335_restart:
.annotate 'line', 4
    if_null rx1335_debug, debug_983
    rx1335_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_983:
  rx1335_fail:
    (rx1335_rep, rx1335_pos, $I10, $P10) = rx1335_cur."!mark_fail"(0)
    lt rx1335_pos, -1, rx1335_done
    eq rx1335_pos, -1, rx1335_fail
    jump $I10
  rx1335_done:
    rx1335_cur."!cursor_fail"()
    if_null rx1335_debug, debug_984
    rx1335_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_984:
    .return (rx1335_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("311_1295994649.593") :method
.annotate 'line', 4
    $P1337 = self."!PREFIX__!subrule"("O", "-")
    new $P1338, "ResizablePMCArray"
    push $P1338, $P1337
    .return ($P1338)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("312_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1342_tgt
    .local int rx1342_pos
    .local int rx1342_off
    .local int rx1342_eos
    .local int rx1342_rep
    .local pmc rx1342_cur
    .local pmc rx1342_debug
    (rx1342_cur, rx1342_pos, rx1342_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1342_cur
    .local pmc match
    .lex "$/", match
    length rx1342_eos, rx1342_tgt
    gt rx1342_pos, rx1342_eos, rx1342_done
    set rx1342_off, 0
    lt rx1342_pos, 2, rx1342_start
    sub rx1342_off, rx1342_pos, 1
    substr rx1342_tgt, rx1342_tgt, rx1342_off
  rx1342_start:
    eq $I10, 1, rx1342_restart
    if_null rx1342_debug, debug_985
    rx1342_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1346_done
    goto rxscan1346_scan
  rxscan1346_loop:
    ($P10) = rx1342_cur."from"()
    inc $P10
    set rx1342_pos, $P10
    ge rx1342_pos, rx1342_eos, rxscan1346_done
  rxscan1346_scan:
    set_addr $I10, rxscan1346_loop
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  rxscan1346_done:
.annotate 'line', 592
  # rx subcapture "sym"
    set_addr $I10, rxcap_1347_fail
    rx1342_cur."!mark_push"(0, rx1342_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1342_pos, 2
    gt $I11, rx1342_eos, rx1342_fail
    sub $I11, rx1342_pos, rx1342_off
    substr $S10, rx1342_tgt, $I11, 2
    ne $S10, "+|", rx1342_fail
    add rx1342_pos, 2
    set_addr $I10, rxcap_1347_fail
    ($I12, $I11) = rx1342_cur."!mark_peek"($I10)
    rx1342_cur."!cursor_pos"($I11)
    ($P10) = rx1342_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1342_pos, "")
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1347_done
  rxcap_1347_fail:
    goto rx1342_fail
  rxcap_1347_done:
  # rx subrule "O" subtype=capture negate=
    rx1342_cur."!cursor_pos"(rx1342_pos)
    $P10 = rx1342_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1342_fail
    rx1342_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1342_pos = $P10."pos"()
  # rx pass
    rx1342_cur."!cursor_pass"(rx1342_pos, "infix:sym<+|>")
    if_null rx1342_debug, debug_986
    rx1342_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1342_pos)
  debug_986:
    .return (rx1342_cur)
  rx1342_restart:
.annotate 'line', 4
    if_null rx1342_debug, debug_987
    rx1342_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_987:
  rx1342_fail:
    (rx1342_rep, rx1342_pos, $I10, $P10) = rx1342_cur."!mark_fail"(0)
    lt rx1342_pos, -1, rx1342_done
    eq rx1342_pos, -1, rx1342_fail
    jump $I10
  rx1342_done:
    rx1342_cur."!cursor_fail"()
    if_null rx1342_debug, debug_988
    rx1342_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_988:
    .return (rx1342_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("313_1295994649.593") :method
.annotate 'line', 4
    $P1344 = self."!PREFIX__!subrule"("O", "+|")
    new $P1345, "ResizablePMCArray"
    push $P1345, $P1344
    .return ($P1345)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("314_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1349_tgt
    .local int rx1349_pos
    .local int rx1349_off
    .local int rx1349_eos
    .local int rx1349_rep
    .local pmc rx1349_cur
    .local pmc rx1349_debug
    (rx1349_cur, rx1349_pos, rx1349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1349_cur
    .local pmc match
    .lex "$/", match
    length rx1349_eos, rx1349_tgt
    gt rx1349_pos, rx1349_eos, rx1349_done
    set rx1349_off, 0
    lt rx1349_pos, 2, rx1349_start
    sub rx1349_off, rx1349_pos, 1
    substr rx1349_tgt, rx1349_tgt, rx1349_off
  rx1349_start:
    eq $I10, 1, rx1349_restart
    if_null rx1349_debug, debug_989
    rx1349_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    ($P10) = rx1349_cur."from"()
    inc $P10
    set rx1349_pos, $P10
    ge rx1349_pos, rx1349_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  rxscan1353_done:
.annotate 'line', 593
  # rx subcapture "sym"
    set_addr $I10, rxcap_1354_fail
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1349_pos, 2
    gt $I11, rx1349_eos, rx1349_fail
    sub $I11, rx1349_pos, rx1349_off
    substr $S10, rx1349_tgt, $I11, 2
    ne $S10, "+^", rx1349_fail
    add rx1349_pos, 2
    set_addr $I10, rxcap_1354_fail
    ($I12, $I11) = rx1349_cur."!mark_peek"($I10)
    rx1349_cur."!cursor_pos"($I11)
    ($P10) = rx1349_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1349_pos, "")
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1354_done
  rxcap_1354_fail:
    goto rx1349_fail
  rxcap_1354_done:
  # rx subrule "O" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1349_pos = $P10."pos"()
  # rx pass
    rx1349_cur."!cursor_pass"(rx1349_pos, "infix:sym<+^>")
    if_null rx1349_debug, debug_990
    rx1349_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1349_pos)
  debug_990:
    .return (rx1349_cur)
  rx1349_restart:
.annotate 'line', 4
    if_null rx1349_debug, debug_991
    rx1349_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_991:
  rx1349_fail:
    (rx1349_rep, rx1349_pos, $I10, $P10) = rx1349_cur."!mark_fail"(0)
    lt rx1349_pos, -1, rx1349_done
    eq rx1349_pos, -1, rx1349_fail
    jump $I10
  rx1349_done:
    rx1349_cur."!cursor_fail"()
    if_null rx1349_debug, debug_992
    rx1349_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_992:
    .return (rx1349_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("315_1295994649.593") :method
.annotate 'line', 4
    $P1351 = self."!PREFIX__!subrule"("O", "+^")
    new $P1352, "ResizablePMCArray"
    push $P1352, $P1351
    .return ($P1352)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("316_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1356_tgt
    .local int rx1356_pos
    .local int rx1356_off
    .local int rx1356_eos
    .local int rx1356_rep
    .local pmc rx1356_cur
    .local pmc rx1356_debug
    (rx1356_cur, rx1356_pos, rx1356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1356_cur
    .local pmc match
    .lex "$/", match
    length rx1356_eos, rx1356_tgt
    gt rx1356_pos, rx1356_eos, rx1356_done
    set rx1356_off, 0
    lt rx1356_pos, 2, rx1356_start
    sub rx1356_off, rx1356_pos, 1
    substr rx1356_tgt, rx1356_tgt, rx1356_off
  rx1356_start:
    eq $I10, 1, rx1356_restart
    if_null rx1356_debug, debug_993
    rx1356_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1360_done
    goto rxscan1360_scan
  rxscan1360_loop:
    ($P10) = rx1356_cur."from"()
    inc $P10
    set rx1356_pos, $P10
    ge rx1356_pos, rx1356_eos, rxscan1360_done
  rxscan1360_scan:
    set_addr $I10, rxscan1360_loop
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  rxscan1360_done:
.annotate 'line', 595
  # rx subcapture "sym"
    set_addr $I10, rxcap_1361_fail
    rx1356_cur."!mark_push"(0, rx1356_pos, $I10)
  # rx literal  "~"
    add $I11, rx1356_pos, 1
    gt $I11, rx1356_eos, rx1356_fail
    sub $I11, rx1356_pos, rx1356_off
    ord $I11, rx1356_tgt, $I11
    ne $I11, 126, rx1356_fail
    add rx1356_pos, 1
    set_addr $I10, rxcap_1361_fail
    ($I12, $I11) = rx1356_cur."!mark_peek"($I10)
    rx1356_cur."!cursor_pos"($I11)
    ($P10) = rx1356_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1356_pos, "")
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1361_done
  rxcap_1361_fail:
    goto rx1356_fail
  rxcap_1361_done:
  # rx subrule "O" subtype=capture negate=
    rx1356_cur."!cursor_pos"(rx1356_pos)
    $P10 = rx1356_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1356_fail
    rx1356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1356_pos = $P10."pos"()
  # rx pass
    rx1356_cur."!cursor_pass"(rx1356_pos, "infix:sym<~>")
    if_null rx1356_debug, debug_994
    rx1356_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1356_pos)
  debug_994:
    .return (rx1356_cur)
  rx1356_restart:
.annotate 'line', 4
    if_null rx1356_debug, debug_995
    rx1356_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_995:
  rx1356_fail:
    (rx1356_rep, rx1356_pos, $I10, $P10) = rx1356_cur."!mark_fail"(0)
    lt rx1356_pos, -1, rx1356_done
    eq rx1356_pos, -1, rx1356_fail
    jump $I10
  rx1356_done:
    rx1356_cur."!cursor_fail"()
    if_null rx1356_debug, debug_996
    rx1356_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_996:
    .return (rx1356_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("317_1295994649.593") :method
.annotate 'line', 4
    $P1358 = self."!PREFIX__!subrule"("O", "~")
    new $P1359, "ResizablePMCArray"
    push $P1359, $P1358
    .return ($P1359)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("318_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1363_tgt
    .local int rx1363_pos
    .local int rx1363_off
    .local int rx1363_eos
    .local int rx1363_rep
    .local pmc rx1363_cur
    .local pmc rx1363_debug
    (rx1363_cur, rx1363_pos, rx1363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1363_cur
    .local pmc match
    .lex "$/", match
    length rx1363_eos, rx1363_tgt
    gt rx1363_pos, rx1363_eos, rx1363_done
    set rx1363_off, 0
    lt rx1363_pos, 2, rx1363_start
    sub rx1363_off, rx1363_pos, 1
    substr rx1363_tgt, rx1363_tgt, rx1363_off
  rx1363_start:
    eq $I10, 1, rx1363_restart
    if_null rx1363_debug, debug_997
    rx1363_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1367_done
    goto rxscan1367_scan
  rxscan1367_loop:
    ($P10) = rx1363_cur."from"()
    inc $P10
    set rx1363_pos, $P10
    ge rx1363_pos, rx1363_eos, rxscan1367_done
  rxscan1367_scan:
    set_addr $I10, rxscan1367_loop
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  rxscan1367_done:
.annotate 'line', 597
  # rx subcapture "sym"
    set_addr $I10, rxcap_1368_fail
    rx1363_cur."!mark_push"(0, rx1363_pos, $I10)
  # rx literal  "=="
    add $I11, rx1363_pos, 2
    gt $I11, rx1363_eos, rx1363_fail
    sub $I11, rx1363_pos, rx1363_off
    substr $S10, rx1363_tgt, $I11, 2
    ne $S10, "==", rx1363_fail
    add rx1363_pos, 2
    set_addr $I10, rxcap_1368_fail
    ($I12, $I11) = rx1363_cur."!mark_peek"($I10)
    rx1363_cur."!cursor_pos"($I11)
    ($P10) = rx1363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1363_pos, "")
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1368_done
  rxcap_1368_fail:
    goto rx1363_fail
  rxcap_1368_done:
  # rx subrule "O" subtype=capture negate=
    rx1363_cur."!cursor_pos"(rx1363_pos)
    $P10 = rx1363_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1363_fail
    rx1363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1363_pos = $P10."pos"()
  # rx pass
    rx1363_cur."!cursor_pass"(rx1363_pos, "infix:sym<==>")
    if_null rx1363_debug, debug_998
    rx1363_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1363_pos)
  debug_998:
    .return (rx1363_cur)
  rx1363_restart:
.annotate 'line', 4
    if_null rx1363_debug, debug_999
    rx1363_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_999:
  rx1363_fail:
    (rx1363_rep, rx1363_pos, $I10, $P10) = rx1363_cur."!mark_fail"(0)
    lt rx1363_pos, -1, rx1363_done
    eq rx1363_pos, -1, rx1363_fail
    jump $I10
  rx1363_done:
    rx1363_cur."!cursor_fail"()
    if_null rx1363_debug, debug_1000
    rx1363_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1000:
    .return (rx1363_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("319_1295994649.593") :method
.annotate 'line', 4
    $P1365 = self."!PREFIX__!subrule"("O", "==")
    new $P1366, "ResizablePMCArray"
    push $P1366, $P1365
    .return ($P1366)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("320_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1370_tgt
    .local int rx1370_pos
    .local int rx1370_off
    .local int rx1370_eos
    .local int rx1370_rep
    .local pmc rx1370_cur
    .local pmc rx1370_debug
    (rx1370_cur, rx1370_pos, rx1370_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1370_cur
    .local pmc match
    .lex "$/", match
    length rx1370_eos, rx1370_tgt
    gt rx1370_pos, rx1370_eos, rx1370_done
    set rx1370_off, 0
    lt rx1370_pos, 2, rx1370_start
    sub rx1370_off, rx1370_pos, 1
    substr rx1370_tgt, rx1370_tgt, rx1370_off
  rx1370_start:
    eq $I10, 1, rx1370_restart
    if_null rx1370_debug, debug_1001
    rx1370_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    ($P10) = rx1370_cur."from"()
    inc $P10
    set rx1370_pos, $P10
    ge rx1370_pos, rx1370_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  rxscan1374_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1375_fail
    rx1370_cur."!mark_push"(0, rx1370_pos, $I10)
  # rx literal  "!="
    add $I11, rx1370_pos, 2
    gt $I11, rx1370_eos, rx1370_fail
    sub $I11, rx1370_pos, rx1370_off
    substr $S10, rx1370_tgt, $I11, 2
    ne $S10, "!=", rx1370_fail
    add rx1370_pos, 2
    set_addr $I10, rxcap_1375_fail
    ($I12, $I11) = rx1370_cur."!mark_peek"($I10)
    rx1370_cur."!cursor_pos"($I11)
    ($P10) = rx1370_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1370_pos, "")
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1375_done
  rxcap_1375_fail:
    goto rx1370_fail
  rxcap_1375_done:
  # rx subrule "O" subtype=capture negate=
    rx1370_cur."!cursor_pos"(rx1370_pos)
    $P10 = rx1370_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1370_fail
    rx1370_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1370_pos = $P10."pos"()
  # rx pass
    rx1370_cur."!cursor_pass"(rx1370_pos, "infix:sym<!=>")
    if_null rx1370_debug, debug_1002
    rx1370_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1370_pos)
  debug_1002:
    .return (rx1370_cur)
  rx1370_restart:
.annotate 'line', 4
    if_null rx1370_debug, debug_1003
    rx1370_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1003:
  rx1370_fail:
    (rx1370_rep, rx1370_pos, $I10, $P10) = rx1370_cur."!mark_fail"(0)
    lt rx1370_pos, -1, rx1370_done
    eq rx1370_pos, -1, rx1370_fail
    jump $I10
  rx1370_done:
    rx1370_cur."!cursor_fail"()
    if_null rx1370_debug, debug_1004
    rx1370_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1004:
    .return (rx1370_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("321_1295994649.593") :method
.annotate 'line', 4
    $P1372 = self."!PREFIX__!subrule"("O", "!=")
    new $P1373, "ResizablePMCArray"
    push $P1373, $P1372
    .return ($P1373)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("322_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1377_tgt
    .local int rx1377_pos
    .local int rx1377_off
    .local int rx1377_eos
    .local int rx1377_rep
    .local pmc rx1377_cur
    .local pmc rx1377_debug
    (rx1377_cur, rx1377_pos, rx1377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1377_cur
    .local pmc match
    .lex "$/", match
    length rx1377_eos, rx1377_tgt
    gt rx1377_pos, rx1377_eos, rx1377_done
    set rx1377_off, 0
    lt rx1377_pos, 2, rx1377_start
    sub rx1377_off, rx1377_pos, 1
    substr rx1377_tgt, rx1377_tgt, rx1377_off
  rx1377_start:
    eq $I10, 1, rx1377_restart
    if_null rx1377_debug, debug_1005
    rx1377_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    ($P10) = rx1377_cur."from"()
    inc $P10
    set rx1377_pos, $P10
    ge rx1377_pos, rx1377_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxscan1381_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1382_fail
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  # rx literal  "<="
    add $I11, rx1377_pos, 2
    gt $I11, rx1377_eos, rx1377_fail
    sub $I11, rx1377_pos, rx1377_off
    substr $S10, rx1377_tgt, $I11, 2
    ne $S10, "<=", rx1377_fail
    add rx1377_pos, 2
    set_addr $I10, rxcap_1382_fail
    ($I12, $I11) = rx1377_cur."!mark_peek"($I10)
    rx1377_cur."!cursor_pos"($I11)
    ($P10) = rx1377_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1377_pos, "")
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1382_done
  rxcap_1382_fail:
    goto rx1377_fail
  rxcap_1382_done:
  # rx subrule "O" subtype=capture negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1377_fail
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1377_pos = $P10."pos"()
  # rx pass
    rx1377_cur."!cursor_pass"(rx1377_pos, "infix:sym<<=>")
    if_null rx1377_debug, debug_1006
    rx1377_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1377_pos)
  debug_1006:
    .return (rx1377_cur)
  rx1377_restart:
.annotate 'line', 4
    if_null rx1377_debug, debug_1007
    rx1377_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1007:
  rx1377_fail:
    (rx1377_rep, rx1377_pos, $I10, $P10) = rx1377_cur."!mark_fail"(0)
    lt rx1377_pos, -1, rx1377_done
    eq rx1377_pos, -1, rx1377_fail
    jump $I10
  rx1377_done:
    rx1377_cur."!cursor_fail"()
    if_null rx1377_debug, debug_1008
    rx1377_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1008:
    .return (rx1377_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("323_1295994649.593") :method
.annotate 'line', 4
    $P1379 = self."!PREFIX__!subrule"("O", "<=")
    new $P1380, "ResizablePMCArray"
    push $P1380, $P1379
    .return ($P1380)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("324_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_1009
    rx1384_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    ($P10) = rx1384_cur."from"()
    inc $P10
    set rx1384_pos, $P10
    ge rx1384_pos, rx1384_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1388_done:
.annotate 'line', 600
  # rx subcapture "sym"
    set_addr $I10, rxcap_1389_fail
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  # rx literal  ">="
    add $I11, rx1384_pos, 2
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    substr $S10, rx1384_tgt, $I11, 2
    ne $S10, ">=", rx1384_fail
    add rx1384_pos, 2
    set_addr $I10, rxcap_1389_fail
    ($I12, $I11) = rx1384_cur."!mark_peek"($I10)
    rx1384_cur."!cursor_pos"($I11)
    ($P10) = rx1384_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1384_pos, "")
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1389_done
  rxcap_1389_fail:
    goto rx1384_fail
  rxcap_1389_done:
  # rx subrule "O" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1384_pos = $P10."pos"()
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "infix:sym<>=>")
    if_null rx1384_debug, debug_1010
    rx1384_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1384_pos)
  debug_1010:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 4
    if_null rx1384_debug, debug_1011
    rx1384_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1011:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1012
    rx1384_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1012:
    .return (rx1384_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("325_1295994649.593") :method
.annotate 'line', 4
    $P1386 = self."!PREFIX__!subrule"("O", ">=")
    new $P1387, "ResizablePMCArray"
    push $P1387, $P1386
    .return ($P1387)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("326_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1391_tgt
    .local int rx1391_pos
    .local int rx1391_off
    .local int rx1391_eos
    .local int rx1391_rep
    .local pmc rx1391_cur
    .local pmc rx1391_debug
    (rx1391_cur, rx1391_pos, rx1391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1391_cur
    .local pmc match
    .lex "$/", match
    length rx1391_eos, rx1391_tgt
    gt rx1391_pos, rx1391_eos, rx1391_done
    set rx1391_off, 0
    lt rx1391_pos, 2, rx1391_start
    sub rx1391_off, rx1391_pos, 1
    substr rx1391_tgt, rx1391_tgt, rx1391_off
  rx1391_start:
    eq $I10, 1, rx1391_restart
    if_null rx1391_debug, debug_1013
    rx1391_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1395_done
    goto rxscan1395_scan
  rxscan1395_loop:
    ($P10) = rx1391_cur."from"()
    inc $P10
    set rx1391_pos, $P10
    ge rx1391_pos, rx1391_eos, rxscan1395_done
  rxscan1395_scan:
    set_addr $I10, rxscan1395_loop
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  rxscan1395_done:
.annotate 'line', 601
  # rx subcapture "sym"
    set_addr $I10, rxcap_1396_fail
    rx1391_cur."!mark_push"(0, rx1391_pos, $I10)
  # rx literal  "<"
    add $I11, rx1391_pos, 1
    gt $I11, rx1391_eos, rx1391_fail
    sub $I11, rx1391_pos, rx1391_off
    ord $I11, rx1391_tgt, $I11
    ne $I11, 60, rx1391_fail
    add rx1391_pos, 1
    set_addr $I10, rxcap_1396_fail
    ($I12, $I11) = rx1391_cur."!mark_peek"($I10)
    rx1391_cur."!cursor_pos"($I11)
    ($P10) = rx1391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1391_pos, "")
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1396_done
  rxcap_1396_fail:
    goto rx1391_fail
  rxcap_1396_done:
  # rx subrule "O" subtype=capture negate=
    rx1391_cur."!cursor_pos"(rx1391_pos)
    $P10 = rx1391_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1391_fail
    rx1391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1391_pos = $P10."pos"()
  # rx pass
    rx1391_cur."!cursor_pass"(rx1391_pos, "infix:sym<<>")
    if_null rx1391_debug, debug_1014
    rx1391_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1391_pos)
  debug_1014:
    .return (rx1391_cur)
  rx1391_restart:
.annotate 'line', 4
    if_null rx1391_debug, debug_1015
    rx1391_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1015:
  rx1391_fail:
    (rx1391_rep, rx1391_pos, $I10, $P10) = rx1391_cur."!mark_fail"(0)
    lt rx1391_pos, -1, rx1391_done
    eq rx1391_pos, -1, rx1391_fail
    jump $I10
  rx1391_done:
    rx1391_cur."!cursor_fail"()
    if_null rx1391_debug, debug_1016
    rx1391_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1016:
    .return (rx1391_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("327_1295994649.593") :method
.annotate 'line', 4
    $P1393 = self."!PREFIX__!subrule"("O", "<")
    new $P1394, "ResizablePMCArray"
    push $P1394, $P1393
    .return ($P1394)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("328_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1398_tgt
    .local int rx1398_pos
    .local int rx1398_off
    .local int rx1398_eos
    .local int rx1398_rep
    .local pmc rx1398_cur
    .local pmc rx1398_debug
    (rx1398_cur, rx1398_pos, rx1398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1398_cur
    .local pmc match
    .lex "$/", match
    length rx1398_eos, rx1398_tgt
    gt rx1398_pos, rx1398_eos, rx1398_done
    set rx1398_off, 0
    lt rx1398_pos, 2, rx1398_start
    sub rx1398_off, rx1398_pos, 1
    substr rx1398_tgt, rx1398_tgt, rx1398_off
  rx1398_start:
    eq $I10, 1, rx1398_restart
    if_null rx1398_debug, debug_1017
    rx1398_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1402_done
    goto rxscan1402_scan
  rxscan1402_loop:
    ($P10) = rx1398_cur."from"()
    inc $P10
    set rx1398_pos, $P10
    ge rx1398_pos, rx1398_eos, rxscan1402_done
  rxscan1402_scan:
    set_addr $I10, rxscan1402_loop
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxscan1402_done:
.annotate 'line', 602
  # rx subcapture "sym"
    set_addr $I10, rxcap_1403_fail
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  # rx literal  ">"
    add $I11, rx1398_pos, 1
    gt $I11, rx1398_eos, rx1398_fail
    sub $I11, rx1398_pos, rx1398_off
    ord $I11, rx1398_tgt, $I11
    ne $I11, 62, rx1398_fail
    add rx1398_pos, 1
    set_addr $I10, rxcap_1403_fail
    ($I12, $I11) = rx1398_cur."!mark_peek"($I10)
    rx1398_cur."!cursor_pos"($I11)
    ($P10) = rx1398_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1398_pos, "")
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1403_done
  rxcap_1403_fail:
    goto rx1398_fail
  rxcap_1403_done:
  # rx subrule "O" subtype=capture negate=
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1398_fail
    rx1398_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1398_pos = $P10."pos"()
  # rx pass
    rx1398_cur."!cursor_pass"(rx1398_pos, "infix:sym<>>")
    if_null rx1398_debug, debug_1018
    rx1398_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1398_pos)
  debug_1018:
    .return (rx1398_cur)
  rx1398_restart:
.annotate 'line', 4
    if_null rx1398_debug, debug_1019
    rx1398_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1019:
  rx1398_fail:
    (rx1398_rep, rx1398_pos, $I10, $P10) = rx1398_cur."!mark_fail"(0)
    lt rx1398_pos, -1, rx1398_done
    eq rx1398_pos, -1, rx1398_fail
    jump $I10
  rx1398_done:
    rx1398_cur."!cursor_fail"()
    if_null rx1398_debug, debug_1020
    rx1398_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1020:
    .return (rx1398_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("329_1295994649.593") :method
.annotate 'line', 4
    $P1400 = self."!PREFIX__!subrule"("O", ">")
    new $P1401, "ResizablePMCArray"
    push $P1401, $P1400
    .return ($P1401)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("330_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1405_tgt
    .local int rx1405_pos
    .local int rx1405_off
    .local int rx1405_eos
    .local int rx1405_rep
    .local pmc rx1405_cur
    .local pmc rx1405_debug
    (rx1405_cur, rx1405_pos, rx1405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1405_cur
    .local pmc match
    .lex "$/", match
    length rx1405_eos, rx1405_tgt
    gt rx1405_pos, rx1405_eos, rx1405_done
    set rx1405_off, 0
    lt rx1405_pos, 2, rx1405_start
    sub rx1405_off, rx1405_pos, 1
    substr rx1405_tgt, rx1405_tgt, rx1405_off
  rx1405_start:
    eq $I10, 1, rx1405_restart
    if_null rx1405_debug, debug_1021
    rx1405_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1409_done
    goto rxscan1409_scan
  rxscan1409_loop:
    ($P10) = rx1405_cur."from"()
    inc $P10
    set rx1405_pos, $P10
    ge rx1405_pos, rx1405_eos, rxscan1409_done
  rxscan1409_scan:
    set_addr $I10, rxscan1409_loop
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  rxscan1409_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1410_fail
    rx1405_cur."!mark_push"(0, rx1405_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1405_pos, 2
    gt $I11, rx1405_eos, rx1405_fail
    sub $I11, rx1405_pos, rx1405_off
    substr $S10, rx1405_tgt, $I11, 2
    ne $S10, "eq", rx1405_fail
    add rx1405_pos, 2
    set_addr $I10, rxcap_1410_fail
    ($I12, $I11) = rx1405_cur."!mark_peek"($I10)
    rx1405_cur."!cursor_pos"($I11)
    ($P10) = rx1405_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1405_pos, "")
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1410_done
  rxcap_1410_fail:
    goto rx1405_fail
  rxcap_1410_done:
  # rx subrule "O" subtype=capture negate=
    rx1405_cur."!cursor_pos"(rx1405_pos)
    $P10 = rx1405_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1405_fail
    rx1405_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1405_pos = $P10."pos"()
  # rx pass
    rx1405_cur."!cursor_pass"(rx1405_pos, "infix:sym<eq>")
    if_null rx1405_debug, debug_1022
    rx1405_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1405_pos)
  debug_1022:
    .return (rx1405_cur)
  rx1405_restart:
.annotate 'line', 4
    if_null rx1405_debug, debug_1023
    rx1405_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1023:
  rx1405_fail:
    (rx1405_rep, rx1405_pos, $I10, $P10) = rx1405_cur."!mark_fail"(0)
    lt rx1405_pos, -1, rx1405_done
    eq rx1405_pos, -1, rx1405_fail
    jump $I10
  rx1405_done:
    rx1405_cur."!cursor_fail"()
    if_null rx1405_debug, debug_1024
    rx1405_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1024:
    .return (rx1405_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("331_1295994649.593") :method
.annotate 'line', 4
    $P1407 = self."!PREFIX__!subrule"("O", "eq")
    new $P1408, "ResizablePMCArray"
    push $P1408, $P1407
    .return ($P1408)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("332_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1412_tgt
    .local int rx1412_pos
    .local int rx1412_off
    .local int rx1412_eos
    .local int rx1412_rep
    .local pmc rx1412_cur
    .local pmc rx1412_debug
    (rx1412_cur, rx1412_pos, rx1412_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1412_cur
    .local pmc match
    .lex "$/", match
    length rx1412_eos, rx1412_tgt
    gt rx1412_pos, rx1412_eos, rx1412_done
    set rx1412_off, 0
    lt rx1412_pos, 2, rx1412_start
    sub rx1412_off, rx1412_pos, 1
    substr rx1412_tgt, rx1412_tgt, rx1412_off
  rx1412_start:
    eq $I10, 1, rx1412_restart
    if_null rx1412_debug, debug_1025
    rx1412_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1416_done
    goto rxscan1416_scan
  rxscan1416_loop:
    ($P10) = rx1412_cur."from"()
    inc $P10
    set rx1412_pos, $P10
    ge rx1412_pos, rx1412_eos, rxscan1416_done
  rxscan1416_scan:
    set_addr $I10, rxscan1416_loop
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  rxscan1416_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1417_fail
    rx1412_cur."!mark_push"(0, rx1412_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1412_pos, 2
    gt $I11, rx1412_eos, rx1412_fail
    sub $I11, rx1412_pos, rx1412_off
    substr $S10, rx1412_tgt, $I11, 2
    ne $S10, "ne", rx1412_fail
    add rx1412_pos, 2
    set_addr $I10, rxcap_1417_fail
    ($I12, $I11) = rx1412_cur."!mark_peek"($I10)
    rx1412_cur."!cursor_pos"($I11)
    ($P10) = rx1412_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1412_pos, "")
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1417_done
  rxcap_1417_fail:
    goto rx1412_fail
  rxcap_1417_done:
  # rx subrule "O" subtype=capture negate=
    rx1412_cur."!cursor_pos"(rx1412_pos)
    $P10 = rx1412_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1412_fail
    rx1412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1412_pos = $P10."pos"()
  # rx pass
    rx1412_cur."!cursor_pass"(rx1412_pos, "infix:sym<ne>")
    if_null rx1412_debug, debug_1026
    rx1412_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1412_pos)
  debug_1026:
    .return (rx1412_cur)
  rx1412_restart:
.annotate 'line', 4
    if_null rx1412_debug, debug_1027
    rx1412_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1027:
  rx1412_fail:
    (rx1412_rep, rx1412_pos, $I10, $P10) = rx1412_cur."!mark_fail"(0)
    lt rx1412_pos, -1, rx1412_done
    eq rx1412_pos, -1, rx1412_fail
    jump $I10
  rx1412_done:
    rx1412_cur."!cursor_fail"()
    if_null rx1412_debug, debug_1028
    rx1412_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1028:
    .return (rx1412_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("333_1295994649.593") :method
.annotate 'line', 4
    $P1414 = self."!PREFIX__!subrule"("O", "ne")
    new $P1415, "ResizablePMCArray"
    push $P1415, $P1414
    .return ($P1415)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("334_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1419_tgt
    .local int rx1419_pos
    .local int rx1419_off
    .local int rx1419_eos
    .local int rx1419_rep
    .local pmc rx1419_cur
    .local pmc rx1419_debug
    (rx1419_cur, rx1419_pos, rx1419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1419_cur
    .local pmc match
    .lex "$/", match
    length rx1419_eos, rx1419_tgt
    gt rx1419_pos, rx1419_eos, rx1419_done
    set rx1419_off, 0
    lt rx1419_pos, 2, rx1419_start
    sub rx1419_off, rx1419_pos, 1
    substr rx1419_tgt, rx1419_tgt, rx1419_off
  rx1419_start:
    eq $I10, 1, rx1419_restart
    if_null rx1419_debug, debug_1029
    rx1419_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1423_done
    goto rxscan1423_scan
  rxscan1423_loop:
    ($P10) = rx1419_cur."from"()
    inc $P10
    set rx1419_pos, $P10
    ge rx1419_pos, rx1419_eos, rxscan1423_done
  rxscan1423_scan:
    set_addr $I10, rxscan1423_loop
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  rxscan1423_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1424_fail
    rx1419_cur."!mark_push"(0, rx1419_pos, $I10)
  # rx literal  "le"
    add $I11, rx1419_pos, 2
    gt $I11, rx1419_eos, rx1419_fail
    sub $I11, rx1419_pos, rx1419_off
    substr $S10, rx1419_tgt, $I11, 2
    ne $S10, "le", rx1419_fail
    add rx1419_pos, 2
    set_addr $I10, rxcap_1424_fail
    ($I12, $I11) = rx1419_cur."!mark_peek"($I10)
    rx1419_cur."!cursor_pos"($I11)
    ($P10) = rx1419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1419_pos, "")
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1424_done
  rxcap_1424_fail:
    goto rx1419_fail
  rxcap_1424_done:
  # rx subrule "O" subtype=capture negate=
    rx1419_cur."!cursor_pos"(rx1419_pos)
    $P10 = rx1419_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1419_fail
    rx1419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1419_pos = $P10."pos"()
  # rx pass
    rx1419_cur."!cursor_pass"(rx1419_pos, "infix:sym<le>")
    if_null rx1419_debug, debug_1030
    rx1419_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1419_pos)
  debug_1030:
    .return (rx1419_cur)
  rx1419_restart:
.annotate 'line', 4
    if_null rx1419_debug, debug_1031
    rx1419_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1031:
  rx1419_fail:
    (rx1419_rep, rx1419_pos, $I10, $P10) = rx1419_cur."!mark_fail"(0)
    lt rx1419_pos, -1, rx1419_done
    eq rx1419_pos, -1, rx1419_fail
    jump $I10
  rx1419_done:
    rx1419_cur."!cursor_fail"()
    if_null rx1419_debug, debug_1032
    rx1419_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1032:
    .return (rx1419_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("335_1295994649.593") :method
.annotate 'line', 4
    $P1421 = self."!PREFIX__!subrule"("O", "le")
    new $P1422, "ResizablePMCArray"
    push $P1422, $P1421
    .return ($P1422)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("336_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1426_tgt
    .local int rx1426_pos
    .local int rx1426_off
    .local int rx1426_eos
    .local int rx1426_rep
    .local pmc rx1426_cur
    .local pmc rx1426_debug
    (rx1426_cur, rx1426_pos, rx1426_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1426_cur
    .local pmc match
    .lex "$/", match
    length rx1426_eos, rx1426_tgt
    gt rx1426_pos, rx1426_eos, rx1426_done
    set rx1426_off, 0
    lt rx1426_pos, 2, rx1426_start
    sub rx1426_off, rx1426_pos, 1
    substr rx1426_tgt, rx1426_tgt, rx1426_off
  rx1426_start:
    eq $I10, 1, rx1426_restart
    if_null rx1426_debug, debug_1033
    rx1426_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1430_done
    goto rxscan1430_scan
  rxscan1430_loop:
    ($P10) = rx1426_cur."from"()
    inc $P10
    set rx1426_pos, $P10
    ge rx1426_pos, rx1426_eos, rxscan1430_done
  rxscan1430_scan:
    set_addr $I10, rxscan1430_loop
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxscan1430_done:
.annotate 'line', 606
  # rx subcapture "sym"
    set_addr $I10, rxcap_1431_fail
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1426_pos, 2
    gt $I11, rx1426_eos, rx1426_fail
    sub $I11, rx1426_pos, rx1426_off
    substr $S10, rx1426_tgt, $I11, 2
    ne $S10, "ge", rx1426_fail
    add rx1426_pos, 2
    set_addr $I10, rxcap_1431_fail
    ($I12, $I11) = rx1426_cur."!mark_peek"($I10)
    rx1426_cur."!cursor_pos"($I11)
    ($P10) = rx1426_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1426_pos, "")
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1431_done
  rxcap_1431_fail:
    goto rx1426_fail
  rxcap_1431_done:
  # rx subrule "O" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1426_pos = $P10."pos"()
  # rx pass
    rx1426_cur."!cursor_pass"(rx1426_pos, "infix:sym<ge>")
    if_null rx1426_debug, debug_1034
    rx1426_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1426_pos)
  debug_1034:
    .return (rx1426_cur)
  rx1426_restart:
.annotate 'line', 4
    if_null rx1426_debug, debug_1035
    rx1426_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1035:
  rx1426_fail:
    (rx1426_rep, rx1426_pos, $I10, $P10) = rx1426_cur."!mark_fail"(0)
    lt rx1426_pos, -1, rx1426_done
    eq rx1426_pos, -1, rx1426_fail
    jump $I10
  rx1426_done:
    rx1426_cur."!cursor_fail"()
    if_null rx1426_debug, debug_1036
    rx1426_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1036:
    .return (rx1426_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("337_1295994649.593") :method
.annotate 'line', 4
    $P1428 = self."!PREFIX__!subrule"("O", "ge")
    new $P1429, "ResizablePMCArray"
    push $P1429, $P1428
    .return ($P1429)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("338_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1433_tgt
    .local int rx1433_pos
    .local int rx1433_off
    .local int rx1433_eos
    .local int rx1433_rep
    .local pmc rx1433_cur
    .local pmc rx1433_debug
    (rx1433_cur, rx1433_pos, rx1433_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1433_cur
    .local pmc match
    .lex "$/", match
    length rx1433_eos, rx1433_tgt
    gt rx1433_pos, rx1433_eos, rx1433_done
    set rx1433_off, 0
    lt rx1433_pos, 2, rx1433_start
    sub rx1433_off, rx1433_pos, 1
    substr rx1433_tgt, rx1433_tgt, rx1433_off
  rx1433_start:
    eq $I10, 1, rx1433_restart
    if_null rx1433_debug, debug_1037
    rx1433_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1437_done
    goto rxscan1437_scan
  rxscan1437_loop:
    ($P10) = rx1433_cur."from"()
    inc $P10
    set rx1433_pos, $P10
    ge rx1433_pos, rx1433_eos, rxscan1437_done
  rxscan1437_scan:
    set_addr $I10, rxscan1437_loop
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  rxscan1437_done:
.annotate 'line', 607
  # rx subcapture "sym"
    set_addr $I10, rxcap_1438_fail
    rx1433_cur."!mark_push"(0, rx1433_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1433_pos, 2
    gt $I11, rx1433_eos, rx1433_fail
    sub $I11, rx1433_pos, rx1433_off
    substr $S10, rx1433_tgt, $I11, 2
    ne $S10, "lt", rx1433_fail
    add rx1433_pos, 2
    set_addr $I10, rxcap_1438_fail
    ($I12, $I11) = rx1433_cur."!mark_peek"($I10)
    rx1433_cur."!cursor_pos"($I11)
    ($P10) = rx1433_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1433_pos, "")
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1438_done
  rxcap_1438_fail:
    goto rx1433_fail
  rxcap_1438_done:
  # rx subrule "O" subtype=capture negate=
    rx1433_cur."!cursor_pos"(rx1433_pos)
    $P10 = rx1433_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1433_fail
    rx1433_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1433_pos = $P10."pos"()
  # rx pass
    rx1433_cur."!cursor_pass"(rx1433_pos, "infix:sym<lt>")
    if_null rx1433_debug, debug_1038
    rx1433_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1433_pos)
  debug_1038:
    .return (rx1433_cur)
  rx1433_restart:
.annotate 'line', 4
    if_null rx1433_debug, debug_1039
    rx1433_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1039:
  rx1433_fail:
    (rx1433_rep, rx1433_pos, $I10, $P10) = rx1433_cur."!mark_fail"(0)
    lt rx1433_pos, -1, rx1433_done
    eq rx1433_pos, -1, rx1433_fail
    jump $I10
  rx1433_done:
    rx1433_cur."!cursor_fail"()
    if_null rx1433_debug, debug_1040
    rx1433_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1040:
    .return (rx1433_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("339_1295994649.593") :method
.annotate 'line', 4
    $P1435 = self."!PREFIX__!subrule"("O", "lt")
    new $P1436, "ResizablePMCArray"
    push $P1436, $P1435
    .return ($P1436)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("340_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1440_tgt
    .local int rx1440_pos
    .local int rx1440_off
    .local int rx1440_eos
    .local int rx1440_rep
    .local pmc rx1440_cur
    .local pmc rx1440_debug
    (rx1440_cur, rx1440_pos, rx1440_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1440_cur
    .local pmc match
    .lex "$/", match
    length rx1440_eos, rx1440_tgt
    gt rx1440_pos, rx1440_eos, rx1440_done
    set rx1440_off, 0
    lt rx1440_pos, 2, rx1440_start
    sub rx1440_off, rx1440_pos, 1
    substr rx1440_tgt, rx1440_tgt, rx1440_off
  rx1440_start:
    eq $I10, 1, rx1440_restart
    if_null rx1440_debug, debug_1041
    rx1440_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1444_done
    goto rxscan1444_scan
  rxscan1444_loop:
    ($P10) = rx1440_cur."from"()
    inc $P10
    set rx1440_pos, $P10
    ge rx1440_pos, rx1440_eos, rxscan1444_done
  rxscan1444_scan:
    set_addr $I10, rxscan1444_loop
    rx1440_cur."!mark_push"(0, rx1440_pos, $I10)
  rxscan1444_done:
.annotate 'line', 608
  # rx subcapture "sym"
    set_addr $I10, rxcap_1445_fail
    rx1440_cur."!mark_push"(0, rx1440_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1440_pos, 2
    gt $I11, rx1440_eos, rx1440_fail
    sub $I11, rx1440_pos, rx1440_off
    substr $S10, rx1440_tgt, $I11, 2
    ne $S10, "gt", rx1440_fail
    add rx1440_pos, 2
    set_addr $I10, rxcap_1445_fail
    ($I12, $I11) = rx1440_cur."!mark_peek"($I10)
    rx1440_cur."!cursor_pos"($I11)
    ($P10) = rx1440_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1440_pos, "")
    rx1440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1445_done
  rxcap_1445_fail:
    goto rx1440_fail
  rxcap_1445_done:
  # rx subrule "O" subtype=capture negate=
    rx1440_cur."!cursor_pos"(rx1440_pos)
    $P10 = rx1440_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1440_fail
    rx1440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1440_pos = $P10."pos"()
  # rx pass
    rx1440_cur."!cursor_pass"(rx1440_pos, "infix:sym<gt>")
    if_null rx1440_debug, debug_1042
    rx1440_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1440_pos)
  debug_1042:
    .return (rx1440_cur)
  rx1440_restart:
.annotate 'line', 4
    if_null rx1440_debug, debug_1043
    rx1440_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1043:
  rx1440_fail:
    (rx1440_rep, rx1440_pos, $I10, $P10) = rx1440_cur."!mark_fail"(0)
    lt rx1440_pos, -1, rx1440_done
    eq rx1440_pos, -1, rx1440_fail
    jump $I10
  rx1440_done:
    rx1440_cur."!cursor_fail"()
    if_null rx1440_debug, debug_1044
    rx1440_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1044:
    .return (rx1440_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("341_1295994649.593") :method
.annotate 'line', 4
    $P1442 = self."!PREFIX__!subrule"("O", "gt")
    new $P1443, "ResizablePMCArray"
    push $P1443, $P1442
    .return ($P1443)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("342_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1447_tgt
    .local int rx1447_pos
    .local int rx1447_off
    .local int rx1447_eos
    .local int rx1447_rep
    .local pmc rx1447_cur
    .local pmc rx1447_debug
    (rx1447_cur, rx1447_pos, rx1447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1447_cur
    .local pmc match
    .lex "$/", match
    length rx1447_eos, rx1447_tgt
    gt rx1447_pos, rx1447_eos, rx1447_done
    set rx1447_off, 0
    lt rx1447_pos, 2, rx1447_start
    sub rx1447_off, rx1447_pos, 1
    substr rx1447_tgt, rx1447_tgt, rx1447_off
  rx1447_start:
    eq $I10, 1, rx1447_restart
    if_null rx1447_debug, debug_1045
    rx1447_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1451_done
    goto rxscan1451_scan
  rxscan1451_loop:
    ($P10) = rx1447_cur."from"()
    inc $P10
    set rx1447_pos, $P10
    ge rx1447_pos, rx1447_eos, rxscan1451_done
  rxscan1451_scan:
    set_addr $I10, rxscan1451_loop
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  rxscan1451_done:
.annotate 'line', 609
  # rx subcapture "sym"
    set_addr $I10, rxcap_1452_fail
    rx1447_cur."!mark_push"(0, rx1447_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1447_pos, 3
    gt $I11, rx1447_eos, rx1447_fail
    sub $I11, rx1447_pos, rx1447_off
    substr $S10, rx1447_tgt, $I11, 3
    ne $S10, "=:=", rx1447_fail
    add rx1447_pos, 3
    set_addr $I10, rxcap_1452_fail
    ($I12, $I11) = rx1447_cur."!mark_peek"($I10)
    rx1447_cur."!cursor_pos"($I11)
    ($P10) = rx1447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1447_pos, "")
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1452_done
  rxcap_1452_fail:
    goto rx1447_fail
  rxcap_1452_done:
  # rx subrule "O" subtype=capture negate=
    rx1447_cur."!cursor_pos"(rx1447_pos)
    $P10 = rx1447_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1447_fail
    rx1447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1447_pos = $P10."pos"()
  # rx pass
    rx1447_cur."!cursor_pass"(rx1447_pos, "infix:sym<=:=>")
    if_null rx1447_debug, debug_1046
    rx1447_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1447_pos)
  debug_1046:
    .return (rx1447_cur)
  rx1447_restart:
.annotate 'line', 4
    if_null rx1447_debug, debug_1047
    rx1447_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1047:
  rx1447_fail:
    (rx1447_rep, rx1447_pos, $I10, $P10) = rx1447_cur."!mark_fail"(0)
    lt rx1447_pos, -1, rx1447_done
    eq rx1447_pos, -1, rx1447_fail
    jump $I10
  rx1447_done:
    rx1447_cur."!cursor_fail"()
    if_null rx1447_debug, debug_1048
    rx1447_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1048:
    .return (rx1447_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("343_1295994649.593") :method
.annotate 'line', 4
    $P1449 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1450, "ResizablePMCArray"
    push $P1450, $P1449
    .return ($P1450)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("344_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1454_tgt
    .local int rx1454_pos
    .local int rx1454_off
    .local int rx1454_eos
    .local int rx1454_rep
    .local pmc rx1454_cur
    .local pmc rx1454_debug
    (rx1454_cur, rx1454_pos, rx1454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1454_cur
    .local pmc match
    .lex "$/", match
    length rx1454_eos, rx1454_tgt
    gt rx1454_pos, rx1454_eos, rx1454_done
    set rx1454_off, 0
    lt rx1454_pos, 2, rx1454_start
    sub rx1454_off, rx1454_pos, 1
    substr rx1454_tgt, rx1454_tgt, rx1454_off
  rx1454_start:
    eq $I10, 1, rx1454_restart
    if_null rx1454_debug, debug_1049
    rx1454_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    ($P10) = rx1454_cur."from"()
    inc $P10
    set rx1454_pos, $P10
    ge rx1454_pos, rx1454_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  rxscan1458_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1459_fail
    rx1454_cur."!mark_push"(0, rx1454_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1454_pos, 2
    gt $I11, rx1454_eos, rx1454_fail
    sub $I11, rx1454_pos, rx1454_off
    substr $S10, rx1454_tgt, $I11, 2
    ne $S10, "~~", rx1454_fail
    add rx1454_pos, 2
    set_addr $I10, rxcap_1459_fail
    ($I12, $I11) = rx1454_cur."!mark_peek"($I10)
    rx1454_cur."!cursor_pos"($I11)
    ($P10) = rx1454_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1454_pos, "")
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1459_done
  rxcap_1459_fail:
    goto rx1454_fail
  rxcap_1459_done:
  # rx subrule "O" subtype=capture negate=
    rx1454_cur."!cursor_pos"(rx1454_pos)
    $P10 = rx1454_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1454_fail
    rx1454_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1454_pos = $P10."pos"()
  # rx pass
    rx1454_cur."!cursor_pass"(rx1454_pos, "infix:sym<~~>")
    if_null rx1454_debug, debug_1050
    rx1454_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1454_pos)
  debug_1050:
    .return (rx1454_cur)
  rx1454_restart:
.annotate 'line', 4
    if_null rx1454_debug, debug_1051
    rx1454_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1051:
  rx1454_fail:
    (rx1454_rep, rx1454_pos, $I10, $P10) = rx1454_cur."!mark_fail"(0)
    lt rx1454_pos, -1, rx1454_done
    eq rx1454_pos, -1, rx1454_fail
    jump $I10
  rx1454_done:
    rx1454_cur."!cursor_fail"()
    if_null rx1454_debug, debug_1052
    rx1454_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1052:
    .return (rx1454_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("345_1295994649.593") :method
.annotate 'line', 4
    $P1456 = self."!PREFIX__!subrule"("O", "~~")
    new $P1457, "ResizablePMCArray"
    push $P1457, $P1456
    .return ($P1457)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("346_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1461_tgt
    .local int rx1461_pos
    .local int rx1461_off
    .local int rx1461_eos
    .local int rx1461_rep
    .local pmc rx1461_cur
    .local pmc rx1461_debug
    (rx1461_cur, rx1461_pos, rx1461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1461_cur
    .local pmc match
    .lex "$/", match
    length rx1461_eos, rx1461_tgt
    gt rx1461_pos, rx1461_eos, rx1461_done
    set rx1461_off, 0
    lt rx1461_pos, 2, rx1461_start
    sub rx1461_off, rx1461_pos, 1
    substr rx1461_tgt, rx1461_tgt, rx1461_off
  rx1461_start:
    eq $I10, 1, rx1461_restart
    if_null rx1461_debug, debug_1053
    rx1461_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1465_done
    goto rxscan1465_scan
  rxscan1465_loop:
    ($P10) = rx1461_cur."from"()
    inc $P10
    set rx1461_pos, $P10
    ge rx1461_pos, rx1461_eos, rxscan1465_done
  rxscan1465_scan:
    set_addr $I10, rxscan1465_loop
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  rxscan1465_done:
.annotate 'line', 612
  # rx subcapture "sym"
    set_addr $I10, rxcap_1466_fail
    rx1461_cur."!mark_push"(0, rx1461_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1461_pos, 2
    gt $I11, rx1461_eos, rx1461_fail
    sub $I11, rx1461_pos, rx1461_off
    substr $S10, rx1461_tgt, $I11, 2
    ne $S10, "&&", rx1461_fail
    add rx1461_pos, 2
    set_addr $I10, rxcap_1466_fail
    ($I12, $I11) = rx1461_cur."!mark_peek"($I10)
    rx1461_cur."!cursor_pos"($I11)
    ($P10) = rx1461_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1461_pos, "")
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1466_done
  rxcap_1466_fail:
    goto rx1461_fail
  rxcap_1466_done:
  # rx subrule "O" subtype=capture negate=
    rx1461_cur."!cursor_pos"(rx1461_pos)
    $P10 = rx1461_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1461_fail
    rx1461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1461_pos = $P10."pos"()
  # rx pass
    rx1461_cur."!cursor_pass"(rx1461_pos, "infix:sym<&&>")
    if_null rx1461_debug, debug_1054
    rx1461_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1461_pos)
  debug_1054:
    .return (rx1461_cur)
  rx1461_restart:
.annotate 'line', 4
    if_null rx1461_debug, debug_1055
    rx1461_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1055:
  rx1461_fail:
    (rx1461_rep, rx1461_pos, $I10, $P10) = rx1461_cur."!mark_fail"(0)
    lt rx1461_pos, -1, rx1461_done
    eq rx1461_pos, -1, rx1461_fail
    jump $I10
  rx1461_done:
    rx1461_cur."!cursor_fail"()
    if_null rx1461_debug, debug_1056
    rx1461_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1056:
    .return (rx1461_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("347_1295994649.593") :method
.annotate 'line', 4
    $P1463 = self."!PREFIX__!subrule"("O", "&&")
    new $P1464, "ResizablePMCArray"
    push $P1464, $P1463
    .return ($P1464)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("348_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1468_tgt
    .local int rx1468_pos
    .local int rx1468_off
    .local int rx1468_eos
    .local int rx1468_rep
    .local pmc rx1468_cur
    .local pmc rx1468_debug
    (rx1468_cur, rx1468_pos, rx1468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1468_cur
    .local pmc match
    .lex "$/", match
    length rx1468_eos, rx1468_tgt
    gt rx1468_pos, rx1468_eos, rx1468_done
    set rx1468_off, 0
    lt rx1468_pos, 2, rx1468_start
    sub rx1468_off, rx1468_pos, 1
    substr rx1468_tgt, rx1468_tgt, rx1468_off
  rx1468_start:
    eq $I10, 1, rx1468_restart
    if_null rx1468_debug, debug_1057
    rx1468_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1472_done
    goto rxscan1472_scan
  rxscan1472_loop:
    ($P10) = rx1468_cur."from"()
    inc $P10
    set rx1468_pos, $P10
    ge rx1468_pos, rx1468_eos, rxscan1472_done
  rxscan1472_scan:
    set_addr $I10, rxscan1472_loop
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  rxscan1472_done:
.annotate 'line', 614
  # rx subcapture "sym"
    set_addr $I10, rxcap_1473_fail
    rx1468_cur."!mark_push"(0, rx1468_pos, $I10)
  # rx literal  "||"
    add $I11, rx1468_pos, 2
    gt $I11, rx1468_eos, rx1468_fail
    sub $I11, rx1468_pos, rx1468_off
    substr $S10, rx1468_tgt, $I11, 2
    ne $S10, "||", rx1468_fail
    add rx1468_pos, 2
    set_addr $I10, rxcap_1473_fail
    ($I12, $I11) = rx1468_cur."!mark_peek"($I10)
    rx1468_cur."!cursor_pos"($I11)
    ($P10) = rx1468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1468_pos, "")
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1473_done
  rxcap_1473_fail:
    goto rx1468_fail
  rxcap_1473_done:
  # rx subrule "O" subtype=capture negate=
    rx1468_cur."!cursor_pos"(rx1468_pos)
    $P10 = rx1468_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1468_fail
    rx1468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1468_pos = $P10."pos"()
  # rx pass
    rx1468_cur."!cursor_pass"(rx1468_pos, "infix:sym<||>")
    if_null rx1468_debug, debug_1058
    rx1468_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1468_pos)
  debug_1058:
    .return (rx1468_cur)
  rx1468_restart:
.annotate 'line', 4
    if_null rx1468_debug, debug_1059
    rx1468_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1059:
  rx1468_fail:
    (rx1468_rep, rx1468_pos, $I10, $P10) = rx1468_cur."!mark_fail"(0)
    lt rx1468_pos, -1, rx1468_done
    eq rx1468_pos, -1, rx1468_fail
    jump $I10
  rx1468_done:
    rx1468_cur."!cursor_fail"()
    if_null rx1468_debug, debug_1060
    rx1468_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1060:
    .return (rx1468_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("349_1295994649.593") :method
.annotate 'line', 4
    $P1470 = self."!PREFIX__!subrule"("O", "||")
    new $P1471, "ResizablePMCArray"
    push $P1471, $P1470
    .return ($P1471)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("350_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1475_tgt
    .local int rx1475_pos
    .local int rx1475_off
    .local int rx1475_eos
    .local int rx1475_rep
    .local pmc rx1475_cur
    .local pmc rx1475_debug
    (rx1475_cur, rx1475_pos, rx1475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1475_cur
    .local pmc match
    .lex "$/", match
    length rx1475_eos, rx1475_tgt
    gt rx1475_pos, rx1475_eos, rx1475_done
    set rx1475_off, 0
    lt rx1475_pos, 2, rx1475_start
    sub rx1475_off, rx1475_pos, 1
    substr rx1475_tgt, rx1475_tgt, rx1475_off
  rx1475_start:
    eq $I10, 1, rx1475_restart
    if_null rx1475_debug, debug_1061
    rx1475_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1479_done
    goto rxscan1479_scan
  rxscan1479_loop:
    ($P10) = rx1475_cur."from"()
    inc $P10
    set rx1475_pos, $P10
    ge rx1475_pos, rx1475_eos, rxscan1479_done
  rxscan1479_scan:
    set_addr $I10, rxscan1479_loop
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  rxscan1479_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1480_fail
    rx1475_cur."!mark_push"(0, rx1475_pos, $I10)
  # rx literal  "//"
    add $I11, rx1475_pos, 2
    gt $I11, rx1475_eos, rx1475_fail
    sub $I11, rx1475_pos, rx1475_off
    substr $S10, rx1475_tgt, $I11, 2
    ne $S10, "//", rx1475_fail
    add rx1475_pos, 2
    set_addr $I10, rxcap_1480_fail
    ($I12, $I11) = rx1475_cur."!mark_peek"($I10)
    rx1475_cur."!cursor_pos"($I11)
    ($P10) = rx1475_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1475_pos, "")
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1480_done
  rxcap_1480_fail:
    goto rx1475_fail
  rxcap_1480_done:
  # rx subrule "O" subtype=capture negate=
    rx1475_cur."!cursor_pos"(rx1475_pos)
    $P10 = rx1475_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1475_fail
    rx1475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1475_pos = $P10."pos"()
  # rx pass
    rx1475_cur."!cursor_pass"(rx1475_pos, "infix:sym<//>")
    if_null rx1475_debug, debug_1062
    rx1475_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1475_pos)
  debug_1062:
    .return (rx1475_cur)
  rx1475_restart:
.annotate 'line', 4
    if_null rx1475_debug, debug_1063
    rx1475_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1063:
  rx1475_fail:
    (rx1475_rep, rx1475_pos, $I10, $P10) = rx1475_cur."!mark_fail"(0)
    lt rx1475_pos, -1, rx1475_done
    eq rx1475_pos, -1, rx1475_fail
    jump $I10
  rx1475_done:
    rx1475_cur."!cursor_fail"()
    if_null rx1475_debug, debug_1064
    rx1475_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1064:
    .return (rx1475_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("351_1295994649.593") :method
.annotate 'line', 4
    $P1477 = self."!PREFIX__!subrule"("O", "//")
    new $P1478, "ResizablePMCArray"
    push $P1478, $P1477
    .return ($P1478)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("352_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1482_tgt
    .local int rx1482_pos
    .local int rx1482_off
    .local int rx1482_eos
    .local int rx1482_rep
    .local pmc rx1482_cur
    .local pmc rx1482_debug
    (rx1482_cur, rx1482_pos, rx1482_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1482_cur
    .local pmc match
    .lex "$/", match
    length rx1482_eos, rx1482_tgt
    gt rx1482_pos, rx1482_eos, rx1482_done
    set rx1482_off, 0
    lt rx1482_pos, 2, rx1482_start
    sub rx1482_off, rx1482_pos, 1
    substr rx1482_tgt, rx1482_tgt, rx1482_off
  rx1482_start:
    eq $I10, 1, rx1482_restart
    if_null rx1482_debug, debug_1065
    rx1482_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1486_done
    goto rxscan1486_scan
  rxscan1486_loop:
    ($P10) = rx1482_cur."from"()
    inc $P10
    set rx1482_pos, $P10
    ge rx1482_pos, rx1482_eos, rxscan1486_done
  rxscan1486_scan:
    set_addr $I10, rxscan1486_loop
    rx1482_cur."!mark_push"(0, rx1482_pos, $I10)
  rxscan1486_done:
.annotate 'line', 618
  # rx literal  "??"
    add $I11, rx1482_pos, 2
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    substr $S10, rx1482_tgt, $I11, 2
    ne $S10, "??", rx1482_fail
    add rx1482_pos, 2
.annotate 'line', 619
  # rx subrule "ws" subtype=method negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."ws"()
    unless $P10, rx1482_fail
    rx1482_pos = $P10."pos"()
.annotate 'line', 620
  # rx subrule "EXPR" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."EXPR"("i=")
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1482_pos = $P10."pos"()
.annotate 'line', 621
  # rx literal  "!!"
    add $I11, rx1482_pos, 2
    gt $I11, rx1482_eos, rx1482_fail
    sub $I11, rx1482_pos, rx1482_off
    substr $S10, rx1482_tgt, $I11, 2
    ne $S10, "!!", rx1482_fail
    add rx1482_pos, 2
.annotate 'line', 622
  # rx subrule "O" subtype=capture negate=
    rx1482_cur."!cursor_pos"(rx1482_pos)
    $P10 = rx1482_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1482_fail
    rx1482_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1482_pos = $P10."pos"()
.annotate 'line', 617
  # rx pass
    rx1482_cur."!cursor_pass"(rx1482_pos, "infix:sym<?? !!>")
    if_null rx1482_debug, debug_1066
    rx1482_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1482_pos)
  debug_1066:
    .return (rx1482_cur)
  rx1482_restart:
.annotate 'line', 4
    if_null rx1482_debug, debug_1067
    rx1482_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1067:
  rx1482_fail:
    (rx1482_rep, rx1482_pos, $I10, $P10) = rx1482_cur."!mark_fail"(0)
    lt rx1482_pos, -1, rx1482_done
    eq rx1482_pos, -1, rx1482_fail
    jump $I10
  rx1482_done:
    rx1482_cur."!cursor_fail"()
    if_null rx1482_debug, debug_1068
    rx1482_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1068:
    .return (rx1482_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("353_1295994649.593") :method
.annotate 'line', 4
    $P1484 = self."!PREFIX__!subrule"("ws", "??")
    new $P1485, "ResizablePMCArray"
    push $P1485, $P1484
    .return ($P1485)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("354_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1488_tgt
    .local int rx1488_pos
    .local int rx1488_off
    .local int rx1488_eos
    .local int rx1488_rep
    .local pmc rx1488_cur
    .local pmc rx1488_debug
    (rx1488_cur, rx1488_pos, rx1488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1488_cur
    .local pmc match
    .lex "$/", match
    length rx1488_eos, rx1488_tgt
    gt rx1488_pos, rx1488_eos, rx1488_done
    set rx1488_off, 0
    lt rx1488_pos, 2, rx1488_start
    sub rx1488_off, rx1488_pos, 1
    substr rx1488_tgt, rx1488_tgt, rx1488_off
  rx1488_start:
    eq $I10, 1, rx1488_restart
    if_null rx1488_debug, debug_1069
    rx1488_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1492_done
    goto rxscan1492_scan
  rxscan1492_loop:
    ($P10) = rx1488_cur."from"()
    inc $P10
    set rx1488_pos, $P10
    ge rx1488_pos, rx1488_eos, rxscan1492_done
  rxscan1492_scan:
    set_addr $I10, rxscan1492_loop
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  rxscan1492_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1493_fail
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  # rx literal  "="
    add $I11, rx1488_pos, 1
    gt $I11, rx1488_eos, rx1488_fail
    sub $I11, rx1488_pos, rx1488_off
    ord $I11, rx1488_tgt, $I11
    ne $I11, 61, rx1488_fail
    add rx1488_pos, 1
    set_addr $I10, rxcap_1493_fail
    ($I12, $I11) = rx1488_cur."!mark_peek"($I10)
    rx1488_cur."!cursor_pos"($I11)
    ($P10) = rx1488_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1488_pos, "")
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1493_done
  rxcap_1493_fail:
    goto rx1488_fail
  rxcap_1493_done:
  # rx subrule "panic" subtype=method negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1488_fail
    rx1488_pos = $P10."pos"()
.annotate 'line', 625
  # rx pass
    rx1488_cur."!cursor_pass"(rx1488_pos, "infix:sym<=>")
    if_null rx1488_debug, debug_1070
    rx1488_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1488_pos)
  debug_1070:
    .return (rx1488_cur)
  rx1488_restart:
.annotate 'line', 4
    if_null rx1488_debug, debug_1071
    rx1488_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1071:
  rx1488_fail:
    (rx1488_rep, rx1488_pos, $I10, $P10) = rx1488_cur."!mark_fail"(0)
    lt rx1488_pos, -1, rx1488_done
    eq rx1488_pos, -1, rx1488_fail
    jump $I10
  rx1488_done:
    rx1488_cur."!cursor_fail"()
    if_null rx1488_debug, debug_1072
    rx1488_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1072:
    .return (rx1488_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("355_1295994649.593") :method
.annotate 'line', 4
    $P1490 = self."!PREFIX__!subrule"("panic", "=")
    new $P1491, "ResizablePMCArray"
    push $P1491, $P1490
    .return ($P1491)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("356_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1495_tgt
    .local int rx1495_pos
    .local int rx1495_off
    .local int rx1495_eos
    .local int rx1495_rep
    .local pmc rx1495_cur
    .local pmc rx1495_debug
    (rx1495_cur, rx1495_pos, rx1495_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1495_cur
    .local pmc match
    .lex "$/", match
    length rx1495_eos, rx1495_tgt
    gt rx1495_pos, rx1495_eos, rx1495_done
    set rx1495_off, 0
    lt rx1495_pos, 2, rx1495_start
    sub rx1495_off, rx1495_pos, 1
    substr rx1495_tgt, rx1495_tgt, rx1495_off
  rx1495_start:
    eq $I10, 1, rx1495_restart
    if_null rx1495_debug, debug_1073
    rx1495_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1499_done
    goto rxscan1499_scan
  rxscan1499_loop:
    ($P10) = rx1495_cur."from"()
    inc $P10
    set rx1495_pos, $P10
    ge rx1495_pos, rx1495_eos, rxscan1499_done
  rxscan1499_scan:
    set_addr $I10, rxscan1499_loop
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  rxscan1499_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1500_fail
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  # rx literal  ":="
    add $I11, rx1495_pos, 2
    gt $I11, rx1495_eos, rx1495_fail
    sub $I11, rx1495_pos, rx1495_off
    substr $S10, rx1495_tgt, $I11, 2
    ne $S10, ":=", rx1495_fail
    add rx1495_pos, 2
    set_addr $I10, rxcap_1500_fail
    ($I12, $I11) = rx1495_cur."!mark_peek"($I10)
    rx1495_cur."!cursor_pos"($I11)
    ($P10) = rx1495_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1495_pos, "")
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1500_done
  rxcap_1500_fail:
    goto rx1495_fail
  rxcap_1500_done:
  # rx subrule "O" subtype=capture negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1495_fail
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1495_pos = $P10."pos"()
  # rx pass
    rx1495_cur."!cursor_pass"(rx1495_pos, "infix:sym<:=>")
    if_null rx1495_debug, debug_1074
    rx1495_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1495_pos)
  debug_1074:
    .return (rx1495_cur)
  rx1495_restart:
.annotate 'line', 4
    if_null rx1495_debug, debug_1075
    rx1495_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1075:
  rx1495_fail:
    (rx1495_rep, rx1495_pos, $I10, $P10) = rx1495_cur."!mark_fail"(0)
    lt rx1495_pos, -1, rx1495_done
    eq rx1495_pos, -1, rx1495_fail
    jump $I10
  rx1495_done:
    rx1495_cur."!cursor_fail"()
    if_null rx1495_debug, debug_1076
    rx1495_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1076:
    .return (rx1495_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("357_1295994649.593") :method
.annotate 'line', 4
    $P1497 = self."!PREFIX__!subrule"("O", ":=")
    new $P1498, "ResizablePMCArray"
    push $P1498, $P1497
    .return ($P1498)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("358_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1502_tgt
    .local int rx1502_pos
    .local int rx1502_off
    .local int rx1502_eos
    .local int rx1502_rep
    .local pmc rx1502_cur
    .local pmc rx1502_debug
    (rx1502_cur, rx1502_pos, rx1502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1502_cur
    .local pmc match
    .lex "$/", match
    length rx1502_eos, rx1502_tgt
    gt rx1502_pos, rx1502_eos, rx1502_done
    set rx1502_off, 0
    lt rx1502_pos, 2, rx1502_start
    sub rx1502_off, rx1502_pos, 1
    substr rx1502_tgt, rx1502_tgt, rx1502_off
  rx1502_start:
    eq $I10, 1, rx1502_restart
    if_null rx1502_debug, debug_1077
    rx1502_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1506_done
    goto rxscan1506_scan
  rxscan1506_loop:
    ($P10) = rx1502_cur."from"()
    inc $P10
    set rx1502_pos, $P10
    ge rx1502_pos, rx1502_eos, rxscan1506_done
  rxscan1506_scan:
    set_addr $I10, rxscan1506_loop
    rx1502_cur."!mark_push"(0, rx1502_pos, $I10)
  rxscan1506_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1507_fail
    rx1502_cur."!mark_push"(0, rx1502_pos, $I10)
  # rx literal  "::="
    add $I11, rx1502_pos, 3
    gt $I11, rx1502_eos, rx1502_fail
    sub $I11, rx1502_pos, rx1502_off
    substr $S10, rx1502_tgt, $I11, 3
    ne $S10, "::=", rx1502_fail
    add rx1502_pos, 3
    set_addr $I10, rxcap_1507_fail
    ($I12, $I11) = rx1502_cur."!mark_peek"($I10)
    rx1502_cur."!cursor_pos"($I11)
    ($P10) = rx1502_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1502_pos, "")
    rx1502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1507_done
  rxcap_1507_fail:
    goto rx1502_fail
  rxcap_1507_done:
  # rx subrule "O" subtype=capture negate=
    rx1502_cur."!cursor_pos"(rx1502_pos)
    $P10 = rx1502_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1502_fail
    rx1502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1502_pos = $P10."pos"()
  # rx pass
    rx1502_cur."!cursor_pass"(rx1502_pos, "infix:sym<::=>")
    if_null rx1502_debug, debug_1078
    rx1502_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1502_pos)
  debug_1078:
    .return (rx1502_cur)
  rx1502_restart:
.annotate 'line', 4
    if_null rx1502_debug, debug_1079
    rx1502_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1079:
  rx1502_fail:
    (rx1502_rep, rx1502_pos, $I10, $P10) = rx1502_cur."!mark_fail"(0)
    lt rx1502_pos, -1, rx1502_done
    eq rx1502_pos, -1, rx1502_fail
    jump $I10
  rx1502_done:
    rx1502_cur."!cursor_fail"()
    if_null rx1502_debug, debug_1080
    rx1502_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1080:
    .return (rx1502_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("359_1295994649.593") :method
.annotate 'line', 4
    $P1504 = self."!PREFIX__!subrule"("O", "::=")
    new $P1505, "ResizablePMCArray"
    push $P1505, $P1504
    .return ($P1505)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("360_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1509_tgt
    .local int rx1509_pos
    .local int rx1509_off
    .local int rx1509_eos
    .local int rx1509_rep
    .local pmc rx1509_cur
    .local pmc rx1509_debug
    (rx1509_cur, rx1509_pos, rx1509_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1509_cur
    .local pmc match
    .lex "$/", match
    length rx1509_eos, rx1509_tgt
    gt rx1509_pos, rx1509_eos, rx1509_done
    set rx1509_off, 0
    lt rx1509_pos, 2, rx1509_start
    sub rx1509_off, rx1509_pos, 1
    substr rx1509_tgt, rx1509_tgt, rx1509_off
  rx1509_start:
    eq $I10, 1, rx1509_restart
    if_null rx1509_debug, debug_1081
    rx1509_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1513_done
    goto rxscan1513_scan
  rxscan1513_loop:
    ($P10) = rx1509_cur."from"()
    inc $P10
    set rx1509_pos, $P10
    ge rx1509_pos, rx1509_eos, rxscan1513_done
  rxscan1513_scan:
    set_addr $I10, rxscan1513_loop
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  rxscan1513_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1514_fail
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  # rx literal  ","
    add $I11, rx1509_pos, 1
    gt $I11, rx1509_eos, rx1509_fail
    sub $I11, rx1509_pos, rx1509_off
    ord $I11, rx1509_tgt, $I11
    ne $I11, 44, rx1509_fail
    add rx1509_pos, 1
    set_addr $I10, rxcap_1514_fail
    ($I12, $I11) = rx1509_cur."!mark_peek"($I10)
    rx1509_cur."!cursor_pos"($I11)
    ($P10) = rx1509_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1509_pos, "")
    rx1509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1514_done
  rxcap_1514_fail:
    goto rx1509_fail
  rxcap_1514_done:
  # rx subrule "O" subtype=capture negate=
    rx1509_cur."!cursor_pos"(rx1509_pos)
    $P10 = rx1509_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1509_fail
    rx1509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1509_pos = $P10."pos"()
  # rx pass
    rx1509_cur."!cursor_pass"(rx1509_pos, "infix:sym<,>")
    if_null rx1509_debug, debug_1082
    rx1509_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1509_pos)
  debug_1082:
    .return (rx1509_cur)
  rx1509_restart:
.annotate 'line', 4
    if_null rx1509_debug, debug_1083
    rx1509_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1083:
  rx1509_fail:
    (rx1509_rep, rx1509_pos, $I10, $P10) = rx1509_cur."!mark_fail"(0)
    lt rx1509_pos, -1, rx1509_done
    eq rx1509_pos, -1, rx1509_fail
    jump $I10
  rx1509_done:
    rx1509_cur."!cursor_fail"()
    if_null rx1509_debug, debug_1084
    rx1509_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1084:
    .return (rx1509_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("361_1295994649.593") :method
.annotate 'line', 4
    $P1511 = self."!PREFIX__!subrule"("O", ",")
    new $P1512, "ResizablePMCArray"
    push $P1512, $P1511
    .return ($P1512)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("362_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P1524 = "364_1295994649.593" 
    capture_lex $P1524
    .local string rx1516_tgt
    .local int rx1516_pos
    .local int rx1516_off
    .local int rx1516_eos
    .local int rx1516_rep
    .local pmc rx1516_cur
    .local pmc rx1516_debug
    (rx1516_cur, rx1516_pos, rx1516_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1516_cur
    .local pmc match
    .lex "$/", match
    length rx1516_eos, rx1516_tgt
    gt rx1516_pos, rx1516_eos, rx1516_done
    set rx1516_off, 0
    lt rx1516_pos, 2, rx1516_start
    sub rx1516_off, rx1516_pos, 1
    substr rx1516_tgt, rx1516_tgt, rx1516_off
  rx1516_start:
    eq $I10, 1, rx1516_restart
    if_null rx1516_debug, debug_1085
    rx1516_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1519_done
    goto rxscan1519_scan
  rxscan1519_loop:
    ($P10) = rx1516_cur."from"()
    inc $P10
    set rx1516_pos, $P10
    ge rx1516_pos, rx1516_eos, rxscan1519_done
  rxscan1519_scan:
    set_addr $I10, rxscan1519_loop
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  rxscan1519_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1520_fail
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  # rx literal  "return"
    add $I11, rx1516_pos, 6
    gt $I11, rx1516_eos, rx1516_fail
    sub $I11, rx1516_pos, rx1516_off
    substr $S10, rx1516_tgt, $I11, 6
    ne $S10, "return", rx1516_fail
    add rx1516_pos, 6
    set_addr $I10, rxcap_1520_fail
    ($I12, $I11) = rx1516_cur."!mark_peek"($I10)
    rx1516_cur."!cursor_pos"($I11)
    ($P10) = rx1516_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1516_pos, "")
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1520_done
  rxcap_1520_fail:
    goto rx1516_fail
  rxcap_1520_done:
  # rx charclass s
    ge rx1516_pos, rx1516_eos, rx1516_fail
    sub $I10, rx1516_pos, rx1516_off
    is_cclass $I11, 32, rx1516_tgt, $I10
    unless $I11, rx1516_fail
    inc rx1516_pos
  # rx subrule "O" subtype=capture negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1516_fail
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1516_pos = $P10."pos"()
    rx1516_cur."!cursor_pos"(rx1516_pos)
    find_lex $P1521, unicode:"$\x{a2}"
    $P1522 = $P1521."MATCH"()
    store_lex "$/", $P1522
    .const 'Sub' $P1524 = "364_1295994649.593" 
    capture_lex $P1524
    $P1526 = $P1524()
  # rx pass
    rx1516_cur."!cursor_pass"(rx1516_pos, "prefix:sym<return>")
    if_null rx1516_debug, debug_1086
    rx1516_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1516_pos)
  debug_1086:
    .return (rx1516_cur)
  rx1516_restart:
.annotate 'line', 4
    if_null rx1516_debug, debug_1087
    rx1516_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1087:
  rx1516_fail:
    (rx1516_rep, rx1516_pos, $I10, $P10) = rx1516_cur."!mark_fail"(0)
    lt rx1516_pos, -1, rx1516_done
    eq rx1516_pos, -1, rx1516_fail
    jump $I10
  rx1516_done:
    rx1516_cur."!cursor_fail"()
    if_null rx1516_debug, debug_1088
    rx1516_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1088:
    .return (rx1516_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("363_1295994649.593") :method
.annotate 'line', 4
    new $P1518, "ResizablePMCArray"
    push $P1518, "return"
    .return ($P1518)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1523"  :anon :subid("364_1295994649.593") :outer("362_1295994649.593")
.annotate 'line', 633
    new $P1525, "Integer"
    assign $P1525, 1
    store_dynamic_lex "$*RETURN_USED", $P1525
    .return ($P1525)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("365_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1089
    rx1528_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1531_done
    goto rxscan1531_scan
  rxscan1531_loop:
    ($P10) = rx1528_cur."from"()
    inc $P10
    set rx1528_pos, $P10
    ge rx1528_pos, rx1528_eos, rxscan1531_done
  rxscan1531_scan:
    set_addr $I10, rxscan1531_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1531_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1532_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  "make"
    add $I11, rx1528_pos, 4
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I11, 4
    ne $S10, "make", rx1528_fail
    add rx1528_pos, 4
    set_addr $I10, rxcap_1532_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1532_done
  rxcap_1532_fail:
    goto rx1528_fail
  rxcap_1532_done:
  # rx charclass s
    ge rx1528_pos, rx1528_eos, rx1528_fail
    sub $I10, rx1528_pos, rx1528_off
    is_cclass $I11, 32, rx1528_tgt, $I10
    unless $I11, rx1528_fail
    inc rx1528_pos
  # rx subrule "O" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."O"("%list_prefix")
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "prefix:sym<make>")
    if_null rx1528_debug, debug_1090
    rx1528_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1528_pos)
  debug_1090:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 4
    if_null rx1528_debug, debug_1091
    rx1528_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1091:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1092
    rx1528_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1092:
    .return (rx1528_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("366_1295994649.593") :method
.annotate 'line', 4
    new $P1530, "ResizablePMCArray"
    push $P1530, "make"
    .return ($P1530)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("367_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1534_tgt
    .local int rx1534_pos
    .local int rx1534_off
    .local int rx1534_eos
    .local int rx1534_rep
    .local pmc rx1534_cur
    .local pmc rx1534_debug
    (rx1534_cur, rx1534_pos, rx1534_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1534_cur
    .local pmc match
    .lex "$/", match
    length rx1534_eos, rx1534_tgt
    gt rx1534_pos, rx1534_eos, rx1534_done
    set rx1534_off, 0
    lt rx1534_pos, 2, rx1534_start
    sub rx1534_off, rx1534_pos, 1
    substr rx1534_tgt, rx1534_tgt, rx1534_off
  rx1534_start:
    eq $I10, 1, rx1534_restart
    if_null rx1534_debug, debug_1093
    rx1534_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1537_done
    goto rxscan1537_scan
  rxscan1537_loop:
    ($P10) = rx1534_cur."from"()
    inc $P10
    set rx1534_pos, $P10
    ge rx1534_pos, rx1534_eos, rxscan1537_done
  rxscan1537_scan:
    set_addr $I10, rxscan1537_loop
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  rxscan1537_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1538_fail
    rx1534_cur."!mark_push"(0, rx1534_pos, $I10)
  # rx literal  "last"
    add $I11, rx1534_pos, 4
    gt $I11, rx1534_eos, rx1534_fail
    sub $I11, rx1534_pos, rx1534_off
    substr $S10, rx1534_tgt, $I11, 4
    ne $S10, "last", rx1534_fail
    add rx1534_pos, 4
    set_addr $I10, rxcap_1538_fail
    ($I12, $I11) = rx1534_cur."!mark_peek"($I10)
    rx1534_cur."!cursor_pos"($I11)
    ($P10) = rx1534_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1534_pos, "")
    rx1534_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1538_done
  rxcap_1538_fail:
    goto rx1534_fail
  rxcap_1538_done:
  # rx pass
    rx1534_cur."!cursor_pass"(rx1534_pos, "term:sym<last>")
    if_null rx1534_debug, debug_1094
    rx1534_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1534_pos)
  debug_1094:
    .return (rx1534_cur)
  rx1534_restart:
.annotate 'line', 4
    if_null rx1534_debug, debug_1095
    rx1534_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1095:
  rx1534_fail:
    (rx1534_rep, rx1534_pos, $I10, $P10) = rx1534_cur."!mark_fail"(0)
    lt rx1534_pos, -1, rx1534_done
    eq rx1534_pos, -1, rx1534_fail
    jump $I10
  rx1534_done:
    rx1534_cur."!cursor_fail"()
    if_null rx1534_debug, debug_1096
    rx1534_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1096:
    .return (rx1534_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("368_1295994649.593") :method
.annotate 'line', 4
    new $P1536, "ResizablePMCArray"
    push $P1536, "last"
    .return ($P1536)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("369_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1540_tgt
    .local int rx1540_pos
    .local int rx1540_off
    .local int rx1540_eos
    .local int rx1540_rep
    .local pmc rx1540_cur
    .local pmc rx1540_debug
    (rx1540_cur, rx1540_pos, rx1540_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1540_cur
    .local pmc match
    .lex "$/", match
    length rx1540_eos, rx1540_tgt
    gt rx1540_pos, rx1540_eos, rx1540_done
    set rx1540_off, 0
    lt rx1540_pos, 2, rx1540_start
    sub rx1540_off, rx1540_pos, 1
    substr rx1540_tgt, rx1540_tgt, rx1540_off
  rx1540_start:
    eq $I10, 1, rx1540_restart
    if_null rx1540_debug, debug_1097
    rx1540_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1543_done
    goto rxscan1543_scan
  rxscan1543_loop:
    ($P10) = rx1540_cur."from"()
    inc $P10
    set rx1540_pos, $P10
    ge rx1540_pos, rx1540_eos, rxscan1543_done
  rxscan1543_scan:
    set_addr $I10, rxscan1543_loop
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  rxscan1543_done:
.annotate 'line', 636
  # rx subcapture "sym"
    set_addr $I10, rxcap_1544_fail
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  # rx literal  "next"
    add $I11, rx1540_pos, 4
    gt $I11, rx1540_eos, rx1540_fail
    sub $I11, rx1540_pos, rx1540_off
    substr $S10, rx1540_tgt, $I11, 4
    ne $S10, "next", rx1540_fail
    add rx1540_pos, 4
    set_addr $I10, rxcap_1544_fail
    ($I12, $I11) = rx1540_cur."!mark_peek"($I10)
    rx1540_cur."!cursor_pos"($I11)
    ($P10) = rx1540_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1540_pos, "")
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1544_done
  rxcap_1544_fail:
    goto rx1540_fail
  rxcap_1544_done:
  # rx pass
    rx1540_cur."!cursor_pass"(rx1540_pos, "term:sym<next>")
    if_null rx1540_debug, debug_1098
    rx1540_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1540_pos)
  debug_1098:
    .return (rx1540_cur)
  rx1540_restart:
.annotate 'line', 4
    if_null rx1540_debug, debug_1099
    rx1540_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1099:
  rx1540_fail:
    (rx1540_rep, rx1540_pos, $I10, $P10) = rx1540_cur."!mark_fail"(0)
    lt rx1540_pos, -1, rx1540_done
    eq rx1540_pos, -1, rx1540_fail
    jump $I10
  rx1540_done:
    rx1540_cur."!cursor_fail"()
    if_null rx1540_debug, debug_1100
    rx1540_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1100:
    .return (rx1540_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("370_1295994649.593") :method
.annotate 'line', 4
    new $P1542, "ResizablePMCArray"
    push $P1542, "next"
    .return ($P1542)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("371_1295994649.593") :method :outer("11_1295994649.593")
.annotate 'line', 4
    .local string rx1546_tgt
    .local int rx1546_pos
    .local int rx1546_off
    .local int rx1546_eos
    .local int rx1546_rep
    .local pmc rx1546_cur
    .local pmc rx1546_debug
    (rx1546_cur, rx1546_pos, rx1546_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1546_cur
    .local pmc match
    .lex "$/", match
    length rx1546_eos, rx1546_tgt
    gt rx1546_pos, rx1546_eos, rx1546_done
    set rx1546_off, 0
    lt rx1546_pos, 2, rx1546_start
    sub rx1546_off, rx1546_pos, 1
    substr rx1546_tgt, rx1546_tgt, rx1546_off
  rx1546_start:
    eq $I10, 1, rx1546_restart
    if_null rx1546_debug, debug_1101
    rx1546_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1549_done
    goto rxscan1549_scan
  rxscan1549_loop:
    ($P10) = rx1546_cur."from"()
    inc $P10
    set rx1546_pos, $P10
    ge rx1546_pos, rx1546_eos, rxscan1549_done
  rxscan1549_scan:
    set_addr $I10, rxscan1549_loop
    rx1546_cur."!mark_push"(0, rx1546_pos, $I10)
  rxscan1549_done:
.annotate 'line', 637
  # rx subcapture "sym"
    set_addr $I10, rxcap_1550_fail
    rx1546_cur."!mark_push"(0, rx1546_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1546_pos, 4
    gt $I11, rx1546_eos, rx1546_fail
    sub $I11, rx1546_pos, rx1546_off
    substr $S10, rx1546_tgt, $I11, 4
    ne $S10, "redo", rx1546_fail
    add rx1546_pos, 4
    set_addr $I10, rxcap_1550_fail
    ($I12, $I11) = rx1546_cur."!mark_peek"($I10)
    rx1546_cur."!cursor_pos"($I11)
    ($P10) = rx1546_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1546_pos, "")
    rx1546_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1550_done
  rxcap_1550_fail:
    goto rx1546_fail
  rxcap_1550_done:
  # rx pass
    rx1546_cur."!cursor_pass"(rx1546_pos, "term:sym<redo>")
    if_null rx1546_debug, debug_1102
    rx1546_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1546_pos)
  debug_1102:
    .return (rx1546_cur)
  rx1546_restart:
.annotate 'line', 4
    if_null rx1546_debug, debug_1103
    rx1546_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1103:
  rx1546_fail:
    (rx1546_rep, rx1546_pos, $I10, $P10) = rx1546_cur."!mark_fail"(0)
    lt rx1546_pos, -1, rx1546_done
    eq rx1546_pos, -1, rx1546_fail
    jump $I10
  rx1546_done:
    rx1546_cur."!cursor_fail"()
    if_null rx1546_debug, debug_1104
    rx1546_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1104:
    .return (rx1546_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("372_1295994649.593") :method
.annotate 'line', 4
    new $P1548, "ResizablePMCArray"
    push $P1548, "redo"
    .return ($P1548)
.end


.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("373_1295994649.593") :outer("11_1295994649.593")
    .param pmc param_1552
    .param pmc param_1553
.annotate 'line', 639
    .lex "self", param_1552
    .lex "$/", param_1553
.annotate 'line', 641
    new $P1554, "Undef"
    .lex "$t", $P1554
    find_lex $P1555, "$/"
    unless_null $P1555, vivify_1105
    $P1555 = root_new ['parrot';'ResizablePMCArray']
  vivify_1105:
    set $P1556, $P1555[0]
    unless_null $P1556, vivify_1106
    new $P1556, "Undef"
  vivify_1106:
    store_lex "$t", $P1556
    find_lex $P1557, "$/"
    unless_null $P1557, vivify_1107
    $P1557 = root_new ['parrot';'ResizablePMCArray']
  vivify_1107:
    set $P1558, $P1557[1]
    unless_null $P1558, vivify_1108
    new $P1558, "Undef"
  vivify_1108:
    find_lex $P1559, "$/"
    unless_null $P1559, vivify_1109
    $P1559 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1559
  vivify_1109:
    set $P1559[0], $P1558
    find_lex $P1560, "$t"
    find_lex $P1561, "$/"
    unless_null $P1561, vivify_1110
    $P1561 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1561
  vivify_1110:
    set $P1561[1], $P1560
.annotate 'line', 639
    .return ($P1560)
.end


.namespace ["NQP";"Regex"]
.sub "_block1562"  :subid("374_1295994649.593") :outer("11_1295994649.593")
.annotate 'line', 645
    .const 'Sub' $P1627 = "395_1295994649.593" 
    capture_lex $P1627
    .const 'Sub' $P1620 = "393_1295994649.593" 
    capture_lex $P1620
    .const 'Sub' $P1615 = "391_1295994649.593" 
    capture_lex $P1615
    .const 'Sub' $P1603 = "388_1295994649.593" 
    capture_lex $P1603
    .const 'Sub' $P1593 = "385_1295994649.593" 
    capture_lex $P1593
    .const 'Sub' $P1588 = "383_1295994649.593" 
    capture_lex $P1588
    .const 'Sub' $P1579 = "380_1295994649.593" 
    capture_lex $P1579
    .const 'Sub' $P1574 = "378_1295994649.593" 
    capture_lex $P1574
    .const 'Sub' $P1565 = "375_1295994649.593" 
    capture_lex $P1565
    get_global $P1564, "$?CLASS"
    .const 'Sub' $P1620 = "393_1295994649.593" 
    capture_lex $P1620
    .return ($P1620)
.end


.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1111") :outer("374_1295994649.593")
.annotate 'line', 645
    get_hll_global $P1563, ["NQP";"Regex"], "_block1562" 
    .local pmc block
    set block, $P1563
    .const 'Sub' $P1627 = "395_1295994649.593" 
    capture_lex $P1627
    $P1627()
.end


.namespace ["NQP";"Regex"]
.sub "_block1626"  :anon :subid("395_1295994649.593") :outer("374_1295994649.593")
.annotate 'line', 645
    get_hll_global $P1628, "NQPClassHOW"
    $P1629 = $P1628."new_type"("Regex" :named("name"))
    .local pmc type_obj
    set type_obj, $P1629
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1630, type_obj
    .const 'Sub' $P1631 = "375_1295994649.593" 
    $P1630."add_method"(type_obj, "metachar:sym<:my>", $P1631)
    get_how $P1632, type_obj
    get_global $P1633, "!PREFIX__metachar:sym<:my>"
    $P1632."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1633)
    get_how $P1634, type_obj
    .const 'Sub' $P1635 = "378_1295994649.593" 
    $P1634."add_method"(type_obj, "metachar:sym<{ }>", $P1635)
    get_how $P1636, type_obj
    get_global $P1637, "!PREFIX__metachar:sym<{ }>"
    $P1636."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1637)
    get_how $P1638, type_obj
    .const 'Sub' $P1639 = "380_1295994649.593" 
    $P1638."add_method"(type_obj, "metachar:sym<nqpvar>", $P1639)
    get_how $P1640, type_obj
    get_global $P1641, "!PREFIX__metachar:sym<nqpvar>"
    $P1640."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1641)
    get_how $P1642, type_obj
    .const 'Sub' $P1643 = "383_1295994649.593" 
    $P1642."add_method"(type_obj, "assertion:sym<{ }>", $P1643)
    get_how $P1644, type_obj
    get_global $P1645, "!PREFIX__assertion:sym<{ }>"
    $P1644."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1645)
    get_how $P1646, type_obj
    .const 'Sub' $P1647 = "385_1295994649.593" 
    $P1646."add_method"(type_obj, "assertion:sym<?{ }>", $P1647)
    get_how $P1648, type_obj
    get_global $P1649, "!PREFIX__assertion:sym<?{ }>"
    $P1648."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1649)
    get_how $P1650, type_obj
    .const 'Sub' $P1651 = "388_1295994649.593" 
    $P1650."add_method"(type_obj, "assertion:sym<name>", $P1651)
    get_how $P1652, type_obj
    get_global $P1653, "!PREFIX__assertion:sym<name>"
    $P1652."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1653)
    get_how $P1654, type_obj
    .const 'Sub' $P1655 = "391_1295994649.593" 
    $P1654."add_method"(type_obj, "assertion:sym<var>", $P1655)
    get_how $P1656, type_obj
    get_global $P1657, "!PREFIX__assertion:sym<var>"
    $P1656."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1657)
    get_how $P1658, type_obj
    .const 'Sub' $P1659 = "393_1295994649.593" 
    $P1658."add_method"(type_obj, "codeblock", $P1659)
    get_how $P1660, type_obj
    get_global $P1661, "!PREFIX__codeblock"
    $P1660."add_method"(type_obj, "!PREFIX__codeblock", $P1661)
    get_how $P1662, type_obj
    get_hll_global $P1663, ["Regex";"P6Regex"], "Grammar"
    $P1662."add_parent"(type_obj, $P1663)
    get_how $P1664, type_obj
    $P1665 = $P1664."compose"(type_obj)
    .return ($P1665)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("375_1295994649.593") :method :outer("374_1295994649.593")
.annotate 'line', 645
    .const 'Sub' $P1571 = "377_1295994649.593" 
    capture_lex $P1571
    .local string rx1566_tgt
    .local int rx1566_pos
    .local int rx1566_off
    .local int rx1566_eos
    .local int rx1566_rep
    .local pmc rx1566_cur
    .local pmc rx1566_debug
    (rx1566_cur, rx1566_pos, rx1566_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1566_cur
    .local pmc match
    .lex "$/", match
    length rx1566_eos, rx1566_tgt
    gt rx1566_pos, rx1566_eos, rx1566_done
    set rx1566_off, 0
    lt rx1566_pos, 2, rx1566_start
    sub rx1566_off, rx1566_pos, 1
    substr rx1566_tgt, rx1566_tgt, rx1566_off
  rx1566_start:
    eq $I10, 1, rx1566_restart
    if_null rx1566_debug, debug_1112
    rx1566_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1112:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1569_done
    goto rxscan1569_scan
  rxscan1569_loop:
    ($P10) = rx1566_cur."from"()
    inc $P10
    set rx1566_pos, $P10
    ge rx1566_pos, rx1566_eos, rxscan1569_done
  rxscan1569_scan:
    set_addr $I10, rxscan1569_loop
    rx1566_cur."!mark_push"(0, rx1566_pos, $I10)
  rxscan1569_done:
.annotate 'line', 647
  # rx literal  ":"
    add $I11, rx1566_pos, 1
    gt $I11, rx1566_eos, rx1566_fail
    sub $I11, rx1566_pos, rx1566_off
    ord $I11, rx1566_tgt, $I11
    ne $I11, 58, rx1566_fail
    add rx1566_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1566_cur."!cursor_pos"(rx1566_pos)
    .const 'Sub' $P1571 = "377_1295994649.593" 
    capture_lex $P1571
    $P10 = rx1566_cur."before"($P1571)
    unless $P10, rx1566_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1566_cur."!cursor_pos"(rx1566_pos)
    $P10 = rx1566_cur."LANG"("MAIN", "statement")
    unless $P10, rx1566_fail
    rx1566_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1566_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1566_cur."!cursor_pos"(rx1566_pos)
    $P10 = rx1566_cur."ws"()
    unless $P10, rx1566_fail
    rx1566_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1566_pos, 1
    gt $I11, rx1566_eos, rx1566_fail
    sub $I11, rx1566_pos, rx1566_off
    ord $I11, rx1566_tgt, $I11
    ne $I11, 59, rx1566_fail
    add rx1566_pos, 1
.annotate 'line', 646
  # rx pass
    rx1566_cur."!cursor_pass"(rx1566_pos, "metachar:sym<:my>")
    if_null rx1566_debug, debug_1117
    rx1566_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1566_pos)
  debug_1117:
    .return (rx1566_cur)
  rx1566_restart:
.annotate 'line', 645
    if_null rx1566_debug, debug_1118
    rx1566_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1118:
  rx1566_fail:
    (rx1566_rep, rx1566_pos, $I10, $P10) = rx1566_cur."!mark_fail"(0)
    lt rx1566_pos, -1, rx1566_done
    eq rx1566_pos, -1, rx1566_fail
    jump $I10
  rx1566_done:
    rx1566_cur."!cursor_fail"()
    if_null rx1566_debug, debug_1119
    rx1566_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1119:
    .return (rx1566_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("376_1295994649.593") :method
.annotate 'line', 645
    new $P1568, "ResizablePMCArray"
    push $P1568, ":"
    .return ($P1568)
.end


.namespace ["NQP";"Regex"]
.sub "_block1570"  :anon :subid("377_1295994649.593") :method :outer("375_1295994649.593")
.annotate 'line', 647
    .local string rx1572_tgt
    .local int rx1572_pos
    .local int rx1572_off
    .local int rx1572_eos
    .local int rx1572_rep
    .local pmc rx1572_cur
    .local pmc rx1572_debug
    (rx1572_cur, rx1572_pos, rx1572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1572_cur
    .local pmc match
    .lex "$/", match
    length rx1572_eos, rx1572_tgt
    gt rx1572_pos, rx1572_eos, rx1572_done
    set rx1572_off, 0
    lt rx1572_pos, 2, rx1572_start
    sub rx1572_off, rx1572_pos, 1
    substr rx1572_tgt, rx1572_tgt, rx1572_off
  rx1572_start:
    eq $I10, 1, rx1572_restart
    if_null rx1572_debug, debug_1113
    rx1572_cur."!cursor_debug"("START", "")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1573_done
    goto rxscan1573_scan
  rxscan1573_loop:
    ($P10) = rx1572_cur."from"()
    inc $P10
    set rx1572_pos, $P10
    ge rx1572_pos, rx1572_eos, rxscan1573_done
  rxscan1573_scan:
    set_addr $I10, rxscan1573_loop
    rx1572_cur."!mark_push"(0, rx1572_pos, $I10)
  rxscan1573_done:
  # rx literal  "my"
    add $I11, rx1572_pos, 2
    gt $I11, rx1572_eos, rx1572_fail
    sub $I11, rx1572_pos, rx1572_off
    substr $S10, rx1572_tgt, $I11, 2
    ne $S10, "my", rx1572_fail
    add rx1572_pos, 2
  # rx pass
    rx1572_cur."!cursor_pass"(rx1572_pos, "")
    if_null rx1572_debug, debug_1114
    rx1572_cur."!cursor_debug"("PASS", "", " at pos=", rx1572_pos)
  debug_1114:
    .return (rx1572_cur)
  rx1572_restart:
    if_null rx1572_debug, debug_1115
    rx1572_cur."!cursor_debug"("NEXT", "")
  debug_1115:
  rx1572_fail:
    (rx1572_rep, rx1572_pos, $I10, $P10) = rx1572_cur."!mark_fail"(0)
    lt rx1572_pos, -1, rx1572_done
    eq rx1572_pos, -1, rx1572_fail
    jump $I10
  rx1572_done:
    rx1572_cur."!cursor_fail"()
    if_null rx1572_debug, debug_1116
    rx1572_cur."!cursor_debug"("FAIL", "")
  debug_1116:
    .return (rx1572_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("378_1295994649.593") :method :outer("374_1295994649.593")
.annotate 'line', 645
    .local string rx1575_tgt
    .local int rx1575_pos
    .local int rx1575_off
    .local int rx1575_eos
    .local int rx1575_rep
    .local pmc rx1575_cur
    .local pmc rx1575_debug
    (rx1575_cur, rx1575_pos, rx1575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1575_cur
    .local pmc match
    .lex "$/", match
    length rx1575_eos, rx1575_tgt
    gt rx1575_pos, rx1575_eos, rx1575_done
    set rx1575_off, 0
    lt rx1575_pos, 2, rx1575_start
    sub rx1575_off, rx1575_pos, 1
    substr rx1575_tgt, rx1575_tgt, rx1575_off
  rx1575_start:
    eq $I10, 1, rx1575_restart
    if_null rx1575_debug, debug_1120
    rx1575_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1120:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1578_done
    goto rxscan1578_scan
  rxscan1578_loop:
    ($P10) = rx1575_cur."from"()
    inc $P10
    set rx1575_pos, $P10
    ge rx1575_pos, rx1575_eos, rxscan1578_done
  rxscan1578_scan:
    set_addr $I10, rxscan1578_loop
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  rxscan1578_done:
.annotate 'line', 651
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1575_pos, rx1575_off
    substr $S10, rx1575_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1575_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1575_cur."!cursor_pos"(rx1575_pos)
    $P10 = rx1575_cur."codeblock"()
    unless $P10, rx1575_fail
    rx1575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1575_pos = $P10."pos"()
.annotate 'line', 650
  # rx pass
    rx1575_cur."!cursor_pass"(rx1575_pos, "metachar:sym<{ }>")
    if_null rx1575_debug, debug_1121
    rx1575_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1575_pos)
  debug_1121:
    .return (rx1575_cur)
  rx1575_restart:
.annotate 'line', 645
    if_null rx1575_debug, debug_1122
    rx1575_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1122:
  rx1575_fail:
    (rx1575_rep, rx1575_pos, $I10, $P10) = rx1575_cur."!mark_fail"(0)
    lt rx1575_pos, -1, rx1575_done
    eq rx1575_pos, -1, rx1575_fail
    jump $I10
  rx1575_done:
    rx1575_cur."!cursor_fail"()
    if_null rx1575_debug, debug_1123
    rx1575_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1123:
    .return (rx1575_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("379_1295994649.593") :method
.annotate 'line', 645
    new $P1577, "ResizablePMCArray"
    push $P1577, "{"
    .return ($P1577)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("380_1295994649.593") :method :outer("374_1295994649.593")
.annotate 'line', 645
    .const 'Sub' $P1585 = "382_1295994649.593" 
    capture_lex $P1585
    .local string rx1580_tgt
    .local int rx1580_pos
    .local int rx1580_off
    .local int rx1580_eos
    .local int rx1580_rep
    .local pmc rx1580_cur
    .local pmc rx1580_debug
    (rx1580_cur, rx1580_pos, rx1580_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1580_cur
    .local pmc match
    .lex "$/", match
    length rx1580_eos, rx1580_tgt
    gt rx1580_pos, rx1580_eos, rx1580_done
    set rx1580_off, 0
    lt rx1580_pos, 2, rx1580_start
    sub rx1580_off, rx1580_pos, 1
    substr rx1580_tgt, rx1580_tgt, rx1580_off
  rx1580_start:
    eq $I10, 1, rx1580_restart
    if_null rx1580_debug, debug_1124
    rx1580_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1124:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1583_done
    goto rxscan1583_scan
  rxscan1583_loop:
    ($P10) = rx1580_cur."from"()
    inc $P10
    set rx1580_pos, $P10
    ge rx1580_pos, rx1580_eos, rxscan1583_done
  rxscan1583_scan:
    set_addr $I10, rxscan1583_loop
    rx1580_cur."!mark_push"(0, rx1580_pos, $I10)
  rxscan1583_done:
.annotate 'line', 655
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1580_pos, rx1580_off
    substr $S10, rx1580_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1580_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1580_cur."!cursor_pos"(rx1580_pos)
    .const 'Sub' $P1585 = "382_1295994649.593" 
    capture_lex $P1585
    $P10 = rx1580_cur."before"($P1585)
    unless $P10, rx1580_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1580_cur."!cursor_pos"(rx1580_pos)
    $P10 = rx1580_cur."LANG"("MAIN", "variable")
    unless $P10, rx1580_fail
    rx1580_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1580_pos = $P10."pos"()
.annotate 'line', 654
  # rx pass
    rx1580_cur."!cursor_pass"(rx1580_pos, "metachar:sym<nqpvar>")
    if_null rx1580_debug, debug_1129
    rx1580_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1580_pos)
  debug_1129:
    .return (rx1580_cur)
  rx1580_restart:
.annotate 'line', 645
    if_null rx1580_debug, debug_1130
    rx1580_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1130:
  rx1580_fail:
    (rx1580_rep, rx1580_pos, $I10, $P10) = rx1580_cur."!mark_fail"(0)
    lt rx1580_pos, -1, rx1580_done
    eq rx1580_pos, -1, rx1580_fail
    jump $I10
  rx1580_done:
    rx1580_cur."!cursor_fail"()
    if_null rx1580_debug, debug_1131
    rx1580_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1131:
    .return (rx1580_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("381_1295994649.593") :method
.annotate 'line', 645
    new $P1582, "ResizablePMCArray"
    push $P1582, "$"
    push $P1582, "@"
    .return ($P1582)
.end


.namespace ["NQP";"Regex"]
.sub "_block1584"  :anon :subid("382_1295994649.593") :method :outer("380_1295994649.593")
.annotate 'line', 655
    .local string rx1586_tgt
    .local int rx1586_pos
    .local int rx1586_off
    .local int rx1586_eos
    .local int rx1586_rep
    .local pmc rx1586_cur
    .local pmc rx1586_debug
    (rx1586_cur, rx1586_pos, rx1586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1586_cur
    .local pmc match
    .lex "$/", match
    length rx1586_eos, rx1586_tgt
    gt rx1586_pos, rx1586_eos, rx1586_done
    set rx1586_off, 0
    lt rx1586_pos, 2, rx1586_start
    sub rx1586_off, rx1586_pos, 1
    substr rx1586_tgt, rx1586_tgt, rx1586_off
  rx1586_start:
    eq $I10, 1, rx1586_restart
    if_null rx1586_debug, debug_1125
    rx1586_cur."!cursor_debug"("START", "")
  debug_1125:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1587_done
    goto rxscan1587_scan
  rxscan1587_loop:
    ($P10) = rx1586_cur."from"()
    inc $P10
    set rx1586_pos, $P10
    ge rx1586_pos, rx1586_eos, rxscan1587_done
  rxscan1587_scan:
    set_addr $I10, rxscan1587_loop
    rx1586_cur."!mark_push"(0, rx1586_pos, $I10)
  rxscan1587_done:
  # rx charclass .
    ge rx1586_pos, rx1586_eos, rx1586_fail
    inc rx1586_pos
  # rx charclass w
    ge rx1586_pos, rx1586_eos, rx1586_fail
    sub $I10, rx1586_pos, rx1586_off
    is_cclass $I11, 8192, rx1586_tgt, $I10
    unless $I11, rx1586_fail
    inc rx1586_pos
  # rx pass
    rx1586_cur."!cursor_pass"(rx1586_pos, "")
    if_null rx1586_debug, debug_1126
    rx1586_cur."!cursor_debug"("PASS", "", " at pos=", rx1586_pos)
  debug_1126:
    .return (rx1586_cur)
  rx1586_restart:
    if_null rx1586_debug, debug_1127
    rx1586_cur."!cursor_debug"("NEXT", "")
  debug_1127:
  rx1586_fail:
    (rx1586_rep, rx1586_pos, $I10, $P10) = rx1586_cur."!mark_fail"(0)
    lt rx1586_pos, -1, rx1586_done
    eq rx1586_pos, -1, rx1586_fail
    jump $I10
  rx1586_done:
    rx1586_cur."!cursor_fail"()
    if_null rx1586_debug, debug_1128
    rx1586_cur."!cursor_debug"("FAIL", "")
  debug_1128:
    .return (rx1586_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("383_1295994649.593") :method :outer("374_1295994649.593")
.annotate 'line', 645
    .local string rx1589_tgt
    .local int rx1589_pos
    .local int rx1589_off
    .local int rx1589_eos
    .local int rx1589_rep
    .local pmc rx1589_cur
    .local pmc rx1589_debug
    (rx1589_cur, rx1589_pos, rx1589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1589_cur
    .local pmc match
    .lex "$/", match
    length rx1589_eos, rx1589_tgt
    gt rx1589_pos, rx1589_eos, rx1589_done
    set rx1589_off, 0
    lt rx1589_pos, 2, rx1589_start
    sub rx1589_off, rx1589_pos, 1
    substr rx1589_tgt, rx1589_tgt, rx1589_off
  rx1589_start:
    eq $I10, 1, rx1589_restart
    if_null rx1589_debug, debug_1132
    rx1589_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1132:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1592_done
    goto rxscan1592_scan
  rxscan1592_loop:
    ($P10) = rx1589_cur."from"()
    inc $P10
    set rx1589_pos, $P10
    ge rx1589_pos, rx1589_eos, rxscan1592_done
  rxscan1592_scan:
    set_addr $I10, rxscan1592_loop
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  rxscan1592_done:
.annotate 'line', 659
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1589_pos, rx1589_off
    substr $S10, rx1589_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1589_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1589_cur."!cursor_pos"(rx1589_pos)
    $P10 = rx1589_cur."codeblock"()
    unless $P10, rx1589_fail
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1589_pos = $P10."pos"()
.annotate 'line', 658
  # rx pass
    rx1589_cur."!cursor_pass"(rx1589_pos, "assertion:sym<{ }>")
    if_null rx1589_debug, debug_1133
    rx1589_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1589_pos)
  debug_1133:
    .return (rx1589_cur)
  rx1589_restart:
.annotate 'line', 645
    if_null rx1589_debug, debug_1134
    rx1589_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1134:
  rx1589_fail:
    (rx1589_rep, rx1589_pos, $I10, $P10) = rx1589_cur."!mark_fail"(0)
    lt rx1589_pos, -1, rx1589_done
    eq rx1589_pos, -1, rx1589_fail
    jump $I10
  rx1589_done:
    rx1589_cur."!cursor_fail"()
    if_null rx1589_debug, debug_1135
    rx1589_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1135:
    .return (rx1589_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("384_1295994649.593") :method
.annotate 'line', 645
    new $P1591, "ResizablePMCArray"
    push $P1591, "{"
    .return ($P1591)
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("385_1295994649.593") :method :outer("374_1295994649.593")
.annotate 'line', 645
    .const 'Sub' $P1599 = "387_1295994649.593" 
    capture_lex $P1599
    .local string rx1594_tgt
    .local int rx1594_pos
    .local int rx1594_off
    .local int rx1594_eos
    .local int rx1594_rep
    .local pmc rx1594_cur
    .local pmc rx1594_debug
    (rx1594_cur, rx1594_pos, rx1594_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1594_cur
    .local pmc match
    .lex "$/", match
    length rx1594_eos, rx1594_tgt
    gt rx1594_pos, rx1594_eos, rx1594_done
    set rx1594_off, 0
    lt rx1594_pos, 2, rx1594_start
    sub rx1594_off, rx1594_pos, 1
    substr rx1594_tgt, rx1594_tgt, rx1594_off
  rx1594_start:
    eq $I10, 1, rx1594_restart
    if_null rx1594_debug, debug_1136
    rx1594_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1597_done
    goto rxscan1597_scan
  rxscan1597_loop:
    ($P10) = rx1594_cur."from"()
    inc $P10
    set rx1594_pos, $P10
    ge rx1594_pos, rx1594_eos, rxscan1597_done
  rxscan1597_scan:
    set_addr $I10, rxscan1597_loop
    rx1594_cur."!mark_push"(0, rx1594_pos, $I10)
  rxscan1597_done:
.annotate 'line', 663
  # rx subcapture "zw"
    set_addr $I10, rxcap_1602_fail
    rx1594_cur."!mark_push"(0, rx1594_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1594_pos, rx1594_eos, rx1594_fail
    sub $I10, rx1594_pos, rx1594_off
    substr $S10, rx1594_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1594_fail
    inc rx1594_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1594_cur."!cursor_pos"(rx1594_pos)
    .const 'Sub' $P1599 = "387_1295994649.593" 
    capture_lex $P1599
    $P10 = rx1594_cur."before"($P1599)
    unless $P10, rx1594_fail
    set_addr $I10, rxcap_1602_fail
    ($I12, $I11) = rx1594_cur."!mark_peek"($I10)
    rx1594_cur."!cursor_pos"($I11)
    ($P10) = rx1594_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1594_pos, "")
    rx1594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1602_done
  rxcap_1602_fail:
    goto rx1594_fail
  rxcap_1602_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1594_cur."!cursor_pos"(rx1594_pos)
    $P10 = rx1594_cur."codeblock"()
    unless $P10, rx1594_fail
    rx1594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1594_pos = $P10."pos"()
.annotate 'line', 662
  # rx pass
    rx1594_cur."!cursor_pass"(rx1594_pos, "assertion:sym<?{ }>")
    if_null rx1594_debug, debug_1141
    rx1594_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1594_pos)
  debug_1141:
    .return (rx1594_cur)
  rx1594_restart:
.annotate 'line', 645
    if_null rx1594_debug, debug_1142
    rx1594_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1142:
  rx1594_fail:
    (rx1594_rep, rx1594_pos, $I10, $P10) = rx1594_cur."!mark_fail"(0)
    lt rx1594_pos, -1, rx1594_done
    eq rx1594_pos, -1, rx1594_fail
    jump $I10
  rx1594_done:
    rx1594_cur."!cursor_fail"()
    if_null rx1594_debug, debug_1143
    rx1594_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1143:
    .return (rx1594_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("386_1295994649.593") :method
.annotate 'line', 645
    new $P1596, "ResizablePMCArray"
    push $P1596, "!"
    push $P1596, "?"
    .return ($P1596)
.end


.namespace ["NQP";"Regex"]
.sub "_block1598"  :anon :subid("387_1295994649.593") :method :outer("385_1295994649.593")
.annotate 'line', 663
    .local string rx1600_tgt
    .local int rx1600_pos
    .local int rx1600_off
    .local int rx1600_eos
    .local int rx1600_rep
    .local pmc rx1600_cur
    .local pmc rx1600_debug
    (rx1600_cur, rx1600_pos, rx1600_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1600_cur
    .local pmc match
    .lex "$/", match
    length rx1600_eos, rx1600_tgt
    gt rx1600_pos, rx1600_eos, rx1600_done
    set rx1600_off, 0
    lt rx1600_pos, 2, rx1600_start
    sub rx1600_off, rx1600_pos, 1
    substr rx1600_tgt, rx1600_tgt, rx1600_off
  rx1600_start:
    eq $I10, 1, rx1600_restart
    if_null rx1600_debug, debug_1137
    rx1600_cur."!cursor_debug"("START", "")
  debug_1137:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1601_done
    goto rxscan1601_scan
  rxscan1601_loop:
    ($P10) = rx1600_cur."from"()
    inc $P10
    set rx1600_pos, $P10
    ge rx1600_pos, rx1600_eos, rxscan1601_done
  rxscan1601_scan:
    set_addr $I10, rxscan1601_loop
    rx1600_cur."!mark_push"(0, rx1600_pos, $I10)
  rxscan1601_done:
  # rx literal  "{"
    add $I11, rx1600_pos, 1
    gt $I11, rx1600_eos, rx1600_fail
    sub $I11, rx1600_pos, rx1600_off
    ord $I11, rx1600_tgt, $I11
    ne $I11, 123, rx1600_fail
    add rx1600_pos, 1
  # rx pass
    rx1600_cur."!cursor_pass"(rx1600_pos, "")
    if_null rx1600_debug, debug_1138
    rx1600_cur."!cursor_debug"("PASS", "", " at pos=", rx1600_pos)
  debug_1138:
    .return (rx1600_cur)
  rx1600_restart:
    if_null rx1600_debug, debug_1139
    rx1600_cur."!cursor_debug"("NEXT", "")
  debug_1139:
  rx1600_fail:
    (rx1600_rep, rx1600_pos, $I10, $P10) = rx1600_cur."!mark_fail"(0)
    lt rx1600_pos, -1, rx1600_done
    eq rx1600_pos, -1, rx1600_fail
    jump $I10
  rx1600_done:
    rx1600_cur."!cursor_fail"()
    if_null rx1600_debug, debug_1140
    rx1600_cur."!cursor_debug"("FAIL", "")
  debug_1140:
    .return (rx1600_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("388_1295994649.593") :method :outer("374_1295994649.593")
.annotate 'line', 645
    .const 'Sub' $P1612 = "390_1295994649.593" 
    capture_lex $P1612
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    rx1604_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1144
    rx1604_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1144:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    ($P10) = rx1604_cur."from"()
    inc $P10
    set rx1604_pos, $P10
    ge rx1604_pos, rx1604_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1608_done:
.annotate 'line', 667
  # rx subrule "identifier" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."identifier"()
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1604_pos = $P10."pos"()
.annotate 'line', 674
  # rx rxquantr1609 ** 0..1
    set_addr $I10, rxquantr1609_done
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxquantr1609_loop:
  alt1610_0:
.annotate 'line', 668
    set_addr $I10, alt1610_1
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
.annotate 'line', 669
  # rx subrule "before" subtype=zerowidth negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    .const 'Sub' $P1612 = "390_1295994649.593" 
    capture_lex $P1612
    $P10 = rx1604_cur."before"($P1612)
    unless $P10, rx1604_fail
    goto alt1610_end
  alt1610_1:
    set_addr $I10, alt1610_2
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
.annotate 'line', 670
  # rx literal  "="
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 61, rx1604_fail
    add rx1604_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."assertion"()
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1604_pos = $P10."pos"()
    goto alt1610_end
  alt1610_2:
    set_addr $I10, alt1610_3
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
.annotate 'line', 671
  # rx literal  ":"
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 58, rx1604_fail
    add rx1604_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."arglist"()
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1604_pos = $P10."pos"()
    goto alt1610_end
  alt1610_3:
    set_addr $I10, alt1610_4
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
.annotate 'line', 672
  # rx literal  "("
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 40, rx1604_fail
    add rx1604_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1604_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 41, rx1604_fail
    add rx1604_pos, 1
    goto alt1610_end
  alt1610_4:
.annotate 'line', 673
  # rx subrule "normspace" subtype=method negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."normspace"()
    unless $P10, rx1604_fail
    rx1604_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."nibbler"()
    unless $P10, rx1604_fail
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1604_pos = $P10."pos"()
  alt1610_end:
.annotate 'line', 674
    set_addr $I10, rxquantr1609_done
    (rx1604_rep) = rx1604_cur."!mark_commit"($I10)
  rxquantr1609_done:
.annotate 'line', 666
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "assertion:sym<name>")
    if_null rx1604_debug, debug_1149
    rx1604_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1604_pos)
  debug_1149:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 645
    if_null rx1604_debug, debug_1150
    rx1604_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1150:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1151
    rx1604_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1151:
    .return (rx1604_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("389_1295994649.593") :method
.annotate 'line', 645
    $P1606 = self."!PREFIX__!subrule"("identifier", "")
    new $P1607, "ResizablePMCArray"
    push $P1607, $P1606
    .return ($P1607)
.end


.namespace ["NQP";"Regex"]
.sub "_block1611"  :anon :subid("390_1295994649.593") :method :outer("388_1295994649.593")
.annotate 'line', 669
    .local string rx1613_tgt
    .local int rx1613_pos
    .local int rx1613_off
    .local int rx1613_eos
    .local int rx1613_rep
    .local pmc rx1613_cur
    .local pmc rx1613_debug
    (rx1613_cur, rx1613_pos, rx1613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1613_cur
    .local pmc match
    .lex "$/", match
    length rx1613_eos, rx1613_tgt
    gt rx1613_pos, rx1613_eos, rx1613_done
    set rx1613_off, 0
    lt rx1613_pos, 2, rx1613_start
    sub rx1613_off, rx1613_pos, 1
    substr rx1613_tgt, rx1613_tgt, rx1613_off
  rx1613_start:
    eq $I10, 1, rx1613_restart
    if_null rx1613_debug, debug_1145
    rx1613_cur."!cursor_debug"("START", "")
  debug_1145:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1614_done
    goto rxscan1614_scan
  rxscan1614_loop:
    ($P10) = rx1613_cur."from"()
    inc $P10
    set rx1613_pos, $P10
    ge rx1613_pos, rx1613_eos, rxscan1614_done
  rxscan1614_scan:
    set_addr $I10, rxscan1614_loop
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  rxscan1614_done:
  # rx literal  ">"
    add $I11, rx1613_pos, 1
    gt $I11, rx1613_eos, rx1613_fail
    sub $I11, rx1613_pos, rx1613_off
    ord $I11, rx1613_tgt, $I11
    ne $I11, 62, rx1613_fail
    add rx1613_pos, 1
  # rx pass
    rx1613_cur."!cursor_pass"(rx1613_pos, "")
    if_null rx1613_debug, debug_1146
    rx1613_cur."!cursor_debug"("PASS", "", " at pos=", rx1613_pos)
  debug_1146:
    .return (rx1613_cur)
  rx1613_restart:
    if_null rx1613_debug, debug_1147
    rx1613_cur."!cursor_debug"("NEXT", "")
  debug_1147:
  rx1613_fail:
    (rx1613_rep, rx1613_pos, $I10, $P10) = rx1613_cur."!mark_fail"(0)
    lt rx1613_pos, -1, rx1613_done
    eq rx1613_pos, -1, rx1613_fail
    jump $I10
  rx1613_done:
    rx1613_cur."!cursor_fail"()
    if_null rx1613_debug, debug_1148
    rx1613_cur."!cursor_debug"("FAIL", "")
  debug_1148:
    .return (rx1613_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("391_1295994649.593") :method :outer("374_1295994649.593")
.annotate 'line', 645
    .local string rx1616_tgt
    .local int rx1616_pos
    .local int rx1616_off
    .local int rx1616_eos
    .local int rx1616_rep
    .local pmc rx1616_cur
    .local pmc rx1616_debug
    (rx1616_cur, rx1616_pos, rx1616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1616_cur
    .local pmc match
    .lex "$/", match
    length rx1616_eos, rx1616_tgt
    gt rx1616_pos, rx1616_eos, rx1616_done
    set rx1616_off, 0
    lt rx1616_pos, 2, rx1616_start
    sub rx1616_off, rx1616_pos, 1
    substr rx1616_tgt, rx1616_tgt, rx1616_off
  rx1616_start:
    eq $I10, 1, rx1616_restart
    if_null rx1616_debug, debug_1152
    rx1616_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1619_done
    goto rxscan1619_scan
  rxscan1619_loop:
    ($P10) = rx1616_cur."from"()
    inc $P10
    set rx1616_pos, $P10
    ge rx1616_pos, rx1616_eos, rxscan1619_done
  rxscan1619_scan:
    set_addr $I10, rxscan1619_loop
    rx1616_cur."!mark_push"(0, rx1616_pos, $I10)
  rxscan1619_done:
.annotate 'line', 678
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1616_pos, rx1616_off
    substr $S10, rx1616_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1616_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1616_cur."!cursor_pos"(rx1616_pos)
    $P10 = rx1616_cur."LANG"("MAIN", "variable")
    unless $P10, rx1616_fail
    rx1616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1616_pos = $P10."pos"()
.annotate 'line', 677
  # rx pass
    rx1616_cur."!cursor_pass"(rx1616_pos, "assertion:sym<var>")
    if_null rx1616_debug, debug_1153
    rx1616_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1616_pos)
  debug_1153:
    .return (rx1616_cur)
  rx1616_restart:
.annotate 'line', 645
    if_null rx1616_debug, debug_1154
    rx1616_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1154:
  rx1616_fail:
    (rx1616_rep, rx1616_pos, $I10, $P10) = rx1616_cur."!mark_fail"(0)
    lt rx1616_pos, -1, rx1616_done
    eq rx1616_pos, -1, rx1616_fail
    jump $I10
  rx1616_done:
    rx1616_cur."!cursor_fail"()
    if_null rx1616_debug, debug_1155
    rx1616_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1155:
    .return (rx1616_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("392_1295994649.593") :method
.annotate 'line', 645
    new $P1618, "ResizablePMCArray"
    push $P1618, "$"
    push $P1618, "@"
    .return ($P1618)
.end


.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("393_1295994649.593") :method :outer("374_1295994649.593")
.annotate 'line', 645
    .local string rx1621_tgt
    .local int rx1621_pos
    .local int rx1621_off
    .local int rx1621_eos
    .local int rx1621_rep
    .local pmc rx1621_cur
    .local pmc rx1621_debug
    (rx1621_cur, rx1621_pos, rx1621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1621_cur
    .local pmc match
    .lex "$/", match
    length rx1621_eos, rx1621_tgt
    gt rx1621_pos, rx1621_eos, rx1621_done
    set rx1621_off, 0
    lt rx1621_pos, 2, rx1621_start
    sub rx1621_off, rx1621_pos, 1
    substr rx1621_tgt, rx1621_tgt, rx1621_off
  rx1621_start:
    eq $I10, 1, rx1621_restart
    if_null rx1621_debug, debug_1156
    rx1621_cur."!cursor_debug"("START", "codeblock")
  debug_1156:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1625_done
    goto rxscan1625_scan
  rxscan1625_loop:
    ($P10) = rx1621_cur."from"()
    inc $P10
    set rx1621_pos, $P10
    ge rx1621_pos, rx1621_eos, rxscan1625_done
  rxscan1625_scan:
    set_addr $I10, rxscan1625_loop
    rx1621_cur."!mark_push"(0, rx1621_pos, $I10)
  rxscan1625_done:
.annotate 'line', 682
  # rx subrule "LANG" subtype=capture negate=
    rx1621_cur."!cursor_pos"(rx1621_pos)
    $P10 = rx1621_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1621_fail
    rx1621_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1621_pos = $P10."pos"()
.annotate 'line', 681
  # rx pass
    rx1621_cur."!cursor_pass"(rx1621_pos, "codeblock")
    if_null rx1621_debug, debug_1157
    rx1621_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1621_pos)
  debug_1157:
    .return (rx1621_cur)
  rx1621_restart:
.annotate 'line', 645
    if_null rx1621_debug, debug_1158
    rx1621_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1158:
  rx1621_fail:
    (rx1621_rep, rx1621_pos, $I10, $P10) = rx1621_cur."!mark_fail"(0)
    lt rx1621_pos, -1, rx1621_done
    eq rx1621_pos, -1, rx1621_fail
    jump $I10
  rx1621_done:
    rx1621_cur."!cursor_fail"()
    if_null rx1621_debug, debug_1159
    rx1621_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1159:
    .return (rx1621_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("394_1295994649.593") :method
.annotate 'line', 645
    $P1623 = self."!PREFIX__!subrule"("LANG", "")
    new $P1624, "ResizablePMCArray"
    push $P1624, $P1623
    .return ($P1624)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1667" :load :anon :subid("396_1295994649.593")
.annotate 'line', 4
    .const 'Sub' $P1669 = "11_1295994649.593" 
    $P1670 = $P1669()
    .return ($P1670)
.end


.namespace []
.sub "_block2380" :load :anon :subid("398_1295994649.593")
.annotate 'line', 1
    .const 'Sub' $P2382 = "10_1295994649.593" 
    $P2383 = $P2382()
    .return ($P2383)
.end

### .include 'gen/nqp-actions.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1295994666.515")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
    $P3133 = $P15()
.annotate 'line', 1
    .return ($P3133)
    .const 'Sub' $P3135 = "166_1295994666.515" 
    .return ($P3135)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block14"  :subid("11_1295994666.515") :outer("10_1295994666.515")
.annotate 'line', 3
    .const 'Sub' $P2916 = "165_1295994666.515" 
    capture_lex $P2916
    get_hll_global $P2790, ["NQP";"RegexActions"], "_block2789" 
    capture_lex $P2790
    .const 'Sub' $P2781 = "154_1295994666.515" 
    capture_lex $P2781
    .const 'Sub' $P2776 = "153_1295994666.515" 
    capture_lex $P2776
    .const 'Sub' $P2771 = "152_1295994666.515" 
    capture_lex $P2771
    .const 'Sub' $P2766 = "151_1295994666.515" 
    capture_lex $P2766
    .const 'Sub' $P2755 = "150_1295994666.515" 
    capture_lex $P2755
    .const 'Sub' $P2747 = "149_1295994666.515" 
    capture_lex $P2747
    .const 'Sub' $P2739 = "148_1295994666.515" 
    capture_lex $P2739
    .const 'Sub' $P2731 = "147_1295994666.515" 
    capture_lex $P2731
    .const 'Sub' $P2726 = "146_1295994666.515" 
    capture_lex $P2726
    .const 'Sub' $P2714 = "145_1295994666.515" 
    capture_lex $P2714
    .const 'Sub' $P2706 = "144_1295994666.515" 
    capture_lex $P2706
    .const 'Sub' $P2668 = "143_1295994666.515" 
    capture_lex $P2668
    .const 'Sub' $P2656 = "142_1295994666.515" 
    capture_lex $P2656
    .const 'Sub' $P2648 = "141_1295994666.515" 
    capture_lex $P2648
    .const 'Sub' $P2640 = "140_1295994666.515" 
    capture_lex $P2640
    .const 'Sub' $P2632 = "139_1295994666.515" 
    capture_lex $P2632
    .const 'Sub' $P2624 = "138_1295994666.515" 
    capture_lex $P2624
    .const 'Sub' $P2616 = "137_1295994666.515" 
    capture_lex $P2616
    .const 'Sub' $P2590 = "136_1295994666.515" 
    capture_lex $P2590
    .const 'Sub' $P2575 = "135_1295994666.515" 
    capture_lex $P2575
    .const 'Sub' $P2567 = "134_1295994666.515" 
    capture_lex $P2567
    .const 'Sub' $P2556 = "133_1295994666.515" 
    capture_lex $P2556
    .const 'Sub' $P2545 = "132_1295994666.515" 
    capture_lex $P2545
    .const 'Sub' $P2534 = "131_1295994666.515" 
    capture_lex $P2534
    .const 'Sub' $P2526 = "130_1295994666.515" 
    capture_lex $P2526
    .const 'Sub' $P2499 = "129_1295994666.515" 
    capture_lex $P2499
    .const 'Sub' $P2477 = "128_1295994666.515" 
    capture_lex $P2477
    .const 'Sub' $P2469 = "127_1295994666.515" 
    capture_lex $P2469
    .const 'Sub' $P2461 = "126_1295994666.515" 
    capture_lex $P2461
    .const 'Sub' $P2436 = "125_1295994666.515" 
    capture_lex $P2436
    .const 'Sub' $P2420 = "124_1295994666.515" 
    capture_lex $P2420
    .const 'Sub' $P2412 = "123_1295994666.515" 
    capture_lex $P2412
    .const 'Sub' $P2404 = "122_1295994666.515" 
    capture_lex $P2404
    .const 'Sub' $P2302 = "119_1295994666.515" 
    capture_lex $P2302
    .const 'Sub' $P2294 = "118_1295994666.515" 
    capture_lex $P2294
    .const 'Sub' $P2287 = "117_1295994666.515" 
    capture_lex $P2287
    .const 'Sub' $P2260 = "116_1295994666.515" 
    capture_lex $P2260
    .const 'Sub' $P2220 = "115_1295994666.515" 
    capture_lex $P2220
    .const 'Sub' $P2206 = "114_1295994666.515" 
    capture_lex $P2206
    .const 'Sub' $P2199 = "113_1295994666.515" 
    capture_lex $P2199
    .const 'Sub' $P2155 = "112_1295994666.515" 
    capture_lex $P2155
    .const 'Sub' $P1990 = "108_1295994666.515" 
    capture_lex $P1990
    .const 'Sub' $P1950 = "106_1295994666.515" 
    capture_lex $P1950
    .const 'Sub' $P1942 = "105_1295994666.515" 
    capture_lex $P1942
    .const 'Sub' $P1927 = "104_1295994666.515" 
    capture_lex $P1927
    .const 'Sub' $P1912 = "103_1295994666.515" 
    capture_lex $P1912
    .const 'Sub' $P1894 = "102_1295994666.515" 
    capture_lex $P1894
    .const 'Sub' $P1795 = "101_1295994666.515" 
    capture_lex $P1795
    .const 'Sub' $P1751 = "98_1295994666.515" 
    capture_lex $P1751
    .const 'Sub' $P1626 = "95_1295994666.515" 
    capture_lex $P1626
    .const 'Sub' $P1384 = "88_1295994666.515" 
    capture_lex $P1384
    .const 'Sub' $P1376 = "87_1295994666.515" 
    capture_lex $P1376
    .const 'Sub' $P1368 = "86_1295994666.515" 
    capture_lex $P1368
    .const 'Sub' $P1270 = "83_1295994666.515" 
    capture_lex $P1270
    .const 'Sub' $P1262 = "82_1295994666.515" 
    capture_lex $P1262
    .const 'Sub' $P1247 = "81_1295994666.515" 
    capture_lex $P1247
    .const 'Sub' $P1232 = "80_1295994666.515" 
    capture_lex $P1232
    .const 'Sub' $P1217 = "79_1295994666.515" 
    capture_lex $P1217
    .const 'Sub' $P1202 = "78_1295994666.515" 
    capture_lex $P1202
    .const 'Sub' $P1194 = "77_1295994666.515" 
    capture_lex $P1194
    .const 'Sub' $P1186 = "76_1295994666.515" 
    capture_lex $P1186
    .const 'Sub' $P1178 = "75_1295994666.515" 
    capture_lex $P1178
    .const 'Sub' $P1156 = "74_1295994666.515" 
    capture_lex $P1156
    .const 'Sub' $P1148 = "73_1295994666.515" 
    capture_lex $P1148
    .const 'Sub' $P1141 = "72_1295994666.515" 
    capture_lex $P1141
    .const 'Sub' $P1134 = "71_1295994666.515" 
    capture_lex $P1134
    .const 'Sub' $P1127 = "70_1295994666.515" 
    capture_lex $P1127
    .const 'Sub' $P1119 = "69_1295994666.515" 
    capture_lex $P1119
    .const 'Sub' $P1026 = "67_1295994666.515" 
    capture_lex $P1026
    .const 'Sub' $P1002 = "66_1295994666.515" 
    capture_lex $P1002
    .const 'Sub' $P988 = "65_1295994666.515" 
    capture_lex $P988
    .const 'Sub' $P980 = "64_1295994666.515" 
    capture_lex $P980
    .const 'Sub' $P972 = "63_1295994666.515" 
    capture_lex $P972
    .const 'Sub' $P964 = "62_1295994666.515" 
    capture_lex $P964
    .const 'Sub' $P956 = "61_1295994666.515" 
    capture_lex $P956
    .const 'Sub' $P948 = "60_1295994666.515" 
    capture_lex $P948
    .const 'Sub' $P940 = "59_1295994666.515" 
    capture_lex $P940
    .const 'Sub' $P932 = "58_1295994666.515" 
    capture_lex $P932
    .const 'Sub' $P924 = "57_1295994666.515" 
    capture_lex $P924
    .const 'Sub' $P916 = "56_1295994666.515" 
    capture_lex $P916
    .const 'Sub' $P908 = "55_1295994666.515" 
    capture_lex $P908
    .const 'Sub' $P900 = "54_1295994666.515" 
    capture_lex $P900
    .const 'Sub' $P892 = "53_1295994666.515" 
    capture_lex $P892
    .const 'Sub' $P884 = "52_1295994666.515" 
    capture_lex $P884
    .const 'Sub' $P868 = "51_1295994666.515" 
    capture_lex $P868
    .const 'Sub' $P835 = "50_1295994666.515" 
    capture_lex $P835
    .const 'Sub' $P821 = "49_1295994666.515" 
    capture_lex $P821
    .const 'Sub' $P802 = "48_1295994666.515" 
    capture_lex $P802
    .const 'Sub' $P784 = "47_1295994666.515" 
    capture_lex $P784
    .const 'Sub' $P760 = "46_1295994666.515" 
    capture_lex $P760
    .const 'Sub' $P726 = "45_1295994666.515" 
    capture_lex $P726
    .const 'Sub' $P711 = "44_1295994666.515" 
    capture_lex $P711
    .const 'Sub' $P699 = "43_1295994666.515" 
    capture_lex $P699
    .const 'Sub' $P648 = "41_1295994666.515" 
    capture_lex $P648
    .const 'Sub' $P639 = "40_1295994666.515" 
    capture_lex $P639
    .const 'Sub' $P628 = "39_1295994666.515" 
    capture_lex $P628
    .const 'Sub' $P610 = "38_1295994666.515" 
    capture_lex $P610
    .const 'Sub' $P602 = "37_1295994666.515" 
    capture_lex $P602
    .const 'Sub' $P594 = "36_1295994666.515" 
    capture_lex $P594
    .const 'Sub' $P580 = "35_1295994666.515" 
    capture_lex $P580
    .const 'Sub' $P499 = "33_1295994666.515" 
    capture_lex $P499
    .const 'Sub' $P458 = "31_1295994666.515" 
    capture_lex $P458
    .const 'Sub' $P424 = "30_1295994666.515" 
    capture_lex $P424
    .const 'Sub' $P393 = "29_1295994666.515" 
    capture_lex $P393
    .const 'Sub' $P385 = "28_1295994666.515" 
    capture_lex $P385
    .const 'Sub' $P377 = "26_1295994666.515" 
    capture_lex $P377
    .const 'Sub' $P363 = "25_1295994666.515" 
    capture_lex $P363
    .const 'Sub' $P298 = "23_1295994666.515" 
    capture_lex $P298
    .const 'Sub' $P288 = "22_1295994666.515" 
    capture_lex $P288
    .const 'Sub' $P139 = "19_1295994666.515" 
    capture_lex $P139
    .const 'Sub' $P91 = "18_1295994666.515" 
    capture_lex $P91
    .const 'Sub' $P78 = "17_1295994666.515" 
    capture_lex $P78
    .const 'Sub' $P60 = "16_1295994666.515" 
    capture_lex $P60
    .const 'Sub' $P27 = "13_1295994666.515" 
    capture_lex $P27
    .const 'Sub' $P19 = "12_1295994666.515" 
    capture_lex $P19
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "RegexActions"
    get_global $P18, "@BLOCK"
    unless_null $P18, vivify_168
    $P18 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P18
  vivify_168:
.annotate 'line', 9
    .const 'Sub' $P19 = "12_1295994666.515" 
    newclosure $P26, $P19
    .lex "xblock_immediate", $P26
.annotate 'line', 14
    .const 'Sub' $P27 = "13_1295994666.515" 
    newclosure $P59, $P27
    .lex "block_immediate", $P59
.annotate 'line', 24
    .const 'Sub' $P60 = "16_1295994666.515" 
    newclosure $P77, $P60
    .lex "vivitype", $P77
.annotate 'line', 43
    .const 'Sub' $P78 = "17_1295994666.515" 
    newclosure $P90, $P78
    .lex "colonpair_str", $P90
.annotate 'line', 223
    .const 'Sub' $P91 = "18_1295994666.515" 
    newclosure $P138, $P91
    .lex "push_block_handler", $P138
.annotate 'line', 378
    .const 'Sub' $P139 = "19_1295994666.515" 
    newclosure $P287, $P139
    .lex "package", $P287
.annotate 'line', 740
    .const 'Sub' $P288 = "22_1295994666.515" 
    newclosure $P297, $P288
    .lex "only_star_block", $P297
.annotate 'line', 749
    .const 'Sub' $P298 = "23_1295994666.515" 
    newclosure $P362, $P298
    .lex "attach_multi_signature", $P362
.annotate 'line', 1201
    .const 'Sub' $P363 = "25_1295994666.515" 
    newclosure $P374, $P363
    .lex "control", $P374
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P375, "@BLOCK"
    .const 'Sub' $P377 = "26_1295994666.515" 
    capture_lex $P377
    $P377()
    find_lex $P382, "xblock_immediate"
    find_lex $P383, "block_immediate"
    find_lex $P384, "vivitype"
.annotate 'line', 35
    find_lex $P423, "colonpair_str"
.annotate 'line', 216
    find_lex $P820, "push_block_handler"
.annotate 'line', 376
    find_lex $P1155, "package"
.annotate 'line', 667
    find_lex $P1749, "only_star_block"
    find_lex $P1750, "attach_multi_signature"
.annotate 'line', 1192
    find_lex $P2765, "control"
.annotate 'line', 1219
    get_hll_global $P2790, ["NQP";"RegexActions"], "_block2789" 
    capture_lex $P2790
    $P2910 = $P2790()
.annotate 'line', 3
    .return ($P2910)
    .const 'Sub' $P2912 = "164_1295994666.515" 
    .return ($P2912)
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post167") :outer("11_1295994666.515")
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P2916 = "165_1295994666.515" 
    capture_lex $P2916
    $P2916()
.end


.namespace ["NQP";"Actions"]
.sub "_block2915"  :anon :subid("165_1295994666.515") :outer("11_1295994666.515")
.annotate 'line', 3
    get_hll_global $P2917, "NQPClassHOW"
    $P2918 = $P2917."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2918
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2919, type_obj
    .const 'Sub' $P2920 = "28_1295994666.515" 
    $P2919."add_method"(type_obj, "TOP", $P2920)
    get_how $P2921, type_obj
    .const 'Sub' $P2922 = "29_1295994666.515" 
    $P2921."add_method"(type_obj, "deflongname", $P2922)
    get_how $P2923, type_obj
    .const 'Sub' $P2924 = "30_1295994666.515" 
    $P2923."add_method"(type_obj, "comp_unit", $P2924)
    get_how $P2925, type_obj
    .const 'Sub' $P2926 = "31_1295994666.515" 
    $P2925."add_method"(type_obj, "statementlist", $P2926)
    get_how $P2927, type_obj
    .const 'Sub' $P2928 = "33_1295994666.515" 
    $P2927."add_method"(type_obj, "statement", $P2928)
    get_how $P2929, type_obj
    .const 'Sub' $P2930 = "35_1295994666.515" 
    $P2929."add_method"(type_obj, "xblock", $P2930)
    get_how $P2931, type_obj
    .const 'Sub' $P2932 = "36_1295994666.515" 
    $P2931."add_method"(type_obj, "pblock", $P2932)
    get_how $P2933, type_obj
    .const 'Sub' $P2934 = "37_1295994666.515" 
    $P2933."add_method"(type_obj, "block", $P2934)
    get_how $P2935, type_obj
    .const 'Sub' $P2936 = "38_1295994666.515" 
    $P2935."add_method"(type_obj, "blockoid", $P2936)
    get_how $P2937, type_obj
    .const 'Sub' $P2938 = "39_1295994666.515" 
    $P2937."add_method"(type_obj, "newpad", $P2938)
    get_how $P2939, type_obj
    .const 'Sub' $P2940 = "40_1295994666.515" 
    $P2939."add_method"(type_obj, "outerctx", $P2940)
    get_how $P2941, type_obj
    .const 'Sub' $P2942 = "41_1295994666.515" 
    $P2941."add_method"(type_obj, "statement_control:sym<if>", $P2942)
    get_how $P2943, type_obj
    .const 'Sub' $P2944 = "43_1295994666.515" 
    $P2943."add_method"(type_obj, "statement_control:sym<unless>", $P2944)
    get_how $P2945, type_obj
    .const 'Sub' $P2946 = "44_1295994666.515" 
    $P2945."add_method"(type_obj, "statement_control:sym<while>", $P2946)
    get_how $P2947, type_obj
    .const 'Sub' $P2948 = "45_1295994666.515" 
    $P2947."add_method"(type_obj, "statement_control:sym<repeat>", $P2948)
    get_how $P2949, type_obj
    .const 'Sub' $P2950 = "46_1295994666.515" 
    $P2949."add_method"(type_obj, "statement_control:sym<for>", $P2950)
    get_how $P2951, type_obj
    .const 'Sub' $P2952 = "47_1295994666.515" 
    $P2951."add_method"(type_obj, "statement_control:sym<CATCH>", $P2952)
    get_how $P2953, type_obj
    .const 'Sub' $P2954 = "48_1295994666.515" 
    $P2953."add_method"(type_obj, "statement_control:sym<CONTROL>", $P2954)
    get_how $P2955, type_obj
    .const 'Sub' $P2956 = "49_1295994666.515" 
    $P2955."add_method"(type_obj, "statement_prefix:sym<INIT>", $P2956)
    get_how $P2957, type_obj
    .const 'Sub' $P2958 = "50_1295994666.515" 
    $P2957."add_method"(type_obj, "statement_prefix:sym<try>", $P2958)
    get_how $P2959, type_obj
    .const 'Sub' $P2960 = "51_1295994666.515" 
    $P2959."add_method"(type_obj, "blorst", $P2960)
    get_how $P2961, type_obj
    .const 'Sub' $P2962 = "52_1295994666.515" 
    $P2961."add_method"(type_obj, "statement_mod_cond:sym<if>", $P2962)
    get_how $P2963, type_obj
    .const 'Sub' $P2964 = "53_1295994666.515" 
    $P2963."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P2964)
    get_how $P2965, type_obj
    .const 'Sub' $P2966 = "54_1295994666.515" 
    $P2965."add_method"(type_obj, "statement_mod_loop:sym<while>", $P2966)
    get_how $P2967, type_obj
    .const 'Sub' $P2968 = "55_1295994666.515" 
    $P2967."add_method"(type_obj, "statement_mod_loop:sym<until>", $P2968)
    get_how $P2969, type_obj
    .const 'Sub' $P2970 = "56_1295994666.515" 
    $P2969."add_method"(type_obj, "term:sym<fatarrow>", $P2970)
    get_how $P2971, type_obj
    .const 'Sub' $P2972 = "57_1295994666.515" 
    $P2971."add_method"(type_obj, "term:sym<colonpair>", $P2972)
    get_how $P2973, type_obj
    .const 'Sub' $P2974 = "58_1295994666.515" 
    $P2973."add_method"(type_obj, "term:sym<variable>", $P2974)
    get_how $P2975, type_obj
    .const 'Sub' $P2976 = "59_1295994666.515" 
    $P2975."add_method"(type_obj, "term:sym<package_declarator>", $P2976)
    get_how $P2977, type_obj
    .const 'Sub' $P2978 = "60_1295994666.515" 
    $P2977."add_method"(type_obj, "term:sym<scope_declarator>", $P2978)
    get_how $P2979, type_obj
    .const 'Sub' $P2980 = "61_1295994666.515" 
    $P2979."add_method"(type_obj, "term:sym<routine_declarator>", $P2980)
    get_how $P2981, type_obj
    .const 'Sub' $P2982 = "62_1295994666.515" 
    $P2981."add_method"(type_obj, "term:sym<regex_declarator>", $P2982)
    get_how $P2983, type_obj
    .const 'Sub' $P2984 = "63_1295994666.515" 
    $P2983."add_method"(type_obj, "term:sym<statement_prefix>", $P2984)
    get_how $P2985, type_obj
    .const 'Sub' $P2986 = "64_1295994666.515" 
    $P2985."add_method"(type_obj, "term:sym<lambda>", $P2986)
    get_how $P2987, type_obj
    .const 'Sub' $P2988 = "65_1295994666.515" 
    $P2987."add_method"(type_obj, "fatarrow", $P2988)
    get_how $P2989, type_obj
    .const 'Sub' $P2990 = "66_1295994666.515" 
    $P2989."add_method"(type_obj, "colonpair", $P2990)
    get_how $P2991, type_obj
    .const 'Sub' $P2992 = "67_1295994666.515" 
    $P2991."add_method"(type_obj, "variable", $P2992)
    get_how $P2993, type_obj
    .const 'Sub' $P2994 = "69_1295994666.515" 
    $P2993."add_method"(type_obj, "package_declarator:sym<module>", $P2994)
    get_how $P2995, type_obj
    .const 'Sub' $P2996 = "70_1295994666.515" 
    $P2995."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2996)
    get_how $P2997, type_obj
    .const 'Sub' $P2998 = "71_1295994666.515" 
    $P2997."add_method"(type_obj, "package_declarator:sym<class>", $P2998)
    get_how $P2999, type_obj
    .const 'Sub' $P3000 = "72_1295994666.515" 
    $P2999."add_method"(type_obj, "package_declarator:sym<grammar>", $P3000)
    get_how $P3001, type_obj
    .const 'Sub' $P3002 = "73_1295994666.515" 
    $P3001."add_method"(type_obj, "package_declarator:sym<role>", $P3002)
    get_how $P3003, type_obj
    .const 'Sub' $P3004 = "74_1295994666.515" 
    $P3003."add_method"(type_obj, "package_def", $P3004)
    get_how $P3005, type_obj
    .const 'Sub' $P3006 = "75_1295994666.515" 
    $P3005."add_method"(type_obj, "scope_declarator:sym<my>", $P3006)
    get_how $P3007, type_obj
    .const 'Sub' $P3008 = "76_1295994666.515" 
    $P3007."add_method"(type_obj, "scope_declarator:sym<our>", $P3008)
    get_how $P3009, type_obj
    .const 'Sub' $P3010 = "77_1295994666.515" 
    $P3009."add_method"(type_obj, "scope_declarator:sym<has>", $P3010)
    get_how $P3011, type_obj
    .const 'Sub' $P3012 = "78_1295994666.515" 
    $P3011."add_method"(type_obj, "scoped", $P3012)
    get_how $P3013, type_obj
    .const 'Sub' $P3014 = "79_1295994666.515" 
    $P3013."add_method"(type_obj, "declarator", $P3014)
    get_how $P3015, type_obj
    .const 'Sub' $P3016 = "80_1295994666.515" 
    $P3015."add_method"(type_obj, "multi_declarator:sym<multi>", $P3016)
    get_how $P3017, type_obj
    .const 'Sub' $P3018 = "81_1295994666.515" 
    $P3017."add_method"(type_obj, "multi_declarator:sym<proto>", $P3018)
    get_how $P3019, type_obj
    .const 'Sub' $P3020 = "82_1295994666.515" 
    $P3019."add_method"(type_obj, "multi_declarator:sym<null>", $P3020)
    get_how $P3021, type_obj
    .const 'Sub' $P3022 = "83_1295994666.515" 
    $P3021."add_method"(type_obj, "variable_declarator", $P3022)
    get_how $P3023, type_obj
    .const 'Sub' $P3024 = "86_1295994666.515" 
    $P3023."add_method"(type_obj, "routine_declarator:sym<sub>", $P3024)
    get_how $P3025, type_obj
    .const 'Sub' $P3026 = "87_1295994666.515" 
    $P3025."add_method"(type_obj, "routine_declarator:sym<method>", $P3026)
    get_how $P3027, type_obj
    .const 'Sub' $P3028 = "88_1295994666.515" 
    $P3027."add_method"(type_obj, "routine_def", $P3028)
    get_how $P3029, type_obj
    .const 'Sub' $P3030 = "95_1295994666.515" 
    $P3029."add_method"(type_obj, "method_def", $P3030)
    get_how $P3031, type_obj
    .const 'Sub' $P3032 = "98_1295994666.515" 
    $P3031."add_method"(type_obj, "signature", $P3032)
    get_how $P3033, type_obj
    .const 'Sub' $P3034 = "101_1295994666.515" 
    $P3033."add_method"(type_obj, "parameter", $P3034)
    get_how $P3035, type_obj
    .const 'Sub' $P3036 = "102_1295994666.515" 
    $P3035."add_method"(type_obj, "param_var", $P3036)
    get_how $P3037, type_obj
    .const 'Sub' $P3038 = "103_1295994666.515" 
    $P3037."add_method"(type_obj, "named_param", $P3038)
    get_how $P3039, type_obj
    .const 'Sub' $P3040 = "104_1295994666.515" 
    $P3039."add_method"(type_obj, "typename", $P3040)
    get_how $P3041, type_obj
    .const 'Sub' $P3042 = "105_1295994666.515" 
    $P3041."add_method"(type_obj, "trait", $P3042)
    get_how $P3043, type_obj
    .const 'Sub' $P3044 = "106_1295994666.515" 
    $P3043."add_method"(type_obj, "trait_mod:sym<is>", $P3044)
    get_how $P3045, type_obj
    .const 'Sub' $P3046 = "108_1295994666.515" 
    $P3045."add_method"(type_obj, "regex_declarator", $P3046)
    get_how $P3047, type_obj
    .const 'Sub' $P3048 = "112_1295994666.515" 
    $P3047."add_method"(type_obj, "dotty", $P3048)
    get_how $P3049, type_obj
    .const 'Sub' $P3050 = "113_1295994666.515" 
    $P3049."add_method"(type_obj, "term:sym<self>", $P3050)
    get_how $P3051, type_obj
    .const 'Sub' $P3052 = "114_1295994666.515" 
    $P3051."add_method"(type_obj, "term:sym<identifier>", $P3052)
    get_how $P3053, type_obj
    .const 'Sub' $P3054 = "115_1295994666.515" 
    $P3053."add_method"(type_obj, "term:sym<name>", $P3054)
    get_how $P3055, type_obj
    .const 'Sub' $P3056 = "116_1295994666.515" 
    $P3055."add_method"(type_obj, "term:sym<pir::op>", $P3056)
    get_how $P3057, type_obj
    .const 'Sub' $P3058 = "117_1295994666.515" 
    $P3057."add_method"(type_obj, "term:sym<onlystar>", $P3058)
    get_how $P3059, type_obj
    .const 'Sub' $P3060 = "118_1295994666.515" 
    $P3059."add_method"(type_obj, "args", $P3060)
    get_how $P3061, type_obj
    .const 'Sub' $P3062 = "119_1295994666.515" 
    $P3061."add_method"(type_obj, "arglist", $P3062)
    get_how $P3063, type_obj
    .const 'Sub' $P3064 = "122_1295994666.515" 
    $P3063."add_method"(type_obj, "term:sym<multi_declarator>", $P3064)
    get_how $P3065, type_obj
    .const 'Sub' $P3066 = "123_1295994666.515" 
    $P3065."add_method"(type_obj, "term:sym<value>", $P3066)
    get_how $P3067, type_obj
    .const 'Sub' $P3068 = "124_1295994666.515" 
    $P3067."add_method"(type_obj, "circumfix:sym<( )>", $P3068)
    get_how $P3069, type_obj
    .const 'Sub' $P3070 = "125_1295994666.515" 
    $P3069."add_method"(type_obj, "circumfix:sym<[ ]>", $P3070)
    get_how $P3071, type_obj
    .const 'Sub' $P3072 = "126_1295994666.515" 
    $P3071."add_method"(type_obj, "circumfix:sym<ang>", $P3072)
    get_how $P3073, type_obj
    .const 'Sub' $P3074 = "127_1295994666.515" 
    $P3073."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3074)
    get_how $P3075, type_obj
    .const 'Sub' $P3076 = "128_1295994666.515" 
    $P3075."add_method"(type_obj, "circumfix:sym<{ }>", $P3076)
    get_how $P3077, type_obj
    .const 'Sub' $P3078 = "129_1295994666.515" 
    $P3077."add_method"(type_obj, "circumfix:sym<sigil>", $P3078)
    get_how $P3079, type_obj
    .const 'Sub' $P3080 = "130_1295994666.515" 
    $P3079."add_method"(type_obj, "semilist", $P3080)
    get_how $P3081, type_obj
    .const 'Sub' $P3082 = "131_1295994666.515" 
    $P3081."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3082)
    get_how $P3083, type_obj
    .const 'Sub' $P3084 = "132_1295994666.515" 
    $P3083."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3084)
    get_how $P3085, type_obj
    .const 'Sub' $P3086 = "133_1295994666.515" 
    $P3085."add_method"(type_obj, "postcircumfix:sym<ang>", $P3086)
    get_how $P3087, type_obj
    .const 'Sub' $P3088 = "134_1295994666.515" 
    $P3087."add_method"(type_obj, "postcircumfix:sym<( )>", $P3088)
    get_how $P3089, type_obj
    .const 'Sub' $P3090 = "135_1295994666.515" 
    $P3089."add_method"(type_obj, "value", $P3090)
    get_how $P3091, type_obj
    .const 'Sub' $P3092 = "136_1295994666.515" 
    $P3091."add_method"(type_obj, "number", $P3092)
    get_how $P3093, type_obj
    .const 'Sub' $P3094 = "137_1295994666.515" 
    $P3093."add_method"(type_obj, "quote:sym<apos>", $P3094)
    get_how $P3095, type_obj
    .const 'Sub' $P3096 = "138_1295994666.515" 
    $P3095."add_method"(type_obj, "quote:sym<dblq>", $P3096)
    get_how $P3097, type_obj
    .const 'Sub' $P3098 = "139_1295994666.515" 
    $P3097."add_method"(type_obj, "quote:sym<qq>", $P3098)
    get_how $P3099, type_obj
    .const 'Sub' $P3100 = "140_1295994666.515" 
    $P3099."add_method"(type_obj, "quote:sym<q>", $P3100)
    get_how $P3101, type_obj
    .const 'Sub' $P3102 = "141_1295994666.515" 
    $P3101."add_method"(type_obj, "quote:sym<Q>", $P3102)
    get_how $P3103, type_obj
    .const 'Sub' $P3104 = "142_1295994666.515" 
    $P3103."add_method"(type_obj, "quote:sym<Q:PIR>", $P3104)
    get_how $P3105, type_obj
    .const 'Sub' $P3106 = "143_1295994666.515" 
    $P3105."add_method"(type_obj, "quote:sym</ />", $P3106)
    get_how $P3107, type_obj
    .const 'Sub' $P3108 = "144_1295994666.515" 
    $P3107."add_method"(type_obj, "quote_escape:sym<$>", $P3108)
    get_how $P3109, type_obj
    .const 'Sub' $P3110 = "145_1295994666.515" 
    $P3109."add_method"(type_obj, "quote_escape:sym<{ }>", $P3110)
    get_how $P3111, type_obj
    .const 'Sub' $P3112 = "146_1295994666.515" 
    $P3111."add_method"(type_obj, "quote_escape:sym<esc>", $P3112)
    get_how $P3113, type_obj
    .const 'Sub' $P3114 = "147_1295994666.515" 
    $P3113."add_method"(type_obj, "postfix:sym<.>", $P3114)
    get_how $P3115, type_obj
    .const 'Sub' $P3116 = "148_1295994666.515" 
    $P3115."add_method"(type_obj, "postfix:sym<++>", $P3116)
    get_how $P3117, type_obj
    .const 'Sub' $P3118 = "149_1295994666.515" 
    $P3117."add_method"(type_obj, "postfix:sym<-->", $P3118)
    get_how $P3119, type_obj
    .const 'Sub' $P3120 = "150_1295994666.515" 
    $P3119."add_method"(type_obj, "prefix:sym<make>", $P3120)
    get_how $P3121, type_obj
    .const 'Sub' $P3122 = "151_1295994666.515" 
    $P3121."add_method"(type_obj, "term:sym<next>", $P3122)
    get_how $P3123, type_obj
    .const 'Sub' $P3124 = "152_1295994666.515" 
    $P3123."add_method"(type_obj, "term:sym<last>", $P3124)
    get_how $P3125, type_obj
    .const 'Sub' $P3126 = "153_1295994666.515" 
    $P3125."add_method"(type_obj, "term:sym<redo>", $P3126)
    get_how $P3127, type_obj
    .const 'Sub' $P3128 = "154_1295994666.515" 
    $P3127."add_method"(type_obj, "infix:sym<~~>", $P3128)
    get_how $P3129, type_obj
    get_hll_global $P3130, ["HLL"], "Actions"
    $P3129."add_parent"(type_obj, $P3130)
    get_how $P3131, type_obj
    $P3132 = $P3131."compose"(type_obj)
    .return ($P3132)
.end


.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_20
.annotate 'line', 9
    .lex "$xblock", param_20
.annotate 'line', 10
    find_lex $P21, "$xblock"
    unless_null $P21, vivify_169
    $P21 = root_new ['parrot';'ResizablePMCArray']
  vivify_169:
    set $P22, $P21[1]
    unless_null $P22, vivify_170
    new $P22, "Undef"
  vivify_170:
    $P23 = "block_immediate"($P22)
    find_lex $P24, "$xblock"
    unless_null $P24, vivify_171
    $P24 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P24
  vivify_171:
    set $P24[1], $P23
    find_lex $P25, "$xblock"
.annotate 'line', 9
    .return ($P25)
.end


.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_28
.annotate 'line', 14
    .const 'Sub' $P38 = "14_1295994666.515" 
    capture_lex $P38
    .lex "$block", param_28
.annotate 'line', 15
    find_lex $P29, "$block"
    $P29."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P33, "$block"
    $P34 = $P33."symtable"()
    unless $P34, unless_32
    set $P31, $P34
    goto unless_32_end
  unless_32:
    find_lex $P35, "$block"
    $P36 = $P35."handlers"()
    set $P31, $P36
  unless_32_end:
    if $P31, unless_30_end
    .const 'Sub' $P38 = "14_1295994666.515" 
    capture_lex $P38
    $P38()
  unless_30_end:
    find_lex $P58, "$block"
.annotate 'line', 14
    .return ($P58)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block37"  :anon :subid("14_1295994666.515") :outer("13_1295994666.515")
.annotate 'line', 16
    .const 'Sub' $P49 = "15_1295994666.515" 
    capture_lex $P49
.annotate 'line', 17
    new $P39, "Undef"
    .lex "$stmts", $P39
    get_hll_global $P40, ["PAST"], "Stmts"
    find_lex $P41, "$block"
    $P42 = $P40."new"($P41 :named("node"))
    store_lex "$stmts", $P42
.annotate 'line', 18
    find_lex $P44, "$block"
    $P45 = $P44."list"()
    defined $I46, $P45
    unless $I46, for_undef_172
    iter $P43, $P45
    new $P55, 'ExceptionHandler'
    set_addr $P55, loop54_handler
    $P55."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P55
  loop54_test:
    unless $P43, loop54_done
    shift $P47, $P43
  loop54_redo:
    .const 'Sub' $P49 = "15_1295994666.515" 
    capture_lex $P49
    $P49($P47)
  loop54_next:
    goto loop54_test
  loop54_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P56, exception, 'type'
    eq $P56, .CONTROL_LOOP_NEXT, loop54_next
    eq $P56, .CONTROL_LOOP_REDO, loop54_redo
  loop54_done:
    pop_eh 
  for_undef_172:
.annotate 'line', 19
    find_lex $P57, "$stmts"
    store_lex "$block", $P57
.annotate 'line', 16
    .return ($P57)
.end


.namespace ["NQP";"Actions"]
.sub "_block48"  :anon :subid("15_1295994666.515") :outer("14_1295994666.515")
    .param pmc param_50
.annotate 'line', 18
    .lex "$_", param_50
    find_lex $P51, "$stmts"
    find_lex $P52, "$_"
    $P53 = $P51."push"($P52)
    .return ($P53)
.end


.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_61
.annotate 'line', 24
    .lex "$sigil", param_61
.annotate 'line', 25
    find_lex $P64, "$sigil"
    set $S65, $P64
    iseq $I66, $S65, "%"
    if $I66, if_63
.annotate 'line', 27
    find_lex $P71, "$sigil"
    set $S72, $P71
    iseq $I73, $S72, "@"
    if $I73, if_70
    new $P76, "String"
    assign $P76, "Undef"
    set $P69, $P76
    goto if_70_end
  if_70:
.annotate 'line', 28
    get_hll_global $P74, ["PAST"], "Op"
    $P75 = $P74."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P69, $P75
  if_70_end:
    set $P62, $P69
.annotate 'line', 25
    goto if_63_end
  if_63:
.annotate 'line', 26
    get_hll_global $P67, ["PAST"], "Op"
    $P68 = $P67."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P62, $P68
  if_63_end:
.annotate 'line', 24
    .return ($P62)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_79
.annotate 'line', 43
    .lex "$ast", param_79
.annotate 'line', 44
    get_hll_global $P82, ["PAST"], "Op"
    find_lex $P83, "$ast"
    $P84 = $P82."ACCEPTS"($P83)
    if $P84, if_81
.annotate 'line', 46
    find_lex $P88, "$ast"
    $P89 = $P88."value"()
    set $P80, $P89
.annotate 'line', 44
    goto if_81_end
  if_81:
.annotate 'line', 45
    find_lex $P85, "$ast"
    $P86 = $P85."list"()
    join $S87, " ", $P86
    new $P80, 'String'
    set $P80, $S87
  if_81_end:
.annotate 'line', 43
    .return ($P80)
.end


.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_92
    .param pmc param_93
.annotate 'line', 223
    .lex "$/", param_92
    .lex "$block", param_93
.annotate 'line', 224
    get_global $P95, "@BLOCK"
    unless_null $P95, vivify_173
    $P95 = root_new ['parrot';'ResizablePMCArray']
  vivify_173:
    set $P96, $P95[0]
    unless_null $P96, vivify_174
    new $P96, "Undef"
  vivify_174:
    $P97 = $P96."handlers"()
    if $P97, unless_94_end
.annotate 'line', 225
    get_global $P98, "@BLOCK"
    unless_null $P98, vivify_175
    $P98 = root_new ['parrot';'ResizablePMCArray']
  vivify_175:
    set $P99, $P98[0]
    unless_null $P99, vivify_176
    new $P99, "Undef"
  vivify_176:
    new $P100, "ResizablePMCArray"
    $P99."handlers"($P100)
  unless_94_end:
.annotate 'line', 227
    find_lex $P102, "$block"
    $P103 = $P102."arity"()
    if $P103, unless_101_end
.annotate 'line', 228
    find_lex $P104, "$block"
.annotate 'line', 229
    get_hll_global $P105, ["PAST"], "Op"
.annotate 'line', 230
    get_hll_global $P106, ["PAST"], "Var"
    $P107 = $P106."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 231
    get_hll_global $P108, ["PAST"], "Var"
    $P109 = $P108."new"("lexical" :named("scope"), "$_" :named("name"))
    $P110 = $P105."new"($P107, $P109, "bind" :named("pasttype"))
.annotate 'line', 229
    $P104."unshift"($P110)
.annotate 'line', 234
    find_lex $P111, "$block"
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("$_" :named("name"), "parameter" :named("scope"))
    $P111."unshift"($P113)
.annotate 'line', 235
    find_lex $P114, "$block"
    $P114."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 236
    find_lex $P115, "$block"
    $P115."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 237
    find_lex $P116, "$block"
    $P116."arity"(1)
  unless_101_end:
.annotate 'line', 239
    find_lex $P117, "$block"
    $P117."blocktype"("declaration")
.annotate 'line', 240
    get_global $P118, "@BLOCK"
    unless_null $P118, vivify_177
    $P118 = root_new ['parrot';'ResizablePMCArray']
  vivify_177:
    set $P119, $P118[0]
    unless_null $P119, vivify_178
    new $P119, "Undef"
  vivify_178:
    $P120 = $P119."handlers"()
.annotate 'line', 241
    get_hll_global $P121, ["PAST"], "Control"
    find_lex $P122, "$/"
.annotate 'line', 243
    get_hll_global $P123, ["PAST"], "Stmts"
.annotate 'line', 244
    get_hll_global $P124, ["PAST"], "Op"
    find_lex $P125, "$block"
.annotate 'line', 246
    get_hll_global $P126, ["PAST"], "Var"
    $P127 = $P126."new"("register" :named("scope"), "exception" :named("name"))
    $P128 = $P124."new"($P125, $P127, "call" :named("pasttype"))
.annotate 'line', 248
    get_hll_global $P129, ["PAST"], "Op"
.annotate 'line', 249
    get_hll_global $P130, ["PAST"], "Var"
.annotate 'line', 250
    get_hll_global $P131, ["PAST"], "Var"
    $P132 = $P131."new"("register" :named("scope"), "exception" :named("name"))
    $P133 = $P130."new"($P132, "handled", "keyed" :named("scope"))
.annotate 'line', 249
    $P134 = $P129."new"($P133, 1, "bind" :named("pasttype"))
.annotate 'line', 248
    $P135 = $P123."new"($P128, $P134)
.annotate 'line', 243
    $P136 = $P121."new"($P135, $P122 :named("node"))
.annotate 'line', 241
    $P137 = $P120."unshift"($P136)
.annotate 'line', 223
    .return ($P137)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package"  :subid("19_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_142
.annotate 'line', 378
    .const 'Sub' $P212 = "21_1295994666.515" 
    capture_lex $P212
    .const 'Sub' $P193 = "20_1295994666.515" 
    capture_lex $P193
    new $P141, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P141, control_140
    push_eh $P141
    .lex "$/", param_142
.annotate 'line', 379
    $P143 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P143
.annotate 'line', 380
    new $P144, "Undef"
    .lex "$name", $P144
.annotate 'line', 453
    new $P145, "Undef"
    .lex "$past", $P145
.annotate 'line', 379
    find_lex $P146, "$/"
    unless_null $P146, vivify_179
    $P146 = root_new ['parrot';'Hash']
  vivify_179:
    set $P147, $P146["package_def"]
    unless_null $P147, vivify_180
    $P147 = root_new ['parrot';'Hash']
  vivify_180:
    set $P148, $P147["name"]
    unless_null $P148, vivify_181
    $P148 = root_new ['parrot';'Hash']
  vivify_181:
    set $P149, $P148["identifier"]
    unless_null $P149, vivify_182
    new $P149, "Undef"
  vivify_182:
    clone $P150, $P149
    store_lex "@ns", $P150
.annotate 'line', 380
    find_lex $P151, "@ns"
    $P152 = $P151."pop"()
    set $S153, $P152
    new $P154, 'String'
    set $P154, $S153
    store_lex "$name", $P154
.annotate 'line', 384
    find_dynamic_lex $P155, "$*PACKAGE-SETUP"
    unless_null $P155, vivify_183
    get_hll_global $P155, "$PACKAGE-SETUP"
    unless_null $P155, vivify_184
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_184:
  vivify_183:
    get_hll_global $P156, ["PAST"], "Stmts"
.annotate 'line', 385
    get_hll_global $P157, ["PAST"], "Op"
.annotate 'line', 386
    get_hll_global $P158, ["PAST"], "Var"
    $P159 = $P158."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 387
    get_hll_global $P160, ["PAST"], "Op"
.annotate 'line', 389
    get_hll_global $P161, ["PAST"], "Var"
    find_lex $P162, "$/"
    unless_null $P162, vivify_185
    $P162 = root_new ['parrot';'Hash']
  vivify_185:
    set $P163, $P162["sym"]
    unless_null $P163, vivify_186
    new $P163, "Undef"
  vivify_186:
    set $S164, $P163
    find_dynamic_lex $P165, "%*HOW"
    unless_null $P165, vivify_187
    get_hll_global $P165, "%HOW"
    unless_null $P165, vivify_188
    die "Contextual %*HOW not found"
  vivify_188:
  vivify_187:
    set $P166, $P165[$S164]
    unless_null $P166, vivify_189
    new $P166, "Undef"
  vivify_189:
    $P167 = $P161."new"($P166 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 390
    get_hll_global $P168, ["PAST"], "Val"
    find_lex $P169, "$name"
    $P170 = $P168."new"($P169 :named("value"), "name" :named("named"))
    $P171 = $P160."new"($P167, $P170, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 387
    $P172 = $P157."new"($P159, $P171, "bind" :named("pasttype"))
.annotate 'line', 393
    get_hll_global $P173, ["PAST"], "Op"
.annotate 'line', 394
    get_hll_global $P174, ["PAST"], "Var"
    find_lex $P175, "$name"
    find_lex $P176, "@ns"
    $P177 = $P174."new"($P175 :named("name"), $P176 :named("namespace"), "package" :named("scope"))
.annotate 'line', 395
    get_hll_global $P178, ["PAST"], "Var"
    $P179 = $P178."new"("type_obj" :named("name"), "register" :named("scope"))
    $P180 = $P173."new"($P177, $P179, "bind" :named("pasttype"))
.annotate 'line', 397
    get_hll_global $P181, ["PAST"], "Op"
.annotate 'line', 398
    get_hll_global $P182, ["PAST"], "Var"
    $P183 = $P182."new"("$?CLASS" :named("name"))
.annotate 'line', 399
    get_hll_global $P184, ["PAST"], "Var"
    $P185 = $P184."new"("type_obj" :named("name"), "register" :named("scope"))
    $P186 = $P181."new"($P183, $P185, "bind" :named("pasttype"))
.annotate 'line', 397
    $P187 = $P156."new"($P172, $P180, $P186)
.annotate 'line', 384
    $P155."unshift"($P187)
.annotate 'line', 402
    find_lex $P189, "$/"
    unless_null $P189, vivify_190
    $P189 = root_new ['parrot';'Hash']
  vivify_190:
    set $P190, $P189["package_def"]
    unless_null $P190, vivify_191
    $P190 = root_new ['parrot';'Hash']
  vivify_191:
    set $P191, $P190["repr"]
    unless_null $P191, vivify_192
    new $P191, "Undef"
  vivify_192:
    unless $P191, if_188_end
    .const 'Sub' $P193 = "20_1295994666.515" 
    capture_lex $P193
    $P193()
  if_188_end:
.annotate 'line', 410
    find_lex $P208, "$/"
    unless_null $P208, vivify_202
    $P208 = root_new ['parrot';'Hash']
  vivify_202:
    set $P209, $P208["package_def"]
    unless_null $P209, vivify_203
    $P209 = root_new ['parrot';'Hash']
  vivify_203:
    set $P210, $P209["parent"]
    unless_null $P210, vivify_204
    new $P210, "Undef"
  vivify_204:
    if $P210, if_207
.annotate 'line', 424
    find_lex $P241, "$/"
    unless_null $P241, vivify_205
    $P241 = root_new ['parrot';'Hash']
  vivify_205:
    set $P242, $P241["sym"]
    unless_null $P242, vivify_206
    new $P242, "Undef"
  vivify_206:
    set $S243, $P242
    iseq $I244, $S243, "grammar"
    unless $I244, if_240_end
.annotate 'line', 425
    find_dynamic_lex $P245, "$*PACKAGE-SETUP"
    unless_null $P245, vivify_207
    get_hll_global $P245, "$PACKAGE-SETUP"
    unless_null $P245, vivify_208
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_208:
  vivify_207:
    get_hll_global $P246, ["PAST"], "Op"
.annotate 'line', 427
    get_hll_global $P247, ["PAST"], "Op"
.annotate 'line', 430
    get_hll_global $P248, ["PAST"], "Var"
    $P249 = $P248."new"("type_obj" :named("name"), "register" :named("scope"))
    $P250 = $P247."new"($P249, "get_how PP" :named("pirop"))
.annotate 'line', 432
    get_hll_global $P251, ["PAST"], "Var"
    $P252 = $P251."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 433
    get_hll_global $P253, ["PAST"], "Var"
    $P254 = $P253."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P255 = $P246."new"($P250, $P252, $P254, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 425
    $P245."push"($P255)
  if_240_end:
.annotate 'line', 424
    goto if_207_end
  if_207:
.annotate 'line', 410
    .const 'Sub' $P212 = "21_1295994666.515" 
    capture_lex $P212
    $P212()
  if_207_end:
.annotate 'line', 438
    find_dynamic_lex $P256, "$*PACKAGE-SETUP"
    unless_null $P256, vivify_216
    get_hll_global $P256, "$PACKAGE-SETUP"
    unless_null $P256, vivify_217
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_217:
  vivify_216:
    get_hll_global $P257, ["PAST"], "Op"
.annotate 'line', 440
    get_hll_global $P258, ["PAST"], "Op"
.annotate 'line', 443
    get_hll_global $P259, ["PAST"], "Var"
    $P260 = $P259."new"("type_obj" :named("name"), "register" :named("scope"))
    $P261 = $P258."new"($P260, "get_how PP" :named("pirop"))
.annotate 'line', 445
    get_hll_global $P262, ["PAST"], "Var"
    $P263 = $P262."new"("type_obj" :named("name"), "register" :named("scope"))
    $P264 = $P257."new"($P261, $P263, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 438
    $P256."push"($P264)
.annotate 'line', 449
    get_global $P265, "@BLOCK"
    unless_null $P265, vivify_218
    $P265 = root_new ['parrot';'ResizablePMCArray']
  vivify_218:
    set $P266, $P265[0]
    unless_null $P266, vivify_219
    $P266 = root_new ['parrot';'ResizablePMCArray']
  vivify_219:
    set $P267, $P266[0]
    unless_null $P267, vivify_220
    new $P267, "Undef"
  vivify_220:
    get_hll_global $P268, ["PAST"], "Var"
    find_lex $P269, "$name"
    find_lex $P270, "@ns"
    $P271 = $P268."new"($P269 :named("name"), $P270 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P267."unshift"($P271)
.annotate 'line', 453
    find_lex $P272, "$/"
    unless_null $P272, vivify_221
    $P272 = root_new ['parrot';'Hash']
  vivify_221:
    set $P273, $P272["package_def"]
    unless_null $P273, vivify_222
    new $P273, "Undef"
  vivify_222:
    $P274 = $P273."ast"()
    store_lex "$past", $P274
.annotate 'line', 454
    find_lex $P275, "$past"
    get_hll_global $P276, ["PAST"], "Var"
    $P277 = $P276."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P275."unshift"($P277)
.annotate 'line', 455
    find_lex $P278, "$past"
    $P278."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 458
    find_lex $P279, "$past"
    $P280 = $P279."loadinit"()
    get_hll_global $P281, ["PAST"], "Block"
    find_dynamic_lex $P282, "$*PACKAGE-SETUP"
    unless_null $P282, vivify_223
    get_hll_global $P282, "$PACKAGE-SETUP"
    unless_null $P282, vivify_224
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_224:
  vivify_223:
    $P283 = $P281."new"($P282, "immediate" :named("blocktype"))
    $P280."push"($P283)
.annotate 'line', 460
    new $P284, "Exception"
    set $P284['type'], .CONTROL_RETURN
    find_lex $P285, "$past"
    setattribute $P284, 'payload', $P285
    throw $P284
.annotate 'line', 378
    .return ()
  control_140:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P286, exception, "payload"
    .return ($P286)
.end


.namespace ["NQP";"Actions"]
.sub "_block192"  :anon :subid("20_1295994666.515") :outer("19_1295994666.515")
.annotate 'line', 403
    new $P194, "Undef"
    .lex "$repr_name", $P194
    find_lex $P195, "$/"
    unless_null $P195, vivify_193
    $P195 = root_new ['parrot';'Hash']
  vivify_193:
    set $P196, $P195["package_def"]
    unless_null $P196, vivify_194
    $P196 = root_new ['parrot';'Hash']
  vivify_194:
    set $P197, $P196["repr"]
    unless_null $P197, vivify_195
    $P197 = root_new ['parrot';'ResizablePMCArray']
  vivify_195:
    set $P198, $P197[0]
    unless_null $P198, vivify_196
    new $P198, "Undef"
  vivify_196:
    $P199 = $P198."ast"()
    store_lex "$repr_name", $P199
.annotate 'line', 404
    find_lex $P200, "$repr_name"
    $P200."named"("repr")
.annotate 'line', 405
    find_dynamic_lex $P201, "$*PACKAGE-SETUP"
    unless_null $P201, vivify_197
    get_hll_global $P201, "$PACKAGE-SETUP"
    unless_null $P201, vivify_198
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_198:
  vivify_197:
    set $P202, $P201[0]
    unless_null $P202, vivify_199
    $P202 = root_new ['parrot';'ResizablePMCArray']
  vivify_199:
    set $P203, $P202[0]
    unless_null $P203, vivify_200
    $P203 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P204, $P203[1]
    unless_null $P204, vivify_201
    new $P204, "Undef"
  vivify_201:
    find_lex $P205, "$repr_name"
    $P206 = $P204."push"($P205)
.annotate 'line', 402
    .return ($P206)
.end


.namespace ["NQP";"Actions"]
.sub "_block211"  :anon :subid("21_1295994666.515") :outer("19_1295994666.515")
.annotate 'line', 411
    $P213 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P213
.annotate 'line', 412
    new $P214, "Undef"
    .lex "$name", $P214
.annotate 'line', 411
    find_lex $P215, "$/"
    unless_null $P215, vivify_209
    $P215 = root_new ['parrot';'Hash']
  vivify_209:
    set $P216, $P215["package_def"]
    unless_null $P216, vivify_210
    $P216 = root_new ['parrot';'Hash']
  vivify_210:
    set $P217, $P216["parent"]
    unless_null $P217, vivify_211
    $P217 = root_new ['parrot';'ResizablePMCArray']
  vivify_211:
    set $P218, $P217[0]
    unless_null $P218, vivify_212
    $P218 = root_new ['parrot';'Hash']
  vivify_212:
    set $P219, $P218["identifier"]
    unless_null $P219, vivify_213
    new $P219, "Undef"
  vivify_213:
    clone $P220, $P219
    store_lex "@ns", $P220
.annotate 'line', 412
    find_lex $P221, "@ns"
    $P222 = $P221."pop"()
    set $S223, $P222
    new $P224, 'String'
    set $P224, $S223
    store_lex "$name", $P224
.annotate 'line', 413
    find_dynamic_lex $P225, "$*PACKAGE-SETUP"
    unless_null $P225, vivify_214
    get_hll_global $P225, "$PACKAGE-SETUP"
    unless_null $P225, vivify_215
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_215:
  vivify_214:
    get_hll_global $P226, ["PAST"], "Op"
.annotate 'line', 415
    get_hll_global $P227, ["PAST"], "Op"
.annotate 'line', 418
    get_hll_global $P228, ["PAST"], "Var"
    $P229 = $P228."new"("type_obj" :named("name"), "register" :named("scope"))
    $P230 = $P227."new"($P229, "get_how PP" :named("pirop"))
.annotate 'line', 420
    get_hll_global $P231, ["PAST"], "Var"
    $P232 = $P231."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 421
    get_hll_global $P233, ["PAST"], "Var"
    find_lex $P234, "$name"
    set $S235, $P234
    find_lex $P236, "@ns"
    $P237 = $P233."new"($S235 :named("name"), $P236 :named("namespace"), "package" :named("scope"))
    $P238 = $P226."new"($P230, $P232, $P237, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 413
    $P239 = $P225."push"($P238)
.annotate 'line', 410
    .return ($P239)
.end


.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("22_1295994666.515") :outer("11_1295994666.515")
.annotate 'line', 741
    new $P289, "Undef"
    .lex "$past", $P289
    get_global $P290, "@BLOCK"
    $P291 = $P290."shift"()
    store_lex "$past", $P291
.annotate 'line', 742
    find_lex $P292, "$past"
    $P292."closure"(1)
.annotate 'line', 743
    find_lex $P293, "$past"
    get_hll_global $P294, ["PAST"], "Op"
    $P295 = $P294."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P293."push"($P295)
    find_lex $P296, "$past"
.annotate 'line', 740
    .return ($P296)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("23_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_299
.annotate 'line', 749
    .const 'Sub' $P313 = "24_1295994666.515" 
    capture_lex $P313
    .lex "$routine", param_299
.annotate 'line', 753
    new $P300, "Undef"
    .lex "$types", $P300
.annotate 'line', 754
    new $P301, "Undef"
    .lex "$definednesses", $P301
.annotate 'line', 753
    get_hll_global $P302, ["PAST"], "Op"
    $P303 = $P302."new"("list" :named("pasttype"))
    store_lex "$types", $P303
.annotate 'line', 754
    get_hll_global $P304, ["PAST"], "Op"
    $P305 = $P304."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P305
.annotate 'line', 755
    find_lex $P307, "$routine"
    unless_null $P307, vivify_225
    $P307 = root_new ['parrot';'ResizablePMCArray']
  vivify_225:
    set $P308, $P307[0]
    unless_null $P308, vivify_226
    new $P308, "Undef"
  vivify_226:
    $P309 = $P308."list"()
    defined $I310, $P309
    unless $I310, for_undef_227
    iter $P306, $P309
    new $P351, 'ExceptionHandler'
    set_addr $P351, loop350_handler
    $P351."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P351
  loop350_test:
    unless $P306, loop350_done
    shift $P311, $P306
  loop350_redo:
    .const 'Sub' $P313 = "24_1295994666.515" 
    capture_lex $P313
    $P313($P311)
  loop350_next:
    goto loop350_test
  loop350_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P352, exception, 'type'
    eq $P352, .CONTROL_LOOP_NEXT, loop350_next
    eq $P352, .CONTROL_LOOP_REDO, loop350_redo
  loop350_done:
    pop_eh 
  for_undef_227:
.annotate 'line', 762
    find_lex $P353, "$routine"
    $P354 = $P353."loadinit"()
    get_hll_global $P355, ["PAST"], "Op"
.annotate 'line', 763
    get_hll_global $P356, ["PAST"], "Var"
    $P357 = $P356."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P358, "$types"
    find_lex $P359, "$definednesses"
    $P360 = $P355."new"($P357, $P358, $P359, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 762
    $P361 = $P354."push"($P360)
.annotate 'line', 749
    .return ($P361)
.end


.namespace ["NQP";"Actions"]
.sub "_block312"  :anon :subid("24_1295994666.515") :outer("23_1295994666.515")
    .param pmc param_314
.annotate 'line', 755
    .lex "$_", param_314
.annotate 'line', 756
    get_hll_global $P319, ["PAST"], "Var"
    find_lex $P320, "$_"
    $P321 = $P319."ACCEPTS"($P320)
    if $P321, if_318
    set $P317, $P321
    goto if_318_end
  if_318:
    find_lex $P322, "$_"
    $S323 = $P322."scope"()
    iseq $I324, $S323, "parameter"
    new $P317, 'Integer'
    set $P317, $I324
  if_318_end:
    if $P317, if_316
    set $P315, $P317
    goto if_316_end
  if_316:
.annotate 'line', 757
    find_lex $P325, "$types"
    find_lex $P327, "$_"
    $P328 = $P327."multitype"()
    set $P326, $P328
    defined $I330, $P326
    if $I330, default_329
    get_hll_global $P331, ["PAST"], "Op"
    $P332 = $P331."new"("null P" :named("pirop"))
    set $P326, $P332
  default_329:
    $P325."push"($P326)
.annotate 'line', 758
    find_lex $P333, "$definednesses"
    find_lex $P336, "$_"
    unless_null $P336, vivify_228
    $P336 = root_new ['parrot';'Hash']
  vivify_228:
    set $P337, $P336["definedness"]
    unless_null $P337, vivify_229
    new $P337, "Undef"
  vivify_229:
    set $S338, $P337
    iseq $I339, $S338, "D"
    if $I339, if_335
.annotate 'line', 759
    find_lex $P343, "$_"
    unless_null $P343, vivify_230
    $P343 = root_new ['parrot';'Hash']
  vivify_230:
    set $P344, $P343["definedness"]
    unless_null $P344, vivify_231
    new $P344, "Undef"
  vivify_231:
    set $S345, $P344
    iseq $I346, $S345, "U"
    if $I346, if_342
    new $P348, "Integer"
    assign $P348, 0
    set $P341, $P348
    goto if_342_end
  if_342:
    new $P347, "Integer"
    assign $P347, 2
    set $P341, $P347
  if_342_end:
    set $P334, $P341
.annotate 'line', 758
    goto if_335_end
  if_335:
    new $P340, "Integer"
    assign $P340, 1
    set $P334, $P340
  if_335_end:
    $P349 = $P333."push"($P334)
.annotate 'line', 756
    set $P315, $P349
  if_316_end:
.annotate 'line', 755
    .return ($P315)
.end


.namespace ["NQP";"Actions"]
.sub "control"  :subid("25_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_364
    .param pmc param_365
.annotate 'line', 1201
    .lex "$/", param_364
    .lex "$type", param_365
.annotate 'line', 1202
    find_lex $P366, "$/"
    get_hll_global $P367, ["PAST"], "Op"
    find_lex $P368, "$/"
.annotate 'line', 1206
    get_hll_global $P369, ["PAST"], "Val"
    find_lex $P370, "$type"
    $P371 = $P369."new"($P370 :named("value"), "!except_types" :named("returns"))
    $P372 = $P367."new"(0, $P371, $P368 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1202
    $P373 = $P366."!make"($P372)
.annotate 'line', 1201
    .return ($P373)
.end


.namespace ["NQP";"Actions"]
.sub "_block376"  :anon :subid("26_1295994666.515") :outer("11_1295994666.515")
.annotate 'line', 3
    .const 'Sub' $P379 = "27_1295994666.515" 
    capture_lex $P379
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post232") :outer("26_1295994666.515")
.annotate 'line', 3
    .const 'Sub' $P377 = "26_1295994666.515" 
    .local pmc block
    set block, $P377
.annotate 'line', 5
    .const 'Sub' $P379 = "27_1295994666.515" 
    capture_lex $P379
    $P379()
.end


.namespace ["NQP";"Actions"]
.sub "_block378"  :anon :subid("27_1295994666.515") :outer("26_1295994666.515")
.annotate 'line', 6
    get_global $P380, "@BLOCK"
    unless_null $P380, vivify_233
    $P380 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P380
  vivify_233:
 $P381 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P381
.annotate 'line', 5
    .return ($P381)
.end


.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("28_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_386
    .param pmc param_387
.annotate 'line', 33
    .lex "self", param_386
    .lex "$/", param_387
    find_lex $P388, "$/"
    find_lex $P389, "$/"
    unless_null $P389, vivify_234
    $P389 = root_new ['parrot';'Hash']
  vivify_234:
    set $P390, $P389["comp_unit"]
    unless_null $P390, vivify_235
    new $P390, "Undef"
  vivify_235:
    $P391 = $P390."ast"()
    $P392 = $P388."!make"($P391)
    .return ($P392)
.end


.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("29_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_394
    .param pmc param_395
.annotate 'line', 35
    .lex "self", param_394
    .lex "$/", param_395
.annotate 'line', 36
    find_lex $P396, "$/"
.annotate 'line', 37
    find_lex $P399, "$/"
    unless_null $P399, vivify_236
    $P399 = root_new ['parrot';'Hash']
  vivify_236:
    set $P400, $P399["colonpair"]
    unless_null $P400, vivify_237
    new $P400, "Undef"
  vivify_237:
    if $P400, if_398
.annotate 'line', 39
    find_lex $P420, "$/"
    set $S421, $P420
    new $P397, 'String'
    set $P397, $S421
.annotate 'line', 37
    goto if_398_end
  if_398:
    find_lex $P401, "$/"
    unless_null $P401, vivify_238
    $P401 = root_new ['parrot';'Hash']
  vivify_238:
    set $P402, $P401["identifier"]
    unless_null $P402, vivify_239
    new $P402, "Undef"
  vivify_239:
    set $S403, $P402
    new $P404, 'String'
    set $P404, $S403
    concat $P405, $P404, ":"
    find_lex $P406, "$/"
    unless_null $P406, vivify_240
    $P406 = root_new ['parrot';'Hash']
  vivify_240:
    set $P407, $P406["colonpair"]
    unless_null $P407, vivify_241
    $P407 = root_new ['parrot';'ResizablePMCArray']
  vivify_241:
    set $P408, $P407[0]
    unless_null $P408, vivify_242
    new $P408, "Undef"
  vivify_242:
    $P409 = $P408."ast"()
    $S410 = $P409."named"()
    concat $P411, $P405, $S410
    concat $P412, $P411, "<"
.annotate 'line', 38
    find_lex $P413, "$/"
    unless_null $P413, vivify_243
    $P413 = root_new ['parrot';'Hash']
  vivify_243:
    set $P414, $P413["colonpair"]
    unless_null $P414, vivify_244
    $P414 = root_new ['parrot';'ResizablePMCArray']
  vivify_244:
    set $P415, $P414[0]
    unless_null $P415, vivify_245
    new $P415, "Undef"
  vivify_245:
    $P416 = $P415."ast"()
    $S417 = "colonpair_str"($P416)
    concat $P418, $P412, $S417
    concat $P419, $P418, ">"
    set $P397, $P419
  if_398_end:
.annotate 'line', 37
    $P422 = $P396."!make"($P397)
.annotate 'line', 35
    .return ($P422)
.end


.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("30_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_425
    .param pmc param_426
.annotate 'line', 49
    .lex "self", param_425
    .lex "$/", param_426
.annotate 'line', 50
    new $P427, "Undef"
    .lex "$mainline", $P427
.annotate 'line', 51
    new $P428, "Undef"
    .lex "$unit", $P428
.annotate 'line', 50
    find_lex $P429, "$/"
    unless_null $P429, vivify_246
    $P429 = root_new ['parrot';'Hash']
  vivify_246:
    set $P430, $P429["statementlist"]
    unless_null $P430, vivify_247
    new $P430, "Undef"
  vivify_247:
    $P431 = $P430."ast"()
    store_lex "$mainline", $P431
.annotate 'line', 51
    get_global $P432, "@BLOCK"
    $P433 = $P432."shift"()
    store_lex "$unit", $P433
.annotate 'line', 55
    find_lex $P434, "$unit"
    find_lex $P435, "self"
    $P436 = $P435."CTXSAVE"()
    $P434."push"($P436)
.annotate 'line', 58
    find_lex $P437, "$unit"
    $P437."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 59
    find_lex $P438, "$unit"
    get_hll_global $P439, ["PAST"], "Op"
    $P440 = $P439."new"("nqp_dynop_setup v" :named("pirop"))
    $P438."unshift"($P440)
.annotate 'line', 64
    find_lex $P441, "$unit"
.annotate 'line', 65
    get_hll_global $P442, ["PAST"], "Op"
    find_lex $P443, "$mainline"
    $P444 = $P442."new"($P443, "return" :named("pirop"))
    $P441."push"($P444)
.annotate 'line', 70
    find_lex $P445, "$unit"
.annotate 'line', 71
    get_hll_global $P446, ["PAST"], "Block"
.annotate 'line', 73
    get_hll_global $P447, ["PAST"], "Op"
    get_hll_global $P448, ["PAST"], "Val"
    find_lex $P449, "$unit"
    $P450 = $P448."new"($P449 :named("value"))
    $P451 = $P447."new"($P450, "call" :named("pasttype"))
    $P452 = $P446."new"($P451, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 71
    $P445."push"($P452)
.annotate 'line', 76
    find_lex $P453, "$unit"
    find_lex $P454, "$/"
    $P453."node"($P454)
.annotate 'line', 77
    find_lex $P455, "$/"
    find_lex $P456, "$unit"
    $P457 = $P455."!make"($P456)
.annotate 'line', 49
    .return ($P457)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("31_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_459
    .param pmc param_460
.annotate 'line', 80
    .const 'Sub' $P474 = "32_1295994666.515" 
    capture_lex $P474
    .lex "self", param_459
    .lex "$/", param_460
.annotate 'line', 81
    new $P461, "Undef"
    .lex "$past", $P461
    get_hll_global $P462, ["PAST"], "Stmts"
    find_lex $P463, "$/"
    $P464 = $P462."new"($P463 :named("node"))
    store_lex "$past", $P464
.annotate 'line', 82
    find_lex $P466, "$/"
    unless_null $P466, vivify_248
    $P466 = root_new ['parrot';'Hash']
  vivify_248:
    set $P467, $P466["statement"]
    unless_null $P467, vivify_249
    new $P467, "Undef"
  vivify_249:
    unless $P467, if_465_end
.annotate 'line', 83
    find_lex $P469, "$/"
    unless_null $P469, vivify_250
    $P469 = root_new ['parrot';'Hash']
  vivify_250:
    set $P470, $P469["statement"]
    unless_null $P470, vivify_251
    new $P470, "Undef"
  vivify_251:
    defined $I471, $P470
    unless $I471, for_undef_252
    iter $P468, $P470
    new $P494, 'ExceptionHandler'
    set_addr $P494, loop493_handler
    $P494."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P494
  loop493_test:
    unless $P468, loop493_done
    shift $P472, $P468
  loop493_redo:
    .const 'Sub' $P474 = "32_1295994666.515" 
    capture_lex $P474
    $P474($P472)
  loop493_next:
    goto loop493_test
  loop493_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P495, exception, 'type'
    eq $P495, .CONTROL_LOOP_NEXT, loop493_next
    eq $P495, .CONTROL_LOOP_REDO, loop493_redo
  loop493_done:
    pop_eh 
  for_undef_252:
  if_465_end:
.annotate 'line', 90
    find_lex $P496, "$/"
    find_lex $P497, "$past"
    $P498 = $P496."!make"($P497)
.annotate 'line', 80
    .return ($P498)
.end


.namespace ["NQP";"Actions"]
.sub "_block473"  :anon :subid("32_1295994666.515") :outer("31_1295994666.515")
    .param pmc param_476
.annotate 'line', 84
    new $P475, "Undef"
    .lex "$ast", $P475
    .lex "$_", param_476
    find_lex $P477, "$_"
    $P478 = $P477."ast"()
    store_lex "$ast", $P478
.annotate 'line', 85
    find_lex $P480, "$ast"
    unless_null $P480, vivify_253
    $P480 = root_new ['parrot';'Hash']
  vivify_253:
    set $P481, $P480["sink"]
    unless_null $P481, vivify_254
    new $P481, "Undef"
  vivify_254:
    defined $I482, $P481
    unless $I482, if_479_end
    find_lex $P483, "$ast"
    unless_null $P483, vivify_255
    $P483 = root_new ['parrot';'Hash']
  vivify_255:
    set $P484, $P483["sink"]
    unless_null $P484, vivify_256
    new $P484, "Undef"
  vivify_256:
    store_lex "$ast", $P484
  if_479_end:
.annotate 'line', 86
    find_lex $P486, "$ast"
    unless_null $P486, vivify_257
    $P486 = root_new ['parrot';'Hash']
  vivify_257:
    set $P487, $P486["bareblock"]
    unless_null $P487, vivify_258
    new $P487, "Undef"
  vivify_258:
    unless $P487, if_485_end
    find_lex $P488, "$ast"
    $P489 = "block_immediate"($P488)
    store_lex "$ast", $P489
  if_485_end:
.annotate 'line', 87
    find_lex $P490, "$past"
    find_lex $P491, "$ast"
    $P492 = $P490."push"($P491)
.annotate 'line', 83
    .return ($P492)
.end


.namespace ["NQP";"Actions"]
.sub "statement"  :subid("33_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_500
    .param pmc param_501
    .param pmc param_502 :optional
    .param int has_param_502 :opt_flag
.annotate 'line', 93
    .const 'Sub' $P510 = "34_1295994666.515" 
    capture_lex $P510
    .lex "self", param_500
    .lex "$/", param_501
    if has_param_502, optparam_259
    new $P503, "Undef"
    set param_502, $P503
  optparam_259:
    .lex "$key", param_502
.annotate 'line', 94
    new $P504, "Undef"
    .lex "$past", $P504
.annotate 'line', 93
    find_lex $P505, "$past"
.annotate 'line', 95
    find_lex $P507, "$/"
    unless_null $P507, vivify_260
    $P507 = root_new ['parrot';'Hash']
  vivify_260:
    set $P508, $P507["EXPR"]
    unless_null $P508, vivify_261
    new $P508, "Undef"
  vivify_261:
    if $P508, if_506
.annotate 'line', 116
    find_lex $P571, "$/"
    unless_null $P571, vivify_262
    $P571 = root_new ['parrot';'Hash']
  vivify_262:
    set $P572, $P571["statement_control"]
    unless_null $P572, vivify_263
    new $P572, "Undef"
  vivify_263:
    if $P572, if_570
.annotate 'line', 117
    new $P576, "Integer"
    assign $P576, 0
    store_lex "$past", $P576
    goto if_570_end
  if_570:
.annotate 'line', 116
    find_lex $P573, "$/"
    unless_null $P573, vivify_264
    $P573 = root_new ['parrot';'Hash']
  vivify_264:
    set $P574, $P573["statement_control"]
    unless_null $P574, vivify_265
    new $P574, "Undef"
  vivify_265:
    $P575 = $P574."ast"()
    store_lex "$past", $P575
  if_570_end:
    goto if_506_end
  if_506:
.annotate 'line', 95
    .const 'Sub' $P510 = "34_1295994666.515" 
    capture_lex $P510
    $P510()
  if_506_end:
.annotate 'line', 118
    find_lex $P577, "$/"
    find_lex $P578, "$past"
    $P579 = $P577."!make"($P578)
.annotate 'line', 93
    .return ($P579)
.end


.namespace ["NQP";"Actions"]
.sub "_block509"  :anon :subid("34_1295994666.515") :outer("33_1295994666.515")
.annotate 'line', 96
    new $P511, "Undef"
    .lex "$mc", $P511
.annotate 'line', 97
    new $P512, "Undef"
    .lex "$ml", $P512
.annotate 'line', 96
    find_lex $P513, "$/"
    unless_null $P513, vivify_266
    $P513 = root_new ['parrot';'Hash']
  vivify_266:
    set $P514, $P513["statement_mod_cond"]
    unless_null $P514, vivify_267
    $P514 = root_new ['parrot';'ResizablePMCArray']
  vivify_267:
    set $P515, $P514[0]
    unless_null $P515, vivify_268
    new $P515, "Undef"
  vivify_268:
    store_lex "$mc", $P515
.annotate 'line', 97
    find_lex $P516, "$/"
    unless_null $P516, vivify_269
    $P516 = root_new ['parrot';'Hash']
  vivify_269:
    set $P517, $P516["statement_mod_loop"]
    unless_null $P517, vivify_270
    $P517 = root_new ['parrot';'ResizablePMCArray']
  vivify_270:
    set $P518, $P517[0]
    unless_null $P518, vivify_271
    new $P518, "Undef"
  vivify_271:
    store_lex "$ml", $P518
.annotate 'line', 98
    find_lex $P519, "$/"
    unless_null $P519, vivify_272
    $P519 = root_new ['parrot';'Hash']
  vivify_272:
    set $P520, $P519["EXPR"]
    unless_null $P520, vivify_273
    new $P520, "Undef"
  vivify_273:
    $P521 = $P520."ast"()
    store_lex "$past", $P521
.annotate 'line', 99
    find_lex $P523, "$mc"
    unless $P523, if_522_end
.annotate 'line', 100
    get_hll_global $P524, ["PAST"], "Op"
    find_lex $P525, "$mc"
    unless_null $P525, vivify_274
    $P525 = root_new ['parrot';'Hash']
  vivify_274:
    set $P526, $P525["cond"]
    unless_null $P526, vivify_275
    new $P526, "Undef"
  vivify_275:
    $P527 = $P526."ast"()
    find_lex $P528, "$past"
    find_lex $P529, "$mc"
    unless_null $P529, vivify_276
    $P529 = root_new ['parrot';'Hash']
  vivify_276:
    set $P530, $P529["sym"]
    unless_null $P530, vivify_277
    new $P530, "Undef"
  vivify_277:
    set $S531, $P530
    find_lex $P532, "$/"
    $P533 = $P524."new"($P527, $P528, $S531 :named("pasttype"), $P532 :named("node"))
    store_lex "$past", $P533
  if_522_end:
.annotate 'line', 102
    find_lex $P536, "$ml"
    if $P536, if_535
    set $P534, $P536
    goto if_535_end
  if_535:
.annotate 'line', 103
    find_lex $P539, "$ml"
    unless_null $P539, vivify_278
    $P539 = root_new ['parrot';'Hash']
  vivify_278:
    set $P540, $P539["sym"]
    unless_null $P540, vivify_279
    new $P540, "Undef"
  vivify_279:
    set $S541, $P540
    iseq $I542, $S541, "for"
    if $I542, if_538
.annotate 'line', 112
    get_hll_global $P560, ["PAST"], "Op"
    find_lex $P561, "$ml"
    unless_null $P561, vivify_280
    $P561 = root_new ['parrot';'Hash']
  vivify_280:
    set $P562, $P561["cond"]
    unless_null $P562, vivify_281
    new $P562, "Undef"
  vivify_281:
    $P563 = $P562."ast"()
    find_lex $P564, "$past"
    find_lex $P565, "$ml"
    unless_null $P565, vivify_282
    $P565 = root_new ['parrot';'Hash']
  vivify_282:
    set $P566, $P565["sym"]
    unless_null $P566, vivify_283
    new $P566, "Undef"
  vivify_283:
    set $S567, $P566
    find_lex $P568, "$/"
    $P569 = $P560."new"($P563, $P564, $S567 :named("pasttype"), $P568 :named("node"))
    store_lex "$past", $P569
.annotate 'line', 111
    set $P537, $P569
.annotate 'line', 103
    goto if_538_end
  if_538:
.annotate 'line', 104
    get_hll_global $P543, ["PAST"], "Block"
.annotate 'line', 105
    get_hll_global $P544, ["PAST"], "Var"
    $P545 = $P544."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P546, "$past"
    $P547 = $P543."new"($P545, $P546, "immediate" :named("blocktype"))
.annotate 'line', 104
    store_lex "$past", $P547
.annotate 'line', 107
    find_lex $P548, "$past"
    $P548."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 108
    find_lex $P549, "$past"
    $P549."arity"(1)
.annotate 'line', 109
    get_hll_global $P550, ["PAST"], "Op"
    find_lex $P551, "$ml"
    unless_null $P551, vivify_284
    $P551 = root_new ['parrot';'Hash']
  vivify_284:
    set $P552, $P551["cond"]
    unless_null $P552, vivify_285
    new $P552, "Undef"
  vivify_285:
    $P553 = $P552."ast"()
    find_lex $P554, "$past"
    find_lex $P555, "$ml"
    unless_null $P555, vivify_286
    $P555 = root_new ['parrot';'Hash']
  vivify_286:
    set $P556, $P555["sym"]
    unless_null $P556, vivify_287
    new $P556, "Undef"
  vivify_287:
    set $S557, $P556
    find_lex $P558, "$/"
    $P559 = $P550."new"($P553, $P554, $S557 :named("pasttype"), $P558 :named("node"))
    store_lex "$past", $P559
.annotate 'line', 103
    set $P537, $P559
  if_538_end:
.annotate 'line', 102
    set $P534, $P537
  if_535_end:
.annotate 'line', 95
    .return ($P534)
.end


.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("35_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_581
    .param pmc param_582
.annotate 'line', 121
    .lex "self", param_581
    .lex "$/", param_582
.annotate 'line', 122
    find_lex $P583, "$/"
    get_hll_global $P584, ["PAST"], "Op"
    find_lex $P585, "$/"
    unless_null $P585, vivify_288
    $P585 = root_new ['parrot';'Hash']
  vivify_288:
    set $P586, $P585["EXPR"]
    unless_null $P586, vivify_289
    new $P586, "Undef"
  vivify_289:
    $P587 = $P586."ast"()
    find_lex $P588, "$/"
    unless_null $P588, vivify_290
    $P588 = root_new ['parrot';'Hash']
  vivify_290:
    set $P589, $P588["pblock"]
    unless_null $P589, vivify_291
    new $P589, "Undef"
  vivify_291:
    $P590 = $P589."ast"()
    find_lex $P591, "$/"
    $P592 = $P584."new"($P587, $P590, "if" :named("pasttype"), $P591 :named("node"))
    $P593 = $P583."!make"($P592)
.annotate 'line', 121
    .return ($P593)
.end


.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("36_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_595
    .param pmc param_596
.annotate 'line', 125
    .lex "self", param_595
    .lex "$/", param_596
.annotate 'line', 126
    find_lex $P597, "$/"
    find_lex $P598, "$/"
    unless_null $P598, vivify_292
    $P598 = root_new ['parrot';'Hash']
  vivify_292:
    set $P599, $P598["blockoid"]
    unless_null $P599, vivify_293
    new $P599, "Undef"
  vivify_293:
    $P600 = $P599."ast"()
    $P601 = $P597."!make"($P600)
.annotate 'line', 125
    .return ($P601)
.end


.namespace ["NQP";"Actions"]
.sub "block"  :subid("37_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_603
    .param pmc param_604
.annotate 'line', 129
    .lex "self", param_603
    .lex "$/", param_604
.annotate 'line', 130
    find_lex $P605, "$/"
    find_lex $P606, "$/"
    unless_null $P606, vivify_294
    $P606 = root_new ['parrot';'Hash']
  vivify_294:
    set $P607, $P606["blockoid"]
    unless_null $P607, vivify_295
    new $P607, "Undef"
  vivify_295:
    $P608 = $P607."ast"()
    $P609 = $P605."!make"($P608)
.annotate 'line', 129
    .return ($P609)
.end


.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("38_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_611
    .param pmc param_612
.annotate 'line', 133
    .lex "self", param_611
    .lex "$/", param_612
.annotate 'line', 134
    new $P613, "Undef"
    .lex "$past", $P613
.annotate 'line', 135
    new $P614, "Undef"
    .lex "$BLOCK", $P614
.annotate 'line', 134
    find_lex $P615, "$/"
    unless_null $P615, vivify_296
    $P615 = root_new ['parrot';'Hash']
  vivify_296:
    set $P616, $P615["statementlist"]
    unless_null $P616, vivify_297
    new $P616, "Undef"
  vivify_297:
    $P617 = $P616."ast"()
    store_lex "$past", $P617
.annotate 'line', 135
    get_global $P618, "@BLOCK"
    $P619 = $P618."shift"()
    store_lex "$BLOCK", $P619
.annotate 'line', 136
    find_lex $P620, "$BLOCK"
    find_lex $P621, "$past"
    $P620."push"($P621)
.annotate 'line', 137
    find_lex $P622, "$BLOCK"
    find_lex $P623, "$/"
    $P622."node"($P623)
.annotate 'line', 138
    find_lex $P624, "$BLOCK"
    $P624."closure"(1)
.annotate 'line', 139
    find_lex $P625, "$/"
    find_lex $P626, "$BLOCK"
    $P627 = $P625."!make"($P626)
.annotate 'line', 133
    .return ($P627)
.end


.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("39_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_629
    .param pmc param_630
.annotate 'line', 142
    .lex "self", param_629
    .lex "$/", param_630
.annotate 'line', 143
    get_global $P631, "@BLOCK"
    unless_null $P631, vivify_298
    $P631 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P631
  vivify_298:
.annotate 'line', 142
    get_global $P632, "@BLOCK"
.annotate 'line', 144
    get_global $P633, "@BLOCK"
    get_hll_global $P634, ["PAST"], "Block"
    get_hll_global $P635, ["PAST"], "Stmts"
    $P636 = $P635."new"()
    $P637 = $P634."new"($P636)
    $P638 = $P633."unshift"($P637)
.annotate 'line', 142
    .return ($P638)
.end


.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("40_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_640
    .param pmc param_641
.annotate 'line', 147
    .lex "self", param_640
    .lex "$/", param_641
.annotate 'line', 148
    get_global $P642, "@BLOCK"
    unless_null $P642, vivify_299
    $P642 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P642
  vivify_299:
.annotate 'line', 147
    get_global $P643, "@BLOCK"
.annotate 'line', 149
    find_lex $P644, "self"
    get_global $P645, "@BLOCK"
    unless_null $P645, vivify_300
    $P645 = root_new ['parrot';'ResizablePMCArray']
  vivify_300:
    set $P646, $P645[0]
    unless_null $P646, vivify_301
    new $P646, "Undef"
  vivify_301:
    $P647 = $P644."SET_BLOCK_OUTER_CTX"($P646)
.annotate 'line', 147
    .return ($P647)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("41_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_649
    .param pmc param_650
.annotate 'line', 154
    .const 'Sub' $P678 = "42_1295994666.515" 
    capture_lex $P678
    .lex "self", param_649
    .lex "$/", param_650
.annotate 'line', 155
    new $P651, "Undef"
    .lex "$count", $P651
.annotate 'line', 156
    new $P652, "Undef"
    .lex "$past", $P652
.annotate 'line', 155
    find_lex $P653, "$/"
    unless_null $P653, vivify_302
    $P653 = root_new ['parrot';'Hash']
  vivify_302:
    set $P654, $P653["xblock"]
    unless_null $P654, vivify_303
    new $P654, "Undef"
  vivify_303:
    set $N655, $P654
    new $P656, 'Float'
    set $P656, $N655
    sub $P657, $P656, 1
    store_lex "$count", $P657
.annotate 'line', 156
    find_lex $P658, "$count"
    set $I659, $P658
    find_lex $P660, "$/"
    unless_null $P660, vivify_304
    $P660 = root_new ['parrot';'Hash']
  vivify_304:
    set $P661, $P660["xblock"]
    unless_null $P661, vivify_305
    $P661 = root_new ['parrot';'ResizablePMCArray']
  vivify_305:
    set $P662, $P661[$I659]
    unless_null $P662, vivify_306
    new $P662, "Undef"
  vivify_306:
    $P663 = $P662."ast"()
    $P664 = "xblock_immediate"($P663)
    store_lex "$past", $P664
.annotate 'line', 157
    find_lex $P666, "$/"
    unless_null $P666, vivify_307
    $P666 = root_new ['parrot';'Hash']
  vivify_307:
    set $P667, $P666["else"]
    unless_null $P667, vivify_308
    new $P667, "Undef"
  vivify_308:
    unless $P667, if_665_end
.annotate 'line', 158
    find_lex $P668, "$past"
    find_lex $P669, "$/"
    unless_null $P669, vivify_309
    $P669 = root_new ['parrot';'Hash']
  vivify_309:
    set $P670, $P669["else"]
    unless_null $P670, vivify_310
    $P670 = root_new ['parrot';'ResizablePMCArray']
  vivify_310:
    set $P671, $P670[0]
    unless_null $P671, vivify_311
    new $P671, "Undef"
  vivify_311:
    $P672 = $P671."ast"()
    $P673 = "block_immediate"($P672)
    $P668."push"($P673)
  if_665_end:
.annotate 'line', 161
    new $P694, 'ExceptionHandler'
    set_addr $P694, loop693_handler
    $P694."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P694
  loop693_test:
    find_lex $P674, "$count"
    set $N675, $P674
    isgt $I676, $N675, 0.0
    unless $I676, loop693_done
  loop693_redo:
    .const 'Sub' $P678 = "42_1295994666.515" 
    capture_lex $P678
    $P678()
  loop693_next:
    goto loop693_test
  loop693_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P695, exception, 'type'
    eq $P695, .CONTROL_LOOP_NEXT, loop693_next
    eq $P695, .CONTROL_LOOP_REDO, loop693_redo
  loop693_done:
    pop_eh 
.annotate 'line', 167
    find_lex $P696, "$/"
    find_lex $P697, "$past"
    $P698 = $P696."!make"($P697)
.annotate 'line', 154
    .return ($P698)
.end


.namespace ["NQP";"Actions"]
.sub "_block677"  :anon :subid("42_1295994666.515") :outer("41_1295994666.515")
.annotate 'line', 163
    new $P679, "Undef"
    .lex "$else", $P679
.annotate 'line', 161
    find_lex $P680, "$count"
    clone $P681, $P680
    dec $P680
.annotate 'line', 163
    find_lex $P682, "$past"
    store_lex "$else", $P682
.annotate 'line', 164
    find_lex $P683, "$count"
    set $I684, $P683
    find_lex $P685, "$/"
    unless_null $P685, vivify_312
    $P685 = root_new ['parrot';'Hash']
  vivify_312:
    set $P686, $P685["xblock"]
    unless_null $P686, vivify_313
    $P686 = root_new ['parrot';'ResizablePMCArray']
  vivify_313:
    set $P687, $P686[$I684]
    unless_null $P687, vivify_314
    new $P687, "Undef"
  vivify_314:
    $P688 = $P687."ast"()
    $P689 = "xblock_immediate"($P688)
    store_lex "$past", $P689
.annotate 'line', 165
    find_lex $P690, "$past"
    find_lex $P691, "$else"
    $P692 = $P690."push"($P691)
.annotate 'line', 161
    .return ($P692)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("43_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_700
    .param pmc param_701
.annotate 'line', 170
    .lex "self", param_700
    .lex "$/", param_701
.annotate 'line', 171
    new $P702, "Undef"
    .lex "$past", $P702
    find_lex $P703, "$/"
    unless_null $P703, vivify_315
    $P703 = root_new ['parrot';'Hash']
  vivify_315:
    set $P704, $P703["xblock"]
    unless_null $P704, vivify_316
    new $P704, "Undef"
  vivify_316:
    $P705 = $P704."ast"()
    $P706 = "xblock_immediate"($P705)
    store_lex "$past", $P706
.annotate 'line', 172
    find_lex $P707, "$past"
    $P707."pasttype"("unless")
.annotate 'line', 173
    find_lex $P708, "$/"
    find_lex $P709, "$past"
    $P710 = $P708."!make"($P709)
.annotate 'line', 170
    .return ($P710)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("44_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_712
    .param pmc param_713
.annotate 'line', 176
    .lex "self", param_712
    .lex "$/", param_713
.annotate 'line', 177
    new $P714, "Undef"
    .lex "$past", $P714
    find_lex $P715, "$/"
    unless_null $P715, vivify_317
    $P715 = root_new ['parrot';'Hash']
  vivify_317:
    set $P716, $P715["xblock"]
    unless_null $P716, vivify_318
    new $P716, "Undef"
  vivify_318:
    $P717 = $P716."ast"()
    $P718 = "xblock_immediate"($P717)
    store_lex "$past", $P718
.annotate 'line', 178
    find_lex $P719, "$past"
    find_lex $P720, "$/"
    unless_null $P720, vivify_319
    $P720 = root_new ['parrot';'Hash']
  vivify_319:
    set $P721, $P720["sym"]
    unless_null $P721, vivify_320
    new $P721, "Undef"
  vivify_320:
    set $S722, $P721
    $P719."pasttype"($S722)
.annotate 'line', 179
    find_lex $P723, "$/"
    find_lex $P724, "$past"
    $P725 = $P723."!make"($P724)
.annotate 'line', 176
    .return ($P725)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("45_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_727
    .param pmc param_728
.annotate 'line', 182
    .lex "self", param_727
    .lex "$/", param_728
.annotate 'line', 183
    new $P729, "Undef"
    .lex "$pasttype", $P729
.annotate 'line', 184
    new $P730, "Undef"
    .lex "$past", $P730
.annotate 'line', 183
    new $P731, "String"
    assign $P731, "repeat_"
    find_lex $P732, "$/"
    unless_null $P732, vivify_321
    $P732 = root_new ['parrot';'Hash']
  vivify_321:
    set $P733, $P732["wu"]
    unless_null $P733, vivify_322
    new $P733, "Undef"
  vivify_322:
    set $S734, $P733
    concat $P735, $P731, $S734
    store_lex "$pasttype", $P735
    find_lex $P736, "$past"
.annotate 'line', 185
    find_lex $P738, "$/"
    unless_null $P738, vivify_323
    $P738 = root_new ['parrot';'Hash']
  vivify_323:
    set $P739, $P738["xblock"]
    unless_null $P739, vivify_324
    new $P739, "Undef"
  vivify_324:
    if $P739, if_737
.annotate 'line', 190
    get_hll_global $P746, ["PAST"], "Op"
    find_lex $P747, "$/"
    unless_null $P747, vivify_325
    $P747 = root_new ['parrot';'Hash']
  vivify_325:
    set $P748, $P747["EXPR"]
    unless_null $P748, vivify_326
    new $P748, "Undef"
  vivify_326:
    $P749 = $P748."ast"()
    find_lex $P750, "$/"
    unless_null $P750, vivify_327
    $P750 = root_new ['parrot';'Hash']
  vivify_327:
    set $P751, $P750["pblock"]
    unless_null $P751, vivify_328
    new $P751, "Undef"
  vivify_328:
    $P752 = $P751."ast"()
    $P753 = "block_immediate"($P752)
    find_lex $P754, "$pasttype"
    find_lex $P755, "$/"
    $P756 = $P746."new"($P749, $P753, $P754 :named("pasttype"), $P755 :named("node"))
    store_lex "$past", $P756
.annotate 'line', 189
    goto if_737_end
  if_737:
.annotate 'line', 186
    find_lex $P740, "$/"
    unless_null $P740, vivify_329
    $P740 = root_new ['parrot';'Hash']
  vivify_329:
    set $P741, $P740["xblock"]
    unless_null $P741, vivify_330
    new $P741, "Undef"
  vivify_330:
    $P742 = $P741."ast"()
    $P743 = "xblock_immediate"($P742)
    store_lex "$past", $P743
.annotate 'line', 187
    find_lex $P744, "$past"
    find_lex $P745, "$pasttype"
    $P744."pasttype"($P745)
  if_737_end:
.annotate 'line', 193
    find_lex $P757, "$/"
    find_lex $P758, "$past"
    $P759 = $P757."!make"($P758)
.annotate 'line', 182
    .return ($P759)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("46_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_761
    .param pmc param_762
.annotate 'line', 196
    .lex "self", param_761
    .lex "$/", param_762
.annotate 'line', 197
    new $P763, "Undef"
    .lex "$past", $P763
.annotate 'line', 199
    new $P764, "Undef"
    .lex "$block", $P764
.annotate 'line', 197
    find_lex $P765, "$/"
    unless_null $P765, vivify_331
    $P765 = root_new ['parrot';'Hash']
  vivify_331:
    set $P766, $P765["xblock"]
    unless_null $P766, vivify_332
    new $P766, "Undef"
  vivify_332:
    $P767 = $P766."ast"()
    store_lex "$past", $P767
.annotate 'line', 198
    find_lex $P768, "$past"
    $P768."pasttype"("for")
.annotate 'line', 199
    find_lex $P769, "$past"
    unless_null $P769, vivify_333
    $P769 = root_new ['parrot';'ResizablePMCArray']
  vivify_333:
    set $P770, $P769[1]
    unless_null $P770, vivify_334
    new $P770, "Undef"
  vivify_334:
    store_lex "$block", $P770
.annotate 'line', 200
    find_lex $P772, "$block"
    $P773 = $P772."arity"()
    if $P773, unless_771_end
.annotate 'line', 201
    find_lex $P774, "$block"
    unless_null $P774, vivify_335
    $P774 = root_new ['parrot';'ResizablePMCArray']
  vivify_335:
    set $P775, $P774[0]
    unless_null $P775, vivify_336
    new $P775, "Undef"
  vivify_336:
    get_hll_global $P776, ["PAST"], "Var"
    $P777 = $P776."new"("$_" :named("name"), "parameter" :named("scope"))
    $P775."push"($P777)
.annotate 'line', 202
    find_lex $P778, "$block"
    $P778."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 203
    find_lex $P779, "$block"
    $P779."arity"(1)
  unless_771_end:
.annotate 'line', 205
    find_lex $P780, "$block"
    $P780."blocktype"("immediate")
.annotate 'line', 206
    find_lex $P781, "$/"
    find_lex $P782, "$past"
    $P783 = $P781."!make"($P782)
.annotate 'line', 196
    .return ($P783)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("47_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_785
    .param pmc param_786
.annotate 'line', 209
    .lex "self", param_785
    .lex "$/", param_786
.annotate 'line', 210
    new $P787, "Undef"
    .lex "$block", $P787
    find_lex $P788, "$/"
    unless_null $P788, vivify_337
    $P788 = root_new ['parrot';'Hash']
  vivify_337:
    set $P789, $P788["block"]
    unless_null $P789, vivify_338
    new $P789, "Undef"
  vivify_338:
    $P790 = $P789."ast"()
    store_lex "$block", $P790
.annotate 'line', 211
    find_lex $P791, "$/"
    find_lex $P792, "$block"
    "push_block_handler"($P791, $P792)
.annotate 'line', 212
    get_global $P793, "@BLOCK"
    unless_null $P793, vivify_339
    $P793 = root_new ['parrot';'ResizablePMCArray']
  vivify_339:
    set $P794, $P793[0]
    unless_null $P794, vivify_340
    new $P794, "Undef"
  vivify_340:
    $P795 = $P794."handlers"()
    set $P796, $P795[0]
    unless_null $P796, vivify_341
    new $P796, "Undef"
  vivify_341:
    $P796."handle_types_except"("CONTROL")
.annotate 'line', 213
    find_lex $P797, "$/"
    get_hll_global $P798, ["PAST"], "Stmts"
    find_lex $P799, "$/"
    $P800 = $P798."new"($P799 :named("node"))
    $P801 = $P797."!make"($P800)
.annotate 'line', 209
    .return ($P801)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("48_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_803
    .param pmc param_804
.annotate 'line', 216
    .lex "self", param_803
    .lex "$/", param_804
.annotate 'line', 217
    new $P805, "Undef"
    .lex "$block", $P805
    find_lex $P806, "$/"
    unless_null $P806, vivify_342
    $P806 = root_new ['parrot';'Hash']
  vivify_342:
    set $P807, $P806["block"]
    unless_null $P807, vivify_343
    new $P807, "Undef"
  vivify_343:
    $P808 = $P807."ast"()
    store_lex "$block", $P808
.annotate 'line', 218
    find_lex $P809, "$/"
    find_lex $P810, "$block"
    "push_block_handler"($P809, $P810)
.annotate 'line', 219
    get_global $P811, "@BLOCK"
    unless_null $P811, vivify_344
    $P811 = root_new ['parrot';'ResizablePMCArray']
  vivify_344:
    set $P812, $P811[0]
    unless_null $P812, vivify_345
    new $P812, "Undef"
  vivify_345:
    $P813 = $P812."handlers"()
    set $P814, $P813[0]
    unless_null $P814, vivify_346
    new $P814, "Undef"
  vivify_346:
    $P814."handle_types"("CONTROL")
.annotate 'line', 220
    find_lex $P815, "$/"
    get_hll_global $P816, ["PAST"], "Stmts"
    find_lex $P817, "$/"
    $P818 = $P816."new"($P817 :named("node"))
    $P819 = $P815."!make"($P818)
.annotate 'line', 216
    .return ($P819)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("49_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_822
    .param pmc param_823
.annotate 'line', 260
    .lex "self", param_822
    .lex "$/", param_823
.annotate 'line', 261
    new $P824, "Undef"
    .lex "$init_block", $P824
    get_hll_global $P825, ["PAST"], "Block"
    $P826 = $P825."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P826
.annotate 'line', 262
    find_lex $P827, "$init_block"
    $P828 = $P827."loadinit"()
    find_lex $P829, "$/"
    unless_null $P829, vivify_347
    $P829 = root_new ['parrot';'Hash']
  vivify_347:
    set $P830, $P829["blorst"]
    unless_null $P830, vivify_348
    new $P830, "Undef"
  vivify_348:
    $P831 = $P830."ast"()
    $P828."push"($P831)
.annotate 'line', 263
    find_lex $P832, "$/"
    find_lex $P833, "$init_block"
    $P834 = $P832."!make"($P833)
.annotate 'line', 260
    .return ($P834)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("50_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_836
    .param pmc param_837
.annotate 'line', 266
    .lex "self", param_836
    .lex "$/", param_837
.annotate 'line', 267
    new $P838, "Undef"
    .lex "$past", $P838
    find_lex $P839, "$/"
    unless_null $P839, vivify_349
    $P839 = root_new ['parrot';'Hash']
  vivify_349:
    set $P840, $P839["blorst"]
    unless_null $P840, vivify_350
    new $P840, "Undef"
  vivify_350:
    $P841 = $P840."ast"()
    store_lex "$past", $P841
.annotate 'line', 268
    get_hll_global $P843, ["PAST"], "Block"
    find_lex $P844, "$past"
    $P845 = $P843."ACCEPTS"($P844)
    if $P845, unless_842_end
.annotate 'line', 269
    get_hll_global $P846, ["PAST"], "Block"
    find_lex $P847, "$past"
    find_lex $P848, "$/"
    $P849 = $P846."new"($P847, "immediate" :named("blocktype"), $P848 :named("node"))
    store_lex "$past", $P849
  unless_842_end:
.annotate 'line', 271
    find_lex $P851, "$past"
    $P852 = $P851."handlers"()
    if $P852, unless_850_end
.annotate 'line', 272
    find_lex $P853, "$past"
    get_hll_global $P854, ["PAST"], "Control"
.annotate 'line', 274
    get_hll_global $P855, ["PAST"], "Stmts"
.annotate 'line', 275
    get_hll_global $P856, ["PAST"], "Op"
.annotate 'line', 276
    get_hll_global $P857, ["PAST"], "Var"
.annotate 'line', 277
    get_hll_global $P858, ["PAST"], "Var"
    $P859 = $P858."new"("register" :named("scope"), "exception" :named("name"))
    $P860 = $P857."new"($P859, "handled", "keyed" :named("scope"))
.annotate 'line', 276
    $P861 = $P856."new"($P860, 1, "bind" :named("pasttype"))
.annotate 'line', 275
    $P862 = $P855."new"($P861)
.annotate 'line', 274
    $P863 = $P854."new"($P862, "CONTROL" :named("handle_types_except"))
.annotate 'line', 272
    new $P864, "ResizablePMCArray"
    push $P864, $P863
    $P853."handlers"($P864)
  unless_850_end:
.annotate 'line', 286
    find_lex $P865, "$/"
    find_lex $P866, "$past"
    $P867 = $P865."!make"($P866)
.annotate 'line', 266
    .return ($P867)
.end


.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("51_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_869
    .param pmc param_870
.annotate 'line', 289
    .lex "self", param_869
    .lex "$/", param_870
.annotate 'line', 290
    find_lex $P871, "$/"
.annotate 'line', 291
    find_lex $P874, "$/"
    unless_null $P874, vivify_351
    $P874 = root_new ['parrot';'Hash']
  vivify_351:
    set $P875, $P874["block"]
    unless_null $P875, vivify_352
    new $P875, "Undef"
  vivify_352:
    if $P875, if_873
.annotate 'line', 292
    find_lex $P880, "$/"
    unless_null $P880, vivify_353
    $P880 = root_new ['parrot';'Hash']
  vivify_353:
    set $P881, $P880["statement"]
    unless_null $P881, vivify_354
    new $P881, "Undef"
  vivify_354:
    $P882 = $P881."ast"()
    set $P872, $P882
.annotate 'line', 291
    goto if_873_end
  if_873:
    find_lex $P876, "$/"
    unless_null $P876, vivify_355
    $P876 = root_new ['parrot';'Hash']
  vivify_355:
    set $P877, $P876["block"]
    unless_null $P877, vivify_356
    new $P877, "Undef"
  vivify_356:
    $P878 = $P877."ast"()
    $P879 = "block_immediate"($P878)
    set $P872, $P879
  if_873_end:
    $P883 = $P871."!make"($P872)
.annotate 'line', 289
    .return ($P883)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("52_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_885
    .param pmc param_886
.annotate 'line', 297
    .lex "self", param_885
    .lex "$/", param_886
    find_lex $P887, "$/"
    find_lex $P888, "$/"
    unless_null $P888, vivify_357
    $P888 = root_new ['parrot';'Hash']
  vivify_357:
    set $P889, $P888["cond"]
    unless_null $P889, vivify_358
    new $P889, "Undef"
  vivify_358:
    $P890 = $P889."ast"()
    $P891 = $P887."!make"($P890)
    .return ($P891)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("53_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_893
    .param pmc param_894
.annotate 'line', 298
    .lex "self", param_893
    .lex "$/", param_894
    find_lex $P895, "$/"
    find_lex $P896, "$/"
    unless_null $P896, vivify_359
    $P896 = root_new ['parrot';'Hash']
  vivify_359:
    set $P897, $P896["cond"]
    unless_null $P897, vivify_360
    new $P897, "Undef"
  vivify_360:
    $P898 = $P897."ast"()
    $P899 = $P895."!make"($P898)
    .return ($P899)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("54_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_901
    .param pmc param_902
.annotate 'line', 300
    .lex "self", param_901
    .lex "$/", param_902
    find_lex $P903, "$/"
    find_lex $P904, "$/"
    unless_null $P904, vivify_361
    $P904 = root_new ['parrot';'Hash']
  vivify_361:
    set $P905, $P904["cond"]
    unless_null $P905, vivify_362
    new $P905, "Undef"
  vivify_362:
    $P906 = $P905."ast"()
    $P907 = $P903."!make"($P906)
    .return ($P907)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("55_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_909
    .param pmc param_910
.annotate 'line', 301
    .lex "self", param_909
    .lex "$/", param_910
    find_lex $P911, "$/"
    find_lex $P912, "$/"
    unless_null $P912, vivify_363
    $P912 = root_new ['parrot';'Hash']
  vivify_363:
    set $P913, $P912["cond"]
    unless_null $P913, vivify_364
    new $P913, "Undef"
  vivify_364:
    $P914 = $P913."ast"()
    $P915 = $P911."!make"($P914)
    .return ($P915)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("56_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_917
    .param pmc param_918
.annotate 'line', 305
    .lex "self", param_917
    .lex "$/", param_918
    find_lex $P919, "$/"
    find_lex $P920, "$/"
    unless_null $P920, vivify_365
    $P920 = root_new ['parrot';'Hash']
  vivify_365:
    set $P921, $P920["fatarrow"]
    unless_null $P921, vivify_366
    new $P921, "Undef"
  vivify_366:
    $P922 = $P921."ast"()
    $P923 = $P919."!make"($P922)
    .return ($P923)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("57_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_925
    .param pmc param_926
.annotate 'line', 306
    .lex "self", param_925
    .lex "$/", param_926
    find_lex $P927, "$/"
    find_lex $P928, "$/"
    unless_null $P928, vivify_367
    $P928 = root_new ['parrot';'Hash']
  vivify_367:
    set $P929, $P928["colonpair"]
    unless_null $P929, vivify_368
    new $P929, "Undef"
  vivify_368:
    $P930 = $P929."ast"()
    $P931 = $P927."!make"($P930)
    .return ($P931)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("58_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_933
    .param pmc param_934
.annotate 'line', 307
    .lex "self", param_933
    .lex "$/", param_934
    find_lex $P935, "$/"
    find_lex $P936, "$/"
    unless_null $P936, vivify_369
    $P936 = root_new ['parrot';'Hash']
  vivify_369:
    set $P937, $P936["variable"]
    unless_null $P937, vivify_370
    new $P937, "Undef"
  vivify_370:
    $P938 = $P937."ast"()
    $P939 = $P935."!make"($P938)
    .return ($P939)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("59_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_941
    .param pmc param_942
.annotate 'line', 308
    .lex "self", param_941
    .lex "$/", param_942
    find_lex $P943, "$/"
    find_lex $P944, "$/"
    unless_null $P944, vivify_371
    $P944 = root_new ['parrot';'Hash']
  vivify_371:
    set $P945, $P944["package_declarator"]
    unless_null $P945, vivify_372
    new $P945, "Undef"
  vivify_372:
    $P946 = $P945."ast"()
    $P947 = $P943."!make"($P946)
    .return ($P947)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("60_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_949
    .param pmc param_950
.annotate 'line', 309
    .lex "self", param_949
    .lex "$/", param_950
    find_lex $P951, "$/"
    find_lex $P952, "$/"
    unless_null $P952, vivify_373
    $P952 = root_new ['parrot';'Hash']
  vivify_373:
    set $P953, $P952["scope_declarator"]
    unless_null $P953, vivify_374
    new $P953, "Undef"
  vivify_374:
    $P954 = $P953."ast"()
    $P955 = $P951."!make"($P954)
    .return ($P955)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("61_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_957
    .param pmc param_958
.annotate 'line', 310
    .lex "self", param_957
    .lex "$/", param_958
    find_lex $P959, "$/"
    find_lex $P960, "$/"
    unless_null $P960, vivify_375
    $P960 = root_new ['parrot';'Hash']
  vivify_375:
    set $P961, $P960["routine_declarator"]
    unless_null $P961, vivify_376
    new $P961, "Undef"
  vivify_376:
    $P962 = $P961."ast"()
    $P963 = $P959."!make"($P962)
    .return ($P963)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("62_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_965
    .param pmc param_966
.annotate 'line', 311
    .lex "self", param_965
    .lex "$/", param_966
    find_lex $P967, "$/"
    find_lex $P968, "$/"
    unless_null $P968, vivify_377
    $P968 = root_new ['parrot';'Hash']
  vivify_377:
    set $P969, $P968["regex_declarator"]
    unless_null $P969, vivify_378
    new $P969, "Undef"
  vivify_378:
    $P970 = $P969."ast"()
    $P971 = $P967."!make"($P970)
    .return ($P971)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("63_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_973
    .param pmc param_974
.annotate 'line', 312
    .lex "self", param_973
    .lex "$/", param_974
    find_lex $P975, "$/"
    find_lex $P976, "$/"
    unless_null $P976, vivify_379
    $P976 = root_new ['parrot';'Hash']
  vivify_379:
    set $P977, $P976["statement_prefix"]
    unless_null $P977, vivify_380
    new $P977, "Undef"
  vivify_380:
    $P978 = $P977."ast"()
    $P979 = $P975."!make"($P978)
    .return ($P979)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("64_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_981
    .param pmc param_982
.annotate 'line', 313
    .lex "self", param_981
    .lex "$/", param_982
    find_lex $P983, "$/"
    find_lex $P984, "$/"
    unless_null $P984, vivify_381
    $P984 = root_new ['parrot';'Hash']
  vivify_381:
    set $P985, $P984["pblock"]
    unless_null $P985, vivify_382
    new $P985, "Undef"
  vivify_382:
    $P986 = $P985."ast"()
    $P987 = $P983."!make"($P986)
    .return ($P987)
.end


.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("65_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_989
    .param pmc param_990
.annotate 'line', 315
    .lex "self", param_989
    .lex "$/", param_990
.annotate 'line', 316
    new $P991, "Undef"
    .lex "$past", $P991
    find_lex $P992, "$/"
    unless_null $P992, vivify_383
    $P992 = root_new ['parrot';'Hash']
  vivify_383:
    set $P993, $P992["val"]
    unless_null $P993, vivify_384
    new $P993, "Undef"
  vivify_384:
    $P994 = $P993."ast"()
    store_lex "$past", $P994
.annotate 'line', 317
    find_lex $P995, "$past"
    find_lex $P996, "$/"
    unless_null $P996, vivify_385
    $P996 = root_new ['parrot';'Hash']
  vivify_385:
    set $P997, $P996["key"]
    unless_null $P997, vivify_386
    new $P997, "Undef"
  vivify_386:
    $P998 = $P997."Str"()
    $P995."named"($P998)
.annotate 'line', 318
    find_lex $P999, "$/"
    find_lex $P1000, "$past"
    $P1001 = $P999."!make"($P1000)
.annotate 'line', 315
    .return ($P1001)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("66_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1003
    .param pmc param_1004
.annotate 'line', 321
    .lex "self", param_1003
    .lex "$/", param_1004
.annotate 'line', 322
    new $P1005, "Undef"
    .lex "$past", $P1005
.annotate 'line', 323
    find_lex $P1008, "$/"
    unless_null $P1008, vivify_387
    $P1008 = root_new ['parrot';'Hash']
  vivify_387:
    set $P1009, $P1008["circumfix"]
    unless_null $P1009, vivify_388
    new $P1009, "Undef"
  vivify_388:
    if $P1009, if_1007
.annotate 'line', 324
    get_hll_global $P1014, ["PAST"], "Val"
    find_lex $P1015, "$/"
    unless_null $P1015, vivify_389
    $P1015 = root_new ['parrot';'Hash']
  vivify_389:
    set $P1016, $P1015["not"]
    unless_null $P1016, vivify_390
    new $P1016, "Undef"
  vivify_390:
    isfalse $I1017, $P1016
    $P1018 = $P1014."new"($I1017 :named("value"))
    set $P1006, $P1018
.annotate 'line', 323
    goto if_1007_end
  if_1007:
    find_lex $P1010, "$/"
    unless_null $P1010, vivify_391
    $P1010 = root_new ['parrot';'Hash']
  vivify_391:
    set $P1011, $P1010["circumfix"]
    unless_null $P1011, vivify_392
    $P1011 = root_new ['parrot';'ResizablePMCArray']
  vivify_392:
    set $P1012, $P1011[0]
    unless_null $P1012, vivify_393
    new $P1012, "Undef"
  vivify_393:
    $P1013 = $P1012."ast"()
    set $P1006, $P1013
  if_1007_end:
    store_lex "$past", $P1006
.annotate 'line', 325
    find_lex $P1019, "$past"
    find_lex $P1020, "$/"
    unless_null $P1020, vivify_394
    $P1020 = root_new ['parrot';'Hash']
  vivify_394:
    set $P1021, $P1020["identifier"]
    unless_null $P1021, vivify_395
    new $P1021, "Undef"
  vivify_395:
    set $S1022, $P1021
    $P1019."named"($S1022)
.annotate 'line', 326
    find_lex $P1023, "$/"
    find_lex $P1024, "$past"
    $P1025 = $P1023."!make"($P1024)
.annotate 'line', 321
    .return ($P1025)
.end


.namespace ["NQP";"Actions"]
.sub "variable"  :subid("67_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1027
    .param pmc param_1028
.annotate 'line', 329
    .const 'Sub' $P1041 = "68_1295994666.515" 
    capture_lex $P1041
    .lex "self", param_1027
    .lex "$/", param_1028
.annotate 'line', 330
    new $P1029, "Undef"
    .lex "$past", $P1029
.annotate 'line', 329
    find_lex $P1030, "$past"
.annotate 'line', 331
    find_lex $P1032, "$/"
    unless_null $P1032, vivify_396
    $P1032 = root_new ['parrot';'Hash']
  vivify_396:
    set $P1033, $P1032["postcircumfix"]
    unless_null $P1033, vivify_397
    new $P1033, "Undef"
  vivify_397:
    if $P1033, if_1031
.annotate 'line', 335
    .const 'Sub' $P1041 = "68_1295994666.515" 
    capture_lex $P1041
    $P1041()
    goto if_1031_end
  if_1031:
.annotate 'line', 332
    find_lex $P1034, "$/"
    unless_null $P1034, vivify_416
    $P1034 = root_new ['parrot';'Hash']
  vivify_416:
    set $P1035, $P1034["postcircumfix"]
    unless_null $P1035, vivify_417
    new $P1035, "Undef"
  vivify_417:
    $P1036 = $P1035."ast"()
    store_lex "$past", $P1036
.annotate 'line', 333
    find_lex $P1037, "$past"
    get_hll_global $P1038, ["PAST"], "Var"
    $P1039 = $P1038."new"("$/" :named("name"))
    $P1037."unshift"($P1039)
  if_1031_end:
.annotate 'line', 369
    find_lex $P1116, "$/"
    find_lex $P1117, "$past"
    $P1118 = $P1116."!make"($P1117)
.annotate 'line', 329
    .return ($P1118)
.end


.namespace ["NQP";"Actions"]
.sub "_block1040"  :anon :subid("68_1295994666.515") :outer("67_1295994666.515")
.annotate 'line', 336
    $P1042 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P1042
    get_hll_global $P1043, ["NQP"], "Compiler"
    find_lex $P1044, "$/"
    set $S1045, $P1044
    $P1046 = $P1043."parse_name"($S1045)
    store_lex "@name", $P1046
.annotate 'line', 337
    get_hll_global $P1047, ["PAST"], "Var"
    find_lex $P1048, "@name"
    $P1049 = $P1048."pop"()
    set $S1050, $P1049
    $P1051 = $P1047."new"($S1050 :named("name"))
    store_lex "$past", $P1051
.annotate 'line', 338
    find_lex $P1053, "@name"
    unless $P1053, if_1052_end
.annotate 'line', 339
    find_lex $P1055, "@name"
    unless_null $P1055, vivify_398
    $P1055 = root_new ['parrot';'ResizablePMCArray']
  vivify_398:
    set $P1056, $P1055[0]
    unless_null $P1056, vivify_399
    new $P1056, "Undef"
  vivify_399:
    set $S1057, $P1056
    iseq $I1058, $S1057, "GLOBAL"
    unless $I1058, if_1054_end
    find_lex $P1059, "@name"
    $P1059."shift"()
  if_1054_end:
.annotate 'line', 340
    find_lex $P1060, "$past"
    find_lex $P1061, "@name"
    $P1060."namespace"($P1061)
.annotate 'line', 341
    find_lex $P1062, "$past"
    $P1062."scope"("package")
.annotate 'line', 342
    find_lex $P1063, "$past"
    find_lex $P1064, "$/"
    unless_null $P1064, vivify_400
    $P1064 = root_new ['parrot';'Hash']
  vivify_400:
    set $P1065, $P1064["sigil"]
    unless_null $P1065, vivify_401
    new $P1065, "Undef"
  vivify_401:
    $P1066 = "vivitype"($P1065)
    $P1063."viviself"($P1066)
.annotate 'line', 343
    find_lex $P1067, "$past"
    $P1067."lvalue"(1)
  if_1052_end:
.annotate 'line', 345
    find_lex $P1070, "$/"
    unless_null $P1070, vivify_402
    $P1070 = root_new ['parrot';'Hash']
  vivify_402:
    set $P1071, $P1070["twigil"]
    unless_null $P1071, vivify_403
    $P1071 = root_new ['parrot';'ResizablePMCArray']
  vivify_403:
    set $P1072, $P1071[0]
    unless_null $P1072, vivify_404
    new $P1072, "Undef"
  vivify_404:
    set $S1073, $P1072
    iseq $I1074, $S1073, "*"
    if $I1074, if_1069
.annotate 'line', 358
    find_lex $P1096, "$/"
    unless_null $P1096, vivify_405
    $P1096 = root_new ['parrot';'Hash']
  vivify_405:
    set $P1097, $P1096["twigil"]
    unless_null $P1097, vivify_406
    $P1097 = root_new ['parrot';'ResizablePMCArray']
  vivify_406:
    set $P1098, $P1097[0]
    unless_null $P1098, vivify_407
    new $P1098, "Undef"
  vivify_407:
    set $S1099, $P1098
    iseq $I1100, $S1099, "!"
    if $I1100, if_1095
    new $P1094, 'Integer'
    set $P1094, $I1100
    goto if_1095_end
  if_1095:
.annotate 'line', 359
    find_lex $P1101, "$past"
    get_hll_global $P1102, ["PAST"], "Var"
    $P1103 = $P1102."new"("self" :named("name"))
    $P1101."push"($P1103)
.annotate 'line', 360
    find_lex $P1104, "$past"
    $P1104."scope"("attribute")
.annotate 'line', 361
    find_lex $P1105, "$past"
    find_lex $P1106, "$/"
    unless_null $P1106, vivify_408
    $P1106 = root_new ['parrot';'Hash']
  vivify_408:
    set $P1107, $P1106["sigil"]
    unless_null $P1107, vivify_409
    new $P1107, "Undef"
  vivify_409:
    $P1108 = "vivitype"($P1107)
    $P1105."viviself"($P1108)
.annotate 'line', 362
    find_dynamic_lex $P1111, "$*PACKAGE-SETUP"
    unless_null $P1111, vivify_410
    get_hll_global $P1111, "$PACKAGE-SETUP"
    unless_null $P1111, vivify_411
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_411:
  vivify_410:
    if $P1111, if_1110
    set $P1109, $P1111
    goto if_1110_end
  if_1110:
.annotate 'line', 365
    find_lex $P1112, "$past"
    get_hll_global $P1113, ["PAST"], "Var"
    $P1114 = $P1113."new"("$?CLASS" :named("name"))
    $P1115 = $P1112."push"($P1114)
.annotate 'line', 362
    set $P1109, $P1115
  if_1110_end:
.annotate 'line', 358
    set $P1094, $P1109
  if_1095_end:
    set $P1068, $P1094
.annotate 'line', 345
    goto if_1069_end
  if_1069:
.annotate 'line', 346
    find_lex $P1075, "$past"
    $P1075."scope"("contextual")
.annotate 'line', 347
    find_lex $P1076, "$past"
.annotate 'line', 348
    get_hll_global $P1077, ["PAST"], "Var"
.annotate 'line', 350
    find_lex $P1078, "$/"
    unless_null $P1078, vivify_412
    $P1078 = root_new ['parrot';'Hash']
  vivify_412:
    set $P1079, $P1078["sigil"]
    unless_null $P1079, vivify_413
    new $P1079, "Undef"
  vivify_413:
    set $S1080, $P1079
    new $P1081, 'String'
    set $P1081, $S1080
    find_lex $P1082, "$/"
    unless_null $P1082, vivify_414
    $P1082 = root_new ['parrot';'Hash']
  vivify_414:
    set $P1083, $P1082["desigilname"]
    unless_null $P1083, vivify_415
    new $P1083, "Undef"
  vivify_415:
    concat $P1084, $P1081, $P1083
.annotate 'line', 352
    get_hll_global $P1085, ["PAST"], "Op"
    new $P1086, "String"
    assign $P1086, "Contextual "
    find_lex $P1087, "$/"
    set $S1088, $P1087
    concat $P1089, $P1086, $S1088
    concat $P1090, $P1089, " not found"
    $P1091 = $P1085."new"($P1090, "die" :named("pirop"))
    $P1092 = $P1077."new"("package" :named("scope"), "" :named("namespace"), $P1084 :named("name"), $P1091 :named("viviself"))
.annotate 'line', 348
    $P1093 = $P1076."viviself"($P1092)
.annotate 'line', 345
    set $P1068, $P1093
  if_1069_end:
.annotate 'line', 335
    .return ($P1068)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("69_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1120
    .param pmc param_1121
.annotate 'line', 372
    .lex "self", param_1120
    .lex "$/", param_1121
    find_lex $P1122, "$/"
    find_lex $P1123, "$/"
    unless_null $P1123, vivify_418
    $P1123 = root_new ['parrot';'Hash']
  vivify_418:
    set $P1124, $P1123["package_def"]
    unless_null $P1124, vivify_419
    new $P1124, "Undef"
  vivify_419:
    $P1125 = $P1124."ast"()
    $P1126 = $P1122."!make"($P1125)
    .return ($P1126)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("70_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1128
    .param pmc param_1129
.annotate 'line', 373
    .lex "self", param_1128
    .lex "$/", param_1129
    find_lex $P1130, "$/"
    find_lex $P1131, "$/"
    $P1132 = "package"($P1131)
    $P1133 = $P1130."!make"($P1132)
    .return ($P1133)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("71_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1135
    .param pmc param_1136
.annotate 'line', 374
    .lex "self", param_1135
    .lex "$/", param_1136
    find_lex $P1137, "$/"
    find_lex $P1138, "$/"
    $P1139 = "package"($P1138)
    $P1140 = $P1137."!make"($P1139)
    .return ($P1140)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("72_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1142
    .param pmc param_1143
.annotate 'line', 375
    .lex "self", param_1142
    .lex "$/", param_1143
    find_lex $P1144, "$/"
    find_lex $P1145, "$/"
    $P1146 = "package"($P1145)
    $P1147 = $P1144."!make"($P1146)
    .return ($P1147)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("73_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1149
    .param pmc param_1150
.annotate 'line', 376
    .lex "self", param_1149
    .lex "$/", param_1150
    find_lex $P1151, "$/"
    find_lex $P1152, "$/"
    $P1153 = "package"($P1152)
    $P1154 = $P1151."!make"($P1153)
    .return ($P1154)
.end


.namespace ["NQP";"Actions"]
.sub "package_def"  :subid("74_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1157
    .param pmc param_1158
.annotate 'line', 463
    .lex "self", param_1157
    .lex "$/", param_1158
.annotate 'line', 464
    new $P1159, "Undef"
    .lex "$past", $P1159
    find_lex $P1162, "$/"
    unless_null $P1162, vivify_420
    $P1162 = root_new ['parrot';'Hash']
  vivify_420:
    set $P1163, $P1162["block"]
    unless_null $P1163, vivify_421
    new $P1163, "Undef"
  vivify_421:
    if $P1163, if_1161
    find_lex $P1167, "$/"
    unless_null $P1167, vivify_422
    $P1167 = root_new ['parrot';'Hash']
  vivify_422:
    set $P1168, $P1167["comp_unit"]
    unless_null $P1168, vivify_423
    new $P1168, "Undef"
  vivify_423:
    $P1169 = $P1168."ast"()
    set $P1160, $P1169
    goto if_1161_end
  if_1161:
    find_lex $P1164, "$/"
    unless_null $P1164, vivify_424
    $P1164 = root_new ['parrot';'Hash']
  vivify_424:
    set $P1165, $P1164["block"]
    unless_null $P1165, vivify_425
    new $P1165, "Undef"
  vivify_425:
    $P1166 = $P1165."ast"()
    set $P1160, $P1166
  if_1161_end:
    store_lex "$past", $P1160
.annotate 'line', 465
    find_lex $P1170, "$past"
    find_lex $P1171, "$/"
    unless_null $P1171, vivify_426
    $P1171 = root_new ['parrot';'Hash']
  vivify_426:
    set $P1172, $P1171["name"]
    unless_null $P1172, vivify_427
    $P1172 = root_new ['parrot';'Hash']
  vivify_427:
    set $P1173, $P1172["identifier"]
    unless_null $P1173, vivify_428
    new $P1173, "Undef"
  vivify_428:
    $P1170."namespace"($P1173)
.annotate 'line', 466
    find_lex $P1174, "$past"
    $P1174."blocktype"("immediate")
.annotate 'line', 467
    find_lex $P1175, "$/"
    find_lex $P1176, "$past"
    $P1177 = $P1175."!make"($P1176)
.annotate 'line', 463
    .return ($P1177)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("75_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1179
    .param pmc param_1180
.annotate 'line', 470
    .lex "self", param_1179
    .lex "$/", param_1180
    find_lex $P1181, "$/"
    find_lex $P1182, "$/"
    unless_null $P1182, vivify_429
    $P1182 = root_new ['parrot';'Hash']
  vivify_429:
    set $P1183, $P1182["scoped"]
    unless_null $P1183, vivify_430
    new $P1183, "Undef"
  vivify_430:
    $P1184 = $P1183."ast"()
    $P1185 = $P1181."!make"($P1184)
    .return ($P1185)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("76_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1187
    .param pmc param_1188
.annotate 'line', 471
    .lex "self", param_1187
    .lex "$/", param_1188
    find_lex $P1189, "$/"
    find_lex $P1190, "$/"
    unless_null $P1190, vivify_431
    $P1190 = root_new ['parrot';'Hash']
  vivify_431:
    set $P1191, $P1190["scoped"]
    unless_null $P1191, vivify_432
    new $P1191, "Undef"
  vivify_432:
    $P1192 = $P1191."ast"()
    $P1193 = $P1189."!make"($P1192)
    .return ($P1193)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("77_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1195
    .param pmc param_1196
.annotate 'line', 472
    .lex "self", param_1195
    .lex "$/", param_1196
    find_lex $P1197, "$/"
    find_lex $P1198, "$/"
    unless_null $P1198, vivify_433
    $P1198 = root_new ['parrot';'Hash']
  vivify_433:
    set $P1199, $P1198["scoped"]
    unless_null $P1199, vivify_434
    new $P1199, "Undef"
  vivify_434:
    $P1200 = $P1199."ast"()
    $P1201 = $P1197."!make"($P1200)
    .return ($P1201)
.end


.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("78_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1203
    .param pmc param_1204
.annotate 'line', 474
    .lex "self", param_1203
    .lex "$/", param_1204
.annotate 'line', 475
    find_lex $P1205, "$/"
.annotate 'line', 476
    find_lex $P1208, "$/"
    unless_null $P1208, vivify_435
    $P1208 = root_new ['parrot';'Hash']
  vivify_435:
    set $P1209, $P1208["declarator"]
    unless_null $P1209, vivify_436
    new $P1209, "Undef"
  vivify_436:
    if $P1209, if_1207
.annotate 'line', 477
    find_lex $P1213, "$/"
    unless_null $P1213, vivify_437
    $P1213 = root_new ['parrot';'Hash']
  vivify_437:
    set $P1214, $P1213["multi_declarator"]
    unless_null $P1214, vivify_438
    new $P1214, "Undef"
  vivify_438:
    $P1215 = $P1214."ast"()
    set $P1206, $P1215
.annotate 'line', 476
    goto if_1207_end
  if_1207:
    find_lex $P1210, "$/"
    unless_null $P1210, vivify_439
    $P1210 = root_new ['parrot';'Hash']
  vivify_439:
    set $P1211, $P1210["declarator"]
    unless_null $P1211, vivify_440
    new $P1211, "Undef"
  vivify_440:
    $P1212 = $P1211."ast"()
    set $P1206, $P1212
  if_1207_end:
    $P1216 = $P1205."!make"($P1206)
.annotate 'line', 474
    .return ($P1216)
.end


.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("79_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1218
    .param pmc param_1219
.annotate 'line', 480
    .lex "self", param_1218
    .lex "$/", param_1219
.annotate 'line', 481
    find_lex $P1220, "$/"
.annotate 'line', 482
    find_lex $P1223, "$/"
    unless_null $P1223, vivify_441
    $P1223 = root_new ['parrot';'Hash']
  vivify_441:
    set $P1224, $P1223["routine_declarator"]
    unless_null $P1224, vivify_442
    new $P1224, "Undef"
  vivify_442:
    if $P1224, if_1222
.annotate 'line', 483
    find_lex $P1228, "$/"
    unless_null $P1228, vivify_443
    $P1228 = root_new ['parrot';'Hash']
  vivify_443:
    set $P1229, $P1228["variable_declarator"]
    unless_null $P1229, vivify_444
    new $P1229, "Undef"
  vivify_444:
    $P1230 = $P1229."ast"()
    set $P1221, $P1230
.annotate 'line', 482
    goto if_1222_end
  if_1222:
    find_lex $P1225, "$/"
    unless_null $P1225, vivify_445
    $P1225 = root_new ['parrot';'Hash']
  vivify_445:
    set $P1226, $P1225["routine_declarator"]
    unless_null $P1226, vivify_446
    new $P1226, "Undef"
  vivify_446:
    $P1227 = $P1226."ast"()
    set $P1221, $P1227
  if_1222_end:
    $P1231 = $P1220."!make"($P1221)
.annotate 'line', 480
    .return ($P1231)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("80_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1233
    .param pmc param_1234
.annotate 'line', 486
    .lex "self", param_1233
    .lex "$/", param_1234
    find_lex $P1235, "$/"
    find_lex $P1238, "$/"
    unless_null $P1238, vivify_447
    $P1238 = root_new ['parrot';'Hash']
  vivify_447:
    set $P1239, $P1238["declarator"]
    unless_null $P1239, vivify_448
    new $P1239, "Undef"
  vivify_448:
    if $P1239, if_1237
    find_lex $P1243, "$/"
    unless_null $P1243, vivify_449
    $P1243 = root_new ['parrot';'Hash']
  vivify_449:
    set $P1244, $P1243["routine_def"]
    unless_null $P1244, vivify_450
    new $P1244, "Undef"
  vivify_450:
    $P1245 = $P1244."ast"()
    set $P1236, $P1245
    goto if_1237_end
  if_1237:
    find_lex $P1240, "$/"
    unless_null $P1240, vivify_451
    $P1240 = root_new ['parrot';'Hash']
  vivify_451:
    set $P1241, $P1240["declarator"]
    unless_null $P1241, vivify_452
    new $P1241, "Undef"
  vivify_452:
    $P1242 = $P1241."ast"()
    set $P1236, $P1242
  if_1237_end:
    $P1246 = $P1235."!make"($P1236)
    .return ($P1246)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("81_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1248
    .param pmc param_1249
.annotate 'line', 487
    .lex "self", param_1248
    .lex "$/", param_1249
    find_lex $P1250, "$/"
    find_lex $P1253, "$/"
    unless_null $P1253, vivify_453
    $P1253 = root_new ['parrot';'Hash']
  vivify_453:
    set $P1254, $P1253["declarator"]
    unless_null $P1254, vivify_454
    new $P1254, "Undef"
  vivify_454:
    if $P1254, if_1252
    find_lex $P1258, "$/"
    unless_null $P1258, vivify_455
    $P1258 = root_new ['parrot';'Hash']
  vivify_455:
    set $P1259, $P1258["routine_def"]
    unless_null $P1259, vivify_456
    new $P1259, "Undef"
  vivify_456:
    $P1260 = $P1259."ast"()
    set $P1251, $P1260
    goto if_1252_end
  if_1252:
    find_lex $P1255, "$/"
    unless_null $P1255, vivify_457
    $P1255 = root_new ['parrot';'Hash']
  vivify_457:
    set $P1256, $P1255["declarator"]
    unless_null $P1256, vivify_458
    new $P1256, "Undef"
  vivify_458:
    $P1257 = $P1256."ast"()
    set $P1251, $P1257
  if_1252_end:
    $P1261 = $P1250."!make"($P1251)
    .return ($P1261)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("82_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1263
    .param pmc param_1264
.annotate 'line', 488
    .lex "self", param_1263
    .lex "$/", param_1264
    find_lex $P1265, "$/"
    find_lex $P1266, "$/"
    unless_null $P1266, vivify_459
    $P1266 = root_new ['parrot';'Hash']
  vivify_459:
    set $P1267, $P1266["declarator"]
    unless_null $P1267, vivify_460
    new $P1267, "Undef"
  vivify_460:
    $P1268 = $P1267."ast"()
    $P1269 = $P1265."!make"($P1268)
    .return ($P1269)
.end


.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("83_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1271
    .param pmc param_1272
.annotate 'line', 491
    .const 'Sub' $P1341 = "85_1295994666.515" 
    capture_lex $P1341
    .const 'Sub' $P1303 = "84_1295994666.515" 
    capture_lex $P1303
    .lex "self", param_1271
    .lex "$/", param_1272
.annotate 'line', 492
    new $P1273, "Undef"
    .lex "$past", $P1273
.annotate 'line', 493
    new $P1274, "Undef"
    .lex "$sigil", $P1274
.annotate 'line', 494
    new $P1275, "Undef"
    .lex "$name", $P1275
.annotate 'line', 495
    new $P1276, "Undef"
    .lex "$BLOCK", $P1276
.annotate 'line', 492
    find_lex $P1277, "$/"
    unless_null $P1277, vivify_461
    $P1277 = root_new ['parrot';'Hash']
  vivify_461:
    set $P1278, $P1277["variable"]
    unless_null $P1278, vivify_462
    new $P1278, "Undef"
  vivify_462:
    $P1279 = $P1278."ast"()
    store_lex "$past", $P1279
.annotate 'line', 493
    find_lex $P1280, "$/"
    unless_null $P1280, vivify_463
    $P1280 = root_new ['parrot';'Hash']
  vivify_463:
    set $P1281, $P1280["variable"]
    unless_null $P1281, vivify_464
    $P1281 = root_new ['parrot';'Hash']
  vivify_464:
    set $P1282, $P1281["sigil"]
    unless_null $P1282, vivify_465
    new $P1282, "Undef"
  vivify_465:
    store_lex "$sigil", $P1282
.annotate 'line', 494
    find_lex $P1283, "$past"
    $P1284 = $P1283."name"()
    store_lex "$name", $P1284
.annotate 'line', 495
    get_global $P1285, "@BLOCK"
    unless_null $P1285, vivify_466
    $P1285 = root_new ['parrot';'ResizablePMCArray']
  vivify_466:
    set $P1286, $P1285[0]
    unless_null $P1286, vivify_467
    new $P1286, "Undef"
  vivify_467:
    store_lex "$BLOCK", $P1286
.annotate 'line', 496
    find_lex $P1288, "$BLOCK"
    find_lex $P1289, "$name"
    $P1290 = $P1288."symbol"($P1289)
    unless $P1290, if_1287_end
.annotate 'line', 497
    find_lex $P1291, "$/"
    $P1292 = $P1291."CURSOR"()
    find_lex $P1293, "$name"
    $P1292."panic"("Redeclaration of symbol ", $P1293)
  if_1287_end:
.annotate 'line', 499
    find_dynamic_lex $P1295, "$*SCOPE"
    unless_null $P1295, vivify_468
    get_hll_global $P1295, "$SCOPE"
    unless_null $P1295, vivify_469
    die "Contextual $*SCOPE not found"
  vivify_469:
  vivify_468:
    set $S1296, $P1295
    iseq $I1297, $S1296, "has"
    if $I1297, if_1294
.annotate 'line', 528
    .const 'Sub' $P1341 = "85_1295994666.515" 
    capture_lex $P1341
    $P1341()
    goto if_1294_end
  if_1294:
.annotate 'line', 500
    find_lex $P1298, "$BLOCK"
    find_lex $P1299, "$name"
    $P1298."symbol"($P1299, "attribute" :named("scope"))
.annotate 'line', 501
    find_dynamic_lex $P1301, "$*PACKAGE-SETUP"
    unless_null $P1301, vivify_474
    get_hll_global $P1301, "$PACKAGE-SETUP"
    unless_null $P1301, vivify_475
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_475:
  vivify_474:
    if $P1301, if_1300
.annotate 'line', 520
    find_lex $P1330, "$BLOCK"
    unless_null $P1330, vivify_476
    $P1330 = root_new ['parrot';'Hash']
  vivify_476:
    set $P1331, $P1330["attributes"]
    unless_null $P1331, vivify_477
    new $P1331, "Undef"
  vivify_477:
    if $P1331, unless_1329_end
.annotate 'line', 522
    get_hll_global $P1332, ["PAST"], "Op"
    $P1333 = $P1332."new"("list" :named("pasttype"), "attr" :named("named"))
    find_lex $P1334, "$BLOCK"
    unless_null $P1334, vivify_478
    $P1334 = root_new ['parrot';'Hash']
    store_lex "$BLOCK", $P1334
  vivify_478:
    set $P1334["attributes"], $P1333
  unless_1329_end:
.annotate 'line', 524
    find_lex $P1335, "$BLOCK"
    unless_null $P1335, vivify_479
    $P1335 = root_new ['parrot';'Hash']
  vivify_479:
    set $P1336, $P1335["attributes"]
    unless_null $P1336, vivify_480
    new $P1336, "Undef"
  vivify_480:
    find_lex $P1337, "$name"
    $P1336."push"($P1337)
.annotate 'line', 518
    goto if_1300_end
  if_1300:
.annotate 'line', 501
    .const 'Sub' $P1303 = "84_1295994666.515" 
    capture_lex $P1303
    $P1303()
  if_1300_end:
.annotate 'line', 526
    get_hll_global $P1338, ["PAST"], "Stmts"
    $P1339 = $P1338."new"()
    store_lex "$past", $P1339
  if_1294_end:
.annotate 'line', 536
    find_lex $P1365, "$/"
    find_lex $P1366, "$past"
    $P1367 = $P1365."!make"($P1366)
.annotate 'line', 491
    .return ($P1367)
.end


.namespace ["NQP";"Actions"]
.sub "_block1340"  :anon :subid("85_1295994666.515") :outer("83_1295994666.515")
.annotate 'line', 529
    new $P1342, "Undef"
    .lex "$scope", $P1342
.annotate 'line', 530
    new $P1343, "Undef"
    .lex "$decl", $P1343
.annotate 'line', 529
    find_dynamic_lex $P1346, "$*SCOPE"
    unless_null $P1346, vivify_470
    get_hll_global $P1346, "$SCOPE"
    unless_null $P1346, vivify_471
    die "Contextual $*SCOPE not found"
  vivify_471:
  vivify_470:
    set $S1347, $P1346
    iseq $I1348, $S1347, "our"
    if $I1348, if_1345
    new $P1350, "String"
    assign $P1350, "lexical"
    set $P1344, $P1350
    goto if_1345_end
  if_1345:
    new $P1349, "String"
    assign $P1349, "package"
    set $P1344, $P1349
  if_1345_end:
    store_lex "$scope", $P1344
.annotate 'line', 530
    get_hll_global $P1351, ["PAST"], "Var"
    find_lex $P1352, "$name"
    find_lex $P1353, "$scope"
.annotate 'line', 531
    find_lex $P1354, "$sigil"
    $P1355 = "vivitype"($P1354)
    find_lex $P1356, "$/"
    $P1357 = $P1351."new"($P1352 :named("name"), $P1353 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1355 :named("viviself"), $P1356 :named("node"))
.annotate 'line', 530
    store_lex "$decl", $P1357
.annotate 'line', 533
    find_lex $P1358, "$BLOCK"
    find_lex $P1359, "$name"
    find_lex $P1360, "$scope"
    $P1358."symbol"($P1359, $P1360 :named("scope"))
.annotate 'line', 534
    find_lex $P1361, "$BLOCK"
    unless_null $P1361, vivify_472
    $P1361 = root_new ['parrot';'ResizablePMCArray']
  vivify_472:
    set $P1362, $P1361[0]
    unless_null $P1362, vivify_473
    new $P1362, "Undef"
  vivify_473:
    find_lex $P1363, "$decl"
    $P1364 = $P1362."push"($P1363)
.annotate 'line', 528
    .return ($P1364)
.end


.namespace ["NQP";"Actions"]
.sub "_block1302"  :anon :subid("84_1295994666.515") :outer("83_1295994666.515")
.annotate 'line', 503
    new $P1304, "Undef"
    .lex "$meta-attr-type", $P1304
    find_dynamic_lex $P1307, "$*PKGDECL"
    unless_null $P1307, vivify_481
    get_hll_global $P1307, "$PKGDECL"
    unless_null $P1307, vivify_482
    die "Contextual $*PKGDECL not found"
  vivify_482:
  vivify_481:
    find_dynamic_lex $P1308, "%*HOW-METAATTR"
    unless_null $P1308, vivify_483
    get_hll_global $P1308, "%HOW-METAATTR"
    unless_null $P1308, vivify_484
    die "Contextual %*HOW-METAATTR not found"
  vivify_484:
  vivify_483:
    set $P1309, $P1308[$P1307]
    unless_null $P1309, vivify_485
    new $P1309, "Undef"
  vivify_485:
    unless $P1309, unless_1306
    set $P1305, $P1309
    goto unless_1306_end
  unless_1306:
    find_dynamic_lex $P1310, "$*DEFAULT-METAATTR"
    unless_null $P1310, vivify_486
    get_hll_global $P1310, "$DEFAULT-METAATTR"
    unless_null $P1310, vivify_487
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_487:
  vivify_486:
    set $P1305, $P1310
  unless_1306_end:
    store_lex "$meta-attr-type", $P1305
.annotate 'line', 504
    find_dynamic_lex $P1311, "$*PACKAGE-SETUP"
    unless_null $P1311, vivify_488
    get_hll_global $P1311, "$PACKAGE-SETUP"
    unless_null $P1311, vivify_489
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_489:
  vivify_488:
    get_hll_global $P1312, ["PAST"], "Op"
.annotate 'line', 506
    get_hll_global $P1313, ["PAST"], "Op"
.annotate 'line', 508
    get_hll_global $P1314, ["PAST"], "Var"
    $P1315 = $P1314."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1316 = $P1313."new"($P1315, "get_how PP" :named("pirop"))
.annotate 'line', 510
    get_hll_global $P1317, ["PAST"], "Var"
    $P1318 = $P1317."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 511
    get_hll_global $P1319, ["PAST"], "Op"
.annotate 'line', 513
    get_hll_global $P1320, ["PAST"], "Var"
    find_lex $P1321, "$meta-attr-type"
    $P1322 = $P1320."new"($P1321 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 514
    get_hll_global $P1323, ["PAST"], "Val"
    find_lex $P1324, "$name"
    $P1325 = $P1323."new"($P1324 :named("value"), "name" :named("named"))
    $P1326 = $P1319."new"($P1322, $P1325, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 511
    $P1327 = $P1312."new"($P1316, $P1318, $P1326, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 504
    $P1328 = $P1311."push"($P1327)
.annotate 'line', 501
    .return ($P1328)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("86_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1369
    .param pmc param_1370
.annotate 'line', 539
    .lex "self", param_1369
    .lex "$/", param_1370
    find_lex $P1371, "$/"
    find_lex $P1372, "$/"
    unless_null $P1372, vivify_490
    $P1372 = root_new ['parrot';'Hash']
  vivify_490:
    set $P1373, $P1372["routine_def"]
    unless_null $P1373, vivify_491
    new $P1373, "Undef"
  vivify_491:
    $P1374 = $P1373."ast"()
    $P1375 = $P1371."!make"($P1374)
    .return ($P1375)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("87_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1377
    .param pmc param_1378
.annotate 'line', 540
    .lex "self", param_1377
    .lex "$/", param_1378
    find_lex $P1379, "$/"
    find_lex $P1380, "$/"
    unless_null $P1380, vivify_492
    $P1380 = root_new ['parrot';'Hash']
  vivify_492:
    set $P1381, $P1380["method_def"]
    unless_null $P1381, vivify_493
    new $P1381, "Undef"
  vivify_493:
    $P1382 = $P1381."ast"()
    $P1383 = $P1379."!make"($P1382)
    .return ($P1383)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("88_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1385
    .param pmc param_1386
.annotate 'line', 542
    .const 'Sub' $P1614 = "94_1295994666.515" 
    capture_lex $P1614
    .const 'Sub' $P1406 = "89_1295994666.515" 
    capture_lex $P1406
    .lex "self", param_1385
    .lex "$/", param_1386
.annotate 'line', 545
    new $P1387, "Undef"
    .lex "$past", $P1387
.annotate 'line', 556
    new $P1388, "Undef"
    .lex "$block", $P1388
.annotate 'line', 542
    find_lex $P1389, "$past"
.annotate 'line', 546
    find_lex $P1391, "$/"
    unless_null $P1391, vivify_494
    $P1391 = root_new ['parrot';'Hash']
  vivify_494:
    set $P1392, $P1391["onlystar"]
    unless_null $P1392, vivify_495
    new $P1392, "Undef"
  vivify_495:
    if $P1392, if_1390
.annotate 'line', 550
    find_lex $P1394, "$/"
    unless_null $P1394, vivify_496
    $P1394 = root_new ['parrot';'Hash']
  vivify_496:
    set $P1395, $P1394["blockoid"]
    unless_null $P1395, vivify_497
    new $P1395, "Undef"
  vivify_497:
    $P1396 = $P1395."ast"()
    store_lex "$past", $P1396
.annotate 'line', 551
    find_lex $P1397, "$past"
    $P1397."blocktype"("declaration")
.annotate 'line', 552
    find_dynamic_lex $P1399, "$*RETURN_USED"
    unless_null $P1399, vivify_498
    get_hll_global $P1399, "$RETURN_USED"
    unless_null $P1399, vivify_499
    die "Contextual $*RETURN_USED not found"
  vivify_499:
  vivify_498:
    unless $P1399, if_1398_end
.annotate 'line', 553
    find_lex $P1400, "$past"
    $P1400."control"("return_pir")
  if_1398_end:
.annotate 'line', 549
    goto if_1390_end
  if_1390:
.annotate 'line', 547
    $P1393 = "only_star_block"()
    store_lex "$past", $P1393
  if_1390_end:
.annotate 'line', 556
    find_lex $P1401, "$past"
    store_lex "$block", $P1401
.annotate 'line', 558
    find_lex $P1403, "$/"
    unless_null $P1403, vivify_500
    $P1403 = root_new ['parrot';'Hash']
  vivify_500:
    set $P1404, $P1403["deflongname"]
    unless_null $P1404, vivify_501
    new $P1404, "Undef"
  vivify_501:
    unless $P1404, if_1402_end
    .const 'Sub' $P1406 = "89_1295994666.515" 
    capture_lex $P1406
    $P1406()
  if_1402_end:
.annotate 'line', 658
    find_lex $P1603, "$block"
    find_lex $P1604, "$past"
    unless_null $P1604, vivify_562
    $P1604 = root_new ['parrot';'Hash']
    store_lex "$past", $P1604
  vivify_562:
    set $P1604["block_past"], $P1603
.annotate 'line', 659
    find_lex $P1606, "$/"
    unless_null $P1606, vivify_563
    $P1606 = root_new ['parrot';'Hash']
  vivify_563:
    set $P1607, $P1606["trait"]
    unless_null $P1607, vivify_564
    new $P1607, "Undef"
  vivify_564:
    unless $P1607, if_1605_end
.annotate 'line', 660
    find_lex $P1609, "$/"
    unless_null $P1609, vivify_565
    $P1609 = root_new ['parrot';'Hash']
  vivify_565:
    set $P1610, $P1609["trait"]
    unless_null $P1610, vivify_566
    new $P1610, "Undef"
  vivify_566:
    defined $I1611, $P1610
    unless $I1611, for_undef_567
    iter $P1608, $P1610
    new $P1621, 'ExceptionHandler'
    set_addr $P1621, loop1620_handler
    $P1621."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1621
  loop1620_test:
    unless $P1608, loop1620_done
    shift $P1612, $P1608
  loop1620_redo:
    .const 'Sub' $P1614 = "94_1295994666.515" 
    capture_lex $P1614
    $P1614($P1612)
  loop1620_next:
    goto loop1620_test
  loop1620_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1622, exception, 'type'
    eq $P1622, .CONTROL_LOOP_NEXT, loop1620_next
    eq $P1622, .CONTROL_LOOP_REDO, loop1620_redo
  loop1620_done:
    pop_eh 
  for_undef_567:
  if_1605_end:
.annotate 'line', 663
    find_lex $P1623, "$/"
    find_lex $P1624, "$past"
    $P1625 = $P1623."!make"($P1624)
.annotate 'line', 542
    .return ($P1625)
.end


.namespace ["NQP";"Actions"]
.sub "_block1405"  :anon :subid("89_1295994666.515") :outer("88_1295994666.515")
.annotate 'line', 558
    .const 'Sub' $P1529 = "93_1295994666.515" 
    capture_lex $P1529
    .const 'Sub' $P1440 = "90_1295994666.515" 
    capture_lex $P1440
.annotate 'line', 559
    new $P1407, "Undef"
    .lex "$name", $P1407
    find_lex $P1408, "$/"
    unless_null $P1408, vivify_502
    $P1408 = root_new ['parrot';'Hash']
  vivify_502:
    set $P1409, $P1408["sigil"]
    unless_null $P1409, vivify_503
    $P1409 = root_new ['parrot';'ResizablePMCArray']
  vivify_503:
    set $P1410, $P1409[0]
    unless_null $P1410, vivify_504
    new $P1410, "Undef"
  vivify_504:
    set $S1411, $P1410
    new $P1412, 'String'
    set $P1412, $S1411
    find_lex $P1413, "$/"
    unless_null $P1413, vivify_505
    $P1413 = root_new ['parrot';'Hash']
  vivify_505:
    set $P1414, $P1413["deflongname"]
    unless_null $P1414, vivify_506
    $P1414 = root_new ['parrot';'ResizablePMCArray']
  vivify_506:
    set $P1415, $P1414[0]
    unless_null $P1415, vivify_507
    new $P1415, "Undef"
  vivify_507:
    $S1416 = $P1415."ast"()
    concat $P1417, $P1412, $S1416
    store_lex "$name", $P1417
.annotate 'line', 560
    find_lex $P1418, "$past"
    find_lex $P1419, "$name"
    $P1418."name"($P1419)
.annotate 'line', 561
    find_dynamic_lex $P1426, "$*SCOPE"
    unless_null $P1426, vivify_508
    get_hll_global $P1426, "$SCOPE"
    unless_null $P1426, vivify_509
    die "Contextual $*SCOPE not found"
  vivify_509:
  vivify_508:
    set $S1427, $P1426
    iseq $I1428, $S1427, ""
    unless $I1428, unless_1425
    new $P1424, 'Integer'
    set $P1424, $I1428
    goto unless_1425_end
  unless_1425:
    find_dynamic_lex $P1429, "$*SCOPE"
    unless_null $P1429, vivify_510
    get_hll_global $P1429, "$SCOPE"
    unless_null $P1429, vivify_511
    die "Contextual $*SCOPE not found"
  vivify_511:
  vivify_510:
    set $S1430, $P1429
    iseq $I1431, $S1430, "my"
    new $P1424, 'Integer'
    set $P1424, $I1431
  unless_1425_end:
    unless $P1424, unless_1423
    set $P1422, $P1424
    goto unless_1423_end
  unless_1423:
    find_dynamic_lex $P1432, "$*SCOPE"
    unless_null $P1432, vivify_512
    get_hll_global $P1432, "$SCOPE"
    unless_null $P1432, vivify_513
    die "Contextual $*SCOPE not found"
  vivify_513:
  vivify_512:
    set $S1433, $P1432
    iseq $I1434, $S1433, "our"
    new $P1422, 'Integer'
    set $P1422, $I1434
  unless_1423_end:
    if $P1422, if_1421
.annotate 'line', 653
    find_lex $P1598, "$/"
    $P1599 = $P1598."CURSOR"()
    find_dynamic_lex $P1600, "$*SCOPE"
    unless_null $P1600, vivify_514
    get_hll_global $P1600, "$SCOPE"
    unless_null $P1600, vivify_515
    die "Contextual $*SCOPE not found"
  vivify_515:
  vivify_514:
    concat $P1601, $P1600, " scoped routines are not supported yet"
    $P1602 = $P1599."panic"($P1601)
.annotate 'line', 652
    set $P1420, $P1602
.annotate 'line', 561
    goto if_1421_end
  if_1421:
.annotate 'line', 562
    find_dynamic_lex $P1436, "$*MULTINESS"
    unless_null $P1436, vivify_516
    get_hll_global $P1436, "$MULTINESS"
    unless_null $P1436, vivify_517
    die "Contextual $*MULTINESS not found"
  vivify_517:
  vivify_516:
    set $S1437, $P1436
    iseq $I1438, $S1437, "multi"
    if $I1438, if_1435
.annotate 'line', 613
    find_dynamic_lex $P1525, "$*MULTINESS"
    unless_null $P1525, vivify_518
    get_hll_global $P1525, "$MULTINESS"
    unless_null $P1525, vivify_519
    die "Contextual $*MULTINESS not found"
  vivify_519:
  vivify_518:
    set $S1526, $P1525
    iseq $I1527, $S1526, "proto"
    if $I1527, if_1524
.annotate 'line', 632
    get_global $P1559, "@BLOCK"
    unless_null $P1559, vivify_520
    $P1559 = root_new ['parrot';'ResizablePMCArray']
  vivify_520:
    set $P1560, $P1559[0]
    unless_null $P1560, vivify_521
    $P1560 = root_new ['parrot';'ResizablePMCArray']
  vivify_521:
    set $P1561, $P1560[0]
    unless_null $P1561, vivify_522
    new $P1561, "Undef"
  vivify_522:
    get_hll_global $P1562, ["PAST"], "Var"
    find_lex $P1563, "$name"
    find_lex $P1564, "$past"
    $P1565 = $P1562."new"($P1563 :named("name"), 1 :named("isdecl"), $P1564 :named("viviself"), "lexical" :named("scope"))
    $P1561."push"($P1565)
.annotate 'line', 634
    get_global $P1566, "@BLOCK"
    unless_null $P1566, vivify_523
    $P1566 = root_new ['parrot';'ResizablePMCArray']
  vivify_523:
    set $P1567, $P1566[0]
    unless_null $P1567, vivify_524
    new $P1567, "Undef"
  vivify_524:
    find_lex $P1568, "$name"
    $P1567."symbol"($P1568, "lexical" :named("scope"))
.annotate 'line', 635
    find_dynamic_lex $P1570, "$*SCOPE"
    unless_null $P1570, vivify_525
    get_hll_global $P1570, "$SCOPE"
    unless_null $P1570, vivify_526
    die "Contextual $*SCOPE not found"
  vivify_526:
  vivify_525:
    set $S1571, $P1570
    iseq $I1572, $S1571, "our"
    unless $I1572, if_1569_end
.annotate 'line', 638
    get_global $P1573, "@BLOCK"
    unless_null $P1573, vivify_527
    $P1573 = root_new ['parrot';'ResizablePMCArray']
  vivify_527:
    set $P1574, $P1573[0]
    unless_null $P1574, vivify_528
    $P1574 = root_new ['parrot';'ResizablePMCArray']
  vivify_528:
    set $P1575, $P1574[0]
    unless_null $P1575, vivify_529
    new $P1575, "Undef"
  vivify_529:
    get_hll_global $P1576, ["PAST"], "Op"
.annotate 'line', 640
    get_hll_global $P1577, ["PAST"], "Var"
    find_lex $P1578, "$name"
    $P1579 = $P1577."new"($P1578 :named("name"), "package" :named("scope"))
.annotate 'line', 641
    get_hll_global $P1580, ["PAST"], "Var"
    find_lex $P1581, "$name"
    $P1582 = $P1580."new"($P1581 :named("name"), "lexical" :named("scope"))
    $P1583 = $P1576."new"($P1579, $P1582, "bind" :named("pasttype"))
.annotate 'line', 638
    $P1575."push"($P1583)
.annotate 'line', 643
    get_global $P1584, "@BLOCK"
    unless_null $P1584, vivify_530
    $P1584 = root_new ['parrot';'ResizablePMCArray']
  vivify_530:
    set $P1585, $P1584[0]
    unless_null $P1585, vivify_531
    new $P1585, "Undef"
  vivify_531:
    $P1586 = $P1585."loadinit"()
    get_hll_global $P1587, ["PAST"], "Op"
.annotate 'line', 645
    get_hll_global $P1588, ["PAST"], "Var"
    find_lex $P1589, "$name"
    $P1590 = $P1588."new"($P1589 :named("name"), "package" :named("scope"))
.annotate 'line', 646
    get_hll_global $P1591, ["PAST"], "Val"
    find_lex $P1592, "$past"
    $P1593 = $P1591."new"($P1592 :named("value"))
    $P1594 = $P1587."new"($P1590, $P1593, "bind" :named("pasttype"))
.annotate 'line', 643
    $P1586."push"($P1594)
  if_1569_end:
.annotate 'line', 631
    goto if_1524_end
  if_1524:
.annotate 'line', 613
    .const 'Sub' $P1529 = "93_1295994666.515" 
    capture_lex $P1529
    $P1529()
  if_1524_end:
    goto if_1435_end
  if_1435:
.annotate 'line', 562
    .const 'Sub' $P1440 = "90_1295994666.515" 
    capture_lex $P1440
    $P1440()
  if_1435_end:
.annotate 'line', 650
    get_hll_global $P1595, ["PAST"], "Var"
    find_lex $P1596, "$name"
    $P1597 = $P1595."new"($P1596 :named("name"))
    store_lex "$past", $P1597
.annotate 'line', 561
    set $P1420, $P1597
  if_1421_end:
.annotate 'line', 558
    .return ($P1420)
.end


.namespace ["NQP";"Actions"]
.sub "_block1528"  :anon :subid("93_1295994666.515") :outer("89_1295994666.515")
.annotate 'line', 618
    new $P1530, "Undef"
    .lex "$cholder", $P1530
.annotate 'line', 617
    find_dynamic_lex $P1532, "$*SCOPE"
    unless_null $P1532, vivify_532
    get_hll_global $P1532, "$SCOPE"
    unless_null $P1532, vivify_533
    die "Contextual $*SCOPE not found"
  vivify_533:
  vivify_532:
    set $S1533, $P1532
    iseq $I1534, $S1533, "our"
    unless $I1534, if_1531_end
    die "our-scoped protos not yet implemented"
  if_1531_end:
.annotate 'line', 618
    get_hll_global $P1535, ["PAST"], "Op"
    $P1536 = $P1535."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1536
.annotate 'line', 619
    get_global $P1537, "@BLOCK"
    unless_null $P1537, vivify_534
    $P1537 = root_new ['parrot';'ResizablePMCArray']
  vivify_534:
    set $P1538, $P1537[0]
    unless_null $P1538, vivify_535
    $P1538 = root_new ['parrot';'ResizablePMCArray']
  vivify_535:
    set $P1539, $P1538[0]
    unless_null $P1539, vivify_536
    new $P1539, "Undef"
  vivify_536:
    get_hll_global $P1540, ["PAST"], "Var"
    find_lex $P1541, "$name"
    find_lex $P1542, "$past"
    $P1543 = $P1540."new"($P1541 :named("name"), 1 :named("isdecl"), $P1542 :named("viviself"), "lexical" :named("scope"))
    $P1539."push"($P1543)
.annotate 'line', 621
    get_global $P1544, "@BLOCK"
    unless_null $P1544, vivify_537
    $P1544 = root_new ['parrot';'ResizablePMCArray']
  vivify_537:
    set $P1545, $P1544[0]
    unless_null $P1545, vivify_538
    $P1545 = root_new ['parrot';'ResizablePMCArray']
  vivify_538:
    set $P1546, $P1545[0]
    unless_null $P1546, vivify_539
    new $P1546, "Undef"
  vivify_539:
    get_hll_global $P1547, ["PAST"], "Op"
.annotate 'line', 623
    get_hll_global $P1548, ["PAST"], "Var"
    find_lex $P1549, "$name"
    $P1550 = $P1548."new"($P1549 :named("name"))
    find_lex $P1551, "$cholder"
    $P1552 = $P1547."new"($P1550, $P1551, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 621
    $P1546."push"($P1552)
.annotate 'line', 626
    get_global $P1553, "@BLOCK"
    unless_null $P1553, vivify_540
    $P1553 = root_new ['parrot';'ResizablePMCArray']
  vivify_540:
    set $P1554, $P1553[0]
    unless_null $P1554, vivify_541
    new $P1554, "Undef"
  vivify_541:
    find_lex $P1555, "$name"
    find_lex $P1556, "$cholder"
    $P1554."symbol"($P1555, "lexical" :named("scope"), 1 :named("proto"), $P1556 :named("cholder"))
.annotate 'line', 629
    find_lex $P1557, "$past"
    $P1558 = $P1557."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 613
    .return ($P1558)
.end


.namespace ["NQP";"Actions"]
.sub "_block1439"  :anon :subid("90_1295994666.515") :outer("89_1295994666.515")
.annotate 'line', 562
    .const 'Sub' $P1458 = "91_1295994666.515" 
    capture_lex $P1458
.annotate 'line', 565
    new $P1441, "Undef"
    .lex "$cholder", $P1441
.annotate 'line', 566
    $P1442 = root_new ['parrot';'Hash']
    .lex "%sym", $P1442
.annotate 'line', 564
    find_dynamic_lex $P1444, "$*SCOPE"
    unless_null $P1444, vivify_542
    get_hll_global $P1444, "$SCOPE"
    unless_null $P1444, vivify_543
    die "Contextual $*SCOPE not found"
  vivify_543:
  vivify_542:
    set $S1445, $P1444
    iseq $I1446, $S1445, "our"
    unless $I1446, if_1443_end
    die "our-scoped multis not yet implemented"
  if_1443_end:
    find_lex $P1447, "$cholder"
.annotate 'line', 566
    get_global $P1448, "@BLOCK"
    unless_null $P1448, vivify_544
    $P1448 = root_new ['parrot';'ResizablePMCArray']
  vivify_544:
    set $P1449, $P1448[0]
    unless_null $P1449, vivify_545
    new $P1449, "Undef"
  vivify_545:
    find_lex $P1450, "$name"
    $P1451 = $P1449."symbol"($P1450)
    store_lex "%sym", $P1451
.annotate 'line', 567
    find_lex $P1453, "%sym"
    unless_null $P1453, vivify_546
    $P1453 = root_new ['parrot';'Hash']
  vivify_546:
    set $P1454, $P1453["cholder"]
    unless_null $P1454, vivify_547
    new $P1454, "Undef"
  vivify_547:
    if $P1454, if_1452
.annotate 'line', 572
    .const 'Sub' $P1458 = "91_1295994666.515" 
    capture_lex $P1458
    $P1458()
    goto if_1452_end
  if_1452:
.annotate 'line', 568
    find_lex $P1455, "%sym"
    unless_null $P1455, vivify_560
    $P1455 = root_new ['parrot';'Hash']
  vivify_560:
    set $P1456, $P1455["cholder"]
    unless_null $P1456, vivify_561
    new $P1456, "Undef"
  vivify_561:
    store_lex "$cholder", $P1456
  if_1452_end:
.annotate 'line', 608
    find_lex $P1520, "$cholder"
    find_lex $P1521, "$past"
    $P1520."push"($P1521)
.annotate 'line', 611
    find_lex $P1522, "$past"
    $P1523 = "attach_multi_signature"($P1522)
.annotate 'line', 562
    .return ($P1523)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1457"  :anon :subid("91_1295994666.515") :outer("90_1295994666.515")
.annotate 'line', 572
    .const 'Sub' $P1472 = "92_1295994666.515" 
    capture_lex $P1472
.annotate 'line', 579
    new $P1459, "Undef"
    .lex "$found_proto", $P1459
.annotate 'line', 597
    new $P1460, "Undef"
    .lex "$dispatch_setup", $P1460
.annotate 'line', 574
    find_lex $P1462, "%sym"
    unless_null $P1462, vivify_548
    $P1462 = root_new ['parrot';'Hash']
  vivify_548:
    set $P1463, $P1462["proto"]
    unless_null $P1463, vivify_549
    new $P1463, "Undef"
  vivify_549:
    unless $P1463, if_1461_end
.annotate 'line', 577
    find_lex $P1464, "$/"
    $P1465 = $P1464."CURSOR"()
    $P1465."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1461_end:
.annotate 'line', 574
    find_lex $P1466, "$found_proto"
.annotate 'line', 580
    get_global $P1468, "@BLOCK"
    defined $I1469, $P1468
    unless $I1469, for_undef_550
    iter $P1467, $P1468
    new $P1494, 'ExceptionHandler'
    set_addr $P1494, loop1493_handler
    $P1494."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1494
  loop1493_test:
    unless $P1467, loop1493_done
    shift $P1470, $P1467
  loop1493_redo:
    .const 'Sub' $P1472 = "92_1295994666.515" 
    capture_lex $P1472
    $P1472($P1470)
  loop1493_next:
    goto loop1493_test
  loop1493_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1495, exception, 'type'
    eq $P1495, .CONTROL_LOOP_NEXT, loop1493_next
    eq $P1495, .CONTROL_LOOP_REDO, loop1493_redo
  loop1493_done:
    pop_eh 
  for_undef_550:
.annotate 'line', 591
    find_lex $P1497, "$found_proto"
    if $P1497, unless_1496_end
.annotate 'line', 592
    find_lex $P1498, "$/"
    $P1499 = $P1498."CURSOR"()
    $P1499."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1496_end:
.annotate 'line', 596
    get_hll_global $P1500, ["PAST"], "Op"
    $P1501 = $P1500."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1501
.annotate 'line', 597
    get_hll_global $P1502, ["PAST"], "Op"
.annotate 'line', 599
    get_hll_global $P1503, ["PAST"], "Var"
    find_lex $P1504, "$name"
    $P1505 = $P1503."new"($P1504 :named("name"), "outer" :named("scope"))
    find_lex $P1506, "$cholder"
    $P1507 = $P1502."new"($P1505, $P1506, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 597
    store_lex "$dispatch_setup", $P1507
.annotate 'line', 602
    get_global $P1508, "@BLOCK"
    unless_null $P1508, vivify_555
    $P1508 = root_new ['parrot';'ResizablePMCArray']
  vivify_555:
    set $P1509, $P1508[0]
    unless_null $P1509, vivify_556
    $P1509 = root_new ['parrot';'ResizablePMCArray']
  vivify_556:
    set $P1510, $P1509[0]
    unless_null $P1510, vivify_557
    new $P1510, "Undef"
  vivify_557:
    get_hll_global $P1511, ["PAST"], "Var"
    find_lex $P1512, "$name"
    find_lex $P1513, "$dispatch_setup"
    $P1514 = $P1511."new"($P1512 :named("name"), 1 :named("isdecl"), $P1513 :named("viviself"), "lexical" :named("scope"))
    $P1510."push"($P1514)
.annotate 'line', 604
    get_global $P1515, "@BLOCK"
    unless_null $P1515, vivify_558
    $P1515 = root_new ['parrot';'ResizablePMCArray']
  vivify_558:
    set $P1516, $P1515[0]
    unless_null $P1516, vivify_559
    new $P1516, "Undef"
  vivify_559:
    find_lex $P1517, "$name"
    find_lex $P1518, "$cholder"
    $P1519 = $P1516."symbol"($P1517, "lexical" :named("scope"), $P1518 :named("cholder"))
.annotate 'line', 572
    .return ($P1519)
.end


.namespace ["NQP";"Actions"]
.sub "_block1471"  :anon :subid("92_1295994666.515") :outer("91_1295994666.515")
    .param pmc param_1474
.annotate 'line', 581
    $P1473 = root_new ['parrot';'Hash']
    .lex "%sym", $P1473
    .lex "$_", param_1474
    find_lex $P1475, "$_"
    find_lex $P1476, "$name"
    $P1477 = $P1475."symbol"($P1476)
    store_lex "%sym", $P1477
.annotate 'line', 582
    find_lex $P1482, "%sym"
    unless_null $P1482, vivify_551
    $P1482 = root_new ['parrot';'Hash']
  vivify_551:
    set $P1483, $P1482["proto"]
    unless_null $P1483, vivify_552
    new $P1483, "Undef"
  vivify_552:
    unless $P1483, unless_1481
    set $P1480, $P1483
    goto unless_1481_end
  unless_1481:
    find_lex $P1484, "%sym"
    unless_null $P1484, vivify_553
    $P1484 = root_new ['parrot';'Hash']
  vivify_553:
    set $P1485, $P1484["cholder"]
    unless_null $P1485, vivify_554
    new $P1485, "Undef"
  vivify_554:
    set $P1480, $P1485
  unless_1481_end:
    if $P1480, if_1479
.annotate 'line', 585
    find_lex $P1489, "%sym"
    if $P1489, if_1488
    set $P1487, $P1489
    goto if_1488_end
  if_1488:
.annotate 'line', 586
    find_lex $P1490, "$/"
    $P1491 = $P1490."CURSOR"()
    $P1492 = $P1491."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 585
    set $P1487, $P1492
  if_1488_end:
    set $P1478, $P1487
.annotate 'line', 582
    goto if_1479_end
  if_1479:
.annotate 'line', 583
    new $P1486, "Integer"
    assign $P1486, 1
    store_lex "$found_proto", $P1486
.annotate 'line', 582
    set $P1478, $P1486
  if_1479_end:
.annotate 'line', 580
    .return ($P1478)
.end


.namespace ["NQP";"Actions"]
.sub "_block1613"  :anon :subid("94_1295994666.515") :outer("88_1295994666.515")
    .param pmc param_1615
.annotate 'line', 660
    .lex "$_", param_1615
    find_lex $P1616, "$_"
    $P1617 = $P1616."ast"()
    find_lex $P1618, "$/"
    $P1619 = $P1617($P1618)
    .return ($P1619)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("95_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1627
    .param pmc param_1628
.annotate 'line', 667
    .const 'Sub' $P1737 = "97_1295994666.515" 
    capture_lex $P1737
    .const 'Sub' $P1656 = "96_1295994666.515" 
    capture_lex $P1656
    .lex "self", param_1627
    .lex "$/", param_1628
.annotate 'line', 670
    new $P1629, "Undef"
    .lex "$past", $P1629
.annotate 'line', 667
    find_lex $P1630, "$past"
.annotate 'line', 671
    find_lex $P1632, "$/"
    unless_null $P1632, vivify_568
    $P1632 = root_new ['parrot';'Hash']
  vivify_568:
    set $P1633, $P1632["onlystar"]
    unless_null $P1633, vivify_569
    new $P1633, "Undef"
  vivify_569:
    if $P1633, if_1631
.annotate 'line', 675
    find_lex $P1635, "$/"
    unless_null $P1635, vivify_570
    $P1635 = root_new ['parrot';'Hash']
  vivify_570:
    set $P1636, $P1635["blockoid"]
    unless_null $P1636, vivify_571
    new $P1636, "Undef"
  vivify_571:
    $P1637 = $P1636."ast"()
    store_lex "$past", $P1637
.annotate 'line', 676
    find_lex $P1638, "$past"
    $P1638."blocktype"("declaration")
.annotate 'line', 677
    find_dynamic_lex $P1640, "$*RETURN_USED"
    unless_null $P1640, vivify_572
    get_hll_global $P1640, "$RETURN_USED"
    unless_null $P1640, vivify_573
    die "Contextual $*RETURN_USED not found"
  vivify_573:
  vivify_572:
    unless $P1640, if_1639_end
.annotate 'line', 678
    find_lex $P1641, "$past"
    $P1641."control"("return_pir")
  if_1639_end:
.annotate 'line', 674
    goto if_1631_end
  if_1631:
.annotate 'line', 672
    $P1634 = "only_star_block"()
    store_lex "$past", $P1634
  if_1631_end:
.annotate 'line', 683
    find_lex $P1643, "$past"
    unless_null $P1643, vivify_574
    $P1643 = root_new ['parrot';'Hash']
  vivify_574:
    set $P1644, $P1643["signature_has_invocant"]
    unless_null $P1644, vivify_575
    new $P1644, "Undef"
  vivify_575:
    if $P1644, unless_1642_end
.annotate 'line', 684
    find_lex $P1645, "$past"
    unless_null $P1645, vivify_576
    $P1645 = root_new ['parrot';'ResizablePMCArray']
  vivify_576:
    set $P1646, $P1645[0]
    unless_null $P1646, vivify_577
    new $P1646, "Undef"
  vivify_577:
    get_hll_global $P1647, ["PAST"], "Var"
.annotate 'line', 686
    get_hll_global $P1648, ["PAST"], "Var"
    $P1649 = $P1648."new"("$?CLASS" :named("name"), "package" :named("scope"))
    $P1650 = $P1647."new"("self" :named("name"), "parameter" :named("scope"), $P1649 :named("multitype"))
.annotate 'line', 684
    $P1646."unshift"($P1650)
  unless_1642_end:
.annotate 'line', 689
    find_lex $P1651, "$past"
    $P1651."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 692
    find_lex $P1653, "$/"
    unless_null $P1653, vivify_578
    $P1653 = root_new ['parrot';'Hash']
  vivify_578:
    set $P1654, $P1653["deflongname"]
    unless_null $P1654, vivify_579
    new $P1654, "Undef"
  vivify_579:
    unless $P1654, if_1652_end
    .const 'Sub' $P1656 = "96_1295994666.515" 
    capture_lex $P1656
    $P1656()
  if_1652_end:
.annotate 'line', 727
    find_dynamic_lex $P1722, "$*SCOPE"
    unless_null $P1722, vivify_597
    get_hll_global $P1722, "$SCOPE"
    unless_null $P1722, vivify_598
    die "Contextual $*SCOPE not found"
  vivify_598:
  vivify_597:
    set $S1723, $P1722
    iseq $I1724, $S1723, "our"
    unless $I1724, if_1721_end
.annotate 'line', 728
    find_lex $P1725, "$past"
    $P1725."pirflags"(":nsentry")
  if_1721_end:
.annotate 'line', 732
    find_lex $P1726, "$past"
    find_lex $P1727, "$past"
    unless_null $P1727, vivify_599
    $P1727 = root_new ['parrot';'Hash']
    store_lex "$past", $P1727
  vivify_599:
    set $P1727["block_past"], $P1726
.annotate 'line', 733
    find_lex $P1729, "$/"
    unless_null $P1729, vivify_600
    $P1729 = root_new ['parrot';'Hash']
  vivify_600:
    set $P1730, $P1729["trait"]
    unless_null $P1730, vivify_601
    new $P1730, "Undef"
  vivify_601:
    unless $P1730, if_1728_end
.annotate 'line', 734
    find_lex $P1732, "$/"
    unless_null $P1732, vivify_602
    $P1732 = root_new ['parrot';'Hash']
  vivify_602:
    set $P1733, $P1732["trait"]
    unless_null $P1733, vivify_603
    new $P1733, "Undef"
  vivify_603:
    defined $I1734, $P1733
    unless $I1734, for_undef_604
    iter $P1731, $P1733
    new $P1744, 'ExceptionHandler'
    set_addr $P1744, loop1743_handler
    $P1744."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1744
  loop1743_test:
    unless $P1731, loop1743_done
    shift $P1735, $P1731
  loop1743_redo:
    .const 'Sub' $P1737 = "97_1295994666.515" 
    capture_lex $P1737
    $P1737($P1735)
  loop1743_next:
    goto loop1743_test
  loop1743_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1745, exception, 'type'
    eq $P1745, .CONTROL_LOOP_NEXT, loop1743_next
    eq $P1745, .CONTROL_LOOP_REDO, loop1743_redo
  loop1743_done:
    pop_eh 
  for_undef_604:
  if_1728_end:
.annotate 'line', 737
    find_lex $P1746, "$/"
    find_lex $P1747, "$past"
    $P1748 = $P1746."!make"($P1747)
.annotate 'line', 667
    .return ($P1748)
.end


.namespace ["NQP";"Actions"]
.sub "_block1655"  :anon :subid("96_1295994666.515") :outer("95_1295994666.515")
.annotate 'line', 694
    new $P1657, "Undef"
    .lex "$name", $P1657
.annotate 'line', 699
    new $P1658, "Undef"
    .lex "$to_add", $P1658
.annotate 'line', 694
    find_lex $P1659, "$/"
    unless_null $P1659, vivify_580
    $P1659 = root_new ['parrot';'Hash']
  vivify_580:
    set $P1660, $P1659["private"]
    unless_null $P1660, vivify_581
    new $P1660, "Undef"
  vivify_581:
    set $S1661, $P1660
    new $P1662, 'String'
    set $P1662, $S1661
    find_lex $P1663, "$/"
    unless_null $P1663, vivify_582
    $P1663 = root_new ['parrot';'Hash']
  vivify_582:
    set $P1664, $P1663["deflongname"]
    unless_null $P1664, vivify_583
    $P1664 = root_new ['parrot';'ResizablePMCArray']
  vivify_583:
    set $P1665, $P1664[0]
    unless_null $P1665, vivify_584
    new $P1665, "Undef"
  vivify_584:
    $P1666 = $P1665."ast"()
    set $S1667, $P1666
    concat $P1668, $P1662, $S1667
    store_lex "$name", $P1668
.annotate 'line', 695
    find_lex $P1669, "$past"
    find_lex $P1670, "$name"
    $P1669."name"($P1670)
.annotate 'line', 699
    find_dynamic_lex $P1673, "$*MULTINESS"
    unless_null $P1673, vivify_585
    get_hll_global $P1673, "$MULTINESS"
    unless_null $P1673, vivify_586
    die "Contextual $*MULTINESS not found"
  vivify_586:
  vivify_585:
    set $S1674, $P1673
    isne $I1675, $S1674, "proto"
    if $I1675, if_1672
.annotate 'line', 701
    get_hll_global $P1679, ["PAST"], "Op"
.annotate 'line', 703
    get_hll_global $P1680, ["PAST"], "Val"
    find_lex $P1681, "$past"
    $P1682 = $P1680."new"($P1681 :named("value"))
.annotate 'line', 704
    get_hll_global $P1683, ["PAST"], "Op"
    $P1684 = $P1683."new"("list" :named("pasttype"))
    $P1685 = $P1679."new"($P1682, $P1684, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 701
    set $P1671, $P1685
.annotate 'line', 699
    goto if_1672_end
  if_1672:
.annotate 'line', 700
    get_hll_global $P1676, ["PAST"], "Val"
    find_lex $P1677, "$past"
    $P1678 = $P1676."new"($P1677 :named("value"))
    set $P1671, $P1678
  if_1672_end:
.annotate 'line', 699
    store_lex "$to_add", $P1671
.annotate 'line', 706
    find_dynamic_lex $P1687, "$*MULTINESS"
    unless_null $P1687, vivify_587
    get_hll_global $P1687, "$MULTINESS"
    unless_null $P1687, vivify_588
    die "Contextual $*MULTINESS not found"
  vivify_588:
  vivify_587:
    set $S1688, $P1687
    iseq $I1689, $S1688, "proto"
    unless $I1689, if_1686_end
    find_lex $P1690, "$past"
    $P1690."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1686_end:
.annotate 'line', 710
    find_dynamic_lex $P1692, "$*MULTINESS"
    unless_null $P1692, vivify_589
    get_hll_global $P1692, "$MULTINESS"
    unless_null $P1692, vivify_590
    die "Contextual $*MULTINESS not found"
  vivify_590:
  vivify_589:
    set $S1693, $P1692
    iseq $I1694, $S1693, "multi"
    unless $I1694, if_1691_end
    find_lex $P1695, "$past"
    "attach_multi_signature"($P1695)
  if_1691_end:
.annotate 'line', 713
    find_dynamic_lex $P1698, "$*PACKAGE-SETUP"
    unless_null $P1698, vivify_591
    get_hll_global $P1698, "$PACKAGE-SETUP"
    unless_null $P1698, vivify_592
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_592:
  vivify_591:
    defined $I1699, $P1698
    if $I1699, if_1697
    new $P1696, 'Integer'
    set $P1696, $I1699
    goto if_1697_end
  if_1697:
.annotate 'line', 714
    find_dynamic_lex $P1700, "$*PACKAGE-SETUP"
    unless_null $P1700, vivify_593
    get_hll_global $P1700, "$PACKAGE-SETUP"
    unless_null $P1700, vivify_594
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_594:
  vivify_593:
    get_hll_global $P1701, ["PAST"], "Op"
.annotate 'line', 715
    find_dynamic_lex $P1704, "$*MULTINESS"
    unless_null $P1704, vivify_595
    get_hll_global $P1704, "$MULTINESS"
    unless_null $P1704, vivify_596
    die "Contextual $*MULTINESS not found"
  vivify_596:
  vivify_595:
    set $S1705, $P1704
    iseq $I1706, $S1705, "multi"
    if $I1706, if_1703
    new $P1708, "String"
    assign $P1708, "add_method"
    set $P1702, $P1708
    goto if_1703_end
  if_1703:
    new $P1707, "String"
    assign $P1707, "add_multi_method"
    set $P1702, $P1707
  if_1703_end:
.annotate 'line', 716
    get_hll_global $P1709, ["PAST"], "Op"
.annotate 'line', 719
    get_hll_global $P1710, ["PAST"], "Var"
    $P1711 = $P1710."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1712 = $P1709."new"($P1711, "get_how PP" :named("pirop"))
.annotate 'line', 721
    get_hll_global $P1713, ["PAST"], "Var"
    $P1714 = $P1713."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 722
    get_hll_global $P1715, ["PAST"], "Val"
    find_lex $P1716, "$name"
    $P1717 = $P1715."new"($P1716 :named("value"))
    find_lex $P1718, "$to_add"
    $P1719 = $P1701."new"($P1712, $P1714, $P1717, $P1718, "callmethod" :named("pasttype"), $P1702 :named("name"))
.annotate 'line', 714
    $P1720 = $P1700."push"($P1719)
.annotate 'line', 713
    set $P1696, $P1720
  if_1697_end:
.annotate 'line', 692
    .return ($P1696)
.end


.namespace ["NQP";"Actions"]
.sub "_block1736"  :anon :subid("97_1295994666.515") :outer("95_1295994666.515")
    .param pmc param_1738
.annotate 'line', 734
    .lex "$_", param_1738
    find_lex $P1739, "$_"
    $P1740 = $P1739."ast"()
    find_lex $P1741, "$/"
    $P1742 = $P1740($P1741)
    .return ($P1742)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("98_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1752
    .param pmc param_1753
.annotate 'line', 768
    .const 'Sub' $P1786 = "100_1295994666.515" 
    capture_lex $P1786
    .const 'Sub' $P1762 = "99_1295994666.515" 
    capture_lex $P1762
    .lex "self", param_1752
    .lex "$/", param_1753
.annotate 'line', 769
    new $P1754, "Undef"
    .lex "$BLOCKINIT", $P1754
    get_global $P1755, "@BLOCK"
    unless_null $P1755, vivify_605
    $P1755 = root_new ['parrot';'ResizablePMCArray']
  vivify_605:
    set $P1756, $P1755[0]
    unless_null $P1756, vivify_606
    $P1756 = root_new ['parrot';'ResizablePMCArray']
  vivify_606:
    set $P1757, $P1756[0]
    unless_null $P1757, vivify_607
    new $P1757, "Undef"
  vivify_607:
    store_lex "$BLOCKINIT", $P1757
.annotate 'line', 770
    find_lex $P1759, "$/"
    unless_null $P1759, vivify_608
    $P1759 = root_new ['parrot';'Hash']
  vivify_608:
    set $P1760, $P1759["invocant"]
    unless_null $P1760, vivify_609
    new $P1760, "Undef"
  vivify_609:
    unless $P1760, if_1758_end
    .const 'Sub' $P1762 = "99_1295994666.515" 
    capture_lex $P1762
    $P1762()
  if_1758_end:
.annotate 'line', 779
    find_lex $P1781, "$/"
    unless_null $P1781, vivify_615
    $P1781 = root_new ['parrot';'Hash']
  vivify_615:
    set $P1782, $P1781["parameter"]
    unless_null $P1782, vivify_616
    new $P1782, "Undef"
  vivify_616:
    defined $I1783, $P1782
    unless $I1783, for_undef_617
    iter $P1780, $P1782
    new $P1793, 'ExceptionHandler'
    set_addr $P1793, loop1792_handler
    $P1793."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1793
  loop1792_test:
    unless $P1780, loop1792_done
    shift $P1784, $P1780
  loop1792_redo:
    .const 'Sub' $P1786 = "100_1295994666.515" 
    capture_lex $P1786
    $P1786($P1784)
  loop1792_next:
    goto loop1792_test
  loop1792_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1794, exception, 'type'
    eq $P1794, .CONTROL_LOOP_NEXT, loop1792_next
    eq $P1794, .CONTROL_LOOP_REDO, loop1792_redo
  loop1792_done:
    pop_eh 
  for_undef_617:
.annotate 'line', 768
    .return ($P1780)
.end


.namespace ["NQP";"Actions"]
.sub "_block1761"  :anon :subid("99_1295994666.515") :outer("98_1295994666.515")
.annotate 'line', 771
    new $P1763, "Undef"
    .lex "$inv", $P1763
    find_lex $P1764, "$/"
    unless_null $P1764, vivify_610
    $P1764 = root_new ['parrot';'Hash']
  vivify_610:
    set $P1765, $P1764["invocant"]
    unless_null $P1765, vivify_611
    $P1765 = root_new ['parrot';'ResizablePMCArray']
  vivify_611:
    set $P1766, $P1765[0]
    unless_null $P1766, vivify_612
    new $P1766, "Undef"
  vivify_612:
    $P1767 = $P1766."ast"()
    store_lex "$inv", $P1767
.annotate 'line', 772
    find_lex $P1768, "$BLOCKINIT"
    find_lex $P1769, "$inv"
    $P1768."push"($P1769)
.annotate 'line', 773
    find_lex $P1770, "$BLOCKINIT"
    get_hll_global $P1771, ["PAST"], "Var"
.annotate 'line', 775
    get_hll_global $P1772, ["PAST"], "Var"
    find_lex $P1773, "$inv"
    $P1774 = $P1773."name"()
    $P1775 = $P1772."new"("lexical" :named("scope"), $P1774 :named("name"))
    $P1776 = $P1771."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1775 :named("viviself"))
.annotate 'line', 773
    $P1770."push"($P1776)
.annotate 'line', 777
    new $P1777, "Integer"
    assign $P1777, 1
    get_global $P1778, "@BLOCK"
    unless_null $P1778, vivify_613
    $P1778 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1778
  vivify_613:
    set $P1779, $P1778[0]
    unless_null $P1779, vivify_614
    $P1779 = root_new ['parrot';'Hash']
    set $P1778[0], $P1779
  vivify_614:
    set $P1779["signature_has_invocant"], $P1777
.annotate 'line', 770
    .return ($P1777)
.end


.namespace ["NQP";"Actions"]
.sub "_block1785"  :anon :subid("100_1295994666.515") :outer("98_1295994666.515")
    .param pmc param_1787
.annotate 'line', 779
    .lex "$_", param_1787
    find_lex $P1788, "$BLOCKINIT"
    find_lex $P1789, "$_"
    $P1790 = $P1789."ast"()
    $P1791 = $P1788."push"($P1790)
    .return ($P1791)
.end


.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("101_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1796
    .param pmc param_1797
.annotate 'line', 782
    .lex "self", param_1796
    .lex "$/", param_1797
.annotate 'line', 783
    new $P1798, "Undef"
    .lex "$quant", $P1798
.annotate 'line', 784
    new $P1799, "Undef"
    .lex "$past", $P1799
.annotate 'line', 783
    find_lex $P1800, "$/"
    unless_null $P1800, vivify_618
    $P1800 = root_new ['parrot';'Hash']
  vivify_618:
    set $P1801, $P1800["quant"]
    unless_null $P1801, vivify_619
    new $P1801, "Undef"
  vivify_619:
    store_lex "$quant", $P1801
    find_lex $P1802, "$past"
.annotate 'line', 785
    find_lex $P1804, "$/"
    unless_null $P1804, vivify_620
    $P1804 = root_new ['parrot';'Hash']
  vivify_620:
    set $P1805, $P1804["named_param"]
    unless_null $P1805, vivify_621
    new $P1805, "Undef"
  vivify_621:
    if $P1805, if_1803
.annotate 'line', 792
    find_lex $P1819, "$/"
    unless_null $P1819, vivify_622
    $P1819 = root_new ['parrot';'Hash']
  vivify_622:
    set $P1820, $P1819["param_var"]
    unless_null $P1820, vivify_623
    new $P1820, "Undef"
  vivify_623:
    $P1821 = $P1820."ast"()
    store_lex "$past", $P1821
.annotate 'line', 793
    find_lex $P1823, "$quant"
    set $S1824, $P1823
    iseq $I1825, $S1824, "*"
    if $I1825, if_1822
.annotate 'line', 797
    find_lex $P1834, "$quant"
    set $S1835, $P1834
    iseq $I1836, $S1835, "?"
    unless $I1836, if_1833_end
.annotate 'line', 798
    find_lex $P1837, "$past"
    find_lex $P1838, "$/"
    unless_null $P1838, vivify_624
    $P1838 = root_new ['parrot';'Hash']
  vivify_624:
    set $P1839, $P1838["param_var"]
    unless_null $P1839, vivify_625
    $P1839 = root_new ['parrot';'Hash']
  vivify_625:
    set $P1840, $P1839["sigil"]
    unless_null $P1840, vivify_626
    new $P1840, "Undef"
  vivify_626:
    $P1841 = "vivitype"($P1840)
    $P1837."viviself"($P1841)
  if_1833_end:
.annotate 'line', 797
    goto if_1822_end
  if_1822:
.annotate 'line', 794
    find_lex $P1826, "$past"
    $P1826."slurpy"(1)
.annotate 'line', 795
    find_lex $P1827, "$past"
    find_lex $P1828, "$/"
    unless_null $P1828, vivify_627
    $P1828 = root_new ['parrot';'Hash']
  vivify_627:
    set $P1829, $P1828["param_var"]
    unless_null $P1829, vivify_628
    $P1829 = root_new ['parrot';'Hash']
  vivify_628:
    set $P1830, $P1829["sigil"]
    unless_null $P1830, vivify_629
    new $P1830, "Undef"
  vivify_629:
    set $S1831, $P1830
    iseq $I1832, $S1831, "%"
    $P1827."named"($I1832)
  if_1822_end:
.annotate 'line', 791
    goto if_1803_end
  if_1803:
.annotate 'line', 786
    find_lex $P1806, "$/"
    unless_null $P1806, vivify_630
    $P1806 = root_new ['parrot';'Hash']
  vivify_630:
    set $P1807, $P1806["named_param"]
    unless_null $P1807, vivify_631
    new $P1807, "Undef"
  vivify_631:
    $P1808 = $P1807."ast"()
    store_lex "$past", $P1808
.annotate 'line', 787
    find_lex $P1810, "$quant"
    set $S1811, $P1810
    isne $I1812, $S1811, "!"
    unless $I1812, if_1809_end
.annotate 'line', 788
    find_lex $P1813, "$past"
    find_lex $P1814, "$/"
    unless_null $P1814, vivify_632
    $P1814 = root_new ['parrot';'Hash']
  vivify_632:
    set $P1815, $P1814["named_param"]
    unless_null $P1815, vivify_633
    $P1815 = root_new ['parrot';'Hash']
  vivify_633:
    set $P1816, $P1815["param_var"]
    unless_null $P1816, vivify_634
    $P1816 = root_new ['parrot';'Hash']
  vivify_634:
    set $P1817, $P1816["sigil"]
    unless_null $P1817, vivify_635
    new $P1817, "Undef"
  vivify_635:
    $P1818 = "vivitype"($P1817)
    $P1813."viviself"($P1818)
  if_1809_end:
  if_1803_end:
.annotate 'line', 801
    find_lex $P1843, "$/"
    unless_null $P1843, vivify_636
    $P1843 = root_new ['parrot';'Hash']
  vivify_636:
    set $P1844, $P1843["default_value"]
    unless_null $P1844, vivify_637
    new $P1844, "Undef"
  vivify_637:
    unless $P1844, if_1842_end
.annotate 'line', 802
    find_lex $P1846, "$quant"
    set $S1847, $P1846
    iseq $I1848, $S1847, "*"
    unless $I1848, if_1845_end
.annotate 'line', 803
    find_lex $P1849, "$/"
    $P1850 = $P1849."CURSOR"()
    $P1850."panic"("Can't put default on slurpy parameter")
  if_1845_end:
.annotate 'line', 805
    find_lex $P1852, "$quant"
    set $S1853, $P1852
    iseq $I1854, $S1853, "!"
    unless $I1854, if_1851_end
.annotate 'line', 806
    find_lex $P1855, "$/"
    $P1856 = $P1855."CURSOR"()
    $P1856."panic"("Can't put default on required parameter")
  if_1851_end:
.annotate 'line', 808
    find_lex $P1857, "$past"
    find_lex $P1858, "$/"
    unless_null $P1858, vivify_638
    $P1858 = root_new ['parrot';'Hash']
  vivify_638:
    set $P1859, $P1858["default_value"]
    unless_null $P1859, vivify_639
    $P1859 = root_new ['parrot';'ResizablePMCArray']
  vivify_639:
    set $P1860, $P1859[0]
    unless_null $P1860, vivify_640
    $P1860 = root_new ['parrot';'Hash']
  vivify_640:
    set $P1861, $P1860["EXPR"]
    unless_null $P1861, vivify_641
    new $P1861, "Undef"
  vivify_641:
    $P1862 = $P1861."ast"()
    $P1857."viviself"($P1862)
  if_1842_end:
.annotate 'line', 810
    find_lex $P1864, "$past"
    $P1865 = $P1864."viviself"()
    if $P1865, unless_1863_end
    get_global $P1866, "@BLOCK"
    unless_null $P1866, vivify_642
    $P1866 = root_new ['parrot';'ResizablePMCArray']
  vivify_642:
    set $P1867, $P1866[0]
    unless_null $P1867, vivify_643
    new $P1867, "Undef"
  vivify_643:
    get_global $P1868, "@BLOCK"
    unless_null $P1868, vivify_644
    $P1868 = root_new ['parrot';'ResizablePMCArray']
  vivify_644:
    set $P1869, $P1868[0]
    unless_null $P1869, vivify_645
    new $P1869, "Undef"
  vivify_645:
    $P1870 = $P1869."arity"()
    set $N1871, $P1870
    new $P1872, 'Float'
    set $P1872, $N1871
    add $P1873, $P1872, 1
    $P1867."arity"($P1873)
  unless_1863_end:
.annotate 'line', 814
    find_lex $P1875, "$/"
    unless_null $P1875, vivify_646
    $P1875 = root_new ['parrot';'Hash']
  vivify_646:
    set $P1876, $P1875["typename"]
    unless_null $P1876, vivify_647
    new $P1876, "Undef"
  vivify_647:
    unless $P1876, if_1874_end
.annotate 'line', 815
    find_lex $P1877, "$past"
    find_lex $P1878, "$/"
    unless_null $P1878, vivify_648
    $P1878 = root_new ['parrot';'Hash']
  vivify_648:
    set $P1879, $P1878["typename"]
    unless_null $P1879, vivify_649
    $P1879 = root_new ['parrot';'ResizablePMCArray']
  vivify_649:
    set $P1880, $P1879[0]
    unless_null $P1880, vivify_650
    new $P1880, "Undef"
  vivify_650:
    $P1881 = $P1880."ast"()
    $P1877."multitype"($P1881)
  if_1874_end:
.annotate 'line', 819
    find_lex $P1883, "$/"
    unless_null $P1883, vivify_651
    $P1883 = root_new ['parrot';'Hash']
  vivify_651:
    set $P1884, $P1883["definedness"]
    unless_null $P1884, vivify_652
    new $P1884, "Undef"
  vivify_652:
    unless $P1884, if_1882_end
.annotate 'line', 820
    find_lex $P1885, "$/"
    unless_null $P1885, vivify_653
    $P1885 = root_new ['parrot';'Hash']
  vivify_653:
    set $P1886, $P1885["definedness"]
    unless_null $P1886, vivify_654
    $P1886 = root_new ['parrot';'ResizablePMCArray']
  vivify_654:
    set $P1887, $P1886[0]
    unless_null $P1887, vivify_655
    new $P1887, "Undef"
  vivify_655:
    set $S1888, $P1887
    new $P1889, 'String'
    set $P1889, $S1888
    find_lex $P1890, "$past"
    unless_null $P1890, vivify_656
    $P1890 = root_new ['parrot';'Hash']
    store_lex "$past", $P1890
  vivify_656:
    set $P1890["definedness"], $P1889
  if_1882_end:
.annotate 'line', 823
    find_lex $P1891, "$/"
    find_lex $P1892, "$past"
    $P1893 = $P1891."!make"($P1892)
.annotate 'line', 782
    .return ($P1893)
.end


.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("102_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1895
    .param pmc param_1896
.annotate 'line', 826
    .lex "self", param_1895
    .lex "$/", param_1896
.annotate 'line', 827
    new $P1897, "Undef"
    .lex "$name", $P1897
.annotate 'line', 828
    new $P1898, "Undef"
    .lex "$past", $P1898
.annotate 'line', 827
    find_lex $P1899, "$/"
    set $S1900, $P1899
    new $P1901, 'String'
    set $P1901, $S1900
    store_lex "$name", $P1901
.annotate 'line', 828
    get_hll_global $P1902, ["PAST"], "Var"
    find_lex $P1903, "$name"
    find_lex $P1904, "$/"
    $P1905 = $P1902."new"($P1903 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P1904 :named("node"))
    store_lex "$past", $P1905
.annotate 'line', 830
    get_global $P1906, "@BLOCK"
    unless_null $P1906, vivify_657
    $P1906 = root_new ['parrot';'ResizablePMCArray']
  vivify_657:
    set $P1907, $P1906[0]
    unless_null $P1907, vivify_658
    new $P1907, "Undef"
  vivify_658:
    find_lex $P1908, "$name"
    $P1907."symbol"($P1908, "lexical" :named("scope"))
.annotate 'line', 831
    find_lex $P1909, "$/"
    find_lex $P1910, "$past"
    $P1911 = $P1909."!make"($P1910)
.annotate 'line', 826
    .return ($P1911)
.end


.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("103_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1913
    .param pmc param_1914
.annotate 'line', 834
    .lex "self", param_1913
    .lex "$/", param_1914
.annotate 'line', 835
    new $P1915, "Undef"
    .lex "$past", $P1915
    find_lex $P1916, "$/"
    unless_null $P1916, vivify_659
    $P1916 = root_new ['parrot';'Hash']
  vivify_659:
    set $P1917, $P1916["param_var"]
    unless_null $P1917, vivify_660
    new $P1917, "Undef"
  vivify_660:
    $P1918 = $P1917."ast"()
    store_lex "$past", $P1918
.annotate 'line', 836
    find_lex $P1919, "$past"
    find_lex $P1920, "$/"
    unless_null $P1920, vivify_661
    $P1920 = root_new ['parrot';'Hash']
  vivify_661:
    set $P1921, $P1920["param_var"]
    unless_null $P1921, vivify_662
    $P1921 = root_new ['parrot';'Hash']
  vivify_662:
    set $P1922, $P1921["name"]
    unless_null $P1922, vivify_663
    new $P1922, "Undef"
  vivify_663:
    set $S1923, $P1922
    $P1919."named"($S1923)
.annotate 'line', 837
    find_lex $P1924, "$/"
    find_lex $P1925, "$past"
    $P1926 = $P1924."!make"($P1925)
.annotate 'line', 834
    .return ($P1926)
.end


.namespace ["NQP";"Actions"]
.sub "typename"  :subid("104_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1928
    .param pmc param_1929
.annotate 'line', 840
    .lex "self", param_1928
    .lex "$/", param_1929
.annotate 'line', 841
    $P1930 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P1930
    get_hll_global $P1931, ["HLL"], "Compiler"
    find_lex $P1932, "$/"
    set $S1933, $P1932
    $P1934 = $P1931."parse_name"($S1933)
    store_lex "@name", $P1934
.annotate 'line', 842
    find_lex $P1935, "$/"
    get_hll_global $P1936, ["PAST"], "Var"
.annotate 'line', 843
    find_lex $P1937, "@name"
    $P1938 = $P1937."pop"()
    find_lex $P1939, "@name"
    $P1940 = $P1936."new"($P1938 :named("name"), $P1939 :named("namespace"), "package" :named("scope"))
.annotate 'line', 842
    $P1941 = $P1935."!make"($P1940)
.annotate 'line', 840
    .return ($P1941)
.end


.namespace ["NQP";"Actions"]
.sub "trait"  :subid("105_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1943
    .param pmc param_1944
.annotate 'line', 849
    .lex "self", param_1943
    .lex "$/", param_1944
.annotate 'line', 850
    find_lex $P1945, "$/"
    find_lex $P1946, "$/"
    unless_null $P1946, vivify_664
    $P1946 = root_new ['parrot';'Hash']
  vivify_664:
    set $P1947, $P1946["trait_mod"]
    unless_null $P1947, vivify_665
    new $P1947, "Undef"
  vivify_665:
    $P1948 = $P1947."ast"()
    $P1949 = $P1945."!make"($P1948)
.annotate 'line', 849
    .return ($P1949)
.end


.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("106_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1951
    .param pmc param_1952
.annotate 'line', 853
    .const 'Sub' $P1972 = "107_1295994666.515" 
    capture_lex $P1972
    .lex "self", param_1951
    .lex "$/", param_1952
.annotate 'line', 854
    new $P1953, "Undef"
    .lex "$cpast", $P1953
    find_lex $P1954, "$/"
    unless_null $P1954, vivify_666
    $P1954 = root_new ['parrot';'Hash']
  vivify_666:
    set $P1955, $P1954["circumfix"]
    unless_null $P1955, vivify_667
    $P1955 = root_new ['parrot';'ResizablePMCArray']
  vivify_667:
    set $P1956, $P1955[0]
    unless_null $P1956, vivify_668
    new $P1956, "Undef"
  vivify_668:
    $P1957 = $P1956."ast"()
    store_lex "$cpast", $P1957
.annotate 'line', 855
    find_lex $P1960, "$/"
    unless_null $P1960, vivify_669
    $P1960 = root_new ['parrot';'Hash']
  vivify_669:
    set $P1961, $P1960["longname"]
    unless_null $P1961, vivify_670
    new $P1961, "Undef"
  vivify_670:
    set $S1962, $P1961
    iseq $I1963, $S1962, "pirflags"
    if $I1963, if_1959
.annotate 'line', 861
    find_lex $P1982, "$/"
    $P1983 = $P1982."CURSOR"()
    new $P1984, 'String'
    set $P1984, "Trait '"
    find_lex $P1985, "$/"
    unless_null $P1985, vivify_671
    $P1985 = root_new ['parrot';'Hash']
  vivify_671:
    set $P1986, $P1985["longname"]
    unless_null $P1986, vivify_672
    new $P1986, "Undef"
  vivify_672:
    concat $P1987, $P1984, $P1986
    concat $P1988, $P1987, "' not implemented"
    $P1989 = $P1983."panic"($P1988)
.annotate 'line', 860
    set $P1958, $P1989
.annotate 'line', 855
    goto if_1959_end
  if_1959:
.annotate 'line', 857
    get_hll_global $P1965, ["PAST"], "Val"
    find_lex $P1966, "$cpast"
    $P1967 = $P1965."ACCEPTS"($P1966)
    if $P1967, unless_1964_end
.annotate 'line', 856
    find_lex $P1968, "$/"
    $P1969 = $P1968."CURSOR"()
    $P1969."panic"("Trait 'pirflags' requires constant scalar argument")
  unless_1964_end:
.annotate 'line', 858
    find_lex $P1970, "$/"
    .const 'Sub' $P1972 = "107_1295994666.515" 
    newclosure $P1980, $P1972
    $P1981 = $P1970."!make"($P1980)
.annotate 'line', 855
    set $P1958, $P1981
  if_1959_end:
.annotate 'line', 853
    .return ($P1958)
.end


.namespace ["NQP";"Actions"]
.sub "_block1971"  :anon :subid("107_1295994666.515") :outer("106_1295994666.515")
    .param pmc param_1973
.annotate 'line', 858
    .lex "$match", param_1973
    find_lex $P1974, "$match"
    $P1975 = $P1974."ast"()
    set $P1976, $P1975["block_past"]
    unless_null $P1976, vivify_673
    new $P1976, "Undef"
  vivify_673:
    find_lex $P1977, "$cpast"
    $P1978 = $P1977."value"()
    $P1979 = $P1976."pirflags"($P1978)
    .return ($P1979)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("108_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_1993
    .param pmc param_1994
    .param pmc param_1995 :optional
    .param int has_param_1995 :opt_flag
.annotate 'line', 865
    .const 'Sub' $P2093 = "111_1295994666.515" 
    capture_lex $P2093
    .const 'Sub' $P2065 = "110_1295994666.515" 
    capture_lex $P2065
    .const 'Sub' $P2038 = "109_1295994666.515" 
    capture_lex $P2038
    new $P1992, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P1992, control_1991
    push_eh $P1992
    .lex "self", param_1993
    .lex "$/", param_1994
    if has_param_1995, optparam_674
    new $P1996, "Undef"
    set param_1995, $P1996
  optparam_674:
    .lex "$key", param_1995
.annotate 'line', 866
    $P1997 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P1997
.annotate 'line', 869
    new $P1998, "Undef"
    .lex "$name", $P1998
.annotate 'line', 870
    new $P1999, "Undef"
    .lex "$past", $P1999
.annotate 'line', 866

        $P2000 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2000
.annotate 'line', 869
    find_lex $P2001, "$/"
    unless_null $P2001, vivify_675
    $P2001 = root_new ['parrot';'Hash']
  vivify_675:
    set $P2002, $P2001["deflongname"]
    unless_null $P2002, vivify_676
    new $P2002, "Undef"
  vivify_676:
    $P2003 = $P2002."ast"()
    set $S2004, $P2003
    new $P2005, 'String'
    set $P2005, $S2004
    store_lex "$name", $P2005
    find_lex $P2006, "$past"
.annotate 'line', 871
    find_lex $P2008, "$/"
    unless_null $P2008, vivify_677
    $P2008 = root_new ['parrot';'Hash']
  vivify_677:
    set $P2009, $P2008["proto"]
    unless_null $P2009, vivify_678
    new $P2009, "Undef"
  vivify_678:
    if $P2009, if_2007
.annotate 'line', 910
    find_lex $P2061, "$key"
    set $S2062, $P2061
    iseq $I2063, $S2062, "open"
    if $I2063, if_2060
.annotate 'line', 923
    .const 'Sub' $P2093 = "111_1295994666.515" 
    capture_lex $P2093
    $P2093()
    goto if_2060_end
  if_2060:
.annotate 'line', 910
    .const 'Sub' $P2065 = "110_1295994666.515" 
    capture_lex $P2065
    $P2065()
  if_2060_end:
    goto if_2007_end
  if_2007:
.annotate 'line', 873
    get_hll_global $P2010, ["PAST"], "Stmts"
.annotate 'line', 874
    get_hll_global $P2011, ["PAST"], "Block"
    find_lex $P2012, "$name"
.annotate 'line', 875
    get_hll_global $P2013, ["PAST"], "Op"
.annotate 'line', 876
    get_hll_global $P2014, ["PAST"], "Var"
    $P2015 = $P2014."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2016, "$name"
    $P2017 = $P2013."new"($P2015, $P2016, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 875
    find_lex $P2018, "$/"
    $P2019 = $P2011."new"($P2017, $P2012 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2018 :named("node"))
.annotate 'line', 885
    get_hll_global $P2020, ["PAST"], "Block"
    new $P2021, "String"
    assign $P2021, "!PREFIX__"
    find_lex $P2022, "$name"
    concat $P2023, $P2021, $P2022
.annotate 'line', 886
    get_hll_global $P2024, ["PAST"], "Op"
.annotate 'line', 887
    get_hll_global $P2025, ["PAST"], "Var"
    $P2026 = $P2025."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2027, "$name"
    $P2028 = $P2024."new"($P2026, $P2027, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 886
    find_lex $P2029, "$/"
    $P2030 = $P2020."new"($P2028, $P2023 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2029 :named("node"))
.annotate 'line', 885
    $P2031 = $P2010."new"($P2019, $P2030)
.annotate 'line', 873
    store_lex "$past", $P2031
.annotate 'line', 897
    find_lex $P2033, "$past"
    $P2034 = $P2033."list"()
    defined $I2035, $P2034
    unless $I2035, for_undef_699
    iter $P2032, $P2034
    new $P2058, 'ExceptionHandler'
    set_addr $P2058, loop2057_handler
    $P2058."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2058
  loop2057_test:
    unless $P2032, loop2057_done
    shift $P2036, $P2032
  loop2057_redo:
    .const 'Sub' $P2038 = "109_1295994666.515" 
    capture_lex $P2038
    $P2038($P2036)
  loop2057_next:
    goto loop2057_test
  loop2057_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2059, exception, 'type'
    eq $P2059, .CONTROL_LOOP_NEXT, loop2057_next
    eq $P2059, .CONTROL_LOOP_REDO, loop2057_redo
  loop2057_done:
    pop_eh 
  for_undef_699:
  if_2007_end:
.annotate 'line', 959
    find_lex $P2151, "$/"
    find_lex $P2152, "$past"
    $P2153 = $P2151."!make"($P2152)
.annotate 'line', 865
    .return ($P2153)
  control_1991:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2154, exception, "payload"
    .return ($P2154)
.end


.namespace ["NQP";"Actions"]
.sub "_block2092"  :anon :subid("111_1295994666.515") :outer("108_1295994666.515")
.annotate 'line', 924
    new $P2094, "Undef"
    .lex "$regex", $P2094
.annotate 'line', 925
    get_hll_global $P2095, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2096, "$/"
    unless_null $P2096, vivify_679
    $P2096 = root_new ['parrot';'Hash']
  vivify_679:
    set $P2097, $P2096["p6regex"]
    unless_null $P2097, vivify_680
    new $P2097, "Undef"
  vivify_680:
    $P2098 = $P2097."ast"()
    get_global $P2099, "@BLOCK"
    $P2100 = $P2099."shift"()
    $P2101 = $P2095($P2098, $P2100)
    store_lex "$regex", $P2101
.annotate 'line', 926
    find_lex $P2102, "$regex"
    find_lex $P2103, "$name"
    $P2102."name"($P2103)
.annotate 'line', 928
    get_hll_global $P2104, ["PAST"], "Op"
.annotate 'line', 930
    get_hll_global $P2105, ["PAST"], "Var"
    new $P2106, "ResizablePMCArray"
    push $P2106, "Regex"
    $P2107 = $P2105."new"("Method" :named("name"), $P2106 :named("namespace"), "package" :named("scope"))
    find_lex $P2108, "$regex"
    $P2109 = $P2104."new"($P2107, $P2108, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 928
    store_lex "$past", $P2109
.annotate 'line', 933
    find_dynamic_lex $P2111, "$*PACKAGE-SETUP"
    unless_null $P2111, vivify_681
    get_hll_global $P2111, "$PACKAGE-SETUP"
    unless_null $P2111, vivify_682
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_682:
  vivify_681:
    defined $I2112, $P2111
    unless $I2112, if_2110_end
.annotate 'line', 934
    find_dynamic_lex $P2113, "$*PACKAGE-SETUP"
    unless_null $P2113, vivify_683
    get_hll_global $P2113, "$PACKAGE-SETUP"
    unless_null $P2113, vivify_684
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_684:
  vivify_683:
    get_hll_global $P2114, ["PAST"], "Op"
.annotate 'line', 936
    get_hll_global $P2115, ["PAST"], "Op"
.annotate 'line', 938
    get_hll_global $P2116, ["PAST"], "Var"
    $P2117 = $P2116."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2118 = $P2115."new"($P2117, "get_how PP" :named("pirop"))
.annotate 'line', 940
    get_hll_global $P2119, ["PAST"], "Var"
    $P2120 = $P2119."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 941
    get_hll_global $P2121, ["PAST"], "Val"
    find_lex $P2122, "$name"
    $P2123 = $P2121."new"($P2122 :named("value"))
.annotate 'line', 942
    get_hll_global $P2124, ["PAST"], "Val"
    find_lex $P2125, "$regex"
    $P2126 = $P2124."new"($P2125 :named("value"))
    $P2127 = $P2114."new"($P2118, $P2120, $P2123, $P2126, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 934
    $P2113."push"($P2127)
.annotate 'line', 944
    find_dynamic_lex $P2128, "$*PACKAGE-SETUP"
    unless_null $P2128, vivify_685
    get_hll_global $P2128, "$PACKAGE-SETUP"
    unless_null $P2128, vivify_686
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_686:
  vivify_685:
    get_hll_global $P2129, ["PAST"], "Op"
.annotate 'line', 946
    get_hll_global $P2130, ["PAST"], "Op"
.annotate 'line', 948
    get_hll_global $P2131, ["PAST"], "Var"
    $P2132 = $P2131."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2133 = $P2130."new"($P2132, "get_how PP" :named("pirop"))
.annotate 'line', 950
    get_hll_global $P2134, ["PAST"], "Var"
    $P2135 = $P2134."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 951
    get_hll_global $P2136, ["PAST"], "Val"
    new $P2137, "String"
    assign $P2137, "!PREFIX__"
    find_lex $P2138, "$name"
    concat $P2139, $P2137, $P2138
    $P2140 = $P2136."new"($P2139 :named("value"))
.annotate 'line', 952
    get_hll_global $P2141, ["PAST"], "Var"
    new $P2142, "String"
    assign $P2142, "!PREFIX__"
    find_lex $P2143, "$name"
    concat $P2144, $P2142, $P2143
    $P2145 = $P2141."new"($P2144 :named("name"), "package" :named("scope"))
    $P2146 = $P2129."new"($P2133, $P2135, $P2140, $P2145, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 944
    $P2128."push"($P2146)
  if_2110_end:
.annotate 'line', 956
    find_lex $P2147, "$regex"
    find_lex $P2148, "$past"
    unless_null $P2148, vivify_687
    $P2148 = root_new ['parrot';'Hash']
    store_lex "$past", $P2148
  vivify_687:
    set $P2148["sink"], $P2147
.annotate 'line', 957
    find_lex $P2149, "@MODIFIERS"
    $P2150 = $P2149."shift"()
.annotate 'line', 923
    .return ($P2150)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2064"  :anon :subid("110_1295994666.515") :outer("108_1295994666.515")
.annotate 'line', 911
    $P2066 = root_new ['parrot';'Hash']
    .lex "%h", $P2066
.annotate 'line', 910
    find_lex $P2067, "%h"
.annotate 'line', 912
    find_lex $P2069, "$/"
    unless_null $P2069, vivify_688
    $P2069 = root_new ['parrot';'Hash']
  vivify_688:
    set $P2070, $P2069["sym"]
    unless_null $P2070, vivify_689
    new $P2070, "Undef"
  vivify_689:
    set $S2071, $P2070
    iseq $I2072, $S2071, "token"
    unless $I2072, if_2068_end
    new $P2073, "Integer"
    assign $P2073, 1
    find_lex $P2074, "%h"
    unless_null $P2074, vivify_690
    $P2074 = root_new ['parrot';'Hash']
    store_lex "%h", $P2074
  vivify_690:
    set $P2074["r"], $P2073
  if_2068_end:
.annotate 'line', 913
    find_lex $P2076, "$/"
    unless_null $P2076, vivify_691
    $P2076 = root_new ['parrot';'Hash']
  vivify_691:
    set $P2077, $P2076["sym"]
    unless_null $P2077, vivify_692
    new $P2077, "Undef"
  vivify_692:
    set $S2078, $P2077
    iseq $I2079, $S2078, "rule"
    unless $I2079, if_2075_end
    new $P2080, "Integer"
    assign $P2080, 1
    find_lex $P2081, "%h"
    unless_null $P2081, vivify_693
    $P2081 = root_new ['parrot';'Hash']
    store_lex "%h", $P2081
  vivify_693:
    set $P2081["r"], $P2080
    new $P2082, "Integer"
    assign $P2082, 1
    find_lex $P2083, "%h"
    unless_null $P2083, vivify_694
    $P2083 = root_new ['parrot';'Hash']
    store_lex "%h", $P2083
  vivify_694:
    set $P2083["s"], $P2082
  if_2075_end:
.annotate 'line', 914
    find_lex $P2084, "@MODIFIERS"
    find_lex $P2085, "%h"
    $P2084."unshift"($P2085)
.annotate 'line', 915

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 919
    get_global $P2086, "@BLOCK"
    unless_null $P2086, vivify_695
    $P2086 = root_new ['parrot';'ResizablePMCArray']
  vivify_695:
    set $P2087, $P2086[0]
    unless_null $P2087, vivify_696
    new $P2087, "Undef"
  vivify_696:
    $P2087."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 920
    get_global $P2088, "@BLOCK"
    unless_null $P2088, vivify_697
    $P2088 = root_new ['parrot';'ResizablePMCArray']
  vivify_697:
    set $P2089, $P2088[0]
    unless_null $P2089, vivify_698
    new $P2089, "Undef"
  vivify_698:
    $P2089."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 921
    new $P2090, "Exception"
    set $P2090['type'], .CONTROL_RETURN
    new $P2091, "Integer"
    assign $P2091, 0
    setattribute $P2090, 'payload', $P2091
    throw $P2090
.annotate 'line', 910
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "_block2037"  :anon :subid("109_1295994666.515") :outer("108_1295994666.515")
    .param pmc param_2039
.annotate 'line', 897
    .lex "$_", param_2039
.annotate 'line', 898
    find_dynamic_lex $P2040, "$*PACKAGE-SETUP"
    unless_null $P2040, vivify_700
    get_hll_global $P2040, "$PACKAGE-SETUP"
    unless_null $P2040, vivify_701
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_701:
  vivify_700:
    get_hll_global $P2041, ["PAST"], "Op"
.annotate 'line', 900
    get_hll_global $P2042, ["PAST"], "Op"
.annotate 'line', 902
    get_hll_global $P2043, ["PAST"], "Var"
    $P2044 = $P2043."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2045 = $P2042."new"($P2044, "get_how PP" :named("pirop"))
.annotate 'line', 904
    get_hll_global $P2046, ["PAST"], "Var"
    $P2047 = $P2046."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 905
    get_hll_global $P2048, ["PAST"], "Val"
    find_lex $P2049, "$_"
    $P2050 = $P2049."name"()
    $P2051 = $P2048."new"($P2050 :named("value"))
.annotate 'line', 906
    get_hll_global $P2052, ["PAST"], "Val"
    find_lex $P2053, "$_"
    $P2054 = $P2052."new"($P2053 :named("value"))
    $P2055 = $P2041."new"($P2045, $P2047, $P2051, $P2054, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 898
    $P2056 = $P2040."push"($P2055)
.annotate 'line', 897
    .return ($P2056)
.end


.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("112_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2156
    .param pmc param_2157
.annotate 'line', 963
    .lex "self", param_2156
    .lex "$/", param_2157
.annotate 'line', 964
    new $P2158, "Undef"
    .lex "$past", $P2158
    find_lex $P2161, "$/"
    unless_null $P2161, vivify_702
    $P2161 = root_new ['parrot';'Hash']
  vivify_702:
    set $P2162, $P2161["args"]
    unless_null $P2162, vivify_703
    new $P2162, "Undef"
  vivify_703:
    if $P2162, if_2160
    get_hll_global $P2167, ["PAST"], "Op"
    find_lex $P2168, "$/"
    $P2169 = $P2167."new"($P2168 :named("node"))
    set $P2159, $P2169
    goto if_2160_end
  if_2160:
    find_lex $P2163, "$/"
    unless_null $P2163, vivify_704
    $P2163 = root_new ['parrot';'Hash']
  vivify_704:
    set $P2164, $P2163["args"]
    unless_null $P2164, vivify_705
    $P2164 = root_new ['parrot';'ResizablePMCArray']
  vivify_705:
    set $P2165, $P2164[0]
    unless_null $P2165, vivify_706
    new $P2165, "Undef"
  vivify_706:
    $P2166 = $P2165."ast"()
    set $P2159, $P2166
  if_2160_end:
    store_lex "$past", $P2159
.annotate 'line', 965
    find_lex $P2171, "$/"
    unless_null $P2171, vivify_707
    $P2171 = root_new ['parrot';'Hash']
  vivify_707:
    set $P2172, $P2171["quote"]
    unless_null $P2172, vivify_708
    new $P2172, "Undef"
  vivify_708:
    if $P2172, if_2170
.annotate 'line', 969
    find_lex $P2179, "$/"
    unless_null $P2179, vivify_709
    $P2179 = root_new ['parrot';'Hash']
  vivify_709:
    set $P2180, $P2179["longname"]
    unless_null $P2180, vivify_710
    new $P2180, "Undef"
  vivify_710:
    set $S2181, $P2180
    iseq $I2182, $S2181, "HOW"
    if $I2182, if_2178
.annotate 'line', 973
    find_lex $P2186, "$/"
    unless_null $P2186, vivify_711
    $P2186 = root_new ['parrot';'Hash']
  vivify_711:
    set $P2187, $P2186["longname"]
    unless_null $P2187, vivify_712
    new $P2187, "Undef"
  vivify_712:
    set $S2188, $P2187
    iseq $I2189, $S2188, "WHAT"
    if $I2189, if_2185
.annotate 'line', 977
    find_lex $P2191, "$past"
    find_lex $P2192, "$/"
    unless_null $P2192, vivify_713
    $P2192 = root_new ['parrot';'Hash']
  vivify_713:
    set $P2193, $P2192["longname"]
    unless_null $P2193, vivify_714
    new $P2193, "Undef"
  vivify_714:
    set $S2194, $P2193
    $P2191."name"($S2194)
.annotate 'line', 978
    find_lex $P2195, "$past"
    $P2195."pasttype"("callmethod")
.annotate 'line', 976
    goto if_2185_end
  if_2185:
.annotate 'line', 974
    find_lex $P2190, "$past"
    $P2190."pirop"("get_what PP")
  if_2185_end:
.annotate 'line', 973
    goto if_2178_end
  if_2178:
.annotate 'line', 970
    find_lex $P2183, "$past"
    $P2183."pirop"("get_how PP")
.annotate 'line', 971
    find_lex $P2184, "$past"
    $P2184."pasttype"("pirop")
  if_2178_end:
.annotate 'line', 969
    goto if_2170_end
  if_2170:
.annotate 'line', 966
    find_lex $P2173, "$past"
    find_lex $P2174, "$/"
    unless_null $P2174, vivify_715
    $P2174 = root_new ['parrot';'Hash']
  vivify_715:
    set $P2175, $P2174["quote"]
    unless_null $P2175, vivify_716
    new $P2175, "Undef"
  vivify_716:
    $P2176 = $P2175."ast"()
    $P2173."name"($P2176)
.annotate 'line', 967
    find_lex $P2177, "$past"
    $P2177."pasttype"("callmethod")
  if_2170_end:
.annotate 'line', 980
    find_lex $P2196, "$/"
    find_lex $P2197, "$past"
    $P2198 = $P2196."!make"($P2197)
.annotate 'line', 963
    .return ($P2198)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("113_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2200
    .param pmc param_2201
.annotate 'line', 985
    .lex "self", param_2200
    .lex "$/", param_2201
.annotate 'line', 986
    find_lex $P2202, "$/"
    get_hll_global $P2203, ["PAST"], "Var"
    $P2204 = $P2203."new"("self" :named("name"))
    $P2205 = $P2202."!make"($P2204)
.annotate 'line', 985
    .return ($P2205)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("114_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2207
    .param pmc param_2208
.annotate 'line', 989
    .lex "self", param_2207
    .lex "$/", param_2208
.annotate 'line', 990
    new $P2209, "Undef"
    .lex "$past", $P2209
    find_lex $P2210, "$/"
    unless_null $P2210, vivify_717
    $P2210 = root_new ['parrot';'Hash']
  vivify_717:
    set $P2211, $P2210["args"]
    unless_null $P2211, vivify_718
    new $P2211, "Undef"
  vivify_718:
    $P2212 = $P2211."ast"()
    store_lex "$past", $P2212
.annotate 'line', 991
    find_lex $P2213, "$past"
    find_lex $P2214, "$/"
    unless_null $P2214, vivify_719
    $P2214 = root_new ['parrot';'Hash']
  vivify_719:
    set $P2215, $P2214["deflongname"]
    unless_null $P2215, vivify_720
    new $P2215, "Undef"
  vivify_720:
    set $S2216, $P2215
    $P2213."name"($S2216)
.annotate 'line', 992
    find_lex $P2217, "$/"
    find_lex $P2218, "$past"
    $P2219 = $P2217."!make"($P2218)
.annotate 'line', 989
    .return ($P2219)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("115_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2221
    .param pmc param_2222
.annotate 'line', 995
    .lex "self", param_2221
    .lex "$/", param_2222
.annotate 'line', 996
    $P2223 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2223
.annotate 'line', 997
    new $P2224, "Undef"
    .lex "$name", $P2224
.annotate 'line', 999
    new $P2225, "Undef"
    .lex "$var", $P2225
.annotate 'line', 1001
    new $P2226, "Undef"
    .lex "$past", $P2226
.annotate 'line', 996
    find_lex $P2227, "$/"
    unless_null $P2227, vivify_721
    $P2227 = root_new ['parrot';'Hash']
  vivify_721:
    set $P2228, $P2227["name"]
    unless_null $P2228, vivify_722
    $P2228 = root_new ['parrot';'Hash']
  vivify_722:
    set $P2229, $P2228["identifier"]
    unless_null $P2229, vivify_723
    new $P2229, "Undef"
  vivify_723:
    clone $P2230, $P2229
    store_lex "@ns", $P2230
.annotate 'line', 997
    find_lex $P2231, "@ns"
    $P2232 = $P2231."pop"()
    store_lex "$name", $P2232
.annotate 'line', 998
    find_lex $P2236, "@ns"
    if $P2236, if_2235
    set $P2234, $P2236
    goto if_2235_end
  if_2235:
    find_lex $P2237, "@ns"
    unless_null $P2237, vivify_724
    $P2237 = root_new ['parrot';'ResizablePMCArray']
  vivify_724:
    set $P2238, $P2237[0]
    unless_null $P2238, vivify_725
    new $P2238, "Undef"
  vivify_725:
    set $S2239, $P2238
    iseq $I2240, $S2239, "GLOBAL"
    new $P2234, 'Integer'
    set $P2234, $I2240
  if_2235_end:
    unless $P2234, if_2233_end
    find_lex $P2241, "@ns"
    $P2241."shift"()
  if_2233_end:
.annotate 'line', 1000
    get_hll_global $P2242, ["PAST"], "Var"
    find_lex $P2243, "$name"
    set $S2244, $P2243
    find_lex $P2245, "@ns"
    $P2246 = $P2242."new"($S2244 :named("name"), $P2245 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2246
.annotate 'line', 1001
    find_lex $P2247, "$var"
    store_lex "$past", $P2247
.annotate 'line', 1002
    find_lex $P2249, "$/"
    unless_null $P2249, vivify_726
    $P2249 = root_new ['parrot';'Hash']
  vivify_726:
    set $P2250, $P2249["args"]
    unless_null $P2250, vivify_727
    new $P2250, "Undef"
  vivify_727:
    unless $P2250, if_2248_end
.annotate 'line', 1003
    find_lex $P2251, "$/"
    unless_null $P2251, vivify_728
    $P2251 = root_new ['parrot';'Hash']
  vivify_728:
    set $P2252, $P2251["args"]
    unless_null $P2252, vivify_729
    $P2252 = root_new ['parrot';'ResizablePMCArray']
  vivify_729:
    set $P2253, $P2252[0]
    unless_null $P2253, vivify_730
    new $P2253, "Undef"
  vivify_730:
    $P2254 = $P2253."ast"()
    store_lex "$past", $P2254
.annotate 'line', 1004
    find_lex $P2255, "$past"
    find_lex $P2256, "$var"
    $P2255."unshift"($P2256)
  if_2248_end:
.annotate 'line', 1006
    find_lex $P2257, "$/"
    find_lex $P2258, "$past"
    $P2259 = $P2257."!make"($P2258)
.annotate 'line', 995
    .return ($P2259)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("116_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2261
    .param pmc param_2262
.annotate 'line', 1009
    .lex "self", param_2261
    .lex "$/", param_2262
.annotate 'line', 1010
    new $P2263, "Undef"
    .lex "$past", $P2263
.annotate 'line', 1011
    new $P2264, "Undef"
    .lex "$pirop", $P2264
.annotate 'line', 1010
    find_lex $P2267, "$/"
    unless_null $P2267, vivify_731
    $P2267 = root_new ['parrot';'Hash']
  vivify_731:
    set $P2268, $P2267["args"]
    unless_null $P2268, vivify_732
    new $P2268, "Undef"
  vivify_732:
    if $P2268, if_2266
    get_hll_global $P2273, ["PAST"], "Op"
    find_lex $P2274, "$/"
    $P2275 = $P2273."new"($P2274 :named("node"))
    set $P2265, $P2275
    goto if_2266_end
  if_2266:
    find_lex $P2269, "$/"
    unless_null $P2269, vivify_733
    $P2269 = root_new ['parrot';'Hash']
  vivify_733:
    set $P2270, $P2269["args"]
    unless_null $P2270, vivify_734
    $P2270 = root_new ['parrot';'ResizablePMCArray']
  vivify_734:
    set $P2271, $P2270[0]
    unless_null $P2271, vivify_735
    new $P2271, "Undef"
  vivify_735:
    $P2272 = $P2271."ast"()
    set $P2265, $P2272
  if_2266_end:
    store_lex "$past", $P2265
.annotate 'line', 1011
    find_lex $P2276, "$/"
    unless_null $P2276, vivify_736
    $P2276 = root_new ['parrot';'Hash']
  vivify_736:
    set $P2277, $P2276["op"]
    unless_null $P2277, vivify_737
    new $P2277, "Undef"
  vivify_737:
    set $S2278, $P2277
    new $P2279, 'String'
    set $P2279, $S2278
    store_lex "$pirop", $P2279
.annotate 'line', 1012

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2280 = box $S0
    
    store_lex "$pirop", $P2280
.annotate 'line', 1019
    find_lex $P2281, "$past"
    find_lex $P2282, "$pirop"
    $P2281."pirop"($P2282)
.annotate 'line', 1020
    find_lex $P2283, "$past"
    $P2283."pasttype"("pirop")
.annotate 'line', 1021
    find_lex $P2284, "$/"
    find_lex $P2285, "$past"
    $P2286 = $P2284."!make"($P2285)
.annotate 'line', 1009
    .return ($P2286)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("117_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2288
    .param pmc param_2289
.annotate 'line', 1024
    .lex "self", param_2288
    .lex "$/", param_2289
.annotate 'line', 1025
    find_lex $P2290, "$/"
    get_hll_global $P2291, ["PAST"], "Op"
    $P2292 = $P2291."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2293 = $P2290."!make"($P2292)
.annotate 'line', 1024
    .return ($P2293)
.end


.namespace ["NQP";"Actions"]
.sub "args"  :subid("118_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2295
    .param pmc param_2296
.annotate 'line', 1030
    .lex "self", param_2295
    .lex "$/", param_2296
    find_lex $P2297, "$/"
    find_lex $P2298, "$/"
    unless_null $P2298, vivify_738
    $P2298 = root_new ['parrot';'Hash']
  vivify_738:
    set $P2299, $P2298["arglist"]
    unless_null $P2299, vivify_739
    new $P2299, "Undef"
  vivify_739:
    $P2300 = $P2299."ast"()
    $P2301 = $P2297."!make"($P2300)
    .return ($P2301)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("119_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2303
    .param pmc param_2304
.annotate 'line', 1032
    .const 'Sub' $P2315 = "120_1295994666.515" 
    capture_lex $P2315
    .lex "self", param_2303
    .lex "$/", param_2304
.annotate 'line', 1033
    new $P2305, "Undef"
    .lex "$past", $P2305
.annotate 'line', 1041
    new $P2306, "Undef"
    .lex "$i", $P2306
.annotate 'line', 1042
    new $P2307, "Undef"
    .lex "$n", $P2307
.annotate 'line', 1033
    get_hll_global $P2308, ["PAST"], "Op"
    find_lex $P2309, "$/"
    $P2310 = $P2308."new"("call" :named("pasttype"), $P2309 :named("node"))
    store_lex "$past", $P2310
.annotate 'line', 1034
    find_lex $P2312, "$/"
    unless_null $P2312, vivify_740
    $P2312 = root_new ['parrot';'Hash']
  vivify_740:
    set $P2313, $P2312["EXPR"]
    unless_null $P2313, vivify_741
    new $P2313, "Undef"
  vivify_741:
    unless $P2313, if_2311_end
    .const 'Sub' $P2315 = "120_1295994666.515" 
    capture_lex $P2315
    $P2315()
  if_2311_end:
.annotate 'line', 1041
    new $P2347, "Integer"
    assign $P2347, 0
    store_lex "$i", $P2347
.annotate 'line', 1042
    find_lex $P2348, "$past"
    $P2349 = $P2348."list"()
    set $N2350, $P2349
    new $P2351, 'Float'
    set $P2351, $N2350
    store_lex "$n", $P2351
.annotate 'line', 1043
    new $P2399, 'ExceptionHandler'
    set_addr $P2399, loop2398_handler
    $P2399."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2399
  loop2398_test:
    find_lex $P2352, "$i"
    set $N2353, $P2352
    find_lex $P2354, "$n"
    set $N2355, $P2354
    islt $I2356, $N2353, $N2355
    unless $I2356, loop2398_done
  loop2398_redo:
.annotate 'line', 1044
    find_lex $P2358, "$i"
    set $I2359, $P2358
    find_lex $P2360, "$past"
    unless_null $P2360, vivify_745
    $P2360 = root_new ['parrot';'ResizablePMCArray']
  vivify_745:
    set $P2361, $P2360[$I2359]
    unless_null $P2361, vivify_746
    new $P2361, "Undef"
  vivify_746:
    $S2362 = $P2361."name"()
    iseq $I2363, $S2362, "&prefix:<|>"
    unless $I2363, if_2357_end
.annotate 'line', 1045
    find_lex $P2364, "$i"
    set $I2365, $P2364
    find_lex $P2366, "$past"
    unless_null $P2366, vivify_747
    $P2366 = root_new ['parrot';'ResizablePMCArray']
  vivify_747:
    set $P2367, $P2366[$I2365]
    unless_null $P2367, vivify_748
    $P2367 = root_new ['parrot';'ResizablePMCArray']
  vivify_748:
    set $P2368, $P2367[0]
    unless_null $P2368, vivify_749
    new $P2368, "Undef"
  vivify_749:
    find_lex $P2369, "$i"
    set $I2370, $P2369
    find_lex $P2371, "$past"
    unless_null $P2371, vivify_750
    $P2371 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2371
  vivify_750:
    set $P2371[$I2370], $P2368
.annotate 'line', 1046
    find_lex $P2372, "$i"
    set $I2373, $P2372
    find_lex $P2374, "$past"
    unless_null $P2374, vivify_751
    $P2374 = root_new ['parrot';'ResizablePMCArray']
  vivify_751:
    set $P2375, $P2374[$I2373]
    unless_null $P2375, vivify_752
    new $P2375, "Undef"
  vivify_752:
    $P2375."flat"(1)
.annotate 'line', 1047
    find_lex $P2379, "$i"
    set $I2380, $P2379
    find_lex $P2381, "$past"
    unless_null $P2381, vivify_753
    $P2381 = root_new ['parrot';'ResizablePMCArray']
  vivify_753:
    set $P2382, $P2381[$I2380]
    unless_null $P2382, vivify_754
    new $P2382, "Undef"
  vivify_754:
    get_hll_global $P2383, ["PAST"], "Val"
    $P2384 = $P2382."isa"($P2383)
    if $P2384, if_2378
    set $P2377, $P2384
    goto if_2378_end
  if_2378:
.annotate 'line', 1048
    find_lex $P2385, "$i"
    set $I2386, $P2385
    find_lex $P2387, "$past"
    unless_null $P2387, vivify_755
    $P2387 = root_new ['parrot';'ResizablePMCArray']
  vivify_755:
    set $P2388, $P2387[$I2386]
    unless_null $P2388, vivify_756
    new $P2388, "Undef"
  vivify_756:
    $S2389 = $P2388."name"()
    substr $S2390, $S2389, 0, 1
    iseq $I2391, $S2390, "%"
    new $P2377, 'Integer'
    set $P2377, $I2391
  if_2378_end:
    unless $P2377, if_2376_end
.annotate 'line', 1049
    find_lex $P2392, "$i"
    set $I2393, $P2392
    find_lex $P2394, "$past"
    unless_null $P2394, vivify_757
    $P2394 = root_new ['parrot';'ResizablePMCArray']
  vivify_757:
    set $P2395, $P2394[$I2393]
    unless_null $P2395, vivify_758
    new $P2395, "Undef"
  vivify_758:
    $P2395."named"(1)
  if_2376_end:
  if_2357_end:
.annotate 'line', 1044
    find_lex $P2396, "$i"
    clone $P2397, $P2396
    inc $P2396
  loop2398_next:
.annotate 'line', 1043
    goto loop2398_test
  loop2398_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2400, exception, 'type'
    eq $P2400, .CONTROL_LOOP_NEXT, loop2398_next
    eq $P2400, .CONTROL_LOOP_REDO, loop2398_redo
  loop2398_done:
    pop_eh 
.annotate 'line', 1054
    find_lex $P2401, "$/"
    find_lex $P2402, "$past"
    $P2403 = $P2401."!make"($P2402)
.annotate 'line', 1032
    .return ($P2403)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2314"  :anon :subid("120_1295994666.515") :outer("119_1295994666.515")
.annotate 'line', 1034
    .const 'Sub' $P2336 = "121_1295994666.515" 
    capture_lex $P2336
.annotate 'line', 1035
    new $P2316, "Undef"
    .lex "$expr", $P2316
    find_lex $P2317, "$/"
    unless_null $P2317, vivify_742
    $P2317 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2318, $P2317["EXPR"]
    unless_null $P2318, vivify_743
    new $P2318, "Undef"
  vivify_743:
    $P2319 = $P2318."ast"()
    store_lex "$expr", $P2319
.annotate 'line', 1036
    find_lex $P2324, "$expr"
    $S2325 = $P2324."name"()
    iseq $I2326, $S2325, "&infix:<,>"
    if $I2326, if_2323
    new $P2322, 'Integer'
    set $P2322, $I2326
    goto if_2323_end
  if_2323:
    find_lex $P2327, "$expr"
    $P2328 = $P2327."named"()
    isfalse $I2329, $P2328
    new $P2322, 'Integer'
    set $P2322, $I2329
  if_2323_end:
    if $P2322, if_2321
.annotate 'line', 1039
    find_lex $P2344, "$past"
    find_lex $P2345, "$expr"
    $P2346 = $P2344."push"($P2345)
    set $P2320, $P2346
.annotate 'line', 1036
    goto if_2321_end
  if_2321:
.annotate 'line', 1037
    find_lex $P2331, "$expr"
    $P2332 = $P2331."list"()
    defined $I2333, $P2332
    unless $I2333, for_undef_744
    iter $P2330, $P2332
    new $P2342, 'ExceptionHandler'
    set_addr $P2342, loop2341_handler
    $P2342."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2342
  loop2341_test:
    unless $P2330, loop2341_done
    shift $P2334, $P2330
  loop2341_redo:
    .const 'Sub' $P2336 = "121_1295994666.515" 
    capture_lex $P2336
    $P2336($P2334)
  loop2341_next:
    goto loop2341_test
  loop2341_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2343, exception, 'type'
    eq $P2343, .CONTROL_LOOP_NEXT, loop2341_next
    eq $P2343, .CONTROL_LOOP_REDO, loop2341_redo
  loop2341_done:
    pop_eh 
  for_undef_744:
.annotate 'line', 1036
    set $P2320, $P2330
  if_2321_end:
.annotate 'line', 1034
    .return ($P2320)
.end


.namespace ["NQP";"Actions"]
.sub "_block2335"  :anon :subid("121_1295994666.515") :outer("120_1295994666.515")
    .param pmc param_2337
.annotate 'line', 1037
    .lex "$_", param_2337
    find_lex $P2338, "$past"
    find_lex $P2339, "$_"
    $P2340 = $P2338."push"($P2339)
    .return ($P2340)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("122_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2405
    .param pmc param_2406
.annotate 'line', 1057
    .lex "self", param_2405
    .lex "$/", param_2406
    find_lex $P2407, "$/"
    find_lex $P2408, "$/"
    unless_null $P2408, vivify_759
    $P2408 = root_new ['parrot';'Hash']
  vivify_759:
    set $P2409, $P2408["multi_declarator"]
    unless_null $P2409, vivify_760
    new $P2409, "Undef"
  vivify_760:
    $P2410 = $P2409."ast"()
    $P2411 = $P2407."!make"($P2410)
    .return ($P2411)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("123_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2413
    .param pmc param_2414
.annotate 'line', 1059
    .lex "self", param_2413
    .lex "$/", param_2414
    find_lex $P2415, "$/"
    find_lex $P2416, "$/"
    unless_null $P2416, vivify_761
    $P2416 = root_new ['parrot';'Hash']
  vivify_761:
    set $P2417, $P2416["value"]
    unless_null $P2417, vivify_762
    new $P2417, "Undef"
  vivify_762:
    $P2418 = $P2417."ast"()
    $P2419 = $P2415."!make"($P2418)
    .return ($P2419)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("124_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2421
    .param pmc param_2422
.annotate 'line', 1061
    .lex "self", param_2421
    .lex "$/", param_2422
.annotate 'line', 1062
    find_lex $P2423, "$/"
.annotate 'line', 1063
    find_lex $P2426, "$/"
    unless_null $P2426, vivify_763
    $P2426 = root_new ['parrot';'Hash']
  vivify_763:
    set $P2427, $P2426["EXPR"]
    unless_null $P2427, vivify_764
    new $P2427, "Undef"
  vivify_764:
    if $P2427, if_2425
.annotate 'line', 1064
    get_hll_global $P2432, ["PAST"], "Op"
    find_lex $P2433, "$/"
    $P2434 = $P2432."new"("list" :named("pasttype"), $P2433 :named("node"))
    set $P2424, $P2434
.annotate 'line', 1063
    goto if_2425_end
  if_2425:
    find_lex $P2428, "$/"
    unless_null $P2428, vivify_765
    $P2428 = root_new ['parrot';'Hash']
  vivify_765:
    set $P2429, $P2428["EXPR"]
    unless_null $P2429, vivify_766
    $P2429 = root_new ['parrot';'ResizablePMCArray']
  vivify_766:
    set $P2430, $P2429[0]
    unless_null $P2430, vivify_767
    new $P2430, "Undef"
  vivify_767:
    $P2431 = $P2430."ast"()
    set $P2424, $P2431
  if_2425_end:
    $P2435 = $P2423."!make"($P2424)
.annotate 'line', 1061
    .return ($P2435)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("125_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2437
    .param pmc param_2438
.annotate 'line', 1067
    .lex "self", param_2437
    .lex "$/", param_2438
.annotate 'line', 1068
    new $P2439, "Undef"
    .lex "$past", $P2439
.annotate 'line', 1067
    find_lex $P2440, "$past"
.annotate 'line', 1069
    find_lex $P2442, "$/"
    unless_null $P2442, vivify_768
    $P2442 = root_new ['parrot';'Hash']
  vivify_768:
    set $P2443, $P2442["EXPR"]
    unless_null $P2443, vivify_769
    new $P2443, "Undef"
  vivify_769:
    if $P2443, if_2441
.annotate 'line', 1076
    get_hll_global $P2455, ["PAST"], "Op"
    $P2456 = $P2455."new"("list" :named("pasttype"))
    store_lex "$past", $P2456
.annotate 'line', 1075
    goto if_2441_end
  if_2441:
.annotate 'line', 1070
    find_lex $P2444, "$/"
    unless_null $P2444, vivify_770
    $P2444 = root_new ['parrot';'Hash']
  vivify_770:
    set $P2445, $P2444["EXPR"]
    unless_null $P2445, vivify_771
    $P2445 = root_new ['parrot';'ResizablePMCArray']
  vivify_771:
    set $P2446, $P2445[0]
    unless_null $P2446, vivify_772
    new $P2446, "Undef"
  vivify_772:
    $P2447 = $P2446."ast"()
    store_lex "$past", $P2447
.annotate 'line', 1071
    find_lex $P2449, "$past"
    $S2450 = $P2449."name"()
    isne $I2451, $S2450, "&infix:<,>"
    unless $I2451, if_2448_end
.annotate 'line', 1072
    get_hll_global $P2452, ["PAST"], "Op"
    find_lex $P2453, "$past"
    $P2454 = $P2452."new"($P2453, "list" :named("pasttype"))
    store_lex "$past", $P2454
  if_2448_end:
  if_2441_end:
.annotate 'line', 1078
    find_lex $P2457, "$past"
    $P2457."name"("&circumfix:<[ ]>")
.annotate 'line', 1079
    find_lex $P2458, "$/"
    find_lex $P2459, "$past"
    $P2460 = $P2458."!make"($P2459)
.annotate 'line', 1067
    .return ($P2460)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("126_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2462
    .param pmc param_2463
.annotate 'line', 1082
    .lex "self", param_2462
    .lex "$/", param_2463
    find_lex $P2464, "$/"
    find_lex $P2465, "$/"
    unless_null $P2465, vivify_773
    $P2465 = root_new ['parrot';'Hash']
  vivify_773:
    set $P2466, $P2465["quote_EXPR"]
    unless_null $P2466, vivify_774
    new $P2466, "Undef"
  vivify_774:
    $P2467 = $P2466."ast"()
    $P2468 = $P2464."!make"($P2467)
    .return ($P2468)
.end


.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("127_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2470
    .param pmc param_2471
.annotate 'line', 1083
    .lex "self", param_2470
    .lex "$/", param_2471
    find_lex $P2472, "$/"
    find_lex $P2473, "$/"
    unless_null $P2473, vivify_775
    $P2473 = root_new ['parrot';'Hash']
  vivify_775:
    set $P2474, $P2473["quote_EXPR"]
    unless_null $P2474, vivify_776
    new $P2474, "Undef"
  vivify_776:
    $P2475 = $P2474."ast"()
    $P2476 = $P2472."!make"($P2475)
    .return ($P2476)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("128_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2478
    .param pmc param_2479
.annotate 'line', 1085
    .lex "self", param_2478
    .lex "$/", param_2479
.annotate 'line', 1086
    new $P2480, "Undef"
    .lex "$past", $P2480
    find_lex $P2483, "$/"
    unless_null $P2483, vivify_777
    $P2483 = root_new ['parrot';'Hash']
  vivify_777:
    set $P2484, $P2483["pblock"]
    unless_null $P2484, vivify_778
    $P2484 = root_new ['parrot';'Hash']
  vivify_778:
    set $P2485, $P2484["blockoid"]
    unless_null $P2485, vivify_779
    $P2485 = root_new ['parrot';'Hash']
  vivify_779:
    set $P2486, $P2485["statementlist"]
    unless_null $P2486, vivify_780
    $P2486 = root_new ['parrot';'Hash']
  vivify_780:
    set $P2487, $P2486["statement"]
    unless_null $P2487, vivify_781
    new $P2487, "Undef"
  vivify_781:
    set $N2488, $P2487
    isgt $I2489, $N2488, 0.0
    if $I2489, if_2482
.annotate 'line', 1088
    $P2493 = "vivitype"("%")
    set $P2481, $P2493
.annotate 'line', 1086
    goto if_2482_end
  if_2482:
.annotate 'line', 1087
    find_lex $P2490, "$/"
    unless_null $P2490, vivify_782
    $P2490 = root_new ['parrot';'Hash']
  vivify_782:
    set $P2491, $P2490["pblock"]
    unless_null $P2491, vivify_783
    new $P2491, "Undef"
  vivify_783:
    $P2492 = $P2491."ast"()
    set $P2481, $P2492
  if_2482_end:
    store_lex "$past", $P2481
.annotate 'line', 1089
    new $P2494, "Integer"
    assign $P2494, 1
    find_lex $P2495, "$past"
    unless_null $P2495, vivify_784
    $P2495 = root_new ['parrot';'Hash']
    store_lex "$past", $P2495
  vivify_784:
    set $P2495["bareblock"], $P2494
.annotate 'line', 1090
    find_lex $P2496, "$/"
    find_lex $P2497, "$past"
    $P2498 = $P2496."!make"($P2497)
.annotate 'line', 1085
    .return ($P2498)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("129_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2500
    .param pmc param_2501
.annotate 'line', 1093
    .lex "self", param_2500
    .lex "$/", param_2501
.annotate 'line', 1094
    new $P2502, "Undef"
    .lex "$name", $P2502
    find_lex $P2505, "$/"
    unless_null $P2505, vivify_785
    $P2505 = root_new ['parrot';'Hash']
  vivify_785:
    set $P2506, $P2505["sigil"]
    unless_null $P2506, vivify_786
    new $P2506, "Undef"
  vivify_786:
    set $S2507, $P2506
    iseq $I2508, $S2507, "@"
    if $I2508, if_2504
.annotate 'line', 1095
    find_lex $P2512, "$/"
    unless_null $P2512, vivify_787
    $P2512 = root_new ['parrot';'Hash']
  vivify_787:
    set $P2513, $P2512["sigil"]
    unless_null $P2513, vivify_788
    new $P2513, "Undef"
  vivify_788:
    set $S2514, $P2513
    iseq $I2515, $S2514, "%"
    if $I2515, if_2511
    new $P2517, "String"
    assign $P2517, "item"
    set $P2510, $P2517
    goto if_2511_end
  if_2511:
    new $P2516, "String"
    assign $P2516, "hash"
    set $P2510, $P2516
  if_2511_end:
    set $P2503, $P2510
.annotate 'line', 1094
    goto if_2504_end
  if_2504:
    new $P2509, "String"
    assign $P2509, "list"
    set $P2503, $P2509
  if_2504_end:
    store_lex "$name", $P2503
.annotate 'line', 1097
    find_lex $P2518, "$/"
    get_hll_global $P2519, ["PAST"], "Op"
    find_lex $P2520, "$name"
    find_lex $P2521, "$/"
    unless_null $P2521, vivify_789
    $P2521 = root_new ['parrot';'Hash']
  vivify_789:
    set $P2522, $P2521["semilist"]
    unless_null $P2522, vivify_790
    new $P2522, "Undef"
  vivify_790:
    $P2523 = $P2522."ast"()
    $P2524 = $P2519."new"($P2523, "callmethod" :named("pasttype"), $P2520 :named("name"))
    $P2525 = $P2518."!make"($P2524)
.annotate 'line', 1093
    .return ($P2525)
.end


.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("130_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2527
    .param pmc param_2528
.annotate 'line', 1100
    .lex "self", param_2527
    .lex "$/", param_2528
    find_lex $P2529, "$/"
    find_lex $P2530, "$/"
    unless_null $P2530, vivify_791
    $P2530 = root_new ['parrot';'Hash']
  vivify_791:
    set $P2531, $P2530["statement"]
    unless_null $P2531, vivify_792
    new $P2531, "Undef"
  vivify_792:
    $P2532 = $P2531."ast"()
    $P2533 = $P2529."!make"($P2532)
    .return ($P2533)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("131_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2535
    .param pmc param_2536
.annotate 'line', 1102
    .lex "self", param_2535
    .lex "$/", param_2536
.annotate 'line', 1103
    find_lex $P2537, "$/"
    get_hll_global $P2538, ["PAST"], "Var"
    find_lex $P2539, "$/"
    unless_null $P2539, vivify_793
    $P2539 = root_new ['parrot';'Hash']
  vivify_793:
    set $P2540, $P2539["EXPR"]
    unless_null $P2540, vivify_794
    new $P2540, "Undef"
  vivify_794:
    $P2541 = $P2540."ast"()
.annotate 'line', 1105
    $P2542 = "vivitype"("@")
    $P2543 = $P2538."new"($P2541, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2542 :named("vivibase"))
.annotate 'line', 1103
    $P2544 = $P2537."!make"($P2543)
.annotate 'line', 1102
    .return ($P2544)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("132_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2546
    .param pmc param_2547
.annotate 'line', 1108
    .lex "self", param_2546
    .lex "$/", param_2547
.annotate 'line', 1109
    find_lex $P2548, "$/"
    get_hll_global $P2549, ["PAST"], "Var"
    find_lex $P2550, "$/"
    unless_null $P2550, vivify_795
    $P2550 = root_new ['parrot';'Hash']
  vivify_795:
    set $P2551, $P2550["EXPR"]
    unless_null $P2551, vivify_796
    new $P2551, "Undef"
  vivify_796:
    $P2552 = $P2551."ast"()
.annotate 'line', 1111
    $P2553 = "vivitype"("%")
    $P2554 = $P2549."new"($P2552, "keyed" :named("scope"), "Undef" :named("viviself"), $P2553 :named("vivibase"))
.annotate 'line', 1109
    $P2555 = $P2548."!make"($P2554)
.annotate 'line', 1108
    .return ($P2555)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("133_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2557
    .param pmc param_2558
.annotate 'line', 1114
    .lex "self", param_2557
    .lex "$/", param_2558
.annotate 'line', 1115
    find_lex $P2559, "$/"
    get_hll_global $P2560, ["PAST"], "Var"
    find_lex $P2561, "$/"
    unless_null $P2561, vivify_797
    $P2561 = root_new ['parrot';'Hash']
  vivify_797:
    set $P2562, $P2561["quote_EXPR"]
    unless_null $P2562, vivify_798
    new $P2562, "Undef"
  vivify_798:
    $P2563 = $P2562."ast"()
.annotate 'line', 1117
    $P2564 = "vivitype"("%")
    $P2565 = $P2560."new"($P2563, "keyed" :named("scope"), "Undef" :named("viviself"), $P2564 :named("vivibase"))
.annotate 'line', 1115
    $P2566 = $P2559."!make"($P2565)
.annotate 'line', 1114
    .return ($P2566)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("134_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2568
    .param pmc param_2569
.annotate 'line', 1120
    .lex "self", param_2568
    .lex "$/", param_2569
.annotate 'line', 1121
    find_lex $P2570, "$/"
    find_lex $P2571, "$/"
    unless_null $P2571, vivify_799
    $P2571 = root_new ['parrot';'Hash']
  vivify_799:
    set $P2572, $P2571["arglist"]
    unless_null $P2572, vivify_800
    new $P2572, "Undef"
  vivify_800:
    $P2573 = $P2572."ast"()
    $P2574 = $P2570."!make"($P2573)
.annotate 'line', 1120
    .return ($P2574)
.end


.namespace ["NQP";"Actions"]
.sub "value"  :subid("135_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2576
    .param pmc param_2577
.annotate 'line', 1124
    .lex "self", param_2576
    .lex "$/", param_2577
.annotate 'line', 1125
    find_lex $P2578, "$/"
    find_lex $P2581, "$/"
    unless_null $P2581, vivify_801
    $P2581 = root_new ['parrot';'Hash']
  vivify_801:
    set $P2582, $P2581["quote"]
    unless_null $P2582, vivify_802
    new $P2582, "Undef"
  vivify_802:
    if $P2582, if_2580
    find_lex $P2586, "$/"
    unless_null $P2586, vivify_803
    $P2586 = root_new ['parrot';'Hash']
  vivify_803:
    set $P2587, $P2586["number"]
    unless_null $P2587, vivify_804
    new $P2587, "Undef"
  vivify_804:
    $P2588 = $P2587."ast"()
    set $P2579, $P2588
    goto if_2580_end
  if_2580:
    find_lex $P2583, "$/"
    unless_null $P2583, vivify_805
    $P2583 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2584, $P2583["quote"]
    unless_null $P2584, vivify_806
    new $P2584, "Undef"
  vivify_806:
    $P2585 = $P2584."ast"()
    set $P2579, $P2585
  if_2580_end:
    $P2589 = $P2578."!make"($P2579)
.annotate 'line', 1124
    .return ($P2589)
.end


.namespace ["NQP";"Actions"]
.sub "number"  :subid("136_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2591
    .param pmc param_2592
.annotate 'line', 1128
    .lex "self", param_2591
    .lex "$/", param_2592
.annotate 'line', 1129
    new $P2593, "Undef"
    .lex "$value", $P2593
    find_lex $P2596, "$/"
    unless_null $P2596, vivify_807
    $P2596 = root_new ['parrot';'Hash']
  vivify_807:
    set $P2597, $P2596["dec_number"]
    unless_null $P2597, vivify_808
    new $P2597, "Undef"
  vivify_808:
    if $P2597, if_2595
    find_lex $P2601, "$/"
    unless_null $P2601, vivify_809
    $P2601 = root_new ['parrot';'Hash']
  vivify_809:
    set $P2602, $P2601["integer"]
    unless_null $P2602, vivify_810
    new $P2602, "Undef"
  vivify_810:
    $P2603 = $P2602."ast"()
    set $P2594, $P2603
    goto if_2595_end
  if_2595:
    find_lex $P2598, "$/"
    unless_null $P2598, vivify_811
    $P2598 = root_new ['parrot';'Hash']
  vivify_811:
    set $P2599, $P2598["dec_number"]
    unless_null $P2599, vivify_812
    new $P2599, "Undef"
  vivify_812:
    $P2600 = $P2599."ast"()
    set $P2594, $P2600
  if_2595_end:
    store_lex "$value", $P2594
.annotate 'line', 1130
    find_lex $P2605, "$/"
    unless_null $P2605, vivify_813
    $P2605 = root_new ['parrot';'Hash']
  vivify_813:
    set $P2606, $P2605["sign"]
    unless_null $P2606, vivify_814
    new $P2606, "Undef"
  vivify_814:
    set $S2607, $P2606
    iseq $I2608, $S2607, "-"
    unless $I2608, if_2604_end
    find_lex $P2609, "$value"
    neg $P2610, $P2609
    store_lex "$value", $P2610
  if_2604_end:
.annotate 'line', 1131
    find_lex $P2611, "$/"
    get_hll_global $P2612, ["PAST"], "Val"
    find_lex $P2613, "$value"
    $P2614 = $P2612."new"($P2613 :named("value"))
    $P2615 = $P2611."!make"($P2614)
.annotate 'line', 1128
    .return ($P2615)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("137_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2617
    .param pmc param_2618
.annotate 'line', 1134
    .lex "self", param_2617
    .lex "$/", param_2618
    find_lex $P2619, "$/"
    find_lex $P2620, "$/"
    unless_null $P2620, vivify_815
    $P2620 = root_new ['parrot';'Hash']
  vivify_815:
    set $P2621, $P2620["quote_EXPR"]
    unless_null $P2621, vivify_816
    new $P2621, "Undef"
  vivify_816:
    $P2622 = $P2621."ast"()
    $P2623 = $P2619."!make"($P2622)
    .return ($P2623)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("138_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2625
    .param pmc param_2626
.annotate 'line', 1135
    .lex "self", param_2625
    .lex "$/", param_2626
    find_lex $P2627, "$/"
    find_lex $P2628, "$/"
    unless_null $P2628, vivify_817
    $P2628 = root_new ['parrot';'Hash']
  vivify_817:
    set $P2629, $P2628["quote_EXPR"]
    unless_null $P2629, vivify_818
    new $P2629, "Undef"
  vivify_818:
    $P2630 = $P2629."ast"()
    $P2631 = $P2627."!make"($P2630)
    .return ($P2631)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("139_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2633
    .param pmc param_2634
.annotate 'line', 1136
    .lex "self", param_2633
    .lex "$/", param_2634
    find_lex $P2635, "$/"
    find_lex $P2636, "$/"
    unless_null $P2636, vivify_819
    $P2636 = root_new ['parrot';'Hash']
  vivify_819:
    set $P2637, $P2636["quote_EXPR"]
    unless_null $P2637, vivify_820
    new $P2637, "Undef"
  vivify_820:
    $P2638 = $P2637."ast"()
    $P2639 = $P2635."!make"($P2638)
    .return ($P2639)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("140_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2641
    .param pmc param_2642
.annotate 'line', 1137
    .lex "self", param_2641
    .lex "$/", param_2642
    find_lex $P2643, "$/"
    find_lex $P2644, "$/"
    unless_null $P2644, vivify_821
    $P2644 = root_new ['parrot';'Hash']
  vivify_821:
    set $P2645, $P2644["quote_EXPR"]
    unless_null $P2645, vivify_822
    new $P2645, "Undef"
  vivify_822:
    $P2646 = $P2645."ast"()
    $P2647 = $P2643."!make"($P2646)
    .return ($P2647)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("141_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2649
    .param pmc param_2650
.annotate 'line', 1138
    .lex "self", param_2649
    .lex "$/", param_2650
    find_lex $P2651, "$/"
    find_lex $P2652, "$/"
    unless_null $P2652, vivify_823
    $P2652 = root_new ['parrot';'Hash']
  vivify_823:
    set $P2653, $P2652["quote_EXPR"]
    unless_null $P2653, vivify_824
    new $P2653, "Undef"
  vivify_824:
    $P2654 = $P2653."ast"()
    $P2655 = $P2651."!make"($P2654)
    .return ($P2655)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("142_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2657
    .param pmc param_2658
.annotate 'line', 1139
    .lex "self", param_2657
    .lex "$/", param_2658
.annotate 'line', 1140
    find_lex $P2659, "$/"
    get_hll_global $P2660, ["PAST"], "Op"
    find_lex $P2661, "$/"
    unless_null $P2661, vivify_825
    $P2661 = root_new ['parrot';'Hash']
  vivify_825:
    set $P2662, $P2661["quote_EXPR"]
    unless_null $P2662, vivify_826
    new $P2662, "Undef"
  vivify_826:
    $P2663 = $P2662."ast"()
    $P2664 = $P2663."value"()
    find_lex $P2665, "$/"
    $P2666 = $P2660."new"($P2664 :named("inline"), "inline" :named("pasttype"), $P2665 :named("node"))
    $P2667 = $P2659."!make"($P2666)
.annotate 'line', 1139
    .return ($P2667)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("143_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2671
    .param pmc param_2672
    .param pmc param_2673 :optional
    .param int has_param_2673 :opt_flag
.annotate 'line', 1145
    new $P2670, ['ExceptionHandler'], .CONTROL_RETURN
    set_addr $P2670, control_2669
    push_eh $P2670
    .lex "self", param_2671
    .lex "$/", param_2672
    if has_param_2673, optparam_827
    new $P2674, "Undef"
    set param_2673, $P2674
  optparam_827:
    .lex "$key", param_2673
.annotate 'line', 1155
    new $P2675, "Undef"
    .lex "$regex", $P2675
.annotate 'line', 1157
    new $P2676, "Undef"
    .lex "$past", $P2676
.annotate 'line', 1146
    find_lex $P2678, "$key"
    set $S2679, $P2678
    iseq $I2680, $S2679, "open"
    unless $I2680, if_2677_end
.annotate 'line', 1147

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1151
    get_global $P2681, "@BLOCK"
    unless_null $P2681, vivify_828
    $P2681 = root_new ['parrot';'ResizablePMCArray']
  vivify_828:
    set $P2682, $P2681[0]
    unless_null $P2682, vivify_829
    new $P2682, "Undef"
  vivify_829:
    $P2682."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1152
    get_global $P2683, "@BLOCK"
    unless_null $P2683, vivify_830
    $P2683 = root_new ['parrot';'ResizablePMCArray']
  vivify_830:
    set $P2684, $P2683[0]
    unless_null $P2684, vivify_831
    new $P2684, "Undef"
  vivify_831:
    $P2684."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1153
    new $P2685, "Exception"
    set $P2685['type'], .CONTROL_RETURN
    new $P2686, "Integer"
    assign $P2686, 0
    setattribute $P2685, 'payload', $P2686
    throw $P2685
  if_2677_end:
.annotate 'line', 1156
    get_hll_global $P2687, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2688, "$/"
    unless_null $P2688, vivify_832
    $P2688 = root_new ['parrot';'Hash']
  vivify_832:
    set $P2689, $P2688["p6regex"]
    unless_null $P2689, vivify_833
    new $P2689, "Undef"
  vivify_833:
    $P2690 = $P2689."ast"()
    get_global $P2691, "@BLOCK"
    $P2692 = $P2691."shift"()
    $P2693 = $P2687($P2690, $P2692)
    store_lex "$regex", $P2693
.annotate 'line', 1158
    get_hll_global $P2694, ["PAST"], "Op"
.annotate 'line', 1160
    get_hll_global $P2695, ["PAST"], "Var"
    new $P2696, "ResizablePMCArray"
    push $P2696, "Regex"
    $P2697 = $P2695."new"("Regex" :named("name"), $P2696 :named("namespace"), "package" :named("scope"))
    find_lex $P2698, "$regex"
    $P2699 = $P2694."new"($P2697, $P2698, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1158
    store_lex "$past", $P2699
.annotate 'line', 1164
    find_lex $P2700, "$regex"
    find_lex $P2701, "$past"
    unless_null $P2701, vivify_834
    $P2701 = root_new ['parrot';'Hash']
    store_lex "$past", $P2701
  vivify_834:
    set $P2701["sink"], $P2700
.annotate 'line', 1165
    find_lex $P2702, "$/"
    find_lex $P2703, "$past"
    $P2704 = $P2702."!make"($P2703)
.annotate 'line', 1145
    .return ($P2704)
  control_2669:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2705, exception, "payload"
    .return ($P2705)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("144_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2707
    .param pmc param_2708
.annotate 'line', 1168
    .lex "self", param_2707
    .lex "$/", param_2708
    find_lex $P2709, "$/"
    find_lex $P2710, "$/"
    unless_null $P2710, vivify_835
    $P2710 = root_new ['parrot';'Hash']
  vivify_835:
    set $P2711, $P2710["variable"]
    unless_null $P2711, vivify_836
    new $P2711, "Undef"
  vivify_836:
    $P2712 = $P2711."ast"()
    $P2713 = $P2709."!make"($P2712)
    .return ($P2713)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("145_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2715
    .param pmc param_2716
.annotate 'line', 1169
    .lex "self", param_2715
    .lex "$/", param_2716
.annotate 'line', 1170
    find_lex $P2717, "$/"
    get_hll_global $P2718, ["PAST"], "Op"
.annotate 'line', 1171
    find_lex $P2719, "$/"
    unless_null $P2719, vivify_837
    $P2719 = root_new ['parrot';'Hash']
  vivify_837:
    set $P2720, $P2719["block"]
    unless_null $P2720, vivify_838
    new $P2720, "Undef"
  vivify_838:
    $P2721 = $P2720."ast"()
    $P2722 = "block_immediate"($P2721)
    find_lex $P2723, "$/"
    $P2724 = $P2718."new"($P2722, "set S*" :named("pirop"), $P2723 :named("node"))
.annotate 'line', 1170
    $P2725 = $P2717."!make"($P2724)
.annotate 'line', 1169
    .return ($P2725)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("146_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2727
    .param pmc param_2728
.annotate 'line', 1174
    .lex "self", param_2727
    .lex "$/", param_2728
    find_lex $P2729, "$/"
    $P2730 = $P2729."!make"("\e")
    .return ($P2730)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("147_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2732
    .param pmc param_2733
.annotate 'line', 1178
    .lex "self", param_2732
    .lex "$/", param_2733
    find_lex $P2734, "$/"
    find_lex $P2735, "$/"
    unless_null $P2735, vivify_839
    $P2735 = root_new ['parrot';'Hash']
  vivify_839:
    set $P2736, $P2735["dotty"]
    unless_null $P2736, vivify_840
    new $P2736, "Undef"
  vivify_840:
    $P2737 = $P2736."ast"()
    $P2738 = $P2734."!make"($P2737)
    .return ($P2738)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("148_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2740
    .param pmc param_2741
.annotate 'line', 1180
    .lex "self", param_2740
    .lex "$/", param_2741
.annotate 'line', 1181
    find_lex $P2742, "$/"
    get_hll_global $P2743, ["PAST"], "Op"
.annotate 'line', 1182
    new $P2744, "ResizablePMCArray"
    push $P2744, "    clone %r, %0"
    push $P2744, "    inc %0"
    $P2745 = $P2743."new"("postfix:<++>" :named("name"), $P2744 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1181
    $P2746 = $P2742."!make"($P2745)
.annotate 'line', 1180
    .return ($P2746)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("149_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2748
    .param pmc param_2749
.annotate 'line', 1186
    .lex "self", param_2748
    .lex "$/", param_2749
.annotate 'line', 1187
    find_lex $P2750, "$/"
    get_hll_global $P2751, ["PAST"], "Op"
.annotate 'line', 1188
    new $P2752, "ResizablePMCArray"
    push $P2752, "    clone %r, %0"
    push $P2752, "    dec %0"
    $P2753 = $P2751."new"("postfix:<-->" :named("name"), $P2752 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1187
    $P2754 = $P2750."!make"($P2753)
.annotate 'line', 1186
    .return ($P2754)
.end


.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("150_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2756
    .param pmc param_2757
.annotate 'line', 1192
    .lex "self", param_2756
    .lex "$/", param_2757
.annotate 'line', 1193
    find_lex $P2758, "$/"
    get_hll_global $P2759, ["PAST"], "Op"
.annotate 'line', 1194
    get_hll_global $P2760, ["PAST"], "Var"
    $P2761 = $P2760."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2762, "$/"
    $P2763 = $P2759."new"($P2761, "callmethod" :named("pasttype"), "!make" :named("name"), $P2762 :named("node"))
.annotate 'line', 1193
    $P2764 = $P2758."!make"($P2763)
.annotate 'line', 1192
    .return ($P2764)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("151_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2767
    .param pmc param_2768
.annotate 'line', 1210
    .lex "self", param_2767
    .lex "$/", param_2768
    find_lex $P2769, "$/"
    $P2770 = "control"($P2769, "CONTROL_LOOP_NEXT")
    .return ($P2770)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("152_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2772
    .param pmc param_2773
.annotate 'line', 1211
    .lex "self", param_2772
    .lex "$/", param_2773
    find_lex $P2774, "$/"
    $P2775 = "control"($P2774, "CONTROL_LOOP_LAST")
    .return ($P2775)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("153_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2777
    .param pmc param_2778
.annotate 'line', 1212
    .lex "self", param_2777
    .lex "$/", param_2778
    find_lex $P2779, "$/"
    $P2780 = "control"($P2779, "CONTROL_LOOP_REDO")
    .return ($P2780)
.end


.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("154_1295994666.515") :outer("11_1295994666.515")
    .param pmc param_2782
    .param pmc param_2783
.annotate 'line', 1214
    .lex "self", param_2782
    .lex "$/", param_2783
.annotate 'line', 1215
    find_lex $P2784, "$/"
    get_hll_global $P2785, ["PAST"], "Op"
    find_lex $P2786, "$/"
    $P2787 = $P2785."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2786 :named("node"))
    $P2788 = $P2784."!make"($P2787)
.annotate 'line', 1214
    .return ($P2788)
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2789"  :subid("155_1295994666.515") :outer("11_1295994666.515")
.annotate 'line', 1219
    .const 'Sub' $P2889 = "163_1295994666.515" 
    capture_lex $P2889
    .const 'Sub' $P2864 = "162_1295994666.515" 
    capture_lex $P2864
    .const 'Sub' $P2853 = "161_1295994666.515" 
    capture_lex $P2853
    .const 'Sub' $P2838 = "160_1295994666.515" 
    capture_lex $P2838
    .const 'Sub' $P2827 = "159_1295994666.515" 
    capture_lex $P2827
    .const 'Sub' $P2816 = "158_1295994666.515" 
    capture_lex $P2816
    .const 'Sub' $P2805 = "157_1295994666.515" 
    capture_lex $P2805
    .const 'Sub' $P2792 = "156_1295994666.515" 
    capture_lex $P2792
    get_global $P2791, "$?CLASS"
.annotate 'line', 1253
    .const 'Sub' $P2864 = "162_1295994666.515" 
    newclosure $P2887, $P2864
.annotate 'line', 1219
    .return ($P2887)
.end


.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post841") :outer("155_1295994666.515")
.annotate 'line', 1219
    get_hll_global $P2790, ["NQP";"RegexActions"], "_block2789" 
    .local pmc block
    set block, $P2790
    .const 'Sub' $P2889 = "163_1295994666.515" 
    capture_lex $P2889
    $P2889()
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2888"  :anon :subid("163_1295994666.515") :outer("155_1295994666.515")
.annotate 'line', 1219
    get_hll_global $P2890, "NQPClassHOW"
    $P2891 = $P2890."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2891
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2892, type_obj
    .const 'Sub' $P2893 = "156_1295994666.515" 
    $P2892."add_method"(type_obj, "metachar:sym<:my>", $P2893)
    get_how $P2894, type_obj
    .const 'Sub' $P2895 = "157_1295994666.515" 
    $P2894."add_method"(type_obj, "metachar:sym<{ }>", $P2895)
    get_how $P2896, type_obj
    .const 'Sub' $P2897 = "158_1295994666.515" 
    $P2896."add_method"(type_obj, "metachar:sym<nqpvar>", $P2897)
    get_how $P2898, type_obj
    .const 'Sub' $P2899 = "159_1295994666.515" 
    $P2898."add_method"(type_obj, "assertion:sym<{ }>", $P2899)
    get_how $P2900, type_obj
    .const 'Sub' $P2901 = "160_1295994666.515" 
    $P2900."add_method"(type_obj, "assertion:sym<?{ }>", $P2901)
    get_how $P2902, type_obj
    .const 'Sub' $P2903 = "161_1295994666.515" 
    $P2902."add_method"(type_obj, "assertion:sym<var>", $P2903)
    get_how $P2904, type_obj
    .const 'Sub' $P2905 = "162_1295994666.515" 
    $P2904."add_method"(type_obj, "codeblock", $P2905)
    get_how $P2906, type_obj
    get_hll_global $P2907, ["Regex";"P6Regex"], "Actions"
    $P2906."add_parent"(type_obj, $P2907)
    get_how $P2908, type_obj
    $P2909 = $P2908."compose"(type_obj)
    .return ($P2909)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("156_1295994666.515") :outer("155_1295994666.515")
    .param pmc param_2793
    .param pmc param_2794
.annotate 'line', 1221
    .lex "self", param_2793
    .lex "$/", param_2794
.annotate 'line', 1222
    new $P2795, "Undef"
    .lex "$past", $P2795
    find_lex $P2796, "$/"
    unless_null $P2796, vivify_842
    $P2796 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2797, $P2796["statement"]
    unless_null $P2797, vivify_843
    new $P2797, "Undef"
  vivify_843:
    $P2798 = $P2797."ast"()
    store_lex "$past", $P2798
.annotate 'line', 1223
    find_lex $P2799, "$/"
    get_hll_global $P2800, ["PAST"], "Regex"
    find_lex $P2801, "$past"
    find_lex $P2802, "$/"
    $P2803 = $P2800."new"($P2801, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2802 :named("node"))
    $P2804 = $P2799."!make"($P2803)
.annotate 'line', 1221
    .return ($P2804)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("157_1295994666.515") :outer("155_1295994666.515")
    .param pmc param_2806
    .param pmc param_2807
.annotate 'line', 1227
    .lex "self", param_2806
    .lex "$/", param_2807
.annotate 'line', 1228
    find_lex $P2808, "$/"
    get_hll_global $P2809, ["PAST"], "Regex"
    find_lex $P2810, "$/"
    unless_null $P2810, vivify_844
    $P2810 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2811, $P2810["codeblock"]
    unless_null $P2811, vivify_845
    new $P2811, "Undef"
  vivify_845:
    $P2812 = $P2811."ast"()
    find_lex $P2813, "$/"
    $P2814 = $P2809."new"($P2812, "pastnode" :named("pasttype"), $P2813 :named("node"))
    $P2815 = $P2808."!make"($P2814)
.annotate 'line', 1227
    .return ($P2815)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("158_1295994666.515") :outer("155_1295994666.515")
    .param pmc param_2817
    .param pmc param_2818
.annotate 'line', 1232
    .lex "self", param_2817
    .lex "$/", param_2818
.annotate 'line', 1233
    find_lex $P2819, "$/"
    get_hll_global $P2820, ["PAST"], "Regex"
    find_lex $P2821, "$/"
    unless_null $P2821, vivify_846
    $P2821 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2822, $P2821["var"]
    unless_null $P2822, vivify_847
    new $P2822, "Undef"
  vivify_847:
    $P2823 = $P2822."ast"()
    find_lex $P2824, "$/"
    $P2825 = $P2820."new"("!INTERPOLATE", $P2823, "subrule" :named("pasttype"), "method" :named("subtype"), $P2824 :named("node"))
    $P2826 = $P2819."!make"($P2825)
.annotate 'line', 1232
    .return ($P2826)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("159_1295994666.515") :outer("155_1295994666.515")
    .param pmc param_2828
    .param pmc param_2829
.annotate 'line', 1237
    .lex "self", param_2828
    .lex "$/", param_2829
.annotate 'line', 1238
    find_lex $P2830, "$/"
    get_hll_global $P2831, ["PAST"], "Regex"
    find_lex $P2832, "$/"
    unless_null $P2832, vivify_848
    $P2832 = root_new ['parrot';'Hash']
  vivify_848:
    set $P2833, $P2832["codeblock"]
    unless_null $P2833, vivify_849
    new $P2833, "Undef"
  vivify_849:
    $P2834 = $P2833."ast"()
    find_lex $P2835, "$/"
    $P2836 = $P2831."new"("!INTERPOLATE_REGEX", $P2834, "subrule" :named("pasttype"), "method" :named("subtype"), $P2835 :named("node"))
    $P2837 = $P2830."!make"($P2836)
.annotate 'line', 1237
    .return ($P2837)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("160_1295994666.515") :outer("155_1295994666.515")
    .param pmc param_2839
    .param pmc param_2840
.annotate 'line', 1242
    .lex "self", param_2839
    .lex "$/", param_2840
.annotate 'line', 1243
    find_lex $P2841, "$/"
    get_hll_global $P2842, ["PAST"], "Regex"
    find_lex $P2843, "$/"
    unless_null $P2843, vivify_850
    $P2843 = root_new ['parrot';'Hash']
  vivify_850:
    set $P2844, $P2843["codeblock"]
    unless_null $P2844, vivify_851
    new $P2844, "Undef"
  vivify_851:
    $P2845 = $P2844."ast"()
.annotate 'line', 1244
    find_lex $P2846, "$/"
    unless_null $P2846, vivify_852
    $P2846 = root_new ['parrot';'Hash']
  vivify_852:
    set $P2847, $P2846["zw"]
    unless_null $P2847, vivify_853
    new $P2847, "Undef"
  vivify_853:
    set $S2848, $P2847
    iseq $I2849, $S2848, "!"
    find_lex $P2850, "$/"
    $P2851 = $P2842."new"($P2845, "zerowidth" :named("subtype"), $I2849 :named("negate"), "pastnode" :named("pasttype"), $P2850 :named("node"))
.annotate 'line', 1243
    $P2852 = $P2841."!make"($P2851)
.annotate 'line', 1242
    .return ($P2852)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("161_1295994666.515") :outer("155_1295994666.515")
    .param pmc param_2854
    .param pmc param_2855
.annotate 'line', 1248
    .lex "self", param_2854
    .lex "$/", param_2855
.annotate 'line', 1249
    find_lex $P2856, "$/"
    get_hll_global $P2857, ["PAST"], "Regex"
    find_lex $P2858, "$/"
    unless_null $P2858, vivify_854
    $P2858 = root_new ['parrot';'Hash']
  vivify_854:
    set $P2859, $P2858["var"]
    unless_null $P2859, vivify_855
    new $P2859, "Undef"
  vivify_855:
    $P2860 = $P2859."ast"()
    find_lex $P2861, "$/"
    $P2862 = $P2857."new"("!INTERPOLATE_REGEX", $P2860, "subrule" :named("pasttype"), "method" :named("subtype"), $P2861 :named("node"))
    $P2863 = $P2856."!make"($P2862)
.annotate 'line', 1248
    .return ($P2863)
.end


.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("162_1295994666.515") :outer("155_1295994666.515")
    .param pmc param_2865
    .param pmc param_2866
.annotate 'line', 1253
    .lex "self", param_2865
    .lex "$/", param_2866
.annotate 'line', 1254
    new $P2867, "Undef"
    .lex "$block", $P2867
.annotate 'line', 1256
    new $P2868, "Undef"
    .lex "$past", $P2868
.annotate 'line', 1254
    find_lex $P2869, "$/"
    unless_null $P2869, vivify_856
    $P2869 = root_new ['parrot';'Hash']
  vivify_856:
    set $P2870, $P2869["block"]
    unless_null $P2870, vivify_857
    new $P2870, "Undef"
  vivify_857:
    $P2871 = $P2870."ast"()
    store_lex "$block", $P2871
.annotate 'line', 1255
    find_lex $P2872, "$block"
    $P2872."blocktype"("immediate")
.annotate 'line', 1257
    get_hll_global $P2873, ["PAST"], "Stmts"
.annotate 'line', 1258
    get_hll_global $P2874, ["PAST"], "Op"
.annotate 'line', 1259
    get_hll_global $P2875, ["PAST"], "Var"
    $P2876 = $P2875."new"("$/" :named("name"))
.annotate 'line', 1260
    get_hll_global $P2877, ["PAST"], "Op"
.annotate 'line', 1261
    get_hll_global $P2878, ["PAST"], "Var"
    $P2879 = $P2878."new"(unicode:"$\x{a2}" :named("name"))
    $P2880 = $P2877."new"($P2879, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1260
    $P2881 = $P2874."new"($P2876, $P2880, "bind" :named("pasttype"))
.annotate 'line', 1258
    find_lex $P2882, "$block"
    $P2883 = $P2873."new"($P2881, $P2882)
.annotate 'line', 1257
    store_lex "$past", $P2883
.annotate 'line', 1269
    find_lex $P2884, "$/"
    find_lex $P2885, "$past"
    $P2886 = $P2884."!make"($P2885)
.annotate 'line', 1253
    .return ($P2886)
.end


.namespace ["NQP";"Actions"]
.sub "_block2911" :load :anon :subid("164_1295994666.515")
.annotate 'line', 3
    .const 'Sub' $P2913 = "11_1295994666.515" 
    $P2914 = $P2913()
    .return ($P2914)
.end


.namespace []
.sub "_block3134" :load :anon :subid("166_1295994666.515")
.annotate 'line', 1
    .const 'Sub' $P3136 = "10_1295994666.515" 
    $P3137 = $P3136()
    .return ($P3137)
.end

### .include 'gen/nqp-compiler.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1295994669.593")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
    $P25 = $P15()
    .return ($P25)
    .const 'Sub' $P27 = "13_1295994669.593" 
    .return ($P27)
.end


.namespace ["NQP";"Compiler"]
.sub "_block14"  :subid("11_1295994669.593") :outer("10_1295994669.593")
.annotate 'line', 1
    .const 'Sub' $P18 = "12_1295994669.593" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    .return ()
.end


.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post14") :outer("11_1295994669.593")
.annotate 'line', 1
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P18 = "12_1295994669.593" 
    capture_lex $P18
    $P18()
.end


.namespace ["NQP";"Compiler"]
.sub "_block17"  :anon :subid("12_1295994669.593") :outer("11_1295994669.593")
.annotate 'line', 1
    get_hll_global $P19, "NQPClassHOW"
    $P20 = $P19."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P20
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P21, type_obj
    get_hll_global $P22, ["HLL"], "Compiler"
    $P21."add_parent"(type_obj, $P22)
    get_how $P23, type_obj
    $P24 = $P23."compose"(type_obj)
    .return ($P24)
.end


.namespace []
.sub "_block26" :load :anon :subid("13_1295994669.593")
.annotate 'line', 1
    .const 'Sub' $P28 = "10_1295994669.593" 
    $P29 = $P28()
    .return ($P29)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " # "
        print description
  no_description:
    print "\n"
    .return (1)
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('NQP-rx')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'NQP-rx'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
