# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup
.end
### .include 'gen/nqp-how.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298845494.89")
.annotate 'line', 0
    get_hll_global $P2508, ["NQPMu"], "_block2507" 
    capture_lex $P2508
    get_hll_global $P2499, ["str"], "_block2498" 
    capture_lex $P2499
    get_hll_global $P2490, ["num"], "_block2489" 
    capture_lex $P2490
    get_hll_global $P2481, ["int"], "_block2480" 
    capture_lex $P2481
    get_hll_global $P2392, ["NQPModuleHOW"], "_block2391" 
    capture_lex $P2392
    get_hll_global $P2162, ["RoleToRoleApplier"], "_block2161" 
    capture_lex $P2162
    get_hll_global $P1946, ["RoleToClassApplier"], "_block1945" 
    capture_lex $P1946
    get_hll_global $P1590, ["NQPParametricRoleHOW"], "_block1589" 
    capture_lex $P1590
    get_hll_global $P1268, ["NQPConcreteRoleHOW"], "_block1267" 
    capture_lex $P1268
    get_hll_global $P1184, ["NQPAttribute"], "_block1183" 
    capture_lex $P1184
    get_hll_global $P1096, ["NQPNativeHOW"], "_block1095" 
    capture_lex $P1096
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, "NQPMu"
    get_hll_global $P14, "str"
    get_hll_global $P15, "num"
    get_hll_global $P16, "int"
    get_hll_global $P17, "NQPModuleHOW"
    get_hll_global $P18, "RoleToRoleApplier"
    get_hll_global $P19, "RoleToClassApplier"
    get_hll_global $P20, "NQPParametricRoleHOW"
    get_hll_global $P21, "NQPConcreteRoleHOW"
    get_hll_global $P22, "NQPAttribute"
    get_hll_global $P23, "NQPNativeHOW"
    get_hll_global $P24, "NQPClassHOW"
    get_hll_global $P25, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
    $P27()
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    $P53()
.annotate 'line', 451
    get_hll_global $P1096, ["NQPNativeHOW"], "_block1095" 
    capture_lex $P1096
    $P1096()
.annotate 'line', 495
    get_hll_global $P1184, ["NQPAttribute"], "_block1183" 
    capture_lex $P1184
    $P1184()
.annotate 'line', 528
    get_hll_global $P1268, ["NQPConcreteRoleHOW"], "_block1267" 
    capture_lex $P1268
    $P1268()
.annotate 'line', 677
    get_hll_global $P1590, ["NQPParametricRoleHOW"], "_block1589" 
    capture_lex $P1590
    $P1590()
.annotate 'line', 843
    get_hll_global $P1946, ["RoleToClassApplier"], "_block1945" 
    capture_lex $P1946
    $P1946()
.annotate 'line', 915
    get_hll_global $P2162, ["RoleToRoleApplier"], "_block2161" 
    capture_lex $P2162
    $P2162()
.annotate 'line', 1005
    get_hll_global $P2392, ["NQPModuleHOW"], "_block2391" 
    capture_lex $P2392
    $P2392()
.annotate 'line', 1050
    get_hll_global $P2481, ["int"], "_block2480" 
    capture_lex $P2481
    $P2481()
.annotate 'line', 1052
    get_hll_global $P2490, ["num"], "_block2489" 
    capture_lex $P2490
    $P2490()
.annotate 'line', 1054
    get_hll_global $P2499, ["str"], "_block2498" 
    capture_lex $P2499
    $P2499()
.annotate 'line', 1057
    get_hll_global $P2508, ["NQPMu"], "_block2507" 
    capture_lex $P2508
    $P2661 = $P2508()
.annotate 'line', 1
    .return ($P2661)
    .const 'Sub' $P2663 = "185_1298845494.89" 
    .return ($P2663)
.end


.namespace ["KnowHOWAttribute"]
.sub "_block26"  :subid("11_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 10
    .const 'Sub' $P43 = "14_1298845494.89" 
    capture_lex $P43
    .const 'Sub' $P37 = "13_1298845494.89" 
    capture_lex $P37
    .const 'Sub' $P29 = "12_1298845494.89" 
    capture_lex $P29
    get_global $P28, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P37 = "13_1298845494.89" 
    newclosure $P41, $P37
.annotate 'line', 10
    .return ($P41)
.end


.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post186") :outer("11_1298845494.89")
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    .local pmc block
    set block, $P27
    .const 'Sub' $P43 = "14_1298845494.89" 
    capture_lex $P43
    $P43()
.end


.namespace ["KnowHOWAttribute"]
.sub "_block42"  :anon :subid("14_1298845494.89") :outer("11_1298845494.89")
.annotate 'line', 10
    get_hll_global $P44, "KnowHOW"
    $P45 = $P44."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P45
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P46, type_obj
    .const 'Sub' $P47 = "12_1298845494.89" 
    $P46."add_method"(type_obj, "new", $P47)
    get_how $P48, type_obj
    .const 'Sub' $P49 = "13_1298845494.89" 
    $P48."add_method"(type_obj, "name", $P49)
    get_how $P50, type_obj
    $P51 = $P50."compose"(type_obj)
    .return ($P51)
.end


.namespace ["KnowHOWAttribute"]
.sub "new"  :subid("12_1298845494.89") :outer("11_1298845494.89")
    .param pmc param_30
    .param pmc param_31 :optional :named("name")
    .param int has_param_31 :opt_flag
.annotate 'line', 11
    .lex "self", param_30
    if has_param_31, optparam_187
    new $P32, "Undef"
    set param_31, $P32
  optparam_187:
    .lex "$name", param_31
.annotate 'line', 12
    find_lex $P33, "$name"
    set $S34, $P33
    get_hll_global $P35, "KnowHOWAttribute"
    repr_box_str $P36, $S34, $P35
.annotate 'line', 11
    .return ($P36)
.end


.namespace ["KnowHOWAttribute"]
.sub "name"  :subid("13_1298845494.89") :outer("11_1298845494.89")
    .param pmc param_38
.annotate 'line', 14
    .lex "self", param_38
.annotate 'line', 15
    find_lex $P39, "self"
    repr_unbox_str $S40, $P39
.annotate 'line', 14
    .return ($S40)
.end


.namespace ["NQPClassHOW"]
.sub "_block52"  :subid("15_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 26
    .const 'Sub' $P1004 = "69_1298845494.89" 
    capture_lex $P1004
    .const 'Sub' $P967 = "67_1298845494.89" 
    capture_lex $P967
    .const 'Sub' $P931 = "65_1298845494.89" 
    capture_lex $P931
    .const 'Sub' $P897 = "64_1298845494.89" 
    capture_lex $P897
    .const 'Sub' $P860 = "63_1298845494.89" 
    capture_lex $P860
    .const 'Sub' $P853 = "62_1298845494.89" 
    capture_lex $P853
    .const 'Sub' $P830 = "60_1298845494.89" 
    capture_lex $P830
    .const 'Sub' $P824 = "59_1298845494.89" 
    capture_lex $P824
    .const 'Sub' $P818 = "58_1298845494.89" 
    capture_lex $P818
    .const 'Sub' $P795 = "56_1298845494.89" 
    capture_lex $P795
    .const 'Sub' $P788 = "55_1298845494.89" 
    capture_lex $P788
    .const 'Sub' $P774 = "54_1298845494.89" 
    capture_lex $P774
    .const 'Sub' $P725 = "51_1298845494.89" 
    capture_lex $P725
    .const 'Sub' $P680 = "48_1298845494.89" 
    capture_lex $P680
    .const 'Sub' $P643 = "45_1298845494.89" 
    capture_lex $P643
    .const 'Sub' $P513 = "40_1298845494.89" 
    capture_lex $P513
    .const 'Sub' $P424 = "37_1298845494.89" 
    capture_lex $P424
    .const 'Sub' $P398 = "36_1298845494.89" 
    capture_lex $P398
    .const 'Sub' $P364 = "34_1298845494.89" 
    capture_lex $P364
    .const 'Sub' $P326 = "32_1298845494.89" 
    capture_lex $P326
    .const 'Sub' $P305 = "31_1298845494.89" 
    capture_lex $P305
    .const 'Sub' $P284 = "30_1298845494.89" 
    capture_lex $P284
    .const 'Sub' $P265 = "29_1298845494.89" 
    capture_lex $P265
    .const 'Sub' $P251 = "28_1298845494.89" 
    capture_lex $P251
    .const 'Sub' $P244 = "27_1298845494.89" 
    capture_lex $P244
    .const 'Sub' $P234 = "26_1298845494.89" 
    capture_lex $P234
    .const 'Sub' $P97 = "19_1298845494.89" 
    capture_lex $P97
    .const 'Sub' $P55 = "16_1298845494.89" 
    capture_lex $P55
    get_global $P54, "$?CLASS"
.annotate 'line', 232
    .const 'Sub' $P55 = "16_1298845494.89" 
    newclosure $P96, $P55
    .lex "compute_c3_mro", $P96
.annotate 'line', 254
    .const 'Sub' $P97 = "19_1298845494.89" 
    newclosure $P233, $P97
    .lex "c3_merge", $P233
.annotate 'line', 178
    find_lex $P641, "compute_c3_mro"
    find_lex $P642, "c3_merge"
.annotate 'line', 438
    .const 'Sub' $P967 = "67_1298845494.89" 
    newclosure $P1002, $P967
.annotate 'line', 26
    .return ($P1002)
.end


.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post188") :outer("15_1298845494.89")
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    .local pmc block
    set block, $P53
    .const 'Sub' $P1004 = "69_1298845494.89" 
    capture_lex $P1004
    $P1004()
.end


.namespace ["NQPClassHOW"]
.sub "_block1003"  :anon :subid("69_1298845494.89") :outer("15_1298845494.89")
.annotate 'line', 26
    get_hll_global $P1005, "KnowHOW"
    $P1006 = $P1005."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1006
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1007, type_obj
    get_hll_global $P1008, "KnowHOWAttribute"
    $P1009 = $P1008."new"("$!name" :named("name"))
    $P1007."add_attribute"(type_obj, $P1009)
    get_how $P1010, type_obj
    get_hll_global $P1011, "KnowHOWAttribute"
    $P1012 = $P1011."new"("%!attributes" :named("name"))
    $P1010."add_attribute"(type_obj, $P1012)
    get_how $P1013, type_obj
    get_hll_global $P1014, "KnowHOWAttribute"
    $P1015 = $P1014."new"("%!methods" :named("name"))
    $P1013."add_attribute"(type_obj, $P1015)
    get_how $P1016, type_obj
    get_hll_global $P1017, "KnowHOWAttribute"
    $P1018 = $P1017."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1016."add_attribute"(type_obj, $P1018)
    get_how $P1019, type_obj
    get_hll_global $P1020, "KnowHOWAttribute"
    $P1021 = $P1020."new"("@!parents" :named("name"))
    $P1019."add_attribute"(type_obj, $P1021)
    get_how $P1022, type_obj
    get_hll_global $P1023, "KnowHOWAttribute"
    $P1024 = $P1023."new"("@!roles" :named("name"))
    $P1022."add_attribute"(type_obj, $P1024)
    get_how $P1025, type_obj
    get_hll_global $P1026, "KnowHOWAttribute"
    $P1027 = $P1026."new"("@!vtable" :named("name"))
    $P1025."add_attribute"(type_obj, $P1027)
    get_how $P1028, type_obj
    get_hll_global $P1029, "KnowHOWAttribute"
    $P1030 = $P1029."new"("%!method-vtable-slots" :named("name"))
    $P1028."add_attribute"(type_obj, $P1030)
    get_how $P1031, type_obj
    get_hll_global $P1032, "KnowHOWAttribute"
    $P1033 = $P1032."new"("$!composed" :named("name"))
    $P1031."add_attribute"(type_obj, $P1033)
    get_how $P1034, type_obj
    get_hll_global $P1035, "KnowHOWAttribute"
    $P1036 = $P1035."new"("@!mro" :named("name"))
    $P1034."add_attribute"(type_obj, $P1036)
    get_how $P1037, type_obj
    get_hll_global $P1038, "KnowHOWAttribute"
    $P1039 = $P1038."new"("@!done" :named("name"))
    $P1037."add_attribute"(type_obj, $P1039)
    get_how $P1040, type_obj
    get_hll_global $P1041, "KnowHOWAttribute"
    $P1042 = $P1041."new"("%!parrot_vtable_mapping" :named("name"))
    $P1040."add_attribute"(type_obj, $P1042)
    get_how $P1043, type_obj
    .const 'Sub' $P1044 = "26_1298845494.89" 
    $P1043."add_method"(type_obj, "new", $P1044)
    get_how $P1045, type_obj
    .const 'Sub' $P1046 = "27_1298845494.89" 
    $P1045."add_method"(type_obj, "BUILD", $P1046)
    get_how $P1047, type_obj
    .const 'Sub' $P1048 = "28_1298845494.89" 
    $P1047."add_method"(type_obj, "new_type", $P1048)
    get_how $P1049, type_obj
    .const 'Sub' $P1050 = "29_1298845494.89" 
    $P1049."add_method"(type_obj, "add_method", $P1050)
    get_how $P1051, type_obj
    .const 'Sub' $P1052 = "30_1298845494.89" 
    $P1051."add_method"(type_obj, "add_multi_method", $P1052)
    get_how $P1053, type_obj
    .const 'Sub' $P1054 = "31_1298845494.89" 
    $P1053."add_method"(type_obj, "add_attribute", $P1054)
    get_how $P1055, type_obj
    .const 'Sub' $P1056 = "32_1298845494.89" 
    $P1055."add_method"(type_obj, "add_parent", $P1056)
    get_how $P1057, type_obj
    .const 'Sub' $P1058 = "34_1298845494.89" 
    $P1057."add_method"(type_obj, "add_role", $P1058)
    get_how $P1059, type_obj
    .const 'Sub' $P1060 = "36_1298845494.89" 
    $P1059."add_method"(type_obj, "add_parrot_vtable_mapping", $P1060)
    get_how $P1061, type_obj
    .const 'Sub' $P1062 = "37_1298845494.89" 
    $P1061."add_method"(type_obj, "compose", $P1062)
    get_how $P1063, type_obj
    .const 'Sub' $P1064 = "40_1298845494.89" 
    $P1063."add_method"(type_obj, "incorporate_multi_candidates", $P1064)
    get_how $P1065, type_obj
    .const 'Sub' $P1066 = "45_1298845494.89" 
    $P1065."add_method"(type_obj, "publish_type_cache", $P1066)
    get_how $P1067, type_obj
    .const 'Sub' $P1068 = "48_1298845494.89" 
    $P1067."add_method"(type_obj, "publish_method_cache", $P1068)
    get_how $P1069, type_obj
    .const 'Sub' $P1070 = "51_1298845494.89" 
    $P1069."add_method"(type_obj, "publish_parrot_vtable_mapping", $P1070)
    get_how $P1071, type_obj
    .const 'Sub' $P1072 = "54_1298845494.89" 
    $P1071."add_method"(type_obj, "parents", $P1072)
    get_how $P1073, type_obj
    .const 'Sub' $P1074 = "55_1298845494.89" 
    $P1073."add_method"(type_obj, "roles", $P1074)
    get_how $P1075, type_obj
    .const 'Sub' $P1076 = "56_1298845494.89" 
    $P1075."add_method"(type_obj, "methods", $P1076)
    get_how $P1077, type_obj
    .const 'Sub' $P1078 = "58_1298845494.89" 
    $P1077."add_method"(type_obj, "method_table", $P1078)
    get_how $P1079, type_obj
    .const 'Sub' $P1080 = "59_1298845494.89" 
    $P1079."add_method"(type_obj, "name", $P1080)
    get_how $P1081, type_obj
    .const 'Sub' $P1082 = "60_1298845494.89" 
    $P1081."add_method"(type_obj, "attributes", $P1082)
    get_how $P1083, type_obj
    .const 'Sub' $P1084 = "62_1298845494.89" 
    $P1083."add_method"(type_obj, "parrot_vtable_mappings", $P1084)
    get_how $P1085, type_obj
    .const 'Sub' $P1086 = "63_1298845494.89" 
    $P1085."add_method"(type_obj, "isa", $P1086)
    get_how $P1087, type_obj
    .const 'Sub' $P1088 = "64_1298845494.89" 
    $P1087."add_method"(type_obj, "does", $P1088)
    get_how $P1089, type_obj
    .const 'Sub' $P1090 = "65_1298845494.89" 
    $P1089."add_method"(type_obj, "can", $P1090)
    get_how $P1091, type_obj
    .const 'Sub' $P1092 = "67_1298845494.89" 
    $P1091."add_method"(type_obj, "find_method", $P1092)
    get_how $P1093, type_obj
    $P1094 = $P1093."compose"(type_obj)
    .return ($P1094)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_58
.annotate 'line', 232
    .const 'Sub' $P70 = "17_1298845494.89" 
    capture_lex $P70
    new $P57, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P57, control_56
    push_eh $P57
    .lex "$class", param_58
.annotate 'line', 233
    $P59 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P59
.annotate 'line', 236
    $P60 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P60
.annotate 'line', 233
    find_lex $P61, "$class"
    get_how $P62, $P61
    find_lex $P63, "$class"
    $P64 = $P62."parents"($P63, 1 :named("local"))
    store_lex "@immediate_parents", $P64
    find_lex $P65, "@result"
.annotate 'line', 237
    find_lex $P67, "@immediate_parents"
    set $N68, $P67
    unless $N68, if_66_end
    .const 'Sub' $P70 = "17_1298845494.89" 
    capture_lex $P70
    $P70()
  if_66_end:
.annotate 'line', 249
    find_lex $P91, "@result"
    find_lex $P92, "$class"
    $P91."unshift"($P92)
.annotate 'line', 250
    new $P93, "Exception"
    set $P93['type'], .CONTROL_RETURN
    find_lex $P94, "@result"
    setattribute $P93, 'payload', $P94
    throw $P93
.annotate 'line', 232
    .return ()
  control_56:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P95, exception, "payload"
    .return ($P95)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block69"  :anon :subid("17_1298845494.89") :outer("16_1298845494.89")
.annotate 'line', 237
    .const 'Sub' $P78 = "18_1298845494.89" 
    capture_lex $P78
.annotate 'line', 240
    $P71 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P71
.annotate 'line', 237
    find_lex $P72, "@merge_list"
.annotate 'line', 241
    find_lex $P74, "@immediate_parents"
    defined $I75, $P74
    unless $I75, for_undef_189
    iter $P73, $P74
    new $P85, 'ExceptionHandler'
    set_label $P85, loop84_handler
    $P85."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P85
  loop84_test:
    unless $P73, loop84_done
    shift $P76, $P73
  loop84_redo:
    .const 'Sub' $P78 = "18_1298845494.89" 
    capture_lex $P78
    $P78($P76)
  loop84_next:
    goto loop84_test
  loop84_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P86, exception, 'type'
    eq $P86, .CONTROL_LOOP_NEXT, loop84_next
    eq $P86, .CONTROL_LOOP_REDO, loop84_redo
  loop84_done:
    pop_eh 
  for_undef_189:
.annotate 'line', 244
    find_lex $P87, "@merge_list"
    find_lex $P88, "@immediate_parents"
    $P87."push"($P88)
.annotate 'line', 245
    find_lex $P89, "@merge_list"
    $P90 = "c3_merge"($P89)
    store_lex "@result", $P90
.annotate 'line', 237
    .return ($P90)
.end


.namespace ["NQPClassHOW"]
.sub "_block77"  :anon :subid("18_1298845494.89") :outer("17_1298845494.89")
    .param pmc param_79
.annotate 'line', 241
    .lex "$_", param_79
.annotate 'line', 242
    find_lex $P80, "@merge_list"
    find_lex $P81, "$_"
    $P82 = "compute_c3_mro"($P81)
    $P83 = $P80."push"($P82)
.annotate 'line', 241
    .return ($P83)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_100
.annotate 'line', 254
    .const 'Sub' $P193 = "24_1298845494.89" 
    capture_lex $P193
    .const 'Sub' $P115 = "20_1298845494.89" 
    capture_lex $P115
    new $P99, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P99, control_98
    push_eh $P99
    .lex "@merge_list", param_100
.annotate 'line', 255
    $P101 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P101
.annotate 'line', 256
    new $P102, "Undef"
    .lex "$accepted", $P102
.annotate 'line', 257
    new $P103, "Undef"
    .lex "$something_accepted", $P103
.annotate 'line', 258
    new $P104, "Undef"
    .lex "$cand_count", $P104
.annotate 'line', 301
    new $P105, "Undef"
    .lex "$i", $P105
.annotate 'line', 254
    find_lex $P106, "@result"
    find_lex $P107, "$accepted"
.annotate 'line', 257
    new $P108, "Integer"
    assign $P108, 0
    store_lex "$something_accepted", $P108
.annotate 'line', 258
    new $P109, "Integer"
    assign $P109, 0
    store_lex "$cand_count", $P109
.annotate 'line', 261
    find_lex $P111, "@merge_list"
    defined $I112, $P111
    unless $I112, for_undef_190
    iter $P110, $P111
    new $P176, 'ExceptionHandler'
    set_label $P176, loop175_handler
    $P176."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P176
  loop175_test:
    unless $P110, loop175_done
    shift $P113, $P110
  loop175_redo:
    .const 'Sub' $P115 = "20_1298845494.89" 
    capture_lex $P115
    $P115($P113)
  loop175_next:
    goto loop175_test
  loop175_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P177, exception, 'type'
    eq $P177, .CONTROL_LOOP_NEXT, loop175_next
    eq $P177, .CONTROL_LOOP_REDO, loop175_redo
  loop175_done:
    pop_eh 
  for_undef_190:
.annotate 'line', 291
    find_lex $P179, "$cand_count"
    set $N180, $P179
    iseq $I181, $N180, 0.0
    unless $I181, if_178_end
.annotate 'line', 292
    new $P182, "Exception"
    set $P182['type'], .CONTROL_RETURN
    find_lex $P183, "@result"
    setattribute $P182, 'payload', $P183
    throw $P182
  if_178_end:
.annotate 'line', 296
    find_lex $P185, "$something_accepted"
    if $P185, unless_184_end
.annotate 'line', 297
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_184_end:
.annotate 'line', 301
    new $P186, "Integer"
    assign $P186, 0
    store_lex "$i", $P186
.annotate 'line', 302
    new $P224, 'ExceptionHandler'
    set_label $P224, loop223_handler
    $P224."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P224
  loop223_test:
    find_lex $P187, "$i"
    set $N188, $P187
    find_lex $P189, "@merge_list"
    set $N190, $P189
    islt $I191, $N188, $N190
    unless $I191, loop223_done
  loop223_redo:
    .const 'Sub' $P193 = "24_1298845494.89" 
    capture_lex $P193
    $P193()
  loop223_next:
    goto loop223_test
  loop223_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P225, exception, 'type'
    eq $P225, .CONTROL_LOOP_NEXT, loop223_next
    eq $P225, .CONTROL_LOOP_REDO, loop223_redo
  loop223_done:
    pop_eh 
.annotate 'line', 315
    find_lex $P226, "@merge_list"
    $P227 = "c3_merge"($P226)
    store_lex "@result", $P227
.annotate 'line', 316
    find_lex $P228, "@result"
    find_lex $P229, "$accepted"
    $P228."unshift"($P229)
.annotate 'line', 317
    new $P230, "Exception"
    set $P230['type'], .CONTROL_RETURN
    find_lex $P231, "@result"
    setattribute $P230, 'payload', $P231
    throw $P230
.annotate 'line', 254
    .return ()
  control_98:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P232, exception, "payload"
    .return ($P232)
.end


.namespace ["NQPClassHOW"]
.sub "_block114"  :anon :subid("20_1298845494.89") :outer("19_1298845494.89")
    .param pmc param_117
.annotate 'line', 261
    .const 'Sub' $P124 = "21_1298845494.89" 
    capture_lex $P124
.annotate 'line', 262
    $P116 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P116
    .lex "$_", param_117
    find_lex $P118, "$_"
    store_lex "@cand_list", $P118
.annotate 'line', 263
    find_lex $P121, "@cand_list"
    set $N122, $P121
    if $N122, if_120
    new $P119, 'Float'
    set $P119, $N122
    goto if_120_end
  if_120:
    .const 'Sub' $P124 = "21_1298845494.89" 
    capture_lex $P124
    $P174 = $P124()
    set $P119, $P174
  if_120_end:
.annotate 'line', 261
    .return ($P119)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block123"  :anon :subid("21_1298845494.89") :outer("20_1298845494.89")
.annotate 'line', 263
    .const 'Sub' $P137 = "22_1298845494.89" 
    capture_lex $P137
.annotate 'line', 264
    new $P125, "Undef"
    .lex "$rejected", $P125
.annotate 'line', 265
    new $P126, "Undef"
    .lex "$cand_class", $P126
.annotate 'line', 264
    new $P127, "Integer"
    assign $P127, 0
    store_lex "$rejected", $P127
.annotate 'line', 265
    find_lex $P128, "@cand_list"
    unless_null $P128, vivify_191
    $P128 = root_new ['parrot';'ResizablePMCArray']
  vivify_191:
    set $P129, $P128[0]
    unless_null $P129, vivify_192
    new $P129, "Undef"
  vivify_192:
    store_lex "$cand_class", $P129
.annotate 'line', 266
    find_lex $P130, "$cand_count"
    add $P131, $P130, 1
    store_lex "$cand_count", $P131
.annotate 'line', 267
    find_lex $P133, "@merge_list"
    defined $I134, $P133
    unless $I134, for_undef_193
    iter $P132, $P133
    new $P172, 'ExceptionHandler'
    set_label $P172, loop171_handler
    $P172."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P172
  loop171_test:
    unless $P132, loop171_done
    shift $P135, $P132
  loop171_redo:
    .const 'Sub' $P137 = "22_1298845494.89" 
    capture_lex $P137
    $P137($P135)
  loop171_next:
    goto loop171_test
  loop171_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P173, exception, 'type'
    eq $P173, .CONTROL_LOOP_NEXT, loop171_next
    eq $P173, .CONTROL_LOOP_REDO, loop171_redo
  loop171_done:
    pop_eh 
  for_undef_193:
.annotate 'line', 263
    .return ($P132)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block136"  :anon :subid("22_1298845494.89") :outer("21_1298845494.89")
    .param pmc param_138
.annotate 'line', 267
    .const 'Sub' $P144 = "23_1298845494.89" 
    capture_lex $P144
    .lex "$_", param_138
.annotate 'line', 269
    find_lex $P140, "$_"
    find_lex $P141, "@cand_list"
    issame $I142, $P140, $P141
    if $I142, unless_139_end
    .const 'Sub' $P144 = "23_1298845494.89" 
    capture_lex $P144
    $P144()
  unless_139_end:
.annotate 'line', 281
    find_lex $P167, "$rejected"
    unless $P167, unless_166
    set $P165, $P167
    goto unless_166_end
  unless_166:
.annotate 'line', 282
    find_lex $P168, "$cand_class"
    store_lex "$accepted", $P168
.annotate 'line', 283
    new $P169, "Integer"
    assign $P169, 1
    store_lex "$something_accepted", $P169
.annotate 'line', 284
    set $I170, .CONTROL_LOOP_LAST
    die 0, $I170
  unless_166_end:
.annotate 'line', 267
    .return ($P165)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block143"  :anon :subid("23_1298845494.89") :outer("22_1298845494.89")
.annotate 'line', 271
    new $P145, "Undef"
    .lex "$cur_pos", $P145
    new $P146, "Integer"
    assign $P146, 1
    store_lex "$cur_pos", $P146
.annotate 'line', 272
    new $P163, 'ExceptionHandler'
    set_label $P163, loop162_handler
    $P163."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P163
  loop162_test:
    find_lex $P147, "$cur_pos"
    set $N148, $P147
    find_lex $P149, "$_"
    set $N150, $P149
    isle $I151, $N148, $N150
    unless $I151, loop162_done
  loop162_redo:
.annotate 'line', 273
    find_lex $P153, "$cur_pos"
    set $I154, $P153
    find_lex $P155, "$_"
    unless_null $P155, vivify_194
    $P155 = root_new ['parrot';'ResizablePMCArray']
  vivify_194:
    set $P156, $P155[$I154]
    unless_null $P156, vivify_195
    new $P156, "Undef"
  vivify_195:
    find_lex $P157, "$cand_class"
    issame $I158, $P156, $P157
    unless $I158, if_152_end
.annotate 'line', 274
    new $P159, "Integer"
    assign $P159, 1
    store_lex "$rejected", $P159
  if_152_end:
.annotate 'line', 276
    find_lex $P160, "$cur_pos"
    add $P161, $P160, 1
    store_lex "$cur_pos", $P161
  loop162_next:
.annotate 'line', 272
    goto loop162_test
  loop162_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P164, exception, 'type'
    eq $P164, .CONTROL_LOOP_NEXT, loop162_next
    eq $P164, .CONTROL_LOOP_REDO, loop162_redo
  loop162_done:
    pop_eh 
.annotate 'line', 269
    .return ($I151)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block192"  :anon :subid("24_1298845494.89") :outer("19_1298845494.89")
.annotate 'line', 302
    .const 'Sub' $P204 = "25_1298845494.89" 
    capture_lex $P204
.annotate 'line', 303
    $P194 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P194
.annotate 'line', 302
    find_lex $P195, "@new_list"
.annotate 'line', 304
    find_lex $P197, "$i"
    set $I198, $P197
    find_lex $P199, "@merge_list"
    unless_null $P199, vivify_196
    $P199 = root_new ['parrot';'ResizablePMCArray']
  vivify_196:
    set $P200, $P199[$I198]
    unless_null $P200, vivify_197
    new $P200, "Undef"
  vivify_197:
    defined $I201, $P200
    unless $I201, for_undef_198
    iter $P196, $P200
    new $P215, 'ExceptionHandler'
    set_label $P215, loop214_handler
    $P215."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P215
  loop214_test:
    unless $P196, loop214_done
    shift $P202, $P196
  loop214_redo:
    .const 'Sub' $P204 = "25_1298845494.89" 
    capture_lex $P204
    $P204($P202)
  loop214_next:
    goto loop214_test
  loop214_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P216, exception, 'type'
    eq $P216, .CONTROL_LOOP_NEXT, loop214_next
    eq $P216, .CONTROL_LOOP_REDO, loop214_redo
  loop214_done:
    pop_eh 
  for_undef_198:
.annotate 'line', 309
    find_lex $P217, "@new_list"
    find_lex $P218, "$i"
    set $I219, $P218
    find_lex $P220, "@merge_list"
    unless_null $P220, vivify_199
    $P220 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P220
  vivify_199:
    set $P220[$I219], $P217
.annotate 'line', 310
    find_lex $P221, "$i"
    add $P222, $P221, 1
    store_lex "$i", $P222
.annotate 'line', 302
    .return ($P222)
.end


.namespace ["NQPClassHOW"]
.sub "_block203"  :anon :subid("25_1298845494.89") :outer("24_1298845494.89")
    .param pmc param_205
.annotate 'line', 304
    .lex "$_", param_205
.annotate 'line', 305
    find_lex $P208, "$_"
    find_lex $P209, "$accepted"
    issame $I210, $P208, $P209
    unless $I210, unless_207
    new $P206, 'Integer'
    set $P206, $I210
    goto unless_207_end
  unless_207:
.annotate 'line', 306
    find_lex $P211, "@new_list"
    find_lex $P212, "$_"
    $P213 = $P211."push"($P212)
.annotate 'line', 305
    set $P206, $P213
  unless_207_end:
.annotate 'line', 304
    .return ($P206)
.end


.namespace ["NQPClassHOW"]
.sub "new"  :subid("26_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_235
    .param pmc param_236 :optional :named("name")
    .param int has_param_236 :opt_flag
.annotate 'line', 62
    .lex "self", param_235
    if has_param_236, optparam_200
    new $P237, "Undef"
    set param_236, $P237
  optparam_200:
    .lex "$name", param_236
.annotate 'line', 63
    new $P238, "Undef"
    .lex "$obj", $P238
    find_lex $P239, "self"
    repr_instance_of $P240, $P239
    store_lex "$obj", $P240
.annotate 'line', 64
    find_lex $P241, "$obj"
    find_lex $P242, "$name"
    $P241."BUILD"($P242 :named("name"))
    find_lex $P243, "$obj"
.annotate 'line', 62
    .return ($P243)
.end


.namespace ["NQPClassHOW"]
.sub "BUILD"  :subid("27_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_245
    .param pmc param_246 :optional :named("name")
    .param int has_param_246 :opt_flag
.annotate 'line', 68
    .lex "self", param_245
    if has_param_246, optparam_201
    new $P247, "Undef"
    set param_246, $P247
  optparam_201:
    .lex "$name", param_246
.annotate 'line', 69
    find_lex $P248, "$name"
    find_lex $P249, "self"
    get_global $P250, "$?CLASS"
    setattribute $P249, $P250, "$!name", $P248
.annotate 'line', 68
    .return ($P248)
.end


.namespace ["NQPClassHOW"]
.sub "new_type"  :subid("28_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_252
    .param pmc param_253 :optional :named("name")
    .param int has_param_253 :opt_flag
    .param pmc param_255 :optional :named("repr")
    .param int has_param_255 :opt_flag
.annotate 'line', 74
    .lex "self", param_252
    if has_param_253, optparam_202
    new $P254, "String"
    assign $P254, "<anon>"
    set param_253, $P254
  optparam_202:
    .lex "$name", param_253
    if has_param_255, optparam_203
    new $P256, "String"
    assign $P256, "P6opaque"
    set param_255, $P256
  optparam_203:
    .lex "$repr", param_255
.annotate 'line', 75
    new $P257, "Undef"
    .lex "$metaclass", $P257
    find_lex $P258, "self"
    find_lex $P259, "$name"
    $P260 = $P258."new"($P259 :named("name"))
    store_lex "$metaclass", $P260
.annotate 'line', 76
    find_lex $P261, "$metaclass"
    find_lex $P262, "$repr"
    set $S263, $P262
    repr_type_object_for $P264, $P261, $S263
.annotate 'line', 74
    .return ($P264)
.end


.namespace ["NQPClassHOW"]
.sub "add_method"  :subid("29_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_266
    .param pmc param_267
    .param pmc param_268
    .param pmc param_269
.annotate 'line', 79
    .lex "self", param_266
    .lex "$obj", param_267
    .lex "$name", param_268
    .lex "$code_obj", param_269
.annotate 'line', 80
    find_lex $P271, "$name"
    find_lex $P272, "self"
    get_global $P273, "$?CLASS"
    getattribute $P274, $P272, $P273, "%!methods"
    unless_null $P274, vivify_204
    $P274 = root_new ['parrot';'Hash']
  vivify_204:
    set $P275, $P274[$P271]
    unless_null $P275, vivify_205
    new $P275, "Undef"
  vivify_205:
    unless $P275, if_270_end
.annotate 'line', 81
    new $P276, "String"
    assign $P276, "This class already has a method named "
    find_lex $P277, "$name"
    concat $P278, $P276, $P277
    die $P278
  if_270_end:
.annotate 'line', 83
    find_lex $P279, "$code_obj"
    find_lex $P280, "$name"
    find_lex $P281, "self"
    get_global $P282, "$?CLASS"
    getattribute $P283, $P281, $P282, "%!methods"
    unless_null $P283, vivify_206
    $P283 = root_new ['parrot';'Hash']
    setattribute $P281, $P282, "%!methods", $P283
  vivify_206:
    set $P283[$P280], $P279
.annotate 'line', 79
    .return ($P279)
.end


.namespace ["NQPClassHOW"]
.sub "add_multi_method"  :subid("30_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_285
    .param pmc param_286
    .param pmc param_287
    .param pmc param_288
.annotate 'line', 86
    .lex "self", param_285
    .lex "$obj", param_286
    .lex "$name", param_287
    .lex "$code_obj", param_288
.annotate 'line', 92
    $P289 = root_new ['parrot';'Hash']
    .lex "%todo", $P289
.annotate 'line', 86
    find_lex $P290, "%todo"
.annotate 'line', 93
    find_lex $P291, "$name"
    find_lex $P292, "%todo"
    unless_null $P292, vivify_207
    $P292 = root_new ['parrot';'Hash']
    store_lex "%todo", $P292
  vivify_207:
    set $P292["name"], $P291
.annotate 'line', 94
    find_lex $P293, "$code_obj"
    find_lex $P294, "%todo"
    unless_null $P294, vivify_208
    $P294 = root_new ['parrot';'Hash']
    store_lex "%todo", $P294
  vivify_208:
    set $P294["code"], $P293
.annotate 'line', 95
    find_lex $P295, "%todo"
    find_lex $P296, "self"
    get_global $P297, "$?CLASS"
    getattribute $P298, $P296, $P297, "@!multi_methods_to_incorporate"
    unless_null $P298, vivify_209
    $P298 = root_new ['parrot';'ResizablePMCArray']
  vivify_209:
    set $N299, $P298
    set $I300, $N299
    find_lex $P301, "self"
    get_global $P302, "$?CLASS"
    getattribute $P303, $P301, $P302, "@!multi_methods_to_incorporate"
    unless_null $P303, vivify_210
    $P303 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P301, $P302, "@!multi_methods_to_incorporate", $P303
  vivify_210:
    set $P303[$I300], $P295
    find_lex $P304, "$code_obj"
.annotate 'line', 86
    .return ($P304)
.end


.namespace ["NQPClassHOW"]
.sub "add_attribute"  :subid("31_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_306
    .param pmc param_307
    .param pmc param_308
.annotate 'line', 99
    .lex "self", param_306
    .lex "$obj", param_307
    .lex "$meta_attr", param_308
.annotate 'line', 100
    new $P309, "Undef"
    .lex "$name", $P309
    find_lex $P310, "$meta_attr"
    $P311 = $P310."name"()
    store_lex "$name", $P311
.annotate 'line', 101
    find_lex $P313, "$name"
    find_lex $P314, "self"
    get_global $P315, "$?CLASS"
    getattribute $P316, $P314, $P315, "%!attributes"
    unless_null $P316, vivify_211
    $P316 = root_new ['parrot';'Hash']
  vivify_211:
    set $P317, $P316[$P313]
    unless_null $P317, vivify_212
    new $P317, "Undef"
  vivify_212:
    unless $P317, if_312_end
.annotate 'line', 102
    new $P318, "String"
    assign $P318, "This class already has an attribute named "
    find_lex $P319, "$name"
    concat $P320, $P318, $P319
    die $P320
  if_312_end:
.annotate 'line', 104
    find_lex $P321, "$meta_attr"
    find_lex $P322, "$name"
    find_lex $P323, "self"
    get_global $P324, "$?CLASS"
    getattribute $P325, $P323, $P324, "%!attributes"
    unless_null $P325, vivify_213
    $P325 = root_new ['parrot';'Hash']
    setattribute $P323, $P324, "%!attributes", $P325
  vivify_213:
    set $P325[$P322], $P321
.annotate 'line', 99
    .return ($P321)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_327
    .param pmc param_328
    .param pmc param_329
.annotate 'line', 107
    .const 'Sub' $P341 = "33_1298845494.89" 
    capture_lex $P341
    .lex "self", param_327
    .lex "$obj", param_328
    .lex "$parent", param_329
.annotate 'line', 108
    find_lex $P331, "self"
    get_global $P332, "$?CLASS"
    getattribute $P333, $P331, $P332, "$!composed"
    unless_null $P333, vivify_214
    new $P333, "Undef"
  vivify_214:
    unless $P333, if_330_end
.annotate 'line', 109
    die "NQPClassHOW does not support adding parents after being composed."
  if_330_end:
.annotate 'line', 111
    find_lex $P335, "self"
    get_global $P336, "$?CLASS"
    getattribute $P337, $P335, $P336, "@!parents"
    unless_null $P337, vivify_215
    $P337 = root_new ['parrot';'ResizablePMCArray']
  vivify_215:
    defined $I338, $P337
    unless $I338, for_undef_216
    iter $P334, $P337
    new $P353, 'ExceptionHandler'
    set_label $P353, loop352_handler
    $P353."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P353
  loop352_test:
    unless $P334, loop352_done
    shift $P339, $P334
  loop352_redo:
    .const 'Sub' $P341 = "33_1298845494.89" 
    capture_lex $P341
    $P341($P339)
  loop352_next:
    goto loop352_test
  loop352_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P354, exception, 'type'
    eq $P354, .CONTROL_LOOP_NEXT, loop352_next
    eq $P354, .CONTROL_LOOP_REDO, loop352_redo
  loop352_done:
    pop_eh 
  for_undef_216:
.annotate 'line', 116
    find_lex $P355, "$parent"
    find_lex $P356, "self"
    get_global $P357, "$?CLASS"
    getattribute $P358, $P356, $P357, "@!parents"
    unless_null $P358, vivify_217
    $P358 = root_new ['parrot';'ResizablePMCArray']
  vivify_217:
    set $N359, $P358
    set $I360, $N359
    find_lex $P361, "self"
    get_global $P362, "$?CLASS"
    getattribute $P363, $P361, $P362, "@!parents"
    unless_null $P363, vivify_218
    $P363 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P361, $P362, "@!parents", $P363
  vivify_218:
    set $P363[$I360], $P355
.annotate 'line', 107
    .return ($P355)
.end


.namespace ["NQPClassHOW"]
.sub "_block340"  :anon :subid("33_1298845494.89") :outer("32_1298845494.89")
    .param pmc param_342
.annotate 'line', 111
    .lex "$_", param_342
.annotate 'line', 112
    find_lex $P345, "$_"
    find_lex $P346, "$parent"
    issame $I347, $P345, $P346
    if $I347, if_344
    new $P343, 'Integer'
    set $P343, $I347
    goto if_344_end
  if_344:
.annotate 'line', 113
    new $P348, "String"
    assign $P348, "Already have "
    find_lex $P349, "$parent"
    concat $P350, $P348, $P349
    concat $P351, $P350, " as a parent class."
    die $P351
  if_344_end:
.annotate 'line', 111
    .return ($P343)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_role"  :subid("34_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_365
    .param pmc param_366
    .param pmc param_367
.annotate 'line', 119
    .const 'Sub' $P375 = "35_1298845494.89" 
    capture_lex $P375
    .lex "self", param_365
    .lex "$obj", param_366
    .lex "$role", param_367
.annotate 'line', 120
    find_lex $P369, "self"
    get_global $P370, "$?CLASS"
    getattribute $P371, $P369, $P370, "@!roles"
    unless_null $P371, vivify_219
    $P371 = root_new ['parrot';'ResizablePMCArray']
  vivify_219:
    defined $I372, $P371
    unless $I372, for_undef_220
    iter $P368, $P371
    new $P387, 'ExceptionHandler'
    set_label $P387, loop386_handler
    $P387."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P387
  loop386_test:
    unless $P368, loop386_done
    shift $P373, $P368
  loop386_redo:
    .const 'Sub' $P375 = "35_1298845494.89" 
    capture_lex $P375
    $P375($P373)
  loop386_next:
    goto loop386_test
  loop386_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P388, exception, 'type'
    eq $P388, .CONTROL_LOOP_NEXT, loop386_next
    eq $P388, .CONTROL_LOOP_REDO, loop386_redo
  loop386_done:
    pop_eh 
  for_undef_220:
.annotate 'line', 125
    find_lex $P389, "$role"
    find_lex $P390, "self"
    get_global $P391, "$?CLASS"
    getattribute $P392, $P390, $P391, "@!roles"
    unless_null $P392, vivify_221
    $P392 = root_new ['parrot';'ResizablePMCArray']
  vivify_221:
    set $N393, $P392
    set $I394, $N393
    find_lex $P395, "self"
    get_global $P396, "$?CLASS"
    getattribute $P397, $P395, $P396, "@!roles"
    unless_null $P397, vivify_222
    $P397 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P395, $P396, "@!roles", $P397
  vivify_222:
    set $P397[$I394], $P389
.annotate 'line', 119
    .return ($P389)
.end


.namespace ["NQPClassHOW"]
.sub "_block374"  :anon :subid("35_1298845494.89") :outer("34_1298845494.89")
    .param pmc param_376
.annotate 'line', 120
    .lex "$_", param_376
.annotate 'line', 121
    find_lex $P379, "$_"
    find_lex $P380, "$role"
    issame $I381, $P379, $P380
    if $I381, if_378
    new $P377, 'Integer'
    set $P377, $I381
    goto if_378_end
  if_378:
.annotate 'line', 122
    new $P382, "String"
    assign $P382, "The role "
    find_lex $P383, "$role"
    concat $P384, $P382, $P383
    concat $P385, $P384, " has already been added."
    die $P385
  if_378_end:
.annotate 'line', 120
    .return ($P377)
.end


.namespace ["NQPClassHOW"]
.sub "add_parrot_vtable_mapping"  :subid("36_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_399
    .param pmc param_400
    .param pmc param_401
    .param pmc param_402
.annotate 'line', 128
    .lex "self", param_399
    .lex "$obj", param_400
    .lex "$name", param_401
    .lex "$meth", param_402
.annotate 'line', 129
    find_lex $P404, "$name"
    find_lex $P405, "self"
    get_global $P406, "$?CLASS"
    getattribute $P407, $P405, $P406, "%!parrot_vtable_mapping"
    unless_null $P407, vivify_223
    $P407 = root_new ['parrot';'Hash']
  vivify_223:
    set $P408, $P407[$P404]
    unless_null $P408, vivify_224
    new $P408, "Undef"
  vivify_224:
    defined $I409, $P408
    unless $I409, if_403_end
.annotate 'line', 130
    new $P410, "String"
    assign $P410, "Class '"
    find_lex $P411, "self"
    get_global $P412, "$?CLASS"
    getattribute $P413, $P411, $P412, "$!name"
    unless_null $P413, vivify_225
    new $P413, "Undef"
  vivify_225:
    concat $P414, $P410, $P413
    concat $P415, $P414, "' already has a Parrot v-table override for '"
    find_lex $P416, "$name"
    concat $P417, $P415, $P416
.annotate 'line', 131
    concat $P418, $P417, "'"
.annotate 'line', 132
    die $P418
  if_403_end:
.annotate 'line', 134
    find_lex $P419, "$meth"
    find_lex $P420, "$name"
    find_lex $P421, "self"
    get_global $P422, "$?CLASS"
    getattribute $P423, $P421, $P422, "%!parrot_vtable_mapping"
    unless_null $P423, vivify_226
    $P423 = root_new ['parrot';'Hash']
    setattribute $P421, $P422, "%!parrot_vtable_mapping", $P423
  vivify_226:
    set $P423[$P420], $P419
.annotate 'line', 128
    .return ($P419)
.end


.namespace ["NQPClassHOW"]
.sub "compose"  :subid("37_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_425
    .param pmc param_426
.annotate 'line', 137
    .const 'Sub' $P432 = "38_1298845494.89" 
    capture_lex $P432
    .lex "self", param_425
    .lex "$obj", param_426
.annotate 'line', 141
    find_lex $P428, "self"
    get_global $P429, "$?CLASS"
    getattribute $P430, $P428, $P429, "@!roles"
    unless_null $P430, vivify_227
    $P430 = root_new ['parrot';'ResizablePMCArray']
  vivify_227:
    unless $P430, if_427_end
    .const 'Sub' $P432 = "38_1298845494.89" 
    capture_lex $P432
    $P432()
  if_427_end:
.annotate 'line', 154
    find_lex $P480, "self"
    get_global $P481, "$?CLASS"
    getattribute $P482, $P480, $P481, "@!parents"
    unless_null $P482, vivify_234
    $P482 = root_new ['parrot';'ResizablePMCArray']
  vivify_234:
    set $N483, $P482
    iseq $I484, $N483, 0.0
    if $I484, if_479
    new $P478, 'Integer'
    set $P478, $I484
    goto if_479_end
  if_479:
    find_lex $P485, "self"
    get_global $P486, "$?CLASS"
    getattribute $P487, $P485, $P486, "$!name"
    unless_null $P487, vivify_235
    new $P487, "Undef"
  vivify_235:
    set $S488, $P487
    isne $I489, $S488, "NQPMu"
    new $P478, 'Integer'
    set $P478, $I489
  if_479_end:
    unless $P478, if_477_end
.annotate 'line', 155
    find_lex $P490, "self"
    find_lex $P491, "$obj"
    get_hll_global $P492, "NQPMu"
    $P490."add_parent"($P491, $P492)
  if_477_end:
.annotate 'line', 160
    find_lex $P494, "self"
    get_global $P495, "$?CLASS"
    getattribute $P496, $P494, $P495, "$!composed"
    unless_null $P496, vivify_236
    new $P496, "Undef"
  vivify_236:
    if $P496, unless_493_end
.annotate 'line', 161
    find_lex $P497, "$obj"
    $P498 = "compute_c3_mro"($P497)
    find_lex $P499, "self"
    get_global $P500, "$?CLASS"
    setattribute $P499, $P500, "@!mro", $P498
.annotate 'line', 162
    new $P501, "Integer"
    assign $P501, 1
    find_lex $P502, "self"
    get_global $P503, "$?CLASS"
    setattribute $P502, $P503, "$!composed", $P501
  unless_493_end:
.annotate 'line', 166
    find_lex $P504, "self"
    find_lex $P505, "$obj"
    $P504."incorporate_multi_candidates"($P505)
.annotate 'line', 169
    find_lex $P506, "self"
    find_lex $P507, "$obj"
    $P506."publish_type_cache"($P507)
.annotate 'line', 170
    find_lex $P508, "self"
    find_lex $P509, "$obj"
    $P508."publish_method_cache"($P509)
.annotate 'line', 173
    find_lex $P510, "self"
    find_lex $P511, "$obj"
    $P510."publish_parrot_vtable_mapping"($P511)
    find_lex $P512, "$obj"
.annotate 'line', 137
    .return ($P512)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block431"  :anon :subid("38_1298845494.89") :outer("37_1298845494.89")
.annotate 'line', 141
    .const 'Sub' $P442 = "39_1298845494.89" 
    capture_lex $P442
.annotate 'line', 142
    $P433 = root_new ['parrot';'ResizablePMCArray']
    .lex "@instantiated_roles", $P433
.annotate 'line', 141
    find_lex $P434, "@instantiated_roles"
.annotate 'line', 143
    find_lex $P436, "self"
    get_global $P437, "$?CLASS"
    getattribute $P438, $P436, $P437, "@!roles"
    unless_null $P438, vivify_228
    $P438 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    defined $I439, $P438
    unless $I439, for_undef_229
    iter $P435, $P438
    new $P471, 'ExceptionHandler'
    set_label $P471, loop470_handler
    $P471."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P471
  loop470_test:
    unless $P435, loop470_done
    shift $P440, $P435
  loop470_redo:
    .const 'Sub' $P442 = "39_1298845494.89" 
    capture_lex $P442
    $P442($P440)
  loop470_next:
    goto loop470_test
  loop470_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P472, exception, 'type'
    eq $P472, .CONTROL_LOOP_NEXT, loop470_next
    eq $P472, .CONTROL_LOOP_REDO, loop470_redo
  loop470_done:
    pop_eh 
  for_undef_229:
.annotate 'line', 149
    get_hll_global $P473, "RoleToClassApplier"
    find_lex $P474, "$obj"
    find_lex $P475, "@instantiated_roles"
    $P476 = $P473."apply"($P474, $P475)
.annotate 'line', 141
    .return ($P476)
.end


.namespace ["NQPClassHOW"]
.sub "_block441"  :anon :subid("39_1298845494.89") :outer("38_1298845494.89")
    .param pmc param_444
.annotate 'line', 144
    new $P443, "Undef"
    .lex "$ins", $P443
    .lex "$_", param_444
    find_lex $P445, "$_"
    get_how $P446, $P445
    find_lex $P447, "$_"
    find_lex $P448, "$obj"
    $P449 = $P446."instantiate"($P447, $P448)
    store_lex "$ins", $P449
.annotate 'line', 145
    find_lex $P450, "@instantiated_roles"
    find_lex $P451, "$ins"
    $P450."push"($P451)
.annotate 'line', 146
    find_lex $P452, "$_"
    find_lex $P453, "self"
    get_global $P454, "$?CLASS"
    getattribute $P455, $P453, $P454, "@!done"
    unless_null $P455, vivify_230
    $P455 = root_new ['parrot';'ResizablePMCArray']
  vivify_230:
    set $N456, $P455
    set $I457, $N456
    find_lex $P458, "self"
    get_global $P459, "$?CLASS"
    getattribute $P460, $P458, $P459, "@!done"
    unless_null $P460, vivify_231
    $P460 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P458, $P459, "@!done", $P460
  vivify_231:
    set $P460[$I457], $P452
.annotate 'line', 147
    find_lex $P461, "$ins"
    find_lex $P462, "self"
    get_global $P463, "$?CLASS"
    getattribute $P464, $P462, $P463, "@!done"
    unless_null $P464, vivify_232
    $P464 = root_new ['parrot';'ResizablePMCArray']
  vivify_232:
    set $N465, $P464
    set $I466, $N465
    find_lex $P467, "self"
    get_global $P468, "$?CLASS"
    getattribute $P469, $P467, $P468, "@!done"
    unless_null $P469, vivify_233
    $P469 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P467, $P468, "@!done", $P469
  vivify_233:
    set $P469[$I466], $P461
.annotate 'line', 143
    .return ($P461)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("40_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_514
    .param pmc param_515
.annotate 'line', 178
    .const 'Sub' $P530 = "41_1298845494.89" 
    capture_lex $P530
    .lex "self", param_514
    .lex "$obj", param_515
.annotate 'line', 179
    new $P516, "Undef"
    .lex "$num_todo", $P516
.annotate 'line', 180
    new $P517, "Undef"
    .lex "$i", $P517
.annotate 'line', 179
    find_lex $P518, "self"
    get_global $P519, "$?CLASS"
    getattribute $P520, $P518, $P519, "@!multi_methods_to_incorporate"
    unless_null $P520, vivify_237
    $P520 = root_new ['parrot';'ResizablePMCArray']
  vivify_237:
    set $N521, $P520
    new $P522, 'Float'
    set $P522, $N521
    store_lex "$num_todo", $P522
.annotate 'line', 180
    new $P523, "Integer"
    assign $P523, 0
    store_lex "$i", $P523
.annotate 'line', 181
    new $P639, 'ExceptionHandler'
    set_label $P639, loop638_handler
    $P639."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P639
  loop638_test:
    find_lex $P524, "$i"
    set $N525, $P524
    find_lex $P526, "$num_todo"
    set $N527, $P526
    isne $I528, $N525, $N527
    unless $I528, loop638_done
  loop638_redo:
    .const 'Sub' $P530 = "41_1298845494.89" 
    capture_lex $P530
    $P530()
  loop638_next:
    goto loop638_test
  loop638_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P640, exception, 'type'
    eq $P640, .CONTROL_LOOP_NEXT, loop638_next
    eq $P640, .CONTROL_LOOP_REDO, loop638_redo
  loop638_done:
    pop_eh 
.annotate 'line', 178
    .return ($I528)
.end


.namespace ["NQPClassHOW"]
.sub "_block529"  :anon :subid("41_1298845494.89") :outer("40_1298845494.89")
.annotate 'line', 181
    .const 'Sub' $P566 = "42_1298845494.89" 
    capture_lex $P566
.annotate 'line', 183
    new $P531, "Undef"
    .lex "$name", $P531
.annotate 'line', 184
    new $P532, "Undef"
    .lex "$code", $P532
.annotate 'line', 188
    new $P533, "Undef"
    .lex "$dispatcher", $P533
.annotate 'line', 183
    find_lex $P534, "$i"
    set $I535, $P534
    find_lex $P536, "self"
    get_global $P537, "$?CLASS"
    getattribute $P538, $P536, $P537, "@!multi_methods_to_incorporate"
    unless_null $P538, vivify_238
    $P538 = root_new ['parrot';'ResizablePMCArray']
  vivify_238:
    set $P539, $P538[$I535]
    unless_null $P539, vivify_239
    $P539 = root_new ['parrot';'Hash']
  vivify_239:
    set $P540, $P539["name"]
    unless_null $P540, vivify_240
    new $P540, "Undef"
  vivify_240:
    store_lex "$name", $P540
.annotate 'line', 184
    find_lex $P541, "$i"
    set $I542, $P541
    find_lex $P543, "self"
    get_global $P544, "$?CLASS"
    getattribute $P545, $P543, $P544, "@!multi_methods_to_incorporate"
    unless_null $P545, vivify_241
    $P545 = root_new ['parrot';'ResizablePMCArray']
  vivify_241:
    set $P546, $P545[$I542]
    unless_null $P546, vivify_242
    $P546 = root_new ['parrot';'Hash']
  vivify_242:
    set $P547, $P546["code"]
    unless_null $P547, vivify_243
    new $P547, "Undef"
  vivify_243:
    store_lex "$code", $P547
.annotate 'line', 188
    find_lex $P548, "$name"
    find_lex $P549, "self"
    get_global $P550, "$?CLASS"
    getattribute $P551, $P549, $P550, "%!methods"
    unless_null $P551, vivify_244
    $P551 = root_new ['parrot';'Hash']
  vivify_244:
    set $P552, $P551[$P548]
    unless_null $P552, vivify_245
    new $P552, "Undef"
  vivify_245:
    store_lex "$dispatcher", $P552
.annotate 'line', 189
    find_lex $P554, "$dispatcher"
    defined $I555, $P554
    if $I555, if_553
.annotate 'line', 199
    .const 'Sub' $P566 = "42_1298845494.89" 
    capture_lex $P566
    $P566()
    goto if_553_end
  if_553:
.annotate 'line', 192
    find_lex $P557, "$dispatcher"
    is_dispatcher $I558, $P557
    if $I558, if_556
.annotate 'line', 196
    new $P561, 'String'
    set $P561, "Cannot have a multi candidate for "
    find_lex $P562, "$name"
    concat $P563, $P561, $P562
    concat $P564, $P563, " when an only method is also in the class"
    die $P564
.annotate 'line', 195
    goto if_556_end
  if_556:
.annotate 'line', 193
    find_lex $P559, "$dispatcher"
    find_lex $P560, "$code"
    push_dispatchee $P559, $P560
  if_556_end:
  if_553_end:
.annotate 'line', 227
    find_lex $P636, "$i"
    add $P637, $P636, 1
    store_lex "$i", $P637
.annotate 'line', 181
    .return ($P637)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block565"  :anon :subid("42_1298845494.89") :outer("41_1298845494.89")
.annotate 'line', 199
    .const 'Sub' $P583 = "43_1298845494.89" 
    capture_lex $P583
.annotate 'line', 201
    new $P567, "Undef"
    .lex "$j", $P567
.annotate 'line', 202
    new $P568, "Undef"
    .lex "$found", $P568
.annotate 'line', 201
    new $P569, "Integer"
    assign $P569, 1
    store_lex "$j", $P569
.annotate 'line', 202
    new $P570, "Integer"
    assign $P570, 0
    store_lex "$found", $P570
.annotate 'line', 203
    new $P627, 'ExceptionHandler'
    set_label $P627, loop626_handler
    $P627."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P627
  loop626_test:
    find_lex $P573, "$j"
    set $N574, $P573
    find_lex $P575, "self"
    get_global $P576, "$?CLASS"
    getattribute $P577, $P575, $P576, "@!mro"
    unless_null $P577, vivify_246
    $P577 = root_new ['parrot';'ResizablePMCArray']
  vivify_246:
    set $N578, $P577
    isne $I579, $N574, $N578
    if $I579, if_572
    new $P571, 'Integer'
    set $P571, $I579
    goto if_572_end
  if_572:
    find_lex $P580, "$found"
    isfalse $I581, $P580
    new $P571, 'Integer'
    set $P571, $I581
  if_572_end:
    unless $P571, loop626_done
  loop626_redo:
    .const 'Sub' $P583 = "43_1298845494.89" 
    capture_lex $P583
    $P583()
  loop626_next:
    goto loop626_test
  loop626_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P628, exception, 'type'
    eq $P628, .CONTROL_LOOP_NEXT, loop626_next
    eq $P628, .CONTROL_LOOP_REDO, loop626_redo
  loop626_done:
    pop_eh 
.annotate 'line', 223
    find_lex $P631, "$found"
    unless $P631, unless_630
    set $P629, $P631
    goto unless_630_end
  unless_630:
.annotate 'line', 224
    new $P632, 'String'
    set $P632, "Could not find a proto for multi "
    find_lex $P633, "$name"
    concat $P634, $P632, $P633
    concat $P635, $P634, ", and proto generation is NYI"
    die $P635
  unless_630_end:
.annotate 'line', 199
    .return ($P629)
.end


.namespace ["NQPClassHOW"]
.sub "_block582"  :anon :subid("43_1298845494.89") :outer("42_1298845494.89")
.annotate 'line', 203
    .const 'Sub' $P607 = "44_1298845494.89" 
    capture_lex $P607
.annotate 'line', 204
    new $P584, "Undef"
    .lex "$parent", $P584
.annotate 'line', 205
    $P585 = root_new ['parrot';'Hash']
    .lex "%meths", $P585
.annotate 'line', 206
    new $P586, "Undef"
    .lex "$dispatcher", $P586
.annotate 'line', 204
    find_lex $P587, "$j"
    set $I588, $P587
    find_lex $P589, "self"
    get_global $P590, "$?CLASS"
    getattribute $P591, $P589, $P590, "@!mro"
    unless_null $P591, vivify_247
    $P591 = root_new ['parrot';'ResizablePMCArray']
  vivify_247:
    set $P592, $P591[$I588]
    unless_null $P592, vivify_248
    new $P592, "Undef"
  vivify_248:
    store_lex "$parent", $P592
.annotate 'line', 205
    find_lex $P593, "$parent"
    get_how $P594, $P593
    find_lex $P595, "$parent"
    $P596 = $P594."method_table"($P595)
    store_lex "%meths", $P596
.annotate 'line', 206
    find_lex $P597, "$name"
    find_lex $P598, "%meths"
    unless_null $P598, vivify_249
    $P598 = root_new ['parrot';'Hash']
  vivify_249:
    set $P599, $P598[$P597]
    unless_null $P599, vivify_250
    new $P599, "Undef"
  vivify_250:
    store_lex "$dispatcher", $P599
.annotate 'line', 207
    find_lex $P601, "$dispatcher"
    defined $I602, $P601
    unless $I602, if_600_end
.annotate 'line', 210
    find_lex $P604, "$dispatcher"
    is_dispatcher $I605, $P604
    if $I605, if_603
.annotate 'line', 218
    new $P620, 'String'
    set $P620, "Could not find a proto for multi "
    find_lex $P621, "$name"
    concat $P622, $P620, $P621
    concat $P623, $P622, " (it may exist, but an only is hiding it if so)"
    die $P623
.annotate 'line', 217
    goto if_603_end
  if_603:
.annotate 'line', 210
    .const 'Sub' $P607 = "44_1298845494.89" 
    capture_lex $P607
    $P607()
  if_603_end:
  if_600_end:
.annotate 'line', 221
    find_lex $P624, "$j"
    add $P625, $P624, 1
    store_lex "$j", $P625
.annotate 'line', 203
    .return ($P625)
.end


.namespace ["NQPClassHOW"]
.sub "_block606"  :anon :subid("44_1298845494.89") :outer("43_1298845494.89")
.annotate 'line', 212
    $P608 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P608
.annotate 'line', 210
    find_lex $P609, "@new_dispatchees"
.annotate 'line', 213
    find_lex $P610, "$code"
    find_lex $P611, "@new_dispatchees"
    unless_null $P611, vivify_251
    $P611 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P611
  vivify_251:
    set $P611[0], $P610
.annotate 'line', 214
    find_lex $P612, "$dispatcher"
    find_lex $P613, "@new_dispatchees"
    create_dispatch_and_add_candidates $P614, $P612, $P613
    find_lex $P615, "$name"
    find_lex $P616, "self"
    get_global $P617, "$?CLASS"
    getattribute $P618, $P616, $P617, "%!methods"
    unless_null $P618, vivify_252
    $P618 = root_new ['parrot';'Hash']
    setattribute $P616, $P617, "%!methods", $P618
  vivify_252:
    set $P618[$P615], $P614
.annotate 'line', 215
    new $P619, "Integer"
    assign $P619, 1
    store_lex "$found", $P619
.annotate 'line', 210
    .return ($P619)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_type_cache"  :subid("45_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_644
    .param pmc param_645
.annotate 'line', 320
    .const 'Sub' $P670 = "47_1298845494.89" 
    capture_lex $P670
    .const 'Sub' $P655 = "46_1298845494.89" 
    capture_lex $P655
    .lex "self", param_644
    .lex "$obj", param_645
.annotate 'line', 321
    $P646 = root_new ['parrot';'ResizablePMCArray']
    .lex "@tc", $P646
.annotate 'line', 320
    find_lex $P647, "@tc"
.annotate 'line', 322
    find_lex $P649, "self"
    get_global $P650, "$?CLASS"
    getattribute $P651, $P649, $P650, "@!mro"
    unless_null $P651, vivify_253
    $P651 = root_new ['parrot';'ResizablePMCArray']
  vivify_253:
    defined $I652, $P651
    unless $I652, for_undef_254
    iter $P648, $P651
    new $P661, 'ExceptionHandler'
    set_label $P661, loop660_handler
    $P661."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P661
  loop660_test:
    unless $P648, loop660_done
    shift $P653, $P648
  loop660_redo:
    .const 'Sub' $P655 = "46_1298845494.89" 
    capture_lex $P655
    $P655($P653)
  loop660_next:
    goto loop660_test
  loop660_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P662, exception, 'type'
    eq $P662, .CONTROL_LOOP_NEXT, loop660_next
    eq $P662, .CONTROL_LOOP_REDO, loop660_redo
  loop660_done:
    pop_eh 
  for_undef_254:
.annotate 'line', 323
    find_lex $P664, "self"
    get_global $P665, "$?CLASS"
    getattribute $P666, $P664, $P665, "@!done"
    unless_null $P666, vivify_255
    $P666 = root_new ['parrot';'ResizablePMCArray']
  vivify_255:
    defined $I667, $P666
    unless $I667, for_undef_256
    iter $P663, $P666
    new $P676, 'ExceptionHandler'
    set_label $P676, loop675_handler
    $P676."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P676
  loop675_test:
    unless $P663, loop675_done
    shift $P668, $P663
  loop675_redo:
    .const 'Sub' $P670 = "47_1298845494.89" 
    capture_lex $P670
    $P670($P668)
  loop675_next:
    goto loop675_test
  loop675_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P677, exception, 'type'
    eq $P677, .CONTROL_LOOP_NEXT, loop675_next
    eq $P677, .CONTROL_LOOP_REDO, loop675_redo
  loop675_done:
    pop_eh 
  for_undef_256:
.annotate 'line', 324
    find_lex $P678, "$obj"
    find_lex $P679, "@tc"
    publish_type_check_cache $P678, $P679
.annotate 'line', 320
    .return ()
.end


.namespace ["NQPClassHOW"]
.sub "_block654"  :anon :subid("46_1298845494.89") :outer("45_1298845494.89")
    .param pmc param_656
.annotate 'line', 322
    .lex "$_", param_656
    find_lex $P657, "@tc"
    find_lex $P658, "$_"
    $P659 = $P657."push"($P658)
    .return ($P659)
.end


.namespace ["NQPClassHOW"]
.sub "_block669"  :anon :subid("47_1298845494.89") :outer("45_1298845494.89")
    .param pmc param_671
.annotate 'line', 323
    .lex "$_", param_671
    find_lex $P672, "@tc"
    find_lex $P673, "$_"
    $P674 = $P672."push"($P673)
    .return ($P674)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("48_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_681
    .param pmc param_682
.annotate 'line', 327
    .const 'Sub' $P692 = "49_1298845494.89" 
    capture_lex $P692
    .lex "self", param_681
    .lex "$obj", param_682
.annotate 'line', 330
    $P683 = root_new ['parrot';'Hash']
    .lex "%cache", $P683
.annotate 'line', 327
    find_lex $P684, "%cache"
.annotate 'line', 331
    find_lex $P686, "self"
    get_global $P687, "$?CLASS"
    getattribute $P688, $P686, $P687, "@!mro"
    unless_null $P688, vivify_257
    $P688 = root_new ['parrot';'ResizablePMCArray']
  vivify_257:
    defined $I689, $P688
    unless $I689, for_undef_258
    iter $P685, $P688
    new $P721, 'ExceptionHandler'
    set_label $P721, loop720_handler
    $P721."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P721
  loop720_test:
    unless $P685, loop720_done
    shift $P690, $P685
  loop720_redo:
    .const 'Sub' $P692 = "49_1298845494.89" 
    capture_lex $P692
    $P692($P690)
  loop720_next:
    goto loop720_test
  loop720_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P722, exception, 'type'
    eq $P722, .CONTROL_LOOP_NEXT, loop720_next
    eq $P722, .CONTROL_LOOP_REDO, loop720_redo
  loop720_done:
    pop_eh 
  for_undef_258:
.annotate 'line', 339
    find_lex $P723, "$obj"
    find_lex $P724, "%cache"
    publish_method_cache $P723, $P724
.annotate 'line', 327
    .return ()
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block691"  :anon :subid("49_1298845494.89") :outer("48_1298845494.89")
    .param pmc param_694
.annotate 'line', 331
    .const 'Sub' $P704 = "50_1298845494.89" 
    capture_lex $P704
.annotate 'line', 332
    $P693 = root_new ['parrot';'Hash']
    .lex "%methods", $P693
    .lex "$_", param_694
    find_lex $P695, "$_"
    get_how $P696, $P695
    find_lex $P697, "$_"
    $P698 = $P696."method_table"($P697)
    store_lex "%methods", $P698
.annotate 'line', 333
    find_lex $P700, "%methods"
    defined $I701, $P700
    unless $I701, for_undef_259
    iter $P699, $P700
    new $P718, 'ExceptionHandler'
    set_label $P718, loop717_handler
    $P718."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P718
  loop717_test:
    unless $P699, loop717_done
    shift $P702, $P699
  loop717_redo:
    .const 'Sub' $P704 = "50_1298845494.89" 
    capture_lex $P704
    $P704($P702)
  loop717_next:
    goto loop717_test
  loop717_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P719, exception, 'type'
    eq $P719, .CONTROL_LOOP_NEXT, loop717_next
    eq $P719, .CONTROL_LOOP_REDO, loop717_redo
  loop717_done:
    pop_eh 
  for_undef_259:
.annotate 'line', 331
    .return ($P699)
.end


.namespace ["NQPClassHOW"]
.sub "_block703"  :anon :subid("50_1298845494.89") :outer("49_1298845494.89")
    .param pmc param_705
.annotate 'line', 333
    .lex "$_", param_705
.annotate 'line', 334
    find_lex $P708, "$_"
    $P709 = $P708."key"()
    find_lex $P710, "%cache"
    unless_null $P710, vivify_260
    $P710 = root_new ['parrot';'Hash']
  vivify_260:
    set $P711, $P710[$P709]
    unless_null $P711, vivify_261
    new $P711, "Undef"
  vivify_261:
    unless $P711, unless_707
    set $P706, $P711
    goto unless_707_end
  unless_707:
.annotate 'line', 335
    find_lex $P712, "$_"
    $P713 = $P712."value"()
    find_lex $P714, "$_"
    $P715 = $P714."key"()
    find_lex $P716, "%cache"
    unless_null $P716, vivify_262
    $P716 = root_new ['parrot';'Hash']
    store_lex "%cache", $P716
  vivify_262:
    set $P716[$P715], $P713
.annotate 'line', 334
    set $P706, $P713
  unless_707_end:
.annotate 'line', 333
    .return ($P706)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_parrot_vtable_mapping"  :subid("51_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_726
    .param pmc param_727
.annotate 'line', 342
    .const 'Sub' $P737 = "52_1298845494.89" 
    capture_lex $P737
    .lex "self", param_726
    .lex "$obj", param_727
.annotate 'line', 343
    $P728 = root_new ['parrot';'Hash']
    .lex "%mapping", $P728
.annotate 'line', 342
    find_lex $P729, "%mapping"
.annotate 'line', 344
    find_lex $P731, "self"
    get_global $P732, "$?CLASS"
    getattribute $P733, $P731, $P732, "@!mro"
    unless_null $P733, vivify_263
    $P733 = root_new ['parrot';'ResizablePMCArray']
  vivify_263:
    defined $I734, $P733
    unless $I734, for_undef_264
    iter $P730, $P733
    new $P766, 'ExceptionHandler'
    set_label $P766, loop765_handler
    $P766."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P766
  loop765_test:
    unless $P730, loop765_done
    shift $P735, $P730
  loop765_redo:
    .const 'Sub' $P737 = "52_1298845494.89" 
    capture_lex $P737
    $P737($P735)
  loop765_next:
    goto loop765_test
  loop765_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P767, exception, 'type'
    eq $P767, .CONTROL_LOOP_NEXT, loop765_next
    eq $P767, .CONTROL_LOOP_REDO, loop765_redo
  loop765_done:
    pop_eh 
  for_undef_264:
.annotate 'line', 352
    find_lex $P770, "%mapping"
    set $N771, $P770
    if $N771, if_769
    new $P768, 'Float'
    set $P768, $N771
    goto if_769_end
  if_769:
.annotate 'line', 353
    find_lex $P772, "$obj"
    find_lex $P773, "%mapping"
    stable_publish_vtable_mapping $P772, $P773
  if_769_end:
.annotate 'line', 342
    .return ($P768)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block736"  :anon :subid("52_1298845494.89") :outer("51_1298845494.89")
    .param pmc param_739
.annotate 'line', 344
    .const 'Sub' $P749 = "53_1298845494.89" 
    capture_lex $P749
.annotate 'line', 345
    $P738 = root_new ['parrot';'Hash']
    .lex "%map", $P738
    .lex "$_", param_739
    find_lex $P740, "$_"
    get_how $P741, $P740
    find_lex $P742, "$_"
    $P743 = $P741."parrot_vtable_mappings"($P742, 1 :named("local"))
    store_lex "%map", $P743
.annotate 'line', 346
    find_lex $P745, "%map"
    defined $I746, $P745
    unless $I746, for_undef_265
    iter $P744, $P745
    new $P763, 'ExceptionHandler'
    set_label $P763, loop762_handler
    $P763."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P763
  loop762_test:
    unless $P744, loop762_done
    shift $P747, $P744
  loop762_redo:
    .const 'Sub' $P749 = "53_1298845494.89" 
    capture_lex $P749
    $P749($P747)
  loop762_next:
    goto loop762_test
  loop762_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P764, exception, 'type'
    eq $P764, .CONTROL_LOOP_NEXT, loop762_next
    eq $P764, .CONTROL_LOOP_REDO, loop762_redo
  loop762_done:
    pop_eh 
  for_undef_265:
.annotate 'line', 344
    .return ($P744)
.end


.namespace ["NQPClassHOW"]
.sub "_block748"  :anon :subid("53_1298845494.89") :outer("52_1298845494.89")
    .param pmc param_750
.annotate 'line', 346
    .lex "$_", param_750
.annotate 'line', 347
    find_lex $P753, "$_"
    $P754 = $P753."key"()
    find_lex $P755, "%mapping"
    unless_null $P755, vivify_266
    $P755 = root_new ['parrot';'Hash']
  vivify_266:
    set $P756, $P755[$P754]
    unless_null $P756, vivify_267
    new $P756, "Undef"
  vivify_267:
    unless $P756, unless_752
    set $P751, $P756
    goto unless_752_end
  unless_752:
.annotate 'line', 348
    find_lex $P757, "$_"
    $P758 = $P757."value"()
    find_lex $P759, "$_"
    $P760 = $P759."key"()
    find_lex $P761, "%mapping"
    unless_null $P761, vivify_268
    $P761 = root_new ['parrot';'Hash']
    store_lex "%mapping", $P761
  vivify_268:
    set $P761[$P760], $P758
.annotate 'line', 347
    set $P751, $P758
  unless_752_end:
.annotate 'line', 346
    .return ($P751)
.end


.namespace ["NQPClassHOW"]
.sub "parents"  :subid("54_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_775
    .param pmc param_776
    .param pmc param_777 :optional :named("local")
    .param int has_param_777 :opt_flag
.annotate 'line', 361
    .lex "self", param_775
    .lex "$obj", param_776
    if has_param_777, optparam_269
    new $P778, "Undef"
    set param_777, $P778
  optparam_269:
    .lex "$local", param_777
.annotate 'line', 362
    find_lex $P781, "$local"
    if $P781, if_780
    find_lex $P785, "self"
    get_global $P786, "$?CLASS"
    getattribute $P787, $P785, $P786, "@!mro"
    unless_null $P787, vivify_270
    $P787 = root_new ['parrot';'ResizablePMCArray']
  vivify_270:
    set $P779, $P787
    goto if_780_end
  if_780:
    find_lex $P782, "self"
    get_global $P783, "$?CLASS"
    getattribute $P784, $P782, $P783, "@!parents"
    unless_null $P784, vivify_271
    $P784 = root_new ['parrot';'ResizablePMCArray']
  vivify_271:
    set $P779, $P784
  if_780_end:
.annotate 'line', 361
    .return ($P779)
.end


.namespace ["NQPClassHOW"]
.sub "roles"  :subid("55_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_789
    .param pmc param_790
    .param pmc param_791 :named("local")
.annotate 'line', 365
    .lex "self", param_789
    .lex "$obj", param_790
    .lex "$local", param_791
    find_lex $P792, "self"
    get_global $P793, "$?CLASS"
    getattribute $P794, $P792, $P793, "@!roles"
    unless_null $P794, vivify_272
    $P794 = root_new ['parrot';'ResizablePMCArray']
  vivify_272:
    .return ($P794)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("56_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_796
    .param pmc param_797
    .param pmc param_798 :named("local")
.annotate 'line', 369
    .const 'Sub' $P808 = "57_1298845494.89" 
    capture_lex $P808
    .lex "self", param_796
    .lex "$obj", param_797
    .lex "$local", param_798
.annotate 'line', 370
    $P799 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P799
.annotate 'line', 369
    find_lex $P800, "@meths"
.annotate 'line', 371
    find_lex $P802, "self"
    get_global $P803, "$?CLASS"
    getattribute $P804, $P802, $P803, "%!methods"
    unless_null $P804, vivify_273
    $P804 = root_new ['parrot';'Hash']
  vivify_273:
    defined $I805, $P804
    unless $I805, for_undef_274
    iter $P801, $P804
    new $P815, 'ExceptionHandler'
    set_label $P815, loop814_handler
    $P815."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P815
  loop814_test:
    unless $P801, loop814_done
    shift $P806, $P801
  loop814_redo:
    .const 'Sub' $P808 = "57_1298845494.89" 
    capture_lex $P808
    $P808($P806)
  loop814_next:
    goto loop814_test
  loop814_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P816, exception, 'type'
    eq $P816, .CONTROL_LOOP_NEXT, loop814_next
    eq $P816, .CONTROL_LOOP_REDO, loop814_redo
  loop814_done:
    pop_eh 
  for_undef_274:
    find_lex $P817, "@meths"
.annotate 'line', 369
    .return ($P817)
.end


.namespace ["NQPClassHOW"]
.sub "_block807"  :anon :subid("57_1298845494.89") :outer("56_1298845494.89")
    .param pmc param_809
.annotate 'line', 371
    .lex "$_", param_809
.annotate 'line', 372
    find_lex $P810, "@meths"
    find_lex $P811, "$_"
    $P812 = $P811."value"()
    $P813 = $P810."push"($P812)
.annotate 'line', 371
    .return ($P813)
.end


.namespace ["NQPClassHOW"]
.sub "method_table"  :subid("58_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_819
    .param pmc param_820
.annotate 'line', 377
    .lex "self", param_819
    .lex "$obj", param_820
    find_lex $P821, "self"
    get_global $P822, "$?CLASS"
    getattribute $P823, $P821, $P822, "%!methods"
    unless_null $P823, vivify_275
    $P823 = root_new ['parrot';'Hash']
  vivify_275:
    .return ($P823)
.end


.namespace ["NQPClassHOW"]
.sub "name"  :subid("59_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_825
    .param pmc param_826
.annotate 'line', 381
    .lex "self", param_825
    .lex "$obj", param_826
    find_lex $P827, "self"
    get_global $P828, "$?CLASS"
    getattribute $P829, $P827, $P828, "$!name"
    unless_null $P829, vivify_276
    new $P829, "Undef"
  vivify_276:
    .return ($P829)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("60_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_831
    .param pmc param_832
    .param pmc param_833 :named("local")
.annotate 'line', 385
    .const 'Sub' $P843 = "61_1298845494.89" 
    capture_lex $P843
    .lex "self", param_831
    .lex "$obj", param_832
    .lex "$local", param_833
.annotate 'line', 386
    $P834 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P834
.annotate 'line', 385
    find_lex $P835, "@attrs"
.annotate 'line', 387
    find_lex $P837, "self"
    get_global $P838, "$?CLASS"
    getattribute $P839, $P837, $P838, "%!attributes"
    unless_null $P839, vivify_277
    $P839 = root_new ['parrot';'Hash']
  vivify_277:
    defined $I840, $P839
    unless $I840, for_undef_278
    iter $P836, $P839
    new $P850, 'ExceptionHandler'
    set_label $P850, loop849_handler
    $P850."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P850
  loop849_test:
    unless $P836, loop849_done
    shift $P841, $P836
  loop849_redo:
    .const 'Sub' $P843 = "61_1298845494.89" 
    capture_lex $P843
    $P843($P841)
  loop849_next:
    goto loop849_test
  loop849_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P851, exception, 'type'
    eq $P851, .CONTROL_LOOP_NEXT, loop849_next
    eq $P851, .CONTROL_LOOP_REDO, loop849_redo
  loop849_done:
    pop_eh 
  for_undef_278:
    find_lex $P852, "@attrs"
.annotate 'line', 385
    .return ($P852)
.end


.namespace ["NQPClassHOW"]
.sub "_block842"  :anon :subid("61_1298845494.89") :outer("60_1298845494.89")
    .param pmc param_844
.annotate 'line', 387
    .lex "$_", param_844
.annotate 'line', 388
    find_lex $P845, "@attrs"
    find_lex $P846, "$_"
    $P847 = $P846."value"()
    $P848 = $P845."push"($P847)
.annotate 'line', 387
    .return ($P848)
.end


.namespace ["NQPClassHOW"]
.sub "parrot_vtable_mappings"  :subid("62_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_854
    .param pmc param_855
    .param pmc param_856 :named("local")
.annotate 'line', 393
    .lex "self", param_854
    .lex "$obj", param_855
    .lex "$local", param_856
    find_lex $P857, "self"
    get_global $P858, "$?CLASS"
    getattribute $P859, $P857, $P858, "%!parrot_vtable_mapping"
    unless_null $P859, vivify_279
    $P859 = root_new ['parrot';'Hash']
  vivify_279:
    .return ($P859)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("63_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_863
    .param pmc param_864
    .param pmc param_865
.annotate 'line', 401
    new $P862, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P862, control_861
    push_eh $P862
    .lex "self", param_863
    .lex "$obj", param_864
    .lex "$check", param_865
.annotate 'line', 402
    new $P866, "Undef"
    .lex "$check-class", $P866
.annotate 'line', 403
    new $P867, "Undef"
    .lex "$i", $P867
.annotate 'line', 402
    find_lex $P868, "$check"
    get_what $P869, $P868
    store_lex "$check-class", $P869
.annotate 'line', 403
    find_lex $P870, "self"
    get_global $P871, "$?CLASS"
    getattribute $P872, $P870, $P871, "@!mro"
    unless_null $P872, vivify_280
    $P872 = root_new ['parrot';'ResizablePMCArray']
  vivify_280:
    set $N873, $P872
    new $P874, 'Float'
    set $P874, $N873
    store_lex "$i", $P874
.annotate 'line', 404
    new $P892, 'ExceptionHandler'
    set_label $P892, loop891_handler
    $P892."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P892
  loop891_test:
    find_lex $P875, "$i"
    set $N876, $P875
    isgt $I877, $N876, 0.0
    unless $I877, loop891_done
  loop891_redo:
.annotate 'line', 405
    find_lex $P878, "$i"
    sub $P879, $P878, 1
    store_lex "$i", $P879
.annotate 'line', 406
    find_lex $P881, "$i"
    set $I882, $P881
    find_lex $P883, "self"
    get_global $P884, "$?CLASS"
    getattribute $P885, $P883, $P884, "@!mro"
    unless_null $P885, vivify_281
    $P885 = root_new ['parrot';'ResizablePMCArray']
  vivify_281:
    set $P886, $P885[$I882]
    unless_null $P886, vivify_282
    new $P886, "Undef"
  vivify_282:
    find_lex $P887, "$check-class"
    issame $I888, $P886, $P887
    unless $I888, if_880_end
.annotate 'line', 407
    new $P889, "Exception"
    set $P889['type'], .CONTROL_RETURN
    new $P890, "Integer"
    assign $P890, 1
    setattribute $P889, 'payload', $P890
    throw $P889
  if_880_end:
  loop891_next:
.annotate 'line', 404
    goto loop891_test
  loop891_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P893, exception, 'type'
    eq $P893, .CONTROL_LOOP_NEXT, loop891_next
    eq $P893, .CONTROL_LOOP_REDO, loop891_redo
  loop891_done:
    pop_eh 
.annotate 'line', 410
    new $P894, "Exception"
    set $P894['type'], .CONTROL_RETURN
    new $P895, "Integer"
    assign $P895, 0
    setattribute $P894, 'payload', $P895
    throw $P894
.annotate 'line', 401
    .return ()
  control_861:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P896, exception, "payload"
    .return ($P896)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("64_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_900
    .param pmc param_901
    .param pmc param_902
.annotate 'line', 413
    new $P899, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P899, control_898
    push_eh $P899
    .lex "self", param_900
    .lex "$obj", param_901
    .lex "$check", param_902
.annotate 'line', 414
    new $P903, "Undef"
    .lex "$i", $P903
    find_lex $P904, "self"
    get_global $P905, "$?CLASS"
    getattribute $P906, $P904, $P905, "@!done"
    unless_null $P906, vivify_283
    $P906 = root_new ['parrot';'ResizablePMCArray']
  vivify_283:
    set $N907, $P906
    new $P908, 'Float'
    set $P908, $N907
    store_lex "$i", $P908
.annotate 'line', 415
    new $P926, 'ExceptionHandler'
    set_label $P926, loop925_handler
    $P926."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P926
  loop925_test:
    find_lex $P909, "$i"
    set $N910, $P909
    isgt $I911, $N910, 0.0
    unless $I911, loop925_done
  loop925_redo:
.annotate 'line', 416
    find_lex $P912, "$i"
    sub $P913, $P912, 1
    store_lex "$i", $P913
.annotate 'line', 417
    find_lex $P915, "$i"
    set $I916, $P915
    find_lex $P917, "self"
    get_global $P918, "$?CLASS"
    getattribute $P919, $P917, $P918, "@!done"
    unless_null $P919, vivify_284
    $P919 = root_new ['parrot';'ResizablePMCArray']
  vivify_284:
    set $P920, $P919[$I916]
    unless_null $P920, vivify_285
    new $P920, "Undef"
  vivify_285:
    find_lex $P921, "$check"
    issame $I922, $P920, $P921
    unless $I922, if_914_end
.annotate 'line', 418
    new $P923, "Exception"
    set $P923['type'], .CONTROL_RETURN
    new $P924, "Integer"
    assign $P924, 1
    setattribute $P923, 'payload', $P924
    throw $P923
  if_914_end:
  loop925_next:
.annotate 'line', 415
    goto loop925_test
  loop925_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P927, exception, 'type'
    eq $P927, .CONTROL_LOOP_NEXT, loop925_next
    eq $P927, .CONTROL_LOOP_REDO, loop925_redo
  loop925_done:
    pop_eh 
.annotate 'line', 421
    new $P928, "Exception"
    set $P928['type'], .CONTROL_RETURN
    new $P929, "Integer"
    assign $P929, 0
    setattribute $P928, 'payload', $P929
    throw $P928
.annotate 'line', 413
    .return ()
  control_898:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P930, exception, "payload"
    .return ($P930)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("65_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_934
    .param pmc param_935
    .param pmc param_936
.annotate 'line', 424
    .const 'Sub' $P944 = "66_1298845494.89" 
    capture_lex $P944
    new $P933, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P933, control_932
    push_eh $P933
    .lex "self", param_934
    .lex "$obj", param_935
    .lex "$name", param_936
.annotate 'line', 425
    find_lex $P938, "self"
    get_global $P939, "$?CLASS"
    getattribute $P940, $P938, $P939, "@!mro"
    unless_null $P940, vivify_286
    $P940 = root_new ['parrot';'ResizablePMCArray']
  vivify_286:
    defined $I941, $P940
    unless $I941, for_undef_287
    iter $P937, $P940
    new $P962, 'ExceptionHandler'
    set_label $P962, loop961_handler
    $P962."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P962
  loop961_test:
    unless $P937, loop961_done
    shift $P942, $P937
  loop961_redo:
    .const 'Sub' $P944 = "66_1298845494.89" 
    capture_lex $P944
    $P944($P942)
  loop961_next:
    goto loop961_test
  loop961_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P963, exception, 'type'
    eq $P963, .CONTROL_LOOP_NEXT, loop961_next
    eq $P963, .CONTROL_LOOP_REDO, loop961_redo
  loop961_done:
    pop_eh 
  for_undef_287:
.annotate 'line', 432
    new $P964, "Exception"
    set $P964['type'], .CONTROL_RETURN
    new $P965, "Integer"
    assign $P965, 0
    setattribute $P964, 'payload', $P965
    throw $P964
.annotate 'line', 424
    .return ()
  control_932:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P966, exception, "payload"
    .return ($P966)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block943"  :anon :subid("66_1298845494.89") :outer("65_1298845494.89")
    .param pmc param_947
.annotate 'line', 426
    $P945 = root_new ['parrot';'Hash']
    .lex "%meths", $P945
.annotate 'line', 427
    new $P946, "Undef"
    .lex "$can", $P946
    .lex "$_", param_947
.annotate 'line', 426
    find_lex $P948, "$_"
    get_how $P949, $P948
    find_lex $P950, "$obj"
    $P951 = $P949."method_table"($P950)
    store_lex "%meths", $P951
.annotate 'line', 427
    find_lex $P952, "$name"
    find_lex $P953, "%meths"
    unless_null $P953, vivify_288
    $P953 = root_new ['parrot';'Hash']
  vivify_288:
    set $P954, $P953[$P952]
    unless_null $P954, vivify_289
    new $P954, "Undef"
  vivify_289:
    store_lex "$can", $P954
.annotate 'line', 428
    find_lex $P957, "$can"
    defined $I958, $P957
    if $I958, if_956
    new $P955, 'Integer'
    set $P955, $I958
    goto if_956_end
  if_956:
.annotate 'line', 429
    new $P959, "Exception"
    set $P959['type'], .CONTROL_RETURN
    find_lex $P960, "$can"
    setattribute $P959, 'payload', $P960
    throw $P959
  if_956_end:
.annotate 'line', 425
    .return ($P955)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("67_1298845494.89") :outer("15_1298845494.89")
    .param pmc param_970
    .param pmc param_971
    .param pmc param_972
.annotate 'line', 438
    .const 'Sub' $P980 = "68_1298845494.89" 
    capture_lex $P980
    new $P969, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P969, control_968
    push_eh $P969
    .lex "self", param_970
    .lex "$obj", param_971
    .lex "$name", param_972
.annotate 'line', 439
    find_lex $P974, "self"
    get_global $P975, "$?CLASS"
    getattribute $P976, $P974, $P975, "@!mro"
    unless_null $P976, vivify_290
    $P976 = root_new ['parrot';'ResizablePMCArray']
  vivify_290:
    defined $I977, $P976
    unless $I977, for_undef_291
    iter $P973, $P976
    new $P998, 'ExceptionHandler'
    set_label $P998, loop997_handler
    $P998."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P998
  loop997_test:
    unless $P973, loop997_done
    shift $P978, $P973
  loop997_redo:
    .const 'Sub' $P980 = "68_1298845494.89" 
    capture_lex $P980
    $P980($P978)
  loop997_next:
    goto loop997_test
  loop997_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P999, exception, 'type'
    eq $P999, .CONTROL_LOOP_NEXT, loop997_next
    eq $P999, .CONTROL_LOOP_REDO, loop997_redo
  loop997_done:
    pop_eh 
  for_undef_291:
.annotate 'line', 446
    null $P1000
.annotate 'line', 438
    .return ($P1000)
  control_968:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1001, exception, "payload"
    .return ($P1001)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block979"  :anon :subid("68_1298845494.89") :outer("67_1298845494.89")
    .param pmc param_983
.annotate 'line', 440
    $P981 = root_new ['parrot';'Hash']
    .lex "%meths", $P981
.annotate 'line', 441
    new $P982, "Undef"
    .lex "$found", $P982
    .lex "$_", param_983
.annotate 'line', 440
    find_lex $P984, "$_"
    get_how $P985, $P984
    find_lex $P986, "$obj"
    $P987 = $P985."method_table"($P986)
    store_lex "%meths", $P987
.annotate 'line', 441
    find_lex $P988, "$name"
    find_lex $P989, "%meths"
    unless_null $P989, vivify_292
    $P989 = root_new ['parrot';'Hash']
  vivify_292:
    set $P990, $P989[$P988]
    unless_null $P990, vivify_293
    new $P990, "Undef"
  vivify_293:
    store_lex "$found", $P990
.annotate 'line', 442
    find_lex $P993, "$found"
    defined $I994, $P993
    if $I994, if_992
    new $P991, 'Integer'
    set $P991, $I994
    goto if_992_end
  if_992:
.annotate 'line', 443
    new $P995, "Exception"
    set $P995['type'], .CONTROL_RETURN
    find_lex $P996, "$found"
    setattribute $P995, 'payload', $P996
    throw $P995
  if_992_end:
.annotate 'line', 439
    .return ($P991)
.end


.namespace ["NQPNativeHOW"]
.sub "_block1095"  :subid("70_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 451
    .const 'Sub' $P1156 = "79_1298845494.89" 
    capture_lex $P1156
    .const 'Sub' $P1148 = "78_1298845494.89" 
    capture_lex $P1148
    .const 'Sub' $P1142 = "77_1298845494.89" 
    capture_lex $P1142
    .const 'Sub' $P1138 = "76_1298845494.89" 
    capture_lex $P1138
    .const 'Sub' $P1133 = "75_1298845494.89" 
    capture_lex $P1133
    .const 'Sub' $P1128 = "74_1298845494.89" 
    capture_lex $P1128
    .const 'Sub' $P1115 = "73_1298845494.89" 
    capture_lex $P1115
    .const 'Sub' $P1108 = "72_1298845494.89" 
    capture_lex $P1108
    .const 'Sub' $P1098 = "71_1298845494.89" 
    capture_lex $P1098
    get_global $P1097, "$?CLASS"
.annotate 'line', 489
    .const 'Sub' $P1148 = "78_1298845494.89" 
    newclosure $P1154, $P1148
.annotate 'line', 451
    .return ($P1154)
.end


.namespace ["NQPNativeHOW"]
.sub "" :load :init :subid("post294") :outer("70_1298845494.89")
.annotate 'line', 451
    get_hll_global $P1096, ["NQPNativeHOW"], "_block1095" 
    .local pmc block
    set block, $P1096
    .const 'Sub' $P1156 = "79_1298845494.89" 
    capture_lex $P1156
    $P1156()
.end


.namespace ["NQPNativeHOW"]
.sub "_block1155"  :anon :subid("79_1298845494.89") :outer("70_1298845494.89")
.annotate 'line', 451
    get_hll_global $P1157, "KnowHOW"
    $P1158 = $P1157."new_type"("NQPNativeHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1158
    set_hll_global "NQPNativeHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1159, type_obj
    get_hll_global $P1160, "KnowHOWAttribute"
    $P1161 = $P1160."new"("$!name" :named("name"))
    $P1159."add_attribute"(type_obj, $P1161)
    get_how $P1162, type_obj
    get_hll_global $P1163, "KnowHOWAttribute"
    $P1164 = $P1163."new"("$!composed" :named("name"))
    $P1162."add_attribute"(type_obj, $P1164)
    get_how $P1165, type_obj
    .const 'Sub' $P1166 = "71_1298845494.89" 
    $P1165."add_method"(type_obj, "new", $P1166)
    get_how $P1167, type_obj
    .const 'Sub' $P1168 = "72_1298845494.89" 
    $P1167."add_method"(type_obj, "BUILD", $P1168)
    get_how $P1169, type_obj
    .const 'Sub' $P1170 = "73_1298845494.89" 
    $P1169."add_method"(type_obj, "new_type", $P1170)
    get_how $P1171, type_obj
    .const 'Sub' $P1172 = "74_1298845494.89" 
    $P1171."add_method"(type_obj, "add_method", $P1172)
    get_how $P1173, type_obj
    .const 'Sub' $P1174 = "75_1298845494.89" 
    $P1173."add_method"(type_obj, "add_multi_method", $P1174)
    get_how $P1175, type_obj
    .const 'Sub' $P1176 = "76_1298845494.89" 
    $P1175."add_method"(type_obj, "add_attribute", $P1176)
    get_how $P1177, type_obj
    .const 'Sub' $P1178 = "77_1298845494.89" 
    $P1177."add_method"(type_obj, "compose", $P1178)
    get_how $P1179, type_obj
    .const 'Sub' $P1180 = "78_1298845494.89" 
    $P1179."add_method"(type_obj, "name", $P1180)
    get_how $P1181, type_obj
    $P1182 = $P1181."compose"(type_obj)
    .return ($P1182)
.end


.namespace ["NQPNativeHOW"]
.sub "new"  :subid("71_1298845494.89") :outer("70_1298845494.89")
    .param pmc param_1099
    .param pmc param_1100 :optional :named("name")
    .param int has_param_1100 :opt_flag
.annotate 'line', 455
    .lex "self", param_1099
    if has_param_1100, optparam_295
    new $P1101, "Undef"
    set param_1100, $P1101
  optparam_295:
    .lex "$name", param_1100
.annotate 'line', 456
    new $P1102, "Undef"
    .lex "$obj", $P1102
    find_lex $P1103, "self"
    repr_instance_of $P1104, $P1103
    store_lex "$obj", $P1104
.annotate 'line', 457
    find_lex $P1105, "$obj"
    find_lex $P1106, "$name"
    $P1105."BUILD"($P1106 :named("name"))
    find_lex $P1107, "$obj"
.annotate 'line', 455
    .return ($P1107)
.end


.namespace ["NQPNativeHOW"]
.sub "BUILD"  :subid("72_1298845494.89") :outer("70_1298845494.89")
    .param pmc param_1109
    .param pmc param_1110 :optional :named("name")
    .param int has_param_1110 :opt_flag
.annotate 'line', 461
    .lex "self", param_1109
    if has_param_1110, optparam_296
    new $P1111, "Undef"
    set param_1110, $P1111
  optparam_296:
    .lex "$name", param_1110
.annotate 'line', 462
    find_lex $P1112, "$name"
    find_lex $P1113, "self"
    get_global $P1114, "$?CLASS"
    setattribute $P1113, $P1114, "$!name", $P1112
.annotate 'line', 461
    .return ($P1112)
.end


.namespace ["NQPNativeHOW"]
.sub "new_type"  :subid("73_1298845494.89") :outer("70_1298845494.89")
    .param pmc param_1116
    .param pmc param_1119 :named("repr")
    .param pmc param_1117 :optional :named("name")
    .param int has_param_1117 :opt_flag
.annotate 'line', 468
    .lex "self", param_1116
    if has_param_1117, optparam_297
    new $P1118, "String"
    assign $P1118, "<anon>"
    set param_1117, $P1118
  optparam_297:
    .lex "$name", param_1117
    .lex "$repr", param_1119
.annotate 'line', 469
    new $P1120, "Undef"
    .lex "$metaclass", $P1120
    find_lex $P1121, "self"
    find_lex $P1122, "$name"
    $P1123 = $P1121."new"($P1122 :named("name"))
    store_lex "$metaclass", $P1123
.annotate 'line', 470
    find_lex $P1124, "$metaclass"
    find_lex $P1125, "$repr"
    set $S1126, $P1125
    repr_type_object_for $P1127, $P1124, $S1126
.annotate 'line', 468
    .return ($P1127)
.end


.namespace ["NQPNativeHOW"]
.sub "add_method"  :subid("74_1298845494.89") :outer("70_1298845494.89")
    .param pmc param_1129
    .param pmc param_1130
    .param pmc param_1131
    .param pmc param_1132
.annotate 'line', 473
    .lex "self", param_1129
    .lex "$obj", param_1130
    .lex "$name", param_1131
    .lex "$code_obj", param_1132
.annotate 'line', 474
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 473
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_multi_method"  :subid("75_1298845494.89") :outer("70_1298845494.89")
    .param pmc param_1134
    .param pmc param_1135
    .param pmc param_1136
    .param pmc param_1137
.annotate 'line', 477
    .lex "self", param_1134
    .lex "$obj", param_1135
    .lex "$name", param_1136
    .lex "$code_obj", param_1137
.annotate 'line', 478
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 477
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_attribute"  :subid("76_1298845494.89") :outer("70_1298845494.89")
    .param pmc param_1139
    .param pmc param_1140
    .param pmc param_1141
.annotate 'line', 481
    .lex "self", param_1139
    .lex "$obj", param_1140
    .lex "$meta_attr", param_1141
.annotate 'line', 482
    die "Native types may not have attributes"
.annotate 'line', 481
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "compose"  :subid("77_1298845494.89") :outer("70_1298845494.89")
    .param pmc param_1143
    .param pmc param_1144
.annotate 'line', 485
    .lex "self", param_1143
    .lex "$obj", param_1144
.annotate 'line', 486
    new $P1145, "Integer"
    assign $P1145, 1
    find_lex $P1146, "self"
    get_global $P1147, "$?CLASS"
    setattribute $P1146, $P1147, "$!composed", $P1145
.annotate 'line', 485
    .return ($P1145)
.end


.namespace ["NQPNativeHOW"]
.sub "name"  :subid("78_1298845494.89") :outer("70_1298845494.89")
    .param pmc param_1149
    .param pmc param_1150
.annotate 'line', 489
    .lex "self", param_1149
    .lex "$obj", param_1150
    find_lex $P1151, "self"
    get_global $P1152, "$?CLASS"
    getattribute $P1153, $P1151, $P1152, "$!name"
    unless_null $P1153, vivify_298
    new $P1153, "Undef"
  vivify_298:
    .return ($P1153)
.end


.namespace ["NQPAttribute"]
.sub "_block1183"  :subid("80_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 495
    .const 'Sub' $P1243 = "86_1298845494.89" 
    capture_lex $P1243
    .const 'Sub' $P1232 = "85_1298845494.89" 
    capture_lex $P1232
    .const 'Sub' $P1223 = "84_1298845494.89" 
    capture_lex $P1223
    .const 'Sub' $P1218 = "83_1298845494.89" 
    capture_lex $P1218
    .const 'Sub' $P1201 = "82_1298845494.89" 
    capture_lex $P1201
    .const 'Sub' $P1186 = "81_1298845494.89" 
    capture_lex $P1186
    get_global $P1185, "$?CLASS"
.annotate 'line', 520
    .const 'Sub' $P1232 = "85_1298845494.89" 
    newclosure $P1241, $P1232
.annotate 'line', 495
    .return ($P1241)
.end


.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post299") :outer("80_1298845494.89")
.annotate 'line', 495
    get_hll_global $P1184, ["NQPAttribute"], "_block1183" 
    .local pmc block
    set block, $P1184
    .const 'Sub' $P1243 = "86_1298845494.89" 
    capture_lex $P1243
    $P1243()
.end


.namespace ["NQPAttribute"]
.sub "_block1242"  :anon :subid("86_1298845494.89") :outer("80_1298845494.89")
.annotate 'line', 495
    get_hll_global $P1244, "KnowHOW"
    $P1245 = $P1244."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P1245
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1246, type_obj
    get_hll_global $P1247, "KnowHOWAttribute"
    $P1248 = $P1247."new"("$!name" :named("name"))
    $P1246."add_attribute"(type_obj, $P1248)
    get_how $P1249, type_obj
    get_hll_global $P1250, "KnowHOWAttribute"
    $P1251 = $P1250."new"("$!type" :named("name"))
    $P1249."add_attribute"(type_obj, $P1251)
    get_how $P1252, type_obj
    get_hll_global $P1253, "KnowHOWAttribute"
    $P1254 = $P1253."new"("$!box_target" :named("name"))
    $P1252."add_attribute"(type_obj, $P1254)
    get_how $P1255, type_obj
    .const 'Sub' $P1256 = "81_1298845494.89" 
    $P1255."add_method"(type_obj, "new", $P1256)
    get_how $P1257, type_obj
    .const 'Sub' $P1258 = "82_1298845494.89" 
    $P1257."add_method"(type_obj, "BUILD", $P1258)
    get_how $P1259, type_obj
    .const 'Sub' $P1260 = "83_1298845494.89" 
    $P1259."add_method"(type_obj, "name", $P1260)
    get_how $P1261, type_obj
    .const 'Sub' $P1262 = "84_1298845494.89" 
    $P1261."add_method"(type_obj, "type", $P1262)
    get_how $P1263, type_obj
    .const 'Sub' $P1264 = "85_1298845494.89" 
    $P1263."add_method"(type_obj, "box_target", $P1264)
    get_how $P1265, type_obj
    $P1266 = $P1265."compose"(type_obj)
    .return ($P1266)
.end


.namespace ["NQPAttribute"]
.sub "new"  :subid("81_1298845494.89") :outer("80_1298845494.89")
    .param pmc param_1187
    .param pmc param_1188 :named("name")
    .param pmc param_1189 :optional :named("type")
    .param int has_param_1189 :opt_flag
    .param pmc param_1191 :optional :named("box_target")
    .param int has_param_1191 :opt_flag
.annotate 'line', 500
    .lex "self", param_1187
    .lex "$name", param_1188
    if has_param_1189, optparam_300
    new $P1190, "Undef"
    set param_1189, $P1190
  optparam_300:
    .lex "$type", param_1189
    if has_param_1191, optparam_301
    new $P1192, "Undef"
    set param_1191, $P1192
  optparam_301:
    .lex "$box_target", param_1191
.annotate 'line', 501
    new $P1193, "Undef"
    .lex "$attr", $P1193
    find_lex $P1194, "self"
    repr_instance_of $P1195, $P1194
    store_lex "$attr", $P1195
.annotate 'line', 502
    find_lex $P1196, "$attr"
    find_lex $P1197, "$name"
    find_lex $P1198, "$type"
    find_lex $P1199, "$box_target"
    $P1196."BUILD"($P1197 :named("name"), $P1198 :named("type"), $P1199 :named("box_target"))
    find_lex $P1200, "$attr"
.annotate 'line', 500
    .return ($P1200)
.end


.namespace ["NQPAttribute"]
.sub "BUILD"  :subid("82_1298845494.89") :outer("80_1298845494.89")
    .param pmc param_1202
    .param pmc param_1203 :optional :named("name")
    .param int has_param_1203 :opt_flag
    .param pmc param_1205 :optional :named("type")
    .param int has_param_1205 :opt_flag
    .param pmc param_1207 :optional :named("box_target")
    .param int has_param_1207 :opt_flag
.annotate 'line', 506
    .lex "self", param_1202
    if has_param_1203, optparam_302
    new $P1204, "Undef"
    set param_1203, $P1204
  optparam_302:
    .lex "$name", param_1203
    if has_param_1205, optparam_303
    new $P1206, "Undef"
    set param_1205, $P1206
  optparam_303:
    .lex "$type", param_1205
    if has_param_1207, optparam_304
    new $P1208, "Undef"
    set param_1207, $P1208
  optparam_304:
    .lex "$box_target", param_1207
.annotate 'line', 507
    find_lex $P1209, "$name"
    find_lex $P1210, "self"
    get_global $P1211, "$?CLASS"
    setattribute $P1210, $P1211, "$!name", $P1209
.annotate 'line', 508
    find_lex $P1212, "$type"
    find_lex $P1213, "self"
    get_global $P1214, "$?CLASS"
    setattribute $P1213, $P1214, "$!type", $P1212
.annotate 'line', 509
    find_lex $P1215, "$box_target"
    find_lex $P1216, "self"
    get_global $P1217, "$?CLASS"
    setattribute $P1216, $P1217, "$!box_target", $P1215
.annotate 'line', 506
    .return ($P1215)
.end


.namespace ["NQPAttribute"]
.sub "name"  :subid("83_1298845494.89") :outer("80_1298845494.89")
    .param pmc param_1219
.annotate 'line', 512
    .lex "self", param_1219
    find_lex $P1220, "self"
    get_global $P1221, "$?CLASS"
    getattribute $P1222, $P1220, $P1221, "$!name"
    unless_null $P1222, vivify_305
    new $P1222, "Undef"
  vivify_305:
    .return ($P1222)
.end


.namespace ["NQPAttribute"]
.sub "type"  :subid("84_1298845494.89") :outer("80_1298845494.89")
    .param pmc param_1224
.annotate 'line', 516
    .lex "self", param_1224
.annotate 'line', 517
    find_lex $P1226, "self"
    get_global $P1227, "$?CLASS"
    getattribute $P1228, $P1226, $P1227, "$!type"
    unless_null $P1228, vivify_306
    new $P1228, "Undef"
  vivify_306:
    set $P1225, $P1228
    defined $I1230, $P1225
    if $I1230, default_1229
    null $P1231
    set $P1225, $P1231
  default_1229:
.annotate 'line', 516
    .return ($P1225)
.end


.namespace ["NQPAttribute"]
.sub "box_target"  :subid("85_1298845494.89") :outer("80_1298845494.89")
    .param pmc param_1233
.annotate 'line', 520
    .lex "self", param_1233
.annotate 'line', 521
    find_lex $P1236, "self"
    get_global $P1237, "$?CLASS"
    getattribute $P1238, $P1236, $P1237, "$!box_target"
    unless_null $P1238, vivify_307
    new $P1238, "Undef"
  vivify_307:
    if $P1238, if_1235
    new $P1240, "Integer"
    assign $P1240, 0
    set $P1234, $P1240
    goto if_1235_end
  if_1235:
    new $P1239, "Integer"
    assign $P1239, 1
    set $P1234, $P1239
  if_1235_end:
.annotate 'line', 520
    .return ($P1234)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1267"  :subid("87_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 528
    .const 'Sub' $P1523 = "108_1298845494.89" 
    capture_lex $P1523
    .const 'Sub' $P1515 = "107_1298845494.89" 
    capture_lex $P1515
    .const 'Sub' $P1509 = "106_1298845494.89" 
    capture_lex $P1509
    .const 'Sub' $P1487 = "104_1298845494.89" 
    capture_lex $P1487
    .const 'Sub' $P1481 = "103_1298845494.89" 
    capture_lex $P1481
    .const 'Sub' $P1475 = "102_1298845494.89" 
    capture_lex $P1475
    .const 'Sub' $P1469 = "101_1298845494.89" 
    capture_lex $P1469
    .const 'Sub' $P1447 = "99_1298845494.89" 
    capture_lex $P1447
    .const 'Sub' $P1398 = "97_1298845494.89" 
    capture_lex $P1398
    .const 'Sub' $P1385 = "96_1298845494.89" 
    capture_lex $P1385
    .const 'Sub' $P1372 = "95_1298845494.89" 
    capture_lex $P1372
    .const 'Sub' $P1368 = "94_1298845494.89" 
    capture_lex $P1368
    .const 'Sub' $P1347 = "93_1298845494.89" 
    capture_lex $P1347
    .const 'Sub' $P1326 = "92_1298845494.89" 
    capture_lex $P1326
    .const 'Sub' $P1307 = "91_1298845494.89" 
    capture_lex $P1307
    .const 'Sub' $P1291 = "90_1298845494.89" 
    capture_lex $P1291
    .const 'Sub' $P1281 = "89_1298845494.89" 
    capture_lex $P1281
    .const 'Sub' $P1270 = "88_1298845494.89" 
    capture_lex $P1270
    get_global $P1269, "$?CLASS"
.annotate 'line', 667
    .const 'Sub' $P1515 = "107_1298845494.89" 
    newclosure $P1521, $P1515
.annotate 'line', 528
    .return ($P1521)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "" :load :init :subid("post308") :outer("87_1298845494.89")
.annotate 'line', 528
    get_hll_global $P1268, ["NQPConcreteRoleHOW"], "_block1267" 
    .local pmc block
    set block, $P1268
    .const 'Sub' $P1523 = "108_1298845494.89" 
    capture_lex $P1523
    $P1523()
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1522"  :anon :subid("108_1298845494.89") :outer("87_1298845494.89")
.annotate 'line', 528
    get_hll_global $P1524, "KnowHOW"
    $P1525 = $P1524."new_type"("NQPConcreteRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1525
    set_hll_global "NQPConcreteRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1526, type_obj
    get_hll_global $P1527, "KnowHOWAttribute"
    $P1528 = $P1527."new"("$!name" :named("name"))
    $P1526."add_attribute"(type_obj, $P1528)
    get_how $P1529, type_obj
    get_hll_global $P1530, "KnowHOWAttribute"
    $P1531 = $P1530."new"("$!instance_of" :named("name"))
    $P1529."add_attribute"(type_obj, $P1531)
    get_how $P1532, type_obj
    get_hll_global $P1533, "KnowHOWAttribute"
    $P1534 = $P1533."new"("%!attributes" :named("name"))
    $P1532."add_attribute"(type_obj, $P1534)
    get_how $P1535, type_obj
    get_hll_global $P1536, "KnowHOWAttribute"
    $P1537 = $P1536."new"("%!methods" :named("name"))
    $P1535."add_attribute"(type_obj, $P1537)
    get_how $P1538, type_obj
    get_hll_global $P1539, "KnowHOWAttribute"
    $P1540 = $P1539."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1538."add_attribute"(type_obj, $P1540)
    get_how $P1541, type_obj
    get_hll_global $P1542, "KnowHOWAttribute"
    $P1543 = $P1542."new"("@!collisions" :named("name"))
    $P1541."add_attribute"(type_obj, $P1543)
    get_how $P1544, type_obj
    get_hll_global $P1545, "KnowHOWAttribute"
    $P1546 = $P1545."new"("@!roles" :named("name"))
    $P1544."add_attribute"(type_obj, $P1546)
    get_how $P1547, type_obj
    get_hll_global $P1548, "KnowHOWAttribute"
    $P1549 = $P1548."new"("@!done" :named("name"))
    $P1547."add_attribute"(type_obj, $P1549)
    get_how $P1550, type_obj
    get_hll_global $P1551, "KnowHOWAttribute"
    $P1552 = $P1551."new"("$!composed" :named("name"))
    $P1550."add_attribute"(type_obj, $P1552)
    get_how $P1553, type_obj
    .const 'Sub' $P1554 = "88_1298845494.89" 
    $P1553."add_method"(type_obj, "new", $P1554)
    get_how $P1555, type_obj
    .const 'Sub' $P1556 = "89_1298845494.89" 
    $P1555."add_method"(type_obj, "BUILD", $P1556)
    get_how $P1557, type_obj
    .const 'Sub' $P1558 = "90_1298845494.89" 
    $P1557."add_method"(type_obj, "new_type", $P1558)
    get_how $P1559, type_obj
    .const 'Sub' $P1560 = "91_1298845494.89" 
    $P1559."add_method"(type_obj, "add_method", $P1560)
    get_how $P1561, type_obj
    .const 'Sub' $P1562 = "92_1298845494.89" 
    $P1561."add_method"(type_obj, "add_multi_method", $P1562)
    get_how $P1563, type_obj
    .const 'Sub' $P1564 = "93_1298845494.89" 
    $P1563."add_method"(type_obj, "add_attribute", $P1564)
    get_how $P1565, type_obj
    .const 'Sub' $P1566 = "94_1298845494.89" 
    $P1565."add_method"(type_obj, "add_parent", $P1566)
    get_how $P1567, type_obj
    .const 'Sub' $P1568 = "95_1298845494.89" 
    $P1567."add_method"(type_obj, "add_role", $P1568)
    get_how $P1569, type_obj
    .const 'Sub' $P1570 = "96_1298845494.89" 
    $P1569."add_method"(type_obj, "add_collision", $P1570)
    get_how $P1571, type_obj
    .const 'Sub' $P1572 = "97_1298845494.89" 
    $P1571."add_method"(type_obj, "compose", $P1572)
    get_how $P1573, type_obj
    .const 'Sub' $P1574 = "99_1298845494.89" 
    $P1573."add_method"(type_obj, "methods", $P1574)
    get_how $P1575, type_obj
    .const 'Sub' $P1576 = "101_1298845494.89" 
    $P1575."add_method"(type_obj, "method_table", $P1576)
    get_how $P1577, type_obj
    .const 'Sub' $P1578 = "102_1298845494.89" 
    $P1577."add_method"(type_obj, "collisions", $P1578)
    get_how $P1579, type_obj
    .const 'Sub' $P1580 = "103_1298845494.89" 
    $P1579."add_method"(type_obj, "name", $P1580)
    get_how $P1581, type_obj
    .const 'Sub' $P1582 = "104_1298845494.89" 
    $P1581."add_method"(type_obj, "attributes", $P1582)
    get_how $P1583, type_obj
    .const 'Sub' $P1584 = "106_1298845494.89" 
    $P1583."add_method"(type_obj, "roles", $P1584)
    get_how $P1585, type_obj
    .const 'Sub' $P1586 = "107_1298845494.89" 
    $P1585."add_method"(type_obj, "instance_of", $P1586)
    get_how $P1587, type_obj
    $P1588 = $P1587."compose"(type_obj)
    .return ($P1588)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "new"  :subid("88_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1271
    .param pmc param_1272 :named("name")
    .param pmc param_1273 :named("instance_of")
.annotate 'line', 560
    .lex "self", param_1271
    .lex "$name", param_1272
    .lex "$instance_of", param_1273
.annotate 'line', 561
    new $P1274, "Undef"
    .lex "$obj", $P1274
    find_lex $P1275, "self"
    repr_instance_of $P1276, $P1275
    store_lex "$obj", $P1276
.annotate 'line', 562
    find_lex $P1277, "$obj"
    find_lex $P1278, "$name"
    find_lex $P1279, "$instance_of"
    $P1277."BUILD"($P1278 :named("name"), $P1279 :named("instance_of"))
    find_lex $P1280, "$obj"
.annotate 'line', 560
    .return ($P1280)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "BUILD"  :subid("89_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1282
    .param pmc param_1283 :named("name")
    .param pmc param_1284 :named("instance_of")
.annotate 'line', 566
    .lex "self", param_1282
    .lex "$name", param_1283
    .lex "$instance_of", param_1284
.annotate 'line', 567
    find_lex $P1285, "$name"
    find_lex $P1286, "self"
    get_global $P1287, "$?CLASS"
    setattribute $P1286, $P1287, "$!name", $P1285
.annotate 'line', 568
    find_lex $P1288, "$instance_of"
    find_lex $P1289, "self"
    get_global $P1290, "$?CLASS"
    setattribute $P1289, $P1290, "$!instance_of", $P1288
.annotate 'line', 566
    .return ($P1288)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "new_type"  :subid("90_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1292
    .param pmc param_1297 :named("instance_of")
    .param pmc param_1293 :optional :named("name")
    .param int has_param_1293 :opt_flag
    .param pmc param_1295 :optional :named("repr")
    .param int has_param_1295 :opt_flag
.annotate 'line', 573
    .lex "self", param_1292
    if has_param_1293, optparam_309
    new $P1294, "String"
    assign $P1294, "<anon>"
    set param_1293, $P1294
  optparam_309:
    .lex "$name", param_1293
    if has_param_1295, optparam_310
    new $P1296, "String"
    assign $P1296, "P6opaque"
    set param_1295, $P1296
  optparam_310:
    .lex "$repr", param_1295
    .lex "$instance_of", param_1297
.annotate 'line', 574
    new $P1298, "Undef"
    .lex "$metarole", $P1298
    find_lex $P1299, "self"
    find_lex $P1300, "$name"
    find_lex $P1301, "$instance_of"
    $P1302 = $P1299."new"($P1300 :named("name"), $P1301 :named("instance_of"))
    store_lex "$metarole", $P1302
.annotate 'line', 575
    find_lex $P1303, "$metarole"
    find_lex $P1304, "$repr"
    set $S1305, $P1304
    repr_type_object_for $P1306, $P1303, $S1305
.annotate 'line', 573
    .return ($P1306)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_method"  :subid("91_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1308
    .param pmc param_1309
    .param pmc param_1310
    .param pmc param_1311
.annotate 'line', 578
    .lex "self", param_1308
    .lex "$obj", param_1309
    .lex "$name", param_1310
    .lex "$code_obj", param_1311
.annotate 'line', 579
    find_lex $P1313, "$name"
    find_lex $P1314, "self"
    get_global $P1315, "$?CLASS"
    getattribute $P1316, $P1314, $P1315, "%!methods"
    unless_null $P1316, vivify_311
    $P1316 = root_new ['parrot';'Hash']
  vivify_311:
    set $P1317, $P1316[$P1313]
    unless_null $P1317, vivify_312
    new $P1317, "Undef"
  vivify_312:
    unless $P1317, if_1312_end
.annotate 'line', 580
    new $P1318, "String"
    assign $P1318, "This role already has a method named "
    find_lex $P1319, "$name"
    concat $P1320, $P1318, $P1319
    die $P1320
  if_1312_end:
.annotate 'line', 582
    find_lex $P1321, "$code_obj"
    find_lex $P1322, "$name"
    find_lex $P1323, "self"
    get_global $P1324, "$?CLASS"
    getattribute $P1325, $P1323, $P1324, "%!methods"
    unless_null $P1325, vivify_313
    $P1325 = root_new ['parrot';'Hash']
    setattribute $P1323, $P1324, "%!methods", $P1325
  vivify_313:
    set $P1325[$P1322], $P1321
.annotate 'line', 578
    .return ($P1321)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_multi_method"  :subid("92_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1327
    .param pmc param_1328
    .param pmc param_1329
    .param pmc param_1330
.annotate 'line', 585
    .lex "self", param_1327
    .lex "$obj", param_1328
    .lex "$name", param_1329
    .lex "$code_obj", param_1330
.annotate 'line', 586
    $P1331 = root_new ['parrot';'Hash']
    .lex "%todo", $P1331
.annotate 'line', 585
    find_lex $P1332, "%todo"
.annotate 'line', 587
    find_lex $P1333, "$name"
    find_lex $P1334, "%todo"
    unless_null $P1334, vivify_314
    $P1334 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1334
  vivify_314:
    set $P1334["name"], $P1333
.annotate 'line', 588
    find_lex $P1335, "$code_obj"
    find_lex $P1336, "%todo"
    unless_null $P1336, vivify_315
    $P1336 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1336
  vivify_315:
    set $P1336["code"], $P1335
.annotate 'line', 589
    find_lex $P1337, "%todo"
    find_lex $P1338, "self"
    get_global $P1339, "$?CLASS"
    getattribute $P1340, $P1338, $P1339, "@!multi_methods_to_incorporate"
    unless_null $P1340, vivify_316
    $P1340 = root_new ['parrot';'ResizablePMCArray']
  vivify_316:
    set $N1341, $P1340
    set $I1342, $N1341
    find_lex $P1343, "self"
    get_global $P1344, "$?CLASS"
    getattribute $P1345, $P1343, $P1344, "@!multi_methods_to_incorporate"
    unless_null $P1345, vivify_317
    $P1345 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1343, $P1344, "@!multi_methods_to_incorporate", $P1345
  vivify_317:
    set $P1345[$I1342], $P1337
    find_lex $P1346, "$code_obj"
.annotate 'line', 585
    .return ($P1346)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_attribute"  :subid("93_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1348
    .param pmc param_1349
    .param pmc param_1350
.annotate 'line', 593
    .lex "self", param_1348
    .lex "$obj", param_1349
    .lex "$meta_attr", param_1350
.annotate 'line', 594
    new $P1351, "Undef"
    .lex "$name", $P1351
    find_lex $P1352, "$meta_attr"
    $P1353 = $P1352."name"()
    store_lex "$name", $P1353
.annotate 'line', 595
    find_lex $P1355, "$name"
    find_lex $P1356, "self"
    get_global $P1357, "$?CLASS"
    getattribute $P1358, $P1356, $P1357, "%!attributes"
    unless_null $P1358, vivify_318
    $P1358 = root_new ['parrot';'Hash']
  vivify_318:
    set $P1359, $P1358[$P1355]
    unless_null $P1359, vivify_319
    new $P1359, "Undef"
  vivify_319:
    unless $P1359, if_1354_end
.annotate 'line', 596
    new $P1360, "String"
    assign $P1360, "This role already has an attribute named "
    find_lex $P1361, "$name"
    concat $P1362, $P1360, $P1361
    die $P1362
  if_1354_end:
.annotate 'line', 598
    find_lex $P1363, "$meta_attr"
    find_lex $P1364, "$name"
    find_lex $P1365, "self"
    get_global $P1366, "$?CLASS"
    getattribute $P1367, $P1365, $P1366, "%!attributes"
    unless_null $P1367, vivify_320
    $P1367 = root_new ['parrot';'Hash']
    setattribute $P1365, $P1366, "%!attributes", $P1367
  vivify_320:
    set $P1367[$P1364], $P1363
.annotate 'line', 593
    .return ($P1363)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_parent"  :subid("94_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1369
    .param pmc param_1370
    .param pmc param_1371
.annotate 'line', 601
    .lex "self", param_1369
    .lex "$obj", param_1370
    .lex "$parent", param_1371
.annotate 'line', 602
    die "A role cannot inherit from a class in NQP"
.annotate 'line', 601
    .return ()
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_role"  :subid("95_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1373
    .param pmc param_1374
    .param pmc param_1375
.annotate 'line', 605
    .lex "self", param_1373
    .lex "$obj", param_1374
    .lex "$role", param_1375
.annotate 'line', 606
    find_lex $P1376, "$role"
    find_lex $P1377, "self"
    get_global $P1378, "$?CLASS"
    getattribute $P1379, $P1377, $P1378, "@!roles"
    unless_null $P1379, vivify_321
    $P1379 = root_new ['parrot';'ResizablePMCArray']
  vivify_321:
    set $N1380, $P1379
    set $I1381, $N1380
    find_lex $P1382, "self"
    get_global $P1383, "$?CLASS"
    getattribute $P1384, $P1382, $P1383, "@!roles"
    unless_null $P1384, vivify_322
    $P1384 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1382, $P1383, "@!roles", $P1384
  vivify_322:
    set $P1384[$I1381], $P1376
.annotate 'line', 605
    .return ($P1376)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_collision"  :subid("96_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1386
    .param pmc param_1387
    .param pmc param_1388
.annotate 'line', 609
    .lex "self", param_1386
    .lex "$obj", param_1387
    .lex "$colliding_name", param_1388
.annotate 'line', 610
    find_lex $P1389, "$colliding_name"
    find_lex $P1390, "self"
    get_global $P1391, "$?CLASS"
    getattribute $P1392, $P1390, $P1391, "@!collisions"
    unless_null $P1392, vivify_323
    $P1392 = root_new ['parrot';'ResizablePMCArray']
  vivify_323:
    set $N1393, $P1392
    set $I1394, $N1393
    find_lex $P1395, "self"
    get_global $P1396, "$?CLASS"
    getattribute $P1397, $P1395, $P1396, "@!collisions"
    unless_null $P1397, vivify_324
    $P1397 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1395, $P1396, "@!collisions", $P1397
  vivify_324:
    set $P1397[$I1394], $P1389
.annotate 'line', 609
    .return ($P1389)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("97_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1399
    .param pmc param_1400
.annotate 'line', 614
    .const 'Sub' $P1412 = "98_1298845494.89" 
    capture_lex $P1412
    .lex "self", param_1399
    .lex "$obj", param_1400
.annotate 'line', 617
    find_lex $P1402, "self"
    get_global $P1403, "$?CLASS"
    getattribute $P1404, $P1402, $P1403, "@!roles"
    unless_null $P1404, vivify_325
    $P1404 = root_new ['parrot';'ResizablePMCArray']
  vivify_325:
    unless $P1404, if_1401_end
.annotate 'line', 618
    find_lex $P1406, "self"
    get_global $P1407, "$?CLASS"
    getattribute $P1408, $P1406, $P1407, "@!roles"
    unless_null $P1408, vivify_326
    $P1408 = root_new ['parrot';'ResizablePMCArray']
  vivify_326:
    defined $I1409, $P1408
    unless $I1409, for_undef_327
    iter $P1405, $P1408
    new $P1436, 'ExceptionHandler'
    set_label $P1436, loop1435_handler
    $P1436."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1436
  loop1435_test:
    unless $P1405, loop1435_done
    shift $P1410, $P1405
  loop1435_redo:
    .const 'Sub' $P1412 = "98_1298845494.89" 
    capture_lex $P1412
    $P1412($P1410)
  loop1435_next:
    goto loop1435_test
  loop1435_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1437, exception, 'type'
    eq $P1437, .CONTROL_LOOP_NEXT, loop1435_next
    eq $P1437, .CONTROL_LOOP_REDO, loop1435_redo
  loop1435_done:
    pop_eh 
  for_undef_327:
.annotate 'line', 622
    get_hll_global $P1438, "RoleToRoleApplier"
    find_lex $P1439, "$obj"
    find_lex $P1440, "self"
    get_global $P1441, "$?CLASS"
    getattribute $P1442, $P1440, $P1441, "@!roles"
    unless_null $P1442, vivify_332
    $P1442 = root_new ['parrot';'ResizablePMCArray']
  vivify_332:
    $P1438."apply"($P1439, $P1442)
  if_1401_end:
.annotate 'line', 626
    new $P1443, "Integer"
    assign $P1443, 1
    find_lex $P1444, "self"
    get_global $P1445, "$?CLASS"
    setattribute $P1444, $P1445, "$!composed", $P1443
    find_lex $P1446, "$obj"
.annotate 'line', 614
    .return ($P1446)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1411"  :anon :subid("98_1298845494.89") :outer("97_1298845494.89")
    .param pmc param_1413
.annotate 'line', 618
    .lex "$_", param_1413
.annotate 'line', 619
    find_lex $P1414, "$_"
    find_lex $P1415, "self"
    get_global $P1416, "$?CLASS"
    getattribute $P1417, $P1415, $P1416, "@!done"
    unless_null $P1417, vivify_328
    $P1417 = root_new ['parrot';'ResizablePMCArray']
  vivify_328:
    set $N1418, $P1417
    set $I1419, $N1418
    find_lex $P1420, "self"
    get_global $P1421, "$?CLASS"
    getattribute $P1422, $P1420, $P1421, "@!done"
    unless_null $P1422, vivify_329
    $P1422 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1420, $P1421, "@!done", $P1422
  vivify_329:
    set $P1422[$I1419], $P1414
.annotate 'line', 620
    find_lex $P1423, "$_"
    get_how $P1424, $P1423
    find_lex $P1425, "$_"
    $P1426 = $P1424."instance_of"($P1425)
    find_lex $P1427, "self"
    get_global $P1428, "$?CLASS"
    getattribute $P1429, $P1427, $P1428, "@!done"
    unless_null $P1429, vivify_330
    $P1429 = root_new ['parrot';'ResizablePMCArray']
  vivify_330:
    set $N1430, $P1429
    set $I1431, $N1430
    find_lex $P1432, "self"
    get_global $P1433, "$?CLASS"
    getattribute $P1434, $P1432, $P1433, "@!done"
    unless_null $P1434, vivify_331
    $P1434 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1432, $P1433, "@!done", $P1434
  vivify_331:
    set $P1434[$I1431], $P1426
.annotate 'line', 618
    .return ($P1426)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("99_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1448
    .param pmc param_1449
.annotate 'line', 635
    .const 'Sub' $P1459 = "100_1298845494.89" 
    capture_lex $P1459
    .lex "self", param_1448
    .lex "$obj", param_1449
.annotate 'line', 636
    $P1450 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1450
.annotate 'line', 635
    find_lex $P1451, "@meths"
.annotate 'line', 637
    find_lex $P1453, "self"
    get_global $P1454, "$?CLASS"
    getattribute $P1455, $P1453, $P1454, "%!methods"
    unless_null $P1455, vivify_333
    $P1455 = root_new ['parrot';'Hash']
  vivify_333:
    defined $I1456, $P1455
    unless $I1456, for_undef_334
    iter $P1452, $P1455
    new $P1466, 'ExceptionHandler'
    set_label $P1466, loop1465_handler
    $P1466."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1466
  loop1465_test:
    unless $P1452, loop1465_done
    shift $P1457, $P1452
  loop1465_redo:
    .const 'Sub' $P1459 = "100_1298845494.89" 
    capture_lex $P1459
    $P1459($P1457)
  loop1465_next:
    goto loop1465_test
  loop1465_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1467, exception, 'type'
    eq $P1467, .CONTROL_LOOP_NEXT, loop1465_next
    eq $P1467, .CONTROL_LOOP_REDO, loop1465_redo
  loop1465_done:
    pop_eh 
  for_undef_334:
    find_lex $P1468, "@meths"
.annotate 'line', 635
    .return ($P1468)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1458"  :anon :subid("100_1298845494.89") :outer("99_1298845494.89")
    .param pmc param_1460
.annotate 'line', 637
    .lex "$_", param_1460
.annotate 'line', 638
    find_lex $P1461, "@meths"
    find_lex $P1462, "$_"
    $P1463 = $P1462."value"()
    $P1464 = $P1461."push"($P1463)
.annotate 'line', 637
    .return ($P1464)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "method_table"  :subid("101_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1470
    .param pmc param_1471
.annotate 'line', 643
    .lex "self", param_1470
    .lex "$obj", param_1471
    find_lex $P1472, "self"
    get_global $P1473, "$?CLASS"
    getattribute $P1474, $P1472, $P1473, "%!methods"
    unless_null $P1474, vivify_335
    $P1474 = root_new ['parrot';'Hash']
  vivify_335:
    .return ($P1474)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "collisions"  :subid("102_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1476
    .param pmc param_1477
.annotate 'line', 647
    .lex "self", param_1476
    .lex "$obj", param_1477
    find_lex $P1478, "self"
    get_global $P1479, "$?CLASS"
    getattribute $P1480, $P1478, $P1479, "@!collisions"
    unless_null $P1480, vivify_336
    $P1480 = root_new ['parrot';'ResizablePMCArray']
  vivify_336:
    .return ($P1480)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "name"  :subid("103_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1482
    .param pmc param_1483
.annotate 'line', 651
    .lex "self", param_1482
    .lex "$obj", param_1483
    find_lex $P1484, "self"
    get_global $P1485, "$?CLASS"
    getattribute $P1486, $P1484, $P1485, "$!name"
    unless_null $P1486, vivify_337
    new $P1486, "Undef"
  vivify_337:
    .return ($P1486)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("104_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1488
    .param pmc param_1489
.annotate 'line', 655
    .const 'Sub' $P1499 = "105_1298845494.89" 
    capture_lex $P1499
    .lex "self", param_1488
    .lex "$obj", param_1489
.annotate 'line', 656
    $P1490 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1490
.annotate 'line', 655
    find_lex $P1491, "@attrs"
.annotate 'line', 657
    find_lex $P1493, "self"
    get_global $P1494, "$?CLASS"
    getattribute $P1495, $P1493, $P1494, "%!attributes"
    unless_null $P1495, vivify_338
    $P1495 = root_new ['parrot';'Hash']
  vivify_338:
    defined $I1496, $P1495
    unless $I1496, for_undef_339
    iter $P1492, $P1495
    new $P1506, 'ExceptionHandler'
    set_label $P1506, loop1505_handler
    $P1506."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1506
  loop1505_test:
    unless $P1492, loop1505_done
    shift $P1497, $P1492
  loop1505_redo:
    .const 'Sub' $P1499 = "105_1298845494.89" 
    capture_lex $P1499
    $P1499($P1497)
  loop1505_next:
    goto loop1505_test
  loop1505_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1507, exception, 'type'
    eq $P1507, .CONTROL_LOOP_NEXT, loop1505_next
    eq $P1507, .CONTROL_LOOP_REDO, loop1505_redo
  loop1505_done:
    pop_eh 
  for_undef_339:
    find_lex $P1508, "@attrs"
.annotate 'line', 655
    .return ($P1508)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1498"  :anon :subid("105_1298845494.89") :outer("104_1298845494.89")
    .param pmc param_1500
.annotate 'line', 657
    .lex "$_", param_1500
.annotate 'line', 658
    find_lex $P1501, "@attrs"
    find_lex $P1502, "$_"
    $P1503 = $P1502."value"()
    $P1504 = $P1501."push"($P1503)
.annotate 'line', 657
    .return ($P1504)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "roles"  :subid("106_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1510
    .param pmc param_1511
.annotate 'line', 663
    .lex "self", param_1510
    .lex "$obj", param_1511
    find_lex $P1512, "self"
    get_global $P1513, "$?CLASS"
    getattribute $P1514, $P1512, $P1513, "@!roles"
    unless_null $P1514, vivify_340
    $P1514 = root_new ['parrot';'ResizablePMCArray']
  vivify_340:
    .return ($P1514)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "instance_of"  :subid("107_1298845494.89") :outer("87_1298845494.89")
    .param pmc param_1516
    .param pmc param_1517
.annotate 'line', 667
    .lex "self", param_1516
    .lex "$obj", param_1517
    find_lex $P1518, "self"
    get_global $P1519, "$?CLASS"
    getattribute $P1520, $P1518, $P1519, "$!instance_of"
    unless_null $P1520, vivify_341
    new $P1520, "Undef"
  vivify_341:
    .return ($P1520)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1589"  :subid("109_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 677
    .const 'Sub' $P1887 = "132_1298845494.89" 
    capture_lex $P1887
    .const 'Sub' $P1879 = "131_1298845494.89" 
    capture_lex $P1879
    .const 'Sub' $P1857 = "129_1298845494.89" 
    capture_lex $P1857
    .const 'Sub' $P1851 = "128_1298845494.89" 
    capture_lex $P1851
    .const 'Sub' $P1845 = "127_1298845494.89" 
    capture_lex $P1845
    .const 'Sub' $P1823 = "125_1298845494.89" 
    capture_lex $P1823
    .const 'Sub' $P1717 = "120_1298845494.89" 
    capture_lex $P1717
    .const 'Sub' $P1714 = "119_1298845494.89" 
    capture_lex $P1714
    .const 'Sub' $P1707 = "118_1298845494.89" 
    capture_lex $P1707
    .const 'Sub' $P1694 = "117_1298845494.89" 
    capture_lex $P1694
    .const 'Sub' $P1690 = "116_1298845494.89" 
    capture_lex $P1690
    .const 'Sub' $P1669 = "115_1298845494.89" 
    capture_lex $P1669
    .const 'Sub' $P1648 = "114_1298845494.89" 
    capture_lex $P1648
    .const 'Sub' $P1629 = "113_1298845494.89" 
    capture_lex $P1629
    .const 'Sub' $P1613 = "112_1298845494.89" 
    capture_lex $P1613
    .const 'Sub' $P1603 = "111_1298845494.89" 
    capture_lex $P1603
    .const 'Sub' $P1592 = "110_1298845494.89" 
    capture_lex $P1592
    get_global $P1591, "$?CLASS"
.annotate 'line', 837
    .const 'Sub' $P1879 = "131_1298845494.89" 
    newclosure $P1885, $P1879
.annotate 'line', 677
    .return ($P1885)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "" :load :init :subid("post342") :outer("109_1298845494.89")
.annotate 'line', 677
    get_hll_global $P1590, ["NQPParametricRoleHOW"], "_block1589" 
    .local pmc block
    set block, $P1590
    .const 'Sub' $P1887 = "132_1298845494.89" 
    capture_lex $P1887
    $P1887()
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1886"  :anon :subid("132_1298845494.89") :outer("109_1298845494.89")
.annotate 'line', 677
    get_hll_global $P1888, "KnowHOW"
    $P1889 = $P1888."new_type"("NQPParametricRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1889
    set_hll_global "NQPParametricRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1890, type_obj
    get_hll_global $P1891, "KnowHOWAttribute"
    $P1892 = $P1891."new"("$!name" :named("name"))
    $P1890."add_attribute"(type_obj, $P1892)
    get_how $P1893, type_obj
    get_hll_global $P1894, "KnowHOWAttribute"
    $P1895 = $P1894."new"("%!attributes" :named("name"))
    $P1893."add_attribute"(type_obj, $P1895)
    get_how $P1896, type_obj
    get_hll_global $P1897, "KnowHOWAttribute"
    $P1898 = $P1897."new"("%!methods" :named("name"))
    $P1896."add_attribute"(type_obj, $P1898)
    get_how $P1899, type_obj
    get_hll_global $P1900, "KnowHOWAttribute"
    $P1901 = $P1900."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1899."add_attribute"(type_obj, $P1901)
    get_how $P1902, type_obj
    get_hll_global $P1903, "KnowHOWAttribute"
    $P1904 = $P1903."new"("@!roles" :named("name"))
    $P1902."add_attribute"(type_obj, $P1904)
    get_how $P1905, type_obj
    get_hll_global $P1906, "KnowHOWAttribute"
    $P1907 = $P1906."new"("$!composed" :named("name"))
    $P1905."add_attribute"(type_obj, $P1907)
    get_how $P1908, type_obj
    get_hll_global $P1909, "KnowHOWAttribute"
    $P1910 = $P1909."new"("$!body_block" :named("name"))
    $P1908."add_attribute"(type_obj, $P1910)
    get_how $P1911, type_obj
    .const 'Sub' $P1912 = "110_1298845494.89" 
    $P1911."add_method"(type_obj, "new", $P1912)
    get_how $P1913, type_obj
    .const 'Sub' $P1914 = "111_1298845494.89" 
    $P1913."add_method"(type_obj, "BUILD", $P1914)
    get_how $P1915, type_obj
    .const 'Sub' $P1916 = "112_1298845494.89" 
    $P1915."add_method"(type_obj, "new_type", $P1916)
    get_how $P1917, type_obj
    .const 'Sub' $P1918 = "113_1298845494.89" 
    $P1917."add_method"(type_obj, "add_method", $P1918)
    get_how $P1919, type_obj
    .const 'Sub' $P1920 = "114_1298845494.89" 
    $P1919."add_method"(type_obj, "add_multi_method", $P1920)
    get_how $P1921, type_obj
    .const 'Sub' $P1922 = "115_1298845494.89" 
    $P1921."add_method"(type_obj, "add_attribute", $P1922)
    get_how $P1923, type_obj
    .const 'Sub' $P1924 = "116_1298845494.89" 
    $P1923."add_method"(type_obj, "add_parent", $P1924)
    get_how $P1925, type_obj
    .const 'Sub' $P1926 = "117_1298845494.89" 
    $P1925."add_method"(type_obj, "add_role", $P1926)
    get_how $P1927, type_obj
    .const 'Sub' $P1928 = "118_1298845494.89" 
    $P1927."add_method"(type_obj, "compose", $P1928)
    get_how $P1929, type_obj
    .const 'Sub' $P1930 = "119_1298845494.89" 
    $P1929."add_method"(type_obj, "parametric", $P1930)
    get_how $P1931, type_obj
    .const 'Sub' $P1932 = "120_1298845494.89" 
    $P1931."add_method"(type_obj, "instantiate", $P1932)
    get_how $P1933, type_obj
    .const 'Sub' $P1934 = "125_1298845494.89" 
    $P1933."add_method"(type_obj, "methods", $P1934)
    get_how $P1935, type_obj
    .const 'Sub' $P1936 = "127_1298845494.89" 
    $P1935."add_method"(type_obj, "method_table", $P1936)
    get_how $P1937, type_obj
    .const 'Sub' $P1938 = "128_1298845494.89" 
    $P1937."add_method"(type_obj, "name", $P1938)
    get_how $P1939, type_obj
    .const 'Sub' $P1940 = "129_1298845494.89" 
    $P1939."add_method"(type_obj, "attributes", $P1940)
    get_how $P1941, type_obj
    .const 'Sub' $P1942 = "131_1298845494.89" 
    $P1941."add_method"(type_obj, "roles", $P1942)
    get_how $P1943, type_obj
    $P1944 = $P1943."compose"(type_obj)
    .return ($P1944)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "new"  :subid("110_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1593
    .param pmc param_1594 :named("name")
    .param pmc param_1595 :named("body_block")
.annotate 'line', 707
    .lex "self", param_1593
    .lex "$name", param_1594
    .lex "$body_block", param_1595
.annotate 'line', 708
    new $P1596, "Undef"
    .lex "$obj", $P1596
    find_lex $P1597, "self"
    repr_instance_of $P1598, $P1597
    store_lex "$obj", $P1598
.annotate 'line', 709
    find_lex $P1599, "$obj"
    find_lex $P1600, "$name"
    find_lex $P1601, "$body_block"
    $P1599."BUILD"($P1600 :named("name"), $P1601 :named("body_block"))
    find_lex $P1602, "$obj"
.annotate 'line', 707
    .return ($P1602)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "BUILD"  :subid("111_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1604
    .param pmc param_1605 :named("name")
    .param pmc param_1606 :named("body_block")
.annotate 'line', 713
    .lex "self", param_1604
    .lex "$name", param_1605
    .lex "$body_block", param_1606
.annotate 'line', 714
    find_lex $P1607, "$name"
    find_lex $P1608, "self"
    get_global $P1609, "$?CLASS"
    setattribute $P1608, $P1609, "$!name", $P1607
.annotate 'line', 715
    find_lex $P1610, "$body_block"
    find_lex $P1611, "self"
    get_global $P1612, "$?CLASS"
    setattribute $P1611, $P1612, "$!body_block", $P1610
.annotate 'line', 713
    .return ($P1610)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "new_type"  :subid("112_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1614
    .param pmc param_1615 :named("body_block")
    .param pmc param_1616 :optional :named("name")
    .param int has_param_1616 :opt_flag
    .param pmc param_1618 :optional :named("repr")
    .param int has_param_1618 :opt_flag
.annotate 'line', 720
    .lex "self", param_1614
    .lex "$body_block", param_1615
    if has_param_1616, optparam_343
    new $P1617, "String"
    assign $P1617, "<anon>"
    set param_1616, $P1617
  optparam_343:
    .lex "$name", param_1616
    if has_param_1618, optparam_344
    new $P1619, "String"
    assign $P1619, "P6opaque"
    set param_1618, $P1619
  optparam_344:
    .lex "$repr", param_1618
.annotate 'line', 721
    new $P1620, "Undef"
    .lex "$metarole", $P1620
    find_lex $P1621, "self"
    find_lex $P1622, "$name"
    find_lex $P1623, "$body_block"
    $P1624 = $P1621."new"($P1622 :named("name"), $P1623 :named("body_block"))
    store_lex "$metarole", $P1624
.annotate 'line', 722
    find_lex $P1625, "$metarole"
    find_lex $P1626, "$repr"
    set $S1627, $P1626
    repr_type_object_for $P1628, $P1625, $S1627
.annotate 'line', 720
    .return ($P1628)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_method"  :subid("113_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1630
    .param pmc param_1631
    .param pmc param_1632
    .param pmc param_1633
.annotate 'line', 725
    .lex "self", param_1630
    .lex "$obj", param_1631
    .lex "$name", param_1632
    .lex "$code_obj", param_1633
.annotate 'line', 726
    find_lex $P1635, "$name"
    find_lex $P1636, "self"
    get_global $P1637, "$?CLASS"
    getattribute $P1638, $P1636, $P1637, "%!methods"
    unless_null $P1638, vivify_345
    $P1638 = root_new ['parrot';'Hash']
  vivify_345:
    set $P1639, $P1638[$P1635]
    unless_null $P1639, vivify_346
    new $P1639, "Undef"
  vivify_346:
    unless $P1639, if_1634_end
.annotate 'line', 727
    new $P1640, "String"
    assign $P1640, "This role already has a method named "
    find_lex $P1641, "$name"
    concat $P1642, $P1640, $P1641
    die $P1642
  if_1634_end:
.annotate 'line', 729
    find_lex $P1643, "$code_obj"
    find_lex $P1644, "$name"
    find_lex $P1645, "self"
    get_global $P1646, "$?CLASS"
    getattribute $P1647, $P1645, $P1646, "%!methods"
    unless_null $P1647, vivify_347
    $P1647 = root_new ['parrot';'Hash']
    setattribute $P1645, $P1646, "%!methods", $P1647
  vivify_347:
    set $P1647[$P1644], $P1643
.annotate 'line', 725
    .return ($P1643)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_multi_method"  :subid("114_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1649
    .param pmc param_1650
    .param pmc param_1651
    .param pmc param_1652
.annotate 'line', 732
    .lex "self", param_1649
    .lex "$obj", param_1650
    .lex "$name", param_1651
    .lex "$code_obj", param_1652
.annotate 'line', 733
    $P1653 = root_new ['parrot';'Hash']
    .lex "%todo", $P1653
.annotate 'line', 732
    find_lex $P1654, "%todo"
.annotate 'line', 734
    find_lex $P1655, "$name"
    find_lex $P1656, "%todo"
    unless_null $P1656, vivify_348
    $P1656 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1656
  vivify_348:
    set $P1656["name"], $P1655
.annotate 'line', 735
    find_lex $P1657, "$code_obj"
    find_lex $P1658, "%todo"
    unless_null $P1658, vivify_349
    $P1658 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1658
  vivify_349:
    set $P1658["code"], $P1657
.annotate 'line', 736
    find_lex $P1659, "%todo"
    find_lex $P1660, "self"
    get_global $P1661, "$?CLASS"
    getattribute $P1662, $P1660, $P1661, "@!multi_methods_to_incorporate"
    unless_null $P1662, vivify_350
    $P1662 = root_new ['parrot';'ResizablePMCArray']
  vivify_350:
    set $N1663, $P1662
    set $I1664, $N1663
    find_lex $P1665, "self"
    get_global $P1666, "$?CLASS"
    getattribute $P1667, $P1665, $P1666, "@!multi_methods_to_incorporate"
    unless_null $P1667, vivify_351
    $P1667 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1665, $P1666, "@!multi_methods_to_incorporate", $P1667
  vivify_351:
    set $P1667[$I1664], $P1659
    find_lex $P1668, "$code_obj"
.annotate 'line', 732
    .return ($P1668)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_attribute"  :subid("115_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1670
    .param pmc param_1671
    .param pmc param_1672
.annotate 'line', 740
    .lex "self", param_1670
    .lex "$obj", param_1671
    .lex "$meta_attr", param_1672
.annotate 'line', 741
    new $P1673, "Undef"
    .lex "$name", $P1673
    find_lex $P1674, "$meta_attr"
    $P1675 = $P1674."name"()
    store_lex "$name", $P1675
.annotate 'line', 742
    find_lex $P1677, "$name"
    find_lex $P1678, "self"
    get_global $P1679, "$?CLASS"
    getattribute $P1680, $P1678, $P1679, "%!attributes"
    unless_null $P1680, vivify_352
    $P1680 = root_new ['parrot';'Hash']
  vivify_352:
    set $P1681, $P1680[$P1677]
    unless_null $P1681, vivify_353
    new $P1681, "Undef"
  vivify_353:
    unless $P1681, if_1676_end
.annotate 'line', 743
    new $P1682, "String"
    assign $P1682, "This role already has an attribute named "
    find_lex $P1683, "$name"
    concat $P1684, $P1682, $P1683
    die $P1684
  if_1676_end:
.annotate 'line', 745
    find_lex $P1685, "$meta_attr"
    find_lex $P1686, "$name"
    find_lex $P1687, "self"
    get_global $P1688, "$?CLASS"
    getattribute $P1689, $P1687, $P1688, "%!attributes"
    unless_null $P1689, vivify_354
    $P1689 = root_new ['parrot';'Hash']
    setattribute $P1687, $P1688, "%!attributes", $P1689
  vivify_354:
    set $P1689[$P1686], $P1685
.annotate 'line', 740
    .return ($P1685)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_parent"  :subid("116_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1691
    .param pmc param_1692
    .param pmc param_1693
.annotate 'line', 748
    .lex "self", param_1691
    .lex "$obj", param_1692
    .lex "$parent", param_1693
.annotate 'line', 749
    die "A role cannot inherit from a class"
.annotate 'line', 748
    .return ()
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_role"  :subid("117_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1695
    .param pmc param_1696
    .param pmc param_1697
.annotate 'line', 752
    .lex "self", param_1695
    .lex "$obj", param_1696
    .lex "$role", param_1697
.annotate 'line', 753
    find_lex $P1698, "$role"
    find_lex $P1699, "self"
    get_global $P1700, "$?CLASS"
    getattribute $P1701, $P1699, $P1700, "@!roles"
    unless_null $P1701, vivify_355
    $P1701 = root_new ['parrot';'ResizablePMCArray']
  vivify_355:
    set $N1702, $P1701
    set $I1703, $N1702
    find_lex $P1704, "self"
    get_global $P1705, "$?CLASS"
    getattribute $P1706, $P1704, $P1705, "@!roles"
    unless_null $P1706, vivify_356
    $P1706 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1704, $P1705, "@!roles", $P1706
  vivify_356:
    set $P1706[$I1703], $P1698
.annotate 'line', 752
    .return ($P1698)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "compose"  :subid("118_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1708
    .param pmc param_1709
.annotate 'line', 757
    .lex "self", param_1708
    .lex "$obj", param_1709
.annotate 'line', 758
    new $P1710, "Integer"
    assign $P1710, 1
    find_lex $P1711, "self"
    get_global $P1712, "$?CLASS"
    setattribute $P1711, $P1712, "$!composed", $P1710
    find_lex $P1713, "$obj"
.annotate 'line', 757
    .return ($P1713)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "parametric"  :subid("119_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1715
    .param pmc param_1716
.annotate 'line', 768
    .lex "self", param_1715
    .lex "$obj", param_1716
    .return (1)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "instantiate"  :subid("120_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1720
    .param pmc param_1721
    .param pmc param_1722
.annotate 'line', 774
    .const 'Sub' $P1801 = "124_1298845494.89" 
    capture_lex $P1801
    .const 'Sub' $P1780 = "123_1298845494.89" 
    capture_lex $P1780
    .const 'Sub' $P1759 = "122_1298845494.89" 
    capture_lex $P1759
    .const 'Sub' $P1741 = "121_1298845494.89" 
    capture_lex $P1741
    new $P1719, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1719, control_1718
    push_eh $P1719
    .lex "self", param_1720
    .lex "$obj", param_1721
    .lex "$class_arg", param_1722
.annotate 'line', 780
    new $P1723, "Undef"
    .lex "$irole", $P1723
.annotate 'line', 777
    find_lex $P1724, "self"
    get_global $P1725, "$?CLASS"
    getattribute $P1726, $P1724, $P1725, "$!body_block"
    unless_null $P1726, vivify_357
    new $P1726, "Undef"
  vivify_357:
    find_lex $P1727, "$class_arg"
    $P1726($P1727)
.annotate 'line', 780
    get_hll_global $P1728, "NQPConcreteRoleHOW"
    find_lex $P1729, "self"
    get_global $P1730, "$?CLASS"
    getattribute $P1731, $P1729, $P1730, "$!name"
    unless_null $P1731, vivify_358
    new $P1731, "Undef"
  vivify_358:
    find_lex $P1732, "$obj"
    $P1733 = $P1728."new_type"($P1731 :named("name"), $P1732 :named("instance_of"))
    store_lex "$irole", $P1733
.annotate 'line', 784
    find_lex $P1735, "self"
    get_global $P1736, "$?CLASS"
    getattribute $P1737, $P1735, $P1736, "%!attributes"
    unless_null $P1737, vivify_359
    $P1737 = root_new ['parrot';'Hash']
  vivify_359:
    defined $I1738, $P1737
    unless $I1738, for_undef_360
    iter $P1734, $P1737
    new $P1750, 'ExceptionHandler'
    set_label $P1750, loop1749_handler
    $P1750."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1750
  loop1749_test:
    unless $P1734, loop1749_done
    shift $P1739, $P1734
  loop1749_redo:
    .const 'Sub' $P1741 = "121_1298845494.89" 
    capture_lex $P1741
    $P1741($P1739)
  loop1749_next:
    goto loop1749_test
  loop1749_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1751, exception, 'type'
    eq $P1751, .CONTROL_LOOP_NEXT, loop1749_next
    eq $P1751, .CONTROL_LOOP_REDO, loop1749_redo
  loop1749_done:
    pop_eh 
  for_undef_360:
.annotate 'line', 790
    find_lex $P1753, "self"
    get_global $P1754, "$?CLASS"
    getattribute $P1755, $P1753, $P1754, "%!methods"
    unless_null $P1755, vivify_361
    $P1755 = root_new ['parrot';'Hash']
  vivify_361:
    defined $I1756, $P1755
    unless $I1756, for_undef_362
    iter $P1752, $P1755
    new $P1771, 'ExceptionHandler'
    set_label $P1771, loop1770_handler
    $P1771."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1771
  loop1770_test:
    unless $P1752, loop1770_done
    shift $P1757, $P1752
  loop1770_redo:
    .const 'Sub' $P1759 = "122_1298845494.89" 
    capture_lex $P1759
    $P1759($P1757)
  loop1770_next:
    goto loop1770_test
  loop1770_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1772, exception, 'type'
    eq $P1772, .CONTROL_LOOP_NEXT, loop1770_next
    eq $P1772, .CONTROL_LOOP_REDO, loop1770_redo
  loop1770_done:
    pop_eh 
  for_undef_362:
.annotate 'line', 793
    find_lex $P1774, "self"
    get_global $P1775, "$?CLASS"
    getattribute $P1776, $P1774, $P1775, "@!multi_methods_to_incorporate"
    unless_null $P1776, vivify_363
    $P1776 = root_new ['parrot';'ResizablePMCArray']
  vivify_363:
    defined $I1777, $P1776
    unless $I1777, for_undef_364
    iter $P1773, $P1776
    new $P1792, 'ExceptionHandler'
    set_label $P1792, loop1791_handler
    $P1792."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1792
  loop1791_test:
    unless $P1773, loop1791_done
    shift $P1778, $P1773
  loop1791_redo:
    .const 'Sub' $P1780 = "123_1298845494.89" 
    capture_lex $P1780
    $P1780($P1778)
  loop1791_next:
    goto loop1791_test
  loop1791_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1793, exception, 'type'
    eq $P1793, .CONTROL_LOOP_NEXT, loop1791_next
    eq $P1793, .CONTROL_LOOP_REDO, loop1791_redo
  loop1791_done:
    pop_eh 
  for_undef_364:
.annotate 'line', 798
    find_lex $P1795, "self"
    get_global $P1796, "$?CLASS"
    getattribute $P1797, $P1795, $P1796, "@!roles"
    unless_null $P1797, vivify_369
    $P1797 = root_new ['parrot';'ResizablePMCArray']
  vivify_369:
    defined $I1798, $P1797
    unless $I1798, for_undef_370
    iter $P1794, $P1797
    new $P1815, 'ExceptionHandler'
    set_label $P1815, loop1814_handler
    $P1815."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1815
  loop1814_test:
    unless $P1794, loop1814_done
    shift $P1799, $P1794
  loop1814_redo:
    .const 'Sub' $P1801 = "124_1298845494.89" 
    capture_lex $P1801
    $P1801($P1799)
  loop1814_next:
    goto loop1814_test
  loop1814_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1816, exception, 'type'
    eq $P1816, .CONTROL_LOOP_NEXT, loop1814_next
    eq $P1816, .CONTROL_LOOP_REDO, loop1814_redo
  loop1814_done:
    pop_eh 
  for_undef_370:
.annotate 'line', 804
    find_lex $P1817, "$irole"
    get_how $P1818, $P1817
    find_lex $P1819, "$irole"
    $P1818."compose"($P1819)
.annotate 'line', 805
    new $P1820, "Exception"
    set $P1820['type'], .CONTROL_RETURN
    find_lex $P1821, "$irole"
    setattribute $P1820, 'payload', $P1821
    throw $P1820
.annotate 'line', 774
    .return ()
  control_1718:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1822, exception, "payload"
    .return ($P1822)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1740"  :anon :subid("121_1298845494.89") :outer("120_1298845494.89")
    .param pmc param_1742
.annotate 'line', 784
    .lex "$_", param_1742
.annotate 'line', 785
    find_lex $P1743, "$irole"
    get_how $P1744, $P1743
    find_lex $P1745, "$irole"
    find_lex $P1746, "$_"
    $P1747 = $P1746."value"()
    $P1748 = $P1744."add_attribute"($P1745, $P1747)
.annotate 'line', 784
    .return ($P1748)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1758"  :anon :subid("122_1298845494.89") :outer("120_1298845494.89")
    .param pmc param_1760
.annotate 'line', 790
    .lex "$_", param_1760
.annotate 'line', 791
    find_lex $P1761, "$irole"
    get_how $P1762, $P1761
    find_lex $P1763, "$irole"
    find_lex $P1764, "$_"
    $P1765 = $P1764."key"()
    find_lex $P1766, "$_"
    $P1767 = $P1766."value"()
    clone $P1768, $P1767
    $P1769 = $P1762."add_method"($P1763, $P1765, $P1768)
.annotate 'line', 790
    .return ($P1769)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1779"  :anon :subid("123_1298845494.89") :outer("120_1298845494.89")
    .param pmc param_1781
.annotate 'line', 793
    .lex "$_", param_1781
.annotate 'line', 794
    find_lex $P1782, "$irole"
    get_how $P1783, $P1782
    find_lex $P1784, "$irole"
    find_lex $P1785, "$_"
    unless_null $P1785, vivify_365
    $P1785 = root_new ['parrot';'Hash']
  vivify_365:
    set $P1786, $P1785["name"]
    unless_null $P1786, vivify_366
    new $P1786, "Undef"
  vivify_366:
    find_lex $P1787, "$_"
    unless_null $P1787, vivify_367
    $P1787 = root_new ['parrot';'Hash']
  vivify_367:
    set $P1788, $P1787["code"]
    unless_null $P1788, vivify_368
    new $P1788, "Undef"
  vivify_368:
    clone $P1789, $P1788
    $P1790 = $P1783."add_multi_method"($P1784, $P1786, $P1789)
.annotate 'line', 793
    .return ($P1790)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1800"  :anon :subid("124_1298845494.89") :outer("120_1298845494.89")
    .param pmc param_1803
.annotate 'line', 799
    new $P1802, "Undef"
    .lex "$instantiated", $P1802
    .lex "$_", param_1803
    find_lex $P1804, "$irole"
    get_how $P1805, $P1804
    find_lex $P1806, "$irole"
    find_lex $P1807, "$class_arg"
    $P1808 = $P1805."instantiate"($P1806, $P1807)
    store_lex "$instantiated", $P1808
.annotate 'line', 800
    find_lex $P1809, "$irole"
    get_how $P1810, $P1809
    find_lex $P1811, "$irole"
    find_lex $P1812, "$instantiated"
    $P1813 = $P1810."add_role"($P1811, $P1812)
.annotate 'line', 798
    .return ($P1813)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("125_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1824
    .param pmc param_1825
.annotate 'line', 813
    .const 'Sub' $P1835 = "126_1298845494.89" 
    capture_lex $P1835
    .lex "self", param_1824
    .lex "$obj", param_1825
.annotate 'line', 814
    $P1826 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1826
.annotate 'line', 813
    find_lex $P1827, "@meths"
.annotate 'line', 815
    find_lex $P1829, "self"
    get_global $P1830, "$?CLASS"
    getattribute $P1831, $P1829, $P1830, "%!methods"
    unless_null $P1831, vivify_371
    $P1831 = root_new ['parrot';'Hash']
  vivify_371:
    defined $I1832, $P1831
    unless $I1832, for_undef_372
    iter $P1828, $P1831
    new $P1842, 'ExceptionHandler'
    set_label $P1842, loop1841_handler
    $P1842."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1842
  loop1841_test:
    unless $P1828, loop1841_done
    shift $P1833, $P1828
  loop1841_redo:
    .const 'Sub' $P1835 = "126_1298845494.89" 
    capture_lex $P1835
    $P1835($P1833)
  loop1841_next:
    goto loop1841_test
  loop1841_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1843, exception, 'type'
    eq $P1843, .CONTROL_LOOP_NEXT, loop1841_next
    eq $P1843, .CONTROL_LOOP_REDO, loop1841_redo
  loop1841_done:
    pop_eh 
  for_undef_372:
    find_lex $P1844, "@meths"
.annotate 'line', 813
    .return ($P1844)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1834"  :anon :subid("126_1298845494.89") :outer("125_1298845494.89")
    .param pmc param_1836
.annotate 'line', 815
    .lex "$_", param_1836
.annotate 'line', 816
    find_lex $P1837, "@meths"
    find_lex $P1838, "$_"
    $P1839 = $P1838."value"()
    $P1840 = $P1837."push"($P1839)
.annotate 'line', 815
    .return ($P1840)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "method_table"  :subid("127_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1846
    .param pmc param_1847
.annotate 'line', 821
    .lex "self", param_1846
    .lex "$obj", param_1847
    find_lex $P1848, "self"
    get_global $P1849, "$?CLASS"
    getattribute $P1850, $P1848, $P1849, "%!methods"
    unless_null $P1850, vivify_373
    $P1850 = root_new ['parrot';'Hash']
  vivify_373:
    .return ($P1850)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "name"  :subid("128_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1852
    .param pmc param_1853
.annotate 'line', 825
    .lex "self", param_1852
    .lex "$obj", param_1853
    find_lex $P1854, "self"
    get_global $P1855, "$?CLASS"
    getattribute $P1856, $P1854, $P1855, "$!name"
    unless_null $P1856, vivify_374
    new $P1856, "Undef"
  vivify_374:
    .return ($P1856)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("129_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1858
    .param pmc param_1859
.annotate 'line', 829
    .const 'Sub' $P1869 = "130_1298845494.89" 
    capture_lex $P1869
    .lex "self", param_1858
    .lex "$obj", param_1859
.annotate 'line', 830
    $P1860 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1860
.annotate 'line', 829
    find_lex $P1861, "@attrs"
.annotate 'line', 831
    find_lex $P1863, "self"
    get_global $P1864, "$?CLASS"
    getattribute $P1865, $P1863, $P1864, "%!attributes"
    unless_null $P1865, vivify_375
    $P1865 = root_new ['parrot';'Hash']
  vivify_375:
    defined $I1866, $P1865
    unless $I1866, for_undef_376
    iter $P1862, $P1865
    new $P1876, 'ExceptionHandler'
    set_label $P1876, loop1875_handler
    $P1876."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1876
  loop1875_test:
    unless $P1862, loop1875_done
    shift $P1867, $P1862
  loop1875_redo:
    .const 'Sub' $P1869 = "130_1298845494.89" 
    capture_lex $P1869
    $P1869($P1867)
  loop1875_next:
    goto loop1875_test
  loop1875_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1877, exception, 'type'
    eq $P1877, .CONTROL_LOOP_NEXT, loop1875_next
    eq $P1877, .CONTROL_LOOP_REDO, loop1875_redo
  loop1875_done:
    pop_eh 
  for_undef_376:
    find_lex $P1878, "@attrs"
.annotate 'line', 829
    .return ($P1878)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1868"  :anon :subid("130_1298845494.89") :outer("129_1298845494.89")
    .param pmc param_1870
.annotate 'line', 831
    .lex "$_", param_1870
.annotate 'line', 832
    find_lex $P1871, "@attrs"
    find_lex $P1872, "$_"
    $P1873 = $P1872."value"()
    $P1874 = $P1871."push"($P1873)
.annotate 'line', 831
    .return ($P1874)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "roles"  :subid("131_1298845494.89") :outer("109_1298845494.89")
    .param pmc param_1880
    .param pmc param_1881
.annotate 'line', 837
    .lex "self", param_1880
    .lex "$obj", param_1881
    find_lex $P1882, "self"
    get_global $P1883, "$?CLASS"
    getattribute $P1884, $P1882, $P1883, "@!roles"
    unless_null $P1884, vivify_377
    $P1884 = root_new ['parrot';'ResizablePMCArray']
  vivify_377:
    .return ($P1884)
.end


.namespace ["RoleToClassApplier"]
.sub "_block1945"  :subid("133_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 843
    .const 'Sub' $P2154 = "143_1298845494.89" 
    capture_lex $P2154
    .const 'Sub' $P2018 = "138_1298845494.89" 
    capture_lex $P2018
    .const 'Sub' $P1983 = "136_1298845494.89" 
    capture_lex $P1983
    .const 'Sub' $P1948 = "134_1298845494.89" 
    capture_lex $P1948
    get_global $P1947, "$?CLASS"
.annotate 'line', 845
    .const 'Sub' $P1948 = "134_1298845494.89" 
    newclosure $P1982, $P1948
    .lex "has_method", $P1982
.annotate 'line', 853
    .const 'Sub' $P1983 = "136_1298845494.89" 
    newclosure $P2015, $P1983
    .lex "has_attribute", $P2015
.annotate 'line', 843
    find_lex $P2016, "has_method"
    find_lex $P2017, "has_attribute"
.annotate 'line', 861
    .const 'Sub' $P2018 = "138_1298845494.89" 
    newclosure $P2152, $P2018
.annotate 'line', 843
    .return ($P2152)
.end


.namespace ["RoleToClassApplier"]
.sub "" :load :init :subid("post378") :outer("133_1298845494.89")
.annotate 'line', 843
    get_hll_global $P1946, ["RoleToClassApplier"], "_block1945" 
    .local pmc block
    set block, $P1946
    .const 'Sub' $P2154 = "143_1298845494.89" 
    capture_lex $P2154
    $P2154()
.end


.namespace ["RoleToClassApplier"]
.sub "_block2153"  :anon :subid("143_1298845494.89") :outer("133_1298845494.89")
.annotate 'line', 843
    get_hll_global $P2155, "KnowHOW"
    $P2156 = $P2155."new_type"("RoleToClassApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2156
    set_hll_global "RoleToClassApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2157, type_obj
    .const 'Sub' $P2158 = "138_1298845494.89" 
    $P2157."add_method"(type_obj, "apply", $P2158)
    get_how $P2159, type_obj
    $P2160 = $P2159."compose"(type_obj)
    .return ($P2160)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_method"  :subid("134_1298845494.89") :outer("133_1298845494.89")
    .param pmc param_1951
    .param pmc param_1952
    .param pmc param_1953
.annotate 'line', 845
    .const 'Sub' $P1965 = "135_1298845494.89" 
    capture_lex $P1965
    new $P1950, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1950, control_1949
    push_eh $P1950
    .lex "$target", param_1951
    .lex "$name", param_1952
    .lex "$local", param_1953
.annotate 'line', 846
    $P1954 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P1954
    find_lex $P1955, "$target"
    get_how $P1956, $P1955
    find_lex $P1957, "$target"
    find_lex $P1958, "$local"
    $P1959 = $P1956."methods"($P1957, $P1958 :named("local"))
    store_lex "@methods", $P1959
.annotate 'line', 847
    find_lex $P1961, "@methods"
    defined $I1962, $P1961
    unless $I1962, for_undef_379
    iter $P1960, $P1961
    new $P1977, 'ExceptionHandler'
    set_label $P1977, loop1976_handler
    $P1977."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1977
  loop1976_test:
    unless $P1960, loop1976_done
    shift $P1963, $P1960
  loop1976_redo:
    .const 'Sub' $P1965 = "135_1298845494.89" 
    capture_lex $P1965
    $P1965($P1963)
  loop1976_next:
    goto loop1976_test
  loop1976_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1978, exception, 'type'
    eq $P1978, .CONTROL_LOOP_NEXT, loop1976_next
    eq $P1978, .CONTROL_LOOP_REDO, loop1976_redo
  loop1976_done:
    pop_eh 
  for_undef_379:
.annotate 'line', 850
    new $P1979, "Exception"
    set $P1979['type'], .CONTROL_RETURN
    new $P1980, "Integer"
    assign $P1980, 0
    setattribute $P1979, 'payload', $P1980
    throw $P1979
.annotate 'line', 845
    .return ()
  control_1949:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1981, exception, "payload"
    .return ($P1981)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block1964"  :anon :subid("135_1298845494.89") :outer("134_1298845494.89")
    .param pmc param_1966
.annotate 'line', 847
    .lex "$_", param_1966
.annotate 'line', 848
    find_lex $P1969, "$_"
    set $S1970, $P1969
    find_lex $P1971, "$name"
    set $S1972, $P1971
    iseq $I1973, $S1970, $S1972
    if $I1973, if_1968
    new $P1967, 'Integer'
    set $P1967, $I1973
    goto if_1968_end
  if_1968:
    new $P1974, "Exception"
    set $P1974['type'], .CONTROL_RETURN
    new $P1975, "Integer"
    assign $P1975, 1
    setattribute $P1974, 'payload', $P1975
    throw $P1974
  if_1968_end:
.annotate 'line', 847
    .return ($P1967)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_attribute"  :subid("136_1298845494.89") :outer("133_1298845494.89")
    .param pmc param_1986
    .param pmc param_1987
.annotate 'line', 853
    .const 'Sub' $P1998 = "137_1298845494.89" 
    capture_lex $P1998
    new $P1985, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1985, control_1984
    push_eh $P1985
    .lex "$target", param_1986
    .lex "$name", param_1987
.annotate 'line', 854
    $P1988 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P1988
    find_lex $P1989, "$target"
    get_how $P1990, $P1989
    find_lex $P1991, "$target"
    $P1992 = $P1990."attributes"($P1991, 1 :named("local"))
    store_lex "@attributes", $P1992
.annotate 'line', 855
    find_lex $P1994, "@attributes"
    defined $I1995, $P1994
    unless $I1995, for_undef_380
    iter $P1993, $P1994
    new $P2010, 'ExceptionHandler'
    set_label $P2010, loop2009_handler
    $P2010."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2010
  loop2009_test:
    unless $P1993, loop2009_done
    shift $P1996, $P1993
  loop2009_redo:
    .const 'Sub' $P1998 = "137_1298845494.89" 
    capture_lex $P1998
    $P1998($P1996)
  loop2009_next:
    goto loop2009_test
  loop2009_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2011, exception, 'type'
    eq $P2011, .CONTROL_LOOP_NEXT, loop2009_next
    eq $P2011, .CONTROL_LOOP_REDO, loop2009_redo
  loop2009_done:
    pop_eh 
  for_undef_380:
.annotate 'line', 858
    new $P2012, "Exception"
    set $P2012['type'], .CONTROL_RETURN
    new $P2013, "Integer"
    assign $P2013, 0
    setattribute $P2012, 'payload', $P2013
    throw $P2012
.annotate 'line', 853
    .return ()
  control_1984:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2014, exception, "payload"
    .return ($P2014)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block1997"  :anon :subid("137_1298845494.89") :outer("136_1298845494.89")
    .param pmc param_1999
.annotate 'line', 855
    .lex "$_", param_1999
.annotate 'line', 856
    find_lex $P2002, "$_"
    $S2003 = $P2002."name"()
    find_lex $P2004, "$name"
    set $S2005, $P2004
    iseq $I2006, $S2003, $S2005
    if $I2006, if_2001
    new $P2000, 'Integer'
    set $P2000, $I2006
    goto if_2001_end
  if_2001:
    new $P2007, "Exception"
    set $P2007['type'], .CONTROL_RETURN
    new $P2008, "Integer"
    assign $P2008, 1
    setattribute $P2007, 'payload', $P2008
    throw $P2007
  if_2001_end:
.annotate 'line', 855
    .return ($P2000)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("138_1298845494.89") :outer("133_1298845494.89")
    .param pmc param_2019
    .param pmc param_2020
    .param pmc param_2021
.annotate 'line', 861
    .const 'Sub' $P2123 = "142_1298845494.89" 
    capture_lex $P2123
    .const 'Sub' $P2097 = "141_1298845494.89" 
    capture_lex $P2097
    .const 'Sub' $P2068 = "140_1298845494.89" 
    capture_lex $P2068
    .const 'Sub' $P2048 = "139_1298845494.89" 
    capture_lex $P2048
    .lex "self", param_2019
    .lex "$target", param_2020
    .lex "@roles", param_2021
.annotate 'line', 864
    new $P2022, "Undef"
    .lex "$to_compose", $P2022
.annotate 'line', 865
    new $P2023, "Undef"
    .lex "$to_compose_meta", $P2023
.annotate 'line', 880
    $P2024 = root_new ['parrot';'ResizablePMCArray']
    .lex "@collisions", $P2024
.annotate 'line', 889
    $P2025 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2025
.annotate 'line', 897
    $P2026 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2026
.annotate 'line', 909
    $P2027 = root_new ['parrot';'ResizablePMCArray']
    .lex "@done", $P2027
.annotate 'line', 861
    find_lex $P2028, "$to_compose"
    find_lex $P2029, "$to_compose_meta"
.annotate 'line', 866
    find_lex $P2031, "@roles"
    set $N2032, $P2031
    iseq $I2033, $N2032, 1.0
    if $I2033, if_2030
.annotate 'line', 871
    get_hll_global $P2038, "NQPConcreteRoleHOW"
    get_hll_global $P2039, "NQPMu"
    $P2040 = $P2038."new_type"($P2039 :named("instance_of"))
    store_lex "$to_compose", $P2040
.annotate 'line', 872
    find_lex $P2041, "$to_compose"
    get_how $P2042, $P2041
    store_lex "$to_compose_meta", $P2042
.annotate 'line', 873
    find_lex $P2044, "@roles"
    defined $I2045, $P2044
    unless $I2045, for_undef_381
    iter $P2043, $P2044
    new $P2055, 'ExceptionHandler'
    set_label $P2055, loop2054_handler
    $P2055."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2055
  loop2054_test:
    unless $P2043, loop2054_done
    shift $P2046, $P2043
  loop2054_redo:
    .const 'Sub' $P2048 = "139_1298845494.89" 
    capture_lex $P2048
    $P2048($P2046)
  loop2054_next:
    goto loop2054_test
  loop2054_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2056, exception, 'type'
    eq $P2056, .CONTROL_LOOP_NEXT, loop2054_next
    eq $P2056, .CONTROL_LOOP_REDO, loop2054_redo
  loop2054_done:
    pop_eh 
  for_undef_381:
.annotate 'line', 876
    find_lex $P2057, "$to_compose_meta"
    find_lex $P2058, "$to_compose"
    $P2059 = $P2057."compose"($P2058)
    store_lex "$to_compose", $P2059
.annotate 'line', 870
    goto if_2030_end
  if_2030:
.annotate 'line', 867
    find_lex $P2034, "@roles"
    unless_null $P2034, vivify_382
    $P2034 = root_new ['parrot';'ResizablePMCArray']
  vivify_382:
    set $P2035, $P2034[0]
    unless_null $P2035, vivify_383
    new $P2035, "Undef"
  vivify_383:
    store_lex "$to_compose", $P2035
.annotate 'line', 868
    find_lex $P2036, "$to_compose"
    get_how $P2037, $P2036
    store_lex "$to_compose_meta", $P2037
  if_2030_end:
.annotate 'line', 880
    find_lex $P2060, "$to_compose_meta"
    find_lex $P2061, "$to_compose"
    $P2062 = $P2060."collisions"($P2061)
    store_lex "@collisions", $P2062
.annotate 'line', 881
    find_lex $P2064, "@collisions"
    defined $I2065, $P2064
    unless $I2065, for_undef_384
    iter $P2063, $P2064
    new $P2087, 'ExceptionHandler'
    set_label $P2087, loop2086_handler
    $P2087."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2087
  loop2086_test:
    unless $P2063, loop2086_done
    shift $P2066, $P2063
  loop2086_redo:
    .const 'Sub' $P2068 = "140_1298845494.89" 
    capture_lex $P2068
    $P2068($P2066)
  loop2086_next:
    goto loop2086_test
  loop2086_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2088, exception, 'type'
    eq $P2088, .CONTROL_LOOP_NEXT, loop2086_next
    eq $P2088, .CONTROL_LOOP_REDO, loop2086_redo
  loop2086_done:
    pop_eh 
  for_undef_384:
.annotate 'line', 889
    find_lex $P2089, "$to_compose_meta"
    find_lex $P2090, "$to_compose"
    $P2091 = $P2089."methods"($P2090)
    store_lex "@methods", $P2091
.annotate 'line', 890
    find_lex $P2093, "@methods"
    defined $I2094, $P2093
    unless $I2094, for_undef_385
    iter $P2092, $P2093
    new $P2113, 'ExceptionHandler'
    set_label $P2113, loop2112_handler
    $P2113."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2113
  loop2112_test:
    unless $P2092, loop2112_done
    shift $P2095, $P2092
  loop2112_redo:
    .const 'Sub' $P2097 = "141_1298845494.89" 
    capture_lex $P2097
    $P2097($P2095)
  loop2112_next:
    goto loop2112_test
  loop2112_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2114, exception, 'type'
    eq $P2114, .CONTROL_LOOP_NEXT, loop2112_next
    eq $P2114, .CONTROL_LOOP_REDO, loop2112_redo
  loop2112_done:
    pop_eh 
  for_undef_385:
.annotate 'line', 897
    find_lex $P2115, "$to_compose_meta"
    find_lex $P2116, "$to_compose"
    $P2117 = $P2115."attributes"($P2116)
    store_lex "@attributes", $P2117
.annotate 'line', 898
    find_lex $P2119, "@attributes"
    defined $I2120, $P2119
    unless $I2120, for_undef_386
    iter $P2118, $P2119
    new $P2147, 'ExceptionHandler'
    set_label $P2147, loop2146_handler
    $P2147."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2147
  loop2146_test:
    unless $P2118, loop2146_done
    shift $P2121, $P2118
  loop2146_redo:
    .const 'Sub' $P2123 = "142_1298845494.89" 
    capture_lex $P2123
    $P2123($P2121)
  loop2146_next:
    goto loop2146_test
  loop2146_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2148, exception, 'type'
    eq $P2148, .CONTROL_LOOP_NEXT, loop2146_next
    eq $P2148, .CONTROL_LOOP_REDO, loop2146_redo
  loop2146_done:
    pop_eh 
  for_undef_386:
    find_lex $P2149, "@done"
.annotate 'line', 910
    find_lex $P2150, "$to_compose"
    find_lex $P2151, "@done"
    unless_null $P2151, vivify_387
    $P2151 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@done", $P2151
  vivify_387:
    set $P2151[0], $P2150
.annotate 'line', 861
    .return ($P2150)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2047"  :anon :subid("139_1298845494.89") :outer("138_1298845494.89")
    .param pmc param_2049
.annotate 'line', 873
    .lex "$_", param_2049
.annotate 'line', 874
    find_lex $P2050, "$to_compose_meta"
    find_lex $P2051, "$to_compose"
    find_lex $P2052, "$_"
    $P2053 = $P2050."add_role"($P2051, $P2052)
.annotate 'line', 873
    .return ($P2053)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2067"  :anon :subid("140_1298845494.89") :outer("138_1298845494.89")
    .param pmc param_2069
.annotate 'line', 881
    .lex "$_", param_2069
.annotate 'line', 882
    find_lex $P2072, "$target"
    find_lex $P2073, "$_"
    set $S2074, $P2073
    $P2075 = "has_method"($P2072, $S2074, 1)
    unless $P2075, unless_2071
    set $P2070, $P2075
    goto unless_2071_end
  unless_2071:
.annotate 'line', 883
    new $P2076, 'String'
    set $P2076, "Method '"
    find_lex $P2077, "$_"
    concat $P2078, $P2076, $P2077
    concat $P2079, $P2078, "' collides and a resolution must be provided by the class '"
.annotate 'line', 884
    find_lex $P2080, "$target"
    get_how $P2081, $P2080
    find_lex $P2082, "$target"
    $S2083 = $P2081."name"($P2082)
    concat $P2084, $P2079, $S2083
.annotate 'line', 883
    concat $P2085, $P2084, "'"
.annotate 'line', 884
    die $P2085
  unless_2071_end:
.annotate 'line', 881
    .return ($P2070)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2096"  :anon :subid("141_1298845494.89") :outer("138_1298845494.89")
    .param pmc param_2098
.annotate 'line', 890
    .lex "$_", param_2098
.annotate 'line', 891
    find_lex $P2101, "$target"
    find_lex $P2102, "$_"
    set $S2103, $P2102
    $P2104 = "has_method"($P2101, $S2103, 0)
    unless $P2104, unless_2100
    set $P2099, $P2104
    goto unless_2100_end
  unless_2100:
.annotate 'line', 892
    find_lex $P2105, "$target"
    get_how $P2106, $P2105
    find_lex $P2107, "$target"
    find_lex $P2108, "$_"
    set $S2109, $P2108
    find_lex $P2110, "$_"
    $P2111 = $P2106."add_method"($P2107, $S2109, $P2110)
.annotate 'line', 891
    set $P2099, $P2111
  unless_2100_end:
.annotate 'line', 890
    .return ($P2099)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2122"  :anon :subid("142_1298845494.89") :outer("138_1298845494.89")
    .param pmc param_2124
.annotate 'line', 898
    .lex "$_", param_2124
.annotate 'line', 899
    find_lex $P2126, "$target"
    find_lex $P2127, "$_"
    $P2128 = $P2127."name"()
    $P2129 = "has_attribute"($P2126, $P2128)
    unless $P2129, if_2125_end
.annotate 'line', 900
    new $P2130, "String"
    assign $P2130, "Attribute '"
    find_lex $P2131, "$_"
    $S2132 = $P2131."name"()
    concat $P2133, $P2130, $S2132
    concat $P2134, $P2133, "' already exists in the class '"
.annotate 'line', 901
    find_lex $P2135, "$target"
    get_how $P2136, $P2135
    find_lex $P2137, "$target"
    $S2138 = $P2136."name"($P2137)
    concat $P2139, $P2134, $S2138
.annotate 'line', 900
    concat $P2140, $P2139, "', but a role also wishes to compose it"
.annotate 'line', 901
    die $P2140
  if_2125_end:
.annotate 'line', 903
    find_lex $P2141, "$target"
    get_how $P2142, $P2141
    find_lex $P2143, "$target"
    find_lex $P2144, "$_"
    $P2145 = $P2142."add_attribute"($P2143, $P2144)
.annotate 'line', 898
    .return ($P2145)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2161"  :subid("144_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 915
    .const 'Sub' $P2384 = "154_1298845494.89" 
    capture_lex $P2384
    .const 'Sub' $P2164 = "145_1298845494.89" 
    capture_lex $P2164
    get_global $P2163, "$?CLASS"
.annotate 'line', 916
    .const 'Sub' $P2164 = "145_1298845494.89" 
    newclosure $P2382, $P2164
.annotate 'line', 915
    .return ($P2382)
.end


.namespace ["RoleToRoleApplier"]
.sub "" :load :init :subid("post388") :outer("144_1298845494.89")
.annotate 'line', 915
    get_hll_global $P2162, ["RoleToRoleApplier"], "_block2161" 
    .local pmc block
    set block, $P2162
    .const 'Sub' $P2384 = "154_1298845494.89" 
    capture_lex $P2384
    $P2384()
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2383"  :anon :subid("154_1298845494.89") :outer("144_1298845494.89")
.annotate 'line', 915
    get_hll_global $P2385, "KnowHOW"
    $P2386 = $P2385."new_type"("RoleToRoleApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2386
    set_hll_global "RoleToRoleApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2387, type_obj
    .const 'Sub' $P2388 = "145_1298845494.89" 
    $P2387."add_method"(type_obj, "apply", $P2388)
    get_how $P2389, type_obj
    $P2390 = $P2389."compose"(type_obj)
    .return ($P2390)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("145_1298845494.89") :outer("144_1298845494.89")
    .param pmc param_2167
    .param pmc param_2168
    .param pmc param_2169
.annotate 'line', 916
    .const 'Sub' $P2309 = "151_1298845494.89" 
    capture_lex $P2309
    .const 'Sub' $P2267 = "150_1298845494.89" 
    capture_lex $P2267
    .const 'Sub' $P2253 = "149_1298845494.89" 
    capture_lex $P2253
    .const 'Sub' $P2180 = "146_1298845494.89" 
    capture_lex $P2180
    new $P2166, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2166, control_2165
    push_eh $P2166
    .lex "self", param_2167
    .lex "$target", param_2168
    .lex "@roles", param_2169
.annotate 'line', 918
    $P2170 = root_new ['parrot';'Hash']
    .lex "%meth_info", $P2170
.annotate 'line', 944
    $P2171 = root_new ['parrot';'Hash']
    .lex "%target_meth_info", $P2171
.annotate 'line', 945
    $P2172 = root_new ['parrot';'ResizablePMCArray']
    .lex "@target_meths", $P2172
.annotate 'line', 970
    $P2173 = root_new ['parrot';'ResizablePMCArray']
    .lex "@all_roles", $P2173
.annotate 'line', 916
    find_lex $P2174, "%meth_info"
.annotate 'line', 919
    find_lex $P2176, "@roles"
    defined $I2177, $P2176
    unless $I2177, for_undef_389
    iter $P2175, $P2176
    new $P2241, 'ExceptionHandler'
    set_label $P2241, loop2240_handler
    $P2241."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2241
  loop2240_test:
    unless $P2175, loop2240_done
    shift $P2178, $P2175
  loop2240_redo:
    .const 'Sub' $P2180 = "146_1298845494.89" 
    capture_lex $P2180
    $P2180($P2178)
  loop2240_next:
    goto loop2240_test
  loop2240_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2242, exception, 'type'
    eq $P2242, .CONTROL_LOOP_NEXT, loop2240_next
    eq $P2242, .CONTROL_LOOP_REDO, loop2240_redo
  loop2240_done:
    pop_eh 
  for_undef_389:
    find_lex $P2243, "%target_meth_info"
.annotate 'line', 945
    find_lex $P2244, "$target"
    get_how $P2245, $P2244
    find_lex $P2246, "$target"
    $P2247 = $P2245."methods"($P2246)
    store_lex "@target_meths", $P2247
.annotate 'line', 946
    find_lex $P2249, "@target_meths"
    defined $I2250, $P2249
    unless $I2250, for_undef_397
    iter $P2248, $P2249
    new $P2260, 'ExceptionHandler'
    set_label $P2260, loop2259_handler
    $P2260."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2260
  loop2259_test:
    unless $P2248, loop2259_done
    shift $P2251, $P2248
  loop2259_redo:
    .const 'Sub' $P2253 = "149_1298845494.89" 
    capture_lex $P2253
    $P2253($P2251)
  loop2259_next:
    goto loop2259_test
  loop2259_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2261, exception, 'type'
    eq $P2261, .CONTROL_LOOP_NEXT, loop2259_next
    eq $P2261, .CONTROL_LOOP_REDO, loop2259_redo
  loop2259_done:
    pop_eh 
  for_undef_397:
.annotate 'line', 951
    find_lex $P2263, "%meth_info"
    defined $I2264, $P2263
    unless $I2264, for_undef_399
    iter $P2262, $P2263
    new $P2301, 'ExceptionHandler'
    set_label $P2301, loop2300_handler
    $P2301."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2301
  loop2300_test:
    unless $P2262, loop2300_done
    shift $P2265, $P2262
  loop2300_redo:
    .const 'Sub' $P2267 = "150_1298845494.89" 
    capture_lex $P2267
    $P2267($P2265)
  loop2300_next:
    goto loop2300_test
  loop2300_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2302, exception, 'type'
    eq $P2302, .CONTROL_LOOP_NEXT, loop2300_next
    eq $P2302, .CONTROL_LOOP_REDO, loop2300_redo
  loop2300_done:
    pop_eh 
  for_undef_399:
    find_lex $P2303, "@all_roles"
.annotate 'line', 971
    find_lex $P2305, "@roles"
    defined $I2306, $P2305
    unless $I2306, for_undef_406
    iter $P2304, $P2305
    new $P2377, 'ExceptionHandler'
    set_label $P2377, loop2376_handler
    $P2377."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2377
  loop2376_test:
    unless $P2304, loop2376_done
    shift $P2307, $P2304
  loop2376_redo:
    .const 'Sub' $P2309 = "151_1298845494.89" 
    capture_lex $P2309
    $P2309($P2307)
  loop2376_next:
    goto loop2376_test
  loop2376_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2378, exception, 'type'
    eq $P2378, .CONTROL_LOOP_NEXT, loop2376_next
    eq $P2378, .CONTROL_LOOP_REDO, loop2376_redo
  loop2376_done:
    pop_eh 
  for_undef_406:
.annotate 'line', 1000
    new $P2379, "Exception"
    set $P2379['type'], .CONTROL_RETURN
    find_lex $P2380, "@all_roles"
    setattribute $P2379, 'payload', $P2380
    throw $P2379
.annotate 'line', 916
    .return ()
  control_2165:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2381, exception, "payload"
    .return ($P2381)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2179"  :anon :subid("146_1298845494.89") :outer("145_1298845494.89")
    .param pmc param_2182
.annotate 'line', 919
    .const 'Sub' $P2192 = "147_1298845494.89" 
    capture_lex $P2192
.annotate 'line', 920
    $P2181 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2181
    .lex "$_", param_2182
    find_lex $P2183, "$_"
    get_how $P2184, $P2183
    find_lex $P2185, "$_"
    $P2186 = $P2184."methods"($P2185)
    store_lex "@methods", $P2186
.annotate 'line', 921
    find_lex $P2188, "@methods"
    defined $I2189, $P2188
    unless $I2189, for_undef_390
    iter $P2187, $P2188
    new $P2238, 'ExceptionHandler'
    set_label $P2238, loop2237_handler
    $P2238."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2238
  loop2237_test:
    unless $P2187, loop2237_done
    shift $P2190, $P2187
  loop2237_redo:
    .const 'Sub' $P2192 = "147_1298845494.89" 
    capture_lex $P2192
    $P2192($P2190)
  loop2237_next:
    goto loop2237_test
  loop2237_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2239, exception, 'type'
    eq $P2239, .CONTROL_LOOP_NEXT, loop2237_next
    eq $P2239, .CONTROL_LOOP_REDO, loop2237_redo
  loop2237_done:
    pop_eh 
  for_undef_390:
.annotate 'line', 919
    .return ($P2187)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2191"  :anon :subid("147_1298845494.89") :outer("146_1298845494.89")
    .param pmc param_2197
.annotate 'line', 921
    .const 'Sub' $P2220 = "148_1298845494.89" 
    capture_lex $P2220
.annotate 'line', 922
    new $P2193, "Undef"
    .lex "$name", $P2193
.annotate 'line', 923
    new $P2194, "Undef"
    .lex "$meth", $P2194
.annotate 'line', 924
    $P2195 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meth_list", $P2195
.annotate 'line', 931
    new $P2196, "Undef"
    .lex "$found", $P2196
    .lex "$_", param_2197
.annotate 'line', 922
    find_lex $P2198, "$_"
    set $S2199, $P2198
    new $P2200, 'String'
    set $P2200, $S2199
    store_lex "$name", $P2200
.annotate 'line', 923
    find_lex $P2201, "$_"
    store_lex "$meth", $P2201
    find_lex $P2202, "@meth_list"
.annotate 'line', 925
    find_lex $P2204, "$name"
    find_lex $P2205, "%meth_info"
    unless_null $P2205, vivify_391
    $P2205 = root_new ['parrot';'Hash']
  vivify_391:
    set $P2206, $P2205[$P2204]
    unless_null $P2206, vivify_392
    new $P2206, "Undef"
  vivify_392:
    defined $I2207, $P2206
    if $I2207, if_2203
.annotate 'line', 929
    find_lex $P2211, "@meth_list"
    find_lex $P2212, "$name"
    find_lex $P2213, "%meth_info"
    unless_null $P2213, vivify_393
    $P2213 = root_new ['parrot';'Hash']
    store_lex "%meth_info", $P2213
  vivify_393:
    set $P2213[$P2212], $P2211
.annotate 'line', 928
    goto if_2203_end
  if_2203:
.annotate 'line', 926
    find_lex $P2208, "$name"
    find_lex $P2209, "%meth_info"
    unless_null $P2209, vivify_394
    $P2209 = root_new ['parrot';'Hash']
  vivify_394:
    set $P2210, $P2209[$P2208]
    unless_null $P2210, vivify_395
    new $P2210, "Undef"
  vivify_395:
    store_lex "@meth_list", $P2210
  if_2203_end:
.annotate 'line', 931
    new $P2214, "Integer"
    assign $P2214, 0
    store_lex "$found", $P2214
.annotate 'line', 932
    find_lex $P2216, "@meth_list"
    defined $I2217, $P2216
    unless $I2217, for_undef_396
    iter $P2215, $P2216
    new $P2229, 'ExceptionHandler'
    set_label $P2229, loop2228_handler
    $P2229."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2229
  loop2228_test:
    unless $P2215, loop2228_done
    shift $P2218, $P2215
  loop2228_redo:
    .const 'Sub' $P2220 = "148_1298845494.89" 
    capture_lex $P2220
    $P2220($P2218)
  loop2228_next:
    goto loop2228_test
  loop2228_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2230, exception, 'type'
    eq $P2230, .CONTROL_LOOP_NEXT, loop2228_next
    eq $P2230, .CONTROL_LOOP_REDO, loop2228_redo
  loop2228_done:
    pop_eh 
  for_undef_396:
.annotate 'line', 937
    find_lex $P2233, "$found"
    unless $P2233, unless_2232
    set $P2231, $P2233
    goto unless_2232_end
  unless_2232:
.annotate 'line', 938
    find_lex $P2234, "@meth_list"
    find_lex $P2235, "$meth"
    $P2236 = $P2234."push"($P2235)
.annotate 'line', 937
    set $P2231, $P2236
  unless_2232_end:
.annotate 'line', 921
    .return ($P2231)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2219"  :anon :subid("148_1298845494.89") :outer("147_1298845494.89")
    .param pmc param_2221
.annotate 'line', 932
    .lex "$_", param_2221
.annotate 'line', 933
    find_lex $P2224, "$meth"
    find_lex $P2225, "$_"
    issame $I2226, $P2224, $P2225
    if $I2226, if_2223
    new $P2222, 'Integer'
    set $P2222, $I2226
    goto if_2223_end
  if_2223:
.annotate 'line', 934
    new $P2227, "Integer"
    assign $P2227, 1
    store_lex "$found", $P2227
.annotate 'line', 933
    set $P2222, $P2227
  if_2223_end:
.annotate 'line', 932
    .return ($P2222)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2252"  :anon :subid("149_1298845494.89") :outer("145_1298845494.89")
    .param pmc param_2254
.annotate 'line', 946
    .lex "$_", param_2254
.annotate 'line', 947
    find_lex $P2255, "$_"
    find_lex $P2256, "$_"
    set $S2257, $P2256
    find_lex $P2258, "%target_meth_info"
    unless_null $P2258, vivify_398
    $P2258 = root_new ['parrot';'Hash']
    store_lex "%target_meth_info", $P2258
  vivify_398:
    set $P2258[$S2257], $P2255
.annotate 'line', 946
    .return ($P2255)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2266"  :anon :subid("150_1298845494.89") :outer("145_1298845494.89")
    .param pmc param_2270
.annotate 'line', 952
    new $P2268, "Undef"
    .lex "$name", $P2268
.annotate 'line', 953
    $P2269 = root_new ['parrot';'ResizablePMCArray']
    .lex "@add_meths", $P2269
    .lex "$_", param_2270
.annotate 'line', 952
    find_lex $P2271, "$_"
    set $S2272, $P2271
    new $P2273, 'String'
    set $P2273, $S2272
    store_lex "$name", $P2273
.annotate 'line', 953
    find_lex $P2274, "$name"
    find_lex $P2275, "%meth_info"
    unless_null $P2275, vivify_400
    $P2275 = root_new ['parrot';'Hash']
  vivify_400:
    set $P2276, $P2275[$P2274]
    unless_null $P2276, vivify_401
    new $P2276, "Undef"
  vivify_401:
    store_lex "@add_meths", $P2276
.annotate 'line', 957
    find_lex $P2279, "$name"
    find_lex $P2280, "%target_meth_info"
    unless_null $P2280, vivify_402
    $P2280 = root_new ['parrot';'Hash']
  vivify_402:
    set $P2281, $P2280[$P2279]
    unless_null $P2281, vivify_403
    new $P2281, "Undef"
  vivify_403:
    defined $I2282, $P2281
    unless $I2282, unless_2278
    new $P2277, 'Integer'
    set $P2277, $I2282
    goto unless_2278_end
  unless_2278:
.annotate 'line', 959
    find_lex $P2285, "@add_meths"
    set $N2286, $P2285
    iseq $I2287, $N2286, 1.0
    if $I2287, if_2284
.annotate 'line', 964
    find_lex $P2295, "$target"
    get_how $P2296, $P2295
    find_lex $P2297, "$target"
    find_lex $P2298, "$name"
    $P2299 = $P2296."add_collision"($P2297, $P2298)
.annotate 'line', 962
    set $P2283, $P2299
.annotate 'line', 959
    goto if_2284_end
  if_2284:
.annotate 'line', 960
    find_lex $P2288, "$target"
    get_how $P2289, $P2288
    find_lex $P2290, "$target"
    find_lex $P2291, "$name"
    find_lex $P2292, "@add_meths"
    unless_null $P2292, vivify_404
    $P2292 = root_new ['parrot';'ResizablePMCArray']
  vivify_404:
    set $P2293, $P2292[0]
    unless_null $P2293, vivify_405
    new $P2293, "Undef"
  vivify_405:
    $P2294 = $P2289."add_method"($P2290, $P2291, $P2293)
.annotate 'line', 959
    set $P2283, $P2294
  if_2284_end:
.annotate 'line', 957
    set $P2277, $P2283
  unless_2278_end:
.annotate 'line', 951
    .return ($P2277)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2308"  :anon :subid("151_1298845494.89") :outer("145_1298845494.89")
    .param pmc param_2312
.annotate 'line', 971
    .const 'Sub' $P2323 = "152_1298845494.89" 
    capture_lex $P2323
.annotate 'line', 972
    new $P2310, "Undef"
    .lex "$how", $P2310
.annotate 'line', 975
    $P2311 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2311
    .lex "$_", param_2312
.annotate 'line', 972
    find_lex $P2313, "$_"
    get_how $P2314, $P2313
    store_lex "$how", $P2314
.annotate 'line', 975
    find_lex $P2315, "$how"
    find_lex $P2316, "$_"
    $P2317 = $P2315."attributes"($P2316)
    store_lex "@attributes", $P2317
.annotate 'line', 976
    find_lex $P2319, "@attributes"
    defined $I2320, $P2319
    unless $I2320, for_undef_407
    iter $P2318, $P2319
    new $P2371, 'ExceptionHandler'
    set_label $P2371, loop2370_handler
    $P2371."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2371
  loop2370_test:
    unless $P2318, loop2370_done
    shift $P2321, $P2318
  loop2370_redo:
    .const 'Sub' $P2323 = "152_1298845494.89" 
    capture_lex $P2323
    $P2323($P2321)
  loop2370_next:
    goto loop2370_test
  loop2370_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2372, exception, 'type'
    eq $P2372, .CONTROL_LOOP_NEXT, loop2370_next
    eq $P2372, .CONTROL_LOOP_REDO, loop2370_redo
  loop2370_done:
    pop_eh 
  for_undef_407:
.annotate 'line', 997
    find_lex $P2373, "@all_roles"
    find_lex $P2374, "$_"
    $P2375 = $P2373."push"($P2374)
.annotate 'line', 971
    .return ($P2375)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2322"  :anon :subid("152_1298845494.89") :outer("151_1298845494.89")
    .param pmc param_2327
.annotate 'line', 976
    .const 'Sub' $P2339 = "153_1298845494.89" 
    capture_lex $P2339
.annotate 'line', 977
    new $P2324, "Undef"
    .lex "$add_attr", $P2324
.annotate 'line', 978
    new $P2325, "Undef"
    .lex "$skip", $P2325
.annotate 'line', 979
    $P2326 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cur_attrs", $P2326
    .lex "$_", param_2327
.annotate 'line', 977
    find_lex $P2328, "$_"
    store_lex "$add_attr", $P2328
.annotate 'line', 978
    new $P2329, "Integer"
    assign $P2329, 0
    store_lex "$skip", $P2329
.annotate 'line', 979
    find_lex $P2330, "$target"
    get_how $P2331, $P2330
    find_lex $P2332, "$target"
    $P2333 = $P2331."attributes"($P2332)
    store_lex "@cur_attrs", $P2333
.annotate 'line', 980
    find_lex $P2335, "@cur_attrs"
    defined $I2336, $P2335
    unless $I2336, for_undef_408
    iter $P2334, $P2335
    new $P2360, 'ExceptionHandler'
    set_label $P2360, loop2359_handler
    $P2360."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2360
  loop2359_test:
    unless $P2334, loop2359_done
    shift $P2337, $P2334
  loop2359_redo:
    .const 'Sub' $P2339 = "153_1298845494.89" 
    capture_lex $P2339
    $P2339($P2337)
  loop2359_next:
    goto loop2359_test
  loop2359_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2361, exception, 'type'
    eq $P2361, .CONTROL_LOOP_NEXT, loop2359_next
    eq $P2361, .CONTROL_LOOP_REDO, loop2359_redo
  loop2359_done:
    pop_eh 
  for_undef_408:
.annotate 'line', 990
    find_lex $P2364, "$skip"
    unless $P2364, unless_2363
    set $P2362, $P2364
    goto unless_2363_end
  unless_2363:
.annotate 'line', 991
    find_lex $P2365, "$target"
    get_how $P2366, $P2365
    find_lex $P2367, "$target"
    find_lex $P2368, "$add_attr"
    $P2369 = $P2366."add_attribute"($P2367, $P2368)
.annotate 'line', 990
    set $P2362, $P2369
  unless_2363_end:
.annotate 'line', 976
    .return ($P2362)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2338"  :anon :subid("153_1298845494.89") :outer("152_1298845494.89")
    .param pmc param_2340
.annotate 'line', 980
    .lex "$_", param_2340
.annotate 'line', 981
    find_lex $P2343, "$_"
    find_lex $P2344, "$add_attr"
    issame $I2345, $P2343, $P2344
    if $I2345, if_2342
.annotate 'line', 985
    find_lex $P2349, "$_"
    $S2350 = $P2349."name"()
    find_lex $P2351, "$add_attr"
    $S2352 = $P2351."name"()
    iseq $I2353, $S2350, $S2352
    if $I2353, if_2348
    new $P2347, 'Integer'
    set $P2347, $I2353
    goto if_2348_end
  if_2348:
.annotate 'line', 986
    new $P2354, "String"
    assign $P2354, "Attribute '"
    find_lex $P2355, "$_"
    $S2356 = $P2355."name"()
    concat $P2357, $P2354, $S2356
    concat $P2358, $P2357, "' conflicts in role composition"
    die $P2358
  if_2348_end:
.annotate 'line', 984
    set $P2341, $P2347
.annotate 'line', 981
    goto if_2342_end
  if_2342:
.annotate 'line', 982
    new $P2346, "Integer"
    assign $P2346, 1
    store_lex "$skip", $P2346
.annotate 'line', 981
    set $P2341, $P2346
  if_2342_end:
.annotate 'line', 980
    .return ($P2341)
.end


.namespace ["NQPModuleHOW"]
.sub "_block2391"  :subid("155_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 1005
    .const 'Sub' $P2453 = "164_1298845494.89" 
    capture_lex $P2453
    .const 'Sub' $P2445 = "163_1298845494.89" 
    capture_lex $P2445
    .const 'Sub' $P2439 = "162_1298845494.89" 
    capture_lex $P2439
    .const 'Sub' $P2435 = "161_1298845494.89" 
    capture_lex $P2435
    .const 'Sub' $P2430 = "160_1298845494.89" 
    capture_lex $P2430
    .const 'Sub' $P2425 = "159_1298845494.89" 
    capture_lex $P2425
    .const 'Sub' $P2411 = "158_1298845494.89" 
    capture_lex $P2411
    .const 'Sub' $P2404 = "157_1298845494.89" 
    capture_lex $P2404
    .const 'Sub' $P2394 = "156_1298845494.89" 
    capture_lex $P2394
    get_global $P2393, "$?CLASS"
.annotate 'line', 1044
    .const 'Sub' $P2445 = "163_1298845494.89" 
    newclosure $P2451, $P2445
.annotate 'line', 1005
    .return ($P2451)
.end


.namespace ["NQPModuleHOW"]
.sub "" :load :init :subid("post409") :outer("155_1298845494.89")
.annotate 'line', 1005
    get_hll_global $P2392, ["NQPModuleHOW"], "_block2391" 
    .local pmc block
    set block, $P2392
    .const 'Sub' $P2453 = "164_1298845494.89" 
    capture_lex $P2453
    $P2453()
.end


.namespace ["NQPModuleHOW"]
.sub "_block2452"  :anon :subid("164_1298845494.89") :outer("155_1298845494.89")
.annotate 'line', 1005
    get_hll_global $P2454, "KnowHOW"
    $P2455 = $P2454."new_type"("NQPModuleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2455
    set_hll_global "NQPModuleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2456, type_obj
    get_hll_global $P2457, "KnowHOWAttribute"
    $P2458 = $P2457."new"("$!name" :named("name"))
    $P2456."add_attribute"(type_obj, $P2458)
    get_how $P2459, type_obj
    get_hll_global $P2460, "KnowHOWAttribute"
    $P2461 = $P2460."new"("$!composed" :named("name"))
    $P2459."add_attribute"(type_obj, $P2461)
    get_how $P2462, type_obj
    .const 'Sub' $P2463 = "156_1298845494.89" 
    $P2462."add_method"(type_obj, "new", $P2463)
    get_how $P2464, type_obj
    .const 'Sub' $P2465 = "157_1298845494.89" 
    $P2464."add_method"(type_obj, "BUILD", $P2465)
    get_how $P2466, type_obj
    .const 'Sub' $P2467 = "158_1298845494.89" 
    $P2466."add_method"(type_obj, "new_type", $P2467)
    get_how $P2468, type_obj
    .const 'Sub' $P2469 = "159_1298845494.89" 
    $P2468."add_method"(type_obj, "add_method", $P2469)
    get_how $P2470, type_obj
    .const 'Sub' $P2471 = "160_1298845494.89" 
    $P2470."add_method"(type_obj, "add_multi_method", $P2471)
    get_how $P2472, type_obj
    .const 'Sub' $P2473 = "161_1298845494.89" 
    $P2472."add_method"(type_obj, "add_attribute", $P2473)
    get_how $P2474, type_obj
    .const 'Sub' $P2475 = "162_1298845494.89" 
    $P2474."add_method"(type_obj, "compose", $P2475)
    get_how $P2476, type_obj
    .const 'Sub' $P2477 = "163_1298845494.89" 
    $P2476."add_method"(type_obj, "name", $P2477)
    get_how $P2478, type_obj
    $P2479 = $P2478."compose"(type_obj)
    .return ($P2479)
.end


.namespace ["NQPModuleHOW"]
.sub "new"  :subid("156_1298845494.89") :outer("155_1298845494.89")
    .param pmc param_2395
    .param pmc param_2396 :optional :named("name")
    .param int has_param_2396 :opt_flag
.annotate 'line', 1009
    .lex "self", param_2395
    if has_param_2396, optparam_410
    new $P2397, "Undef"
    set param_2396, $P2397
  optparam_410:
    .lex "$name", param_2396
.annotate 'line', 1010
    new $P2398, "Undef"
    .lex "$obj", $P2398
    find_lex $P2399, "self"
    repr_instance_of $P2400, $P2399
    store_lex "$obj", $P2400
.annotate 'line', 1011
    find_lex $P2401, "$obj"
    find_lex $P2402, "$name"
    $P2401."BUILD"($P2402 :named("name"))
    find_lex $P2403, "$obj"
.annotate 'line', 1009
    .return ($P2403)
.end


.namespace ["NQPModuleHOW"]
.sub "BUILD"  :subid("157_1298845494.89") :outer("155_1298845494.89")
    .param pmc param_2405
    .param pmc param_2406 :optional :named("name")
    .param int has_param_2406 :opt_flag
.annotate 'line', 1015
    .lex "self", param_2405
    if has_param_2406, optparam_411
    new $P2407, "Undef"
    set param_2406, $P2407
  optparam_411:
    .lex "$name", param_2406
.annotate 'line', 1016
    find_lex $P2408, "$name"
    find_lex $P2409, "self"
    get_global $P2410, "$?CLASS"
    setattribute $P2409, $P2410, "$!name", $P2408
.annotate 'line', 1015
    .return ($P2408)
.end


.namespace ["NQPModuleHOW"]
.sub "new_type"  :subid("158_1298845494.89") :outer("155_1298845494.89")
    .param pmc param_2412
    .param pmc param_2413 :optional :named("name")
    .param int has_param_2413 :opt_flag
    .param pmc param_2415 :optional :named("repr")
    .param int has_param_2415 :opt_flag
.annotate 'line', 1021
    .lex "self", param_2412
    if has_param_2413, optparam_412
    new $P2414, "String"
    assign $P2414, "<anon>"
    set param_2413, $P2414
  optparam_412:
    .lex "$name", param_2413
    if has_param_2415, optparam_413
    new $P2416, "String"
    assign $P2416, "P6opaque"
    set param_2415, $P2416
  optparam_413:
    .lex "$repr", param_2415
.annotate 'line', 1022
    new $P2417, "Undef"
    .lex "$metaclass", $P2417
    find_lex $P2418, "self"
    find_lex $P2419, "$name"
    $P2420 = $P2418."new"($P2419 :named("name"))
    store_lex "$metaclass", $P2420
.annotate 'line', 1023
    find_lex $P2421, "$metaclass"
    find_lex $P2422, "$repr"
    set $S2423, $P2422
    repr_type_object_for $P2424, $P2421, $S2423
.annotate 'line', 1021
    .return ($P2424)
.end


.namespace ["NQPModuleHOW"]
.sub "add_method"  :subid("159_1298845494.89") :outer("155_1298845494.89")
    .param pmc param_2426
    .param pmc param_2427
    .param pmc param_2428
    .param pmc param_2429
.annotate 'line', 1026
    .lex "self", param_2426
    .lex "$obj", param_2427
    .lex "$name", param_2428
    .lex "$code_obj", param_2429
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "add_multi_method"  :subid("160_1298845494.89") :outer("155_1298845494.89")
    .param pmc param_2431
    .param pmc param_2432
    .param pmc param_2433
    .param pmc param_2434
.annotate 'line', 1032
    .lex "self", param_2431
    .lex "$obj", param_2432
    .lex "$name", param_2433
    .lex "$code_obj", param_2434
.annotate 'line', 1033
    die "Modules may not have methods"
.annotate 'line', 1032
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "add_attribute"  :subid("161_1298845494.89") :outer("155_1298845494.89")
    .param pmc param_2436
    .param pmc param_2437
    .param pmc param_2438
.annotate 'line', 1036
    .lex "self", param_2436
    .lex "$obj", param_2437
    .lex "$meta_attr", param_2438
.annotate 'line', 1037
    die "Modules may not have attributes"
.annotate 'line', 1036
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "compose"  :subid("162_1298845494.89") :outer("155_1298845494.89")
    .param pmc param_2440
    .param pmc param_2441
.annotate 'line', 1040
    .lex "self", param_2440
    .lex "$obj", param_2441
.annotate 'line', 1041
    new $P2442, "Integer"
    assign $P2442, 1
    find_lex $P2443, "self"
    get_global $P2444, "$?CLASS"
    setattribute $P2443, $P2444, "$!composed", $P2442
.annotate 'line', 1040
    .return ($P2442)
.end


.namespace ["NQPModuleHOW"]
.sub "name"  :subid("163_1298845494.89") :outer("155_1298845494.89")
    .param pmc param_2446
    .param pmc param_2447
.annotate 'line', 1044
    .lex "self", param_2446
    .lex "$obj", param_2447
    find_lex $P2448, "self"
    get_global $P2449, "$?CLASS"
    getattribute $P2450, $P2448, $P2449, "$!name"
    unless_null $P2450, vivify_414
    new $P2450, "Undef"
  vivify_414:
    .return ($P2450)
.end


.namespace ["int"]
.sub "_block2480"  :subid("165_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 1050
    .const 'Sub' $P2484 = "166_1298845494.89" 
    capture_lex $P2484
    get_global $P2482, "$?CLASS"
    .return ()
.end


.namespace ["int"]
.sub "" :load :init :subid("post415") :outer("165_1298845494.89")
.annotate 'line', 1050
    get_hll_global $P2481, ["int"], "_block2480" 
    .local pmc block
    set block, $P2481
    .const 'Sub' $P2484 = "166_1298845494.89" 
    capture_lex $P2484
    $P2484()
.end


.namespace ["int"]
.sub "_block2483"  :anon :subid("166_1298845494.89") :outer("165_1298845494.89")
.annotate 'line', 1050
    get_hll_global $P2485, "NQPNativeHOW"
    $P2486 = $P2485."new_type"("int" :named("name"), "P6int" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2486
    set_hll_global "int", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2487, type_obj
    $P2488 = $P2487."compose"(type_obj)
    .return ($P2488)
.end


.namespace ["num"]
.sub "_block2489"  :subid("167_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 1052
    .const 'Sub' $P2493 = "168_1298845494.89" 
    capture_lex $P2493
    get_global $P2491, "$?CLASS"
    .return ()
.end


.namespace ["num"]
.sub "" :load :init :subid("post416") :outer("167_1298845494.89")
.annotate 'line', 1052
    get_hll_global $P2490, ["num"], "_block2489" 
    .local pmc block
    set block, $P2490
    .const 'Sub' $P2493 = "168_1298845494.89" 
    capture_lex $P2493
    $P2493()
.end


.namespace ["num"]
.sub "_block2492"  :anon :subid("168_1298845494.89") :outer("167_1298845494.89")
.annotate 'line', 1052
    get_hll_global $P2494, "NQPNativeHOW"
    $P2495 = $P2494."new_type"("num" :named("name"), "P6num" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2495
    set_hll_global "num", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2496, type_obj
    $P2497 = $P2496."compose"(type_obj)
    .return ($P2497)
.end


.namespace ["str"]
.sub "_block2498"  :subid("169_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 1054
    .const 'Sub' $P2502 = "170_1298845494.89" 
    capture_lex $P2502
    get_global $P2500, "$?CLASS"
    .return ()
.end


.namespace ["str"]
.sub "" :load :init :subid("post417") :outer("169_1298845494.89")
.annotate 'line', 1054
    get_hll_global $P2499, ["str"], "_block2498" 
    .local pmc block
    set block, $P2499
    .const 'Sub' $P2502 = "170_1298845494.89" 
    capture_lex $P2502
    $P2502()
.end


.namespace ["str"]
.sub "_block2501"  :anon :subid("170_1298845494.89") :outer("169_1298845494.89")
.annotate 'line', 1054
    get_hll_global $P2503, "NQPNativeHOW"
    $P2504 = $P2503."new_type"("str" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2504
    set_hll_global "str", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2505, type_obj
    $P2506 = $P2505."compose"(type_obj)
    .return ($P2506)
.end


.namespace ["NQPMu"]
.sub "_block2507"  :subid("171_1298845494.89") :outer("10_1298845494.89")
.annotate 'line', 1057
    .const 'Sub' $P2629 = "184_1298845494.89" 
    capture_lex $P2629
    .const 'Sub' $P2619 = "183_1298845494.89" 
    capture_lex $P2619
    .const 'Sub' $P2607 = "182_1298845494.89" 
    capture_lex $P2607
    .const 'Sub' $P2603 = "181_1298845494.89" 
    capture_lex $P2603
    .const 'Sub' $P2592 = "180_1298845494.89" 
    capture_lex $P2592
    .const 'Sub' $P2589 = "179_1298845494.89" 
    capture_lex $P2589
    .const 'Sub' $P2583 = "178_1298845494.89" 
    capture_lex $P2583
    .const 'Sub' $P2545 = "176_1298845494.89" 
    capture_lex $P2545
    .const 'Sub' $P2524 = "174_1298845494.89" 
    capture_lex $P2524
    .const 'Sub' $P2514 = "173_1298845494.89" 
    capture_lex $P2514
    .const 'Sub' $P2510 = "172_1298845494.89" 
    capture_lex $P2510
    get_global $P2509, "$?CLASS"
.annotate 'line', 1099
    .const 'Sub' $P2619 = "183_1298845494.89" 
    newclosure $P2627, $P2619
.annotate 'line', 1057
    .return ($P2627)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post418") :outer("171_1298845494.89")
.annotate 'line', 1057
    get_hll_global $P2508, ["NQPMu"], "_block2507" 
    .local pmc block
    set block, $P2508
    .const 'Sub' $P2629 = "184_1298845494.89" 
    capture_lex $P2629
    $P2629()
.end


.namespace ["NQPMu"]
.sub "_block2628"  :anon :subid("184_1298845494.89") :outer("171_1298845494.89")
.annotate 'line', 1057
    .const 'Sub' $P2646 = "179_1298845494.89" 
    capture_lex $P2646
    get_hll_global $P2630, "NQPClassHOW"
    $P2631 = $P2630."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P2631
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2632, type_obj
    .const 'Sub' $P2633 = "172_1298845494.89" 
    $P2632."add_method"(type_obj, "CREATE", $P2633)
    get_how $P2634, type_obj
    .const 'Sub' $P2635 = "173_1298845494.89" 
    $P2634."add_method"(type_obj, "bless", $P2635)
    get_how $P2636, type_obj
    .const 'Sub' $P2637 = "174_1298845494.89" 
    $P2636."add_method"(type_obj, "BUILDALL", $P2637)
    get_how $P2638, type_obj
    .const 'Sub' $P2639 = "176_1298845494.89" 
    $P2638."add_method"(type_obj, "BUILD_MAGIC", $P2639)
    get_how $P2640, type_obj
    .const 'Sub' $P2641 = "178_1298845494.89" 
    $P2640."add_method"(type_obj, "new", $P2641)
    get_how $P2642, type_obj
    .const 'Sub' $P2643 = "179_1298845494.89" 
    new $P2644, "ResizablePMCArray"
    set_dispatchees $P2643, $P2644
    $P2642."add_method"(type_obj, "Str", $P2643)
    get_how $P2645, type_obj
    .const 'Sub' $P2646 = "179_1298845494.89" 
    newclosure $P2649, $P2646
    $P2645."add_parrot_vtable_mapping"(type_obj, "get_string", $P2649)
    get_how $P2650, type_obj
    .const 'Sub' $P2651 = "180_1298845494.89" 
    $P2650."add_multi_method"(type_obj, "Str", $P2651)
    get_how $P2652, type_obj
    .const 'Sub' $P2653 = "181_1298845494.89" 
    new $P2654, "ResizablePMCArray"
    set_dispatchees $P2653, $P2654
    $P2652."add_method"(type_obj, "ACCEPTS", $P2653)
    get_how $P2655, type_obj
    .const 'Sub' $P2656 = "182_1298845494.89" 
    $P2655."add_multi_method"(type_obj, "ACCEPTS", $P2656)
    get_how $P2657, type_obj
    .const 'Sub' $P2658 = "183_1298845494.89" 
    $P2657."add_method"(type_obj, "isa", $P2658)
    get_how $P2659, type_obj
    $P2660 = $P2659."compose"(type_obj)
    .return ($P2660)
.end


.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("179_1298845494.89") :outer("184_1298845494.89")
    .param pmc param_2647
.annotate 'line', 1057
    .lex "self", param_2647
    multi_dispatch_over_lexical_candidates $P2648
    .return ($P2648)
.end


.namespace ["NQPMu"]
.sub "CREATE"  :subid("172_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2511
.annotate 'line', 1058
    .lex "self", param_2511
.annotate 'line', 1059
    find_lex $P2512, "self"
    repr_instance_of $P2513, $P2512
.annotate 'line', 1058
    .return ($P2513)
.end


.namespace ["NQPMu"]
.sub "bless"  :subid("173_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2515
    .param pmc param_2517 :slurpy :named
.annotate 'line', 1063
    .lex "$self", param_2515
    find_lex $P2516, "$self"
    .lex "self", $P2516
    .lex "%attributes", param_2517
.annotate 'line', 1064
    new $P2518, "Undef"
    .lex "$instance", $P2518
    find_lex $P2519, "self"
    $P2520 = $P2519."CREATE"()
    store_lex "$instance", $P2520
.annotate 'line', 1065
    find_lex $P2521, "$instance"
    find_lex $P2522, "%attributes"
    $P2521."BUILDALL"($P2522 :flat)
    find_lex $P2523, "$instance"
.annotate 'line', 1063
    .return ($P2523)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILDALL"  :subid("174_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2525
    .param pmc param_2527 :slurpy :named
.annotate 'line', 1069
    .const 'Sub' $P2536 = "175_1298845494.89" 
    capture_lex $P2536
    .lex "$self", param_2525
    find_lex $P2526, "$self"
    .lex "self", $P2526
    .lex "%attributes", param_2527
.annotate 'line', 1070
    find_lex $P2529, "$self"
    get_how $P2530, $P2529
    find_lex $P2531, "$self"
    $P2532 = $P2530."parents"($P2531)
    defined $I2533, $P2532
    unless $I2533, for_undef_419
    iter $P2528, $P2532
    new $P2543, 'ExceptionHandler'
    set_label $P2543, loop2542_handler
    $P2543."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2543
  loop2542_test:
    unless $P2528, loop2542_done
    shift $P2534, $P2528
  loop2542_redo:
    .const 'Sub' $P2536 = "175_1298845494.89" 
    capture_lex $P2536
    $P2536($P2534)
  loop2542_next:
    goto loop2542_test
  loop2542_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2544, exception, 'type'
    eq $P2544, .CONTROL_LOOP_NEXT, loop2542_next
    eq $P2544, .CONTROL_LOOP_REDO, loop2542_redo
  loop2542_done:
    pop_eh 
  for_undef_419:
.annotate 'line', 1069
    .return ($P2528)
.end


.namespace ["NQPMu"]
.sub "_block2535"  :anon :subid("175_1298845494.89") :outer("174_1298845494.89")
    .param pmc param_2537
.annotate 'line', 1070
    .lex "$class", param_2537
.annotate 'line', 1071
    find_lex $P2538, "$self"
    find_lex $P2539, "$class"
    find_lex $P2540, "%attributes"
    $P2541 = $P2538."BUILD_MAGIC"($P2539, $P2540 :flat)
.annotate 'line', 1070
    .return ($P2541)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILD_MAGIC"  :subid("176_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2546
    .param pmc param_2548
    .param pmc param_2549 :slurpy :named
.annotate 'line', 1075
    .const 'Sub' $P2558 = "177_1298845494.89" 
    capture_lex $P2558
    .lex "$self", param_2546
    find_lex $P2547, "$self"
    .lex "self", $P2547
    .lex "$type", param_2548
    .lex "%attributes", param_2549
.annotate 'line', 1076
    find_lex $P2551, "$type"
    get_how $P2552, $P2551
    find_lex $P2553, "$type"
    $P2554 = $P2552."attributes"($P2553, 1 :named("local"))
    defined $I2555, $P2554
    unless $I2555, for_undef_420
    iter $P2550, $P2554
    new $P2581, 'ExceptionHandler'
    set_label $P2581, loop2580_handler
    $P2581."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2581
  loop2580_test:
    unless $P2550, loop2580_done
    shift $P2556, $P2550
  loop2580_redo:
    .const 'Sub' $P2558 = "177_1298845494.89" 
    capture_lex $P2558
    $P2558($P2556)
  loop2580_next:
    goto loop2580_test
  loop2580_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2582, exception, 'type'
    eq $P2582, .CONTROL_LOOP_NEXT, loop2580_next
    eq $P2582, .CONTROL_LOOP_REDO, loop2580_redo
  loop2580_done:
    pop_eh 
  for_undef_420:
.annotate 'line', 1075
    .return ($P2550)
.end


.namespace ["NQPMu"]
.sub "_block2557"  :anon :subid("177_1298845494.89") :outer("176_1298845494.89")
    .param pmc param_2561
.annotate 'line', 1077
    new $P2559, "Undef"
    .lex "$name", $P2559
.annotate 'line', 1078
    new $P2560, "Undef"
    .lex "$shortname", $P2560
    .lex "$_", param_2561
.annotate 'line', 1077
    find_lex $P2562, "$_"
    $P2563 = $P2562."name"()
    store_lex "$name", $P2563
.annotate 'line', 1078
    find_lex $P2564, "$name"
    set $S2565, $P2564
    substr $S2566, $S2565, 2
    new $P2567, 'String'
    set $P2567, $S2566
    store_lex "$shortname", $P2567
.annotate 'line', 1079
    find_lex $P2571, "$shortname"
    find_lex $P2570, "%attributes"
    exists $I2572, $P2570[$P2571]
    if $I2572, if_2569
    new $P2568, 'Integer'
    set $P2568, $I2572
    goto if_2569_end
  if_2569:
.annotate 'line', 1080
    find_lex $P2573, "$self"
    find_lex $P2574, "$type"
    find_lex $P2575, "$name"
    set $S2576, $P2575
    find_lex $P2577, "$shortname"
    find_lex $P2578, "%attributes"
    unless_null $P2578, vivify_421
    $P2578 = root_new ['parrot';'Hash']
  vivify_421:
    set $P2579, $P2578[$P2577]
    unless_null $P2579, vivify_422
    new $P2579, "Undef"
  vivify_422:
    setattribute $P2573, $P2574, $S2576, $P2579
  if_2569_end:
.annotate 'line', 1076
    .return ($P2568)
.end


.namespace ["NQPMu"]
.sub "new"  :subid("178_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2584
    .param pmc param_2585 :slurpy :named
.annotate 'line', 1085
    .lex "self", param_2584
    .lex "%attributes", param_2585
.annotate 'line', 1086
    find_lex $P2586, "self"
    find_lex $P2587, "%attributes"
    $P2588 = $P2586."bless"($P2587 :flat)
.annotate 'line', 1085
    .return ($P2588)
.end


.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("179_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2590
.annotate 'line', 1085
    .lex "self", param_2590
    multi_dispatch_over_lexical_candidates $P2591
    .return ($P2591)
.end


.namespace ["NQPMu"]
.sub "Str"  :subid("180_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2593
.annotate 'line', 1090
    .lex "$self", param_2593
    find_lex $P2594, "$self"
    .lex "self", $P2594
.annotate 'line', 1091
    find_lex $P2595, "self"
    get_how $P2596, $P2595
    find_lex $P2597, "self"
    $P2598 = $P2596."name"($P2597)
    concat $P2599, $P2598, "()"
.annotate 'line', 1090
    .return ($P2599)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post423") :outer("180_1298845494.89")
.annotate 'line', 1090
    .const 'Sub' $P2592 = "180_1298845494.89" 
    .local pmc block
    set block, $P2592
    get_hll_global $P2600, "Mu"
    new $P2601, "ResizablePMCArray"
    push $P2601, $P2600
    new $P2602, "ResizablePMCArray"
    push $P2602, 2
    set_sub_multisig block, $P2601, $P2602
.end


.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("181_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2604
    .param pmc param_2605
.annotate 'line', 1090
    .lex "self", param_2604
.annotate 'line', 1094
    .lex "$topic", param_2605
.annotate 'line', 1090
    multi_dispatch_over_lexical_candidates $P2606
    .return ($P2606)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS"  :subid("182_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2608
    .param pmc param_2610
.annotate 'line', 1095
    .lex "$self", param_2608
    find_lex $P2609, "$self"
    .lex "self", $P2609
    .lex "$topic", param_2610
.annotate 'line', 1096
    find_lex $P2611, "$topic"
    find_lex $P2612, "self"
    get_what $P2613, $P2612
    type_check $I2614, $P2611, $P2613
.annotate 'line', 1095
    .return ($I2614)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post424") :outer("182_1298845494.89")
.annotate 'line', 1095
    .const 'Sub' $P2607 = "182_1298845494.89" 
    .local pmc block
    set block, $P2607
    get_hll_global $P2615, "NQPMu"
    null $P2616
    new $P2617, "ResizablePMCArray"
    push $P2617, $P2615
    push $P2617, $P2616
    new $P2618, "ResizablePMCArray"
    push $P2618, 2
    push $P2618, 0
    set_sub_multisig block, $P2617, $P2618
.end


.namespace ["NQPMu"]
.sub "isa"  :subid("183_1298845494.89") :outer("171_1298845494.89")
    .param pmc param_2620
    .param pmc param_2621
.annotate 'line', 1099
    .lex "self", param_2620
    .lex "$type", param_2621
.annotate 'line', 1100
    find_lex $P2622, "self"
    get_how $P2623, $P2622
    find_lex $P2624, "self"
    find_lex $P2625, "$type"
    $P2626 = $P2623."isa"($P2624, $P2625)
.annotate 'line', 1099
    .return ($P2626)
.end


.namespace []
.sub "_block2662" :load :anon :subid("185_1298845494.89")
.annotate 'line', 1
    .const 'Sub' $P2664 = "10_1298845494.89" 
    $P2665 = $P2664()
    .return ($P2665)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
.end

### .include 'gen/nqp-grammar.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298845521.609")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
    $P2430 = $P15()
.annotate 'line', 1
    .return ($P2430)
    .const 'Sub' $P2432 = "402_1298845521.609" 
    .return ($P2432)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block14"  :subid("11_1298845521.609") :outer("10_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P1715 = "401_1298845521.609" 
    capture_lex $P1715
    get_hll_global $P1606, ["NQP";"Regex"], "_block1605" 
    capture_lex $P1606
    .const 'Sub' $P1594 = "377_1298845521.609" 
    capture_lex $P1594
    .const 'Sub' $P1588 = "375_1298845521.609" 
    capture_lex $P1588
    .const 'Sub' $P1582 = "373_1298845521.609" 
    capture_lex $P1582
    .const 'Sub' $P1576 = "371_1298845521.609" 
    capture_lex $P1576
    .const 'Sub' $P1570 = "369_1298845521.609" 
    capture_lex $P1570
    .const 'Sub' $P1558 = "366_1298845521.609" 
    capture_lex $P1558
    .const 'Sub' $P1551 = "364_1298845521.609" 
    capture_lex $P1551
    .const 'Sub' $P1544 = "362_1298845521.609" 
    capture_lex $P1544
    .const 'Sub' $P1537 = "360_1298845521.609" 
    capture_lex $P1537
    .const 'Sub' $P1530 = "358_1298845521.609" 
    capture_lex $P1530
    .const 'Sub' $P1524 = "356_1298845521.609" 
    capture_lex $P1524
    .const 'Sub' $P1517 = "354_1298845521.609" 
    capture_lex $P1517
    .const 'Sub' $P1510 = "352_1298845521.609" 
    capture_lex $P1510
    .const 'Sub' $P1503 = "350_1298845521.609" 
    capture_lex $P1503
    .const 'Sub' $P1496 = "348_1298845521.609" 
    capture_lex $P1496
    .const 'Sub' $P1489 = "346_1298845521.609" 
    capture_lex $P1489
    .const 'Sub' $P1482 = "344_1298845521.609" 
    capture_lex $P1482
    .const 'Sub' $P1475 = "342_1298845521.609" 
    capture_lex $P1475
    .const 'Sub' $P1468 = "340_1298845521.609" 
    capture_lex $P1468
    .const 'Sub' $P1461 = "338_1298845521.609" 
    capture_lex $P1461
    .const 'Sub' $P1454 = "336_1298845521.609" 
    capture_lex $P1454
    .const 'Sub' $P1447 = "334_1298845521.609" 
    capture_lex $P1447
    .const 'Sub' $P1440 = "332_1298845521.609" 
    capture_lex $P1440
    .const 'Sub' $P1433 = "330_1298845521.609" 
    capture_lex $P1433
    .const 'Sub' $P1426 = "328_1298845521.609" 
    capture_lex $P1426
    .const 'Sub' $P1419 = "326_1298845521.609" 
    capture_lex $P1419
    .const 'Sub' $P1412 = "324_1298845521.609" 
    capture_lex $P1412
    .const 'Sub' $P1405 = "322_1298845521.609" 
    capture_lex $P1405
    .const 'Sub' $P1398 = "320_1298845521.609" 
    capture_lex $P1398
    .const 'Sub' $P1391 = "318_1298845521.609" 
    capture_lex $P1391
    .const 'Sub' $P1384 = "316_1298845521.609" 
    capture_lex $P1384
    .const 'Sub' $P1377 = "314_1298845521.609" 
    capture_lex $P1377
    .const 'Sub' $P1370 = "312_1298845521.609" 
    capture_lex $P1370
    .const 'Sub' $P1363 = "310_1298845521.609" 
    capture_lex $P1363
    .const 'Sub' $P1356 = "308_1298845521.609" 
    capture_lex $P1356
    .const 'Sub' $P1349 = "306_1298845521.609" 
    capture_lex $P1349
    .const 'Sub' $P1342 = "304_1298845521.609" 
    capture_lex $P1342
    .const 'Sub' $P1335 = "302_1298845521.609" 
    capture_lex $P1335
    .const 'Sub' $P1328 = "300_1298845521.609" 
    capture_lex $P1328
    .const 'Sub' $P1321 = "298_1298845521.609" 
    capture_lex $P1321
    .const 'Sub' $P1315 = "296_1298845521.609" 
    capture_lex $P1315
    .const 'Sub' $P1308 = "294_1298845521.609" 
    capture_lex $P1308
    .const 'Sub' $P1301 = "292_1298845521.609" 
    capture_lex $P1301
    .const 'Sub' $P1294 = "290_1298845521.609" 
    capture_lex $P1294
    .const 'Sub' $P1287 = "288_1298845521.609" 
    capture_lex $P1287
    .const 'Sub' $P1280 = "286_1298845521.609" 
    capture_lex $P1280
    .const 'Sub' $P1273 = "284_1298845521.609" 
    capture_lex $P1273
    .const 'Sub' $P1266 = "282_1298845521.609" 
    capture_lex $P1266
    .const 'Sub' $P1260 = "280_1298845521.609" 
    capture_lex $P1260
    .const 'Sub' $P1254 = "278_1298845521.609" 
    capture_lex $P1254
    .const 'Sub' $P1249 = "276_1298845521.609" 
    capture_lex $P1249
    .const 'Sub' $P1243 = "274_1298845521.609" 
    capture_lex $P1243
    .const 'Sub' $P1237 = "272_1298845521.609" 
    capture_lex $P1237
    .const 'Sub' $P1232 = "270_1298845521.609" 
    capture_lex $P1232
    .const 'Sub' $P1227 = "268_1298845521.609" 
    capture_lex $P1227
    .const 'Sub' $P1211 = "267_1298845521.609" 
    capture_lex $P1211
    .const 'Sub' $P1202 = "265_1298845521.609" 
    capture_lex $P1202
    .const 'Sub' $P1193 = "263_1298845521.609" 
    capture_lex $P1193
    .const 'Sub' $P1188 = "261_1298845521.609" 
    capture_lex $P1188
    .const 'Sub' $P1183 = "259_1298845521.609" 
    capture_lex $P1183
    .const 'Sub' $P1178 = "257_1298845521.609" 
    capture_lex $P1178
    .const 'Sub' $P1170 = "255_1298845521.609" 
    capture_lex $P1170
    .const 'Sub' $P1162 = "253_1298845521.609" 
    capture_lex $P1162
    .const 'Sub' $P1157 = "251_1298845521.609" 
    capture_lex $P1157
    .const 'Sub' $P1152 = "249_1298845521.609" 
    capture_lex $P1152
    .const 'Sub' $P1147 = "247_1298845521.609" 
    capture_lex $P1147
    .const 'Sub' $P1141 = "245_1298845521.609" 
    capture_lex $P1141
    .const 'Sub' $P1135 = "243_1298845521.609" 
    capture_lex $P1135
    .const 'Sub' $P1129 = "241_1298845521.609" 
    capture_lex $P1129
    .const 'Sub' $P1123 = "239_1298845521.609" 
    capture_lex $P1123
    .const 'Sub' $P1117 = "237_1298845521.609" 
    capture_lex $P1117
    .const 'Sub' $P1112 = "235_1298845521.609" 
    capture_lex $P1112
    .const 'Sub' $P1107 = "233_1298845521.609" 
    capture_lex $P1107
    .const 'Sub' $P1093 = "229_1298845521.609" 
    capture_lex $P1093
    .const 'Sub' $P1085 = "227_1298845521.609" 
    capture_lex $P1085
    .const 'Sub' $P1079 = "225_1298845521.609" 
    capture_lex $P1079
    .const 'Sub' $P1072 = "223_1298845521.609" 
    capture_lex $P1072
    .const 'Sub' $P1066 = "221_1298845521.609" 
    capture_lex $P1066
    .const 'Sub' $P1052 = "218_1298845521.609" 
    capture_lex $P1052
    .const 'Sub' $P1044 = "216_1298845521.609" 
    capture_lex $P1044
    .const 'Sub' $P1036 = "214_1298845521.609" 
    capture_lex $P1036
    .const 'Sub' $P1030 = "212_1298845521.609" 
    capture_lex $P1030
    .const 'Sub' $P1024 = "210_1298845521.609" 
    capture_lex $P1024
    .const 'Sub' $P1008 = "206_1298845521.609" 
    capture_lex $P1008
    .const 'Sub' $P967 = "204_1298845521.609" 
    capture_lex $P967
    .const 'Sub' $P956 = "202_1298845521.609" 
    capture_lex $P956
    .const 'Sub' $P942 = "198_1298845521.609" 
    capture_lex $P942
    .const 'Sub' $P933 = "196_1298845521.609" 
    capture_lex $P933
    .const 'Sub' $P927 = "194_1298845521.609" 
    capture_lex $P927
    .const 'Sub' $P917 = "192_1298845521.609" 
    capture_lex $P917
    .const 'Sub' $P902 = "190_1298845521.609" 
    capture_lex $P902
    .const 'Sub' $P888 = "187_1298845521.609" 
    capture_lex $P888
    .const 'Sub' $P880 = "185_1298845521.609" 
    capture_lex $P880
    .const 'Sub' $P870 = "183_1298845521.609" 
    capture_lex $P870
    .const 'Sub' $P860 = "181_1298845521.609" 
    capture_lex $P860
    .const 'Sub' $P841 = "176_1298845521.609" 
    capture_lex $P841
    .const 'Sub' $P797 = "173_1298845521.609" 
    capture_lex $P797
    .const 'Sub' $P763 = "171_1298845521.609" 
    capture_lex $P763
    .const 'Sub' $P756 = "169_1298845521.609" 
    capture_lex $P756
    .const 'Sub' $P749 = "167_1298845521.609" 
    capture_lex $P749
    .const 'Sub' $P732 = "163_1298845521.609" 
    capture_lex $P732
    .const 'Sub' $P724 = "161_1298845521.609" 
    capture_lex $P724
    .const 'Sub' $P718 = "159_1298845521.609" 
    capture_lex $P718
    .const 'Sub' $P705 = "157_1298845521.609" 
    capture_lex $P705
    .const 'Sub' $P698 = "155_1298845521.609" 
    capture_lex $P698
    .const 'Sub' $P691 = "153_1298845521.609" 
    capture_lex $P691
    .const 'Sub' $P684 = "151_1298845521.609" 
    capture_lex $P684
    .const 'Sub' $P643 = "147_1298845521.609" 
    capture_lex $P643
    .const 'Sub' $P631 = "145_1298845521.609" 
    capture_lex $P631
    .const 'Sub' $P619 = "143_1298845521.609" 
    capture_lex $P619
    .const 'Sub' $P607 = "141_1298845521.609" 
    capture_lex $P607
    .const 'Sub' $P595 = "139_1298845521.609" 
    capture_lex $P595
    .const 'Sub' $P583 = "137_1298845521.609" 
    capture_lex $P583
    .const 'Sub' $P571 = "135_1298845521.609" 
    capture_lex $P571
    .const 'Sub' $P560 = "131_1298845521.609" 
    capture_lex $P560
    .const 'Sub' $P555 = "129_1298845521.609" 
    capture_lex $P555
    .const 'Sub' $P543 = "127_1298845521.609" 
    capture_lex $P543
    .const 'Sub' $P531 = "125_1298845521.609" 
    capture_lex $P531
    .const 'Sub' $P524 = "123_1298845521.609" 
    capture_lex $P524
    .const 'Sub' $P519 = "121_1298845521.609" 
    capture_lex $P519
    .const 'Sub' $P513 = "119_1298845521.609" 
    capture_lex $P513
    .const 'Sub' $P507 = "117_1298845521.609" 
    capture_lex $P507
    .const 'Sub' $P492 = "113_1298845521.609" 
    capture_lex $P492
    .const 'Sub' $P486 = "111_1298845521.609" 
    capture_lex $P486
    .const 'Sub' $P480 = "109_1298845521.609" 
    capture_lex $P480
    .const 'Sub' $P474 = "107_1298845521.609" 
    capture_lex $P474
    .const 'Sub' $P468 = "105_1298845521.609" 
    capture_lex $P468
    .const 'Sub' $P462 = "103_1298845521.609" 
    capture_lex $P462
    .const 'Sub' $P456 = "101_1298845521.609" 
    capture_lex $P456
    .const 'Sub' $P447 = "99_1298845521.609" 
    capture_lex $P447
    .const 'Sub' $P438 = "97_1298845521.609" 
    capture_lex $P438
    .const 'Sub' $P429 = "95_1298845521.609" 
    capture_lex $P429
    .const 'Sub' $P414 = "91_1298845521.609" 
    capture_lex $P414
    .const 'Sub' $P405 = "89_1298845521.609" 
    capture_lex $P405
    .const 'Sub' $P393 = "85_1298845521.609" 
    capture_lex $P393
    .const 'Sub' $P386 = "83_1298845521.609" 
    capture_lex $P386
    .const 'Sub' $P379 = "81_1298845521.609" 
    capture_lex $P379
    .const 'Sub' $P365 = "77_1298845521.609" 
    capture_lex $P365
    .const 'Sub' $P357 = "75_1298845521.609" 
    capture_lex $P357
    .const 'Sub' $P349 = "73_1298845521.609" 
    capture_lex $P349
    .const 'Sub' $P329 = "71_1298845521.609" 
    capture_lex $P329
    .const 'Sub' $P320 = "69_1298845521.609" 
    capture_lex $P320
    .const 'Sub' $P302 = "66_1298845521.609" 
    capture_lex $P302
    .const 'Sub' $P284 = "64_1298845521.609" 
    capture_lex $P284
    .const 'Sub' $P273 = "60_1298845521.609" 
    capture_lex $P273
    .const 'Sub' $P268 = "58_1298845521.609" 
    capture_lex $P268
    .const 'Sub' $P257 = "54_1298845521.609" 
    capture_lex $P257
    .const 'Sub' $P252 = "52_1298845521.609" 
    capture_lex $P252
    .const 'Sub' $P247 = "50_1298845521.609" 
    capture_lex $P247
    .const 'Sub' $P242 = "48_1298845521.609" 
    capture_lex $P242
    .const 'Sub' $P232 = "46_1298845521.609" 
    capture_lex $P232
    .const 'Sub' $P225 = "44_1298845521.609" 
    capture_lex $P225
    .const 'Sub' $P219 = "42_1298845521.609" 
    capture_lex $P219
    .const 'Sub' $P211 = "40_1298845521.609" 
    capture_lex $P211
    .const 'Sub' $P205 = "38_1298845521.609" 
    capture_lex $P205
    .const 'Sub' $P199 = "36_1298845521.609" 
    capture_lex $P199
    .const 'Sub' $P184 = "33_1298845521.609" 
    capture_lex $P184
    .const 'Sub' $P170 = "31_1298845521.609" 
    capture_lex $P170
    .const 'Sub' $P161 = "29_1298845521.609" 
    capture_lex $P161
    .const 'Sub' $P122 = "26_1298845521.609" 
    capture_lex $P122
    .const 'Sub' $P107 = "23_1298845521.609" 
    capture_lex $P107
    .const 'Sub' $P96 = "21_1298845521.609" 
    capture_lex $P96
    .const 'Sub' $P84 = "19_1298845521.609" 
    capture_lex $P84
    .const 'Sub' $P76 = "17_1298845521.609" 
    capture_lex $P76
    .const 'Sub' $P69 = "15_1298845521.609" 
    capture_lex $P69
    .const 'Sub' $P62 = "13_1298845521.609" 
    capture_lex $P62
    .const 'Sub' $P18 = "12_1298845521.609" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1211 = "267_1298845521.609" 
    capture_lex $P1211
    $P1211()
.annotate 'line', 663
    get_hll_global $P1606, ["NQP";"Regex"], "_block1605" 
    capture_lex $P1606
    $P1709 = $P1606()
.annotate 'line', 4
    .return ($P1709)
    .const 'Sub' $P1711 = "400_1298845521.609" 
    .return ($P1711)
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post403") :outer("11_1298845521.609")
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P1715 = "401_1298845521.609" 
    capture_lex $P1715
    $P1715()
.end


.namespace ["NQP";"Grammar"]
.sub "_block1714"  :anon :subid("401_1298845521.609") :outer("11_1298845521.609")
.annotate 'line', 4
    get_hll_global $P1716, "NQPClassHOW"
    $P1717 = $P1716."new_type"("Grammar" :named("name"))
    .local pmc type_obj
    set type_obj, $P1717
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1718, type_obj
    .const 'Sub' $P1719 = "12_1298845521.609" 
    $P1718."add_method"(type_obj, "TOP", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "13_1298845521.609" 
    $P1720."add_method"(type_obj, "identifier", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__identifier"
    $P1722."add_method"(type_obj, "!PREFIX__identifier", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "15_1298845521.609" 
    $P1724."add_method"(type_obj, "name", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__name"
    $P1726."add_method"(type_obj, "!PREFIX__name", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "17_1298845521.609" 
    $P1728."add_method"(type_obj, "deflongname", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__deflongname"
    $P1730."add_method"(type_obj, "!PREFIX__deflongname", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "19_1298845521.609" 
    $P1732."add_method"(type_obj, "ENDSTMT", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__ENDSTMT"
    $P1734."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "21_1298845521.609" 
    $P1736."add_method"(type_obj, "ws", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__ws"
    $P1738."add_method"(type_obj, "!PREFIX__ws", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "23_1298845521.609" 
    $P1740."add_method"(type_obj, "unv", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__unv"
    $P1742."add_method"(type_obj, "!PREFIX__unv", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "26_1298845521.609" 
    $P1744."add_method"(type_obj, "pod_comment", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__pod_comment"
    $P1746."add_method"(type_obj, "!PREFIX__pod_comment", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "29_1298845521.609" 
    $P1748."add_method"(type_obj, "comp_unit", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__comp_unit"
    $P1750."add_method"(type_obj, "!PREFIX__comp_unit", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "31_1298845521.609" 
    $P1752."add_method"(type_obj, "statementlist", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__statementlist"
    $P1754."add_method"(type_obj, "!PREFIX__statementlist", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "33_1298845521.609" 
    $P1756."add_method"(type_obj, "statement", $P1757)
    get_how $P1758, type_obj
    get_global $P1759, "!PREFIX__statement"
    $P1758."add_method"(type_obj, "!PREFIX__statement", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "36_1298845521.609" 
    $P1760."add_method"(type_obj, "eat_terminator", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__eat_terminator"
    $P1762."add_method"(type_obj, "!PREFIX__eat_terminator", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "38_1298845521.609" 
    $P1764."add_method"(type_obj, "xblock", $P1765)
    get_how $P1766, type_obj
    get_global $P1767, "!PREFIX__xblock"
    $P1766."add_method"(type_obj, "!PREFIX__xblock", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "40_1298845521.609" 
    $P1768."add_method"(type_obj, "pblock", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__pblock"
    $P1770."add_method"(type_obj, "!PREFIX__pblock", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "42_1298845521.609" 
    $P1772."add_method"(type_obj, "lambda", $P1773)
    get_how $P1774, type_obj
    get_global $P1775, "!PREFIX__lambda"
    $P1774."add_method"(type_obj, "!PREFIX__lambda", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "44_1298845521.609" 
    $P1776."add_method"(type_obj, "block", $P1777)
    get_how $P1778, type_obj
    get_global $P1779, "!PREFIX__block"
    $P1778."add_method"(type_obj, "!PREFIX__block", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "46_1298845521.609" 
    $P1780."add_method"(type_obj, "blockoid", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__blockoid"
    $P1782."add_method"(type_obj, "!PREFIX__blockoid", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "48_1298845521.609" 
    $P1784."add_method"(type_obj, "newpad", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__newpad"
    $P1786."add_method"(type_obj, "!PREFIX__newpad", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "50_1298845521.609" 
    $P1788."add_method"(type_obj, "outerctx", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__outerctx"
    $P1790."add_method"(type_obj, "!PREFIX__outerctx", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "52_1298845521.609" 
    $P1792."add_method"(type_obj, "finishpad", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__finishpad"
    $P1794."add_method"(type_obj, "!PREFIX__finishpad", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "54_1298845521.609" 
    $P1796."add_method"(type_obj, "you_are_here", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__you_are_here"
    $P1798."add_method"(type_obj, "!PREFIX__you_are_here", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "56_1298845521.609" 
    $P1800."add_method"(type_obj, "terminator", $P1801)
    get_how $P1802, type_obj
    .const 'Sub' $P1803 = "57_1298845521.609" 
    $P1802."add_method"(type_obj, "!PREFIX__terminator", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "58_1298845521.609" 
    $P1804."add_method"(type_obj, "terminator:sym<;>", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__terminator:sym<;>"
    $P1806."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "60_1298845521.609" 
    $P1808."add_method"(type_obj, "terminator:sym<}>", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__terminator:sym<}>"
    $P1810."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "62_1298845521.609" 
    $P1812."add_method"(type_obj, "statement_control", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "63_1298845521.609" 
    $P1814."add_method"(type_obj, "!PREFIX__statement_control", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "64_1298845521.609" 
    $P1816."add_method"(type_obj, "statement_control:sym<if>", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__statement_control:sym<if>"
    $P1818."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "66_1298845521.609" 
    $P1820."add_method"(type_obj, "statement_control:sym<unless>", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__statement_control:sym<unless>"
    $P1822."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "69_1298845521.609" 
    $P1824."add_method"(type_obj, "statement_control:sym<while>", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__statement_control:sym<while>"
    $P1826."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "71_1298845521.609" 
    $P1828."add_method"(type_obj, "statement_control:sym<repeat>", $P1829)
    get_how $P1830, type_obj
    get_global $P1831, "!PREFIX__statement_control:sym<repeat>"
    $P1830."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "73_1298845521.609" 
    $P1832."add_method"(type_obj, "statement_control:sym<for>", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__statement_control:sym<for>"
    $P1834."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "75_1298845521.609" 
    $P1836."add_method"(type_obj, "statement_control:sym<CATCH>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__statement_control:sym<CATCH>"
    $P1838."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "77_1298845521.609" 
    $P1840."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1841)
    get_how $P1842, type_obj
    get_global $P1843, "!PREFIX__statement_control:sym<CONTROL>"
    $P1842."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "79_1298845521.609" 
    $P1844."add_method"(type_obj, "statement_prefix", $P1845)
    get_how $P1846, type_obj
    .const 'Sub' $P1847 = "80_1298845521.609" 
    $P1846."add_method"(type_obj, "!PREFIX__statement_prefix", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "81_1298845521.609" 
    $P1848."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__statement_prefix:sym<INIT>"
    $P1850."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "83_1298845521.609" 
    $P1852."add_method"(type_obj, "statement_prefix:sym<try>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__statement_prefix:sym<try>"
    $P1854."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "85_1298845521.609" 
    $P1856."add_method"(type_obj, "blorst", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__blorst"
    $P1858."add_method"(type_obj, "!PREFIX__blorst", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "87_1298845521.609" 
    $P1860."add_method"(type_obj, "statement_mod_cond", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "88_1298845521.609" 
    $P1862."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "89_1298845521.609" 
    $P1864."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__statement_mod_cond:sym<if>"
    $P1866."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "91_1298845521.609" 
    $P1868."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1870."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "93_1298845521.609" 
    $P1872."add_method"(type_obj, "statement_mod_loop", $P1873)
    get_how $P1874, type_obj
    .const 'Sub' $P1875 = "94_1298845521.609" 
    $P1874."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "95_1298845521.609" 
    $P1876."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__statement_mod_loop:sym<while>"
    $P1878."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "97_1298845521.609" 
    $P1880."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__statement_mod_loop:sym<until>"
    $P1882."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "99_1298845521.609" 
    $P1884."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__statement_mod_loop:sym<for>"
    $P1886."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "101_1298845521.609" 
    $P1888."add_method"(type_obj, "term:sym<fatarrow>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__term:sym<fatarrow>"
    $P1890."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "103_1298845521.609" 
    $P1892."add_method"(type_obj, "term:sym<colonpair>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__term:sym<colonpair>"
    $P1894."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "105_1298845521.609" 
    $P1896."add_method"(type_obj, "term:sym<variable>", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__term:sym<variable>"
    $P1898."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "107_1298845521.609" 
    $P1900."add_method"(type_obj, "term:sym<package_declarator>", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__term:sym<package_declarator>"
    $P1902."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "109_1298845521.609" 
    $P1904."add_method"(type_obj, "term:sym<scope_declarator>", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__term:sym<scope_declarator>"
    $P1906."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "111_1298845521.609" 
    $P1908."add_method"(type_obj, "term:sym<routine_declarator>", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__term:sym<routine_declarator>"
    $P1910."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "113_1298845521.609" 
    $P1912."add_method"(type_obj, "term:sym<multi_declarator>", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__term:sym<multi_declarator>"
    $P1914."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "117_1298845521.609" 
    $P1916."add_method"(type_obj, "term:sym<regex_declarator>", $P1917)
    get_how $P1918, type_obj
    get_global $P1919, "!PREFIX__term:sym<regex_declarator>"
    $P1918."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "119_1298845521.609" 
    $P1920."add_method"(type_obj, "term:sym<statement_prefix>", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__term:sym<statement_prefix>"
    $P1922."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "121_1298845521.609" 
    $P1924."add_method"(type_obj, "term:sym<lambda>", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__term:sym<lambda>"
    $P1926."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "123_1298845521.609" 
    $P1928."add_method"(type_obj, "fatarrow", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__fatarrow"
    $P1930."add_method"(type_obj, "!PREFIX__fatarrow", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "125_1298845521.609" 
    $P1932."add_method"(type_obj, "colonpair", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__colonpair"
    $P1934."add_method"(type_obj, "!PREFIX__colonpair", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "127_1298845521.609" 
    $P1936."add_method"(type_obj, "variable", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__variable"
    $P1938."add_method"(type_obj, "!PREFIX__variable", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "129_1298845521.609" 
    $P1940."add_method"(type_obj, "sigil", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__sigil"
    $P1942."add_method"(type_obj, "!PREFIX__sigil", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "131_1298845521.609" 
    $P1944."add_method"(type_obj, "twigil", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__twigil"
    $P1946."add_method"(type_obj, "!PREFIX__twigil", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "133_1298845521.609" 
    $P1948."add_method"(type_obj, "package_declarator", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "134_1298845521.609" 
    $P1950."add_method"(type_obj, "!PREFIX__package_declarator", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "135_1298845521.609" 
    $P1952."add_method"(type_obj, "package_declarator:sym<module>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__package_declarator:sym<module>"
    $P1954."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "137_1298845521.609" 
    $P1956."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__package_declarator:sym<knowhow>"
    $P1958."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "139_1298845521.609" 
    $P1960."add_method"(type_obj, "package_declarator:sym<class>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__package_declarator:sym<class>"
    $P1962."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "141_1298845521.609" 
    $P1964."add_method"(type_obj, "package_declarator:sym<grammar>", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__package_declarator:sym<grammar>"
    $P1966."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "143_1298845521.609" 
    $P1968."add_method"(type_obj, "package_declarator:sym<role>", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__package_declarator:sym<role>"
    $P1970."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "145_1298845521.609" 
    $P1972."add_method"(type_obj, "package_declarator:sym<native>", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__package_declarator:sym<native>"
    $P1974."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "147_1298845521.609" 
    $P1976."add_method"(type_obj, "package_def", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__package_def"
    $P1978."add_method"(type_obj, "!PREFIX__package_def", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "149_1298845521.609" 
    $P1980."add_method"(type_obj, "scope_declarator", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "150_1298845521.609" 
    $P1982."add_method"(type_obj, "!PREFIX__scope_declarator", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "151_1298845521.609" 
    $P1984."add_method"(type_obj, "scope_declarator:sym<my>", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__scope_declarator:sym<my>"
    $P1986."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "153_1298845521.609" 
    $P1988."add_method"(type_obj, "scope_declarator:sym<our>", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__scope_declarator:sym<our>"
    $P1990."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "155_1298845521.609" 
    $P1992."add_method"(type_obj, "scope_declarator:sym<has>", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__scope_declarator:sym<has>"
    $P1994."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "157_1298845521.609" 
    $P1996."add_method"(type_obj, "scoped", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__scoped"
    $P1998."add_method"(type_obj, "!PREFIX__scoped", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "159_1298845521.609" 
    $P2000."add_method"(type_obj, "typename", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__typename"
    $P2002."add_method"(type_obj, "!PREFIX__typename", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "161_1298845521.609" 
    $P2004."add_method"(type_obj, "declarator", $P2005)
    get_how $P2006, type_obj
    get_global $P2007, "!PREFIX__declarator"
    $P2006."add_method"(type_obj, "!PREFIX__declarator", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "163_1298845521.609" 
    $P2008."add_method"(type_obj, "variable_declarator", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__variable_declarator"
    $P2010."add_method"(type_obj, "!PREFIX__variable_declarator", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "165_1298845521.609" 
    $P2012."add_method"(type_obj, "routine_declarator", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "166_1298845521.609" 
    $P2014."add_method"(type_obj, "!PREFIX__routine_declarator", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "167_1298845521.609" 
    $P2016."add_method"(type_obj, "routine_declarator:sym<sub>", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__routine_declarator:sym<sub>"
    $P2018."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "169_1298845521.609" 
    $P2020."add_method"(type_obj, "routine_declarator:sym<method>", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__routine_declarator:sym<method>"
    $P2022."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "171_1298845521.609" 
    $P2024."add_method"(type_obj, "routine_def", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__routine_def"
    $P2026."add_method"(type_obj, "!PREFIX__routine_def", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "173_1298845521.609" 
    $P2028."add_method"(type_obj, "method_def", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__method_def"
    $P2030."add_method"(type_obj, "!PREFIX__method_def", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "176_1298845521.609" 
    $P2032."add_method"(type_obj, "onlystar", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__onlystar"
    $P2034."add_method"(type_obj, "!PREFIX__onlystar", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "179_1298845521.609" 
    $P2036."add_method"(type_obj, "multi_declarator", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "180_1298845521.609" 
    $P2038."add_method"(type_obj, "!PREFIX__multi_declarator", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "181_1298845521.609" 
    $P2040."add_method"(type_obj, "multi_declarator:sym<multi>", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__multi_declarator:sym<multi>"
    $P2042."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "183_1298845521.609" 
    $P2044."add_method"(type_obj, "multi_declarator:sym<proto>", $P2045)
    get_how $P2046, type_obj
    get_global $P2047, "!PREFIX__multi_declarator:sym<proto>"
    $P2046."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "185_1298845521.609" 
    $P2048."add_method"(type_obj, "multi_declarator:sym<null>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__multi_declarator:sym<null>"
    $P2050."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "187_1298845521.609" 
    $P2052."add_method"(type_obj, "signature", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__signature"
    $P2054."add_method"(type_obj, "!PREFIX__signature", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "190_1298845521.609" 
    $P2056."add_method"(type_obj, "parameter", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__parameter"
    $P2058."add_method"(type_obj, "!PREFIX__parameter", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "192_1298845521.609" 
    $P2060."add_method"(type_obj, "param_var", $P2061)
    get_how $P2062, type_obj
    get_global $P2063, "!PREFIX__param_var"
    $P2062."add_method"(type_obj, "!PREFIX__param_var", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "194_1298845521.609" 
    $P2064."add_method"(type_obj, "named_param", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__named_param"
    $P2066."add_method"(type_obj, "!PREFIX__named_param", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "196_1298845521.609" 
    $P2068."add_method"(type_obj, "default_value", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__default_value"
    $P2070."add_method"(type_obj, "!PREFIX__default_value", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "198_1298845521.609" 
    $P2072."add_method"(type_obj, "trait", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__trait"
    $P2074."add_method"(type_obj, "!PREFIX__trait", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "200_1298845521.609" 
    $P2076."add_method"(type_obj, "trait_mod", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "201_1298845521.609" 
    $P2078."add_method"(type_obj, "!PREFIX__trait_mod", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "202_1298845521.609" 
    $P2080."add_method"(type_obj, "trait_mod:sym<is>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__trait_mod:sym<is>"
    $P2082."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "204_1298845521.609" 
    $P2084."add_method"(type_obj, "regex_declarator", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__regex_declarator"
    $P2086."add_method"(type_obj, "!PREFIX__regex_declarator", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "206_1298845521.609" 
    $P2088."add_method"(type_obj, "dotty", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__dotty"
    $P2090."add_method"(type_obj, "!PREFIX__dotty", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "208_1298845521.609" 
    $P2092."add_method"(type_obj, "term", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "209_1298845521.609" 
    $P2094."add_method"(type_obj, "!PREFIX__term", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "210_1298845521.609" 
    $P2096."add_method"(type_obj, "term:sym<self>", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__term:sym<self>"
    $P2098."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "212_1298845521.609" 
    $P2100."add_method"(type_obj, "term:sym<identifier>", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__term:sym<identifier>"
    $P2102."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "214_1298845521.609" 
    $P2104."add_method"(type_obj, "term:sym<name>", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__term:sym<name>"
    $P2106."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "216_1298845521.609" 
    $P2108."add_method"(type_obj, "term:sym<pir::op>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__term:sym<pir::op>"
    $P2110."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "218_1298845521.609" 
    $P2112."add_method"(type_obj, "term:sym<onlystar>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__term:sym<onlystar>"
    $P2114."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "221_1298845521.609" 
    $P2116."add_method"(type_obj, "args", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__args"
    $P2118."add_method"(type_obj, "!PREFIX__args", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "223_1298845521.609" 
    $P2120."add_method"(type_obj, "arglist", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__arglist"
    $P2122."add_method"(type_obj, "!PREFIX__arglist", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "225_1298845521.609" 
    $P2124."add_method"(type_obj, "term:sym<value>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__term:sym<value>"
    $P2126."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "227_1298845521.609" 
    $P2128."add_method"(type_obj, "value", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__value"
    $P2130."add_method"(type_obj, "!PREFIX__value", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "229_1298845521.609" 
    $P2132."add_method"(type_obj, "number", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__number"
    $P2134."add_method"(type_obj, "!PREFIX__number", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "231_1298845521.609" 
    $P2136."add_method"(type_obj, "quote", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "232_1298845521.609" 
    $P2138."add_method"(type_obj, "!PREFIX__quote", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "233_1298845521.609" 
    $P2140."add_method"(type_obj, "quote:sym<apos>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__quote:sym<apos>"
    $P2142."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "235_1298845521.609" 
    $P2144."add_method"(type_obj, "quote:sym<dblq>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__quote:sym<dblq>"
    $P2146."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "237_1298845521.609" 
    $P2148."add_method"(type_obj, "quote:sym<q>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__quote:sym<q>"
    $P2150."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "239_1298845521.609" 
    $P2152."add_method"(type_obj, "quote:sym<qq>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__quote:sym<qq>"
    $P2154."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "241_1298845521.609" 
    $P2156."add_method"(type_obj, "quote:sym<Q>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__quote:sym<Q>"
    $P2158."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "243_1298845521.609" 
    $P2160."add_method"(type_obj, "quote:sym<Q:PIR>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__quote:sym<Q:PIR>"
    $P2162."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "245_1298845521.609" 
    $P2164."add_method"(type_obj, "quote:sym</ />", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__quote:sym</ />"
    $P2166."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "247_1298845521.609" 
    $P2168."add_method"(type_obj, "quote_escape:sym<$>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__quote_escape:sym<$>"
    $P2170."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "249_1298845521.609" 
    $P2172."add_method"(type_obj, "quote_escape:sym<{ }>", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__quote_escape:sym<{ }>"
    $P2174."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "251_1298845521.609" 
    $P2176."add_method"(type_obj, "quote_escape:sym<esc>", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__quote_escape:sym<esc>"
    $P2178."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "253_1298845521.609" 
    $P2180."add_method"(type_obj, "circumfix:sym<( )>", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__circumfix:sym<( )>"
    $P2182."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "255_1298845521.609" 
    $P2184."add_method"(type_obj, "circumfix:sym<[ ]>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__circumfix:sym<[ ]>"
    $P2186."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "257_1298845521.609" 
    $P2188."add_method"(type_obj, "circumfix:sym<ang>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__circumfix:sym<ang>"
    $P2190."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "259_1298845521.609" 
    $P2192."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2194."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "261_1298845521.609" 
    $P2196."add_method"(type_obj, "circumfix:sym<{ }>", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__circumfix:sym<{ }>"
    $P2198."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "263_1298845521.609" 
    $P2200."add_method"(type_obj, "circumfix:sym<sigil>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__circumfix:sym<sigil>"
    $P2202."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "265_1298845521.609" 
    $P2204."add_method"(type_obj, "semilist", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__semilist"
    $P2206."add_method"(type_obj, "!PREFIX__semilist", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "268_1298845521.609" 
    $P2208."add_method"(type_obj, "infixish", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__infixish"
    $P2210."add_method"(type_obj, "!PREFIX__infixish", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "270_1298845521.609" 
    $P2212."add_method"(type_obj, "infixstopper", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__infixstopper"
    $P2214."add_method"(type_obj, "!PREFIX__infixstopper", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "272_1298845521.609" 
    $P2216."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2218."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "274_1298845521.609" 
    $P2220."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__postcircumfix:sym<{ }>"
    $P2222."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "276_1298845521.609" 
    $P2224."add_method"(type_obj, "postcircumfix:sym<ang>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__postcircumfix:sym<ang>"
    $P2226."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "278_1298845521.609" 
    $P2228."add_method"(type_obj, "postcircumfix:sym<( )>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__postcircumfix:sym<( )>"
    $P2230."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "280_1298845521.609" 
    $P2232."add_method"(type_obj, "postfix:sym<.>", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__postfix:sym<.>"
    $P2234."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "282_1298845521.609" 
    $P2236."add_method"(type_obj, "prefix:sym<++>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__prefix:sym<++>"
    $P2238."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "284_1298845521.609" 
    $P2240."add_method"(type_obj, "prefix:sym<-->", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__prefix:sym<-->"
    $P2242."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "286_1298845521.609" 
    $P2244."add_method"(type_obj, "postfix:sym<++>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__postfix:sym<++>"
    $P2246."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "288_1298845521.609" 
    $P2248."add_method"(type_obj, "postfix:sym<-->", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__postfix:sym<-->"
    $P2250."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "290_1298845521.609" 
    $P2252."add_method"(type_obj, "infix:sym<**>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__infix:sym<**>"
    $P2254."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "292_1298845521.609" 
    $P2256."add_method"(type_obj, "prefix:sym<+>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__prefix:sym<+>"
    $P2258."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "294_1298845521.609" 
    $P2260."add_method"(type_obj, "prefix:sym<~>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__prefix:sym<~>"
    $P2262."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "296_1298845521.609" 
    $P2264."add_method"(type_obj, "prefix:sym<->", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__prefix:sym<->"
    $P2266."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "298_1298845521.609" 
    $P2268."add_method"(type_obj, "prefix:sym<?>", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__prefix:sym<?>"
    $P2270."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "300_1298845521.609" 
    $P2272."add_method"(type_obj, "prefix:sym<!>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__prefix:sym<!>"
    $P2274."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "302_1298845521.609" 
    $P2276."add_method"(type_obj, "prefix:sym<|>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__prefix:sym<|>"
    $P2278."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "304_1298845521.609" 
    $P2280."add_method"(type_obj, "infix:sym<*>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<*>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "306_1298845521.609" 
    $P2284."add_method"(type_obj, "infix:sym</>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym</>"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "308_1298845521.609" 
    $P2288."add_method"(type_obj, "infix:sym<%>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<%>"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "310_1298845521.609" 
    $P2292."add_method"(type_obj, "infix:sym<+&>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<+&>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "312_1298845521.609" 
    $P2296."add_method"(type_obj, "infix:sym<+>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<+>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "314_1298845521.609" 
    $P2300."add_method"(type_obj, "infix:sym<->", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<->"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "316_1298845521.609" 
    $P2304."add_method"(type_obj, "infix:sym<+|>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<+|>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "318_1298845521.609" 
    $P2308."add_method"(type_obj, "infix:sym<+^>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<+^>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "320_1298845521.609" 
    $P2312."add_method"(type_obj, "infix:sym<~>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<~>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "322_1298845521.609" 
    $P2316."add_method"(type_obj, "infix:sym<==>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<==>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "324_1298845521.609" 
    $P2320."add_method"(type_obj, "infix:sym<!=>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<!=>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "326_1298845521.609" 
    $P2324."add_method"(type_obj, "infix:sym<<=>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<<=>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "328_1298845521.609" 
    $P2328."add_method"(type_obj, "infix:sym<>=>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<>=>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "330_1298845521.609" 
    $P2332."add_method"(type_obj, "infix:sym<<>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<<>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "332_1298845521.609" 
    $P2336."add_method"(type_obj, "infix:sym<>>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<>>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "334_1298845521.609" 
    $P2340."add_method"(type_obj, "infix:sym<eq>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<eq>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "336_1298845521.609" 
    $P2344."add_method"(type_obj, "infix:sym<ne>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<ne>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "338_1298845521.609" 
    $P2348."add_method"(type_obj, "infix:sym<le>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<le>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "340_1298845521.609" 
    $P2352."add_method"(type_obj, "infix:sym<ge>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<ge>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "342_1298845521.609" 
    $P2356."add_method"(type_obj, "infix:sym<lt>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<lt>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "344_1298845521.609" 
    $P2360."add_method"(type_obj, "infix:sym<gt>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<gt>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "346_1298845521.609" 
    $P2364."add_method"(type_obj, "infix:sym<=:=>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<=:=>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "348_1298845521.609" 
    $P2368."add_method"(type_obj, "infix:sym<~~>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<~~>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "350_1298845521.609" 
    $P2372."add_method"(type_obj, "infix:sym<&&>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__infix:sym<&&>"
    $P2374."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "352_1298845521.609" 
    $P2376."add_method"(type_obj, "infix:sym<||>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__infix:sym<||>"
    $P2378."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "354_1298845521.609" 
    $P2380."add_method"(type_obj, "infix:sym<//>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__infix:sym<//>"
    $P2382."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "356_1298845521.609" 
    $P2384."add_method"(type_obj, "infix:sym<?? !!>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__infix:sym<?? !!>"
    $P2386."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "358_1298845521.609" 
    $P2388."add_method"(type_obj, "infix:sym<=>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__infix:sym<=>"
    $P2390."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "360_1298845521.609" 
    $P2392."add_method"(type_obj, "infix:sym<:=>", $P2393)
    get_how $P2394, type_obj
    get_global $P2395, "!PREFIX__infix:sym<:=>"
    $P2394."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2395)
    get_how $P2396, type_obj
    .const 'Sub' $P2397 = "362_1298845521.609" 
    $P2396."add_method"(type_obj, "infix:sym<::=>", $P2397)
    get_how $P2398, type_obj
    get_global $P2399, "!PREFIX__infix:sym<::=>"
    $P2398."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2399)
    get_how $P2400, type_obj
    .const 'Sub' $P2401 = "364_1298845521.609" 
    $P2400."add_method"(type_obj, "infix:sym<,>", $P2401)
    get_how $P2402, type_obj
    get_global $P2403, "!PREFIX__infix:sym<,>"
    $P2402."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2403)
    get_how $P2404, type_obj
    .const 'Sub' $P2405 = "366_1298845521.609" 
    $P2404."add_method"(type_obj, "prefix:sym<return>", $P2405)
    get_how $P2406, type_obj
    get_global $P2407, "!PREFIX__prefix:sym<return>"
    $P2406."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2407)
    get_how $P2408, type_obj
    .const 'Sub' $P2409 = "369_1298845521.609" 
    $P2408."add_method"(type_obj, "prefix:sym<make>", $P2409)
    get_how $P2410, type_obj
    get_global $P2411, "!PREFIX__prefix:sym<make>"
    $P2410."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2411)
    get_how $P2412, type_obj
    .const 'Sub' $P2413 = "371_1298845521.609" 
    $P2412."add_method"(type_obj, "term:sym<last>", $P2413)
    get_how $P2414, type_obj
    get_global $P2415, "!PREFIX__term:sym<last>"
    $P2414."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2415)
    get_how $P2416, type_obj
    .const 'Sub' $P2417 = "373_1298845521.609" 
    $P2416."add_method"(type_obj, "term:sym<next>", $P2417)
    get_how $P2418, type_obj
    get_global $P2419, "!PREFIX__term:sym<next>"
    $P2418."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2419)
    get_how $P2420, type_obj
    .const 'Sub' $P2421 = "375_1298845521.609" 
    $P2420."add_method"(type_obj, "term:sym<redo>", $P2421)
    get_how $P2422, type_obj
    get_global $P2423, "!PREFIX__term:sym<redo>"
    $P2422."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2423)
    get_how $P2424, type_obj
    .const 'Sub' $P2425 = "377_1298845521.609" 
    $P2424."add_method"(type_obj, "smartmatch", $P2425)
    get_how $P2426, type_obj
    get_hll_global $P2427, ["HLL"], "Grammar"
    $P2426."add_parent"(type_obj, $P2427)
    get_how $P2428, type_obj
    $P2429 = $P2428."compose"(type_obj)
    .return ($P2429)
.end


.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1298845521.609") :outer("11_1298845521.609")
    .param pmc param_19
.annotate 'line', 4
    .lex "self", param_19
.annotate 'line', 5
    $P20 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P20
.annotate 'line', 12
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P21
.annotate 'line', 21
    new $P22, "Undef"
    .lex "$*DEFAULT-METAATTR", $P22
.annotate 'line', 22
    $P23 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P23
.annotate 'line', 25
    new $P24, "Undef"
    .lex "$*SCOPE", $P24
.annotate 'line', 26
    new $P25, "Undef"
    .lex "$*MULTINESS", $P25
.annotate 'line', 27
    new $P26, "Undef"
    .lex "$*INVOCANT_OK", $P26
.annotate 'line', 28
    new $P27, "Undef"
    .lex "$*RETURN_USED", $P27
.annotate 'line', 29
    new $P28, "Undef"
    .lex "$*PACKAGE-SETUP", $P28
.annotate 'line', 4
    find_lex $P29, "%*LANG"
    unless_null $P29, vivify_404
    get_hll_global $P29, "%LANG"
    unless_null $P29, vivify_405
    die "Contextual %*LANG not found"
  vivify_405:
  vivify_404:
.annotate 'line', 6
    get_hll_global $P30, ["NQP"], "Regex"
    find_lex $P31, "%*LANG"
    unless_null $P31, vivify_406
    get_hll_global $P31, "%LANG"
    unless_null $P31, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
    store_lex "%*LANG", $P31
  vivify_406:
    set $P31["Regex"], $P30
.annotate 'line', 7
    get_hll_global $P32, ["NQP"], "RegexActions"
    find_lex $P33, "%*LANG"
    unless_null $P33, vivify_408
    get_hll_global $P33, "%LANG"
    unless_null $P33, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P33
  vivify_408:
    set $P33["Regex-actions"], $P32
.annotate 'line', 8
    get_hll_global $P34, ["NQP"], "Grammar"
    find_lex $P35, "%*LANG"
    unless_null $P35, vivify_410
    get_hll_global $P35, "%LANG"
    unless_null $P35, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P35
  vivify_410:
    set $P35["MAIN"], $P34
.annotate 'line', 9
    get_hll_global $P36, ["NQP"], "Actions"
    find_lex $P37, "%*LANG"
    unless_null $P37, vivify_412
    get_hll_global $P37, "%LANG"
    unless_null $P37, vivify_413
    die "Contextual %*LANG not found"
  vivify_413:
    store_lex "%*LANG", $P37
  vivify_412:
    set $P37["MAIN-actions"], $P36
    find_lex $P38, "%*HOW"
    unless_null $P38, vivify_414
    get_hll_global $P38, "%HOW"
    unless_null $P38, vivify_415
    die "Contextual %*HOW not found"
  vivify_415:
  vivify_414:
.annotate 'line', 13
    get_hll_global $P39, "KnowHOW"
    find_lex $P40, "%*HOW"
    unless_null $P40, vivify_416
    get_hll_global $P40, "%HOW"
    unless_null $P40, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
    store_lex "%*HOW", $P40
  vivify_416:
    set $P40["knowhow"], $P39
.annotate 'line', 14
    get_hll_global $P41, "NQPModuleHOW"
    find_lex $P42, "%*HOW"
    unless_null $P42, vivify_418
    get_hll_global $P42, "%HOW"
    unless_null $P42, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P42
  vivify_418:
    set $P42["module"], $P41
.annotate 'line', 15
    get_hll_global $P43, "NQPClassHOW"
    find_lex $P44, "%*HOW"
    unless_null $P44, vivify_420
    get_hll_global $P44, "%HOW"
    unless_null $P44, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P44
  vivify_420:
    set $P44["class"], $P43
.annotate 'line', 16
    get_hll_global $P45, "NQPClassHOW"
    find_lex $P46, "%*HOW"
    unless_null $P46, vivify_422
    get_hll_global $P46, "%HOW"
    unless_null $P46, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P46
  vivify_422:
    set $P46["grammar"], $P45
.annotate 'line', 17
    get_hll_global $P47, "NQPParametricRoleHOW"
    find_lex $P48, "%*HOW"
    unless_null $P48, vivify_424
    get_hll_global $P48, "%HOW"
    unless_null $P48, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
    store_lex "%*HOW", $P48
  vivify_424:
    set $P48["role"], $P47
.annotate 'line', 18
    get_hll_global $P49, "NQPNativeHOW"
    find_lex $P50, "%*HOW"
    unless_null $P50, vivify_426
    get_hll_global $P50, "%HOW"
    unless_null $P50, vivify_427
    die "Contextual %*HOW not found"
  vivify_427:
    store_lex "%*HOW", $P50
  vivify_426:
    set $P50["native"], $P49
.annotate 'line', 21
    new $P51, "String"
    assign $P51, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P51
    find_lex $P52, "%*HOW-METAATTR"
    unless_null $P52, vivify_428
    get_hll_global $P52, "%HOW-METAATTR"
    unless_null $P52, vivify_429
    die "Contextual %*HOW-METAATTR not found"
  vivify_429:
  vivify_428:
.annotate 'line', 23
    new $P53, "String"
    assign $P53, "KnowHOWAttribute"
    find_lex $P54, "%*HOW-METAATTR"
    unless_null $P54, vivify_430
    get_hll_global $P54, "%HOW-METAATTR"
    unless_null $P54, vivify_431
    die "Contextual %*HOW-METAATTR not found"
  vivify_431:
    store_lex "%*HOW-METAATTR", $P54
  vivify_430:
    set $P54["knowhow"], $P53
.annotate 'line', 25
    new $P55, "String"
    assign $P55, ""
    store_lex "$*SCOPE", $P55
.annotate 'line', 26
    new $P56, "String"
    assign $P56, ""
    store_lex "$*MULTINESS", $P56
.annotate 'line', 27
    new $P57, "Integer"
    assign $P57, 0
    store_lex "$*INVOCANT_OK", $P57
.annotate 'line', 28
    new $P58, "Integer"
    assign $P58, 0
    store_lex "$*RETURN_USED", $P58
    find_lex $P59, "$*PACKAGE-SETUP"
    unless_null $P59, vivify_432
    get_hll_global $P59, "$PACKAGE-SETUP"
    unless_null $P59, vivify_433
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_433:
  vivify_432:
.annotate 'line', 30
    find_lex $P60, "self"
    $P61 = $P60."comp_unit"()
.annotate 'line', 4
    .return ($P61)
.end


.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx63_tgt
    .local int rx63_pos
    .local int rx63_off
    .local int rx63_eos
    .local int rx63_rep
    .local pmc rx63_cur
    .local pmc rx63_debug
    (rx63_cur, rx63_pos, rx63_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx63_cur
    .local pmc match
    .lex "$/", match
    length rx63_eos, rx63_tgt
    gt rx63_pos, rx63_eos, rx63_done
    set rx63_off, 0
    lt rx63_pos, 2, rx63_start
    sub rx63_off, rx63_pos, 1
    substr rx63_tgt, rx63_tgt, rx63_off
  rx63_start:
    eq $I10, 1, rx63_restart
    if_null rx63_debug, debug_434
    rx63_cur."!cursor_debug"("START", "identifier")
  debug_434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan67_done
    goto rxscan67_scan
  rxscan67_loop:
    (rx63_pos) = rx63_cur."from"()
    inc rx63_pos
    rx63_cur."!cursor_from"(rx63_pos)
    ge rx63_pos, rx63_eos, rxscan67_done
  rxscan67_scan:
    set_addr $I10, rxscan67_loop
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxscan67_done:
.annotate 'line', 35
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
  # rx rxquantr68 ** 0..*
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxquantr68_loop:
  # rx enumcharlist negate=0 
    ge rx63_pos, rx63_eos, rx63_fail
    sub $I10, rx63_pos, rx63_off
    substr $S10, rx63_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx63_fail
    inc rx63_pos
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
    set_addr $I10, rxquantr68_done
    (rx63_rep) = rx63_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(rx63_rep, rx63_pos, $I10)
    goto rxquantr68_loop
  rxquantr68_done:
  # rx pass
    rx63_cur."!cursor_pass"(rx63_pos, "identifier")
    if_null rx63_debug, debug_435
    rx63_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx63_pos)
  debug_435:
    .return (rx63_cur)
  rx63_restart:
.annotate 'line', 4
    if_null rx63_debug, debug_436
    rx63_cur."!cursor_debug"("NEXT", "identifier")
  debug_436:
  rx63_fail:
    (rx63_rep, rx63_pos, $I10, $P10) = rx63_cur."!mark_fail"(0)
    lt rx63_pos, -1, rx63_done
    eq rx63_pos, -1, rx63_fail
    jump $I10
  rx63_done:
    rx63_cur."!cursor_fail"()
    if_null rx63_debug, debug_437
    rx63_cur."!cursor_debug"("FAIL", "identifier")
  debug_437:
    .return (rx63_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1298845521.609") :method
.annotate 'line', 4
    $P65 = self."!PREFIX__!subrule"("ident", "")
    new $P66, "ResizablePMCArray"
    push $P66, $P65
    .return ($P66)
.end


.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx70_tgt
    .local int rx70_pos
    .local int rx70_off
    .local int rx70_eos
    .local int rx70_rep
    .local pmc rx70_cur
    .local pmc rx70_debug
    (rx70_cur, rx70_pos, rx70_tgt, $I10) = self."!cursor_start"()
    rx70_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx70_cur
    .local pmc match
    .lex "$/", match
    length rx70_eos, rx70_tgt
    gt rx70_pos, rx70_eos, rx70_done
    set rx70_off, 0
    lt rx70_pos, 2, rx70_start
    sub rx70_off, rx70_pos, 1
    substr rx70_tgt, rx70_tgt, rx70_off
  rx70_start:
    eq $I10, 1, rx70_restart
    if_null rx70_debug, debug_438
    rx70_cur."!cursor_debug"("START", "name")
  debug_438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan73_done
    goto rxscan73_scan
  rxscan73_loop:
    (rx70_pos) = rx70_cur."from"()
    inc rx70_pos
    rx70_cur."!cursor_from"(rx70_pos)
    ge rx70_pos, rx70_eos, rxscan73_done
  rxscan73_scan:
    set_addr $I10, rxscan73_loop
    rx70_cur."!mark_push"(0, rx70_pos, $I10)
  rxscan73_done:
.annotate 'line', 37
  # rx rxquantr74 ** 1..*
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(0, -1, $I10)
  rxquantr74_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx70_cur."!cursor_pos"(rx70_pos)
    $P10 = rx70_cur."identifier"()
    unless $P10, rx70_fail
    goto rxsubrule75_pass
  rxsubrule75_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx70_fail
  rxsubrule75_pass:
    set_addr $I10, rxsubrule75_back
    rx70_cur."!mark_push"(0, rx70_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx70_pos = $P10."pos"()
    set_addr $I10, rxquantr74_done
    (rx70_rep) = rx70_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(rx70_rep, rx70_pos, $I10)
  # rx literal  "::"
    add $I11, rx70_pos, 2
    gt $I11, rx70_eos, rx70_fail
    sub $I11, rx70_pos, rx70_off
    substr $S10, rx70_tgt, $I11, 2
    ne $S10, "::", rx70_fail
    add rx70_pos, 2
    goto rxquantr74_loop
  rxquantr74_done:
  # rx pass
    rx70_cur."!cursor_pass"(rx70_pos, "name")
    if_null rx70_debug, debug_439
    rx70_cur."!cursor_debug"("PASS", "name", " at pos=", rx70_pos)
  debug_439:
    .return (rx70_cur)
  rx70_restart:
.annotate 'line', 4
    if_null rx70_debug, debug_440
    rx70_cur."!cursor_debug"("NEXT", "name")
  debug_440:
  rx70_fail:
    (rx70_rep, rx70_pos, $I10, $P10) = rx70_cur."!mark_fail"(0)
    lt rx70_pos, -1, rx70_done
    eq rx70_pos, -1, rx70_fail
    jump $I10
  rx70_done:
    rx70_cur."!cursor_fail"()
    if_null rx70_debug, debug_441
    rx70_cur."!cursor_debug"("FAIL", "name")
  debug_441:
    .return (rx70_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1298845521.609") :method
.annotate 'line', 4
    new $P72, "ResizablePMCArray"
    push $P72, ""
    .return ($P72)
.end


.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx77_tgt
    .local int rx77_pos
    .local int rx77_off
    .local int rx77_eos
    .local int rx77_rep
    .local pmc rx77_cur
    .local pmc rx77_debug
    (rx77_cur, rx77_pos, rx77_tgt, $I10) = self."!cursor_start"()
    rx77_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx77_cur
    .local pmc match
    .lex "$/", match
    length rx77_eos, rx77_tgt
    gt rx77_pos, rx77_eos, rx77_done
    set rx77_off, 0
    lt rx77_pos, 2, rx77_start
    sub rx77_off, rx77_pos, 1
    substr rx77_tgt, rx77_tgt, rx77_off
  rx77_start:
    eq $I10, 1, rx77_restart
    if_null rx77_debug, debug_442
    rx77_cur."!cursor_debug"("START", "deflongname")
  debug_442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan81_done
    goto rxscan81_scan
  rxscan81_loop:
    (rx77_pos) = rx77_cur."from"()
    inc rx77_pos
    rx77_cur."!cursor_from"(rx77_pos)
    ge rx77_pos, rx77_eos, rxscan81_done
  rxscan81_scan:
    set_addr $I10, rxscan81_loop
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxscan81_done:
.annotate 'line', 40
  # rx subrule "identifier" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."identifier"()
    unless $P10, rx77_fail
    rx77_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx77_pos = $P10."pos"()
  # rx rxquantr82 ** 0..1
    set_addr $I10, rxquantr82_done
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxquantr82_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."colonpair"()
    unless $P10, rx77_fail
    goto rxsubrule83_pass
  rxsubrule83_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx77_fail
  rxsubrule83_pass:
    set_addr $I10, rxsubrule83_back
    rx77_cur."!mark_push"(0, rx77_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx77_pos = $P10."pos"()
    set_addr $I10, rxquantr82_done
    (rx77_rep) = rx77_cur."!mark_commit"($I10)
  rxquantr82_done:
.annotate 'line', 39
  # rx pass
    rx77_cur."!cursor_pass"(rx77_pos, "deflongname")
    if_null rx77_debug, debug_443
    rx77_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx77_pos)
  debug_443:
    .return (rx77_cur)
  rx77_restart:
.annotate 'line', 4
    if_null rx77_debug, debug_444
    rx77_cur."!cursor_debug"("NEXT", "deflongname")
  debug_444:
  rx77_fail:
    (rx77_rep, rx77_pos, $I10, $P10) = rx77_cur."!mark_fail"(0)
    lt rx77_pos, -1, rx77_done
    eq rx77_pos, -1, rx77_fail
    jump $I10
  rx77_done:
    rx77_cur."!cursor_fail"()
    if_null rx77_debug, debug_445
    rx77_cur."!cursor_debug"("FAIL", "deflongname")
  debug_445:
    .return (rx77_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1298845521.609") :method
.annotate 'line', 4
    $P79 = self."!PREFIX__!subrule"("identifier", "")
    new $P80, "ResizablePMCArray"
    push $P80, $P79
    .return ($P80)
.end


.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx85_tgt
    .local int rx85_pos
    .local int rx85_off
    .local int rx85_eos
    .local int rx85_rep
    .local pmc rx85_cur
    .local pmc rx85_debug
    (rx85_cur, rx85_pos, rx85_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx85_cur
    .local pmc match
    .lex "$/", match
    length rx85_eos, rx85_tgt
    gt rx85_pos, rx85_eos, rx85_done
    set rx85_off, 0
    lt rx85_pos, 2, rx85_start
    sub rx85_off, rx85_pos, 1
    substr rx85_tgt, rx85_tgt, rx85_off
  rx85_start:
    eq $I10, 1, rx85_restart
    if_null rx85_debug, debug_446
    rx85_cur."!cursor_debug"("START", "ENDSTMT")
  debug_446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan88_done
    goto rxscan88_scan
  rxscan88_loop:
    (rx85_pos) = rx85_cur."from"()
    inc rx85_pos
    rx85_cur."!cursor_from"(rx85_pos)
    ge rx85_pos, rx85_eos, rxscan88_done
  rxscan88_scan:
    set_addr $I10, rxscan88_loop
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxscan88_done:
.annotate 'line', 47
  # rx rxquantr89 ** 0..1
    set_addr $I10, rxquantr89_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr89_loop:
  alt90_0:
.annotate 'line', 44
    set_addr $I10, alt90_1
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
.annotate 'line', 45
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx85_pos, rx85_off
    set rx85_rep, 0
    sub $I12, rx85_eos, rx85_pos
  rxenumcharlistq91_loop:
    le $I12, 0, rxenumcharlistq91_done
    substr $S10, rx85_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq91_done
    inc rx85_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq91_loop
  rxenumcharlistq91_done:
    add rx85_pos, rx85_pos, rx85_rep
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor92_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor92_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor92_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
    goto alt90_end
  alt90_1:
.annotate 'line', 46
  # rx rxquantr93 ** 0..1
    set_addr $I10, rxquantr93_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr93_loop:
  # rx subrule "unv" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."unv"()
    unless $P10, rx85_fail
    goto rxsubrule94_pass
  rxsubrule94_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx85_fail
  rxsubrule94_pass:
    set_addr $I10, rxsubrule94_back
    rx85_cur."!mark_push"(0, rx85_pos, $I10, $P10)
    rx85_pos = $P10."pos"()
    set_addr $I10, rxquantr93_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr93_done:
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor95_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor95_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor95_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
  alt90_end:
.annotate 'line', 47
    set_addr $I10, rxquantr89_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr89_done:
.annotate 'line', 43
  # rx pass
    rx85_cur."!cursor_pass"(rx85_pos, "ENDSTMT")
    if_null rx85_debug, debug_447
    rx85_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx85_pos)
  debug_447:
    .return (rx85_cur)
  rx85_restart:
.annotate 'line', 4
    if_null rx85_debug, debug_448
    rx85_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_448:
  rx85_fail:
    (rx85_rep, rx85_pos, $I10, $P10) = rx85_cur."!mark_fail"(0)
    lt rx85_pos, -1, rx85_done
    eq rx85_pos, -1, rx85_fail
    jump $I10
  rx85_done:
    rx85_cur."!cursor_fail"()
    if_null rx85_debug, debug_449
    rx85_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_449:
    .return (rx85_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1298845521.609") :method
.annotate 'line', 4
    new $P87, "ResizablePMCArray"
    push $P87, ""
    .return ($P87)
.end


.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx97_tgt
    .local int rx97_pos
    .local int rx97_off
    .local int rx97_eos
    .local int rx97_rep
    .local pmc rx97_cur
    .local pmc rx97_debug
    (rx97_cur, rx97_pos, rx97_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx97_cur
    .local pmc match
    .lex "$/", match
    length rx97_eos, rx97_tgt
    gt rx97_pos, rx97_eos, rx97_done
    set rx97_off, 0
    lt rx97_pos, 2, rx97_start
    sub rx97_off, rx97_pos, 1
    substr rx97_tgt, rx97_tgt, rx97_off
  rx97_start:
    eq $I10, 1, rx97_restart
    if_null rx97_debug, debug_450
    rx97_cur."!cursor_debug"("START", "ws")
  debug_450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan100_done
    goto rxscan100_scan
  rxscan100_loop:
    (rx97_pos) = rx97_cur."from"()
    inc rx97_pos
    rx97_cur."!cursor_from"(rx97_pos)
    ge rx97_pos, rx97_eos, rxscan100_done
  rxscan100_scan:
    set_addr $I10, rxscan100_loop
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxscan100_done:
  alt101_0:
.annotate 'line', 50
    set_addr $I10, alt101_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 51
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKED"("ws")
    unless $P10, rx97_fail
    goto alt101_end
  alt101_1:
.annotate 'line', 52
  # rx subrule "ww" subtype=zerowidth negate=1
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."ww"()
    if $P10, rx97_fail
.annotate 'line', 57
  # rx rxquantr102 ** 0..*
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxquantr102_loop:
  alt103_0:
.annotate 'line', 53
    set_addr $I10, alt103_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq104_loop:
    le $I12, 0, rxenumcharlistq104_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq104_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq104_loop
  rxenumcharlistq104_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
    goto alt103_end
  alt103_1:
    set_addr $I10, alt103_2
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 54
  # rx literal  "#"
    add $I11, rx97_pos, 1
    gt $I11, rx97_eos, rx97_fail
    sub $I11, rx97_pos, rx97_off
    ord $I11, rx97_tgt, $I11
    ne $I11, 35, rx97_fail
    add rx97_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx97_pos, rx97_off
    find_cclass $I11, 4096, rx97_tgt, $I10, rx97_eos
    add rx97_pos, rx97_off, $I11
    goto alt103_end
  alt103_2:
    set_addr $I10, alt103_3
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 55
  # rxanchor bol
    eq rx97_pos, 0, rxanchor105_done
    ge rx97_pos, rx97_eos, rx97_fail
    sub $I10, rx97_pos, rx97_off
    dec $I10
    is_cclass $I11, 4096, rx97_tgt, $I10
    unless $I11, rx97_fail
  rxanchor105_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."pod_comment"()
    unless $P10, rx97_fail
    rx97_pos = $P10."pos"()
    goto alt103_end
  alt103_3:
.annotate 'line', 56
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq106_loop:
    le $I12, 0, rxenumcharlistq106_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq106_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq106_loop
  rxenumcharlistq106_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
  alt103_end:
.annotate 'line', 57
    set_addr $I10, rxquantr102_done
    (rx97_rep) = rx97_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(rx97_rep, rx97_pos, $I10)
    goto rxquantr102_loop
  rxquantr102_done:
.annotate 'line', 58
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKER"("ws")
    unless $P10, rx97_fail
  alt101_end:
.annotate 'line', 50
  # rx pass
    rx97_cur."!cursor_pass"(rx97_pos, "ws")
    if_null rx97_debug, debug_451
    rx97_cur."!cursor_debug"("PASS", "ws", " at pos=", rx97_pos)
  debug_451:
    .return (rx97_cur)
  rx97_restart:
.annotate 'line', 4
    if_null rx97_debug, debug_452
    rx97_cur."!cursor_debug"("NEXT", "ws")
  debug_452:
  rx97_fail:
    (rx97_rep, rx97_pos, $I10, $P10) = rx97_cur."!mark_fail"(0)
    lt rx97_pos, -1, rx97_done
    eq rx97_pos, -1, rx97_fail
    jump $I10
  rx97_done:
    rx97_cur."!cursor_fail"()
    if_null rx97_debug, debug_453
    rx97_cur."!cursor_debug"("FAIL", "ws")
  debug_453:
    .return (rx97_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1298845521.609") :method
.annotate 'line', 4
    new $P99, "ResizablePMCArray"
    push $P99, ""
    push $P99, ""
    .return ($P99)
.end


.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P115 = "25_1298845521.609" 
    capture_lex $P115
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_454
    rx108_cur."!cursor_debug"("START", "unv")
  debug_454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
  alt112_0:
.annotate 'line', 63
    set_addr $I10, alt112_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 64
  # rxanchor bol
    eq rx108_pos, 0, rxanchor113_done
    ge rx108_pos, rx108_eos, rx108_fail
    sub $I10, rx108_pos, rx108_off
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    unless $I11, rx108_fail
  rxanchor113_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    .const 'Sub' $P115 = "25_1298845521.609" 
    capture_lex $P115
    $P10 = rx108_cur."before"($P115)
    unless $P10, rx108_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."pod_comment"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
    goto alt112_end
  alt112_1:
    set_addr $I10, alt112_2
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 65
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq120_loop:
    le $I12, 0, rxenumcharlistq120_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq120_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq120_loop
  rxenumcharlistq120_done:
    add rx108_pos, rx108_pos, rx108_rep
  # rx literal  "#"
    add $I11, rx108_pos, 1
    gt $I11, rx108_eos, rx108_fail
    sub $I11, rx108_pos, rx108_off
    ord $I11, rx108_tgt, $I11
    ne $I11, 35, rx108_fail
    add rx108_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx108_pos, rx108_off
    find_cclass $I11, 4096, rx108_tgt, $I10, rx108_eos
    add rx108_pos, rx108_off, $I11
    goto alt112_end
  alt112_2:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq121_loop:
    le $I12, 0, rxenumcharlistq121_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq121_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq121_loop
  rxenumcharlistq121_done:
    lt rx108_rep, 1, rx108_fail
    add rx108_pos, rx108_pos, rx108_rep
  alt112_end:
.annotate 'line', 61
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "unv")
    if_null rx108_debug, debug_459
    rx108_cur."!cursor_debug"("PASS", "unv", " at pos=", rx108_pos)
  debug_459:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 4
    if_null rx108_debug, debug_460
    rx108_cur."!cursor_debug"("NEXT", "unv")
  debug_460:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_461
    rx108_cur."!cursor_debug"("FAIL", "unv")
  debug_461:
    .return (rx108_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1298845521.609") :method
.annotate 'line', 4
    new $P110, "ResizablePMCArray"
    push $P110, ""
    push $P110, ""
    push $P110, ""
    .return ($P110)
.end


.namespace ["NQP";"Grammar"]
.sub "_block114"  :anon :subid("25_1298845521.609") :method :outer("23_1298845521.609")
.annotate 'line', 64
    .local string rx116_tgt
    .local int rx116_pos
    .local int rx116_off
    .local int rx116_eos
    .local int rx116_rep
    .local pmc rx116_cur
    .local pmc rx116_debug
    (rx116_cur, rx116_pos, rx116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx116_cur
    .local pmc match
    .lex "$/", match
    length rx116_eos, rx116_tgt
    gt rx116_pos, rx116_eos, rx116_done
    set rx116_off, 0
    lt rx116_pos, 2, rx116_start
    sub rx116_off, rx116_pos, 1
    substr rx116_tgt, rx116_tgt, rx116_off
  rx116_start:
    eq $I10, 1, rx116_restart
    if_null rx116_debug, debug_455
    rx116_cur."!cursor_debug"("START", "")
  debug_455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan117_done
    goto rxscan117_scan
  rxscan117_loop:
    (rx116_pos) = rx116_cur."from"()
    inc rx116_pos
    rx116_cur."!cursor_from"(rx116_pos)
    ge rx116_pos, rx116_eos, rxscan117_done
  rxscan117_scan:
    set_addr $I10, rxscan117_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  rxscan117_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq118_loop:
    le $I12, 0, rxenumcharlistq118_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq118_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq118_loop
  rxenumcharlistq118_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "="
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 61, rx116_fail
    add rx116_pos, 1
  alt119_0:
    set_addr $I10, alt119_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rx charclass w
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
    inc rx116_pos
    goto alt119_end
  alt119_1:
  # rx literal  "\\"
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 92, rx116_fail
    add rx116_pos, 1
  alt119_end:
  # rx pass
    rx116_cur."!cursor_pass"(rx116_pos, "")
    if_null rx116_debug, debug_456
    rx116_cur."!cursor_debug"("PASS", "", " at pos=", rx116_pos)
  debug_456:
    .return (rx116_cur)
  rx116_restart:
    if_null rx116_debug, debug_457
    rx116_cur."!cursor_debug"("NEXT", "")
  debug_457:
  rx116_fail:
    (rx116_rep, rx116_pos, $I10, $P10) = rx116_cur."!mark_fail"(0)
    lt rx116_pos, -1, rx116_done
    eq rx116_pos, -1, rx116_fail
    jump $I10
  rx116_done:
    rx116_cur."!cursor_fail"()
    if_null rx116_debug, debug_458
    rx116_cur."!cursor_debug"("FAIL", "")
  debug_458:
    .return (rx116_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P154 = "28_1298845521.609" 
    capture_lex $P154
    .local string rx123_tgt
    .local int rx123_pos
    .local int rx123_off
    .local int rx123_eos
    .local int rx123_rep
    .local pmc rx123_cur
    .local pmc rx123_debug
    (rx123_cur, rx123_pos, rx123_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx123_cur
    .local pmc match
    .lex "$/", match
    length rx123_eos, rx123_tgt
    gt rx123_pos, rx123_eos, rx123_done
    set rx123_off, 0
    lt rx123_pos, 2, rx123_start
    sub rx123_off, rx123_pos, 1
    substr rx123_tgt, rx123_tgt, rx123_off
  rx123_start:
    eq $I10, 1, rx123_restart
    if_null rx123_debug, debug_462
    rx123_cur."!cursor_debug"("START", "pod_comment")
  debug_462:
    $I10 = self.'from'()
    ne $I10, -1, rxscan126_done
    goto rxscan126_scan
  rxscan126_loop:
    (rx123_pos) = rx123_cur."from"()
    inc rx123_pos
    rx123_cur."!cursor_from"(rx123_pos)
    ge rx123_pos, rx123_eos, rxscan126_done
  rxscan126_scan:
    set_addr $I10, rxscan126_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  rxscan126_done:
.annotate 'line', 71
  # rxanchor bol
    eq rx123_pos, 0, rxanchor127_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor127_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq128_loop:
    le $I12, 0, rxenumcharlistq128_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq128_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq128_loop
  rxenumcharlistq128_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "="
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 61, rx123_fail
    add rx123_pos, 1
  alt129_0:
.annotate 'line', 72
    set_addr $I10, alt129_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 73
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq130_loop:
    le $I12, 0, rxenumcharlistq130_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq130_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq130_loop
  rxenumcharlistq130_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  alt131_0:
.annotate 'line', 74
    set_addr $I10, alt131_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx rxquantf132 ** 0..*
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf132_done
  rxquantf132_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf132_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq135_loop:
    le $I12, 0, rxenumcharlistq135_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq135_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq135_loop
  rxenumcharlistq135_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt131_end
  alt131_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_not_cclass $I11, 65535, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt131_end:
.annotate 'line', 73
    goto alt129_end
  alt129_1:
    set_addr $I10, alt129_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 75
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq136_loop:
    le $I12, 0, rxenumcharlistq136_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq136_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq136_loop
  rxenumcharlistq136_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
  alt137_0:
.annotate 'line', 76
    set_addr $I10, alt137_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 77
  # rx rxquantf138 ** 0..*
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf138_done
  rxquantf138_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf138_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq140_loop:
    le $I12, 0, rxenumcharlistq140_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq140_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq140_loop
  rxenumcharlistq140_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."!BACKREF"("identifier")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt137_end
  alt137_1:
.annotate 'line', 78
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt137_end:
.annotate 'line', 75
    goto alt129_end
  alt129_2:
    set_addr $I10, alt129_3
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx123_pos, rx123_pos, rx123_rep
  alt144_0:
.annotate 'line', 81
    set_addr $I10, alt144_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rxanchor eol
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rxanchor145_done
    ne rx123_pos, rx123_eos, rx123_fail
    eq rx123_pos, 0, rxanchor145_done
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rx123_fail
  rxanchor145_done:
    goto alt144_end
  alt144_1:
    set_addr $I10, alt144_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx literal  "#"
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 35, rx123_fail
    add rx123_pos, 1
    goto alt144_end
  alt144_2:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt144_end:
  alt146_0:
.annotate 'line', 82
    set_addr $I10, alt146_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 83
  # rx rxquantf147 ** 0..*
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf147_done
  rxquantf147_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf147_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq149_loop:
    le $I12, 0, rxenumcharlistq149_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq149_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq149_loop
  rxenumcharlistq149_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt146_end
  alt146_1:
.annotate 'line', 84
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt146_end:
.annotate 'line', 80
    goto alt129_end
  alt129_3:
    set_addr $I10, alt129_4
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 86
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
.annotate 'line', 87
  # rx rxquantf150 ** 0..*
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf150_done
  rxquantf150_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf150_done:
  # rxanchor bol
    eq rx123_pos, 0, rxanchor152_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor152_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    .const 'Sub' $P154 = "28_1298845521.609" 
    capture_lex $P154
    $P10 = rx123_cur."before"($P154)
    unless $P10, rx123_fail
.annotate 'line', 86
    goto alt129_end
  alt129_4:
  alt160_0:
.annotate 'line', 93
    set_addr $I10, alt160_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx charclass s
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 32, rx123_tgt, $I10
    unless $I11, rx123_fail
    inc rx123_pos
    goto alt160_end
  alt160_1:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Illegal pod directive")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 94
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt129_end:
.annotate 'line', 70
  # rx pass
    rx123_cur."!cursor_pass"(rx123_pos, "pod_comment")
    if_null rx123_debug, debug_467
    rx123_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx123_pos)
  debug_467:
    .return (rx123_cur)
  rx123_restart:
.annotate 'line', 4
    if_null rx123_debug, debug_468
    rx123_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_468:
  rx123_fail:
    (rx123_rep, rx123_pos, $I10, $P10) = rx123_cur."!mark_fail"(0)
    lt rx123_pos, -1, rx123_done
    eq rx123_pos, -1, rx123_fail
    jump $I10
  rx123_done:
    rx123_cur."!cursor_fail"()
    if_null rx123_debug, debug_469
    rx123_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_469:
    .return (rx123_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1298845521.609") :method
.annotate 'line', 4
    new $P125, "ResizablePMCArray"
    push $P125, ""
    .return ($P125)
.end


.namespace ["NQP";"Grammar"]
.sub "_block153"  :anon :subid("28_1298845521.609") :method :outer("26_1298845521.609")
.annotate 'line', 87
    .local string rx155_tgt
    .local int rx155_pos
    .local int rx155_off
    .local int rx155_eos
    .local int rx155_rep
    .local pmc rx155_cur
    .local pmc rx155_debug
    (rx155_cur, rx155_pos, rx155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx155_cur
    .local pmc match
    .lex "$/", match
    length rx155_eos, rx155_tgt
    gt rx155_pos, rx155_eos, rx155_done
    set rx155_off, 0
    lt rx155_pos, 2, rx155_start
    sub rx155_off, rx155_pos, 1
    substr rx155_tgt, rx155_tgt, rx155_off
  rx155_start:
    eq $I10, 1, rx155_restart
    if_null rx155_debug, debug_463
    rx155_cur."!cursor_debug"("START", "")
  debug_463:
    $I10 = self.'from'()
    ne $I10, -1, rxscan156_done
    goto rxscan156_scan
  rxscan156_loop:
    (rx155_pos) = rx155_cur."from"()
    inc rx155_pos
    rx155_cur."!cursor_from"(rx155_pos)
    ge rx155_pos, rx155_eos, rxscan156_done
  rxscan156_scan:
    set_addr $I10, rxscan156_loop
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxscan156_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx155_pos, rx155_off
    set rx155_rep, 0
    sub $I12, rx155_eos, rx155_pos
  rxenumcharlistq157_loop:
    le $I12, 0, rxenumcharlistq157_done
    substr $S10, rx155_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq157_done
    inc rx155_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq157_loop
  rxenumcharlistq157_done:
    add rx155_pos, rx155_pos, rx155_rep
  alt158_0:
    set_addr $I10, alt158_1
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
.annotate 'line', 88
  # rx literal  "="
    add $I11, rx155_pos, 1
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    ord $I11, rx155_tgt, $I11
    ne $I11, 61, rx155_fail
    add rx155_pos, 1
.annotate 'line', 90
  # rx rxquantr159 ** 0..1
    set_addr $I10, rxquantr159_done
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxquantr159_loop:
.annotate 'line', 89
  # rx literal  "cut"
    add $I11, rx155_pos, 3
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    substr $S10, rx155_tgt, $I11, 3
    ne $S10, "cut", rx155_fail
    add rx155_pos, 3
  # rxanchor rwb
    le rx155_pos, 0, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 8192, rx155_tgt, $I10
    if $I11, rx155_fail
    dec $I10
    is_cclass $I11, 8192, rx155_tgt, $I10
    unless $I11, rx155_fail
.annotate 'line', 90
  # rx subrule "panic" subtype=method negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx155_fail
    rx155_pos = $P10."pos"()
    set_addr $I10, rxquantr159_done
    (rx155_rep) = rx155_cur."!mark_commit"($I10)
  rxquantr159_done:
.annotate 'line', 87
    goto alt158_end
  alt158_1:
.annotate 'line', 91
  # rx charclass nl
    ge rx155_pos, rx155_eos, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 4096, rx155_tgt, $I10
    unless $I11, rx155_fail
    substr $S10, rx155_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx155_pos, $I11
    inc rx155_pos
  alt158_end:
.annotate 'line', 87
  # rx pass
    rx155_cur."!cursor_pass"(rx155_pos, "")
    if_null rx155_debug, debug_464
    rx155_cur."!cursor_debug"("PASS", "", " at pos=", rx155_pos)
  debug_464:
    .return (rx155_cur)
  rx155_restart:
    if_null rx155_debug, debug_465
    rx155_cur."!cursor_debug"("NEXT", "")
  debug_465:
  rx155_fail:
    (rx155_rep, rx155_pos, $I10, $P10) = rx155_cur."!mark_fail"(0)
    lt rx155_pos, -1, rx155_done
    eq rx155_pos, -1, rx155_fail
    jump $I10
  rx155_done:
    rx155_cur."!cursor_fail"()
    if_null rx155_debug, debug_466
    rx155_cur."!cursor_debug"("FAIL", "")
  debug_466:
    .return (rx155_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 102
    new $P162, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P162
.annotate 'line', 4
    .local string rx163_tgt
    .local int rx163_pos
    .local int rx163_off
    .local int rx163_eos
    .local int rx163_rep
    .local pmc rx163_cur
    .local pmc rx163_debug
    (rx163_cur, rx163_pos, rx163_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx163_cur
    .local pmc match
    .lex "$/", match
    length rx163_eos, rx163_tgt
    gt rx163_pos, rx163_eos, rx163_done
    set rx163_off, 0
    lt rx163_pos, 2, rx163_start
    sub rx163_off, rx163_pos, 1
    substr rx163_tgt, rx163_tgt, rx163_off
  rx163_start:
    eq $I10, 1, rx163_restart
    if_null rx163_debug, debug_470
    rx163_cur."!cursor_debug"("START", "comp_unit")
  debug_470:
    $I10 = self.'from'()
    ne $I10, -1, rxscan167_done
    goto rxscan167_scan
  rxscan167_loop:
    (rx163_pos) = rx163_cur."from"()
    inc rx163_pos
    rx163_cur."!cursor_from"(rx163_pos)
    ge rx163_pos, rx163_eos, rxscan167_done
  rxscan167_scan:
    set_addr $I10, rxscan167_loop
    rx163_cur."!mark_push"(0, rx163_pos, $I10)
  rxscan167_done:
.annotate 'line', 102
    rx163_cur."!cursor_pos"(rx163_pos)
    new $P168, "Integer"
    assign $P168, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P168
.annotate 'line', 103
  # rx subrule "newpad" subtype=method negate=
    rx163_cur."!cursor_pos"(rx163_pos)
    $P10 = rx163_cur."newpad"()
    unless $P10, rx163_fail
    rx163_pos = $P10."pos"()
.annotate 'line', 104
  # rx subrule "outerctx" subtype=method negate=
    rx163_cur."!cursor_pos"(rx163_pos)
    $P10 = rx163_cur."outerctx"()
    unless $P10, rx163_fail
    rx163_pos = $P10."pos"()
.annotate 'line', 105
  # rx subrule "statementlist" subtype=capture negate=
    rx163_cur."!cursor_pos"(rx163_pos)
    $P10 = rx163_cur."statementlist"()
    unless $P10, rx163_fail
    rx163_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx163_pos = $P10."pos"()
  alt169_0:
.annotate 'line', 106
    set_addr $I10, alt169_1
    rx163_cur."!mark_push"(0, rx163_pos, $I10)
  # rxanchor eos
    ne rx163_pos, rx163_eos, rx163_fail
    goto alt169_end
  alt169_1:
  # rx subrule "panic" subtype=method negate=
    rx163_cur."!cursor_pos"(rx163_pos)
    $P10 = rx163_cur."panic"("Confused")
    unless $P10, rx163_fail
    rx163_pos = $P10."pos"()
  alt169_end:
.annotate 'line', 101
  # rx pass
    rx163_cur."!cursor_pass"(rx163_pos, "comp_unit")
    if_null rx163_debug, debug_471
    rx163_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx163_pos)
  debug_471:
    .return (rx163_cur)
  rx163_restart:
.annotate 'line', 4
    if_null rx163_debug, debug_472
    rx163_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_472:
  rx163_fail:
    (rx163_rep, rx163_pos, $I10, $P10) = rx163_cur."!mark_fail"(0)
    lt rx163_pos, -1, rx163_done
    eq rx163_pos, -1, rx163_fail
    jump $I10
  rx163_done:
    rx163_cur."!cursor_fail"()
    if_null rx163_debug, debug_473
    rx163_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_473:
    .return (rx163_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1298845521.609") :method
.annotate 'line', 4
    $P165 = self."!PREFIX__!subrule"("newpad", "")
    new $P166, "ResizablePMCArray"
    push $P166, $P165
    .return ($P166)
.end


.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx171_tgt
    .local int rx171_pos
    .local int rx171_off
    .local int rx171_eos
    .local int rx171_rep
    .local pmc rx171_cur
    .local pmc rx171_debug
    (rx171_cur, rx171_pos, rx171_tgt, $I10) = self."!cursor_start"()
    rx171_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx171_cur
    .local pmc match
    .lex "$/", match
    length rx171_eos, rx171_tgt
    gt rx171_pos, rx171_eos, rx171_done
    set rx171_off, 0
    lt rx171_pos, 2, rx171_start
    sub rx171_off, rx171_pos, 1
    substr rx171_tgt, rx171_tgt, rx171_off
  rx171_start:
    eq $I10, 1, rx171_restart
    if_null rx171_debug, debug_474
    rx171_cur."!cursor_debug"("START", "statementlist")
  debug_474:
    $I10 = self.'from'()
    ne $I10, -1, rxscan176_done
    goto rxscan176_scan
  rxscan176_loop:
    (rx171_pos) = rx171_cur."from"()
    inc rx171_pos
    rx171_cur."!cursor_from"(rx171_pos)
    ge rx171_pos, rx171_eos, rxscan176_done
  rxscan176_scan:
    set_addr $I10, rxscan176_loop
    rx171_cur."!mark_push"(0, rx171_pos, $I10)
  rxscan176_done:
  alt177_0:
.annotate 'line', 109
    set_addr $I10, alt177_1
    rx171_cur."!mark_push"(0, rx171_pos, $I10)
.annotate 'line', 110
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
  # rxanchor eos
    ne rx171_pos, rx171_eos, rx171_fail
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
    goto alt177_end
  alt177_1:
.annotate 'line', 111
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
  # rx rxquantr181 ** 0..*
    set_addr $I10, rxquantr181_done
    rx171_cur."!mark_push"(0, rx171_pos, $I10)
  rxquantr181_loop:
  # rx subrule "statement" subtype=capture negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."statement"()
    unless $P10, rx171_fail
    rx171_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx171_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."eat_terminator"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
    set_addr $I10, rxquantr181_done
    (rx171_rep) = rx171_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr181_done
    rx171_cur."!mark_push"(rx171_rep, rx171_pos, $I10)
    goto rxquantr181_loop
  rxquantr181_done:
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
  alt177_end:
.annotate 'line', 109
  # rx pass
    rx171_cur."!cursor_pass"(rx171_pos, "statementlist")
    if_null rx171_debug, debug_475
    rx171_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx171_pos)
  debug_475:
    .return (rx171_cur)
  rx171_restart:
.annotate 'line', 4
    if_null rx171_debug, debug_476
    rx171_cur."!cursor_debug"("NEXT", "statementlist")
  debug_476:
  rx171_fail:
    (rx171_rep, rx171_pos, $I10, $P10) = rx171_cur."!mark_fail"(0)
    lt rx171_pos, -1, rx171_done
    eq rx171_pos, -1, rx171_fail
    jump $I10
  rx171_done:
    rx171_cur."!cursor_fail"()
    if_null rx171_debug, debug_477
    rx171_cur."!cursor_debug"("FAIL", "statementlist")
  debug_477:
    .return (rx171_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1298845521.609") :method
.annotate 'line', 4
    $P173 = self."!PREFIX__!subrule"("ws", "")
    $P174 = self."!PREFIX__!subrule"("ws", "")
    new $P175, "ResizablePMCArray"
    push $P175, $P173
    push $P175, $P174
    .return ($P175)
.end


.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P190 = "35_1298845521.609" 
    capture_lex $P190
    .local string rx185_tgt
    .local int rx185_pos
    .local int rx185_off
    .local int rx185_eos
    .local int rx185_rep
    .local pmc rx185_cur
    .local pmc rx185_debug
    (rx185_cur, rx185_pos, rx185_tgt, $I10) = self."!cursor_start"()
    rx185_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx185_cur
    .local pmc match
    .lex "$/", match
    length rx185_eos, rx185_tgt
    gt rx185_pos, rx185_eos, rx185_done
    set rx185_off, 0
    lt rx185_pos, 2, rx185_start
    sub rx185_off, rx185_pos, 1
    substr rx185_tgt, rx185_tgt, rx185_off
  rx185_start:
    eq $I10, 1, rx185_restart
    if_null rx185_debug, debug_478
    rx185_cur."!cursor_debug"("START", "statement")
  debug_478:
    $I10 = self.'from'()
    ne $I10, -1, rxscan188_done
    goto rxscan188_scan
  rxscan188_loop:
    (rx185_pos) = rx185_cur."from"()
    inc rx185_pos
    rx185_cur."!cursor_from"(rx185_pos)
    ge rx185_pos, rx185_eos, rxscan188_done
  rxscan188_scan:
    set_addr $I10, rxscan188_loop
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxscan188_done:
.annotate 'line', 115
  # rx subrule "before" subtype=zerowidth negate=1
    rx185_cur."!cursor_pos"(rx185_pos)
    .const 'Sub' $P190 = "35_1298845521.609" 
    capture_lex $P190
    $P10 = rx185_cur."before"($P190)
    if $P10, rx185_fail
  alt194_0:
.annotate 'line', 116
    set_addr $I10, alt194_1
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
.annotate 'line', 117
  # rx subrule "statement_control" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."statement_control"()
    unless $P10, rx185_fail
    rx185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx185_pos = $P10."pos"()
    goto alt194_end
  alt194_1:
.annotate 'line', 118
  # rx subrule "EXPR" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."EXPR"()
    unless $P10, rx185_fail
    rx185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx185_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."ws"()
    unless $P10, rx185_fail
    rx185_pos = $P10."pos"()
.annotate 'line', 123
  # rx rxquantr195 ** 0..1
    set_addr $I10, rxquantr195_done
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxquantr195_loop:
  alt196_0:
.annotate 'line', 119
    set_addr $I10, alt196_1
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
.annotate 'line', 120
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."MARKED"("endstmt")
    unless $P10, rx185_fail
    goto alt196_end
  alt196_1:
    set_addr $I10, alt196_2
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
.annotate 'line', 121
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."statement_mod_cond"()
    unless $P10, rx185_fail
    rx185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx185_pos = $P10."pos"()
  # rx rxquantr197 ** 0..1
    set_addr $I10, rxquantr197_done
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxquantr197_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."statement_mod_loop"()
    unless $P10, rx185_fail
    goto rxsubrule198_pass
  rxsubrule198_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx185_fail
  rxsubrule198_pass:
    set_addr $I10, rxsubrule198_back
    rx185_cur."!mark_push"(0, rx185_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx185_pos = $P10."pos"()
    set_addr $I10, rxquantr197_done
    (rx185_rep) = rx185_cur."!mark_commit"($I10)
  rxquantr197_done:
    goto alt196_end
  alt196_2:
.annotate 'line', 122
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."statement_mod_loop"()
    unless $P10, rx185_fail
    rx185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx185_pos = $P10."pos"()
  alt196_end:
.annotate 'line', 123
    set_addr $I10, rxquantr195_done
    (rx185_rep) = rx185_cur."!mark_commit"($I10)
  rxquantr195_done:
  alt194_end:
.annotate 'line', 114
  # rx pass
    rx185_cur."!cursor_pass"(rx185_pos, "statement")
    if_null rx185_debug, debug_483
    rx185_cur."!cursor_debug"("PASS", "statement", " at pos=", rx185_pos)
  debug_483:
    .return (rx185_cur)
  rx185_restart:
.annotate 'line', 4
    if_null rx185_debug, debug_484
    rx185_cur."!cursor_debug"("NEXT", "statement")
  debug_484:
  rx185_fail:
    (rx185_rep, rx185_pos, $I10, $P10) = rx185_cur."!mark_fail"(0)
    lt rx185_pos, -1, rx185_done
    eq rx185_pos, -1, rx185_fail
    jump $I10
  rx185_done:
    rx185_cur."!cursor_fail"()
    if_null rx185_debug, debug_485
    rx185_cur."!cursor_debug"("FAIL", "statement")
  debug_485:
    .return (rx185_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1298845521.609") :method
.annotate 'line', 4
    new $P187, "ResizablePMCArray"
    push $P187, ""
    .return ($P187)
.end


.namespace ["NQP";"Grammar"]
.sub "_block189"  :anon :subid("35_1298845521.609") :method :outer("33_1298845521.609")
.annotate 'line', 115
    .local string rx191_tgt
    .local int rx191_pos
    .local int rx191_off
    .local int rx191_eos
    .local int rx191_rep
    .local pmc rx191_cur
    .local pmc rx191_debug
    (rx191_cur, rx191_pos, rx191_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx191_cur
    .local pmc match
    .lex "$/", match
    length rx191_eos, rx191_tgt
    gt rx191_pos, rx191_eos, rx191_done
    set rx191_off, 0
    lt rx191_pos, 2, rx191_start
    sub rx191_off, rx191_pos, 1
    substr rx191_tgt, rx191_tgt, rx191_off
  rx191_start:
    eq $I10, 1, rx191_restart
    if_null rx191_debug, debug_479
    rx191_cur."!cursor_debug"("START", "")
  debug_479:
    $I10 = self.'from'()
    ne $I10, -1, rxscan192_done
    goto rxscan192_scan
  rxscan192_loop:
    (rx191_pos) = rx191_cur."from"()
    inc rx191_pos
    rx191_cur."!cursor_from"(rx191_pos)
    ge rx191_pos, rx191_eos, rxscan192_done
  rxscan192_scan:
    set_addr $I10, rxscan192_loop
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
  rxscan192_done:
  alt193_0:
    set_addr $I10, alt193_1
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx191_pos, rx191_eos, rx191_fail
    sub $I10, rx191_pos, rx191_off
    substr $S10, rx191_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx191_fail
    inc rx191_pos
    goto alt193_end
  alt193_1:
  # rxanchor eos
    ne rx191_pos, rx191_eos, rx191_fail
  alt193_end:
  # rx pass
    rx191_cur."!cursor_pass"(rx191_pos, "")
    if_null rx191_debug, debug_480
    rx191_cur."!cursor_debug"("PASS", "", " at pos=", rx191_pos)
  debug_480:
    .return (rx191_cur)
  rx191_restart:
    if_null rx191_debug, debug_481
    rx191_cur."!cursor_debug"("NEXT", "")
  debug_481:
  rx191_fail:
    (rx191_rep, rx191_pos, $I10, $P10) = rx191_cur."!mark_fail"(0)
    lt rx191_pos, -1, rx191_done
    eq rx191_pos, -1, rx191_fail
    jump $I10
  rx191_done:
    rx191_cur."!cursor_fail"()
    if_null rx191_debug, debug_482
    rx191_cur."!cursor_debug"("FAIL", "")
  debug_482:
    .return (rx191_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_486
    rx200_cur."!cursor_debug"("START", "eat_terminator")
  debug_486:
    $I10 = self.'from'()
    ne $I10, -1, rxscan203_done
    goto rxscan203_scan
  rxscan203_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan203_done
  rxscan203_scan:
    set_addr $I10, rxscan203_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan203_done:
  alt204_0:
.annotate 'line', 127
    set_addr $I10, alt204_1
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 128
  # rx literal  ";"
    add $I11, rx200_pos, 1
    gt $I11, rx200_eos, rx200_fail
    sub $I11, rx200_pos, rx200_off
    ord $I11, rx200_tgt, $I11
    ne $I11, 59, rx200_fail
    add rx200_pos, 1
    goto alt204_end
  alt204_1:
    set_addr $I10, alt204_2
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 129
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."MARKED"("endstmt")
    unless $P10, rx200_fail
    goto alt204_end
  alt204_2:
    set_addr $I10, alt204_3
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 130
  # rx subrule "terminator" subtype=zerowidth negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."terminator"()
    unless $P10, rx200_fail
    goto alt204_end
  alt204_3:
.annotate 'line', 131
  # rxanchor eos
    ne rx200_pos, rx200_eos, rx200_fail
  alt204_end:
.annotate 'line', 127
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "eat_terminator")
    if_null rx200_debug, debug_487
    rx200_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx200_pos)
  debug_487:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 4
    if_null rx200_debug, debug_488
    rx200_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_488:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_489
    rx200_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_489:
    .return (rx200_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1298845521.609") :method
.annotate 'line', 4
    new $P202, "ResizablePMCArray"
    push $P202, ""
    push $P202, ""
    push $P202, ""
    push $P202, ";"
    .return ($P202)
.end


.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx206_tgt
    .local int rx206_pos
    .local int rx206_off
    .local int rx206_eos
    .local int rx206_rep
    .local pmc rx206_cur
    .local pmc rx206_debug
    (rx206_cur, rx206_pos, rx206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx206_cur
    .local pmc match
    .lex "$/", match
    length rx206_eos, rx206_tgt
    gt rx206_pos, rx206_eos, rx206_done
    set rx206_off, 0
    lt rx206_pos, 2, rx206_start
    sub rx206_off, rx206_pos, 1
    substr rx206_tgt, rx206_tgt, rx206_off
  rx206_start:
    eq $I10, 1, rx206_restart
    if_null rx206_debug, debug_490
    rx206_cur."!cursor_debug"("START", "xblock")
  debug_490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan210_done
    goto rxscan210_scan
  rxscan210_loop:
    (rx206_pos) = rx206_cur."from"()
    inc rx206_pos
    rx206_cur."!cursor_from"(rx206_pos)
    ge rx206_pos, rx206_eos, rxscan210_done
  rxscan210_scan:
    set_addr $I10, rxscan210_loop
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
  rxscan210_done:
.annotate 'line', 135
  # rx subrule "EXPR" subtype=capture negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."EXPR"()
    unless $P10, rx206_fail
    rx206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx206_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."ws"()
    unless $P10, rx206_fail
    rx206_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."pblock"()
    unless $P10, rx206_fail
    rx206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx206_pos = $P10."pos"()
.annotate 'line', 134
  # rx pass
    rx206_cur."!cursor_pass"(rx206_pos, "xblock")
    if_null rx206_debug, debug_491
    rx206_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx206_pos)
  debug_491:
    .return (rx206_cur)
  rx206_restart:
.annotate 'line', 4
    if_null rx206_debug, debug_492
    rx206_cur."!cursor_debug"("NEXT", "xblock")
  debug_492:
  rx206_fail:
    (rx206_rep, rx206_pos, $I10, $P10) = rx206_cur."!mark_fail"(0)
    lt rx206_pos, -1, rx206_done
    eq rx206_pos, -1, rx206_fail
    jump $I10
  rx206_done:
    rx206_cur."!cursor_fail"()
    if_null rx206_debug, debug_493
    rx206_cur."!cursor_debug"("FAIL", "xblock")
  debug_493:
    .return (rx206_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1298845521.609") :method
.annotate 'line', 4
    $P208 = self."!PREFIX__!subrule"("EXPR", "")
    new $P209, "ResizablePMCArray"
    push $P209, $P208
    .return ($P209)
.end


.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx212_tgt
    .local int rx212_pos
    .local int rx212_off
    .local int rx212_eos
    .local int rx212_rep
    .local pmc rx212_cur
    .local pmc rx212_debug
    (rx212_cur, rx212_pos, rx212_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx212_cur
    .local pmc match
    .lex "$/", match
    length rx212_eos, rx212_tgt
    gt rx212_pos, rx212_eos, rx212_done
    set rx212_off, 0
    lt rx212_pos, 2, rx212_start
    sub rx212_off, rx212_pos, 1
    substr rx212_tgt, rx212_tgt, rx212_off
  rx212_start:
    eq $I10, 1, rx212_restart
    if_null rx212_debug, debug_494
    rx212_cur."!cursor_debug"("START", "pblock")
  debug_494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    (rx212_pos) = rx212_cur."from"()
    inc rx212_pos
    rx212_cur."!cursor_from"(rx212_pos)
    ge rx212_pos, rx212_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  rxscan217_done:
  alt218_0:
.annotate 'line', 138
    set_addr $I10, alt218_1
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 139
  # rx subrule "lambda" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."lambda"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
.annotate 'line', 140
  # rx subrule "newpad" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."newpad"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
.annotate 'line', 141
  # rx subrule "signature" subtype=capture negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."signature"()
    unless $P10, rx212_fail
    rx212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx212_pos = $P10."pos"()
.annotate 'line', 142
  # rx subrule "blockoid" subtype=capture negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."blockoid"()
    unless $P10, rx212_fail
    rx212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx212_pos = $P10."pos"()
.annotate 'line', 139
    goto alt218_end
  alt218_1:
    set_addr $I10, alt218_2
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 143
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx212_pos, rx212_off
    substr $S10, rx212_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx212_fail
.annotate 'line', 144
  # rx subrule "newpad" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."newpad"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
.annotate 'line', 145
  # rx subrule "blockoid" subtype=capture negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."blockoid"()
    unless $P10, rx212_fail
    rx212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx212_pos = $P10."pos"()
.annotate 'line', 143
    goto alt218_end
  alt218_2:
.annotate 'line', 146
  # rx subrule "panic" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."panic"("Missing block")
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
  alt218_end:
.annotate 'line', 138
  # rx pass
    rx212_cur."!cursor_pass"(rx212_pos, "pblock")
    if_null rx212_debug, debug_495
    rx212_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx212_pos)
  debug_495:
    .return (rx212_cur)
  rx212_restart:
.annotate 'line', 4
    if_null rx212_debug, debug_496
    rx212_cur."!cursor_debug"("NEXT", "pblock")
  debug_496:
  rx212_fail:
    (rx212_rep, rx212_pos, $I10, $P10) = rx212_cur."!mark_fail"(0)
    lt rx212_pos, -1, rx212_done
    eq rx212_pos, -1, rx212_fail
    jump $I10
  rx212_done:
    rx212_cur."!cursor_fail"()
    if_null rx212_debug, debug_497
    rx212_cur."!cursor_debug"("FAIL", "pblock")
  debug_497:
    .return (rx212_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1298845521.609") :method
.annotate 'line', 4
    $P214 = self."!PREFIX__!subrule"("panic", "")
    $P215 = self."!PREFIX__!subrule"("lambda", "")
    new $P216, "ResizablePMCArray"
    push $P216, $P214
    push $P216, "{"
    push $P216, $P215
    .return ($P216)
.end


.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx220_tgt
    .local int rx220_pos
    .local int rx220_off
    .local int rx220_eos
    .local int rx220_rep
    .local pmc rx220_cur
    .local pmc rx220_debug
    (rx220_cur, rx220_pos, rx220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx220_cur
    .local pmc match
    .lex "$/", match
    length rx220_eos, rx220_tgt
    gt rx220_pos, rx220_eos, rx220_done
    set rx220_off, 0
    lt rx220_pos, 2, rx220_start
    sub rx220_off, rx220_pos, 1
    substr rx220_tgt, rx220_tgt, rx220_off
  rx220_start:
    eq $I10, 1, rx220_restart
    if_null rx220_debug, debug_498
    rx220_cur."!cursor_debug"("START", "lambda")
  debug_498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan223_done
    goto rxscan223_scan
  rxscan223_loop:
    (rx220_pos) = rx220_cur."from"()
    inc rx220_pos
    rx220_cur."!cursor_from"(rx220_pos)
    ge rx220_pos, rx220_eos, rxscan223_done
  rxscan223_scan:
    set_addr $I10, rxscan223_loop
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxscan223_done:
  alt224_0:
.annotate 'line', 149
    set_addr $I10, alt224_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  # rx literal  "->"
    add $I11, rx220_pos, 2
    gt $I11, rx220_eos, rx220_fail
    sub $I11, rx220_pos, rx220_off
    substr $S10, rx220_tgt, $I11, 2
    ne $S10, "->", rx220_fail
    add rx220_pos, 2
    goto alt224_end
  alt224_1:
  # rx literal  "<->"
    add $I11, rx220_pos, 3
    gt $I11, rx220_eos, rx220_fail
    sub $I11, rx220_pos, rx220_off
    substr $S10, rx220_tgt, $I11, 3
    ne $S10, "<->", rx220_fail
    add rx220_pos, 3
  alt224_end:
  # rx pass
    rx220_cur."!cursor_pass"(rx220_pos, "lambda")
    if_null rx220_debug, debug_499
    rx220_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx220_pos)
  debug_499:
    .return (rx220_cur)
  rx220_restart:
.annotate 'line', 4
    if_null rx220_debug, debug_500
    rx220_cur."!cursor_debug"("NEXT", "lambda")
  debug_500:
  rx220_fail:
    (rx220_rep, rx220_pos, $I10, $P10) = rx220_cur."!mark_fail"(0)
    lt rx220_pos, -1, rx220_done
    eq rx220_pos, -1, rx220_fail
    jump $I10
  rx220_done:
    rx220_cur."!cursor_fail"()
    if_null rx220_debug, debug_501
    rx220_cur."!cursor_debug"("FAIL", "lambda")
  debug_501:
    .return (rx220_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1298845521.609") :method
.annotate 'line', 4
    new $P222, "ResizablePMCArray"
    push $P222, "<->"
    push $P222, "->"
    .return ($P222)
.end


.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx226_tgt
    .local int rx226_pos
    .local int rx226_off
    .local int rx226_eos
    .local int rx226_rep
    .local pmc rx226_cur
    .local pmc rx226_debug
    (rx226_cur, rx226_pos, rx226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx226_cur
    .local pmc match
    .lex "$/", match
    length rx226_eos, rx226_tgt
    gt rx226_pos, rx226_eos, rx226_done
    set rx226_off, 0
    lt rx226_pos, 2, rx226_start
    sub rx226_off, rx226_pos, 1
    substr rx226_tgt, rx226_tgt, rx226_off
  rx226_start:
    eq $I10, 1, rx226_restart
    if_null rx226_debug, debug_502
    rx226_cur."!cursor_debug"("START", "block")
  debug_502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan230_done
    goto rxscan230_scan
  rxscan230_loop:
    (rx226_pos) = rx226_cur."from"()
    inc rx226_pos
    rx226_cur."!cursor_from"(rx226_pos)
    ge rx226_pos, rx226_eos, rxscan230_done
  rxscan230_scan:
    set_addr $I10, rxscan230_loop
    rx226_cur."!mark_push"(0, rx226_pos, $I10)
  rxscan230_done:
  alt231_0:
.annotate 'line', 152
    set_addr $I10, alt231_1
    rx226_cur."!mark_push"(0, rx226_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx226_pos, rx226_off
    substr $S10, rx226_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx226_fail
    goto alt231_end
  alt231_1:
  # rx subrule "panic" subtype=method negate=
    rx226_cur."!cursor_pos"(rx226_pos)
    $P10 = rx226_cur."panic"("Missing block")
    unless $P10, rx226_fail
    rx226_pos = $P10."pos"()
  alt231_end:
.annotate 'line', 153
  # rx subrule "newpad" subtype=method negate=
    rx226_cur."!cursor_pos"(rx226_pos)
    $P10 = rx226_cur."newpad"()
    unless $P10, rx226_fail
    rx226_pos = $P10."pos"()
.annotate 'line', 154
  # rx subrule "blockoid" subtype=capture negate=
    rx226_cur."!cursor_pos"(rx226_pos)
    $P10 = rx226_cur."blockoid"()
    unless $P10, rx226_fail
    rx226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx226_pos = $P10."pos"()
.annotate 'line', 151
  # rx pass
    rx226_cur."!cursor_pass"(rx226_pos, "block")
    if_null rx226_debug, debug_503
    rx226_cur."!cursor_debug"("PASS", "block", " at pos=", rx226_pos)
  debug_503:
    .return (rx226_cur)
  rx226_restart:
.annotate 'line', 4
    if_null rx226_debug, debug_504
    rx226_cur."!cursor_debug"("NEXT", "block")
  debug_504:
  rx226_fail:
    (rx226_rep, rx226_pos, $I10, $P10) = rx226_cur."!mark_fail"(0)
    lt rx226_pos, -1, rx226_done
    eq rx226_pos, -1, rx226_fail
    jump $I10
  rx226_done:
    rx226_cur."!cursor_fail"()
    if_null rx226_debug, debug_505
    rx226_cur."!cursor_debug"("FAIL", "block")
  debug_505:
    .return (rx226_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1298845521.609") :method
.annotate 'line', 4
    $P228 = self."!PREFIX__!subrule"("panic", "")
    new $P229, "ResizablePMCArray"
    push $P229, $P228
    push $P229, "{"
    .return ($P229)
.end


.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx233_tgt
    .local int rx233_pos
    .local int rx233_off
    .local int rx233_eos
    .local int rx233_rep
    .local pmc rx233_cur
    .local pmc rx233_debug
    (rx233_cur, rx233_pos, rx233_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx233_cur
    .local pmc match
    .lex "$/", match
    length rx233_eos, rx233_tgt
    gt rx233_pos, rx233_eos, rx233_done
    set rx233_off, 0
    lt rx233_pos, 2, rx233_start
    sub rx233_off, rx233_pos, 1
    substr rx233_tgt, rx233_tgt, rx233_off
  rx233_start:
    eq $I10, 1, rx233_restart
    if_null rx233_debug, debug_506
    rx233_cur."!cursor_debug"("START", "blockoid")
  debug_506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan237_done
    goto rxscan237_scan
  rxscan237_loop:
    (rx233_pos) = rx233_cur."from"()
    inc rx233_pos
    rx233_cur."!cursor_from"(rx233_pos)
    ge rx233_pos, rx233_eos, rxscan237_done
  rxscan237_scan:
    set_addr $I10, rxscan237_loop
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxscan237_done:
.annotate 'line', 158
  # rx subrule "finishpad" subtype=method negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."finishpad"()
    unless $P10, rx233_fail
    rx233_pos = $P10."pos"()
  alt238_0:
.annotate 'line', 159
    set_addr $I10, alt238_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
.annotate 'line', 160
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx233_pos, 14
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    substr $S10, rx233_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx233_fail
    add rx233_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."you_are_here"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx233_pos = $P10."pos"()
    goto alt238_end
  alt238_1:
.annotate 'line', 161
  # rx literal  "{"
    add $I11, rx233_pos, 1
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    ord $I11, rx233_tgt, $I11
    ne $I11, 123, rx233_fail
    add rx233_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statementlist"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx233_pos = $P10."pos"()
  alt239_0:
    set_addr $I10, alt239_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  # rx literal  "}"
    add $I11, rx233_pos, 1
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    ord $I11, rx233_tgt, $I11
    ne $I11, 125, rx233_fail
    add rx233_pos, 1
    goto alt239_end
  alt239_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."FAILGOAL"("'}'")
    unless $P10, rx233_fail
    goto rxsubrule241_pass
  rxsubrule241_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx233_fail
  rxsubrule241_pass:
    set_addr $I10, rxsubrule241_back
    rx233_cur."!mark_push"(0, rx233_pos, $I10, $P10)
    rx233_pos = $P10."pos"()
  alt239_end:
  alt238_end:
.annotate 'line', 163
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."ENDSTMT"()
    unless $P10, rx233_fail
.annotate 'line', 157
  # rx pass
    rx233_cur."!cursor_pass"(rx233_pos, "blockoid")
    if_null rx233_debug, debug_507
    rx233_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx233_pos)
  debug_507:
    .return (rx233_cur)
  rx233_restart:
.annotate 'line', 4
    if_null rx233_debug, debug_508
    rx233_cur."!cursor_debug"("NEXT", "blockoid")
  debug_508:
  rx233_fail:
    (rx233_rep, rx233_pos, $I10, $P10) = rx233_cur."!mark_fail"(0)
    lt rx233_pos, -1, rx233_done
    eq rx233_pos, -1, rx233_fail
    jump $I10
  rx233_done:
    rx233_cur."!cursor_fail"()
    if_null rx233_debug, debug_509
    rx233_cur."!cursor_debug"("FAIL", "blockoid")
  debug_509:
    .return (rx233_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1298845521.609") :method
.annotate 'line', 4
    $P235 = self."!PREFIX__!subrule"("finishpad", "")
    new $P236, "ResizablePMCArray"
    push $P236, $P235
    .return ($P236)
.end


.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx243_tgt
    .local int rx243_pos
    .local int rx243_off
    .local int rx243_eos
    .local int rx243_rep
    .local pmc rx243_cur
    .local pmc rx243_debug
    (rx243_cur, rx243_pos, rx243_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx243_cur
    .local pmc match
    .lex "$/", match
    length rx243_eos, rx243_tgt
    gt rx243_pos, rx243_eos, rx243_done
    set rx243_off, 0
    lt rx243_pos, 2, rx243_start
    sub rx243_off, rx243_pos, 1
    substr rx243_tgt, rx243_tgt, rx243_off
  rx243_start:
    eq $I10, 1, rx243_restart
    if_null rx243_debug, debug_510
    rx243_cur."!cursor_debug"("START", "newpad")
  debug_510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan246_done
    goto rxscan246_scan
  rxscan246_loop:
    (rx243_pos) = rx243_cur."from"()
    inc rx243_pos
    rx243_cur."!cursor_from"(rx243_pos)
    ge rx243_pos, rx243_eos, rxscan246_done
  rxscan246_scan:
    set_addr $I10, rxscan246_loop
    rx243_cur."!mark_push"(0, rx243_pos, $I10)
  rxscan246_done:
.annotate 'line', 166
  # rx pass
    rx243_cur."!cursor_pass"(rx243_pos, "newpad")
    if_null rx243_debug, debug_511
    rx243_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx243_pos)
  debug_511:
    .return (rx243_cur)
  rx243_restart:
.annotate 'line', 4
    if_null rx243_debug, debug_512
    rx243_cur."!cursor_debug"("NEXT", "newpad")
  debug_512:
  rx243_fail:
    (rx243_rep, rx243_pos, $I10, $P10) = rx243_cur."!mark_fail"(0)
    lt rx243_pos, -1, rx243_done
    eq rx243_pos, -1, rx243_fail
    jump $I10
  rx243_done:
    rx243_cur."!cursor_fail"()
    if_null rx243_debug, debug_513
    rx243_cur."!cursor_debug"("FAIL", "newpad")
  debug_513:
    .return (rx243_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1298845521.609") :method
.annotate 'line', 4
    new $P245, "ResizablePMCArray"
    push $P245, ""
    .return ($P245)
.end


.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx248_tgt
    .local int rx248_pos
    .local int rx248_off
    .local int rx248_eos
    .local int rx248_rep
    .local pmc rx248_cur
    .local pmc rx248_debug
    (rx248_cur, rx248_pos, rx248_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx248_cur
    .local pmc match
    .lex "$/", match
    length rx248_eos, rx248_tgt
    gt rx248_pos, rx248_eos, rx248_done
    set rx248_off, 0
    lt rx248_pos, 2, rx248_start
    sub rx248_off, rx248_pos, 1
    substr rx248_tgt, rx248_tgt, rx248_off
  rx248_start:
    eq $I10, 1, rx248_restart
    if_null rx248_debug, debug_514
    rx248_cur."!cursor_debug"("START", "outerctx")
  debug_514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan251_done
    goto rxscan251_scan
  rxscan251_loop:
    (rx248_pos) = rx248_cur."from"()
    inc rx248_pos
    rx248_cur."!cursor_from"(rx248_pos)
    ge rx248_pos, rx248_eos, rxscan251_done
  rxscan251_scan:
    set_addr $I10, rxscan251_loop
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
  rxscan251_done:
.annotate 'line', 167
  # rx pass
    rx248_cur."!cursor_pass"(rx248_pos, "outerctx")
    if_null rx248_debug, debug_515
    rx248_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx248_pos)
  debug_515:
    .return (rx248_cur)
  rx248_restart:
.annotate 'line', 4
    if_null rx248_debug, debug_516
    rx248_cur."!cursor_debug"("NEXT", "outerctx")
  debug_516:
  rx248_fail:
    (rx248_rep, rx248_pos, $I10, $P10) = rx248_cur."!mark_fail"(0)
    lt rx248_pos, -1, rx248_done
    eq rx248_pos, -1, rx248_fail
    jump $I10
  rx248_done:
    rx248_cur."!cursor_fail"()
    if_null rx248_debug, debug_517
    rx248_cur."!cursor_debug"("FAIL", "outerctx")
  debug_517:
    .return (rx248_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1298845521.609") :method
.annotate 'line', 4
    new $P250, "ResizablePMCArray"
    push $P250, ""
    .return ($P250)
.end


.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx253_tgt
    .local int rx253_pos
    .local int rx253_off
    .local int rx253_eos
    .local int rx253_rep
    .local pmc rx253_cur
    .local pmc rx253_debug
    (rx253_cur, rx253_pos, rx253_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx253_cur
    .local pmc match
    .lex "$/", match
    length rx253_eos, rx253_tgt
    gt rx253_pos, rx253_eos, rx253_done
    set rx253_off, 0
    lt rx253_pos, 2, rx253_start
    sub rx253_off, rx253_pos, 1
    substr rx253_tgt, rx253_tgt, rx253_off
  rx253_start:
    eq $I10, 1, rx253_restart
    if_null rx253_debug, debug_518
    rx253_cur."!cursor_debug"("START", "finishpad")
  debug_518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan256_done
    goto rxscan256_scan
  rxscan256_loop:
    (rx253_pos) = rx253_cur."from"()
    inc rx253_pos
    rx253_cur."!cursor_from"(rx253_pos)
    ge rx253_pos, rx253_eos, rxscan256_done
  rxscan256_scan:
    set_addr $I10, rxscan256_loop
    rx253_cur."!mark_push"(0, rx253_pos, $I10)
  rxscan256_done:
.annotate 'line', 168
  # rx pass
    rx253_cur."!cursor_pass"(rx253_pos, "finishpad")
    if_null rx253_debug, debug_519
    rx253_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx253_pos)
  debug_519:
    .return (rx253_cur)
  rx253_restart:
.annotate 'line', 4
    if_null rx253_debug, debug_520
    rx253_cur."!cursor_debug"("NEXT", "finishpad")
  debug_520:
  rx253_fail:
    (rx253_rep, rx253_pos, $I10, $P10) = rx253_cur."!mark_fail"(0)
    lt rx253_pos, -1, rx253_done
    eq rx253_pos, -1, rx253_fail
    jump $I10
  rx253_done:
    rx253_cur."!cursor_fail"()
    if_null rx253_debug, debug_521
    rx253_cur."!cursor_debug"("FAIL", "finishpad")
  debug_521:
    .return (rx253_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1298845521.609") :method
.annotate 'line', 4
    new $P255, "ResizablePMCArray"
    push $P255, ""
    .return ($P255)
.end


.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("54_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx258_tgt
    .local int rx258_pos
    .local int rx258_off
    .local int rx258_eos
    .local int rx258_rep
    .local pmc rx258_cur
    .local pmc rx258_debug
    (rx258_cur, rx258_pos, rx258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx258_cur
    .local pmc match
    .lex "$/", match
    length rx258_eos, rx258_tgt
    gt rx258_pos, rx258_eos, rx258_done
    set rx258_off, 0
    lt rx258_pos, 2, rx258_start
    sub rx258_off, rx258_pos, 1
    substr rx258_tgt, rx258_tgt, rx258_off
  rx258_start:
    eq $I10, 1, rx258_restart
    if_null rx258_debug, debug_522
    rx258_cur."!cursor_debug"("START", "you_are_here")
  debug_522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan261_done
    goto rxscan261_scan
  rxscan261_loop:
    (rx258_pos) = rx258_cur."from"()
    inc rx258_pos
    rx258_cur."!cursor_from"(rx258_pos)
    ge rx258_pos, rx258_eos, rxscan261_done
  rxscan261_scan:
    set_addr $I10, rxscan261_loop
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  rxscan261_done:
.annotate 'line', 169
  # rx pass
    rx258_cur."!cursor_pass"(rx258_pos, "you_are_here")
    if_null rx258_debug, debug_523
    rx258_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx258_pos)
  debug_523:
    .return (rx258_cur)
  rx258_restart:
.annotate 'line', 4
    if_null rx258_debug, debug_524
    rx258_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_524:
  rx258_fail:
    (rx258_rep, rx258_pos, $I10, $P10) = rx258_cur."!mark_fail"(0)
    lt rx258_pos, -1, rx258_done
    eq rx258_pos, -1, rx258_fail
    jump $I10
  rx258_done:
    rx258_cur."!cursor_fail"()
    if_null rx258_debug, debug_525
    rx258_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_525:
    .return (rx258_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("55_1298845521.609") :method
.annotate 'line', 4
    new $P260, "ResizablePMCArray"
    push $P260, ""
    .return ($P260)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("56_1298845521.609")
    .param pmc param_263
.annotate 'line', 171
    .lex "self", param_263
    $P264 = param_263."!protoregex"("terminator")
    .return ($P264)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("57_1298845521.609")
    .param pmc param_266
.annotate 'line', 171
    .lex "self", param_266
    $P267 = param_266."!PREFIX__!protoregex"("terminator")
    .return ($P267)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("58_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx269_tgt
    .local int rx269_pos
    .local int rx269_off
    .local int rx269_eos
    .local int rx269_rep
    .local pmc rx269_cur
    .local pmc rx269_debug
    (rx269_cur, rx269_pos, rx269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx269_cur
    .local pmc match
    .lex "$/", match
    length rx269_eos, rx269_tgt
    gt rx269_pos, rx269_eos, rx269_done
    set rx269_off, 0
    lt rx269_pos, 2, rx269_start
    sub rx269_off, rx269_pos, 1
    substr rx269_tgt, rx269_tgt, rx269_off
  rx269_start:
    eq $I10, 1, rx269_restart
    if_null rx269_debug, debug_526
    rx269_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan272_done
    goto rxscan272_scan
  rxscan272_loop:
    (rx269_pos) = rx269_cur."from"()
    inc rx269_pos
    rx269_cur."!cursor_from"(rx269_pos)
    ge rx269_pos, rx269_eos, rxscan272_done
  rxscan272_scan:
    set_addr $I10, rxscan272_loop
    rx269_cur."!mark_push"(0, rx269_pos, $I10)
  rxscan272_done:
.annotate 'line', 173
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx269_pos, rx269_off
    substr $S10, rx269_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx269_fail
  # rx pass
    rx269_cur."!cursor_pass"(rx269_pos, "terminator:sym<;>")
    if_null rx269_debug, debug_527
    rx269_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx269_pos)
  debug_527:
    .return (rx269_cur)
  rx269_restart:
.annotate 'line', 4
    if_null rx269_debug, debug_528
    rx269_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_528:
  rx269_fail:
    (rx269_rep, rx269_pos, $I10, $P10) = rx269_cur."!mark_fail"(0)
    lt rx269_pos, -1, rx269_done
    eq rx269_pos, -1, rx269_fail
    jump $I10
  rx269_done:
    rx269_cur."!cursor_fail"()
    if_null rx269_debug, debug_529
    rx269_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_529:
    .return (rx269_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("59_1298845521.609") :method
.annotate 'line', 4
    new $P271, "ResizablePMCArray"
    push $P271, ";"
    .return ($P271)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("60_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx274_tgt
    .local int rx274_pos
    .local int rx274_off
    .local int rx274_eos
    .local int rx274_rep
    .local pmc rx274_cur
    .local pmc rx274_debug
    (rx274_cur, rx274_pos, rx274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx274_cur
    .local pmc match
    .lex "$/", match
    length rx274_eos, rx274_tgt
    gt rx274_pos, rx274_eos, rx274_done
    set rx274_off, 0
    lt rx274_pos, 2, rx274_start
    sub rx274_off, rx274_pos, 1
    substr rx274_tgt, rx274_tgt, rx274_off
  rx274_start:
    eq $I10, 1, rx274_restart
    if_null rx274_debug, debug_530
    rx274_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_530:
    $I10 = self.'from'()
    ne $I10, -1, rxscan277_done
    goto rxscan277_scan
  rxscan277_loop:
    (rx274_pos) = rx274_cur."from"()
    inc rx274_pos
    rx274_cur."!cursor_from"(rx274_pos)
    ge rx274_pos, rx274_eos, rxscan277_done
  rxscan277_scan:
    set_addr $I10, rxscan277_loop
    rx274_cur."!mark_push"(0, rx274_pos, $I10)
  rxscan277_done:
.annotate 'line', 174
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx274_pos, rx274_off
    substr $S10, rx274_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx274_fail
  # rx pass
    rx274_cur."!cursor_pass"(rx274_pos, "terminator:sym<}>")
    if_null rx274_debug, debug_531
    rx274_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx274_pos)
  debug_531:
    .return (rx274_cur)
  rx274_restart:
.annotate 'line', 4
    if_null rx274_debug, debug_532
    rx274_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_532:
  rx274_fail:
    (rx274_rep, rx274_pos, $I10, $P10) = rx274_cur."!mark_fail"(0)
    lt rx274_pos, -1, rx274_done
    eq rx274_pos, -1, rx274_fail
    jump $I10
  rx274_done:
    rx274_cur."!cursor_fail"()
    if_null rx274_debug, debug_533
    rx274_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_533:
    .return (rx274_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("61_1298845521.609") :method
.annotate 'line', 4
    new $P276, "ResizablePMCArray"
    push $P276, "}"
    .return ($P276)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("62_1298845521.609")
    .param pmc param_279
.annotate 'line', 178
    .lex "self", param_279
    $P280 = param_279."!protoregex"("statement_control")
    .return ($P280)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("63_1298845521.609")
    .param pmc param_282
.annotate 'line', 178
    .lex "self", param_282
    $P283 = param_282."!PREFIX__!protoregex"("statement_control")
    .return ($P283)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("64_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx285_tgt
    .local int rx285_pos
    .local int rx285_off
    .local int rx285_eos
    .local int rx285_rep
    .local pmc rx285_cur
    .local pmc rx285_debug
    (rx285_cur, rx285_pos, rx285_tgt, $I10) = self."!cursor_start"()
    rx285_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx285_cur
    .local pmc match
    .lex "$/", match
    length rx285_eos, rx285_tgt
    gt rx285_pos, rx285_eos, rx285_done
    set rx285_off, 0
    lt rx285_pos, 2, rx285_start
    sub rx285_off, rx285_pos, 1
    substr rx285_tgt, rx285_tgt, rx285_off
  rx285_start:
    eq $I10, 1, rx285_restart
    if_null rx285_debug, debug_534
    rx285_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_534:
    $I10 = self.'from'()
    ne $I10, -1, rxscan288_done
    goto rxscan288_scan
  rxscan288_loop:
    (rx285_pos) = rx285_cur."from"()
    inc rx285_pos
    rx285_cur."!cursor_from"(rx285_pos)
    ge rx285_pos, rx285_eos, rxscan288_done
  rxscan288_scan:
    set_addr $I10, rxscan288_loop
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  rxscan288_done:
.annotate 'line', 181
  # rx subcapture "sym"
    set_addr $I10, rxcap_289_fail
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  # rx literal  "if"
    add $I11, rx285_pos, 2
    gt $I11, rx285_eos, rx285_fail
    sub $I11, rx285_pos, rx285_off
    substr $S10, rx285_tgt, $I11, 2
    ne $S10, "if", rx285_fail
    add rx285_pos, 2
    set_addr $I10, rxcap_289_fail
    ($I12, $I11) = rx285_cur."!mark_peek"($I10)
    rx285_cur."!cursor_pos"($I11)
    ($P10) = rx285_cur."!cursor_start"()
    $P10."!cursor_pass"(rx285_pos, "")
    rx285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_289_done
  rxcap_289_fail:
    goto rx285_fail
  rxcap_289_done:
  # rx charclass s
    ge rx285_pos, rx285_eos, rx285_fail
    sub $I10, rx285_pos, rx285_off
    is_cclass $I11, 32, rx285_tgt, $I10
    unless $I11, rx285_fail
    inc rx285_pos
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
.annotate 'line', 182
  # rx subrule "xblock" subtype=capture negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."xblock"()
    unless $P10, rx285_fail
    rx285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx285_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
.annotate 'line', 183
  # rx rxquantr292 ** 0..*
    set_addr $I10, rxquantr292_done
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  rxquantr292_loop:
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx285_pos, 5
    gt $I11, rx285_eos, rx285_fail
    sub $I11, rx285_pos, rx285_off
    substr $S10, rx285_tgt, $I11, 5
    ne $S10, "elsif", rx285_fail
    add rx285_pos, 5
  # rx charclass s
    ge rx285_pos, rx285_eos, rx285_fail
    sub $I10, rx285_pos, rx285_off
    is_cclass $I11, 32, rx285_tgt, $I10
    unless $I11, rx285_fail
    inc rx285_pos
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."xblock"()
    unless $P10, rx285_fail
    rx285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx285_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
    set_addr $I10, rxquantr292_done
    (rx285_rep) = rx285_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr292_done
    rx285_cur."!mark_push"(rx285_rep, rx285_pos, $I10)
    goto rxquantr292_loop
  rxquantr292_done:
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
.annotate 'line', 184
  # rx rxquantr297 ** 0..1
    set_addr $I10, rxquantr297_done
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  rxquantr297_loop:
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx285_pos, 4
    gt $I11, rx285_eos, rx285_fail
    sub $I11, rx285_pos, rx285_off
    substr $S10, rx285_tgt, $I11, 4
    ne $S10, "else", rx285_fail
    add rx285_pos, 4
  # rx charclass s
    ge rx285_pos, rx285_eos, rx285_fail
    sub $I10, rx285_pos, rx285_off
    is_cclass $I11, 32, rx285_tgt, $I10
    unless $I11, rx285_fail
    inc rx285_pos
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."pblock"()
    unless $P10, rx285_fail
    rx285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx285_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
    set_addr $I10, rxquantr297_done
    (rx285_rep) = rx285_cur."!mark_commit"($I10)
  rxquantr297_done:
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
.annotate 'line', 180
  # rx pass
    rx285_cur."!cursor_pass"(rx285_pos, "statement_control:sym<if>")
    if_null rx285_debug, debug_535
    rx285_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx285_pos)
  debug_535:
    .return (rx285_cur)
  rx285_restart:
.annotate 'line', 4
    if_null rx285_debug, debug_536
    rx285_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_536:
  rx285_fail:
    (rx285_rep, rx285_pos, $I10, $P10) = rx285_cur."!mark_fail"(0)
    lt rx285_pos, -1, rx285_done
    eq rx285_pos, -1, rx285_fail
    jump $I10
  rx285_done:
    rx285_cur."!cursor_fail"()
    if_null rx285_debug, debug_537
    rx285_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_537:
    .return (rx285_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("65_1298845521.609") :method
.annotate 'line', 4
    new $P287, "ResizablePMCArray"
    push $P287, "if"
    .return ($P287)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("66_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P313 = "68_1298845521.609" 
    capture_lex $P313
    .local string rx303_tgt
    .local int rx303_pos
    .local int rx303_off
    .local int rx303_eos
    .local int rx303_rep
    .local pmc rx303_cur
    .local pmc rx303_debug
    (rx303_cur, rx303_pos, rx303_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx303_cur
    .local pmc match
    .lex "$/", match
    length rx303_eos, rx303_tgt
    gt rx303_pos, rx303_eos, rx303_done
    set rx303_off, 0
    lt rx303_pos, 2, rx303_start
    sub rx303_off, rx303_pos, 1
    substr rx303_tgt, rx303_tgt, rx303_off
  rx303_start:
    eq $I10, 1, rx303_restart
    if_null rx303_debug, debug_538
    rx303_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan306_done
    goto rxscan306_scan
  rxscan306_loop:
    (rx303_pos) = rx303_cur."from"()
    inc rx303_pos
    rx303_cur."!cursor_from"(rx303_pos)
    ge rx303_pos, rx303_eos, rxscan306_done
  rxscan306_scan:
    set_addr $I10, rxscan306_loop
    rx303_cur."!mark_push"(0, rx303_pos, $I10)
  rxscan306_done:
.annotate 'line', 188
  # rx subcapture "sym"
    set_addr $I10, rxcap_307_fail
    rx303_cur."!mark_push"(0, rx303_pos, $I10)
  # rx literal  "unless"
    add $I11, rx303_pos, 6
    gt $I11, rx303_eos, rx303_fail
    sub $I11, rx303_pos, rx303_off
    substr $S10, rx303_tgt, $I11, 6
    ne $S10, "unless", rx303_fail
    add rx303_pos, 6
    set_addr $I10, rxcap_307_fail
    ($I12, $I11) = rx303_cur."!mark_peek"($I10)
    rx303_cur."!cursor_pos"($I11)
    ($P10) = rx303_cur."!cursor_start"()
    $P10."!cursor_pass"(rx303_pos, "")
    rx303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_307_done
  rxcap_307_fail:
    goto rx303_fail
  rxcap_307_done:
  # rx charclass s
    ge rx303_pos, rx303_eos, rx303_fail
    sub $I10, rx303_pos, rx303_off
    is_cclass $I11, 32, rx303_tgt, $I10
    unless $I11, rx303_fail
    inc rx303_pos
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
.annotate 'line', 189
  # rx subrule "xblock" subtype=capture negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."xblock"()
    unless $P10, rx303_fail
    rx303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx303_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  alt310_0:
.annotate 'line', 190
    set_addr $I10, alt310_1
    rx303_cur."!mark_push"(0, rx303_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx303_cur."!cursor_pos"(rx303_pos)
    .const 'Sub' $P313 = "68_1298845521.609" 
    capture_lex $P313
    $P10 = rx303_cur."before"($P313)
    if $P10, rx303_fail
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
    goto alt310_end
  alt310_1:
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  alt310_end:
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
.annotate 'line', 187
  # rx pass
    rx303_cur."!cursor_pass"(rx303_pos, "statement_control:sym<unless>")
    if_null rx303_debug, debug_543
    rx303_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx303_pos)
  debug_543:
    .return (rx303_cur)
  rx303_restart:
.annotate 'line', 4
    if_null rx303_debug, debug_544
    rx303_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_544:
  rx303_fail:
    (rx303_rep, rx303_pos, $I10, $P10) = rx303_cur."!mark_fail"(0)
    lt rx303_pos, -1, rx303_done
    eq rx303_pos, -1, rx303_fail
    jump $I10
  rx303_done:
    rx303_cur."!cursor_fail"()
    if_null rx303_debug, debug_545
    rx303_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_545:
    .return (rx303_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("67_1298845521.609") :method
.annotate 'line', 4
    new $P305, "ResizablePMCArray"
    push $P305, "unless"
    .return ($P305)
.end


.namespace ["NQP";"Grammar"]
.sub "_block312"  :anon :subid("68_1298845521.609") :method :outer("66_1298845521.609")
.annotate 'line', 190
    .local string rx314_tgt
    .local int rx314_pos
    .local int rx314_off
    .local int rx314_eos
    .local int rx314_rep
    .local pmc rx314_cur
    .local pmc rx314_debug
    (rx314_cur, rx314_pos, rx314_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx314_cur
    .local pmc match
    .lex "$/", match
    length rx314_eos, rx314_tgt
    gt rx314_pos, rx314_eos, rx314_done
    set rx314_off, 0
    lt rx314_pos, 2, rx314_start
    sub rx314_off, rx314_pos, 1
    substr rx314_tgt, rx314_tgt, rx314_off
  rx314_start:
    eq $I10, 1, rx314_restart
    if_null rx314_debug, debug_539
    rx314_cur."!cursor_debug"("START", "")
  debug_539:
    $I10 = self.'from'()
    ne $I10, -1, rxscan315_done
    goto rxscan315_scan
  rxscan315_loop:
    (rx314_pos) = rx314_cur."from"()
    inc rx314_pos
    rx314_cur."!cursor_from"(rx314_pos)
    ge rx314_pos, rx314_eos, rxscan315_done
  rxscan315_scan:
    set_addr $I10, rxscan315_loop
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxscan315_done:
  # rx literal  "else"
    add $I11, rx314_pos, 4
    gt $I11, rx314_eos, rx314_fail
    sub $I11, rx314_pos, rx314_off
    substr $S10, rx314_tgt, $I11, 4
    ne $S10, "else", rx314_fail
    add rx314_pos, 4
  # rx pass
    rx314_cur."!cursor_pass"(rx314_pos, "")
    if_null rx314_debug, debug_540
    rx314_cur."!cursor_debug"("PASS", "", " at pos=", rx314_pos)
  debug_540:
    .return (rx314_cur)
  rx314_restart:
    if_null rx314_debug, debug_541
    rx314_cur."!cursor_debug"("NEXT", "")
  debug_541:
  rx314_fail:
    (rx314_rep, rx314_pos, $I10, $P10) = rx314_cur."!mark_fail"(0)
    lt rx314_pos, -1, rx314_done
    eq rx314_pos, -1, rx314_fail
    jump $I10
  rx314_done:
    rx314_cur."!cursor_fail"()
    if_null rx314_debug, debug_542
    rx314_cur."!cursor_debug"("FAIL", "")
  debug_542:
    .return (rx314_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("69_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx321_tgt
    .local int rx321_pos
    .local int rx321_off
    .local int rx321_eos
    .local int rx321_rep
    .local pmc rx321_cur
    .local pmc rx321_debug
    (rx321_cur, rx321_pos, rx321_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx321_cur
    .local pmc match
    .lex "$/", match
    length rx321_eos, rx321_tgt
    gt rx321_pos, rx321_eos, rx321_done
    set rx321_off, 0
    lt rx321_pos, 2, rx321_start
    sub rx321_off, rx321_pos, 1
    substr rx321_tgt, rx321_tgt, rx321_off
  rx321_start:
    eq $I10, 1, rx321_restart
    if_null rx321_debug, debug_546
    rx321_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan324_done
    goto rxscan324_scan
  rxscan324_loop:
    (rx321_pos) = rx321_cur."from"()
    inc rx321_pos
    rx321_cur."!cursor_from"(rx321_pos)
    ge rx321_pos, rx321_eos, rxscan324_done
  rxscan324_scan:
    set_addr $I10, rxscan324_loop
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  rxscan324_done:
.annotate 'line', 194
  # rx subcapture "sym"
    set_addr $I10, rxcap_326_fail
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  alt325_0:
    set_addr $I10, alt325_1
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  # rx literal  "while"
    add $I11, rx321_pos, 5
    gt $I11, rx321_eos, rx321_fail
    sub $I11, rx321_pos, rx321_off
    substr $S10, rx321_tgt, $I11, 5
    ne $S10, "while", rx321_fail
    add rx321_pos, 5
    goto alt325_end
  alt325_1:
  # rx literal  "until"
    add $I11, rx321_pos, 5
    gt $I11, rx321_eos, rx321_fail
    sub $I11, rx321_pos, rx321_off
    substr $S10, rx321_tgt, $I11, 5
    ne $S10, "until", rx321_fail
    add rx321_pos, 5
  alt325_end:
    set_addr $I10, rxcap_326_fail
    ($I12, $I11) = rx321_cur."!mark_peek"($I10)
    rx321_cur."!cursor_pos"($I11)
    ($P10) = rx321_cur."!cursor_start"()
    $P10."!cursor_pass"(rx321_pos, "")
    rx321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_326_done
  rxcap_326_fail:
    goto rx321_fail
  rxcap_326_done:
  # rx charclass s
    ge rx321_pos, rx321_eos, rx321_fail
    sub $I10, rx321_pos, rx321_off
    is_cclass $I11, 32, rx321_tgt, $I10
    unless $I11, rx321_fail
    inc rx321_pos
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
.annotate 'line', 195
  # rx subrule "xblock" subtype=capture negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."xblock"()
    unless $P10, rx321_fail
    rx321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx321_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
.annotate 'line', 193
  # rx pass
    rx321_cur."!cursor_pass"(rx321_pos, "statement_control:sym<while>")
    if_null rx321_debug, debug_547
    rx321_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx321_pos)
  debug_547:
    .return (rx321_cur)
  rx321_restart:
.annotate 'line', 4
    if_null rx321_debug, debug_548
    rx321_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_548:
  rx321_fail:
    (rx321_rep, rx321_pos, $I10, $P10) = rx321_cur."!mark_fail"(0)
    lt rx321_pos, -1, rx321_done
    eq rx321_pos, -1, rx321_fail
    jump $I10
  rx321_done:
    rx321_cur."!cursor_fail"()
    if_null rx321_debug, debug_549
    rx321_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_549:
    .return (rx321_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("70_1298845521.609") :method
.annotate 'line', 4
    new $P323, "ResizablePMCArray"
    push $P323, "until"
    push $P323, "while"
    .return ($P323)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("71_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx330_tgt
    .local int rx330_pos
    .local int rx330_off
    .local int rx330_eos
    .local int rx330_rep
    .local pmc rx330_cur
    .local pmc rx330_debug
    (rx330_cur, rx330_pos, rx330_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx330_cur
    .local pmc match
    .lex "$/", match
    length rx330_eos, rx330_tgt
    gt rx330_pos, rx330_eos, rx330_done
    set rx330_off, 0
    lt rx330_pos, 2, rx330_start
    sub rx330_off, rx330_pos, 1
    substr rx330_tgt, rx330_tgt, rx330_off
  rx330_start:
    eq $I10, 1, rx330_restart
    if_null rx330_debug, debug_550
    rx330_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_550:
    $I10 = self.'from'()
    ne $I10, -1, rxscan333_done
    goto rxscan333_scan
  rxscan333_loop:
    (rx330_pos) = rx330_cur."from"()
    inc rx330_pos
    rx330_cur."!cursor_from"(rx330_pos)
    ge rx330_pos, rx330_eos, rxscan333_done
  rxscan333_scan:
    set_addr $I10, rxscan333_loop
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  rxscan333_done:
.annotate 'line', 199
  # rx subcapture "sym"
    set_addr $I10, rxcap_334_fail
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx330_pos, 6
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 6
    ne $S10, "repeat", rx330_fail
    add rx330_pos, 6
    set_addr $I10, rxcap_334_fail
    ($I12, $I11) = rx330_cur."!mark_peek"($I10)
    rx330_cur."!cursor_pos"($I11)
    ($P10) = rx330_cur."!cursor_start"()
    $P10."!cursor_pass"(rx330_pos, "")
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_334_done
  rxcap_334_fail:
    goto rx330_fail
  rxcap_334_done:
  # rx charclass s
    ge rx330_pos, rx330_eos, rx330_fail
    sub $I10, rx330_pos, rx330_off
    is_cclass $I11, 32, rx330_tgt, $I10
    unless $I11, rx330_fail
    inc rx330_pos
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  alt336_0:
.annotate 'line', 200
    set_addr $I10, alt336_1
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
.annotate 'line', 201
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_339_fail
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  alt338_0:
    set_addr $I10, alt338_1
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  # rx literal  "while"
    add $I11, rx330_pos, 5
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 5
    ne $S10, "while", rx330_fail
    add rx330_pos, 5
    goto alt338_end
  alt338_1:
  # rx literal  "until"
    add $I11, rx330_pos, 5
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 5
    ne $S10, "until", rx330_fail
    add rx330_pos, 5
  alt338_end:
    set_addr $I10, rxcap_339_fail
    ($I12, $I11) = rx330_cur."!mark_peek"($I10)
    rx330_cur."!cursor_pos"($I11)
    ($P10) = rx330_cur."!cursor_start"()
    $P10."!cursor_pass"(rx330_pos, "")
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_339_done
  rxcap_339_fail:
    goto rx330_fail
  rxcap_339_done:
  # rx charclass s
    ge rx330_pos, rx330_eos, rx330_fail
    sub $I10, rx330_pos, rx330_off
    is_cclass $I11, 32, rx330_tgt, $I10
    unless $I11, rx330_fail
    inc rx330_pos
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."xblock"()
    unless $P10, rx330_fail
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx330_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
    goto alt336_end
  alt336_1:
.annotate 'line', 202
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."pblock"()
    unless $P10, rx330_fail
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx330_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_345_fail
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  alt344_0:
    set_addr $I10, alt344_1
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  # rx literal  "while"
    add $I11, rx330_pos, 5
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 5
    ne $S10, "while", rx330_fail
    add rx330_pos, 5
    goto alt344_end
  alt344_1:
  # rx literal  "until"
    add $I11, rx330_pos, 5
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 5
    ne $S10, "until", rx330_fail
    add rx330_pos, 5
  alt344_end:
    set_addr $I10, rxcap_345_fail
    ($I12, $I11) = rx330_cur."!mark_peek"($I10)
    rx330_cur."!cursor_pos"($I11)
    ($P10) = rx330_cur."!cursor_start"()
    $P10."!cursor_pass"(rx330_pos, "")
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_345_done
  rxcap_345_fail:
    goto rx330_fail
  rxcap_345_done:
  # rx charclass s
    ge rx330_pos, rx330_eos, rx330_fail
    sub $I10, rx330_pos, rx330_off
    is_cclass $I11, 32, rx330_tgt, $I10
    unless $I11, rx330_fail
    inc rx330_pos
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."EXPR"()
    unless $P10, rx330_fail
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx330_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  alt336_end:
.annotate 'line', 203
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
.annotate 'line', 198
  # rx pass
    rx330_cur."!cursor_pass"(rx330_pos, "statement_control:sym<repeat>")
    if_null rx330_debug, debug_551
    rx330_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx330_pos)
  debug_551:
    .return (rx330_cur)
  rx330_restart:
.annotate 'line', 4
    if_null rx330_debug, debug_552
    rx330_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_552:
  rx330_fail:
    (rx330_rep, rx330_pos, $I10, $P10) = rx330_cur."!mark_fail"(0)
    lt rx330_pos, -1, rx330_done
    eq rx330_pos, -1, rx330_fail
    jump $I10
  rx330_done:
    rx330_cur."!cursor_fail"()
    if_null rx330_debug, debug_553
    rx330_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_553:
    .return (rx330_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("72_1298845521.609") :method
.annotate 'line', 4
    new $P332, "ResizablePMCArray"
    push $P332, "repeat"
    .return ($P332)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("73_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx350_tgt
    .local int rx350_pos
    .local int rx350_off
    .local int rx350_eos
    .local int rx350_rep
    .local pmc rx350_cur
    .local pmc rx350_debug
    (rx350_cur, rx350_pos, rx350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx350_cur
    .local pmc match
    .lex "$/", match
    length rx350_eos, rx350_tgt
    gt rx350_pos, rx350_eos, rx350_done
    set rx350_off, 0
    lt rx350_pos, 2, rx350_start
    sub rx350_off, rx350_pos, 1
    substr rx350_tgt, rx350_tgt, rx350_off
  rx350_start:
    eq $I10, 1, rx350_restart
    if_null rx350_debug, debug_554
    rx350_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan353_done
    goto rxscan353_scan
  rxscan353_loop:
    (rx350_pos) = rx350_cur."from"()
    inc rx350_pos
    rx350_cur."!cursor_from"(rx350_pos)
    ge rx350_pos, rx350_eos, rxscan353_done
  rxscan353_scan:
    set_addr $I10, rxscan353_loop
    rx350_cur."!mark_push"(0, rx350_pos, $I10)
  rxscan353_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_354_fail
    rx350_cur."!mark_push"(0, rx350_pos, $I10)
  # rx literal  "for"
    add $I11, rx350_pos, 3
    gt $I11, rx350_eos, rx350_fail
    sub $I11, rx350_pos, rx350_off
    substr $S10, rx350_tgt, $I11, 3
    ne $S10, "for", rx350_fail
    add rx350_pos, 3
    set_addr $I10, rxcap_354_fail
    ($I12, $I11) = rx350_cur."!mark_peek"($I10)
    rx350_cur."!cursor_pos"($I11)
    ($P10) = rx350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx350_pos, "")
    rx350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_354_done
  rxcap_354_fail:
    goto rx350_fail
  rxcap_354_done:
  # rx charclass s
    ge rx350_pos, rx350_eos, rx350_fail
    sub $I10, rx350_pos, rx350_off
    is_cclass $I11, 32, rx350_tgt, $I10
    unless $I11, rx350_fail
    inc rx350_pos
  # rx subrule "ws" subtype=method negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."ws"()
    unless $P10, rx350_fail
    rx350_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "xblock" subtype=capture negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."xblock"()
    unless $P10, rx350_fail
    rx350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx350_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."ws"()
    unless $P10, rx350_fail
    rx350_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx350_cur."!cursor_pass"(rx350_pos, "statement_control:sym<for>")
    if_null rx350_debug, debug_555
    rx350_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx350_pos)
  debug_555:
    .return (rx350_cur)
  rx350_restart:
.annotate 'line', 4
    if_null rx350_debug, debug_556
    rx350_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_556:
  rx350_fail:
    (rx350_rep, rx350_pos, $I10, $P10) = rx350_cur."!mark_fail"(0)
    lt rx350_pos, -1, rx350_done
    eq rx350_pos, -1, rx350_fail
    jump $I10
  rx350_done:
    rx350_cur."!cursor_fail"()
    if_null rx350_debug, debug_557
    rx350_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_557:
    .return (rx350_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("74_1298845521.609") :method
.annotate 'line', 4
    new $P352, "ResizablePMCArray"
    push $P352, "for"
    .return ($P352)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("75_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx358_tgt
    .local int rx358_pos
    .local int rx358_off
    .local int rx358_eos
    .local int rx358_rep
    .local pmc rx358_cur
    .local pmc rx358_debug
    (rx358_cur, rx358_pos, rx358_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx358_cur
    .local pmc match
    .lex "$/", match
    length rx358_eos, rx358_tgt
    gt rx358_pos, rx358_eos, rx358_done
    set rx358_off, 0
    lt rx358_pos, 2, rx358_start
    sub rx358_off, rx358_pos, 1
    substr rx358_tgt, rx358_tgt, rx358_off
  rx358_start:
    eq $I10, 1, rx358_restart
    if_null rx358_debug, debug_558
    rx358_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan361_done
    goto rxscan361_scan
  rxscan361_loop:
    (rx358_pos) = rx358_cur."from"()
    inc rx358_pos
    rx358_cur."!cursor_from"(rx358_pos)
    ge rx358_pos, rx358_eos, rxscan361_done
  rxscan361_scan:
    set_addr $I10, rxscan361_loop
    rx358_cur."!mark_push"(0, rx358_pos, $I10)
  rxscan361_done:
.annotate 'line', 212
  # rx subcapture "sym"
    set_addr $I10, rxcap_362_fail
    rx358_cur."!mark_push"(0, rx358_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx358_pos, 5
    gt $I11, rx358_eos, rx358_fail
    sub $I11, rx358_pos, rx358_off
    substr $S10, rx358_tgt, $I11, 5
    ne $S10, "CATCH", rx358_fail
    add rx358_pos, 5
    set_addr $I10, rxcap_362_fail
    ($I12, $I11) = rx358_cur."!mark_peek"($I10)
    rx358_cur."!cursor_pos"($I11)
    ($P10) = rx358_cur."!cursor_start"()
    $P10."!cursor_pass"(rx358_pos, "")
    rx358_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_362_done
  rxcap_362_fail:
    goto rx358_fail
  rxcap_362_done:
  # rx charclass s
    ge rx358_pos, rx358_eos, rx358_fail
    sub $I10, rx358_pos, rx358_off
    is_cclass $I11, 32, rx358_tgt, $I10
    unless $I11, rx358_fail
    inc rx358_pos
  # rx subrule "ws" subtype=method negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."ws"()
    unless $P10, rx358_fail
    rx358_pos = $P10."pos"()
.annotate 'line', 213
  # rx subrule "block" subtype=capture negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."block"()
    unless $P10, rx358_fail
    rx358_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx358_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."ws"()
    unless $P10, rx358_fail
    rx358_pos = $P10."pos"()
.annotate 'line', 211
  # rx pass
    rx358_cur."!cursor_pass"(rx358_pos, "statement_control:sym<CATCH>")
    if_null rx358_debug, debug_559
    rx358_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx358_pos)
  debug_559:
    .return (rx358_cur)
  rx358_restart:
.annotate 'line', 4
    if_null rx358_debug, debug_560
    rx358_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_560:
  rx358_fail:
    (rx358_rep, rx358_pos, $I10, $P10) = rx358_cur."!mark_fail"(0)
    lt rx358_pos, -1, rx358_done
    eq rx358_pos, -1, rx358_fail
    jump $I10
  rx358_done:
    rx358_cur."!cursor_fail"()
    if_null rx358_debug, debug_561
    rx358_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_561:
    .return (rx358_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("76_1298845521.609") :method
.annotate 'line', 4
    new $P360, "ResizablePMCArray"
    push $P360, "CATCH"
    .return ($P360)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("77_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx366_tgt
    .local int rx366_pos
    .local int rx366_off
    .local int rx366_eos
    .local int rx366_rep
    .local pmc rx366_cur
    .local pmc rx366_debug
    (rx366_cur, rx366_pos, rx366_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx366_cur
    .local pmc match
    .lex "$/", match
    length rx366_eos, rx366_tgt
    gt rx366_pos, rx366_eos, rx366_done
    set rx366_off, 0
    lt rx366_pos, 2, rx366_start
    sub rx366_off, rx366_pos, 1
    substr rx366_tgt, rx366_tgt, rx366_off
  rx366_start:
    eq $I10, 1, rx366_restart
    if_null rx366_debug, debug_562
    rx366_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan369_done
    goto rxscan369_scan
  rxscan369_loop:
    (rx366_pos) = rx366_cur."from"()
    inc rx366_pos
    rx366_cur."!cursor_from"(rx366_pos)
    ge rx366_pos, rx366_eos, rxscan369_done
  rxscan369_scan:
    set_addr $I10, rxscan369_loop
    rx366_cur."!mark_push"(0, rx366_pos, $I10)
  rxscan369_done:
.annotate 'line', 217
  # rx subcapture "sym"
    set_addr $I10, rxcap_370_fail
    rx366_cur."!mark_push"(0, rx366_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx366_pos, 7
    gt $I11, rx366_eos, rx366_fail
    sub $I11, rx366_pos, rx366_off
    substr $S10, rx366_tgt, $I11, 7
    ne $S10, "CONTROL", rx366_fail
    add rx366_pos, 7
    set_addr $I10, rxcap_370_fail
    ($I12, $I11) = rx366_cur."!mark_peek"($I10)
    rx366_cur."!cursor_pos"($I11)
    ($P10) = rx366_cur."!cursor_start"()
    $P10."!cursor_pass"(rx366_pos, "")
    rx366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_370_done
  rxcap_370_fail:
    goto rx366_fail
  rxcap_370_done:
  # rx charclass s
    ge rx366_pos, rx366_eos, rx366_fail
    sub $I10, rx366_pos, rx366_off
    is_cclass $I11, 32, rx366_tgt, $I10
    unless $I11, rx366_fail
    inc rx366_pos
  # rx subrule "ws" subtype=method negate=
    rx366_cur."!cursor_pos"(rx366_pos)
    $P10 = rx366_cur."ws"()
    unless $P10, rx366_fail
    rx366_pos = $P10."pos"()
.annotate 'line', 218
  # rx subrule "block" subtype=capture negate=
    rx366_cur."!cursor_pos"(rx366_pos)
    $P10 = rx366_cur."block"()
    unless $P10, rx366_fail
    rx366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx366_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx366_cur."!cursor_pos"(rx366_pos)
    $P10 = rx366_cur."ws"()
    unless $P10, rx366_fail
    rx366_pos = $P10."pos"()
.annotate 'line', 216
  # rx pass
    rx366_cur."!cursor_pass"(rx366_pos, "statement_control:sym<CONTROL>")
    if_null rx366_debug, debug_563
    rx366_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx366_pos)
  debug_563:
    .return (rx366_cur)
  rx366_restart:
.annotate 'line', 4
    if_null rx366_debug, debug_564
    rx366_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_564:
  rx366_fail:
    (rx366_rep, rx366_pos, $I10, $P10) = rx366_cur."!mark_fail"(0)
    lt rx366_pos, -1, rx366_done
    eq rx366_pos, -1, rx366_fail
    jump $I10
  rx366_done:
    rx366_cur."!cursor_fail"()
    if_null rx366_debug, debug_565
    rx366_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_565:
    .return (rx366_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("78_1298845521.609") :method
.annotate 'line', 4
    new $P368, "ResizablePMCArray"
    push $P368, "CONTROL"
    .return ($P368)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("79_1298845521.609")
    .param pmc param_374
.annotate 'line', 221
    .lex "self", param_374
    $P375 = param_374."!protoregex"("statement_prefix")
    .return ($P375)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("80_1298845521.609")
    .param pmc param_377
.annotate 'line', 221
    .lex "self", param_377
    $P378 = param_377."!PREFIX__!protoregex"("statement_prefix")
    .return ($P378)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("81_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx380_tgt
    .local int rx380_pos
    .local int rx380_off
    .local int rx380_eos
    .local int rx380_rep
    .local pmc rx380_cur
    .local pmc rx380_debug
    (rx380_cur, rx380_pos, rx380_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx380_cur
    .local pmc match
    .lex "$/", match
    length rx380_eos, rx380_tgt
    gt rx380_pos, rx380_eos, rx380_done
    set rx380_off, 0
    lt rx380_pos, 2, rx380_start
    sub rx380_off, rx380_pos, 1
    substr rx380_tgt, rx380_tgt, rx380_off
  rx380_start:
    eq $I10, 1, rx380_restart
    if_null rx380_debug, debug_566
    rx380_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan384_done
    goto rxscan384_scan
  rxscan384_loop:
    (rx380_pos) = rx380_cur."from"()
    inc rx380_pos
    rx380_cur."!cursor_from"(rx380_pos)
    ge rx380_pos, rx380_eos, rxscan384_done
  rxscan384_scan:
    set_addr $I10, rxscan384_loop
    rx380_cur."!mark_push"(0, rx380_pos, $I10)
  rxscan384_done:
.annotate 'line', 222
  # rx subcapture "sym"
    set_addr $I10, rxcap_385_fail
    rx380_cur."!mark_push"(0, rx380_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx380_pos, 4
    gt $I11, rx380_eos, rx380_fail
    sub $I11, rx380_pos, rx380_off
    substr $S10, rx380_tgt, $I11, 4
    ne $S10, "INIT", rx380_fail
    add rx380_pos, 4
    set_addr $I10, rxcap_385_fail
    ($I12, $I11) = rx380_cur."!mark_peek"($I10)
    rx380_cur."!cursor_pos"($I11)
    ($P10) = rx380_cur."!cursor_start"()
    $P10."!cursor_pass"(rx380_pos, "")
    rx380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_385_done
  rxcap_385_fail:
    goto rx380_fail
  rxcap_385_done:
  # rx subrule "blorst" subtype=capture negate=
    rx380_cur."!cursor_pos"(rx380_pos)
    $P10 = rx380_cur."blorst"()
    unless $P10, rx380_fail
    rx380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx380_pos = $P10."pos"()
  # rx pass
    rx380_cur."!cursor_pass"(rx380_pos, "statement_prefix:sym<INIT>")
    if_null rx380_debug, debug_567
    rx380_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx380_pos)
  debug_567:
    .return (rx380_cur)
  rx380_restart:
.annotate 'line', 4
    if_null rx380_debug, debug_568
    rx380_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_568:
  rx380_fail:
    (rx380_rep, rx380_pos, $I10, $P10) = rx380_cur."!mark_fail"(0)
    lt rx380_pos, -1, rx380_done
    eq rx380_pos, -1, rx380_fail
    jump $I10
  rx380_done:
    rx380_cur."!cursor_fail"()
    if_null rx380_debug, debug_569
    rx380_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_569:
    .return (rx380_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("82_1298845521.609") :method
.annotate 'line', 4
    $P382 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P383, "ResizablePMCArray"
    push $P383, $P382
    .return ($P383)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("83_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx387_tgt
    .local int rx387_pos
    .local int rx387_off
    .local int rx387_eos
    .local int rx387_rep
    .local pmc rx387_cur
    .local pmc rx387_debug
    (rx387_cur, rx387_pos, rx387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx387_cur
    .local pmc match
    .lex "$/", match
    length rx387_eos, rx387_tgt
    gt rx387_pos, rx387_eos, rx387_done
    set rx387_off, 0
    lt rx387_pos, 2, rx387_start
    sub rx387_off, rx387_pos, 1
    substr rx387_tgt, rx387_tgt, rx387_off
  rx387_start:
    eq $I10, 1, rx387_restart
    if_null rx387_debug, debug_570
    rx387_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan391_done
    goto rxscan391_scan
  rxscan391_loop:
    (rx387_pos) = rx387_cur."from"()
    inc rx387_pos
    rx387_cur."!cursor_from"(rx387_pos)
    ge rx387_pos, rx387_eos, rxscan391_done
  rxscan391_scan:
    set_addr $I10, rxscan391_loop
    rx387_cur."!mark_push"(0, rx387_pos, $I10)
  rxscan391_done:
.annotate 'line', 225
  # rx subcapture "sym"
    set_addr $I10, rxcap_392_fail
    rx387_cur."!mark_push"(0, rx387_pos, $I10)
  # rx literal  "try"
    add $I11, rx387_pos, 3
    gt $I11, rx387_eos, rx387_fail
    sub $I11, rx387_pos, rx387_off
    substr $S10, rx387_tgt, $I11, 3
    ne $S10, "try", rx387_fail
    add rx387_pos, 3
    set_addr $I10, rxcap_392_fail
    ($I12, $I11) = rx387_cur."!mark_peek"($I10)
    rx387_cur."!cursor_pos"($I11)
    ($P10) = rx387_cur."!cursor_start"()
    $P10."!cursor_pass"(rx387_pos, "")
    rx387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_392_done
  rxcap_392_fail:
    goto rx387_fail
  rxcap_392_done:
.annotate 'line', 226
  # rx subrule "blorst" subtype=capture negate=
    rx387_cur."!cursor_pos"(rx387_pos)
    $P10 = rx387_cur."blorst"()
    unless $P10, rx387_fail
    rx387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx387_pos = $P10."pos"()
.annotate 'line', 224
  # rx pass
    rx387_cur."!cursor_pass"(rx387_pos, "statement_prefix:sym<try>")
    if_null rx387_debug, debug_571
    rx387_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx387_pos)
  debug_571:
    .return (rx387_cur)
  rx387_restart:
.annotate 'line', 4
    if_null rx387_debug, debug_572
    rx387_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_572:
  rx387_fail:
    (rx387_rep, rx387_pos, $I10, $P10) = rx387_cur."!mark_fail"(0)
    lt rx387_pos, -1, rx387_done
    eq rx387_pos, -1, rx387_fail
    jump $I10
  rx387_done:
    rx387_cur."!cursor_fail"()
    if_null rx387_debug, debug_573
    rx387_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_573:
    .return (rx387_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("84_1298845521.609") :method
.annotate 'line', 4
    $P389 = self."!PREFIX__!subrule"("blorst", "try")
    new $P390, "ResizablePMCArray"
    push $P390, $P389
    .return ($P390)
.end


.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("85_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx394_tgt
    .local int rx394_pos
    .local int rx394_off
    .local int rx394_eos
    .local int rx394_rep
    .local pmc rx394_cur
    .local pmc rx394_debug
    (rx394_cur, rx394_pos, rx394_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx394_cur
    .local pmc match
    .lex "$/", match
    length rx394_eos, rx394_tgt
    gt rx394_pos, rx394_eos, rx394_done
    set rx394_off, 0
    lt rx394_pos, 2, rx394_start
    sub rx394_off, rx394_pos, 1
    substr rx394_tgt, rx394_tgt, rx394_off
  rx394_start:
    eq $I10, 1, rx394_restart
    if_null rx394_debug, debug_574
    rx394_cur."!cursor_debug"("START", "blorst")
  debug_574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan397_done
    goto rxscan397_scan
  rxscan397_loop:
    (rx394_pos) = rx394_cur."from"()
    inc rx394_pos
    rx394_cur."!cursor_from"(rx394_pos)
    ge rx394_pos, rx394_eos, rxscan397_done
  rxscan397_scan:
    set_addr $I10, rxscan397_loop
    rx394_cur."!mark_push"(0, rx394_pos, $I10)
  rxscan397_done:
.annotate 'line', 230
  # rx charclass s
    ge rx394_pos, rx394_eos, rx394_fail
    sub $I10, rx394_pos, rx394_off
    is_cclass $I11, 32, rx394_tgt, $I10
    unless $I11, rx394_fail
    inc rx394_pos
  # rx subrule "ws" subtype=method negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."ws"()
    unless $P10, rx394_fail
    rx394_pos = $P10."pos"()
  alt398_0:
    set_addr $I10, alt398_1
    rx394_cur."!mark_push"(0, rx394_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx394_pos, rx394_off
    substr $S10, rx394_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx394_fail
  # rx subrule "block" subtype=capture negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."block"()
    unless $P10, rx394_fail
    rx394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx394_pos = $P10."pos"()
    goto alt398_end
  alt398_1:
  # rx subrule "statement" subtype=capture negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."statement"()
    unless $P10, rx394_fail
    rx394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx394_pos = $P10."pos"()
  alt398_end:
.annotate 'line', 229
  # rx pass
    rx394_cur."!cursor_pass"(rx394_pos, "blorst")
    if_null rx394_debug, debug_575
    rx394_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx394_pos)
  debug_575:
    .return (rx394_cur)
  rx394_restart:
.annotate 'line', 4
    if_null rx394_debug, debug_576
    rx394_cur."!cursor_debug"("NEXT", "blorst")
  debug_576:
  rx394_fail:
    (rx394_rep, rx394_pos, $I10, $P10) = rx394_cur."!mark_fail"(0)
    lt rx394_pos, -1, rx394_done
    eq rx394_pos, -1, rx394_fail
    jump $I10
  rx394_done:
    rx394_cur."!cursor_fail"()
    if_null rx394_debug, debug_577
    rx394_cur."!cursor_debug"("FAIL", "blorst")
  debug_577:
    .return (rx394_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("86_1298845521.609") :method
.annotate 'line', 4
    new $P396, "ResizablePMCArray"
    push $P396, ""
    .return ($P396)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("87_1298845521.609")
    .param pmc param_400
.annotate 'line', 235
    .lex "self", param_400
    $P401 = param_400."!protoregex"("statement_mod_cond")
    .return ($P401)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("88_1298845521.609")
    .param pmc param_403
.annotate 'line', 235
    .lex "self", param_403
    $P404 = param_403."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P404)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("89_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx406_tgt
    .local int rx406_pos
    .local int rx406_off
    .local int rx406_eos
    .local int rx406_rep
    .local pmc rx406_cur
    .local pmc rx406_debug
    (rx406_cur, rx406_pos, rx406_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx406_cur
    .local pmc match
    .lex "$/", match
    length rx406_eos, rx406_tgt
    gt rx406_pos, rx406_eos, rx406_done
    set rx406_off, 0
    lt rx406_pos, 2, rx406_start
    sub rx406_off, rx406_pos, 1
    substr rx406_tgt, rx406_tgt, rx406_off
  rx406_start:
    eq $I10, 1, rx406_restart
    if_null rx406_debug, debug_578
    rx406_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan410_done
    goto rxscan410_scan
  rxscan410_loop:
    (rx406_pos) = rx406_cur."from"()
    inc rx406_pos
    rx406_cur."!cursor_from"(rx406_pos)
    ge rx406_pos, rx406_eos, rxscan410_done
  rxscan410_scan:
    set_addr $I10, rxscan410_loop
    rx406_cur."!mark_push"(0, rx406_pos, $I10)
  rxscan410_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_411_fail
    rx406_cur."!mark_push"(0, rx406_pos, $I10)
  # rx literal  "if"
    add $I11, rx406_pos, 2
    gt $I11, rx406_eos, rx406_fail
    sub $I11, rx406_pos, rx406_off
    substr $S10, rx406_tgt, $I11, 2
    ne $S10, "if", rx406_fail
    add rx406_pos, 2
    set_addr $I10, rxcap_411_fail
    ($I12, $I11) = rx406_cur."!mark_peek"($I10)
    rx406_cur."!cursor_pos"($I11)
    ($P10) = rx406_cur."!cursor_start"()
    $P10."!cursor_pass"(rx406_pos, "")
    rx406_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_411_done
  rxcap_411_fail:
    goto rx406_fail
  rxcap_411_done:
  # rx subrule "ws" subtype=method negate=
    rx406_cur."!cursor_pos"(rx406_pos)
    $P10 = rx406_cur."ws"()
    unless $P10, rx406_fail
    rx406_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx406_cur."!cursor_pos"(rx406_pos)
    $P10 = rx406_cur."EXPR"()
    unless $P10, rx406_fail
    rx406_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx406_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx406_cur."!cursor_pos"(rx406_pos)
    $P10 = rx406_cur."ws"()
    unless $P10, rx406_fail
    rx406_pos = $P10."pos"()
  # rx pass
    rx406_cur."!cursor_pass"(rx406_pos, "statement_mod_cond:sym<if>")
    if_null rx406_debug, debug_579
    rx406_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx406_pos)
  debug_579:
    .return (rx406_cur)
  rx406_restart:
.annotate 'line', 4
    if_null rx406_debug, debug_580
    rx406_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_580:
  rx406_fail:
    (rx406_rep, rx406_pos, $I10, $P10) = rx406_cur."!mark_fail"(0)
    lt rx406_pos, -1, rx406_done
    eq rx406_pos, -1, rx406_fail
    jump $I10
  rx406_done:
    rx406_cur."!cursor_fail"()
    if_null rx406_debug, debug_581
    rx406_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_581:
    .return (rx406_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("90_1298845521.609") :method
.annotate 'line', 4
    $P408 = self."!PREFIX__!subrule"("ws", "if")
    new $P409, "ResizablePMCArray"
    push $P409, $P408
    .return ($P409)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("91_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx415_tgt
    .local int rx415_pos
    .local int rx415_off
    .local int rx415_eos
    .local int rx415_rep
    .local pmc rx415_cur
    .local pmc rx415_debug
    (rx415_cur, rx415_pos, rx415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx415_cur
    .local pmc match
    .lex "$/", match
    length rx415_eos, rx415_tgt
    gt rx415_pos, rx415_eos, rx415_done
    set rx415_off, 0
    lt rx415_pos, 2, rx415_start
    sub rx415_off, rx415_pos, 1
    substr rx415_tgt, rx415_tgt, rx415_off
  rx415_start:
    eq $I10, 1, rx415_restart
    if_null rx415_debug, debug_582
    rx415_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan419_done
    goto rxscan419_scan
  rxscan419_loop:
    (rx415_pos) = rx415_cur."from"()
    inc rx415_pos
    rx415_cur."!cursor_from"(rx415_pos)
    ge rx415_pos, rx415_eos, rxscan419_done
  rxscan419_scan:
    set_addr $I10, rxscan419_loop
    rx415_cur."!mark_push"(0, rx415_pos, $I10)
  rxscan419_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_420_fail
    rx415_cur."!mark_push"(0, rx415_pos, $I10)
  # rx literal  "unless"
    add $I11, rx415_pos, 6
    gt $I11, rx415_eos, rx415_fail
    sub $I11, rx415_pos, rx415_off
    substr $S10, rx415_tgt, $I11, 6
    ne $S10, "unless", rx415_fail
    add rx415_pos, 6
    set_addr $I10, rxcap_420_fail
    ($I12, $I11) = rx415_cur."!mark_peek"($I10)
    rx415_cur."!cursor_pos"($I11)
    ($P10) = rx415_cur."!cursor_start"()
    $P10."!cursor_pass"(rx415_pos, "")
    rx415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_420_done
  rxcap_420_fail:
    goto rx415_fail
  rxcap_420_done:
  # rx subrule "ws" subtype=method negate=
    rx415_cur."!cursor_pos"(rx415_pos)
    $P10 = rx415_cur."ws"()
    unless $P10, rx415_fail
    rx415_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx415_cur."!cursor_pos"(rx415_pos)
    $P10 = rx415_cur."EXPR"()
    unless $P10, rx415_fail
    rx415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx415_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx415_cur."!cursor_pos"(rx415_pos)
    $P10 = rx415_cur."ws"()
    unless $P10, rx415_fail
    rx415_pos = $P10."pos"()
  # rx pass
    rx415_cur."!cursor_pass"(rx415_pos, "statement_mod_cond:sym<unless>")
    if_null rx415_debug, debug_583
    rx415_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx415_pos)
  debug_583:
    .return (rx415_cur)
  rx415_restart:
.annotate 'line', 4
    if_null rx415_debug, debug_584
    rx415_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_584:
  rx415_fail:
    (rx415_rep, rx415_pos, $I10, $P10) = rx415_cur."!mark_fail"(0)
    lt rx415_pos, -1, rx415_done
    eq rx415_pos, -1, rx415_fail
    jump $I10
  rx415_done:
    rx415_cur."!cursor_fail"()
    if_null rx415_debug, debug_585
    rx415_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_585:
    .return (rx415_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("92_1298845521.609") :method
.annotate 'line', 4
    $P417 = self."!PREFIX__!subrule"("ws", "unless")
    new $P418, "ResizablePMCArray"
    push $P418, $P417
    .return ($P418)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("93_1298845521.609")
    .param pmc param_424
.annotate 'line', 240
    .lex "self", param_424
    $P425 = param_424."!protoregex"("statement_mod_loop")
    .return ($P425)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("94_1298845521.609")
    .param pmc param_427
.annotate 'line', 240
    .lex "self", param_427
    $P428 = param_427."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P428)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("95_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx430_tgt
    .local int rx430_pos
    .local int rx430_off
    .local int rx430_eos
    .local int rx430_rep
    .local pmc rx430_cur
    .local pmc rx430_debug
    (rx430_cur, rx430_pos, rx430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx430_cur
    .local pmc match
    .lex "$/", match
    length rx430_eos, rx430_tgt
    gt rx430_pos, rx430_eos, rx430_done
    set rx430_off, 0
    lt rx430_pos, 2, rx430_start
    sub rx430_off, rx430_pos, 1
    substr rx430_tgt, rx430_tgt, rx430_off
  rx430_start:
    eq $I10, 1, rx430_restart
    if_null rx430_debug, debug_586
    rx430_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan434_done
    goto rxscan434_scan
  rxscan434_loop:
    (rx430_pos) = rx430_cur."from"()
    inc rx430_pos
    rx430_cur."!cursor_from"(rx430_pos)
    ge rx430_pos, rx430_eos, rxscan434_done
  rxscan434_scan:
    set_addr $I10, rxscan434_loop
    rx430_cur."!mark_push"(0, rx430_pos, $I10)
  rxscan434_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_435_fail
    rx430_cur."!mark_push"(0, rx430_pos, $I10)
  # rx literal  "while"
    add $I11, rx430_pos, 5
    gt $I11, rx430_eos, rx430_fail
    sub $I11, rx430_pos, rx430_off
    substr $S10, rx430_tgt, $I11, 5
    ne $S10, "while", rx430_fail
    add rx430_pos, 5
    set_addr $I10, rxcap_435_fail
    ($I12, $I11) = rx430_cur."!mark_peek"($I10)
    rx430_cur."!cursor_pos"($I11)
    ($P10) = rx430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx430_pos, "")
    rx430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_435_done
  rxcap_435_fail:
    goto rx430_fail
  rxcap_435_done:
  # rx subrule "ws" subtype=method negate=
    rx430_cur."!cursor_pos"(rx430_pos)
    $P10 = rx430_cur."ws"()
    unless $P10, rx430_fail
    rx430_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx430_cur."!cursor_pos"(rx430_pos)
    $P10 = rx430_cur."EXPR"()
    unless $P10, rx430_fail
    rx430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx430_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx430_cur."!cursor_pos"(rx430_pos)
    $P10 = rx430_cur."ws"()
    unless $P10, rx430_fail
    rx430_pos = $P10."pos"()
  # rx pass
    rx430_cur."!cursor_pass"(rx430_pos, "statement_mod_loop:sym<while>")
    if_null rx430_debug, debug_587
    rx430_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx430_pos)
  debug_587:
    .return (rx430_cur)
  rx430_restart:
.annotate 'line', 4
    if_null rx430_debug, debug_588
    rx430_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_588:
  rx430_fail:
    (rx430_rep, rx430_pos, $I10, $P10) = rx430_cur."!mark_fail"(0)
    lt rx430_pos, -1, rx430_done
    eq rx430_pos, -1, rx430_fail
    jump $I10
  rx430_done:
    rx430_cur."!cursor_fail"()
    if_null rx430_debug, debug_589
    rx430_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_589:
    .return (rx430_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("96_1298845521.609") :method
.annotate 'line', 4
    $P432 = self."!PREFIX__!subrule"("ws", "while")
    new $P433, "ResizablePMCArray"
    push $P433, $P432
    .return ($P433)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("97_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx439_tgt
    .local int rx439_pos
    .local int rx439_off
    .local int rx439_eos
    .local int rx439_rep
    .local pmc rx439_cur
    .local pmc rx439_debug
    (rx439_cur, rx439_pos, rx439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx439_cur
    .local pmc match
    .lex "$/", match
    length rx439_eos, rx439_tgt
    gt rx439_pos, rx439_eos, rx439_done
    set rx439_off, 0
    lt rx439_pos, 2, rx439_start
    sub rx439_off, rx439_pos, 1
    substr rx439_tgt, rx439_tgt, rx439_off
  rx439_start:
    eq $I10, 1, rx439_restart
    if_null rx439_debug, debug_590
    rx439_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan443_done
    goto rxscan443_scan
  rxscan443_loop:
    (rx439_pos) = rx439_cur."from"()
    inc rx439_pos
    rx439_cur."!cursor_from"(rx439_pos)
    ge rx439_pos, rx439_eos, rxscan443_done
  rxscan443_scan:
    set_addr $I10, rxscan443_loop
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  rxscan443_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_444_fail
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  # rx literal  "until"
    add $I11, rx439_pos, 5
    gt $I11, rx439_eos, rx439_fail
    sub $I11, rx439_pos, rx439_off
    substr $S10, rx439_tgt, $I11, 5
    ne $S10, "until", rx439_fail
    add rx439_pos, 5
    set_addr $I10, rxcap_444_fail
    ($I12, $I11) = rx439_cur."!mark_peek"($I10)
    rx439_cur."!cursor_pos"($I11)
    ($P10) = rx439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx439_pos, "")
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_444_done
  rxcap_444_fail:
    goto rx439_fail
  rxcap_444_done:
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."EXPR"()
    unless $P10, rx439_fail
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx439_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx pass
    rx439_cur."!cursor_pass"(rx439_pos, "statement_mod_loop:sym<until>")
    if_null rx439_debug, debug_591
    rx439_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx439_pos)
  debug_591:
    .return (rx439_cur)
  rx439_restart:
.annotate 'line', 4
    if_null rx439_debug, debug_592
    rx439_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_592:
  rx439_fail:
    (rx439_rep, rx439_pos, $I10, $P10) = rx439_cur."!mark_fail"(0)
    lt rx439_pos, -1, rx439_done
    eq rx439_pos, -1, rx439_fail
    jump $I10
  rx439_done:
    rx439_cur."!cursor_fail"()
    if_null rx439_debug, debug_593
    rx439_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_593:
    .return (rx439_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("98_1298845521.609") :method
.annotate 'line', 4
    $P441 = self."!PREFIX__!subrule"("ws", "until")
    new $P442, "ResizablePMCArray"
    push $P442, $P441
    .return ($P442)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("99_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx448_tgt
    .local int rx448_pos
    .local int rx448_off
    .local int rx448_eos
    .local int rx448_rep
    .local pmc rx448_cur
    .local pmc rx448_debug
    (rx448_cur, rx448_pos, rx448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx448_cur
    .local pmc match
    .lex "$/", match
    length rx448_eos, rx448_tgt
    gt rx448_pos, rx448_eos, rx448_done
    set rx448_off, 0
    lt rx448_pos, 2, rx448_start
    sub rx448_off, rx448_pos, 1
    substr rx448_tgt, rx448_tgt, rx448_off
  rx448_start:
    eq $I10, 1, rx448_restart
    if_null rx448_debug, debug_594
    rx448_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan452_done
    goto rxscan452_scan
  rxscan452_loop:
    (rx448_pos) = rx448_cur."from"()
    inc rx448_pos
    rx448_cur."!cursor_from"(rx448_pos)
    ge rx448_pos, rx448_eos, rxscan452_done
  rxscan452_scan:
    set_addr $I10, rxscan452_loop
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  rxscan452_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_453_fail
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  # rx literal  "for"
    add $I11, rx448_pos, 3
    gt $I11, rx448_eos, rx448_fail
    sub $I11, rx448_pos, rx448_off
    substr $S10, rx448_tgt, $I11, 3
    ne $S10, "for", rx448_fail
    add rx448_pos, 3
    set_addr $I10, rxcap_453_fail
    ($I12, $I11) = rx448_cur."!mark_peek"($I10)
    rx448_cur."!cursor_pos"($I11)
    ($P10) = rx448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx448_pos, "")
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_453_done
  rxcap_453_fail:
    goto rx448_fail
  rxcap_453_done:
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."EXPR"()
    unless $P10, rx448_fail
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx pass
    rx448_cur."!cursor_pass"(rx448_pos, "statement_mod_loop:sym<for>")
    if_null rx448_debug, debug_595
    rx448_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx448_pos)
  debug_595:
    .return (rx448_cur)
  rx448_restart:
.annotate 'line', 4
    if_null rx448_debug, debug_596
    rx448_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_596:
  rx448_fail:
    (rx448_rep, rx448_pos, $I10, $P10) = rx448_cur."!mark_fail"(0)
    lt rx448_pos, -1, rx448_done
    eq rx448_pos, -1, rx448_fail
    jump $I10
  rx448_done:
    rx448_cur."!cursor_fail"()
    if_null rx448_debug, debug_597
    rx448_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_597:
    .return (rx448_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("100_1298845521.609") :method
.annotate 'line', 4
    $P450 = self."!PREFIX__!subrule"("ws", "for")
    new $P451, "ResizablePMCArray"
    push $P451, $P450
    .return ($P451)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("101_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx457_tgt
    .local int rx457_pos
    .local int rx457_off
    .local int rx457_eos
    .local int rx457_rep
    .local pmc rx457_cur
    .local pmc rx457_debug
    (rx457_cur, rx457_pos, rx457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx457_cur
    .local pmc match
    .lex "$/", match
    length rx457_eos, rx457_tgt
    gt rx457_pos, rx457_eos, rx457_done
    set rx457_off, 0
    lt rx457_pos, 2, rx457_start
    sub rx457_off, rx457_pos, 1
    substr rx457_tgt, rx457_tgt, rx457_off
  rx457_start:
    eq $I10, 1, rx457_restart
    if_null rx457_debug, debug_598
    rx457_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan461_done
    goto rxscan461_scan
  rxscan461_loop:
    (rx457_pos) = rx457_cur."from"()
    inc rx457_pos
    rx457_cur."!cursor_from"(rx457_pos)
    ge rx457_pos, rx457_eos, rxscan461_done
  rxscan461_scan:
    set_addr $I10, rxscan461_loop
    rx457_cur."!mark_push"(0, rx457_pos, $I10)
  rxscan461_done:
.annotate 'line', 248
  # rx subrule "fatarrow" subtype=capture negate=
    rx457_cur."!cursor_pos"(rx457_pos)
    $P10 = rx457_cur."fatarrow"()
    unless $P10, rx457_fail
    rx457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx457_pos = $P10."pos"()
  # rx pass
    rx457_cur."!cursor_pass"(rx457_pos, "term:sym<fatarrow>")
    if_null rx457_debug, debug_599
    rx457_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx457_pos)
  debug_599:
    .return (rx457_cur)
  rx457_restart:
.annotate 'line', 4
    if_null rx457_debug, debug_600
    rx457_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_600:
  rx457_fail:
    (rx457_rep, rx457_pos, $I10, $P10) = rx457_cur."!mark_fail"(0)
    lt rx457_pos, -1, rx457_done
    eq rx457_pos, -1, rx457_fail
    jump $I10
  rx457_done:
    rx457_cur."!cursor_fail"()
    if_null rx457_debug, debug_601
    rx457_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_601:
    .return (rx457_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("102_1298845521.609") :method
.annotate 'line', 4
    $P459 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P460, "ResizablePMCArray"
    push $P460, $P459
    .return ($P460)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("103_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_602
    rx463_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan467_done
    goto rxscan467_scan
  rxscan467_loop:
    (rx463_pos) = rx463_cur."from"()
    inc rx463_pos
    rx463_cur."!cursor_from"(rx463_pos)
    ge rx463_pos, rx463_eos, rxscan467_done
  rxscan467_scan:
    set_addr $I10, rxscan467_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan467_done:
.annotate 'line', 249
  # rx subrule "colonpair" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."colonpair"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx463_pos = $P10."pos"()
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "term:sym<colonpair>")
    if_null rx463_debug, debug_603
    rx463_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx463_pos)
  debug_603:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 4
    if_null rx463_debug, debug_604
    rx463_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_604:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_605
    rx463_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_605:
    .return (rx463_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("104_1298845521.609") :method
.annotate 'line', 4
    $P465 = self."!PREFIX__!subrule"("colonpair", "")
    new $P466, "ResizablePMCArray"
    push $P466, $P465
    .return ($P466)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("105_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx469_tgt
    .local int rx469_pos
    .local int rx469_off
    .local int rx469_eos
    .local int rx469_rep
    .local pmc rx469_cur
    .local pmc rx469_debug
    (rx469_cur, rx469_pos, rx469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx469_cur
    .local pmc match
    .lex "$/", match
    length rx469_eos, rx469_tgt
    gt rx469_pos, rx469_eos, rx469_done
    set rx469_off, 0
    lt rx469_pos, 2, rx469_start
    sub rx469_off, rx469_pos, 1
    substr rx469_tgt, rx469_tgt, rx469_off
  rx469_start:
    eq $I10, 1, rx469_restart
    if_null rx469_debug, debug_606
    rx469_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan473_done
    goto rxscan473_scan
  rxscan473_loop:
    (rx469_pos) = rx469_cur."from"()
    inc rx469_pos
    rx469_cur."!cursor_from"(rx469_pos)
    ge rx469_pos, rx469_eos, rxscan473_done
  rxscan473_scan:
    set_addr $I10, rxscan473_loop
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  rxscan473_done:
.annotate 'line', 250
  # rx subrule "variable" subtype=capture negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."variable"()
    unless $P10, rx469_fail
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx469_pos = $P10."pos"()
  # rx pass
    rx469_cur."!cursor_pass"(rx469_pos, "term:sym<variable>")
    if_null rx469_debug, debug_607
    rx469_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx469_pos)
  debug_607:
    .return (rx469_cur)
  rx469_restart:
.annotate 'line', 4
    if_null rx469_debug, debug_608
    rx469_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_608:
  rx469_fail:
    (rx469_rep, rx469_pos, $I10, $P10) = rx469_cur."!mark_fail"(0)
    lt rx469_pos, -1, rx469_done
    eq rx469_pos, -1, rx469_fail
    jump $I10
  rx469_done:
    rx469_cur."!cursor_fail"()
    if_null rx469_debug, debug_609
    rx469_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_609:
    .return (rx469_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("106_1298845521.609") :method
.annotate 'line', 4
    $P471 = self."!PREFIX__!subrule"("variable", "")
    new $P472, "ResizablePMCArray"
    push $P472, $P471
    .return ($P472)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("107_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx475_tgt
    .local int rx475_pos
    .local int rx475_off
    .local int rx475_eos
    .local int rx475_rep
    .local pmc rx475_cur
    .local pmc rx475_debug
    (rx475_cur, rx475_pos, rx475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx475_cur
    .local pmc match
    .lex "$/", match
    length rx475_eos, rx475_tgt
    gt rx475_pos, rx475_eos, rx475_done
    set rx475_off, 0
    lt rx475_pos, 2, rx475_start
    sub rx475_off, rx475_pos, 1
    substr rx475_tgt, rx475_tgt, rx475_off
  rx475_start:
    eq $I10, 1, rx475_restart
    if_null rx475_debug, debug_610
    rx475_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan479_done
    goto rxscan479_scan
  rxscan479_loop:
    (rx475_pos) = rx475_cur."from"()
    inc rx475_pos
    rx475_cur."!cursor_from"(rx475_pos)
    ge rx475_pos, rx475_eos, rxscan479_done
  rxscan479_scan:
    set_addr $I10, rxscan479_loop
    rx475_cur."!mark_push"(0, rx475_pos, $I10)
  rxscan479_done:
.annotate 'line', 251
  # rx subrule "package_declarator" subtype=capture negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."package_declarator"()
    unless $P10, rx475_fail
    rx475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx475_pos = $P10."pos"()
  # rx pass
    rx475_cur."!cursor_pass"(rx475_pos, "term:sym<package_declarator>")
    if_null rx475_debug, debug_611
    rx475_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx475_pos)
  debug_611:
    .return (rx475_cur)
  rx475_restart:
.annotate 'line', 4
    if_null rx475_debug, debug_612
    rx475_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_612:
  rx475_fail:
    (rx475_rep, rx475_pos, $I10, $P10) = rx475_cur."!mark_fail"(0)
    lt rx475_pos, -1, rx475_done
    eq rx475_pos, -1, rx475_fail
    jump $I10
  rx475_done:
    rx475_cur."!cursor_fail"()
    if_null rx475_debug, debug_613
    rx475_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_613:
    .return (rx475_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("108_1298845521.609") :method
.annotate 'line', 4
    $P477 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P478, "ResizablePMCArray"
    push $P478, $P477
    .return ($P478)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("109_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx481_tgt
    .local int rx481_pos
    .local int rx481_off
    .local int rx481_eos
    .local int rx481_rep
    .local pmc rx481_cur
    .local pmc rx481_debug
    (rx481_cur, rx481_pos, rx481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx481_cur
    .local pmc match
    .lex "$/", match
    length rx481_eos, rx481_tgt
    gt rx481_pos, rx481_eos, rx481_done
    set rx481_off, 0
    lt rx481_pos, 2, rx481_start
    sub rx481_off, rx481_pos, 1
    substr rx481_tgt, rx481_tgt, rx481_off
  rx481_start:
    eq $I10, 1, rx481_restart
    if_null rx481_debug, debug_614
    rx481_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan485_done
    goto rxscan485_scan
  rxscan485_loop:
    (rx481_pos) = rx481_cur."from"()
    inc rx481_pos
    rx481_cur."!cursor_from"(rx481_pos)
    ge rx481_pos, rx481_eos, rxscan485_done
  rxscan485_scan:
    set_addr $I10, rxscan485_loop
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  rxscan485_done:
.annotate 'line', 252
  # rx subrule "scope_declarator" subtype=capture negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."scope_declarator"()
    unless $P10, rx481_fail
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx481_pos = $P10."pos"()
  # rx pass
    rx481_cur."!cursor_pass"(rx481_pos, "term:sym<scope_declarator>")
    if_null rx481_debug, debug_615
    rx481_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx481_pos)
  debug_615:
    .return (rx481_cur)
  rx481_restart:
.annotate 'line', 4
    if_null rx481_debug, debug_616
    rx481_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_616:
  rx481_fail:
    (rx481_rep, rx481_pos, $I10, $P10) = rx481_cur."!mark_fail"(0)
    lt rx481_pos, -1, rx481_done
    eq rx481_pos, -1, rx481_fail
    jump $I10
  rx481_done:
    rx481_cur."!cursor_fail"()
    if_null rx481_debug, debug_617
    rx481_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_617:
    .return (rx481_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("110_1298845521.609") :method
.annotate 'line', 4
    $P483 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P484, "ResizablePMCArray"
    push $P484, $P483
    .return ($P484)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("111_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx487_tgt
    .local int rx487_pos
    .local int rx487_off
    .local int rx487_eos
    .local int rx487_rep
    .local pmc rx487_cur
    .local pmc rx487_debug
    (rx487_cur, rx487_pos, rx487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx487_cur
    .local pmc match
    .lex "$/", match
    length rx487_eos, rx487_tgt
    gt rx487_pos, rx487_eos, rx487_done
    set rx487_off, 0
    lt rx487_pos, 2, rx487_start
    sub rx487_off, rx487_pos, 1
    substr rx487_tgt, rx487_tgt, rx487_off
  rx487_start:
    eq $I10, 1, rx487_restart
    if_null rx487_debug, debug_618
    rx487_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan491_done
    goto rxscan491_scan
  rxscan491_loop:
    (rx487_pos) = rx487_cur."from"()
    inc rx487_pos
    rx487_cur."!cursor_from"(rx487_pos)
    ge rx487_pos, rx487_eos, rxscan491_done
  rxscan491_scan:
    set_addr $I10, rxscan491_loop
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  rxscan491_done:
.annotate 'line', 253
  # rx subrule "routine_declarator" subtype=capture negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."routine_declarator"()
    unless $P10, rx487_fail
    rx487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx487_pos = $P10."pos"()
  # rx pass
    rx487_cur."!cursor_pass"(rx487_pos, "term:sym<routine_declarator>")
    if_null rx487_debug, debug_619
    rx487_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx487_pos)
  debug_619:
    .return (rx487_cur)
  rx487_restart:
.annotate 'line', 4
    if_null rx487_debug, debug_620
    rx487_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_620:
  rx487_fail:
    (rx487_rep, rx487_pos, $I10, $P10) = rx487_cur."!mark_fail"(0)
    lt rx487_pos, -1, rx487_done
    eq rx487_pos, -1, rx487_fail
    jump $I10
  rx487_done:
    rx487_cur."!cursor_fail"()
    if_null rx487_debug, debug_621
    rx487_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_621:
    .return (rx487_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("112_1298845521.609") :method
.annotate 'line', 4
    $P489 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P490, "ResizablePMCArray"
    push $P490, $P489
    .return ($P490)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("113_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P503 = "116_1298845521.609" 
    capture_lex $P503
    .const 'Sub' $P498 = "115_1298845521.609" 
    capture_lex $P498
    .local string rx493_tgt
    .local int rx493_pos
    .local int rx493_off
    .local int rx493_eos
    .local int rx493_rep
    .local pmc rx493_cur
    .local pmc rx493_debug
    (rx493_cur, rx493_pos, rx493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx493_cur
    .local pmc match
    .lex "$/", match
    length rx493_eos, rx493_tgt
    gt rx493_pos, rx493_eos, rx493_done
    set rx493_off, 0
    lt rx493_pos, 2, rx493_start
    sub rx493_off, rx493_pos, 1
    substr rx493_tgt, rx493_tgt, rx493_off
  rx493_start:
    eq $I10, 1, rx493_restart
    if_null rx493_debug, debug_622
    rx493_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan496_done
    goto rxscan496_scan
  rxscan496_loop:
    (rx493_pos) = rx493_cur."from"()
    inc rx493_pos
    rx493_cur."!cursor_from"(rx493_pos)
    ge rx493_pos, rx493_eos, rxscan496_done
  rxscan496_scan:
    set_addr $I10, rxscan496_loop
    rx493_cur."!mark_push"(0, rx493_pos, $I10)
  rxscan496_done:
.annotate 'line', 255
  # rx subrule "before" subtype=zerowidth negate=
    rx493_cur."!cursor_pos"(rx493_pos)
    .const 'Sub' $P498 = "115_1298845521.609" 
    capture_lex $P498
    $P10 = rx493_cur."before"($P498)
    unless $P10, rx493_fail
.annotate 'line', 256
  # rx subrule "before" subtype=zerowidth negate=1
    rx493_cur."!cursor_pos"(rx493_pos)
    .const 'Sub' $P503 = "116_1298845521.609" 
    capture_lex $P503
    $P10 = rx493_cur."before"($P503)
    if $P10, rx493_fail
.annotate 'line', 257
  # rx subrule "multi_declarator" subtype=capture negate=
    rx493_cur."!cursor_pos"(rx493_pos)
    $P10 = rx493_cur."multi_declarator"()
    unless $P10, rx493_fail
    rx493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx493_pos = $P10."pos"()
.annotate 'line', 254
  # rx pass
    rx493_cur."!cursor_pass"(rx493_pos, "term:sym<multi_declarator>")
    if_null rx493_debug, debug_631
    rx493_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx493_pos)
  debug_631:
    .return (rx493_cur)
  rx493_restart:
.annotate 'line', 4
    if_null rx493_debug, debug_632
    rx493_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_632:
  rx493_fail:
    (rx493_rep, rx493_pos, $I10, $P10) = rx493_cur."!mark_fail"(0)
    lt rx493_pos, -1, rx493_done
    eq rx493_pos, -1, rx493_fail
    jump $I10
  rx493_done:
    rx493_cur."!cursor_fail"()
    if_null rx493_debug, debug_633
    rx493_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_633:
    .return (rx493_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("114_1298845521.609") :method
.annotate 'line', 4
    new $P495, "ResizablePMCArray"
    push $P495, ""
    .return ($P495)
.end


.namespace ["NQP";"Grammar"]
.sub "_block497"  :anon :subid("115_1298845521.609") :method :outer("113_1298845521.609")
.annotate 'line', 255
    .local string rx499_tgt
    .local int rx499_pos
    .local int rx499_off
    .local int rx499_eos
    .local int rx499_rep
    .local pmc rx499_cur
    .local pmc rx499_debug
    (rx499_cur, rx499_pos, rx499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx499_cur
    .local pmc match
    .lex "$/", match
    length rx499_eos, rx499_tgt
    gt rx499_pos, rx499_eos, rx499_done
    set rx499_off, 0
    lt rx499_pos, 2, rx499_start
    sub rx499_off, rx499_pos, 1
    substr rx499_tgt, rx499_tgt, rx499_off
  rx499_start:
    eq $I10, 1, rx499_restart
    if_null rx499_debug, debug_623
    rx499_cur."!cursor_debug"("START", "")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan500_done
    goto rxscan500_scan
  rxscan500_loop:
    (rx499_pos) = rx499_cur."from"()
    inc rx499_pos
    rx499_cur."!cursor_from"(rx499_pos)
    ge rx499_pos, rx499_eos, rxscan500_done
  rxscan500_scan:
    set_addr $I10, rxscan500_loop
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  rxscan500_done:
  alt501_0:
    set_addr $I10, alt501_1
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  # rx literal  "multi"
    add $I11, rx499_pos, 5
    gt $I11, rx499_eos, rx499_fail
    sub $I11, rx499_pos, rx499_off
    substr $S10, rx499_tgt, $I11, 5
    ne $S10, "multi", rx499_fail
    add rx499_pos, 5
    goto alt501_end
  alt501_1:
    set_addr $I10, alt501_2
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  # rx literal  "proto"
    add $I11, rx499_pos, 5
    gt $I11, rx499_eos, rx499_fail
    sub $I11, rx499_pos, rx499_off
    substr $S10, rx499_tgt, $I11, 5
    ne $S10, "proto", rx499_fail
    add rx499_pos, 5
    goto alt501_end
  alt501_2:
  # rx literal  "only"
    add $I11, rx499_pos, 4
    gt $I11, rx499_eos, rx499_fail
    sub $I11, rx499_pos, rx499_off
    substr $S10, rx499_tgt, $I11, 4
    ne $S10, "only", rx499_fail
    add rx499_pos, 4
  alt501_end:
  # rx pass
    rx499_cur."!cursor_pass"(rx499_pos, "")
    if_null rx499_debug, debug_624
    rx499_cur."!cursor_debug"("PASS", "", " at pos=", rx499_pos)
  debug_624:
    .return (rx499_cur)
  rx499_restart:
    if_null rx499_debug, debug_625
    rx499_cur."!cursor_debug"("NEXT", "")
  debug_625:
  rx499_fail:
    (rx499_rep, rx499_pos, $I10, $P10) = rx499_cur."!mark_fail"(0)
    lt rx499_pos, -1, rx499_done
    eq rx499_pos, -1, rx499_fail
    jump $I10
  rx499_done:
    rx499_cur."!cursor_fail"()
    if_null rx499_debug, debug_626
    rx499_cur."!cursor_debug"("FAIL", "")
  debug_626:
    .return (rx499_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "_block502"  :anon :subid("116_1298845521.609") :method :outer("113_1298845521.609")
.annotate 'line', 256
    .local string rx504_tgt
    .local int rx504_pos
    .local int rx504_off
    .local int rx504_eos
    .local int rx504_rep
    .local pmc rx504_cur
    .local pmc rx504_debug
    (rx504_cur, rx504_pos, rx504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx504_cur
    .local pmc match
    .lex "$/", match
    length rx504_eos, rx504_tgt
    gt rx504_pos, rx504_eos, rx504_done
    set rx504_off, 0
    lt rx504_pos, 2, rx504_start
    sub rx504_off, rx504_pos, 1
    substr rx504_tgt, rx504_tgt, rx504_off
  rx504_start:
    eq $I10, 1, rx504_restart
    if_null rx504_debug, debug_627
    rx504_cur."!cursor_debug"("START", "")
  debug_627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan505_done
    goto rxscan505_scan
  rxscan505_loop:
    (rx504_pos) = rx504_cur."from"()
    inc rx504_pos
    rx504_cur."!cursor_from"(rx504_pos)
    ge rx504_pos, rx504_eos, rxscan505_done
  rxscan505_scan:
    set_addr $I10, rxscan505_loop
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  rxscan505_done:
  # rx literal  "proto"
    add $I11, rx504_pos, 5
    gt $I11, rx504_eos, rx504_fail
    sub $I11, rx504_pos, rx504_off
    substr $S10, rx504_tgt, $I11, 5
    ne $S10, "proto", rx504_fail
    add rx504_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx504_cur."!cursor_pos"(rx504_pos)
    $P10 = rx504_cur."ws"()
    unless $P10, rx504_fail
    rx504_pos = $P10."pos"()
  alt506_0:
    set_addr $I10, alt506_1
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  # rx literal  "regex"
    add $I11, rx504_pos, 5
    gt $I11, rx504_eos, rx504_fail
    sub $I11, rx504_pos, rx504_off
    substr $S10, rx504_tgt, $I11, 5
    ne $S10, "regex", rx504_fail
    add rx504_pos, 5
    goto alt506_end
  alt506_1:
    set_addr $I10, alt506_2
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  # rx literal  "token"
    add $I11, rx504_pos, 5
    gt $I11, rx504_eos, rx504_fail
    sub $I11, rx504_pos, rx504_off
    substr $S10, rx504_tgt, $I11, 5
    ne $S10, "token", rx504_fail
    add rx504_pos, 5
    goto alt506_end
  alt506_2:
  # rx literal  "rule"
    add $I11, rx504_pos, 4
    gt $I11, rx504_eos, rx504_fail
    sub $I11, rx504_pos, rx504_off
    substr $S10, rx504_tgt, $I11, 4
    ne $S10, "rule", rx504_fail
    add rx504_pos, 4
  alt506_end:
  # rx pass
    rx504_cur."!cursor_pass"(rx504_pos, "")
    if_null rx504_debug, debug_628
    rx504_cur."!cursor_debug"("PASS", "", " at pos=", rx504_pos)
  debug_628:
    .return (rx504_cur)
  rx504_restart:
    if_null rx504_debug, debug_629
    rx504_cur."!cursor_debug"("NEXT", "")
  debug_629:
  rx504_fail:
    (rx504_rep, rx504_pos, $I10, $P10) = rx504_cur."!mark_fail"(0)
    lt rx504_pos, -1, rx504_done
    eq rx504_pos, -1, rx504_fail
    jump $I10
  rx504_done:
    rx504_cur."!cursor_fail"()
    if_null rx504_debug, debug_630
    rx504_cur."!cursor_debug"("FAIL", "")
  debug_630:
    .return (rx504_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("117_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_634
    rx508_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan512_done
    goto rxscan512_scan
  rxscan512_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan512_done
  rxscan512_scan:
    set_addr $I10, rxscan512_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan512_done:
.annotate 'line', 259
  # rx subrule "regex_declarator" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."regex_declarator"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx508_pos = $P10."pos"()
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "term:sym<regex_declarator>")
    if_null rx508_debug, debug_635
    rx508_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx508_pos)
  debug_635:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 4
    if_null rx508_debug, debug_636
    rx508_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_636:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_637
    rx508_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_637:
    .return (rx508_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("118_1298845521.609") :method
.annotate 'line', 4
    $P510 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P511, "ResizablePMCArray"
    push $P511, $P510
    .return ($P511)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("119_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_638
    rx514_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan518_done
    goto rxscan518_scan
  rxscan518_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan518_done
  rxscan518_scan:
    set_addr $I10, rxscan518_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan518_done:
.annotate 'line', 260
  # rx subrule "statement_prefix" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."statement_prefix"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx514_pos = $P10."pos"()
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "term:sym<statement_prefix>")
    if_null rx514_debug, debug_639
    rx514_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx514_pos)
  debug_639:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 4
    if_null rx514_debug, debug_640
    rx514_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_640:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_641
    rx514_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_641:
    .return (rx514_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("120_1298845521.609") :method
.annotate 'line', 4
    $P516 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P517, "ResizablePMCArray"
    push $P517, $P516
    .return ($P517)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("121_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx520_tgt
    .local int rx520_pos
    .local int rx520_off
    .local int rx520_eos
    .local int rx520_rep
    .local pmc rx520_cur
    .local pmc rx520_debug
    (rx520_cur, rx520_pos, rx520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx520_cur
    .local pmc match
    .lex "$/", match
    length rx520_eos, rx520_tgt
    gt rx520_pos, rx520_eos, rx520_done
    set rx520_off, 0
    lt rx520_pos, 2, rx520_start
    sub rx520_off, rx520_pos, 1
    substr rx520_tgt, rx520_tgt, rx520_off
  rx520_start:
    eq $I10, 1, rx520_restart
    if_null rx520_debug, debug_642
    rx520_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan523_done
    goto rxscan523_scan
  rxscan523_loop:
    (rx520_pos) = rx520_cur."from"()
    inc rx520_pos
    rx520_cur."!cursor_from"(rx520_pos)
    ge rx520_pos, rx520_eos, rxscan523_done
  rxscan523_scan:
    set_addr $I10, rxscan523_loop
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  rxscan523_done:
.annotate 'line', 261
  # rx subrule "lambda" subtype=zerowidth negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."lambda"()
    unless $P10, rx520_fail
  # rx subrule "pblock" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."pblock"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx520_pos = $P10."pos"()
  # rx pass
    rx520_cur."!cursor_pass"(rx520_pos, "term:sym<lambda>")
    if_null rx520_debug, debug_643
    rx520_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx520_pos)
  debug_643:
    .return (rx520_cur)
  rx520_restart:
.annotate 'line', 4
    if_null rx520_debug, debug_644
    rx520_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_644:
  rx520_fail:
    (rx520_rep, rx520_pos, $I10, $P10) = rx520_cur."!mark_fail"(0)
    lt rx520_pos, -1, rx520_done
    eq rx520_pos, -1, rx520_fail
    jump $I10
  rx520_done:
    rx520_cur."!cursor_fail"()
    if_null rx520_debug, debug_645
    rx520_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_645:
    .return (rx520_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("122_1298845521.609") :method
.annotate 'line', 4
    new $P522, "ResizablePMCArray"
    push $P522, ""
    .return ($P522)
.end


.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("123_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx525_tgt
    .local int rx525_pos
    .local int rx525_off
    .local int rx525_eos
    .local int rx525_rep
    .local pmc rx525_cur
    .local pmc rx525_debug
    (rx525_cur, rx525_pos, rx525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx525_cur
    .local pmc match
    .lex "$/", match
    length rx525_eos, rx525_tgt
    gt rx525_pos, rx525_eos, rx525_done
    set rx525_off, 0
    lt rx525_pos, 2, rx525_start
    sub rx525_off, rx525_pos, 1
    substr rx525_tgt, rx525_tgt, rx525_off
  rx525_start:
    eq $I10, 1, rx525_restart
    if_null rx525_debug, debug_646
    rx525_cur."!cursor_debug"("START", "fatarrow")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx525_pos) = rx525_cur."from"()
    inc rx525_pos
    rx525_cur."!cursor_from"(rx525_pos)
    ge rx525_pos, rx525_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx525_cur."!mark_push"(0, rx525_pos, $I10)
  rxscan529_done:
.annotate 'line', 264
  # rx subrule "identifier" subtype=capture negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."identifier"()
    unless $P10, rx525_fail
    rx525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx525_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx525_pos, rx525_off
    set rx525_rep, 0
    sub $I12, rx525_eos, rx525_pos
  rxenumcharlistq530_loop:
    le $I12, 0, rxenumcharlistq530_done
    substr $S10, rx525_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq530_done
    inc rx525_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq530_loop
  rxenumcharlistq530_done:
    add rx525_pos, rx525_pos, rx525_rep
  # rx literal  "=>"
    add $I11, rx525_pos, 2
    gt $I11, rx525_eos, rx525_fail
    sub $I11, rx525_pos, rx525_off
    substr $S10, rx525_tgt, $I11, 2
    ne $S10, "=>", rx525_fail
    add rx525_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."ws"()
    unless $P10, rx525_fail
    rx525_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."EXPR"("i=")
    unless $P10, rx525_fail
    rx525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx525_pos = $P10."pos"()
.annotate 'line', 263
  # rx pass
    rx525_cur."!cursor_pass"(rx525_pos, "fatarrow")
    if_null rx525_debug, debug_647
    rx525_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx525_pos)
  debug_647:
    .return (rx525_cur)
  rx525_restart:
.annotate 'line', 4
    if_null rx525_debug, debug_648
    rx525_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_648:
  rx525_fail:
    (rx525_rep, rx525_pos, $I10, $P10) = rx525_cur."!mark_fail"(0)
    lt rx525_pos, -1, rx525_done
    eq rx525_pos, -1, rx525_fail
    jump $I10
  rx525_done:
    rx525_cur."!cursor_fail"()
    if_null rx525_debug, debug_649
    rx525_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_649:
    .return (rx525_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("124_1298845521.609") :method
.annotate 'line', 4
    $P527 = self."!PREFIX__!subrule"("identifier", "")
    new $P528, "ResizablePMCArray"
    push $P528, $P527
    .return ($P528)
.end


.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("125_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx532_tgt
    .local int rx532_pos
    .local int rx532_off
    .local int rx532_eos
    .local int rx532_rep
    .local pmc rx532_cur
    .local pmc rx532_debug
    (rx532_cur, rx532_pos, rx532_tgt, $I10) = self."!cursor_start"()
    rx532_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx532_cur
    .local pmc match
    .lex "$/", match
    length rx532_eos, rx532_tgt
    gt rx532_pos, rx532_eos, rx532_done
    set rx532_off, 0
    lt rx532_pos, 2, rx532_start
    sub rx532_off, rx532_pos, 1
    substr rx532_tgt, rx532_tgt, rx532_off
  rx532_start:
    eq $I10, 1, rx532_restart
    if_null rx532_debug, debug_650
    rx532_cur."!cursor_debug"("START", "colonpair")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan538_done
    goto rxscan538_scan
  rxscan538_loop:
    (rx532_pos) = rx532_cur."from"()
    inc rx532_pos
    rx532_cur."!cursor_from"(rx532_pos)
    ge rx532_pos, rx532_eos, rxscan538_done
  rxscan538_scan:
    set_addr $I10, rxscan538_loop
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxscan538_done:
.annotate 'line', 268
  # rx literal  ":"
    add $I11, rx532_pos, 1
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    ord $I11, rx532_tgt, $I11
    ne $I11, 58, rx532_fail
    add rx532_pos, 1
  alt539_0:
.annotate 'line', 269
    set_addr $I10, alt539_1
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
.annotate 'line', 270
  # rx subcapture "not"
    set_addr $I10, rxcap_540_fail
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "!"
    add $I11, rx532_pos, 1
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    ord $I11, rx532_tgt, $I11
    ne $I11, 33, rx532_fail
    add rx532_pos, 1
    set_addr $I10, rxcap_540_fail
    ($I12, $I11) = rx532_cur."!mark_peek"($I10)
    rx532_cur."!cursor_pos"($I11)
    ($P10) = rx532_cur."!cursor_start"()
    $P10."!cursor_pass"(rx532_pos, "")
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_540_done
  rxcap_540_fail:
    goto rx532_fail
  rxcap_540_done:
  # rx subrule "identifier" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."identifier"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx532_pos = $P10."pos"()
    goto alt539_end
  alt539_1:
    set_addr $I10, alt539_2
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
.annotate 'line', 271
  # rx subrule "identifier" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."identifier"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx532_pos = $P10."pos"()
  # rx rxquantr541 ** 0..1
    set_addr $I10, rxquantr541_done
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxquantr541_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."circumfix"()
    unless $P10, rx532_fail
    goto rxsubrule542_pass
  rxsubrule542_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx532_fail
  rxsubrule542_pass:
    set_addr $I10, rxsubrule542_back
    rx532_cur."!mark_push"(0, rx532_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx532_pos = $P10."pos"()
    set_addr $I10, rxquantr541_done
    (rx532_rep) = rx532_cur."!mark_commit"($I10)
  rxquantr541_done:
    goto alt539_end
  alt539_2:
.annotate 'line', 272
  # rx subrule "circumfix" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."circumfix"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx532_pos = $P10."pos"()
  alt539_end:
.annotate 'line', 267
  # rx pass
    rx532_cur."!cursor_pass"(rx532_pos, "colonpair")
    if_null rx532_debug, debug_651
    rx532_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx532_pos)
  debug_651:
    .return (rx532_cur)
  rx532_restart:
.annotate 'line', 4
    if_null rx532_debug, debug_652
    rx532_cur."!cursor_debug"("NEXT", "colonpair")
  debug_652:
  rx532_fail:
    (rx532_rep, rx532_pos, $I10, $P10) = rx532_cur."!mark_fail"(0)
    lt rx532_pos, -1, rx532_done
    eq rx532_pos, -1, rx532_fail
    jump $I10
  rx532_done:
    rx532_cur."!cursor_fail"()
    if_null rx532_debug, debug_653
    rx532_cur."!cursor_debug"("FAIL", "colonpair")
  debug_653:
    .return (rx532_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("126_1298845521.609") :method
.annotate 'line', 4
    $P534 = self."!PREFIX__!subrule"("circumfix", ":")
    $P535 = self."!PREFIX__!subrule"("identifier", ":")
    $P536 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P537, "ResizablePMCArray"
    push $P537, $P534
    push $P537, $P535
    push $P537, $P536
    .return ($P537)
.end


.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("127_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx544_tgt
    .local int rx544_pos
    .local int rx544_off
    .local int rx544_eos
    .local int rx544_rep
    .local pmc rx544_cur
    .local pmc rx544_debug
    (rx544_cur, rx544_pos, rx544_tgt, $I10) = self."!cursor_start"()
    rx544_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx544_cur
    .local pmc match
    .lex "$/", match
    length rx544_eos, rx544_tgt
    gt rx544_pos, rx544_eos, rx544_done
    set rx544_off, 0
    lt rx544_pos, 2, rx544_start
    sub rx544_off, rx544_pos, 1
    substr rx544_tgt, rx544_tgt, rx544_off
  rx544_start:
    eq $I10, 1, rx544_restart
    if_null rx544_debug, debug_654
    rx544_cur."!cursor_debug"("START", "variable")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan549_done
    goto rxscan549_scan
  rxscan549_loop:
    (rx544_pos) = rx544_cur."from"()
    inc rx544_pos
    rx544_cur."!cursor_from"(rx544_pos)
    ge rx544_pos, rx544_eos, rxscan549_done
  rxscan549_scan:
    set_addr $I10, rxscan549_loop
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  rxscan549_done:
  alt550_0:
.annotate 'line', 276
    set_addr $I10, alt550_1
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
.annotate 'line', 277
  # rx subrule "sigil" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."sigil"()
    unless $P10, rx544_fail
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx544_pos = $P10."pos"()
  # rx rxquantr551 ** 0..1
    set_addr $I10, rxquantr551_done
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  rxquantr551_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."twigil"()
    unless $P10, rx544_fail
    goto rxsubrule552_pass
  rxsubrule552_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx544_fail
  rxsubrule552_pass:
    set_addr $I10, rxsubrule552_back
    rx544_cur."!mark_push"(0, rx544_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx544_pos = $P10."pos"()
    set_addr $I10, rxquantr551_done
    (rx544_rep) = rx544_cur."!mark_commit"($I10)
  rxquantr551_done:
  # rx subrule "name" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."name"()
    unless $P10, rx544_fail
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx544_pos = $P10."pos"()
    goto alt550_end
  alt550_1:
    set_addr $I10, alt550_2
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
.annotate 'line', 278
  # rx subrule "sigil" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."sigil"()
    unless $P10, rx544_fail
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx544_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx544_pos, rx544_off
    substr $S10, rx544_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx544_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."postcircumfix"()
    unless $P10, rx544_fail
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx544_pos = $P10."pos"()
    goto alt550_end
  alt550_2:
.annotate 'line', 279
  # rx subcapture "sigil"
    set_addr $I10, rxcap_553_fail
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  # rx literal  "$"
    add $I11, rx544_pos, 1
    gt $I11, rx544_eos, rx544_fail
    sub $I11, rx544_pos, rx544_off
    ord $I11, rx544_tgt, $I11
    ne $I11, 36, rx544_fail
    add rx544_pos, 1
    set_addr $I10, rxcap_553_fail
    ($I12, $I11) = rx544_cur."!mark_peek"($I10)
    rx544_cur."!cursor_pos"($I11)
    ($P10) = rx544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx544_pos, "")
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_553_done
  rxcap_553_fail:
    goto rx544_fail
  rxcap_553_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_554_fail
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx544_pos, rx544_eos, rx544_fail
    sub $I10, rx544_pos, rx544_off
    substr $S10, rx544_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx544_fail
    inc rx544_pos
    set_addr $I10, rxcap_554_fail
    ($I12, $I11) = rx544_cur."!mark_peek"($I10)
    rx544_cur."!cursor_pos"($I11)
    ($P10) = rx544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx544_pos, "")
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_554_done
  rxcap_554_fail:
    goto rx544_fail
  rxcap_554_done:
  alt550_end:
.annotate 'line', 276
  # rx pass
    rx544_cur."!cursor_pass"(rx544_pos, "variable")
    if_null rx544_debug, debug_655
    rx544_cur."!cursor_debug"("PASS", "variable", " at pos=", rx544_pos)
  debug_655:
    .return (rx544_cur)
  rx544_restart:
.annotate 'line', 4
    if_null rx544_debug, debug_656
    rx544_cur."!cursor_debug"("NEXT", "variable")
  debug_656:
  rx544_fail:
    (rx544_rep, rx544_pos, $I10, $P10) = rx544_cur."!mark_fail"(0)
    lt rx544_pos, -1, rx544_done
    eq rx544_pos, -1, rx544_fail
    jump $I10
  rx544_done:
    rx544_cur."!cursor_fail"()
    if_null rx544_debug, debug_657
    rx544_cur."!cursor_debug"("FAIL", "variable")
  debug_657:
    .return (rx544_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("128_1298845521.609") :method
.annotate 'line', 4
    $P546 = self."!PREFIX__!subrule"("sigil", "")
    $P547 = self."!PREFIX__!subrule"("sigil", "")
    new $P548, "ResizablePMCArray"
    push $P548, "$!"
    push $P548, "$_"
    push $P548, "$/"
    push $P548, $P546
    push $P548, $P547
    .return ($P548)
.end


.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("129_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx556_tgt
    .local int rx556_pos
    .local int rx556_off
    .local int rx556_eos
    .local int rx556_rep
    .local pmc rx556_cur
    .local pmc rx556_debug
    (rx556_cur, rx556_pos, rx556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx556_cur
    .local pmc match
    .lex "$/", match
    length rx556_eos, rx556_tgt
    gt rx556_pos, rx556_eos, rx556_done
    set rx556_off, 0
    lt rx556_pos, 2, rx556_start
    sub rx556_off, rx556_pos, 1
    substr rx556_tgt, rx556_tgt, rx556_off
  rx556_start:
    eq $I10, 1, rx556_restart
    if_null rx556_debug, debug_658
    rx556_cur."!cursor_debug"("START", "sigil")
  debug_658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan559_done
    goto rxscan559_scan
  rxscan559_loop:
    (rx556_pos) = rx556_cur."from"()
    inc rx556_pos
    rx556_cur."!cursor_from"(rx556_pos)
    ge rx556_pos, rx556_eos, rxscan559_done
  rxscan559_scan:
    set_addr $I10, rxscan559_loop
    rx556_cur."!mark_push"(0, rx556_pos, $I10)
  rxscan559_done:
.annotate 'line', 282
  # rx enumcharlist negate=0 
    ge rx556_pos, rx556_eos, rx556_fail
    sub $I10, rx556_pos, rx556_off
    substr $S10, rx556_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx556_fail
    inc rx556_pos
  # rx pass
    rx556_cur."!cursor_pass"(rx556_pos, "sigil")
    if_null rx556_debug, debug_659
    rx556_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx556_pos)
  debug_659:
    .return (rx556_cur)
  rx556_restart:
.annotate 'line', 4
    if_null rx556_debug, debug_660
    rx556_cur."!cursor_debug"("NEXT", "sigil")
  debug_660:
  rx556_fail:
    (rx556_rep, rx556_pos, $I10, $P10) = rx556_cur."!mark_fail"(0)
    lt rx556_pos, -1, rx556_done
    eq rx556_pos, -1, rx556_fail
    jump $I10
  rx556_done:
    rx556_cur."!cursor_fail"()
    if_null rx556_debug, debug_661
    rx556_cur."!cursor_debug"("FAIL", "sigil")
  debug_661:
    .return (rx556_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("130_1298845521.609") :method
.annotate 'line', 4
    new $P558, "ResizablePMCArray"
    push $P558, "&"
    push $P558, "%"
    push $P558, "@"
    push $P558, "$"
    .return ($P558)
.end


.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("131_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx561_tgt
    .local int rx561_pos
    .local int rx561_off
    .local int rx561_eos
    .local int rx561_rep
    .local pmc rx561_cur
    .local pmc rx561_debug
    (rx561_cur, rx561_pos, rx561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx561_cur
    .local pmc match
    .lex "$/", match
    length rx561_eos, rx561_tgt
    gt rx561_pos, rx561_eos, rx561_done
    set rx561_off, 0
    lt rx561_pos, 2, rx561_start
    sub rx561_off, rx561_pos, 1
    substr rx561_tgt, rx561_tgt, rx561_off
  rx561_start:
    eq $I10, 1, rx561_restart
    if_null rx561_debug, debug_662
    rx561_cur."!cursor_debug"("START", "twigil")
  debug_662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan564_done
    goto rxscan564_scan
  rxscan564_loop:
    (rx561_pos) = rx561_cur."from"()
    inc rx561_pos
    rx561_cur."!cursor_from"(rx561_pos)
    ge rx561_pos, rx561_eos, rxscan564_done
  rxscan564_scan:
    set_addr $I10, rxscan564_loop
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  rxscan564_done:
.annotate 'line', 284
  # rx enumcharlist negate=0 
    ge rx561_pos, rx561_eos, rx561_fail
    sub $I10, rx561_pos, rx561_off
    substr $S10, rx561_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx561_fail
    inc rx561_pos
  # rx pass
    rx561_cur."!cursor_pass"(rx561_pos, "twigil")
    if_null rx561_debug, debug_663
    rx561_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx561_pos)
  debug_663:
    .return (rx561_cur)
  rx561_restart:
.annotate 'line', 4
    if_null rx561_debug, debug_664
    rx561_cur."!cursor_debug"("NEXT", "twigil")
  debug_664:
  rx561_fail:
    (rx561_rep, rx561_pos, $I10, $P10) = rx561_cur."!mark_fail"(0)
    lt rx561_pos, -1, rx561_done
    eq rx561_pos, -1, rx561_fail
    jump $I10
  rx561_done:
    rx561_cur."!cursor_fail"()
    if_null rx561_debug, debug_665
    rx561_cur."!cursor_debug"("FAIL", "twigil")
  debug_665:
    .return (rx561_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("132_1298845521.609") :method
.annotate 'line', 4
    new $P563, "ResizablePMCArray"
    push $P563, "?"
    push $P563, "!"
    push $P563, "*"
    .return ($P563)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("133_1298845521.609")
    .param pmc param_566
.annotate 'line', 286
    .lex "self", param_566
    $P567 = param_566."!protoregex"("package_declarator")
    .return ($P567)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("134_1298845521.609")
    .param pmc param_569
.annotate 'line', 286
    .lex "self", param_569
    $P570 = param_569."!PREFIX__!protoregex"("package_declarator")
    .return ($P570)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("135_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 288
    new $P572, "Undef"
    .lex "$*PACKAGE-SETUP", $P572
.annotate 'line', 289
    new $P573, "Undef"
    .lex "$*PKGDECL", $P573
.annotate 'line', 4
    .local string rx574_tgt
    .local int rx574_pos
    .local int rx574_off
    .local int rx574_eos
    .local int rx574_rep
    .local pmc rx574_cur
    .local pmc rx574_debug
    (rx574_cur, rx574_pos, rx574_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx574_cur
    .local pmc match
    .lex "$/", match
    length rx574_eos, rx574_tgt
    gt rx574_pos, rx574_eos, rx574_done
    set rx574_off, 0
    lt rx574_pos, 2, rx574_start
    sub rx574_off, rx574_pos, 1
    substr rx574_tgt, rx574_tgt, rx574_off
  rx574_start:
    eq $I10, 1, rx574_restart
    if_null rx574_debug, debug_666
    rx574_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan578_done
    goto rxscan578_scan
  rxscan578_loop:
    (rx574_pos) = rx574_cur."from"()
    inc rx574_pos
    rx574_cur."!cursor_from"(rx574_pos)
    ge rx574_pos, rx574_eos, rxscan578_done
  rxscan578_scan:
    set_addr $I10, rxscan578_loop
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxscan578_done:
.annotate 'line', 288
    rx574_cur."!cursor_pos"(rx574_pos)
    get_hll_global $P579, ["PAST"], "Stmts"
    $P580 = $P579."new"()
    store_lex "$*PACKAGE-SETUP", $P580
.annotate 'line', 289
    rx574_cur."!cursor_pos"(rx574_pos)
    new $P581, "String"
    assign $P581, "module"
    store_lex "$*PKGDECL", $P581
.annotate 'line', 290
  # rx subcapture "sym"
    set_addr $I10, rxcap_582_fail
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  # rx literal  "module"
    add $I11, rx574_pos, 6
    gt $I11, rx574_eos, rx574_fail
    sub $I11, rx574_pos, rx574_off
    substr $S10, rx574_tgt, $I11, 6
    ne $S10, "module", rx574_fail
    add rx574_pos, 6
    set_addr $I10, rxcap_582_fail
    ($I12, $I11) = rx574_cur."!mark_peek"($I10)
    rx574_cur."!cursor_pos"($I11)
    ($P10) = rx574_cur."!cursor_start"()
    $P10."!cursor_pass"(rx574_pos, "")
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_582_done
  rxcap_582_fail:
    goto rx574_fail
  rxcap_582_done:
  # rx subrule "package_def" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."package_def"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx574_pos = $P10."pos"()
.annotate 'line', 287
  # rx pass
    rx574_cur."!cursor_pass"(rx574_pos, "package_declarator:sym<module>")
    if_null rx574_debug, debug_667
    rx574_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx574_pos)
  debug_667:
    .return (rx574_cur)
  rx574_restart:
.annotate 'line', 4
    if_null rx574_debug, debug_668
    rx574_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_668:
  rx574_fail:
    (rx574_rep, rx574_pos, $I10, $P10) = rx574_cur."!mark_fail"(0)
    lt rx574_pos, -1, rx574_done
    eq rx574_pos, -1, rx574_fail
    jump $I10
  rx574_done:
    rx574_cur."!cursor_fail"()
    if_null rx574_debug, debug_669
    rx574_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_669:
    .return (rx574_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("136_1298845521.609") :method
.annotate 'line', 4
    $P576 = self."!PREFIX__!subrule"("package_def", "module")
    new $P577, "ResizablePMCArray"
    push $P577, $P576
    .return ($P577)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("137_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 293
    new $P584, "Undef"
    .lex "$*PACKAGE-SETUP", $P584
.annotate 'line', 294
    new $P585, "Undef"
    .lex "$*PKGDECL", $P585
.annotate 'line', 4
    .local string rx586_tgt
    .local int rx586_pos
    .local int rx586_off
    .local int rx586_eos
    .local int rx586_rep
    .local pmc rx586_cur
    .local pmc rx586_debug
    (rx586_cur, rx586_pos, rx586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx586_cur
    .local pmc match
    .lex "$/", match
    length rx586_eos, rx586_tgt
    gt rx586_pos, rx586_eos, rx586_done
    set rx586_off, 0
    lt rx586_pos, 2, rx586_start
    sub rx586_off, rx586_pos, 1
    substr rx586_tgt, rx586_tgt, rx586_off
  rx586_start:
    eq $I10, 1, rx586_restart
    if_null rx586_debug, debug_670
    rx586_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan590_done
    goto rxscan590_scan
  rxscan590_loop:
    (rx586_pos) = rx586_cur."from"()
    inc rx586_pos
    rx586_cur."!cursor_from"(rx586_pos)
    ge rx586_pos, rx586_eos, rxscan590_done
  rxscan590_scan:
    set_addr $I10, rxscan590_loop
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  rxscan590_done:
.annotate 'line', 293
    rx586_cur."!cursor_pos"(rx586_pos)
    get_hll_global $P591, ["PAST"], "Stmts"
    $P592 = $P591."new"()
    store_lex "$*PACKAGE-SETUP", $P592
.annotate 'line', 294
    rx586_cur."!cursor_pos"(rx586_pos)
    new $P593, "String"
    assign $P593, "knowhow"
    store_lex "$*PKGDECL", $P593
.annotate 'line', 295
  # rx subcapture "sym"
    set_addr $I10, rxcap_594_fail
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx586_pos, 7
    gt $I11, rx586_eos, rx586_fail
    sub $I11, rx586_pos, rx586_off
    substr $S10, rx586_tgt, $I11, 7
    ne $S10, "knowhow", rx586_fail
    add rx586_pos, 7
    set_addr $I10, rxcap_594_fail
    ($I12, $I11) = rx586_cur."!mark_peek"($I10)
    rx586_cur."!cursor_pos"($I11)
    ($P10) = rx586_cur."!cursor_start"()
    $P10."!cursor_pass"(rx586_pos, "")
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_594_done
  rxcap_594_fail:
    goto rx586_fail
  rxcap_594_done:
  # rx subrule "package_def" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."package_def"()
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx586_pos = $P10."pos"()
.annotate 'line', 292
  # rx pass
    rx586_cur."!cursor_pass"(rx586_pos, "package_declarator:sym<knowhow>")
    if_null rx586_debug, debug_671
    rx586_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx586_pos)
  debug_671:
    .return (rx586_cur)
  rx586_restart:
.annotate 'line', 4
    if_null rx586_debug, debug_672
    rx586_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_672:
  rx586_fail:
    (rx586_rep, rx586_pos, $I10, $P10) = rx586_cur."!mark_fail"(0)
    lt rx586_pos, -1, rx586_done
    eq rx586_pos, -1, rx586_fail
    jump $I10
  rx586_done:
    rx586_cur."!cursor_fail"()
    if_null rx586_debug, debug_673
    rx586_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_673:
    .return (rx586_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("138_1298845521.609") :method
.annotate 'line', 4
    $P588 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P589, "ResizablePMCArray"
    push $P589, $P588
    .return ($P589)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("139_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 298
    new $P596, "Undef"
    .lex "$*PACKAGE-SETUP", $P596
.annotate 'line', 299
    new $P597, "Undef"
    .lex "$*PKGDECL", $P597
.annotate 'line', 4
    .local string rx598_tgt
    .local int rx598_pos
    .local int rx598_off
    .local int rx598_eos
    .local int rx598_rep
    .local pmc rx598_cur
    .local pmc rx598_debug
    (rx598_cur, rx598_pos, rx598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx598_cur
    .local pmc match
    .lex "$/", match
    length rx598_eos, rx598_tgt
    gt rx598_pos, rx598_eos, rx598_done
    set rx598_off, 0
    lt rx598_pos, 2, rx598_start
    sub rx598_off, rx598_pos, 1
    substr rx598_tgt, rx598_tgt, rx598_off
  rx598_start:
    eq $I10, 1, rx598_restart
    if_null rx598_debug, debug_674
    rx598_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan602_done
    goto rxscan602_scan
  rxscan602_loop:
    (rx598_pos) = rx598_cur."from"()
    inc rx598_pos
    rx598_cur."!cursor_from"(rx598_pos)
    ge rx598_pos, rx598_eos, rxscan602_done
  rxscan602_scan:
    set_addr $I10, rxscan602_loop
    rx598_cur."!mark_push"(0, rx598_pos, $I10)
  rxscan602_done:
.annotate 'line', 298
    rx598_cur."!cursor_pos"(rx598_pos)
    get_hll_global $P603, ["PAST"], "Stmts"
    $P604 = $P603."new"()
    store_lex "$*PACKAGE-SETUP", $P604
.annotate 'line', 299
    rx598_cur."!cursor_pos"(rx598_pos)
    new $P605, "String"
    assign $P605, "class"
    store_lex "$*PKGDECL", $P605
.annotate 'line', 300
  # rx subcapture "sym"
    set_addr $I10, rxcap_606_fail
    rx598_cur."!mark_push"(0, rx598_pos, $I10)
  # rx literal  "class"
    add $I11, rx598_pos, 5
    gt $I11, rx598_eos, rx598_fail
    sub $I11, rx598_pos, rx598_off
    substr $S10, rx598_tgt, $I11, 5
    ne $S10, "class", rx598_fail
    add rx598_pos, 5
    set_addr $I10, rxcap_606_fail
    ($I12, $I11) = rx598_cur."!mark_peek"($I10)
    rx598_cur."!cursor_pos"($I11)
    ($P10) = rx598_cur."!cursor_start"()
    $P10."!cursor_pass"(rx598_pos, "")
    rx598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_606_done
  rxcap_606_fail:
    goto rx598_fail
  rxcap_606_done:
  # rx subrule "package_def" subtype=capture negate=
    rx598_cur."!cursor_pos"(rx598_pos)
    $P10 = rx598_cur."package_def"()
    unless $P10, rx598_fail
    rx598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx598_pos = $P10."pos"()
.annotate 'line', 297
  # rx pass
    rx598_cur."!cursor_pass"(rx598_pos, "package_declarator:sym<class>")
    if_null rx598_debug, debug_675
    rx598_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx598_pos)
  debug_675:
    .return (rx598_cur)
  rx598_restart:
.annotate 'line', 4
    if_null rx598_debug, debug_676
    rx598_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_676:
  rx598_fail:
    (rx598_rep, rx598_pos, $I10, $P10) = rx598_cur."!mark_fail"(0)
    lt rx598_pos, -1, rx598_done
    eq rx598_pos, -1, rx598_fail
    jump $I10
  rx598_done:
    rx598_cur."!cursor_fail"()
    if_null rx598_debug, debug_677
    rx598_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_677:
    .return (rx598_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("140_1298845521.609") :method
.annotate 'line', 4
    $P600 = self."!PREFIX__!subrule"("package_def", "class")
    new $P601, "ResizablePMCArray"
    push $P601, $P600
    .return ($P601)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("141_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 303
    new $P608, "Undef"
    .lex "$*PACKAGE-SETUP", $P608
.annotate 'line', 304
    new $P609, "Undef"
    .lex "$*PKGDECL", $P609
.annotate 'line', 4
    .local string rx610_tgt
    .local int rx610_pos
    .local int rx610_off
    .local int rx610_eos
    .local int rx610_rep
    .local pmc rx610_cur
    .local pmc rx610_debug
    (rx610_cur, rx610_pos, rx610_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx610_cur
    .local pmc match
    .lex "$/", match
    length rx610_eos, rx610_tgt
    gt rx610_pos, rx610_eos, rx610_done
    set rx610_off, 0
    lt rx610_pos, 2, rx610_start
    sub rx610_off, rx610_pos, 1
    substr rx610_tgt, rx610_tgt, rx610_off
  rx610_start:
    eq $I10, 1, rx610_restart
    if_null rx610_debug, debug_678
    rx610_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan614_done
    goto rxscan614_scan
  rxscan614_loop:
    (rx610_pos) = rx610_cur."from"()
    inc rx610_pos
    rx610_cur."!cursor_from"(rx610_pos)
    ge rx610_pos, rx610_eos, rxscan614_done
  rxscan614_scan:
    set_addr $I10, rxscan614_loop
    rx610_cur."!mark_push"(0, rx610_pos, $I10)
  rxscan614_done:
.annotate 'line', 303
    rx610_cur."!cursor_pos"(rx610_pos)
    get_hll_global $P615, ["PAST"], "Stmts"
    $P616 = $P615."new"()
    store_lex "$*PACKAGE-SETUP", $P616
.annotate 'line', 304
    rx610_cur."!cursor_pos"(rx610_pos)
    new $P617, "String"
    assign $P617, "grammar"
    store_lex "$*PKGDECL", $P617
.annotate 'line', 305
  # rx subcapture "sym"
    set_addr $I10, rxcap_618_fail
    rx610_cur."!mark_push"(0, rx610_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx610_pos, 7
    gt $I11, rx610_eos, rx610_fail
    sub $I11, rx610_pos, rx610_off
    substr $S10, rx610_tgt, $I11, 7
    ne $S10, "grammar", rx610_fail
    add rx610_pos, 7
    set_addr $I10, rxcap_618_fail
    ($I12, $I11) = rx610_cur."!mark_peek"($I10)
    rx610_cur."!cursor_pos"($I11)
    ($P10) = rx610_cur."!cursor_start"()
    $P10."!cursor_pass"(rx610_pos, "")
    rx610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_618_done
  rxcap_618_fail:
    goto rx610_fail
  rxcap_618_done:
  # rx subrule "package_def" subtype=capture negate=
    rx610_cur."!cursor_pos"(rx610_pos)
    $P10 = rx610_cur."package_def"()
    unless $P10, rx610_fail
    rx610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx610_pos = $P10."pos"()
.annotate 'line', 302
  # rx pass
    rx610_cur."!cursor_pass"(rx610_pos, "package_declarator:sym<grammar>")
    if_null rx610_debug, debug_679
    rx610_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx610_pos)
  debug_679:
    .return (rx610_cur)
  rx610_restart:
.annotate 'line', 4
    if_null rx610_debug, debug_680
    rx610_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_680:
  rx610_fail:
    (rx610_rep, rx610_pos, $I10, $P10) = rx610_cur."!mark_fail"(0)
    lt rx610_pos, -1, rx610_done
    eq rx610_pos, -1, rx610_fail
    jump $I10
  rx610_done:
    rx610_cur."!cursor_fail"()
    if_null rx610_debug, debug_681
    rx610_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_681:
    .return (rx610_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("142_1298845521.609") :method
.annotate 'line', 4
    $P612 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P613, "ResizablePMCArray"
    push $P613, $P612
    .return ($P613)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("143_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 308
    new $P620, "Undef"
    .lex "$*PACKAGE-SETUP", $P620
.annotate 'line', 309
    new $P621, "Undef"
    .lex "$*PKGDECL", $P621
.annotate 'line', 4
    .local string rx622_tgt
    .local int rx622_pos
    .local int rx622_off
    .local int rx622_eos
    .local int rx622_rep
    .local pmc rx622_cur
    .local pmc rx622_debug
    (rx622_cur, rx622_pos, rx622_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx622_cur
    .local pmc match
    .lex "$/", match
    length rx622_eos, rx622_tgt
    gt rx622_pos, rx622_eos, rx622_done
    set rx622_off, 0
    lt rx622_pos, 2, rx622_start
    sub rx622_off, rx622_pos, 1
    substr rx622_tgt, rx622_tgt, rx622_off
  rx622_start:
    eq $I10, 1, rx622_restart
    if_null rx622_debug, debug_682
    rx622_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan626_done
    goto rxscan626_scan
  rxscan626_loop:
    (rx622_pos) = rx622_cur."from"()
    inc rx622_pos
    rx622_cur."!cursor_from"(rx622_pos)
    ge rx622_pos, rx622_eos, rxscan626_done
  rxscan626_scan:
    set_addr $I10, rxscan626_loop
    rx622_cur."!mark_push"(0, rx622_pos, $I10)
  rxscan626_done:
.annotate 'line', 308
    rx622_cur."!cursor_pos"(rx622_pos)
    get_hll_global $P627, ["PAST"], "Stmts"
    $P628 = $P627."new"()
    store_lex "$*PACKAGE-SETUP", $P628
.annotate 'line', 309
    rx622_cur."!cursor_pos"(rx622_pos)
    new $P629, "String"
    assign $P629, "role"
    store_lex "$*PKGDECL", $P629
.annotate 'line', 310
  # rx subcapture "sym"
    set_addr $I10, rxcap_630_fail
    rx622_cur."!mark_push"(0, rx622_pos, $I10)
  # rx literal  "role"
    add $I11, rx622_pos, 4
    gt $I11, rx622_eos, rx622_fail
    sub $I11, rx622_pos, rx622_off
    substr $S10, rx622_tgt, $I11, 4
    ne $S10, "role", rx622_fail
    add rx622_pos, 4
    set_addr $I10, rxcap_630_fail
    ($I12, $I11) = rx622_cur."!mark_peek"($I10)
    rx622_cur."!cursor_pos"($I11)
    ($P10) = rx622_cur."!cursor_start"()
    $P10."!cursor_pass"(rx622_pos, "")
    rx622_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_630_done
  rxcap_630_fail:
    goto rx622_fail
  rxcap_630_done:
  # rx subrule "package_def" subtype=capture negate=
    rx622_cur."!cursor_pos"(rx622_pos)
    $P10 = rx622_cur."package_def"()
    unless $P10, rx622_fail
    rx622_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx622_pos = $P10."pos"()
.annotate 'line', 307
  # rx pass
    rx622_cur."!cursor_pass"(rx622_pos, "package_declarator:sym<role>")
    if_null rx622_debug, debug_683
    rx622_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx622_pos)
  debug_683:
    .return (rx622_cur)
  rx622_restart:
.annotate 'line', 4
    if_null rx622_debug, debug_684
    rx622_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_684:
  rx622_fail:
    (rx622_rep, rx622_pos, $I10, $P10) = rx622_cur."!mark_fail"(0)
    lt rx622_pos, -1, rx622_done
    eq rx622_pos, -1, rx622_fail
    jump $I10
  rx622_done:
    rx622_cur."!cursor_fail"()
    if_null rx622_debug, debug_685
    rx622_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_685:
    .return (rx622_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("144_1298845521.609") :method
.annotate 'line', 4
    $P624 = self."!PREFIX__!subrule"("package_def", "role")
    new $P625, "ResizablePMCArray"
    push $P625, $P624
    .return ($P625)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("145_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 313
    new $P632, "Undef"
    .lex "$*PACKAGE-SETUP", $P632
.annotate 'line', 314
    new $P633, "Undef"
    .lex "$*PKGDECL", $P633
.annotate 'line', 4
    .local string rx634_tgt
    .local int rx634_pos
    .local int rx634_off
    .local int rx634_eos
    .local int rx634_rep
    .local pmc rx634_cur
    .local pmc rx634_debug
    (rx634_cur, rx634_pos, rx634_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx634_cur
    .local pmc match
    .lex "$/", match
    length rx634_eos, rx634_tgt
    gt rx634_pos, rx634_eos, rx634_done
    set rx634_off, 0
    lt rx634_pos, 2, rx634_start
    sub rx634_off, rx634_pos, 1
    substr rx634_tgt, rx634_tgt, rx634_off
  rx634_start:
    eq $I10, 1, rx634_restart
    if_null rx634_debug, debug_686
    rx634_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan638_done
    goto rxscan638_scan
  rxscan638_loop:
    (rx634_pos) = rx634_cur."from"()
    inc rx634_pos
    rx634_cur."!cursor_from"(rx634_pos)
    ge rx634_pos, rx634_eos, rxscan638_done
  rxscan638_scan:
    set_addr $I10, rxscan638_loop
    rx634_cur."!mark_push"(0, rx634_pos, $I10)
  rxscan638_done:
.annotate 'line', 313
    rx634_cur."!cursor_pos"(rx634_pos)
    get_hll_global $P639, ["PAST"], "Stmts"
    $P640 = $P639."new"()
    store_lex "$*PACKAGE-SETUP", $P640
.annotate 'line', 314
    rx634_cur."!cursor_pos"(rx634_pos)
    new $P641, "String"
    assign $P641, "native"
    store_lex "$*PKGDECL", $P641
.annotate 'line', 315
  # rx subcapture "sym"
    set_addr $I10, rxcap_642_fail
    rx634_cur."!mark_push"(0, rx634_pos, $I10)
  # rx literal  "native"
    add $I11, rx634_pos, 6
    gt $I11, rx634_eos, rx634_fail
    sub $I11, rx634_pos, rx634_off
    substr $S10, rx634_tgt, $I11, 6
    ne $S10, "native", rx634_fail
    add rx634_pos, 6
    set_addr $I10, rxcap_642_fail
    ($I12, $I11) = rx634_cur."!mark_peek"($I10)
    rx634_cur."!cursor_pos"($I11)
    ($P10) = rx634_cur."!cursor_start"()
    $P10."!cursor_pass"(rx634_pos, "")
    rx634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_642_done
  rxcap_642_fail:
    goto rx634_fail
  rxcap_642_done:
  # rx subrule "package_def" subtype=capture negate=
    rx634_cur."!cursor_pos"(rx634_pos)
    $P10 = rx634_cur."package_def"()
    unless $P10, rx634_fail
    rx634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx634_pos = $P10."pos"()
.annotate 'line', 312
  # rx pass
    rx634_cur."!cursor_pass"(rx634_pos, "package_declarator:sym<native>")
    if_null rx634_debug, debug_687
    rx634_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx634_pos)
  debug_687:
    .return (rx634_cur)
  rx634_restart:
.annotate 'line', 4
    if_null rx634_debug, debug_688
    rx634_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_688:
  rx634_fail:
    (rx634_rep, rx634_pos, $I10, $P10) = rx634_cur."!mark_fail"(0)
    lt rx634_pos, -1, rx634_done
    eq rx634_pos, -1, rx634_fail
    jump $I10
  rx634_done:
    rx634_cur."!cursor_fail"()
    if_null rx634_debug, debug_689
    rx634_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_689:
    .return (rx634_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("146_1298845521.609") :method
.annotate 'line', 4
    $P636 = self."!PREFIX__!subrule"("package_def", "native")
    new $P637, "ResizablePMCArray"
    push $P637, $P636
    .return ($P637)
.end


.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("147_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx644_tgt
    .local int rx644_pos
    .local int rx644_off
    .local int rx644_eos
    .local int rx644_rep
    .local pmc rx644_cur
    .local pmc rx644_debug
    (rx644_cur, rx644_pos, rx644_tgt, $I10) = self."!cursor_start"()
    rx644_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx644_cur
    .local pmc match
    .lex "$/", match
    length rx644_eos, rx644_tgt
    gt rx644_pos, rx644_eos, rx644_done
    set rx644_off, 0
    lt rx644_pos, 2, rx644_start
    sub rx644_off, rx644_pos, 1
    substr rx644_tgt, rx644_tgt, rx644_off
  rx644_start:
    eq $I10, 1, rx644_restart
    if_null rx644_debug, debug_690
    rx644_cur."!cursor_debug"("START", "package_def")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan648_done
    goto rxscan648_scan
  rxscan648_loop:
    (rx644_pos) = rx644_cur."from"()
    inc rx644_pos
    rx644_cur."!cursor_from"(rx644_pos)
    ge rx644_pos, rx644_eos, rxscan648_done
  rxscan648_scan:
    set_addr $I10, rxscan648_loop
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxscan648_done:
.annotate 'line', 318
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 319
  # rx subrule "name" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."name"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 320
  # rx rxquantr651 ** 0..1
    set_addr $I10, rxquantr651_done
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxquantr651_loop:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx644_pos, 2
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 2
    ne $S10, "is", rx644_fail
    add rx644_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx644_pos, 5
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 5
    ne $S10, "repr(", rx644_fail
    add rx644_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."quote_EXPR"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx644_pos, 1
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    ord $I11, rx644_tgt, $I11
    ne $I11, 41, rx644_fail
    add rx644_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    set_addr $I10, rxquantr651_done
    (rx644_rep) = rx644_cur."!mark_commit"($I10)
  rxquantr651_done:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 321
  # rx rxquantr658 ** 0..1
    set_addr $I10, rxquantr658_done
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxquantr658_loop:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx644_pos, 2
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 2
    ne $S10, "is", rx644_fail
    add rx644_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."name"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    set_addr $I10, rxquantr658_done
    (rx644_rep) = rx644_cur."!mark_commit"($I10)
  rxquantr658_done:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 322
  # rx rxquantr663 ** 0..*
    set_addr $I10, rxquantr663_done
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxquantr663_loop:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx644_pos, 4
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 4
    ne $S10, "does", rx644_fail
    add rx644_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."name"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    set_addr $I10, rxquantr663_done
    (rx644_rep) = rx644_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr663_done
    rx644_cur."!mark_push"(rx644_rep, rx644_pos, $I10)
    goto rxquantr663_loop
  rxquantr663_done:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  alt668_0:
.annotate 'line', 323
    set_addr $I10, alt668_1
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
.annotate 'line', 324
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx644_pos, 1
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    ord $I11, rx644_tgt, $I11
    ne $I11, 59, rx644_fail
    add rx644_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."comp_unit"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    goto alt668_end
  alt668_1:
    set_addr $I10, alt668_2
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
.annotate 'line', 325
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx644_fail
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."block"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    goto alt668_end
  alt668_2:
.annotate 'line', 326
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."panic"("Malformed package declaration")
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  alt668_end:
.annotate 'line', 327
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx644_cur."!cursor_pass"(rx644_pos, "package_def")
    if_null rx644_debug, debug_691
    rx644_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx644_pos)
  debug_691:
    .return (rx644_cur)
  rx644_restart:
.annotate 'line', 4
    if_null rx644_debug, debug_692
    rx644_cur."!cursor_debug"("NEXT", "package_def")
  debug_692:
  rx644_fail:
    (rx644_rep, rx644_pos, $I10, $P10) = rx644_cur."!mark_fail"(0)
    lt rx644_pos, -1, rx644_done
    eq rx644_pos, -1, rx644_fail
    jump $I10
  rx644_done:
    rx644_cur."!cursor_fail"()
    if_null rx644_debug, debug_693
    rx644_cur."!cursor_debug"("FAIL", "package_def")
  debug_693:
    .return (rx644_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("148_1298845521.609") :method
.annotate 'line', 4
    $P646 = self."!PREFIX__!subrule"("ws", "")
    new $P647, "ResizablePMCArray"
    push $P647, $P646
    .return ($P647)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("149_1298845521.609")
    .param pmc param_679
.annotate 'line', 330
    .lex "self", param_679
    $P680 = param_679."!protoregex"("scope_declarator")
    .return ($P680)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("150_1298845521.609")
    .param pmc param_682
.annotate 'line', 330
    .lex "self", param_682
    $P683 = param_682."!PREFIX__!protoregex"("scope_declarator")
    .return ($P683)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("151_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx685_tgt
    .local int rx685_pos
    .local int rx685_off
    .local int rx685_eos
    .local int rx685_rep
    .local pmc rx685_cur
    .local pmc rx685_debug
    (rx685_cur, rx685_pos, rx685_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx685_cur
    .local pmc match
    .lex "$/", match
    length rx685_eos, rx685_tgt
    gt rx685_pos, rx685_eos, rx685_done
    set rx685_off, 0
    lt rx685_pos, 2, rx685_start
    sub rx685_off, rx685_pos, 1
    substr rx685_tgt, rx685_tgt, rx685_off
  rx685_start:
    eq $I10, 1, rx685_restart
    if_null rx685_debug, debug_694
    rx685_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan689_done
    goto rxscan689_scan
  rxscan689_loop:
    (rx685_pos) = rx685_cur."from"()
    inc rx685_pos
    rx685_cur."!cursor_from"(rx685_pos)
    ge rx685_pos, rx685_eos, rxscan689_done
  rxscan689_scan:
    set_addr $I10, rxscan689_loop
    rx685_cur."!mark_push"(0, rx685_pos, $I10)
  rxscan689_done:
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_690_fail
    rx685_cur."!mark_push"(0, rx685_pos, $I10)
  # rx literal  "my"
    add $I11, rx685_pos, 2
    gt $I11, rx685_eos, rx685_fail
    sub $I11, rx685_pos, rx685_off
    substr $S10, rx685_tgt, $I11, 2
    ne $S10, "my", rx685_fail
    add rx685_pos, 2
    set_addr $I10, rxcap_690_fail
    ($I12, $I11) = rx685_cur."!mark_peek"($I10)
    rx685_cur."!cursor_pos"($I11)
    ($P10) = rx685_cur."!cursor_start"()
    $P10."!cursor_pass"(rx685_pos, "")
    rx685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_690_done
  rxcap_690_fail:
    goto rx685_fail
  rxcap_690_done:
  # rx subrule "scoped" subtype=capture negate=
    rx685_cur."!cursor_pos"(rx685_pos)
    $P10 = rx685_cur."scoped"("my")
    unless $P10, rx685_fail
    rx685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx685_pos = $P10."pos"()
  # rx pass
    rx685_cur."!cursor_pass"(rx685_pos, "scope_declarator:sym<my>")
    if_null rx685_debug, debug_695
    rx685_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx685_pos)
  debug_695:
    .return (rx685_cur)
  rx685_restart:
.annotate 'line', 4
    if_null rx685_debug, debug_696
    rx685_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_696:
  rx685_fail:
    (rx685_rep, rx685_pos, $I10, $P10) = rx685_cur."!mark_fail"(0)
    lt rx685_pos, -1, rx685_done
    eq rx685_pos, -1, rx685_fail
    jump $I10
  rx685_done:
    rx685_cur."!cursor_fail"()
    if_null rx685_debug, debug_697
    rx685_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_697:
    .return (rx685_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("152_1298845521.609") :method
.annotate 'line', 4
    $P687 = self."!PREFIX__!subrule"("scoped", "my")
    new $P688, "ResizablePMCArray"
    push $P688, $P687
    .return ($P688)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("153_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx692_tgt
    .local int rx692_pos
    .local int rx692_off
    .local int rx692_eos
    .local int rx692_rep
    .local pmc rx692_cur
    .local pmc rx692_debug
    (rx692_cur, rx692_pos, rx692_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx692_cur
    .local pmc match
    .lex "$/", match
    length rx692_eos, rx692_tgt
    gt rx692_pos, rx692_eos, rx692_done
    set rx692_off, 0
    lt rx692_pos, 2, rx692_start
    sub rx692_off, rx692_pos, 1
    substr rx692_tgt, rx692_tgt, rx692_off
  rx692_start:
    eq $I10, 1, rx692_restart
    if_null rx692_debug, debug_698
    rx692_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan696_done
    goto rxscan696_scan
  rxscan696_loop:
    (rx692_pos) = rx692_cur."from"()
    inc rx692_pos
    rx692_cur."!cursor_from"(rx692_pos)
    ge rx692_pos, rx692_eos, rxscan696_done
  rxscan696_scan:
    set_addr $I10, rxscan696_loop
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxscan696_done:
.annotate 'line', 332
  # rx subcapture "sym"
    set_addr $I10, rxcap_697_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx literal  "our"
    add $I11, rx692_pos, 3
    gt $I11, rx692_eos, rx692_fail
    sub $I11, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I11, 3
    ne $S10, "our", rx692_fail
    add rx692_pos, 3
    set_addr $I10, rxcap_697_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_697_done
  rxcap_697_fail:
    goto rx692_fail
  rxcap_697_done:
  # rx subrule "scoped" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."scoped"("our")
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx692_pos = $P10."pos"()
  # rx pass
    rx692_cur."!cursor_pass"(rx692_pos, "scope_declarator:sym<our>")
    if_null rx692_debug, debug_699
    rx692_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx692_pos)
  debug_699:
    .return (rx692_cur)
  rx692_restart:
.annotate 'line', 4
    if_null rx692_debug, debug_700
    rx692_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_700:
  rx692_fail:
    (rx692_rep, rx692_pos, $I10, $P10) = rx692_cur."!mark_fail"(0)
    lt rx692_pos, -1, rx692_done
    eq rx692_pos, -1, rx692_fail
    jump $I10
  rx692_done:
    rx692_cur."!cursor_fail"()
    if_null rx692_debug, debug_701
    rx692_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_701:
    .return (rx692_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("154_1298845521.609") :method
.annotate 'line', 4
    $P694 = self."!PREFIX__!subrule"("scoped", "our")
    new $P695, "ResizablePMCArray"
    push $P695, $P694
    .return ($P695)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("155_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx699_tgt
    .local int rx699_pos
    .local int rx699_off
    .local int rx699_eos
    .local int rx699_rep
    .local pmc rx699_cur
    .local pmc rx699_debug
    (rx699_cur, rx699_pos, rx699_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx699_cur
    .local pmc match
    .lex "$/", match
    length rx699_eos, rx699_tgt
    gt rx699_pos, rx699_eos, rx699_done
    set rx699_off, 0
    lt rx699_pos, 2, rx699_start
    sub rx699_off, rx699_pos, 1
    substr rx699_tgt, rx699_tgt, rx699_off
  rx699_start:
    eq $I10, 1, rx699_restart
    if_null rx699_debug, debug_702
    rx699_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan703_done
    goto rxscan703_scan
  rxscan703_loop:
    (rx699_pos) = rx699_cur."from"()
    inc rx699_pos
    rx699_cur."!cursor_from"(rx699_pos)
    ge rx699_pos, rx699_eos, rxscan703_done
  rxscan703_scan:
    set_addr $I10, rxscan703_loop
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
  rxscan703_done:
.annotate 'line', 333
  # rx subcapture "sym"
    set_addr $I10, rxcap_704_fail
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
  # rx literal  "has"
    add $I11, rx699_pos, 3
    gt $I11, rx699_eos, rx699_fail
    sub $I11, rx699_pos, rx699_off
    substr $S10, rx699_tgt, $I11, 3
    ne $S10, "has", rx699_fail
    add rx699_pos, 3
    set_addr $I10, rxcap_704_fail
    ($I12, $I11) = rx699_cur."!mark_peek"($I10)
    rx699_cur."!cursor_pos"($I11)
    ($P10) = rx699_cur."!cursor_start"()
    $P10."!cursor_pass"(rx699_pos, "")
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_704_done
  rxcap_704_fail:
    goto rx699_fail
  rxcap_704_done:
  # rx subrule "scoped" subtype=capture negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."scoped"("has")
    unless $P10, rx699_fail
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx699_pos = $P10."pos"()
  # rx pass
    rx699_cur."!cursor_pass"(rx699_pos, "scope_declarator:sym<has>")
    if_null rx699_debug, debug_703
    rx699_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx699_pos)
  debug_703:
    .return (rx699_cur)
  rx699_restart:
.annotate 'line', 4
    if_null rx699_debug, debug_704
    rx699_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_704:
  rx699_fail:
    (rx699_rep, rx699_pos, $I10, $P10) = rx699_cur."!mark_fail"(0)
    lt rx699_pos, -1, rx699_done
    eq rx699_pos, -1, rx699_fail
    jump $I10
  rx699_done:
    rx699_cur."!cursor_fail"()
    if_null rx699_debug, debug_705
    rx699_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_705:
    .return (rx699_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("156_1298845521.609") :method
.annotate 'line', 4
    $P701 = self."!PREFIX__!subrule"("scoped", "has")
    new $P702, "ResizablePMCArray"
    push $P702, $P701
    .return ($P702)
.end


.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("157_1298845521.609") :method :outer("11_1298845521.609")
    .param pmc param_706
.annotate 'line', 335
    .lex "$*SCOPE", param_706
.annotate 'line', 4
    .local string rx707_tgt
    .local int rx707_pos
    .local int rx707_off
    .local int rx707_eos
    .local int rx707_rep
    .local pmc rx707_cur
    .local pmc rx707_debug
    (rx707_cur, rx707_pos, rx707_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx707_cur
    .local pmc match
    .lex "$/", match
    length rx707_eos, rx707_tgt
    gt rx707_pos, rx707_eos, rx707_done
    set rx707_off, 0
    lt rx707_pos, 2, rx707_start
    sub rx707_off, rx707_pos, 1
    substr rx707_tgt, rx707_tgt, rx707_off
  rx707_start:
    eq $I10, 1, rx707_restart
    if_null rx707_debug, debug_706
    rx707_cur."!cursor_debug"("START", "scoped")
  debug_706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan712_done
    goto rxscan712_scan
  rxscan712_loop:
    (rx707_pos) = rx707_cur."from"()
    inc rx707_pos
    rx707_cur."!cursor_from"(rx707_pos)
    ge rx707_pos, rx707_eos, rxscan712_done
  rxscan712_scan:
    set_addr $I10, rxscan712_loop
    rx707_cur."!mark_push"(0, rx707_pos, $I10)
  rxscan712_done:
  alt713_0:
.annotate 'line', 335
    set_addr $I10, alt713_1
    rx707_cur."!mark_push"(0, rx707_pos, $I10)
.annotate 'line', 336
  # rx subrule "ws" subtype=method negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."ws"()
    unless $P10, rx707_fail
    rx707_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."declarator"()
    unless $P10, rx707_fail
    rx707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx707_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."ws"()
    unless $P10, rx707_fail
    rx707_pos = $P10."pos"()
    goto alt713_end
  alt713_1:
.annotate 'line', 337
  # rx subrule "ws" subtype=method negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."ws"()
    unless $P10, rx707_fail
    rx707_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."multi_declarator"()
    unless $P10, rx707_fail
    rx707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx707_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."ws"()
    unless $P10, rx707_fail
    rx707_pos = $P10."pos"()
  alt713_end:
.annotate 'line', 335
  # rx pass
    rx707_cur."!cursor_pass"(rx707_pos, "scoped")
    if_null rx707_debug, debug_707
    rx707_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx707_pos)
  debug_707:
    .return (rx707_cur)
  rx707_restart:
.annotate 'line', 4
    if_null rx707_debug, debug_708
    rx707_cur."!cursor_debug"("NEXT", "scoped")
  debug_708:
  rx707_fail:
    (rx707_rep, rx707_pos, $I10, $P10) = rx707_cur."!mark_fail"(0)
    lt rx707_pos, -1, rx707_done
    eq rx707_pos, -1, rx707_fail
    jump $I10
  rx707_done:
    rx707_cur."!cursor_fail"()
    if_null rx707_debug, debug_709
    rx707_cur."!cursor_debug"("FAIL", "scoped")
  debug_709:
    .return (rx707_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("158_1298845521.609") :method
.annotate 'line', 4
    $P709 = self."!PREFIX__!subrule"("ws", "")
    $P710 = self."!PREFIX__!subrule"("ws", "")
    new $P711, "ResizablePMCArray"
    push $P711, $P709
    push $P711, $P710
    .return ($P711)
.end


.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("159_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx719_tgt
    .local int rx719_pos
    .local int rx719_off
    .local int rx719_eos
    .local int rx719_rep
    .local pmc rx719_cur
    .local pmc rx719_debug
    (rx719_cur, rx719_pos, rx719_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx719_cur
    .local pmc match
    .lex "$/", match
    length rx719_eos, rx719_tgt
    gt rx719_pos, rx719_eos, rx719_done
    set rx719_off, 0
    lt rx719_pos, 2, rx719_start
    sub rx719_off, rx719_pos, 1
    substr rx719_tgt, rx719_tgt, rx719_off
  rx719_start:
    eq $I10, 1, rx719_restart
    if_null rx719_debug, debug_710
    rx719_cur."!cursor_debug"("START", "typename")
  debug_710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan723_done
    goto rxscan723_scan
  rxscan723_loop:
    (rx719_pos) = rx719_cur."from"()
    inc rx719_pos
    rx719_cur."!cursor_from"(rx719_pos)
    ge rx719_pos, rx719_eos, rxscan723_done
  rxscan723_scan:
    set_addr $I10, rxscan723_loop
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxscan723_done:
.annotate 'line', 340
  # rx subrule "name" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."name"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx719_pos = $P10."pos"()
  # rx pass
    rx719_cur."!cursor_pass"(rx719_pos, "typename")
    if_null rx719_debug, debug_711
    rx719_cur."!cursor_debug"("PASS", "typename", " at pos=", rx719_pos)
  debug_711:
    .return (rx719_cur)
  rx719_restart:
.annotate 'line', 4
    if_null rx719_debug, debug_712
    rx719_cur."!cursor_debug"("NEXT", "typename")
  debug_712:
  rx719_fail:
    (rx719_rep, rx719_pos, $I10, $P10) = rx719_cur."!mark_fail"(0)
    lt rx719_pos, -1, rx719_done
    eq rx719_pos, -1, rx719_fail
    jump $I10
  rx719_done:
    rx719_cur."!cursor_fail"()
    if_null rx719_debug, debug_713
    rx719_cur."!cursor_debug"("FAIL", "typename")
  debug_713:
    .return (rx719_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("160_1298845521.609") :method
.annotate 'line', 4
    $P721 = self."!PREFIX__!subrule"("name", "")
    new $P722, "ResizablePMCArray"
    push $P722, $P721
    .return ($P722)
.end


.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("161_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx725_tgt
    .local int rx725_pos
    .local int rx725_off
    .local int rx725_eos
    .local int rx725_rep
    .local pmc rx725_cur
    .local pmc rx725_debug
    (rx725_cur, rx725_pos, rx725_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx725_cur
    .local pmc match
    .lex "$/", match
    length rx725_eos, rx725_tgt
    gt rx725_pos, rx725_eos, rx725_done
    set rx725_off, 0
    lt rx725_pos, 2, rx725_start
    sub rx725_off, rx725_pos, 1
    substr rx725_tgt, rx725_tgt, rx725_off
  rx725_start:
    eq $I10, 1, rx725_restart
    if_null rx725_debug, debug_714
    rx725_cur."!cursor_debug"("START", "declarator")
  debug_714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan730_done
    goto rxscan730_scan
  rxscan730_loop:
    (rx725_pos) = rx725_cur."from"()
    inc rx725_pos
    rx725_cur."!cursor_from"(rx725_pos)
    ge rx725_pos, rx725_eos, rxscan730_done
  rxscan730_scan:
    set_addr $I10, rxscan730_loop
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
  rxscan730_done:
  alt731_0:
.annotate 'line', 342
    set_addr $I10, alt731_1
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
.annotate 'line', 343
  # rx subrule "variable_declarator" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."variable_declarator"()
    unless $P10, rx725_fail
    rx725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx725_pos = $P10."pos"()
    goto alt731_end
  alt731_1:
.annotate 'line', 344
  # rx subrule "routine_declarator" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."routine_declarator"()
    unless $P10, rx725_fail
    rx725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx725_pos = $P10."pos"()
  alt731_end:
.annotate 'line', 342
  # rx pass
    rx725_cur."!cursor_pass"(rx725_pos, "declarator")
    if_null rx725_debug, debug_715
    rx725_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx725_pos)
  debug_715:
    .return (rx725_cur)
  rx725_restart:
.annotate 'line', 4
    if_null rx725_debug, debug_716
    rx725_cur."!cursor_debug"("NEXT", "declarator")
  debug_716:
  rx725_fail:
    (rx725_rep, rx725_pos, $I10, $P10) = rx725_cur."!mark_fail"(0)
    lt rx725_pos, -1, rx725_done
    eq rx725_pos, -1, rx725_fail
    jump $I10
  rx725_done:
    rx725_cur."!cursor_fail"()
    if_null rx725_debug, debug_717
    rx725_cur."!cursor_debug"("FAIL", "declarator")
  debug_717:
    .return (rx725_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("162_1298845521.609") :method
.annotate 'line', 4
    $P727 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P728 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P729, "ResizablePMCArray"
    push $P729, $P727
    push $P729, $P728
    .return ($P729)
.end


.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("163_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx733_tgt
    .local int rx733_pos
    .local int rx733_off
    .local int rx733_eos
    .local int rx733_rep
    .local pmc rx733_cur
    .local pmc rx733_debug
    (rx733_cur, rx733_pos, rx733_tgt, $I10) = self."!cursor_start"()
    rx733_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx733_cur
    .local pmc match
    .lex "$/", match
    length rx733_eos, rx733_tgt
    gt rx733_pos, rx733_eos, rx733_done
    set rx733_off, 0
    lt rx733_pos, 2, rx733_start
    sub rx733_off, rx733_pos, 1
    substr rx733_tgt, rx733_tgt, rx733_off
  rx733_start:
    eq $I10, 1, rx733_restart
    if_null rx733_debug, debug_718
    rx733_cur."!cursor_debug"("START", "variable_declarator")
  debug_718:
    $I10 = self.'from'()
    ne $I10, -1, rxscan737_done
    goto rxscan737_scan
  rxscan737_loop:
    (rx733_pos) = rx733_cur."from"()
    inc rx733_pos
    rx733_cur."!cursor_from"(rx733_pos)
    ge rx733_pos, rx733_eos, rxscan737_done
  rxscan737_scan:
    set_addr $I10, rxscan737_loop
    rx733_cur."!mark_push"(0, rx733_pos, $I10)
  rxscan737_done:
.annotate 'line', 347
  # rx subrule "ws" subtype=method negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."ws"()
    unless $P10, rx733_fail
    rx733_pos = $P10."pos"()
  # rx rxquantr739 ** 0..1
    set_addr $I10, rxquantr739_done
    rx733_cur."!mark_push"(0, rx733_pos, $I10)
  rxquantr739_loop:
  # rx subrule "typename" subtype=capture negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."typename"()
    unless $P10, rx733_fail
    goto rxsubrule740_pass
  rxsubrule740_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx733_fail
  rxsubrule740_pass:
    set_addr $I10, rxsubrule740_back
    rx733_cur."!mark_push"(0, rx733_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx733_pos = $P10."pos"()
    set_addr $I10, rxquantr739_done
    (rx733_rep) = rx733_cur."!mark_commit"($I10)
  rxquantr739_done:
  # rx subrule "ws" subtype=method negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."ws"()
    unless $P10, rx733_fail
    rx733_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."variable"()
    unless $P10, rx733_fail
    rx733_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx733_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."ws"()
    unless $P10, rx733_fail
    rx733_pos = $P10."pos"()
  # rx pass
    rx733_cur."!cursor_pass"(rx733_pos, "variable_declarator")
    if_null rx733_debug, debug_719
    rx733_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx733_pos)
  debug_719:
    .return (rx733_cur)
  rx733_restart:
.annotate 'line', 4
    if_null rx733_debug, debug_720
    rx733_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_720:
  rx733_fail:
    (rx733_rep, rx733_pos, $I10, $P10) = rx733_cur."!mark_fail"(0)
    lt rx733_pos, -1, rx733_done
    eq rx733_pos, -1, rx733_fail
    jump $I10
  rx733_done:
    rx733_cur."!cursor_fail"()
    if_null rx733_debug, debug_721
    rx733_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_721:
    .return (rx733_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("164_1298845521.609") :method
.annotate 'line', 4
    $P735 = self."!PREFIX__!subrule"("ws", "")
    new $P736, "ResizablePMCArray"
    push $P736, $P735
    .return ($P736)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("165_1298845521.609")
    .param pmc param_744
.annotate 'line', 349
    .lex "self", param_744
    $P745 = param_744."!protoregex"("routine_declarator")
    .return ($P745)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("166_1298845521.609")
    .param pmc param_747
.annotate 'line', 349
    .lex "self", param_747
    $P748 = param_747."!PREFIX__!protoregex"("routine_declarator")
    .return ($P748)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("167_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx750_tgt
    .local int rx750_pos
    .local int rx750_off
    .local int rx750_eos
    .local int rx750_rep
    .local pmc rx750_cur
    .local pmc rx750_debug
    (rx750_cur, rx750_pos, rx750_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx750_cur
    .local pmc match
    .lex "$/", match
    length rx750_eos, rx750_tgt
    gt rx750_pos, rx750_eos, rx750_done
    set rx750_off, 0
    lt rx750_pos, 2, rx750_start
    sub rx750_off, rx750_pos, 1
    substr rx750_tgt, rx750_tgt, rx750_off
  rx750_start:
    eq $I10, 1, rx750_restart
    if_null rx750_debug, debug_722
    rx750_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan754_done
    goto rxscan754_scan
  rxscan754_loop:
    (rx750_pos) = rx750_cur."from"()
    inc rx750_pos
    rx750_cur."!cursor_from"(rx750_pos)
    ge rx750_pos, rx750_eos, rxscan754_done
  rxscan754_scan:
    set_addr $I10, rxscan754_loop
    rx750_cur."!mark_push"(0, rx750_pos, $I10)
  rxscan754_done:
.annotate 'line', 350
  # rx subcapture "sym"
    set_addr $I10, rxcap_755_fail
    rx750_cur."!mark_push"(0, rx750_pos, $I10)
  # rx literal  "sub"
    add $I11, rx750_pos, 3
    gt $I11, rx750_eos, rx750_fail
    sub $I11, rx750_pos, rx750_off
    substr $S10, rx750_tgt, $I11, 3
    ne $S10, "sub", rx750_fail
    add rx750_pos, 3
    set_addr $I10, rxcap_755_fail
    ($I12, $I11) = rx750_cur."!mark_peek"($I10)
    rx750_cur."!cursor_pos"($I11)
    ($P10) = rx750_cur."!cursor_start"()
    $P10."!cursor_pass"(rx750_pos, "")
    rx750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_755_done
  rxcap_755_fail:
    goto rx750_fail
  rxcap_755_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx750_cur."!cursor_pos"(rx750_pos)
    $P10 = rx750_cur."routine_def"()
    unless $P10, rx750_fail
    rx750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx750_pos = $P10."pos"()
  # rx pass
    rx750_cur."!cursor_pass"(rx750_pos, "routine_declarator:sym<sub>")
    if_null rx750_debug, debug_723
    rx750_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx750_pos)
  debug_723:
    .return (rx750_cur)
  rx750_restart:
.annotate 'line', 4
    if_null rx750_debug, debug_724
    rx750_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_724:
  rx750_fail:
    (rx750_rep, rx750_pos, $I10, $P10) = rx750_cur."!mark_fail"(0)
    lt rx750_pos, -1, rx750_done
    eq rx750_pos, -1, rx750_fail
    jump $I10
  rx750_done:
    rx750_cur."!cursor_fail"()
    if_null rx750_debug, debug_725
    rx750_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_725:
    .return (rx750_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("168_1298845521.609") :method
.annotate 'line', 4
    $P752 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P753, "ResizablePMCArray"
    push $P753, $P752
    .return ($P753)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("169_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx757_tgt
    .local int rx757_pos
    .local int rx757_off
    .local int rx757_eos
    .local int rx757_rep
    .local pmc rx757_cur
    .local pmc rx757_debug
    (rx757_cur, rx757_pos, rx757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx757_cur
    .local pmc match
    .lex "$/", match
    length rx757_eos, rx757_tgt
    gt rx757_pos, rx757_eos, rx757_done
    set rx757_off, 0
    lt rx757_pos, 2, rx757_start
    sub rx757_off, rx757_pos, 1
    substr rx757_tgt, rx757_tgt, rx757_off
  rx757_start:
    eq $I10, 1, rx757_restart
    if_null rx757_debug, debug_726
    rx757_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_726:
    $I10 = self.'from'()
    ne $I10, -1, rxscan761_done
    goto rxscan761_scan
  rxscan761_loop:
    (rx757_pos) = rx757_cur."from"()
    inc rx757_pos
    rx757_cur."!cursor_from"(rx757_pos)
    ge rx757_pos, rx757_eos, rxscan761_done
  rxscan761_scan:
    set_addr $I10, rxscan761_loop
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxscan761_done:
.annotate 'line', 351
  # rx subcapture "sym"
    set_addr $I10, rxcap_762_fail
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  # rx literal  "method"
    add $I11, rx757_pos, 6
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    substr $S10, rx757_tgt, $I11, 6
    ne $S10, "method", rx757_fail
    add rx757_pos, 6
    set_addr $I10, rxcap_762_fail
    ($I12, $I11) = rx757_cur."!mark_peek"($I10)
    rx757_cur."!cursor_pos"($I11)
    ($P10) = rx757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx757_pos, "")
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_762_done
  rxcap_762_fail:
    goto rx757_fail
  rxcap_762_done:
  # rx subrule "method_def" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."method_def"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx757_pos = $P10."pos"()
  # rx pass
    rx757_cur."!cursor_pass"(rx757_pos, "routine_declarator:sym<method>")
    if_null rx757_debug, debug_727
    rx757_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx757_pos)
  debug_727:
    .return (rx757_cur)
  rx757_restart:
.annotate 'line', 4
    if_null rx757_debug, debug_728
    rx757_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_728:
  rx757_fail:
    (rx757_rep, rx757_pos, $I10, $P10) = rx757_cur."!mark_fail"(0)
    lt rx757_pos, -1, rx757_done
    eq rx757_pos, -1, rx757_fail
    jump $I10
  rx757_done:
    rx757_cur."!cursor_fail"()
    if_null rx757_debug, debug_729
    rx757_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_729:
    .return (rx757_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("170_1298845521.609") :method
.annotate 'line', 4
    $P759 = self."!PREFIX__!subrule"("method_def", "method")
    new $P760, "ResizablePMCArray"
    push $P760, $P759
    .return ($P760)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("171_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 354
    new $P764, "Undef"
    .lex "$*RETURN_USED", $P764
.annotate 'line', 4
    .local string rx765_tgt
    .local int rx765_pos
    .local int rx765_off
    .local int rx765_eos
    .local int rx765_rep
    .local pmc rx765_cur
    .local pmc rx765_debug
    (rx765_cur, rx765_pos, rx765_tgt, $I10) = self."!cursor_start"()
    rx765_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx765_cur
    .local pmc match
    .lex "$/", match
    length rx765_eos, rx765_tgt
    gt rx765_pos, rx765_eos, rx765_done
    set rx765_off, 0
    lt rx765_pos, 2, rx765_start
    sub rx765_off, rx765_pos, 1
    substr rx765_tgt, rx765_tgt, rx765_off
  rx765_start:
    eq $I10, 1, rx765_restart
    if_null rx765_debug, debug_730
    rx765_cur."!cursor_debug"("START", "routine_def")
  debug_730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan769_done
    goto rxscan769_scan
  rxscan769_loop:
    (rx765_pos) = rx765_cur."from"()
    inc rx765_pos
    rx765_cur."!cursor_from"(rx765_pos)
    ge rx765_pos, rx765_eos, rxscan769_done
  rxscan769_scan:
    set_addr $I10, rxscan769_loop
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  rxscan769_done:
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 354
    rx765_cur."!cursor_pos"(rx765_pos)
    new $P771, "Integer"
    assign $P771, 0
    store_lex "$*RETURN_USED", $P771
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 355
  # rx rxquantr773 ** 0..1
    set_addr $I10, rxquantr773_done
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  rxquantr773_loop:
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_776_fail
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  # rx rxquantr775 ** 0..1
    set_addr $I10, rxquantr775_done
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  rxquantr775_loop:
  # rx literal  "&"
    add $I11, rx765_pos, 1
    gt $I11, rx765_eos, rx765_fail
    sub $I11, rx765_pos, rx765_off
    ord $I11, rx765_tgt, $I11
    ne $I11, 38, rx765_fail
    add rx765_pos, 1
    set_addr $I10, rxquantr775_done
    (rx765_rep) = rx765_cur."!mark_commit"($I10)
  rxquantr775_done:
    set_addr $I10, rxcap_776_fail
    ($I12, $I11) = rx765_cur."!mark_peek"($I10)
    rx765_cur."!cursor_pos"($I11)
    ($P10) = rx765_cur."!cursor_start"()
    $P10."!cursor_pass"(rx765_pos, "")
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_776_done
  rxcap_776_fail:
    goto rx765_fail
  rxcap_776_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."deflongname"()
    unless $P10, rx765_fail
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
    set_addr $I10, rxquantr773_done
    (rx765_rep) = rx765_cur."!mark_commit"($I10)
  rxquantr773_done:
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 356
  # rx subrule "newpad" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."newpad"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  alt780_0:
.annotate 'line', 357
    set_addr $I10, alt780_1
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx765_pos, 1
    gt $I11, rx765_eos, rx765_fail
    sub $I11, rx765_pos, rx765_off
    ord $I11, rx765_tgt, $I11
    ne $I11, 40, rx765_fail
    add rx765_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."signature"()
    unless $P10, rx765_fail
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx765_pos, 1
    gt $I11, rx765_eos, rx765_fail
    sub $I11, rx765_pos, rx765_off
    ord $I11, rx765_tgt, $I11
    ne $I11, 41, rx765_fail
    add rx765_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
    goto alt780_end
  alt780_1:
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  alt780_end:
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 359
  # rx rxquantr788 ** 0..*
    set_addr $I10, rxquantr788_done
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  rxquantr788_loop:
  # rx subrule "trait" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."trait"()
    unless $P10, rx765_fail
    goto rxsubrule789_pass
  rxsubrule789_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx765_fail
  rxsubrule789_pass:
    set_addr $I10, rxsubrule789_back
    rx765_cur."!mark_push"(0, rx765_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx765_pos = $P10."pos"()
    set_addr $I10, rxquantr788_done
    (rx765_rep) = rx765_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr788_done
    rx765_cur."!mark_push"(rx765_rep, rx765_pos, $I10)
    goto rxquantr788_loop
  rxquantr788_done:
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  alt791_0:
.annotate 'line', 360
    set_addr $I10, alt791_1
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."onlystar"()
    unless $P10, rx765_fail
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
    goto alt791_end
  alt791_1:
.annotate 'line', 362
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."blockoid"()
    unless $P10, rx765_fail
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  alt791_end:
.annotate 'line', 363
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 353
  # rx pass
    rx765_cur."!cursor_pass"(rx765_pos, "routine_def")
    if_null rx765_debug, debug_731
    rx765_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx765_pos)
  debug_731:
    .return (rx765_cur)
  rx765_restart:
.annotate 'line', 4
    if_null rx765_debug, debug_732
    rx765_cur."!cursor_debug"("NEXT", "routine_def")
  debug_732:
  rx765_fail:
    (rx765_rep, rx765_pos, $I10, $P10) = rx765_cur."!mark_fail"(0)
    lt rx765_pos, -1, rx765_done
    eq rx765_pos, -1, rx765_fail
    jump $I10
  rx765_done:
    rx765_cur."!cursor_fail"()
    if_null rx765_debug, debug_733
    rx765_cur."!cursor_debug"("FAIL", "routine_def")
  debug_733:
    .return (rx765_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("172_1298845521.609") :method
.annotate 'line', 4
    $P767 = self."!PREFIX__!subrule"("ws", "")
    new $P768, "ResizablePMCArray"
    push $P768, $P767
    .return ($P768)
.end


.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("173_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P828 = "175_1298845521.609" 
    capture_lex $P828
.annotate 'line', 367
    new $P798, "Undef"
    .lex "$*RETURN_USED", $P798
.annotate 'line', 368
    new $P799, "Undef"
    .lex "$*INVOCANT_OK", $P799
.annotate 'line', 4
    .local string rx800_tgt
    .local int rx800_pos
    .local int rx800_off
    .local int rx800_eos
    .local int rx800_rep
    .local pmc rx800_cur
    .local pmc rx800_debug
    (rx800_cur, rx800_pos, rx800_tgt, $I10) = self."!cursor_start"()
    rx800_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx800_cur
    .local pmc match
    .lex "$/", match
    length rx800_eos, rx800_tgt
    gt rx800_pos, rx800_eos, rx800_done
    set rx800_off, 0
    lt rx800_pos, 2, rx800_start
    sub rx800_off, rx800_pos, 1
    substr rx800_tgt, rx800_tgt, rx800_off
  rx800_start:
    eq $I10, 1, rx800_restart
    if_null rx800_debug, debug_734
    rx800_cur."!cursor_debug"("START", "method_def")
  debug_734:
    $I10 = self.'from'()
    ne $I10, -1, rxscan804_done
    goto rxscan804_scan
  rxscan804_loop:
    (rx800_pos) = rx800_cur."from"()
    inc rx800_pos
    rx800_cur."!cursor_from"(rx800_pos)
    ge rx800_pos, rx800_eos, rxscan804_done
  rxscan804_scan:
    set_addr $I10, rxscan804_loop
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxscan804_done:
.annotate 'line', 366
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 367
    rx800_cur."!cursor_pos"(rx800_pos)
    new $P806, "Integer"
    assign $P806, 0
    store_lex "$*RETURN_USED", $P806
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 368
    rx800_cur."!cursor_pos"(rx800_pos)
    new $P808, "Integer"
    assign $P808, 1
    store_lex "$*INVOCANT_OK", $P808
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 369
  # rx subcapture "private"
    set_addr $I10, rxcap_811_fail
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  # rx rxquantr810 ** 0..1
    set_addr $I10, rxquantr810_done
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxquantr810_loop:
  # rx literal  "!"
    add $I11, rx800_pos, 1
    gt $I11, rx800_eos, rx800_fail
    sub $I11, rx800_pos, rx800_off
    ord $I11, rx800_tgt, $I11
    ne $I11, 33, rx800_fail
    add rx800_pos, 1
    set_addr $I10, rxquantr810_done
    (rx800_rep) = rx800_cur."!mark_commit"($I10)
  rxquantr810_done:
    set_addr $I10, rxcap_811_fail
    ($I12, $I11) = rx800_cur."!mark_peek"($I10)
    rx800_cur."!cursor_pos"($I11)
    ($P10) = rx800_cur."!cursor_start"()
    $P10."!cursor_pass"(rx800_pos, "")
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_811_done
  rxcap_811_fail:
    goto rx800_fail
  rxcap_811_done:
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 370
  # rx rxquantr813 ** 0..1
    set_addr $I10, rxquantr813_done
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxquantr813_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."deflongname"()
    unless $P10, rx800_fail
    goto rxsubrule814_pass
  rxsubrule814_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx800_fail
  rxsubrule814_pass:
    set_addr $I10, rxsubrule814_back
    rx800_cur."!mark_push"(0, rx800_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx800_pos = $P10."pos"()
    set_addr $I10, rxquantr813_done
    (rx800_rep) = rx800_cur."!mark_commit"($I10)
  rxquantr813_done:
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 371
  # rx subrule "newpad" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."newpad"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt817_0:
.annotate 'line', 372
    set_addr $I10, alt817_1
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx800_pos, 1
    gt $I11, rx800_eos, rx800_fail
    sub $I11, rx800_pos, rx800_off
    ord $I11, rx800_tgt, $I11
    ne $I11, 40, rx800_fail
    add rx800_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."signature"()
    unless $P10, rx800_fail
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx800_pos, 1
    gt $I11, rx800_eos, rx800_fail
    sub $I11, rx800_pos, rx800_off
    ord $I11, rx800_tgt, $I11
    ne $I11, 41, rx800_fail
    add rx800_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
    goto alt817_end
  alt817_1:
.annotate 'line', 373
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt817_end:
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 374
    rx800_cur."!cursor_pos"(rx800_pos)
    find_lex $P825, unicode:"$\x{a2}"
    $P826 = $P825."MATCH"()
    store_lex "$/", $P826
    .const 'Sub' $P828 = "175_1298845521.609" 
    capture_lex $P828
    $P830 = $P828()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 375
  # rx rxquantr832 ** 0..*
    set_addr $I10, rxquantr832_done
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxquantr832_loop:
  # rx subrule "trait" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."trait"()
    unless $P10, rx800_fail
    goto rxsubrule833_pass
  rxsubrule833_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx800_fail
  rxsubrule833_pass:
    set_addr $I10, rxsubrule833_back
    rx800_cur."!mark_push"(0, rx800_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx800_pos = $P10."pos"()
    set_addr $I10, rxquantr832_done
    (rx800_rep) = rx800_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr832_done
    rx800_cur."!mark_push"(rx800_rep, rx800_pos, $I10)
    goto rxquantr832_loop
  rxquantr832_done:
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt835_0:
.annotate 'line', 376
    set_addr $I10, alt835_1
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
.annotate 'line', 377
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."onlystar"()
    unless $P10, rx800_fail
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
    goto alt835_end
  alt835_1:
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."blockoid"()
    unless $P10, rx800_fail
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt835_end:
.annotate 'line', 379
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 366
  # rx pass
    rx800_cur."!cursor_pass"(rx800_pos, "method_def")
    if_null rx800_debug, debug_735
    rx800_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx800_pos)
  debug_735:
    .return (rx800_cur)
  rx800_restart:
.annotate 'line', 4
    if_null rx800_debug, debug_736
    rx800_cur."!cursor_debug"("NEXT", "method_def")
  debug_736:
  rx800_fail:
    (rx800_rep, rx800_pos, $I10, $P10) = rx800_cur."!mark_fail"(0)
    lt rx800_pos, -1, rx800_done
    eq rx800_pos, -1, rx800_fail
    jump $I10
  rx800_done:
    rx800_cur."!cursor_fail"()
    if_null rx800_debug, debug_737
    rx800_cur."!cursor_debug"("FAIL", "method_def")
  debug_737:
    .return (rx800_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("174_1298845521.609") :method
.annotate 'line', 4
    $P802 = self."!PREFIX__!subrule"("ws", "")
    new $P803, "ResizablePMCArray"
    push $P803, $P802
    .return ($P803)
.end


.namespace ["NQP";"Grammar"]
.sub "_block827"  :anon :subid("175_1298845521.609") :outer("173_1298845521.609")
.annotate 'line', 374
    new $P829, "Integer"
    assign $P829, 0
    store_dynamic_lex "$*INVOCANT_OK", $P829
    .return ($P829)
.end


.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("176_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P849 = "178_1298845521.609" 
    capture_lex $P849
    .local string rx842_tgt
    .local int rx842_pos
    .local int rx842_off
    .local int rx842_eos
    .local int rx842_rep
    .local pmc rx842_cur
    .local pmc rx842_debug
    (rx842_cur, rx842_pos, rx842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx842_cur
    .local pmc match
    .lex "$/", match
    length rx842_eos, rx842_tgt
    gt rx842_pos, rx842_eos, rx842_done
    set rx842_off, 0
    lt rx842_pos, 2, rx842_start
    sub rx842_off, rx842_pos, 1
    substr rx842_tgt, rx842_tgt, rx842_off
  rx842_start:
    eq $I10, 1, rx842_restart
    if_null rx842_debug, debug_738
    rx842_cur."!cursor_debug"("START", "onlystar")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan845_done
    goto rxscan845_scan
  rxscan845_loop:
    (rx842_pos) = rx842_cur."from"()
    inc rx842_pos
    rx842_cur."!cursor_from"(rx842_pos)
    ge rx842_pos, rx842_eos, rxscan845_done
  rxscan845_scan:
    set_addr $I10, rxscan845_loop
    rx842_cur."!mark_push"(0, rx842_pos, $I10)
  rxscan845_done:
.annotate 'line', 383
    rx842_cur."!cursor_pos"(rx842_pos)
    find_lex $P846, unicode:"$\x{a2}"
    $P847 = $P846."MATCH"()
    store_lex "$/", $P847
    .const 'Sub' $P849 = "178_1298845521.609" 
    capture_lex $P849
    $P853 = $P849()
    unless $P853, rx842_fail
.annotate 'line', 384
  # rx literal  "{"
    add $I11, rx842_pos, 1
    gt $I11, rx842_eos, rx842_fail
    sub $I11, rx842_pos, rx842_off
    ord $I11, rx842_tgt, $I11
    ne $I11, 123, rx842_fail
    add rx842_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."ws"()
    unless $P10, rx842_fail
    rx842_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx842_pos, 1
    gt $I11, rx842_eos, rx842_fail
    sub $I11, rx842_pos, rx842_off
    ord $I11, rx842_tgt, $I11
    ne $I11, 42, rx842_fail
    add rx842_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."ws"()
    unless $P10, rx842_fail
    rx842_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx842_pos, 1
    gt $I11, rx842_eos, rx842_fail
    sub $I11, rx842_pos, rx842_off
    ord $I11, rx842_tgt, $I11
    ne $I11, 125, rx842_fail
    add rx842_pos, 1
.annotate 'line', 385
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."ENDSTMT"()
    unless $P10, rx842_fail
.annotate 'line', 386
  # rx subrule "finishpad" subtype=method negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."finishpad"()
    unless $P10, rx842_fail
    rx842_pos = $P10."pos"()
.annotate 'line', 382
  # rx pass
    rx842_cur."!cursor_pass"(rx842_pos, "onlystar")
    if_null rx842_debug, debug_741
    rx842_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx842_pos)
  debug_741:
    .return (rx842_cur)
  rx842_restart:
.annotate 'line', 4
    if_null rx842_debug, debug_742
    rx842_cur."!cursor_debug"("NEXT", "onlystar")
  debug_742:
  rx842_fail:
    (rx842_rep, rx842_pos, $I10, $P10) = rx842_cur."!mark_fail"(0)
    lt rx842_pos, -1, rx842_done
    eq rx842_pos, -1, rx842_fail
    jump $I10
  rx842_done:
    rx842_cur."!cursor_fail"()
    if_null rx842_debug, debug_743
    rx842_cur."!cursor_debug"("FAIL", "onlystar")
  debug_743:
    .return (rx842_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("177_1298845521.609") :method
.annotate 'line', 4
    new $P844, "ResizablePMCArray"
    push $P844, ""
    .return ($P844)
.end


.namespace ["NQP";"Grammar"]
.sub "_block848"  :anon :subid("178_1298845521.609") :outer("176_1298845521.609")
.annotate 'line', 383
    find_dynamic_lex $P850, "$*MULTINESS"
    unless_null $P850, vivify_739
    get_hll_global $P850, "$MULTINESS"
    unless_null $P850, vivify_740
    die "Contextual $*MULTINESS not found"
  vivify_740:
  vivify_739:
    set $S851, $P850
    iseq $I852, $S851, "proto"
    .return ($I852)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("179_1298845521.609")
    .param pmc param_855
.annotate 'line', 389
    .lex "self", param_855
    $P856 = param_855."!protoregex"("multi_declarator")
    .return ($P856)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("180_1298845521.609")
    .param pmc param_858
.annotate 'line', 389
    .lex "self", param_858
    $P859 = param_858."!PREFIX__!protoregex"("multi_declarator")
    .return ($P859)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("181_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 391
    new $P861, "Undef"
    .lex "$*MULTINESS", $P861
.annotate 'line', 4
    .local string rx862_tgt
    .local int rx862_pos
    .local int rx862_off
    .local int rx862_eos
    .local int rx862_rep
    .local pmc rx862_cur
    .local pmc rx862_debug
    (rx862_cur, rx862_pos, rx862_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx862_cur
    .local pmc match
    .lex "$/", match
    length rx862_eos, rx862_tgt
    gt rx862_pos, rx862_eos, rx862_done
    set rx862_off, 0
    lt rx862_pos, 2, rx862_start
    sub rx862_off, rx862_pos, 1
    substr rx862_tgt, rx862_tgt, rx862_off
  rx862_start:
    eq $I10, 1, rx862_restart
    if_null rx862_debug, debug_744
    rx862_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan866_done
    goto rxscan866_scan
  rxscan866_loop:
    (rx862_pos) = rx862_cur."from"()
    inc rx862_pos
    rx862_cur."!cursor_from"(rx862_pos)
    ge rx862_pos, rx862_eos, rxscan866_done
  rxscan866_scan:
    set_addr $I10, rxscan866_loop
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  rxscan866_done:
.annotate 'line', 391
    rx862_cur."!cursor_pos"(rx862_pos)
    new $P867, "String"
    assign $P867, "multi"
    store_lex "$*MULTINESS", $P867
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_868_fail
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  # rx literal  "multi"
    add $I11, rx862_pos, 5
    gt $I11, rx862_eos, rx862_fail
    sub $I11, rx862_pos, rx862_off
    substr $S10, rx862_tgt, $I11, 5
    ne $S10, "multi", rx862_fail
    add rx862_pos, 5
    set_addr $I10, rxcap_868_fail
    ($I12, $I11) = rx862_cur."!mark_peek"($I10)
    rx862_cur."!cursor_pos"($I11)
    ($P10) = rx862_cur."!cursor_start"()
    $P10."!cursor_pass"(rx862_pos, "")
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_868_done
  rxcap_868_fail:
    goto rx862_fail
  rxcap_868_done:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."ws"()
    unless $P10, rx862_fail
    rx862_pos = $P10."pos"()
  alt869_0:
    set_addr $I10, alt869_1
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."declarator"()
    unless $P10, rx862_fail
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx862_pos = $P10."pos"()
    goto alt869_end
  alt869_1:
    set_addr $I10, alt869_2
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."routine_def"()
    unless $P10, rx862_fail
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx862_pos = $P10."pos"()
    goto alt869_end
  alt869_2:
  # rx subrule "panic" subtype=method negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."panic"("Malformed multi")
    unless $P10, rx862_fail
    rx862_pos = $P10."pos"()
  alt869_end:
.annotate 'line', 390
  # rx pass
    rx862_cur."!cursor_pass"(rx862_pos, "multi_declarator:sym<multi>")
    if_null rx862_debug, debug_745
    rx862_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx862_pos)
  debug_745:
    .return (rx862_cur)
  rx862_restart:
.annotate 'line', 4
    if_null rx862_debug, debug_746
    rx862_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_746:
  rx862_fail:
    (rx862_rep, rx862_pos, $I10, $P10) = rx862_cur."!mark_fail"(0)
    lt rx862_pos, -1, rx862_done
    eq rx862_pos, -1, rx862_fail
    jump $I10
  rx862_done:
    rx862_cur."!cursor_fail"()
    if_null rx862_debug, debug_747
    rx862_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_747:
    .return (rx862_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("182_1298845521.609") :method
.annotate 'line', 4
    $P864 = self."!PREFIX__!subrule"("ws", "multi")
    new $P865, "ResizablePMCArray"
    push $P865, $P864
    .return ($P865)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("183_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 396
    new $P871, "Undef"
    .lex "$*MULTINESS", $P871
.annotate 'line', 4
    .local string rx872_tgt
    .local int rx872_pos
    .local int rx872_off
    .local int rx872_eos
    .local int rx872_rep
    .local pmc rx872_cur
    .local pmc rx872_debug
    (rx872_cur, rx872_pos, rx872_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx872_cur
    .local pmc match
    .lex "$/", match
    length rx872_eos, rx872_tgt
    gt rx872_pos, rx872_eos, rx872_done
    set rx872_off, 0
    lt rx872_pos, 2, rx872_start
    sub rx872_off, rx872_pos, 1
    substr rx872_tgt, rx872_tgt, rx872_off
  rx872_start:
    eq $I10, 1, rx872_restart
    if_null rx872_debug, debug_748
    rx872_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan876_done
    goto rxscan876_scan
  rxscan876_loop:
    (rx872_pos) = rx872_cur."from"()
    inc rx872_pos
    rx872_cur."!cursor_from"(rx872_pos)
    ge rx872_pos, rx872_eos, rxscan876_done
  rxscan876_scan:
    set_addr $I10, rxscan876_loop
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  rxscan876_done:
.annotate 'line', 396
    rx872_cur."!cursor_pos"(rx872_pos)
    new $P877, "String"
    assign $P877, "proto"
    store_lex "$*MULTINESS", $P877
.annotate 'line', 397
  # rx subcapture "sym"
    set_addr $I10, rxcap_878_fail
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  # rx literal  "proto"
    add $I11, rx872_pos, 5
    gt $I11, rx872_eos, rx872_fail
    sub $I11, rx872_pos, rx872_off
    substr $S10, rx872_tgt, $I11, 5
    ne $S10, "proto", rx872_fail
    add rx872_pos, 5
    set_addr $I10, rxcap_878_fail
    ($I12, $I11) = rx872_cur."!mark_peek"($I10)
    rx872_cur."!cursor_pos"($I11)
    ($P10) = rx872_cur."!cursor_start"()
    $P10."!cursor_pass"(rx872_pos, "")
    rx872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_878_done
  rxcap_878_fail:
    goto rx872_fail
  rxcap_878_done:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."ws"()
    unless $P10, rx872_fail
    rx872_pos = $P10."pos"()
  alt879_0:
    set_addr $I10, alt879_1
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."declarator"()
    unless $P10, rx872_fail
    rx872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx872_pos = $P10."pos"()
    goto alt879_end
  alt879_1:
    set_addr $I10, alt879_2
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."routine_def"()
    unless $P10, rx872_fail
    rx872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx872_pos = $P10."pos"()
    goto alt879_end
  alt879_2:
  # rx subrule "panic" subtype=method negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."panic"("Malformed proto")
    unless $P10, rx872_fail
    rx872_pos = $P10."pos"()
  alt879_end:
.annotate 'line', 395
  # rx pass
    rx872_cur."!cursor_pass"(rx872_pos, "multi_declarator:sym<proto>")
    if_null rx872_debug, debug_749
    rx872_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx872_pos)
  debug_749:
    .return (rx872_cur)
  rx872_restart:
.annotate 'line', 4
    if_null rx872_debug, debug_750
    rx872_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_750:
  rx872_fail:
    (rx872_rep, rx872_pos, $I10, $P10) = rx872_cur."!mark_fail"(0)
    lt rx872_pos, -1, rx872_done
    eq rx872_pos, -1, rx872_fail
    jump $I10
  rx872_done:
    rx872_cur."!cursor_fail"()
    if_null rx872_debug, debug_751
    rx872_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_751:
    .return (rx872_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("184_1298845521.609") :method
.annotate 'line', 4
    $P874 = self."!PREFIX__!subrule"("ws", "proto")
    new $P875, "ResizablePMCArray"
    push $P875, $P874
    .return ($P875)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("185_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 401
    new $P881, "Undef"
    .lex "$*MULTINESS", $P881
.annotate 'line', 4
    .local string rx882_tgt
    .local int rx882_pos
    .local int rx882_off
    .local int rx882_eos
    .local int rx882_rep
    .local pmc rx882_cur
    .local pmc rx882_debug
    (rx882_cur, rx882_pos, rx882_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx882_cur
    .local pmc match
    .lex "$/", match
    length rx882_eos, rx882_tgt
    gt rx882_pos, rx882_eos, rx882_done
    set rx882_off, 0
    lt rx882_pos, 2, rx882_start
    sub rx882_off, rx882_pos, 1
    substr rx882_tgt, rx882_tgt, rx882_off
  rx882_start:
    eq $I10, 1, rx882_restart
    if_null rx882_debug, debug_752
    rx882_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan886_done
    goto rxscan886_scan
  rxscan886_loop:
    (rx882_pos) = rx882_cur."from"()
    inc rx882_pos
    rx882_cur."!cursor_from"(rx882_pos)
    ge rx882_pos, rx882_eos, rxscan886_done
  rxscan886_scan:
    set_addr $I10, rxscan886_loop
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  rxscan886_done:
.annotate 'line', 401
    rx882_cur."!cursor_pos"(rx882_pos)
    new $P887, "String"
    assign $P887, ""
    store_lex "$*MULTINESS", $P887
.annotate 'line', 402
  # rx subrule "declarator" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."declarator"()
    unless $P10, rx882_fail
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx882_pos = $P10."pos"()
.annotate 'line', 400
  # rx pass
    rx882_cur."!cursor_pass"(rx882_pos, "multi_declarator:sym<null>")
    if_null rx882_debug, debug_753
    rx882_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx882_pos)
  debug_753:
    .return (rx882_cur)
  rx882_restart:
.annotate 'line', 4
    if_null rx882_debug, debug_754
    rx882_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_754:
  rx882_fail:
    (rx882_rep, rx882_pos, $I10, $P10) = rx882_cur."!mark_fail"(0)
    lt rx882_pos, -1, rx882_done
    eq rx882_pos, -1, rx882_fail
    jump $I10
  rx882_done:
    rx882_cur."!cursor_fail"()
    if_null rx882_debug, debug_755
    rx882_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_755:
    .return (rx882_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("186_1298845521.609") :method
.annotate 'line', 4
    $P884 = self."!PREFIX__!subrule"("declarator", "")
    new $P885, "ResizablePMCArray"
    push $P885, $P884
    .return ($P885)
.end


.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("187_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P897 = "189_1298845521.609" 
    capture_lex $P897
    .local string rx889_tgt
    .local int rx889_pos
    .local int rx889_off
    .local int rx889_eos
    .local int rx889_rep
    .local pmc rx889_cur
    .local pmc rx889_debug
    (rx889_cur, rx889_pos, rx889_tgt, $I10) = self."!cursor_start"()
    rx889_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx889_cur
    .local pmc match
    .lex "$/", match
    length rx889_eos, rx889_tgt
    gt rx889_pos, rx889_eos, rx889_done
    set rx889_off, 0
    lt rx889_pos, 2, rx889_start
    sub rx889_off, rx889_pos, 1
    substr rx889_tgt, rx889_tgt, rx889_off
  rx889_start:
    eq $I10, 1, rx889_restart
    if_null rx889_debug, debug_756
    rx889_cur."!cursor_debug"("START", "signature")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan892_done
    goto rxscan892_scan
  rxscan892_loop:
    (rx889_pos) = rx889_cur."from"()
    inc rx889_pos
    rx889_cur."!cursor_from"(rx889_pos)
    ge rx889_pos, rx889_eos, rxscan892_done
  rxscan892_scan:
    set_addr $I10, rxscan892_loop
    rx889_cur."!mark_push"(0, rx889_pos, $I10)
  rxscan892_done:
.annotate 'line', 406
  # rx rxquantr893 ** 0..1
    set_addr $I10, rxquantr893_done
    rx889_cur."!mark_push"(0, rx889_pos, $I10)
  rxquantr893_loop:
    rx889_cur."!cursor_pos"(rx889_pos)
    find_lex $P894, unicode:"$\x{a2}"
    $P895 = $P894."MATCH"()
    store_lex "$/", $P895
    .const 'Sub' $P897 = "189_1298845521.609" 
    capture_lex $P897
    $P899 = $P897()
    unless $P899, rx889_fail
  # rx subrule "ws" subtype=method negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."ws"()
    unless $P10, rx889_fail
    rx889_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."parameter"()
    unless $P10, rx889_fail
    rx889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx889_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."ws"()
    unless $P10, rx889_fail
    rx889_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx889_pos, 1
    gt $I11, rx889_eos, rx889_fail
    sub $I11, rx889_pos, rx889_off
    ord $I11, rx889_tgt, $I11
    ne $I11, 58, rx889_fail
    add rx889_pos, 1
    set_addr $I10, rxquantr893_done
    (rx889_rep) = rx889_cur."!mark_commit"($I10)
  rxquantr893_done:
.annotate 'line', 407
  # rx rxquantr900 ** 0..1
    set_addr $I10, rxquantr900_done
    rx889_cur."!mark_push"(0, rx889_pos, $I10)
  rxquantr900_loop:
  # rx rxquantr901 ** 1..*
    set_addr $I10, rxquantr901_done
    rx889_cur."!mark_push"(0, -1, $I10)
  rxquantr901_loop:
  # rx subrule "ws" subtype=method negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."ws"()
    unless $P10, rx889_fail
    rx889_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."parameter"()
    unless $P10, rx889_fail
    rx889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx889_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."ws"()
    unless $P10, rx889_fail
    rx889_pos = $P10."pos"()
    set_addr $I10, rxquantr901_done
    (rx889_rep) = rx889_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr901_done
    rx889_cur."!mark_push"(rx889_rep, rx889_pos, $I10)
  # rx literal  ","
    add $I11, rx889_pos, 1
    gt $I11, rx889_eos, rx889_fail
    sub $I11, rx889_pos, rx889_off
    ord $I11, rx889_tgt, $I11
    ne $I11, 44, rx889_fail
    add rx889_pos, 1
    goto rxquantr901_loop
  rxquantr901_done:
    set_addr $I10, rxquantr900_done
    (rx889_rep) = rx889_cur."!mark_commit"($I10)
  rxquantr900_done:
.annotate 'line', 405
  # rx pass
    rx889_cur."!cursor_pass"(rx889_pos, "signature")
    if_null rx889_debug, debug_759
    rx889_cur."!cursor_debug"("PASS", "signature", " at pos=", rx889_pos)
  debug_759:
    .return (rx889_cur)
  rx889_restart:
.annotate 'line', 4
    if_null rx889_debug, debug_760
    rx889_cur."!cursor_debug"("NEXT", "signature")
  debug_760:
  rx889_fail:
    (rx889_rep, rx889_pos, $I10, $P10) = rx889_cur."!mark_fail"(0)
    lt rx889_pos, -1, rx889_done
    eq rx889_pos, -1, rx889_fail
    jump $I10
  rx889_done:
    rx889_cur."!cursor_fail"()
    if_null rx889_debug, debug_761
    rx889_cur."!cursor_debug"("FAIL", "signature")
  debug_761:
    .return (rx889_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("188_1298845521.609") :method
.annotate 'line', 4
    new $P891, "ResizablePMCArray"
    push $P891, ""
    .return ($P891)
.end


.namespace ["NQP";"Grammar"]
.sub "_block896"  :anon :subid("189_1298845521.609") :outer("187_1298845521.609")
.annotate 'line', 406
    find_dynamic_lex $P898, "$*INVOCANT_OK"
    unless_null $P898, vivify_757
    get_hll_global $P898, "$INVOCANT_OK"
    unless_null $P898, vivify_758
    die "Contextual $*INVOCANT_OK not found"
  vivify_758:
  vivify_757:
    .return ($P898)
.end


.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("190_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx903_tgt
    .local int rx903_pos
    .local int rx903_off
    .local int rx903_eos
    .local int rx903_rep
    .local pmc rx903_cur
    .local pmc rx903_debug
    (rx903_cur, rx903_pos, rx903_tgt, $I10) = self."!cursor_start"()
    rx903_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx903_cur
    .local pmc match
    .lex "$/", match
    length rx903_eos, rx903_tgt
    gt rx903_pos, rx903_eos, rx903_done
    set rx903_off, 0
    lt rx903_pos, 2, rx903_start
    sub rx903_off, rx903_pos, 1
    substr rx903_tgt, rx903_tgt, rx903_off
  rx903_start:
    eq $I10, 1, rx903_restart
    if_null rx903_debug, debug_762
    rx903_cur."!cursor_debug"("START", "parameter")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan906_done
    goto rxscan906_scan
  rxscan906_loop:
    (rx903_pos) = rx903_cur."from"()
    inc rx903_pos
    rx903_cur."!cursor_from"(rx903_pos)
    ge rx903_pos, rx903_eos, rxscan906_done
  rxscan906_scan:
    set_addr $I10, rxscan906_loop
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxscan906_done:
.annotate 'line', 411
  # rx rxquantr907 ** 0..*
    set_addr $I10, rxquantr907_done
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxquantr907_loop:
  # rx subrule "typename" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."typename"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx903_pos = $P10."pos"()
  # rx rxquantr908 ** 0..1
    set_addr $I10, rxquantr908_done
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxquantr908_loop:
  # rx literal  ":"
    add $I11, rx903_pos, 1
    gt $I11, rx903_eos, rx903_fail
    sub $I11, rx903_pos, rx903_off
    ord $I11, rx903_tgt, $I11
    ne $I11, 58, rx903_fail
    add rx903_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_909_fail
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx903_pos, rx903_eos, rx903_fail
    sub $I10, rx903_pos, rx903_off
    substr $S10, rx903_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx903_fail
    inc rx903_pos
    set_addr $I10, rxcap_909_fail
    ($I12, $I11) = rx903_cur."!mark_peek"($I10)
    rx903_cur."!cursor_pos"($I11)
    ($P10) = rx903_cur."!cursor_start"()
    $P10."!cursor_pass"(rx903_pos, "")
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_909_done
  rxcap_909_fail:
    goto rx903_fail
  rxcap_909_done:
    set_addr $I10, rxquantr908_done
    (rx903_rep) = rx903_cur."!mark_commit"($I10)
  rxquantr908_done:
  # rx subrule "ws" subtype=method negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."ws"()
    unless $P10, rx903_fail
    rx903_pos = $P10."pos"()
    set_addr $I10, rxquantr907_done
    (rx903_rep) = rx903_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr907_done
    rx903_cur."!mark_push"(rx903_rep, rx903_pos, $I10)
    goto rxquantr907_loop
  rxquantr907_done:
  alt910_0:
.annotate 'line', 412
    set_addr $I10, alt910_1
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
.annotate 'line', 413
  # rx subcapture "quant"
    set_addr $I10, rxcap_911_fail
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx literal  "*"
    add $I11, rx903_pos, 1
    gt $I11, rx903_eos, rx903_fail
    sub $I11, rx903_pos, rx903_off
    ord $I11, rx903_tgt, $I11
    ne $I11, 42, rx903_fail
    add rx903_pos, 1
    set_addr $I10, rxcap_911_fail
    ($I12, $I11) = rx903_cur."!mark_peek"($I10)
    rx903_cur."!cursor_pos"($I11)
    ($P10) = rx903_cur."!cursor_start"()
    $P10."!cursor_pass"(rx903_pos, "")
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_911_done
  rxcap_911_fail:
    goto rx903_fail
  rxcap_911_done:
  # rx subrule "param_var" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."param_var"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx903_pos = $P10."pos"()
    goto alt910_end
  alt910_1:
  alt912_0:
.annotate 'line', 414
    set_addr $I10, alt912_1
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."param_var"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx903_pos = $P10."pos"()
    goto alt912_end
  alt912_1:
  # rx subrule "named_param" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."named_param"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx903_pos = $P10."pos"()
  alt912_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_914_fail
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  alt913_0:
    set_addr $I10, alt913_1
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx literal  "?"
    add $I11, rx903_pos, 1
    gt $I11, rx903_eos, rx903_fail
    sub $I11, rx903_pos, rx903_off
    ord $I11, rx903_tgt, $I11
    ne $I11, 63, rx903_fail
    add rx903_pos, 1
    goto alt913_end
  alt913_1:
    set_addr $I10, alt913_2
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx literal  "!"
    add $I11, rx903_pos, 1
    gt $I11, rx903_eos, rx903_fail
    sub $I11, rx903_pos, rx903_off
    ord $I11, rx903_tgt, $I11
    ne $I11, 33, rx903_fail
    add rx903_pos, 1
    goto alt913_end
  alt913_2:
  alt913_end:
    set_addr $I10, rxcap_914_fail
    ($I12, $I11) = rx903_cur."!mark_peek"($I10)
    rx903_cur."!cursor_pos"($I11)
    ($P10) = rx903_cur."!cursor_start"()
    $P10."!cursor_pass"(rx903_pos, "")
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_914_done
  rxcap_914_fail:
    goto rx903_fail
  rxcap_914_done:
  alt910_end:
.annotate 'line', 416
  # rx rxquantr915 ** 0..1
    set_addr $I10, rxquantr915_done
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxquantr915_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."default_value"()
    unless $P10, rx903_fail
    goto rxsubrule916_pass
  rxsubrule916_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx903_fail
  rxsubrule916_pass:
    set_addr $I10, rxsubrule916_back
    rx903_cur."!mark_push"(0, rx903_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx903_pos = $P10."pos"()
    set_addr $I10, rxquantr915_done
    (rx903_rep) = rx903_cur."!mark_commit"($I10)
  rxquantr915_done:
.annotate 'line', 410
  # rx pass
    rx903_cur."!cursor_pass"(rx903_pos, "parameter")
    if_null rx903_debug, debug_763
    rx903_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx903_pos)
  debug_763:
    .return (rx903_cur)
  rx903_restart:
.annotate 'line', 4
    if_null rx903_debug, debug_764
    rx903_cur."!cursor_debug"("NEXT", "parameter")
  debug_764:
  rx903_fail:
    (rx903_rep, rx903_pos, $I10, $P10) = rx903_cur."!mark_fail"(0)
    lt rx903_pos, -1, rx903_done
    eq rx903_pos, -1, rx903_fail
    jump $I10
  rx903_done:
    rx903_cur."!cursor_fail"()
    if_null rx903_debug, debug_765
    rx903_cur."!cursor_debug"("FAIL", "parameter")
  debug_765:
    .return (rx903_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("191_1298845521.609") :method
.annotate 'line', 4
    new $P905, "ResizablePMCArray"
    push $P905, ""
    .return ($P905)
.end


.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("192_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx918_tgt
    .local int rx918_pos
    .local int rx918_off
    .local int rx918_eos
    .local int rx918_rep
    .local pmc rx918_cur
    .local pmc rx918_debug
    (rx918_cur, rx918_pos, rx918_tgt, $I10) = self."!cursor_start"()
    rx918_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx918_cur
    .local pmc match
    .lex "$/", match
    length rx918_eos, rx918_tgt
    gt rx918_pos, rx918_eos, rx918_done
    set rx918_off, 0
    lt rx918_pos, 2, rx918_start
    sub rx918_off, rx918_pos, 1
    substr rx918_tgt, rx918_tgt, rx918_off
  rx918_start:
    eq $I10, 1, rx918_restart
    if_null rx918_debug, debug_766
    rx918_cur."!cursor_debug"("START", "param_var")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan922_done
    goto rxscan922_scan
  rxscan922_loop:
    (rx918_pos) = rx918_cur."from"()
    inc rx918_pos
    rx918_cur."!cursor_from"(rx918_pos)
    ge rx918_pos, rx918_eos, rxscan922_done
  rxscan922_scan:
    set_addr $I10, rxscan922_loop
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  rxscan922_done:
.annotate 'line', 420
  # rx subrule "sigil" subtype=capture negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."sigil"()
    unless $P10, rx918_fail
    rx918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx918_pos = $P10."pos"()
  # rx rxquantr923 ** 0..1
    set_addr $I10, rxquantr923_done
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  rxquantr923_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."twigil"()
    unless $P10, rx918_fail
    goto rxsubrule924_pass
  rxsubrule924_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx918_fail
  rxsubrule924_pass:
    set_addr $I10, rxsubrule924_back
    rx918_cur."!mark_push"(0, rx918_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx918_pos = $P10."pos"()
    set_addr $I10, rxquantr923_done
    (rx918_rep) = rx918_cur."!mark_commit"($I10)
  rxquantr923_done:
  alt925_0:
.annotate 'line', 421
    set_addr $I10, alt925_1
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."ident"()
    unless $P10, rx918_fail
    rx918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx918_pos = $P10."pos"()
    goto alt925_end
  alt925_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_926_fail
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx918_pos, rx918_eos, rx918_fail
    sub $I10, rx918_pos, rx918_off
    substr $S10, rx918_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx918_fail
    inc rx918_pos
    set_addr $I10, rxcap_926_fail
    ($I12, $I11) = rx918_cur."!mark_peek"($I10)
    rx918_cur."!cursor_pos"($I11)
    ($P10) = rx918_cur."!cursor_start"()
    $P10."!cursor_pass"(rx918_pos, "")
    rx918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_926_done
  rxcap_926_fail:
    goto rx918_fail
  rxcap_926_done:
  alt925_end:
.annotate 'line', 419
  # rx pass
    rx918_cur."!cursor_pass"(rx918_pos, "param_var")
    if_null rx918_debug, debug_767
    rx918_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx918_pos)
  debug_767:
    .return (rx918_cur)
  rx918_restart:
.annotate 'line', 4
    if_null rx918_debug, debug_768
    rx918_cur."!cursor_debug"("NEXT", "param_var")
  debug_768:
  rx918_fail:
    (rx918_rep, rx918_pos, $I10, $P10) = rx918_cur."!mark_fail"(0)
    lt rx918_pos, -1, rx918_done
    eq rx918_pos, -1, rx918_fail
    jump $I10
  rx918_done:
    rx918_cur."!cursor_fail"()
    if_null rx918_debug, debug_769
    rx918_cur."!cursor_debug"("FAIL", "param_var")
  debug_769:
    .return (rx918_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("193_1298845521.609") :method
.annotate 'line', 4
    $P920 = self."!PREFIX__!subrule"("sigil", "")
    new $P921, "ResizablePMCArray"
    push $P921, $P920
    .return ($P921)
.end


.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("194_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx928_tgt
    .local int rx928_pos
    .local int rx928_off
    .local int rx928_eos
    .local int rx928_rep
    .local pmc rx928_cur
    .local pmc rx928_debug
    (rx928_cur, rx928_pos, rx928_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx928_cur
    .local pmc match
    .lex "$/", match
    length rx928_eos, rx928_tgt
    gt rx928_pos, rx928_eos, rx928_done
    set rx928_off, 0
    lt rx928_pos, 2, rx928_start
    sub rx928_off, rx928_pos, 1
    substr rx928_tgt, rx928_tgt, rx928_off
  rx928_start:
    eq $I10, 1, rx928_restart
    if_null rx928_debug, debug_770
    rx928_cur."!cursor_debug"("START", "named_param")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan932_done
    goto rxscan932_scan
  rxscan932_loop:
    (rx928_pos) = rx928_cur."from"()
    inc rx928_pos
    rx928_cur."!cursor_from"(rx928_pos)
    ge rx928_pos, rx928_eos, rxscan932_done
  rxscan932_scan:
    set_addr $I10, rxscan932_loop
    rx928_cur."!mark_push"(0, rx928_pos, $I10)
  rxscan932_done:
.annotate 'line', 425
  # rx literal  ":"
    add $I11, rx928_pos, 1
    gt $I11, rx928_eos, rx928_fail
    sub $I11, rx928_pos, rx928_off
    ord $I11, rx928_tgt, $I11
    ne $I11, 58, rx928_fail
    add rx928_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx928_cur."!cursor_pos"(rx928_pos)
    $P10 = rx928_cur."param_var"()
    unless $P10, rx928_fail
    rx928_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx928_pos = $P10."pos"()
.annotate 'line', 424
  # rx pass
    rx928_cur."!cursor_pass"(rx928_pos, "named_param")
    if_null rx928_debug, debug_771
    rx928_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx928_pos)
  debug_771:
    .return (rx928_cur)
  rx928_restart:
.annotate 'line', 4
    if_null rx928_debug, debug_772
    rx928_cur."!cursor_debug"("NEXT", "named_param")
  debug_772:
  rx928_fail:
    (rx928_rep, rx928_pos, $I10, $P10) = rx928_cur."!mark_fail"(0)
    lt rx928_pos, -1, rx928_done
    eq rx928_pos, -1, rx928_fail
    jump $I10
  rx928_done:
    rx928_cur."!cursor_fail"()
    if_null rx928_debug, debug_773
    rx928_cur."!cursor_debug"("FAIL", "named_param")
  debug_773:
    .return (rx928_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("195_1298845521.609") :method
.annotate 'line', 4
    $P930 = self."!PREFIX__!subrule"("param_var", ":")
    new $P931, "ResizablePMCArray"
    push $P931, $P930
    .return ($P931)
.end


.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("196_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx934_tgt
    .local int rx934_pos
    .local int rx934_off
    .local int rx934_eos
    .local int rx934_rep
    .local pmc rx934_cur
    .local pmc rx934_debug
    (rx934_cur, rx934_pos, rx934_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx934_cur
    .local pmc match
    .lex "$/", match
    length rx934_eos, rx934_tgt
    gt rx934_pos, rx934_eos, rx934_done
    set rx934_off, 0
    lt rx934_pos, 2, rx934_start
    sub rx934_off, rx934_pos, 1
    substr rx934_tgt, rx934_tgt, rx934_off
  rx934_start:
    eq $I10, 1, rx934_restart
    if_null rx934_debug, debug_774
    rx934_cur."!cursor_debug"("START", "default_value")
  debug_774:
    $I10 = self.'from'()
    ne $I10, -1, rxscan938_done
    goto rxscan938_scan
  rxscan938_loop:
    (rx934_pos) = rx934_cur."from"()
    inc rx934_pos
    rx934_cur."!cursor_from"(rx934_pos)
    ge rx934_pos, rx934_eos, rxscan938_done
  rxscan938_scan:
    set_addr $I10, rxscan938_loop
    rx934_cur."!mark_push"(0, rx934_pos, $I10)
  rxscan938_done:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."ws"()
    unless $P10, rx934_fail
    rx934_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx934_pos, 1
    gt $I11, rx934_eos, rx934_fail
    sub $I11, rx934_pos, rx934_off
    ord $I11, rx934_tgt, $I11
    ne $I11, 61, rx934_fail
    add rx934_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."ws"()
    unless $P10, rx934_fail
    rx934_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."EXPR"("i=")
    unless $P10, rx934_fail
    rx934_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx934_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."ws"()
    unless $P10, rx934_fail
    rx934_pos = $P10."pos"()
  # rx pass
    rx934_cur."!cursor_pass"(rx934_pos, "default_value")
    if_null rx934_debug, debug_775
    rx934_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx934_pos)
  debug_775:
    .return (rx934_cur)
  rx934_restart:
.annotate 'line', 4
    if_null rx934_debug, debug_776
    rx934_cur."!cursor_debug"("NEXT", "default_value")
  debug_776:
  rx934_fail:
    (rx934_rep, rx934_pos, $I10, $P10) = rx934_cur."!mark_fail"(0)
    lt rx934_pos, -1, rx934_done
    eq rx934_pos, -1, rx934_fail
    jump $I10
  rx934_done:
    rx934_cur."!cursor_fail"()
    if_null rx934_debug, debug_777
    rx934_cur."!cursor_debug"("FAIL", "default_value")
  debug_777:
    .return (rx934_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("197_1298845521.609") :method
.annotate 'line', 4
    $P936 = self."!PREFIX__!subrule"("ws", "")
    new $P937, "ResizablePMCArray"
    push $P937, $P936
    .return ($P937)
.end


.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("198_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx943_tgt
    .local int rx943_pos
    .local int rx943_off
    .local int rx943_eos
    .local int rx943_rep
    .local pmc rx943_cur
    .local pmc rx943_debug
    (rx943_cur, rx943_pos, rx943_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx943_cur
    .local pmc match
    .lex "$/", match
    length rx943_eos, rx943_tgt
    gt rx943_pos, rx943_eos, rx943_done
    set rx943_off, 0
    lt rx943_pos, 2, rx943_start
    sub rx943_off, rx943_pos, 1
    substr rx943_tgt, rx943_tgt, rx943_off
  rx943_start:
    eq $I10, 1, rx943_restart
    if_null rx943_debug, debug_778
    rx943_cur."!cursor_debug"("START", "trait")
  debug_778:
    $I10 = self.'from'()
    ne $I10, -1, rxscan947_done
    goto rxscan947_scan
  rxscan947_loop:
    (rx943_pos) = rx943_cur."from"()
    inc rx943_pos
    rx943_cur."!cursor_from"(rx943_pos)
    ge rx943_pos, rx943_eos, rxscan947_done
  rxscan947_scan:
    set_addr $I10, rxscan947_loop
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
  rxscan947_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."trait_mod"()
    unless $P10, rx943_fail
    rx943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx943_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx pass
    rx943_cur."!cursor_pass"(rx943_pos, "trait")
    if_null rx943_debug, debug_779
    rx943_cur."!cursor_debug"("PASS", "trait", " at pos=", rx943_pos)
  debug_779:
    .return (rx943_cur)
  rx943_restart:
.annotate 'line', 4
    if_null rx943_debug, debug_780
    rx943_cur."!cursor_debug"("NEXT", "trait")
  debug_780:
  rx943_fail:
    (rx943_rep, rx943_pos, $I10, $P10) = rx943_cur."!mark_fail"(0)
    lt rx943_pos, -1, rx943_done
    eq rx943_pos, -1, rx943_fail
    jump $I10
  rx943_done:
    rx943_cur."!cursor_fail"()
    if_null rx943_debug, debug_781
    rx943_cur."!cursor_debug"("FAIL", "trait")
  debug_781:
    .return (rx943_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("199_1298845521.609") :method
.annotate 'line', 4
    $P945 = self."!PREFIX__!subrule"("ws", "")
    new $P946, "ResizablePMCArray"
    push $P946, $P945
    .return ($P946)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("200_1298845521.609")
    .param pmc param_951
.annotate 'line', 432
    .lex "self", param_951
    $P952 = param_951."!protoregex"("trait_mod")
    .return ($P952)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("201_1298845521.609")
    .param pmc param_954
.annotate 'line', 432
    .lex "self", param_954
    $P955 = param_954."!PREFIX__!protoregex"("trait_mod")
    .return ($P955)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("202_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx957_tgt
    .local int rx957_pos
    .local int rx957_off
    .local int rx957_eos
    .local int rx957_rep
    .local pmc rx957_cur
    .local pmc rx957_debug
    (rx957_cur, rx957_pos, rx957_tgt, $I10) = self."!cursor_start"()
    rx957_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx957_cur
    .local pmc match
    .lex "$/", match
    length rx957_eos, rx957_tgt
    gt rx957_pos, rx957_eos, rx957_done
    set rx957_off, 0
    lt rx957_pos, 2, rx957_start
    sub rx957_off, rx957_pos, 1
    substr rx957_tgt, rx957_tgt, rx957_off
  rx957_start:
    eq $I10, 1, rx957_restart
    if_null rx957_debug, debug_782
    rx957_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_782:
    $I10 = self.'from'()
    ne $I10, -1, rxscan961_done
    goto rxscan961_scan
  rxscan961_loop:
    (rx957_pos) = rx957_cur."from"()
    inc rx957_pos
    rx957_cur."!cursor_from"(rx957_pos)
    ge rx957_pos, rx957_eos, rxscan961_done
  rxscan961_scan:
    set_addr $I10, rxscan961_loop
    rx957_cur."!mark_push"(0, rx957_pos, $I10)
  rxscan961_done:
.annotate 'line', 433
  # rx subcapture "sym"
    set_addr $I10, rxcap_962_fail
    rx957_cur."!mark_push"(0, rx957_pos, $I10)
  # rx literal  "is"
    add $I11, rx957_pos, 2
    gt $I11, rx957_eos, rx957_fail
    sub $I11, rx957_pos, rx957_off
    substr $S10, rx957_tgt, $I11, 2
    ne $S10, "is", rx957_fail
    add rx957_pos, 2
    set_addr $I10, rxcap_962_fail
    ($I12, $I11) = rx957_cur."!mark_peek"($I10)
    rx957_cur."!cursor_pos"($I11)
    ($P10) = rx957_cur."!cursor_start"()
    $P10."!cursor_pass"(rx957_pos, "")
    rx957_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_962_done
  rxcap_962_fail:
    goto rx957_fail
  rxcap_962_done:
  # rx subrule "ws" subtype=method negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."ws"()
    unless $P10, rx957_fail
    rx957_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."deflongname"()
    unless $P10, rx957_fail
    rx957_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx957_pos = $P10."pos"()
  # rx rxquantr964 ** 0..1
    set_addr $I10, rxquantr964_done
    rx957_cur."!mark_push"(0, rx957_pos, $I10)
  rxquantr964_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."circumfix"()
    unless $P10, rx957_fail
    goto rxsubrule965_pass
  rxsubrule965_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx957_fail
  rxsubrule965_pass:
    set_addr $I10, rxsubrule965_back
    rx957_cur."!mark_push"(0, rx957_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx957_pos = $P10."pos"()
    set_addr $I10, rxquantr964_done
    (rx957_rep) = rx957_cur."!mark_commit"($I10)
  rxquantr964_done:
  # rx subrule "ws" subtype=method negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."ws"()
    unless $P10, rx957_fail
    rx957_pos = $P10."pos"()
  # rx pass
    rx957_cur."!cursor_pass"(rx957_pos, "trait_mod:sym<is>")
    if_null rx957_debug, debug_783
    rx957_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx957_pos)
  debug_783:
    .return (rx957_cur)
  rx957_restart:
.annotate 'line', 4
    if_null rx957_debug, debug_784
    rx957_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_784:
  rx957_fail:
    (rx957_rep, rx957_pos, $I10, $P10) = rx957_cur."!mark_fail"(0)
    lt rx957_pos, -1, rx957_done
    eq rx957_pos, -1, rx957_fail
    jump $I10
  rx957_done:
    rx957_cur."!cursor_fail"()
    if_null rx957_debug, debug_785
    rx957_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_785:
    .return (rx957_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("203_1298845521.609") :method
.annotate 'line', 4
    $P959 = self."!PREFIX__!subrule"("ws", "is")
    new $P960, "ResizablePMCArray"
    push $P960, $P959
    .return ($P960)
.end


.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("204_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx968_tgt
    .local int rx968_pos
    .local int rx968_off
    .local int rx968_eos
    .local int rx968_rep
    .local pmc rx968_cur
    .local pmc rx968_debug
    (rx968_cur, rx968_pos, rx968_tgt, $I10) = self."!cursor_start"()
    rx968_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx968_cur
    .local pmc match
    .lex "$/", match
    length rx968_eos, rx968_tgt
    gt rx968_pos, rx968_eos, rx968_done
    set rx968_off, 0
    lt rx968_pos, 2, rx968_start
    sub rx968_off, rx968_pos, 1
    substr rx968_tgt, rx968_tgt, rx968_off
  rx968_start:
    eq $I10, 1, rx968_restart
    if_null rx968_debug, debug_786
    rx968_cur."!cursor_debug"("START", "regex_declarator")
  debug_786:
    $I10 = self.'from'()
    ne $I10, -1, rxscan972_done
    goto rxscan972_scan
  rxscan972_loop:
    (rx968_pos) = rx968_cur."from"()
    inc rx968_pos
    rx968_cur."!cursor_from"(rx968_pos)
    ge rx968_pos, rx968_eos, rxscan972_done
  rxscan972_scan:
    set_addr $I10, rxscan972_loop
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  rxscan972_done:
.annotate 'line', 435
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt974_0:
.annotate 'line', 436
    set_addr $I10, alt974_1
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_976_fail
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "proto"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "proto", rx968_fail
    add rx968_pos, 5
    set_addr $I10, rxcap_976_fail
    ($I12, $I11) = rx968_cur."!mark_peek"($I10)
    rx968_cur."!cursor_pos"($I11)
    ($P10) = rx968_cur."!cursor_start"()
    $P10."!cursor_pass"(rx968_pos, "")
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_976_done
  rxcap_976_fail:
    goto rx968_fail
  rxcap_976_done:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt978_0:
    set_addr $I10, alt978_1
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "regex"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "regex", rx968_fail
    add rx968_pos, 5
    goto alt978_end
  alt978_1:
    set_addr $I10, alt978_2
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "token"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "token", rx968_fail
    add rx968_pos, 5
    goto alt978_end
  alt978_2:
  # rx literal  "rule"
    add $I11, rx968_pos, 4
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 4
    ne $S10, "rule", rx968_fail
    add rx968_pos, 4
  alt978_end:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 438
  # rx subrule "deflongname" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."deflongname"()
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt981_0:
.annotate 'line', 439
    set_addr $I10, alt981_1
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 123, rx968_fail
    add rx968_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "<...>", rx968_fail
    add rx968_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 125, rx968_fail
    add rx968_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ENDSTMT"()
    unless $P10, rx968_fail
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
    goto alt981_end
  alt981_1:
    set_addr $I10, alt981_2
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 123, rx968_fail
    add rx968_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx968_pos, 3
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 3
    ne $S10, "<*>", rx968_fail
    add rx968_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 125, rx968_fail
    add rx968_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ENDSTMT"()
    unless $P10, rx968_fail
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
    goto alt981_end
  alt981_2:
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt981_end:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 437
    goto alt974_end
  alt974_1:
.annotate 'line', 444
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_995_fail
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  alt994_0:
    set_addr $I10, alt994_1
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "regex"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "regex", rx968_fail
    add rx968_pos, 5
    goto alt994_end
  alt994_1:
    set_addr $I10, alt994_2
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "token"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "token", rx968_fail
    add rx968_pos, 5
    goto alt994_end
  alt994_2:
  # rx literal  "rule"
    add $I11, rx968_pos, 4
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 4
    ne $S10, "rule", rx968_fail
    add rx968_pos, 4
  alt994_end:
    set_addr $I10, rxcap_995_fail
    ($I12, $I11) = rx968_cur."!mark_peek"($I10)
    rx968_cur."!cursor_pos"($I11)
    ($P10) = rx968_cur."!cursor_start"()
    $P10."!cursor_pass"(rx968_pos, "")
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_995_done
  rxcap_995_fail:
    goto rx968_fail
  rxcap_995_done:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 445
  # rx subrule "deflongname" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."deflongname"()
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 446
  # rx subrule "newpad" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."newpad"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 447
  # rx rxquantr999 ** 0..1
    set_addr $I10, rxquantr999_done
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  rxquantr999_loop:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 40, rx968_fail
    add rx968_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."signature"()
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 41, rx968_fail
    add rx968_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
    set_addr $I10, rxquantr999_done
    (rx968_rep) = rx968_cur."!mark_commit"($I10)
  rxquantr999_done:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 448
  # rx reduce name="regex_declarator" key="open"
    rx968_cur."!cursor_pos"(rx968_pos)
    rx968_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 449
  # rx literal  "{"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 123, rx968_fail
    add rx968_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."LANG"("Regex", "nibbler")
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx968_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 125, rx968_fail
    add rx968_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ENDSTMT"()
    unless $P10, rx968_fail
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt974_end:
.annotate 'line', 450
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 435
  # rx pass
    rx968_cur."!cursor_pass"(rx968_pos, "regex_declarator")
    if_null rx968_debug, debug_787
    rx968_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx968_pos)
  debug_787:
    .return (rx968_cur)
  rx968_restart:
.annotate 'line', 4
    if_null rx968_debug, debug_788
    rx968_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_788:
  rx968_fail:
    (rx968_rep, rx968_pos, $I10, $P10) = rx968_cur."!mark_fail"(0)
    lt rx968_pos, -1, rx968_done
    eq rx968_pos, -1, rx968_fail
    jump $I10
  rx968_done:
    rx968_cur."!cursor_fail"()
    if_null rx968_debug, debug_789
    rx968_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_789:
    .return (rx968_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("205_1298845521.609") :method
.annotate 'line', 4
    $P970 = self."!PREFIX__!subrule"("ws", "")
    new $P971, "ResizablePMCArray"
    push $P971, $P970
    .return ($P971)
.end


.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("206_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1009_tgt
    .local int rx1009_pos
    .local int rx1009_off
    .local int rx1009_eos
    .local int rx1009_rep
    .local pmc rx1009_cur
    .local pmc rx1009_debug
    (rx1009_cur, rx1009_pos, rx1009_tgt, $I10) = self."!cursor_start"()
    rx1009_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1009_cur
    .local pmc match
    .lex "$/", match
    length rx1009_eos, rx1009_tgt
    gt rx1009_pos, rx1009_eos, rx1009_done
    set rx1009_off, 0
    lt rx1009_pos, 2, rx1009_start
    sub rx1009_off, rx1009_pos, 1
    substr rx1009_tgt, rx1009_tgt, rx1009_off
  rx1009_start:
    eq $I10, 1, rx1009_restart
    if_null rx1009_debug, debug_790
    rx1009_cur."!cursor_debug"("START", "dotty")
  debug_790:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1013_done
    goto rxscan1013_scan
  rxscan1013_loop:
    (rx1009_pos) = rx1009_cur."from"()
    inc rx1009_pos
    rx1009_cur."!cursor_from"(rx1009_pos)
    ge rx1009_pos, rx1009_eos, rxscan1013_done
  rxscan1013_scan:
    set_addr $I10, rxscan1013_loop
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
  rxscan1013_done:
.annotate 'line', 454
  # rx literal  "."
    add $I11, rx1009_pos, 1
    gt $I11, rx1009_eos, rx1009_fail
    sub $I11, rx1009_pos, rx1009_off
    ord $I11, rx1009_tgt, $I11
    ne $I11, 46, rx1009_fail
    add rx1009_pos, 1
  alt1014_0:
.annotate 'line', 455
    set_addr $I10, alt1014_1
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."deflongname"()
    unless $P10, rx1009_fail
    rx1009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1009_pos = $P10."pos"()
    goto alt1014_end
  alt1014_1:
.annotate 'line', 456
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1009_pos, rx1009_off
    substr $S10, rx1009_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1009_fail
  # rx subrule "quote" subtype=capture negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."quote"()
    unless $P10, rx1009_fail
    rx1009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1009_pos = $P10."pos"()
  alt1015_0:
.annotate 'line', 457
    set_addr $I10, alt1015_1
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1009_pos, rx1009_off
    substr $S10, rx1009_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1009_fail
    goto alt1015_end
  alt1015_1:
  # rx subrule "panic" subtype=method negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1009_fail
    rx1009_pos = $P10."pos"()
  alt1015_end:
  alt1014_end:
.annotate 'line', 463
  # rx rxquantr1016 ** 0..1
    set_addr $I10, rxquantr1016_done
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
  rxquantr1016_loop:
  alt1017_0:
.annotate 'line', 460
    set_addr $I10, alt1017_1
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
.annotate 'line', 461
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1009_pos, rx1009_off
    substr $S10, rx1009_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1009_fail
  # rx subrule "args" subtype=capture negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."args"()
    unless $P10, rx1009_fail
    rx1009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1009_pos = $P10."pos"()
    goto alt1017_end
  alt1017_1:
.annotate 'line', 462
  # rx literal  ":"
    add $I11, rx1009_pos, 1
    gt $I11, rx1009_eos, rx1009_fail
    sub $I11, rx1009_pos, rx1009_off
    ord $I11, rx1009_tgt, $I11
    ne $I11, 58, rx1009_fail
    add rx1009_pos, 1
  # rx charclass s
    ge rx1009_pos, rx1009_eos, rx1009_fail
    sub $I10, rx1009_pos, rx1009_off
    is_cclass $I11, 32, rx1009_tgt, $I10
    unless $I11, rx1009_fail
    inc rx1009_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."arglist"()
    unless $P10, rx1009_fail
    rx1009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1009_pos = $P10."pos"()
  alt1017_end:
.annotate 'line', 463
    set_addr $I10, rxquantr1016_done
    (rx1009_rep) = rx1009_cur."!mark_commit"($I10)
  rxquantr1016_done:
.annotate 'line', 453
  # rx pass
    rx1009_cur."!cursor_pass"(rx1009_pos, "dotty")
    if_null rx1009_debug, debug_791
    rx1009_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1009_pos)
  debug_791:
    .return (rx1009_cur)
  rx1009_restart:
.annotate 'line', 4
    if_null rx1009_debug, debug_792
    rx1009_cur."!cursor_debug"("NEXT", "dotty")
  debug_792:
  rx1009_fail:
    (rx1009_rep, rx1009_pos, $I10, $P10) = rx1009_cur."!mark_fail"(0)
    lt rx1009_pos, -1, rx1009_done
    eq rx1009_pos, -1, rx1009_fail
    jump $I10
  rx1009_done:
    rx1009_cur."!cursor_fail"()
    if_null rx1009_debug, debug_793
    rx1009_cur."!cursor_debug"("FAIL", "dotty")
  debug_793:
    .return (rx1009_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("207_1298845521.609") :method
.annotate 'line', 4
    $P1011 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1012, "ResizablePMCArray"
    push $P1012, "'"
    push $P1012, "\""
    push $P1012, $P1011
    .return ($P1012)
.end


.namespace ["NQP";"Grammar"]
.sub "term"  :subid("208_1298845521.609")
    .param pmc param_1019
.annotate 'line', 467
    .lex "self", param_1019
    $P1020 = param_1019."!protoregex"("term")
    .return ($P1020)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("209_1298845521.609")
    .param pmc param_1022
.annotate 'line', 467
    .lex "self", param_1022
    $P1023 = param_1022."!PREFIX__!protoregex"("term")
    .return ($P1023)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("210_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1025_tgt
    .local int rx1025_pos
    .local int rx1025_off
    .local int rx1025_eos
    .local int rx1025_rep
    .local pmc rx1025_cur
    .local pmc rx1025_debug
    (rx1025_cur, rx1025_pos, rx1025_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1025_cur
    .local pmc match
    .lex "$/", match
    length rx1025_eos, rx1025_tgt
    gt rx1025_pos, rx1025_eos, rx1025_done
    set rx1025_off, 0
    lt rx1025_pos, 2, rx1025_start
    sub rx1025_off, rx1025_pos, 1
    substr rx1025_tgt, rx1025_tgt, rx1025_off
  rx1025_start:
    eq $I10, 1, rx1025_restart
    if_null rx1025_debug, debug_794
    rx1025_cur."!cursor_debug"("START", "term:sym<self>")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1028_done
    goto rxscan1028_scan
  rxscan1028_loop:
    (rx1025_pos) = rx1025_cur."from"()
    inc rx1025_pos
    rx1025_cur."!cursor_from"(rx1025_pos)
    ge rx1025_pos, rx1025_eos, rxscan1028_done
  rxscan1028_scan:
    set_addr $I10, rxscan1028_loop
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  rxscan1028_done:
.annotate 'line', 469
  # rx subcapture "sym"
    set_addr $I10, rxcap_1029_fail
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  # rx literal  "self"
    add $I11, rx1025_pos, 4
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 4
    ne $S10, "self", rx1025_fail
    add rx1025_pos, 4
    set_addr $I10, rxcap_1029_fail
    ($I12, $I11) = rx1025_cur."!mark_peek"($I10)
    rx1025_cur."!cursor_pos"($I11)
    ($P10) = rx1025_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1025_pos, "")
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1029_done
  rxcap_1029_fail:
    goto rx1025_fail
  rxcap_1029_done:
  # rxanchor rwb
    le rx1025_pos, 0, rx1025_fail
    sub $I10, rx1025_pos, rx1025_off
    is_cclass $I11, 8192, rx1025_tgt, $I10
    if $I11, rx1025_fail
    dec $I10
    is_cclass $I11, 8192, rx1025_tgt, $I10
    unless $I11, rx1025_fail
  # rx pass
    rx1025_cur."!cursor_pass"(rx1025_pos, "term:sym<self>")
    if_null rx1025_debug, debug_795
    rx1025_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1025_pos)
  debug_795:
    .return (rx1025_cur)
  rx1025_restart:
.annotate 'line', 4
    if_null rx1025_debug, debug_796
    rx1025_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_796:
  rx1025_fail:
    (rx1025_rep, rx1025_pos, $I10, $P10) = rx1025_cur."!mark_fail"(0)
    lt rx1025_pos, -1, rx1025_done
    eq rx1025_pos, -1, rx1025_fail
    jump $I10
  rx1025_done:
    rx1025_cur."!cursor_fail"()
    if_null rx1025_debug, debug_797
    rx1025_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_797:
    .return (rx1025_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("211_1298845521.609") :method
.annotate 'line', 4
    new $P1027, "ResizablePMCArray"
    push $P1027, "self"
    .return ($P1027)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("212_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1031_tgt
    .local int rx1031_pos
    .local int rx1031_off
    .local int rx1031_eos
    .local int rx1031_rep
    .local pmc rx1031_cur
    .local pmc rx1031_debug
    (rx1031_cur, rx1031_pos, rx1031_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1031_cur
    .local pmc match
    .lex "$/", match
    length rx1031_eos, rx1031_tgt
    gt rx1031_pos, rx1031_eos, rx1031_done
    set rx1031_off, 0
    lt rx1031_pos, 2, rx1031_start
    sub rx1031_off, rx1031_pos, 1
    substr rx1031_tgt, rx1031_tgt, rx1031_off
  rx1031_start:
    eq $I10, 1, rx1031_restart
    if_null rx1031_debug, debug_798
    rx1031_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_798:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1035_done
    goto rxscan1035_scan
  rxscan1035_loop:
    (rx1031_pos) = rx1031_cur."from"()
    inc rx1031_pos
    rx1031_cur."!cursor_from"(rx1031_pos)
    ge rx1031_pos, rx1031_eos, rxscan1035_done
  rxscan1035_scan:
    set_addr $I10, rxscan1035_loop
    rx1031_cur."!mark_push"(0, rx1031_pos, $I10)
  rxscan1035_done:
.annotate 'line', 472
  # rx subrule "deflongname" subtype=capture negate=
    rx1031_cur."!cursor_pos"(rx1031_pos)
    $P10 = rx1031_cur."deflongname"()
    unless $P10, rx1031_fail
    rx1031_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1031_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1031_pos, rx1031_off
    substr $S10, rx1031_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1031_fail
  # rx subrule "args" subtype=capture negate=
    rx1031_cur."!cursor_pos"(rx1031_pos)
    $P10 = rx1031_cur."args"()
    unless $P10, rx1031_fail
    rx1031_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1031_pos = $P10."pos"()
.annotate 'line', 471
  # rx pass
    rx1031_cur."!cursor_pass"(rx1031_pos, "term:sym<identifier>")
    if_null rx1031_debug, debug_799
    rx1031_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1031_pos)
  debug_799:
    .return (rx1031_cur)
  rx1031_restart:
.annotate 'line', 4
    if_null rx1031_debug, debug_800
    rx1031_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_800:
  rx1031_fail:
    (rx1031_rep, rx1031_pos, $I10, $P10) = rx1031_cur."!mark_fail"(0)
    lt rx1031_pos, -1, rx1031_done
    eq rx1031_pos, -1, rx1031_fail
    jump $I10
  rx1031_done:
    rx1031_cur."!cursor_fail"()
    if_null rx1031_debug, debug_801
    rx1031_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_801:
    .return (rx1031_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("213_1298845521.609") :method
.annotate 'line', 4
    $P1033 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1034, "ResizablePMCArray"
    push $P1034, $P1033
    .return ($P1034)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("214_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1037_tgt
    .local int rx1037_pos
    .local int rx1037_off
    .local int rx1037_eos
    .local int rx1037_rep
    .local pmc rx1037_cur
    .local pmc rx1037_debug
    (rx1037_cur, rx1037_pos, rx1037_tgt, $I10) = self."!cursor_start"()
    rx1037_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1037_cur
    .local pmc match
    .lex "$/", match
    length rx1037_eos, rx1037_tgt
    gt rx1037_pos, rx1037_eos, rx1037_done
    set rx1037_off, 0
    lt rx1037_pos, 2, rx1037_start
    sub rx1037_off, rx1037_pos, 1
    substr rx1037_tgt, rx1037_tgt, rx1037_off
  rx1037_start:
    eq $I10, 1, rx1037_restart
    if_null rx1037_debug, debug_802
    rx1037_cur."!cursor_debug"("START", "term:sym<name>")
  debug_802:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1041_done
    goto rxscan1041_scan
  rxscan1041_loop:
    (rx1037_pos) = rx1037_cur."from"()
    inc rx1037_pos
    rx1037_cur."!cursor_from"(rx1037_pos)
    ge rx1037_pos, rx1037_eos, rxscan1041_done
  rxscan1041_scan:
    set_addr $I10, rxscan1041_loop
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  rxscan1041_done:
.annotate 'line', 476
  # rx subrule "name" subtype=capture negate=
    rx1037_cur."!cursor_pos"(rx1037_pos)
    $P10 = rx1037_cur."name"()
    unless $P10, rx1037_fail
    rx1037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1037_pos = $P10."pos"()
  # rx rxquantr1042 ** 0..1
    set_addr $I10, rxquantr1042_done
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  rxquantr1042_loop:
  # rx subrule "args" subtype=capture negate=
    rx1037_cur."!cursor_pos"(rx1037_pos)
    $P10 = rx1037_cur."args"()
    unless $P10, rx1037_fail
    goto rxsubrule1043_pass
  rxsubrule1043_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1037_fail
  rxsubrule1043_pass:
    set_addr $I10, rxsubrule1043_back
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1037_pos = $P10."pos"()
    set_addr $I10, rxquantr1042_done
    (rx1037_rep) = rx1037_cur."!mark_commit"($I10)
  rxquantr1042_done:
.annotate 'line', 475
  # rx pass
    rx1037_cur."!cursor_pass"(rx1037_pos, "term:sym<name>")
    if_null rx1037_debug, debug_803
    rx1037_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1037_pos)
  debug_803:
    .return (rx1037_cur)
  rx1037_restart:
.annotate 'line', 4
    if_null rx1037_debug, debug_804
    rx1037_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_804:
  rx1037_fail:
    (rx1037_rep, rx1037_pos, $I10, $P10) = rx1037_cur."!mark_fail"(0)
    lt rx1037_pos, -1, rx1037_done
    eq rx1037_pos, -1, rx1037_fail
    jump $I10
  rx1037_done:
    rx1037_cur."!cursor_fail"()
    if_null rx1037_debug, debug_805
    rx1037_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_805:
    .return (rx1037_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("215_1298845521.609") :method
.annotate 'line', 4
    $P1039 = self."!PREFIX__!subrule"("name", "")
    new $P1040, "ResizablePMCArray"
    push $P1040, $P1039
    .return ($P1040)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("216_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1045_tgt
    .local int rx1045_pos
    .local int rx1045_off
    .local int rx1045_eos
    .local int rx1045_rep
    .local pmc rx1045_cur
    .local pmc rx1045_debug
    (rx1045_cur, rx1045_pos, rx1045_tgt, $I10) = self."!cursor_start"()
    rx1045_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1045_cur
    .local pmc match
    .lex "$/", match
    length rx1045_eos, rx1045_tgt
    gt rx1045_pos, rx1045_eos, rx1045_done
    set rx1045_off, 0
    lt rx1045_pos, 2, rx1045_start
    sub rx1045_off, rx1045_pos, 1
    substr rx1045_tgt, rx1045_tgt, rx1045_off
  rx1045_start:
    eq $I10, 1, rx1045_restart
    if_null rx1045_debug, debug_806
    rx1045_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_806:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1048_done
    goto rxscan1048_scan
  rxscan1048_loop:
    (rx1045_pos) = rx1045_cur."from"()
    inc rx1045_pos
    rx1045_cur."!cursor_from"(rx1045_pos)
    ge rx1045_pos, rx1045_eos, rxscan1048_done
  rxscan1048_scan:
    set_addr $I10, rxscan1048_loop
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  rxscan1048_done:
.annotate 'line', 480
  # rx literal  "pir::"
    add $I11, rx1045_pos, 5
    gt $I11, rx1045_eos, rx1045_fail
    sub $I11, rx1045_pos, rx1045_off
    substr $S10, rx1045_tgt, $I11, 5
    ne $S10, "pir::", rx1045_fail
    add rx1045_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1049_fail
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1045_pos, rx1045_off
    find_not_cclass $I11, 8192, rx1045_tgt, $I10, rx1045_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1045_fail
    add rx1045_pos, rx1045_off, $I11
    set_addr $I10, rxcap_1049_fail
    ($I12, $I11) = rx1045_cur."!mark_peek"($I10)
    rx1045_cur."!cursor_pos"($I11)
    ($P10) = rx1045_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1045_pos, "")
    rx1045_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1049_done
  rxcap_1049_fail:
    goto rx1045_fail
  rxcap_1049_done:
  # rx rxquantr1050 ** 0..1
    set_addr $I10, rxquantr1050_done
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  rxquantr1050_loop:
  # rx subrule "args" subtype=capture negate=
    rx1045_cur."!cursor_pos"(rx1045_pos)
    $P10 = rx1045_cur."args"()
    unless $P10, rx1045_fail
    goto rxsubrule1051_pass
  rxsubrule1051_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1045_fail
  rxsubrule1051_pass:
    set_addr $I10, rxsubrule1051_back
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1045_pos = $P10."pos"()
    set_addr $I10, rxquantr1050_done
    (rx1045_rep) = rx1045_cur."!mark_commit"($I10)
  rxquantr1050_done:
.annotate 'line', 479
  # rx pass
    rx1045_cur."!cursor_pass"(rx1045_pos, "term:sym<pir::op>")
    if_null rx1045_debug, debug_807
    rx1045_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1045_pos)
  debug_807:
    .return (rx1045_cur)
  rx1045_restart:
.annotate 'line', 4
    if_null rx1045_debug, debug_808
    rx1045_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_808:
  rx1045_fail:
    (rx1045_rep, rx1045_pos, $I10, $P10) = rx1045_cur."!mark_fail"(0)
    lt rx1045_pos, -1, rx1045_done
    eq rx1045_pos, -1, rx1045_fail
    jump $I10
  rx1045_done:
    rx1045_cur."!cursor_fail"()
    if_null rx1045_debug, debug_809
    rx1045_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_809:
    .return (rx1045_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("217_1298845521.609") :method
.annotate 'line', 4
    new $P1047, "ResizablePMCArray"
    push $P1047, "pir::"
    .return ($P1047)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("218_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P1061 = "220_1298845521.609" 
    capture_lex $P1061
    .local string rx1053_tgt
    .local int rx1053_pos
    .local int rx1053_off
    .local int rx1053_eos
    .local int rx1053_rep
    .local pmc rx1053_cur
    .local pmc rx1053_debug
    (rx1053_cur, rx1053_pos, rx1053_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1053_cur
    .local pmc match
    .lex "$/", match
    length rx1053_eos, rx1053_tgt
    gt rx1053_pos, rx1053_eos, rx1053_done
    set rx1053_off, 0
    lt rx1053_pos, 2, rx1053_start
    sub rx1053_off, rx1053_pos, 1
    substr rx1053_tgt, rx1053_tgt, rx1053_off
  rx1053_start:
    eq $I10, 1, rx1053_restart
    if_null rx1053_debug, debug_810
    rx1053_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1056_done
    goto rxscan1056_scan
  rxscan1056_loop:
    (rx1053_pos) = rx1053_cur."from"()
    inc rx1053_pos
    rx1053_cur."!cursor_from"(rx1053_pos)
    ge rx1053_pos, rx1053_eos, rxscan1056_done
  rxscan1056_scan:
    set_addr $I10, rxscan1056_loop
    rx1053_cur."!mark_push"(0, rx1053_pos, $I10)
  rxscan1056_done:
.annotate 'line', 484
  # rx literal  "{*}"
    add $I11, rx1053_pos, 3
    gt $I11, rx1053_eos, rx1053_fail
    sub $I11, rx1053_pos, rx1053_off
    substr $S10, rx1053_tgt, $I11, 3
    ne $S10, "{*}", rx1053_fail
    add rx1053_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1053_cur."!cursor_pos"(rx1053_pos)
    $P10 = rx1053_cur."ENDSTMT"()
    unless $P10, rx1053_fail
  alt1057_0:
.annotate 'line', 485
    set_addr $I10, alt1057_1
    rx1053_cur."!mark_push"(0, rx1053_pos, $I10)
    rx1053_cur."!cursor_pos"(rx1053_pos)
    find_lex $P1058, unicode:"$\x{a2}"
    $P1059 = $P1058."MATCH"()
    store_lex "$/", $P1059
    .const 'Sub' $P1061 = "220_1298845521.609" 
    capture_lex $P1061
    $P1065 = $P1061()
    unless $P1065, rx1053_fail
    goto alt1057_end
  alt1057_1:
  # rx subrule "panic" subtype=method negate=
    rx1053_cur."!cursor_pos"(rx1053_pos)
    $P10 = rx1053_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1053_fail
    rx1053_pos = $P10."pos"()
  alt1057_end:
.annotate 'line', 483
  # rx pass
    rx1053_cur."!cursor_pass"(rx1053_pos, "term:sym<onlystar>")
    if_null rx1053_debug, debug_813
    rx1053_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1053_pos)
  debug_813:
    .return (rx1053_cur)
  rx1053_restart:
.annotate 'line', 4
    if_null rx1053_debug, debug_814
    rx1053_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_814:
  rx1053_fail:
    (rx1053_rep, rx1053_pos, $I10, $P10) = rx1053_cur."!mark_fail"(0)
    lt rx1053_pos, -1, rx1053_done
    eq rx1053_pos, -1, rx1053_fail
    jump $I10
  rx1053_done:
    rx1053_cur."!cursor_fail"()
    if_null rx1053_debug, debug_815
    rx1053_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_815:
    .return (rx1053_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("219_1298845521.609") :method
.annotate 'line', 4
    new $P1055, "ResizablePMCArray"
    push $P1055, "{*}"
    .return ($P1055)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1060"  :anon :subid("220_1298845521.609") :outer("218_1298845521.609")
.annotate 'line', 485
    find_dynamic_lex $P1062, "$*MULTINESS"
    unless_null $P1062, vivify_811
    get_hll_global $P1062, "$MULTINESS"
    unless_null $P1062, vivify_812
    die "Contextual $*MULTINESS not found"
  vivify_812:
  vivify_811:
    set $S1063, $P1062
    iseq $I1064, $S1063, "proto"
    .return ($I1064)
.end


.namespace ["NQP";"Grammar"]
.sub "args"  :subid("221_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1067_tgt
    .local int rx1067_pos
    .local int rx1067_off
    .local int rx1067_eos
    .local int rx1067_rep
    .local pmc rx1067_cur
    .local pmc rx1067_debug
    (rx1067_cur, rx1067_pos, rx1067_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1067_cur
    .local pmc match
    .lex "$/", match
    length rx1067_eos, rx1067_tgt
    gt rx1067_pos, rx1067_eos, rx1067_done
    set rx1067_off, 0
    lt rx1067_pos, 2, rx1067_start
    sub rx1067_off, rx1067_pos, 1
    substr rx1067_tgt, rx1067_tgt, rx1067_off
  rx1067_start:
    eq $I10, 1, rx1067_restart
    if_null rx1067_debug, debug_816
    rx1067_cur."!cursor_debug"("START", "args")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1071_done
    goto rxscan1071_scan
  rxscan1071_loop:
    (rx1067_pos) = rx1067_cur."from"()
    inc rx1067_pos
    rx1067_cur."!cursor_from"(rx1067_pos)
    ge rx1067_pos, rx1067_eos, rxscan1071_done
  rxscan1071_scan:
    set_addr $I10, rxscan1071_loop
    rx1067_cur."!mark_push"(0, rx1067_pos, $I10)
  rxscan1071_done:
.annotate 'line', 489
  # rx literal  "("
    add $I11, rx1067_pos, 1
    gt $I11, rx1067_eos, rx1067_fail
    sub $I11, rx1067_pos, rx1067_off
    ord $I11, rx1067_tgt, $I11
    ne $I11, 40, rx1067_fail
    add rx1067_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1067_cur."!cursor_pos"(rx1067_pos)
    $P10 = rx1067_cur."arglist"()
    unless $P10, rx1067_fail
    rx1067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1067_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1067_pos, 1
    gt $I11, rx1067_eos, rx1067_fail
    sub $I11, rx1067_pos, rx1067_off
    ord $I11, rx1067_tgt, $I11
    ne $I11, 41, rx1067_fail
    add rx1067_pos, 1
  # rx pass
    rx1067_cur."!cursor_pass"(rx1067_pos, "args")
    if_null rx1067_debug, debug_817
    rx1067_cur."!cursor_debug"("PASS", "args", " at pos=", rx1067_pos)
  debug_817:
    .return (rx1067_cur)
  rx1067_restart:
.annotate 'line', 4
    if_null rx1067_debug, debug_818
    rx1067_cur."!cursor_debug"("NEXT", "args")
  debug_818:
  rx1067_fail:
    (rx1067_rep, rx1067_pos, $I10, $P10) = rx1067_cur."!mark_fail"(0)
    lt rx1067_pos, -1, rx1067_done
    eq rx1067_pos, -1, rx1067_fail
    jump $I10
  rx1067_done:
    rx1067_cur."!cursor_fail"()
    if_null rx1067_debug, debug_819
    rx1067_cur."!cursor_debug"("FAIL", "args")
  debug_819:
    .return (rx1067_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("222_1298845521.609") :method
.annotate 'line', 4
    $P1069 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1070, "ResizablePMCArray"
    push $P1070, $P1069
    .return ($P1070)
.end


.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("223_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1073_tgt
    .local int rx1073_pos
    .local int rx1073_off
    .local int rx1073_eos
    .local int rx1073_rep
    .local pmc rx1073_cur
    .local pmc rx1073_debug
    (rx1073_cur, rx1073_pos, rx1073_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1073_cur
    .local pmc match
    .lex "$/", match
    length rx1073_eos, rx1073_tgt
    gt rx1073_pos, rx1073_eos, rx1073_done
    set rx1073_off, 0
    lt rx1073_pos, 2, rx1073_start
    sub rx1073_off, rx1073_pos, 1
    substr rx1073_tgt, rx1073_tgt, rx1073_off
  rx1073_start:
    eq $I10, 1, rx1073_restart
    if_null rx1073_debug, debug_820
    rx1073_cur."!cursor_debug"("START", "arglist")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1077_done
    goto rxscan1077_scan
  rxscan1077_loop:
    (rx1073_pos) = rx1073_cur."from"()
    inc rx1073_pos
    rx1073_cur."!cursor_from"(rx1073_pos)
    ge rx1073_pos, rx1073_eos, rxscan1077_done
  rxscan1077_scan:
    set_addr $I10, rxscan1077_loop
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
  rxscan1077_done:
.annotate 'line', 493
  # rx subrule "ws" subtype=method negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."ws"()
    unless $P10, rx1073_fail
    rx1073_pos = $P10."pos"()
  alt1078_0:
.annotate 'line', 494
    set_addr $I10, alt1078_1
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
.annotate 'line', 495
  # rx subrule "EXPR" subtype=capture negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."EXPR"("f=")
    unless $P10, rx1073_fail
    rx1073_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1073_pos = $P10."pos"()
    goto alt1078_end
  alt1078_1:
  alt1078_end:
.annotate 'line', 492
  # rx pass
    rx1073_cur."!cursor_pass"(rx1073_pos, "arglist")
    if_null rx1073_debug, debug_821
    rx1073_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1073_pos)
  debug_821:
    .return (rx1073_cur)
  rx1073_restart:
.annotate 'line', 4
    if_null rx1073_debug, debug_822
    rx1073_cur."!cursor_debug"("NEXT", "arglist")
  debug_822:
  rx1073_fail:
    (rx1073_rep, rx1073_pos, $I10, $P10) = rx1073_cur."!mark_fail"(0)
    lt rx1073_pos, -1, rx1073_done
    eq rx1073_pos, -1, rx1073_fail
    jump $I10
  rx1073_done:
    rx1073_cur."!cursor_fail"()
    if_null rx1073_debug, debug_823
    rx1073_cur."!cursor_debug"("FAIL", "arglist")
  debug_823:
    .return (rx1073_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("224_1298845521.609") :method
.annotate 'line', 4
    $P1075 = self."!PREFIX__!subrule"("ws", "")
    new $P1076, "ResizablePMCArray"
    push $P1076, $P1075
    .return ($P1076)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("225_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1080_tgt
    .local int rx1080_pos
    .local int rx1080_off
    .local int rx1080_eos
    .local int rx1080_rep
    .local pmc rx1080_cur
    .local pmc rx1080_debug
    (rx1080_cur, rx1080_pos, rx1080_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1080_cur
    .local pmc match
    .lex "$/", match
    length rx1080_eos, rx1080_tgt
    gt rx1080_pos, rx1080_eos, rx1080_done
    set rx1080_off, 0
    lt rx1080_pos, 2, rx1080_start
    sub rx1080_off, rx1080_pos, 1
    substr rx1080_tgt, rx1080_tgt, rx1080_off
  rx1080_start:
    eq $I10, 1, rx1080_restart
    if_null rx1080_debug, debug_824
    rx1080_cur."!cursor_debug"("START", "term:sym<value>")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1084_done
    goto rxscan1084_scan
  rxscan1084_loop:
    (rx1080_pos) = rx1080_cur."from"()
    inc rx1080_pos
    rx1080_cur."!cursor_from"(rx1080_pos)
    ge rx1080_pos, rx1080_eos, rxscan1084_done
  rxscan1084_scan:
    set_addr $I10, rxscan1084_loop
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxscan1084_done:
.annotate 'line', 501
  # rx subrule "value" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."value"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1080_pos = $P10."pos"()
  # rx pass
    rx1080_cur."!cursor_pass"(rx1080_pos, "term:sym<value>")
    if_null rx1080_debug, debug_825
    rx1080_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1080_pos)
  debug_825:
    .return (rx1080_cur)
  rx1080_restart:
.annotate 'line', 4
    if_null rx1080_debug, debug_826
    rx1080_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_826:
  rx1080_fail:
    (rx1080_rep, rx1080_pos, $I10, $P10) = rx1080_cur."!mark_fail"(0)
    lt rx1080_pos, -1, rx1080_done
    eq rx1080_pos, -1, rx1080_fail
    jump $I10
  rx1080_done:
    rx1080_cur."!cursor_fail"()
    if_null rx1080_debug, debug_827
    rx1080_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_827:
    .return (rx1080_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("226_1298845521.609") :method
.annotate 'line', 4
    $P1082 = self."!PREFIX__!subrule"("value", "")
    new $P1083, "ResizablePMCArray"
    push $P1083, $P1082
    .return ($P1083)
.end


.namespace ["NQP";"Grammar"]
.sub "value"  :subid("227_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1086_tgt
    .local int rx1086_pos
    .local int rx1086_off
    .local int rx1086_eos
    .local int rx1086_rep
    .local pmc rx1086_cur
    .local pmc rx1086_debug
    (rx1086_cur, rx1086_pos, rx1086_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1086_cur
    .local pmc match
    .lex "$/", match
    length rx1086_eos, rx1086_tgt
    gt rx1086_pos, rx1086_eos, rx1086_done
    set rx1086_off, 0
    lt rx1086_pos, 2, rx1086_start
    sub rx1086_off, rx1086_pos, 1
    substr rx1086_tgt, rx1086_tgt, rx1086_off
  rx1086_start:
    eq $I10, 1, rx1086_restart
    if_null rx1086_debug, debug_828
    rx1086_cur."!cursor_debug"("START", "value")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1091_done
    goto rxscan1091_scan
  rxscan1091_loop:
    (rx1086_pos) = rx1086_cur."from"()
    inc rx1086_pos
    rx1086_cur."!cursor_from"(rx1086_pos)
    ge rx1086_pos, rx1086_eos, rxscan1091_done
  rxscan1091_scan:
    set_addr $I10, rxscan1091_loop
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
  rxscan1091_done:
  alt1092_0:
.annotate 'line', 503
    set_addr $I10, alt1092_1
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
.annotate 'line', 504
  # rx subrule "quote" subtype=capture negate=
    rx1086_cur."!cursor_pos"(rx1086_pos)
    $P10 = rx1086_cur."quote"()
    unless $P10, rx1086_fail
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1086_pos = $P10."pos"()
    goto alt1092_end
  alt1092_1:
.annotate 'line', 505
  # rx subrule "number" subtype=capture negate=
    rx1086_cur."!cursor_pos"(rx1086_pos)
    $P10 = rx1086_cur."number"()
    unless $P10, rx1086_fail
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1086_pos = $P10."pos"()
  alt1092_end:
.annotate 'line', 503
  # rx pass
    rx1086_cur."!cursor_pass"(rx1086_pos, "value")
    if_null rx1086_debug, debug_829
    rx1086_cur."!cursor_debug"("PASS", "value", " at pos=", rx1086_pos)
  debug_829:
    .return (rx1086_cur)
  rx1086_restart:
.annotate 'line', 4
    if_null rx1086_debug, debug_830
    rx1086_cur."!cursor_debug"("NEXT", "value")
  debug_830:
  rx1086_fail:
    (rx1086_rep, rx1086_pos, $I10, $P10) = rx1086_cur."!mark_fail"(0)
    lt rx1086_pos, -1, rx1086_done
    eq rx1086_pos, -1, rx1086_fail
    jump $I10
  rx1086_done:
    rx1086_cur."!cursor_fail"()
    if_null rx1086_debug, debug_831
    rx1086_cur."!cursor_debug"("FAIL", "value")
  debug_831:
    .return (rx1086_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("228_1298845521.609") :method
.annotate 'line', 4
    $P1088 = self."!PREFIX__!subrule"("number", "")
    $P1089 = self."!PREFIX__!subrule"("quote", "")
    new $P1090, "ResizablePMCArray"
    push $P1090, $P1088
    push $P1090, $P1089
    .return ($P1090)
.end


.namespace ["NQP";"Grammar"]
.sub "number"  :subid("229_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1094_tgt
    .local int rx1094_pos
    .local int rx1094_off
    .local int rx1094_eos
    .local int rx1094_rep
    .local pmc rx1094_cur
    .local pmc rx1094_debug
    (rx1094_cur, rx1094_pos, rx1094_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1094_cur
    .local pmc match
    .lex "$/", match
    length rx1094_eos, rx1094_tgt
    gt rx1094_pos, rx1094_eos, rx1094_done
    set rx1094_off, 0
    lt rx1094_pos, 2, rx1094_start
    sub rx1094_off, rx1094_pos, 1
    substr rx1094_tgt, rx1094_tgt, rx1094_off
  rx1094_start:
    eq $I10, 1, rx1094_restart
    if_null rx1094_debug, debug_832
    rx1094_cur."!cursor_debug"("START", "number")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1097_done
    goto rxscan1097_scan
  rxscan1097_loop:
    (rx1094_pos) = rx1094_cur."from"()
    inc rx1094_pos
    rx1094_cur."!cursor_from"(rx1094_pos)
    ge rx1094_pos, rx1094_eos, rxscan1097_done
  rxscan1097_scan:
    set_addr $I10, rxscan1097_loop
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  rxscan1097_done:
.annotate 'line', 509
  # rx subcapture "sign"
    set_addr $I10, rxcap_1099_fail
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1094_pos, rx1094_off
    set rx1094_rep, 0
    sub $I12, rx1094_eos, rx1094_pos
    le $I12, 1, rxenumcharlistq1098_loop
    set $I12, 1
  rxenumcharlistq1098_loop:
    le $I12, 0, rxenumcharlistq1098_done
    substr $S10, rx1094_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1098_done
    inc rx1094_rep
  rxenumcharlistq1098_done:
    add rx1094_pos, rx1094_pos, rx1094_rep
    set_addr $I10, rxcap_1099_fail
    ($I12, $I11) = rx1094_cur."!mark_peek"($I10)
    rx1094_cur."!cursor_pos"($I11)
    ($P10) = rx1094_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1094_pos, "")
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1099_done
  rxcap_1099_fail:
    goto rx1094_fail
  rxcap_1099_done:
  alt1100_0:
.annotate 'line', 510
    set_addr $I10, alt1100_1
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."dec_number"()
    unless $P10, rx1094_fail
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1094_pos = $P10."pos"()
    goto alt1100_end
  alt1100_1:
  # rx subrule "integer" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."integer"()
    unless $P10, rx1094_fail
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1094_pos = $P10."pos"()
  alt1100_end:
.annotate 'line', 508
  # rx pass
    rx1094_cur."!cursor_pass"(rx1094_pos, "number")
    if_null rx1094_debug, debug_833
    rx1094_cur."!cursor_debug"("PASS", "number", " at pos=", rx1094_pos)
  debug_833:
    .return (rx1094_cur)
  rx1094_restart:
.annotate 'line', 4
    if_null rx1094_debug, debug_834
    rx1094_cur."!cursor_debug"("NEXT", "number")
  debug_834:
  rx1094_fail:
    (rx1094_rep, rx1094_pos, $I10, $P10) = rx1094_cur."!mark_fail"(0)
    lt rx1094_pos, -1, rx1094_done
    eq rx1094_pos, -1, rx1094_fail
    jump $I10
  rx1094_done:
    rx1094_cur."!cursor_fail"()
    if_null rx1094_debug, debug_835
    rx1094_cur."!cursor_debug"("FAIL", "number")
  debug_835:
    .return (rx1094_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("230_1298845521.609") :method
.annotate 'line', 4
    new $P1096, "ResizablePMCArray"
    push $P1096, ""
    .return ($P1096)
.end


.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("231_1298845521.609")
    .param pmc param_1102
.annotate 'line', 513
    .lex "self", param_1102
    $P1103 = param_1102."!protoregex"("quote")
    .return ($P1103)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("232_1298845521.609")
    .param pmc param_1105
.annotate 'line', 513
    .lex "self", param_1105
    $P1106 = param_1105."!PREFIX__!protoregex"("quote")
    .return ($P1106)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("233_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1108_tgt
    .local int rx1108_pos
    .local int rx1108_off
    .local int rx1108_eos
    .local int rx1108_rep
    .local pmc rx1108_cur
    .local pmc rx1108_debug
    (rx1108_cur, rx1108_pos, rx1108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1108_cur
    .local pmc match
    .lex "$/", match
    length rx1108_eos, rx1108_tgt
    gt rx1108_pos, rx1108_eos, rx1108_done
    set rx1108_off, 0
    lt rx1108_pos, 2, rx1108_start
    sub rx1108_off, rx1108_pos, 1
    substr rx1108_tgt, rx1108_tgt, rx1108_off
  rx1108_start:
    eq $I10, 1, rx1108_restart
    if_null rx1108_debug, debug_836
    rx1108_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1111_done
    goto rxscan1111_scan
  rxscan1111_loop:
    (rx1108_pos) = rx1108_cur."from"()
    inc rx1108_pos
    rx1108_cur."!cursor_from"(rx1108_pos)
    ge rx1108_pos, rx1108_eos, rxscan1111_done
  rxscan1111_scan:
    set_addr $I10, rxscan1111_loop
    rx1108_cur."!mark_push"(0, rx1108_pos, $I10)
  rxscan1111_done:
.annotate 'line', 514
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1108_pos, rx1108_off
    substr $S10, rx1108_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1108_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1108_cur."!cursor_pos"(rx1108_pos)
    $P10 = rx1108_cur."quote_EXPR"(":q")
    unless $P10, rx1108_fail
    rx1108_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1108_pos = $P10."pos"()
  # rx pass
    rx1108_cur."!cursor_pass"(rx1108_pos, "quote:sym<apos>")
    if_null rx1108_debug, debug_837
    rx1108_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1108_pos)
  debug_837:
    .return (rx1108_cur)
  rx1108_restart:
.annotate 'line', 4
    if_null rx1108_debug, debug_838
    rx1108_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_838:
  rx1108_fail:
    (rx1108_rep, rx1108_pos, $I10, $P10) = rx1108_cur."!mark_fail"(0)
    lt rx1108_pos, -1, rx1108_done
    eq rx1108_pos, -1, rx1108_fail
    jump $I10
  rx1108_done:
    rx1108_cur."!cursor_fail"()
    if_null rx1108_debug, debug_839
    rx1108_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_839:
    .return (rx1108_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("234_1298845521.609") :method
.annotate 'line', 4
    new $P1110, "ResizablePMCArray"
    push $P1110, "'"
    .return ($P1110)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("235_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1113_tgt
    .local int rx1113_pos
    .local int rx1113_off
    .local int rx1113_eos
    .local int rx1113_rep
    .local pmc rx1113_cur
    .local pmc rx1113_debug
    (rx1113_cur, rx1113_pos, rx1113_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1113_cur
    .local pmc match
    .lex "$/", match
    length rx1113_eos, rx1113_tgt
    gt rx1113_pos, rx1113_eos, rx1113_done
    set rx1113_off, 0
    lt rx1113_pos, 2, rx1113_start
    sub rx1113_off, rx1113_pos, 1
    substr rx1113_tgt, rx1113_tgt, rx1113_off
  rx1113_start:
    eq $I10, 1, rx1113_restart
    if_null rx1113_debug, debug_840
    rx1113_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1116_done
    goto rxscan1116_scan
  rxscan1116_loop:
    (rx1113_pos) = rx1113_cur."from"()
    inc rx1113_pos
    rx1113_cur."!cursor_from"(rx1113_pos)
    ge rx1113_pos, rx1113_eos, rxscan1116_done
  rxscan1116_scan:
    set_addr $I10, rxscan1116_loop
    rx1113_cur."!mark_push"(0, rx1113_pos, $I10)
  rxscan1116_done:
.annotate 'line', 515
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1113_pos, rx1113_off
    substr $S10, rx1113_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1113_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1113_cur."!cursor_pos"(rx1113_pos)
    $P10 = rx1113_cur."quote_EXPR"(":qq")
    unless $P10, rx1113_fail
    rx1113_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1113_pos = $P10."pos"()
  # rx pass
    rx1113_cur."!cursor_pass"(rx1113_pos, "quote:sym<dblq>")
    if_null rx1113_debug, debug_841
    rx1113_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1113_pos)
  debug_841:
    .return (rx1113_cur)
  rx1113_restart:
.annotate 'line', 4
    if_null rx1113_debug, debug_842
    rx1113_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_842:
  rx1113_fail:
    (rx1113_rep, rx1113_pos, $I10, $P10) = rx1113_cur."!mark_fail"(0)
    lt rx1113_pos, -1, rx1113_done
    eq rx1113_pos, -1, rx1113_fail
    jump $I10
  rx1113_done:
    rx1113_cur."!cursor_fail"()
    if_null rx1113_debug, debug_843
    rx1113_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_843:
    .return (rx1113_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("236_1298845521.609") :method
.annotate 'line', 4
    new $P1115, "ResizablePMCArray"
    push $P1115, "\""
    .return ($P1115)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("237_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1118_tgt
    .local int rx1118_pos
    .local int rx1118_off
    .local int rx1118_eos
    .local int rx1118_rep
    .local pmc rx1118_cur
    .local pmc rx1118_debug
    (rx1118_cur, rx1118_pos, rx1118_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1118_cur
    .local pmc match
    .lex "$/", match
    length rx1118_eos, rx1118_tgt
    gt rx1118_pos, rx1118_eos, rx1118_done
    set rx1118_off, 0
    lt rx1118_pos, 2, rx1118_start
    sub rx1118_off, rx1118_pos, 1
    substr rx1118_tgt, rx1118_tgt, rx1118_off
  rx1118_start:
    eq $I10, 1, rx1118_restart
    if_null rx1118_debug, debug_844
    rx1118_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1122_done
    goto rxscan1122_scan
  rxscan1122_loop:
    (rx1118_pos) = rx1118_cur."from"()
    inc rx1118_pos
    rx1118_cur."!cursor_from"(rx1118_pos)
    ge rx1118_pos, rx1118_eos, rxscan1122_done
  rxscan1122_scan:
    set_addr $I10, rxscan1122_loop
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxscan1122_done:
.annotate 'line', 516
  # rx literal  "q"
    add $I11, rx1118_pos, 1
    gt $I11, rx1118_eos, rx1118_fail
    sub $I11, rx1118_pos, rx1118_off
    ord $I11, rx1118_tgt, $I11
    ne $I11, 113, rx1118_fail
    add rx1118_pos, 1
  # rxanchor rwb
    le rx1118_pos, 0, rx1118_fail
    sub $I10, rx1118_pos, rx1118_off
    is_cclass $I11, 8192, rx1118_tgt, $I10
    if $I11, rx1118_fail
    dec $I10
    is_cclass $I11, 8192, rx1118_tgt, $I10
    unless $I11, rx1118_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1118_pos, rx1118_off
    substr $S10, rx1118_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1118_fail
  # rx subrule "ws" subtype=method negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."ws"()
    unless $P10, rx1118_fail
    rx1118_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."quote_EXPR"(":q")
    unless $P10, rx1118_fail
    rx1118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1118_pos = $P10."pos"()
  # rx pass
    rx1118_cur."!cursor_pass"(rx1118_pos, "quote:sym<q>")
    if_null rx1118_debug, debug_845
    rx1118_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1118_pos)
  debug_845:
    .return (rx1118_cur)
  rx1118_restart:
.annotate 'line', 4
    if_null rx1118_debug, debug_846
    rx1118_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_846:
  rx1118_fail:
    (rx1118_rep, rx1118_pos, $I10, $P10) = rx1118_cur."!mark_fail"(0)
    lt rx1118_pos, -1, rx1118_done
    eq rx1118_pos, -1, rx1118_fail
    jump $I10
  rx1118_done:
    rx1118_cur."!cursor_fail"()
    if_null rx1118_debug, debug_847
    rx1118_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_847:
    .return (rx1118_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("238_1298845521.609") :method
.annotate 'line', 4
    $P1120 = self."!PREFIX__!subrule"("ws", "q")
    new $P1121, "ResizablePMCArray"
    push $P1121, $P1120
    .return ($P1121)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("239_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1124_tgt
    .local int rx1124_pos
    .local int rx1124_off
    .local int rx1124_eos
    .local int rx1124_rep
    .local pmc rx1124_cur
    .local pmc rx1124_debug
    (rx1124_cur, rx1124_pos, rx1124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1124_cur
    .local pmc match
    .lex "$/", match
    length rx1124_eos, rx1124_tgt
    gt rx1124_pos, rx1124_eos, rx1124_done
    set rx1124_off, 0
    lt rx1124_pos, 2, rx1124_start
    sub rx1124_off, rx1124_pos, 1
    substr rx1124_tgt, rx1124_tgt, rx1124_off
  rx1124_start:
    eq $I10, 1, rx1124_restart
    if_null rx1124_debug, debug_848
    rx1124_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1128_done
    goto rxscan1128_scan
  rxscan1128_loop:
    (rx1124_pos) = rx1124_cur."from"()
    inc rx1124_pos
    rx1124_cur."!cursor_from"(rx1124_pos)
    ge rx1124_pos, rx1124_eos, rxscan1128_done
  rxscan1128_scan:
    set_addr $I10, rxscan1128_loop
    rx1124_cur."!mark_push"(0, rx1124_pos, $I10)
  rxscan1128_done:
.annotate 'line', 517
  # rx literal  "qq"
    add $I11, rx1124_pos, 2
    gt $I11, rx1124_eos, rx1124_fail
    sub $I11, rx1124_pos, rx1124_off
    substr $S10, rx1124_tgt, $I11, 2
    ne $S10, "qq", rx1124_fail
    add rx1124_pos, 2
  # rxanchor rwb
    le rx1124_pos, 0, rx1124_fail
    sub $I10, rx1124_pos, rx1124_off
    is_cclass $I11, 8192, rx1124_tgt, $I10
    if $I11, rx1124_fail
    dec $I10
    is_cclass $I11, 8192, rx1124_tgt, $I10
    unless $I11, rx1124_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1124_pos, rx1124_off
    substr $S10, rx1124_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1124_fail
  # rx subrule "ws" subtype=method negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."ws"()
    unless $P10, rx1124_fail
    rx1124_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."quote_EXPR"(":qq")
    unless $P10, rx1124_fail
    rx1124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1124_pos = $P10."pos"()
  # rx pass
    rx1124_cur."!cursor_pass"(rx1124_pos, "quote:sym<qq>")
    if_null rx1124_debug, debug_849
    rx1124_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1124_pos)
  debug_849:
    .return (rx1124_cur)
  rx1124_restart:
.annotate 'line', 4
    if_null rx1124_debug, debug_850
    rx1124_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_850:
  rx1124_fail:
    (rx1124_rep, rx1124_pos, $I10, $P10) = rx1124_cur."!mark_fail"(0)
    lt rx1124_pos, -1, rx1124_done
    eq rx1124_pos, -1, rx1124_fail
    jump $I10
  rx1124_done:
    rx1124_cur."!cursor_fail"()
    if_null rx1124_debug, debug_851
    rx1124_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_851:
    .return (rx1124_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("240_1298845521.609") :method
.annotate 'line', 4
    $P1126 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1127, "ResizablePMCArray"
    push $P1127, $P1126
    .return ($P1127)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("241_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_852
    rx1130_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1134_done
    goto rxscan1134_scan
  rxscan1134_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1134_done
  rxscan1134_scan:
    set_addr $I10, rxscan1134_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1134_done:
.annotate 'line', 518
  # rx literal  "Q"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 81, rx1130_fail
    add rx1130_pos, 1
  # rxanchor rwb
    le rx1130_pos, 0, rx1130_fail
    sub $I10, rx1130_pos, rx1130_off
    is_cclass $I11, 8192, rx1130_tgt, $I10
    if $I11, rx1130_fail
    dec $I10
    is_cclass $I11, 8192, rx1130_tgt, $I10
    unless $I11, rx1130_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1130_pos, rx1130_off
    substr $S10, rx1130_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1130_fail
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."quote_EXPR"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1130_pos = $P10."pos"()
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "quote:sym<Q>")
    if_null rx1130_debug, debug_853
    rx1130_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1130_pos)
  debug_853:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 4
    if_null rx1130_debug, debug_854
    rx1130_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_854:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_855
    rx1130_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_855:
    .return (rx1130_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("242_1298845521.609") :method
.annotate 'line', 4
    $P1132 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1133, "ResizablePMCArray"
    push $P1133, $P1132
    .return ($P1133)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("243_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1136_tgt
    .local int rx1136_pos
    .local int rx1136_off
    .local int rx1136_eos
    .local int rx1136_rep
    .local pmc rx1136_cur
    .local pmc rx1136_debug
    (rx1136_cur, rx1136_pos, rx1136_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1136_cur
    .local pmc match
    .lex "$/", match
    length rx1136_eos, rx1136_tgt
    gt rx1136_pos, rx1136_eos, rx1136_done
    set rx1136_off, 0
    lt rx1136_pos, 2, rx1136_start
    sub rx1136_off, rx1136_pos, 1
    substr rx1136_tgt, rx1136_tgt, rx1136_off
  rx1136_start:
    eq $I10, 1, rx1136_restart
    if_null rx1136_debug, debug_856
    rx1136_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1140_done
    goto rxscan1140_scan
  rxscan1140_loop:
    (rx1136_pos) = rx1136_cur."from"()
    inc rx1136_pos
    rx1136_cur."!cursor_from"(rx1136_pos)
    ge rx1136_pos, rx1136_eos, rxscan1140_done
  rxscan1140_scan:
    set_addr $I10, rxscan1140_loop
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxscan1140_done:
.annotate 'line', 519
  # rx literal  "Q:PIR"
    add $I11, rx1136_pos, 5
    gt $I11, rx1136_eos, rx1136_fail
    sub $I11, rx1136_pos, rx1136_off
    substr $S10, rx1136_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1136_fail
    add rx1136_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."quote_EXPR"()
    unless $P10, rx1136_fail
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1136_pos = $P10."pos"()
  # rx pass
    rx1136_cur."!cursor_pass"(rx1136_pos, "quote:sym<Q:PIR>")
    if_null rx1136_debug, debug_857
    rx1136_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1136_pos)
  debug_857:
    .return (rx1136_cur)
  rx1136_restart:
.annotate 'line', 4
    if_null rx1136_debug, debug_858
    rx1136_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_858:
  rx1136_fail:
    (rx1136_rep, rx1136_pos, $I10, $P10) = rx1136_cur."!mark_fail"(0)
    lt rx1136_pos, -1, rx1136_done
    eq rx1136_pos, -1, rx1136_fail
    jump $I10
  rx1136_done:
    rx1136_cur."!cursor_fail"()
    if_null rx1136_debug, debug_859
    rx1136_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_859:
    .return (rx1136_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("244_1298845521.609") :method
.annotate 'line', 4
    $P1138 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1139, "ResizablePMCArray"
    push $P1139, $P1138
    .return ($P1139)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("245_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1142_tgt
    .local int rx1142_pos
    .local int rx1142_off
    .local int rx1142_eos
    .local int rx1142_rep
    .local pmc rx1142_cur
    .local pmc rx1142_debug
    (rx1142_cur, rx1142_pos, rx1142_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1142_cur
    .local pmc match
    .lex "$/", match
    length rx1142_eos, rx1142_tgt
    gt rx1142_pos, rx1142_eos, rx1142_done
    set rx1142_off, 0
    lt rx1142_pos, 2, rx1142_start
    sub rx1142_off, rx1142_pos, 1
    substr rx1142_tgt, rx1142_tgt, rx1142_off
  rx1142_start:
    eq $I10, 1, rx1142_restart
    if_null rx1142_debug, debug_860
    rx1142_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1146_done
    goto rxscan1146_scan
  rxscan1146_loop:
    (rx1142_pos) = rx1142_cur."from"()
    inc rx1142_pos
    rx1142_cur."!cursor_from"(rx1142_pos)
    ge rx1142_pos, rx1142_eos, rxscan1146_done
  rxscan1146_scan:
    set_addr $I10, rxscan1146_loop
    rx1142_cur."!mark_push"(0, rx1142_pos, $I10)
  rxscan1146_done:
.annotate 'line', 521
  # rx literal  "/"
    add $I11, rx1142_pos, 1
    gt $I11, rx1142_eos, rx1142_fail
    sub $I11, rx1142_pos, rx1142_off
    ord $I11, rx1142_tgt, $I11
    ne $I11, 47, rx1142_fail
    add rx1142_pos, 1
.annotate 'line', 522
  # rx subrule "newpad" subtype=method negate=
    rx1142_cur."!cursor_pos"(rx1142_pos)
    $P10 = rx1142_cur."newpad"()
    unless $P10, rx1142_fail
    rx1142_pos = $P10."pos"()
.annotate 'line', 523
  # rx reduce name="quote:sym</ />" key="open"
    rx1142_cur."!cursor_pos"(rx1142_pos)
    rx1142_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 524
  # rx subrule "LANG" subtype=capture negate=
    rx1142_cur."!cursor_pos"(rx1142_pos)
    $P10 = rx1142_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1142_fail
    rx1142_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1142_pos = $P10."pos"()
.annotate 'line', 525
  # rx literal  "/"
    add $I11, rx1142_pos, 1
    gt $I11, rx1142_eos, rx1142_fail
    sub $I11, rx1142_pos, rx1142_off
    ord $I11, rx1142_tgt, $I11
    ne $I11, 47, rx1142_fail
    add rx1142_pos, 1
.annotate 'line', 520
  # rx pass
    rx1142_cur."!cursor_pass"(rx1142_pos, "quote:sym</ />")
    if_null rx1142_debug, debug_861
    rx1142_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1142_pos)
  debug_861:
    .return (rx1142_cur)
  rx1142_restart:
.annotate 'line', 4
    if_null rx1142_debug, debug_862
    rx1142_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_862:
  rx1142_fail:
    (rx1142_rep, rx1142_pos, $I10, $P10) = rx1142_cur."!mark_fail"(0)
    lt rx1142_pos, -1, rx1142_done
    eq rx1142_pos, -1, rx1142_fail
    jump $I10
  rx1142_done:
    rx1142_cur."!cursor_fail"()
    if_null rx1142_debug, debug_863
    rx1142_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_863:
    .return (rx1142_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("246_1298845521.609") :method
.annotate 'line', 4
    $P1144 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1145, "ResizablePMCArray"
    push $P1145, $P1144
    .return ($P1145)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("247_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1148_tgt
    .local int rx1148_pos
    .local int rx1148_off
    .local int rx1148_eos
    .local int rx1148_rep
    .local pmc rx1148_cur
    .local pmc rx1148_debug
    (rx1148_cur, rx1148_pos, rx1148_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1148_cur
    .local pmc match
    .lex "$/", match
    length rx1148_eos, rx1148_tgt
    gt rx1148_pos, rx1148_eos, rx1148_done
    set rx1148_off, 0
    lt rx1148_pos, 2, rx1148_start
    sub rx1148_off, rx1148_pos, 1
    substr rx1148_tgt, rx1148_tgt, rx1148_off
  rx1148_start:
    eq $I10, 1, rx1148_restart
    if_null rx1148_debug, debug_864
    rx1148_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1151_done
    goto rxscan1151_scan
  rxscan1151_loop:
    (rx1148_pos) = rx1148_cur."from"()
    inc rx1148_pos
    rx1148_cur."!cursor_from"(rx1148_pos)
    ge rx1148_pos, rx1148_eos, rxscan1151_done
  rxscan1151_scan:
    set_addr $I10, rxscan1151_loop
    rx1148_cur."!mark_push"(0, rx1148_pos, $I10)
  rxscan1151_done:
.annotate 'line', 528
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1148_pos, rx1148_off
    substr $S10, rx1148_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1148_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1148_cur."!cursor_pos"(rx1148_pos)
    $P10 = rx1148_cur."quotemod_check"("s")
    unless $P10, rx1148_fail
  # rx subrule "variable" subtype=capture negate=
    rx1148_cur."!cursor_pos"(rx1148_pos)
    $P10 = rx1148_cur."variable"()
    unless $P10, rx1148_fail
    rx1148_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1148_pos = $P10."pos"()
  # rx pass
    rx1148_cur."!cursor_pass"(rx1148_pos, "quote_escape:sym<$>")
    if_null rx1148_debug, debug_865
    rx1148_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1148_pos)
  debug_865:
    .return (rx1148_cur)
  rx1148_restart:
.annotate 'line', 4
    if_null rx1148_debug, debug_866
    rx1148_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_866:
  rx1148_fail:
    (rx1148_rep, rx1148_pos, $I10, $P10) = rx1148_cur."!mark_fail"(0)
    lt rx1148_pos, -1, rx1148_done
    eq rx1148_pos, -1, rx1148_fail
    jump $I10
  rx1148_done:
    rx1148_cur."!cursor_fail"()
    if_null rx1148_debug, debug_867
    rx1148_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_867:
    .return (rx1148_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("248_1298845521.609") :method
.annotate 'line', 4
    new $P1150, "ResizablePMCArray"
    push $P1150, "$"
    .return ($P1150)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("249_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1153_tgt
    .local int rx1153_pos
    .local int rx1153_off
    .local int rx1153_eos
    .local int rx1153_rep
    .local pmc rx1153_cur
    .local pmc rx1153_debug
    (rx1153_cur, rx1153_pos, rx1153_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1153_cur
    .local pmc match
    .lex "$/", match
    length rx1153_eos, rx1153_tgt
    gt rx1153_pos, rx1153_eos, rx1153_done
    set rx1153_off, 0
    lt rx1153_pos, 2, rx1153_start
    sub rx1153_off, rx1153_pos, 1
    substr rx1153_tgt, rx1153_tgt, rx1153_off
  rx1153_start:
    eq $I10, 1, rx1153_restart
    if_null rx1153_debug, debug_868
    rx1153_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1156_done
    goto rxscan1156_scan
  rxscan1156_loop:
    (rx1153_pos) = rx1153_cur."from"()
    inc rx1153_pos
    rx1153_cur."!cursor_from"(rx1153_pos)
    ge rx1153_pos, rx1153_eos, rxscan1156_done
  rxscan1156_scan:
    set_addr $I10, rxscan1156_loop
    rx1153_cur."!mark_push"(0, rx1153_pos, $I10)
  rxscan1156_done:
.annotate 'line', 529
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1153_pos, rx1153_off
    substr $S10, rx1153_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1153_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."quotemod_check"("c")
    unless $P10, rx1153_fail
  # rx subrule "block" subtype=capture negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."block"()
    unless $P10, rx1153_fail
    rx1153_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1153_pos = $P10."pos"()
  # rx pass
    rx1153_cur."!cursor_pass"(rx1153_pos, "quote_escape:sym<{ }>")
    if_null rx1153_debug, debug_869
    rx1153_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1153_pos)
  debug_869:
    .return (rx1153_cur)
  rx1153_restart:
.annotate 'line', 4
    if_null rx1153_debug, debug_870
    rx1153_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_870:
  rx1153_fail:
    (rx1153_rep, rx1153_pos, $I10, $P10) = rx1153_cur."!mark_fail"(0)
    lt rx1153_pos, -1, rx1153_done
    eq rx1153_pos, -1, rx1153_fail
    jump $I10
  rx1153_done:
    rx1153_cur."!cursor_fail"()
    if_null rx1153_debug, debug_871
    rx1153_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_871:
    .return (rx1153_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("250_1298845521.609") :method
.annotate 'line', 4
    new $P1155, "ResizablePMCArray"
    push $P1155, "{"
    .return ($P1155)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("251_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1158_tgt
    .local int rx1158_pos
    .local int rx1158_off
    .local int rx1158_eos
    .local int rx1158_rep
    .local pmc rx1158_cur
    .local pmc rx1158_debug
    (rx1158_cur, rx1158_pos, rx1158_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1158_cur
    .local pmc match
    .lex "$/", match
    length rx1158_eos, rx1158_tgt
    gt rx1158_pos, rx1158_eos, rx1158_done
    set rx1158_off, 0
    lt rx1158_pos, 2, rx1158_start
    sub rx1158_off, rx1158_pos, 1
    substr rx1158_tgt, rx1158_tgt, rx1158_off
  rx1158_start:
    eq $I10, 1, rx1158_restart
    if_null rx1158_debug, debug_872
    rx1158_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1161_done
    goto rxscan1161_scan
  rxscan1161_loop:
    (rx1158_pos) = rx1158_cur."from"()
    inc rx1158_pos
    rx1158_cur."!cursor_from"(rx1158_pos)
    ge rx1158_pos, rx1158_eos, rxscan1161_done
  rxscan1161_scan:
    set_addr $I10, rxscan1161_loop
    rx1158_cur."!mark_push"(0, rx1158_pos, $I10)
  rxscan1161_done:
.annotate 'line', 530
  # rx literal  "\\e"
    add $I11, rx1158_pos, 2
    gt $I11, rx1158_eos, rx1158_fail
    sub $I11, rx1158_pos, rx1158_off
    substr $S10, rx1158_tgt, $I11, 2
    ne $S10, "\\e", rx1158_fail
    add rx1158_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1158_cur."!cursor_pos"(rx1158_pos)
    $P10 = rx1158_cur."quotemod_check"("b")
    unless $P10, rx1158_fail
  # rx pass
    rx1158_cur."!cursor_pass"(rx1158_pos, "quote_escape:sym<esc>")
    if_null rx1158_debug, debug_873
    rx1158_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1158_pos)
  debug_873:
    .return (rx1158_cur)
  rx1158_restart:
.annotate 'line', 4
    if_null rx1158_debug, debug_874
    rx1158_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_874:
  rx1158_fail:
    (rx1158_rep, rx1158_pos, $I10, $P10) = rx1158_cur."!mark_fail"(0)
    lt rx1158_pos, -1, rx1158_done
    eq rx1158_pos, -1, rx1158_fail
    jump $I10
  rx1158_done:
    rx1158_cur."!cursor_fail"()
    if_null rx1158_debug, debug_875
    rx1158_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_875:
    .return (rx1158_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("252_1298845521.609") :method
.annotate 'line', 4
    new $P1160, "ResizablePMCArray"
    push $P1160, "\\e"
    .return ($P1160)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("253_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1163_tgt
    .local int rx1163_pos
    .local int rx1163_off
    .local int rx1163_eos
    .local int rx1163_rep
    .local pmc rx1163_cur
    .local pmc rx1163_debug
    (rx1163_cur, rx1163_pos, rx1163_tgt, $I10) = self."!cursor_start"()
    rx1163_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1163_cur
    .local pmc match
    .lex "$/", match
    length rx1163_eos, rx1163_tgt
    gt rx1163_pos, rx1163_eos, rx1163_done
    set rx1163_off, 0
    lt rx1163_pos, 2, rx1163_start
    sub rx1163_off, rx1163_pos, 1
    substr rx1163_tgt, rx1163_tgt, rx1163_off
  rx1163_start:
    eq $I10, 1, rx1163_restart
    if_null rx1163_debug, debug_876
    rx1163_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1167_done
    goto rxscan1167_scan
  rxscan1167_loop:
    (rx1163_pos) = rx1163_cur."from"()
    inc rx1163_pos
    rx1163_cur."!cursor_from"(rx1163_pos)
    ge rx1163_pos, rx1163_eos, rxscan1167_done
  rxscan1167_scan:
    set_addr $I10, rxscan1167_loop
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10)
  rxscan1167_done:
.annotate 'line', 532
  # rx literal  "("
    add $I11, rx1163_pos, 1
    gt $I11, rx1163_eos, rx1163_fail
    sub $I11, rx1163_pos, rx1163_off
    ord $I11, rx1163_tgt, $I11
    ne $I11, 40, rx1163_fail
    add rx1163_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1163_cur."!cursor_pos"(rx1163_pos)
    $P10 = rx1163_cur."ws"()
    unless $P10, rx1163_fail
    rx1163_pos = $P10."pos"()
  # rx rxquantr1168 ** 0..1
    set_addr $I10, rxquantr1168_done
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10)
  rxquantr1168_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1163_cur."!cursor_pos"(rx1163_pos)
    $P10 = rx1163_cur."EXPR"()
    unless $P10, rx1163_fail
    goto rxsubrule1169_pass
  rxsubrule1169_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1163_fail
  rxsubrule1169_pass:
    set_addr $I10, rxsubrule1169_back
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1163_pos = $P10."pos"()
    set_addr $I10, rxquantr1168_done
    (rx1163_rep) = rx1163_cur."!mark_commit"($I10)
  rxquantr1168_done:
  # rx literal  ")"
    add $I11, rx1163_pos, 1
    gt $I11, rx1163_eos, rx1163_fail
    sub $I11, rx1163_pos, rx1163_off
    ord $I11, rx1163_tgt, $I11
    ne $I11, 41, rx1163_fail
    add rx1163_pos, 1
  # rx pass
    rx1163_cur."!cursor_pass"(rx1163_pos, "circumfix:sym<( )>")
    if_null rx1163_debug, debug_877
    rx1163_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1163_pos)
  debug_877:
    .return (rx1163_cur)
  rx1163_restart:
.annotate 'line', 4
    if_null rx1163_debug, debug_878
    rx1163_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_878:
  rx1163_fail:
    (rx1163_rep, rx1163_pos, $I10, $P10) = rx1163_cur."!mark_fail"(0)
    lt rx1163_pos, -1, rx1163_done
    eq rx1163_pos, -1, rx1163_fail
    jump $I10
  rx1163_done:
    rx1163_cur."!cursor_fail"()
    if_null rx1163_debug, debug_879
    rx1163_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_879:
    .return (rx1163_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("254_1298845521.609") :method
.annotate 'line', 4
    $P1165 = self."!PREFIX__!subrule"("ws", "(")
    new $P1166, "ResizablePMCArray"
    push $P1166, $P1165
    .return ($P1166)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("255_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1171_tgt
    .local int rx1171_pos
    .local int rx1171_off
    .local int rx1171_eos
    .local int rx1171_rep
    .local pmc rx1171_cur
    .local pmc rx1171_debug
    (rx1171_cur, rx1171_pos, rx1171_tgt, $I10) = self."!cursor_start"()
    rx1171_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1171_cur
    .local pmc match
    .lex "$/", match
    length rx1171_eos, rx1171_tgt
    gt rx1171_pos, rx1171_eos, rx1171_done
    set rx1171_off, 0
    lt rx1171_pos, 2, rx1171_start
    sub rx1171_off, rx1171_pos, 1
    substr rx1171_tgt, rx1171_tgt, rx1171_off
  rx1171_start:
    eq $I10, 1, rx1171_restart
    if_null rx1171_debug, debug_880
    rx1171_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1175_done
    goto rxscan1175_scan
  rxscan1175_loop:
    (rx1171_pos) = rx1171_cur."from"()
    inc rx1171_pos
    rx1171_cur."!cursor_from"(rx1171_pos)
    ge rx1171_pos, rx1171_eos, rxscan1175_done
  rxscan1175_scan:
    set_addr $I10, rxscan1175_loop
    rx1171_cur."!mark_push"(0, rx1171_pos, $I10)
  rxscan1175_done:
.annotate 'line', 533
  # rx literal  "["
    add $I11, rx1171_pos, 1
    gt $I11, rx1171_eos, rx1171_fail
    sub $I11, rx1171_pos, rx1171_off
    ord $I11, rx1171_tgt, $I11
    ne $I11, 91, rx1171_fail
    add rx1171_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1171_cur."!cursor_pos"(rx1171_pos)
    $P10 = rx1171_cur."ws"()
    unless $P10, rx1171_fail
    rx1171_pos = $P10."pos"()
  # rx rxquantr1176 ** 0..1
    set_addr $I10, rxquantr1176_done
    rx1171_cur."!mark_push"(0, rx1171_pos, $I10)
  rxquantr1176_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1171_cur."!cursor_pos"(rx1171_pos)
    $P10 = rx1171_cur."EXPR"()
    unless $P10, rx1171_fail
    goto rxsubrule1177_pass
  rxsubrule1177_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1171_fail
  rxsubrule1177_pass:
    set_addr $I10, rxsubrule1177_back
    rx1171_cur."!mark_push"(0, rx1171_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1171_pos = $P10."pos"()
    set_addr $I10, rxquantr1176_done
    (rx1171_rep) = rx1171_cur."!mark_commit"($I10)
  rxquantr1176_done:
  # rx literal  "]"
    add $I11, rx1171_pos, 1
    gt $I11, rx1171_eos, rx1171_fail
    sub $I11, rx1171_pos, rx1171_off
    ord $I11, rx1171_tgt, $I11
    ne $I11, 93, rx1171_fail
    add rx1171_pos, 1
  # rx pass
    rx1171_cur."!cursor_pass"(rx1171_pos, "circumfix:sym<[ ]>")
    if_null rx1171_debug, debug_881
    rx1171_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1171_pos)
  debug_881:
    .return (rx1171_cur)
  rx1171_restart:
.annotate 'line', 4
    if_null rx1171_debug, debug_882
    rx1171_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_882:
  rx1171_fail:
    (rx1171_rep, rx1171_pos, $I10, $P10) = rx1171_cur."!mark_fail"(0)
    lt rx1171_pos, -1, rx1171_done
    eq rx1171_pos, -1, rx1171_fail
    jump $I10
  rx1171_done:
    rx1171_cur."!cursor_fail"()
    if_null rx1171_debug, debug_883
    rx1171_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_883:
    .return (rx1171_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("256_1298845521.609") :method
.annotate 'line', 4
    $P1173 = self."!PREFIX__!subrule"("ws", "[")
    new $P1174, "ResizablePMCArray"
    push $P1174, $P1173
    .return ($P1174)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("257_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1179_tgt
    .local int rx1179_pos
    .local int rx1179_off
    .local int rx1179_eos
    .local int rx1179_rep
    .local pmc rx1179_cur
    .local pmc rx1179_debug
    (rx1179_cur, rx1179_pos, rx1179_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1179_cur
    .local pmc match
    .lex "$/", match
    length rx1179_eos, rx1179_tgt
    gt rx1179_pos, rx1179_eos, rx1179_done
    set rx1179_off, 0
    lt rx1179_pos, 2, rx1179_start
    sub rx1179_off, rx1179_pos, 1
    substr rx1179_tgt, rx1179_tgt, rx1179_off
  rx1179_start:
    eq $I10, 1, rx1179_restart
    if_null rx1179_debug, debug_884
    rx1179_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1182_done
    goto rxscan1182_scan
  rxscan1182_loop:
    (rx1179_pos) = rx1179_cur."from"()
    inc rx1179_pos
    rx1179_cur."!cursor_from"(rx1179_pos)
    ge rx1179_pos, rx1179_eos, rxscan1182_done
  rxscan1182_scan:
    set_addr $I10, rxscan1182_loop
    rx1179_cur."!mark_push"(0, rx1179_pos, $I10)
  rxscan1182_done:
.annotate 'line', 534
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1179_pos, rx1179_off
    substr $S10, rx1179_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1179_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1179_cur."!cursor_pos"(rx1179_pos)
    $P10 = rx1179_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1179_fail
    rx1179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1179_pos = $P10."pos"()
  # rx pass
    rx1179_cur."!cursor_pass"(rx1179_pos, "circumfix:sym<ang>")
    if_null rx1179_debug, debug_885
    rx1179_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1179_pos)
  debug_885:
    .return (rx1179_cur)
  rx1179_restart:
.annotate 'line', 4
    if_null rx1179_debug, debug_886
    rx1179_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_886:
  rx1179_fail:
    (rx1179_rep, rx1179_pos, $I10, $P10) = rx1179_cur."!mark_fail"(0)
    lt rx1179_pos, -1, rx1179_done
    eq rx1179_pos, -1, rx1179_fail
    jump $I10
  rx1179_done:
    rx1179_cur."!cursor_fail"()
    if_null rx1179_debug, debug_887
    rx1179_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_887:
    .return (rx1179_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("258_1298845521.609") :method
.annotate 'line', 4
    new $P1181, "ResizablePMCArray"
    push $P1181, "<"
    .return ($P1181)
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("259_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1184_tgt
    .local int rx1184_pos
    .local int rx1184_off
    .local int rx1184_eos
    .local int rx1184_rep
    .local pmc rx1184_cur
    .local pmc rx1184_debug
    (rx1184_cur, rx1184_pos, rx1184_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1184_cur
    .local pmc match
    .lex "$/", match
    length rx1184_eos, rx1184_tgt
    gt rx1184_pos, rx1184_eos, rx1184_done
    set rx1184_off, 0
    lt rx1184_pos, 2, rx1184_start
    sub rx1184_off, rx1184_pos, 1
    substr rx1184_tgt, rx1184_tgt, rx1184_off
  rx1184_start:
    eq $I10, 1, rx1184_restart
    if_null rx1184_debug, debug_888
    rx1184_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1187_done
    goto rxscan1187_scan
  rxscan1187_loop:
    (rx1184_pos) = rx1184_cur."from"()
    inc rx1184_pos
    rx1184_cur."!cursor_from"(rx1184_pos)
    ge rx1184_pos, rx1184_eos, rxscan1187_done
  rxscan1187_scan:
    set_addr $I10, rxscan1187_loop
    rx1184_cur."!mark_push"(0, rx1184_pos, $I10)
  rxscan1187_done:
.annotate 'line', 535
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1184_pos, rx1184_off
    substr $S10, rx1184_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1184_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1184_cur."!cursor_pos"(rx1184_pos)
    $P10 = rx1184_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1184_fail
    rx1184_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1184_pos = $P10."pos"()
  # rx pass
    rx1184_cur."!cursor_pass"(rx1184_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1184_debug, debug_889
    rx1184_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1184_pos)
  debug_889:
    .return (rx1184_cur)
  rx1184_restart:
.annotate 'line', 4
    if_null rx1184_debug, debug_890
    rx1184_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_890:
  rx1184_fail:
    (rx1184_rep, rx1184_pos, $I10, $P10) = rx1184_cur."!mark_fail"(0)
    lt rx1184_pos, -1, rx1184_done
    eq rx1184_pos, -1, rx1184_fail
    jump $I10
  rx1184_done:
    rx1184_cur."!cursor_fail"()
    if_null rx1184_debug, debug_891
    rx1184_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_891:
    .return (rx1184_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("260_1298845521.609") :method
.annotate 'line', 4
    new $P1186, "ResizablePMCArray"
    push $P1186, unicode:"\x{ab}"
    .return ($P1186)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("261_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1189_tgt
    .local int rx1189_pos
    .local int rx1189_off
    .local int rx1189_eos
    .local int rx1189_rep
    .local pmc rx1189_cur
    .local pmc rx1189_debug
    (rx1189_cur, rx1189_pos, rx1189_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1189_cur
    .local pmc match
    .lex "$/", match
    length rx1189_eos, rx1189_tgt
    gt rx1189_pos, rx1189_eos, rx1189_done
    set rx1189_off, 0
    lt rx1189_pos, 2, rx1189_start
    sub rx1189_off, rx1189_pos, 1
    substr rx1189_tgt, rx1189_tgt, rx1189_off
  rx1189_start:
    eq $I10, 1, rx1189_restart
    if_null rx1189_debug, debug_892
    rx1189_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1192_done
    goto rxscan1192_scan
  rxscan1192_loop:
    (rx1189_pos) = rx1189_cur."from"()
    inc rx1189_pos
    rx1189_cur."!cursor_from"(rx1189_pos)
    ge rx1189_pos, rx1189_eos, rxscan1192_done
  rxscan1192_scan:
    set_addr $I10, rxscan1192_loop
    rx1189_cur."!mark_push"(0, rx1189_pos, $I10)
  rxscan1192_done:
.annotate 'line', 536
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1189_pos, rx1189_off
    substr $S10, rx1189_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1189_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1189_cur."!cursor_pos"(rx1189_pos)
    $P10 = rx1189_cur."pblock"()
    unless $P10, rx1189_fail
    rx1189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1189_pos = $P10."pos"()
  # rx pass
    rx1189_cur."!cursor_pass"(rx1189_pos, "circumfix:sym<{ }>")
    if_null rx1189_debug, debug_893
    rx1189_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1189_pos)
  debug_893:
    .return (rx1189_cur)
  rx1189_restart:
.annotate 'line', 4
    if_null rx1189_debug, debug_894
    rx1189_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_894:
  rx1189_fail:
    (rx1189_rep, rx1189_pos, $I10, $P10) = rx1189_cur."!mark_fail"(0)
    lt rx1189_pos, -1, rx1189_done
    eq rx1189_pos, -1, rx1189_fail
    jump $I10
  rx1189_done:
    rx1189_cur."!cursor_fail"()
    if_null rx1189_debug, debug_895
    rx1189_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_895:
    .return (rx1189_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("262_1298845521.609") :method
.annotate 'line', 4
    new $P1191, "ResizablePMCArray"
    push $P1191, "{"
    .return ($P1191)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("263_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1194_tgt
    .local int rx1194_pos
    .local int rx1194_off
    .local int rx1194_eos
    .local int rx1194_rep
    .local pmc rx1194_cur
    .local pmc rx1194_debug
    (rx1194_cur, rx1194_pos, rx1194_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1194_cur
    .local pmc match
    .lex "$/", match
    length rx1194_eos, rx1194_tgt
    gt rx1194_pos, rx1194_eos, rx1194_done
    set rx1194_off, 0
    lt rx1194_pos, 2, rx1194_start
    sub rx1194_off, rx1194_pos, 1
    substr rx1194_tgt, rx1194_tgt, rx1194_off
  rx1194_start:
    eq $I10, 1, rx1194_restart
    if_null rx1194_debug, debug_896
    rx1194_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1198_done
    goto rxscan1198_scan
  rxscan1198_loop:
    (rx1194_pos) = rx1194_cur."from"()
    inc rx1194_pos
    rx1194_cur."!cursor_from"(rx1194_pos)
    ge rx1194_pos, rx1194_eos, rxscan1198_done
  rxscan1198_scan:
    set_addr $I10, rxscan1198_loop
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  rxscan1198_done:
.annotate 'line', 537
  # rx subrule "sigil" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."sigil"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1194_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1194_pos, 1
    gt $I11, rx1194_eos, rx1194_fail
    sub $I11, rx1194_pos, rx1194_off
    ord $I11, rx1194_tgt, $I11
    ne $I11, 40, rx1194_fail
    add rx1194_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."semilist"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1194_pos = $P10."pos"()
  alt1199_0:
    set_addr $I10, alt1199_1
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx literal  ")"
    add $I11, rx1194_pos, 1
    gt $I11, rx1194_eos, rx1194_fail
    sub $I11, rx1194_pos, rx1194_off
    ord $I11, rx1194_tgt, $I11
    ne $I11, 41, rx1194_fail
    add rx1194_pos, 1
    goto alt1199_end
  alt1199_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."FAILGOAL"("')'")
    unless $P10, rx1194_fail
    goto rxsubrule1201_pass
  rxsubrule1201_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1194_fail
  rxsubrule1201_pass:
    set_addr $I10, rxsubrule1201_back
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10, $P10)
    rx1194_pos = $P10."pos"()
  alt1199_end:
  # rx pass
    rx1194_cur."!cursor_pass"(rx1194_pos, "circumfix:sym<sigil>")
    if_null rx1194_debug, debug_897
    rx1194_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1194_pos)
  debug_897:
    .return (rx1194_cur)
  rx1194_restart:
.annotate 'line', 4
    if_null rx1194_debug, debug_898
    rx1194_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_898:
  rx1194_fail:
    (rx1194_rep, rx1194_pos, $I10, $P10) = rx1194_cur."!mark_fail"(0)
    lt rx1194_pos, -1, rx1194_done
    eq rx1194_pos, -1, rx1194_fail
    jump $I10
  rx1194_done:
    rx1194_cur."!cursor_fail"()
    if_null rx1194_debug, debug_899
    rx1194_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_899:
    .return (rx1194_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("264_1298845521.609") :method
.annotate 'line', 4
    $P1196 = self."!PREFIX__!subrule"("sigil", "")
    new $P1197, "ResizablePMCArray"
    push $P1197, $P1196
    .return ($P1197)
.end


.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("265_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1203_tgt
    .local int rx1203_pos
    .local int rx1203_off
    .local int rx1203_eos
    .local int rx1203_rep
    .local pmc rx1203_cur
    .local pmc rx1203_debug
    (rx1203_cur, rx1203_pos, rx1203_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1203_cur
    .local pmc match
    .lex "$/", match
    length rx1203_eos, rx1203_tgt
    gt rx1203_pos, rx1203_eos, rx1203_done
    set rx1203_off, 0
    lt rx1203_pos, 2, rx1203_start
    sub rx1203_off, rx1203_pos, 1
    substr rx1203_tgt, rx1203_tgt, rx1203_off
  rx1203_start:
    eq $I10, 1, rx1203_restart
    if_null rx1203_debug, debug_900
    rx1203_cur."!cursor_debug"("START", "semilist")
  debug_900:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    (rx1203_pos) = rx1203_cur."from"()
    inc rx1203_pos
    rx1203_cur."!cursor_from"(rx1203_pos)
    ge rx1203_pos, rx1203_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  rxscan1207_done:
.annotate 'line', 539
  # rx subrule "ws" subtype=method negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."ws"()
    unless $P10, rx1203_fail
    rx1203_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."statement"()
    unless $P10, rx1203_fail
    rx1203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1203_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."ws"()
    unless $P10, rx1203_fail
    rx1203_pos = $P10."pos"()
  # rx pass
    rx1203_cur."!cursor_pass"(rx1203_pos, "semilist")
    if_null rx1203_debug, debug_901
    rx1203_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1203_pos)
  debug_901:
    .return (rx1203_cur)
  rx1203_restart:
.annotate 'line', 4
    if_null rx1203_debug, debug_902
    rx1203_cur."!cursor_debug"("NEXT", "semilist")
  debug_902:
  rx1203_fail:
    (rx1203_rep, rx1203_pos, $I10, $P10) = rx1203_cur."!mark_fail"(0)
    lt rx1203_pos, -1, rx1203_done
    eq rx1203_pos, -1, rx1203_fail
    jump $I10
  rx1203_done:
    rx1203_cur."!cursor_fail"()
    if_null rx1203_debug, debug_903
    rx1203_cur."!cursor_debug"("FAIL", "semilist")
  debug_903:
    .return (rx1203_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("266_1298845521.609") :method
.annotate 'line', 4
    $P1205 = self."!PREFIX__!subrule"("ws", "")
    new $P1206, "ResizablePMCArray"
    push $P1206, $P1205
    .return ($P1206)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1210"  :anon :subid("267_1298845521.609") :outer("11_1298845521.609")
.annotate 'line', 4
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post904") :outer("267_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P1211 = "267_1298845521.609" 
    .local pmc block
    set block, $P1211
.annotate 'line', 544
    get_hll_global $P1212, ["NQP"], "Grammar"
    $P1212."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 545
    get_hll_global $P1213, ["NQP"], "Grammar"
    $P1213."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 546
    get_hll_global $P1214, ["NQP"], "Grammar"
    $P1214."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 547
    get_hll_global $P1215, ["NQP"], "Grammar"
    $P1215."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 548
    get_hll_global $P1216, ["NQP"], "Grammar"
    $P1216."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 549
    get_hll_global $P1217, ["NQP"], "Grammar"
    $P1217."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 550
    get_hll_global $P1218, ["NQP"], "Grammar"
    $P1218."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 551
    get_hll_global $P1219, ["NQP"], "Grammar"
    $P1219."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 552
    get_hll_global $P1220, ["NQP"], "Grammar"
    $P1220."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 553
    get_hll_global $P1221, ["NQP"], "Grammar"
    $P1221."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 554
    get_hll_global $P1222, ["NQP"], "Grammar"
    $P1222."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 555
    get_hll_global $P1223, ["NQP"], "Grammar"
    $P1223."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 556
    get_hll_global $P1224, ["NQP"], "Grammar"
    $P1224."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 557
    get_hll_global $P1225, ["NQP"], "Grammar"
    $P1225."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 558
    get_hll_global $P1226, ["NQP"], "Grammar"
    $P1226."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("268_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1228_tgt
    .local int rx1228_pos
    .local int rx1228_off
    .local int rx1228_eos
    .local int rx1228_rep
    .local pmc rx1228_cur
    .local pmc rx1228_debug
    (rx1228_cur, rx1228_pos, rx1228_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1228_cur
    .local pmc match
    .lex "$/", match
    length rx1228_eos, rx1228_tgt
    gt rx1228_pos, rx1228_eos, rx1228_done
    set rx1228_off, 0
    lt rx1228_pos, 2, rx1228_start
    sub rx1228_off, rx1228_pos, 1
    substr rx1228_tgt, rx1228_tgt, rx1228_off
  rx1228_start:
    eq $I10, 1, rx1228_restart
    if_null rx1228_debug, debug_905
    rx1228_cur."!cursor_debug"("START", "infixish")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1231_done
    goto rxscan1231_scan
  rxscan1231_loop:
    (rx1228_pos) = rx1228_cur."from"()
    inc rx1228_pos
    rx1228_cur."!cursor_from"(rx1228_pos)
    ge rx1228_pos, rx1228_eos, rxscan1231_done
  rxscan1231_scan:
    set_addr $I10, rxscan1231_loop
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
  rxscan1231_done:
.annotate 'line', 562
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."infixstopper"()
    if $P10, rx1228_fail
  # rx subrule "infix" subtype=capture negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."infix"()
    unless $P10, rx1228_fail
    rx1228_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1228_pos = $P10."pos"()
  # rx pass
    rx1228_cur."!cursor_pass"(rx1228_pos, "infixish")
    if_null rx1228_debug, debug_906
    rx1228_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1228_pos)
  debug_906:
    .return (rx1228_cur)
  rx1228_restart:
.annotate 'line', 4
    if_null rx1228_debug, debug_907
    rx1228_cur."!cursor_debug"("NEXT", "infixish")
  debug_907:
  rx1228_fail:
    (rx1228_rep, rx1228_pos, $I10, $P10) = rx1228_cur."!mark_fail"(0)
    lt rx1228_pos, -1, rx1228_done
    eq rx1228_pos, -1, rx1228_fail
    jump $I10
  rx1228_done:
    rx1228_cur."!cursor_fail"()
    if_null rx1228_debug, debug_908
    rx1228_cur."!cursor_debug"("FAIL", "infixish")
  debug_908:
    .return (rx1228_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("269_1298845521.609") :method
.annotate 'line', 4
    new $P1230, "ResizablePMCArray"
    push $P1230, ""
    .return ($P1230)
.end


.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("270_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1233_tgt
    .local int rx1233_pos
    .local int rx1233_off
    .local int rx1233_eos
    .local int rx1233_rep
    .local pmc rx1233_cur
    .local pmc rx1233_debug
    (rx1233_cur, rx1233_pos, rx1233_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1233_cur
    .local pmc match
    .lex "$/", match
    length rx1233_eos, rx1233_tgt
    gt rx1233_pos, rx1233_eos, rx1233_done
    set rx1233_off, 0
    lt rx1233_pos, 2, rx1233_start
    sub rx1233_off, rx1233_pos, 1
    substr rx1233_tgt, rx1233_tgt, rx1233_off
  rx1233_start:
    eq $I10, 1, rx1233_restart
    if_null rx1233_debug, debug_909
    rx1233_cur."!cursor_debug"("START", "infixstopper")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1236_done
    goto rxscan1236_scan
  rxscan1236_loop:
    (rx1233_pos) = rx1233_cur."from"()
    inc rx1233_pos
    rx1233_cur."!cursor_from"(rx1233_pos)
    ge rx1233_pos, rx1233_eos, rxscan1236_done
  rxscan1236_scan:
    set_addr $I10, rxscan1236_loop
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  rxscan1236_done:
.annotate 'line', 563
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."lambda"()
    unless $P10, rx1233_fail
  # rx pass
    rx1233_cur."!cursor_pass"(rx1233_pos, "infixstopper")
    if_null rx1233_debug, debug_910
    rx1233_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1233_pos)
  debug_910:
    .return (rx1233_cur)
  rx1233_restart:
.annotate 'line', 4
    if_null rx1233_debug, debug_911
    rx1233_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_911:
  rx1233_fail:
    (rx1233_rep, rx1233_pos, $I10, $P10) = rx1233_cur."!mark_fail"(0)
    lt rx1233_pos, -1, rx1233_done
    eq rx1233_pos, -1, rx1233_fail
    jump $I10
  rx1233_done:
    rx1233_cur."!cursor_fail"()
    if_null rx1233_debug, debug_912
    rx1233_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_912:
    .return (rx1233_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("271_1298845521.609") :method
.annotate 'line', 4
    new $P1235, "ResizablePMCArray"
    push $P1235, ""
    .return ($P1235)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("272_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1238_tgt
    .local int rx1238_pos
    .local int rx1238_off
    .local int rx1238_eos
    .local int rx1238_rep
    .local pmc rx1238_cur
    .local pmc rx1238_debug
    (rx1238_cur, rx1238_pos, rx1238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1238_cur
    .local pmc match
    .lex "$/", match
    length rx1238_eos, rx1238_tgt
    gt rx1238_pos, rx1238_eos, rx1238_done
    set rx1238_off, 0
    lt rx1238_pos, 2, rx1238_start
    sub rx1238_off, rx1238_pos, 1
    substr rx1238_tgt, rx1238_tgt, rx1238_off
  rx1238_start:
    eq $I10, 1, rx1238_restart
    if_null rx1238_debug, debug_913
    rx1238_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1242_done
    goto rxscan1242_scan
  rxscan1242_loop:
    (rx1238_pos) = rx1238_cur."from"()
    inc rx1238_pos
    rx1238_cur."!cursor_from"(rx1238_pos)
    ge rx1238_pos, rx1238_eos, rxscan1242_done
  rxscan1242_scan:
    set_addr $I10, rxscan1242_loop
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  rxscan1242_done:
.annotate 'line', 566
  # rx literal  "["
    add $I11, rx1238_pos, 1
    gt $I11, rx1238_eos, rx1238_fail
    sub $I11, rx1238_pos, rx1238_off
    ord $I11, rx1238_tgt, $I11
    ne $I11, 91, rx1238_fail
    add rx1238_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."EXPR"()
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1238_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1238_pos, 1
    gt $I11, rx1238_eos, rx1238_fail
    sub $I11, rx1238_pos, rx1238_off
    ord $I11, rx1238_tgt, $I11
    ne $I11, 93, rx1238_fail
    add rx1238_pos, 1
.annotate 'line', 567
  # rx subrule "O" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."O"("%methodop")
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1238_pos = $P10."pos"()
.annotate 'line', 565
  # rx pass
    rx1238_cur."!cursor_pass"(rx1238_pos, "postcircumfix:sym<[ ]>")
    if_null rx1238_debug, debug_914
    rx1238_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1238_pos)
  debug_914:
    .return (rx1238_cur)
  rx1238_restart:
.annotate 'line', 4
    if_null rx1238_debug, debug_915
    rx1238_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_915:
  rx1238_fail:
    (rx1238_rep, rx1238_pos, $I10, $P10) = rx1238_cur."!mark_fail"(0)
    lt rx1238_pos, -1, rx1238_done
    eq rx1238_pos, -1, rx1238_fail
    jump $I10
  rx1238_done:
    rx1238_cur."!cursor_fail"()
    if_null rx1238_debug, debug_916
    rx1238_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_916:
    .return (rx1238_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("273_1298845521.609") :method
.annotate 'line', 4
    $P1240 = self."!PREFIX__!subrule"("ws", "[")
    new $P1241, "ResizablePMCArray"
    push $P1241, $P1240
    .return ($P1241)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("274_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_917
    rx1244_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 571
  # rx literal  "{"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 123, rx1244_fail
    add rx1244_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."ws"()
    unless $P10, rx1244_fail
    rx1244_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."EXPR"()
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1244_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 125, rx1244_fail
    add rx1244_pos, 1
.annotate 'line', 572
  # rx subrule "O" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."O"("%methodop")
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1244_pos = $P10."pos"()
.annotate 'line', 570
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "postcircumfix:sym<{ }>")
    if_null rx1244_debug, debug_918
    rx1244_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1244_pos)
  debug_918:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 4
    if_null rx1244_debug, debug_919
    rx1244_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_919:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_920
    rx1244_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_920:
    .return (rx1244_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("275_1298845521.609") :method
.annotate 'line', 4
    $P1246 = self."!PREFIX__!subrule"("ws", "{")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("276_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1250_tgt
    .local int rx1250_pos
    .local int rx1250_off
    .local int rx1250_eos
    .local int rx1250_rep
    .local pmc rx1250_cur
    .local pmc rx1250_debug
    (rx1250_cur, rx1250_pos, rx1250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1250_cur
    .local pmc match
    .lex "$/", match
    length rx1250_eos, rx1250_tgt
    gt rx1250_pos, rx1250_eos, rx1250_done
    set rx1250_off, 0
    lt rx1250_pos, 2, rx1250_start
    sub rx1250_off, rx1250_pos, 1
    substr rx1250_tgt, rx1250_tgt, rx1250_off
  rx1250_start:
    eq $I10, 1, rx1250_restart
    if_null rx1250_debug, debug_921
    rx1250_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1253_done
    goto rxscan1253_scan
  rxscan1253_loop:
    (rx1250_pos) = rx1250_cur."from"()
    inc rx1250_pos
    rx1250_cur."!cursor_from"(rx1250_pos)
    ge rx1250_pos, rx1250_eos, rxscan1253_done
  rxscan1253_scan:
    set_addr $I10, rxscan1253_loop
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
  rxscan1253_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1250_pos, rx1250_off
    substr $S10, rx1250_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1250_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."quote_EXPR"(":q")
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1250_pos = $P10."pos"()
.annotate 'line', 577
  # rx subrule "O" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."O"("%methodop")
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1250_pos = $P10."pos"()
.annotate 'line', 575
  # rx pass
    rx1250_cur."!cursor_pass"(rx1250_pos, "postcircumfix:sym<ang>")
    if_null rx1250_debug, debug_922
    rx1250_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1250_pos)
  debug_922:
    .return (rx1250_cur)
  rx1250_restart:
.annotate 'line', 4
    if_null rx1250_debug, debug_923
    rx1250_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_923:
  rx1250_fail:
    (rx1250_rep, rx1250_pos, $I10, $P10) = rx1250_cur."!mark_fail"(0)
    lt rx1250_pos, -1, rx1250_done
    eq rx1250_pos, -1, rx1250_fail
    jump $I10
  rx1250_done:
    rx1250_cur."!cursor_fail"()
    if_null rx1250_debug, debug_924
    rx1250_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_924:
    .return (rx1250_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("277_1298845521.609") :method
.annotate 'line', 4
    new $P1252, "ResizablePMCArray"
    push $P1252, "<"
    .return ($P1252)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("278_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1255_tgt
    .local int rx1255_pos
    .local int rx1255_off
    .local int rx1255_eos
    .local int rx1255_rep
    .local pmc rx1255_cur
    .local pmc rx1255_debug
    (rx1255_cur, rx1255_pos, rx1255_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1255_cur
    .local pmc match
    .lex "$/", match
    length rx1255_eos, rx1255_tgt
    gt rx1255_pos, rx1255_eos, rx1255_done
    set rx1255_off, 0
    lt rx1255_pos, 2, rx1255_start
    sub rx1255_off, rx1255_pos, 1
    substr rx1255_tgt, rx1255_tgt, rx1255_off
  rx1255_start:
    eq $I10, 1, rx1255_restart
    if_null rx1255_debug, debug_925
    rx1255_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1259_done
    goto rxscan1259_scan
  rxscan1259_loop:
    (rx1255_pos) = rx1255_cur."from"()
    inc rx1255_pos
    rx1255_cur."!cursor_from"(rx1255_pos)
    ge rx1255_pos, rx1255_eos, rxscan1259_done
  rxscan1259_scan:
    set_addr $I10, rxscan1259_loop
    rx1255_cur."!mark_push"(0, rx1255_pos, $I10)
  rxscan1259_done:
.annotate 'line', 581
  # rx literal  "("
    add $I11, rx1255_pos, 1
    gt $I11, rx1255_eos, rx1255_fail
    sub $I11, rx1255_pos, rx1255_off
    ord $I11, rx1255_tgt, $I11
    ne $I11, 40, rx1255_fail
    add rx1255_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1255_cur."!cursor_pos"(rx1255_pos)
    $P10 = rx1255_cur."ws"()
    unless $P10, rx1255_fail
    rx1255_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1255_cur."!cursor_pos"(rx1255_pos)
    $P10 = rx1255_cur."arglist"()
    unless $P10, rx1255_fail
    rx1255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1255_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1255_pos, 1
    gt $I11, rx1255_eos, rx1255_fail
    sub $I11, rx1255_pos, rx1255_off
    ord $I11, rx1255_tgt, $I11
    ne $I11, 41, rx1255_fail
    add rx1255_pos, 1
.annotate 'line', 582
  # rx subrule "O" subtype=capture negate=
    rx1255_cur."!cursor_pos"(rx1255_pos)
    $P10 = rx1255_cur."O"("%methodop")
    unless $P10, rx1255_fail
    rx1255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1255_pos = $P10."pos"()
.annotate 'line', 580
  # rx pass
    rx1255_cur."!cursor_pass"(rx1255_pos, "postcircumfix:sym<( )>")
    if_null rx1255_debug, debug_926
    rx1255_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1255_pos)
  debug_926:
    .return (rx1255_cur)
  rx1255_restart:
.annotate 'line', 4
    if_null rx1255_debug, debug_927
    rx1255_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_927:
  rx1255_fail:
    (rx1255_rep, rx1255_pos, $I10, $P10) = rx1255_cur."!mark_fail"(0)
    lt rx1255_pos, -1, rx1255_done
    eq rx1255_pos, -1, rx1255_fail
    jump $I10
  rx1255_done:
    rx1255_cur."!cursor_fail"()
    if_null rx1255_debug, debug_928
    rx1255_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_928:
    .return (rx1255_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("279_1298845521.609") :method
.annotate 'line', 4
    $P1257 = self."!PREFIX__!subrule"("ws", "(")
    new $P1258, "ResizablePMCArray"
    push $P1258, $P1257
    .return ($P1258)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("280_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1261_tgt
    .local int rx1261_pos
    .local int rx1261_off
    .local int rx1261_eos
    .local int rx1261_rep
    .local pmc rx1261_cur
    .local pmc rx1261_debug
    (rx1261_cur, rx1261_pos, rx1261_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1261_cur
    .local pmc match
    .lex "$/", match
    length rx1261_eos, rx1261_tgt
    gt rx1261_pos, rx1261_eos, rx1261_done
    set rx1261_off, 0
    lt rx1261_pos, 2, rx1261_start
    sub rx1261_off, rx1261_pos, 1
    substr rx1261_tgt, rx1261_tgt, rx1261_off
  rx1261_start:
    eq $I10, 1, rx1261_restart
    if_null rx1261_debug, debug_929
    rx1261_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_929:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1265_done
    goto rxscan1265_scan
  rxscan1265_loop:
    (rx1261_pos) = rx1261_cur."from"()
    inc rx1261_pos
    rx1261_cur."!cursor_from"(rx1261_pos)
    ge rx1261_pos, rx1261_eos, rxscan1265_done
  rxscan1265_scan:
    set_addr $I10, rxscan1265_loop
    rx1261_cur."!mark_push"(0, rx1261_pos, $I10)
  rxscan1265_done:
.annotate 'line', 585
  # rx subrule "dotty" subtype=capture negate=
    rx1261_cur."!cursor_pos"(rx1261_pos)
    $P10 = rx1261_cur."dotty"()
    unless $P10, rx1261_fail
    rx1261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1261_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1261_cur."!cursor_pos"(rx1261_pos)
    $P10 = rx1261_cur."O"("%methodop")
    unless $P10, rx1261_fail
    rx1261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1261_pos = $P10."pos"()
  # rx pass
    rx1261_cur."!cursor_pass"(rx1261_pos, "postfix:sym<.>")
    if_null rx1261_debug, debug_930
    rx1261_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1261_pos)
  debug_930:
    .return (rx1261_cur)
  rx1261_restart:
.annotate 'line', 4
    if_null rx1261_debug, debug_931
    rx1261_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_931:
  rx1261_fail:
    (rx1261_rep, rx1261_pos, $I10, $P10) = rx1261_cur."!mark_fail"(0)
    lt rx1261_pos, -1, rx1261_done
    eq rx1261_pos, -1, rx1261_fail
    jump $I10
  rx1261_done:
    rx1261_cur."!cursor_fail"()
    if_null rx1261_debug, debug_932
    rx1261_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_932:
    .return (rx1261_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("281_1298845521.609") :method
.annotate 'line', 4
    $P1263 = self."!PREFIX__!subrule"("dotty", "")
    new $P1264, "ResizablePMCArray"
    push $P1264, $P1263
    .return ($P1264)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("282_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1267_tgt
    .local int rx1267_pos
    .local int rx1267_off
    .local int rx1267_eos
    .local int rx1267_rep
    .local pmc rx1267_cur
    .local pmc rx1267_debug
    (rx1267_cur, rx1267_pos, rx1267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1267_cur
    .local pmc match
    .lex "$/", match
    length rx1267_eos, rx1267_tgt
    gt rx1267_pos, rx1267_eos, rx1267_done
    set rx1267_off, 0
    lt rx1267_pos, 2, rx1267_start
    sub rx1267_off, rx1267_pos, 1
    substr rx1267_tgt, rx1267_tgt, rx1267_off
  rx1267_start:
    eq $I10, 1, rx1267_restart
    if_null rx1267_debug, debug_933
    rx1267_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1271_done
    goto rxscan1271_scan
  rxscan1271_loop:
    (rx1267_pos) = rx1267_cur."from"()
    inc rx1267_pos
    rx1267_cur."!cursor_from"(rx1267_pos)
    ge rx1267_pos, rx1267_eos, rxscan1271_done
  rxscan1271_scan:
    set_addr $I10, rxscan1271_loop
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  rxscan1271_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1272_fail
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  # rx literal  "++"
    add $I11, rx1267_pos, 2
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    substr $S10, rx1267_tgt, $I11, 2
    ne $S10, "++", rx1267_fail
    add rx1267_pos, 2
    set_addr $I10, rxcap_1272_fail
    ($I12, $I11) = rx1267_cur."!mark_peek"($I10)
    rx1267_cur."!cursor_pos"($I11)
    ($P10) = rx1267_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1267_pos, "")
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1272_done
  rxcap_1272_fail:
    goto rx1267_fail
  rxcap_1272_done:
  # rx subrule "O" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1267_pos = $P10."pos"()
  # rx pass
    rx1267_cur."!cursor_pass"(rx1267_pos, "prefix:sym<++>")
    if_null rx1267_debug, debug_934
    rx1267_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1267_pos)
  debug_934:
    .return (rx1267_cur)
  rx1267_restart:
.annotate 'line', 4
    if_null rx1267_debug, debug_935
    rx1267_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_935:
  rx1267_fail:
    (rx1267_rep, rx1267_pos, $I10, $P10) = rx1267_cur."!mark_fail"(0)
    lt rx1267_pos, -1, rx1267_done
    eq rx1267_pos, -1, rx1267_fail
    jump $I10
  rx1267_done:
    rx1267_cur."!cursor_fail"()
    if_null rx1267_debug, debug_936
    rx1267_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_936:
    .return (rx1267_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("283_1298845521.609") :method
.annotate 'line', 4
    $P1269 = self."!PREFIX__!subrule"("O", "++")
    new $P1270, "ResizablePMCArray"
    push $P1270, $P1269
    .return ($P1270)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("284_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1274_tgt
    .local int rx1274_pos
    .local int rx1274_off
    .local int rx1274_eos
    .local int rx1274_rep
    .local pmc rx1274_cur
    .local pmc rx1274_debug
    (rx1274_cur, rx1274_pos, rx1274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1274_cur
    .local pmc match
    .lex "$/", match
    length rx1274_eos, rx1274_tgt
    gt rx1274_pos, rx1274_eos, rx1274_done
    set rx1274_off, 0
    lt rx1274_pos, 2, rx1274_start
    sub rx1274_off, rx1274_pos, 1
    substr rx1274_tgt, rx1274_tgt, rx1274_off
  rx1274_start:
    eq $I10, 1, rx1274_restart
    if_null rx1274_debug, debug_937
    rx1274_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1278_done
    goto rxscan1278_scan
  rxscan1278_loop:
    (rx1274_pos) = rx1274_cur."from"()
    inc rx1274_pos
    rx1274_cur."!cursor_from"(rx1274_pos)
    ge rx1274_pos, rx1274_eos, rxscan1278_done
  rxscan1278_scan:
    set_addr $I10, rxscan1278_loop
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  rxscan1278_done:
.annotate 'line', 588
  # rx subcapture "sym"
    set_addr $I10, rxcap_1279_fail
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  # rx literal  "--"
    add $I11, rx1274_pos, 2
    gt $I11, rx1274_eos, rx1274_fail
    sub $I11, rx1274_pos, rx1274_off
    substr $S10, rx1274_tgt, $I11, 2
    ne $S10, "--", rx1274_fail
    add rx1274_pos, 2
    set_addr $I10, rxcap_1279_fail
    ($I12, $I11) = rx1274_cur."!mark_peek"($I10)
    rx1274_cur."!cursor_pos"($I11)
    ($P10) = rx1274_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1274_pos, "")
    rx1274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1279_done
  rxcap_1279_fail:
    goto rx1274_fail
  rxcap_1279_done:
  # rx subrule "O" subtype=capture negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1274_fail
    rx1274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1274_pos = $P10."pos"()
  # rx pass
    rx1274_cur."!cursor_pass"(rx1274_pos, "prefix:sym<-->")
    if_null rx1274_debug, debug_938
    rx1274_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1274_pos)
  debug_938:
    .return (rx1274_cur)
  rx1274_restart:
.annotate 'line', 4
    if_null rx1274_debug, debug_939
    rx1274_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_939:
  rx1274_fail:
    (rx1274_rep, rx1274_pos, $I10, $P10) = rx1274_cur."!mark_fail"(0)
    lt rx1274_pos, -1, rx1274_done
    eq rx1274_pos, -1, rx1274_fail
    jump $I10
  rx1274_done:
    rx1274_cur."!cursor_fail"()
    if_null rx1274_debug, debug_940
    rx1274_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_940:
    .return (rx1274_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("285_1298845521.609") :method
.annotate 'line', 4
    $P1276 = self."!PREFIX__!subrule"("O", "--")
    new $P1277, "ResizablePMCArray"
    push $P1277, $P1276
    .return ($P1277)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("286_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1281_tgt
    .local int rx1281_pos
    .local int rx1281_off
    .local int rx1281_eos
    .local int rx1281_rep
    .local pmc rx1281_cur
    .local pmc rx1281_debug
    (rx1281_cur, rx1281_pos, rx1281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1281_cur
    .local pmc match
    .lex "$/", match
    length rx1281_eos, rx1281_tgt
    gt rx1281_pos, rx1281_eos, rx1281_done
    set rx1281_off, 0
    lt rx1281_pos, 2, rx1281_start
    sub rx1281_off, rx1281_pos, 1
    substr rx1281_tgt, rx1281_tgt, rx1281_off
  rx1281_start:
    eq $I10, 1, rx1281_restart
    if_null rx1281_debug, debug_941
    rx1281_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1285_done
    goto rxscan1285_scan
  rxscan1285_loop:
    (rx1281_pos) = rx1281_cur."from"()
    inc rx1281_pos
    rx1281_cur."!cursor_from"(rx1281_pos)
    ge rx1281_pos, rx1281_eos, rxscan1285_done
  rxscan1285_scan:
    set_addr $I10, rxscan1285_loop
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  rxscan1285_done:
.annotate 'line', 591
  # rx subcapture "sym"
    set_addr $I10, rxcap_1286_fail
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  # rx literal  "++"
    add $I11, rx1281_pos, 2
    gt $I11, rx1281_eos, rx1281_fail
    sub $I11, rx1281_pos, rx1281_off
    substr $S10, rx1281_tgt, $I11, 2
    ne $S10, "++", rx1281_fail
    add rx1281_pos, 2
    set_addr $I10, rxcap_1286_fail
    ($I12, $I11) = rx1281_cur."!mark_peek"($I10)
    rx1281_cur."!cursor_pos"($I11)
    ($P10) = rx1281_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1281_pos, "")
    rx1281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1286_done
  rxcap_1286_fail:
    goto rx1281_fail
  rxcap_1286_done:
  # rx subrule "O" subtype=capture negate=
    rx1281_cur."!cursor_pos"(rx1281_pos)
    $P10 = rx1281_cur."O"("%autoincrement")
    unless $P10, rx1281_fail
    rx1281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1281_pos = $P10."pos"()
  # rx pass
    rx1281_cur."!cursor_pass"(rx1281_pos, "postfix:sym<++>")
    if_null rx1281_debug, debug_942
    rx1281_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1281_pos)
  debug_942:
    .return (rx1281_cur)
  rx1281_restart:
.annotate 'line', 4
    if_null rx1281_debug, debug_943
    rx1281_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_943:
  rx1281_fail:
    (rx1281_rep, rx1281_pos, $I10, $P10) = rx1281_cur."!mark_fail"(0)
    lt rx1281_pos, -1, rx1281_done
    eq rx1281_pos, -1, rx1281_fail
    jump $I10
  rx1281_done:
    rx1281_cur."!cursor_fail"()
    if_null rx1281_debug, debug_944
    rx1281_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_944:
    .return (rx1281_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("287_1298845521.609") :method
.annotate 'line', 4
    $P1283 = self."!PREFIX__!subrule"("O", "++")
    new $P1284, "ResizablePMCArray"
    push $P1284, $P1283
    .return ($P1284)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("288_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1288_tgt
    .local int rx1288_pos
    .local int rx1288_off
    .local int rx1288_eos
    .local int rx1288_rep
    .local pmc rx1288_cur
    .local pmc rx1288_debug
    (rx1288_cur, rx1288_pos, rx1288_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1288_cur
    .local pmc match
    .lex "$/", match
    length rx1288_eos, rx1288_tgt
    gt rx1288_pos, rx1288_eos, rx1288_done
    set rx1288_off, 0
    lt rx1288_pos, 2, rx1288_start
    sub rx1288_off, rx1288_pos, 1
    substr rx1288_tgt, rx1288_tgt, rx1288_off
  rx1288_start:
    eq $I10, 1, rx1288_restart
    if_null rx1288_debug, debug_945
    rx1288_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1292_done
    goto rxscan1292_scan
  rxscan1292_loop:
    (rx1288_pos) = rx1288_cur."from"()
    inc rx1288_pos
    rx1288_cur."!cursor_from"(rx1288_pos)
    ge rx1288_pos, rx1288_eos, rxscan1292_done
  rxscan1292_scan:
    set_addr $I10, rxscan1292_loop
    rx1288_cur."!mark_push"(0, rx1288_pos, $I10)
  rxscan1292_done:
.annotate 'line', 592
  # rx subcapture "sym"
    set_addr $I10, rxcap_1293_fail
    rx1288_cur."!mark_push"(0, rx1288_pos, $I10)
  # rx literal  "--"
    add $I11, rx1288_pos, 2
    gt $I11, rx1288_eos, rx1288_fail
    sub $I11, rx1288_pos, rx1288_off
    substr $S10, rx1288_tgt, $I11, 2
    ne $S10, "--", rx1288_fail
    add rx1288_pos, 2
    set_addr $I10, rxcap_1293_fail
    ($I12, $I11) = rx1288_cur."!mark_peek"($I10)
    rx1288_cur."!cursor_pos"($I11)
    ($P10) = rx1288_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1288_pos, "")
    rx1288_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1293_done
  rxcap_1293_fail:
    goto rx1288_fail
  rxcap_1293_done:
  # rx subrule "O" subtype=capture negate=
    rx1288_cur."!cursor_pos"(rx1288_pos)
    $P10 = rx1288_cur."O"("%autoincrement")
    unless $P10, rx1288_fail
    rx1288_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1288_pos = $P10."pos"()
  # rx pass
    rx1288_cur."!cursor_pass"(rx1288_pos, "postfix:sym<-->")
    if_null rx1288_debug, debug_946
    rx1288_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1288_pos)
  debug_946:
    .return (rx1288_cur)
  rx1288_restart:
.annotate 'line', 4
    if_null rx1288_debug, debug_947
    rx1288_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_947:
  rx1288_fail:
    (rx1288_rep, rx1288_pos, $I10, $P10) = rx1288_cur."!mark_fail"(0)
    lt rx1288_pos, -1, rx1288_done
    eq rx1288_pos, -1, rx1288_fail
    jump $I10
  rx1288_done:
    rx1288_cur."!cursor_fail"()
    if_null rx1288_debug, debug_948
    rx1288_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_948:
    .return (rx1288_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("289_1298845521.609") :method
.annotate 'line', 4
    $P1290 = self."!PREFIX__!subrule"("O", "--")
    new $P1291, "ResizablePMCArray"
    push $P1291, $P1290
    .return ($P1291)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("290_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1295_tgt
    .local int rx1295_pos
    .local int rx1295_off
    .local int rx1295_eos
    .local int rx1295_rep
    .local pmc rx1295_cur
    .local pmc rx1295_debug
    (rx1295_cur, rx1295_pos, rx1295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1295_cur
    .local pmc match
    .lex "$/", match
    length rx1295_eos, rx1295_tgt
    gt rx1295_pos, rx1295_eos, rx1295_done
    set rx1295_off, 0
    lt rx1295_pos, 2, rx1295_start
    sub rx1295_off, rx1295_pos, 1
    substr rx1295_tgt, rx1295_tgt, rx1295_off
  rx1295_start:
    eq $I10, 1, rx1295_restart
    if_null rx1295_debug, debug_949
    rx1295_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1299_done
    goto rxscan1299_scan
  rxscan1299_loop:
    (rx1295_pos) = rx1295_cur."from"()
    inc rx1295_pos
    rx1295_cur."!cursor_from"(rx1295_pos)
    ge rx1295_pos, rx1295_eos, rxscan1299_done
  rxscan1299_scan:
    set_addr $I10, rxscan1299_loop
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  rxscan1299_done:
.annotate 'line', 594
  # rx subcapture "sym"
    set_addr $I10, rxcap_1300_fail
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  # rx literal  "**"
    add $I11, rx1295_pos, 2
    gt $I11, rx1295_eos, rx1295_fail
    sub $I11, rx1295_pos, rx1295_off
    substr $S10, rx1295_tgt, $I11, 2
    ne $S10, "**", rx1295_fail
    add rx1295_pos, 2
    set_addr $I10, rxcap_1300_fail
    ($I12, $I11) = rx1295_cur."!mark_peek"($I10)
    rx1295_cur."!cursor_pos"($I11)
    ($P10) = rx1295_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1295_pos, "")
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1300_done
  rxcap_1300_fail:
    goto rx1295_fail
  rxcap_1300_done:
  # rx subrule "O" subtype=capture negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1295_fail
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1295_pos = $P10."pos"()
  # rx pass
    rx1295_cur."!cursor_pass"(rx1295_pos, "infix:sym<**>")
    if_null rx1295_debug, debug_950
    rx1295_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1295_pos)
  debug_950:
    .return (rx1295_cur)
  rx1295_restart:
.annotate 'line', 4
    if_null rx1295_debug, debug_951
    rx1295_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_951:
  rx1295_fail:
    (rx1295_rep, rx1295_pos, $I10, $P10) = rx1295_cur."!mark_fail"(0)
    lt rx1295_pos, -1, rx1295_done
    eq rx1295_pos, -1, rx1295_fail
    jump $I10
  rx1295_done:
    rx1295_cur."!cursor_fail"()
    if_null rx1295_debug, debug_952
    rx1295_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_952:
    .return (rx1295_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("291_1298845521.609") :method
.annotate 'line', 4
    $P1297 = self."!PREFIX__!subrule"("O", "**")
    new $P1298, "ResizablePMCArray"
    push $P1298, $P1297
    .return ($P1298)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("292_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1302_tgt
    .local int rx1302_pos
    .local int rx1302_off
    .local int rx1302_eos
    .local int rx1302_rep
    .local pmc rx1302_cur
    .local pmc rx1302_debug
    (rx1302_cur, rx1302_pos, rx1302_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1302_cur
    .local pmc match
    .lex "$/", match
    length rx1302_eos, rx1302_tgt
    gt rx1302_pos, rx1302_eos, rx1302_done
    set rx1302_off, 0
    lt rx1302_pos, 2, rx1302_start
    sub rx1302_off, rx1302_pos, 1
    substr rx1302_tgt, rx1302_tgt, rx1302_off
  rx1302_start:
    eq $I10, 1, rx1302_restart
    if_null rx1302_debug, debug_953
    rx1302_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1302_pos) = rx1302_cur."from"()
    inc rx1302_pos
    rx1302_cur."!cursor_from"(rx1302_pos)
    ge rx1302_pos, rx1302_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxscan1306_done:
.annotate 'line', 596
  # rx subcapture "sym"
    set_addr $I10, rxcap_1307_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "+"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 43, rx1302_fail
    add rx1302_pos, 1
    set_addr $I10, rxcap_1307_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1307_done
  rxcap_1307_fail:
    goto rx1302_fail
  rxcap_1307_done:
  # rx subrule "O" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1302_pos = $P10."pos"()
  # rx pass
    rx1302_cur."!cursor_pass"(rx1302_pos, "prefix:sym<+>")
    if_null rx1302_debug, debug_954
    rx1302_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1302_pos)
  debug_954:
    .return (rx1302_cur)
  rx1302_restart:
.annotate 'line', 4
    if_null rx1302_debug, debug_955
    rx1302_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_955:
  rx1302_fail:
    (rx1302_rep, rx1302_pos, $I10, $P10) = rx1302_cur."!mark_fail"(0)
    lt rx1302_pos, -1, rx1302_done
    eq rx1302_pos, -1, rx1302_fail
    jump $I10
  rx1302_done:
    rx1302_cur."!cursor_fail"()
    if_null rx1302_debug, debug_956
    rx1302_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_956:
    .return (rx1302_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("293_1298845521.609") :method
.annotate 'line', 4
    $P1304 = self."!PREFIX__!subrule"("O", "+")
    new $P1305, "ResizablePMCArray"
    push $P1305, $P1304
    .return ($P1305)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("294_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1309_tgt
    .local int rx1309_pos
    .local int rx1309_off
    .local int rx1309_eos
    .local int rx1309_rep
    .local pmc rx1309_cur
    .local pmc rx1309_debug
    (rx1309_cur, rx1309_pos, rx1309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1309_cur
    .local pmc match
    .lex "$/", match
    length rx1309_eos, rx1309_tgt
    gt rx1309_pos, rx1309_eos, rx1309_done
    set rx1309_off, 0
    lt rx1309_pos, 2, rx1309_start
    sub rx1309_off, rx1309_pos, 1
    substr rx1309_tgt, rx1309_tgt, rx1309_off
  rx1309_start:
    eq $I10, 1, rx1309_restart
    if_null rx1309_debug, debug_957
    rx1309_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1313_done
    goto rxscan1313_scan
  rxscan1313_loop:
    (rx1309_pos) = rx1309_cur."from"()
    inc rx1309_pos
    rx1309_cur."!cursor_from"(rx1309_pos)
    ge rx1309_pos, rx1309_eos, rxscan1313_done
  rxscan1313_scan:
    set_addr $I10, rxscan1313_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  rxscan1313_done:
.annotate 'line', 597
  # rx subcapture "sym"
    set_addr $I10, rxcap_1314_fail
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  # rx literal  "~"
    add $I11, rx1309_pos, 1
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    ord $I11, rx1309_tgt, $I11
    ne $I11, 126, rx1309_fail
    add rx1309_pos, 1
    set_addr $I10, rxcap_1314_fail
    ($I12, $I11) = rx1309_cur."!mark_peek"($I10)
    rx1309_cur."!cursor_pos"($I11)
    ($P10) = rx1309_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1309_pos, "")
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1314_done
  rxcap_1314_fail:
    goto rx1309_fail
  rxcap_1314_done:
  # rx subrule "O" subtype=capture negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1309_fail
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1309_pos = $P10."pos"()
  # rx pass
    rx1309_cur."!cursor_pass"(rx1309_pos, "prefix:sym<~>")
    if_null rx1309_debug, debug_958
    rx1309_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1309_pos)
  debug_958:
    .return (rx1309_cur)
  rx1309_restart:
.annotate 'line', 4
    if_null rx1309_debug, debug_959
    rx1309_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_959:
  rx1309_fail:
    (rx1309_rep, rx1309_pos, $I10, $P10) = rx1309_cur."!mark_fail"(0)
    lt rx1309_pos, -1, rx1309_done
    eq rx1309_pos, -1, rx1309_fail
    jump $I10
  rx1309_done:
    rx1309_cur."!cursor_fail"()
    if_null rx1309_debug, debug_960
    rx1309_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_960:
    .return (rx1309_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("295_1298845521.609") :method
.annotate 'line', 4
    $P1311 = self."!PREFIX__!subrule"("O", "~")
    new $P1312, "ResizablePMCArray"
    push $P1312, $P1311
    .return ($P1312)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("296_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1316_tgt
    .local int rx1316_pos
    .local int rx1316_off
    .local int rx1316_eos
    .local int rx1316_rep
    .local pmc rx1316_cur
    .local pmc rx1316_debug
    (rx1316_cur, rx1316_pos, rx1316_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1316_cur
    .local pmc match
    .lex "$/", match
    length rx1316_eos, rx1316_tgt
    gt rx1316_pos, rx1316_eos, rx1316_done
    set rx1316_off, 0
    lt rx1316_pos, 2, rx1316_start
    sub rx1316_off, rx1316_pos, 1
    substr rx1316_tgt, rx1316_tgt, rx1316_off
  rx1316_start:
    eq $I10, 1, rx1316_restart
    if_null rx1316_debug, debug_961
    rx1316_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1319_done
    goto rxscan1319_scan
  rxscan1319_loop:
    (rx1316_pos) = rx1316_cur."from"()
    inc rx1316_pos
    rx1316_cur."!cursor_from"(rx1316_pos)
    ge rx1316_pos, rx1316_eos, rxscan1319_done
  rxscan1319_scan:
    set_addr $I10, rxscan1319_loop
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  rxscan1319_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1320_fail
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  # rx literal  "-"
    add $I11, rx1316_pos, 1
    gt $I11, rx1316_eos, rx1316_fail
    sub $I11, rx1316_pos, rx1316_off
    ord $I11, rx1316_tgt, $I11
    ne $I11, 45, rx1316_fail
    add rx1316_pos, 1
    set_addr $I10, rxcap_1320_fail
    ($I12, $I11) = rx1316_cur."!mark_peek"($I10)
    rx1316_cur."!cursor_pos"($I11)
    ($P10) = rx1316_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1316_pos, "")
    rx1316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1320_done
  rxcap_1320_fail:
    goto rx1316_fail
  rxcap_1320_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1316_pos, rx1316_off
    substr $S10, rx1316_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1316_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."number"()
    if $P10, rx1316_fail
  # rx subrule "O" subtype=capture negate=
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1316_fail
    rx1316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1316_pos = $P10."pos"()
  # rx pass
    rx1316_cur."!cursor_pass"(rx1316_pos, "prefix:sym<->")
    if_null rx1316_debug, debug_962
    rx1316_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1316_pos)
  debug_962:
    .return (rx1316_cur)
  rx1316_restart:
.annotate 'line', 4
    if_null rx1316_debug, debug_963
    rx1316_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_963:
  rx1316_fail:
    (rx1316_rep, rx1316_pos, $I10, $P10) = rx1316_cur."!mark_fail"(0)
    lt rx1316_pos, -1, rx1316_done
    eq rx1316_pos, -1, rx1316_fail
    jump $I10
  rx1316_done:
    rx1316_cur."!cursor_fail"()
    if_null rx1316_debug, debug_964
    rx1316_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_964:
    .return (rx1316_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("297_1298845521.609") :method
.annotate 'line', 4
    new $P1318, "ResizablePMCArray"
    push $P1318, "-"
    .return ($P1318)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("298_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1322_tgt
    .local int rx1322_pos
    .local int rx1322_off
    .local int rx1322_eos
    .local int rx1322_rep
    .local pmc rx1322_cur
    .local pmc rx1322_debug
    (rx1322_cur, rx1322_pos, rx1322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1322_cur
    .local pmc match
    .lex "$/", match
    length rx1322_eos, rx1322_tgt
    gt rx1322_pos, rx1322_eos, rx1322_done
    set rx1322_off, 0
    lt rx1322_pos, 2, rx1322_start
    sub rx1322_off, rx1322_pos, 1
    substr rx1322_tgt, rx1322_tgt, rx1322_off
  rx1322_start:
    eq $I10, 1, rx1322_restart
    if_null rx1322_debug, debug_965
    rx1322_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1322_pos) = rx1322_cur."from"()
    inc rx1322_pos
    rx1322_cur."!cursor_from"(rx1322_pos)
    ge rx1322_pos, rx1322_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  rxscan1326_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1327_fail
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  # rx literal  "?"
    add $I11, rx1322_pos, 1
    gt $I11, rx1322_eos, rx1322_fail
    sub $I11, rx1322_pos, rx1322_off
    ord $I11, rx1322_tgt, $I11
    ne $I11, 63, rx1322_fail
    add rx1322_pos, 1
    set_addr $I10, rxcap_1327_fail
    ($I12, $I11) = rx1322_cur."!mark_peek"($I10)
    rx1322_cur."!cursor_pos"($I11)
    ($P10) = rx1322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1322_pos, "")
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1327_done
  rxcap_1327_fail:
    goto rx1322_fail
  rxcap_1327_done:
  # rx subrule "O" subtype=capture negate=
    rx1322_cur."!cursor_pos"(rx1322_pos)
    $P10 = rx1322_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1322_fail
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1322_pos = $P10."pos"()
  # rx pass
    rx1322_cur."!cursor_pass"(rx1322_pos, "prefix:sym<?>")
    if_null rx1322_debug, debug_966
    rx1322_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1322_pos)
  debug_966:
    .return (rx1322_cur)
  rx1322_restart:
.annotate 'line', 4
    if_null rx1322_debug, debug_967
    rx1322_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_967:
  rx1322_fail:
    (rx1322_rep, rx1322_pos, $I10, $P10) = rx1322_cur."!mark_fail"(0)
    lt rx1322_pos, -1, rx1322_done
    eq rx1322_pos, -1, rx1322_fail
    jump $I10
  rx1322_done:
    rx1322_cur."!cursor_fail"()
    if_null rx1322_debug, debug_968
    rx1322_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_968:
    .return (rx1322_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("299_1298845521.609") :method
.annotate 'line', 4
    $P1324 = self."!PREFIX__!subrule"("O", "?")
    new $P1325, "ResizablePMCArray"
    push $P1325, $P1324
    .return ($P1325)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("300_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1329_tgt
    .local int rx1329_pos
    .local int rx1329_off
    .local int rx1329_eos
    .local int rx1329_rep
    .local pmc rx1329_cur
    .local pmc rx1329_debug
    (rx1329_cur, rx1329_pos, rx1329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1329_cur
    .local pmc match
    .lex "$/", match
    length rx1329_eos, rx1329_tgt
    gt rx1329_pos, rx1329_eos, rx1329_done
    set rx1329_off, 0
    lt rx1329_pos, 2, rx1329_start
    sub rx1329_off, rx1329_pos, 1
    substr rx1329_tgt, rx1329_tgt, rx1329_off
  rx1329_start:
    eq $I10, 1, rx1329_restart
    if_null rx1329_debug, debug_969
    rx1329_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1333_done
    goto rxscan1333_scan
  rxscan1333_loop:
    (rx1329_pos) = rx1329_cur."from"()
    inc rx1329_pos
    rx1329_cur."!cursor_from"(rx1329_pos)
    ge rx1329_pos, rx1329_eos, rxscan1333_done
  rxscan1333_scan:
    set_addr $I10, rxscan1333_loop
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  rxscan1333_done:
.annotate 'line', 600
  # rx subcapture "sym"
    set_addr $I10, rxcap_1334_fail
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  # rx literal  "!"
    add $I11, rx1329_pos, 1
    gt $I11, rx1329_eos, rx1329_fail
    sub $I11, rx1329_pos, rx1329_off
    ord $I11, rx1329_tgt, $I11
    ne $I11, 33, rx1329_fail
    add rx1329_pos, 1
    set_addr $I10, rxcap_1334_fail
    ($I12, $I11) = rx1329_cur."!mark_peek"($I10)
    rx1329_cur."!cursor_pos"($I11)
    ($P10) = rx1329_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1329_pos, "")
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1334_done
  rxcap_1334_fail:
    goto rx1329_fail
  rxcap_1334_done:
  # rx subrule "O" subtype=capture negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1329_fail
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1329_pos = $P10."pos"()
  # rx pass
    rx1329_cur."!cursor_pass"(rx1329_pos, "prefix:sym<!>")
    if_null rx1329_debug, debug_970
    rx1329_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1329_pos)
  debug_970:
    .return (rx1329_cur)
  rx1329_restart:
.annotate 'line', 4
    if_null rx1329_debug, debug_971
    rx1329_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_971:
  rx1329_fail:
    (rx1329_rep, rx1329_pos, $I10, $P10) = rx1329_cur."!mark_fail"(0)
    lt rx1329_pos, -1, rx1329_done
    eq rx1329_pos, -1, rx1329_fail
    jump $I10
  rx1329_done:
    rx1329_cur."!cursor_fail"()
    if_null rx1329_debug, debug_972
    rx1329_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_972:
    .return (rx1329_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("301_1298845521.609") :method
.annotate 'line', 4
    $P1331 = self."!PREFIX__!subrule"("O", "!")
    new $P1332, "ResizablePMCArray"
    push $P1332, $P1331
    .return ($P1332)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("302_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1336_tgt
    .local int rx1336_pos
    .local int rx1336_off
    .local int rx1336_eos
    .local int rx1336_rep
    .local pmc rx1336_cur
    .local pmc rx1336_debug
    (rx1336_cur, rx1336_pos, rx1336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1336_cur
    .local pmc match
    .lex "$/", match
    length rx1336_eos, rx1336_tgt
    gt rx1336_pos, rx1336_eos, rx1336_done
    set rx1336_off, 0
    lt rx1336_pos, 2, rx1336_start
    sub rx1336_off, rx1336_pos, 1
    substr rx1336_tgt, rx1336_tgt, rx1336_off
  rx1336_start:
    eq $I10, 1, rx1336_restart
    if_null rx1336_debug, debug_973
    rx1336_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1340_done
    goto rxscan1340_scan
  rxscan1340_loop:
    (rx1336_pos) = rx1336_cur."from"()
    inc rx1336_pos
    rx1336_cur."!cursor_from"(rx1336_pos)
    ge rx1336_pos, rx1336_eos, rxscan1340_done
  rxscan1340_scan:
    set_addr $I10, rxscan1340_loop
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  rxscan1340_done:
.annotate 'line', 601
  # rx subcapture "sym"
    set_addr $I10, rxcap_1341_fail
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  # rx literal  "|"
    add $I11, rx1336_pos, 1
    gt $I11, rx1336_eos, rx1336_fail
    sub $I11, rx1336_pos, rx1336_off
    ord $I11, rx1336_tgt, $I11
    ne $I11, 124, rx1336_fail
    add rx1336_pos, 1
    set_addr $I10, rxcap_1341_fail
    ($I12, $I11) = rx1336_cur."!mark_peek"($I10)
    rx1336_cur."!cursor_pos"($I11)
    ($P10) = rx1336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1336_pos, "")
    rx1336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1341_done
  rxcap_1341_fail:
    goto rx1336_fail
  rxcap_1341_done:
  # rx subrule "O" subtype=capture negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."O"("%symbolic_unary")
    unless $P10, rx1336_fail
    rx1336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1336_pos = $P10."pos"()
  # rx pass
    rx1336_cur."!cursor_pass"(rx1336_pos, "prefix:sym<|>")
    if_null rx1336_debug, debug_974
    rx1336_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1336_pos)
  debug_974:
    .return (rx1336_cur)
  rx1336_restart:
.annotate 'line', 4
    if_null rx1336_debug, debug_975
    rx1336_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_975:
  rx1336_fail:
    (rx1336_rep, rx1336_pos, $I10, $P10) = rx1336_cur."!mark_fail"(0)
    lt rx1336_pos, -1, rx1336_done
    eq rx1336_pos, -1, rx1336_fail
    jump $I10
  rx1336_done:
    rx1336_cur."!cursor_fail"()
    if_null rx1336_debug, debug_976
    rx1336_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_976:
    .return (rx1336_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("303_1298845521.609") :method
.annotate 'line', 4
    $P1338 = self."!PREFIX__!subrule"("O", "|")
    new $P1339, "ResizablePMCArray"
    push $P1339, $P1338
    .return ($P1339)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("304_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_977
    rx1343_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1348_fail
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx literal  "*"
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 42, rx1343_fail
    add rx1343_pos, 1
    set_addr $I10, rxcap_1348_fail
    ($I12, $I11) = rx1343_cur."!mark_peek"($I10)
    rx1343_cur."!cursor_pos"($I11)
    ($P10) = rx1343_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1343_pos, "")
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1348_done
  rxcap_1348_fail:
    goto rx1343_fail
  rxcap_1348_done:
  # rx subrule "O" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1343_pos = $P10."pos"()
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "infix:sym<*>")
    if_null rx1343_debug, debug_978
    rx1343_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1343_pos)
  debug_978:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 4
    if_null rx1343_debug, debug_979
    rx1343_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_979:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_980
    rx1343_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_980:
    .return (rx1343_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("305_1298845521.609") :method
.annotate 'line', 4
    $P1345 = self."!PREFIX__!subrule"("O", "*")
    new $P1346, "ResizablePMCArray"
    push $P1346, $P1345
    .return ($P1346)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("306_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1350_tgt
    .local int rx1350_pos
    .local int rx1350_off
    .local int rx1350_eos
    .local int rx1350_rep
    .local pmc rx1350_cur
    .local pmc rx1350_debug
    (rx1350_cur, rx1350_pos, rx1350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1350_cur
    .local pmc match
    .lex "$/", match
    length rx1350_eos, rx1350_tgt
    gt rx1350_pos, rx1350_eos, rx1350_done
    set rx1350_off, 0
    lt rx1350_pos, 2, rx1350_start
    sub rx1350_off, rx1350_pos, 1
    substr rx1350_tgt, rx1350_tgt, rx1350_off
  rx1350_start:
    eq $I10, 1, rx1350_restart
    if_null rx1350_debug, debug_981
    rx1350_cur."!cursor_debug"("START", "infix:sym</>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1354_done
    goto rxscan1354_scan
  rxscan1354_loop:
    (rx1350_pos) = rx1350_cur."from"()
    inc rx1350_pos
    rx1350_cur."!cursor_from"(rx1350_pos)
    ge rx1350_pos, rx1350_eos, rxscan1354_done
  rxscan1354_scan:
    set_addr $I10, rxscan1354_loop
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  rxscan1354_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1355_fail
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  # rx literal  "/"
    add $I11, rx1350_pos, 1
    gt $I11, rx1350_eos, rx1350_fail
    sub $I11, rx1350_pos, rx1350_off
    ord $I11, rx1350_tgt, $I11
    ne $I11, 47, rx1350_fail
    add rx1350_pos, 1
    set_addr $I10, rxcap_1355_fail
    ($I12, $I11) = rx1350_cur."!mark_peek"($I10)
    rx1350_cur."!cursor_pos"($I11)
    ($P10) = rx1350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1350_pos, "")
    rx1350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1355_done
  rxcap_1355_fail:
    goto rx1350_fail
  rxcap_1355_done:
  # rx subrule "O" subtype=capture negate=
    rx1350_cur."!cursor_pos"(rx1350_pos)
    $P10 = rx1350_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1350_fail
    rx1350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1350_pos = $P10."pos"()
  # rx pass
    rx1350_cur."!cursor_pass"(rx1350_pos, "infix:sym</>")
    if_null rx1350_debug, debug_982
    rx1350_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1350_pos)
  debug_982:
    .return (rx1350_cur)
  rx1350_restart:
.annotate 'line', 4
    if_null rx1350_debug, debug_983
    rx1350_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_983:
  rx1350_fail:
    (rx1350_rep, rx1350_pos, $I10, $P10) = rx1350_cur."!mark_fail"(0)
    lt rx1350_pos, -1, rx1350_done
    eq rx1350_pos, -1, rx1350_fail
    jump $I10
  rx1350_done:
    rx1350_cur."!cursor_fail"()
    if_null rx1350_debug, debug_984
    rx1350_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_984:
    .return (rx1350_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("307_1298845521.609") :method
.annotate 'line', 4
    $P1352 = self."!PREFIX__!subrule"("O", "/")
    new $P1353, "ResizablePMCArray"
    push $P1353, $P1352
    .return ($P1353)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("308_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1357_tgt
    .local int rx1357_pos
    .local int rx1357_off
    .local int rx1357_eos
    .local int rx1357_rep
    .local pmc rx1357_cur
    .local pmc rx1357_debug
    (rx1357_cur, rx1357_pos, rx1357_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1357_cur
    .local pmc match
    .lex "$/", match
    length rx1357_eos, rx1357_tgt
    gt rx1357_pos, rx1357_eos, rx1357_done
    set rx1357_off, 0
    lt rx1357_pos, 2, rx1357_start
    sub rx1357_off, rx1357_pos, 1
    substr rx1357_tgt, rx1357_tgt, rx1357_off
  rx1357_start:
    eq $I10, 1, rx1357_restart
    if_null rx1357_debug, debug_985
    rx1357_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1361_done
    goto rxscan1361_scan
  rxscan1361_loop:
    (rx1357_pos) = rx1357_cur."from"()
    inc rx1357_pos
    rx1357_cur."!cursor_from"(rx1357_pos)
    ge rx1357_pos, rx1357_eos, rxscan1361_done
  rxscan1361_scan:
    set_addr $I10, rxscan1361_loop
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  rxscan1361_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1362_fail
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  # rx literal  "%"
    add $I11, rx1357_pos, 1
    gt $I11, rx1357_eos, rx1357_fail
    sub $I11, rx1357_pos, rx1357_off
    ord $I11, rx1357_tgt, $I11
    ne $I11, 37, rx1357_fail
    add rx1357_pos, 1
    set_addr $I10, rxcap_1362_fail
    ($I12, $I11) = rx1357_cur."!mark_peek"($I10)
    rx1357_cur."!cursor_pos"($I11)
    ($P10) = rx1357_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1357_pos, "")
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1362_done
  rxcap_1362_fail:
    goto rx1357_fail
  rxcap_1362_done:
  # rx subrule "O" subtype=capture negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1357_fail
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1357_pos = $P10."pos"()
  # rx pass
    rx1357_cur."!cursor_pass"(rx1357_pos, "infix:sym<%>")
    if_null rx1357_debug, debug_986
    rx1357_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1357_pos)
  debug_986:
    .return (rx1357_cur)
  rx1357_restart:
.annotate 'line', 4
    if_null rx1357_debug, debug_987
    rx1357_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_987:
  rx1357_fail:
    (rx1357_rep, rx1357_pos, $I10, $P10) = rx1357_cur."!mark_fail"(0)
    lt rx1357_pos, -1, rx1357_done
    eq rx1357_pos, -1, rx1357_fail
    jump $I10
  rx1357_done:
    rx1357_cur."!cursor_fail"()
    if_null rx1357_debug, debug_988
    rx1357_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_988:
    .return (rx1357_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("309_1298845521.609") :method
.annotate 'line', 4
    $P1359 = self."!PREFIX__!subrule"("O", "%")
    new $P1360, "ResizablePMCArray"
    push $P1360, $P1359
    .return ($P1360)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("310_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1364_tgt
    .local int rx1364_pos
    .local int rx1364_off
    .local int rx1364_eos
    .local int rx1364_rep
    .local pmc rx1364_cur
    .local pmc rx1364_debug
    (rx1364_cur, rx1364_pos, rx1364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1364_cur
    .local pmc match
    .lex "$/", match
    length rx1364_eos, rx1364_tgt
    gt rx1364_pos, rx1364_eos, rx1364_done
    set rx1364_off, 0
    lt rx1364_pos, 2, rx1364_start
    sub rx1364_off, rx1364_pos, 1
    substr rx1364_tgt, rx1364_tgt, rx1364_off
  rx1364_start:
    eq $I10, 1, rx1364_restart
    if_null rx1364_debug, debug_989
    rx1364_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1368_done
    goto rxscan1368_scan
  rxscan1368_loop:
    (rx1364_pos) = rx1364_cur."from"()
    inc rx1364_pos
    rx1364_cur."!cursor_from"(rx1364_pos)
    ge rx1364_pos, rx1364_eos, rxscan1368_done
  rxscan1368_scan:
    set_addr $I10, rxscan1368_loop
    rx1364_cur."!mark_push"(0, rx1364_pos, $I10)
  rxscan1368_done:
.annotate 'line', 606
  # rx subcapture "sym"
    set_addr $I10, rxcap_1369_fail
    rx1364_cur."!mark_push"(0, rx1364_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1364_pos, 2
    gt $I11, rx1364_eos, rx1364_fail
    sub $I11, rx1364_pos, rx1364_off
    substr $S10, rx1364_tgt, $I11, 2
    ne $S10, "+&", rx1364_fail
    add rx1364_pos, 2
    set_addr $I10, rxcap_1369_fail
    ($I12, $I11) = rx1364_cur."!mark_peek"($I10)
    rx1364_cur."!cursor_pos"($I11)
    ($P10) = rx1364_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1364_pos, "")
    rx1364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1369_done
  rxcap_1369_fail:
    goto rx1364_fail
  rxcap_1369_done:
  # rx subrule "O" subtype=capture negate=
    rx1364_cur."!cursor_pos"(rx1364_pos)
    $P10 = rx1364_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1364_fail
    rx1364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1364_pos = $P10."pos"()
  # rx pass
    rx1364_cur."!cursor_pass"(rx1364_pos, "infix:sym<+&>")
    if_null rx1364_debug, debug_990
    rx1364_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1364_pos)
  debug_990:
    .return (rx1364_cur)
  rx1364_restart:
.annotate 'line', 4
    if_null rx1364_debug, debug_991
    rx1364_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_991:
  rx1364_fail:
    (rx1364_rep, rx1364_pos, $I10, $P10) = rx1364_cur."!mark_fail"(0)
    lt rx1364_pos, -1, rx1364_done
    eq rx1364_pos, -1, rx1364_fail
    jump $I10
  rx1364_done:
    rx1364_cur."!cursor_fail"()
    if_null rx1364_debug, debug_992
    rx1364_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_992:
    .return (rx1364_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("311_1298845521.609") :method
.annotate 'line', 4
    $P1366 = self."!PREFIX__!subrule"("O", "+&")
    new $P1367, "ResizablePMCArray"
    push $P1367, $P1366
    .return ($P1367)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("312_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1371_tgt
    .local int rx1371_pos
    .local int rx1371_off
    .local int rx1371_eos
    .local int rx1371_rep
    .local pmc rx1371_cur
    .local pmc rx1371_debug
    (rx1371_cur, rx1371_pos, rx1371_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1371_cur
    .local pmc match
    .lex "$/", match
    length rx1371_eos, rx1371_tgt
    gt rx1371_pos, rx1371_eos, rx1371_done
    set rx1371_off, 0
    lt rx1371_pos, 2, rx1371_start
    sub rx1371_off, rx1371_pos, 1
    substr rx1371_tgt, rx1371_tgt, rx1371_off
  rx1371_start:
    eq $I10, 1, rx1371_restart
    if_null rx1371_debug, debug_993
    rx1371_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1375_done
    goto rxscan1375_scan
  rxscan1375_loop:
    (rx1371_pos) = rx1371_cur."from"()
    inc rx1371_pos
    rx1371_cur."!cursor_from"(rx1371_pos)
    ge rx1371_pos, rx1371_eos, rxscan1375_done
  rxscan1375_scan:
    set_addr $I10, rxscan1375_loop
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxscan1375_done:
.annotate 'line', 608
  # rx subcapture "sym"
    set_addr $I10, rxcap_1376_fail
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  # rx literal  "+"
    add $I11, rx1371_pos, 1
    gt $I11, rx1371_eos, rx1371_fail
    sub $I11, rx1371_pos, rx1371_off
    ord $I11, rx1371_tgt, $I11
    ne $I11, 43, rx1371_fail
    add rx1371_pos, 1
    set_addr $I10, rxcap_1376_fail
    ($I12, $I11) = rx1371_cur."!mark_peek"($I10)
    rx1371_cur."!cursor_pos"($I11)
    ($P10) = rx1371_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1371_pos, "")
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1376_done
  rxcap_1376_fail:
    goto rx1371_fail
  rxcap_1376_done:
  # rx subrule "O" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1371_fail
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1371_pos = $P10."pos"()
  # rx pass
    rx1371_cur."!cursor_pass"(rx1371_pos, "infix:sym<+>")
    if_null rx1371_debug, debug_994
    rx1371_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1371_pos)
  debug_994:
    .return (rx1371_cur)
  rx1371_restart:
.annotate 'line', 4
    if_null rx1371_debug, debug_995
    rx1371_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_995:
  rx1371_fail:
    (rx1371_rep, rx1371_pos, $I10, $P10) = rx1371_cur."!mark_fail"(0)
    lt rx1371_pos, -1, rx1371_done
    eq rx1371_pos, -1, rx1371_fail
    jump $I10
  rx1371_done:
    rx1371_cur."!cursor_fail"()
    if_null rx1371_debug, debug_996
    rx1371_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_996:
    .return (rx1371_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("313_1298845521.609") :method
.annotate 'line', 4
    $P1373 = self."!PREFIX__!subrule"("O", "+")
    new $P1374, "ResizablePMCArray"
    push $P1374, $P1373
    .return ($P1374)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("314_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1378_tgt
    .local int rx1378_pos
    .local int rx1378_off
    .local int rx1378_eos
    .local int rx1378_rep
    .local pmc rx1378_cur
    .local pmc rx1378_debug
    (rx1378_cur, rx1378_pos, rx1378_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1378_cur
    .local pmc match
    .lex "$/", match
    length rx1378_eos, rx1378_tgt
    gt rx1378_pos, rx1378_eos, rx1378_done
    set rx1378_off, 0
    lt rx1378_pos, 2, rx1378_start
    sub rx1378_off, rx1378_pos, 1
    substr rx1378_tgt, rx1378_tgt, rx1378_off
  rx1378_start:
    eq $I10, 1, rx1378_restart
    if_null rx1378_debug, debug_997
    rx1378_cur."!cursor_debug"("START", "infix:sym<->")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1382_done
    goto rxscan1382_scan
  rxscan1382_loop:
    (rx1378_pos) = rx1378_cur."from"()
    inc rx1378_pos
    rx1378_cur."!cursor_from"(rx1378_pos)
    ge rx1378_pos, rx1378_eos, rxscan1382_done
  rxscan1382_scan:
    set_addr $I10, rxscan1382_loop
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
  rxscan1382_done:
.annotate 'line', 609
  # rx subcapture "sym"
    set_addr $I10, rxcap_1383_fail
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
  # rx literal  "-"
    add $I11, rx1378_pos, 1
    gt $I11, rx1378_eos, rx1378_fail
    sub $I11, rx1378_pos, rx1378_off
    ord $I11, rx1378_tgt, $I11
    ne $I11, 45, rx1378_fail
    add rx1378_pos, 1
    set_addr $I10, rxcap_1383_fail
    ($I12, $I11) = rx1378_cur."!mark_peek"($I10)
    rx1378_cur."!cursor_pos"($I11)
    ($P10) = rx1378_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1378_pos, "")
    rx1378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1383_done
  rxcap_1383_fail:
    goto rx1378_fail
  rxcap_1383_done:
  # rx subrule "O" subtype=capture negate=
    rx1378_cur."!cursor_pos"(rx1378_pos)
    $P10 = rx1378_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1378_fail
    rx1378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1378_pos = $P10."pos"()
  # rx pass
    rx1378_cur."!cursor_pass"(rx1378_pos, "infix:sym<->")
    if_null rx1378_debug, debug_998
    rx1378_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1378_pos)
  debug_998:
    .return (rx1378_cur)
  rx1378_restart:
.annotate 'line', 4
    if_null rx1378_debug, debug_999
    rx1378_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_999:
  rx1378_fail:
    (rx1378_rep, rx1378_pos, $I10, $P10) = rx1378_cur."!mark_fail"(0)
    lt rx1378_pos, -1, rx1378_done
    eq rx1378_pos, -1, rx1378_fail
    jump $I10
  rx1378_done:
    rx1378_cur."!cursor_fail"()
    if_null rx1378_debug, debug_1000
    rx1378_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1000:
    .return (rx1378_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("315_1298845521.609") :method
.annotate 'line', 4
    $P1380 = self."!PREFIX__!subrule"("O", "-")
    new $P1381, "ResizablePMCArray"
    push $P1381, $P1380
    .return ($P1381)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("316_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1385_tgt
    .local int rx1385_pos
    .local int rx1385_off
    .local int rx1385_eos
    .local int rx1385_rep
    .local pmc rx1385_cur
    .local pmc rx1385_debug
    (rx1385_cur, rx1385_pos, rx1385_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1385_cur
    .local pmc match
    .lex "$/", match
    length rx1385_eos, rx1385_tgt
    gt rx1385_pos, rx1385_eos, rx1385_done
    set rx1385_off, 0
    lt rx1385_pos, 2, rx1385_start
    sub rx1385_off, rx1385_pos, 1
    substr rx1385_tgt, rx1385_tgt, rx1385_off
  rx1385_start:
    eq $I10, 1, rx1385_restart
    if_null rx1385_debug, debug_1001
    rx1385_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1389_done
    goto rxscan1389_scan
  rxscan1389_loop:
    (rx1385_pos) = rx1385_cur."from"()
    inc rx1385_pos
    rx1385_cur."!cursor_from"(rx1385_pos)
    ge rx1385_pos, rx1385_eos, rxscan1389_done
  rxscan1389_scan:
    set_addr $I10, rxscan1389_loop
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  rxscan1389_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1390_fail
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1385_pos, 2
    gt $I11, rx1385_eos, rx1385_fail
    sub $I11, rx1385_pos, rx1385_off
    substr $S10, rx1385_tgt, $I11, 2
    ne $S10, "+|", rx1385_fail
    add rx1385_pos, 2
    set_addr $I10, rxcap_1390_fail
    ($I12, $I11) = rx1385_cur."!mark_peek"($I10)
    rx1385_cur."!cursor_pos"($I11)
    ($P10) = rx1385_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1385_pos, "")
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1390_done
  rxcap_1390_fail:
    goto rx1385_fail
  rxcap_1390_done:
  # rx subrule "O" subtype=capture negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1385_fail
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1385_pos = $P10."pos"()
  # rx pass
    rx1385_cur."!cursor_pass"(rx1385_pos, "infix:sym<+|>")
    if_null rx1385_debug, debug_1002
    rx1385_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1385_pos)
  debug_1002:
    .return (rx1385_cur)
  rx1385_restart:
.annotate 'line', 4
    if_null rx1385_debug, debug_1003
    rx1385_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1003:
  rx1385_fail:
    (rx1385_rep, rx1385_pos, $I10, $P10) = rx1385_cur."!mark_fail"(0)
    lt rx1385_pos, -1, rx1385_done
    eq rx1385_pos, -1, rx1385_fail
    jump $I10
  rx1385_done:
    rx1385_cur."!cursor_fail"()
    if_null rx1385_debug, debug_1004
    rx1385_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1004:
    .return (rx1385_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("317_1298845521.609") :method
.annotate 'line', 4
    $P1387 = self."!PREFIX__!subrule"("O", "+|")
    new $P1388, "ResizablePMCArray"
    push $P1388, $P1387
    .return ($P1388)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("318_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1392_tgt
    .local int rx1392_pos
    .local int rx1392_off
    .local int rx1392_eos
    .local int rx1392_rep
    .local pmc rx1392_cur
    .local pmc rx1392_debug
    (rx1392_cur, rx1392_pos, rx1392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1392_cur
    .local pmc match
    .lex "$/", match
    length rx1392_eos, rx1392_tgt
    gt rx1392_pos, rx1392_eos, rx1392_done
    set rx1392_off, 0
    lt rx1392_pos, 2, rx1392_start
    sub rx1392_off, rx1392_pos, 1
    substr rx1392_tgt, rx1392_tgt, rx1392_off
  rx1392_start:
    eq $I10, 1, rx1392_restart
    if_null rx1392_debug, debug_1005
    rx1392_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1396_done
    goto rxscan1396_scan
  rxscan1396_loop:
    (rx1392_pos) = rx1392_cur."from"()
    inc rx1392_pos
    rx1392_cur."!cursor_from"(rx1392_pos)
    ge rx1392_pos, rx1392_eos, rxscan1396_done
  rxscan1396_scan:
    set_addr $I10, rxscan1396_loop
    rx1392_cur."!mark_push"(0, rx1392_pos, $I10)
  rxscan1396_done:
.annotate 'line', 611
  # rx subcapture "sym"
    set_addr $I10, rxcap_1397_fail
    rx1392_cur."!mark_push"(0, rx1392_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1392_pos, 2
    gt $I11, rx1392_eos, rx1392_fail
    sub $I11, rx1392_pos, rx1392_off
    substr $S10, rx1392_tgt, $I11, 2
    ne $S10, "+^", rx1392_fail
    add rx1392_pos, 2
    set_addr $I10, rxcap_1397_fail
    ($I12, $I11) = rx1392_cur."!mark_peek"($I10)
    rx1392_cur."!cursor_pos"($I11)
    ($P10) = rx1392_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1392_pos, "")
    rx1392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1397_done
  rxcap_1397_fail:
    goto rx1392_fail
  rxcap_1397_done:
  # rx subrule "O" subtype=capture negate=
    rx1392_cur."!cursor_pos"(rx1392_pos)
    $P10 = rx1392_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1392_fail
    rx1392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1392_pos = $P10."pos"()
  # rx pass
    rx1392_cur."!cursor_pass"(rx1392_pos, "infix:sym<+^>")
    if_null rx1392_debug, debug_1006
    rx1392_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1392_pos)
  debug_1006:
    .return (rx1392_cur)
  rx1392_restart:
.annotate 'line', 4
    if_null rx1392_debug, debug_1007
    rx1392_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1007:
  rx1392_fail:
    (rx1392_rep, rx1392_pos, $I10, $P10) = rx1392_cur."!mark_fail"(0)
    lt rx1392_pos, -1, rx1392_done
    eq rx1392_pos, -1, rx1392_fail
    jump $I10
  rx1392_done:
    rx1392_cur."!cursor_fail"()
    if_null rx1392_debug, debug_1008
    rx1392_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1008:
    .return (rx1392_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("319_1298845521.609") :method
.annotate 'line', 4
    $P1394 = self."!PREFIX__!subrule"("O", "+^")
    new $P1395, "ResizablePMCArray"
    push $P1395, $P1394
    .return ($P1395)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("320_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1399_tgt
    .local int rx1399_pos
    .local int rx1399_off
    .local int rx1399_eos
    .local int rx1399_rep
    .local pmc rx1399_cur
    .local pmc rx1399_debug
    (rx1399_cur, rx1399_pos, rx1399_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1399_cur
    .local pmc match
    .lex "$/", match
    length rx1399_eos, rx1399_tgt
    gt rx1399_pos, rx1399_eos, rx1399_done
    set rx1399_off, 0
    lt rx1399_pos, 2, rx1399_start
    sub rx1399_off, rx1399_pos, 1
    substr rx1399_tgt, rx1399_tgt, rx1399_off
  rx1399_start:
    eq $I10, 1, rx1399_restart
    if_null rx1399_debug, debug_1009
    rx1399_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1403_done
    goto rxscan1403_scan
  rxscan1403_loop:
    (rx1399_pos) = rx1399_cur."from"()
    inc rx1399_pos
    rx1399_cur."!cursor_from"(rx1399_pos)
    ge rx1399_pos, rx1399_eos, rxscan1403_done
  rxscan1403_scan:
    set_addr $I10, rxscan1403_loop
    rx1399_cur."!mark_push"(0, rx1399_pos, $I10)
  rxscan1403_done:
.annotate 'line', 613
  # rx subcapture "sym"
    set_addr $I10, rxcap_1404_fail
    rx1399_cur."!mark_push"(0, rx1399_pos, $I10)
  # rx literal  "~"
    add $I11, rx1399_pos, 1
    gt $I11, rx1399_eos, rx1399_fail
    sub $I11, rx1399_pos, rx1399_off
    ord $I11, rx1399_tgt, $I11
    ne $I11, 126, rx1399_fail
    add rx1399_pos, 1
    set_addr $I10, rxcap_1404_fail
    ($I12, $I11) = rx1399_cur."!mark_peek"($I10)
    rx1399_cur."!cursor_pos"($I11)
    ($P10) = rx1399_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1399_pos, "")
    rx1399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1404_done
  rxcap_1404_fail:
    goto rx1399_fail
  rxcap_1404_done:
  # rx subrule "O" subtype=capture negate=
    rx1399_cur."!cursor_pos"(rx1399_pos)
    $P10 = rx1399_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1399_fail
    rx1399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1399_pos = $P10."pos"()
  # rx pass
    rx1399_cur."!cursor_pass"(rx1399_pos, "infix:sym<~>")
    if_null rx1399_debug, debug_1010
    rx1399_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1399_pos)
  debug_1010:
    .return (rx1399_cur)
  rx1399_restart:
.annotate 'line', 4
    if_null rx1399_debug, debug_1011
    rx1399_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1011:
  rx1399_fail:
    (rx1399_rep, rx1399_pos, $I10, $P10) = rx1399_cur."!mark_fail"(0)
    lt rx1399_pos, -1, rx1399_done
    eq rx1399_pos, -1, rx1399_fail
    jump $I10
  rx1399_done:
    rx1399_cur."!cursor_fail"()
    if_null rx1399_debug, debug_1012
    rx1399_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1012:
    .return (rx1399_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("321_1298845521.609") :method
.annotate 'line', 4
    $P1401 = self."!PREFIX__!subrule"("O", "~")
    new $P1402, "ResizablePMCArray"
    push $P1402, $P1401
    .return ($P1402)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("322_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1406_tgt
    .local int rx1406_pos
    .local int rx1406_off
    .local int rx1406_eos
    .local int rx1406_rep
    .local pmc rx1406_cur
    .local pmc rx1406_debug
    (rx1406_cur, rx1406_pos, rx1406_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1406_cur
    .local pmc match
    .lex "$/", match
    length rx1406_eos, rx1406_tgt
    gt rx1406_pos, rx1406_eos, rx1406_done
    set rx1406_off, 0
    lt rx1406_pos, 2, rx1406_start
    sub rx1406_off, rx1406_pos, 1
    substr rx1406_tgt, rx1406_tgt, rx1406_off
  rx1406_start:
    eq $I10, 1, rx1406_restart
    if_null rx1406_debug, debug_1013
    rx1406_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1410_done
    goto rxscan1410_scan
  rxscan1410_loop:
    (rx1406_pos) = rx1406_cur."from"()
    inc rx1406_pos
    rx1406_cur."!cursor_from"(rx1406_pos)
    ge rx1406_pos, rx1406_eos, rxscan1410_done
  rxscan1410_scan:
    set_addr $I10, rxscan1410_loop
    rx1406_cur."!mark_push"(0, rx1406_pos, $I10)
  rxscan1410_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1411_fail
    rx1406_cur."!mark_push"(0, rx1406_pos, $I10)
  # rx literal  "=="
    add $I11, rx1406_pos, 2
    gt $I11, rx1406_eos, rx1406_fail
    sub $I11, rx1406_pos, rx1406_off
    substr $S10, rx1406_tgt, $I11, 2
    ne $S10, "==", rx1406_fail
    add rx1406_pos, 2
    set_addr $I10, rxcap_1411_fail
    ($I12, $I11) = rx1406_cur."!mark_peek"($I10)
    rx1406_cur."!cursor_pos"($I11)
    ($P10) = rx1406_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1406_pos, "")
    rx1406_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1411_done
  rxcap_1411_fail:
    goto rx1406_fail
  rxcap_1411_done:
  # rx subrule "O" subtype=capture negate=
    rx1406_cur."!cursor_pos"(rx1406_pos)
    $P10 = rx1406_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1406_fail
    rx1406_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1406_pos = $P10."pos"()
  # rx pass
    rx1406_cur."!cursor_pass"(rx1406_pos, "infix:sym<==>")
    if_null rx1406_debug, debug_1014
    rx1406_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1406_pos)
  debug_1014:
    .return (rx1406_cur)
  rx1406_restart:
.annotate 'line', 4
    if_null rx1406_debug, debug_1015
    rx1406_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1015:
  rx1406_fail:
    (rx1406_rep, rx1406_pos, $I10, $P10) = rx1406_cur."!mark_fail"(0)
    lt rx1406_pos, -1, rx1406_done
    eq rx1406_pos, -1, rx1406_fail
    jump $I10
  rx1406_done:
    rx1406_cur."!cursor_fail"()
    if_null rx1406_debug, debug_1016
    rx1406_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1016:
    .return (rx1406_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("323_1298845521.609") :method
.annotate 'line', 4
    $P1408 = self."!PREFIX__!subrule"("O", "==")
    new $P1409, "ResizablePMCArray"
    push $P1409, $P1408
    .return ($P1409)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("324_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1413_tgt
    .local int rx1413_pos
    .local int rx1413_off
    .local int rx1413_eos
    .local int rx1413_rep
    .local pmc rx1413_cur
    .local pmc rx1413_debug
    (rx1413_cur, rx1413_pos, rx1413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1413_cur
    .local pmc match
    .lex "$/", match
    length rx1413_eos, rx1413_tgt
    gt rx1413_pos, rx1413_eos, rx1413_done
    set rx1413_off, 0
    lt rx1413_pos, 2, rx1413_start
    sub rx1413_off, rx1413_pos, 1
    substr rx1413_tgt, rx1413_tgt, rx1413_off
  rx1413_start:
    eq $I10, 1, rx1413_restart
    if_null rx1413_debug, debug_1017
    rx1413_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1417_done
    goto rxscan1417_scan
  rxscan1417_loop:
    (rx1413_pos) = rx1413_cur."from"()
    inc rx1413_pos
    rx1413_cur."!cursor_from"(rx1413_pos)
    ge rx1413_pos, rx1413_eos, rxscan1417_done
  rxscan1417_scan:
    set_addr $I10, rxscan1417_loop
    rx1413_cur."!mark_push"(0, rx1413_pos, $I10)
  rxscan1417_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1418_fail
    rx1413_cur."!mark_push"(0, rx1413_pos, $I10)
  # rx literal  "!="
    add $I11, rx1413_pos, 2
    gt $I11, rx1413_eos, rx1413_fail
    sub $I11, rx1413_pos, rx1413_off
    substr $S10, rx1413_tgt, $I11, 2
    ne $S10, "!=", rx1413_fail
    add rx1413_pos, 2
    set_addr $I10, rxcap_1418_fail
    ($I12, $I11) = rx1413_cur."!mark_peek"($I10)
    rx1413_cur."!cursor_pos"($I11)
    ($P10) = rx1413_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1413_pos, "")
    rx1413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1418_done
  rxcap_1418_fail:
    goto rx1413_fail
  rxcap_1418_done:
  # rx subrule "O" subtype=capture negate=
    rx1413_cur."!cursor_pos"(rx1413_pos)
    $P10 = rx1413_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1413_fail
    rx1413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1413_pos = $P10."pos"()
  # rx pass
    rx1413_cur."!cursor_pass"(rx1413_pos, "infix:sym<!=>")
    if_null rx1413_debug, debug_1018
    rx1413_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1413_pos)
  debug_1018:
    .return (rx1413_cur)
  rx1413_restart:
.annotate 'line', 4
    if_null rx1413_debug, debug_1019
    rx1413_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1019:
  rx1413_fail:
    (rx1413_rep, rx1413_pos, $I10, $P10) = rx1413_cur."!mark_fail"(0)
    lt rx1413_pos, -1, rx1413_done
    eq rx1413_pos, -1, rx1413_fail
    jump $I10
  rx1413_done:
    rx1413_cur."!cursor_fail"()
    if_null rx1413_debug, debug_1020
    rx1413_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1020:
    .return (rx1413_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("325_1298845521.609") :method
.annotate 'line', 4
    $P1415 = self."!PREFIX__!subrule"("O", "!=")
    new $P1416, "ResizablePMCArray"
    push $P1416, $P1415
    .return ($P1416)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("326_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1420_tgt
    .local int rx1420_pos
    .local int rx1420_off
    .local int rx1420_eos
    .local int rx1420_rep
    .local pmc rx1420_cur
    .local pmc rx1420_debug
    (rx1420_cur, rx1420_pos, rx1420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1420_cur
    .local pmc match
    .lex "$/", match
    length rx1420_eos, rx1420_tgt
    gt rx1420_pos, rx1420_eos, rx1420_done
    set rx1420_off, 0
    lt rx1420_pos, 2, rx1420_start
    sub rx1420_off, rx1420_pos, 1
    substr rx1420_tgt, rx1420_tgt, rx1420_off
  rx1420_start:
    eq $I10, 1, rx1420_restart
    if_null rx1420_debug, debug_1021
    rx1420_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1424_done
    goto rxscan1424_scan
  rxscan1424_loop:
    (rx1420_pos) = rx1420_cur."from"()
    inc rx1420_pos
    rx1420_cur."!cursor_from"(rx1420_pos)
    ge rx1420_pos, rx1420_eos, rxscan1424_done
  rxscan1424_scan:
    set_addr $I10, rxscan1424_loop
    rx1420_cur."!mark_push"(0, rx1420_pos, $I10)
  rxscan1424_done:
.annotate 'line', 617
  # rx subcapture "sym"
    set_addr $I10, rxcap_1425_fail
    rx1420_cur."!mark_push"(0, rx1420_pos, $I10)
  # rx literal  "<="
    add $I11, rx1420_pos, 2
    gt $I11, rx1420_eos, rx1420_fail
    sub $I11, rx1420_pos, rx1420_off
    substr $S10, rx1420_tgt, $I11, 2
    ne $S10, "<=", rx1420_fail
    add rx1420_pos, 2
    set_addr $I10, rxcap_1425_fail
    ($I12, $I11) = rx1420_cur."!mark_peek"($I10)
    rx1420_cur."!cursor_pos"($I11)
    ($P10) = rx1420_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1420_pos, "")
    rx1420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1425_done
  rxcap_1425_fail:
    goto rx1420_fail
  rxcap_1425_done:
  # rx subrule "O" subtype=capture negate=
    rx1420_cur."!cursor_pos"(rx1420_pos)
    $P10 = rx1420_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1420_fail
    rx1420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1420_pos = $P10."pos"()
  # rx pass
    rx1420_cur."!cursor_pass"(rx1420_pos, "infix:sym<<=>")
    if_null rx1420_debug, debug_1022
    rx1420_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1420_pos)
  debug_1022:
    .return (rx1420_cur)
  rx1420_restart:
.annotate 'line', 4
    if_null rx1420_debug, debug_1023
    rx1420_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1023:
  rx1420_fail:
    (rx1420_rep, rx1420_pos, $I10, $P10) = rx1420_cur."!mark_fail"(0)
    lt rx1420_pos, -1, rx1420_done
    eq rx1420_pos, -1, rx1420_fail
    jump $I10
  rx1420_done:
    rx1420_cur."!cursor_fail"()
    if_null rx1420_debug, debug_1024
    rx1420_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1024:
    .return (rx1420_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("327_1298845521.609") :method
.annotate 'line', 4
    $P1422 = self."!PREFIX__!subrule"("O", "<=")
    new $P1423, "ResizablePMCArray"
    push $P1423, $P1422
    .return ($P1423)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("328_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1427_tgt
    .local int rx1427_pos
    .local int rx1427_off
    .local int rx1427_eos
    .local int rx1427_rep
    .local pmc rx1427_cur
    .local pmc rx1427_debug
    (rx1427_cur, rx1427_pos, rx1427_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1427_cur
    .local pmc match
    .lex "$/", match
    length rx1427_eos, rx1427_tgt
    gt rx1427_pos, rx1427_eos, rx1427_done
    set rx1427_off, 0
    lt rx1427_pos, 2, rx1427_start
    sub rx1427_off, rx1427_pos, 1
    substr rx1427_tgt, rx1427_tgt, rx1427_off
  rx1427_start:
    eq $I10, 1, rx1427_restart
    if_null rx1427_debug, debug_1025
    rx1427_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1431_done
    goto rxscan1431_scan
  rxscan1431_loop:
    (rx1427_pos) = rx1427_cur."from"()
    inc rx1427_pos
    rx1427_cur."!cursor_from"(rx1427_pos)
    ge rx1427_pos, rx1427_eos, rxscan1431_done
  rxscan1431_scan:
    set_addr $I10, rxscan1431_loop
    rx1427_cur."!mark_push"(0, rx1427_pos, $I10)
  rxscan1431_done:
.annotate 'line', 618
  # rx subcapture "sym"
    set_addr $I10, rxcap_1432_fail
    rx1427_cur."!mark_push"(0, rx1427_pos, $I10)
  # rx literal  ">="
    add $I11, rx1427_pos, 2
    gt $I11, rx1427_eos, rx1427_fail
    sub $I11, rx1427_pos, rx1427_off
    substr $S10, rx1427_tgt, $I11, 2
    ne $S10, ">=", rx1427_fail
    add rx1427_pos, 2
    set_addr $I10, rxcap_1432_fail
    ($I12, $I11) = rx1427_cur."!mark_peek"($I10)
    rx1427_cur."!cursor_pos"($I11)
    ($P10) = rx1427_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1427_pos, "")
    rx1427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1432_done
  rxcap_1432_fail:
    goto rx1427_fail
  rxcap_1432_done:
  # rx subrule "O" subtype=capture negate=
    rx1427_cur."!cursor_pos"(rx1427_pos)
    $P10 = rx1427_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1427_fail
    rx1427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1427_pos = $P10."pos"()
  # rx pass
    rx1427_cur."!cursor_pass"(rx1427_pos, "infix:sym<>=>")
    if_null rx1427_debug, debug_1026
    rx1427_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1427_pos)
  debug_1026:
    .return (rx1427_cur)
  rx1427_restart:
.annotate 'line', 4
    if_null rx1427_debug, debug_1027
    rx1427_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1027:
  rx1427_fail:
    (rx1427_rep, rx1427_pos, $I10, $P10) = rx1427_cur."!mark_fail"(0)
    lt rx1427_pos, -1, rx1427_done
    eq rx1427_pos, -1, rx1427_fail
    jump $I10
  rx1427_done:
    rx1427_cur."!cursor_fail"()
    if_null rx1427_debug, debug_1028
    rx1427_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1028:
    .return (rx1427_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("329_1298845521.609") :method
.annotate 'line', 4
    $P1429 = self."!PREFIX__!subrule"("O", ">=")
    new $P1430, "ResizablePMCArray"
    push $P1430, $P1429
    .return ($P1430)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("330_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1434_tgt
    .local int rx1434_pos
    .local int rx1434_off
    .local int rx1434_eos
    .local int rx1434_rep
    .local pmc rx1434_cur
    .local pmc rx1434_debug
    (rx1434_cur, rx1434_pos, rx1434_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1434_cur
    .local pmc match
    .lex "$/", match
    length rx1434_eos, rx1434_tgt
    gt rx1434_pos, rx1434_eos, rx1434_done
    set rx1434_off, 0
    lt rx1434_pos, 2, rx1434_start
    sub rx1434_off, rx1434_pos, 1
    substr rx1434_tgt, rx1434_tgt, rx1434_off
  rx1434_start:
    eq $I10, 1, rx1434_restart
    if_null rx1434_debug, debug_1029
    rx1434_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1438_done
    goto rxscan1438_scan
  rxscan1438_loop:
    (rx1434_pos) = rx1434_cur."from"()
    inc rx1434_pos
    rx1434_cur."!cursor_from"(rx1434_pos)
    ge rx1434_pos, rx1434_eos, rxscan1438_done
  rxscan1438_scan:
    set_addr $I10, rxscan1438_loop
    rx1434_cur."!mark_push"(0, rx1434_pos, $I10)
  rxscan1438_done:
.annotate 'line', 619
  # rx subcapture "sym"
    set_addr $I10, rxcap_1439_fail
    rx1434_cur."!mark_push"(0, rx1434_pos, $I10)
  # rx literal  "<"
    add $I11, rx1434_pos, 1
    gt $I11, rx1434_eos, rx1434_fail
    sub $I11, rx1434_pos, rx1434_off
    ord $I11, rx1434_tgt, $I11
    ne $I11, 60, rx1434_fail
    add rx1434_pos, 1
    set_addr $I10, rxcap_1439_fail
    ($I12, $I11) = rx1434_cur."!mark_peek"($I10)
    rx1434_cur."!cursor_pos"($I11)
    ($P10) = rx1434_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1434_pos, "")
    rx1434_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1439_done
  rxcap_1439_fail:
    goto rx1434_fail
  rxcap_1439_done:
  # rx subrule "O" subtype=capture negate=
    rx1434_cur."!cursor_pos"(rx1434_pos)
    $P10 = rx1434_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1434_fail
    rx1434_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1434_pos = $P10."pos"()
  # rx pass
    rx1434_cur."!cursor_pass"(rx1434_pos, "infix:sym<<>")
    if_null rx1434_debug, debug_1030
    rx1434_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1434_pos)
  debug_1030:
    .return (rx1434_cur)
  rx1434_restart:
.annotate 'line', 4
    if_null rx1434_debug, debug_1031
    rx1434_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1031:
  rx1434_fail:
    (rx1434_rep, rx1434_pos, $I10, $P10) = rx1434_cur."!mark_fail"(0)
    lt rx1434_pos, -1, rx1434_done
    eq rx1434_pos, -1, rx1434_fail
    jump $I10
  rx1434_done:
    rx1434_cur."!cursor_fail"()
    if_null rx1434_debug, debug_1032
    rx1434_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1032:
    .return (rx1434_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("331_1298845521.609") :method
.annotate 'line', 4
    $P1436 = self."!PREFIX__!subrule"("O", "<")
    new $P1437, "ResizablePMCArray"
    push $P1437, $P1436
    .return ($P1437)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("332_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1441_tgt
    .local int rx1441_pos
    .local int rx1441_off
    .local int rx1441_eos
    .local int rx1441_rep
    .local pmc rx1441_cur
    .local pmc rx1441_debug
    (rx1441_cur, rx1441_pos, rx1441_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1441_cur
    .local pmc match
    .lex "$/", match
    length rx1441_eos, rx1441_tgt
    gt rx1441_pos, rx1441_eos, rx1441_done
    set rx1441_off, 0
    lt rx1441_pos, 2, rx1441_start
    sub rx1441_off, rx1441_pos, 1
    substr rx1441_tgt, rx1441_tgt, rx1441_off
  rx1441_start:
    eq $I10, 1, rx1441_restart
    if_null rx1441_debug, debug_1033
    rx1441_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1445_done
    goto rxscan1445_scan
  rxscan1445_loop:
    (rx1441_pos) = rx1441_cur."from"()
    inc rx1441_pos
    rx1441_cur."!cursor_from"(rx1441_pos)
    ge rx1441_pos, rx1441_eos, rxscan1445_done
  rxscan1445_scan:
    set_addr $I10, rxscan1445_loop
    rx1441_cur."!mark_push"(0, rx1441_pos, $I10)
  rxscan1445_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1446_fail
    rx1441_cur."!mark_push"(0, rx1441_pos, $I10)
  # rx literal  ">"
    add $I11, rx1441_pos, 1
    gt $I11, rx1441_eos, rx1441_fail
    sub $I11, rx1441_pos, rx1441_off
    ord $I11, rx1441_tgt, $I11
    ne $I11, 62, rx1441_fail
    add rx1441_pos, 1
    set_addr $I10, rxcap_1446_fail
    ($I12, $I11) = rx1441_cur."!mark_peek"($I10)
    rx1441_cur."!cursor_pos"($I11)
    ($P10) = rx1441_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1441_pos, "")
    rx1441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1446_done
  rxcap_1446_fail:
    goto rx1441_fail
  rxcap_1446_done:
  # rx subrule "O" subtype=capture negate=
    rx1441_cur."!cursor_pos"(rx1441_pos)
    $P10 = rx1441_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1441_fail
    rx1441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1441_pos = $P10."pos"()
  # rx pass
    rx1441_cur."!cursor_pass"(rx1441_pos, "infix:sym<>>")
    if_null rx1441_debug, debug_1034
    rx1441_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1441_pos)
  debug_1034:
    .return (rx1441_cur)
  rx1441_restart:
.annotate 'line', 4
    if_null rx1441_debug, debug_1035
    rx1441_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1035:
  rx1441_fail:
    (rx1441_rep, rx1441_pos, $I10, $P10) = rx1441_cur."!mark_fail"(0)
    lt rx1441_pos, -1, rx1441_done
    eq rx1441_pos, -1, rx1441_fail
    jump $I10
  rx1441_done:
    rx1441_cur."!cursor_fail"()
    if_null rx1441_debug, debug_1036
    rx1441_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1036:
    .return (rx1441_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("333_1298845521.609") :method
.annotate 'line', 4
    $P1443 = self."!PREFIX__!subrule"("O", ">")
    new $P1444, "ResizablePMCArray"
    push $P1444, $P1443
    .return ($P1444)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("334_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1448_tgt
    .local int rx1448_pos
    .local int rx1448_off
    .local int rx1448_eos
    .local int rx1448_rep
    .local pmc rx1448_cur
    .local pmc rx1448_debug
    (rx1448_cur, rx1448_pos, rx1448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1448_cur
    .local pmc match
    .lex "$/", match
    length rx1448_eos, rx1448_tgt
    gt rx1448_pos, rx1448_eos, rx1448_done
    set rx1448_off, 0
    lt rx1448_pos, 2, rx1448_start
    sub rx1448_off, rx1448_pos, 1
    substr rx1448_tgt, rx1448_tgt, rx1448_off
  rx1448_start:
    eq $I10, 1, rx1448_restart
    if_null rx1448_debug, debug_1037
    rx1448_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1452_done
    goto rxscan1452_scan
  rxscan1452_loop:
    (rx1448_pos) = rx1448_cur."from"()
    inc rx1448_pos
    rx1448_cur."!cursor_from"(rx1448_pos)
    ge rx1448_pos, rx1448_eos, rxscan1452_done
  rxscan1452_scan:
    set_addr $I10, rxscan1452_loop
    rx1448_cur."!mark_push"(0, rx1448_pos, $I10)
  rxscan1452_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1453_fail
    rx1448_cur."!mark_push"(0, rx1448_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1448_pos, 2
    gt $I11, rx1448_eos, rx1448_fail
    sub $I11, rx1448_pos, rx1448_off
    substr $S10, rx1448_tgt, $I11, 2
    ne $S10, "eq", rx1448_fail
    add rx1448_pos, 2
    set_addr $I10, rxcap_1453_fail
    ($I12, $I11) = rx1448_cur."!mark_peek"($I10)
    rx1448_cur."!cursor_pos"($I11)
    ($P10) = rx1448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1448_pos, "")
    rx1448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1453_done
  rxcap_1453_fail:
    goto rx1448_fail
  rxcap_1453_done:
  # rx subrule "O" subtype=capture negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1448_fail
    rx1448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1448_pos = $P10."pos"()
  # rx pass
    rx1448_cur."!cursor_pass"(rx1448_pos, "infix:sym<eq>")
    if_null rx1448_debug, debug_1038
    rx1448_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1448_pos)
  debug_1038:
    .return (rx1448_cur)
  rx1448_restart:
.annotate 'line', 4
    if_null rx1448_debug, debug_1039
    rx1448_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1039:
  rx1448_fail:
    (rx1448_rep, rx1448_pos, $I10, $P10) = rx1448_cur."!mark_fail"(0)
    lt rx1448_pos, -1, rx1448_done
    eq rx1448_pos, -1, rx1448_fail
    jump $I10
  rx1448_done:
    rx1448_cur."!cursor_fail"()
    if_null rx1448_debug, debug_1040
    rx1448_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1040:
    .return (rx1448_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("335_1298845521.609") :method
.annotate 'line', 4
    $P1450 = self."!PREFIX__!subrule"("O", "eq")
    new $P1451, "ResizablePMCArray"
    push $P1451, $P1450
    .return ($P1451)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("336_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1455_tgt
    .local int rx1455_pos
    .local int rx1455_off
    .local int rx1455_eos
    .local int rx1455_rep
    .local pmc rx1455_cur
    .local pmc rx1455_debug
    (rx1455_cur, rx1455_pos, rx1455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1455_cur
    .local pmc match
    .lex "$/", match
    length rx1455_eos, rx1455_tgt
    gt rx1455_pos, rx1455_eos, rx1455_done
    set rx1455_off, 0
    lt rx1455_pos, 2, rx1455_start
    sub rx1455_off, rx1455_pos, 1
    substr rx1455_tgt, rx1455_tgt, rx1455_off
  rx1455_start:
    eq $I10, 1, rx1455_restart
    if_null rx1455_debug, debug_1041
    rx1455_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1459_done
    goto rxscan1459_scan
  rxscan1459_loop:
    (rx1455_pos) = rx1455_cur."from"()
    inc rx1455_pos
    rx1455_cur."!cursor_from"(rx1455_pos)
    ge rx1455_pos, rx1455_eos, rxscan1459_done
  rxscan1459_scan:
    set_addr $I10, rxscan1459_loop
    rx1455_cur."!mark_push"(0, rx1455_pos, $I10)
  rxscan1459_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1460_fail
    rx1455_cur."!mark_push"(0, rx1455_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1455_pos, 2
    gt $I11, rx1455_eos, rx1455_fail
    sub $I11, rx1455_pos, rx1455_off
    substr $S10, rx1455_tgt, $I11, 2
    ne $S10, "ne", rx1455_fail
    add rx1455_pos, 2
    set_addr $I10, rxcap_1460_fail
    ($I12, $I11) = rx1455_cur."!mark_peek"($I10)
    rx1455_cur."!cursor_pos"($I11)
    ($P10) = rx1455_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1455_pos, "")
    rx1455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1460_done
  rxcap_1460_fail:
    goto rx1455_fail
  rxcap_1460_done:
  # rx subrule "O" subtype=capture negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1455_fail
    rx1455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1455_pos = $P10."pos"()
  # rx pass
    rx1455_cur."!cursor_pass"(rx1455_pos, "infix:sym<ne>")
    if_null rx1455_debug, debug_1042
    rx1455_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1455_pos)
  debug_1042:
    .return (rx1455_cur)
  rx1455_restart:
.annotate 'line', 4
    if_null rx1455_debug, debug_1043
    rx1455_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1043:
  rx1455_fail:
    (rx1455_rep, rx1455_pos, $I10, $P10) = rx1455_cur."!mark_fail"(0)
    lt rx1455_pos, -1, rx1455_done
    eq rx1455_pos, -1, rx1455_fail
    jump $I10
  rx1455_done:
    rx1455_cur."!cursor_fail"()
    if_null rx1455_debug, debug_1044
    rx1455_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1044:
    .return (rx1455_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("337_1298845521.609") :method
.annotate 'line', 4
    $P1457 = self."!PREFIX__!subrule"("O", "ne")
    new $P1458, "ResizablePMCArray"
    push $P1458, $P1457
    .return ($P1458)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("338_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1462_tgt
    .local int rx1462_pos
    .local int rx1462_off
    .local int rx1462_eos
    .local int rx1462_rep
    .local pmc rx1462_cur
    .local pmc rx1462_debug
    (rx1462_cur, rx1462_pos, rx1462_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1462_cur
    .local pmc match
    .lex "$/", match
    length rx1462_eos, rx1462_tgt
    gt rx1462_pos, rx1462_eos, rx1462_done
    set rx1462_off, 0
    lt rx1462_pos, 2, rx1462_start
    sub rx1462_off, rx1462_pos, 1
    substr rx1462_tgt, rx1462_tgt, rx1462_off
  rx1462_start:
    eq $I10, 1, rx1462_restart
    if_null rx1462_debug, debug_1045
    rx1462_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1466_done
    goto rxscan1466_scan
  rxscan1466_loop:
    (rx1462_pos) = rx1462_cur."from"()
    inc rx1462_pos
    rx1462_cur."!cursor_from"(rx1462_pos)
    ge rx1462_pos, rx1462_eos, rxscan1466_done
  rxscan1466_scan:
    set_addr $I10, rxscan1466_loop
    rx1462_cur."!mark_push"(0, rx1462_pos, $I10)
  rxscan1466_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1467_fail
    rx1462_cur."!mark_push"(0, rx1462_pos, $I10)
  # rx literal  "le"
    add $I11, rx1462_pos, 2
    gt $I11, rx1462_eos, rx1462_fail
    sub $I11, rx1462_pos, rx1462_off
    substr $S10, rx1462_tgt, $I11, 2
    ne $S10, "le", rx1462_fail
    add rx1462_pos, 2
    set_addr $I10, rxcap_1467_fail
    ($I12, $I11) = rx1462_cur."!mark_peek"($I10)
    rx1462_cur."!cursor_pos"($I11)
    ($P10) = rx1462_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1462_pos, "")
    rx1462_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1467_done
  rxcap_1467_fail:
    goto rx1462_fail
  rxcap_1467_done:
  # rx subrule "O" subtype=capture negate=
    rx1462_cur."!cursor_pos"(rx1462_pos)
    $P10 = rx1462_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1462_fail
    rx1462_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1462_pos = $P10."pos"()
  # rx pass
    rx1462_cur."!cursor_pass"(rx1462_pos, "infix:sym<le>")
    if_null rx1462_debug, debug_1046
    rx1462_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1462_pos)
  debug_1046:
    .return (rx1462_cur)
  rx1462_restart:
.annotate 'line', 4
    if_null rx1462_debug, debug_1047
    rx1462_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1047:
  rx1462_fail:
    (rx1462_rep, rx1462_pos, $I10, $P10) = rx1462_cur."!mark_fail"(0)
    lt rx1462_pos, -1, rx1462_done
    eq rx1462_pos, -1, rx1462_fail
    jump $I10
  rx1462_done:
    rx1462_cur."!cursor_fail"()
    if_null rx1462_debug, debug_1048
    rx1462_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1048:
    .return (rx1462_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("339_1298845521.609") :method
.annotate 'line', 4
    $P1464 = self."!PREFIX__!subrule"("O", "le")
    new $P1465, "ResizablePMCArray"
    push $P1465, $P1464
    .return ($P1465)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("340_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1469_tgt
    .local int rx1469_pos
    .local int rx1469_off
    .local int rx1469_eos
    .local int rx1469_rep
    .local pmc rx1469_cur
    .local pmc rx1469_debug
    (rx1469_cur, rx1469_pos, rx1469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1469_cur
    .local pmc match
    .lex "$/", match
    length rx1469_eos, rx1469_tgt
    gt rx1469_pos, rx1469_eos, rx1469_done
    set rx1469_off, 0
    lt rx1469_pos, 2, rx1469_start
    sub rx1469_off, rx1469_pos, 1
    substr rx1469_tgt, rx1469_tgt, rx1469_off
  rx1469_start:
    eq $I10, 1, rx1469_restart
    if_null rx1469_debug, debug_1049
    rx1469_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1473_done
    goto rxscan1473_scan
  rxscan1473_loop:
    (rx1469_pos) = rx1469_cur."from"()
    inc rx1469_pos
    rx1469_cur."!cursor_from"(rx1469_pos)
    ge rx1469_pos, rx1469_eos, rxscan1473_done
  rxscan1473_scan:
    set_addr $I10, rxscan1473_loop
    rx1469_cur."!mark_push"(0, rx1469_pos, $I10)
  rxscan1473_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1474_fail
    rx1469_cur."!mark_push"(0, rx1469_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1469_pos, 2
    gt $I11, rx1469_eos, rx1469_fail
    sub $I11, rx1469_pos, rx1469_off
    substr $S10, rx1469_tgt, $I11, 2
    ne $S10, "ge", rx1469_fail
    add rx1469_pos, 2
    set_addr $I10, rxcap_1474_fail
    ($I12, $I11) = rx1469_cur."!mark_peek"($I10)
    rx1469_cur."!cursor_pos"($I11)
    ($P10) = rx1469_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1469_pos, "")
    rx1469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1474_done
  rxcap_1474_fail:
    goto rx1469_fail
  rxcap_1474_done:
  # rx subrule "O" subtype=capture negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1469_fail
    rx1469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1469_pos = $P10."pos"()
  # rx pass
    rx1469_cur."!cursor_pass"(rx1469_pos, "infix:sym<ge>")
    if_null rx1469_debug, debug_1050
    rx1469_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1469_pos)
  debug_1050:
    .return (rx1469_cur)
  rx1469_restart:
.annotate 'line', 4
    if_null rx1469_debug, debug_1051
    rx1469_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1051:
  rx1469_fail:
    (rx1469_rep, rx1469_pos, $I10, $P10) = rx1469_cur."!mark_fail"(0)
    lt rx1469_pos, -1, rx1469_done
    eq rx1469_pos, -1, rx1469_fail
    jump $I10
  rx1469_done:
    rx1469_cur."!cursor_fail"()
    if_null rx1469_debug, debug_1052
    rx1469_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1052:
    .return (rx1469_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("341_1298845521.609") :method
.annotate 'line', 4
    $P1471 = self."!PREFIX__!subrule"("O", "ge")
    new $P1472, "ResizablePMCArray"
    push $P1472, $P1471
    .return ($P1472)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("342_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1476_tgt
    .local int rx1476_pos
    .local int rx1476_off
    .local int rx1476_eos
    .local int rx1476_rep
    .local pmc rx1476_cur
    .local pmc rx1476_debug
    (rx1476_cur, rx1476_pos, rx1476_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1476_cur
    .local pmc match
    .lex "$/", match
    length rx1476_eos, rx1476_tgt
    gt rx1476_pos, rx1476_eos, rx1476_done
    set rx1476_off, 0
    lt rx1476_pos, 2, rx1476_start
    sub rx1476_off, rx1476_pos, 1
    substr rx1476_tgt, rx1476_tgt, rx1476_off
  rx1476_start:
    eq $I10, 1, rx1476_restart
    if_null rx1476_debug, debug_1053
    rx1476_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1480_done
    goto rxscan1480_scan
  rxscan1480_loop:
    (rx1476_pos) = rx1476_cur."from"()
    inc rx1476_pos
    rx1476_cur."!cursor_from"(rx1476_pos)
    ge rx1476_pos, rx1476_eos, rxscan1480_done
  rxscan1480_scan:
    set_addr $I10, rxscan1480_loop
    rx1476_cur."!mark_push"(0, rx1476_pos, $I10)
  rxscan1480_done:
.annotate 'line', 625
  # rx subcapture "sym"
    set_addr $I10, rxcap_1481_fail
    rx1476_cur."!mark_push"(0, rx1476_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1476_pos, 2
    gt $I11, rx1476_eos, rx1476_fail
    sub $I11, rx1476_pos, rx1476_off
    substr $S10, rx1476_tgt, $I11, 2
    ne $S10, "lt", rx1476_fail
    add rx1476_pos, 2
    set_addr $I10, rxcap_1481_fail
    ($I12, $I11) = rx1476_cur."!mark_peek"($I10)
    rx1476_cur."!cursor_pos"($I11)
    ($P10) = rx1476_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1476_pos, "")
    rx1476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1481_done
  rxcap_1481_fail:
    goto rx1476_fail
  rxcap_1481_done:
  # rx subrule "O" subtype=capture negate=
    rx1476_cur."!cursor_pos"(rx1476_pos)
    $P10 = rx1476_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1476_fail
    rx1476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1476_pos = $P10."pos"()
  # rx pass
    rx1476_cur."!cursor_pass"(rx1476_pos, "infix:sym<lt>")
    if_null rx1476_debug, debug_1054
    rx1476_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1476_pos)
  debug_1054:
    .return (rx1476_cur)
  rx1476_restart:
.annotate 'line', 4
    if_null rx1476_debug, debug_1055
    rx1476_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1055:
  rx1476_fail:
    (rx1476_rep, rx1476_pos, $I10, $P10) = rx1476_cur."!mark_fail"(0)
    lt rx1476_pos, -1, rx1476_done
    eq rx1476_pos, -1, rx1476_fail
    jump $I10
  rx1476_done:
    rx1476_cur."!cursor_fail"()
    if_null rx1476_debug, debug_1056
    rx1476_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1056:
    .return (rx1476_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("343_1298845521.609") :method
.annotate 'line', 4
    $P1478 = self."!PREFIX__!subrule"("O", "lt")
    new $P1479, "ResizablePMCArray"
    push $P1479, $P1478
    .return ($P1479)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("344_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1483_tgt
    .local int rx1483_pos
    .local int rx1483_off
    .local int rx1483_eos
    .local int rx1483_rep
    .local pmc rx1483_cur
    .local pmc rx1483_debug
    (rx1483_cur, rx1483_pos, rx1483_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1483_cur
    .local pmc match
    .lex "$/", match
    length rx1483_eos, rx1483_tgt
    gt rx1483_pos, rx1483_eos, rx1483_done
    set rx1483_off, 0
    lt rx1483_pos, 2, rx1483_start
    sub rx1483_off, rx1483_pos, 1
    substr rx1483_tgt, rx1483_tgt, rx1483_off
  rx1483_start:
    eq $I10, 1, rx1483_restart
    if_null rx1483_debug, debug_1057
    rx1483_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1487_done
    goto rxscan1487_scan
  rxscan1487_loop:
    (rx1483_pos) = rx1483_cur."from"()
    inc rx1483_pos
    rx1483_cur."!cursor_from"(rx1483_pos)
    ge rx1483_pos, rx1483_eos, rxscan1487_done
  rxscan1487_scan:
    set_addr $I10, rxscan1487_loop
    rx1483_cur."!mark_push"(0, rx1483_pos, $I10)
  rxscan1487_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1488_fail
    rx1483_cur."!mark_push"(0, rx1483_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1483_pos, 2
    gt $I11, rx1483_eos, rx1483_fail
    sub $I11, rx1483_pos, rx1483_off
    substr $S10, rx1483_tgt, $I11, 2
    ne $S10, "gt", rx1483_fail
    add rx1483_pos, 2
    set_addr $I10, rxcap_1488_fail
    ($I12, $I11) = rx1483_cur."!mark_peek"($I10)
    rx1483_cur."!cursor_pos"($I11)
    ($P10) = rx1483_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1483_pos, "")
    rx1483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1488_done
  rxcap_1488_fail:
    goto rx1483_fail
  rxcap_1488_done:
  # rx subrule "O" subtype=capture negate=
    rx1483_cur."!cursor_pos"(rx1483_pos)
    $P10 = rx1483_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1483_fail
    rx1483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1483_pos = $P10."pos"()
  # rx pass
    rx1483_cur."!cursor_pass"(rx1483_pos, "infix:sym<gt>")
    if_null rx1483_debug, debug_1058
    rx1483_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1483_pos)
  debug_1058:
    .return (rx1483_cur)
  rx1483_restart:
.annotate 'line', 4
    if_null rx1483_debug, debug_1059
    rx1483_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1059:
  rx1483_fail:
    (rx1483_rep, rx1483_pos, $I10, $P10) = rx1483_cur."!mark_fail"(0)
    lt rx1483_pos, -1, rx1483_done
    eq rx1483_pos, -1, rx1483_fail
    jump $I10
  rx1483_done:
    rx1483_cur."!cursor_fail"()
    if_null rx1483_debug, debug_1060
    rx1483_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1060:
    .return (rx1483_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("345_1298845521.609") :method
.annotate 'line', 4
    $P1485 = self."!PREFIX__!subrule"("O", "gt")
    new $P1486, "ResizablePMCArray"
    push $P1486, $P1485
    .return ($P1486)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("346_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1490_tgt
    .local int rx1490_pos
    .local int rx1490_off
    .local int rx1490_eos
    .local int rx1490_rep
    .local pmc rx1490_cur
    .local pmc rx1490_debug
    (rx1490_cur, rx1490_pos, rx1490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1490_cur
    .local pmc match
    .lex "$/", match
    length rx1490_eos, rx1490_tgt
    gt rx1490_pos, rx1490_eos, rx1490_done
    set rx1490_off, 0
    lt rx1490_pos, 2, rx1490_start
    sub rx1490_off, rx1490_pos, 1
    substr rx1490_tgt, rx1490_tgt, rx1490_off
  rx1490_start:
    eq $I10, 1, rx1490_restart
    if_null rx1490_debug, debug_1061
    rx1490_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1494_done
    goto rxscan1494_scan
  rxscan1494_loop:
    (rx1490_pos) = rx1490_cur."from"()
    inc rx1490_pos
    rx1490_cur."!cursor_from"(rx1490_pos)
    ge rx1490_pos, rx1490_eos, rxscan1494_done
  rxscan1494_scan:
    set_addr $I10, rxscan1494_loop
    rx1490_cur."!mark_push"(0, rx1490_pos, $I10)
  rxscan1494_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1495_fail
    rx1490_cur."!mark_push"(0, rx1490_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1490_pos, 3
    gt $I11, rx1490_eos, rx1490_fail
    sub $I11, rx1490_pos, rx1490_off
    substr $S10, rx1490_tgt, $I11, 3
    ne $S10, "=:=", rx1490_fail
    add rx1490_pos, 3
    set_addr $I10, rxcap_1495_fail
    ($I12, $I11) = rx1490_cur."!mark_peek"($I10)
    rx1490_cur."!cursor_pos"($I11)
    ($P10) = rx1490_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1490_pos, "")
    rx1490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1495_done
  rxcap_1495_fail:
    goto rx1490_fail
  rxcap_1495_done:
  # rx subrule "O" subtype=capture negate=
    rx1490_cur."!cursor_pos"(rx1490_pos)
    $P10 = rx1490_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1490_fail
    rx1490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1490_pos = $P10."pos"()
  # rx pass
    rx1490_cur."!cursor_pass"(rx1490_pos, "infix:sym<=:=>")
    if_null rx1490_debug, debug_1062
    rx1490_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1490_pos)
  debug_1062:
    .return (rx1490_cur)
  rx1490_restart:
.annotate 'line', 4
    if_null rx1490_debug, debug_1063
    rx1490_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1063:
  rx1490_fail:
    (rx1490_rep, rx1490_pos, $I10, $P10) = rx1490_cur."!mark_fail"(0)
    lt rx1490_pos, -1, rx1490_done
    eq rx1490_pos, -1, rx1490_fail
    jump $I10
  rx1490_done:
    rx1490_cur."!cursor_fail"()
    if_null rx1490_debug, debug_1064
    rx1490_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1064:
    .return (rx1490_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("347_1298845521.609") :method
.annotate 'line', 4
    $P1492 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1493, "ResizablePMCArray"
    push $P1493, $P1492
    .return ($P1493)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("348_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1497_tgt
    .local int rx1497_pos
    .local int rx1497_off
    .local int rx1497_eos
    .local int rx1497_rep
    .local pmc rx1497_cur
    .local pmc rx1497_debug
    (rx1497_cur, rx1497_pos, rx1497_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1497_cur
    .local pmc match
    .lex "$/", match
    length rx1497_eos, rx1497_tgt
    gt rx1497_pos, rx1497_eos, rx1497_done
    set rx1497_off, 0
    lt rx1497_pos, 2, rx1497_start
    sub rx1497_off, rx1497_pos, 1
    substr rx1497_tgt, rx1497_tgt, rx1497_off
  rx1497_start:
    eq $I10, 1, rx1497_restart
    if_null rx1497_debug, debug_1065
    rx1497_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1497_pos) = rx1497_cur."from"()
    inc rx1497_pos
    rx1497_cur."!cursor_from"(rx1497_pos)
    ge rx1497_pos, rx1497_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1497_cur."!mark_push"(0, rx1497_pos, $I10)
  rxscan1501_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1502_fail
    rx1497_cur."!mark_push"(0, rx1497_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1497_pos, 2
    gt $I11, rx1497_eos, rx1497_fail
    sub $I11, rx1497_pos, rx1497_off
    substr $S10, rx1497_tgt, $I11, 2
    ne $S10, "~~", rx1497_fail
    add rx1497_pos, 2
    set_addr $I10, rxcap_1502_fail
    ($I12, $I11) = rx1497_cur."!mark_peek"($I10)
    rx1497_cur."!cursor_pos"($I11)
    ($P10) = rx1497_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1497_pos, "")
    rx1497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1502_done
  rxcap_1502_fail:
    goto rx1497_fail
  rxcap_1502_done:
  # rx subrule "O" subtype=capture negate=
    rx1497_cur."!cursor_pos"(rx1497_pos)
    $P10 = rx1497_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1497_fail
    rx1497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1497_pos = $P10."pos"()
  # rx pass
    rx1497_cur."!cursor_pass"(rx1497_pos, "infix:sym<~~>")
    if_null rx1497_debug, debug_1066
    rx1497_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1497_pos)
  debug_1066:
    .return (rx1497_cur)
  rx1497_restart:
.annotate 'line', 4
    if_null rx1497_debug, debug_1067
    rx1497_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1067:
  rx1497_fail:
    (rx1497_rep, rx1497_pos, $I10, $P10) = rx1497_cur."!mark_fail"(0)
    lt rx1497_pos, -1, rx1497_done
    eq rx1497_pos, -1, rx1497_fail
    jump $I10
  rx1497_done:
    rx1497_cur."!cursor_fail"()
    if_null rx1497_debug, debug_1068
    rx1497_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1068:
    .return (rx1497_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("349_1298845521.609") :method
.annotate 'line', 4
    $P1499 = self."!PREFIX__!subrule"("O", "~~")
    new $P1500, "ResizablePMCArray"
    push $P1500, $P1499
    .return ($P1500)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("350_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1504_tgt
    .local int rx1504_pos
    .local int rx1504_off
    .local int rx1504_eos
    .local int rx1504_rep
    .local pmc rx1504_cur
    .local pmc rx1504_debug
    (rx1504_cur, rx1504_pos, rx1504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1504_cur
    .local pmc match
    .lex "$/", match
    length rx1504_eos, rx1504_tgt
    gt rx1504_pos, rx1504_eos, rx1504_done
    set rx1504_off, 0
    lt rx1504_pos, 2, rx1504_start
    sub rx1504_off, rx1504_pos, 1
    substr rx1504_tgt, rx1504_tgt, rx1504_off
  rx1504_start:
    eq $I10, 1, rx1504_restart
    if_null rx1504_debug, debug_1069
    rx1504_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1508_done
    goto rxscan1508_scan
  rxscan1508_loop:
    (rx1504_pos) = rx1504_cur."from"()
    inc rx1504_pos
    rx1504_cur."!cursor_from"(rx1504_pos)
    ge rx1504_pos, rx1504_eos, rxscan1508_done
  rxscan1508_scan:
    set_addr $I10, rxscan1508_loop
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  rxscan1508_done:
.annotate 'line', 630
  # rx subcapture "sym"
    set_addr $I10, rxcap_1509_fail
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1504_pos, 2
    gt $I11, rx1504_eos, rx1504_fail
    sub $I11, rx1504_pos, rx1504_off
    substr $S10, rx1504_tgt, $I11, 2
    ne $S10, "&&", rx1504_fail
    add rx1504_pos, 2
    set_addr $I10, rxcap_1509_fail
    ($I12, $I11) = rx1504_cur."!mark_peek"($I10)
    rx1504_cur."!cursor_pos"($I11)
    ($P10) = rx1504_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1504_pos, "")
    rx1504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1509_done
  rxcap_1509_fail:
    goto rx1504_fail
  rxcap_1509_done:
  # rx subrule "O" subtype=capture negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1504_fail
    rx1504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1504_pos = $P10."pos"()
  # rx pass
    rx1504_cur."!cursor_pass"(rx1504_pos, "infix:sym<&&>")
    if_null rx1504_debug, debug_1070
    rx1504_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1504_pos)
  debug_1070:
    .return (rx1504_cur)
  rx1504_restart:
.annotate 'line', 4
    if_null rx1504_debug, debug_1071
    rx1504_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1071:
  rx1504_fail:
    (rx1504_rep, rx1504_pos, $I10, $P10) = rx1504_cur."!mark_fail"(0)
    lt rx1504_pos, -1, rx1504_done
    eq rx1504_pos, -1, rx1504_fail
    jump $I10
  rx1504_done:
    rx1504_cur."!cursor_fail"()
    if_null rx1504_debug, debug_1072
    rx1504_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1072:
    .return (rx1504_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("351_1298845521.609") :method
.annotate 'line', 4
    $P1506 = self."!PREFIX__!subrule"("O", "&&")
    new $P1507, "ResizablePMCArray"
    push $P1507, $P1506
    .return ($P1507)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("352_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1511_tgt
    .local int rx1511_pos
    .local int rx1511_off
    .local int rx1511_eos
    .local int rx1511_rep
    .local pmc rx1511_cur
    .local pmc rx1511_debug
    (rx1511_cur, rx1511_pos, rx1511_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1511_cur
    .local pmc match
    .lex "$/", match
    length rx1511_eos, rx1511_tgt
    gt rx1511_pos, rx1511_eos, rx1511_done
    set rx1511_off, 0
    lt rx1511_pos, 2, rx1511_start
    sub rx1511_off, rx1511_pos, 1
    substr rx1511_tgt, rx1511_tgt, rx1511_off
  rx1511_start:
    eq $I10, 1, rx1511_restart
    if_null rx1511_debug, debug_1073
    rx1511_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1515_done
    goto rxscan1515_scan
  rxscan1515_loop:
    (rx1511_pos) = rx1511_cur."from"()
    inc rx1511_pos
    rx1511_cur."!cursor_from"(rx1511_pos)
    ge rx1511_pos, rx1511_eos, rxscan1515_done
  rxscan1515_scan:
    set_addr $I10, rxscan1515_loop
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxscan1515_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1516_fail
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  # rx literal  "||"
    add $I11, rx1511_pos, 2
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    substr $S10, rx1511_tgt, $I11, 2
    ne $S10, "||", rx1511_fail
    add rx1511_pos, 2
    set_addr $I10, rxcap_1516_fail
    ($I12, $I11) = rx1511_cur."!mark_peek"($I10)
    rx1511_cur."!cursor_pos"($I11)
    ($P10) = rx1511_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1511_pos, "")
    rx1511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1516_done
  rxcap_1516_fail:
    goto rx1511_fail
  rxcap_1516_done:
  # rx subrule "O" subtype=capture negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1511_fail
    rx1511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1511_pos = $P10."pos"()
  # rx pass
    rx1511_cur."!cursor_pass"(rx1511_pos, "infix:sym<||>")
    if_null rx1511_debug, debug_1074
    rx1511_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1511_pos)
  debug_1074:
    .return (rx1511_cur)
  rx1511_restart:
.annotate 'line', 4
    if_null rx1511_debug, debug_1075
    rx1511_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1075:
  rx1511_fail:
    (rx1511_rep, rx1511_pos, $I10, $P10) = rx1511_cur."!mark_fail"(0)
    lt rx1511_pos, -1, rx1511_done
    eq rx1511_pos, -1, rx1511_fail
    jump $I10
  rx1511_done:
    rx1511_cur."!cursor_fail"()
    if_null rx1511_debug, debug_1076
    rx1511_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1076:
    .return (rx1511_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("353_1298845521.609") :method
.annotate 'line', 4
    $P1513 = self."!PREFIX__!subrule"("O", "||")
    new $P1514, "ResizablePMCArray"
    push $P1514, $P1513
    .return ($P1514)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("354_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1518_tgt
    .local int rx1518_pos
    .local int rx1518_off
    .local int rx1518_eos
    .local int rx1518_rep
    .local pmc rx1518_cur
    .local pmc rx1518_debug
    (rx1518_cur, rx1518_pos, rx1518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1518_cur
    .local pmc match
    .lex "$/", match
    length rx1518_eos, rx1518_tgt
    gt rx1518_pos, rx1518_eos, rx1518_done
    set rx1518_off, 0
    lt rx1518_pos, 2, rx1518_start
    sub rx1518_off, rx1518_pos, 1
    substr rx1518_tgt, rx1518_tgt, rx1518_off
  rx1518_start:
    eq $I10, 1, rx1518_restart
    if_null rx1518_debug, debug_1077
    rx1518_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1522_done
    goto rxscan1522_scan
  rxscan1522_loop:
    (rx1518_pos) = rx1518_cur."from"()
    inc rx1518_pos
    rx1518_cur."!cursor_from"(rx1518_pos)
    ge rx1518_pos, rx1518_eos, rxscan1522_done
  rxscan1522_scan:
    set_addr $I10, rxscan1522_loop
    rx1518_cur."!mark_push"(0, rx1518_pos, $I10)
  rxscan1522_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1523_fail
    rx1518_cur."!mark_push"(0, rx1518_pos, $I10)
  # rx literal  "//"
    add $I11, rx1518_pos, 2
    gt $I11, rx1518_eos, rx1518_fail
    sub $I11, rx1518_pos, rx1518_off
    substr $S10, rx1518_tgt, $I11, 2
    ne $S10, "//", rx1518_fail
    add rx1518_pos, 2
    set_addr $I10, rxcap_1523_fail
    ($I12, $I11) = rx1518_cur."!mark_peek"($I10)
    rx1518_cur."!cursor_pos"($I11)
    ($P10) = rx1518_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1518_pos, "")
    rx1518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1523_done
  rxcap_1523_fail:
    goto rx1518_fail
  rxcap_1523_done:
  # rx subrule "O" subtype=capture negate=
    rx1518_cur."!cursor_pos"(rx1518_pos)
    $P10 = rx1518_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1518_fail
    rx1518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1518_pos = $P10."pos"()
  # rx pass
    rx1518_cur."!cursor_pass"(rx1518_pos, "infix:sym<//>")
    if_null rx1518_debug, debug_1078
    rx1518_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1518_pos)
  debug_1078:
    .return (rx1518_cur)
  rx1518_restart:
.annotate 'line', 4
    if_null rx1518_debug, debug_1079
    rx1518_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1079:
  rx1518_fail:
    (rx1518_rep, rx1518_pos, $I10, $P10) = rx1518_cur."!mark_fail"(0)
    lt rx1518_pos, -1, rx1518_done
    eq rx1518_pos, -1, rx1518_fail
    jump $I10
  rx1518_done:
    rx1518_cur."!cursor_fail"()
    if_null rx1518_debug, debug_1080
    rx1518_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1080:
    .return (rx1518_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("355_1298845521.609") :method
.annotate 'line', 4
    $P1520 = self."!PREFIX__!subrule"("O", "//")
    new $P1521, "ResizablePMCArray"
    push $P1521, $P1520
    .return ($P1521)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("356_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1525_tgt
    .local int rx1525_pos
    .local int rx1525_off
    .local int rx1525_eos
    .local int rx1525_rep
    .local pmc rx1525_cur
    .local pmc rx1525_debug
    (rx1525_cur, rx1525_pos, rx1525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1525_cur
    .local pmc match
    .lex "$/", match
    length rx1525_eos, rx1525_tgt
    gt rx1525_pos, rx1525_eos, rx1525_done
    set rx1525_off, 0
    lt rx1525_pos, 2, rx1525_start
    sub rx1525_off, rx1525_pos, 1
    substr rx1525_tgt, rx1525_tgt, rx1525_off
  rx1525_start:
    eq $I10, 1, rx1525_restart
    if_null rx1525_debug, debug_1081
    rx1525_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1529_done
    goto rxscan1529_scan
  rxscan1529_loop:
    (rx1525_pos) = rx1525_cur."from"()
    inc rx1525_pos
    rx1525_cur."!cursor_from"(rx1525_pos)
    ge rx1525_pos, rx1525_eos, rxscan1529_done
  rxscan1529_scan:
    set_addr $I10, rxscan1529_loop
    rx1525_cur."!mark_push"(0, rx1525_pos, $I10)
  rxscan1529_done:
.annotate 'line', 636
  # rx literal  "??"
    add $I11, rx1525_pos, 2
    gt $I11, rx1525_eos, rx1525_fail
    sub $I11, rx1525_pos, rx1525_off
    substr $S10, rx1525_tgt, $I11, 2
    ne $S10, "??", rx1525_fail
    add rx1525_pos, 2
.annotate 'line', 637
  # rx subrule "ws" subtype=method negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."ws"()
    unless $P10, rx1525_fail
    rx1525_pos = $P10."pos"()
.annotate 'line', 638
  # rx subrule "EXPR" subtype=capture negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."EXPR"("i=")
    unless $P10, rx1525_fail
    rx1525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1525_pos = $P10."pos"()
.annotate 'line', 639
  # rx literal  "!!"
    add $I11, rx1525_pos, 2
    gt $I11, rx1525_eos, rx1525_fail
    sub $I11, rx1525_pos, rx1525_off
    substr $S10, rx1525_tgt, $I11, 2
    ne $S10, "!!", rx1525_fail
    add rx1525_pos, 2
.annotate 'line', 640
  # rx subrule "O" subtype=capture negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1525_fail
    rx1525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1525_pos = $P10."pos"()
.annotate 'line', 635
  # rx pass
    rx1525_cur."!cursor_pass"(rx1525_pos, "infix:sym<?? !!>")
    if_null rx1525_debug, debug_1082
    rx1525_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1525_pos)
  debug_1082:
    .return (rx1525_cur)
  rx1525_restart:
.annotate 'line', 4
    if_null rx1525_debug, debug_1083
    rx1525_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1083:
  rx1525_fail:
    (rx1525_rep, rx1525_pos, $I10, $P10) = rx1525_cur."!mark_fail"(0)
    lt rx1525_pos, -1, rx1525_done
    eq rx1525_pos, -1, rx1525_fail
    jump $I10
  rx1525_done:
    rx1525_cur."!cursor_fail"()
    if_null rx1525_debug, debug_1084
    rx1525_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1084:
    .return (rx1525_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("357_1298845521.609") :method
.annotate 'line', 4
    $P1527 = self."!PREFIX__!subrule"("ws", "??")
    new $P1528, "ResizablePMCArray"
    push $P1528, $P1527
    .return ($P1528)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("358_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1531_tgt
    .local int rx1531_pos
    .local int rx1531_off
    .local int rx1531_eos
    .local int rx1531_rep
    .local pmc rx1531_cur
    .local pmc rx1531_debug
    (rx1531_cur, rx1531_pos, rx1531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1531_cur
    .local pmc match
    .lex "$/", match
    length rx1531_eos, rx1531_tgt
    gt rx1531_pos, rx1531_eos, rx1531_done
    set rx1531_off, 0
    lt rx1531_pos, 2, rx1531_start
    sub rx1531_off, rx1531_pos, 1
    substr rx1531_tgt, rx1531_tgt, rx1531_off
  rx1531_start:
    eq $I10, 1, rx1531_restart
    if_null rx1531_debug, debug_1085
    rx1531_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1535_done
    goto rxscan1535_scan
  rxscan1535_loop:
    (rx1531_pos) = rx1531_cur."from"()
    inc rx1531_pos
    rx1531_cur."!cursor_from"(rx1531_pos)
    ge rx1531_pos, rx1531_eos, rxscan1535_done
  rxscan1535_scan:
    set_addr $I10, rxscan1535_loop
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  rxscan1535_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1536_fail
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  # rx literal  "="
    add $I11, rx1531_pos, 1
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    ord $I11, rx1531_tgt, $I11
    ne $I11, 61, rx1531_fail
    add rx1531_pos, 1
    set_addr $I10, rxcap_1536_fail
    ($I12, $I11) = rx1531_cur."!mark_peek"($I10)
    rx1531_cur."!cursor_pos"($I11)
    ($P10) = rx1531_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1531_pos, "")
    rx1531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1536_done
  rxcap_1536_fail:
    goto rx1531_fail
  rxcap_1536_done:
  # rx subrule "panic" subtype=method negate=
    rx1531_cur."!cursor_pos"(rx1531_pos)
    $P10 = rx1531_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1531_fail
    rx1531_pos = $P10."pos"()
.annotate 'line', 643
  # rx pass
    rx1531_cur."!cursor_pass"(rx1531_pos, "infix:sym<=>")
    if_null rx1531_debug, debug_1086
    rx1531_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1531_pos)
  debug_1086:
    .return (rx1531_cur)
  rx1531_restart:
.annotate 'line', 4
    if_null rx1531_debug, debug_1087
    rx1531_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1087:
  rx1531_fail:
    (rx1531_rep, rx1531_pos, $I10, $P10) = rx1531_cur."!mark_fail"(0)
    lt rx1531_pos, -1, rx1531_done
    eq rx1531_pos, -1, rx1531_fail
    jump $I10
  rx1531_done:
    rx1531_cur."!cursor_fail"()
    if_null rx1531_debug, debug_1088
    rx1531_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1088:
    .return (rx1531_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("359_1298845521.609") :method
.annotate 'line', 4
    $P1533 = self."!PREFIX__!subrule"("panic", "=")
    new $P1534, "ResizablePMCArray"
    push $P1534, $P1533
    .return ($P1534)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("360_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1538_tgt
    .local int rx1538_pos
    .local int rx1538_off
    .local int rx1538_eos
    .local int rx1538_rep
    .local pmc rx1538_cur
    .local pmc rx1538_debug
    (rx1538_cur, rx1538_pos, rx1538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1538_cur
    .local pmc match
    .lex "$/", match
    length rx1538_eos, rx1538_tgt
    gt rx1538_pos, rx1538_eos, rx1538_done
    set rx1538_off, 0
    lt rx1538_pos, 2, rx1538_start
    sub rx1538_off, rx1538_pos, 1
    substr rx1538_tgt, rx1538_tgt, rx1538_off
  rx1538_start:
    eq $I10, 1, rx1538_restart
    if_null rx1538_debug, debug_1089
    rx1538_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1542_done
    goto rxscan1542_scan
  rxscan1542_loop:
    (rx1538_pos) = rx1538_cur."from"()
    inc rx1538_pos
    rx1538_cur."!cursor_from"(rx1538_pos)
    ge rx1538_pos, rx1538_eos, rxscan1542_done
  rxscan1542_scan:
    set_addr $I10, rxscan1542_loop
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  rxscan1542_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1543_fail
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  # rx literal  ":="
    add $I11, rx1538_pos, 2
    gt $I11, rx1538_eos, rx1538_fail
    sub $I11, rx1538_pos, rx1538_off
    substr $S10, rx1538_tgt, $I11, 2
    ne $S10, ":=", rx1538_fail
    add rx1538_pos, 2
    set_addr $I10, rxcap_1543_fail
    ($I12, $I11) = rx1538_cur."!mark_peek"($I10)
    rx1538_cur."!cursor_pos"($I11)
    ($P10) = rx1538_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1538_pos, "")
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1543_done
  rxcap_1543_fail:
    goto rx1538_fail
  rxcap_1543_done:
  # rx subrule "O" subtype=capture negate=
    rx1538_cur."!cursor_pos"(rx1538_pos)
    $P10 = rx1538_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1538_fail
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1538_pos = $P10."pos"()
  # rx pass
    rx1538_cur."!cursor_pass"(rx1538_pos, "infix:sym<:=>")
    if_null rx1538_debug, debug_1090
    rx1538_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1538_pos)
  debug_1090:
    .return (rx1538_cur)
  rx1538_restart:
.annotate 'line', 4
    if_null rx1538_debug, debug_1091
    rx1538_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1091:
  rx1538_fail:
    (rx1538_rep, rx1538_pos, $I10, $P10) = rx1538_cur."!mark_fail"(0)
    lt rx1538_pos, -1, rx1538_done
    eq rx1538_pos, -1, rx1538_fail
    jump $I10
  rx1538_done:
    rx1538_cur."!cursor_fail"()
    if_null rx1538_debug, debug_1092
    rx1538_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1092:
    .return (rx1538_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("361_1298845521.609") :method
.annotate 'line', 4
    $P1540 = self."!PREFIX__!subrule"("O", ":=")
    new $P1541, "ResizablePMCArray"
    push $P1541, $P1540
    .return ($P1541)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("362_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1545_tgt
    .local int rx1545_pos
    .local int rx1545_off
    .local int rx1545_eos
    .local int rx1545_rep
    .local pmc rx1545_cur
    .local pmc rx1545_debug
    (rx1545_cur, rx1545_pos, rx1545_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1545_cur
    .local pmc match
    .lex "$/", match
    length rx1545_eos, rx1545_tgt
    gt rx1545_pos, rx1545_eos, rx1545_done
    set rx1545_off, 0
    lt rx1545_pos, 2, rx1545_start
    sub rx1545_off, rx1545_pos, 1
    substr rx1545_tgt, rx1545_tgt, rx1545_off
  rx1545_start:
    eq $I10, 1, rx1545_restart
    if_null rx1545_debug, debug_1093
    rx1545_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1549_done
    goto rxscan1549_scan
  rxscan1549_loop:
    (rx1545_pos) = rx1545_cur."from"()
    inc rx1545_pos
    rx1545_cur."!cursor_from"(rx1545_pos)
    ge rx1545_pos, rx1545_eos, rxscan1549_done
  rxscan1549_scan:
    set_addr $I10, rxscan1549_loop
    rx1545_cur."!mark_push"(0, rx1545_pos, $I10)
  rxscan1549_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1550_fail
    rx1545_cur."!mark_push"(0, rx1545_pos, $I10)
  # rx literal  "::="
    add $I11, rx1545_pos, 3
    gt $I11, rx1545_eos, rx1545_fail
    sub $I11, rx1545_pos, rx1545_off
    substr $S10, rx1545_tgt, $I11, 3
    ne $S10, "::=", rx1545_fail
    add rx1545_pos, 3
    set_addr $I10, rxcap_1550_fail
    ($I12, $I11) = rx1545_cur."!mark_peek"($I10)
    rx1545_cur."!cursor_pos"($I11)
    ($P10) = rx1545_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1545_pos, "")
    rx1545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1550_done
  rxcap_1550_fail:
    goto rx1545_fail
  rxcap_1550_done:
  # rx subrule "O" subtype=capture negate=
    rx1545_cur."!cursor_pos"(rx1545_pos)
    $P10 = rx1545_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1545_fail
    rx1545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1545_pos = $P10."pos"()
  # rx pass
    rx1545_cur."!cursor_pass"(rx1545_pos, "infix:sym<::=>")
    if_null rx1545_debug, debug_1094
    rx1545_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1545_pos)
  debug_1094:
    .return (rx1545_cur)
  rx1545_restart:
.annotate 'line', 4
    if_null rx1545_debug, debug_1095
    rx1545_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1095:
  rx1545_fail:
    (rx1545_rep, rx1545_pos, $I10, $P10) = rx1545_cur."!mark_fail"(0)
    lt rx1545_pos, -1, rx1545_done
    eq rx1545_pos, -1, rx1545_fail
    jump $I10
  rx1545_done:
    rx1545_cur."!cursor_fail"()
    if_null rx1545_debug, debug_1096
    rx1545_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1096:
    .return (rx1545_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("363_1298845521.609") :method
.annotate 'line', 4
    $P1547 = self."!PREFIX__!subrule"("O", "::=")
    new $P1548, "ResizablePMCArray"
    push $P1548, $P1547
    .return ($P1548)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("364_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1552_tgt
    .local int rx1552_pos
    .local int rx1552_off
    .local int rx1552_eos
    .local int rx1552_rep
    .local pmc rx1552_cur
    .local pmc rx1552_debug
    (rx1552_cur, rx1552_pos, rx1552_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1552_cur
    .local pmc match
    .lex "$/", match
    length rx1552_eos, rx1552_tgt
    gt rx1552_pos, rx1552_eos, rx1552_done
    set rx1552_off, 0
    lt rx1552_pos, 2, rx1552_start
    sub rx1552_off, rx1552_pos, 1
    substr rx1552_tgt, rx1552_tgt, rx1552_off
  rx1552_start:
    eq $I10, 1, rx1552_restart
    if_null rx1552_debug, debug_1097
    rx1552_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1556_done
    goto rxscan1556_scan
  rxscan1556_loop:
    (rx1552_pos) = rx1552_cur."from"()
    inc rx1552_pos
    rx1552_cur."!cursor_from"(rx1552_pos)
    ge rx1552_pos, rx1552_eos, rxscan1556_done
  rxscan1556_scan:
    set_addr $I10, rxscan1556_loop
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  rxscan1556_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1557_fail
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  # rx literal  ","
    add $I11, rx1552_pos, 1
    gt $I11, rx1552_eos, rx1552_fail
    sub $I11, rx1552_pos, rx1552_off
    ord $I11, rx1552_tgt, $I11
    ne $I11, 44, rx1552_fail
    add rx1552_pos, 1
    set_addr $I10, rxcap_1557_fail
    ($I12, $I11) = rx1552_cur."!mark_peek"($I10)
    rx1552_cur."!cursor_pos"($I11)
    ($P10) = rx1552_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1552_pos, "")
    rx1552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1557_done
  rxcap_1557_fail:
    goto rx1552_fail
  rxcap_1557_done:
  # rx subrule "O" subtype=capture negate=
    rx1552_cur."!cursor_pos"(rx1552_pos)
    $P10 = rx1552_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1552_fail
    rx1552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1552_pos = $P10."pos"()
  # rx pass
    rx1552_cur."!cursor_pass"(rx1552_pos, "infix:sym<,>")
    if_null rx1552_debug, debug_1098
    rx1552_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1552_pos)
  debug_1098:
    .return (rx1552_cur)
  rx1552_restart:
.annotate 'line', 4
    if_null rx1552_debug, debug_1099
    rx1552_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1099:
  rx1552_fail:
    (rx1552_rep, rx1552_pos, $I10, $P10) = rx1552_cur."!mark_fail"(0)
    lt rx1552_pos, -1, rx1552_done
    eq rx1552_pos, -1, rx1552_fail
    jump $I10
  rx1552_done:
    rx1552_cur."!cursor_fail"()
    if_null rx1552_debug, debug_1100
    rx1552_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1100:
    .return (rx1552_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("365_1298845521.609") :method
.annotate 'line', 4
    $P1554 = self."!PREFIX__!subrule"("O", ",")
    new $P1555, "ResizablePMCArray"
    push $P1555, $P1554
    .return ($P1555)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("366_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P1567 = "368_1298845521.609" 
    capture_lex $P1567
    .local string rx1559_tgt
    .local int rx1559_pos
    .local int rx1559_off
    .local int rx1559_eos
    .local int rx1559_rep
    .local pmc rx1559_cur
    .local pmc rx1559_debug
    (rx1559_cur, rx1559_pos, rx1559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1559_cur
    .local pmc match
    .lex "$/", match
    length rx1559_eos, rx1559_tgt
    gt rx1559_pos, rx1559_eos, rx1559_done
    set rx1559_off, 0
    lt rx1559_pos, 2, rx1559_start
    sub rx1559_off, rx1559_pos, 1
    substr rx1559_tgt, rx1559_tgt, rx1559_off
  rx1559_start:
    eq $I10, 1, rx1559_restart
    if_null rx1559_debug, debug_1101
    rx1559_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1559_pos) = rx1559_cur."from"()
    inc rx1559_pos
    rx1559_cur."!cursor_from"(rx1559_pos)
    ge rx1559_pos, rx1559_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  rxscan1562_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1563_fail
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  # rx literal  "return"
    add $I11, rx1559_pos, 6
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 6
    ne $S10, "return", rx1559_fail
    add rx1559_pos, 6
    set_addr $I10, rxcap_1563_fail
    ($I12, $I11) = rx1559_cur."!mark_peek"($I10)
    rx1559_cur."!cursor_pos"($I11)
    ($P10) = rx1559_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1559_pos, "")
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1563_done
  rxcap_1563_fail:
    goto rx1559_fail
  rxcap_1563_done:
  # rx charclass s
    ge rx1559_pos, rx1559_eos, rx1559_fail
    sub $I10, rx1559_pos, rx1559_off
    is_cclass $I11, 32, rx1559_tgt, $I10
    unless $I11, rx1559_fail
    inc rx1559_pos
  # rx subrule "O" subtype=capture negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1559_fail
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1559_pos = $P10."pos"()
    rx1559_cur."!cursor_pos"(rx1559_pos)
    find_lex $P1564, unicode:"$\x{a2}"
    $P1565 = $P1564."MATCH"()
    store_lex "$/", $P1565
    .const 'Sub' $P1567 = "368_1298845521.609" 
    capture_lex $P1567
    $P1569 = $P1567()
  # rx pass
    rx1559_cur."!cursor_pass"(rx1559_pos, "prefix:sym<return>")
    if_null rx1559_debug, debug_1102
    rx1559_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1559_pos)
  debug_1102:
    .return (rx1559_cur)
  rx1559_restart:
.annotate 'line', 4
    if_null rx1559_debug, debug_1103
    rx1559_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1103:
  rx1559_fail:
    (rx1559_rep, rx1559_pos, $I10, $P10) = rx1559_cur."!mark_fail"(0)
    lt rx1559_pos, -1, rx1559_done
    eq rx1559_pos, -1, rx1559_fail
    jump $I10
  rx1559_done:
    rx1559_cur."!cursor_fail"()
    if_null rx1559_debug, debug_1104
    rx1559_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1104:
    .return (rx1559_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("367_1298845521.609") :method
.annotate 'line', 4
    new $P1561, "ResizablePMCArray"
    push $P1561, "return"
    .return ($P1561)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1566"  :anon :subid("368_1298845521.609") :outer("366_1298845521.609")
.annotate 'line', 651
    new $P1568, "Integer"
    assign $P1568, 1
    store_dynamic_lex "$*RETURN_USED", $P1568
    .return ($P1568)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("369_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1571_tgt
    .local int rx1571_pos
    .local int rx1571_off
    .local int rx1571_eos
    .local int rx1571_rep
    .local pmc rx1571_cur
    .local pmc rx1571_debug
    (rx1571_cur, rx1571_pos, rx1571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1571_cur
    .local pmc match
    .lex "$/", match
    length rx1571_eos, rx1571_tgt
    gt rx1571_pos, rx1571_eos, rx1571_done
    set rx1571_off, 0
    lt rx1571_pos, 2, rx1571_start
    sub rx1571_off, rx1571_pos, 1
    substr rx1571_tgt, rx1571_tgt, rx1571_off
  rx1571_start:
    eq $I10, 1, rx1571_restart
    if_null rx1571_debug, debug_1105
    rx1571_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1571_pos) = rx1571_cur."from"()
    inc rx1571_pos
    rx1571_cur."!cursor_from"(rx1571_pos)
    ge rx1571_pos, rx1571_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  rxscan1574_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1575_fail
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  # rx literal  "make"
    add $I11, rx1571_pos, 4
    gt $I11, rx1571_eos, rx1571_fail
    sub $I11, rx1571_pos, rx1571_off
    substr $S10, rx1571_tgt, $I11, 4
    ne $S10, "make", rx1571_fail
    add rx1571_pos, 4
    set_addr $I10, rxcap_1575_fail
    ($I12, $I11) = rx1571_cur."!mark_peek"($I10)
    rx1571_cur."!cursor_pos"($I11)
    ($P10) = rx1571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1571_pos, "")
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1575_done
  rxcap_1575_fail:
    goto rx1571_fail
  rxcap_1575_done:
  # rx charclass s
    ge rx1571_pos, rx1571_eos, rx1571_fail
    sub $I10, rx1571_pos, rx1571_off
    is_cclass $I11, 32, rx1571_tgt, $I10
    unless $I11, rx1571_fail
    inc rx1571_pos
  # rx subrule "O" subtype=capture negate=
    rx1571_cur."!cursor_pos"(rx1571_pos)
    $P10 = rx1571_cur."O"("%list_prefix")
    unless $P10, rx1571_fail
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1571_pos = $P10."pos"()
  # rx pass
    rx1571_cur."!cursor_pass"(rx1571_pos, "prefix:sym<make>")
    if_null rx1571_debug, debug_1106
    rx1571_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1571_pos)
  debug_1106:
    .return (rx1571_cur)
  rx1571_restart:
.annotate 'line', 4
    if_null rx1571_debug, debug_1107
    rx1571_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1107:
  rx1571_fail:
    (rx1571_rep, rx1571_pos, $I10, $P10) = rx1571_cur."!mark_fail"(0)
    lt rx1571_pos, -1, rx1571_done
    eq rx1571_pos, -1, rx1571_fail
    jump $I10
  rx1571_done:
    rx1571_cur."!cursor_fail"()
    if_null rx1571_debug, debug_1108
    rx1571_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1108:
    .return (rx1571_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("370_1298845521.609") :method
.annotate 'line', 4
    new $P1573, "ResizablePMCArray"
    push $P1573, "make"
    .return ($P1573)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("371_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1109
    rx1577_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1580_done
    goto rxscan1580_scan
  rxscan1580_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1580_done
  rxscan1580_scan:
    set_addr $I10, rxscan1580_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1580_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1581_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "last"
    add $I11, rx1577_pos, 4
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 4
    ne $S10, "last", rx1577_fail
    add rx1577_pos, 4
    set_addr $I10, rxcap_1581_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1581_done
  rxcap_1581_fail:
    goto rx1577_fail
  rxcap_1581_done:
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "term:sym<last>")
    if_null rx1577_debug, debug_1110
    rx1577_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1577_pos)
  debug_1110:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 4
    if_null rx1577_debug, debug_1111
    rx1577_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1111:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1112
    rx1577_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1112:
    .return (rx1577_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("372_1298845521.609") :method
.annotate 'line', 4
    new $P1579, "ResizablePMCArray"
    push $P1579, "last"
    .return ($P1579)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("373_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1583_tgt
    .local int rx1583_pos
    .local int rx1583_off
    .local int rx1583_eos
    .local int rx1583_rep
    .local pmc rx1583_cur
    .local pmc rx1583_debug
    (rx1583_cur, rx1583_pos, rx1583_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1583_cur
    .local pmc match
    .lex "$/", match
    length rx1583_eos, rx1583_tgt
    gt rx1583_pos, rx1583_eos, rx1583_done
    set rx1583_off, 0
    lt rx1583_pos, 2, rx1583_start
    sub rx1583_off, rx1583_pos, 1
    substr rx1583_tgt, rx1583_tgt, rx1583_off
  rx1583_start:
    eq $I10, 1, rx1583_restart
    if_null rx1583_debug, debug_1113
    rx1583_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1586_done
    goto rxscan1586_scan
  rxscan1586_loop:
    (rx1583_pos) = rx1583_cur."from"()
    inc rx1583_pos
    rx1583_cur."!cursor_from"(rx1583_pos)
    ge rx1583_pos, rx1583_eos, rxscan1586_done
  rxscan1586_scan:
    set_addr $I10, rxscan1586_loop
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  rxscan1586_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1587_fail
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  # rx literal  "next"
    add $I11, rx1583_pos, 4
    gt $I11, rx1583_eos, rx1583_fail
    sub $I11, rx1583_pos, rx1583_off
    substr $S10, rx1583_tgt, $I11, 4
    ne $S10, "next", rx1583_fail
    add rx1583_pos, 4
    set_addr $I10, rxcap_1587_fail
    ($I12, $I11) = rx1583_cur."!mark_peek"($I10)
    rx1583_cur."!cursor_pos"($I11)
    ($P10) = rx1583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1583_pos, "")
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1587_done
  rxcap_1587_fail:
    goto rx1583_fail
  rxcap_1587_done:
  # rx pass
    rx1583_cur."!cursor_pass"(rx1583_pos, "term:sym<next>")
    if_null rx1583_debug, debug_1114
    rx1583_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1583_pos)
  debug_1114:
    .return (rx1583_cur)
  rx1583_restart:
.annotate 'line', 4
    if_null rx1583_debug, debug_1115
    rx1583_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1115:
  rx1583_fail:
    (rx1583_rep, rx1583_pos, $I10, $P10) = rx1583_cur."!mark_fail"(0)
    lt rx1583_pos, -1, rx1583_done
    eq rx1583_pos, -1, rx1583_fail
    jump $I10
  rx1583_done:
    rx1583_cur."!cursor_fail"()
    if_null rx1583_debug, debug_1116
    rx1583_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1116:
    .return (rx1583_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("374_1298845521.609") :method
.annotate 'line', 4
    new $P1585, "ResizablePMCArray"
    push $P1585, "next"
    .return ($P1585)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("375_1298845521.609") :method :outer("11_1298845521.609")
.annotate 'line', 4
    .local string rx1589_tgt
    .local int rx1589_pos
    .local int rx1589_off
    .local int rx1589_eos
    .local int rx1589_rep
    .local pmc rx1589_cur
    .local pmc rx1589_debug
    (rx1589_cur, rx1589_pos, rx1589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1589_cur
    .local pmc match
    .lex "$/", match
    length rx1589_eos, rx1589_tgt
    gt rx1589_pos, rx1589_eos, rx1589_done
    set rx1589_off, 0
    lt rx1589_pos, 2, rx1589_start
    sub rx1589_off, rx1589_pos, 1
    substr rx1589_tgt, rx1589_tgt, rx1589_off
  rx1589_start:
    eq $I10, 1, rx1589_restart
    if_null rx1589_debug, debug_1117
    rx1589_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1117:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1592_done
    goto rxscan1592_scan
  rxscan1592_loop:
    (rx1589_pos) = rx1589_cur."from"()
    inc rx1589_pos
    rx1589_cur."!cursor_from"(rx1589_pos)
    ge rx1589_pos, rx1589_eos, rxscan1592_done
  rxscan1592_scan:
    set_addr $I10, rxscan1592_loop
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  rxscan1592_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1593_fail
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1589_pos, 4
    gt $I11, rx1589_eos, rx1589_fail
    sub $I11, rx1589_pos, rx1589_off
    substr $S10, rx1589_tgt, $I11, 4
    ne $S10, "redo", rx1589_fail
    add rx1589_pos, 4
    set_addr $I10, rxcap_1593_fail
    ($I12, $I11) = rx1589_cur."!mark_peek"($I10)
    rx1589_cur."!cursor_pos"($I11)
    ($P10) = rx1589_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1589_pos, "")
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1593_done
  rxcap_1593_fail:
    goto rx1589_fail
  rxcap_1593_done:
  # rx pass
    rx1589_cur."!cursor_pass"(rx1589_pos, "term:sym<redo>")
    if_null rx1589_debug, debug_1118
    rx1589_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1589_pos)
  debug_1118:
    .return (rx1589_cur)
  rx1589_restart:
.annotate 'line', 4
    if_null rx1589_debug, debug_1119
    rx1589_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1119:
  rx1589_fail:
    (rx1589_rep, rx1589_pos, $I10, $P10) = rx1589_cur."!mark_fail"(0)
    lt rx1589_pos, -1, rx1589_done
    eq rx1589_pos, -1, rx1589_fail
    jump $I10
  rx1589_done:
    rx1589_cur."!cursor_fail"()
    if_null rx1589_debug, debug_1120
    rx1589_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1120:
    .return (rx1589_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("376_1298845521.609") :method
.annotate 'line', 4
    new $P1591, "ResizablePMCArray"
    push $P1591, "redo"
    .return ($P1591)
.end


.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("377_1298845521.609") :outer("11_1298845521.609")
    .param pmc param_1595
    .param pmc param_1596
.annotate 'line', 657
    .lex "self", param_1595
    .lex "$/", param_1596
.annotate 'line', 659
    new $P1597, "Undef"
    .lex "$t", $P1597
    find_lex $P1598, "$/"
    unless_null $P1598, vivify_1121
    $P1598 = root_new ['parrot';'ResizablePMCArray']
  vivify_1121:
    set $P1599, $P1598[0]
    unless_null $P1599, vivify_1122
    new $P1599, "Undef"
  vivify_1122:
    store_lex "$t", $P1599
    find_lex $P1600, "$/"
    unless_null $P1600, vivify_1123
    $P1600 = root_new ['parrot';'ResizablePMCArray']
  vivify_1123:
    set $P1601, $P1600[1]
    unless_null $P1601, vivify_1124
    new $P1601, "Undef"
  vivify_1124:
    find_lex $P1602, "$/"
    unless_null $P1602, vivify_1125
    $P1602 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1602
  vivify_1125:
    set $P1602[0], $P1601
    find_lex $P1603, "$t"
    find_lex $P1604, "$/"
    unless_null $P1604, vivify_1126
    $P1604 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1604
  vivify_1126:
    set $P1604[1], $P1603
.annotate 'line', 657
    .return ($P1603)
.end


.namespace ["NQP";"Regex"]
.sub "_block1605"  :subid("378_1298845521.609") :outer("11_1298845521.609")
.annotate 'line', 663
    .const 'Sub' $P1670 = "399_1298845521.609" 
    capture_lex $P1670
    .const 'Sub' $P1663 = "397_1298845521.609" 
    capture_lex $P1663
    .const 'Sub' $P1658 = "395_1298845521.609" 
    capture_lex $P1658
    .const 'Sub' $P1646 = "392_1298845521.609" 
    capture_lex $P1646
    .const 'Sub' $P1636 = "389_1298845521.609" 
    capture_lex $P1636
    .const 'Sub' $P1631 = "387_1298845521.609" 
    capture_lex $P1631
    .const 'Sub' $P1622 = "384_1298845521.609" 
    capture_lex $P1622
    .const 'Sub' $P1617 = "382_1298845521.609" 
    capture_lex $P1617
    .const 'Sub' $P1608 = "379_1298845521.609" 
    capture_lex $P1608
    get_global $P1607, "$?CLASS"
    .const 'Sub' $P1663 = "397_1298845521.609" 
    capture_lex $P1663
    .return ($P1663)
.end


.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1127") :outer("378_1298845521.609")
.annotate 'line', 663
    get_hll_global $P1606, ["NQP";"Regex"], "_block1605" 
    .local pmc block
    set block, $P1606
    .const 'Sub' $P1670 = "399_1298845521.609" 
    capture_lex $P1670
    $P1670()
.end


.namespace ["NQP";"Regex"]
.sub "_block1669"  :anon :subid("399_1298845521.609") :outer("378_1298845521.609")
.annotate 'line', 663
    get_hll_global $P1671, "NQPClassHOW"
    $P1672 = $P1671."new_type"("Regex" :named("name"))
    .local pmc type_obj
    set type_obj, $P1672
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1673, type_obj
    .const 'Sub' $P1674 = "379_1298845521.609" 
    $P1673."add_method"(type_obj, "metachar:sym<:my>", $P1674)
    get_how $P1675, type_obj
    get_global $P1676, "!PREFIX__metachar:sym<:my>"
    $P1675."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1676)
    get_how $P1677, type_obj
    .const 'Sub' $P1678 = "382_1298845521.609" 
    $P1677."add_method"(type_obj, "metachar:sym<{ }>", $P1678)
    get_how $P1679, type_obj
    get_global $P1680, "!PREFIX__metachar:sym<{ }>"
    $P1679."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1680)
    get_how $P1681, type_obj
    .const 'Sub' $P1682 = "384_1298845521.609" 
    $P1681."add_method"(type_obj, "metachar:sym<nqpvar>", $P1682)
    get_how $P1683, type_obj
    get_global $P1684, "!PREFIX__metachar:sym<nqpvar>"
    $P1683."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1684)
    get_how $P1685, type_obj
    .const 'Sub' $P1686 = "387_1298845521.609" 
    $P1685."add_method"(type_obj, "assertion:sym<{ }>", $P1686)
    get_how $P1687, type_obj
    get_global $P1688, "!PREFIX__assertion:sym<{ }>"
    $P1687."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1688)
    get_how $P1689, type_obj
    .const 'Sub' $P1690 = "389_1298845521.609" 
    $P1689."add_method"(type_obj, "assertion:sym<?{ }>", $P1690)
    get_how $P1691, type_obj
    get_global $P1692, "!PREFIX__assertion:sym<?{ }>"
    $P1691."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1692)
    get_how $P1693, type_obj
    .const 'Sub' $P1694 = "392_1298845521.609" 
    $P1693."add_method"(type_obj, "assertion:sym<name>", $P1694)
    get_how $P1695, type_obj
    get_global $P1696, "!PREFIX__assertion:sym<name>"
    $P1695."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1696)
    get_how $P1697, type_obj
    .const 'Sub' $P1698 = "395_1298845521.609" 
    $P1697."add_method"(type_obj, "assertion:sym<var>", $P1698)
    get_how $P1699, type_obj
    get_global $P1700, "!PREFIX__assertion:sym<var>"
    $P1699."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1700)
    get_how $P1701, type_obj
    .const 'Sub' $P1702 = "397_1298845521.609" 
    $P1701."add_method"(type_obj, "codeblock", $P1702)
    get_how $P1703, type_obj
    get_global $P1704, "!PREFIX__codeblock"
    $P1703."add_method"(type_obj, "!PREFIX__codeblock", $P1704)
    get_how $P1705, type_obj
    get_hll_global $P1706, ["Regex";"P6Regex"], "Grammar"
    $P1705."add_parent"(type_obj, $P1706)
    get_how $P1707, type_obj
    $P1708 = $P1707."compose"(type_obj)
    .return ($P1708)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("379_1298845521.609") :method :outer("378_1298845521.609")
.annotate 'line', 663
    .const 'Sub' $P1614 = "381_1298845521.609" 
    capture_lex $P1614
    .local string rx1609_tgt
    .local int rx1609_pos
    .local int rx1609_off
    .local int rx1609_eos
    .local int rx1609_rep
    .local pmc rx1609_cur
    .local pmc rx1609_debug
    (rx1609_cur, rx1609_pos, rx1609_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1609_cur
    .local pmc match
    .lex "$/", match
    length rx1609_eos, rx1609_tgt
    gt rx1609_pos, rx1609_eos, rx1609_done
    set rx1609_off, 0
    lt rx1609_pos, 2, rx1609_start
    sub rx1609_off, rx1609_pos, 1
    substr rx1609_tgt, rx1609_tgt, rx1609_off
  rx1609_start:
    eq $I10, 1, rx1609_restart
    if_null rx1609_debug, debug_1128
    rx1609_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1612_done
    goto rxscan1612_scan
  rxscan1612_loop:
    (rx1609_pos) = rx1609_cur."from"()
    inc rx1609_pos
    rx1609_cur."!cursor_from"(rx1609_pos)
    ge rx1609_pos, rx1609_eos, rxscan1612_done
  rxscan1612_scan:
    set_addr $I10, rxscan1612_loop
    rx1609_cur."!mark_push"(0, rx1609_pos, $I10)
  rxscan1612_done:
.annotate 'line', 665
  # rx literal  ":"
    add $I11, rx1609_pos, 1
    gt $I11, rx1609_eos, rx1609_fail
    sub $I11, rx1609_pos, rx1609_off
    ord $I11, rx1609_tgt, $I11
    ne $I11, 58, rx1609_fail
    add rx1609_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1609_cur."!cursor_pos"(rx1609_pos)
    .const 'Sub' $P1614 = "381_1298845521.609" 
    capture_lex $P1614
    $P10 = rx1609_cur."before"($P1614)
    unless $P10, rx1609_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1609_cur."!cursor_pos"(rx1609_pos)
    $P10 = rx1609_cur."LANG"("MAIN", "statement")
    unless $P10, rx1609_fail
    rx1609_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1609_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1609_cur."!cursor_pos"(rx1609_pos)
    $P10 = rx1609_cur."ws"()
    unless $P10, rx1609_fail
    rx1609_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1609_pos, 1
    gt $I11, rx1609_eos, rx1609_fail
    sub $I11, rx1609_pos, rx1609_off
    ord $I11, rx1609_tgt, $I11
    ne $I11, 59, rx1609_fail
    add rx1609_pos, 1
.annotate 'line', 664
  # rx pass
    rx1609_cur."!cursor_pass"(rx1609_pos, "metachar:sym<:my>")
    if_null rx1609_debug, debug_1133
    rx1609_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1609_pos)
  debug_1133:
    .return (rx1609_cur)
  rx1609_restart:
.annotate 'line', 663
    if_null rx1609_debug, debug_1134
    rx1609_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1134:
  rx1609_fail:
    (rx1609_rep, rx1609_pos, $I10, $P10) = rx1609_cur."!mark_fail"(0)
    lt rx1609_pos, -1, rx1609_done
    eq rx1609_pos, -1, rx1609_fail
    jump $I10
  rx1609_done:
    rx1609_cur."!cursor_fail"()
    if_null rx1609_debug, debug_1135
    rx1609_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1135:
    .return (rx1609_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("380_1298845521.609") :method
.annotate 'line', 663
    new $P1611, "ResizablePMCArray"
    push $P1611, ":"
    .return ($P1611)
.end


.namespace ["NQP";"Regex"]
.sub "_block1613"  :anon :subid("381_1298845521.609") :method :outer("379_1298845521.609")
.annotate 'line', 665
    .local string rx1615_tgt
    .local int rx1615_pos
    .local int rx1615_off
    .local int rx1615_eos
    .local int rx1615_rep
    .local pmc rx1615_cur
    .local pmc rx1615_debug
    (rx1615_cur, rx1615_pos, rx1615_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1615_cur
    .local pmc match
    .lex "$/", match
    length rx1615_eos, rx1615_tgt
    gt rx1615_pos, rx1615_eos, rx1615_done
    set rx1615_off, 0
    lt rx1615_pos, 2, rx1615_start
    sub rx1615_off, rx1615_pos, 1
    substr rx1615_tgt, rx1615_tgt, rx1615_off
  rx1615_start:
    eq $I10, 1, rx1615_restart
    if_null rx1615_debug, debug_1129
    rx1615_cur."!cursor_debug"("START", "")
  debug_1129:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1616_done
    goto rxscan1616_scan
  rxscan1616_loop:
    (rx1615_pos) = rx1615_cur."from"()
    inc rx1615_pos
    rx1615_cur."!cursor_from"(rx1615_pos)
    ge rx1615_pos, rx1615_eos, rxscan1616_done
  rxscan1616_scan:
    set_addr $I10, rxscan1616_loop
    rx1615_cur."!mark_push"(0, rx1615_pos, $I10)
  rxscan1616_done:
  # rx literal  "my"
    add $I11, rx1615_pos, 2
    gt $I11, rx1615_eos, rx1615_fail
    sub $I11, rx1615_pos, rx1615_off
    substr $S10, rx1615_tgt, $I11, 2
    ne $S10, "my", rx1615_fail
    add rx1615_pos, 2
  # rx pass
    rx1615_cur."!cursor_pass"(rx1615_pos, "")
    if_null rx1615_debug, debug_1130
    rx1615_cur."!cursor_debug"("PASS", "", " at pos=", rx1615_pos)
  debug_1130:
    .return (rx1615_cur)
  rx1615_restart:
    if_null rx1615_debug, debug_1131
    rx1615_cur."!cursor_debug"("NEXT", "")
  debug_1131:
  rx1615_fail:
    (rx1615_rep, rx1615_pos, $I10, $P10) = rx1615_cur."!mark_fail"(0)
    lt rx1615_pos, -1, rx1615_done
    eq rx1615_pos, -1, rx1615_fail
    jump $I10
  rx1615_done:
    rx1615_cur."!cursor_fail"()
    if_null rx1615_debug, debug_1132
    rx1615_cur."!cursor_debug"("FAIL", "")
  debug_1132:
    .return (rx1615_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("382_1298845521.609") :method :outer("378_1298845521.609")
.annotate 'line', 663
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1136
    rx1618_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1621_done
    goto rxscan1621_scan
  rxscan1621_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1621_done
  rxscan1621_scan:
    set_addr $I10, rxscan1621_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1621_done:
.annotate 'line', 669
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1618_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."codeblock"()
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1618_pos = $P10."pos"()
.annotate 'line', 668
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "metachar:sym<{ }>")
    if_null rx1618_debug, debug_1137
    rx1618_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1618_pos)
  debug_1137:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 663
    if_null rx1618_debug, debug_1138
    rx1618_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1138:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1139
    rx1618_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1139:
    .return (rx1618_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("383_1298845521.609") :method
.annotate 'line', 663
    new $P1620, "ResizablePMCArray"
    push $P1620, "{"
    .return ($P1620)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("384_1298845521.609") :method :outer("378_1298845521.609")
.annotate 'line', 663
    .const 'Sub' $P1628 = "386_1298845521.609" 
    capture_lex $P1628
    .local string rx1623_tgt
    .local int rx1623_pos
    .local int rx1623_off
    .local int rx1623_eos
    .local int rx1623_rep
    .local pmc rx1623_cur
    .local pmc rx1623_debug
    (rx1623_cur, rx1623_pos, rx1623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1623_cur
    .local pmc match
    .lex "$/", match
    length rx1623_eos, rx1623_tgt
    gt rx1623_pos, rx1623_eos, rx1623_done
    set rx1623_off, 0
    lt rx1623_pos, 2, rx1623_start
    sub rx1623_off, rx1623_pos, 1
    substr rx1623_tgt, rx1623_tgt, rx1623_off
  rx1623_start:
    eq $I10, 1, rx1623_restart
    if_null rx1623_debug, debug_1140
    rx1623_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1626_done
    goto rxscan1626_scan
  rxscan1626_loop:
    (rx1623_pos) = rx1623_cur."from"()
    inc rx1623_pos
    rx1623_cur."!cursor_from"(rx1623_pos)
    ge rx1623_pos, rx1623_eos, rxscan1626_done
  rxscan1626_scan:
    set_addr $I10, rxscan1626_loop
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
  rxscan1626_done:
.annotate 'line', 673
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1623_pos, rx1623_off
    substr $S10, rx1623_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1623_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    .const 'Sub' $P1628 = "386_1298845521.609" 
    capture_lex $P1628
    $P10 = rx1623_cur."before"($P1628)
    unless $P10, rx1623_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."LANG"("MAIN", "variable")
    unless $P10, rx1623_fail
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1623_pos = $P10."pos"()
.annotate 'line', 672
  # rx pass
    rx1623_cur."!cursor_pass"(rx1623_pos, "metachar:sym<nqpvar>")
    if_null rx1623_debug, debug_1145
    rx1623_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1623_pos)
  debug_1145:
    .return (rx1623_cur)
  rx1623_restart:
.annotate 'line', 663
    if_null rx1623_debug, debug_1146
    rx1623_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1146:
  rx1623_fail:
    (rx1623_rep, rx1623_pos, $I10, $P10) = rx1623_cur."!mark_fail"(0)
    lt rx1623_pos, -1, rx1623_done
    eq rx1623_pos, -1, rx1623_fail
    jump $I10
  rx1623_done:
    rx1623_cur."!cursor_fail"()
    if_null rx1623_debug, debug_1147
    rx1623_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1147:
    .return (rx1623_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("385_1298845521.609") :method
.annotate 'line', 663
    new $P1625, "ResizablePMCArray"
    push $P1625, "$"
    push $P1625, "@"
    .return ($P1625)
.end


.namespace ["NQP";"Regex"]
.sub "_block1627"  :anon :subid("386_1298845521.609") :method :outer("384_1298845521.609")
.annotate 'line', 673
    .local string rx1629_tgt
    .local int rx1629_pos
    .local int rx1629_off
    .local int rx1629_eos
    .local int rx1629_rep
    .local pmc rx1629_cur
    .local pmc rx1629_debug
    (rx1629_cur, rx1629_pos, rx1629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1629_cur
    .local pmc match
    .lex "$/", match
    length rx1629_eos, rx1629_tgt
    gt rx1629_pos, rx1629_eos, rx1629_done
    set rx1629_off, 0
    lt rx1629_pos, 2, rx1629_start
    sub rx1629_off, rx1629_pos, 1
    substr rx1629_tgt, rx1629_tgt, rx1629_off
  rx1629_start:
    eq $I10, 1, rx1629_restart
    if_null rx1629_debug, debug_1141
    rx1629_cur."!cursor_debug"("START", "")
  debug_1141:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1630_done
    goto rxscan1630_scan
  rxscan1630_loop:
    (rx1629_pos) = rx1629_cur."from"()
    inc rx1629_pos
    rx1629_cur."!cursor_from"(rx1629_pos)
    ge rx1629_pos, rx1629_eos, rxscan1630_done
  rxscan1630_scan:
    set_addr $I10, rxscan1630_loop
    rx1629_cur."!mark_push"(0, rx1629_pos, $I10)
  rxscan1630_done:
  # rx charclass .
    ge rx1629_pos, rx1629_eos, rx1629_fail
    inc rx1629_pos
  # rx charclass w
    ge rx1629_pos, rx1629_eos, rx1629_fail
    sub $I10, rx1629_pos, rx1629_off
    is_cclass $I11, 8192, rx1629_tgt, $I10
    unless $I11, rx1629_fail
    inc rx1629_pos
  # rx pass
    rx1629_cur."!cursor_pass"(rx1629_pos, "")
    if_null rx1629_debug, debug_1142
    rx1629_cur."!cursor_debug"("PASS", "", " at pos=", rx1629_pos)
  debug_1142:
    .return (rx1629_cur)
  rx1629_restart:
    if_null rx1629_debug, debug_1143
    rx1629_cur."!cursor_debug"("NEXT", "")
  debug_1143:
  rx1629_fail:
    (rx1629_rep, rx1629_pos, $I10, $P10) = rx1629_cur."!mark_fail"(0)
    lt rx1629_pos, -1, rx1629_done
    eq rx1629_pos, -1, rx1629_fail
    jump $I10
  rx1629_done:
    rx1629_cur."!cursor_fail"()
    if_null rx1629_debug, debug_1144
    rx1629_cur."!cursor_debug"("FAIL", "")
  debug_1144:
    .return (rx1629_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("387_1298845521.609") :method :outer("378_1298845521.609")
.annotate 'line', 663
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1148
    rx1632_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1635_done
    goto rxscan1635_scan
  rxscan1635_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1635_done
  rxscan1635_scan:
    set_addr $I10, rxscan1635_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1635_done:
.annotate 'line', 677
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1632_pos, rx1632_off
    substr $S10, rx1632_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1632_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."codeblock"()
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1632_pos = $P10."pos"()
.annotate 'line', 676
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "assertion:sym<{ }>")
    if_null rx1632_debug, debug_1149
    rx1632_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1632_pos)
  debug_1149:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 663
    if_null rx1632_debug, debug_1150
    rx1632_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1150:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1151
    rx1632_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1151:
    .return (rx1632_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("388_1298845521.609") :method
.annotate 'line', 663
    new $P1634, "ResizablePMCArray"
    push $P1634, "{"
    .return ($P1634)
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("389_1298845521.609") :method :outer("378_1298845521.609")
.annotate 'line', 663
    .const 'Sub' $P1642 = "391_1298845521.609" 
    capture_lex $P1642
    .local string rx1637_tgt
    .local int rx1637_pos
    .local int rx1637_off
    .local int rx1637_eos
    .local int rx1637_rep
    .local pmc rx1637_cur
    .local pmc rx1637_debug
    (rx1637_cur, rx1637_pos, rx1637_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1637_cur
    .local pmc match
    .lex "$/", match
    length rx1637_eos, rx1637_tgt
    gt rx1637_pos, rx1637_eos, rx1637_done
    set rx1637_off, 0
    lt rx1637_pos, 2, rx1637_start
    sub rx1637_off, rx1637_pos, 1
    substr rx1637_tgt, rx1637_tgt, rx1637_off
  rx1637_start:
    eq $I10, 1, rx1637_restart
    if_null rx1637_debug, debug_1152
    rx1637_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1640_done
    goto rxscan1640_scan
  rxscan1640_loop:
    (rx1637_pos) = rx1637_cur."from"()
    inc rx1637_pos
    rx1637_cur."!cursor_from"(rx1637_pos)
    ge rx1637_pos, rx1637_eos, rxscan1640_done
  rxscan1640_scan:
    set_addr $I10, rxscan1640_loop
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  rxscan1640_done:
.annotate 'line', 681
  # rx subcapture "zw"
    set_addr $I10, rxcap_1645_fail
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1637_pos, rx1637_eos, rx1637_fail
    sub $I10, rx1637_pos, rx1637_off
    substr $S10, rx1637_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1637_fail
    inc rx1637_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1637_cur."!cursor_pos"(rx1637_pos)
    .const 'Sub' $P1642 = "391_1298845521.609" 
    capture_lex $P1642
    $P10 = rx1637_cur."before"($P1642)
    unless $P10, rx1637_fail
    set_addr $I10, rxcap_1645_fail
    ($I12, $I11) = rx1637_cur."!mark_peek"($I10)
    rx1637_cur."!cursor_pos"($I11)
    ($P10) = rx1637_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1637_pos, "")
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1645_done
  rxcap_1645_fail:
    goto rx1637_fail
  rxcap_1645_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1637_cur."!cursor_pos"(rx1637_pos)
    $P10 = rx1637_cur."codeblock"()
    unless $P10, rx1637_fail
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1637_pos = $P10."pos"()
.annotate 'line', 680
  # rx pass
    rx1637_cur."!cursor_pass"(rx1637_pos, "assertion:sym<?{ }>")
    if_null rx1637_debug, debug_1157
    rx1637_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1637_pos)
  debug_1157:
    .return (rx1637_cur)
  rx1637_restart:
.annotate 'line', 663
    if_null rx1637_debug, debug_1158
    rx1637_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1158:
  rx1637_fail:
    (rx1637_rep, rx1637_pos, $I10, $P10) = rx1637_cur."!mark_fail"(0)
    lt rx1637_pos, -1, rx1637_done
    eq rx1637_pos, -1, rx1637_fail
    jump $I10
  rx1637_done:
    rx1637_cur."!cursor_fail"()
    if_null rx1637_debug, debug_1159
    rx1637_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1159:
    .return (rx1637_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("390_1298845521.609") :method
.annotate 'line', 663
    new $P1639, "ResizablePMCArray"
    push $P1639, "!"
    push $P1639, "?"
    .return ($P1639)
.end


.namespace ["NQP";"Regex"]
.sub "_block1641"  :anon :subid("391_1298845521.609") :method :outer("389_1298845521.609")
.annotate 'line', 681
    .local string rx1643_tgt
    .local int rx1643_pos
    .local int rx1643_off
    .local int rx1643_eos
    .local int rx1643_rep
    .local pmc rx1643_cur
    .local pmc rx1643_debug
    (rx1643_cur, rx1643_pos, rx1643_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1643_cur
    .local pmc match
    .lex "$/", match
    length rx1643_eos, rx1643_tgt
    gt rx1643_pos, rx1643_eos, rx1643_done
    set rx1643_off, 0
    lt rx1643_pos, 2, rx1643_start
    sub rx1643_off, rx1643_pos, 1
    substr rx1643_tgt, rx1643_tgt, rx1643_off
  rx1643_start:
    eq $I10, 1, rx1643_restart
    if_null rx1643_debug, debug_1153
    rx1643_cur."!cursor_debug"("START", "")
  debug_1153:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1644_done
    goto rxscan1644_scan
  rxscan1644_loop:
    (rx1643_pos) = rx1643_cur."from"()
    inc rx1643_pos
    rx1643_cur."!cursor_from"(rx1643_pos)
    ge rx1643_pos, rx1643_eos, rxscan1644_done
  rxscan1644_scan:
    set_addr $I10, rxscan1644_loop
    rx1643_cur."!mark_push"(0, rx1643_pos, $I10)
  rxscan1644_done:
  # rx literal  "{"
    add $I11, rx1643_pos, 1
    gt $I11, rx1643_eos, rx1643_fail
    sub $I11, rx1643_pos, rx1643_off
    ord $I11, rx1643_tgt, $I11
    ne $I11, 123, rx1643_fail
    add rx1643_pos, 1
  # rx pass
    rx1643_cur."!cursor_pass"(rx1643_pos, "")
    if_null rx1643_debug, debug_1154
    rx1643_cur."!cursor_debug"("PASS", "", " at pos=", rx1643_pos)
  debug_1154:
    .return (rx1643_cur)
  rx1643_restart:
    if_null rx1643_debug, debug_1155
    rx1643_cur."!cursor_debug"("NEXT", "")
  debug_1155:
  rx1643_fail:
    (rx1643_rep, rx1643_pos, $I10, $P10) = rx1643_cur."!mark_fail"(0)
    lt rx1643_pos, -1, rx1643_done
    eq rx1643_pos, -1, rx1643_fail
    jump $I10
  rx1643_done:
    rx1643_cur."!cursor_fail"()
    if_null rx1643_debug, debug_1156
    rx1643_cur."!cursor_debug"("FAIL", "")
  debug_1156:
    .return (rx1643_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("392_1298845521.609") :method :outer("378_1298845521.609")
.annotate 'line', 663
    .const 'Sub' $P1655 = "394_1298845521.609" 
    capture_lex $P1655
    .local string rx1647_tgt
    .local int rx1647_pos
    .local int rx1647_off
    .local int rx1647_eos
    .local int rx1647_rep
    .local pmc rx1647_cur
    .local pmc rx1647_debug
    (rx1647_cur, rx1647_pos, rx1647_tgt, $I10) = self."!cursor_start"()
    rx1647_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1647_cur
    .local pmc match
    .lex "$/", match
    length rx1647_eos, rx1647_tgt
    gt rx1647_pos, rx1647_eos, rx1647_done
    set rx1647_off, 0
    lt rx1647_pos, 2, rx1647_start
    sub rx1647_off, rx1647_pos, 1
    substr rx1647_tgt, rx1647_tgt, rx1647_off
  rx1647_start:
    eq $I10, 1, rx1647_restart
    if_null rx1647_debug, debug_1160
    rx1647_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1651_done
    goto rxscan1651_scan
  rxscan1651_loop:
    (rx1647_pos) = rx1647_cur."from"()
    inc rx1647_pos
    rx1647_cur."!cursor_from"(rx1647_pos)
    ge rx1647_pos, rx1647_eos, rxscan1651_done
  rxscan1651_scan:
    set_addr $I10, rxscan1651_loop
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxscan1651_done:
.annotate 'line', 685
  # rx subrule "identifier" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."identifier"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1647_pos = $P10."pos"()
.annotate 'line', 692
  # rx rxquantr1652 ** 0..1
    set_addr $I10, rxquantr1652_done
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxquantr1652_loop:
  alt1653_0:
.annotate 'line', 686
    set_addr $I10, alt1653_1
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
.annotate 'line', 687
  # rx subrule "before" subtype=zerowidth negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    .const 'Sub' $P1655 = "394_1298845521.609" 
    capture_lex $P1655
    $P10 = rx1647_cur."before"($P1655)
    unless $P10, rx1647_fail
    goto alt1653_end
  alt1653_1:
    set_addr $I10, alt1653_2
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
.annotate 'line', 688
  # rx literal  "="
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 61, rx1647_fail
    add rx1647_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."assertion"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1647_pos = $P10."pos"()
    goto alt1653_end
  alt1653_2:
    set_addr $I10, alt1653_3
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
.annotate 'line', 689
  # rx literal  ":"
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 58, rx1647_fail
    add rx1647_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."arglist"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1647_pos = $P10."pos"()
    goto alt1653_end
  alt1653_3:
    set_addr $I10, alt1653_4
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
.annotate 'line', 690
  # rx literal  "("
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 40, rx1647_fail
    add rx1647_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1647_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 41, rx1647_fail
    add rx1647_pos, 1
    goto alt1653_end
  alt1653_4:
.annotate 'line', 691
  # rx subrule "normspace" subtype=method negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."normspace"()
    unless $P10, rx1647_fail
    rx1647_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."nibbler"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1647_pos = $P10."pos"()
  alt1653_end:
.annotate 'line', 692
    set_addr $I10, rxquantr1652_done
    (rx1647_rep) = rx1647_cur."!mark_commit"($I10)
  rxquantr1652_done:
.annotate 'line', 684
  # rx pass
    rx1647_cur."!cursor_pass"(rx1647_pos, "assertion:sym<name>")
    if_null rx1647_debug, debug_1165
    rx1647_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1647_pos)
  debug_1165:
    .return (rx1647_cur)
  rx1647_restart:
.annotate 'line', 663
    if_null rx1647_debug, debug_1166
    rx1647_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1166:
  rx1647_fail:
    (rx1647_rep, rx1647_pos, $I10, $P10) = rx1647_cur."!mark_fail"(0)
    lt rx1647_pos, -1, rx1647_done
    eq rx1647_pos, -1, rx1647_fail
    jump $I10
  rx1647_done:
    rx1647_cur."!cursor_fail"()
    if_null rx1647_debug, debug_1167
    rx1647_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1167:
    .return (rx1647_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("393_1298845521.609") :method
.annotate 'line', 663
    $P1649 = self."!PREFIX__!subrule"("identifier", "")
    new $P1650, "ResizablePMCArray"
    push $P1650, $P1649
    .return ($P1650)
.end


.namespace ["NQP";"Regex"]
.sub "_block1654"  :anon :subid("394_1298845521.609") :method :outer("392_1298845521.609")
.annotate 'line', 687
    .local string rx1656_tgt
    .local int rx1656_pos
    .local int rx1656_off
    .local int rx1656_eos
    .local int rx1656_rep
    .local pmc rx1656_cur
    .local pmc rx1656_debug
    (rx1656_cur, rx1656_pos, rx1656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1656_cur
    .local pmc match
    .lex "$/", match
    length rx1656_eos, rx1656_tgt
    gt rx1656_pos, rx1656_eos, rx1656_done
    set rx1656_off, 0
    lt rx1656_pos, 2, rx1656_start
    sub rx1656_off, rx1656_pos, 1
    substr rx1656_tgt, rx1656_tgt, rx1656_off
  rx1656_start:
    eq $I10, 1, rx1656_restart
    if_null rx1656_debug, debug_1161
    rx1656_cur."!cursor_debug"("START", "")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1657_done
    goto rxscan1657_scan
  rxscan1657_loop:
    (rx1656_pos) = rx1656_cur."from"()
    inc rx1656_pos
    rx1656_cur."!cursor_from"(rx1656_pos)
    ge rx1656_pos, rx1656_eos, rxscan1657_done
  rxscan1657_scan:
    set_addr $I10, rxscan1657_loop
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  rxscan1657_done:
  # rx literal  ">"
    add $I11, rx1656_pos, 1
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    ord $I11, rx1656_tgt, $I11
    ne $I11, 62, rx1656_fail
    add rx1656_pos, 1
  # rx pass
    rx1656_cur."!cursor_pass"(rx1656_pos, "")
    if_null rx1656_debug, debug_1162
    rx1656_cur."!cursor_debug"("PASS", "", " at pos=", rx1656_pos)
  debug_1162:
    .return (rx1656_cur)
  rx1656_restart:
    if_null rx1656_debug, debug_1163
    rx1656_cur."!cursor_debug"("NEXT", "")
  debug_1163:
  rx1656_fail:
    (rx1656_rep, rx1656_pos, $I10, $P10) = rx1656_cur."!mark_fail"(0)
    lt rx1656_pos, -1, rx1656_done
    eq rx1656_pos, -1, rx1656_fail
    jump $I10
  rx1656_done:
    rx1656_cur."!cursor_fail"()
    if_null rx1656_debug, debug_1164
    rx1656_cur."!cursor_debug"("FAIL", "")
  debug_1164:
    .return (rx1656_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("395_1298845521.609") :method :outer("378_1298845521.609")
.annotate 'line', 663
    .local string rx1659_tgt
    .local int rx1659_pos
    .local int rx1659_off
    .local int rx1659_eos
    .local int rx1659_rep
    .local pmc rx1659_cur
    .local pmc rx1659_debug
    (rx1659_cur, rx1659_pos, rx1659_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1659_cur
    .local pmc match
    .lex "$/", match
    length rx1659_eos, rx1659_tgt
    gt rx1659_pos, rx1659_eos, rx1659_done
    set rx1659_off, 0
    lt rx1659_pos, 2, rx1659_start
    sub rx1659_off, rx1659_pos, 1
    substr rx1659_tgt, rx1659_tgt, rx1659_off
  rx1659_start:
    eq $I10, 1, rx1659_restart
    if_null rx1659_debug, debug_1168
    rx1659_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1168:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1662_done
    goto rxscan1662_scan
  rxscan1662_loop:
    (rx1659_pos) = rx1659_cur."from"()
    inc rx1659_pos
    rx1659_cur."!cursor_from"(rx1659_pos)
    ge rx1659_pos, rx1659_eos, rxscan1662_done
  rxscan1662_scan:
    set_addr $I10, rxscan1662_loop
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  rxscan1662_done:
.annotate 'line', 696
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1659_pos, rx1659_off
    substr $S10, rx1659_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1659_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1659_cur."!cursor_pos"(rx1659_pos)
    $P10 = rx1659_cur."LANG"("MAIN", "variable")
    unless $P10, rx1659_fail
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1659_pos = $P10."pos"()
.annotate 'line', 695
  # rx pass
    rx1659_cur."!cursor_pass"(rx1659_pos, "assertion:sym<var>")
    if_null rx1659_debug, debug_1169
    rx1659_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1659_pos)
  debug_1169:
    .return (rx1659_cur)
  rx1659_restart:
.annotate 'line', 663
    if_null rx1659_debug, debug_1170
    rx1659_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1170:
  rx1659_fail:
    (rx1659_rep, rx1659_pos, $I10, $P10) = rx1659_cur."!mark_fail"(0)
    lt rx1659_pos, -1, rx1659_done
    eq rx1659_pos, -1, rx1659_fail
    jump $I10
  rx1659_done:
    rx1659_cur."!cursor_fail"()
    if_null rx1659_debug, debug_1171
    rx1659_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1171:
    .return (rx1659_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("396_1298845521.609") :method
.annotate 'line', 663
    new $P1661, "ResizablePMCArray"
    push $P1661, "$"
    push $P1661, "@"
    .return ($P1661)
.end


.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("397_1298845521.609") :method :outer("378_1298845521.609")
.annotate 'line', 663
    .local string rx1664_tgt
    .local int rx1664_pos
    .local int rx1664_off
    .local int rx1664_eos
    .local int rx1664_rep
    .local pmc rx1664_cur
    .local pmc rx1664_debug
    (rx1664_cur, rx1664_pos, rx1664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1664_cur
    .local pmc match
    .lex "$/", match
    length rx1664_eos, rx1664_tgt
    gt rx1664_pos, rx1664_eos, rx1664_done
    set rx1664_off, 0
    lt rx1664_pos, 2, rx1664_start
    sub rx1664_off, rx1664_pos, 1
    substr rx1664_tgt, rx1664_tgt, rx1664_off
  rx1664_start:
    eq $I10, 1, rx1664_restart
    if_null rx1664_debug, debug_1172
    rx1664_cur."!cursor_debug"("START", "codeblock")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1668_done
    goto rxscan1668_scan
  rxscan1668_loop:
    (rx1664_pos) = rx1664_cur."from"()
    inc rx1664_pos
    rx1664_cur."!cursor_from"(rx1664_pos)
    ge rx1664_pos, rx1664_eos, rxscan1668_done
  rxscan1668_scan:
    set_addr $I10, rxscan1668_loop
    rx1664_cur."!mark_push"(0, rx1664_pos, $I10)
  rxscan1668_done:
.annotate 'line', 700
  # rx subrule "LANG" subtype=capture negate=
    rx1664_cur."!cursor_pos"(rx1664_pos)
    $P10 = rx1664_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1664_fail
    rx1664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1664_pos = $P10."pos"()
.annotate 'line', 699
  # rx pass
    rx1664_cur."!cursor_pass"(rx1664_pos, "codeblock")
    if_null rx1664_debug, debug_1173
    rx1664_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1664_pos)
  debug_1173:
    .return (rx1664_cur)
  rx1664_restart:
.annotate 'line', 663
    if_null rx1664_debug, debug_1174
    rx1664_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1174:
  rx1664_fail:
    (rx1664_rep, rx1664_pos, $I10, $P10) = rx1664_cur."!mark_fail"(0)
    lt rx1664_pos, -1, rx1664_done
    eq rx1664_pos, -1, rx1664_fail
    jump $I10
  rx1664_done:
    rx1664_cur."!cursor_fail"()
    if_null rx1664_debug, debug_1175
    rx1664_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1175:
    .return (rx1664_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("398_1298845521.609") :method
.annotate 'line', 663
    $P1666 = self."!PREFIX__!subrule"("LANG", "")
    new $P1667, "ResizablePMCArray"
    push $P1667, $P1666
    .return ($P1667)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1710" :load :anon :subid("400_1298845521.609")
.annotate 'line', 4
    .const 'Sub' $P1712 = "11_1298845521.609" 
    $P1713 = $P1712()
    .return ($P1713)
.end


.namespace []
.sub "_block2431" :load :anon :subid("402_1298845521.609")
.annotate 'line', 1
    .const 'Sub' $P2433 = "10_1298845521.609" 
    $P2434 = $P2433()
    .return ($P2434)
.end

### .include 'gen/nqp-actions.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298845576.421")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
    $P3256 = $P15()
.annotate 'line', 1
    .return ($P3256)
    .const 'Sub' $P3258 = "171_1298845576.421" 
    .return ($P3258)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block14"  :subid("11_1298845576.421") :outer("10_1298845576.421")
.annotate 'line', 3
    .const 'Sub' $P3035 = "170_1298845576.421" 
    capture_lex $P3035
    get_hll_global $P2909, ["NQP";"RegexActions"], "_block2908" 
    capture_lex $P2909
    .const 'Sub' $P2900 = "159_1298845576.421" 
    capture_lex $P2900
    .const 'Sub' $P2895 = "158_1298845576.421" 
    capture_lex $P2895
    .const 'Sub' $P2890 = "157_1298845576.421" 
    capture_lex $P2890
    .const 'Sub' $P2885 = "156_1298845576.421" 
    capture_lex $P2885
    .const 'Sub' $P2874 = "155_1298845576.421" 
    capture_lex $P2874
    .const 'Sub' $P2866 = "154_1298845576.421" 
    capture_lex $P2866
    .const 'Sub' $P2858 = "153_1298845576.421" 
    capture_lex $P2858
    .const 'Sub' $P2850 = "152_1298845576.421" 
    capture_lex $P2850
    .const 'Sub' $P2845 = "151_1298845576.421" 
    capture_lex $P2845
    .const 'Sub' $P2833 = "150_1298845576.421" 
    capture_lex $P2833
    .const 'Sub' $P2825 = "149_1298845576.421" 
    capture_lex $P2825
    .const 'Sub' $P2787 = "148_1298845576.421" 
    capture_lex $P2787
    .const 'Sub' $P2775 = "147_1298845576.421" 
    capture_lex $P2775
    .const 'Sub' $P2767 = "146_1298845576.421" 
    capture_lex $P2767
    .const 'Sub' $P2759 = "145_1298845576.421" 
    capture_lex $P2759
    .const 'Sub' $P2751 = "144_1298845576.421" 
    capture_lex $P2751
    .const 'Sub' $P2743 = "143_1298845576.421" 
    capture_lex $P2743
    .const 'Sub' $P2735 = "142_1298845576.421" 
    capture_lex $P2735
    .const 'Sub' $P2709 = "141_1298845576.421" 
    capture_lex $P2709
    .const 'Sub' $P2694 = "140_1298845576.421" 
    capture_lex $P2694
    .const 'Sub' $P2686 = "139_1298845576.421" 
    capture_lex $P2686
    .const 'Sub' $P2675 = "138_1298845576.421" 
    capture_lex $P2675
    .const 'Sub' $P2664 = "137_1298845576.421" 
    capture_lex $P2664
    .const 'Sub' $P2653 = "136_1298845576.421" 
    capture_lex $P2653
    .const 'Sub' $P2645 = "135_1298845576.421" 
    capture_lex $P2645
    .const 'Sub' $P2618 = "134_1298845576.421" 
    capture_lex $P2618
    .const 'Sub' $P2580 = "132_1298845576.421" 
    capture_lex $P2580
    .const 'Sub' $P2572 = "131_1298845576.421" 
    capture_lex $P2572
    .const 'Sub' $P2564 = "130_1298845576.421" 
    capture_lex $P2564
    .const 'Sub' $P2539 = "129_1298845576.421" 
    capture_lex $P2539
    .const 'Sub' $P2523 = "128_1298845576.421" 
    capture_lex $P2523
    .const 'Sub' $P2515 = "127_1298845576.421" 
    capture_lex $P2515
    .const 'Sub' $P2507 = "126_1298845576.421" 
    capture_lex $P2507
    .const 'Sub' $P2405 = "123_1298845576.421" 
    capture_lex $P2405
    .const 'Sub' $P2397 = "122_1298845576.421" 
    capture_lex $P2397
    .const 'Sub' $P2390 = "121_1298845576.421" 
    capture_lex $P2390
    .const 'Sub' $P2363 = "120_1298845576.421" 
    capture_lex $P2363
    .const 'Sub' $P2323 = "119_1298845576.421" 
    capture_lex $P2323
    .const 'Sub' $P2309 = "118_1298845576.421" 
    capture_lex $P2309
    .const 'Sub' $P2302 = "117_1298845576.421" 
    capture_lex $P2302
    .const 'Sub' $P2258 = "116_1298845576.421" 
    capture_lex $P2258
    .const 'Sub' $P2093 = "112_1298845576.421" 
    capture_lex $P2093
    .const 'Sub' $P2030 = "110_1298845576.421" 
    capture_lex $P2030
    .const 'Sub' $P2022 = "109_1298845576.421" 
    capture_lex $P2022
    .const 'Sub' $P2007 = "108_1298845576.421" 
    capture_lex $P2007
    .const 'Sub' $P1992 = "107_1298845576.421" 
    capture_lex $P1992
    .const 'Sub' $P1974 = "106_1298845576.421" 
    capture_lex $P1974
    .const 'Sub' $P1875 = "105_1298845576.421" 
    capture_lex $P1875
    .const 'Sub' $P1831 = "102_1298845576.421" 
    capture_lex $P1831
    .const 'Sub' $P1706 = "99_1298845576.421" 
    capture_lex $P1706
    .const 'Sub' $P1464 = "92_1298845576.421" 
    capture_lex $P1464
    .const 'Sub' $P1456 = "91_1298845576.421" 
    capture_lex $P1456
    .const 'Sub' $P1448 = "90_1298845576.421" 
    capture_lex $P1448
    .const 'Sub' $P1347 = "86_1298845576.421" 
    capture_lex $P1347
    .const 'Sub' $P1339 = "85_1298845576.421" 
    capture_lex $P1339
    .const 'Sub' $P1324 = "84_1298845576.421" 
    capture_lex $P1324
    .const 'Sub' $P1309 = "83_1298845576.421" 
    capture_lex $P1309
    .const 'Sub' $P1294 = "82_1298845576.421" 
    capture_lex $P1294
    .const 'Sub' $P1279 = "81_1298845576.421" 
    capture_lex $P1279
    .const 'Sub' $P1271 = "80_1298845576.421" 
    capture_lex $P1271
    .const 'Sub' $P1263 = "79_1298845576.421" 
    capture_lex $P1263
    .const 'Sub' $P1255 = "78_1298845576.421" 
    capture_lex $P1255
    .const 'Sub' $P1041 = "74_1298845576.421" 
    capture_lex $P1041
    .const 'Sub' $P1033 = "73_1298845576.421" 
    capture_lex $P1033
    .const 'Sub' $P1025 = "72_1298845576.421" 
    capture_lex $P1025
    .const 'Sub' $P1017 = "71_1298845576.421" 
    capture_lex $P1017
    .const 'Sub' $P1009 = "70_1298845576.421" 
    capture_lex $P1009
    .const 'Sub' $P1001 = "69_1298845576.421" 
    capture_lex $P1001
    .const 'Sub' $P993 = "68_1298845576.421" 
    capture_lex $P993
    .const 'Sub' $P903 = "66_1298845576.421" 
    capture_lex $P903
    .const 'Sub' $P879 = "65_1298845576.421" 
    capture_lex $P879
    .const 'Sub' $P865 = "64_1298845576.421" 
    capture_lex $P865
    .const 'Sub' $P857 = "63_1298845576.421" 
    capture_lex $P857
    .const 'Sub' $P849 = "62_1298845576.421" 
    capture_lex $P849
    .const 'Sub' $P841 = "61_1298845576.421" 
    capture_lex $P841
    .const 'Sub' $P833 = "60_1298845576.421" 
    capture_lex $P833
    .const 'Sub' $P825 = "59_1298845576.421" 
    capture_lex $P825
    .const 'Sub' $P817 = "58_1298845576.421" 
    capture_lex $P817
    .const 'Sub' $P809 = "57_1298845576.421" 
    capture_lex $P809
    .const 'Sub' $P801 = "56_1298845576.421" 
    capture_lex $P801
    .const 'Sub' $P793 = "55_1298845576.421" 
    capture_lex $P793
    .const 'Sub' $P785 = "54_1298845576.421" 
    capture_lex $P785
    .const 'Sub' $P777 = "53_1298845576.421" 
    capture_lex $P777
    .const 'Sub' $P769 = "52_1298845576.421" 
    capture_lex $P769
    .const 'Sub' $P761 = "51_1298845576.421" 
    capture_lex $P761
    .const 'Sub' $P745 = "50_1298845576.421" 
    capture_lex $P745
    .const 'Sub' $P712 = "49_1298845576.421" 
    capture_lex $P712
    .const 'Sub' $P698 = "48_1298845576.421" 
    capture_lex $P698
    .const 'Sub' $P679 = "47_1298845576.421" 
    capture_lex $P679
    .const 'Sub' $P661 = "46_1298845576.421" 
    capture_lex $P661
    .const 'Sub' $P637 = "45_1298845576.421" 
    capture_lex $P637
    .const 'Sub' $P603 = "44_1298845576.421" 
    capture_lex $P603
    .const 'Sub' $P588 = "43_1298845576.421" 
    capture_lex $P588
    .const 'Sub' $P576 = "42_1298845576.421" 
    capture_lex $P576
    .const 'Sub' $P525 = "40_1298845576.421" 
    capture_lex $P525
    .const 'Sub' $P518 = "39_1298845576.421" 
    capture_lex $P518
    .const 'Sub' $P509 = "38_1298845576.421" 
    capture_lex $P509
    .const 'Sub' $P498 = "37_1298845576.421" 
    capture_lex $P498
    .const 'Sub' $P463 = "35_1298845576.421" 
    capture_lex $P463
    .const 'Sub' $P455 = "34_1298845576.421" 
    capture_lex $P455
    .const 'Sub' $P447 = "33_1298845576.421" 
    capture_lex $P447
    .const 'Sub' $P433 = "32_1298845576.421" 
    capture_lex $P433
    .const 'Sub' $P352 = "30_1298845576.421" 
    capture_lex $P352
    .const 'Sub' $P311 = "28_1298845576.421" 
    capture_lex $P311
    .const 'Sub' $P275 = "27_1298845576.421" 
    capture_lex $P275
    .const 'Sub' $P244 = "26_1298845576.421" 
    capture_lex $P244
    .const 'Sub' $P236 = "25_1298845576.421" 
    capture_lex $P236
    .const 'Sub' $P228 = "23_1298845576.421" 
    capture_lex $P228
    .const 'Sub' $P214 = "22_1298845576.421" 
    capture_lex $P214
    .const 'Sub' $P149 = "20_1298845576.421" 
    capture_lex $P149
    .const 'Sub' $P139 = "19_1298845576.421" 
    capture_lex $P139
    .const 'Sub' $P91 = "18_1298845576.421" 
    capture_lex $P91
    .const 'Sub' $P78 = "17_1298845576.421" 
    capture_lex $P78
    .const 'Sub' $P60 = "16_1298845576.421" 
    capture_lex $P60
    .const 'Sub' $P27 = "13_1298845576.421" 
    capture_lex $P27
    .const 'Sub' $P19 = "12_1298845576.421" 
    capture_lex $P19
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "RegexActions"
    get_global $P18, "@BLOCK"
    unless_null $P18, vivify_173
    $P18 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P18
  vivify_173:
.annotate 'line', 9
    .const 'Sub' $P19 = "12_1298845576.421" 
    newclosure $P26, $P19
    .lex "xblock_immediate", $P26
.annotate 'line', 14
    .const 'Sub' $P27 = "13_1298845576.421" 
    newclosure $P59, $P27
    .lex "block_immediate", $P59
.annotate 'line', 24
    .const 'Sub' $P60 = "16_1298845576.421" 
    newclosure $P77, $P60
    .lex "vivitype", $P77
.annotate 'line', 43
    .const 'Sub' $P78 = "17_1298845576.421" 
    newclosure $P90, $P78
    .lex "colonpair_str", $P90
.annotate 'line', 239
    .const 'Sub' $P91 = "18_1298845576.421" 
    newclosure $P138, $P91
    .lex "push_block_handler", $P138
.annotate 'line', 778
    .const 'Sub' $P139 = "19_1298845576.421" 
    newclosure $P148, $P139
    .lex "only_star_block", $P148
.annotate 'line', 787
    .const 'Sub' $P149 = "20_1298845576.421" 
    newclosure $P213, $P149
    .lex "attach_multi_signature", $P213
.annotate 'line', 1263
    .const 'Sub' $P214 = "22_1298845576.421" 
    newclosure $P225, $P214
    .lex "control", $P225
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P226, "@BLOCK"
    .const 'Sub' $P228 = "23_1298845576.421" 
    capture_lex $P228
    $P228()
    find_lex $P233, "xblock_immediate"
    find_lex $P234, "block_immediate"
    find_lex $P235, "vivitype"
.annotate 'line', 35
    find_lex $P274, "colonpair_str"
.annotate 'line', 232
    find_lex $P697, "push_block_handler"
.annotate 'line', 706
    find_lex $P1829, "only_star_block"
    find_lex $P1830, "attach_multi_signature"
.annotate 'line', 1254
    find_lex $P2884, "control"
.annotate 'line', 1281
    get_hll_global $P2909, ["NQP";"RegexActions"], "_block2908" 
    capture_lex $P2909
    $P3029 = $P2909()
.annotate 'line', 3
    .return ($P3029)
    .const 'Sub' $P3031 = "169_1298845576.421" 
    .return ($P3031)
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post172") :outer("11_1298845576.421")
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P3035 = "170_1298845576.421" 
    capture_lex $P3035
    $P3035()
.end


.namespace ["NQP";"Actions"]
.sub "_block3034"  :anon :subid("170_1298845576.421") :outer("11_1298845576.421")
.annotate 'line', 3
    get_hll_global $P3036, "NQPClassHOW"
    $P3037 = $P3036."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3037
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3038, type_obj
    .const 'Sub' $P3039 = "25_1298845576.421" 
    $P3038."add_method"(type_obj, "TOP", $P3039)
    get_how $P3040, type_obj
    .const 'Sub' $P3041 = "26_1298845576.421" 
    $P3040."add_method"(type_obj, "deflongname", $P3041)
    get_how $P3042, type_obj
    .const 'Sub' $P3043 = "27_1298845576.421" 
    $P3042."add_method"(type_obj, "comp_unit", $P3043)
    get_how $P3044, type_obj
    .const 'Sub' $P3045 = "28_1298845576.421" 
    $P3044."add_method"(type_obj, "statementlist", $P3045)
    get_how $P3046, type_obj
    .const 'Sub' $P3047 = "30_1298845576.421" 
    $P3046."add_method"(type_obj, "statement", $P3047)
    get_how $P3048, type_obj
    .const 'Sub' $P3049 = "32_1298845576.421" 
    $P3048."add_method"(type_obj, "xblock", $P3049)
    get_how $P3050, type_obj
    .const 'Sub' $P3051 = "33_1298845576.421" 
    $P3050."add_method"(type_obj, "pblock", $P3051)
    get_how $P3052, type_obj
    .const 'Sub' $P3053 = "34_1298845576.421" 
    $P3052."add_method"(type_obj, "block", $P3053)
    get_how $P3054, type_obj
    .const 'Sub' $P3055 = "35_1298845576.421" 
    $P3054."add_method"(type_obj, "blockoid", $P3055)
    get_how $P3056, type_obj
    .const 'Sub' $P3057 = "37_1298845576.421" 
    $P3056."add_method"(type_obj, "newpad", $P3057)
    get_how $P3058, type_obj
    .const 'Sub' $P3059 = "38_1298845576.421" 
    $P3058."add_method"(type_obj, "outerctx", $P3059)
    get_how $P3060, type_obj
    .const 'Sub' $P3061 = "39_1298845576.421" 
    $P3060."add_method"(type_obj, "you_are_here", $P3061)
    get_how $P3062, type_obj
    .const 'Sub' $P3063 = "40_1298845576.421" 
    $P3062."add_method"(type_obj, "statement_control:sym<if>", $P3063)
    get_how $P3064, type_obj
    .const 'Sub' $P3065 = "42_1298845576.421" 
    $P3064."add_method"(type_obj, "statement_control:sym<unless>", $P3065)
    get_how $P3066, type_obj
    .const 'Sub' $P3067 = "43_1298845576.421" 
    $P3066."add_method"(type_obj, "statement_control:sym<while>", $P3067)
    get_how $P3068, type_obj
    .const 'Sub' $P3069 = "44_1298845576.421" 
    $P3068."add_method"(type_obj, "statement_control:sym<repeat>", $P3069)
    get_how $P3070, type_obj
    .const 'Sub' $P3071 = "45_1298845576.421" 
    $P3070."add_method"(type_obj, "statement_control:sym<for>", $P3071)
    get_how $P3072, type_obj
    .const 'Sub' $P3073 = "46_1298845576.421" 
    $P3072."add_method"(type_obj, "statement_control:sym<CATCH>", $P3073)
    get_how $P3074, type_obj
    .const 'Sub' $P3075 = "47_1298845576.421" 
    $P3074."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3075)
    get_how $P3076, type_obj
    .const 'Sub' $P3077 = "48_1298845576.421" 
    $P3076."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3077)
    get_how $P3078, type_obj
    .const 'Sub' $P3079 = "49_1298845576.421" 
    $P3078."add_method"(type_obj, "statement_prefix:sym<try>", $P3079)
    get_how $P3080, type_obj
    .const 'Sub' $P3081 = "50_1298845576.421" 
    $P3080."add_method"(type_obj, "blorst", $P3081)
    get_how $P3082, type_obj
    .const 'Sub' $P3083 = "51_1298845576.421" 
    $P3082."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3083)
    get_how $P3084, type_obj
    .const 'Sub' $P3085 = "52_1298845576.421" 
    $P3084."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3085)
    get_how $P3086, type_obj
    .const 'Sub' $P3087 = "53_1298845576.421" 
    $P3086."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3087)
    get_how $P3088, type_obj
    .const 'Sub' $P3089 = "54_1298845576.421" 
    $P3088."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3089)
    get_how $P3090, type_obj
    .const 'Sub' $P3091 = "55_1298845576.421" 
    $P3090."add_method"(type_obj, "term:sym<fatarrow>", $P3091)
    get_how $P3092, type_obj
    .const 'Sub' $P3093 = "56_1298845576.421" 
    $P3092."add_method"(type_obj, "term:sym<colonpair>", $P3093)
    get_how $P3094, type_obj
    .const 'Sub' $P3095 = "57_1298845576.421" 
    $P3094."add_method"(type_obj, "term:sym<variable>", $P3095)
    get_how $P3096, type_obj
    .const 'Sub' $P3097 = "58_1298845576.421" 
    $P3096."add_method"(type_obj, "term:sym<package_declarator>", $P3097)
    get_how $P3098, type_obj
    .const 'Sub' $P3099 = "59_1298845576.421" 
    $P3098."add_method"(type_obj, "term:sym<scope_declarator>", $P3099)
    get_how $P3100, type_obj
    .const 'Sub' $P3101 = "60_1298845576.421" 
    $P3100."add_method"(type_obj, "term:sym<routine_declarator>", $P3101)
    get_how $P3102, type_obj
    .const 'Sub' $P3103 = "61_1298845576.421" 
    $P3102."add_method"(type_obj, "term:sym<regex_declarator>", $P3103)
    get_how $P3104, type_obj
    .const 'Sub' $P3105 = "62_1298845576.421" 
    $P3104."add_method"(type_obj, "term:sym<statement_prefix>", $P3105)
    get_how $P3106, type_obj
    .const 'Sub' $P3107 = "63_1298845576.421" 
    $P3106."add_method"(type_obj, "term:sym<lambda>", $P3107)
    get_how $P3108, type_obj
    .const 'Sub' $P3109 = "64_1298845576.421" 
    $P3108."add_method"(type_obj, "fatarrow", $P3109)
    get_how $P3110, type_obj
    .const 'Sub' $P3111 = "65_1298845576.421" 
    $P3110."add_method"(type_obj, "colonpair", $P3111)
    get_how $P3112, type_obj
    .const 'Sub' $P3113 = "66_1298845576.421" 
    $P3112."add_method"(type_obj, "variable", $P3113)
    get_how $P3114, type_obj
    .const 'Sub' $P3115 = "68_1298845576.421" 
    $P3114."add_method"(type_obj, "package_declarator:sym<module>", $P3115)
    get_how $P3116, type_obj
    .const 'Sub' $P3117 = "69_1298845576.421" 
    $P3116."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3117)
    get_how $P3118, type_obj
    .const 'Sub' $P3119 = "70_1298845576.421" 
    $P3118."add_method"(type_obj, "package_declarator:sym<class>", $P3119)
    get_how $P3120, type_obj
    .const 'Sub' $P3121 = "71_1298845576.421" 
    $P3120."add_method"(type_obj, "package_declarator:sym<grammar>", $P3121)
    get_how $P3122, type_obj
    .const 'Sub' $P3123 = "72_1298845576.421" 
    $P3122."add_method"(type_obj, "package_declarator:sym<role>", $P3123)
    get_how $P3124, type_obj
    .const 'Sub' $P3125 = "73_1298845576.421" 
    $P3124."add_method"(type_obj, "package_declarator:sym<native>", $P3125)
    get_how $P3126, type_obj
    .const 'Sub' $P3127 = "74_1298845576.421" 
    $P3126."add_method"(type_obj, "package_def", $P3127)
    get_how $P3128, type_obj
    .const 'Sub' $P3129 = "78_1298845576.421" 
    $P3128."add_method"(type_obj, "scope_declarator:sym<my>", $P3129)
    get_how $P3130, type_obj
    .const 'Sub' $P3131 = "79_1298845576.421" 
    $P3130."add_method"(type_obj, "scope_declarator:sym<our>", $P3131)
    get_how $P3132, type_obj
    .const 'Sub' $P3133 = "80_1298845576.421" 
    $P3132."add_method"(type_obj, "scope_declarator:sym<has>", $P3133)
    get_how $P3134, type_obj
    .const 'Sub' $P3135 = "81_1298845576.421" 
    $P3134."add_method"(type_obj, "scoped", $P3135)
    get_how $P3136, type_obj
    .const 'Sub' $P3137 = "82_1298845576.421" 
    $P3136."add_method"(type_obj, "declarator", $P3137)
    get_how $P3138, type_obj
    .const 'Sub' $P3139 = "83_1298845576.421" 
    $P3138."add_method"(type_obj, "multi_declarator:sym<multi>", $P3139)
    get_how $P3140, type_obj
    .const 'Sub' $P3141 = "84_1298845576.421" 
    $P3140."add_method"(type_obj, "multi_declarator:sym<proto>", $P3141)
    get_how $P3142, type_obj
    .const 'Sub' $P3143 = "85_1298845576.421" 
    $P3142."add_method"(type_obj, "multi_declarator:sym<null>", $P3143)
    get_how $P3144, type_obj
    .const 'Sub' $P3145 = "86_1298845576.421" 
    $P3144."add_method"(type_obj, "variable_declarator", $P3145)
    get_how $P3146, type_obj
    .const 'Sub' $P3147 = "90_1298845576.421" 
    $P3146."add_method"(type_obj, "routine_declarator:sym<sub>", $P3147)
    get_how $P3148, type_obj
    .const 'Sub' $P3149 = "91_1298845576.421" 
    $P3148."add_method"(type_obj, "routine_declarator:sym<method>", $P3149)
    get_how $P3150, type_obj
    .const 'Sub' $P3151 = "92_1298845576.421" 
    $P3150."add_method"(type_obj, "routine_def", $P3151)
    get_how $P3152, type_obj
    .const 'Sub' $P3153 = "99_1298845576.421" 
    $P3152."add_method"(type_obj, "method_def", $P3153)
    get_how $P3154, type_obj
    .const 'Sub' $P3155 = "102_1298845576.421" 
    $P3154."add_method"(type_obj, "signature", $P3155)
    get_how $P3156, type_obj
    .const 'Sub' $P3157 = "105_1298845576.421" 
    $P3156."add_method"(type_obj, "parameter", $P3157)
    get_how $P3158, type_obj
    .const 'Sub' $P3159 = "106_1298845576.421" 
    $P3158."add_method"(type_obj, "param_var", $P3159)
    get_how $P3160, type_obj
    .const 'Sub' $P3161 = "107_1298845576.421" 
    $P3160."add_method"(type_obj, "named_param", $P3161)
    get_how $P3162, type_obj
    .const 'Sub' $P3163 = "108_1298845576.421" 
    $P3162."add_method"(type_obj, "typename", $P3163)
    get_how $P3164, type_obj
    .const 'Sub' $P3165 = "109_1298845576.421" 
    $P3164."add_method"(type_obj, "trait", $P3165)
    get_how $P3166, type_obj
    .const 'Sub' $P3167 = "110_1298845576.421" 
    $P3166."add_method"(type_obj, "trait_mod:sym<is>", $P3167)
    get_how $P3168, type_obj
    .const 'Sub' $P3169 = "112_1298845576.421" 
    $P3168."add_method"(type_obj, "regex_declarator", $P3169)
    get_how $P3170, type_obj
    .const 'Sub' $P3171 = "116_1298845576.421" 
    $P3170."add_method"(type_obj, "dotty", $P3171)
    get_how $P3172, type_obj
    .const 'Sub' $P3173 = "117_1298845576.421" 
    $P3172."add_method"(type_obj, "term:sym<self>", $P3173)
    get_how $P3174, type_obj
    .const 'Sub' $P3175 = "118_1298845576.421" 
    $P3174."add_method"(type_obj, "term:sym<identifier>", $P3175)
    get_how $P3176, type_obj
    .const 'Sub' $P3177 = "119_1298845576.421" 
    $P3176."add_method"(type_obj, "term:sym<name>", $P3177)
    get_how $P3178, type_obj
    .const 'Sub' $P3179 = "120_1298845576.421" 
    $P3178."add_method"(type_obj, "term:sym<pir::op>", $P3179)
    get_how $P3180, type_obj
    .const 'Sub' $P3181 = "121_1298845576.421" 
    $P3180."add_method"(type_obj, "term:sym<onlystar>", $P3181)
    get_how $P3182, type_obj
    .const 'Sub' $P3183 = "122_1298845576.421" 
    $P3182."add_method"(type_obj, "args", $P3183)
    get_how $P3184, type_obj
    .const 'Sub' $P3185 = "123_1298845576.421" 
    $P3184."add_method"(type_obj, "arglist", $P3185)
    get_how $P3186, type_obj
    .const 'Sub' $P3187 = "126_1298845576.421" 
    $P3186."add_method"(type_obj, "term:sym<multi_declarator>", $P3187)
    get_how $P3188, type_obj
    .const 'Sub' $P3189 = "127_1298845576.421" 
    $P3188."add_method"(type_obj, "term:sym<value>", $P3189)
    get_how $P3190, type_obj
    .const 'Sub' $P3191 = "128_1298845576.421" 
    $P3190."add_method"(type_obj, "circumfix:sym<( )>", $P3191)
    get_how $P3192, type_obj
    .const 'Sub' $P3193 = "129_1298845576.421" 
    $P3192."add_method"(type_obj, "circumfix:sym<[ ]>", $P3193)
    get_how $P3194, type_obj
    .const 'Sub' $P3195 = "130_1298845576.421" 
    $P3194."add_method"(type_obj, "circumfix:sym<ang>", $P3195)
    get_how $P3196, type_obj
    .const 'Sub' $P3197 = "131_1298845576.421" 
    $P3196."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3197)
    get_how $P3198, type_obj
    .const 'Sub' $P3199 = "132_1298845576.421" 
    $P3198."add_method"(type_obj, "circumfix:sym<{ }>", $P3199)
    get_how $P3200, type_obj
    .const 'Sub' $P3201 = "134_1298845576.421" 
    $P3200."add_method"(type_obj, "circumfix:sym<sigil>", $P3201)
    get_how $P3202, type_obj
    .const 'Sub' $P3203 = "135_1298845576.421" 
    $P3202."add_method"(type_obj, "semilist", $P3203)
    get_how $P3204, type_obj
    .const 'Sub' $P3205 = "136_1298845576.421" 
    $P3204."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3205)
    get_how $P3206, type_obj
    .const 'Sub' $P3207 = "137_1298845576.421" 
    $P3206."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3207)
    get_how $P3208, type_obj
    .const 'Sub' $P3209 = "138_1298845576.421" 
    $P3208."add_method"(type_obj, "postcircumfix:sym<ang>", $P3209)
    get_how $P3210, type_obj
    .const 'Sub' $P3211 = "139_1298845576.421" 
    $P3210."add_method"(type_obj, "postcircumfix:sym<( )>", $P3211)
    get_how $P3212, type_obj
    .const 'Sub' $P3213 = "140_1298845576.421" 
    $P3212."add_method"(type_obj, "value", $P3213)
    get_how $P3214, type_obj
    .const 'Sub' $P3215 = "141_1298845576.421" 
    $P3214."add_method"(type_obj, "number", $P3215)
    get_how $P3216, type_obj
    .const 'Sub' $P3217 = "142_1298845576.421" 
    $P3216."add_method"(type_obj, "quote:sym<apos>", $P3217)
    get_how $P3218, type_obj
    .const 'Sub' $P3219 = "143_1298845576.421" 
    $P3218."add_method"(type_obj, "quote:sym<dblq>", $P3219)
    get_how $P3220, type_obj
    .const 'Sub' $P3221 = "144_1298845576.421" 
    $P3220."add_method"(type_obj, "quote:sym<qq>", $P3221)
    get_how $P3222, type_obj
    .const 'Sub' $P3223 = "145_1298845576.421" 
    $P3222."add_method"(type_obj, "quote:sym<q>", $P3223)
    get_how $P3224, type_obj
    .const 'Sub' $P3225 = "146_1298845576.421" 
    $P3224."add_method"(type_obj, "quote:sym<Q>", $P3225)
    get_how $P3226, type_obj
    .const 'Sub' $P3227 = "147_1298845576.421" 
    $P3226."add_method"(type_obj, "quote:sym<Q:PIR>", $P3227)
    get_how $P3228, type_obj
    .const 'Sub' $P3229 = "148_1298845576.421" 
    $P3228."add_method"(type_obj, "quote:sym</ />", $P3229)
    get_how $P3230, type_obj
    .const 'Sub' $P3231 = "149_1298845576.421" 
    $P3230."add_method"(type_obj, "quote_escape:sym<$>", $P3231)
    get_how $P3232, type_obj
    .const 'Sub' $P3233 = "150_1298845576.421" 
    $P3232."add_method"(type_obj, "quote_escape:sym<{ }>", $P3233)
    get_how $P3234, type_obj
    .const 'Sub' $P3235 = "151_1298845576.421" 
    $P3234."add_method"(type_obj, "quote_escape:sym<esc>", $P3235)
    get_how $P3236, type_obj
    .const 'Sub' $P3237 = "152_1298845576.421" 
    $P3236."add_method"(type_obj, "postfix:sym<.>", $P3237)
    get_how $P3238, type_obj
    .const 'Sub' $P3239 = "153_1298845576.421" 
    $P3238."add_method"(type_obj, "postfix:sym<++>", $P3239)
    get_how $P3240, type_obj
    .const 'Sub' $P3241 = "154_1298845576.421" 
    $P3240."add_method"(type_obj, "postfix:sym<-->", $P3241)
    get_how $P3242, type_obj
    .const 'Sub' $P3243 = "155_1298845576.421" 
    $P3242."add_method"(type_obj, "prefix:sym<make>", $P3243)
    get_how $P3244, type_obj
    .const 'Sub' $P3245 = "156_1298845576.421" 
    $P3244."add_method"(type_obj, "term:sym<next>", $P3245)
    get_how $P3246, type_obj
    .const 'Sub' $P3247 = "157_1298845576.421" 
    $P3246."add_method"(type_obj, "term:sym<last>", $P3247)
    get_how $P3248, type_obj
    .const 'Sub' $P3249 = "158_1298845576.421" 
    $P3248."add_method"(type_obj, "term:sym<redo>", $P3249)
    get_how $P3250, type_obj
    .const 'Sub' $P3251 = "159_1298845576.421" 
    $P3250."add_method"(type_obj, "infix:sym<~~>", $P3251)
    get_how $P3252, type_obj
    get_hll_global $P3253, ["HLL"], "Actions"
    $P3252."add_parent"(type_obj, $P3253)
    get_how $P3254, type_obj
    $P3255 = $P3254."compose"(type_obj)
    .return ($P3255)
.end


.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_20
.annotate 'line', 9
    .lex "$xblock", param_20
.annotate 'line', 10
    find_lex $P21, "$xblock"
    unless_null $P21, vivify_174
    $P21 = root_new ['parrot';'ResizablePMCArray']
  vivify_174:
    set $P22, $P21[1]
    unless_null $P22, vivify_175
    new $P22, "Undef"
  vivify_175:
    $P23 = "block_immediate"($P22)
    find_lex $P24, "$xblock"
    unless_null $P24, vivify_176
    $P24 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P24
  vivify_176:
    set $P24[1], $P23
    find_lex $P25, "$xblock"
.annotate 'line', 9
    .return ($P25)
.end


.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_28
.annotate 'line', 14
    .const 'Sub' $P38 = "14_1298845576.421" 
    capture_lex $P38
    .lex "$block", param_28
.annotate 'line', 15
    find_lex $P29, "$block"
    $P29."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P33, "$block"
    $P34 = $P33."symtable"()
    unless $P34, unless_32
    set $P31, $P34
    goto unless_32_end
  unless_32:
    find_lex $P35, "$block"
    $P36 = $P35."handlers"()
    set $P31, $P36
  unless_32_end:
    if $P31, unless_30_end
    .const 'Sub' $P38 = "14_1298845576.421" 
    capture_lex $P38
    $P38()
  unless_30_end:
    find_lex $P58, "$block"
.annotate 'line', 14
    .return ($P58)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block37"  :anon :subid("14_1298845576.421") :outer("13_1298845576.421")
.annotate 'line', 16
    .const 'Sub' $P49 = "15_1298845576.421" 
    capture_lex $P49
.annotate 'line', 17
    new $P39, "Undef"
    .lex "$stmts", $P39
    get_hll_global $P40, ["PAST"], "Stmts"
    find_lex $P41, "$block"
    $P42 = $P40."new"($P41 :named("node"))
    store_lex "$stmts", $P42
.annotate 'line', 18
    find_lex $P44, "$block"
    $P45 = $P44."list"()
    defined $I46, $P45
    unless $I46, for_undef_177
    iter $P43, $P45
    new $P55, 'ExceptionHandler'
    set_label $P55, loop54_handler
    $P55."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P55
  loop54_test:
    unless $P43, loop54_done
    shift $P47, $P43
  loop54_redo:
    .const 'Sub' $P49 = "15_1298845576.421" 
    capture_lex $P49
    $P49($P47)
  loop54_next:
    goto loop54_test
  loop54_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P56, exception, 'type'
    eq $P56, .CONTROL_LOOP_NEXT, loop54_next
    eq $P56, .CONTROL_LOOP_REDO, loop54_redo
  loop54_done:
    pop_eh 
  for_undef_177:
.annotate 'line', 19
    find_lex $P57, "$stmts"
    store_lex "$block", $P57
.annotate 'line', 16
    .return ($P57)
.end


.namespace ["NQP";"Actions"]
.sub "_block48"  :anon :subid("15_1298845576.421") :outer("14_1298845576.421")
    .param pmc param_50
.annotate 'line', 18
    .lex "$_", param_50
    find_lex $P51, "$stmts"
    find_lex $P52, "$_"
    $P53 = $P51."push"($P52)
    .return ($P53)
.end


.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_61
.annotate 'line', 24
    .lex "$sigil", param_61
.annotate 'line', 25
    find_lex $P64, "$sigil"
    set $S65, $P64
    iseq $I66, $S65, "%"
    if $I66, if_63
.annotate 'line', 27
    find_lex $P71, "$sigil"
    set $S72, $P71
    iseq $I73, $S72, "@"
    if $I73, if_70
    new $P76, "String"
    assign $P76, "Undef"
    set $P69, $P76
    goto if_70_end
  if_70:
.annotate 'line', 28
    get_hll_global $P74, ["PAST"], "Op"
    $P75 = $P74."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P69, $P75
  if_70_end:
    set $P62, $P69
.annotate 'line', 25
    goto if_63_end
  if_63:
.annotate 'line', 26
    get_hll_global $P67, ["PAST"], "Op"
    $P68 = $P67."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P62, $P68
  if_63_end:
.annotate 'line', 24
    .return ($P62)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_79
.annotate 'line', 43
    .lex "$ast", param_79
.annotate 'line', 44
    get_hll_global $P82, ["PAST"], "Op"
    find_lex $P83, "$ast"
    $P84 = $P82."ACCEPTS"($P83)
    if $P84, if_81
.annotate 'line', 46
    find_lex $P88, "$ast"
    $P89 = $P88."value"()
    set $P80, $P89
.annotate 'line', 44
    goto if_81_end
  if_81:
.annotate 'line', 45
    find_lex $P85, "$ast"
    $P86 = $P85."list"()
    join $S87, " ", $P86
    new $P80, 'String'
    set $P80, $S87
  if_81_end:
.annotate 'line', 43
    .return ($P80)
.end


.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_92
    .param pmc param_93
.annotate 'line', 239
    .lex "$/", param_92
    .lex "$block", param_93
.annotate 'line', 240
    get_global $P95, "@BLOCK"
    unless_null $P95, vivify_178
    $P95 = root_new ['parrot';'ResizablePMCArray']
  vivify_178:
    set $P96, $P95[0]
    unless_null $P96, vivify_179
    new $P96, "Undef"
  vivify_179:
    $P97 = $P96."handlers"()
    if $P97, unless_94_end
.annotate 'line', 241
    get_global $P98, "@BLOCK"
    unless_null $P98, vivify_180
    $P98 = root_new ['parrot';'ResizablePMCArray']
  vivify_180:
    set $P99, $P98[0]
    unless_null $P99, vivify_181
    new $P99, "Undef"
  vivify_181:
    new $P100, "ResizablePMCArray"
    $P99."handlers"($P100)
  unless_94_end:
.annotate 'line', 243
    find_lex $P102, "$block"
    $P103 = $P102."arity"()
    if $P103, unless_101_end
.annotate 'line', 244
    find_lex $P104, "$block"
.annotate 'line', 245
    get_hll_global $P105, ["PAST"], "Op"
.annotate 'line', 246
    get_hll_global $P106, ["PAST"], "Var"
    $P107 = $P106."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 247
    get_hll_global $P108, ["PAST"], "Var"
    $P109 = $P108."new"("lexical" :named("scope"), "$_" :named("name"))
    $P110 = $P105."new"($P107, $P109, "bind" :named("pasttype"))
.annotate 'line', 245
    $P104."unshift"($P110)
.annotate 'line', 250
    find_lex $P111, "$block"
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("$_" :named("name"), "parameter" :named("scope"))
    $P111."unshift"($P113)
.annotate 'line', 251
    find_lex $P114, "$block"
    $P114."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 252
    find_lex $P115, "$block"
    $P115."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 253
    find_lex $P116, "$block"
    $P116."arity"(1)
  unless_101_end:
.annotate 'line', 255
    find_lex $P117, "$block"
    $P117."blocktype"("declaration")
.annotate 'line', 256
    get_global $P118, "@BLOCK"
    unless_null $P118, vivify_182
    $P118 = root_new ['parrot';'ResizablePMCArray']
  vivify_182:
    set $P119, $P118[0]
    unless_null $P119, vivify_183
    new $P119, "Undef"
  vivify_183:
    $P120 = $P119."handlers"()
.annotate 'line', 257
    get_hll_global $P121, ["PAST"], "Control"
    find_lex $P122, "$/"
.annotate 'line', 259
    get_hll_global $P123, ["PAST"], "Stmts"
.annotate 'line', 260
    get_hll_global $P124, ["PAST"], "Op"
    find_lex $P125, "$block"
.annotate 'line', 262
    get_hll_global $P126, ["PAST"], "Var"
    $P127 = $P126."new"("register" :named("scope"), "exception" :named("name"))
    $P128 = $P124."new"($P125, $P127, "call" :named("pasttype"))
.annotate 'line', 264
    get_hll_global $P129, ["PAST"], "Op"
.annotate 'line', 265
    get_hll_global $P130, ["PAST"], "Var"
.annotate 'line', 266
    get_hll_global $P131, ["PAST"], "Var"
    $P132 = $P131."new"("register" :named("scope"), "exception" :named("name"))
    $P133 = $P130."new"($P132, "handled", "keyed" :named("scope"))
.annotate 'line', 265
    $P134 = $P129."new"($P133, 1, "bind" :named("pasttype"))
.annotate 'line', 264
    $P135 = $P123."new"($P128, $P134)
.annotate 'line', 259
    $P136 = $P121."new"($P135, $P122 :named("node"))
.annotate 'line', 257
    $P137 = $P120."unshift"($P136)
.annotate 'line', 239
    .return ($P137)
.end


.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1298845576.421") :outer("11_1298845576.421")
.annotate 'line', 779
    new $P140, "Undef"
    .lex "$past", $P140
    get_global $P141, "@BLOCK"
    $P142 = $P141."shift"()
    store_lex "$past", $P142
.annotate 'line', 780
    find_lex $P143, "$past"
    $P143."closure"(1)
.annotate 'line', 781
    find_lex $P144, "$past"
    get_hll_global $P145, ["PAST"], "Op"
    $P146 = $P145."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P144."push"($P146)
    find_lex $P147, "$past"
.annotate 'line', 778
    .return ($P147)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_150
.annotate 'line', 787
    .const 'Sub' $P164 = "21_1298845576.421" 
    capture_lex $P164
    .lex "$routine", param_150
.annotate 'line', 791
    new $P151, "Undef"
    .lex "$types", $P151
.annotate 'line', 792
    new $P152, "Undef"
    .lex "$definednesses", $P152
.annotate 'line', 791
    get_hll_global $P153, ["PAST"], "Op"
    $P154 = $P153."new"("list" :named("pasttype"))
    store_lex "$types", $P154
.annotate 'line', 792
    get_hll_global $P155, ["PAST"], "Op"
    $P156 = $P155."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P156
.annotate 'line', 793
    find_lex $P158, "$routine"
    unless_null $P158, vivify_184
    $P158 = root_new ['parrot';'ResizablePMCArray']
  vivify_184:
    set $P159, $P158[0]
    unless_null $P159, vivify_185
    new $P159, "Undef"
  vivify_185:
    $P160 = $P159."list"()
    defined $I161, $P160
    unless $I161, for_undef_186
    iter $P157, $P160
    new $P202, 'ExceptionHandler'
    set_label $P202, loop201_handler
    $P202."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P202
  loop201_test:
    unless $P157, loop201_done
    shift $P162, $P157
  loop201_redo:
    .const 'Sub' $P164 = "21_1298845576.421" 
    capture_lex $P164
    $P164($P162)
  loop201_next:
    goto loop201_test
  loop201_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P203, exception, 'type'
    eq $P203, .CONTROL_LOOP_NEXT, loop201_next
    eq $P203, .CONTROL_LOOP_REDO, loop201_redo
  loop201_done:
    pop_eh 
  for_undef_186:
.annotate 'line', 800
    find_lex $P204, "$routine"
    $P205 = $P204."loadinit"()
    get_hll_global $P206, ["PAST"], "Op"
.annotate 'line', 801
    get_hll_global $P207, ["PAST"], "Var"
    $P208 = $P207."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P209, "$types"
    find_lex $P210, "$definednesses"
    $P211 = $P206."new"($P208, $P209, $P210, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 800
    $P212 = $P205."push"($P211)
.annotate 'line', 787
    .return ($P212)
.end


.namespace ["NQP";"Actions"]
.sub "_block163"  :anon :subid("21_1298845576.421") :outer("20_1298845576.421")
    .param pmc param_165
.annotate 'line', 793
    .lex "$_", param_165
.annotate 'line', 794
    get_hll_global $P170, ["PAST"], "Var"
    find_lex $P171, "$_"
    $P172 = $P170."ACCEPTS"($P171)
    if $P172, if_169
    set $P168, $P172
    goto if_169_end
  if_169:
    find_lex $P173, "$_"
    $S174 = $P173."scope"()
    iseq $I175, $S174, "parameter"
    new $P168, 'Integer'
    set $P168, $I175
  if_169_end:
    if $P168, if_167
    set $P166, $P168
    goto if_167_end
  if_167:
.annotate 'line', 795
    find_lex $P176, "$types"
    find_lex $P178, "$_"
    $P179 = $P178."multitype"()
    set $P177, $P179
    defined $I181, $P177
    if $I181, default_180
    get_hll_global $P182, ["PAST"], "Op"
    $P183 = $P182."new"("null P" :named("pirop"))
    set $P177, $P183
  default_180:
    $P176."push"($P177)
.annotate 'line', 796
    find_lex $P184, "$definednesses"
    find_lex $P187, "$_"
    unless_null $P187, vivify_187
    $P187 = root_new ['parrot';'Hash']
  vivify_187:
    set $P188, $P187["definedness"]
    unless_null $P188, vivify_188
    new $P188, "Undef"
  vivify_188:
    set $S189, $P188
    iseq $I190, $S189, "D"
    if $I190, if_186
.annotate 'line', 797
    find_lex $P194, "$_"
    unless_null $P194, vivify_189
    $P194 = root_new ['parrot';'Hash']
  vivify_189:
    set $P195, $P194["definedness"]
    unless_null $P195, vivify_190
    new $P195, "Undef"
  vivify_190:
    set $S196, $P195
    iseq $I197, $S196, "U"
    if $I197, if_193
    new $P199, "Integer"
    assign $P199, 0
    set $P192, $P199
    goto if_193_end
  if_193:
    new $P198, "Integer"
    assign $P198, 2
    set $P192, $P198
  if_193_end:
    set $P185, $P192
.annotate 'line', 796
    goto if_186_end
  if_186:
    new $P191, "Integer"
    assign $P191, 1
    set $P185, $P191
  if_186_end:
    $P200 = $P184."push"($P185)
.annotate 'line', 794
    set $P166, $P200
  if_167_end:
.annotate 'line', 793
    .return ($P166)
.end


.namespace ["NQP";"Actions"]
.sub "control"  :subid("22_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_215
    .param pmc param_216
.annotate 'line', 1263
    .lex "$/", param_215
    .lex "$type", param_216
.annotate 'line', 1264
    find_lex $P217, "$/"
    get_hll_global $P218, ["PAST"], "Op"
    find_lex $P219, "$/"
.annotate 'line', 1268
    get_hll_global $P220, ["PAST"], "Val"
    find_lex $P221, "$type"
    $P222 = $P220."new"($P221 :named("value"), "!except_types" :named("returns"))
    $P223 = $P218."new"(0, $P222, $P219 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1264
    $P224 = $P217."!make"($P223)
.annotate 'line', 1263
    .return ($P224)
.end


.namespace ["NQP";"Actions"]
.sub "_block227"  :anon :subid("23_1298845576.421") :outer("11_1298845576.421")
.annotate 'line', 3
    .const 'Sub' $P230 = "24_1298845576.421" 
    capture_lex $P230
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post191") :outer("23_1298845576.421")
.annotate 'line', 3
    .const 'Sub' $P228 = "23_1298845576.421" 
    .local pmc block
    set block, $P228
.annotate 'line', 5
    .const 'Sub' $P230 = "24_1298845576.421" 
    capture_lex $P230
    $P230()
.end


.namespace ["NQP";"Actions"]
.sub "_block229"  :anon :subid("24_1298845576.421") :outer("23_1298845576.421")
.annotate 'line', 6
    get_global $P231, "@BLOCK"
    unless_null $P231, vivify_192
    $P231 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P231
  vivify_192:
 $P232 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P232
.annotate 'line', 5
    .return ($P232)
.end


.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("25_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_237
    .param pmc param_238
.annotate 'line', 33
    .lex "self", param_237
    .lex "$/", param_238
    find_lex $P239, "$/"
    find_lex $P240, "$/"
    unless_null $P240, vivify_193
    $P240 = root_new ['parrot';'Hash']
  vivify_193:
    set $P241, $P240["comp_unit"]
    unless_null $P241, vivify_194
    new $P241, "Undef"
  vivify_194:
    $P242 = $P241."ast"()
    $P243 = $P239."!make"($P242)
    .return ($P243)
.end


.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("26_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_245
    .param pmc param_246
.annotate 'line', 35
    .lex "self", param_245
    .lex "$/", param_246
.annotate 'line', 36
    find_lex $P247, "$/"
.annotate 'line', 37
    find_lex $P250, "$/"
    unless_null $P250, vivify_195
    $P250 = root_new ['parrot';'Hash']
  vivify_195:
    set $P251, $P250["colonpair"]
    unless_null $P251, vivify_196
    new $P251, "Undef"
  vivify_196:
    if $P251, if_249
.annotate 'line', 39
    find_lex $P271, "$/"
    set $S272, $P271
    new $P248, 'String'
    set $P248, $S272
.annotate 'line', 37
    goto if_249_end
  if_249:
    find_lex $P252, "$/"
    unless_null $P252, vivify_197
    $P252 = root_new ['parrot';'Hash']
  vivify_197:
    set $P253, $P252["identifier"]
    unless_null $P253, vivify_198
    new $P253, "Undef"
  vivify_198:
    set $S254, $P253
    new $P255, 'String'
    set $P255, $S254
    concat $P256, $P255, ":"
    find_lex $P257, "$/"
    unless_null $P257, vivify_199
    $P257 = root_new ['parrot';'Hash']
  vivify_199:
    set $P258, $P257["colonpair"]
    unless_null $P258, vivify_200
    $P258 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P259, $P258[0]
    unless_null $P259, vivify_201
    new $P259, "Undef"
  vivify_201:
    $P260 = $P259."ast"()
    $S261 = $P260."named"()
    concat $P262, $P256, $S261
    concat $P263, $P262, "<"
.annotate 'line', 38
    find_lex $P264, "$/"
    unless_null $P264, vivify_202
    $P264 = root_new ['parrot';'Hash']
  vivify_202:
    set $P265, $P264["colonpair"]
    unless_null $P265, vivify_203
    $P265 = root_new ['parrot';'ResizablePMCArray']
  vivify_203:
    set $P266, $P265[0]
    unless_null $P266, vivify_204
    new $P266, "Undef"
  vivify_204:
    $P267 = $P266."ast"()
    $S268 = "colonpair_str"($P267)
    concat $P269, $P263, $S268
    concat $P270, $P269, ">"
    set $P248, $P270
  if_249_end:
.annotate 'line', 37
    $P273 = $P247."!make"($P248)
.annotate 'line', 35
    .return ($P273)
.end


.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("27_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_276
    .param pmc param_277
.annotate 'line', 49
    .lex "self", param_276
    .lex "$/", param_277
.annotate 'line', 50
    new $P278, "Undef"
    .lex "$mainline", $P278
.annotate 'line', 51
    new $P279, "Undef"
    .lex "$unit", $P279
.annotate 'line', 50
    find_lex $P280, "$/"
    unless_null $P280, vivify_205
    $P280 = root_new ['parrot';'Hash']
  vivify_205:
    set $P281, $P280["statementlist"]
    unless_null $P281, vivify_206
    new $P281, "Undef"
  vivify_206:
    $P282 = $P281."ast"()
    store_lex "$mainline", $P282
.annotate 'line', 51
    get_global $P283, "@BLOCK"
    $P284 = $P283."shift"()
    store_lex "$unit", $P284
.annotate 'line', 56
    find_dynamic_lex $P286, "$*HAS_YOU_ARE_HERE"
    unless_null $P286, vivify_207
    get_hll_global $P286, "$HAS_YOU_ARE_HERE"
    unless_null $P286, vivify_208
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_208:
  vivify_207:
    if $P286, unless_285_end
.annotate 'line', 57
    find_lex $P287, "$unit"
    find_lex $P288, "self"
    $P289 = $P288."CTXSAVE"()
    $P287."push"($P289)
  unless_285_end:
.annotate 'line', 61
    find_lex $P290, "$unit"
    $P290."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 62
    find_lex $P291, "$unit"
    get_hll_global $P292, ["PAST"], "Op"
    $P293 = $P292."new"("nqp_dynop_setup v" :named("pirop"))
    $P291."unshift"($P293)
.annotate 'line', 67
    find_lex $P294, "$unit"
.annotate 'line', 68
    get_hll_global $P295, ["PAST"], "Op"
    find_lex $P296, "$mainline"
    $P297 = $P295."new"($P296, "return" :named("pirop"))
    $P294."push"($P297)
.annotate 'line', 73
    find_lex $P298, "$unit"
.annotate 'line', 74
    get_hll_global $P299, ["PAST"], "Block"
.annotate 'line', 76
    get_hll_global $P300, ["PAST"], "Op"
    get_hll_global $P301, ["PAST"], "Val"
    find_lex $P302, "$unit"
    $P303 = $P301."new"($P302 :named("value"))
    $P304 = $P300."new"($P303, "call" :named("pasttype"))
    $P305 = $P299."new"($P304, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 74
    $P298."push"($P305)
.annotate 'line', 79
    find_lex $P306, "$unit"
    find_lex $P307, "$/"
    $P306."node"($P307)
.annotate 'line', 80
    find_lex $P308, "$/"
    find_lex $P309, "$unit"
    $P310 = $P308."!make"($P309)
.annotate 'line', 49
    .return ($P310)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("28_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_312
    .param pmc param_313
.annotate 'line', 83
    .const 'Sub' $P327 = "29_1298845576.421" 
    capture_lex $P327
    .lex "self", param_312
    .lex "$/", param_313
.annotate 'line', 84
    new $P314, "Undef"
    .lex "$past", $P314
    get_hll_global $P315, ["PAST"], "Stmts"
    find_lex $P316, "$/"
    $P317 = $P315."new"($P316 :named("node"))
    store_lex "$past", $P317
.annotate 'line', 85
    find_lex $P319, "$/"
    unless_null $P319, vivify_209
    $P319 = root_new ['parrot';'Hash']
  vivify_209:
    set $P320, $P319["statement"]
    unless_null $P320, vivify_210
    new $P320, "Undef"
  vivify_210:
    unless $P320, if_318_end
.annotate 'line', 86
    find_lex $P322, "$/"
    unless_null $P322, vivify_211
    $P322 = root_new ['parrot';'Hash']
  vivify_211:
    set $P323, $P322["statement"]
    unless_null $P323, vivify_212
    new $P323, "Undef"
  vivify_212:
    defined $I324, $P323
    unless $I324, for_undef_213
    iter $P321, $P323
    new $P347, 'ExceptionHandler'
    set_label $P347, loop346_handler
    $P347."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P347
  loop346_test:
    unless $P321, loop346_done
    shift $P325, $P321
  loop346_redo:
    .const 'Sub' $P327 = "29_1298845576.421" 
    capture_lex $P327
    $P327($P325)
  loop346_next:
    goto loop346_test
  loop346_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P348, exception, 'type'
    eq $P348, .CONTROL_LOOP_NEXT, loop346_next
    eq $P348, .CONTROL_LOOP_REDO, loop346_redo
  loop346_done:
    pop_eh 
  for_undef_213:
  if_318_end:
.annotate 'line', 93
    find_lex $P349, "$/"
    find_lex $P350, "$past"
    $P351 = $P349."!make"($P350)
.annotate 'line', 83
    .return ($P351)
.end


.namespace ["NQP";"Actions"]
.sub "_block326"  :anon :subid("29_1298845576.421") :outer("28_1298845576.421")
    .param pmc param_329
.annotate 'line', 87
    new $P328, "Undef"
    .lex "$ast", $P328
    .lex "$_", param_329
    find_lex $P330, "$_"
    $P331 = $P330."ast"()
    store_lex "$ast", $P331
.annotate 'line', 88
    find_lex $P333, "$ast"
    unless_null $P333, vivify_214
    $P333 = root_new ['parrot';'Hash']
  vivify_214:
    set $P334, $P333["sink"]
    unless_null $P334, vivify_215
    new $P334, "Undef"
  vivify_215:
    defined $I335, $P334
    unless $I335, if_332_end
    find_lex $P336, "$ast"
    unless_null $P336, vivify_216
    $P336 = root_new ['parrot';'Hash']
  vivify_216:
    set $P337, $P336["sink"]
    unless_null $P337, vivify_217
    new $P337, "Undef"
  vivify_217:
    store_lex "$ast", $P337
  if_332_end:
.annotate 'line', 89
    find_lex $P339, "$ast"
    unless_null $P339, vivify_218
    $P339 = root_new ['parrot';'Hash']
  vivify_218:
    set $P340, $P339["bareblock"]
    unless_null $P340, vivify_219
    new $P340, "Undef"
  vivify_219:
    unless $P340, if_338_end
    find_lex $P341, "$ast"
    $P342 = "block_immediate"($P341)
    store_lex "$ast", $P342
  if_338_end:
.annotate 'line', 90
    find_lex $P343, "$past"
    find_lex $P344, "$ast"
    $P345 = $P343."push"($P344)
.annotate 'line', 86
    .return ($P345)
.end


.namespace ["NQP";"Actions"]
.sub "statement"  :subid("30_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_353
    .param pmc param_354
    .param pmc param_355 :optional
    .param int has_param_355 :opt_flag
.annotate 'line', 96
    .const 'Sub' $P363 = "31_1298845576.421" 
    capture_lex $P363
    .lex "self", param_353
    .lex "$/", param_354
    if has_param_355, optparam_220
    new $P356, "Undef"
    set param_355, $P356
  optparam_220:
    .lex "$key", param_355
.annotate 'line', 97
    new $P357, "Undef"
    .lex "$past", $P357
.annotate 'line', 96
    find_lex $P358, "$past"
.annotate 'line', 98
    find_lex $P360, "$/"
    unless_null $P360, vivify_221
    $P360 = root_new ['parrot';'Hash']
  vivify_221:
    set $P361, $P360["EXPR"]
    unless_null $P361, vivify_222
    new $P361, "Undef"
  vivify_222:
    if $P361, if_359
.annotate 'line', 119
    find_lex $P424, "$/"
    unless_null $P424, vivify_223
    $P424 = root_new ['parrot';'Hash']
  vivify_223:
    set $P425, $P424["statement_control"]
    unless_null $P425, vivify_224
    new $P425, "Undef"
  vivify_224:
    if $P425, if_423
.annotate 'line', 120
    new $P429, "Integer"
    assign $P429, 0
    store_lex "$past", $P429
    goto if_423_end
  if_423:
.annotate 'line', 119
    find_lex $P426, "$/"
    unless_null $P426, vivify_225
    $P426 = root_new ['parrot';'Hash']
  vivify_225:
    set $P427, $P426["statement_control"]
    unless_null $P427, vivify_226
    new $P427, "Undef"
  vivify_226:
    $P428 = $P427."ast"()
    store_lex "$past", $P428
  if_423_end:
    goto if_359_end
  if_359:
.annotate 'line', 98
    .const 'Sub' $P363 = "31_1298845576.421" 
    capture_lex $P363
    $P363()
  if_359_end:
.annotate 'line', 121
    find_lex $P430, "$/"
    find_lex $P431, "$past"
    $P432 = $P430."!make"($P431)
.annotate 'line', 96
    .return ($P432)
.end


.namespace ["NQP";"Actions"]
.sub "_block362"  :anon :subid("31_1298845576.421") :outer("30_1298845576.421")
.annotate 'line', 99
    new $P364, "Undef"
    .lex "$mc", $P364
.annotate 'line', 100
    new $P365, "Undef"
    .lex "$ml", $P365
.annotate 'line', 99
    find_lex $P366, "$/"
    unless_null $P366, vivify_227
    $P366 = root_new ['parrot';'Hash']
  vivify_227:
    set $P367, $P366["statement_mod_cond"]
    unless_null $P367, vivify_228
    $P367 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    set $P368, $P367[0]
    unless_null $P368, vivify_229
    new $P368, "Undef"
  vivify_229:
    store_lex "$mc", $P368
.annotate 'line', 100
    find_lex $P369, "$/"
    unless_null $P369, vivify_230
    $P369 = root_new ['parrot';'Hash']
  vivify_230:
    set $P370, $P369["statement_mod_loop"]
    unless_null $P370, vivify_231
    $P370 = root_new ['parrot';'ResizablePMCArray']
  vivify_231:
    set $P371, $P370[0]
    unless_null $P371, vivify_232
    new $P371, "Undef"
  vivify_232:
    store_lex "$ml", $P371
.annotate 'line', 101
    find_lex $P372, "$/"
    unless_null $P372, vivify_233
    $P372 = root_new ['parrot';'Hash']
  vivify_233:
    set $P373, $P372["EXPR"]
    unless_null $P373, vivify_234
    new $P373, "Undef"
  vivify_234:
    $P374 = $P373."ast"()
    store_lex "$past", $P374
.annotate 'line', 102
    find_lex $P376, "$mc"
    unless $P376, if_375_end
.annotate 'line', 103
    get_hll_global $P377, ["PAST"], "Op"
    find_lex $P378, "$mc"
    unless_null $P378, vivify_235
    $P378 = root_new ['parrot';'Hash']
  vivify_235:
    set $P379, $P378["cond"]
    unless_null $P379, vivify_236
    new $P379, "Undef"
  vivify_236:
    $P380 = $P379."ast"()
    find_lex $P381, "$past"
    find_lex $P382, "$mc"
    unless_null $P382, vivify_237
    $P382 = root_new ['parrot';'Hash']
  vivify_237:
    set $P383, $P382["sym"]
    unless_null $P383, vivify_238
    new $P383, "Undef"
  vivify_238:
    set $S384, $P383
    find_lex $P385, "$/"
    $P386 = $P377."new"($P380, $P381, $S384 :named("pasttype"), $P385 :named("node"))
    store_lex "$past", $P386
  if_375_end:
.annotate 'line', 105
    find_lex $P389, "$ml"
    if $P389, if_388
    set $P387, $P389
    goto if_388_end
  if_388:
.annotate 'line', 106
    find_lex $P392, "$ml"
    unless_null $P392, vivify_239
    $P392 = root_new ['parrot';'Hash']
  vivify_239:
    set $P393, $P392["sym"]
    unless_null $P393, vivify_240
    new $P393, "Undef"
  vivify_240:
    set $S394, $P393
    iseq $I395, $S394, "for"
    if $I395, if_391
.annotate 'line', 115
    get_hll_global $P413, ["PAST"], "Op"
    find_lex $P414, "$ml"
    unless_null $P414, vivify_241
    $P414 = root_new ['parrot';'Hash']
  vivify_241:
    set $P415, $P414["cond"]
    unless_null $P415, vivify_242
    new $P415, "Undef"
  vivify_242:
    $P416 = $P415."ast"()
    find_lex $P417, "$past"
    find_lex $P418, "$ml"
    unless_null $P418, vivify_243
    $P418 = root_new ['parrot';'Hash']
  vivify_243:
    set $P419, $P418["sym"]
    unless_null $P419, vivify_244
    new $P419, "Undef"
  vivify_244:
    set $S420, $P419
    find_lex $P421, "$/"
    $P422 = $P413."new"($P416, $P417, $S420 :named("pasttype"), $P421 :named("node"))
    store_lex "$past", $P422
.annotate 'line', 114
    set $P390, $P422
.annotate 'line', 106
    goto if_391_end
  if_391:
.annotate 'line', 107
    get_hll_global $P396, ["PAST"], "Block"
.annotate 'line', 108
    get_hll_global $P397, ["PAST"], "Var"
    $P398 = $P397."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P399, "$past"
    $P400 = $P396."new"($P398, $P399, "immediate" :named("blocktype"))
.annotate 'line', 107
    store_lex "$past", $P400
.annotate 'line', 110
    find_lex $P401, "$past"
    $P401."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 111
    find_lex $P402, "$past"
    $P402."arity"(1)
.annotate 'line', 112
    get_hll_global $P403, ["PAST"], "Op"
    find_lex $P404, "$ml"
    unless_null $P404, vivify_245
    $P404 = root_new ['parrot';'Hash']
  vivify_245:
    set $P405, $P404["cond"]
    unless_null $P405, vivify_246
    new $P405, "Undef"
  vivify_246:
    $P406 = $P405."ast"()
    find_lex $P407, "$past"
    find_lex $P408, "$ml"
    unless_null $P408, vivify_247
    $P408 = root_new ['parrot';'Hash']
  vivify_247:
    set $P409, $P408["sym"]
    unless_null $P409, vivify_248
    new $P409, "Undef"
  vivify_248:
    set $S410, $P409
    find_lex $P411, "$/"
    $P412 = $P403."new"($P406, $P407, $S410 :named("pasttype"), $P411 :named("node"))
    store_lex "$past", $P412
.annotate 'line', 106
    set $P390, $P412
  if_391_end:
.annotate 'line', 105
    set $P387, $P390
  if_388_end:
.annotate 'line', 98
    .return ($P387)
.end


.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("32_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_434
    .param pmc param_435
.annotate 'line', 124
    .lex "self", param_434
    .lex "$/", param_435
.annotate 'line', 125
    find_lex $P436, "$/"
    get_hll_global $P437, ["PAST"], "Op"
    find_lex $P438, "$/"
    unless_null $P438, vivify_249
    $P438 = root_new ['parrot';'Hash']
  vivify_249:
    set $P439, $P438["EXPR"]
    unless_null $P439, vivify_250
    new $P439, "Undef"
  vivify_250:
    $P440 = $P439."ast"()
    find_lex $P441, "$/"
    unless_null $P441, vivify_251
    $P441 = root_new ['parrot';'Hash']
  vivify_251:
    set $P442, $P441["pblock"]
    unless_null $P442, vivify_252
    new $P442, "Undef"
  vivify_252:
    $P443 = $P442."ast"()
    find_lex $P444, "$/"
    $P445 = $P437."new"($P440, $P443, "if" :named("pasttype"), $P444 :named("node"))
    $P446 = $P436."!make"($P445)
.annotate 'line', 124
    .return ($P446)
.end


.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("33_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_448
    .param pmc param_449
.annotate 'line', 128
    .lex "self", param_448
    .lex "$/", param_449
.annotate 'line', 129
    find_lex $P450, "$/"
    find_lex $P451, "$/"
    unless_null $P451, vivify_253
    $P451 = root_new ['parrot';'Hash']
  vivify_253:
    set $P452, $P451["blockoid"]
    unless_null $P452, vivify_254
    new $P452, "Undef"
  vivify_254:
    $P453 = $P452."ast"()
    $P454 = $P450."!make"($P453)
.annotate 'line', 128
    .return ($P454)
.end


.namespace ["NQP";"Actions"]
.sub "block"  :subid("34_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_456
    .param pmc param_457
.annotate 'line', 132
    .lex "self", param_456
    .lex "$/", param_457
.annotate 'line', 133
    find_lex $P458, "$/"
    find_lex $P459, "$/"
    unless_null $P459, vivify_255
    $P459 = root_new ['parrot';'Hash']
  vivify_255:
    set $P460, $P459["blockoid"]
    unless_null $P460, vivify_256
    new $P460, "Undef"
  vivify_256:
    $P461 = $P460."ast"()
    $P462 = $P458."!make"($P461)
.annotate 'line', 132
    .return ($P462)
.end


.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("35_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_464
    .param pmc param_465
.annotate 'line', 136
    .const 'Sub' $P474 = "36_1298845576.421" 
    capture_lex $P474
    .lex "self", param_464
    .lex "$/", param_465
.annotate 'line', 137
    new $P466, "Undef"
    .lex "$BLOCK", $P466
    get_global $P467, "@BLOCK"
    $P468 = $P467."shift"()
    store_lex "$BLOCK", $P468
.annotate 'line', 138
    find_lex $P471, "$/"
    unless_null $P471, vivify_257
    $P471 = root_new ['parrot';'Hash']
  vivify_257:
    set $P472, $P471["statementlist"]
    unless_null $P472, vivify_258
    new $P472, "Undef"
  vivify_258:
    if $P472, if_470
.annotate 'line', 146
    find_dynamic_lex $P489, "$*HAS_YOU_ARE_HERE"
    unless_null $P489, vivify_259
    get_hll_global $P489, "$HAS_YOU_ARE_HERE"
    unless_null $P489, vivify_260
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_260:
  vivify_259:
    unless $P489, if_488_end
.annotate 'line', 147
    find_lex $P490, "$/"
    $P491 = $P490."CURSOR"()
    $P491."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_488_end:
.annotate 'line', 149
    new $P492, "Integer"
    assign $P492, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P492
.annotate 'line', 150
    find_lex $P493, "$/"
    find_lex $P494, "$/"
    unless_null $P494, vivify_261
    $P494 = root_new ['parrot';'Hash']
  vivify_261:
    set $P495, $P494["you_are_here"]
    unless_null $P495, vivify_262
    new $P495, "Undef"
  vivify_262:
    $P496 = $P495."ast"()
    $P497 = $P493."!make"($P496)
.annotate 'line', 145
    set $P469, $P497
.annotate 'line', 138
    goto if_470_end
  if_470:
    .const 'Sub' $P474 = "36_1298845576.421" 
    capture_lex $P474
    $P487 = $P474()
    set $P469, $P487
  if_470_end:
.annotate 'line', 136
    .return ($P469)
.end


.namespace ["NQP";"Actions"]
.sub "_block473"  :anon :subid("36_1298845576.421") :outer("35_1298845576.421")
.annotate 'line', 139
    new $P475, "Undef"
    .lex "$past", $P475
    find_lex $P476, "$/"
    unless_null $P476, vivify_263
    $P476 = root_new ['parrot';'Hash']
  vivify_263:
    set $P477, $P476["statementlist"]
    unless_null $P477, vivify_264
    new $P477, "Undef"
  vivify_264:
    $P478 = $P477."ast"()
    store_lex "$past", $P478
.annotate 'line', 140
    find_lex $P479, "$BLOCK"
    find_lex $P480, "$past"
    $P479."push"($P480)
.annotate 'line', 141
    find_lex $P481, "$BLOCK"
    find_lex $P482, "$/"
    $P481."node"($P482)
.annotate 'line', 142
    find_lex $P483, "$BLOCK"
    $P483."closure"(1)
.annotate 'line', 143
    find_dynamic_lex $P484, "$/"
    find_lex $P485, "$BLOCK"
    $P486 = $P484."!make"($P485)
.annotate 'line', 138
    .return ($P486)
.end


.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("37_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_499
    .param pmc param_500
.annotate 'line', 154
    .lex "self", param_499
    .lex "$/", param_500
.annotate 'line', 155
    get_global $P501, "@BLOCK"
    unless_null $P501, vivify_265
    $P501 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P501
  vivify_265:
.annotate 'line', 154
    get_global $P502, "@BLOCK"
.annotate 'line', 156
    get_global $P503, "@BLOCK"
    get_hll_global $P504, ["PAST"], "Block"
    get_hll_global $P505, ["PAST"], "Stmts"
    $P506 = $P505."new"()
    $P507 = $P504."new"($P506)
    $P508 = $P503."unshift"($P507)
.annotate 'line', 154
    .return ($P508)
.end


.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("38_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_510
    .param pmc param_511
.annotate 'line', 159
    .lex "self", param_510
    .lex "$/", param_511
.annotate 'line', 160
    get_global $P512, "@BLOCK"
    unless_null $P512, vivify_266
    $P512 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P512
  vivify_266:
.annotate 'line', 159
    get_global $P513, "@BLOCK"
.annotate 'line', 161
    find_lex $P514, "self"
    get_global $P515, "@BLOCK"
    unless_null $P515, vivify_267
    $P515 = root_new ['parrot';'ResizablePMCArray']
  vivify_267:
    set $P516, $P515[0]
    unless_null $P516, vivify_268
    new $P516, "Undef"
  vivify_268:
    $P517 = $P514."SET_BLOCK_OUTER_CTX"($P516)
.annotate 'line', 159
    .return ($P517)
.end


.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("39_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_519
    .param pmc param_520
.annotate 'line', 164
    .lex "self", param_519
    .lex "$/", param_520
.annotate 'line', 165
    find_lex $P521, "$/"
    find_lex $P522, "self"
    $P523 = $P522."CTXSAVE"()
    $P524 = $P521."!make"($P523)
.annotate 'line', 164
    .return ($P524)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("40_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_526
    .param pmc param_527
.annotate 'line', 170
    .const 'Sub' $P555 = "41_1298845576.421" 
    capture_lex $P555
    .lex "self", param_526
    .lex "$/", param_527
.annotate 'line', 171
    new $P528, "Undef"
    .lex "$count", $P528
.annotate 'line', 172
    new $P529, "Undef"
    .lex "$past", $P529
.annotate 'line', 171
    find_lex $P530, "$/"
    unless_null $P530, vivify_269
    $P530 = root_new ['parrot';'Hash']
  vivify_269:
    set $P531, $P530["xblock"]
    unless_null $P531, vivify_270
    new $P531, "Undef"
  vivify_270:
    set $N532, $P531
    new $P533, 'Float'
    set $P533, $N532
    sub $P534, $P533, 1
    store_lex "$count", $P534
.annotate 'line', 172
    find_lex $P535, "$count"
    set $I536, $P535
    find_lex $P537, "$/"
    unless_null $P537, vivify_271
    $P537 = root_new ['parrot';'Hash']
  vivify_271:
    set $P538, $P537["xblock"]
    unless_null $P538, vivify_272
    $P538 = root_new ['parrot';'ResizablePMCArray']
  vivify_272:
    set $P539, $P538[$I536]
    unless_null $P539, vivify_273
    new $P539, "Undef"
  vivify_273:
    $P540 = $P539."ast"()
    $P541 = "xblock_immediate"($P540)
    store_lex "$past", $P541
.annotate 'line', 173
    find_lex $P543, "$/"
    unless_null $P543, vivify_274
    $P543 = root_new ['parrot';'Hash']
  vivify_274:
    set $P544, $P543["else"]
    unless_null $P544, vivify_275
    new $P544, "Undef"
  vivify_275:
    unless $P544, if_542_end
.annotate 'line', 174
    find_lex $P545, "$past"
    find_lex $P546, "$/"
    unless_null $P546, vivify_276
    $P546 = root_new ['parrot';'Hash']
  vivify_276:
    set $P547, $P546["else"]
    unless_null $P547, vivify_277
    $P547 = root_new ['parrot';'ResizablePMCArray']
  vivify_277:
    set $P548, $P547[0]
    unless_null $P548, vivify_278
    new $P548, "Undef"
  vivify_278:
    $P549 = $P548."ast"()
    $P550 = "block_immediate"($P549)
    $P545."push"($P550)
  if_542_end:
.annotate 'line', 177
    new $P571, 'ExceptionHandler'
    set_label $P571, loop570_handler
    $P571."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P571
  loop570_test:
    find_lex $P551, "$count"
    set $N552, $P551
    isgt $I553, $N552, 0.0
    unless $I553, loop570_done
  loop570_redo:
    .const 'Sub' $P555 = "41_1298845576.421" 
    capture_lex $P555
    $P555()
  loop570_next:
    goto loop570_test
  loop570_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P572, exception, 'type'
    eq $P572, .CONTROL_LOOP_NEXT, loop570_next
    eq $P572, .CONTROL_LOOP_REDO, loop570_redo
  loop570_done:
    pop_eh 
.annotate 'line', 183
    find_lex $P573, "$/"
    find_lex $P574, "$past"
    $P575 = $P573."!make"($P574)
.annotate 'line', 170
    .return ($P575)
.end


.namespace ["NQP";"Actions"]
.sub "_block554"  :anon :subid("41_1298845576.421") :outer("40_1298845576.421")
.annotate 'line', 179
    new $P556, "Undef"
    .lex "$else", $P556
.annotate 'line', 177
    find_lex $P557, "$count"
    clone $P558, $P557
    dec $P557
.annotate 'line', 179
    find_lex $P559, "$past"
    store_lex "$else", $P559
.annotate 'line', 180
    find_lex $P560, "$count"
    set $I561, $P560
    find_lex $P562, "$/"
    unless_null $P562, vivify_279
    $P562 = root_new ['parrot';'Hash']
  vivify_279:
    set $P563, $P562["xblock"]
    unless_null $P563, vivify_280
    $P563 = root_new ['parrot';'ResizablePMCArray']
  vivify_280:
    set $P564, $P563[$I561]
    unless_null $P564, vivify_281
    new $P564, "Undef"
  vivify_281:
    $P565 = $P564."ast"()
    $P566 = "xblock_immediate"($P565)
    store_lex "$past", $P566
.annotate 'line', 181
    find_lex $P567, "$past"
    find_lex $P568, "$else"
    $P569 = $P567."push"($P568)
.annotate 'line', 177
    .return ($P569)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("42_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_577
    .param pmc param_578
.annotate 'line', 186
    .lex "self", param_577
    .lex "$/", param_578
.annotate 'line', 187
    new $P579, "Undef"
    .lex "$past", $P579
    find_lex $P580, "$/"
    unless_null $P580, vivify_282
    $P580 = root_new ['parrot';'Hash']
  vivify_282:
    set $P581, $P580["xblock"]
    unless_null $P581, vivify_283
    new $P581, "Undef"
  vivify_283:
    $P582 = $P581."ast"()
    $P583 = "xblock_immediate"($P582)
    store_lex "$past", $P583
.annotate 'line', 188
    find_lex $P584, "$past"
    $P584."pasttype"("unless")
.annotate 'line', 189
    find_lex $P585, "$/"
    find_lex $P586, "$past"
    $P587 = $P585."!make"($P586)
.annotate 'line', 186
    .return ($P587)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("43_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_589
    .param pmc param_590
.annotate 'line', 192
    .lex "self", param_589
    .lex "$/", param_590
.annotate 'line', 193
    new $P591, "Undef"
    .lex "$past", $P591
    find_lex $P592, "$/"
    unless_null $P592, vivify_284
    $P592 = root_new ['parrot';'Hash']
  vivify_284:
    set $P593, $P592["xblock"]
    unless_null $P593, vivify_285
    new $P593, "Undef"
  vivify_285:
    $P594 = $P593."ast"()
    $P595 = "xblock_immediate"($P594)
    store_lex "$past", $P595
.annotate 'line', 194
    find_lex $P596, "$past"
    find_lex $P597, "$/"
    unless_null $P597, vivify_286
    $P597 = root_new ['parrot';'Hash']
  vivify_286:
    set $P598, $P597["sym"]
    unless_null $P598, vivify_287
    new $P598, "Undef"
  vivify_287:
    set $S599, $P598
    $P596."pasttype"($S599)
.annotate 'line', 195
    find_lex $P600, "$/"
    find_lex $P601, "$past"
    $P602 = $P600."!make"($P601)
.annotate 'line', 192
    .return ($P602)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("44_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_604
    .param pmc param_605
.annotate 'line', 198
    .lex "self", param_604
    .lex "$/", param_605
.annotate 'line', 199
    new $P606, "Undef"
    .lex "$pasttype", $P606
.annotate 'line', 200
    new $P607, "Undef"
    .lex "$past", $P607
.annotate 'line', 199
    new $P608, "String"
    assign $P608, "repeat_"
    find_lex $P609, "$/"
    unless_null $P609, vivify_288
    $P609 = root_new ['parrot';'Hash']
  vivify_288:
    set $P610, $P609["wu"]
    unless_null $P610, vivify_289
    new $P610, "Undef"
  vivify_289:
    set $S611, $P610
    concat $P612, $P608, $S611
    store_lex "$pasttype", $P612
    find_lex $P613, "$past"
.annotate 'line', 201
    find_lex $P615, "$/"
    unless_null $P615, vivify_290
    $P615 = root_new ['parrot';'Hash']
  vivify_290:
    set $P616, $P615["xblock"]
    unless_null $P616, vivify_291
    new $P616, "Undef"
  vivify_291:
    if $P616, if_614
.annotate 'line', 206
    get_hll_global $P623, ["PAST"], "Op"
    find_lex $P624, "$/"
    unless_null $P624, vivify_292
    $P624 = root_new ['parrot';'Hash']
  vivify_292:
    set $P625, $P624["EXPR"]
    unless_null $P625, vivify_293
    new $P625, "Undef"
  vivify_293:
    $P626 = $P625."ast"()
    find_lex $P627, "$/"
    unless_null $P627, vivify_294
    $P627 = root_new ['parrot';'Hash']
  vivify_294:
    set $P628, $P627["pblock"]
    unless_null $P628, vivify_295
    new $P628, "Undef"
  vivify_295:
    $P629 = $P628."ast"()
    $P630 = "block_immediate"($P629)
    find_lex $P631, "$pasttype"
    find_lex $P632, "$/"
    $P633 = $P623."new"($P626, $P630, $P631 :named("pasttype"), $P632 :named("node"))
    store_lex "$past", $P633
.annotate 'line', 205
    goto if_614_end
  if_614:
.annotate 'line', 202
    find_lex $P617, "$/"
    unless_null $P617, vivify_296
    $P617 = root_new ['parrot';'Hash']
  vivify_296:
    set $P618, $P617["xblock"]
    unless_null $P618, vivify_297
    new $P618, "Undef"
  vivify_297:
    $P619 = $P618."ast"()
    $P620 = "xblock_immediate"($P619)
    store_lex "$past", $P620
.annotate 'line', 203
    find_lex $P621, "$past"
    find_lex $P622, "$pasttype"
    $P621."pasttype"($P622)
  if_614_end:
.annotate 'line', 209
    find_lex $P634, "$/"
    find_lex $P635, "$past"
    $P636 = $P634."!make"($P635)
.annotate 'line', 198
    .return ($P636)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("45_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_638
    .param pmc param_639
.annotate 'line', 212
    .lex "self", param_638
    .lex "$/", param_639
.annotate 'line', 213
    new $P640, "Undef"
    .lex "$past", $P640
.annotate 'line', 215
    new $P641, "Undef"
    .lex "$block", $P641
.annotate 'line', 213
    find_lex $P642, "$/"
    unless_null $P642, vivify_298
    $P642 = root_new ['parrot';'Hash']
  vivify_298:
    set $P643, $P642["xblock"]
    unless_null $P643, vivify_299
    new $P643, "Undef"
  vivify_299:
    $P644 = $P643."ast"()
    store_lex "$past", $P644
.annotate 'line', 214
    find_lex $P645, "$past"
    $P645."pasttype"("for")
.annotate 'line', 215
    find_lex $P646, "$past"
    unless_null $P646, vivify_300
    $P646 = root_new ['parrot';'ResizablePMCArray']
  vivify_300:
    set $P647, $P646[1]
    unless_null $P647, vivify_301
    new $P647, "Undef"
  vivify_301:
    store_lex "$block", $P647
.annotate 'line', 216
    find_lex $P649, "$block"
    $P650 = $P649."arity"()
    if $P650, unless_648_end
.annotate 'line', 217
    find_lex $P651, "$block"
    unless_null $P651, vivify_302
    $P651 = root_new ['parrot';'ResizablePMCArray']
  vivify_302:
    set $P652, $P651[0]
    unless_null $P652, vivify_303
    new $P652, "Undef"
  vivify_303:
    get_hll_global $P653, ["PAST"], "Var"
    $P654 = $P653."new"("$_" :named("name"), "parameter" :named("scope"))
    $P652."push"($P654)
.annotate 'line', 218
    find_lex $P655, "$block"
    $P655."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 219
    find_lex $P656, "$block"
    $P656."arity"(1)
  unless_648_end:
.annotate 'line', 221
    find_lex $P657, "$block"
    $P657."blocktype"("immediate")
.annotate 'line', 222
    find_lex $P658, "$/"
    find_lex $P659, "$past"
    $P660 = $P658."!make"($P659)
.annotate 'line', 212
    .return ($P660)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("46_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_662
    .param pmc param_663
.annotate 'line', 225
    .lex "self", param_662
    .lex "$/", param_663
.annotate 'line', 226
    new $P664, "Undef"
    .lex "$block", $P664
    find_lex $P665, "$/"
    unless_null $P665, vivify_304
    $P665 = root_new ['parrot';'Hash']
  vivify_304:
    set $P666, $P665["block"]
    unless_null $P666, vivify_305
    new $P666, "Undef"
  vivify_305:
    $P667 = $P666."ast"()
    store_lex "$block", $P667
.annotate 'line', 227
    find_lex $P668, "$/"
    find_lex $P669, "$block"
    "push_block_handler"($P668, $P669)
.annotate 'line', 228
    get_global $P670, "@BLOCK"
    unless_null $P670, vivify_306
    $P670 = root_new ['parrot';'ResizablePMCArray']
  vivify_306:
    set $P671, $P670[0]
    unless_null $P671, vivify_307
    new $P671, "Undef"
  vivify_307:
    $P672 = $P671."handlers"()
    set $P673, $P672[0]
    unless_null $P673, vivify_308
    new $P673, "Undef"
  vivify_308:
    $P673."handle_types_except"("CONTROL")
.annotate 'line', 229
    find_lex $P674, "$/"
    get_hll_global $P675, ["PAST"], "Stmts"
    find_lex $P676, "$/"
    $P677 = $P675."new"($P676 :named("node"))
    $P678 = $P674."!make"($P677)
.annotate 'line', 225
    .return ($P678)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("47_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_680
    .param pmc param_681
.annotate 'line', 232
    .lex "self", param_680
    .lex "$/", param_681
.annotate 'line', 233
    new $P682, "Undef"
    .lex "$block", $P682
    find_lex $P683, "$/"
    unless_null $P683, vivify_309
    $P683 = root_new ['parrot';'Hash']
  vivify_309:
    set $P684, $P683["block"]
    unless_null $P684, vivify_310
    new $P684, "Undef"
  vivify_310:
    $P685 = $P684."ast"()
    store_lex "$block", $P685
.annotate 'line', 234
    find_lex $P686, "$/"
    find_lex $P687, "$block"
    "push_block_handler"($P686, $P687)
.annotate 'line', 235
    get_global $P688, "@BLOCK"
    unless_null $P688, vivify_311
    $P688 = root_new ['parrot';'ResizablePMCArray']
  vivify_311:
    set $P689, $P688[0]
    unless_null $P689, vivify_312
    new $P689, "Undef"
  vivify_312:
    $P690 = $P689."handlers"()
    set $P691, $P690[0]
    unless_null $P691, vivify_313
    new $P691, "Undef"
  vivify_313:
    $P691."handle_types"("CONTROL")
.annotate 'line', 236
    find_lex $P692, "$/"
    get_hll_global $P693, ["PAST"], "Stmts"
    find_lex $P694, "$/"
    $P695 = $P693."new"($P694 :named("node"))
    $P696 = $P692."!make"($P695)
.annotate 'line', 232
    .return ($P696)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("48_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_699
    .param pmc param_700
.annotate 'line', 276
    .lex "self", param_699
    .lex "$/", param_700
.annotate 'line', 277
    new $P701, "Undef"
    .lex "$init_block", $P701
    get_hll_global $P702, ["PAST"], "Block"
    $P703 = $P702."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P703
.annotate 'line', 278
    find_lex $P704, "$init_block"
    $P705 = $P704."loadinit"()
    find_lex $P706, "$/"
    unless_null $P706, vivify_314
    $P706 = root_new ['parrot';'Hash']
  vivify_314:
    set $P707, $P706["blorst"]
    unless_null $P707, vivify_315
    new $P707, "Undef"
  vivify_315:
    $P708 = $P707."ast"()
    $P705."push"($P708)
.annotate 'line', 279
    find_lex $P709, "$/"
    find_lex $P710, "$init_block"
    $P711 = $P709."!make"($P710)
.annotate 'line', 276
    .return ($P711)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("49_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_713
    .param pmc param_714
.annotate 'line', 282
    .lex "self", param_713
    .lex "$/", param_714
.annotate 'line', 283
    new $P715, "Undef"
    .lex "$past", $P715
    find_lex $P716, "$/"
    unless_null $P716, vivify_316
    $P716 = root_new ['parrot';'Hash']
  vivify_316:
    set $P717, $P716["blorst"]
    unless_null $P717, vivify_317
    new $P717, "Undef"
  vivify_317:
    $P718 = $P717."ast"()
    store_lex "$past", $P718
.annotate 'line', 284
    get_hll_global $P720, ["PAST"], "Block"
    find_lex $P721, "$past"
    $P722 = $P720."ACCEPTS"($P721)
    if $P722, unless_719_end
.annotate 'line', 285
    get_hll_global $P723, ["PAST"], "Block"
    find_lex $P724, "$past"
    find_lex $P725, "$/"
    $P726 = $P723."new"($P724, "immediate" :named("blocktype"), $P725 :named("node"))
    store_lex "$past", $P726
  unless_719_end:
.annotate 'line', 287
    find_lex $P728, "$past"
    $P729 = $P728."handlers"()
    if $P729, unless_727_end
.annotate 'line', 288
    find_lex $P730, "$past"
    get_hll_global $P731, ["PAST"], "Control"
.annotate 'line', 290
    get_hll_global $P732, ["PAST"], "Stmts"
.annotate 'line', 291
    get_hll_global $P733, ["PAST"], "Op"
.annotate 'line', 292
    get_hll_global $P734, ["PAST"], "Var"
.annotate 'line', 293
    get_hll_global $P735, ["PAST"], "Var"
    $P736 = $P735."new"("register" :named("scope"), "exception" :named("name"))
    $P737 = $P734."new"($P736, "handled", "keyed" :named("scope"))
.annotate 'line', 292
    $P738 = $P733."new"($P737, 1, "bind" :named("pasttype"))
.annotate 'line', 291
    $P739 = $P732."new"($P738)
.annotate 'line', 290
    $P740 = $P731."new"($P739, "CONTROL" :named("handle_types_except"))
.annotate 'line', 288
    new $P741, "ResizablePMCArray"
    push $P741, $P740
    $P730."handlers"($P741)
  unless_727_end:
.annotate 'line', 302
    find_lex $P742, "$/"
    find_lex $P743, "$past"
    $P744 = $P742."!make"($P743)
.annotate 'line', 282
    .return ($P744)
.end


.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("50_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_746
    .param pmc param_747
.annotate 'line', 305
    .lex "self", param_746
    .lex "$/", param_747
.annotate 'line', 306
    find_lex $P748, "$/"
.annotate 'line', 307
    find_lex $P751, "$/"
    unless_null $P751, vivify_318
    $P751 = root_new ['parrot';'Hash']
  vivify_318:
    set $P752, $P751["block"]
    unless_null $P752, vivify_319
    new $P752, "Undef"
  vivify_319:
    if $P752, if_750
.annotate 'line', 308
    find_lex $P757, "$/"
    unless_null $P757, vivify_320
    $P757 = root_new ['parrot';'Hash']
  vivify_320:
    set $P758, $P757["statement"]
    unless_null $P758, vivify_321
    new $P758, "Undef"
  vivify_321:
    $P759 = $P758."ast"()
    set $P749, $P759
.annotate 'line', 307
    goto if_750_end
  if_750:
    find_lex $P753, "$/"
    unless_null $P753, vivify_322
    $P753 = root_new ['parrot';'Hash']
  vivify_322:
    set $P754, $P753["block"]
    unless_null $P754, vivify_323
    new $P754, "Undef"
  vivify_323:
    $P755 = $P754."ast"()
    $P756 = "block_immediate"($P755)
    set $P749, $P756
  if_750_end:
    $P760 = $P748."!make"($P749)
.annotate 'line', 305
    .return ($P760)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("51_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_762
    .param pmc param_763
.annotate 'line', 313
    .lex "self", param_762
    .lex "$/", param_763
    find_lex $P764, "$/"
    find_lex $P765, "$/"
    unless_null $P765, vivify_324
    $P765 = root_new ['parrot';'Hash']
  vivify_324:
    set $P766, $P765["cond"]
    unless_null $P766, vivify_325
    new $P766, "Undef"
  vivify_325:
    $P767 = $P766."ast"()
    $P768 = $P764."!make"($P767)
    .return ($P768)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("52_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_770
    .param pmc param_771
.annotate 'line', 314
    .lex "self", param_770
    .lex "$/", param_771
    find_lex $P772, "$/"
    find_lex $P773, "$/"
    unless_null $P773, vivify_326
    $P773 = root_new ['parrot';'Hash']
  vivify_326:
    set $P774, $P773["cond"]
    unless_null $P774, vivify_327
    new $P774, "Undef"
  vivify_327:
    $P775 = $P774."ast"()
    $P776 = $P772."!make"($P775)
    .return ($P776)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("53_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_778
    .param pmc param_779
.annotate 'line', 316
    .lex "self", param_778
    .lex "$/", param_779
    find_lex $P780, "$/"
    find_lex $P781, "$/"
    unless_null $P781, vivify_328
    $P781 = root_new ['parrot';'Hash']
  vivify_328:
    set $P782, $P781["cond"]
    unless_null $P782, vivify_329
    new $P782, "Undef"
  vivify_329:
    $P783 = $P782."ast"()
    $P784 = $P780."!make"($P783)
    .return ($P784)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("54_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_786
    .param pmc param_787
.annotate 'line', 317
    .lex "self", param_786
    .lex "$/", param_787
    find_lex $P788, "$/"
    find_lex $P789, "$/"
    unless_null $P789, vivify_330
    $P789 = root_new ['parrot';'Hash']
  vivify_330:
    set $P790, $P789["cond"]
    unless_null $P790, vivify_331
    new $P790, "Undef"
  vivify_331:
    $P791 = $P790."ast"()
    $P792 = $P788."!make"($P791)
    .return ($P792)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("55_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_794
    .param pmc param_795
.annotate 'line', 321
    .lex "self", param_794
    .lex "$/", param_795
    find_lex $P796, "$/"
    find_lex $P797, "$/"
    unless_null $P797, vivify_332
    $P797 = root_new ['parrot';'Hash']
  vivify_332:
    set $P798, $P797["fatarrow"]
    unless_null $P798, vivify_333
    new $P798, "Undef"
  vivify_333:
    $P799 = $P798."ast"()
    $P800 = $P796."!make"($P799)
    .return ($P800)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("56_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_802
    .param pmc param_803
.annotate 'line', 322
    .lex "self", param_802
    .lex "$/", param_803
    find_lex $P804, "$/"
    find_lex $P805, "$/"
    unless_null $P805, vivify_334
    $P805 = root_new ['parrot';'Hash']
  vivify_334:
    set $P806, $P805["colonpair"]
    unless_null $P806, vivify_335
    new $P806, "Undef"
  vivify_335:
    $P807 = $P806."ast"()
    $P808 = $P804."!make"($P807)
    .return ($P808)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("57_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_810
    .param pmc param_811
.annotate 'line', 323
    .lex "self", param_810
    .lex "$/", param_811
    find_lex $P812, "$/"
    find_lex $P813, "$/"
    unless_null $P813, vivify_336
    $P813 = root_new ['parrot';'Hash']
  vivify_336:
    set $P814, $P813["variable"]
    unless_null $P814, vivify_337
    new $P814, "Undef"
  vivify_337:
    $P815 = $P814."ast"()
    $P816 = $P812."!make"($P815)
    .return ($P816)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("58_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_818
    .param pmc param_819
.annotate 'line', 324
    .lex "self", param_818
    .lex "$/", param_819
    find_lex $P820, "$/"
    find_lex $P821, "$/"
    unless_null $P821, vivify_338
    $P821 = root_new ['parrot';'Hash']
  vivify_338:
    set $P822, $P821["package_declarator"]
    unless_null $P822, vivify_339
    new $P822, "Undef"
  vivify_339:
    $P823 = $P822."ast"()
    $P824 = $P820."!make"($P823)
    .return ($P824)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("59_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_826
    .param pmc param_827
.annotate 'line', 325
    .lex "self", param_826
    .lex "$/", param_827
    find_lex $P828, "$/"
    find_lex $P829, "$/"
    unless_null $P829, vivify_340
    $P829 = root_new ['parrot';'Hash']
  vivify_340:
    set $P830, $P829["scope_declarator"]
    unless_null $P830, vivify_341
    new $P830, "Undef"
  vivify_341:
    $P831 = $P830."ast"()
    $P832 = $P828."!make"($P831)
    .return ($P832)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("60_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_834
    .param pmc param_835
.annotate 'line', 326
    .lex "self", param_834
    .lex "$/", param_835
    find_lex $P836, "$/"
    find_lex $P837, "$/"
    unless_null $P837, vivify_342
    $P837 = root_new ['parrot';'Hash']
  vivify_342:
    set $P838, $P837["routine_declarator"]
    unless_null $P838, vivify_343
    new $P838, "Undef"
  vivify_343:
    $P839 = $P838."ast"()
    $P840 = $P836."!make"($P839)
    .return ($P840)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("61_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_842
    .param pmc param_843
.annotate 'line', 327
    .lex "self", param_842
    .lex "$/", param_843
    find_lex $P844, "$/"
    find_lex $P845, "$/"
    unless_null $P845, vivify_344
    $P845 = root_new ['parrot';'Hash']
  vivify_344:
    set $P846, $P845["regex_declarator"]
    unless_null $P846, vivify_345
    new $P846, "Undef"
  vivify_345:
    $P847 = $P846."ast"()
    $P848 = $P844."!make"($P847)
    .return ($P848)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("62_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_850
    .param pmc param_851
.annotate 'line', 328
    .lex "self", param_850
    .lex "$/", param_851
    find_lex $P852, "$/"
    find_lex $P853, "$/"
    unless_null $P853, vivify_346
    $P853 = root_new ['parrot';'Hash']
  vivify_346:
    set $P854, $P853["statement_prefix"]
    unless_null $P854, vivify_347
    new $P854, "Undef"
  vivify_347:
    $P855 = $P854."ast"()
    $P856 = $P852."!make"($P855)
    .return ($P856)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("63_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_858
    .param pmc param_859
.annotate 'line', 329
    .lex "self", param_858
    .lex "$/", param_859
    find_lex $P860, "$/"
    find_lex $P861, "$/"
    unless_null $P861, vivify_348
    $P861 = root_new ['parrot';'Hash']
  vivify_348:
    set $P862, $P861["pblock"]
    unless_null $P862, vivify_349
    new $P862, "Undef"
  vivify_349:
    $P863 = $P862."ast"()
    $P864 = $P860."!make"($P863)
    .return ($P864)
.end


.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("64_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_866
    .param pmc param_867
.annotate 'line', 331
    .lex "self", param_866
    .lex "$/", param_867
.annotate 'line', 332
    new $P868, "Undef"
    .lex "$past", $P868
    find_lex $P869, "$/"
    unless_null $P869, vivify_350
    $P869 = root_new ['parrot';'Hash']
  vivify_350:
    set $P870, $P869["val"]
    unless_null $P870, vivify_351
    new $P870, "Undef"
  vivify_351:
    $P871 = $P870."ast"()
    store_lex "$past", $P871
.annotate 'line', 333
    find_lex $P872, "$past"
    find_lex $P873, "$/"
    unless_null $P873, vivify_352
    $P873 = root_new ['parrot';'Hash']
  vivify_352:
    set $P874, $P873["key"]
    unless_null $P874, vivify_353
    new $P874, "Undef"
  vivify_353:
    $P875 = $P874."Str"()
    $P872."named"($P875)
.annotate 'line', 334
    find_lex $P876, "$/"
    find_lex $P877, "$past"
    $P878 = $P876."!make"($P877)
.annotate 'line', 331
    .return ($P878)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("65_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_880
    .param pmc param_881
.annotate 'line', 337
    .lex "self", param_880
    .lex "$/", param_881
.annotate 'line', 338
    new $P882, "Undef"
    .lex "$past", $P882
.annotate 'line', 339
    find_lex $P885, "$/"
    unless_null $P885, vivify_354
    $P885 = root_new ['parrot';'Hash']
  vivify_354:
    set $P886, $P885["circumfix"]
    unless_null $P886, vivify_355
    new $P886, "Undef"
  vivify_355:
    if $P886, if_884
.annotate 'line', 340
    get_hll_global $P891, ["PAST"], "Val"
    find_lex $P892, "$/"
    unless_null $P892, vivify_356
    $P892 = root_new ['parrot';'Hash']
  vivify_356:
    set $P893, $P892["not"]
    unless_null $P893, vivify_357
    new $P893, "Undef"
  vivify_357:
    isfalse $I894, $P893
    $P895 = $P891."new"($I894 :named("value"))
    set $P883, $P895
.annotate 'line', 339
    goto if_884_end
  if_884:
    find_lex $P887, "$/"
    unless_null $P887, vivify_358
    $P887 = root_new ['parrot';'Hash']
  vivify_358:
    set $P888, $P887["circumfix"]
    unless_null $P888, vivify_359
    $P888 = root_new ['parrot';'ResizablePMCArray']
  vivify_359:
    set $P889, $P888[0]
    unless_null $P889, vivify_360
    new $P889, "Undef"
  vivify_360:
    $P890 = $P889."ast"()
    set $P883, $P890
  if_884_end:
    store_lex "$past", $P883
.annotate 'line', 341
    find_lex $P896, "$past"
    find_lex $P897, "$/"
    unless_null $P897, vivify_361
    $P897 = root_new ['parrot';'Hash']
  vivify_361:
    set $P898, $P897["identifier"]
    unless_null $P898, vivify_362
    new $P898, "Undef"
  vivify_362:
    set $S899, $P898
    $P896."named"($S899)
.annotate 'line', 342
    find_lex $P900, "$/"
    find_lex $P901, "$past"
    $P902 = $P900."!make"($P901)
.annotate 'line', 337
    .return ($P902)
.end


.namespace ["NQP";"Actions"]
.sub "variable"  :subid("66_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_904
    .param pmc param_905
.annotate 'line', 345
    .const 'Sub' $P918 = "67_1298845576.421" 
    capture_lex $P918
    .lex "self", param_904
    .lex "$/", param_905
.annotate 'line', 346
    new $P906, "Undef"
    .lex "$past", $P906
.annotate 'line', 345
    find_lex $P907, "$past"
.annotate 'line', 347
    find_lex $P909, "$/"
    unless_null $P909, vivify_363
    $P909 = root_new ['parrot';'Hash']
  vivify_363:
    set $P910, $P909["postcircumfix"]
    unless_null $P910, vivify_364
    new $P910, "Undef"
  vivify_364:
    if $P910, if_908
.annotate 'line', 351
    .const 'Sub' $P918 = "67_1298845576.421" 
    capture_lex $P918
    $P918()
    goto if_908_end
  if_908:
.annotate 'line', 348
    find_lex $P911, "$/"
    unless_null $P911, vivify_381
    $P911 = root_new ['parrot';'Hash']
  vivify_381:
    set $P912, $P911["postcircumfix"]
    unless_null $P912, vivify_382
    new $P912, "Undef"
  vivify_382:
    $P913 = $P912."ast"()
    store_lex "$past", $P913
.annotate 'line', 349
    find_lex $P914, "$past"
    get_hll_global $P915, ["PAST"], "Var"
    $P916 = $P915."new"("$/" :named("name"))
    $P914."unshift"($P916)
  if_908_end:
.annotate 'line', 381
    find_lex $P990, "$/"
    find_lex $P991, "$past"
    $P992 = $P990."!make"($P991)
.annotate 'line', 345
    .return ($P992)
.end


.namespace ["NQP";"Actions"]
.sub "_block917"  :anon :subid("67_1298845576.421") :outer("66_1298845576.421")
.annotate 'line', 352
    $P919 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P919
    get_hll_global $P920, ["NQP"], "Compiler"
    find_lex $P921, "$/"
    set $S922, $P921
    $P923 = $P920."parse_name"($S922)
    store_lex "@name", $P923
.annotate 'line', 353
    get_hll_global $P924, ["PAST"], "Var"
    find_lex $P925, "@name"
    $P926 = $P925."pop"()
    set $S927, $P926
    $P928 = $P924."new"($S927 :named("name"))
    store_lex "$past", $P928
.annotate 'line', 354
    find_lex $P930, "@name"
    unless $P930, if_929_end
.annotate 'line', 355
    find_lex $P932, "@name"
    unless_null $P932, vivify_365
    $P932 = root_new ['parrot';'ResizablePMCArray']
  vivify_365:
    set $P933, $P932[0]
    unless_null $P933, vivify_366
    new $P933, "Undef"
  vivify_366:
    set $S934, $P933
    iseq $I935, $S934, "GLOBAL"
    unless $I935, if_931_end
    find_lex $P936, "@name"
    $P936."shift"()
  if_931_end:
.annotate 'line', 356
    find_lex $P937, "$past"
    find_lex $P938, "@name"
    $P937."namespace"($P938)
.annotate 'line', 357
    find_lex $P939, "$past"
    $P939."scope"("package")
.annotate 'line', 358
    find_lex $P940, "$past"
    find_lex $P941, "$/"
    unless_null $P941, vivify_367
    $P941 = root_new ['parrot';'Hash']
  vivify_367:
    set $P942, $P941["sigil"]
    unless_null $P942, vivify_368
    new $P942, "Undef"
  vivify_368:
    $P943 = "vivitype"($P942)
    $P940."viviself"($P943)
.annotate 'line', 359
    find_lex $P944, "$past"
    $P944."lvalue"(1)
  if_929_end:
.annotate 'line', 361
    find_lex $P947, "$/"
    unless_null $P947, vivify_369
    $P947 = root_new ['parrot';'Hash']
  vivify_369:
    set $P948, $P947["twigil"]
    unless_null $P948, vivify_370
    $P948 = root_new ['parrot';'ResizablePMCArray']
  vivify_370:
    set $P949, $P948[0]
    unless_null $P949, vivify_371
    new $P949, "Undef"
  vivify_371:
    set $S950, $P949
    iseq $I951, $S950, "*"
    if $I951, if_946
.annotate 'line', 374
    find_lex $P973, "$/"
    unless_null $P973, vivify_372
    $P973 = root_new ['parrot';'Hash']
  vivify_372:
    set $P974, $P973["twigil"]
    unless_null $P974, vivify_373
    $P974 = root_new ['parrot';'ResizablePMCArray']
  vivify_373:
    set $P975, $P974[0]
    unless_null $P975, vivify_374
    new $P975, "Undef"
  vivify_374:
    set $S976, $P975
    iseq $I977, $S976, "!"
    if $I977, if_972
    new $P971, 'Integer'
    set $P971, $I977
    goto if_972_end
  if_972:
.annotate 'line', 375
    find_lex $P978, "$past"
    get_hll_global $P979, ["PAST"], "Var"
    $P980 = $P979."new"("self" :named("name"))
    $P978."push"($P980)
.annotate 'line', 376
    find_lex $P981, "$past"
    $P981."scope"("attribute")
.annotate 'line', 377
    find_lex $P982, "$past"
    find_lex $P983, "$/"
    unless_null $P983, vivify_375
    $P983 = root_new ['parrot';'Hash']
  vivify_375:
    set $P984, $P983["sigil"]
    unless_null $P984, vivify_376
    new $P984, "Undef"
  vivify_376:
    $P985 = "vivitype"($P984)
    $P982."viviself"($P985)
.annotate 'line', 378
    find_lex $P986, "$past"
    get_hll_global $P987, ["PAST"], "Var"
    $P988 = $P987."new"("$?CLASS" :named("name"))
    $P989 = $P986."push"($P988)
.annotate 'line', 374
    set $P971, $P989
  if_972_end:
    set $P945, $P971
.annotate 'line', 361
    goto if_946_end
  if_946:
.annotate 'line', 362
    find_lex $P952, "$past"
    $P952."scope"("contextual")
.annotate 'line', 363
    find_lex $P953, "$past"
.annotate 'line', 364
    get_hll_global $P954, ["PAST"], "Var"
.annotate 'line', 366
    find_lex $P955, "$/"
    unless_null $P955, vivify_377
    $P955 = root_new ['parrot';'Hash']
  vivify_377:
    set $P956, $P955["sigil"]
    unless_null $P956, vivify_378
    new $P956, "Undef"
  vivify_378:
    set $S957, $P956
    new $P958, 'String'
    set $P958, $S957
    find_lex $P959, "$/"
    unless_null $P959, vivify_379
    $P959 = root_new ['parrot';'Hash']
  vivify_379:
    set $P960, $P959["desigilname"]
    unless_null $P960, vivify_380
    new $P960, "Undef"
  vivify_380:
    concat $P961, $P958, $P960
.annotate 'line', 368
    get_hll_global $P962, ["PAST"], "Op"
    new $P963, "String"
    assign $P963, "Contextual "
    find_lex $P964, "$/"
    set $S965, $P964
    concat $P966, $P963, $S965
    concat $P967, $P966, " not found"
    $P968 = $P962."new"($P967, "die" :named("pirop"))
    $P969 = $P954."new"("package" :named("scope"), "" :named("namespace"), $P961 :named("name"), $P968 :named("viviself"))
.annotate 'line', 364
    $P970 = $P953."viviself"($P969)
.annotate 'line', 361
    set $P945, $P970
  if_946_end:
.annotate 'line', 351
    .return ($P945)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("68_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_994
    .param pmc param_995
.annotate 'line', 384
    .lex "self", param_994
    .lex "$/", param_995
    find_lex $P996, "$/"
    find_lex $P997, "$/"
    unless_null $P997, vivify_383
    $P997 = root_new ['parrot';'Hash']
  vivify_383:
    set $P998, $P997["package_def"]
    unless_null $P998, vivify_384
    new $P998, "Undef"
  vivify_384:
    $P999 = $P998."ast"()
    $P1000 = $P996."!make"($P999)
    .return ($P1000)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("69_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1002
    .param pmc param_1003
.annotate 'line', 385
    .lex "self", param_1002
    .lex "$/", param_1003
    find_lex $P1004, "$/"
    find_lex $P1005, "$/"
    unless_null $P1005, vivify_385
    $P1005 = root_new ['parrot';'Hash']
  vivify_385:
    set $P1006, $P1005["package_def"]
    unless_null $P1006, vivify_386
    new $P1006, "Undef"
  vivify_386:
    $P1007 = $P1006."ast"()
    $P1008 = $P1004."!make"($P1007)
    .return ($P1008)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("70_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1010
    .param pmc param_1011
.annotate 'line', 386
    .lex "self", param_1010
    .lex "$/", param_1011
    find_lex $P1012, "$/"
    find_lex $P1013, "$/"
    unless_null $P1013, vivify_387
    $P1013 = root_new ['parrot';'Hash']
  vivify_387:
    set $P1014, $P1013["package_def"]
    unless_null $P1014, vivify_388
    new $P1014, "Undef"
  vivify_388:
    $P1015 = $P1014."ast"()
    $P1016 = $P1012."!make"($P1015)
    .return ($P1016)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("71_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1018
    .param pmc param_1019
.annotate 'line', 387
    .lex "self", param_1018
    .lex "$/", param_1019
    find_lex $P1020, "$/"
    find_lex $P1021, "$/"
    unless_null $P1021, vivify_389
    $P1021 = root_new ['parrot';'Hash']
  vivify_389:
    set $P1022, $P1021["package_def"]
    unless_null $P1022, vivify_390
    new $P1022, "Undef"
  vivify_390:
    $P1023 = $P1022."ast"()
    $P1024 = $P1020."!make"($P1023)
    .return ($P1024)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("72_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1026
    .param pmc param_1027
.annotate 'line', 388
    .lex "self", param_1026
    .lex "$/", param_1027
    find_lex $P1028, "$/"
    find_lex $P1029, "$/"
    unless_null $P1029, vivify_391
    $P1029 = root_new ['parrot';'Hash']
  vivify_391:
    set $P1030, $P1029["package_def"]
    unless_null $P1030, vivify_392
    new $P1030, "Undef"
  vivify_392:
    $P1031 = $P1030."ast"()
    $P1032 = $P1028."!make"($P1031)
    .return ($P1032)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("73_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1034
    .param pmc param_1035
.annotate 'line', 389
    .lex "self", param_1034
    .lex "$/", param_1035
    find_lex $P1036, "$/"
    find_lex $P1037, "$/"
    unless_null $P1037, vivify_393
    $P1037 = root_new ['parrot';'Hash']
  vivify_393:
    set $P1038, $P1037["package_def"]
    unless_null $P1038, vivify_394
    new $P1038, "Undef"
  vivify_394:
    $P1039 = $P1038."ast"()
    $P1040 = $P1036."!make"($P1039)
    .return ($P1040)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("74_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1042
    .param pmc param_1043
.annotate 'line', 391
    .const 'Sub' $P1202 = "77_1298845576.421" 
    capture_lex $P1202
    .const 'Sub' $P1151 = "76_1298845576.421" 
    capture_lex $P1151
    .const 'Sub' $P1109 = "75_1298845576.421" 
    capture_lex $P1109
    .lex "self", param_1042
    .lex "$/", param_1043
.annotate 'line', 393
    $P1044 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1044
.annotate 'line', 394
    new $P1045, "Undef"
    .lex "$name", $P1045
.annotate 'line', 395
    new $P1046, "Undef"
    .lex "$how", $P1046
.annotate 'line', 398
    new $P1047, "Undef"
    .lex "$past", $P1047
.annotate 'line', 393
    find_lex $P1048, "$/"
    unless_null $P1048, vivify_395
    $P1048 = root_new ['parrot';'Hash']
  vivify_395:
    set $P1049, $P1048["name"]
    unless_null $P1049, vivify_396
    $P1049 = root_new ['parrot';'Hash']
  vivify_396:
    set $P1050, $P1049["identifier"]
    unless_null $P1050, vivify_397
    new $P1050, "Undef"
  vivify_397:
    clone $P1051, $P1050
    store_lex "@ns", $P1051
.annotate 'line', 394
    find_lex $P1052, "@ns"
    $P1053 = $P1052."pop"()
    set $S1054, $P1053
    new $P1055, 'String'
    set $P1055, $S1054
    store_lex "$name", $P1055
.annotate 'line', 395
    find_dynamic_lex $P1056, "$*PKGDECL"
    unless_null $P1056, vivify_398
    get_hll_global $P1056, "$PKGDECL"
    unless_null $P1056, vivify_399
    die "Contextual $*PKGDECL not found"
  vivify_399:
  vivify_398:
    find_dynamic_lex $P1057, "%*HOW"
    unless_null $P1057, vivify_400
    get_hll_global $P1057, "%HOW"
    unless_null $P1057, vivify_401
    die "Contextual %*HOW not found"
  vivify_401:
  vivify_400:
    set $P1058, $P1057[$P1056]
    unless_null $P1058, vivify_402
    new $P1058, "Undef"
  vivify_402:
    store_lex "$how", $P1058
.annotate 'line', 398
    find_lex $P1061, "$/"
    unless_null $P1061, vivify_403
    $P1061 = root_new ['parrot';'Hash']
  vivify_403:
    set $P1062, $P1061["block"]
    unless_null $P1062, vivify_404
    new $P1062, "Undef"
  vivify_404:
    if $P1062, if_1060
    find_lex $P1066, "$/"
    unless_null $P1066, vivify_405
    $P1066 = root_new ['parrot';'Hash']
  vivify_405:
    set $P1067, $P1066["comp_unit"]
    unless_null $P1067, vivify_406
    new $P1067, "Undef"
  vivify_406:
    $P1068 = $P1067."ast"()
    set $P1059, $P1068
    goto if_1060_end
  if_1060:
    find_lex $P1063, "$/"
    unless_null $P1063, vivify_407
    $P1063 = root_new ['parrot';'Hash']
  vivify_407:
    set $P1064, $P1063["block"]
    unless_null $P1064, vivify_408
    new $P1064, "Undef"
  vivify_408:
    $P1065 = $P1064."ast"()
    set $P1059, $P1065
  if_1060_end:
    store_lex "$past", $P1059
.annotate 'line', 399
    find_lex $P1069, "$past"
    find_lex $P1070, "$/"
    unless_null $P1070, vivify_409
    $P1070 = root_new ['parrot';'Hash']
  vivify_409:
    set $P1071, $P1070["name"]
    unless_null $P1071, vivify_410
    $P1071 = root_new ['parrot';'Hash']
  vivify_410:
    set $P1072, $P1071["identifier"]
    unless_null $P1072, vivify_411
    new $P1072, "Undef"
  vivify_411:
    $P1069."namespace"($P1072)
.annotate 'line', 403
    find_dynamic_lex $P1073, "$*PACKAGE-SETUP"
    unless_null $P1073, vivify_412
    get_hll_global $P1073, "$PACKAGE-SETUP"
    unless_null $P1073, vivify_413
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_413:
  vivify_412:
    get_hll_global $P1074, ["PAST"], "Stmts"
.annotate 'line', 404
    get_hll_global $P1075, ["PAST"], "Op"
.annotate 'line', 405
    get_hll_global $P1076, ["PAST"], "Var"
    $P1077 = $P1076."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 406
    get_hll_global $P1078, ["PAST"], "Op"
.annotate 'line', 408
    get_hll_global $P1079, ["PAST"], "Var"
    find_lex $P1080, "$how"
    get_how $P1081, $P1080
    find_lex $P1082, "$how"
    $P1083 = $P1081."name"($P1082)
    $P1084 = $P1079."new"($P1083 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 409
    get_hll_global $P1085, ["PAST"], "Val"
    find_lex $P1086, "$name"
    $P1087 = $P1085."new"($P1086 :named("value"), "name" :named("named"))
    $P1088 = $P1078."new"($P1084, $P1087, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 406
    $P1089 = $P1075."new"($P1077, $P1088, "bind" :named("pasttype"))
.annotate 'line', 412
    get_hll_global $P1090, ["PAST"], "Op"
.annotate 'line', 413
    get_hll_global $P1091, ["PAST"], "Var"
    find_lex $P1092, "$name"
    find_lex $P1093, "@ns"
    $P1094 = $P1091."new"($P1092 :named("name"), $P1093 :named("namespace"), "package" :named("scope"))
.annotate 'line', 414
    get_hll_global $P1095, ["PAST"], "Var"
    $P1096 = $P1095."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1097 = $P1090."new"($P1094, $P1096, "bind" :named("pasttype"))
.annotate 'line', 416
    get_hll_global $P1098, ["PAST"], "Op"
.annotate 'line', 417
    get_hll_global $P1099, ["PAST"], "Var"
    $P1100 = $P1099."new"("$?CLASS" :named("name"))
.annotate 'line', 418
    get_hll_global $P1101, ["PAST"], "Var"
    $P1102 = $P1101."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1103 = $P1098."new"($P1100, $P1102, "bind" :named("pasttype"))
.annotate 'line', 416
    $P1104 = $P1074."new"($P1089, $P1097, $P1103)
.annotate 'line', 403
    $P1073."unshift"($P1104)
.annotate 'line', 423
    find_lex $P1106, "$/"
    unless_null $P1106, vivify_414
    $P1106 = root_new ['parrot';'Hash']
  vivify_414:
    set $P1107, $P1106["repr"]
    unless_null $P1107, vivify_415
    new $P1107, "Undef"
  vivify_415:
    unless $P1107, if_1105_end
    .const 'Sub' $P1109 = "75_1298845576.421" 
    capture_lex $P1109
    $P1109()
  if_1105_end:
.annotate 'line', 434
    find_lex $P1125, "$how"
    can $I1126, $P1125, "parametric"
    if $I1126, if_1124
    new $P1123, 'Integer'
    set $P1123, $I1126
    goto if_1124_end
  if_1124:
    find_lex $P1127, "$how"
    find_lex $P1128, "$how"
    $P1129 = $P1127."parametric"($P1128)
    set $P1123, $P1129
  if_1124_end:
    if $P1123, if_1122
.annotate 'line', 441
    find_lex $P1142, "$past"
    $P1142."blocktype"("immediate")
.annotate 'line', 442
    find_lex $P1143, "$past"
    get_hll_global $P1144, ["PAST"], "Var"
    $P1145 = $P1144."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1143."unshift"($P1145)
.annotate 'line', 443
    find_lex $P1146, "$past"
    $P1146."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 440
    goto if_1122_end
  if_1122:
.annotate 'line', 435
    find_lex $P1130, "$past"
    $P1130."blocktype"("declaration")
.annotate 'line', 436
    find_lex $P1131, "$past"
    get_hll_global $P1132, ["PAST"], "Var"
    $P1133 = $P1132."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1131."unshift"($P1133)
.annotate 'line', 437
    find_lex $P1134, "$past"
    $P1134."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 438
    find_dynamic_lex $P1135, "$*PACKAGE-SETUP"
    unless_null $P1135, vivify_424
    get_hll_global $P1135, "$PACKAGE-SETUP"
    unless_null $P1135, vivify_425
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_425:
  vivify_424:
    set $P1136, $P1135[0]
    unless_null $P1136, vivify_426
    $P1136 = root_new ['parrot';'ResizablePMCArray']
  vivify_426:
    set $P1137, $P1136[0]
    unless_null $P1137, vivify_427
    $P1137 = root_new ['parrot';'ResizablePMCArray']
  vivify_427:
    set $P1138, $P1137[1]
    unless_null $P1138, vivify_428
    new $P1138, "Undef"
  vivify_428:
    get_hll_global $P1139, ["PAST"], "Val"
    find_lex $P1140, "$past"
    $P1141 = $P1139."new"($P1140 :named("value"), "body_block" :named("named"))
    $P1138."push"($P1141)
  if_1122_end:
.annotate 'line', 448
    find_lex $P1148, "$/"
    unless_null $P1148, vivify_429
    $P1148 = root_new ['parrot';'Hash']
  vivify_429:
    set $P1149, $P1148["parent"]
    unless_null $P1149, vivify_430
    new $P1149, "Undef"
  vivify_430:
    if $P1149, if_1147
.annotate 'line', 462
    find_dynamic_lex $P1179, "$*PKGDECL"
    unless_null $P1179, vivify_431
    get_hll_global $P1179, "$PKGDECL"
    unless_null $P1179, vivify_432
    die "Contextual $*PKGDECL not found"
  vivify_432:
  vivify_431:
    set $S1180, $P1179
    iseq $I1181, $S1180, "grammar"
    unless $I1181, if_1178_end
.annotate 'line', 463
    find_dynamic_lex $P1182, "$*PACKAGE-SETUP"
    unless_null $P1182, vivify_433
    get_hll_global $P1182, "$PACKAGE-SETUP"
    unless_null $P1182, vivify_434
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_434:
  vivify_433:
    get_hll_global $P1183, ["PAST"], "Op"
.annotate 'line', 465
    get_hll_global $P1184, ["PAST"], "Op"
.annotate 'line', 468
    get_hll_global $P1185, ["PAST"], "Var"
    $P1186 = $P1185."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1187 = $P1184."new"($P1186, "get_how PP" :named("pirop"))
.annotate 'line', 470
    get_hll_global $P1188, ["PAST"], "Var"
    $P1189 = $P1188."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 471
    get_hll_global $P1190, ["PAST"], "Var"
    $P1191 = $P1190."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1192 = $P1183."new"($P1187, $P1189, $P1191, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 463
    $P1182."push"($P1192)
  if_1178_end:
.annotate 'line', 462
    goto if_1147_end
  if_1147:
.annotate 'line', 448
    .const 'Sub' $P1151 = "76_1298845576.421" 
    capture_lex $P1151
    $P1151()
  if_1147_end:
.annotate 'line', 476
    find_lex $P1194, "$/"
    unless_null $P1194, vivify_441
    $P1194 = root_new ['parrot';'Hash']
  vivify_441:
    set $P1195, $P1194["role"]
    unless_null $P1195, vivify_442
    new $P1195, "Undef"
  vivify_442:
    unless $P1195, if_1193_end
.annotate 'line', 477
    find_lex $P1197, "$/"
    unless_null $P1197, vivify_443
    $P1197 = root_new ['parrot';'Hash']
  vivify_443:
    set $P1198, $P1197["role"]
    unless_null $P1198, vivify_444
    new $P1198, "Undef"
  vivify_444:
    defined $I1199, $P1198
    unless $I1199, for_undef_445
    iter $P1196, $P1198
    new $P1229, 'ExceptionHandler'
    set_label $P1229, loop1228_handler
    $P1229."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1229
  loop1228_test:
    unless $P1196, loop1228_done
    shift $P1200, $P1196
  loop1228_redo:
    .const 'Sub' $P1202 = "77_1298845576.421" 
    capture_lex $P1202
    $P1202($P1200)
  loop1228_next:
    goto loop1228_test
  loop1228_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1230, exception, 'type'
    eq $P1230, .CONTROL_LOOP_NEXT, loop1228_next
    eq $P1230, .CONTROL_LOOP_REDO, loop1228_redo
  loop1228_done:
    pop_eh 
  for_undef_445:
  if_1193_end:
.annotate 'line', 494
    find_dynamic_lex $P1231, "$*PACKAGE-SETUP"
    unless_null $P1231, vivify_450
    get_hll_global $P1231, "$PACKAGE-SETUP"
    unless_null $P1231, vivify_451
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_451:
  vivify_450:
    get_hll_global $P1232, ["PAST"], "Op"
.annotate 'line', 496
    get_hll_global $P1233, ["PAST"], "Op"
.annotate 'line', 499
    get_hll_global $P1234, ["PAST"], "Var"
    $P1235 = $P1234."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1236 = $P1233."new"($P1235, "get_how PP" :named("pirop"))
.annotate 'line', 501
    get_hll_global $P1237, ["PAST"], "Var"
    $P1238 = $P1237."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1239 = $P1232."new"($P1236, $P1238, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 494
    $P1231."push"($P1239)
.annotate 'line', 505
    get_global $P1240, "@BLOCK"
    unless_null $P1240, vivify_452
    $P1240 = root_new ['parrot';'ResizablePMCArray']
  vivify_452:
    set $P1241, $P1240[0]
    unless_null $P1241, vivify_453
    $P1241 = root_new ['parrot';'ResizablePMCArray']
  vivify_453:
    set $P1242, $P1241[0]
    unless_null $P1242, vivify_454
    new $P1242, "Undef"
  vivify_454:
    get_hll_global $P1243, ["PAST"], "Var"
    find_lex $P1244, "$name"
    find_lex $P1245, "@ns"
    $P1246 = $P1243."new"($P1244 :named("name"), $P1245 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P1242."unshift"($P1246)
.annotate 'line', 508
    find_lex $P1247, "$past"
    $P1248 = $P1247."loadinit"()
    get_hll_global $P1249, ["PAST"], "Block"
    find_dynamic_lex $P1250, "$*PACKAGE-SETUP"
    unless_null $P1250, vivify_455
    get_hll_global $P1250, "$PACKAGE-SETUP"
    unless_null $P1250, vivify_456
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_456:
  vivify_455:
    $P1251 = $P1249."new"($P1250, "immediate" :named("blocktype"))
    $P1248."push"($P1251)
.annotate 'line', 510
    find_lex $P1252, "$/"
    find_lex $P1253, "$past"
    $P1254 = $P1252."!make"($P1253)
.annotate 'line', 391
    .return ($P1254)
.end


.namespace ["NQP";"Actions"]
.sub "_block1108"  :anon :subid("75_1298845576.421") :outer("74_1298845576.421")
.annotate 'line', 424
    new $P1110, "Undef"
    .lex "$repr_name", $P1110
    find_lex $P1111, "$/"
    unless_null $P1111, vivify_416
    $P1111 = root_new ['parrot';'Hash']
  vivify_416:
    set $P1112, $P1111["repr"]
    unless_null $P1112, vivify_417
    $P1112 = root_new ['parrot';'ResizablePMCArray']
  vivify_417:
    set $P1113, $P1112[0]
    unless_null $P1113, vivify_418
    new $P1113, "Undef"
  vivify_418:
    $P1114 = $P1113."ast"()
    store_lex "$repr_name", $P1114
.annotate 'line', 425
    find_lex $P1115, "$repr_name"
    $P1115."named"("repr")
.annotate 'line', 426
    find_dynamic_lex $P1116, "$*PACKAGE-SETUP"
    unless_null $P1116, vivify_419
    get_hll_global $P1116, "$PACKAGE-SETUP"
    unless_null $P1116, vivify_420
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_420:
  vivify_419:
    set $P1117, $P1116[0]
    unless_null $P1117, vivify_421
    $P1117 = root_new ['parrot';'ResizablePMCArray']
  vivify_421:
    set $P1118, $P1117[0]
    unless_null $P1118, vivify_422
    $P1118 = root_new ['parrot';'ResizablePMCArray']
  vivify_422:
    set $P1119, $P1118[1]
    unless_null $P1119, vivify_423
    new $P1119, "Undef"
  vivify_423:
    find_lex $P1120, "$repr_name"
    $P1121 = $P1119."push"($P1120)
.annotate 'line', 423
    .return ($P1121)
.end


.namespace ["NQP";"Actions"]
.sub "_block1150"  :anon :subid("76_1298845576.421") :outer("74_1298845576.421")
.annotate 'line', 449
    $P1152 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1152
.annotate 'line', 450
    new $P1153, "Undef"
    .lex "$name", $P1153
.annotate 'line', 449
    find_lex $P1154, "$/"
    unless_null $P1154, vivify_435
    $P1154 = root_new ['parrot';'Hash']
  vivify_435:
    set $P1155, $P1154["parent"]
    unless_null $P1155, vivify_436
    $P1155 = root_new ['parrot';'ResizablePMCArray']
  vivify_436:
    set $P1156, $P1155[0]
    unless_null $P1156, vivify_437
    $P1156 = root_new ['parrot';'Hash']
  vivify_437:
    set $P1157, $P1156["identifier"]
    unless_null $P1157, vivify_438
    new $P1157, "Undef"
  vivify_438:
    clone $P1158, $P1157
    store_lex "@ns", $P1158
.annotate 'line', 450
    find_lex $P1159, "@ns"
    $P1160 = $P1159."pop"()
    set $S1161, $P1160
    new $P1162, 'String'
    set $P1162, $S1161
    store_lex "$name", $P1162
.annotate 'line', 451
    find_dynamic_lex $P1163, "$*PACKAGE-SETUP"
    unless_null $P1163, vivify_439
    get_hll_global $P1163, "$PACKAGE-SETUP"
    unless_null $P1163, vivify_440
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_440:
  vivify_439:
    get_hll_global $P1164, ["PAST"], "Op"
.annotate 'line', 453
    get_hll_global $P1165, ["PAST"], "Op"
.annotate 'line', 456
    get_hll_global $P1166, ["PAST"], "Var"
    $P1167 = $P1166."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1168 = $P1165."new"($P1167, "get_how PP" :named("pirop"))
.annotate 'line', 458
    get_hll_global $P1169, ["PAST"], "Var"
    $P1170 = $P1169."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 459
    get_hll_global $P1171, ["PAST"], "Var"
    find_lex $P1172, "$name"
    set $S1173, $P1172
    find_lex $P1174, "@ns"
    $P1175 = $P1171."new"($S1173 :named("name"), $P1174 :named("namespace"), "package" :named("scope"))
    $P1176 = $P1164."new"($P1168, $P1170, $P1175, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 451
    $P1177 = $P1163."push"($P1176)
.annotate 'line', 448
    .return ($P1177)
.end


.namespace ["NQP";"Actions"]
.sub "_block1201"  :anon :subid("77_1298845576.421") :outer("74_1298845576.421")
    .param pmc param_1205
.annotate 'line', 478
    $P1203 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1203
.annotate 'line', 479
    new $P1204, "Undef"
    .lex "$name", $P1204
    .lex "$_", param_1205
.annotate 'line', 478
    find_lex $P1206, "$_"
    unless_null $P1206, vivify_446
    $P1206 = root_new ['parrot';'Hash']
  vivify_446:
    set $P1207, $P1206["identifier"]
    unless_null $P1207, vivify_447
    new $P1207, "Undef"
  vivify_447:
    clone $P1208, $P1207
    store_lex "@ns", $P1208
.annotate 'line', 479
    find_lex $P1209, "@ns"
    $P1210 = $P1209."pop"()
    set $S1211, $P1210
    new $P1212, 'String'
    set $P1212, $S1211
    store_lex "$name", $P1212
.annotate 'line', 480
    find_dynamic_lex $P1213, "$*PACKAGE-SETUP"
    unless_null $P1213, vivify_448
    get_hll_global $P1213, "$PACKAGE-SETUP"
    unless_null $P1213, vivify_449
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_449:
  vivify_448:
    get_hll_global $P1214, ["PAST"], "Op"
.annotate 'line', 482
    get_hll_global $P1215, ["PAST"], "Op"
.annotate 'line', 485
    get_hll_global $P1216, ["PAST"], "Var"
    $P1217 = $P1216."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1218 = $P1215."new"($P1217, "get_how PP" :named("pirop"))
.annotate 'line', 487
    get_hll_global $P1219, ["PAST"], "Var"
    $P1220 = $P1219."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 488
    get_hll_global $P1221, ["PAST"], "Var"
    find_lex $P1222, "$name"
    set $S1223, $P1222
    find_lex $P1224, "@ns"
    $P1225 = $P1221."new"($S1223 :named("name"), $P1224 :named("namespace"), "package" :named("scope"))
    $P1226 = $P1214."new"($P1218, $P1220, $P1225, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 480
    $P1227 = $P1213."push"($P1226)
.annotate 'line', 477
    .return ($P1227)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("78_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1256
    .param pmc param_1257
.annotate 'line', 513
    .lex "self", param_1256
    .lex "$/", param_1257
    find_lex $P1258, "$/"
    find_lex $P1259, "$/"
    unless_null $P1259, vivify_457
    $P1259 = root_new ['parrot';'Hash']
  vivify_457:
    set $P1260, $P1259["scoped"]
    unless_null $P1260, vivify_458
    new $P1260, "Undef"
  vivify_458:
    $P1261 = $P1260."ast"()
    $P1262 = $P1258."!make"($P1261)
    .return ($P1262)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("79_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1264
    .param pmc param_1265
.annotate 'line', 514
    .lex "self", param_1264
    .lex "$/", param_1265
    find_lex $P1266, "$/"
    find_lex $P1267, "$/"
    unless_null $P1267, vivify_459
    $P1267 = root_new ['parrot';'Hash']
  vivify_459:
    set $P1268, $P1267["scoped"]
    unless_null $P1268, vivify_460
    new $P1268, "Undef"
  vivify_460:
    $P1269 = $P1268."ast"()
    $P1270 = $P1266."!make"($P1269)
    .return ($P1270)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("80_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1272
    .param pmc param_1273
.annotate 'line', 515
    .lex "self", param_1272
    .lex "$/", param_1273
    find_lex $P1274, "$/"
    find_lex $P1275, "$/"
    unless_null $P1275, vivify_461
    $P1275 = root_new ['parrot';'Hash']
  vivify_461:
    set $P1276, $P1275["scoped"]
    unless_null $P1276, vivify_462
    new $P1276, "Undef"
  vivify_462:
    $P1277 = $P1276."ast"()
    $P1278 = $P1274."!make"($P1277)
    .return ($P1278)
.end


.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("81_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1280
    .param pmc param_1281
.annotate 'line', 517
    .lex "self", param_1280
    .lex "$/", param_1281
.annotate 'line', 518
    find_lex $P1282, "$/"
.annotate 'line', 519
    find_lex $P1285, "$/"
    unless_null $P1285, vivify_463
    $P1285 = root_new ['parrot';'Hash']
  vivify_463:
    set $P1286, $P1285["declarator"]
    unless_null $P1286, vivify_464
    new $P1286, "Undef"
  vivify_464:
    if $P1286, if_1284
.annotate 'line', 520
    find_lex $P1290, "$/"
    unless_null $P1290, vivify_465
    $P1290 = root_new ['parrot';'Hash']
  vivify_465:
    set $P1291, $P1290["multi_declarator"]
    unless_null $P1291, vivify_466
    new $P1291, "Undef"
  vivify_466:
    $P1292 = $P1291."ast"()
    set $P1283, $P1292
.annotate 'line', 519
    goto if_1284_end
  if_1284:
    find_lex $P1287, "$/"
    unless_null $P1287, vivify_467
    $P1287 = root_new ['parrot';'Hash']
  vivify_467:
    set $P1288, $P1287["declarator"]
    unless_null $P1288, vivify_468
    new $P1288, "Undef"
  vivify_468:
    $P1289 = $P1288."ast"()
    set $P1283, $P1289
  if_1284_end:
    $P1293 = $P1282."!make"($P1283)
.annotate 'line', 517
    .return ($P1293)
.end


.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("82_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1295
    .param pmc param_1296
.annotate 'line', 523
    .lex "self", param_1295
    .lex "$/", param_1296
.annotate 'line', 524
    find_lex $P1297, "$/"
.annotate 'line', 525
    find_lex $P1300, "$/"
    unless_null $P1300, vivify_469
    $P1300 = root_new ['parrot';'Hash']
  vivify_469:
    set $P1301, $P1300["routine_declarator"]
    unless_null $P1301, vivify_470
    new $P1301, "Undef"
  vivify_470:
    if $P1301, if_1299
.annotate 'line', 526
    find_lex $P1305, "$/"
    unless_null $P1305, vivify_471
    $P1305 = root_new ['parrot';'Hash']
  vivify_471:
    set $P1306, $P1305["variable_declarator"]
    unless_null $P1306, vivify_472
    new $P1306, "Undef"
  vivify_472:
    $P1307 = $P1306."ast"()
    set $P1298, $P1307
.annotate 'line', 525
    goto if_1299_end
  if_1299:
    find_lex $P1302, "$/"
    unless_null $P1302, vivify_473
    $P1302 = root_new ['parrot';'Hash']
  vivify_473:
    set $P1303, $P1302["routine_declarator"]
    unless_null $P1303, vivify_474
    new $P1303, "Undef"
  vivify_474:
    $P1304 = $P1303."ast"()
    set $P1298, $P1304
  if_1299_end:
    $P1308 = $P1297."!make"($P1298)
.annotate 'line', 523
    .return ($P1308)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("83_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1310
    .param pmc param_1311
.annotate 'line', 529
    .lex "self", param_1310
    .lex "$/", param_1311
    find_lex $P1312, "$/"
    find_lex $P1315, "$/"
    unless_null $P1315, vivify_475
    $P1315 = root_new ['parrot';'Hash']
  vivify_475:
    set $P1316, $P1315["declarator"]
    unless_null $P1316, vivify_476
    new $P1316, "Undef"
  vivify_476:
    if $P1316, if_1314
    find_lex $P1320, "$/"
    unless_null $P1320, vivify_477
    $P1320 = root_new ['parrot';'Hash']
  vivify_477:
    set $P1321, $P1320["routine_def"]
    unless_null $P1321, vivify_478
    new $P1321, "Undef"
  vivify_478:
    $P1322 = $P1321."ast"()
    set $P1313, $P1322
    goto if_1314_end
  if_1314:
    find_lex $P1317, "$/"
    unless_null $P1317, vivify_479
    $P1317 = root_new ['parrot';'Hash']
  vivify_479:
    set $P1318, $P1317["declarator"]
    unless_null $P1318, vivify_480
    new $P1318, "Undef"
  vivify_480:
    $P1319 = $P1318."ast"()
    set $P1313, $P1319
  if_1314_end:
    $P1323 = $P1312."!make"($P1313)
    .return ($P1323)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("84_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1325
    .param pmc param_1326
.annotate 'line', 530
    .lex "self", param_1325
    .lex "$/", param_1326
    find_lex $P1327, "$/"
    find_lex $P1330, "$/"
    unless_null $P1330, vivify_481
    $P1330 = root_new ['parrot';'Hash']
  vivify_481:
    set $P1331, $P1330["declarator"]
    unless_null $P1331, vivify_482
    new $P1331, "Undef"
  vivify_482:
    if $P1331, if_1329
    find_lex $P1335, "$/"
    unless_null $P1335, vivify_483
    $P1335 = root_new ['parrot';'Hash']
  vivify_483:
    set $P1336, $P1335["routine_def"]
    unless_null $P1336, vivify_484
    new $P1336, "Undef"
  vivify_484:
    $P1337 = $P1336."ast"()
    set $P1328, $P1337
    goto if_1329_end
  if_1329:
    find_lex $P1332, "$/"
    unless_null $P1332, vivify_485
    $P1332 = root_new ['parrot';'Hash']
  vivify_485:
    set $P1333, $P1332["declarator"]
    unless_null $P1333, vivify_486
    new $P1333, "Undef"
  vivify_486:
    $P1334 = $P1333."ast"()
    set $P1328, $P1334
  if_1329_end:
    $P1338 = $P1327."!make"($P1328)
    .return ($P1338)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("85_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1340
    .param pmc param_1341
.annotate 'line', 531
    .lex "self", param_1340
    .lex "$/", param_1341
    find_lex $P1342, "$/"
    find_lex $P1343, "$/"
    unless_null $P1343, vivify_487
    $P1343 = root_new ['parrot';'Hash']
  vivify_487:
    set $P1344, $P1343["declarator"]
    unless_null $P1344, vivify_488
    new $P1344, "Undef"
  vivify_488:
    $P1345 = $P1344."ast"()
    $P1346 = $P1342."!make"($P1345)
    .return ($P1346)
.end


.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("86_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1348
    .param pmc param_1349
.annotate 'line', 534
    .const 'Sub' $P1421 = "89_1298845576.421" 
    capture_lex $P1421
    .const 'Sub' $P1376 = "87_1298845576.421" 
    capture_lex $P1376
    .lex "self", param_1348
    .lex "$/", param_1349
.annotate 'line', 535
    new $P1350, "Undef"
    .lex "$past", $P1350
.annotate 'line', 536
    new $P1351, "Undef"
    .lex "$sigil", $P1351
.annotate 'line', 537
    new $P1352, "Undef"
    .lex "$name", $P1352
.annotate 'line', 538
    new $P1353, "Undef"
    .lex "$BLOCK", $P1353
.annotate 'line', 535
    find_lex $P1354, "$/"
    unless_null $P1354, vivify_489
    $P1354 = root_new ['parrot';'Hash']
  vivify_489:
    set $P1355, $P1354["variable"]
    unless_null $P1355, vivify_490
    new $P1355, "Undef"
  vivify_490:
    $P1356 = $P1355."ast"()
    store_lex "$past", $P1356
.annotate 'line', 536
    find_lex $P1357, "$/"
    unless_null $P1357, vivify_491
    $P1357 = root_new ['parrot';'Hash']
  vivify_491:
    set $P1358, $P1357["variable"]
    unless_null $P1358, vivify_492
    $P1358 = root_new ['parrot';'Hash']
  vivify_492:
    set $P1359, $P1358["sigil"]
    unless_null $P1359, vivify_493
    new $P1359, "Undef"
  vivify_493:
    store_lex "$sigil", $P1359
.annotate 'line', 537
    find_lex $P1360, "$past"
    $P1361 = $P1360."name"()
    store_lex "$name", $P1361
.annotate 'line', 538
    get_global $P1362, "@BLOCK"
    unless_null $P1362, vivify_494
    $P1362 = root_new ['parrot';'ResizablePMCArray']
  vivify_494:
    set $P1363, $P1362[0]
    unless_null $P1363, vivify_495
    new $P1363, "Undef"
  vivify_495:
    store_lex "$BLOCK", $P1363
.annotate 'line', 539
    find_lex $P1365, "$BLOCK"
    find_lex $P1366, "$name"
    $P1367 = $P1365."symbol"($P1366)
    unless $P1367, if_1364_end
.annotate 'line', 540
    find_lex $P1368, "$/"
    $P1369 = $P1368."CURSOR"()
    find_lex $P1370, "$name"
    $P1369."panic"("Redeclaration of symbol ", $P1370)
  if_1364_end:
.annotate 'line', 542
    find_dynamic_lex $P1372, "$*SCOPE"
    unless_null $P1372, vivify_496
    get_hll_global $P1372, "$SCOPE"
    unless_null $P1372, vivify_497
    die "Contextual $*SCOPE not found"
  vivify_497:
  vivify_496:
    set $S1373, $P1372
    iseq $I1374, $S1373, "has"
    if $I1374, if_1371
.annotate 'line', 567
    .const 'Sub' $P1421 = "89_1298845576.421" 
    capture_lex $P1421
    $P1421()
    goto if_1371_end
  if_1371:
.annotate 'line', 542
    .const 'Sub' $P1376 = "87_1298845576.421" 
    capture_lex $P1376
    $P1376()
  if_1371_end:
.annotate 'line', 575
    find_lex $P1445, "$/"
    find_lex $P1446, "$past"
    $P1447 = $P1445."!make"($P1446)
.annotate 'line', 534
    .return ($P1447)
.end


.namespace ["NQP";"Actions"]
.sub "_block1420"  :anon :subid("89_1298845576.421") :outer("86_1298845576.421")
.annotate 'line', 568
    new $P1422, "Undef"
    .lex "$scope", $P1422
.annotate 'line', 569
    new $P1423, "Undef"
    .lex "$decl", $P1423
.annotate 'line', 568
    find_dynamic_lex $P1426, "$*SCOPE"
    unless_null $P1426, vivify_498
    get_hll_global $P1426, "$SCOPE"
    unless_null $P1426, vivify_499
    die "Contextual $*SCOPE not found"
  vivify_499:
  vivify_498:
    set $S1427, $P1426
    iseq $I1428, $S1427, "our"
    if $I1428, if_1425
    new $P1430, "String"
    assign $P1430, "lexical"
    set $P1424, $P1430
    goto if_1425_end
  if_1425:
    new $P1429, "String"
    assign $P1429, "package"
    set $P1424, $P1429
  if_1425_end:
    store_lex "$scope", $P1424
.annotate 'line', 569
    get_hll_global $P1431, ["PAST"], "Var"
    find_lex $P1432, "$name"
    find_lex $P1433, "$scope"
.annotate 'line', 570
    find_lex $P1434, "$sigil"
    $P1435 = "vivitype"($P1434)
    find_lex $P1436, "$/"
    $P1437 = $P1431."new"($P1432 :named("name"), $P1433 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1435 :named("viviself"), $P1436 :named("node"))
.annotate 'line', 569
    store_lex "$decl", $P1437
.annotate 'line', 572
    find_lex $P1438, "$BLOCK"
    find_lex $P1439, "$name"
    find_lex $P1440, "$scope"
    $P1438."symbol"($P1439, $P1440 :named("scope"))
.annotate 'line', 573
    find_lex $P1441, "$BLOCK"
    unless_null $P1441, vivify_500
    $P1441 = root_new ['parrot';'ResizablePMCArray']
  vivify_500:
    set $P1442, $P1441[0]
    unless_null $P1442, vivify_501
    new $P1442, "Undef"
  vivify_501:
    find_lex $P1443, "$decl"
    $P1444 = $P1442."push"($P1443)
.annotate 'line', 567
    .return ($P1444)
.end


.namespace ["NQP";"Actions"]
.sub "_block1375"  :anon :subid("87_1298845576.421") :outer("86_1298845576.421")
.annotate 'line', 542
    .const 'Sub' $P1406 = "88_1298845576.421" 
    capture_lex $P1406
.annotate 'line', 544
    new $P1377, "Undef"
    .lex "$meta-attr-type", $P1377
.annotate 'line', 552
    new $P1378, "Undef"
    .lex "$meta_args", $P1378
.annotate 'line', 544
    find_dynamic_lex $P1381, "$*PKGDECL"
    unless_null $P1381, vivify_502
    get_hll_global $P1381, "$PKGDECL"
    unless_null $P1381, vivify_503
    die "Contextual $*PKGDECL not found"
  vivify_503:
  vivify_502:
    find_dynamic_lex $P1382, "%*HOW-METAATTR"
    unless_null $P1382, vivify_504
    get_hll_global $P1382, "%HOW-METAATTR"
    unless_null $P1382, vivify_505
    die "Contextual %*HOW-METAATTR not found"
  vivify_505:
  vivify_504:
    set $P1383, $P1382[$P1381]
    unless_null $P1383, vivify_506
    new $P1383, "Undef"
  vivify_506:
    unless $P1383, unless_1380
    set $P1379, $P1383
    goto unless_1380_end
  unless_1380:
    find_dynamic_lex $P1384, "$*DEFAULT-METAATTR"
    unless_null $P1384, vivify_507
    get_hll_global $P1384, "$DEFAULT-METAATTR"
    unless_null $P1384, vivify_508
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_508:
  vivify_507:
    set $P1379, $P1384
  unless_1380_end:
    store_lex "$meta-attr-type", $P1379
.annotate 'line', 545
    find_dynamic_lex $P1385, "$*PACKAGE-SETUP"
    unless_null $P1385, vivify_509
    get_hll_global $P1385, "$PACKAGE-SETUP"
    unless_null $P1385, vivify_510
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_510:
  vivify_509:
    get_hll_global $P1386, ["PAST"], "Op"
.annotate 'line', 547
    get_hll_global $P1387, ["PAST"], "Op"
.annotate 'line', 549
    get_hll_global $P1388, ["PAST"], "Var"
    $P1389 = $P1388."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1390 = $P1387."new"($P1389, "get_how PP" :named("pirop"))
.annotate 'line', 551
    get_hll_global $P1391, ["PAST"], "Var"
    $P1392 = $P1391."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 552
    get_hll_global $P1393, ["PAST"], "Op"
.annotate 'line', 554
    get_hll_global $P1394, ["PAST"], "Var"
    find_lex $P1395, "$meta-attr-type"
    $P1396 = $P1394."new"($P1395 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 555
    get_hll_global $P1397, ["PAST"], "Val"
    find_lex $P1398, "$name"
    $P1399 = $P1397."new"($P1398 :named("value"), "name" :named("named"))
    $P1400 = $P1393."new"($P1396, $P1399, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 552
    store_lex "$meta_args", $P1400
    $P1401 = $P1386."new"($P1390, $P1392, $P1400, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 545
    $P1385."push"($P1401)
.annotate 'line', 558
    find_lex $P1403, "$/"
    unless_null $P1403, vivify_511
    $P1403 = root_new ['parrot';'Hash']
  vivify_511:
    set $P1404, $P1403["typename"]
    unless_null $P1404, vivify_512
    new $P1404, "Undef"
  vivify_512:
    unless $P1404, if_1402_end
    .const 'Sub' $P1406 = "88_1298845576.421" 
    capture_lex $P1406
    $P1406()
  if_1402_end:
.annotate 'line', 564
    find_lex $P1416, "$BLOCK"
    find_lex $P1417, "$name"
    $P1416."symbol"($P1417, "attribute" :named("scope"))
.annotate 'line', 565
    get_hll_global $P1418, ["PAST"], "Stmts"
    $P1419 = $P1418."new"()
    store_lex "$past", $P1419
.annotate 'line', 542
    .return ($P1419)
.end


.namespace ["NQP";"Actions"]
.sub "_block1405"  :anon :subid("88_1298845576.421") :outer("87_1298845576.421")
.annotate 'line', 559
    new $P1407, "Undef"
    .lex "$type", $P1407
    find_lex $P1408, "$/"
    unless_null $P1408, vivify_513
    $P1408 = root_new ['parrot';'Hash']
  vivify_513:
    set $P1409, $P1408["typename"]
    unless_null $P1409, vivify_514
    $P1409 = root_new ['parrot';'ResizablePMCArray']
  vivify_514:
    set $P1410, $P1409[0]
    unless_null $P1410, vivify_515
    new $P1410, "Undef"
  vivify_515:
    $P1411 = $P1410."ast"()
    store_lex "$type", $P1411
.annotate 'line', 560
    find_lex $P1412, "$type"
    $P1412."named"("type")
.annotate 'line', 561
    find_lex $P1413, "$meta_args"
    find_lex $P1414, "$type"
    $P1415 = $P1413."push"($P1414)
.annotate 'line', 558
    .return ($P1415)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("90_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1449
    .param pmc param_1450
.annotate 'line', 578
    .lex "self", param_1449
    .lex "$/", param_1450
    find_lex $P1451, "$/"
    find_lex $P1452, "$/"
    unless_null $P1452, vivify_516
    $P1452 = root_new ['parrot';'Hash']
  vivify_516:
    set $P1453, $P1452["routine_def"]
    unless_null $P1453, vivify_517
    new $P1453, "Undef"
  vivify_517:
    $P1454 = $P1453."ast"()
    $P1455 = $P1451."!make"($P1454)
    .return ($P1455)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("91_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1457
    .param pmc param_1458
.annotate 'line', 579
    .lex "self", param_1457
    .lex "$/", param_1458
    find_lex $P1459, "$/"
    find_lex $P1460, "$/"
    unless_null $P1460, vivify_518
    $P1460 = root_new ['parrot';'Hash']
  vivify_518:
    set $P1461, $P1460["method_def"]
    unless_null $P1461, vivify_519
    new $P1461, "Undef"
  vivify_519:
    $P1462 = $P1461."ast"()
    $P1463 = $P1459."!make"($P1462)
    .return ($P1463)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("92_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1465
    .param pmc param_1466
.annotate 'line', 581
    .const 'Sub' $P1694 = "98_1298845576.421" 
    capture_lex $P1694
    .const 'Sub' $P1486 = "93_1298845576.421" 
    capture_lex $P1486
    .lex "self", param_1465
    .lex "$/", param_1466
.annotate 'line', 584
    new $P1467, "Undef"
    .lex "$past", $P1467
.annotate 'line', 595
    new $P1468, "Undef"
    .lex "$block", $P1468
.annotate 'line', 581
    find_lex $P1469, "$past"
.annotate 'line', 585
    find_lex $P1471, "$/"
    unless_null $P1471, vivify_520
    $P1471 = root_new ['parrot';'Hash']
  vivify_520:
    set $P1472, $P1471["onlystar"]
    unless_null $P1472, vivify_521
    new $P1472, "Undef"
  vivify_521:
    if $P1472, if_1470
.annotate 'line', 589
    find_lex $P1474, "$/"
    unless_null $P1474, vivify_522
    $P1474 = root_new ['parrot';'Hash']
  vivify_522:
    set $P1475, $P1474["blockoid"]
    unless_null $P1475, vivify_523
    new $P1475, "Undef"
  vivify_523:
    $P1476 = $P1475."ast"()
    store_lex "$past", $P1476
.annotate 'line', 590
    find_lex $P1477, "$past"
    $P1477."blocktype"("declaration")
.annotate 'line', 591
    find_dynamic_lex $P1479, "$*RETURN_USED"
    unless_null $P1479, vivify_524
    get_hll_global $P1479, "$RETURN_USED"
    unless_null $P1479, vivify_525
    die "Contextual $*RETURN_USED not found"
  vivify_525:
  vivify_524:
    unless $P1479, if_1478_end
.annotate 'line', 592
    find_lex $P1480, "$past"
    $P1480."control"("return_pir")
  if_1478_end:
.annotate 'line', 588
    goto if_1470_end
  if_1470:
.annotate 'line', 586
    $P1473 = "only_star_block"()
    store_lex "$past", $P1473
  if_1470_end:
.annotate 'line', 595
    find_lex $P1481, "$past"
    store_lex "$block", $P1481
.annotate 'line', 597
    find_lex $P1483, "$/"
    unless_null $P1483, vivify_526
    $P1483 = root_new ['parrot';'Hash']
  vivify_526:
    set $P1484, $P1483["deflongname"]
    unless_null $P1484, vivify_527
    new $P1484, "Undef"
  vivify_527:
    unless $P1484, if_1482_end
    .const 'Sub' $P1486 = "93_1298845576.421" 
    capture_lex $P1486
    $P1486()
  if_1482_end:
.annotate 'line', 697
    find_lex $P1683, "$block"
    find_lex $P1684, "$past"
    unless_null $P1684, vivify_588
    $P1684 = root_new ['parrot';'Hash']
    store_lex "$past", $P1684
  vivify_588:
    set $P1684["block_past"], $P1683
.annotate 'line', 698
    find_lex $P1686, "$/"
    unless_null $P1686, vivify_589
    $P1686 = root_new ['parrot';'Hash']
  vivify_589:
    set $P1687, $P1686["trait"]
    unless_null $P1687, vivify_590
    new $P1687, "Undef"
  vivify_590:
    unless $P1687, if_1685_end
.annotate 'line', 699
    find_lex $P1689, "$/"
    unless_null $P1689, vivify_591
    $P1689 = root_new ['parrot';'Hash']
  vivify_591:
    set $P1690, $P1689["trait"]
    unless_null $P1690, vivify_592
    new $P1690, "Undef"
  vivify_592:
    defined $I1691, $P1690
    unless $I1691, for_undef_593
    iter $P1688, $P1690
    new $P1701, 'ExceptionHandler'
    set_label $P1701, loop1700_handler
    $P1701."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1701
  loop1700_test:
    unless $P1688, loop1700_done
    shift $P1692, $P1688
  loop1700_redo:
    .const 'Sub' $P1694 = "98_1298845576.421" 
    capture_lex $P1694
    $P1694($P1692)
  loop1700_next:
    goto loop1700_test
  loop1700_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1702, exception, 'type'
    eq $P1702, .CONTROL_LOOP_NEXT, loop1700_next
    eq $P1702, .CONTROL_LOOP_REDO, loop1700_redo
  loop1700_done:
    pop_eh 
  for_undef_593:
  if_1685_end:
.annotate 'line', 702
    find_lex $P1703, "$/"
    find_lex $P1704, "$past"
    $P1705 = $P1703."!make"($P1704)
.annotate 'line', 581
    .return ($P1705)
.end


.namespace ["NQP";"Actions"]
.sub "_block1485"  :anon :subid("93_1298845576.421") :outer("92_1298845576.421")
.annotate 'line', 597
    .const 'Sub' $P1609 = "97_1298845576.421" 
    capture_lex $P1609
    .const 'Sub' $P1520 = "94_1298845576.421" 
    capture_lex $P1520
.annotate 'line', 598
    new $P1487, "Undef"
    .lex "$name", $P1487
    find_lex $P1488, "$/"
    unless_null $P1488, vivify_528
    $P1488 = root_new ['parrot';'Hash']
  vivify_528:
    set $P1489, $P1488["sigil"]
    unless_null $P1489, vivify_529
    $P1489 = root_new ['parrot';'ResizablePMCArray']
  vivify_529:
    set $P1490, $P1489[0]
    unless_null $P1490, vivify_530
    new $P1490, "Undef"
  vivify_530:
    set $S1491, $P1490
    new $P1492, 'String'
    set $P1492, $S1491
    find_lex $P1493, "$/"
    unless_null $P1493, vivify_531
    $P1493 = root_new ['parrot';'Hash']
  vivify_531:
    set $P1494, $P1493["deflongname"]
    unless_null $P1494, vivify_532
    $P1494 = root_new ['parrot';'ResizablePMCArray']
  vivify_532:
    set $P1495, $P1494[0]
    unless_null $P1495, vivify_533
    new $P1495, "Undef"
  vivify_533:
    $S1496 = $P1495."ast"()
    concat $P1497, $P1492, $S1496
    store_lex "$name", $P1497
.annotate 'line', 599
    find_lex $P1498, "$past"
    find_lex $P1499, "$name"
    $P1498."name"($P1499)
.annotate 'line', 600
    find_dynamic_lex $P1506, "$*SCOPE"
    unless_null $P1506, vivify_534
    get_hll_global $P1506, "$SCOPE"
    unless_null $P1506, vivify_535
    die "Contextual $*SCOPE not found"
  vivify_535:
  vivify_534:
    set $S1507, $P1506
    iseq $I1508, $S1507, ""
    unless $I1508, unless_1505
    new $P1504, 'Integer'
    set $P1504, $I1508
    goto unless_1505_end
  unless_1505:
    find_dynamic_lex $P1509, "$*SCOPE"
    unless_null $P1509, vivify_536
    get_hll_global $P1509, "$SCOPE"
    unless_null $P1509, vivify_537
    die "Contextual $*SCOPE not found"
  vivify_537:
  vivify_536:
    set $S1510, $P1509
    iseq $I1511, $S1510, "my"
    new $P1504, 'Integer'
    set $P1504, $I1511
  unless_1505_end:
    unless $P1504, unless_1503
    set $P1502, $P1504
    goto unless_1503_end
  unless_1503:
    find_dynamic_lex $P1512, "$*SCOPE"
    unless_null $P1512, vivify_538
    get_hll_global $P1512, "$SCOPE"
    unless_null $P1512, vivify_539
    die "Contextual $*SCOPE not found"
  vivify_539:
  vivify_538:
    set $S1513, $P1512
    iseq $I1514, $S1513, "our"
    new $P1502, 'Integer'
    set $P1502, $I1514
  unless_1503_end:
    if $P1502, if_1501
.annotate 'line', 692
    find_lex $P1678, "$/"
    $P1679 = $P1678."CURSOR"()
    find_dynamic_lex $P1680, "$*SCOPE"
    unless_null $P1680, vivify_540
    get_hll_global $P1680, "$SCOPE"
    unless_null $P1680, vivify_541
    die "Contextual $*SCOPE not found"
  vivify_541:
  vivify_540:
    concat $P1681, $P1680, " scoped routines are not supported yet"
    $P1682 = $P1679."panic"($P1681)
.annotate 'line', 691
    set $P1500, $P1682
.annotate 'line', 600
    goto if_1501_end
  if_1501:
.annotate 'line', 601
    find_dynamic_lex $P1516, "$*MULTINESS"
    unless_null $P1516, vivify_542
    get_hll_global $P1516, "$MULTINESS"
    unless_null $P1516, vivify_543
    die "Contextual $*MULTINESS not found"
  vivify_543:
  vivify_542:
    set $S1517, $P1516
    iseq $I1518, $S1517, "multi"
    if $I1518, if_1515
.annotate 'line', 652
    find_dynamic_lex $P1605, "$*MULTINESS"
    unless_null $P1605, vivify_544
    get_hll_global $P1605, "$MULTINESS"
    unless_null $P1605, vivify_545
    die "Contextual $*MULTINESS not found"
  vivify_545:
  vivify_544:
    set $S1606, $P1605
    iseq $I1607, $S1606, "proto"
    if $I1607, if_1604
.annotate 'line', 671
    get_global $P1639, "@BLOCK"
    unless_null $P1639, vivify_546
    $P1639 = root_new ['parrot';'ResizablePMCArray']
  vivify_546:
    set $P1640, $P1639[0]
    unless_null $P1640, vivify_547
    $P1640 = root_new ['parrot';'ResizablePMCArray']
  vivify_547:
    set $P1641, $P1640[0]
    unless_null $P1641, vivify_548
    new $P1641, "Undef"
  vivify_548:
    get_hll_global $P1642, ["PAST"], "Var"
    find_lex $P1643, "$name"
    find_lex $P1644, "$past"
    $P1645 = $P1642."new"($P1643 :named("name"), 1 :named("isdecl"), $P1644 :named("viviself"), "lexical" :named("scope"))
    $P1641."push"($P1645)
.annotate 'line', 673
    get_global $P1646, "@BLOCK"
    unless_null $P1646, vivify_549
    $P1646 = root_new ['parrot';'ResizablePMCArray']
  vivify_549:
    set $P1647, $P1646[0]
    unless_null $P1647, vivify_550
    new $P1647, "Undef"
  vivify_550:
    find_lex $P1648, "$name"
    $P1647."symbol"($P1648, "lexical" :named("scope"))
.annotate 'line', 674
    find_dynamic_lex $P1650, "$*SCOPE"
    unless_null $P1650, vivify_551
    get_hll_global $P1650, "$SCOPE"
    unless_null $P1650, vivify_552
    die "Contextual $*SCOPE not found"
  vivify_552:
  vivify_551:
    set $S1651, $P1650
    iseq $I1652, $S1651, "our"
    unless $I1652, if_1649_end
.annotate 'line', 677
    get_global $P1653, "@BLOCK"
    unless_null $P1653, vivify_553
    $P1653 = root_new ['parrot';'ResizablePMCArray']
  vivify_553:
    set $P1654, $P1653[0]
    unless_null $P1654, vivify_554
    $P1654 = root_new ['parrot';'ResizablePMCArray']
  vivify_554:
    set $P1655, $P1654[0]
    unless_null $P1655, vivify_555
    new $P1655, "Undef"
  vivify_555:
    get_hll_global $P1656, ["PAST"], "Op"
.annotate 'line', 679
    get_hll_global $P1657, ["PAST"], "Var"
    find_lex $P1658, "$name"
    $P1659 = $P1657."new"($P1658 :named("name"), "package" :named("scope"))
.annotate 'line', 680
    get_hll_global $P1660, ["PAST"], "Var"
    find_lex $P1661, "$name"
    $P1662 = $P1660."new"($P1661 :named("name"), "lexical" :named("scope"))
    $P1663 = $P1656."new"($P1659, $P1662, "bind" :named("pasttype"))
.annotate 'line', 677
    $P1655."push"($P1663)
.annotate 'line', 682
    get_global $P1664, "@BLOCK"
    unless_null $P1664, vivify_556
    $P1664 = root_new ['parrot';'ResizablePMCArray']
  vivify_556:
    set $P1665, $P1664[0]
    unless_null $P1665, vivify_557
    new $P1665, "Undef"
  vivify_557:
    $P1666 = $P1665."loadinit"()
    get_hll_global $P1667, ["PAST"], "Op"
.annotate 'line', 684
    get_hll_global $P1668, ["PAST"], "Var"
    find_lex $P1669, "$name"
    $P1670 = $P1668."new"($P1669 :named("name"), "package" :named("scope"))
.annotate 'line', 685
    get_hll_global $P1671, ["PAST"], "Val"
    find_lex $P1672, "$past"
    $P1673 = $P1671."new"($P1672 :named("value"))
    $P1674 = $P1667."new"($P1670, $P1673, "bind" :named("pasttype"))
.annotate 'line', 682
    $P1666."push"($P1674)
  if_1649_end:
.annotate 'line', 670
    goto if_1604_end
  if_1604:
.annotate 'line', 652
    .const 'Sub' $P1609 = "97_1298845576.421" 
    capture_lex $P1609
    $P1609()
  if_1604_end:
    goto if_1515_end
  if_1515:
.annotate 'line', 601
    .const 'Sub' $P1520 = "94_1298845576.421" 
    capture_lex $P1520
    $P1520()
  if_1515_end:
.annotate 'line', 689
    get_hll_global $P1675, ["PAST"], "Var"
    find_lex $P1676, "$name"
    $P1677 = $P1675."new"($P1676 :named("name"))
    store_lex "$past", $P1677
.annotate 'line', 600
    set $P1500, $P1677
  if_1501_end:
.annotate 'line', 597
    .return ($P1500)
.end


.namespace ["NQP";"Actions"]
.sub "_block1608"  :anon :subid("97_1298845576.421") :outer("93_1298845576.421")
.annotate 'line', 657
    new $P1610, "Undef"
    .lex "$cholder", $P1610
.annotate 'line', 656
    find_dynamic_lex $P1612, "$*SCOPE"
    unless_null $P1612, vivify_558
    get_hll_global $P1612, "$SCOPE"
    unless_null $P1612, vivify_559
    die "Contextual $*SCOPE not found"
  vivify_559:
  vivify_558:
    set $S1613, $P1612
    iseq $I1614, $S1613, "our"
    unless $I1614, if_1611_end
    die "our-scoped protos not yet implemented"
  if_1611_end:
.annotate 'line', 657
    get_hll_global $P1615, ["PAST"], "Op"
    $P1616 = $P1615."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1616
.annotate 'line', 658
    get_global $P1617, "@BLOCK"
    unless_null $P1617, vivify_560
    $P1617 = root_new ['parrot';'ResizablePMCArray']
  vivify_560:
    set $P1618, $P1617[0]
    unless_null $P1618, vivify_561
    $P1618 = root_new ['parrot';'ResizablePMCArray']
  vivify_561:
    set $P1619, $P1618[0]
    unless_null $P1619, vivify_562
    new $P1619, "Undef"
  vivify_562:
    get_hll_global $P1620, ["PAST"], "Var"
    find_lex $P1621, "$name"
    find_lex $P1622, "$past"
    $P1623 = $P1620."new"($P1621 :named("name"), 1 :named("isdecl"), $P1622 :named("viviself"), "lexical" :named("scope"))
    $P1619."push"($P1623)
.annotate 'line', 660
    get_global $P1624, "@BLOCK"
    unless_null $P1624, vivify_563
    $P1624 = root_new ['parrot';'ResizablePMCArray']
  vivify_563:
    set $P1625, $P1624[0]
    unless_null $P1625, vivify_564
    $P1625 = root_new ['parrot';'ResizablePMCArray']
  vivify_564:
    set $P1626, $P1625[0]
    unless_null $P1626, vivify_565
    new $P1626, "Undef"
  vivify_565:
    get_hll_global $P1627, ["PAST"], "Op"
.annotate 'line', 662
    get_hll_global $P1628, ["PAST"], "Var"
    find_lex $P1629, "$name"
    $P1630 = $P1628."new"($P1629 :named("name"))
    find_lex $P1631, "$cholder"
    $P1632 = $P1627."new"($P1630, $P1631, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 660
    $P1626."push"($P1632)
.annotate 'line', 665
    get_global $P1633, "@BLOCK"
    unless_null $P1633, vivify_566
    $P1633 = root_new ['parrot';'ResizablePMCArray']
  vivify_566:
    set $P1634, $P1633[0]
    unless_null $P1634, vivify_567
    new $P1634, "Undef"
  vivify_567:
    find_lex $P1635, "$name"
    find_lex $P1636, "$cholder"
    $P1634."symbol"($P1635, "lexical" :named("scope"), 1 :named("proto"), $P1636 :named("cholder"))
.annotate 'line', 668
    find_lex $P1637, "$past"
    $P1638 = $P1637."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 652
    .return ($P1638)
.end


.namespace ["NQP";"Actions"]
.sub "_block1519"  :anon :subid("94_1298845576.421") :outer("93_1298845576.421")
.annotate 'line', 601
    .const 'Sub' $P1538 = "95_1298845576.421" 
    capture_lex $P1538
.annotate 'line', 604
    new $P1521, "Undef"
    .lex "$cholder", $P1521
.annotate 'line', 605
    $P1522 = root_new ['parrot';'Hash']
    .lex "%sym", $P1522
.annotate 'line', 603
    find_dynamic_lex $P1524, "$*SCOPE"
    unless_null $P1524, vivify_568
    get_hll_global $P1524, "$SCOPE"
    unless_null $P1524, vivify_569
    die "Contextual $*SCOPE not found"
  vivify_569:
  vivify_568:
    set $S1525, $P1524
    iseq $I1526, $S1525, "our"
    unless $I1526, if_1523_end
    die "our-scoped multis not yet implemented"
  if_1523_end:
    find_lex $P1527, "$cholder"
.annotate 'line', 605
    get_global $P1528, "@BLOCK"
    unless_null $P1528, vivify_570
    $P1528 = root_new ['parrot';'ResizablePMCArray']
  vivify_570:
    set $P1529, $P1528[0]
    unless_null $P1529, vivify_571
    new $P1529, "Undef"
  vivify_571:
    find_lex $P1530, "$name"
    $P1531 = $P1529."symbol"($P1530)
    store_lex "%sym", $P1531
.annotate 'line', 606
    find_lex $P1533, "%sym"
    unless_null $P1533, vivify_572
    $P1533 = root_new ['parrot';'Hash']
  vivify_572:
    set $P1534, $P1533["cholder"]
    unless_null $P1534, vivify_573
    new $P1534, "Undef"
  vivify_573:
    if $P1534, if_1532
.annotate 'line', 611
    .const 'Sub' $P1538 = "95_1298845576.421" 
    capture_lex $P1538
    $P1538()
    goto if_1532_end
  if_1532:
.annotate 'line', 607
    find_lex $P1535, "%sym"
    unless_null $P1535, vivify_586
    $P1535 = root_new ['parrot';'Hash']
  vivify_586:
    set $P1536, $P1535["cholder"]
    unless_null $P1536, vivify_587
    new $P1536, "Undef"
  vivify_587:
    store_lex "$cholder", $P1536
  if_1532_end:
.annotate 'line', 647
    find_lex $P1600, "$cholder"
    find_lex $P1601, "$past"
    $P1600."push"($P1601)
.annotate 'line', 650
    find_lex $P1602, "$past"
    $P1603 = "attach_multi_signature"($P1602)
.annotate 'line', 601
    .return ($P1603)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1537"  :anon :subid("95_1298845576.421") :outer("94_1298845576.421")
.annotate 'line', 611
    .const 'Sub' $P1552 = "96_1298845576.421" 
    capture_lex $P1552
.annotate 'line', 618
    new $P1539, "Undef"
    .lex "$found_proto", $P1539
.annotate 'line', 636
    new $P1540, "Undef"
    .lex "$dispatch_setup", $P1540
.annotate 'line', 613
    find_lex $P1542, "%sym"
    unless_null $P1542, vivify_574
    $P1542 = root_new ['parrot';'Hash']
  vivify_574:
    set $P1543, $P1542["proto"]
    unless_null $P1543, vivify_575
    new $P1543, "Undef"
  vivify_575:
    unless $P1543, if_1541_end
.annotate 'line', 616
    find_lex $P1544, "$/"
    $P1545 = $P1544."CURSOR"()
    $P1545."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1541_end:
.annotate 'line', 613
    find_lex $P1546, "$found_proto"
.annotate 'line', 619
    get_global $P1548, "@BLOCK"
    defined $I1549, $P1548
    unless $I1549, for_undef_576
    iter $P1547, $P1548
    new $P1574, 'ExceptionHandler'
    set_label $P1574, loop1573_handler
    $P1574."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1574
  loop1573_test:
    unless $P1547, loop1573_done
    shift $P1550, $P1547
  loop1573_redo:
    .const 'Sub' $P1552 = "96_1298845576.421" 
    capture_lex $P1552
    $P1552($P1550)
  loop1573_next:
    goto loop1573_test
  loop1573_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1575, exception, 'type'
    eq $P1575, .CONTROL_LOOP_NEXT, loop1573_next
    eq $P1575, .CONTROL_LOOP_REDO, loop1573_redo
  loop1573_done:
    pop_eh 
  for_undef_576:
.annotate 'line', 630
    find_lex $P1577, "$found_proto"
    if $P1577, unless_1576_end
.annotate 'line', 631
    find_lex $P1578, "$/"
    $P1579 = $P1578."CURSOR"()
    $P1579."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1576_end:
.annotate 'line', 635
    get_hll_global $P1580, ["PAST"], "Op"
    $P1581 = $P1580."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1581
.annotate 'line', 636
    get_hll_global $P1582, ["PAST"], "Op"
.annotate 'line', 638
    get_hll_global $P1583, ["PAST"], "Var"
    find_lex $P1584, "$name"
    $P1585 = $P1583."new"($P1584 :named("name"), "outer" :named("scope"))
    find_lex $P1586, "$cholder"
    $P1587 = $P1582."new"($P1585, $P1586, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 636
    store_lex "$dispatch_setup", $P1587
.annotate 'line', 641
    get_global $P1588, "@BLOCK"
    unless_null $P1588, vivify_581
    $P1588 = root_new ['parrot';'ResizablePMCArray']
  vivify_581:
    set $P1589, $P1588[0]
    unless_null $P1589, vivify_582
    $P1589 = root_new ['parrot';'ResizablePMCArray']
  vivify_582:
    set $P1590, $P1589[0]
    unless_null $P1590, vivify_583
    new $P1590, "Undef"
  vivify_583:
    get_hll_global $P1591, ["PAST"], "Var"
    find_lex $P1592, "$name"
    find_lex $P1593, "$dispatch_setup"
    $P1594 = $P1591."new"($P1592 :named("name"), 1 :named("isdecl"), $P1593 :named("viviself"), "lexical" :named("scope"))
    $P1590."push"($P1594)
.annotate 'line', 643
    get_global $P1595, "@BLOCK"
    unless_null $P1595, vivify_584
    $P1595 = root_new ['parrot';'ResizablePMCArray']
  vivify_584:
    set $P1596, $P1595[0]
    unless_null $P1596, vivify_585
    new $P1596, "Undef"
  vivify_585:
    find_lex $P1597, "$name"
    find_lex $P1598, "$cholder"
    $P1599 = $P1596."symbol"($P1597, "lexical" :named("scope"), $P1598 :named("cholder"))
.annotate 'line', 611
    .return ($P1599)
.end


.namespace ["NQP";"Actions"]
.sub "_block1551"  :anon :subid("96_1298845576.421") :outer("95_1298845576.421")
    .param pmc param_1554
.annotate 'line', 620
    $P1553 = root_new ['parrot';'Hash']
    .lex "%sym", $P1553
    .lex "$_", param_1554
    find_lex $P1555, "$_"
    find_lex $P1556, "$name"
    $P1557 = $P1555."symbol"($P1556)
    store_lex "%sym", $P1557
.annotate 'line', 621
    find_lex $P1562, "%sym"
    unless_null $P1562, vivify_577
    $P1562 = root_new ['parrot';'Hash']
  vivify_577:
    set $P1563, $P1562["proto"]
    unless_null $P1563, vivify_578
    new $P1563, "Undef"
  vivify_578:
    unless $P1563, unless_1561
    set $P1560, $P1563
    goto unless_1561_end
  unless_1561:
    find_lex $P1564, "%sym"
    unless_null $P1564, vivify_579
    $P1564 = root_new ['parrot';'Hash']
  vivify_579:
    set $P1565, $P1564["cholder"]
    unless_null $P1565, vivify_580
    new $P1565, "Undef"
  vivify_580:
    set $P1560, $P1565
  unless_1561_end:
    if $P1560, if_1559
.annotate 'line', 624
    find_lex $P1569, "%sym"
    if $P1569, if_1568
    set $P1567, $P1569
    goto if_1568_end
  if_1568:
.annotate 'line', 625
    find_lex $P1570, "$/"
    $P1571 = $P1570."CURSOR"()
    $P1572 = $P1571."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 624
    set $P1567, $P1572
  if_1568_end:
    set $P1558, $P1567
.annotate 'line', 621
    goto if_1559_end
  if_1559:
.annotate 'line', 622
    new $P1566, "Integer"
    assign $P1566, 1
    store_lex "$found_proto", $P1566
.annotate 'line', 621
    set $P1558, $P1566
  if_1559_end:
.annotate 'line', 619
    .return ($P1558)
.end


.namespace ["NQP";"Actions"]
.sub "_block1693"  :anon :subid("98_1298845576.421") :outer("92_1298845576.421")
    .param pmc param_1695
.annotate 'line', 699
    .lex "$_", param_1695
    find_lex $P1696, "$_"
    $P1697 = $P1696."ast"()
    find_lex $P1698, "$/"
    $P1699 = $P1697($P1698)
    .return ($P1699)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("99_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1707
    .param pmc param_1708
.annotate 'line', 706
    .const 'Sub' $P1820 = "101_1298845576.421" 
    capture_lex $P1820
    .const 'Sub' $P1736 = "100_1298845576.421" 
    capture_lex $P1736
    .lex "self", param_1707
    .lex "$/", param_1708
.annotate 'line', 709
    new $P1709, "Undef"
    .lex "$past", $P1709
.annotate 'line', 706
    find_lex $P1710, "$past"
.annotate 'line', 710
    find_lex $P1712, "$/"
    unless_null $P1712, vivify_594
    $P1712 = root_new ['parrot';'Hash']
  vivify_594:
    set $P1713, $P1712["onlystar"]
    unless_null $P1713, vivify_595
    new $P1713, "Undef"
  vivify_595:
    if $P1713, if_1711
.annotate 'line', 714
    find_lex $P1715, "$/"
    unless_null $P1715, vivify_596
    $P1715 = root_new ['parrot';'Hash']
  vivify_596:
    set $P1716, $P1715["blockoid"]
    unless_null $P1716, vivify_597
    new $P1716, "Undef"
  vivify_597:
    $P1717 = $P1716."ast"()
    store_lex "$past", $P1717
.annotate 'line', 715
    find_lex $P1718, "$past"
    $P1718."blocktype"("declaration")
.annotate 'line', 716
    find_dynamic_lex $P1720, "$*RETURN_USED"
    unless_null $P1720, vivify_598
    get_hll_global $P1720, "$RETURN_USED"
    unless_null $P1720, vivify_599
    die "Contextual $*RETURN_USED not found"
  vivify_599:
  vivify_598:
    unless $P1720, if_1719_end
.annotate 'line', 717
    find_lex $P1721, "$past"
    $P1721."control"("return_pir")
  if_1719_end:
.annotate 'line', 713
    goto if_1711_end
  if_1711:
.annotate 'line', 711
    $P1714 = "only_star_block"()
    store_lex "$past", $P1714
  if_1711_end:
.annotate 'line', 722
    find_lex $P1723, "$past"
    unless_null $P1723, vivify_600
    $P1723 = root_new ['parrot';'Hash']
  vivify_600:
    set $P1724, $P1723["signature_has_invocant"]
    unless_null $P1724, vivify_601
    new $P1724, "Undef"
  vivify_601:
    if $P1724, unless_1722_end
.annotate 'line', 723
    find_lex $P1725, "$past"
    unless_null $P1725, vivify_602
    $P1725 = root_new ['parrot';'ResizablePMCArray']
  vivify_602:
    set $P1726, $P1725[0]
    unless_null $P1726, vivify_603
    new $P1726, "Undef"
  vivify_603:
    get_hll_global $P1727, ["PAST"], "Var"
.annotate 'line', 725
    get_hll_global $P1728, ["PAST"], "Var"
    $P1729 = $P1728."new"("$?CLASS" :named("name"))
    $P1730 = $P1727."new"("self" :named("name"), "parameter" :named("scope"), $P1729 :named("multitype"))
.annotate 'line', 723
    $P1726."unshift"($P1730)
  unless_1722_end:
.annotate 'line', 728
    find_lex $P1731, "$past"
    $P1731."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 731
    find_lex $P1733, "$/"
    unless_null $P1733, vivify_604
    $P1733 = root_new ['parrot';'Hash']
  vivify_604:
    set $P1734, $P1733["deflongname"]
    unless_null $P1734, vivify_605
    new $P1734, "Undef"
  vivify_605:
    unless $P1734, if_1732_end
    .const 'Sub' $P1736 = "100_1298845576.421" 
    capture_lex $P1736
    $P1736()
  if_1732_end:
.annotate 'line', 766
    find_dynamic_lex $P1802, "$*SCOPE"
    unless_null $P1802, vivify_623
    get_hll_global $P1802, "$SCOPE"
    unless_null $P1802, vivify_624
    die "Contextual $*SCOPE not found"
  vivify_624:
  vivify_623:
    set $S1803, $P1802
    iseq $I1804, $S1803, "our"
    unless $I1804, if_1801_end
.annotate 'line', 767
    find_lex $P1805, "$past"
    $P1805."pirflags"(":nsentry")
  if_1801_end:
.annotate 'line', 771
    find_lex $P1806, "$/"
    find_lex $P1807, "$past"
    $P1806."!make"($P1807)
.annotate 'line', 772
    find_lex $P1808, "$past"
    find_lex $P1809, "$past"
    unless_null $P1809, vivify_625
    $P1809 = root_new ['parrot';'Hash']
    store_lex "$past", $P1809
  vivify_625:
    set $P1809["block_past"], $P1808
.annotate 'line', 773
    find_lex $P1812, "$/"
    unless_null $P1812, vivify_626
    $P1812 = root_new ['parrot';'Hash']
  vivify_626:
    set $P1813, $P1812["trait"]
    unless_null $P1813, vivify_627
    new $P1813, "Undef"
  vivify_627:
    if $P1813, if_1811
    set $P1810, $P1813
    goto if_1811_end
  if_1811:
.annotate 'line', 774
    find_lex $P1815, "$/"
    unless_null $P1815, vivify_628
    $P1815 = root_new ['parrot';'Hash']
  vivify_628:
    set $P1816, $P1815["trait"]
    unless_null $P1816, vivify_629
    new $P1816, "Undef"
  vivify_629:
    defined $I1817, $P1816
    unless $I1817, for_undef_630
    iter $P1814, $P1816
    new $P1827, 'ExceptionHandler'
    set_label $P1827, loop1826_handler
    $P1827."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1827
  loop1826_test:
    unless $P1814, loop1826_done
    shift $P1818, $P1814
  loop1826_redo:
    .const 'Sub' $P1820 = "101_1298845576.421" 
    capture_lex $P1820
    $P1820($P1818)
  loop1826_next:
    goto loop1826_test
  loop1826_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1828, exception, 'type'
    eq $P1828, .CONTROL_LOOP_NEXT, loop1826_next
    eq $P1828, .CONTROL_LOOP_REDO, loop1826_redo
  loop1826_done:
    pop_eh 
  for_undef_630:
.annotate 'line', 773
    set $P1810, $P1814
  if_1811_end:
.annotate 'line', 706
    .return ($P1810)
.end


.namespace ["NQP";"Actions"]
.sub "_block1735"  :anon :subid("100_1298845576.421") :outer("99_1298845576.421")
.annotate 'line', 733
    new $P1737, "Undef"
    .lex "$name", $P1737
.annotate 'line', 738
    new $P1738, "Undef"
    .lex "$to_add", $P1738
.annotate 'line', 733
    find_lex $P1739, "$/"
    unless_null $P1739, vivify_606
    $P1739 = root_new ['parrot';'Hash']
  vivify_606:
    set $P1740, $P1739["private"]
    unless_null $P1740, vivify_607
    new $P1740, "Undef"
  vivify_607:
    set $S1741, $P1740
    new $P1742, 'String'
    set $P1742, $S1741
    find_lex $P1743, "$/"
    unless_null $P1743, vivify_608
    $P1743 = root_new ['parrot';'Hash']
  vivify_608:
    set $P1744, $P1743["deflongname"]
    unless_null $P1744, vivify_609
    $P1744 = root_new ['parrot';'ResizablePMCArray']
  vivify_609:
    set $P1745, $P1744[0]
    unless_null $P1745, vivify_610
    new $P1745, "Undef"
  vivify_610:
    $P1746 = $P1745."ast"()
    set $S1747, $P1746
    concat $P1748, $P1742, $S1747
    store_lex "$name", $P1748
.annotate 'line', 734
    find_lex $P1749, "$past"
    find_lex $P1750, "$name"
    $P1749."name"($P1750)
.annotate 'line', 738
    find_dynamic_lex $P1753, "$*MULTINESS"
    unless_null $P1753, vivify_611
    get_hll_global $P1753, "$MULTINESS"
    unless_null $P1753, vivify_612
    die "Contextual $*MULTINESS not found"
  vivify_612:
  vivify_611:
    set $S1754, $P1753
    isne $I1755, $S1754, "proto"
    if $I1755, if_1752
.annotate 'line', 740
    get_hll_global $P1759, ["PAST"], "Op"
.annotate 'line', 742
    get_hll_global $P1760, ["PAST"], "Val"
    find_lex $P1761, "$past"
    $P1762 = $P1760."new"($P1761 :named("value"))
.annotate 'line', 743
    get_hll_global $P1763, ["PAST"], "Op"
    $P1764 = $P1763."new"("list" :named("pasttype"))
    $P1765 = $P1759."new"($P1762, $P1764, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 740
    set $P1751, $P1765
.annotate 'line', 738
    goto if_1752_end
  if_1752:
.annotate 'line', 739
    get_hll_global $P1756, ["PAST"], "Val"
    find_lex $P1757, "$past"
    $P1758 = $P1756."new"($P1757 :named("value"))
    set $P1751, $P1758
  if_1752_end:
.annotate 'line', 738
    store_lex "$to_add", $P1751
.annotate 'line', 745
    find_dynamic_lex $P1767, "$*MULTINESS"
    unless_null $P1767, vivify_613
    get_hll_global $P1767, "$MULTINESS"
    unless_null $P1767, vivify_614
    die "Contextual $*MULTINESS not found"
  vivify_614:
  vivify_613:
    set $S1768, $P1767
    iseq $I1769, $S1768, "proto"
    unless $I1769, if_1766_end
    find_lex $P1770, "$past"
    $P1770."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1766_end:
.annotate 'line', 749
    find_dynamic_lex $P1772, "$*MULTINESS"
    unless_null $P1772, vivify_615
    get_hll_global $P1772, "$MULTINESS"
    unless_null $P1772, vivify_616
    die "Contextual $*MULTINESS not found"
  vivify_616:
  vivify_615:
    set $S1773, $P1772
    iseq $I1774, $S1773, "multi"
    unless $I1774, if_1771_end
    find_lex $P1775, "$past"
    "attach_multi_signature"($P1775)
  if_1771_end:
.annotate 'line', 752
    find_dynamic_lex $P1778, "$*PACKAGE-SETUP"
    unless_null $P1778, vivify_617
    get_hll_global $P1778, "$PACKAGE-SETUP"
    unless_null $P1778, vivify_618
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_618:
  vivify_617:
    defined $I1779, $P1778
    if $I1779, if_1777
    new $P1776, 'Integer'
    set $P1776, $I1779
    goto if_1777_end
  if_1777:
.annotate 'line', 753
    find_dynamic_lex $P1780, "$*PACKAGE-SETUP"
    unless_null $P1780, vivify_619
    get_hll_global $P1780, "$PACKAGE-SETUP"
    unless_null $P1780, vivify_620
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_620:
  vivify_619:
    get_hll_global $P1781, ["PAST"], "Op"
.annotate 'line', 754
    find_dynamic_lex $P1784, "$*MULTINESS"
    unless_null $P1784, vivify_621
    get_hll_global $P1784, "$MULTINESS"
    unless_null $P1784, vivify_622
    die "Contextual $*MULTINESS not found"
  vivify_622:
  vivify_621:
    set $S1785, $P1784
    iseq $I1786, $S1785, "multi"
    if $I1786, if_1783
    new $P1788, "String"
    assign $P1788, "add_method"
    set $P1782, $P1788
    goto if_1783_end
  if_1783:
    new $P1787, "String"
    assign $P1787, "add_multi_method"
    set $P1782, $P1787
  if_1783_end:
.annotate 'line', 755
    get_hll_global $P1789, ["PAST"], "Op"
.annotate 'line', 758
    get_hll_global $P1790, ["PAST"], "Var"
    $P1791 = $P1790."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1792 = $P1789."new"($P1791, "get_how PP" :named("pirop"))
.annotate 'line', 760
    get_hll_global $P1793, ["PAST"], "Var"
    $P1794 = $P1793."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 761
    get_hll_global $P1795, ["PAST"], "Val"
    find_lex $P1796, "$name"
    $P1797 = $P1795."new"($P1796 :named("value"))
    find_lex $P1798, "$to_add"
    $P1799 = $P1781."new"($P1792, $P1794, $P1797, $P1798, "callmethod" :named("pasttype"), $P1782 :named("name"))
.annotate 'line', 753
    $P1800 = $P1780."push"($P1799)
.annotate 'line', 752
    set $P1776, $P1800
  if_1777_end:
.annotate 'line', 731
    .return ($P1776)
.end


.namespace ["NQP";"Actions"]
.sub "_block1819"  :anon :subid("101_1298845576.421") :outer("99_1298845576.421")
    .param pmc param_1821
.annotate 'line', 774
    .lex "$_", param_1821
    find_lex $P1822, "$_"
    $P1823 = $P1822."ast"()
    find_lex $P1824, "$/"
    $P1825 = $P1823($P1824)
    .return ($P1825)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("102_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1832
    .param pmc param_1833
.annotate 'line', 806
    .const 'Sub' $P1866 = "104_1298845576.421" 
    capture_lex $P1866
    .const 'Sub' $P1842 = "103_1298845576.421" 
    capture_lex $P1842
    .lex "self", param_1832
    .lex "$/", param_1833
.annotate 'line', 807
    new $P1834, "Undef"
    .lex "$BLOCKINIT", $P1834
    get_global $P1835, "@BLOCK"
    unless_null $P1835, vivify_631
    $P1835 = root_new ['parrot';'ResizablePMCArray']
  vivify_631:
    set $P1836, $P1835[0]
    unless_null $P1836, vivify_632
    $P1836 = root_new ['parrot';'ResizablePMCArray']
  vivify_632:
    set $P1837, $P1836[0]
    unless_null $P1837, vivify_633
    new $P1837, "Undef"
  vivify_633:
    store_lex "$BLOCKINIT", $P1837
.annotate 'line', 808
    find_lex $P1839, "$/"
    unless_null $P1839, vivify_634
    $P1839 = root_new ['parrot';'Hash']
  vivify_634:
    set $P1840, $P1839["invocant"]
    unless_null $P1840, vivify_635
    new $P1840, "Undef"
  vivify_635:
    unless $P1840, if_1838_end
    .const 'Sub' $P1842 = "103_1298845576.421" 
    capture_lex $P1842
    $P1842()
  if_1838_end:
.annotate 'line', 817
    find_lex $P1861, "$/"
    unless_null $P1861, vivify_641
    $P1861 = root_new ['parrot';'Hash']
  vivify_641:
    set $P1862, $P1861["parameter"]
    unless_null $P1862, vivify_642
    new $P1862, "Undef"
  vivify_642:
    defined $I1863, $P1862
    unless $I1863, for_undef_643
    iter $P1860, $P1862
    new $P1873, 'ExceptionHandler'
    set_label $P1873, loop1872_handler
    $P1873."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1873
  loop1872_test:
    unless $P1860, loop1872_done
    shift $P1864, $P1860
  loop1872_redo:
    .const 'Sub' $P1866 = "104_1298845576.421" 
    capture_lex $P1866
    $P1866($P1864)
  loop1872_next:
    goto loop1872_test
  loop1872_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1874, exception, 'type'
    eq $P1874, .CONTROL_LOOP_NEXT, loop1872_next
    eq $P1874, .CONTROL_LOOP_REDO, loop1872_redo
  loop1872_done:
    pop_eh 
  for_undef_643:
.annotate 'line', 806
    .return ($P1860)
.end


.namespace ["NQP";"Actions"]
.sub "_block1841"  :anon :subid("103_1298845576.421") :outer("102_1298845576.421")
.annotate 'line', 809
    new $P1843, "Undef"
    .lex "$inv", $P1843
    find_lex $P1844, "$/"
    unless_null $P1844, vivify_636
    $P1844 = root_new ['parrot';'Hash']
  vivify_636:
    set $P1845, $P1844["invocant"]
    unless_null $P1845, vivify_637
    $P1845 = root_new ['parrot';'ResizablePMCArray']
  vivify_637:
    set $P1846, $P1845[0]
    unless_null $P1846, vivify_638
    new $P1846, "Undef"
  vivify_638:
    $P1847 = $P1846."ast"()
    store_lex "$inv", $P1847
.annotate 'line', 810
    find_lex $P1848, "$BLOCKINIT"
    find_lex $P1849, "$inv"
    $P1848."push"($P1849)
.annotate 'line', 811
    find_lex $P1850, "$BLOCKINIT"
    get_hll_global $P1851, ["PAST"], "Var"
.annotate 'line', 813
    get_hll_global $P1852, ["PAST"], "Var"
    find_lex $P1853, "$inv"
    $P1854 = $P1853."name"()
    $P1855 = $P1852."new"("lexical" :named("scope"), $P1854 :named("name"))
    $P1856 = $P1851."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1855 :named("viviself"))
.annotate 'line', 811
    $P1850."push"($P1856)
.annotate 'line', 815
    new $P1857, "Integer"
    assign $P1857, 1
    get_global $P1858, "@BLOCK"
    unless_null $P1858, vivify_639
    $P1858 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1858
  vivify_639:
    set $P1859, $P1858[0]
    unless_null $P1859, vivify_640
    $P1859 = root_new ['parrot';'Hash']
    set $P1858[0], $P1859
  vivify_640:
    set $P1859["signature_has_invocant"], $P1857
.annotate 'line', 808
    .return ($P1857)
.end


.namespace ["NQP";"Actions"]
.sub "_block1865"  :anon :subid("104_1298845576.421") :outer("102_1298845576.421")
    .param pmc param_1867
.annotate 'line', 817
    .lex "$_", param_1867
    find_lex $P1868, "$BLOCKINIT"
    find_lex $P1869, "$_"
    $P1870 = $P1869."ast"()
    $P1871 = $P1868."push"($P1870)
    .return ($P1871)
.end


.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("105_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1876
    .param pmc param_1877
.annotate 'line', 820
    .lex "self", param_1876
    .lex "$/", param_1877
.annotate 'line', 821
    new $P1878, "Undef"
    .lex "$quant", $P1878
.annotate 'line', 822
    new $P1879, "Undef"
    .lex "$past", $P1879
.annotate 'line', 821
    find_lex $P1880, "$/"
    unless_null $P1880, vivify_644
    $P1880 = root_new ['parrot';'Hash']
  vivify_644:
    set $P1881, $P1880["quant"]
    unless_null $P1881, vivify_645
    new $P1881, "Undef"
  vivify_645:
    store_lex "$quant", $P1881
    find_lex $P1882, "$past"
.annotate 'line', 823
    find_lex $P1884, "$/"
    unless_null $P1884, vivify_646
    $P1884 = root_new ['parrot';'Hash']
  vivify_646:
    set $P1885, $P1884["named_param"]
    unless_null $P1885, vivify_647
    new $P1885, "Undef"
  vivify_647:
    if $P1885, if_1883
.annotate 'line', 830
    find_lex $P1899, "$/"
    unless_null $P1899, vivify_648
    $P1899 = root_new ['parrot';'Hash']
  vivify_648:
    set $P1900, $P1899["param_var"]
    unless_null $P1900, vivify_649
    new $P1900, "Undef"
  vivify_649:
    $P1901 = $P1900."ast"()
    store_lex "$past", $P1901
.annotate 'line', 831
    find_lex $P1903, "$quant"
    set $S1904, $P1903
    iseq $I1905, $S1904, "*"
    if $I1905, if_1902
.annotate 'line', 835
    find_lex $P1914, "$quant"
    set $S1915, $P1914
    iseq $I1916, $S1915, "?"
    unless $I1916, if_1913_end
.annotate 'line', 836
    find_lex $P1917, "$past"
    find_lex $P1918, "$/"
    unless_null $P1918, vivify_650
    $P1918 = root_new ['parrot';'Hash']
  vivify_650:
    set $P1919, $P1918["param_var"]
    unless_null $P1919, vivify_651
    $P1919 = root_new ['parrot';'Hash']
  vivify_651:
    set $P1920, $P1919["sigil"]
    unless_null $P1920, vivify_652
    new $P1920, "Undef"
  vivify_652:
    $P1921 = "vivitype"($P1920)
    $P1917."viviself"($P1921)
  if_1913_end:
.annotate 'line', 835
    goto if_1902_end
  if_1902:
.annotate 'line', 832
    find_lex $P1906, "$past"
    $P1906."slurpy"(1)
.annotate 'line', 833
    find_lex $P1907, "$past"
    find_lex $P1908, "$/"
    unless_null $P1908, vivify_653
    $P1908 = root_new ['parrot';'Hash']
  vivify_653:
    set $P1909, $P1908["param_var"]
    unless_null $P1909, vivify_654
    $P1909 = root_new ['parrot';'Hash']
  vivify_654:
    set $P1910, $P1909["sigil"]
    unless_null $P1910, vivify_655
    new $P1910, "Undef"
  vivify_655:
    set $S1911, $P1910
    iseq $I1912, $S1911, "%"
    $P1907."named"($I1912)
  if_1902_end:
.annotate 'line', 829
    goto if_1883_end
  if_1883:
.annotate 'line', 824
    find_lex $P1886, "$/"
    unless_null $P1886, vivify_656
    $P1886 = root_new ['parrot';'Hash']
  vivify_656:
    set $P1887, $P1886["named_param"]
    unless_null $P1887, vivify_657
    new $P1887, "Undef"
  vivify_657:
    $P1888 = $P1887."ast"()
    store_lex "$past", $P1888
.annotate 'line', 825
    find_lex $P1890, "$quant"
    set $S1891, $P1890
    isne $I1892, $S1891, "!"
    unless $I1892, if_1889_end
.annotate 'line', 826
    find_lex $P1893, "$past"
    find_lex $P1894, "$/"
    unless_null $P1894, vivify_658
    $P1894 = root_new ['parrot';'Hash']
  vivify_658:
    set $P1895, $P1894["named_param"]
    unless_null $P1895, vivify_659
    $P1895 = root_new ['parrot';'Hash']
  vivify_659:
    set $P1896, $P1895["param_var"]
    unless_null $P1896, vivify_660
    $P1896 = root_new ['parrot';'Hash']
  vivify_660:
    set $P1897, $P1896["sigil"]
    unless_null $P1897, vivify_661
    new $P1897, "Undef"
  vivify_661:
    $P1898 = "vivitype"($P1897)
    $P1893."viviself"($P1898)
  if_1889_end:
  if_1883_end:
.annotate 'line', 839
    find_lex $P1923, "$/"
    unless_null $P1923, vivify_662
    $P1923 = root_new ['parrot';'Hash']
  vivify_662:
    set $P1924, $P1923["default_value"]
    unless_null $P1924, vivify_663
    new $P1924, "Undef"
  vivify_663:
    unless $P1924, if_1922_end
.annotate 'line', 840
    find_lex $P1926, "$quant"
    set $S1927, $P1926
    iseq $I1928, $S1927, "*"
    unless $I1928, if_1925_end
.annotate 'line', 841
    find_lex $P1929, "$/"
    $P1930 = $P1929."CURSOR"()
    $P1930."panic"("Can't put default on slurpy parameter")
  if_1925_end:
.annotate 'line', 843
    find_lex $P1932, "$quant"
    set $S1933, $P1932
    iseq $I1934, $S1933, "!"
    unless $I1934, if_1931_end
.annotate 'line', 844
    find_lex $P1935, "$/"
    $P1936 = $P1935."CURSOR"()
    $P1936."panic"("Can't put default on required parameter")
  if_1931_end:
.annotate 'line', 846
    find_lex $P1937, "$past"
    find_lex $P1938, "$/"
    unless_null $P1938, vivify_664
    $P1938 = root_new ['parrot';'Hash']
  vivify_664:
    set $P1939, $P1938["default_value"]
    unless_null $P1939, vivify_665
    $P1939 = root_new ['parrot';'ResizablePMCArray']
  vivify_665:
    set $P1940, $P1939[0]
    unless_null $P1940, vivify_666
    $P1940 = root_new ['parrot';'Hash']
  vivify_666:
    set $P1941, $P1940["EXPR"]
    unless_null $P1941, vivify_667
    new $P1941, "Undef"
  vivify_667:
    $P1942 = $P1941."ast"()
    $P1937."viviself"($P1942)
  if_1922_end:
.annotate 'line', 848
    find_lex $P1944, "$past"
    $P1945 = $P1944."viviself"()
    if $P1945, unless_1943_end
    get_global $P1946, "@BLOCK"
    unless_null $P1946, vivify_668
    $P1946 = root_new ['parrot';'ResizablePMCArray']
  vivify_668:
    set $P1947, $P1946[0]
    unless_null $P1947, vivify_669
    new $P1947, "Undef"
  vivify_669:
    get_global $P1948, "@BLOCK"
    unless_null $P1948, vivify_670
    $P1948 = root_new ['parrot';'ResizablePMCArray']
  vivify_670:
    set $P1949, $P1948[0]
    unless_null $P1949, vivify_671
    new $P1949, "Undef"
  vivify_671:
    $P1950 = $P1949."arity"()
    set $N1951, $P1950
    new $P1952, 'Float'
    set $P1952, $N1951
    add $P1953, $P1952, 1
    $P1947."arity"($P1953)
  unless_1943_end:
.annotate 'line', 852
    find_lex $P1955, "$/"
    unless_null $P1955, vivify_672
    $P1955 = root_new ['parrot';'Hash']
  vivify_672:
    set $P1956, $P1955["typename"]
    unless_null $P1956, vivify_673
    new $P1956, "Undef"
  vivify_673:
    unless $P1956, if_1954_end
.annotate 'line', 853
    find_lex $P1957, "$past"
    find_lex $P1958, "$/"
    unless_null $P1958, vivify_674
    $P1958 = root_new ['parrot';'Hash']
  vivify_674:
    set $P1959, $P1958["typename"]
    unless_null $P1959, vivify_675
    $P1959 = root_new ['parrot';'ResizablePMCArray']
  vivify_675:
    set $P1960, $P1959[0]
    unless_null $P1960, vivify_676
    new $P1960, "Undef"
  vivify_676:
    $P1961 = $P1960."ast"()
    $P1957."multitype"($P1961)
  if_1954_end:
.annotate 'line', 857
    find_lex $P1963, "$/"
    unless_null $P1963, vivify_677
    $P1963 = root_new ['parrot';'Hash']
  vivify_677:
    set $P1964, $P1963["definedness"]
    unless_null $P1964, vivify_678
    new $P1964, "Undef"
  vivify_678:
    unless $P1964, if_1962_end
.annotate 'line', 858
    find_lex $P1965, "$/"
    unless_null $P1965, vivify_679
    $P1965 = root_new ['parrot';'Hash']
  vivify_679:
    set $P1966, $P1965["definedness"]
    unless_null $P1966, vivify_680
    $P1966 = root_new ['parrot';'ResizablePMCArray']
  vivify_680:
    set $P1967, $P1966[0]
    unless_null $P1967, vivify_681
    new $P1967, "Undef"
  vivify_681:
    set $S1968, $P1967
    new $P1969, 'String'
    set $P1969, $S1968
    find_lex $P1970, "$past"
    unless_null $P1970, vivify_682
    $P1970 = root_new ['parrot';'Hash']
    store_lex "$past", $P1970
  vivify_682:
    set $P1970["definedness"], $P1969
  if_1962_end:
.annotate 'line', 861
    find_lex $P1971, "$/"
    find_lex $P1972, "$past"
    $P1973 = $P1971."!make"($P1972)
.annotate 'line', 820
    .return ($P1973)
.end


.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("106_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1975
    .param pmc param_1976
.annotate 'line', 864
    .lex "self", param_1975
    .lex "$/", param_1976
.annotate 'line', 865
    new $P1977, "Undef"
    .lex "$name", $P1977
.annotate 'line', 866
    new $P1978, "Undef"
    .lex "$past", $P1978
.annotate 'line', 865
    find_lex $P1979, "$/"
    set $S1980, $P1979
    new $P1981, 'String'
    set $P1981, $S1980
    store_lex "$name", $P1981
.annotate 'line', 866
    get_hll_global $P1982, ["PAST"], "Var"
    find_lex $P1983, "$name"
    find_lex $P1984, "$/"
    $P1985 = $P1982."new"($P1983 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P1984 :named("node"))
    store_lex "$past", $P1985
.annotate 'line', 868
    get_global $P1986, "@BLOCK"
    unless_null $P1986, vivify_683
    $P1986 = root_new ['parrot';'ResizablePMCArray']
  vivify_683:
    set $P1987, $P1986[0]
    unless_null $P1987, vivify_684
    new $P1987, "Undef"
  vivify_684:
    find_lex $P1988, "$name"
    $P1987."symbol"($P1988, "lexical" :named("scope"))
.annotate 'line', 869
    find_lex $P1989, "$/"
    find_lex $P1990, "$past"
    $P1991 = $P1989."!make"($P1990)
.annotate 'line', 864
    .return ($P1991)
.end


.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("107_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_1993
    .param pmc param_1994
.annotate 'line', 872
    .lex "self", param_1993
    .lex "$/", param_1994
.annotate 'line', 873
    new $P1995, "Undef"
    .lex "$past", $P1995
    find_lex $P1996, "$/"
    unless_null $P1996, vivify_685
    $P1996 = root_new ['parrot';'Hash']
  vivify_685:
    set $P1997, $P1996["param_var"]
    unless_null $P1997, vivify_686
    new $P1997, "Undef"
  vivify_686:
    $P1998 = $P1997."ast"()
    store_lex "$past", $P1998
.annotate 'line', 874
    find_lex $P1999, "$past"
    find_lex $P2000, "$/"
    unless_null $P2000, vivify_687
    $P2000 = root_new ['parrot';'Hash']
  vivify_687:
    set $P2001, $P2000["param_var"]
    unless_null $P2001, vivify_688
    $P2001 = root_new ['parrot';'Hash']
  vivify_688:
    set $P2002, $P2001["name"]
    unless_null $P2002, vivify_689
    new $P2002, "Undef"
  vivify_689:
    set $S2003, $P2002
    $P1999."named"($S2003)
.annotate 'line', 875
    find_lex $P2004, "$/"
    find_lex $P2005, "$past"
    $P2006 = $P2004."!make"($P2005)
.annotate 'line', 872
    .return ($P2006)
.end


.namespace ["NQP";"Actions"]
.sub "typename"  :subid("108_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2008
    .param pmc param_2009
.annotate 'line', 878
    .lex "self", param_2008
    .lex "$/", param_2009
.annotate 'line', 879
    $P2010 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P2010
    get_hll_global $P2011, ["HLL"], "Compiler"
    find_lex $P2012, "$/"
    set $S2013, $P2012
    $P2014 = $P2011."parse_name"($S2013)
    store_lex "@name", $P2014
.annotate 'line', 880
    find_lex $P2015, "$/"
    get_hll_global $P2016, ["PAST"], "Var"
.annotate 'line', 881
    find_lex $P2017, "@name"
    $P2018 = $P2017."pop"()
    find_lex $P2019, "@name"
    $P2020 = $P2016."new"($P2018 :named("name"), $P2019 :named("namespace"), "package" :named("scope"))
.annotate 'line', 880
    $P2021 = $P2015."!make"($P2020)
.annotate 'line', 878
    .return ($P2021)
.end


.namespace ["NQP";"Actions"]
.sub "trait"  :subid("109_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2023
    .param pmc param_2024
.annotate 'line', 887
    .lex "self", param_2023
    .lex "$/", param_2024
.annotate 'line', 888
    find_lex $P2025, "$/"
    find_lex $P2026, "$/"
    unless_null $P2026, vivify_690
    $P2026 = root_new ['parrot';'Hash']
  vivify_690:
    set $P2027, $P2026["trait_mod"]
    unless_null $P2027, vivify_691
    new $P2027, "Undef"
  vivify_691:
    $P2028 = $P2027."ast"()
    $P2029 = $P2025."!make"($P2028)
.annotate 'line', 887
    .return ($P2029)
.end


.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("110_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2031
    .param pmc param_2032
.annotate 'line', 891
    .const 'Sub' $P2052 = "111_1298845576.421" 
    capture_lex $P2052
    .lex "self", param_2031
    .lex "$/", param_2032
.annotate 'line', 892
    new $P2033, "Undef"
    .lex "$cpast", $P2033
    find_lex $P2034, "$/"
    unless_null $P2034, vivify_692
    $P2034 = root_new ['parrot';'Hash']
  vivify_692:
    set $P2035, $P2034["circumfix"]
    unless_null $P2035, vivify_693
    $P2035 = root_new ['parrot';'ResizablePMCArray']
  vivify_693:
    set $P2036, $P2035[0]
    unless_null $P2036, vivify_694
    new $P2036, "Undef"
  vivify_694:
    $P2037 = $P2036."ast"()
    store_lex "$cpast", $P2037
.annotate 'line', 893
    find_lex $P2040, "$/"
    unless_null $P2040, vivify_695
    $P2040 = root_new ['parrot';'Hash']
  vivify_695:
    set $P2041, $P2040["longname"]
    unless_null $P2041, vivify_696
    new $P2041, "Undef"
  vivify_696:
    set $S2042, $P2041
    iseq $I2043, $S2042, "parrot_vtable"
    if $I2043, if_2039
.annotate 'line', 913
    find_lex $P2078, "$/"
    unless_null $P2078, vivify_697
    $P2078 = root_new ['parrot';'Hash']
  vivify_697:
    set $P2079, $P2078["longname"]
    unless_null $P2079, vivify_698
    new $P2079, "Undef"
  vivify_698:
    set $S2080, $P2079
    iseq $I2081, $S2080, "pirflags"
    if $I2081, if_2077
.annotate 'line', 917
    find_lex $P2085, "$/"
    $P2086 = $P2085."CURSOR"()
    new $P2087, 'String'
    set $P2087, "Trait '"
    find_lex $P2088, "$/"
    unless_null $P2088, vivify_699
    $P2088 = root_new ['parrot';'Hash']
  vivify_699:
    set $P2089, $P2088["longname"]
    unless_null $P2089, vivify_700
    new $P2089, "Undef"
  vivify_700:
    concat $P2090, $P2087, $P2089
    concat $P2091, $P2090, "' not implemented"
    $P2092 = $P2086."panic"($P2091)
.annotate 'line', 916
    set $P2076, $P2092
.annotate 'line', 913
    goto if_2077_end
  if_2077:
.annotate 'line', 914
    find_lex $P2082, "$/"
    $P2083 = $P2082."CURSOR"()
    $P2084 = $P2083."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 913
    set $P2076, $P2084
  if_2077_end:
    set $P2038, $P2076
.annotate 'line', 893
    goto if_2039_end
  if_2039:
.annotate 'line', 896
    get_hll_global $P2045, ["PAST"], "Val"
    find_lex $P2046, "$cpast"
    $P2047 = $P2045."ACCEPTS"($P2046)
    if $P2047, unless_2044_end
.annotate 'line', 895
    find_lex $P2048, "$/"
    $P2049 = $P2048."CURSOR"()
    $P2049."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2044_end:
.annotate 'line', 897
    find_lex $P2050, "$/"
    .const 'Sub' $P2052 = "111_1298845576.421" 
    newclosure $P2074, $P2052
    $P2075 = $P2050."!make"($P2074)
.annotate 'line', 893
    set $P2038, $P2075
  if_2039_end:
.annotate 'line', 891
    .return ($P2038)
.end


.namespace ["NQP";"Actions"]
.sub "_block2051"  :anon :subid("111_1298845576.421") :outer("110_1298845576.421")
    .param pmc param_2053
.annotate 'line', 897
    .lex "$match", param_2053
.annotate 'line', 898
    new $P2054, "Undef"
    .lex "$meth", $P2054
    find_lex $P2055, "$match"
    $P2056 = $P2055."ast"()
    set $P2057, $P2056["block_past"]
    unless_null $P2057, vivify_701
    new $P2057, "Undef"
  vivify_701:
    store_lex "$meth", $P2057
.annotate 'line', 899
    find_dynamic_lex $P2060, "$*PACKAGE-SETUP"
    unless_null $P2060, vivify_702
    get_hll_global $P2060, "$PACKAGE-SETUP"
    unless_null $P2060, vivify_703
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_703:
  vivify_702:
    defined $I2061, $P2060
    if $I2061, if_2059
    new $P2058, 'Integer'
    set $P2058, $I2061
    goto if_2059_end
  if_2059:
.annotate 'line', 900
    find_dynamic_lex $P2062, "$*PACKAGE-SETUP"
    unless_null $P2062, vivify_704
    get_hll_global $P2062, "$PACKAGE-SETUP"
    unless_null $P2062, vivify_705
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_705:
  vivify_704:
    get_hll_global $P2063, ["PAST"], "Op"
.annotate 'line', 902
    get_hll_global $P2064, ["PAST"], "Op"
.annotate 'line', 905
    get_hll_global $P2065, ["PAST"], "Var"
    $P2066 = $P2065."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2067 = $P2064."new"($P2066, "get_how PP" :named("pirop"))
.annotate 'line', 907
    get_hll_global $P2068, ["PAST"], "Var"
    $P2069 = $P2068."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2070, "$cpast"
    find_lex $P2071, "$meth"
    $P2072 = $P2063."new"($P2067, $P2069, $P2070, $P2071, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 900
    $P2073 = $P2062."push"($P2072)
.annotate 'line', 899
    set $P2058, $P2073
  if_2059_end:
.annotate 'line', 897
    .return ($P2058)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("112_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2096
    .param pmc param_2097
    .param pmc param_2098 :optional
    .param int has_param_2098 :opt_flag
.annotate 'line', 921
    .const 'Sub' $P2196 = "115_1298845576.421" 
    capture_lex $P2196
    .const 'Sub' $P2168 = "114_1298845576.421" 
    capture_lex $P2168
    .const 'Sub' $P2141 = "113_1298845576.421" 
    capture_lex $P2141
    new $P2095, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2095, control_2094
    push_eh $P2095
    .lex "self", param_2096
    .lex "$/", param_2097
    if has_param_2098, optparam_706
    new $P2099, "Undef"
    set param_2098, $P2099
  optparam_706:
    .lex "$key", param_2098
.annotate 'line', 922
    $P2100 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2100
.annotate 'line', 925
    new $P2101, "Undef"
    .lex "$name", $P2101
.annotate 'line', 926
    new $P2102, "Undef"
    .lex "$past", $P2102
.annotate 'line', 922

        $P2103 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2103
.annotate 'line', 925
    find_lex $P2104, "$/"
    unless_null $P2104, vivify_707
    $P2104 = root_new ['parrot';'Hash']
  vivify_707:
    set $P2105, $P2104["deflongname"]
    unless_null $P2105, vivify_708
    new $P2105, "Undef"
  vivify_708:
    $P2106 = $P2105."ast"()
    set $S2107, $P2106
    new $P2108, 'String'
    set $P2108, $S2107
    store_lex "$name", $P2108
    find_lex $P2109, "$past"
.annotate 'line', 927
    find_lex $P2111, "$/"
    unless_null $P2111, vivify_709
    $P2111 = root_new ['parrot';'Hash']
  vivify_709:
    set $P2112, $P2111["proto"]
    unless_null $P2112, vivify_710
    new $P2112, "Undef"
  vivify_710:
    if $P2112, if_2110
.annotate 'line', 966
    find_lex $P2164, "$key"
    set $S2165, $P2164
    iseq $I2166, $S2165, "open"
    if $I2166, if_2163
.annotate 'line', 979
    .const 'Sub' $P2196 = "115_1298845576.421" 
    capture_lex $P2196
    $P2196()
    goto if_2163_end
  if_2163:
.annotate 'line', 966
    .const 'Sub' $P2168 = "114_1298845576.421" 
    capture_lex $P2168
    $P2168()
  if_2163_end:
    goto if_2110_end
  if_2110:
.annotate 'line', 929
    get_hll_global $P2113, ["PAST"], "Stmts"
.annotate 'line', 930
    get_hll_global $P2114, ["PAST"], "Block"
    find_lex $P2115, "$name"
.annotate 'line', 931
    get_hll_global $P2116, ["PAST"], "Op"
.annotate 'line', 932
    get_hll_global $P2117, ["PAST"], "Var"
    $P2118 = $P2117."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2119, "$name"
    $P2120 = $P2116."new"($P2118, $P2119, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 931
    find_lex $P2121, "$/"
    $P2122 = $P2114."new"($P2120, $P2115 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2121 :named("node"))
.annotate 'line', 941
    get_hll_global $P2123, ["PAST"], "Block"
    new $P2124, "String"
    assign $P2124, "!PREFIX__"
    find_lex $P2125, "$name"
    concat $P2126, $P2124, $P2125
.annotate 'line', 942
    get_hll_global $P2127, ["PAST"], "Op"
.annotate 'line', 943
    get_hll_global $P2128, ["PAST"], "Var"
    $P2129 = $P2128."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2130, "$name"
    $P2131 = $P2127."new"($P2129, $P2130, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 942
    find_lex $P2132, "$/"
    $P2133 = $P2123."new"($P2131, $P2126 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2132 :named("node"))
.annotate 'line', 941
    $P2134 = $P2113."new"($P2122, $P2133)
.annotate 'line', 929
    store_lex "$past", $P2134
.annotate 'line', 953
    find_lex $P2136, "$past"
    $P2137 = $P2136."list"()
    defined $I2138, $P2137
    unless $I2138, for_undef_731
    iter $P2135, $P2137
    new $P2161, 'ExceptionHandler'
    set_label $P2161, loop2160_handler
    $P2161."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2161
  loop2160_test:
    unless $P2135, loop2160_done
    shift $P2139, $P2135
  loop2160_redo:
    .const 'Sub' $P2141 = "113_1298845576.421" 
    capture_lex $P2141
    $P2141($P2139)
  loop2160_next:
    goto loop2160_test
  loop2160_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2162, exception, 'type'
    eq $P2162, .CONTROL_LOOP_NEXT, loop2160_next
    eq $P2162, .CONTROL_LOOP_REDO, loop2160_redo
  loop2160_done:
    pop_eh 
  for_undef_731:
  if_2110_end:
.annotate 'line', 1015
    find_lex $P2254, "$/"
    find_lex $P2255, "$past"
    $P2256 = $P2254."!make"($P2255)
.annotate 'line', 921
    .return ($P2256)
  control_2094:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2257, exception, "payload"
    .return ($P2257)
.end


.namespace ["NQP";"Actions"]
.sub "_block2195"  :anon :subid("115_1298845576.421") :outer("112_1298845576.421")
.annotate 'line', 980
    new $P2197, "Undef"
    .lex "$regex", $P2197
.annotate 'line', 981
    get_hll_global $P2198, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2199, "$/"
    unless_null $P2199, vivify_711
    $P2199 = root_new ['parrot';'Hash']
  vivify_711:
    set $P2200, $P2199["p6regex"]
    unless_null $P2200, vivify_712
    new $P2200, "Undef"
  vivify_712:
    $P2201 = $P2200."ast"()
    get_global $P2202, "@BLOCK"
    $P2203 = $P2202."shift"()
    $P2204 = $P2198($P2201, $P2203)
    store_lex "$regex", $P2204
.annotate 'line', 982
    find_lex $P2205, "$regex"
    find_lex $P2206, "$name"
    $P2205."name"($P2206)
.annotate 'line', 984
    get_hll_global $P2207, ["PAST"], "Op"
.annotate 'line', 986
    get_hll_global $P2208, ["PAST"], "Var"
    new $P2209, "ResizablePMCArray"
    push $P2209, "Regex"
    $P2210 = $P2208."new"("Method" :named("name"), $P2209 :named("namespace"), "package" :named("scope"))
    find_lex $P2211, "$regex"
    $P2212 = $P2207."new"($P2210, $P2211, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 984
    store_lex "$past", $P2212
.annotate 'line', 989
    find_dynamic_lex $P2214, "$*PACKAGE-SETUP"
    unless_null $P2214, vivify_713
    get_hll_global $P2214, "$PACKAGE-SETUP"
    unless_null $P2214, vivify_714
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_714:
  vivify_713:
    defined $I2215, $P2214
    unless $I2215, if_2213_end
.annotate 'line', 990
    find_dynamic_lex $P2216, "$*PACKAGE-SETUP"
    unless_null $P2216, vivify_715
    get_hll_global $P2216, "$PACKAGE-SETUP"
    unless_null $P2216, vivify_716
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_716:
  vivify_715:
    get_hll_global $P2217, ["PAST"], "Op"
.annotate 'line', 992
    get_hll_global $P2218, ["PAST"], "Op"
.annotate 'line', 994
    get_hll_global $P2219, ["PAST"], "Var"
    $P2220 = $P2219."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2221 = $P2218."new"($P2220, "get_how PP" :named("pirop"))
.annotate 'line', 996
    get_hll_global $P2222, ["PAST"], "Var"
    $P2223 = $P2222."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 997
    get_hll_global $P2224, ["PAST"], "Val"
    find_lex $P2225, "$name"
    $P2226 = $P2224."new"($P2225 :named("value"))
.annotate 'line', 998
    get_hll_global $P2227, ["PAST"], "Val"
    find_lex $P2228, "$regex"
    $P2229 = $P2227."new"($P2228 :named("value"))
    $P2230 = $P2217."new"($P2221, $P2223, $P2226, $P2229, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 990
    $P2216."push"($P2230)
.annotate 'line', 1000
    find_dynamic_lex $P2231, "$*PACKAGE-SETUP"
    unless_null $P2231, vivify_717
    get_hll_global $P2231, "$PACKAGE-SETUP"
    unless_null $P2231, vivify_718
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_718:
  vivify_717:
    get_hll_global $P2232, ["PAST"], "Op"
.annotate 'line', 1002
    get_hll_global $P2233, ["PAST"], "Op"
.annotate 'line', 1004
    get_hll_global $P2234, ["PAST"], "Var"
    $P2235 = $P2234."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2236 = $P2233."new"($P2235, "get_how PP" :named("pirop"))
.annotate 'line', 1006
    get_hll_global $P2237, ["PAST"], "Var"
    $P2238 = $P2237."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1007
    get_hll_global $P2239, ["PAST"], "Val"
    new $P2240, "String"
    assign $P2240, "!PREFIX__"
    find_lex $P2241, "$name"
    concat $P2242, $P2240, $P2241
    $P2243 = $P2239."new"($P2242 :named("value"))
.annotate 'line', 1008
    get_hll_global $P2244, ["PAST"], "Var"
    new $P2245, "String"
    assign $P2245, "!PREFIX__"
    find_lex $P2246, "$name"
    concat $P2247, $P2245, $P2246
    $P2248 = $P2244."new"($P2247 :named("name"), "package" :named("scope"))
    $P2249 = $P2232."new"($P2236, $P2238, $P2243, $P2248, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1000
    $P2231."push"($P2249)
  if_2213_end:
.annotate 'line', 1012
    find_lex $P2250, "$regex"
    find_lex $P2251, "$past"
    unless_null $P2251, vivify_719
    $P2251 = root_new ['parrot';'Hash']
    store_lex "$past", $P2251
  vivify_719:
    set $P2251["sink"], $P2250
.annotate 'line', 1013
    find_lex $P2252, "@MODIFIERS"
    $P2253 = $P2252."shift"()
.annotate 'line', 979
    .return ($P2253)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2167"  :anon :subid("114_1298845576.421") :outer("112_1298845576.421")
.annotate 'line', 967
    $P2169 = root_new ['parrot';'Hash']
    .lex "%h", $P2169
.annotate 'line', 966
    find_lex $P2170, "%h"
.annotate 'line', 968
    find_lex $P2172, "$/"
    unless_null $P2172, vivify_720
    $P2172 = root_new ['parrot';'Hash']
  vivify_720:
    set $P2173, $P2172["sym"]
    unless_null $P2173, vivify_721
    new $P2173, "Undef"
  vivify_721:
    set $S2174, $P2173
    iseq $I2175, $S2174, "token"
    unless $I2175, if_2171_end
    new $P2176, "Integer"
    assign $P2176, 1
    find_lex $P2177, "%h"
    unless_null $P2177, vivify_722
    $P2177 = root_new ['parrot';'Hash']
    store_lex "%h", $P2177
  vivify_722:
    set $P2177["r"], $P2176
  if_2171_end:
.annotate 'line', 969
    find_lex $P2179, "$/"
    unless_null $P2179, vivify_723
    $P2179 = root_new ['parrot';'Hash']
  vivify_723:
    set $P2180, $P2179["sym"]
    unless_null $P2180, vivify_724
    new $P2180, "Undef"
  vivify_724:
    set $S2181, $P2180
    iseq $I2182, $S2181, "rule"
    unless $I2182, if_2178_end
    new $P2183, "Integer"
    assign $P2183, 1
    find_lex $P2184, "%h"
    unless_null $P2184, vivify_725
    $P2184 = root_new ['parrot';'Hash']
    store_lex "%h", $P2184
  vivify_725:
    set $P2184["r"], $P2183
    new $P2185, "Integer"
    assign $P2185, 1
    find_lex $P2186, "%h"
    unless_null $P2186, vivify_726
    $P2186 = root_new ['parrot';'Hash']
    store_lex "%h", $P2186
  vivify_726:
    set $P2186["s"], $P2185
  if_2178_end:
.annotate 'line', 970
    find_lex $P2187, "@MODIFIERS"
    find_lex $P2188, "%h"
    $P2187."unshift"($P2188)
.annotate 'line', 971

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 975
    get_global $P2189, "@BLOCK"
    unless_null $P2189, vivify_727
    $P2189 = root_new ['parrot';'ResizablePMCArray']
  vivify_727:
    set $P2190, $P2189[0]
    unless_null $P2190, vivify_728
    new $P2190, "Undef"
  vivify_728:
    $P2190."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 976
    get_global $P2191, "@BLOCK"
    unless_null $P2191, vivify_729
    $P2191 = root_new ['parrot';'ResizablePMCArray']
  vivify_729:
    set $P2192, $P2191[0]
    unless_null $P2192, vivify_730
    new $P2192, "Undef"
  vivify_730:
    $P2192."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 977
    new $P2193, "Exception"
    set $P2193['type'], .CONTROL_RETURN
    new $P2194, "Integer"
    assign $P2194, 0
    setattribute $P2193, 'payload', $P2194
    throw $P2193
.annotate 'line', 966
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "_block2140"  :anon :subid("113_1298845576.421") :outer("112_1298845576.421")
    .param pmc param_2142
.annotate 'line', 953
    .lex "$_", param_2142
.annotate 'line', 954
    find_dynamic_lex $P2143, "$*PACKAGE-SETUP"
    unless_null $P2143, vivify_732
    get_hll_global $P2143, "$PACKAGE-SETUP"
    unless_null $P2143, vivify_733
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_733:
  vivify_732:
    get_hll_global $P2144, ["PAST"], "Op"
.annotate 'line', 956
    get_hll_global $P2145, ["PAST"], "Op"
.annotate 'line', 958
    get_hll_global $P2146, ["PAST"], "Var"
    $P2147 = $P2146."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2148 = $P2145."new"($P2147, "get_how PP" :named("pirop"))
.annotate 'line', 960
    get_hll_global $P2149, ["PAST"], "Var"
    $P2150 = $P2149."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 961
    get_hll_global $P2151, ["PAST"], "Val"
    find_lex $P2152, "$_"
    $P2153 = $P2152."name"()
    $P2154 = $P2151."new"($P2153 :named("value"))
.annotate 'line', 962
    get_hll_global $P2155, ["PAST"], "Val"
    find_lex $P2156, "$_"
    $P2157 = $P2155."new"($P2156 :named("value"))
    $P2158 = $P2144."new"($P2148, $P2150, $P2154, $P2157, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 954
    $P2159 = $P2143."push"($P2158)
.annotate 'line', 953
    .return ($P2159)
.end


.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("116_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2259
    .param pmc param_2260
.annotate 'line', 1019
    .lex "self", param_2259
    .lex "$/", param_2260
.annotate 'line', 1020
    new $P2261, "Undef"
    .lex "$past", $P2261
    find_lex $P2264, "$/"
    unless_null $P2264, vivify_734
    $P2264 = root_new ['parrot';'Hash']
  vivify_734:
    set $P2265, $P2264["args"]
    unless_null $P2265, vivify_735
    new $P2265, "Undef"
  vivify_735:
    if $P2265, if_2263
    get_hll_global $P2270, ["PAST"], "Op"
    find_lex $P2271, "$/"
    $P2272 = $P2270."new"($P2271 :named("node"))
    set $P2262, $P2272
    goto if_2263_end
  if_2263:
    find_lex $P2266, "$/"
    unless_null $P2266, vivify_736
    $P2266 = root_new ['parrot';'Hash']
  vivify_736:
    set $P2267, $P2266["args"]
    unless_null $P2267, vivify_737
    $P2267 = root_new ['parrot';'ResizablePMCArray']
  vivify_737:
    set $P2268, $P2267[0]
    unless_null $P2268, vivify_738
    new $P2268, "Undef"
  vivify_738:
    $P2269 = $P2268."ast"()
    set $P2262, $P2269
  if_2263_end:
    store_lex "$past", $P2262
.annotate 'line', 1021
    find_lex $P2274, "$/"
    unless_null $P2274, vivify_739
    $P2274 = root_new ['parrot';'Hash']
  vivify_739:
    set $P2275, $P2274["quote"]
    unless_null $P2275, vivify_740
    new $P2275, "Undef"
  vivify_740:
    if $P2275, if_2273
.annotate 'line', 1025
    find_lex $P2282, "$/"
    unless_null $P2282, vivify_741
    $P2282 = root_new ['parrot';'Hash']
  vivify_741:
    set $P2283, $P2282["longname"]
    unless_null $P2283, vivify_742
    new $P2283, "Undef"
  vivify_742:
    set $S2284, $P2283
    iseq $I2285, $S2284, "HOW"
    if $I2285, if_2281
.annotate 'line', 1029
    find_lex $P2289, "$/"
    unless_null $P2289, vivify_743
    $P2289 = root_new ['parrot';'Hash']
  vivify_743:
    set $P2290, $P2289["longname"]
    unless_null $P2290, vivify_744
    new $P2290, "Undef"
  vivify_744:
    set $S2291, $P2290
    iseq $I2292, $S2291, "WHAT"
    if $I2292, if_2288
.annotate 'line', 1033
    find_lex $P2294, "$past"
    find_lex $P2295, "$/"
    unless_null $P2295, vivify_745
    $P2295 = root_new ['parrot';'Hash']
  vivify_745:
    set $P2296, $P2295["longname"]
    unless_null $P2296, vivify_746
    new $P2296, "Undef"
  vivify_746:
    set $S2297, $P2296
    $P2294."name"($S2297)
.annotate 'line', 1034
    find_lex $P2298, "$past"
    $P2298."pasttype"("callmethod")
.annotate 'line', 1032
    goto if_2288_end
  if_2288:
.annotate 'line', 1030
    find_lex $P2293, "$past"
    $P2293."pirop"("get_what PP")
  if_2288_end:
.annotate 'line', 1029
    goto if_2281_end
  if_2281:
.annotate 'line', 1026
    find_lex $P2286, "$past"
    $P2286."pirop"("get_how PP")
.annotate 'line', 1027
    find_lex $P2287, "$past"
    $P2287."pasttype"("pirop")
  if_2281_end:
.annotate 'line', 1025
    goto if_2273_end
  if_2273:
.annotate 'line', 1022
    find_lex $P2276, "$past"
    find_lex $P2277, "$/"
    unless_null $P2277, vivify_747
    $P2277 = root_new ['parrot';'Hash']
  vivify_747:
    set $P2278, $P2277["quote"]
    unless_null $P2278, vivify_748
    new $P2278, "Undef"
  vivify_748:
    $P2279 = $P2278."ast"()
    $P2276."name"($P2279)
.annotate 'line', 1023
    find_lex $P2280, "$past"
    $P2280."pasttype"("callmethod")
  if_2273_end:
.annotate 'line', 1036
    find_lex $P2299, "$/"
    find_lex $P2300, "$past"
    $P2301 = $P2299."!make"($P2300)
.annotate 'line', 1019
    .return ($P2301)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("117_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2303
    .param pmc param_2304
.annotate 'line', 1041
    .lex "self", param_2303
    .lex "$/", param_2304
.annotate 'line', 1042
    find_lex $P2305, "$/"
    get_hll_global $P2306, ["PAST"], "Var"
    $P2307 = $P2306."new"("self" :named("name"))
    $P2308 = $P2305."!make"($P2307)
.annotate 'line', 1041
    .return ($P2308)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("118_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2310
    .param pmc param_2311
.annotate 'line', 1045
    .lex "self", param_2310
    .lex "$/", param_2311
.annotate 'line', 1046
    new $P2312, "Undef"
    .lex "$past", $P2312
    find_lex $P2313, "$/"
    unless_null $P2313, vivify_749
    $P2313 = root_new ['parrot';'Hash']
  vivify_749:
    set $P2314, $P2313["args"]
    unless_null $P2314, vivify_750
    new $P2314, "Undef"
  vivify_750:
    $P2315 = $P2314."ast"()
    store_lex "$past", $P2315
.annotate 'line', 1047
    find_lex $P2316, "$past"
    find_lex $P2317, "$/"
    unless_null $P2317, vivify_751
    $P2317 = root_new ['parrot';'Hash']
  vivify_751:
    set $P2318, $P2317["deflongname"]
    unless_null $P2318, vivify_752
    new $P2318, "Undef"
  vivify_752:
    set $S2319, $P2318
    $P2316."name"($S2319)
.annotate 'line', 1048
    find_lex $P2320, "$/"
    find_lex $P2321, "$past"
    $P2322 = $P2320."!make"($P2321)
.annotate 'line', 1045
    .return ($P2322)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("119_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2324
    .param pmc param_2325
.annotate 'line', 1051
    .lex "self", param_2324
    .lex "$/", param_2325
.annotate 'line', 1052
    $P2326 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2326
.annotate 'line', 1053
    new $P2327, "Undef"
    .lex "$name", $P2327
.annotate 'line', 1055
    new $P2328, "Undef"
    .lex "$var", $P2328
.annotate 'line', 1057
    new $P2329, "Undef"
    .lex "$past", $P2329
.annotate 'line', 1052
    find_lex $P2330, "$/"
    unless_null $P2330, vivify_753
    $P2330 = root_new ['parrot';'Hash']
  vivify_753:
    set $P2331, $P2330["name"]
    unless_null $P2331, vivify_754
    $P2331 = root_new ['parrot';'Hash']
  vivify_754:
    set $P2332, $P2331["identifier"]
    unless_null $P2332, vivify_755
    new $P2332, "Undef"
  vivify_755:
    clone $P2333, $P2332
    store_lex "@ns", $P2333
.annotate 'line', 1053
    find_lex $P2334, "@ns"
    $P2335 = $P2334."pop"()
    store_lex "$name", $P2335
.annotate 'line', 1054
    find_lex $P2339, "@ns"
    if $P2339, if_2338
    set $P2337, $P2339
    goto if_2338_end
  if_2338:
    find_lex $P2340, "@ns"
    unless_null $P2340, vivify_756
    $P2340 = root_new ['parrot';'ResizablePMCArray']
  vivify_756:
    set $P2341, $P2340[0]
    unless_null $P2341, vivify_757
    new $P2341, "Undef"
  vivify_757:
    set $S2342, $P2341
    iseq $I2343, $S2342, "GLOBAL"
    new $P2337, 'Integer'
    set $P2337, $I2343
  if_2338_end:
    unless $P2337, if_2336_end
    find_lex $P2344, "@ns"
    $P2344."shift"()
  if_2336_end:
.annotate 'line', 1056
    get_hll_global $P2345, ["PAST"], "Var"
    find_lex $P2346, "$name"
    set $S2347, $P2346
    find_lex $P2348, "@ns"
    $P2349 = $P2345."new"($S2347 :named("name"), $P2348 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2349
.annotate 'line', 1057
    find_lex $P2350, "$var"
    store_lex "$past", $P2350
.annotate 'line', 1058
    find_lex $P2352, "$/"
    unless_null $P2352, vivify_758
    $P2352 = root_new ['parrot';'Hash']
  vivify_758:
    set $P2353, $P2352["args"]
    unless_null $P2353, vivify_759
    new $P2353, "Undef"
  vivify_759:
    unless $P2353, if_2351_end
.annotate 'line', 1059
    find_lex $P2354, "$/"
    unless_null $P2354, vivify_760
    $P2354 = root_new ['parrot';'Hash']
  vivify_760:
    set $P2355, $P2354["args"]
    unless_null $P2355, vivify_761
    $P2355 = root_new ['parrot';'ResizablePMCArray']
  vivify_761:
    set $P2356, $P2355[0]
    unless_null $P2356, vivify_762
    new $P2356, "Undef"
  vivify_762:
    $P2357 = $P2356."ast"()
    store_lex "$past", $P2357
.annotate 'line', 1060
    find_lex $P2358, "$past"
    find_lex $P2359, "$var"
    $P2358."unshift"($P2359)
  if_2351_end:
.annotate 'line', 1062
    find_lex $P2360, "$/"
    find_lex $P2361, "$past"
    $P2362 = $P2360."!make"($P2361)
.annotate 'line', 1051
    .return ($P2362)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("120_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2364
    .param pmc param_2365
.annotate 'line', 1065
    .lex "self", param_2364
    .lex "$/", param_2365
.annotate 'line', 1066
    new $P2366, "Undef"
    .lex "$past", $P2366
.annotate 'line', 1067
    new $P2367, "Undef"
    .lex "$pirop", $P2367
.annotate 'line', 1066
    find_lex $P2370, "$/"
    unless_null $P2370, vivify_763
    $P2370 = root_new ['parrot';'Hash']
  vivify_763:
    set $P2371, $P2370["args"]
    unless_null $P2371, vivify_764
    new $P2371, "Undef"
  vivify_764:
    if $P2371, if_2369
    get_hll_global $P2376, ["PAST"], "Op"
    find_lex $P2377, "$/"
    $P2378 = $P2376."new"($P2377 :named("node"))
    set $P2368, $P2378
    goto if_2369_end
  if_2369:
    find_lex $P2372, "$/"
    unless_null $P2372, vivify_765
    $P2372 = root_new ['parrot';'Hash']
  vivify_765:
    set $P2373, $P2372["args"]
    unless_null $P2373, vivify_766
    $P2373 = root_new ['parrot';'ResizablePMCArray']
  vivify_766:
    set $P2374, $P2373[0]
    unless_null $P2374, vivify_767
    new $P2374, "Undef"
  vivify_767:
    $P2375 = $P2374."ast"()
    set $P2368, $P2375
  if_2369_end:
    store_lex "$past", $P2368
.annotate 'line', 1067
    find_lex $P2379, "$/"
    unless_null $P2379, vivify_768
    $P2379 = root_new ['parrot';'Hash']
  vivify_768:
    set $P2380, $P2379["op"]
    unless_null $P2380, vivify_769
    new $P2380, "Undef"
  vivify_769:
    set $S2381, $P2380
    new $P2382, 'String'
    set $P2382, $S2381
    store_lex "$pirop", $P2382
.annotate 'line', 1068

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2383 = box $S0
    
    store_lex "$pirop", $P2383
.annotate 'line', 1075
    find_lex $P2384, "$past"
    find_lex $P2385, "$pirop"
    $P2384."pirop"($P2385)
.annotate 'line', 1076
    find_lex $P2386, "$past"
    $P2386."pasttype"("pirop")
.annotate 'line', 1077
    find_lex $P2387, "$/"
    find_lex $P2388, "$past"
    $P2389 = $P2387."!make"($P2388)
.annotate 'line', 1065
    .return ($P2389)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("121_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2391
    .param pmc param_2392
.annotate 'line', 1080
    .lex "self", param_2391
    .lex "$/", param_2392
.annotate 'line', 1081
    find_lex $P2393, "$/"
    get_hll_global $P2394, ["PAST"], "Op"
    $P2395 = $P2394."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2396 = $P2393."!make"($P2395)
.annotate 'line', 1080
    .return ($P2396)
.end


.namespace ["NQP";"Actions"]
.sub "args"  :subid("122_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2398
    .param pmc param_2399
.annotate 'line', 1086
    .lex "self", param_2398
    .lex "$/", param_2399
    find_lex $P2400, "$/"
    find_lex $P2401, "$/"
    unless_null $P2401, vivify_770
    $P2401 = root_new ['parrot';'Hash']
  vivify_770:
    set $P2402, $P2401["arglist"]
    unless_null $P2402, vivify_771
    new $P2402, "Undef"
  vivify_771:
    $P2403 = $P2402."ast"()
    $P2404 = $P2400."!make"($P2403)
    .return ($P2404)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("123_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2406
    .param pmc param_2407
.annotate 'line', 1088
    .const 'Sub' $P2418 = "124_1298845576.421" 
    capture_lex $P2418
    .lex "self", param_2406
    .lex "$/", param_2407
.annotate 'line', 1089
    new $P2408, "Undef"
    .lex "$past", $P2408
.annotate 'line', 1097
    new $P2409, "Undef"
    .lex "$i", $P2409
.annotate 'line', 1098
    new $P2410, "Undef"
    .lex "$n", $P2410
.annotate 'line', 1089
    get_hll_global $P2411, ["PAST"], "Op"
    find_lex $P2412, "$/"
    $P2413 = $P2411."new"("call" :named("pasttype"), $P2412 :named("node"))
    store_lex "$past", $P2413
.annotate 'line', 1090
    find_lex $P2415, "$/"
    unless_null $P2415, vivify_772
    $P2415 = root_new ['parrot';'Hash']
  vivify_772:
    set $P2416, $P2415["EXPR"]
    unless_null $P2416, vivify_773
    new $P2416, "Undef"
  vivify_773:
    unless $P2416, if_2414_end
    .const 'Sub' $P2418 = "124_1298845576.421" 
    capture_lex $P2418
    $P2418()
  if_2414_end:
.annotate 'line', 1097
    new $P2450, "Integer"
    assign $P2450, 0
    store_lex "$i", $P2450
.annotate 'line', 1098
    find_lex $P2451, "$past"
    $P2452 = $P2451."list"()
    set $N2453, $P2452
    new $P2454, 'Float'
    set $P2454, $N2453
    store_lex "$n", $P2454
.annotate 'line', 1099
    new $P2502, 'ExceptionHandler'
    set_label $P2502, loop2501_handler
    $P2502."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2502
  loop2501_test:
    find_lex $P2455, "$i"
    set $N2456, $P2455
    find_lex $P2457, "$n"
    set $N2458, $P2457
    islt $I2459, $N2456, $N2458
    unless $I2459, loop2501_done
  loop2501_redo:
.annotate 'line', 1100
    find_lex $P2461, "$i"
    set $I2462, $P2461
    find_lex $P2463, "$past"
    unless_null $P2463, vivify_777
    $P2463 = root_new ['parrot';'ResizablePMCArray']
  vivify_777:
    set $P2464, $P2463[$I2462]
    unless_null $P2464, vivify_778
    new $P2464, "Undef"
  vivify_778:
    $S2465 = $P2464."name"()
    iseq $I2466, $S2465, "&prefix:<|>"
    unless $I2466, if_2460_end
.annotate 'line', 1101
    find_lex $P2467, "$i"
    set $I2468, $P2467
    find_lex $P2469, "$past"
    unless_null $P2469, vivify_779
    $P2469 = root_new ['parrot';'ResizablePMCArray']
  vivify_779:
    set $P2470, $P2469[$I2468]
    unless_null $P2470, vivify_780
    $P2470 = root_new ['parrot';'ResizablePMCArray']
  vivify_780:
    set $P2471, $P2470[0]
    unless_null $P2471, vivify_781
    new $P2471, "Undef"
  vivify_781:
    find_lex $P2472, "$i"
    set $I2473, $P2472
    find_lex $P2474, "$past"
    unless_null $P2474, vivify_782
    $P2474 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2474
  vivify_782:
    set $P2474[$I2473], $P2471
.annotate 'line', 1102
    find_lex $P2475, "$i"
    set $I2476, $P2475
    find_lex $P2477, "$past"
    unless_null $P2477, vivify_783
    $P2477 = root_new ['parrot';'ResizablePMCArray']
  vivify_783:
    set $P2478, $P2477[$I2476]
    unless_null $P2478, vivify_784
    new $P2478, "Undef"
  vivify_784:
    $P2478."flat"(1)
.annotate 'line', 1103
    find_lex $P2482, "$i"
    set $I2483, $P2482
    find_lex $P2484, "$past"
    unless_null $P2484, vivify_785
    $P2484 = root_new ['parrot';'ResizablePMCArray']
  vivify_785:
    set $P2485, $P2484[$I2483]
    unless_null $P2485, vivify_786
    new $P2485, "Undef"
  vivify_786:
    get_hll_global $P2486, ["PAST"], "Val"
    $P2487 = $P2485."isa"($P2486)
    if $P2487, if_2481
    set $P2480, $P2487
    goto if_2481_end
  if_2481:
.annotate 'line', 1104
    find_lex $P2488, "$i"
    set $I2489, $P2488
    find_lex $P2490, "$past"
    unless_null $P2490, vivify_787
    $P2490 = root_new ['parrot';'ResizablePMCArray']
  vivify_787:
    set $P2491, $P2490[$I2489]
    unless_null $P2491, vivify_788
    new $P2491, "Undef"
  vivify_788:
    $S2492 = $P2491."name"()
    substr $S2493, $S2492, 0, 1
    iseq $I2494, $S2493, "%"
    new $P2480, 'Integer'
    set $P2480, $I2494
  if_2481_end:
    unless $P2480, if_2479_end
.annotate 'line', 1105
    find_lex $P2495, "$i"
    set $I2496, $P2495
    find_lex $P2497, "$past"
    unless_null $P2497, vivify_789
    $P2497 = root_new ['parrot';'ResizablePMCArray']
  vivify_789:
    set $P2498, $P2497[$I2496]
    unless_null $P2498, vivify_790
    new $P2498, "Undef"
  vivify_790:
    $P2498."named"(1)
  if_2479_end:
  if_2460_end:
.annotate 'line', 1100
    find_lex $P2499, "$i"
    clone $P2500, $P2499
    inc $P2499
  loop2501_next:
.annotate 'line', 1099
    goto loop2501_test
  loop2501_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2503, exception, 'type'
    eq $P2503, .CONTROL_LOOP_NEXT, loop2501_next
    eq $P2503, .CONTROL_LOOP_REDO, loop2501_redo
  loop2501_done:
    pop_eh 
.annotate 'line', 1110
    find_lex $P2504, "$/"
    find_lex $P2505, "$past"
    $P2506 = $P2504."!make"($P2505)
.annotate 'line', 1088
    .return ($P2506)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2417"  :anon :subid("124_1298845576.421") :outer("123_1298845576.421")
.annotate 'line', 1090
    .const 'Sub' $P2439 = "125_1298845576.421" 
    capture_lex $P2439
.annotate 'line', 1091
    new $P2419, "Undef"
    .lex "$expr", $P2419
    find_lex $P2420, "$/"
    unless_null $P2420, vivify_774
    $P2420 = root_new ['parrot';'Hash']
  vivify_774:
    set $P2421, $P2420["EXPR"]
    unless_null $P2421, vivify_775
    new $P2421, "Undef"
  vivify_775:
    $P2422 = $P2421."ast"()
    store_lex "$expr", $P2422
.annotate 'line', 1092
    find_lex $P2427, "$expr"
    $S2428 = $P2427."name"()
    iseq $I2429, $S2428, "&infix:<,>"
    if $I2429, if_2426
    new $P2425, 'Integer'
    set $P2425, $I2429
    goto if_2426_end
  if_2426:
    find_lex $P2430, "$expr"
    $P2431 = $P2430."named"()
    isfalse $I2432, $P2431
    new $P2425, 'Integer'
    set $P2425, $I2432
  if_2426_end:
    if $P2425, if_2424
.annotate 'line', 1095
    find_lex $P2447, "$past"
    find_lex $P2448, "$expr"
    $P2449 = $P2447."push"($P2448)
    set $P2423, $P2449
.annotate 'line', 1092
    goto if_2424_end
  if_2424:
.annotate 'line', 1093
    find_lex $P2434, "$expr"
    $P2435 = $P2434."list"()
    defined $I2436, $P2435
    unless $I2436, for_undef_776
    iter $P2433, $P2435
    new $P2445, 'ExceptionHandler'
    set_label $P2445, loop2444_handler
    $P2445."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2445
  loop2444_test:
    unless $P2433, loop2444_done
    shift $P2437, $P2433
  loop2444_redo:
    .const 'Sub' $P2439 = "125_1298845576.421" 
    capture_lex $P2439
    $P2439($P2437)
  loop2444_next:
    goto loop2444_test
  loop2444_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2446, exception, 'type'
    eq $P2446, .CONTROL_LOOP_NEXT, loop2444_next
    eq $P2446, .CONTROL_LOOP_REDO, loop2444_redo
  loop2444_done:
    pop_eh 
  for_undef_776:
.annotate 'line', 1092
    set $P2423, $P2433
  if_2424_end:
.annotate 'line', 1090
    .return ($P2423)
.end


.namespace ["NQP";"Actions"]
.sub "_block2438"  :anon :subid("125_1298845576.421") :outer("124_1298845576.421")
    .param pmc param_2440
.annotate 'line', 1093
    .lex "$_", param_2440
    find_lex $P2441, "$past"
    find_lex $P2442, "$_"
    $P2443 = $P2441."push"($P2442)
    .return ($P2443)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("126_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2508
    .param pmc param_2509
.annotate 'line', 1113
    .lex "self", param_2508
    .lex "$/", param_2509
    find_lex $P2510, "$/"
    find_lex $P2511, "$/"
    unless_null $P2511, vivify_791
    $P2511 = root_new ['parrot';'Hash']
  vivify_791:
    set $P2512, $P2511["multi_declarator"]
    unless_null $P2512, vivify_792
    new $P2512, "Undef"
  vivify_792:
    $P2513 = $P2512."ast"()
    $P2514 = $P2510."!make"($P2513)
    .return ($P2514)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("127_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2516
    .param pmc param_2517
.annotate 'line', 1115
    .lex "self", param_2516
    .lex "$/", param_2517
    find_lex $P2518, "$/"
    find_lex $P2519, "$/"
    unless_null $P2519, vivify_793
    $P2519 = root_new ['parrot';'Hash']
  vivify_793:
    set $P2520, $P2519["value"]
    unless_null $P2520, vivify_794
    new $P2520, "Undef"
  vivify_794:
    $P2521 = $P2520."ast"()
    $P2522 = $P2518."!make"($P2521)
    .return ($P2522)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("128_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2524
    .param pmc param_2525
.annotate 'line', 1117
    .lex "self", param_2524
    .lex "$/", param_2525
.annotate 'line', 1118
    find_lex $P2526, "$/"
.annotate 'line', 1119
    find_lex $P2529, "$/"
    unless_null $P2529, vivify_795
    $P2529 = root_new ['parrot';'Hash']
  vivify_795:
    set $P2530, $P2529["EXPR"]
    unless_null $P2530, vivify_796
    new $P2530, "Undef"
  vivify_796:
    if $P2530, if_2528
.annotate 'line', 1120
    get_hll_global $P2535, ["PAST"], "Op"
    find_lex $P2536, "$/"
    $P2537 = $P2535."new"("list" :named("pasttype"), $P2536 :named("node"))
    set $P2527, $P2537
.annotate 'line', 1119
    goto if_2528_end
  if_2528:
    find_lex $P2531, "$/"
    unless_null $P2531, vivify_797
    $P2531 = root_new ['parrot';'Hash']
  vivify_797:
    set $P2532, $P2531["EXPR"]
    unless_null $P2532, vivify_798
    $P2532 = root_new ['parrot';'ResizablePMCArray']
  vivify_798:
    set $P2533, $P2532[0]
    unless_null $P2533, vivify_799
    new $P2533, "Undef"
  vivify_799:
    $P2534 = $P2533."ast"()
    set $P2527, $P2534
  if_2528_end:
    $P2538 = $P2526."!make"($P2527)
.annotate 'line', 1117
    .return ($P2538)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("129_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2540
    .param pmc param_2541
.annotate 'line', 1123
    .lex "self", param_2540
    .lex "$/", param_2541
.annotate 'line', 1124
    new $P2542, "Undef"
    .lex "$past", $P2542
.annotate 'line', 1123
    find_lex $P2543, "$past"
.annotate 'line', 1125
    find_lex $P2545, "$/"
    unless_null $P2545, vivify_800
    $P2545 = root_new ['parrot';'Hash']
  vivify_800:
    set $P2546, $P2545["EXPR"]
    unless_null $P2546, vivify_801
    new $P2546, "Undef"
  vivify_801:
    if $P2546, if_2544
.annotate 'line', 1132
    get_hll_global $P2558, ["PAST"], "Op"
    $P2559 = $P2558."new"("list" :named("pasttype"))
    store_lex "$past", $P2559
.annotate 'line', 1131
    goto if_2544_end
  if_2544:
.annotate 'line', 1126
    find_lex $P2547, "$/"
    unless_null $P2547, vivify_802
    $P2547 = root_new ['parrot';'Hash']
  vivify_802:
    set $P2548, $P2547["EXPR"]
    unless_null $P2548, vivify_803
    $P2548 = root_new ['parrot';'ResizablePMCArray']
  vivify_803:
    set $P2549, $P2548[0]
    unless_null $P2549, vivify_804
    new $P2549, "Undef"
  vivify_804:
    $P2550 = $P2549."ast"()
    store_lex "$past", $P2550
.annotate 'line', 1127
    find_lex $P2552, "$past"
    $S2553 = $P2552."name"()
    isne $I2554, $S2553, "&infix:<,>"
    unless $I2554, if_2551_end
.annotate 'line', 1128
    get_hll_global $P2555, ["PAST"], "Op"
    find_lex $P2556, "$past"
    $P2557 = $P2555."new"($P2556, "list" :named("pasttype"))
    store_lex "$past", $P2557
  if_2551_end:
  if_2544_end:
.annotate 'line', 1134
    find_lex $P2560, "$past"
    $P2560."name"("&circumfix:<[ ]>")
.annotate 'line', 1135
    find_lex $P2561, "$/"
    find_lex $P2562, "$past"
    $P2563 = $P2561."!make"($P2562)
.annotate 'line', 1123
    .return ($P2563)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("130_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2565
    .param pmc param_2566
.annotate 'line', 1138
    .lex "self", param_2565
    .lex "$/", param_2566
    find_lex $P2567, "$/"
    find_lex $P2568, "$/"
    unless_null $P2568, vivify_805
    $P2568 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2569, $P2568["quote_EXPR"]
    unless_null $P2569, vivify_806
    new $P2569, "Undef"
  vivify_806:
    $P2570 = $P2569."ast"()
    $P2571 = $P2567."!make"($P2570)
    .return ($P2571)
.end


.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("131_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2573
    .param pmc param_2574
.annotate 'line', 1139
    .lex "self", param_2573
    .lex "$/", param_2574
    find_lex $P2575, "$/"
    find_lex $P2576, "$/"
    unless_null $P2576, vivify_807
    $P2576 = root_new ['parrot';'Hash']
  vivify_807:
    set $P2577, $P2576["quote_EXPR"]
    unless_null $P2577, vivify_808
    new $P2577, "Undef"
  vivify_808:
    $P2578 = $P2577."ast"()
    $P2579 = $P2575."!make"($P2578)
    .return ($P2579)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("132_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2581
    .param pmc param_2582
.annotate 'line', 1141
    .const 'Sub' $P2593 = "133_1298845576.421" 
    capture_lex $P2593
    .lex "self", param_2581
    .lex "$/", param_2582
.annotate 'line', 1142
    find_lex $P2585, "$/"
    unless_null $P2585, vivify_809
    $P2585 = root_new ['parrot';'Hash']
  vivify_809:
    set $P2586, $P2585["pblock"]
    unless_null $P2586, vivify_810
    $P2586 = root_new ['parrot';'Hash']
  vivify_810:
    set $P2587, $P2586["blockoid"]
    unless_null $P2587, vivify_811
    $P2587 = root_new ['parrot';'Hash']
  vivify_811:
    set $P2588, $P2587["statementlist"]
    unless_null $P2588, vivify_812
    $P2588 = root_new ['parrot';'Hash']
  vivify_812:
    set $P2589, $P2588["statement"]
    unless_null $P2589, vivify_813
    new $P2589, "Undef"
  vivify_813:
    set $N2590, $P2589
    isgt $I2591, $N2590, 0.0
    if $I2591, if_2584
.annotate 'line', 1147
    find_lex $P2606, "$/"
    unless_null $P2606, vivify_814
    $P2606 = root_new ['parrot';'Hash']
  vivify_814:
    set $P2607, $P2606["pblock"]
    unless_null $P2607, vivify_815
    $P2607 = root_new ['parrot';'Hash']
  vivify_815:
    set $P2608, $P2607["blockoid"]
    unless_null $P2608, vivify_816
    $P2608 = root_new ['parrot';'Hash']
  vivify_816:
    set $P2609, $P2608["you_are_here"]
    unless_null $P2609, vivify_817
    new $P2609, "Undef"
  vivify_817:
    if $P2609, if_2605
.annotate 'line', 1151
    find_lex $P2615, "$/"
    $P2616 = "vivitype"("%")
    $P2617 = $P2615."!make"($P2616)
.annotate 'line', 1150
    set $P2604, $P2617
.annotate 'line', 1147
    goto if_2605_end
  if_2605:
.annotate 'line', 1148
    find_lex $P2610, "$/"
    find_lex $P2611, "$/"
    unless_null $P2611, vivify_818
    $P2611 = root_new ['parrot';'Hash']
  vivify_818:
    set $P2612, $P2611["pblock"]
    unless_null $P2612, vivify_819
    new $P2612, "Undef"
  vivify_819:
    $P2613 = $P2612."ast"()
    $P2614 = $P2610."!make"($P2613)
.annotate 'line', 1147
    set $P2604, $P2614
  if_2605_end:
    set $P2583, $P2604
.annotate 'line', 1142
    goto if_2584_end
  if_2584:
    .const 'Sub' $P2593 = "133_1298845576.421" 
    capture_lex $P2593
    $P2603 = $P2593()
    set $P2583, $P2603
  if_2584_end:
.annotate 'line', 1141
    .return ($P2583)
.end


.namespace ["NQP";"Actions"]
.sub "_block2592"  :anon :subid("133_1298845576.421") :outer("132_1298845576.421")
.annotate 'line', 1143
    new $P2594, "Undef"
    .lex "$past", $P2594
    find_lex $P2595, "$/"
    unless_null $P2595, vivify_820
    $P2595 = root_new ['parrot';'Hash']
  vivify_820:
    set $P2596, $P2595["pblock"]
    unless_null $P2596, vivify_821
    new $P2596, "Undef"
  vivify_821:
    $P2597 = $P2596."ast"()
    store_lex "$past", $P2597
.annotate 'line', 1144
    new $P2598, "Integer"
    assign $P2598, 1
    find_lex $P2599, "$past"
    unless_null $P2599, vivify_822
    $P2599 = root_new ['parrot';'Hash']
    store_lex "$past", $P2599
  vivify_822:
    set $P2599["bareblock"], $P2598
.annotate 'line', 1145
    find_dynamic_lex $P2600, "$/"
    find_lex $P2601, "$past"
    $P2602 = $P2600."!make"($P2601)
.annotate 'line', 1142
    .return ($P2602)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("134_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2619
    .param pmc param_2620
.annotate 'line', 1155
    .lex "self", param_2619
    .lex "$/", param_2620
.annotate 'line', 1156
    new $P2621, "Undef"
    .lex "$name", $P2621
    find_lex $P2624, "$/"
    unless_null $P2624, vivify_823
    $P2624 = root_new ['parrot';'Hash']
  vivify_823:
    set $P2625, $P2624["sigil"]
    unless_null $P2625, vivify_824
    new $P2625, "Undef"
  vivify_824:
    set $S2626, $P2625
    iseq $I2627, $S2626, "@"
    if $I2627, if_2623
.annotate 'line', 1157
    find_lex $P2631, "$/"
    unless_null $P2631, vivify_825
    $P2631 = root_new ['parrot';'Hash']
  vivify_825:
    set $P2632, $P2631["sigil"]
    unless_null $P2632, vivify_826
    new $P2632, "Undef"
  vivify_826:
    set $S2633, $P2632
    iseq $I2634, $S2633, "%"
    if $I2634, if_2630
    new $P2636, "String"
    assign $P2636, "item"
    set $P2629, $P2636
    goto if_2630_end
  if_2630:
    new $P2635, "String"
    assign $P2635, "hash"
    set $P2629, $P2635
  if_2630_end:
    set $P2622, $P2629
.annotate 'line', 1156
    goto if_2623_end
  if_2623:
    new $P2628, "String"
    assign $P2628, "list"
    set $P2622, $P2628
  if_2623_end:
    store_lex "$name", $P2622
.annotate 'line', 1159
    find_lex $P2637, "$/"
    get_hll_global $P2638, ["PAST"], "Op"
    find_lex $P2639, "$name"
    find_lex $P2640, "$/"
    unless_null $P2640, vivify_827
    $P2640 = root_new ['parrot';'Hash']
  vivify_827:
    set $P2641, $P2640["semilist"]
    unless_null $P2641, vivify_828
    new $P2641, "Undef"
  vivify_828:
    $P2642 = $P2641."ast"()
    $P2643 = $P2638."new"($P2642, "callmethod" :named("pasttype"), $P2639 :named("name"))
    $P2644 = $P2637."!make"($P2643)
.annotate 'line', 1155
    .return ($P2644)
.end


.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("135_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2646
    .param pmc param_2647
.annotate 'line', 1162
    .lex "self", param_2646
    .lex "$/", param_2647
    find_lex $P2648, "$/"
    find_lex $P2649, "$/"
    unless_null $P2649, vivify_829
    $P2649 = root_new ['parrot';'Hash']
  vivify_829:
    set $P2650, $P2649["statement"]
    unless_null $P2650, vivify_830
    new $P2650, "Undef"
  vivify_830:
    $P2651 = $P2650."ast"()
    $P2652 = $P2648."!make"($P2651)
    .return ($P2652)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("136_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2654
    .param pmc param_2655
.annotate 'line', 1164
    .lex "self", param_2654
    .lex "$/", param_2655
.annotate 'line', 1165
    find_lex $P2656, "$/"
    get_hll_global $P2657, ["PAST"], "Var"
    find_lex $P2658, "$/"
    unless_null $P2658, vivify_831
    $P2658 = root_new ['parrot';'Hash']
  vivify_831:
    set $P2659, $P2658["EXPR"]
    unless_null $P2659, vivify_832
    new $P2659, "Undef"
  vivify_832:
    $P2660 = $P2659."ast"()
.annotate 'line', 1167
    $P2661 = "vivitype"("@")
    $P2662 = $P2657."new"($P2660, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2661 :named("vivibase"))
.annotate 'line', 1165
    $P2663 = $P2656."!make"($P2662)
.annotate 'line', 1164
    .return ($P2663)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("137_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2665
    .param pmc param_2666
.annotate 'line', 1170
    .lex "self", param_2665
    .lex "$/", param_2666
.annotate 'line', 1171
    find_lex $P2667, "$/"
    get_hll_global $P2668, ["PAST"], "Var"
    find_lex $P2669, "$/"
    unless_null $P2669, vivify_833
    $P2669 = root_new ['parrot';'Hash']
  vivify_833:
    set $P2670, $P2669["EXPR"]
    unless_null $P2670, vivify_834
    new $P2670, "Undef"
  vivify_834:
    $P2671 = $P2670."ast"()
.annotate 'line', 1173
    $P2672 = "vivitype"("%")
    $P2673 = $P2668."new"($P2671, "keyed" :named("scope"), "Undef" :named("viviself"), $P2672 :named("vivibase"))
.annotate 'line', 1171
    $P2674 = $P2667."!make"($P2673)
.annotate 'line', 1170
    .return ($P2674)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("138_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2676
    .param pmc param_2677
.annotate 'line', 1176
    .lex "self", param_2676
    .lex "$/", param_2677
.annotate 'line', 1177
    find_lex $P2678, "$/"
    get_hll_global $P2679, ["PAST"], "Var"
    find_lex $P2680, "$/"
    unless_null $P2680, vivify_835
    $P2680 = root_new ['parrot';'Hash']
  vivify_835:
    set $P2681, $P2680["quote_EXPR"]
    unless_null $P2681, vivify_836
    new $P2681, "Undef"
  vivify_836:
    $P2682 = $P2681."ast"()
.annotate 'line', 1179
    $P2683 = "vivitype"("%")
    $P2684 = $P2679."new"($P2682, "keyed" :named("scope"), "Undef" :named("viviself"), $P2683 :named("vivibase"))
.annotate 'line', 1177
    $P2685 = $P2678."!make"($P2684)
.annotate 'line', 1176
    .return ($P2685)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("139_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2687
    .param pmc param_2688
.annotate 'line', 1182
    .lex "self", param_2687
    .lex "$/", param_2688
.annotate 'line', 1183
    find_lex $P2689, "$/"
    find_lex $P2690, "$/"
    unless_null $P2690, vivify_837
    $P2690 = root_new ['parrot';'Hash']
  vivify_837:
    set $P2691, $P2690["arglist"]
    unless_null $P2691, vivify_838
    new $P2691, "Undef"
  vivify_838:
    $P2692 = $P2691."ast"()
    $P2693 = $P2689."!make"($P2692)
.annotate 'line', 1182
    .return ($P2693)
.end


.namespace ["NQP";"Actions"]
.sub "value"  :subid("140_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2695
    .param pmc param_2696
.annotate 'line', 1186
    .lex "self", param_2695
    .lex "$/", param_2696
.annotate 'line', 1187
    find_lex $P2697, "$/"
    find_lex $P2700, "$/"
    unless_null $P2700, vivify_839
    $P2700 = root_new ['parrot';'Hash']
  vivify_839:
    set $P2701, $P2700["quote"]
    unless_null $P2701, vivify_840
    new $P2701, "Undef"
  vivify_840:
    if $P2701, if_2699
    find_lex $P2705, "$/"
    unless_null $P2705, vivify_841
    $P2705 = root_new ['parrot';'Hash']
  vivify_841:
    set $P2706, $P2705["number"]
    unless_null $P2706, vivify_842
    new $P2706, "Undef"
  vivify_842:
    $P2707 = $P2706."ast"()
    set $P2698, $P2707
    goto if_2699_end
  if_2699:
    find_lex $P2702, "$/"
    unless_null $P2702, vivify_843
    $P2702 = root_new ['parrot';'Hash']
  vivify_843:
    set $P2703, $P2702["quote"]
    unless_null $P2703, vivify_844
    new $P2703, "Undef"
  vivify_844:
    $P2704 = $P2703."ast"()
    set $P2698, $P2704
  if_2699_end:
    $P2708 = $P2697."!make"($P2698)
.annotate 'line', 1186
    .return ($P2708)
.end


.namespace ["NQP";"Actions"]
.sub "number"  :subid("141_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2710
    .param pmc param_2711
.annotate 'line', 1190
    .lex "self", param_2710
    .lex "$/", param_2711
.annotate 'line', 1191
    new $P2712, "Undef"
    .lex "$value", $P2712
    find_lex $P2715, "$/"
    unless_null $P2715, vivify_845
    $P2715 = root_new ['parrot';'Hash']
  vivify_845:
    set $P2716, $P2715["dec_number"]
    unless_null $P2716, vivify_846
    new $P2716, "Undef"
  vivify_846:
    if $P2716, if_2714
    find_lex $P2720, "$/"
    unless_null $P2720, vivify_847
    $P2720 = root_new ['parrot';'Hash']
  vivify_847:
    set $P2721, $P2720["integer"]
    unless_null $P2721, vivify_848
    new $P2721, "Undef"
  vivify_848:
    $P2722 = $P2721."ast"()
    set $P2713, $P2722
    goto if_2714_end
  if_2714:
    find_lex $P2717, "$/"
    unless_null $P2717, vivify_849
    $P2717 = root_new ['parrot';'Hash']
  vivify_849:
    set $P2718, $P2717["dec_number"]
    unless_null $P2718, vivify_850
    new $P2718, "Undef"
  vivify_850:
    $P2719 = $P2718."ast"()
    set $P2713, $P2719
  if_2714_end:
    store_lex "$value", $P2713
.annotate 'line', 1192
    find_lex $P2724, "$/"
    unless_null $P2724, vivify_851
    $P2724 = root_new ['parrot';'Hash']
  vivify_851:
    set $P2725, $P2724["sign"]
    unless_null $P2725, vivify_852
    new $P2725, "Undef"
  vivify_852:
    set $S2726, $P2725
    iseq $I2727, $S2726, "-"
    unless $I2727, if_2723_end
    find_lex $P2728, "$value"
    neg $P2729, $P2728
    store_lex "$value", $P2729
  if_2723_end:
.annotate 'line', 1193
    find_lex $P2730, "$/"
    get_hll_global $P2731, ["PAST"], "Val"
    find_lex $P2732, "$value"
    $P2733 = $P2731."new"($P2732 :named("value"))
    $P2734 = $P2730."!make"($P2733)
.annotate 'line', 1190
    .return ($P2734)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("142_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2736
    .param pmc param_2737
.annotate 'line', 1196
    .lex "self", param_2736
    .lex "$/", param_2737
    find_lex $P2738, "$/"
    find_lex $P2739, "$/"
    unless_null $P2739, vivify_853
    $P2739 = root_new ['parrot';'Hash']
  vivify_853:
    set $P2740, $P2739["quote_EXPR"]
    unless_null $P2740, vivify_854
    new $P2740, "Undef"
  vivify_854:
    $P2741 = $P2740."ast"()
    $P2742 = $P2738."!make"($P2741)
    .return ($P2742)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("143_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2744
    .param pmc param_2745
.annotate 'line', 1197
    .lex "self", param_2744
    .lex "$/", param_2745
    find_lex $P2746, "$/"
    find_lex $P2747, "$/"
    unless_null $P2747, vivify_855
    $P2747 = root_new ['parrot';'Hash']
  vivify_855:
    set $P2748, $P2747["quote_EXPR"]
    unless_null $P2748, vivify_856
    new $P2748, "Undef"
  vivify_856:
    $P2749 = $P2748."ast"()
    $P2750 = $P2746."!make"($P2749)
    .return ($P2750)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("144_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2752
    .param pmc param_2753
.annotate 'line', 1198
    .lex "self", param_2752
    .lex "$/", param_2753
    find_lex $P2754, "$/"
    find_lex $P2755, "$/"
    unless_null $P2755, vivify_857
    $P2755 = root_new ['parrot';'Hash']
  vivify_857:
    set $P2756, $P2755["quote_EXPR"]
    unless_null $P2756, vivify_858
    new $P2756, "Undef"
  vivify_858:
    $P2757 = $P2756."ast"()
    $P2758 = $P2754."!make"($P2757)
    .return ($P2758)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("145_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2760
    .param pmc param_2761
.annotate 'line', 1199
    .lex "self", param_2760
    .lex "$/", param_2761
    find_lex $P2762, "$/"
    find_lex $P2763, "$/"
    unless_null $P2763, vivify_859
    $P2763 = root_new ['parrot';'Hash']
  vivify_859:
    set $P2764, $P2763["quote_EXPR"]
    unless_null $P2764, vivify_860
    new $P2764, "Undef"
  vivify_860:
    $P2765 = $P2764."ast"()
    $P2766 = $P2762."!make"($P2765)
    .return ($P2766)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("146_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2768
    .param pmc param_2769
.annotate 'line', 1200
    .lex "self", param_2768
    .lex "$/", param_2769
    find_lex $P2770, "$/"
    find_lex $P2771, "$/"
    unless_null $P2771, vivify_861
    $P2771 = root_new ['parrot';'Hash']
  vivify_861:
    set $P2772, $P2771["quote_EXPR"]
    unless_null $P2772, vivify_862
    new $P2772, "Undef"
  vivify_862:
    $P2773 = $P2772."ast"()
    $P2774 = $P2770."!make"($P2773)
    .return ($P2774)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("147_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2776
    .param pmc param_2777
.annotate 'line', 1201
    .lex "self", param_2776
    .lex "$/", param_2777
.annotate 'line', 1202
    find_lex $P2778, "$/"
    get_hll_global $P2779, ["PAST"], "Op"
    find_lex $P2780, "$/"
    unless_null $P2780, vivify_863
    $P2780 = root_new ['parrot';'Hash']
  vivify_863:
    set $P2781, $P2780["quote_EXPR"]
    unless_null $P2781, vivify_864
    new $P2781, "Undef"
  vivify_864:
    $P2782 = $P2781."ast"()
    $P2783 = $P2782."value"()
    find_lex $P2784, "$/"
    $P2785 = $P2779."new"($P2783 :named("inline"), "inline" :named("pasttype"), $P2784 :named("node"))
    $P2786 = $P2778."!make"($P2785)
.annotate 'line', 1201
    .return ($P2786)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("148_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2790
    .param pmc param_2791
    .param pmc param_2792 :optional
    .param int has_param_2792 :opt_flag
.annotate 'line', 1207
    new $P2789, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2789, control_2788
    push_eh $P2789
    .lex "self", param_2790
    .lex "$/", param_2791
    if has_param_2792, optparam_865
    new $P2793, "Undef"
    set param_2792, $P2793
  optparam_865:
    .lex "$key", param_2792
.annotate 'line', 1217
    new $P2794, "Undef"
    .lex "$regex", $P2794
.annotate 'line', 1219
    new $P2795, "Undef"
    .lex "$past", $P2795
.annotate 'line', 1208
    find_lex $P2797, "$key"
    set $S2798, $P2797
    iseq $I2799, $S2798, "open"
    unless $I2799, if_2796_end
.annotate 'line', 1209

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1213
    get_global $P2800, "@BLOCK"
    unless_null $P2800, vivify_866
    $P2800 = root_new ['parrot';'ResizablePMCArray']
  vivify_866:
    set $P2801, $P2800[0]
    unless_null $P2801, vivify_867
    new $P2801, "Undef"
  vivify_867:
    $P2801."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1214
    get_global $P2802, "@BLOCK"
    unless_null $P2802, vivify_868
    $P2802 = root_new ['parrot';'ResizablePMCArray']
  vivify_868:
    set $P2803, $P2802[0]
    unless_null $P2803, vivify_869
    new $P2803, "Undef"
  vivify_869:
    $P2803."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1215
    new $P2804, "Exception"
    set $P2804['type'], .CONTROL_RETURN
    new $P2805, "Integer"
    assign $P2805, 0
    setattribute $P2804, 'payload', $P2805
    throw $P2804
  if_2796_end:
.annotate 'line', 1218
    get_hll_global $P2806, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2807, "$/"
    unless_null $P2807, vivify_870
    $P2807 = root_new ['parrot';'Hash']
  vivify_870:
    set $P2808, $P2807["p6regex"]
    unless_null $P2808, vivify_871
    new $P2808, "Undef"
  vivify_871:
    $P2809 = $P2808."ast"()
    get_global $P2810, "@BLOCK"
    $P2811 = $P2810."shift"()
    $P2812 = $P2806($P2809, $P2811)
    store_lex "$regex", $P2812
.annotate 'line', 1220
    get_hll_global $P2813, ["PAST"], "Op"
.annotate 'line', 1222
    get_hll_global $P2814, ["PAST"], "Var"
    new $P2815, "ResizablePMCArray"
    push $P2815, "Regex"
    $P2816 = $P2814."new"("Regex" :named("name"), $P2815 :named("namespace"), "package" :named("scope"))
    find_lex $P2817, "$regex"
    $P2818 = $P2813."new"($P2816, $P2817, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1220
    store_lex "$past", $P2818
.annotate 'line', 1226
    find_lex $P2819, "$regex"
    find_lex $P2820, "$past"
    unless_null $P2820, vivify_872
    $P2820 = root_new ['parrot';'Hash']
    store_lex "$past", $P2820
  vivify_872:
    set $P2820["sink"], $P2819
.annotate 'line', 1227
    find_lex $P2821, "$/"
    find_lex $P2822, "$past"
    $P2823 = $P2821."!make"($P2822)
.annotate 'line', 1207
    .return ($P2823)
  control_2788:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2824, exception, "payload"
    .return ($P2824)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("149_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2826
    .param pmc param_2827
.annotate 'line', 1230
    .lex "self", param_2826
    .lex "$/", param_2827
    find_lex $P2828, "$/"
    find_lex $P2829, "$/"
    unless_null $P2829, vivify_873
    $P2829 = root_new ['parrot';'Hash']
  vivify_873:
    set $P2830, $P2829["variable"]
    unless_null $P2830, vivify_874
    new $P2830, "Undef"
  vivify_874:
    $P2831 = $P2830."ast"()
    $P2832 = $P2828."!make"($P2831)
    .return ($P2832)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("150_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2834
    .param pmc param_2835
.annotate 'line', 1231
    .lex "self", param_2834
    .lex "$/", param_2835
.annotate 'line', 1232
    find_lex $P2836, "$/"
    get_hll_global $P2837, ["PAST"], "Op"
.annotate 'line', 1233
    find_lex $P2838, "$/"
    unless_null $P2838, vivify_875
    $P2838 = root_new ['parrot';'Hash']
  vivify_875:
    set $P2839, $P2838["block"]
    unless_null $P2839, vivify_876
    new $P2839, "Undef"
  vivify_876:
    $P2840 = $P2839."ast"()
    $P2841 = "block_immediate"($P2840)
    find_lex $P2842, "$/"
    $P2843 = $P2837."new"($P2841, "set S*" :named("pirop"), $P2842 :named("node"))
.annotate 'line', 1232
    $P2844 = $P2836."!make"($P2843)
.annotate 'line', 1231
    .return ($P2844)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("151_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2846
    .param pmc param_2847
.annotate 'line', 1236
    .lex "self", param_2846
    .lex "$/", param_2847
    find_lex $P2848, "$/"
    $P2849 = $P2848."!make"("\e")
    .return ($P2849)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("152_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2851
    .param pmc param_2852
.annotate 'line', 1240
    .lex "self", param_2851
    .lex "$/", param_2852
    find_lex $P2853, "$/"
    find_lex $P2854, "$/"
    unless_null $P2854, vivify_877
    $P2854 = root_new ['parrot';'Hash']
  vivify_877:
    set $P2855, $P2854["dotty"]
    unless_null $P2855, vivify_878
    new $P2855, "Undef"
  vivify_878:
    $P2856 = $P2855."ast"()
    $P2857 = $P2853."!make"($P2856)
    .return ($P2857)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("153_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2859
    .param pmc param_2860
.annotate 'line', 1242
    .lex "self", param_2859
    .lex "$/", param_2860
.annotate 'line', 1243
    find_lex $P2861, "$/"
    get_hll_global $P2862, ["PAST"], "Op"
.annotate 'line', 1244
    new $P2863, "ResizablePMCArray"
    push $P2863, "    clone %r, %0"
    push $P2863, "    inc %0"
    $P2864 = $P2862."new"("postfix:<++>" :named("name"), $P2863 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1243
    $P2865 = $P2861."!make"($P2864)
.annotate 'line', 1242
    .return ($P2865)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("154_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2867
    .param pmc param_2868
.annotate 'line', 1248
    .lex "self", param_2867
    .lex "$/", param_2868
.annotate 'line', 1249
    find_lex $P2869, "$/"
    get_hll_global $P2870, ["PAST"], "Op"
.annotate 'line', 1250
    new $P2871, "ResizablePMCArray"
    push $P2871, "    clone %r, %0"
    push $P2871, "    dec %0"
    $P2872 = $P2870."new"("postfix:<-->" :named("name"), $P2871 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1249
    $P2873 = $P2869."!make"($P2872)
.annotate 'line', 1248
    .return ($P2873)
.end


.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("155_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2875
    .param pmc param_2876
.annotate 'line', 1254
    .lex "self", param_2875
    .lex "$/", param_2876
.annotate 'line', 1255
    find_lex $P2877, "$/"
    get_hll_global $P2878, ["PAST"], "Op"
.annotate 'line', 1256
    get_hll_global $P2879, ["PAST"], "Var"
    $P2880 = $P2879."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2881, "$/"
    $P2882 = $P2878."new"($P2880, "callmethod" :named("pasttype"), "!make" :named("name"), $P2881 :named("node"))
.annotate 'line', 1255
    $P2883 = $P2877."!make"($P2882)
.annotate 'line', 1254
    .return ($P2883)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("156_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2886
    .param pmc param_2887
.annotate 'line', 1272
    .lex "self", param_2886
    .lex "$/", param_2887
    find_lex $P2888, "$/"
    $P2889 = "control"($P2888, "CONTROL_LOOP_NEXT")
    .return ($P2889)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("157_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2891
    .param pmc param_2892
.annotate 'line', 1273
    .lex "self", param_2891
    .lex "$/", param_2892
    find_lex $P2893, "$/"
    $P2894 = "control"($P2893, "CONTROL_LOOP_LAST")
    .return ($P2894)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("158_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2896
    .param pmc param_2897
.annotate 'line', 1274
    .lex "self", param_2896
    .lex "$/", param_2897
    find_lex $P2898, "$/"
    $P2899 = "control"($P2898, "CONTROL_LOOP_REDO")
    .return ($P2899)
.end


.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("159_1298845576.421") :outer("11_1298845576.421")
    .param pmc param_2901
    .param pmc param_2902
.annotate 'line', 1276
    .lex "self", param_2901
    .lex "$/", param_2902
.annotate 'line', 1277
    find_lex $P2903, "$/"
    get_hll_global $P2904, ["PAST"], "Op"
    find_lex $P2905, "$/"
    $P2906 = $P2904."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2905 :named("node"))
    $P2907 = $P2903."!make"($P2906)
.annotate 'line', 1276
    .return ($P2907)
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2908"  :subid("160_1298845576.421") :outer("11_1298845576.421")
.annotate 'line', 1281
    .const 'Sub' $P3008 = "168_1298845576.421" 
    capture_lex $P3008
    .const 'Sub' $P2983 = "167_1298845576.421" 
    capture_lex $P2983
    .const 'Sub' $P2972 = "166_1298845576.421" 
    capture_lex $P2972
    .const 'Sub' $P2957 = "165_1298845576.421" 
    capture_lex $P2957
    .const 'Sub' $P2946 = "164_1298845576.421" 
    capture_lex $P2946
    .const 'Sub' $P2935 = "163_1298845576.421" 
    capture_lex $P2935
    .const 'Sub' $P2924 = "162_1298845576.421" 
    capture_lex $P2924
    .const 'Sub' $P2911 = "161_1298845576.421" 
    capture_lex $P2911
    get_global $P2910, "$?CLASS"
.annotate 'line', 1315
    .const 'Sub' $P2983 = "167_1298845576.421" 
    newclosure $P3006, $P2983
.annotate 'line', 1281
    .return ($P3006)
.end


.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post879") :outer("160_1298845576.421")
.annotate 'line', 1281
    get_hll_global $P2909, ["NQP";"RegexActions"], "_block2908" 
    .local pmc block
    set block, $P2909
    .const 'Sub' $P3008 = "168_1298845576.421" 
    capture_lex $P3008
    $P3008()
.end


.namespace ["NQP";"RegexActions"]
.sub "_block3007"  :anon :subid("168_1298845576.421") :outer("160_1298845576.421")
.annotate 'line', 1281
    get_hll_global $P3009, "NQPClassHOW"
    $P3010 = $P3009."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3010
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3011, type_obj
    .const 'Sub' $P3012 = "161_1298845576.421" 
    $P3011."add_method"(type_obj, "metachar:sym<:my>", $P3012)
    get_how $P3013, type_obj
    .const 'Sub' $P3014 = "162_1298845576.421" 
    $P3013."add_method"(type_obj, "metachar:sym<{ }>", $P3014)
    get_how $P3015, type_obj
    .const 'Sub' $P3016 = "163_1298845576.421" 
    $P3015."add_method"(type_obj, "metachar:sym<nqpvar>", $P3016)
    get_how $P3017, type_obj
    .const 'Sub' $P3018 = "164_1298845576.421" 
    $P3017."add_method"(type_obj, "assertion:sym<{ }>", $P3018)
    get_how $P3019, type_obj
    .const 'Sub' $P3020 = "165_1298845576.421" 
    $P3019."add_method"(type_obj, "assertion:sym<?{ }>", $P3020)
    get_how $P3021, type_obj
    .const 'Sub' $P3022 = "166_1298845576.421" 
    $P3021."add_method"(type_obj, "assertion:sym<var>", $P3022)
    get_how $P3023, type_obj
    .const 'Sub' $P3024 = "167_1298845576.421" 
    $P3023."add_method"(type_obj, "codeblock", $P3024)
    get_how $P3025, type_obj
    get_hll_global $P3026, ["Regex";"P6Regex"], "Actions"
    $P3025."add_parent"(type_obj, $P3026)
    get_how $P3027, type_obj
    $P3028 = $P3027."compose"(type_obj)
    .return ($P3028)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("161_1298845576.421") :outer("160_1298845576.421")
    .param pmc param_2912
    .param pmc param_2913
.annotate 'line', 1283
    .lex "self", param_2912
    .lex "$/", param_2913
.annotate 'line', 1284
    new $P2914, "Undef"
    .lex "$past", $P2914
    find_lex $P2915, "$/"
    unless_null $P2915, vivify_880
    $P2915 = root_new ['parrot';'Hash']
  vivify_880:
    set $P2916, $P2915["statement"]
    unless_null $P2916, vivify_881
    new $P2916, "Undef"
  vivify_881:
    $P2917 = $P2916."ast"()
    store_lex "$past", $P2917
.annotate 'line', 1285
    find_lex $P2918, "$/"
    get_hll_global $P2919, ["PAST"], "Regex"
    find_lex $P2920, "$past"
    find_lex $P2921, "$/"
    $P2922 = $P2919."new"($P2920, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2921 :named("node"))
    $P2923 = $P2918."!make"($P2922)
.annotate 'line', 1283
    .return ($P2923)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("162_1298845576.421") :outer("160_1298845576.421")
    .param pmc param_2925
    .param pmc param_2926
.annotate 'line', 1289
    .lex "self", param_2925
    .lex "$/", param_2926
.annotate 'line', 1290
    find_lex $P2927, "$/"
    get_hll_global $P2928, ["PAST"], "Regex"
    find_lex $P2929, "$/"
    unless_null $P2929, vivify_882
    $P2929 = root_new ['parrot';'Hash']
  vivify_882:
    set $P2930, $P2929["codeblock"]
    unless_null $P2930, vivify_883
    new $P2930, "Undef"
  vivify_883:
    $P2931 = $P2930."ast"()
    find_lex $P2932, "$/"
    $P2933 = $P2928."new"($P2931, "pastnode" :named("pasttype"), $P2932 :named("node"))
    $P2934 = $P2927."!make"($P2933)
.annotate 'line', 1289
    .return ($P2934)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("163_1298845576.421") :outer("160_1298845576.421")
    .param pmc param_2936
    .param pmc param_2937
.annotate 'line', 1294
    .lex "self", param_2936
    .lex "$/", param_2937
.annotate 'line', 1295
    find_lex $P2938, "$/"
    get_hll_global $P2939, ["PAST"], "Regex"
    find_lex $P2940, "$/"
    unless_null $P2940, vivify_884
    $P2940 = root_new ['parrot';'Hash']
  vivify_884:
    set $P2941, $P2940["var"]
    unless_null $P2941, vivify_885
    new $P2941, "Undef"
  vivify_885:
    $P2942 = $P2941."ast"()
    find_lex $P2943, "$/"
    $P2944 = $P2939."new"("!INTERPOLATE", $P2942, "subrule" :named("pasttype"), "method" :named("subtype"), $P2943 :named("node"))
    $P2945 = $P2938."!make"($P2944)
.annotate 'line', 1294
    .return ($P2945)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("164_1298845576.421") :outer("160_1298845576.421")
    .param pmc param_2947
    .param pmc param_2948
.annotate 'line', 1299
    .lex "self", param_2947
    .lex "$/", param_2948
.annotate 'line', 1300
    find_lex $P2949, "$/"
    get_hll_global $P2950, ["PAST"], "Regex"
    find_lex $P2951, "$/"
    unless_null $P2951, vivify_886
    $P2951 = root_new ['parrot';'Hash']
  vivify_886:
    set $P2952, $P2951["codeblock"]
    unless_null $P2952, vivify_887
    new $P2952, "Undef"
  vivify_887:
    $P2953 = $P2952."ast"()
    find_lex $P2954, "$/"
    $P2955 = $P2950."new"("!INTERPOLATE_REGEX", $P2953, "subrule" :named("pasttype"), "method" :named("subtype"), $P2954 :named("node"))
    $P2956 = $P2949."!make"($P2955)
.annotate 'line', 1299
    .return ($P2956)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("165_1298845576.421") :outer("160_1298845576.421")
    .param pmc param_2958
    .param pmc param_2959
.annotate 'line', 1304
    .lex "self", param_2958
    .lex "$/", param_2959
.annotate 'line', 1305
    find_lex $P2960, "$/"
    get_hll_global $P2961, ["PAST"], "Regex"
    find_lex $P2962, "$/"
    unless_null $P2962, vivify_888
    $P2962 = root_new ['parrot';'Hash']
  vivify_888:
    set $P2963, $P2962["codeblock"]
    unless_null $P2963, vivify_889
    new $P2963, "Undef"
  vivify_889:
    $P2964 = $P2963."ast"()
.annotate 'line', 1306
    find_lex $P2965, "$/"
    unless_null $P2965, vivify_890
    $P2965 = root_new ['parrot';'Hash']
  vivify_890:
    set $P2966, $P2965["zw"]
    unless_null $P2966, vivify_891
    new $P2966, "Undef"
  vivify_891:
    set $S2967, $P2966
    iseq $I2968, $S2967, "!"
    find_lex $P2969, "$/"
    $P2970 = $P2961."new"($P2964, "zerowidth" :named("subtype"), $I2968 :named("negate"), "pastnode" :named("pasttype"), $P2969 :named("node"))
.annotate 'line', 1305
    $P2971 = $P2960."!make"($P2970)
.annotate 'line', 1304
    .return ($P2971)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("166_1298845576.421") :outer("160_1298845576.421")
    .param pmc param_2973
    .param pmc param_2974
.annotate 'line', 1310
    .lex "self", param_2973
    .lex "$/", param_2974
.annotate 'line', 1311
    find_lex $P2975, "$/"
    get_hll_global $P2976, ["PAST"], "Regex"
    find_lex $P2977, "$/"
    unless_null $P2977, vivify_892
    $P2977 = root_new ['parrot';'Hash']
  vivify_892:
    set $P2978, $P2977["var"]
    unless_null $P2978, vivify_893
    new $P2978, "Undef"
  vivify_893:
    $P2979 = $P2978."ast"()
    find_lex $P2980, "$/"
    $P2981 = $P2976."new"("!INTERPOLATE_REGEX", $P2979, "subrule" :named("pasttype"), "method" :named("subtype"), $P2980 :named("node"))
    $P2982 = $P2975."!make"($P2981)
.annotate 'line', 1310
    .return ($P2982)
.end


.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("167_1298845576.421") :outer("160_1298845576.421")
    .param pmc param_2984
    .param pmc param_2985
.annotate 'line', 1315
    .lex "self", param_2984
    .lex "$/", param_2985
.annotate 'line', 1316
    new $P2986, "Undef"
    .lex "$block", $P2986
.annotate 'line', 1318
    new $P2987, "Undef"
    .lex "$past", $P2987
.annotate 'line', 1316
    find_lex $P2988, "$/"
    unless_null $P2988, vivify_894
    $P2988 = root_new ['parrot';'Hash']
  vivify_894:
    set $P2989, $P2988["block"]
    unless_null $P2989, vivify_895
    new $P2989, "Undef"
  vivify_895:
    $P2990 = $P2989."ast"()
    store_lex "$block", $P2990
.annotate 'line', 1317
    find_lex $P2991, "$block"
    $P2991."blocktype"("immediate")
.annotate 'line', 1319
    get_hll_global $P2992, ["PAST"], "Stmts"
.annotate 'line', 1320
    get_hll_global $P2993, ["PAST"], "Op"
.annotate 'line', 1321
    get_hll_global $P2994, ["PAST"], "Var"
    $P2995 = $P2994."new"("$/" :named("name"))
.annotate 'line', 1322
    get_hll_global $P2996, ["PAST"], "Op"
.annotate 'line', 1323
    get_hll_global $P2997, ["PAST"], "Var"
    $P2998 = $P2997."new"(unicode:"$\x{a2}" :named("name"))
    $P2999 = $P2996."new"($P2998, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1322
    $P3000 = $P2993."new"($P2995, $P2999, "bind" :named("pasttype"))
.annotate 'line', 1320
    find_lex $P3001, "$block"
    $P3002 = $P2992."new"($P3000, $P3001)
.annotate 'line', 1319
    store_lex "$past", $P3002
.annotate 'line', 1331
    find_lex $P3003, "$/"
    find_lex $P3004, "$past"
    $P3005 = $P3003."!make"($P3004)
.annotate 'line', 1315
    .return ($P3005)
.end


.namespace ["NQP";"Actions"]
.sub "_block3030" :load :anon :subid("169_1298845576.421")
.annotate 'line', 3
    .const 'Sub' $P3032 = "11_1298845576.421" 
    $P3033 = $P3032()
    .return ($P3033)
.end


.namespace []
.sub "_block3257" :load :anon :subid("171_1298845576.421")
.annotate 'line', 1
    .const 'Sub' $P3259 = "10_1298845576.421" 
    $P3260 = $P3259()
    .return ($P3260)
.end

### .include 'gen/nqp-compiler.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298845585.328")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
    $P25 = $P15()
    .return ($P25)
    .const 'Sub' $P27 = "13_1298845585.328" 
    .return ($P27)
.end


.namespace ["NQP";"Compiler"]
.sub "_block14"  :subid("11_1298845585.328") :outer("10_1298845585.328")
.annotate 'line', 1
    .const 'Sub' $P18 = "12_1298845585.328" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    .return ()
.end


.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post14") :outer("11_1298845585.328")
.annotate 'line', 1
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P18 = "12_1298845585.328" 
    capture_lex $P18
    $P18()
.end


.namespace ["NQP";"Compiler"]
.sub "_block17"  :anon :subid("12_1298845585.328") :outer("11_1298845585.328")
.annotate 'line', 1
    get_hll_global $P19, "NQPClassHOW"
    $P20 = $P19."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P20
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P21, type_obj
    get_hll_global $P22, ["HLL"], "Compiler"
    $P21."add_parent"(type_obj, $P22)
    get_how $P23, type_obj
    $P24 = $P23."compose"(type_obj)
    .return ($P24)
.end


.namespace []
.sub "_block26" :load :anon :subid("13_1298845585.328")
.annotate 'line', 1
    .const 'Sub' $P28 = "10_1298845585.328" 
    $P29 = $P28()
    .return ($P29)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " - "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'skip'
    .param string desc

    print 'ok '
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    print " # SKIP "
    print desc
    print "\n"
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('NQP-rx')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
    push $P0, 'setting=s'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'NQP-rx'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
