
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303603603.711")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P6270 = "577_1303603603.711" 
    capture_lex $P6270
    .const 'Sub' $P6149 = "568_1303603603.711" 
    capture_lex $P6149
    .const 'Sub' $P2599 = "406_1303603603.711" 
    capture_lex $P2599
    .const 'Sub' $P2495 = "384_1303603603.711" 
    capture_lex $P2495
    .const 'Sub' $P38 = "12_1303603603.711" 
    capture_lex $P38
    .const 'Sub' $P16 = "11_1303603603.711" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2300
    .const 'Sub' $P16 = "11_1303603603.711" 
    newclosure $P36, $P16
    .lex "MAIN", $P36
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P38 = "12_1303603603.711" 
    capture_lex $P38
    $P38()
.annotate 'line', 727
    .const 'Sub' $P2495 = "384_1303603603.711" 
    capture_lex $P2495
    $P2495()
.annotate 'line', 770
    .const 'Sub' $P2599 = "406_1303603603.711" 
    capture_lex $P2599
    $P2599()
.annotate 'line', 2242
    .const 'Sub' $P6149 = "568_1303603603.711" 
    capture_lex $P6149
    $P6149()
.annotate 'line', 2297
    .const 'Sub' $P6270 = "577_1303603603.711" 
    capture_lex $P6270
    $P6270()
    find_lex $P6280, "MAIN"
    find_lex $P6283, "@ARGS"
    if $P6283, if_6282
    set $P6281, $P6283
    goto if_6282_end
  if_6282:
    .const 'Sub' $P6284 = "11_1303603603.711" 
    find_lex $P6285, "@ARGS"
    $P6286 = $P6284($P6285 :flat)
    set $P6281, $P6286
  if_6282_end:
.annotate 'line', 1
    .return ($P6281)
    .const 'Sub' $P6288 = "579_1303603603.711" 
    .return ($P6288)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post580") :outer("10_1303603603.711")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303603603.711" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6292, "1303603591.505"
    isnull $I6293, $P6292
    if $I6293, if_6291
    .const 'Sub' $P6399 = "10_1303603603.711" 
    $P6400 = $P6399."get_lexinfo"()
    nqp_get_sc_object $P6401, "1303603591.505", 0
    $P6400."set_static_lexpad_value"("GLOBALish", $P6401)
    .const 'Sub' $P6402 = "10_1303603603.711" 
    $P6403 = $P6402."get_lexinfo"()
    $P6403."finish_static_lexpad"()
    .const 'Sub' $P6404 = "10_1303603603.711" 
    $P6405 = $P6404."get_lexinfo"()
    nqp_get_sc_object $P6406, "1303603591.505", 0
    $P6405."set_static_lexpad_value"("$?PACKAGE", $P6406)
    .const 'Sub' $P6407 = "10_1303603603.711" 
    $P6408 = $P6407."get_lexinfo"()
    $P6408."finish_static_lexpad"()
    nqp_get_sc_object $P6409, "1303603591.505", 1
    set_hll_global ["NQP"], "Grammar", $P6409
    .const 'Sub' $P6410 = "12_1303603603.711" 
    $P6411 = $P6410."get_lexinfo"()
    nqp_get_sc_object $P6412, "1303603591.505", 1
    $P6411."set_static_lexpad_value"("$?PACKAGE", $P6412)
    .const 'Sub' $P6413 = "12_1303603603.711" 
    $P6414 = $P6413."get_lexinfo"()
    $P6414."finish_static_lexpad"()
    .const 'Sub' $P6415 = "12_1303603603.711" 
    $P6416 = $P6415."get_lexinfo"()
    nqp_get_sc_object $P6417, "1303603591.505", 1
    $P6416."set_static_lexpad_value"("$?CLASS", $P6417)
    .const 'Sub' $P6418 = "12_1303603603.711" 
    $P6419 = $P6418."get_lexinfo"()
    $P6419."finish_static_lexpad"()
    nqp_get_sc_object $P6420, "1303603591.505", 2
    set_hll_global ["NQP"], "Regex", $P6420
    .const 'Sub' $P6421 = "384_1303603603.711" 
    $P6422 = $P6421."get_lexinfo"()
    nqp_get_sc_object $P6423, "1303603591.505", 2
    $P6422."set_static_lexpad_value"("$?PACKAGE", $P6423)
    .const 'Sub' $P6424 = "384_1303603603.711" 
    $P6425 = $P6424."get_lexinfo"()
    $P6425."finish_static_lexpad"()
    .const 'Sub' $P6426 = "384_1303603603.711" 
    $P6427 = $P6426."get_lexinfo"()
    nqp_get_sc_object $P6428, "1303603591.505", 2
    $P6427."set_static_lexpad_value"("$?CLASS", $P6428)
    .const 'Sub' $P6429 = "384_1303603603.711" 
    $P6430 = $P6429."get_lexinfo"()
    $P6430."finish_static_lexpad"()
    nqp_get_sc_object $P6431, "1303603591.505", 3
    set_hll_global ["NQP"], "Actions", $P6431
    .const 'Sub' $P6432 = "406_1303603603.711" 
    $P6433 = $P6432."get_lexinfo"()
    nqp_get_sc_object $P6434, "1303603591.505", 3
    $P6433."set_static_lexpad_value"("$?PACKAGE", $P6434)
    .const 'Sub' $P6435 = "406_1303603603.711" 
    $P6436 = $P6435."get_lexinfo"()
    $P6436."finish_static_lexpad"()
    .const 'Sub' $P6437 = "406_1303603603.711" 
    $P6438 = $P6437."get_lexinfo"()
    nqp_get_sc_object $P6439, "1303603591.505", 3
    $P6438."set_static_lexpad_value"("$?CLASS", $P6439)
    .const 'Sub' $P6440 = "406_1303603603.711" 
    $P6441 = $P6440."get_lexinfo"()
    $P6441."finish_static_lexpad"()
    nqp_get_sc_object $P6442, "1303603591.505", 4
    set_hll_global ["NQP"], "RegexActions", $P6442
    .const 'Sub' $P6443 = "568_1303603603.711" 
    $P6444 = $P6443."get_lexinfo"()
    nqp_get_sc_object $P6445, "1303603591.505", 4
    $P6444."set_static_lexpad_value"("$?PACKAGE", $P6445)
    .const 'Sub' $P6446 = "568_1303603603.711" 
    $P6447 = $P6446."get_lexinfo"()
    $P6447."finish_static_lexpad"()
    .const 'Sub' $P6448 = "568_1303603603.711" 
    $P6449 = $P6448."get_lexinfo"()
    nqp_get_sc_object $P6450, "1303603591.505", 4
    $P6449."set_static_lexpad_value"("$?CLASS", $P6450)
    .const 'Sub' $P6451 = "568_1303603603.711" 
    $P6452 = $P6451."get_lexinfo"()
    $P6452."finish_static_lexpad"()
    nqp_get_sc_object $P6453, "1303603591.505", 5
    set_hll_global ["NQP"], "Compiler", $P6453
    .const 'Sub' $P6454 = "577_1303603603.711" 
    $P6455 = $P6454."get_lexinfo"()
    nqp_get_sc_object $P6456, "1303603591.505", 5
    $P6455."set_static_lexpad_value"("$?PACKAGE", $P6456)
    .const 'Sub' $P6457 = "577_1303603603.711" 
    $P6458 = $P6457."get_lexinfo"()
    $P6458."finish_static_lexpad"()
    .const 'Sub' $P6459 = "577_1303603603.711" 
    $P6460 = $P6459."get_lexinfo"()
    nqp_get_sc_object $P6461, "1303603591.505", 5
    $P6460."set_static_lexpad_value"("$?CLASS", $P6461)
    .const 'Sub' $P6462 = "577_1303603603.711" 
    $P6463 = $P6462."get_lexinfo"()
    $P6463."finish_static_lexpad"()
    goto if_6291_end
  if_6291:
    nqp_dynop_setup 
    getinterp $P6294
    get_class $P6295, "LexPad"
    get_class $P6296, "NQPLexPad"
    $P6294."hll_map"($P6295, $P6296)
    nqp_create_sc $P6297, "1303603591.505"
    .local pmc cur_sc
    set cur_sc, $P6297
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6298, "ModuleLoader"
    $P6299 = $P6298."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6299)
    get_hll_global $P6300, "KnowHOW"
    $P6301 = $P6300."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6301, cur_sc
    nqp_set_sc_object "1303603591.505", 0, $P6301
    .const 'Sub' $P6302 = "10_1303603603.711" 
    $P6303 = $P6302."get_lexinfo"()
    nqp_get_sc_object $P6304, "1303603591.505", 0
    $P6303."set_static_lexpad_value"("GLOBALish", $P6304)
    .const 'Sub' $P6305 = "10_1303603603.711" 
    $P6306 = $P6305."get_lexinfo"()
    $P6306."finish_static_lexpad"()
    .const 'Sub' $P6307 = "10_1303603603.711" 
    $P6308 = $P6307."get_lexinfo"()
    nqp_get_sc_object $P6309, "1303603591.505", 0
    $P6308."set_static_lexpad_value"("$?PACKAGE", $P6309)
    .const 'Sub' $P6310 = "10_1303603603.711" 
    $P6311 = $P6310."get_lexinfo"()
    $P6311."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6312, "ModuleLoader"
    nqp_get_sc_object $P6313, "1303603591.505", 0
    $P6312."load_module"("P6Regex", $P6313)
    get_hll_global $P6314, "NQPClassHOW"
    $P6315 = $P6314."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6315, cur_sc
    nqp_set_sc_object "1303603591.505", 1, $P6315
    nqp_get_sc_object $P6316, "1303603591.505", 1
    nqp_get_sc_object $P6317, "1303603591.505", 0
    nqp_get_package_through_who $P6318, $P6317, "NQP"
    get_who $P6319, $P6318
    set $P6319["Grammar"], $P6316
    nqp_get_sc_object $P6320, "1303603591.505", 1
    set_hll_global ["NQP"], "Grammar", $P6320
    .const 'Sub' $P6321 = "12_1303603603.711" 
    $P6322 = $P6321."get_lexinfo"()
    nqp_get_sc_object $P6323, "1303603591.505", 1
    $P6322."set_static_lexpad_value"("$?PACKAGE", $P6323)
    .const 'Sub' $P6324 = "12_1303603603.711" 
    $P6325 = $P6324."get_lexinfo"()
    $P6325."finish_static_lexpad"()
    .const 'Sub' $P6326 = "12_1303603603.711" 
    $P6327 = $P6326."get_lexinfo"()
    nqp_get_sc_object $P6328, "1303603591.505", 1
    $P6327."set_static_lexpad_value"("$?CLASS", $P6328)
    .const 'Sub' $P6329 = "12_1303603603.711" 
    $P6330 = $P6329."get_lexinfo"()
    $P6330."finish_static_lexpad"()
    get_hll_global $P6331, "NQPClassHOW"
    $P6332 = $P6331."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P6332, cur_sc
    nqp_set_sc_object "1303603591.505", 2, $P6332
    nqp_get_sc_object $P6333, "1303603591.505", 2
    nqp_get_sc_object $P6334, "1303603591.505", 0
    nqp_get_package_through_who $P6335, $P6334, "NQP"
    get_who $P6336, $P6335
    set $P6336["Regex"], $P6333
    nqp_get_sc_object $P6337, "1303603591.505", 2
    set_hll_global ["NQP"], "Regex", $P6337
    .const 'Sub' $P6338 = "384_1303603603.711" 
    $P6339 = $P6338."get_lexinfo"()
    nqp_get_sc_object $P6340, "1303603591.505", 2
    $P6339."set_static_lexpad_value"("$?PACKAGE", $P6340)
    .const 'Sub' $P6341 = "384_1303603603.711" 
    $P6342 = $P6341."get_lexinfo"()
    $P6342."finish_static_lexpad"()
    .const 'Sub' $P6343 = "384_1303603603.711" 
    $P6344 = $P6343."get_lexinfo"()
    nqp_get_sc_object $P6345, "1303603591.505", 2
    $P6344."set_static_lexpad_value"("$?CLASS", $P6345)
    .const 'Sub' $P6346 = "384_1303603603.711" 
    $P6347 = $P6346."get_lexinfo"()
    $P6347."finish_static_lexpad"()
    get_hll_global $P6348, "NQPClassHOW"
    $P6349 = $P6348."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P6349, cur_sc
    nqp_set_sc_object "1303603591.505", 3, $P6349
    nqp_get_sc_object $P6350, "1303603591.505", 3
    nqp_get_sc_object $P6351, "1303603591.505", 0
    nqp_get_package_through_who $P6352, $P6351, "NQP"
    get_who $P6353, $P6352
    set $P6353["Actions"], $P6350
    nqp_get_sc_object $P6354, "1303603591.505", 3
    set_hll_global ["NQP"], "Actions", $P6354
    .const 'Sub' $P6355 = "406_1303603603.711" 
    $P6356 = $P6355."get_lexinfo"()
    nqp_get_sc_object $P6357, "1303603591.505", 3
    $P6356."set_static_lexpad_value"("$?PACKAGE", $P6357)
    .const 'Sub' $P6358 = "406_1303603603.711" 
    $P6359 = $P6358."get_lexinfo"()
    $P6359."finish_static_lexpad"()
    .const 'Sub' $P6360 = "406_1303603603.711" 
    $P6361 = $P6360."get_lexinfo"()
    nqp_get_sc_object $P6362, "1303603591.505", 3
    $P6361."set_static_lexpad_value"("$?CLASS", $P6362)
    .const 'Sub' $P6363 = "406_1303603603.711" 
    $P6364 = $P6363."get_lexinfo"()
    $P6364."finish_static_lexpad"()
    get_hll_global $P6365, "NQPClassHOW"
    $P6366 = $P6365."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P6366, cur_sc
    nqp_set_sc_object "1303603591.505", 4, $P6366
    nqp_get_sc_object $P6367, "1303603591.505", 4
    nqp_get_sc_object $P6368, "1303603591.505", 0
    nqp_get_package_through_who $P6369, $P6368, "NQP"
    get_who $P6370, $P6369
    set $P6370["RegexActions"], $P6367
    nqp_get_sc_object $P6371, "1303603591.505", 4
    set_hll_global ["NQP"], "RegexActions", $P6371
    .const 'Sub' $P6372 = "568_1303603603.711" 
    $P6373 = $P6372."get_lexinfo"()
    nqp_get_sc_object $P6374, "1303603591.505", 4
    $P6373."set_static_lexpad_value"("$?PACKAGE", $P6374)
    .const 'Sub' $P6375 = "568_1303603603.711" 
    $P6376 = $P6375."get_lexinfo"()
    $P6376."finish_static_lexpad"()
    .const 'Sub' $P6377 = "568_1303603603.711" 
    $P6378 = $P6377."get_lexinfo"()
    nqp_get_sc_object $P6379, "1303603591.505", 4
    $P6378."set_static_lexpad_value"("$?CLASS", $P6379)
    .const 'Sub' $P6380 = "568_1303603603.711" 
    $P6381 = $P6380."get_lexinfo"()
    $P6381."finish_static_lexpad"()
    get_hll_global $P6382, "NQPClassHOW"
    $P6383 = $P6382."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P6383, cur_sc
    nqp_set_sc_object "1303603591.505", 5, $P6383
    nqp_get_sc_object $P6384, "1303603591.505", 5
    nqp_get_sc_object $P6385, "1303603591.505", 0
    nqp_get_package_through_who $P6386, $P6385, "NQP"
    get_who $P6387, $P6386
    set $P6387["Compiler"], $P6384
    nqp_get_sc_object $P6388, "1303603591.505", 5
    set_hll_global ["NQP"], "Compiler", $P6388
    .const 'Sub' $P6389 = "577_1303603603.711" 
    $P6390 = $P6389."get_lexinfo"()
    nqp_get_sc_object $P6391, "1303603591.505", 5
    $P6390."set_static_lexpad_value"("$?PACKAGE", $P6391)
    .const 'Sub' $P6392 = "577_1303603603.711" 
    $P6393 = $P6392."get_lexinfo"()
    $P6393."finish_static_lexpad"()
    .const 'Sub' $P6394 = "577_1303603603.711" 
    $P6395 = $P6394."get_lexinfo"()
    nqp_get_sc_object $P6396, "1303603591.505", 5
    $P6395."set_static_lexpad_value"("$?CLASS", $P6396)
    .const 'Sub' $P6397 = "577_1303603603.711" 
    $P6398 = $P6397."get_lexinfo"()
    $P6398."finish_static_lexpad"()
  if_6291_end:
    nqp_get_sc_object $P6464, "1303603591.505", 0
    set_hll_global "GLOBAL", $P6464
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303603603.711") :outer("10_1303603603.711")
    .param pmc param_17
.annotate 'line', 2300
    .lex "@ARGS", param_17
.annotate 'line', 2302
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2308
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2302
    get_hll_global $P20, ["NQP"], "Compiler"
    $P21 = $P20."new"()
    store_lex "$nqpcomp", $P21
.annotate 'line', 2303
    find_lex $P22, "$nqpcomp"
    unless_null $P22, vivify_581
    new $P22, "Undef"
  vivify_581:
    $P22."language"("nqp")
.annotate 'line', 2304
    find_lex $P23, "$nqpcomp"
    unless_null $P23, vivify_582
    new $P23, "Undef"
  vivify_582:
    get_hll_global $P24, ["NQP"], "Grammar"
    $P23."parsegrammar"($P24)
.annotate 'line', 2305
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_583
    new $P25, "Undef"
  vivify_583:
    get_hll_global $P26, ["NQP"], "Actions"
    $P25."parseactions"($P26)
.annotate 'line', 2308
    find_lex $P27, "$nqpcomp"
    unless_null $P27, vivify_584
    new $P27, "Undef"
  vivify_584:
    $P28 = $P27."commandline_options"()
    store_lex "@clo", $P28
.annotate 'line', 2309
    find_lex $P29, "@clo"
    unless_null $P29, vivify_585
    $P29 = root_new ['parrot';'ResizablePMCArray']
  vivify_585:
    $P29."push"("parsetrace")
.annotate 'line', 2310
    find_lex $P30, "@clo"
    unless_null $P30, vivify_586
    $P30 = root_new ['parrot';'ResizablePMCArray']
  vivify_586:
    $P30."push"("setting=s")
.annotate 'line', 2311
    find_lex $P31, "@clo"
    unless_null $P31, vivify_587
    $P31 = root_new ['parrot';'ResizablePMCArray']
  vivify_587:
    $P31."push"("setting-path=s")
.annotate 'line', 2312
    find_lex $P32, "@clo"
    unless_null $P32, vivify_588
    $P32 = root_new ['parrot';'ResizablePMCArray']
  vivify_588:
    $P32."push"("module-path=s")
.annotate 'line', 2315
    find_lex $P33, "$nqpcomp"
    unless_null $P33, vivify_589
    new $P33, "Undef"
  vivify_589:
    find_lex $P34, "@ARGS"
    unless_null $P34, vivify_590
    $P34 = root_new ['parrot';'ResizablePMCArray']
  vivify_590:
    $P35 = $P33."command_line"($P34, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2300
    .return ($P35)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block37"  :subid("12_1303603603.711") :outer("10_1303603603.711")
.annotate 'line', 9
    .const 'Sub' $P1772 = "383_1303603603.711" 
    capture_lex $P1772
    .const 'Sub' $P1759 = "382_1303603603.711" 
    capture_lex $P1759
    .const 'Sub' $P1753 = "380_1303603603.711" 
    capture_lex $P1753
    .const 'Sub' $P1747 = "378_1303603603.711" 
    capture_lex $P1747
    .const 'Sub' $P1741 = "376_1303603603.711" 
    capture_lex $P1741
    .const 'Sub' $P1735 = "374_1303603603.711" 
    capture_lex $P1735
    .const 'Sub' $P1723 = "371_1303603603.711" 
    capture_lex $P1723
    .const 'Sub' $P1716 = "369_1303603603.711" 
    capture_lex $P1716
    .const 'Sub' $P1709 = "367_1303603603.711" 
    capture_lex $P1709
    .const 'Sub' $P1702 = "365_1303603603.711" 
    capture_lex $P1702
    .const 'Sub' $P1695 = "363_1303603603.711" 
    capture_lex $P1695
    .const 'Sub' $P1689 = "361_1303603603.711" 
    capture_lex $P1689
    .const 'Sub' $P1682 = "359_1303603603.711" 
    capture_lex $P1682
    .const 'Sub' $P1675 = "357_1303603603.711" 
    capture_lex $P1675
    .const 'Sub' $P1668 = "355_1303603603.711" 
    capture_lex $P1668
    .const 'Sub' $P1661 = "353_1303603603.711" 
    capture_lex $P1661
    .const 'Sub' $P1654 = "351_1303603603.711" 
    capture_lex $P1654
    .const 'Sub' $P1647 = "349_1303603603.711" 
    capture_lex $P1647
    .const 'Sub' $P1640 = "347_1303603603.711" 
    capture_lex $P1640
    .const 'Sub' $P1633 = "345_1303603603.711" 
    capture_lex $P1633
    .const 'Sub' $P1626 = "343_1303603603.711" 
    capture_lex $P1626
    .const 'Sub' $P1619 = "341_1303603603.711" 
    capture_lex $P1619
    .const 'Sub' $P1612 = "339_1303603603.711" 
    capture_lex $P1612
    .const 'Sub' $P1605 = "337_1303603603.711" 
    capture_lex $P1605
    .const 'Sub' $P1598 = "335_1303603603.711" 
    capture_lex $P1598
    .const 'Sub' $P1591 = "333_1303603603.711" 
    capture_lex $P1591
    .const 'Sub' $P1584 = "331_1303603603.711" 
    capture_lex $P1584
    .const 'Sub' $P1577 = "329_1303603603.711" 
    capture_lex $P1577
    .const 'Sub' $P1570 = "327_1303603603.711" 
    capture_lex $P1570
    .const 'Sub' $P1563 = "325_1303603603.711" 
    capture_lex $P1563
    .const 'Sub' $P1556 = "323_1303603603.711" 
    capture_lex $P1556
    .const 'Sub' $P1549 = "321_1303603603.711" 
    capture_lex $P1549
    .const 'Sub' $P1542 = "319_1303603603.711" 
    capture_lex $P1542
    .const 'Sub' $P1535 = "317_1303603603.711" 
    capture_lex $P1535
    .const 'Sub' $P1528 = "315_1303603603.711" 
    capture_lex $P1528
    .const 'Sub' $P1521 = "313_1303603603.711" 
    capture_lex $P1521
    .const 'Sub' $P1514 = "311_1303603603.711" 
    capture_lex $P1514
    .const 'Sub' $P1507 = "309_1303603603.711" 
    capture_lex $P1507
    .const 'Sub' $P1500 = "307_1303603603.711" 
    capture_lex $P1500
    .const 'Sub' $P1493 = "305_1303603603.711" 
    capture_lex $P1493
    .const 'Sub' $P1486 = "303_1303603603.711" 
    capture_lex $P1486
    .const 'Sub' $P1480 = "301_1303603603.711" 
    capture_lex $P1480
    .const 'Sub' $P1473 = "299_1303603603.711" 
    capture_lex $P1473
    .const 'Sub' $P1466 = "297_1303603603.711" 
    capture_lex $P1466
    .const 'Sub' $P1459 = "295_1303603603.711" 
    capture_lex $P1459
    .const 'Sub' $P1452 = "293_1303603603.711" 
    capture_lex $P1452
    .const 'Sub' $P1445 = "291_1303603603.711" 
    capture_lex $P1445
    .const 'Sub' $P1438 = "289_1303603603.711" 
    capture_lex $P1438
    .const 'Sub' $P1431 = "287_1303603603.711" 
    capture_lex $P1431
    .const 'Sub' $P1425 = "285_1303603603.711" 
    capture_lex $P1425
    .const 'Sub' $P1419 = "283_1303603603.711" 
    capture_lex $P1419
    .const 'Sub' $P1414 = "281_1303603603.711" 
    capture_lex $P1414
    .const 'Sub' $P1408 = "279_1303603603.711" 
    capture_lex $P1408
    .const 'Sub' $P1402 = "277_1303603603.711" 
    capture_lex $P1402
    .const 'Sub' $P1397 = "275_1303603603.711" 
    capture_lex $P1397
    .const 'Sub' $P1392 = "273_1303603603.711" 
    capture_lex $P1392
    .const 'Sub' $P1384 = "271_1303603603.711" 
    capture_lex $P1384
    .const 'Sub' $P1375 = "269_1303603603.711" 
    capture_lex $P1375
    .const 'Sub' $P1370 = "267_1303603603.711" 
    capture_lex $P1370
    .const 'Sub' $P1365 = "265_1303603603.711" 
    capture_lex $P1365
    .const 'Sub' $P1360 = "263_1303603603.711" 
    capture_lex $P1360
    .const 'Sub' $P1352 = "261_1303603603.711" 
    capture_lex $P1352
    .const 'Sub' $P1344 = "259_1303603603.711" 
    capture_lex $P1344
    .const 'Sub' $P1339 = "257_1303603603.711" 
    capture_lex $P1339
    .const 'Sub' $P1334 = "255_1303603603.711" 
    capture_lex $P1334
    .const 'Sub' $P1329 = "253_1303603603.711" 
    capture_lex $P1329
    .const 'Sub' $P1323 = "251_1303603603.711" 
    capture_lex $P1323
    .const 'Sub' $P1316 = "249_1303603603.711" 
    capture_lex $P1316
    .const 'Sub' $P1309 = "247_1303603603.711" 
    capture_lex $P1309
    .const 'Sub' $P1302 = "245_1303603603.711" 
    capture_lex $P1302
    .const 'Sub' $P1295 = "243_1303603603.711" 
    capture_lex $P1295
    .const 'Sub' $P1290 = "241_1303603603.711" 
    capture_lex $P1290
    .const 'Sub' $P1285 = "239_1303603603.711" 
    capture_lex $P1285
    .const 'Sub' $P1271 = "235_1303603603.711" 
    capture_lex $P1271
    .const 'Sub' $P1263 = "233_1303603603.711" 
    capture_lex $P1263
    .const 'Sub' $P1257 = "231_1303603603.711" 
    capture_lex $P1257
    .const 'Sub' $P1250 = "229_1303603603.711" 
    capture_lex $P1250
    .const 'Sub' $P1244 = "227_1303603603.711" 
    capture_lex $P1244
    .const 'Sub' $P1230 = "224_1303603603.711" 
    capture_lex $P1230
    .const 'Sub' $P1222 = "222_1303603603.711" 
    capture_lex $P1222
    .const 'Sub' $P1214 = "220_1303603603.711" 
    capture_lex $P1214
    .const 'Sub' $P1208 = "218_1303603603.711" 
    capture_lex $P1208
    .const 'Sub' $P1202 = "216_1303603603.711" 
    capture_lex $P1202
    .const 'Sub' $P1186 = "212_1303603603.711" 
    capture_lex $P1186
    .const 'Sub' $P1145 = "210_1303603603.711" 
    capture_lex $P1145
    .const 'Sub' $P1134 = "208_1303603603.711" 
    capture_lex $P1134
    .const 'Sub' $P1120 = "204_1303603603.711" 
    capture_lex $P1120
    .const 'Sub' $P1111 = "202_1303603603.711" 
    capture_lex $P1111
    .const 'Sub' $P1105 = "200_1303603603.711" 
    capture_lex $P1105
    .const 'Sub' $P1095 = "198_1303603603.711" 
    capture_lex $P1095
    .const 'Sub' $P1080 = "196_1303603603.711" 
    capture_lex $P1080
    .const 'Sub' $P1066 = "193_1303603603.711" 
    capture_lex $P1066
    .const 'Sub' $P1058 = "191_1303603603.711" 
    capture_lex $P1058
    .const 'Sub' $P1048 = "189_1303603603.711" 
    capture_lex $P1048
    .const 'Sub' $P1038 = "187_1303603603.711" 
    capture_lex $P1038
    .const 'Sub' $P1019 = "182_1303603603.711" 
    capture_lex $P1019
    .const 'Sub' $P975 = "179_1303603603.711" 
    capture_lex $P975
    .const 'Sub' $P941 = "177_1303603603.711" 
    capture_lex $P941
    .const 'Sub' $P934 = "175_1303603603.711" 
    capture_lex $P934
    .const 'Sub' $P927 = "173_1303603603.711" 
    capture_lex $P927
    .const 'Sub' $P910 = "169_1303603603.711" 
    capture_lex $P910
    .const 'Sub' $P902 = "167_1303603603.711" 
    capture_lex $P902
    .const 'Sub' $P896 = "165_1303603603.711" 
    capture_lex $P896
    .const 'Sub' $P880 = "163_1303603603.711" 
    capture_lex $P880
    .const 'Sub' $P873 = "161_1303603603.711" 
    capture_lex $P873
    .const 'Sub' $P866 = "159_1303603603.711" 
    capture_lex $P866
    .const 'Sub' $P859 = "157_1303603603.711" 
    capture_lex $P859
    .const 'Sub' $P717 = "152_1303603603.711" 
    capture_lex $P717
    .const 'Sub' $P703 = "150_1303603603.711" 
    capture_lex $P703
    .const 'Sub' $P689 = "148_1303603603.711" 
    capture_lex $P689
    .const 'Sub' $P675 = "146_1303603603.711" 
    capture_lex $P675
    .const 'Sub' $P661 = "144_1303603603.711" 
    capture_lex $P661
    .const 'Sub' $P647 = "142_1303603603.711" 
    capture_lex $P647
    .const 'Sub' $P633 = "140_1303603603.711" 
    capture_lex $P633
    .const 'Sub' $P622 = "136_1303603603.711" 
    capture_lex $P622
    .const 'Sub' $P617 = "134_1303603603.711" 
    capture_lex $P617
    .const 'Sub' $P605 = "132_1303603603.711" 
    capture_lex $P605
    .const 'Sub' $P593 = "130_1303603603.711" 
    capture_lex $P593
    .const 'Sub' $P586 = "128_1303603603.711" 
    capture_lex $P586
    .const 'Sub' $P581 = "126_1303603603.711" 
    capture_lex $P581
    .const 'Sub' $P575 = "124_1303603603.711" 
    capture_lex $P575
    .const 'Sub' $P569 = "122_1303603603.711" 
    capture_lex $P569
    .const 'Sub' $P554 = "118_1303603603.711" 
    capture_lex $P554
    .const 'Sub' $P548 = "116_1303603603.711" 
    capture_lex $P548
    .const 'Sub' $P542 = "114_1303603603.711" 
    capture_lex $P542
    .const 'Sub' $P536 = "112_1303603603.711" 
    capture_lex $P536
    .const 'Sub' $P530 = "110_1303603603.711" 
    capture_lex $P530
    .const 'Sub' $P524 = "108_1303603603.711" 
    capture_lex $P524
    .const 'Sub' $P518 = "106_1303603603.711" 
    capture_lex $P518
    .const 'Sub' $P509 = "104_1303603603.711" 
    capture_lex $P509
    .const 'Sub' $P500 = "102_1303603603.711" 
    capture_lex $P500
    .const 'Sub' $P491 = "100_1303603603.711" 
    capture_lex $P491
    .const 'Sub' $P476 = "96_1303603603.711" 
    capture_lex $P476
    .const 'Sub' $P467 = "94_1303603603.711" 
    capture_lex $P467
    .const 'Sub' $P455 = "90_1303603603.711" 
    capture_lex $P455
    .const 'Sub' $P448 = "88_1303603603.711" 
    capture_lex $P448
    .const 'Sub' $P441 = "86_1303603603.711" 
    capture_lex $P441
    .const 'Sub' $P427 = "82_1303603603.711" 
    capture_lex $P427
    .const 'Sub' $P419 = "80_1303603603.711" 
    capture_lex $P419
    .const 'Sub' $P411 = "78_1303603603.711" 
    capture_lex $P411
    .const 'Sub' $P391 = "76_1303603603.711" 
    capture_lex $P391
    .const 'Sub' $P382 = "74_1303603603.711" 
    capture_lex $P382
    .const 'Sub' $P364 = "71_1303603603.711" 
    capture_lex $P364
    .const 'Sub' $P346 = "69_1303603603.711" 
    capture_lex $P346
    .const 'Sub' $P338 = "67_1303603603.711" 
    capture_lex $P338
    .const 'Sub' $P327 = "63_1303603603.711" 
    capture_lex $P327
    .const 'Sub' $P322 = "61_1303603603.711" 
    capture_lex $P322
    .const 'Sub' $P311 = "57_1303603603.711" 
    capture_lex $P311
    .const 'Sub' $P306 = "55_1303603603.711" 
    capture_lex $P306
    .const 'Sub' $P301 = "53_1303603603.711" 
    capture_lex $P301
    .const 'Sub' $P296 = "51_1303603603.711" 
    capture_lex $P296
    .const 'Sub' $P291 = "49_1303603603.711" 
    capture_lex $P291
    .const 'Sub' $P281 = "47_1303603603.711" 
    capture_lex $P281
    .const 'Sub' $P274 = "45_1303603603.711" 
    capture_lex $P274
    .const 'Sub' $P268 = "43_1303603603.711" 
    capture_lex $P268
    .const 'Sub' $P260 = "41_1303603603.711" 
    capture_lex $P260
    .const 'Sub' $P254 = "39_1303603603.711" 
    capture_lex $P254
    .const 'Sub' $P248 = "37_1303603603.711" 
    capture_lex $P248
    .const 'Sub' $P233 = "34_1303603603.711" 
    capture_lex $P233
    .const 'Sub' $P219 = "32_1303603603.711" 
    capture_lex $P219
    .const 'Sub' $P204 = "30_1303603603.711" 
    capture_lex $P204
    .const 'Sub' $P165 = "27_1303603603.711" 
    capture_lex $P165
    .const 'Sub' $P150 = "24_1303603603.711" 
    capture_lex $P150
    .const 'Sub' $P139 = "22_1303603603.711" 
    capture_lex $P139
    .const 'Sub' $P127 = "20_1303603603.711" 
    capture_lex $P127
    .const 'Sub' $P119 = "18_1303603603.711" 
    capture_lex $P119
    .const 'Sub' $P112 = "16_1303603603.711" 
    capture_lex $P112
    .const 'Sub' $P105 = "14_1303603603.711" 
    capture_lex $P105
    .const 'Sub' $P56 = "13_1303603603.711" 
    capture_lex $P56
    .lex "$?PACKAGE", $P39
    .lex "$?CLASS", $P40
.annotate 'line', 608
    get_hll_global $P41, ["NQP"], "Grammar"
    $P41."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 609
    get_hll_global $P42, ["NQP"], "Grammar"
    $P42."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 610
    get_hll_global $P43, ["NQP"], "Grammar"
    $P43."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 611
    get_hll_global $P44, ["NQP"], "Grammar"
    $P44."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 612
    get_hll_global $P45, ["NQP"], "Grammar"
    $P45."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 613
    get_hll_global $P46, ["NQP"], "Grammar"
    $P46."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 614
    get_hll_global $P47, ["NQP"], "Grammar"
    $P47."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 615
    get_hll_global $P48, ["NQP"], "Grammar"
    $P48."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 616
    get_hll_global $P49, ["NQP"], "Grammar"
    $P49."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 617
    get_hll_global $P50, ["NQP"], "Grammar"
    $P50."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 618
    get_hll_global $P51, ["NQP"], "Grammar"
    $P51."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 619
    get_hll_global $P52, ["NQP"], "Grammar"
    $P52."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 620
    get_hll_global $P53, ["NQP"], "Grammar"
    $P53."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 621
    get_hll_global $P54, ["NQP"], "Grammar"
    $P54."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 622
    get_hll_global $P55, ["NQP"], "Grammar"
    $P55."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 721
    .const 'Sub' $P1759 = "382_1303603603.711" 
    newclosure $P1770, $P1759
.annotate 'line', 9
    .return ($P1770)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post591") :outer("12_1303603603.711")
.annotate 'line', 9
    .const 'Sub' $P38 = "12_1303603603.711" 
    .local pmc block
    set block, $P38
    .const 'Sub' $P1772 = "383_1303603603.711" 
    capture_lex $P1772
    $P1772()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1771"  :anon :subid("383_1303603603.711") :outer("12_1303603603.711")
.annotate 'line', 9
    nqp_get_sc_object $P1773, "1303603591.505", 1
    .local pmc type_obj
    set type_obj, $P1773
    get_how $P1774, type_obj
    .const 'Sub' $P1775 = "13_1303603603.711" 
    $P1774."add_method"(type_obj, "TOP", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "14_1303603603.711" 
    $P1776."add_method"(type_obj, "identifier", $P1777)
    get_how $P1778, type_obj
    get_global $P1779, "!PREFIX__identifier"
    $P1778."add_method"(type_obj, "!PREFIX__identifier", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "16_1303603603.711" 
    $P1780."add_method"(type_obj, "name", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__name"
    $P1782."add_method"(type_obj, "!PREFIX__name", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "18_1303603603.711" 
    $P1784."add_method"(type_obj, "deflongname", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__deflongname"
    $P1786."add_method"(type_obj, "!PREFIX__deflongname", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "20_1303603603.711" 
    $P1788."add_method"(type_obj, "ENDSTMT", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__ENDSTMT"
    $P1790."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "22_1303603603.711" 
    $P1792."add_method"(type_obj, "ws", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__ws"
    $P1794."add_method"(type_obj, "!PREFIX__ws", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "24_1303603603.711" 
    $P1796."add_method"(type_obj, "unv", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__unv"
    $P1798."add_method"(type_obj, "!PREFIX__unv", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "27_1303603603.711" 
    $P1800."add_method"(type_obj, "pod_comment", $P1801)
    get_how $P1802, type_obj
    get_global $P1803, "!PREFIX__pod_comment"
    $P1802."add_method"(type_obj, "!PREFIX__pod_comment", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "30_1303603603.711" 
    $P1804."add_method"(type_obj, "comp_unit", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__comp_unit"
    $P1806."add_method"(type_obj, "!PREFIX__comp_unit", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "32_1303603603.711" 
    $P1808."add_method"(type_obj, "statementlist", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__statementlist"
    $P1810."add_method"(type_obj, "!PREFIX__statementlist", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "34_1303603603.711" 
    $P1812."add_method"(type_obj, "statement", $P1813)
    get_how $P1814, type_obj
    get_global $P1815, "!PREFIX__statement"
    $P1814."add_method"(type_obj, "!PREFIX__statement", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "37_1303603603.711" 
    $P1816."add_method"(type_obj, "eat_terminator", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__eat_terminator"
    $P1818."add_method"(type_obj, "!PREFIX__eat_terminator", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "39_1303603603.711" 
    $P1820."add_method"(type_obj, "xblock", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__xblock"
    $P1822."add_method"(type_obj, "!PREFIX__xblock", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "41_1303603603.711" 
    $P1824."add_method"(type_obj, "pblock", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__pblock"
    $P1826."add_method"(type_obj, "!PREFIX__pblock", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "43_1303603603.711" 
    $P1828."add_method"(type_obj, "lambda", $P1829)
    get_how $P1830, type_obj
    get_global $P1831, "!PREFIX__lambda"
    $P1830."add_method"(type_obj, "!PREFIX__lambda", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "45_1303603603.711" 
    $P1832."add_method"(type_obj, "block", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__block"
    $P1834."add_method"(type_obj, "!PREFIX__block", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "47_1303603603.711" 
    $P1836."add_method"(type_obj, "blockoid", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__blockoid"
    $P1838."add_method"(type_obj, "!PREFIX__blockoid", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "49_1303603603.711" 
    $P1840."add_method"(type_obj, "newpad", $P1841)
    get_how $P1842, type_obj
    get_global $P1843, "!PREFIX__newpad"
    $P1842."add_method"(type_obj, "!PREFIX__newpad", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "51_1303603603.711" 
    $P1844."add_method"(type_obj, "outerctx", $P1845)
    get_how $P1846, type_obj
    get_global $P1847, "!PREFIX__outerctx"
    $P1846."add_method"(type_obj, "!PREFIX__outerctx", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "53_1303603603.711" 
    $P1848."add_method"(type_obj, "GLOBALish", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__GLOBALish"
    $P1850."add_method"(type_obj, "!PREFIX__GLOBALish", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "55_1303603603.711" 
    $P1852."add_method"(type_obj, "finishpad", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__finishpad"
    $P1854."add_method"(type_obj, "!PREFIX__finishpad", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "57_1303603603.711" 
    $P1856."add_method"(type_obj, "you_are_here", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__you_are_here"
    $P1858."add_method"(type_obj, "!PREFIX__you_are_here", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "59_1303603603.711" 
    $P1860."add_method"(type_obj, "terminator", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "60_1303603603.711" 
    $P1862."add_method"(type_obj, "!PREFIX__terminator", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "61_1303603603.711" 
    $P1864."add_method"(type_obj, "terminator:sym<;>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__terminator:sym<;>"
    $P1866."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "63_1303603603.711" 
    $P1868."add_method"(type_obj, "terminator:sym<}>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__terminator:sym<}>"
    $P1870."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "65_1303603603.711" 
    $P1872."add_method"(type_obj, "statement_control", $P1873)
    get_how $P1874, type_obj
    .const 'Sub' $P1875 = "66_1303603603.711" 
    $P1874."add_method"(type_obj, "!PREFIX__statement_control", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "67_1303603603.711" 
    $P1876."add_method"(type_obj, "statement_control:sym<use>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__statement_control:sym<use>"
    $P1878."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "69_1303603603.711" 
    $P1880."add_method"(type_obj, "statement_control:sym<if>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__statement_control:sym<if>"
    $P1882."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "71_1303603603.711" 
    $P1884."add_method"(type_obj, "statement_control:sym<unless>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__statement_control:sym<unless>"
    $P1886."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "74_1303603603.711" 
    $P1888."add_method"(type_obj, "statement_control:sym<while>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__statement_control:sym<while>"
    $P1890."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "76_1303603603.711" 
    $P1892."add_method"(type_obj, "statement_control:sym<repeat>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__statement_control:sym<repeat>"
    $P1894."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "78_1303603603.711" 
    $P1896."add_method"(type_obj, "statement_control:sym<for>", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__statement_control:sym<for>"
    $P1898."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "80_1303603603.711" 
    $P1900."add_method"(type_obj, "statement_control:sym<CATCH>", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__statement_control:sym<CATCH>"
    $P1902."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "82_1303603603.711" 
    $P1904."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__statement_control:sym<CONTROL>"
    $P1906."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "84_1303603603.711" 
    $P1908."add_method"(type_obj, "statement_prefix", $P1909)
    get_how $P1910, type_obj
    .const 'Sub' $P1911 = "85_1303603603.711" 
    $P1910."add_method"(type_obj, "!PREFIX__statement_prefix", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "86_1303603603.711" 
    $P1912."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__statement_prefix:sym<INIT>"
    $P1914."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "88_1303603603.711" 
    $P1916."add_method"(type_obj, "statement_prefix:sym<try>", $P1917)
    get_how $P1918, type_obj
    get_global $P1919, "!PREFIX__statement_prefix:sym<try>"
    $P1918."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "90_1303603603.711" 
    $P1920."add_method"(type_obj, "blorst", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__blorst"
    $P1922."add_method"(type_obj, "!PREFIX__blorst", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "92_1303603603.711" 
    $P1924."add_method"(type_obj, "statement_mod_cond", $P1925)
    get_how $P1926, type_obj
    .const 'Sub' $P1927 = "93_1303603603.711" 
    $P1926."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "94_1303603603.711" 
    $P1928."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__statement_mod_cond:sym<if>"
    $P1930."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "96_1303603603.711" 
    $P1932."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1934."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "98_1303603603.711" 
    $P1936."add_method"(type_obj, "statement_mod_loop", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "99_1303603603.711" 
    $P1938."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "100_1303603603.711" 
    $P1940."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__statement_mod_loop:sym<while>"
    $P1942."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "102_1303603603.711" 
    $P1944."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__statement_mod_loop:sym<until>"
    $P1946."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "104_1303603603.711" 
    $P1948."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1949)
    get_how $P1950, type_obj
    get_global $P1951, "!PREFIX__statement_mod_loop:sym<for>"
    $P1950."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "106_1303603603.711" 
    $P1952."add_method"(type_obj, "term:sym<fatarrow>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__term:sym<fatarrow>"
    $P1954."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "108_1303603603.711" 
    $P1956."add_method"(type_obj, "term:sym<colonpair>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__term:sym<colonpair>"
    $P1958."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "110_1303603603.711" 
    $P1960."add_method"(type_obj, "term:sym<variable>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__term:sym<variable>"
    $P1962."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "112_1303603603.711" 
    $P1964."add_method"(type_obj, "term:sym<package_declarator>", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__term:sym<package_declarator>"
    $P1966."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "114_1303603603.711" 
    $P1968."add_method"(type_obj, "term:sym<scope_declarator>", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__term:sym<scope_declarator>"
    $P1970."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "116_1303603603.711" 
    $P1972."add_method"(type_obj, "term:sym<routine_declarator>", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__term:sym<routine_declarator>"
    $P1974."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "118_1303603603.711" 
    $P1976."add_method"(type_obj, "term:sym<multi_declarator>", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__term:sym<multi_declarator>"
    $P1978."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "122_1303603603.711" 
    $P1980."add_method"(type_obj, "term:sym<regex_declarator>", $P1981)
    get_how $P1982, type_obj
    get_global $P1983, "!PREFIX__term:sym<regex_declarator>"
    $P1982."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "124_1303603603.711" 
    $P1984."add_method"(type_obj, "term:sym<statement_prefix>", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__term:sym<statement_prefix>"
    $P1986."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "126_1303603603.711" 
    $P1988."add_method"(type_obj, "term:sym<lambda>", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__term:sym<lambda>"
    $P1990."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "128_1303603603.711" 
    $P1992."add_method"(type_obj, "fatarrow", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__fatarrow"
    $P1994."add_method"(type_obj, "!PREFIX__fatarrow", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "130_1303603603.711" 
    $P1996."add_method"(type_obj, "colonpair", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__colonpair"
    $P1998."add_method"(type_obj, "!PREFIX__colonpair", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "132_1303603603.711" 
    $P2000."add_method"(type_obj, "variable", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__variable"
    $P2002."add_method"(type_obj, "!PREFIX__variable", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "134_1303603603.711" 
    $P2004."add_method"(type_obj, "sigil", $P2005)
    get_how $P2006, type_obj
    get_global $P2007, "!PREFIX__sigil"
    $P2006."add_method"(type_obj, "!PREFIX__sigil", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "136_1303603603.711" 
    $P2008."add_method"(type_obj, "twigil", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__twigil"
    $P2010."add_method"(type_obj, "!PREFIX__twigil", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "138_1303603603.711" 
    $P2012."add_method"(type_obj, "package_declarator", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "139_1303603603.711" 
    $P2014."add_method"(type_obj, "!PREFIX__package_declarator", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "140_1303603603.711" 
    $P2016."add_method"(type_obj, "package_declarator:sym<module>", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__package_declarator:sym<module>"
    $P2018."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "142_1303603603.711" 
    $P2020."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__package_declarator:sym<knowhow>"
    $P2022."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "144_1303603603.711" 
    $P2024."add_method"(type_obj, "package_declarator:sym<class>", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__package_declarator:sym<class>"
    $P2026."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "146_1303603603.711" 
    $P2028."add_method"(type_obj, "package_declarator:sym<grammar>", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__package_declarator:sym<grammar>"
    $P2030."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "148_1303603603.711" 
    $P2032."add_method"(type_obj, "package_declarator:sym<role>", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__package_declarator:sym<role>"
    $P2034."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "150_1303603603.711" 
    $P2036."add_method"(type_obj, "package_declarator:sym<native>", $P2037)
    get_how $P2038, type_obj
    get_global $P2039, "!PREFIX__package_declarator:sym<native>"
    $P2038."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "152_1303603603.711" 
    $P2040."add_method"(type_obj, "package_def", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__package_def"
    $P2042."add_method"(type_obj, "!PREFIX__package_def", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "155_1303603603.711" 
    $P2044."add_method"(type_obj, "scope_declarator", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "156_1303603603.711" 
    $P2046."add_method"(type_obj, "!PREFIX__scope_declarator", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "157_1303603603.711" 
    $P2048."add_method"(type_obj, "scope_declarator:sym<my>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__scope_declarator:sym<my>"
    $P2050."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "159_1303603603.711" 
    $P2052."add_method"(type_obj, "scope_declarator:sym<our>", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__scope_declarator:sym<our>"
    $P2054."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "161_1303603603.711" 
    $P2056."add_method"(type_obj, "scope_declarator:sym<has>", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__scope_declarator:sym<has>"
    $P2058."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "163_1303603603.711" 
    $P2060."add_method"(type_obj, "scoped", $P2061)
    get_how $P2062, type_obj
    get_global $P2063, "!PREFIX__scoped"
    $P2062."add_method"(type_obj, "!PREFIX__scoped", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "165_1303603603.711" 
    $P2064."add_method"(type_obj, "typename", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__typename"
    $P2066."add_method"(type_obj, "!PREFIX__typename", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "167_1303603603.711" 
    $P2068."add_method"(type_obj, "declarator", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__declarator"
    $P2070."add_method"(type_obj, "!PREFIX__declarator", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "169_1303603603.711" 
    $P2072."add_method"(type_obj, "variable_declarator", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__variable_declarator"
    $P2074."add_method"(type_obj, "!PREFIX__variable_declarator", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "171_1303603603.711" 
    $P2076."add_method"(type_obj, "routine_declarator", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "172_1303603603.711" 
    $P2078."add_method"(type_obj, "!PREFIX__routine_declarator", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "173_1303603603.711" 
    $P2080."add_method"(type_obj, "routine_declarator:sym<sub>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__routine_declarator:sym<sub>"
    $P2082."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "175_1303603603.711" 
    $P2084."add_method"(type_obj, "routine_declarator:sym<method>", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__routine_declarator:sym<method>"
    $P2086."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "177_1303603603.711" 
    $P2088."add_method"(type_obj, "routine_def", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__routine_def"
    $P2090."add_method"(type_obj, "!PREFIX__routine_def", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "179_1303603603.711" 
    $P2092."add_method"(type_obj, "method_def", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__method_def"
    $P2094."add_method"(type_obj, "!PREFIX__method_def", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "182_1303603603.711" 
    $P2096."add_method"(type_obj, "onlystar", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__onlystar"
    $P2098."add_method"(type_obj, "!PREFIX__onlystar", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "185_1303603603.711" 
    $P2100."add_method"(type_obj, "multi_declarator", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "186_1303603603.711" 
    $P2102."add_method"(type_obj, "!PREFIX__multi_declarator", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "187_1303603603.711" 
    $P2104."add_method"(type_obj, "multi_declarator:sym<multi>", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__multi_declarator:sym<multi>"
    $P2106."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "189_1303603603.711" 
    $P2108."add_method"(type_obj, "multi_declarator:sym<proto>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__multi_declarator:sym<proto>"
    $P2110."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "191_1303603603.711" 
    $P2112."add_method"(type_obj, "multi_declarator:sym<null>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__multi_declarator:sym<null>"
    $P2114."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "193_1303603603.711" 
    $P2116."add_method"(type_obj, "signature", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__signature"
    $P2118."add_method"(type_obj, "!PREFIX__signature", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "196_1303603603.711" 
    $P2120."add_method"(type_obj, "parameter", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__parameter"
    $P2122."add_method"(type_obj, "!PREFIX__parameter", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "198_1303603603.711" 
    $P2124."add_method"(type_obj, "param_var", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__param_var"
    $P2126."add_method"(type_obj, "!PREFIX__param_var", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "200_1303603603.711" 
    $P2128."add_method"(type_obj, "named_param", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__named_param"
    $P2130."add_method"(type_obj, "!PREFIX__named_param", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "202_1303603603.711" 
    $P2132."add_method"(type_obj, "default_value", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__default_value"
    $P2134."add_method"(type_obj, "!PREFIX__default_value", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "204_1303603603.711" 
    $P2136."add_method"(type_obj, "trait", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__trait"
    $P2138."add_method"(type_obj, "!PREFIX__trait", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "206_1303603603.711" 
    $P2140."add_method"(type_obj, "trait_mod", $P2141)
    get_how $P2142, type_obj
    .const 'Sub' $P2143 = "207_1303603603.711" 
    $P2142."add_method"(type_obj, "!PREFIX__trait_mod", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "208_1303603603.711" 
    $P2144."add_method"(type_obj, "trait_mod:sym<is>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__trait_mod:sym<is>"
    $P2146."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "210_1303603603.711" 
    $P2148."add_method"(type_obj, "regex_declarator", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__regex_declarator"
    $P2150."add_method"(type_obj, "!PREFIX__regex_declarator", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "212_1303603603.711" 
    $P2152."add_method"(type_obj, "dotty", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__dotty"
    $P2154."add_method"(type_obj, "!PREFIX__dotty", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "214_1303603603.711" 
    $P2156."add_method"(type_obj, "term", $P2157)
    get_how $P2158, type_obj
    .const 'Sub' $P2159 = "215_1303603603.711" 
    $P2158."add_method"(type_obj, "!PREFIX__term", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "216_1303603603.711" 
    $P2160."add_method"(type_obj, "term:sym<self>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__term:sym<self>"
    $P2162."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "218_1303603603.711" 
    $P2164."add_method"(type_obj, "term:sym<identifier>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__term:sym<identifier>"
    $P2166."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "220_1303603603.711" 
    $P2168."add_method"(type_obj, "term:sym<name>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__term:sym<name>"
    $P2170."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "222_1303603603.711" 
    $P2172."add_method"(type_obj, "term:sym<pir::op>", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__term:sym<pir::op>"
    $P2174."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "224_1303603603.711" 
    $P2176."add_method"(type_obj, "term:sym<onlystar>", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__term:sym<onlystar>"
    $P2178."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "227_1303603603.711" 
    $P2180."add_method"(type_obj, "args", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__args"
    $P2182."add_method"(type_obj, "!PREFIX__args", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "229_1303603603.711" 
    $P2184."add_method"(type_obj, "arglist", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__arglist"
    $P2186."add_method"(type_obj, "!PREFIX__arglist", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "231_1303603603.711" 
    $P2188."add_method"(type_obj, "term:sym<value>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__term:sym<value>"
    $P2190."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "233_1303603603.711" 
    $P2192."add_method"(type_obj, "value", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__value"
    $P2194."add_method"(type_obj, "!PREFIX__value", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "235_1303603603.711" 
    $P2196."add_method"(type_obj, "number", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__number"
    $P2198."add_method"(type_obj, "!PREFIX__number", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "237_1303603603.711" 
    $P2200."add_method"(type_obj, "quote", $P2201)
    get_how $P2202, type_obj
    .const 'Sub' $P2203 = "238_1303603603.711" 
    $P2202."add_method"(type_obj, "!PREFIX__quote", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "239_1303603603.711" 
    $P2204."add_method"(type_obj, "quote:sym<apos>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__quote:sym<apos>"
    $P2206."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "241_1303603603.711" 
    $P2208."add_method"(type_obj, "quote:sym<dblq>", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__quote:sym<dblq>"
    $P2210."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "243_1303603603.711" 
    $P2212."add_method"(type_obj, "quote:sym<q>", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__quote:sym<q>"
    $P2214."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "245_1303603603.711" 
    $P2216."add_method"(type_obj, "quote:sym<qq>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__quote:sym<qq>"
    $P2218."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "247_1303603603.711" 
    $P2220."add_method"(type_obj, "quote:sym<Q>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__quote:sym<Q>"
    $P2222."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "249_1303603603.711" 
    $P2224."add_method"(type_obj, "quote:sym<Q:PIR>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__quote:sym<Q:PIR>"
    $P2226."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "251_1303603603.711" 
    $P2228."add_method"(type_obj, "quote:sym</ />", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__quote:sym</ />"
    $P2230."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "253_1303603603.711" 
    $P2232."add_method"(type_obj, "quote_escape:sym<$>", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__quote_escape:sym<$>"
    $P2234."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "255_1303603603.711" 
    $P2236."add_method"(type_obj, "quote_escape:sym<{ }>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__quote_escape:sym<{ }>"
    $P2238."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "257_1303603603.711" 
    $P2240."add_method"(type_obj, "quote_escape:sym<esc>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__quote_escape:sym<esc>"
    $P2242."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "259_1303603603.711" 
    $P2244."add_method"(type_obj, "circumfix:sym<( )>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__circumfix:sym<( )>"
    $P2246."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "261_1303603603.711" 
    $P2248."add_method"(type_obj, "circumfix:sym<[ ]>", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__circumfix:sym<[ ]>"
    $P2250."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "263_1303603603.711" 
    $P2252."add_method"(type_obj, "circumfix:sym<ang>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__circumfix:sym<ang>"
    $P2254."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "265_1303603603.711" 
    $P2256."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2258."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "267_1303603603.711" 
    $P2260."add_method"(type_obj, "circumfix:sym<{ }>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__circumfix:sym<{ }>"
    $P2262."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "269_1303603603.711" 
    $P2264."add_method"(type_obj, "circumfix:sym<sigil>", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__circumfix:sym<sigil>"
    $P2266."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "271_1303603603.711" 
    $P2268."add_method"(type_obj, "semilist", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__semilist"
    $P2270."add_method"(type_obj, "!PREFIX__semilist", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "273_1303603603.711" 
    $P2272."add_method"(type_obj, "infixish", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__infixish"
    $P2274."add_method"(type_obj, "!PREFIX__infixish", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "275_1303603603.711" 
    $P2276."add_method"(type_obj, "infixstopper", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__infixstopper"
    $P2278."add_method"(type_obj, "!PREFIX__infixstopper", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "277_1303603603.711" 
    $P2280."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2282."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "279_1303603603.711" 
    $P2284."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__postcircumfix:sym<{ }>"
    $P2286."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "281_1303603603.711" 
    $P2288."add_method"(type_obj, "postcircumfix:sym<ang>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__postcircumfix:sym<ang>"
    $P2290."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "283_1303603603.711" 
    $P2292."add_method"(type_obj, "postcircumfix:sym<( )>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__postcircumfix:sym<( )>"
    $P2294."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "285_1303603603.711" 
    $P2296."add_method"(type_obj, "postfix:sym<.>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__postfix:sym<.>"
    $P2298."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "287_1303603603.711" 
    $P2300."add_method"(type_obj, "prefix:sym<++>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__prefix:sym<++>"
    $P2302."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "289_1303603603.711" 
    $P2304."add_method"(type_obj, "prefix:sym<-->", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__prefix:sym<-->"
    $P2306."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "291_1303603603.711" 
    $P2308."add_method"(type_obj, "postfix:sym<++>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__postfix:sym<++>"
    $P2310."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "293_1303603603.711" 
    $P2312."add_method"(type_obj, "postfix:sym<-->", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__postfix:sym<-->"
    $P2314."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "295_1303603603.711" 
    $P2316."add_method"(type_obj, "infix:sym<**>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<**>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "297_1303603603.711" 
    $P2320."add_method"(type_obj, "prefix:sym<+>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__prefix:sym<+>"
    $P2322."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "299_1303603603.711" 
    $P2324."add_method"(type_obj, "prefix:sym<~>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__prefix:sym<~>"
    $P2326."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "301_1303603603.711" 
    $P2328."add_method"(type_obj, "prefix:sym<->", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__prefix:sym<->"
    $P2330."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "303_1303603603.711" 
    $P2332."add_method"(type_obj, "prefix:sym<?>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__prefix:sym<?>"
    $P2334."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "305_1303603603.711" 
    $P2336."add_method"(type_obj, "prefix:sym<!>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__prefix:sym<!>"
    $P2338."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "307_1303603603.711" 
    $P2340."add_method"(type_obj, "prefix:sym<|>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__prefix:sym<|>"
    $P2342."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "309_1303603603.711" 
    $P2344."add_method"(type_obj, "infix:sym<*>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<*>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "311_1303603603.711" 
    $P2348."add_method"(type_obj, "infix:sym</>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym</>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "313_1303603603.711" 
    $P2352."add_method"(type_obj, "infix:sym<%>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<%>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "315_1303603603.711" 
    $P2356."add_method"(type_obj, "infix:sym<+&>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<+&>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "317_1303603603.711" 
    $P2360."add_method"(type_obj, "infix:sym<+>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<+>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "319_1303603603.711" 
    $P2364."add_method"(type_obj, "infix:sym<->", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<->"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "321_1303603603.711" 
    $P2368."add_method"(type_obj, "infix:sym<+|>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<+|>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "323_1303603603.711" 
    $P2372."add_method"(type_obj, "infix:sym<+^>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__infix:sym<+^>"
    $P2374."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "325_1303603603.711" 
    $P2376."add_method"(type_obj, "infix:sym<~>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__infix:sym<~>"
    $P2378."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "327_1303603603.711" 
    $P2380."add_method"(type_obj, "infix:sym<==>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__infix:sym<==>"
    $P2382."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "329_1303603603.711" 
    $P2384."add_method"(type_obj, "infix:sym<!=>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__infix:sym<!=>"
    $P2386."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "331_1303603603.711" 
    $P2388."add_method"(type_obj, "infix:sym<<=>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__infix:sym<<=>"
    $P2390."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "333_1303603603.711" 
    $P2392."add_method"(type_obj, "infix:sym<>=>", $P2393)
    get_how $P2394, type_obj
    get_global $P2395, "!PREFIX__infix:sym<>=>"
    $P2394."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2395)
    get_how $P2396, type_obj
    .const 'Sub' $P2397 = "335_1303603603.711" 
    $P2396."add_method"(type_obj, "infix:sym<<>", $P2397)
    get_how $P2398, type_obj
    get_global $P2399, "!PREFIX__infix:sym<<>"
    $P2398."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2399)
    get_how $P2400, type_obj
    .const 'Sub' $P2401 = "337_1303603603.711" 
    $P2400."add_method"(type_obj, "infix:sym<>>", $P2401)
    get_how $P2402, type_obj
    get_global $P2403, "!PREFIX__infix:sym<>>"
    $P2402."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2403)
    get_how $P2404, type_obj
    .const 'Sub' $P2405 = "339_1303603603.711" 
    $P2404."add_method"(type_obj, "infix:sym<eq>", $P2405)
    get_how $P2406, type_obj
    get_global $P2407, "!PREFIX__infix:sym<eq>"
    $P2406."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2407)
    get_how $P2408, type_obj
    .const 'Sub' $P2409 = "341_1303603603.711" 
    $P2408."add_method"(type_obj, "infix:sym<ne>", $P2409)
    get_how $P2410, type_obj
    get_global $P2411, "!PREFIX__infix:sym<ne>"
    $P2410."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2411)
    get_how $P2412, type_obj
    .const 'Sub' $P2413 = "343_1303603603.711" 
    $P2412."add_method"(type_obj, "infix:sym<le>", $P2413)
    get_how $P2414, type_obj
    get_global $P2415, "!PREFIX__infix:sym<le>"
    $P2414."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2415)
    get_how $P2416, type_obj
    .const 'Sub' $P2417 = "345_1303603603.711" 
    $P2416."add_method"(type_obj, "infix:sym<ge>", $P2417)
    get_how $P2418, type_obj
    get_global $P2419, "!PREFIX__infix:sym<ge>"
    $P2418."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2419)
    get_how $P2420, type_obj
    .const 'Sub' $P2421 = "347_1303603603.711" 
    $P2420."add_method"(type_obj, "infix:sym<lt>", $P2421)
    get_how $P2422, type_obj
    get_global $P2423, "!PREFIX__infix:sym<lt>"
    $P2422."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2423)
    get_how $P2424, type_obj
    .const 'Sub' $P2425 = "349_1303603603.711" 
    $P2424."add_method"(type_obj, "infix:sym<gt>", $P2425)
    get_how $P2426, type_obj
    get_global $P2427, "!PREFIX__infix:sym<gt>"
    $P2426."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2427)
    get_how $P2428, type_obj
    .const 'Sub' $P2429 = "351_1303603603.711" 
    $P2428."add_method"(type_obj, "infix:sym<=:=>", $P2429)
    get_how $P2430, type_obj
    get_global $P2431, "!PREFIX__infix:sym<=:=>"
    $P2430."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2431)
    get_how $P2432, type_obj
    .const 'Sub' $P2433 = "353_1303603603.711" 
    $P2432."add_method"(type_obj, "infix:sym<~~>", $P2433)
    get_how $P2434, type_obj
    get_global $P2435, "!PREFIX__infix:sym<~~>"
    $P2434."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2435)
    get_how $P2436, type_obj
    .const 'Sub' $P2437 = "355_1303603603.711" 
    $P2436."add_method"(type_obj, "infix:sym<&&>", $P2437)
    get_how $P2438, type_obj
    get_global $P2439, "!PREFIX__infix:sym<&&>"
    $P2438."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2439)
    get_how $P2440, type_obj
    .const 'Sub' $P2441 = "357_1303603603.711" 
    $P2440."add_method"(type_obj, "infix:sym<||>", $P2441)
    get_how $P2442, type_obj
    get_global $P2443, "!PREFIX__infix:sym<||>"
    $P2442."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2443)
    get_how $P2444, type_obj
    .const 'Sub' $P2445 = "359_1303603603.711" 
    $P2444."add_method"(type_obj, "infix:sym<//>", $P2445)
    get_how $P2446, type_obj
    get_global $P2447, "!PREFIX__infix:sym<//>"
    $P2446."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2447)
    get_how $P2448, type_obj
    .const 'Sub' $P2449 = "361_1303603603.711" 
    $P2448."add_method"(type_obj, "infix:sym<?? !!>", $P2449)
    get_how $P2450, type_obj
    get_global $P2451, "!PREFIX__infix:sym<?? !!>"
    $P2450."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2451)
    get_how $P2452, type_obj
    .const 'Sub' $P2453 = "363_1303603603.711" 
    $P2452."add_method"(type_obj, "infix:sym<=>", $P2453)
    get_how $P2454, type_obj
    get_global $P2455, "!PREFIX__infix:sym<=>"
    $P2454."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2455)
    get_how $P2456, type_obj
    .const 'Sub' $P2457 = "365_1303603603.711" 
    $P2456."add_method"(type_obj, "infix:sym<:=>", $P2457)
    get_how $P2458, type_obj
    get_global $P2459, "!PREFIX__infix:sym<:=>"
    $P2458."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2459)
    get_how $P2460, type_obj
    .const 'Sub' $P2461 = "367_1303603603.711" 
    $P2460."add_method"(type_obj, "infix:sym<::=>", $P2461)
    get_how $P2462, type_obj
    get_global $P2463, "!PREFIX__infix:sym<::=>"
    $P2462."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2463)
    get_how $P2464, type_obj
    .const 'Sub' $P2465 = "369_1303603603.711" 
    $P2464."add_method"(type_obj, "infix:sym<,>", $P2465)
    get_how $P2466, type_obj
    get_global $P2467, "!PREFIX__infix:sym<,>"
    $P2466."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2467)
    get_how $P2468, type_obj
    .const 'Sub' $P2469 = "371_1303603603.711" 
    $P2468."add_method"(type_obj, "prefix:sym<return>", $P2469)
    get_how $P2470, type_obj
    get_global $P2471, "!PREFIX__prefix:sym<return>"
    $P2470."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2471)
    get_how $P2472, type_obj
    .const 'Sub' $P2473 = "374_1303603603.711" 
    $P2472."add_method"(type_obj, "prefix:sym<make>", $P2473)
    get_how $P2474, type_obj
    get_global $P2475, "!PREFIX__prefix:sym<make>"
    $P2474."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2475)
    get_how $P2476, type_obj
    .const 'Sub' $P2477 = "376_1303603603.711" 
    $P2476."add_method"(type_obj, "term:sym<last>", $P2477)
    get_how $P2478, type_obj
    get_global $P2479, "!PREFIX__term:sym<last>"
    $P2478."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2479)
    get_how $P2480, type_obj
    .const 'Sub' $P2481 = "378_1303603603.711" 
    $P2480."add_method"(type_obj, "term:sym<next>", $P2481)
    get_how $P2482, type_obj
    get_global $P2483, "!PREFIX__term:sym<next>"
    $P2482."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2483)
    get_how $P2484, type_obj
    .const 'Sub' $P2485 = "380_1303603603.711" 
    $P2484."add_method"(type_obj, "term:sym<redo>", $P2485)
    get_how $P2486, type_obj
    get_global $P2487, "!PREFIX__term:sym<redo>"
    $P2486."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2487)
    get_how $P2488, type_obj
    .const 'Sub' $P2489 = "382_1303603603.711" 
    $P2488."add_method"(type_obj, "smartmatch", $P2489)
    get_how $P2490, type_obj
    get_hll_global $P2491, ["HLL"], "Grammar"
    $P2490."add_parent"(type_obj, $P2491)
    get_how $P2492, type_obj
    $P2493 = $P2492."compose"(type_obj)
    .return ($P2493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303603603.711") :outer("12_1303603603.711")
    .param pmc param_57
.annotate 'line', 10
    .lex "self", param_57
.annotate 'line', 12
    $P58 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P58
.annotate 'line', 19
    $P59 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P59
.annotate 'line', 28
    new $P60, "Undef"
    .lex "$*DEFAULT-METAATTR", $P60
.annotate 'line', 29
    $P61 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P61
.annotate 'line', 35
    new $P62, "Undef"
    .lex "$*SC", $P62
.annotate 'line', 39
    new $P63, "Undef"
    .lex "$*SCOPE", $P63
.annotate 'line', 40
    new $P64, "Undef"
    .lex "$*MULTINESS", $P64
.annotate 'line', 41
    new $P65, "Undef"
    .lex "$*INVOCANT_OK", $P65
.annotate 'line', 42
    new $P66, "Undef"
    .lex "$*RETURN_USED", $P66
.annotate 'line', 43
    new $P67, "Undef"
    .lex "$*PACKAGE-SETUP", $P67
.annotate 'line', 10
    find_lex $P68, "%*LANG"
    unless_null $P68, vivify_592
    get_hll_global $P68, "%LANG"
    unless_null $P68, vivify_593
    die "Contextual %*LANG not found"
  vivify_593:
  vivify_592:
.annotate 'line', 13
    get_hll_global $P69, ["NQP"], "Regex"
    find_lex $P70, "%*LANG"
    unless_null $P70, vivify_594
    get_hll_global $P70, "%LANG"
    unless_null $P70, vivify_595
    die "Contextual %*LANG not found"
  vivify_595:
    store_lex "%*LANG", $P70
  vivify_594:
    set $P70["Regex"], $P69
.annotate 'line', 14
    get_hll_global $P71, ["NQP"], "RegexActions"
    find_lex $P72, "%*LANG"
    unless_null $P72, vivify_596
    get_hll_global $P72, "%LANG"
    unless_null $P72, vivify_597
    die "Contextual %*LANG not found"
  vivify_597:
    store_lex "%*LANG", $P72
  vivify_596:
    set $P72["Regex-actions"], $P71
.annotate 'line', 15
    get_hll_global $P73, ["NQP"], "Grammar"
    find_lex $P74, "%*LANG"
    unless_null $P74, vivify_598
    get_hll_global $P74, "%LANG"
    unless_null $P74, vivify_599
    die "Contextual %*LANG not found"
  vivify_599:
    store_lex "%*LANG", $P74
  vivify_598:
    set $P74["MAIN"], $P73
.annotate 'line', 16
    get_hll_global $P75, ["NQP"], "Actions"
    find_lex $P76, "%*LANG"
    unless_null $P76, vivify_600
    get_hll_global $P76, "%LANG"
    unless_null $P76, vivify_601
    die "Contextual %*LANG not found"
  vivify_601:
    store_lex "%*LANG", $P76
  vivify_600:
    set $P76["MAIN-actions"], $P75
    find_lex $P77, "%*HOW"
    unless_null $P77, vivify_602
    get_hll_global $P77, "%HOW"
    unless_null $P77, vivify_603
    die "Contextual %*HOW not found"
  vivify_603:
  vivify_602:
.annotate 'line', 20
    get_hll_global $P78, "KnowHOW"
    find_lex $P79, "%*HOW"
    unless_null $P79, vivify_604
    get_hll_global $P79, "%HOW"
    unless_null $P79, vivify_605
    die "Contextual %*HOW not found"
  vivify_605:
    store_lex "%*HOW", $P79
  vivify_604:
    set $P79["knowhow"], $P78
.annotate 'line', 21
    get_hll_global $P80, "NQPModuleHOW"
    find_lex $P81, "%*HOW"
    unless_null $P81, vivify_606
    get_hll_global $P81, "%HOW"
    unless_null $P81, vivify_607
    die "Contextual %*HOW not found"
  vivify_607:
    store_lex "%*HOW", $P81
  vivify_606:
    set $P81["module"], $P80
.annotate 'line', 22
    get_hll_global $P82, "NQPClassHOW"
    find_lex $P83, "%*HOW"
    unless_null $P83, vivify_608
    get_hll_global $P83, "%HOW"
    unless_null $P83, vivify_609
    die "Contextual %*HOW not found"
  vivify_609:
    store_lex "%*HOW", $P83
  vivify_608:
    set $P83["class"], $P82
.annotate 'line', 23
    get_hll_global $P84, "NQPClassHOW"
    find_lex $P85, "%*HOW"
    unless_null $P85, vivify_610
    get_hll_global $P85, "%HOW"
    unless_null $P85, vivify_611
    die "Contextual %*HOW not found"
  vivify_611:
    store_lex "%*HOW", $P85
  vivify_610:
    set $P85["grammar"], $P84
.annotate 'line', 24
    get_hll_global $P86, "NQPParametricRoleHOW"
    find_lex $P87, "%*HOW"
    unless_null $P87, vivify_612
    get_hll_global $P87, "%HOW"
    unless_null $P87, vivify_613
    die "Contextual %*HOW not found"
  vivify_613:
    store_lex "%*HOW", $P87
  vivify_612:
    set $P87["role"], $P86
.annotate 'line', 25
    get_hll_global $P88, "NQPNativeHOW"
    find_lex $P89, "%*HOW"
    unless_null $P89, vivify_614
    get_hll_global $P89, "%HOW"
    unless_null $P89, vivify_615
    die "Contextual %*HOW not found"
  vivify_615:
    store_lex "%*HOW", $P89
  vivify_614:
    set $P89["native"], $P88
.annotate 'line', 28
    new $P90, "String"
    assign $P90, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P90
    find_lex $P91, "%*HOW-METAATTR"
    unless_null $P91, vivify_616
    get_hll_global $P91, "%HOW-METAATTR"
    unless_null $P91, vivify_617
    die "Contextual %*HOW-METAATTR not found"
  vivify_617:
  vivify_616:
.annotate 'line', 30
    new $P92, "String"
    assign $P92, "KnowHOWAttribute"
    find_lex $P93, "%*HOW-METAATTR"
    unless_null $P93, vivify_618
    get_hll_global $P93, "%HOW-METAATTR"
    unless_null $P93, vivify_619
    die "Contextual %*HOW-METAATTR not found"
  vivify_619:
    store_lex "%*HOW-METAATTR", $P93
  vivify_618:
    set $P93["knowhow"], $P92
.annotate 'line', 35
    get_hll_global $P94, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N95
    set $S96, $N95
    $P97 = $P94."new"($S96 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P97
.annotate 'line', 39
    new $P98, "String"
    assign $P98, ""
    store_lex "$*SCOPE", $P98
.annotate 'line', 40
    new $P99, "String"
    assign $P99, ""
    store_lex "$*MULTINESS", $P99
.annotate 'line', 41
    new $P100, "Integer"
    assign $P100, 0
    store_lex "$*INVOCANT_OK", $P100
.annotate 'line', 42
    new $P101, "Integer"
    assign $P101, 0
    store_lex "$*RETURN_USED", $P101
    find_lex $P102, "$*PACKAGE-SETUP"
    unless_null $P102, vivify_620
    get_hll_global $P102, "$PACKAGE-SETUP"
    unless_null $P102, vivify_621
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_621:
  vivify_620:
.annotate 'line', 44
    find_lex $P103, "self"
    $P104 = $P103."comp_unit"()
.annotate 'line', 10
    .return ($P104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx106_tgt
    .local int rx106_pos
    .local int rx106_off
    .local int rx106_eos
    .local int rx106_rep
    .local pmc rx106_cur
    .local pmc rx106_debug
    (rx106_cur, rx106_pos, rx106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx106_cur
    .local pmc match
    .lex "$/", match
    length rx106_eos, rx106_tgt
    gt rx106_pos, rx106_eos, rx106_done
    set rx106_off, 0
    lt rx106_pos, 2, rx106_start
    sub rx106_off, rx106_pos, 1
    substr rx106_tgt, rx106_tgt, rx106_off
  rx106_start:
    eq $I10, 1, rx106_restart
    if_null rx106_debug, debug_622
    rx106_cur."!cursor_debug"("START", "identifier")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan110_done
    goto rxscan110_scan
  rxscan110_loop:
    (rx106_pos) = rx106_cur."from"()
    inc rx106_pos
    rx106_cur."!cursor_from"(rx106_pos)
    ge rx106_pos, rx106_eos, rxscan110_done
  rxscan110_scan:
    set_addr $I10, rxscan110_loop
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
  rxscan110_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx106_cur."!cursor_pos"(rx106_pos)
    $P10 = rx106_cur."ident"()
    unless $P10, rx106_fail
    rx106_pos = $P10."pos"()
  # rx rxquantr111 ** 0..*
    set_addr $I10, rxquantr111_done
    rx106_cur."!mark_push"(0, rx106_pos, $I10)
  rxquantr111_loop:
  # rx enumcharlist negate=0 
    ge rx106_pos, rx106_eos, rx106_fail
    sub $I10, rx106_pos, rx106_off
    substr $S10, rx106_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx106_fail
    inc rx106_pos
  # rx subrule "ident" subtype=method negate=
    rx106_cur."!cursor_pos"(rx106_pos)
    $P10 = rx106_cur."ident"()
    unless $P10, rx106_fail
    rx106_pos = $P10."pos"()
    set_addr $I10, rxquantr111_done
    (rx106_rep) = rx106_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr111_done
    rx106_cur."!mark_push"(rx106_rep, rx106_pos, $I10)
    goto rxquantr111_loop
  rxquantr111_done:
  # rx pass
    rx106_cur."!cursor_pass"(rx106_pos, "identifier")
    if_null rx106_debug, debug_623
    rx106_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx106_pos)
  debug_623:
    .return (rx106_cur)
  rx106_restart:
.annotate 'line', 10
    if_null rx106_debug, debug_624
    rx106_cur."!cursor_debug"("NEXT", "identifier")
  debug_624:
  rx106_fail:
    (rx106_rep, rx106_pos, $I10, $P10) = rx106_cur."!mark_fail"(0)
    lt rx106_pos, -1, rx106_done
    eq rx106_pos, -1, rx106_fail
    jump $I10
  rx106_done:
    rx106_cur."!cursor_fail"()
    if_null rx106_debug, debug_625
    rx106_cur."!cursor_debug"("FAIL", "identifier")
  debug_625:
    .return (rx106_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303603603.711") :method
.annotate 'line', 10
    $P108 = self."!PREFIX__!subrule"("ident", "")
    new $P109, "ResizablePMCArray"
    push $P109, $P108
    .return ($P109)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx113_tgt
    .local int rx113_pos
    .local int rx113_off
    .local int rx113_eos
    .local int rx113_rep
    .local pmc rx113_cur
    .local pmc rx113_debug
    (rx113_cur, rx113_pos, rx113_tgt, $I10) = self."!cursor_start"()
    rx113_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx113_cur
    .local pmc match
    .lex "$/", match
    length rx113_eos, rx113_tgt
    gt rx113_pos, rx113_eos, rx113_done
    set rx113_off, 0
    lt rx113_pos, 2, rx113_start
    sub rx113_off, rx113_pos, 1
    substr rx113_tgt, rx113_tgt, rx113_off
  rx113_start:
    eq $I10, 1, rx113_restart
    if_null rx113_debug, debug_626
    rx113_cur."!cursor_debug"("START", "name")
  debug_626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan116_done
    goto rxscan116_scan
  rxscan116_loop:
    (rx113_pos) = rx113_cur."from"()
    inc rx113_pos
    rx113_cur."!cursor_from"(rx113_pos)
    ge rx113_pos, rx113_eos, rxscan116_done
  rxscan116_scan:
    set_addr $I10, rxscan116_loop
    rx113_cur."!mark_push"(0, rx113_pos, $I10)
  rxscan116_done:
.annotate 'line', 51
  # rx rxquantr117 ** 1..*
    set_addr $I10, rxquantr117_done
    rx113_cur."!mark_push"(0, -1, $I10)
  rxquantr117_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx113_cur."!cursor_pos"(rx113_pos)
    $P10 = rx113_cur."identifier"()
    unless $P10, rx113_fail
    goto rxsubrule118_pass
  rxsubrule118_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx113_fail
  rxsubrule118_pass:
    set_addr $I10, rxsubrule118_back
    rx113_cur."!mark_push"(0, rx113_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx113_pos = $P10."pos"()
    set_addr $I10, rxquantr117_done
    (rx113_rep) = rx113_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr117_done
    rx113_cur."!mark_push"(rx113_rep, rx113_pos, $I10)
  # rx literal  "::"
    add $I11, rx113_pos, 2
    gt $I11, rx113_eos, rx113_fail
    sub $I11, rx113_pos, rx113_off
    substr $S10, rx113_tgt, $I11, 2
    ne $S10, "::", rx113_fail
    add rx113_pos, 2
    goto rxquantr117_loop
  rxquantr117_done:
  # rx pass
    rx113_cur."!cursor_pass"(rx113_pos, "name")
    if_null rx113_debug, debug_627
    rx113_cur."!cursor_debug"("PASS", "name", " at pos=", rx113_pos)
  debug_627:
    .return (rx113_cur)
  rx113_restart:
.annotate 'line', 10
    if_null rx113_debug, debug_628
    rx113_cur."!cursor_debug"("NEXT", "name")
  debug_628:
  rx113_fail:
    (rx113_rep, rx113_pos, $I10, $P10) = rx113_cur."!mark_fail"(0)
    lt rx113_pos, -1, rx113_done
    eq rx113_pos, -1, rx113_fail
    jump $I10
  rx113_done:
    rx113_cur."!cursor_fail"()
    if_null rx113_debug, debug_629
    rx113_cur."!cursor_debug"("FAIL", "name")
  debug_629:
    .return (rx113_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303603603.711") :method
.annotate 'line', 10
    new $P115, "ResizablePMCArray"
    push $P115, ""
    .return ($P115)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx120_tgt
    .local int rx120_pos
    .local int rx120_off
    .local int rx120_eos
    .local int rx120_rep
    .local pmc rx120_cur
    .local pmc rx120_debug
    (rx120_cur, rx120_pos, rx120_tgt, $I10) = self."!cursor_start"()
    rx120_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx120_cur
    .local pmc match
    .lex "$/", match
    length rx120_eos, rx120_tgt
    gt rx120_pos, rx120_eos, rx120_done
    set rx120_off, 0
    lt rx120_pos, 2, rx120_start
    sub rx120_off, rx120_pos, 1
    substr rx120_tgt, rx120_tgt, rx120_off
  rx120_start:
    eq $I10, 1, rx120_restart
    if_null rx120_debug, debug_630
    rx120_cur."!cursor_debug"("START", "deflongname")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan124_done
    goto rxscan124_scan
  rxscan124_loop:
    (rx120_pos) = rx120_cur."from"()
    inc rx120_pos
    rx120_cur."!cursor_from"(rx120_pos)
    ge rx120_pos, rx120_eos, rxscan124_done
  rxscan124_scan:
    set_addr $I10, rxscan124_loop
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  rxscan124_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."identifier"()
    unless $P10, rx120_fail
    rx120_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx120_pos = $P10."pos"()
  # rx rxquantr125 ** 0..1
    set_addr $I10, rxquantr125_done
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  rxquantr125_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."colonpair"()
    unless $P10, rx120_fail
    goto rxsubrule126_pass
  rxsubrule126_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx120_fail
  rxsubrule126_pass:
    set_addr $I10, rxsubrule126_back
    rx120_cur."!mark_push"(0, rx120_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx120_pos = $P10."pos"()
    set_addr $I10, rxquantr125_done
    (rx120_rep) = rx120_cur."!mark_commit"($I10)
  rxquantr125_done:
.annotate 'line', 53
  # rx pass
    rx120_cur."!cursor_pass"(rx120_pos, "deflongname")
    if_null rx120_debug, debug_631
    rx120_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx120_pos)
  debug_631:
    .return (rx120_cur)
  rx120_restart:
.annotate 'line', 10
    if_null rx120_debug, debug_632
    rx120_cur."!cursor_debug"("NEXT", "deflongname")
  debug_632:
  rx120_fail:
    (rx120_rep, rx120_pos, $I10, $P10) = rx120_cur."!mark_fail"(0)
    lt rx120_pos, -1, rx120_done
    eq rx120_pos, -1, rx120_fail
    jump $I10
  rx120_done:
    rx120_cur."!cursor_fail"()
    if_null rx120_debug, debug_633
    rx120_cur."!cursor_debug"("FAIL", "deflongname")
  debug_633:
    .return (rx120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303603603.711") :method
.annotate 'line', 10
    $P122 = self."!PREFIX__!subrule"("identifier", "")
    new $P123, "ResizablePMCArray"
    push $P123, $P122
    .return ($P123)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx128_tgt
    .local int rx128_pos
    .local int rx128_off
    .local int rx128_eos
    .local int rx128_rep
    .local pmc rx128_cur
    .local pmc rx128_debug
    (rx128_cur, rx128_pos, rx128_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx128_cur
    .local pmc match
    .lex "$/", match
    length rx128_eos, rx128_tgt
    gt rx128_pos, rx128_eos, rx128_done
    set rx128_off, 0
    lt rx128_pos, 2, rx128_start
    sub rx128_off, rx128_pos, 1
    substr rx128_tgt, rx128_tgt, rx128_off
  rx128_start:
    eq $I10, 1, rx128_restart
    if_null rx128_debug, debug_634
    rx128_cur."!cursor_debug"("START", "ENDSTMT")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan131_done
    goto rxscan131_scan
  rxscan131_loop:
    (rx128_pos) = rx128_cur."from"()
    inc rx128_pos
    rx128_cur."!cursor_from"(rx128_pos)
    ge rx128_pos, rx128_eos, rxscan131_done
  rxscan131_scan:
    set_addr $I10, rxscan131_loop
    rx128_cur."!mark_push"(0, rx128_pos, $I10)
  rxscan131_done:
.annotate 'line', 61
  # rx rxquantr132 ** 0..1
    set_addr $I10, rxquantr132_done
    rx128_cur."!mark_push"(0, rx128_pos, $I10)
  rxquantr132_loop:
  alt133_0:
.annotate 'line', 58
    set_addr $I10, alt133_1
    rx128_cur."!mark_push"(0, rx128_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx128_pos, rx128_off
    set rx128_rep, 0
    sub $I12, rx128_eos, rx128_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx128_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx128_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    add rx128_pos, rx128_pos, rx128_rep
  # rxanchor eol
    sub $I10, rx128_pos, rx128_off
    is_cclass $I11, 4096, rx128_tgt, $I10
    if $I11, rxanchor135_done
    ne rx128_pos, rx128_eos, rx128_fail
    eq rx128_pos, 0, rxanchor135_done
    dec $I10
    is_cclass $I11, 4096, rx128_tgt, $I10
    if $I11, rx128_fail
  rxanchor135_done:
  # rx subrule "ws" subtype=method negate=
    rx128_cur."!cursor_pos"(rx128_pos)
    $P10 = rx128_cur."ws"()
    unless $P10, rx128_fail
    rx128_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx128_cur."!cursor_pos"(rx128_pos)
    $P10 = rx128_cur."MARKER"("endstmt")
    unless $P10, rx128_fail
    goto alt133_end
  alt133_1:
.annotate 'line', 60
  # rx rxquantr136 ** 0..1
    set_addr $I10, rxquantr136_done
    rx128_cur."!mark_push"(0, rx128_pos, $I10)
  rxquantr136_loop:
  # rx subrule "unv" subtype=method negate=
    rx128_cur."!cursor_pos"(rx128_pos)
    $P10 = rx128_cur."unv"()
    unless $P10, rx128_fail
    goto rxsubrule137_pass
  rxsubrule137_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx128_fail
  rxsubrule137_pass:
    set_addr $I10, rxsubrule137_back
    rx128_cur."!mark_push"(0, rx128_pos, $I10, $P10)
    rx128_pos = $P10."pos"()
    set_addr $I10, rxquantr136_done
    (rx128_rep) = rx128_cur."!mark_commit"($I10)
  rxquantr136_done:
  # rxanchor eol
    sub $I10, rx128_pos, rx128_off
    is_cclass $I11, 4096, rx128_tgt, $I10
    if $I11, rxanchor138_done
    ne rx128_pos, rx128_eos, rx128_fail
    eq rx128_pos, 0, rxanchor138_done
    dec $I10
    is_cclass $I11, 4096, rx128_tgt, $I10
    if $I11, rx128_fail
  rxanchor138_done:
  # rx subrule "ws" subtype=method negate=
    rx128_cur."!cursor_pos"(rx128_pos)
    $P10 = rx128_cur."ws"()
    unless $P10, rx128_fail
    rx128_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx128_cur."!cursor_pos"(rx128_pos)
    $P10 = rx128_cur."MARKER"("endstmt")
    unless $P10, rx128_fail
  alt133_end:
.annotate 'line', 61
    set_addr $I10, rxquantr132_done
    (rx128_rep) = rx128_cur."!mark_commit"($I10)
  rxquantr132_done:
.annotate 'line', 57
  # rx pass
    rx128_cur."!cursor_pass"(rx128_pos, "ENDSTMT")
    if_null rx128_debug, debug_635
    rx128_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx128_pos)
  debug_635:
    .return (rx128_cur)
  rx128_restart:
.annotate 'line', 10
    if_null rx128_debug, debug_636
    rx128_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_636:
  rx128_fail:
    (rx128_rep, rx128_pos, $I10, $P10) = rx128_cur."!mark_fail"(0)
    lt rx128_pos, -1, rx128_done
    eq rx128_pos, -1, rx128_fail
    jump $I10
  rx128_done:
    rx128_cur."!cursor_fail"()
    if_null rx128_debug, debug_637
    rx128_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_637:
    .return (rx128_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303603603.711") :method
.annotate 'line', 10
    new $P130, "ResizablePMCArray"
    push $P130, ""
    .return ($P130)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx140_tgt
    .local int rx140_pos
    .local int rx140_off
    .local int rx140_eos
    .local int rx140_rep
    .local pmc rx140_cur
    .local pmc rx140_debug
    (rx140_cur, rx140_pos, rx140_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx140_cur
    .local pmc match
    .lex "$/", match
    length rx140_eos, rx140_tgt
    gt rx140_pos, rx140_eos, rx140_done
    set rx140_off, 0
    lt rx140_pos, 2, rx140_start
    sub rx140_off, rx140_pos, 1
    substr rx140_tgt, rx140_tgt, rx140_off
  rx140_start:
    eq $I10, 1, rx140_restart
    if_null rx140_debug, debug_638
    rx140_cur."!cursor_debug"("START", "ws")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan143_done
    goto rxscan143_scan
  rxscan143_loop:
    (rx140_pos) = rx140_cur."from"()
    inc rx140_pos
    rx140_cur."!cursor_from"(rx140_pos)
    ge rx140_pos, rx140_eos, rxscan143_done
  rxscan143_scan:
    set_addr $I10, rxscan143_loop
    rx140_cur."!mark_push"(0, rx140_pos, $I10)
  rxscan143_done:
  alt144_0:
.annotate 'line', 64
    set_addr $I10, alt144_1
    rx140_cur."!mark_push"(0, rx140_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx140_cur."!cursor_pos"(rx140_pos)
    $P10 = rx140_cur."MARKED"("ws")
    unless $P10, rx140_fail
    goto alt144_end
  alt144_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx140_cur."!cursor_pos"(rx140_pos)
    $P10 = rx140_cur."ww"()
    if $P10, rx140_fail
.annotate 'line', 71
  # rx rxquantr145 ** 0..*
    set_addr $I10, rxquantr145_done
    rx140_cur."!mark_push"(0, rx140_pos, $I10)
  rxquantr145_loop:
  alt146_0:
.annotate 'line', 67
    set_addr $I10, alt146_1
    rx140_cur."!mark_push"(0, rx140_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx140_pos, rx140_off
    set rx140_rep, 0
    sub $I12, rx140_eos, rx140_pos
  rxenumcharlistq147_loop:
    le $I12, 0, rxenumcharlistq147_done
    substr $S10, rx140_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq147_done
    inc rx140_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq147_loop
  rxenumcharlistq147_done:
    lt rx140_rep, 1, rx140_fail
    add rx140_pos, rx140_pos, rx140_rep
    goto alt146_end
  alt146_1:
    set_addr $I10, alt146_2
    rx140_cur."!mark_push"(0, rx140_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx140_pos, 1
    gt $I11, rx140_eos, rx140_fail
    sub $I11, rx140_pos, rx140_off
    ord $I11, rx140_tgt, $I11
    ne $I11, 35, rx140_fail
    add rx140_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx140_pos, rx140_off
    find_cclass $I11, 4096, rx140_tgt, $I10, rx140_eos
    add rx140_pos, rx140_off, $I11
    goto alt146_end
  alt146_2:
    set_addr $I10, alt146_3
    rx140_cur."!mark_push"(0, rx140_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx140_pos, 0, rxanchor148_done
    ge rx140_pos, rx140_eos, rx140_fail
    sub $I10, rx140_pos, rx140_off
    dec $I10
    is_cclass $I11, 4096, rx140_tgt, $I10
    unless $I11, rx140_fail
  rxanchor148_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx140_cur."!cursor_pos"(rx140_pos)
    $P10 = rx140_cur."pod_comment"()
    unless $P10, rx140_fail
    rx140_pos = $P10."pos"()
    goto alt146_end
  alt146_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx140_pos, rx140_off
    set rx140_rep, 0
    sub $I12, rx140_eos, rx140_pos
  rxenumcharlistq149_loop:
    le $I12, 0, rxenumcharlistq149_done
    substr $S10, rx140_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq149_done
    inc rx140_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq149_loop
  rxenumcharlistq149_done:
    lt rx140_rep, 1, rx140_fail
    add rx140_pos, rx140_pos, rx140_rep
  alt146_end:
.annotate 'line', 71
    set_addr $I10, rxquantr145_done
    (rx140_rep) = rx140_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr145_done
    rx140_cur."!mark_push"(rx140_rep, rx140_pos, $I10)
    goto rxquantr145_loop
  rxquantr145_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx140_cur."!cursor_pos"(rx140_pos)
    $P10 = rx140_cur."MARKER"("ws")
    unless $P10, rx140_fail
  alt144_end:
.annotate 'line', 64
  # rx pass
    rx140_cur."!cursor_pass"(rx140_pos, "ws")
    if_null rx140_debug, debug_639
    rx140_cur."!cursor_debug"("PASS", "ws", " at pos=", rx140_pos)
  debug_639:
    .return (rx140_cur)
  rx140_restart:
.annotate 'line', 10
    if_null rx140_debug, debug_640
    rx140_cur."!cursor_debug"("NEXT", "ws")
  debug_640:
  rx140_fail:
    (rx140_rep, rx140_pos, $I10, $P10) = rx140_cur."!mark_fail"(0)
    lt rx140_pos, -1, rx140_done
    eq rx140_pos, -1, rx140_fail
    jump $I10
  rx140_done:
    rx140_cur."!cursor_fail"()
    if_null rx140_debug, debug_641
    rx140_cur."!cursor_debug"("FAIL", "ws")
  debug_641:
    .return (rx140_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303603603.711") :method
.annotate 'line', 10
    new $P142, "ResizablePMCArray"
    push $P142, ""
    push $P142, ""
    .return ($P142)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P158 = "26_1303603603.711" 
    capture_lex $P158
    .local string rx151_tgt
    .local int rx151_pos
    .local int rx151_off
    .local int rx151_eos
    .local int rx151_rep
    .local pmc rx151_cur
    .local pmc rx151_debug
    (rx151_cur, rx151_pos, rx151_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx151_cur
    .local pmc match
    .lex "$/", match
    length rx151_eos, rx151_tgt
    gt rx151_pos, rx151_eos, rx151_done
    set rx151_off, 0
    lt rx151_pos, 2, rx151_start
    sub rx151_off, rx151_pos, 1
    substr rx151_tgt, rx151_tgt, rx151_off
  rx151_start:
    eq $I10, 1, rx151_restart
    if_null rx151_debug, debug_642
    rx151_cur."!cursor_debug"("START", "unv")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan154_done
    goto rxscan154_scan
  rxscan154_loop:
    (rx151_pos) = rx151_cur."from"()
    inc rx151_pos
    rx151_cur."!cursor_from"(rx151_pos)
    ge rx151_pos, rx151_eos, rxscan154_done
  rxscan154_scan:
    set_addr $I10, rxscan154_loop
    rx151_cur."!mark_push"(0, rx151_pos, $I10)
  rxscan154_done:
  alt155_0:
.annotate 'line', 77
    set_addr $I10, alt155_1
    rx151_cur."!mark_push"(0, rx151_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx151_pos, 0, rxanchor156_done
    ge rx151_pos, rx151_eos, rx151_fail
    sub $I10, rx151_pos, rx151_off
    dec $I10
    is_cclass $I11, 4096, rx151_tgt, $I10
    unless $I11, rx151_fail
  rxanchor156_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx151_cur."!cursor_pos"(rx151_pos)
    .const 'Sub' $P158 = "26_1303603603.711" 
    capture_lex $P158
    $P10 = rx151_cur."before"($P158)
    unless $P10, rx151_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx151_cur."!cursor_pos"(rx151_pos)
    $P10 = rx151_cur."pod_comment"()
    unless $P10, rx151_fail
    rx151_pos = $P10."pos"()
    goto alt155_end
  alt155_1:
    set_addr $I10, alt155_2
    rx151_cur."!mark_push"(0, rx151_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx151_pos, rx151_off
    set rx151_rep, 0
    sub $I12, rx151_eos, rx151_pos
  rxenumcharlistq163_loop:
    le $I12, 0, rxenumcharlistq163_done
    substr $S10, rx151_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq163_done
    inc rx151_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq163_loop
  rxenumcharlistq163_done:
    add rx151_pos, rx151_pos, rx151_rep
  # rx literal  "#"
    add $I11, rx151_pos, 1
    gt $I11, rx151_eos, rx151_fail
    sub $I11, rx151_pos, rx151_off
    ord $I11, rx151_tgt, $I11
    ne $I11, 35, rx151_fail
    add rx151_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx151_pos, rx151_off
    find_cclass $I11, 4096, rx151_tgt, $I10, rx151_eos
    add rx151_pos, rx151_off, $I11
    goto alt155_end
  alt155_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx151_pos, rx151_off
    set rx151_rep, 0
    sub $I12, rx151_eos, rx151_pos
  rxenumcharlistq164_loop:
    le $I12, 0, rxenumcharlistq164_done
    substr $S10, rx151_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq164_done
    inc rx151_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq164_loop
  rxenumcharlistq164_done:
    lt rx151_rep, 1, rx151_fail
    add rx151_pos, rx151_pos, rx151_rep
  alt155_end:
.annotate 'line', 75
  # rx pass
    rx151_cur."!cursor_pass"(rx151_pos, "unv")
    if_null rx151_debug, debug_647
    rx151_cur."!cursor_debug"("PASS", "unv", " at pos=", rx151_pos)
  debug_647:
    .return (rx151_cur)
  rx151_restart:
.annotate 'line', 10
    if_null rx151_debug, debug_648
    rx151_cur."!cursor_debug"("NEXT", "unv")
  debug_648:
  rx151_fail:
    (rx151_rep, rx151_pos, $I10, $P10) = rx151_cur."!mark_fail"(0)
    lt rx151_pos, -1, rx151_done
    eq rx151_pos, -1, rx151_fail
    jump $I10
  rx151_done:
    rx151_cur."!cursor_fail"()
    if_null rx151_debug, debug_649
    rx151_cur."!cursor_debug"("FAIL", "unv")
  debug_649:
    .return (rx151_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303603603.711") :method
.annotate 'line', 10
    new $P153, "ResizablePMCArray"
    push $P153, ""
    push $P153, ""
    push $P153, ""
    .return ($P153)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block157"  :anon :subid("26_1303603603.711") :method :outer("24_1303603603.711")
.annotate 'line', 78
    .local string rx159_tgt
    .local int rx159_pos
    .local int rx159_off
    .local int rx159_eos
    .local int rx159_rep
    .local pmc rx159_cur
    .local pmc rx159_debug
    (rx159_cur, rx159_pos, rx159_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx159_cur
    .local pmc match
    .lex "$/", match
    length rx159_eos, rx159_tgt
    gt rx159_pos, rx159_eos, rx159_done
    set rx159_off, 0
    lt rx159_pos, 2, rx159_start
    sub rx159_off, rx159_pos, 1
    substr rx159_tgt, rx159_tgt, rx159_off
  rx159_start:
    eq $I10, 1, rx159_restart
    if_null rx159_debug, debug_643
    rx159_cur."!cursor_debug"("START", "")
  debug_643:
    $I10 = self.'from'()
    ne $I10, -1, rxscan160_done
    goto rxscan160_scan
  rxscan160_loop:
    (rx159_pos) = rx159_cur."from"()
    inc rx159_pos
    rx159_cur."!cursor_from"(rx159_pos)
    ge rx159_pos, rx159_eos, rxscan160_done
  rxscan160_scan:
    set_addr $I10, rxscan160_loop
    rx159_cur."!mark_push"(0, rx159_pos, $I10)
  rxscan160_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx159_pos, rx159_off
    set rx159_rep, 0
    sub $I12, rx159_eos, rx159_pos
  rxenumcharlistq161_loop:
    le $I12, 0, rxenumcharlistq161_done
    substr $S10, rx159_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq161_done
    inc rx159_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq161_loop
  rxenumcharlistq161_done:
    add rx159_pos, rx159_pos, rx159_rep
  # rx literal  "="
    add $I11, rx159_pos, 1
    gt $I11, rx159_eos, rx159_fail
    sub $I11, rx159_pos, rx159_off
    ord $I11, rx159_tgt, $I11
    ne $I11, 61, rx159_fail
    add rx159_pos, 1
  alt162_0:
    set_addr $I10, alt162_1
    rx159_cur."!mark_push"(0, rx159_pos, $I10)
  # rx charclass w
    ge rx159_pos, rx159_eos, rx159_fail
    sub $I10, rx159_pos, rx159_off
    is_cclass $I11, 8192, rx159_tgt, $I10
    unless $I11, rx159_fail
    inc rx159_pos
    goto alt162_end
  alt162_1:
  # rx literal  "\\"
    add $I11, rx159_pos, 1
    gt $I11, rx159_eos, rx159_fail
    sub $I11, rx159_pos, rx159_off
    ord $I11, rx159_tgt, $I11
    ne $I11, 92, rx159_fail
    add rx159_pos, 1
  alt162_end:
  # rx pass
    rx159_cur."!cursor_pass"(rx159_pos, "")
    if_null rx159_debug, debug_644
    rx159_cur."!cursor_debug"("PASS", "", " at pos=", rx159_pos)
  debug_644:
    .return (rx159_cur)
  rx159_restart:
    if_null rx159_debug, debug_645
    rx159_cur."!cursor_debug"("NEXT", "")
  debug_645:
  rx159_fail:
    (rx159_rep, rx159_pos, $I10, $P10) = rx159_cur."!mark_fail"(0)
    lt rx159_pos, -1, rx159_done
    eq rx159_pos, -1, rx159_fail
    jump $I10
  rx159_done:
    rx159_cur."!cursor_fail"()
    if_null rx159_debug, debug_646
    rx159_cur."!cursor_debug"("FAIL", "")
  debug_646:
    .return (rx159_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P197 = "29_1303603603.711" 
    capture_lex $P197
    .local string rx166_tgt
    .local int rx166_pos
    .local int rx166_off
    .local int rx166_eos
    .local int rx166_rep
    .local pmc rx166_cur
    .local pmc rx166_debug
    (rx166_cur, rx166_pos, rx166_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx166_cur
    .local pmc match
    .lex "$/", match
    length rx166_eos, rx166_tgt
    gt rx166_pos, rx166_eos, rx166_done
    set rx166_off, 0
    lt rx166_pos, 2, rx166_start
    sub rx166_off, rx166_pos, 1
    substr rx166_tgt, rx166_tgt, rx166_off
  rx166_start:
    eq $I10, 1, rx166_restart
    if_null rx166_debug, debug_650
    rx166_cur."!cursor_debug"("START", "pod_comment")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan169_done
    goto rxscan169_scan
  rxscan169_loop:
    (rx166_pos) = rx166_cur."from"()
    inc rx166_pos
    rx166_cur."!cursor_from"(rx166_pos)
    ge rx166_pos, rx166_eos, rxscan169_done
  rxscan169_scan:
    set_addr $I10, rxscan169_loop
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
  rxscan169_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx166_pos, 0, rxanchor170_done
    ge rx166_pos, rx166_eos, rx166_fail
    sub $I10, rx166_pos, rx166_off
    dec $I10
    is_cclass $I11, 4096, rx166_tgt, $I10
    unless $I11, rx166_fail
  rxanchor170_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq171_loop:
    le $I12, 0, rxenumcharlistq171_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq171_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq171_loop
  rxenumcharlistq171_done:
    add rx166_pos, rx166_pos, rx166_rep
  # rx literal  "="
    add $I11, rx166_pos, 1
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    ord $I11, rx166_tgt, $I11
    ne $I11, 61, rx166_fail
    add rx166_pos, 1
  alt172_0:
.annotate 'line', 86
    set_addr $I10, alt172_1
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx166_pos, 5
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 5
    ne $S10, "begin", rx166_fail
    add rx166_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq173_loop:
    le $I12, 0, rxenumcharlistq173_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq173_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq173_loop
  rxenumcharlistq173_done:
    lt rx166_rep, 1, rx166_fail
    add rx166_pos, rx166_pos, rx166_rep
  # rx literal  "END"
    add $I11, rx166_pos, 3
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 3
    ne $S10, "END", rx166_fail
    add rx166_pos, 3
  # rxanchor rwb
    le rx166_pos, 0, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 8192, rx166_tgt, $I10
    if $I11, rx166_fail
    dec $I10
    is_cclass $I11, 8192, rx166_tgt, $I10
    unless $I11, rx166_fail
  alt174_0:
.annotate 'line', 88
    set_addr $I10, alt174_1
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
  # rx rxquantf175 ** 0..*
    set_addr $I10, rxquantf175_loop
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
    goto rxquantf175_done
  rxquantf175_loop:
  # rx charclass .
    ge rx166_pos, rx166_eos, rx166_fail
    inc rx166_pos
    set_addr $I10, rxquantf175_loop
    rx166_cur."!mark_push"(rx166_rep, rx166_pos, $I10)
  rxquantf175_done:
  # rx charclass nl
    ge rx166_pos, rx166_eos, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 4096, rx166_tgt, $I10
    unless $I11, rx166_fail
    substr $S10, rx166_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx166_pos, $I11
    inc rx166_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq177_loop:
    le $I12, 0, rxenumcharlistq177_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq177_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq177_loop
  rxenumcharlistq177_done:
    add rx166_pos, rx166_pos, rx166_rep
  # rx literal  "=end"
    add $I11, rx166_pos, 4
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 4
    ne $S10, "=end", rx166_fail
    add rx166_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq178_loop:
    le $I12, 0, rxenumcharlistq178_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq178_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq178_loop
  rxenumcharlistq178_done:
    lt rx166_rep, 1, rx166_fail
    add rx166_pos, rx166_pos, rx166_rep
  # rx literal  "END"
    add $I11, rx166_pos, 3
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 3
    ne $S10, "END", rx166_fail
    add rx166_pos, 3
  # rxanchor rwb
    le rx166_pos, 0, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 8192, rx166_tgt, $I10
    if $I11, rx166_fail
    dec $I10
    is_cclass $I11, 8192, rx166_tgt, $I10
    unless $I11, rx166_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx166_pos, rx166_off
    find_cclass $I11, 4096, rx166_tgt, $I10, rx166_eos
    add rx166_pos, rx166_off, $I11
    goto alt174_end
  alt174_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx166_pos, rx166_off
    find_not_cclass $I11, 65535, rx166_tgt, $I10, rx166_eos
    add rx166_pos, rx166_off, $I11
  alt174_end:
.annotate 'line', 87
    goto alt172_end
  alt172_1:
    set_addr $I10, alt172_2
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx166_pos, 5
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 5
    ne $S10, "begin", rx166_fail
    add rx166_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq179_loop:
    le $I12, 0, rxenumcharlistq179_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq179_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq179_loop
  rxenumcharlistq179_done:
    lt rx166_rep, 1, rx166_fail
    add rx166_pos, rx166_pos, rx166_rep
  # rx subrule "identifier" subtype=capture negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    $P10 = rx166_cur."identifier"()
    unless $P10, rx166_fail
    rx166_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx166_pos = $P10."pos"()
  alt180_0:
.annotate 'line', 90
    set_addr $I10, alt180_1
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
.annotate 'line', 91
  # rx rxquantf181 ** 0..*
    set_addr $I10, rxquantf181_loop
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
    goto rxquantf181_done
  rxquantf181_loop:
  # rx charclass .
    ge rx166_pos, rx166_eos, rx166_fail
    inc rx166_pos
    set_addr $I10, rxquantf181_loop
    rx166_cur."!mark_push"(rx166_rep, rx166_pos, $I10)
  rxquantf181_done:
  # rx charclass nl
    ge rx166_pos, rx166_eos, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 4096, rx166_tgt, $I10
    unless $I11, rx166_fail
    substr $S10, rx166_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx166_pos, $I11
    inc rx166_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq183_loop:
    le $I12, 0, rxenumcharlistq183_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq183_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq183_loop
  rxenumcharlistq183_done:
    add rx166_pos, rx166_pos, rx166_rep
  # rx literal  "=end"
    add $I11, rx166_pos, 4
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 4
    ne $S10, "=end", rx166_fail
    add rx166_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq184_loop:
    le $I12, 0, rxenumcharlistq184_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq184_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq184_loop
  rxenumcharlistq184_done:
    lt rx166_rep, 1, rx166_fail
    add rx166_pos, rx166_pos, rx166_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    $P10 = rx166_cur."!BACKREF"("identifier")
    unless $P10, rx166_fail
    rx166_pos = $P10."pos"()
  # rxanchor rwb
    le rx166_pos, 0, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 8192, rx166_tgt, $I10
    if $I11, rx166_fail
    dec $I10
    is_cclass $I11, 8192, rx166_tgt, $I10
    unless $I11, rx166_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx166_pos, rx166_off
    find_cclass $I11, 4096, rx166_tgt, $I10, rx166_eos
    add rx166_pos, rx166_off, $I11
    goto alt180_end
  alt180_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    $P10 = rx166_cur."panic"("=begin without matching =end")
    unless $P10, rx166_fail
    rx166_pos = $P10."pos"()
  alt180_end:
.annotate 'line', 89
    goto alt172_end
  alt172_2:
    set_addr $I10, alt172_3
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx166_pos, 5
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 5
    ne $S10, "begin", rx166_fail
    add rx166_pos, 5
  # rxanchor rwb
    le rx166_pos, 0, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 8192, rx166_tgt, $I10
    if $I11, rx166_fail
    dec $I10
    is_cclass $I11, 8192, rx166_tgt, $I10
    unless $I11, rx166_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq186_loop:
    le $I12, 0, rxenumcharlistq186_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq186_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq186_loop
  rxenumcharlistq186_done:
    add rx166_pos, rx166_pos, rx166_rep
  alt187_0:
.annotate 'line', 95
    set_addr $I10, alt187_1
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
  # rxanchor eol
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 4096, rx166_tgt, $I10
    if $I11, rxanchor188_done
    ne rx166_pos, rx166_eos, rx166_fail
    eq rx166_pos, 0, rxanchor188_done
    dec $I10
    is_cclass $I11, 4096, rx166_tgt, $I10
    if $I11, rx166_fail
  rxanchor188_done:
    goto alt187_end
  alt187_1:
    set_addr $I10, alt187_2
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
  # rx literal  "#"
    add $I11, rx166_pos, 1
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    ord $I11, rx166_tgt, $I11
    ne $I11, 35, rx166_fail
    add rx166_pos, 1
    goto alt187_end
  alt187_2:
  # rx subrule "panic" subtype=method negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    $P10 = rx166_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx166_fail
    rx166_pos = $P10."pos"()
  alt187_end:
  alt189_0:
.annotate 'line', 96
    set_addr $I10, alt189_1
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
.annotate 'line', 97
  # rx rxquantf190 ** 0..*
    set_addr $I10, rxquantf190_loop
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
    goto rxquantf190_done
  rxquantf190_loop:
  # rx charclass .
    ge rx166_pos, rx166_eos, rx166_fail
    inc rx166_pos
    set_addr $I10, rxquantf190_loop
    rx166_cur."!mark_push"(rx166_rep, rx166_pos, $I10)
  rxquantf190_done:
  # rx charclass nl
    ge rx166_pos, rx166_eos, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 4096, rx166_tgt, $I10
    unless $I11, rx166_fail
    substr $S10, rx166_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx166_pos, $I11
    inc rx166_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx166_pos, rx166_off
    set rx166_rep, 0
    sub $I12, rx166_eos, rx166_pos
  rxenumcharlistq192_loop:
    le $I12, 0, rxenumcharlistq192_done
    substr $S10, rx166_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq192_done
    inc rx166_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq192_loop
  rxenumcharlistq192_done:
    add rx166_pos, rx166_pos, rx166_rep
  # rx literal  "=end"
    add $I11, rx166_pos, 4
    gt $I11, rx166_eos, rx166_fail
    sub $I11, rx166_pos, rx166_off
    substr $S10, rx166_tgt, $I11, 4
    ne $S10, "=end", rx166_fail
    add rx166_pos, 4
  # rxanchor rwb
    le rx166_pos, 0, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 8192, rx166_tgt, $I10
    if $I11, rx166_fail
    dec $I10
    is_cclass $I11, 8192, rx166_tgt, $I10
    unless $I11, rx166_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx166_pos, rx166_off
    find_cclass $I11, 4096, rx166_tgt, $I10, rx166_eos
    add rx166_pos, rx166_off, $I11
    goto alt189_end
  alt189_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    $P10 = rx166_cur."panic"("=begin without matching =end")
    unless $P10, rx166_fail
    rx166_pos = $P10."pos"()
  alt189_end:
.annotate 'line', 94
    goto alt172_end
  alt172_3:
    set_addr $I10, alt172_4
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    $P10 = rx166_cur."identifier"()
    unless $P10, rx166_fail
    rx166_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx166_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf193 ** 0..*
    set_addr $I10, rxquantf193_loop
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
    goto rxquantf193_done
  rxquantf193_loop:
  # rx charclass .
    ge rx166_pos, rx166_eos, rx166_fail
    inc rx166_pos
    set_addr $I10, rxquantf193_loop
    rx166_cur."!mark_push"(rx166_rep, rx166_pos, $I10)
  rxquantf193_done:
  # rxanchor bol
    eq rx166_pos, 0, rxanchor195_done
    ge rx166_pos, rx166_eos, rx166_fail
    sub $I10, rx166_pos, rx166_off
    dec $I10
    is_cclass $I11, 4096, rx166_tgt, $I10
    unless $I11, rx166_fail
  rxanchor195_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    .const 'Sub' $P197 = "29_1303603603.711" 
    capture_lex $P197
    $P10 = rx166_cur."before"($P197)
    unless $P10, rx166_fail
.annotate 'line', 100
    goto alt172_end
  alt172_4:
  alt203_0:
.annotate 'line', 107
    set_addr $I10, alt203_1
    rx166_cur."!mark_push"(0, rx166_pos, $I10)
  # rx charclass s
    ge rx166_pos, rx166_eos, rx166_fail
    sub $I10, rx166_pos, rx166_off
    is_cclass $I11, 32, rx166_tgt, $I10
    unless $I11, rx166_fail
    inc rx166_pos
    goto alt203_end
  alt203_1:
  # rx subrule "panic" subtype=method negate=
    rx166_cur."!cursor_pos"(rx166_pos)
    $P10 = rx166_cur."panic"("Illegal pod directive")
    unless $P10, rx166_fail
    rx166_pos = $P10."pos"()
  alt203_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx166_pos, rx166_off
    find_cclass $I11, 4096, rx166_tgt, $I10, rx166_eos
    add rx166_pos, rx166_off, $I11
  alt172_end:
.annotate 'line', 84
  # rx pass
    rx166_cur."!cursor_pass"(rx166_pos, "pod_comment")
    if_null rx166_debug, debug_655
    rx166_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx166_pos)
  debug_655:
    .return (rx166_cur)
  rx166_restart:
.annotate 'line', 10
    if_null rx166_debug, debug_656
    rx166_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_656:
  rx166_fail:
    (rx166_rep, rx166_pos, $I10, $P10) = rx166_cur."!mark_fail"(0)
    lt rx166_pos, -1, rx166_done
    eq rx166_pos, -1, rx166_fail
    jump $I10
  rx166_done:
    rx166_cur."!cursor_fail"()
    if_null rx166_debug, debug_657
    rx166_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_657:
    .return (rx166_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303603603.711") :method
.annotate 'line', 10
    new $P168, "ResizablePMCArray"
    push $P168, ""
    .return ($P168)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block196"  :anon :subid("29_1303603603.711") :method :outer("27_1303603603.711")
.annotate 'line', 101
    .local string rx198_tgt
    .local int rx198_pos
    .local int rx198_off
    .local int rx198_eos
    .local int rx198_rep
    .local pmc rx198_cur
    .local pmc rx198_debug
    (rx198_cur, rx198_pos, rx198_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx198_cur
    .local pmc match
    .lex "$/", match
    length rx198_eos, rx198_tgt
    gt rx198_pos, rx198_eos, rx198_done
    set rx198_off, 0
    lt rx198_pos, 2, rx198_start
    sub rx198_off, rx198_pos, 1
    substr rx198_tgt, rx198_tgt, rx198_off
  rx198_start:
    eq $I10, 1, rx198_restart
    if_null rx198_debug, debug_651
    rx198_cur."!cursor_debug"("START", "")
  debug_651:
    $I10 = self.'from'()
    ne $I10, -1, rxscan199_done
    goto rxscan199_scan
  rxscan199_loop:
    (rx198_pos) = rx198_cur."from"()
    inc rx198_pos
    rx198_cur."!cursor_from"(rx198_pos)
    ge rx198_pos, rx198_eos, rxscan199_done
  rxscan199_scan:
    set_addr $I10, rxscan199_loop
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
  rxscan199_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx198_pos, rx198_off
    set rx198_rep, 0
    sub $I12, rx198_eos, rx198_pos
  rxenumcharlistq200_loop:
    le $I12, 0, rxenumcharlistq200_done
    substr $S10, rx198_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq200_done
    inc rx198_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq200_loop
  rxenumcharlistq200_done:
    add rx198_pos, rx198_pos, rx198_rep
  alt201_0:
    set_addr $I10, alt201_1
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx198_pos, 1
    gt $I11, rx198_eos, rx198_fail
    sub $I11, rx198_pos, rx198_off
    ord $I11, rx198_tgt, $I11
    ne $I11, 61, rx198_fail
    add rx198_pos, 1
.annotate 'line', 104
  # rx rxquantr202 ** 0..1
    set_addr $I10, rxquantr202_done
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
  rxquantr202_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx198_pos, 3
    gt $I11, rx198_eos, rx198_fail
    sub $I11, rx198_pos, rx198_off
    substr $S10, rx198_tgt, $I11, 3
    ne $S10, "cut", rx198_fail
    add rx198_pos, 3
  # rxanchor rwb
    le rx198_pos, 0, rx198_fail
    sub $I10, rx198_pos, rx198_off
    is_cclass $I11, 8192, rx198_tgt, $I10
    if $I11, rx198_fail
    dec $I10
    is_cclass $I11, 8192, rx198_tgt, $I10
    unless $I11, rx198_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx198_cur."!cursor_pos"(rx198_pos)
    $P10 = rx198_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx198_fail
    rx198_pos = $P10."pos"()
    set_addr $I10, rxquantr202_done
    (rx198_rep) = rx198_cur."!mark_commit"($I10)
  rxquantr202_done:
.annotate 'line', 101
    goto alt201_end
  alt201_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx198_pos, rx198_eos, rx198_fail
    sub $I10, rx198_pos, rx198_off
    is_cclass $I11, 4096, rx198_tgt, $I10
    unless $I11, rx198_fail
    substr $S10, rx198_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx198_pos, $I11
    inc rx198_pos
  alt201_end:
.annotate 'line', 101
  # rx pass
    rx198_cur."!cursor_pass"(rx198_pos, "")
    if_null rx198_debug, debug_652
    rx198_cur."!cursor_debug"("PASS", "", " at pos=", rx198_pos)
  debug_652:
    .return (rx198_cur)
  rx198_restart:
    if_null rx198_debug, debug_653
    rx198_cur."!cursor_debug"("NEXT", "")
  debug_653:
  rx198_fail:
    (rx198_rep, rx198_pos, $I10, $P10) = rx198_cur."!mark_fail"(0)
    lt rx198_pos, -1, rx198_done
    eq rx198_pos, -1, rx198_fail
    jump $I10
  rx198_done:
    rx198_cur."!cursor_fail"()
    if_null rx198_debug, debug_654
    rx198_cur."!cursor_debug"("FAIL", "")
  debug_654:
    .return (rx198_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 116
    new $P205, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P205
.annotate 'line', 117
    new $P206, "Undef"
    .lex "$*MAIN_SUB", $P206
.annotate 'line', 121
    new $P207, "Undef"
    .lex "$*PACKAGE", $P207
.annotate 'line', 122
    new $P208, "Undef"
    .lex "$*GLOBALish", $P208
.annotate 'line', 10
    .local string rx209_tgt
    .local int rx209_pos
    .local int rx209_off
    .local int rx209_eos
    .local int rx209_rep
    .local pmc rx209_cur
    .local pmc rx209_debug
    (rx209_cur, rx209_pos, rx209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx209_cur
    .local pmc match
    .lex "$/", match
    length rx209_eos, rx209_tgt
    gt rx209_pos, rx209_eos, rx209_done
    set rx209_off, 0
    lt rx209_pos, 2, rx209_start
    sub rx209_off, rx209_pos, 1
    substr rx209_tgt, rx209_tgt, rx209_off
  rx209_start:
    eq $I10, 1, rx209_restart
    if_null rx209_debug, debug_658
    rx209_cur."!cursor_debug"("START", "comp_unit")
  debug_658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan213_done
    goto rxscan213_scan
  rxscan213_loop:
    (rx209_pos) = rx209_cur."from"()
    inc rx209_pos
    rx209_cur."!cursor_from"(rx209_pos)
    ge rx209_pos, rx209_eos, rxscan213_done
  rxscan213_scan:
    set_addr $I10, rxscan213_loop
    rx209_cur."!mark_push"(0, rx209_pos, $I10)
  rxscan213_done:
.annotate 'line', 116
    rx209_cur."!cursor_pos"(rx209_pos)
    new $P214, "Integer"
    assign $P214, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P214
.annotate 'line', 117
    rx209_cur."!cursor_pos"(rx209_pos)
    find_lex $P215, "$*MAIN_SUB"
    unless_null $P215, vivify_659
    get_hll_global $P215, "$MAIN_SUB"
    unless_null $P215, vivify_660
    die "Contextual $*MAIN_SUB not found"
  vivify_660:
  vivify_659:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx209_cur."!cursor_pos"(rx209_pos)
    $P10 = rx209_cur."newpad"()
    unless $P10, rx209_fail
    rx209_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx209_cur."!cursor_pos"(rx209_pos)
    $P10 = rx209_cur."outerctx"()
    unless $P10, rx209_fail
    rx209_pos = $P10."pos"()
.annotate 'line', 121
    rx209_cur."!cursor_pos"(rx209_pos)
    find_lex $P216, "$*PACKAGE"
    unless_null $P216, vivify_661
    get_hll_global $P216, "$PACKAGE"
    unless_null $P216, vivify_662
    die "Contextual $*PACKAGE not found"
  vivify_662:
  vivify_661:
.annotate 'line', 122
    rx209_cur."!cursor_pos"(rx209_pos)
    find_lex $P217, "$*GLOBALish"
    unless_null $P217, vivify_663
    get_hll_global $P217, "$GLOBALish"
    unless_null $P217, vivify_664
    die "Contextual $*GLOBALish not found"
  vivify_664:
  vivify_663:
.annotate 'line', 123
  # rx subrule "GLOBALish" subtype=method negate=
    rx209_cur."!cursor_pos"(rx209_pos)
    $P10 = rx209_cur."GLOBALish"()
    unless $P10, rx209_fail
    rx209_pos = $P10."pos"()
.annotate 'line', 125
  # rx subrule "statementlist" subtype=capture negate=
    rx209_cur."!cursor_pos"(rx209_pos)
    $P10 = rx209_cur."statementlist"()
    unless $P10, rx209_fail
    rx209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx209_pos = $P10."pos"()
  alt218_0:
.annotate 'line', 126
    set_addr $I10, alt218_1
    rx209_cur."!mark_push"(0, rx209_pos, $I10)
  # rxanchor eos
    ne rx209_pos, rx209_eos, rx209_fail
    goto alt218_end
  alt218_1:
  # rx subrule "panic" subtype=method negate=
    rx209_cur."!cursor_pos"(rx209_pos)
    $P10 = rx209_cur."panic"("Confused")
    unless $P10, rx209_fail
    rx209_pos = $P10."pos"()
  alt218_end:
.annotate 'line', 115
  # rx pass
    rx209_cur."!cursor_pass"(rx209_pos, "comp_unit")
    if_null rx209_debug, debug_665
    rx209_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx209_pos)
  debug_665:
    .return (rx209_cur)
  rx209_restart:
.annotate 'line', 10
    if_null rx209_debug, debug_666
    rx209_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_666:
  rx209_fail:
    (rx209_rep, rx209_pos, $I10, $P10) = rx209_cur."!mark_fail"(0)
    lt rx209_pos, -1, rx209_done
    eq rx209_pos, -1, rx209_fail
    jump $I10
  rx209_done:
    rx209_cur."!cursor_fail"()
    if_null rx209_debug, debug_667
    rx209_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_667:
    .return (rx209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303603603.711") :method
.annotate 'line', 10
    $P211 = self."!PREFIX__!subrule"("newpad", "")
    new $P212, "ResizablePMCArray"
    push $P212, $P211
    .return ($P212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx220_tgt
    .local int rx220_pos
    .local int rx220_off
    .local int rx220_eos
    .local int rx220_rep
    .local pmc rx220_cur
    .local pmc rx220_debug
    (rx220_cur, rx220_pos, rx220_tgt, $I10) = self."!cursor_start"()
    rx220_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx220_cur
    .local pmc match
    .lex "$/", match
    length rx220_eos, rx220_tgt
    gt rx220_pos, rx220_eos, rx220_done
    set rx220_off, 0
    lt rx220_pos, 2, rx220_start
    sub rx220_off, rx220_pos, 1
    substr rx220_tgt, rx220_tgt, rx220_off
  rx220_start:
    eq $I10, 1, rx220_restart
    if_null rx220_debug, debug_668
    rx220_cur."!cursor_debug"("START", "statementlist")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan225_done
    goto rxscan225_scan
  rxscan225_loop:
    (rx220_pos) = rx220_cur."from"()
    inc rx220_pos
    rx220_cur."!cursor_from"(rx220_pos)
    ge rx220_pos, rx220_eos, rxscan225_done
  rxscan225_scan:
    set_addr $I10, rxscan225_loop
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxscan225_done:
  alt226_0:
.annotate 'line', 129
    set_addr $I10, alt226_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
.annotate 'line', 130
  # rx subrule "ws" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."ws"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
  # rxanchor eos
    ne rx220_pos, rx220_eos, rx220_fail
  # rx subrule "ws" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."ws"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
    goto alt226_end
  alt226_1:
.annotate 'line', 131
  # rx subrule "ws" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."ws"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
  # rx rxquantr230 ** 0..*
    set_addr $I10, rxquantr230_done
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxquantr230_loop:
  # rx subrule "statement" subtype=capture negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."statement"()
    unless $P10, rx220_fail
    rx220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx220_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."eat_terminator"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."ws"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
    set_addr $I10, rxquantr230_done
    (rx220_rep) = rx220_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr230_done
    rx220_cur."!mark_push"(rx220_rep, rx220_pos, $I10)
    goto rxquantr230_loop
  rxquantr230_done:
  # rx subrule "ws" subtype=method negate=
    rx220_cur."!cursor_pos"(rx220_pos)
    $P10 = rx220_cur."ws"()
    unless $P10, rx220_fail
    rx220_pos = $P10."pos"()
  alt226_end:
.annotate 'line', 129
  # rx pass
    rx220_cur."!cursor_pass"(rx220_pos, "statementlist")
    if_null rx220_debug, debug_669
    rx220_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx220_pos)
  debug_669:
    .return (rx220_cur)
  rx220_restart:
.annotate 'line', 10
    if_null rx220_debug, debug_670
    rx220_cur."!cursor_debug"("NEXT", "statementlist")
  debug_670:
  rx220_fail:
    (rx220_rep, rx220_pos, $I10, $P10) = rx220_cur."!mark_fail"(0)
    lt rx220_pos, -1, rx220_done
    eq rx220_pos, -1, rx220_fail
    jump $I10
  rx220_done:
    rx220_cur."!cursor_fail"()
    if_null rx220_debug, debug_671
    rx220_cur."!cursor_debug"("FAIL", "statementlist")
  debug_671:
    .return (rx220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303603603.711") :method
.annotate 'line', 10
    $P222 = self."!PREFIX__!subrule"("ws", "")
    $P223 = self."!PREFIX__!subrule"("ws", "")
    new $P224, "ResizablePMCArray"
    push $P224, $P222
    push $P224, $P223
    .return ($P224)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P239 = "36_1303603603.711" 
    capture_lex $P239
    .local string rx234_tgt
    .local int rx234_pos
    .local int rx234_off
    .local int rx234_eos
    .local int rx234_rep
    .local pmc rx234_cur
    .local pmc rx234_debug
    (rx234_cur, rx234_pos, rx234_tgt, $I10) = self."!cursor_start"()
    rx234_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx234_cur
    .local pmc match
    .lex "$/", match
    length rx234_eos, rx234_tgt
    gt rx234_pos, rx234_eos, rx234_done
    set rx234_off, 0
    lt rx234_pos, 2, rx234_start
    sub rx234_off, rx234_pos, 1
    substr rx234_tgt, rx234_tgt, rx234_off
  rx234_start:
    eq $I10, 1, rx234_restart
    if_null rx234_debug, debug_672
    rx234_cur."!cursor_debug"("START", "statement")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan237_done
    goto rxscan237_scan
  rxscan237_loop:
    (rx234_pos) = rx234_cur."from"()
    inc rx234_pos
    rx234_cur."!cursor_from"(rx234_pos)
    ge rx234_pos, rx234_eos, rxscan237_done
  rxscan237_scan:
    set_addr $I10, rxscan237_loop
    rx234_cur."!mark_push"(0, rx234_pos, $I10)
  rxscan237_done:
.annotate 'line', 135
  # rx subrule "before" subtype=zerowidth negate=1
    rx234_cur."!cursor_pos"(rx234_pos)
    .const 'Sub' $P239 = "36_1303603603.711" 
    capture_lex $P239
    $P10 = rx234_cur."before"($P239)
    if $P10, rx234_fail
  alt243_0:
.annotate 'line', 136
    set_addr $I10, alt243_1
    rx234_cur."!mark_push"(0, rx234_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_control" subtype=capture negate=
    rx234_cur."!cursor_pos"(rx234_pos)
    $P10 = rx234_cur."statement_control"()
    unless $P10, rx234_fail
    rx234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx234_pos = $P10."pos"()
    goto alt243_end
  alt243_1:
.annotate 'line', 138
  # rx subrule "EXPR" subtype=capture negate=
    rx234_cur."!cursor_pos"(rx234_pos)
    $P10 = rx234_cur."EXPR"()
    unless $P10, rx234_fail
    rx234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx234_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx234_cur."!cursor_pos"(rx234_pos)
    $P10 = rx234_cur."ws"()
    unless $P10, rx234_fail
    rx234_pos = $P10."pos"()
.annotate 'line', 143
  # rx rxquantr244 ** 0..1
    set_addr $I10, rxquantr244_done
    rx234_cur."!mark_push"(0, rx234_pos, $I10)
  rxquantr244_loop:
  alt245_0:
.annotate 'line', 139
    set_addr $I10, alt245_1
    rx234_cur."!mark_push"(0, rx234_pos, $I10)
.annotate 'line', 140
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx234_cur."!cursor_pos"(rx234_pos)
    $P10 = rx234_cur."MARKED"("endstmt")
    unless $P10, rx234_fail
    goto alt245_end
  alt245_1:
    set_addr $I10, alt245_2
    rx234_cur."!mark_push"(0, rx234_pos, $I10)
.annotate 'line', 141
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx234_cur."!cursor_pos"(rx234_pos)
    $P10 = rx234_cur."statement_mod_cond"()
    unless $P10, rx234_fail
    rx234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx234_pos = $P10."pos"()
  # rx rxquantr246 ** 0..1
    set_addr $I10, rxquantr246_done
    rx234_cur."!mark_push"(0, rx234_pos, $I10)
  rxquantr246_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx234_cur."!cursor_pos"(rx234_pos)
    $P10 = rx234_cur."statement_mod_loop"()
    unless $P10, rx234_fail
    goto rxsubrule247_pass
  rxsubrule247_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx234_fail
  rxsubrule247_pass:
    set_addr $I10, rxsubrule247_back
    rx234_cur."!mark_push"(0, rx234_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx234_pos = $P10."pos"()
    set_addr $I10, rxquantr246_done
    (rx234_rep) = rx234_cur."!mark_commit"($I10)
  rxquantr246_done:
    goto alt245_end
  alt245_2:
.annotate 'line', 142
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx234_cur."!cursor_pos"(rx234_pos)
    $P10 = rx234_cur."statement_mod_loop"()
    unless $P10, rx234_fail
    rx234_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx234_pos = $P10."pos"()
  alt245_end:
.annotate 'line', 143
    set_addr $I10, rxquantr244_done
    (rx234_rep) = rx234_cur."!mark_commit"($I10)
  rxquantr244_done:
  alt243_end:
.annotate 'line', 134
  # rx pass
    rx234_cur."!cursor_pass"(rx234_pos, "statement")
    if_null rx234_debug, debug_677
    rx234_cur."!cursor_debug"("PASS", "statement", " at pos=", rx234_pos)
  debug_677:
    .return (rx234_cur)
  rx234_restart:
.annotate 'line', 10
    if_null rx234_debug, debug_678
    rx234_cur."!cursor_debug"("NEXT", "statement")
  debug_678:
  rx234_fail:
    (rx234_rep, rx234_pos, $I10, $P10) = rx234_cur."!mark_fail"(0)
    lt rx234_pos, -1, rx234_done
    eq rx234_pos, -1, rx234_fail
    jump $I10
  rx234_done:
    rx234_cur."!cursor_fail"()
    if_null rx234_debug, debug_679
    rx234_cur."!cursor_debug"("FAIL", "statement")
  debug_679:
    .return (rx234_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303603603.711") :method
.annotate 'line', 10
    new $P236, "ResizablePMCArray"
    push $P236, ""
    .return ($P236)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block238"  :anon :subid("36_1303603603.711") :method :outer("34_1303603603.711")
.annotate 'line', 135
    .local string rx240_tgt
    .local int rx240_pos
    .local int rx240_off
    .local int rx240_eos
    .local int rx240_rep
    .local pmc rx240_cur
    .local pmc rx240_debug
    (rx240_cur, rx240_pos, rx240_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx240_cur
    .local pmc match
    .lex "$/", match
    length rx240_eos, rx240_tgt
    gt rx240_pos, rx240_eos, rx240_done
    set rx240_off, 0
    lt rx240_pos, 2, rx240_start
    sub rx240_off, rx240_pos, 1
    substr rx240_tgt, rx240_tgt, rx240_off
  rx240_start:
    eq $I10, 1, rx240_restart
    if_null rx240_debug, debug_673
    rx240_cur."!cursor_debug"("START", "")
  debug_673:
    $I10 = self.'from'()
    ne $I10, -1, rxscan241_done
    goto rxscan241_scan
  rxscan241_loop:
    (rx240_pos) = rx240_cur."from"()
    inc rx240_pos
    rx240_cur."!cursor_from"(rx240_pos)
    ge rx240_pos, rx240_eos, rxscan241_done
  rxscan241_scan:
    set_addr $I10, rxscan241_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  rxscan241_done:
  alt242_0:
    set_addr $I10, alt242_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx240_fail
    inc rx240_pos
    goto alt242_end
  alt242_1:
  # rxanchor eos
    ne rx240_pos, rx240_eos, rx240_fail
  alt242_end:
  # rx pass
    rx240_cur."!cursor_pass"(rx240_pos, "")
    if_null rx240_debug, debug_674
    rx240_cur."!cursor_debug"("PASS", "", " at pos=", rx240_pos)
  debug_674:
    .return (rx240_cur)
  rx240_restart:
    if_null rx240_debug, debug_675
    rx240_cur."!cursor_debug"("NEXT", "")
  debug_675:
  rx240_fail:
    (rx240_rep, rx240_pos, $I10, $P10) = rx240_cur."!mark_fail"(0)
    lt rx240_pos, -1, rx240_done
    eq rx240_pos, -1, rx240_fail
    jump $I10
  rx240_done:
    rx240_cur."!cursor_fail"()
    if_null rx240_debug, debug_676
    rx240_cur."!cursor_debug"("FAIL", "")
  debug_676:
    .return (rx240_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx249_tgt
    .local int rx249_pos
    .local int rx249_off
    .local int rx249_eos
    .local int rx249_rep
    .local pmc rx249_cur
    .local pmc rx249_debug
    (rx249_cur, rx249_pos, rx249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx249_cur
    .local pmc match
    .lex "$/", match
    length rx249_eos, rx249_tgt
    gt rx249_pos, rx249_eos, rx249_done
    set rx249_off, 0
    lt rx249_pos, 2, rx249_start
    sub rx249_off, rx249_pos, 1
    substr rx249_tgt, rx249_tgt, rx249_off
  rx249_start:
    eq $I10, 1, rx249_restart
    if_null rx249_debug, debug_680
    rx249_cur."!cursor_debug"("START", "eat_terminator")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan252_done
    goto rxscan252_scan
  rxscan252_loop:
    (rx249_pos) = rx249_cur."from"()
    inc rx249_pos
    rx249_cur."!cursor_from"(rx249_pos)
    ge rx249_pos, rx249_eos, rxscan252_done
  rxscan252_scan:
    set_addr $I10, rxscan252_loop
    rx249_cur."!mark_push"(0, rx249_pos, $I10)
  rxscan252_done:
  alt253_0:
.annotate 'line', 147
    set_addr $I10, alt253_1
    rx249_cur."!mark_push"(0, rx249_pos, $I10)
.annotate 'line', 148
  # rx literal  ";"
    add $I11, rx249_pos, 1
    gt $I11, rx249_eos, rx249_fail
    sub $I11, rx249_pos, rx249_off
    ord $I11, rx249_tgt, $I11
    ne $I11, 59, rx249_fail
    add rx249_pos, 1
    goto alt253_end
  alt253_1:
    set_addr $I10, alt253_2
    rx249_cur."!mark_push"(0, rx249_pos, $I10)
.annotate 'line', 149
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx249_cur."!cursor_pos"(rx249_pos)
    $P10 = rx249_cur."MARKED"("endstmt")
    unless $P10, rx249_fail
    goto alt253_end
  alt253_2:
    set_addr $I10, alt253_3
    rx249_cur."!mark_push"(0, rx249_pos, $I10)
.annotate 'line', 150
  # rx subrule "terminator" subtype=zerowidth negate=
    rx249_cur."!cursor_pos"(rx249_pos)
    $P10 = rx249_cur."terminator"()
    unless $P10, rx249_fail
    goto alt253_end
  alt253_3:
.annotate 'line', 151
  # rxanchor eos
    ne rx249_pos, rx249_eos, rx249_fail
  alt253_end:
.annotate 'line', 147
  # rx pass
    rx249_cur."!cursor_pass"(rx249_pos, "eat_terminator")
    if_null rx249_debug, debug_681
    rx249_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx249_pos)
  debug_681:
    .return (rx249_cur)
  rx249_restart:
.annotate 'line', 10
    if_null rx249_debug, debug_682
    rx249_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_682:
  rx249_fail:
    (rx249_rep, rx249_pos, $I10, $P10) = rx249_cur."!mark_fail"(0)
    lt rx249_pos, -1, rx249_done
    eq rx249_pos, -1, rx249_fail
    jump $I10
  rx249_done:
    rx249_cur."!cursor_fail"()
    if_null rx249_debug, debug_683
    rx249_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_683:
    .return (rx249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303603603.711") :method
.annotate 'line', 10
    new $P251, "ResizablePMCArray"
    push $P251, ""
    push $P251, ""
    push $P251, ""
    push $P251, ";"
    .return ($P251)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx255_tgt
    .local int rx255_pos
    .local int rx255_off
    .local int rx255_eos
    .local int rx255_rep
    .local pmc rx255_cur
    .local pmc rx255_debug
    (rx255_cur, rx255_pos, rx255_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx255_cur
    .local pmc match
    .lex "$/", match
    length rx255_eos, rx255_tgt
    gt rx255_pos, rx255_eos, rx255_done
    set rx255_off, 0
    lt rx255_pos, 2, rx255_start
    sub rx255_off, rx255_pos, 1
    substr rx255_tgt, rx255_tgt, rx255_off
  rx255_start:
    eq $I10, 1, rx255_restart
    if_null rx255_debug, debug_684
    rx255_cur."!cursor_debug"("START", "xblock")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan259_done
    goto rxscan259_scan
  rxscan259_loop:
    (rx255_pos) = rx255_cur."from"()
    inc rx255_pos
    rx255_cur."!cursor_from"(rx255_pos)
    ge rx255_pos, rx255_eos, rxscan259_done
  rxscan259_scan:
    set_addr $I10, rxscan259_loop
    rx255_cur."!mark_push"(0, rx255_pos, $I10)
  rxscan259_done:
.annotate 'line', 155
  # rx subrule "EXPR" subtype=capture negate=
    rx255_cur."!cursor_pos"(rx255_pos)
    $P10 = rx255_cur."EXPR"()
    unless $P10, rx255_fail
    rx255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx255_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx255_cur."!cursor_pos"(rx255_pos)
    $P10 = rx255_cur."ws"()
    unless $P10, rx255_fail
    rx255_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx255_cur."!cursor_pos"(rx255_pos)
    $P10 = rx255_cur."pblock"()
    unless $P10, rx255_fail
    rx255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx255_pos = $P10."pos"()
.annotate 'line', 154
  # rx pass
    rx255_cur."!cursor_pass"(rx255_pos, "xblock")
    if_null rx255_debug, debug_685
    rx255_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx255_pos)
  debug_685:
    .return (rx255_cur)
  rx255_restart:
.annotate 'line', 10
    if_null rx255_debug, debug_686
    rx255_cur."!cursor_debug"("NEXT", "xblock")
  debug_686:
  rx255_fail:
    (rx255_rep, rx255_pos, $I10, $P10) = rx255_cur."!mark_fail"(0)
    lt rx255_pos, -1, rx255_done
    eq rx255_pos, -1, rx255_fail
    jump $I10
  rx255_done:
    rx255_cur."!cursor_fail"()
    if_null rx255_debug, debug_687
    rx255_cur."!cursor_debug"("FAIL", "xblock")
  debug_687:
    .return (rx255_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303603603.711") :method
.annotate 'line', 10
    $P257 = self."!PREFIX__!subrule"("EXPR", "")
    new $P258, "ResizablePMCArray"
    push $P258, $P257
    .return ($P258)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx261_tgt
    .local int rx261_pos
    .local int rx261_off
    .local int rx261_eos
    .local int rx261_rep
    .local pmc rx261_cur
    .local pmc rx261_debug
    (rx261_cur, rx261_pos, rx261_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx261_cur
    .local pmc match
    .lex "$/", match
    length rx261_eos, rx261_tgt
    gt rx261_pos, rx261_eos, rx261_done
    set rx261_off, 0
    lt rx261_pos, 2, rx261_start
    sub rx261_off, rx261_pos, 1
    substr rx261_tgt, rx261_tgt, rx261_off
  rx261_start:
    eq $I10, 1, rx261_restart
    if_null rx261_debug, debug_688
    rx261_cur."!cursor_debug"("START", "pblock")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan266_done
    goto rxscan266_scan
  rxscan266_loop:
    (rx261_pos) = rx261_cur."from"()
    inc rx261_pos
    rx261_cur."!cursor_from"(rx261_pos)
    ge rx261_pos, rx261_eos, rxscan266_done
  rxscan266_scan:
    set_addr $I10, rxscan266_loop
    rx261_cur."!mark_push"(0, rx261_pos, $I10)
  rxscan266_done:
  alt267_0:
.annotate 'line', 158
    set_addr $I10, alt267_1
    rx261_cur."!mark_push"(0, rx261_pos, $I10)
.annotate 'line', 159
  # rx subrule "lambda" subtype=method negate=
    rx261_cur."!cursor_pos"(rx261_pos)
    $P10 = rx261_cur."lambda"()
    unless $P10, rx261_fail
    rx261_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx261_cur."!cursor_pos"(rx261_pos)
    $P10 = rx261_cur."newpad"()
    unless $P10, rx261_fail
    rx261_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "signature" subtype=capture negate=
    rx261_cur."!cursor_pos"(rx261_pos)
    $P10 = rx261_cur."signature"()
    unless $P10, rx261_fail
    rx261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx261_pos = $P10."pos"()
.annotate 'line', 162
  # rx subrule "blockoid" subtype=capture negate=
    rx261_cur."!cursor_pos"(rx261_pos)
    $P10 = rx261_cur."blockoid"()
    unless $P10, rx261_fail
    rx261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx261_pos = $P10."pos"()
.annotate 'line', 159
    goto alt267_end
  alt267_1:
    set_addr $I10, alt267_2
    rx261_cur."!mark_push"(0, rx261_pos, $I10)
.annotate 'line', 163
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx261_pos, rx261_off
    substr $S10, rx261_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx261_fail
.annotate 'line', 164
  # rx subrule "newpad" subtype=method negate=
    rx261_cur."!cursor_pos"(rx261_pos)
    $P10 = rx261_cur."newpad"()
    unless $P10, rx261_fail
    rx261_pos = $P10."pos"()
.annotate 'line', 165
  # rx subrule "blockoid" subtype=capture negate=
    rx261_cur."!cursor_pos"(rx261_pos)
    $P10 = rx261_cur."blockoid"()
    unless $P10, rx261_fail
    rx261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx261_pos = $P10."pos"()
.annotate 'line', 163
    goto alt267_end
  alt267_2:
.annotate 'line', 166
  # rx subrule "panic" subtype=method negate=
    rx261_cur."!cursor_pos"(rx261_pos)
    $P10 = rx261_cur."panic"("Missing block")
    unless $P10, rx261_fail
    rx261_pos = $P10."pos"()
  alt267_end:
.annotate 'line', 158
  # rx pass
    rx261_cur."!cursor_pass"(rx261_pos, "pblock")
    if_null rx261_debug, debug_689
    rx261_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx261_pos)
  debug_689:
    .return (rx261_cur)
  rx261_restart:
.annotate 'line', 10
    if_null rx261_debug, debug_690
    rx261_cur."!cursor_debug"("NEXT", "pblock")
  debug_690:
  rx261_fail:
    (rx261_rep, rx261_pos, $I10, $P10) = rx261_cur."!mark_fail"(0)
    lt rx261_pos, -1, rx261_done
    eq rx261_pos, -1, rx261_fail
    jump $I10
  rx261_done:
    rx261_cur."!cursor_fail"()
    if_null rx261_debug, debug_691
    rx261_cur."!cursor_debug"("FAIL", "pblock")
  debug_691:
    .return (rx261_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303603603.711") :method
.annotate 'line', 10
    $P263 = self."!PREFIX__!subrule"("panic", "")
    $P264 = self."!PREFIX__!subrule"("lambda", "")
    new $P265, "ResizablePMCArray"
    push $P265, $P263
    push $P265, "{"
    push $P265, $P264
    .return ($P265)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx269_tgt
    .local int rx269_pos
    .local int rx269_off
    .local int rx269_eos
    .local int rx269_rep
    .local pmc rx269_cur
    .local pmc rx269_debug
    (rx269_cur, rx269_pos, rx269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx269_cur
    .local pmc match
    .lex "$/", match
    length rx269_eos, rx269_tgt
    gt rx269_pos, rx269_eos, rx269_done
    set rx269_off, 0
    lt rx269_pos, 2, rx269_start
    sub rx269_off, rx269_pos, 1
    substr rx269_tgt, rx269_tgt, rx269_off
  rx269_start:
    eq $I10, 1, rx269_restart
    if_null rx269_debug, debug_692
    rx269_cur."!cursor_debug"("START", "lambda")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan272_done
    goto rxscan272_scan
  rxscan272_loop:
    (rx269_pos) = rx269_cur."from"()
    inc rx269_pos
    rx269_cur."!cursor_from"(rx269_pos)
    ge rx269_pos, rx269_eos, rxscan272_done
  rxscan272_scan:
    set_addr $I10, rxscan272_loop
    rx269_cur."!mark_push"(0, rx269_pos, $I10)
  rxscan272_done:
  alt273_0:
.annotate 'line', 169
    set_addr $I10, alt273_1
    rx269_cur."!mark_push"(0, rx269_pos, $I10)
  # rx literal  "->"
    add $I11, rx269_pos, 2
    gt $I11, rx269_eos, rx269_fail
    sub $I11, rx269_pos, rx269_off
    substr $S10, rx269_tgt, $I11, 2
    ne $S10, "->", rx269_fail
    add rx269_pos, 2
    goto alt273_end
  alt273_1:
  # rx literal  "<->"
    add $I11, rx269_pos, 3
    gt $I11, rx269_eos, rx269_fail
    sub $I11, rx269_pos, rx269_off
    substr $S10, rx269_tgt, $I11, 3
    ne $S10, "<->", rx269_fail
    add rx269_pos, 3
  alt273_end:
  # rx pass
    rx269_cur."!cursor_pass"(rx269_pos, "lambda")
    if_null rx269_debug, debug_693
    rx269_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx269_pos)
  debug_693:
    .return (rx269_cur)
  rx269_restart:
.annotate 'line', 10
    if_null rx269_debug, debug_694
    rx269_cur."!cursor_debug"("NEXT", "lambda")
  debug_694:
  rx269_fail:
    (rx269_rep, rx269_pos, $I10, $P10) = rx269_cur."!mark_fail"(0)
    lt rx269_pos, -1, rx269_done
    eq rx269_pos, -1, rx269_fail
    jump $I10
  rx269_done:
    rx269_cur."!cursor_fail"()
    if_null rx269_debug, debug_695
    rx269_cur."!cursor_debug"("FAIL", "lambda")
  debug_695:
    .return (rx269_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303603603.711") :method
.annotate 'line', 10
    new $P271, "ResizablePMCArray"
    push $P271, "<->"
    push $P271, "->"
    .return ($P271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx275_tgt
    .local int rx275_pos
    .local int rx275_off
    .local int rx275_eos
    .local int rx275_rep
    .local pmc rx275_cur
    .local pmc rx275_debug
    (rx275_cur, rx275_pos, rx275_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx275_cur
    .local pmc match
    .lex "$/", match
    length rx275_eos, rx275_tgt
    gt rx275_pos, rx275_eos, rx275_done
    set rx275_off, 0
    lt rx275_pos, 2, rx275_start
    sub rx275_off, rx275_pos, 1
    substr rx275_tgt, rx275_tgt, rx275_off
  rx275_start:
    eq $I10, 1, rx275_restart
    if_null rx275_debug, debug_696
    rx275_cur."!cursor_debug"("START", "block")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan279_done
    goto rxscan279_scan
  rxscan279_loop:
    (rx275_pos) = rx275_cur."from"()
    inc rx275_pos
    rx275_cur."!cursor_from"(rx275_pos)
    ge rx275_pos, rx275_eos, rxscan279_done
  rxscan279_scan:
    set_addr $I10, rxscan279_loop
    rx275_cur."!mark_push"(0, rx275_pos, $I10)
  rxscan279_done:
  alt280_0:
.annotate 'line', 172
    set_addr $I10, alt280_1
    rx275_cur."!mark_push"(0, rx275_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx275_pos, rx275_off
    substr $S10, rx275_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx275_fail
    goto alt280_end
  alt280_1:
  # rx subrule "panic" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."panic"("Missing block")
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
  alt280_end:
.annotate 'line', 173
  # rx subrule "newpad" subtype=method negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."newpad"()
    unless $P10, rx275_fail
    rx275_pos = $P10."pos"()
.annotate 'line', 174
  # rx subrule "blockoid" subtype=capture negate=
    rx275_cur."!cursor_pos"(rx275_pos)
    $P10 = rx275_cur."blockoid"()
    unless $P10, rx275_fail
    rx275_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx275_pos = $P10."pos"()
.annotate 'line', 171
  # rx pass
    rx275_cur."!cursor_pass"(rx275_pos, "block")
    if_null rx275_debug, debug_697
    rx275_cur."!cursor_debug"("PASS", "block", " at pos=", rx275_pos)
  debug_697:
    .return (rx275_cur)
  rx275_restart:
.annotate 'line', 10
    if_null rx275_debug, debug_698
    rx275_cur."!cursor_debug"("NEXT", "block")
  debug_698:
  rx275_fail:
    (rx275_rep, rx275_pos, $I10, $P10) = rx275_cur."!mark_fail"(0)
    lt rx275_pos, -1, rx275_done
    eq rx275_pos, -1, rx275_fail
    jump $I10
  rx275_done:
    rx275_cur."!cursor_fail"()
    if_null rx275_debug, debug_699
    rx275_cur."!cursor_debug"("FAIL", "block")
  debug_699:
    .return (rx275_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303603603.711") :method
.annotate 'line', 10
    $P277 = self."!PREFIX__!subrule"("panic", "")
    new $P278, "ResizablePMCArray"
    push $P278, $P277
    push $P278, "{"
    .return ($P278)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx282_tgt
    .local int rx282_pos
    .local int rx282_off
    .local int rx282_eos
    .local int rx282_rep
    .local pmc rx282_cur
    .local pmc rx282_debug
    (rx282_cur, rx282_pos, rx282_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx282_cur
    .local pmc match
    .lex "$/", match
    length rx282_eos, rx282_tgt
    gt rx282_pos, rx282_eos, rx282_done
    set rx282_off, 0
    lt rx282_pos, 2, rx282_start
    sub rx282_off, rx282_pos, 1
    substr rx282_tgt, rx282_tgt, rx282_off
  rx282_start:
    eq $I10, 1, rx282_restart
    if_null rx282_debug, debug_700
    rx282_cur."!cursor_debug"("START", "blockoid")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan286_done
    goto rxscan286_scan
  rxscan286_loop:
    (rx282_pos) = rx282_cur."from"()
    inc rx282_pos
    rx282_cur."!cursor_from"(rx282_pos)
    ge rx282_pos, rx282_eos, rxscan286_done
  rxscan286_scan:
    set_addr $I10, rxscan286_loop
    rx282_cur."!mark_push"(0, rx282_pos, $I10)
  rxscan286_done:
.annotate 'line', 178
  # rx subrule "finishpad" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."finishpad"()
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
  alt287_0:
.annotate 'line', 179
    set_addr $I10, alt287_1
    rx282_cur."!mark_push"(0, rx282_pos, $I10)
.annotate 'line', 180
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx282_pos, 14
    gt $I11, rx282_eos, rx282_fail
    sub $I11, rx282_pos, rx282_off
    substr $S10, rx282_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx282_fail
    add rx282_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."you_are_here"()
    unless $P10, rx282_fail
    rx282_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx282_pos = $P10."pos"()
    goto alt287_end
  alt287_1:
.annotate 'line', 181
  # rx literal  "{"
    add $I11, rx282_pos, 1
    gt $I11, rx282_eos, rx282_fail
    sub $I11, rx282_pos, rx282_off
    ord $I11, rx282_tgt, $I11
    ne $I11, 123, rx282_fail
    add rx282_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."statementlist"()
    unless $P10, rx282_fail
    rx282_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx282_pos = $P10."pos"()
  alt288_0:
    set_addr $I10, alt288_1
    rx282_cur."!mark_push"(0, rx282_pos, $I10)
  # rx literal  "}"
    add $I11, rx282_pos, 1
    gt $I11, rx282_eos, rx282_fail
    sub $I11, rx282_pos, rx282_off
    ord $I11, rx282_tgt, $I11
    ne $I11, 125, rx282_fail
    add rx282_pos, 1
    goto alt288_end
  alt288_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."FAILGOAL"("'}'")
    unless $P10, rx282_fail
    goto rxsubrule290_pass
  rxsubrule290_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx282_fail
  rxsubrule290_pass:
    set_addr $I10, rxsubrule290_back
    rx282_cur."!mark_push"(0, rx282_pos, $I10, $P10)
    rx282_pos = $P10."pos"()
  alt288_end:
  alt287_end:
.annotate 'line', 183
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."ENDSTMT"()
    unless $P10, rx282_fail
.annotate 'line', 177
  # rx pass
    rx282_cur."!cursor_pass"(rx282_pos, "blockoid")
    if_null rx282_debug, debug_701
    rx282_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx282_pos)
  debug_701:
    .return (rx282_cur)
  rx282_restart:
.annotate 'line', 10
    if_null rx282_debug, debug_702
    rx282_cur."!cursor_debug"("NEXT", "blockoid")
  debug_702:
  rx282_fail:
    (rx282_rep, rx282_pos, $I10, $P10) = rx282_cur."!mark_fail"(0)
    lt rx282_pos, -1, rx282_done
    eq rx282_pos, -1, rx282_fail
    jump $I10
  rx282_done:
    rx282_cur."!cursor_fail"()
    if_null rx282_debug, debug_703
    rx282_cur."!cursor_debug"("FAIL", "blockoid")
  debug_703:
    .return (rx282_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303603603.711") :method
.annotate 'line', 10
    $P284 = self."!PREFIX__!subrule"("finishpad", "")
    new $P285, "ResizablePMCArray"
    push $P285, $P284
    .return ($P285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx292_tgt
    .local int rx292_pos
    .local int rx292_off
    .local int rx292_eos
    .local int rx292_rep
    .local pmc rx292_cur
    .local pmc rx292_debug
    (rx292_cur, rx292_pos, rx292_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx292_cur
    .local pmc match
    .lex "$/", match
    length rx292_eos, rx292_tgt
    gt rx292_pos, rx292_eos, rx292_done
    set rx292_off, 0
    lt rx292_pos, 2, rx292_start
    sub rx292_off, rx292_pos, 1
    substr rx292_tgt, rx292_tgt, rx292_off
  rx292_start:
    eq $I10, 1, rx292_restart
    if_null rx292_debug, debug_704
    rx292_cur."!cursor_debug"("START", "newpad")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan295_done
    goto rxscan295_scan
  rxscan295_loop:
    (rx292_pos) = rx292_cur."from"()
    inc rx292_pos
    rx292_cur."!cursor_from"(rx292_pos)
    ge rx292_pos, rx292_eos, rxscan295_done
  rxscan295_scan:
    set_addr $I10, rxscan295_loop
    rx292_cur."!mark_push"(0, rx292_pos, $I10)
  rxscan295_done:
.annotate 'line', 186
  # rx pass
    rx292_cur."!cursor_pass"(rx292_pos, "newpad")
    if_null rx292_debug, debug_705
    rx292_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx292_pos)
  debug_705:
    .return (rx292_cur)
  rx292_restart:
.annotate 'line', 10
    if_null rx292_debug, debug_706
    rx292_cur."!cursor_debug"("NEXT", "newpad")
  debug_706:
  rx292_fail:
    (rx292_rep, rx292_pos, $I10, $P10) = rx292_cur."!mark_fail"(0)
    lt rx292_pos, -1, rx292_done
    eq rx292_pos, -1, rx292_fail
    jump $I10
  rx292_done:
    rx292_cur."!cursor_fail"()
    if_null rx292_debug, debug_707
    rx292_cur."!cursor_debug"("FAIL", "newpad")
  debug_707:
    .return (rx292_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303603603.711") :method
.annotate 'line', 10
    new $P294, "ResizablePMCArray"
    push $P294, ""
    .return ($P294)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx297_tgt
    .local int rx297_pos
    .local int rx297_off
    .local int rx297_eos
    .local int rx297_rep
    .local pmc rx297_cur
    .local pmc rx297_debug
    (rx297_cur, rx297_pos, rx297_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx297_cur
    .local pmc match
    .lex "$/", match
    length rx297_eos, rx297_tgt
    gt rx297_pos, rx297_eos, rx297_done
    set rx297_off, 0
    lt rx297_pos, 2, rx297_start
    sub rx297_off, rx297_pos, 1
    substr rx297_tgt, rx297_tgt, rx297_off
  rx297_start:
    eq $I10, 1, rx297_restart
    if_null rx297_debug, debug_708
    rx297_cur."!cursor_debug"("START", "outerctx")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan300_done
    goto rxscan300_scan
  rxscan300_loop:
    (rx297_pos) = rx297_cur."from"()
    inc rx297_pos
    rx297_cur."!cursor_from"(rx297_pos)
    ge rx297_pos, rx297_eos, rxscan300_done
  rxscan300_scan:
    set_addr $I10, rxscan300_loop
    rx297_cur."!mark_push"(0, rx297_pos, $I10)
  rxscan300_done:
.annotate 'line', 187
  # rx pass
    rx297_cur."!cursor_pass"(rx297_pos, "outerctx")
    if_null rx297_debug, debug_709
    rx297_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx297_pos)
  debug_709:
    .return (rx297_cur)
  rx297_restart:
.annotate 'line', 10
    if_null rx297_debug, debug_710
    rx297_cur."!cursor_debug"("NEXT", "outerctx")
  debug_710:
  rx297_fail:
    (rx297_rep, rx297_pos, $I10, $P10) = rx297_cur."!mark_fail"(0)
    lt rx297_pos, -1, rx297_done
    eq rx297_pos, -1, rx297_fail
    jump $I10
  rx297_done:
    rx297_cur."!cursor_fail"()
    if_null rx297_debug, debug_711
    rx297_cur."!cursor_debug"("FAIL", "outerctx")
  debug_711:
    .return (rx297_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303603603.711") :method
.annotate 'line', 10
    new $P299, "ResizablePMCArray"
    push $P299, ""
    .return ($P299)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx302_tgt
    .local int rx302_pos
    .local int rx302_off
    .local int rx302_eos
    .local int rx302_rep
    .local pmc rx302_cur
    .local pmc rx302_debug
    (rx302_cur, rx302_pos, rx302_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx302_cur
    .local pmc match
    .lex "$/", match
    length rx302_eos, rx302_tgt
    gt rx302_pos, rx302_eos, rx302_done
    set rx302_off, 0
    lt rx302_pos, 2, rx302_start
    sub rx302_off, rx302_pos, 1
    substr rx302_tgt, rx302_tgt, rx302_off
  rx302_start:
    eq $I10, 1, rx302_restart
    if_null rx302_debug, debug_712
    rx302_cur."!cursor_debug"("START", "GLOBALish")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan305_done
    goto rxscan305_scan
  rxscan305_loop:
    (rx302_pos) = rx302_cur."from"()
    inc rx302_pos
    rx302_cur."!cursor_from"(rx302_pos)
    ge rx302_pos, rx302_eos, rxscan305_done
  rxscan305_scan:
    set_addr $I10, rxscan305_loop
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxscan305_done:
.annotate 'line', 188
  # rx pass
    rx302_cur."!cursor_pass"(rx302_pos, "GLOBALish")
    if_null rx302_debug, debug_713
    rx302_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx302_pos)
  debug_713:
    .return (rx302_cur)
  rx302_restart:
.annotate 'line', 10
    if_null rx302_debug, debug_714
    rx302_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_714:
  rx302_fail:
    (rx302_rep, rx302_pos, $I10, $P10) = rx302_cur."!mark_fail"(0)
    lt rx302_pos, -1, rx302_done
    eq rx302_pos, -1, rx302_fail
    jump $I10
  rx302_done:
    rx302_cur."!cursor_fail"()
    if_null rx302_debug, debug_715
    rx302_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_715:
    .return (rx302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303603603.711") :method
.annotate 'line', 10
    new $P304, "ResizablePMCArray"
    push $P304, ""
    .return ($P304)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx307_tgt
    .local int rx307_pos
    .local int rx307_off
    .local int rx307_eos
    .local int rx307_rep
    .local pmc rx307_cur
    .local pmc rx307_debug
    (rx307_cur, rx307_pos, rx307_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx307_cur
    .local pmc match
    .lex "$/", match
    length rx307_eos, rx307_tgt
    gt rx307_pos, rx307_eos, rx307_done
    set rx307_off, 0
    lt rx307_pos, 2, rx307_start
    sub rx307_off, rx307_pos, 1
    substr rx307_tgt, rx307_tgt, rx307_off
  rx307_start:
    eq $I10, 1, rx307_restart
    if_null rx307_debug, debug_716
    rx307_cur."!cursor_debug"("START", "finishpad")
  debug_716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan310_done
    goto rxscan310_scan
  rxscan310_loop:
    (rx307_pos) = rx307_cur."from"()
    inc rx307_pos
    rx307_cur."!cursor_from"(rx307_pos)
    ge rx307_pos, rx307_eos, rxscan310_done
  rxscan310_scan:
    set_addr $I10, rxscan310_loop
    rx307_cur."!mark_push"(0, rx307_pos, $I10)
  rxscan310_done:
.annotate 'line', 189
  # rx pass
    rx307_cur."!cursor_pass"(rx307_pos, "finishpad")
    if_null rx307_debug, debug_717
    rx307_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx307_pos)
  debug_717:
    .return (rx307_cur)
  rx307_restart:
.annotate 'line', 10
    if_null rx307_debug, debug_718
    rx307_cur."!cursor_debug"("NEXT", "finishpad")
  debug_718:
  rx307_fail:
    (rx307_rep, rx307_pos, $I10, $P10) = rx307_cur."!mark_fail"(0)
    lt rx307_pos, -1, rx307_done
    eq rx307_pos, -1, rx307_fail
    jump $I10
  rx307_done:
    rx307_cur."!cursor_fail"()
    if_null rx307_debug, debug_719
    rx307_cur."!cursor_debug"("FAIL", "finishpad")
  debug_719:
    .return (rx307_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303603603.711") :method
.annotate 'line', 10
    new $P309, "ResizablePMCArray"
    push $P309, ""
    .return ($P309)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx312_tgt
    .local int rx312_pos
    .local int rx312_off
    .local int rx312_eos
    .local int rx312_rep
    .local pmc rx312_cur
    .local pmc rx312_debug
    (rx312_cur, rx312_pos, rx312_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx312_cur
    .local pmc match
    .lex "$/", match
    length rx312_eos, rx312_tgt
    gt rx312_pos, rx312_eos, rx312_done
    set rx312_off, 0
    lt rx312_pos, 2, rx312_start
    sub rx312_off, rx312_pos, 1
    substr rx312_tgt, rx312_tgt, rx312_off
  rx312_start:
    eq $I10, 1, rx312_restart
    if_null rx312_debug, debug_720
    rx312_cur."!cursor_debug"("START", "you_are_here")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan315_done
    goto rxscan315_scan
  rxscan315_loop:
    (rx312_pos) = rx312_cur."from"()
    inc rx312_pos
    rx312_cur."!cursor_from"(rx312_pos)
    ge rx312_pos, rx312_eos, rxscan315_done
  rxscan315_scan:
    set_addr $I10, rxscan315_loop
    rx312_cur."!mark_push"(0, rx312_pos, $I10)
  rxscan315_done:
.annotate 'line', 190
  # rx pass
    rx312_cur."!cursor_pass"(rx312_pos, "you_are_here")
    if_null rx312_debug, debug_721
    rx312_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx312_pos)
  debug_721:
    .return (rx312_cur)
  rx312_restart:
.annotate 'line', 10
    if_null rx312_debug, debug_722
    rx312_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_722:
  rx312_fail:
    (rx312_rep, rx312_pos, $I10, $P10) = rx312_cur."!mark_fail"(0)
    lt rx312_pos, -1, rx312_done
    eq rx312_pos, -1, rx312_fail
    jump $I10
  rx312_done:
    rx312_cur."!cursor_fail"()
    if_null rx312_debug, debug_723
    rx312_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_723:
    .return (rx312_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303603603.711") :method
.annotate 'line', 10
    new $P314, "ResizablePMCArray"
    push $P314, ""
    .return ($P314)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303603603.711")
    .param pmc param_317
.annotate 'line', 192
    .lex "self", param_317
    $P318 = param_317."!protoregex"("terminator")
    .return ($P318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303603603.711")
    .param pmc param_320
.annotate 'line', 192
    .lex "self", param_320
    $P321 = param_320."!PREFIX__!protoregex"("terminator")
    .return ($P321)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx323_tgt
    .local int rx323_pos
    .local int rx323_off
    .local int rx323_eos
    .local int rx323_rep
    .local pmc rx323_cur
    .local pmc rx323_debug
    (rx323_cur, rx323_pos, rx323_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx323_cur
    .local pmc match
    .lex "$/", match
    length rx323_eos, rx323_tgt
    gt rx323_pos, rx323_eos, rx323_done
    set rx323_off, 0
    lt rx323_pos, 2, rx323_start
    sub rx323_off, rx323_pos, 1
    substr rx323_tgt, rx323_tgt, rx323_off
  rx323_start:
    eq $I10, 1, rx323_restart
    if_null rx323_debug, debug_724
    rx323_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan326_done
    goto rxscan326_scan
  rxscan326_loop:
    (rx323_pos) = rx323_cur."from"()
    inc rx323_pos
    rx323_cur."!cursor_from"(rx323_pos)
    ge rx323_pos, rx323_eos, rxscan326_done
  rxscan326_scan:
    set_addr $I10, rxscan326_loop
    rx323_cur."!mark_push"(0, rx323_pos, $I10)
  rxscan326_done:
.annotate 'line', 194
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx323_pos, rx323_off
    substr $S10, rx323_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx323_fail
  # rx pass
    rx323_cur."!cursor_pass"(rx323_pos, "terminator:sym<;>")
    if_null rx323_debug, debug_725
    rx323_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx323_pos)
  debug_725:
    .return (rx323_cur)
  rx323_restart:
.annotate 'line', 10
    if_null rx323_debug, debug_726
    rx323_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_726:
  rx323_fail:
    (rx323_rep, rx323_pos, $I10, $P10) = rx323_cur."!mark_fail"(0)
    lt rx323_pos, -1, rx323_done
    eq rx323_pos, -1, rx323_fail
    jump $I10
  rx323_done:
    rx323_cur."!cursor_fail"()
    if_null rx323_debug, debug_727
    rx323_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_727:
    .return (rx323_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303603603.711") :method
.annotate 'line', 10
    new $P325, "ResizablePMCArray"
    push $P325, ";"
    .return ($P325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx328_tgt
    .local int rx328_pos
    .local int rx328_off
    .local int rx328_eos
    .local int rx328_rep
    .local pmc rx328_cur
    .local pmc rx328_debug
    (rx328_cur, rx328_pos, rx328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx328_cur
    .local pmc match
    .lex "$/", match
    length rx328_eos, rx328_tgt
    gt rx328_pos, rx328_eos, rx328_done
    set rx328_off, 0
    lt rx328_pos, 2, rx328_start
    sub rx328_off, rx328_pos, 1
    substr rx328_tgt, rx328_tgt, rx328_off
  rx328_start:
    eq $I10, 1, rx328_restart
    if_null rx328_debug, debug_728
    rx328_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan331_done
    goto rxscan331_scan
  rxscan331_loop:
    (rx328_pos) = rx328_cur."from"()
    inc rx328_pos
    rx328_cur."!cursor_from"(rx328_pos)
    ge rx328_pos, rx328_eos, rxscan331_done
  rxscan331_scan:
    set_addr $I10, rxscan331_loop
    rx328_cur."!mark_push"(0, rx328_pos, $I10)
  rxscan331_done:
.annotate 'line', 195
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx328_pos, rx328_off
    substr $S10, rx328_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx328_fail
  # rx pass
    rx328_cur."!cursor_pass"(rx328_pos, "terminator:sym<}>")
    if_null rx328_debug, debug_729
    rx328_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx328_pos)
  debug_729:
    .return (rx328_cur)
  rx328_restart:
.annotate 'line', 10
    if_null rx328_debug, debug_730
    rx328_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_730:
  rx328_fail:
    (rx328_rep, rx328_pos, $I10, $P10) = rx328_cur."!mark_fail"(0)
    lt rx328_pos, -1, rx328_done
    eq rx328_pos, -1, rx328_fail
    jump $I10
  rx328_done:
    rx328_cur."!cursor_fail"()
    if_null rx328_debug, debug_731
    rx328_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_731:
    .return (rx328_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303603603.711") :method
.annotate 'line', 10
    new $P330, "ResizablePMCArray"
    push $P330, "}"
    .return ($P330)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303603603.711")
    .param pmc param_333
.annotate 'line', 199
    .lex "self", param_333
    $P334 = param_333."!protoregex"("statement_control")
    .return ($P334)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303603603.711")
    .param pmc param_336
.annotate 'line', 199
    .lex "self", param_336
    $P337 = param_336."!PREFIX__!protoregex"("statement_control")
    .return ($P337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx339_tgt
    .local int rx339_pos
    .local int rx339_off
    .local int rx339_eos
    .local int rx339_rep
    .local pmc rx339_cur
    .local pmc rx339_debug
    (rx339_cur, rx339_pos, rx339_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx339_cur
    .local pmc match
    .lex "$/", match
    length rx339_eos, rx339_tgt
    gt rx339_pos, rx339_eos, rx339_done
    set rx339_off, 0
    lt rx339_pos, 2, rx339_start
    sub rx339_off, rx339_pos, 1
    substr rx339_tgt, rx339_tgt, rx339_off
  rx339_start:
    eq $I10, 1, rx339_restart
    if_null rx339_debug, debug_732
    rx339_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan342_done
    goto rxscan342_scan
  rxscan342_loop:
    (rx339_pos) = rx339_cur."from"()
    inc rx339_pos
    rx339_cur."!cursor_from"(rx339_pos)
    ge rx339_pos, rx339_eos, rxscan342_done
  rxscan342_scan:
    set_addr $I10, rxscan342_loop
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
  rxscan342_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_343_fail
    rx339_cur."!mark_push"(0, rx339_pos, $I10)
  # rx literal  "use"
    add $I11, rx339_pos, 3
    gt $I11, rx339_eos, rx339_fail
    sub $I11, rx339_pos, rx339_off
    substr $S10, rx339_tgt, $I11, 3
    ne $S10, "use", rx339_fail
    add rx339_pos, 3
    set_addr $I10, rxcap_343_fail
    ($I12, $I11) = rx339_cur."!mark_peek"($I10)
    rx339_cur."!cursor_pos"($I11)
    ($P10) = rx339_cur."!cursor_start"()
    $P10."!cursor_pass"(rx339_pos, "")
    rx339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_343_done
  rxcap_343_fail:
    goto rx339_fail
  rxcap_343_done:
  # rx charclass s
    ge rx339_pos, rx339_eos, rx339_fail
    sub $I10, rx339_pos, rx339_off
    is_cclass $I11, 32, rx339_tgt, $I10
    unless $I11, rx339_fail
    inc rx339_pos
  # rx subrule "ws" subtype=method negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."ws"()
    unless $P10, rx339_fail
    rx339_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."name"()
    unless $P10, rx339_fail
    rx339_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx339_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx339_cur."!cursor_pos"(rx339_pos)
    $P10 = rx339_cur."ws"()
    unless $P10, rx339_fail
    rx339_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx339_cur."!cursor_pass"(rx339_pos, "statement_control:sym<use>")
    if_null rx339_debug, debug_733
    rx339_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx339_pos)
  debug_733:
    .return (rx339_cur)
  rx339_restart:
.annotate 'line', 10
    if_null rx339_debug, debug_734
    rx339_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_734:
  rx339_fail:
    (rx339_rep, rx339_pos, $I10, $P10) = rx339_cur."!mark_fail"(0)
    lt rx339_pos, -1, rx339_done
    eq rx339_pos, -1, rx339_fail
    jump $I10
  rx339_done:
    rx339_cur."!cursor_fail"()
    if_null rx339_debug, debug_735
    rx339_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_735:
    .return (rx339_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303603603.711") :method
.annotate 'line', 10
    new $P341, "ResizablePMCArray"
    push $P341, "use"
    .return ($P341)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    rx347_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_736
    rx347_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan350_done
    goto rxscan350_scan
  rxscan350_loop:
    (rx347_pos) = rx347_cur."from"()
    inc rx347_pos
    rx347_cur."!cursor_from"(rx347_pos)
    ge rx347_pos, rx347_eos, rxscan350_done
  rxscan350_scan:
    set_addr $I10, rxscan350_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan350_done:
.annotate 'line', 206
  # rx subcapture "sym"
    set_addr $I10, rxcap_351_fail
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  # rx literal  "if"
    add $I11, rx347_pos, 2
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 2
    ne $S10, "if", rx347_fail
    add rx347_pos, 2
    set_addr $I10, rxcap_351_fail
    ($I12, $I11) = rx347_cur."!mark_peek"($I10)
    rx347_cur."!cursor_pos"($I11)
    ($P10) = rx347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx347_pos, "")
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_351_done
  rxcap_351_fail:
    goto rx347_fail
  rxcap_351_done:
  # rx charclass s
    ge rx347_pos, rx347_eos, rx347_fail
    sub $I10, rx347_pos, rx347_off
    is_cclass $I11, 32, rx347_tgt, $I10
    unless $I11, rx347_fail
    inc rx347_pos
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 207
  # rx subrule "xblock" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."xblock"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx347_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 208
  # rx rxquantr354 ** 0..*
    set_addr $I10, rxquantr354_done
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxquantr354_loop:
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx347_pos, 5
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 5
    ne $S10, "elsif", rx347_fail
    add rx347_pos, 5
  # rx charclass s
    ge rx347_pos, rx347_eos, rx347_fail
    sub $I10, rx347_pos, rx347_off
    is_cclass $I11, 32, rx347_tgt, $I10
    unless $I11, rx347_fail
    inc rx347_pos
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."xblock"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx347_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
    set_addr $I10, rxquantr354_done
    (rx347_rep) = rx347_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr354_done
    rx347_cur."!mark_push"(rx347_rep, rx347_pos, $I10)
    goto rxquantr354_loop
  rxquantr354_done:
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 209
  # rx rxquantr359 ** 0..1
    set_addr $I10, rxquantr359_done
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxquantr359_loop:
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx347_pos, 4
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 4
    ne $S10, "else", rx347_fail
    add rx347_pos, 4
  # rx charclass s
    ge rx347_pos, rx347_eos, rx347_fail
    sub $I10, rx347_pos, rx347_off
    is_cclass $I11, 32, rx347_tgt, $I10
    unless $I11, rx347_fail
    inc rx347_pos
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."pblock"()
    unless $P10, rx347_fail
    rx347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx347_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
    set_addr $I10, rxquantr359_done
    (rx347_rep) = rx347_cur."!mark_commit"($I10)
  rxquantr359_done:
  # rx subrule "ws" subtype=method negate=
    rx347_cur."!cursor_pos"(rx347_pos)
    $P10 = rx347_cur."ws"()
    unless $P10, rx347_fail
    rx347_pos = $P10."pos"()
.annotate 'line', 205
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "statement_control:sym<if>")
    if_null rx347_debug, debug_737
    rx347_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx347_pos)
  debug_737:
    .return (rx347_cur)
  rx347_restart:
.annotate 'line', 10
    if_null rx347_debug, debug_738
    rx347_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_738:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_739
    rx347_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_739:
    .return (rx347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303603603.711") :method
.annotate 'line', 10
    new $P349, "ResizablePMCArray"
    push $P349, "if"
    .return ($P349)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P375 = "73_1303603603.711" 
    capture_lex $P375
    .local string rx365_tgt
    .local int rx365_pos
    .local int rx365_off
    .local int rx365_eos
    .local int rx365_rep
    .local pmc rx365_cur
    .local pmc rx365_debug
    (rx365_cur, rx365_pos, rx365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx365_cur
    .local pmc match
    .lex "$/", match
    length rx365_eos, rx365_tgt
    gt rx365_pos, rx365_eos, rx365_done
    set rx365_off, 0
    lt rx365_pos, 2, rx365_start
    sub rx365_off, rx365_pos, 1
    substr rx365_tgt, rx365_tgt, rx365_off
  rx365_start:
    eq $I10, 1, rx365_restart
    if_null rx365_debug, debug_740
    rx365_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_740:
    $I10 = self.'from'()
    ne $I10, -1, rxscan368_done
    goto rxscan368_scan
  rxscan368_loop:
    (rx365_pos) = rx365_cur."from"()
    inc rx365_pos
    rx365_cur."!cursor_from"(rx365_pos)
    ge rx365_pos, rx365_eos, rxscan368_done
  rxscan368_scan:
    set_addr $I10, rxscan368_loop
    rx365_cur."!mark_push"(0, rx365_pos, $I10)
  rxscan368_done:
.annotate 'line', 213
  # rx subcapture "sym"
    set_addr $I10, rxcap_369_fail
    rx365_cur."!mark_push"(0, rx365_pos, $I10)
  # rx literal  "unless"
    add $I11, rx365_pos, 6
    gt $I11, rx365_eos, rx365_fail
    sub $I11, rx365_pos, rx365_off
    substr $S10, rx365_tgt, $I11, 6
    ne $S10, "unless", rx365_fail
    add rx365_pos, 6
    set_addr $I10, rxcap_369_fail
    ($I12, $I11) = rx365_cur."!mark_peek"($I10)
    rx365_cur."!cursor_pos"($I11)
    ($P10) = rx365_cur."!cursor_start"()
    $P10."!cursor_pass"(rx365_pos, "")
    rx365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_369_done
  rxcap_369_fail:
    goto rx365_fail
  rxcap_369_done:
  # rx charclass s
    ge rx365_pos, rx365_eos, rx365_fail
    sub $I10, rx365_pos, rx365_off
    is_cclass $I11, 32, rx365_tgt, $I10
    unless $I11, rx365_fail
    inc rx365_pos
  # rx subrule "ws" subtype=method negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."ws"()
    unless $P10, rx365_fail
    rx365_pos = $P10."pos"()
.annotate 'line', 214
  # rx subrule "xblock" subtype=capture negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."xblock"()
    unless $P10, rx365_fail
    rx365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx365_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."ws"()
    unless $P10, rx365_fail
    rx365_pos = $P10."pos"()
  alt372_0:
.annotate 'line', 215
    set_addr $I10, alt372_1
    rx365_cur."!mark_push"(0, rx365_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."ws"()
    unless $P10, rx365_fail
    rx365_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx365_cur."!cursor_pos"(rx365_pos)
    .const 'Sub' $P375 = "73_1303603603.711" 
    capture_lex $P375
    $P10 = rx365_cur."before"($P375)
    if $P10, rx365_fail
  # rx subrule "ws" subtype=method negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."ws"()
    unless $P10, rx365_fail
    rx365_pos = $P10."pos"()
    goto alt372_end
  alt372_1:
  # rx subrule "ws" subtype=method negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."ws"()
    unless $P10, rx365_fail
    rx365_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx365_fail
    rx365_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."ws"()
    unless $P10, rx365_fail
    rx365_pos = $P10."pos"()
  alt372_end:
  # rx subrule "ws" subtype=method negate=
    rx365_cur."!cursor_pos"(rx365_pos)
    $P10 = rx365_cur."ws"()
    unless $P10, rx365_fail
    rx365_pos = $P10."pos"()
.annotate 'line', 212
  # rx pass
    rx365_cur."!cursor_pass"(rx365_pos, "statement_control:sym<unless>")
    if_null rx365_debug, debug_745
    rx365_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx365_pos)
  debug_745:
    .return (rx365_cur)
  rx365_restart:
.annotate 'line', 10
    if_null rx365_debug, debug_746
    rx365_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_746:
  rx365_fail:
    (rx365_rep, rx365_pos, $I10, $P10) = rx365_cur."!mark_fail"(0)
    lt rx365_pos, -1, rx365_done
    eq rx365_pos, -1, rx365_fail
    jump $I10
  rx365_done:
    rx365_cur."!cursor_fail"()
    if_null rx365_debug, debug_747
    rx365_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_747:
    .return (rx365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303603603.711") :method
.annotate 'line', 10
    new $P367, "ResizablePMCArray"
    push $P367, "unless"
    .return ($P367)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block374"  :anon :subid("73_1303603603.711") :method :outer("71_1303603603.711")
.annotate 'line', 215
    .local string rx376_tgt
    .local int rx376_pos
    .local int rx376_off
    .local int rx376_eos
    .local int rx376_rep
    .local pmc rx376_cur
    .local pmc rx376_debug
    (rx376_cur, rx376_pos, rx376_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx376_cur
    .local pmc match
    .lex "$/", match
    length rx376_eos, rx376_tgt
    gt rx376_pos, rx376_eos, rx376_done
    set rx376_off, 0
    lt rx376_pos, 2, rx376_start
    sub rx376_off, rx376_pos, 1
    substr rx376_tgt, rx376_tgt, rx376_off
  rx376_start:
    eq $I10, 1, rx376_restart
    if_null rx376_debug, debug_741
    rx376_cur."!cursor_debug"("START", "")
  debug_741:
    $I10 = self.'from'()
    ne $I10, -1, rxscan377_done
    goto rxscan377_scan
  rxscan377_loop:
    (rx376_pos) = rx376_cur."from"()
    inc rx376_pos
    rx376_cur."!cursor_from"(rx376_pos)
    ge rx376_pos, rx376_eos, rxscan377_done
  rxscan377_scan:
    set_addr $I10, rxscan377_loop
    rx376_cur."!mark_push"(0, rx376_pos, $I10)
  rxscan377_done:
  # rx literal  "else"
    add $I11, rx376_pos, 4
    gt $I11, rx376_eos, rx376_fail
    sub $I11, rx376_pos, rx376_off
    substr $S10, rx376_tgt, $I11, 4
    ne $S10, "else", rx376_fail
    add rx376_pos, 4
  # rx pass
    rx376_cur."!cursor_pass"(rx376_pos, "")
    if_null rx376_debug, debug_742
    rx376_cur."!cursor_debug"("PASS", "", " at pos=", rx376_pos)
  debug_742:
    .return (rx376_cur)
  rx376_restart:
    if_null rx376_debug, debug_743
    rx376_cur."!cursor_debug"("NEXT", "")
  debug_743:
  rx376_fail:
    (rx376_rep, rx376_pos, $I10, $P10) = rx376_cur."!mark_fail"(0)
    lt rx376_pos, -1, rx376_done
    eq rx376_pos, -1, rx376_fail
    jump $I10
  rx376_done:
    rx376_cur."!cursor_fail"()
    if_null rx376_debug, debug_744
    rx376_cur."!cursor_debug"("FAIL", "")
  debug_744:
    .return (rx376_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_748
    rx383_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan386_done
    goto rxscan386_scan
  rxscan386_loop:
    (rx383_pos) = rx383_cur."from"()
    inc rx383_pos
    rx383_cur."!cursor_from"(rx383_pos)
    ge rx383_pos, rx383_eos, rxscan386_done
  rxscan386_scan:
    set_addr $I10, rxscan386_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan386_done:
.annotate 'line', 219
  # rx subcapture "sym"
    set_addr $I10, rxcap_388_fail
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  alt387_0:
    set_addr $I10, alt387_1
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  # rx literal  "while"
    add $I11, rx383_pos, 5
    gt $I11, rx383_eos, rx383_fail
    sub $I11, rx383_pos, rx383_off
    substr $S10, rx383_tgt, $I11, 5
    ne $S10, "while", rx383_fail
    add rx383_pos, 5
    goto alt387_end
  alt387_1:
  # rx literal  "until"
    add $I11, rx383_pos, 5
    gt $I11, rx383_eos, rx383_fail
    sub $I11, rx383_pos, rx383_off
    substr $S10, rx383_tgt, $I11, 5
    ne $S10, "until", rx383_fail
    add rx383_pos, 5
  alt387_end:
    set_addr $I10, rxcap_388_fail
    ($I12, $I11) = rx383_cur."!mark_peek"($I10)
    rx383_cur."!cursor_pos"($I11)
    ($P10) = rx383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx383_pos, "")
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_388_done
  rxcap_388_fail:
    goto rx383_fail
  rxcap_388_done:
  # rx charclass s
    ge rx383_pos, rx383_eos, rx383_fail
    sub $I10, rx383_pos, rx383_off
    is_cclass $I11, 32, rx383_tgt, $I10
    unless $I11, rx383_fail
    inc rx383_pos
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 220
  # rx subrule "xblock" subtype=capture negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."xblock"()
    unless $P10, rx383_fail
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 218
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "statement_control:sym<while>")
    if_null rx383_debug, debug_749
    rx383_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx383_pos)
  debug_749:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 10
    if_null rx383_debug, debug_750
    rx383_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_750:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_751
    rx383_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_751:
    .return (rx383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303603603.711") :method
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, "until"
    push $P385, "while"
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx392_tgt
    .local int rx392_pos
    .local int rx392_off
    .local int rx392_eos
    .local int rx392_rep
    .local pmc rx392_cur
    .local pmc rx392_debug
    (rx392_cur, rx392_pos, rx392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx392_cur
    .local pmc match
    .lex "$/", match
    length rx392_eos, rx392_tgt
    gt rx392_pos, rx392_eos, rx392_done
    set rx392_off, 0
    lt rx392_pos, 2, rx392_start
    sub rx392_off, rx392_pos, 1
    substr rx392_tgt, rx392_tgt, rx392_off
  rx392_start:
    eq $I10, 1, rx392_restart
    if_null rx392_debug, debug_752
    rx392_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan395_done
    goto rxscan395_scan
  rxscan395_loop:
    (rx392_pos) = rx392_cur."from"()
    inc rx392_pos
    rx392_cur."!cursor_from"(rx392_pos)
    ge rx392_pos, rx392_eos, rxscan395_done
  rxscan395_scan:
    set_addr $I10, rxscan395_loop
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  rxscan395_done:
.annotate 'line', 224
  # rx subcapture "sym"
    set_addr $I10, rxcap_396_fail
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx392_pos, 6
    gt $I11, rx392_eos, rx392_fail
    sub $I11, rx392_pos, rx392_off
    substr $S10, rx392_tgt, $I11, 6
    ne $S10, "repeat", rx392_fail
    add rx392_pos, 6
    set_addr $I10, rxcap_396_fail
    ($I12, $I11) = rx392_cur."!mark_peek"($I10)
    rx392_cur."!cursor_pos"($I11)
    ($P10) = rx392_cur."!cursor_start"()
    $P10."!cursor_pass"(rx392_pos, "")
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_396_done
  rxcap_396_fail:
    goto rx392_fail
  rxcap_396_done:
  # rx charclass s
    ge rx392_pos, rx392_eos, rx392_fail
    sub $I10, rx392_pos, rx392_off
    is_cclass $I11, 32, rx392_tgt, $I10
    unless $I11, rx392_fail
    inc rx392_pos
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  alt398_0:
.annotate 'line', 225
    set_addr $I10, alt398_1
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
.annotate 'line', 226
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_401_fail
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  alt400_0:
    set_addr $I10, alt400_1
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  # rx literal  "while"
    add $I11, rx392_pos, 5
    gt $I11, rx392_eos, rx392_fail
    sub $I11, rx392_pos, rx392_off
    substr $S10, rx392_tgt, $I11, 5
    ne $S10, "while", rx392_fail
    add rx392_pos, 5
    goto alt400_end
  alt400_1:
  # rx literal  "until"
    add $I11, rx392_pos, 5
    gt $I11, rx392_eos, rx392_fail
    sub $I11, rx392_pos, rx392_off
    substr $S10, rx392_tgt, $I11, 5
    ne $S10, "until", rx392_fail
    add rx392_pos, 5
  alt400_end:
    set_addr $I10, rxcap_401_fail
    ($I12, $I11) = rx392_cur."!mark_peek"($I10)
    rx392_cur."!cursor_pos"($I11)
    ($P10) = rx392_cur."!cursor_start"()
    $P10."!cursor_pass"(rx392_pos, "")
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_401_done
  rxcap_401_fail:
    goto rx392_fail
  rxcap_401_done:
  # rx charclass s
    ge rx392_pos, rx392_eos, rx392_fail
    sub $I10, rx392_pos, rx392_off
    is_cclass $I11, 32, rx392_tgt, $I10
    unless $I11, rx392_fail
    inc rx392_pos
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."xblock"()
    unless $P10, rx392_fail
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx392_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
    goto alt398_end
  alt398_1:
.annotate 'line', 227
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."pblock"()
    unless $P10, rx392_fail
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx392_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_407_fail
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  alt406_0:
    set_addr $I10, alt406_1
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  # rx literal  "while"
    add $I11, rx392_pos, 5
    gt $I11, rx392_eos, rx392_fail
    sub $I11, rx392_pos, rx392_off
    substr $S10, rx392_tgt, $I11, 5
    ne $S10, "while", rx392_fail
    add rx392_pos, 5
    goto alt406_end
  alt406_1:
  # rx literal  "until"
    add $I11, rx392_pos, 5
    gt $I11, rx392_eos, rx392_fail
    sub $I11, rx392_pos, rx392_off
    substr $S10, rx392_tgt, $I11, 5
    ne $S10, "until", rx392_fail
    add rx392_pos, 5
  alt406_end:
    set_addr $I10, rxcap_407_fail
    ($I12, $I11) = rx392_cur."!mark_peek"($I10)
    rx392_cur."!cursor_pos"($I11)
    ($P10) = rx392_cur."!cursor_start"()
    $P10."!cursor_pass"(rx392_pos, "")
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_407_done
  rxcap_407_fail:
    goto rx392_fail
  rxcap_407_done:
  # rx charclass s
    ge rx392_pos, rx392_eos, rx392_fail
    sub $I10, rx392_pos, rx392_off
    is_cclass $I11, 32, rx392_tgt, $I10
    unless $I11, rx392_fail
    inc rx392_pos
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."EXPR"()
    unless $P10, rx392_fail
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx392_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  alt398_end:
.annotate 'line', 228
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
.annotate 'line', 223
  # rx pass
    rx392_cur."!cursor_pass"(rx392_pos, "statement_control:sym<repeat>")
    if_null rx392_debug, debug_753
    rx392_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx392_pos)
  debug_753:
    .return (rx392_cur)
  rx392_restart:
.annotate 'line', 10
    if_null rx392_debug, debug_754
    rx392_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_754:
  rx392_fail:
    (rx392_rep, rx392_pos, $I10, $P10) = rx392_cur."!mark_fail"(0)
    lt rx392_pos, -1, rx392_done
    eq rx392_pos, -1, rx392_fail
    jump $I10
  rx392_done:
    rx392_cur."!cursor_fail"()
    if_null rx392_debug, debug_755
    rx392_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_755:
    .return (rx392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303603603.711") :method
.annotate 'line', 10
    new $P394, "ResizablePMCArray"
    push $P394, "repeat"
    .return ($P394)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx412_tgt
    .local int rx412_pos
    .local int rx412_off
    .local int rx412_eos
    .local int rx412_rep
    .local pmc rx412_cur
    .local pmc rx412_debug
    (rx412_cur, rx412_pos, rx412_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx412_cur
    .local pmc match
    .lex "$/", match
    length rx412_eos, rx412_tgt
    gt rx412_pos, rx412_eos, rx412_done
    set rx412_off, 0
    lt rx412_pos, 2, rx412_start
    sub rx412_off, rx412_pos, 1
    substr rx412_tgt, rx412_tgt, rx412_off
  rx412_start:
    eq $I10, 1, rx412_restart
    if_null rx412_debug, debug_756
    rx412_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan415_done
    goto rxscan415_scan
  rxscan415_loop:
    (rx412_pos) = rx412_cur."from"()
    inc rx412_pos
    rx412_cur."!cursor_from"(rx412_pos)
    ge rx412_pos, rx412_eos, rxscan415_done
  rxscan415_scan:
    set_addr $I10, rxscan415_loop
    rx412_cur."!mark_push"(0, rx412_pos, $I10)
  rxscan415_done:
.annotate 'line', 232
  # rx subcapture "sym"
    set_addr $I10, rxcap_416_fail
    rx412_cur."!mark_push"(0, rx412_pos, $I10)
  # rx literal  "for"
    add $I11, rx412_pos, 3
    gt $I11, rx412_eos, rx412_fail
    sub $I11, rx412_pos, rx412_off
    substr $S10, rx412_tgt, $I11, 3
    ne $S10, "for", rx412_fail
    add rx412_pos, 3
    set_addr $I10, rxcap_416_fail
    ($I12, $I11) = rx412_cur."!mark_peek"($I10)
    rx412_cur."!cursor_pos"($I11)
    ($P10) = rx412_cur."!cursor_start"()
    $P10."!cursor_pass"(rx412_pos, "")
    rx412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_416_done
  rxcap_416_fail:
    goto rx412_fail
  rxcap_416_done:
  # rx charclass s
    ge rx412_pos, rx412_eos, rx412_fail
    sub $I10, rx412_pos, rx412_off
    is_cclass $I11, 32, rx412_tgt, $I10
    unless $I11, rx412_fail
    inc rx412_pos
  # rx subrule "ws" subtype=method negate=
    rx412_cur."!cursor_pos"(rx412_pos)
    $P10 = rx412_cur."ws"()
    unless $P10, rx412_fail
    rx412_pos = $P10."pos"()
.annotate 'line', 233
  # rx subrule "xblock" subtype=capture negate=
    rx412_cur."!cursor_pos"(rx412_pos)
    $P10 = rx412_cur."xblock"()
    unless $P10, rx412_fail
    rx412_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx412_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx412_cur."!cursor_pos"(rx412_pos)
    $P10 = rx412_cur."ws"()
    unless $P10, rx412_fail
    rx412_pos = $P10."pos"()
.annotate 'line', 231
  # rx pass
    rx412_cur."!cursor_pass"(rx412_pos, "statement_control:sym<for>")
    if_null rx412_debug, debug_757
    rx412_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx412_pos)
  debug_757:
    .return (rx412_cur)
  rx412_restart:
.annotate 'line', 10
    if_null rx412_debug, debug_758
    rx412_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_758:
  rx412_fail:
    (rx412_rep, rx412_pos, $I10, $P10) = rx412_cur."!mark_fail"(0)
    lt rx412_pos, -1, rx412_done
    eq rx412_pos, -1, rx412_fail
    jump $I10
  rx412_done:
    rx412_cur."!cursor_fail"()
    if_null rx412_debug, debug_759
    rx412_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_759:
    .return (rx412_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303603603.711") :method
.annotate 'line', 10
    new $P414, "ResizablePMCArray"
    push $P414, "for"
    .return ($P414)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx420_tgt
    .local int rx420_pos
    .local int rx420_off
    .local int rx420_eos
    .local int rx420_rep
    .local pmc rx420_cur
    .local pmc rx420_debug
    (rx420_cur, rx420_pos, rx420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx420_cur
    .local pmc match
    .lex "$/", match
    length rx420_eos, rx420_tgt
    gt rx420_pos, rx420_eos, rx420_done
    set rx420_off, 0
    lt rx420_pos, 2, rx420_start
    sub rx420_off, rx420_pos, 1
    substr rx420_tgt, rx420_tgt, rx420_off
  rx420_start:
    eq $I10, 1, rx420_restart
    if_null rx420_debug, debug_760
    rx420_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan423_done
    goto rxscan423_scan
  rxscan423_loop:
    (rx420_pos) = rx420_cur."from"()
    inc rx420_pos
    rx420_cur."!cursor_from"(rx420_pos)
    ge rx420_pos, rx420_eos, rxscan423_done
  rxscan423_scan:
    set_addr $I10, rxscan423_loop
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  rxscan423_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_424_fail
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx420_pos, 5
    gt $I11, rx420_eos, rx420_fail
    sub $I11, rx420_pos, rx420_off
    substr $S10, rx420_tgt, $I11, 5
    ne $S10, "CATCH", rx420_fail
    add rx420_pos, 5
    set_addr $I10, rxcap_424_fail
    ($I12, $I11) = rx420_cur."!mark_peek"($I10)
    rx420_cur."!cursor_pos"($I11)
    ($P10) = rx420_cur."!cursor_start"()
    $P10."!cursor_pass"(rx420_pos, "")
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_424_done
  rxcap_424_fail:
    goto rx420_fail
  rxcap_424_done:
  # rx charclass s
    ge rx420_pos, rx420_eos, rx420_fail
    sub $I10, rx420_pos, rx420_off
    is_cclass $I11, 32, rx420_tgt, $I10
    unless $I11, rx420_fail
    inc rx420_pos
  # rx subrule "ws" subtype=method negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."ws"()
    unless $P10, rx420_fail
    rx420_pos = $P10."pos"()
.annotate 'line', 238
  # rx subrule "block" subtype=capture negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."block"()
    unless $P10, rx420_fail
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx420_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."ws"()
    unless $P10, rx420_fail
    rx420_pos = $P10."pos"()
.annotate 'line', 236
  # rx pass
    rx420_cur."!cursor_pass"(rx420_pos, "statement_control:sym<CATCH>")
    if_null rx420_debug, debug_761
    rx420_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx420_pos)
  debug_761:
    .return (rx420_cur)
  rx420_restart:
.annotate 'line', 10
    if_null rx420_debug, debug_762
    rx420_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_762:
  rx420_fail:
    (rx420_rep, rx420_pos, $I10, $P10) = rx420_cur."!mark_fail"(0)
    lt rx420_pos, -1, rx420_done
    eq rx420_pos, -1, rx420_fail
    jump $I10
  rx420_done:
    rx420_cur."!cursor_fail"()
    if_null rx420_debug, debug_763
    rx420_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_763:
    .return (rx420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303603603.711") :method
.annotate 'line', 10
    new $P422, "ResizablePMCArray"
    push $P422, "CATCH"
    .return ($P422)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx428_tgt
    .local int rx428_pos
    .local int rx428_off
    .local int rx428_eos
    .local int rx428_rep
    .local pmc rx428_cur
    .local pmc rx428_debug
    (rx428_cur, rx428_pos, rx428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx428_cur
    .local pmc match
    .lex "$/", match
    length rx428_eos, rx428_tgt
    gt rx428_pos, rx428_eos, rx428_done
    set rx428_off, 0
    lt rx428_pos, 2, rx428_start
    sub rx428_off, rx428_pos, 1
    substr rx428_tgt, rx428_tgt, rx428_off
  rx428_start:
    eq $I10, 1, rx428_restart
    if_null rx428_debug, debug_764
    rx428_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan431_done
    goto rxscan431_scan
  rxscan431_loop:
    (rx428_pos) = rx428_cur."from"()
    inc rx428_pos
    rx428_cur."!cursor_from"(rx428_pos)
    ge rx428_pos, rx428_eos, rxscan431_done
  rxscan431_scan:
    set_addr $I10, rxscan431_loop
    rx428_cur."!mark_push"(0, rx428_pos, $I10)
  rxscan431_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_432_fail
    rx428_cur."!mark_push"(0, rx428_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx428_pos, 7
    gt $I11, rx428_eos, rx428_fail
    sub $I11, rx428_pos, rx428_off
    substr $S10, rx428_tgt, $I11, 7
    ne $S10, "CONTROL", rx428_fail
    add rx428_pos, 7
    set_addr $I10, rxcap_432_fail
    ($I12, $I11) = rx428_cur."!mark_peek"($I10)
    rx428_cur."!cursor_pos"($I11)
    ($P10) = rx428_cur."!cursor_start"()
    $P10."!cursor_pass"(rx428_pos, "")
    rx428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_432_done
  rxcap_432_fail:
    goto rx428_fail
  rxcap_432_done:
  # rx charclass s
    ge rx428_pos, rx428_eos, rx428_fail
    sub $I10, rx428_pos, rx428_off
    is_cclass $I11, 32, rx428_tgt, $I10
    unless $I11, rx428_fail
    inc rx428_pos
  # rx subrule "ws" subtype=method negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."ws"()
    unless $P10, rx428_fail
    rx428_pos = $P10."pos"()
.annotate 'line', 243
  # rx subrule "block" subtype=capture negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."block"()
    unless $P10, rx428_fail
    rx428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx428_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."ws"()
    unless $P10, rx428_fail
    rx428_pos = $P10."pos"()
.annotate 'line', 241
  # rx pass
    rx428_cur."!cursor_pass"(rx428_pos, "statement_control:sym<CONTROL>")
    if_null rx428_debug, debug_765
    rx428_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx428_pos)
  debug_765:
    .return (rx428_cur)
  rx428_restart:
.annotate 'line', 10
    if_null rx428_debug, debug_766
    rx428_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_766:
  rx428_fail:
    (rx428_rep, rx428_pos, $I10, $P10) = rx428_cur."!mark_fail"(0)
    lt rx428_pos, -1, rx428_done
    eq rx428_pos, -1, rx428_fail
    jump $I10
  rx428_done:
    rx428_cur."!cursor_fail"()
    if_null rx428_debug, debug_767
    rx428_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_767:
    .return (rx428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303603603.711") :method
.annotate 'line', 10
    new $P430, "ResizablePMCArray"
    push $P430, "CONTROL"
    .return ($P430)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303603603.711")
    .param pmc param_436
.annotate 'line', 246
    .lex "self", param_436
    $P437 = param_436."!protoregex"("statement_prefix")
    .return ($P437)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303603603.711")
    .param pmc param_439
.annotate 'line', 246
    .lex "self", param_439
    $P440 = param_439."!PREFIX__!protoregex"("statement_prefix")
    .return ($P440)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx442_tgt
    .local int rx442_pos
    .local int rx442_off
    .local int rx442_eos
    .local int rx442_rep
    .local pmc rx442_cur
    .local pmc rx442_debug
    (rx442_cur, rx442_pos, rx442_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx442_cur
    .local pmc match
    .lex "$/", match
    length rx442_eos, rx442_tgt
    gt rx442_pos, rx442_eos, rx442_done
    set rx442_off, 0
    lt rx442_pos, 2, rx442_start
    sub rx442_off, rx442_pos, 1
    substr rx442_tgt, rx442_tgt, rx442_off
  rx442_start:
    eq $I10, 1, rx442_restart
    if_null rx442_debug, debug_768
    rx442_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan446_done
    goto rxscan446_scan
  rxscan446_loop:
    (rx442_pos) = rx442_cur."from"()
    inc rx442_pos
    rx442_cur."!cursor_from"(rx442_pos)
    ge rx442_pos, rx442_eos, rxscan446_done
  rxscan446_scan:
    set_addr $I10, rxscan446_loop
    rx442_cur."!mark_push"(0, rx442_pos, $I10)
  rxscan446_done:
.annotate 'line', 247
  # rx subcapture "sym"
    set_addr $I10, rxcap_447_fail
    rx442_cur."!mark_push"(0, rx442_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx442_pos, 4
    gt $I11, rx442_eos, rx442_fail
    sub $I11, rx442_pos, rx442_off
    substr $S10, rx442_tgt, $I11, 4
    ne $S10, "INIT", rx442_fail
    add rx442_pos, 4
    set_addr $I10, rxcap_447_fail
    ($I12, $I11) = rx442_cur."!mark_peek"($I10)
    rx442_cur."!cursor_pos"($I11)
    ($P10) = rx442_cur."!cursor_start"()
    $P10."!cursor_pass"(rx442_pos, "")
    rx442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_447_done
  rxcap_447_fail:
    goto rx442_fail
  rxcap_447_done:
  # rx subrule "blorst" subtype=capture negate=
    rx442_cur."!cursor_pos"(rx442_pos)
    $P10 = rx442_cur."blorst"()
    unless $P10, rx442_fail
    rx442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx442_pos = $P10."pos"()
  # rx pass
    rx442_cur."!cursor_pass"(rx442_pos, "statement_prefix:sym<INIT>")
    if_null rx442_debug, debug_769
    rx442_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx442_pos)
  debug_769:
    .return (rx442_cur)
  rx442_restart:
.annotate 'line', 10
    if_null rx442_debug, debug_770
    rx442_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_770:
  rx442_fail:
    (rx442_rep, rx442_pos, $I10, $P10) = rx442_cur."!mark_fail"(0)
    lt rx442_pos, -1, rx442_done
    eq rx442_pos, -1, rx442_fail
    jump $I10
  rx442_done:
    rx442_cur."!cursor_fail"()
    if_null rx442_debug, debug_771
    rx442_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_771:
    .return (rx442_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303603603.711") :method
.annotate 'line', 10
    $P444 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P445, "ResizablePMCArray"
    push $P445, $P444
    .return ($P445)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx449_tgt
    .local int rx449_pos
    .local int rx449_off
    .local int rx449_eos
    .local int rx449_rep
    .local pmc rx449_cur
    .local pmc rx449_debug
    (rx449_cur, rx449_pos, rx449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx449_cur
    .local pmc match
    .lex "$/", match
    length rx449_eos, rx449_tgt
    gt rx449_pos, rx449_eos, rx449_done
    set rx449_off, 0
    lt rx449_pos, 2, rx449_start
    sub rx449_off, rx449_pos, 1
    substr rx449_tgt, rx449_tgt, rx449_off
  rx449_start:
    eq $I10, 1, rx449_restart
    if_null rx449_debug, debug_772
    rx449_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan453_done
    goto rxscan453_scan
  rxscan453_loop:
    (rx449_pos) = rx449_cur."from"()
    inc rx449_pos
    rx449_cur."!cursor_from"(rx449_pos)
    ge rx449_pos, rx449_eos, rxscan453_done
  rxscan453_scan:
    set_addr $I10, rxscan453_loop
    rx449_cur."!mark_push"(0, rx449_pos, $I10)
  rxscan453_done:
.annotate 'line', 250
  # rx subcapture "sym"
    set_addr $I10, rxcap_454_fail
    rx449_cur."!mark_push"(0, rx449_pos, $I10)
  # rx literal  "try"
    add $I11, rx449_pos, 3
    gt $I11, rx449_eos, rx449_fail
    sub $I11, rx449_pos, rx449_off
    substr $S10, rx449_tgt, $I11, 3
    ne $S10, "try", rx449_fail
    add rx449_pos, 3
    set_addr $I10, rxcap_454_fail
    ($I12, $I11) = rx449_cur."!mark_peek"($I10)
    rx449_cur."!cursor_pos"($I11)
    ($P10) = rx449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx449_pos, "")
    rx449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_454_done
  rxcap_454_fail:
    goto rx449_fail
  rxcap_454_done:
.annotate 'line', 251
  # rx subrule "blorst" subtype=capture negate=
    rx449_cur."!cursor_pos"(rx449_pos)
    $P10 = rx449_cur."blorst"()
    unless $P10, rx449_fail
    rx449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx449_pos = $P10."pos"()
.annotate 'line', 249
  # rx pass
    rx449_cur."!cursor_pass"(rx449_pos, "statement_prefix:sym<try>")
    if_null rx449_debug, debug_773
    rx449_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx449_pos)
  debug_773:
    .return (rx449_cur)
  rx449_restart:
.annotate 'line', 10
    if_null rx449_debug, debug_774
    rx449_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_774:
  rx449_fail:
    (rx449_rep, rx449_pos, $I10, $P10) = rx449_cur."!mark_fail"(0)
    lt rx449_pos, -1, rx449_done
    eq rx449_pos, -1, rx449_fail
    jump $I10
  rx449_done:
    rx449_cur."!cursor_fail"()
    if_null rx449_debug, debug_775
    rx449_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_775:
    .return (rx449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303603603.711") :method
.annotate 'line', 10
    $P451 = self."!PREFIX__!subrule"("blorst", "try")
    new $P452, "ResizablePMCArray"
    push $P452, $P451
    .return ($P452)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx456_tgt
    .local int rx456_pos
    .local int rx456_off
    .local int rx456_eos
    .local int rx456_rep
    .local pmc rx456_cur
    .local pmc rx456_debug
    (rx456_cur, rx456_pos, rx456_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx456_cur
    .local pmc match
    .lex "$/", match
    length rx456_eos, rx456_tgt
    gt rx456_pos, rx456_eos, rx456_done
    set rx456_off, 0
    lt rx456_pos, 2, rx456_start
    sub rx456_off, rx456_pos, 1
    substr rx456_tgt, rx456_tgt, rx456_off
  rx456_start:
    eq $I10, 1, rx456_restart
    if_null rx456_debug, debug_776
    rx456_cur."!cursor_debug"("START", "blorst")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan459_done
    goto rxscan459_scan
  rxscan459_loop:
    (rx456_pos) = rx456_cur."from"()
    inc rx456_pos
    rx456_cur."!cursor_from"(rx456_pos)
    ge rx456_pos, rx456_eos, rxscan459_done
  rxscan459_scan:
    set_addr $I10, rxscan459_loop
    rx456_cur."!mark_push"(0, rx456_pos, $I10)
  rxscan459_done:
.annotate 'line', 255
  # rx charclass s
    ge rx456_pos, rx456_eos, rx456_fail
    sub $I10, rx456_pos, rx456_off
    is_cclass $I11, 32, rx456_tgt, $I10
    unless $I11, rx456_fail
    inc rx456_pos
  # rx subrule "ws" subtype=method negate=
    rx456_cur."!cursor_pos"(rx456_pos)
    $P10 = rx456_cur."ws"()
    unless $P10, rx456_fail
    rx456_pos = $P10."pos"()
  alt460_0:
    set_addr $I10, alt460_1
    rx456_cur."!mark_push"(0, rx456_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx456_pos, rx456_off
    substr $S10, rx456_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx456_fail
  # rx subrule "block" subtype=capture negate=
    rx456_cur."!cursor_pos"(rx456_pos)
    $P10 = rx456_cur."block"()
    unless $P10, rx456_fail
    rx456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx456_pos = $P10."pos"()
    goto alt460_end
  alt460_1:
  # rx subrule "statement" subtype=capture negate=
    rx456_cur."!cursor_pos"(rx456_pos)
    $P10 = rx456_cur."statement"()
    unless $P10, rx456_fail
    rx456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx456_pos = $P10."pos"()
  alt460_end:
.annotate 'line', 254
  # rx pass
    rx456_cur."!cursor_pass"(rx456_pos, "blorst")
    if_null rx456_debug, debug_777
    rx456_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx456_pos)
  debug_777:
    .return (rx456_cur)
  rx456_restart:
.annotate 'line', 10
    if_null rx456_debug, debug_778
    rx456_cur."!cursor_debug"("NEXT", "blorst")
  debug_778:
  rx456_fail:
    (rx456_rep, rx456_pos, $I10, $P10) = rx456_cur."!mark_fail"(0)
    lt rx456_pos, -1, rx456_done
    eq rx456_pos, -1, rx456_fail
    jump $I10
  rx456_done:
    rx456_cur."!cursor_fail"()
    if_null rx456_debug, debug_779
    rx456_cur."!cursor_debug"("FAIL", "blorst")
  debug_779:
    .return (rx456_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303603603.711") :method
.annotate 'line', 10
    new $P458, "ResizablePMCArray"
    push $P458, ""
    .return ($P458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303603603.711")
    .param pmc param_462
.annotate 'line', 260
    .lex "self", param_462
    $P463 = param_462."!protoregex"("statement_mod_cond")
    .return ($P463)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303603603.711")
    .param pmc param_465
.annotate 'line', 260
    .lex "self", param_465
    $P466 = param_465."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx468_tgt
    .local int rx468_pos
    .local int rx468_off
    .local int rx468_eos
    .local int rx468_rep
    .local pmc rx468_cur
    .local pmc rx468_debug
    (rx468_cur, rx468_pos, rx468_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx468_cur
    .local pmc match
    .lex "$/", match
    length rx468_eos, rx468_tgt
    gt rx468_pos, rx468_eos, rx468_done
    set rx468_off, 0
    lt rx468_pos, 2, rx468_start
    sub rx468_off, rx468_pos, 1
    substr rx468_tgt, rx468_tgt, rx468_off
  rx468_start:
    eq $I10, 1, rx468_restart
    if_null rx468_debug, debug_780
    rx468_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan472_done
    goto rxscan472_scan
  rxscan472_loop:
    (rx468_pos) = rx468_cur."from"()
    inc rx468_pos
    rx468_cur."!cursor_from"(rx468_pos)
    ge rx468_pos, rx468_eos, rxscan472_done
  rxscan472_scan:
    set_addr $I10, rxscan472_loop
    rx468_cur."!mark_push"(0, rx468_pos, $I10)
  rxscan472_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_473_fail
    rx468_cur."!mark_push"(0, rx468_pos, $I10)
  # rx literal  "if"
    add $I11, rx468_pos, 2
    gt $I11, rx468_eos, rx468_fail
    sub $I11, rx468_pos, rx468_off
    substr $S10, rx468_tgt, $I11, 2
    ne $S10, "if", rx468_fail
    add rx468_pos, 2
    set_addr $I10, rxcap_473_fail
    ($I12, $I11) = rx468_cur."!mark_peek"($I10)
    rx468_cur."!cursor_pos"($I11)
    ($P10) = rx468_cur."!cursor_start"()
    $P10."!cursor_pass"(rx468_pos, "")
    rx468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_473_done
  rxcap_473_fail:
    goto rx468_fail
  rxcap_473_done:
  # rx subrule "ws" subtype=method negate=
    rx468_cur."!cursor_pos"(rx468_pos)
    $P10 = rx468_cur."ws"()
    unless $P10, rx468_fail
    rx468_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx468_cur."!cursor_pos"(rx468_pos)
    $P10 = rx468_cur."EXPR"()
    unless $P10, rx468_fail
    rx468_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx468_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx468_cur."!cursor_pos"(rx468_pos)
    $P10 = rx468_cur."ws"()
    unless $P10, rx468_fail
    rx468_pos = $P10."pos"()
  # rx pass
    rx468_cur."!cursor_pass"(rx468_pos, "statement_mod_cond:sym<if>")
    if_null rx468_debug, debug_781
    rx468_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx468_pos)
  debug_781:
    .return (rx468_cur)
  rx468_restart:
.annotate 'line', 10
    if_null rx468_debug, debug_782
    rx468_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_782:
  rx468_fail:
    (rx468_rep, rx468_pos, $I10, $P10) = rx468_cur."!mark_fail"(0)
    lt rx468_pos, -1, rx468_done
    eq rx468_pos, -1, rx468_fail
    jump $I10
  rx468_done:
    rx468_cur."!cursor_fail"()
    if_null rx468_debug, debug_783
    rx468_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_783:
    .return (rx468_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303603603.711") :method
.annotate 'line', 10
    $P470 = self."!PREFIX__!subrule"("ws", "if")
    new $P471, "ResizablePMCArray"
    push $P471, $P470
    .return ($P471)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx477_tgt
    .local int rx477_pos
    .local int rx477_off
    .local int rx477_eos
    .local int rx477_rep
    .local pmc rx477_cur
    .local pmc rx477_debug
    (rx477_cur, rx477_pos, rx477_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx477_cur
    .local pmc match
    .lex "$/", match
    length rx477_eos, rx477_tgt
    gt rx477_pos, rx477_eos, rx477_done
    set rx477_off, 0
    lt rx477_pos, 2, rx477_start
    sub rx477_off, rx477_pos, 1
    substr rx477_tgt, rx477_tgt, rx477_off
  rx477_start:
    eq $I10, 1, rx477_restart
    if_null rx477_debug, debug_784
    rx477_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan481_done
    goto rxscan481_scan
  rxscan481_loop:
    (rx477_pos) = rx477_cur."from"()
    inc rx477_pos
    rx477_cur."!cursor_from"(rx477_pos)
    ge rx477_pos, rx477_eos, rxscan481_done
  rxscan481_scan:
    set_addr $I10, rxscan481_loop
    rx477_cur."!mark_push"(0, rx477_pos, $I10)
  rxscan481_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_482_fail
    rx477_cur."!mark_push"(0, rx477_pos, $I10)
  # rx literal  "unless"
    add $I11, rx477_pos, 6
    gt $I11, rx477_eos, rx477_fail
    sub $I11, rx477_pos, rx477_off
    substr $S10, rx477_tgt, $I11, 6
    ne $S10, "unless", rx477_fail
    add rx477_pos, 6
    set_addr $I10, rxcap_482_fail
    ($I12, $I11) = rx477_cur."!mark_peek"($I10)
    rx477_cur."!cursor_pos"($I11)
    ($P10) = rx477_cur."!cursor_start"()
    $P10."!cursor_pass"(rx477_pos, "")
    rx477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_482_done
  rxcap_482_fail:
    goto rx477_fail
  rxcap_482_done:
  # rx subrule "ws" subtype=method negate=
    rx477_cur."!cursor_pos"(rx477_pos)
    $P10 = rx477_cur."ws"()
    unless $P10, rx477_fail
    rx477_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx477_cur."!cursor_pos"(rx477_pos)
    $P10 = rx477_cur."EXPR"()
    unless $P10, rx477_fail
    rx477_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx477_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx477_cur."!cursor_pos"(rx477_pos)
    $P10 = rx477_cur."ws"()
    unless $P10, rx477_fail
    rx477_pos = $P10."pos"()
  # rx pass
    rx477_cur."!cursor_pass"(rx477_pos, "statement_mod_cond:sym<unless>")
    if_null rx477_debug, debug_785
    rx477_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx477_pos)
  debug_785:
    .return (rx477_cur)
  rx477_restart:
.annotate 'line', 10
    if_null rx477_debug, debug_786
    rx477_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_786:
  rx477_fail:
    (rx477_rep, rx477_pos, $I10, $P10) = rx477_cur."!mark_fail"(0)
    lt rx477_pos, -1, rx477_done
    eq rx477_pos, -1, rx477_fail
    jump $I10
  rx477_done:
    rx477_cur."!cursor_fail"()
    if_null rx477_debug, debug_787
    rx477_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_787:
    .return (rx477_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303603603.711") :method
.annotate 'line', 10
    $P479 = self."!PREFIX__!subrule"("ws", "unless")
    new $P480, "ResizablePMCArray"
    push $P480, $P479
    .return ($P480)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303603603.711")
    .param pmc param_486
.annotate 'line', 265
    .lex "self", param_486
    $P487 = param_486."!protoregex"("statement_mod_loop")
    .return ($P487)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303603603.711")
    .param pmc param_489
.annotate 'line', 265
    .lex "self", param_489
    $P490 = param_489."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx492_tgt
    .local int rx492_pos
    .local int rx492_off
    .local int rx492_eos
    .local int rx492_rep
    .local pmc rx492_cur
    .local pmc rx492_debug
    (rx492_cur, rx492_pos, rx492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx492_cur
    .local pmc match
    .lex "$/", match
    length rx492_eos, rx492_tgt
    gt rx492_pos, rx492_eos, rx492_done
    set rx492_off, 0
    lt rx492_pos, 2, rx492_start
    sub rx492_off, rx492_pos, 1
    substr rx492_tgt, rx492_tgt, rx492_off
  rx492_start:
    eq $I10, 1, rx492_restart
    if_null rx492_debug, debug_788
    rx492_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan496_done
    goto rxscan496_scan
  rxscan496_loop:
    (rx492_pos) = rx492_cur."from"()
    inc rx492_pos
    rx492_cur."!cursor_from"(rx492_pos)
    ge rx492_pos, rx492_eos, rxscan496_done
  rxscan496_scan:
    set_addr $I10, rxscan496_loop
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  rxscan496_done:
.annotate 'line', 267
  # rx subcapture "sym"
    set_addr $I10, rxcap_497_fail
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  # rx literal  "while"
    add $I11, rx492_pos, 5
    gt $I11, rx492_eos, rx492_fail
    sub $I11, rx492_pos, rx492_off
    substr $S10, rx492_tgt, $I11, 5
    ne $S10, "while", rx492_fail
    add rx492_pos, 5
    set_addr $I10, rxcap_497_fail
    ($I12, $I11) = rx492_cur."!mark_peek"($I10)
    rx492_cur."!cursor_pos"($I11)
    ($P10) = rx492_cur."!cursor_start"()
    $P10."!cursor_pass"(rx492_pos, "")
    rx492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_497_done
  rxcap_497_fail:
    goto rx492_fail
  rxcap_497_done:
  # rx subrule "ws" subtype=method negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."ws"()
    unless $P10, rx492_fail
    rx492_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."EXPR"()
    unless $P10, rx492_fail
    rx492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx492_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."ws"()
    unless $P10, rx492_fail
    rx492_pos = $P10."pos"()
  # rx pass
    rx492_cur."!cursor_pass"(rx492_pos, "statement_mod_loop:sym<while>")
    if_null rx492_debug, debug_789
    rx492_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx492_pos)
  debug_789:
    .return (rx492_cur)
  rx492_restart:
.annotate 'line', 10
    if_null rx492_debug, debug_790
    rx492_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_790:
  rx492_fail:
    (rx492_rep, rx492_pos, $I10, $P10) = rx492_cur."!mark_fail"(0)
    lt rx492_pos, -1, rx492_done
    eq rx492_pos, -1, rx492_fail
    jump $I10
  rx492_done:
    rx492_cur."!cursor_fail"()
    if_null rx492_debug, debug_791
    rx492_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_791:
    .return (rx492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303603603.711") :method
.annotate 'line', 10
    $P494 = self."!PREFIX__!subrule"("ws", "while")
    new $P495, "ResizablePMCArray"
    push $P495, $P494
    .return ($P495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx501_tgt
    .local int rx501_pos
    .local int rx501_off
    .local int rx501_eos
    .local int rx501_rep
    .local pmc rx501_cur
    .local pmc rx501_debug
    (rx501_cur, rx501_pos, rx501_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx501_cur
    .local pmc match
    .lex "$/", match
    length rx501_eos, rx501_tgt
    gt rx501_pos, rx501_eos, rx501_done
    set rx501_off, 0
    lt rx501_pos, 2, rx501_start
    sub rx501_off, rx501_pos, 1
    substr rx501_tgt, rx501_tgt, rx501_off
  rx501_start:
    eq $I10, 1, rx501_restart
    if_null rx501_debug, debug_792
    rx501_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan505_done
    goto rxscan505_scan
  rxscan505_loop:
    (rx501_pos) = rx501_cur."from"()
    inc rx501_pos
    rx501_cur."!cursor_from"(rx501_pos)
    ge rx501_pos, rx501_eos, rxscan505_done
  rxscan505_scan:
    set_addr $I10, rxscan505_loop
    rx501_cur."!mark_push"(0, rx501_pos, $I10)
  rxscan505_done:
.annotate 'line', 268
  # rx subcapture "sym"
    set_addr $I10, rxcap_506_fail
    rx501_cur."!mark_push"(0, rx501_pos, $I10)
  # rx literal  "until"
    add $I11, rx501_pos, 5
    gt $I11, rx501_eos, rx501_fail
    sub $I11, rx501_pos, rx501_off
    substr $S10, rx501_tgt, $I11, 5
    ne $S10, "until", rx501_fail
    add rx501_pos, 5
    set_addr $I10, rxcap_506_fail
    ($I12, $I11) = rx501_cur."!mark_peek"($I10)
    rx501_cur."!cursor_pos"($I11)
    ($P10) = rx501_cur."!cursor_start"()
    $P10."!cursor_pass"(rx501_pos, "")
    rx501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_506_done
  rxcap_506_fail:
    goto rx501_fail
  rxcap_506_done:
  # rx subrule "ws" subtype=method negate=
    rx501_cur."!cursor_pos"(rx501_pos)
    $P10 = rx501_cur."ws"()
    unless $P10, rx501_fail
    rx501_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx501_cur."!cursor_pos"(rx501_pos)
    $P10 = rx501_cur."EXPR"()
    unless $P10, rx501_fail
    rx501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx501_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx501_cur."!cursor_pos"(rx501_pos)
    $P10 = rx501_cur."ws"()
    unless $P10, rx501_fail
    rx501_pos = $P10."pos"()
  # rx pass
    rx501_cur."!cursor_pass"(rx501_pos, "statement_mod_loop:sym<until>")
    if_null rx501_debug, debug_793
    rx501_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx501_pos)
  debug_793:
    .return (rx501_cur)
  rx501_restart:
.annotate 'line', 10
    if_null rx501_debug, debug_794
    rx501_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_794:
  rx501_fail:
    (rx501_rep, rx501_pos, $I10, $P10) = rx501_cur."!mark_fail"(0)
    lt rx501_pos, -1, rx501_done
    eq rx501_pos, -1, rx501_fail
    jump $I10
  rx501_done:
    rx501_cur."!cursor_fail"()
    if_null rx501_debug, debug_795
    rx501_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_795:
    .return (rx501_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303603603.711") :method
.annotate 'line', 10
    $P503 = self."!PREFIX__!subrule"("ws", "until")
    new $P504, "ResizablePMCArray"
    push $P504, $P503
    .return ($P504)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx510_tgt
    .local int rx510_pos
    .local int rx510_off
    .local int rx510_eos
    .local int rx510_rep
    .local pmc rx510_cur
    .local pmc rx510_debug
    (rx510_cur, rx510_pos, rx510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx510_cur
    .local pmc match
    .lex "$/", match
    length rx510_eos, rx510_tgt
    gt rx510_pos, rx510_eos, rx510_done
    set rx510_off, 0
    lt rx510_pos, 2, rx510_start
    sub rx510_off, rx510_pos, 1
    substr rx510_tgt, rx510_tgt, rx510_off
  rx510_start:
    eq $I10, 1, rx510_restart
    if_null rx510_debug, debug_796
    rx510_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan514_done
    goto rxscan514_scan
  rxscan514_loop:
    (rx510_pos) = rx510_cur."from"()
    inc rx510_pos
    rx510_cur."!cursor_from"(rx510_pos)
    ge rx510_pos, rx510_eos, rxscan514_done
  rxscan514_scan:
    set_addr $I10, rxscan514_loop
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  rxscan514_done:
.annotate 'line', 269
  # rx subcapture "sym"
    set_addr $I10, rxcap_515_fail
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  # rx literal  "for"
    add $I11, rx510_pos, 3
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 3
    ne $S10, "for", rx510_fail
    add rx510_pos, 3
    set_addr $I10, rxcap_515_fail
    ($I12, $I11) = rx510_cur."!mark_peek"($I10)
    rx510_cur."!cursor_pos"($I11)
    ($P10) = rx510_cur."!cursor_start"()
    $P10."!cursor_pass"(rx510_pos, "")
    rx510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_515_done
  rxcap_515_fail:
    goto rx510_fail
  rxcap_515_done:
  # rx subrule "ws" subtype=method negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."ws"()
    unless $P10, rx510_fail
    rx510_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."EXPR"()
    unless $P10, rx510_fail
    rx510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx510_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."ws"()
    unless $P10, rx510_fail
    rx510_pos = $P10."pos"()
  # rx pass
    rx510_cur."!cursor_pass"(rx510_pos, "statement_mod_loop:sym<for>")
    if_null rx510_debug, debug_797
    rx510_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx510_pos)
  debug_797:
    .return (rx510_cur)
  rx510_restart:
.annotate 'line', 10
    if_null rx510_debug, debug_798
    rx510_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_798:
  rx510_fail:
    (rx510_rep, rx510_pos, $I10, $P10) = rx510_cur."!mark_fail"(0)
    lt rx510_pos, -1, rx510_done
    eq rx510_pos, -1, rx510_fail
    jump $I10
  rx510_done:
    rx510_cur."!cursor_fail"()
    if_null rx510_debug, debug_799
    rx510_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_799:
    .return (rx510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303603603.711") :method
.annotate 'line', 10
    $P512 = self."!PREFIX__!subrule"("ws", "for")
    new $P513, "ResizablePMCArray"
    push $P513, $P512
    .return ($P513)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx519_tgt
    .local int rx519_pos
    .local int rx519_off
    .local int rx519_eos
    .local int rx519_rep
    .local pmc rx519_cur
    .local pmc rx519_debug
    (rx519_cur, rx519_pos, rx519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx519_cur
    .local pmc match
    .lex "$/", match
    length rx519_eos, rx519_tgt
    gt rx519_pos, rx519_eos, rx519_done
    set rx519_off, 0
    lt rx519_pos, 2, rx519_start
    sub rx519_off, rx519_pos, 1
    substr rx519_tgt, rx519_tgt, rx519_off
  rx519_start:
    eq $I10, 1, rx519_restart
    if_null rx519_debug, debug_800
    rx519_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan523_done
    goto rxscan523_scan
  rxscan523_loop:
    (rx519_pos) = rx519_cur."from"()
    inc rx519_pos
    rx519_cur."!cursor_from"(rx519_pos)
    ge rx519_pos, rx519_eos, rxscan523_done
  rxscan523_scan:
    set_addr $I10, rxscan523_loop
    rx519_cur."!mark_push"(0, rx519_pos, $I10)
  rxscan523_done:
.annotate 'line', 273
  # rx subrule "fatarrow" subtype=capture negate=
    rx519_cur."!cursor_pos"(rx519_pos)
    $P10 = rx519_cur."fatarrow"()
    unless $P10, rx519_fail
    rx519_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx519_pos = $P10."pos"()
  # rx pass
    rx519_cur."!cursor_pass"(rx519_pos, "term:sym<fatarrow>")
    if_null rx519_debug, debug_801
    rx519_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx519_pos)
  debug_801:
    .return (rx519_cur)
  rx519_restart:
.annotate 'line', 10
    if_null rx519_debug, debug_802
    rx519_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_802:
  rx519_fail:
    (rx519_rep, rx519_pos, $I10, $P10) = rx519_cur."!mark_fail"(0)
    lt rx519_pos, -1, rx519_done
    eq rx519_pos, -1, rx519_fail
    jump $I10
  rx519_done:
    rx519_cur."!cursor_fail"()
    if_null rx519_debug, debug_803
    rx519_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_803:
    .return (rx519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303603603.711") :method
.annotate 'line', 10
    $P521 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P522, "ResizablePMCArray"
    push $P522, $P521
    .return ($P522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx525_tgt
    .local int rx525_pos
    .local int rx525_off
    .local int rx525_eos
    .local int rx525_rep
    .local pmc rx525_cur
    .local pmc rx525_debug
    (rx525_cur, rx525_pos, rx525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx525_cur
    .local pmc match
    .lex "$/", match
    length rx525_eos, rx525_tgt
    gt rx525_pos, rx525_eos, rx525_done
    set rx525_off, 0
    lt rx525_pos, 2, rx525_start
    sub rx525_off, rx525_pos, 1
    substr rx525_tgt, rx525_tgt, rx525_off
  rx525_start:
    eq $I10, 1, rx525_restart
    if_null rx525_debug, debug_804
    rx525_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx525_pos) = rx525_cur."from"()
    inc rx525_pos
    rx525_cur."!cursor_from"(rx525_pos)
    ge rx525_pos, rx525_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx525_cur."!mark_push"(0, rx525_pos, $I10)
  rxscan529_done:
.annotate 'line', 274
  # rx subrule "colonpair" subtype=capture negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."colonpair"()
    unless $P10, rx525_fail
    rx525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx525_pos = $P10."pos"()
  # rx pass
    rx525_cur."!cursor_pass"(rx525_pos, "term:sym<colonpair>")
    if_null rx525_debug, debug_805
    rx525_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx525_pos)
  debug_805:
    .return (rx525_cur)
  rx525_restart:
.annotate 'line', 10
    if_null rx525_debug, debug_806
    rx525_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_806:
  rx525_fail:
    (rx525_rep, rx525_pos, $I10, $P10) = rx525_cur."!mark_fail"(0)
    lt rx525_pos, -1, rx525_done
    eq rx525_pos, -1, rx525_fail
    jump $I10
  rx525_done:
    rx525_cur."!cursor_fail"()
    if_null rx525_debug, debug_807
    rx525_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_807:
    .return (rx525_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303603603.711") :method
.annotate 'line', 10
    $P527 = self."!PREFIX__!subrule"("colonpair", "")
    new $P528, "ResizablePMCArray"
    push $P528, $P527
    .return ($P528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx531_tgt
    .local int rx531_pos
    .local int rx531_off
    .local int rx531_eos
    .local int rx531_rep
    .local pmc rx531_cur
    .local pmc rx531_debug
    (rx531_cur, rx531_pos, rx531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx531_cur
    .local pmc match
    .lex "$/", match
    length rx531_eos, rx531_tgt
    gt rx531_pos, rx531_eos, rx531_done
    set rx531_off, 0
    lt rx531_pos, 2, rx531_start
    sub rx531_off, rx531_pos, 1
    substr rx531_tgt, rx531_tgt, rx531_off
  rx531_start:
    eq $I10, 1, rx531_restart
    if_null rx531_debug, debug_808
    rx531_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan535_done
    goto rxscan535_scan
  rxscan535_loop:
    (rx531_pos) = rx531_cur."from"()
    inc rx531_pos
    rx531_cur."!cursor_from"(rx531_pos)
    ge rx531_pos, rx531_eos, rxscan535_done
  rxscan535_scan:
    set_addr $I10, rxscan535_loop
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  rxscan535_done:
.annotate 'line', 275
  # rx subrule "variable" subtype=capture negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."variable"()
    unless $P10, rx531_fail
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx531_pos = $P10."pos"()
  # rx pass
    rx531_cur."!cursor_pass"(rx531_pos, "term:sym<variable>")
    if_null rx531_debug, debug_809
    rx531_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx531_pos)
  debug_809:
    .return (rx531_cur)
  rx531_restart:
.annotate 'line', 10
    if_null rx531_debug, debug_810
    rx531_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_810:
  rx531_fail:
    (rx531_rep, rx531_pos, $I10, $P10) = rx531_cur."!mark_fail"(0)
    lt rx531_pos, -1, rx531_done
    eq rx531_pos, -1, rx531_fail
    jump $I10
  rx531_done:
    rx531_cur."!cursor_fail"()
    if_null rx531_debug, debug_811
    rx531_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_811:
    .return (rx531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303603603.711") :method
.annotate 'line', 10
    $P533 = self."!PREFIX__!subrule"("variable", "")
    new $P534, "ResizablePMCArray"
    push $P534, $P533
    .return ($P534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx537_tgt
    .local int rx537_pos
    .local int rx537_off
    .local int rx537_eos
    .local int rx537_rep
    .local pmc rx537_cur
    .local pmc rx537_debug
    (rx537_cur, rx537_pos, rx537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx537_cur
    .local pmc match
    .lex "$/", match
    length rx537_eos, rx537_tgt
    gt rx537_pos, rx537_eos, rx537_done
    set rx537_off, 0
    lt rx537_pos, 2, rx537_start
    sub rx537_off, rx537_pos, 1
    substr rx537_tgt, rx537_tgt, rx537_off
  rx537_start:
    eq $I10, 1, rx537_restart
    if_null rx537_debug, debug_812
    rx537_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan541_done
    goto rxscan541_scan
  rxscan541_loop:
    (rx537_pos) = rx537_cur."from"()
    inc rx537_pos
    rx537_cur."!cursor_from"(rx537_pos)
    ge rx537_pos, rx537_eos, rxscan541_done
  rxscan541_scan:
    set_addr $I10, rxscan541_loop
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  rxscan541_done:
.annotate 'line', 276
  # rx subrule "package_declarator" subtype=capture negate=
    rx537_cur."!cursor_pos"(rx537_pos)
    $P10 = rx537_cur."package_declarator"()
    unless $P10, rx537_fail
    rx537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx537_pos = $P10."pos"()
  # rx pass
    rx537_cur."!cursor_pass"(rx537_pos, "term:sym<package_declarator>")
    if_null rx537_debug, debug_813
    rx537_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx537_pos)
  debug_813:
    .return (rx537_cur)
  rx537_restart:
.annotate 'line', 10
    if_null rx537_debug, debug_814
    rx537_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_814:
  rx537_fail:
    (rx537_rep, rx537_pos, $I10, $P10) = rx537_cur."!mark_fail"(0)
    lt rx537_pos, -1, rx537_done
    eq rx537_pos, -1, rx537_fail
    jump $I10
  rx537_done:
    rx537_cur."!cursor_fail"()
    if_null rx537_debug, debug_815
    rx537_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_815:
    .return (rx537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303603603.711") :method
.annotate 'line', 10
    $P539 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P540, "ResizablePMCArray"
    push $P540, $P539
    .return ($P540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx543_tgt
    .local int rx543_pos
    .local int rx543_off
    .local int rx543_eos
    .local int rx543_rep
    .local pmc rx543_cur
    .local pmc rx543_debug
    (rx543_cur, rx543_pos, rx543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx543_cur
    .local pmc match
    .lex "$/", match
    length rx543_eos, rx543_tgt
    gt rx543_pos, rx543_eos, rx543_done
    set rx543_off, 0
    lt rx543_pos, 2, rx543_start
    sub rx543_off, rx543_pos, 1
    substr rx543_tgt, rx543_tgt, rx543_off
  rx543_start:
    eq $I10, 1, rx543_restart
    if_null rx543_debug, debug_816
    rx543_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan547_done
    goto rxscan547_scan
  rxscan547_loop:
    (rx543_pos) = rx543_cur."from"()
    inc rx543_pos
    rx543_cur."!cursor_from"(rx543_pos)
    ge rx543_pos, rx543_eos, rxscan547_done
  rxscan547_scan:
    set_addr $I10, rxscan547_loop
    rx543_cur."!mark_push"(0, rx543_pos, $I10)
  rxscan547_done:
.annotate 'line', 277
  # rx subrule "scope_declarator" subtype=capture negate=
    rx543_cur."!cursor_pos"(rx543_pos)
    $P10 = rx543_cur."scope_declarator"()
    unless $P10, rx543_fail
    rx543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx543_pos = $P10."pos"()
  # rx pass
    rx543_cur."!cursor_pass"(rx543_pos, "term:sym<scope_declarator>")
    if_null rx543_debug, debug_817
    rx543_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx543_pos)
  debug_817:
    .return (rx543_cur)
  rx543_restart:
.annotate 'line', 10
    if_null rx543_debug, debug_818
    rx543_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_818:
  rx543_fail:
    (rx543_rep, rx543_pos, $I10, $P10) = rx543_cur."!mark_fail"(0)
    lt rx543_pos, -1, rx543_done
    eq rx543_pos, -1, rx543_fail
    jump $I10
  rx543_done:
    rx543_cur."!cursor_fail"()
    if_null rx543_debug, debug_819
    rx543_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_819:
    .return (rx543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303603603.711") :method
.annotate 'line', 10
    $P545 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P546, "ResizablePMCArray"
    push $P546, $P545
    .return ($P546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx549_tgt
    .local int rx549_pos
    .local int rx549_off
    .local int rx549_eos
    .local int rx549_rep
    .local pmc rx549_cur
    .local pmc rx549_debug
    (rx549_cur, rx549_pos, rx549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx549_cur
    .local pmc match
    .lex "$/", match
    length rx549_eos, rx549_tgt
    gt rx549_pos, rx549_eos, rx549_done
    set rx549_off, 0
    lt rx549_pos, 2, rx549_start
    sub rx549_off, rx549_pos, 1
    substr rx549_tgt, rx549_tgt, rx549_off
  rx549_start:
    eq $I10, 1, rx549_restart
    if_null rx549_debug, debug_820
    rx549_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan553_done
    goto rxscan553_scan
  rxscan553_loop:
    (rx549_pos) = rx549_cur."from"()
    inc rx549_pos
    rx549_cur."!cursor_from"(rx549_pos)
    ge rx549_pos, rx549_eos, rxscan553_done
  rxscan553_scan:
    set_addr $I10, rxscan553_loop
    rx549_cur."!mark_push"(0, rx549_pos, $I10)
  rxscan553_done:
.annotate 'line', 278
  # rx subrule "routine_declarator" subtype=capture negate=
    rx549_cur."!cursor_pos"(rx549_pos)
    $P10 = rx549_cur."routine_declarator"()
    unless $P10, rx549_fail
    rx549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx549_pos = $P10."pos"()
  # rx pass
    rx549_cur."!cursor_pass"(rx549_pos, "term:sym<routine_declarator>")
    if_null rx549_debug, debug_821
    rx549_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx549_pos)
  debug_821:
    .return (rx549_cur)
  rx549_restart:
.annotate 'line', 10
    if_null rx549_debug, debug_822
    rx549_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_822:
  rx549_fail:
    (rx549_rep, rx549_pos, $I10, $P10) = rx549_cur."!mark_fail"(0)
    lt rx549_pos, -1, rx549_done
    eq rx549_pos, -1, rx549_fail
    jump $I10
  rx549_done:
    rx549_cur."!cursor_fail"()
    if_null rx549_debug, debug_823
    rx549_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_823:
    .return (rx549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303603603.711") :method
.annotate 'line', 10
    $P551 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P552, "ResizablePMCArray"
    push $P552, $P551
    .return ($P552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P565 = "121_1303603603.711" 
    capture_lex $P565
    .const 'Sub' $P560 = "120_1303603603.711" 
    capture_lex $P560
    .local string rx555_tgt
    .local int rx555_pos
    .local int rx555_off
    .local int rx555_eos
    .local int rx555_rep
    .local pmc rx555_cur
    .local pmc rx555_debug
    (rx555_cur, rx555_pos, rx555_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx555_cur
    .local pmc match
    .lex "$/", match
    length rx555_eos, rx555_tgt
    gt rx555_pos, rx555_eos, rx555_done
    set rx555_off, 0
    lt rx555_pos, 2, rx555_start
    sub rx555_off, rx555_pos, 1
    substr rx555_tgt, rx555_tgt, rx555_off
  rx555_start:
    eq $I10, 1, rx555_restart
    if_null rx555_debug, debug_824
    rx555_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan558_done
    goto rxscan558_scan
  rxscan558_loop:
    (rx555_pos) = rx555_cur."from"()
    inc rx555_pos
    rx555_cur."!cursor_from"(rx555_pos)
    ge rx555_pos, rx555_eos, rxscan558_done
  rxscan558_scan:
    set_addr $I10, rxscan558_loop
    rx555_cur."!mark_push"(0, rx555_pos, $I10)
  rxscan558_done:
.annotate 'line', 280
  # rx subrule "before" subtype=zerowidth negate=
    rx555_cur."!cursor_pos"(rx555_pos)
    .const 'Sub' $P560 = "120_1303603603.711" 
    capture_lex $P560
    $P10 = rx555_cur."before"($P560)
    unless $P10, rx555_fail
.annotate 'line', 281
  # rx subrule "before" subtype=zerowidth negate=1
    rx555_cur."!cursor_pos"(rx555_pos)
    .const 'Sub' $P565 = "121_1303603603.711" 
    capture_lex $P565
    $P10 = rx555_cur."before"($P565)
    if $P10, rx555_fail
.annotate 'line', 282
  # rx subrule "multi_declarator" subtype=capture negate=
    rx555_cur."!cursor_pos"(rx555_pos)
    $P10 = rx555_cur."multi_declarator"()
    unless $P10, rx555_fail
    rx555_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx555_pos = $P10."pos"()
.annotate 'line', 279
  # rx pass
    rx555_cur."!cursor_pass"(rx555_pos, "term:sym<multi_declarator>")
    if_null rx555_debug, debug_833
    rx555_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx555_pos)
  debug_833:
    .return (rx555_cur)
  rx555_restart:
.annotate 'line', 10
    if_null rx555_debug, debug_834
    rx555_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_834:
  rx555_fail:
    (rx555_rep, rx555_pos, $I10, $P10) = rx555_cur."!mark_fail"(0)
    lt rx555_pos, -1, rx555_done
    eq rx555_pos, -1, rx555_fail
    jump $I10
  rx555_done:
    rx555_cur."!cursor_fail"()
    if_null rx555_debug, debug_835
    rx555_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_835:
    .return (rx555_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303603603.711") :method
.annotate 'line', 10
    new $P557, "ResizablePMCArray"
    push $P557, ""
    .return ($P557)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block559"  :anon :subid("120_1303603603.711") :method :outer("118_1303603603.711")
.annotate 'line', 280
    .local string rx561_tgt
    .local int rx561_pos
    .local int rx561_off
    .local int rx561_eos
    .local int rx561_rep
    .local pmc rx561_cur
    .local pmc rx561_debug
    (rx561_cur, rx561_pos, rx561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx561_cur
    .local pmc match
    .lex "$/", match
    length rx561_eos, rx561_tgt
    gt rx561_pos, rx561_eos, rx561_done
    set rx561_off, 0
    lt rx561_pos, 2, rx561_start
    sub rx561_off, rx561_pos, 1
    substr rx561_tgt, rx561_tgt, rx561_off
  rx561_start:
    eq $I10, 1, rx561_restart
    if_null rx561_debug, debug_825
    rx561_cur."!cursor_debug"("START", "")
  debug_825:
    $I10 = self.'from'()
    ne $I10, -1, rxscan562_done
    goto rxscan562_scan
  rxscan562_loop:
    (rx561_pos) = rx561_cur."from"()
    inc rx561_pos
    rx561_cur."!cursor_from"(rx561_pos)
    ge rx561_pos, rx561_eos, rxscan562_done
  rxscan562_scan:
    set_addr $I10, rxscan562_loop
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  rxscan562_done:
  alt563_0:
    set_addr $I10, alt563_1
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  # rx literal  "multi"
    add $I11, rx561_pos, 5
    gt $I11, rx561_eos, rx561_fail
    sub $I11, rx561_pos, rx561_off
    substr $S10, rx561_tgt, $I11, 5
    ne $S10, "multi", rx561_fail
    add rx561_pos, 5
    goto alt563_end
  alt563_1:
    set_addr $I10, alt563_2
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  # rx literal  "proto"
    add $I11, rx561_pos, 5
    gt $I11, rx561_eos, rx561_fail
    sub $I11, rx561_pos, rx561_off
    substr $S10, rx561_tgt, $I11, 5
    ne $S10, "proto", rx561_fail
    add rx561_pos, 5
    goto alt563_end
  alt563_2:
  # rx literal  "only"
    add $I11, rx561_pos, 4
    gt $I11, rx561_eos, rx561_fail
    sub $I11, rx561_pos, rx561_off
    substr $S10, rx561_tgt, $I11, 4
    ne $S10, "only", rx561_fail
    add rx561_pos, 4
  alt563_end:
  # rx pass
    rx561_cur."!cursor_pass"(rx561_pos, "")
    if_null rx561_debug, debug_826
    rx561_cur."!cursor_debug"("PASS", "", " at pos=", rx561_pos)
  debug_826:
    .return (rx561_cur)
  rx561_restart:
    if_null rx561_debug, debug_827
    rx561_cur."!cursor_debug"("NEXT", "")
  debug_827:
  rx561_fail:
    (rx561_rep, rx561_pos, $I10, $P10) = rx561_cur."!mark_fail"(0)
    lt rx561_pos, -1, rx561_done
    eq rx561_pos, -1, rx561_fail
    jump $I10
  rx561_done:
    rx561_cur."!cursor_fail"()
    if_null rx561_debug, debug_828
    rx561_cur."!cursor_debug"("FAIL", "")
  debug_828:
    .return (rx561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block564"  :anon :subid("121_1303603603.711") :method :outer("118_1303603603.711")
.annotate 'line', 281
    .local string rx566_tgt
    .local int rx566_pos
    .local int rx566_off
    .local int rx566_eos
    .local int rx566_rep
    .local pmc rx566_cur
    .local pmc rx566_debug
    (rx566_cur, rx566_pos, rx566_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx566_cur
    .local pmc match
    .lex "$/", match
    length rx566_eos, rx566_tgt
    gt rx566_pos, rx566_eos, rx566_done
    set rx566_off, 0
    lt rx566_pos, 2, rx566_start
    sub rx566_off, rx566_pos, 1
    substr rx566_tgt, rx566_tgt, rx566_off
  rx566_start:
    eq $I10, 1, rx566_restart
    if_null rx566_debug, debug_829
    rx566_cur."!cursor_debug"("START", "")
  debug_829:
    $I10 = self.'from'()
    ne $I10, -1, rxscan567_done
    goto rxscan567_scan
  rxscan567_loop:
    (rx566_pos) = rx566_cur."from"()
    inc rx566_pos
    rx566_cur."!cursor_from"(rx566_pos)
    ge rx566_pos, rx566_eos, rxscan567_done
  rxscan567_scan:
    set_addr $I10, rxscan567_loop
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  rxscan567_done:
  # rx literal  "proto"
    add $I11, rx566_pos, 5
    gt $I11, rx566_eos, rx566_fail
    sub $I11, rx566_pos, rx566_off
    substr $S10, rx566_tgt, $I11, 5
    ne $S10, "proto", rx566_fail
    add rx566_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx566_cur."!cursor_pos"(rx566_pos)
    $P10 = rx566_cur."ws"()
    unless $P10, rx566_fail
    rx566_pos = $P10."pos"()
  alt568_0:
    set_addr $I10, alt568_1
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  # rx literal  "regex"
    add $I11, rx566_pos, 5
    gt $I11, rx566_eos, rx566_fail
    sub $I11, rx566_pos, rx566_off
    substr $S10, rx566_tgt, $I11, 5
    ne $S10, "regex", rx566_fail
    add rx566_pos, 5
    goto alt568_end
  alt568_1:
    set_addr $I10, alt568_2
    rx566_cur."!mark_push"(0, rx566_pos, $I10)
  # rx literal  "token"
    add $I11, rx566_pos, 5
    gt $I11, rx566_eos, rx566_fail
    sub $I11, rx566_pos, rx566_off
    substr $S10, rx566_tgt, $I11, 5
    ne $S10, "token", rx566_fail
    add rx566_pos, 5
    goto alt568_end
  alt568_2:
  # rx literal  "rule"
    add $I11, rx566_pos, 4
    gt $I11, rx566_eos, rx566_fail
    sub $I11, rx566_pos, rx566_off
    substr $S10, rx566_tgt, $I11, 4
    ne $S10, "rule", rx566_fail
    add rx566_pos, 4
  alt568_end:
  # rx pass
    rx566_cur."!cursor_pass"(rx566_pos, "")
    if_null rx566_debug, debug_830
    rx566_cur."!cursor_debug"("PASS", "", " at pos=", rx566_pos)
  debug_830:
    .return (rx566_cur)
  rx566_restart:
    if_null rx566_debug, debug_831
    rx566_cur."!cursor_debug"("NEXT", "")
  debug_831:
  rx566_fail:
    (rx566_rep, rx566_pos, $I10, $P10) = rx566_cur."!mark_fail"(0)
    lt rx566_pos, -1, rx566_done
    eq rx566_pos, -1, rx566_fail
    jump $I10
  rx566_done:
    rx566_cur."!cursor_fail"()
    if_null rx566_debug, debug_832
    rx566_cur."!cursor_debug"("FAIL", "")
  debug_832:
    .return (rx566_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx570_tgt
    .local int rx570_pos
    .local int rx570_off
    .local int rx570_eos
    .local int rx570_rep
    .local pmc rx570_cur
    .local pmc rx570_debug
    (rx570_cur, rx570_pos, rx570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx570_cur
    .local pmc match
    .lex "$/", match
    length rx570_eos, rx570_tgt
    gt rx570_pos, rx570_eos, rx570_done
    set rx570_off, 0
    lt rx570_pos, 2, rx570_start
    sub rx570_off, rx570_pos, 1
    substr rx570_tgt, rx570_tgt, rx570_off
  rx570_start:
    eq $I10, 1, rx570_restart
    if_null rx570_debug, debug_836
    rx570_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan574_done
    goto rxscan574_scan
  rxscan574_loop:
    (rx570_pos) = rx570_cur."from"()
    inc rx570_pos
    rx570_cur."!cursor_from"(rx570_pos)
    ge rx570_pos, rx570_eos, rxscan574_done
  rxscan574_scan:
    set_addr $I10, rxscan574_loop
    rx570_cur."!mark_push"(0, rx570_pos, $I10)
  rxscan574_done:
.annotate 'line', 284
  # rx subrule "regex_declarator" subtype=capture negate=
    rx570_cur."!cursor_pos"(rx570_pos)
    $P10 = rx570_cur."regex_declarator"()
    unless $P10, rx570_fail
    rx570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx570_pos = $P10."pos"()
  # rx pass
    rx570_cur."!cursor_pass"(rx570_pos, "term:sym<regex_declarator>")
    if_null rx570_debug, debug_837
    rx570_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx570_pos)
  debug_837:
    .return (rx570_cur)
  rx570_restart:
.annotate 'line', 10
    if_null rx570_debug, debug_838
    rx570_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_838:
  rx570_fail:
    (rx570_rep, rx570_pos, $I10, $P10) = rx570_cur."!mark_fail"(0)
    lt rx570_pos, -1, rx570_done
    eq rx570_pos, -1, rx570_fail
    jump $I10
  rx570_done:
    rx570_cur."!cursor_fail"()
    if_null rx570_debug, debug_839
    rx570_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_839:
    .return (rx570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303603603.711") :method
.annotate 'line', 10
    $P572 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P573, "ResizablePMCArray"
    push $P573, $P572
    .return ($P573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx576_tgt
    .local int rx576_pos
    .local int rx576_off
    .local int rx576_eos
    .local int rx576_rep
    .local pmc rx576_cur
    .local pmc rx576_debug
    (rx576_cur, rx576_pos, rx576_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx576_cur
    .local pmc match
    .lex "$/", match
    length rx576_eos, rx576_tgt
    gt rx576_pos, rx576_eos, rx576_done
    set rx576_off, 0
    lt rx576_pos, 2, rx576_start
    sub rx576_off, rx576_pos, 1
    substr rx576_tgt, rx576_tgt, rx576_off
  rx576_start:
    eq $I10, 1, rx576_restart
    if_null rx576_debug, debug_840
    rx576_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan580_done
    goto rxscan580_scan
  rxscan580_loop:
    (rx576_pos) = rx576_cur."from"()
    inc rx576_pos
    rx576_cur."!cursor_from"(rx576_pos)
    ge rx576_pos, rx576_eos, rxscan580_done
  rxscan580_scan:
    set_addr $I10, rxscan580_loop
    rx576_cur."!mark_push"(0, rx576_pos, $I10)
  rxscan580_done:
.annotate 'line', 285
  # rx subrule "statement_prefix" subtype=capture negate=
    rx576_cur."!cursor_pos"(rx576_pos)
    $P10 = rx576_cur."statement_prefix"()
    unless $P10, rx576_fail
    rx576_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx576_pos = $P10."pos"()
  # rx pass
    rx576_cur."!cursor_pass"(rx576_pos, "term:sym<statement_prefix>")
    if_null rx576_debug, debug_841
    rx576_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx576_pos)
  debug_841:
    .return (rx576_cur)
  rx576_restart:
.annotate 'line', 10
    if_null rx576_debug, debug_842
    rx576_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_842:
  rx576_fail:
    (rx576_rep, rx576_pos, $I10, $P10) = rx576_cur."!mark_fail"(0)
    lt rx576_pos, -1, rx576_done
    eq rx576_pos, -1, rx576_fail
    jump $I10
  rx576_done:
    rx576_cur."!cursor_fail"()
    if_null rx576_debug, debug_843
    rx576_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_843:
    .return (rx576_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303603603.711") :method
.annotate 'line', 10
    $P578 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P579, "ResizablePMCArray"
    push $P579, $P578
    .return ($P579)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx582_tgt
    .local int rx582_pos
    .local int rx582_off
    .local int rx582_eos
    .local int rx582_rep
    .local pmc rx582_cur
    .local pmc rx582_debug
    (rx582_cur, rx582_pos, rx582_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx582_cur
    .local pmc match
    .lex "$/", match
    length rx582_eos, rx582_tgt
    gt rx582_pos, rx582_eos, rx582_done
    set rx582_off, 0
    lt rx582_pos, 2, rx582_start
    sub rx582_off, rx582_pos, 1
    substr rx582_tgt, rx582_tgt, rx582_off
  rx582_start:
    eq $I10, 1, rx582_restart
    if_null rx582_debug, debug_844
    rx582_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan585_done
    goto rxscan585_scan
  rxscan585_loop:
    (rx582_pos) = rx582_cur."from"()
    inc rx582_pos
    rx582_cur."!cursor_from"(rx582_pos)
    ge rx582_pos, rx582_eos, rxscan585_done
  rxscan585_scan:
    set_addr $I10, rxscan585_loop
    rx582_cur."!mark_push"(0, rx582_pos, $I10)
  rxscan585_done:
.annotate 'line', 286
  # rx subrule "lambda" subtype=zerowidth negate=
    rx582_cur."!cursor_pos"(rx582_pos)
    $P10 = rx582_cur."lambda"()
    unless $P10, rx582_fail
  # rx subrule "pblock" subtype=capture negate=
    rx582_cur."!cursor_pos"(rx582_pos)
    $P10 = rx582_cur."pblock"()
    unless $P10, rx582_fail
    rx582_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx582_pos = $P10."pos"()
  # rx pass
    rx582_cur."!cursor_pass"(rx582_pos, "term:sym<lambda>")
    if_null rx582_debug, debug_845
    rx582_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx582_pos)
  debug_845:
    .return (rx582_cur)
  rx582_restart:
.annotate 'line', 10
    if_null rx582_debug, debug_846
    rx582_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_846:
  rx582_fail:
    (rx582_rep, rx582_pos, $I10, $P10) = rx582_cur."!mark_fail"(0)
    lt rx582_pos, -1, rx582_done
    eq rx582_pos, -1, rx582_fail
    jump $I10
  rx582_done:
    rx582_cur."!cursor_fail"()
    if_null rx582_debug, debug_847
    rx582_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_847:
    .return (rx582_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303603603.711") :method
.annotate 'line', 10
    new $P584, "ResizablePMCArray"
    push $P584, ""
    .return ($P584)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx587_tgt
    .local int rx587_pos
    .local int rx587_off
    .local int rx587_eos
    .local int rx587_rep
    .local pmc rx587_cur
    .local pmc rx587_debug
    (rx587_cur, rx587_pos, rx587_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx587_cur
    .local pmc match
    .lex "$/", match
    length rx587_eos, rx587_tgt
    gt rx587_pos, rx587_eos, rx587_done
    set rx587_off, 0
    lt rx587_pos, 2, rx587_start
    sub rx587_off, rx587_pos, 1
    substr rx587_tgt, rx587_tgt, rx587_off
  rx587_start:
    eq $I10, 1, rx587_restart
    if_null rx587_debug, debug_848
    rx587_cur."!cursor_debug"("START", "fatarrow")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    (rx587_pos) = rx587_cur."from"()
    inc rx587_pos
    rx587_cur."!cursor_from"(rx587_pos)
    ge rx587_pos, rx587_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx587_cur."!mark_push"(0, rx587_pos, $I10)
  rxscan591_done:
.annotate 'line', 289
  # rx subrule "identifier" subtype=capture negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."identifier"()
    unless $P10, rx587_fail
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx587_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx587_pos, rx587_off
    set rx587_rep, 0
    sub $I12, rx587_eos, rx587_pos
  rxenumcharlistq592_loop:
    le $I12, 0, rxenumcharlistq592_done
    substr $S10, rx587_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq592_done
    inc rx587_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq592_loop
  rxenumcharlistq592_done:
    add rx587_pos, rx587_pos, rx587_rep
  # rx literal  "=>"
    add $I11, rx587_pos, 2
    gt $I11, rx587_eos, rx587_fail
    sub $I11, rx587_pos, rx587_off
    substr $S10, rx587_tgt, $I11, 2
    ne $S10, "=>", rx587_fail
    add rx587_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."ws"()
    unless $P10, rx587_fail
    rx587_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx587_cur."!cursor_pos"(rx587_pos)
    $P10 = rx587_cur."EXPR"("i=")
    unless $P10, rx587_fail
    rx587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx587_pos = $P10."pos"()
.annotate 'line', 288
  # rx pass
    rx587_cur."!cursor_pass"(rx587_pos, "fatarrow")
    if_null rx587_debug, debug_849
    rx587_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx587_pos)
  debug_849:
    .return (rx587_cur)
  rx587_restart:
.annotate 'line', 10
    if_null rx587_debug, debug_850
    rx587_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_850:
  rx587_fail:
    (rx587_rep, rx587_pos, $I10, $P10) = rx587_cur."!mark_fail"(0)
    lt rx587_pos, -1, rx587_done
    eq rx587_pos, -1, rx587_fail
    jump $I10
  rx587_done:
    rx587_cur."!cursor_fail"()
    if_null rx587_debug, debug_851
    rx587_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_851:
    .return (rx587_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303603603.711") :method
.annotate 'line', 10
    $P589 = self."!PREFIX__!subrule"("identifier", "")
    new $P590, "ResizablePMCArray"
    push $P590, $P589
    .return ($P590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx594_tgt
    .local int rx594_pos
    .local int rx594_off
    .local int rx594_eos
    .local int rx594_rep
    .local pmc rx594_cur
    .local pmc rx594_debug
    (rx594_cur, rx594_pos, rx594_tgt, $I10) = self."!cursor_start"()
    rx594_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx594_cur
    .local pmc match
    .lex "$/", match
    length rx594_eos, rx594_tgt
    gt rx594_pos, rx594_eos, rx594_done
    set rx594_off, 0
    lt rx594_pos, 2, rx594_start
    sub rx594_off, rx594_pos, 1
    substr rx594_tgt, rx594_tgt, rx594_off
  rx594_start:
    eq $I10, 1, rx594_restart
    if_null rx594_debug, debug_852
    rx594_cur."!cursor_debug"("START", "colonpair")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan600_done
    goto rxscan600_scan
  rxscan600_loop:
    (rx594_pos) = rx594_cur."from"()
    inc rx594_pos
    rx594_cur."!cursor_from"(rx594_pos)
    ge rx594_pos, rx594_eos, rxscan600_done
  rxscan600_scan:
    set_addr $I10, rxscan600_loop
    rx594_cur."!mark_push"(0, rx594_pos, $I10)
  rxscan600_done:
.annotate 'line', 293
  # rx literal  ":"
    add $I11, rx594_pos, 1
    gt $I11, rx594_eos, rx594_fail
    sub $I11, rx594_pos, rx594_off
    ord $I11, rx594_tgt, $I11
    ne $I11, 58, rx594_fail
    add rx594_pos, 1
  alt601_0:
.annotate 'line', 294
    set_addr $I10, alt601_1
    rx594_cur."!mark_push"(0, rx594_pos, $I10)
.annotate 'line', 295
  # rx subcapture "not"
    set_addr $I10, rxcap_602_fail
    rx594_cur."!mark_push"(0, rx594_pos, $I10)
  # rx literal  "!"
    add $I11, rx594_pos, 1
    gt $I11, rx594_eos, rx594_fail
    sub $I11, rx594_pos, rx594_off
    ord $I11, rx594_tgt, $I11
    ne $I11, 33, rx594_fail
    add rx594_pos, 1
    set_addr $I10, rxcap_602_fail
    ($I12, $I11) = rx594_cur."!mark_peek"($I10)
    rx594_cur."!cursor_pos"($I11)
    ($P10) = rx594_cur."!cursor_start"()
    $P10."!cursor_pass"(rx594_pos, "")
    rx594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_602_done
  rxcap_602_fail:
    goto rx594_fail
  rxcap_602_done:
  # rx subrule "identifier" subtype=capture negate=
    rx594_cur."!cursor_pos"(rx594_pos)
    $P10 = rx594_cur."identifier"()
    unless $P10, rx594_fail
    rx594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx594_pos = $P10."pos"()
    goto alt601_end
  alt601_1:
    set_addr $I10, alt601_2
    rx594_cur."!mark_push"(0, rx594_pos, $I10)
.annotate 'line', 296
  # rx subrule "identifier" subtype=capture negate=
    rx594_cur."!cursor_pos"(rx594_pos)
    $P10 = rx594_cur."identifier"()
    unless $P10, rx594_fail
    rx594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx594_pos = $P10."pos"()
  # rx rxquantr603 ** 0..1
    set_addr $I10, rxquantr603_done
    rx594_cur."!mark_push"(0, rx594_pos, $I10)
  rxquantr603_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx594_cur."!cursor_pos"(rx594_pos)
    $P10 = rx594_cur."circumfix"()
    unless $P10, rx594_fail
    goto rxsubrule604_pass
  rxsubrule604_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx594_fail
  rxsubrule604_pass:
    set_addr $I10, rxsubrule604_back
    rx594_cur."!mark_push"(0, rx594_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx594_pos = $P10."pos"()
    set_addr $I10, rxquantr603_done
    (rx594_rep) = rx594_cur."!mark_commit"($I10)
  rxquantr603_done:
    goto alt601_end
  alt601_2:
.annotate 'line', 297
  # rx subrule "circumfix" subtype=capture negate=
    rx594_cur."!cursor_pos"(rx594_pos)
    $P10 = rx594_cur."circumfix"()
    unless $P10, rx594_fail
    rx594_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx594_pos = $P10."pos"()
  alt601_end:
.annotate 'line', 292
  # rx pass
    rx594_cur."!cursor_pass"(rx594_pos, "colonpair")
    if_null rx594_debug, debug_853
    rx594_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx594_pos)
  debug_853:
    .return (rx594_cur)
  rx594_restart:
.annotate 'line', 10
    if_null rx594_debug, debug_854
    rx594_cur."!cursor_debug"("NEXT", "colonpair")
  debug_854:
  rx594_fail:
    (rx594_rep, rx594_pos, $I10, $P10) = rx594_cur."!mark_fail"(0)
    lt rx594_pos, -1, rx594_done
    eq rx594_pos, -1, rx594_fail
    jump $I10
  rx594_done:
    rx594_cur."!cursor_fail"()
    if_null rx594_debug, debug_855
    rx594_cur."!cursor_debug"("FAIL", "colonpair")
  debug_855:
    .return (rx594_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303603603.711") :method
.annotate 'line', 10
    $P596 = self."!PREFIX__!subrule"("circumfix", ":")
    $P597 = self."!PREFIX__!subrule"("identifier", ":")
    $P598 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P599, "ResizablePMCArray"
    push $P599, $P596
    push $P599, $P597
    push $P599, $P598
    .return ($P599)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx606_tgt
    .local int rx606_pos
    .local int rx606_off
    .local int rx606_eos
    .local int rx606_rep
    .local pmc rx606_cur
    .local pmc rx606_debug
    (rx606_cur, rx606_pos, rx606_tgt, $I10) = self."!cursor_start"()
    rx606_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx606_cur
    .local pmc match
    .lex "$/", match
    length rx606_eos, rx606_tgt
    gt rx606_pos, rx606_eos, rx606_done
    set rx606_off, 0
    lt rx606_pos, 2, rx606_start
    sub rx606_off, rx606_pos, 1
    substr rx606_tgt, rx606_tgt, rx606_off
  rx606_start:
    eq $I10, 1, rx606_restart
    if_null rx606_debug, debug_856
    rx606_cur."!cursor_debug"("START", "variable")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan611_done
    goto rxscan611_scan
  rxscan611_loop:
    (rx606_pos) = rx606_cur."from"()
    inc rx606_pos
    rx606_cur."!cursor_from"(rx606_pos)
    ge rx606_pos, rx606_eos, rxscan611_done
  rxscan611_scan:
    set_addr $I10, rxscan611_loop
    rx606_cur."!mark_push"(0, rx606_pos, $I10)
  rxscan611_done:
  alt612_0:
.annotate 'line', 301
    set_addr $I10, alt612_1
    rx606_cur."!mark_push"(0, rx606_pos, $I10)
.annotate 'line', 302
  # rx subrule "sigil" subtype=capture negate=
    rx606_cur."!cursor_pos"(rx606_pos)
    $P10 = rx606_cur."sigil"()
    unless $P10, rx606_fail
    rx606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx606_pos = $P10."pos"()
  # rx rxquantr613 ** 0..1
    set_addr $I10, rxquantr613_done
    rx606_cur."!mark_push"(0, rx606_pos, $I10)
  rxquantr613_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx606_cur."!cursor_pos"(rx606_pos)
    $P10 = rx606_cur."twigil"()
    unless $P10, rx606_fail
    goto rxsubrule614_pass
  rxsubrule614_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx606_fail
  rxsubrule614_pass:
    set_addr $I10, rxsubrule614_back
    rx606_cur."!mark_push"(0, rx606_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx606_pos = $P10."pos"()
    set_addr $I10, rxquantr613_done
    (rx606_rep) = rx606_cur."!mark_commit"($I10)
  rxquantr613_done:
  # rx subrule "name" subtype=capture negate=
    rx606_cur."!cursor_pos"(rx606_pos)
    $P10 = rx606_cur."name"()
    unless $P10, rx606_fail
    rx606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx606_pos = $P10."pos"()
    goto alt612_end
  alt612_1:
    set_addr $I10, alt612_2
    rx606_cur."!mark_push"(0, rx606_pos, $I10)
.annotate 'line', 303
  # rx subrule "sigil" subtype=capture negate=
    rx606_cur."!cursor_pos"(rx606_pos)
    $P10 = rx606_cur."sigil"()
    unless $P10, rx606_fail
    rx606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx606_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx606_pos, rx606_off
    substr $S10, rx606_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx606_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx606_cur."!cursor_pos"(rx606_pos)
    $P10 = rx606_cur."postcircumfix"()
    unless $P10, rx606_fail
    rx606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx606_pos = $P10."pos"()
    goto alt612_end
  alt612_2:
.annotate 'line', 304
  # rx subcapture "sigil"
    set_addr $I10, rxcap_615_fail
    rx606_cur."!mark_push"(0, rx606_pos, $I10)
  # rx literal  "$"
    add $I11, rx606_pos, 1
    gt $I11, rx606_eos, rx606_fail
    sub $I11, rx606_pos, rx606_off
    ord $I11, rx606_tgt, $I11
    ne $I11, 36, rx606_fail
    add rx606_pos, 1
    set_addr $I10, rxcap_615_fail
    ($I12, $I11) = rx606_cur."!mark_peek"($I10)
    rx606_cur."!cursor_pos"($I11)
    ($P10) = rx606_cur."!cursor_start"()
    $P10."!cursor_pass"(rx606_pos, "")
    rx606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_615_done
  rxcap_615_fail:
    goto rx606_fail
  rxcap_615_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_616_fail
    rx606_cur."!mark_push"(0, rx606_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx606_pos, rx606_eos, rx606_fail
    sub $I10, rx606_pos, rx606_off
    substr $S10, rx606_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx606_fail
    inc rx606_pos
    set_addr $I10, rxcap_616_fail
    ($I12, $I11) = rx606_cur."!mark_peek"($I10)
    rx606_cur."!cursor_pos"($I11)
    ($P10) = rx606_cur."!cursor_start"()
    $P10."!cursor_pass"(rx606_pos, "")
    rx606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_616_done
  rxcap_616_fail:
    goto rx606_fail
  rxcap_616_done:
  alt612_end:
.annotate 'line', 301
  # rx pass
    rx606_cur."!cursor_pass"(rx606_pos, "variable")
    if_null rx606_debug, debug_857
    rx606_cur."!cursor_debug"("PASS", "variable", " at pos=", rx606_pos)
  debug_857:
    .return (rx606_cur)
  rx606_restart:
.annotate 'line', 10
    if_null rx606_debug, debug_858
    rx606_cur."!cursor_debug"("NEXT", "variable")
  debug_858:
  rx606_fail:
    (rx606_rep, rx606_pos, $I10, $P10) = rx606_cur."!mark_fail"(0)
    lt rx606_pos, -1, rx606_done
    eq rx606_pos, -1, rx606_fail
    jump $I10
  rx606_done:
    rx606_cur."!cursor_fail"()
    if_null rx606_debug, debug_859
    rx606_cur."!cursor_debug"("FAIL", "variable")
  debug_859:
    .return (rx606_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303603603.711") :method
.annotate 'line', 10
    $P608 = self."!PREFIX__!subrule"("sigil", "")
    $P609 = self."!PREFIX__!subrule"("sigil", "")
    new $P610, "ResizablePMCArray"
    push $P610, "$!"
    push $P610, "$_"
    push $P610, "$/"
    push $P610, $P608
    push $P610, $P609
    .return ($P610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx618_tgt
    .local int rx618_pos
    .local int rx618_off
    .local int rx618_eos
    .local int rx618_rep
    .local pmc rx618_cur
    .local pmc rx618_debug
    (rx618_cur, rx618_pos, rx618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx618_cur
    .local pmc match
    .lex "$/", match
    length rx618_eos, rx618_tgt
    gt rx618_pos, rx618_eos, rx618_done
    set rx618_off, 0
    lt rx618_pos, 2, rx618_start
    sub rx618_off, rx618_pos, 1
    substr rx618_tgt, rx618_tgt, rx618_off
  rx618_start:
    eq $I10, 1, rx618_restart
    if_null rx618_debug, debug_860
    rx618_cur."!cursor_debug"("START", "sigil")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan621_done
    goto rxscan621_scan
  rxscan621_loop:
    (rx618_pos) = rx618_cur."from"()
    inc rx618_pos
    rx618_cur."!cursor_from"(rx618_pos)
    ge rx618_pos, rx618_eos, rxscan621_done
  rxscan621_scan:
    set_addr $I10, rxscan621_loop
    rx618_cur."!mark_push"(0, rx618_pos, $I10)
  rxscan621_done:
.annotate 'line', 307
  # rx enumcharlist negate=0 
    ge rx618_pos, rx618_eos, rx618_fail
    sub $I10, rx618_pos, rx618_off
    substr $S10, rx618_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx618_fail
    inc rx618_pos
  # rx pass
    rx618_cur."!cursor_pass"(rx618_pos, "sigil")
    if_null rx618_debug, debug_861
    rx618_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx618_pos)
  debug_861:
    .return (rx618_cur)
  rx618_restart:
.annotate 'line', 10
    if_null rx618_debug, debug_862
    rx618_cur."!cursor_debug"("NEXT", "sigil")
  debug_862:
  rx618_fail:
    (rx618_rep, rx618_pos, $I10, $P10) = rx618_cur."!mark_fail"(0)
    lt rx618_pos, -1, rx618_done
    eq rx618_pos, -1, rx618_fail
    jump $I10
  rx618_done:
    rx618_cur."!cursor_fail"()
    if_null rx618_debug, debug_863
    rx618_cur."!cursor_debug"("FAIL", "sigil")
  debug_863:
    .return (rx618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303603603.711") :method
.annotate 'line', 10
    new $P620, "ResizablePMCArray"
    push $P620, "&"
    push $P620, "%"
    push $P620, "@"
    push $P620, "$"
    .return ($P620)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx623_tgt
    .local int rx623_pos
    .local int rx623_off
    .local int rx623_eos
    .local int rx623_rep
    .local pmc rx623_cur
    .local pmc rx623_debug
    (rx623_cur, rx623_pos, rx623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx623_cur
    .local pmc match
    .lex "$/", match
    length rx623_eos, rx623_tgt
    gt rx623_pos, rx623_eos, rx623_done
    set rx623_off, 0
    lt rx623_pos, 2, rx623_start
    sub rx623_off, rx623_pos, 1
    substr rx623_tgt, rx623_tgt, rx623_off
  rx623_start:
    eq $I10, 1, rx623_restart
    if_null rx623_debug, debug_864
    rx623_cur."!cursor_debug"("START", "twigil")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan626_done
    goto rxscan626_scan
  rxscan626_loop:
    (rx623_pos) = rx623_cur."from"()
    inc rx623_pos
    rx623_cur."!cursor_from"(rx623_pos)
    ge rx623_pos, rx623_eos, rxscan626_done
  rxscan626_scan:
    set_addr $I10, rxscan626_loop
    rx623_cur."!mark_push"(0, rx623_pos, $I10)
  rxscan626_done:
.annotate 'line', 309
  # rx enumcharlist negate=0 
    ge rx623_pos, rx623_eos, rx623_fail
    sub $I10, rx623_pos, rx623_off
    substr $S10, rx623_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx623_fail
    inc rx623_pos
  # rx pass
    rx623_cur."!cursor_pass"(rx623_pos, "twigil")
    if_null rx623_debug, debug_865
    rx623_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx623_pos)
  debug_865:
    .return (rx623_cur)
  rx623_restart:
.annotate 'line', 10
    if_null rx623_debug, debug_866
    rx623_cur."!cursor_debug"("NEXT", "twigil")
  debug_866:
  rx623_fail:
    (rx623_rep, rx623_pos, $I10, $P10) = rx623_cur."!mark_fail"(0)
    lt rx623_pos, -1, rx623_done
    eq rx623_pos, -1, rx623_fail
    jump $I10
  rx623_done:
    rx623_cur."!cursor_fail"()
    if_null rx623_debug, debug_867
    rx623_cur."!cursor_debug"("FAIL", "twigil")
  debug_867:
    .return (rx623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303603603.711") :method
.annotate 'line', 10
    new $P625, "ResizablePMCArray"
    push $P625, "?"
    push $P625, "!"
    push $P625, "*"
    .return ($P625)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303603603.711")
    .param pmc param_628
.annotate 'line', 311
    .lex "self", param_628
    $P629 = param_628."!protoregex"("package_declarator")
    .return ($P629)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303603603.711")
    .param pmc param_631
.annotate 'line', 311
    .lex "self", param_631
    $P632 = param_631."!PREFIX__!protoregex"("package_declarator")
    .return ($P632)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 313
    new $P634, "Undef"
    .lex "$*OUTERPACKAGE", $P634
.annotate 'line', 314
    new $P635, "Undef"
    .lex "$*PACKAGE-SETUP", $P635
.annotate 'line', 315
    new $P636, "Undef"
    .lex "$*PKGDECL", $P636
.annotate 'line', 10
    .local string rx637_tgt
    .local int rx637_pos
    .local int rx637_off
    .local int rx637_eos
    .local int rx637_rep
    .local pmc rx637_cur
    .local pmc rx637_debug
    (rx637_cur, rx637_pos, rx637_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx637_cur
    .local pmc match
    .lex "$/", match
    length rx637_eos, rx637_tgt
    gt rx637_pos, rx637_eos, rx637_done
    set rx637_off, 0
    lt rx637_pos, 2, rx637_start
    sub rx637_off, rx637_pos, 1
    substr rx637_tgt, rx637_tgt, rx637_off
  rx637_start:
    eq $I10, 1, rx637_restart
    if_null rx637_debug, debug_868
    rx637_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan641_done
    goto rxscan641_scan
  rxscan641_loop:
    (rx637_pos) = rx637_cur."from"()
    inc rx637_pos
    rx637_cur."!cursor_from"(rx637_pos)
    ge rx637_pos, rx637_eos, rxscan641_done
  rxscan641_scan:
    set_addr $I10, rxscan641_loop
    rx637_cur."!mark_push"(0, rx637_pos, $I10)
  rxscan641_done:
.annotate 'line', 313
    rx637_cur."!cursor_pos"(rx637_pos)
    find_dynamic_lex $P642, "$*PACKAGE"
    unless_null $P642, vivify_869
    get_hll_global $P642, "$PACKAGE"
    unless_null $P642, vivify_870
    die "Contextual $*PACKAGE not found"
  vivify_870:
  vivify_869:
    store_lex "$*OUTERPACKAGE", $P642
.annotate 'line', 314
    rx637_cur."!cursor_pos"(rx637_pos)
    get_hll_global $P643, ["PAST"], "Stmts"
    $P644 = $P643."new"()
    store_lex "$*PACKAGE-SETUP", $P644
.annotate 'line', 315
    rx637_cur."!cursor_pos"(rx637_pos)
    new $P645, "String"
    assign $P645, "module"
    store_lex "$*PKGDECL", $P645
.annotate 'line', 316
  # rx subcapture "sym"
    set_addr $I10, rxcap_646_fail
    rx637_cur."!mark_push"(0, rx637_pos, $I10)
  # rx literal  "module"
    add $I11, rx637_pos, 6
    gt $I11, rx637_eos, rx637_fail
    sub $I11, rx637_pos, rx637_off
    substr $S10, rx637_tgt, $I11, 6
    ne $S10, "module", rx637_fail
    add rx637_pos, 6
    set_addr $I10, rxcap_646_fail
    ($I12, $I11) = rx637_cur."!mark_peek"($I10)
    rx637_cur."!cursor_pos"($I11)
    ($P10) = rx637_cur."!cursor_start"()
    $P10."!cursor_pass"(rx637_pos, "")
    rx637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_646_done
  rxcap_646_fail:
    goto rx637_fail
  rxcap_646_done:
  # rx subrule "package_def" subtype=capture negate=
    rx637_cur."!cursor_pos"(rx637_pos)
    $P10 = rx637_cur."package_def"()
    unless $P10, rx637_fail
    rx637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx637_pos = $P10."pos"()
.annotate 'line', 312
  # rx pass
    rx637_cur."!cursor_pass"(rx637_pos, "package_declarator:sym<module>")
    if_null rx637_debug, debug_871
    rx637_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx637_pos)
  debug_871:
    .return (rx637_cur)
  rx637_restart:
.annotate 'line', 10
    if_null rx637_debug, debug_872
    rx637_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_872:
  rx637_fail:
    (rx637_rep, rx637_pos, $I10, $P10) = rx637_cur."!mark_fail"(0)
    lt rx637_pos, -1, rx637_done
    eq rx637_pos, -1, rx637_fail
    jump $I10
  rx637_done:
    rx637_cur."!cursor_fail"()
    if_null rx637_debug, debug_873
    rx637_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_873:
    .return (rx637_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303603603.711") :method
.annotate 'line', 10
    $P639 = self."!PREFIX__!subrule"("package_def", "module")
    new $P640, "ResizablePMCArray"
    push $P640, $P639
    .return ($P640)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 319
    new $P648, "Undef"
    .lex "$*OUTERPACKAGE", $P648
.annotate 'line', 320
    new $P649, "Undef"
    .lex "$*PACKAGE-SETUP", $P649
.annotate 'line', 321
    new $P650, "Undef"
    .lex "$*PKGDECL", $P650
.annotate 'line', 10
    .local string rx651_tgt
    .local int rx651_pos
    .local int rx651_off
    .local int rx651_eos
    .local int rx651_rep
    .local pmc rx651_cur
    .local pmc rx651_debug
    (rx651_cur, rx651_pos, rx651_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx651_cur
    .local pmc match
    .lex "$/", match
    length rx651_eos, rx651_tgt
    gt rx651_pos, rx651_eos, rx651_done
    set rx651_off, 0
    lt rx651_pos, 2, rx651_start
    sub rx651_off, rx651_pos, 1
    substr rx651_tgt, rx651_tgt, rx651_off
  rx651_start:
    eq $I10, 1, rx651_restart
    if_null rx651_debug, debug_874
    rx651_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_874:
    $I10 = self.'from'()
    ne $I10, -1, rxscan655_done
    goto rxscan655_scan
  rxscan655_loop:
    (rx651_pos) = rx651_cur."from"()
    inc rx651_pos
    rx651_cur."!cursor_from"(rx651_pos)
    ge rx651_pos, rx651_eos, rxscan655_done
  rxscan655_scan:
    set_addr $I10, rxscan655_loop
    rx651_cur."!mark_push"(0, rx651_pos, $I10)
  rxscan655_done:
.annotate 'line', 319
    rx651_cur."!cursor_pos"(rx651_pos)
    find_dynamic_lex $P656, "$*PACKAGE"
    unless_null $P656, vivify_875
    get_hll_global $P656, "$PACKAGE"
    unless_null $P656, vivify_876
    die "Contextual $*PACKAGE not found"
  vivify_876:
  vivify_875:
    store_lex "$*OUTERPACKAGE", $P656
.annotate 'line', 320
    rx651_cur."!cursor_pos"(rx651_pos)
    get_hll_global $P657, ["PAST"], "Stmts"
    $P658 = $P657."new"()
    store_lex "$*PACKAGE-SETUP", $P658
.annotate 'line', 321
    rx651_cur."!cursor_pos"(rx651_pos)
    new $P659, "String"
    assign $P659, "knowhow"
    store_lex "$*PKGDECL", $P659
.annotate 'line', 322
  # rx subcapture "sym"
    set_addr $I10, rxcap_660_fail
    rx651_cur."!mark_push"(0, rx651_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx651_pos, 7
    gt $I11, rx651_eos, rx651_fail
    sub $I11, rx651_pos, rx651_off
    substr $S10, rx651_tgt, $I11, 7
    ne $S10, "knowhow", rx651_fail
    add rx651_pos, 7
    set_addr $I10, rxcap_660_fail
    ($I12, $I11) = rx651_cur."!mark_peek"($I10)
    rx651_cur."!cursor_pos"($I11)
    ($P10) = rx651_cur."!cursor_start"()
    $P10."!cursor_pass"(rx651_pos, "")
    rx651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_660_done
  rxcap_660_fail:
    goto rx651_fail
  rxcap_660_done:
  # rx subrule "package_def" subtype=capture negate=
    rx651_cur."!cursor_pos"(rx651_pos)
    $P10 = rx651_cur."package_def"()
    unless $P10, rx651_fail
    rx651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx651_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx651_cur."!cursor_pass"(rx651_pos, "package_declarator:sym<knowhow>")
    if_null rx651_debug, debug_877
    rx651_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx651_pos)
  debug_877:
    .return (rx651_cur)
  rx651_restart:
.annotate 'line', 10
    if_null rx651_debug, debug_878
    rx651_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_878:
  rx651_fail:
    (rx651_rep, rx651_pos, $I10, $P10) = rx651_cur."!mark_fail"(0)
    lt rx651_pos, -1, rx651_done
    eq rx651_pos, -1, rx651_fail
    jump $I10
  rx651_done:
    rx651_cur."!cursor_fail"()
    if_null rx651_debug, debug_879
    rx651_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_879:
    .return (rx651_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303603603.711") :method
.annotate 'line', 10
    $P653 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P654, "ResizablePMCArray"
    push $P654, $P653
    .return ($P654)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 325
    new $P662, "Undef"
    .lex "$*OUTERPACKAGE", $P662
.annotate 'line', 326
    new $P663, "Undef"
    .lex "$*PACKAGE-SETUP", $P663
.annotate 'line', 327
    new $P664, "Undef"
    .lex "$*PKGDECL", $P664
.annotate 'line', 10
    .local string rx665_tgt
    .local int rx665_pos
    .local int rx665_off
    .local int rx665_eos
    .local int rx665_rep
    .local pmc rx665_cur
    .local pmc rx665_debug
    (rx665_cur, rx665_pos, rx665_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx665_cur
    .local pmc match
    .lex "$/", match
    length rx665_eos, rx665_tgt
    gt rx665_pos, rx665_eos, rx665_done
    set rx665_off, 0
    lt rx665_pos, 2, rx665_start
    sub rx665_off, rx665_pos, 1
    substr rx665_tgt, rx665_tgt, rx665_off
  rx665_start:
    eq $I10, 1, rx665_restart
    if_null rx665_debug, debug_880
    rx665_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan669_done
    goto rxscan669_scan
  rxscan669_loop:
    (rx665_pos) = rx665_cur."from"()
    inc rx665_pos
    rx665_cur."!cursor_from"(rx665_pos)
    ge rx665_pos, rx665_eos, rxscan669_done
  rxscan669_scan:
    set_addr $I10, rxscan669_loop
    rx665_cur."!mark_push"(0, rx665_pos, $I10)
  rxscan669_done:
.annotate 'line', 325
    rx665_cur."!cursor_pos"(rx665_pos)
    find_dynamic_lex $P670, "$*PACKAGE"
    unless_null $P670, vivify_881
    get_hll_global $P670, "$PACKAGE"
    unless_null $P670, vivify_882
    die "Contextual $*PACKAGE not found"
  vivify_882:
  vivify_881:
    store_lex "$*OUTERPACKAGE", $P670
.annotate 'line', 326
    rx665_cur."!cursor_pos"(rx665_pos)
    get_hll_global $P671, ["PAST"], "Stmts"
    $P672 = $P671."new"()
    store_lex "$*PACKAGE-SETUP", $P672
.annotate 'line', 327
    rx665_cur."!cursor_pos"(rx665_pos)
    new $P673, "String"
    assign $P673, "class"
    store_lex "$*PKGDECL", $P673
.annotate 'line', 328
  # rx subcapture "sym"
    set_addr $I10, rxcap_674_fail
    rx665_cur."!mark_push"(0, rx665_pos, $I10)
  # rx literal  "class"
    add $I11, rx665_pos, 5
    gt $I11, rx665_eos, rx665_fail
    sub $I11, rx665_pos, rx665_off
    substr $S10, rx665_tgt, $I11, 5
    ne $S10, "class", rx665_fail
    add rx665_pos, 5
    set_addr $I10, rxcap_674_fail
    ($I12, $I11) = rx665_cur."!mark_peek"($I10)
    rx665_cur."!cursor_pos"($I11)
    ($P10) = rx665_cur."!cursor_start"()
    $P10."!cursor_pass"(rx665_pos, "")
    rx665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_674_done
  rxcap_674_fail:
    goto rx665_fail
  rxcap_674_done:
  # rx subrule "package_def" subtype=capture negate=
    rx665_cur."!cursor_pos"(rx665_pos)
    $P10 = rx665_cur."package_def"()
    unless $P10, rx665_fail
    rx665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx665_pos = $P10."pos"()
.annotate 'line', 324
  # rx pass
    rx665_cur."!cursor_pass"(rx665_pos, "package_declarator:sym<class>")
    if_null rx665_debug, debug_883
    rx665_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx665_pos)
  debug_883:
    .return (rx665_cur)
  rx665_restart:
.annotate 'line', 10
    if_null rx665_debug, debug_884
    rx665_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_884:
  rx665_fail:
    (rx665_rep, rx665_pos, $I10, $P10) = rx665_cur."!mark_fail"(0)
    lt rx665_pos, -1, rx665_done
    eq rx665_pos, -1, rx665_fail
    jump $I10
  rx665_done:
    rx665_cur."!cursor_fail"()
    if_null rx665_debug, debug_885
    rx665_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_885:
    .return (rx665_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303603603.711") :method
.annotate 'line', 10
    $P667 = self."!PREFIX__!subrule"("package_def", "class")
    new $P668, "ResizablePMCArray"
    push $P668, $P667
    .return ($P668)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 331
    new $P676, "Undef"
    .lex "$*OUTERPACKAGE", $P676
.annotate 'line', 332
    new $P677, "Undef"
    .lex "$*PACKAGE-SETUP", $P677
.annotate 'line', 333
    new $P678, "Undef"
    .lex "$*PKGDECL", $P678
.annotate 'line', 10
    .local string rx679_tgt
    .local int rx679_pos
    .local int rx679_off
    .local int rx679_eos
    .local int rx679_rep
    .local pmc rx679_cur
    .local pmc rx679_debug
    (rx679_cur, rx679_pos, rx679_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx679_cur
    .local pmc match
    .lex "$/", match
    length rx679_eos, rx679_tgt
    gt rx679_pos, rx679_eos, rx679_done
    set rx679_off, 0
    lt rx679_pos, 2, rx679_start
    sub rx679_off, rx679_pos, 1
    substr rx679_tgt, rx679_tgt, rx679_off
  rx679_start:
    eq $I10, 1, rx679_restart
    if_null rx679_debug, debug_886
    rx679_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_886:
    $I10 = self.'from'()
    ne $I10, -1, rxscan683_done
    goto rxscan683_scan
  rxscan683_loop:
    (rx679_pos) = rx679_cur."from"()
    inc rx679_pos
    rx679_cur."!cursor_from"(rx679_pos)
    ge rx679_pos, rx679_eos, rxscan683_done
  rxscan683_scan:
    set_addr $I10, rxscan683_loop
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxscan683_done:
.annotate 'line', 331
    rx679_cur."!cursor_pos"(rx679_pos)
    find_dynamic_lex $P684, "$*PACKAGE"
    unless_null $P684, vivify_887
    get_hll_global $P684, "$PACKAGE"
    unless_null $P684, vivify_888
    die "Contextual $*PACKAGE not found"
  vivify_888:
  vivify_887:
    store_lex "$*OUTERPACKAGE", $P684
.annotate 'line', 332
    rx679_cur."!cursor_pos"(rx679_pos)
    get_hll_global $P685, ["PAST"], "Stmts"
    $P686 = $P685."new"()
    store_lex "$*PACKAGE-SETUP", $P686
.annotate 'line', 333
    rx679_cur."!cursor_pos"(rx679_pos)
    new $P687, "String"
    assign $P687, "grammar"
    store_lex "$*PKGDECL", $P687
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_688_fail
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx679_pos, 7
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 7
    ne $S10, "grammar", rx679_fail
    add rx679_pos, 7
    set_addr $I10, rxcap_688_fail
    ($I12, $I11) = rx679_cur."!mark_peek"($I10)
    rx679_cur."!cursor_pos"($I11)
    ($P10) = rx679_cur."!cursor_start"()
    $P10."!cursor_pass"(rx679_pos, "")
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_688_done
  rxcap_688_fail:
    goto rx679_fail
  rxcap_688_done:
  # rx subrule "package_def" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."package_def"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx679_pos = $P10."pos"()
.annotate 'line', 330
  # rx pass
    rx679_cur."!cursor_pass"(rx679_pos, "package_declarator:sym<grammar>")
    if_null rx679_debug, debug_889
    rx679_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx679_pos)
  debug_889:
    .return (rx679_cur)
  rx679_restart:
.annotate 'line', 10
    if_null rx679_debug, debug_890
    rx679_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_890:
  rx679_fail:
    (rx679_rep, rx679_pos, $I10, $P10) = rx679_cur."!mark_fail"(0)
    lt rx679_pos, -1, rx679_done
    eq rx679_pos, -1, rx679_fail
    jump $I10
  rx679_done:
    rx679_cur."!cursor_fail"()
    if_null rx679_debug, debug_891
    rx679_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_891:
    .return (rx679_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303603603.711") :method
.annotate 'line', 10
    $P681 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P682, "ResizablePMCArray"
    push $P682, $P681
    .return ($P682)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 337
    new $P690, "Undef"
    .lex "$*OUTERPACKAGE", $P690
.annotate 'line', 338
    new $P691, "Undef"
    .lex "$*PACKAGE-SETUP", $P691
.annotate 'line', 339
    new $P692, "Undef"
    .lex "$*PKGDECL", $P692
.annotate 'line', 10
    .local string rx693_tgt
    .local int rx693_pos
    .local int rx693_off
    .local int rx693_eos
    .local int rx693_rep
    .local pmc rx693_cur
    .local pmc rx693_debug
    (rx693_cur, rx693_pos, rx693_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx693_cur
    .local pmc match
    .lex "$/", match
    length rx693_eos, rx693_tgt
    gt rx693_pos, rx693_eos, rx693_done
    set rx693_off, 0
    lt rx693_pos, 2, rx693_start
    sub rx693_off, rx693_pos, 1
    substr rx693_tgt, rx693_tgt, rx693_off
  rx693_start:
    eq $I10, 1, rx693_restart
    if_null rx693_debug, debug_892
    rx693_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan697_done
    goto rxscan697_scan
  rxscan697_loop:
    (rx693_pos) = rx693_cur."from"()
    inc rx693_pos
    rx693_cur."!cursor_from"(rx693_pos)
    ge rx693_pos, rx693_eos, rxscan697_done
  rxscan697_scan:
    set_addr $I10, rxscan697_loop
    rx693_cur."!mark_push"(0, rx693_pos, $I10)
  rxscan697_done:
.annotate 'line', 337
    rx693_cur."!cursor_pos"(rx693_pos)
    find_dynamic_lex $P698, "$*PACKAGE"
    unless_null $P698, vivify_893
    get_hll_global $P698, "$PACKAGE"
    unless_null $P698, vivify_894
    die "Contextual $*PACKAGE not found"
  vivify_894:
  vivify_893:
    store_lex "$*OUTERPACKAGE", $P698
.annotate 'line', 338
    rx693_cur."!cursor_pos"(rx693_pos)
    get_hll_global $P699, ["PAST"], "Stmts"
    $P700 = $P699."new"()
    store_lex "$*PACKAGE-SETUP", $P700
.annotate 'line', 339
    rx693_cur."!cursor_pos"(rx693_pos)
    new $P701, "String"
    assign $P701, "role"
    store_lex "$*PKGDECL", $P701
.annotate 'line', 340
  # rx subcapture "sym"
    set_addr $I10, rxcap_702_fail
    rx693_cur."!mark_push"(0, rx693_pos, $I10)
  # rx literal  "role"
    add $I11, rx693_pos, 4
    gt $I11, rx693_eos, rx693_fail
    sub $I11, rx693_pos, rx693_off
    substr $S10, rx693_tgt, $I11, 4
    ne $S10, "role", rx693_fail
    add rx693_pos, 4
    set_addr $I10, rxcap_702_fail
    ($I12, $I11) = rx693_cur."!mark_peek"($I10)
    rx693_cur."!cursor_pos"($I11)
    ($P10) = rx693_cur."!cursor_start"()
    $P10."!cursor_pass"(rx693_pos, "")
    rx693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_702_done
  rxcap_702_fail:
    goto rx693_fail
  rxcap_702_done:
  # rx subrule "package_def" subtype=capture negate=
    rx693_cur."!cursor_pos"(rx693_pos)
    $P10 = rx693_cur."package_def"()
    unless $P10, rx693_fail
    rx693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx693_pos = $P10."pos"()
.annotate 'line', 336
  # rx pass
    rx693_cur."!cursor_pass"(rx693_pos, "package_declarator:sym<role>")
    if_null rx693_debug, debug_895
    rx693_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx693_pos)
  debug_895:
    .return (rx693_cur)
  rx693_restart:
.annotate 'line', 10
    if_null rx693_debug, debug_896
    rx693_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_896:
  rx693_fail:
    (rx693_rep, rx693_pos, $I10, $P10) = rx693_cur."!mark_fail"(0)
    lt rx693_pos, -1, rx693_done
    eq rx693_pos, -1, rx693_fail
    jump $I10
  rx693_done:
    rx693_cur."!cursor_fail"()
    if_null rx693_debug, debug_897
    rx693_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_897:
    .return (rx693_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303603603.711") :method
.annotate 'line', 10
    $P695 = self."!PREFIX__!subrule"("package_def", "role")
    new $P696, "ResizablePMCArray"
    push $P696, $P695
    .return ($P696)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 343
    new $P704, "Undef"
    .lex "$*OUTERPACKAGE", $P704
.annotate 'line', 344
    new $P705, "Undef"
    .lex "$*PACKAGE-SETUP", $P705
.annotate 'line', 345
    new $P706, "Undef"
    .lex "$*PKGDECL", $P706
.annotate 'line', 10
    .local string rx707_tgt
    .local int rx707_pos
    .local int rx707_off
    .local int rx707_eos
    .local int rx707_rep
    .local pmc rx707_cur
    .local pmc rx707_debug
    (rx707_cur, rx707_pos, rx707_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx707_cur
    .local pmc match
    .lex "$/", match
    length rx707_eos, rx707_tgt
    gt rx707_pos, rx707_eos, rx707_done
    set rx707_off, 0
    lt rx707_pos, 2, rx707_start
    sub rx707_off, rx707_pos, 1
    substr rx707_tgt, rx707_tgt, rx707_off
  rx707_start:
    eq $I10, 1, rx707_restart
    if_null rx707_debug, debug_898
    rx707_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_898:
    $I10 = self.'from'()
    ne $I10, -1, rxscan711_done
    goto rxscan711_scan
  rxscan711_loop:
    (rx707_pos) = rx707_cur."from"()
    inc rx707_pos
    rx707_cur."!cursor_from"(rx707_pos)
    ge rx707_pos, rx707_eos, rxscan711_done
  rxscan711_scan:
    set_addr $I10, rxscan711_loop
    rx707_cur."!mark_push"(0, rx707_pos, $I10)
  rxscan711_done:
.annotate 'line', 343
    rx707_cur."!cursor_pos"(rx707_pos)
    find_dynamic_lex $P712, "$*PACKAGE"
    unless_null $P712, vivify_899
    get_hll_global $P712, "$PACKAGE"
    unless_null $P712, vivify_900
    die "Contextual $*PACKAGE not found"
  vivify_900:
  vivify_899:
    store_lex "$*OUTERPACKAGE", $P712
.annotate 'line', 344
    rx707_cur."!cursor_pos"(rx707_pos)
    get_hll_global $P713, ["PAST"], "Stmts"
    $P714 = $P713."new"()
    store_lex "$*PACKAGE-SETUP", $P714
.annotate 'line', 345
    rx707_cur."!cursor_pos"(rx707_pos)
    new $P715, "String"
    assign $P715, "native"
    store_lex "$*PKGDECL", $P715
.annotate 'line', 346
  # rx subcapture "sym"
    set_addr $I10, rxcap_716_fail
    rx707_cur."!mark_push"(0, rx707_pos, $I10)
  # rx literal  "native"
    add $I11, rx707_pos, 6
    gt $I11, rx707_eos, rx707_fail
    sub $I11, rx707_pos, rx707_off
    substr $S10, rx707_tgt, $I11, 6
    ne $S10, "native", rx707_fail
    add rx707_pos, 6
    set_addr $I10, rxcap_716_fail
    ($I12, $I11) = rx707_cur."!mark_peek"($I10)
    rx707_cur."!cursor_pos"($I11)
    ($P10) = rx707_cur."!cursor_start"()
    $P10."!cursor_pass"(rx707_pos, "")
    rx707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_716_done
  rxcap_716_fail:
    goto rx707_fail
  rxcap_716_done:
  # rx subrule "package_def" subtype=capture negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."package_def"()
    unless $P10, rx707_fail
    rx707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx707_pos = $P10."pos"()
.annotate 'line', 342
  # rx pass
    rx707_cur."!cursor_pass"(rx707_pos, "package_declarator:sym<native>")
    if_null rx707_debug, debug_901
    rx707_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx707_pos)
  debug_901:
    .return (rx707_cur)
  rx707_restart:
.annotate 'line', 10
    if_null rx707_debug, debug_902
    rx707_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_902:
  rx707_fail:
    (rx707_rep, rx707_pos, $I10, $P10) = rx707_cur."!mark_fail"(0)
    lt rx707_pos, -1, rx707_done
    eq rx707_pos, -1, rx707_fail
    jump $I10
  rx707_done:
    rx707_cur."!cursor_fail"()
    if_null rx707_debug, debug_903
    rx707_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_903:
    .return (rx707_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303603603.711") :method
.annotate 'line', 10
    $P709 = self."!PREFIX__!subrule"("package_def", "native")
    new $P710, "ResizablePMCArray"
    push $P710, $P709
    .return ($P710)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P741 = "154_1303603603.711" 
    capture_lex $P741
.annotate 'line', 350
    new $P718, "Undef"
    .lex "$*PACKAGE", $P718
.annotate 'line', 351
    $P719 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P719
.annotate 'line', 10
    .local string rx720_tgt
    .local int rx720_pos
    .local int rx720_off
    .local int rx720_eos
    .local int rx720_rep
    .local pmc rx720_cur
    .local pmc rx720_debug
    (rx720_cur, rx720_pos, rx720_tgt, $I10) = self."!cursor_start"()
    rx720_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx720_cur
    .local pmc match
    .lex "$/", match
    length rx720_eos, rx720_tgt
    gt rx720_pos, rx720_eos, rx720_done
    set rx720_off, 0
    lt rx720_pos, 2, rx720_start
    sub rx720_off, rx720_pos, 1
    substr rx720_tgt, rx720_tgt, rx720_off
  rx720_start:
    eq $I10, 1, rx720_restart
    if_null rx720_debug, debug_904
    rx720_cur."!cursor_debug"("START", "package_def")
  debug_904:
    $I10 = self.'from'()
    ne $I10, -1, rxscan724_done
    goto rxscan724_scan
  rxscan724_loop:
    (rx720_pos) = rx720_cur."from"()
    inc rx720_pos
    rx720_cur."!cursor_from"(rx720_pos)
    ge rx720_pos, rx720_eos, rxscan724_done
  rxscan724_scan:
    set_addr $I10, rxscan724_loop
    rx720_cur."!mark_push"(0, rx720_pos, $I10)
  rxscan724_done:
.annotate 'line', 349
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
.annotate 'line', 350
    rx720_cur."!cursor_pos"(rx720_pos)
    find_lex $P726, "$*PACKAGE"
    unless_null $P726, vivify_905
    get_hll_global $P726, "$PACKAGE"
    unless_null $P726, vivify_906
    die "Contextual $*PACKAGE not found"
  vivify_906:
  vivify_905:
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
.annotate 'line', 351
    rx720_cur."!cursor_pos"(rx720_pos)
    find_lex $P728, "%*ATTR-CHECK"
    unless_null $P728, vivify_907
    get_hll_global $P728, "%ATTR-CHECK"
    unless_null $P728, vivify_908
    die "Contextual %*ATTR-CHECK not found"
  vivify_908:
  vivify_907:
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
.annotate 'line', 353
  # rx subrule "name" subtype=capture negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."name"()
    unless $P10, rx720_fail
    rx720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx720_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
.annotate 'line', 354
  # rx rxquantr731 ** 0..1
    set_addr $I10, rxquantr731_done
    rx720_cur."!mark_push"(0, rx720_pos, $I10)
  rxquantr731_loop:
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx720_pos, 2
    gt $I11, rx720_eos, rx720_fail
    sub $I11, rx720_pos, rx720_off
    substr $S10, rx720_tgt, $I11, 2
    ne $S10, "is", rx720_fail
    add rx720_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx720_pos, 5
    gt $I11, rx720_eos, rx720_fail
    sub $I11, rx720_pos, rx720_off
    substr $S10, rx720_tgt, $I11, 5
    ne $S10, "repr(", rx720_fail
    add rx720_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."quote_EXPR"()
    unless $P10, rx720_fail
    rx720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx720_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx720_pos, 1
    gt $I11, rx720_eos, rx720_fail
    sub $I11, rx720_pos, rx720_off
    ord $I11, rx720_tgt, $I11
    ne $I11, 41, rx720_fail
    add rx720_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
    set_addr $I10, rxquantr731_done
    (rx720_rep) = rx720_cur."!mark_commit"($I10)
  rxquantr731_done:
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
.annotate 'line', 356
    rx720_cur."!cursor_pos"(rx720_pos)
    find_lex $P738, unicode:"$\x{a2}"
    $P739 = $P738."MATCH"()
    store_lex "$/", $P739
    .const 'Sub' $P741 = "154_1303603603.711" 
    capture_lex $P741
    $P831 = $P741()
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
.annotate 'line', 384
  # rx rxquantr833 ** 0..1
    set_addr $I10, rxquantr833_done
    rx720_cur."!mark_push"(0, rx720_pos, $I10)
  rxquantr833_loop:
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx720_pos, 2
    gt $I11, rx720_eos, rx720_fail
    sub $I11, rx720_pos, rx720_off
    substr $S10, rx720_tgt, $I11, 2
    ne $S10, "is", rx720_fail
    add rx720_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."name"()
    unless $P10, rx720_fail
    rx720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx720_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
    set_addr $I10, rxquantr833_done
    (rx720_rep) = rx720_cur."!mark_commit"($I10)
  rxquantr833_done:
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
.annotate 'line', 385
  # rx rxquantr838 ** 0..*
    set_addr $I10, rxquantr838_done
    rx720_cur."!mark_push"(0, rx720_pos, $I10)
  rxquantr838_loop:
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx720_pos, 4
    gt $I11, rx720_eos, rx720_fail
    sub $I11, rx720_pos, rx720_off
    substr $S10, rx720_tgt, $I11, 4
    ne $S10, "does", rx720_fail
    add rx720_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."name"()
    unless $P10, rx720_fail
    rx720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx720_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
    set_addr $I10, rxquantr838_done
    (rx720_rep) = rx720_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr838_done
    rx720_cur."!mark_push"(rx720_rep, rx720_pos, $I10)
    goto rxquantr838_loop
  rxquantr838_done:
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  alt843_0:
.annotate 'line', 386
    set_addr $I10, alt843_1
    rx720_cur."!mark_push"(0, rx720_pos, $I10)
.annotate 'line', 387
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx720_pos, 1
    gt $I11, rx720_eos, rx720_fail
    sub $I11, rx720_pos, rx720_off
    ord $I11, rx720_tgt, $I11
    ne $I11, 59, rx720_fail
    add rx720_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."comp_unit"()
    unless $P10, rx720_fail
    rx720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx720_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
    goto alt843_end
  alt843_1:
    set_addr $I10, alt843_2
    rx720_cur."!mark_push"(0, rx720_pos, $I10)
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx720_pos, rx720_off
    substr $S10, rx720_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx720_fail
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."block"()
    unless $P10, rx720_fail
    rx720_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx720_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
    goto alt843_end
  alt843_2:
.annotate 'line', 389
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."panic"("Malformed package declaration")
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
  alt843_end:
.annotate 'line', 390
  # rx subrule "ws" subtype=method negate=
    rx720_cur."!cursor_pos"(rx720_pos)
    $P10 = rx720_cur."ws"()
    unless $P10, rx720_fail
    rx720_pos = $P10."pos"()
.annotate 'line', 349
  # rx pass
    rx720_cur."!cursor_pass"(rx720_pos, "package_def")
    if_null rx720_debug, debug_976
    rx720_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx720_pos)
  debug_976:
    .return (rx720_cur)
  rx720_restart:
.annotate 'line', 10
    if_null rx720_debug, debug_977
    rx720_cur."!cursor_debug"("NEXT", "package_def")
  debug_977:
  rx720_fail:
    (rx720_rep, rx720_pos, $I10, $P10) = rx720_cur."!mark_fail"(0)
    lt rx720_pos, -1, rx720_done
    eq rx720_pos, -1, rx720_fail
    jump $I10
  rx720_done:
    rx720_cur."!cursor_fail"()
    if_null rx720_debug, debug_978
    rx720_cur."!cursor_debug"("FAIL", "package_def")
  debug_978:
    .return (rx720_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303603603.711") :method
.annotate 'line', 10
    $P722 = self."!PREFIX__!subrule"("ws", "")
    new $P723, "ResizablePMCArray"
    push $P723, $P722
    .return ($P723)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block740"  :anon :subid("154_1303603603.711") :outer("152_1303603603.711")
.annotate 'line', 359
    $P742 = root_new ['parrot';'Hash']
    .lex "%args", $P742
.annotate 'line', 356
    find_lex $P743, "%args"
    unless_null $P743, vivify_909
    $P743 = root_new ['parrot';'Hash']
  vivify_909:
.annotate 'line', 360
    find_lex $P744, "$/"
    unless_null $P744, vivify_910
    $P744 = root_new ['parrot';'Hash']
  vivify_910:
    set $P745, $P744["name"]
    unless_null $P745, vivify_911
    new $P745, "Undef"
  vivify_911:
    set $S746, $P745
    new $P747, 'String'
    set $P747, $S746
    find_lex $P748, "%args"
    unless_null $P748, vivify_912
    $P748 = root_new ['parrot';'Hash']
    store_lex "%args", $P748
  vivify_912:
    set $P748["name"], $P747
.annotate 'line', 361
    find_lex $P750, "$/"
    unless_null $P750, vivify_913
    $P750 = root_new ['parrot';'Hash']
  vivify_913:
    set $P751, $P750["repr"]
    unless_null $P751, vivify_914
    new $P751, "Undef"
  vivify_914:
    unless $P751, if_749_end
.annotate 'line', 362
    find_lex $P752, "$/"
    unless_null $P752, vivify_915
    $P752 = root_new ['parrot';'Hash']
  vivify_915:
    set $P753, $P752["repr"]
    unless_null $P753, vivify_916
    $P753 = root_new ['parrot';'ResizablePMCArray']
  vivify_916:
    set $P754, $P753[0]
    unless_null $P754, vivify_917
    $P754 = root_new ['parrot';'Hash']
  vivify_917:
    set $P755, $P754["quote_delimited"]
    unless_null $P755, vivify_918
    $P755 = root_new ['parrot';'Hash']
  vivify_918:
    set $P756, $P755["quote_atom"]
    unless_null $P756, vivify_919
    $P756 = root_new ['parrot';'ResizablePMCArray']
  vivify_919:
    set $P757, $P756[0]
    unless_null $P757, vivify_920
    new $P757, "Undef"
  vivify_920:
    set $S758, $P757
    new $P759, 'String'
    set $P759, $S758
    find_lex $P760, "%args"
    unless_null $P760, vivify_921
    $P760 = root_new ['parrot';'Hash']
    store_lex "%args", $P760
  vivify_921:
    set $P760["repr"], $P759
  if_749_end:
.annotate 'line', 364
    find_dynamic_lex $P761, "$*SC"
    unless_null $P761, vivify_922
    get_hll_global $P761, "$SC"
    unless_null $P761, vivify_923
    die "Contextual $*SC not found"
  vivify_923:
  vivify_922:
    find_dynamic_lex $P762, "$*PKGDECL"
    unless_null $P762, vivify_924
    get_hll_global $P762, "$PKGDECL"
    unless_null $P762, vivify_925
    die "Contextual $*PKGDECL not found"
  vivify_925:
  vivify_924:
    find_dynamic_lex $P763, "%*HOW"
    unless_null $P763, vivify_926
    get_hll_global $P763, "%HOW"
    unless_null $P763, vivify_927
    die "Contextual %*HOW not found"
  vivify_927:
  vivify_926:
    set $P764, $P763[$P762]
    unless_null $P764, vivify_928
    new $P764, "Undef"
  vivify_928:
    find_lex $P765, "%args"
    unless_null $P765, vivify_929
    $P765 = root_new ['parrot';'Hash']
  vivify_929:
    $P766 = $P761."pkg_create_mo"($P764, $P765 :flat)
    store_dynamic_lex "$*PACKAGE", $P766
.annotate 'line', 367
    find_dynamic_lex $P771, "$*SCOPE"
    unless_null $P771, vivify_930
    get_hll_global $P771, "$SCOPE"
    unless_null $P771, vivify_931
    die "Contextual $*SCOPE not found"
  vivify_931:
  vivify_930:
    set $S772, $P771
    iseq $I773, $S772, "our"
    unless $I773, unless_770
    new $P769, 'Integer'
    set $P769, $I773
    goto unless_770_end
  unless_770:
    find_dynamic_lex $P774, "$*SCOPE"
    unless_null $P774, vivify_932
    get_hll_global $P774, "$SCOPE"
    unless_null $P774, vivify_933
    die "Contextual $*SCOPE not found"
  vivify_933:
  vivify_932:
    set $S775, $P774
    iseq $I776, $S775, ""
    new $P769, 'Integer'
    set $P769, $I776
  unless_770_end:
    if $P769, if_768
.annotate 'line', 373
    find_dynamic_lex $P803, "$*SCOPE"
    unless_null $P803, vivify_934
    get_hll_global $P803, "$SCOPE"
    unless_null $P803, vivify_935
    die "Contextual $*SCOPE not found"
  vivify_935:
  vivify_934:
    set $S804, $P803
    iseq $I805, $S804, "my"
    if $I805, if_802
.annotate 'line', 380
    find_lex $P826, "$/"
    unless_null $P826, vivify_936
    new $P826, "Undef"
  vivify_936:
    $P827 = $P826."CURSOR"()
    find_dynamic_lex $P828, "$*SCOPE"
    unless_null $P828, vivify_937
    get_hll_global $P828, "$SCOPE"
    unless_null $P828, vivify_938
    die "Contextual $*SCOPE not found"
  vivify_938:
  vivify_937:
    concat $P829, $P828, " scoped packages are not supported"
    $P830 = $P827."panic"($P829)
.annotate 'line', 379
    set $P801, $P830
.annotate 'line', 373
    goto if_802_end
  if_802:
.annotate 'line', 374
    find_lex $P807, "$/"
    unless_null $P807, vivify_939
    $P807 = root_new ['parrot';'Hash']
  vivify_939:
    set $P808, $P807["name"]
    unless_null $P808, vivify_940
    $P808 = root_new ['parrot';'Hash']
  vivify_940:
    set $P809, $P808["identifier"]
    unless_null $P809, vivify_941
    new $P809, "Undef"
  vivify_941:
    set $N810, $P809
    isne $I811, $N810, 1.0
    unless $I811, if_806_end
.annotate 'line', 375
    find_lex $P812, "$/"
    unless_null $P812, vivify_942
    $P812 = root_new ['parrot';'Hash']
  vivify_942:
    set $P813, $P812["name"]
    unless_null $P813, vivify_943
    new $P813, "Undef"
  vivify_943:
    $P814 = $P813."CURSOR"()
    $P814."panic"("A my scoped package cannot have a multi-part name yet")
  if_806_end:
.annotate 'line', 377
    find_dynamic_lex $P815, "$*SC"
    unless_null $P815, vivify_944
    get_hll_global $P815, "$SC"
    unless_null $P815, vivify_945
    die "Contextual $*SC not found"
  vivify_945:
  vivify_944:
    get_hll_global $P816, ["NQP"], "Actions"
    get_who $P817, $P816
    set $P818, $P817["@BLOCK"]
    unless_null $P818, vivify_946
    $P818 = root_new ['parrot';'ResizablePMCArray']
  vivify_946:
    set $P819, $P818[0]
    unless_null $P819, vivify_947
    new $P819, "Undef"
  vivify_947:
    find_lex $P820, "$/"
    unless_null $P820, vivify_948
    $P820 = root_new ['parrot';'Hash']
  vivify_948:
    set $P821, $P820["name"]
    unless_null $P821, vivify_949
    $P821 = root_new ['parrot';'Hash']
  vivify_949:
    set $P822, $P821["identifier"]
    unless_null $P822, vivify_950
    $P822 = root_new ['parrot';'ResizablePMCArray']
  vivify_950:
    set $P823, $P822[0]
    unless_null $P823, vivify_951
    new $P823, "Undef"
  vivify_951:
    find_dynamic_lex $P824, "$*PACKAGE"
    unless_null $P824, vivify_952
    get_hll_global $P824, "$PACKAGE"
    unless_null $P824, vivify_953
    die "Contextual $*PACKAGE not found"
  vivify_953:
  vivify_952:
    $P825 = $P815."install_lexical_symbol"($P819, $P823, $P824)
.annotate 'line', 373
    set $P801, $P825
  if_802_end:
    set $P767, $P801
.annotate 'line', 367
    goto if_768_end
  if_768:
.annotate 'line', 368
    find_dynamic_lex $P777, "$*SC"
    unless_null $P777, vivify_954
    get_hll_global $P777, "$SC"
    unless_null $P777, vivify_955
    die "Contextual $*SC not found"
  vivify_955:
  vivify_954:
    find_dynamic_lex $P778, "$*OUTERPACKAGE"
    unless_null $P778, vivify_956
    get_hll_global $P778, "$OUTERPACKAGE"
    unless_null $P778, vivify_957
    die "Contextual $*OUTERPACKAGE not found"
  vivify_957:
  vivify_956:
    find_lex $P779, "$/"
    unless_null $P779, vivify_958
    $P779 = root_new ['parrot';'Hash']
  vivify_958:
    set $P780, $P779["name"]
    unless_null $P780, vivify_959
    $P780 = root_new ['parrot';'Hash']
  vivify_959:
    set $P781, $P780["identifier"]
    unless_null $P781, vivify_960
    new $P781, "Undef"
  vivify_960:
    find_dynamic_lex $P782, "$*PACKAGE"
    unless_null $P782, vivify_961
    get_hll_global $P782, "$PACKAGE"
    unless_null $P782, vivify_962
    die "Contextual $*PACKAGE not found"
  vivify_962:
  vivify_961:
    $P777."install_package_symbol"($P778, $P781, $P782)
.annotate 'line', 369
    find_lex $P785, "$/"
    unless_null $P785, vivify_963
    $P785 = root_new ['parrot';'Hash']
  vivify_963:
    set $P786, $P785["name"]
    unless_null $P786, vivify_964
    $P786 = root_new ['parrot';'Hash']
  vivify_964:
    set $P787, $P786["identifier"]
    unless_null $P787, vivify_965
    new $P787, "Undef"
  vivify_965:
    set $N788, $P787
    iseq $I789, $N788, 1.0
    if $I789, if_784
    new $P783, 'Integer'
    set $P783, $I789
    goto if_784_end
  if_784:
.annotate 'line', 370
    find_dynamic_lex $P790, "$*SC"
    unless_null $P790, vivify_966
    get_hll_global $P790, "$SC"
    unless_null $P790, vivify_967
    die "Contextual $*SC not found"
  vivify_967:
  vivify_966:
    get_hll_global $P791, ["NQP"], "Actions"
    get_who $P792, $P791
    set $P793, $P792["@BLOCK"]
    unless_null $P793, vivify_968
    $P793 = root_new ['parrot';'ResizablePMCArray']
  vivify_968:
    set $P794, $P793[0]
    unless_null $P794, vivify_969
    new $P794, "Undef"
  vivify_969:
    find_lex $P795, "$/"
    unless_null $P795, vivify_970
    $P795 = root_new ['parrot';'Hash']
  vivify_970:
    set $P796, $P795["name"]
    unless_null $P796, vivify_971
    $P796 = root_new ['parrot';'Hash']
  vivify_971:
    set $P797, $P796["identifier"]
    unless_null $P797, vivify_972
    $P797 = root_new ['parrot';'ResizablePMCArray']
  vivify_972:
    set $P798, $P797[0]
    unless_null $P798, vivify_973
    new $P798, "Undef"
  vivify_973:
    find_dynamic_lex $P799, "$*PACKAGE"
    unless_null $P799, vivify_974
    get_hll_global $P799, "$PACKAGE"
    unless_null $P799, vivify_975
    die "Contextual $*PACKAGE not found"
  vivify_975:
  vivify_974:
    $P800 = $P790."install_lexical_symbol"($P794, $P798, $P799)
.annotate 'line', 369
    set $P783, $P800
  if_784_end:
.annotate 'line', 367
    set $P767, $P783
  if_768_end:
.annotate 'line', 356
    .return ($P767)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303603603.711")
    .param pmc param_854
.annotate 'line', 393
    .lex "self", param_854
    $P855 = param_854."!protoregex"("scope_declarator")
    .return ($P855)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303603603.711")
    .param pmc param_857
.annotate 'line', 393
    .lex "self", param_857
    $P858 = param_857."!PREFIX__!protoregex"("scope_declarator")
    .return ($P858)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx860_tgt
    .local int rx860_pos
    .local int rx860_off
    .local int rx860_eos
    .local int rx860_rep
    .local pmc rx860_cur
    .local pmc rx860_debug
    (rx860_cur, rx860_pos, rx860_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx860_cur
    .local pmc match
    .lex "$/", match
    length rx860_eos, rx860_tgt
    gt rx860_pos, rx860_eos, rx860_done
    set rx860_off, 0
    lt rx860_pos, 2, rx860_start
    sub rx860_off, rx860_pos, 1
    substr rx860_tgt, rx860_tgt, rx860_off
  rx860_start:
    eq $I10, 1, rx860_restart
    if_null rx860_debug, debug_979
    rx860_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan864_done
    goto rxscan864_scan
  rxscan864_loop:
    (rx860_pos) = rx860_cur."from"()
    inc rx860_pos
    rx860_cur."!cursor_from"(rx860_pos)
    ge rx860_pos, rx860_eos, rxscan864_done
  rxscan864_scan:
    set_addr $I10, rxscan864_loop
    rx860_cur."!mark_push"(0, rx860_pos, $I10)
  rxscan864_done:
.annotate 'line', 394
  # rx subcapture "sym"
    set_addr $I10, rxcap_865_fail
    rx860_cur."!mark_push"(0, rx860_pos, $I10)
  # rx literal  "my"
    add $I11, rx860_pos, 2
    gt $I11, rx860_eos, rx860_fail
    sub $I11, rx860_pos, rx860_off
    substr $S10, rx860_tgt, $I11, 2
    ne $S10, "my", rx860_fail
    add rx860_pos, 2
    set_addr $I10, rxcap_865_fail
    ($I12, $I11) = rx860_cur."!mark_peek"($I10)
    rx860_cur."!cursor_pos"($I11)
    ($P10) = rx860_cur."!cursor_start"()
    $P10."!cursor_pass"(rx860_pos, "")
    rx860_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_865_done
  rxcap_865_fail:
    goto rx860_fail
  rxcap_865_done:
  # rx subrule "scoped" subtype=capture negate=
    rx860_cur."!cursor_pos"(rx860_pos)
    $P10 = rx860_cur."scoped"("my")
    unless $P10, rx860_fail
    rx860_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx860_pos = $P10."pos"()
  # rx pass
    rx860_cur."!cursor_pass"(rx860_pos, "scope_declarator:sym<my>")
    if_null rx860_debug, debug_980
    rx860_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx860_pos)
  debug_980:
    .return (rx860_cur)
  rx860_restart:
.annotate 'line', 10
    if_null rx860_debug, debug_981
    rx860_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_981:
  rx860_fail:
    (rx860_rep, rx860_pos, $I10, $P10) = rx860_cur."!mark_fail"(0)
    lt rx860_pos, -1, rx860_done
    eq rx860_pos, -1, rx860_fail
    jump $I10
  rx860_done:
    rx860_cur."!cursor_fail"()
    if_null rx860_debug, debug_982
    rx860_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_982:
    .return (rx860_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303603603.711") :method
.annotate 'line', 10
    $P862 = self."!PREFIX__!subrule"("scoped", "my")
    new $P863, "ResizablePMCArray"
    push $P863, $P862
    .return ($P863)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx867_tgt
    .local int rx867_pos
    .local int rx867_off
    .local int rx867_eos
    .local int rx867_rep
    .local pmc rx867_cur
    .local pmc rx867_debug
    (rx867_cur, rx867_pos, rx867_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx867_cur
    .local pmc match
    .lex "$/", match
    length rx867_eos, rx867_tgt
    gt rx867_pos, rx867_eos, rx867_done
    set rx867_off, 0
    lt rx867_pos, 2, rx867_start
    sub rx867_off, rx867_pos, 1
    substr rx867_tgt, rx867_tgt, rx867_off
  rx867_start:
    eq $I10, 1, rx867_restart
    if_null rx867_debug, debug_983
    rx867_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan871_done
    goto rxscan871_scan
  rxscan871_loop:
    (rx867_pos) = rx867_cur."from"()
    inc rx867_pos
    rx867_cur."!cursor_from"(rx867_pos)
    ge rx867_pos, rx867_eos, rxscan871_done
  rxscan871_scan:
    set_addr $I10, rxscan871_loop
    rx867_cur."!mark_push"(0, rx867_pos, $I10)
  rxscan871_done:
.annotate 'line', 395
  # rx subcapture "sym"
    set_addr $I10, rxcap_872_fail
    rx867_cur."!mark_push"(0, rx867_pos, $I10)
  # rx literal  "our"
    add $I11, rx867_pos, 3
    gt $I11, rx867_eos, rx867_fail
    sub $I11, rx867_pos, rx867_off
    substr $S10, rx867_tgt, $I11, 3
    ne $S10, "our", rx867_fail
    add rx867_pos, 3
    set_addr $I10, rxcap_872_fail
    ($I12, $I11) = rx867_cur."!mark_peek"($I10)
    rx867_cur."!cursor_pos"($I11)
    ($P10) = rx867_cur."!cursor_start"()
    $P10."!cursor_pass"(rx867_pos, "")
    rx867_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_872_done
  rxcap_872_fail:
    goto rx867_fail
  rxcap_872_done:
  # rx subrule "scoped" subtype=capture negate=
    rx867_cur."!cursor_pos"(rx867_pos)
    $P10 = rx867_cur."scoped"("our")
    unless $P10, rx867_fail
    rx867_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx867_pos = $P10."pos"()
  # rx pass
    rx867_cur."!cursor_pass"(rx867_pos, "scope_declarator:sym<our>")
    if_null rx867_debug, debug_984
    rx867_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx867_pos)
  debug_984:
    .return (rx867_cur)
  rx867_restart:
.annotate 'line', 10
    if_null rx867_debug, debug_985
    rx867_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_985:
  rx867_fail:
    (rx867_rep, rx867_pos, $I10, $P10) = rx867_cur."!mark_fail"(0)
    lt rx867_pos, -1, rx867_done
    eq rx867_pos, -1, rx867_fail
    jump $I10
  rx867_done:
    rx867_cur."!cursor_fail"()
    if_null rx867_debug, debug_986
    rx867_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_986:
    .return (rx867_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303603603.711") :method
.annotate 'line', 10
    $P869 = self."!PREFIX__!subrule"("scoped", "our")
    new $P870, "ResizablePMCArray"
    push $P870, $P869
    .return ($P870)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx874_tgt
    .local int rx874_pos
    .local int rx874_off
    .local int rx874_eos
    .local int rx874_rep
    .local pmc rx874_cur
    .local pmc rx874_debug
    (rx874_cur, rx874_pos, rx874_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx874_cur
    .local pmc match
    .lex "$/", match
    length rx874_eos, rx874_tgt
    gt rx874_pos, rx874_eos, rx874_done
    set rx874_off, 0
    lt rx874_pos, 2, rx874_start
    sub rx874_off, rx874_pos, 1
    substr rx874_tgt, rx874_tgt, rx874_off
  rx874_start:
    eq $I10, 1, rx874_restart
    if_null rx874_debug, debug_987
    rx874_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan878_done
    goto rxscan878_scan
  rxscan878_loop:
    (rx874_pos) = rx874_cur."from"()
    inc rx874_pos
    rx874_cur."!cursor_from"(rx874_pos)
    ge rx874_pos, rx874_eos, rxscan878_done
  rxscan878_scan:
    set_addr $I10, rxscan878_loop
    rx874_cur."!mark_push"(0, rx874_pos, $I10)
  rxscan878_done:
.annotate 'line', 396
  # rx subcapture "sym"
    set_addr $I10, rxcap_879_fail
    rx874_cur."!mark_push"(0, rx874_pos, $I10)
  # rx literal  "has"
    add $I11, rx874_pos, 3
    gt $I11, rx874_eos, rx874_fail
    sub $I11, rx874_pos, rx874_off
    substr $S10, rx874_tgt, $I11, 3
    ne $S10, "has", rx874_fail
    add rx874_pos, 3
    set_addr $I10, rxcap_879_fail
    ($I12, $I11) = rx874_cur."!mark_peek"($I10)
    rx874_cur."!cursor_pos"($I11)
    ($P10) = rx874_cur."!cursor_start"()
    $P10."!cursor_pass"(rx874_pos, "")
    rx874_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_879_done
  rxcap_879_fail:
    goto rx874_fail
  rxcap_879_done:
  # rx subrule "scoped" subtype=capture negate=
    rx874_cur."!cursor_pos"(rx874_pos)
    $P10 = rx874_cur."scoped"("has")
    unless $P10, rx874_fail
    rx874_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx874_pos = $P10."pos"()
  # rx pass
    rx874_cur."!cursor_pass"(rx874_pos, "scope_declarator:sym<has>")
    if_null rx874_debug, debug_988
    rx874_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx874_pos)
  debug_988:
    .return (rx874_cur)
  rx874_restart:
.annotate 'line', 10
    if_null rx874_debug, debug_989
    rx874_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_989:
  rx874_fail:
    (rx874_rep, rx874_pos, $I10, $P10) = rx874_cur."!mark_fail"(0)
    lt rx874_pos, -1, rx874_done
    eq rx874_pos, -1, rx874_fail
    jump $I10
  rx874_done:
    rx874_cur."!cursor_fail"()
    if_null rx874_debug, debug_990
    rx874_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_990:
    .return (rx874_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303603603.711") :method
.annotate 'line', 10
    $P876 = self."!PREFIX__!subrule"("scoped", "has")
    new $P877, "ResizablePMCArray"
    push $P877, $P876
    .return ($P877)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303603603.711") :method :outer("12_1303603603.711")
    .param pmc param_881
.annotate 'line', 398
    .lex "$*SCOPE", param_881
.annotate 'line', 10
    .local string rx882_tgt
    .local int rx882_pos
    .local int rx882_off
    .local int rx882_eos
    .local int rx882_rep
    .local pmc rx882_cur
    .local pmc rx882_debug
    (rx882_cur, rx882_pos, rx882_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx882_cur
    .local pmc match
    .lex "$/", match
    length rx882_eos, rx882_tgt
    gt rx882_pos, rx882_eos, rx882_done
    set rx882_off, 0
    lt rx882_pos, 2, rx882_start
    sub rx882_off, rx882_pos, 1
    substr rx882_tgt, rx882_tgt, rx882_off
  rx882_start:
    eq $I10, 1, rx882_restart
    if_null rx882_debug, debug_991
    rx882_cur."!cursor_debug"("START", "scoped")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan888_done
    goto rxscan888_scan
  rxscan888_loop:
    (rx882_pos) = rx882_cur."from"()
    inc rx882_pos
    rx882_cur."!cursor_from"(rx882_pos)
    ge rx882_pos, rx882_eos, rxscan888_done
  rxscan888_scan:
    set_addr $I10, rxscan888_loop
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  rxscan888_done:
  alt889_0:
.annotate 'line', 398
    set_addr $I10, alt889_1
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
.annotate 'line', 399
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."declarator"()
    unless $P10, rx882_fail
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
    goto alt889_end
  alt889_1:
    set_addr $I10, alt889_2
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
.annotate 'line', 400
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."multi_declarator"()
    unless $P10, rx882_fail
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
    goto alt889_end
  alt889_2:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."package_declarator"()
    unless $P10, rx882_fail
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx882_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."ws"()
    unless $P10, rx882_fail
    rx882_pos = $P10."pos"()
  alt889_end:
.annotate 'line', 398
  # rx pass
    rx882_cur."!cursor_pass"(rx882_pos, "scoped")
    if_null rx882_debug, debug_992
    rx882_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx882_pos)
  debug_992:
    .return (rx882_cur)
  rx882_restart:
.annotate 'line', 10
    if_null rx882_debug, debug_993
    rx882_cur."!cursor_debug"("NEXT", "scoped")
  debug_993:
  rx882_fail:
    (rx882_rep, rx882_pos, $I10, $P10) = rx882_cur."!mark_fail"(0)
    lt rx882_pos, -1, rx882_done
    eq rx882_pos, -1, rx882_fail
    jump $I10
  rx882_done:
    rx882_cur."!cursor_fail"()
    if_null rx882_debug, debug_994
    rx882_cur."!cursor_debug"("FAIL", "scoped")
  debug_994:
    .return (rx882_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303603603.711") :method
.annotate 'line', 10
    $P884 = self."!PREFIX__!subrule"("ws", "")
    $P885 = self."!PREFIX__!subrule"("ws", "")
    $P886 = self."!PREFIX__!subrule"("ws", "")
    new $P887, "ResizablePMCArray"
    push $P887, $P884
    push $P887, $P885
    push $P887, $P886
    .return ($P887)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx897_tgt
    .local int rx897_pos
    .local int rx897_off
    .local int rx897_eos
    .local int rx897_rep
    .local pmc rx897_cur
    .local pmc rx897_debug
    (rx897_cur, rx897_pos, rx897_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx897_cur
    .local pmc match
    .lex "$/", match
    length rx897_eos, rx897_tgt
    gt rx897_pos, rx897_eos, rx897_done
    set rx897_off, 0
    lt rx897_pos, 2, rx897_start
    sub rx897_off, rx897_pos, 1
    substr rx897_tgt, rx897_tgt, rx897_off
  rx897_start:
    eq $I10, 1, rx897_restart
    if_null rx897_debug, debug_995
    rx897_cur."!cursor_debug"("START", "typename")
  debug_995:
    $I10 = self.'from'()
    ne $I10, -1, rxscan901_done
    goto rxscan901_scan
  rxscan901_loop:
    (rx897_pos) = rx897_cur."from"()
    inc rx897_pos
    rx897_cur."!cursor_from"(rx897_pos)
    ge rx897_pos, rx897_eos, rxscan901_done
  rxscan901_scan:
    set_addr $I10, rxscan901_loop
    rx897_cur."!mark_push"(0, rx897_pos, $I10)
  rxscan901_done:
.annotate 'line', 404
  # rx subrule "name" subtype=capture negate=
    rx897_cur."!cursor_pos"(rx897_pos)
    $P10 = rx897_cur."name"()
    unless $P10, rx897_fail
    rx897_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx897_pos = $P10."pos"()
  # rx pass
    rx897_cur."!cursor_pass"(rx897_pos, "typename")
    if_null rx897_debug, debug_996
    rx897_cur."!cursor_debug"("PASS", "typename", " at pos=", rx897_pos)
  debug_996:
    .return (rx897_cur)
  rx897_restart:
.annotate 'line', 10
    if_null rx897_debug, debug_997
    rx897_cur."!cursor_debug"("NEXT", "typename")
  debug_997:
  rx897_fail:
    (rx897_rep, rx897_pos, $I10, $P10) = rx897_cur."!mark_fail"(0)
    lt rx897_pos, -1, rx897_done
    eq rx897_pos, -1, rx897_fail
    jump $I10
  rx897_done:
    rx897_cur."!cursor_fail"()
    if_null rx897_debug, debug_998
    rx897_cur."!cursor_debug"("FAIL", "typename")
  debug_998:
    .return (rx897_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303603603.711") :method
.annotate 'line', 10
    $P899 = self."!PREFIX__!subrule"("name", "")
    new $P900, "ResizablePMCArray"
    push $P900, $P899
    .return ($P900)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx903_tgt
    .local int rx903_pos
    .local int rx903_off
    .local int rx903_eos
    .local int rx903_rep
    .local pmc rx903_cur
    .local pmc rx903_debug
    (rx903_cur, rx903_pos, rx903_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx903_cur
    .local pmc match
    .lex "$/", match
    length rx903_eos, rx903_tgt
    gt rx903_pos, rx903_eos, rx903_done
    set rx903_off, 0
    lt rx903_pos, 2, rx903_start
    sub rx903_off, rx903_pos, 1
    substr rx903_tgt, rx903_tgt, rx903_off
  rx903_start:
    eq $I10, 1, rx903_restart
    if_null rx903_debug, debug_999
    rx903_cur."!cursor_debug"("START", "declarator")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan908_done
    goto rxscan908_scan
  rxscan908_loop:
    (rx903_pos) = rx903_cur."from"()
    inc rx903_pos
    rx903_cur."!cursor_from"(rx903_pos)
    ge rx903_pos, rx903_eos, rxscan908_done
  rxscan908_scan:
    set_addr $I10, rxscan908_loop
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxscan908_done:
  alt909_0:
.annotate 'line', 406
    set_addr $I10, alt909_1
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
.annotate 'line', 407
  # rx subrule "variable_declarator" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."variable_declarator"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx903_pos = $P10."pos"()
    goto alt909_end
  alt909_1:
.annotate 'line', 408
  # rx subrule "routine_declarator" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."routine_declarator"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx903_pos = $P10."pos"()
  alt909_end:
.annotate 'line', 406
  # rx pass
    rx903_cur."!cursor_pass"(rx903_pos, "declarator")
    if_null rx903_debug, debug_1000
    rx903_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx903_pos)
  debug_1000:
    .return (rx903_cur)
  rx903_restart:
.annotate 'line', 10
    if_null rx903_debug, debug_1001
    rx903_cur."!cursor_debug"("NEXT", "declarator")
  debug_1001:
  rx903_fail:
    (rx903_rep, rx903_pos, $I10, $P10) = rx903_cur."!mark_fail"(0)
    lt rx903_pos, -1, rx903_done
    eq rx903_pos, -1, rx903_fail
    jump $I10
  rx903_done:
    rx903_cur."!cursor_fail"()
    if_null rx903_debug, debug_1002
    rx903_cur."!cursor_debug"("FAIL", "declarator")
  debug_1002:
    .return (rx903_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303603603.711") :method
.annotate 'line', 10
    $P905 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P906 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P907, "ResizablePMCArray"
    push $P907, $P905
    push $P907, $P906
    .return ($P907)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx911_tgt
    .local int rx911_pos
    .local int rx911_off
    .local int rx911_eos
    .local int rx911_rep
    .local pmc rx911_cur
    .local pmc rx911_debug
    (rx911_cur, rx911_pos, rx911_tgt, $I10) = self."!cursor_start"()
    rx911_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx911_cur
    .local pmc match
    .lex "$/", match
    length rx911_eos, rx911_tgt
    gt rx911_pos, rx911_eos, rx911_done
    set rx911_off, 0
    lt rx911_pos, 2, rx911_start
    sub rx911_off, rx911_pos, 1
    substr rx911_tgt, rx911_tgt, rx911_off
  rx911_start:
    eq $I10, 1, rx911_restart
    if_null rx911_debug, debug_1003
    rx911_cur."!cursor_debug"("START", "variable_declarator")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan915_done
    goto rxscan915_scan
  rxscan915_loop:
    (rx911_pos) = rx911_cur."from"()
    inc rx911_pos
    rx911_cur."!cursor_from"(rx911_pos)
    ge rx911_pos, rx911_eos, rxscan915_done
  rxscan915_scan:
    set_addr $I10, rxscan915_loop
    rx911_cur."!mark_push"(0, rx911_pos, $I10)
  rxscan915_done:
.annotate 'line', 411
  # rx subrule "ws" subtype=method negate=
    rx911_cur."!cursor_pos"(rx911_pos)
    $P10 = rx911_cur."ws"()
    unless $P10, rx911_fail
    rx911_pos = $P10."pos"()
  # rx rxquantr917 ** 0..1
    set_addr $I10, rxquantr917_done
    rx911_cur."!mark_push"(0, rx911_pos, $I10)
  rxquantr917_loop:
  # rx subrule "typename" subtype=capture negate=
    rx911_cur."!cursor_pos"(rx911_pos)
    $P10 = rx911_cur."typename"()
    unless $P10, rx911_fail
    goto rxsubrule918_pass
  rxsubrule918_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx911_fail
  rxsubrule918_pass:
    set_addr $I10, rxsubrule918_back
    rx911_cur."!mark_push"(0, rx911_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx911_pos = $P10."pos"()
    set_addr $I10, rxquantr917_done
    (rx911_rep) = rx911_cur."!mark_commit"($I10)
  rxquantr917_done:
  # rx subrule "ws" subtype=method negate=
    rx911_cur."!cursor_pos"(rx911_pos)
    $P10 = rx911_cur."ws"()
    unless $P10, rx911_fail
    rx911_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx911_cur."!cursor_pos"(rx911_pos)
    $P10 = rx911_cur."variable"()
    unless $P10, rx911_fail
    rx911_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx911_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx911_cur."!cursor_pos"(rx911_pos)
    $P10 = rx911_cur."ws"()
    unless $P10, rx911_fail
    rx911_pos = $P10."pos"()
  # rx pass
    rx911_cur."!cursor_pass"(rx911_pos, "variable_declarator")
    if_null rx911_debug, debug_1004
    rx911_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx911_pos)
  debug_1004:
    .return (rx911_cur)
  rx911_restart:
.annotate 'line', 10
    if_null rx911_debug, debug_1005
    rx911_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1005:
  rx911_fail:
    (rx911_rep, rx911_pos, $I10, $P10) = rx911_cur."!mark_fail"(0)
    lt rx911_pos, -1, rx911_done
    eq rx911_pos, -1, rx911_fail
    jump $I10
  rx911_done:
    rx911_cur."!cursor_fail"()
    if_null rx911_debug, debug_1006
    rx911_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1006:
    .return (rx911_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303603603.711") :method
.annotate 'line', 10
    $P913 = self."!PREFIX__!subrule"("ws", "")
    new $P914, "ResizablePMCArray"
    push $P914, $P913
    .return ($P914)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("171_1303603603.711")
    .param pmc param_922
.annotate 'line', 413
    .lex "self", param_922
    $P923 = param_922."!protoregex"("routine_declarator")
    .return ($P923)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("172_1303603603.711")
    .param pmc param_925
.annotate 'line', 413
    .lex "self", param_925
    $P926 = param_925."!PREFIX__!protoregex"("routine_declarator")
    .return ($P926)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("173_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx928_tgt
    .local int rx928_pos
    .local int rx928_off
    .local int rx928_eos
    .local int rx928_rep
    .local pmc rx928_cur
    .local pmc rx928_debug
    (rx928_cur, rx928_pos, rx928_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx928_cur
    .local pmc match
    .lex "$/", match
    length rx928_eos, rx928_tgt
    gt rx928_pos, rx928_eos, rx928_done
    set rx928_off, 0
    lt rx928_pos, 2, rx928_start
    sub rx928_off, rx928_pos, 1
    substr rx928_tgt, rx928_tgt, rx928_off
  rx928_start:
    eq $I10, 1, rx928_restart
    if_null rx928_debug, debug_1007
    rx928_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan932_done
    goto rxscan932_scan
  rxscan932_loop:
    (rx928_pos) = rx928_cur."from"()
    inc rx928_pos
    rx928_cur."!cursor_from"(rx928_pos)
    ge rx928_pos, rx928_eos, rxscan932_done
  rxscan932_scan:
    set_addr $I10, rxscan932_loop
    rx928_cur."!mark_push"(0, rx928_pos, $I10)
  rxscan932_done:
.annotate 'line', 414
  # rx subcapture "sym"
    set_addr $I10, rxcap_933_fail
    rx928_cur."!mark_push"(0, rx928_pos, $I10)
  # rx literal  "sub"
    add $I11, rx928_pos, 3
    gt $I11, rx928_eos, rx928_fail
    sub $I11, rx928_pos, rx928_off
    substr $S10, rx928_tgt, $I11, 3
    ne $S10, "sub", rx928_fail
    add rx928_pos, 3
    set_addr $I10, rxcap_933_fail
    ($I12, $I11) = rx928_cur."!mark_peek"($I10)
    rx928_cur."!cursor_pos"($I11)
    ($P10) = rx928_cur."!cursor_start"()
    $P10."!cursor_pass"(rx928_pos, "")
    rx928_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_933_done
  rxcap_933_fail:
    goto rx928_fail
  rxcap_933_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx928_cur."!cursor_pos"(rx928_pos)
    $P10 = rx928_cur."routine_def"()
    unless $P10, rx928_fail
    rx928_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx928_pos = $P10."pos"()
  # rx pass
    rx928_cur."!cursor_pass"(rx928_pos, "routine_declarator:sym<sub>")
    if_null rx928_debug, debug_1008
    rx928_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx928_pos)
  debug_1008:
    .return (rx928_cur)
  rx928_restart:
.annotate 'line', 10
    if_null rx928_debug, debug_1009
    rx928_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1009:
  rx928_fail:
    (rx928_rep, rx928_pos, $I10, $P10) = rx928_cur."!mark_fail"(0)
    lt rx928_pos, -1, rx928_done
    eq rx928_pos, -1, rx928_fail
    jump $I10
  rx928_done:
    rx928_cur."!cursor_fail"()
    if_null rx928_debug, debug_1010
    rx928_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1010:
    .return (rx928_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("174_1303603603.711") :method
.annotate 'line', 10
    $P930 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P931, "ResizablePMCArray"
    push $P931, $P930
    .return ($P931)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("175_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx935_tgt
    .local int rx935_pos
    .local int rx935_off
    .local int rx935_eos
    .local int rx935_rep
    .local pmc rx935_cur
    .local pmc rx935_debug
    (rx935_cur, rx935_pos, rx935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx935_cur
    .local pmc match
    .lex "$/", match
    length rx935_eos, rx935_tgt
    gt rx935_pos, rx935_eos, rx935_done
    set rx935_off, 0
    lt rx935_pos, 2, rx935_start
    sub rx935_off, rx935_pos, 1
    substr rx935_tgt, rx935_tgt, rx935_off
  rx935_start:
    eq $I10, 1, rx935_restart
    if_null rx935_debug, debug_1011
    rx935_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1011:
    $I10 = self.'from'()
    ne $I10, -1, rxscan939_done
    goto rxscan939_scan
  rxscan939_loop:
    (rx935_pos) = rx935_cur."from"()
    inc rx935_pos
    rx935_cur."!cursor_from"(rx935_pos)
    ge rx935_pos, rx935_eos, rxscan939_done
  rxscan939_scan:
    set_addr $I10, rxscan939_loop
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  rxscan939_done:
.annotate 'line', 415
  # rx subcapture "sym"
    set_addr $I10, rxcap_940_fail
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx literal  "method"
    add $I11, rx935_pos, 6
    gt $I11, rx935_eos, rx935_fail
    sub $I11, rx935_pos, rx935_off
    substr $S10, rx935_tgt, $I11, 6
    ne $S10, "method", rx935_fail
    add rx935_pos, 6
    set_addr $I10, rxcap_940_fail
    ($I12, $I11) = rx935_cur."!mark_peek"($I10)
    rx935_cur."!cursor_pos"($I11)
    ($P10) = rx935_cur."!cursor_start"()
    $P10."!cursor_pass"(rx935_pos, "")
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_940_done
  rxcap_940_fail:
    goto rx935_fail
  rxcap_940_done:
  # rx subrule "method_def" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."method_def"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx935_pos = $P10."pos"()
  # rx pass
    rx935_cur."!cursor_pass"(rx935_pos, "routine_declarator:sym<method>")
    if_null rx935_debug, debug_1012
    rx935_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx935_pos)
  debug_1012:
    .return (rx935_cur)
  rx935_restart:
.annotate 'line', 10
    if_null rx935_debug, debug_1013
    rx935_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1013:
  rx935_fail:
    (rx935_rep, rx935_pos, $I10, $P10) = rx935_cur."!mark_fail"(0)
    lt rx935_pos, -1, rx935_done
    eq rx935_pos, -1, rx935_fail
    jump $I10
  rx935_done:
    rx935_cur."!cursor_fail"()
    if_null rx935_debug, debug_1014
    rx935_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1014:
    .return (rx935_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("176_1303603603.711") :method
.annotate 'line', 10
    $P937 = self."!PREFIX__!subrule"("method_def", "method")
    new $P938, "ResizablePMCArray"
    push $P938, $P937
    .return ($P938)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("177_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 418
    new $P942, "Undef"
    .lex "$*RETURN_USED", $P942
.annotate 'line', 10
    .local string rx943_tgt
    .local int rx943_pos
    .local int rx943_off
    .local int rx943_eos
    .local int rx943_rep
    .local pmc rx943_cur
    .local pmc rx943_debug
    (rx943_cur, rx943_pos, rx943_tgt, $I10) = self."!cursor_start"()
    rx943_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx943_cur
    .local pmc match
    .lex "$/", match
    length rx943_eos, rx943_tgt
    gt rx943_pos, rx943_eos, rx943_done
    set rx943_off, 0
    lt rx943_pos, 2, rx943_start
    sub rx943_off, rx943_pos, 1
    substr rx943_tgt, rx943_tgt, rx943_off
  rx943_start:
    eq $I10, 1, rx943_restart
    if_null rx943_debug, debug_1015
    rx943_cur."!cursor_debug"("START", "routine_def")
  debug_1015:
    $I10 = self.'from'()
    ne $I10, -1, rxscan947_done
    goto rxscan947_scan
  rxscan947_loop:
    (rx943_pos) = rx943_cur."from"()
    inc rx943_pos
    rx943_cur."!cursor_from"(rx943_pos)
    ge rx943_pos, rx943_eos, rxscan947_done
  rxscan947_scan:
    set_addr $I10, rxscan947_loop
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
  rxscan947_done:
.annotate 'line', 417
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
.annotate 'line', 418
    rx943_cur."!cursor_pos"(rx943_pos)
    new $P949, "Integer"
    assign $P949, 0
    store_lex "$*RETURN_USED", $P949
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
.annotate 'line', 419
  # rx rxquantr951 ** 0..1
    set_addr $I10, rxquantr951_done
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
  rxquantr951_loop:
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_954_fail
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
  # rx rxquantr953 ** 0..1
    set_addr $I10, rxquantr953_done
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
  rxquantr953_loop:
  # rx literal  "&"
    add $I11, rx943_pos, 1
    gt $I11, rx943_eos, rx943_fail
    sub $I11, rx943_pos, rx943_off
    ord $I11, rx943_tgt, $I11
    ne $I11, 38, rx943_fail
    add rx943_pos, 1
    set_addr $I10, rxquantr953_done
    (rx943_rep) = rx943_cur."!mark_commit"($I10)
  rxquantr953_done:
    set_addr $I10, rxcap_954_fail
    ($I12, $I11) = rx943_cur."!mark_peek"($I10)
    rx943_cur."!cursor_pos"($I11)
    ($P10) = rx943_cur."!cursor_start"()
    $P10."!cursor_pass"(rx943_pos, "")
    rx943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_954_done
  rxcap_954_fail:
    goto rx943_fail
  rxcap_954_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."deflongname"()
    unless $P10, rx943_fail
    rx943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx943_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
    set_addr $I10, rxquantr951_done
    (rx943_rep) = rx943_cur."!mark_commit"($I10)
  rxquantr951_done:
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
.annotate 'line', 420
  # rx subrule "newpad" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."newpad"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  alt958_0:
.annotate 'line', 421
    set_addr $I10, alt958_1
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx943_pos, 1
    gt $I11, rx943_eos, rx943_fail
    sub $I11, rx943_pos, rx943_off
    ord $I11, rx943_tgt, $I11
    ne $I11, 40, rx943_fail
    add rx943_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."signature"()
    unless $P10, rx943_fail
    rx943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx943_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx943_pos, 1
    gt $I11, rx943_eos, rx943_fail
    sub $I11, rx943_pos, rx943_off
    ord $I11, rx943_tgt, $I11
    ne $I11, 41, rx943_fail
    add rx943_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
    goto alt958_end
  alt958_1:
.annotate 'line', 422
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  alt958_end:
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
.annotate 'line', 423
  # rx rxquantr966 ** 0..*
    set_addr $I10, rxquantr966_done
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
  rxquantr966_loop:
  # rx subrule "trait" subtype=capture negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."trait"()
    unless $P10, rx943_fail
    goto rxsubrule967_pass
  rxsubrule967_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx943_fail
  rxsubrule967_pass:
    set_addr $I10, rxsubrule967_back
    rx943_cur."!mark_push"(0, rx943_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx943_pos = $P10."pos"()
    set_addr $I10, rxquantr966_done
    (rx943_rep) = rx943_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr966_done
    rx943_cur."!mark_push"(rx943_rep, rx943_pos, $I10)
    goto rxquantr966_loop
  rxquantr966_done:
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  alt969_0:
.annotate 'line', 424
    set_addr $I10, alt969_1
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."onlystar"()
    unless $P10, rx943_fail
    rx943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx943_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
    goto alt969_end
  alt969_1:
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."blockoid"()
    unless $P10, rx943_fail
    rx943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx943_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  alt969_end:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
.annotate 'line', 417
  # rx pass
    rx943_cur."!cursor_pass"(rx943_pos, "routine_def")
    if_null rx943_debug, debug_1016
    rx943_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx943_pos)
  debug_1016:
    .return (rx943_cur)
  rx943_restart:
.annotate 'line', 10
    if_null rx943_debug, debug_1017
    rx943_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1017:
  rx943_fail:
    (rx943_rep, rx943_pos, $I10, $P10) = rx943_cur."!mark_fail"(0)
    lt rx943_pos, -1, rx943_done
    eq rx943_pos, -1, rx943_fail
    jump $I10
  rx943_done:
    rx943_cur."!cursor_fail"()
    if_null rx943_debug, debug_1018
    rx943_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1018:
    .return (rx943_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("178_1303603603.711") :method
.annotate 'line', 10
    $P945 = self."!PREFIX__!subrule"("ws", "")
    new $P946, "ResizablePMCArray"
    push $P946, $P945
    .return ($P946)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("179_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P1006 = "181_1303603603.711" 
    capture_lex $P1006
.annotate 'line', 431
    new $P976, "Undef"
    .lex "$*RETURN_USED", $P976
.annotate 'line', 432
    new $P977, "Undef"
    .lex "$*INVOCANT_OK", $P977
.annotate 'line', 10
    .local string rx978_tgt
    .local int rx978_pos
    .local int rx978_off
    .local int rx978_eos
    .local int rx978_rep
    .local pmc rx978_cur
    .local pmc rx978_debug
    (rx978_cur, rx978_pos, rx978_tgt, $I10) = self."!cursor_start"()
    rx978_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx978_cur
    .local pmc match
    .lex "$/", match
    length rx978_eos, rx978_tgt
    gt rx978_pos, rx978_eos, rx978_done
    set rx978_off, 0
    lt rx978_pos, 2, rx978_start
    sub rx978_off, rx978_pos, 1
    substr rx978_tgt, rx978_tgt, rx978_off
  rx978_start:
    eq $I10, 1, rx978_restart
    if_null rx978_debug, debug_1019
    rx978_cur."!cursor_debug"("START", "method_def")
  debug_1019:
    $I10 = self.'from'()
    ne $I10, -1, rxscan982_done
    goto rxscan982_scan
  rxscan982_loop:
    (rx978_pos) = rx978_cur."from"()
    inc rx978_pos
    rx978_cur."!cursor_from"(rx978_pos)
    ge rx978_pos, rx978_eos, rxscan982_done
  rxscan982_scan:
    set_addr $I10, rxscan982_loop
    rx978_cur."!mark_push"(0, rx978_pos, $I10)
  rxscan982_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
.annotate 'line', 431
    rx978_cur."!cursor_pos"(rx978_pos)
    new $P984, "Integer"
    assign $P984, 0
    store_lex "$*RETURN_USED", $P984
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
.annotate 'line', 432
    rx978_cur."!cursor_pos"(rx978_pos)
    new $P986, "Integer"
    assign $P986, 1
    store_lex "$*INVOCANT_OK", $P986
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
.annotate 'line', 433
  # rx subcapture "private"
    set_addr $I10, rxcap_989_fail
    rx978_cur."!mark_push"(0, rx978_pos, $I10)
  # rx rxquantr988 ** 0..1
    set_addr $I10, rxquantr988_done
    rx978_cur."!mark_push"(0, rx978_pos, $I10)
  rxquantr988_loop:
  # rx literal  "!"
    add $I11, rx978_pos, 1
    gt $I11, rx978_eos, rx978_fail
    sub $I11, rx978_pos, rx978_off
    ord $I11, rx978_tgt, $I11
    ne $I11, 33, rx978_fail
    add rx978_pos, 1
    set_addr $I10, rxquantr988_done
    (rx978_rep) = rx978_cur."!mark_commit"($I10)
  rxquantr988_done:
    set_addr $I10, rxcap_989_fail
    ($I12, $I11) = rx978_cur."!mark_peek"($I10)
    rx978_cur."!cursor_pos"($I11)
    ($P10) = rx978_cur."!cursor_start"()
    $P10."!cursor_pass"(rx978_pos, "")
    rx978_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_989_done
  rxcap_989_fail:
    goto rx978_fail
  rxcap_989_done:
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
.annotate 'line', 434
  # rx rxquantr991 ** 0..1
    set_addr $I10, rxquantr991_done
    rx978_cur."!mark_push"(0, rx978_pos, $I10)
  rxquantr991_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."deflongname"()
    unless $P10, rx978_fail
    goto rxsubrule992_pass
  rxsubrule992_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx978_fail
  rxsubrule992_pass:
    set_addr $I10, rxsubrule992_back
    rx978_cur."!mark_push"(0, rx978_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx978_pos = $P10."pos"()
    set_addr $I10, rxquantr991_done
    (rx978_rep) = rx978_cur."!mark_commit"($I10)
  rxquantr991_done:
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
.annotate 'line', 435
  # rx subrule "newpad" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."newpad"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  alt995_0:
.annotate 'line', 436
    set_addr $I10, alt995_1
    rx978_cur."!mark_push"(0, rx978_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx978_pos, 1
    gt $I11, rx978_eos, rx978_fail
    sub $I11, rx978_pos, rx978_off
    ord $I11, rx978_tgt, $I11
    ne $I11, 40, rx978_fail
    add rx978_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."signature"()
    unless $P10, rx978_fail
    rx978_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx978_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx978_pos, 1
    gt $I11, rx978_eos, rx978_fail
    sub $I11, rx978_pos, rx978_off
    ord $I11, rx978_tgt, $I11
    ne $I11, 41, rx978_fail
    add rx978_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
    goto alt995_end
  alt995_1:
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  alt995_end:
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
.annotate 'line', 438
    rx978_cur."!cursor_pos"(rx978_pos)
    find_lex $P1003, unicode:"$\x{a2}"
    $P1004 = $P1003."MATCH"()
    store_lex "$/", $P1004
    .const 'Sub' $P1006 = "181_1303603603.711" 
    capture_lex $P1006
    $P1008 = $P1006()
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
.annotate 'line', 439
  # rx rxquantr1010 ** 0..*
    set_addr $I10, rxquantr1010_done
    rx978_cur."!mark_push"(0, rx978_pos, $I10)
  rxquantr1010_loop:
  # rx subrule "trait" subtype=capture negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."trait"()
    unless $P10, rx978_fail
    goto rxsubrule1011_pass
  rxsubrule1011_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx978_fail
  rxsubrule1011_pass:
    set_addr $I10, rxsubrule1011_back
    rx978_cur."!mark_push"(0, rx978_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx978_pos = $P10."pos"()
    set_addr $I10, rxquantr1010_done
    (rx978_rep) = rx978_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1010_done
    rx978_cur."!mark_push"(rx978_rep, rx978_pos, $I10)
    goto rxquantr1010_loop
  rxquantr1010_done:
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  alt1013_0:
.annotate 'line', 440
    set_addr $I10, alt1013_1
    rx978_cur."!mark_push"(0, rx978_pos, $I10)
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."onlystar"()
    unless $P10, rx978_fail
    rx978_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx978_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
    goto alt1013_end
  alt1013_1:
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."blockoid"()
    unless $P10, rx978_fail
    rx978_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx978_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
  alt1013_end:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx978_cur."!cursor_pos"(rx978_pos)
    $P10 = rx978_cur."ws"()
    unless $P10, rx978_fail
    rx978_pos = $P10."pos"()
.annotate 'line', 430
  # rx pass
    rx978_cur."!cursor_pass"(rx978_pos, "method_def")
    if_null rx978_debug, debug_1020
    rx978_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx978_pos)
  debug_1020:
    .return (rx978_cur)
  rx978_restart:
.annotate 'line', 10
    if_null rx978_debug, debug_1021
    rx978_cur."!cursor_debug"("NEXT", "method_def")
  debug_1021:
  rx978_fail:
    (rx978_rep, rx978_pos, $I10, $P10) = rx978_cur."!mark_fail"(0)
    lt rx978_pos, -1, rx978_done
    eq rx978_pos, -1, rx978_fail
    jump $I10
  rx978_done:
    rx978_cur."!cursor_fail"()
    if_null rx978_debug, debug_1022
    rx978_cur."!cursor_debug"("FAIL", "method_def")
  debug_1022:
    .return (rx978_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("180_1303603603.711") :method
.annotate 'line', 10
    $P980 = self."!PREFIX__!subrule"("ws", "")
    new $P981, "ResizablePMCArray"
    push $P981, $P980
    .return ($P981)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1005"  :anon :subid("181_1303603603.711") :outer("179_1303603603.711")
.annotate 'line', 438
    new $P1007, "Integer"
    assign $P1007, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1007
    .return ($P1007)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("182_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P1027 = "184_1303603603.711" 
    capture_lex $P1027
    .local string rx1020_tgt
    .local int rx1020_pos
    .local int rx1020_off
    .local int rx1020_eos
    .local int rx1020_rep
    .local pmc rx1020_cur
    .local pmc rx1020_debug
    (rx1020_cur, rx1020_pos, rx1020_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1020_cur
    .local pmc match
    .lex "$/", match
    length rx1020_eos, rx1020_tgt
    gt rx1020_pos, rx1020_eos, rx1020_done
    set rx1020_off, 0
    lt rx1020_pos, 2, rx1020_start
    sub rx1020_off, rx1020_pos, 1
    substr rx1020_tgt, rx1020_tgt, rx1020_off
  rx1020_start:
    eq $I10, 1, rx1020_restart
    if_null rx1020_debug, debug_1023
    rx1020_cur."!cursor_debug"("START", "onlystar")
  debug_1023:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1023_done
    goto rxscan1023_scan
  rxscan1023_loop:
    (rx1020_pos) = rx1020_cur."from"()
    inc rx1020_pos
    rx1020_cur."!cursor_from"(rx1020_pos)
    ge rx1020_pos, rx1020_eos, rxscan1023_done
  rxscan1023_scan:
    set_addr $I10, rxscan1023_loop
    rx1020_cur."!mark_push"(0, rx1020_pos, $I10)
  rxscan1023_done:
.annotate 'line', 447
    rx1020_cur."!cursor_pos"(rx1020_pos)
    find_lex $P1024, unicode:"$\x{a2}"
    $P1025 = $P1024."MATCH"()
    store_lex "$/", $P1025
    .const 'Sub' $P1027 = "184_1303603603.711" 
    capture_lex $P1027
    $P1031 = $P1027()
    unless $P1031, rx1020_fail
.annotate 'line', 448
  # rx literal  "{"
    add $I11, rx1020_pos, 1
    gt $I11, rx1020_eos, rx1020_fail
    sub $I11, rx1020_pos, rx1020_off
    ord $I11, rx1020_tgt, $I11
    ne $I11, 123, rx1020_fail
    add rx1020_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1020_cur."!cursor_pos"(rx1020_pos)
    $P10 = rx1020_cur."ws"()
    unless $P10, rx1020_fail
    rx1020_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1020_pos, 1
    gt $I11, rx1020_eos, rx1020_fail
    sub $I11, rx1020_pos, rx1020_off
    ord $I11, rx1020_tgt, $I11
    ne $I11, 42, rx1020_fail
    add rx1020_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1020_cur."!cursor_pos"(rx1020_pos)
    $P10 = rx1020_cur."ws"()
    unless $P10, rx1020_fail
    rx1020_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1020_pos, 1
    gt $I11, rx1020_eos, rx1020_fail
    sub $I11, rx1020_pos, rx1020_off
    ord $I11, rx1020_tgt, $I11
    ne $I11, 125, rx1020_fail
    add rx1020_pos, 1
.annotate 'line', 449
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1020_cur."!cursor_pos"(rx1020_pos)
    $P10 = rx1020_cur."ENDSTMT"()
    unless $P10, rx1020_fail
.annotate 'line', 450
  # rx subrule "finishpad" subtype=method negate=
    rx1020_cur."!cursor_pos"(rx1020_pos)
    $P10 = rx1020_cur."finishpad"()
    unless $P10, rx1020_fail
    rx1020_pos = $P10."pos"()
.annotate 'line', 446
  # rx pass
    rx1020_cur."!cursor_pass"(rx1020_pos, "onlystar")
    if_null rx1020_debug, debug_1026
    rx1020_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1020_pos)
  debug_1026:
    .return (rx1020_cur)
  rx1020_restart:
.annotate 'line', 10
    if_null rx1020_debug, debug_1027
    rx1020_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1027:
  rx1020_fail:
    (rx1020_rep, rx1020_pos, $I10, $P10) = rx1020_cur."!mark_fail"(0)
    lt rx1020_pos, -1, rx1020_done
    eq rx1020_pos, -1, rx1020_fail
    jump $I10
  rx1020_done:
    rx1020_cur."!cursor_fail"()
    if_null rx1020_debug, debug_1028
    rx1020_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1028:
    .return (rx1020_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("183_1303603603.711") :method
.annotate 'line', 10
    new $P1022, "ResizablePMCArray"
    push $P1022, ""
    .return ($P1022)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1026"  :anon :subid("184_1303603603.711") :outer("182_1303603603.711")
.annotate 'line', 447
    find_dynamic_lex $P1028, "$*MULTINESS"
    unless_null $P1028, vivify_1024
    get_hll_global $P1028, "$MULTINESS"
    unless_null $P1028, vivify_1025
    die "Contextual $*MULTINESS not found"
  vivify_1025:
  vivify_1024:
    set $S1029, $P1028
    iseq $I1030, $S1029, "proto"
    .return ($I1030)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("185_1303603603.711")
    .param pmc param_1033
.annotate 'line', 453
    .lex "self", param_1033
    $P1034 = param_1033."!protoregex"("multi_declarator")
    .return ($P1034)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("186_1303603603.711")
    .param pmc param_1036
.annotate 'line', 453
    .lex "self", param_1036
    $P1037 = param_1036."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1037)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("187_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 455
    new $P1039, "Undef"
    .lex "$*MULTINESS", $P1039
.annotate 'line', 10
    .local string rx1040_tgt
    .local int rx1040_pos
    .local int rx1040_off
    .local int rx1040_eos
    .local int rx1040_rep
    .local pmc rx1040_cur
    .local pmc rx1040_debug
    (rx1040_cur, rx1040_pos, rx1040_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1040_cur
    .local pmc match
    .lex "$/", match
    length rx1040_eos, rx1040_tgt
    gt rx1040_pos, rx1040_eos, rx1040_done
    set rx1040_off, 0
    lt rx1040_pos, 2, rx1040_start
    sub rx1040_off, rx1040_pos, 1
    substr rx1040_tgt, rx1040_tgt, rx1040_off
  rx1040_start:
    eq $I10, 1, rx1040_restart
    if_null rx1040_debug, debug_1029
    rx1040_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1044_done
    goto rxscan1044_scan
  rxscan1044_loop:
    (rx1040_pos) = rx1040_cur."from"()
    inc rx1040_pos
    rx1040_cur."!cursor_from"(rx1040_pos)
    ge rx1040_pos, rx1040_eos, rxscan1044_done
  rxscan1044_scan:
    set_addr $I10, rxscan1044_loop
    rx1040_cur."!mark_push"(0, rx1040_pos, $I10)
  rxscan1044_done:
.annotate 'line', 455
    rx1040_cur."!cursor_pos"(rx1040_pos)
    new $P1045, "String"
    assign $P1045, "multi"
    store_lex "$*MULTINESS", $P1045
.annotate 'line', 456
  # rx subcapture "sym"
    set_addr $I10, rxcap_1046_fail
    rx1040_cur."!mark_push"(0, rx1040_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1040_pos, 5
    gt $I11, rx1040_eos, rx1040_fail
    sub $I11, rx1040_pos, rx1040_off
    substr $S10, rx1040_tgt, $I11, 5
    ne $S10, "multi", rx1040_fail
    add rx1040_pos, 5
    set_addr $I10, rxcap_1046_fail
    ($I12, $I11) = rx1040_cur."!mark_peek"($I10)
    rx1040_cur."!cursor_pos"($I11)
    ($P10) = rx1040_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1040_pos, "")
    rx1040_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1046_done
  rxcap_1046_fail:
    goto rx1040_fail
  rxcap_1046_done:
.annotate 'line', 457
  # rx subrule "ws" subtype=method negate=
    rx1040_cur."!cursor_pos"(rx1040_pos)
    $P10 = rx1040_cur."ws"()
    unless $P10, rx1040_fail
    rx1040_pos = $P10."pos"()
  alt1047_0:
    set_addr $I10, alt1047_1
    rx1040_cur."!mark_push"(0, rx1040_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1040_cur."!cursor_pos"(rx1040_pos)
    $P10 = rx1040_cur."declarator"()
    unless $P10, rx1040_fail
    rx1040_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1040_pos = $P10."pos"()
    goto alt1047_end
  alt1047_1:
    set_addr $I10, alt1047_2
    rx1040_cur."!mark_push"(0, rx1040_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1040_cur."!cursor_pos"(rx1040_pos)
    $P10 = rx1040_cur."routine_def"()
    unless $P10, rx1040_fail
    rx1040_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1040_pos = $P10."pos"()
    goto alt1047_end
  alt1047_2:
  # rx subrule "panic" subtype=method negate=
    rx1040_cur."!cursor_pos"(rx1040_pos)
    $P10 = rx1040_cur."panic"("Malformed multi")
    unless $P10, rx1040_fail
    rx1040_pos = $P10."pos"()
  alt1047_end:
.annotate 'line', 454
  # rx pass
    rx1040_cur."!cursor_pass"(rx1040_pos, "multi_declarator:sym<multi>")
    if_null rx1040_debug, debug_1030
    rx1040_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1040_pos)
  debug_1030:
    .return (rx1040_cur)
  rx1040_restart:
.annotate 'line', 10
    if_null rx1040_debug, debug_1031
    rx1040_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1031:
  rx1040_fail:
    (rx1040_rep, rx1040_pos, $I10, $P10) = rx1040_cur."!mark_fail"(0)
    lt rx1040_pos, -1, rx1040_done
    eq rx1040_pos, -1, rx1040_fail
    jump $I10
  rx1040_done:
    rx1040_cur."!cursor_fail"()
    if_null rx1040_debug, debug_1032
    rx1040_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1032:
    .return (rx1040_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("188_1303603603.711") :method
.annotate 'line', 10
    $P1042 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1043, "ResizablePMCArray"
    push $P1043, $P1042
    .return ($P1043)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("189_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 460
    new $P1049, "Undef"
    .lex "$*MULTINESS", $P1049
.annotate 'line', 10
    .local string rx1050_tgt
    .local int rx1050_pos
    .local int rx1050_off
    .local int rx1050_eos
    .local int rx1050_rep
    .local pmc rx1050_cur
    .local pmc rx1050_debug
    (rx1050_cur, rx1050_pos, rx1050_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1050_cur
    .local pmc match
    .lex "$/", match
    length rx1050_eos, rx1050_tgt
    gt rx1050_pos, rx1050_eos, rx1050_done
    set rx1050_off, 0
    lt rx1050_pos, 2, rx1050_start
    sub rx1050_off, rx1050_pos, 1
    substr rx1050_tgt, rx1050_tgt, rx1050_off
  rx1050_start:
    eq $I10, 1, rx1050_restart
    if_null rx1050_debug, debug_1033
    rx1050_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1054_done
    goto rxscan1054_scan
  rxscan1054_loop:
    (rx1050_pos) = rx1050_cur."from"()
    inc rx1050_pos
    rx1050_cur."!cursor_from"(rx1050_pos)
    ge rx1050_pos, rx1050_eos, rxscan1054_done
  rxscan1054_scan:
    set_addr $I10, rxscan1054_loop
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  rxscan1054_done:
.annotate 'line', 460
    rx1050_cur."!cursor_pos"(rx1050_pos)
    new $P1055, "String"
    assign $P1055, "proto"
    store_lex "$*MULTINESS", $P1055
.annotate 'line', 461
  # rx subcapture "sym"
    set_addr $I10, rxcap_1056_fail
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1050_pos, 5
    gt $I11, rx1050_eos, rx1050_fail
    sub $I11, rx1050_pos, rx1050_off
    substr $S10, rx1050_tgt, $I11, 5
    ne $S10, "proto", rx1050_fail
    add rx1050_pos, 5
    set_addr $I10, rxcap_1056_fail
    ($I12, $I11) = rx1050_cur."!mark_peek"($I10)
    rx1050_cur."!cursor_pos"($I11)
    ($P10) = rx1050_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1050_pos, "")
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1056_done
  rxcap_1056_fail:
    goto rx1050_fail
  rxcap_1056_done:
.annotate 'line', 462
  # rx subrule "ws" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."ws"()
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  alt1057_0:
    set_addr $I10, alt1057_1
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."declarator"()
    unless $P10, rx1050_fail
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1050_pos = $P10."pos"()
    goto alt1057_end
  alt1057_1:
    set_addr $I10, alt1057_2
    rx1050_cur."!mark_push"(0, rx1050_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."routine_def"()
    unless $P10, rx1050_fail
    rx1050_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1050_pos = $P10."pos"()
    goto alt1057_end
  alt1057_2:
  # rx subrule "panic" subtype=method negate=
    rx1050_cur."!cursor_pos"(rx1050_pos)
    $P10 = rx1050_cur."panic"("Malformed proto")
    unless $P10, rx1050_fail
    rx1050_pos = $P10."pos"()
  alt1057_end:
.annotate 'line', 459
  # rx pass
    rx1050_cur."!cursor_pass"(rx1050_pos, "multi_declarator:sym<proto>")
    if_null rx1050_debug, debug_1034
    rx1050_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1050_pos)
  debug_1034:
    .return (rx1050_cur)
  rx1050_restart:
.annotate 'line', 10
    if_null rx1050_debug, debug_1035
    rx1050_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1035:
  rx1050_fail:
    (rx1050_rep, rx1050_pos, $I10, $P10) = rx1050_cur."!mark_fail"(0)
    lt rx1050_pos, -1, rx1050_done
    eq rx1050_pos, -1, rx1050_fail
    jump $I10
  rx1050_done:
    rx1050_cur."!cursor_fail"()
    if_null rx1050_debug, debug_1036
    rx1050_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1036:
    .return (rx1050_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("190_1303603603.711") :method
.annotate 'line', 10
    $P1052 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1053, "ResizablePMCArray"
    push $P1053, $P1052
    .return ($P1053)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("191_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 465
    new $P1059, "Undef"
    .lex "$*MULTINESS", $P1059
.annotate 'line', 10
    .local string rx1060_tgt
    .local int rx1060_pos
    .local int rx1060_off
    .local int rx1060_eos
    .local int rx1060_rep
    .local pmc rx1060_cur
    .local pmc rx1060_debug
    (rx1060_cur, rx1060_pos, rx1060_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1060_cur
    .local pmc match
    .lex "$/", match
    length rx1060_eos, rx1060_tgt
    gt rx1060_pos, rx1060_eos, rx1060_done
    set rx1060_off, 0
    lt rx1060_pos, 2, rx1060_start
    sub rx1060_off, rx1060_pos, 1
    substr rx1060_tgt, rx1060_tgt, rx1060_off
  rx1060_start:
    eq $I10, 1, rx1060_restart
    if_null rx1060_debug, debug_1037
    rx1060_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1064_done
    goto rxscan1064_scan
  rxscan1064_loop:
    (rx1060_pos) = rx1060_cur."from"()
    inc rx1060_pos
    rx1060_cur."!cursor_from"(rx1060_pos)
    ge rx1060_pos, rx1060_eos, rxscan1064_done
  rxscan1064_scan:
    set_addr $I10, rxscan1064_loop
    rx1060_cur."!mark_push"(0, rx1060_pos, $I10)
  rxscan1064_done:
.annotate 'line', 465
    rx1060_cur."!cursor_pos"(rx1060_pos)
    new $P1065, "String"
    assign $P1065, ""
    store_lex "$*MULTINESS", $P1065
.annotate 'line', 466
  # rx subrule "declarator" subtype=capture negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."declarator"()
    unless $P10, rx1060_fail
    rx1060_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1060_pos = $P10."pos"()
.annotate 'line', 464
  # rx pass
    rx1060_cur."!cursor_pass"(rx1060_pos, "multi_declarator:sym<null>")
    if_null rx1060_debug, debug_1038
    rx1060_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1060_pos)
  debug_1038:
    .return (rx1060_cur)
  rx1060_restart:
.annotate 'line', 10
    if_null rx1060_debug, debug_1039
    rx1060_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1039:
  rx1060_fail:
    (rx1060_rep, rx1060_pos, $I10, $P10) = rx1060_cur."!mark_fail"(0)
    lt rx1060_pos, -1, rx1060_done
    eq rx1060_pos, -1, rx1060_fail
    jump $I10
  rx1060_done:
    rx1060_cur."!cursor_fail"()
    if_null rx1060_debug, debug_1040
    rx1060_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1040:
    .return (rx1060_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("192_1303603603.711") :method
.annotate 'line', 10
    $P1062 = self."!PREFIX__!subrule"("declarator", "")
    new $P1063, "ResizablePMCArray"
    push $P1063, $P1062
    .return ($P1063)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("193_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P1075 = "195_1303603603.711" 
    capture_lex $P1075
    .local string rx1067_tgt
    .local int rx1067_pos
    .local int rx1067_off
    .local int rx1067_eos
    .local int rx1067_rep
    .local pmc rx1067_cur
    .local pmc rx1067_debug
    (rx1067_cur, rx1067_pos, rx1067_tgt, $I10) = self."!cursor_start"()
    rx1067_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1067_cur
    .local pmc match
    .lex "$/", match
    length rx1067_eos, rx1067_tgt
    gt rx1067_pos, rx1067_eos, rx1067_done
    set rx1067_off, 0
    lt rx1067_pos, 2, rx1067_start
    sub rx1067_off, rx1067_pos, 1
    substr rx1067_tgt, rx1067_tgt, rx1067_off
  rx1067_start:
    eq $I10, 1, rx1067_restart
    if_null rx1067_debug, debug_1041
    rx1067_cur."!cursor_debug"("START", "signature")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1070_done
    goto rxscan1070_scan
  rxscan1070_loop:
    (rx1067_pos) = rx1067_cur."from"()
    inc rx1067_pos
    rx1067_cur."!cursor_from"(rx1067_pos)
    ge rx1067_pos, rx1067_eos, rxscan1070_done
  rxscan1070_scan:
    set_addr $I10, rxscan1070_loop
    rx1067_cur."!mark_push"(0, rx1067_pos, $I10)
  rxscan1070_done:
.annotate 'line', 470
  # rx rxquantr1071 ** 0..1
    set_addr $I10, rxquantr1071_done
    rx1067_cur."!mark_push"(0, rx1067_pos, $I10)
  rxquantr1071_loop:
    rx1067_cur."!cursor_pos"(rx1067_pos)
    find_lex $P1072, unicode:"$\x{a2}"
    $P1073 = $P1072."MATCH"()
    store_lex "$/", $P1073
    .const 'Sub' $P1075 = "195_1303603603.711" 
    capture_lex $P1075
    $P1077 = $P1075()
    unless $P1077, rx1067_fail
  # rx subrule "ws" subtype=method negate=
    rx1067_cur."!cursor_pos"(rx1067_pos)
    $P10 = rx1067_cur."ws"()
    unless $P10, rx1067_fail
    rx1067_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1067_cur."!cursor_pos"(rx1067_pos)
    $P10 = rx1067_cur."parameter"()
    unless $P10, rx1067_fail
    rx1067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1067_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1067_cur."!cursor_pos"(rx1067_pos)
    $P10 = rx1067_cur."ws"()
    unless $P10, rx1067_fail
    rx1067_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1067_pos, 1
    gt $I11, rx1067_eos, rx1067_fail
    sub $I11, rx1067_pos, rx1067_off
    ord $I11, rx1067_tgt, $I11
    ne $I11, 58, rx1067_fail
    add rx1067_pos, 1
    set_addr $I10, rxquantr1071_done
    (rx1067_rep) = rx1067_cur."!mark_commit"($I10)
  rxquantr1071_done:
.annotate 'line', 471
  # rx rxquantr1078 ** 0..1
    set_addr $I10, rxquantr1078_done
    rx1067_cur."!mark_push"(0, rx1067_pos, $I10)
  rxquantr1078_loop:
  # rx rxquantr1079 ** 1..*
    set_addr $I10, rxquantr1079_done
    rx1067_cur."!mark_push"(0, -1, $I10)
  rxquantr1079_loop:
  # rx subrule "ws" subtype=method negate=
    rx1067_cur."!cursor_pos"(rx1067_pos)
    $P10 = rx1067_cur."ws"()
    unless $P10, rx1067_fail
    rx1067_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1067_cur."!cursor_pos"(rx1067_pos)
    $P10 = rx1067_cur."parameter"()
    unless $P10, rx1067_fail
    rx1067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1067_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1067_cur."!cursor_pos"(rx1067_pos)
    $P10 = rx1067_cur."ws"()
    unless $P10, rx1067_fail
    rx1067_pos = $P10."pos"()
    set_addr $I10, rxquantr1079_done
    (rx1067_rep) = rx1067_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1079_done
    rx1067_cur."!mark_push"(rx1067_rep, rx1067_pos, $I10)
  # rx literal  ","
    add $I11, rx1067_pos, 1
    gt $I11, rx1067_eos, rx1067_fail
    sub $I11, rx1067_pos, rx1067_off
    ord $I11, rx1067_tgt, $I11
    ne $I11, 44, rx1067_fail
    add rx1067_pos, 1
    goto rxquantr1079_loop
  rxquantr1079_done:
    set_addr $I10, rxquantr1078_done
    (rx1067_rep) = rx1067_cur."!mark_commit"($I10)
  rxquantr1078_done:
.annotate 'line', 469
  # rx pass
    rx1067_cur."!cursor_pass"(rx1067_pos, "signature")
    if_null rx1067_debug, debug_1044
    rx1067_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1067_pos)
  debug_1044:
    .return (rx1067_cur)
  rx1067_restart:
.annotate 'line', 10
    if_null rx1067_debug, debug_1045
    rx1067_cur."!cursor_debug"("NEXT", "signature")
  debug_1045:
  rx1067_fail:
    (rx1067_rep, rx1067_pos, $I10, $P10) = rx1067_cur."!mark_fail"(0)
    lt rx1067_pos, -1, rx1067_done
    eq rx1067_pos, -1, rx1067_fail
    jump $I10
  rx1067_done:
    rx1067_cur."!cursor_fail"()
    if_null rx1067_debug, debug_1046
    rx1067_cur."!cursor_debug"("FAIL", "signature")
  debug_1046:
    .return (rx1067_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("194_1303603603.711") :method
.annotate 'line', 10
    new $P1069, "ResizablePMCArray"
    push $P1069, ""
    .return ($P1069)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1074"  :anon :subid("195_1303603603.711") :outer("193_1303603603.711")
.annotate 'line', 470
    find_dynamic_lex $P1076, "$*INVOCANT_OK"
    unless_null $P1076, vivify_1042
    get_hll_global $P1076, "$INVOCANT_OK"
    unless_null $P1076, vivify_1043
    die "Contextual $*INVOCANT_OK not found"
  vivify_1043:
  vivify_1042:
    .return ($P1076)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("196_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1081_tgt
    .local int rx1081_pos
    .local int rx1081_off
    .local int rx1081_eos
    .local int rx1081_rep
    .local pmc rx1081_cur
    .local pmc rx1081_debug
    (rx1081_cur, rx1081_pos, rx1081_tgt, $I10) = self."!cursor_start"()
    rx1081_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1081_cur
    .local pmc match
    .lex "$/", match
    length rx1081_eos, rx1081_tgt
    gt rx1081_pos, rx1081_eos, rx1081_done
    set rx1081_off, 0
    lt rx1081_pos, 2, rx1081_start
    sub rx1081_off, rx1081_pos, 1
    substr rx1081_tgt, rx1081_tgt, rx1081_off
  rx1081_start:
    eq $I10, 1, rx1081_restart
    if_null rx1081_debug, debug_1047
    rx1081_cur."!cursor_debug"("START", "parameter")
  debug_1047:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1084_done
    goto rxscan1084_scan
  rxscan1084_loop:
    (rx1081_pos) = rx1081_cur."from"()
    inc rx1081_pos
    rx1081_cur."!cursor_from"(rx1081_pos)
    ge rx1081_pos, rx1081_eos, rxscan1084_done
  rxscan1084_scan:
    set_addr $I10, rxscan1084_loop
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  rxscan1084_done:
.annotate 'line', 475
  # rx rxquantr1085 ** 0..*
    set_addr $I10, rxquantr1085_done
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  rxquantr1085_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."typename"()
    unless $P10, rx1081_fail
    rx1081_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1081_pos = $P10."pos"()
  # rx rxquantr1086 ** 0..1
    set_addr $I10, rxquantr1086_done
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  rxquantr1086_loop:
  # rx literal  ":"
    add $I11, rx1081_pos, 1
    gt $I11, rx1081_eos, rx1081_fail
    sub $I11, rx1081_pos, rx1081_off
    ord $I11, rx1081_tgt, $I11
    ne $I11, 58, rx1081_fail
    add rx1081_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1087_fail
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1081_pos, rx1081_eos, rx1081_fail
    sub $I10, rx1081_pos, rx1081_off
    substr $S10, rx1081_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1081_fail
    inc rx1081_pos
    set_addr $I10, rxcap_1087_fail
    ($I12, $I11) = rx1081_cur."!mark_peek"($I10)
    rx1081_cur."!cursor_pos"($I11)
    ($P10) = rx1081_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1081_pos, "")
    rx1081_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1087_done
  rxcap_1087_fail:
    goto rx1081_fail
  rxcap_1087_done:
    set_addr $I10, rxquantr1086_done
    (rx1081_rep) = rx1081_cur."!mark_commit"($I10)
  rxquantr1086_done:
  # rx subrule "ws" subtype=method negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."ws"()
    unless $P10, rx1081_fail
    rx1081_pos = $P10."pos"()
    set_addr $I10, rxquantr1085_done
    (rx1081_rep) = rx1081_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1085_done
    rx1081_cur."!mark_push"(rx1081_rep, rx1081_pos, $I10)
    goto rxquantr1085_loop
  rxquantr1085_done:
  alt1088_0:
.annotate 'line', 476
    set_addr $I10, alt1088_1
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
.annotate 'line', 477
  # rx subcapture "quant"
    set_addr $I10, rxcap_1089_fail
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  # rx literal  "*"
    add $I11, rx1081_pos, 1
    gt $I11, rx1081_eos, rx1081_fail
    sub $I11, rx1081_pos, rx1081_off
    ord $I11, rx1081_tgt, $I11
    ne $I11, 42, rx1081_fail
    add rx1081_pos, 1
    set_addr $I10, rxcap_1089_fail
    ($I12, $I11) = rx1081_cur."!mark_peek"($I10)
    rx1081_cur."!cursor_pos"($I11)
    ($P10) = rx1081_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1081_pos, "")
    rx1081_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1089_done
  rxcap_1089_fail:
    goto rx1081_fail
  rxcap_1089_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."param_var"()
    unless $P10, rx1081_fail
    rx1081_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1081_pos = $P10."pos"()
    goto alt1088_end
  alt1088_1:
  alt1090_0:
.annotate 'line', 478
    set_addr $I10, alt1090_1
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."param_var"()
    unless $P10, rx1081_fail
    rx1081_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1081_pos = $P10."pos"()
    goto alt1090_end
  alt1090_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."named_param"()
    unless $P10, rx1081_fail
    rx1081_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1081_pos = $P10."pos"()
  alt1090_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1092_fail
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  alt1091_0:
    set_addr $I10, alt1091_1
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  # rx literal  "?"
    add $I11, rx1081_pos, 1
    gt $I11, rx1081_eos, rx1081_fail
    sub $I11, rx1081_pos, rx1081_off
    ord $I11, rx1081_tgt, $I11
    ne $I11, 63, rx1081_fail
    add rx1081_pos, 1
    goto alt1091_end
  alt1091_1:
    set_addr $I10, alt1091_2
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  # rx literal  "!"
    add $I11, rx1081_pos, 1
    gt $I11, rx1081_eos, rx1081_fail
    sub $I11, rx1081_pos, rx1081_off
    ord $I11, rx1081_tgt, $I11
    ne $I11, 33, rx1081_fail
    add rx1081_pos, 1
    goto alt1091_end
  alt1091_2:
  alt1091_end:
    set_addr $I10, rxcap_1092_fail
    ($I12, $I11) = rx1081_cur."!mark_peek"($I10)
    rx1081_cur."!cursor_pos"($I11)
    ($P10) = rx1081_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1081_pos, "")
    rx1081_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1092_done
  rxcap_1092_fail:
    goto rx1081_fail
  rxcap_1092_done:
  alt1088_end:
.annotate 'line', 480
  # rx rxquantr1093 ** 0..1
    set_addr $I10, rxquantr1093_done
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10)
  rxquantr1093_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1081_cur."!cursor_pos"(rx1081_pos)
    $P10 = rx1081_cur."default_value"()
    unless $P10, rx1081_fail
    goto rxsubrule1094_pass
  rxsubrule1094_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1081_fail
  rxsubrule1094_pass:
    set_addr $I10, rxsubrule1094_back
    rx1081_cur."!mark_push"(0, rx1081_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1081_pos = $P10."pos"()
    set_addr $I10, rxquantr1093_done
    (rx1081_rep) = rx1081_cur."!mark_commit"($I10)
  rxquantr1093_done:
.annotate 'line', 474
  # rx pass
    rx1081_cur."!cursor_pass"(rx1081_pos, "parameter")
    if_null rx1081_debug, debug_1048
    rx1081_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1081_pos)
  debug_1048:
    .return (rx1081_cur)
  rx1081_restart:
.annotate 'line', 10
    if_null rx1081_debug, debug_1049
    rx1081_cur."!cursor_debug"("NEXT", "parameter")
  debug_1049:
  rx1081_fail:
    (rx1081_rep, rx1081_pos, $I10, $P10) = rx1081_cur."!mark_fail"(0)
    lt rx1081_pos, -1, rx1081_done
    eq rx1081_pos, -1, rx1081_fail
    jump $I10
  rx1081_done:
    rx1081_cur."!cursor_fail"()
    if_null rx1081_debug, debug_1050
    rx1081_cur."!cursor_debug"("FAIL", "parameter")
  debug_1050:
    .return (rx1081_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("197_1303603603.711") :method
.annotate 'line', 10
    new $P1083, "ResizablePMCArray"
    push $P1083, ""
    .return ($P1083)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("198_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1096_tgt
    .local int rx1096_pos
    .local int rx1096_off
    .local int rx1096_eos
    .local int rx1096_rep
    .local pmc rx1096_cur
    .local pmc rx1096_debug
    (rx1096_cur, rx1096_pos, rx1096_tgt, $I10) = self."!cursor_start"()
    rx1096_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1096_cur
    .local pmc match
    .lex "$/", match
    length rx1096_eos, rx1096_tgt
    gt rx1096_pos, rx1096_eos, rx1096_done
    set rx1096_off, 0
    lt rx1096_pos, 2, rx1096_start
    sub rx1096_off, rx1096_pos, 1
    substr rx1096_tgt, rx1096_tgt, rx1096_off
  rx1096_start:
    eq $I10, 1, rx1096_restart
    if_null rx1096_debug, debug_1051
    rx1096_cur."!cursor_debug"("START", "param_var")
  debug_1051:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1100_done
    goto rxscan1100_scan
  rxscan1100_loop:
    (rx1096_pos) = rx1096_cur."from"()
    inc rx1096_pos
    rx1096_cur."!cursor_from"(rx1096_pos)
    ge rx1096_pos, rx1096_eos, rxscan1100_done
  rxscan1100_scan:
    set_addr $I10, rxscan1100_loop
    rx1096_cur."!mark_push"(0, rx1096_pos, $I10)
  rxscan1100_done:
.annotate 'line', 484
  # rx subrule "sigil" subtype=capture negate=
    rx1096_cur."!cursor_pos"(rx1096_pos)
    $P10 = rx1096_cur."sigil"()
    unless $P10, rx1096_fail
    rx1096_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1096_pos = $P10."pos"()
  # rx rxquantr1101 ** 0..1
    set_addr $I10, rxquantr1101_done
    rx1096_cur."!mark_push"(0, rx1096_pos, $I10)
  rxquantr1101_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1096_cur."!cursor_pos"(rx1096_pos)
    $P10 = rx1096_cur."twigil"()
    unless $P10, rx1096_fail
    goto rxsubrule1102_pass
  rxsubrule1102_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1096_fail
  rxsubrule1102_pass:
    set_addr $I10, rxsubrule1102_back
    rx1096_cur."!mark_push"(0, rx1096_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1096_pos = $P10."pos"()
    set_addr $I10, rxquantr1101_done
    (rx1096_rep) = rx1096_cur."!mark_commit"($I10)
  rxquantr1101_done:
  alt1103_0:
.annotate 'line', 485
    set_addr $I10, alt1103_1
    rx1096_cur."!mark_push"(0, rx1096_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1096_cur."!cursor_pos"(rx1096_pos)
    $P10 = rx1096_cur."ident"()
    unless $P10, rx1096_fail
    rx1096_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1096_pos = $P10."pos"()
    goto alt1103_end
  alt1103_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1104_fail
    rx1096_cur."!mark_push"(0, rx1096_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1096_pos, rx1096_eos, rx1096_fail
    sub $I10, rx1096_pos, rx1096_off
    substr $S10, rx1096_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1096_fail
    inc rx1096_pos
    set_addr $I10, rxcap_1104_fail
    ($I12, $I11) = rx1096_cur."!mark_peek"($I10)
    rx1096_cur."!cursor_pos"($I11)
    ($P10) = rx1096_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1096_pos, "")
    rx1096_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1104_done
  rxcap_1104_fail:
    goto rx1096_fail
  rxcap_1104_done:
  alt1103_end:
.annotate 'line', 483
  # rx pass
    rx1096_cur."!cursor_pass"(rx1096_pos, "param_var")
    if_null rx1096_debug, debug_1052
    rx1096_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1096_pos)
  debug_1052:
    .return (rx1096_cur)
  rx1096_restart:
.annotate 'line', 10
    if_null rx1096_debug, debug_1053
    rx1096_cur."!cursor_debug"("NEXT", "param_var")
  debug_1053:
  rx1096_fail:
    (rx1096_rep, rx1096_pos, $I10, $P10) = rx1096_cur."!mark_fail"(0)
    lt rx1096_pos, -1, rx1096_done
    eq rx1096_pos, -1, rx1096_fail
    jump $I10
  rx1096_done:
    rx1096_cur."!cursor_fail"()
    if_null rx1096_debug, debug_1054
    rx1096_cur."!cursor_debug"("FAIL", "param_var")
  debug_1054:
    .return (rx1096_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("199_1303603603.711") :method
.annotate 'line', 10
    $P1098 = self."!PREFIX__!subrule"("sigil", "")
    new $P1099, "ResizablePMCArray"
    push $P1099, $P1098
    .return ($P1099)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("200_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1106_tgt
    .local int rx1106_pos
    .local int rx1106_off
    .local int rx1106_eos
    .local int rx1106_rep
    .local pmc rx1106_cur
    .local pmc rx1106_debug
    (rx1106_cur, rx1106_pos, rx1106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1106_cur
    .local pmc match
    .lex "$/", match
    length rx1106_eos, rx1106_tgt
    gt rx1106_pos, rx1106_eos, rx1106_done
    set rx1106_off, 0
    lt rx1106_pos, 2, rx1106_start
    sub rx1106_off, rx1106_pos, 1
    substr rx1106_tgt, rx1106_tgt, rx1106_off
  rx1106_start:
    eq $I10, 1, rx1106_restart
    if_null rx1106_debug, debug_1055
    rx1106_cur."!cursor_debug"("START", "named_param")
  debug_1055:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1110_done
    goto rxscan1110_scan
  rxscan1110_loop:
    (rx1106_pos) = rx1106_cur."from"()
    inc rx1106_pos
    rx1106_cur."!cursor_from"(rx1106_pos)
    ge rx1106_pos, rx1106_eos, rxscan1110_done
  rxscan1110_scan:
    set_addr $I10, rxscan1110_loop
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  rxscan1110_done:
.annotate 'line', 489
  # rx literal  ":"
    add $I11, rx1106_pos, 1
    gt $I11, rx1106_eos, rx1106_fail
    sub $I11, rx1106_pos, rx1106_off
    ord $I11, rx1106_tgt, $I11
    ne $I11, 58, rx1106_fail
    add rx1106_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."param_var"()
    unless $P10, rx1106_fail
    rx1106_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1106_pos = $P10."pos"()
.annotate 'line', 488
  # rx pass
    rx1106_cur."!cursor_pass"(rx1106_pos, "named_param")
    if_null rx1106_debug, debug_1056
    rx1106_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1106_pos)
  debug_1056:
    .return (rx1106_cur)
  rx1106_restart:
.annotate 'line', 10
    if_null rx1106_debug, debug_1057
    rx1106_cur."!cursor_debug"("NEXT", "named_param")
  debug_1057:
  rx1106_fail:
    (rx1106_rep, rx1106_pos, $I10, $P10) = rx1106_cur."!mark_fail"(0)
    lt rx1106_pos, -1, rx1106_done
    eq rx1106_pos, -1, rx1106_fail
    jump $I10
  rx1106_done:
    rx1106_cur."!cursor_fail"()
    if_null rx1106_debug, debug_1058
    rx1106_cur."!cursor_debug"("FAIL", "named_param")
  debug_1058:
    .return (rx1106_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("201_1303603603.711") :method
.annotate 'line', 10
    $P1108 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1109, "ResizablePMCArray"
    push $P1109, $P1108
    .return ($P1109)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("202_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1112_tgt
    .local int rx1112_pos
    .local int rx1112_off
    .local int rx1112_eos
    .local int rx1112_rep
    .local pmc rx1112_cur
    .local pmc rx1112_debug
    (rx1112_cur, rx1112_pos, rx1112_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1112_cur
    .local pmc match
    .lex "$/", match
    length rx1112_eos, rx1112_tgt
    gt rx1112_pos, rx1112_eos, rx1112_done
    set rx1112_off, 0
    lt rx1112_pos, 2, rx1112_start
    sub rx1112_off, rx1112_pos, 1
    substr rx1112_tgt, rx1112_tgt, rx1112_off
  rx1112_start:
    eq $I10, 1, rx1112_restart
    if_null rx1112_debug, debug_1059
    rx1112_cur."!cursor_debug"("START", "default_value")
  debug_1059:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1116_done
    goto rxscan1116_scan
  rxscan1116_loop:
    (rx1112_pos) = rx1112_cur."from"()
    inc rx1112_pos
    rx1112_cur."!cursor_from"(rx1112_pos)
    ge rx1112_pos, rx1112_eos, rxscan1116_done
  rxscan1116_scan:
    set_addr $I10, rxscan1116_loop
    rx1112_cur."!mark_push"(0, rx1112_pos, $I10)
  rxscan1116_done:
.annotate 'line', 492
  # rx subrule "ws" subtype=method negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."ws"()
    unless $P10, rx1112_fail
    rx1112_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1112_pos, 1
    gt $I11, rx1112_eos, rx1112_fail
    sub $I11, rx1112_pos, rx1112_off
    ord $I11, rx1112_tgt, $I11
    ne $I11, 61, rx1112_fail
    add rx1112_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."ws"()
    unless $P10, rx1112_fail
    rx1112_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."EXPR"("i=")
    unless $P10, rx1112_fail
    rx1112_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1112_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1112_cur."!cursor_pos"(rx1112_pos)
    $P10 = rx1112_cur."ws"()
    unless $P10, rx1112_fail
    rx1112_pos = $P10."pos"()
  # rx pass
    rx1112_cur."!cursor_pass"(rx1112_pos, "default_value")
    if_null rx1112_debug, debug_1060
    rx1112_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1112_pos)
  debug_1060:
    .return (rx1112_cur)
  rx1112_restart:
.annotate 'line', 10
    if_null rx1112_debug, debug_1061
    rx1112_cur."!cursor_debug"("NEXT", "default_value")
  debug_1061:
  rx1112_fail:
    (rx1112_rep, rx1112_pos, $I10, $P10) = rx1112_cur."!mark_fail"(0)
    lt rx1112_pos, -1, rx1112_done
    eq rx1112_pos, -1, rx1112_fail
    jump $I10
  rx1112_done:
    rx1112_cur."!cursor_fail"()
    if_null rx1112_debug, debug_1062
    rx1112_cur."!cursor_debug"("FAIL", "default_value")
  debug_1062:
    .return (rx1112_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("203_1303603603.711") :method
.annotate 'line', 10
    $P1114 = self."!PREFIX__!subrule"("ws", "")
    new $P1115, "ResizablePMCArray"
    push $P1115, $P1114
    .return ($P1115)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("204_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1121_tgt
    .local int rx1121_pos
    .local int rx1121_off
    .local int rx1121_eos
    .local int rx1121_rep
    .local pmc rx1121_cur
    .local pmc rx1121_debug
    (rx1121_cur, rx1121_pos, rx1121_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1121_cur
    .local pmc match
    .lex "$/", match
    length rx1121_eos, rx1121_tgt
    gt rx1121_pos, rx1121_eos, rx1121_done
    set rx1121_off, 0
    lt rx1121_pos, 2, rx1121_start
    sub rx1121_off, rx1121_pos, 1
    substr rx1121_tgt, rx1121_tgt, rx1121_off
  rx1121_start:
    eq $I10, 1, rx1121_restart
    if_null rx1121_debug, debug_1063
    rx1121_cur."!cursor_debug"("START", "trait")
  debug_1063:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1125_done
    goto rxscan1125_scan
  rxscan1125_loop:
    (rx1121_pos) = rx1121_cur."from"()
    inc rx1121_pos
    rx1121_cur."!cursor_from"(rx1121_pos)
    ge rx1121_pos, rx1121_eos, rxscan1125_done
  rxscan1125_scan:
    set_addr $I10, rxscan1125_loop
    rx1121_cur."!mark_push"(0, rx1121_pos, $I10)
  rxscan1125_done:
.annotate 'line', 494
  # rx subrule "ws" subtype=method negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."ws"()
    unless $P10, rx1121_fail
    rx1121_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."trait_mod"()
    unless $P10, rx1121_fail
    rx1121_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1121_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1121_cur."!cursor_pos"(rx1121_pos)
    $P10 = rx1121_cur."ws"()
    unless $P10, rx1121_fail
    rx1121_pos = $P10."pos"()
  # rx pass
    rx1121_cur."!cursor_pass"(rx1121_pos, "trait")
    if_null rx1121_debug, debug_1064
    rx1121_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1121_pos)
  debug_1064:
    .return (rx1121_cur)
  rx1121_restart:
.annotate 'line', 10
    if_null rx1121_debug, debug_1065
    rx1121_cur."!cursor_debug"("NEXT", "trait")
  debug_1065:
  rx1121_fail:
    (rx1121_rep, rx1121_pos, $I10, $P10) = rx1121_cur."!mark_fail"(0)
    lt rx1121_pos, -1, rx1121_done
    eq rx1121_pos, -1, rx1121_fail
    jump $I10
  rx1121_done:
    rx1121_cur."!cursor_fail"()
    if_null rx1121_debug, debug_1066
    rx1121_cur."!cursor_debug"("FAIL", "trait")
  debug_1066:
    .return (rx1121_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("205_1303603603.711") :method
.annotate 'line', 10
    $P1123 = self."!PREFIX__!subrule"("ws", "")
    new $P1124, "ResizablePMCArray"
    push $P1124, $P1123
    .return ($P1124)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("206_1303603603.711")
    .param pmc param_1129
.annotate 'line', 496
    .lex "self", param_1129
    $P1130 = param_1129."!protoregex"("trait_mod")
    .return ($P1130)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("207_1303603603.711")
    .param pmc param_1132
.annotate 'line', 496
    .lex "self", param_1132
    $P1133 = param_1132."!PREFIX__!protoregex"("trait_mod")
    .return ($P1133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("208_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1135_tgt
    .local int rx1135_pos
    .local int rx1135_off
    .local int rx1135_eos
    .local int rx1135_rep
    .local pmc rx1135_cur
    .local pmc rx1135_debug
    (rx1135_cur, rx1135_pos, rx1135_tgt, $I10) = self."!cursor_start"()
    rx1135_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1135_cur
    .local pmc match
    .lex "$/", match
    length rx1135_eos, rx1135_tgt
    gt rx1135_pos, rx1135_eos, rx1135_done
    set rx1135_off, 0
    lt rx1135_pos, 2, rx1135_start
    sub rx1135_off, rx1135_pos, 1
    substr rx1135_tgt, rx1135_tgt, rx1135_off
  rx1135_start:
    eq $I10, 1, rx1135_restart
    if_null rx1135_debug, debug_1067
    rx1135_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1067:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1139_done
    goto rxscan1139_scan
  rxscan1139_loop:
    (rx1135_pos) = rx1135_cur."from"()
    inc rx1135_pos
    rx1135_cur."!cursor_from"(rx1135_pos)
    ge rx1135_pos, rx1135_eos, rxscan1139_done
  rxscan1139_scan:
    set_addr $I10, rxscan1139_loop
    rx1135_cur."!mark_push"(0, rx1135_pos, $I10)
  rxscan1139_done:
.annotate 'line', 497
  # rx subcapture "sym"
    set_addr $I10, rxcap_1140_fail
    rx1135_cur."!mark_push"(0, rx1135_pos, $I10)
  # rx literal  "is"
    add $I11, rx1135_pos, 2
    gt $I11, rx1135_eos, rx1135_fail
    sub $I11, rx1135_pos, rx1135_off
    substr $S10, rx1135_tgt, $I11, 2
    ne $S10, "is", rx1135_fail
    add rx1135_pos, 2
    set_addr $I10, rxcap_1140_fail
    ($I12, $I11) = rx1135_cur."!mark_peek"($I10)
    rx1135_cur."!cursor_pos"($I11)
    ($P10) = rx1135_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1135_pos, "")
    rx1135_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1140_done
  rxcap_1140_fail:
    goto rx1135_fail
  rxcap_1140_done:
  # rx subrule "ws" subtype=method negate=
    rx1135_cur."!cursor_pos"(rx1135_pos)
    $P10 = rx1135_cur."ws"()
    unless $P10, rx1135_fail
    rx1135_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1135_cur."!cursor_pos"(rx1135_pos)
    $P10 = rx1135_cur."deflongname"()
    unless $P10, rx1135_fail
    rx1135_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1135_pos = $P10."pos"()
  # rx rxquantr1142 ** 0..1
    set_addr $I10, rxquantr1142_done
    rx1135_cur."!mark_push"(0, rx1135_pos, $I10)
  rxquantr1142_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1135_cur."!cursor_pos"(rx1135_pos)
    $P10 = rx1135_cur."circumfix"()
    unless $P10, rx1135_fail
    goto rxsubrule1143_pass
  rxsubrule1143_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1135_fail
  rxsubrule1143_pass:
    set_addr $I10, rxsubrule1143_back
    rx1135_cur."!mark_push"(0, rx1135_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1135_pos = $P10."pos"()
    set_addr $I10, rxquantr1142_done
    (rx1135_rep) = rx1135_cur."!mark_commit"($I10)
  rxquantr1142_done:
  # rx subrule "ws" subtype=method negate=
    rx1135_cur."!cursor_pos"(rx1135_pos)
    $P10 = rx1135_cur."ws"()
    unless $P10, rx1135_fail
    rx1135_pos = $P10."pos"()
  # rx pass
    rx1135_cur."!cursor_pass"(rx1135_pos, "trait_mod:sym<is>")
    if_null rx1135_debug, debug_1068
    rx1135_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1135_pos)
  debug_1068:
    .return (rx1135_cur)
  rx1135_restart:
.annotate 'line', 10
    if_null rx1135_debug, debug_1069
    rx1135_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1069:
  rx1135_fail:
    (rx1135_rep, rx1135_pos, $I10, $P10) = rx1135_cur."!mark_fail"(0)
    lt rx1135_pos, -1, rx1135_done
    eq rx1135_pos, -1, rx1135_fail
    jump $I10
  rx1135_done:
    rx1135_cur."!cursor_fail"()
    if_null rx1135_debug, debug_1070
    rx1135_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1070:
    .return (rx1135_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("209_1303603603.711") :method
.annotate 'line', 10
    $P1137 = self."!PREFIX__!subrule"("ws", "is")
    new $P1138, "ResizablePMCArray"
    push $P1138, $P1137
    .return ($P1138)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("210_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1146_tgt
    .local int rx1146_pos
    .local int rx1146_off
    .local int rx1146_eos
    .local int rx1146_rep
    .local pmc rx1146_cur
    .local pmc rx1146_debug
    (rx1146_cur, rx1146_pos, rx1146_tgt, $I10) = self."!cursor_start"()
    rx1146_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1146_cur
    .local pmc match
    .lex "$/", match
    length rx1146_eos, rx1146_tgt
    gt rx1146_pos, rx1146_eos, rx1146_done
    set rx1146_off, 0
    lt rx1146_pos, 2, rx1146_start
    sub rx1146_off, rx1146_pos, 1
    substr rx1146_tgt, rx1146_tgt, rx1146_off
  rx1146_start:
    eq $I10, 1, rx1146_restart
    if_null rx1146_debug, debug_1071
    rx1146_cur."!cursor_debug"("START", "regex_declarator")
  debug_1071:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1150_done
    goto rxscan1150_scan
  rxscan1150_loop:
    (rx1146_pos) = rx1146_cur."from"()
    inc rx1146_pos
    rx1146_cur."!cursor_from"(rx1146_pos)
    ge rx1146_pos, rx1146_eos, rxscan1150_done
  rxscan1150_scan:
    set_addr $I10, rxscan1150_loop
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  rxscan1150_done:
.annotate 'line', 499
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  alt1152_0:
.annotate 'line', 500
    set_addr $I10, alt1152_1
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
.annotate 'line', 501
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1154_fail
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1146_pos, 5
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 5
    ne $S10, "proto", rx1146_fail
    add rx1146_pos, 5
    set_addr $I10, rxcap_1154_fail
    ($I12, $I11) = rx1146_cur."!mark_peek"($I10)
    rx1146_cur."!cursor_pos"($I11)
    ($P10) = rx1146_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1146_pos, "")
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1154_done
  rxcap_1154_fail:
    goto rx1146_fail
  rxcap_1154_done:
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  alt1156_0:
    set_addr $I10, alt1156_1
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1146_pos, 5
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 5
    ne $S10, "regex", rx1146_fail
    add rx1146_pos, 5
    goto alt1156_end
  alt1156_1:
    set_addr $I10, alt1156_2
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  # rx literal  "token"
    add $I11, rx1146_pos, 5
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 5
    ne $S10, "token", rx1146_fail
    add rx1146_pos, 5
    goto alt1156_end
  alt1156_2:
  # rx literal  "rule"
    add $I11, rx1146_pos, 4
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 4
    ne $S10, "rule", rx1146_fail
    add rx1146_pos, 4
  alt1156_end:
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
.annotate 'line', 502
  # rx subrule "deflongname" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."deflongname"()
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1146_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  alt1159_0:
.annotate 'line', 503
    set_addr $I10, alt1159_1
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1146_pos, 1
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    ord $I11, rx1146_tgt, $I11
    ne $I11, 123, rx1146_fail
    add rx1146_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1146_pos, 5
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 5
    ne $S10, "<...>", rx1146_fail
    add rx1146_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1146_pos, 1
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    ord $I11, rx1146_tgt, $I11
    ne $I11, 125, rx1146_fail
    add rx1146_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ENDSTMT"()
    unless $P10, rx1146_fail
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
    goto alt1159_end
  alt1159_1:
    set_addr $I10, alt1159_2
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1146_pos, 1
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    ord $I11, rx1146_tgt, $I11
    ne $I11, 123, rx1146_fail
    add rx1146_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1146_pos, 3
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 3
    ne $S10, "<*>", rx1146_fail
    add rx1146_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1146_pos, 1
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    ord $I11, rx1146_tgt, $I11
    ne $I11, 125, rx1146_fail
    add rx1146_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ENDSTMT"()
    unless $P10, rx1146_fail
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
    goto alt1159_end
  alt1159_2:
.annotate 'line', 506
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  alt1159_end:
.annotate 'line', 507
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
.annotate 'line', 501
    goto alt1152_end
  alt1152_1:
.annotate 'line', 508
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1173_fail
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  alt1172_0:
    set_addr $I10, alt1172_1
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1146_pos, 5
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 5
    ne $S10, "regex", rx1146_fail
    add rx1146_pos, 5
    goto alt1172_end
  alt1172_1:
    set_addr $I10, alt1172_2
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  # rx literal  "token"
    add $I11, rx1146_pos, 5
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 5
    ne $S10, "token", rx1146_fail
    add rx1146_pos, 5
    goto alt1172_end
  alt1172_2:
  # rx literal  "rule"
    add $I11, rx1146_pos, 4
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I11, 4
    ne $S10, "rule", rx1146_fail
    add rx1146_pos, 4
  alt1172_end:
    set_addr $I10, rxcap_1173_fail
    ($I12, $I11) = rx1146_cur."!mark_peek"($I10)
    rx1146_cur."!cursor_pos"($I11)
    ($P10) = rx1146_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1146_pos, "")
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1173_done
  rxcap_1173_fail:
    goto rx1146_fail
  rxcap_1173_done:
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
.annotate 'line', 509
  # rx subrule "deflongname" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."deflongname"()
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1146_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
.annotate 'line', 510
  # rx subrule "newpad" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."newpad"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
.annotate 'line', 511
  # rx rxquantr1177 ** 0..1
    set_addr $I10, rxquantr1177_done
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  rxquantr1177_loop:
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1146_pos, 1
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    ord $I11, rx1146_tgt, $I11
    ne $I11, 40, rx1146_fail
    add rx1146_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."signature"()
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1146_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1146_pos, 1
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    ord $I11, rx1146_tgt, $I11
    ne $I11, 41, rx1146_fail
    add rx1146_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
    set_addr $I10, rxquantr1177_done
    (rx1146_rep) = rx1146_cur."!mark_commit"($I10)
  rxquantr1177_done:
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
.annotate 'line', 512
  # rx reduce name="regex_declarator" key="open"
    rx1146_cur."!cursor_pos"(rx1146_pos)
    rx1146_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
.annotate 'line', 513
  # rx literal  "{"
    add $I11, rx1146_pos, 1
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    ord $I11, rx1146_tgt, $I11
    ne $I11, 123, rx1146_fail
    add rx1146_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1146_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1146_pos, 1
    gt $I11, rx1146_eos, rx1146_fail
    sub $I11, rx1146_pos, rx1146_off
    ord $I11, rx1146_tgt, $I11
    ne $I11, 125, rx1146_fail
    add rx1146_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ENDSTMT"()
    unless $P10, rx1146_fail
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  alt1152_end:
.annotate 'line', 514
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
.annotate 'line', 499
  # rx pass
    rx1146_cur."!cursor_pass"(rx1146_pos, "regex_declarator")
    if_null rx1146_debug, debug_1072
    rx1146_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1146_pos)
  debug_1072:
    .return (rx1146_cur)
  rx1146_restart:
.annotate 'line', 10
    if_null rx1146_debug, debug_1073
    rx1146_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1073:
  rx1146_fail:
    (rx1146_rep, rx1146_pos, $I10, $P10) = rx1146_cur."!mark_fail"(0)
    lt rx1146_pos, -1, rx1146_done
    eq rx1146_pos, -1, rx1146_fail
    jump $I10
  rx1146_done:
    rx1146_cur."!cursor_fail"()
    if_null rx1146_debug, debug_1074
    rx1146_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1074:
    .return (rx1146_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("211_1303603603.711") :method
.annotate 'line', 10
    $P1148 = self."!PREFIX__!subrule"("ws", "")
    new $P1149, "ResizablePMCArray"
    push $P1149, $P1148
    .return ($P1149)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("212_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1187_tgt
    .local int rx1187_pos
    .local int rx1187_off
    .local int rx1187_eos
    .local int rx1187_rep
    .local pmc rx1187_cur
    .local pmc rx1187_debug
    (rx1187_cur, rx1187_pos, rx1187_tgt, $I10) = self."!cursor_start"()
    rx1187_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1187_cur
    .local pmc match
    .lex "$/", match
    length rx1187_eos, rx1187_tgt
    gt rx1187_pos, rx1187_eos, rx1187_done
    set rx1187_off, 0
    lt rx1187_pos, 2, rx1187_start
    sub rx1187_off, rx1187_pos, 1
    substr rx1187_tgt, rx1187_tgt, rx1187_off
  rx1187_start:
    eq $I10, 1, rx1187_restart
    if_null rx1187_debug, debug_1075
    rx1187_cur."!cursor_debug"("START", "dotty")
  debug_1075:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1191_done
    goto rxscan1191_scan
  rxscan1191_loop:
    (rx1187_pos) = rx1187_cur."from"()
    inc rx1187_pos
    rx1187_cur."!cursor_from"(rx1187_pos)
    ge rx1187_pos, rx1187_eos, rxscan1191_done
  rxscan1191_scan:
    set_addr $I10, rxscan1191_loop
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
  rxscan1191_done:
.annotate 'line', 518
  # rx literal  "."
    add $I11, rx1187_pos, 1
    gt $I11, rx1187_eos, rx1187_fail
    sub $I11, rx1187_pos, rx1187_off
    ord $I11, rx1187_tgt, $I11
    ne $I11, 46, rx1187_fail
    add rx1187_pos, 1
  alt1192_0:
.annotate 'line', 519
    set_addr $I10, alt1192_1
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."deflongname"()
    unless $P10, rx1187_fail
    rx1187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1187_pos = $P10."pos"()
    goto alt1192_end
  alt1192_1:
.annotate 'line', 520
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1187_pos, rx1187_off
    substr $S10, rx1187_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1187_fail
  # rx subrule "quote" subtype=capture negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."quote"()
    unless $P10, rx1187_fail
    rx1187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1187_pos = $P10."pos"()
  alt1193_0:
.annotate 'line', 521
    set_addr $I10, alt1193_1
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1187_pos, rx1187_off
    substr $S10, rx1187_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1187_fail
    goto alt1193_end
  alt1193_1:
  # rx subrule "panic" subtype=method negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1187_fail
    rx1187_pos = $P10."pos"()
  alt1193_end:
  alt1192_end:
.annotate 'line', 527
  # rx rxquantr1194 ** 0..1
    set_addr $I10, rxquantr1194_done
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
  rxquantr1194_loop:
  alt1195_0:
.annotate 'line', 524
    set_addr $I10, alt1195_1
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
.annotate 'line', 525
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1187_pos, rx1187_off
    substr $S10, rx1187_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1187_fail
  # rx subrule "args" subtype=capture negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."args"()
    unless $P10, rx1187_fail
    rx1187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1187_pos = $P10."pos"()
    goto alt1195_end
  alt1195_1:
.annotate 'line', 526
  # rx literal  ":"
    add $I11, rx1187_pos, 1
    gt $I11, rx1187_eos, rx1187_fail
    sub $I11, rx1187_pos, rx1187_off
    ord $I11, rx1187_tgt, $I11
    ne $I11, 58, rx1187_fail
    add rx1187_pos, 1
  # rx charclass s
    ge rx1187_pos, rx1187_eos, rx1187_fail
    sub $I10, rx1187_pos, rx1187_off
    is_cclass $I11, 32, rx1187_tgt, $I10
    unless $I11, rx1187_fail
    inc rx1187_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."arglist"()
    unless $P10, rx1187_fail
    rx1187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1187_pos = $P10."pos"()
  alt1195_end:
.annotate 'line', 527
    set_addr $I10, rxquantr1194_done
    (rx1187_rep) = rx1187_cur."!mark_commit"($I10)
  rxquantr1194_done:
.annotate 'line', 517
  # rx pass
    rx1187_cur."!cursor_pass"(rx1187_pos, "dotty")
    if_null rx1187_debug, debug_1076
    rx1187_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1187_pos)
  debug_1076:
    .return (rx1187_cur)
  rx1187_restart:
.annotate 'line', 10
    if_null rx1187_debug, debug_1077
    rx1187_cur."!cursor_debug"("NEXT", "dotty")
  debug_1077:
  rx1187_fail:
    (rx1187_rep, rx1187_pos, $I10, $P10) = rx1187_cur."!mark_fail"(0)
    lt rx1187_pos, -1, rx1187_done
    eq rx1187_pos, -1, rx1187_fail
    jump $I10
  rx1187_done:
    rx1187_cur."!cursor_fail"()
    if_null rx1187_debug, debug_1078
    rx1187_cur."!cursor_debug"("FAIL", "dotty")
  debug_1078:
    .return (rx1187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("213_1303603603.711") :method
.annotate 'line', 10
    $P1189 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1190, "ResizablePMCArray"
    push $P1190, "'"
    push $P1190, "\""
    push $P1190, $P1189
    .return ($P1190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("214_1303603603.711")
    .param pmc param_1197
.annotate 'line', 531
    .lex "self", param_1197
    $P1198 = param_1197."!protoregex"("term")
    .return ($P1198)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("215_1303603603.711")
    .param pmc param_1200
.annotate 'line', 531
    .lex "self", param_1200
    $P1201 = param_1200."!PREFIX__!protoregex"("term")
    .return ($P1201)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("216_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1203_tgt
    .local int rx1203_pos
    .local int rx1203_off
    .local int rx1203_eos
    .local int rx1203_rep
    .local pmc rx1203_cur
    .local pmc rx1203_debug
    (rx1203_cur, rx1203_pos, rx1203_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1203_cur
    .local pmc match
    .lex "$/", match
    length rx1203_eos, rx1203_tgt
    gt rx1203_pos, rx1203_eos, rx1203_done
    set rx1203_off, 0
    lt rx1203_pos, 2, rx1203_start
    sub rx1203_off, rx1203_pos, 1
    substr rx1203_tgt, rx1203_tgt, rx1203_off
  rx1203_start:
    eq $I10, 1, rx1203_restart
    if_null rx1203_debug, debug_1079
    rx1203_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1079:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1206_done
    goto rxscan1206_scan
  rxscan1206_loop:
    (rx1203_pos) = rx1203_cur."from"()
    inc rx1203_pos
    rx1203_cur."!cursor_from"(rx1203_pos)
    ge rx1203_pos, rx1203_eos, rxscan1206_done
  rxscan1206_scan:
    set_addr $I10, rxscan1206_loop
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  rxscan1206_done:
.annotate 'line', 533
  # rx subcapture "sym"
    set_addr $I10, rxcap_1207_fail
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  # rx literal  "self"
    add $I11, rx1203_pos, 4
    gt $I11, rx1203_eos, rx1203_fail
    sub $I11, rx1203_pos, rx1203_off
    substr $S10, rx1203_tgt, $I11, 4
    ne $S10, "self", rx1203_fail
    add rx1203_pos, 4
    set_addr $I10, rxcap_1207_fail
    ($I12, $I11) = rx1203_cur."!mark_peek"($I10)
    rx1203_cur."!cursor_pos"($I11)
    ($P10) = rx1203_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1203_pos, "")
    rx1203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1207_done
  rxcap_1207_fail:
    goto rx1203_fail
  rxcap_1207_done:
  # rxanchor rwb
    le rx1203_pos, 0, rx1203_fail
    sub $I10, rx1203_pos, rx1203_off
    is_cclass $I11, 8192, rx1203_tgt, $I10
    if $I11, rx1203_fail
    dec $I10
    is_cclass $I11, 8192, rx1203_tgt, $I10
    unless $I11, rx1203_fail
  # rx pass
    rx1203_cur."!cursor_pass"(rx1203_pos, "term:sym<self>")
    if_null rx1203_debug, debug_1080
    rx1203_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1203_pos)
  debug_1080:
    .return (rx1203_cur)
  rx1203_restart:
.annotate 'line', 10
    if_null rx1203_debug, debug_1081
    rx1203_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1081:
  rx1203_fail:
    (rx1203_rep, rx1203_pos, $I10, $P10) = rx1203_cur."!mark_fail"(0)
    lt rx1203_pos, -1, rx1203_done
    eq rx1203_pos, -1, rx1203_fail
    jump $I10
  rx1203_done:
    rx1203_cur."!cursor_fail"()
    if_null rx1203_debug, debug_1082
    rx1203_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1082:
    .return (rx1203_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("217_1303603603.711") :method
.annotate 'line', 10
    new $P1205, "ResizablePMCArray"
    push $P1205, "self"
    .return ($P1205)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("218_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1209_tgt
    .local int rx1209_pos
    .local int rx1209_off
    .local int rx1209_eos
    .local int rx1209_rep
    .local pmc rx1209_cur
    .local pmc rx1209_debug
    (rx1209_cur, rx1209_pos, rx1209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1209_cur
    .local pmc match
    .lex "$/", match
    length rx1209_eos, rx1209_tgt
    gt rx1209_pos, rx1209_eos, rx1209_done
    set rx1209_off, 0
    lt rx1209_pos, 2, rx1209_start
    sub rx1209_off, rx1209_pos, 1
    substr rx1209_tgt, rx1209_tgt, rx1209_off
  rx1209_start:
    eq $I10, 1, rx1209_restart
    if_null rx1209_debug, debug_1083
    rx1209_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1083:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1213_done
    goto rxscan1213_scan
  rxscan1213_loop:
    (rx1209_pos) = rx1209_cur."from"()
    inc rx1209_pos
    rx1209_cur."!cursor_from"(rx1209_pos)
    ge rx1209_pos, rx1209_eos, rxscan1213_done
  rxscan1213_scan:
    set_addr $I10, rxscan1213_loop
    rx1209_cur."!mark_push"(0, rx1209_pos, $I10)
  rxscan1213_done:
.annotate 'line', 536
  # rx subrule "deflongname" subtype=capture negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."deflongname"()
    unless $P10, rx1209_fail
    rx1209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1209_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1209_pos, rx1209_off
    substr $S10, rx1209_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1209_fail
  # rx subrule "args" subtype=capture negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."args"()
    unless $P10, rx1209_fail
    rx1209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1209_pos = $P10."pos"()
.annotate 'line', 535
  # rx pass
    rx1209_cur."!cursor_pass"(rx1209_pos, "term:sym<identifier>")
    if_null rx1209_debug, debug_1084
    rx1209_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1209_pos)
  debug_1084:
    .return (rx1209_cur)
  rx1209_restart:
.annotate 'line', 10
    if_null rx1209_debug, debug_1085
    rx1209_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1085:
  rx1209_fail:
    (rx1209_rep, rx1209_pos, $I10, $P10) = rx1209_cur."!mark_fail"(0)
    lt rx1209_pos, -1, rx1209_done
    eq rx1209_pos, -1, rx1209_fail
    jump $I10
  rx1209_done:
    rx1209_cur."!cursor_fail"()
    if_null rx1209_debug, debug_1086
    rx1209_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1086:
    .return (rx1209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("219_1303603603.711") :method
.annotate 'line', 10
    $P1211 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1212, "ResizablePMCArray"
    push $P1212, $P1211
    .return ($P1212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("220_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1215_tgt
    .local int rx1215_pos
    .local int rx1215_off
    .local int rx1215_eos
    .local int rx1215_rep
    .local pmc rx1215_cur
    .local pmc rx1215_debug
    (rx1215_cur, rx1215_pos, rx1215_tgt, $I10) = self."!cursor_start"()
    rx1215_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1215_cur
    .local pmc match
    .lex "$/", match
    length rx1215_eos, rx1215_tgt
    gt rx1215_pos, rx1215_eos, rx1215_done
    set rx1215_off, 0
    lt rx1215_pos, 2, rx1215_start
    sub rx1215_off, rx1215_pos, 1
    substr rx1215_tgt, rx1215_tgt, rx1215_off
  rx1215_start:
    eq $I10, 1, rx1215_restart
    if_null rx1215_debug, debug_1087
    rx1215_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1087:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1219_done
    goto rxscan1219_scan
  rxscan1219_loop:
    (rx1215_pos) = rx1215_cur."from"()
    inc rx1215_pos
    rx1215_cur."!cursor_from"(rx1215_pos)
    ge rx1215_pos, rx1215_eos, rxscan1219_done
  rxscan1219_scan:
    set_addr $I10, rxscan1219_loop
    rx1215_cur."!mark_push"(0, rx1215_pos, $I10)
  rxscan1219_done:
.annotate 'line', 540
  # rx subrule "name" subtype=capture negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."name"()
    unless $P10, rx1215_fail
    rx1215_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1215_pos = $P10."pos"()
  # rx rxquantr1220 ** 0..1
    set_addr $I10, rxquantr1220_done
    rx1215_cur."!mark_push"(0, rx1215_pos, $I10)
  rxquantr1220_loop:
  # rx subrule "args" subtype=capture negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."args"()
    unless $P10, rx1215_fail
    goto rxsubrule1221_pass
  rxsubrule1221_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1215_fail
  rxsubrule1221_pass:
    set_addr $I10, rxsubrule1221_back
    rx1215_cur."!mark_push"(0, rx1215_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1215_pos = $P10."pos"()
    set_addr $I10, rxquantr1220_done
    (rx1215_rep) = rx1215_cur."!mark_commit"($I10)
  rxquantr1220_done:
.annotate 'line', 539
  # rx pass
    rx1215_cur."!cursor_pass"(rx1215_pos, "term:sym<name>")
    if_null rx1215_debug, debug_1088
    rx1215_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1215_pos)
  debug_1088:
    .return (rx1215_cur)
  rx1215_restart:
.annotate 'line', 10
    if_null rx1215_debug, debug_1089
    rx1215_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1089:
  rx1215_fail:
    (rx1215_rep, rx1215_pos, $I10, $P10) = rx1215_cur."!mark_fail"(0)
    lt rx1215_pos, -1, rx1215_done
    eq rx1215_pos, -1, rx1215_fail
    jump $I10
  rx1215_done:
    rx1215_cur."!cursor_fail"()
    if_null rx1215_debug, debug_1090
    rx1215_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1090:
    .return (rx1215_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("221_1303603603.711") :method
.annotate 'line', 10
    $P1217 = self."!PREFIX__!subrule"("name", "")
    new $P1218, "ResizablePMCArray"
    push $P1218, $P1217
    .return ($P1218)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("222_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1223_tgt
    .local int rx1223_pos
    .local int rx1223_off
    .local int rx1223_eos
    .local int rx1223_rep
    .local pmc rx1223_cur
    .local pmc rx1223_debug
    (rx1223_cur, rx1223_pos, rx1223_tgt, $I10) = self."!cursor_start"()
    rx1223_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1223_cur
    .local pmc match
    .lex "$/", match
    length rx1223_eos, rx1223_tgt
    gt rx1223_pos, rx1223_eos, rx1223_done
    set rx1223_off, 0
    lt rx1223_pos, 2, rx1223_start
    sub rx1223_off, rx1223_pos, 1
    substr rx1223_tgt, rx1223_tgt, rx1223_off
  rx1223_start:
    eq $I10, 1, rx1223_restart
    if_null rx1223_debug, debug_1091
    rx1223_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1091:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1226_done
    goto rxscan1226_scan
  rxscan1226_loop:
    (rx1223_pos) = rx1223_cur."from"()
    inc rx1223_pos
    rx1223_cur."!cursor_from"(rx1223_pos)
    ge rx1223_pos, rx1223_eos, rxscan1226_done
  rxscan1226_scan:
    set_addr $I10, rxscan1226_loop
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  rxscan1226_done:
.annotate 'line', 544
  # rx literal  "pir::"
    add $I11, rx1223_pos, 5
    gt $I11, rx1223_eos, rx1223_fail
    sub $I11, rx1223_pos, rx1223_off
    substr $S10, rx1223_tgt, $I11, 5
    ne $S10, "pir::", rx1223_fail
    add rx1223_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1227_fail
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1223_pos, rx1223_off
    find_not_cclass $I11, 8192, rx1223_tgt, $I10, rx1223_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1223_fail
    add rx1223_pos, rx1223_off, $I11
    set_addr $I10, rxcap_1227_fail
    ($I12, $I11) = rx1223_cur."!mark_peek"($I10)
    rx1223_cur."!cursor_pos"($I11)
    ($P10) = rx1223_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1223_pos, "")
    rx1223_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1227_done
  rxcap_1227_fail:
    goto rx1223_fail
  rxcap_1227_done:
  # rx rxquantr1228 ** 0..1
    set_addr $I10, rxquantr1228_done
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10)
  rxquantr1228_loop:
  # rx subrule "args" subtype=capture negate=
    rx1223_cur."!cursor_pos"(rx1223_pos)
    $P10 = rx1223_cur."args"()
    unless $P10, rx1223_fail
    goto rxsubrule1229_pass
  rxsubrule1229_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1223_fail
  rxsubrule1229_pass:
    set_addr $I10, rxsubrule1229_back
    rx1223_cur."!mark_push"(0, rx1223_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1223_pos = $P10."pos"()
    set_addr $I10, rxquantr1228_done
    (rx1223_rep) = rx1223_cur."!mark_commit"($I10)
  rxquantr1228_done:
.annotate 'line', 543
  # rx pass
    rx1223_cur."!cursor_pass"(rx1223_pos, "term:sym<pir::op>")
    if_null rx1223_debug, debug_1092
    rx1223_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1223_pos)
  debug_1092:
    .return (rx1223_cur)
  rx1223_restart:
.annotate 'line', 10
    if_null rx1223_debug, debug_1093
    rx1223_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1093:
  rx1223_fail:
    (rx1223_rep, rx1223_pos, $I10, $P10) = rx1223_cur."!mark_fail"(0)
    lt rx1223_pos, -1, rx1223_done
    eq rx1223_pos, -1, rx1223_fail
    jump $I10
  rx1223_done:
    rx1223_cur."!cursor_fail"()
    if_null rx1223_debug, debug_1094
    rx1223_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1094:
    .return (rx1223_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("223_1303603603.711") :method
.annotate 'line', 10
    new $P1225, "ResizablePMCArray"
    push $P1225, "pir::"
    .return ($P1225)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("224_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P1239 = "226_1303603603.711" 
    capture_lex $P1239
    .local string rx1231_tgt
    .local int rx1231_pos
    .local int rx1231_off
    .local int rx1231_eos
    .local int rx1231_rep
    .local pmc rx1231_cur
    .local pmc rx1231_debug
    (rx1231_cur, rx1231_pos, rx1231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1231_cur
    .local pmc match
    .lex "$/", match
    length rx1231_eos, rx1231_tgt
    gt rx1231_pos, rx1231_eos, rx1231_done
    set rx1231_off, 0
    lt rx1231_pos, 2, rx1231_start
    sub rx1231_off, rx1231_pos, 1
    substr rx1231_tgt, rx1231_tgt, rx1231_off
  rx1231_start:
    eq $I10, 1, rx1231_restart
    if_null rx1231_debug, debug_1095
    rx1231_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1095:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1231_pos) = rx1231_cur."from"()
    inc rx1231_pos
    rx1231_cur."!cursor_from"(rx1231_pos)
    ge rx1231_pos, rx1231_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
  rxscan1234_done:
.annotate 'line', 548
  # rx literal  "{*}"
    add $I11, rx1231_pos, 3
    gt $I11, rx1231_eos, rx1231_fail
    sub $I11, rx1231_pos, rx1231_off
    substr $S10, rx1231_tgt, $I11, 3
    ne $S10, "{*}", rx1231_fail
    add rx1231_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."ENDSTMT"()
    unless $P10, rx1231_fail
  alt1235_0:
.annotate 'line', 549
    set_addr $I10, alt1235_1
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
    rx1231_cur."!cursor_pos"(rx1231_pos)
    find_lex $P1236, unicode:"$\x{a2}"
    $P1237 = $P1236."MATCH"()
    store_lex "$/", $P1237
    .const 'Sub' $P1239 = "226_1303603603.711" 
    capture_lex $P1239
    $P1243 = $P1239()
    unless $P1243, rx1231_fail
    goto alt1235_end
  alt1235_1:
  # rx subrule "panic" subtype=method negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1231_fail
    rx1231_pos = $P10."pos"()
  alt1235_end:
.annotate 'line', 547
  # rx pass
    rx1231_cur."!cursor_pass"(rx1231_pos, "term:sym<onlystar>")
    if_null rx1231_debug, debug_1098
    rx1231_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1231_pos)
  debug_1098:
    .return (rx1231_cur)
  rx1231_restart:
.annotate 'line', 10
    if_null rx1231_debug, debug_1099
    rx1231_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1099:
  rx1231_fail:
    (rx1231_rep, rx1231_pos, $I10, $P10) = rx1231_cur."!mark_fail"(0)
    lt rx1231_pos, -1, rx1231_done
    eq rx1231_pos, -1, rx1231_fail
    jump $I10
  rx1231_done:
    rx1231_cur."!cursor_fail"()
    if_null rx1231_debug, debug_1100
    rx1231_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1100:
    .return (rx1231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("225_1303603603.711") :method
.annotate 'line', 10
    new $P1233, "ResizablePMCArray"
    push $P1233, "{*}"
    .return ($P1233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1238"  :anon :subid("226_1303603603.711") :outer("224_1303603603.711")
.annotate 'line', 549
    find_dynamic_lex $P1240, "$*MULTINESS"
    unless_null $P1240, vivify_1096
    get_hll_global $P1240, "$MULTINESS"
    unless_null $P1240, vivify_1097
    die "Contextual $*MULTINESS not found"
  vivify_1097:
  vivify_1096:
    set $S1241, $P1240
    iseq $I1242, $S1241, "proto"
    .return ($I1242)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("227_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1245_tgt
    .local int rx1245_pos
    .local int rx1245_off
    .local int rx1245_eos
    .local int rx1245_rep
    .local pmc rx1245_cur
    .local pmc rx1245_debug
    (rx1245_cur, rx1245_pos, rx1245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1245_cur
    .local pmc match
    .lex "$/", match
    length rx1245_eos, rx1245_tgt
    gt rx1245_pos, rx1245_eos, rx1245_done
    set rx1245_off, 0
    lt rx1245_pos, 2, rx1245_start
    sub rx1245_off, rx1245_pos, 1
    substr rx1245_tgt, rx1245_tgt, rx1245_off
  rx1245_start:
    eq $I10, 1, rx1245_restart
    if_null rx1245_debug, debug_1101
    rx1245_cur."!cursor_debug"("START", "args")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1249_done
    goto rxscan1249_scan
  rxscan1249_loop:
    (rx1245_pos) = rx1245_cur."from"()
    inc rx1245_pos
    rx1245_cur."!cursor_from"(rx1245_pos)
    ge rx1245_pos, rx1245_eos, rxscan1249_done
  rxscan1249_scan:
    set_addr $I10, rxscan1249_loop
    rx1245_cur."!mark_push"(0, rx1245_pos, $I10)
  rxscan1249_done:
.annotate 'line', 553
  # rx literal  "("
    add $I11, rx1245_pos, 1
    gt $I11, rx1245_eos, rx1245_fail
    sub $I11, rx1245_pos, rx1245_off
    ord $I11, rx1245_tgt, $I11
    ne $I11, 40, rx1245_fail
    add rx1245_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1245_cur."!cursor_pos"(rx1245_pos)
    $P10 = rx1245_cur."arglist"()
    unless $P10, rx1245_fail
    rx1245_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1245_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1245_pos, 1
    gt $I11, rx1245_eos, rx1245_fail
    sub $I11, rx1245_pos, rx1245_off
    ord $I11, rx1245_tgt, $I11
    ne $I11, 41, rx1245_fail
    add rx1245_pos, 1
  # rx pass
    rx1245_cur."!cursor_pass"(rx1245_pos, "args")
    if_null rx1245_debug, debug_1102
    rx1245_cur."!cursor_debug"("PASS", "args", " at pos=", rx1245_pos)
  debug_1102:
    .return (rx1245_cur)
  rx1245_restart:
.annotate 'line', 10
    if_null rx1245_debug, debug_1103
    rx1245_cur."!cursor_debug"("NEXT", "args")
  debug_1103:
  rx1245_fail:
    (rx1245_rep, rx1245_pos, $I10, $P10) = rx1245_cur."!mark_fail"(0)
    lt rx1245_pos, -1, rx1245_done
    eq rx1245_pos, -1, rx1245_fail
    jump $I10
  rx1245_done:
    rx1245_cur."!cursor_fail"()
    if_null rx1245_debug, debug_1104
    rx1245_cur."!cursor_debug"("FAIL", "args")
  debug_1104:
    .return (rx1245_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("228_1303603603.711") :method
.annotate 'line', 10
    $P1247 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1248, "ResizablePMCArray"
    push $P1248, $P1247
    .return ($P1248)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("229_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1251_tgt
    .local int rx1251_pos
    .local int rx1251_off
    .local int rx1251_eos
    .local int rx1251_rep
    .local pmc rx1251_cur
    .local pmc rx1251_debug
    (rx1251_cur, rx1251_pos, rx1251_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1251_cur
    .local pmc match
    .lex "$/", match
    length rx1251_eos, rx1251_tgt
    gt rx1251_pos, rx1251_eos, rx1251_done
    set rx1251_off, 0
    lt rx1251_pos, 2, rx1251_start
    sub rx1251_off, rx1251_pos, 1
    substr rx1251_tgt, rx1251_tgt, rx1251_off
  rx1251_start:
    eq $I10, 1, rx1251_restart
    if_null rx1251_debug, debug_1105
    rx1251_cur."!cursor_debug"("START", "arglist")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    (rx1251_pos) = rx1251_cur."from"()
    inc rx1251_pos
    rx1251_cur."!cursor_from"(rx1251_pos)
    ge rx1251_pos, rx1251_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
  rxscan1255_done:
.annotate 'line', 557
  # rx subrule "ws" subtype=method negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."ws"()
    unless $P10, rx1251_fail
    rx1251_pos = $P10."pos"()
  alt1256_0:
.annotate 'line', 558
    set_addr $I10, alt1256_1
    rx1251_cur."!mark_push"(0, rx1251_pos, $I10)
.annotate 'line', 559
  # rx subrule "EXPR" subtype=capture negate=
    rx1251_cur."!cursor_pos"(rx1251_pos)
    $P10 = rx1251_cur."EXPR"("f=")
    unless $P10, rx1251_fail
    rx1251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1251_pos = $P10."pos"()
    goto alt1256_end
  alt1256_1:
  alt1256_end:
.annotate 'line', 556
  # rx pass
    rx1251_cur."!cursor_pass"(rx1251_pos, "arglist")
    if_null rx1251_debug, debug_1106
    rx1251_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1251_pos)
  debug_1106:
    .return (rx1251_cur)
  rx1251_restart:
.annotate 'line', 10
    if_null rx1251_debug, debug_1107
    rx1251_cur."!cursor_debug"("NEXT", "arglist")
  debug_1107:
  rx1251_fail:
    (rx1251_rep, rx1251_pos, $I10, $P10) = rx1251_cur."!mark_fail"(0)
    lt rx1251_pos, -1, rx1251_done
    eq rx1251_pos, -1, rx1251_fail
    jump $I10
  rx1251_done:
    rx1251_cur."!cursor_fail"()
    if_null rx1251_debug, debug_1108
    rx1251_cur."!cursor_debug"("FAIL", "arglist")
  debug_1108:
    .return (rx1251_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("230_1303603603.711") :method
.annotate 'line', 10
    $P1253 = self."!PREFIX__!subrule"("ws", "")
    new $P1254, "ResizablePMCArray"
    push $P1254, $P1253
    .return ($P1254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("231_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1258_tgt
    .local int rx1258_pos
    .local int rx1258_off
    .local int rx1258_eos
    .local int rx1258_rep
    .local pmc rx1258_cur
    .local pmc rx1258_debug
    (rx1258_cur, rx1258_pos, rx1258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1258_cur
    .local pmc match
    .lex "$/", match
    length rx1258_eos, rx1258_tgt
    gt rx1258_pos, rx1258_eos, rx1258_done
    set rx1258_off, 0
    lt rx1258_pos, 2, rx1258_start
    sub rx1258_off, rx1258_pos, 1
    substr rx1258_tgt, rx1258_tgt, rx1258_off
  rx1258_start:
    eq $I10, 1, rx1258_restart
    if_null rx1258_debug, debug_1109
    rx1258_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1262_done
    goto rxscan1262_scan
  rxscan1262_loop:
    (rx1258_pos) = rx1258_cur."from"()
    inc rx1258_pos
    rx1258_cur."!cursor_from"(rx1258_pos)
    ge rx1258_pos, rx1258_eos, rxscan1262_done
  rxscan1262_scan:
    set_addr $I10, rxscan1262_loop
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxscan1262_done:
.annotate 'line', 565
  # rx subrule "value" subtype=capture negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."value"()
    unless $P10, rx1258_fail
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1258_pos = $P10."pos"()
  # rx pass
    rx1258_cur."!cursor_pass"(rx1258_pos, "term:sym<value>")
    if_null rx1258_debug, debug_1110
    rx1258_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1258_pos)
  debug_1110:
    .return (rx1258_cur)
  rx1258_restart:
.annotate 'line', 10
    if_null rx1258_debug, debug_1111
    rx1258_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1111:
  rx1258_fail:
    (rx1258_rep, rx1258_pos, $I10, $P10) = rx1258_cur."!mark_fail"(0)
    lt rx1258_pos, -1, rx1258_done
    eq rx1258_pos, -1, rx1258_fail
    jump $I10
  rx1258_done:
    rx1258_cur."!cursor_fail"()
    if_null rx1258_debug, debug_1112
    rx1258_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1112:
    .return (rx1258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("232_1303603603.711") :method
.annotate 'line', 10
    $P1260 = self."!PREFIX__!subrule"("value", "")
    new $P1261, "ResizablePMCArray"
    push $P1261, $P1260
    .return ($P1261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("233_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1264_tgt
    .local int rx1264_pos
    .local int rx1264_off
    .local int rx1264_eos
    .local int rx1264_rep
    .local pmc rx1264_cur
    .local pmc rx1264_debug
    (rx1264_cur, rx1264_pos, rx1264_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1264_cur
    .local pmc match
    .lex "$/", match
    length rx1264_eos, rx1264_tgt
    gt rx1264_pos, rx1264_eos, rx1264_done
    set rx1264_off, 0
    lt rx1264_pos, 2, rx1264_start
    sub rx1264_off, rx1264_pos, 1
    substr rx1264_tgt, rx1264_tgt, rx1264_off
  rx1264_start:
    eq $I10, 1, rx1264_restart
    if_null rx1264_debug, debug_1113
    rx1264_cur."!cursor_debug"("START", "value")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1269_done
    goto rxscan1269_scan
  rxscan1269_loop:
    (rx1264_pos) = rx1264_cur."from"()
    inc rx1264_pos
    rx1264_cur."!cursor_from"(rx1264_pos)
    ge rx1264_pos, rx1264_eos, rxscan1269_done
  rxscan1269_scan:
    set_addr $I10, rxscan1269_loop
    rx1264_cur."!mark_push"(0, rx1264_pos, $I10)
  rxscan1269_done:
  alt1270_0:
.annotate 'line', 567
    set_addr $I10, alt1270_1
    rx1264_cur."!mark_push"(0, rx1264_pos, $I10)
.annotate 'line', 568
  # rx subrule "quote" subtype=capture negate=
    rx1264_cur."!cursor_pos"(rx1264_pos)
    $P10 = rx1264_cur."quote"()
    unless $P10, rx1264_fail
    rx1264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1264_pos = $P10."pos"()
    goto alt1270_end
  alt1270_1:
.annotate 'line', 569
  # rx subrule "number" subtype=capture negate=
    rx1264_cur."!cursor_pos"(rx1264_pos)
    $P10 = rx1264_cur."number"()
    unless $P10, rx1264_fail
    rx1264_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1264_pos = $P10."pos"()
  alt1270_end:
.annotate 'line', 567
  # rx pass
    rx1264_cur."!cursor_pass"(rx1264_pos, "value")
    if_null rx1264_debug, debug_1114
    rx1264_cur."!cursor_debug"("PASS", "value", " at pos=", rx1264_pos)
  debug_1114:
    .return (rx1264_cur)
  rx1264_restart:
.annotate 'line', 10
    if_null rx1264_debug, debug_1115
    rx1264_cur."!cursor_debug"("NEXT", "value")
  debug_1115:
  rx1264_fail:
    (rx1264_rep, rx1264_pos, $I10, $P10) = rx1264_cur."!mark_fail"(0)
    lt rx1264_pos, -1, rx1264_done
    eq rx1264_pos, -1, rx1264_fail
    jump $I10
  rx1264_done:
    rx1264_cur."!cursor_fail"()
    if_null rx1264_debug, debug_1116
    rx1264_cur."!cursor_debug"("FAIL", "value")
  debug_1116:
    .return (rx1264_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("234_1303603603.711") :method
.annotate 'line', 10
    $P1266 = self."!PREFIX__!subrule"("number", "")
    $P1267 = self."!PREFIX__!subrule"("quote", "")
    new $P1268, "ResizablePMCArray"
    push $P1268, $P1266
    push $P1268, $P1267
    .return ($P1268)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("235_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1272_tgt
    .local int rx1272_pos
    .local int rx1272_off
    .local int rx1272_eos
    .local int rx1272_rep
    .local pmc rx1272_cur
    .local pmc rx1272_debug
    (rx1272_cur, rx1272_pos, rx1272_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1272_cur
    .local pmc match
    .lex "$/", match
    length rx1272_eos, rx1272_tgt
    gt rx1272_pos, rx1272_eos, rx1272_done
    set rx1272_off, 0
    lt rx1272_pos, 2, rx1272_start
    sub rx1272_off, rx1272_pos, 1
    substr rx1272_tgt, rx1272_tgt, rx1272_off
  rx1272_start:
    eq $I10, 1, rx1272_restart
    if_null rx1272_debug, debug_1117
    rx1272_cur."!cursor_debug"("START", "number")
  debug_1117:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1275_done
    goto rxscan1275_scan
  rxscan1275_loop:
    (rx1272_pos) = rx1272_cur."from"()
    inc rx1272_pos
    rx1272_cur."!cursor_from"(rx1272_pos)
    ge rx1272_pos, rx1272_eos, rxscan1275_done
  rxscan1275_scan:
    set_addr $I10, rxscan1275_loop
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  rxscan1275_done:
.annotate 'line', 573
  # rx subcapture "sign"
    set_addr $I10, rxcap_1277_fail
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1272_pos, rx1272_off
    set rx1272_rep, 0
    sub $I12, rx1272_eos, rx1272_pos
    le $I12, 1, rxenumcharlistq1276_loop
    set $I12, 1
  rxenumcharlistq1276_loop:
    le $I12, 0, rxenumcharlistq1276_done
    substr $S10, rx1272_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1276_done
    inc rx1272_rep
  rxenumcharlistq1276_done:
    add rx1272_pos, rx1272_pos, rx1272_rep
    set_addr $I10, rxcap_1277_fail
    ($I12, $I11) = rx1272_cur."!mark_peek"($I10)
    rx1272_cur."!cursor_pos"($I11)
    ($P10) = rx1272_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1272_pos, "")
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1277_done
  rxcap_1277_fail:
    goto rx1272_fail
  rxcap_1277_done:
  alt1278_0:
.annotate 'line', 574
    set_addr $I10, alt1278_1
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."dec_number"()
    unless $P10, rx1272_fail
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1272_pos = $P10."pos"()
    goto alt1278_end
  alt1278_1:
  # rx subrule "integer" subtype=capture negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."integer"()
    unless $P10, rx1272_fail
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1272_pos = $P10."pos"()
  alt1278_end:
.annotate 'line', 572
  # rx pass
    rx1272_cur."!cursor_pass"(rx1272_pos, "number")
    if_null rx1272_debug, debug_1118
    rx1272_cur."!cursor_debug"("PASS", "number", " at pos=", rx1272_pos)
  debug_1118:
    .return (rx1272_cur)
  rx1272_restart:
.annotate 'line', 10
    if_null rx1272_debug, debug_1119
    rx1272_cur."!cursor_debug"("NEXT", "number")
  debug_1119:
  rx1272_fail:
    (rx1272_rep, rx1272_pos, $I10, $P10) = rx1272_cur."!mark_fail"(0)
    lt rx1272_pos, -1, rx1272_done
    eq rx1272_pos, -1, rx1272_fail
    jump $I10
  rx1272_done:
    rx1272_cur."!cursor_fail"()
    if_null rx1272_debug, debug_1120
    rx1272_cur."!cursor_debug"("FAIL", "number")
  debug_1120:
    .return (rx1272_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("236_1303603603.711") :method
.annotate 'line', 10
    new $P1274, "ResizablePMCArray"
    push $P1274, ""
    .return ($P1274)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("237_1303603603.711")
    .param pmc param_1280
.annotate 'line', 577
    .lex "self", param_1280
    $P1281 = param_1280."!protoregex"("quote")
    .return ($P1281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("238_1303603603.711")
    .param pmc param_1283
.annotate 'line', 577
    .lex "self", param_1283
    $P1284 = param_1283."!PREFIX__!protoregex"("quote")
    .return ($P1284)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("239_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1286_tgt
    .local int rx1286_pos
    .local int rx1286_off
    .local int rx1286_eos
    .local int rx1286_rep
    .local pmc rx1286_cur
    .local pmc rx1286_debug
    (rx1286_cur, rx1286_pos, rx1286_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1286_cur
    .local pmc match
    .lex "$/", match
    length rx1286_eos, rx1286_tgt
    gt rx1286_pos, rx1286_eos, rx1286_done
    set rx1286_off, 0
    lt rx1286_pos, 2, rx1286_start
    sub rx1286_off, rx1286_pos, 1
    substr rx1286_tgt, rx1286_tgt, rx1286_off
  rx1286_start:
    eq $I10, 1, rx1286_restart
    if_null rx1286_debug, debug_1121
    rx1286_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1121:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1289_done
    goto rxscan1289_scan
  rxscan1289_loop:
    (rx1286_pos) = rx1286_cur."from"()
    inc rx1286_pos
    rx1286_cur."!cursor_from"(rx1286_pos)
    ge rx1286_pos, rx1286_eos, rxscan1289_done
  rxscan1289_scan:
    set_addr $I10, rxscan1289_loop
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  rxscan1289_done:
.annotate 'line', 578
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1286_pos, rx1286_off
    substr $S10, rx1286_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1286_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."quote_EXPR"(":q")
    unless $P10, rx1286_fail
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1286_pos = $P10."pos"()
  # rx pass
    rx1286_cur."!cursor_pass"(rx1286_pos, "quote:sym<apos>")
    if_null rx1286_debug, debug_1122
    rx1286_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1286_pos)
  debug_1122:
    .return (rx1286_cur)
  rx1286_restart:
.annotate 'line', 10
    if_null rx1286_debug, debug_1123
    rx1286_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1123:
  rx1286_fail:
    (rx1286_rep, rx1286_pos, $I10, $P10) = rx1286_cur."!mark_fail"(0)
    lt rx1286_pos, -1, rx1286_done
    eq rx1286_pos, -1, rx1286_fail
    jump $I10
  rx1286_done:
    rx1286_cur."!cursor_fail"()
    if_null rx1286_debug, debug_1124
    rx1286_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1124:
    .return (rx1286_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("240_1303603603.711") :method
.annotate 'line', 10
    new $P1288, "ResizablePMCArray"
    push $P1288, "'"
    .return ($P1288)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("241_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1291_tgt
    .local int rx1291_pos
    .local int rx1291_off
    .local int rx1291_eos
    .local int rx1291_rep
    .local pmc rx1291_cur
    .local pmc rx1291_debug
    (rx1291_cur, rx1291_pos, rx1291_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1291_cur
    .local pmc match
    .lex "$/", match
    length rx1291_eos, rx1291_tgt
    gt rx1291_pos, rx1291_eos, rx1291_done
    set rx1291_off, 0
    lt rx1291_pos, 2, rx1291_start
    sub rx1291_off, rx1291_pos, 1
    substr rx1291_tgt, rx1291_tgt, rx1291_off
  rx1291_start:
    eq $I10, 1, rx1291_restart
    if_null rx1291_debug, debug_1125
    rx1291_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1125:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1294_done
    goto rxscan1294_scan
  rxscan1294_loop:
    (rx1291_pos) = rx1291_cur."from"()
    inc rx1291_pos
    rx1291_cur."!cursor_from"(rx1291_pos)
    ge rx1291_pos, rx1291_eos, rxscan1294_done
  rxscan1294_scan:
    set_addr $I10, rxscan1294_loop
    rx1291_cur."!mark_push"(0, rx1291_pos, $I10)
  rxscan1294_done:
.annotate 'line', 579
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1291_pos, rx1291_off
    substr $S10, rx1291_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1291_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1291_cur."!cursor_pos"(rx1291_pos)
    $P10 = rx1291_cur."quote_EXPR"(":qq")
    unless $P10, rx1291_fail
    rx1291_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1291_pos = $P10."pos"()
  # rx pass
    rx1291_cur."!cursor_pass"(rx1291_pos, "quote:sym<dblq>")
    if_null rx1291_debug, debug_1126
    rx1291_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1291_pos)
  debug_1126:
    .return (rx1291_cur)
  rx1291_restart:
.annotate 'line', 10
    if_null rx1291_debug, debug_1127
    rx1291_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1127:
  rx1291_fail:
    (rx1291_rep, rx1291_pos, $I10, $P10) = rx1291_cur."!mark_fail"(0)
    lt rx1291_pos, -1, rx1291_done
    eq rx1291_pos, -1, rx1291_fail
    jump $I10
  rx1291_done:
    rx1291_cur."!cursor_fail"()
    if_null rx1291_debug, debug_1128
    rx1291_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1128:
    .return (rx1291_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("242_1303603603.711") :method
.annotate 'line', 10
    new $P1293, "ResizablePMCArray"
    push $P1293, "\""
    .return ($P1293)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("243_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1296_tgt
    .local int rx1296_pos
    .local int rx1296_off
    .local int rx1296_eos
    .local int rx1296_rep
    .local pmc rx1296_cur
    .local pmc rx1296_debug
    (rx1296_cur, rx1296_pos, rx1296_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1296_cur
    .local pmc match
    .lex "$/", match
    length rx1296_eos, rx1296_tgt
    gt rx1296_pos, rx1296_eos, rx1296_done
    set rx1296_off, 0
    lt rx1296_pos, 2, rx1296_start
    sub rx1296_off, rx1296_pos, 1
    substr rx1296_tgt, rx1296_tgt, rx1296_off
  rx1296_start:
    eq $I10, 1, rx1296_restart
    if_null rx1296_debug, debug_1129
    rx1296_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1129:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1300_done
    goto rxscan1300_scan
  rxscan1300_loop:
    (rx1296_pos) = rx1296_cur."from"()
    inc rx1296_pos
    rx1296_cur."!cursor_from"(rx1296_pos)
    ge rx1296_pos, rx1296_eos, rxscan1300_done
  rxscan1300_scan:
    set_addr $I10, rxscan1300_loop
    rx1296_cur."!mark_push"(0, rx1296_pos, $I10)
  rxscan1300_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1301_fail
    rx1296_cur."!mark_push"(0, rx1296_pos, $I10)
  # rx literal  "q"
    add $I11, rx1296_pos, 1
    gt $I11, rx1296_eos, rx1296_fail
    sub $I11, rx1296_pos, rx1296_off
    ord $I11, rx1296_tgt, $I11
    ne $I11, 113, rx1296_fail
    add rx1296_pos, 1
    set_addr $I10, rxcap_1301_fail
    ($I12, $I11) = rx1296_cur."!mark_peek"($I10)
    rx1296_cur."!cursor_pos"($I11)
    ($P10) = rx1296_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1296_pos, "")
    rx1296_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1301_done
  rxcap_1301_fail:
    goto rx1296_fail
  rxcap_1301_done:
  # rxanchor rwb
    le rx1296_pos, 0, rx1296_fail
    sub $I10, rx1296_pos, rx1296_off
    is_cclass $I11, 8192, rx1296_tgt, $I10
    if $I11, rx1296_fail
    dec $I10
    is_cclass $I11, 8192, rx1296_tgt, $I10
    unless $I11, rx1296_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1296_pos, rx1296_off
    substr $S10, rx1296_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1296_fail
  # rx subrule "ws" subtype=method negate=
    rx1296_cur."!cursor_pos"(rx1296_pos)
    $P10 = rx1296_cur."ws"()
    unless $P10, rx1296_fail
    rx1296_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1296_cur."!cursor_pos"(rx1296_pos)
    $P10 = rx1296_cur."quote_EXPR"(":q")
    unless $P10, rx1296_fail
    rx1296_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1296_pos = $P10."pos"()
  # rx pass
    rx1296_cur."!cursor_pass"(rx1296_pos, "quote:sym<q>")
    if_null rx1296_debug, debug_1130
    rx1296_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1296_pos)
  debug_1130:
    .return (rx1296_cur)
  rx1296_restart:
.annotate 'line', 10
    if_null rx1296_debug, debug_1131
    rx1296_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1131:
  rx1296_fail:
    (rx1296_rep, rx1296_pos, $I10, $P10) = rx1296_cur."!mark_fail"(0)
    lt rx1296_pos, -1, rx1296_done
    eq rx1296_pos, -1, rx1296_fail
    jump $I10
  rx1296_done:
    rx1296_cur."!cursor_fail"()
    if_null rx1296_debug, debug_1132
    rx1296_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1132:
    .return (rx1296_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("244_1303603603.711") :method
.annotate 'line', 10
    $P1298 = self."!PREFIX__!subrule"("ws", "q")
    new $P1299, "ResizablePMCArray"
    push $P1299, $P1298
    .return ($P1299)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("245_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1303_tgt
    .local int rx1303_pos
    .local int rx1303_off
    .local int rx1303_eos
    .local int rx1303_rep
    .local pmc rx1303_cur
    .local pmc rx1303_debug
    (rx1303_cur, rx1303_pos, rx1303_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1303_cur
    .local pmc match
    .lex "$/", match
    length rx1303_eos, rx1303_tgt
    gt rx1303_pos, rx1303_eos, rx1303_done
    set rx1303_off, 0
    lt rx1303_pos, 2, rx1303_start
    sub rx1303_off, rx1303_pos, 1
    substr rx1303_tgt, rx1303_tgt, rx1303_off
  rx1303_start:
    eq $I10, 1, rx1303_restart
    if_null rx1303_debug, debug_1133
    rx1303_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1133:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1307_done
    goto rxscan1307_scan
  rxscan1307_loop:
    (rx1303_pos) = rx1303_cur."from"()
    inc rx1303_pos
    rx1303_cur."!cursor_from"(rx1303_pos)
    ge rx1303_pos, rx1303_eos, rxscan1307_done
  rxscan1307_scan:
    set_addr $I10, rxscan1307_loop
    rx1303_cur."!mark_push"(0, rx1303_pos, $I10)
  rxscan1307_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1308_fail
    rx1303_cur."!mark_push"(0, rx1303_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1303_pos, 2
    gt $I11, rx1303_eos, rx1303_fail
    sub $I11, rx1303_pos, rx1303_off
    substr $S10, rx1303_tgt, $I11, 2
    ne $S10, "qq", rx1303_fail
    add rx1303_pos, 2
    set_addr $I10, rxcap_1308_fail
    ($I12, $I11) = rx1303_cur."!mark_peek"($I10)
    rx1303_cur."!cursor_pos"($I11)
    ($P10) = rx1303_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1303_pos, "")
    rx1303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1308_done
  rxcap_1308_fail:
    goto rx1303_fail
  rxcap_1308_done:
  # rxanchor rwb
    le rx1303_pos, 0, rx1303_fail
    sub $I10, rx1303_pos, rx1303_off
    is_cclass $I11, 8192, rx1303_tgt, $I10
    if $I11, rx1303_fail
    dec $I10
    is_cclass $I11, 8192, rx1303_tgt, $I10
    unless $I11, rx1303_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1303_pos, rx1303_off
    substr $S10, rx1303_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1303_fail
  # rx subrule "ws" subtype=method negate=
    rx1303_cur."!cursor_pos"(rx1303_pos)
    $P10 = rx1303_cur."ws"()
    unless $P10, rx1303_fail
    rx1303_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1303_cur."!cursor_pos"(rx1303_pos)
    $P10 = rx1303_cur."quote_EXPR"(":qq")
    unless $P10, rx1303_fail
    rx1303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1303_pos = $P10."pos"()
  # rx pass
    rx1303_cur."!cursor_pass"(rx1303_pos, "quote:sym<qq>")
    if_null rx1303_debug, debug_1134
    rx1303_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1303_pos)
  debug_1134:
    .return (rx1303_cur)
  rx1303_restart:
.annotate 'line', 10
    if_null rx1303_debug, debug_1135
    rx1303_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1135:
  rx1303_fail:
    (rx1303_rep, rx1303_pos, $I10, $P10) = rx1303_cur."!mark_fail"(0)
    lt rx1303_pos, -1, rx1303_done
    eq rx1303_pos, -1, rx1303_fail
    jump $I10
  rx1303_done:
    rx1303_cur."!cursor_fail"()
    if_null rx1303_debug, debug_1136
    rx1303_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1136:
    .return (rx1303_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("246_1303603603.711") :method
.annotate 'line', 10
    $P1305 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1306, "ResizablePMCArray"
    push $P1306, $P1305
    .return ($P1306)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("247_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1310_tgt
    .local int rx1310_pos
    .local int rx1310_off
    .local int rx1310_eos
    .local int rx1310_rep
    .local pmc rx1310_cur
    .local pmc rx1310_debug
    (rx1310_cur, rx1310_pos, rx1310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1310_cur
    .local pmc match
    .lex "$/", match
    length rx1310_eos, rx1310_tgt
    gt rx1310_pos, rx1310_eos, rx1310_done
    set rx1310_off, 0
    lt rx1310_pos, 2, rx1310_start
    sub rx1310_off, rx1310_pos, 1
    substr rx1310_tgt, rx1310_tgt, rx1310_off
  rx1310_start:
    eq $I10, 1, rx1310_restart
    if_null rx1310_debug, debug_1137
    rx1310_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1137:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1314_done
    goto rxscan1314_scan
  rxscan1314_loop:
    (rx1310_pos) = rx1310_cur."from"()
    inc rx1310_pos
    rx1310_cur."!cursor_from"(rx1310_pos)
    ge rx1310_pos, rx1310_eos, rxscan1314_done
  rxscan1314_scan:
    set_addr $I10, rxscan1314_loop
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  rxscan1314_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1315_fail
    rx1310_cur."!mark_push"(0, rx1310_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1310_pos, 1
    gt $I11, rx1310_eos, rx1310_fail
    sub $I11, rx1310_pos, rx1310_off
    ord $I11, rx1310_tgt, $I11
    ne $I11, 81, rx1310_fail
    add rx1310_pos, 1
    set_addr $I10, rxcap_1315_fail
    ($I12, $I11) = rx1310_cur."!mark_peek"($I10)
    rx1310_cur."!cursor_pos"($I11)
    ($P10) = rx1310_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1310_pos, "")
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1315_done
  rxcap_1315_fail:
    goto rx1310_fail
  rxcap_1315_done:
  # rxanchor rwb
    le rx1310_pos, 0, rx1310_fail
    sub $I10, rx1310_pos, rx1310_off
    is_cclass $I11, 8192, rx1310_tgt, $I10
    if $I11, rx1310_fail
    dec $I10
    is_cclass $I11, 8192, rx1310_tgt, $I10
    unless $I11, rx1310_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1310_pos, rx1310_off
    substr $S10, rx1310_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1310_fail
  # rx subrule "ws" subtype=method negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."ws"()
    unless $P10, rx1310_fail
    rx1310_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1310_cur."!cursor_pos"(rx1310_pos)
    $P10 = rx1310_cur."quote_EXPR"()
    unless $P10, rx1310_fail
    rx1310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1310_pos = $P10."pos"()
  # rx pass
    rx1310_cur."!cursor_pass"(rx1310_pos, "quote:sym<Q>")
    if_null rx1310_debug, debug_1138
    rx1310_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1310_pos)
  debug_1138:
    .return (rx1310_cur)
  rx1310_restart:
.annotate 'line', 10
    if_null rx1310_debug, debug_1139
    rx1310_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1139:
  rx1310_fail:
    (rx1310_rep, rx1310_pos, $I10, $P10) = rx1310_cur."!mark_fail"(0)
    lt rx1310_pos, -1, rx1310_done
    eq rx1310_pos, -1, rx1310_fail
    jump $I10
  rx1310_done:
    rx1310_cur."!cursor_fail"()
    if_null rx1310_debug, debug_1140
    rx1310_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1140:
    .return (rx1310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("248_1303603603.711") :method
.annotate 'line', 10
    $P1312 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1313, "ResizablePMCArray"
    push $P1313, $P1312
    .return ($P1313)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("249_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1317_tgt
    .local int rx1317_pos
    .local int rx1317_off
    .local int rx1317_eos
    .local int rx1317_rep
    .local pmc rx1317_cur
    .local pmc rx1317_debug
    (rx1317_cur, rx1317_pos, rx1317_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1317_cur
    .local pmc match
    .lex "$/", match
    length rx1317_eos, rx1317_tgt
    gt rx1317_pos, rx1317_eos, rx1317_done
    set rx1317_off, 0
    lt rx1317_pos, 2, rx1317_start
    sub rx1317_off, rx1317_pos, 1
    substr rx1317_tgt, rx1317_tgt, rx1317_off
  rx1317_start:
    eq $I10, 1, rx1317_restart
    if_null rx1317_debug, debug_1141
    rx1317_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1141:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1321_done
    goto rxscan1321_scan
  rxscan1321_loop:
    (rx1317_pos) = rx1317_cur."from"()
    inc rx1317_pos
    rx1317_cur."!cursor_from"(rx1317_pos)
    ge rx1317_pos, rx1317_eos, rxscan1321_done
  rxscan1321_scan:
    set_addr $I10, rxscan1321_loop
    rx1317_cur."!mark_push"(0, rx1317_pos, $I10)
  rxscan1321_done:
.annotate 'line', 583
  # rx subcapture "sym"
    set_addr $I10, rxcap_1322_fail
    rx1317_cur."!mark_push"(0, rx1317_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1317_pos, 5
    gt $I11, rx1317_eos, rx1317_fail
    sub $I11, rx1317_pos, rx1317_off
    substr $S10, rx1317_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1317_fail
    add rx1317_pos, 5
    set_addr $I10, rxcap_1322_fail
    ($I12, $I11) = rx1317_cur."!mark_peek"($I10)
    rx1317_cur."!cursor_pos"($I11)
    ($P10) = rx1317_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1317_pos, "")
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1322_done
  rxcap_1322_fail:
    goto rx1317_fail
  rxcap_1322_done:
  # rx subrule "ws" subtype=method negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."ws"()
    unless $P10, rx1317_fail
    rx1317_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."quote_EXPR"()
    unless $P10, rx1317_fail
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1317_pos = $P10."pos"()
  # rx pass
    rx1317_cur."!cursor_pass"(rx1317_pos, "quote:sym<Q:PIR>")
    if_null rx1317_debug, debug_1142
    rx1317_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1317_pos)
  debug_1142:
    .return (rx1317_cur)
  rx1317_restart:
.annotate 'line', 10
    if_null rx1317_debug, debug_1143
    rx1317_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1143:
  rx1317_fail:
    (rx1317_rep, rx1317_pos, $I10, $P10) = rx1317_cur."!mark_fail"(0)
    lt rx1317_pos, -1, rx1317_done
    eq rx1317_pos, -1, rx1317_fail
    jump $I10
  rx1317_done:
    rx1317_cur."!cursor_fail"()
    if_null rx1317_debug, debug_1144
    rx1317_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1144:
    .return (rx1317_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("250_1303603603.711") :method
.annotate 'line', 10
    $P1319 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1320, "ResizablePMCArray"
    push $P1320, $P1319
    .return ($P1320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("251_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1324_tgt
    .local int rx1324_pos
    .local int rx1324_off
    .local int rx1324_eos
    .local int rx1324_rep
    .local pmc rx1324_cur
    .local pmc rx1324_debug
    (rx1324_cur, rx1324_pos, rx1324_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1324_cur
    .local pmc match
    .lex "$/", match
    length rx1324_eos, rx1324_tgt
    gt rx1324_pos, rx1324_eos, rx1324_done
    set rx1324_off, 0
    lt rx1324_pos, 2, rx1324_start
    sub rx1324_off, rx1324_pos, 1
    substr rx1324_tgt, rx1324_tgt, rx1324_off
  rx1324_start:
    eq $I10, 1, rx1324_restart
    if_null rx1324_debug, debug_1145
    rx1324_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1145:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1328_done
    goto rxscan1328_scan
  rxscan1328_loop:
    (rx1324_pos) = rx1324_cur."from"()
    inc rx1324_pos
    rx1324_cur."!cursor_from"(rx1324_pos)
    ge rx1324_pos, rx1324_eos, rxscan1328_done
  rxscan1328_scan:
    set_addr $I10, rxscan1328_loop
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  rxscan1328_done:
.annotate 'line', 585
  # rx literal  "/"
    add $I11, rx1324_pos, 1
    gt $I11, rx1324_eos, rx1324_fail
    sub $I11, rx1324_pos, rx1324_off
    ord $I11, rx1324_tgt, $I11
    ne $I11, 47, rx1324_fail
    add rx1324_pos, 1
.annotate 'line', 586
  # rx subrule "newpad" subtype=method negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."newpad"()
    unless $P10, rx1324_fail
    rx1324_pos = $P10."pos"()
.annotate 'line', 587
  # rx reduce name="quote:sym</ />" key="open"
    rx1324_cur."!cursor_pos"(rx1324_pos)
    rx1324_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 588
  # rx subrule "LANG" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1324_pos = $P10."pos"()
.annotate 'line', 589
  # rx literal  "/"
    add $I11, rx1324_pos, 1
    gt $I11, rx1324_eos, rx1324_fail
    sub $I11, rx1324_pos, rx1324_off
    ord $I11, rx1324_tgt, $I11
    ne $I11, 47, rx1324_fail
    add rx1324_pos, 1
.annotate 'line', 584
  # rx pass
    rx1324_cur."!cursor_pass"(rx1324_pos, "quote:sym</ />")
    if_null rx1324_debug, debug_1146
    rx1324_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1324_pos)
  debug_1146:
    .return (rx1324_cur)
  rx1324_restart:
.annotate 'line', 10
    if_null rx1324_debug, debug_1147
    rx1324_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1147:
  rx1324_fail:
    (rx1324_rep, rx1324_pos, $I10, $P10) = rx1324_cur."!mark_fail"(0)
    lt rx1324_pos, -1, rx1324_done
    eq rx1324_pos, -1, rx1324_fail
    jump $I10
  rx1324_done:
    rx1324_cur."!cursor_fail"()
    if_null rx1324_debug, debug_1148
    rx1324_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1148:
    .return (rx1324_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("252_1303603603.711") :method
.annotate 'line', 10
    $P1326 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1327, "ResizablePMCArray"
    push $P1327, $P1326
    .return ($P1327)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("253_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1330_tgt
    .local int rx1330_pos
    .local int rx1330_off
    .local int rx1330_eos
    .local int rx1330_rep
    .local pmc rx1330_cur
    .local pmc rx1330_debug
    (rx1330_cur, rx1330_pos, rx1330_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1330_cur
    .local pmc match
    .lex "$/", match
    length rx1330_eos, rx1330_tgt
    gt rx1330_pos, rx1330_eos, rx1330_done
    set rx1330_off, 0
    lt rx1330_pos, 2, rx1330_start
    sub rx1330_off, rx1330_pos, 1
    substr rx1330_tgt, rx1330_tgt, rx1330_off
  rx1330_start:
    eq $I10, 1, rx1330_restart
    if_null rx1330_debug, debug_1149
    rx1330_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1149:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1333_done
    goto rxscan1333_scan
  rxscan1333_loop:
    (rx1330_pos) = rx1330_cur."from"()
    inc rx1330_pos
    rx1330_cur."!cursor_from"(rx1330_pos)
    ge rx1330_pos, rx1330_eos, rxscan1333_done
  rxscan1333_scan:
    set_addr $I10, rxscan1333_loop
    rx1330_cur."!mark_push"(0, rx1330_pos, $I10)
  rxscan1333_done:
.annotate 'line', 592
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1330_pos, rx1330_off
    substr $S10, rx1330_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1330_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1330_cur."!cursor_pos"(rx1330_pos)
    $P10 = rx1330_cur."quotemod_check"("s")
    unless $P10, rx1330_fail
  # rx subrule "variable" subtype=capture negate=
    rx1330_cur."!cursor_pos"(rx1330_pos)
    $P10 = rx1330_cur."variable"()
    unless $P10, rx1330_fail
    rx1330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1330_pos = $P10."pos"()
  # rx pass
    rx1330_cur."!cursor_pass"(rx1330_pos, "quote_escape:sym<$>")
    if_null rx1330_debug, debug_1150
    rx1330_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1330_pos)
  debug_1150:
    .return (rx1330_cur)
  rx1330_restart:
.annotate 'line', 10
    if_null rx1330_debug, debug_1151
    rx1330_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1151:
  rx1330_fail:
    (rx1330_rep, rx1330_pos, $I10, $P10) = rx1330_cur."!mark_fail"(0)
    lt rx1330_pos, -1, rx1330_done
    eq rx1330_pos, -1, rx1330_fail
    jump $I10
  rx1330_done:
    rx1330_cur."!cursor_fail"()
    if_null rx1330_debug, debug_1152
    rx1330_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1152:
    .return (rx1330_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("254_1303603603.711") :method
.annotate 'line', 10
    new $P1332, "ResizablePMCArray"
    push $P1332, "$"
    .return ($P1332)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("255_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1335_tgt
    .local int rx1335_pos
    .local int rx1335_off
    .local int rx1335_eos
    .local int rx1335_rep
    .local pmc rx1335_cur
    .local pmc rx1335_debug
    (rx1335_cur, rx1335_pos, rx1335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1335_cur
    .local pmc match
    .lex "$/", match
    length rx1335_eos, rx1335_tgt
    gt rx1335_pos, rx1335_eos, rx1335_done
    set rx1335_off, 0
    lt rx1335_pos, 2, rx1335_start
    sub rx1335_off, rx1335_pos, 1
    substr rx1335_tgt, rx1335_tgt, rx1335_off
  rx1335_start:
    eq $I10, 1, rx1335_restart
    if_null rx1335_debug, debug_1153
    rx1335_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1153:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1338_done
    goto rxscan1338_scan
  rxscan1338_loop:
    (rx1335_pos) = rx1335_cur."from"()
    inc rx1335_pos
    rx1335_cur."!cursor_from"(rx1335_pos)
    ge rx1335_pos, rx1335_eos, rxscan1338_done
  rxscan1338_scan:
    set_addr $I10, rxscan1338_loop
    rx1335_cur."!mark_push"(0, rx1335_pos, $I10)
  rxscan1338_done:
.annotate 'line', 593
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1335_pos, rx1335_off
    substr $S10, rx1335_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1335_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1335_cur."!cursor_pos"(rx1335_pos)
    $P10 = rx1335_cur."quotemod_check"("c")
    unless $P10, rx1335_fail
  # rx subrule "block" subtype=capture negate=
    rx1335_cur."!cursor_pos"(rx1335_pos)
    $P10 = rx1335_cur."block"()
    unless $P10, rx1335_fail
    rx1335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1335_pos = $P10."pos"()
  # rx pass
    rx1335_cur."!cursor_pass"(rx1335_pos, "quote_escape:sym<{ }>")
    if_null rx1335_debug, debug_1154
    rx1335_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1335_pos)
  debug_1154:
    .return (rx1335_cur)
  rx1335_restart:
.annotate 'line', 10
    if_null rx1335_debug, debug_1155
    rx1335_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1155:
  rx1335_fail:
    (rx1335_rep, rx1335_pos, $I10, $P10) = rx1335_cur."!mark_fail"(0)
    lt rx1335_pos, -1, rx1335_done
    eq rx1335_pos, -1, rx1335_fail
    jump $I10
  rx1335_done:
    rx1335_cur."!cursor_fail"()
    if_null rx1335_debug, debug_1156
    rx1335_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1156:
    .return (rx1335_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("256_1303603603.711") :method
.annotate 'line', 10
    new $P1337, "ResizablePMCArray"
    push $P1337, "{"
    .return ($P1337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("257_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1340_tgt
    .local int rx1340_pos
    .local int rx1340_off
    .local int rx1340_eos
    .local int rx1340_rep
    .local pmc rx1340_cur
    .local pmc rx1340_debug
    (rx1340_cur, rx1340_pos, rx1340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1340_cur
    .local pmc match
    .lex "$/", match
    length rx1340_eos, rx1340_tgt
    gt rx1340_pos, rx1340_eos, rx1340_done
    set rx1340_off, 0
    lt rx1340_pos, 2, rx1340_start
    sub rx1340_off, rx1340_pos, 1
    substr rx1340_tgt, rx1340_tgt, rx1340_off
  rx1340_start:
    eq $I10, 1, rx1340_restart
    if_null rx1340_debug, debug_1157
    rx1340_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1157:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1343_done
    goto rxscan1343_scan
  rxscan1343_loop:
    (rx1340_pos) = rx1340_cur."from"()
    inc rx1340_pos
    rx1340_cur."!cursor_from"(rx1340_pos)
    ge rx1340_pos, rx1340_eos, rxscan1343_done
  rxscan1343_scan:
    set_addr $I10, rxscan1343_loop
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxscan1343_done:
.annotate 'line', 594
  # rx literal  "\\e"
    add $I11, rx1340_pos, 2
    gt $I11, rx1340_eos, rx1340_fail
    sub $I11, rx1340_pos, rx1340_off
    substr $S10, rx1340_tgt, $I11, 2
    ne $S10, "\\e", rx1340_fail
    add rx1340_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."quotemod_check"("b")
    unless $P10, rx1340_fail
  # rx pass
    rx1340_cur."!cursor_pass"(rx1340_pos, "quote_escape:sym<esc>")
    if_null rx1340_debug, debug_1158
    rx1340_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1340_pos)
  debug_1158:
    .return (rx1340_cur)
  rx1340_restart:
.annotate 'line', 10
    if_null rx1340_debug, debug_1159
    rx1340_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1159:
  rx1340_fail:
    (rx1340_rep, rx1340_pos, $I10, $P10) = rx1340_cur."!mark_fail"(0)
    lt rx1340_pos, -1, rx1340_done
    eq rx1340_pos, -1, rx1340_fail
    jump $I10
  rx1340_done:
    rx1340_cur."!cursor_fail"()
    if_null rx1340_debug, debug_1160
    rx1340_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1160:
    .return (rx1340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("258_1303603603.711") :method
.annotate 'line', 10
    new $P1342, "ResizablePMCArray"
    push $P1342, "\\e"
    .return ($P1342)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("259_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1345_tgt
    .local int rx1345_pos
    .local int rx1345_off
    .local int rx1345_eos
    .local int rx1345_rep
    .local pmc rx1345_cur
    .local pmc rx1345_debug
    (rx1345_cur, rx1345_pos, rx1345_tgt, $I10) = self."!cursor_start"()
    rx1345_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1345_cur
    .local pmc match
    .lex "$/", match
    length rx1345_eos, rx1345_tgt
    gt rx1345_pos, rx1345_eos, rx1345_done
    set rx1345_off, 0
    lt rx1345_pos, 2, rx1345_start
    sub rx1345_off, rx1345_pos, 1
    substr rx1345_tgt, rx1345_tgt, rx1345_off
  rx1345_start:
    eq $I10, 1, rx1345_restart
    if_null rx1345_debug, debug_1161
    rx1345_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1349_done
    goto rxscan1349_scan
  rxscan1349_loop:
    (rx1345_pos) = rx1345_cur."from"()
    inc rx1345_pos
    rx1345_cur."!cursor_from"(rx1345_pos)
    ge rx1345_pos, rx1345_eos, rxscan1349_done
  rxscan1349_scan:
    set_addr $I10, rxscan1349_loop
    rx1345_cur."!mark_push"(0, rx1345_pos, $I10)
  rxscan1349_done:
.annotate 'line', 596
  # rx literal  "("
    add $I11, rx1345_pos, 1
    gt $I11, rx1345_eos, rx1345_fail
    sub $I11, rx1345_pos, rx1345_off
    ord $I11, rx1345_tgt, $I11
    ne $I11, 40, rx1345_fail
    add rx1345_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1345_cur."!cursor_pos"(rx1345_pos)
    $P10 = rx1345_cur."ws"()
    unless $P10, rx1345_fail
    rx1345_pos = $P10."pos"()
  # rx rxquantr1350 ** 0..1
    set_addr $I10, rxquantr1350_done
    rx1345_cur."!mark_push"(0, rx1345_pos, $I10)
  rxquantr1350_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1345_cur."!cursor_pos"(rx1345_pos)
    $P10 = rx1345_cur."EXPR"()
    unless $P10, rx1345_fail
    goto rxsubrule1351_pass
  rxsubrule1351_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1345_fail
  rxsubrule1351_pass:
    set_addr $I10, rxsubrule1351_back
    rx1345_cur."!mark_push"(0, rx1345_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1345_pos = $P10."pos"()
    set_addr $I10, rxquantr1350_done
    (rx1345_rep) = rx1345_cur."!mark_commit"($I10)
  rxquantr1350_done:
  # rx literal  ")"
    add $I11, rx1345_pos, 1
    gt $I11, rx1345_eos, rx1345_fail
    sub $I11, rx1345_pos, rx1345_off
    ord $I11, rx1345_tgt, $I11
    ne $I11, 41, rx1345_fail
    add rx1345_pos, 1
  # rx pass
    rx1345_cur."!cursor_pass"(rx1345_pos, "circumfix:sym<( )>")
    if_null rx1345_debug, debug_1162
    rx1345_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1345_pos)
  debug_1162:
    .return (rx1345_cur)
  rx1345_restart:
.annotate 'line', 10
    if_null rx1345_debug, debug_1163
    rx1345_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1163:
  rx1345_fail:
    (rx1345_rep, rx1345_pos, $I10, $P10) = rx1345_cur."!mark_fail"(0)
    lt rx1345_pos, -1, rx1345_done
    eq rx1345_pos, -1, rx1345_fail
    jump $I10
  rx1345_done:
    rx1345_cur."!cursor_fail"()
    if_null rx1345_debug, debug_1164
    rx1345_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1164:
    .return (rx1345_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("260_1303603603.711") :method
.annotate 'line', 10
    $P1347 = self."!PREFIX__!subrule"("ws", "(")
    new $P1348, "ResizablePMCArray"
    push $P1348, $P1347
    .return ($P1348)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("261_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1353_tgt
    .local int rx1353_pos
    .local int rx1353_off
    .local int rx1353_eos
    .local int rx1353_rep
    .local pmc rx1353_cur
    .local pmc rx1353_debug
    (rx1353_cur, rx1353_pos, rx1353_tgt, $I10) = self."!cursor_start"()
    rx1353_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1353_cur
    .local pmc match
    .lex "$/", match
    length rx1353_eos, rx1353_tgt
    gt rx1353_pos, rx1353_eos, rx1353_done
    set rx1353_off, 0
    lt rx1353_pos, 2, rx1353_start
    sub rx1353_off, rx1353_pos, 1
    substr rx1353_tgt, rx1353_tgt, rx1353_off
  rx1353_start:
    eq $I10, 1, rx1353_restart
    if_null rx1353_debug, debug_1165
    rx1353_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1165:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1357_done
    goto rxscan1357_scan
  rxscan1357_loop:
    (rx1353_pos) = rx1353_cur."from"()
    inc rx1353_pos
    rx1353_cur."!cursor_from"(rx1353_pos)
    ge rx1353_pos, rx1353_eos, rxscan1357_done
  rxscan1357_scan:
    set_addr $I10, rxscan1357_loop
    rx1353_cur."!mark_push"(0, rx1353_pos, $I10)
  rxscan1357_done:
.annotate 'line', 597
  # rx literal  "["
    add $I11, rx1353_pos, 1
    gt $I11, rx1353_eos, rx1353_fail
    sub $I11, rx1353_pos, rx1353_off
    ord $I11, rx1353_tgt, $I11
    ne $I11, 91, rx1353_fail
    add rx1353_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1353_cur."!cursor_pos"(rx1353_pos)
    $P10 = rx1353_cur."ws"()
    unless $P10, rx1353_fail
    rx1353_pos = $P10."pos"()
  # rx rxquantr1358 ** 0..1
    set_addr $I10, rxquantr1358_done
    rx1353_cur."!mark_push"(0, rx1353_pos, $I10)
  rxquantr1358_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1353_cur."!cursor_pos"(rx1353_pos)
    $P10 = rx1353_cur."EXPR"()
    unless $P10, rx1353_fail
    goto rxsubrule1359_pass
  rxsubrule1359_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1353_fail
  rxsubrule1359_pass:
    set_addr $I10, rxsubrule1359_back
    rx1353_cur."!mark_push"(0, rx1353_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1353_pos = $P10."pos"()
    set_addr $I10, rxquantr1358_done
    (rx1353_rep) = rx1353_cur."!mark_commit"($I10)
  rxquantr1358_done:
  # rx literal  "]"
    add $I11, rx1353_pos, 1
    gt $I11, rx1353_eos, rx1353_fail
    sub $I11, rx1353_pos, rx1353_off
    ord $I11, rx1353_tgt, $I11
    ne $I11, 93, rx1353_fail
    add rx1353_pos, 1
  # rx pass
    rx1353_cur."!cursor_pass"(rx1353_pos, "circumfix:sym<[ ]>")
    if_null rx1353_debug, debug_1166
    rx1353_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1353_pos)
  debug_1166:
    .return (rx1353_cur)
  rx1353_restart:
.annotate 'line', 10
    if_null rx1353_debug, debug_1167
    rx1353_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1167:
  rx1353_fail:
    (rx1353_rep, rx1353_pos, $I10, $P10) = rx1353_cur."!mark_fail"(0)
    lt rx1353_pos, -1, rx1353_done
    eq rx1353_pos, -1, rx1353_fail
    jump $I10
  rx1353_done:
    rx1353_cur."!cursor_fail"()
    if_null rx1353_debug, debug_1168
    rx1353_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1168:
    .return (rx1353_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("262_1303603603.711") :method
.annotate 'line', 10
    $P1355 = self."!PREFIX__!subrule"("ws", "[")
    new $P1356, "ResizablePMCArray"
    push $P1356, $P1355
    .return ($P1356)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("263_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1361_tgt
    .local int rx1361_pos
    .local int rx1361_off
    .local int rx1361_eos
    .local int rx1361_rep
    .local pmc rx1361_cur
    .local pmc rx1361_debug
    (rx1361_cur, rx1361_pos, rx1361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1361_cur
    .local pmc match
    .lex "$/", match
    length rx1361_eos, rx1361_tgt
    gt rx1361_pos, rx1361_eos, rx1361_done
    set rx1361_off, 0
    lt rx1361_pos, 2, rx1361_start
    sub rx1361_off, rx1361_pos, 1
    substr rx1361_tgt, rx1361_tgt, rx1361_off
  rx1361_start:
    eq $I10, 1, rx1361_restart
    if_null rx1361_debug, debug_1169
    rx1361_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1169:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1364_done
    goto rxscan1364_scan
  rxscan1364_loop:
    (rx1361_pos) = rx1361_cur."from"()
    inc rx1361_pos
    rx1361_cur."!cursor_from"(rx1361_pos)
    ge rx1361_pos, rx1361_eos, rxscan1364_done
  rxscan1364_scan:
    set_addr $I10, rxscan1364_loop
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  rxscan1364_done:
.annotate 'line', 598
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1361_pos, rx1361_off
    substr $S10, rx1361_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1361_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1361_cur."!cursor_pos"(rx1361_pos)
    $P10 = rx1361_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1361_fail
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1361_pos = $P10."pos"()
  # rx pass
    rx1361_cur."!cursor_pass"(rx1361_pos, "circumfix:sym<ang>")
    if_null rx1361_debug, debug_1170
    rx1361_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1361_pos)
  debug_1170:
    .return (rx1361_cur)
  rx1361_restart:
.annotate 'line', 10
    if_null rx1361_debug, debug_1171
    rx1361_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1171:
  rx1361_fail:
    (rx1361_rep, rx1361_pos, $I10, $P10) = rx1361_cur."!mark_fail"(0)
    lt rx1361_pos, -1, rx1361_done
    eq rx1361_pos, -1, rx1361_fail
    jump $I10
  rx1361_done:
    rx1361_cur."!cursor_fail"()
    if_null rx1361_debug, debug_1172
    rx1361_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1172:
    .return (rx1361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("264_1303603603.711") :method
.annotate 'line', 10
    new $P1363, "ResizablePMCArray"
    push $P1363, "<"
    .return ($P1363)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("265_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1366_tgt
    .local int rx1366_pos
    .local int rx1366_off
    .local int rx1366_eos
    .local int rx1366_rep
    .local pmc rx1366_cur
    .local pmc rx1366_debug
    (rx1366_cur, rx1366_pos, rx1366_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1366_cur
    .local pmc match
    .lex "$/", match
    length rx1366_eos, rx1366_tgt
    gt rx1366_pos, rx1366_eos, rx1366_done
    set rx1366_off, 0
    lt rx1366_pos, 2, rx1366_start
    sub rx1366_off, rx1366_pos, 1
    substr rx1366_tgt, rx1366_tgt, rx1366_off
  rx1366_start:
    eq $I10, 1, rx1366_restart
    if_null rx1366_debug, debug_1173
    rx1366_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1173:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1369_done
    goto rxscan1369_scan
  rxscan1369_loop:
    (rx1366_pos) = rx1366_cur."from"()
    inc rx1366_pos
    rx1366_cur."!cursor_from"(rx1366_pos)
    ge rx1366_pos, rx1366_eos, rxscan1369_done
  rxscan1369_scan:
    set_addr $I10, rxscan1369_loop
    rx1366_cur."!mark_push"(0, rx1366_pos, $I10)
  rxscan1369_done:
.annotate 'line', 599
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1366_pos, rx1366_off
    substr $S10, rx1366_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1366_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1366_cur."!cursor_pos"(rx1366_pos)
    $P10 = rx1366_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1366_fail
    rx1366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1366_pos = $P10."pos"()
  # rx pass
    rx1366_cur."!cursor_pass"(rx1366_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1366_debug, debug_1174
    rx1366_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1366_pos)
  debug_1174:
    .return (rx1366_cur)
  rx1366_restart:
.annotate 'line', 10
    if_null rx1366_debug, debug_1175
    rx1366_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1175:
  rx1366_fail:
    (rx1366_rep, rx1366_pos, $I10, $P10) = rx1366_cur."!mark_fail"(0)
    lt rx1366_pos, -1, rx1366_done
    eq rx1366_pos, -1, rx1366_fail
    jump $I10
  rx1366_done:
    rx1366_cur."!cursor_fail"()
    if_null rx1366_debug, debug_1176
    rx1366_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1176:
    .return (rx1366_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("266_1303603603.711") :method
.annotate 'line', 10
    new $P1368, "ResizablePMCArray"
    push $P1368, unicode:"\x{ab}"
    .return ($P1368)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("267_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1371_tgt
    .local int rx1371_pos
    .local int rx1371_off
    .local int rx1371_eos
    .local int rx1371_rep
    .local pmc rx1371_cur
    .local pmc rx1371_debug
    (rx1371_cur, rx1371_pos, rx1371_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1371_cur
    .local pmc match
    .lex "$/", match
    length rx1371_eos, rx1371_tgt
    gt rx1371_pos, rx1371_eos, rx1371_done
    set rx1371_off, 0
    lt rx1371_pos, 2, rx1371_start
    sub rx1371_off, rx1371_pos, 1
    substr rx1371_tgt, rx1371_tgt, rx1371_off
  rx1371_start:
    eq $I10, 1, rx1371_restart
    if_null rx1371_debug, debug_1177
    rx1371_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1177:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1374_done
    goto rxscan1374_scan
  rxscan1374_loop:
    (rx1371_pos) = rx1371_cur."from"()
    inc rx1371_pos
    rx1371_cur."!cursor_from"(rx1371_pos)
    ge rx1371_pos, rx1371_eos, rxscan1374_done
  rxscan1374_scan:
    set_addr $I10, rxscan1374_loop
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxscan1374_done:
.annotate 'line', 600
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1371_pos, rx1371_off
    substr $S10, rx1371_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1371_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."pblock"()
    unless $P10, rx1371_fail
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1371_pos = $P10."pos"()
  # rx pass
    rx1371_cur."!cursor_pass"(rx1371_pos, "circumfix:sym<{ }>")
    if_null rx1371_debug, debug_1178
    rx1371_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1371_pos)
  debug_1178:
    .return (rx1371_cur)
  rx1371_restart:
.annotate 'line', 10
    if_null rx1371_debug, debug_1179
    rx1371_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1179:
  rx1371_fail:
    (rx1371_rep, rx1371_pos, $I10, $P10) = rx1371_cur."!mark_fail"(0)
    lt rx1371_pos, -1, rx1371_done
    eq rx1371_pos, -1, rx1371_fail
    jump $I10
  rx1371_done:
    rx1371_cur."!cursor_fail"()
    if_null rx1371_debug, debug_1180
    rx1371_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1180:
    .return (rx1371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("268_1303603603.711") :method
.annotate 'line', 10
    new $P1373, "ResizablePMCArray"
    push $P1373, "{"
    .return ($P1373)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("269_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1376_tgt
    .local int rx1376_pos
    .local int rx1376_off
    .local int rx1376_eos
    .local int rx1376_rep
    .local pmc rx1376_cur
    .local pmc rx1376_debug
    (rx1376_cur, rx1376_pos, rx1376_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1376_cur
    .local pmc match
    .lex "$/", match
    length rx1376_eos, rx1376_tgt
    gt rx1376_pos, rx1376_eos, rx1376_done
    set rx1376_off, 0
    lt rx1376_pos, 2, rx1376_start
    sub rx1376_off, rx1376_pos, 1
    substr rx1376_tgt, rx1376_tgt, rx1376_off
  rx1376_start:
    eq $I10, 1, rx1376_restart
    if_null rx1376_debug, debug_1181
    rx1376_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1181:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1380_done
    goto rxscan1380_scan
  rxscan1380_loop:
    (rx1376_pos) = rx1376_cur."from"()
    inc rx1376_pos
    rx1376_cur."!cursor_from"(rx1376_pos)
    ge rx1376_pos, rx1376_eos, rxscan1380_done
  rxscan1380_scan:
    set_addr $I10, rxscan1380_loop
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10)
  rxscan1380_done:
.annotate 'line', 601
  # rx subrule "sigil" subtype=capture negate=
    rx1376_cur."!cursor_pos"(rx1376_pos)
    $P10 = rx1376_cur."sigil"()
    unless $P10, rx1376_fail
    rx1376_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1376_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1376_pos, 1
    gt $I11, rx1376_eos, rx1376_fail
    sub $I11, rx1376_pos, rx1376_off
    ord $I11, rx1376_tgt, $I11
    ne $I11, 40, rx1376_fail
    add rx1376_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1376_cur."!cursor_pos"(rx1376_pos)
    $P10 = rx1376_cur."semilist"()
    unless $P10, rx1376_fail
    rx1376_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1376_pos = $P10."pos"()
  alt1381_0:
    set_addr $I10, alt1381_1
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10)
  # rx literal  ")"
    add $I11, rx1376_pos, 1
    gt $I11, rx1376_eos, rx1376_fail
    sub $I11, rx1376_pos, rx1376_off
    ord $I11, rx1376_tgt, $I11
    ne $I11, 41, rx1376_fail
    add rx1376_pos, 1
    goto alt1381_end
  alt1381_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1376_cur."!cursor_pos"(rx1376_pos)
    $P10 = rx1376_cur."FAILGOAL"("')'")
    unless $P10, rx1376_fail
    goto rxsubrule1383_pass
  rxsubrule1383_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1376_fail
  rxsubrule1383_pass:
    set_addr $I10, rxsubrule1383_back
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10, $P10)
    rx1376_pos = $P10."pos"()
  alt1381_end:
  # rx pass
    rx1376_cur."!cursor_pass"(rx1376_pos, "circumfix:sym<sigil>")
    if_null rx1376_debug, debug_1182
    rx1376_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1376_pos)
  debug_1182:
    .return (rx1376_cur)
  rx1376_restart:
.annotate 'line', 10
    if_null rx1376_debug, debug_1183
    rx1376_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1183:
  rx1376_fail:
    (rx1376_rep, rx1376_pos, $I10, $P10) = rx1376_cur."!mark_fail"(0)
    lt rx1376_pos, -1, rx1376_done
    eq rx1376_pos, -1, rx1376_fail
    jump $I10
  rx1376_done:
    rx1376_cur."!cursor_fail"()
    if_null rx1376_debug, debug_1184
    rx1376_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1184:
    .return (rx1376_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("270_1303603603.711") :method
.annotate 'line', 10
    $P1378 = self."!PREFIX__!subrule"("sigil", "")
    new $P1379, "ResizablePMCArray"
    push $P1379, $P1378
    .return ($P1379)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("271_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1385_tgt
    .local int rx1385_pos
    .local int rx1385_off
    .local int rx1385_eos
    .local int rx1385_rep
    .local pmc rx1385_cur
    .local pmc rx1385_debug
    (rx1385_cur, rx1385_pos, rx1385_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1385_cur
    .local pmc match
    .lex "$/", match
    length rx1385_eos, rx1385_tgt
    gt rx1385_pos, rx1385_eos, rx1385_done
    set rx1385_off, 0
    lt rx1385_pos, 2, rx1385_start
    sub rx1385_off, rx1385_pos, 1
    substr rx1385_tgt, rx1385_tgt, rx1385_off
  rx1385_start:
    eq $I10, 1, rx1385_restart
    if_null rx1385_debug, debug_1185
    rx1385_cur."!cursor_debug"("START", "semilist")
  debug_1185:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1389_done
    goto rxscan1389_scan
  rxscan1389_loop:
    (rx1385_pos) = rx1385_cur."from"()
    inc rx1385_pos
    rx1385_cur."!cursor_from"(rx1385_pos)
    ge rx1385_pos, rx1385_eos, rxscan1389_done
  rxscan1389_scan:
    set_addr $I10, rxscan1389_loop
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  rxscan1389_done:
.annotate 'line', 603
  # rx subrule "ws" subtype=method negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."ws"()
    unless $P10, rx1385_fail
    rx1385_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."statement"()
    unless $P10, rx1385_fail
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1385_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."ws"()
    unless $P10, rx1385_fail
    rx1385_pos = $P10."pos"()
  # rx pass
    rx1385_cur."!cursor_pass"(rx1385_pos, "semilist")
    if_null rx1385_debug, debug_1186
    rx1385_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1385_pos)
  debug_1186:
    .return (rx1385_cur)
  rx1385_restart:
.annotate 'line', 10
    if_null rx1385_debug, debug_1187
    rx1385_cur."!cursor_debug"("NEXT", "semilist")
  debug_1187:
  rx1385_fail:
    (rx1385_rep, rx1385_pos, $I10, $P10) = rx1385_cur."!mark_fail"(0)
    lt rx1385_pos, -1, rx1385_done
    eq rx1385_pos, -1, rx1385_fail
    jump $I10
  rx1385_done:
    rx1385_cur."!cursor_fail"()
    if_null rx1385_debug, debug_1188
    rx1385_cur."!cursor_debug"("FAIL", "semilist")
  debug_1188:
    .return (rx1385_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("272_1303603603.711") :method
.annotate 'line', 10
    $P1387 = self."!PREFIX__!subrule"("ws", "")
    new $P1388, "ResizablePMCArray"
    push $P1388, $P1387
    .return ($P1388)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("273_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1393_tgt
    .local int rx1393_pos
    .local int rx1393_off
    .local int rx1393_eos
    .local int rx1393_rep
    .local pmc rx1393_cur
    .local pmc rx1393_debug
    (rx1393_cur, rx1393_pos, rx1393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1393_cur
    .local pmc match
    .lex "$/", match
    length rx1393_eos, rx1393_tgt
    gt rx1393_pos, rx1393_eos, rx1393_done
    set rx1393_off, 0
    lt rx1393_pos, 2, rx1393_start
    sub rx1393_off, rx1393_pos, 1
    substr rx1393_tgt, rx1393_tgt, rx1393_off
  rx1393_start:
    eq $I10, 1, rx1393_restart
    if_null rx1393_debug, debug_1189
    rx1393_cur."!cursor_debug"("START", "infixish")
  debug_1189:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1396_done
    goto rxscan1396_scan
  rxscan1396_loop:
    (rx1393_pos) = rx1393_cur."from"()
    inc rx1393_pos
    rx1393_cur."!cursor_from"(rx1393_pos)
    ge rx1393_pos, rx1393_eos, rxscan1396_done
  rxscan1396_scan:
    set_addr $I10, rxscan1396_loop
    rx1393_cur."!mark_push"(0, rx1393_pos, $I10)
  rxscan1396_done:
.annotate 'line', 626
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1393_cur."!cursor_pos"(rx1393_pos)
    $P10 = rx1393_cur."infixstopper"()
    if $P10, rx1393_fail
  # rx subrule "infix" subtype=capture negate=
    rx1393_cur."!cursor_pos"(rx1393_pos)
    $P10 = rx1393_cur."infix"()
    unless $P10, rx1393_fail
    rx1393_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1393_pos = $P10."pos"()
  # rx pass
    rx1393_cur."!cursor_pass"(rx1393_pos, "infixish")
    if_null rx1393_debug, debug_1190
    rx1393_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1393_pos)
  debug_1190:
    .return (rx1393_cur)
  rx1393_restart:
.annotate 'line', 10
    if_null rx1393_debug, debug_1191
    rx1393_cur."!cursor_debug"("NEXT", "infixish")
  debug_1191:
  rx1393_fail:
    (rx1393_rep, rx1393_pos, $I10, $P10) = rx1393_cur."!mark_fail"(0)
    lt rx1393_pos, -1, rx1393_done
    eq rx1393_pos, -1, rx1393_fail
    jump $I10
  rx1393_done:
    rx1393_cur."!cursor_fail"()
    if_null rx1393_debug, debug_1192
    rx1393_cur."!cursor_debug"("FAIL", "infixish")
  debug_1192:
    .return (rx1393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("274_1303603603.711") :method
.annotate 'line', 10
    new $P1395, "ResizablePMCArray"
    push $P1395, ""
    .return ($P1395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("275_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1398_tgt
    .local int rx1398_pos
    .local int rx1398_off
    .local int rx1398_eos
    .local int rx1398_rep
    .local pmc rx1398_cur
    .local pmc rx1398_debug
    (rx1398_cur, rx1398_pos, rx1398_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1398_cur
    .local pmc match
    .lex "$/", match
    length rx1398_eos, rx1398_tgt
    gt rx1398_pos, rx1398_eos, rx1398_done
    set rx1398_off, 0
    lt rx1398_pos, 2, rx1398_start
    sub rx1398_off, rx1398_pos, 1
    substr rx1398_tgt, rx1398_tgt, rx1398_off
  rx1398_start:
    eq $I10, 1, rx1398_restart
    if_null rx1398_debug, debug_1193
    rx1398_cur."!cursor_debug"("START", "infixstopper")
  debug_1193:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1401_done
    goto rxscan1401_scan
  rxscan1401_loop:
    (rx1398_pos) = rx1398_cur."from"()
    inc rx1398_pos
    rx1398_cur."!cursor_from"(rx1398_pos)
    ge rx1398_pos, rx1398_eos, rxscan1401_done
  rxscan1401_scan:
    set_addr $I10, rxscan1401_loop
    rx1398_cur."!mark_push"(0, rx1398_pos, $I10)
  rxscan1401_done:
.annotate 'line', 627
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1398_cur."!cursor_pos"(rx1398_pos)
    $P10 = rx1398_cur."lambda"()
    unless $P10, rx1398_fail
  # rx pass
    rx1398_cur."!cursor_pass"(rx1398_pos, "infixstopper")
    if_null rx1398_debug, debug_1194
    rx1398_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1398_pos)
  debug_1194:
    .return (rx1398_cur)
  rx1398_restart:
.annotate 'line', 10
    if_null rx1398_debug, debug_1195
    rx1398_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1195:
  rx1398_fail:
    (rx1398_rep, rx1398_pos, $I10, $P10) = rx1398_cur."!mark_fail"(0)
    lt rx1398_pos, -1, rx1398_done
    eq rx1398_pos, -1, rx1398_fail
    jump $I10
  rx1398_done:
    rx1398_cur."!cursor_fail"()
    if_null rx1398_debug, debug_1196
    rx1398_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1196:
    .return (rx1398_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("276_1303603603.711") :method
.annotate 'line', 10
    new $P1400, "ResizablePMCArray"
    push $P1400, ""
    .return ($P1400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("277_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_1197
    rx1403_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1197:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1407_done
    goto rxscan1407_scan
  rxscan1407_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1407_done
  rxscan1407_scan:
    set_addr $I10, rxscan1407_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1407_done:
.annotate 'line', 630
  # rx literal  "["
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 91, rx1403_fail
    add rx1403_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."ws"()
    unless $P10, rx1403_fail
    rx1403_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."EXPR"()
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1403_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1403_pos, 1
    gt $I11, rx1403_eos, rx1403_fail
    sub $I11, rx1403_pos, rx1403_off
    ord $I11, rx1403_tgt, $I11
    ne $I11, 93, rx1403_fail
    add rx1403_pos, 1
.annotate 'line', 631
  # rx subrule "O" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."O"("%methodop")
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1403_pos = $P10."pos"()
.annotate 'line', 629
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "postcircumfix:sym<[ ]>")
    if_null rx1403_debug, debug_1198
    rx1403_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1403_pos)
  debug_1198:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 10
    if_null rx1403_debug, debug_1199
    rx1403_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1199:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_1200
    rx1403_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1200:
    .return (rx1403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("278_1303603603.711") :method
.annotate 'line', 10
    $P1405 = self."!PREFIX__!subrule"("ws", "[")
    new $P1406, "ResizablePMCArray"
    push $P1406, $P1405
    .return ($P1406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("279_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_1201
    rx1409_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1201:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1413_done:
.annotate 'line', 635
  # rx literal  "{"
    add $I11, rx1409_pos, 1
    gt $I11, rx1409_eos, rx1409_fail
    sub $I11, rx1409_pos, rx1409_off
    ord $I11, rx1409_tgt, $I11
    ne $I11, 123, rx1409_fail
    add rx1409_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."ws"()
    unless $P10, rx1409_fail
    rx1409_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."EXPR"()
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1409_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1409_pos, 1
    gt $I11, rx1409_eos, rx1409_fail
    sub $I11, rx1409_pos, rx1409_off
    ord $I11, rx1409_tgt, $I11
    ne $I11, 125, rx1409_fail
    add rx1409_pos, 1
.annotate 'line', 636
  # rx subrule "O" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."O"("%methodop")
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1409_pos = $P10."pos"()
.annotate 'line', 634
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "postcircumfix:sym<{ }>")
    if_null rx1409_debug, debug_1202
    rx1409_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1409_pos)
  debug_1202:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 10
    if_null rx1409_debug, debug_1203
    rx1409_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1203:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_1204
    rx1409_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1204:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("280_1303603603.711") :method
.annotate 'line', 10
    $P1411 = self."!PREFIX__!subrule"("ws", "{")
    new $P1412, "ResizablePMCArray"
    push $P1412, $P1411
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("281_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1415_tgt
    .local int rx1415_pos
    .local int rx1415_off
    .local int rx1415_eos
    .local int rx1415_rep
    .local pmc rx1415_cur
    .local pmc rx1415_debug
    (rx1415_cur, rx1415_pos, rx1415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1415_cur
    .local pmc match
    .lex "$/", match
    length rx1415_eos, rx1415_tgt
    gt rx1415_pos, rx1415_eos, rx1415_done
    set rx1415_off, 0
    lt rx1415_pos, 2, rx1415_start
    sub rx1415_off, rx1415_pos, 1
    substr rx1415_tgt, rx1415_tgt, rx1415_off
  rx1415_start:
    eq $I10, 1, rx1415_restart
    if_null rx1415_debug, debug_1205
    rx1415_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1205:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1418_done
    goto rxscan1418_scan
  rxscan1418_loop:
    (rx1415_pos) = rx1415_cur."from"()
    inc rx1415_pos
    rx1415_cur."!cursor_from"(rx1415_pos)
    ge rx1415_pos, rx1415_eos, rxscan1418_done
  rxscan1418_scan:
    set_addr $I10, rxscan1418_loop
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
  rxscan1418_done:
.annotate 'line', 640
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1415_pos, rx1415_off
    substr $S10, rx1415_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1415_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1415_cur."!cursor_pos"(rx1415_pos)
    $P10 = rx1415_cur."quote_EXPR"(":q")
    unless $P10, rx1415_fail
    rx1415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1415_pos = $P10."pos"()
.annotate 'line', 641
  # rx subrule "O" subtype=capture negate=
    rx1415_cur."!cursor_pos"(rx1415_pos)
    $P10 = rx1415_cur."O"("%methodop")
    unless $P10, rx1415_fail
    rx1415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1415_pos = $P10."pos"()
.annotate 'line', 639
  # rx pass
    rx1415_cur."!cursor_pass"(rx1415_pos, "postcircumfix:sym<ang>")
    if_null rx1415_debug, debug_1206
    rx1415_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1415_pos)
  debug_1206:
    .return (rx1415_cur)
  rx1415_restart:
.annotate 'line', 10
    if_null rx1415_debug, debug_1207
    rx1415_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1207:
  rx1415_fail:
    (rx1415_rep, rx1415_pos, $I10, $P10) = rx1415_cur."!mark_fail"(0)
    lt rx1415_pos, -1, rx1415_done
    eq rx1415_pos, -1, rx1415_fail
    jump $I10
  rx1415_done:
    rx1415_cur."!cursor_fail"()
    if_null rx1415_debug, debug_1208
    rx1415_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1208:
    .return (rx1415_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("282_1303603603.711") :method
.annotate 'line', 10
    new $P1417, "ResizablePMCArray"
    push $P1417, "<"
    .return ($P1417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("283_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1420_tgt
    .local int rx1420_pos
    .local int rx1420_off
    .local int rx1420_eos
    .local int rx1420_rep
    .local pmc rx1420_cur
    .local pmc rx1420_debug
    (rx1420_cur, rx1420_pos, rx1420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1420_cur
    .local pmc match
    .lex "$/", match
    length rx1420_eos, rx1420_tgt
    gt rx1420_pos, rx1420_eos, rx1420_done
    set rx1420_off, 0
    lt rx1420_pos, 2, rx1420_start
    sub rx1420_off, rx1420_pos, 1
    substr rx1420_tgt, rx1420_tgt, rx1420_off
  rx1420_start:
    eq $I10, 1, rx1420_restart
    if_null rx1420_debug, debug_1209
    rx1420_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1209:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1424_done
    goto rxscan1424_scan
  rxscan1424_loop:
    (rx1420_pos) = rx1420_cur."from"()
    inc rx1420_pos
    rx1420_cur."!cursor_from"(rx1420_pos)
    ge rx1420_pos, rx1420_eos, rxscan1424_done
  rxscan1424_scan:
    set_addr $I10, rxscan1424_loop
    rx1420_cur."!mark_push"(0, rx1420_pos, $I10)
  rxscan1424_done:
.annotate 'line', 645
  # rx literal  "("
    add $I11, rx1420_pos, 1
    gt $I11, rx1420_eos, rx1420_fail
    sub $I11, rx1420_pos, rx1420_off
    ord $I11, rx1420_tgt, $I11
    ne $I11, 40, rx1420_fail
    add rx1420_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1420_cur."!cursor_pos"(rx1420_pos)
    $P10 = rx1420_cur."ws"()
    unless $P10, rx1420_fail
    rx1420_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1420_cur."!cursor_pos"(rx1420_pos)
    $P10 = rx1420_cur."arglist"()
    unless $P10, rx1420_fail
    rx1420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1420_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1420_pos, 1
    gt $I11, rx1420_eos, rx1420_fail
    sub $I11, rx1420_pos, rx1420_off
    ord $I11, rx1420_tgt, $I11
    ne $I11, 41, rx1420_fail
    add rx1420_pos, 1
.annotate 'line', 646
  # rx subrule "O" subtype=capture negate=
    rx1420_cur."!cursor_pos"(rx1420_pos)
    $P10 = rx1420_cur."O"("%methodop")
    unless $P10, rx1420_fail
    rx1420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1420_pos = $P10."pos"()
.annotate 'line', 644
  # rx pass
    rx1420_cur."!cursor_pass"(rx1420_pos, "postcircumfix:sym<( )>")
    if_null rx1420_debug, debug_1210
    rx1420_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1420_pos)
  debug_1210:
    .return (rx1420_cur)
  rx1420_restart:
.annotate 'line', 10
    if_null rx1420_debug, debug_1211
    rx1420_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1211:
  rx1420_fail:
    (rx1420_rep, rx1420_pos, $I10, $P10) = rx1420_cur."!mark_fail"(0)
    lt rx1420_pos, -1, rx1420_done
    eq rx1420_pos, -1, rx1420_fail
    jump $I10
  rx1420_done:
    rx1420_cur."!cursor_fail"()
    if_null rx1420_debug, debug_1212
    rx1420_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1212:
    .return (rx1420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("284_1303603603.711") :method
.annotate 'line', 10
    $P1422 = self."!PREFIX__!subrule"("ws", "(")
    new $P1423, "ResizablePMCArray"
    push $P1423, $P1422
    .return ($P1423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("285_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1426_tgt
    .local int rx1426_pos
    .local int rx1426_off
    .local int rx1426_eos
    .local int rx1426_rep
    .local pmc rx1426_cur
    .local pmc rx1426_debug
    (rx1426_cur, rx1426_pos, rx1426_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1426_cur
    .local pmc match
    .lex "$/", match
    length rx1426_eos, rx1426_tgt
    gt rx1426_pos, rx1426_eos, rx1426_done
    set rx1426_off, 0
    lt rx1426_pos, 2, rx1426_start
    sub rx1426_off, rx1426_pos, 1
    substr rx1426_tgt, rx1426_tgt, rx1426_off
  rx1426_start:
    eq $I10, 1, rx1426_restart
    if_null rx1426_debug, debug_1213
    rx1426_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1213:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1430_done
    goto rxscan1430_scan
  rxscan1430_loop:
    (rx1426_pos) = rx1426_cur."from"()
    inc rx1426_pos
    rx1426_cur."!cursor_from"(rx1426_pos)
    ge rx1426_pos, rx1426_eos, rxscan1430_done
  rxscan1430_scan:
    set_addr $I10, rxscan1430_loop
    rx1426_cur."!mark_push"(0, rx1426_pos, $I10)
  rxscan1430_done:
.annotate 'line', 649
  # rx subrule "dotty" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."dotty"()
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1426_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1426_cur."!cursor_pos"(rx1426_pos)
    $P10 = rx1426_cur."O"("%methodop")
    unless $P10, rx1426_fail
    rx1426_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1426_pos = $P10."pos"()
  # rx pass
    rx1426_cur."!cursor_pass"(rx1426_pos, "postfix:sym<.>")
    if_null rx1426_debug, debug_1214
    rx1426_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1426_pos)
  debug_1214:
    .return (rx1426_cur)
  rx1426_restart:
.annotate 'line', 10
    if_null rx1426_debug, debug_1215
    rx1426_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1215:
  rx1426_fail:
    (rx1426_rep, rx1426_pos, $I10, $P10) = rx1426_cur."!mark_fail"(0)
    lt rx1426_pos, -1, rx1426_done
    eq rx1426_pos, -1, rx1426_fail
    jump $I10
  rx1426_done:
    rx1426_cur."!cursor_fail"()
    if_null rx1426_debug, debug_1216
    rx1426_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1216:
    .return (rx1426_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("286_1303603603.711") :method
.annotate 'line', 10
    $P1428 = self."!PREFIX__!subrule"("dotty", "")
    new $P1429, "ResizablePMCArray"
    push $P1429, $P1428
    .return ($P1429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("287_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1432_tgt
    .local int rx1432_pos
    .local int rx1432_off
    .local int rx1432_eos
    .local int rx1432_rep
    .local pmc rx1432_cur
    .local pmc rx1432_debug
    (rx1432_cur, rx1432_pos, rx1432_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1432_cur
    .local pmc match
    .lex "$/", match
    length rx1432_eos, rx1432_tgt
    gt rx1432_pos, rx1432_eos, rx1432_done
    set rx1432_off, 0
    lt rx1432_pos, 2, rx1432_start
    sub rx1432_off, rx1432_pos, 1
    substr rx1432_tgt, rx1432_tgt, rx1432_off
  rx1432_start:
    eq $I10, 1, rx1432_restart
    if_null rx1432_debug, debug_1217
    rx1432_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1217:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    (rx1432_pos) = rx1432_cur."from"()
    inc rx1432_pos
    rx1432_cur."!cursor_from"(rx1432_pos)
    ge rx1432_pos, rx1432_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  rxscan1436_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1437_fail
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  # rx literal  "++"
    add $I11, rx1432_pos, 2
    gt $I11, rx1432_eos, rx1432_fail
    sub $I11, rx1432_pos, rx1432_off
    substr $S10, rx1432_tgt, $I11, 2
    ne $S10, "++", rx1432_fail
    add rx1432_pos, 2
    set_addr $I10, rxcap_1437_fail
    ($I12, $I11) = rx1432_cur."!mark_peek"($I10)
    rx1432_cur."!cursor_pos"($I11)
    ($P10) = rx1432_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1432_pos, "")
    rx1432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1437_done
  rxcap_1437_fail:
    goto rx1432_fail
  rxcap_1437_done:
  # rx subrule "O" subtype=capture negate=
    rx1432_cur."!cursor_pos"(rx1432_pos)
    $P10 = rx1432_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1432_fail
    rx1432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1432_pos = $P10."pos"()
  # rx pass
    rx1432_cur."!cursor_pass"(rx1432_pos, "prefix:sym<++>")
    if_null rx1432_debug, debug_1218
    rx1432_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1432_pos)
  debug_1218:
    .return (rx1432_cur)
  rx1432_restart:
.annotate 'line', 10
    if_null rx1432_debug, debug_1219
    rx1432_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1219:
  rx1432_fail:
    (rx1432_rep, rx1432_pos, $I10, $P10) = rx1432_cur."!mark_fail"(0)
    lt rx1432_pos, -1, rx1432_done
    eq rx1432_pos, -1, rx1432_fail
    jump $I10
  rx1432_done:
    rx1432_cur."!cursor_fail"()
    if_null rx1432_debug, debug_1220
    rx1432_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1220:
    .return (rx1432_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("288_1303603603.711") :method
.annotate 'line', 10
    $P1434 = self."!PREFIX__!subrule"("O", "++")
    new $P1435, "ResizablePMCArray"
    push $P1435, $P1434
    .return ($P1435)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("289_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1439_tgt
    .local int rx1439_pos
    .local int rx1439_off
    .local int rx1439_eos
    .local int rx1439_rep
    .local pmc rx1439_cur
    .local pmc rx1439_debug
    (rx1439_cur, rx1439_pos, rx1439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1439_cur
    .local pmc match
    .lex "$/", match
    length rx1439_eos, rx1439_tgt
    gt rx1439_pos, rx1439_eos, rx1439_done
    set rx1439_off, 0
    lt rx1439_pos, 2, rx1439_start
    sub rx1439_off, rx1439_pos, 1
    substr rx1439_tgt, rx1439_tgt, rx1439_off
  rx1439_start:
    eq $I10, 1, rx1439_restart
    if_null rx1439_debug, debug_1221
    rx1439_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1221:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1443_done
    goto rxscan1443_scan
  rxscan1443_loop:
    (rx1439_pos) = rx1439_cur."from"()
    inc rx1439_pos
    rx1439_cur."!cursor_from"(rx1439_pos)
    ge rx1439_pos, rx1439_eos, rxscan1443_done
  rxscan1443_scan:
    set_addr $I10, rxscan1443_loop
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  rxscan1443_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1444_fail
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  # rx literal  "--"
    add $I11, rx1439_pos, 2
    gt $I11, rx1439_eos, rx1439_fail
    sub $I11, rx1439_pos, rx1439_off
    substr $S10, rx1439_tgt, $I11, 2
    ne $S10, "--", rx1439_fail
    add rx1439_pos, 2
    set_addr $I10, rxcap_1444_fail
    ($I12, $I11) = rx1439_cur."!mark_peek"($I10)
    rx1439_cur."!cursor_pos"($I11)
    ($P10) = rx1439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1439_pos, "")
    rx1439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1444_done
  rxcap_1444_fail:
    goto rx1439_fail
  rxcap_1444_done:
  # rx subrule "O" subtype=capture negate=
    rx1439_cur."!cursor_pos"(rx1439_pos)
    $P10 = rx1439_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1439_fail
    rx1439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1439_pos = $P10."pos"()
  # rx pass
    rx1439_cur."!cursor_pass"(rx1439_pos, "prefix:sym<-->")
    if_null rx1439_debug, debug_1222
    rx1439_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1439_pos)
  debug_1222:
    .return (rx1439_cur)
  rx1439_restart:
.annotate 'line', 10
    if_null rx1439_debug, debug_1223
    rx1439_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1223:
  rx1439_fail:
    (rx1439_rep, rx1439_pos, $I10, $P10) = rx1439_cur."!mark_fail"(0)
    lt rx1439_pos, -1, rx1439_done
    eq rx1439_pos, -1, rx1439_fail
    jump $I10
  rx1439_done:
    rx1439_cur."!cursor_fail"()
    if_null rx1439_debug, debug_1224
    rx1439_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1224:
    .return (rx1439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("290_1303603603.711") :method
.annotate 'line', 10
    $P1441 = self."!PREFIX__!subrule"("O", "--")
    new $P1442, "ResizablePMCArray"
    push $P1442, $P1441
    .return ($P1442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("291_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1446_tgt
    .local int rx1446_pos
    .local int rx1446_off
    .local int rx1446_eos
    .local int rx1446_rep
    .local pmc rx1446_cur
    .local pmc rx1446_debug
    (rx1446_cur, rx1446_pos, rx1446_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1446_cur
    .local pmc match
    .lex "$/", match
    length rx1446_eos, rx1446_tgt
    gt rx1446_pos, rx1446_eos, rx1446_done
    set rx1446_off, 0
    lt rx1446_pos, 2, rx1446_start
    sub rx1446_off, rx1446_pos, 1
    substr rx1446_tgt, rx1446_tgt, rx1446_off
  rx1446_start:
    eq $I10, 1, rx1446_restart
    if_null rx1446_debug, debug_1225
    rx1446_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1225:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    (rx1446_pos) = rx1446_cur."from"()
    inc rx1446_pos
    rx1446_cur."!cursor_from"(rx1446_pos)
    ge rx1446_pos, rx1446_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  rxscan1450_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1451_fail
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  # rx literal  "++"
    add $I11, rx1446_pos, 2
    gt $I11, rx1446_eos, rx1446_fail
    sub $I11, rx1446_pos, rx1446_off
    substr $S10, rx1446_tgt, $I11, 2
    ne $S10, "++", rx1446_fail
    add rx1446_pos, 2
    set_addr $I10, rxcap_1451_fail
    ($I12, $I11) = rx1446_cur."!mark_peek"($I10)
    rx1446_cur."!cursor_pos"($I11)
    ($P10) = rx1446_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1446_pos, "")
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1451_done
  rxcap_1451_fail:
    goto rx1446_fail
  rxcap_1451_done:
  # rx subrule "O" subtype=capture negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."O"("%autoincrement")
    unless $P10, rx1446_fail
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1446_pos = $P10."pos"()
  # rx pass
    rx1446_cur."!cursor_pass"(rx1446_pos, "postfix:sym<++>")
    if_null rx1446_debug, debug_1226
    rx1446_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1446_pos)
  debug_1226:
    .return (rx1446_cur)
  rx1446_restart:
.annotate 'line', 10
    if_null rx1446_debug, debug_1227
    rx1446_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1227:
  rx1446_fail:
    (rx1446_rep, rx1446_pos, $I10, $P10) = rx1446_cur."!mark_fail"(0)
    lt rx1446_pos, -1, rx1446_done
    eq rx1446_pos, -1, rx1446_fail
    jump $I10
  rx1446_done:
    rx1446_cur."!cursor_fail"()
    if_null rx1446_debug, debug_1228
    rx1446_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1228:
    .return (rx1446_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("292_1303603603.711") :method
.annotate 'line', 10
    $P1448 = self."!PREFIX__!subrule"("O", "++")
    new $P1449, "ResizablePMCArray"
    push $P1449, $P1448
    .return ($P1449)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("293_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1453_tgt
    .local int rx1453_pos
    .local int rx1453_off
    .local int rx1453_eos
    .local int rx1453_rep
    .local pmc rx1453_cur
    .local pmc rx1453_debug
    (rx1453_cur, rx1453_pos, rx1453_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1453_cur
    .local pmc match
    .lex "$/", match
    length rx1453_eos, rx1453_tgt
    gt rx1453_pos, rx1453_eos, rx1453_done
    set rx1453_off, 0
    lt rx1453_pos, 2, rx1453_start
    sub rx1453_off, rx1453_pos, 1
    substr rx1453_tgt, rx1453_tgt, rx1453_off
  rx1453_start:
    eq $I10, 1, rx1453_restart
    if_null rx1453_debug, debug_1229
    rx1453_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1229:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1457_done
    goto rxscan1457_scan
  rxscan1457_loop:
    (rx1453_pos) = rx1453_cur."from"()
    inc rx1453_pos
    rx1453_cur."!cursor_from"(rx1453_pos)
    ge rx1453_pos, rx1453_eos, rxscan1457_done
  rxscan1457_scan:
    set_addr $I10, rxscan1457_loop
    rx1453_cur."!mark_push"(0, rx1453_pos, $I10)
  rxscan1457_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1458_fail
    rx1453_cur."!mark_push"(0, rx1453_pos, $I10)
  # rx literal  "--"
    add $I11, rx1453_pos, 2
    gt $I11, rx1453_eos, rx1453_fail
    sub $I11, rx1453_pos, rx1453_off
    substr $S10, rx1453_tgt, $I11, 2
    ne $S10, "--", rx1453_fail
    add rx1453_pos, 2
    set_addr $I10, rxcap_1458_fail
    ($I12, $I11) = rx1453_cur."!mark_peek"($I10)
    rx1453_cur."!cursor_pos"($I11)
    ($P10) = rx1453_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1453_pos, "")
    rx1453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1458_done
  rxcap_1458_fail:
    goto rx1453_fail
  rxcap_1458_done:
  # rx subrule "O" subtype=capture negate=
    rx1453_cur."!cursor_pos"(rx1453_pos)
    $P10 = rx1453_cur."O"("%autoincrement")
    unless $P10, rx1453_fail
    rx1453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1453_pos = $P10."pos"()
  # rx pass
    rx1453_cur."!cursor_pass"(rx1453_pos, "postfix:sym<-->")
    if_null rx1453_debug, debug_1230
    rx1453_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1453_pos)
  debug_1230:
    .return (rx1453_cur)
  rx1453_restart:
.annotate 'line', 10
    if_null rx1453_debug, debug_1231
    rx1453_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1231:
  rx1453_fail:
    (rx1453_rep, rx1453_pos, $I10, $P10) = rx1453_cur."!mark_fail"(0)
    lt rx1453_pos, -1, rx1453_done
    eq rx1453_pos, -1, rx1453_fail
    jump $I10
  rx1453_done:
    rx1453_cur."!cursor_fail"()
    if_null rx1453_debug, debug_1232
    rx1453_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1232:
    .return (rx1453_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("294_1303603603.711") :method
.annotate 'line', 10
    $P1455 = self."!PREFIX__!subrule"("O", "--")
    new $P1456, "ResizablePMCArray"
    push $P1456, $P1455
    .return ($P1456)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("295_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1460_tgt
    .local int rx1460_pos
    .local int rx1460_off
    .local int rx1460_eos
    .local int rx1460_rep
    .local pmc rx1460_cur
    .local pmc rx1460_debug
    (rx1460_cur, rx1460_pos, rx1460_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1460_cur
    .local pmc match
    .lex "$/", match
    length rx1460_eos, rx1460_tgt
    gt rx1460_pos, rx1460_eos, rx1460_done
    set rx1460_off, 0
    lt rx1460_pos, 2, rx1460_start
    sub rx1460_off, rx1460_pos, 1
    substr rx1460_tgt, rx1460_tgt, rx1460_off
  rx1460_start:
    eq $I10, 1, rx1460_restart
    if_null rx1460_debug, debug_1233
    rx1460_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1233:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1464_done
    goto rxscan1464_scan
  rxscan1464_loop:
    (rx1460_pos) = rx1460_cur."from"()
    inc rx1460_pos
    rx1460_cur."!cursor_from"(rx1460_pos)
    ge rx1460_pos, rx1460_eos, rxscan1464_done
  rxscan1464_scan:
    set_addr $I10, rxscan1464_loop
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  rxscan1464_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1465_fail
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  # rx literal  "**"
    add $I11, rx1460_pos, 2
    gt $I11, rx1460_eos, rx1460_fail
    sub $I11, rx1460_pos, rx1460_off
    substr $S10, rx1460_tgt, $I11, 2
    ne $S10, "**", rx1460_fail
    add rx1460_pos, 2
    set_addr $I10, rxcap_1465_fail
    ($I12, $I11) = rx1460_cur."!mark_peek"($I10)
    rx1460_cur."!cursor_pos"($I11)
    ($P10) = rx1460_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1460_pos, "")
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1465_done
  rxcap_1465_fail:
    goto rx1460_fail
  rxcap_1465_done:
  # rx subrule "O" subtype=capture negate=
    rx1460_cur."!cursor_pos"(rx1460_pos)
    $P10 = rx1460_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1460_fail
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1460_pos = $P10."pos"()
  # rx pass
    rx1460_cur."!cursor_pass"(rx1460_pos, "infix:sym<**>")
    if_null rx1460_debug, debug_1234
    rx1460_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1460_pos)
  debug_1234:
    .return (rx1460_cur)
  rx1460_restart:
.annotate 'line', 10
    if_null rx1460_debug, debug_1235
    rx1460_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1235:
  rx1460_fail:
    (rx1460_rep, rx1460_pos, $I10, $P10) = rx1460_cur."!mark_fail"(0)
    lt rx1460_pos, -1, rx1460_done
    eq rx1460_pos, -1, rx1460_fail
    jump $I10
  rx1460_done:
    rx1460_cur."!cursor_fail"()
    if_null rx1460_debug, debug_1236
    rx1460_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1236:
    .return (rx1460_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("296_1303603603.711") :method
.annotate 'line', 10
    $P1462 = self."!PREFIX__!subrule"("O", "**")
    new $P1463, "ResizablePMCArray"
    push $P1463, $P1462
    .return ($P1463)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("297_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1467_tgt
    .local int rx1467_pos
    .local int rx1467_off
    .local int rx1467_eos
    .local int rx1467_rep
    .local pmc rx1467_cur
    .local pmc rx1467_debug
    (rx1467_cur, rx1467_pos, rx1467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1467_cur
    .local pmc match
    .lex "$/", match
    length rx1467_eos, rx1467_tgt
    gt rx1467_pos, rx1467_eos, rx1467_done
    set rx1467_off, 0
    lt rx1467_pos, 2, rx1467_start
    sub rx1467_off, rx1467_pos, 1
    substr rx1467_tgt, rx1467_tgt, rx1467_off
  rx1467_start:
    eq $I10, 1, rx1467_restart
    if_null rx1467_debug, debug_1237
    rx1467_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1237:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1471_done
    goto rxscan1471_scan
  rxscan1471_loop:
    (rx1467_pos) = rx1467_cur."from"()
    inc rx1467_pos
    rx1467_cur."!cursor_from"(rx1467_pos)
    ge rx1467_pos, rx1467_eos, rxscan1471_done
  rxscan1471_scan:
    set_addr $I10, rxscan1471_loop
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  rxscan1471_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1472_fail
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  # rx literal  "+"
    add $I11, rx1467_pos, 1
    gt $I11, rx1467_eos, rx1467_fail
    sub $I11, rx1467_pos, rx1467_off
    ord $I11, rx1467_tgt, $I11
    ne $I11, 43, rx1467_fail
    add rx1467_pos, 1
    set_addr $I10, rxcap_1472_fail
    ($I12, $I11) = rx1467_cur."!mark_peek"($I10)
    rx1467_cur."!cursor_pos"($I11)
    ($P10) = rx1467_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1467_pos, "")
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1472_done
  rxcap_1472_fail:
    goto rx1467_fail
  rxcap_1472_done:
  # rx subrule "O" subtype=capture negate=
    rx1467_cur."!cursor_pos"(rx1467_pos)
    $P10 = rx1467_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1467_fail
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1467_pos = $P10."pos"()
  # rx pass
    rx1467_cur."!cursor_pass"(rx1467_pos, "prefix:sym<+>")
    if_null rx1467_debug, debug_1238
    rx1467_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1467_pos)
  debug_1238:
    .return (rx1467_cur)
  rx1467_restart:
.annotate 'line', 10
    if_null rx1467_debug, debug_1239
    rx1467_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1239:
  rx1467_fail:
    (rx1467_rep, rx1467_pos, $I10, $P10) = rx1467_cur."!mark_fail"(0)
    lt rx1467_pos, -1, rx1467_done
    eq rx1467_pos, -1, rx1467_fail
    jump $I10
  rx1467_done:
    rx1467_cur."!cursor_fail"()
    if_null rx1467_debug, debug_1240
    rx1467_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1240:
    .return (rx1467_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("298_1303603603.711") :method
.annotate 'line', 10
    $P1469 = self."!PREFIX__!subrule"("O", "+")
    new $P1470, "ResizablePMCArray"
    push $P1470, $P1469
    .return ($P1470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("299_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1474_tgt
    .local int rx1474_pos
    .local int rx1474_off
    .local int rx1474_eos
    .local int rx1474_rep
    .local pmc rx1474_cur
    .local pmc rx1474_debug
    (rx1474_cur, rx1474_pos, rx1474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1474_cur
    .local pmc match
    .lex "$/", match
    length rx1474_eos, rx1474_tgt
    gt rx1474_pos, rx1474_eos, rx1474_done
    set rx1474_off, 0
    lt rx1474_pos, 2, rx1474_start
    sub rx1474_off, rx1474_pos, 1
    substr rx1474_tgt, rx1474_tgt, rx1474_off
  rx1474_start:
    eq $I10, 1, rx1474_restart
    if_null rx1474_debug, debug_1241
    rx1474_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1241:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1478_done
    goto rxscan1478_scan
  rxscan1478_loop:
    (rx1474_pos) = rx1474_cur."from"()
    inc rx1474_pos
    rx1474_cur."!cursor_from"(rx1474_pos)
    ge rx1474_pos, rx1474_eos, rxscan1478_done
  rxscan1478_scan:
    set_addr $I10, rxscan1478_loop
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  rxscan1478_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1479_fail
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  # rx literal  "~"
    add $I11, rx1474_pos, 1
    gt $I11, rx1474_eos, rx1474_fail
    sub $I11, rx1474_pos, rx1474_off
    ord $I11, rx1474_tgt, $I11
    ne $I11, 126, rx1474_fail
    add rx1474_pos, 1
    set_addr $I10, rxcap_1479_fail
    ($I12, $I11) = rx1474_cur."!mark_peek"($I10)
    rx1474_cur."!cursor_pos"($I11)
    ($P10) = rx1474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1474_pos, "")
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1479_done
  rxcap_1479_fail:
    goto rx1474_fail
  rxcap_1479_done:
  # rx subrule "O" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1474_pos = $P10."pos"()
  # rx pass
    rx1474_cur."!cursor_pass"(rx1474_pos, "prefix:sym<~>")
    if_null rx1474_debug, debug_1242
    rx1474_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1474_pos)
  debug_1242:
    .return (rx1474_cur)
  rx1474_restart:
.annotate 'line', 10
    if_null rx1474_debug, debug_1243
    rx1474_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1243:
  rx1474_fail:
    (rx1474_rep, rx1474_pos, $I10, $P10) = rx1474_cur."!mark_fail"(0)
    lt rx1474_pos, -1, rx1474_done
    eq rx1474_pos, -1, rx1474_fail
    jump $I10
  rx1474_done:
    rx1474_cur."!cursor_fail"()
    if_null rx1474_debug, debug_1244
    rx1474_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1244:
    .return (rx1474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("300_1303603603.711") :method
.annotate 'line', 10
    $P1476 = self."!PREFIX__!subrule"("O", "~")
    new $P1477, "ResizablePMCArray"
    push $P1477, $P1476
    .return ($P1477)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("301_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1481_tgt
    .local int rx1481_pos
    .local int rx1481_off
    .local int rx1481_eos
    .local int rx1481_rep
    .local pmc rx1481_cur
    .local pmc rx1481_debug
    (rx1481_cur, rx1481_pos, rx1481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1481_cur
    .local pmc match
    .lex "$/", match
    length rx1481_eos, rx1481_tgt
    gt rx1481_pos, rx1481_eos, rx1481_done
    set rx1481_off, 0
    lt rx1481_pos, 2, rx1481_start
    sub rx1481_off, rx1481_pos, 1
    substr rx1481_tgt, rx1481_tgt, rx1481_off
  rx1481_start:
    eq $I10, 1, rx1481_restart
    if_null rx1481_debug, debug_1245
    rx1481_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1245:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1484_done
    goto rxscan1484_scan
  rxscan1484_loop:
    (rx1481_pos) = rx1481_cur."from"()
    inc rx1481_pos
    rx1481_cur."!cursor_from"(rx1481_pos)
    ge rx1481_pos, rx1481_eos, rxscan1484_done
  rxscan1484_scan:
    set_addr $I10, rxscan1484_loop
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  rxscan1484_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1485_fail
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  # rx literal  "-"
    add $I11, rx1481_pos, 1
    gt $I11, rx1481_eos, rx1481_fail
    sub $I11, rx1481_pos, rx1481_off
    ord $I11, rx1481_tgt, $I11
    ne $I11, 45, rx1481_fail
    add rx1481_pos, 1
    set_addr $I10, rxcap_1485_fail
    ($I12, $I11) = rx1481_cur."!mark_peek"($I10)
    rx1481_cur."!cursor_pos"($I11)
    ($P10) = rx1481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1481_pos, "")
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1485_done
  rxcap_1485_fail:
    goto rx1481_fail
  rxcap_1485_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1481_pos, rx1481_off
    substr $S10, rx1481_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1481_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."number"()
    if $P10, rx1481_fail
  # rx subrule "O" subtype=capture negate=
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1481_fail
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1481_pos = $P10."pos"()
  # rx pass
    rx1481_cur."!cursor_pass"(rx1481_pos, "prefix:sym<->")
    if_null rx1481_debug, debug_1246
    rx1481_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1481_pos)
  debug_1246:
    .return (rx1481_cur)
  rx1481_restart:
.annotate 'line', 10
    if_null rx1481_debug, debug_1247
    rx1481_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1247:
  rx1481_fail:
    (rx1481_rep, rx1481_pos, $I10, $P10) = rx1481_cur."!mark_fail"(0)
    lt rx1481_pos, -1, rx1481_done
    eq rx1481_pos, -1, rx1481_fail
    jump $I10
  rx1481_done:
    rx1481_cur."!cursor_fail"()
    if_null rx1481_debug, debug_1248
    rx1481_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1248:
    .return (rx1481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("302_1303603603.711") :method
.annotate 'line', 10
    new $P1483, "ResizablePMCArray"
    push $P1483, "-"
    .return ($P1483)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("303_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1487_tgt
    .local int rx1487_pos
    .local int rx1487_off
    .local int rx1487_eos
    .local int rx1487_rep
    .local pmc rx1487_cur
    .local pmc rx1487_debug
    (rx1487_cur, rx1487_pos, rx1487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1487_cur
    .local pmc match
    .lex "$/", match
    length rx1487_eos, rx1487_tgt
    gt rx1487_pos, rx1487_eos, rx1487_done
    set rx1487_off, 0
    lt rx1487_pos, 2, rx1487_start
    sub rx1487_off, rx1487_pos, 1
    substr rx1487_tgt, rx1487_tgt, rx1487_off
  rx1487_start:
    eq $I10, 1, rx1487_restart
    if_null rx1487_debug, debug_1249
    rx1487_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1249:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1491_done
    goto rxscan1491_scan
  rxscan1491_loop:
    (rx1487_pos) = rx1487_cur."from"()
    inc rx1487_pos
    rx1487_cur."!cursor_from"(rx1487_pos)
    ge rx1487_pos, rx1487_eos, rxscan1491_done
  rxscan1491_scan:
    set_addr $I10, rxscan1491_loop
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  rxscan1491_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1492_fail
    rx1487_cur."!mark_push"(0, rx1487_pos, $I10)
  # rx literal  "?"
    add $I11, rx1487_pos, 1
    gt $I11, rx1487_eos, rx1487_fail
    sub $I11, rx1487_pos, rx1487_off
    ord $I11, rx1487_tgt, $I11
    ne $I11, 63, rx1487_fail
    add rx1487_pos, 1
    set_addr $I10, rxcap_1492_fail
    ($I12, $I11) = rx1487_cur."!mark_peek"($I10)
    rx1487_cur."!cursor_pos"($I11)
    ($P10) = rx1487_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1487_pos, "")
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1492_done
  rxcap_1492_fail:
    goto rx1487_fail
  rxcap_1492_done:
  # rx subrule "O" subtype=capture negate=
    rx1487_cur."!cursor_pos"(rx1487_pos)
    $P10 = rx1487_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1487_fail
    rx1487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1487_pos = $P10."pos"()
  # rx pass
    rx1487_cur."!cursor_pass"(rx1487_pos, "prefix:sym<?>")
    if_null rx1487_debug, debug_1250
    rx1487_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1487_pos)
  debug_1250:
    .return (rx1487_cur)
  rx1487_restart:
.annotate 'line', 10
    if_null rx1487_debug, debug_1251
    rx1487_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1251:
  rx1487_fail:
    (rx1487_rep, rx1487_pos, $I10, $P10) = rx1487_cur."!mark_fail"(0)
    lt rx1487_pos, -1, rx1487_done
    eq rx1487_pos, -1, rx1487_fail
    jump $I10
  rx1487_done:
    rx1487_cur."!cursor_fail"()
    if_null rx1487_debug, debug_1252
    rx1487_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1252:
    .return (rx1487_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("304_1303603603.711") :method
.annotate 'line', 10
    $P1489 = self."!PREFIX__!subrule"("O", "?")
    new $P1490, "ResizablePMCArray"
    push $P1490, $P1489
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("305_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1494_tgt
    .local int rx1494_pos
    .local int rx1494_off
    .local int rx1494_eos
    .local int rx1494_rep
    .local pmc rx1494_cur
    .local pmc rx1494_debug
    (rx1494_cur, rx1494_pos, rx1494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1494_cur
    .local pmc match
    .lex "$/", match
    length rx1494_eos, rx1494_tgt
    gt rx1494_pos, rx1494_eos, rx1494_done
    set rx1494_off, 0
    lt rx1494_pos, 2, rx1494_start
    sub rx1494_off, rx1494_pos, 1
    substr rx1494_tgt, rx1494_tgt, rx1494_off
  rx1494_start:
    eq $I10, 1, rx1494_restart
    if_null rx1494_debug, debug_1253
    rx1494_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1253:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1498_done
    goto rxscan1498_scan
  rxscan1498_loop:
    (rx1494_pos) = rx1494_cur."from"()
    inc rx1494_pos
    rx1494_cur."!cursor_from"(rx1494_pos)
    ge rx1494_pos, rx1494_eos, rxscan1498_done
  rxscan1498_scan:
    set_addr $I10, rxscan1498_loop
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  rxscan1498_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1499_fail
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  # rx literal  "!"
    add $I11, rx1494_pos, 1
    gt $I11, rx1494_eos, rx1494_fail
    sub $I11, rx1494_pos, rx1494_off
    ord $I11, rx1494_tgt, $I11
    ne $I11, 33, rx1494_fail
    add rx1494_pos, 1
    set_addr $I10, rxcap_1499_fail
    ($I12, $I11) = rx1494_cur."!mark_peek"($I10)
    rx1494_cur."!cursor_pos"($I11)
    ($P10) = rx1494_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1494_pos, "")
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1499_done
  rxcap_1499_fail:
    goto rx1494_fail
  rxcap_1499_done:
  # rx subrule "O" subtype=capture negate=
    rx1494_cur."!cursor_pos"(rx1494_pos)
    $P10 = rx1494_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1494_fail
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1494_pos = $P10."pos"()
  # rx pass
    rx1494_cur."!cursor_pass"(rx1494_pos, "prefix:sym<!>")
    if_null rx1494_debug, debug_1254
    rx1494_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1494_pos)
  debug_1254:
    .return (rx1494_cur)
  rx1494_restart:
.annotate 'line', 10
    if_null rx1494_debug, debug_1255
    rx1494_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1255:
  rx1494_fail:
    (rx1494_rep, rx1494_pos, $I10, $P10) = rx1494_cur."!mark_fail"(0)
    lt rx1494_pos, -1, rx1494_done
    eq rx1494_pos, -1, rx1494_fail
    jump $I10
  rx1494_done:
    rx1494_cur."!cursor_fail"()
    if_null rx1494_debug, debug_1256
    rx1494_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1256:
    .return (rx1494_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("306_1303603603.711") :method
.annotate 'line', 10
    $P1496 = self."!PREFIX__!subrule"("O", "!")
    new $P1497, "ResizablePMCArray"
    push $P1497, $P1496
    .return ($P1497)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("307_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1501_tgt
    .local int rx1501_pos
    .local int rx1501_off
    .local int rx1501_eos
    .local int rx1501_rep
    .local pmc rx1501_cur
    .local pmc rx1501_debug
    (rx1501_cur, rx1501_pos, rx1501_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1501_cur
    .local pmc match
    .lex "$/", match
    length rx1501_eos, rx1501_tgt
    gt rx1501_pos, rx1501_eos, rx1501_done
    set rx1501_off, 0
    lt rx1501_pos, 2, rx1501_start
    sub rx1501_off, rx1501_pos, 1
    substr rx1501_tgt, rx1501_tgt, rx1501_off
  rx1501_start:
    eq $I10, 1, rx1501_restart
    if_null rx1501_debug, debug_1257
    rx1501_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1257:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1505_done
    goto rxscan1505_scan
  rxscan1505_loop:
    (rx1501_pos) = rx1501_cur."from"()
    inc rx1501_pos
    rx1501_cur."!cursor_from"(rx1501_pos)
    ge rx1501_pos, rx1501_eos, rxscan1505_done
  rxscan1505_scan:
    set_addr $I10, rxscan1505_loop
    rx1501_cur."!mark_push"(0, rx1501_pos, $I10)
  rxscan1505_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1506_fail
    rx1501_cur."!mark_push"(0, rx1501_pos, $I10)
  # rx literal  "|"
    add $I11, rx1501_pos, 1
    gt $I11, rx1501_eos, rx1501_fail
    sub $I11, rx1501_pos, rx1501_off
    ord $I11, rx1501_tgt, $I11
    ne $I11, 124, rx1501_fail
    add rx1501_pos, 1
    set_addr $I10, rxcap_1506_fail
    ($I12, $I11) = rx1501_cur."!mark_peek"($I10)
    rx1501_cur."!cursor_pos"($I11)
    ($P10) = rx1501_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1501_pos, "")
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1506_done
  rxcap_1506_fail:
    goto rx1501_fail
  rxcap_1506_done:
  # rx subrule "O" subtype=capture negate=
    rx1501_cur."!cursor_pos"(rx1501_pos)
    $P10 = rx1501_cur."O"("%symbolic_unary")
    unless $P10, rx1501_fail
    rx1501_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1501_pos = $P10."pos"()
  # rx pass
    rx1501_cur."!cursor_pass"(rx1501_pos, "prefix:sym<|>")
    if_null rx1501_debug, debug_1258
    rx1501_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1501_pos)
  debug_1258:
    .return (rx1501_cur)
  rx1501_restart:
.annotate 'line', 10
    if_null rx1501_debug, debug_1259
    rx1501_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1259:
  rx1501_fail:
    (rx1501_rep, rx1501_pos, $I10, $P10) = rx1501_cur."!mark_fail"(0)
    lt rx1501_pos, -1, rx1501_done
    eq rx1501_pos, -1, rx1501_fail
    jump $I10
  rx1501_done:
    rx1501_cur."!cursor_fail"()
    if_null rx1501_debug, debug_1260
    rx1501_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1260:
    .return (rx1501_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("308_1303603603.711") :method
.annotate 'line', 10
    $P1503 = self."!PREFIX__!subrule"("O", "|")
    new $P1504, "ResizablePMCArray"
    push $P1504, $P1503
    .return ($P1504)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("309_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1508_tgt
    .local int rx1508_pos
    .local int rx1508_off
    .local int rx1508_eos
    .local int rx1508_rep
    .local pmc rx1508_cur
    .local pmc rx1508_debug
    (rx1508_cur, rx1508_pos, rx1508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1508_cur
    .local pmc match
    .lex "$/", match
    length rx1508_eos, rx1508_tgt
    gt rx1508_pos, rx1508_eos, rx1508_done
    set rx1508_off, 0
    lt rx1508_pos, 2, rx1508_start
    sub rx1508_off, rx1508_pos, 1
    substr rx1508_tgt, rx1508_tgt, rx1508_off
  rx1508_start:
    eq $I10, 1, rx1508_restart
    if_null rx1508_debug, debug_1261
    rx1508_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1261:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1512_done
    goto rxscan1512_scan
  rxscan1512_loop:
    (rx1508_pos) = rx1508_cur."from"()
    inc rx1508_pos
    rx1508_cur."!cursor_from"(rx1508_pos)
    ge rx1508_pos, rx1508_eos, rxscan1512_done
  rxscan1512_scan:
    set_addr $I10, rxscan1512_loop
    rx1508_cur."!mark_push"(0, rx1508_pos, $I10)
  rxscan1512_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1513_fail
    rx1508_cur."!mark_push"(0, rx1508_pos, $I10)
  # rx literal  "*"
    add $I11, rx1508_pos, 1
    gt $I11, rx1508_eos, rx1508_fail
    sub $I11, rx1508_pos, rx1508_off
    ord $I11, rx1508_tgt, $I11
    ne $I11, 42, rx1508_fail
    add rx1508_pos, 1
    set_addr $I10, rxcap_1513_fail
    ($I12, $I11) = rx1508_cur."!mark_peek"($I10)
    rx1508_cur."!cursor_pos"($I11)
    ($P10) = rx1508_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1508_pos, "")
    rx1508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1513_done
  rxcap_1513_fail:
    goto rx1508_fail
  rxcap_1513_done:
  # rx subrule "O" subtype=capture negate=
    rx1508_cur."!cursor_pos"(rx1508_pos)
    $P10 = rx1508_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1508_fail
    rx1508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1508_pos = $P10."pos"()
  # rx pass
    rx1508_cur."!cursor_pass"(rx1508_pos, "infix:sym<*>")
    if_null rx1508_debug, debug_1262
    rx1508_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1508_pos)
  debug_1262:
    .return (rx1508_cur)
  rx1508_restart:
.annotate 'line', 10
    if_null rx1508_debug, debug_1263
    rx1508_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1263:
  rx1508_fail:
    (rx1508_rep, rx1508_pos, $I10, $P10) = rx1508_cur."!mark_fail"(0)
    lt rx1508_pos, -1, rx1508_done
    eq rx1508_pos, -1, rx1508_fail
    jump $I10
  rx1508_done:
    rx1508_cur."!cursor_fail"()
    if_null rx1508_debug, debug_1264
    rx1508_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1264:
    .return (rx1508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("310_1303603603.711") :method
.annotate 'line', 10
    $P1510 = self."!PREFIX__!subrule"("O", "*")
    new $P1511, "ResizablePMCArray"
    push $P1511, $P1510
    .return ($P1511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("311_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1515_tgt
    .local int rx1515_pos
    .local int rx1515_off
    .local int rx1515_eos
    .local int rx1515_rep
    .local pmc rx1515_cur
    .local pmc rx1515_debug
    (rx1515_cur, rx1515_pos, rx1515_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1515_cur
    .local pmc match
    .lex "$/", match
    length rx1515_eos, rx1515_tgt
    gt rx1515_pos, rx1515_eos, rx1515_done
    set rx1515_off, 0
    lt rx1515_pos, 2, rx1515_start
    sub rx1515_off, rx1515_pos, 1
    substr rx1515_tgt, rx1515_tgt, rx1515_off
  rx1515_start:
    eq $I10, 1, rx1515_restart
    if_null rx1515_debug, debug_1265
    rx1515_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1265:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1519_done
    goto rxscan1519_scan
  rxscan1519_loop:
    (rx1515_pos) = rx1515_cur."from"()
    inc rx1515_pos
    rx1515_cur."!cursor_from"(rx1515_pos)
    ge rx1515_pos, rx1515_eos, rxscan1519_done
  rxscan1519_scan:
    set_addr $I10, rxscan1519_loop
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10)
  rxscan1519_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1520_fail
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10)
  # rx literal  "/"
    add $I11, rx1515_pos, 1
    gt $I11, rx1515_eos, rx1515_fail
    sub $I11, rx1515_pos, rx1515_off
    ord $I11, rx1515_tgt, $I11
    ne $I11, 47, rx1515_fail
    add rx1515_pos, 1
    set_addr $I10, rxcap_1520_fail
    ($I12, $I11) = rx1515_cur."!mark_peek"($I10)
    rx1515_cur."!cursor_pos"($I11)
    ($P10) = rx1515_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1515_pos, "")
    rx1515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1520_done
  rxcap_1520_fail:
    goto rx1515_fail
  rxcap_1520_done:
  # rx subrule "O" subtype=capture negate=
    rx1515_cur."!cursor_pos"(rx1515_pos)
    $P10 = rx1515_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1515_fail
    rx1515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1515_pos = $P10."pos"()
  # rx pass
    rx1515_cur."!cursor_pass"(rx1515_pos, "infix:sym</>")
    if_null rx1515_debug, debug_1266
    rx1515_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1515_pos)
  debug_1266:
    .return (rx1515_cur)
  rx1515_restart:
.annotate 'line', 10
    if_null rx1515_debug, debug_1267
    rx1515_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1267:
  rx1515_fail:
    (rx1515_rep, rx1515_pos, $I10, $P10) = rx1515_cur."!mark_fail"(0)
    lt rx1515_pos, -1, rx1515_done
    eq rx1515_pos, -1, rx1515_fail
    jump $I10
  rx1515_done:
    rx1515_cur."!cursor_fail"()
    if_null rx1515_debug, debug_1268
    rx1515_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1268:
    .return (rx1515_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("312_1303603603.711") :method
.annotate 'line', 10
    $P1517 = self."!PREFIX__!subrule"("O", "/")
    new $P1518, "ResizablePMCArray"
    push $P1518, $P1517
    .return ($P1518)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("313_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1522_tgt
    .local int rx1522_pos
    .local int rx1522_off
    .local int rx1522_eos
    .local int rx1522_rep
    .local pmc rx1522_cur
    .local pmc rx1522_debug
    (rx1522_cur, rx1522_pos, rx1522_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1522_cur
    .local pmc match
    .lex "$/", match
    length rx1522_eos, rx1522_tgt
    gt rx1522_pos, rx1522_eos, rx1522_done
    set rx1522_off, 0
    lt rx1522_pos, 2, rx1522_start
    sub rx1522_off, rx1522_pos, 1
    substr rx1522_tgt, rx1522_tgt, rx1522_off
  rx1522_start:
    eq $I10, 1, rx1522_restart
    if_null rx1522_debug, debug_1269
    rx1522_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1269:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1526_done
    goto rxscan1526_scan
  rxscan1526_loop:
    (rx1522_pos) = rx1522_cur."from"()
    inc rx1522_pos
    rx1522_cur."!cursor_from"(rx1522_pos)
    ge rx1522_pos, rx1522_eos, rxscan1526_done
  rxscan1526_scan:
    set_addr $I10, rxscan1526_loop
    rx1522_cur."!mark_push"(0, rx1522_pos, $I10)
  rxscan1526_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1527_fail
    rx1522_cur."!mark_push"(0, rx1522_pos, $I10)
  # rx literal  "%"
    add $I11, rx1522_pos, 1
    gt $I11, rx1522_eos, rx1522_fail
    sub $I11, rx1522_pos, rx1522_off
    ord $I11, rx1522_tgt, $I11
    ne $I11, 37, rx1522_fail
    add rx1522_pos, 1
    set_addr $I10, rxcap_1527_fail
    ($I12, $I11) = rx1522_cur."!mark_peek"($I10)
    rx1522_cur."!cursor_pos"($I11)
    ($P10) = rx1522_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1522_pos, "")
    rx1522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1527_done
  rxcap_1527_fail:
    goto rx1522_fail
  rxcap_1527_done:
  # rx subrule "O" subtype=capture negate=
    rx1522_cur."!cursor_pos"(rx1522_pos)
    $P10 = rx1522_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1522_fail
    rx1522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1522_pos = $P10."pos"()
  # rx pass
    rx1522_cur."!cursor_pass"(rx1522_pos, "infix:sym<%>")
    if_null rx1522_debug, debug_1270
    rx1522_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1522_pos)
  debug_1270:
    .return (rx1522_cur)
  rx1522_restart:
.annotate 'line', 10
    if_null rx1522_debug, debug_1271
    rx1522_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1271:
  rx1522_fail:
    (rx1522_rep, rx1522_pos, $I10, $P10) = rx1522_cur."!mark_fail"(0)
    lt rx1522_pos, -1, rx1522_done
    eq rx1522_pos, -1, rx1522_fail
    jump $I10
  rx1522_done:
    rx1522_cur."!cursor_fail"()
    if_null rx1522_debug, debug_1272
    rx1522_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1272:
    .return (rx1522_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("314_1303603603.711") :method
.annotate 'line', 10
    $P1524 = self."!PREFIX__!subrule"("O", "%")
    new $P1525, "ResizablePMCArray"
    push $P1525, $P1524
    .return ($P1525)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("315_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1529_tgt
    .local int rx1529_pos
    .local int rx1529_off
    .local int rx1529_eos
    .local int rx1529_rep
    .local pmc rx1529_cur
    .local pmc rx1529_debug
    (rx1529_cur, rx1529_pos, rx1529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1529_cur
    .local pmc match
    .lex "$/", match
    length rx1529_eos, rx1529_tgt
    gt rx1529_pos, rx1529_eos, rx1529_done
    set rx1529_off, 0
    lt rx1529_pos, 2, rx1529_start
    sub rx1529_off, rx1529_pos, 1
    substr rx1529_tgt, rx1529_tgt, rx1529_off
  rx1529_start:
    eq $I10, 1, rx1529_restart
    if_null rx1529_debug, debug_1273
    rx1529_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1273:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1533_done
    goto rxscan1533_scan
  rxscan1533_loop:
    (rx1529_pos) = rx1529_cur."from"()
    inc rx1529_pos
    rx1529_cur."!cursor_from"(rx1529_pos)
    ge rx1529_pos, rx1529_eos, rxscan1533_done
  rxscan1533_scan:
    set_addr $I10, rxscan1533_loop
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  rxscan1533_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1534_fail
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1529_pos, 2
    gt $I11, rx1529_eos, rx1529_fail
    sub $I11, rx1529_pos, rx1529_off
    substr $S10, rx1529_tgt, $I11, 2
    ne $S10, "+&", rx1529_fail
    add rx1529_pos, 2
    set_addr $I10, rxcap_1534_fail
    ($I12, $I11) = rx1529_cur."!mark_peek"($I10)
    rx1529_cur."!cursor_pos"($I11)
    ($P10) = rx1529_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1529_pos, "")
    rx1529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1534_done
  rxcap_1534_fail:
    goto rx1529_fail
  rxcap_1534_done:
  # rx subrule "O" subtype=capture negate=
    rx1529_cur."!cursor_pos"(rx1529_pos)
    $P10 = rx1529_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1529_fail
    rx1529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1529_pos = $P10."pos"()
  # rx pass
    rx1529_cur."!cursor_pass"(rx1529_pos, "infix:sym<+&>")
    if_null rx1529_debug, debug_1274
    rx1529_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1529_pos)
  debug_1274:
    .return (rx1529_cur)
  rx1529_restart:
.annotate 'line', 10
    if_null rx1529_debug, debug_1275
    rx1529_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1275:
  rx1529_fail:
    (rx1529_rep, rx1529_pos, $I10, $P10) = rx1529_cur."!mark_fail"(0)
    lt rx1529_pos, -1, rx1529_done
    eq rx1529_pos, -1, rx1529_fail
    jump $I10
  rx1529_done:
    rx1529_cur."!cursor_fail"()
    if_null rx1529_debug, debug_1276
    rx1529_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1276:
    .return (rx1529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("316_1303603603.711") :method
.annotate 'line', 10
    $P1531 = self."!PREFIX__!subrule"("O", "+&")
    new $P1532, "ResizablePMCArray"
    push $P1532, $P1531
    .return ($P1532)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("317_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1536_tgt
    .local int rx1536_pos
    .local int rx1536_off
    .local int rx1536_eos
    .local int rx1536_rep
    .local pmc rx1536_cur
    .local pmc rx1536_debug
    (rx1536_cur, rx1536_pos, rx1536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1536_cur
    .local pmc match
    .lex "$/", match
    length rx1536_eos, rx1536_tgt
    gt rx1536_pos, rx1536_eos, rx1536_done
    set rx1536_off, 0
    lt rx1536_pos, 2, rx1536_start
    sub rx1536_off, rx1536_pos, 1
    substr rx1536_tgt, rx1536_tgt, rx1536_off
  rx1536_start:
    eq $I10, 1, rx1536_restart
    if_null rx1536_debug, debug_1277
    rx1536_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1277:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1540_done
    goto rxscan1540_scan
  rxscan1540_loop:
    (rx1536_pos) = rx1536_cur."from"()
    inc rx1536_pos
    rx1536_cur."!cursor_from"(rx1536_pos)
    ge rx1536_pos, rx1536_eos, rxscan1540_done
  rxscan1540_scan:
    set_addr $I10, rxscan1540_loop
    rx1536_cur."!mark_push"(0, rx1536_pos, $I10)
  rxscan1540_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1541_fail
    rx1536_cur."!mark_push"(0, rx1536_pos, $I10)
  # rx literal  "+"
    add $I11, rx1536_pos, 1
    gt $I11, rx1536_eos, rx1536_fail
    sub $I11, rx1536_pos, rx1536_off
    ord $I11, rx1536_tgt, $I11
    ne $I11, 43, rx1536_fail
    add rx1536_pos, 1
    set_addr $I10, rxcap_1541_fail
    ($I12, $I11) = rx1536_cur."!mark_peek"($I10)
    rx1536_cur."!cursor_pos"($I11)
    ($P10) = rx1536_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1536_pos, "")
    rx1536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1541_done
  rxcap_1541_fail:
    goto rx1536_fail
  rxcap_1541_done:
  # rx subrule "O" subtype=capture negate=
    rx1536_cur."!cursor_pos"(rx1536_pos)
    $P10 = rx1536_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1536_fail
    rx1536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1536_pos = $P10."pos"()
  # rx pass
    rx1536_cur."!cursor_pass"(rx1536_pos, "infix:sym<+>")
    if_null rx1536_debug, debug_1278
    rx1536_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1536_pos)
  debug_1278:
    .return (rx1536_cur)
  rx1536_restart:
.annotate 'line', 10
    if_null rx1536_debug, debug_1279
    rx1536_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1279:
  rx1536_fail:
    (rx1536_rep, rx1536_pos, $I10, $P10) = rx1536_cur."!mark_fail"(0)
    lt rx1536_pos, -1, rx1536_done
    eq rx1536_pos, -1, rx1536_fail
    jump $I10
  rx1536_done:
    rx1536_cur."!cursor_fail"()
    if_null rx1536_debug, debug_1280
    rx1536_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1280:
    .return (rx1536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("318_1303603603.711") :method
.annotate 'line', 10
    $P1538 = self."!PREFIX__!subrule"("O", "+")
    new $P1539, "ResizablePMCArray"
    push $P1539, $P1538
    .return ($P1539)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("319_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1281
    rx1543_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1281:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1547_done
    goto rxscan1547_scan
  rxscan1547_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1547_done
  rxscan1547_scan:
    set_addr $I10, rxscan1547_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1547_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1548_fail
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  # rx literal  "-"
    add $I11, rx1543_pos, 1
    gt $I11, rx1543_eos, rx1543_fail
    sub $I11, rx1543_pos, rx1543_off
    ord $I11, rx1543_tgt, $I11
    ne $I11, 45, rx1543_fail
    add rx1543_pos, 1
    set_addr $I10, rxcap_1548_fail
    ($I12, $I11) = rx1543_cur."!mark_peek"($I10)
    rx1543_cur."!cursor_pos"($I11)
    ($P10) = rx1543_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1543_pos, "")
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1548_done
  rxcap_1548_fail:
    goto rx1543_fail
  rxcap_1548_done:
  # rx subrule "O" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "infix:sym<->")
    if_null rx1543_debug, debug_1282
    rx1543_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1543_pos)
  debug_1282:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 10
    if_null rx1543_debug, debug_1283
    rx1543_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1283:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1284
    rx1543_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1284:
    .return (rx1543_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("320_1303603603.711") :method
.annotate 'line', 10
    $P1545 = self."!PREFIX__!subrule"("O", "-")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("321_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1550_tgt
    .local int rx1550_pos
    .local int rx1550_off
    .local int rx1550_eos
    .local int rx1550_rep
    .local pmc rx1550_cur
    .local pmc rx1550_debug
    (rx1550_cur, rx1550_pos, rx1550_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1550_cur
    .local pmc match
    .lex "$/", match
    length rx1550_eos, rx1550_tgt
    gt rx1550_pos, rx1550_eos, rx1550_done
    set rx1550_off, 0
    lt rx1550_pos, 2, rx1550_start
    sub rx1550_off, rx1550_pos, 1
    substr rx1550_tgt, rx1550_tgt, rx1550_off
  rx1550_start:
    eq $I10, 1, rx1550_restart
    if_null rx1550_debug, debug_1285
    rx1550_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1285:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1554_done
    goto rxscan1554_scan
  rxscan1554_loop:
    (rx1550_pos) = rx1550_cur."from"()
    inc rx1550_pos
    rx1550_cur."!cursor_from"(rx1550_pos)
    ge rx1550_pos, rx1550_eos, rxscan1554_done
  rxscan1554_scan:
    set_addr $I10, rxscan1554_loop
    rx1550_cur."!mark_push"(0, rx1550_pos, $I10)
  rxscan1554_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1555_fail
    rx1550_cur."!mark_push"(0, rx1550_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1550_pos, 2
    gt $I11, rx1550_eos, rx1550_fail
    sub $I11, rx1550_pos, rx1550_off
    substr $S10, rx1550_tgt, $I11, 2
    ne $S10, "+|", rx1550_fail
    add rx1550_pos, 2
    set_addr $I10, rxcap_1555_fail
    ($I12, $I11) = rx1550_cur."!mark_peek"($I10)
    rx1550_cur."!cursor_pos"($I11)
    ($P10) = rx1550_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1550_pos, "")
    rx1550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1555_done
  rxcap_1555_fail:
    goto rx1550_fail
  rxcap_1555_done:
  # rx subrule "O" subtype=capture negate=
    rx1550_cur."!cursor_pos"(rx1550_pos)
    $P10 = rx1550_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1550_fail
    rx1550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1550_pos = $P10."pos"()
  # rx pass
    rx1550_cur."!cursor_pass"(rx1550_pos, "infix:sym<+|>")
    if_null rx1550_debug, debug_1286
    rx1550_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1550_pos)
  debug_1286:
    .return (rx1550_cur)
  rx1550_restart:
.annotate 'line', 10
    if_null rx1550_debug, debug_1287
    rx1550_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1287:
  rx1550_fail:
    (rx1550_rep, rx1550_pos, $I10, $P10) = rx1550_cur."!mark_fail"(0)
    lt rx1550_pos, -1, rx1550_done
    eq rx1550_pos, -1, rx1550_fail
    jump $I10
  rx1550_done:
    rx1550_cur."!cursor_fail"()
    if_null rx1550_debug, debug_1288
    rx1550_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1288:
    .return (rx1550_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("322_1303603603.711") :method
.annotate 'line', 10
    $P1552 = self."!PREFIX__!subrule"("O", "+|")
    new $P1553, "ResizablePMCArray"
    push $P1553, $P1552
    .return ($P1553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("323_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1557_tgt
    .local int rx1557_pos
    .local int rx1557_off
    .local int rx1557_eos
    .local int rx1557_rep
    .local pmc rx1557_cur
    .local pmc rx1557_debug
    (rx1557_cur, rx1557_pos, rx1557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1557_cur
    .local pmc match
    .lex "$/", match
    length rx1557_eos, rx1557_tgt
    gt rx1557_pos, rx1557_eos, rx1557_done
    set rx1557_off, 0
    lt rx1557_pos, 2, rx1557_start
    sub rx1557_off, rx1557_pos, 1
    substr rx1557_tgt, rx1557_tgt, rx1557_off
  rx1557_start:
    eq $I10, 1, rx1557_restart
    if_null rx1557_debug, debug_1289
    rx1557_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1289:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1561_done
    goto rxscan1561_scan
  rxscan1561_loop:
    (rx1557_pos) = rx1557_cur."from"()
    inc rx1557_pos
    rx1557_cur."!cursor_from"(rx1557_pos)
    ge rx1557_pos, rx1557_eos, rxscan1561_done
  rxscan1561_scan:
    set_addr $I10, rxscan1561_loop
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  rxscan1561_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1562_fail
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1557_pos, 2
    gt $I11, rx1557_eos, rx1557_fail
    sub $I11, rx1557_pos, rx1557_off
    substr $S10, rx1557_tgt, $I11, 2
    ne $S10, "+^", rx1557_fail
    add rx1557_pos, 2
    set_addr $I10, rxcap_1562_fail
    ($I12, $I11) = rx1557_cur."!mark_peek"($I10)
    rx1557_cur."!cursor_pos"($I11)
    ($P10) = rx1557_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1557_pos, "")
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1562_done
  rxcap_1562_fail:
    goto rx1557_fail
  rxcap_1562_done:
  # rx subrule "O" subtype=capture negate=
    rx1557_cur."!cursor_pos"(rx1557_pos)
    $P10 = rx1557_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1557_fail
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1557_pos = $P10."pos"()
  # rx pass
    rx1557_cur."!cursor_pass"(rx1557_pos, "infix:sym<+^>")
    if_null rx1557_debug, debug_1290
    rx1557_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1557_pos)
  debug_1290:
    .return (rx1557_cur)
  rx1557_restart:
.annotate 'line', 10
    if_null rx1557_debug, debug_1291
    rx1557_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1291:
  rx1557_fail:
    (rx1557_rep, rx1557_pos, $I10, $P10) = rx1557_cur."!mark_fail"(0)
    lt rx1557_pos, -1, rx1557_done
    eq rx1557_pos, -1, rx1557_fail
    jump $I10
  rx1557_done:
    rx1557_cur."!cursor_fail"()
    if_null rx1557_debug, debug_1292
    rx1557_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1292:
    .return (rx1557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("324_1303603603.711") :method
.annotate 'line', 10
    $P1559 = self."!PREFIX__!subrule"("O", "+^")
    new $P1560, "ResizablePMCArray"
    push $P1560, $P1559
    .return ($P1560)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("325_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1564_tgt
    .local int rx1564_pos
    .local int rx1564_off
    .local int rx1564_eos
    .local int rx1564_rep
    .local pmc rx1564_cur
    .local pmc rx1564_debug
    (rx1564_cur, rx1564_pos, rx1564_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1564_cur
    .local pmc match
    .lex "$/", match
    length rx1564_eos, rx1564_tgt
    gt rx1564_pos, rx1564_eos, rx1564_done
    set rx1564_off, 0
    lt rx1564_pos, 2, rx1564_start
    sub rx1564_off, rx1564_pos, 1
    substr rx1564_tgt, rx1564_tgt, rx1564_off
  rx1564_start:
    eq $I10, 1, rx1564_restart
    if_null rx1564_debug, debug_1293
    rx1564_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1293:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1568_done
    goto rxscan1568_scan
  rxscan1568_loop:
    (rx1564_pos) = rx1564_cur."from"()
    inc rx1564_pos
    rx1564_cur."!cursor_from"(rx1564_pos)
    ge rx1564_pos, rx1564_eos, rxscan1568_done
  rxscan1568_scan:
    set_addr $I10, rxscan1568_loop
    rx1564_cur."!mark_push"(0, rx1564_pos, $I10)
  rxscan1568_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1569_fail
    rx1564_cur."!mark_push"(0, rx1564_pos, $I10)
  # rx literal  "~"
    add $I11, rx1564_pos, 1
    gt $I11, rx1564_eos, rx1564_fail
    sub $I11, rx1564_pos, rx1564_off
    ord $I11, rx1564_tgt, $I11
    ne $I11, 126, rx1564_fail
    add rx1564_pos, 1
    set_addr $I10, rxcap_1569_fail
    ($I12, $I11) = rx1564_cur."!mark_peek"($I10)
    rx1564_cur."!cursor_pos"($I11)
    ($P10) = rx1564_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1564_pos, "")
    rx1564_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1569_done
  rxcap_1569_fail:
    goto rx1564_fail
  rxcap_1569_done:
  # rx subrule "O" subtype=capture negate=
    rx1564_cur."!cursor_pos"(rx1564_pos)
    $P10 = rx1564_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1564_fail
    rx1564_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1564_pos = $P10."pos"()
  # rx pass
    rx1564_cur."!cursor_pass"(rx1564_pos, "infix:sym<~>")
    if_null rx1564_debug, debug_1294
    rx1564_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1564_pos)
  debug_1294:
    .return (rx1564_cur)
  rx1564_restart:
.annotate 'line', 10
    if_null rx1564_debug, debug_1295
    rx1564_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1295:
  rx1564_fail:
    (rx1564_rep, rx1564_pos, $I10, $P10) = rx1564_cur."!mark_fail"(0)
    lt rx1564_pos, -1, rx1564_done
    eq rx1564_pos, -1, rx1564_fail
    jump $I10
  rx1564_done:
    rx1564_cur."!cursor_fail"()
    if_null rx1564_debug, debug_1296
    rx1564_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1296:
    .return (rx1564_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("326_1303603603.711") :method
.annotate 'line', 10
    $P1566 = self."!PREFIX__!subrule"("O", "~")
    new $P1567, "ResizablePMCArray"
    push $P1567, $P1566
    .return ($P1567)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("327_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1571_tgt
    .local int rx1571_pos
    .local int rx1571_off
    .local int rx1571_eos
    .local int rx1571_rep
    .local pmc rx1571_cur
    .local pmc rx1571_debug
    (rx1571_cur, rx1571_pos, rx1571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1571_cur
    .local pmc match
    .lex "$/", match
    length rx1571_eos, rx1571_tgt
    gt rx1571_pos, rx1571_eos, rx1571_done
    set rx1571_off, 0
    lt rx1571_pos, 2, rx1571_start
    sub rx1571_off, rx1571_pos, 1
    substr rx1571_tgt, rx1571_tgt, rx1571_off
  rx1571_start:
    eq $I10, 1, rx1571_restart
    if_null rx1571_debug, debug_1297
    rx1571_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1297:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1575_done
    goto rxscan1575_scan
  rxscan1575_loop:
    (rx1571_pos) = rx1571_cur."from"()
    inc rx1571_pos
    rx1571_cur."!cursor_from"(rx1571_pos)
    ge rx1571_pos, rx1571_eos, rxscan1575_done
  rxscan1575_scan:
    set_addr $I10, rxscan1575_loop
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  rxscan1575_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1576_fail
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  # rx literal  "=="
    add $I11, rx1571_pos, 2
    gt $I11, rx1571_eos, rx1571_fail
    sub $I11, rx1571_pos, rx1571_off
    substr $S10, rx1571_tgt, $I11, 2
    ne $S10, "==", rx1571_fail
    add rx1571_pos, 2
    set_addr $I10, rxcap_1576_fail
    ($I12, $I11) = rx1571_cur."!mark_peek"($I10)
    rx1571_cur."!cursor_pos"($I11)
    ($P10) = rx1571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1571_pos, "")
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1576_done
  rxcap_1576_fail:
    goto rx1571_fail
  rxcap_1576_done:
  # rx subrule "O" subtype=capture negate=
    rx1571_cur."!cursor_pos"(rx1571_pos)
    $P10 = rx1571_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1571_fail
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1571_pos = $P10."pos"()
  # rx pass
    rx1571_cur."!cursor_pass"(rx1571_pos, "infix:sym<==>")
    if_null rx1571_debug, debug_1298
    rx1571_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1571_pos)
  debug_1298:
    .return (rx1571_cur)
  rx1571_restart:
.annotate 'line', 10
    if_null rx1571_debug, debug_1299
    rx1571_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1299:
  rx1571_fail:
    (rx1571_rep, rx1571_pos, $I10, $P10) = rx1571_cur."!mark_fail"(0)
    lt rx1571_pos, -1, rx1571_done
    eq rx1571_pos, -1, rx1571_fail
    jump $I10
  rx1571_done:
    rx1571_cur."!cursor_fail"()
    if_null rx1571_debug, debug_1300
    rx1571_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1300:
    .return (rx1571_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("328_1303603603.711") :method
.annotate 'line', 10
    $P1573 = self."!PREFIX__!subrule"("O", "==")
    new $P1574, "ResizablePMCArray"
    push $P1574, $P1573
    .return ($P1574)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("329_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1301
    rx1578_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1301:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1582_done
    goto rxscan1582_scan
  rxscan1582_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1582_done
  rxscan1582_scan:
    set_addr $I10, rxscan1582_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1582_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1583_fail
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  # rx literal  "!="
    add $I11, rx1578_pos, 2
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    substr $S10, rx1578_tgt, $I11, 2
    ne $S10, "!=", rx1578_fail
    add rx1578_pos, 2
    set_addr $I10, rxcap_1583_fail
    ($I12, $I11) = rx1578_cur."!mark_peek"($I10)
    rx1578_cur."!cursor_pos"($I11)
    ($P10) = rx1578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1578_pos, "")
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1583_done
  rxcap_1583_fail:
    goto rx1578_fail
  rxcap_1583_done:
  # rx subrule "O" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1578_pos = $P10."pos"()
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "infix:sym<!=>")
    if_null rx1578_debug, debug_1302
    rx1578_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1578_pos)
  debug_1302:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 10
    if_null rx1578_debug, debug_1303
    rx1578_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1303:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1304
    rx1578_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1304:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("330_1303603603.711") :method
.annotate 'line', 10
    $P1580 = self."!PREFIX__!subrule"("O", "!=")
    new $P1581, "ResizablePMCArray"
    push $P1581, $P1580
    .return ($P1581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("331_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1585_tgt
    .local int rx1585_pos
    .local int rx1585_off
    .local int rx1585_eos
    .local int rx1585_rep
    .local pmc rx1585_cur
    .local pmc rx1585_debug
    (rx1585_cur, rx1585_pos, rx1585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1585_cur
    .local pmc match
    .lex "$/", match
    length rx1585_eos, rx1585_tgt
    gt rx1585_pos, rx1585_eos, rx1585_done
    set rx1585_off, 0
    lt rx1585_pos, 2, rx1585_start
    sub rx1585_off, rx1585_pos, 1
    substr rx1585_tgt, rx1585_tgt, rx1585_off
  rx1585_start:
    eq $I10, 1, rx1585_restart
    if_null rx1585_debug, debug_1305
    rx1585_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1305:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1589_done
    goto rxscan1589_scan
  rxscan1589_loop:
    (rx1585_pos) = rx1585_cur."from"()
    inc rx1585_pos
    rx1585_cur."!cursor_from"(rx1585_pos)
    ge rx1585_pos, rx1585_eos, rxscan1589_done
  rxscan1589_scan:
    set_addr $I10, rxscan1589_loop
    rx1585_cur."!mark_push"(0, rx1585_pos, $I10)
  rxscan1589_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1590_fail
    rx1585_cur."!mark_push"(0, rx1585_pos, $I10)
  # rx literal  "<="
    add $I11, rx1585_pos, 2
    gt $I11, rx1585_eos, rx1585_fail
    sub $I11, rx1585_pos, rx1585_off
    substr $S10, rx1585_tgt, $I11, 2
    ne $S10, "<=", rx1585_fail
    add rx1585_pos, 2
    set_addr $I10, rxcap_1590_fail
    ($I12, $I11) = rx1585_cur."!mark_peek"($I10)
    rx1585_cur."!cursor_pos"($I11)
    ($P10) = rx1585_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1585_pos, "")
    rx1585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1590_done
  rxcap_1590_fail:
    goto rx1585_fail
  rxcap_1590_done:
  # rx subrule "O" subtype=capture negate=
    rx1585_cur."!cursor_pos"(rx1585_pos)
    $P10 = rx1585_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1585_fail
    rx1585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1585_pos = $P10."pos"()
  # rx pass
    rx1585_cur."!cursor_pass"(rx1585_pos, "infix:sym<<=>")
    if_null rx1585_debug, debug_1306
    rx1585_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1585_pos)
  debug_1306:
    .return (rx1585_cur)
  rx1585_restart:
.annotate 'line', 10
    if_null rx1585_debug, debug_1307
    rx1585_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1307:
  rx1585_fail:
    (rx1585_rep, rx1585_pos, $I10, $P10) = rx1585_cur."!mark_fail"(0)
    lt rx1585_pos, -1, rx1585_done
    eq rx1585_pos, -1, rx1585_fail
    jump $I10
  rx1585_done:
    rx1585_cur."!cursor_fail"()
    if_null rx1585_debug, debug_1308
    rx1585_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1308:
    .return (rx1585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("332_1303603603.711") :method
.annotate 'line', 10
    $P1587 = self."!PREFIX__!subrule"("O", "<=")
    new $P1588, "ResizablePMCArray"
    push $P1588, $P1587
    .return ($P1588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("333_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1592_tgt
    .local int rx1592_pos
    .local int rx1592_off
    .local int rx1592_eos
    .local int rx1592_rep
    .local pmc rx1592_cur
    .local pmc rx1592_debug
    (rx1592_cur, rx1592_pos, rx1592_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1592_cur
    .local pmc match
    .lex "$/", match
    length rx1592_eos, rx1592_tgt
    gt rx1592_pos, rx1592_eos, rx1592_done
    set rx1592_off, 0
    lt rx1592_pos, 2, rx1592_start
    sub rx1592_off, rx1592_pos, 1
    substr rx1592_tgt, rx1592_tgt, rx1592_off
  rx1592_start:
    eq $I10, 1, rx1592_restart
    if_null rx1592_debug, debug_1309
    rx1592_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1309:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1596_done
    goto rxscan1596_scan
  rxscan1596_loop:
    (rx1592_pos) = rx1592_cur."from"()
    inc rx1592_pos
    rx1592_cur."!cursor_from"(rx1592_pos)
    ge rx1592_pos, rx1592_eos, rxscan1596_done
  rxscan1596_scan:
    set_addr $I10, rxscan1596_loop
    rx1592_cur."!mark_push"(0, rx1592_pos, $I10)
  rxscan1596_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1597_fail
    rx1592_cur."!mark_push"(0, rx1592_pos, $I10)
  # rx literal  ">="
    add $I11, rx1592_pos, 2
    gt $I11, rx1592_eos, rx1592_fail
    sub $I11, rx1592_pos, rx1592_off
    substr $S10, rx1592_tgt, $I11, 2
    ne $S10, ">=", rx1592_fail
    add rx1592_pos, 2
    set_addr $I10, rxcap_1597_fail
    ($I12, $I11) = rx1592_cur."!mark_peek"($I10)
    rx1592_cur."!cursor_pos"($I11)
    ($P10) = rx1592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1592_pos, "")
    rx1592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1597_done
  rxcap_1597_fail:
    goto rx1592_fail
  rxcap_1597_done:
  # rx subrule "O" subtype=capture negate=
    rx1592_cur."!cursor_pos"(rx1592_pos)
    $P10 = rx1592_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1592_fail
    rx1592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1592_pos = $P10."pos"()
  # rx pass
    rx1592_cur."!cursor_pass"(rx1592_pos, "infix:sym<>=>")
    if_null rx1592_debug, debug_1310
    rx1592_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1592_pos)
  debug_1310:
    .return (rx1592_cur)
  rx1592_restart:
.annotate 'line', 10
    if_null rx1592_debug, debug_1311
    rx1592_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1311:
  rx1592_fail:
    (rx1592_rep, rx1592_pos, $I10, $P10) = rx1592_cur."!mark_fail"(0)
    lt rx1592_pos, -1, rx1592_done
    eq rx1592_pos, -1, rx1592_fail
    jump $I10
  rx1592_done:
    rx1592_cur."!cursor_fail"()
    if_null rx1592_debug, debug_1312
    rx1592_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1312:
    .return (rx1592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("334_1303603603.711") :method
.annotate 'line', 10
    $P1594 = self."!PREFIX__!subrule"("O", ">=")
    new $P1595, "ResizablePMCArray"
    push $P1595, $P1594
    .return ($P1595)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("335_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1599_tgt
    .local int rx1599_pos
    .local int rx1599_off
    .local int rx1599_eos
    .local int rx1599_rep
    .local pmc rx1599_cur
    .local pmc rx1599_debug
    (rx1599_cur, rx1599_pos, rx1599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1599_cur
    .local pmc match
    .lex "$/", match
    length rx1599_eos, rx1599_tgt
    gt rx1599_pos, rx1599_eos, rx1599_done
    set rx1599_off, 0
    lt rx1599_pos, 2, rx1599_start
    sub rx1599_off, rx1599_pos, 1
    substr rx1599_tgt, rx1599_tgt, rx1599_off
  rx1599_start:
    eq $I10, 1, rx1599_restart
    if_null rx1599_debug, debug_1313
    rx1599_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1313:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1603_done
    goto rxscan1603_scan
  rxscan1603_loop:
    (rx1599_pos) = rx1599_cur."from"()
    inc rx1599_pos
    rx1599_cur."!cursor_from"(rx1599_pos)
    ge rx1599_pos, rx1599_eos, rxscan1603_done
  rxscan1603_scan:
    set_addr $I10, rxscan1603_loop
    rx1599_cur."!mark_push"(0, rx1599_pos, $I10)
  rxscan1603_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1604_fail
    rx1599_cur."!mark_push"(0, rx1599_pos, $I10)
  # rx literal  "<"
    add $I11, rx1599_pos, 1
    gt $I11, rx1599_eos, rx1599_fail
    sub $I11, rx1599_pos, rx1599_off
    ord $I11, rx1599_tgt, $I11
    ne $I11, 60, rx1599_fail
    add rx1599_pos, 1
    set_addr $I10, rxcap_1604_fail
    ($I12, $I11) = rx1599_cur."!mark_peek"($I10)
    rx1599_cur."!cursor_pos"($I11)
    ($P10) = rx1599_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1599_pos, "")
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1604_done
  rxcap_1604_fail:
    goto rx1599_fail
  rxcap_1604_done:
  # rx subrule "O" subtype=capture negate=
    rx1599_cur."!cursor_pos"(rx1599_pos)
    $P10 = rx1599_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1599_fail
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1599_pos = $P10."pos"()
  # rx pass
    rx1599_cur."!cursor_pass"(rx1599_pos, "infix:sym<<>")
    if_null rx1599_debug, debug_1314
    rx1599_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1599_pos)
  debug_1314:
    .return (rx1599_cur)
  rx1599_restart:
.annotate 'line', 10
    if_null rx1599_debug, debug_1315
    rx1599_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1315:
  rx1599_fail:
    (rx1599_rep, rx1599_pos, $I10, $P10) = rx1599_cur."!mark_fail"(0)
    lt rx1599_pos, -1, rx1599_done
    eq rx1599_pos, -1, rx1599_fail
    jump $I10
  rx1599_done:
    rx1599_cur."!cursor_fail"()
    if_null rx1599_debug, debug_1316
    rx1599_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1316:
    .return (rx1599_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("336_1303603603.711") :method
.annotate 'line', 10
    $P1601 = self."!PREFIX__!subrule"("O", "<")
    new $P1602, "ResizablePMCArray"
    push $P1602, $P1601
    .return ($P1602)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("337_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1606_tgt
    .local int rx1606_pos
    .local int rx1606_off
    .local int rx1606_eos
    .local int rx1606_rep
    .local pmc rx1606_cur
    .local pmc rx1606_debug
    (rx1606_cur, rx1606_pos, rx1606_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1606_cur
    .local pmc match
    .lex "$/", match
    length rx1606_eos, rx1606_tgt
    gt rx1606_pos, rx1606_eos, rx1606_done
    set rx1606_off, 0
    lt rx1606_pos, 2, rx1606_start
    sub rx1606_off, rx1606_pos, 1
    substr rx1606_tgt, rx1606_tgt, rx1606_off
  rx1606_start:
    eq $I10, 1, rx1606_restart
    if_null rx1606_debug, debug_1317
    rx1606_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1317:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1610_done
    goto rxscan1610_scan
  rxscan1610_loop:
    (rx1606_pos) = rx1606_cur."from"()
    inc rx1606_pos
    rx1606_cur."!cursor_from"(rx1606_pos)
    ge rx1606_pos, rx1606_eos, rxscan1610_done
  rxscan1610_scan:
    set_addr $I10, rxscan1610_loop
    rx1606_cur."!mark_push"(0, rx1606_pos, $I10)
  rxscan1610_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1611_fail
    rx1606_cur."!mark_push"(0, rx1606_pos, $I10)
  # rx literal  ">"
    add $I11, rx1606_pos, 1
    gt $I11, rx1606_eos, rx1606_fail
    sub $I11, rx1606_pos, rx1606_off
    ord $I11, rx1606_tgt, $I11
    ne $I11, 62, rx1606_fail
    add rx1606_pos, 1
    set_addr $I10, rxcap_1611_fail
    ($I12, $I11) = rx1606_cur."!mark_peek"($I10)
    rx1606_cur."!cursor_pos"($I11)
    ($P10) = rx1606_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1606_pos, "")
    rx1606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1611_done
  rxcap_1611_fail:
    goto rx1606_fail
  rxcap_1611_done:
  # rx subrule "O" subtype=capture negate=
    rx1606_cur."!cursor_pos"(rx1606_pos)
    $P10 = rx1606_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1606_fail
    rx1606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1606_pos = $P10."pos"()
  # rx pass
    rx1606_cur."!cursor_pass"(rx1606_pos, "infix:sym<>>")
    if_null rx1606_debug, debug_1318
    rx1606_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1606_pos)
  debug_1318:
    .return (rx1606_cur)
  rx1606_restart:
.annotate 'line', 10
    if_null rx1606_debug, debug_1319
    rx1606_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1319:
  rx1606_fail:
    (rx1606_rep, rx1606_pos, $I10, $P10) = rx1606_cur."!mark_fail"(0)
    lt rx1606_pos, -1, rx1606_done
    eq rx1606_pos, -1, rx1606_fail
    jump $I10
  rx1606_done:
    rx1606_cur."!cursor_fail"()
    if_null rx1606_debug, debug_1320
    rx1606_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1320:
    .return (rx1606_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("338_1303603603.711") :method
.annotate 'line', 10
    $P1608 = self."!PREFIX__!subrule"("O", ">")
    new $P1609, "ResizablePMCArray"
    push $P1609, $P1608
    .return ($P1609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("339_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1613_tgt
    .local int rx1613_pos
    .local int rx1613_off
    .local int rx1613_eos
    .local int rx1613_rep
    .local pmc rx1613_cur
    .local pmc rx1613_debug
    (rx1613_cur, rx1613_pos, rx1613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1613_cur
    .local pmc match
    .lex "$/", match
    length rx1613_eos, rx1613_tgt
    gt rx1613_pos, rx1613_eos, rx1613_done
    set rx1613_off, 0
    lt rx1613_pos, 2, rx1613_start
    sub rx1613_off, rx1613_pos, 1
    substr rx1613_tgt, rx1613_tgt, rx1613_off
  rx1613_start:
    eq $I10, 1, rx1613_restart
    if_null rx1613_debug, debug_1321
    rx1613_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1321:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1617_done
    goto rxscan1617_scan
  rxscan1617_loop:
    (rx1613_pos) = rx1613_cur."from"()
    inc rx1613_pos
    rx1613_cur."!cursor_from"(rx1613_pos)
    ge rx1613_pos, rx1613_eos, rxscan1617_done
  rxscan1617_scan:
    set_addr $I10, rxscan1617_loop
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  rxscan1617_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1618_fail
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1613_pos, 2
    gt $I11, rx1613_eos, rx1613_fail
    sub $I11, rx1613_pos, rx1613_off
    substr $S10, rx1613_tgt, $I11, 2
    ne $S10, "eq", rx1613_fail
    add rx1613_pos, 2
    set_addr $I10, rxcap_1618_fail
    ($I12, $I11) = rx1613_cur."!mark_peek"($I10)
    rx1613_cur."!cursor_pos"($I11)
    ($P10) = rx1613_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1613_pos, "")
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1618_done
  rxcap_1618_fail:
    goto rx1613_fail
  rxcap_1618_done:
  # rx subrule "O" subtype=capture negate=
    rx1613_cur."!cursor_pos"(rx1613_pos)
    $P10 = rx1613_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1613_fail
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1613_pos = $P10."pos"()
  # rx pass
    rx1613_cur."!cursor_pass"(rx1613_pos, "infix:sym<eq>")
    if_null rx1613_debug, debug_1322
    rx1613_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1613_pos)
  debug_1322:
    .return (rx1613_cur)
  rx1613_restart:
.annotate 'line', 10
    if_null rx1613_debug, debug_1323
    rx1613_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1323:
  rx1613_fail:
    (rx1613_rep, rx1613_pos, $I10, $P10) = rx1613_cur."!mark_fail"(0)
    lt rx1613_pos, -1, rx1613_done
    eq rx1613_pos, -1, rx1613_fail
    jump $I10
  rx1613_done:
    rx1613_cur."!cursor_fail"()
    if_null rx1613_debug, debug_1324
    rx1613_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1324:
    .return (rx1613_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("340_1303603603.711") :method
.annotate 'line', 10
    $P1615 = self."!PREFIX__!subrule"("O", "eq")
    new $P1616, "ResizablePMCArray"
    push $P1616, $P1615
    .return ($P1616)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("341_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1620_tgt
    .local int rx1620_pos
    .local int rx1620_off
    .local int rx1620_eos
    .local int rx1620_rep
    .local pmc rx1620_cur
    .local pmc rx1620_debug
    (rx1620_cur, rx1620_pos, rx1620_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1620_cur
    .local pmc match
    .lex "$/", match
    length rx1620_eos, rx1620_tgt
    gt rx1620_pos, rx1620_eos, rx1620_done
    set rx1620_off, 0
    lt rx1620_pos, 2, rx1620_start
    sub rx1620_off, rx1620_pos, 1
    substr rx1620_tgt, rx1620_tgt, rx1620_off
  rx1620_start:
    eq $I10, 1, rx1620_restart
    if_null rx1620_debug, debug_1325
    rx1620_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1624_done
    goto rxscan1624_scan
  rxscan1624_loop:
    (rx1620_pos) = rx1620_cur."from"()
    inc rx1620_pos
    rx1620_cur."!cursor_from"(rx1620_pos)
    ge rx1620_pos, rx1620_eos, rxscan1624_done
  rxscan1624_scan:
    set_addr $I10, rxscan1624_loop
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  rxscan1624_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1625_fail
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1620_pos, 2
    gt $I11, rx1620_eos, rx1620_fail
    sub $I11, rx1620_pos, rx1620_off
    substr $S10, rx1620_tgt, $I11, 2
    ne $S10, "ne", rx1620_fail
    add rx1620_pos, 2
    set_addr $I10, rxcap_1625_fail
    ($I12, $I11) = rx1620_cur."!mark_peek"($I10)
    rx1620_cur."!cursor_pos"($I11)
    ($P10) = rx1620_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1620_pos, "")
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1625_done
  rxcap_1625_fail:
    goto rx1620_fail
  rxcap_1625_done:
  # rx subrule "O" subtype=capture negate=
    rx1620_cur."!cursor_pos"(rx1620_pos)
    $P10 = rx1620_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1620_fail
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1620_pos = $P10."pos"()
  # rx pass
    rx1620_cur."!cursor_pass"(rx1620_pos, "infix:sym<ne>")
    if_null rx1620_debug, debug_1326
    rx1620_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1620_pos)
  debug_1326:
    .return (rx1620_cur)
  rx1620_restart:
.annotate 'line', 10
    if_null rx1620_debug, debug_1327
    rx1620_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1327:
  rx1620_fail:
    (rx1620_rep, rx1620_pos, $I10, $P10) = rx1620_cur."!mark_fail"(0)
    lt rx1620_pos, -1, rx1620_done
    eq rx1620_pos, -1, rx1620_fail
    jump $I10
  rx1620_done:
    rx1620_cur."!cursor_fail"()
    if_null rx1620_debug, debug_1328
    rx1620_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1328:
    .return (rx1620_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("342_1303603603.711") :method
.annotate 'line', 10
    $P1622 = self."!PREFIX__!subrule"("O", "ne")
    new $P1623, "ResizablePMCArray"
    push $P1623, $P1622
    .return ($P1623)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("343_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1627_tgt
    .local int rx1627_pos
    .local int rx1627_off
    .local int rx1627_eos
    .local int rx1627_rep
    .local pmc rx1627_cur
    .local pmc rx1627_debug
    (rx1627_cur, rx1627_pos, rx1627_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1627_cur
    .local pmc match
    .lex "$/", match
    length rx1627_eos, rx1627_tgt
    gt rx1627_pos, rx1627_eos, rx1627_done
    set rx1627_off, 0
    lt rx1627_pos, 2, rx1627_start
    sub rx1627_off, rx1627_pos, 1
    substr rx1627_tgt, rx1627_tgt, rx1627_off
  rx1627_start:
    eq $I10, 1, rx1627_restart
    if_null rx1627_debug, debug_1329
    rx1627_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1329:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1631_done
    goto rxscan1631_scan
  rxscan1631_loop:
    (rx1627_pos) = rx1627_cur."from"()
    inc rx1627_pos
    rx1627_cur."!cursor_from"(rx1627_pos)
    ge rx1627_pos, rx1627_eos, rxscan1631_done
  rxscan1631_scan:
    set_addr $I10, rxscan1631_loop
    rx1627_cur."!mark_push"(0, rx1627_pos, $I10)
  rxscan1631_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1632_fail
    rx1627_cur."!mark_push"(0, rx1627_pos, $I10)
  # rx literal  "le"
    add $I11, rx1627_pos, 2
    gt $I11, rx1627_eos, rx1627_fail
    sub $I11, rx1627_pos, rx1627_off
    substr $S10, rx1627_tgt, $I11, 2
    ne $S10, "le", rx1627_fail
    add rx1627_pos, 2
    set_addr $I10, rxcap_1632_fail
    ($I12, $I11) = rx1627_cur."!mark_peek"($I10)
    rx1627_cur."!cursor_pos"($I11)
    ($P10) = rx1627_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1627_pos, "")
    rx1627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1632_done
  rxcap_1632_fail:
    goto rx1627_fail
  rxcap_1632_done:
  # rx subrule "O" subtype=capture negate=
    rx1627_cur."!cursor_pos"(rx1627_pos)
    $P10 = rx1627_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1627_fail
    rx1627_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1627_pos = $P10."pos"()
  # rx pass
    rx1627_cur."!cursor_pass"(rx1627_pos, "infix:sym<le>")
    if_null rx1627_debug, debug_1330
    rx1627_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1627_pos)
  debug_1330:
    .return (rx1627_cur)
  rx1627_restart:
.annotate 'line', 10
    if_null rx1627_debug, debug_1331
    rx1627_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1331:
  rx1627_fail:
    (rx1627_rep, rx1627_pos, $I10, $P10) = rx1627_cur."!mark_fail"(0)
    lt rx1627_pos, -1, rx1627_done
    eq rx1627_pos, -1, rx1627_fail
    jump $I10
  rx1627_done:
    rx1627_cur."!cursor_fail"()
    if_null rx1627_debug, debug_1332
    rx1627_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1332:
    .return (rx1627_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("344_1303603603.711") :method
.annotate 'line', 10
    $P1629 = self."!PREFIX__!subrule"("O", "le")
    new $P1630, "ResizablePMCArray"
    push $P1630, $P1629
    .return ($P1630)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("345_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1634_tgt
    .local int rx1634_pos
    .local int rx1634_off
    .local int rx1634_eos
    .local int rx1634_rep
    .local pmc rx1634_cur
    .local pmc rx1634_debug
    (rx1634_cur, rx1634_pos, rx1634_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1634_cur
    .local pmc match
    .lex "$/", match
    length rx1634_eos, rx1634_tgt
    gt rx1634_pos, rx1634_eos, rx1634_done
    set rx1634_off, 0
    lt rx1634_pos, 2, rx1634_start
    sub rx1634_off, rx1634_pos, 1
    substr rx1634_tgt, rx1634_tgt, rx1634_off
  rx1634_start:
    eq $I10, 1, rx1634_restart
    if_null rx1634_debug, debug_1333
    rx1634_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1638_done
    goto rxscan1638_scan
  rxscan1638_loop:
    (rx1634_pos) = rx1634_cur."from"()
    inc rx1634_pos
    rx1634_cur."!cursor_from"(rx1634_pos)
    ge rx1634_pos, rx1634_eos, rxscan1638_done
  rxscan1638_scan:
    set_addr $I10, rxscan1638_loop
    rx1634_cur."!mark_push"(0, rx1634_pos, $I10)
  rxscan1638_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1639_fail
    rx1634_cur."!mark_push"(0, rx1634_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1634_pos, 2
    gt $I11, rx1634_eos, rx1634_fail
    sub $I11, rx1634_pos, rx1634_off
    substr $S10, rx1634_tgt, $I11, 2
    ne $S10, "ge", rx1634_fail
    add rx1634_pos, 2
    set_addr $I10, rxcap_1639_fail
    ($I12, $I11) = rx1634_cur."!mark_peek"($I10)
    rx1634_cur."!cursor_pos"($I11)
    ($P10) = rx1634_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1634_pos, "")
    rx1634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1639_done
  rxcap_1639_fail:
    goto rx1634_fail
  rxcap_1639_done:
  # rx subrule "O" subtype=capture negate=
    rx1634_cur."!cursor_pos"(rx1634_pos)
    $P10 = rx1634_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1634_fail
    rx1634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1634_pos = $P10."pos"()
  # rx pass
    rx1634_cur."!cursor_pass"(rx1634_pos, "infix:sym<ge>")
    if_null rx1634_debug, debug_1334
    rx1634_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1634_pos)
  debug_1334:
    .return (rx1634_cur)
  rx1634_restart:
.annotate 'line', 10
    if_null rx1634_debug, debug_1335
    rx1634_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1335:
  rx1634_fail:
    (rx1634_rep, rx1634_pos, $I10, $P10) = rx1634_cur."!mark_fail"(0)
    lt rx1634_pos, -1, rx1634_done
    eq rx1634_pos, -1, rx1634_fail
    jump $I10
  rx1634_done:
    rx1634_cur."!cursor_fail"()
    if_null rx1634_debug, debug_1336
    rx1634_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1336:
    .return (rx1634_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("346_1303603603.711") :method
.annotate 'line', 10
    $P1636 = self."!PREFIX__!subrule"("O", "ge")
    new $P1637, "ResizablePMCArray"
    push $P1637, $P1636
    .return ($P1637)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("347_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1641_tgt
    .local int rx1641_pos
    .local int rx1641_off
    .local int rx1641_eos
    .local int rx1641_rep
    .local pmc rx1641_cur
    .local pmc rx1641_debug
    (rx1641_cur, rx1641_pos, rx1641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1641_cur
    .local pmc match
    .lex "$/", match
    length rx1641_eos, rx1641_tgt
    gt rx1641_pos, rx1641_eos, rx1641_done
    set rx1641_off, 0
    lt rx1641_pos, 2, rx1641_start
    sub rx1641_off, rx1641_pos, 1
    substr rx1641_tgt, rx1641_tgt, rx1641_off
  rx1641_start:
    eq $I10, 1, rx1641_restart
    if_null rx1641_debug, debug_1337
    rx1641_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1645_done
    goto rxscan1645_scan
  rxscan1645_loop:
    (rx1641_pos) = rx1641_cur."from"()
    inc rx1641_pos
    rx1641_cur."!cursor_from"(rx1641_pos)
    ge rx1641_pos, rx1641_eos, rxscan1645_done
  rxscan1645_scan:
    set_addr $I10, rxscan1645_loop
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  rxscan1645_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1646_fail
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1641_pos, 2
    gt $I11, rx1641_eos, rx1641_fail
    sub $I11, rx1641_pos, rx1641_off
    substr $S10, rx1641_tgt, $I11, 2
    ne $S10, "lt", rx1641_fail
    add rx1641_pos, 2
    set_addr $I10, rxcap_1646_fail
    ($I12, $I11) = rx1641_cur."!mark_peek"($I10)
    rx1641_cur."!cursor_pos"($I11)
    ($P10) = rx1641_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1641_pos, "")
    rx1641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1646_done
  rxcap_1646_fail:
    goto rx1641_fail
  rxcap_1646_done:
  # rx subrule "O" subtype=capture negate=
    rx1641_cur."!cursor_pos"(rx1641_pos)
    $P10 = rx1641_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1641_fail
    rx1641_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1641_pos = $P10."pos"()
  # rx pass
    rx1641_cur."!cursor_pass"(rx1641_pos, "infix:sym<lt>")
    if_null rx1641_debug, debug_1338
    rx1641_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1641_pos)
  debug_1338:
    .return (rx1641_cur)
  rx1641_restart:
.annotate 'line', 10
    if_null rx1641_debug, debug_1339
    rx1641_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1339:
  rx1641_fail:
    (rx1641_rep, rx1641_pos, $I10, $P10) = rx1641_cur."!mark_fail"(0)
    lt rx1641_pos, -1, rx1641_done
    eq rx1641_pos, -1, rx1641_fail
    jump $I10
  rx1641_done:
    rx1641_cur."!cursor_fail"()
    if_null rx1641_debug, debug_1340
    rx1641_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1340:
    .return (rx1641_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("348_1303603603.711") :method
.annotate 'line', 10
    $P1643 = self."!PREFIX__!subrule"("O", "lt")
    new $P1644, "ResizablePMCArray"
    push $P1644, $P1643
    .return ($P1644)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("349_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1648_tgt
    .local int rx1648_pos
    .local int rx1648_off
    .local int rx1648_eos
    .local int rx1648_rep
    .local pmc rx1648_cur
    .local pmc rx1648_debug
    (rx1648_cur, rx1648_pos, rx1648_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1648_cur
    .local pmc match
    .lex "$/", match
    length rx1648_eos, rx1648_tgt
    gt rx1648_pos, rx1648_eos, rx1648_done
    set rx1648_off, 0
    lt rx1648_pos, 2, rx1648_start
    sub rx1648_off, rx1648_pos, 1
    substr rx1648_tgt, rx1648_tgt, rx1648_off
  rx1648_start:
    eq $I10, 1, rx1648_restart
    if_null rx1648_debug, debug_1341
    rx1648_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1341:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1652_done
    goto rxscan1652_scan
  rxscan1652_loop:
    (rx1648_pos) = rx1648_cur."from"()
    inc rx1648_pos
    rx1648_cur."!cursor_from"(rx1648_pos)
    ge rx1648_pos, rx1648_eos, rxscan1652_done
  rxscan1652_scan:
    set_addr $I10, rxscan1652_loop
    rx1648_cur."!mark_push"(0, rx1648_pos, $I10)
  rxscan1652_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1653_fail
    rx1648_cur."!mark_push"(0, rx1648_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1648_pos, 2
    gt $I11, rx1648_eos, rx1648_fail
    sub $I11, rx1648_pos, rx1648_off
    substr $S10, rx1648_tgt, $I11, 2
    ne $S10, "gt", rx1648_fail
    add rx1648_pos, 2
    set_addr $I10, rxcap_1653_fail
    ($I12, $I11) = rx1648_cur."!mark_peek"($I10)
    rx1648_cur."!cursor_pos"($I11)
    ($P10) = rx1648_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1648_pos, "")
    rx1648_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1653_done
  rxcap_1653_fail:
    goto rx1648_fail
  rxcap_1653_done:
  # rx subrule "O" subtype=capture negate=
    rx1648_cur."!cursor_pos"(rx1648_pos)
    $P10 = rx1648_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1648_fail
    rx1648_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1648_pos = $P10."pos"()
  # rx pass
    rx1648_cur."!cursor_pass"(rx1648_pos, "infix:sym<gt>")
    if_null rx1648_debug, debug_1342
    rx1648_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1648_pos)
  debug_1342:
    .return (rx1648_cur)
  rx1648_restart:
.annotate 'line', 10
    if_null rx1648_debug, debug_1343
    rx1648_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1343:
  rx1648_fail:
    (rx1648_rep, rx1648_pos, $I10, $P10) = rx1648_cur."!mark_fail"(0)
    lt rx1648_pos, -1, rx1648_done
    eq rx1648_pos, -1, rx1648_fail
    jump $I10
  rx1648_done:
    rx1648_cur."!cursor_fail"()
    if_null rx1648_debug, debug_1344
    rx1648_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1344:
    .return (rx1648_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("350_1303603603.711") :method
.annotate 'line', 10
    $P1650 = self."!PREFIX__!subrule"("O", "gt")
    new $P1651, "ResizablePMCArray"
    push $P1651, $P1650
    .return ($P1651)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("351_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1655_tgt
    .local int rx1655_pos
    .local int rx1655_off
    .local int rx1655_eos
    .local int rx1655_rep
    .local pmc rx1655_cur
    .local pmc rx1655_debug
    (rx1655_cur, rx1655_pos, rx1655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1655_cur
    .local pmc match
    .lex "$/", match
    length rx1655_eos, rx1655_tgt
    gt rx1655_pos, rx1655_eos, rx1655_done
    set rx1655_off, 0
    lt rx1655_pos, 2, rx1655_start
    sub rx1655_off, rx1655_pos, 1
    substr rx1655_tgt, rx1655_tgt, rx1655_off
  rx1655_start:
    eq $I10, 1, rx1655_restart
    if_null rx1655_debug, debug_1345
    rx1655_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1659_done
    goto rxscan1659_scan
  rxscan1659_loop:
    (rx1655_pos) = rx1655_cur."from"()
    inc rx1655_pos
    rx1655_cur."!cursor_from"(rx1655_pos)
    ge rx1655_pos, rx1655_eos, rxscan1659_done
  rxscan1659_scan:
    set_addr $I10, rxscan1659_loop
    rx1655_cur."!mark_push"(0, rx1655_pos, $I10)
  rxscan1659_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1660_fail
    rx1655_cur."!mark_push"(0, rx1655_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1655_pos, 3
    gt $I11, rx1655_eos, rx1655_fail
    sub $I11, rx1655_pos, rx1655_off
    substr $S10, rx1655_tgt, $I11, 3
    ne $S10, "=:=", rx1655_fail
    add rx1655_pos, 3
    set_addr $I10, rxcap_1660_fail
    ($I12, $I11) = rx1655_cur."!mark_peek"($I10)
    rx1655_cur."!cursor_pos"($I11)
    ($P10) = rx1655_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1655_pos, "")
    rx1655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1660_done
  rxcap_1660_fail:
    goto rx1655_fail
  rxcap_1660_done:
  # rx subrule "O" subtype=capture negate=
    rx1655_cur."!cursor_pos"(rx1655_pos)
    $P10 = rx1655_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1655_fail
    rx1655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1655_pos = $P10."pos"()
  # rx pass
    rx1655_cur."!cursor_pass"(rx1655_pos, "infix:sym<=:=>")
    if_null rx1655_debug, debug_1346
    rx1655_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1655_pos)
  debug_1346:
    .return (rx1655_cur)
  rx1655_restart:
.annotate 'line', 10
    if_null rx1655_debug, debug_1347
    rx1655_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1347:
  rx1655_fail:
    (rx1655_rep, rx1655_pos, $I10, $P10) = rx1655_cur."!mark_fail"(0)
    lt rx1655_pos, -1, rx1655_done
    eq rx1655_pos, -1, rx1655_fail
    jump $I10
  rx1655_done:
    rx1655_cur."!cursor_fail"()
    if_null rx1655_debug, debug_1348
    rx1655_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1348:
    .return (rx1655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("352_1303603603.711") :method
.annotate 'line', 10
    $P1657 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1658, "ResizablePMCArray"
    push $P1658, $P1657
    .return ($P1658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("353_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1662_tgt
    .local int rx1662_pos
    .local int rx1662_off
    .local int rx1662_eos
    .local int rx1662_rep
    .local pmc rx1662_cur
    .local pmc rx1662_debug
    (rx1662_cur, rx1662_pos, rx1662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1662_cur
    .local pmc match
    .lex "$/", match
    length rx1662_eos, rx1662_tgt
    gt rx1662_pos, rx1662_eos, rx1662_done
    set rx1662_off, 0
    lt rx1662_pos, 2, rx1662_start
    sub rx1662_off, rx1662_pos, 1
    substr rx1662_tgt, rx1662_tgt, rx1662_off
  rx1662_start:
    eq $I10, 1, rx1662_restart
    if_null rx1662_debug, debug_1349
    rx1662_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1666_done
    goto rxscan1666_scan
  rxscan1666_loop:
    (rx1662_pos) = rx1662_cur."from"()
    inc rx1662_pos
    rx1662_cur."!cursor_from"(rx1662_pos)
    ge rx1662_pos, rx1662_eos, rxscan1666_done
  rxscan1666_scan:
    set_addr $I10, rxscan1666_loop
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxscan1666_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1667_fail
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1662_pos, 2
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 2
    ne $S10, "~~", rx1662_fail
    add rx1662_pos, 2
    set_addr $I10, rxcap_1667_fail
    ($I12, $I11) = rx1662_cur."!mark_peek"($I10)
    rx1662_cur."!cursor_pos"($I11)
    ($P10) = rx1662_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1662_pos, "")
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1667_done
  rxcap_1667_fail:
    goto rx1662_fail
  rxcap_1667_done:
  # rx subrule "O" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1662_pos = $P10."pos"()
  # rx pass
    rx1662_cur."!cursor_pass"(rx1662_pos, "infix:sym<~~>")
    if_null rx1662_debug, debug_1350
    rx1662_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1662_pos)
  debug_1350:
    .return (rx1662_cur)
  rx1662_restart:
.annotate 'line', 10
    if_null rx1662_debug, debug_1351
    rx1662_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1351:
  rx1662_fail:
    (rx1662_rep, rx1662_pos, $I10, $P10) = rx1662_cur."!mark_fail"(0)
    lt rx1662_pos, -1, rx1662_done
    eq rx1662_pos, -1, rx1662_fail
    jump $I10
  rx1662_done:
    rx1662_cur."!cursor_fail"()
    if_null rx1662_debug, debug_1352
    rx1662_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1352:
    .return (rx1662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("354_1303603603.711") :method
.annotate 'line', 10
    $P1664 = self."!PREFIX__!subrule"("O", "~~")
    new $P1665, "ResizablePMCArray"
    push $P1665, $P1664
    .return ($P1665)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("355_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1669_tgt
    .local int rx1669_pos
    .local int rx1669_off
    .local int rx1669_eos
    .local int rx1669_rep
    .local pmc rx1669_cur
    .local pmc rx1669_debug
    (rx1669_cur, rx1669_pos, rx1669_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1669_cur
    .local pmc match
    .lex "$/", match
    length rx1669_eos, rx1669_tgt
    gt rx1669_pos, rx1669_eos, rx1669_done
    set rx1669_off, 0
    lt rx1669_pos, 2, rx1669_start
    sub rx1669_off, rx1669_pos, 1
    substr rx1669_tgt, rx1669_tgt, rx1669_off
  rx1669_start:
    eq $I10, 1, rx1669_restart
    if_null rx1669_debug, debug_1353
    rx1669_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1353:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1673_done
    goto rxscan1673_scan
  rxscan1673_loop:
    (rx1669_pos) = rx1669_cur."from"()
    inc rx1669_pos
    rx1669_cur."!cursor_from"(rx1669_pos)
    ge rx1669_pos, rx1669_eos, rxscan1673_done
  rxscan1673_scan:
    set_addr $I10, rxscan1673_loop
    rx1669_cur."!mark_push"(0, rx1669_pos, $I10)
  rxscan1673_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1674_fail
    rx1669_cur."!mark_push"(0, rx1669_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1669_pos, 2
    gt $I11, rx1669_eos, rx1669_fail
    sub $I11, rx1669_pos, rx1669_off
    substr $S10, rx1669_tgt, $I11, 2
    ne $S10, "&&", rx1669_fail
    add rx1669_pos, 2
    set_addr $I10, rxcap_1674_fail
    ($I12, $I11) = rx1669_cur."!mark_peek"($I10)
    rx1669_cur."!cursor_pos"($I11)
    ($P10) = rx1669_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1669_pos, "")
    rx1669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1674_done
  rxcap_1674_fail:
    goto rx1669_fail
  rxcap_1674_done:
  # rx subrule "O" subtype=capture negate=
    rx1669_cur."!cursor_pos"(rx1669_pos)
    $P10 = rx1669_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1669_fail
    rx1669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1669_pos = $P10."pos"()
  # rx pass
    rx1669_cur."!cursor_pass"(rx1669_pos, "infix:sym<&&>")
    if_null rx1669_debug, debug_1354
    rx1669_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1669_pos)
  debug_1354:
    .return (rx1669_cur)
  rx1669_restart:
.annotate 'line', 10
    if_null rx1669_debug, debug_1355
    rx1669_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1355:
  rx1669_fail:
    (rx1669_rep, rx1669_pos, $I10, $P10) = rx1669_cur."!mark_fail"(0)
    lt rx1669_pos, -1, rx1669_done
    eq rx1669_pos, -1, rx1669_fail
    jump $I10
  rx1669_done:
    rx1669_cur."!cursor_fail"()
    if_null rx1669_debug, debug_1356
    rx1669_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1356:
    .return (rx1669_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("356_1303603603.711") :method
.annotate 'line', 10
    $P1671 = self."!PREFIX__!subrule"("O", "&&")
    new $P1672, "ResizablePMCArray"
    push $P1672, $P1671
    .return ($P1672)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("357_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1676_tgt
    .local int rx1676_pos
    .local int rx1676_off
    .local int rx1676_eos
    .local int rx1676_rep
    .local pmc rx1676_cur
    .local pmc rx1676_debug
    (rx1676_cur, rx1676_pos, rx1676_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1676_cur
    .local pmc match
    .lex "$/", match
    length rx1676_eos, rx1676_tgt
    gt rx1676_pos, rx1676_eos, rx1676_done
    set rx1676_off, 0
    lt rx1676_pos, 2, rx1676_start
    sub rx1676_off, rx1676_pos, 1
    substr rx1676_tgt, rx1676_tgt, rx1676_off
  rx1676_start:
    eq $I10, 1, rx1676_restart
    if_null rx1676_debug, debug_1357
    rx1676_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1680_done
    goto rxscan1680_scan
  rxscan1680_loop:
    (rx1676_pos) = rx1676_cur."from"()
    inc rx1676_pos
    rx1676_cur."!cursor_from"(rx1676_pos)
    ge rx1676_pos, rx1676_eos, rxscan1680_done
  rxscan1680_scan:
    set_addr $I10, rxscan1680_loop
    rx1676_cur."!mark_push"(0, rx1676_pos, $I10)
  rxscan1680_done:
.annotate 'line', 696
  # rx subcapture "sym"
    set_addr $I10, rxcap_1681_fail
    rx1676_cur."!mark_push"(0, rx1676_pos, $I10)
  # rx literal  "||"
    add $I11, rx1676_pos, 2
    gt $I11, rx1676_eos, rx1676_fail
    sub $I11, rx1676_pos, rx1676_off
    substr $S10, rx1676_tgt, $I11, 2
    ne $S10, "||", rx1676_fail
    add rx1676_pos, 2
    set_addr $I10, rxcap_1681_fail
    ($I12, $I11) = rx1676_cur."!mark_peek"($I10)
    rx1676_cur."!cursor_pos"($I11)
    ($P10) = rx1676_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1676_pos, "")
    rx1676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1681_done
  rxcap_1681_fail:
    goto rx1676_fail
  rxcap_1681_done:
  # rx subrule "O" subtype=capture negate=
    rx1676_cur."!cursor_pos"(rx1676_pos)
    $P10 = rx1676_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1676_fail
    rx1676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1676_pos = $P10."pos"()
  # rx pass
    rx1676_cur."!cursor_pass"(rx1676_pos, "infix:sym<||>")
    if_null rx1676_debug, debug_1358
    rx1676_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1676_pos)
  debug_1358:
    .return (rx1676_cur)
  rx1676_restart:
.annotate 'line', 10
    if_null rx1676_debug, debug_1359
    rx1676_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1359:
  rx1676_fail:
    (rx1676_rep, rx1676_pos, $I10, $P10) = rx1676_cur."!mark_fail"(0)
    lt rx1676_pos, -1, rx1676_done
    eq rx1676_pos, -1, rx1676_fail
    jump $I10
  rx1676_done:
    rx1676_cur."!cursor_fail"()
    if_null rx1676_debug, debug_1360
    rx1676_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1360:
    .return (rx1676_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("358_1303603603.711") :method
.annotate 'line', 10
    $P1678 = self."!PREFIX__!subrule"("O", "||")
    new $P1679, "ResizablePMCArray"
    push $P1679, $P1678
    .return ($P1679)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("359_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1683_tgt
    .local int rx1683_pos
    .local int rx1683_off
    .local int rx1683_eos
    .local int rx1683_rep
    .local pmc rx1683_cur
    .local pmc rx1683_debug
    (rx1683_cur, rx1683_pos, rx1683_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1683_cur
    .local pmc match
    .lex "$/", match
    length rx1683_eos, rx1683_tgt
    gt rx1683_pos, rx1683_eos, rx1683_done
    set rx1683_off, 0
    lt rx1683_pos, 2, rx1683_start
    sub rx1683_off, rx1683_pos, 1
    substr rx1683_tgt, rx1683_tgt, rx1683_off
  rx1683_start:
    eq $I10, 1, rx1683_restart
    if_null rx1683_debug, debug_1361
    rx1683_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1361:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1687_done
    goto rxscan1687_scan
  rxscan1687_loop:
    (rx1683_pos) = rx1683_cur."from"()
    inc rx1683_pos
    rx1683_cur."!cursor_from"(rx1683_pos)
    ge rx1683_pos, rx1683_eos, rxscan1687_done
  rxscan1687_scan:
    set_addr $I10, rxscan1687_loop
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
  rxscan1687_done:
.annotate 'line', 697
  # rx subcapture "sym"
    set_addr $I10, rxcap_1688_fail
    rx1683_cur."!mark_push"(0, rx1683_pos, $I10)
  # rx literal  "//"
    add $I11, rx1683_pos, 2
    gt $I11, rx1683_eos, rx1683_fail
    sub $I11, rx1683_pos, rx1683_off
    substr $S10, rx1683_tgt, $I11, 2
    ne $S10, "//", rx1683_fail
    add rx1683_pos, 2
    set_addr $I10, rxcap_1688_fail
    ($I12, $I11) = rx1683_cur."!mark_peek"($I10)
    rx1683_cur."!cursor_pos"($I11)
    ($P10) = rx1683_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1683_pos, "")
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1688_done
  rxcap_1688_fail:
    goto rx1683_fail
  rxcap_1688_done:
  # rx subrule "O" subtype=capture negate=
    rx1683_cur."!cursor_pos"(rx1683_pos)
    $P10 = rx1683_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1683_fail
    rx1683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1683_pos = $P10."pos"()
  # rx pass
    rx1683_cur."!cursor_pass"(rx1683_pos, "infix:sym<//>")
    if_null rx1683_debug, debug_1362
    rx1683_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1683_pos)
  debug_1362:
    .return (rx1683_cur)
  rx1683_restart:
.annotate 'line', 10
    if_null rx1683_debug, debug_1363
    rx1683_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1363:
  rx1683_fail:
    (rx1683_rep, rx1683_pos, $I10, $P10) = rx1683_cur."!mark_fail"(0)
    lt rx1683_pos, -1, rx1683_done
    eq rx1683_pos, -1, rx1683_fail
    jump $I10
  rx1683_done:
    rx1683_cur."!cursor_fail"()
    if_null rx1683_debug, debug_1364
    rx1683_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1364:
    .return (rx1683_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("360_1303603603.711") :method
.annotate 'line', 10
    $P1685 = self."!PREFIX__!subrule"("O", "//")
    new $P1686, "ResizablePMCArray"
    push $P1686, $P1685
    .return ($P1686)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("361_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1690_tgt
    .local int rx1690_pos
    .local int rx1690_off
    .local int rx1690_eos
    .local int rx1690_rep
    .local pmc rx1690_cur
    .local pmc rx1690_debug
    (rx1690_cur, rx1690_pos, rx1690_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1690_cur
    .local pmc match
    .lex "$/", match
    length rx1690_eos, rx1690_tgt
    gt rx1690_pos, rx1690_eos, rx1690_done
    set rx1690_off, 0
    lt rx1690_pos, 2, rx1690_start
    sub rx1690_off, rx1690_pos, 1
    substr rx1690_tgt, rx1690_tgt, rx1690_off
  rx1690_start:
    eq $I10, 1, rx1690_restart
    if_null rx1690_debug, debug_1365
    rx1690_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1694_done
    goto rxscan1694_scan
  rxscan1694_loop:
    (rx1690_pos) = rx1690_cur."from"()
    inc rx1690_pos
    rx1690_cur."!cursor_from"(rx1690_pos)
    ge rx1690_pos, rx1690_eos, rxscan1694_done
  rxscan1694_scan:
    set_addr $I10, rxscan1694_loop
    rx1690_cur."!mark_push"(0, rx1690_pos, $I10)
  rxscan1694_done:
.annotate 'line', 700
  # rx literal  "??"
    add $I11, rx1690_pos, 2
    gt $I11, rx1690_eos, rx1690_fail
    sub $I11, rx1690_pos, rx1690_off
    substr $S10, rx1690_tgt, $I11, 2
    ne $S10, "??", rx1690_fail
    add rx1690_pos, 2
.annotate 'line', 701
  # rx subrule "ws" subtype=method negate=
    rx1690_cur."!cursor_pos"(rx1690_pos)
    $P10 = rx1690_cur."ws"()
    unless $P10, rx1690_fail
    rx1690_pos = $P10."pos"()
.annotate 'line', 702
  # rx subrule "EXPR" subtype=capture negate=
    rx1690_cur."!cursor_pos"(rx1690_pos)
    $P10 = rx1690_cur."EXPR"("i=")
    unless $P10, rx1690_fail
    rx1690_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1690_pos = $P10."pos"()
.annotate 'line', 703
  # rx literal  "!!"
    add $I11, rx1690_pos, 2
    gt $I11, rx1690_eos, rx1690_fail
    sub $I11, rx1690_pos, rx1690_off
    substr $S10, rx1690_tgt, $I11, 2
    ne $S10, "!!", rx1690_fail
    add rx1690_pos, 2
.annotate 'line', 704
  # rx subrule "O" subtype=capture negate=
    rx1690_cur."!cursor_pos"(rx1690_pos)
    $P10 = rx1690_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1690_fail
    rx1690_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1690_pos = $P10."pos"()
.annotate 'line', 699
  # rx pass
    rx1690_cur."!cursor_pass"(rx1690_pos, "infix:sym<?? !!>")
    if_null rx1690_debug, debug_1366
    rx1690_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1690_pos)
  debug_1366:
    .return (rx1690_cur)
  rx1690_restart:
.annotate 'line', 10
    if_null rx1690_debug, debug_1367
    rx1690_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1367:
  rx1690_fail:
    (rx1690_rep, rx1690_pos, $I10, $P10) = rx1690_cur."!mark_fail"(0)
    lt rx1690_pos, -1, rx1690_done
    eq rx1690_pos, -1, rx1690_fail
    jump $I10
  rx1690_done:
    rx1690_cur."!cursor_fail"()
    if_null rx1690_debug, debug_1368
    rx1690_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1368:
    .return (rx1690_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("362_1303603603.711") :method
.annotate 'line', 10
    $P1692 = self."!PREFIX__!subrule"("ws", "??")
    new $P1693, "ResizablePMCArray"
    push $P1693, $P1692
    .return ($P1693)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("363_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1696_tgt
    .local int rx1696_pos
    .local int rx1696_off
    .local int rx1696_eos
    .local int rx1696_rep
    .local pmc rx1696_cur
    .local pmc rx1696_debug
    (rx1696_cur, rx1696_pos, rx1696_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1696_cur
    .local pmc match
    .lex "$/", match
    length rx1696_eos, rx1696_tgt
    gt rx1696_pos, rx1696_eos, rx1696_done
    set rx1696_off, 0
    lt rx1696_pos, 2, rx1696_start
    sub rx1696_off, rx1696_pos, 1
    substr rx1696_tgt, rx1696_tgt, rx1696_off
  rx1696_start:
    eq $I10, 1, rx1696_restart
    if_null rx1696_debug, debug_1369
    rx1696_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1700_done
    goto rxscan1700_scan
  rxscan1700_loop:
    (rx1696_pos) = rx1696_cur."from"()
    inc rx1696_pos
    rx1696_cur."!cursor_from"(rx1696_pos)
    ge rx1696_pos, rx1696_eos, rxscan1700_done
  rxscan1700_scan:
    set_addr $I10, rxscan1700_loop
    rx1696_cur."!mark_push"(0, rx1696_pos, $I10)
  rxscan1700_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1701_fail
    rx1696_cur."!mark_push"(0, rx1696_pos, $I10)
  # rx literal  "="
    add $I11, rx1696_pos, 1
    gt $I11, rx1696_eos, rx1696_fail
    sub $I11, rx1696_pos, rx1696_off
    ord $I11, rx1696_tgt, $I11
    ne $I11, 61, rx1696_fail
    add rx1696_pos, 1
    set_addr $I10, rxcap_1701_fail
    ($I12, $I11) = rx1696_cur."!mark_peek"($I10)
    rx1696_cur."!cursor_pos"($I11)
    ($P10) = rx1696_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1696_pos, "")
    rx1696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1701_done
  rxcap_1701_fail:
    goto rx1696_fail
  rxcap_1701_done:
  # rx subrule "panic" subtype=method negate=
    rx1696_cur."!cursor_pos"(rx1696_pos)
    $P10 = rx1696_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1696_fail
    rx1696_pos = $P10."pos"()
.annotate 'line', 707
  # rx pass
    rx1696_cur."!cursor_pass"(rx1696_pos, "infix:sym<=>")
    if_null rx1696_debug, debug_1370
    rx1696_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1696_pos)
  debug_1370:
    .return (rx1696_cur)
  rx1696_restart:
.annotate 'line', 10
    if_null rx1696_debug, debug_1371
    rx1696_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1371:
  rx1696_fail:
    (rx1696_rep, rx1696_pos, $I10, $P10) = rx1696_cur."!mark_fail"(0)
    lt rx1696_pos, -1, rx1696_done
    eq rx1696_pos, -1, rx1696_fail
    jump $I10
  rx1696_done:
    rx1696_cur."!cursor_fail"()
    if_null rx1696_debug, debug_1372
    rx1696_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1372:
    .return (rx1696_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("364_1303603603.711") :method
.annotate 'line', 10
    $P1698 = self."!PREFIX__!subrule"("panic", "=")
    new $P1699, "ResizablePMCArray"
    push $P1699, $P1698
    .return ($P1699)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("365_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1703_tgt
    .local int rx1703_pos
    .local int rx1703_off
    .local int rx1703_eos
    .local int rx1703_rep
    .local pmc rx1703_cur
    .local pmc rx1703_debug
    (rx1703_cur, rx1703_pos, rx1703_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1703_cur
    .local pmc match
    .lex "$/", match
    length rx1703_eos, rx1703_tgt
    gt rx1703_pos, rx1703_eos, rx1703_done
    set rx1703_off, 0
    lt rx1703_pos, 2, rx1703_start
    sub rx1703_off, rx1703_pos, 1
    substr rx1703_tgt, rx1703_tgt, rx1703_off
  rx1703_start:
    eq $I10, 1, rx1703_restart
    if_null rx1703_debug, debug_1373
    rx1703_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1373:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1707_done
    goto rxscan1707_scan
  rxscan1707_loop:
    (rx1703_pos) = rx1703_cur."from"()
    inc rx1703_pos
    rx1703_cur."!cursor_from"(rx1703_pos)
    ge rx1703_pos, rx1703_eos, rxscan1707_done
  rxscan1707_scan:
    set_addr $I10, rxscan1707_loop
    rx1703_cur."!mark_push"(0, rx1703_pos, $I10)
  rxscan1707_done:
.annotate 'line', 710
  # rx subcapture "sym"
    set_addr $I10, rxcap_1708_fail
    rx1703_cur."!mark_push"(0, rx1703_pos, $I10)
  # rx literal  ":="
    add $I11, rx1703_pos, 2
    gt $I11, rx1703_eos, rx1703_fail
    sub $I11, rx1703_pos, rx1703_off
    substr $S10, rx1703_tgt, $I11, 2
    ne $S10, ":=", rx1703_fail
    add rx1703_pos, 2
    set_addr $I10, rxcap_1708_fail
    ($I12, $I11) = rx1703_cur."!mark_peek"($I10)
    rx1703_cur."!cursor_pos"($I11)
    ($P10) = rx1703_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1703_pos, "")
    rx1703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1708_done
  rxcap_1708_fail:
    goto rx1703_fail
  rxcap_1708_done:
  # rx subrule "O" subtype=capture negate=
    rx1703_cur."!cursor_pos"(rx1703_pos)
    $P10 = rx1703_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1703_fail
    rx1703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1703_pos = $P10."pos"()
  # rx pass
    rx1703_cur."!cursor_pass"(rx1703_pos, "infix:sym<:=>")
    if_null rx1703_debug, debug_1374
    rx1703_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1703_pos)
  debug_1374:
    .return (rx1703_cur)
  rx1703_restart:
.annotate 'line', 10
    if_null rx1703_debug, debug_1375
    rx1703_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1375:
  rx1703_fail:
    (rx1703_rep, rx1703_pos, $I10, $P10) = rx1703_cur."!mark_fail"(0)
    lt rx1703_pos, -1, rx1703_done
    eq rx1703_pos, -1, rx1703_fail
    jump $I10
  rx1703_done:
    rx1703_cur."!cursor_fail"()
    if_null rx1703_debug, debug_1376
    rx1703_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1376:
    .return (rx1703_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("366_1303603603.711") :method
.annotate 'line', 10
    $P1705 = self."!PREFIX__!subrule"("O", ":=")
    new $P1706, "ResizablePMCArray"
    push $P1706, $P1705
    .return ($P1706)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("367_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1710_tgt
    .local int rx1710_pos
    .local int rx1710_off
    .local int rx1710_eos
    .local int rx1710_rep
    .local pmc rx1710_cur
    .local pmc rx1710_debug
    (rx1710_cur, rx1710_pos, rx1710_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1710_cur
    .local pmc match
    .lex "$/", match
    length rx1710_eos, rx1710_tgt
    gt rx1710_pos, rx1710_eos, rx1710_done
    set rx1710_off, 0
    lt rx1710_pos, 2, rx1710_start
    sub rx1710_off, rx1710_pos, 1
    substr rx1710_tgt, rx1710_tgt, rx1710_off
  rx1710_start:
    eq $I10, 1, rx1710_restart
    if_null rx1710_debug, debug_1377
    rx1710_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1377:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1714_done
    goto rxscan1714_scan
  rxscan1714_loop:
    (rx1710_pos) = rx1710_cur."from"()
    inc rx1710_pos
    rx1710_cur."!cursor_from"(rx1710_pos)
    ge rx1710_pos, rx1710_eos, rxscan1714_done
  rxscan1714_scan:
    set_addr $I10, rxscan1714_loop
    rx1710_cur."!mark_push"(0, rx1710_pos, $I10)
  rxscan1714_done:
.annotate 'line', 711
  # rx subcapture "sym"
    set_addr $I10, rxcap_1715_fail
    rx1710_cur."!mark_push"(0, rx1710_pos, $I10)
  # rx literal  "::="
    add $I11, rx1710_pos, 3
    gt $I11, rx1710_eos, rx1710_fail
    sub $I11, rx1710_pos, rx1710_off
    substr $S10, rx1710_tgt, $I11, 3
    ne $S10, "::=", rx1710_fail
    add rx1710_pos, 3
    set_addr $I10, rxcap_1715_fail
    ($I12, $I11) = rx1710_cur."!mark_peek"($I10)
    rx1710_cur."!cursor_pos"($I11)
    ($P10) = rx1710_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1710_pos, "")
    rx1710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1715_done
  rxcap_1715_fail:
    goto rx1710_fail
  rxcap_1715_done:
  # rx subrule "O" subtype=capture negate=
    rx1710_cur."!cursor_pos"(rx1710_pos)
    $P10 = rx1710_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1710_fail
    rx1710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1710_pos = $P10."pos"()
  # rx pass
    rx1710_cur."!cursor_pass"(rx1710_pos, "infix:sym<::=>")
    if_null rx1710_debug, debug_1378
    rx1710_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1710_pos)
  debug_1378:
    .return (rx1710_cur)
  rx1710_restart:
.annotate 'line', 10
    if_null rx1710_debug, debug_1379
    rx1710_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1379:
  rx1710_fail:
    (rx1710_rep, rx1710_pos, $I10, $P10) = rx1710_cur."!mark_fail"(0)
    lt rx1710_pos, -1, rx1710_done
    eq rx1710_pos, -1, rx1710_fail
    jump $I10
  rx1710_done:
    rx1710_cur."!cursor_fail"()
    if_null rx1710_debug, debug_1380
    rx1710_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1380:
    .return (rx1710_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("368_1303603603.711") :method
.annotate 'line', 10
    $P1712 = self."!PREFIX__!subrule"("O", "::=")
    new $P1713, "ResizablePMCArray"
    push $P1713, $P1712
    .return ($P1713)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("369_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1717_tgt
    .local int rx1717_pos
    .local int rx1717_off
    .local int rx1717_eos
    .local int rx1717_rep
    .local pmc rx1717_cur
    .local pmc rx1717_debug
    (rx1717_cur, rx1717_pos, rx1717_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1717_cur
    .local pmc match
    .lex "$/", match
    length rx1717_eos, rx1717_tgt
    gt rx1717_pos, rx1717_eos, rx1717_done
    set rx1717_off, 0
    lt rx1717_pos, 2, rx1717_start
    sub rx1717_off, rx1717_pos, 1
    substr rx1717_tgt, rx1717_tgt, rx1717_off
  rx1717_start:
    eq $I10, 1, rx1717_restart
    if_null rx1717_debug, debug_1381
    rx1717_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1381:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1721_done
    goto rxscan1721_scan
  rxscan1721_loop:
    (rx1717_pos) = rx1717_cur."from"()
    inc rx1717_pos
    rx1717_cur."!cursor_from"(rx1717_pos)
    ge rx1717_pos, rx1717_eos, rxscan1721_done
  rxscan1721_scan:
    set_addr $I10, rxscan1721_loop
    rx1717_cur."!mark_push"(0, rx1717_pos, $I10)
  rxscan1721_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1722_fail
    rx1717_cur."!mark_push"(0, rx1717_pos, $I10)
  # rx literal  ","
    add $I11, rx1717_pos, 1
    gt $I11, rx1717_eos, rx1717_fail
    sub $I11, rx1717_pos, rx1717_off
    ord $I11, rx1717_tgt, $I11
    ne $I11, 44, rx1717_fail
    add rx1717_pos, 1
    set_addr $I10, rxcap_1722_fail
    ($I12, $I11) = rx1717_cur."!mark_peek"($I10)
    rx1717_cur."!cursor_pos"($I11)
    ($P10) = rx1717_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1717_pos, "")
    rx1717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1722_done
  rxcap_1722_fail:
    goto rx1717_fail
  rxcap_1722_done:
  # rx subrule "O" subtype=capture negate=
    rx1717_cur."!cursor_pos"(rx1717_pos)
    $P10 = rx1717_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1717_fail
    rx1717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1717_pos = $P10."pos"()
  # rx pass
    rx1717_cur."!cursor_pass"(rx1717_pos, "infix:sym<,>")
    if_null rx1717_debug, debug_1382
    rx1717_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1717_pos)
  debug_1382:
    .return (rx1717_cur)
  rx1717_restart:
.annotate 'line', 10
    if_null rx1717_debug, debug_1383
    rx1717_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1383:
  rx1717_fail:
    (rx1717_rep, rx1717_pos, $I10, $P10) = rx1717_cur."!mark_fail"(0)
    lt rx1717_pos, -1, rx1717_done
    eq rx1717_pos, -1, rx1717_fail
    jump $I10
  rx1717_done:
    rx1717_cur."!cursor_fail"()
    if_null rx1717_debug, debug_1384
    rx1717_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1384:
    .return (rx1717_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("370_1303603603.711") :method
.annotate 'line', 10
    $P1719 = self."!PREFIX__!subrule"("O", ",")
    new $P1720, "ResizablePMCArray"
    push $P1720, $P1719
    .return ($P1720)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("371_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .const 'Sub' $P1732 = "373_1303603603.711" 
    capture_lex $P1732
    .local string rx1724_tgt
    .local int rx1724_pos
    .local int rx1724_off
    .local int rx1724_eos
    .local int rx1724_rep
    .local pmc rx1724_cur
    .local pmc rx1724_debug
    (rx1724_cur, rx1724_pos, rx1724_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1724_cur
    .local pmc match
    .lex "$/", match
    length rx1724_eos, rx1724_tgt
    gt rx1724_pos, rx1724_eos, rx1724_done
    set rx1724_off, 0
    lt rx1724_pos, 2, rx1724_start
    sub rx1724_off, rx1724_pos, 1
    substr rx1724_tgt, rx1724_tgt, rx1724_off
  rx1724_start:
    eq $I10, 1, rx1724_restart
    if_null rx1724_debug, debug_1385
    rx1724_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1385:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1727_done
    goto rxscan1727_scan
  rxscan1727_loop:
    (rx1724_pos) = rx1724_cur."from"()
    inc rx1724_pos
    rx1724_cur."!cursor_from"(rx1724_pos)
    ge rx1724_pos, rx1724_eos, rxscan1727_done
  rxscan1727_scan:
    set_addr $I10, rxscan1727_loop
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
  rxscan1727_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1728_fail
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
  # rx literal  "return"
    add $I11, rx1724_pos, 6
    gt $I11, rx1724_eos, rx1724_fail
    sub $I11, rx1724_pos, rx1724_off
    substr $S10, rx1724_tgt, $I11, 6
    ne $S10, "return", rx1724_fail
    add rx1724_pos, 6
    set_addr $I10, rxcap_1728_fail
    ($I12, $I11) = rx1724_cur."!mark_peek"($I10)
    rx1724_cur."!cursor_pos"($I11)
    ($P10) = rx1724_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1724_pos, "")
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1728_done
  rxcap_1728_fail:
    goto rx1724_fail
  rxcap_1728_done:
  # rx charclass s
    ge rx1724_pos, rx1724_eos, rx1724_fail
    sub $I10, rx1724_pos, rx1724_off
    is_cclass $I11, 32, rx1724_tgt, $I10
    unless $I11, rx1724_fail
    inc rx1724_pos
  # rx subrule "O" subtype=capture negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1724_fail
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1724_pos = $P10."pos"()
    rx1724_cur."!cursor_pos"(rx1724_pos)
    find_lex $P1729, unicode:"$\x{a2}"
    $P1730 = $P1729."MATCH"()
    store_lex "$/", $P1730
    .const 'Sub' $P1732 = "373_1303603603.711" 
    capture_lex $P1732
    $P1734 = $P1732()
  # rx pass
    rx1724_cur."!cursor_pass"(rx1724_pos, "prefix:sym<return>")
    if_null rx1724_debug, debug_1386
    rx1724_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1724_pos)
  debug_1386:
    .return (rx1724_cur)
  rx1724_restart:
.annotate 'line', 10
    if_null rx1724_debug, debug_1387
    rx1724_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1387:
  rx1724_fail:
    (rx1724_rep, rx1724_pos, $I10, $P10) = rx1724_cur."!mark_fail"(0)
    lt rx1724_pos, -1, rx1724_done
    eq rx1724_pos, -1, rx1724_fail
    jump $I10
  rx1724_done:
    rx1724_cur."!cursor_fail"()
    if_null rx1724_debug, debug_1388
    rx1724_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1388:
    .return (rx1724_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("372_1303603603.711") :method
.annotate 'line', 10
    new $P1726, "ResizablePMCArray"
    push $P1726, "return"
    .return ($P1726)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1731"  :anon :subid("373_1303603603.711") :outer("371_1303603603.711")
.annotate 'line', 715
    new $P1733, "Integer"
    assign $P1733, 1
    store_dynamic_lex "$*RETURN_USED", $P1733
    .return ($P1733)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("374_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1736_tgt
    .local int rx1736_pos
    .local int rx1736_off
    .local int rx1736_eos
    .local int rx1736_rep
    .local pmc rx1736_cur
    .local pmc rx1736_debug
    (rx1736_cur, rx1736_pos, rx1736_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1736_cur
    .local pmc match
    .lex "$/", match
    length rx1736_eos, rx1736_tgt
    gt rx1736_pos, rx1736_eos, rx1736_done
    set rx1736_off, 0
    lt rx1736_pos, 2, rx1736_start
    sub rx1736_off, rx1736_pos, 1
    substr rx1736_tgt, rx1736_tgt, rx1736_off
  rx1736_start:
    eq $I10, 1, rx1736_restart
    if_null rx1736_debug, debug_1389
    rx1736_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1389:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1739_done
    goto rxscan1739_scan
  rxscan1739_loop:
    (rx1736_pos) = rx1736_cur."from"()
    inc rx1736_pos
    rx1736_cur."!cursor_from"(rx1736_pos)
    ge rx1736_pos, rx1736_eos, rxscan1739_done
  rxscan1739_scan:
    set_addr $I10, rxscan1739_loop
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  rxscan1739_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1740_fail
    rx1736_cur."!mark_push"(0, rx1736_pos, $I10)
  # rx literal  "make"
    add $I11, rx1736_pos, 4
    gt $I11, rx1736_eos, rx1736_fail
    sub $I11, rx1736_pos, rx1736_off
    substr $S10, rx1736_tgt, $I11, 4
    ne $S10, "make", rx1736_fail
    add rx1736_pos, 4
    set_addr $I10, rxcap_1740_fail
    ($I12, $I11) = rx1736_cur."!mark_peek"($I10)
    rx1736_cur."!cursor_pos"($I11)
    ($P10) = rx1736_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1736_pos, "")
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1740_done
  rxcap_1740_fail:
    goto rx1736_fail
  rxcap_1740_done:
  # rx charclass s
    ge rx1736_pos, rx1736_eos, rx1736_fail
    sub $I10, rx1736_pos, rx1736_off
    is_cclass $I11, 32, rx1736_tgt, $I10
    unless $I11, rx1736_fail
    inc rx1736_pos
  # rx subrule "O" subtype=capture negate=
    rx1736_cur."!cursor_pos"(rx1736_pos)
    $P10 = rx1736_cur."O"("%list_prefix")
    unless $P10, rx1736_fail
    rx1736_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1736_pos = $P10."pos"()
  # rx pass
    rx1736_cur."!cursor_pass"(rx1736_pos, "prefix:sym<make>")
    if_null rx1736_debug, debug_1390
    rx1736_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1736_pos)
  debug_1390:
    .return (rx1736_cur)
  rx1736_restart:
.annotate 'line', 10
    if_null rx1736_debug, debug_1391
    rx1736_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1391:
  rx1736_fail:
    (rx1736_rep, rx1736_pos, $I10, $P10) = rx1736_cur."!mark_fail"(0)
    lt rx1736_pos, -1, rx1736_done
    eq rx1736_pos, -1, rx1736_fail
    jump $I10
  rx1736_done:
    rx1736_cur."!cursor_fail"()
    if_null rx1736_debug, debug_1392
    rx1736_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1392:
    .return (rx1736_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("375_1303603603.711") :method
.annotate 'line', 10
    new $P1738, "ResizablePMCArray"
    push $P1738, "make"
    .return ($P1738)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("376_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1742_tgt
    .local int rx1742_pos
    .local int rx1742_off
    .local int rx1742_eos
    .local int rx1742_rep
    .local pmc rx1742_cur
    .local pmc rx1742_debug
    (rx1742_cur, rx1742_pos, rx1742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1742_cur
    .local pmc match
    .lex "$/", match
    length rx1742_eos, rx1742_tgt
    gt rx1742_pos, rx1742_eos, rx1742_done
    set rx1742_off, 0
    lt rx1742_pos, 2, rx1742_start
    sub rx1742_off, rx1742_pos, 1
    substr rx1742_tgt, rx1742_tgt, rx1742_off
  rx1742_start:
    eq $I10, 1, rx1742_restart
    if_null rx1742_debug, debug_1393
    rx1742_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1393:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1745_done
    goto rxscan1745_scan
  rxscan1745_loop:
    (rx1742_pos) = rx1742_cur."from"()
    inc rx1742_pos
    rx1742_cur."!cursor_from"(rx1742_pos)
    ge rx1742_pos, rx1742_eos, rxscan1745_done
  rxscan1745_scan:
    set_addr $I10, rxscan1745_loop
    rx1742_cur."!mark_push"(0, rx1742_pos, $I10)
  rxscan1745_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_1746_fail
    rx1742_cur."!mark_push"(0, rx1742_pos, $I10)
  # rx literal  "last"
    add $I11, rx1742_pos, 4
    gt $I11, rx1742_eos, rx1742_fail
    sub $I11, rx1742_pos, rx1742_off
    substr $S10, rx1742_tgt, $I11, 4
    ne $S10, "last", rx1742_fail
    add rx1742_pos, 4
    set_addr $I10, rxcap_1746_fail
    ($I12, $I11) = rx1742_cur."!mark_peek"($I10)
    rx1742_cur."!cursor_pos"($I11)
    ($P10) = rx1742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1742_pos, "")
    rx1742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1746_done
  rxcap_1746_fail:
    goto rx1742_fail
  rxcap_1746_done:
  # rx pass
    rx1742_cur."!cursor_pass"(rx1742_pos, "term:sym<last>")
    if_null rx1742_debug, debug_1394
    rx1742_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1742_pos)
  debug_1394:
    .return (rx1742_cur)
  rx1742_restart:
.annotate 'line', 10
    if_null rx1742_debug, debug_1395
    rx1742_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1395:
  rx1742_fail:
    (rx1742_rep, rx1742_pos, $I10, $P10) = rx1742_cur."!mark_fail"(0)
    lt rx1742_pos, -1, rx1742_done
    eq rx1742_pos, -1, rx1742_fail
    jump $I10
  rx1742_done:
    rx1742_cur."!cursor_fail"()
    if_null rx1742_debug, debug_1396
    rx1742_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1396:
    .return (rx1742_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("377_1303603603.711") :method
.annotate 'line', 10
    new $P1744, "ResizablePMCArray"
    push $P1744, "last"
    .return ($P1744)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("378_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1748_tgt
    .local int rx1748_pos
    .local int rx1748_off
    .local int rx1748_eos
    .local int rx1748_rep
    .local pmc rx1748_cur
    .local pmc rx1748_debug
    (rx1748_cur, rx1748_pos, rx1748_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1748_cur
    .local pmc match
    .lex "$/", match
    length rx1748_eos, rx1748_tgt
    gt rx1748_pos, rx1748_eos, rx1748_done
    set rx1748_off, 0
    lt rx1748_pos, 2, rx1748_start
    sub rx1748_off, rx1748_pos, 1
    substr rx1748_tgt, rx1748_tgt, rx1748_off
  rx1748_start:
    eq $I10, 1, rx1748_restart
    if_null rx1748_debug, debug_1397
    rx1748_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1397:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1751_done
    goto rxscan1751_scan
  rxscan1751_loop:
    (rx1748_pos) = rx1748_cur."from"()
    inc rx1748_pos
    rx1748_cur."!cursor_from"(rx1748_pos)
    ge rx1748_pos, rx1748_eos, rxscan1751_done
  rxscan1751_scan:
    set_addr $I10, rxscan1751_loop
    rx1748_cur."!mark_push"(0, rx1748_pos, $I10)
  rxscan1751_done:
.annotate 'line', 718
  # rx subcapture "sym"
    set_addr $I10, rxcap_1752_fail
    rx1748_cur."!mark_push"(0, rx1748_pos, $I10)
  # rx literal  "next"
    add $I11, rx1748_pos, 4
    gt $I11, rx1748_eos, rx1748_fail
    sub $I11, rx1748_pos, rx1748_off
    substr $S10, rx1748_tgt, $I11, 4
    ne $S10, "next", rx1748_fail
    add rx1748_pos, 4
    set_addr $I10, rxcap_1752_fail
    ($I12, $I11) = rx1748_cur."!mark_peek"($I10)
    rx1748_cur."!cursor_pos"($I11)
    ($P10) = rx1748_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1748_pos, "")
    rx1748_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1752_done
  rxcap_1752_fail:
    goto rx1748_fail
  rxcap_1752_done:
  # rx pass
    rx1748_cur."!cursor_pass"(rx1748_pos, "term:sym<next>")
    if_null rx1748_debug, debug_1398
    rx1748_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1748_pos)
  debug_1398:
    .return (rx1748_cur)
  rx1748_restart:
.annotate 'line', 10
    if_null rx1748_debug, debug_1399
    rx1748_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1399:
  rx1748_fail:
    (rx1748_rep, rx1748_pos, $I10, $P10) = rx1748_cur."!mark_fail"(0)
    lt rx1748_pos, -1, rx1748_done
    eq rx1748_pos, -1, rx1748_fail
    jump $I10
  rx1748_done:
    rx1748_cur."!cursor_fail"()
    if_null rx1748_debug, debug_1400
    rx1748_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1400:
    .return (rx1748_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("379_1303603603.711") :method
.annotate 'line', 10
    new $P1750, "ResizablePMCArray"
    push $P1750, "next"
    .return ($P1750)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("380_1303603603.711") :method :outer("12_1303603603.711")
.annotate 'line', 10
    .local string rx1754_tgt
    .local int rx1754_pos
    .local int rx1754_off
    .local int rx1754_eos
    .local int rx1754_rep
    .local pmc rx1754_cur
    .local pmc rx1754_debug
    (rx1754_cur, rx1754_pos, rx1754_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1754_cur
    .local pmc match
    .lex "$/", match
    length rx1754_eos, rx1754_tgt
    gt rx1754_pos, rx1754_eos, rx1754_done
    set rx1754_off, 0
    lt rx1754_pos, 2, rx1754_start
    sub rx1754_off, rx1754_pos, 1
    substr rx1754_tgt, rx1754_tgt, rx1754_off
  rx1754_start:
    eq $I10, 1, rx1754_restart
    if_null rx1754_debug, debug_1401
    rx1754_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1401:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1757_done
    goto rxscan1757_scan
  rxscan1757_loop:
    (rx1754_pos) = rx1754_cur."from"()
    inc rx1754_pos
    rx1754_cur."!cursor_from"(rx1754_pos)
    ge rx1754_pos, rx1754_eos, rxscan1757_done
  rxscan1757_scan:
    set_addr $I10, rxscan1757_loop
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  rxscan1757_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_1758_fail
    rx1754_cur."!mark_push"(0, rx1754_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1754_pos, 4
    gt $I11, rx1754_eos, rx1754_fail
    sub $I11, rx1754_pos, rx1754_off
    substr $S10, rx1754_tgt, $I11, 4
    ne $S10, "redo", rx1754_fail
    add rx1754_pos, 4
    set_addr $I10, rxcap_1758_fail
    ($I12, $I11) = rx1754_cur."!mark_peek"($I10)
    rx1754_cur."!cursor_pos"($I11)
    ($P10) = rx1754_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1754_pos, "")
    rx1754_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1758_done
  rxcap_1758_fail:
    goto rx1754_fail
  rxcap_1758_done:
  # rx pass
    rx1754_cur."!cursor_pass"(rx1754_pos, "term:sym<redo>")
    if_null rx1754_debug, debug_1402
    rx1754_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1754_pos)
  debug_1402:
    .return (rx1754_cur)
  rx1754_restart:
.annotate 'line', 10
    if_null rx1754_debug, debug_1403
    rx1754_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1403:
  rx1754_fail:
    (rx1754_rep, rx1754_pos, $I10, $P10) = rx1754_cur."!mark_fail"(0)
    lt rx1754_pos, -1, rx1754_done
    eq rx1754_pos, -1, rx1754_fail
    jump $I10
  rx1754_done:
    rx1754_cur."!cursor_fail"()
    if_null rx1754_debug, debug_1404
    rx1754_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1404:
    .return (rx1754_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("381_1303603603.711") :method
.annotate 'line', 10
    new $P1756, "ResizablePMCArray"
    push $P1756, "redo"
    .return ($P1756)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("382_1303603603.711") :outer("12_1303603603.711")
    .param pmc param_1760
    .param pmc param_1761
.annotate 'line', 721
    .lex "self", param_1760
    .lex "$/", param_1761
.annotate 'line', 723
    new $P1762, "Undef"
    .lex "$t", $P1762
    find_lex $P1763, "$/"
    unless_null $P1763, vivify_1405
    $P1763 = root_new ['parrot';'ResizablePMCArray']
  vivify_1405:
    set $P1764, $P1763[0]
    unless_null $P1764, vivify_1406
    new $P1764, "Undef"
  vivify_1406:
    store_lex "$t", $P1764
    find_lex $P1765, "$/"
    unless_null $P1765, vivify_1407
    $P1765 = root_new ['parrot';'ResizablePMCArray']
  vivify_1407:
    set $P1766, $P1765[1]
    unless_null $P1766, vivify_1408
    new $P1766, "Undef"
  vivify_1408:
    find_lex $P1767, "$/"
    unless_null $P1767, vivify_1409
    $P1767 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1767
  vivify_1409:
    set $P1767[0], $P1766
    find_lex $P1768, "$t"
    unless_null $P1768, vivify_1410
    new $P1768, "Undef"
  vivify_1410:
    find_lex $P1769, "$/"
    unless_null $P1769, vivify_1411
    $P1769 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1769
  vivify_1411:
    set $P1769[1], $P1768
.annotate 'line', 721
    .return ($P1768)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2494"  :subid("384_1303603603.711") :outer("10_1303603603.711")
.annotate 'line', 727
    .const 'Sub' $P2560 = "405_1303603603.711" 
    capture_lex $P2560
    .const 'Sub' $P2553 = "403_1303603603.711" 
    capture_lex $P2553
    .const 'Sub' $P2548 = "401_1303603603.711" 
    capture_lex $P2548
    .const 'Sub' $P2536 = "398_1303603603.711" 
    capture_lex $P2536
    .const 'Sub' $P2526 = "395_1303603603.711" 
    capture_lex $P2526
    .const 'Sub' $P2521 = "393_1303603603.711" 
    capture_lex $P2521
    .const 'Sub' $P2512 = "390_1303603603.711" 
    capture_lex $P2512
    .const 'Sub' $P2507 = "388_1303603603.711" 
    capture_lex $P2507
    .const 'Sub' $P2498 = "385_1303603603.711" 
    capture_lex $P2498
    .lex "$?PACKAGE", $P2496
    .lex "$?CLASS", $P2497
    .const 'Sub' $P2553 = "403_1303603603.711" 
    capture_lex $P2553
    .return ($P2553)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1412") :outer("384_1303603603.711")
.annotate 'line', 727
    .const 'Sub' $P2495 = "384_1303603603.711" 
    .local pmc block
    set block, $P2495
    .const 'Sub' $P2560 = "405_1303603603.711" 
    capture_lex $P2560
    $P2560()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2559"  :anon :subid("405_1303603603.711") :outer("384_1303603603.711")
.annotate 'line', 727
    nqp_get_sc_object $P2561, "1303603591.505", 2
    .local pmc type_obj
    set type_obj, $P2561
    get_how $P2562, type_obj
    .const 'Sub' $P2563 = "385_1303603603.711" 
    $P2562."add_method"(type_obj, "metachar:sym<:my>", $P2563)
    get_how $P2564, type_obj
    get_global $P2565, "!PREFIX__metachar:sym<:my>"
    $P2564."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2565)
    get_how $P2566, type_obj
    .const 'Sub' $P2567 = "388_1303603603.711" 
    $P2566."add_method"(type_obj, "metachar:sym<{ }>", $P2567)
    get_how $P2568, type_obj
    get_global $P2569, "!PREFIX__metachar:sym<{ }>"
    $P2568."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2569)
    get_how $P2570, type_obj
    .const 'Sub' $P2571 = "390_1303603603.711" 
    $P2570."add_method"(type_obj, "metachar:sym<nqpvar>", $P2571)
    get_how $P2572, type_obj
    get_global $P2573, "!PREFIX__metachar:sym<nqpvar>"
    $P2572."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2573)
    get_how $P2574, type_obj
    .const 'Sub' $P2575 = "393_1303603603.711" 
    $P2574."add_method"(type_obj, "assertion:sym<{ }>", $P2575)
    get_how $P2576, type_obj
    get_global $P2577, "!PREFIX__assertion:sym<{ }>"
    $P2576."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2577)
    get_how $P2578, type_obj
    .const 'Sub' $P2579 = "395_1303603603.711" 
    $P2578."add_method"(type_obj, "assertion:sym<?{ }>", $P2579)
    get_how $P2580, type_obj
    get_global $P2581, "!PREFIX__assertion:sym<?{ }>"
    $P2580."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2581)
    get_how $P2582, type_obj
    .const 'Sub' $P2583 = "398_1303603603.711" 
    $P2582."add_method"(type_obj, "assertion:sym<name>", $P2583)
    get_how $P2584, type_obj
    get_global $P2585, "!PREFIX__assertion:sym<name>"
    $P2584."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2585)
    get_how $P2586, type_obj
    .const 'Sub' $P2587 = "401_1303603603.711" 
    $P2586."add_method"(type_obj, "assertion:sym<var>", $P2587)
    get_how $P2588, type_obj
    get_global $P2589, "!PREFIX__assertion:sym<var>"
    $P2588."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2589)
    get_how $P2590, type_obj
    .const 'Sub' $P2591 = "403_1303603603.711" 
    $P2590."add_method"(type_obj, "codeblock", $P2591)
    get_how $P2592, type_obj
    get_global $P2593, "!PREFIX__codeblock"
    $P2592."add_method"(type_obj, "!PREFIX__codeblock", $P2593)
    get_how $P2594, type_obj
    get_hll_global $P2595, ["Regex";"P6Regex"], "Grammar"
    $P2594."add_parent"(type_obj, $P2595)
    get_how $P2596, type_obj
    $P2597 = $P2596."compose"(type_obj)
    .return ($P2597)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("385_1303603603.711") :method :outer("384_1303603603.711")
.annotate 'line', 727
    .const 'Sub' $P2504 = "387_1303603603.711" 
    capture_lex $P2504
    .local string rx2499_tgt
    .local int rx2499_pos
    .local int rx2499_off
    .local int rx2499_eos
    .local int rx2499_rep
    .local pmc rx2499_cur
    .local pmc rx2499_debug
    (rx2499_cur, rx2499_pos, rx2499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2499_cur
    .local pmc match
    .lex "$/", match
    length rx2499_eos, rx2499_tgt
    gt rx2499_pos, rx2499_eos, rx2499_done
    set rx2499_off, 0
    lt rx2499_pos, 2, rx2499_start
    sub rx2499_off, rx2499_pos, 1
    substr rx2499_tgt, rx2499_tgt, rx2499_off
  rx2499_start:
    eq $I10, 1, rx2499_restart
    if_null rx2499_debug, debug_1413
    rx2499_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1413:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2502_done
    goto rxscan2502_scan
  rxscan2502_loop:
    (rx2499_pos) = rx2499_cur."from"()
    inc rx2499_pos
    rx2499_cur."!cursor_from"(rx2499_pos)
    ge rx2499_pos, rx2499_eos, rxscan2502_done
  rxscan2502_scan:
    set_addr $I10, rxscan2502_loop
    rx2499_cur."!mark_push"(0, rx2499_pos, $I10)
  rxscan2502_done:
.annotate 'line', 729
  # rx literal  ":"
    add $I11, rx2499_pos, 1
    gt $I11, rx2499_eos, rx2499_fail
    sub $I11, rx2499_pos, rx2499_off
    ord $I11, rx2499_tgt, $I11
    ne $I11, 58, rx2499_fail
    add rx2499_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2499_cur."!cursor_pos"(rx2499_pos)
    .const 'Sub' $P2504 = "387_1303603603.711" 
    capture_lex $P2504
    $P10 = rx2499_cur."before"($P2504)
    unless $P10, rx2499_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2499_cur."!cursor_pos"(rx2499_pos)
    $P10 = rx2499_cur."LANG"("MAIN", "statement")
    unless $P10, rx2499_fail
    rx2499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2499_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2499_cur."!cursor_pos"(rx2499_pos)
    $P10 = rx2499_cur."ws"()
    unless $P10, rx2499_fail
    rx2499_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2499_pos, 1
    gt $I11, rx2499_eos, rx2499_fail
    sub $I11, rx2499_pos, rx2499_off
    ord $I11, rx2499_tgt, $I11
    ne $I11, 59, rx2499_fail
    add rx2499_pos, 1
.annotate 'line', 728
  # rx pass
    rx2499_cur."!cursor_pass"(rx2499_pos, "metachar:sym<:my>")
    if_null rx2499_debug, debug_1418
    rx2499_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2499_pos)
  debug_1418:
    .return (rx2499_cur)
  rx2499_restart:
.annotate 'line', 727
    if_null rx2499_debug, debug_1419
    rx2499_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1419:
  rx2499_fail:
    (rx2499_rep, rx2499_pos, $I10, $P10) = rx2499_cur."!mark_fail"(0)
    lt rx2499_pos, -1, rx2499_done
    eq rx2499_pos, -1, rx2499_fail
    jump $I10
  rx2499_done:
    rx2499_cur."!cursor_fail"()
    if_null rx2499_debug, debug_1420
    rx2499_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1420:
    .return (rx2499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("386_1303603603.711") :method
.annotate 'line', 727
    new $P2501, "ResizablePMCArray"
    push $P2501, ":"
    .return ($P2501)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2503"  :anon :subid("387_1303603603.711") :method :outer("385_1303603603.711")
.annotate 'line', 729
    .local string rx2505_tgt
    .local int rx2505_pos
    .local int rx2505_off
    .local int rx2505_eos
    .local int rx2505_rep
    .local pmc rx2505_cur
    .local pmc rx2505_debug
    (rx2505_cur, rx2505_pos, rx2505_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2505_cur
    .local pmc match
    .lex "$/", match
    length rx2505_eos, rx2505_tgt
    gt rx2505_pos, rx2505_eos, rx2505_done
    set rx2505_off, 0
    lt rx2505_pos, 2, rx2505_start
    sub rx2505_off, rx2505_pos, 1
    substr rx2505_tgt, rx2505_tgt, rx2505_off
  rx2505_start:
    eq $I10, 1, rx2505_restart
    if_null rx2505_debug, debug_1414
    rx2505_cur."!cursor_debug"("START", "")
  debug_1414:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2506_done
    goto rxscan2506_scan
  rxscan2506_loop:
    (rx2505_pos) = rx2505_cur."from"()
    inc rx2505_pos
    rx2505_cur."!cursor_from"(rx2505_pos)
    ge rx2505_pos, rx2505_eos, rxscan2506_done
  rxscan2506_scan:
    set_addr $I10, rxscan2506_loop
    rx2505_cur."!mark_push"(0, rx2505_pos, $I10)
  rxscan2506_done:
  # rx literal  "my"
    add $I11, rx2505_pos, 2
    gt $I11, rx2505_eos, rx2505_fail
    sub $I11, rx2505_pos, rx2505_off
    substr $S10, rx2505_tgt, $I11, 2
    ne $S10, "my", rx2505_fail
    add rx2505_pos, 2
  # rx pass
    rx2505_cur."!cursor_pass"(rx2505_pos, "")
    if_null rx2505_debug, debug_1415
    rx2505_cur."!cursor_debug"("PASS", "", " at pos=", rx2505_pos)
  debug_1415:
    .return (rx2505_cur)
  rx2505_restart:
    if_null rx2505_debug, debug_1416
    rx2505_cur."!cursor_debug"("NEXT", "")
  debug_1416:
  rx2505_fail:
    (rx2505_rep, rx2505_pos, $I10, $P10) = rx2505_cur."!mark_fail"(0)
    lt rx2505_pos, -1, rx2505_done
    eq rx2505_pos, -1, rx2505_fail
    jump $I10
  rx2505_done:
    rx2505_cur."!cursor_fail"()
    if_null rx2505_debug, debug_1417
    rx2505_cur."!cursor_debug"("FAIL", "")
  debug_1417:
    .return (rx2505_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("388_1303603603.711") :method :outer("384_1303603603.711")
.annotate 'line', 727
    .local string rx2508_tgt
    .local int rx2508_pos
    .local int rx2508_off
    .local int rx2508_eos
    .local int rx2508_rep
    .local pmc rx2508_cur
    .local pmc rx2508_debug
    (rx2508_cur, rx2508_pos, rx2508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2508_cur
    .local pmc match
    .lex "$/", match
    length rx2508_eos, rx2508_tgt
    gt rx2508_pos, rx2508_eos, rx2508_done
    set rx2508_off, 0
    lt rx2508_pos, 2, rx2508_start
    sub rx2508_off, rx2508_pos, 1
    substr rx2508_tgt, rx2508_tgt, rx2508_off
  rx2508_start:
    eq $I10, 1, rx2508_restart
    if_null rx2508_debug, debug_1421
    rx2508_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1421:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2511_done
    goto rxscan2511_scan
  rxscan2511_loop:
    (rx2508_pos) = rx2508_cur."from"()
    inc rx2508_pos
    rx2508_cur."!cursor_from"(rx2508_pos)
    ge rx2508_pos, rx2508_eos, rxscan2511_done
  rxscan2511_scan:
    set_addr $I10, rxscan2511_loop
    rx2508_cur."!mark_push"(0, rx2508_pos, $I10)
  rxscan2511_done:
.annotate 'line', 733
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2508_pos, rx2508_off
    substr $S10, rx2508_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2508_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2508_cur."!cursor_pos"(rx2508_pos)
    $P10 = rx2508_cur."codeblock"()
    unless $P10, rx2508_fail
    rx2508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2508_pos = $P10."pos"()
.annotate 'line', 732
  # rx pass
    rx2508_cur."!cursor_pass"(rx2508_pos, "metachar:sym<{ }>")
    if_null rx2508_debug, debug_1422
    rx2508_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2508_pos)
  debug_1422:
    .return (rx2508_cur)
  rx2508_restart:
.annotate 'line', 727
    if_null rx2508_debug, debug_1423
    rx2508_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1423:
  rx2508_fail:
    (rx2508_rep, rx2508_pos, $I10, $P10) = rx2508_cur."!mark_fail"(0)
    lt rx2508_pos, -1, rx2508_done
    eq rx2508_pos, -1, rx2508_fail
    jump $I10
  rx2508_done:
    rx2508_cur."!cursor_fail"()
    if_null rx2508_debug, debug_1424
    rx2508_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1424:
    .return (rx2508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("389_1303603603.711") :method
.annotate 'line', 727
    new $P2510, "ResizablePMCArray"
    push $P2510, "{"
    .return ($P2510)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("390_1303603603.711") :method :outer("384_1303603603.711")
.annotate 'line', 727
    .const 'Sub' $P2518 = "392_1303603603.711" 
    capture_lex $P2518
    .local string rx2513_tgt
    .local int rx2513_pos
    .local int rx2513_off
    .local int rx2513_eos
    .local int rx2513_rep
    .local pmc rx2513_cur
    .local pmc rx2513_debug
    (rx2513_cur, rx2513_pos, rx2513_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2513_cur
    .local pmc match
    .lex "$/", match
    length rx2513_eos, rx2513_tgt
    gt rx2513_pos, rx2513_eos, rx2513_done
    set rx2513_off, 0
    lt rx2513_pos, 2, rx2513_start
    sub rx2513_off, rx2513_pos, 1
    substr rx2513_tgt, rx2513_tgt, rx2513_off
  rx2513_start:
    eq $I10, 1, rx2513_restart
    if_null rx2513_debug, debug_1425
    rx2513_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1425:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2516_done
    goto rxscan2516_scan
  rxscan2516_loop:
    (rx2513_pos) = rx2513_cur."from"()
    inc rx2513_pos
    rx2513_cur."!cursor_from"(rx2513_pos)
    ge rx2513_pos, rx2513_eos, rxscan2516_done
  rxscan2516_scan:
    set_addr $I10, rxscan2516_loop
    rx2513_cur."!mark_push"(0, rx2513_pos, $I10)
  rxscan2516_done:
.annotate 'line', 737
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2513_pos, rx2513_off
    substr $S10, rx2513_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2513_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2513_cur."!cursor_pos"(rx2513_pos)
    .const 'Sub' $P2518 = "392_1303603603.711" 
    capture_lex $P2518
    $P10 = rx2513_cur."before"($P2518)
    unless $P10, rx2513_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2513_cur."!cursor_pos"(rx2513_pos)
    $P10 = rx2513_cur."LANG"("MAIN", "variable")
    unless $P10, rx2513_fail
    rx2513_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2513_pos = $P10."pos"()
.annotate 'line', 736
  # rx pass
    rx2513_cur."!cursor_pass"(rx2513_pos, "metachar:sym<nqpvar>")
    if_null rx2513_debug, debug_1430
    rx2513_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2513_pos)
  debug_1430:
    .return (rx2513_cur)
  rx2513_restart:
.annotate 'line', 727
    if_null rx2513_debug, debug_1431
    rx2513_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1431:
  rx2513_fail:
    (rx2513_rep, rx2513_pos, $I10, $P10) = rx2513_cur."!mark_fail"(0)
    lt rx2513_pos, -1, rx2513_done
    eq rx2513_pos, -1, rx2513_fail
    jump $I10
  rx2513_done:
    rx2513_cur."!cursor_fail"()
    if_null rx2513_debug, debug_1432
    rx2513_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1432:
    .return (rx2513_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("391_1303603603.711") :method
.annotate 'line', 727
    new $P2515, "ResizablePMCArray"
    push $P2515, "$"
    push $P2515, "@"
    .return ($P2515)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2517"  :anon :subid("392_1303603603.711") :method :outer("390_1303603603.711")
.annotate 'line', 737
    .local string rx2519_tgt
    .local int rx2519_pos
    .local int rx2519_off
    .local int rx2519_eos
    .local int rx2519_rep
    .local pmc rx2519_cur
    .local pmc rx2519_debug
    (rx2519_cur, rx2519_pos, rx2519_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2519_cur
    .local pmc match
    .lex "$/", match
    length rx2519_eos, rx2519_tgt
    gt rx2519_pos, rx2519_eos, rx2519_done
    set rx2519_off, 0
    lt rx2519_pos, 2, rx2519_start
    sub rx2519_off, rx2519_pos, 1
    substr rx2519_tgt, rx2519_tgt, rx2519_off
  rx2519_start:
    eq $I10, 1, rx2519_restart
    if_null rx2519_debug, debug_1426
    rx2519_cur."!cursor_debug"("START", "")
  debug_1426:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2520_done
    goto rxscan2520_scan
  rxscan2520_loop:
    (rx2519_pos) = rx2519_cur."from"()
    inc rx2519_pos
    rx2519_cur."!cursor_from"(rx2519_pos)
    ge rx2519_pos, rx2519_eos, rxscan2520_done
  rxscan2520_scan:
    set_addr $I10, rxscan2520_loop
    rx2519_cur."!mark_push"(0, rx2519_pos, $I10)
  rxscan2520_done:
  # rx charclass .
    ge rx2519_pos, rx2519_eos, rx2519_fail
    inc rx2519_pos
  # rx charclass w
    ge rx2519_pos, rx2519_eos, rx2519_fail
    sub $I10, rx2519_pos, rx2519_off
    is_cclass $I11, 8192, rx2519_tgt, $I10
    unless $I11, rx2519_fail
    inc rx2519_pos
  # rx pass
    rx2519_cur."!cursor_pass"(rx2519_pos, "")
    if_null rx2519_debug, debug_1427
    rx2519_cur."!cursor_debug"("PASS", "", " at pos=", rx2519_pos)
  debug_1427:
    .return (rx2519_cur)
  rx2519_restart:
    if_null rx2519_debug, debug_1428
    rx2519_cur."!cursor_debug"("NEXT", "")
  debug_1428:
  rx2519_fail:
    (rx2519_rep, rx2519_pos, $I10, $P10) = rx2519_cur."!mark_fail"(0)
    lt rx2519_pos, -1, rx2519_done
    eq rx2519_pos, -1, rx2519_fail
    jump $I10
  rx2519_done:
    rx2519_cur."!cursor_fail"()
    if_null rx2519_debug, debug_1429
    rx2519_cur."!cursor_debug"("FAIL", "")
  debug_1429:
    .return (rx2519_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("393_1303603603.711") :method :outer("384_1303603603.711")
.annotate 'line', 727
    .local string rx2522_tgt
    .local int rx2522_pos
    .local int rx2522_off
    .local int rx2522_eos
    .local int rx2522_rep
    .local pmc rx2522_cur
    .local pmc rx2522_debug
    (rx2522_cur, rx2522_pos, rx2522_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2522_cur
    .local pmc match
    .lex "$/", match
    length rx2522_eos, rx2522_tgt
    gt rx2522_pos, rx2522_eos, rx2522_done
    set rx2522_off, 0
    lt rx2522_pos, 2, rx2522_start
    sub rx2522_off, rx2522_pos, 1
    substr rx2522_tgt, rx2522_tgt, rx2522_off
  rx2522_start:
    eq $I10, 1, rx2522_restart
    if_null rx2522_debug, debug_1433
    rx2522_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1433:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2525_done
    goto rxscan2525_scan
  rxscan2525_loop:
    (rx2522_pos) = rx2522_cur."from"()
    inc rx2522_pos
    rx2522_cur."!cursor_from"(rx2522_pos)
    ge rx2522_pos, rx2522_eos, rxscan2525_done
  rxscan2525_scan:
    set_addr $I10, rxscan2525_loop
    rx2522_cur."!mark_push"(0, rx2522_pos, $I10)
  rxscan2525_done:
.annotate 'line', 741
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2522_pos, rx2522_off
    substr $S10, rx2522_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2522_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2522_cur."!cursor_pos"(rx2522_pos)
    $P10 = rx2522_cur."codeblock"()
    unless $P10, rx2522_fail
    rx2522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2522_pos = $P10."pos"()
.annotate 'line', 740
  # rx pass
    rx2522_cur."!cursor_pass"(rx2522_pos, "assertion:sym<{ }>")
    if_null rx2522_debug, debug_1434
    rx2522_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2522_pos)
  debug_1434:
    .return (rx2522_cur)
  rx2522_restart:
.annotate 'line', 727
    if_null rx2522_debug, debug_1435
    rx2522_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1435:
  rx2522_fail:
    (rx2522_rep, rx2522_pos, $I10, $P10) = rx2522_cur."!mark_fail"(0)
    lt rx2522_pos, -1, rx2522_done
    eq rx2522_pos, -1, rx2522_fail
    jump $I10
  rx2522_done:
    rx2522_cur."!cursor_fail"()
    if_null rx2522_debug, debug_1436
    rx2522_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1436:
    .return (rx2522_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("394_1303603603.711") :method
.annotate 'line', 727
    new $P2524, "ResizablePMCArray"
    push $P2524, "{"
    .return ($P2524)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("395_1303603603.711") :method :outer("384_1303603603.711")
.annotate 'line', 727
    .const 'Sub' $P2532 = "397_1303603603.711" 
    capture_lex $P2532
    .local string rx2527_tgt
    .local int rx2527_pos
    .local int rx2527_off
    .local int rx2527_eos
    .local int rx2527_rep
    .local pmc rx2527_cur
    .local pmc rx2527_debug
    (rx2527_cur, rx2527_pos, rx2527_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2527_cur
    .local pmc match
    .lex "$/", match
    length rx2527_eos, rx2527_tgt
    gt rx2527_pos, rx2527_eos, rx2527_done
    set rx2527_off, 0
    lt rx2527_pos, 2, rx2527_start
    sub rx2527_off, rx2527_pos, 1
    substr rx2527_tgt, rx2527_tgt, rx2527_off
  rx2527_start:
    eq $I10, 1, rx2527_restart
    if_null rx2527_debug, debug_1437
    rx2527_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1437:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2530_done
    goto rxscan2530_scan
  rxscan2530_loop:
    (rx2527_pos) = rx2527_cur."from"()
    inc rx2527_pos
    rx2527_cur."!cursor_from"(rx2527_pos)
    ge rx2527_pos, rx2527_eos, rxscan2530_done
  rxscan2530_scan:
    set_addr $I10, rxscan2530_loop
    rx2527_cur."!mark_push"(0, rx2527_pos, $I10)
  rxscan2530_done:
.annotate 'line', 745
  # rx subcapture "zw"
    set_addr $I10, rxcap_2535_fail
    rx2527_cur."!mark_push"(0, rx2527_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2527_pos, rx2527_eos, rx2527_fail
    sub $I10, rx2527_pos, rx2527_off
    substr $S10, rx2527_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2527_fail
    inc rx2527_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2527_cur."!cursor_pos"(rx2527_pos)
    .const 'Sub' $P2532 = "397_1303603603.711" 
    capture_lex $P2532
    $P10 = rx2527_cur."before"($P2532)
    unless $P10, rx2527_fail
    set_addr $I10, rxcap_2535_fail
    ($I12, $I11) = rx2527_cur."!mark_peek"($I10)
    rx2527_cur."!cursor_pos"($I11)
    ($P10) = rx2527_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2527_pos, "")
    rx2527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2535_done
  rxcap_2535_fail:
    goto rx2527_fail
  rxcap_2535_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2527_cur."!cursor_pos"(rx2527_pos)
    $P10 = rx2527_cur."codeblock"()
    unless $P10, rx2527_fail
    rx2527_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2527_pos = $P10."pos"()
.annotate 'line', 744
  # rx pass
    rx2527_cur."!cursor_pass"(rx2527_pos, "assertion:sym<?{ }>")
    if_null rx2527_debug, debug_1442
    rx2527_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2527_pos)
  debug_1442:
    .return (rx2527_cur)
  rx2527_restart:
.annotate 'line', 727
    if_null rx2527_debug, debug_1443
    rx2527_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1443:
  rx2527_fail:
    (rx2527_rep, rx2527_pos, $I10, $P10) = rx2527_cur."!mark_fail"(0)
    lt rx2527_pos, -1, rx2527_done
    eq rx2527_pos, -1, rx2527_fail
    jump $I10
  rx2527_done:
    rx2527_cur."!cursor_fail"()
    if_null rx2527_debug, debug_1444
    rx2527_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1444:
    .return (rx2527_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("396_1303603603.711") :method
.annotate 'line', 727
    new $P2529, "ResizablePMCArray"
    push $P2529, "!"
    push $P2529, "?"
    .return ($P2529)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2531"  :anon :subid("397_1303603603.711") :method :outer("395_1303603603.711")
.annotate 'line', 745
    .local string rx2533_tgt
    .local int rx2533_pos
    .local int rx2533_off
    .local int rx2533_eos
    .local int rx2533_rep
    .local pmc rx2533_cur
    .local pmc rx2533_debug
    (rx2533_cur, rx2533_pos, rx2533_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2533_cur
    .local pmc match
    .lex "$/", match
    length rx2533_eos, rx2533_tgt
    gt rx2533_pos, rx2533_eos, rx2533_done
    set rx2533_off, 0
    lt rx2533_pos, 2, rx2533_start
    sub rx2533_off, rx2533_pos, 1
    substr rx2533_tgt, rx2533_tgt, rx2533_off
  rx2533_start:
    eq $I10, 1, rx2533_restart
    if_null rx2533_debug, debug_1438
    rx2533_cur."!cursor_debug"("START", "")
  debug_1438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2534_done
    goto rxscan2534_scan
  rxscan2534_loop:
    (rx2533_pos) = rx2533_cur."from"()
    inc rx2533_pos
    rx2533_cur."!cursor_from"(rx2533_pos)
    ge rx2533_pos, rx2533_eos, rxscan2534_done
  rxscan2534_scan:
    set_addr $I10, rxscan2534_loop
    rx2533_cur."!mark_push"(0, rx2533_pos, $I10)
  rxscan2534_done:
  # rx literal  "{"
    add $I11, rx2533_pos, 1
    gt $I11, rx2533_eos, rx2533_fail
    sub $I11, rx2533_pos, rx2533_off
    ord $I11, rx2533_tgt, $I11
    ne $I11, 123, rx2533_fail
    add rx2533_pos, 1
  # rx pass
    rx2533_cur."!cursor_pass"(rx2533_pos, "")
    if_null rx2533_debug, debug_1439
    rx2533_cur."!cursor_debug"("PASS", "", " at pos=", rx2533_pos)
  debug_1439:
    .return (rx2533_cur)
  rx2533_restart:
    if_null rx2533_debug, debug_1440
    rx2533_cur."!cursor_debug"("NEXT", "")
  debug_1440:
  rx2533_fail:
    (rx2533_rep, rx2533_pos, $I10, $P10) = rx2533_cur."!mark_fail"(0)
    lt rx2533_pos, -1, rx2533_done
    eq rx2533_pos, -1, rx2533_fail
    jump $I10
  rx2533_done:
    rx2533_cur."!cursor_fail"()
    if_null rx2533_debug, debug_1441
    rx2533_cur."!cursor_debug"("FAIL", "")
  debug_1441:
    .return (rx2533_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("398_1303603603.711") :method :outer("384_1303603603.711")
.annotate 'line', 727
    .const 'Sub' $P2545 = "400_1303603603.711" 
    capture_lex $P2545
    .local string rx2537_tgt
    .local int rx2537_pos
    .local int rx2537_off
    .local int rx2537_eos
    .local int rx2537_rep
    .local pmc rx2537_cur
    .local pmc rx2537_debug
    (rx2537_cur, rx2537_pos, rx2537_tgt, $I10) = self."!cursor_start"()
    rx2537_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2537_cur
    .local pmc match
    .lex "$/", match
    length rx2537_eos, rx2537_tgt
    gt rx2537_pos, rx2537_eos, rx2537_done
    set rx2537_off, 0
    lt rx2537_pos, 2, rx2537_start
    sub rx2537_off, rx2537_pos, 1
    substr rx2537_tgt, rx2537_tgt, rx2537_off
  rx2537_start:
    eq $I10, 1, rx2537_restart
    if_null rx2537_debug, debug_1445
    rx2537_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1445:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2541_done
    goto rxscan2541_scan
  rxscan2541_loop:
    (rx2537_pos) = rx2537_cur."from"()
    inc rx2537_pos
    rx2537_cur."!cursor_from"(rx2537_pos)
    ge rx2537_pos, rx2537_eos, rxscan2541_done
  rxscan2541_scan:
    set_addr $I10, rxscan2541_loop
    rx2537_cur."!mark_push"(0, rx2537_pos, $I10)
  rxscan2541_done:
.annotate 'line', 749
  # rx subrule "identifier" subtype=capture negate=
    rx2537_cur."!cursor_pos"(rx2537_pos)
    $P10 = rx2537_cur."identifier"()
    unless $P10, rx2537_fail
    rx2537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2537_pos = $P10."pos"()
.annotate 'line', 756
  # rx rxquantr2542 ** 0..1
    set_addr $I10, rxquantr2542_done
    rx2537_cur."!mark_push"(0, rx2537_pos, $I10)
  rxquantr2542_loop:
  alt2543_0:
.annotate 'line', 750
    set_addr $I10, alt2543_1
    rx2537_cur."!mark_push"(0, rx2537_pos, $I10)
.annotate 'line', 751
  # rx subrule "before" subtype=zerowidth negate=
    rx2537_cur."!cursor_pos"(rx2537_pos)
    .const 'Sub' $P2545 = "400_1303603603.711" 
    capture_lex $P2545
    $P10 = rx2537_cur."before"($P2545)
    unless $P10, rx2537_fail
    goto alt2543_end
  alt2543_1:
    set_addr $I10, alt2543_2
    rx2537_cur."!mark_push"(0, rx2537_pos, $I10)
.annotate 'line', 752
  # rx literal  "="
    add $I11, rx2537_pos, 1
    gt $I11, rx2537_eos, rx2537_fail
    sub $I11, rx2537_pos, rx2537_off
    ord $I11, rx2537_tgt, $I11
    ne $I11, 61, rx2537_fail
    add rx2537_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2537_cur."!cursor_pos"(rx2537_pos)
    $P10 = rx2537_cur."assertion"()
    unless $P10, rx2537_fail
    rx2537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2537_pos = $P10."pos"()
    goto alt2543_end
  alt2543_2:
    set_addr $I10, alt2543_3
    rx2537_cur."!mark_push"(0, rx2537_pos, $I10)
.annotate 'line', 753
  # rx literal  ":"
    add $I11, rx2537_pos, 1
    gt $I11, rx2537_eos, rx2537_fail
    sub $I11, rx2537_pos, rx2537_off
    ord $I11, rx2537_tgt, $I11
    ne $I11, 58, rx2537_fail
    add rx2537_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2537_cur."!cursor_pos"(rx2537_pos)
    $P10 = rx2537_cur."arglist"()
    unless $P10, rx2537_fail
    rx2537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2537_pos = $P10."pos"()
    goto alt2543_end
  alt2543_3:
    set_addr $I10, alt2543_4
    rx2537_cur."!mark_push"(0, rx2537_pos, $I10)
.annotate 'line', 754
  # rx literal  "("
    add $I11, rx2537_pos, 1
    gt $I11, rx2537_eos, rx2537_fail
    sub $I11, rx2537_pos, rx2537_off
    ord $I11, rx2537_tgt, $I11
    ne $I11, 40, rx2537_fail
    add rx2537_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2537_cur."!cursor_pos"(rx2537_pos)
    $P10 = rx2537_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2537_fail
    rx2537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2537_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2537_pos, 1
    gt $I11, rx2537_eos, rx2537_fail
    sub $I11, rx2537_pos, rx2537_off
    ord $I11, rx2537_tgt, $I11
    ne $I11, 41, rx2537_fail
    add rx2537_pos, 1
    goto alt2543_end
  alt2543_4:
.annotate 'line', 755
  # rx subrule "normspace" subtype=method negate=
    rx2537_cur."!cursor_pos"(rx2537_pos)
    $P10 = rx2537_cur."normspace"()
    unless $P10, rx2537_fail
    rx2537_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2537_cur."!cursor_pos"(rx2537_pos)
    $P10 = rx2537_cur."nibbler"()
    unless $P10, rx2537_fail
    rx2537_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2537_pos = $P10."pos"()
  alt2543_end:
.annotate 'line', 756
    set_addr $I10, rxquantr2542_done
    (rx2537_rep) = rx2537_cur."!mark_commit"($I10)
  rxquantr2542_done:
.annotate 'line', 748
  # rx pass
    rx2537_cur."!cursor_pass"(rx2537_pos, "assertion:sym<name>")
    if_null rx2537_debug, debug_1450
    rx2537_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2537_pos)
  debug_1450:
    .return (rx2537_cur)
  rx2537_restart:
.annotate 'line', 727
    if_null rx2537_debug, debug_1451
    rx2537_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1451:
  rx2537_fail:
    (rx2537_rep, rx2537_pos, $I10, $P10) = rx2537_cur."!mark_fail"(0)
    lt rx2537_pos, -1, rx2537_done
    eq rx2537_pos, -1, rx2537_fail
    jump $I10
  rx2537_done:
    rx2537_cur."!cursor_fail"()
    if_null rx2537_debug, debug_1452
    rx2537_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1452:
    .return (rx2537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("399_1303603603.711") :method
.annotate 'line', 727
    $P2539 = self."!PREFIX__!subrule"("identifier", "")
    new $P2540, "ResizablePMCArray"
    push $P2540, $P2539
    .return ($P2540)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2544"  :anon :subid("400_1303603603.711") :method :outer("398_1303603603.711")
.annotate 'line', 751
    .local string rx2546_tgt
    .local int rx2546_pos
    .local int rx2546_off
    .local int rx2546_eos
    .local int rx2546_rep
    .local pmc rx2546_cur
    .local pmc rx2546_debug
    (rx2546_cur, rx2546_pos, rx2546_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2546_cur
    .local pmc match
    .lex "$/", match
    length rx2546_eos, rx2546_tgt
    gt rx2546_pos, rx2546_eos, rx2546_done
    set rx2546_off, 0
    lt rx2546_pos, 2, rx2546_start
    sub rx2546_off, rx2546_pos, 1
    substr rx2546_tgt, rx2546_tgt, rx2546_off
  rx2546_start:
    eq $I10, 1, rx2546_restart
    if_null rx2546_debug, debug_1446
    rx2546_cur."!cursor_debug"("START", "")
  debug_1446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2547_done
    goto rxscan2547_scan
  rxscan2547_loop:
    (rx2546_pos) = rx2546_cur."from"()
    inc rx2546_pos
    rx2546_cur."!cursor_from"(rx2546_pos)
    ge rx2546_pos, rx2546_eos, rxscan2547_done
  rxscan2547_scan:
    set_addr $I10, rxscan2547_loop
    rx2546_cur."!mark_push"(0, rx2546_pos, $I10)
  rxscan2547_done:
  # rx literal  ">"
    add $I11, rx2546_pos, 1
    gt $I11, rx2546_eos, rx2546_fail
    sub $I11, rx2546_pos, rx2546_off
    ord $I11, rx2546_tgt, $I11
    ne $I11, 62, rx2546_fail
    add rx2546_pos, 1
  # rx pass
    rx2546_cur."!cursor_pass"(rx2546_pos, "")
    if_null rx2546_debug, debug_1447
    rx2546_cur."!cursor_debug"("PASS", "", " at pos=", rx2546_pos)
  debug_1447:
    .return (rx2546_cur)
  rx2546_restart:
    if_null rx2546_debug, debug_1448
    rx2546_cur."!cursor_debug"("NEXT", "")
  debug_1448:
  rx2546_fail:
    (rx2546_rep, rx2546_pos, $I10, $P10) = rx2546_cur."!mark_fail"(0)
    lt rx2546_pos, -1, rx2546_done
    eq rx2546_pos, -1, rx2546_fail
    jump $I10
  rx2546_done:
    rx2546_cur."!cursor_fail"()
    if_null rx2546_debug, debug_1449
    rx2546_cur."!cursor_debug"("FAIL", "")
  debug_1449:
    .return (rx2546_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("401_1303603603.711") :method :outer("384_1303603603.711")
.annotate 'line', 727
    .local string rx2549_tgt
    .local int rx2549_pos
    .local int rx2549_off
    .local int rx2549_eos
    .local int rx2549_rep
    .local pmc rx2549_cur
    .local pmc rx2549_debug
    (rx2549_cur, rx2549_pos, rx2549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2549_cur
    .local pmc match
    .lex "$/", match
    length rx2549_eos, rx2549_tgt
    gt rx2549_pos, rx2549_eos, rx2549_done
    set rx2549_off, 0
    lt rx2549_pos, 2, rx2549_start
    sub rx2549_off, rx2549_pos, 1
    substr rx2549_tgt, rx2549_tgt, rx2549_off
  rx2549_start:
    eq $I10, 1, rx2549_restart
    if_null rx2549_debug, debug_1453
    rx2549_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1453:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2552_done
    goto rxscan2552_scan
  rxscan2552_loop:
    (rx2549_pos) = rx2549_cur."from"()
    inc rx2549_pos
    rx2549_cur."!cursor_from"(rx2549_pos)
    ge rx2549_pos, rx2549_eos, rxscan2552_done
  rxscan2552_scan:
    set_addr $I10, rxscan2552_loop
    rx2549_cur."!mark_push"(0, rx2549_pos, $I10)
  rxscan2552_done:
.annotate 'line', 760
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2549_pos, rx2549_off
    substr $S10, rx2549_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2549_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2549_cur."!cursor_pos"(rx2549_pos)
    $P10 = rx2549_cur."LANG"("MAIN", "variable")
    unless $P10, rx2549_fail
    rx2549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2549_pos = $P10."pos"()
.annotate 'line', 759
  # rx pass
    rx2549_cur."!cursor_pass"(rx2549_pos, "assertion:sym<var>")
    if_null rx2549_debug, debug_1454
    rx2549_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2549_pos)
  debug_1454:
    .return (rx2549_cur)
  rx2549_restart:
.annotate 'line', 727
    if_null rx2549_debug, debug_1455
    rx2549_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1455:
  rx2549_fail:
    (rx2549_rep, rx2549_pos, $I10, $P10) = rx2549_cur."!mark_fail"(0)
    lt rx2549_pos, -1, rx2549_done
    eq rx2549_pos, -1, rx2549_fail
    jump $I10
  rx2549_done:
    rx2549_cur."!cursor_fail"()
    if_null rx2549_debug, debug_1456
    rx2549_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1456:
    .return (rx2549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("402_1303603603.711") :method
.annotate 'line', 727
    new $P2551, "ResizablePMCArray"
    push $P2551, "$"
    push $P2551, "@"
    .return ($P2551)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("403_1303603603.711") :method :outer("384_1303603603.711")
.annotate 'line', 727
    .local string rx2554_tgt
    .local int rx2554_pos
    .local int rx2554_off
    .local int rx2554_eos
    .local int rx2554_rep
    .local pmc rx2554_cur
    .local pmc rx2554_debug
    (rx2554_cur, rx2554_pos, rx2554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2554_cur
    .local pmc match
    .lex "$/", match
    length rx2554_eos, rx2554_tgt
    gt rx2554_pos, rx2554_eos, rx2554_done
    set rx2554_off, 0
    lt rx2554_pos, 2, rx2554_start
    sub rx2554_off, rx2554_pos, 1
    substr rx2554_tgt, rx2554_tgt, rx2554_off
  rx2554_start:
    eq $I10, 1, rx2554_restart
    if_null rx2554_debug, debug_1457
    rx2554_cur."!cursor_debug"("START", "codeblock")
  debug_1457:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2558_done
    goto rxscan2558_scan
  rxscan2558_loop:
    (rx2554_pos) = rx2554_cur."from"()
    inc rx2554_pos
    rx2554_cur."!cursor_from"(rx2554_pos)
    ge rx2554_pos, rx2554_eos, rxscan2558_done
  rxscan2558_scan:
    set_addr $I10, rxscan2558_loop
    rx2554_cur."!mark_push"(0, rx2554_pos, $I10)
  rxscan2558_done:
.annotate 'line', 764
  # rx subrule "LANG" subtype=capture negate=
    rx2554_cur."!cursor_pos"(rx2554_pos)
    $P10 = rx2554_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2554_fail
    rx2554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2554_pos = $P10."pos"()
.annotate 'line', 763
  # rx pass
    rx2554_cur."!cursor_pass"(rx2554_pos, "codeblock")
    if_null rx2554_debug, debug_1458
    rx2554_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2554_pos)
  debug_1458:
    .return (rx2554_cur)
  rx2554_restart:
.annotate 'line', 727
    if_null rx2554_debug, debug_1459
    rx2554_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1459:
  rx2554_fail:
    (rx2554_rep, rx2554_pos, $I10, $P10) = rx2554_cur."!mark_fail"(0)
    lt rx2554_pos, -1, rx2554_done
    eq rx2554_pos, -1, rx2554_fail
    jump $I10
  rx2554_done:
    rx2554_cur."!cursor_fail"()
    if_null rx2554_debug, debug_1460
    rx2554_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1460:
    .return (rx2554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("404_1303603603.711") :method
.annotate 'line', 727
    $P2556 = self."!PREFIX__!subrule"("LANG", "")
    new $P2557, "ResizablePMCArray"
    push $P2557, $P2556
    .return ($P2557)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2598"  :subid("406_1303603603.711") :outer("10_1303603603.711")
.annotate 'line', 770
    .const 'Sub' $P5924 = "567_1303603603.711" 
    capture_lex $P5924
    .const 'Sub' $P5910 = "566_1303603603.711" 
    capture_lex $P5910
    .const 'Sub' $P5905 = "565_1303603603.711" 
    capture_lex $P5905
    .const 'Sub' $P5900 = "564_1303603603.711" 
    capture_lex $P5900
    .const 'Sub' $P5895 = "563_1303603603.711" 
    capture_lex $P5895
    .const 'Sub' $P5884 = "562_1303603603.711" 
    capture_lex $P5884
    .const 'Sub' $P5876 = "561_1303603603.711" 
    capture_lex $P5876
    .const 'Sub' $P5868 = "560_1303603603.711" 
    capture_lex $P5868
    .const 'Sub' $P5860 = "559_1303603603.711" 
    capture_lex $P5860
    .const 'Sub' $P5855 = "558_1303603603.711" 
    capture_lex $P5855
    .const 'Sub' $P5843 = "557_1303603603.711" 
    capture_lex $P5843
    .const 'Sub' $P5835 = "556_1303603603.711" 
    capture_lex $P5835
    .const 'Sub' $P5788 = "555_1303603603.711" 
    capture_lex $P5788
    .const 'Sub' $P5776 = "554_1303603603.711" 
    capture_lex $P5776
    .const 'Sub' $P5768 = "553_1303603603.711" 
    capture_lex $P5768
    .const 'Sub' $P5760 = "552_1303603603.711" 
    capture_lex $P5760
    .const 'Sub' $P5752 = "551_1303603603.711" 
    capture_lex $P5752
    .const 'Sub' $P5744 = "550_1303603603.711" 
    capture_lex $P5744
    .const 'Sub' $P5736 = "549_1303603603.711" 
    capture_lex $P5736
    .const 'Sub' $P5710 = "548_1303603603.711" 
    capture_lex $P5710
    .const 'Sub' $P5695 = "547_1303603603.711" 
    capture_lex $P5695
    .const 'Sub' $P5687 = "546_1303603603.711" 
    capture_lex $P5687
    .const 'Sub' $P5676 = "545_1303603603.711" 
    capture_lex $P5676
    .const 'Sub' $P5665 = "544_1303603603.711" 
    capture_lex $P5665
    .const 'Sub' $P5654 = "543_1303603603.711" 
    capture_lex $P5654
    .const 'Sub' $P5646 = "542_1303603603.711" 
    capture_lex $P5646
    .const 'Sub' $P5619 = "541_1303603603.711" 
    capture_lex $P5619
    .const 'Sub' $P5581 = "539_1303603603.711" 
    capture_lex $P5581
    .const 'Sub' $P5573 = "538_1303603603.711" 
    capture_lex $P5573
    .const 'Sub' $P5565 = "537_1303603603.711" 
    capture_lex $P5565
    .const 'Sub' $P5540 = "536_1303603603.711" 
    capture_lex $P5540
    .const 'Sub' $P5524 = "535_1303603603.711" 
    capture_lex $P5524
    .const 'Sub' $P5516 = "534_1303603603.711" 
    capture_lex $P5516
    .const 'Sub' $P5508 = "533_1303603603.711" 
    capture_lex $P5508
    .const 'Sub' $P5406 = "530_1303603603.711" 
    capture_lex $P5406
    .const 'Sub' $P5398 = "529_1303603603.711" 
    capture_lex $P5398
    .const 'Sub' $P5391 = "528_1303603603.711" 
    capture_lex $P5391
    .const 'Sub' $P5360 = "527_1303603603.711" 
    capture_lex $P5360
    .const 'Sub' $P5307 = "525_1303603603.711" 
    capture_lex $P5307
    .const 'Sub' $P5293 = "524_1303603603.711" 
    capture_lex $P5293
    .const 'Sub' $P5286 = "523_1303603603.711" 
    capture_lex $P5286
    .const 'Sub' $P5237 = "522_1303603603.711" 
    capture_lex $P5237
    .const 'Sub' $P5061 = "518_1303603603.711" 
    capture_lex $P5061
    .const 'Sub' $P4998 = "516_1303603603.711" 
    capture_lex $P4998
    .const 'Sub' $P4990 = "515_1303603603.711" 
    capture_lex $P4990
    .const 'Sub' $P4975 = "514_1303603603.711" 
    capture_lex $P4975
    .const 'Sub' $P4960 = "513_1303603603.711" 
    capture_lex $P4960
    .const 'Sub' $P4940 = "512_1303603603.711" 
    capture_lex $P4940
    .const 'Sub' $P4837 = "511_1303603603.711" 
    capture_lex $P4837
    .const 'Sub' $P4789 = "508_1303603603.711" 
    capture_lex $P4789
    .const 'Sub' $P4664 = "505_1303603603.711" 
    capture_lex $P4664
    .const 'Sub' $P4391 = "498_1303603603.711" 
    capture_lex $P4391
    .const 'Sub' $P4383 = "497_1303603603.711" 
    capture_lex $P4383
    .const 'Sub' $P4375 = "496_1303603603.711" 
    capture_lex $P4375
    .const 'Sub' $P4267 = "493_1303603603.711" 
    capture_lex $P4267
    .const 'Sub' $P4259 = "492_1303603603.711" 
    capture_lex $P4259
    .const 'Sub' $P4244 = "491_1303603603.711" 
    capture_lex $P4244
    .const 'Sub' $P4229 = "490_1303603603.711" 
    capture_lex $P4229
    .const 'Sub' $P4214 = "489_1303603603.711" 
    capture_lex $P4214
    .const 'Sub' $P4192 = "488_1303603603.711" 
    capture_lex $P4192
    .const 'Sub' $P4184 = "487_1303603603.711" 
    capture_lex $P4184
    .const 'Sub' $P4176 = "486_1303603603.711" 
    capture_lex $P4176
    .const 'Sub' $P4168 = "485_1303603603.711" 
    capture_lex $P4168
    .const 'Sub' $P3969 = "482_1303603603.711" 
    capture_lex $P3969
    .const 'Sub' $P3961 = "481_1303603603.711" 
    capture_lex $P3961
    .const 'Sub' $P3953 = "480_1303603603.711" 
    capture_lex $P3953
    .const 'Sub' $P3945 = "479_1303603603.711" 
    capture_lex $P3945
    .const 'Sub' $P3937 = "478_1303603603.711" 
    capture_lex $P3937
    .const 'Sub' $P3929 = "477_1303603603.711" 
    capture_lex $P3929
    .const 'Sub' $P3921 = "476_1303603603.711" 
    capture_lex $P3921
    .const 'Sub' $P3810 = "474_1303603603.711" 
    capture_lex $P3810
    .const 'Sub' $P3786 = "473_1303603603.711" 
    capture_lex $P3786
    .const 'Sub' $P3772 = "472_1303603603.711" 
    capture_lex $P3772
    .const 'Sub' $P3764 = "471_1303603603.711" 
    capture_lex $P3764
    .const 'Sub' $P3756 = "470_1303603603.711" 
    capture_lex $P3756
    .const 'Sub' $P3748 = "469_1303603603.711" 
    capture_lex $P3748
    .const 'Sub' $P3740 = "468_1303603603.711" 
    capture_lex $P3740
    .const 'Sub' $P3732 = "467_1303603603.711" 
    capture_lex $P3732
    .const 'Sub' $P3724 = "466_1303603603.711" 
    capture_lex $P3724
    .const 'Sub' $P3716 = "465_1303603603.711" 
    capture_lex $P3716
    .const 'Sub' $P3708 = "464_1303603603.711" 
    capture_lex $P3708
    .const 'Sub' $P3700 = "463_1303603603.711" 
    capture_lex $P3700
    .const 'Sub' $P3692 = "462_1303603603.711" 
    capture_lex $P3692
    .const 'Sub' $P3684 = "461_1303603603.711" 
    capture_lex $P3684
    .const 'Sub' $P3676 = "460_1303603603.711" 
    capture_lex $P3676
    .const 'Sub' $P3668 = "459_1303603603.711" 
    capture_lex $P3668
    .const 'Sub' $P3652 = "458_1303603603.711" 
    capture_lex $P3652
    .const 'Sub' $P3619 = "457_1303603603.711" 
    capture_lex $P3619
    .const 'Sub' $P3605 = "456_1303603603.711" 
    capture_lex $P3605
    .const 'Sub' $P3584 = "455_1303603603.711" 
    capture_lex $P3584
    .const 'Sub' $P3564 = "454_1303603603.711" 
    capture_lex $P3564
    .const 'Sub' $P3540 = "453_1303603603.711" 
    capture_lex $P3540
    .const 'Sub' $P3506 = "452_1303603603.711" 
    capture_lex $P3506
    .const 'Sub' $P3491 = "451_1303603603.711" 
    capture_lex $P3491
    .const 'Sub' $P3479 = "450_1303603603.711" 
    capture_lex $P3479
    .const 'Sub' $P3428 = "448_1303603603.711" 
    capture_lex $P3428
    .const 'Sub' $P3416 = "447_1303603603.711" 
    capture_lex $P3416
    .const 'Sub' $P3409 = "446_1303603603.711" 
    capture_lex $P3409
    .const 'Sub' $P3386 = "445_1303603603.711" 
    capture_lex $P3386
    .const 'Sub' $P3364 = "444_1303603603.711" 
    capture_lex $P3364
    .const 'Sub' $P3353 = "443_1303603603.711" 
    capture_lex $P3353
    .const 'Sub' $P3316 = "441_1303603603.711" 
    capture_lex $P3316
    .const 'Sub' $P3308 = "440_1303603603.711" 
    capture_lex $P3308
    .const 'Sub' $P3300 = "439_1303603603.711" 
    capture_lex $P3300
    .const 'Sub' $P3286 = "438_1303603603.711" 
    capture_lex $P3286
    .const 'Sub' $P3205 = "436_1303603603.711" 
    capture_lex $P3205
    .const 'Sub' $P3164 = "434_1303603603.711" 
    capture_lex $P3164
    .const 'Sub' $P3097 = "433_1303603603.711" 
    capture_lex $P3097
    .const 'Sub' $P3066 = "432_1303603603.711" 
    capture_lex $P3066
    .const 'Sub' $P3058 = "431_1303603603.711" 
    capture_lex $P3058
    .const 'Sub' $P2931 = "425_1303603603.711" 
    capture_lex $P2931
    .const 'Sub' $P2896 = "423_1303603603.711" 
    capture_lex $P2896
    .const 'Sub' $P2891 = "422_1303603603.711" 
    capture_lex $P2891
    .const 'Sub' $P2886 = "421_1303603603.711" 
    capture_lex $P2886
    .const 'Sub' $P2815 = "418_1303603603.711" 
    capture_lex $P2815
    .const 'Sub' $P2803 = "417_1303603603.711" 
    capture_lex $P2803
    .const 'Sub' $P2738 = "415_1303603603.711" 
    capture_lex $P2738
    .const 'Sub' $P2726 = "414_1303603603.711" 
    capture_lex $P2726
    .const 'Sub' $P2672 = "413_1303603603.711" 
    capture_lex $P2672
    .const 'Sub' $P2659 = "412_1303603603.711" 
    capture_lex $P2659
    .const 'Sub' $P2641 = "411_1303603603.711" 
    capture_lex $P2641
    .const 'Sub' $P2608 = "408_1303603603.711" 
    capture_lex $P2608
    .const 'Sub' $P2600 = "407_1303603603.711" 
    capture_lex $P2600
.annotate 'line', 774
    .const 'Sub' $P2600 = "407_1303603603.711" 
    newclosure $P2607, $P2600
    .lex "xblock_immediate", $P2607
.annotate 'line', 779
    .const 'Sub' $P2608 = "408_1303603603.711" 
    newclosure $P2640, $P2608
    .lex "block_immediate", $P2640
.annotate 'line', 789
    .const 'Sub' $P2641 = "411_1303603603.711" 
    newclosure $P2658, $P2641
    .lex "vivitype", $P2658
.annotate 'line', 808
    .const 'Sub' $P2659 = "412_1303603603.711" 
    newclosure $P2671, $P2659
    .lex "colonpair_str", $P2671
.annotate 'line', 1056
    .const 'Sub' $P2672 = "413_1303603603.711" 
    newclosure $P2725, $P2672
    .lex "push_block_handler", $P2725
.annotate 'line', 1613
    .const 'Sub' $P2726 = "414_1303603603.711" 
    newclosure $P2737, $P2726
    .lex "only_star_block", $P2737
.annotate 'line', 1622
    .const 'Sub' $P2738 = "415_1303603603.711" 
    newclosure $P2802, $P2738
    .lex "attach_multi_signature", $P2802
.annotate 'line', 2096
    .const 'Sub' $P2803 = "417_1303603603.711" 
    newclosure $P2814, $P2803
    .lex "control", $P2814
.annotate 'line', 2115
    .const 'Sub' $P2815 = "418_1303603603.711" 
    newclosure $P2885, $P2815
    .lex "lexical_package_lookup", $P2885
.annotate 'line', 2160
    .const 'Sub' $P2886 = "421_1303603603.711" 
    newclosure $P2890, $P2886
    .lex "is_lexical", $P2890
.annotate 'line', 2166
    .const 'Sub' $P2891 = "422_1303603603.711" 
    newclosure $P2895, $P2891
    .lex "is_package", $P2895
.annotate 'line', 2172
    .const 'Sub' $P2896 = "423_1303603603.711" 
    newclosure $P2930, $P2896
    .lex "is_scope", $P2930
.annotate 'line', 2185
    .const 'Sub' $P2931 = "425_1303603603.711" 
    newclosure $P3049, $P2931
    .lex "find_sym", $P3049
.annotate 'line', 770
    .lex "$?PACKAGE", $P3050
    .lex "$?CLASS", $P3051
.annotate 'line', 772
    new $P3052, "ResizablePMCArray"
    find_lex $P3053, "$?PACKAGE"
    get_who $P3054, $P3053
    set $P3054["@BLOCK"], $P3052
    find_lex $P3055, "xblock_immediate"
    find_lex $P3056, "block_immediate"
    find_lex $P3057, "vivitype"
.annotate 'line', 800
    find_lex $P3096, "colonpair_str"
.annotate 'line', 1049
    find_lex $P3604, "push_block_handler"
.annotate 'line', 1541
    find_lex $P4787, "only_star_block"
    find_lex $P4788, "attach_multi_signature"
.annotate 'line', 2087
    find_lex $P5894, "control"
.annotate 'line', 2109
    find_lex $P5918, "lexical_package_lookup"
    find_lex $P5919, "is_lexical"
    find_lex $P5920, "is_package"
    find_lex $P5921, "is_scope"
    find_lex $P5922, "find_sym"
.annotate 'line', 770
    .return ($P5922)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1461") :outer("406_1303603603.711")
.annotate 'line', 770
    .const 'Sub' $P2599 = "406_1303603603.711" 
    .local pmc block
    set block, $P2599
    .const 'Sub' $P5924 = "567_1303603603.711" 
    capture_lex $P5924
    $P5924()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5923"  :anon :subid("567_1303603603.711") :outer("406_1303603603.711")
.annotate 'line', 770
    nqp_get_sc_object $P5925, "1303603591.505", 3
    .local pmc type_obj
    set type_obj, $P5925
    get_how $P5926, type_obj
    .const 'Sub' $P5927 = "431_1303603603.711" 
    $P5926."add_method"(type_obj, "TOP", $P5927)
    get_how $P5928, type_obj
    .const 'Sub' $P5929 = "432_1303603603.711" 
    $P5928."add_method"(type_obj, "deflongname", $P5929)
    get_how $P5930, type_obj
    .const 'Sub' $P5931 = "433_1303603603.711" 
    $P5930."add_method"(type_obj, "comp_unit", $P5931)
    get_how $P5932, type_obj
    .const 'Sub' $P5933 = "434_1303603603.711" 
    $P5932."add_method"(type_obj, "statementlist", $P5933)
    get_how $P5934, type_obj
    .const 'Sub' $P5935 = "436_1303603603.711" 
    $P5934."add_method"(type_obj, "statement", $P5935)
    get_how $P5936, type_obj
    .const 'Sub' $P5937 = "438_1303603603.711" 
    $P5936."add_method"(type_obj, "xblock", $P5937)
    get_how $P5938, type_obj
    .const 'Sub' $P5939 = "439_1303603603.711" 
    $P5938."add_method"(type_obj, "pblock", $P5939)
    get_how $P5940, type_obj
    .const 'Sub' $P5941 = "440_1303603603.711" 
    $P5940."add_method"(type_obj, "block", $P5941)
    get_how $P5942, type_obj
    .const 'Sub' $P5943 = "441_1303603603.711" 
    $P5942."add_method"(type_obj, "blockoid", $P5943)
    get_how $P5944, type_obj
    .const 'Sub' $P5945 = "443_1303603603.711" 
    $P5944."add_method"(type_obj, "newpad", $P5945)
    get_how $P5946, type_obj
    .const 'Sub' $P5947 = "444_1303603603.711" 
    $P5946."add_method"(type_obj, "outerctx", $P5947)
    get_how $P5948, type_obj
    .const 'Sub' $P5949 = "445_1303603603.711" 
    $P5948."add_method"(type_obj, "GLOBALish", $P5949)
    get_how $P5950, type_obj
    .const 'Sub' $P5951 = "446_1303603603.711" 
    $P5950."add_method"(type_obj, "you_are_here", $P5951)
    get_how $P5952, type_obj
    .const 'Sub' $P5953 = "447_1303603603.711" 
    $P5952."add_method"(type_obj, "statement_control:sym<use>", $P5953)
    get_how $P5954, type_obj
    .const 'Sub' $P5955 = "448_1303603603.711" 
    $P5954."add_method"(type_obj, "statement_control:sym<if>", $P5955)
    get_how $P5956, type_obj
    .const 'Sub' $P5957 = "450_1303603603.711" 
    $P5956."add_method"(type_obj, "statement_control:sym<unless>", $P5957)
    get_how $P5958, type_obj
    .const 'Sub' $P5959 = "451_1303603603.711" 
    $P5958."add_method"(type_obj, "statement_control:sym<while>", $P5959)
    get_how $P5960, type_obj
    .const 'Sub' $P5961 = "452_1303603603.711" 
    $P5960."add_method"(type_obj, "statement_control:sym<repeat>", $P5961)
    get_how $P5962, type_obj
    .const 'Sub' $P5963 = "453_1303603603.711" 
    $P5962."add_method"(type_obj, "statement_control:sym<for>", $P5963)
    get_how $P5964, type_obj
    .const 'Sub' $P5965 = "454_1303603603.711" 
    $P5964."add_method"(type_obj, "statement_control:sym<CATCH>", $P5965)
    get_how $P5966, type_obj
    .const 'Sub' $P5967 = "455_1303603603.711" 
    $P5966."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5967)
    get_how $P5968, type_obj
    .const 'Sub' $P5969 = "456_1303603603.711" 
    $P5968."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5969)
    get_how $P5970, type_obj
    .const 'Sub' $P5971 = "457_1303603603.711" 
    $P5970."add_method"(type_obj, "statement_prefix:sym<try>", $P5971)
    get_how $P5972, type_obj
    .const 'Sub' $P5973 = "458_1303603603.711" 
    $P5972."add_method"(type_obj, "blorst", $P5973)
    get_how $P5974, type_obj
    .const 'Sub' $P5975 = "459_1303603603.711" 
    $P5974."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5975)
    get_how $P5976, type_obj
    .const 'Sub' $P5977 = "460_1303603603.711" 
    $P5976."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5977)
    get_how $P5978, type_obj
    .const 'Sub' $P5979 = "461_1303603603.711" 
    $P5978."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5979)
    get_how $P5980, type_obj
    .const 'Sub' $P5981 = "462_1303603603.711" 
    $P5980."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5981)
    get_how $P5982, type_obj
    .const 'Sub' $P5983 = "463_1303603603.711" 
    $P5982."add_method"(type_obj, "term:sym<fatarrow>", $P5983)
    get_how $P5984, type_obj
    .const 'Sub' $P5985 = "464_1303603603.711" 
    $P5984."add_method"(type_obj, "term:sym<colonpair>", $P5985)
    get_how $P5986, type_obj
    .const 'Sub' $P5987 = "465_1303603603.711" 
    $P5986."add_method"(type_obj, "term:sym<variable>", $P5987)
    get_how $P5988, type_obj
    .const 'Sub' $P5989 = "466_1303603603.711" 
    $P5988."add_method"(type_obj, "term:sym<package_declarator>", $P5989)
    get_how $P5990, type_obj
    .const 'Sub' $P5991 = "467_1303603603.711" 
    $P5990."add_method"(type_obj, "term:sym<scope_declarator>", $P5991)
    get_how $P5992, type_obj
    .const 'Sub' $P5993 = "468_1303603603.711" 
    $P5992."add_method"(type_obj, "term:sym<routine_declarator>", $P5993)
    get_how $P5994, type_obj
    .const 'Sub' $P5995 = "469_1303603603.711" 
    $P5994."add_method"(type_obj, "term:sym<regex_declarator>", $P5995)
    get_how $P5996, type_obj
    .const 'Sub' $P5997 = "470_1303603603.711" 
    $P5996."add_method"(type_obj, "term:sym<statement_prefix>", $P5997)
    get_how $P5998, type_obj
    .const 'Sub' $P5999 = "471_1303603603.711" 
    $P5998."add_method"(type_obj, "term:sym<lambda>", $P5999)
    get_how $P6000, type_obj
    .const 'Sub' $P6001 = "472_1303603603.711" 
    $P6000."add_method"(type_obj, "fatarrow", $P6001)
    get_how $P6002, type_obj
    .const 'Sub' $P6003 = "473_1303603603.711" 
    $P6002."add_method"(type_obj, "colonpair", $P6003)
    get_how $P6004, type_obj
    .const 'Sub' $P6005 = "474_1303603603.711" 
    $P6004."add_method"(type_obj, "variable", $P6005)
    get_how $P6006, type_obj
    .const 'Sub' $P6007 = "476_1303603603.711" 
    $P6006."add_method"(type_obj, "package_declarator:sym<module>", $P6007)
    get_how $P6008, type_obj
    .const 'Sub' $P6009 = "477_1303603603.711" 
    $P6008."add_method"(type_obj, "package_declarator:sym<knowhow>", $P6009)
    get_how $P6010, type_obj
    .const 'Sub' $P6011 = "478_1303603603.711" 
    $P6010."add_method"(type_obj, "package_declarator:sym<class>", $P6011)
    get_how $P6012, type_obj
    .const 'Sub' $P6013 = "479_1303603603.711" 
    $P6012."add_method"(type_obj, "package_declarator:sym<grammar>", $P6013)
    get_how $P6014, type_obj
    .const 'Sub' $P6015 = "480_1303603603.711" 
    $P6014."add_method"(type_obj, "package_declarator:sym<role>", $P6015)
    get_how $P6016, type_obj
    .const 'Sub' $P6017 = "481_1303603603.711" 
    $P6016."add_method"(type_obj, "package_declarator:sym<native>", $P6017)
    get_how $P6018, type_obj
    .const 'Sub' $P6019 = "482_1303603603.711" 
    $P6018."add_method"(type_obj, "package_def", $P6019)
    get_how $P6020, type_obj
    .const 'Sub' $P6021 = "485_1303603603.711" 
    $P6020."add_method"(type_obj, "scope_declarator:sym<my>", $P6021)
    get_how $P6022, type_obj
    .const 'Sub' $P6023 = "486_1303603603.711" 
    $P6022."add_method"(type_obj, "scope_declarator:sym<our>", $P6023)
    get_how $P6024, type_obj
    .const 'Sub' $P6025 = "487_1303603603.711" 
    $P6024."add_method"(type_obj, "scope_declarator:sym<has>", $P6025)
    get_how $P6026, type_obj
    .const 'Sub' $P6027 = "488_1303603603.711" 
    $P6026."add_method"(type_obj, "scoped", $P6027)
    get_how $P6028, type_obj
    .const 'Sub' $P6029 = "489_1303603603.711" 
    $P6028."add_method"(type_obj, "declarator", $P6029)
    get_how $P6030, type_obj
    .const 'Sub' $P6031 = "490_1303603603.711" 
    $P6030."add_method"(type_obj, "multi_declarator:sym<multi>", $P6031)
    get_how $P6032, type_obj
    .const 'Sub' $P6033 = "491_1303603603.711" 
    $P6032."add_method"(type_obj, "multi_declarator:sym<proto>", $P6033)
    get_how $P6034, type_obj
    .const 'Sub' $P6035 = "492_1303603603.711" 
    $P6034."add_method"(type_obj, "multi_declarator:sym<null>", $P6035)
    get_how $P6036, type_obj
    .const 'Sub' $P6037 = "493_1303603603.711" 
    $P6036."add_method"(type_obj, "variable_declarator", $P6037)
    get_how $P6038, type_obj
    .const 'Sub' $P6039 = "496_1303603603.711" 
    $P6038."add_method"(type_obj, "routine_declarator:sym<sub>", $P6039)
    get_how $P6040, type_obj
    .const 'Sub' $P6041 = "497_1303603603.711" 
    $P6040."add_method"(type_obj, "routine_declarator:sym<method>", $P6041)
    get_how $P6042, type_obj
    .const 'Sub' $P6043 = "498_1303603603.711" 
    $P6042."add_method"(type_obj, "routine_def", $P6043)
    get_how $P6044, type_obj
    .const 'Sub' $P6045 = "505_1303603603.711" 
    $P6044."add_method"(type_obj, "method_def", $P6045)
    get_how $P6046, type_obj
    .const 'Sub' $P6047 = "508_1303603603.711" 
    $P6046."add_method"(type_obj, "signature", $P6047)
    get_how $P6048, type_obj
    .const 'Sub' $P6049 = "511_1303603603.711" 
    $P6048."add_method"(type_obj, "parameter", $P6049)
    get_how $P6050, type_obj
    .const 'Sub' $P6051 = "512_1303603603.711" 
    $P6050."add_method"(type_obj, "param_var", $P6051)
    get_how $P6052, type_obj
    .const 'Sub' $P6053 = "513_1303603603.711" 
    $P6052."add_method"(type_obj, "named_param", $P6053)
    get_how $P6054, type_obj
    .const 'Sub' $P6055 = "514_1303603603.711" 
    $P6054."add_method"(type_obj, "typename", $P6055)
    get_how $P6056, type_obj
    .const 'Sub' $P6057 = "515_1303603603.711" 
    $P6056."add_method"(type_obj, "trait", $P6057)
    get_how $P6058, type_obj
    .const 'Sub' $P6059 = "516_1303603603.711" 
    $P6058."add_method"(type_obj, "trait_mod:sym<is>", $P6059)
    get_how $P6060, type_obj
    .const 'Sub' $P6061 = "518_1303603603.711" 
    $P6060."add_method"(type_obj, "regex_declarator", $P6061)
    get_how $P6062, type_obj
    .const 'Sub' $P6063 = "522_1303603603.711" 
    $P6062."add_method"(type_obj, "dotty", $P6063)
    get_how $P6064, type_obj
    .const 'Sub' $P6065 = "523_1303603603.711" 
    $P6064."add_method"(type_obj, "term:sym<self>", $P6065)
    get_how $P6066, type_obj
    .const 'Sub' $P6067 = "524_1303603603.711" 
    $P6066."add_method"(type_obj, "term:sym<identifier>", $P6067)
    get_how $P6068, type_obj
    .const 'Sub' $P6069 = "525_1303603603.711" 
    $P6068."add_method"(type_obj, "term:sym<name>", $P6069)
    get_how $P6070, type_obj
    .const 'Sub' $P6071 = "527_1303603603.711" 
    $P6070."add_method"(type_obj, "term:sym<pir::op>", $P6071)
    get_how $P6072, type_obj
    .const 'Sub' $P6073 = "528_1303603603.711" 
    $P6072."add_method"(type_obj, "term:sym<onlystar>", $P6073)
    get_how $P6074, type_obj
    .const 'Sub' $P6075 = "529_1303603603.711" 
    $P6074."add_method"(type_obj, "args", $P6075)
    get_how $P6076, type_obj
    .const 'Sub' $P6077 = "530_1303603603.711" 
    $P6076."add_method"(type_obj, "arglist", $P6077)
    get_how $P6078, type_obj
    .const 'Sub' $P6079 = "533_1303603603.711" 
    $P6078."add_method"(type_obj, "term:sym<multi_declarator>", $P6079)
    get_how $P6080, type_obj
    .const 'Sub' $P6081 = "534_1303603603.711" 
    $P6080."add_method"(type_obj, "term:sym<value>", $P6081)
    get_how $P6082, type_obj
    .const 'Sub' $P6083 = "535_1303603603.711" 
    $P6082."add_method"(type_obj, "circumfix:sym<( )>", $P6083)
    get_how $P6084, type_obj
    .const 'Sub' $P6085 = "536_1303603603.711" 
    $P6084."add_method"(type_obj, "circumfix:sym<[ ]>", $P6085)
    get_how $P6086, type_obj
    .const 'Sub' $P6087 = "537_1303603603.711" 
    $P6086."add_method"(type_obj, "circumfix:sym<ang>", $P6087)
    get_how $P6088, type_obj
    .const 'Sub' $P6089 = "538_1303603603.711" 
    $P6088."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P6089)
    get_how $P6090, type_obj
    .const 'Sub' $P6091 = "539_1303603603.711" 
    $P6090."add_method"(type_obj, "circumfix:sym<{ }>", $P6091)
    get_how $P6092, type_obj
    .const 'Sub' $P6093 = "541_1303603603.711" 
    $P6092."add_method"(type_obj, "circumfix:sym<sigil>", $P6093)
    get_how $P6094, type_obj
    .const 'Sub' $P6095 = "542_1303603603.711" 
    $P6094."add_method"(type_obj, "semilist", $P6095)
    get_how $P6096, type_obj
    .const 'Sub' $P6097 = "543_1303603603.711" 
    $P6096."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P6097)
    get_how $P6098, type_obj
    .const 'Sub' $P6099 = "544_1303603603.711" 
    $P6098."add_method"(type_obj, "postcircumfix:sym<{ }>", $P6099)
    get_how $P6100, type_obj
    .const 'Sub' $P6101 = "545_1303603603.711" 
    $P6100."add_method"(type_obj, "postcircumfix:sym<ang>", $P6101)
    get_how $P6102, type_obj
    .const 'Sub' $P6103 = "546_1303603603.711" 
    $P6102."add_method"(type_obj, "postcircumfix:sym<( )>", $P6103)
    get_how $P6104, type_obj
    .const 'Sub' $P6105 = "547_1303603603.711" 
    $P6104."add_method"(type_obj, "value", $P6105)
    get_how $P6106, type_obj
    .const 'Sub' $P6107 = "548_1303603603.711" 
    $P6106."add_method"(type_obj, "number", $P6107)
    get_how $P6108, type_obj
    .const 'Sub' $P6109 = "549_1303603603.711" 
    $P6108."add_method"(type_obj, "quote:sym<apos>", $P6109)
    get_how $P6110, type_obj
    .const 'Sub' $P6111 = "550_1303603603.711" 
    $P6110."add_method"(type_obj, "quote:sym<dblq>", $P6111)
    get_how $P6112, type_obj
    .const 'Sub' $P6113 = "551_1303603603.711" 
    $P6112."add_method"(type_obj, "quote:sym<qq>", $P6113)
    get_how $P6114, type_obj
    .const 'Sub' $P6115 = "552_1303603603.711" 
    $P6114."add_method"(type_obj, "quote:sym<q>", $P6115)
    get_how $P6116, type_obj
    .const 'Sub' $P6117 = "553_1303603603.711" 
    $P6116."add_method"(type_obj, "quote:sym<Q>", $P6117)
    get_how $P6118, type_obj
    .const 'Sub' $P6119 = "554_1303603603.711" 
    $P6118."add_method"(type_obj, "quote:sym<Q:PIR>", $P6119)
    get_how $P6120, type_obj
    .const 'Sub' $P6121 = "555_1303603603.711" 
    $P6120."add_method"(type_obj, "quote:sym</ />", $P6121)
    get_how $P6122, type_obj
    .const 'Sub' $P6123 = "556_1303603603.711" 
    $P6122."add_method"(type_obj, "quote_escape:sym<$>", $P6123)
    get_how $P6124, type_obj
    .const 'Sub' $P6125 = "557_1303603603.711" 
    $P6124."add_method"(type_obj, "quote_escape:sym<{ }>", $P6125)
    get_how $P6126, type_obj
    .const 'Sub' $P6127 = "558_1303603603.711" 
    $P6126."add_method"(type_obj, "quote_escape:sym<esc>", $P6127)
    get_how $P6128, type_obj
    .const 'Sub' $P6129 = "559_1303603603.711" 
    $P6128."add_method"(type_obj, "postfix:sym<.>", $P6129)
    get_how $P6130, type_obj
    .const 'Sub' $P6131 = "560_1303603603.711" 
    $P6130."add_method"(type_obj, "postfix:sym<++>", $P6131)
    get_how $P6132, type_obj
    .const 'Sub' $P6133 = "561_1303603603.711" 
    $P6132."add_method"(type_obj, "postfix:sym<-->", $P6133)
    get_how $P6134, type_obj
    .const 'Sub' $P6135 = "562_1303603603.711" 
    $P6134."add_method"(type_obj, "prefix:sym<make>", $P6135)
    get_how $P6136, type_obj
    .const 'Sub' $P6137 = "563_1303603603.711" 
    $P6136."add_method"(type_obj, "term:sym<next>", $P6137)
    get_how $P6138, type_obj
    .const 'Sub' $P6139 = "564_1303603603.711" 
    $P6138."add_method"(type_obj, "term:sym<last>", $P6139)
    get_how $P6140, type_obj
    .const 'Sub' $P6141 = "565_1303603603.711" 
    $P6140."add_method"(type_obj, "term:sym<redo>", $P6141)
    get_how $P6142, type_obj
    .const 'Sub' $P6143 = "566_1303603603.711" 
    $P6142."add_method"(type_obj, "infix:sym<~~>", $P6143)
    get_how $P6144, type_obj
    get_hll_global $P6145, ["HLL"], "Actions"
    $P6144."add_parent"(type_obj, $P6145)
    get_how $P6146, type_obj
    $P6147 = $P6146."compose"(type_obj)
    .return ($P6147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2601
.annotate 'line', 774
    .lex "$xblock", param_2601
.annotate 'line', 775
    find_lex $P2602, "$xblock"
    unless_null $P2602, vivify_1462
    $P2602 = root_new ['parrot';'ResizablePMCArray']
  vivify_1462:
    set $P2603, $P2602[1]
    unless_null $P2603, vivify_1463
    new $P2603, "Undef"
  vivify_1463:
    $P2604 = "block_immediate"($P2603)
    find_lex $P2605, "$xblock"
    unless_null $P2605, vivify_1464
    $P2605 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2605
  vivify_1464:
    set $P2605[1], $P2604
    find_lex $P2606, "$xblock"
    unless_null $P2606, vivify_1465
    new $P2606, "Undef"
  vivify_1465:
.annotate 'line', 774
    .return ($P2606)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2609
.annotate 'line', 779
    .const 'Sub' $P2619 = "409_1303603603.711" 
    capture_lex $P2619
    .lex "$block", param_2609
.annotate 'line', 780
    find_lex $P2610, "$block"
    unless_null $P2610, vivify_1466
    new $P2610, "Undef"
  vivify_1466:
    $P2610."blocktype"("immediate")
.annotate 'line', 781
    find_lex $P2614, "$block"
    unless_null $P2614, vivify_1467
    new $P2614, "Undef"
  vivify_1467:
    $P2615 = $P2614."symtable"()
    unless $P2615, unless_2613
    set $P2612, $P2615
    goto unless_2613_end
  unless_2613:
    find_lex $P2616, "$block"
    unless_null $P2616, vivify_1468
    new $P2616, "Undef"
  vivify_1468:
    $P2617 = $P2616."handlers"()
    set $P2612, $P2617
  unless_2613_end:
    if $P2612, unless_2611_end
    .const 'Sub' $P2619 = "409_1303603603.711" 
    capture_lex $P2619
    $P2619()
  unless_2611_end:
    find_lex $P2639, "$block"
    unless_null $P2639, vivify_1475
    new $P2639, "Undef"
  vivify_1475:
.annotate 'line', 779
    .return ($P2639)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2618"  :anon :subid("409_1303603603.711") :outer("408_1303603603.711")
.annotate 'line', 781
    .const 'Sub' $P2630 = "410_1303603603.711" 
    capture_lex $P2630
.annotate 'line', 782
    new $P2620, "Undef"
    .lex "$stmts", $P2620
    get_hll_global $P2621, ["PAST"], "Stmts"
    find_lex $P2622, "$block"
    unless_null $P2622, vivify_1469
    new $P2622, "Undef"
  vivify_1469:
    $P2623 = $P2621."new"($P2622 :named("node"))
    store_lex "$stmts", $P2623
.annotate 'line', 783
    find_lex $P2625, "$block"
    unless_null $P2625, vivify_1470
    new $P2625, "Undef"
  vivify_1470:
    $P2626 = $P2625."list"()
    defined $I2627, $P2626
    unless $I2627, for_undef_1471
    iter $P2624, $P2626
    new $P2636, 'ExceptionHandler'
    set_label $P2636, loop2635_handler
    $P2636."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2636
  loop2635_test:
    unless $P2624, loop2635_done
    shift $P2628, $P2624
  loop2635_redo:
    .const 'Sub' $P2630 = "410_1303603603.711" 
    capture_lex $P2630
    $P2630($P2628)
  loop2635_next:
    goto loop2635_test
  loop2635_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2637, exception, 'type'
    eq $P2637, .CONTROL_LOOP_NEXT, loop2635_next
    eq $P2637, .CONTROL_LOOP_REDO, loop2635_redo
  loop2635_done:
    pop_eh 
  for_undef_1471:
.annotate 'line', 784
    find_lex $P2638, "$stmts"
    unless_null $P2638, vivify_1474
    new $P2638, "Undef"
  vivify_1474:
    store_lex "$block", $P2638
.annotate 'line', 781
    .return ($P2638)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2629"  :anon :subid("410_1303603603.711") :outer("409_1303603603.711")
    .param pmc param_2631
.annotate 'line', 783
    .lex "$_", param_2631
    find_lex $P2632, "$stmts"
    unless_null $P2632, vivify_1472
    new $P2632, "Undef"
  vivify_1472:
    find_lex $P2633, "$_"
    unless_null $P2633, vivify_1473
    new $P2633, "Undef"
  vivify_1473:
    $P2634 = $P2632."push"($P2633)
    .return ($P2634)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2642
.annotate 'line', 789
    .lex "$sigil", param_2642
.annotate 'line', 790
    find_lex $P2645, "$sigil"
    unless_null $P2645, vivify_1476
    new $P2645, "Undef"
  vivify_1476:
    set $S2646, $P2645
    iseq $I2647, $S2646, "%"
    if $I2647, if_2644
.annotate 'line', 792
    find_lex $P2652, "$sigil"
    unless_null $P2652, vivify_1477
    new $P2652, "Undef"
  vivify_1477:
    set $S2653, $P2652
    iseq $I2654, $S2653, "@"
    if $I2654, if_2651
    new $P2657, "String"
    assign $P2657, "Undef"
    set $P2650, $P2657
    goto if_2651_end
  if_2651:
.annotate 'line', 793
    get_hll_global $P2655, ["PAST"], "Op"
    $P2656 = $P2655."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2650, $P2656
  if_2651_end:
    set $P2643, $P2650
.annotate 'line', 790
    goto if_2644_end
  if_2644:
.annotate 'line', 791
    get_hll_global $P2648, ["PAST"], "Op"
    $P2649 = $P2648."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2643, $P2649
  if_2644_end:
.annotate 'line', 789
    .return ($P2643)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2660
.annotate 'line', 808
    .lex "$ast", param_2660
.annotate 'line', 809
    get_hll_global $P2663, ["PAST"], "Op"
    find_lex $P2664, "$ast"
    unless_null $P2664, vivify_1478
    new $P2664, "Undef"
  vivify_1478:
    $P2665 = $P2663."ACCEPTS"($P2664)
    if $P2665, if_2662
.annotate 'line', 811
    find_lex $P2669, "$ast"
    unless_null $P2669, vivify_1479
    new $P2669, "Undef"
  vivify_1479:
    $P2670 = $P2669."value"()
    set $P2661, $P2670
.annotate 'line', 809
    goto if_2662_end
  if_2662:
.annotate 'line', 810
    find_lex $P2666, "$ast"
    unless_null $P2666, vivify_1480
    new $P2666, "Undef"
  vivify_1480:
    $P2667 = $P2666."list"()
    join $S2668, " ", $P2667
    new $P2661, 'String'
    set $P2661, $S2668
  if_2662_end:
.annotate 'line', 808
    .return ($P2661)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("413_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2673
    .param pmc param_2674
.annotate 'line', 1056
    .lex "$/", param_2673
    .lex "$block", param_2674
.annotate 'line', 1057
    find_lex $P2676, "$?PACKAGE"
    get_who $P2677, $P2676
    set $P2678, $P2677["@BLOCK"]
    unless_null $P2678, vivify_1481
    $P2678 = root_new ['parrot';'ResizablePMCArray']
  vivify_1481:
    set $P2679, $P2678[0]
    unless_null $P2679, vivify_1482
    new $P2679, "Undef"
  vivify_1482:
    $P2680 = $P2679."handlers"()
    if $P2680, unless_2675_end
.annotate 'line', 1058
    find_lex $P2681, "$?PACKAGE"
    get_who $P2682, $P2681
    set $P2683, $P2682["@BLOCK"]
    unless_null $P2683, vivify_1483
    $P2683 = root_new ['parrot';'ResizablePMCArray']
  vivify_1483:
    set $P2684, $P2683[0]
    unless_null $P2684, vivify_1484
    new $P2684, "Undef"
  vivify_1484:
    new $P2685, "ResizablePMCArray"
    $P2684."handlers"($P2685)
  unless_2675_end:
.annotate 'line', 1060
    find_lex $P2687, "$block"
    unless_null $P2687, vivify_1485
    new $P2687, "Undef"
  vivify_1485:
    $P2688 = $P2687."arity"()
    if $P2688, unless_2686_end
.annotate 'line', 1061
    find_lex $P2689, "$block"
    unless_null $P2689, vivify_1486
    new $P2689, "Undef"
  vivify_1486:
.annotate 'line', 1062
    get_hll_global $P2690, ["PAST"], "Op"
.annotate 'line', 1063
    get_hll_global $P2691, ["PAST"], "Var"
    $P2692 = $P2691."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1064
    get_hll_global $P2693, ["PAST"], "Var"
    $P2694 = $P2693."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2695 = $P2690."new"($P2692, $P2694, "bind" :named("pasttype"))
.annotate 'line', 1062
    $P2689."unshift"($P2695)
.annotate 'line', 1067
    find_lex $P2696, "$block"
    unless_null $P2696, vivify_1487
    new $P2696, "Undef"
  vivify_1487:
    get_hll_global $P2697, ["PAST"], "Var"
    $P2698 = $P2697."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2696."unshift"($P2698)
.annotate 'line', 1068
    find_lex $P2699, "$block"
    unless_null $P2699, vivify_1488
    new $P2699, "Undef"
  vivify_1488:
    $P2699."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1069
    find_lex $P2700, "$block"
    unless_null $P2700, vivify_1489
    new $P2700, "Undef"
  vivify_1489:
    $P2700."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1070
    find_lex $P2701, "$block"
    unless_null $P2701, vivify_1490
    new $P2701, "Undef"
  vivify_1490:
    $P2701."arity"(1)
  unless_2686_end:
.annotate 'line', 1072
    find_lex $P2702, "$block"
    unless_null $P2702, vivify_1491
    new $P2702, "Undef"
  vivify_1491:
    $P2702."blocktype"("declaration")
.annotate 'line', 1073
    find_lex $P2703, "$?PACKAGE"
    get_who $P2704, $P2703
    set $P2705, $P2704["@BLOCK"]
    unless_null $P2705, vivify_1492
    $P2705 = root_new ['parrot';'ResizablePMCArray']
  vivify_1492:
    set $P2706, $P2705[0]
    unless_null $P2706, vivify_1493
    new $P2706, "Undef"
  vivify_1493:
    $P2707 = $P2706."handlers"()
.annotate 'line', 1074
    get_hll_global $P2708, ["PAST"], "Control"
    find_lex $P2709, "$/"
    unless_null $P2709, vivify_1494
    new $P2709, "Undef"
  vivify_1494:
.annotate 'line', 1076
    get_hll_global $P2710, ["PAST"], "Stmts"
.annotate 'line', 1077
    get_hll_global $P2711, ["PAST"], "Op"
    find_lex $P2712, "$block"
    unless_null $P2712, vivify_1495
    new $P2712, "Undef"
  vivify_1495:
.annotate 'line', 1079
    get_hll_global $P2713, ["PAST"], "Var"
    $P2714 = $P2713."new"("register" :named("scope"), "exception" :named("name"))
    $P2715 = $P2711."new"($P2712, $P2714, "call" :named("pasttype"))
.annotate 'line', 1081
    get_hll_global $P2716, ["PAST"], "Op"
.annotate 'line', 1082
    get_hll_global $P2717, ["PAST"], "Var"
.annotate 'line', 1083
    get_hll_global $P2718, ["PAST"], "Var"
    $P2719 = $P2718."new"("register" :named("scope"), "exception" :named("name"))
    $P2720 = $P2717."new"($P2719, "handled", "keyed" :named("scope"))
.annotate 'line', 1082
    $P2721 = $P2716."new"($P2720, 1, "bind" :named("pasttype"))
.annotate 'line', 1081
    $P2722 = $P2710."new"($P2715, $P2721)
.annotate 'line', 1076
    $P2723 = $P2708."new"($P2722, $P2709 :named("node"))
.annotate 'line', 1074
    $P2724 = $P2707."unshift"($P2723)
.annotate 'line', 1056
    .return ($P2724)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("414_1303603603.711") :outer("406_1303603603.711")
.annotate 'line', 1614
    new $P2727, "Undef"
    .lex "$past", $P2727
    find_lex $P2728, "$?PACKAGE"
    get_who $P2729, $P2728
    set $P2730, $P2729["@BLOCK"]
    unless_null $P2730, vivify_1496
    $P2730 = root_new ['parrot';'ResizablePMCArray']
  vivify_1496:
    $P2731 = $P2730."shift"()
    store_lex "$past", $P2731
.annotate 'line', 1615
    find_lex $P2732, "$past"
    unless_null $P2732, vivify_1497
    new $P2732, "Undef"
  vivify_1497:
    $P2732."closure"(1)
.annotate 'line', 1616
    find_lex $P2733, "$past"
    unless_null $P2733, vivify_1498
    new $P2733, "Undef"
  vivify_1498:
    get_hll_global $P2734, ["PAST"], "Op"
    $P2735 = $P2734."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2733."push"($P2735)
    find_lex $P2736, "$past"
    unless_null $P2736, vivify_1499
    new $P2736, "Undef"
  vivify_1499:
.annotate 'line', 1613
    .return ($P2736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("415_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2739
.annotate 'line', 1622
    .const 'Sub' $P2753 = "416_1303603603.711" 
    capture_lex $P2753
    .lex "$routine", param_2739
.annotate 'line', 1626
    new $P2740, "Undef"
    .lex "$types", $P2740
.annotate 'line', 1627
    new $P2741, "Undef"
    .lex "$definednesses", $P2741
.annotate 'line', 1626
    get_hll_global $P2742, ["PAST"], "Op"
    $P2743 = $P2742."new"("list" :named("pasttype"))
    store_lex "$types", $P2743
.annotate 'line', 1627
    get_hll_global $P2744, ["PAST"], "Op"
    $P2745 = $P2744."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2745
.annotate 'line', 1628
    find_lex $P2747, "$routine"
    unless_null $P2747, vivify_1500
    $P2747 = root_new ['parrot';'ResizablePMCArray']
  vivify_1500:
    set $P2748, $P2747[0]
    unless_null $P2748, vivify_1501
    new $P2748, "Undef"
  vivify_1501:
    $P2749 = $P2748."list"()
    defined $I2750, $P2749
    unless $I2750, for_undef_1502
    iter $P2746, $P2749
    new $P2791, 'ExceptionHandler'
    set_label $P2791, loop2790_handler
    $P2791."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2791
  loop2790_test:
    unless $P2746, loop2790_done
    shift $P2751, $P2746
  loop2790_redo:
    .const 'Sub' $P2753 = "416_1303603603.711" 
    capture_lex $P2753
    $P2753($P2751)
  loop2790_next:
    goto loop2790_test
  loop2790_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2792, exception, 'type'
    eq $P2792, .CONTROL_LOOP_NEXT, loop2790_next
    eq $P2792, .CONTROL_LOOP_REDO, loop2790_redo
  loop2790_done:
    pop_eh 
  for_undef_1502:
.annotate 'line', 1635
    find_lex $P2793, "$routine"
    unless_null $P2793, vivify_1512
    new $P2793, "Undef"
  vivify_1512:
    $P2794 = $P2793."loadinit"()
    get_hll_global $P2795, ["PAST"], "Op"
.annotate 'line', 1636
    get_hll_global $P2796, ["PAST"], "Var"
    $P2797 = $P2796."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2798, "$types"
    unless_null $P2798, vivify_1513
    new $P2798, "Undef"
  vivify_1513:
    find_lex $P2799, "$definednesses"
    unless_null $P2799, vivify_1514
    new $P2799, "Undef"
  vivify_1514:
    $P2800 = $P2795."new"($P2797, $P2798, $P2799, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1635
    $P2801 = $P2794."push"($P2800)
.annotate 'line', 1622
    .return ($P2801)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2752"  :anon :subid("416_1303603603.711") :outer("415_1303603603.711")
    .param pmc param_2754
.annotate 'line', 1628
    .lex "$_", param_2754
.annotate 'line', 1629
    get_hll_global $P2759, ["PAST"], "Var"
    find_lex $P2760, "$_"
    unless_null $P2760, vivify_1503
    new $P2760, "Undef"
  vivify_1503:
    $P2761 = $P2759."ACCEPTS"($P2760)
    if $P2761, if_2758
    set $P2757, $P2761
    goto if_2758_end
  if_2758:
    find_lex $P2762, "$_"
    unless_null $P2762, vivify_1504
    new $P2762, "Undef"
  vivify_1504:
    $S2763 = $P2762."scope"()
    iseq $I2764, $S2763, "parameter"
    new $P2757, 'Integer'
    set $P2757, $I2764
  if_2758_end:
    if $P2757, if_2756
    set $P2755, $P2757
    goto if_2756_end
  if_2756:
.annotate 'line', 1630
    find_lex $P2765, "$types"
    unless_null $P2765, vivify_1505
    new $P2765, "Undef"
  vivify_1505:
    find_lex $P2767, "$_"
    unless_null $P2767, vivify_1506
    new $P2767, "Undef"
  vivify_1506:
    $P2768 = $P2767."multitype"()
    set $P2766, $P2768
    defined $I2770, $P2766
    if $I2770, default_2769
    get_hll_global $P2771, ["PAST"], "Op"
    $P2772 = $P2771."new"("null P" :named("pirop"))
    set $P2766, $P2772
  default_2769:
    $P2765."push"($P2766)
.annotate 'line', 1631
    find_lex $P2773, "$definednesses"
    unless_null $P2773, vivify_1507
    new $P2773, "Undef"
  vivify_1507:
    find_lex $P2776, "$_"
    unless_null $P2776, vivify_1508
    $P2776 = root_new ['parrot';'Hash']
  vivify_1508:
    set $P2777, $P2776["definedness"]
    unless_null $P2777, vivify_1509
    new $P2777, "Undef"
  vivify_1509:
    set $S2778, $P2777
    iseq $I2779, $S2778, "D"
    if $I2779, if_2775
.annotate 'line', 1632
    find_lex $P2783, "$_"
    unless_null $P2783, vivify_1510
    $P2783 = root_new ['parrot';'Hash']
  vivify_1510:
    set $P2784, $P2783["definedness"]
    unless_null $P2784, vivify_1511
    new $P2784, "Undef"
  vivify_1511:
    set $S2785, $P2784
    iseq $I2786, $S2785, "U"
    if $I2786, if_2782
    new $P2788, "Integer"
    assign $P2788, 0
    set $P2781, $P2788
    goto if_2782_end
  if_2782:
    new $P2787, "Integer"
    assign $P2787, 2
    set $P2781, $P2787
  if_2782_end:
    set $P2774, $P2781
.annotate 'line', 1631
    goto if_2775_end
  if_2775:
    new $P2780, "Integer"
    assign $P2780, 1
    set $P2774, $P2780
  if_2775_end:
    $P2789 = $P2773."push"($P2774)
.annotate 'line', 1629
    set $P2755, $P2789
  if_2756_end:
.annotate 'line', 1628
    .return ($P2755)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("417_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2804
    .param pmc param_2805
.annotate 'line', 2096
    .lex "$/", param_2804
    .lex "$type", param_2805
.annotate 'line', 2097
    find_lex $P2806, "$/"
    get_hll_global $P2807, ["PAST"], "Op"
    find_lex $P2808, "$/"
    unless_null $P2808, vivify_1515
    new $P2808, "Undef"
  vivify_1515:
.annotate 'line', 2101
    get_hll_global $P2809, ["PAST"], "Val"
    find_lex $P2810, "$type"
    unless_null $P2810, vivify_1516
    new $P2810, "Undef"
  vivify_1516:
    $P2811 = $P2809."new"($P2810 :named("value"), "!except_types" :named("returns"))
    $P2812 = $P2807."new"(0, $P2811, $P2808 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2097
    $P2813 = $P2806."!make"($P2812)
.annotate 'line', 2096
    .return ($P2813)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("418_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2818
    .param pmc param_2819
.annotate 'line', 2115
    .const 'Sub' $P2848 = "419_1303603603.711" 
    capture_lex $P2848
    new $P2817, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2817, control_2816
    push_eh $P2817
    .lex "@name", param_2818
    .lex "$/", param_2819
.annotate 'line', 2121
    new $P2820, "Undef"
    .lex "$final_name", $P2820
.annotate 'line', 2122
    new $P2821, "Undef"
    .lex "$lookup", $P2821
.annotate 'line', 2117
    find_lex $P2823, "@name"
    unless_null $P2823, vivify_1517
    $P2823 = root_new ['parrot';'ResizablePMCArray']
  vivify_1517:
    set $N2824, $P2823
    iseq $I2825, $N2824, 0.0
    unless $I2825, if_2822_end
    find_lex $P2826, "$/"
    unless_null $P2826, vivify_1518
    new $P2826, "Undef"
  vivify_1518:
    $P2827 = $P2826."CURSOR"()
    $P2827."panic"("Cannot compile empty name")
  if_2822_end:
.annotate 'line', 2121
    find_lex $P2828, "@name"
    unless_null $P2828, vivify_1519
    $P2828 = root_new ['parrot';'ResizablePMCArray']
  vivify_1519:
    $P2829 = $P2828."pop"()
    store_lex "$final_name", $P2829
.annotate 'line', 2122
    get_hll_global $P2830, ["PAST"], "Var"
    find_lex $P2831, "$final_name"
    unless_null $P2831, vivify_1520
    new $P2831, "Undef"
  vivify_1520:
    set $S2832, $P2831
    $P2833 = $P2830."new"($S2832, "keyed" :named("scope"))
    store_lex "$lookup", $P2833
.annotate 'line', 2126
    find_lex $P2835, "@name"
    unless_null $P2835, vivify_1521
    $P2835 = root_new ['parrot';'ResizablePMCArray']
  vivify_1521:
    set $N2836, $P2835
    iseq $I2837, $N2836, 0.0
    if $I2837, if_2834
.annotate 'line', 2135
    find_lex $P2844, "@name"
    unless_null $P2844, vivify_1522
    $P2844 = root_new ['parrot';'ResizablePMCArray']
  vivify_1522:
    set $P2845, $P2844[0]
    unless_null $P2845, vivify_1523
    new $P2845, "Undef"
  vivify_1523:
    $P2846 = "is_lexical"($P2845)
    if $P2846, if_2843
.annotate 'line', 2149
    find_lex $P2874, "$lookup"
    unless_null $P2874, vivify_1524
    new $P2874, "Undef"
  vivify_1524:
    get_hll_global $P2875, ["PAST"], "Op"
.annotate 'line', 2151
    get_hll_global $P2876, ["PAST"], "Var"
    find_lex $P2877, "@name"
    unless_null $P2877, vivify_1525
    $P2877 = root_new ['parrot';'ResizablePMCArray']
  vivify_1525:
    $P2878 = $P2877."pop"()
    find_lex $P2879, "@name"
    unless_null $P2879, vivify_1526
    $P2879 = root_new ['parrot';'ResizablePMCArray']
  vivify_1526:
    $P2880 = $P2876."new"($P2878 :named("name"), $P2879 :named("namespace"), "package" :named("scope"))
    $P2881 = $P2875."new"($P2880, "get_who PP" :named("pirop"))
.annotate 'line', 2149
    $P2874."unshift"($P2881)
.annotate 'line', 2144
    goto if_2843_end
  if_2843:
.annotate 'line', 2135
    .const 'Sub' $P2848 = "419_1303603603.711" 
    capture_lex $P2848
    $P2848()
  if_2843_end:
    goto if_2834_end
  if_2834:
.annotate 'line', 2127
    find_lex $P2838, "$lookup"
    unless_null $P2838, vivify_1534
    new $P2838, "Undef"
  vivify_1534:
    get_hll_global $P2839, ["PAST"], "Op"
.annotate 'line', 2129
    get_hll_global $P2840, ["PAST"], "Var"
    $P2841 = $P2840."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2842 = $P2839."new"($P2841, "get_who PP" :named("pirop"))
.annotate 'line', 2127
    $P2838."unshift"($P2842)
  if_2834_end:
.annotate 'line', 2155
    new $P2882, "Exception"
    set $P2882['type'], .CONTROL_RETURN
    find_lex $P2883, "$lookup"
    unless_null $P2883, vivify_1535
    new $P2883, "Undef"
  vivify_1535:
    setattribute $P2882, 'payload', $P2883
    throw $P2882
.annotate 'line', 2115
    .return ()
  control_2816:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2884, exception, "payload"
    .return ($P2884)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2847"  :anon :subid("419_1303603603.711") :outer("418_1303603603.711")
.annotate 'line', 2135
    .const 'Sub' $P2859 = "420_1303603603.711" 
    capture_lex $P2859
.annotate 'line', 2136
    new $P2849, "Undef"
    .lex "$path", $P2849
    get_hll_global $P2850, ["PAST"], "Var"
    find_lex $P2851, "@name"
    unless_null $P2851, vivify_1527
    $P2851 = root_new ['parrot';'ResizablePMCArray']
  vivify_1527:
    $P2852 = $P2851."shift"()
    $P2853 = $P2850."new"($P2852 :named("name"), "lexical" :named("scope"))
    store_lex "$path", $P2853
.annotate 'line', 2137
    find_lex $P2855, "@name"
    unless_null $P2855, vivify_1528
    $P2855 = root_new ['parrot';'ResizablePMCArray']
  vivify_1528:
    defined $I2856, $P2855
    unless $I2856, for_undef_1529
    iter $P2854, $P2855
    new $P2867, 'ExceptionHandler'
    set_label $P2867, loop2866_handler
    $P2867."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2867
  loop2866_test:
    unless $P2854, loop2866_done
    shift $P2857, $P2854
  loop2866_redo:
    .const 'Sub' $P2859 = "420_1303603603.711" 
    capture_lex $P2859
    $P2859($P2857)
  loop2866_next:
    goto loop2866_test
  loop2866_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2868, exception, 'type'
    eq $P2868, .CONTROL_LOOP_NEXT, loop2866_next
    eq $P2868, .CONTROL_LOOP_REDO, loop2866_redo
  loop2866_done:
    pop_eh 
  for_undef_1529:
.annotate 'line', 2142
    find_lex $P2869, "$lookup"
    unless_null $P2869, vivify_1532
    new $P2869, "Undef"
  vivify_1532:
    get_hll_global $P2870, ["PAST"], "Op"
    find_lex $P2871, "$path"
    unless_null $P2871, vivify_1533
    new $P2871, "Undef"
  vivify_1533:
    $P2872 = $P2870."new"($P2871, "get_who PP" :named("pirop"))
    $P2873 = $P2869."unshift"($P2872)
.annotate 'line', 2135
    .return ($P2873)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2858"  :anon :subid("420_1303603603.711") :outer("419_1303603603.711")
    .param pmc param_2860
.annotate 'line', 2137
    .lex "$_", param_2860
.annotate 'line', 2138
    get_hll_global $P2861, ["PAST"], "Op"
    find_lex $P2862, "$path"
    unless_null $P2862, vivify_1530
    new $P2862, "Undef"
  vivify_1530:
.annotate 'line', 2140
    find_lex $P2863, "$_"
    unless_null $P2863, vivify_1531
    new $P2863, "Undef"
  vivify_1531:
    set $S2864, $P2863
    $P2865 = $P2861."new"($P2862, $S2864, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2138
    store_lex "$path", $P2865
.annotate 'line', 2137
    .return ($P2865)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("421_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2887
.annotate 'line', 2160
    .lex "$name", param_2887
.annotate 'line', 2161
    find_lex $P2888, "$name"
    unless_null $P2888, vivify_1536
    new $P2888, "Undef"
  vivify_1536:
    $P2889 = "is_scope"($P2888, "lexical")
.annotate 'line', 2160
    .return ($P2889)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("422_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2892
.annotate 'line', 2166
    .lex "$name", param_2892
.annotate 'line', 2167
    find_lex $P2893, "$name"
    unless_null $P2893, vivify_1537
    new $P2893, "Undef"
  vivify_1537:
    $P2894 = "is_scope"($P2893, "package")
.annotate 'line', 2166
    .return ($P2894)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("423_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2899
    .param pmc param_2900
.annotate 'line', 2172
    .const 'Sub' $P2908 = "424_1303603603.711" 
    capture_lex $P2908
    new $P2898, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2898, control_2897
    push_eh $P2898
    .lex "$name", param_2899
    .lex "$wanted_scope", param_2900
.annotate 'line', 2173
    find_lex $P2902, "$?PACKAGE"
    get_who $P2903, $P2902
    set $P2904, $P2903["@BLOCK"]
    unless_null $P2904, vivify_1538
    $P2904 = root_new ['parrot';'ResizablePMCArray']
  vivify_1538:
    defined $I2905, $P2904
    unless $I2905, for_undef_1539
    iter $P2901, $P2904
    new $P2927, 'ExceptionHandler'
    set_label $P2927, loop2926_handler
    $P2927."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2927
  loop2926_test:
    unless $P2901, loop2926_done
    shift $P2906, $P2901
  loop2926_redo:
    .const 'Sub' $P2908 = "424_1303603603.711" 
    capture_lex $P2908
    $P2908($P2906)
  loop2926_next:
    goto loop2926_test
  loop2926_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2928, exception, 'type'
    eq $P2928, .CONTROL_LOOP_NEXT, loop2926_next
    eq $P2928, .CONTROL_LOOP_REDO, loop2926_redo
  loop2926_done:
    pop_eh 
  for_undef_1539:
.annotate 'line', 2172
    .return (0)
  control_2897:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2929, exception, "payload"
    .return ($P2929)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2907"  :anon :subid("424_1303603603.711") :outer("423_1303603603.711")
    .param pmc param_2910
.annotate 'line', 2174
    $P2909 = root_new ['parrot';'Hash']
    .lex "%sym", $P2909
    .lex "$_", param_2910
    find_lex $P2911, "$_"
    unless_null $P2911, vivify_1540
    new $P2911, "Undef"
  vivify_1540:
    find_lex $P2912, "$name"
    unless_null $P2912, vivify_1541
    new $P2912, "Undef"
  vivify_1541:
    $P2913 = $P2911."symbol"($P2912)
    store_lex "%sym", $P2913
.annotate 'line', 2175
    find_lex $P2916, "%sym"
    unless_null $P2916, vivify_1542
    $P2916 = root_new ['parrot';'Hash']
  vivify_1542:
    set $N2917, $P2916
    if $N2917, if_2915
    new $P2914, 'Float'
    set $P2914, $N2917
    goto if_2915_end
  if_2915:
.annotate 'line', 2176
    new $P2918, "Exception"
    set $P2918['type'], .CONTROL_RETURN
    find_lex $P2919, "%sym"
    unless_null $P2919, vivify_1543
    $P2919 = root_new ['parrot';'Hash']
  vivify_1543:
    set $P2920, $P2919["scope"]
    unless_null $P2920, vivify_1544
    new $P2920, "Undef"
  vivify_1544:
    set $S2921, $P2920
    find_lex $P2922, "$wanted_scope"
    unless_null $P2922, vivify_1545
    new $P2922, "Undef"
  vivify_1545:
    set $S2923, $P2922
    iseq $I2924, $S2921, $S2923
    new $P2925, 'Integer'
    set $P2925, $I2924
    setattribute $P2918, 'payload', $P2925
    throw $P2918
  if_2915_end:
.annotate 'line', 2173
    .return ($P2914)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("425_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_2934
    .param pmc param_2935
.annotate 'line', 2185
    .const 'Sub' $P3027 = "430_1303603603.711" 
    capture_lex $P3027
    .const 'Sub' $P2987 = "428_1303603603.711" 
    capture_lex $P2987
    .const 'Sub' $P2947 = "426_1303603603.711" 
    capture_lex $P2947
    new $P2933, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2933, control_2932
    push_eh $P2933
    .lex "@name", param_2934
    .lex "$/", param_2935
.annotate 'line', 2209
    new $P2936, "Undef"
    .lex "$result", $P2936
.annotate 'line', 2187
    find_lex $P2938, "@name"
    unless_null $P2938, vivify_1546
    $P2938 = root_new ['parrot';'ResizablePMCArray']
  vivify_1546:
    set $N2939, $P2938
    if $N2939, unless_2937_end
    find_lex $P2940, "$/"
    unless_null $P2940, vivify_1547
    new $P2940, "Undef"
  vivify_1547:
    $P2941 = $P2940."CURSOR"()
    $P2941."panic"("Cannot look up empty name")
  unless_2937_end:
.annotate 'line', 2191
    find_lex $P2943, "@name"
    unless_null $P2943, vivify_1548
    $P2943 = root_new ['parrot';'ResizablePMCArray']
  vivify_1548:
    set $N2944, $P2943
    iseq $I2945, $N2944, 1.0
    unless $I2945, if_2942_end
    .const 'Sub' $P2947 = "426_1303603603.711" 
    capture_lex $P2947
    $P2947()
  if_2942_end:
.annotate 'line', 2209
    find_dynamic_lex $P2981, "$*GLOBALish"
    unless_null $P2981, vivify_1560
    get_hll_global $P2981, "$GLOBALish"
    unless_null $P2981, vivify_1561
    die "Contextual $*GLOBALish not found"
  vivify_1561:
  vivify_1560:
    store_lex "$result", $P2981
.annotate 'line', 2210
    find_lex $P2983, "@name"
    unless_null $P2983, vivify_1562
    $P2983 = root_new ['parrot';'ResizablePMCArray']
  vivify_1562:
    set $N2984, $P2983
    isge $I2985, $N2984, 2.0
    unless $I2985, if_2982_end
    .const 'Sub' $P2987 = "428_1303603603.711" 
    capture_lex $P2987
    $P2987()
  if_2982_end:
.annotate 'line', 2228
    find_lex $P3023, "@name"
    unless_null $P3023, vivify_1575
    $P3023 = root_new ['parrot';'ResizablePMCArray']
  vivify_1575:
    defined $I3024, $P3023
    unless $I3024, for_undef_1576
    iter $P3022, $P3023
    new $P3045, 'ExceptionHandler'
    set_label $P3045, loop3044_handler
    $P3045."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3045
  loop3044_test:
    unless $P3022, loop3044_done
    shift $P3025, $P3022
  loop3044_redo:
    .const 'Sub' $P3027 = "430_1303603603.711" 
    capture_lex $P3027
    $P3027($P3025)
  loop3044_next:
    goto loop3044_test
  loop3044_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3046, exception, 'type'
    eq $P3046, .CONTROL_LOOP_NEXT, loop3044_next
    eq $P3046, .CONTROL_LOOP_REDO, loop3044_redo
  loop3044_done:
    pop_eh 
  for_undef_1576:
    find_lex $P3047, "$result"
    unless_null $P3047, vivify_1583
    new $P3047, "Undef"
  vivify_1583:
.annotate 'line', 2185
    .return ($P3047)
  control_2932:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3048, exception, "payload"
    .return ($P3048)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2946"  :anon :subid("426_1303603603.711") :outer("425_1303603603.711")
.annotate 'line', 2191
    .const 'Sub' $P2958 = "427_1303603603.711" 
    capture_lex $P2958
.annotate 'line', 2192
    new $P2948, "Undef"
    .lex "$final_name", $P2948
    find_lex $P2949, "@name"
    unless_null $P2949, vivify_1549
    $P2949 = root_new ['parrot';'ResizablePMCArray']
  vivify_1549:
    set $P2950, $P2949[0]
    unless_null $P2950, vivify_1550
    new $P2950, "Undef"
  vivify_1550:
    store_lex "$final_name", $P2950
.annotate 'line', 2193
    find_lex $P2952, "$?PACKAGE"
    get_who $P2953, $P2952
    set $P2954, $P2953["@BLOCK"]
    unless_null $P2954, vivify_1551
    $P2954 = root_new ['parrot';'ResizablePMCArray']
  vivify_1551:
    defined $I2955, $P2954
    unless $I2955, for_undef_1552
    iter $P2951, $P2954
    new $P2979, 'ExceptionHandler'
    set_label $P2979, loop2978_handler
    $P2979."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2979
  loop2978_test:
    unless $P2951, loop2978_done
    shift $P2956, $P2951
  loop2978_redo:
    .const 'Sub' $P2958 = "427_1303603603.711" 
    capture_lex $P2958
    $P2958($P2956)
  loop2978_next:
    goto loop2978_test
  loop2978_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2980, exception, 'type'
    eq $P2980, .CONTROL_LOOP_NEXT, loop2978_next
    eq $P2980, .CONTROL_LOOP_REDO, loop2978_redo
  loop2978_done:
    pop_eh 
  for_undef_1552:
.annotate 'line', 2191
    .return ($P2951)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2957"  :anon :subid("427_1303603603.711") :outer("426_1303603603.711")
    .param pmc param_2960
.annotate 'line', 2194
    $P2959 = root_new ['parrot';'Hash']
    .lex "%sym", $P2959
    .lex "$_", param_2960
    find_lex $P2961, "$_"
    unless_null $P2961, vivify_1553
    new $P2961, "Undef"
  vivify_1553:
    find_lex $P2962, "$final_name"
    unless_null $P2962, vivify_1554
    new $P2962, "Undef"
  vivify_1554:
    $P2963 = $P2961."symbol"($P2962)
    store_lex "%sym", $P2963
.annotate 'line', 2195
    find_lex $P2966, "%sym"
    unless_null $P2966, vivify_1555
    $P2966 = root_new ['parrot';'Hash']
  vivify_1555:
    set $N2967, $P2966
    if $N2967, if_2965
    new $P2964, 'Float'
    set $P2964, $N2967
    goto if_2965_end
  if_2965:
.annotate 'line', 2196
    find_lex $P2970, "%sym"
    unless_null $P2970, vivify_1556
    $P2970 = root_new ['parrot';'Hash']
  vivify_1556:
    exists $I2971, $P2970["value"]
    if $I2971, if_2969
.annotate 'line', 2200
    new $P2975, 'String'
    set $P2975, "No compile-time value for "
    find_lex $P2976, "$final_name"
    unless_null $P2976, vivify_1557
    new $P2976, "Undef"
  vivify_1557:
    concat $P2977, $P2975, $P2976
    die $P2977
.annotate 'line', 2199
    goto if_2969_end
  if_2969:
.annotate 'line', 2197
    new $P2972, "Exception"
    set $P2972['type'], .CONTROL_RETURN
    find_lex $P2973, "%sym"
    unless_null $P2973, vivify_1558
    $P2973 = root_new ['parrot';'Hash']
  vivify_1558:
    set $P2974, $P2973["value"]
    unless_null $P2974, vivify_1559
    new $P2974, "Undef"
  vivify_1559:
    setattribute $P2972, 'payload', $P2974
    throw $P2972
  if_2969_end:
.annotate 'line', 2195
    set $P2964, $P2968
  if_2965_end:
.annotate 'line', 2193
    .return ($P2964)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2986"  :anon :subid("428_1303603603.711") :outer("425_1303603603.711")
.annotate 'line', 2210
    .const 'Sub' $P2998 = "429_1303603603.711" 
    capture_lex $P2998
.annotate 'line', 2211
    new $P2988, "Undef"
    .lex "$first", $P2988
    find_lex $P2989, "@name"
    unless_null $P2989, vivify_1563
    $P2989 = root_new ['parrot';'ResizablePMCArray']
  vivify_1563:
    set $P2990, $P2989[0]
    unless_null $P2990, vivify_1564
    new $P2990, "Undef"
  vivify_1564:
    store_lex "$first", $P2990
.annotate 'line', 2212
    find_lex $P2992, "$?PACKAGE"
    get_who $P2993, $P2992
    set $P2994, $P2993["@BLOCK"]
    unless_null $P2994, vivify_1565
    $P2994 = root_new ['parrot';'ResizablePMCArray']
  vivify_1565:
    defined $I2995, $P2994
    unless $I2995, for_undef_1566
    iter $P2991, $P2994
    new $P3020, 'ExceptionHandler'
    set_label $P3020, loop3019_handler
    $P3020."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3020
  loop3019_test:
    unless $P2991, loop3019_done
    shift $P2996, $P2991
  loop3019_redo:
    .const 'Sub' $P2998 = "429_1303603603.711" 
    capture_lex $P2998
    $P2998($P2996)
  loop3019_next:
    goto loop3019_test
  loop3019_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3021, exception, 'type'
    eq $P3021, .CONTROL_LOOP_NEXT, loop3019_next
    eq $P3021, .CONTROL_LOOP_REDO, loop3019_redo
  loop3019_done:
    pop_eh 
  for_undef_1566:
.annotate 'line', 2210
    .return ($P2991)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2997"  :anon :subid("429_1303603603.711") :outer("428_1303603603.711")
    .param pmc param_3000
.annotate 'line', 2213
    $P2999 = root_new ['parrot';'Hash']
    .lex "%sym", $P2999
    .lex "$_", param_3000
    find_lex $P3001, "$_"
    unless_null $P3001, vivify_1567
    new $P3001, "Undef"
  vivify_1567:
    find_lex $P3002, "$first"
    unless_null $P3002, vivify_1568
    new $P3002, "Undef"
  vivify_1568:
    $P3003 = $P3001."symbol"($P3002)
    store_lex "%sym", $P3003
.annotate 'line', 2214
    find_lex $P3006, "%sym"
    unless_null $P3006, vivify_1569
    $P3006 = root_new ['parrot';'Hash']
  vivify_1569:
    set $N3007, $P3006
    if $N3007, if_3005
    new $P3004, 'Float'
    set $P3004, $N3007
    goto if_3005_end
  if_3005:
.annotate 'line', 2215
    find_lex $P3010, "%sym"
    unless_null $P3010, vivify_1570
    $P3010 = root_new ['parrot';'Hash']
  vivify_1570:
    exists $I3011, $P3010["value"]
    if $I3011, if_3009
.annotate 'line', 2221
    new $P3016, 'String'
    set $P3016, "No compile-time value for "
    find_lex $P3017, "$first"
    unless_null $P3017, vivify_1571
    new $P3017, "Undef"
  vivify_1571:
    concat $P3018, $P3016, $P3017
    die $P3018
.annotate 'line', 2220
    goto if_3009_end
  if_3009:
.annotate 'line', 2216
    find_lex $P3012, "%sym"
    unless_null $P3012, vivify_1572
    $P3012 = root_new ['parrot';'Hash']
  vivify_1572:
    set $P3013, $P3012["value"]
    unless_null $P3013, vivify_1573
    new $P3013, "Undef"
  vivify_1573:
    store_lex "$result", $P3013
.annotate 'line', 2217
    find_lex $P3014, "@name"
    unless_null $P3014, vivify_1574
    $P3014 = root_new ['parrot';'ResizablePMCArray']
  vivify_1574:
    $P3014."shift"()
.annotate 'line', 2218
    set $I3015, .CONTROL_LOOP_LAST
    die 0, $I3015
  if_3009_end:
.annotate 'line', 2214
    set $P3004, $P3008
  if_3005_end:
.annotate 'line', 2212
    .return ($P3004)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3026"  :anon :subid("430_1303603603.711") :outer("425_1303603603.711")
    .param pmc param_3028
.annotate 'line', 2228
    .lex "$_", param_3028
.annotate 'line', 2229
    find_lex $P3033, "$_"
    unless_null $P3033, vivify_1577
    new $P3033, "Undef"
  vivify_1577:
    set $S3034, $P3033
    find_lex $P3031, "$result"
    unless_null $P3031, vivify_1578
    new $P3031, "Undef"
  vivify_1578:
    get_who $P3032, $P3031
    exists $I3035, $P3032[$S3034]
    if $I3035, if_3030
.annotate 'line', 2233
    new $P3040, "String"
    assign $P3040, "Could not locate compile-time value for symbol "
.annotate 'line', 2234
    find_lex $P3041, "@name"
    unless_null $P3041, vivify_1579
    $P3041 = root_new ['parrot';'ResizablePMCArray']
  vivify_1579:
    join $S3042, "::", $P3041
    concat $P3043, $P3040, $S3042
.annotate 'line', 2233
    die $P3043
.annotate 'line', 2232
    goto if_3030_end
  if_3030:
.annotate 'line', 2230
    find_lex $P3036, "$_"
    unless_null $P3036, vivify_1580
    new $P3036, "Undef"
  vivify_1580:
    find_lex $P3037, "$result"
    unless_null $P3037, vivify_1581
    new $P3037, "Undef"
  vivify_1581:
    get_who $P3038, $P3037
    set $P3039, $P3038[$P3036]
    unless_null $P3039, vivify_1582
    new $P3039, "Undef"
  vivify_1582:
    store_lex "$result", $P3039
.annotate 'line', 2229
    set $P3029, $P3039
  if_3030_end:
.annotate 'line', 2228
    .return ($P3029)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("431_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3059
    .param pmc param_3060
.annotate 'line', 798
    .lex "self", param_3059
    .lex "$/", param_3060
    find_lex $P3061, "$/"
    find_lex $P3062, "$/"
    unless_null $P3062, vivify_1584
    $P3062 = root_new ['parrot';'Hash']
  vivify_1584:
    set $P3063, $P3062["comp_unit"]
    unless_null $P3063, vivify_1585
    new $P3063, "Undef"
  vivify_1585:
    $P3064 = $P3063."ast"()
    $P3065 = $P3061."!make"($P3064)
    .return ($P3065)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("432_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3067
    .param pmc param_3068
.annotate 'line', 800
    .lex "self", param_3067
    .lex "$/", param_3068
.annotate 'line', 801
    find_lex $P3069, "$/"
.annotate 'line', 802
    find_lex $P3072, "$/"
    unless_null $P3072, vivify_1586
    $P3072 = root_new ['parrot';'Hash']
  vivify_1586:
    set $P3073, $P3072["colonpair"]
    unless_null $P3073, vivify_1587
    new $P3073, "Undef"
  vivify_1587:
    if $P3073, if_3071
.annotate 'line', 804
    find_lex $P3093, "$/"
    unless_null $P3093, vivify_1588
    new $P3093, "Undef"
  vivify_1588:
    set $S3094, $P3093
    new $P3070, 'String'
    set $P3070, $S3094
.annotate 'line', 802
    goto if_3071_end
  if_3071:
    find_lex $P3074, "$/"
    unless_null $P3074, vivify_1589
    $P3074 = root_new ['parrot';'Hash']
  vivify_1589:
    set $P3075, $P3074["identifier"]
    unless_null $P3075, vivify_1590
    new $P3075, "Undef"
  vivify_1590:
    set $S3076, $P3075
    new $P3077, 'String'
    set $P3077, $S3076
    concat $P3078, $P3077, ":"
    find_lex $P3079, "$/"
    unless_null $P3079, vivify_1591
    $P3079 = root_new ['parrot';'Hash']
  vivify_1591:
    set $P3080, $P3079["colonpair"]
    unless_null $P3080, vivify_1592
    $P3080 = root_new ['parrot';'ResizablePMCArray']
  vivify_1592:
    set $P3081, $P3080[0]
    unless_null $P3081, vivify_1593
    new $P3081, "Undef"
  vivify_1593:
    $P3082 = $P3081."ast"()
    $S3083 = $P3082."named"()
    concat $P3084, $P3078, $S3083
    concat $P3085, $P3084, "<"
.annotate 'line', 803
    find_lex $P3086, "$/"
    unless_null $P3086, vivify_1594
    $P3086 = root_new ['parrot';'Hash']
  vivify_1594:
    set $P3087, $P3086["colonpair"]
    unless_null $P3087, vivify_1595
    $P3087 = root_new ['parrot';'ResizablePMCArray']
  vivify_1595:
    set $P3088, $P3087[0]
    unless_null $P3088, vivify_1596
    new $P3088, "Undef"
  vivify_1596:
    $P3089 = $P3088."ast"()
    $S3090 = "colonpair_str"($P3089)
    concat $P3091, $P3085, $S3090
    concat $P3092, $P3091, ">"
    set $P3070, $P3092
  if_3071_end:
.annotate 'line', 802
    $P3095 = $P3069."!make"($P3070)
.annotate 'line', 800
    .return ($P3095)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("433_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3098
    .param pmc param_3099
.annotate 'line', 814
    .lex "self", param_3098
    .lex "$/", param_3099
.annotate 'line', 815
    new $P3100, "Undef"
    .lex "$mainline", $P3100
.annotate 'line', 816
    new $P3101, "Undef"
    .lex "$unit", $P3101
.annotate 'line', 815
    find_lex $P3102, "$/"
    unless_null $P3102, vivify_1597
    $P3102 = root_new ['parrot';'Hash']
  vivify_1597:
    set $P3103, $P3102["statementlist"]
    unless_null $P3103, vivify_1598
    new $P3103, "Undef"
  vivify_1598:
    $P3104 = $P3103."ast"()
    store_lex "$mainline", $P3104
.annotate 'line', 816
    find_lex $P3105, "$?PACKAGE"
    get_who $P3106, $P3105
    set $P3107, $P3106["@BLOCK"]
    unless_null $P3107, vivify_1599
    $P3107 = root_new ['parrot';'ResizablePMCArray']
  vivify_1599:
    $P3108 = $P3107."shift"()
    store_lex "$unit", $P3108
.annotate 'line', 820
    find_lex $P3109, "$unit"
    unless_null $P3109, vivify_1600
    new $P3109, "Undef"
  vivify_1600:
    $P3110 = $P3109."loadinit"()
    find_dynamic_lex $P3111, "$*SC"
    unless_null $P3111, vivify_1601
    get_hll_global $P3111, "$SC"
    unless_null $P3111, vivify_1602
    die "Contextual $*SC not found"
  vivify_1602:
  vivify_1601:
    $P3112 = $P3111."to_past"()
    $P3110."push"($P3112)
.annotate 'line', 826
    find_lex $P3113, "$unit"
    unless_null $P3113, vivify_1603
    new $P3113, "Undef"
  vivify_1603:
    $P3114 = $P3113."loadinit"()
    get_hll_global $P3115, ["PAST"], "Op"
.annotate 'line', 828
    get_hll_global $P3116, ["PAST"], "Var"
    new $P3117, "ResizablePMCArray"
    $P3118 = $P3116."new"("GLOBAL" :named("name"), $P3117 :named("namespace"), "package" :named("scope"))
.annotate 'line', 829
    find_dynamic_lex $P3119, "$*SC"
    unless_null $P3119, vivify_1604
    get_hll_global $P3119, "$SC"
    unless_null $P3119, vivify_1605
    die "Contextual $*SC not found"
  vivify_1605:
  vivify_1604:
    find_dynamic_lex $P3120, "$*PACKAGE"
    unless_null $P3120, vivify_1606
    get_hll_global $P3120, "$PACKAGE"
    unless_null $P3120, vivify_1607
    die "Contextual $*PACKAGE not found"
  vivify_1607:
  vivify_1606:
    $P3121 = $P3119."get_slot_past_for_object"($P3120)
    $P3122 = $P3115."new"($P3118, $P3121, "bind" :named("pasttype"))
.annotate 'line', 826
    $P3114."push"($P3122)
.annotate 'line', 835
    find_dynamic_lex $P3124, "$*HAS_YOU_ARE_HERE"
    unless_null $P3124, vivify_1608
    get_hll_global $P3124, "$HAS_YOU_ARE_HERE"
    unless_null $P3124, vivify_1609
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1609:
  vivify_1608:
    if $P3124, unless_3123_end
.annotate 'line', 836
    find_lex $P3125, "$unit"
    unless_null $P3125, vivify_1610
    new $P3125, "Undef"
  vivify_1610:
    find_lex $P3126, "self"
    $P3127 = $P3126."CTXSAVE"()
    $P3125."push"($P3127)
  unless_3123_end:
.annotate 'line', 840
    find_lex $P3128, "$unit"
    unless_null $P3128, vivify_1611
    new $P3128, "Undef"
  vivify_1611:
    $P3128."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 844
    find_dynamic_lex $P3130, "$*MAIN_SUB"
    unless_null $P3130, vivify_1612
    get_hll_global $P3130, "$MAIN_SUB"
    unless_null $P3130, vivify_1613
    die "Contextual $*MAIN_SUB not found"
  vivify_1613:
  vivify_1612:
    unless $P3130, if_3129_end
.annotate 'line', 845
    find_lex $P3131, "$unit"
    unless_null $P3131, vivify_1614
    new $P3131, "Undef"
  vivify_1614:
    get_hll_global $P3132, ["PAST"], "Var"
    $P3133 = $P3132."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3131."unshift"($P3133)
.annotate 'line', 846
    find_lex $P3134, "$mainline"
    unless_null $P3134, vivify_1615
    new $P3134, "Undef"
  vivify_1615:
    get_hll_global $P3135, ["PAST"], "Op"
.annotate 'line', 848
    get_hll_global $P3136, ["PAST"], "Var"
    $P3137 = $P3136."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 849
    get_hll_global $P3138, ["PAST"], "Op"
.annotate 'line', 850
    get_hll_global $P3139, ["PAST"], "Val"
    find_dynamic_lex $P3140, "$*MAIN_SUB"
    unless_null $P3140, vivify_1616
    get_hll_global $P3140, "$MAIN_SUB"
    unless_null $P3140, vivify_1617
    die "Contextual $*MAIN_SUB not found"
  vivify_1617:
  vivify_1616:
    $P3141 = $P3139."new"($P3140 :named("value"))
.annotate 'line', 851
    get_hll_global $P3142, ["PAST"], "Var"
    $P3143 = $P3142."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3144 = $P3138."new"($P3141, $P3143, "call" :named("pasttype"))
.annotate 'line', 849
    $P3145 = $P3135."new"($P3137, $P3144, "if" :named("pasttype"))
.annotate 'line', 846
    $P3134."push"($P3145)
  if_3129_end:
.annotate 'line', 859
    find_lex $P3146, "$unit"
    unless_null $P3146, vivify_1618
    new $P3146, "Undef"
  vivify_1618:
.annotate 'line', 860
    get_hll_global $P3147, ["PAST"], "Op"
    find_lex $P3148, "$mainline"
    unless_null $P3148, vivify_1619
    new $P3148, "Undef"
  vivify_1619:
    $P3149 = $P3147."new"($P3148, "return" :named("pirop"))
    $P3146."push"($P3149)
.annotate 'line', 865
    find_lex $P3150, "$unit"
    unless_null $P3150, vivify_1620
    new $P3150, "Undef"
  vivify_1620:
.annotate 'line', 866
    get_hll_global $P3151, ["PAST"], "Block"
.annotate 'line', 868
    get_hll_global $P3152, ["PAST"], "Op"
    get_hll_global $P3153, ["PAST"], "Val"
    find_lex $P3154, "$unit"
    unless_null $P3154, vivify_1621
    new $P3154, "Undef"
  vivify_1621:
    $P3155 = $P3153."new"($P3154 :named("value"))
    $P3156 = $P3152."new"($P3155, "call" :named("pasttype"))
    $P3157 = $P3151."new"($P3156, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 866
    $P3150."push"($P3157)
.annotate 'line', 871
    find_lex $P3158, "$unit"
    unless_null $P3158, vivify_1622
    new $P3158, "Undef"
  vivify_1622:
    find_lex $P3159, "$/"
    unless_null $P3159, vivify_1623
    new $P3159, "Undef"
  vivify_1623:
    $P3158."node"($P3159)
.annotate 'line', 874
    find_lex $P3160, "$unit"
    unless_null $P3160, vivify_1624
    new $P3160, "Undef"
  vivify_1624:
    $P3160."hll"("nqp")
.annotate 'line', 876
    find_lex $P3161, "$/"
    find_lex $P3162, "$unit"
    unless_null $P3162, vivify_1625
    new $P3162, "Undef"
  vivify_1625:
    $P3163 = $P3161."!make"($P3162)
.annotate 'line', 814
    .return ($P3163)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("434_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3165
    .param pmc param_3166
.annotate 'line', 879
    .const 'Sub' $P3180 = "435_1303603603.711" 
    capture_lex $P3180
    .lex "self", param_3165
    .lex "$/", param_3166
.annotate 'line', 880
    new $P3167, "Undef"
    .lex "$past", $P3167
    get_hll_global $P3168, ["PAST"], "Stmts"
    find_lex $P3169, "$/"
    unless_null $P3169, vivify_1626
    new $P3169, "Undef"
  vivify_1626:
    $P3170 = $P3168."new"($P3169 :named("node"))
    store_lex "$past", $P3170
.annotate 'line', 881
    find_lex $P3172, "$/"
    unless_null $P3172, vivify_1627
    $P3172 = root_new ['parrot';'Hash']
  vivify_1627:
    set $P3173, $P3172["statement"]
    unless_null $P3173, vivify_1628
    new $P3173, "Undef"
  vivify_1628:
    unless $P3173, if_3171_end
.annotate 'line', 882
    find_lex $P3175, "$/"
    unless_null $P3175, vivify_1629
    $P3175 = root_new ['parrot';'Hash']
  vivify_1629:
    set $P3176, $P3175["statement"]
    unless_null $P3176, vivify_1630
    new $P3176, "Undef"
  vivify_1630:
    defined $I3177, $P3176
    unless $I3177, for_undef_1631
    iter $P3174, $P3176
    new $P3200, 'ExceptionHandler'
    set_label $P3200, loop3199_handler
    $P3200."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3200
  loop3199_test:
    unless $P3174, loop3199_done
    shift $P3178, $P3174
  loop3199_redo:
    .const 'Sub' $P3180 = "435_1303603603.711" 
    capture_lex $P3180
    $P3180($P3178)
  loop3199_next:
    goto loop3199_test
  loop3199_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3201, exception, 'type'
    eq $P3201, .CONTROL_LOOP_NEXT, loop3199_next
    eq $P3201, .CONTROL_LOOP_REDO, loop3199_redo
  loop3199_done:
    pop_eh 
  for_undef_1631:
  if_3171_end:
.annotate 'line', 889
    find_lex $P3202, "$/"
    find_lex $P3203, "$past"
    unless_null $P3203, vivify_1642
    new $P3203, "Undef"
  vivify_1642:
    $P3204 = $P3202."!make"($P3203)
.annotate 'line', 879
    .return ($P3204)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3179"  :anon :subid("435_1303603603.711") :outer("434_1303603603.711")
    .param pmc param_3182
.annotate 'line', 883
    new $P3181, "Undef"
    .lex "$ast", $P3181
    .lex "$_", param_3182
    find_lex $P3183, "$_"
    unless_null $P3183, vivify_1632
    new $P3183, "Undef"
  vivify_1632:
    $P3184 = $P3183."ast"()
    store_lex "$ast", $P3184
.annotate 'line', 884
    find_lex $P3186, "$ast"
    unless_null $P3186, vivify_1633
    $P3186 = root_new ['parrot';'Hash']
  vivify_1633:
    set $P3187, $P3186["sink"]
    unless_null $P3187, vivify_1634
    new $P3187, "Undef"
  vivify_1634:
    defined $I3188, $P3187
    unless $I3188, if_3185_end
    find_lex $P3189, "$ast"
    unless_null $P3189, vivify_1635
    $P3189 = root_new ['parrot';'Hash']
  vivify_1635:
    set $P3190, $P3189["sink"]
    unless_null $P3190, vivify_1636
    new $P3190, "Undef"
  vivify_1636:
    store_lex "$ast", $P3190
  if_3185_end:
.annotate 'line', 885
    find_lex $P3192, "$ast"
    unless_null $P3192, vivify_1637
    $P3192 = root_new ['parrot';'Hash']
  vivify_1637:
    set $P3193, $P3192["bareblock"]
    unless_null $P3193, vivify_1638
    new $P3193, "Undef"
  vivify_1638:
    unless $P3193, if_3191_end
    find_lex $P3194, "$ast"
    unless_null $P3194, vivify_1639
    new $P3194, "Undef"
  vivify_1639:
    $P3195 = "block_immediate"($P3194)
    store_lex "$ast", $P3195
  if_3191_end:
.annotate 'line', 886
    find_lex $P3196, "$past"
    unless_null $P3196, vivify_1640
    new $P3196, "Undef"
  vivify_1640:
    find_lex $P3197, "$ast"
    unless_null $P3197, vivify_1641
    new $P3197, "Undef"
  vivify_1641:
    $P3198 = $P3196."push"($P3197)
.annotate 'line', 882
    .return ($P3198)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("436_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3206
    .param pmc param_3207
    .param pmc param_3208 :optional
    .param int has_param_3208 :opt_flag
.annotate 'line', 892
    .const 'Sub' $P3216 = "437_1303603603.711" 
    capture_lex $P3216
    .lex "self", param_3206
    .lex "$/", param_3207
    if has_param_3208, optparam_1643
    new $P3209, "Undef"
    set param_3208, $P3209
  optparam_1643:
    .lex "$key", param_3208
.annotate 'line', 893
    new $P3210, "Undef"
    .lex "$past", $P3210
.annotate 'line', 892
    find_lex $P3211, "$past"
    unless_null $P3211, vivify_1644
    new $P3211, "Undef"
  vivify_1644:
.annotate 'line', 894
    find_lex $P3213, "$/"
    unless_null $P3213, vivify_1645
    $P3213 = root_new ['parrot';'Hash']
  vivify_1645:
    set $P3214, $P3213["EXPR"]
    unless_null $P3214, vivify_1646
    new $P3214, "Undef"
  vivify_1646:
    if $P3214, if_3212
.annotate 'line', 915
    find_lex $P3277, "$/"
    unless_null $P3277, vivify_1647
    $P3277 = root_new ['parrot';'Hash']
  vivify_1647:
    set $P3278, $P3277["statement_control"]
    unless_null $P3278, vivify_1648
    new $P3278, "Undef"
  vivify_1648:
    if $P3278, if_3276
.annotate 'line', 916
    new $P3282, "Integer"
    assign $P3282, 0
    store_lex "$past", $P3282
    goto if_3276_end
  if_3276:
.annotate 'line', 915
    find_lex $P3279, "$/"
    unless_null $P3279, vivify_1649
    $P3279 = root_new ['parrot';'Hash']
  vivify_1649:
    set $P3280, $P3279["statement_control"]
    unless_null $P3280, vivify_1650
    new $P3280, "Undef"
  vivify_1650:
    $P3281 = $P3280."ast"()
    store_lex "$past", $P3281
  if_3276_end:
    goto if_3212_end
  if_3212:
.annotate 'line', 894
    .const 'Sub' $P3216 = "437_1303603603.711" 
    capture_lex $P3216
    $P3216()
  if_3212_end:
.annotate 'line', 917
    find_lex $P3283, "$/"
    find_lex $P3284, "$past"
    unless_null $P3284, vivify_1684
    new $P3284, "Undef"
  vivify_1684:
    $P3285 = $P3283."!make"($P3284)
.annotate 'line', 892
    .return ($P3285)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3215"  :anon :subid("437_1303603603.711") :outer("436_1303603603.711")
.annotate 'line', 895
    new $P3217, "Undef"
    .lex "$mc", $P3217
.annotate 'line', 896
    new $P3218, "Undef"
    .lex "$ml", $P3218
.annotate 'line', 895
    find_lex $P3219, "$/"
    unless_null $P3219, vivify_1651
    $P3219 = root_new ['parrot';'Hash']
  vivify_1651:
    set $P3220, $P3219["statement_mod_cond"]
    unless_null $P3220, vivify_1652
    $P3220 = root_new ['parrot';'ResizablePMCArray']
  vivify_1652:
    set $P3221, $P3220[0]
    unless_null $P3221, vivify_1653
    new $P3221, "Undef"
  vivify_1653:
    store_lex "$mc", $P3221
.annotate 'line', 896
    find_lex $P3222, "$/"
    unless_null $P3222, vivify_1654
    $P3222 = root_new ['parrot';'Hash']
  vivify_1654:
    set $P3223, $P3222["statement_mod_loop"]
    unless_null $P3223, vivify_1655
    $P3223 = root_new ['parrot';'ResizablePMCArray']
  vivify_1655:
    set $P3224, $P3223[0]
    unless_null $P3224, vivify_1656
    new $P3224, "Undef"
  vivify_1656:
    store_lex "$ml", $P3224
.annotate 'line', 897
    find_lex $P3225, "$/"
    unless_null $P3225, vivify_1657
    $P3225 = root_new ['parrot';'Hash']
  vivify_1657:
    set $P3226, $P3225["EXPR"]
    unless_null $P3226, vivify_1658
    new $P3226, "Undef"
  vivify_1658:
    $P3227 = $P3226."ast"()
    store_lex "$past", $P3227
.annotate 'line', 898
    find_lex $P3229, "$mc"
    unless_null $P3229, vivify_1659
    new $P3229, "Undef"
  vivify_1659:
    unless $P3229, if_3228_end
.annotate 'line', 899
    get_hll_global $P3230, ["PAST"], "Op"
    find_lex $P3231, "$mc"
    unless_null $P3231, vivify_1660
    $P3231 = root_new ['parrot';'Hash']
  vivify_1660:
    set $P3232, $P3231["cond"]
    unless_null $P3232, vivify_1661
    new $P3232, "Undef"
  vivify_1661:
    $P3233 = $P3232."ast"()
    find_lex $P3234, "$past"
    unless_null $P3234, vivify_1662
    new $P3234, "Undef"
  vivify_1662:
    find_lex $P3235, "$mc"
    unless_null $P3235, vivify_1663
    $P3235 = root_new ['parrot';'Hash']
  vivify_1663:
    set $P3236, $P3235["sym"]
    unless_null $P3236, vivify_1664
    new $P3236, "Undef"
  vivify_1664:
    set $S3237, $P3236
    find_lex $P3238, "$/"
    unless_null $P3238, vivify_1665
    new $P3238, "Undef"
  vivify_1665:
    $P3239 = $P3230."new"($P3233, $P3234, $S3237 :named("pasttype"), $P3238 :named("node"))
    store_lex "$past", $P3239
  if_3228_end:
.annotate 'line', 901
    find_lex $P3242, "$ml"
    unless_null $P3242, vivify_1666
    new $P3242, "Undef"
  vivify_1666:
    if $P3242, if_3241
    set $P3240, $P3242
    goto if_3241_end
  if_3241:
.annotate 'line', 902
    find_lex $P3245, "$ml"
    unless_null $P3245, vivify_1667
    $P3245 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3246, $P3245["sym"]
    unless_null $P3246, vivify_1668
    new $P3246, "Undef"
  vivify_1668:
    set $S3247, $P3246
    iseq $I3248, $S3247, "for"
    if $I3248, if_3244
.annotate 'line', 911
    get_hll_global $P3266, ["PAST"], "Op"
    find_lex $P3267, "$ml"
    unless_null $P3267, vivify_1669
    $P3267 = root_new ['parrot';'Hash']
  vivify_1669:
    set $P3268, $P3267["cond"]
    unless_null $P3268, vivify_1670
    new $P3268, "Undef"
  vivify_1670:
    $P3269 = $P3268."ast"()
    find_lex $P3270, "$past"
    unless_null $P3270, vivify_1671
    new $P3270, "Undef"
  vivify_1671:
    find_lex $P3271, "$ml"
    unless_null $P3271, vivify_1672
    $P3271 = root_new ['parrot';'Hash']
  vivify_1672:
    set $P3272, $P3271["sym"]
    unless_null $P3272, vivify_1673
    new $P3272, "Undef"
  vivify_1673:
    set $S3273, $P3272
    find_lex $P3274, "$/"
    unless_null $P3274, vivify_1674
    new $P3274, "Undef"
  vivify_1674:
    $P3275 = $P3266."new"($P3269, $P3270, $S3273 :named("pasttype"), $P3274 :named("node"))
    store_lex "$past", $P3275
.annotate 'line', 910
    set $P3243, $P3275
.annotate 'line', 902
    goto if_3244_end
  if_3244:
.annotate 'line', 903
    get_hll_global $P3249, ["PAST"], "Block"
.annotate 'line', 904
    get_hll_global $P3250, ["PAST"], "Var"
    $P3251 = $P3250."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3252, "$past"
    unless_null $P3252, vivify_1675
    new $P3252, "Undef"
  vivify_1675:
    $P3253 = $P3249."new"($P3251, $P3252, "immediate" :named("blocktype"))
.annotate 'line', 903
    store_lex "$past", $P3253
.annotate 'line', 906
    find_lex $P3254, "$past"
    unless_null $P3254, vivify_1676
    new $P3254, "Undef"
  vivify_1676:
    $P3254."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 907
    find_lex $P3255, "$past"
    unless_null $P3255, vivify_1677
    new $P3255, "Undef"
  vivify_1677:
    $P3255."arity"(1)
.annotate 'line', 908
    get_hll_global $P3256, ["PAST"], "Op"
    find_lex $P3257, "$ml"
    unless_null $P3257, vivify_1678
    $P3257 = root_new ['parrot';'Hash']
  vivify_1678:
    set $P3258, $P3257["cond"]
    unless_null $P3258, vivify_1679
    new $P3258, "Undef"
  vivify_1679:
    $P3259 = $P3258."ast"()
    find_lex $P3260, "$past"
    unless_null $P3260, vivify_1680
    new $P3260, "Undef"
  vivify_1680:
    find_lex $P3261, "$ml"
    unless_null $P3261, vivify_1681
    $P3261 = root_new ['parrot';'Hash']
  vivify_1681:
    set $P3262, $P3261["sym"]
    unless_null $P3262, vivify_1682
    new $P3262, "Undef"
  vivify_1682:
    set $S3263, $P3262
    find_lex $P3264, "$/"
    unless_null $P3264, vivify_1683
    new $P3264, "Undef"
  vivify_1683:
    $P3265 = $P3256."new"($P3259, $P3260, $S3263 :named("pasttype"), $P3264 :named("node"))
    store_lex "$past", $P3265
.annotate 'line', 902
    set $P3243, $P3265
  if_3244_end:
.annotate 'line', 901
    set $P3240, $P3243
  if_3241_end:
.annotate 'line', 894
    .return ($P3240)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("438_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3287
    .param pmc param_3288
.annotate 'line', 920
    .lex "self", param_3287
    .lex "$/", param_3288
.annotate 'line', 921
    find_lex $P3289, "$/"
    get_hll_global $P3290, ["PAST"], "Op"
    find_lex $P3291, "$/"
    unless_null $P3291, vivify_1685
    $P3291 = root_new ['parrot';'Hash']
  vivify_1685:
    set $P3292, $P3291["EXPR"]
    unless_null $P3292, vivify_1686
    new $P3292, "Undef"
  vivify_1686:
    $P3293 = $P3292."ast"()
    find_lex $P3294, "$/"
    unless_null $P3294, vivify_1687
    $P3294 = root_new ['parrot';'Hash']
  vivify_1687:
    set $P3295, $P3294["pblock"]
    unless_null $P3295, vivify_1688
    new $P3295, "Undef"
  vivify_1688:
    $P3296 = $P3295."ast"()
    find_lex $P3297, "$/"
    unless_null $P3297, vivify_1689
    new $P3297, "Undef"
  vivify_1689:
    $P3298 = $P3290."new"($P3293, $P3296, "if" :named("pasttype"), $P3297 :named("node"))
    $P3299 = $P3289."!make"($P3298)
.annotate 'line', 920
    .return ($P3299)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("439_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3301
    .param pmc param_3302
.annotate 'line', 924
    .lex "self", param_3301
    .lex "$/", param_3302
.annotate 'line', 925
    find_lex $P3303, "$/"
    find_lex $P3304, "$/"
    unless_null $P3304, vivify_1690
    $P3304 = root_new ['parrot';'Hash']
  vivify_1690:
    set $P3305, $P3304["blockoid"]
    unless_null $P3305, vivify_1691
    new $P3305, "Undef"
  vivify_1691:
    $P3306 = $P3305."ast"()
    $P3307 = $P3303."!make"($P3306)
.annotate 'line', 924
    .return ($P3307)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("440_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3309
    .param pmc param_3310
.annotate 'line', 928
    .lex "self", param_3309
    .lex "$/", param_3310
.annotate 'line', 929
    find_lex $P3311, "$/"
    find_lex $P3312, "$/"
    unless_null $P3312, vivify_1692
    $P3312 = root_new ['parrot';'Hash']
  vivify_1692:
    set $P3313, $P3312["blockoid"]
    unless_null $P3313, vivify_1693
    new $P3313, "Undef"
  vivify_1693:
    $P3314 = $P3313."ast"()
    $P3315 = $P3311."!make"($P3314)
.annotate 'line', 928
    .return ($P3315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("441_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3317
    .param pmc param_3318
.annotate 'line', 932
    .const 'Sub' $P3329 = "442_1303603603.711" 
    capture_lex $P3329
    .lex "self", param_3317
    .lex "$/", param_3318
.annotate 'line', 933
    new $P3319, "Undef"
    .lex "$BLOCK", $P3319
    find_lex $P3320, "$?PACKAGE"
    get_who $P3321, $P3320
    set $P3322, $P3321["@BLOCK"]
    unless_null $P3322, vivify_1694
    $P3322 = root_new ['parrot';'ResizablePMCArray']
  vivify_1694:
    $P3323 = $P3322."shift"()
    store_lex "$BLOCK", $P3323
.annotate 'line', 934
    find_lex $P3326, "$/"
    unless_null $P3326, vivify_1695
    $P3326 = root_new ['parrot';'Hash']
  vivify_1695:
    set $P3327, $P3326["statementlist"]
    unless_null $P3327, vivify_1696
    new $P3327, "Undef"
  vivify_1696:
    if $P3327, if_3325
.annotate 'line', 942
    find_dynamic_lex $P3344, "$*HAS_YOU_ARE_HERE"
    unless_null $P3344, vivify_1697
    get_hll_global $P3344, "$HAS_YOU_ARE_HERE"
    unless_null $P3344, vivify_1698
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1698:
  vivify_1697:
    unless $P3344, if_3343_end
.annotate 'line', 943
    find_lex $P3345, "$/"
    unless_null $P3345, vivify_1699
    new $P3345, "Undef"
  vivify_1699:
    $P3346 = $P3345."CURSOR"()
    $P3346."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3343_end:
.annotate 'line', 945
    new $P3347, "Integer"
    assign $P3347, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3347
.annotate 'line', 946
    find_lex $P3348, "$/"
    find_lex $P3349, "$/"
    unless_null $P3349, vivify_1700
    $P3349 = root_new ['parrot';'Hash']
  vivify_1700:
    set $P3350, $P3349["you_are_here"]
    unless_null $P3350, vivify_1701
    new $P3350, "Undef"
  vivify_1701:
    $P3351 = $P3350."ast"()
    $P3352 = $P3348."!make"($P3351)
.annotate 'line', 941
    set $P3324, $P3352
.annotate 'line', 934
    goto if_3325_end
  if_3325:
    .const 'Sub' $P3329 = "442_1303603603.711" 
    capture_lex $P3329
    $P3342 = $P3329()
    set $P3324, $P3342
  if_3325_end:
.annotate 'line', 932
    .return ($P3324)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3328"  :anon :subid("442_1303603603.711") :outer("441_1303603603.711")
.annotate 'line', 935
    new $P3330, "Undef"
    .lex "$past", $P3330
    find_lex $P3331, "$/"
    unless_null $P3331, vivify_1702
    $P3331 = root_new ['parrot';'Hash']
  vivify_1702:
    set $P3332, $P3331["statementlist"]
    unless_null $P3332, vivify_1703
    new $P3332, "Undef"
  vivify_1703:
    $P3333 = $P3332."ast"()
    store_lex "$past", $P3333
.annotate 'line', 936
    find_lex $P3334, "$BLOCK"
    unless_null $P3334, vivify_1704
    new $P3334, "Undef"
  vivify_1704:
    find_lex $P3335, "$past"
    unless_null $P3335, vivify_1705
    new $P3335, "Undef"
  vivify_1705:
    $P3334."push"($P3335)
.annotate 'line', 937
    find_lex $P3336, "$BLOCK"
    unless_null $P3336, vivify_1706
    new $P3336, "Undef"
  vivify_1706:
    find_lex $P3337, "$/"
    unless_null $P3337, vivify_1707
    new $P3337, "Undef"
  vivify_1707:
    $P3336."node"($P3337)
.annotate 'line', 938
    find_lex $P3338, "$BLOCK"
    unless_null $P3338, vivify_1708
    new $P3338, "Undef"
  vivify_1708:
    $P3338."closure"(1)
.annotate 'line', 939
    find_dynamic_lex $P3339, "$/"
    find_lex $P3340, "$BLOCK"
    unless_null $P3340, vivify_1709
    new $P3340, "Undef"
  vivify_1709:
    $P3341 = $P3339."!make"($P3340)
.annotate 'line', 934
    .return ($P3341)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("443_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3354
    .param pmc param_3355
.annotate 'line', 950
    .lex "self", param_3354
    .lex "$/", param_3355
.annotate 'line', 951
    find_lex $P3356, "$?PACKAGE"
    get_who $P3357, $P3356
    set $P3358, $P3357["@BLOCK"]
    unless_null $P3358, vivify_1710
    $P3358 = root_new ['parrot';'ResizablePMCArray']
  vivify_1710:
    get_hll_global $P3359, ["PAST"], "Block"
    get_hll_global $P3360, ["PAST"], "Stmts"
    $P3361 = $P3360."new"()
    $P3362 = $P3359."new"($P3361)
    $P3363 = $P3358."unshift"($P3362)
.annotate 'line', 950
    .return ($P3363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("444_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3365
    .param pmc param_3366
.annotate 'line', 954
    .lex "self", param_3365
    .lex "$/", param_3366
.annotate 'line', 955
    find_dynamic_lex $P3368, "%*COMPILING"
    unless_null $P3368, vivify_1711
    get_hll_global $P3368, "%COMPILING"
    unless_null $P3368, vivify_1712
    die "Contextual %*COMPILING not found"
  vivify_1712:
  vivify_1711:
    set $P3369, $P3368["%?OPTIONS"]
    unless_null $P3369, vivify_1713
    $P3369 = root_new ['parrot';'Hash']
  vivify_1713:
    set $P3370, $P3369["outer_ctx"]
    unless_null $P3370, vivify_1714
    new $P3370, "Undef"
  vivify_1714:
    defined $I3371, $P3370
    if $I3371, unless_3367_end
.annotate 'line', 958
    find_dynamic_lex $P3372, "$*SC"
    unless_null $P3372, vivify_1715
    get_hll_global $P3372, "$SC"
    unless_null $P3372, vivify_1716
    die "Contextual $*SC not found"
  vivify_1716:
  vivify_1715:
    find_dynamic_lex $P3374, "%*COMPILING"
    unless_null $P3374, vivify_1717
    get_hll_global $P3374, "%COMPILING"
    unless_null $P3374, vivify_1718
    die "Contextual %*COMPILING not found"
  vivify_1718:
  vivify_1717:
    set $P3375, $P3374["%?OPTIONS"]
    unless_null $P3375, vivify_1719
    $P3375 = root_new ['parrot';'Hash']
  vivify_1719:
    set $P3376, $P3375["setting"]
    unless_null $P3376, vivify_1720
    new $P3376, "Undef"
  vivify_1720:
    set $P3373, $P3376
    defined $I3378, $P3373
    if $I3378, default_3377
    new $P3379, "String"
    assign $P3379, "NQPCORE"
    set $P3373, $P3379
  default_3377:
    $P3372."load_setting"($P3373)
  unless_3367_end:
.annotate 'line', 960
    find_lex $P3380, "self"
    find_lex $P3381, "$?PACKAGE"
    get_who $P3382, $P3381
    set $P3383, $P3382["@BLOCK"]
    unless_null $P3383, vivify_1721
    $P3383 = root_new ['parrot';'ResizablePMCArray']
  vivify_1721:
    set $P3384, $P3383[0]
    unless_null $P3384, vivify_1722
    new $P3384, "Undef"
  vivify_1722:
    $P3385 = $P3380."SET_BLOCK_OUTER_CTX"($P3384)
.annotate 'line', 954
    .return ($P3385)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("445_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3387
    .param pmc param_3388
.annotate 'line', 963
    .lex "self", param_3387
    .lex "$/", param_3388
.annotate 'line', 967
    find_dynamic_lex $P3389, "$*SC"
    unless_null $P3389, vivify_1723
    get_hll_global $P3389, "$SC"
    unless_null $P3389, vivify_1724
    die "Contextual $*SC not found"
  vivify_1724:
  vivify_1723:
    get_hll_global $P3390, "KnowHOW"
    $P3391 = $P3389."pkg_create_mo"($P3390, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3391
.annotate 'line', 968
    find_dynamic_lex $P3392, "$*GLOBALish"
    unless_null $P3392, vivify_1725
    get_hll_global $P3392, "$GLOBALish"
    unless_null $P3392, vivify_1726
    die "Contextual $*GLOBALish not found"
  vivify_1726:
  vivify_1725:
    get_how $P3393, $P3392
    find_dynamic_lex $P3394, "$*GLOBALish"
    unless_null $P3394, vivify_1727
    get_hll_global $P3394, "$GLOBALish"
    unless_null $P3394, vivify_1728
    die "Contextual $*GLOBALish not found"
  vivify_1728:
  vivify_1727:
    $P3393."compose"($P3394)
.annotate 'line', 969
    find_dynamic_lex $P3395, "$*SC"
    unless_null $P3395, vivify_1729
    get_hll_global $P3395, "$SC"
    unless_null $P3395, vivify_1730
    die "Contextual $*SC not found"
  vivify_1730:
  vivify_1729:
    find_lex $P3396, "$?PACKAGE"
    get_who $P3397, $P3396
    set $P3398, $P3397["@BLOCK"]
    unless_null $P3398, vivify_1731
    $P3398 = root_new ['parrot';'ResizablePMCArray']
  vivify_1731:
    set $P3399, $P3398[0]
    unless_null $P3399, vivify_1732
    new $P3399, "Undef"
  vivify_1732:
    find_dynamic_lex $P3400, "$*GLOBALish"
    unless_null $P3400, vivify_1733
    get_hll_global $P3400, "$GLOBALish"
    unless_null $P3400, vivify_1734
    die "Contextual $*GLOBALish not found"
  vivify_1734:
  vivify_1733:
    $P3395."install_lexical_symbol"($P3399, "GLOBALish", $P3400)
.annotate 'line', 972
    find_dynamic_lex $P3401, "$*GLOBALish"
    unless_null $P3401, vivify_1735
    get_hll_global $P3401, "$GLOBALish"
    unless_null $P3401, vivify_1736
    die "Contextual $*GLOBALish not found"
  vivify_1736:
  vivify_1735:
    store_dynamic_lex "$*PACKAGE", $P3401
.annotate 'line', 973
    find_dynamic_lex $P3402, "$*SC"
    unless_null $P3402, vivify_1737
    get_hll_global $P3402, "$SC"
    unless_null $P3402, vivify_1738
    die "Contextual $*SC not found"
  vivify_1738:
  vivify_1737:
    find_lex $P3403, "$?PACKAGE"
    get_who $P3404, $P3403
    set $P3405, $P3404["@BLOCK"]
    unless_null $P3405, vivify_1739
    $P3405 = root_new ['parrot';'ResizablePMCArray']
  vivify_1739:
    set $P3406, $P3405[0]
    unless_null $P3406, vivify_1740
    new $P3406, "Undef"
  vivify_1740:
    find_dynamic_lex $P3407, "$*PACKAGE"
    unless_null $P3407, vivify_1741
    get_hll_global $P3407, "$PACKAGE"
    unless_null $P3407, vivify_1742
    die "Contextual $*PACKAGE not found"
  vivify_1742:
  vivify_1741:
    $P3408 = $P3402."install_lexical_symbol"($P3406, "$?PACKAGE", $P3407)
.annotate 'line', 963
    .return ($P3408)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("446_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3410
    .param pmc param_3411
.annotate 'line', 976
    .lex "self", param_3410
    .lex "$/", param_3411
.annotate 'line', 977
    find_lex $P3412, "$/"
    find_lex $P3413, "self"
    $P3414 = $P3413."CTXSAVE"()
    $P3415 = $P3412."!make"($P3414)
.annotate 'line', 976
    .return ($P3415)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("447_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3417
    .param pmc param_3418
.annotate 'line', 982
    .lex "self", param_3417
    .lex "$/", param_3418
.annotate 'line', 983
    find_dynamic_lex $P3419, "$*SC"
    unless_null $P3419, vivify_1743
    get_hll_global $P3419, "$SC"
    unless_null $P3419, vivify_1744
    die "Contextual $*SC not found"
  vivify_1744:
  vivify_1743:
    find_lex $P3420, "$/"
    unless_null $P3420, vivify_1745
    $P3420 = root_new ['parrot';'Hash']
  vivify_1745:
    set $P3421, $P3420["name"]
    unless_null $P3421, vivify_1746
    new $P3421, "Undef"
  vivify_1746:
    set $S3422, $P3421
    find_dynamic_lex $P3423, "$*GLOBALish"
    unless_null $P3423, vivify_1747
    get_hll_global $P3423, "$GLOBALish"
    unless_null $P3423, vivify_1748
    die "Contextual $*GLOBALish not found"
  vivify_1748:
  vivify_1747:
    $P3419."load_module"($S3422, $P3423)
.annotate 'line', 984
    find_lex $P3424, "$/"
    get_hll_global $P3425, ["PAST"], "Stmts"
    $P3426 = $P3425."new"()
    $P3427 = $P3424."!make"($P3426)
.annotate 'line', 982
    .return ($P3427)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("448_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3429
    .param pmc param_3430
.annotate 'line', 987
    .const 'Sub' $P3458 = "449_1303603603.711" 
    capture_lex $P3458
    .lex "self", param_3429
    .lex "$/", param_3430
.annotate 'line', 988
    new $P3431, "Undef"
    .lex "$count", $P3431
.annotate 'line', 989
    new $P3432, "Undef"
    .lex "$past", $P3432
.annotate 'line', 988
    find_lex $P3433, "$/"
    unless_null $P3433, vivify_1749
    $P3433 = root_new ['parrot';'Hash']
  vivify_1749:
    set $P3434, $P3433["xblock"]
    unless_null $P3434, vivify_1750
    new $P3434, "Undef"
  vivify_1750:
    set $N3435, $P3434
    new $P3436, 'Float'
    set $P3436, $N3435
    sub $P3437, $P3436, 1
    store_lex "$count", $P3437
.annotate 'line', 989
    find_lex $P3438, "$count"
    unless_null $P3438, vivify_1751
    new $P3438, "Undef"
  vivify_1751:
    set $I3439, $P3438
    find_lex $P3440, "$/"
    unless_null $P3440, vivify_1752
    $P3440 = root_new ['parrot';'Hash']
  vivify_1752:
    set $P3441, $P3440["xblock"]
    unless_null $P3441, vivify_1753
    $P3441 = root_new ['parrot';'ResizablePMCArray']
  vivify_1753:
    set $P3442, $P3441[$I3439]
    unless_null $P3442, vivify_1754
    new $P3442, "Undef"
  vivify_1754:
    $P3443 = $P3442."ast"()
    $P3444 = "xblock_immediate"($P3443)
    store_lex "$past", $P3444
.annotate 'line', 990
    find_lex $P3446, "$/"
    unless_null $P3446, vivify_1755
    $P3446 = root_new ['parrot';'Hash']
  vivify_1755:
    set $P3447, $P3446["else"]
    unless_null $P3447, vivify_1756
    new $P3447, "Undef"
  vivify_1756:
    unless $P3447, if_3445_end
.annotate 'line', 991
    find_lex $P3448, "$past"
    unless_null $P3448, vivify_1757
    new $P3448, "Undef"
  vivify_1757:
    find_lex $P3449, "$/"
    unless_null $P3449, vivify_1758
    $P3449 = root_new ['parrot';'Hash']
  vivify_1758:
    set $P3450, $P3449["else"]
    unless_null $P3450, vivify_1759
    $P3450 = root_new ['parrot';'ResizablePMCArray']
  vivify_1759:
    set $P3451, $P3450[0]
    unless_null $P3451, vivify_1760
    new $P3451, "Undef"
  vivify_1760:
    $P3452 = $P3451."ast"()
    $P3453 = "block_immediate"($P3452)
    $P3448."push"($P3453)
  if_3445_end:
.annotate 'line', 994
    new $P3474, 'ExceptionHandler'
    set_label $P3474, loop3473_handler
    $P3474."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3474
  loop3473_test:
    find_lex $P3454, "$count"
    unless_null $P3454, vivify_1761
    new $P3454, "Undef"
  vivify_1761:
    set $N3455, $P3454
    isgt $I3456, $N3455, 0.0
    unless $I3456, loop3473_done
  loop3473_redo:
    .const 'Sub' $P3458 = "449_1303603603.711" 
    capture_lex $P3458
    $P3458()
  loop3473_next:
    goto loop3473_test
  loop3473_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3475, exception, 'type'
    eq $P3475, .CONTROL_LOOP_NEXT, loop3473_next
    eq $P3475, .CONTROL_LOOP_REDO, loop3473_redo
  loop3473_done:
    pop_eh 
.annotate 'line', 1000
    find_lex $P3476, "$/"
    find_lex $P3477, "$past"
    unless_null $P3477, vivify_1770
    new $P3477, "Undef"
  vivify_1770:
    $P3478 = $P3476."!make"($P3477)
.annotate 'line', 987
    .return ($P3478)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3457"  :anon :subid("449_1303603603.711") :outer("448_1303603603.711")
.annotate 'line', 996
    new $P3459, "Undef"
    .lex "$else", $P3459
.annotate 'line', 994
    find_lex $P3460, "$count"
    unless_null $P3460, vivify_1762
    new $P3460, "Undef"
  vivify_1762:
    clone $P3461, $P3460
    dec $P3460
.annotate 'line', 996
    find_lex $P3462, "$past"
    unless_null $P3462, vivify_1763
    new $P3462, "Undef"
  vivify_1763:
    store_lex "$else", $P3462
.annotate 'line', 997
    find_lex $P3463, "$count"
    unless_null $P3463, vivify_1764
    new $P3463, "Undef"
  vivify_1764:
    set $I3464, $P3463
    find_lex $P3465, "$/"
    unless_null $P3465, vivify_1765
    $P3465 = root_new ['parrot';'Hash']
  vivify_1765:
    set $P3466, $P3465["xblock"]
    unless_null $P3466, vivify_1766
    $P3466 = root_new ['parrot';'ResizablePMCArray']
  vivify_1766:
    set $P3467, $P3466[$I3464]
    unless_null $P3467, vivify_1767
    new $P3467, "Undef"
  vivify_1767:
    $P3468 = $P3467."ast"()
    $P3469 = "xblock_immediate"($P3468)
    store_lex "$past", $P3469
.annotate 'line', 998
    find_lex $P3470, "$past"
    unless_null $P3470, vivify_1768
    new $P3470, "Undef"
  vivify_1768:
    find_lex $P3471, "$else"
    unless_null $P3471, vivify_1769
    new $P3471, "Undef"
  vivify_1769:
    $P3472 = $P3470."push"($P3471)
.annotate 'line', 994
    .return ($P3472)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("450_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3480
    .param pmc param_3481
.annotate 'line', 1003
    .lex "self", param_3480
    .lex "$/", param_3481
.annotate 'line', 1004
    new $P3482, "Undef"
    .lex "$past", $P3482
    find_lex $P3483, "$/"
    unless_null $P3483, vivify_1771
    $P3483 = root_new ['parrot';'Hash']
  vivify_1771:
    set $P3484, $P3483["xblock"]
    unless_null $P3484, vivify_1772
    new $P3484, "Undef"
  vivify_1772:
    $P3485 = $P3484."ast"()
    $P3486 = "xblock_immediate"($P3485)
    store_lex "$past", $P3486
.annotate 'line', 1005
    find_lex $P3487, "$past"
    unless_null $P3487, vivify_1773
    new $P3487, "Undef"
  vivify_1773:
    $P3487."pasttype"("unless")
.annotate 'line', 1006
    find_lex $P3488, "$/"
    find_lex $P3489, "$past"
    unless_null $P3489, vivify_1774
    new $P3489, "Undef"
  vivify_1774:
    $P3490 = $P3488."!make"($P3489)
.annotate 'line', 1003
    .return ($P3490)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("451_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3492
    .param pmc param_3493
.annotate 'line', 1009
    .lex "self", param_3492
    .lex "$/", param_3493
.annotate 'line', 1010
    new $P3494, "Undef"
    .lex "$past", $P3494
    find_lex $P3495, "$/"
    unless_null $P3495, vivify_1775
    $P3495 = root_new ['parrot';'Hash']
  vivify_1775:
    set $P3496, $P3495["xblock"]
    unless_null $P3496, vivify_1776
    new $P3496, "Undef"
  vivify_1776:
    $P3497 = $P3496."ast"()
    $P3498 = "xblock_immediate"($P3497)
    store_lex "$past", $P3498
.annotate 'line', 1011
    find_lex $P3499, "$past"
    unless_null $P3499, vivify_1777
    new $P3499, "Undef"
  vivify_1777:
    find_lex $P3500, "$/"
    unless_null $P3500, vivify_1778
    $P3500 = root_new ['parrot';'Hash']
  vivify_1778:
    set $P3501, $P3500["sym"]
    unless_null $P3501, vivify_1779
    new $P3501, "Undef"
  vivify_1779:
    set $S3502, $P3501
    $P3499."pasttype"($S3502)
.annotate 'line', 1012
    find_lex $P3503, "$/"
    find_lex $P3504, "$past"
    unless_null $P3504, vivify_1780
    new $P3504, "Undef"
  vivify_1780:
    $P3505 = $P3503."!make"($P3504)
.annotate 'line', 1009
    .return ($P3505)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("452_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3507
    .param pmc param_3508
.annotate 'line', 1015
    .lex "self", param_3507
    .lex "$/", param_3508
.annotate 'line', 1016
    new $P3509, "Undef"
    .lex "$pasttype", $P3509
.annotate 'line', 1017
    new $P3510, "Undef"
    .lex "$past", $P3510
.annotate 'line', 1016
    new $P3511, "String"
    assign $P3511, "repeat_"
    find_lex $P3512, "$/"
    unless_null $P3512, vivify_1781
    $P3512 = root_new ['parrot';'Hash']
  vivify_1781:
    set $P3513, $P3512["wu"]
    unless_null $P3513, vivify_1782
    new $P3513, "Undef"
  vivify_1782:
    set $S3514, $P3513
    concat $P3515, $P3511, $S3514
    store_lex "$pasttype", $P3515
    find_lex $P3516, "$past"
    unless_null $P3516, vivify_1783
    new $P3516, "Undef"
  vivify_1783:
.annotate 'line', 1018
    find_lex $P3518, "$/"
    unless_null $P3518, vivify_1784
    $P3518 = root_new ['parrot';'Hash']
  vivify_1784:
    set $P3519, $P3518["xblock"]
    unless_null $P3519, vivify_1785
    new $P3519, "Undef"
  vivify_1785:
    if $P3519, if_3517
.annotate 'line', 1023
    get_hll_global $P3526, ["PAST"], "Op"
    find_lex $P3527, "$/"
    unless_null $P3527, vivify_1786
    $P3527 = root_new ['parrot';'Hash']
  vivify_1786:
    set $P3528, $P3527["EXPR"]
    unless_null $P3528, vivify_1787
    new $P3528, "Undef"
  vivify_1787:
    $P3529 = $P3528."ast"()
    find_lex $P3530, "$/"
    unless_null $P3530, vivify_1788
    $P3530 = root_new ['parrot';'Hash']
  vivify_1788:
    set $P3531, $P3530["pblock"]
    unless_null $P3531, vivify_1789
    new $P3531, "Undef"
  vivify_1789:
    $P3532 = $P3531."ast"()
    $P3533 = "block_immediate"($P3532)
    find_lex $P3534, "$pasttype"
    unless_null $P3534, vivify_1790
    new $P3534, "Undef"
  vivify_1790:
    find_lex $P3535, "$/"
    unless_null $P3535, vivify_1791
    new $P3535, "Undef"
  vivify_1791:
    $P3536 = $P3526."new"($P3529, $P3533, $P3534 :named("pasttype"), $P3535 :named("node"))
    store_lex "$past", $P3536
.annotate 'line', 1022
    goto if_3517_end
  if_3517:
.annotate 'line', 1019
    find_lex $P3520, "$/"
    unless_null $P3520, vivify_1792
    $P3520 = root_new ['parrot';'Hash']
  vivify_1792:
    set $P3521, $P3520["xblock"]
    unless_null $P3521, vivify_1793
    new $P3521, "Undef"
  vivify_1793:
    $P3522 = $P3521."ast"()
    $P3523 = "xblock_immediate"($P3522)
    store_lex "$past", $P3523
.annotate 'line', 1020
    find_lex $P3524, "$past"
    unless_null $P3524, vivify_1794
    new $P3524, "Undef"
  vivify_1794:
    find_lex $P3525, "$pasttype"
    unless_null $P3525, vivify_1795
    new $P3525, "Undef"
  vivify_1795:
    $P3524."pasttype"($P3525)
  if_3517_end:
.annotate 'line', 1026
    find_lex $P3537, "$/"
    find_lex $P3538, "$past"
    unless_null $P3538, vivify_1796
    new $P3538, "Undef"
  vivify_1796:
    $P3539 = $P3537."!make"($P3538)
.annotate 'line', 1015
    .return ($P3539)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("453_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3541
    .param pmc param_3542
.annotate 'line', 1029
    .lex "self", param_3541
    .lex "$/", param_3542
.annotate 'line', 1030
    new $P3543, "Undef"
    .lex "$past", $P3543
.annotate 'line', 1032
    new $P3544, "Undef"
    .lex "$block", $P3544
.annotate 'line', 1030
    find_lex $P3545, "$/"
    unless_null $P3545, vivify_1797
    $P3545 = root_new ['parrot';'Hash']
  vivify_1797:
    set $P3546, $P3545["xblock"]
    unless_null $P3546, vivify_1798
    new $P3546, "Undef"
  vivify_1798:
    $P3547 = $P3546."ast"()
    store_lex "$past", $P3547
.annotate 'line', 1031
    find_lex $P3548, "$past"
    unless_null $P3548, vivify_1799
    new $P3548, "Undef"
  vivify_1799:
    $P3548."pasttype"("for")
.annotate 'line', 1032
    find_lex $P3549, "$past"
    unless_null $P3549, vivify_1800
    $P3549 = root_new ['parrot';'ResizablePMCArray']
  vivify_1800:
    set $P3550, $P3549[1]
    unless_null $P3550, vivify_1801
    new $P3550, "Undef"
  vivify_1801:
    store_lex "$block", $P3550
.annotate 'line', 1033
    find_lex $P3552, "$block"
    unless_null $P3552, vivify_1802
    new $P3552, "Undef"
  vivify_1802:
    $P3553 = $P3552."arity"()
    if $P3553, unless_3551_end
.annotate 'line', 1034
    find_lex $P3554, "$block"
    unless_null $P3554, vivify_1803
    $P3554 = root_new ['parrot';'ResizablePMCArray']
  vivify_1803:
    set $P3555, $P3554[0]
    unless_null $P3555, vivify_1804
    new $P3555, "Undef"
  vivify_1804:
    get_hll_global $P3556, ["PAST"], "Var"
    $P3557 = $P3556."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3555."push"($P3557)
.annotate 'line', 1035
    find_lex $P3558, "$block"
    unless_null $P3558, vivify_1805
    new $P3558, "Undef"
  vivify_1805:
    $P3558."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1036
    find_lex $P3559, "$block"
    unless_null $P3559, vivify_1806
    new $P3559, "Undef"
  vivify_1806:
    $P3559."arity"(1)
  unless_3551_end:
.annotate 'line', 1038
    find_lex $P3560, "$block"
    unless_null $P3560, vivify_1807
    new $P3560, "Undef"
  vivify_1807:
    $P3560."blocktype"("immediate")
.annotate 'line', 1039
    find_lex $P3561, "$/"
    find_lex $P3562, "$past"
    unless_null $P3562, vivify_1808
    new $P3562, "Undef"
  vivify_1808:
    $P3563 = $P3561."!make"($P3562)
.annotate 'line', 1029
    .return ($P3563)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("454_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3565
    .param pmc param_3566
.annotate 'line', 1042
    .lex "self", param_3565
    .lex "$/", param_3566
.annotate 'line', 1043
    new $P3567, "Undef"
    .lex "$block", $P3567
    find_lex $P3568, "$/"
    unless_null $P3568, vivify_1809
    $P3568 = root_new ['parrot';'Hash']
  vivify_1809:
    set $P3569, $P3568["block"]
    unless_null $P3569, vivify_1810
    new $P3569, "Undef"
  vivify_1810:
    $P3570 = $P3569."ast"()
    store_lex "$block", $P3570
.annotate 'line', 1044
    find_lex $P3571, "$/"
    unless_null $P3571, vivify_1811
    new $P3571, "Undef"
  vivify_1811:
    find_lex $P3572, "$block"
    unless_null $P3572, vivify_1812
    new $P3572, "Undef"
  vivify_1812:
    "push_block_handler"($P3571, $P3572)
.annotate 'line', 1045
    find_lex $P3573, "$?PACKAGE"
    get_who $P3574, $P3573
    set $P3575, $P3574["@BLOCK"]
    unless_null $P3575, vivify_1813
    $P3575 = root_new ['parrot';'ResizablePMCArray']
  vivify_1813:
    set $P3576, $P3575[0]
    unless_null $P3576, vivify_1814
    new $P3576, "Undef"
  vivify_1814:
    $P3577 = $P3576."handlers"()
    set $P3578, $P3577[0]
    unless_null $P3578, vivify_1815
    new $P3578, "Undef"
  vivify_1815:
    $P3578."handle_types_except"("CONTROL")
.annotate 'line', 1046
    find_lex $P3579, "$/"
    get_hll_global $P3580, ["PAST"], "Stmts"
    find_lex $P3581, "$/"
    unless_null $P3581, vivify_1816
    new $P3581, "Undef"
  vivify_1816:
    $P3582 = $P3580."new"($P3581 :named("node"))
    $P3583 = $P3579."!make"($P3582)
.annotate 'line', 1042
    .return ($P3583)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("455_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3585
    .param pmc param_3586
.annotate 'line', 1049
    .lex "self", param_3585
    .lex "$/", param_3586
.annotate 'line', 1050
    new $P3587, "Undef"
    .lex "$block", $P3587
    find_lex $P3588, "$/"
    unless_null $P3588, vivify_1817
    $P3588 = root_new ['parrot';'Hash']
  vivify_1817:
    set $P3589, $P3588["block"]
    unless_null $P3589, vivify_1818
    new $P3589, "Undef"
  vivify_1818:
    $P3590 = $P3589."ast"()
    store_lex "$block", $P3590
.annotate 'line', 1051
    find_lex $P3591, "$/"
    unless_null $P3591, vivify_1819
    new $P3591, "Undef"
  vivify_1819:
    find_lex $P3592, "$block"
    unless_null $P3592, vivify_1820
    new $P3592, "Undef"
  vivify_1820:
    "push_block_handler"($P3591, $P3592)
.annotate 'line', 1052
    find_lex $P3593, "$?PACKAGE"
    get_who $P3594, $P3593
    set $P3595, $P3594["@BLOCK"]
    unless_null $P3595, vivify_1821
    $P3595 = root_new ['parrot';'ResizablePMCArray']
  vivify_1821:
    set $P3596, $P3595[0]
    unless_null $P3596, vivify_1822
    new $P3596, "Undef"
  vivify_1822:
    $P3597 = $P3596."handlers"()
    set $P3598, $P3597[0]
    unless_null $P3598, vivify_1823
    new $P3598, "Undef"
  vivify_1823:
    $P3598."handle_types"("CONTROL")
.annotate 'line', 1053
    find_lex $P3599, "$/"
    get_hll_global $P3600, ["PAST"], "Stmts"
    find_lex $P3601, "$/"
    unless_null $P3601, vivify_1824
    new $P3601, "Undef"
  vivify_1824:
    $P3602 = $P3600."new"($P3601 :named("node"))
    $P3603 = $P3599."!make"($P3602)
.annotate 'line', 1049
    .return ($P3603)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("456_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3606
    .param pmc param_3607
.annotate 'line', 1093
    .lex "self", param_3606
    .lex "$/", param_3607
.annotate 'line', 1094
    find_lex $P3608, "$?PACKAGE"
    get_who $P3609, $P3608
    set $P3610, $P3609["@BLOCK"]
    unless_null $P3610, vivify_1825
    $P3610 = root_new ['parrot';'ResizablePMCArray']
  vivify_1825:
    set $P3611, $P3610[0]
    unless_null $P3611, vivify_1826
    new $P3611, "Undef"
  vivify_1826:
    find_lex $P3612, "$/"
    unless_null $P3612, vivify_1827
    $P3612 = root_new ['parrot';'Hash']
  vivify_1827:
    set $P3613, $P3612["blorst"]
    unless_null $P3613, vivify_1828
    new $P3613, "Undef"
  vivify_1828:
    $P3614 = $P3613."ast"()
    $P3611."push"($P3614)
.annotate 'line', 1095
    find_lex $P3615, "$/"
    get_hll_global $P3616, ["PAST"], "Stmts"
    $P3617 = $P3616."new"()
    $P3618 = $P3615."!make"($P3617)
.annotate 'line', 1093
    .return ($P3618)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("457_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3620
    .param pmc param_3621
.annotate 'line', 1098
    .lex "self", param_3620
    .lex "$/", param_3621
.annotate 'line', 1099
    new $P3622, "Undef"
    .lex "$past", $P3622
    find_lex $P3623, "$/"
    unless_null $P3623, vivify_1829
    $P3623 = root_new ['parrot';'Hash']
  vivify_1829:
    set $P3624, $P3623["blorst"]
    unless_null $P3624, vivify_1830
    new $P3624, "Undef"
  vivify_1830:
    $P3625 = $P3624."ast"()
    store_lex "$past", $P3625
.annotate 'line', 1100
    get_hll_global $P3627, ["PAST"], "Block"
    find_lex $P3628, "$past"
    unless_null $P3628, vivify_1831
    new $P3628, "Undef"
  vivify_1831:
    $P3629 = $P3627."ACCEPTS"($P3628)
    if $P3629, unless_3626_end
.annotate 'line', 1101
    get_hll_global $P3630, ["PAST"], "Block"
    find_lex $P3631, "$past"
    unless_null $P3631, vivify_1832
    new $P3631, "Undef"
  vivify_1832:
    find_lex $P3632, "$/"
    unless_null $P3632, vivify_1833
    new $P3632, "Undef"
  vivify_1833:
    $P3633 = $P3630."new"($P3631, "immediate" :named("blocktype"), $P3632 :named("node"))
    store_lex "$past", $P3633
  unless_3626_end:
.annotate 'line', 1103
    find_lex $P3635, "$past"
    unless_null $P3635, vivify_1834
    new $P3635, "Undef"
  vivify_1834:
    $P3636 = $P3635."handlers"()
    if $P3636, unless_3634_end
.annotate 'line', 1104
    find_lex $P3637, "$past"
    unless_null $P3637, vivify_1835
    new $P3637, "Undef"
  vivify_1835:
    get_hll_global $P3638, ["PAST"], "Control"
.annotate 'line', 1106
    get_hll_global $P3639, ["PAST"], "Stmts"
.annotate 'line', 1107
    get_hll_global $P3640, ["PAST"], "Op"
.annotate 'line', 1108
    get_hll_global $P3641, ["PAST"], "Var"
.annotate 'line', 1109
    get_hll_global $P3642, ["PAST"], "Var"
    $P3643 = $P3642."new"("register" :named("scope"), "exception" :named("name"))
    $P3644 = $P3641."new"($P3643, "handled", "keyed" :named("scope"))
.annotate 'line', 1108
    $P3645 = $P3640."new"($P3644, 1, "bind" :named("pasttype"))
.annotate 'line', 1107
    $P3646 = $P3639."new"($P3645)
.annotate 'line', 1106
    $P3647 = $P3638."new"($P3646, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1104
    new $P3648, "ResizablePMCArray"
    push $P3648, $P3647
    $P3637."handlers"($P3648)
  unless_3634_end:
.annotate 'line', 1118
    find_lex $P3649, "$/"
    find_lex $P3650, "$past"
    unless_null $P3650, vivify_1836
    new $P3650, "Undef"
  vivify_1836:
    $P3651 = $P3649."!make"($P3650)
.annotate 'line', 1098
    .return ($P3651)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("458_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3653
    .param pmc param_3654
.annotate 'line', 1121
    .lex "self", param_3653
    .lex "$/", param_3654
.annotate 'line', 1122
    find_lex $P3655, "$/"
.annotate 'line', 1123
    find_lex $P3658, "$/"
    unless_null $P3658, vivify_1837
    $P3658 = root_new ['parrot';'Hash']
  vivify_1837:
    set $P3659, $P3658["block"]
    unless_null $P3659, vivify_1838
    new $P3659, "Undef"
  vivify_1838:
    if $P3659, if_3657
.annotate 'line', 1124
    find_lex $P3664, "$/"
    unless_null $P3664, vivify_1839
    $P3664 = root_new ['parrot';'Hash']
  vivify_1839:
    set $P3665, $P3664["statement"]
    unless_null $P3665, vivify_1840
    new $P3665, "Undef"
  vivify_1840:
    $P3666 = $P3665."ast"()
    set $P3656, $P3666
.annotate 'line', 1123
    goto if_3657_end
  if_3657:
    find_lex $P3660, "$/"
    unless_null $P3660, vivify_1841
    $P3660 = root_new ['parrot';'Hash']
  vivify_1841:
    set $P3661, $P3660["block"]
    unless_null $P3661, vivify_1842
    new $P3661, "Undef"
  vivify_1842:
    $P3662 = $P3661."ast"()
    $P3663 = "block_immediate"($P3662)
    set $P3656, $P3663
  if_3657_end:
    $P3667 = $P3655."!make"($P3656)
.annotate 'line', 1121
    .return ($P3667)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("459_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3669
    .param pmc param_3670
.annotate 'line', 1129
    .lex "self", param_3669
    .lex "$/", param_3670
    find_lex $P3671, "$/"
    find_lex $P3672, "$/"
    unless_null $P3672, vivify_1843
    $P3672 = root_new ['parrot';'Hash']
  vivify_1843:
    set $P3673, $P3672["cond"]
    unless_null $P3673, vivify_1844
    new $P3673, "Undef"
  vivify_1844:
    $P3674 = $P3673."ast"()
    $P3675 = $P3671."!make"($P3674)
    .return ($P3675)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("460_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3677
    .param pmc param_3678
.annotate 'line', 1130
    .lex "self", param_3677
    .lex "$/", param_3678
    find_lex $P3679, "$/"
    find_lex $P3680, "$/"
    unless_null $P3680, vivify_1845
    $P3680 = root_new ['parrot';'Hash']
  vivify_1845:
    set $P3681, $P3680["cond"]
    unless_null $P3681, vivify_1846
    new $P3681, "Undef"
  vivify_1846:
    $P3682 = $P3681."ast"()
    $P3683 = $P3679."!make"($P3682)
    .return ($P3683)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("461_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3685
    .param pmc param_3686
.annotate 'line', 1132
    .lex "self", param_3685
    .lex "$/", param_3686
    find_lex $P3687, "$/"
    find_lex $P3688, "$/"
    unless_null $P3688, vivify_1847
    $P3688 = root_new ['parrot';'Hash']
  vivify_1847:
    set $P3689, $P3688["cond"]
    unless_null $P3689, vivify_1848
    new $P3689, "Undef"
  vivify_1848:
    $P3690 = $P3689."ast"()
    $P3691 = $P3687."!make"($P3690)
    .return ($P3691)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("462_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3693
    .param pmc param_3694
.annotate 'line', 1133
    .lex "self", param_3693
    .lex "$/", param_3694
    find_lex $P3695, "$/"
    find_lex $P3696, "$/"
    unless_null $P3696, vivify_1849
    $P3696 = root_new ['parrot';'Hash']
  vivify_1849:
    set $P3697, $P3696["cond"]
    unless_null $P3697, vivify_1850
    new $P3697, "Undef"
  vivify_1850:
    $P3698 = $P3697."ast"()
    $P3699 = $P3695."!make"($P3698)
    .return ($P3699)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("463_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3701
    .param pmc param_3702
.annotate 'line', 1137
    .lex "self", param_3701
    .lex "$/", param_3702
    find_lex $P3703, "$/"
    find_lex $P3704, "$/"
    unless_null $P3704, vivify_1851
    $P3704 = root_new ['parrot';'Hash']
  vivify_1851:
    set $P3705, $P3704["fatarrow"]
    unless_null $P3705, vivify_1852
    new $P3705, "Undef"
  vivify_1852:
    $P3706 = $P3705."ast"()
    $P3707 = $P3703."!make"($P3706)
    .return ($P3707)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("464_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3709
    .param pmc param_3710
.annotate 'line', 1138
    .lex "self", param_3709
    .lex "$/", param_3710
    find_lex $P3711, "$/"
    find_lex $P3712, "$/"
    unless_null $P3712, vivify_1853
    $P3712 = root_new ['parrot';'Hash']
  vivify_1853:
    set $P3713, $P3712["colonpair"]
    unless_null $P3713, vivify_1854
    new $P3713, "Undef"
  vivify_1854:
    $P3714 = $P3713."ast"()
    $P3715 = $P3711."!make"($P3714)
    .return ($P3715)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("465_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3717
    .param pmc param_3718
.annotate 'line', 1139
    .lex "self", param_3717
    .lex "$/", param_3718
    find_lex $P3719, "$/"
    find_lex $P3720, "$/"
    unless_null $P3720, vivify_1855
    $P3720 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P3721, $P3720["variable"]
    unless_null $P3721, vivify_1856
    new $P3721, "Undef"
  vivify_1856:
    $P3722 = $P3721."ast"()
    $P3723 = $P3719."!make"($P3722)
    .return ($P3723)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("466_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3725
    .param pmc param_3726
.annotate 'line', 1140
    .lex "self", param_3725
    .lex "$/", param_3726
    find_lex $P3727, "$/"
    find_lex $P3728, "$/"
    unless_null $P3728, vivify_1857
    $P3728 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P3729, $P3728["package_declarator"]
    unless_null $P3729, vivify_1858
    new $P3729, "Undef"
  vivify_1858:
    $P3730 = $P3729."ast"()
    $P3731 = $P3727."!make"($P3730)
    .return ($P3731)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("467_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3733
    .param pmc param_3734
.annotate 'line', 1141
    .lex "self", param_3733
    .lex "$/", param_3734
    find_lex $P3735, "$/"
    find_lex $P3736, "$/"
    unless_null $P3736, vivify_1859
    $P3736 = root_new ['parrot';'Hash']
  vivify_1859:
    set $P3737, $P3736["scope_declarator"]
    unless_null $P3737, vivify_1860
    new $P3737, "Undef"
  vivify_1860:
    $P3738 = $P3737."ast"()
    $P3739 = $P3735."!make"($P3738)
    .return ($P3739)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("468_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3741
    .param pmc param_3742
.annotate 'line', 1142
    .lex "self", param_3741
    .lex "$/", param_3742
    find_lex $P3743, "$/"
    find_lex $P3744, "$/"
    unless_null $P3744, vivify_1861
    $P3744 = root_new ['parrot';'Hash']
  vivify_1861:
    set $P3745, $P3744["routine_declarator"]
    unless_null $P3745, vivify_1862
    new $P3745, "Undef"
  vivify_1862:
    $P3746 = $P3745."ast"()
    $P3747 = $P3743."!make"($P3746)
    .return ($P3747)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("469_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3749
    .param pmc param_3750
.annotate 'line', 1143
    .lex "self", param_3749
    .lex "$/", param_3750
    find_lex $P3751, "$/"
    find_lex $P3752, "$/"
    unless_null $P3752, vivify_1863
    $P3752 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P3753, $P3752["regex_declarator"]
    unless_null $P3753, vivify_1864
    new $P3753, "Undef"
  vivify_1864:
    $P3754 = $P3753."ast"()
    $P3755 = $P3751."!make"($P3754)
    .return ($P3755)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("470_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3757
    .param pmc param_3758
.annotate 'line', 1144
    .lex "self", param_3757
    .lex "$/", param_3758
    find_lex $P3759, "$/"
    find_lex $P3760, "$/"
    unless_null $P3760, vivify_1865
    $P3760 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P3761, $P3760["statement_prefix"]
    unless_null $P3761, vivify_1866
    new $P3761, "Undef"
  vivify_1866:
    $P3762 = $P3761."ast"()
    $P3763 = $P3759."!make"($P3762)
    .return ($P3763)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("471_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3765
    .param pmc param_3766
.annotate 'line', 1145
    .lex "self", param_3765
    .lex "$/", param_3766
    find_lex $P3767, "$/"
    find_lex $P3768, "$/"
    unless_null $P3768, vivify_1867
    $P3768 = root_new ['parrot';'Hash']
  vivify_1867:
    set $P3769, $P3768["pblock"]
    unless_null $P3769, vivify_1868
    new $P3769, "Undef"
  vivify_1868:
    $P3770 = $P3769."ast"()
    $P3771 = $P3767."!make"($P3770)
    .return ($P3771)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("472_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3773
    .param pmc param_3774
.annotate 'line', 1147
    .lex "self", param_3773
    .lex "$/", param_3774
.annotate 'line', 1148
    new $P3775, "Undef"
    .lex "$past", $P3775
    find_lex $P3776, "$/"
    unless_null $P3776, vivify_1869
    $P3776 = root_new ['parrot';'Hash']
  vivify_1869:
    set $P3777, $P3776["val"]
    unless_null $P3777, vivify_1870
    new $P3777, "Undef"
  vivify_1870:
    $P3778 = $P3777."ast"()
    store_lex "$past", $P3778
.annotate 'line', 1149
    find_lex $P3779, "$past"
    unless_null $P3779, vivify_1871
    new $P3779, "Undef"
  vivify_1871:
    find_lex $P3780, "$/"
    unless_null $P3780, vivify_1872
    $P3780 = root_new ['parrot';'Hash']
  vivify_1872:
    set $P3781, $P3780["key"]
    unless_null $P3781, vivify_1873
    new $P3781, "Undef"
  vivify_1873:
    $P3782 = $P3781."Str"()
    $P3779."named"($P3782)
.annotate 'line', 1150
    find_lex $P3783, "$/"
    find_lex $P3784, "$past"
    unless_null $P3784, vivify_1874
    new $P3784, "Undef"
  vivify_1874:
    $P3785 = $P3783."!make"($P3784)
.annotate 'line', 1147
    .return ($P3785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("473_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3787
    .param pmc param_3788
.annotate 'line', 1153
    .lex "self", param_3787
    .lex "$/", param_3788
.annotate 'line', 1154
    new $P3789, "Undef"
    .lex "$past", $P3789
.annotate 'line', 1155
    find_lex $P3792, "$/"
    unless_null $P3792, vivify_1875
    $P3792 = root_new ['parrot';'Hash']
  vivify_1875:
    set $P3793, $P3792["circumfix"]
    unless_null $P3793, vivify_1876
    new $P3793, "Undef"
  vivify_1876:
    if $P3793, if_3791
.annotate 'line', 1156
    get_hll_global $P3798, ["PAST"], "Val"
    find_lex $P3799, "$/"
    unless_null $P3799, vivify_1877
    $P3799 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P3800, $P3799["not"]
    unless_null $P3800, vivify_1878
    new $P3800, "Undef"
  vivify_1878:
    isfalse $I3801, $P3800
    $P3802 = $P3798."new"($I3801 :named("value"))
    set $P3790, $P3802
.annotate 'line', 1155
    goto if_3791_end
  if_3791:
    find_lex $P3794, "$/"
    unless_null $P3794, vivify_1879
    $P3794 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P3795, $P3794["circumfix"]
    unless_null $P3795, vivify_1880
    $P3795 = root_new ['parrot';'ResizablePMCArray']
  vivify_1880:
    set $P3796, $P3795[0]
    unless_null $P3796, vivify_1881
    new $P3796, "Undef"
  vivify_1881:
    $P3797 = $P3796."ast"()
    set $P3790, $P3797
  if_3791_end:
    store_lex "$past", $P3790
.annotate 'line', 1157
    find_lex $P3803, "$past"
    unless_null $P3803, vivify_1882
    new $P3803, "Undef"
  vivify_1882:
    find_lex $P3804, "$/"
    unless_null $P3804, vivify_1883
    $P3804 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P3805, $P3804["identifier"]
    unless_null $P3805, vivify_1884
    new $P3805, "Undef"
  vivify_1884:
    set $S3806, $P3805
    $P3803."named"($S3806)
.annotate 'line', 1158
    find_lex $P3807, "$/"
    find_lex $P3808, "$past"
    unless_null $P3808, vivify_1885
    new $P3808, "Undef"
  vivify_1885:
    $P3809 = $P3807."!make"($P3808)
.annotate 'line', 1153
    .return ($P3809)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("474_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3811
    .param pmc param_3812
.annotate 'line', 1161
    .const 'Sub' $P3825 = "475_1303603603.711" 
    capture_lex $P3825
    .lex "self", param_3811
    .lex "$/", param_3812
.annotate 'line', 1162
    new $P3813, "Undef"
    .lex "$past", $P3813
.annotate 'line', 1161
    find_lex $P3814, "$past"
    unless_null $P3814, vivify_1886
    new $P3814, "Undef"
  vivify_1886:
.annotate 'line', 1163
    find_lex $P3816, "$/"
    unless_null $P3816, vivify_1887
    $P3816 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P3817, $P3816["postcircumfix"]
    unless_null $P3817, vivify_1888
    new $P3817, "Undef"
  vivify_1888:
    if $P3817, if_3815
.annotate 'line', 1167
    .const 'Sub' $P3825 = "475_1303603603.711" 
    capture_lex $P3825
    $P3825()
    goto if_3815_end
  if_3815:
.annotate 'line', 1164
    find_lex $P3818, "$/"
    unless_null $P3818, vivify_1924
    $P3818 = root_new ['parrot';'Hash']
  vivify_1924:
    set $P3819, $P3818["postcircumfix"]
    unless_null $P3819, vivify_1925
    new $P3819, "Undef"
  vivify_1925:
    $P3820 = $P3819."ast"()
    store_lex "$past", $P3820
.annotate 'line', 1165
    find_lex $P3821, "$past"
    unless_null $P3821, vivify_1926
    new $P3821, "Undef"
  vivify_1926:
    get_hll_global $P3822, ["PAST"], "Var"
    $P3823 = $P3822."new"("$/" :named("name"))
    $P3821."unshift"($P3823)
  if_3815_end:
.annotate 'line', 1209
    find_lex $P3918, "$/"
    find_lex $P3919, "$past"
    unless_null $P3919, vivify_1927
    new $P3919, "Undef"
  vivify_1927:
    $P3920 = $P3918."!make"($P3919)
.annotate 'line', 1161
    .return ($P3920)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3824"  :anon :subid("475_1303603603.711") :outer("474_1303603603.711")
.annotate 'line', 1168
    $P3826 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3826
    get_hll_global $P3827, ["NQP"], "Compiler"
    find_lex $P3828, "$/"
    unless_null $P3828, vivify_1889
    new $P3828, "Undef"
  vivify_1889:
    set $S3829, $P3828
    $P3830 = $P3827."parse_name"($S3829)
    store_lex "@name", $P3830
.annotate 'line', 1169
    find_lex $P3833, "@name"
    unless_null $P3833, vivify_1890
    $P3833 = root_new ['parrot';'ResizablePMCArray']
  vivify_1890:
    set $N3834, $P3833
    isgt $I3835, $N3834, 1.0
    if $I3835, if_3832
.annotate 'line', 1176
    find_lex $P3851, "$/"
    unless_null $P3851, vivify_1891
    $P3851 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P3852, $P3851["twigil"]
    unless_null $P3852, vivify_1892
    $P3852 = root_new ['parrot';'ResizablePMCArray']
  vivify_1892:
    set $P3853, $P3852[0]
    unless_null $P3853, vivify_1893
    new $P3853, "Undef"
  vivify_1893:
    set $S3854, $P3853
    iseq $I3855, $S3854, "*"
    if $I3855, if_3850
.annotate 'line', 1191
    find_lex $P3879, "$/"
    unless_null $P3879, vivify_1894
    $P3879 = root_new ['parrot';'Hash']
  vivify_1894:
    set $P3880, $P3879["twigil"]
    unless_null $P3880, vivify_1895
    $P3880 = root_new ['parrot';'ResizablePMCArray']
  vivify_1895:
    set $P3881, $P3880[0]
    unless_null $P3881, vivify_1896
    new $P3881, "Undef"
  vivify_1896:
    set $S3882, $P3881
    iseq $I3883, $S3882, "!"
    if $I3883, if_3878
.annotate 'line', 1199
    find_lex $P3898, "@name"
    unless_null $P3898, vivify_1897
    $P3898 = root_new ['parrot';'ResizablePMCArray']
  vivify_1897:
    set $P3899, $P3898[0]
    unless_null $P3899, vivify_1898
    new $P3899, "Undef"
  vivify_1898:
    set $S3900, $P3899
    $P3901 = "is_package"($S3900)
    if $P3901, if_3897
.annotate 'line', 1204
    get_hll_global $P3910, ["PAST"], "Var"
.annotate 'line', 1205
    find_lex $P3911, "@name"
    unless_null $P3911, vivify_1899
    $P3911 = root_new ['parrot';'ResizablePMCArray']
  vivify_1899:
    $P3912 = $P3911."pop"()
    set $S3913, $P3912
    find_lex $P3914, "$/"
    unless_null $P3914, vivify_1900
    $P3914 = root_new ['parrot';'Hash']
  vivify_1900:
    set $P3915, $P3914["sigil"]
    unless_null $P3915, vivify_1901
    new $P3915, "Undef"
  vivify_1901:
    $P3916 = "vivitype"($P3915)
    $P3917 = $P3910."new"($S3913 :named("name"), $P3916 :named("viviself"))
.annotate 'line', 1204
    store_lex "$past", $P3917
.annotate 'line', 1203
    set $P3896, $P3917
.annotate 'line', 1199
    goto if_3897_end
  if_3897:
.annotate 'line', 1200
    find_lex $P3902, "@name"
    unless_null $P3902, vivify_1902
    $P3902 = root_new ['parrot';'ResizablePMCArray']
  vivify_1902:
    find_lex $P3903, "$/"
    unless_null $P3903, vivify_1903
    new $P3903, "Undef"
  vivify_1903:
    $P3904 = "lexical_package_lookup"($P3902, $P3903)
    store_lex "$past", $P3904
.annotate 'line', 1201
    find_lex $P3905, "$past"
    unless_null $P3905, vivify_1904
    new $P3905, "Undef"
  vivify_1904:
    find_lex $P3906, "$/"
    unless_null $P3906, vivify_1905
    $P3906 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P3907, $P3906["sigil"]
    unless_null $P3907, vivify_1906
    new $P3907, "Undef"
  vivify_1906:
    $P3908 = "vivitype"($P3907)
    $P3909 = $P3905."viviself"($P3908)
.annotate 'line', 1199
    set $P3896, $P3909
  if_3897_end:
    set $P3877, $P3896
.annotate 'line', 1191
    goto if_3878_end
  if_3878:
.annotate 'line', 1192
    get_hll_global $P3884, ["PAST"], "Var"
.annotate 'line', 1193
    find_lex $P3885, "@name"
    unless_null $P3885, vivify_1907
    $P3885 = root_new ['parrot';'ResizablePMCArray']
  vivify_1907:
    $P3886 = $P3885."pop"()
    set $S3887, $P3886
.annotate 'line', 1194
    find_lex $P3888, "$/"
    unless_null $P3888, vivify_1908
    $P3888 = root_new ['parrot';'Hash']
  vivify_1908:
    set $P3889, $P3888["sigil"]
    unless_null $P3889, vivify_1909
    new $P3889, "Undef"
  vivify_1909:
    $P3890 = "vivitype"($P3889)
.annotate 'line', 1195
    get_hll_global $P3891, ["PAST"], "Var"
    $P3892 = $P3891."new"("self" :named("name"))
.annotate 'line', 1196
    get_hll_global $P3893, ["PAST"], "Var"
    $P3894 = $P3893."new"("$?CLASS" :named("name"))
    $P3895 = $P3884."new"($P3892, $P3894, $S3887 :named("name"), "attribute" :named("scope"), $P3890 :named("viviself"))
.annotate 'line', 1192
    store_lex "$past", $P3895
.annotate 'line', 1191
    set $P3877, $P3895
  if_3878_end:
    set $P3849, $P3877
.annotate 'line', 1176
    goto if_3850_end
  if_3850:
.annotate 'line', 1177
    get_hll_global $P3856, ["PAST"], "Var"
.annotate 'line', 1178
    find_lex $P3857, "@name"
    unless_null $P3857, vivify_1910
    $P3857 = root_new ['parrot';'ResizablePMCArray']
  vivify_1910:
    $P3858 = $P3857."pop"()
    set $S3859, $P3858
.annotate 'line', 1180
    get_hll_global $P3860, ["PAST"], "Var"
.annotate 'line', 1182
    find_lex $P3861, "$/"
    unless_null $P3861, vivify_1911
    $P3861 = root_new ['parrot';'Hash']
  vivify_1911:
    set $P3862, $P3861["sigil"]
    unless_null $P3862, vivify_1912
    new $P3862, "Undef"
  vivify_1912:
    set $S3863, $P3862
    new $P3864, 'String'
    set $P3864, $S3863
    find_lex $P3865, "$/"
    unless_null $P3865, vivify_1913
    $P3865 = root_new ['parrot';'Hash']
  vivify_1913:
    set $P3866, $P3865["desigilname"]
    unless_null $P3866, vivify_1914
    new $P3866, "Undef"
  vivify_1914:
    concat $P3867, $P3864, $P3866
.annotate 'line', 1184
    get_hll_global $P3868, ["PAST"], "Op"
    new $P3869, "String"
    assign $P3869, "Contextual "
    find_lex $P3870, "$/"
    unless_null $P3870, vivify_1915
    new $P3870, "Undef"
  vivify_1915:
    set $S3871, $P3870
    concat $P3872, $P3869, $S3871
    concat $P3873, $P3872, " not found"
    $P3874 = $P3868."new"($P3873, "die" :named("pirop"))
    $P3875 = $P3860."new"("package" :named("scope"), "" :named("namespace"), $P3867 :named("name"), $P3874 :named("viviself"))
.annotate 'line', 1180
    $P3876 = $P3856."new"($S3859 :named("name"), "contextual" :named("scope"), $P3875 :named("viviself"))
.annotate 'line', 1177
    store_lex "$past", $P3876
.annotate 'line', 1176
    set $P3849, $P3876
  if_3850_end:
    set $P3831, $P3849
.annotate 'line', 1169
    goto if_3832_end
  if_3832:
.annotate 'line', 1170
    find_lex $P3837, "$/"
    unless_null $P3837, vivify_1916
    $P3837 = root_new ['parrot';'Hash']
  vivify_1916:
    set $P3838, $P3837["twigil"]
    unless_null $P3838, vivify_1917
    new $P3838, "Undef"
  vivify_1917:
    unless $P3838, if_3836_end
.annotate 'line', 1171
    find_lex $P3839, "$/"
    unless_null $P3839, vivify_1918
    new $P3839, "Undef"
  vivify_1918:
    $P3840 = $P3839."CURSOR"()
    $P3840."panic"("Twigil not allowed on multi-part name")
  if_3836_end:
.annotate 'line', 1173
    find_lex $P3841, "@name"
    unless_null $P3841, vivify_1919
    $P3841 = root_new ['parrot';'ResizablePMCArray']
  vivify_1919:
    find_lex $P3842, "$/"
    unless_null $P3842, vivify_1920
    new $P3842, "Undef"
  vivify_1920:
    $P3843 = "lexical_package_lookup"($P3841, $P3842)
    store_lex "$past", $P3843
.annotate 'line', 1174
    find_lex $P3844, "$past"
    unless_null $P3844, vivify_1921
    new $P3844, "Undef"
  vivify_1921:
    find_lex $P3845, "$/"
    unless_null $P3845, vivify_1922
    $P3845 = root_new ['parrot';'Hash']
  vivify_1922:
    set $P3846, $P3845["sigil"]
    unless_null $P3846, vivify_1923
    new $P3846, "Undef"
  vivify_1923:
    $P3847 = "vivitype"($P3846)
    $P3848 = $P3844."viviself"($P3847)
.annotate 'line', 1169
    set $P3831, $P3848
  if_3832_end:
.annotate 'line', 1167
    .return ($P3831)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("476_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3922
    .param pmc param_3923
.annotate 'line', 1212
    .lex "self", param_3922
    .lex "$/", param_3923
    find_lex $P3924, "$/"
    find_lex $P3925, "$/"
    unless_null $P3925, vivify_1928
    $P3925 = root_new ['parrot';'Hash']
  vivify_1928:
    set $P3926, $P3925["package_def"]
    unless_null $P3926, vivify_1929
    new $P3926, "Undef"
  vivify_1929:
    $P3927 = $P3926."ast"()
    $P3928 = $P3924."!make"($P3927)
    .return ($P3928)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("477_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3930
    .param pmc param_3931
.annotate 'line', 1213
    .lex "self", param_3930
    .lex "$/", param_3931
    find_lex $P3932, "$/"
    find_lex $P3933, "$/"
    unless_null $P3933, vivify_1930
    $P3933 = root_new ['parrot';'Hash']
  vivify_1930:
    set $P3934, $P3933["package_def"]
    unless_null $P3934, vivify_1931
    new $P3934, "Undef"
  vivify_1931:
    $P3935 = $P3934."ast"()
    $P3936 = $P3932."!make"($P3935)
    .return ($P3936)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("478_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3938
    .param pmc param_3939
.annotate 'line', 1214
    .lex "self", param_3938
    .lex "$/", param_3939
    find_lex $P3940, "$/"
    find_lex $P3941, "$/"
    unless_null $P3941, vivify_1932
    $P3941 = root_new ['parrot';'Hash']
  vivify_1932:
    set $P3942, $P3941["package_def"]
    unless_null $P3942, vivify_1933
    new $P3942, "Undef"
  vivify_1933:
    $P3943 = $P3942."ast"()
    $P3944 = $P3940."!make"($P3943)
    .return ($P3944)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("479_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3946
    .param pmc param_3947
.annotate 'line', 1215
    .lex "self", param_3946
    .lex "$/", param_3947
    find_lex $P3948, "$/"
    find_lex $P3949, "$/"
    unless_null $P3949, vivify_1934
    $P3949 = root_new ['parrot';'Hash']
  vivify_1934:
    set $P3950, $P3949["package_def"]
    unless_null $P3950, vivify_1935
    new $P3950, "Undef"
  vivify_1935:
    $P3951 = $P3950."ast"()
    $P3952 = $P3948."!make"($P3951)
    .return ($P3952)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("480_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3954
    .param pmc param_3955
.annotate 'line', 1216
    .lex "self", param_3954
    .lex "$/", param_3955
    find_lex $P3956, "$/"
    find_lex $P3957, "$/"
    unless_null $P3957, vivify_1936
    $P3957 = root_new ['parrot';'Hash']
  vivify_1936:
    set $P3958, $P3957["package_def"]
    unless_null $P3958, vivify_1937
    new $P3958, "Undef"
  vivify_1937:
    $P3959 = $P3958."ast"()
    $P3960 = $P3956."!make"($P3959)
    .return ($P3960)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("481_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3962
    .param pmc param_3963
.annotate 'line', 1217
    .lex "self", param_3962
    .lex "$/", param_3963
    find_lex $P3964, "$/"
    find_lex $P3965, "$/"
    unless_null $P3965, vivify_1938
    $P3965 = root_new ['parrot';'Hash']
  vivify_1938:
    set $P3966, $P3965["package_def"]
    unless_null $P3966, vivify_1939
    new $P3966, "Undef"
  vivify_1939:
    $P3967 = $P3966."ast"()
    $P3968 = $P3964."!make"($P3967)
    .return ($P3968)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("482_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_3970
    .param pmc param_3971
.annotate 'line', 1219
    .const 'Sub' $P4122 = "484_1303603603.711" 
    capture_lex $P4122
    .const 'Sub' $P4062 = "483_1303603603.711" 
    capture_lex $P4062
    .lex "self", param_3970
    .lex "$/", param_3971
.annotate 'line', 1221
    $P3972 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3972
.annotate 'line', 1222
    new $P3973, "Undef"
    .lex "$name", $P3973
.annotate 'line', 1223
    new $P3974, "Undef"
    .lex "$how", $P3974
.annotate 'line', 1226
    new $P3975, "Undef"
    .lex "$past", $P3975
.annotate 'line', 1221
    find_lex $P3976, "$/"
    unless_null $P3976, vivify_1940
    $P3976 = root_new ['parrot';'Hash']
  vivify_1940:
    set $P3977, $P3976["name"]
    unless_null $P3977, vivify_1941
    $P3977 = root_new ['parrot';'Hash']
  vivify_1941:
    set $P3978, $P3977["identifier"]
    unless_null $P3978, vivify_1942
    new $P3978, "Undef"
  vivify_1942:
    clone $P3979, $P3978
    store_lex "@ns", $P3979
.annotate 'line', 1222
    find_lex $P3980, "@ns"
    unless_null $P3980, vivify_1943
    $P3980 = root_new ['parrot';'ResizablePMCArray']
  vivify_1943:
    $P3981 = $P3980."pop"()
    set $S3982, $P3981
    new $P3983, 'String'
    set $P3983, $S3982
    store_lex "$name", $P3983
.annotate 'line', 1223
    find_dynamic_lex $P3984, "$*PKGDECL"
    unless_null $P3984, vivify_1944
    get_hll_global $P3984, "$PKGDECL"
    unless_null $P3984, vivify_1945
    die "Contextual $*PKGDECL not found"
  vivify_1945:
  vivify_1944:
    find_dynamic_lex $P3985, "%*HOW"
    unless_null $P3985, vivify_1946
    get_hll_global $P3985, "%HOW"
    unless_null $P3985, vivify_1947
    die "Contextual %*HOW not found"
  vivify_1947:
  vivify_1946:
    set $P3986, $P3985[$P3984]
    unless_null $P3986, vivify_1948
    new $P3986, "Undef"
  vivify_1948:
    store_lex "$how", $P3986
.annotate 'line', 1226
    find_lex $P3989, "$/"
    unless_null $P3989, vivify_1949
    $P3989 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P3990, $P3989["block"]
    unless_null $P3990, vivify_1950
    new $P3990, "Undef"
  vivify_1950:
    if $P3990, if_3988
    find_lex $P3994, "$/"
    unless_null $P3994, vivify_1951
    $P3994 = root_new ['parrot';'Hash']
  vivify_1951:
    set $P3995, $P3994["comp_unit"]
    unless_null $P3995, vivify_1952
    new $P3995, "Undef"
  vivify_1952:
    $P3996 = $P3995."ast"()
    set $P3987, $P3996
    goto if_3988_end
  if_3988:
    find_lex $P3991, "$/"
    unless_null $P3991, vivify_1953
    $P3991 = root_new ['parrot';'Hash']
  vivify_1953:
    set $P3992, $P3991["block"]
    unless_null $P3992, vivify_1954
    new $P3992, "Undef"
  vivify_1954:
    $P3993 = $P3992."ast"()
    set $P3987, $P3993
  if_3988_end:
    store_lex "$past", $P3987
.annotate 'line', 1227
    find_dynamic_lex $P4000, "$*SCOPE"
    unless_null $P4000, vivify_1955
    get_hll_global $P4000, "$SCOPE"
    unless_null $P4000, vivify_1956
    die "Contextual $*SCOPE not found"
  vivify_1956:
  vivify_1955:
    set $S4001, $P4000
    iseq $I4002, $S4001, "our"
    unless $I4002, unless_3999
    new $P3998, 'Integer'
    set $P3998, $I4002
    goto unless_3999_end
  unless_3999:
    find_dynamic_lex $P4003, "$*SCOPE"
    unless_null $P4003, vivify_1957
    get_hll_global $P4003, "$SCOPE"
    unless_null $P4003, vivify_1958
    die "Contextual $*SCOPE not found"
  vivify_1958:
  vivify_1957:
    set $S4004, $P4003
    iseq $I4005, $S4004, ""
    new $P3998, 'Integer'
    set $P3998, $I4005
  unless_3999_end:
    unless $P3998, if_3997_end
.annotate 'line', 1228
    find_lex $P4006, "$past"
    unless_null $P4006, vivify_1959
    new $P4006, "Undef"
  vivify_1959:
    find_lex $P4007, "$/"
    unless_null $P4007, vivify_1960
    $P4007 = root_new ['parrot';'Hash']
  vivify_1960:
    set $P4008, $P4007["name"]
    unless_null $P4008, vivify_1961
    $P4008 = root_new ['parrot';'Hash']
  vivify_1961:
    set $P4009, $P4008["identifier"]
    unless_null $P4009, vivify_1962
    new $P4009, "Undef"
  vivify_1962:
    $P4006."namespace"($P4009)
  if_3997_end:
.annotate 'line', 1232
    find_dynamic_lex $P4010, "$*PACKAGE-SETUP"
    unless_null $P4010, vivify_1963
    get_hll_global $P4010, "$PACKAGE-SETUP"
    unless_null $P4010, vivify_1964
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1964:
  vivify_1963:
    get_hll_global $P4011, ["PAST"], "Stmts"
.annotate 'line', 1233
    get_hll_global $P4012, ["PAST"], "Op"
.annotate 'line', 1234
    get_hll_global $P4013, ["PAST"], "Var"
    $P4014 = $P4013."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1235
    find_dynamic_lex $P4015, "$*SC"
    unless_null $P4015, vivify_1965
    get_hll_global $P4015, "$SC"
    unless_null $P4015, vivify_1966
    die "Contextual $*SC not found"
  vivify_1966:
  vivify_1965:
    find_dynamic_lex $P4016, "$*PACKAGE"
    unless_null $P4016, vivify_1967
    get_hll_global $P4016, "$PACKAGE"
    unless_null $P4016, vivify_1968
    die "Contextual $*PACKAGE not found"
  vivify_1968:
  vivify_1967:
    $P4017 = $P4015."get_slot_past_for_object"($P4016)
    $P4018 = $P4012."new"($P4014, $P4017, "bind" :named("pasttype"))
.annotate 'line', 1233
    $P4019 = $P4011."new"($P4018)
.annotate 'line', 1232
    $P4010."unshift"($P4019)
.annotate 'line', 1244
    find_lex $P4023, "$how"
    unless_null $P4023, vivify_1969
    new $P4023, "Undef"
  vivify_1969:
    can $I4024, $P4023, "parametric"
    if $I4024, if_4022
    new $P4021, 'Integer'
    set $P4021, $I4024
    goto if_4022_end
  if_4022:
    find_lex $P4025, "$how"
    unless_null $P4025, vivify_1970
    new $P4025, "Undef"
  vivify_1970:
    find_lex $P4026, "$how"
    unless_null $P4026, vivify_1971
    new $P4026, "Undef"
  vivify_1971:
    $P4027 = $P4025."parametric"($P4026)
    set $P4021, $P4027
  if_4022_end:
    if $P4021, if_4020
.annotate 'line', 1262
    find_lex $P4051, "$past"
    unless_null $P4051, vivify_1972
    new $P4051, "Undef"
  vivify_1972:
    $P4051."blocktype"("immediate")
.annotate 'line', 1263
    find_dynamic_lex $P4052, "$*SC"
    unless_null $P4052, vivify_1973
    get_hll_global $P4052, "$SC"
    unless_null $P4052, vivify_1974
    die "Contextual $*SC not found"
  vivify_1974:
  vivify_1973:
    find_lex $P4053, "$past"
    unless_null $P4053, vivify_1975
    new $P4053, "Undef"
  vivify_1975:
    find_dynamic_lex $P4054, "$*PACKAGE"
    unless_null $P4054, vivify_1976
    get_hll_global $P4054, "$PACKAGE"
    unless_null $P4054, vivify_1977
    die "Contextual $*PACKAGE not found"
  vivify_1977:
  vivify_1976:
    $P4052."install_lexical_symbol"($P4053, "$?PACKAGE", $P4054)
.annotate 'line', 1264
    find_dynamic_lex $P4055, "$*SC"
    unless_null $P4055, vivify_1978
    get_hll_global $P4055, "$SC"
    unless_null $P4055, vivify_1979
    die "Contextual $*SC not found"
  vivify_1979:
  vivify_1978:
    find_lex $P4056, "$past"
    unless_null $P4056, vivify_1980
    new $P4056, "Undef"
  vivify_1980:
    find_dynamic_lex $P4057, "$*PACKAGE"
    unless_null $P4057, vivify_1981
    get_hll_global $P4057, "$PACKAGE"
    unless_null $P4057, vivify_1982
    die "Contextual $*PACKAGE not found"
  vivify_1982:
  vivify_1981:
    $P4055."install_lexical_symbol"($P4056, "$?CLASS", $P4057)
.annotate 'line', 1261
    goto if_4020_end
  if_4020:
.annotate 'line', 1245
    find_lex $P4028, "$past"
    unless_null $P4028, vivify_1983
    new $P4028, "Undef"
  vivify_1983:
    $P4028."blocktype"("declaration")
.annotate 'line', 1246
    find_lex $P4029, "$past"
    unless_null $P4029, vivify_1984
    new $P4029, "Undef"
  vivify_1984:
    get_hll_global $P4030, ["PAST"], "Var"
    $P4031 = $P4030."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4029."unshift"($P4031)
.annotate 'line', 1247
    find_lex $P4032, "$past"
    unless_null $P4032, vivify_1985
    new $P4032, "Undef"
  vivify_1985:
    $P4032."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1248
    find_dynamic_lex $P4033, "$*PACKAGE-SETUP"
    unless_null $P4033, vivify_1986
    get_hll_global $P4033, "$PACKAGE-SETUP"
    unless_null $P4033, vivify_1987
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1987:
  vivify_1986:
    get_hll_global $P4034, ["PAST"], "Op"
.annotate 'line', 1250
    get_hll_global $P4035, ["PAST"], "Op"
.annotate 'line', 1253
    get_hll_global $P4036, ["PAST"], "Var"
    $P4037 = $P4036."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4038 = $P4035."new"($P4037, "get_how PP" :named("pirop"))
.annotate 'line', 1255
    get_hll_global $P4039, ["PAST"], "Var"
    $P4040 = $P4039."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1256
    get_hll_global $P4041, ["PAST"], "Val"
    find_lex $P4042, "$past"
    unless_null $P4042, vivify_1988
    new $P4042, "Undef"
  vivify_1988:
    $P4043 = $P4041."new"($P4042 :named("value"))
    $P4044 = $P4034."new"($P4038, $P4040, $P4043, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1248
    $P4033."push"($P4044)
.annotate 'line', 1258
    find_dynamic_lex $P4045, "$*SC"
    unless_null $P4045, vivify_1989
    get_hll_global $P4045, "$SC"
    unless_null $P4045, vivify_1990
    die "Contextual $*SC not found"
  vivify_1990:
  vivify_1989:
    find_lex $P4046, "$past"
    unless_null $P4046, vivify_1991
    new $P4046, "Undef"
  vivify_1991:
    find_dynamic_lex $P4047, "$*PACKAGE"
    unless_null $P4047, vivify_1992
    get_hll_global $P4047, "$PACKAGE"
    unless_null $P4047, vivify_1993
    die "Contextual $*PACKAGE not found"
  vivify_1993:
  vivify_1992:
    $P4045."install_lexical_symbol"($P4046, "$?PACKAGE", $P4047)
.annotate 'line', 1259
    find_dynamic_lex $P4048, "$*SC"
    unless_null $P4048, vivify_1994
    get_hll_global $P4048, "$SC"
    unless_null $P4048, vivify_1995
    die "Contextual $*SC not found"
  vivify_1995:
  vivify_1994:
    find_lex $P4049, "$past"
    unless_null $P4049, vivify_1996
    new $P4049, "Undef"
  vivify_1996:
    find_dynamic_lex $P4050, "$*PACKAGE"
    unless_null $P4050, vivify_1997
    get_hll_global $P4050, "$PACKAGE"
    unless_null $P4050, vivify_1998
    die "Contextual $*PACKAGE not found"
  vivify_1998:
  vivify_1997:
    $P4048."install_lexical_symbol"($P4049, "$?ROLE", $P4050)
  if_4020_end:
.annotate 'line', 1269
    find_lex $P4059, "$/"
    unless_null $P4059, vivify_1999
    $P4059 = root_new ['parrot';'Hash']
  vivify_1999:
    set $P4060, $P4059["parent"]
    unless_null $P4060, vivify_2000
    new $P4060, "Undef"
  vivify_2000:
    if $P4060, if_4058
.annotate 'line', 1283
    find_lex $P4090, "$how"
    unless_null $P4090, vivify_2001
    new $P4090, "Undef"
  vivify_2001:
    can $I4091, $P4090, "set_default_parent"
    unless $I4091, if_4089_end
.annotate 'line', 1285
    find_dynamic_lex $P4092, "$*PACKAGE-SETUP"
    unless_null $P4092, vivify_2002
    get_hll_global $P4092, "$PACKAGE-SETUP"
    unless_null $P4092, vivify_2003
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2003:
  vivify_2002:
    get_hll_global $P4093, ["PAST"], "Op"
.annotate 'line', 1287
    get_hll_global $P4094, ["PAST"], "Op"
.annotate 'line', 1290
    get_hll_global $P4095, ["PAST"], "Var"
    $P4096 = $P4095."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4097 = $P4094."new"($P4096, "get_how PP" :named("pirop"))
.annotate 'line', 1292
    get_hll_global $P4098, ["PAST"], "Var"
    $P4099 = $P4098."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1293
    find_dynamic_lex $P4102, "$*PKGDECL"
    unless_null $P4102, vivify_2004
    get_hll_global $P4102, "$PKGDECL"
    unless_null $P4102, vivify_2005
    die "Contextual $*PKGDECL not found"
  vivify_2005:
  vivify_2004:
    set $S4103, $P4102
    iseq $I4104, $S4103, "grammar"
    if $I4104, if_4101
.annotate 'line', 1295
    find_dynamic_lex $P4107, "$*SC"
    unless_null $P4107, vivify_2006
    get_hll_global $P4107, "$SC"
    unless_null $P4107, vivify_2007
    die "Contextual $*SC not found"
  vivify_2007:
  vivify_2006:
    new $P4108, "ResizablePMCArray"
    push $P4108, "NQPMu"
    find_lex $P4109, "$/"
    unless_null $P4109, vivify_2008
    new $P4109, "Undef"
  vivify_2008:
    $P4110 = "find_sym"($P4108, $P4109)
    $P4111 = $P4107."get_object_sc_ref_past"($P4110)
    set $P4100, $P4111
.annotate 'line', 1293
    goto if_4101_end
  if_4101:
.annotate 'line', 1294
    get_hll_global $P4105, ["PAST"], "Var"
    $P4106 = $P4105."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    set $P4100, $P4106
  if_4101_end:
.annotate 'line', 1293
    $P4112 = $P4093."new"($P4097, $P4099, $P4100, "callmethod" :named("pasttype"), "set_default_parent" :named("name"))
.annotate 'line', 1285
    $P4092."push"($P4112)
  if_4089_end:
.annotate 'line', 1283
    goto if_4058_end
  if_4058:
.annotate 'line', 1269
    .const 'Sub' $P4062 = "483_1303603603.711" 
    capture_lex $P4062
    $P4062()
  if_4058_end:
.annotate 'line', 1300
    find_lex $P4114, "$/"
    unless_null $P4114, vivify_2018
    $P4114 = root_new ['parrot';'Hash']
  vivify_2018:
    set $P4115, $P4114["role"]
    unless_null $P4115, vivify_2019
    new $P4115, "Undef"
  vivify_2019:
    unless $P4115, if_4113_end
.annotate 'line', 1301
    find_lex $P4117, "$/"
    unless_null $P4117, vivify_2020
    $P4117 = root_new ['parrot';'Hash']
  vivify_2020:
    set $P4118, $P4117["role"]
    unless_null $P4118, vivify_2021
    new $P4118, "Undef"
  vivify_2021:
    defined $I4119, $P4118
    unless $I4119, for_undef_2022
    iter $P4116, $P4118
    new $P4149, 'ExceptionHandler'
    set_label $P4149, loop4148_handler
    $P4149."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4149
  loop4148_test:
    unless $P4116, loop4148_done
    shift $P4120, $P4116
  loop4148_redo:
    .const 'Sub' $P4122 = "484_1303603603.711" 
    capture_lex $P4122
    $P4122($P4120)
  loop4148_next:
    goto loop4148_test
  loop4148_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4150, exception, 'type'
    eq $P4150, .CONTROL_LOOP_NEXT, loop4148_next
    eq $P4150, .CONTROL_LOOP_REDO, loop4148_redo
  loop4148_done:
    pop_eh 
  for_undef_2022:
  if_4113_end:
.annotate 'line', 1318
    find_dynamic_lex $P4151, "$*PACKAGE-SETUP"
    unless_null $P4151, vivify_2030
    get_hll_global $P4151, "$PACKAGE-SETUP"
    unless_null $P4151, vivify_2031
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2031:
  vivify_2030:
    get_hll_global $P4152, ["PAST"], "Op"
.annotate 'line', 1320
    get_hll_global $P4153, ["PAST"], "Op"
.annotate 'line', 1323
    get_hll_global $P4154, ["PAST"], "Var"
    $P4155 = $P4154."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4156 = $P4153."new"($P4155, "get_how PP" :named("pirop"))
.annotate 'line', 1325
    get_hll_global $P4157, ["PAST"], "Var"
    $P4158 = $P4157."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4159 = $P4152."new"($P4156, $P4158, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1318
    $P4151."push"($P4159)
.annotate 'line', 1329
    find_lex $P4160, "$past"
    unless_null $P4160, vivify_2032
    new $P4160, "Undef"
  vivify_2032:
    $P4161 = $P4160."loadinit"()
    get_hll_global $P4162, ["PAST"], "Block"
    find_dynamic_lex $P4163, "$*PACKAGE-SETUP"
    unless_null $P4163, vivify_2033
    get_hll_global $P4163, "$PACKAGE-SETUP"
    unless_null $P4163, vivify_2034
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2034:
  vivify_2033:
    $P4164 = $P4162."new"($P4163, "immediate" :named("blocktype"))
    $P4161."push"($P4164)
.annotate 'line', 1331
    find_lex $P4165, "$/"
    find_lex $P4166, "$past"
    unless_null $P4166, vivify_2035
    new $P4166, "Undef"
  vivify_2035:
    $P4167 = $P4165."!make"($P4166)
.annotate 'line', 1219
    .return ($P4167)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4061"  :anon :subid("483_1303603603.711") :outer("482_1303603603.711")
.annotate 'line', 1270
    $P4063 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4063
.annotate 'line', 1271
    new $P4064, "Undef"
    .lex "$name", $P4064
.annotate 'line', 1270
    find_lex $P4065, "$/"
    unless_null $P4065, vivify_2009
    $P4065 = root_new ['parrot';'Hash']
  vivify_2009:
    set $P4066, $P4065["parent"]
    unless_null $P4066, vivify_2010
    $P4066 = root_new ['parrot';'ResizablePMCArray']
  vivify_2010:
    set $P4067, $P4066[0]
    unless_null $P4067, vivify_2011
    $P4067 = root_new ['parrot';'Hash']
  vivify_2011:
    set $P4068, $P4067["identifier"]
    unless_null $P4068, vivify_2012
    new $P4068, "Undef"
  vivify_2012:
    clone $P4069, $P4068
    store_lex "@ns", $P4069
.annotate 'line', 1271
    find_lex $P4070, "@ns"
    unless_null $P4070, vivify_2013
    $P4070 = root_new ['parrot';'ResizablePMCArray']
  vivify_2013:
    $P4071 = $P4070."pop"()
    set $S4072, $P4071
    new $P4073, 'String'
    set $P4073, $S4072
    store_lex "$name", $P4073
.annotate 'line', 1272
    find_dynamic_lex $P4074, "$*PACKAGE-SETUP"
    unless_null $P4074, vivify_2014
    get_hll_global $P4074, "$PACKAGE-SETUP"
    unless_null $P4074, vivify_2015
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2015:
  vivify_2014:
    get_hll_global $P4075, ["PAST"], "Op"
.annotate 'line', 1274
    get_hll_global $P4076, ["PAST"], "Op"
.annotate 'line', 1277
    get_hll_global $P4077, ["PAST"], "Var"
    $P4078 = $P4077."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4079 = $P4076."new"($P4078, "get_how PP" :named("pirop"))
.annotate 'line', 1279
    get_hll_global $P4080, ["PAST"], "Var"
    $P4081 = $P4080."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1280
    get_hll_global $P4082, ["PAST"], "Var"
    find_lex $P4083, "$name"
    unless_null $P4083, vivify_2016
    new $P4083, "Undef"
  vivify_2016:
    set $S4084, $P4083
    find_lex $P4085, "@ns"
    unless_null $P4085, vivify_2017
    $P4085 = root_new ['parrot';'ResizablePMCArray']
  vivify_2017:
    $P4086 = $P4082."new"($S4084 :named("name"), $P4085 :named("namespace"), "package" :named("scope"))
    $P4087 = $P4075."new"($P4079, $P4081, $P4086, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1272
    $P4088 = $P4074."push"($P4087)
.annotate 'line', 1269
    .return ($P4088)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4121"  :anon :subid("484_1303603603.711") :outer("482_1303603603.711")
    .param pmc param_4125
.annotate 'line', 1302
    $P4123 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4123
.annotate 'line', 1303
    new $P4124, "Undef"
    .lex "$name", $P4124
    .lex "$_", param_4125
.annotate 'line', 1302
    find_lex $P4126, "$_"
    unless_null $P4126, vivify_2023
    $P4126 = root_new ['parrot';'Hash']
  vivify_2023:
    set $P4127, $P4126["identifier"]
    unless_null $P4127, vivify_2024
    new $P4127, "Undef"
  vivify_2024:
    clone $P4128, $P4127
    store_lex "@ns", $P4128
.annotate 'line', 1303
    find_lex $P4129, "@ns"
    unless_null $P4129, vivify_2025
    $P4129 = root_new ['parrot';'ResizablePMCArray']
  vivify_2025:
    $P4130 = $P4129."pop"()
    set $S4131, $P4130
    new $P4132, 'String'
    set $P4132, $S4131
    store_lex "$name", $P4132
.annotate 'line', 1304
    find_dynamic_lex $P4133, "$*PACKAGE-SETUP"
    unless_null $P4133, vivify_2026
    get_hll_global $P4133, "$PACKAGE-SETUP"
    unless_null $P4133, vivify_2027
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2027:
  vivify_2026:
    get_hll_global $P4134, ["PAST"], "Op"
.annotate 'line', 1306
    get_hll_global $P4135, ["PAST"], "Op"
.annotate 'line', 1309
    get_hll_global $P4136, ["PAST"], "Var"
    $P4137 = $P4136."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4138 = $P4135."new"($P4137, "get_how PP" :named("pirop"))
.annotate 'line', 1311
    get_hll_global $P4139, ["PAST"], "Var"
    $P4140 = $P4139."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1312
    get_hll_global $P4141, ["PAST"], "Var"
    find_lex $P4142, "$name"
    unless_null $P4142, vivify_2028
    new $P4142, "Undef"
  vivify_2028:
    set $S4143, $P4142
    find_lex $P4144, "@ns"
    unless_null $P4144, vivify_2029
    $P4144 = root_new ['parrot';'ResizablePMCArray']
  vivify_2029:
    $P4145 = $P4141."new"($S4143 :named("name"), $P4144 :named("namespace"), "package" :named("scope"))
    $P4146 = $P4134."new"($P4138, $P4140, $P4145, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1304
    $P4147 = $P4133."push"($P4146)
.annotate 'line', 1301
    .return ($P4147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("485_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4169
    .param pmc param_4170
.annotate 'line', 1334
    .lex "self", param_4169
    .lex "$/", param_4170
    find_lex $P4171, "$/"
    find_lex $P4172, "$/"
    unless_null $P4172, vivify_2036
    $P4172 = root_new ['parrot';'Hash']
  vivify_2036:
    set $P4173, $P4172["scoped"]
    unless_null $P4173, vivify_2037
    new $P4173, "Undef"
  vivify_2037:
    $P4174 = $P4173."ast"()
    $P4175 = $P4171."!make"($P4174)
    .return ($P4175)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("486_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4177
    .param pmc param_4178
.annotate 'line', 1335
    .lex "self", param_4177
    .lex "$/", param_4178
    find_lex $P4179, "$/"
    find_lex $P4180, "$/"
    unless_null $P4180, vivify_2038
    $P4180 = root_new ['parrot';'Hash']
  vivify_2038:
    set $P4181, $P4180["scoped"]
    unless_null $P4181, vivify_2039
    new $P4181, "Undef"
  vivify_2039:
    $P4182 = $P4181."ast"()
    $P4183 = $P4179."!make"($P4182)
    .return ($P4183)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("487_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4185
    .param pmc param_4186
.annotate 'line', 1336
    .lex "self", param_4185
    .lex "$/", param_4186
    find_lex $P4187, "$/"
    find_lex $P4188, "$/"
    unless_null $P4188, vivify_2040
    $P4188 = root_new ['parrot';'Hash']
  vivify_2040:
    set $P4189, $P4188["scoped"]
    unless_null $P4189, vivify_2041
    new $P4189, "Undef"
  vivify_2041:
    $P4190 = $P4189."ast"()
    $P4191 = $P4187."!make"($P4190)
    .return ($P4191)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("488_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4193
    .param pmc param_4194
.annotate 'line', 1338
    .lex "self", param_4193
    .lex "$/", param_4194
.annotate 'line', 1339
    find_lex $P4195, "$/"
    find_lex $P4198, "$/"
    unless_null $P4198, vivify_2042
    $P4198 = root_new ['parrot';'Hash']
  vivify_2042:
    set $P4199, $P4198["declarator"]
    unless_null $P4199, vivify_2043
    new $P4199, "Undef"
  vivify_2043:
    if $P4199, if_4197
.annotate 'line', 1340
    find_lex $P4205, "$/"
    unless_null $P4205, vivify_2044
    $P4205 = root_new ['parrot';'Hash']
  vivify_2044:
    set $P4206, $P4205["multi_declarator"]
    unless_null $P4206, vivify_2045
    new $P4206, "Undef"
  vivify_2045:
    if $P4206, if_4204
.annotate 'line', 1341
    find_lex $P4210, "$/"
    unless_null $P4210, vivify_2046
    $P4210 = root_new ['parrot';'Hash']
  vivify_2046:
    set $P4211, $P4210["package_declarator"]
    unless_null $P4211, vivify_2047
    new $P4211, "Undef"
  vivify_2047:
    $P4212 = $P4211."ast"()
    set $P4203, $P4212
.annotate 'line', 1340
    goto if_4204_end
  if_4204:
    find_lex $P4207, "$/"
    unless_null $P4207, vivify_2048
    $P4207 = root_new ['parrot';'Hash']
  vivify_2048:
    set $P4208, $P4207["multi_declarator"]
    unless_null $P4208, vivify_2049
    new $P4208, "Undef"
  vivify_2049:
    $P4209 = $P4208."ast"()
    set $P4203, $P4209
  if_4204_end:
    set $P4196, $P4203
.annotate 'line', 1339
    goto if_4197_end
  if_4197:
    find_lex $P4200, "$/"
    unless_null $P4200, vivify_2050
    $P4200 = root_new ['parrot';'Hash']
  vivify_2050:
    set $P4201, $P4200["declarator"]
    unless_null $P4201, vivify_2051
    new $P4201, "Undef"
  vivify_2051:
    $P4202 = $P4201."ast"()
    set $P4196, $P4202
  if_4197_end:
    $P4213 = $P4195."!make"($P4196)
.annotate 'line', 1338
    .return ($P4213)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("489_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4215
    .param pmc param_4216
.annotate 'line', 1344
    .lex "self", param_4215
    .lex "$/", param_4216
.annotate 'line', 1345
    find_lex $P4217, "$/"
.annotate 'line', 1346
    find_lex $P4220, "$/"
    unless_null $P4220, vivify_2052
    $P4220 = root_new ['parrot';'Hash']
  vivify_2052:
    set $P4221, $P4220["routine_declarator"]
    unless_null $P4221, vivify_2053
    new $P4221, "Undef"
  vivify_2053:
    if $P4221, if_4219
.annotate 'line', 1347
    find_lex $P4225, "$/"
    unless_null $P4225, vivify_2054
    $P4225 = root_new ['parrot';'Hash']
  vivify_2054:
    set $P4226, $P4225["variable_declarator"]
    unless_null $P4226, vivify_2055
    new $P4226, "Undef"
  vivify_2055:
    $P4227 = $P4226."ast"()
    set $P4218, $P4227
.annotate 'line', 1346
    goto if_4219_end
  if_4219:
    find_lex $P4222, "$/"
    unless_null $P4222, vivify_2056
    $P4222 = root_new ['parrot';'Hash']
  vivify_2056:
    set $P4223, $P4222["routine_declarator"]
    unless_null $P4223, vivify_2057
    new $P4223, "Undef"
  vivify_2057:
    $P4224 = $P4223."ast"()
    set $P4218, $P4224
  if_4219_end:
    $P4228 = $P4217."!make"($P4218)
.annotate 'line', 1344
    .return ($P4228)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("490_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4230
    .param pmc param_4231
.annotate 'line', 1350
    .lex "self", param_4230
    .lex "$/", param_4231
    find_lex $P4232, "$/"
    find_lex $P4235, "$/"
    unless_null $P4235, vivify_2058
    $P4235 = root_new ['parrot';'Hash']
  vivify_2058:
    set $P4236, $P4235["declarator"]
    unless_null $P4236, vivify_2059
    new $P4236, "Undef"
  vivify_2059:
    if $P4236, if_4234
    find_lex $P4240, "$/"
    unless_null $P4240, vivify_2060
    $P4240 = root_new ['parrot';'Hash']
  vivify_2060:
    set $P4241, $P4240["routine_def"]
    unless_null $P4241, vivify_2061
    new $P4241, "Undef"
  vivify_2061:
    $P4242 = $P4241."ast"()
    set $P4233, $P4242
    goto if_4234_end
  if_4234:
    find_lex $P4237, "$/"
    unless_null $P4237, vivify_2062
    $P4237 = root_new ['parrot';'Hash']
  vivify_2062:
    set $P4238, $P4237["declarator"]
    unless_null $P4238, vivify_2063
    new $P4238, "Undef"
  vivify_2063:
    $P4239 = $P4238."ast"()
    set $P4233, $P4239
  if_4234_end:
    $P4243 = $P4232."!make"($P4233)
    .return ($P4243)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("491_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4245
    .param pmc param_4246
.annotate 'line', 1351
    .lex "self", param_4245
    .lex "$/", param_4246
    find_lex $P4247, "$/"
    find_lex $P4250, "$/"
    unless_null $P4250, vivify_2064
    $P4250 = root_new ['parrot';'Hash']
  vivify_2064:
    set $P4251, $P4250["declarator"]
    unless_null $P4251, vivify_2065
    new $P4251, "Undef"
  vivify_2065:
    if $P4251, if_4249
    find_lex $P4255, "$/"
    unless_null $P4255, vivify_2066
    $P4255 = root_new ['parrot';'Hash']
  vivify_2066:
    set $P4256, $P4255["routine_def"]
    unless_null $P4256, vivify_2067
    new $P4256, "Undef"
  vivify_2067:
    $P4257 = $P4256."ast"()
    set $P4248, $P4257
    goto if_4249_end
  if_4249:
    find_lex $P4252, "$/"
    unless_null $P4252, vivify_2068
    $P4252 = root_new ['parrot';'Hash']
  vivify_2068:
    set $P4253, $P4252["declarator"]
    unless_null $P4253, vivify_2069
    new $P4253, "Undef"
  vivify_2069:
    $P4254 = $P4253."ast"()
    set $P4248, $P4254
  if_4249_end:
    $P4258 = $P4247."!make"($P4248)
    .return ($P4258)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("492_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4260
    .param pmc param_4261
.annotate 'line', 1352
    .lex "self", param_4260
    .lex "$/", param_4261
    find_lex $P4262, "$/"
    find_lex $P4263, "$/"
    unless_null $P4263, vivify_2070
    $P4263 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P4264, $P4263["declarator"]
    unless_null $P4264, vivify_2071
    new $P4264, "Undef"
  vivify_2071:
    $P4265 = $P4264."ast"()
    $P4266 = $P4262."!make"($P4265)
    .return ($P4266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("493_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4268
    .param pmc param_4269
.annotate 'line', 1355
    .const 'Sub' $P4301 = "494_1303603603.711" 
    capture_lex $P4301
    .lex "self", param_4268
    .lex "$/", param_4269
.annotate 'line', 1356
    new $P4270, "Undef"
    .lex "$past", $P4270
.annotate 'line', 1357
    new $P4271, "Undef"
    .lex "$sigil", $P4271
.annotate 'line', 1358
    new $P4272, "Undef"
    .lex "$name", $P4272
.annotate 'line', 1359
    new $P4273, "Undef"
    .lex "$BLOCK", $P4273
.annotate 'line', 1356
    find_lex $P4274, "$/"
    unless_null $P4274, vivify_2072
    $P4274 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P4275, $P4274["variable"]
    unless_null $P4275, vivify_2073
    new $P4275, "Undef"
  vivify_2073:
    $P4276 = $P4275."ast"()
    store_lex "$past", $P4276
.annotate 'line', 1357
    find_lex $P4277, "$/"
    unless_null $P4277, vivify_2074
    $P4277 = root_new ['parrot';'Hash']
  vivify_2074:
    set $P4278, $P4277["variable"]
    unless_null $P4278, vivify_2075
    $P4278 = root_new ['parrot';'Hash']
  vivify_2075:
    set $P4279, $P4278["sigil"]
    unless_null $P4279, vivify_2076
    new $P4279, "Undef"
  vivify_2076:
    store_lex "$sigil", $P4279
.annotate 'line', 1358
    find_lex $P4280, "$past"
    unless_null $P4280, vivify_2077
    new $P4280, "Undef"
  vivify_2077:
    $P4281 = $P4280."name"()
    store_lex "$name", $P4281
.annotate 'line', 1359
    find_lex $P4282, "$?PACKAGE"
    get_who $P4283, $P4282
    set $P4284, $P4283["@BLOCK"]
    unless_null $P4284, vivify_2078
    $P4284 = root_new ['parrot';'ResizablePMCArray']
  vivify_2078:
    set $P4285, $P4284[0]
    unless_null $P4285, vivify_2079
    new $P4285, "Undef"
  vivify_2079:
    store_lex "$BLOCK", $P4285
.annotate 'line', 1360
    find_lex $P4289, "$name"
    unless_null $P4289, vivify_2080
    new $P4289, "Undef"
  vivify_2080:
    if $P4289, if_4288
    set $P4287, $P4289
    goto if_4288_end
  if_4288:
    find_lex $P4290, "$BLOCK"
    unless_null $P4290, vivify_2081
    new $P4290, "Undef"
  vivify_2081:
    find_lex $P4291, "$name"
    unless_null $P4291, vivify_2082
    new $P4291, "Undef"
  vivify_2082:
    $P4292 = $P4290."symbol"($P4291)
    set $P4287, $P4292
  if_4288_end:
    unless $P4287, if_4286_end
.annotate 'line', 1361
    find_lex $P4293, "$/"
    unless_null $P4293, vivify_2083
    new $P4293, "Undef"
  vivify_2083:
    $P4294 = $P4293."CURSOR"()
    find_lex $P4295, "$name"
    unless_null $P4295, vivify_2084
    new $P4295, "Undef"
  vivify_2084:
    $P4294."panic"("Redeclaration of symbol ", $P4295)
  if_4286_end:
.annotate 'line', 1363
    find_dynamic_lex $P4297, "$*SCOPE"
    unless_null $P4297, vivify_2085
    get_hll_global $P4297, "$SCOPE"
    unless_null $P4297, vivify_2086
    die "Contextual $*SCOPE not found"
  vivify_2086:
  vivify_2085:
    set $S4298, $P4297
    iseq $I4299, $S4298, "has"
    if $I4299, if_4296
.annotate 'line', 1388
    find_dynamic_lex $P4346, "$*SCOPE"
    unless_null $P4346, vivify_2087
    get_hll_global $P4346, "$SCOPE"
    unless_null $P4346, vivify_2088
    die "Contextual $*SCOPE not found"
  vivify_2088:
  vivify_2087:
    set $S4347, $P4346
    iseq $I4348, $S4347, "our"
    if $I4348, if_4345
.annotate 'line', 1398
    find_lex $P4362, "$BLOCK"
    unless_null $P4362, vivify_2089
    $P4362 = root_new ['parrot';'ResizablePMCArray']
  vivify_2089:
    set $P4363, $P4362[0]
    unless_null $P4363, vivify_2090
    new $P4363, "Undef"
  vivify_2090:
    get_hll_global $P4364, ["PAST"], "Var"
    find_lex $P4365, "$name"
    unless_null $P4365, vivify_2091
    new $P4365, "Undef"
  vivify_2091:
.annotate 'line', 1400
    find_lex $P4366, "$sigil"
    unless_null $P4366, vivify_2092
    new $P4366, "Undef"
  vivify_2092:
    $P4367 = "vivitype"($P4366)
    find_lex $P4368, "$/"
    unless_null $P4368, vivify_2093
    new $P4368, "Undef"
  vivify_2093:
    $P4369 = $P4364."new"($P4365 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4367 :named("viviself"), $P4368 :named("node"))
.annotate 'line', 1398
    $P4363."push"($P4369)
.annotate 'line', 1403
    find_lex $P4370, "$BLOCK"
    unless_null $P4370, vivify_2094
    new $P4370, "Undef"
  vivify_2094:
    find_lex $P4371, "$name"
    unless_null $P4371, vivify_2095
    new $P4371, "Undef"
  vivify_2095:
    $P4370."symbol"($P4371, "lexical" :named("scope"))
.annotate 'line', 1397
    goto if_4345_end
  if_4345:
.annotate 'line', 1392
    find_lex $P4349, "$/"
    unless_null $P4349, vivify_2096
    $P4349 = root_new ['parrot';'Hash']
  vivify_2096:
    set $P4350, $P4349["variable"]
    unless_null $P4350, vivify_2097
    new $P4350, "Undef"
  vivify_2097:
    set $S4351, $P4350
    new $P4352, 'String'
    set $P4352, $S4351
    store_lex "$name", $P4352
.annotate 'line', 1393
    find_lex $P4353, "$name"
    unless_null $P4353, vivify_2098
    new $P4353, "Undef"
  vivify_2098:
    new $P4354, "ResizablePMCArray"
    push $P4354, $P4353
    find_lex $P4355, "$/"
    unless_null $P4355, vivify_2099
    new $P4355, "Undef"
  vivify_2099:
    $P4356 = "lexical_package_lookup"($P4354, $P4355)
    store_lex "$past", $P4356
.annotate 'line', 1394
    find_lex $P4357, "$past"
    unless_null $P4357, vivify_2100
    new $P4357, "Undef"
  vivify_2100:
    find_lex $P4358, "$sigil"
    unless_null $P4358, vivify_2101
    new $P4358, "Undef"
  vivify_2101:
    $P4359 = "vivitype"($P4358)
    $P4357."viviself"($P4359)
.annotate 'line', 1395
    find_lex $P4360, "$BLOCK"
    unless_null $P4360, vivify_2102
    new $P4360, "Undef"
  vivify_2102:
    find_lex $P4361, "$name"
    unless_null $P4361, vivify_2103
    new $P4361, "Undef"
  vivify_2103:
    $P4360."symbol"($P4361, "package" :named("scope"))
  if_4345_end:
.annotate 'line', 1388
    goto if_4296_end
  if_4296:
.annotate 'line', 1363
    .const 'Sub' $P4301 = "494_1303603603.711" 
    capture_lex $P4301
    $P4301()
  if_4296_end:
.annotate 'line', 1405
    find_lex $P4372, "$/"
    find_lex $P4373, "$past"
    unless_null $P4373, vivify_2125
    new $P4373, "Undef"
  vivify_2125:
    $P4374 = $P4372."!make"($P4373)
.annotate 'line', 1355
    .return ($P4374)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4300"  :anon :subid("494_1303603603.711") :outer("493_1303603603.711")
.annotate 'line', 1363
    .const 'Sub' $P4331 = "495_1303603603.711" 
    capture_lex $P4331
.annotate 'line', 1365
    new $P4302, "Undef"
    .lex "$meta-attr-type", $P4302
.annotate 'line', 1373
    new $P4303, "Undef"
    .lex "$meta_args", $P4303
.annotate 'line', 1365
    find_dynamic_lex $P4306, "$*PKGDECL"
    unless_null $P4306, vivify_2104
    get_hll_global $P4306, "$PKGDECL"
    unless_null $P4306, vivify_2105
    die "Contextual $*PKGDECL not found"
  vivify_2105:
  vivify_2104:
    find_dynamic_lex $P4307, "%*HOW-METAATTR"
    unless_null $P4307, vivify_2106
    get_hll_global $P4307, "%HOW-METAATTR"
    unless_null $P4307, vivify_2107
    die "Contextual %*HOW-METAATTR not found"
  vivify_2107:
  vivify_2106:
    set $P4308, $P4307[$P4306]
    unless_null $P4308, vivify_2108
    new $P4308, "Undef"
  vivify_2108:
    unless $P4308, unless_4305
    set $P4304, $P4308
    goto unless_4305_end
  unless_4305:
    find_dynamic_lex $P4309, "$*DEFAULT-METAATTR"
    unless_null $P4309, vivify_2109
    get_hll_global $P4309, "$DEFAULT-METAATTR"
    unless_null $P4309, vivify_2110
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_2110:
  vivify_2109:
    set $P4304, $P4309
  unless_4305_end:
    store_lex "$meta-attr-type", $P4304
.annotate 'line', 1366
    find_dynamic_lex $P4310, "$*PACKAGE-SETUP"
    unless_null $P4310, vivify_2111
    get_hll_global $P4310, "$PACKAGE-SETUP"
    unless_null $P4310, vivify_2112
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2112:
  vivify_2111:
    get_hll_global $P4311, ["PAST"], "Op"
.annotate 'line', 1368
    get_hll_global $P4312, ["PAST"], "Op"
.annotate 'line', 1370
    get_hll_global $P4313, ["PAST"], "Var"
    $P4314 = $P4313."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4315 = $P4312."new"($P4314, "get_how PP" :named("pirop"))
.annotate 'line', 1372
    get_hll_global $P4316, ["PAST"], "Var"
    $P4317 = $P4316."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1373
    get_hll_global $P4318, ["PAST"], "Op"
.annotate 'line', 1375
    get_hll_global $P4319, ["PAST"], "Var"
    find_lex $P4320, "$meta-attr-type"
    unless_null $P4320, vivify_2113
    new $P4320, "Undef"
  vivify_2113:
    $P4321 = $P4319."new"($P4320 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1376
    get_hll_global $P4322, ["PAST"], "Val"
    find_lex $P4323, "$name"
    unless_null $P4323, vivify_2114
    new $P4323, "Undef"
  vivify_2114:
    $P4324 = $P4322."new"($P4323 :named("value"), "name" :named("named"))
    $P4325 = $P4318."new"($P4321, $P4324, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1373
    store_lex "$meta_args", $P4325
    $P4326 = $P4311."new"($P4315, $P4317, $P4325, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1366
    $P4310."push"($P4326)
.annotate 'line', 1379
    find_lex $P4328, "$/"
    unless_null $P4328, vivify_2115
    $P4328 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P4329, $P4328["typename"]
    unless_null $P4329, vivify_2116
    new $P4329, "Undef"
  vivify_2116:
    unless $P4329, if_4327_end
    .const 'Sub' $P4331 = "495_1303603603.711" 
    capture_lex $P4331
    $P4331()
  if_4327_end:
.annotate 'line', 1385
    find_lex $P4341, "$BLOCK"
    unless_null $P4341, vivify_2123
    new $P4341, "Undef"
  vivify_2123:
    find_lex $P4342, "$name"
    unless_null $P4342, vivify_2124
    new $P4342, "Undef"
  vivify_2124:
    $P4341."symbol"($P4342, "attribute" :named("scope"))
.annotate 'line', 1386
    get_hll_global $P4343, ["PAST"], "Stmts"
    $P4344 = $P4343."new"()
    store_lex "$past", $P4344
.annotate 'line', 1363
    .return ($P4344)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4330"  :anon :subid("495_1303603603.711") :outer("494_1303603603.711")
.annotate 'line', 1380
    new $P4332, "Undef"
    .lex "$type", $P4332
    find_lex $P4333, "$/"
    unless_null $P4333, vivify_2117
    $P4333 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P4334, $P4333["typename"]
    unless_null $P4334, vivify_2118
    $P4334 = root_new ['parrot';'ResizablePMCArray']
  vivify_2118:
    set $P4335, $P4334[0]
    unless_null $P4335, vivify_2119
    new $P4335, "Undef"
  vivify_2119:
    $P4336 = $P4335."ast"()
    store_lex "$type", $P4336
.annotate 'line', 1381
    find_lex $P4337, "$type"
    unless_null $P4337, vivify_2120
    new $P4337, "Undef"
  vivify_2120:
    $P4337."named"("type")
.annotate 'line', 1382
    find_lex $P4338, "$meta_args"
    unless_null $P4338, vivify_2121
    new $P4338, "Undef"
  vivify_2121:
    find_lex $P4339, "$type"
    unless_null $P4339, vivify_2122
    new $P4339, "Undef"
  vivify_2122:
    $P4340 = $P4338."push"($P4339)
.annotate 'line', 1379
    .return ($P4340)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("496_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4376
    .param pmc param_4377
.annotate 'line', 1408
    .lex "self", param_4376
    .lex "$/", param_4377
    find_lex $P4378, "$/"
    find_lex $P4379, "$/"
    unless_null $P4379, vivify_2126
    $P4379 = root_new ['parrot';'Hash']
  vivify_2126:
    set $P4380, $P4379["routine_def"]
    unless_null $P4380, vivify_2127
    new $P4380, "Undef"
  vivify_2127:
    $P4381 = $P4380."ast"()
    $P4382 = $P4378."!make"($P4381)
    .return ($P4382)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("497_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4384
    .param pmc param_4385
.annotate 'line', 1409
    .lex "self", param_4384
    .lex "$/", param_4385
    find_lex $P4386, "$/"
    find_lex $P4387, "$/"
    unless_null $P4387, vivify_2128
    $P4387 = root_new ['parrot';'Hash']
  vivify_2128:
    set $P4388, $P4387["method_def"]
    unless_null $P4388, vivify_2129
    new $P4388, "Undef"
  vivify_2129:
    $P4389 = $P4388."ast"()
    $P4390 = $P4386."!make"($P4389)
    .return ($P4390)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("498_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4392
    .param pmc param_4393
.annotate 'line', 1411
    .const 'Sub' $P4652 = "504_1303603603.711" 
    capture_lex $P4652
    .const 'Sub' $P4413 = "499_1303603603.711" 
    capture_lex $P4413
    .lex "self", param_4392
    .lex "$/", param_4393
.annotate 'line', 1414
    new $P4394, "Undef"
    .lex "$past", $P4394
.annotate 'line', 1425
    new $P4395, "Undef"
    .lex "$block", $P4395
.annotate 'line', 1411
    find_lex $P4396, "$past"
    unless_null $P4396, vivify_2130
    new $P4396, "Undef"
  vivify_2130:
.annotate 'line', 1415
    find_lex $P4398, "$/"
    unless_null $P4398, vivify_2131
    $P4398 = root_new ['parrot';'Hash']
  vivify_2131:
    set $P4399, $P4398["onlystar"]
    unless_null $P4399, vivify_2132
    new $P4399, "Undef"
  vivify_2132:
    if $P4399, if_4397
.annotate 'line', 1419
    find_lex $P4401, "$/"
    unless_null $P4401, vivify_2133
    $P4401 = root_new ['parrot';'Hash']
  vivify_2133:
    set $P4402, $P4401["blockoid"]
    unless_null $P4402, vivify_2134
    new $P4402, "Undef"
  vivify_2134:
    $P4403 = $P4402."ast"()
    store_lex "$past", $P4403
.annotate 'line', 1420
    find_lex $P4404, "$past"
    unless_null $P4404, vivify_2135
    new $P4404, "Undef"
  vivify_2135:
    $P4404."blocktype"("declaration")
.annotate 'line', 1421
    find_dynamic_lex $P4406, "$*RETURN_USED"
    unless_null $P4406, vivify_2136
    get_hll_global $P4406, "$RETURN_USED"
    unless_null $P4406, vivify_2137
    die "Contextual $*RETURN_USED not found"
  vivify_2137:
  vivify_2136:
    unless $P4406, if_4405_end
.annotate 'line', 1422
    find_lex $P4407, "$past"
    unless_null $P4407, vivify_2138
    new $P4407, "Undef"
  vivify_2138:
    $P4407."control"("return_pir")
  if_4405_end:
.annotate 'line', 1418
    goto if_4397_end
  if_4397:
.annotate 'line', 1416
    $P4400 = "only_star_block"()
    store_lex "$past", $P4400
  if_4397_end:
.annotate 'line', 1425
    find_lex $P4408, "$past"
    unless_null $P4408, vivify_2139
    new $P4408, "Undef"
  vivify_2139:
    store_lex "$block", $P4408
.annotate 'line', 1427
    find_lex $P4410, "$/"
    unless_null $P4410, vivify_2140
    $P4410 = root_new ['parrot';'Hash']
  vivify_2140:
    set $P4411, $P4410["deflongname"]
    unless_null $P4411, vivify_2141
    new $P4411, "Undef"
  vivify_2141:
    unless $P4411, if_4409_end
    .const 'Sub' $P4413 = "499_1303603603.711" 
    capture_lex $P4413
    $P4413()
  if_4409_end:
.annotate 'line', 1532
    find_lex $P4641, "$block"
    unless_null $P4641, vivify_2244
    new $P4641, "Undef"
  vivify_2244:
    find_lex $P4642, "$past"
    unless_null $P4642, vivify_2245
    $P4642 = root_new ['parrot';'Hash']
    store_lex "$past", $P4642
  vivify_2245:
    set $P4642["block_past"], $P4641
.annotate 'line', 1533
    find_lex $P4644, "$/"
    unless_null $P4644, vivify_2246
    $P4644 = root_new ['parrot';'Hash']
  vivify_2246:
    set $P4645, $P4644["trait"]
    unless_null $P4645, vivify_2247
    new $P4645, "Undef"
  vivify_2247:
    unless $P4645, if_4643_end
.annotate 'line', 1534
    find_lex $P4647, "$/"
    unless_null $P4647, vivify_2248
    $P4647 = root_new ['parrot';'Hash']
  vivify_2248:
    set $P4648, $P4647["trait"]
    unless_null $P4648, vivify_2249
    new $P4648, "Undef"
  vivify_2249:
    defined $I4649, $P4648
    unless $I4649, for_undef_2250
    iter $P4646, $P4648
    new $P4659, 'ExceptionHandler'
    set_label $P4659, loop4658_handler
    $P4659."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4659
  loop4658_test:
    unless $P4646, loop4658_done
    shift $P4650, $P4646
  loop4658_redo:
    .const 'Sub' $P4652 = "504_1303603603.711" 
    capture_lex $P4652
    $P4652($P4650)
  loop4658_next:
    goto loop4658_test
  loop4658_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4660, exception, 'type'
    eq $P4660, .CONTROL_LOOP_NEXT, loop4658_next
    eq $P4660, .CONTROL_LOOP_REDO, loop4658_redo
  loop4658_done:
    pop_eh 
  for_undef_2250:
  if_4643_end:
.annotate 'line', 1537
    find_lex $P4661, "$/"
    find_lex $P4662, "$past"
    unless_null $P4662, vivify_2253
    new $P4662, "Undef"
  vivify_2253:
    $P4663 = $P4661."!make"($P4662)
.annotate 'line', 1411
    .return ($P4663)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4412"  :anon :subid("499_1303603603.711") :outer("498_1303603603.711")
.annotate 'line', 1427
    .const 'Sub' $P4543 = "503_1303603603.711" 
    capture_lex $P4543
    .const 'Sub' $P4446 = "500_1303603603.711" 
    capture_lex $P4446
.annotate 'line', 1428
    new $P4414, "Undef"
    .lex "$name", $P4414
    find_lex $P4415, "$/"
    unless_null $P4415, vivify_2142
    $P4415 = root_new ['parrot';'Hash']
  vivify_2142:
    set $P4416, $P4415["sigil"]
    unless_null $P4416, vivify_2143
    $P4416 = root_new ['parrot';'ResizablePMCArray']
  vivify_2143:
    set $P4417, $P4416[0]
    unless_null $P4417, vivify_2144
    new $P4417, "Undef"
  vivify_2144:
    set $S4418, $P4417
    new $P4419, 'String'
    set $P4419, $S4418
    find_lex $P4420, "$/"
    unless_null $P4420, vivify_2145
    $P4420 = root_new ['parrot';'Hash']
  vivify_2145:
    set $P4421, $P4420["deflongname"]
    unless_null $P4421, vivify_2146
    $P4421 = root_new ['parrot';'ResizablePMCArray']
  vivify_2146:
    set $P4422, $P4421[0]
    unless_null $P4422, vivify_2147
    new $P4422, "Undef"
  vivify_2147:
    $S4423 = $P4422."ast"()
    concat $P4424, $P4419, $S4423
    store_lex "$name", $P4424
.annotate 'line', 1429
    find_lex $P4425, "$past"
    unless_null $P4425, vivify_2148
    new $P4425, "Undef"
  vivify_2148:
    find_lex $P4426, "$name"
    unless_null $P4426, vivify_2149
    new $P4426, "Undef"
  vivify_2149:
    $P4425."name"($P4426)
.annotate 'line', 1430
    find_dynamic_lex $P4432, "$*SCOPE"
    unless_null $P4432, vivify_2150
    get_hll_global $P4432, "$SCOPE"
    unless_null $P4432, vivify_2151
    die "Contextual $*SCOPE not found"
  vivify_2151:
  vivify_2150:
    set $S4433, $P4432
    iseq $I4434, $S4433, ""
    unless $I4434, unless_4431
    new $P4430, 'Integer'
    set $P4430, $I4434
    goto unless_4431_end
  unless_4431:
    find_dynamic_lex $P4435, "$*SCOPE"
    unless_null $P4435, vivify_2152
    get_hll_global $P4435, "$SCOPE"
    unless_null $P4435, vivify_2153
    die "Contextual $*SCOPE not found"
  vivify_2153:
  vivify_2152:
    set $S4436, $P4435
    iseq $I4437, $S4436, "my"
    new $P4430, 'Integer'
    set $P4430, $I4437
  unless_4431_end:
    unless $P4430, unless_4429
    set $P4428, $P4430
    goto unless_4429_end
  unless_4429:
    find_dynamic_lex $P4438, "$*SCOPE"
    unless_null $P4438, vivify_2154
    get_hll_global $P4438, "$SCOPE"
    unless_null $P4438, vivify_2155
    die "Contextual $*SCOPE not found"
  vivify_2155:
  vivify_2154:
    set $S4439, $P4438
    iseq $I4440, $S4439, "our"
    new $P4428, 'Integer'
    set $P4428, $I4440
  unless_4429_end:
    if $P4428, if_4427
.annotate 'line', 1522
    find_lex $P4626, "$/"
    unless_null $P4626, vivify_2156
    new $P4626, "Undef"
  vivify_2156:
    $P4627 = $P4626."CURSOR"()
    find_dynamic_lex $P4628, "$*SCOPE"
    unless_null $P4628, vivify_2157
    get_hll_global $P4628, "$SCOPE"
    unless_null $P4628, vivify_2158
    die "Contextual $*SCOPE not found"
  vivify_2158:
  vivify_2157:
    concat $P4629, $P4628, " scoped routines are not supported yet"
    $P4627."panic"($P4629)
.annotate 'line', 1521
    goto if_4427_end
  if_4427:
.annotate 'line', 1431
    find_dynamic_lex $P4442, "$*MULTINESS"
    unless_null $P4442, vivify_2159
    get_hll_global $P4442, "$MULTINESS"
    unless_null $P4442, vivify_2160
    die "Contextual $*MULTINESS not found"
  vivify_2160:
  vivify_2159:
    set $S4443, $P4442
    iseq $I4444, $S4443, "multi"
    if $I4444, if_4441
.annotate 'line', 1482
    find_dynamic_lex $P4539, "$*MULTINESS"
    unless_null $P4539, vivify_2161
    get_hll_global $P4539, "$MULTINESS"
    unless_null $P4539, vivify_2162
    die "Contextual $*MULTINESS not found"
  vivify_2162:
  vivify_2161:
    set $S4540, $P4539
    iseq $I4541, $S4540, "proto"
    if $I4541, if_4538
.annotate 'line', 1501
    find_lex $P4579, "$?PACKAGE"
    get_who $P4580, $P4579
    set $P4581, $P4580["@BLOCK"]
    unless_null $P4581, vivify_2163
    $P4581 = root_new ['parrot';'ResizablePMCArray']
  vivify_2163:
    set $P4582, $P4581[0]
    unless_null $P4582, vivify_2164
    $P4582 = root_new ['parrot';'ResizablePMCArray']
  vivify_2164:
    set $P4583, $P4582[0]
    unless_null $P4583, vivify_2165
    new $P4583, "Undef"
  vivify_2165:
    get_hll_global $P4584, ["PAST"], "Var"
    find_lex $P4585, "$name"
    unless_null $P4585, vivify_2166
    new $P4585, "Undef"
  vivify_2166:
    find_lex $P4586, "$past"
    unless_null $P4586, vivify_2167
    new $P4586, "Undef"
  vivify_2167:
    $P4587 = $P4584."new"($P4585 :named("name"), 1 :named("isdecl"), $P4586 :named("viviself"), "lexical" :named("scope"))
    $P4583."push"($P4587)
.annotate 'line', 1503
    find_lex $P4588, "$?PACKAGE"
    get_who $P4589, $P4588
    set $P4590, $P4589["@BLOCK"]
    unless_null $P4590, vivify_2168
    $P4590 = root_new ['parrot';'ResizablePMCArray']
  vivify_2168:
    set $P4591, $P4590[0]
    unless_null $P4591, vivify_2169
    new $P4591, "Undef"
  vivify_2169:
    find_lex $P4592, "$name"
    unless_null $P4592, vivify_2170
    new $P4592, "Undef"
  vivify_2170:
    $P4591."symbol"($P4592, "lexical" :named("scope"))
.annotate 'line', 1504
    find_dynamic_lex $P4594, "$*SCOPE"
    unless_null $P4594, vivify_2171
    get_hll_global $P4594, "$SCOPE"
    unless_null $P4594, vivify_2172
    die "Contextual $*SCOPE not found"
  vivify_2172:
  vivify_2171:
    set $S4595, $P4594
    iseq $I4596, $S4595, "our"
    unless $I4596, if_4593_end
.annotate 'line', 1507
    find_lex $P4597, "$?PACKAGE"
    get_who $P4598, $P4597
    set $P4599, $P4598["@BLOCK"]
    unless_null $P4599, vivify_2173
    $P4599 = root_new ['parrot';'ResizablePMCArray']
  vivify_2173:
    set $P4600, $P4599[0]
    unless_null $P4600, vivify_2174
    $P4600 = root_new ['parrot';'ResizablePMCArray']
  vivify_2174:
    set $P4601, $P4600[0]
    unless_null $P4601, vivify_2175
    new $P4601, "Undef"
  vivify_2175:
    get_hll_global $P4602, ["PAST"], "Op"
.annotate 'line', 1509
    get_hll_global $P4603, ["PAST"], "Var"
    find_lex $P4604, "$name"
    unless_null $P4604, vivify_2176
    new $P4604, "Undef"
  vivify_2176:
    $P4605 = $P4603."new"($P4604 :named("name"), "package" :named("scope"))
.annotate 'line', 1510
    get_hll_global $P4606, ["PAST"], "Var"
    find_lex $P4607, "$name"
    unless_null $P4607, vivify_2177
    new $P4607, "Undef"
  vivify_2177:
    $P4608 = $P4606."new"($P4607 :named("name"), "lexical" :named("scope"))
    $P4609 = $P4602."new"($P4605, $P4608, "bind" :named("pasttype"))
.annotate 'line', 1507
    $P4601."push"($P4609)
.annotate 'line', 1512
    find_lex $P4610, "$?PACKAGE"
    get_who $P4611, $P4610
    set $P4612, $P4611["@BLOCK"]
    unless_null $P4612, vivify_2178
    $P4612 = root_new ['parrot';'ResizablePMCArray']
  vivify_2178:
    set $P4613, $P4612[0]
    unless_null $P4613, vivify_2179
    new $P4613, "Undef"
  vivify_2179:
    $P4614 = $P4613."loadinit"()
    get_hll_global $P4615, ["PAST"], "Op"
.annotate 'line', 1514
    get_hll_global $P4616, ["PAST"], "Var"
    find_lex $P4617, "$name"
    unless_null $P4617, vivify_2180
    new $P4617, "Undef"
  vivify_2180:
    $P4618 = $P4616."new"($P4617 :named("name"), "package" :named("scope"))
.annotate 'line', 1515
    get_hll_global $P4619, ["PAST"], "Val"
    find_lex $P4620, "$past"
    unless_null $P4620, vivify_2181
    new $P4620, "Undef"
  vivify_2181:
    $P4621 = $P4619."new"($P4620 :named("value"))
    $P4622 = $P4615."new"($P4618, $P4621, "bind" :named("pasttype"))
.annotate 'line', 1512
    $P4614."push"($P4622)
  if_4593_end:
.annotate 'line', 1500
    goto if_4538_end
  if_4538:
.annotate 'line', 1482
    .const 'Sub' $P4543 = "503_1303603603.711" 
    capture_lex $P4543
    $P4543()
  if_4538_end:
    goto if_4441_end
  if_4441:
.annotate 'line', 1431
    .const 'Sub' $P4446 = "500_1303603603.711" 
    capture_lex $P4446
    $P4446()
  if_4441_end:
.annotate 'line', 1519
    get_hll_global $P4623, ["PAST"], "Var"
    find_lex $P4624, "$name"
    unless_null $P4624, vivify_2239
    new $P4624, "Undef"
  vivify_2239:
    $P4625 = $P4623."new"($P4624 :named("name"))
    store_lex "$past", $P4625
  if_4427_end:
.annotate 'line', 1526
    find_lex $P4634, "$name"
    unless_null $P4634, vivify_2240
    new $P4634, "Undef"
  vivify_2240:
    set $S4635, $P4634
    iseq $I4636, $S4635, "MAIN"
    if $I4636, if_4633
    new $P4632, 'Integer'
    set $P4632, $I4636
    goto if_4633_end
  if_4633:
    find_dynamic_lex $P4637, "$*MULTINESS"
    unless_null $P4637, vivify_2241
    get_hll_global $P4637, "$MULTINESS"
    unless_null $P4637, vivify_2242
    die "Contextual $*MULTINESS not found"
  vivify_2242:
  vivify_2241:
    set $S4638, $P4637
    isne $I4639, $S4638, "multi"
    new $P4632, 'Integer'
    set $P4632, $I4639
  if_4633_end:
    if $P4632, if_4631
    set $P4630, $P4632
    goto if_4631_end
  if_4631:
.annotate 'line', 1527
    find_lex $P4640, "$block"
    unless_null $P4640, vivify_2243
    new $P4640, "Undef"
  vivify_2243:
    store_dynamic_lex "$*MAIN_SUB", $P4640
.annotate 'line', 1526
    set $P4630, $P4640
  if_4631_end:
.annotate 'line', 1427
    .return ($P4630)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4542"  :anon :subid("503_1303603603.711") :outer("499_1303603603.711")
.annotate 'line', 1487
    new $P4544, "Undef"
    .lex "$cholder", $P4544
.annotate 'line', 1486
    find_dynamic_lex $P4546, "$*SCOPE"
    unless_null $P4546, vivify_2182
    get_hll_global $P4546, "$SCOPE"
    unless_null $P4546, vivify_2183
    die "Contextual $*SCOPE not found"
  vivify_2183:
  vivify_2182:
    set $S4547, $P4546
    iseq $I4548, $S4547, "our"
    unless $I4548, if_4545_end
    die "our-scoped protos not yet implemented"
  if_4545_end:
.annotate 'line', 1487
    get_hll_global $P4549, ["PAST"], "Op"
    $P4550 = $P4549."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4550
.annotate 'line', 1488
    find_lex $P4551, "$?PACKAGE"
    get_who $P4552, $P4551
    set $P4553, $P4552["@BLOCK"]
    unless_null $P4553, vivify_2184
    $P4553 = root_new ['parrot';'ResizablePMCArray']
  vivify_2184:
    set $P4554, $P4553[0]
    unless_null $P4554, vivify_2185
    $P4554 = root_new ['parrot';'ResizablePMCArray']
  vivify_2185:
    set $P4555, $P4554[0]
    unless_null $P4555, vivify_2186
    new $P4555, "Undef"
  vivify_2186:
    get_hll_global $P4556, ["PAST"], "Var"
    find_lex $P4557, "$name"
    unless_null $P4557, vivify_2187
    new $P4557, "Undef"
  vivify_2187:
    find_lex $P4558, "$past"
    unless_null $P4558, vivify_2188
    new $P4558, "Undef"
  vivify_2188:
    $P4559 = $P4556."new"($P4557 :named("name"), 1 :named("isdecl"), $P4558 :named("viviself"), "lexical" :named("scope"))
    $P4555."push"($P4559)
.annotate 'line', 1490
    find_lex $P4560, "$?PACKAGE"
    get_who $P4561, $P4560
    set $P4562, $P4561["@BLOCK"]
    unless_null $P4562, vivify_2189
    $P4562 = root_new ['parrot';'ResizablePMCArray']
  vivify_2189:
    set $P4563, $P4562[0]
    unless_null $P4563, vivify_2190
    $P4563 = root_new ['parrot';'ResizablePMCArray']
  vivify_2190:
    set $P4564, $P4563[0]
    unless_null $P4564, vivify_2191
    new $P4564, "Undef"
  vivify_2191:
    get_hll_global $P4565, ["PAST"], "Op"
.annotate 'line', 1492
    get_hll_global $P4566, ["PAST"], "Var"
    find_lex $P4567, "$name"
    unless_null $P4567, vivify_2192
    new $P4567, "Undef"
  vivify_2192:
    $P4568 = $P4566."new"($P4567 :named("name"))
    find_lex $P4569, "$cholder"
    unless_null $P4569, vivify_2193
    new $P4569, "Undef"
  vivify_2193:
    $P4570 = $P4565."new"($P4568, $P4569, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1490
    $P4564."push"($P4570)
.annotate 'line', 1495
    find_lex $P4571, "$?PACKAGE"
    get_who $P4572, $P4571
    set $P4573, $P4572["@BLOCK"]
    unless_null $P4573, vivify_2194
    $P4573 = root_new ['parrot';'ResizablePMCArray']
  vivify_2194:
    set $P4574, $P4573[0]
    unless_null $P4574, vivify_2195
    new $P4574, "Undef"
  vivify_2195:
    find_lex $P4575, "$name"
    unless_null $P4575, vivify_2196
    new $P4575, "Undef"
  vivify_2196:
    find_lex $P4576, "$cholder"
    unless_null $P4576, vivify_2197
    new $P4576, "Undef"
  vivify_2197:
    $P4574."symbol"($P4575, "lexical" :named("scope"), 1 :named("proto"), $P4576 :named("cholder"))
.annotate 'line', 1498
    find_lex $P4577, "$past"
    unless_null $P4577, vivify_2198
    new $P4577, "Undef"
  vivify_2198:
    $P4578 = $P4577."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1482
    .return ($P4578)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4445"  :anon :subid("500_1303603603.711") :outer("499_1303603603.711")
.annotate 'line', 1431
    .const 'Sub' $P4466 = "501_1303603603.711" 
    capture_lex $P4466
.annotate 'line', 1434
    new $P4447, "Undef"
    .lex "$cholder", $P4447
.annotate 'line', 1435
    $P4448 = root_new ['parrot';'Hash']
    .lex "%sym", $P4448
.annotate 'line', 1433
    find_dynamic_lex $P4450, "$*SCOPE"
    unless_null $P4450, vivify_2199
    get_hll_global $P4450, "$SCOPE"
    unless_null $P4450, vivify_2200
    die "Contextual $*SCOPE not found"
  vivify_2200:
  vivify_2199:
    set $S4451, $P4450
    iseq $I4452, $S4451, "our"
    unless $I4452, if_4449_end
    die "our-scoped multis not yet implemented"
  if_4449_end:
    find_lex $P4453, "$cholder"
    unless_null $P4453, vivify_2201
    new $P4453, "Undef"
  vivify_2201:
.annotate 'line', 1435
    find_lex $P4454, "$?PACKAGE"
    get_who $P4455, $P4454
    set $P4456, $P4455["@BLOCK"]
    unless_null $P4456, vivify_2202
    $P4456 = root_new ['parrot';'ResizablePMCArray']
  vivify_2202:
    set $P4457, $P4456[0]
    unless_null $P4457, vivify_2203
    new $P4457, "Undef"
  vivify_2203:
    find_lex $P4458, "$name"
    unless_null $P4458, vivify_2204
    new $P4458, "Undef"
  vivify_2204:
    $P4459 = $P4457."symbol"($P4458)
    store_lex "%sym", $P4459
.annotate 'line', 1436
    find_lex $P4461, "%sym"
    unless_null $P4461, vivify_2205
    $P4461 = root_new ['parrot';'Hash']
  vivify_2205:
    set $P4462, $P4461["cholder"]
    unless_null $P4462, vivify_2206
    new $P4462, "Undef"
  vivify_2206:
    if $P4462, if_4460
.annotate 'line', 1441
    .const 'Sub' $P4466 = "501_1303603603.711" 
    capture_lex $P4466
    $P4466()
    goto if_4460_end
  if_4460:
.annotate 'line', 1437
    find_lex $P4463, "%sym"
    unless_null $P4463, vivify_2234
    $P4463 = root_new ['parrot';'Hash']
  vivify_2234:
    set $P4464, $P4463["cholder"]
    unless_null $P4464, vivify_2235
    new $P4464, "Undef"
  vivify_2235:
    store_lex "$cholder", $P4464
  if_4460_end:
.annotate 'line', 1477
    find_lex $P4534, "$cholder"
    unless_null $P4534, vivify_2236
    new $P4534, "Undef"
  vivify_2236:
    find_lex $P4535, "$past"
    unless_null $P4535, vivify_2237
    new $P4535, "Undef"
  vivify_2237:
    $P4534."push"($P4535)
.annotate 'line', 1480
    find_lex $P4536, "$past"
    unless_null $P4536, vivify_2238
    new $P4536, "Undef"
  vivify_2238:
    $P4537 = "attach_multi_signature"($P4536)
.annotate 'line', 1431
    .return ($P4537)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4465"  :anon :subid("501_1303603603.711") :outer("500_1303603603.711")
.annotate 'line', 1441
    .const 'Sub' $P4482 = "502_1303603603.711" 
    capture_lex $P4482
.annotate 'line', 1448
    new $P4467, "Undef"
    .lex "$found_proto", $P4467
.annotate 'line', 1466
    new $P4468, "Undef"
    .lex "$dispatch_setup", $P4468
.annotate 'line', 1443
    find_lex $P4470, "%sym"
    unless_null $P4470, vivify_2207
    $P4470 = root_new ['parrot';'Hash']
  vivify_2207:
    set $P4471, $P4470["proto"]
    unless_null $P4471, vivify_2208
    new $P4471, "Undef"
  vivify_2208:
    unless $P4471, if_4469_end
.annotate 'line', 1446
    find_lex $P4472, "$/"
    unless_null $P4472, vivify_2209
    new $P4472, "Undef"
  vivify_2209:
    $P4473 = $P4472."CURSOR"()
    $P4473."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4469_end:
.annotate 'line', 1443
    find_lex $P4474, "$found_proto"
    unless_null $P4474, vivify_2210
    new $P4474, "Undef"
  vivify_2210:
.annotate 'line', 1449
    find_lex $P4476, "$?PACKAGE"
    get_who $P4477, $P4476
    set $P4478, $P4477["@BLOCK"]
    unless_null $P4478, vivify_2211
    $P4478 = root_new ['parrot';'ResizablePMCArray']
  vivify_2211:
    defined $I4479, $P4478
    unless $I4479, for_undef_2212
    iter $P4475, $P4478
    new $P4504, 'ExceptionHandler'
    set_label $P4504, loop4503_handler
    $P4504."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4504
  loop4503_test:
    unless $P4475, loop4503_done
    shift $P4480, $P4475
  loop4503_redo:
    .const 'Sub' $P4482 = "502_1303603603.711" 
    capture_lex $P4482
    $P4482($P4480)
  loop4503_next:
    goto loop4503_test
  loop4503_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4505, exception, 'type'
    eq $P4505, .CONTROL_LOOP_NEXT, loop4503_next
    eq $P4505, .CONTROL_LOOP_REDO, loop4503_redo
  loop4503_done:
    pop_eh 
  for_undef_2212:
.annotate 'line', 1460
    find_lex $P4507, "$found_proto"
    unless_null $P4507, vivify_2221
    new $P4507, "Undef"
  vivify_2221:
    if $P4507, unless_4506_end
.annotate 'line', 1461
    find_lex $P4508, "$/"
    unless_null $P4508, vivify_2222
    new $P4508, "Undef"
  vivify_2222:
    $P4509 = $P4508."CURSOR"()
    $P4509."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4506_end:
.annotate 'line', 1465
    get_hll_global $P4510, ["PAST"], "Op"
    $P4511 = $P4510."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4511
.annotate 'line', 1466
    get_hll_global $P4512, ["PAST"], "Op"
.annotate 'line', 1468
    get_hll_global $P4513, ["PAST"], "Var"
    find_lex $P4514, "$name"
    unless_null $P4514, vivify_2223
    new $P4514, "Undef"
  vivify_2223:
    $P4515 = $P4513."new"($P4514 :named("name"), "outer" :named("scope"))
    find_lex $P4516, "$cholder"
    unless_null $P4516, vivify_2224
    new $P4516, "Undef"
  vivify_2224:
    $P4517 = $P4512."new"($P4515, $P4516, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1466
    store_lex "$dispatch_setup", $P4517
.annotate 'line', 1471
    find_lex $P4518, "$?PACKAGE"
    get_who $P4519, $P4518
    set $P4520, $P4519["@BLOCK"]
    unless_null $P4520, vivify_2225
    $P4520 = root_new ['parrot';'ResizablePMCArray']
  vivify_2225:
    set $P4521, $P4520[0]
    unless_null $P4521, vivify_2226
    $P4521 = root_new ['parrot';'ResizablePMCArray']
  vivify_2226:
    set $P4522, $P4521[0]
    unless_null $P4522, vivify_2227
    new $P4522, "Undef"
  vivify_2227:
    get_hll_global $P4523, ["PAST"], "Var"
    find_lex $P4524, "$name"
    unless_null $P4524, vivify_2228
    new $P4524, "Undef"
  vivify_2228:
    find_lex $P4525, "$dispatch_setup"
    unless_null $P4525, vivify_2229
    new $P4525, "Undef"
  vivify_2229:
    $P4526 = $P4523."new"($P4524 :named("name"), 1 :named("isdecl"), $P4525 :named("viviself"), "lexical" :named("scope"))
    $P4522."push"($P4526)
.annotate 'line', 1473
    find_lex $P4527, "$?PACKAGE"
    get_who $P4528, $P4527
    set $P4529, $P4528["@BLOCK"]
    unless_null $P4529, vivify_2230
    $P4529 = root_new ['parrot';'ResizablePMCArray']
  vivify_2230:
    set $P4530, $P4529[0]
    unless_null $P4530, vivify_2231
    new $P4530, "Undef"
  vivify_2231:
    find_lex $P4531, "$name"
    unless_null $P4531, vivify_2232
    new $P4531, "Undef"
  vivify_2232:
    find_lex $P4532, "$cholder"
    unless_null $P4532, vivify_2233
    new $P4532, "Undef"
  vivify_2233:
    $P4533 = $P4530."symbol"($P4531, "lexical" :named("scope"), $P4532 :named("cholder"))
.annotate 'line', 1441
    .return ($P4533)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4481"  :anon :subid("502_1303603603.711") :outer("501_1303603603.711")
    .param pmc param_4484
.annotate 'line', 1450
    $P4483 = root_new ['parrot';'Hash']
    .lex "%sym", $P4483
    .lex "$_", param_4484
    find_lex $P4485, "$_"
    unless_null $P4485, vivify_2213
    new $P4485, "Undef"
  vivify_2213:
    find_lex $P4486, "$name"
    unless_null $P4486, vivify_2214
    new $P4486, "Undef"
  vivify_2214:
    $P4487 = $P4485."symbol"($P4486)
    store_lex "%sym", $P4487
.annotate 'line', 1451
    find_lex $P4492, "%sym"
    unless_null $P4492, vivify_2215
    $P4492 = root_new ['parrot';'Hash']
  vivify_2215:
    set $P4493, $P4492["proto"]
    unless_null $P4493, vivify_2216
    new $P4493, "Undef"
  vivify_2216:
    unless $P4493, unless_4491
    set $P4490, $P4493
    goto unless_4491_end
  unless_4491:
    find_lex $P4494, "%sym"
    unless_null $P4494, vivify_2217
    $P4494 = root_new ['parrot';'Hash']
  vivify_2217:
    set $P4495, $P4494["cholder"]
    unless_null $P4495, vivify_2218
    new $P4495, "Undef"
  vivify_2218:
    set $P4490, $P4495
  unless_4491_end:
    if $P4490, if_4489
.annotate 'line', 1454
    find_lex $P4499, "%sym"
    unless_null $P4499, vivify_2219
    $P4499 = root_new ['parrot';'Hash']
  vivify_2219:
    if $P4499, if_4498
    set $P4497, $P4499
    goto if_4498_end
  if_4498:
.annotate 'line', 1455
    find_lex $P4500, "$/"
    unless_null $P4500, vivify_2220
    new $P4500, "Undef"
  vivify_2220:
    $P4501 = $P4500."CURSOR"()
    $P4502 = $P4501."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1454
    set $P4497, $P4502
  if_4498_end:
    set $P4488, $P4497
.annotate 'line', 1451
    goto if_4489_end
  if_4489:
.annotate 'line', 1452
    new $P4496, "Integer"
    assign $P4496, 1
    store_lex "$found_proto", $P4496
.annotate 'line', 1451
    set $P4488, $P4496
  if_4489_end:
.annotate 'line', 1449
    .return ($P4488)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4651"  :anon :subid("504_1303603603.711") :outer("498_1303603603.711")
    .param pmc param_4653
.annotate 'line', 1534
    .lex "$_", param_4653
    find_lex $P4654, "$_"
    unless_null $P4654, vivify_2251
    new $P4654, "Undef"
  vivify_2251:
    $P4655 = $P4654."ast"()
    find_lex $P4656, "$/"
    unless_null $P4656, vivify_2252
    new $P4656, "Undef"
  vivify_2252:
    $P4657 = $P4655($P4656)
    .return ($P4657)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("505_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4665
    .param pmc param_4666
.annotate 'line', 1541
    .const 'Sub' $P4778 = "507_1303603603.711" 
    capture_lex $P4778
    .const 'Sub' $P4694 = "506_1303603603.711" 
    capture_lex $P4694
    .lex "self", param_4665
    .lex "$/", param_4666
.annotate 'line', 1544
    new $P4667, "Undef"
    .lex "$past", $P4667
.annotate 'line', 1541
    find_lex $P4668, "$past"
    unless_null $P4668, vivify_2254
    new $P4668, "Undef"
  vivify_2254:
.annotate 'line', 1545
    find_lex $P4670, "$/"
    unless_null $P4670, vivify_2255
    $P4670 = root_new ['parrot';'Hash']
  vivify_2255:
    set $P4671, $P4670["onlystar"]
    unless_null $P4671, vivify_2256
    new $P4671, "Undef"
  vivify_2256:
    if $P4671, if_4669
.annotate 'line', 1549
    find_lex $P4673, "$/"
    unless_null $P4673, vivify_2257
    $P4673 = root_new ['parrot';'Hash']
  vivify_2257:
    set $P4674, $P4673["blockoid"]
    unless_null $P4674, vivify_2258
    new $P4674, "Undef"
  vivify_2258:
    $P4675 = $P4674."ast"()
    store_lex "$past", $P4675
.annotate 'line', 1550
    find_lex $P4676, "$past"
    unless_null $P4676, vivify_2259
    new $P4676, "Undef"
  vivify_2259:
    $P4676."blocktype"("declaration")
.annotate 'line', 1551
    find_dynamic_lex $P4678, "$*RETURN_USED"
    unless_null $P4678, vivify_2260
    get_hll_global $P4678, "$RETURN_USED"
    unless_null $P4678, vivify_2261
    die "Contextual $*RETURN_USED not found"
  vivify_2261:
  vivify_2260:
    unless $P4678, if_4677_end
.annotate 'line', 1552
    find_lex $P4679, "$past"
    unless_null $P4679, vivify_2262
    new $P4679, "Undef"
  vivify_2262:
    $P4679."control"("return_pir")
  if_4677_end:
.annotate 'line', 1548
    goto if_4669_end
  if_4669:
.annotate 'line', 1546
    $P4672 = "only_star_block"()
    store_lex "$past", $P4672
  if_4669_end:
.annotate 'line', 1557
    find_lex $P4681, "$past"
    unless_null $P4681, vivify_2263
    $P4681 = root_new ['parrot';'Hash']
  vivify_2263:
    set $P4682, $P4681["signature_has_invocant"]
    unless_null $P4682, vivify_2264
    new $P4682, "Undef"
  vivify_2264:
    if $P4682, unless_4680_end
.annotate 'line', 1558
    find_lex $P4683, "$past"
    unless_null $P4683, vivify_2265
    $P4683 = root_new ['parrot';'ResizablePMCArray']
  vivify_2265:
    set $P4684, $P4683[0]
    unless_null $P4684, vivify_2266
    new $P4684, "Undef"
  vivify_2266:
    get_hll_global $P4685, ["PAST"], "Var"
.annotate 'line', 1560
    get_hll_global $P4686, ["PAST"], "Var"
    $P4687 = $P4686."new"("$?CLASS" :named("name"))
    $P4688 = $P4685."new"("self" :named("name"), "parameter" :named("scope"), $P4687 :named("multitype"))
.annotate 'line', 1558
    $P4684."unshift"($P4688)
  unless_4680_end:
.annotate 'line', 1563
    find_lex $P4689, "$past"
    unless_null $P4689, vivify_2267
    new $P4689, "Undef"
  vivify_2267:
    $P4689."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1566
    find_lex $P4691, "$/"
    unless_null $P4691, vivify_2268
    $P4691 = root_new ['parrot';'Hash']
  vivify_2268:
    set $P4692, $P4691["deflongname"]
    unless_null $P4692, vivify_2269
    new $P4692, "Undef"
  vivify_2269:
    unless $P4692, if_4690_end
    .const 'Sub' $P4694 = "506_1303603603.711" 
    capture_lex $P4694
    $P4694()
  if_4690_end:
.annotate 'line', 1601
    find_dynamic_lex $P4760, "$*SCOPE"
    unless_null $P4760, vivify_2295
    get_hll_global $P4760, "$SCOPE"
    unless_null $P4760, vivify_2296
    die "Contextual $*SCOPE not found"
  vivify_2296:
  vivify_2295:
    set $S4761, $P4760
    iseq $I4762, $S4761, "our"
    unless $I4762, if_4759_end
.annotate 'line', 1602
    find_lex $P4763, "$past"
    unless_null $P4763, vivify_2297
    new $P4763, "Undef"
  vivify_2297:
    $P4763."pirflags"(":nsentry")
  if_4759_end:
.annotate 'line', 1606
    find_lex $P4764, "$/"
    find_lex $P4765, "$past"
    unless_null $P4765, vivify_2298
    new $P4765, "Undef"
  vivify_2298:
    $P4764."!make"($P4765)
.annotate 'line', 1607
    find_lex $P4766, "$past"
    unless_null $P4766, vivify_2299
    new $P4766, "Undef"
  vivify_2299:
    find_lex $P4767, "$past"
    unless_null $P4767, vivify_2300
    $P4767 = root_new ['parrot';'Hash']
    store_lex "$past", $P4767
  vivify_2300:
    set $P4767["block_past"], $P4766
.annotate 'line', 1608
    find_lex $P4770, "$/"
    unless_null $P4770, vivify_2301
    $P4770 = root_new ['parrot';'Hash']
  vivify_2301:
    set $P4771, $P4770["trait"]
    unless_null $P4771, vivify_2302
    new $P4771, "Undef"
  vivify_2302:
    if $P4771, if_4769
    set $P4768, $P4771
    goto if_4769_end
  if_4769:
.annotate 'line', 1609
    find_lex $P4773, "$/"
    unless_null $P4773, vivify_2303
    $P4773 = root_new ['parrot';'Hash']
  vivify_2303:
    set $P4774, $P4773["trait"]
    unless_null $P4774, vivify_2304
    new $P4774, "Undef"
  vivify_2304:
    defined $I4775, $P4774
    unless $I4775, for_undef_2305
    iter $P4772, $P4774
    new $P4785, 'ExceptionHandler'
    set_label $P4785, loop4784_handler
    $P4785."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4785
  loop4784_test:
    unless $P4772, loop4784_done
    shift $P4776, $P4772
  loop4784_redo:
    .const 'Sub' $P4778 = "507_1303603603.711" 
    capture_lex $P4778
    $P4778($P4776)
  loop4784_next:
    goto loop4784_test
  loop4784_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4786, exception, 'type'
    eq $P4786, .CONTROL_LOOP_NEXT, loop4784_next
    eq $P4786, .CONTROL_LOOP_REDO, loop4784_redo
  loop4784_done:
    pop_eh 
  for_undef_2305:
.annotate 'line', 1608
    set $P4768, $P4772
  if_4769_end:
.annotate 'line', 1541
    .return ($P4768)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4693"  :anon :subid("506_1303603603.711") :outer("505_1303603603.711")
.annotate 'line', 1568
    new $P4695, "Undef"
    .lex "$name", $P4695
.annotate 'line', 1573
    new $P4696, "Undef"
    .lex "$to_add", $P4696
.annotate 'line', 1568
    find_lex $P4697, "$/"
    unless_null $P4697, vivify_2270
    $P4697 = root_new ['parrot';'Hash']
  vivify_2270:
    set $P4698, $P4697["private"]
    unless_null $P4698, vivify_2271
    new $P4698, "Undef"
  vivify_2271:
    set $S4699, $P4698
    new $P4700, 'String'
    set $P4700, $S4699
    find_lex $P4701, "$/"
    unless_null $P4701, vivify_2272
    $P4701 = root_new ['parrot';'Hash']
  vivify_2272:
    set $P4702, $P4701["deflongname"]
    unless_null $P4702, vivify_2273
    $P4702 = root_new ['parrot';'ResizablePMCArray']
  vivify_2273:
    set $P4703, $P4702[0]
    unless_null $P4703, vivify_2274
    new $P4703, "Undef"
  vivify_2274:
    $P4704 = $P4703."ast"()
    set $S4705, $P4704
    concat $P4706, $P4700, $S4705
    store_lex "$name", $P4706
.annotate 'line', 1569
    find_lex $P4707, "$past"
    unless_null $P4707, vivify_2275
    new $P4707, "Undef"
  vivify_2275:
    find_lex $P4708, "$name"
    unless_null $P4708, vivify_2276
    new $P4708, "Undef"
  vivify_2276:
    $P4707."name"($P4708)
.annotate 'line', 1573
    find_dynamic_lex $P4711, "$*MULTINESS"
    unless_null $P4711, vivify_2277
    get_hll_global $P4711, "$MULTINESS"
    unless_null $P4711, vivify_2278
    die "Contextual $*MULTINESS not found"
  vivify_2278:
  vivify_2277:
    set $S4712, $P4711
    isne $I4713, $S4712, "proto"
    if $I4713, if_4710
.annotate 'line', 1575
    get_hll_global $P4717, ["PAST"], "Op"
.annotate 'line', 1577
    get_hll_global $P4718, ["PAST"], "Val"
    find_lex $P4719, "$past"
    unless_null $P4719, vivify_2279
    new $P4719, "Undef"
  vivify_2279:
    $P4720 = $P4718."new"($P4719 :named("value"))
.annotate 'line', 1578
    get_hll_global $P4721, ["PAST"], "Op"
    $P4722 = $P4721."new"("list" :named("pasttype"))
    $P4723 = $P4717."new"($P4720, $P4722, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1575
    set $P4709, $P4723
.annotate 'line', 1573
    goto if_4710_end
  if_4710:
.annotate 'line', 1574
    get_hll_global $P4714, ["PAST"], "Val"
    find_lex $P4715, "$past"
    unless_null $P4715, vivify_2280
    new $P4715, "Undef"
  vivify_2280:
    $P4716 = $P4714."new"($P4715 :named("value"))
    set $P4709, $P4716
  if_4710_end:
.annotate 'line', 1573
    store_lex "$to_add", $P4709
.annotate 'line', 1580
    find_dynamic_lex $P4725, "$*MULTINESS"
    unless_null $P4725, vivify_2281
    get_hll_global $P4725, "$MULTINESS"
    unless_null $P4725, vivify_2282
    die "Contextual $*MULTINESS not found"
  vivify_2282:
  vivify_2281:
    set $S4726, $P4725
    iseq $I4727, $S4726, "proto"
    unless $I4727, if_4724_end
    find_lex $P4728, "$past"
    unless_null $P4728, vivify_2283
    new $P4728, "Undef"
  vivify_2283:
    $P4728."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4724_end:
.annotate 'line', 1584
    find_dynamic_lex $P4730, "$*MULTINESS"
    unless_null $P4730, vivify_2284
    get_hll_global $P4730, "$MULTINESS"
    unless_null $P4730, vivify_2285
    die "Contextual $*MULTINESS not found"
  vivify_2285:
  vivify_2284:
    set $S4731, $P4730
    iseq $I4732, $S4731, "multi"
    unless $I4732, if_4729_end
    find_lex $P4733, "$past"
    unless_null $P4733, vivify_2286
    new $P4733, "Undef"
  vivify_2286:
    "attach_multi_signature"($P4733)
  if_4729_end:
.annotate 'line', 1587
    find_dynamic_lex $P4736, "$*PACKAGE-SETUP"
    unless_null $P4736, vivify_2287
    get_hll_global $P4736, "$PACKAGE-SETUP"
    unless_null $P4736, vivify_2288
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2288:
  vivify_2287:
    defined $I4737, $P4736
    if $I4737, if_4735
    new $P4734, 'Integer'
    set $P4734, $I4737
    goto if_4735_end
  if_4735:
.annotate 'line', 1588
    find_dynamic_lex $P4738, "$*PACKAGE-SETUP"
    unless_null $P4738, vivify_2289
    get_hll_global $P4738, "$PACKAGE-SETUP"
    unless_null $P4738, vivify_2290
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2290:
  vivify_2289:
    get_hll_global $P4739, ["PAST"], "Op"
.annotate 'line', 1589
    find_dynamic_lex $P4742, "$*MULTINESS"
    unless_null $P4742, vivify_2291
    get_hll_global $P4742, "$MULTINESS"
    unless_null $P4742, vivify_2292
    die "Contextual $*MULTINESS not found"
  vivify_2292:
  vivify_2291:
    set $S4743, $P4742
    iseq $I4744, $S4743, "multi"
    if $I4744, if_4741
    new $P4746, "String"
    assign $P4746, "add_method"
    set $P4740, $P4746
    goto if_4741_end
  if_4741:
    new $P4745, "String"
    assign $P4745, "add_multi_method"
    set $P4740, $P4745
  if_4741_end:
.annotate 'line', 1590
    get_hll_global $P4747, ["PAST"], "Op"
.annotate 'line', 1593
    get_hll_global $P4748, ["PAST"], "Var"
    $P4749 = $P4748."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4750 = $P4747."new"($P4749, "get_how PP" :named("pirop"))
.annotate 'line', 1595
    get_hll_global $P4751, ["PAST"], "Var"
    $P4752 = $P4751."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1596
    get_hll_global $P4753, ["PAST"], "Val"
    find_lex $P4754, "$name"
    unless_null $P4754, vivify_2293
    new $P4754, "Undef"
  vivify_2293:
    $P4755 = $P4753."new"($P4754 :named("value"))
    find_lex $P4756, "$to_add"
    unless_null $P4756, vivify_2294
    new $P4756, "Undef"
  vivify_2294:
    $P4757 = $P4739."new"($P4750, $P4752, $P4755, $P4756, "callmethod" :named("pasttype"), $P4740 :named("name"))
.annotate 'line', 1588
    $P4758 = $P4738."push"($P4757)
.annotate 'line', 1587
    set $P4734, $P4758
  if_4735_end:
.annotate 'line', 1566
    .return ($P4734)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4777"  :anon :subid("507_1303603603.711") :outer("505_1303603603.711")
    .param pmc param_4779
.annotate 'line', 1609
    .lex "$_", param_4779
    find_lex $P4780, "$_"
    unless_null $P4780, vivify_2306
    new $P4780, "Undef"
  vivify_2306:
    $P4781 = $P4780."ast"()
    find_lex $P4782, "$/"
    unless_null $P4782, vivify_2307
    new $P4782, "Undef"
  vivify_2307:
    $P4783 = $P4781($P4782)
    .return ($P4783)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("508_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4790
    .param pmc param_4791
.annotate 'line', 1641
    .const 'Sub' $P4828 = "510_1303603603.711" 
    capture_lex $P4828
    .const 'Sub' $P4802 = "509_1303603603.711" 
    capture_lex $P4802
    .lex "self", param_4790
    .lex "$/", param_4791
.annotate 'line', 1642
    new $P4792, "Undef"
    .lex "$BLOCKINIT", $P4792
    find_lex $P4793, "$?PACKAGE"
    get_who $P4794, $P4793
    set $P4795, $P4794["@BLOCK"]
    unless_null $P4795, vivify_2308
    $P4795 = root_new ['parrot';'ResizablePMCArray']
  vivify_2308:
    set $P4796, $P4795[0]
    unless_null $P4796, vivify_2309
    $P4796 = root_new ['parrot';'ResizablePMCArray']
  vivify_2309:
    set $P4797, $P4796[0]
    unless_null $P4797, vivify_2310
    new $P4797, "Undef"
  vivify_2310:
    store_lex "$BLOCKINIT", $P4797
.annotate 'line', 1643
    find_lex $P4799, "$/"
    unless_null $P4799, vivify_2311
    $P4799 = root_new ['parrot';'Hash']
  vivify_2311:
    set $P4800, $P4799["invocant"]
    unless_null $P4800, vivify_2312
    new $P4800, "Undef"
  vivify_2312:
    unless $P4800, if_4798_end
    .const 'Sub' $P4802 = "509_1303603603.711" 
    capture_lex $P4802
    $P4802()
  if_4798_end:
.annotate 'line', 1652
    find_lex $P4823, "$/"
    unless_null $P4823, vivify_2322
    $P4823 = root_new ['parrot';'Hash']
  vivify_2322:
    set $P4824, $P4823["parameter"]
    unless_null $P4824, vivify_2323
    new $P4824, "Undef"
  vivify_2323:
    defined $I4825, $P4824
    unless $I4825, for_undef_2324
    iter $P4822, $P4824
    new $P4835, 'ExceptionHandler'
    set_label $P4835, loop4834_handler
    $P4835."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4835
  loop4834_test:
    unless $P4822, loop4834_done
    shift $P4826, $P4822
  loop4834_redo:
    .const 'Sub' $P4828 = "510_1303603603.711" 
    capture_lex $P4828
    $P4828($P4826)
  loop4834_next:
    goto loop4834_test
  loop4834_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4836, exception, 'type'
    eq $P4836, .CONTROL_LOOP_NEXT, loop4834_next
    eq $P4836, .CONTROL_LOOP_REDO, loop4834_redo
  loop4834_done:
    pop_eh 
  for_undef_2324:
.annotate 'line', 1641
    .return ($P4822)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4801"  :anon :subid("509_1303603603.711") :outer("508_1303603603.711")
.annotate 'line', 1644
    new $P4803, "Undef"
    .lex "$inv", $P4803
    find_lex $P4804, "$/"
    unless_null $P4804, vivify_2313
    $P4804 = root_new ['parrot';'Hash']
  vivify_2313:
    set $P4805, $P4804["invocant"]
    unless_null $P4805, vivify_2314
    $P4805 = root_new ['parrot';'ResizablePMCArray']
  vivify_2314:
    set $P4806, $P4805[0]
    unless_null $P4806, vivify_2315
    new $P4806, "Undef"
  vivify_2315:
    $P4807 = $P4806."ast"()
    store_lex "$inv", $P4807
.annotate 'line', 1645
    find_lex $P4808, "$BLOCKINIT"
    unless_null $P4808, vivify_2316
    new $P4808, "Undef"
  vivify_2316:
    find_lex $P4809, "$inv"
    unless_null $P4809, vivify_2317
    new $P4809, "Undef"
  vivify_2317:
    $P4808."push"($P4809)
.annotate 'line', 1646
    find_lex $P4810, "$BLOCKINIT"
    unless_null $P4810, vivify_2318
    new $P4810, "Undef"
  vivify_2318:
    get_hll_global $P4811, ["PAST"], "Var"
.annotate 'line', 1648
    get_hll_global $P4812, ["PAST"], "Var"
    find_lex $P4813, "$inv"
    unless_null $P4813, vivify_2319
    new $P4813, "Undef"
  vivify_2319:
    $P4814 = $P4813."name"()
    $P4815 = $P4812."new"("lexical" :named("scope"), $P4814 :named("name"))
    $P4816 = $P4811."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4815 :named("viviself"))
.annotate 'line', 1646
    $P4810."push"($P4816)
.annotate 'line', 1650
    new $P4817, "Integer"
    assign $P4817, 1
    find_lex $P4818, "$?PACKAGE"
    get_who $P4819, $P4818
    set $P4820, $P4819["@BLOCK"]
    unless_null $P4820, vivify_2320
    $P4820 = root_new ['parrot';'ResizablePMCArray']
    set $P4819["@BLOCK"], $P4820
  vivify_2320:
    set $P4821, $P4820[0]
    unless_null $P4821, vivify_2321
    $P4821 = root_new ['parrot';'Hash']
    set $P4820[0], $P4821
  vivify_2321:
    set $P4821["signature_has_invocant"], $P4817
.annotate 'line', 1643
    .return ($P4817)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4827"  :anon :subid("510_1303603603.711") :outer("508_1303603603.711")
    .param pmc param_4829
.annotate 'line', 1652
    .lex "$_", param_4829
    find_lex $P4830, "$BLOCKINIT"
    unless_null $P4830, vivify_2325
    new $P4830, "Undef"
  vivify_2325:
    find_lex $P4831, "$_"
    unless_null $P4831, vivify_2326
    new $P4831, "Undef"
  vivify_2326:
    $P4832 = $P4831."ast"()
    $P4833 = $P4830."push"($P4832)
    .return ($P4833)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("511_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4838
    .param pmc param_4839
.annotate 'line', 1655
    .lex "self", param_4838
    .lex "$/", param_4839
.annotate 'line', 1656
    new $P4840, "Undef"
    .lex "$quant", $P4840
.annotate 'line', 1657
    new $P4841, "Undef"
    .lex "$past", $P4841
.annotate 'line', 1656
    find_lex $P4842, "$/"
    unless_null $P4842, vivify_2327
    $P4842 = root_new ['parrot';'Hash']
  vivify_2327:
    set $P4843, $P4842["quant"]
    unless_null $P4843, vivify_2328
    new $P4843, "Undef"
  vivify_2328:
    store_lex "$quant", $P4843
    find_lex $P4844, "$past"
    unless_null $P4844, vivify_2329
    new $P4844, "Undef"
  vivify_2329:
.annotate 'line', 1658
    find_lex $P4846, "$/"
    unless_null $P4846, vivify_2330
    $P4846 = root_new ['parrot';'Hash']
  vivify_2330:
    set $P4847, $P4846["named_param"]
    unless_null $P4847, vivify_2331
    new $P4847, "Undef"
  vivify_2331:
    if $P4847, if_4845
.annotate 'line', 1665
    find_lex $P4861, "$/"
    unless_null $P4861, vivify_2332
    $P4861 = root_new ['parrot';'Hash']
  vivify_2332:
    set $P4862, $P4861["param_var"]
    unless_null $P4862, vivify_2333
    new $P4862, "Undef"
  vivify_2333:
    $P4863 = $P4862."ast"()
    store_lex "$past", $P4863
.annotate 'line', 1666
    find_lex $P4865, "$quant"
    unless_null $P4865, vivify_2334
    new $P4865, "Undef"
  vivify_2334:
    set $S4866, $P4865
    iseq $I4867, $S4866, "*"
    if $I4867, if_4864
.annotate 'line', 1670
    find_lex $P4876, "$quant"
    unless_null $P4876, vivify_2335
    new $P4876, "Undef"
  vivify_2335:
    set $S4877, $P4876
    iseq $I4878, $S4877, "?"
    unless $I4878, if_4875_end
.annotate 'line', 1671
    find_lex $P4879, "$past"
    unless_null $P4879, vivify_2336
    new $P4879, "Undef"
  vivify_2336:
    find_lex $P4880, "$/"
    unless_null $P4880, vivify_2337
    $P4880 = root_new ['parrot';'Hash']
  vivify_2337:
    set $P4881, $P4880["param_var"]
    unless_null $P4881, vivify_2338
    $P4881 = root_new ['parrot';'Hash']
  vivify_2338:
    set $P4882, $P4881["sigil"]
    unless_null $P4882, vivify_2339
    new $P4882, "Undef"
  vivify_2339:
    $P4883 = "vivitype"($P4882)
    $P4879."viviself"($P4883)
  if_4875_end:
.annotate 'line', 1670
    goto if_4864_end
  if_4864:
.annotate 'line', 1667
    find_lex $P4868, "$past"
    unless_null $P4868, vivify_2340
    new $P4868, "Undef"
  vivify_2340:
    $P4868."slurpy"(1)
.annotate 'line', 1668
    find_lex $P4869, "$past"
    unless_null $P4869, vivify_2341
    new $P4869, "Undef"
  vivify_2341:
    find_lex $P4870, "$/"
    unless_null $P4870, vivify_2342
    $P4870 = root_new ['parrot';'Hash']
  vivify_2342:
    set $P4871, $P4870["param_var"]
    unless_null $P4871, vivify_2343
    $P4871 = root_new ['parrot';'Hash']
  vivify_2343:
    set $P4872, $P4871["sigil"]
    unless_null $P4872, vivify_2344
    new $P4872, "Undef"
  vivify_2344:
    set $S4873, $P4872
    iseq $I4874, $S4873, "%"
    $P4869."named"($I4874)
  if_4864_end:
.annotate 'line', 1664
    goto if_4845_end
  if_4845:
.annotate 'line', 1659
    find_lex $P4848, "$/"
    unless_null $P4848, vivify_2345
    $P4848 = root_new ['parrot';'Hash']
  vivify_2345:
    set $P4849, $P4848["named_param"]
    unless_null $P4849, vivify_2346
    new $P4849, "Undef"
  vivify_2346:
    $P4850 = $P4849."ast"()
    store_lex "$past", $P4850
.annotate 'line', 1660
    find_lex $P4852, "$quant"
    unless_null $P4852, vivify_2347
    new $P4852, "Undef"
  vivify_2347:
    set $S4853, $P4852
    isne $I4854, $S4853, "!"
    unless $I4854, if_4851_end
.annotate 'line', 1661
    find_lex $P4855, "$past"
    unless_null $P4855, vivify_2348
    new $P4855, "Undef"
  vivify_2348:
    find_lex $P4856, "$/"
    unless_null $P4856, vivify_2349
    $P4856 = root_new ['parrot';'Hash']
  vivify_2349:
    set $P4857, $P4856["named_param"]
    unless_null $P4857, vivify_2350
    $P4857 = root_new ['parrot';'Hash']
  vivify_2350:
    set $P4858, $P4857["param_var"]
    unless_null $P4858, vivify_2351
    $P4858 = root_new ['parrot';'Hash']
  vivify_2351:
    set $P4859, $P4858["sigil"]
    unless_null $P4859, vivify_2352
    new $P4859, "Undef"
  vivify_2352:
    $P4860 = "vivitype"($P4859)
    $P4855."viviself"($P4860)
  if_4851_end:
  if_4845_end:
.annotate 'line', 1674
    find_lex $P4885, "$/"
    unless_null $P4885, vivify_2353
    $P4885 = root_new ['parrot';'Hash']
  vivify_2353:
    set $P4886, $P4885["default_value"]
    unless_null $P4886, vivify_2354
    new $P4886, "Undef"
  vivify_2354:
    unless $P4886, if_4884_end
.annotate 'line', 1675
    find_lex $P4888, "$quant"
    unless_null $P4888, vivify_2355
    new $P4888, "Undef"
  vivify_2355:
    set $S4889, $P4888
    iseq $I4890, $S4889, "*"
    unless $I4890, if_4887_end
.annotate 'line', 1676
    find_lex $P4891, "$/"
    unless_null $P4891, vivify_2356
    new $P4891, "Undef"
  vivify_2356:
    $P4892 = $P4891."CURSOR"()
    $P4892."panic"("Can't put default on slurpy parameter")
  if_4887_end:
.annotate 'line', 1678
    find_lex $P4894, "$quant"
    unless_null $P4894, vivify_2357
    new $P4894, "Undef"
  vivify_2357:
    set $S4895, $P4894
    iseq $I4896, $S4895, "!"
    unless $I4896, if_4893_end
.annotate 'line', 1679
    find_lex $P4897, "$/"
    unless_null $P4897, vivify_2358
    new $P4897, "Undef"
  vivify_2358:
    $P4898 = $P4897."CURSOR"()
    $P4898."panic"("Can't put default on required parameter")
  if_4893_end:
.annotate 'line', 1681
    find_lex $P4899, "$past"
    unless_null $P4899, vivify_2359
    new $P4899, "Undef"
  vivify_2359:
    find_lex $P4900, "$/"
    unless_null $P4900, vivify_2360
    $P4900 = root_new ['parrot';'Hash']
  vivify_2360:
    set $P4901, $P4900["default_value"]
    unless_null $P4901, vivify_2361
    $P4901 = root_new ['parrot';'ResizablePMCArray']
  vivify_2361:
    set $P4902, $P4901[0]
    unless_null $P4902, vivify_2362
    $P4902 = root_new ['parrot';'Hash']
  vivify_2362:
    set $P4903, $P4902["EXPR"]
    unless_null $P4903, vivify_2363
    new $P4903, "Undef"
  vivify_2363:
    $P4904 = $P4903."ast"()
    $P4899."viviself"($P4904)
  if_4884_end:
.annotate 'line', 1683
    find_lex $P4906, "$past"
    unless_null $P4906, vivify_2364
    new $P4906, "Undef"
  vivify_2364:
    $P4907 = $P4906."viviself"()
    if $P4907, unless_4905_end
    find_lex $P4908, "$?PACKAGE"
    get_who $P4909, $P4908
    set $P4910, $P4909["@BLOCK"]
    unless_null $P4910, vivify_2365
    $P4910 = root_new ['parrot';'ResizablePMCArray']
  vivify_2365:
    set $P4911, $P4910[0]
    unless_null $P4911, vivify_2366
    new $P4911, "Undef"
  vivify_2366:
    find_lex $P4912, "$?PACKAGE"
    get_who $P4913, $P4912
    set $P4914, $P4913["@BLOCK"]
    unless_null $P4914, vivify_2367
    $P4914 = root_new ['parrot';'ResizablePMCArray']
  vivify_2367:
    set $P4915, $P4914[0]
    unless_null $P4915, vivify_2368
    new $P4915, "Undef"
  vivify_2368:
    $P4916 = $P4915."arity"()
    set $N4917, $P4916
    new $P4918, 'Float'
    set $P4918, $N4917
    add $P4919, $P4918, 1
    $P4911."arity"($P4919)
  unless_4905_end:
.annotate 'line', 1687
    find_lex $P4921, "$/"
    unless_null $P4921, vivify_2369
    $P4921 = root_new ['parrot';'Hash']
  vivify_2369:
    set $P4922, $P4921["typename"]
    unless_null $P4922, vivify_2370
    new $P4922, "Undef"
  vivify_2370:
    unless $P4922, if_4920_end
.annotate 'line', 1688
    find_lex $P4923, "$past"
    unless_null $P4923, vivify_2371
    new $P4923, "Undef"
  vivify_2371:
    find_lex $P4924, "$/"
    unless_null $P4924, vivify_2372
    $P4924 = root_new ['parrot';'Hash']
  vivify_2372:
    set $P4925, $P4924["typename"]
    unless_null $P4925, vivify_2373
    $P4925 = root_new ['parrot';'ResizablePMCArray']
  vivify_2373:
    set $P4926, $P4925[0]
    unless_null $P4926, vivify_2374
    new $P4926, "Undef"
  vivify_2374:
    $P4927 = $P4926."ast"()
    $P4923."multitype"($P4927)
  if_4920_end:
.annotate 'line', 1692
    find_lex $P4929, "$/"
    unless_null $P4929, vivify_2375
    $P4929 = root_new ['parrot';'Hash']
  vivify_2375:
    set $P4930, $P4929["definedness"]
    unless_null $P4930, vivify_2376
    new $P4930, "Undef"
  vivify_2376:
    unless $P4930, if_4928_end
.annotate 'line', 1693
    find_lex $P4931, "$/"
    unless_null $P4931, vivify_2377
    $P4931 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P4932, $P4931["definedness"]
    unless_null $P4932, vivify_2378
    $P4932 = root_new ['parrot';'ResizablePMCArray']
  vivify_2378:
    set $P4933, $P4932[0]
    unless_null $P4933, vivify_2379
    new $P4933, "Undef"
  vivify_2379:
    set $S4934, $P4933
    new $P4935, 'String'
    set $P4935, $S4934
    find_lex $P4936, "$past"
    unless_null $P4936, vivify_2380
    $P4936 = root_new ['parrot';'Hash']
    store_lex "$past", $P4936
  vivify_2380:
    set $P4936["definedness"], $P4935
  if_4928_end:
.annotate 'line', 1696
    find_lex $P4937, "$/"
    find_lex $P4938, "$past"
    unless_null $P4938, vivify_2381
    new $P4938, "Undef"
  vivify_2381:
    $P4939 = $P4937."!make"($P4938)
.annotate 'line', 1655
    .return ($P4939)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("512_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4941
    .param pmc param_4942
.annotate 'line', 1699
    .lex "self", param_4941
    .lex "$/", param_4942
.annotate 'line', 1700
    new $P4943, "Undef"
    .lex "$name", $P4943
.annotate 'line', 1701
    new $P4944, "Undef"
    .lex "$past", $P4944
.annotate 'line', 1700
    find_lex $P4945, "$/"
    unless_null $P4945, vivify_2382
    new $P4945, "Undef"
  vivify_2382:
    set $S4946, $P4945
    new $P4947, 'String'
    set $P4947, $S4946
    store_lex "$name", $P4947
.annotate 'line', 1701
    get_hll_global $P4948, ["PAST"], "Var"
    find_lex $P4949, "$name"
    unless_null $P4949, vivify_2383
    new $P4949, "Undef"
  vivify_2383:
    find_lex $P4950, "$/"
    unless_null $P4950, vivify_2384
    new $P4950, "Undef"
  vivify_2384:
    $P4951 = $P4948."new"($P4949 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4950 :named("node"))
    store_lex "$past", $P4951
.annotate 'line', 1703
    find_lex $P4952, "$?PACKAGE"
    get_who $P4953, $P4952
    set $P4954, $P4953["@BLOCK"]
    unless_null $P4954, vivify_2385
    $P4954 = root_new ['parrot';'ResizablePMCArray']
  vivify_2385:
    set $P4955, $P4954[0]
    unless_null $P4955, vivify_2386
    new $P4955, "Undef"
  vivify_2386:
    find_lex $P4956, "$name"
    unless_null $P4956, vivify_2387
    new $P4956, "Undef"
  vivify_2387:
    $P4955."symbol"($P4956, "lexical" :named("scope"))
.annotate 'line', 1704
    find_lex $P4957, "$/"
    find_lex $P4958, "$past"
    unless_null $P4958, vivify_2388
    new $P4958, "Undef"
  vivify_2388:
    $P4959 = $P4957."!make"($P4958)
.annotate 'line', 1699
    .return ($P4959)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("513_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4961
    .param pmc param_4962
.annotate 'line', 1707
    .lex "self", param_4961
    .lex "$/", param_4962
.annotate 'line', 1708
    new $P4963, "Undef"
    .lex "$past", $P4963
    find_lex $P4964, "$/"
    unless_null $P4964, vivify_2389
    $P4964 = root_new ['parrot';'Hash']
  vivify_2389:
    set $P4965, $P4964["param_var"]
    unless_null $P4965, vivify_2390
    new $P4965, "Undef"
  vivify_2390:
    $P4966 = $P4965."ast"()
    store_lex "$past", $P4966
.annotate 'line', 1709
    find_lex $P4967, "$past"
    unless_null $P4967, vivify_2391
    new $P4967, "Undef"
  vivify_2391:
    find_lex $P4968, "$/"
    unless_null $P4968, vivify_2392
    $P4968 = root_new ['parrot';'Hash']
  vivify_2392:
    set $P4969, $P4968["param_var"]
    unless_null $P4969, vivify_2393
    $P4969 = root_new ['parrot';'Hash']
  vivify_2393:
    set $P4970, $P4969["name"]
    unless_null $P4970, vivify_2394
    new $P4970, "Undef"
  vivify_2394:
    set $S4971, $P4970
    $P4967."named"($S4971)
.annotate 'line', 1710
    find_lex $P4972, "$/"
    find_lex $P4973, "$past"
    unless_null $P4973, vivify_2395
    new $P4973, "Undef"
  vivify_2395:
    $P4974 = $P4972."!make"($P4973)
.annotate 'line', 1707
    .return ($P4974)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("514_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4976
    .param pmc param_4977
.annotate 'line', 1713
    .lex "self", param_4976
    .lex "$/", param_4977
.annotate 'line', 1714
    $P4978 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4978
    get_hll_global $P4979, ["HLL"], "Compiler"
    find_lex $P4980, "$/"
    unless_null $P4980, vivify_2396
    new $P4980, "Undef"
  vivify_2396:
    set $S4981, $P4980
    $P4982 = $P4979."parse_name"($S4981)
    store_lex "@name", $P4982
.annotate 'line', 1715
    find_lex $P4983, "$/"
    get_hll_global $P4984, ["PAST"], "Var"
.annotate 'line', 1716
    find_lex $P4985, "@name"
    unless_null $P4985, vivify_2397
    $P4985 = root_new ['parrot';'ResizablePMCArray']
  vivify_2397:
    $P4986 = $P4985."pop"()
    find_lex $P4987, "@name"
    unless_null $P4987, vivify_2398
    $P4987 = root_new ['parrot';'ResizablePMCArray']
  vivify_2398:
    $P4988 = $P4984."new"($P4986 :named("name"), $P4987 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1715
    $P4989 = $P4983."!make"($P4988)
.annotate 'line', 1713
    .return ($P4989)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("515_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4991
    .param pmc param_4992
.annotate 'line', 1722
    .lex "self", param_4991
    .lex "$/", param_4992
.annotate 'line', 1723
    find_lex $P4993, "$/"
    find_lex $P4994, "$/"
    unless_null $P4994, vivify_2399
    $P4994 = root_new ['parrot';'Hash']
  vivify_2399:
    set $P4995, $P4994["trait_mod"]
    unless_null $P4995, vivify_2400
    new $P4995, "Undef"
  vivify_2400:
    $P4996 = $P4995."ast"()
    $P4997 = $P4993."!make"($P4996)
.annotate 'line', 1722
    .return ($P4997)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("516_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_4999
    .param pmc param_5000
.annotate 'line', 1726
    .const 'Sub' $P5020 = "517_1303603603.711" 
    capture_lex $P5020
    .lex "self", param_4999
    .lex "$/", param_5000
.annotate 'line', 1727
    new $P5001, "Undef"
    .lex "$cpast", $P5001
    find_lex $P5002, "$/"
    unless_null $P5002, vivify_2401
    $P5002 = root_new ['parrot';'Hash']
  vivify_2401:
    set $P5003, $P5002["circumfix"]
    unless_null $P5003, vivify_2402
    $P5003 = root_new ['parrot';'ResizablePMCArray']
  vivify_2402:
    set $P5004, $P5003[0]
    unless_null $P5004, vivify_2403
    new $P5004, "Undef"
  vivify_2403:
    $P5005 = $P5004."ast"()
    store_lex "$cpast", $P5005
.annotate 'line', 1728
    find_lex $P5008, "$/"
    unless_null $P5008, vivify_2404
    $P5008 = root_new ['parrot';'Hash']
  vivify_2404:
    set $P5009, $P5008["longname"]
    unless_null $P5009, vivify_2405
    new $P5009, "Undef"
  vivify_2405:
    set $S5010, $P5009
    iseq $I5011, $S5010, "parrot_vtable"
    if $I5011, if_5007
.annotate 'line', 1748
    find_lex $P5046, "$/"
    unless_null $P5046, vivify_2406
    $P5046 = root_new ['parrot';'Hash']
  vivify_2406:
    set $P5047, $P5046["longname"]
    unless_null $P5047, vivify_2407
    new $P5047, "Undef"
  vivify_2407:
    set $S5048, $P5047
    iseq $I5049, $S5048, "pirflags"
    if $I5049, if_5045
.annotate 'line', 1752
    find_lex $P5053, "$/"
    unless_null $P5053, vivify_2408
    new $P5053, "Undef"
  vivify_2408:
    $P5054 = $P5053."CURSOR"()
    new $P5055, 'String'
    set $P5055, "Trait '"
    find_lex $P5056, "$/"
    unless_null $P5056, vivify_2409
    $P5056 = root_new ['parrot';'Hash']
  vivify_2409:
    set $P5057, $P5056["longname"]
    unless_null $P5057, vivify_2410
    new $P5057, "Undef"
  vivify_2410:
    concat $P5058, $P5055, $P5057
    concat $P5059, $P5058, "' not implemented"
    $P5060 = $P5054."panic"($P5059)
.annotate 'line', 1751
    set $P5044, $P5060
.annotate 'line', 1748
    goto if_5045_end
  if_5045:
.annotate 'line', 1749
    find_lex $P5050, "$/"
    unless_null $P5050, vivify_2411
    new $P5050, "Undef"
  vivify_2411:
    $P5051 = $P5050."CURSOR"()
    $P5052 = $P5051."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1748
    set $P5044, $P5052
  if_5045_end:
    set $P5006, $P5044
.annotate 'line', 1728
    goto if_5007_end
  if_5007:
.annotate 'line', 1731
    get_hll_global $P5013, ["PAST"], "Val"
    find_lex $P5014, "$cpast"
    unless_null $P5014, vivify_2412
    new $P5014, "Undef"
  vivify_2412:
    $P5015 = $P5013."ACCEPTS"($P5014)
    if $P5015, unless_5012_end
.annotate 'line', 1730
    find_lex $P5016, "$/"
    unless_null $P5016, vivify_2413
    new $P5016, "Undef"
  vivify_2413:
    $P5017 = $P5016."CURSOR"()
    $P5017."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_5012_end:
.annotate 'line', 1732
    find_lex $P5018, "$/"
    .const 'Sub' $P5020 = "517_1303603603.711" 
    newclosure $P5042, $P5020
    $P5043 = $P5018."!make"($P5042)
.annotate 'line', 1728
    set $P5006, $P5043
  if_5007_end:
.annotate 'line', 1726
    .return ($P5006)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5019"  :anon :subid("517_1303603603.711") :outer("516_1303603603.711")
    .param pmc param_5021
.annotate 'line', 1732
    .lex "$match", param_5021
.annotate 'line', 1733
    new $P5022, "Undef"
    .lex "$meth", $P5022
    find_lex $P5023, "$match"
    unless_null $P5023, vivify_2414
    new $P5023, "Undef"
  vivify_2414:
    $P5024 = $P5023."ast"()
    set $P5025, $P5024["block_past"]
    unless_null $P5025, vivify_2415
    new $P5025, "Undef"
  vivify_2415:
    store_lex "$meth", $P5025
.annotate 'line', 1734
    find_dynamic_lex $P5028, "$*PACKAGE-SETUP"
    unless_null $P5028, vivify_2416
    get_hll_global $P5028, "$PACKAGE-SETUP"
    unless_null $P5028, vivify_2417
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2417:
  vivify_2416:
    defined $I5029, $P5028
    if $I5029, if_5027
    new $P5026, 'Integer'
    set $P5026, $I5029
    goto if_5027_end
  if_5027:
.annotate 'line', 1735
    find_dynamic_lex $P5030, "$*PACKAGE-SETUP"
    unless_null $P5030, vivify_2418
    get_hll_global $P5030, "$PACKAGE-SETUP"
    unless_null $P5030, vivify_2419
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2419:
  vivify_2418:
    get_hll_global $P5031, ["PAST"], "Op"
.annotate 'line', 1737
    get_hll_global $P5032, ["PAST"], "Op"
.annotate 'line', 1740
    get_hll_global $P5033, ["PAST"], "Var"
    $P5034 = $P5033."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5035 = $P5032."new"($P5034, "get_how PP" :named("pirop"))
.annotate 'line', 1742
    get_hll_global $P5036, ["PAST"], "Var"
    $P5037 = $P5036."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P5038, "$cpast"
    unless_null $P5038, vivify_2420
    new $P5038, "Undef"
  vivify_2420:
    find_lex $P5039, "$meth"
    unless_null $P5039, vivify_2421
    new $P5039, "Undef"
  vivify_2421:
    $P5040 = $P5031."new"($P5035, $P5037, $P5038, $P5039, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1735
    $P5041 = $P5030."push"($P5040)
.annotate 'line', 1734
    set $P5026, $P5041
  if_5027_end:
.annotate 'line', 1732
    .return ($P5026)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("518_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5064
    .param pmc param_5065
    .param pmc param_5066 :optional
    .param int has_param_5066 :opt_flag
.annotate 'line', 1756
    .const 'Sub' $P5173 = "521_1303603603.711" 
    capture_lex $P5173
    .const 'Sub' $P5138 = "520_1303603603.711" 
    capture_lex $P5138
    .const 'Sub' $P5111 = "519_1303603603.711" 
    capture_lex $P5111
    new $P5063, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5063, control_5062
    push_eh $P5063
    .lex "self", param_5064
    .lex "$/", param_5065
    if has_param_5066, optparam_2422
    new $P5067, "Undef"
    set param_5066, $P5067
  optparam_2422:
    .lex "$key", param_5066
.annotate 'line', 1757
    $P5068 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5068
.annotate 'line', 1758
    new $P5069, "Undef"
    .lex "$name", $P5069
.annotate 'line', 1759
    new $P5070, "Undef"
    .lex "$past", $P5070
.annotate 'line', 1757
    get_hll_global $P5071, ["Regex";"P6Regex"], "Actions"
    get_who $P5072, $P5071
    set $P5073, $P5072["@MODIFIERS"]
    unless_null $P5073, vivify_2423
    $P5073 = root_new ['parrot';'ResizablePMCArray']
  vivify_2423:
    store_lex "@MODIFIERS", $P5073
.annotate 'line', 1758
    find_lex $P5074, "$/"
    unless_null $P5074, vivify_2424
    $P5074 = root_new ['parrot';'Hash']
  vivify_2424:
    set $P5075, $P5074["deflongname"]
    unless_null $P5075, vivify_2425
    new $P5075, "Undef"
  vivify_2425:
    $P5076 = $P5075."ast"()
    set $S5077, $P5076
    new $P5078, 'String'
    set $P5078, $S5077
    store_lex "$name", $P5078
    find_lex $P5079, "$past"
    unless_null $P5079, vivify_2426
    new $P5079, "Undef"
  vivify_2426:
.annotate 'line', 1760
    find_lex $P5081, "$/"
    unless_null $P5081, vivify_2427
    $P5081 = root_new ['parrot';'Hash']
  vivify_2427:
    set $P5082, $P5081["proto"]
    unless_null $P5082, vivify_2428
    new $P5082, "Undef"
  vivify_2428:
    if $P5082, if_5080
.annotate 'line', 1799
    find_lex $P5134, "$key"
    unless_null $P5134, vivify_2429
    new $P5134, "Undef"
  vivify_2429:
    set $S5135, $P5134
    iseq $I5136, $S5135, "open"
    if $I5136, if_5133
.annotate 'line', 1809
    .const 'Sub' $P5173 = "521_1303603603.711" 
    capture_lex $P5173
    $P5173()
    goto if_5133_end
  if_5133:
.annotate 'line', 1799
    .const 'Sub' $P5138 = "520_1303603603.711" 
    capture_lex $P5138
    $P5138()
  if_5133_end:
    goto if_5080_end
  if_5080:
.annotate 'line', 1762
    get_hll_global $P5083, ["PAST"], "Stmts"
.annotate 'line', 1763
    get_hll_global $P5084, ["PAST"], "Block"
    find_lex $P5085, "$name"
    unless_null $P5085, vivify_2464
    new $P5085, "Undef"
  vivify_2464:
.annotate 'line', 1764
    get_hll_global $P5086, ["PAST"], "Op"
.annotate 'line', 1765
    get_hll_global $P5087, ["PAST"], "Var"
    $P5088 = $P5087."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5089, "$name"
    unless_null $P5089, vivify_2465
    new $P5089, "Undef"
  vivify_2465:
    $P5090 = $P5086."new"($P5088, $P5089, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1764
    find_lex $P5091, "$/"
    unless_null $P5091, vivify_2466
    new $P5091, "Undef"
  vivify_2466:
    $P5092 = $P5084."new"($P5090, $P5085 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5091 :named("node"))
.annotate 'line', 1774
    get_hll_global $P5093, ["PAST"], "Block"
    new $P5094, "String"
    assign $P5094, "!PREFIX__"
    find_lex $P5095, "$name"
    unless_null $P5095, vivify_2467
    new $P5095, "Undef"
  vivify_2467:
    concat $P5096, $P5094, $P5095
.annotate 'line', 1775
    get_hll_global $P5097, ["PAST"], "Op"
.annotate 'line', 1776
    get_hll_global $P5098, ["PAST"], "Var"
    $P5099 = $P5098."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5100, "$name"
    unless_null $P5100, vivify_2468
    new $P5100, "Undef"
  vivify_2468:
    $P5101 = $P5097."new"($P5099, $P5100, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1775
    find_lex $P5102, "$/"
    unless_null $P5102, vivify_2469
    new $P5102, "Undef"
  vivify_2469:
    $P5103 = $P5093."new"($P5101, $P5096 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5102 :named("node"))
.annotate 'line', 1774
    $P5104 = $P5083."new"($P5092, $P5103)
.annotate 'line', 1762
    store_lex "$past", $P5104
.annotate 'line', 1786
    find_lex $P5106, "$past"
    unless_null $P5106, vivify_2470
    new $P5106, "Undef"
  vivify_2470:
    $P5107 = $P5106."list"()
    defined $I5108, $P5107
    unless $I5108, for_undef_2471
    iter $P5105, $P5107
    new $P5131, 'ExceptionHandler'
    set_label $P5131, loop5130_handler
    $P5131."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5131
  loop5130_test:
    unless $P5105, loop5130_done
    shift $P5109, $P5105
  loop5130_redo:
    .const 'Sub' $P5111 = "519_1303603603.711" 
    capture_lex $P5111
    $P5111($P5109)
  loop5130_next:
    goto loop5130_test
  loop5130_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5132, exception, 'type'
    eq $P5132, .CONTROL_LOOP_NEXT, loop5130_next
    eq $P5132, .CONTROL_LOOP_REDO, loop5130_redo
  loop5130_done:
    pop_eh 
  for_undef_2471:
  if_5080_end:
.annotate 'line', 1845
    find_lex $P5233, "$/"
    find_lex $P5234, "$past"
    unless_null $P5234, vivify_2476
    new $P5234, "Undef"
  vivify_2476:
    $P5235 = $P5233."!make"($P5234)
.annotate 'line', 1756
    .return ($P5235)
  control_5062:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5236, exception, "payload"
    .return ($P5236)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5172"  :anon :subid("521_1303603603.711") :outer("518_1303603603.711")
.annotate 'line', 1810
    new $P5174, "Undef"
    .lex "$regex", $P5174
.annotate 'line', 1811
    get_hll_global $P5175, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5176, "$/"
    unless_null $P5176, vivify_2430
    $P5176 = root_new ['parrot';'Hash']
  vivify_2430:
    set $P5177, $P5176["p6regex"]
    unless_null $P5177, vivify_2431
    new $P5177, "Undef"
  vivify_2431:
    $P5178 = $P5177."ast"()
    find_lex $P5179, "$?PACKAGE"
    get_who $P5180, $P5179
    set $P5181, $P5180["@BLOCK"]
    unless_null $P5181, vivify_2432
    $P5181 = root_new ['parrot';'ResizablePMCArray']
  vivify_2432:
    $P5182 = $P5181."shift"()
    $P5183 = $P5175($P5178, $P5182)
    store_lex "$regex", $P5183
.annotate 'line', 1812
    find_lex $P5184, "$regex"
    unless_null $P5184, vivify_2433
    new $P5184, "Undef"
  vivify_2433:
    find_lex $P5185, "$name"
    unless_null $P5185, vivify_2434
    new $P5185, "Undef"
  vivify_2434:
    $P5184."name"($P5185)
.annotate 'line', 1814
    get_hll_global $P5186, ["PAST"], "Op"
.annotate 'line', 1816
    get_hll_global $P5187, ["PAST"], "Var"
    new $P5188, "ResizablePMCArray"
    push $P5188, "Regex"
    $P5189 = $P5187."new"("Method" :named("name"), $P5188 :named("namespace"), "package" :named("scope"))
    find_lex $P5190, "$regex"
    unless_null $P5190, vivify_2435
    new $P5190, "Undef"
  vivify_2435:
    $P5191 = $P5186."new"($P5189, $P5190, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1814
    store_lex "$past", $P5191
.annotate 'line', 1819
    find_dynamic_lex $P5193, "$*PACKAGE-SETUP"
    unless_null $P5193, vivify_2436
    get_hll_global $P5193, "$PACKAGE-SETUP"
    unless_null $P5193, vivify_2437
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2437:
  vivify_2436:
    defined $I5194, $P5193
    unless $I5194, if_5192_end
.annotate 'line', 1820
    find_dynamic_lex $P5195, "$*PACKAGE-SETUP"
    unless_null $P5195, vivify_2438
    get_hll_global $P5195, "$PACKAGE-SETUP"
    unless_null $P5195, vivify_2439
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2439:
  vivify_2438:
    get_hll_global $P5196, ["PAST"], "Op"
.annotate 'line', 1822
    get_hll_global $P5197, ["PAST"], "Op"
.annotate 'line', 1824
    get_hll_global $P5198, ["PAST"], "Var"
    $P5199 = $P5198."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5200 = $P5197."new"($P5199, "get_how PP" :named("pirop"))
.annotate 'line', 1826
    get_hll_global $P5201, ["PAST"], "Var"
    $P5202 = $P5201."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1827
    get_hll_global $P5203, ["PAST"], "Val"
    find_lex $P5204, "$name"
    unless_null $P5204, vivify_2440
    new $P5204, "Undef"
  vivify_2440:
    $P5205 = $P5203."new"($P5204 :named("value"))
.annotate 'line', 1828
    get_hll_global $P5206, ["PAST"], "Val"
    find_lex $P5207, "$regex"
    unless_null $P5207, vivify_2441
    new $P5207, "Undef"
  vivify_2441:
    $P5208 = $P5206."new"($P5207 :named("value"))
    $P5209 = $P5196."new"($P5200, $P5202, $P5205, $P5208, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1820
    $P5195."push"($P5209)
.annotate 'line', 1830
    find_dynamic_lex $P5210, "$*PACKAGE-SETUP"
    unless_null $P5210, vivify_2442
    get_hll_global $P5210, "$PACKAGE-SETUP"
    unless_null $P5210, vivify_2443
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2443:
  vivify_2442:
    get_hll_global $P5211, ["PAST"], "Op"
.annotate 'line', 1832
    get_hll_global $P5212, ["PAST"], "Op"
.annotate 'line', 1834
    get_hll_global $P5213, ["PAST"], "Var"
    $P5214 = $P5213."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5215 = $P5212."new"($P5214, "get_how PP" :named("pirop"))
.annotate 'line', 1836
    get_hll_global $P5216, ["PAST"], "Var"
    $P5217 = $P5216."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1837
    get_hll_global $P5218, ["PAST"], "Val"
    new $P5219, "String"
    assign $P5219, "!PREFIX__"
    find_lex $P5220, "$name"
    unless_null $P5220, vivify_2444
    new $P5220, "Undef"
  vivify_2444:
    concat $P5221, $P5219, $P5220
    $P5222 = $P5218."new"($P5221 :named("value"))
.annotate 'line', 1838
    get_hll_global $P5223, ["PAST"], "Var"
    new $P5224, "String"
    assign $P5224, "!PREFIX__"
    find_lex $P5225, "$name"
    unless_null $P5225, vivify_2445
    new $P5225, "Undef"
  vivify_2445:
    concat $P5226, $P5224, $P5225
    $P5227 = $P5223."new"($P5226 :named("name"), "package" :named("scope"))
    $P5228 = $P5211."new"($P5215, $P5217, $P5222, $P5227, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1830
    $P5210."push"($P5228)
  if_5192_end:
.annotate 'line', 1842
    find_lex $P5229, "$regex"
    unless_null $P5229, vivify_2446
    new $P5229, "Undef"
  vivify_2446:
    find_lex $P5230, "$past"
    unless_null $P5230, vivify_2447
    $P5230 = root_new ['parrot';'Hash']
    store_lex "$past", $P5230
  vivify_2447:
    set $P5230["sink"], $P5229
.annotate 'line', 1843
    find_lex $P5231, "@MODIFIERS"
    unless_null $P5231, vivify_2448
    $P5231 = root_new ['parrot';'ResizablePMCArray']
  vivify_2448:
    $P5232 = $P5231."shift"()
.annotate 'line', 1809
    .return ($P5232)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5137"  :anon :subid("520_1303603603.711") :outer("518_1303603603.711")
.annotate 'line', 1800
    $P5139 = root_new ['parrot';'Hash']
    .lex "%h", $P5139
.annotate 'line', 1799
    find_lex $P5140, "%h"
    unless_null $P5140, vivify_2449
    $P5140 = root_new ['parrot';'Hash']
  vivify_2449:
.annotate 'line', 1801
    find_lex $P5142, "$/"
    unless_null $P5142, vivify_2450
    $P5142 = root_new ['parrot';'Hash']
  vivify_2450:
    set $P5143, $P5142["sym"]
    unless_null $P5143, vivify_2451
    new $P5143, "Undef"
  vivify_2451:
    set $S5144, $P5143
    iseq $I5145, $S5144, "token"
    unless $I5145, if_5141_end
    new $P5146, "Integer"
    assign $P5146, 1
    find_lex $P5147, "%h"
    unless_null $P5147, vivify_2452
    $P5147 = root_new ['parrot';'Hash']
    store_lex "%h", $P5147
  vivify_2452:
    set $P5147["r"], $P5146
  if_5141_end:
.annotate 'line', 1802
    find_lex $P5149, "$/"
    unless_null $P5149, vivify_2453
    $P5149 = root_new ['parrot';'Hash']
  vivify_2453:
    set $P5150, $P5149["sym"]
    unless_null $P5150, vivify_2454
    new $P5150, "Undef"
  vivify_2454:
    set $S5151, $P5150
    iseq $I5152, $S5151, "rule"
    unless $I5152, if_5148_end
    new $P5153, "Integer"
    assign $P5153, 1
    find_lex $P5154, "%h"
    unless_null $P5154, vivify_2455
    $P5154 = root_new ['parrot';'Hash']
    store_lex "%h", $P5154
  vivify_2455:
    set $P5154["r"], $P5153
    new $P5155, "Integer"
    assign $P5155, 1
    find_lex $P5156, "%h"
    unless_null $P5156, vivify_2456
    $P5156 = root_new ['parrot';'Hash']
    store_lex "%h", $P5156
  vivify_2456:
    set $P5156["s"], $P5155
  if_5148_end:
.annotate 'line', 1803
    find_lex $P5157, "@MODIFIERS"
    unless_null $P5157, vivify_2457
    $P5157 = root_new ['parrot';'ResizablePMCArray']
  vivify_2457:
    find_lex $P5158, "%h"
    unless_null $P5158, vivify_2458
    $P5158 = root_new ['parrot';'Hash']
  vivify_2458:
    $P5157."unshift"($P5158)
.annotate 'line', 1804
    find_lex $P5159, "$name"
    unless_null $P5159, vivify_2459
    new $P5159, "Undef"
  vivify_2459:
    get_hll_global $P5160, ["Regex";"P6Regex"], "Actions"
    get_who $P5161, $P5160
    set $P5161["$REGEXNAME"], $P5159
.annotate 'line', 1805
    find_lex $P5162, "$?PACKAGE"
    get_who $P5163, $P5162
    set $P5164, $P5163["@BLOCK"]
    unless_null $P5164, vivify_2460
    $P5164 = root_new ['parrot';'ResizablePMCArray']
  vivify_2460:
    set $P5165, $P5164[0]
    unless_null $P5165, vivify_2461
    new $P5165, "Undef"
  vivify_2461:
    $P5165."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1806
    find_lex $P5166, "$?PACKAGE"
    get_who $P5167, $P5166
    set $P5168, $P5167["@BLOCK"]
    unless_null $P5168, vivify_2462
    $P5168 = root_new ['parrot';'ResizablePMCArray']
  vivify_2462:
    set $P5169, $P5168[0]
    unless_null $P5169, vivify_2463
    new $P5169, "Undef"
  vivify_2463:
    $P5169."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1807
    new $P5170, "Exception"
    set $P5170['type'], .CONTROL_RETURN
    new $P5171, "Integer"
    assign $P5171, 0
    setattribute $P5170, 'payload', $P5171
    throw $P5170
.annotate 'line', 1799
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5110"  :anon :subid("519_1303603603.711") :outer("518_1303603603.711")
    .param pmc param_5112
.annotate 'line', 1786
    .lex "$_", param_5112
.annotate 'line', 1787
    find_dynamic_lex $P5113, "$*PACKAGE-SETUP"
    unless_null $P5113, vivify_2472
    get_hll_global $P5113, "$PACKAGE-SETUP"
    unless_null $P5113, vivify_2473
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2473:
  vivify_2472:
    get_hll_global $P5114, ["PAST"], "Op"
.annotate 'line', 1789
    get_hll_global $P5115, ["PAST"], "Op"
.annotate 'line', 1791
    get_hll_global $P5116, ["PAST"], "Var"
    $P5117 = $P5116."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5118 = $P5115."new"($P5117, "get_how PP" :named("pirop"))
.annotate 'line', 1793
    get_hll_global $P5119, ["PAST"], "Var"
    $P5120 = $P5119."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1794
    get_hll_global $P5121, ["PAST"], "Val"
    find_lex $P5122, "$_"
    unless_null $P5122, vivify_2474
    new $P5122, "Undef"
  vivify_2474:
    $P5123 = $P5122."name"()
    $P5124 = $P5121."new"($P5123 :named("value"))
.annotate 'line', 1795
    get_hll_global $P5125, ["PAST"], "Val"
    find_lex $P5126, "$_"
    unless_null $P5126, vivify_2475
    new $P5126, "Undef"
  vivify_2475:
    $P5127 = $P5125."new"($P5126 :named("value"))
    $P5128 = $P5114."new"($P5118, $P5120, $P5124, $P5127, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1787
    $P5129 = $P5113."push"($P5128)
.annotate 'line', 1786
    .return ($P5129)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("522_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5238
    .param pmc param_5239
.annotate 'line', 1849
    .lex "self", param_5238
    .lex "$/", param_5239
.annotate 'line', 1850
    new $P5240, "Undef"
    .lex "$past", $P5240
    find_lex $P5243, "$/"
    unless_null $P5243, vivify_2477
    $P5243 = root_new ['parrot';'Hash']
  vivify_2477:
    set $P5244, $P5243["args"]
    unless_null $P5244, vivify_2478
    new $P5244, "Undef"
  vivify_2478:
    if $P5244, if_5242
    get_hll_global $P5249, ["PAST"], "Op"
    find_lex $P5250, "$/"
    unless_null $P5250, vivify_2479
    new $P5250, "Undef"
  vivify_2479:
    $P5251 = $P5249."new"($P5250 :named("node"))
    set $P5241, $P5251
    goto if_5242_end
  if_5242:
    find_lex $P5245, "$/"
    unless_null $P5245, vivify_2480
    $P5245 = root_new ['parrot';'Hash']
  vivify_2480:
    set $P5246, $P5245["args"]
    unless_null $P5246, vivify_2481
    $P5246 = root_new ['parrot';'ResizablePMCArray']
  vivify_2481:
    set $P5247, $P5246[0]
    unless_null $P5247, vivify_2482
    new $P5247, "Undef"
  vivify_2482:
    $P5248 = $P5247."ast"()
    set $P5241, $P5248
  if_5242_end:
    store_lex "$past", $P5241
.annotate 'line', 1851
    find_lex $P5253, "$/"
    unless_null $P5253, vivify_2483
    $P5253 = root_new ['parrot';'Hash']
  vivify_2483:
    set $P5254, $P5253["quote"]
    unless_null $P5254, vivify_2484
    new $P5254, "Undef"
  vivify_2484:
    if $P5254, if_5252
.annotate 'line', 1855
    find_lex $P5261, "$/"
    unless_null $P5261, vivify_2485
    $P5261 = root_new ['parrot';'Hash']
  vivify_2485:
    set $P5262, $P5261["longname"]
    unless_null $P5262, vivify_2486
    new $P5262, "Undef"
  vivify_2486:
    set $S5263, $P5262
    iseq $I5264, $S5263, "HOW"
    if $I5264, if_5260
.annotate 'line', 1858
    find_lex $P5267, "$/"
    unless_null $P5267, vivify_2487
    $P5267 = root_new ['parrot';'Hash']
  vivify_2487:
    set $P5268, $P5267["longname"]
    unless_null $P5268, vivify_2488
    new $P5268, "Undef"
  vivify_2488:
    set $S5269, $P5268
    iseq $I5270, $S5269, "WHAT"
    if $I5270, if_5266
.annotate 'line', 1861
    find_lex $P5273, "$/"
    unless_null $P5273, vivify_2489
    $P5273 = root_new ['parrot';'Hash']
  vivify_2489:
    set $P5274, $P5273["longname"]
    unless_null $P5274, vivify_2490
    new $P5274, "Undef"
  vivify_2490:
    set $S5275, $P5274
    iseq $I5276, $S5275, "WHO"
    if $I5276, if_5272
.annotate 'line', 1865
    find_lex $P5278, "$past"
    unless_null $P5278, vivify_2491
    new $P5278, "Undef"
  vivify_2491:
    find_lex $P5279, "$/"
    unless_null $P5279, vivify_2492
    $P5279 = root_new ['parrot';'Hash']
  vivify_2492:
    set $P5280, $P5279["longname"]
    unless_null $P5280, vivify_2493
    new $P5280, "Undef"
  vivify_2493:
    set $S5281, $P5280
    $P5278."name"($S5281)
.annotate 'line', 1866
    find_lex $P5282, "$past"
    unless_null $P5282, vivify_2494
    new $P5282, "Undef"
  vivify_2494:
    $P5282."pasttype"("callmethod")
.annotate 'line', 1864
    goto if_5272_end
  if_5272:
.annotate 'line', 1862
    find_lex $P5277, "$past"
    unless_null $P5277, vivify_2495
    new $P5277, "Undef"
  vivify_2495:
    $P5277."pirop"("get_who PP")
  if_5272_end:
.annotate 'line', 1861
    goto if_5266_end
  if_5266:
.annotate 'line', 1859
    find_lex $P5271, "$past"
    unless_null $P5271, vivify_2496
    new $P5271, "Undef"
  vivify_2496:
    $P5271."pirop"("get_what PP")
  if_5266_end:
.annotate 'line', 1858
    goto if_5260_end
  if_5260:
.annotate 'line', 1856
    find_lex $P5265, "$past"
    unless_null $P5265, vivify_2497
    new $P5265, "Undef"
  vivify_2497:
    $P5265."pirop"("get_how PP")
  if_5260_end:
.annotate 'line', 1855
    goto if_5252_end
  if_5252:
.annotate 'line', 1852
    find_lex $P5255, "$past"
    unless_null $P5255, vivify_2498
    new $P5255, "Undef"
  vivify_2498:
    find_lex $P5256, "$/"
    unless_null $P5256, vivify_2499
    $P5256 = root_new ['parrot';'Hash']
  vivify_2499:
    set $P5257, $P5256["quote"]
    unless_null $P5257, vivify_2500
    new $P5257, "Undef"
  vivify_2500:
    $P5258 = $P5257."ast"()
    $P5255."name"($P5258)
.annotate 'line', 1853
    find_lex $P5259, "$past"
    unless_null $P5259, vivify_2501
    new $P5259, "Undef"
  vivify_2501:
    $P5259."pasttype"("callmethod")
  if_5252_end:
.annotate 'line', 1868
    find_lex $P5283, "$/"
    find_lex $P5284, "$past"
    unless_null $P5284, vivify_2502
    new $P5284, "Undef"
  vivify_2502:
    $P5285 = $P5283."!make"($P5284)
.annotate 'line', 1849
    .return ($P5285)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("523_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5287
    .param pmc param_5288
.annotate 'line', 1873
    .lex "self", param_5287
    .lex "$/", param_5288
.annotate 'line', 1874
    find_lex $P5289, "$/"
    get_hll_global $P5290, ["PAST"], "Var"
    $P5291 = $P5290."new"("self" :named("name"))
    $P5292 = $P5289."!make"($P5291)
.annotate 'line', 1873
    .return ($P5292)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("524_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5294
    .param pmc param_5295
.annotate 'line', 1877
    .lex "self", param_5294
    .lex "$/", param_5295
.annotate 'line', 1878
    new $P5296, "Undef"
    .lex "$past", $P5296
    find_lex $P5297, "$/"
    unless_null $P5297, vivify_2503
    $P5297 = root_new ['parrot';'Hash']
  vivify_2503:
    set $P5298, $P5297["args"]
    unless_null $P5298, vivify_2504
    new $P5298, "Undef"
  vivify_2504:
    $P5299 = $P5298."ast"()
    store_lex "$past", $P5299
.annotate 'line', 1879
    find_lex $P5300, "$past"
    unless_null $P5300, vivify_2505
    new $P5300, "Undef"
  vivify_2505:
    find_lex $P5301, "$/"
    unless_null $P5301, vivify_2506
    $P5301 = root_new ['parrot';'Hash']
  vivify_2506:
    set $P5302, $P5301["deflongname"]
    unless_null $P5302, vivify_2507
    new $P5302, "Undef"
  vivify_2507:
    set $S5303, $P5302
    $P5300."name"($S5303)
.annotate 'line', 1880
    find_lex $P5304, "$/"
    find_lex $P5305, "$past"
    unless_null $P5305, vivify_2508
    new $P5305, "Undef"
  vivify_2508:
    $P5306 = $P5304."!make"($P5305)
.annotate 'line', 1877
    .return ($P5306)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("525_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5308
    .param pmc param_5309
.annotate 'line', 1883
    .const 'Sub' $P5324 = "526_1303603603.711" 
    capture_lex $P5324
    .lex "self", param_5308
    .lex "$/", param_5309
.annotate 'line', 1885
    new $P5310, "Undef"
    .lex "$var", $P5310
.annotate 'line', 1899
    new $P5311, "Undef"
    .lex "$past", $P5311
.annotate 'line', 1883
    find_lex $P5312, "$var"
    unless_null $P5312, vivify_2509
    new $P5312, "Undef"
  vivify_2509:
.annotate 'line', 1886
    find_lex $P5314, "$/"
    unless_null $P5314, vivify_2510
    $P5314 = root_new ['parrot';'Hash']
  vivify_2510:
    set $P5315, $P5314["name"]
    unless_null $P5315, vivify_2511
    new $P5315, "Undef"
  vivify_2511:
    set $S5316, $P5315
    $P5317 = "is_lexical"($S5316)
    if $P5317, if_5313
.annotate 'line', 1889
    .const 'Sub' $P5324 = "526_1303603603.711" 
    capture_lex $P5324
    $P5324()
    goto if_5313_end
  if_5313:
.annotate 'line', 1887
    get_hll_global $P5318, ["PAST"], "Var"
    find_lex $P5319, "$/"
    unless_null $P5319, vivify_2522
    $P5319 = root_new ['parrot';'Hash']
  vivify_2522:
    set $P5320, $P5319["name"]
    unless_null $P5320, vivify_2523
    new $P5320, "Undef"
  vivify_2523:
    set $S5321, $P5320
    $P5322 = $P5318."new"($S5321 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5322
  if_5313_end:
.annotate 'line', 1899
    find_lex $P5347, "$var"
    unless_null $P5347, vivify_2524
    new $P5347, "Undef"
  vivify_2524:
    store_lex "$past", $P5347
.annotate 'line', 1900
    find_lex $P5349, "$/"
    unless_null $P5349, vivify_2525
    $P5349 = root_new ['parrot';'Hash']
  vivify_2525:
    set $P5350, $P5349["args"]
    unless_null $P5350, vivify_2526
    new $P5350, "Undef"
  vivify_2526:
    unless $P5350, if_5348_end
.annotate 'line', 1901
    find_lex $P5351, "$/"
    unless_null $P5351, vivify_2527
    $P5351 = root_new ['parrot';'Hash']
  vivify_2527:
    set $P5352, $P5351["args"]
    unless_null $P5352, vivify_2528
    $P5352 = root_new ['parrot';'ResizablePMCArray']
  vivify_2528:
    set $P5353, $P5352[0]
    unless_null $P5353, vivify_2529
    new $P5353, "Undef"
  vivify_2529:
    $P5354 = $P5353."ast"()
    store_lex "$past", $P5354
.annotate 'line', 1902
    find_lex $P5355, "$past"
    unless_null $P5355, vivify_2530
    new $P5355, "Undef"
  vivify_2530:
    find_lex $P5356, "$var"
    unless_null $P5356, vivify_2531
    new $P5356, "Undef"
  vivify_2531:
    $P5355."unshift"($P5356)
  if_5348_end:
.annotate 'line', 1904
    find_lex $P5357, "$/"
    find_lex $P5358, "$past"
    unless_null $P5358, vivify_2532
    new $P5358, "Undef"
  vivify_2532:
    $P5359 = $P5357."!make"($P5358)
.annotate 'line', 1883
    .return ($P5359)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5323"  :anon :subid("526_1303603603.711") :outer("525_1303603603.711")
.annotate 'line', 1890
    $P5325 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5325
.annotate 'line', 1891
    new $P5326, "Undef"
    .lex "$name", $P5326
.annotate 'line', 1890
    find_lex $P5327, "$/"
    unless_null $P5327, vivify_2512
    $P5327 = root_new ['parrot';'Hash']
  vivify_2512:
    set $P5328, $P5327["name"]
    unless_null $P5328, vivify_2513
    $P5328 = root_new ['parrot';'Hash']
  vivify_2513:
    set $P5329, $P5328["identifier"]
    unless_null $P5329, vivify_2514
    new $P5329, "Undef"
  vivify_2514:
    clone $P5330, $P5329
    store_lex "@ns", $P5330
.annotate 'line', 1891
    find_lex $P5331, "@ns"
    unless_null $P5331, vivify_2515
    $P5331 = root_new ['parrot';'ResizablePMCArray']
  vivify_2515:
    $P5332 = $P5331."pop"()
    store_lex "$name", $P5332
.annotate 'line', 1892
    find_lex $P5336, "@ns"
    unless_null $P5336, vivify_2516
    $P5336 = root_new ['parrot';'ResizablePMCArray']
  vivify_2516:
    if $P5336, if_5335
    set $P5334, $P5336
    goto if_5335_end
  if_5335:
    find_lex $P5337, "@ns"
    unless_null $P5337, vivify_2517
    $P5337 = root_new ['parrot';'ResizablePMCArray']
  vivify_2517:
    set $P5338, $P5337[0]
    unless_null $P5338, vivify_2518
    new $P5338, "Undef"
  vivify_2518:
    set $S5339, $P5338
    iseq $I5340, $S5339, "GLOBAL"
    new $P5334, 'Integer'
    set $P5334, $I5340
  if_5335_end:
    unless $P5334, if_5333_end
    find_lex $P5341, "@ns"
    unless_null $P5341, vivify_2519
    $P5341 = root_new ['parrot';'ResizablePMCArray']
  vivify_2519:
    $P5341."shift"()
  if_5333_end:
.annotate 'line', 1893
    get_hll_global $P5342, ["PAST"], "Var"
    find_lex $P5343, "$name"
    unless_null $P5343, vivify_2520
    new $P5343, "Undef"
  vivify_2520:
    set $S5344, $P5343
    find_lex $P5345, "@ns"
    unless_null $P5345, vivify_2521
    $P5345 = root_new ['parrot';'ResizablePMCArray']
  vivify_2521:
    $P5346 = $P5342."new"($S5344 :named("name"), $P5345 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P5346
.annotate 'line', 1889
    .return ($P5346)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("527_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5361
    .param pmc param_5362
.annotate 'line', 1907
    .lex "self", param_5361
    .lex "$/", param_5362
.annotate 'line', 1908
    new $P5363, "Undef"
    .lex "$past", $P5363
.annotate 'line', 1909
    new $P5364, "Undef"
    .lex "$pirop", $P5364
.annotate 'line', 1908
    find_lex $P5367, "$/"
    unless_null $P5367, vivify_2533
    $P5367 = root_new ['parrot';'Hash']
  vivify_2533:
    set $P5368, $P5367["args"]
    unless_null $P5368, vivify_2534
    new $P5368, "Undef"
  vivify_2534:
    if $P5368, if_5366
    get_hll_global $P5373, ["PAST"], "Op"
    find_lex $P5374, "$/"
    unless_null $P5374, vivify_2535
    new $P5374, "Undef"
  vivify_2535:
    $P5375 = $P5373."new"($P5374 :named("node"))
    set $P5365, $P5375
    goto if_5366_end
  if_5366:
    find_lex $P5369, "$/"
    unless_null $P5369, vivify_2536
    $P5369 = root_new ['parrot';'Hash']
  vivify_2536:
    set $P5370, $P5369["args"]
    unless_null $P5370, vivify_2537
    $P5370 = root_new ['parrot';'ResizablePMCArray']
  vivify_2537:
    set $P5371, $P5370[0]
    unless_null $P5371, vivify_2538
    new $P5371, "Undef"
  vivify_2538:
    $P5372 = $P5371."ast"()
    set $P5365, $P5372
  if_5366_end:
    store_lex "$past", $P5365
.annotate 'line', 1909
    find_lex $P5376, "$/"
    unless_null $P5376, vivify_2539
    $P5376 = root_new ['parrot';'Hash']
  vivify_2539:
    set $P5377, $P5376["op"]
    unless_null $P5377, vivify_2540
    new $P5377, "Undef"
  vivify_2540:
    set $S5378, $P5377
    new $P5379, 'String'
    set $P5379, $S5378
    store_lex "$pirop", $P5379
.annotate 'line', 1910
    find_lex $P5380, "$pirop"
    unless_null $P5380, vivify_2541
    new $P5380, "Undef"
  vivify_2541:
    set $S5381, $P5380
    split $P5382, "__", $S5381
    join $S5383, " ", $P5382
    new $P5384, 'String'
    set $P5384, $S5383
    store_lex "$pirop", $P5384
.annotate 'line', 1911
    find_lex $P5385, "$past"
    unless_null $P5385, vivify_2542
    new $P5385, "Undef"
  vivify_2542:
    find_lex $P5386, "$pirop"
    unless_null $P5386, vivify_2543
    new $P5386, "Undef"
  vivify_2543:
    $P5385."pirop"($P5386)
.annotate 'line', 1912
    find_lex $P5387, "$past"
    unless_null $P5387, vivify_2544
    new $P5387, "Undef"
  vivify_2544:
    $P5387."pasttype"("pirop")
.annotate 'line', 1913
    find_lex $P5388, "$/"
    find_lex $P5389, "$past"
    unless_null $P5389, vivify_2545
    new $P5389, "Undef"
  vivify_2545:
    $P5390 = $P5388."!make"($P5389)
.annotate 'line', 1907
    .return ($P5390)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("528_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5392
    .param pmc param_5393
.annotate 'line', 1916
    .lex "self", param_5392
    .lex "$/", param_5393
.annotate 'line', 1917
    find_lex $P5394, "$/"
    get_hll_global $P5395, ["PAST"], "Op"
    $P5396 = $P5395."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5397 = $P5394."!make"($P5396)
.annotate 'line', 1916
    .return ($P5397)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("529_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5399
    .param pmc param_5400
.annotate 'line', 1922
    .lex "self", param_5399
    .lex "$/", param_5400
    find_lex $P5401, "$/"
    find_lex $P5402, "$/"
    unless_null $P5402, vivify_2546
    $P5402 = root_new ['parrot';'Hash']
  vivify_2546:
    set $P5403, $P5402["arglist"]
    unless_null $P5403, vivify_2547
    new $P5403, "Undef"
  vivify_2547:
    $P5404 = $P5403."ast"()
    $P5405 = $P5401."!make"($P5404)
    .return ($P5405)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("530_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5407
    .param pmc param_5408
.annotate 'line', 1924
    .const 'Sub' $P5419 = "531_1303603603.711" 
    capture_lex $P5419
    .lex "self", param_5407
    .lex "$/", param_5408
.annotate 'line', 1925
    new $P5409, "Undef"
    .lex "$past", $P5409
.annotate 'line', 1933
    new $P5410, "Undef"
    .lex "$i", $P5410
.annotate 'line', 1934
    new $P5411, "Undef"
    .lex "$n", $P5411
.annotate 'line', 1925
    get_hll_global $P5412, ["PAST"], "Op"
    find_lex $P5413, "$/"
    unless_null $P5413, vivify_2548
    new $P5413, "Undef"
  vivify_2548:
    $P5414 = $P5412."new"("call" :named("pasttype"), $P5413 :named("node"))
    store_lex "$past", $P5414
.annotate 'line', 1926
    find_lex $P5416, "$/"
    unless_null $P5416, vivify_2549
    $P5416 = root_new ['parrot';'Hash']
  vivify_2549:
    set $P5417, $P5416["EXPR"]
    unless_null $P5417, vivify_2550
    new $P5417, "Undef"
  vivify_2550:
    unless $P5417, if_5415_end
    .const 'Sub' $P5419 = "531_1303603603.711" 
    capture_lex $P5419
    $P5419()
  if_5415_end:
.annotate 'line', 1933
    new $P5451, "Integer"
    assign $P5451, 0
    store_lex "$i", $P5451
.annotate 'line', 1934
    find_lex $P5452, "$past"
    unless_null $P5452, vivify_2561
    new $P5452, "Undef"
  vivify_2561:
    $P5453 = $P5452."list"()
    set $N5454, $P5453
    new $P5455, 'Float'
    set $P5455, $N5454
    store_lex "$n", $P5455
.annotate 'line', 1935
    new $P5503, 'ExceptionHandler'
    set_label $P5503, loop5502_handler
    $P5503."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5503
  loop5502_test:
    find_lex $P5456, "$i"
    unless_null $P5456, vivify_2562
    new $P5456, "Undef"
  vivify_2562:
    set $N5457, $P5456
    find_lex $P5458, "$n"
    unless_null $P5458, vivify_2563
    new $P5458, "Undef"
  vivify_2563:
    set $N5459, $P5458
    islt $I5460, $N5457, $N5459
    unless $I5460, loop5502_done
  loop5502_redo:
.annotate 'line', 1936
    find_lex $P5462, "$i"
    unless_null $P5462, vivify_2564
    new $P5462, "Undef"
  vivify_2564:
    set $I5463, $P5462
    find_lex $P5464, "$past"
    unless_null $P5464, vivify_2565
    $P5464 = root_new ['parrot';'ResizablePMCArray']
  vivify_2565:
    set $P5465, $P5464[$I5463]
    unless_null $P5465, vivify_2566
    new $P5465, "Undef"
  vivify_2566:
    $S5466 = $P5465."name"()
    iseq $I5467, $S5466, "&prefix:<|>"
    unless $I5467, if_5461_end
.annotate 'line', 1937
    find_lex $P5468, "$i"
    unless_null $P5468, vivify_2567
    new $P5468, "Undef"
  vivify_2567:
    set $I5469, $P5468
    find_lex $P5470, "$past"
    unless_null $P5470, vivify_2568
    $P5470 = root_new ['parrot';'ResizablePMCArray']
  vivify_2568:
    set $P5471, $P5470[$I5469]
    unless_null $P5471, vivify_2569
    $P5471 = root_new ['parrot';'ResizablePMCArray']
  vivify_2569:
    set $P5472, $P5471[0]
    unless_null $P5472, vivify_2570
    new $P5472, "Undef"
  vivify_2570:
    find_lex $P5473, "$i"
    unless_null $P5473, vivify_2571
    new $P5473, "Undef"
  vivify_2571:
    set $I5474, $P5473
    find_lex $P5475, "$past"
    unless_null $P5475, vivify_2572
    $P5475 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5475
  vivify_2572:
    set $P5475[$I5474], $P5472
.annotate 'line', 1938
    find_lex $P5476, "$i"
    unless_null $P5476, vivify_2573
    new $P5476, "Undef"
  vivify_2573:
    set $I5477, $P5476
    find_lex $P5478, "$past"
    unless_null $P5478, vivify_2574
    $P5478 = root_new ['parrot';'ResizablePMCArray']
  vivify_2574:
    set $P5479, $P5478[$I5477]
    unless_null $P5479, vivify_2575
    new $P5479, "Undef"
  vivify_2575:
    $P5479."flat"(1)
.annotate 'line', 1939
    find_lex $P5483, "$i"
    unless_null $P5483, vivify_2576
    new $P5483, "Undef"
  vivify_2576:
    set $I5484, $P5483
    find_lex $P5485, "$past"
    unless_null $P5485, vivify_2577
    $P5485 = root_new ['parrot';'ResizablePMCArray']
  vivify_2577:
    set $P5486, $P5485[$I5484]
    unless_null $P5486, vivify_2578
    new $P5486, "Undef"
  vivify_2578:
    get_hll_global $P5487, ["PAST"], "Val"
    $P5488 = $P5486."isa"($P5487)
    if $P5488, if_5482
    set $P5481, $P5488
    goto if_5482_end
  if_5482:
.annotate 'line', 1940
    find_lex $P5489, "$i"
    unless_null $P5489, vivify_2579
    new $P5489, "Undef"
  vivify_2579:
    set $I5490, $P5489
    find_lex $P5491, "$past"
    unless_null $P5491, vivify_2580
    $P5491 = root_new ['parrot';'ResizablePMCArray']
  vivify_2580:
    set $P5492, $P5491[$I5490]
    unless_null $P5492, vivify_2581
    new $P5492, "Undef"
  vivify_2581:
    $S5493 = $P5492."name"()
    substr $S5494, $S5493, 0, 1
    iseq $I5495, $S5494, "%"
    new $P5481, 'Integer'
    set $P5481, $I5495
  if_5482_end:
    unless $P5481, if_5480_end
.annotate 'line', 1941
    find_lex $P5496, "$i"
    unless_null $P5496, vivify_2582
    new $P5496, "Undef"
  vivify_2582:
    set $I5497, $P5496
    find_lex $P5498, "$past"
    unless_null $P5498, vivify_2583
    $P5498 = root_new ['parrot';'ResizablePMCArray']
  vivify_2583:
    set $P5499, $P5498[$I5497]
    unless_null $P5499, vivify_2584
    new $P5499, "Undef"
  vivify_2584:
    $P5499."named"(1)
  if_5480_end:
  if_5461_end:
.annotate 'line', 1936
    find_lex $P5500, "$i"
    unless_null $P5500, vivify_2585
    new $P5500, "Undef"
  vivify_2585:
    clone $P5501, $P5500
    inc $P5500
  loop5502_next:
.annotate 'line', 1935
    goto loop5502_test
  loop5502_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5504, exception, 'type'
    eq $P5504, .CONTROL_LOOP_NEXT, loop5502_next
    eq $P5504, .CONTROL_LOOP_REDO, loop5502_redo
  loop5502_done:
    pop_eh 
.annotate 'line', 1946
    find_lex $P5505, "$/"
    find_lex $P5506, "$past"
    unless_null $P5506, vivify_2586
    new $P5506, "Undef"
  vivify_2586:
    $P5507 = $P5505."!make"($P5506)
.annotate 'line', 1924
    .return ($P5507)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5418"  :anon :subid("531_1303603603.711") :outer("530_1303603603.711")
.annotate 'line', 1926
    .const 'Sub' $P5440 = "532_1303603603.711" 
    capture_lex $P5440
.annotate 'line', 1927
    new $P5420, "Undef"
    .lex "$expr", $P5420
    find_lex $P5421, "$/"
    unless_null $P5421, vivify_2551
    $P5421 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P5422, $P5421["EXPR"]
    unless_null $P5422, vivify_2552
    new $P5422, "Undef"
  vivify_2552:
    $P5423 = $P5422."ast"()
    store_lex "$expr", $P5423
.annotate 'line', 1928
    find_lex $P5428, "$expr"
    unless_null $P5428, vivify_2553
    new $P5428, "Undef"
  vivify_2553:
    $S5429 = $P5428."name"()
    iseq $I5430, $S5429, "&infix:<,>"
    if $I5430, if_5427
    new $P5426, 'Integer'
    set $P5426, $I5430
    goto if_5427_end
  if_5427:
    find_lex $P5431, "$expr"
    unless_null $P5431, vivify_2554
    new $P5431, "Undef"
  vivify_2554:
    $P5432 = $P5431."named"()
    isfalse $I5433, $P5432
    new $P5426, 'Integer'
    set $P5426, $I5433
  if_5427_end:
    if $P5426, if_5425
.annotate 'line', 1931
    find_lex $P5448, "$past"
    unless_null $P5448, vivify_2555
    new $P5448, "Undef"
  vivify_2555:
    find_lex $P5449, "$expr"
    unless_null $P5449, vivify_2556
    new $P5449, "Undef"
  vivify_2556:
    $P5450 = $P5448."push"($P5449)
    set $P5424, $P5450
.annotate 'line', 1928
    goto if_5425_end
  if_5425:
.annotate 'line', 1929
    find_lex $P5435, "$expr"
    unless_null $P5435, vivify_2557
    new $P5435, "Undef"
  vivify_2557:
    $P5436 = $P5435."list"()
    defined $I5437, $P5436
    unless $I5437, for_undef_2558
    iter $P5434, $P5436
    new $P5446, 'ExceptionHandler'
    set_label $P5446, loop5445_handler
    $P5446."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5446
  loop5445_test:
    unless $P5434, loop5445_done
    shift $P5438, $P5434
  loop5445_redo:
    .const 'Sub' $P5440 = "532_1303603603.711" 
    capture_lex $P5440
    $P5440($P5438)
  loop5445_next:
    goto loop5445_test
  loop5445_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5447, exception, 'type'
    eq $P5447, .CONTROL_LOOP_NEXT, loop5445_next
    eq $P5447, .CONTROL_LOOP_REDO, loop5445_redo
  loop5445_done:
    pop_eh 
  for_undef_2558:
.annotate 'line', 1928
    set $P5424, $P5434
  if_5425_end:
.annotate 'line', 1926
    .return ($P5424)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5439"  :anon :subid("532_1303603603.711") :outer("531_1303603603.711")
    .param pmc param_5441
.annotate 'line', 1929
    .lex "$_", param_5441
    find_lex $P5442, "$past"
    unless_null $P5442, vivify_2559
    new $P5442, "Undef"
  vivify_2559:
    find_lex $P5443, "$_"
    unless_null $P5443, vivify_2560
    new $P5443, "Undef"
  vivify_2560:
    $P5444 = $P5442."push"($P5443)
    .return ($P5444)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("533_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5509
    .param pmc param_5510
.annotate 'line', 1949
    .lex "self", param_5509
    .lex "$/", param_5510
    find_lex $P5511, "$/"
    find_lex $P5512, "$/"
    unless_null $P5512, vivify_2587
    $P5512 = root_new ['parrot';'Hash']
  vivify_2587:
    set $P5513, $P5512["multi_declarator"]
    unless_null $P5513, vivify_2588
    new $P5513, "Undef"
  vivify_2588:
    $P5514 = $P5513."ast"()
    $P5515 = $P5511."!make"($P5514)
    .return ($P5515)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("534_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5517
    .param pmc param_5518
.annotate 'line', 1951
    .lex "self", param_5517
    .lex "$/", param_5518
    find_lex $P5519, "$/"
    find_lex $P5520, "$/"
    unless_null $P5520, vivify_2589
    $P5520 = root_new ['parrot';'Hash']
  vivify_2589:
    set $P5521, $P5520["value"]
    unless_null $P5521, vivify_2590
    new $P5521, "Undef"
  vivify_2590:
    $P5522 = $P5521."ast"()
    $P5523 = $P5519."!make"($P5522)
    .return ($P5523)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("535_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5525
    .param pmc param_5526
.annotate 'line', 1953
    .lex "self", param_5525
    .lex "$/", param_5526
.annotate 'line', 1954
    find_lex $P5527, "$/"
.annotate 'line', 1955
    find_lex $P5530, "$/"
    unless_null $P5530, vivify_2591
    $P5530 = root_new ['parrot';'Hash']
  vivify_2591:
    set $P5531, $P5530["EXPR"]
    unless_null $P5531, vivify_2592
    new $P5531, "Undef"
  vivify_2592:
    if $P5531, if_5529
.annotate 'line', 1956
    get_hll_global $P5536, ["PAST"], "Op"
    find_lex $P5537, "$/"
    unless_null $P5537, vivify_2593
    new $P5537, "Undef"
  vivify_2593:
    $P5538 = $P5536."new"("list" :named("pasttype"), $P5537 :named("node"))
    set $P5528, $P5538
.annotate 'line', 1955
    goto if_5529_end
  if_5529:
    find_lex $P5532, "$/"
    unless_null $P5532, vivify_2594
    $P5532 = root_new ['parrot';'Hash']
  vivify_2594:
    set $P5533, $P5532["EXPR"]
    unless_null $P5533, vivify_2595
    $P5533 = root_new ['parrot';'ResizablePMCArray']
  vivify_2595:
    set $P5534, $P5533[0]
    unless_null $P5534, vivify_2596
    new $P5534, "Undef"
  vivify_2596:
    $P5535 = $P5534."ast"()
    set $P5528, $P5535
  if_5529_end:
    $P5539 = $P5527."!make"($P5528)
.annotate 'line', 1953
    .return ($P5539)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("536_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5541
    .param pmc param_5542
.annotate 'line', 1959
    .lex "self", param_5541
    .lex "$/", param_5542
.annotate 'line', 1960
    new $P5543, "Undef"
    .lex "$past", $P5543
.annotate 'line', 1959
    find_lex $P5544, "$past"
    unless_null $P5544, vivify_2597
    new $P5544, "Undef"
  vivify_2597:
.annotate 'line', 1961
    find_lex $P5546, "$/"
    unless_null $P5546, vivify_2598
    $P5546 = root_new ['parrot';'Hash']
  vivify_2598:
    set $P5547, $P5546["EXPR"]
    unless_null $P5547, vivify_2599
    new $P5547, "Undef"
  vivify_2599:
    if $P5547, if_5545
.annotate 'line', 1968
    get_hll_global $P5559, ["PAST"], "Op"
    $P5560 = $P5559."new"("list" :named("pasttype"))
    store_lex "$past", $P5560
.annotate 'line', 1967
    goto if_5545_end
  if_5545:
.annotate 'line', 1962
    find_lex $P5548, "$/"
    unless_null $P5548, vivify_2600
    $P5548 = root_new ['parrot';'Hash']
  vivify_2600:
    set $P5549, $P5548["EXPR"]
    unless_null $P5549, vivify_2601
    $P5549 = root_new ['parrot';'ResizablePMCArray']
  vivify_2601:
    set $P5550, $P5549[0]
    unless_null $P5550, vivify_2602
    new $P5550, "Undef"
  vivify_2602:
    $P5551 = $P5550."ast"()
    store_lex "$past", $P5551
.annotate 'line', 1963
    find_lex $P5553, "$past"
    unless_null $P5553, vivify_2603
    new $P5553, "Undef"
  vivify_2603:
    $S5554 = $P5553."name"()
    isne $I5555, $S5554, "&infix:<,>"
    unless $I5555, if_5552_end
.annotate 'line', 1964
    get_hll_global $P5556, ["PAST"], "Op"
    find_lex $P5557, "$past"
    unless_null $P5557, vivify_2604
    new $P5557, "Undef"
  vivify_2604:
    $P5558 = $P5556."new"($P5557, "list" :named("pasttype"))
    store_lex "$past", $P5558
  if_5552_end:
  if_5545_end:
.annotate 'line', 1970
    find_lex $P5561, "$past"
    unless_null $P5561, vivify_2605
    new $P5561, "Undef"
  vivify_2605:
    $P5561."name"("&circumfix:<[ ]>")
.annotate 'line', 1971
    find_lex $P5562, "$/"
    find_lex $P5563, "$past"
    unless_null $P5563, vivify_2606
    new $P5563, "Undef"
  vivify_2606:
    $P5564 = $P5562."!make"($P5563)
.annotate 'line', 1959
    .return ($P5564)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("537_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5566
    .param pmc param_5567
.annotate 'line', 1974
    .lex "self", param_5566
    .lex "$/", param_5567
    find_lex $P5568, "$/"
    find_lex $P5569, "$/"
    unless_null $P5569, vivify_2607
    $P5569 = root_new ['parrot';'Hash']
  vivify_2607:
    set $P5570, $P5569["quote_EXPR"]
    unless_null $P5570, vivify_2608
    new $P5570, "Undef"
  vivify_2608:
    $P5571 = $P5570."ast"()
    $P5572 = $P5568."!make"($P5571)
    .return ($P5572)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("538_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5574
    .param pmc param_5575
.annotate 'line', 1975
    .lex "self", param_5574
    .lex "$/", param_5575
    find_lex $P5576, "$/"
    find_lex $P5577, "$/"
    unless_null $P5577, vivify_2609
    $P5577 = root_new ['parrot';'Hash']
  vivify_2609:
    set $P5578, $P5577["quote_EXPR"]
    unless_null $P5578, vivify_2610
    new $P5578, "Undef"
  vivify_2610:
    $P5579 = $P5578."ast"()
    $P5580 = $P5576."!make"($P5579)
    .return ($P5580)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("539_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5582
    .param pmc param_5583
.annotate 'line', 1977
    .const 'Sub' $P5594 = "540_1303603603.711" 
    capture_lex $P5594
    .lex "self", param_5582
    .lex "$/", param_5583
.annotate 'line', 1978
    find_lex $P5586, "$/"
    unless_null $P5586, vivify_2611
    $P5586 = root_new ['parrot';'Hash']
  vivify_2611:
    set $P5587, $P5586["pblock"]
    unless_null $P5587, vivify_2612
    $P5587 = root_new ['parrot';'Hash']
  vivify_2612:
    set $P5588, $P5587["blockoid"]
    unless_null $P5588, vivify_2613
    $P5588 = root_new ['parrot';'Hash']
  vivify_2613:
    set $P5589, $P5588["statementlist"]
    unless_null $P5589, vivify_2614
    $P5589 = root_new ['parrot';'Hash']
  vivify_2614:
    set $P5590, $P5589["statement"]
    unless_null $P5590, vivify_2615
    new $P5590, "Undef"
  vivify_2615:
    set $N5591, $P5590
    isgt $I5592, $N5591, 0.0
    if $I5592, if_5585
.annotate 'line', 1983
    find_lex $P5607, "$/"
    unless_null $P5607, vivify_2616
    $P5607 = root_new ['parrot';'Hash']
  vivify_2616:
    set $P5608, $P5607["pblock"]
    unless_null $P5608, vivify_2617
    $P5608 = root_new ['parrot';'Hash']
  vivify_2617:
    set $P5609, $P5608["blockoid"]
    unless_null $P5609, vivify_2618
    $P5609 = root_new ['parrot';'Hash']
  vivify_2618:
    set $P5610, $P5609["you_are_here"]
    unless_null $P5610, vivify_2619
    new $P5610, "Undef"
  vivify_2619:
    if $P5610, if_5606
.annotate 'line', 1987
    find_lex $P5616, "$/"
    $P5617 = "vivitype"("%")
    $P5618 = $P5616."!make"($P5617)
.annotate 'line', 1986
    set $P5605, $P5618
.annotate 'line', 1983
    goto if_5606_end
  if_5606:
.annotate 'line', 1984
    find_lex $P5611, "$/"
    find_lex $P5612, "$/"
    unless_null $P5612, vivify_2620
    $P5612 = root_new ['parrot';'Hash']
  vivify_2620:
    set $P5613, $P5612["pblock"]
    unless_null $P5613, vivify_2621
    new $P5613, "Undef"
  vivify_2621:
    $P5614 = $P5613."ast"()
    $P5615 = $P5611."!make"($P5614)
.annotate 'line', 1983
    set $P5605, $P5615
  if_5606_end:
    set $P5584, $P5605
.annotate 'line', 1978
    goto if_5585_end
  if_5585:
    .const 'Sub' $P5594 = "540_1303603603.711" 
    capture_lex $P5594
    $P5604 = $P5594()
    set $P5584, $P5604
  if_5585_end:
.annotate 'line', 1977
    .return ($P5584)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5593"  :anon :subid("540_1303603603.711") :outer("539_1303603603.711")
.annotate 'line', 1979
    new $P5595, "Undef"
    .lex "$past", $P5595
    find_lex $P5596, "$/"
    unless_null $P5596, vivify_2622
    $P5596 = root_new ['parrot';'Hash']
  vivify_2622:
    set $P5597, $P5596["pblock"]
    unless_null $P5597, vivify_2623
    new $P5597, "Undef"
  vivify_2623:
    $P5598 = $P5597."ast"()
    store_lex "$past", $P5598
.annotate 'line', 1980
    new $P5599, "Integer"
    assign $P5599, 1
    find_lex $P5600, "$past"
    unless_null $P5600, vivify_2624
    $P5600 = root_new ['parrot';'Hash']
    store_lex "$past", $P5600
  vivify_2624:
    set $P5600["bareblock"], $P5599
.annotate 'line', 1981
    find_dynamic_lex $P5601, "$/"
    find_lex $P5602, "$past"
    unless_null $P5602, vivify_2625
    new $P5602, "Undef"
  vivify_2625:
    $P5603 = $P5601."!make"($P5602)
.annotate 'line', 1978
    .return ($P5603)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("541_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5620
    .param pmc param_5621
.annotate 'line', 1991
    .lex "self", param_5620
    .lex "$/", param_5621
.annotate 'line', 1992
    new $P5622, "Undef"
    .lex "$name", $P5622
    find_lex $P5625, "$/"
    unless_null $P5625, vivify_2626
    $P5625 = root_new ['parrot';'Hash']
  vivify_2626:
    set $P5626, $P5625["sigil"]
    unless_null $P5626, vivify_2627
    new $P5626, "Undef"
  vivify_2627:
    set $S5627, $P5626
    iseq $I5628, $S5627, "@"
    if $I5628, if_5624
.annotate 'line', 1993
    find_lex $P5632, "$/"
    unless_null $P5632, vivify_2628
    $P5632 = root_new ['parrot';'Hash']
  vivify_2628:
    set $P5633, $P5632["sigil"]
    unless_null $P5633, vivify_2629
    new $P5633, "Undef"
  vivify_2629:
    set $S5634, $P5633
    iseq $I5635, $S5634, "%"
    if $I5635, if_5631
    new $P5637, "String"
    assign $P5637, "item"
    set $P5630, $P5637
    goto if_5631_end
  if_5631:
    new $P5636, "String"
    assign $P5636, "hash"
    set $P5630, $P5636
  if_5631_end:
    set $P5623, $P5630
.annotate 'line', 1992
    goto if_5624_end
  if_5624:
    new $P5629, "String"
    assign $P5629, "list"
    set $P5623, $P5629
  if_5624_end:
    store_lex "$name", $P5623
.annotate 'line', 1995
    find_lex $P5638, "$/"
    get_hll_global $P5639, ["PAST"], "Op"
    find_lex $P5640, "$name"
    unless_null $P5640, vivify_2630
    new $P5640, "Undef"
  vivify_2630:
    find_lex $P5641, "$/"
    unless_null $P5641, vivify_2631
    $P5641 = root_new ['parrot';'Hash']
  vivify_2631:
    set $P5642, $P5641["semilist"]
    unless_null $P5642, vivify_2632
    new $P5642, "Undef"
  vivify_2632:
    $P5643 = $P5642."ast"()
    $P5644 = $P5639."new"($P5643, "callmethod" :named("pasttype"), $P5640 :named("name"))
    $P5645 = $P5638."!make"($P5644)
.annotate 'line', 1991
    .return ($P5645)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("542_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5647
    .param pmc param_5648
.annotate 'line', 1998
    .lex "self", param_5647
    .lex "$/", param_5648
    find_lex $P5649, "$/"
    find_lex $P5650, "$/"
    unless_null $P5650, vivify_2633
    $P5650 = root_new ['parrot';'Hash']
  vivify_2633:
    set $P5651, $P5650["statement"]
    unless_null $P5651, vivify_2634
    new $P5651, "Undef"
  vivify_2634:
    $P5652 = $P5651."ast"()
    $P5653 = $P5649."!make"($P5652)
    .return ($P5653)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("543_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5655
    .param pmc param_5656
.annotate 'line', 2000
    .lex "self", param_5655
    .lex "$/", param_5656
.annotate 'line', 2001
    find_lex $P5657, "$/"
    get_hll_global $P5658, ["PAST"], "Var"
    find_lex $P5659, "$/"
    unless_null $P5659, vivify_2635
    $P5659 = root_new ['parrot';'Hash']
  vivify_2635:
    set $P5660, $P5659["EXPR"]
    unless_null $P5660, vivify_2636
    new $P5660, "Undef"
  vivify_2636:
    $P5661 = $P5660."ast"()
.annotate 'line', 2003
    $P5662 = "vivitype"("@")
    $P5663 = $P5658."new"($P5661, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5662 :named("vivibase"))
.annotate 'line', 2001
    $P5664 = $P5657."!make"($P5663)
.annotate 'line', 2000
    .return ($P5664)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("544_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5666
    .param pmc param_5667
.annotate 'line', 2006
    .lex "self", param_5666
    .lex "$/", param_5667
.annotate 'line', 2007
    find_lex $P5668, "$/"
    get_hll_global $P5669, ["PAST"], "Var"
    find_lex $P5670, "$/"
    unless_null $P5670, vivify_2637
    $P5670 = root_new ['parrot';'Hash']
  vivify_2637:
    set $P5671, $P5670["EXPR"]
    unless_null $P5671, vivify_2638
    new $P5671, "Undef"
  vivify_2638:
    $P5672 = $P5671."ast"()
.annotate 'line', 2009
    $P5673 = "vivitype"("%")
    $P5674 = $P5669."new"($P5672, "keyed" :named("scope"), "Undef" :named("viviself"), $P5673 :named("vivibase"))
.annotate 'line', 2007
    $P5675 = $P5668."!make"($P5674)
.annotate 'line', 2006
    .return ($P5675)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("545_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5677
    .param pmc param_5678
.annotate 'line', 2012
    .lex "self", param_5677
    .lex "$/", param_5678
.annotate 'line', 2013
    find_lex $P5679, "$/"
    get_hll_global $P5680, ["PAST"], "Var"
    find_lex $P5681, "$/"
    unless_null $P5681, vivify_2639
    $P5681 = root_new ['parrot';'Hash']
  vivify_2639:
    set $P5682, $P5681["quote_EXPR"]
    unless_null $P5682, vivify_2640
    new $P5682, "Undef"
  vivify_2640:
    $P5683 = $P5682."ast"()
.annotate 'line', 2015
    $P5684 = "vivitype"("%")
    $P5685 = $P5680."new"($P5683, "keyed" :named("scope"), "Undef" :named("viviself"), $P5684 :named("vivibase"))
.annotate 'line', 2013
    $P5686 = $P5679."!make"($P5685)
.annotate 'line', 2012
    .return ($P5686)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("546_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5688
    .param pmc param_5689
.annotate 'line', 2018
    .lex "self", param_5688
    .lex "$/", param_5689
.annotate 'line', 2019
    find_lex $P5690, "$/"
    find_lex $P5691, "$/"
    unless_null $P5691, vivify_2641
    $P5691 = root_new ['parrot';'Hash']
  vivify_2641:
    set $P5692, $P5691["arglist"]
    unless_null $P5692, vivify_2642
    new $P5692, "Undef"
  vivify_2642:
    $P5693 = $P5692."ast"()
    $P5694 = $P5690."!make"($P5693)
.annotate 'line', 2018
    .return ($P5694)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("547_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5696
    .param pmc param_5697
.annotate 'line', 2022
    .lex "self", param_5696
    .lex "$/", param_5697
.annotate 'line', 2023
    find_lex $P5698, "$/"
    find_lex $P5701, "$/"
    unless_null $P5701, vivify_2643
    $P5701 = root_new ['parrot';'Hash']
  vivify_2643:
    set $P5702, $P5701["quote"]
    unless_null $P5702, vivify_2644
    new $P5702, "Undef"
  vivify_2644:
    if $P5702, if_5700
    find_lex $P5706, "$/"
    unless_null $P5706, vivify_2645
    $P5706 = root_new ['parrot';'Hash']
  vivify_2645:
    set $P5707, $P5706["number"]
    unless_null $P5707, vivify_2646
    new $P5707, "Undef"
  vivify_2646:
    $P5708 = $P5707."ast"()
    set $P5699, $P5708
    goto if_5700_end
  if_5700:
    find_lex $P5703, "$/"
    unless_null $P5703, vivify_2647
    $P5703 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P5704, $P5703["quote"]
    unless_null $P5704, vivify_2648
    new $P5704, "Undef"
  vivify_2648:
    $P5705 = $P5704."ast"()
    set $P5699, $P5705
  if_5700_end:
    $P5709 = $P5698."!make"($P5699)
.annotate 'line', 2022
    .return ($P5709)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("548_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5711
    .param pmc param_5712
.annotate 'line', 2026
    .lex "self", param_5711
    .lex "$/", param_5712
.annotate 'line', 2027
    new $P5713, "Undef"
    .lex "$value", $P5713
    find_lex $P5716, "$/"
    unless_null $P5716, vivify_2649
    $P5716 = root_new ['parrot';'Hash']
  vivify_2649:
    set $P5717, $P5716["dec_number"]
    unless_null $P5717, vivify_2650
    new $P5717, "Undef"
  vivify_2650:
    if $P5717, if_5715
    find_lex $P5721, "$/"
    unless_null $P5721, vivify_2651
    $P5721 = root_new ['parrot';'Hash']
  vivify_2651:
    set $P5722, $P5721["integer"]
    unless_null $P5722, vivify_2652
    new $P5722, "Undef"
  vivify_2652:
    $P5723 = $P5722."ast"()
    set $P5714, $P5723
    goto if_5715_end
  if_5715:
    find_lex $P5718, "$/"
    unless_null $P5718, vivify_2653
    $P5718 = root_new ['parrot';'Hash']
  vivify_2653:
    set $P5719, $P5718["dec_number"]
    unless_null $P5719, vivify_2654
    new $P5719, "Undef"
  vivify_2654:
    $P5720 = $P5719."ast"()
    set $P5714, $P5720
  if_5715_end:
    store_lex "$value", $P5714
.annotate 'line', 2028
    find_lex $P5725, "$/"
    unless_null $P5725, vivify_2655
    $P5725 = root_new ['parrot';'Hash']
  vivify_2655:
    set $P5726, $P5725["sign"]
    unless_null $P5726, vivify_2656
    new $P5726, "Undef"
  vivify_2656:
    set $S5727, $P5726
    iseq $I5728, $S5727, "-"
    unless $I5728, if_5724_end
    find_lex $P5729, "$value"
    unless_null $P5729, vivify_2657
    new $P5729, "Undef"
  vivify_2657:
    neg $P5730, $P5729
    store_lex "$value", $P5730
  if_5724_end:
.annotate 'line', 2029
    find_lex $P5731, "$/"
    get_hll_global $P5732, ["PAST"], "Val"
    find_lex $P5733, "$value"
    unless_null $P5733, vivify_2658
    new $P5733, "Undef"
  vivify_2658:
    $P5734 = $P5732."new"($P5733 :named("value"))
    $P5735 = $P5731."!make"($P5734)
.annotate 'line', 2026
    .return ($P5735)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("549_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5737
    .param pmc param_5738
.annotate 'line', 2032
    .lex "self", param_5737
    .lex "$/", param_5738
    find_lex $P5739, "$/"
    find_lex $P5740, "$/"
    unless_null $P5740, vivify_2659
    $P5740 = root_new ['parrot';'Hash']
  vivify_2659:
    set $P5741, $P5740["quote_EXPR"]
    unless_null $P5741, vivify_2660
    new $P5741, "Undef"
  vivify_2660:
    $P5742 = $P5741."ast"()
    $P5743 = $P5739."!make"($P5742)
    .return ($P5743)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("550_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5745
    .param pmc param_5746
.annotate 'line', 2033
    .lex "self", param_5745
    .lex "$/", param_5746
    find_lex $P5747, "$/"
    find_lex $P5748, "$/"
    unless_null $P5748, vivify_2661
    $P5748 = root_new ['parrot';'Hash']
  vivify_2661:
    set $P5749, $P5748["quote_EXPR"]
    unless_null $P5749, vivify_2662
    new $P5749, "Undef"
  vivify_2662:
    $P5750 = $P5749."ast"()
    $P5751 = $P5747."!make"($P5750)
    .return ($P5751)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("551_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5753
    .param pmc param_5754
.annotate 'line', 2034
    .lex "self", param_5753
    .lex "$/", param_5754
    find_lex $P5755, "$/"
    find_lex $P5756, "$/"
    unless_null $P5756, vivify_2663
    $P5756 = root_new ['parrot';'Hash']
  vivify_2663:
    set $P5757, $P5756["quote_EXPR"]
    unless_null $P5757, vivify_2664
    new $P5757, "Undef"
  vivify_2664:
    $P5758 = $P5757."ast"()
    $P5759 = $P5755."!make"($P5758)
    .return ($P5759)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("552_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5761
    .param pmc param_5762
.annotate 'line', 2035
    .lex "self", param_5761
    .lex "$/", param_5762
    find_lex $P5763, "$/"
    find_lex $P5764, "$/"
    unless_null $P5764, vivify_2665
    $P5764 = root_new ['parrot';'Hash']
  vivify_2665:
    set $P5765, $P5764["quote_EXPR"]
    unless_null $P5765, vivify_2666
    new $P5765, "Undef"
  vivify_2666:
    $P5766 = $P5765."ast"()
    $P5767 = $P5763."!make"($P5766)
    .return ($P5767)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("553_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5769
    .param pmc param_5770
.annotate 'line', 2036
    .lex "self", param_5769
    .lex "$/", param_5770
    find_lex $P5771, "$/"
    find_lex $P5772, "$/"
    unless_null $P5772, vivify_2667
    $P5772 = root_new ['parrot';'Hash']
  vivify_2667:
    set $P5773, $P5772["quote_EXPR"]
    unless_null $P5773, vivify_2668
    new $P5773, "Undef"
  vivify_2668:
    $P5774 = $P5773."ast"()
    $P5775 = $P5771."!make"($P5774)
    .return ($P5775)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("554_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5777
    .param pmc param_5778
.annotate 'line', 2037
    .lex "self", param_5777
    .lex "$/", param_5778
.annotate 'line', 2038
    find_lex $P5779, "$/"
    get_hll_global $P5780, ["PAST"], "Op"
    find_lex $P5781, "$/"
    unless_null $P5781, vivify_2669
    $P5781 = root_new ['parrot';'Hash']
  vivify_2669:
    set $P5782, $P5781["quote_EXPR"]
    unless_null $P5782, vivify_2670
    new $P5782, "Undef"
  vivify_2670:
    $P5783 = $P5782."ast"()
    $P5784 = $P5783."value"()
    find_lex $P5785, "$/"
    unless_null $P5785, vivify_2671
    new $P5785, "Undef"
  vivify_2671:
    $P5786 = $P5780."new"($P5784 :named("inline"), "inline" :named("pasttype"), $P5785 :named("node"))
    $P5787 = $P5779."!make"($P5786)
.annotate 'line', 2037
    .return ($P5787)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("555_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5791
    .param pmc param_5792
    .param pmc param_5793 :optional
    .param int has_param_5793 :opt_flag
.annotate 'line', 2043
    new $P5790, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5790, control_5789
    push_eh $P5790
    .lex "self", param_5791
    .lex "$/", param_5792
    if has_param_5793, optparam_2672
    new $P5794, "Undef"
    set param_5793, $P5794
  optparam_2672:
    .lex "$key", param_5793
.annotate 'line', 2050
    new $P5795, "Undef"
    .lex "$regex", $P5795
.annotate 'line', 2052
    new $P5796, "Undef"
    .lex "$past", $P5796
.annotate 'line', 2044
    find_lex $P5798, "$key"
    unless_null $P5798, vivify_2673
    new $P5798, "Undef"
  vivify_2673:
    set $S5799, $P5798
    iseq $I5800, $S5799, "open"
    unless $I5800, if_5797_end
.annotate 'line', 2045
    null $P5801
    get_hll_global $P5802, ["Regex";"P6Regex"], "Actions"
    get_who $P5803, $P5802
    set $P5803["$REGEXNAME"], $P5801
.annotate 'line', 2046
    find_lex $P5804, "$?PACKAGE"
    get_who $P5805, $P5804
    set $P5806, $P5805["@BLOCK"]
    unless_null $P5806, vivify_2674
    $P5806 = root_new ['parrot';'ResizablePMCArray']
  vivify_2674:
    set $P5807, $P5806[0]
    unless_null $P5807, vivify_2675
    new $P5807, "Undef"
  vivify_2675:
    $P5807."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2047
    find_lex $P5808, "$?PACKAGE"
    get_who $P5809, $P5808
    set $P5810, $P5809["@BLOCK"]
    unless_null $P5810, vivify_2676
    $P5810 = root_new ['parrot';'ResizablePMCArray']
  vivify_2676:
    set $P5811, $P5810[0]
    unless_null $P5811, vivify_2677
    new $P5811, "Undef"
  vivify_2677:
    $P5811."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2048
    new $P5812, "Exception"
    set $P5812['type'], .CONTROL_RETURN
    new $P5813, "Integer"
    assign $P5813, 0
    setattribute $P5812, 'payload', $P5813
    throw $P5812
  if_5797_end:
.annotate 'line', 2051
    get_hll_global $P5814, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5815, "$/"
    unless_null $P5815, vivify_2678
    $P5815 = root_new ['parrot';'Hash']
  vivify_2678:
    set $P5816, $P5815["p6regex"]
    unless_null $P5816, vivify_2679
    new $P5816, "Undef"
  vivify_2679:
    $P5817 = $P5816."ast"()
    find_lex $P5818, "$?PACKAGE"
    get_who $P5819, $P5818
    set $P5820, $P5819["@BLOCK"]
    unless_null $P5820, vivify_2680
    $P5820 = root_new ['parrot';'ResizablePMCArray']
  vivify_2680:
    $P5821 = $P5820."shift"()
    $P5822 = $P5814($P5817, $P5821)
    store_lex "$regex", $P5822
.annotate 'line', 2053
    get_hll_global $P5823, ["PAST"], "Op"
.annotate 'line', 2055
    get_hll_global $P5824, ["PAST"], "Var"
    new $P5825, "ResizablePMCArray"
    push $P5825, "Regex"
    $P5826 = $P5824."new"("Regex" :named("name"), $P5825 :named("namespace"), "package" :named("scope"))
    find_lex $P5827, "$regex"
    unless_null $P5827, vivify_2681
    new $P5827, "Undef"
  vivify_2681:
    $P5828 = $P5823."new"($P5826, $P5827, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2053
    store_lex "$past", $P5828
.annotate 'line', 2059
    find_lex $P5829, "$regex"
    unless_null $P5829, vivify_2682
    new $P5829, "Undef"
  vivify_2682:
    find_lex $P5830, "$past"
    unless_null $P5830, vivify_2683
    $P5830 = root_new ['parrot';'Hash']
    store_lex "$past", $P5830
  vivify_2683:
    set $P5830["sink"], $P5829
.annotate 'line', 2060
    find_lex $P5831, "$/"
    find_lex $P5832, "$past"
    unless_null $P5832, vivify_2684
    new $P5832, "Undef"
  vivify_2684:
    $P5833 = $P5831."!make"($P5832)
.annotate 'line', 2043
    .return ($P5833)
  control_5789:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5834, exception, "payload"
    .return ($P5834)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("556_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5836
    .param pmc param_5837
.annotate 'line', 2063
    .lex "self", param_5836
    .lex "$/", param_5837
    find_lex $P5838, "$/"
    find_lex $P5839, "$/"
    unless_null $P5839, vivify_2685
    $P5839 = root_new ['parrot';'Hash']
  vivify_2685:
    set $P5840, $P5839["variable"]
    unless_null $P5840, vivify_2686
    new $P5840, "Undef"
  vivify_2686:
    $P5841 = $P5840."ast"()
    $P5842 = $P5838."!make"($P5841)
    .return ($P5842)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("557_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5844
    .param pmc param_5845
.annotate 'line', 2064
    .lex "self", param_5844
    .lex "$/", param_5845
.annotate 'line', 2065
    find_lex $P5846, "$/"
    get_hll_global $P5847, ["PAST"], "Op"
.annotate 'line', 2066
    find_lex $P5848, "$/"
    unless_null $P5848, vivify_2687
    $P5848 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P5849, $P5848["block"]
    unless_null $P5849, vivify_2688
    new $P5849, "Undef"
  vivify_2688:
    $P5850 = $P5849."ast"()
    $P5851 = "block_immediate"($P5850)
    find_lex $P5852, "$/"
    unless_null $P5852, vivify_2689
    new $P5852, "Undef"
  vivify_2689:
    $P5853 = $P5847."new"($P5851, "set S*" :named("pirop"), $P5852 :named("node"))
.annotate 'line', 2065
    $P5854 = $P5846."!make"($P5853)
.annotate 'line', 2064
    .return ($P5854)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("558_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5856
    .param pmc param_5857
.annotate 'line', 2069
    .lex "self", param_5856
    .lex "$/", param_5857
    find_lex $P5858, "$/"
    $P5859 = $P5858."!make"("\e")
    .return ($P5859)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("559_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5861
    .param pmc param_5862
.annotate 'line', 2073
    .lex "self", param_5861
    .lex "$/", param_5862
    find_lex $P5863, "$/"
    find_lex $P5864, "$/"
    unless_null $P5864, vivify_2690
    $P5864 = root_new ['parrot';'Hash']
  vivify_2690:
    set $P5865, $P5864["dotty"]
    unless_null $P5865, vivify_2691
    new $P5865, "Undef"
  vivify_2691:
    $P5866 = $P5865."ast"()
    $P5867 = $P5863."!make"($P5866)
    .return ($P5867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("560_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5869
    .param pmc param_5870
.annotate 'line', 2075
    .lex "self", param_5869
    .lex "$/", param_5870
.annotate 'line', 2076
    find_lex $P5871, "$/"
    get_hll_global $P5872, ["PAST"], "Op"
.annotate 'line', 2077
    new $P5873, "ResizablePMCArray"
    push $P5873, "    clone %r, %0"
    push $P5873, "    inc %0"
    $P5874 = $P5872."new"("postfix:<++>" :named("name"), $P5873 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2076
    $P5875 = $P5871."!make"($P5874)
.annotate 'line', 2075
    .return ($P5875)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("561_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5877
    .param pmc param_5878
.annotate 'line', 2081
    .lex "self", param_5877
    .lex "$/", param_5878
.annotate 'line', 2082
    find_lex $P5879, "$/"
    get_hll_global $P5880, ["PAST"], "Op"
.annotate 'line', 2083
    new $P5881, "ResizablePMCArray"
    push $P5881, "    clone %r, %0"
    push $P5881, "    dec %0"
    $P5882 = $P5880."new"("postfix:<-->" :named("name"), $P5881 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2082
    $P5883 = $P5879."!make"($P5882)
.annotate 'line', 2081
    .return ($P5883)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("562_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5885
    .param pmc param_5886
.annotate 'line', 2087
    .lex "self", param_5885
    .lex "$/", param_5886
.annotate 'line', 2088
    find_lex $P5887, "$/"
    get_hll_global $P5888, ["PAST"], "Op"
.annotate 'line', 2089
    get_hll_global $P5889, ["PAST"], "Var"
    $P5890 = $P5889."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5891, "$/"
    unless_null $P5891, vivify_2692
    new $P5891, "Undef"
  vivify_2692:
    $P5892 = $P5888."new"($P5890, "callmethod" :named("pasttype"), "!make" :named("name"), $P5891 :named("node"))
.annotate 'line', 2088
    $P5893 = $P5887."!make"($P5892)
.annotate 'line', 2087
    .return ($P5893)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("563_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5896
    .param pmc param_5897
.annotate 'line', 2105
    .lex "self", param_5896
    .lex "$/", param_5897
    find_lex $P5898, "$/"
    unless_null $P5898, vivify_2693
    new $P5898, "Undef"
  vivify_2693:
    $P5899 = "control"($P5898, "CONTROL_LOOP_NEXT")
    .return ($P5899)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("564_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5901
    .param pmc param_5902
.annotate 'line', 2106
    .lex "self", param_5901
    .lex "$/", param_5902
    find_lex $P5903, "$/"
    unless_null $P5903, vivify_2694
    new $P5903, "Undef"
  vivify_2694:
    $P5904 = "control"($P5903, "CONTROL_LOOP_LAST")
    .return ($P5904)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("565_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5906
    .param pmc param_5907
.annotate 'line', 2107
    .lex "self", param_5906
    .lex "$/", param_5907
    find_lex $P5908, "$/"
    unless_null $P5908, vivify_2695
    new $P5908, "Undef"
  vivify_2695:
    $P5909 = "control"($P5908, "CONTROL_LOOP_REDO")
    .return ($P5909)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("566_1303603603.711") :outer("406_1303603603.711")
    .param pmc param_5911
    .param pmc param_5912
.annotate 'line', 2109
    .lex "self", param_5911
    .lex "$/", param_5912
.annotate 'line', 2110
    find_lex $P5913, "$/"
    get_hll_global $P5914, ["PAST"], "Op"
    find_lex $P5915, "$/"
    unless_null $P5915, vivify_2696
    new $P5915, "Undef"
  vivify_2696:
    $P5916 = $P5914."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5915 :named("node"))
    $P5917 = $P5913."!make"($P5916)
.annotate 'line', 2109
    .return ($P5917)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6148"  :subid("568_1303603603.711") :outer("10_1303603603.711")
.annotate 'line', 2242
    .const 'Sub' $P6249 = "576_1303603603.711" 
    capture_lex $P6249
    .const 'Sub' $P6224 = "575_1303603603.711" 
    capture_lex $P6224
    .const 'Sub' $P6213 = "574_1303603603.711" 
    capture_lex $P6213
    .const 'Sub' $P6198 = "573_1303603603.711" 
    capture_lex $P6198
    .const 'Sub' $P6187 = "572_1303603603.711" 
    capture_lex $P6187
    .const 'Sub' $P6176 = "571_1303603603.711" 
    capture_lex $P6176
    .const 'Sub' $P6165 = "570_1303603603.711" 
    capture_lex $P6165
    .const 'Sub' $P6152 = "569_1303603603.711" 
    capture_lex $P6152
    .lex "$?PACKAGE", $P6150
    .lex "$?CLASS", $P6151
.annotate 'line', 2276
    .const 'Sub' $P6224 = "575_1303603603.711" 
    newclosure $P6247, $P6224
.annotate 'line', 2242
    .return ($P6247)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2697") :outer("568_1303603603.711")
.annotate 'line', 2242
    .const 'Sub' $P6149 = "568_1303603603.711" 
    .local pmc block
    set block, $P6149
    .const 'Sub' $P6249 = "576_1303603603.711" 
    capture_lex $P6249
    $P6249()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6248"  :anon :subid("576_1303603603.711") :outer("568_1303603603.711")
.annotate 'line', 2242
    nqp_get_sc_object $P6250, "1303603591.505", 4
    .local pmc type_obj
    set type_obj, $P6250
    get_how $P6251, type_obj
    .const 'Sub' $P6252 = "569_1303603603.711" 
    $P6251."add_method"(type_obj, "metachar:sym<:my>", $P6252)
    get_how $P6253, type_obj
    .const 'Sub' $P6254 = "570_1303603603.711" 
    $P6253."add_method"(type_obj, "metachar:sym<{ }>", $P6254)
    get_how $P6255, type_obj
    .const 'Sub' $P6256 = "571_1303603603.711" 
    $P6255."add_method"(type_obj, "metachar:sym<nqpvar>", $P6256)
    get_how $P6257, type_obj
    .const 'Sub' $P6258 = "572_1303603603.711" 
    $P6257."add_method"(type_obj, "assertion:sym<{ }>", $P6258)
    get_how $P6259, type_obj
    .const 'Sub' $P6260 = "573_1303603603.711" 
    $P6259."add_method"(type_obj, "assertion:sym<?{ }>", $P6260)
    get_how $P6261, type_obj
    .const 'Sub' $P6262 = "574_1303603603.711" 
    $P6261."add_method"(type_obj, "assertion:sym<var>", $P6262)
    get_how $P6263, type_obj
    .const 'Sub' $P6264 = "575_1303603603.711" 
    $P6263."add_method"(type_obj, "codeblock", $P6264)
    get_how $P6265, type_obj
    get_hll_global $P6266, ["Regex";"P6Regex"], "Actions"
    $P6265."add_parent"(type_obj, $P6266)
    get_how $P6267, type_obj
    $P6268 = $P6267."compose"(type_obj)
    .return ($P6268)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("569_1303603603.711") :outer("568_1303603603.711")
    .param pmc param_6153
    .param pmc param_6154
.annotate 'line', 2244
    .lex "self", param_6153
    .lex "$/", param_6154
.annotate 'line', 2245
    new $P6155, "Undef"
    .lex "$past", $P6155
    find_lex $P6156, "$/"
    unless_null $P6156, vivify_2698
    $P6156 = root_new ['parrot';'Hash']
  vivify_2698:
    set $P6157, $P6156["statement"]
    unless_null $P6157, vivify_2699
    new $P6157, "Undef"
  vivify_2699:
    $P6158 = $P6157."ast"()
    store_lex "$past", $P6158
.annotate 'line', 2246
    find_lex $P6159, "$/"
    get_hll_global $P6160, ["PAST"], "Regex"
    find_lex $P6161, "$past"
    unless_null $P6161, vivify_2700
    new $P6161, "Undef"
  vivify_2700:
    find_lex $P6162, "$/"
    unless_null $P6162, vivify_2701
    new $P6162, "Undef"
  vivify_2701:
    $P6163 = $P6160."new"($P6161, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6162 :named("node"))
    $P6164 = $P6159."!make"($P6163)
.annotate 'line', 2244
    .return ($P6164)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("570_1303603603.711") :outer("568_1303603603.711")
    .param pmc param_6166
    .param pmc param_6167
.annotate 'line', 2250
    .lex "self", param_6166
    .lex "$/", param_6167
.annotate 'line', 2251
    find_lex $P6168, "$/"
    get_hll_global $P6169, ["PAST"], "Regex"
    find_lex $P6170, "$/"
    unless_null $P6170, vivify_2702
    $P6170 = root_new ['parrot';'Hash']
  vivify_2702:
    set $P6171, $P6170["codeblock"]
    unless_null $P6171, vivify_2703
    new $P6171, "Undef"
  vivify_2703:
    $P6172 = $P6171."ast"()
    find_lex $P6173, "$/"
    unless_null $P6173, vivify_2704
    new $P6173, "Undef"
  vivify_2704:
    $P6174 = $P6169."new"($P6172, "pastnode" :named("pasttype"), $P6173 :named("node"))
    $P6175 = $P6168."!make"($P6174)
.annotate 'line', 2250
    .return ($P6175)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("571_1303603603.711") :outer("568_1303603603.711")
    .param pmc param_6177
    .param pmc param_6178
.annotate 'line', 2255
    .lex "self", param_6177
    .lex "$/", param_6178
.annotate 'line', 2256
    find_lex $P6179, "$/"
    get_hll_global $P6180, ["PAST"], "Regex"
    find_lex $P6181, "$/"
    unless_null $P6181, vivify_2705
    $P6181 = root_new ['parrot';'Hash']
  vivify_2705:
    set $P6182, $P6181["var"]
    unless_null $P6182, vivify_2706
    new $P6182, "Undef"
  vivify_2706:
    $P6183 = $P6182."ast"()
    find_lex $P6184, "$/"
    unless_null $P6184, vivify_2707
    new $P6184, "Undef"
  vivify_2707:
    $P6185 = $P6180."new"("!INTERPOLATE", $P6183, "subrule" :named("pasttype"), "method" :named("subtype"), $P6184 :named("node"))
    $P6186 = $P6179."!make"($P6185)
.annotate 'line', 2255
    .return ($P6186)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("572_1303603603.711") :outer("568_1303603603.711")
    .param pmc param_6188
    .param pmc param_6189
.annotate 'line', 2260
    .lex "self", param_6188
    .lex "$/", param_6189
.annotate 'line', 2261
    find_lex $P6190, "$/"
    get_hll_global $P6191, ["PAST"], "Regex"
    find_lex $P6192, "$/"
    unless_null $P6192, vivify_2708
    $P6192 = root_new ['parrot';'Hash']
  vivify_2708:
    set $P6193, $P6192["codeblock"]
    unless_null $P6193, vivify_2709
    new $P6193, "Undef"
  vivify_2709:
    $P6194 = $P6193."ast"()
    find_lex $P6195, "$/"
    unless_null $P6195, vivify_2710
    new $P6195, "Undef"
  vivify_2710:
    $P6196 = $P6191."new"("!INTERPOLATE_REGEX", $P6194, "subrule" :named("pasttype"), "method" :named("subtype"), $P6195 :named("node"))
    $P6197 = $P6190."!make"($P6196)
.annotate 'line', 2260
    .return ($P6197)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("573_1303603603.711") :outer("568_1303603603.711")
    .param pmc param_6199
    .param pmc param_6200
.annotate 'line', 2265
    .lex "self", param_6199
    .lex "$/", param_6200
.annotate 'line', 2266
    find_lex $P6201, "$/"
    get_hll_global $P6202, ["PAST"], "Regex"
    find_lex $P6203, "$/"
    unless_null $P6203, vivify_2711
    $P6203 = root_new ['parrot';'Hash']
  vivify_2711:
    set $P6204, $P6203["codeblock"]
    unless_null $P6204, vivify_2712
    new $P6204, "Undef"
  vivify_2712:
    $P6205 = $P6204."ast"()
.annotate 'line', 2267
    find_lex $P6206, "$/"
    unless_null $P6206, vivify_2713
    $P6206 = root_new ['parrot';'Hash']
  vivify_2713:
    set $P6207, $P6206["zw"]
    unless_null $P6207, vivify_2714
    new $P6207, "Undef"
  vivify_2714:
    set $S6208, $P6207
    iseq $I6209, $S6208, "!"
    find_lex $P6210, "$/"
    unless_null $P6210, vivify_2715
    new $P6210, "Undef"
  vivify_2715:
    $P6211 = $P6202."new"($P6205, "zerowidth" :named("subtype"), $I6209 :named("negate"), "pastnode" :named("pasttype"), $P6210 :named("node"))
.annotate 'line', 2266
    $P6212 = $P6201."!make"($P6211)
.annotate 'line', 2265
    .return ($P6212)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("574_1303603603.711") :outer("568_1303603603.711")
    .param pmc param_6214
    .param pmc param_6215
.annotate 'line', 2271
    .lex "self", param_6214
    .lex "$/", param_6215
.annotate 'line', 2272
    find_lex $P6216, "$/"
    get_hll_global $P6217, ["PAST"], "Regex"
    find_lex $P6218, "$/"
    unless_null $P6218, vivify_2716
    $P6218 = root_new ['parrot';'Hash']
  vivify_2716:
    set $P6219, $P6218["var"]
    unless_null $P6219, vivify_2717
    new $P6219, "Undef"
  vivify_2717:
    $P6220 = $P6219."ast"()
    find_lex $P6221, "$/"
    unless_null $P6221, vivify_2718
    new $P6221, "Undef"
  vivify_2718:
    $P6222 = $P6217."new"("!INTERPOLATE_REGEX", $P6220, "subrule" :named("pasttype"), "method" :named("subtype"), $P6221 :named("node"))
    $P6223 = $P6216."!make"($P6222)
.annotate 'line', 2271
    .return ($P6223)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("575_1303603603.711") :outer("568_1303603603.711")
    .param pmc param_6225
    .param pmc param_6226
.annotate 'line', 2276
    .lex "self", param_6225
    .lex "$/", param_6226
.annotate 'line', 2277
    new $P6227, "Undef"
    .lex "$block", $P6227
.annotate 'line', 2279
    new $P6228, "Undef"
    .lex "$past", $P6228
.annotate 'line', 2277
    find_lex $P6229, "$/"
    unless_null $P6229, vivify_2719
    $P6229 = root_new ['parrot';'Hash']
  vivify_2719:
    set $P6230, $P6229["block"]
    unless_null $P6230, vivify_2720
    new $P6230, "Undef"
  vivify_2720:
    $P6231 = $P6230."ast"()
    store_lex "$block", $P6231
.annotate 'line', 2278
    find_lex $P6232, "$block"
    unless_null $P6232, vivify_2721
    new $P6232, "Undef"
  vivify_2721:
    $P6232."blocktype"("immediate")
.annotate 'line', 2280
    get_hll_global $P6233, ["PAST"], "Stmts"
.annotate 'line', 2281
    get_hll_global $P6234, ["PAST"], "Op"
.annotate 'line', 2282
    get_hll_global $P6235, ["PAST"], "Var"
    $P6236 = $P6235."new"("$/" :named("name"))
.annotate 'line', 2283
    get_hll_global $P6237, ["PAST"], "Op"
.annotate 'line', 2284
    get_hll_global $P6238, ["PAST"], "Var"
    $P6239 = $P6238."new"(unicode:"$\x{a2}" :named("name"))
    $P6240 = $P6237."new"($P6239, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2283
    $P6241 = $P6234."new"($P6236, $P6240, "bind" :named("pasttype"))
.annotate 'line', 2281
    find_lex $P6242, "$block"
    unless_null $P6242, vivify_2722
    new $P6242, "Undef"
  vivify_2722:
    $P6243 = $P6233."new"($P6241, $P6242)
.annotate 'line', 2280
    store_lex "$past", $P6243
.annotate 'line', 2292
    find_lex $P6244, "$/"
    find_lex $P6245, "$past"
    unless_null $P6245, vivify_2723
    new $P6245, "Undef"
  vivify_2723:
    $P6246 = $P6244."!make"($P6245)
.annotate 'line', 2276
    .return ($P6246)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6269"  :subid("577_1303603603.711") :outer("10_1303603603.711")
.annotate 'line', 2297
    .const 'Sub' $P6274 = "578_1303603603.711" 
    capture_lex $P6274
    .lex "$?PACKAGE", $P6271
    .lex "$?CLASS", $P6272
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2724") :outer("577_1303603603.711")
.annotate 'line', 2297
    .const 'Sub' $P6270 = "577_1303603603.711" 
    .local pmc block
    set block, $P6270
    .const 'Sub' $P6274 = "578_1303603603.711" 
    capture_lex $P6274
    $P6274()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6273"  :anon :subid("578_1303603603.711") :outer("577_1303603603.711")
.annotate 'line', 2297
    nqp_get_sc_object $P6275, "1303603591.505", 5
    .local pmc type_obj
    set type_obj, $P6275
    get_how $P6276, type_obj
    get_hll_global $P6277, ["HLL"], "Compiler"
    $P6276."add_parent"(type_obj, $P6277)
    get_how $P6278, type_obj
    $P6279 = $P6278."compose"(type_obj)
    .return ($P6279)
.end


.HLL "nqp"

.namespace []
.sub "_block6287" :load :anon :subid("579_1303603603.711")
.annotate 'line', 1
    .const 'Sub' $P6289 = "10_1303603603.711" 
    $P6290 = $P6289()
    .return ($P6290)
.end

