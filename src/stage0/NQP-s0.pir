
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1303923618.727")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P7300 = "587_1303923618.727" 
    capture_lex $P7300
    .const 'Sub' $P7148 = "578_1303923618.727" 
    capture_lex $P7148
    .const 'Sub' $P2759 = "407_1303923618.727" 
    capture_lex $P2759
    .const 'Sub' $P2657 = "385_1303923618.727" 
    capture_lex $P2657
    .const 'Sub' $P47 = "12_1303923618.727" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1303923618.727" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2313
    .const 'Sub' $P16 = "11_1303923618.727" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1303923618.727" 
    capture_lex $P47
    $P47()
.annotate 'line', 728
    .const 'Sub' $P2657 = "385_1303923618.727" 
    capture_lex $P2657
    $P2657()
.annotate 'line', 771
    .const 'Sub' $P2759 = "407_1303923618.727" 
    capture_lex $P2759
    $P2759()
.annotate 'line', 2255
    .const 'Sub' $P7148 = "578_1303923618.727" 
    capture_lex $P7148
    $P7148()
.annotate 'line', 2310
    .const 'Sub' $P7300 = "587_1303923618.727" 
    capture_lex $P7300
    $P7300()
    find_lex $P7308, "MAIN"
    find_lex $P7311, "@ARGS"
    if $P7311, if_7310
    set $P7309, $P7311
    goto if_7310_end
  if_7310:
    .const 'Sub' $P7312 = "11_1303923618.727" 
    find_lex $P7313, "@ARGS"
    $P7314 = $P7312($P7313 :flat)
    set $P7309, $P7314
  if_7310_end:
.annotate 'line', 1
    .return ($P7309)
    .const 'Sub' $P7316 = "589_1303923618.727" 
    .return ($P7316)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post590") :outer("10_1303923618.727")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1303923618.727" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P7320, "1303923606.34"
    isnull $I7321, $P7320
    if $I7321, if_7319
    .const 'Sub' $P7449 = "10_1303923618.727" 
    $P7450 = $P7449."get_lexinfo"()
    nqp_get_sc_object $P7451, "1303923606.34", 0
    $P7450."set_static_lexpad_value"("GLOBALish", $P7451)
    .const 'Sub' $P7452 = "10_1303923618.727" 
    $P7453 = $P7452."get_lexinfo"()
    $P7453."finish_static_lexpad"()
    .const 'Sub' $P7454 = "10_1303923618.727" 
    $P7455 = $P7454."get_lexinfo"()
    nqp_get_sc_object $P7456, "1303923606.34", 0
    $P7455."set_static_lexpad_value"("$?PACKAGE", $P7456)
    .const 'Sub' $P7457 = "10_1303923618.727" 
    $P7458 = $P7457."get_lexinfo"()
    $P7458."finish_static_lexpad"()
    nqp_get_sc_object $P7459, "1303923606.34", 1
    set_hll_global ["NQP"], "Grammar", $P7459
    .const 'Sub' $P7460 = "12_1303923618.727" 
    $P7461 = $P7460."get_lexinfo"()
    nqp_get_sc_object $P7462, "1303923606.34", 1
    $P7461."set_static_lexpad_value"("$?PACKAGE", $P7462)
    .const 'Sub' $P7463 = "12_1303923618.727" 
    $P7464 = $P7463."get_lexinfo"()
    $P7464."finish_static_lexpad"()
    .const 'Sub' $P7465 = "12_1303923618.727" 
    $P7466 = $P7465."get_lexinfo"()
    nqp_get_sc_object $P7467, "1303923606.34", 1
    $P7466."set_static_lexpad_value"("$?CLASS", $P7467)
    .const 'Sub' $P7468 = "12_1303923618.727" 
    $P7469 = $P7468."get_lexinfo"()
    $P7469."finish_static_lexpad"()
    nqp_get_sc_object $P7470, "1303923606.34", 2
    set_hll_global ["NQP"], "Regex", $P7470
    .const 'Sub' $P7471 = "385_1303923618.727" 
    $P7472 = $P7471."get_lexinfo"()
    nqp_get_sc_object $P7473, "1303923606.34", 2
    $P7472."set_static_lexpad_value"("$?PACKAGE", $P7473)
    .const 'Sub' $P7474 = "385_1303923618.727" 
    $P7475 = $P7474."get_lexinfo"()
    $P7475."finish_static_lexpad"()
    .const 'Sub' $P7476 = "385_1303923618.727" 
    $P7477 = $P7476."get_lexinfo"()
    nqp_get_sc_object $P7478, "1303923606.34", 2
    $P7477."set_static_lexpad_value"("$?CLASS", $P7478)
    .const 'Sub' $P7479 = "385_1303923618.727" 
    $P7480 = $P7479."get_lexinfo"()
    $P7480."finish_static_lexpad"()
    nqp_get_sc_object $P7481, "1303923606.34", 3
    set_hll_global ["NQP"], "Actions", $P7481
    .const 'Sub' $P7482 = "407_1303923618.727" 
    $P7483 = $P7482."get_lexinfo"()
    nqp_get_sc_object $P7484, "1303923606.34", 3
    $P7483."set_static_lexpad_value"("$?PACKAGE", $P7484)
    .const 'Sub' $P7485 = "407_1303923618.727" 
    $P7486 = $P7485."get_lexinfo"()
    $P7486."finish_static_lexpad"()
    .const 'Sub' $P7487 = "407_1303923618.727" 
    $P7488 = $P7487."get_lexinfo"()
    nqp_get_sc_object $P7489, "1303923606.34", 3
    $P7488."set_static_lexpad_value"("$?CLASS", $P7489)
    .const 'Sub' $P7490 = "407_1303923618.727" 
    $P7491 = $P7490."get_lexinfo"()
    $P7491."finish_static_lexpad"()
    nqp_get_sc_object $P7492, "1303923606.34", 4
    set_hll_global ["NQP"], "RegexActions", $P7492
    .const 'Sub' $P7493 = "578_1303923618.727" 
    $P7494 = $P7493."get_lexinfo"()
    nqp_get_sc_object $P7495, "1303923606.34", 4
    $P7494."set_static_lexpad_value"("$?PACKAGE", $P7495)
    .const 'Sub' $P7496 = "578_1303923618.727" 
    $P7497 = $P7496."get_lexinfo"()
    $P7497."finish_static_lexpad"()
    .const 'Sub' $P7498 = "578_1303923618.727" 
    $P7499 = $P7498."get_lexinfo"()
    nqp_get_sc_object $P7500, "1303923606.34", 4
    $P7499."set_static_lexpad_value"("$?CLASS", $P7500)
    .const 'Sub' $P7501 = "578_1303923618.727" 
    $P7502 = $P7501."get_lexinfo"()
    $P7502."finish_static_lexpad"()
    nqp_get_sc_object $P7503, "1303923606.34", 5
    set_hll_global ["NQP"], "Compiler", $P7503
    .const 'Sub' $P7504 = "587_1303923618.727" 
    $P7505 = $P7504."get_lexinfo"()
    nqp_get_sc_object $P7506, "1303923606.34", 5
    $P7505."set_static_lexpad_value"("$?PACKAGE", $P7506)
    .const 'Sub' $P7507 = "587_1303923618.727" 
    $P7508 = $P7507."get_lexinfo"()
    $P7508."finish_static_lexpad"()
    .const 'Sub' $P7509 = "587_1303923618.727" 
    $P7510 = $P7509."get_lexinfo"()
    nqp_get_sc_object $P7511, "1303923606.34", 5
    $P7510."set_static_lexpad_value"("$?CLASS", $P7511)
    .const 'Sub' $P7512 = "587_1303923618.727" 
    $P7513 = $P7512."get_lexinfo"()
    $P7513."finish_static_lexpad"()
    goto if_7319_end
  if_7319:
    nqp_dynop_setup 
    getinterp $P7322
    get_class $P7323, "LexPad"
    get_class $P7324, "NQPLexPad"
    $P7322."hll_map"($P7323, $P7324)
    nqp_create_sc $P7325, "1303923606.34"
    .local pmc cur_sc
    set cur_sc, $P7325
    nqp_get_sc_object $P7326, "__6MODEL_CORE__", 0
    $P7327 = $P7326."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P7327, cur_sc
    nqp_set_sc_object "1303923606.34", 0, $P7327
    .const 'Sub' $P7328 = "10_1303923618.727" 
    $P7329 = $P7328."get_lexinfo"()
    nqp_get_sc_object $P7330, "1303923606.34", 0
    $P7329."set_static_lexpad_value"("GLOBALish", $P7330)
    .const 'Sub' $P7331 = "10_1303923618.727" 
    $P7332 = $P7331."get_lexinfo"()
    $P7332."finish_static_lexpad"()
    .const 'Sub' $P7333 = "10_1303923618.727" 
    $P7334 = $P7333."get_lexinfo"()
    nqp_get_sc_object $P7335, "1303923606.34", 0
    $P7334."set_static_lexpad_value"("$?PACKAGE", $P7335)
    .const 'Sub' $P7336 = "10_1303923618.727" 
    $P7337 = $P7336."get_lexinfo"()
    $P7337."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7338, "ModuleLoader"
    $P7339 = $P7338."load_setting"("NQPCORE")
    block."set_outer_ctx"($P7339)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7340, "ModuleLoader"
    nqp_get_sc_object $P7341, "1303923606.34", 0
    $P7340."load_module"("Regex", $P7341)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P7342, "ModuleLoader"
    nqp_get_sc_object $P7343, "1303923606.34", 0
    $P7342."load_module"("P6Regex", $P7343)
    nqp_get_sc_object $P7344, "1303923580.726", 6
    $P7345 = $P7344."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P7345, cur_sc
    nqp_set_sc_object "1303923606.34", 1, $P7345
    nqp_get_sc_object $P7346, "1303923606.34", 1
    nqp_get_sc_object $P7347, "1303923606.34", 0
    nqp_get_package_through_who $P7348, $P7347, "NQP"
    get_who $P7349, $P7348
    set $P7349["Grammar"], $P7346
    nqp_get_sc_object $P7350, "1303923606.34", 1
    set_hll_global ["NQP"], "Grammar", $P7350
    .const 'Sub' $P7351 = "12_1303923618.727" 
    $P7352 = $P7351."get_lexinfo"()
    nqp_get_sc_object $P7353, "1303923606.34", 1
    $P7352."set_static_lexpad_value"("$?PACKAGE", $P7353)
    .const 'Sub' $P7354 = "12_1303923618.727" 
    $P7355 = $P7354."get_lexinfo"()
    $P7355."finish_static_lexpad"()
    .const 'Sub' $P7356 = "12_1303923618.727" 
    $P7357 = $P7356."get_lexinfo"()
    nqp_get_sc_object $P7358, "1303923606.34", 1
    $P7357."set_static_lexpad_value"("$?CLASS", $P7358)
    .const 'Sub' $P7359 = "12_1303923618.727" 
    $P7360 = $P7359."get_lexinfo"()
    $P7360."finish_static_lexpad"()
    nqp_get_sc_object $P7361, "1303923606.34", 1
    get_how $P7362, $P7361
    nqp_get_sc_object $P7363, "1303923606.34", 1
    nqp_get_sc_object $P7364, "1303923588.442", 1
    $P7362."add_parent"($P7363, $P7364)
    nqp_get_sc_object $P7365, "1303923580.726", 6
    $P7366 = $P7365."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P7366, cur_sc
    nqp_set_sc_object "1303923606.34", 2, $P7366
    nqp_get_sc_object $P7367, "1303923606.34", 2
    nqp_get_sc_object $P7368, "1303923606.34", 0
    nqp_get_package_through_who $P7369, $P7368, "NQP"
    get_who $P7370, $P7369
    set $P7370["Regex"], $P7367
    nqp_get_sc_object $P7371, "1303923606.34", 2
    set_hll_global ["NQP"], "Regex", $P7371
    .const 'Sub' $P7372 = "385_1303923618.727" 
    $P7373 = $P7372."get_lexinfo"()
    nqp_get_sc_object $P7374, "1303923606.34", 2
    $P7373."set_static_lexpad_value"("$?PACKAGE", $P7374)
    .const 'Sub' $P7375 = "385_1303923618.727" 
    $P7376 = $P7375."get_lexinfo"()
    $P7376."finish_static_lexpad"()
    .const 'Sub' $P7377 = "385_1303923618.727" 
    $P7378 = $P7377."get_lexinfo"()
    nqp_get_sc_object $P7379, "1303923606.34", 2
    $P7378."set_static_lexpad_value"("$?CLASS", $P7379)
    .const 'Sub' $P7380 = "385_1303923618.727" 
    $P7381 = $P7380."get_lexinfo"()
    $P7381."finish_static_lexpad"()
    nqp_get_sc_object $P7382, "1303923606.34", 2
    get_how $P7383, $P7382
    nqp_get_sc_object $P7384, "1303923606.34", 2
    nqp_get_sc_object $P7385, "1303923599.428", 1
    $P7383."add_parent"($P7384, $P7385)
    nqp_get_sc_object $P7386, "1303923580.726", 6
    $P7387 = $P7386."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P7387, cur_sc
    nqp_set_sc_object "1303923606.34", 3, $P7387
    nqp_get_sc_object $P7388, "1303923606.34", 3
    nqp_get_sc_object $P7389, "1303923606.34", 0
    nqp_get_package_through_who $P7390, $P7389, "NQP"
    get_who $P7391, $P7390
    set $P7391["Actions"], $P7388
    nqp_get_sc_object $P7392, "1303923606.34", 3
    set_hll_global ["NQP"], "Actions", $P7392
    .const 'Sub' $P7393 = "407_1303923618.727" 
    $P7394 = $P7393."get_lexinfo"()
    nqp_get_sc_object $P7395, "1303923606.34", 3
    $P7394."set_static_lexpad_value"("$?PACKAGE", $P7395)
    .const 'Sub' $P7396 = "407_1303923618.727" 
    $P7397 = $P7396."get_lexinfo"()
    $P7397."finish_static_lexpad"()
    .const 'Sub' $P7398 = "407_1303923618.727" 
    $P7399 = $P7398."get_lexinfo"()
    nqp_get_sc_object $P7400, "1303923606.34", 3
    $P7399."set_static_lexpad_value"("$?CLASS", $P7400)
    .const 'Sub' $P7401 = "407_1303923618.727" 
    $P7402 = $P7401."get_lexinfo"()
    $P7402."finish_static_lexpad"()
    nqp_get_sc_object $P7403, "1303923606.34", 3
    get_how $P7404, $P7403
    nqp_get_sc_object $P7405, "1303923606.34", 3
    nqp_get_sc_object $P7406, "1303923588.442", 2
    $P7404."add_parent"($P7405, $P7406)
    nqp_get_sc_object $P7407, "1303923580.726", 6
    $P7408 = $P7407."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P7408, cur_sc
    nqp_set_sc_object "1303923606.34", 4, $P7408
    nqp_get_sc_object $P7409, "1303923606.34", 4
    nqp_get_sc_object $P7410, "1303923606.34", 0
    nqp_get_package_through_who $P7411, $P7410, "NQP"
    get_who $P7412, $P7411
    set $P7412["RegexActions"], $P7409
    nqp_get_sc_object $P7413, "1303923606.34", 4
    set_hll_global ["NQP"], "RegexActions", $P7413
    .const 'Sub' $P7414 = "578_1303923618.727" 
    $P7415 = $P7414."get_lexinfo"()
    nqp_get_sc_object $P7416, "1303923606.34", 4
    $P7415."set_static_lexpad_value"("$?PACKAGE", $P7416)
    .const 'Sub' $P7417 = "578_1303923618.727" 
    $P7418 = $P7417."get_lexinfo"()
    $P7418."finish_static_lexpad"()
    .const 'Sub' $P7419 = "578_1303923618.727" 
    $P7420 = $P7419."get_lexinfo"()
    nqp_get_sc_object $P7421, "1303923606.34", 4
    $P7420."set_static_lexpad_value"("$?CLASS", $P7421)
    .const 'Sub' $P7422 = "578_1303923618.727" 
    $P7423 = $P7422."get_lexinfo"()
    $P7423."finish_static_lexpad"()
    nqp_get_sc_object $P7424, "1303923606.34", 4
    get_how $P7425, $P7424
    nqp_get_sc_object $P7426, "1303923606.34", 4
    nqp_get_sc_object $P7427, "1303923599.428", 2
    $P7425."add_parent"($P7426, $P7427)
    nqp_get_sc_object $P7428, "1303923580.726", 6
    $P7429 = $P7428."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P7429, cur_sc
    nqp_set_sc_object "1303923606.34", 5, $P7429
    nqp_get_sc_object $P7430, "1303923606.34", 5
    nqp_get_sc_object $P7431, "1303923606.34", 0
    nqp_get_package_through_who $P7432, $P7431, "NQP"
    get_who $P7433, $P7432
    set $P7433["Compiler"], $P7430
    nqp_get_sc_object $P7434, "1303923606.34", 5
    set_hll_global ["NQP"], "Compiler", $P7434
    .const 'Sub' $P7435 = "587_1303923618.727" 
    $P7436 = $P7435."get_lexinfo"()
    nqp_get_sc_object $P7437, "1303923606.34", 5
    $P7436."set_static_lexpad_value"("$?PACKAGE", $P7437)
    .const 'Sub' $P7438 = "587_1303923618.727" 
    $P7439 = $P7438."get_lexinfo"()
    $P7439."finish_static_lexpad"()
    .const 'Sub' $P7440 = "587_1303923618.727" 
    $P7441 = $P7440."get_lexinfo"()
    nqp_get_sc_object $P7442, "1303923606.34", 5
    $P7441."set_static_lexpad_value"("$?CLASS", $P7442)
    .const 'Sub' $P7443 = "587_1303923618.727" 
    $P7444 = $P7443."get_lexinfo"()
    $P7444."finish_static_lexpad"()
    nqp_get_sc_object $P7445, "1303923606.34", 5
    get_how $P7446, $P7445
    nqp_get_sc_object $P7447, "1303923606.34", 5
    nqp_get_sc_object $P7448, "1303923588.442", 3
    $P7446."add_parent"($P7447, $P7448)
  if_7319_end:
    nqp_get_sc_object $P7514, "1303923606.34", 0
    set_hll_global "GLOBAL", $P7514
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1303923618.727") :outer("10_1303923618.727")
    .param pmc param_17
.annotate 'line', 2313
    .lex "@ARGS", param_17
.annotate 'line', 2315
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2321
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2315
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2316
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_591
    new $P25, "Undef"
  vivify_591:
    $P25."language"("nqp")
.annotate 'line', 2317
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_592
    new $P26, "Undef"
  vivify_592:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2318
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_593
    new $P31, "Undef"
  vivify_593:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2321
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_594
    new $P36, "Undef"
  vivify_594:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2322
    find_lex $P38, "@clo"
    unless_null $P38, vivify_595
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_595:
    $P38."push"("parsetrace")
.annotate 'line', 2323
    find_lex $P39, "@clo"
    unless_null $P39, vivify_596
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_596:
    $P39."push"("setting=s")
.annotate 'line', 2324
    find_lex $P40, "@clo"
    unless_null $P40, vivify_597
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_597:
    $P40."push"("setting-path=s")
.annotate 'line', 2325
    find_lex $P41, "@clo"
    unless_null $P41, vivify_598
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_598:
    $P41."push"("module-path=s")
.annotate 'line', 2328
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_599
    new $P42, "Undef"
  vivify_599:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_600
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_600:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2313
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block46"  :subid("12_1303923618.727") :outer("10_1303923618.727")
.annotate 'line', 9
    .const 'Sub' $P1936 = "384_1303923618.727" 
    capture_lex $P1936
    .const 'Sub' $P1923 = "383_1303923618.727" 
    capture_lex $P1923
    .const 'Sub' $P1917 = "381_1303923618.727" 
    capture_lex $P1917
    .const 'Sub' $P1911 = "379_1303923618.727" 
    capture_lex $P1911
    .const 'Sub' $P1905 = "377_1303923618.727" 
    capture_lex $P1905
    .const 'Sub' $P1899 = "375_1303923618.727" 
    capture_lex $P1899
    .const 'Sub' $P1887 = "372_1303923618.727" 
    capture_lex $P1887
    .const 'Sub' $P1880 = "370_1303923618.727" 
    capture_lex $P1880
    .const 'Sub' $P1873 = "368_1303923618.727" 
    capture_lex $P1873
    .const 'Sub' $P1866 = "366_1303923618.727" 
    capture_lex $P1866
    .const 'Sub' $P1859 = "364_1303923618.727" 
    capture_lex $P1859
    .const 'Sub' $P1853 = "362_1303923618.727" 
    capture_lex $P1853
    .const 'Sub' $P1846 = "360_1303923618.727" 
    capture_lex $P1846
    .const 'Sub' $P1839 = "358_1303923618.727" 
    capture_lex $P1839
    .const 'Sub' $P1832 = "356_1303923618.727" 
    capture_lex $P1832
    .const 'Sub' $P1825 = "354_1303923618.727" 
    capture_lex $P1825
    .const 'Sub' $P1818 = "352_1303923618.727" 
    capture_lex $P1818
    .const 'Sub' $P1811 = "350_1303923618.727" 
    capture_lex $P1811
    .const 'Sub' $P1804 = "348_1303923618.727" 
    capture_lex $P1804
    .const 'Sub' $P1797 = "346_1303923618.727" 
    capture_lex $P1797
    .const 'Sub' $P1790 = "344_1303923618.727" 
    capture_lex $P1790
    .const 'Sub' $P1783 = "342_1303923618.727" 
    capture_lex $P1783
    .const 'Sub' $P1776 = "340_1303923618.727" 
    capture_lex $P1776
    .const 'Sub' $P1769 = "338_1303923618.727" 
    capture_lex $P1769
    .const 'Sub' $P1762 = "336_1303923618.727" 
    capture_lex $P1762
    .const 'Sub' $P1755 = "334_1303923618.727" 
    capture_lex $P1755
    .const 'Sub' $P1748 = "332_1303923618.727" 
    capture_lex $P1748
    .const 'Sub' $P1741 = "330_1303923618.727" 
    capture_lex $P1741
    .const 'Sub' $P1734 = "328_1303923618.727" 
    capture_lex $P1734
    .const 'Sub' $P1727 = "326_1303923618.727" 
    capture_lex $P1727
    .const 'Sub' $P1720 = "324_1303923618.727" 
    capture_lex $P1720
    .const 'Sub' $P1713 = "322_1303923618.727" 
    capture_lex $P1713
    .const 'Sub' $P1706 = "320_1303923618.727" 
    capture_lex $P1706
    .const 'Sub' $P1699 = "318_1303923618.727" 
    capture_lex $P1699
    .const 'Sub' $P1692 = "316_1303923618.727" 
    capture_lex $P1692
    .const 'Sub' $P1685 = "314_1303923618.727" 
    capture_lex $P1685
    .const 'Sub' $P1678 = "312_1303923618.727" 
    capture_lex $P1678
    .const 'Sub' $P1671 = "310_1303923618.727" 
    capture_lex $P1671
    .const 'Sub' $P1664 = "308_1303923618.727" 
    capture_lex $P1664
    .const 'Sub' $P1657 = "306_1303923618.727" 
    capture_lex $P1657
    .const 'Sub' $P1650 = "304_1303923618.727" 
    capture_lex $P1650
    .const 'Sub' $P1644 = "302_1303923618.727" 
    capture_lex $P1644
    .const 'Sub' $P1637 = "300_1303923618.727" 
    capture_lex $P1637
    .const 'Sub' $P1630 = "298_1303923618.727" 
    capture_lex $P1630
    .const 'Sub' $P1623 = "296_1303923618.727" 
    capture_lex $P1623
    .const 'Sub' $P1616 = "294_1303923618.727" 
    capture_lex $P1616
    .const 'Sub' $P1609 = "292_1303923618.727" 
    capture_lex $P1609
    .const 'Sub' $P1602 = "290_1303923618.727" 
    capture_lex $P1602
    .const 'Sub' $P1595 = "288_1303923618.727" 
    capture_lex $P1595
    .const 'Sub' $P1589 = "286_1303923618.727" 
    capture_lex $P1589
    .const 'Sub' $P1583 = "284_1303923618.727" 
    capture_lex $P1583
    .const 'Sub' $P1578 = "282_1303923618.727" 
    capture_lex $P1578
    .const 'Sub' $P1572 = "280_1303923618.727" 
    capture_lex $P1572
    .const 'Sub' $P1566 = "278_1303923618.727" 
    capture_lex $P1566
    .const 'Sub' $P1561 = "276_1303923618.727" 
    capture_lex $P1561
    .const 'Sub' $P1556 = "274_1303923618.727" 
    capture_lex $P1556
    .const 'Sub' $P1548 = "272_1303923618.727" 
    capture_lex $P1548
    .const 'Sub' $P1539 = "270_1303923618.727" 
    capture_lex $P1539
    .const 'Sub' $P1534 = "268_1303923618.727" 
    capture_lex $P1534
    .const 'Sub' $P1529 = "266_1303923618.727" 
    capture_lex $P1529
    .const 'Sub' $P1524 = "264_1303923618.727" 
    capture_lex $P1524
    .const 'Sub' $P1516 = "262_1303923618.727" 
    capture_lex $P1516
    .const 'Sub' $P1508 = "260_1303923618.727" 
    capture_lex $P1508
    .const 'Sub' $P1503 = "258_1303923618.727" 
    capture_lex $P1503
    .const 'Sub' $P1498 = "256_1303923618.727" 
    capture_lex $P1498
    .const 'Sub' $P1493 = "254_1303923618.727" 
    capture_lex $P1493
    .const 'Sub' $P1487 = "252_1303923618.727" 
    capture_lex $P1487
    .const 'Sub' $P1480 = "250_1303923618.727" 
    capture_lex $P1480
    .const 'Sub' $P1473 = "248_1303923618.727" 
    capture_lex $P1473
    .const 'Sub' $P1466 = "246_1303923618.727" 
    capture_lex $P1466
    .const 'Sub' $P1459 = "244_1303923618.727" 
    capture_lex $P1459
    .const 'Sub' $P1454 = "242_1303923618.727" 
    capture_lex $P1454
    .const 'Sub' $P1449 = "240_1303923618.727" 
    capture_lex $P1449
    .const 'Sub' $P1435 = "236_1303923618.727" 
    capture_lex $P1435
    .const 'Sub' $P1427 = "234_1303923618.727" 
    capture_lex $P1427
    .const 'Sub' $P1421 = "232_1303923618.727" 
    capture_lex $P1421
    .const 'Sub' $P1414 = "230_1303923618.727" 
    capture_lex $P1414
    .const 'Sub' $P1408 = "228_1303923618.727" 
    capture_lex $P1408
    .const 'Sub' $P1392 = "225_1303923618.727" 
    capture_lex $P1392
    .const 'Sub' $P1384 = "223_1303923618.727" 
    capture_lex $P1384
    .const 'Sub' $P1376 = "221_1303923618.727" 
    capture_lex $P1376
    .const 'Sub' $P1370 = "219_1303923618.727" 
    capture_lex $P1370
    .const 'Sub' $P1364 = "217_1303923618.727" 
    capture_lex $P1364
    .const 'Sub' $P1348 = "213_1303923618.727" 
    capture_lex $P1348
    .const 'Sub' $P1307 = "211_1303923618.727" 
    capture_lex $P1307
    .const 'Sub' $P1296 = "209_1303923618.727" 
    capture_lex $P1296
    .const 'Sub' $P1282 = "205_1303923618.727" 
    capture_lex $P1282
    .const 'Sub' $P1273 = "203_1303923618.727" 
    capture_lex $P1273
    .const 'Sub' $P1267 = "201_1303923618.727" 
    capture_lex $P1267
    .const 'Sub' $P1257 = "199_1303923618.727" 
    capture_lex $P1257
    .const 'Sub' $P1242 = "197_1303923618.727" 
    capture_lex $P1242
    .const 'Sub' $P1226 = "194_1303923618.727" 
    capture_lex $P1226
    .const 'Sub' $P1218 = "192_1303923618.727" 
    capture_lex $P1218
    .const 'Sub' $P1208 = "190_1303923618.727" 
    capture_lex $P1208
    .const 'Sub' $P1198 = "188_1303923618.727" 
    capture_lex $P1198
    .const 'Sub' $P1177 = "183_1303923618.727" 
    capture_lex $P1177
    .const 'Sub' $P1133 = "180_1303923618.727" 
    capture_lex $P1133
    .const 'Sub' $P1099 = "178_1303923618.727" 
    capture_lex $P1099
    .const 'Sub' $P1092 = "176_1303923618.727" 
    capture_lex $P1092
    .const 'Sub' $P1085 = "174_1303923618.727" 
    capture_lex $P1085
    .const 'Sub' $P1058 = "169_1303923618.727" 
    capture_lex $P1058
    .const 'Sub' $P1050 = "167_1303923618.727" 
    capture_lex $P1050
    .const 'Sub' $P1044 = "165_1303923618.727" 
    capture_lex $P1044
    .const 'Sub' $P1028 = "163_1303923618.727" 
    capture_lex $P1028
    .const 'Sub' $P1021 = "161_1303923618.727" 
    capture_lex $P1021
    .const 'Sub' $P1014 = "159_1303923618.727" 
    capture_lex $P1014
    .const 'Sub' $P1007 = "157_1303923618.727" 
    capture_lex $P1007
    .const 'Sub' $P829 = "152_1303923618.727" 
    capture_lex $P829
    .const 'Sub' $P810 = "150_1303923618.727" 
    capture_lex $P810
    .const 'Sub' $P791 = "148_1303923618.727" 
    capture_lex $P791
    .const 'Sub' $P772 = "146_1303923618.727" 
    capture_lex $P772
    .const 'Sub' $P753 = "144_1303923618.727" 
    capture_lex $P753
    .const 'Sub' $P734 = "142_1303923618.727" 
    capture_lex $P734
    .const 'Sub' $P715 = "140_1303923618.727" 
    capture_lex $P715
    .const 'Sub' $P704 = "136_1303923618.727" 
    capture_lex $P704
    .const 'Sub' $P699 = "134_1303923618.727" 
    capture_lex $P699
    .const 'Sub' $P687 = "132_1303923618.727" 
    capture_lex $P687
    .const 'Sub' $P675 = "130_1303923618.727" 
    capture_lex $P675
    .const 'Sub' $P668 = "128_1303923618.727" 
    capture_lex $P668
    .const 'Sub' $P663 = "126_1303923618.727" 
    capture_lex $P663
    .const 'Sub' $P657 = "124_1303923618.727" 
    capture_lex $P657
    .const 'Sub' $P651 = "122_1303923618.727" 
    capture_lex $P651
    .const 'Sub' $P636 = "118_1303923618.727" 
    capture_lex $P636
    .const 'Sub' $P630 = "116_1303923618.727" 
    capture_lex $P630
    .const 'Sub' $P624 = "114_1303923618.727" 
    capture_lex $P624
    .const 'Sub' $P618 = "112_1303923618.727" 
    capture_lex $P618
    .const 'Sub' $P612 = "110_1303923618.727" 
    capture_lex $P612
    .const 'Sub' $P606 = "108_1303923618.727" 
    capture_lex $P606
    .const 'Sub' $P600 = "106_1303923618.727" 
    capture_lex $P600
    .const 'Sub' $P591 = "104_1303923618.727" 
    capture_lex $P591
    .const 'Sub' $P582 = "102_1303923618.727" 
    capture_lex $P582
    .const 'Sub' $P573 = "100_1303923618.727" 
    capture_lex $P573
    .const 'Sub' $P558 = "96_1303923618.727" 
    capture_lex $P558
    .const 'Sub' $P549 = "94_1303923618.727" 
    capture_lex $P549
    .const 'Sub' $P537 = "90_1303923618.727" 
    capture_lex $P537
    .const 'Sub' $P530 = "88_1303923618.727" 
    capture_lex $P530
    .const 'Sub' $P523 = "86_1303923618.727" 
    capture_lex $P523
    .const 'Sub' $P509 = "82_1303923618.727" 
    capture_lex $P509
    .const 'Sub' $P501 = "80_1303923618.727" 
    capture_lex $P501
    .const 'Sub' $P493 = "78_1303923618.727" 
    capture_lex $P493
    .const 'Sub' $P473 = "76_1303923618.727" 
    capture_lex $P473
    .const 'Sub' $P464 = "74_1303923618.727" 
    capture_lex $P464
    .const 'Sub' $P446 = "71_1303923618.727" 
    capture_lex $P446
    .const 'Sub' $P428 = "69_1303923618.727" 
    capture_lex $P428
    .const 'Sub' $P420 = "67_1303923618.727" 
    capture_lex $P420
    .const 'Sub' $P409 = "63_1303923618.727" 
    capture_lex $P409
    .const 'Sub' $P404 = "61_1303923618.727" 
    capture_lex $P404
    .const 'Sub' $P393 = "57_1303923618.727" 
    capture_lex $P393
    .const 'Sub' $P388 = "55_1303923618.727" 
    capture_lex $P388
    .const 'Sub' $P383 = "53_1303923618.727" 
    capture_lex $P383
    .const 'Sub' $P378 = "51_1303923618.727" 
    capture_lex $P378
    .const 'Sub' $P373 = "49_1303923618.727" 
    capture_lex $P373
    .const 'Sub' $P363 = "47_1303923618.727" 
    capture_lex $P363
    .const 'Sub' $P356 = "45_1303923618.727" 
    capture_lex $P356
    .const 'Sub' $P350 = "43_1303923618.727" 
    capture_lex $P350
    .const 'Sub' $P342 = "41_1303923618.727" 
    capture_lex $P342
    .const 'Sub' $P336 = "39_1303923618.727" 
    capture_lex $P336
    .const 'Sub' $P330 = "37_1303923618.727" 
    capture_lex $P330
    .const 'Sub' $P315 = "34_1303923618.727" 
    capture_lex $P315
    .const 'Sub' $P301 = "32_1303923618.727" 
    capture_lex $P301
    .const 'Sub' $P278 = "30_1303923618.727" 
    capture_lex $P278
    .const 'Sub' $P239 = "27_1303923618.727" 
    capture_lex $P239
    .const 'Sub' $P224 = "24_1303923618.727" 
    capture_lex $P224
    .const 'Sub' $P213 = "22_1303923618.727" 
    capture_lex $P213
    .const 'Sub' $P201 = "20_1303923618.727" 
    capture_lex $P201
    .const 'Sub' $P193 = "18_1303923618.727" 
    capture_lex $P193
    .const 'Sub' $P186 = "16_1303923618.727" 
    capture_lex $P186
    .const 'Sub' $P179 = "14_1303923618.727" 
    capture_lex $P179
    .const 'Sub' $P110 = "13_1303923618.727" 
    capture_lex $P110
    .lex "$?PACKAGE", $P48
    .lex "$?CLASS", $P49
.annotate 'line', 609
    get_hll_global $P50, "GLOBAL"
    nqp_get_package_through_who $P51, $P50, "NQP"
    get_who $P52, $P51
    set $P53, $P52["Grammar"]
    $P53."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 610
    get_hll_global $P54, "GLOBAL"
    nqp_get_package_through_who $P55, $P54, "NQP"
    get_who $P56, $P55
    set $P57, $P56["Grammar"]
    $P57."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 611
    get_hll_global $P58, "GLOBAL"
    nqp_get_package_through_who $P59, $P58, "NQP"
    get_who $P60, $P59
    set $P61, $P60["Grammar"]
    $P61."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 612
    get_hll_global $P62, "GLOBAL"
    nqp_get_package_through_who $P63, $P62, "NQP"
    get_who $P64, $P63
    set $P65, $P64["Grammar"]
    $P65."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 613
    get_hll_global $P66, "GLOBAL"
    nqp_get_package_through_who $P67, $P66, "NQP"
    get_who $P68, $P67
    set $P69, $P68["Grammar"]
    $P69."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 614
    get_hll_global $P70, "GLOBAL"
    nqp_get_package_through_who $P71, $P70, "NQP"
    get_who $P72, $P71
    set $P73, $P72["Grammar"]
    $P73."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 615
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "NQP"
    get_who $P76, $P75
    set $P77, $P76["Grammar"]
    $P77."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 616
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "NQP"
    get_who $P80, $P79
    set $P81, $P80["Grammar"]
    $P81."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 617
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "NQP"
    get_who $P84, $P83
    set $P85, $P84["Grammar"]
    $P85."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 618
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "NQP"
    get_who $P88, $P87
    set $P89, $P88["Grammar"]
    $P89."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 619
    get_hll_global $P90, "GLOBAL"
    nqp_get_package_through_who $P91, $P90, "NQP"
    get_who $P92, $P91
    set $P93, $P92["Grammar"]
    $P93."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 620
    get_hll_global $P94, "GLOBAL"
    nqp_get_package_through_who $P95, $P94, "NQP"
    get_who $P96, $P95
    set $P97, $P96["Grammar"]
    $P97."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 621
    get_hll_global $P98, "GLOBAL"
    nqp_get_package_through_who $P99, $P98, "NQP"
    get_who $P100, $P99
    set $P101, $P100["Grammar"]
    $P101."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 622
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P105."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 623
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "NQP"
    get_who $P108, $P107
    set $P109, $P108["Grammar"]
    $P109."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 722
    .const 'Sub' $P1923 = "383_1303923618.727" 
    newclosure $P1934, $P1923
.annotate 'line', 9
    .return ($P1934)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post601") :outer("12_1303923618.727")
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1303923618.727" 
    .local pmc block
    set block, $P47
    .const 'Sub' $P1936 = "384_1303923618.727" 
    capture_lex $P1936
    $P1936()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1935"  :anon :subid("384_1303923618.727") :outer("12_1303923618.727")
.annotate 'line', 9
    nqp_get_sc_object $P1937, "1303923606.34", 1
    .local pmc type_obj
    set type_obj, $P1937
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "13_1303923618.727" 
    $P1938."add_method"(type_obj, "TOP", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "14_1303923618.727" 
    $P1940."add_method"(type_obj, "identifier", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__identifier"
    $P1942."add_method"(type_obj, "!PREFIX__identifier", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "16_1303923618.727" 
    $P1944."add_method"(type_obj, "name", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__name"
    $P1946."add_method"(type_obj, "!PREFIX__name", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "18_1303923618.727" 
    $P1948."add_method"(type_obj, "deflongname", $P1949)
    get_how $P1950, type_obj
    get_global $P1951, "!PREFIX__deflongname"
    $P1950."add_method"(type_obj, "!PREFIX__deflongname", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "20_1303923618.727" 
    $P1952."add_method"(type_obj, "ENDSTMT", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__ENDSTMT"
    $P1954."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "22_1303923618.727" 
    $P1956."add_method"(type_obj, "ws", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__ws"
    $P1958."add_method"(type_obj, "!PREFIX__ws", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "24_1303923618.727" 
    $P1960."add_method"(type_obj, "unv", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__unv"
    $P1962."add_method"(type_obj, "!PREFIX__unv", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "27_1303923618.727" 
    $P1964."add_method"(type_obj, "pod_comment", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__pod_comment"
    $P1966."add_method"(type_obj, "!PREFIX__pod_comment", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "30_1303923618.727" 
    $P1968."add_method"(type_obj, "comp_unit", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__comp_unit"
    $P1970."add_method"(type_obj, "!PREFIX__comp_unit", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "32_1303923618.727" 
    $P1972."add_method"(type_obj, "statementlist", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__statementlist"
    $P1974."add_method"(type_obj, "!PREFIX__statementlist", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "34_1303923618.727" 
    $P1976."add_method"(type_obj, "statement", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__statement"
    $P1978."add_method"(type_obj, "!PREFIX__statement", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "37_1303923618.727" 
    $P1980."add_method"(type_obj, "eat_terminator", $P1981)
    get_how $P1982, type_obj
    get_global $P1983, "!PREFIX__eat_terminator"
    $P1982."add_method"(type_obj, "!PREFIX__eat_terminator", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "39_1303923618.727" 
    $P1984."add_method"(type_obj, "xblock", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__xblock"
    $P1986."add_method"(type_obj, "!PREFIX__xblock", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "41_1303923618.727" 
    $P1988."add_method"(type_obj, "pblock", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__pblock"
    $P1990."add_method"(type_obj, "!PREFIX__pblock", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "43_1303923618.727" 
    $P1992."add_method"(type_obj, "lambda", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__lambda"
    $P1994."add_method"(type_obj, "!PREFIX__lambda", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "45_1303923618.727" 
    $P1996."add_method"(type_obj, "block", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__block"
    $P1998."add_method"(type_obj, "!PREFIX__block", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "47_1303923618.727" 
    $P2000."add_method"(type_obj, "blockoid", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__blockoid"
    $P2002."add_method"(type_obj, "!PREFIX__blockoid", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "49_1303923618.727" 
    $P2004."add_method"(type_obj, "newpad", $P2005)
    get_how $P2006, type_obj
    get_global $P2007, "!PREFIX__newpad"
    $P2006."add_method"(type_obj, "!PREFIX__newpad", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "51_1303923618.727" 
    $P2008."add_method"(type_obj, "outerctx", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__outerctx"
    $P2010."add_method"(type_obj, "!PREFIX__outerctx", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "53_1303923618.727" 
    $P2012."add_method"(type_obj, "GLOBALish", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__GLOBALish"
    $P2014."add_method"(type_obj, "!PREFIX__GLOBALish", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "55_1303923618.727" 
    $P2016."add_method"(type_obj, "finishpad", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__finishpad"
    $P2018."add_method"(type_obj, "!PREFIX__finishpad", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "57_1303923618.727" 
    $P2020."add_method"(type_obj, "you_are_here", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__you_are_here"
    $P2022."add_method"(type_obj, "!PREFIX__you_are_here", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "59_1303923618.727" 
    $P2024."add_method"(type_obj, "terminator", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "60_1303923618.727" 
    $P2026."add_method"(type_obj, "!PREFIX__terminator", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "61_1303923618.727" 
    $P2028."add_method"(type_obj, "terminator:sym<;>", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__terminator:sym<;>"
    $P2030."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "63_1303923618.727" 
    $P2032."add_method"(type_obj, "terminator:sym<}>", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__terminator:sym<}>"
    $P2034."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "65_1303923618.727" 
    $P2036."add_method"(type_obj, "statement_control", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "66_1303923618.727" 
    $P2038."add_method"(type_obj, "!PREFIX__statement_control", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "67_1303923618.727" 
    $P2040."add_method"(type_obj, "statement_control:sym<use>", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__statement_control:sym<use>"
    $P2042."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "69_1303923618.727" 
    $P2044."add_method"(type_obj, "statement_control:sym<if>", $P2045)
    get_how $P2046, type_obj
    get_global $P2047, "!PREFIX__statement_control:sym<if>"
    $P2046."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "71_1303923618.727" 
    $P2048."add_method"(type_obj, "statement_control:sym<unless>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__statement_control:sym<unless>"
    $P2050."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "74_1303923618.727" 
    $P2052."add_method"(type_obj, "statement_control:sym<while>", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__statement_control:sym<while>"
    $P2054."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "76_1303923618.727" 
    $P2056."add_method"(type_obj, "statement_control:sym<repeat>", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__statement_control:sym<repeat>"
    $P2058."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "78_1303923618.727" 
    $P2060."add_method"(type_obj, "statement_control:sym<for>", $P2061)
    get_how $P2062, type_obj
    get_global $P2063, "!PREFIX__statement_control:sym<for>"
    $P2062."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "80_1303923618.727" 
    $P2064."add_method"(type_obj, "statement_control:sym<CATCH>", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__statement_control:sym<CATCH>"
    $P2066."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "82_1303923618.727" 
    $P2068."add_method"(type_obj, "statement_control:sym<CONTROL>", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__statement_control:sym<CONTROL>"
    $P2070."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "84_1303923618.727" 
    $P2072."add_method"(type_obj, "statement_prefix", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "85_1303923618.727" 
    $P2074."add_method"(type_obj, "!PREFIX__statement_prefix", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "86_1303923618.727" 
    $P2076."add_method"(type_obj, "statement_prefix:sym<INIT>", $P2077)
    get_how $P2078, type_obj
    get_global $P2079, "!PREFIX__statement_prefix:sym<INIT>"
    $P2078."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "88_1303923618.727" 
    $P2080."add_method"(type_obj, "statement_prefix:sym<try>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__statement_prefix:sym<try>"
    $P2082."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "90_1303923618.727" 
    $P2084."add_method"(type_obj, "blorst", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__blorst"
    $P2086."add_method"(type_obj, "!PREFIX__blorst", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "92_1303923618.727" 
    $P2088."add_method"(type_obj, "statement_mod_cond", $P2089)
    get_how $P2090, type_obj
    .const 'Sub' $P2091 = "93_1303923618.727" 
    $P2090."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "94_1303923618.727" 
    $P2092."add_method"(type_obj, "statement_mod_cond:sym<if>", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__statement_mod_cond:sym<if>"
    $P2094."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "96_1303923618.727" 
    $P2096."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__statement_mod_cond:sym<unless>"
    $P2098."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "98_1303923618.727" 
    $P2100."add_method"(type_obj, "statement_mod_loop", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "99_1303923618.727" 
    $P2102."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "100_1303923618.727" 
    $P2104."add_method"(type_obj, "statement_mod_loop:sym<while>", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__statement_mod_loop:sym<while>"
    $P2106."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "102_1303923618.727" 
    $P2108."add_method"(type_obj, "statement_mod_loop:sym<until>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__statement_mod_loop:sym<until>"
    $P2110."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "104_1303923618.727" 
    $P2112."add_method"(type_obj, "statement_mod_loop:sym<for>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__statement_mod_loop:sym<for>"
    $P2114."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "106_1303923618.727" 
    $P2116."add_method"(type_obj, "term:sym<fatarrow>", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__term:sym<fatarrow>"
    $P2118."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "108_1303923618.727" 
    $P2120."add_method"(type_obj, "term:sym<colonpair>", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__term:sym<colonpair>"
    $P2122."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "110_1303923618.727" 
    $P2124."add_method"(type_obj, "term:sym<variable>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__term:sym<variable>"
    $P2126."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "112_1303923618.727" 
    $P2128."add_method"(type_obj, "term:sym<package_declarator>", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__term:sym<package_declarator>"
    $P2130."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "114_1303923618.727" 
    $P2132."add_method"(type_obj, "term:sym<scope_declarator>", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__term:sym<scope_declarator>"
    $P2134."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "116_1303923618.727" 
    $P2136."add_method"(type_obj, "term:sym<routine_declarator>", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__term:sym<routine_declarator>"
    $P2138."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "118_1303923618.727" 
    $P2140."add_method"(type_obj, "term:sym<multi_declarator>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__term:sym<multi_declarator>"
    $P2142."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "122_1303923618.727" 
    $P2144."add_method"(type_obj, "term:sym<regex_declarator>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__term:sym<regex_declarator>"
    $P2146."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "124_1303923618.727" 
    $P2148."add_method"(type_obj, "term:sym<statement_prefix>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__term:sym<statement_prefix>"
    $P2150."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "126_1303923618.727" 
    $P2152."add_method"(type_obj, "term:sym<lambda>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__term:sym<lambda>"
    $P2154."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "128_1303923618.727" 
    $P2156."add_method"(type_obj, "fatarrow", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__fatarrow"
    $P2158."add_method"(type_obj, "!PREFIX__fatarrow", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "130_1303923618.727" 
    $P2160."add_method"(type_obj, "colonpair", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__colonpair"
    $P2162."add_method"(type_obj, "!PREFIX__colonpair", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "132_1303923618.727" 
    $P2164."add_method"(type_obj, "variable", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__variable"
    $P2166."add_method"(type_obj, "!PREFIX__variable", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "134_1303923618.727" 
    $P2168."add_method"(type_obj, "sigil", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__sigil"
    $P2170."add_method"(type_obj, "!PREFIX__sigil", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "136_1303923618.727" 
    $P2172."add_method"(type_obj, "twigil", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__twigil"
    $P2174."add_method"(type_obj, "!PREFIX__twigil", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "138_1303923618.727" 
    $P2176."add_method"(type_obj, "package_declarator", $P2177)
    get_how $P2178, type_obj
    .const 'Sub' $P2179 = "139_1303923618.727" 
    $P2178."add_method"(type_obj, "!PREFIX__package_declarator", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "140_1303923618.727" 
    $P2180."add_method"(type_obj, "package_declarator:sym<module>", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__package_declarator:sym<module>"
    $P2182."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "142_1303923618.727" 
    $P2184."add_method"(type_obj, "package_declarator:sym<knowhow>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__package_declarator:sym<knowhow>"
    $P2186."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "144_1303923618.727" 
    $P2188."add_method"(type_obj, "package_declarator:sym<class>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__package_declarator:sym<class>"
    $P2190."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "146_1303923618.727" 
    $P2192."add_method"(type_obj, "package_declarator:sym<grammar>", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__package_declarator:sym<grammar>"
    $P2194."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "148_1303923618.727" 
    $P2196."add_method"(type_obj, "package_declarator:sym<role>", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__package_declarator:sym<role>"
    $P2198."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "150_1303923618.727" 
    $P2200."add_method"(type_obj, "package_declarator:sym<native>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__package_declarator:sym<native>"
    $P2202."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "152_1303923618.727" 
    $P2204."add_method"(type_obj, "package_def", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__package_def"
    $P2206."add_method"(type_obj, "!PREFIX__package_def", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "155_1303923618.727" 
    $P2208."add_method"(type_obj, "scope_declarator", $P2209)
    get_how $P2210, type_obj
    .const 'Sub' $P2211 = "156_1303923618.727" 
    $P2210."add_method"(type_obj, "!PREFIX__scope_declarator", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "157_1303923618.727" 
    $P2212."add_method"(type_obj, "scope_declarator:sym<my>", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__scope_declarator:sym<my>"
    $P2214."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "159_1303923618.727" 
    $P2216."add_method"(type_obj, "scope_declarator:sym<our>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__scope_declarator:sym<our>"
    $P2218."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "161_1303923618.727" 
    $P2220."add_method"(type_obj, "scope_declarator:sym<has>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__scope_declarator:sym<has>"
    $P2222."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "163_1303923618.727" 
    $P2224."add_method"(type_obj, "scoped", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__scoped"
    $P2226."add_method"(type_obj, "!PREFIX__scoped", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "165_1303923618.727" 
    $P2228."add_method"(type_obj, "typename", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__typename"
    $P2230."add_method"(type_obj, "!PREFIX__typename", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "167_1303923618.727" 
    $P2232."add_method"(type_obj, "declarator", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__declarator"
    $P2234."add_method"(type_obj, "!PREFIX__declarator", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "169_1303923618.727" 
    $P2236."add_method"(type_obj, "variable_declarator", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__variable_declarator"
    $P2238."add_method"(type_obj, "!PREFIX__variable_declarator", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "172_1303923618.727" 
    $P2240."add_method"(type_obj, "routine_declarator", $P2241)
    get_how $P2242, type_obj
    .const 'Sub' $P2243 = "173_1303923618.727" 
    $P2242."add_method"(type_obj, "!PREFIX__routine_declarator", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "174_1303923618.727" 
    $P2244."add_method"(type_obj, "routine_declarator:sym<sub>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__routine_declarator:sym<sub>"
    $P2246."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "176_1303923618.727" 
    $P2248."add_method"(type_obj, "routine_declarator:sym<method>", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__routine_declarator:sym<method>"
    $P2250."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "178_1303923618.727" 
    $P2252."add_method"(type_obj, "routine_def", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__routine_def"
    $P2254."add_method"(type_obj, "!PREFIX__routine_def", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "180_1303923618.727" 
    $P2256."add_method"(type_obj, "method_def", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__method_def"
    $P2258."add_method"(type_obj, "!PREFIX__method_def", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "183_1303923618.727" 
    $P2260."add_method"(type_obj, "onlystar", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__onlystar"
    $P2262."add_method"(type_obj, "!PREFIX__onlystar", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "186_1303923618.727" 
    $P2264."add_method"(type_obj, "multi_declarator", $P2265)
    get_how $P2266, type_obj
    .const 'Sub' $P2267 = "187_1303923618.727" 
    $P2266."add_method"(type_obj, "!PREFIX__multi_declarator", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "188_1303923618.727" 
    $P2268."add_method"(type_obj, "multi_declarator:sym<multi>", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__multi_declarator:sym<multi>"
    $P2270."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "190_1303923618.727" 
    $P2272."add_method"(type_obj, "multi_declarator:sym<proto>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__multi_declarator:sym<proto>"
    $P2274."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "192_1303923618.727" 
    $P2276."add_method"(type_obj, "multi_declarator:sym<null>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__multi_declarator:sym<null>"
    $P2278."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "194_1303923618.727" 
    $P2280."add_method"(type_obj, "signature", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__signature"
    $P2282."add_method"(type_obj, "!PREFIX__signature", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "197_1303923618.727" 
    $P2284."add_method"(type_obj, "parameter", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__parameter"
    $P2286."add_method"(type_obj, "!PREFIX__parameter", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "199_1303923618.727" 
    $P2288."add_method"(type_obj, "param_var", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__param_var"
    $P2290."add_method"(type_obj, "!PREFIX__param_var", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "201_1303923618.727" 
    $P2292."add_method"(type_obj, "named_param", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__named_param"
    $P2294."add_method"(type_obj, "!PREFIX__named_param", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "203_1303923618.727" 
    $P2296."add_method"(type_obj, "default_value", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__default_value"
    $P2298."add_method"(type_obj, "!PREFIX__default_value", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "205_1303923618.727" 
    $P2300."add_method"(type_obj, "trait", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__trait"
    $P2302."add_method"(type_obj, "!PREFIX__trait", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "207_1303923618.727" 
    $P2304."add_method"(type_obj, "trait_mod", $P2305)
    get_how $P2306, type_obj
    .const 'Sub' $P2307 = "208_1303923618.727" 
    $P2306."add_method"(type_obj, "!PREFIX__trait_mod", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "209_1303923618.727" 
    $P2308."add_method"(type_obj, "trait_mod:sym<is>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__trait_mod:sym<is>"
    $P2310."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "211_1303923618.727" 
    $P2312."add_method"(type_obj, "regex_declarator", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__regex_declarator"
    $P2314."add_method"(type_obj, "!PREFIX__regex_declarator", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "213_1303923618.727" 
    $P2316."add_method"(type_obj, "dotty", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__dotty"
    $P2318."add_method"(type_obj, "!PREFIX__dotty", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "215_1303923618.727" 
    $P2320."add_method"(type_obj, "term", $P2321)
    get_how $P2322, type_obj
    .const 'Sub' $P2323 = "216_1303923618.727" 
    $P2322."add_method"(type_obj, "!PREFIX__term", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "217_1303923618.727" 
    $P2324."add_method"(type_obj, "term:sym<self>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__term:sym<self>"
    $P2326."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "219_1303923618.727" 
    $P2328."add_method"(type_obj, "term:sym<identifier>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__term:sym<identifier>"
    $P2330."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "221_1303923618.727" 
    $P2332."add_method"(type_obj, "term:sym<name>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__term:sym<name>"
    $P2334."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "223_1303923618.727" 
    $P2336."add_method"(type_obj, "term:sym<pir::op>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__term:sym<pir::op>"
    $P2338."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "225_1303923618.727" 
    $P2340."add_method"(type_obj, "term:sym<onlystar>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__term:sym<onlystar>"
    $P2342."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "228_1303923618.727" 
    $P2344."add_method"(type_obj, "args", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__args"
    $P2346."add_method"(type_obj, "!PREFIX__args", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "230_1303923618.727" 
    $P2348."add_method"(type_obj, "arglist", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__arglist"
    $P2350."add_method"(type_obj, "!PREFIX__arglist", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "232_1303923618.727" 
    $P2352."add_method"(type_obj, "term:sym<value>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__term:sym<value>"
    $P2354."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "234_1303923618.727" 
    $P2356."add_method"(type_obj, "value", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__value"
    $P2358."add_method"(type_obj, "!PREFIX__value", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "236_1303923618.727" 
    $P2360."add_method"(type_obj, "number", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__number"
    $P2362."add_method"(type_obj, "!PREFIX__number", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "238_1303923618.727" 
    $P2364."add_method"(type_obj, "quote", $P2365)
    get_how $P2366, type_obj
    .const 'Sub' $P2367 = "239_1303923618.727" 
    $P2366."add_method"(type_obj, "!PREFIX__quote", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "240_1303923618.727" 
    $P2368."add_method"(type_obj, "quote:sym<apos>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__quote:sym<apos>"
    $P2370."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "242_1303923618.727" 
    $P2372."add_method"(type_obj, "quote:sym<dblq>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__quote:sym<dblq>"
    $P2374."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "244_1303923618.727" 
    $P2376."add_method"(type_obj, "quote:sym<q>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__quote:sym<q>"
    $P2378."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "246_1303923618.727" 
    $P2380."add_method"(type_obj, "quote:sym<qq>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__quote:sym<qq>"
    $P2382."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "248_1303923618.727" 
    $P2384."add_method"(type_obj, "quote:sym<Q>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__quote:sym<Q>"
    $P2386."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "250_1303923618.727" 
    $P2388."add_method"(type_obj, "quote:sym<Q:PIR>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__quote:sym<Q:PIR>"
    $P2390."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "252_1303923618.727" 
    $P2392."add_method"(type_obj, "quote:sym</ />", $P2393)
    get_how $P2394, type_obj
    get_global $P2395, "!PREFIX__quote:sym</ />"
    $P2394."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2395)
    get_how $P2396, type_obj
    .const 'Sub' $P2397 = "254_1303923618.727" 
    $P2396."add_method"(type_obj, "quote_escape:sym<$>", $P2397)
    get_how $P2398, type_obj
    get_global $P2399, "!PREFIX__quote_escape:sym<$>"
    $P2398."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2399)
    get_how $P2400, type_obj
    .const 'Sub' $P2401 = "256_1303923618.727" 
    $P2400."add_method"(type_obj, "quote_escape:sym<{ }>", $P2401)
    get_how $P2402, type_obj
    get_global $P2403, "!PREFIX__quote_escape:sym<{ }>"
    $P2402."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2403)
    get_how $P2404, type_obj
    .const 'Sub' $P2405 = "258_1303923618.727" 
    $P2404."add_method"(type_obj, "quote_escape:sym<esc>", $P2405)
    get_how $P2406, type_obj
    get_global $P2407, "!PREFIX__quote_escape:sym<esc>"
    $P2406."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2407)
    get_how $P2408, type_obj
    .const 'Sub' $P2409 = "260_1303923618.727" 
    $P2408."add_method"(type_obj, "circumfix:sym<( )>", $P2409)
    get_how $P2410, type_obj
    get_global $P2411, "!PREFIX__circumfix:sym<( )>"
    $P2410."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2411)
    get_how $P2412, type_obj
    .const 'Sub' $P2413 = "262_1303923618.727" 
    $P2412."add_method"(type_obj, "circumfix:sym<[ ]>", $P2413)
    get_how $P2414, type_obj
    get_global $P2415, "!PREFIX__circumfix:sym<[ ]>"
    $P2414."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2415)
    get_how $P2416, type_obj
    .const 'Sub' $P2417 = "264_1303923618.727" 
    $P2416."add_method"(type_obj, "circumfix:sym<ang>", $P2417)
    get_how $P2418, type_obj
    get_global $P2419, "!PREFIX__circumfix:sym<ang>"
    $P2418."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2419)
    get_how $P2420, type_obj
    .const 'Sub' $P2421 = "266_1303923618.727" 
    $P2420."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2421)
    get_how $P2422, type_obj
    get_global $P2423, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2422."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2423)
    get_how $P2424, type_obj
    .const 'Sub' $P2425 = "268_1303923618.727" 
    $P2424."add_method"(type_obj, "circumfix:sym<{ }>", $P2425)
    get_how $P2426, type_obj
    get_global $P2427, "!PREFIX__circumfix:sym<{ }>"
    $P2426."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2427)
    get_how $P2428, type_obj
    .const 'Sub' $P2429 = "270_1303923618.727" 
    $P2428."add_method"(type_obj, "circumfix:sym<sigil>", $P2429)
    get_how $P2430, type_obj
    get_global $P2431, "!PREFIX__circumfix:sym<sigil>"
    $P2430."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2431)
    get_how $P2432, type_obj
    .const 'Sub' $P2433 = "272_1303923618.727" 
    $P2432."add_method"(type_obj, "semilist", $P2433)
    get_how $P2434, type_obj
    get_global $P2435, "!PREFIX__semilist"
    $P2434."add_method"(type_obj, "!PREFIX__semilist", $P2435)
    get_how $P2436, type_obj
    .const 'Sub' $P2437 = "274_1303923618.727" 
    $P2436."add_method"(type_obj, "infixish", $P2437)
    get_how $P2438, type_obj
    get_global $P2439, "!PREFIX__infixish"
    $P2438."add_method"(type_obj, "!PREFIX__infixish", $P2439)
    get_how $P2440, type_obj
    .const 'Sub' $P2441 = "276_1303923618.727" 
    $P2440."add_method"(type_obj, "infixstopper", $P2441)
    get_how $P2442, type_obj
    get_global $P2443, "!PREFIX__infixstopper"
    $P2442."add_method"(type_obj, "!PREFIX__infixstopper", $P2443)
    get_how $P2444, type_obj
    .const 'Sub' $P2445 = "278_1303923618.727" 
    $P2444."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2445)
    get_how $P2446, type_obj
    get_global $P2447, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2446."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2447)
    get_how $P2448, type_obj
    .const 'Sub' $P2449 = "280_1303923618.727" 
    $P2448."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2449)
    get_how $P2450, type_obj
    get_global $P2451, "!PREFIX__postcircumfix:sym<{ }>"
    $P2450."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2451)
    get_how $P2452, type_obj
    .const 'Sub' $P2453 = "282_1303923618.727" 
    $P2452."add_method"(type_obj, "postcircumfix:sym<ang>", $P2453)
    get_how $P2454, type_obj
    get_global $P2455, "!PREFIX__postcircumfix:sym<ang>"
    $P2454."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2455)
    get_how $P2456, type_obj
    .const 'Sub' $P2457 = "284_1303923618.727" 
    $P2456."add_method"(type_obj, "postcircumfix:sym<( )>", $P2457)
    get_how $P2458, type_obj
    get_global $P2459, "!PREFIX__postcircumfix:sym<( )>"
    $P2458."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2459)
    get_how $P2460, type_obj
    .const 'Sub' $P2461 = "286_1303923618.727" 
    $P2460."add_method"(type_obj, "postfix:sym<.>", $P2461)
    get_how $P2462, type_obj
    get_global $P2463, "!PREFIX__postfix:sym<.>"
    $P2462."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2463)
    get_how $P2464, type_obj
    .const 'Sub' $P2465 = "288_1303923618.727" 
    $P2464."add_method"(type_obj, "prefix:sym<++>", $P2465)
    get_how $P2466, type_obj
    get_global $P2467, "!PREFIX__prefix:sym<++>"
    $P2466."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2467)
    get_how $P2468, type_obj
    .const 'Sub' $P2469 = "290_1303923618.727" 
    $P2468."add_method"(type_obj, "prefix:sym<-->", $P2469)
    get_how $P2470, type_obj
    get_global $P2471, "!PREFIX__prefix:sym<-->"
    $P2470."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2471)
    get_how $P2472, type_obj
    .const 'Sub' $P2473 = "292_1303923618.727" 
    $P2472."add_method"(type_obj, "postfix:sym<++>", $P2473)
    get_how $P2474, type_obj
    get_global $P2475, "!PREFIX__postfix:sym<++>"
    $P2474."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2475)
    get_how $P2476, type_obj
    .const 'Sub' $P2477 = "294_1303923618.727" 
    $P2476."add_method"(type_obj, "postfix:sym<-->", $P2477)
    get_how $P2478, type_obj
    get_global $P2479, "!PREFIX__postfix:sym<-->"
    $P2478."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2479)
    get_how $P2480, type_obj
    .const 'Sub' $P2481 = "296_1303923618.727" 
    $P2480."add_method"(type_obj, "infix:sym<**>", $P2481)
    get_how $P2482, type_obj
    get_global $P2483, "!PREFIX__infix:sym<**>"
    $P2482."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2483)
    get_how $P2484, type_obj
    .const 'Sub' $P2485 = "298_1303923618.727" 
    $P2484."add_method"(type_obj, "prefix:sym<+>", $P2485)
    get_how $P2486, type_obj
    get_global $P2487, "!PREFIX__prefix:sym<+>"
    $P2486."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2487)
    get_how $P2488, type_obj
    .const 'Sub' $P2489 = "300_1303923618.727" 
    $P2488."add_method"(type_obj, "prefix:sym<~>", $P2489)
    get_how $P2490, type_obj
    get_global $P2491, "!PREFIX__prefix:sym<~>"
    $P2490."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2491)
    get_how $P2492, type_obj
    .const 'Sub' $P2493 = "302_1303923618.727" 
    $P2492."add_method"(type_obj, "prefix:sym<->", $P2493)
    get_how $P2494, type_obj
    get_global $P2495, "!PREFIX__prefix:sym<->"
    $P2494."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2495)
    get_how $P2496, type_obj
    .const 'Sub' $P2497 = "304_1303923618.727" 
    $P2496."add_method"(type_obj, "prefix:sym<?>", $P2497)
    get_how $P2498, type_obj
    get_global $P2499, "!PREFIX__prefix:sym<?>"
    $P2498."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2499)
    get_how $P2500, type_obj
    .const 'Sub' $P2501 = "306_1303923618.727" 
    $P2500."add_method"(type_obj, "prefix:sym<!>", $P2501)
    get_how $P2502, type_obj
    get_global $P2503, "!PREFIX__prefix:sym<!>"
    $P2502."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2503)
    get_how $P2504, type_obj
    .const 'Sub' $P2505 = "308_1303923618.727" 
    $P2504."add_method"(type_obj, "prefix:sym<|>", $P2505)
    get_how $P2506, type_obj
    get_global $P2507, "!PREFIX__prefix:sym<|>"
    $P2506."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2507)
    get_how $P2508, type_obj
    .const 'Sub' $P2509 = "310_1303923618.727" 
    $P2508."add_method"(type_obj, "infix:sym<*>", $P2509)
    get_how $P2510, type_obj
    get_global $P2511, "!PREFIX__infix:sym<*>"
    $P2510."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2511)
    get_how $P2512, type_obj
    .const 'Sub' $P2513 = "312_1303923618.727" 
    $P2512."add_method"(type_obj, "infix:sym</>", $P2513)
    get_how $P2514, type_obj
    get_global $P2515, "!PREFIX__infix:sym</>"
    $P2514."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2515)
    get_how $P2516, type_obj
    .const 'Sub' $P2517 = "314_1303923618.727" 
    $P2516."add_method"(type_obj, "infix:sym<%>", $P2517)
    get_how $P2518, type_obj
    get_global $P2519, "!PREFIX__infix:sym<%>"
    $P2518."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2519)
    get_how $P2520, type_obj
    .const 'Sub' $P2521 = "316_1303923618.727" 
    $P2520."add_method"(type_obj, "infix:sym<+&>", $P2521)
    get_how $P2522, type_obj
    get_global $P2523, "!PREFIX__infix:sym<+&>"
    $P2522."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2523)
    get_how $P2524, type_obj
    .const 'Sub' $P2525 = "318_1303923618.727" 
    $P2524."add_method"(type_obj, "infix:sym<+>", $P2525)
    get_how $P2526, type_obj
    get_global $P2527, "!PREFIX__infix:sym<+>"
    $P2526."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2527)
    get_how $P2528, type_obj
    .const 'Sub' $P2529 = "320_1303923618.727" 
    $P2528."add_method"(type_obj, "infix:sym<->", $P2529)
    get_how $P2530, type_obj
    get_global $P2531, "!PREFIX__infix:sym<->"
    $P2530."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2531)
    get_how $P2532, type_obj
    .const 'Sub' $P2533 = "322_1303923618.727" 
    $P2532."add_method"(type_obj, "infix:sym<+|>", $P2533)
    get_how $P2534, type_obj
    get_global $P2535, "!PREFIX__infix:sym<+|>"
    $P2534."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2535)
    get_how $P2536, type_obj
    .const 'Sub' $P2537 = "324_1303923618.727" 
    $P2536."add_method"(type_obj, "infix:sym<+^>", $P2537)
    get_how $P2538, type_obj
    get_global $P2539, "!PREFIX__infix:sym<+^>"
    $P2538."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2539)
    get_how $P2540, type_obj
    .const 'Sub' $P2541 = "326_1303923618.727" 
    $P2540."add_method"(type_obj, "infix:sym<~>", $P2541)
    get_how $P2542, type_obj
    get_global $P2543, "!PREFIX__infix:sym<~>"
    $P2542."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2543)
    get_how $P2544, type_obj
    .const 'Sub' $P2545 = "328_1303923618.727" 
    $P2544."add_method"(type_obj, "infix:sym<==>", $P2545)
    get_how $P2546, type_obj
    get_global $P2547, "!PREFIX__infix:sym<==>"
    $P2546."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2547)
    get_how $P2548, type_obj
    .const 'Sub' $P2549 = "330_1303923618.727" 
    $P2548."add_method"(type_obj, "infix:sym<!=>", $P2549)
    get_how $P2550, type_obj
    get_global $P2551, "!PREFIX__infix:sym<!=>"
    $P2550."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2551)
    get_how $P2552, type_obj
    .const 'Sub' $P2553 = "332_1303923618.727" 
    $P2552."add_method"(type_obj, "infix:sym<<=>", $P2553)
    get_how $P2554, type_obj
    get_global $P2555, "!PREFIX__infix:sym<<=>"
    $P2554."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2555)
    get_how $P2556, type_obj
    .const 'Sub' $P2557 = "334_1303923618.727" 
    $P2556."add_method"(type_obj, "infix:sym<>=>", $P2557)
    get_how $P2558, type_obj
    get_global $P2559, "!PREFIX__infix:sym<>=>"
    $P2558."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2559)
    get_how $P2560, type_obj
    .const 'Sub' $P2561 = "336_1303923618.727" 
    $P2560."add_method"(type_obj, "infix:sym<<>", $P2561)
    get_how $P2562, type_obj
    get_global $P2563, "!PREFIX__infix:sym<<>"
    $P2562."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2563)
    get_how $P2564, type_obj
    .const 'Sub' $P2565 = "338_1303923618.727" 
    $P2564."add_method"(type_obj, "infix:sym<>>", $P2565)
    get_how $P2566, type_obj
    get_global $P2567, "!PREFIX__infix:sym<>>"
    $P2566."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2567)
    get_how $P2568, type_obj
    .const 'Sub' $P2569 = "340_1303923618.727" 
    $P2568."add_method"(type_obj, "infix:sym<eq>", $P2569)
    get_how $P2570, type_obj
    get_global $P2571, "!PREFIX__infix:sym<eq>"
    $P2570."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2571)
    get_how $P2572, type_obj
    .const 'Sub' $P2573 = "342_1303923618.727" 
    $P2572."add_method"(type_obj, "infix:sym<ne>", $P2573)
    get_how $P2574, type_obj
    get_global $P2575, "!PREFIX__infix:sym<ne>"
    $P2574."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2575)
    get_how $P2576, type_obj
    .const 'Sub' $P2577 = "344_1303923618.727" 
    $P2576."add_method"(type_obj, "infix:sym<le>", $P2577)
    get_how $P2578, type_obj
    get_global $P2579, "!PREFIX__infix:sym<le>"
    $P2578."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2579)
    get_how $P2580, type_obj
    .const 'Sub' $P2581 = "346_1303923618.727" 
    $P2580."add_method"(type_obj, "infix:sym<ge>", $P2581)
    get_how $P2582, type_obj
    get_global $P2583, "!PREFIX__infix:sym<ge>"
    $P2582."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2583)
    get_how $P2584, type_obj
    .const 'Sub' $P2585 = "348_1303923618.727" 
    $P2584."add_method"(type_obj, "infix:sym<lt>", $P2585)
    get_how $P2586, type_obj
    get_global $P2587, "!PREFIX__infix:sym<lt>"
    $P2586."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2587)
    get_how $P2588, type_obj
    .const 'Sub' $P2589 = "350_1303923618.727" 
    $P2588."add_method"(type_obj, "infix:sym<gt>", $P2589)
    get_how $P2590, type_obj
    get_global $P2591, "!PREFIX__infix:sym<gt>"
    $P2590."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2591)
    get_how $P2592, type_obj
    .const 'Sub' $P2593 = "352_1303923618.727" 
    $P2592."add_method"(type_obj, "infix:sym<=:=>", $P2593)
    get_how $P2594, type_obj
    get_global $P2595, "!PREFIX__infix:sym<=:=>"
    $P2594."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2595)
    get_how $P2596, type_obj
    .const 'Sub' $P2597 = "354_1303923618.727" 
    $P2596."add_method"(type_obj, "infix:sym<~~>", $P2597)
    get_how $P2598, type_obj
    get_global $P2599, "!PREFIX__infix:sym<~~>"
    $P2598."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2599)
    get_how $P2600, type_obj
    .const 'Sub' $P2601 = "356_1303923618.727" 
    $P2600."add_method"(type_obj, "infix:sym<&&>", $P2601)
    get_how $P2602, type_obj
    get_global $P2603, "!PREFIX__infix:sym<&&>"
    $P2602."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2603)
    get_how $P2604, type_obj
    .const 'Sub' $P2605 = "358_1303923618.727" 
    $P2604."add_method"(type_obj, "infix:sym<||>", $P2605)
    get_how $P2606, type_obj
    get_global $P2607, "!PREFIX__infix:sym<||>"
    $P2606."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2607)
    get_how $P2608, type_obj
    .const 'Sub' $P2609 = "360_1303923618.727" 
    $P2608."add_method"(type_obj, "infix:sym<//>", $P2609)
    get_how $P2610, type_obj
    get_global $P2611, "!PREFIX__infix:sym<//>"
    $P2610."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2611)
    get_how $P2612, type_obj
    .const 'Sub' $P2613 = "362_1303923618.727" 
    $P2612."add_method"(type_obj, "infix:sym<?? !!>", $P2613)
    get_how $P2614, type_obj
    get_global $P2615, "!PREFIX__infix:sym<?? !!>"
    $P2614."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2615)
    get_how $P2616, type_obj
    .const 'Sub' $P2617 = "364_1303923618.727" 
    $P2616."add_method"(type_obj, "infix:sym<=>", $P2617)
    get_how $P2618, type_obj
    get_global $P2619, "!PREFIX__infix:sym<=>"
    $P2618."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2619)
    get_how $P2620, type_obj
    .const 'Sub' $P2621 = "366_1303923618.727" 
    $P2620."add_method"(type_obj, "infix:sym<:=>", $P2621)
    get_how $P2622, type_obj
    get_global $P2623, "!PREFIX__infix:sym<:=>"
    $P2622."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2623)
    get_how $P2624, type_obj
    .const 'Sub' $P2625 = "368_1303923618.727" 
    $P2624."add_method"(type_obj, "infix:sym<::=>", $P2625)
    get_how $P2626, type_obj
    get_global $P2627, "!PREFIX__infix:sym<::=>"
    $P2626."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2627)
    get_how $P2628, type_obj
    .const 'Sub' $P2629 = "370_1303923618.727" 
    $P2628."add_method"(type_obj, "infix:sym<,>", $P2629)
    get_how $P2630, type_obj
    get_global $P2631, "!PREFIX__infix:sym<,>"
    $P2630."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2631)
    get_how $P2632, type_obj
    .const 'Sub' $P2633 = "372_1303923618.727" 
    $P2632."add_method"(type_obj, "prefix:sym<return>", $P2633)
    get_how $P2634, type_obj
    get_global $P2635, "!PREFIX__prefix:sym<return>"
    $P2634."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2635)
    get_how $P2636, type_obj
    .const 'Sub' $P2637 = "375_1303923618.727" 
    $P2636."add_method"(type_obj, "prefix:sym<make>", $P2637)
    get_how $P2638, type_obj
    get_global $P2639, "!PREFIX__prefix:sym<make>"
    $P2638."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2639)
    get_how $P2640, type_obj
    .const 'Sub' $P2641 = "377_1303923618.727" 
    $P2640."add_method"(type_obj, "term:sym<last>", $P2641)
    get_how $P2642, type_obj
    get_global $P2643, "!PREFIX__term:sym<last>"
    $P2642."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2643)
    get_how $P2644, type_obj
    .const 'Sub' $P2645 = "379_1303923618.727" 
    $P2644."add_method"(type_obj, "term:sym<next>", $P2645)
    get_how $P2646, type_obj
    get_global $P2647, "!PREFIX__term:sym<next>"
    $P2646."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2647)
    get_how $P2648, type_obj
    .const 'Sub' $P2649 = "381_1303923618.727" 
    $P2648."add_method"(type_obj, "term:sym<redo>", $P2649)
    get_how $P2650, type_obj
    get_global $P2651, "!PREFIX__term:sym<redo>"
    $P2650."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2651)
    get_how $P2652, type_obj
    .const 'Sub' $P2653 = "383_1303923618.727" 
    $P2652."add_method"(type_obj, "smartmatch", $P2653)
    get_how $P2654, type_obj
    $P2655 = $P2654."compose"(type_obj)
    .return ($P2655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1303923618.727") :outer("12_1303923618.727")
    .param pmc param_111
.annotate 'line', 10
    .lex "self", param_111
.annotate 'line', 12
    $P112 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P112
.annotate 'line', 21
    $P113 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P113
.annotate 'line', 28
    new $P114, "Undef"
    .lex "$*SC", $P114
.annotate 'line', 32
    new $P115, "Undef"
    .lex "$*SCOPE", $P115
.annotate 'line', 33
    new $P116, "Undef"
    .lex "$*MULTINESS", $P116
.annotate 'line', 34
    new $P117, "Undef"
    .lex "$*INVOCANT_OK", $P117
.annotate 'line', 35
    new $P118, "Undef"
    .lex "$*RETURN_USED", $P118
.annotate 'line', 36
    new $P119, "Undef"
    .lex "$*PACKAGE-SETUP", $P119
.annotate 'line', 10
    find_lex $P122, "%*LANG"
    unless_null $P122, vivify_602
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["%LANG"]
    unless_null $P122, vivify_603
    die "Contextual %*LANG not found"
  vivify_603:
  vivify_602:
.annotate 'line', 13
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "NQP"
    get_who $P125, $P124
    set $P126, $P125["Regex"]
    find_lex $P129, "%*LANG"
    unless_null $P129, vivify_604
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["%LANG"]
    unless_null $P129, vivify_605
    die "Contextual %*LANG not found"
  vivify_605:
    store_lex "%*LANG", $P129
  vivify_604:
    set $P129["Regex"], $P126
.annotate 'line', 14
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "NQP"
    get_who $P132, $P131
    set $P133, $P132["RegexActions"]
    find_lex $P136, "%*LANG"
    unless_null $P136, vivify_606
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["%LANG"]
    unless_null $P136, vivify_607
    die "Contextual %*LANG not found"
  vivify_607:
    store_lex "%*LANG", $P136
  vivify_606:
    set $P136["Regex-actions"], $P133
.annotate 'line', 15
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "NQP"
    get_who $P139, $P138
    set $P140, $P139["Grammar"]
    find_lex $P143, "%*LANG"
    unless_null $P143, vivify_608
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["%LANG"]
    unless_null $P143, vivify_609
    die "Contextual %*LANG not found"
  vivify_609:
    store_lex "%*LANG", $P143
  vivify_608:
    set $P143["MAIN"], $P140
.annotate 'line', 16
    get_hll_global $P144, "GLOBAL"
    nqp_get_package_through_who $P145, $P144, "NQP"
    get_who $P146, $P145
    set $P147, $P146["Actions"]
    find_lex $P150, "%*LANG"
    unless_null $P150, vivify_610
    get_hll_global $P148, "GLOBAL"
    get_who $P149, $P148
    set $P150, $P149["%LANG"]
    unless_null $P150, vivify_611
    die "Contextual %*LANG not found"
  vivify_611:
    store_lex "%*LANG", $P150
  vivify_610:
    set $P150["MAIN-actions"], $P147
    find_lex $P153, "%*HOW"
    unless_null $P153, vivify_612
    get_hll_global $P151, "GLOBAL"
    get_who $P152, $P151
    set $P153, $P152["%HOW"]
    unless_null $P153, vivify_613
    die "Contextual %*HOW not found"
  vivify_613:
  vivify_612:
.annotate 'line', 22
    get_knowhow $P154
    find_lex $P157, "%*HOW"
    unless_null $P157, vivify_614
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["%HOW"]
    unless_null $P157, vivify_615
    die "Contextual %*HOW not found"
  vivify_615:
    store_lex "%*HOW", $P157
  vivify_614:
    set $P157["knowhow"], $P154
.annotate 'line', 23
    get_knowhow_attribute $P158
    find_lex $P161, "%*HOW"
    unless_null $P161, vivify_616
    get_hll_global $P159, "GLOBAL"
    get_who $P160, $P159
    set $P161, $P160["%HOW"]
    unless_null $P161, vivify_617
    die "Contextual %*HOW not found"
  vivify_617:
    store_lex "%*HOW", $P161
  vivify_616:
    set $P161["knowhow-attr"], $P158
.annotate 'line', 28
    get_hll_global $P162, "GLOBAL"
    nqp_get_package_through_who $P163, $P162, "HLL"
    nqp_get_package_through_who $P164, $P163, "Compiler"
    get_who $P165, $P164
    set $P166, $P165["SerializationContextBuilder"]
.annotate 'line', 30
    time $N167
    set $S168, $N167
    $P169 = $P166."new"($S168 :named("handle"))
.annotate 'line', 28
    store_lex "$*SC", $P169
.annotate 'line', 32
    new $P170, "String"
    assign $P170, ""
    store_lex "$*SCOPE", $P170
.annotate 'line', 33
    new $P171, "String"
    assign $P171, ""
    store_lex "$*MULTINESS", $P171
.annotate 'line', 34
    new $P172, "Integer"
    assign $P172, 0
    store_lex "$*INVOCANT_OK", $P172
.annotate 'line', 35
    new $P173, "Integer"
    assign $P173, 0
    store_lex "$*RETURN_USED", $P173
    find_lex $P176, "$*PACKAGE-SETUP"
    unless_null $P176, vivify_618
    get_hll_global $P174, "GLOBAL"
    get_who $P175, $P174
    set $P176, $P175["$PACKAGE-SETUP"]
    unless_null $P176, vivify_619
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_619:
  vivify_618:
.annotate 'line', 37
    find_lex $P177, "self"
    $P178 = $P177."comp_unit"()
.annotate 'line', 10
    .return ($P178)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx180_tgt
    .local int rx180_pos
    .local int rx180_off
    .local int rx180_eos
    .local int rx180_rep
    .local pmc rx180_cur
    .local pmc rx180_debug
    (rx180_cur, rx180_pos, rx180_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx180_cur
    .local pmc match
    .lex "$/", match
    length rx180_eos, rx180_tgt
    gt rx180_pos, rx180_eos, rx180_done
    set rx180_off, 0
    lt rx180_pos, 2, rx180_start
    sub rx180_off, rx180_pos, 1
    substr rx180_tgt, rx180_tgt, rx180_off
  rx180_start:
    eq $I10, 1, rx180_restart
    if_null rx180_debug, debug_620
    rx180_cur."!cursor_debug"("START", "identifier")
  debug_620:
    $I10 = self.'from'()
    ne $I10, -1, rxscan184_done
    goto rxscan184_scan
  rxscan184_loop:
    (rx180_pos) = rx180_cur."from"()
    inc rx180_pos
    rx180_cur."!cursor_from"(rx180_pos)
    ge rx180_pos, rx180_eos, rxscan184_done
  rxscan184_scan:
    set_addr $I10, rxscan184_loop
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxscan184_done:
.annotate 'line', 42
  # rx subrule "ident" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ident"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
  # rx rxquantr185 ** 0..*
    set_addr $I10, rxquantr185_done
    rx180_cur."!mark_push"(0, rx180_pos, $I10)
  rxquantr185_loop:
  # rx enumcharlist negate=0 
    ge rx180_pos, rx180_eos, rx180_fail
    sub $I10, rx180_pos, rx180_off
    substr $S10, rx180_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx180_fail
    inc rx180_pos
  # rx subrule "ident" subtype=method negate=
    rx180_cur."!cursor_pos"(rx180_pos)
    $P10 = rx180_cur."ident"()
    unless $P10, rx180_fail
    rx180_pos = $P10."pos"()
    set_addr $I10, rxquantr185_done
    (rx180_rep) = rx180_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr185_done
    rx180_cur."!mark_push"(rx180_rep, rx180_pos, $I10)
    goto rxquantr185_loop
  rxquantr185_done:
  # rx pass
    rx180_cur."!cursor_pass"(rx180_pos, "identifier")
    if_null rx180_debug, debug_621
    rx180_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx180_pos)
  debug_621:
    .return (rx180_cur)
  rx180_restart:
.annotate 'line', 10
    if_null rx180_debug, debug_622
    rx180_cur."!cursor_debug"("NEXT", "identifier")
  debug_622:
  rx180_fail:
    (rx180_rep, rx180_pos, $I10, $P10) = rx180_cur."!mark_fail"(0)
    lt rx180_pos, -1, rx180_done
    eq rx180_pos, -1, rx180_fail
    jump $I10
  rx180_done:
    rx180_cur."!cursor_fail"()
    if_null rx180_debug, debug_623
    rx180_cur."!cursor_debug"("FAIL", "identifier")
  debug_623:
    .return (rx180_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1303923618.727") :method
.annotate 'line', 10
    $P182 = self."!PREFIX__!subrule"("ident", "")
    new $P183, "ResizablePMCArray"
    push $P183, $P182
    .return ($P183)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx187_tgt
    .local int rx187_pos
    .local int rx187_off
    .local int rx187_eos
    .local int rx187_rep
    .local pmc rx187_cur
    .local pmc rx187_debug
    (rx187_cur, rx187_pos, rx187_tgt, $I10) = self."!cursor_start"()
    rx187_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx187_cur
    .local pmc match
    .lex "$/", match
    length rx187_eos, rx187_tgt
    gt rx187_pos, rx187_eos, rx187_done
    set rx187_off, 0
    lt rx187_pos, 2, rx187_start
    sub rx187_off, rx187_pos, 1
    substr rx187_tgt, rx187_tgt, rx187_off
  rx187_start:
    eq $I10, 1, rx187_restart
    if_null rx187_debug, debug_624
    rx187_cur."!cursor_debug"("START", "name")
  debug_624:
    $I10 = self.'from'()
    ne $I10, -1, rxscan190_done
    goto rxscan190_scan
  rxscan190_loop:
    (rx187_pos) = rx187_cur."from"()
    inc rx187_pos
    rx187_cur."!cursor_from"(rx187_pos)
    ge rx187_pos, rx187_eos, rxscan190_done
  rxscan190_scan:
    set_addr $I10, rxscan190_loop
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  rxscan190_done:
.annotate 'line', 44
  # rx rxquantr191 ** 1..*
    set_addr $I10, rxquantr191_done
    rx187_cur."!mark_push"(0, -1, $I10)
  rxquantr191_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."identifier"()
    unless $P10, rx187_fail
    goto rxsubrule192_pass
  rxsubrule192_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx187_fail
  rxsubrule192_pass:
    set_addr $I10, rxsubrule192_back
    rx187_cur."!mark_push"(0, rx187_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx187_pos = $P10."pos"()
    set_addr $I10, rxquantr191_done
    (rx187_rep) = rx187_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr191_done
    rx187_cur."!mark_push"(rx187_rep, rx187_pos, $I10)
  # rx literal  "::"
    add $I11, rx187_pos, 2
    gt $I11, rx187_eos, rx187_fail
    sub $I11, rx187_pos, rx187_off
    substr $S10, rx187_tgt, $I11, 2
    ne $S10, "::", rx187_fail
    add rx187_pos, 2
    goto rxquantr191_loop
  rxquantr191_done:
  # rx pass
    rx187_cur."!cursor_pass"(rx187_pos, "name")
    if_null rx187_debug, debug_625
    rx187_cur."!cursor_debug"("PASS", "name", " at pos=", rx187_pos)
  debug_625:
    .return (rx187_cur)
  rx187_restart:
.annotate 'line', 10
    if_null rx187_debug, debug_626
    rx187_cur."!cursor_debug"("NEXT", "name")
  debug_626:
  rx187_fail:
    (rx187_rep, rx187_pos, $I10, $P10) = rx187_cur."!mark_fail"(0)
    lt rx187_pos, -1, rx187_done
    eq rx187_pos, -1, rx187_fail
    jump $I10
  rx187_done:
    rx187_cur."!cursor_fail"()
    if_null rx187_debug, debug_627
    rx187_cur."!cursor_debug"("FAIL", "name")
  debug_627:
    .return (rx187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1303923618.727") :method
.annotate 'line', 10
    new $P189, "ResizablePMCArray"
    push $P189, ""
    .return ($P189)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx194_tgt
    .local int rx194_pos
    .local int rx194_off
    .local int rx194_eos
    .local int rx194_rep
    .local pmc rx194_cur
    .local pmc rx194_debug
    (rx194_cur, rx194_pos, rx194_tgt, $I10) = self."!cursor_start"()
    rx194_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx194_cur
    .local pmc match
    .lex "$/", match
    length rx194_eos, rx194_tgt
    gt rx194_pos, rx194_eos, rx194_done
    set rx194_off, 0
    lt rx194_pos, 2, rx194_start
    sub rx194_off, rx194_pos, 1
    substr rx194_tgt, rx194_tgt, rx194_off
  rx194_start:
    eq $I10, 1, rx194_restart
    if_null rx194_debug, debug_628
    rx194_cur."!cursor_debug"("START", "deflongname")
  debug_628:
    $I10 = self.'from'()
    ne $I10, -1, rxscan198_done
    goto rxscan198_scan
  rxscan198_loop:
    (rx194_pos) = rx194_cur."from"()
    inc rx194_pos
    rx194_cur."!cursor_from"(rx194_pos)
    ge rx194_pos, rx194_eos, rxscan198_done
  rxscan198_scan:
    set_addr $I10, rxscan198_loop
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
  rxscan198_done:
.annotate 'line', 47
  # rx subrule "identifier" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."identifier"()
    unless $P10, rx194_fail
    rx194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx194_pos = $P10."pos"()
  # rx rxquantr199 ** 0..1
    set_addr $I10, rxquantr199_done
    rx194_cur."!mark_push"(0, rx194_pos, $I10)
  rxquantr199_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx194_cur."!cursor_pos"(rx194_pos)
    $P10 = rx194_cur."colonpair"()
    unless $P10, rx194_fail
    goto rxsubrule200_pass
  rxsubrule200_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx194_fail
  rxsubrule200_pass:
    set_addr $I10, rxsubrule200_back
    rx194_cur."!mark_push"(0, rx194_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx194_pos = $P10."pos"()
    set_addr $I10, rxquantr199_done
    (rx194_rep) = rx194_cur."!mark_commit"($I10)
  rxquantr199_done:
.annotate 'line', 46
  # rx pass
    rx194_cur."!cursor_pass"(rx194_pos, "deflongname")
    if_null rx194_debug, debug_629
    rx194_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx194_pos)
  debug_629:
    .return (rx194_cur)
  rx194_restart:
.annotate 'line', 10
    if_null rx194_debug, debug_630
    rx194_cur."!cursor_debug"("NEXT", "deflongname")
  debug_630:
  rx194_fail:
    (rx194_rep, rx194_pos, $I10, $P10) = rx194_cur."!mark_fail"(0)
    lt rx194_pos, -1, rx194_done
    eq rx194_pos, -1, rx194_fail
    jump $I10
  rx194_done:
    rx194_cur."!cursor_fail"()
    if_null rx194_debug, debug_631
    rx194_cur."!cursor_debug"("FAIL", "deflongname")
  debug_631:
    .return (rx194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1303923618.727") :method
.annotate 'line', 10
    $P196 = self."!PREFIX__!subrule"("identifier", "")
    new $P197, "ResizablePMCArray"
    push $P197, $P196
    .return ($P197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx202_tgt
    .local int rx202_pos
    .local int rx202_off
    .local int rx202_eos
    .local int rx202_rep
    .local pmc rx202_cur
    .local pmc rx202_debug
    (rx202_cur, rx202_pos, rx202_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx202_cur
    .local pmc match
    .lex "$/", match
    length rx202_eos, rx202_tgt
    gt rx202_pos, rx202_eos, rx202_done
    set rx202_off, 0
    lt rx202_pos, 2, rx202_start
    sub rx202_off, rx202_pos, 1
    substr rx202_tgt, rx202_tgt, rx202_off
  rx202_start:
    eq $I10, 1, rx202_restart
    if_null rx202_debug, debug_632
    rx202_cur."!cursor_debug"("START", "ENDSTMT")
  debug_632:
    $I10 = self.'from'()
    ne $I10, -1, rxscan205_done
    goto rxscan205_scan
  rxscan205_loop:
    (rx202_pos) = rx202_cur."from"()
    inc rx202_pos
    rx202_cur."!cursor_from"(rx202_pos)
    ge rx202_pos, rx202_eos, rxscan205_done
  rxscan205_scan:
    set_addr $I10, rxscan205_loop
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  rxscan205_done:
.annotate 'line', 54
  # rx rxquantr206 ** 0..1
    set_addr $I10, rxquantr206_done
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  rxquantr206_loop:
  alt207_0:
.annotate 'line', 51
    set_addr $I10, alt207_1
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
.annotate 'line', 52
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx202_pos, rx202_off
    set rx202_rep, 0
    sub $I12, rx202_eos, rx202_pos
  rxenumcharlistq208_loop:
    le $I12, 0, rxenumcharlistq208_done
    substr $S10, rx202_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq208_done
    inc rx202_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq208_loop
  rxenumcharlistq208_done:
    add rx202_pos, rx202_pos, rx202_rep
  # rxanchor eol
    sub $I10, rx202_pos, rx202_off
    is_cclass $I11, 4096, rx202_tgt, $I10
    if $I11, rxanchor209_done
    ne rx202_pos, rx202_eos, rx202_fail
    eq rx202_pos, 0, rxanchor209_done
    dec $I10
    is_cclass $I11, 4096, rx202_tgt, $I10
    if $I11, rx202_fail
  rxanchor209_done:
  # rx subrule "ws" subtype=method negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."ws"()
    unless $P10, rx202_fail
    rx202_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."MARKER"("endstmt")
    unless $P10, rx202_fail
    goto alt207_end
  alt207_1:
.annotate 'line', 53
  # rx rxquantr210 ** 0..1
    set_addr $I10, rxquantr210_done
    rx202_cur."!mark_push"(0, rx202_pos, $I10)
  rxquantr210_loop:
  # rx subrule "unv" subtype=method negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."unv"()
    unless $P10, rx202_fail
    goto rxsubrule211_pass
  rxsubrule211_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx202_fail
  rxsubrule211_pass:
    set_addr $I10, rxsubrule211_back
    rx202_cur."!mark_push"(0, rx202_pos, $I10, $P10)
    rx202_pos = $P10."pos"()
    set_addr $I10, rxquantr210_done
    (rx202_rep) = rx202_cur."!mark_commit"($I10)
  rxquantr210_done:
  # rxanchor eol
    sub $I10, rx202_pos, rx202_off
    is_cclass $I11, 4096, rx202_tgt, $I10
    if $I11, rxanchor212_done
    ne rx202_pos, rx202_eos, rx202_fail
    eq rx202_pos, 0, rxanchor212_done
    dec $I10
    is_cclass $I11, 4096, rx202_tgt, $I10
    if $I11, rx202_fail
  rxanchor212_done:
  # rx subrule "ws" subtype=method negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."ws"()
    unless $P10, rx202_fail
    rx202_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx202_cur."!cursor_pos"(rx202_pos)
    $P10 = rx202_cur."MARKER"("endstmt")
    unless $P10, rx202_fail
  alt207_end:
.annotate 'line', 54
    set_addr $I10, rxquantr206_done
    (rx202_rep) = rx202_cur."!mark_commit"($I10)
  rxquantr206_done:
.annotate 'line', 50
  # rx pass
    rx202_cur."!cursor_pass"(rx202_pos, "ENDSTMT")
    if_null rx202_debug, debug_633
    rx202_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx202_pos)
  debug_633:
    .return (rx202_cur)
  rx202_restart:
.annotate 'line', 10
    if_null rx202_debug, debug_634
    rx202_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_634:
  rx202_fail:
    (rx202_rep, rx202_pos, $I10, $P10) = rx202_cur."!mark_fail"(0)
    lt rx202_pos, -1, rx202_done
    eq rx202_pos, -1, rx202_fail
    jump $I10
  rx202_done:
    rx202_cur."!cursor_fail"()
    if_null rx202_debug, debug_635
    rx202_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_635:
    .return (rx202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1303923618.727") :method
.annotate 'line', 10
    new $P204, "ResizablePMCArray"
    push $P204, ""
    .return ($P204)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx214_tgt
    .local int rx214_pos
    .local int rx214_off
    .local int rx214_eos
    .local int rx214_rep
    .local pmc rx214_cur
    .local pmc rx214_debug
    (rx214_cur, rx214_pos, rx214_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx214_cur
    .local pmc match
    .lex "$/", match
    length rx214_eos, rx214_tgt
    gt rx214_pos, rx214_eos, rx214_done
    set rx214_off, 0
    lt rx214_pos, 2, rx214_start
    sub rx214_off, rx214_pos, 1
    substr rx214_tgt, rx214_tgt, rx214_off
  rx214_start:
    eq $I10, 1, rx214_restart
    if_null rx214_debug, debug_636
    rx214_cur."!cursor_debug"("START", "ws")
  debug_636:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    (rx214_pos) = rx214_cur."from"()
    inc rx214_pos
    rx214_cur."!cursor_from"(rx214_pos)
    ge rx214_pos, rx214_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  rxscan217_done:
  alt218_0:
.annotate 'line', 57
    set_addr $I10, alt218_1
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 58
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."MARKED"("ws")
    unless $P10, rx214_fail
    goto alt218_end
  alt218_1:
.annotate 'line', 59
  # rx subrule "ww" subtype=zerowidth negate=1
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."ww"()
    if $P10, rx214_fail
.annotate 'line', 64
  # rx rxquantr219 ** 0..*
    set_addr $I10, rxquantr219_done
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  rxquantr219_loop:
  alt220_0:
.annotate 'line', 60
    set_addr $I10, alt220_1
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx214_pos, rx214_off
    set rx214_rep, 0
    sub $I12, rx214_eos, rx214_pos
  rxenumcharlistq221_loop:
    le $I12, 0, rxenumcharlistq221_done
    substr $S10, rx214_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq221_done
    inc rx214_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq221_loop
  rxenumcharlistq221_done:
    lt rx214_rep, 1, rx214_fail
    add rx214_pos, rx214_pos, rx214_rep
    goto alt220_end
  alt220_1:
    set_addr $I10, alt220_2
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 61
  # rx literal  "#"
    add $I11, rx214_pos, 1
    gt $I11, rx214_eos, rx214_fail
    sub $I11, rx214_pos, rx214_off
    ord $I11, rx214_tgt, $I11
    ne $I11, 35, rx214_fail
    add rx214_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx214_pos, rx214_off
    find_cclass $I11, 4096, rx214_tgt, $I10, rx214_eos
    add rx214_pos, rx214_off, $I11
    goto alt220_end
  alt220_2:
    set_addr $I10, alt220_3
    rx214_cur."!mark_push"(0, rx214_pos, $I10)
.annotate 'line', 62
  # rxanchor bol
    eq rx214_pos, 0, rxanchor222_done
    ge rx214_pos, rx214_eos, rx214_fail
    sub $I10, rx214_pos, rx214_off
    dec $I10
    is_cclass $I11, 4096, rx214_tgt, $I10
    unless $I11, rx214_fail
  rxanchor222_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."pod_comment"()
    unless $P10, rx214_fail
    rx214_pos = $P10."pos"()
    goto alt220_end
  alt220_3:
.annotate 'line', 63
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx214_pos, rx214_off
    set rx214_rep, 0
    sub $I12, rx214_eos, rx214_pos
  rxenumcharlistq223_loop:
    le $I12, 0, rxenumcharlistq223_done
    substr $S10, rx214_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq223_done
    inc rx214_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq223_loop
  rxenumcharlistq223_done:
    lt rx214_rep, 1, rx214_fail
    add rx214_pos, rx214_pos, rx214_rep
  alt220_end:
.annotate 'line', 64
    set_addr $I10, rxquantr219_done
    (rx214_rep) = rx214_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr219_done
    rx214_cur."!mark_push"(rx214_rep, rx214_pos, $I10)
    goto rxquantr219_loop
  rxquantr219_done:
.annotate 'line', 65
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx214_cur."!cursor_pos"(rx214_pos)
    $P10 = rx214_cur."MARKER"("ws")
    unless $P10, rx214_fail
  alt218_end:
.annotate 'line', 57
  # rx pass
    rx214_cur."!cursor_pass"(rx214_pos, "ws")
    if_null rx214_debug, debug_637
    rx214_cur."!cursor_debug"("PASS", "ws", " at pos=", rx214_pos)
  debug_637:
    .return (rx214_cur)
  rx214_restart:
.annotate 'line', 10
    if_null rx214_debug, debug_638
    rx214_cur."!cursor_debug"("NEXT", "ws")
  debug_638:
  rx214_fail:
    (rx214_rep, rx214_pos, $I10, $P10) = rx214_cur."!mark_fail"(0)
    lt rx214_pos, -1, rx214_done
    eq rx214_pos, -1, rx214_fail
    jump $I10
  rx214_done:
    rx214_cur."!cursor_fail"()
    if_null rx214_debug, debug_639
    rx214_cur."!cursor_debug"("FAIL", "ws")
  debug_639:
    .return (rx214_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1303923618.727") :method
.annotate 'line', 10
    new $P216, "ResizablePMCArray"
    push $P216, ""
    push $P216, ""
    .return ($P216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P232 = "26_1303923618.727" 
    capture_lex $P232
    .local string rx225_tgt
    .local int rx225_pos
    .local int rx225_off
    .local int rx225_eos
    .local int rx225_rep
    .local pmc rx225_cur
    .local pmc rx225_debug
    (rx225_cur, rx225_pos, rx225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx225_cur
    .local pmc match
    .lex "$/", match
    length rx225_eos, rx225_tgt
    gt rx225_pos, rx225_eos, rx225_done
    set rx225_off, 0
    lt rx225_pos, 2, rx225_start
    sub rx225_off, rx225_pos, 1
    substr rx225_tgt, rx225_tgt, rx225_off
  rx225_start:
    eq $I10, 1, rx225_restart
    if_null rx225_debug, debug_640
    rx225_cur."!cursor_debug"("START", "unv")
  debug_640:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx225_pos) = rx225_cur."from"()
    inc rx225_pos
    rx225_cur."!cursor_from"(rx225_pos)
    ge rx225_pos, rx225_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 70
    set_addr $I10, alt229_1
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 71
  # rxanchor bol
    eq rx225_pos, 0, rxanchor230_done
    ge rx225_pos, rx225_eos, rx225_fail
    sub $I10, rx225_pos, rx225_off
    dec $I10
    is_cclass $I11, 4096, rx225_tgt, $I10
    unless $I11, rx225_fail
  rxanchor230_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    .const 'Sub' $P232 = "26_1303923618.727" 
    capture_lex $P232
    $P10 = rx225_cur."before"($P232)
    unless $P10, rx225_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    $P10 = rx225_cur."pod_comment"()
    unless $P10, rx225_fail
    rx225_pos = $P10."pos"()
    goto alt229_end
  alt229_1:
    set_addr $I10, alt229_2
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 72
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx225_pos, rx225_off
    set rx225_rep, 0
    sub $I12, rx225_eos, rx225_pos
  rxenumcharlistq237_loop:
    le $I12, 0, rxenumcharlistq237_done
    substr $S10, rx225_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq237_done
    inc rx225_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq237_loop
  rxenumcharlistq237_done:
    add rx225_pos, rx225_pos, rx225_rep
  # rx literal  "#"
    add $I11, rx225_pos, 1
    gt $I11, rx225_eos, rx225_fail
    sub $I11, rx225_pos, rx225_off
    ord $I11, rx225_tgt, $I11
    ne $I11, 35, rx225_fail
    add rx225_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx225_pos, rx225_off
    find_cclass $I11, 4096, rx225_tgt, $I10, rx225_eos
    add rx225_pos, rx225_off, $I11
    goto alt229_end
  alt229_2:
.annotate 'line', 73
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx225_pos, rx225_off
    set rx225_rep, 0
    sub $I12, rx225_eos, rx225_pos
  rxenumcharlistq238_loop:
    le $I12, 0, rxenumcharlistq238_done
    substr $S10, rx225_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq238_done
    inc rx225_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq238_loop
  rxenumcharlistq238_done:
    lt rx225_rep, 1, rx225_fail
    add rx225_pos, rx225_pos, rx225_rep
  alt229_end:
.annotate 'line', 68
  # rx pass
    rx225_cur."!cursor_pass"(rx225_pos, "unv")
    if_null rx225_debug, debug_645
    rx225_cur."!cursor_debug"("PASS", "unv", " at pos=", rx225_pos)
  debug_645:
    .return (rx225_cur)
  rx225_restart:
.annotate 'line', 10
    if_null rx225_debug, debug_646
    rx225_cur."!cursor_debug"("NEXT", "unv")
  debug_646:
  rx225_fail:
    (rx225_rep, rx225_pos, $I10, $P10) = rx225_cur."!mark_fail"(0)
    lt rx225_pos, -1, rx225_done
    eq rx225_pos, -1, rx225_fail
    jump $I10
  rx225_done:
    rx225_cur."!cursor_fail"()
    if_null rx225_debug, debug_647
    rx225_cur."!cursor_debug"("FAIL", "unv")
  debug_647:
    .return (rx225_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1303923618.727") :method
.annotate 'line', 10
    new $P227, "ResizablePMCArray"
    push $P227, ""
    push $P227, ""
    push $P227, ""
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block231"  :anon :subid("26_1303923618.727") :method :outer("24_1303923618.727")
.annotate 'line', 71
    .local string rx233_tgt
    .local int rx233_pos
    .local int rx233_off
    .local int rx233_eos
    .local int rx233_rep
    .local pmc rx233_cur
    .local pmc rx233_debug
    (rx233_cur, rx233_pos, rx233_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx233_cur
    .local pmc match
    .lex "$/", match
    length rx233_eos, rx233_tgt
    gt rx233_pos, rx233_eos, rx233_done
    set rx233_off, 0
    lt rx233_pos, 2, rx233_start
    sub rx233_off, rx233_pos, 1
    substr rx233_tgt, rx233_tgt, rx233_off
  rx233_start:
    eq $I10, 1, rx233_restart
    if_null rx233_debug, debug_641
    rx233_cur."!cursor_debug"("START", "")
  debug_641:
    $I10 = self.'from'()
    ne $I10, -1, rxscan234_done
    goto rxscan234_scan
  rxscan234_loop:
    (rx233_pos) = rx233_cur."from"()
    inc rx233_pos
    rx233_cur."!cursor_from"(rx233_pos)
    ge rx233_pos, rx233_eos, rxscan234_done
  rxscan234_scan:
    set_addr $I10, rxscan234_loop
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxscan234_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx233_pos, rx233_off
    set rx233_rep, 0
    sub $I12, rx233_eos, rx233_pos
  rxenumcharlistq235_loop:
    le $I12, 0, rxenumcharlistq235_done
    substr $S10, rx233_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq235_done
    inc rx233_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq235_loop
  rxenumcharlistq235_done:
    add rx233_pos, rx233_pos, rx233_rep
  # rx literal  "="
    add $I11, rx233_pos, 1
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    ord $I11, rx233_tgt, $I11
    ne $I11, 61, rx233_fail
    add rx233_pos, 1
  alt236_0:
    set_addr $I10, alt236_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  # rx charclass w
    ge rx233_pos, rx233_eos, rx233_fail
    sub $I10, rx233_pos, rx233_off
    is_cclass $I11, 8192, rx233_tgt, $I10
    unless $I11, rx233_fail
    inc rx233_pos
    goto alt236_end
  alt236_1:
  # rx literal  "\\"
    add $I11, rx233_pos, 1
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    ord $I11, rx233_tgt, $I11
    ne $I11, 92, rx233_fail
    add rx233_pos, 1
  alt236_end:
  # rx pass
    rx233_cur."!cursor_pass"(rx233_pos, "")
    if_null rx233_debug, debug_642
    rx233_cur."!cursor_debug"("PASS", "", " at pos=", rx233_pos)
  debug_642:
    .return (rx233_cur)
  rx233_restart:
    if_null rx233_debug, debug_643
    rx233_cur."!cursor_debug"("NEXT", "")
  debug_643:
  rx233_fail:
    (rx233_rep, rx233_pos, $I10, $P10) = rx233_cur."!mark_fail"(0)
    lt rx233_pos, -1, rx233_done
    eq rx233_pos, -1, rx233_fail
    jump $I10
  rx233_done:
    rx233_cur."!cursor_fail"()
    if_null rx233_debug, debug_644
    rx233_cur."!cursor_debug"("FAIL", "")
  debug_644:
    .return (rx233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P271 = "29_1303923618.727" 
    capture_lex $P271
    .local string rx240_tgt
    .local int rx240_pos
    .local int rx240_off
    .local int rx240_eos
    .local int rx240_rep
    .local pmc rx240_cur
    .local pmc rx240_debug
    (rx240_cur, rx240_pos, rx240_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx240_cur
    .local pmc match
    .lex "$/", match
    length rx240_eos, rx240_tgt
    gt rx240_pos, rx240_eos, rx240_done
    set rx240_off, 0
    lt rx240_pos, 2, rx240_start
    sub rx240_off, rx240_pos, 1
    substr rx240_tgt, rx240_tgt, rx240_off
  rx240_start:
    eq $I10, 1, rx240_restart
    if_null rx240_debug, debug_648
    rx240_cur."!cursor_debug"("START", "pod_comment")
  debug_648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan243_done
    goto rxscan243_scan
  rxscan243_loop:
    (rx240_pos) = rx240_cur."from"()
    inc rx240_pos
    rx240_cur."!cursor_from"(rx240_pos)
    ge rx240_pos, rx240_eos, rxscan243_done
  rxscan243_scan:
    set_addr $I10, rxscan243_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  rxscan243_done:
.annotate 'line', 78
  # rxanchor bol
    eq rx240_pos, 0, rxanchor244_done
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    dec $I10
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
  rxanchor244_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq245_loop:
    le $I12, 0, rxenumcharlistq245_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq245_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq245_loop
  rxenumcharlistq245_done:
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "="
    add $I11, rx240_pos, 1
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    ord $I11, rx240_tgt, $I11
    ne $I11, 61, rx240_fail
    add rx240_pos, 1
  alt246_0:
.annotate 'line', 79
    set_addr $I10, alt246_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx240_pos, 5
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 5
    ne $S10, "begin", rx240_fail
    add rx240_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq247_loop:
    le $I12, 0, rxenumcharlistq247_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq247_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq247_loop
  rxenumcharlistq247_done:
    lt rx240_rep, 1, rx240_fail
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "END"
    add $I11, rx240_pos, 3
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 3
    ne $S10, "END", rx240_fail
    add rx240_pos, 3
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  alt248_0:
.annotate 'line', 81
    set_addr $I10, alt248_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rx rxquantf249 ** 0..*
    set_addr $I10, rxquantf249_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
    goto rxquantf249_done
  rxquantf249_loop:
  # rx charclass .
    ge rx240_pos, rx240_eos, rx240_fail
    inc rx240_pos
    set_addr $I10, rxquantf249_loop
    rx240_cur."!mark_push"(rx240_rep, rx240_pos, $I10)
  rxquantf249_done:
  # rx charclass nl
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
    substr $S10, rx240_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx240_pos, $I11
    inc rx240_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq251_loop:
    le $I12, 0, rxenumcharlistq251_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq251_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq251_loop
  rxenumcharlistq251_done:
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "=end"
    add $I11, rx240_pos, 4
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 4
    ne $S10, "=end", rx240_fail
    add rx240_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq252_loop:
    le $I12, 0, rxenumcharlistq252_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq252_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq252_loop
  rxenumcharlistq252_done:
    lt rx240_rep, 1, rx240_fail
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "END"
    add $I11, rx240_pos, 3
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 3
    ne $S10, "END", rx240_fail
    add rx240_pos, 3
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_cclass $I11, 4096, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
    goto alt248_end
  alt248_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_not_cclass $I11, 65535, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
  alt248_end:
.annotate 'line', 80
    goto alt246_end
  alt246_1:
    set_addr $I10, alt246_2
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 82
  # rx literal  "begin"
    add $I11, rx240_pos, 5
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 5
    ne $S10, "begin", rx240_fail
    add rx240_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq253_loop:
    le $I12, 0, rxenumcharlistq253_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq253_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq253_loop
  rxenumcharlistq253_done:
    lt rx240_rep, 1, rx240_fail
    add rx240_pos, rx240_pos, rx240_rep
  # rx subrule "identifier" subtype=capture negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."identifier"()
    unless $P10, rx240_fail
    rx240_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx240_pos = $P10."pos"()
  alt254_0:
.annotate 'line', 83
    set_addr $I10, alt254_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 84
  # rx rxquantf255 ** 0..*
    set_addr $I10, rxquantf255_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
    goto rxquantf255_done
  rxquantf255_loop:
  # rx charclass .
    ge rx240_pos, rx240_eos, rx240_fail
    inc rx240_pos
    set_addr $I10, rxquantf255_loop
    rx240_cur."!mark_push"(rx240_rep, rx240_pos, $I10)
  rxquantf255_done:
  # rx charclass nl
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
    substr $S10, rx240_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx240_pos, $I11
    inc rx240_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq257_loop:
    le $I12, 0, rxenumcharlistq257_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq257_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq257_loop
  rxenumcharlistq257_done:
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "=end"
    add $I11, rx240_pos, 4
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 4
    ne $S10, "=end", rx240_fail
    add rx240_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq258_loop:
    le $I12, 0, rxenumcharlistq258_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq258_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq258_loop
  rxenumcharlistq258_done:
    lt rx240_rep, 1, rx240_fail
    add rx240_pos, rx240_pos, rx240_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."!BACKREF"("identifier")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_cclass $I11, 4096, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
    goto alt254_end
  alt254_1:
.annotate 'line', 85
  # rx subrule "panic" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."panic"("=begin without matching =end")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  alt254_end:
.annotate 'line', 82
    goto alt246_end
  alt246_2:
    set_addr $I10, alt246_3
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx240_pos, 5
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 5
    ne $S10, "begin", rx240_fail
    add rx240_pos, 5
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq260_loop:
    le $I12, 0, rxenumcharlistq260_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq260_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq260_loop
  rxenumcharlistq260_done:
    add rx240_pos, rx240_pos, rx240_rep
  alt261_0:
.annotate 'line', 88
    set_addr $I10, alt261_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rxanchor eol
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 4096, rx240_tgt, $I10
    if $I11, rxanchor262_done
    ne rx240_pos, rx240_eos, rx240_fail
    eq rx240_pos, 0, rxanchor262_done
    dec $I10
    is_cclass $I11, 4096, rx240_tgt, $I10
    if $I11, rx240_fail
  rxanchor262_done:
    goto alt261_end
  alt261_1:
    set_addr $I10, alt261_2
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rx literal  "#"
    add $I11, rx240_pos, 1
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    ord $I11, rx240_tgt, $I11
    ne $I11, 35, rx240_fail
    add rx240_pos, 1
    goto alt261_end
  alt261_2:
  # rx subrule "panic" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  alt261_end:
  alt263_0:
.annotate 'line', 89
    set_addr $I10, alt263_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 90
  # rx rxquantf264 ** 0..*
    set_addr $I10, rxquantf264_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
    goto rxquantf264_done
  rxquantf264_loop:
  # rx charclass .
    ge rx240_pos, rx240_eos, rx240_fail
    inc rx240_pos
    set_addr $I10, rxquantf264_loop
    rx240_cur."!mark_push"(rx240_rep, rx240_pos, $I10)
  rxquantf264_done:
  # rx charclass nl
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
    substr $S10, rx240_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx240_pos, $I11
    inc rx240_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx240_pos, rx240_off
    set rx240_rep, 0
    sub $I12, rx240_eos, rx240_pos
  rxenumcharlistq266_loop:
    le $I12, 0, rxenumcharlistq266_done
    substr $S10, rx240_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq266_done
    inc rx240_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq266_loop
  rxenumcharlistq266_done:
    add rx240_pos, rx240_pos, rx240_rep
  # rx literal  "=end"
    add $I11, rx240_pos, 4
    gt $I11, rx240_eos, rx240_fail
    sub $I11, rx240_pos, rx240_off
    substr $S10, rx240_tgt, $I11, 4
    ne $S10, "=end", rx240_fail
    add rx240_pos, 4
  # rxanchor rwb
    le rx240_pos, 0, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 8192, rx240_tgt, $I10
    if $I11, rx240_fail
    dec $I10
    is_cclass $I11, 8192, rx240_tgt, $I10
    unless $I11, rx240_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_cclass $I11, 4096, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
    goto alt263_end
  alt263_1:
.annotate 'line', 91
  # rx subrule "panic" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."panic"("=begin without matching =end")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  alt263_end:
.annotate 'line', 87
    goto alt246_end
  alt246_3:
    set_addr $I10, alt246_4
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
.annotate 'line', 93
  # rx subrule "identifier" subtype=capture negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."identifier"()
    unless $P10, rx240_fail
    rx240_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx240_pos = $P10."pos"()
.annotate 'line', 94
  # rx rxquantf267 ** 0..*
    set_addr $I10, rxquantf267_loop
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
    goto rxquantf267_done
  rxquantf267_loop:
  # rx charclass .
    ge rx240_pos, rx240_eos, rx240_fail
    inc rx240_pos
    set_addr $I10, rxquantf267_loop
    rx240_cur."!mark_push"(rx240_rep, rx240_pos, $I10)
  rxquantf267_done:
  # rxanchor bol
    eq rx240_pos, 0, rxanchor269_done
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    dec $I10
    is_cclass $I11, 4096, rx240_tgt, $I10
    unless $I11, rx240_fail
  rxanchor269_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    .const 'Sub' $P271 = "29_1303923618.727" 
    capture_lex $P271
    $P10 = rx240_cur."before"($P271)
    unless $P10, rx240_fail
.annotate 'line', 93
    goto alt246_end
  alt246_4:
  alt277_0:
.annotate 'line', 100
    set_addr $I10, alt277_1
    rx240_cur."!mark_push"(0, rx240_pos, $I10)
  # rx charclass s
    ge rx240_pos, rx240_eos, rx240_fail
    sub $I10, rx240_pos, rx240_off
    is_cclass $I11, 32, rx240_tgt, $I10
    unless $I11, rx240_fail
    inc rx240_pos
    goto alt277_end
  alt277_1:
  # rx subrule "panic" subtype=method negate=
    rx240_cur."!cursor_pos"(rx240_pos)
    $P10 = rx240_cur."panic"("Illegal pod directive")
    unless $P10, rx240_fail
    rx240_pos = $P10."pos"()
  alt277_end:
.annotate 'line', 101
  # rx charclass_q N r 0..-1
    sub $I10, rx240_pos, rx240_off
    find_cclass $I11, 4096, rx240_tgt, $I10, rx240_eos
    add rx240_pos, rx240_off, $I11
  alt246_end:
.annotate 'line', 77
  # rx pass
    rx240_cur."!cursor_pass"(rx240_pos, "pod_comment")
    if_null rx240_debug, debug_653
    rx240_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx240_pos)
  debug_653:
    .return (rx240_cur)
  rx240_restart:
.annotate 'line', 10
    if_null rx240_debug, debug_654
    rx240_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_654:
  rx240_fail:
    (rx240_rep, rx240_pos, $I10, $P10) = rx240_cur."!mark_fail"(0)
    lt rx240_pos, -1, rx240_done
    eq rx240_pos, -1, rx240_fail
    jump $I10
  rx240_done:
    rx240_cur."!cursor_fail"()
    if_null rx240_debug, debug_655
    rx240_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_655:
    .return (rx240_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1303923618.727") :method
.annotate 'line', 10
    new $P242, "ResizablePMCArray"
    push $P242, ""
    .return ($P242)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block270"  :anon :subid("29_1303923618.727") :method :outer("27_1303923618.727")
.annotate 'line', 94
    .local string rx272_tgt
    .local int rx272_pos
    .local int rx272_off
    .local int rx272_eos
    .local int rx272_rep
    .local pmc rx272_cur
    .local pmc rx272_debug
    (rx272_cur, rx272_pos, rx272_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx272_cur
    .local pmc match
    .lex "$/", match
    length rx272_eos, rx272_tgt
    gt rx272_pos, rx272_eos, rx272_done
    set rx272_off, 0
    lt rx272_pos, 2, rx272_start
    sub rx272_off, rx272_pos, 1
    substr rx272_tgt, rx272_tgt, rx272_off
  rx272_start:
    eq $I10, 1, rx272_restart
    if_null rx272_debug, debug_649
    rx272_cur."!cursor_debug"("START", "")
  debug_649:
    $I10 = self.'from'()
    ne $I10, -1, rxscan273_done
    goto rxscan273_scan
  rxscan273_loop:
    (rx272_pos) = rx272_cur."from"()
    inc rx272_pos
    rx272_cur."!cursor_from"(rx272_pos)
    ge rx272_pos, rx272_eos, rxscan273_done
  rxscan273_scan:
    set_addr $I10, rxscan273_loop
    rx272_cur."!mark_push"(0, rx272_pos, $I10)
  rxscan273_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx272_pos, rx272_off
    set rx272_rep, 0
    sub $I12, rx272_eos, rx272_pos
  rxenumcharlistq274_loop:
    le $I12, 0, rxenumcharlistq274_done
    substr $S10, rx272_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq274_done
    inc rx272_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq274_loop
  rxenumcharlistq274_done:
    add rx272_pos, rx272_pos, rx272_rep
  alt275_0:
    set_addr $I10, alt275_1
    rx272_cur."!mark_push"(0, rx272_pos, $I10)
.annotate 'line', 95
  # rx literal  "="
    add $I11, rx272_pos, 1
    gt $I11, rx272_eos, rx272_fail
    sub $I11, rx272_pos, rx272_off
    ord $I11, rx272_tgt, $I11
    ne $I11, 61, rx272_fail
    add rx272_pos, 1
.annotate 'line', 97
  # rx rxquantr276 ** 0..1
    set_addr $I10, rxquantr276_done
    rx272_cur."!mark_push"(0, rx272_pos, $I10)
  rxquantr276_loop:
.annotate 'line', 96
  # rx literal  "cut"
    add $I11, rx272_pos, 3
    gt $I11, rx272_eos, rx272_fail
    sub $I11, rx272_pos, rx272_off
    substr $S10, rx272_tgt, $I11, 3
    ne $S10, "cut", rx272_fail
    add rx272_pos, 3
  # rxanchor rwb
    le rx272_pos, 0, rx272_fail
    sub $I10, rx272_pos, rx272_off
    is_cclass $I11, 8192, rx272_tgt, $I10
    if $I11, rx272_fail
    dec $I10
    is_cclass $I11, 8192, rx272_tgt, $I10
    unless $I11, rx272_fail
.annotate 'line', 97
  # rx subrule "panic" subtype=method negate=
    rx272_cur."!cursor_pos"(rx272_pos)
    $P10 = rx272_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx272_fail
    rx272_pos = $P10."pos"()
    set_addr $I10, rxquantr276_done
    (rx272_rep) = rx272_cur."!mark_commit"($I10)
  rxquantr276_done:
.annotate 'line', 94
    goto alt275_end
  alt275_1:
.annotate 'line', 98
  # rx charclass nl
    ge rx272_pos, rx272_eos, rx272_fail
    sub $I10, rx272_pos, rx272_off
    is_cclass $I11, 4096, rx272_tgt, $I10
    unless $I11, rx272_fail
    substr $S10, rx272_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx272_pos, $I11
    inc rx272_pos
  alt275_end:
.annotate 'line', 94
  # rx pass
    rx272_cur."!cursor_pass"(rx272_pos, "")
    if_null rx272_debug, debug_650
    rx272_cur."!cursor_debug"("PASS", "", " at pos=", rx272_pos)
  debug_650:
    .return (rx272_cur)
  rx272_restart:
    if_null rx272_debug, debug_651
    rx272_cur."!cursor_debug"("NEXT", "")
  debug_651:
  rx272_fail:
    (rx272_rep, rx272_pos, $I10, $P10) = rx272_cur."!mark_fail"(0)
    lt rx272_pos, -1, rx272_done
    eq rx272_pos, -1, rx272_fail
    jump $I10
  rx272_done:
    rx272_cur."!cursor_fail"()
    if_null rx272_debug, debug_652
    rx272_cur."!cursor_debug"("FAIL", "")
  debug_652:
    .return (rx272_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 109
    new $P279, "Undef"
    .lex "$*IN_DECL", $P279
.annotate 'line', 111
    new $P280, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P280
.annotate 'line', 112
    new $P281, "Undef"
    .lex "$*MAIN_SUB", $P281
.annotate 'line', 115
    new $P282, "Undef"
    .lex "$*PACKAGE", $P282
.annotate 'line', 116
    new $P283, "Undef"
    .lex "$*GLOBALish", $P283
.annotate 'line', 10
    .local string rx284_tgt
    .local int rx284_pos
    .local int rx284_off
    .local int rx284_eos
    .local int rx284_rep
    .local pmc rx284_cur
    .local pmc rx284_debug
    (rx284_cur, rx284_pos, rx284_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx284_cur
    .local pmc match
    .lex "$/", match
    length rx284_eos, rx284_tgt
    gt rx284_pos, rx284_eos, rx284_done
    set rx284_off, 0
    lt rx284_pos, 2, rx284_start
    sub rx284_off, rx284_pos, 1
    substr rx284_tgt, rx284_tgt, rx284_off
  rx284_start:
    eq $I10, 1, rx284_restart
    if_null rx284_debug, debug_656
    rx284_cur."!cursor_debug"("START", "comp_unit")
  debug_656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan288_done
    goto rxscan288_scan
  rxscan288_loop:
    (rx284_pos) = rx284_cur."from"()
    inc rx284_pos
    rx284_cur."!cursor_from"(rx284_pos)
    ge rx284_pos, rx284_eos, rxscan288_done
  rxscan288_scan:
    set_addr $I10, rxscan288_loop
    rx284_cur."!mark_push"(0, rx284_pos, $I10)
  rxscan288_done:
.annotate 'line', 109
    rx284_cur."!cursor_pos"(rx284_pos)
    new $P289, "String"
    assign $P289, ""
    store_lex "$*IN_DECL", $P289
.annotate 'line', 111
    rx284_cur."!cursor_pos"(rx284_pos)
    new $P290, "Integer"
    assign $P290, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P290
.annotate 'line', 112
    rx284_cur."!cursor_pos"(rx284_pos)
    find_lex $P293, "$*MAIN_SUB"
    unless_null $P293, vivify_657
    get_hll_global $P291, "GLOBAL"
    get_who $P292, $P291
    set $P293, $P292["$MAIN_SUB"]
    unless_null $P293, vivify_658
    die "Contextual $*MAIN_SUB not found"
  vivify_658:
  vivify_657:
.annotate 'line', 113
  # rx subrule "newpad" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."newpad"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
.annotate 'line', 115
    rx284_cur."!cursor_pos"(rx284_pos)
    find_lex $P296, "$*PACKAGE"
    unless_null $P296, vivify_659
    get_hll_global $P294, "GLOBAL"
    get_who $P295, $P294
    set $P296, $P295["$PACKAGE"]
    unless_null $P296, vivify_660
    die "Contextual $*PACKAGE not found"
  vivify_660:
  vivify_659:
.annotate 'line', 116
    rx284_cur."!cursor_pos"(rx284_pos)
    find_lex $P299, "$*GLOBALish"
    unless_null $P299, vivify_661
    get_hll_global $P297, "GLOBAL"
    get_who $P298, $P297
    set $P299, $P298["$GLOBALish"]
    unless_null $P299, vivify_662
    die "Contextual $*GLOBALish not found"
  vivify_662:
  vivify_661:
.annotate 'line', 117
  # rx subrule "GLOBALish" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."GLOBALish"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."outerctx"()
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
.annotate 'line', 121
  # rx subrule "statementlist" subtype=capture negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."statementlist"()
    unless $P10, rx284_fail
    rx284_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx284_pos = $P10."pos"()
  alt300_0:
.annotate 'line', 122
    set_addr $I10, alt300_1
    rx284_cur."!mark_push"(0, rx284_pos, $I10)
  # rxanchor eos
    ne rx284_pos, rx284_eos, rx284_fail
    goto alt300_end
  alt300_1:
  # rx subrule "panic" subtype=method negate=
    rx284_cur."!cursor_pos"(rx284_pos)
    $P10 = rx284_cur."panic"("Confused")
    unless $P10, rx284_fail
    rx284_pos = $P10."pos"()
  alt300_end:
.annotate 'line', 108
  # rx pass
    rx284_cur."!cursor_pass"(rx284_pos, "comp_unit")
    if_null rx284_debug, debug_663
    rx284_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx284_pos)
  debug_663:
    .return (rx284_cur)
  rx284_restart:
.annotate 'line', 10
    if_null rx284_debug, debug_664
    rx284_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_664:
  rx284_fail:
    (rx284_rep, rx284_pos, $I10, $P10) = rx284_cur."!mark_fail"(0)
    lt rx284_pos, -1, rx284_done
    eq rx284_pos, -1, rx284_fail
    jump $I10
  rx284_done:
    rx284_cur."!cursor_fail"()
    if_null rx284_debug, debug_665
    rx284_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_665:
    .return (rx284_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1303923618.727") :method
.annotate 'line', 10
    $P286 = self."!PREFIX__!subrule"("newpad", "")
    new $P287, "ResizablePMCArray"
    push $P287, $P286
    .return ($P287)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx302_tgt
    .local int rx302_pos
    .local int rx302_off
    .local int rx302_eos
    .local int rx302_rep
    .local pmc rx302_cur
    .local pmc rx302_debug
    (rx302_cur, rx302_pos, rx302_tgt, $I10) = self."!cursor_start"()
    rx302_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx302_cur
    .local pmc match
    .lex "$/", match
    length rx302_eos, rx302_tgt
    gt rx302_pos, rx302_eos, rx302_done
    set rx302_off, 0
    lt rx302_pos, 2, rx302_start
    sub rx302_off, rx302_pos, 1
    substr rx302_tgt, rx302_tgt, rx302_off
  rx302_start:
    eq $I10, 1, rx302_restart
    if_null rx302_debug, debug_666
    rx302_cur."!cursor_debug"("START", "statementlist")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan307_done
    goto rxscan307_scan
  rxscan307_loop:
    (rx302_pos) = rx302_cur."from"()
    inc rx302_pos
    rx302_cur."!cursor_from"(rx302_pos)
    ge rx302_pos, rx302_eos, rxscan307_done
  rxscan307_scan:
    set_addr $I10, rxscan307_loop
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxscan307_done:
  alt308_0:
.annotate 'line', 125
    set_addr $I10, alt308_1
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
.annotate 'line', 126
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rxanchor eos
    ne rx302_pos, rx302_eos, rx302_fail
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
    goto alt308_end
  alt308_1:
.annotate 'line', 127
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rx rxquantr312 ** 0..*
    set_addr $I10, rxquantr312_done
    rx302_cur."!mark_push"(0, rx302_pos, $I10)
  rxquantr312_loop:
  # rx subrule "statement" subtype=capture negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."statement"()
    unless $P10, rx302_fail
    rx302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx302_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."eat_terminator"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
    set_addr $I10, rxquantr312_done
    (rx302_rep) = rx302_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr312_done
    rx302_cur."!mark_push"(rx302_rep, rx302_pos, $I10)
    goto rxquantr312_loop
  rxquantr312_done:
  # rx subrule "ws" subtype=method negate=
    rx302_cur."!cursor_pos"(rx302_pos)
    $P10 = rx302_cur."ws"()
    unless $P10, rx302_fail
    rx302_pos = $P10."pos"()
  alt308_end:
.annotate 'line', 125
  # rx pass
    rx302_cur."!cursor_pass"(rx302_pos, "statementlist")
    if_null rx302_debug, debug_667
    rx302_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx302_pos)
  debug_667:
    .return (rx302_cur)
  rx302_restart:
.annotate 'line', 10
    if_null rx302_debug, debug_668
    rx302_cur."!cursor_debug"("NEXT", "statementlist")
  debug_668:
  rx302_fail:
    (rx302_rep, rx302_pos, $I10, $P10) = rx302_cur."!mark_fail"(0)
    lt rx302_pos, -1, rx302_done
    eq rx302_pos, -1, rx302_fail
    jump $I10
  rx302_done:
    rx302_cur."!cursor_fail"()
    if_null rx302_debug, debug_669
    rx302_cur."!cursor_debug"("FAIL", "statementlist")
  debug_669:
    .return (rx302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1303923618.727") :method
.annotate 'line', 10
    $P304 = self."!PREFIX__!subrule"("ws", "")
    $P305 = self."!PREFIX__!subrule"("ws", "")
    new $P306, "ResizablePMCArray"
    push $P306, $P304
    push $P306, $P305
    .return ($P306)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P321 = "36_1303923618.727" 
    capture_lex $P321
    .local string rx316_tgt
    .local int rx316_pos
    .local int rx316_off
    .local int rx316_eos
    .local int rx316_rep
    .local pmc rx316_cur
    .local pmc rx316_debug
    (rx316_cur, rx316_pos, rx316_tgt, $I10) = self."!cursor_start"()
    rx316_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx316_cur
    .local pmc match
    .lex "$/", match
    length rx316_eos, rx316_tgt
    gt rx316_pos, rx316_eos, rx316_done
    set rx316_off, 0
    lt rx316_pos, 2, rx316_start
    sub rx316_off, rx316_pos, 1
    substr rx316_tgt, rx316_tgt, rx316_off
  rx316_start:
    eq $I10, 1, rx316_restart
    if_null rx316_debug, debug_670
    rx316_cur."!cursor_debug"("START", "statement")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan319_done
    goto rxscan319_scan
  rxscan319_loop:
    (rx316_pos) = rx316_cur."from"()
    inc rx316_pos
    rx316_cur."!cursor_from"(rx316_pos)
    ge rx316_pos, rx316_eos, rxscan319_done
  rxscan319_scan:
    set_addr $I10, rxscan319_loop
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  rxscan319_done:
.annotate 'line', 131
  # rx subrule "before" subtype=zerowidth negate=1
    rx316_cur."!cursor_pos"(rx316_pos)
    .const 'Sub' $P321 = "36_1303923618.727" 
    capture_lex $P321
    $P10 = rx316_cur."before"($P321)
    if $P10, rx316_fail
  alt325_0:
.annotate 'line', 132
    set_addr $I10, alt325_1
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
.annotate 'line', 133
  # rx subrule "statement_control" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."statement_control"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx316_pos = $P10."pos"()
    goto alt325_end
  alt325_1:
.annotate 'line', 134
  # rx subrule "EXPR" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."EXPR"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx316_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."ws"()
    unless $P10, rx316_fail
    rx316_pos = $P10."pos"()
.annotate 'line', 139
  # rx rxquantr326 ** 0..1
    set_addr $I10, rxquantr326_done
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  rxquantr326_loop:
  alt327_0:
.annotate 'line', 135
    set_addr $I10, alt327_1
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
.annotate 'line', 136
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."MARKED"("endstmt")
    unless $P10, rx316_fail
    goto alt327_end
  alt327_1:
    set_addr $I10, alt327_2
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."statement_mod_cond"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx316_pos = $P10."pos"()
  # rx rxquantr328 ** 0..1
    set_addr $I10, rxquantr328_done
    rx316_cur."!mark_push"(0, rx316_pos, $I10)
  rxquantr328_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."statement_mod_loop"()
    unless $P10, rx316_fail
    goto rxsubrule329_pass
  rxsubrule329_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx316_fail
  rxsubrule329_pass:
    set_addr $I10, rxsubrule329_back
    rx316_cur."!mark_push"(0, rx316_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx316_pos = $P10."pos"()
    set_addr $I10, rxquantr328_done
    (rx316_rep) = rx316_cur."!mark_commit"($I10)
  rxquantr328_done:
    goto alt327_end
  alt327_2:
.annotate 'line', 138
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx316_cur."!cursor_pos"(rx316_pos)
    $P10 = rx316_cur."statement_mod_loop"()
    unless $P10, rx316_fail
    rx316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx316_pos = $P10."pos"()
  alt327_end:
.annotate 'line', 139
    set_addr $I10, rxquantr326_done
    (rx316_rep) = rx316_cur."!mark_commit"($I10)
  rxquantr326_done:
  alt325_end:
.annotate 'line', 130
  # rx pass
    rx316_cur."!cursor_pass"(rx316_pos, "statement")
    if_null rx316_debug, debug_675
    rx316_cur."!cursor_debug"("PASS", "statement", " at pos=", rx316_pos)
  debug_675:
    .return (rx316_cur)
  rx316_restart:
.annotate 'line', 10
    if_null rx316_debug, debug_676
    rx316_cur."!cursor_debug"("NEXT", "statement")
  debug_676:
  rx316_fail:
    (rx316_rep, rx316_pos, $I10, $P10) = rx316_cur."!mark_fail"(0)
    lt rx316_pos, -1, rx316_done
    eq rx316_pos, -1, rx316_fail
    jump $I10
  rx316_done:
    rx316_cur."!cursor_fail"()
    if_null rx316_debug, debug_677
    rx316_cur."!cursor_debug"("FAIL", "statement")
  debug_677:
    .return (rx316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1303923618.727") :method
.annotate 'line', 10
    new $P318, "ResizablePMCArray"
    push $P318, ""
    .return ($P318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block320"  :anon :subid("36_1303923618.727") :method :outer("34_1303923618.727")
.annotate 'line', 131
    .local string rx322_tgt
    .local int rx322_pos
    .local int rx322_off
    .local int rx322_eos
    .local int rx322_rep
    .local pmc rx322_cur
    .local pmc rx322_debug
    (rx322_cur, rx322_pos, rx322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx322_cur
    .local pmc match
    .lex "$/", match
    length rx322_eos, rx322_tgt
    gt rx322_pos, rx322_eos, rx322_done
    set rx322_off, 0
    lt rx322_pos, 2, rx322_start
    sub rx322_off, rx322_pos, 1
    substr rx322_tgt, rx322_tgt, rx322_off
  rx322_start:
    eq $I10, 1, rx322_restart
    if_null rx322_debug, debug_671
    rx322_cur."!cursor_debug"("START", "")
  debug_671:
    $I10 = self.'from'()
    ne $I10, -1, rxscan323_done
    goto rxscan323_scan
  rxscan323_loop:
    (rx322_pos) = rx322_cur."from"()
    inc rx322_pos
    rx322_cur."!cursor_from"(rx322_pos)
    ge rx322_pos, rx322_eos, rxscan323_done
  rxscan323_scan:
    set_addr $I10, rxscan323_loop
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  rxscan323_done:
  alt324_0:
    set_addr $I10, alt324_1
    rx322_cur."!mark_push"(0, rx322_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx322_pos, rx322_eos, rx322_fail
    sub $I10, rx322_pos, rx322_off
    substr $S10, rx322_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx322_fail
    inc rx322_pos
    goto alt324_end
  alt324_1:
  # rxanchor eos
    ne rx322_pos, rx322_eos, rx322_fail
  alt324_end:
  # rx pass
    rx322_cur."!cursor_pass"(rx322_pos, "")
    if_null rx322_debug, debug_672
    rx322_cur."!cursor_debug"("PASS", "", " at pos=", rx322_pos)
  debug_672:
    .return (rx322_cur)
  rx322_restart:
    if_null rx322_debug, debug_673
    rx322_cur."!cursor_debug"("NEXT", "")
  debug_673:
  rx322_fail:
    (rx322_rep, rx322_pos, $I10, $P10) = rx322_cur."!mark_fail"(0)
    lt rx322_pos, -1, rx322_done
    eq rx322_pos, -1, rx322_fail
    jump $I10
  rx322_done:
    rx322_cur."!cursor_fail"()
    if_null rx322_debug, debug_674
    rx322_cur."!cursor_debug"("FAIL", "")
  debug_674:
    .return (rx322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx331_tgt
    .local int rx331_pos
    .local int rx331_off
    .local int rx331_eos
    .local int rx331_rep
    .local pmc rx331_cur
    .local pmc rx331_debug
    (rx331_cur, rx331_pos, rx331_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx331_cur
    .local pmc match
    .lex "$/", match
    length rx331_eos, rx331_tgt
    gt rx331_pos, rx331_eos, rx331_done
    set rx331_off, 0
    lt rx331_pos, 2, rx331_start
    sub rx331_off, rx331_pos, 1
    substr rx331_tgt, rx331_tgt, rx331_off
  rx331_start:
    eq $I10, 1, rx331_restart
    if_null rx331_debug, debug_678
    rx331_cur."!cursor_debug"("START", "eat_terminator")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan334_done
    goto rxscan334_scan
  rxscan334_loop:
    (rx331_pos) = rx331_cur."from"()
    inc rx331_pos
    rx331_cur."!cursor_from"(rx331_pos)
    ge rx331_pos, rx331_eos, rxscan334_done
  rxscan334_scan:
    set_addr $I10, rxscan334_loop
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
  rxscan334_done:
  alt335_0:
.annotate 'line', 143
    set_addr $I10, alt335_1
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
.annotate 'line', 144
  # rx literal  ";"
    add $I11, rx331_pos, 1
    gt $I11, rx331_eos, rx331_fail
    sub $I11, rx331_pos, rx331_off
    ord $I11, rx331_tgt, $I11
    ne $I11, 59, rx331_fail
    add rx331_pos, 1
    goto alt335_end
  alt335_1:
    set_addr $I10, alt335_2
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
.annotate 'line', 145
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx331_cur."!cursor_pos"(rx331_pos)
    $P10 = rx331_cur."MARKED"("endstmt")
    unless $P10, rx331_fail
    goto alt335_end
  alt335_2:
    set_addr $I10, alt335_3
    rx331_cur."!mark_push"(0, rx331_pos, $I10)
.annotate 'line', 146
  # rx subrule "terminator" subtype=zerowidth negate=
    rx331_cur."!cursor_pos"(rx331_pos)
    $P10 = rx331_cur."terminator"()
    unless $P10, rx331_fail
    goto alt335_end
  alt335_3:
.annotate 'line', 147
  # rxanchor eos
    ne rx331_pos, rx331_eos, rx331_fail
  alt335_end:
.annotate 'line', 143
  # rx pass
    rx331_cur."!cursor_pass"(rx331_pos, "eat_terminator")
    if_null rx331_debug, debug_679
    rx331_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx331_pos)
  debug_679:
    .return (rx331_cur)
  rx331_restart:
.annotate 'line', 10
    if_null rx331_debug, debug_680
    rx331_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_680:
  rx331_fail:
    (rx331_rep, rx331_pos, $I10, $P10) = rx331_cur."!mark_fail"(0)
    lt rx331_pos, -1, rx331_done
    eq rx331_pos, -1, rx331_fail
    jump $I10
  rx331_done:
    rx331_cur."!cursor_fail"()
    if_null rx331_debug, debug_681
    rx331_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_681:
    .return (rx331_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1303923618.727") :method
.annotate 'line', 10
    new $P333, "ResizablePMCArray"
    push $P333, ""
    push $P333, ""
    push $P333, ""
    push $P333, ";"
    .return ($P333)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx337_tgt
    .local int rx337_pos
    .local int rx337_off
    .local int rx337_eos
    .local int rx337_rep
    .local pmc rx337_cur
    .local pmc rx337_debug
    (rx337_cur, rx337_pos, rx337_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx337_cur
    .local pmc match
    .lex "$/", match
    length rx337_eos, rx337_tgt
    gt rx337_pos, rx337_eos, rx337_done
    set rx337_off, 0
    lt rx337_pos, 2, rx337_start
    sub rx337_off, rx337_pos, 1
    substr rx337_tgt, rx337_tgt, rx337_off
  rx337_start:
    eq $I10, 1, rx337_restart
    if_null rx337_debug, debug_682
    rx337_cur."!cursor_debug"("START", "xblock")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan341_done
    goto rxscan341_scan
  rxscan341_loop:
    (rx337_pos) = rx337_cur."from"()
    inc rx337_pos
    rx337_cur."!cursor_from"(rx337_pos)
    ge rx337_pos, rx337_eos, rxscan341_done
  rxscan341_scan:
    set_addr $I10, rxscan341_loop
    rx337_cur."!mark_push"(0, rx337_pos, $I10)
  rxscan341_done:
.annotate 'line', 151
  # rx subrule "EXPR" subtype=capture negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."EXPR"()
    unless $P10, rx337_fail
    rx337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx337_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."ws"()
    unless $P10, rx337_fail
    rx337_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx337_cur."!cursor_pos"(rx337_pos)
    $P10 = rx337_cur."pblock"()
    unless $P10, rx337_fail
    rx337_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx337_pos = $P10."pos"()
.annotate 'line', 150
  # rx pass
    rx337_cur."!cursor_pass"(rx337_pos, "xblock")
    if_null rx337_debug, debug_683
    rx337_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx337_pos)
  debug_683:
    .return (rx337_cur)
  rx337_restart:
.annotate 'line', 10
    if_null rx337_debug, debug_684
    rx337_cur."!cursor_debug"("NEXT", "xblock")
  debug_684:
  rx337_fail:
    (rx337_rep, rx337_pos, $I10, $P10) = rx337_cur."!mark_fail"(0)
    lt rx337_pos, -1, rx337_done
    eq rx337_pos, -1, rx337_fail
    jump $I10
  rx337_done:
    rx337_cur."!cursor_fail"()
    if_null rx337_debug, debug_685
    rx337_cur."!cursor_debug"("FAIL", "xblock")
  debug_685:
    .return (rx337_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1303923618.727") :method
.annotate 'line', 10
    $P339 = self."!PREFIX__!subrule"("EXPR", "")
    new $P340, "ResizablePMCArray"
    push $P340, $P339
    .return ($P340)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx343_tgt
    .local int rx343_pos
    .local int rx343_off
    .local int rx343_eos
    .local int rx343_rep
    .local pmc rx343_cur
    .local pmc rx343_debug
    (rx343_cur, rx343_pos, rx343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx343_cur
    .local pmc match
    .lex "$/", match
    length rx343_eos, rx343_tgt
    gt rx343_pos, rx343_eos, rx343_done
    set rx343_off, 0
    lt rx343_pos, 2, rx343_start
    sub rx343_off, rx343_pos, 1
    substr rx343_tgt, rx343_tgt, rx343_off
  rx343_start:
    eq $I10, 1, rx343_restart
    if_null rx343_debug, debug_686
    rx343_cur."!cursor_debug"("START", "pblock")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan348_done
    goto rxscan348_scan
  rxscan348_loop:
    (rx343_pos) = rx343_cur."from"()
    inc rx343_pos
    rx343_cur."!cursor_from"(rx343_pos)
    ge rx343_pos, rx343_eos, rxscan348_done
  rxscan348_scan:
    set_addr $I10, rxscan348_loop
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
  rxscan348_done:
  alt349_0:
.annotate 'line', 154
    set_addr $I10, alt349_1
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
.annotate 'line', 155
  # rx subrule "lambda" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."lambda"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
.annotate 'line', 156
  # rx subrule "newpad" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."newpad"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "signature" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."signature"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx343_pos = $P10."pos"()
.annotate 'line', 158
  # rx subrule "blockoid" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."blockoid"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx343_pos = $P10."pos"()
.annotate 'line', 155
    goto alt349_end
  alt349_1:
    set_addr $I10, alt349_2
    rx343_cur."!mark_push"(0, rx343_pos, $I10)
.annotate 'line', 159
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx343_pos, rx343_off
    substr $S10, rx343_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx343_fail
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."newpad"()
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "blockoid" subtype=capture negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."blockoid"()
    unless $P10, rx343_fail
    rx343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx343_pos = $P10."pos"()
.annotate 'line', 159
    goto alt349_end
  alt349_2:
.annotate 'line', 162
  # rx subrule "panic" subtype=method negate=
    rx343_cur."!cursor_pos"(rx343_pos)
    $P10 = rx343_cur."panic"("Missing block")
    unless $P10, rx343_fail
    rx343_pos = $P10."pos"()
  alt349_end:
.annotate 'line', 154
  # rx pass
    rx343_cur."!cursor_pass"(rx343_pos, "pblock")
    if_null rx343_debug, debug_687
    rx343_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx343_pos)
  debug_687:
    .return (rx343_cur)
  rx343_restart:
.annotate 'line', 10
    if_null rx343_debug, debug_688
    rx343_cur."!cursor_debug"("NEXT", "pblock")
  debug_688:
  rx343_fail:
    (rx343_rep, rx343_pos, $I10, $P10) = rx343_cur."!mark_fail"(0)
    lt rx343_pos, -1, rx343_done
    eq rx343_pos, -1, rx343_fail
    jump $I10
  rx343_done:
    rx343_cur."!cursor_fail"()
    if_null rx343_debug, debug_689
    rx343_cur."!cursor_debug"("FAIL", "pblock")
  debug_689:
    .return (rx343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1303923618.727") :method
.annotate 'line', 10
    $P345 = self."!PREFIX__!subrule"("panic", "")
    $P346 = self."!PREFIX__!subrule"("lambda", "")
    new $P347, "ResizablePMCArray"
    push $P347, $P345
    push $P347, "{"
    push $P347, $P346
    .return ($P347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx351_tgt
    .local int rx351_pos
    .local int rx351_off
    .local int rx351_eos
    .local int rx351_rep
    .local pmc rx351_cur
    .local pmc rx351_debug
    (rx351_cur, rx351_pos, rx351_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx351_cur
    .local pmc match
    .lex "$/", match
    length rx351_eos, rx351_tgt
    gt rx351_pos, rx351_eos, rx351_done
    set rx351_off, 0
    lt rx351_pos, 2, rx351_start
    sub rx351_off, rx351_pos, 1
    substr rx351_tgt, rx351_tgt, rx351_off
  rx351_start:
    eq $I10, 1, rx351_restart
    if_null rx351_debug, debug_690
    rx351_cur."!cursor_debug"("START", "lambda")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan354_done
    goto rxscan354_scan
  rxscan354_loop:
    (rx351_pos) = rx351_cur."from"()
    inc rx351_pos
    rx351_cur."!cursor_from"(rx351_pos)
    ge rx351_pos, rx351_eos, rxscan354_done
  rxscan354_scan:
    set_addr $I10, rxscan354_loop
    rx351_cur."!mark_push"(0, rx351_pos, $I10)
  rxscan354_done:
  alt355_0:
.annotate 'line', 165
    set_addr $I10, alt355_1
    rx351_cur."!mark_push"(0, rx351_pos, $I10)
  # rx literal  "->"
    add $I11, rx351_pos, 2
    gt $I11, rx351_eos, rx351_fail
    sub $I11, rx351_pos, rx351_off
    substr $S10, rx351_tgt, $I11, 2
    ne $S10, "->", rx351_fail
    add rx351_pos, 2
    goto alt355_end
  alt355_1:
  # rx literal  "<->"
    add $I11, rx351_pos, 3
    gt $I11, rx351_eos, rx351_fail
    sub $I11, rx351_pos, rx351_off
    substr $S10, rx351_tgt, $I11, 3
    ne $S10, "<->", rx351_fail
    add rx351_pos, 3
  alt355_end:
  # rx pass
    rx351_cur."!cursor_pass"(rx351_pos, "lambda")
    if_null rx351_debug, debug_691
    rx351_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx351_pos)
  debug_691:
    .return (rx351_cur)
  rx351_restart:
.annotate 'line', 10
    if_null rx351_debug, debug_692
    rx351_cur."!cursor_debug"("NEXT", "lambda")
  debug_692:
  rx351_fail:
    (rx351_rep, rx351_pos, $I10, $P10) = rx351_cur."!mark_fail"(0)
    lt rx351_pos, -1, rx351_done
    eq rx351_pos, -1, rx351_fail
    jump $I10
  rx351_done:
    rx351_cur."!cursor_fail"()
    if_null rx351_debug, debug_693
    rx351_cur."!cursor_debug"("FAIL", "lambda")
  debug_693:
    .return (rx351_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1303923618.727") :method
.annotate 'line', 10
    new $P353, "ResizablePMCArray"
    push $P353, "<->"
    push $P353, "->"
    .return ($P353)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx357_tgt
    .local int rx357_pos
    .local int rx357_off
    .local int rx357_eos
    .local int rx357_rep
    .local pmc rx357_cur
    .local pmc rx357_debug
    (rx357_cur, rx357_pos, rx357_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx357_cur
    .local pmc match
    .lex "$/", match
    length rx357_eos, rx357_tgt
    gt rx357_pos, rx357_eos, rx357_done
    set rx357_off, 0
    lt rx357_pos, 2, rx357_start
    sub rx357_off, rx357_pos, 1
    substr rx357_tgt, rx357_tgt, rx357_off
  rx357_start:
    eq $I10, 1, rx357_restart
    if_null rx357_debug, debug_694
    rx357_cur."!cursor_debug"("START", "block")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan361_done
    goto rxscan361_scan
  rxscan361_loop:
    (rx357_pos) = rx357_cur."from"()
    inc rx357_pos
    rx357_cur."!cursor_from"(rx357_pos)
    ge rx357_pos, rx357_eos, rxscan361_done
  rxscan361_scan:
    set_addr $I10, rxscan361_loop
    rx357_cur."!mark_push"(0, rx357_pos, $I10)
  rxscan361_done:
  alt362_0:
.annotate 'line', 168
    set_addr $I10, alt362_1
    rx357_cur."!mark_push"(0, rx357_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx357_pos, rx357_off
    substr $S10, rx357_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx357_fail
    goto alt362_end
  alt362_1:
  # rx subrule "panic" subtype=method negate=
    rx357_cur."!cursor_pos"(rx357_pos)
    $P10 = rx357_cur."panic"("Missing block")
    unless $P10, rx357_fail
    rx357_pos = $P10."pos"()
  alt362_end:
.annotate 'line', 169
  # rx subrule "newpad" subtype=method negate=
    rx357_cur."!cursor_pos"(rx357_pos)
    $P10 = rx357_cur."newpad"()
    unless $P10, rx357_fail
    rx357_pos = $P10."pos"()
.annotate 'line', 170
  # rx subrule "blockoid" subtype=capture negate=
    rx357_cur."!cursor_pos"(rx357_pos)
    $P10 = rx357_cur."blockoid"()
    unless $P10, rx357_fail
    rx357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx357_pos = $P10."pos"()
.annotate 'line', 167
  # rx pass
    rx357_cur."!cursor_pass"(rx357_pos, "block")
    if_null rx357_debug, debug_695
    rx357_cur."!cursor_debug"("PASS", "block", " at pos=", rx357_pos)
  debug_695:
    .return (rx357_cur)
  rx357_restart:
.annotate 'line', 10
    if_null rx357_debug, debug_696
    rx357_cur."!cursor_debug"("NEXT", "block")
  debug_696:
  rx357_fail:
    (rx357_rep, rx357_pos, $I10, $P10) = rx357_cur."!mark_fail"(0)
    lt rx357_pos, -1, rx357_done
    eq rx357_pos, -1, rx357_fail
    jump $I10
  rx357_done:
    rx357_cur."!cursor_fail"()
    if_null rx357_debug, debug_697
    rx357_cur."!cursor_debug"("FAIL", "block")
  debug_697:
    .return (rx357_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1303923618.727") :method
.annotate 'line', 10
    $P359 = self."!PREFIX__!subrule"("panic", "")
    new $P360, "ResizablePMCArray"
    push $P360, $P359
    push $P360, "{"
    .return ($P360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx364_tgt
    .local int rx364_pos
    .local int rx364_off
    .local int rx364_eos
    .local int rx364_rep
    .local pmc rx364_cur
    .local pmc rx364_debug
    (rx364_cur, rx364_pos, rx364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx364_cur
    .local pmc match
    .lex "$/", match
    length rx364_eos, rx364_tgt
    gt rx364_pos, rx364_eos, rx364_done
    set rx364_off, 0
    lt rx364_pos, 2, rx364_start
    sub rx364_off, rx364_pos, 1
    substr rx364_tgt, rx364_tgt, rx364_off
  rx364_start:
    eq $I10, 1, rx364_restart
    if_null rx364_debug, debug_698
    rx364_cur."!cursor_debug"("START", "blockoid")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan368_done
    goto rxscan368_scan
  rxscan368_loop:
    (rx364_pos) = rx364_cur."from"()
    inc rx364_pos
    rx364_cur."!cursor_from"(rx364_pos)
    ge rx364_pos, rx364_eos, rxscan368_done
  rxscan368_scan:
    set_addr $I10, rxscan368_loop
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  rxscan368_done:
.annotate 'line', 174
  # rx subrule "finishpad" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."finishpad"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
  alt369_0:
.annotate 'line', 175
    set_addr $I10, alt369_1
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
.annotate 'line', 176
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx364_pos, 14
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    substr $S10, rx364_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx364_fail
    add rx364_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."you_are_here"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx364_pos = $P10."pos"()
    goto alt369_end
  alt369_1:
.annotate 'line', 177
  # rx literal  "{"
    add $I11, rx364_pos, 1
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    ord $I11, rx364_tgt, $I11
    ne $I11, 123, rx364_fail
    add rx364_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."statementlist"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx364_pos = $P10."pos"()
  alt370_0:
    set_addr $I10, alt370_1
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  # rx literal  "}"
    add $I11, rx364_pos, 1
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    ord $I11, rx364_tgt, $I11
    ne $I11, 125, rx364_fail
    add rx364_pos, 1
    goto alt370_end
  alt370_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."FAILGOAL"("'}'")
    unless $P10, rx364_fail
    goto rxsubrule372_pass
  rxsubrule372_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx364_fail
  rxsubrule372_pass:
    set_addr $I10, rxsubrule372_back
    rx364_cur."!mark_push"(0, rx364_pos, $I10, $P10)
    rx364_pos = $P10."pos"()
  alt370_end:
  alt369_end:
.annotate 'line', 179
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ENDSTMT"()
    unless $P10, rx364_fail
.annotate 'line', 173
  # rx pass
    rx364_cur."!cursor_pass"(rx364_pos, "blockoid")
    if_null rx364_debug, debug_699
    rx364_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx364_pos)
  debug_699:
    .return (rx364_cur)
  rx364_restart:
.annotate 'line', 10
    if_null rx364_debug, debug_700
    rx364_cur."!cursor_debug"("NEXT", "blockoid")
  debug_700:
  rx364_fail:
    (rx364_rep, rx364_pos, $I10, $P10) = rx364_cur."!mark_fail"(0)
    lt rx364_pos, -1, rx364_done
    eq rx364_pos, -1, rx364_fail
    jump $I10
  rx364_done:
    rx364_cur."!cursor_fail"()
    if_null rx364_debug, debug_701
    rx364_cur."!cursor_debug"("FAIL", "blockoid")
  debug_701:
    .return (rx364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1303923618.727") :method
.annotate 'line', 10
    $P366 = self."!PREFIX__!subrule"("finishpad", "")
    new $P367, "ResizablePMCArray"
    push $P367, $P366
    .return ($P367)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx374_tgt
    .local int rx374_pos
    .local int rx374_off
    .local int rx374_eos
    .local int rx374_rep
    .local pmc rx374_cur
    .local pmc rx374_debug
    (rx374_cur, rx374_pos, rx374_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx374_cur
    .local pmc match
    .lex "$/", match
    length rx374_eos, rx374_tgt
    gt rx374_pos, rx374_eos, rx374_done
    set rx374_off, 0
    lt rx374_pos, 2, rx374_start
    sub rx374_off, rx374_pos, 1
    substr rx374_tgt, rx374_tgt, rx374_off
  rx374_start:
    eq $I10, 1, rx374_restart
    if_null rx374_debug, debug_702
    rx374_cur."!cursor_debug"("START", "newpad")
  debug_702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan377_done
    goto rxscan377_scan
  rxscan377_loop:
    (rx374_pos) = rx374_cur."from"()
    inc rx374_pos
    rx374_cur."!cursor_from"(rx374_pos)
    ge rx374_pos, rx374_eos, rxscan377_done
  rxscan377_scan:
    set_addr $I10, rxscan377_loop
    rx374_cur."!mark_push"(0, rx374_pos, $I10)
  rxscan377_done:
.annotate 'line', 182
  # rx pass
    rx374_cur."!cursor_pass"(rx374_pos, "newpad")
    if_null rx374_debug, debug_703
    rx374_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx374_pos)
  debug_703:
    .return (rx374_cur)
  rx374_restart:
.annotate 'line', 10
    if_null rx374_debug, debug_704
    rx374_cur."!cursor_debug"("NEXT", "newpad")
  debug_704:
  rx374_fail:
    (rx374_rep, rx374_pos, $I10, $P10) = rx374_cur."!mark_fail"(0)
    lt rx374_pos, -1, rx374_done
    eq rx374_pos, -1, rx374_fail
    jump $I10
  rx374_done:
    rx374_cur."!cursor_fail"()
    if_null rx374_debug, debug_705
    rx374_cur."!cursor_debug"("FAIL", "newpad")
  debug_705:
    .return (rx374_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1303923618.727") :method
.annotate 'line', 10
    new $P376, "ResizablePMCArray"
    push $P376, ""
    .return ($P376)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx379_tgt
    .local int rx379_pos
    .local int rx379_off
    .local int rx379_eos
    .local int rx379_rep
    .local pmc rx379_cur
    .local pmc rx379_debug
    (rx379_cur, rx379_pos, rx379_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx379_cur
    .local pmc match
    .lex "$/", match
    length rx379_eos, rx379_tgt
    gt rx379_pos, rx379_eos, rx379_done
    set rx379_off, 0
    lt rx379_pos, 2, rx379_start
    sub rx379_off, rx379_pos, 1
    substr rx379_tgt, rx379_tgt, rx379_off
  rx379_start:
    eq $I10, 1, rx379_restart
    if_null rx379_debug, debug_706
    rx379_cur."!cursor_debug"("START", "outerctx")
  debug_706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan382_done
    goto rxscan382_scan
  rxscan382_loop:
    (rx379_pos) = rx379_cur."from"()
    inc rx379_pos
    rx379_cur."!cursor_from"(rx379_pos)
    ge rx379_pos, rx379_eos, rxscan382_done
  rxscan382_scan:
    set_addr $I10, rxscan382_loop
    rx379_cur."!mark_push"(0, rx379_pos, $I10)
  rxscan382_done:
.annotate 'line', 183
  # rx pass
    rx379_cur."!cursor_pass"(rx379_pos, "outerctx")
    if_null rx379_debug, debug_707
    rx379_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx379_pos)
  debug_707:
    .return (rx379_cur)
  rx379_restart:
.annotate 'line', 10
    if_null rx379_debug, debug_708
    rx379_cur."!cursor_debug"("NEXT", "outerctx")
  debug_708:
  rx379_fail:
    (rx379_rep, rx379_pos, $I10, $P10) = rx379_cur."!mark_fail"(0)
    lt rx379_pos, -1, rx379_done
    eq rx379_pos, -1, rx379_fail
    jump $I10
  rx379_done:
    rx379_cur."!cursor_fail"()
    if_null rx379_debug, debug_709
    rx379_cur."!cursor_debug"("FAIL", "outerctx")
  debug_709:
    .return (rx379_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1303923618.727") :method
.annotate 'line', 10
    new $P381, "ResizablePMCArray"
    push $P381, ""
    .return ($P381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx384_tgt
    .local int rx384_pos
    .local int rx384_off
    .local int rx384_eos
    .local int rx384_rep
    .local pmc rx384_cur
    .local pmc rx384_debug
    (rx384_cur, rx384_pos, rx384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx384_cur
    .local pmc match
    .lex "$/", match
    length rx384_eos, rx384_tgt
    gt rx384_pos, rx384_eos, rx384_done
    set rx384_off, 0
    lt rx384_pos, 2, rx384_start
    sub rx384_off, rx384_pos, 1
    substr rx384_tgt, rx384_tgt, rx384_off
  rx384_start:
    eq $I10, 1, rx384_restart
    if_null rx384_debug, debug_710
    rx384_cur."!cursor_debug"("START", "GLOBALish")
  debug_710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan387_done
    goto rxscan387_scan
  rxscan387_loop:
    (rx384_pos) = rx384_cur."from"()
    inc rx384_pos
    rx384_cur."!cursor_from"(rx384_pos)
    ge rx384_pos, rx384_eos, rxscan387_done
  rxscan387_scan:
    set_addr $I10, rxscan387_loop
    rx384_cur."!mark_push"(0, rx384_pos, $I10)
  rxscan387_done:
.annotate 'line', 184
  # rx pass
    rx384_cur."!cursor_pass"(rx384_pos, "GLOBALish")
    if_null rx384_debug, debug_711
    rx384_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx384_pos)
  debug_711:
    .return (rx384_cur)
  rx384_restart:
.annotate 'line', 10
    if_null rx384_debug, debug_712
    rx384_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_712:
  rx384_fail:
    (rx384_rep, rx384_pos, $I10, $P10) = rx384_cur."!mark_fail"(0)
    lt rx384_pos, -1, rx384_done
    eq rx384_pos, -1, rx384_fail
    jump $I10
  rx384_done:
    rx384_cur."!cursor_fail"()
    if_null rx384_debug, debug_713
    rx384_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_713:
    .return (rx384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :nsentry("!PREFIX__GLOBALish") :subid("54_1303923618.727") :method
.annotate 'line', 10
    new $P386, "ResizablePMCArray"
    push $P386, ""
    .return ($P386)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx389_tgt
    .local int rx389_pos
    .local int rx389_off
    .local int rx389_eos
    .local int rx389_rep
    .local pmc rx389_cur
    .local pmc rx389_debug
    (rx389_cur, rx389_pos, rx389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx389_cur
    .local pmc match
    .lex "$/", match
    length rx389_eos, rx389_tgt
    gt rx389_pos, rx389_eos, rx389_done
    set rx389_off, 0
    lt rx389_pos, 2, rx389_start
    sub rx389_off, rx389_pos, 1
    substr rx389_tgt, rx389_tgt, rx389_off
  rx389_start:
    eq $I10, 1, rx389_restart
    if_null rx389_debug, debug_714
    rx389_cur."!cursor_debug"("START", "finishpad")
  debug_714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan392_done
    goto rxscan392_scan
  rxscan392_loop:
    (rx389_pos) = rx389_cur."from"()
    inc rx389_pos
    rx389_cur."!cursor_from"(rx389_pos)
    ge rx389_pos, rx389_eos, rxscan392_done
  rxscan392_scan:
    set_addr $I10, rxscan392_loop
    rx389_cur."!mark_push"(0, rx389_pos, $I10)
  rxscan392_done:
.annotate 'line', 185
  # rx pass
    rx389_cur."!cursor_pass"(rx389_pos, "finishpad")
    if_null rx389_debug, debug_715
    rx389_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx389_pos)
  debug_715:
    .return (rx389_cur)
  rx389_restart:
.annotate 'line', 10
    if_null rx389_debug, debug_716
    rx389_cur."!cursor_debug"("NEXT", "finishpad")
  debug_716:
  rx389_fail:
    (rx389_rep, rx389_pos, $I10, $P10) = rx389_cur."!mark_fail"(0)
    lt rx389_pos, -1, rx389_done
    eq rx389_pos, -1, rx389_fail
    jump $I10
  rx389_done:
    rx389_cur."!cursor_fail"()
    if_null rx389_debug, debug_717
    rx389_cur."!cursor_debug"("FAIL", "finishpad")
  debug_717:
    .return (rx389_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("56_1303923618.727") :method
.annotate 'line', 10
    new $P391, "ResizablePMCArray"
    push $P391, ""
    .return ($P391)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx394_tgt
    .local int rx394_pos
    .local int rx394_off
    .local int rx394_eos
    .local int rx394_rep
    .local pmc rx394_cur
    .local pmc rx394_debug
    (rx394_cur, rx394_pos, rx394_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx394_cur
    .local pmc match
    .lex "$/", match
    length rx394_eos, rx394_tgt
    gt rx394_pos, rx394_eos, rx394_done
    set rx394_off, 0
    lt rx394_pos, 2, rx394_start
    sub rx394_off, rx394_pos, 1
    substr rx394_tgt, rx394_tgt, rx394_off
  rx394_start:
    eq $I10, 1, rx394_restart
    if_null rx394_debug, debug_718
    rx394_cur."!cursor_debug"("START", "you_are_here")
  debug_718:
    $I10 = self.'from'()
    ne $I10, -1, rxscan397_done
    goto rxscan397_scan
  rxscan397_loop:
    (rx394_pos) = rx394_cur."from"()
    inc rx394_pos
    rx394_cur."!cursor_from"(rx394_pos)
    ge rx394_pos, rx394_eos, rxscan397_done
  rxscan397_scan:
    set_addr $I10, rxscan397_loop
    rx394_cur."!mark_push"(0, rx394_pos, $I10)
  rxscan397_done:
.annotate 'line', 186
  # rx pass
    rx394_cur."!cursor_pass"(rx394_pos, "you_are_here")
    if_null rx394_debug, debug_719
    rx394_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx394_pos)
  debug_719:
    .return (rx394_cur)
  rx394_restart:
.annotate 'line', 10
    if_null rx394_debug, debug_720
    rx394_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_720:
  rx394_fail:
    (rx394_rep, rx394_pos, $I10, $P10) = rx394_cur."!mark_fail"(0)
    lt rx394_pos, -1, rx394_done
    eq rx394_pos, -1, rx394_fail
    jump $I10
  rx394_done:
    rx394_cur."!cursor_fail"()
    if_null rx394_debug, debug_721
    rx394_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_721:
    .return (rx394_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("58_1303923618.727") :method
.annotate 'line', 10
    new $P396, "ResizablePMCArray"
    push $P396, ""
    .return ($P396)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1303923618.727")
    .param pmc param_399
.annotate 'line', 188
    .lex "self", param_399
    $P400 = param_399."!protoregex"("terminator")
    .return ($P400)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1303923618.727")
    .param pmc param_402
.annotate 'line', 188
    .lex "self", param_402
    $P403 = param_402."!PREFIX__!protoregex"("terminator")
    .return ($P403)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx405_tgt
    .local int rx405_pos
    .local int rx405_off
    .local int rx405_eos
    .local int rx405_rep
    .local pmc rx405_cur
    .local pmc rx405_debug
    (rx405_cur, rx405_pos, rx405_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx405_cur
    .local pmc match
    .lex "$/", match
    length rx405_eos, rx405_tgt
    gt rx405_pos, rx405_eos, rx405_done
    set rx405_off, 0
    lt rx405_pos, 2, rx405_start
    sub rx405_off, rx405_pos, 1
    substr rx405_tgt, rx405_tgt, rx405_off
  rx405_start:
    eq $I10, 1, rx405_restart
    if_null rx405_debug, debug_722
    rx405_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan408_done
    goto rxscan408_scan
  rxscan408_loop:
    (rx405_pos) = rx405_cur."from"()
    inc rx405_pos
    rx405_cur."!cursor_from"(rx405_pos)
    ge rx405_pos, rx405_eos, rxscan408_done
  rxscan408_scan:
    set_addr $I10, rxscan408_loop
    rx405_cur."!mark_push"(0, rx405_pos, $I10)
  rxscan408_done:
.annotate 'line', 190
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx405_pos, rx405_off
    substr $S10, rx405_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx405_fail
  # rx pass
    rx405_cur."!cursor_pass"(rx405_pos, "terminator:sym<;>")
    if_null rx405_debug, debug_723
    rx405_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx405_pos)
  debug_723:
    .return (rx405_cur)
  rx405_restart:
.annotate 'line', 10
    if_null rx405_debug, debug_724
    rx405_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_724:
  rx405_fail:
    (rx405_rep, rx405_pos, $I10, $P10) = rx405_cur."!mark_fail"(0)
    lt rx405_pos, -1, rx405_done
    eq rx405_pos, -1, rx405_fail
    jump $I10
  rx405_done:
    rx405_cur."!cursor_fail"()
    if_null rx405_debug, debug_725
    rx405_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_725:
    .return (rx405_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("62_1303923618.727") :method
.annotate 'line', 10
    new $P407, "ResizablePMCArray"
    push $P407, ";"
    .return ($P407)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx410_tgt
    .local int rx410_pos
    .local int rx410_off
    .local int rx410_eos
    .local int rx410_rep
    .local pmc rx410_cur
    .local pmc rx410_debug
    (rx410_cur, rx410_pos, rx410_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx410_cur
    .local pmc match
    .lex "$/", match
    length rx410_eos, rx410_tgt
    gt rx410_pos, rx410_eos, rx410_done
    set rx410_off, 0
    lt rx410_pos, 2, rx410_start
    sub rx410_off, rx410_pos, 1
    substr rx410_tgt, rx410_tgt, rx410_off
  rx410_start:
    eq $I10, 1, rx410_restart
    if_null rx410_debug, debug_726
    rx410_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_726:
    $I10 = self.'from'()
    ne $I10, -1, rxscan413_done
    goto rxscan413_scan
  rxscan413_loop:
    (rx410_pos) = rx410_cur."from"()
    inc rx410_pos
    rx410_cur."!cursor_from"(rx410_pos)
    ge rx410_pos, rx410_eos, rxscan413_done
  rxscan413_scan:
    set_addr $I10, rxscan413_loop
    rx410_cur."!mark_push"(0, rx410_pos, $I10)
  rxscan413_done:
.annotate 'line', 191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx410_pos, rx410_off
    substr $S10, rx410_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx410_fail
  # rx pass
    rx410_cur."!cursor_pass"(rx410_pos, "terminator:sym<}>")
    if_null rx410_debug, debug_727
    rx410_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx410_pos)
  debug_727:
    .return (rx410_cur)
  rx410_restart:
.annotate 'line', 10
    if_null rx410_debug, debug_728
    rx410_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_728:
  rx410_fail:
    (rx410_rep, rx410_pos, $I10, $P10) = rx410_cur."!mark_fail"(0)
    lt rx410_pos, -1, rx410_done
    eq rx410_pos, -1, rx410_fail
    jump $I10
  rx410_done:
    rx410_cur."!cursor_fail"()
    if_null rx410_debug, debug_729
    rx410_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_729:
    .return (rx410_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("64_1303923618.727") :method
.annotate 'line', 10
    new $P412, "ResizablePMCArray"
    push $P412, "}"
    .return ($P412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1303923618.727")
    .param pmc param_415
.annotate 'line', 195
    .lex "self", param_415
    $P416 = param_415."!protoregex"("statement_control")
    .return ($P416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1303923618.727")
    .param pmc param_418
.annotate 'line', 195
    .lex "self", param_418
    $P419 = param_418."!PREFIX__!protoregex"("statement_control")
    .return ($P419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx421_tgt
    .local int rx421_pos
    .local int rx421_off
    .local int rx421_eos
    .local int rx421_rep
    .local pmc rx421_cur
    .local pmc rx421_debug
    (rx421_cur, rx421_pos, rx421_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx421_cur
    .local pmc match
    .lex "$/", match
    length rx421_eos, rx421_tgt
    gt rx421_pos, rx421_eos, rx421_done
    set rx421_off, 0
    lt rx421_pos, 2, rx421_start
    sub rx421_off, rx421_pos, 1
    substr rx421_tgt, rx421_tgt, rx421_off
  rx421_start:
    eq $I10, 1, rx421_restart
    if_null rx421_debug, debug_730
    rx421_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan424_done
    goto rxscan424_scan
  rxscan424_loop:
    (rx421_pos) = rx421_cur."from"()
    inc rx421_pos
    rx421_cur."!cursor_from"(rx421_pos)
    ge rx421_pos, rx421_eos, rxscan424_done
  rxscan424_scan:
    set_addr $I10, rxscan424_loop
    rx421_cur."!mark_push"(0, rx421_pos, $I10)
  rxscan424_done:
.annotate 'line', 198
  # rx subcapture "sym"
    set_addr $I10, rxcap_425_fail
    rx421_cur."!mark_push"(0, rx421_pos, $I10)
  # rx literal  "use"
    add $I11, rx421_pos, 3
    gt $I11, rx421_eos, rx421_fail
    sub $I11, rx421_pos, rx421_off
    substr $S10, rx421_tgt, $I11, 3
    ne $S10, "use", rx421_fail
    add rx421_pos, 3
    set_addr $I10, rxcap_425_fail
    ($I12, $I11) = rx421_cur."!mark_peek"($I10)
    rx421_cur."!cursor_pos"($I11)
    ($P10) = rx421_cur."!cursor_start"()
    $P10."!cursor_pass"(rx421_pos, "")
    rx421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_425_done
  rxcap_425_fail:
    goto rx421_fail
  rxcap_425_done:
  # rx charclass s
    ge rx421_pos, rx421_eos, rx421_fail
    sub $I10, rx421_pos, rx421_off
    is_cclass $I11, 32, rx421_tgt, $I10
    unless $I11, rx421_fail
    inc rx421_pos
  # rx subrule "ws" subtype=method negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."ws"()
    unless $P10, rx421_fail
    rx421_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."name"()
    unless $P10, rx421_fail
    rx421_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx421_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx421_cur."!cursor_pos"(rx421_pos)
    $P10 = rx421_cur."ws"()
    unless $P10, rx421_fail
    rx421_pos = $P10."pos"()
.annotate 'line', 197
  # rx pass
    rx421_cur."!cursor_pass"(rx421_pos, "statement_control:sym<use>")
    if_null rx421_debug, debug_731
    rx421_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx421_pos)
  debug_731:
    .return (rx421_cur)
  rx421_restart:
.annotate 'line', 10
    if_null rx421_debug, debug_732
    rx421_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_732:
  rx421_fail:
    (rx421_rep, rx421_pos, $I10, $P10) = rx421_cur."!mark_fail"(0)
    lt rx421_pos, -1, rx421_done
    eq rx421_pos, -1, rx421_fail
    jump $I10
  rx421_done:
    rx421_cur."!cursor_fail"()
    if_null rx421_debug, debug_733
    rx421_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_733:
    .return (rx421_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("68_1303923618.727") :method
.annotate 'line', 10
    new $P423, "ResizablePMCArray"
    push $P423, "use"
    .return ($P423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx429_tgt
    .local int rx429_pos
    .local int rx429_off
    .local int rx429_eos
    .local int rx429_rep
    .local pmc rx429_cur
    .local pmc rx429_debug
    (rx429_cur, rx429_pos, rx429_tgt, $I10) = self."!cursor_start"()
    rx429_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx429_cur
    .local pmc match
    .lex "$/", match
    length rx429_eos, rx429_tgt
    gt rx429_pos, rx429_eos, rx429_done
    set rx429_off, 0
    lt rx429_pos, 2, rx429_start
    sub rx429_off, rx429_pos, 1
    substr rx429_tgt, rx429_tgt, rx429_off
  rx429_start:
    eq $I10, 1, rx429_restart
    if_null rx429_debug, debug_734
    rx429_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_734:
    $I10 = self.'from'()
    ne $I10, -1, rxscan432_done
    goto rxscan432_scan
  rxscan432_loop:
    (rx429_pos) = rx429_cur."from"()
    inc rx429_pos
    rx429_cur."!cursor_from"(rx429_pos)
    ge rx429_pos, rx429_eos, rxscan432_done
  rxscan432_scan:
    set_addr $I10, rxscan432_loop
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  rxscan432_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_433_fail
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  # rx literal  "if"
    add $I11, rx429_pos, 2
    gt $I11, rx429_eos, rx429_fail
    sub $I11, rx429_pos, rx429_off
    substr $S10, rx429_tgt, $I11, 2
    ne $S10, "if", rx429_fail
    add rx429_pos, 2
    set_addr $I10, rxcap_433_fail
    ($I12, $I11) = rx429_cur."!mark_peek"($I10)
    rx429_cur."!cursor_pos"($I11)
    ($P10) = rx429_cur."!cursor_start"()
    $P10."!cursor_pass"(rx429_pos, "")
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_433_done
  rxcap_433_fail:
    goto rx429_fail
  rxcap_433_done:
  # rx charclass s
    ge rx429_pos, rx429_eos, rx429_fail
    sub $I10, rx429_pos, rx429_off
    is_cclass $I11, 32, rx429_tgt, $I10
    unless $I11, rx429_fail
    inc rx429_pos
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
.annotate 'line', 203
  # rx subrule "xblock" subtype=capture negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."xblock"()
    unless $P10, rx429_fail
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx429_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
.annotate 'line', 204
  # rx rxquantr436 ** 0..*
    set_addr $I10, rxquantr436_done
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  rxquantr436_loop:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx429_pos, 5
    gt $I11, rx429_eos, rx429_fail
    sub $I11, rx429_pos, rx429_off
    substr $S10, rx429_tgt, $I11, 5
    ne $S10, "elsif", rx429_fail
    add rx429_pos, 5
  # rx charclass s
    ge rx429_pos, rx429_eos, rx429_fail
    sub $I10, rx429_pos, rx429_off
    is_cclass $I11, 32, rx429_tgt, $I10
    unless $I11, rx429_fail
    inc rx429_pos
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."xblock"()
    unless $P10, rx429_fail
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx429_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
    set_addr $I10, rxquantr436_done
    (rx429_rep) = rx429_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr436_done
    rx429_cur."!mark_push"(rx429_rep, rx429_pos, $I10)
    goto rxquantr436_loop
  rxquantr436_done:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
.annotate 'line', 205
  # rx rxquantr441 ** 0..1
    set_addr $I10, rxquantr441_done
    rx429_cur."!mark_push"(0, rx429_pos, $I10)
  rxquantr441_loop:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx429_pos, 4
    gt $I11, rx429_eos, rx429_fail
    sub $I11, rx429_pos, rx429_off
    substr $S10, rx429_tgt, $I11, 4
    ne $S10, "else", rx429_fail
    add rx429_pos, 4
  # rx charclass s
    ge rx429_pos, rx429_eos, rx429_fail
    sub $I10, rx429_pos, rx429_off
    is_cclass $I11, 32, rx429_tgt, $I10
    unless $I11, rx429_fail
    inc rx429_pos
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."pblock"()
    unless $P10, rx429_fail
    rx429_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx429_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
    set_addr $I10, rxquantr441_done
    (rx429_rep) = rx429_cur."!mark_commit"($I10)
  rxquantr441_done:
  # rx subrule "ws" subtype=method negate=
    rx429_cur."!cursor_pos"(rx429_pos)
    $P10 = rx429_cur."ws"()
    unless $P10, rx429_fail
    rx429_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx429_cur."!cursor_pass"(rx429_pos, "statement_control:sym<if>")
    if_null rx429_debug, debug_735
    rx429_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx429_pos)
  debug_735:
    .return (rx429_cur)
  rx429_restart:
.annotate 'line', 10
    if_null rx429_debug, debug_736
    rx429_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_736:
  rx429_fail:
    (rx429_rep, rx429_pos, $I10, $P10) = rx429_cur."!mark_fail"(0)
    lt rx429_pos, -1, rx429_done
    eq rx429_pos, -1, rx429_fail
    jump $I10
  rx429_done:
    rx429_cur."!cursor_fail"()
    if_null rx429_debug, debug_737
    rx429_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_737:
    .return (rx429_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("70_1303923618.727") :method
.annotate 'line', 10
    new $P431, "ResizablePMCArray"
    push $P431, "if"
    .return ($P431)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P457 = "73_1303923618.727" 
    capture_lex $P457
    .local string rx447_tgt
    .local int rx447_pos
    .local int rx447_off
    .local int rx447_eos
    .local int rx447_rep
    .local pmc rx447_cur
    .local pmc rx447_debug
    (rx447_cur, rx447_pos, rx447_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx447_cur
    .local pmc match
    .lex "$/", match
    length rx447_eos, rx447_tgt
    gt rx447_pos, rx447_eos, rx447_done
    set rx447_off, 0
    lt rx447_pos, 2, rx447_start
    sub rx447_off, rx447_pos, 1
    substr rx447_tgt, rx447_tgt, rx447_off
  rx447_start:
    eq $I10, 1, rx447_restart
    if_null rx447_debug, debug_738
    rx447_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan450_done
    goto rxscan450_scan
  rxscan450_loop:
    (rx447_pos) = rx447_cur."from"()
    inc rx447_pos
    rx447_cur."!cursor_from"(rx447_pos)
    ge rx447_pos, rx447_eos, rxscan450_done
  rxscan450_scan:
    set_addr $I10, rxscan450_loop
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  rxscan450_done:
.annotate 'line', 209
  # rx subcapture "sym"
    set_addr $I10, rxcap_451_fail
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  # rx literal  "unless"
    add $I11, rx447_pos, 6
    gt $I11, rx447_eos, rx447_fail
    sub $I11, rx447_pos, rx447_off
    substr $S10, rx447_tgt, $I11, 6
    ne $S10, "unless", rx447_fail
    add rx447_pos, 6
    set_addr $I10, rxcap_451_fail
    ($I12, $I11) = rx447_cur."!mark_peek"($I10)
    rx447_cur."!cursor_pos"($I11)
    ($P10) = rx447_cur."!cursor_start"()
    $P10."!cursor_pass"(rx447_pos, "")
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_451_done
  rxcap_451_fail:
    goto rx447_fail
  rxcap_451_done:
  # rx charclass s
    ge rx447_pos, rx447_eos, rx447_fail
    sub $I10, rx447_pos, rx447_off
    is_cclass $I11, 32, rx447_tgt, $I10
    unless $I11, rx447_fail
    inc rx447_pos
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
.annotate 'line', 210
  # rx subrule "xblock" subtype=capture negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."xblock"()
    unless $P10, rx447_fail
    rx447_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx447_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  alt454_0:
.annotate 'line', 211
    set_addr $I10, alt454_1
    rx447_cur."!mark_push"(0, rx447_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx447_cur."!cursor_pos"(rx447_pos)
    .const 'Sub' $P457 = "73_1303923618.727" 
    capture_lex $P457
    $P10 = rx447_cur."before"($P457)
    if $P10, rx447_fail
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
    goto alt454_end
  alt454_1:
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
  alt454_end:
  # rx subrule "ws" subtype=method negate=
    rx447_cur."!cursor_pos"(rx447_pos)
    $P10 = rx447_cur."ws"()
    unless $P10, rx447_fail
    rx447_pos = $P10."pos"()
.annotate 'line', 208
  # rx pass
    rx447_cur."!cursor_pass"(rx447_pos, "statement_control:sym<unless>")
    if_null rx447_debug, debug_743
    rx447_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx447_pos)
  debug_743:
    .return (rx447_cur)
  rx447_restart:
.annotate 'line', 10
    if_null rx447_debug, debug_744
    rx447_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_744:
  rx447_fail:
    (rx447_rep, rx447_pos, $I10, $P10) = rx447_cur."!mark_fail"(0)
    lt rx447_pos, -1, rx447_done
    eq rx447_pos, -1, rx447_fail
    jump $I10
  rx447_done:
    rx447_cur."!cursor_fail"()
    if_null rx447_debug, debug_745
    rx447_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_745:
    .return (rx447_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("72_1303923618.727") :method
.annotate 'line', 10
    new $P449, "ResizablePMCArray"
    push $P449, "unless"
    .return ($P449)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block456"  :anon :subid("73_1303923618.727") :method :outer("71_1303923618.727")
.annotate 'line', 211
    .local string rx458_tgt
    .local int rx458_pos
    .local int rx458_off
    .local int rx458_eos
    .local int rx458_rep
    .local pmc rx458_cur
    .local pmc rx458_debug
    (rx458_cur, rx458_pos, rx458_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx458_cur
    .local pmc match
    .lex "$/", match
    length rx458_eos, rx458_tgt
    gt rx458_pos, rx458_eos, rx458_done
    set rx458_off, 0
    lt rx458_pos, 2, rx458_start
    sub rx458_off, rx458_pos, 1
    substr rx458_tgt, rx458_tgt, rx458_off
  rx458_start:
    eq $I10, 1, rx458_restart
    if_null rx458_debug, debug_739
    rx458_cur."!cursor_debug"("START", "")
  debug_739:
    $I10 = self.'from'()
    ne $I10, -1, rxscan459_done
    goto rxscan459_scan
  rxscan459_loop:
    (rx458_pos) = rx458_cur."from"()
    inc rx458_pos
    rx458_cur."!cursor_from"(rx458_pos)
    ge rx458_pos, rx458_eos, rxscan459_done
  rxscan459_scan:
    set_addr $I10, rxscan459_loop
    rx458_cur."!mark_push"(0, rx458_pos, $I10)
  rxscan459_done:
  # rx literal  "else"
    add $I11, rx458_pos, 4
    gt $I11, rx458_eos, rx458_fail
    sub $I11, rx458_pos, rx458_off
    substr $S10, rx458_tgt, $I11, 4
    ne $S10, "else", rx458_fail
    add rx458_pos, 4
  # rx pass
    rx458_cur."!cursor_pass"(rx458_pos, "")
    if_null rx458_debug, debug_740
    rx458_cur."!cursor_debug"("PASS", "", " at pos=", rx458_pos)
  debug_740:
    .return (rx458_cur)
  rx458_restart:
    if_null rx458_debug, debug_741
    rx458_cur."!cursor_debug"("NEXT", "")
  debug_741:
  rx458_fail:
    (rx458_rep, rx458_pos, $I10, $P10) = rx458_cur."!mark_fail"(0)
    lt rx458_pos, -1, rx458_done
    eq rx458_pos, -1, rx458_fail
    jump $I10
  rx458_done:
    rx458_cur."!cursor_fail"()
    if_null rx458_debug, debug_742
    rx458_cur."!cursor_debug"("FAIL", "")
  debug_742:
    .return (rx458_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx465_tgt
    .local int rx465_pos
    .local int rx465_off
    .local int rx465_eos
    .local int rx465_rep
    .local pmc rx465_cur
    .local pmc rx465_debug
    (rx465_cur, rx465_pos, rx465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx465_cur
    .local pmc match
    .lex "$/", match
    length rx465_eos, rx465_tgt
    gt rx465_pos, rx465_eos, rx465_done
    set rx465_off, 0
    lt rx465_pos, 2, rx465_start
    sub rx465_off, rx465_pos, 1
    substr rx465_tgt, rx465_tgt, rx465_off
  rx465_start:
    eq $I10, 1, rx465_restart
    if_null rx465_debug, debug_746
    rx465_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_746:
    $I10 = self.'from'()
    ne $I10, -1, rxscan468_done
    goto rxscan468_scan
  rxscan468_loop:
    (rx465_pos) = rx465_cur."from"()
    inc rx465_pos
    rx465_cur."!cursor_from"(rx465_pos)
    ge rx465_pos, rx465_eos, rxscan468_done
  rxscan468_scan:
    set_addr $I10, rxscan468_loop
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  rxscan468_done:
.annotate 'line', 215
  # rx subcapture "sym"
    set_addr $I10, rxcap_470_fail
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  alt469_0:
    set_addr $I10, alt469_1
    rx465_cur."!mark_push"(0, rx465_pos, $I10)
  # rx literal  "while"
    add $I11, rx465_pos, 5
    gt $I11, rx465_eos, rx465_fail
    sub $I11, rx465_pos, rx465_off
    substr $S10, rx465_tgt, $I11, 5
    ne $S10, "while", rx465_fail
    add rx465_pos, 5
    goto alt469_end
  alt469_1:
  # rx literal  "until"
    add $I11, rx465_pos, 5
    gt $I11, rx465_eos, rx465_fail
    sub $I11, rx465_pos, rx465_off
    substr $S10, rx465_tgt, $I11, 5
    ne $S10, "until", rx465_fail
    add rx465_pos, 5
  alt469_end:
    set_addr $I10, rxcap_470_fail
    ($I12, $I11) = rx465_cur."!mark_peek"($I10)
    rx465_cur."!cursor_pos"($I11)
    ($P10) = rx465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx465_pos, "")
    rx465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_470_done
  rxcap_470_fail:
    goto rx465_fail
  rxcap_470_done:
  # rx charclass s
    ge rx465_pos, rx465_eos, rx465_fail
    sub $I10, rx465_pos, rx465_off
    is_cclass $I11, 32, rx465_tgt, $I10
    unless $I11, rx465_fail
    inc rx465_pos
  # rx subrule "ws" subtype=method negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."ws"()
    unless $P10, rx465_fail
    rx465_pos = $P10."pos"()
.annotate 'line', 216
  # rx subrule "xblock" subtype=capture negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."xblock"()
    unless $P10, rx465_fail
    rx465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx465_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx465_cur."!cursor_pos"(rx465_pos)
    $P10 = rx465_cur."ws"()
    unless $P10, rx465_fail
    rx465_pos = $P10."pos"()
.annotate 'line', 214
  # rx pass
    rx465_cur."!cursor_pass"(rx465_pos, "statement_control:sym<while>")
    if_null rx465_debug, debug_747
    rx465_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx465_pos)
  debug_747:
    .return (rx465_cur)
  rx465_restart:
.annotate 'line', 10
    if_null rx465_debug, debug_748
    rx465_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_748:
  rx465_fail:
    (rx465_rep, rx465_pos, $I10, $P10) = rx465_cur."!mark_fail"(0)
    lt rx465_pos, -1, rx465_done
    eq rx465_pos, -1, rx465_fail
    jump $I10
  rx465_done:
    rx465_cur."!cursor_fail"()
    if_null rx465_debug, debug_749
    rx465_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_749:
    .return (rx465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("75_1303923618.727") :method
.annotate 'line', 10
    new $P467, "ResizablePMCArray"
    push $P467, "until"
    push $P467, "while"
    .return ($P467)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx474_tgt
    .local int rx474_pos
    .local int rx474_off
    .local int rx474_eos
    .local int rx474_rep
    .local pmc rx474_cur
    .local pmc rx474_debug
    (rx474_cur, rx474_pos, rx474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx474_cur
    .local pmc match
    .lex "$/", match
    length rx474_eos, rx474_tgt
    gt rx474_pos, rx474_eos, rx474_done
    set rx474_off, 0
    lt rx474_pos, 2, rx474_start
    sub rx474_off, rx474_pos, 1
    substr rx474_tgt, rx474_tgt, rx474_off
  rx474_start:
    eq $I10, 1, rx474_restart
    if_null rx474_debug, debug_750
    rx474_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_750:
    $I10 = self.'from'()
    ne $I10, -1, rxscan477_done
    goto rxscan477_scan
  rxscan477_loop:
    (rx474_pos) = rx474_cur."from"()
    inc rx474_pos
    rx474_cur."!cursor_from"(rx474_pos)
    ge rx474_pos, rx474_eos, rxscan477_done
  rxscan477_scan:
    set_addr $I10, rxscan477_loop
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  rxscan477_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_478_fail
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx474_pos, 6
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 6
    ne $S10, "repeat", rx474_fail
    add rx474_pos, 6
    set_addr $I10, rxcap_478_fail
    ($I12, $I11) = rx474_cur."!mark_peek"($I10)
    rx474_cur."!cursor_pos"($I11)
    ($P10) = rx474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx474_pos, "")
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_478_done
  rxcap_478_fail:
    goto rx474_fail
  rxcap_478_done:
  # rx charclass s
    ge rx474_pos, rx474_eos, rx474_fail
    sub $I10, rx474_pos, rx474_off
    is_cclass $I11, 32, rx474_tgt, $I10
    unless $I11, rx474_fail
    inc rx474_pos
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  alt480_0:
.annotate 'line', 221
    set_addr $I10, alt480_1
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
.annotate 'line', 222
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_483_fail
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  alt482_0:
    set_addr $I10, alt482_1
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  # rx literal  "while"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "while", rx474_fail
    add rx474_pos, 5
    goto alt482_end
  alt482_1:
  # rx literal  "until"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "until", rx474_fail
    add rx474_pos, 5
  alt482_end:
    set_addr $I10, rxcap_483_fail
    ($I12, $I11) = rx474_cur."!mark_peek"($I10)
    rx474_cur."!cursor_pos"($I11)
    ($P10) = rx474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx474_pos, "")
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_483_done
  rxcap_483_fail:
    goto rx474_fail
  rxcap_483_done:
  # rx charclass s
    ge rx474_pos, rx474_eos, rx474_fail
    sub $I10, rx474_pos, rx474_off
    is_cclass $I11, 32, rx474_tgt, $I10
    unless $I11, rx474_fail
    inc rx474_pos
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."xblock"()
    unless $P10, rx474_fail
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx474_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
    goto alt480_end
  alt480_1:
.annotate 'line', 223
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."pblock"()
    unless $P10, rx474_fail
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx474_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_489_fail
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  alt488_0:
    set_addr $I10, alt488_1
    rx474_cur."!mark_push"(0, rx474_pos, $I10)
  # rx literal  "while"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "while", rx474_fail
    add rx474_pos, 5
    goto alt488_end
  alt488_1:
  # rx literal  "until"
    add $I11, rx474_pos, 5
    gt $I11, rx474_eos, rx474_fail
    sub $I11, rx474_pos, rx474_off
    substr $S10, rx474_tgt, $I11, 5
    ne $S10, "until", rx474_fail
    add rx474_pos, 5
  alt488_end:
    set_addr $I10, rxcap_489_fail
    ($I12, $I11) = rx474_cur."!mark_peek"($I10)
    rx474_cur."!cursor_pos"($I11)
    ($P10) = rx474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx474_pos, "")
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_489_done
  rxcap_489_fail:
    goto rx474_fail
  rxcap_489_done:
  # rx charclass s
    ge rx474_pos, rx474_eos, rx474_fail
    sub $I10, rx474_pos, rx474_off
    is_cclass $I11, 32, rx474_tgt, $I10
    unless $I11, rx474_fail
    inc rx474_pos
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."EXPR"()
    unless $P10, rx474_fail
    rx474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx474_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
  alt480_end:
.annotate 'line', 224
  # rx subrule "ws" subtype=method negate=
    rx474_cur."!cursor_pos"(rx474_pos)
    $P10 = rx474_cur."ws"()
    unless $P10, rx474_fail
    rx474_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx474_cur."!cursor_pass"(rx474_pos, "statement_control:sym<repeat>")
    if_null rx474_debug, debug_751
    rx474_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx474_pos)
  debug_751:
    .return (rx474_cur)
  rx474_restart:
.annotate 'line', 10
    if_null rx474_debug, debug_752
    rx474_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_752:
  rx474_fail:
    (rx474_rep, rx474_pos, $I10, $P10) = rx474_cur."!mark_fail"(0)
    lt rx474_pos, -1, rx474_done
    eq rx474_pos, -1, rx474_fail
    jump $I10
  rx474_done:
    rx474_cur."!cursor_fail"()
    if_null rx474_debug, debug_753
    rx474_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_753:
    .return (rx474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("77_1303923618.727") :method
.annotate 'line', 10
    new $P476, "ResizablePMCArray"
    push $P476, "repeat"
    .return ($P476)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx494_tgt
    .local int rx494_pos
    .local int rx494_off
    .local int rx494_eos
    .local int rx494_rep
    .local pmc rx494_cur
    .local pmc rx494_debug
    (rx494_cur, rx494_pos, rx494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx494_cur
    .local pmc match
    .lex "$/", match
    length rx494_eos, rx494_tgt
    gt rx494_pos, rx494_eos, rx494_done
    set rx494_off, 0
    lt rx494_pos, 2, rx494_start
    sub rx494_off, rx494_pos, 1
    substr rx494_tgt, rx494_tgt, rx494_off
  rx494_start:
    eq $I10, 1, rx494_restart
    if_null rx494_debug, debug_754
    rx494_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_754:
    $I10 = self.'from'()
    ne $I10, -1, rxscan497_done
    goto rxscan497_scan
  rxscan497_loop:
    (rx494_pos) = rx494_cur."from"()
    inc rx494_pos
    rx494_cur."!cursor_from"(rx494_pos)
    ge rx494_pos, rx494_eos, rxscan497_done
  rxscan497_scan:
    set_addr $I10, rxscan497_loop
    rx494_cur."!mark_push"(0, rx494_pos, $I10)
  rxscan497_done:
.annotate 'line', 228
  # rx subcapture "sym"
    set_addr $I10, rxcap_498_fail
    rx494_cur."!mark_push"(0, rx494_pos, $I10)
  # rx literal  "for"
    add $I11, rx494_pos, 3
    gt $I11, rx494_eos, rx494_fail
    sub $I11, rx494_pos, rx494_off
    substr $S10, rx494_tgt, $I11, 3
    ne $S10, "for", rx494_fail
    add rx494_pos, 3
    set_addr $I10, rxcap_498_fail
    ($I12, $I11) = rx494_cur."!mark_peek"($I10)
    rx494_cur."!cursor_pos"($I11)
    ($P10) = rx494_cur."!cursor_start"()
    $P10."!cursor_pass"(rx494_pos, "")
    rx494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_498_done
  rxcap_498_fail:
    goto rx494_fail
  rxcap_498_done:
  # rx charclass s
    ge rx494_pos, rx494_eos, rx494_fail
    sub $I10, rx494_pos, rx494_off
    is_cclass $I11, 32, rx494_tgt, $I10
    unless $I11, rx494_fail
    inc rx494_pos
  # rx subrule "ws" subtype=method negate=
    rx494_cur."!cursor_pos"(rx494_pos)
    $P10 = rx494_cur."ws"()
    unless $P10, rx494_fail
    rx494_pos = $P10."pos"()
.annotate 'line', 229
  # rx subrule "xblock" subtype=capture negate=
    rx494_cur."!cursor_pos"(rx494_pos)
    $P10 = rx494_cur."xblock"()
    unless $P10, rx494_fail
    rx494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx494_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx494_cur."!cursor_pos"(rx494_pos)
    $P10 = rx494_cur."ws"()
    unless $P10, rx494_fail
    rx494_pos = $P10."pos"()
.annotate 'line', 227
  # rx pass
    rx494_cur."!cursor_pass"(rx494_pos, "statement_control:sym<for>")
    if_null rx494_debug, debug_755
    rx494_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx494_pos)
  debug_755:
    .return (rx494_cur)
  rx494_restart:
.annotate 'line', 10
    if_null rx494_debug, debug_756
    rx494_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_756:
  rx494_fail:
    (rx494_rep, rx494_pos, $I10, $P10) = rx494_cur."!mark_fail"(0)
    lt rx494_pos, -1, rx494_done
    eq rx494_pos, -1, rx494_fail
    jump $I10
  rx494_done:
    rx494_cur."!cursor_fail"()
    if_null rx494_debug, debug_757
    rx494_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_757:
    .return (rx494_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("79_1303923618.727") :method
.annotate 'line', 10
    new $P496, "ResizablePMCArray"
    push $P496, "for"
    .return ($P496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx502_tgt
    .local int rx502_pos
    .local int rx502_off
    .local int rx502_eos
    .local int rx502_rep
    .local pmc rx502_cur
    .local pmc rx502_debug
    (rx502_cur, rx502_pos, rx502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx502_cur
    .local pmc match
    .lex "$/", match
    length rx502_eos, rx502_tgt
    gt rx502_pos, rx502_eos, rx502_done
    set rx502_off, 0
    lt rx502_pos, 2, rx502_start
    sub rx502_off, rx502_pos, 1
    substr rx502_tgt, rx502_tgt, rx502_off
  rx502_start:
    eq $I10, 1, rx502_restart
    if_null rx502_debug, debug_758
    rx502_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_758:
    $I10 = self.'from'()
    ne $I10, -1, rxscan505_done
    goto rxscan505_scan
  rxscan505_loop:
    (rx502_pos) = rx502_cur."from"()
    inc rx502_pos
    rx502_cur."!cursor_from"(rx502_pos)
    ge rx502_pos, rx502_eos, rxscan505_done
  rxscan505_scan:
    set_addr $I10, rxscan505_loop
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  rxscan505_done:
.annotate 'line', 233
  # rx subcapture "sym"
    set_addr $I10, rxcap_506_fail
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx502_pos, 5
    gt $I11, rx502_eos, rx502_fail
    sub $I11, rx502_pos, rx502_off
    substr $S10, rx502_tgt, $I11, 5
    ne $S10, "CATCH", rx502_fail
    add rx502_pos, 5
    set_addr $I10, rxcap_506_fail
    ($I12, $I11) = rx502_cur."!mark_peek"($I10)
    rx502_cur."!cursor_pos"($I11)
    ($P10) = rx502_cur."!cursor_start"()
    $P10."!cursor_pass"(rx502_pos, "")
    rx502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_506_done
  rxcap_506_fail:
    goto rx502_fail
  rxcap_506_done:
  # rx charclass s
    ge rx502_pos, rx502_eos, rx502_fail
    sub $I10, rx502_pos, rx502_off
    is_cclass $I11, 32, rx502_tgt, $I10
    unless $I11, rx502_fail
    inc rx502_pos
  # rx subrule "ws" subtype=method negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."ws"()
    unless $P10, rx502_fail
    rx502_pos = $P10."pos"()
.annotate 'line', 234
  # rx subrule "block" subtype=capture negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."block"()
    unless $P10, rx502_fail
    rx502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx502_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."ws"()
    unless $P10, rx502_fail
    rx502_pos = $P10."pos"()
.annotate 'line', 232
  # rx pass
    rx502_cur."!cursor_pass"(rx502_pos, "statement_control:sym<CATCH>")
    if_null rx502_debug, debug_759
    rx502_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx502_pos)
  debug_759:
    .return (rx502_cur)
  rx502_restart:
.annotate 'line', 10
    if_null rx502_debug, debug_760
    rx502_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_760:
  rx502_fail:
    (rx502_rep, rx502_pos, $I10, $P10) = rx502_cur."!mark_fail"(0)
    lt rx502_pos, -1, rx502_done
    eq rx502_pos, -1, rx502_fail
    jump $I10
  rx502_done:
    rx502_cur."!cursor_fail"()
    if_null rx502_debug, debug_761
    rx502_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_761:
    .return (rx502_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("81_1303923618.727") :method
.annotate 'line', 10
    new $P504, "ResizablePMCArray"
    push $P504, "CATCH"
    .return ($P504)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx510_tgt
    .local int rx510_pos
    .local int rx510_off
    .local int rx510_eos
    .local int rx510_rep
    .local pmc rx510_cur
    .local pmc rx510_debug
    (rx510_cur, rx510_pos, rx510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx510_cur
    .local pmc match
    .lex "$/", match
    length rx510_eos, rx510_tgt
    gt rx510_pos, rx510_eos, rx510_done
    set rx510_off, 0
    lt rx510_pos, 2, rx510_start
    sub rx510_off, rx510_pos, 1
    substr rx510_tgt, rx510_tgt, rx510_off
  rx510_start:
    eq $I10, 1, rx510_restart
    if_null rx510_debug, debug_762
    rx510_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan513_done
    goto rxscan513_scan
  rxscan513_loop:
    (rx510_pos) = rx510_cur."from"()
    inc rx510_pos
    rx510_cur."!cursor_from"(rx510_pos)
    ge rx510_pos, rx510_eos, rxscan513_done
  rxscan513_scan:
    set_addr $I10, rxscan513_loop
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  rxscan513_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_514_fail
    rx510_cur."!mark_push"(0, rx510_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx510_pos, 7
    gt $I11, rx510_eos, rx510_fail
    sub $I11, rx510_pos, rx510_off
    substr $S10, rx510_tgt, $I11, 7
    ne $S10, "CONTROL", rx510_fail
    add rx510_pos, 7
    set_addr $I10, rxcap_514_fail
    ($I12, $I11) = rx510_cur."!mark_peek"($I10)
    rx510_cur."!cursor_pos"($I11)
    ($P10) = rx510_cur."!cursor_start"()
    $P10."!cursor_pass"(rx510_pos, "")
    rx510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_514_done
  rxcap_514_fail:
    goto rx510_fail
  rxcap_514_done:
  # rx charclass s
    ge rx510_pos, rx510_eos, rx510_fail
    sub $I10, rx510_pos, rx510_off
    is_cclass $I11, 32, rx510_tgt, $I10
    unless $I11, rx510_fail
    inc rx510_pos
  # rx subrule "ws" subtype=method negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."ws"()
    unless $P10, rx510_fail
    rx510_pos = $P10."pos"()
.annotate 'line', 239
  # rx subrule "block" subtype=capture negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."block"()
    unless $P10, rx510_fail
    rx510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx510_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx510_cur."!cursor_pos"(rx510_pos)
    $P10 = rx510_cur."ws"()
    unless $P10, rx510_fail
    rx510_pos = $P10."pos"()
.annotate 'line', 237
  # rx pass
    rx510_cur."!cursor_pass"(rx510_pos, "statement_control:sym<CONTROL>")
    if_null rx510_debug, debug_763
    rx510_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx510_pos)
  debug_763:
    .return (rx510_cur)
  rx510_restart:
.annotate 'line', 10
    if_null rx510_debug, debug_764
    rx510_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_764:
  rx510_fail:
    (rx510_rep, rx510_pos, $I10, $P10) = rx510_cur."!mark_fail"(0)
    lt rx510_pos, -1, rx510_done
    eq rx510_pos, -1, rx510_fail
    jump $I10
  rx510_done:
    rx510_cur."!cursor_fail"()
    if_null rx510_debug, debug_765
    rx510_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_765:
    .return (rx510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("83_1303923618.727") :method
.annotate 'line', 10
    new $P512, "ResizablePMCArray"
    push $P512, "CONTROL"
    .return ($P512)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1303923618.727")
    .param pmc param_518
.annotate 'line', 242
    .lex "self", param_518
    $P519 = param_518."!protoregex"("statement_prefix")
    .return ($P519)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1303923618.727")
    .param pmc param_521
.annotate 'line', 242
    .lex "self", param_521
    $P522 = param_521."!PREFIX__!protoregex"("statement_prefix")
    .return ($P522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx524_tgt
    .local int rx524_pos
    .local int rx524_off
    .local int rx524_eos
    .local int rx524_rep
    .local pmc rx524_cur
    .local pmc rx524_debug
    (rx524_cur, rx524_pos, rx524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx524_cur
    .local pmc match
    .lex "$/", match
    length rx524_eos, rx524_tgt
    gt rx524_pos, rx524_eos, rx524_done
    set rx524_off, 0
    lt rx524_pos, 2, rx524_start
    sub rx524_off, rx524_pos, 1
    substr rx524_tgt, rx524_tgt, rx524_off
  rx524_start:
    eq $I10, 1, rx524_restart
    if_null rx524_debug, debug_766
    rx524_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan528_done
    goto rxscan528_scan
  rxscan528_loop:
    (rx524_pos) = rx524_cur."from"()
    inc rx524_pos
    rx524_cur."!cursor_from"(rx524_pos)
    ge rx524_pos, rx524_eos, rxscan528_done
  rxscan528_scan:
    set_addr $I10, rxscan528_loop
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  rxscan528_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_529_fail
    rx524_cur."!mark_push"(0, rx524_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx524_pos, 4
    gt $I11, rx524_eos, rx524_fail
    sub $I11, rx524_pos, rx524_off
    substr $S10, rx524_tgt, $I11, 4
    ne $S10, "INIT", rx524_fail
    add rx524_pos, 4
    set_addr $I10, rxcap_529_fail
    ($I12, $I11) = rx524_cur."!mark_peek"($I10)
    rx524_cur."!cursor_pos"($I11)
    ($P10) = rx524_cur."!cursor_start"()
    $P10."!cursor_pass"(rx524_pos, "")
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_529_done
  rxcap_529_fail:
    goto rx524_fail
  rxcap_529_done:
  # rx subrule "blorst" subtype=capture negate=
    rx524_cur."!cursor_pos"(rx524_pos)
    $P10 = rx524_cur."blorst"()
    unless $P10, rx524_fail
    rx524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx524_pos = $P10."pos"()
  # rx pass
    rx524_cur."!cursor_pass"(rx524_pos, "statement_prefix:sym<INIT>")
    if_null rx524_debug, debug_767
    rx524_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx524_pos)
  debug_767:
    .return (rx524_cur)
  rx524_restart:
.annotate 'line', 10
    if_null rx524_debug, debug_768
    rx524_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_768:
  rx524_fail:
    (rx524_rep, rx524_pos, $I10, $P10) = rx524_cur."!mark_fail"(0)
    lt rx524_pos, -1, rx524_done
    eq rx524_pos, -1, rx524_fail
    jump $I10
  rx524_done:
    rx524_cur."!cursor_fail"()
    if_null rx524_debug, debug_769
    rx524_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_769:
    .return (rx524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("87_1303923618.727") :method
.annotate 'line', 10
    $P526 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P527, "ResizablePMCArray"
    push $P527, $P526
    .return ($P527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx531_tgt
    .local int rx531_pos
    .local int rx531_off
    .local int rx531_eos
    .local int rx531_rep
    .local pmc rx531_cur
    .local pmc rx531_debug
    (rx531_cur, rx531_pos, rx531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx531_cur
    .local pmc match
    .lex "$/", match
    length rx531_eos, rx531_tgt
    gt rx531_pos, rx531_eos, rx531_done
    set rx531_off, 0
    lt rx531_pos, 2, rx531_start
    sub rx531_off, rx531_pos, 1
    substr rx531_tgt, rx531_tgt, rx531_off
  rx531_start:
    eq $I10, 1, rx531_restart
    if_null rx531_debug, debug_770
    rx531_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan535_done
    goto rxscan535_scan
  rxscan535_loop:
    (rx531_pos) = rx531_cur."from"()
    inc rx531_pos
    rx531_cur."!cursor_from"(rx531_pos)
    ge rx531_pos, rx531_eos, rxscan535_done
  rxscan535_scan:
    set_addr $I10, rxscan535_loop
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  rxscan535_done:
.annotate 'line', 246
  # rx subcapture "sym"
    set_addr $I10, rxcap_536_fail
    rx531_cur."!mark_push"(0, rx531_pos, $I10)
  # rx literal  "try"
    add $I11, rx531_pos, 3
    gt $I11, rx531_eos, rx531_fail
    sub $I11, rx531_pos, rx531_off
    substr $S10, rx531_tgt, $I11, 3
    ne $S10, "try", rx531_fail
    add rx531_pos, 3
    set_addr $I10, rxcap_536_fail
    ($I12, $I11) = rx531_cur."!mark_peek"($I10)
    rx531_cur."!cursor_pos"($I11)
    ($P10) = rx531_cur."!cursor_start"()
    $P10."!cursor_pass"(rx531_pos, "")
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_536_done
  rxcap_536_fail:
    goto rx531_fail
  rxcap_536_done:
.annotate 'line', 247
  # rx subrule "blorst" subtype=capture negate=
    rx531_cur."!cursor_pos"(rx531_pos)
    $P10 = rx531_cur."blorst"()
    unless $P10, rx531_fail
    rx531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx531_pos = $P10."pos"()
.annotate 'line', 245
  # rx pass
    rx531_cur."!cursor_pass"(rx531_pos, "statement_prefix:sym<try>")
    if_null rx531_debug, debug_771
    rx531_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx531_pos)
  debug_771:
    .return (rx531_cur)
  rx531_restart:
.annotate 'line', 10
    if_null rx531_debug, debug_772
    rx531_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_772:
  rx531_fail:
    (rx531_rep, rx531_pos, $I10, $P10) = rx531_cur."!mark_fail"(0)
    lt rx531_pos, -1, rx531_done
    eq rx531_pos, -1, rx531_fail
    jump $I10
  rx531_done:
    rx531_cur."!cursor_fail"()
    if_null rx531_debug, debug_773
    rx531_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_773:
    .return (rx531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("89_1303923618.727") :method
.annotate 'line', 10
    $P533 = self."!PREFIX__!subrule"("blorst", "try")
    new $P534, "ResizablePMCArray"
    push $P534, $P533
    .return ($P534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx538_tgt
    .local int rx538_pos
    .local int rx538_off
    .local int rx538_eos
    .local int rx538_rep
    .local pmc rx538_cur
    .local pmc rx538_debug
    (rx538_cur, rx538_pos, rx538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx538_cur
    .local pmc match
    .lex "$/", match
    length rx538_eos, rx538_tgt
    gt rx538_pos, rx538_eos, rx538_done
    set rx538_off, 0
    lt rx538_pos, 2, rx538_start
    sub rx538_off, rx538_pos, 1
    substr rx538_tgt, rx538_tgt, rx538_off
  rx538_start:
    eq $I10, 1, rx538_restart
    if_null rx538_debug, debug_774
    rx538_cur."!cursor_debug"("START", "blorst")
  debug_774:
    $I10 = self.'from'()
    ne $I10, -1, rxscan541_done
    goto rxscan541_scan
  rxscan541_loop:
    (rx538_pos) = rx538_cur."from"()
    inc rx538_pos
    rx538_cur."!cursor_from"(rx538_pos)
    ge rx538_pos, rx538_eos, rxscan541_done
  rxscan541_scan:
    set_addr $I10, rxscan541_loop
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  rxscan541_done:
.annotate 'line', 251
  # rx charclass s
    ge rx538_pos, rx538_eos, rx538_fail
    sub $I10, rx538_pos, rx538_off
    is_cclass $I11, 32, rx538_tgt, $I10
    unless $I11, rx538_fail
    inc rx538_pos
  # rx subrule "ws" subtype=method negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."ws"()
    unless $P10, rx538_fail
    rx538_pos = $P10."pos"()
  alt542_0:
    set_addr $I10, alt542_1
    rx538_cur."!mark_push"(0, rx538_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx538_pos, rx538_off
    substr $S10, rx538_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx538_fail
  # rx subrule "block" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."block"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx538_pos = $P10."pos"()
    goto alt542_end
  alt542_1:
  # rx subrule "statement" subtype=capture negate=
    rx538_cur."!cursor_pos"(rx538_pos)
    $P10 = rx538_cur."statement"()
    unless $P10, rx538_fail
    rx538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx538_pos = $P10."pos"()
  alt542_end:
.annotate 'line', 250
  # rx pass
    rx538_cur."!cursor_pass"(rx538_pos, "blorst")
    if_null rx538_debug, debug_775
    rx538_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx538_pos)
  debug_775:
    .return (rx538_cur)
  rx538_restart:
.annotate 'line', 10
    if_null rx538_debug, debug_776
    rx538_cur."!cursor_debug"("NEXT", "blorst")
  debug_776:
  rx538_fail:
    (rx538_rep, rx538_pos, $I10, $P10) = rx538_cur."!mark_fail"(0)
    lt rx538_pos, -1, rx538_done
    eq rx538_pos, -1, rx538_fail
    jump $I10
  rx538_done:
    rx538_cur."!cursor_fail"()
    if_null rx538_debug, debug_777
    rx538_cur."!cursor_debug"("FAIL", "blorst")
  debug_777:
    .return (rx538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("91_1303923618.727") :method
.annotate 'line', 10
    new $P540, "ResizablePMCArray"
    push $P540, ""
    .return ($P540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1303923618.727")
    .param pmc param_544
.annotate 'line', 256
    .lex "self", param_544
    $P545 = param_544."!protoregex"("statement_mod_cond")
    .return ($P545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1303923618.727")
    .param pmc param_547
.annotate 'line', 256
    .lex "self", param_547
    $P548 = param_547."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P548)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx550_tgt
    .local int rx550_pos
    .local int rx550_off
    .local int rx550_eos
    .local int rx550_rep
    .local pmc rx550_cur
    .local pmc rx550_debug
    (rx550_cur, rx550_pos, rx550_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx550_cur
    .local pmc match
    .lex "$/", match
    length rx550_eos, rx550_tgt
    gt rx550_pos, rx550_eos, rx550_done
    set rx550_off, 0
    lt rx550_pos, 2, rx550_start
    sub rx550_off, rx550_pos, 1
    substr rx550_tgt, rx550_tgt, rx550_off
  rx550_start:
    eq $I10, 1, rx550_restart
    if_null rx550_debug, debug_778
    rx550_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_778:
    $I10 = self.'from'()
    ne $I10, -1, rxscan554_done
    goto rxscan554_scan
  rxscan554_loop:
    (rx550_pos) = rx550_cur."from"()
    inc rx550_pos
    rx550_cur."!cursor_from"(rx550_pos)
    ge rx550_pos, rx550_eos, rxscan554_done
  rxscan554_scan:
    set_addr $I10, rxscan554_loop
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  rxscan554_done:
.annotate 'line', 258
  # rx subcapture "sym"
    set_addr $I10, rxcap_555_fail
    rx550_cur."!mark_push"(0, rx550_pos, $I10)
  # rx literal  "if"
    add $I11, rx550_pos, 2
    gt $I11, rx550_eos, rx550_fail
    sub $I11, rx550_pos, rx550_off
    substr $S10, rx550_tgt, $I11, 2
    ne $S10, "if", rx550_fail
    add rx550_pos, 2
    set_addr $I10, rxcap_555_fail
    ($I12, $I11) = rx550_cur."!mark_peek"($I10)
    rx550_cur."!cursor_pos"($I11)
    ($P10) = rx550_cur."!cursor_start"()
    $P10."!cursor_pass"(rx550_pos, "")
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_555_done
  rxcap_555_fail:
    goto rx550_fail
  rxcap_555_done:
  # rx subrule "ws" subtype=method negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."ws"()
    unless $P10, rx550_fail
    rx550_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."EXPR"()
    unless $P10, rx550_fail
    rx550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx550_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx550_cur."!cursor_pos"(rx550_pos)
    $P10 = rx550_cur."ws"()
    unless $P10, rx550_fail
    rx550_pos = $P10."pos"()
  # rx pass
    rx550_cur."!cursor_pass"(rx550_pos, "statement_mod_cond:sym<if>")
    if_null rx550_debug, debug_779
    rx550_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx550_pos)
  debug_779:
    .return (rx550_cur)
  rx550_restart:
.annotate 'line', 10
    if_null rx550_debug, debug_780
    rx550_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_780:
  rx550_fail:
    (rx550_rep, rx550_pos, $I10, $P10) = rx550_cur."!mark_fail"(0)
    lt rx550_pos, -1, rx550_done
    eq rx550_pos, -1, rx550_fail
    jump $I10
  rx550_done:
    rx550_cur."!cursor_fail"()
    if_null rx550_debug, debug_781
    rx550_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_781:
    .return (rx550_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("95_1303923618.727") :method
.annotate 'line', 10
    $P552 = self."!PREFIX__!subrule"("ws", "if")
    new $P553, "ResizablePMCArray"
    push $P553, $P552
    .return ($P553)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx559_tgt
    .local int rx559_pos
    .local int rx559_off
    .local int rx559_eos
    .local int rx559_rep
    .local pmc rx559_cur
    .local pmc rx559_debug
    (rx559_cur, rx559_pos, rx559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx559_cur
    .local pmc match
    .lex "$/", match
    length rx559_eos, rx559_tgt
    gt rx559_pos, rx559_eos, rx559_done
    set rx559_off, 0
    lt rx559_pos, 2, rx559_start
    sub rx559_off, rx559_pos, 1
    substr rx559_tgt, rx559_tgt, rx559_off
  rx559_start:
    eq $I10, 1, rx559_restart
    if_null rx559_debug, debug_782
    rx559_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_782:
    $I10 = self.'from'()
    ne $I10, -1, rxscan563_done
    goto rxscan563_scan
  rxscan563_loop:
    (rx559_pos) = rx559_cur."from"()
    inc rx559_pos
    rx559_cur."!cursor_from"(rx559_pos)
    ge rx559_pos, rx559_eos, rxscan563_done
  rxscan563_scan:
    set_addr $I10, rxscan563_loop
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  rxscan563_done:
.annotate 'line', 259
  # rx subcapture "sym"
    set_addr $I10, rxcap_564_fail
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  # rx literal  "unless"
    add $I11, rx559_pos, 6
    gt $I11, rx559_eos, rx559_fail
    sub $I11, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I11, 6
    ne $S10, "unless", rx559_fail
    add rx559_pos, 6
    set_addr $I10, rxcap_564_fail
    ($I12, $I11) = rx559_cur."!mark_peek"($I10)
    rx559_cur."!cursor_pos"($I11)
    ($P10) = rx559_cur."!cursor_start"()
    $P10."!cursor_pass"(rx559_pos, "")
    rx559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_564_done
  rxcap_564_fail:
    goto rx559_fail
  rxcap_564_done:
  # rx subrule "ws" subtype=method negate=
    rx559_cur."!cursor_pos"(rx559_pos)
    $P10 = rx559_cur."ws"()
    unless $P10, rx559_fail
    rx559_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx559_cur."!cursor_pos"(rx559_pos)
    $P10 = rx559_cur."EXPR"()
    unless $P10, rx559_fail
    rx559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx559_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx559_cur."!cursor_pos"(rx559_pos)
    $P10 = rx559_cur."ws"()
    unless $P10, rx559_fail
    rx559_pos = $P10."pos"()
  # rx pass
    rx559_cur."!cursor_pass"(rx559_pos, "statement_mod_cond:sym<unless>")
    if_null rx559_debug, debug_783
    rx559_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx559_pos)
  debug_783:
    .return (rx559_cur)
  rx559_restart:
.annotate 'line', 10
    if_null rx559_debug, debug_784
    rx559_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_784:
  rx559_fail:
    (rx559_rep, rx559_pos, $I10, $P10) = rx559_cur."!mark_fail"(0)
    lt rx559_pos, -1, rx559_done
    eq rx559_pos, -1, rx559_fail
    jump $I10
  rx559_done:
    rx559_cur."!cursor_fail"()
    if_null rx559_debug, debug_785
    rx559_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_785:
    .return (rx559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("97_1303923618.727") :method
.annotate 'line', 10
    $P561 = self."!PREFIX__!subrule"("ws", "unless")
    new $P562, "ResizablePMCArray"
    push $P562, $P561
    .return ($P562)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1303923618.727")
    .param pmc param_568
.annotate 'line', 261
    .lex "self", param_568
    $P569 = param_568."!protoregex"("statement_mod_loop")
    .return ($P569)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1303923618.727")
    .param pmc param_571
.annotate 'line', 261
    .lex "self", param_571
    $P572 = param_571."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P572)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx574_tgt
    .local int rx574_pos
    .local int rx574_off
    .local int rx574_eos
    .local int rx574_rep
    .local pmc rx574_cur
    .local pmc rx574_debug
    (rx574_cur, rx574_pos, rx574_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx574_cur
    .local pmc match
    .lex "$/", match
    length rx574_eos, rx574_tgt
    gt rx574_pos, rx574_eos, rx574_done
    set rx574_off, 0
    lt rx574_pos, 2, rx574_start
    sub rx574_off, rx574_pos, 1
    substr rx574_tgt, rx574_tgt, rx574_off
  rx574_start:
    eq $I10, 1, rx574_restart
    if_null rx574_debug, debug_786
    rx574_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_786:
    $I10 = self.'from'()
    ne $I10, -1, rxscan578_done
    goto rxscan578_scan
  rxscan578_loop:
    (rx574_pos) = rx574_cur."from"()
    inc rx574_pos
    rx574_cur."!cursor_from"(rx574_pos)
    ge rx574_pos, rx574_eos, rxscan578_done
  rxscan578_scan:
    set_addr $I10, rxscan578_loop
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxscan578_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_579_fail
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  # rx literal  "while"
    add $I11, rx574_pos, 5
    gt $I11, rx574_eos, rx574_fail
    sub $I11, rx574_pos, rx574_off
    substr $S10, rx574_tgt, $I11, 5
    ne $S10, "while", rx574_fail
    add rx574_pos, 5
    set_addr $I10, rxcap_579_fail
    ($I12, $I11) = rx574_cur."!mark_peek"($I10)
    rx574_cur."!cursor_pos"($I11)
    ($P10) = rx574_cur."!cursor_start"()
    $P10."!cursor_pass"(rx574_pos, "")
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_579_done
  rxcap_579_fail:
    goto rx574_fail
  rxcap_579_done:
  # rx subrule "ws" subtype=method negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."ws"()
    unless $P10, rx574_fail
    rx574_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."EXPR"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx574_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."ws"()
    unless $P10, rx574_fail
    rx574_pos = $P10."pos"()
  # rx pass
    rx574_cur."!cursor_pass"(rx574_pos, "statement_mod_loop:sym<while>")
    if_null rx574_debug, debug_787
    rx574_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx574_pos)
  debug_787:
    .return (rx574_cur)
  rx574_restart:
.annotate 'line', 10
    if_null rx574_debug, debug_788
    rx574_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_788:
  rx574_fail:
    (rx574_rep, rx574_pos, $I10, $P10) = rx574_cur."!mark_fail"(0)
    lt rx574_pos, -1, rx574_done
    eq rx574_pos, -1, rx574_fail
    jump $I10
  rx574_done:
    rx574_cur."!cursor_fail"()
    if_null rx574_debug, debug_789
    rx574_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_789:
    .return (rx574_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("101_1303923618.727") :method
.annotate 'line', 10
    $P576 = self."!PREFIX__!subrule"("ws", "while")
    new $P577, "ResizablePMCArray"
    push $P577, $P576
    .return ($P577)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx583_tgt
    .local int rx583_pos
    .local int rx583_off
    .local int rx583_eos
    .local int rx583_rep
    .local pmc rx583_cur
    .local pmc rx583_debug
    (rx583_cur, rx583_pos, rx583_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx583_cur
    .local pmc match
    .lex "$/", match
    length rx583_eos, rx583_tgt
    gt rx583_pos, rx583_eos, rx583_done
    set rx583_off, 0
    lt rx583_pos, 2, rx583_start
    sub rx583_off, rx583_pos, 1
    substr rx583_tgt, rx583_tgt, rx583_off
  rx583_start:
    eq $I10, 1, rx583_restart
    if_null rx583_debug, debug_790
    rx583_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_790:
    $I10 = self.'from'()
    ne $I10, -1, rxscan587_done
    goto rxscan587_scan
  rxscan587_loop:
    (rx583_pos) = rx583_cur."from"()
    inc rx583_pos
    rx583_cur."!cursor_from"(rx583_pos)
    ge rx583_pos, rx583_eos, rxscan587_done
  rxscan587_scan:
    set_addr $I10, rxscan587_loop
    rx583_cur."!mark_push"(0, rx583_pos, $I10)
  rxscan587_done:
.annotate 'line', 264
  # rx subcapture "sym"
    set_addr $I10, rxcap_588_fail
    rx583_cur."!mark_push"(0, rx583_pos, $I10)
  # rx literal  "until"
    add $I11, rx583_pos, 5
    gt $I11, rx583_eos, rx583_fail
    sub $I11, rx583_pos, rx583_off
    substr $S10, rx583_tgt, $I11, 5
    ne $S10, "until", rx583_fail
    add rx583_pos, 5
    set_addr $I10, rxcap_588_fail
    ($I12, $I11) = rx583_cur."!mark_peek"($I10)
    rx583_cur."!cursor_pos"($I11)
    ($P10) = rx583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx583_pos, "")
    rx583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_588_done
  rxcap_588_fail:
    goto rx583_fail
  rxcap_588_done:
  # rx subrule "ws" subtype=method negate=
    rx583_cur."!cursor_pos"(rx583_pos)
    $P10 = rx583_cur."ws"()
    unless $P10, rx583_fail
    rx583_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx583_cur."!cursor_pos"(rx583_pos)
    $P10 = rx583_cur."EXPR"()
    unless $P10, rx583_fail
    rx583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx583_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx583_cur."!cursor_pos"(rx583_pos)
    $P10 = rx583_cur."ws"()
    unless $P10, rx583_fail
    rx583_pos = $P10."pos"()
  # rx pass
    rx583_cur."!cursor_pass"(rx583_pos, "statement_mod_loop:sym<until>")
    if_null rx583_debug, debug_791
    rx583_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx583_pos)
  debug_791:
    .return (rx583_cur)
  rx583_restart:
.annotate 'line', 10
    if_null rx583_debug, debug_792
    rx583_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_792:
  rx583_fail:
    (rx583_rep, rx583_pos, $I10, $P10) = rx583_cur."!mark_fail"(0)
    lt rx583_pos, -1, rx583_done
    eq rx583_pos, -1, rx583_fail
    jump $I10
  rx583_done:
    rx583_cur."!cursor_fail"()
    if_null rx583_debug, debug_793
    rx583_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_793:
    .return (rx583_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("103_1303923618.727") :method
.annotate 'line', 10
    $P585 = self."!PREFIX__!subrule"("ws", "until")
    new $P586, "ResizablePMCArray"
    push $P586, $P585
    .return ($P586)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx592_tgt
    .local int rx592_pos
    .local int rx592_off
    .local int rx592_eos
    .local int rx592_rep
    .local pmc rx592_cur
    .local pmc rx592_debug
    (rx592_cur, rx592_pos, rx592_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx592_cur
    .local pmc match
    .lex "$/", match
    length rx592_eos, rx592_tgt
    gt rx592_pos, rx592_eos, rx592_done
    set rx592_off, 0
    lt rx592_pos, 2, rx592_start
    sub rx592_off, rx592_pos, 1
    substr rx592_tgt, rx592_tgt, rx592_off
  rx592_start:
    eq $I10, 1, rx592_restart
    if_null rx592_debug, debug_794
    rx592_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan596_done
    goto rxscan596_scan
  rxscan596_loop:
    (rx592_pos) = rx592_cur."from"()
    inc rx592_pos
    rx592_cur."!cursor_from"(rx592_pos)
    ge rx592_pos, rx592_eos, rxscan596_done
  rxscan596_scan:
    set_addr $I10, rxscan596_loop
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  rxscan596_done:
.annotate 'line', 265
  # rx subcapture "sym"
    set_addr $I10, rxcap_597_fail
    rx592_cur."!mark_push"(0, rx592_pos, $I10)
  # rx literal  "for"
    add $I11, rx592_pos, 3
    gt $I11, rx592_eos, rx592_fail
    sub $I11, rx592_pos, rx592_off
    substr $S10, rx592_tgt, $I11, 3
    ne $S10, "for", rx592_fail
    add rx592_pos, 3
    set_addr $I10, rxcap_597_fail
    ($I12, $I11) = rx592_cur."!mark_peek"($I10)
    rx592_cur."!cursor_pos"($I11)
    ($P10) = rx592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx592_pos, "")
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_597_done
  rxcap_597_fail:
    goto rx592_fail
  rxcap_597_done:
  # rx subrule "ws" subtype=method negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."ws"()
    unless $P10, rx592_fail
    rx592_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."EXPR"()
    unless $P10, rx592_fail
    rx592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx592_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx592_cur."!cursor_pos"(rx592_pos)
    $P10 = rx592_cur."ws"()
    unless $P10, rx592_fail
    rx592_pos = $P10."pos"()
  # rx pass
    rx592_cur."!cursor_pass"(rx592_pos, "statement_mod_loop:sym<for>")
    if_null rx592_debug, debug_795
    rx592_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx592_pos)
  debug_795:
    .return (rx592_cur)
  rx592_restart:
.annotate 'line', 10
    if_null rx592_debug, debug_796
    rx592_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_796:
  rx592_fail:
    (rx592_rep, rx592_pos, $I10, $P10) = rx592_cur."!mark_fail"(0)
    lt rx592_pos, -1, rx592_done
    eq rx592_pos, -1, rx592_fail
    jump $I10
  rx592_done:
    rx592_cur."!cursor_fail"()
    if_null rx592_debug, debug_797
    rx592_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_797:
    .return (rx592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("105_1303923618.727") :method
.annotate 'line', 10
    $P594 = self."!PREFIX__!subrule"("ws", "for")
    new $P595, "ResizablePMCArray"
    push $P595, $P594
    .return ($P595)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx601_tgt
    .local int rx601_pos
    .local int rx601_off
    .local int rx601_eos
    .local int rx601_rep
    .local pmc rx601_cur
    .local pmc rx601_debug
    (rx601_cur, rx601_pos, rx601_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx601_cur
    .local pmc match
    .lex "$/", match
    length rx601_eos, rx601_tgt
    gt rx601_pos, rx601_eos, rx601_done
    set rx601_off, 0
    lt rx601_pos, 2, rx601_start
    sub rx601_off, rx601_pos, 1
    substr rx601_tgt, rx601_tgt, rx601_off
  rx601_start:
    eq $I10, 1, rx601_restart
    if_null rx601_debug, debug_798
    rx601_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_798:
    $I10 = self.'from'()
    ne $I10, -1, rxscan605_done
    goto rxscan605_scan
  rxscan605_loop:
    (rx601_pos) = rx601_cur."from"()
    inc rx601_pos
    rx601_cur."!cursor_from"(rx601_pos)
    ge rx601_pos, rx601_eos, rxscan605_done
  rxscan605_scan:
    set_addr $I10, rxscan605_loop
    rx601_cur."!mark_push"(0, rx601_pos, $I10)
  rxscan605_done:
.annotate 'line', 269
  # rx subrule "fatarrow" subtype=capture negate=
    rx601_cur."!cursor_pos"(rx601_pos)
    $P10 = rx601_cur."fatarrow"()
    unless $P10, rx601_fail
    rx601_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx601_pos = $P10."pos"()
  # rx pass
    rx601_cur."!cursor_pass"(rx601_pos, "term:sym<fatarrow>")
    if_null rx601_debug, debug_799
    rx601_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx601_pos)
  debug_799:
    .return (rx601_cur)
  rx601_restart:
.annotate 'line', 10
    if_null rx601_debug, debug_800
    rx601_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_800:
  rx601_fail:
    (rx601_rep, rx601_pos, $I10, $P10) = rx601_cur."!mark_fail"(0)
    lt rx601_pos, -1, rx601_done
    eq rx601_pos, -1, rx601_fail
    jump $I10
  rx601_done:
    rx601_cur."!cursor_fail"()
    if_null rx601_debug, debug_801
    rx601_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_801:
    .return (rx601_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("107_1303923618.727") :method
.annotate 'line', 10
    $P603 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P604, "ResizablePMCArray"
    push $P604, $P603
    .return ($P604)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx607_tgt
    .local int rx607_pos
    .local int rx607_off
    .local int rx607_eos
    .local int rx607_rep
    .local pmc rx607_cur
    .local pmc rx607_debug
    (rx607_cur, rx607_pos, rx607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx607_cur
    .local pmc match
    .lex "$/", match
    length rx607_eos, rx607_tgt
    gt rx607_pos, rx607_eos, rx607_done
    set rx607_off, 0
    lt rx607_pos, 2, rx607_start
    sub rx607_off, rx607_pos, 1
    substr rx607_tgt, rx607_tgt, rx607_off
  rx607_start:
    eq $I10, 1, rx607_restart
    if_null rx607_debug, debug_802
    rx607_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_802:
    $I10 = self.'from'()
    ne $I10, -1, rxscan611_done
    goto rxscan611_scan
  rxscan611_loop:
    (rx607_pos) = rx607_cur."from"()
    inc rx607_pos
    rx607_cur."!cursor_from"(rx607_pos)
    ge rx607_pos, rx607_eos, rxscan611_done
  rxscan611_scan:
    set_addr $I10, rxscan611_loop
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  rxscan611_done:
.annotate 'line', 270
  # rx subrule "colonpair" subtype=capture negate=
    rx607_cur."!cursor_pos"(rx607_pos)
    $P10 = rx607_cur."colonpair"()
    unless $P10, rx607_fail
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx607_pos = $P10."pos"()
  # rx pass
    rx607_cur."!cursor_pass"(rx607_pos, "term:sym<colonpair>")
    if_null rx607_debug, debug_803
    rx607_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx607_pos)
  debug_803:
    .return (rx607_cur)
  rx607_restart:
.annotate 'line', 10
    if_null rx607_debug, debug_804
    rx607_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_804:
  rx607_fail:
    (rx607_rep, rx607_pos, $I10, $P10) = rx607_cur."!mark_fail"(0)
    lt rx607_pos, -1, rx607_done
    eq rx607_pos, -1, rx607_fail
    jump $I10
  rx607_done:
    rx607_cur."!cursor_fail"()
    if_null rx607_debug, debug_805
    rx607_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_805:
    .return (rx607_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("109_1303923618.727") :method
.annotate 'line', 10
    $P609 = self."!PREFIX__!subrule"("colonpair", "")
    new $P610, "ResizablePMCArray"
    push $P610, $P609
    .return ($P610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx613_tgt
    .local int rx613_pos
    .local int rx613_off
    .local int rx613_eos
    .local int rx613_rep
    .local pmc rx613_cur
    .local pmc rx613_debug
    (rx613_cur, rx613_pos, rx613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx613_cur
    .local pmc match
    .lex "$/", match
    length rx613_eos, rx613_tgt
    gt rx613_pos, rx613_eos, rx613_done
    set rx613_off, 0
    lt rx613_pos, 2, rx613_start
    sub rx613_off, rx613_pos, 1
    substr rx613_tgt, rx613_tgt, rx613_off
  rx613_start:
    eq $I10, 1, rx613_restart
    if_null rx613_debug, debug_806
    rx613_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_806:
    $I10 = self.'from'()
    ne $I10, -1, rxscan617_done
    goto rxscan617_scan
  rxscan617_loop:
    (rx613_pos) = rx613_cur."from"()
    inc rx613_pos
    rx613_cur."!cursor_from"(rx613_pos)
    ge rx613_pos, rx613_eos, rxscan617_done
  rxscan617_scan:
    set_addr $I10, rxscan617_loop
    rx613_cur."!mark_push"(0, rx613_pos, $I10)
  rxscan617_done:
.annotate 'line', 271
  # rx subrule "variable" subtype=capture negate=
    rx613_cur."!cursor_pos"(rx613_pos)
    $P10 = rx613_cur."variable"()
    unless $P10, rx613_fail
    rx613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx613_pos = $P10."pos"()
  # rx pass
    rx613_cur."!cursor_pass"(rx613_pos, "term:sym<variable>")
    if_null rx613_debug, debug_807
    rx613_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx613_pos)
  debug_807:
    .return (rx613_cur)
  rx613_restart:
.annotate 'line', 10
    if_null rx613_debug, debug_808
    rx613_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_808:
  rx613_fail:
    (rx613_rep, rx613_pos, $I10, $P10) = rx613_cur."!mark_fail"(0)
    lt rx613_pos, -1, rx613_done
    eq rx613_pos, -1, rx613_fail
    jump $I10
  rx613_done:
    rx613_cur."!cursor_fail"()
    if_null rx613_debug, debug_809
    rx613_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_809:
    .return (rx613_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("111_1303923618.727") :method
.annotate 'line', 10
    $P615 = self."!PREFIX__!subrule"("variable", "")
    new $P616, "ResizablePMCArray"
    push $P616, $P615
    .return ($P616)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx619_tgt
    .local int rx619_pos
    .local int rx619_off
    .local int rx619_eos
    .local int rx619_rep
    .local pmc rx619_cur
    .local pmc rx619_debug
    (rx619_cur, rx619_pos, rx619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx619_cur
    .local pmc match
    .lex "$/", match
    length rx619_eos, rx619_tgt
    gt rx619_pos, rx619_eos, rx619_done
    set rx619_off, 0
    lt rx619_pos, 2, rx619_start
    sub rx619_off, rx619_pos, 1
    substr rx619_tgt, rx619_tgt, rx619_off
  rx619_start:
    eq $I10, 1, rx619_restart
    if_null rx619_debug, debug_810
    rx619_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan623_done
    goto rxscan623_scan
  rxscan623_loop:
    (rx619_pos) = rx619_cur."from"()
    inc rx619_pos
    rx619_cur."!cursor_from"(rx619_pos)
    ge rx619_pos, rx619_eos, rxscan623_done
  rxscan623_scan:
    set_addr $I10, rxscan623_loop
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  rxscan623_done:
.annotate 'line', 272
  # rx subrule "package_declarator" subtype=capture negate=
    rx619_cur."!cursor_pos"(rx619_pos)
    $P10 = rx619_cur."package_declarator"()
    unless $P10, rx619_fail
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx619_pos = $P10."pos"()
  # rx pass
    rx619_cur."!cursor_pass"(rx619_pos, "term:sym<package_declarator>")
    if_null rx619_debug, debug_811
    rx619_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx619_pos)
  debug_811:
    .return (rx619_cur)
  rx619_restart:
.annotate 'line', 10
    if_null rx619_debug, debug_812
    rx619_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_812:
  rx619_fail:
    (rx619_rep, rx619_pos, $I10, $P10) = rx619_cur."!mark_fail"(0)
    lt rx619_pos, -1, rx619_done
    eq rx619_pos, -1, rx619_fail
    jump $I10
  rx619_done:
    rx619_cur."!cursor_fail"()
    if_null rx619_debug, debug_813
    rx619_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_813:
    .return (rx619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("113_1303923618.727") :method
.annotate 'line', 10
    $P621 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P622, "ResizablePMCArray"
    push $P622, $P621
    .return ($P622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx625_tgt
    .local int rx625_pos
    .local int rx625_off
    .local int rx625_eos
    .local int rx625_rep
    .local pmc rx625_cur
    .local pmc rx625_debug
    (rx625_cur, rx625_pos, rx625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx625_cur
    .local pmc match
    .lex "$/", match
    length rx625_eos, rx625_tgt
    gt rx625_pos, rx625_eos, rx625_done
    set rx625_off, 0
    lt rx625_pos, 2, rx625_start
    sub rx625_off, rx625_pos, 1
    substr rx625_tgt, rx625_tgt, rx625_off
  rx625_start:
    eq $I10, 1, rx625_restart
    if_null rx625_debug, debug_814
    rx625_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_814:
    $I10 = self.'from'()
    ne $I10, -1, rxscan629_done
    goto rxscan629_scan
  rxscan629_loop:
    (rx625_pos) = rx625_cur."from"()
    inc rx625_pos
    rx625_cur."!cursor_from"(rx625_pos)
    ge rx625_pos, rx625_eos, rxscan629_done
  rxscan629_scan:
    set_addr $I10, rxscan629_loop
    rx625_cur."!mark_push"(0, rx625_pos, $I10)
  rxscan629_done:
.annotate 'line', 273
  # rx subrule "scope_declarator" subtype=capture negate=
    rx625_cur."!cursor_pos"(rx625_pos)
    $P10 = rx625_cur."scope_declarator"()
    unless $P10, rx625_fail
    rx625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx625_pos = $P10."pos"()
  # rx pass
    rx625_cur."!cursor_pass"(rx625_pos, "term:sym<scope_declarator>")
    if_null rx625_debug, debug_815
    rx625_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx625_pos)
  debug_815:
    .return (rx625_cur)
  rx625_restart:
.annotate 'line', 10
    if_null rx625_debug, debug_816
    rx625_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_816:
  rx625_fail:
    (rx625_rep, rx625_pos, $I10, $P10) = rx625_cur."!mark_fail"(0)
    lt rx625_pos, -1, rx625_done
    eq rx625_pos, -1, rx625_fail
    jump $I10
  rx625_done:
    rx625_cur."!cursor_fail"()
    if_null rx625_debug, debug_817
    rx625_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_817:
    .return (rx625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("115_1303923618.727") :method
.annotate 'line', 10
    $P627 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P628, "ResizablePMCArray"
    push $P628, $P627
    .return ($P628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx631_tgt
    .local int rx631_pos
    .local int rx631_off
    .local int rx631_eos
    .local int rx631_rep
    .local pmc rx631_cur
    .local pmc rx631_debug
    (rx631_cur, rx631_pos, rx631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx631_cur
    .local pmc match
    .lex "$/", match
    length rx631_eos, rx631_tgt
    gt rx631_pos, rx631_eos, rx631_done
    set rx631_off, 0
    lt rx631_pos, 2, rx631_start
    sub rx631_off, rx631_pos, 1
    substr rx631_tgt, rx631_tgt, rx631_off
  rx631_start:
    eq $I10, 1, rx631_restart
    if_null rx631_debug, debug_818
    rx631_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_818:
    $I10 = self.'from'()
    ne $I10, -1, rxscan635_done
    goto rxscan635_scan
  rxscan635_loop:
    (rx631_pos) = rx631_cur."from"()
    inc rx631_pos
    rx631_cur."!cursor_from"(rx631_pos)
    ge rx631_pos, rx631_eos, rxscan635_done
  rxscan635_scan:
    set_addr $I10, rxscan635_loop
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  rxscan635_done:
.annotate 'line', 274
  # rx subrule "routine_declarator" subtype=capture negate=
    rx631_cur."!cursor_pos"(rx631_pos)
    $P10 = rx631_cur."routine_declarator"()
    unless $P10, rx631_fail
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx631_pos = $P10."pos"()
  # rx pass
    rx631_cur."!cursor_pass"(rx631_pos, "term:sym<routine_declarator>")
    if_null rx631_debug, debug_819
    rx631_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx631_pos)
  debug_819:
    .return (rx631_cur)
  rx631_restart:
.annotate 'line', 10
    if_null rx631_debug, debug_820
    rx631_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_820:
  rx631_fail:
    (rx631_rep, rx631_pos, $I10, $P10) = rx631_cur."!mark_fail"(0)
    lt rx631_pos, -1, rx631_done
    eq rx631_pos, -1, rx631_fail
    jump $I10
  rx631_done:
    rx631_cur."!cursor_fail"()
    if_null rx631_debug, debug_821
    rx631_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_821:
    .return (rx631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("117_1303923618.727") :method
.annotate 'line', 10
    $P633 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P634, "ResizablePMCArray"
    push $P634, $P633
    .return ($P634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P647 = "121_1303923618.727" 
    capture_lex $P647
    .const 'Sub' $P642 = "120_1303923618.727" 
    capture_lex $P642
    .local string rx637_tgt
    .local int rx637_pos
    .local int rx637_off
    .local int rx637_eos
    .local int rx637_rep
    .local pmc rx637_cur
    .local pmc rx637_debug
    (rx637_cur, rx637_pos, rx637_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx637_cur
    .local pmc match
    .lex "$/", match
    length rx637_eos, rx637_tgt
    gt rx637_pos, rx637_eos, rx637_done
    set rx637_off, 0
    lt rx637_pos, 2, rx637_start
    sub rx637_off, rx637_pos, 1
    substr rx637_tgt, rx637_tgt, rx637_off
  rx637_start:
    eq $I10, 1, rx637_restart
    if_null rx637_debug, debug_822
    rx637_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_822:
    $I10 = self.'from'()
    ne $I10, -1, rxscan640_done
    goto rxscan640_scan
  rxscan640_loop:
    (rx637_pos) = rx637_cur."from"()
    inc rx637_pos
    rx637_cur."!cursor_from"(rx637_pos)
    ge rx637_pos, rx637_eos, rxscan640_done
  rxscan640_scan:
    set_addr $I10, rxscan640_loop
    rx637_cur."!mark_push"(0, rx637_pos, $I10)
  rxscan640_done:
.annotate 'line', 276
  # rx subrule "before" subtype=zerowidth negate=
    rx637_cur."!cursor_pos"(rx637_pos)
    .const 'Sub' $P642 = "120_1303923618.727" 
    capture_lex $P642
    $P10 = rx637_cur."before"($P642)
    unless $P10, rx637_fail
.annotate 'line', 277
  # rx subrule "before" subtype=zerowidth negate=1
    rx637_cur."!cursor_pos"(rx637_pos)
    .const 'Sub' $P647 = "121_1303923618.727" 
    capture_lex $P647
    $P10 = rx637_cur."before"($P647)
    if $P10, rx637_fail
.annotate 'line', 278
  # rx subrule "multi_declarator" subtype=capture negate=
    rx637_cur."!cursor_pos"(rx637_pos)
    $P10 = rx637_cur."multi_declarator"()
    unless $P10, rx637_fail
    rx637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx637_pos = $P10."pos"()
.annotate 'line', 275
  # rx pass
    rx637_cur."!cursor_pass"(rx637_pos, "term:sym<multi_declarator>")
    if_null rx637_debug, debug_831
    rx637_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx637_pos)
  debug_831:
    .return (rx637_cur)
  rx637_restart:
.annotate 'line', 10
    if_null rx637_debug, debug_832
    rx637_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_832:
  rx637_fail:
    (rx637_rep, rx637_pos, $I10, $P10) = rx637_cur."!mark_fail"(0)
    lt rx637_pos, -1, rx637_done
    eq rx637_pos, -1, rx637_fail
    jump $I10
  rx637_done:
    rx637_cur."!cursor_fail"()
    if_null rx637_debug, debug_833
    rx637_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_833:
    .return (rx637_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("119_1303923618.727") :method
.annotate 'line', 10
    new $P639, "ResizablePMCArray"
    push $P639, ""
    .return ($P639)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block641"  :anon :subid("120_1303923618.727") :method :outer("118_1303923618.727")
.annotate 'line', 276
    .local string rx643_tgt
    .local int rx643_pos
    .local int rx643_off
    .local int rx643_eos
    .local int rx643_rep
    .local pmc rx643_cur
    .local pmc rx643_debug
    (rx643_cur, rx643_pos, rx643_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx643_cur
    .local pmc match
    .lex "$/", match
    length rx643_eos, rx643_tgt
    gt rx643_pos, rx643_eos, rx643_done
    set rx643_off, 0
    lt rx643_pos, 2, rx643_start
    sub rx643_off, rx643_pos, 1
    substr rx643_tgt, rx643_tgt, rx643_off
  rx643_start:
    eq $I10, 1, rx643_restart
    if_null rx643_debug, debug_823
    rx643_cur."!cursor_debug"("START", "")
  debug_823:
    $I10 = self.'from'()
    ne $I10, -1, rxscan644_done
    goto rxscan644_scan
  rxscan644_loop:
    (rx643_pos) = rx643_cur."from"()
    inc rx643_pos
    rx643_cur."!cursor_from"(rx643_pos)
    ge rx643_pos, rx643_eos, rxscan644_done
  rxscan644_scan:
    set_addr $I10, rxscan644_loop
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  rxscan644_done:
  alt645_0:
    set_addr $I10, alt645_1
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  # rx literal  "multi"
    add $I11, rx643_pos, 5
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 5
    ne $S10, "multi", rx643_fail
    add rx643_pos, 5
    goto alt645_end
  alt645_1:
    set_addr $I10, alt645_2
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  # rx literal  "proto"
    add $I11, rx643_pos, 5
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 5
    ne $S10, "proto", rx643_fail
    add rx643_pos, 5
    goto alt645_end
  alt645_2:
  # rx literal  "only"
    add $I11, rx643_pos, 4
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 4
    ne $S10, "only", rx643_fail
    add rx643_pos, 4
  alt645_end:
  # rx pass
    rx643_cur."!cursor_pass"(rx643_pos, "")
    if_null rx643_debug, debug_824
    rx643_cur."!cursor_debug"("PASS", "", " at pos=", rx643_pos)
  debug_824:
    .return (rx643_cur)
  rx643_restart:
    if_null rx643_debug, debug_825
    rx643_cur."!cursor_debug"("NEXT", "")
  debug_825:
  rx643_fail:
    (rx643_rep, rx643_pos, $I10, $P10) = rx643_cur."!mark_fail"(0)
    lt rx643_pos, -1, rx643_done
    eq rx643_pos, -1, rx643_fail
    jump $I10
  rx643_done:
    rx643_cur."!cursor_fail"()
    if_null rx643_debug, debug_826
    rx643_cur."!cursor_debug"("FAIL", "")
  debug_826:
    .return (rx643_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block646"  :anon :subid("121_1303923618.727") :method :outer("118_1303923618.727")
.annotate 'line', 277
    .local string rx648_tgt
    .local int rx648_pos
    .local int rx648_off
    .local int rx648_eos
    .local int rx648_rep
    .local pmc rx648_cur
    .local pmc rx648_debug
    (rx648_cur, rx648_pos, rx648_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx648_cur
    .local pmc match
    .lex "$/", match
    length rx648_eos, rx648_tgt
    gt rx648_pos, rx648_eos, rx648_done
    set rx648_off, 0
    lt rx648_pos, 2, rx648_start
    sub rx648_off, rx648_pos, 1
    substr rx648_tgt, rx648_tgt, rx648_off
  rx648_start:
    eq $I10, 1, rx648_restart
    if_null rx648_debug, debug_827
    rx648_cur."!cursor_debug"("START", "")
  debug_827:
    $I10 = self.'from'()
    ne $I10, -1, rxscan649_done
    goto rxscan649_scan
  rxscan649_loop:
    (rx648_pos) = rx648_cur."from"()
    inc rx648_pos
    rx648_cur."!cursor_from"(rx648_pos)
    ge rx648_pos, rx648_eos, rxscan649_done
  rxscan649_scan:
    set_addr $I10, rxscan649_loop
    rx648_cur."!mark_push"(0, rx648_pos, $I10)
  rxscan649_done:
  # rx literal  "proto"
    add $I11, rx648_pos, 5
    gt $I11, rx648_eos, rx648_fail
    sub $I11, rx648_pos, rx648_off
    substr $S10, rx648_tgt, $I11, 5
    ne $S10, "proto", rx648_fail
    add rx648_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx648_cur."!cursor_pos"(rx648_pos)
    $P10 = rx648_cur."ws"()
    unless $P10, rx648_fail
    rx648_pos = $P10."pos"()
  alt650_0:
    set_addr $I10, alt650_1
    rx648_cur."!mark_push"(0, rx648_pos, $I10)
  # rx literal  "regex"
    add $I11, rx648_pos, 5
    gt $I11, rx648_eos, rx648_fail
    sub $I11, rx648_pos, rx648_off
    substr $S10, rx648_tgt, $I11, 5
    ne $S10, "regex", rx648_fail
    add rx648_pos, 5
    goto alt650_end
  alt650_1:
    set_addr $I10, alt650_2
    rx648_cur."!mark_push"(0, rx648_pos, $I10)
  # rx literal  "token"
    add $I11, rx648_pos, 5
    gt $I11, rx648_eos, rx648_fail
    sub $I11, rx648_pos, rx648_off
    substr $S10, rx648_tgt, $I11, 5
    ne $S10, "token", rx648_fail
    add rx648_pos, 5
    goto alt650_end
  alt650_2:
  # rx literal  "rule"
    add $I11, rx648_pos, 4
    gt $I11, rx648_eos, rx648_fail
    sub $I11, rx648_pos, rx648_off
    substr $S10, rx648_tgt, $I11, 4
    ne $S10, "rule", rx648_fail
    add rx648_pos, 4
  alt650_end:
  # rx pass
    rx648_cur."!cursor_pass"(rx648_pos, "")
    if_null rx648_debug, debug_828
    rx648_cur."!cursor_debug"("PASS", "", " at pos=", rx648_pos)
  debug_828:
    .return (rx648_cur)
  rx648_restart:
    if_null rx648_debug, debug_829
    rx648_cur."!cursor_debug"("NEXT", "")
  debug_829:
  rx648_fail:
    (rx648_rep, rx648_pos, $I10, $P10) = rx648_cur."!mark_fail"(0)
    lt rx648_pos, -1, rx648_done
    eq rx648_pos, -1, rx648_fail
    jump $I10
  rx648_done:
    rx648_cur."!cursor_fail"()
    if_null rx648_debug, debug_830
    rx648_cur."!cursor_debug"("FAIL", "")
  debug_830:
    .return (rx648_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx652_tgt
    .local int rx652_pos
    .local int rx652_off
    .local int rx652_eos
    .local int rx652_rep
    .local pmc rx652_cur
    .local pmc rx652_debug
    (rx652_cur, rx652_pos, rx652_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx652_cur
    .local pmc match
    .lex "$/", match
    length rx652_eos, rx652_tgt
    gt rx652_pos, rx652_eos, rx652_done
    set rx652_off, 0
    lt rx652_pos, 2, rx652_start
    sub rx652_off, rx652_pos, 1
    substr rx652_tgt, rx652_tgt, rx652_off
  rx652_start:
    eq $I10, 1, rx652_restart
    if_null rx652_debug, debug_834
    rx652_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_834:
    $I10 = self.'from'()
    ne $I10, -1, rxscan656_done
    goto rxscan656_scan
  rxscan656_loop:
    (rx652_pos) = rx652_cur."from"()
    inc rx652_pos
    rx652_cur."!cursor_from"(rx652_pos)
    ge rx652_pos, rx652_eos, rxscan656_done
  rxscan656_scan:
    set_addr $I10, rxscan656_loop
    rx652_cur."!mark_push"(0, rx652_pos, $I10)
  rxscan656_done:
.annotate 'line', 280
  # rx subrule "regex_declarator" subtype=capture negate=
    rx652_cur."!cursor_pos"(rx652_pos)
    $P10 = rx652_cur."regex_declarator"()
    unless $P10, rx652_fail
    rx652_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx652_pos = $P10."pos"()
  # rx pass
    rx652_cur."!cursor_pass"(rx652_pos, "term:sym<regex_declarator>")
    if_null rx652_debug, debug_835
    rx652_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx652_pos)
  debug_835:
    .return (rx652_cur)
  rx652_restart:
.annotate 'line', 10
    if_null rx652_debug, debug_836
    rx652_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_836:
  rx652_fail:
    (rx652_rep, rx652_pos, $I10, $P10) = rx652_cur."!mark_fail"(0)
    lt rx652_pos, -1, rx652_done
    eq rx652_pos, -1, rx652_fail
    jump $I10
  rx652_done:
    rx652_cur."!cursor_fail"()
    if_null rx652_debug, debug_837
    rx652_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_837:
    .return (rx652_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("123_1303923618.727") :method
.annotate 'line', 10
    $P654 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P655, "ResizablePMCArray"
    push $P655, $P654
    .return ($P655)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx658_tgt
    .local int rx658_pos
    .local int rx658_off
    .local int rx658_eos
    .local int rx658_rep
    .local pmc rx658_cur
    .local pmc rx658_debug
    (rx658_cur, rx658_pos, rx658_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx658_cur
    .local pmc match
    .lex "$/", match
    length rx658_eos, rx658_tgt
    gt rx658_pos, rx658_eos, rx658_done
    set rx658_off, 0
    lt rx658_pos, 2, rx658_start
    sub rx658_off, rx658_pos, 1
    substr rx658_tgt, rx658_tgt, rx658_off
  rx658_start:
    eq $I10, 1, rx658_restart
    if_null rx658_debug, debug_838
    rx658_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_838:
    $I10 = self.'from'()
    ne $I10, -1, rxscan662_done
    goto rxscan662_scan
  rxscan662_loop:
    (rx658_pos) = rx658_cur."from"()
    inc rx658_pos
    rx658_cur."!cursor_from"(rx658_pos)
    ge rx658_pos, rx658_eos, rxscan662_done
  rxscan662_scan:
    set_addr $I10, rxscan662_loop
    rx658_cur."!mark_push"(0, rx658_pos, $I10)
  rxscan662_done:
.annotate 'line', 281
  # rx subrule "statement_prefix" subtype=capture negate=
    rx658_cur."!cursor_pos"(rx658_pos)
    $P10 = rx658_cur."statement_prefix"()
    unless $P10, rx658_fail
    rx658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx658_pos = $P10."pos"()
  # rx pass
    rx658_cur."!cursor_pass"(rx658_pos, "term:sym<statement_prefix>")
    if_null rx658_debug, debug_839
    rx658_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx658_pos)
  debug_839:
    .return (rx658_cur)
  rx658_restart:
.annotate 'line', 10
    if_null rx658_debug, debug_840
    rx658_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_840:
  rx658_fail:
    (rx658_rep, rx658_pos, $I10, $P10) = rx658_cur."!mark_fail"(0)
    lt rx658_pos, -1, rx658_done
    eq rx658_pos, -1, rx658_fail
    jump $I10
  rx658_done:
    rx658_cur."!cursor_fail"()
    if_null rx658_debug, debug_841
    rx658_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_841:
    .return (rx658_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("125_1303923618.727") :method
.annotate 'line', 10
    $P660 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P661, "ResizablePMCArray"
    push $P661, $P660
    .return ($P661)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx664_tgt
    .local int rx664_pos
    .local int rx664_off
    .local int rx664_eos
    .local int rx664_rep
    .local pmc rx664_cur
    .local pmc rx664_debug
    (rx664_cur, rx664_pos, rx664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx664_cur
    .local pmc match
    .lex "$/", match
    length rx664_eos, rx664_tgt
    gt rx664_pos, rx664_eos, rx664_done
    set rx664_off, 0
    lt rx664_pos, 2, rx664_start
    sub rx664_off, rx664_pos, 1
    substr rx664_tgt, rx664_tgt, rx664_off
  rx664_start:
    eq $I10, 1, rx664_restart
    if_null rx664_debug, debug_842
    rx664_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_842:
    $I10 = self.'from'()
    ne $I10, -1, rxscan667_done
    goto rxscan667_scan
  rxscan667_loop:
    (rx664_pos) = rx664_cur."from"()
    inc rx664_pos
    rx664_cur."!cursor_from"(rx664_pos)
    ge rx664_pos, rx664_eos, rxscan667_done
  rxscan667_scan:
    set_addr $I10, rxscan667_loop
    rx664_cur."!mark_push"(0, rx664_pos, $I10)
  rxscan667_done:
.annotate 'line', 282
  # rx subrule "lambda" subtype=zerowidth negate=
    rx664_cur."!cursor_pos"(rx664_pos)
    $P10 = rx664_cur."lambda"()
    unless $P10, rx664_fail
  # rx subrule "pblock" subtype=capture negate=
    rx664_cur."!cursor_pos"(rx664_pos)
    $P10 = rx664_cur."pblock"()
    unless $P10, rx664_fail
    rx664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx664_pos = $P10."pos"()
  # rx pass
    rx664_cur."!cursor_pass"(rx664_pos, "term:sym<lambda>")
    if_null rx664_debug, debug_843
    rx664_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx664_pos)
  debug_843:
    .return (rx664_cur)
  rx664_restart:
.annotate 'line', 10
    if_null rx664_debug, debug_844
    rx664_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_844:
  rx664_fail:
    (rx664_rep, rx664_pos, $I10, $P10) = rx664_cur."!mark_fail"(0)
    lt rx664_pos, -1, rx664_done
    eq rx664_pos, -1, rx664_fail
    jump $I10
  rx664_done:
    rx664_cur."!cursor_fail"()
    if_null rx664_debug, debug_845
    rx664_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_845:
    .return (rx664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("127_1303923618.727") :method
.annotate 'line', 10
    new $P666, "ResizablePMCArray"
    push $P666, ""
    .return ($P666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx669_tgt
    .local int rx669_pos
    .local int rx669_off
    .local int rx669_eos
    .local int rx669_rep
    .local pmc rx669_cur
    .local pmc rx669_debug
    (rx669_cur, rx669_pos, rx669_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx669_cur
    .local pmc match
    .lex "$/", match
    length rx669_eos, rx669_tgt
    gt rx669_pos, rx669_eos, rx669_done
    set rx669_off, 0
    lt rx669_pos, 2, rx669_start
    sub rx669_off, rx669_pos, 1
    substr rx669_tgt, rx669_tgt, rx669_off
  rx669_start:
    eq $I10, 1, rx669_restart
    if_null rx669_debug, debug_846
    rx669_cur."!cursor_debug"("START", "fatarrow")
  debug_846:
    $I10 = self.'from'()
    ne $I10, -1, rxscan673_done
    goto rxscan673_scan
  rxscan673_loop:
    (rx669_pos) = rx669_cur."from"()
    inc rx669_pos
    rx669_cur."!cursor_from"(rx669_pos)
    ge rx669_pos, rx669_eos, rxscan673_done
  rxscan673_scan:
    set_addr $I10, rxscan673_loop
    rx669_cur."!mark_push"(0, rx669_pos, $I10)
  rxscan673_done:
.annotate 'line', 285
  # rx subrule "identifier" subtype=capture negate=
    rx669_cur."!cursor_pos"(rx669_pos)
    $P10 = rx669_cur."identifier"()
    unless $P10, rx669_fail
    rx669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx669_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx669_pos, rx669_off
    set rx669_rep, 0
    sub $I12, rx669_eos, rx669_pos
  rxenumcharlistq674_loop:
    le $I12, 0, rxenumcharlistq674_done
    substr $S10, rx669_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq674_done
    inc rx669_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq674_loop
  rxenumcharlistq674_done:
    add rx669_pos, rx669_pos, rx669_rep
  # rx literal  "=>"
    add $I11, rx669_pos, 2
    gt $I11, rx669_eos, rx669_fail
    sub $I11, rx669_pos, rx669_off
    substr $S10, rx669_tgt, $I11, 2
    ne $S10, "=>", rx669_fail
    add rx669_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx669_cur."!cursor_pos"(rx669_pos)
    $P10 = rx669_cur."ws"()
    unless $P10, rx669_fail
    rx669_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx669_cur."!cursor_pos"(rx669_pos)
    $P10 = rx669_cur."EXPR"("i=")
    unless $P10, rx669_fail
    rx669_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx669_pos = $P10."pos"()
.annotate 'line', 284
  # rx pass
    rx669_cur."!cursor_pass"(rx669_pos, "fatarrow")
    if_null rx669_debug, debug_847
    rx669_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx669_pos)
  debug_847:
    .return (rx669_cur)
  rx669_restart:
.annotate 'line', 10
    if_null rx669_debug, debug_848
    rx669_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_848:
  rx669_fail:
    (rx669_rep, rx669_pos, $I10, $P10) = rx669_cur."!mark_fail"(0)
    lt rx669_pos, -1, rx669_done
    eq rx669_pos, -1, rx669_fail
    jump $I10
  rx669_done:
    rx669_cur."!cursor_fail"()
    if_null rx669_debug, debug_849
    rx669_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_849:
    .return (rx669_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("129_1303923618.727") :method
.annotate 'line', 10
    $P671 = self."!PREFIX__!subrule"("identifier", "")
    new $P672, "ResizablePMCArray"
    push $P672, $P671
    .return ($P672)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx676_tgt
    .local int rx676_pos
    .local int rx676_off
    .local int rx676_eos
    .local int rx676_rep
    .local pmc rx676_cur
    .local pmc rx676_debug
    (rx676_cur, rx676_pos, rx676_tgt, $I10) = self."!cursor_start"()
    rx676_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx676_cur
    .local pmc match
    .lex "$/", match
    length rx676_eos, rx676_tgt
    gt rx676_pos, rx676_eos, rx676_done
    set rx676_off, 0
    lt rx676_pos, 2, rx676_start
    sub rx676_off, rx676_pos, 1
    substr rx676_tgt, rx676_tgt, rx676_off
  rx676_start:
    eq $I10, 1, rx676_restart
    if_null rx676_debug, debug_850
    rx676_cur."!cursor_debug"("START", "colonpair")
  debug_850:
    $I10 = self.'from'()
    ne $I10, -1, rxscan682_done
    goto rxscan682_scan
  rxscan682_loop:
    (rx676_pos) = rx676_cur."from"()
    inc rx676_pos
    rx676_cur."!cursor_from"(rx676_pos)
    ge rx676_pos, rx676_eos, rxscan682_done
  rxscan682_scan:
    set_addr $I10, rxscan682_loop
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
  rxscan682_done:
.annotate 'line', 289
  # rx literal  ":"
    add $I11, rx676_pos, 1
    gt $I11, rx676_eos, rx676_fail
    sub $I11, rx676_pos, rx676_off
    ord $I11, rx676_tgt, $I11
    ne $I11, 58, rx676_fail
    add rx676_pos, 1
  alt683_0:
.annotate 'line', 290
    set_addr $I10, alt683_1
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
.annotate 'line', 291
  # rx subcapture "not"
    set_addr $I10, rxcap_684_fail
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
  # rx literal  "!"
    add $I11, rx676_pos, 1
    gt $I11, rx676_eos, rx676_fail
    sub $I11, rx676_pos, rx676_off
    ord $I11, rx676_tgt, $I11
    ne $I11, 33, rx676_fail
    add rx676_pos, 1
    set_addr $I10, rxcap_684_fail
    ($I12, $I11) = rx676_cur."!mark_peek"($I10)
    rx676_cur."!cursor_pos"($I11)
    ($P10) = rx676_cur."!cursor_start"()
    $P10."!cursor_pass"(rx676_pos, "")
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_684_done
  rxcap_684_fail:
    goto rx676_fail
  rxcap_684_done:
  # rx subrule "identifier" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."identifier"()
    unless $P10, rx676_fail
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx676_pos = $P10."pos"()
    goto alt683_end
  alt683_1:
    set_addr $I10, alt683_2
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
.annotate 'line', 292
  # rx subrule "identifier" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."identifier"()
    unless $P10, rx676_fail
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx676_pos = $P10."pos"()
  # rx rxquantr685 ** 0..1
    set_addr $I10, rxquantr685_done
    rx676_cur."!mark_push"(0, rx676_pos, $I10)
  rxquantr685_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."circumfix"()
    unless $P10, rx676_fail
    goto rxsubrule686_pass
  rxsubrule686_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx676_fail
  rxsubrule686_pass:
    set_addr $I10, rxsubrule686_back
    rx676_cur."!mark_push"(0, rx676_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx676_pos = $P10."pos"()
    set_addr $I10, rxquantr685_done
    (rx676_rep) = rx676_cur."!mark_commit"($I10)
  rxquantr685_done:
    goto alt683_end
  alt683_2:
.annotate 'line', 293
  # rx subrule "circumfix" subtype=capture negate=
    rx676_cur."!cursor_pos"(rx676_pos)
    $P10 = rx676_cur."circumfix"()
    unless $P10, rx676_fail
    rx676_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx676_pos = $P10."pos"()
  alt683_end:
.annotate 'line', 288
  # rx pass
    rx676_cur."!cursor_pass"(rx676_pos, "colonpair")
    if_null rx676_debug, debug_851
    rx676_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx676_pos)
  debug_851:
    .return (rx676_cur)
  rx676_restart:
.annotate 'line', 10
    if_null rx676_debug, debug_852
    rx676_cur."!cursor_debug"("NEXT", "colonpair")
  debug_852:
  rx676_fail:
    (rx676_rep, rx676_pos, $I10, $P10) = rx676_cur."!mark_fail"(0)
    lt rx676_pos, -1, rx676_done
    eq rx676_pos, -1, rx676_fail
    jump $I10
  rx676_done:
    rx676_cur."!cursor_fail"()
    if_null rx676_debug, debug_853
    rx676_cur."!cursor_debug"("FAIL", "colonpair")
  debug_853:
    .return (rx676_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("131_1303923618.727") :method
.annotate 'line', 10
    $P678 = self."!PREFIX__!subrule"("circumfix", ":")
    $P679 = self."!PREFIX__!subrule"("identifier", ":")
    $P680 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P681, "ResizablePMCArray"
    push $P681, $P678
    push $P681, $P679
    push $P681, $P680
    .return ($P681)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx688_tgt
    .local int rx688_pos
    .local int rx688_off
    .local int rx688_eos
    .local int rx688_rep
    .local pmc rx688_cur
    .local pmc rx688_debug
    (rx688_cur, rx688_pos, rx688_tgt, $I10) = self."!cursor_start"()
    rx688_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx688_cur
    .local pmc match
    .lex "$/", match
    length rx688_eos, rx688_tgt
    gt rx688_pos, rx688_eos, rx688_done
    set rx688_off, 0
    lt rx688_pos, 2, rx688_start
    sub rx688_off, rx688_pos, 1
    substr rx688_tgt, rx688_tgt, rx688_off
  rx688_start:
    eq $I10, 1, rx688_restart
    if_null rx688_debug, debug_854
    rx688_cur."!cursor_debug"("START", "variable")
  debug_854:
    $I10 = self.'from'()
    ne $I10, -1, rxscan693_done
    goto rxscan693_scan
  rxscan693_loop:
    (rx688_pos) = rx688_cur."from"()
    inc rx688_pos
    rx688_cur."!cursor_from"(rx688_pos)
    ge rx688_pos, rx688_eos, rxscan693_done
  rxscan693_scan:
    set_addr $I10, rxscan693_loop
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  rxscan693_done:
  alt694_0:
.annotate 'line', 297
    set_addr $I10, alt694_1
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
.annotate 'line', 298
  # rx subrule "sigil" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."sigil"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx688_pos = $P10."pos"()
  # rx rxquantr695 ** 0..1
    set_addr $I10, rxquantr695_done
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  rxquantr695_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."twigil"()
    unless $P10, rx688_fail
    goto rxsubrule696_pass
  rxsubrule696_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx688_fail
  rxsubrule696_pass:
    set_addr $I10, rxsubrule696_back
    rx688_cur."!mark_push"(0, rx688_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx688_pos = $P10."pos"()
    set_addr $I10, rxquantr695_done
    (rx688_rep) = rx688_cur."!mark_commit"($I10)
  rxquantr695_done:
  # rx subrule "name" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."name"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx688_pos = $P10."pos"()
    goto alt694_end
  alt694_1:
    set_addr $I10, alt694_2
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
.annotate 'line', 299
  # rx subrule "sigil" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."sigil"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx688_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx688_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx688_cur."!cursor_pos"(rx688_pos)
    $P10 = rx688_cur."postcircumfix"()
    unless $P10, rx688_fail
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx688_pos = $P10."pos"()
    goto alt694_end
  alt694_2:
.annotate 'line', 300
  # rx subcapture "sigil"
    set_addr $I10, rxcap_697_fail
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  # rx literal  "$"
    add $I11, rx688_pos, 1
    gt $I11, rx688_eos, rx688_fail
    sub $I11, rx688_pos, rx688_off
    ord $I11, rx688_tgt, $I11
    ne $I11, 36, rx688_fail
    add rx688_pos, 1
    set_addr $I10, rxcap_697_fail
    ($I12, $I11) = rx688_cur."!mark_peek"($I10)
    rx688_cur."!cursor_pos"($I11)
    ($P10) = rx688_cur."!cursor_start"()
    $P10."!cursor_pass"(rx688_pos, "")
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_697_done
  rxcap_697_fail:
    goto rx688_fail
  rxcap_697_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_698_fail
    rx688_cur."!mark_push"(0, rx688_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx688_pos, rx688_eos, rx688_fail
    sub $I10, rx688_pos, rx688_off
    substr $S10, rx688_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx688_fail
    inc rx688_pos
    set_addr $I10, rxcap_698_fail
    ($I12, $I11) = rx688_cur."!mark_peek"($I10)
    rx688_cur."!cursor_pos"($I11)
    ($P10) = rx688_cur."!cursor_start"()
    $P10."!cursor_pass"(rx688_pos, "")
    rx688_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_698_done
  rxcap_698_fail:
    goto rx688_fail
  rxcap_698_done:
  alt694_end:
.annotate 'line', 297
  # rx pass
    rx688_cur."!cursor_pass"(rx688_pos, "variable")
    if_null rx688_debug, debug_855
    rx688_cur."!cursor_debug"("PASS", "variable", " at pos=", rx688_pos)
  debug_855:
    .return (rx688_cur)
  rx688_restart:
.annotate 'line', 10
    if_null rx688_debug, debug_856
    rx688_cur."!cursor_debug"("NEXT", "variable")
  debug_856:
  rx688_fail:
    (rx688_rep, rx688_pos, $I10, $P10) = rx688_cur."!mark_fail"(0)
    lt rx688_pos, -1, rx688_done
    eq rx688_pos, -1, rx688_fail
    jump $I10
  rx688_done:
    rx688_cur."!cursor_fail"()
    if_null rx688_debug, debug_857
    rx688_cur."!cursor_debug"("FAIL", "variable")
  debug_857:
    .return (rx688_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("133_1303923618.727") :method
.annotate 'line', 10
    $P690 = self."!PREFIX__!subrule"("sigil", "")
    $P691 = self."!PREFIX__!subrule"("sigil", "")
    new $P692, "ResizablePMCArray"
    push $P692, "$!"
    push $P692, "$_"
    push $P692, "$/"
    push $P692, $P690
    push $P692, $P691
    .return ($P692)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx700_tgt
    .local int rx700_pos
    .local int rx700_off
    .local int rx700_eos
    .local int rx700_rep
    .local pmc rx700_cur
    .local pmc rx700_debug
    (rx700_cur, rx700_pos, rx700_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx700_cur
    .local pmc match
    .lex "$/", match
    length rx700_eos, rx700_tgt
    gt rx700_pos, rx700_eos, rx700_done
    set rx700_off, 0
    lt rx700_pos, 2, rx700_start
    sub rx700_off, rx700_pos, 1
    substr rx700_tgt, rx700_tgt, rx700_off
  rx700_start:
    eq $I10, 1, rx700_restart
    if_null rx700_debug, debug_858
    rx700_cur."!cursor_debug"("START", "sigil")
  debug_858:
    $I10 = self.'from'()
    ne $I10, -1, rxscan703_done
    goto rxscan703_scan
  rxscan703_loop:
    (rx700_pos) = rx700_cur."from"()
    inc rx700_pos
    rx700_cur."!cursor_from"(rx700_pos)
    ge rx700_pos, rx700_eos, rxscan703_done
  rxscan703_scan:
    set_addr $I10, rxscan703_loop
    rx700_cur."!mark_push"(0, rx700_pos, $I10)
  rxscan703_done:
.annotate 'line', 303
  # rx enumcharlist negate=0 
    ge rx700_pos, rx700_eos, rx700_fail
    sub $I10, rx700_pos, rx700_off
    substr $S10, rx700_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx700_fail
    inc rx700_pos
  # rx pass
    rx700_cur."!cursor_pass"(rx700_pos, "sigil")
    if_null rx700_debug, debug_859
    rx700_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx700_pos)
  debug_859:
    .return (rx700_cur)
  rx700_restart:
.annotate 'line', 10
    if_null rx700_debug, debug_860
    rx700_cur."!cursor_debug"("NEXT", "sigil")
  debug_860:
  rx700_fail:
    (rx700_rep, rx700_pos, $I10, $P10) = rx700_cur."!mark_fail"(0)
    lt rx700_pos, -1, rx700_done
    eq rx700_pos, -1, rx700_fail
    jump $I10
  rx700_done:
    rx700_cur."!cursor_fail"()
    if_null rx700_debug, debug_861
    rx700_cur."!cursor_debug"("FAIL", "sigil")
  debug_861:
    .return (rx700_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("135_1303923618.727") :method
.annotate 'line', 10
    new $P702, "ResizablePMCArray"
    push $P702, "&"
    push $P702, "%"
    push $P702, "@"
    push $P702, "$"
    .return ($P702)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx705_tgt
    .local int rx705_pos
    .local int rx705_off
    .local int rx705_eos
    .local int rx705_rep
    .local pmc rx705_cur
    .local pmc rx705_debug
    (rx705_cur, rx705_pos, rx705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx705_cur
    .local pmc match
    .lex "$/", match
    length rx705_eos, rx705_tgt
    gt rx705_pos, rx705_eos, rx705_done
    set rx705_off, 0
    lt rx705_pos, 2, rx705_start
    sub rx705_off, rx705_pos, 1
    substr rx705_tgt, rx705_tgt, rx705_off
  rx705_start:
    eq $I10, 1, rx705_restart
    if_null rx705_debug, debug_862
    rx705_cur."!cursor_debug"("START", "twigil")
  debug_862:
    $I10 = self.'from'()
    ne $I10, -1, rxscan708_done
    goto rxscan708_scan
  rxscan708_loop:
    (rx705_pos) = rx705_cur."from"()
    inc rx705_pos
    rx705_cur."!cursor_from"(rx705_pos)
    ge rx705_pos, rx705_eos, rxscan708_done
  rxscan708_scan:
    set_addr $I10, rxscan708_loop
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  rxscan708_done:
.annotate 'line', 305
  # rx enumcharlist negate=0 
    ge rx705_pos, rx705_eos, rx705_fail
    sub $I10, rx705_pos, rx705_off
    substr $S10, rx705_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx705_fail
    inc rx705_pos
  # rx pass
    rx705_cur."!cursor_pass"(rx705_pos, "twigil")
    if_null rx705_debug, debug_863
    rx705_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx705_pos)
  debug_863:
    .return (rx705_cur)
  rx705_restart:
.annotate 'line', 10
    if_null rx705_debug, debug_864
    rx705_cur."!cursor_debug"("NEXT", "twigil")
  debug_864:
  rx705_fail:
    (rx705_rep, rx705_pos, $I10, $P10) = rx705_cur."!mark_fail"(0)
    lt rx705_pos, -1, rx705_done
    eq rx705_pos, -1, rx705_fail
    jump $I10
  rx705_done:
    rx705_cur."!cursor_fail"()
    if_null rx705_debug, debug_865
    rx705_cur."!cursor_debug"("FAIL", "twigil")
  debug_865:
    .return (rx705_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("137_1303923618.727") :method
.annotate 'line', 10
    new $P707, "ResizablePMCArray"
    push $P707, "?"
    push $P707, "!"
    push $P707, "*"
    .return ($P707)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1303923618.727")
    .param pmc param_710
.annotate 'line', 307
    .lex "self", param_710
    $P711 = param_710."!protoregex"("package_declarator")
    .return ($P711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1303923618.727")
    .param pmc param_713
.annotate 'line', 307
    .lex "self", param_713
    $P714 = param_713."!PREFIX__!protoregex"("package_declarator")
    .return ($P714)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 309
    new $P716, "Undef"
    .lex "$*OUTERPACKAGE", $P716
.annotate 'line', 310
    new $P717, "Undef"
    .lex "$*PACKAGE-SETUP", $P717
.annotate 'line', 311
    new $P718, "Undef"
    .lex "$*PKGDECL", $P718
.annotate 'line', 10
    .local string rx719_tgt
    .local int rx719_pos
    .local int rx719_off
    .local int rx719_eos
    .local int rx719_rep
    .local pmc rx719_cur
    .local pmc rx719_debug
    (rx719_cur, rx719_pos, rx719_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx719_cur
    .local pmc match
    .lex "$/", match
    length rx719_eos, rx719_tgt
    gt rx719_pos, rx719_eos, rx719_done
    set rx719_off, 0
    lt rx719_pos, 2, rx719_start
    sub rx719_off, rx719_pos, 1
    substr rx719_tgt, rx719_tgt, rx719_off
  rx719_start:
    eq $I10, 1, rx719_restart
    if_null rx719_debug, debug_866
    rx719_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_866:
    $I10 = self.'from'()
    ne $I10, -1, rxscan723_done
    goto rxscan723_scan
  rxscan723_loop:
    (rx719_pos) = rx719_cur."from"()
    inc rx719_pos
    rx719_cur."!cursor_from"(rx719_pos)
    ge rx719_pos, rx719_eos, rxscan723_done
  rxscan723_scan:
    set_addr $I10, rxscan723_loop
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxscan723_done:
.annotate 'line', 309
    rx719_cur."!cursor_pos"(rx719_pos)
    find_dynamic_lex $P726, "$*PACKAGE"
    unless_null $P726, vivify_867
    get_hll_global $P724, "GLOBAL"
    get_who $P725, $P724
    set $P726, $P725["$PACKAGE"]
    unless_null $P726, vivify_868
    die "Contextual $*PACKAGE not found"
  vivify_868:
  vivify_867:
    store_lex "$*OUTERPACKAGE", $P726
.annotate 'line', 310
    rx719_cur."!cursor_pos"(rx719_pos)
    get_hll_global $P727, "GLOBAL"
    nqp_get_package_through_who $P728, $P727, "PAST"
    get_who $P729, $P728
    set $P730, $P729["Stmts"]
    $P731 = $P730."new"()
    store_lex "$*PACKAGE-SETUP", $P731
.annotate 'line', 311
    rx719_cur."!cursor_pos"(rx719_pos)
    new $P732, "String"
    assign $P732, "module"
    store_lex "$*PKGDECL", $P732
.annotate 'line', 312
  # rx subcapture "sym"
    set_addr $I10, rxcap_733_fail
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  # rx literal  "module"
    add $I11, rx719_pos, 6
    gt $I11, rx719_eos, rx719_fail
    sub $I11, rx719_pos, rx719_off
    substr $S10, rx719_tgt, $I11, 6
    ne $S10, "module", rx719_fail
    add rx719_pos, 6
    set_addr $I10, rxcap_733_fail
    ($I12, $I11) = rx719_cur."!mark_peek"($I10)
    rx719_cur."!cursor_pos"($I11)
    ($P10) = rx719_cur."!cursor_start"()
    $P10."!cursor_pass"(rx719_pos, "")
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_733_done
  rxcap_733_fail:
    goto rx719_fail
  rxcap_733_done:
  # rx subrule "package_def" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."package_def"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx719_pos = $P10."pos"()
.annotate 'line', 308
  # rx pass
    rx719_cur."!cursor_pass"(rx719_pos, "package_declarator:sym<module>")
    if_null rx719_debug, debug_869
    rx719_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx719_pos)
  debug_869:
    .return (rx719_cur)
  rx719_restart:
.annotate 'line', 10
    if_null rx719_debug, debug_870
    rx719_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_870:
  rx719_fail:
    (rx719_rep, rx719_pos, $I10, $P10) = rx719_cur."!mark_fail"(0)
    lt rx719_pos, -1, rx719_done
    eq rx719_pos, -1, rx719_fail
    jump $I10
  rx719_done:
    rx719_cur."!cursor_fail"()
    if_null rx719_debug, debug_871
    rx719_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_871:
    .return (rx719_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("141_1303923618.727") :method
.annotate 'line', 10
    $P721 = self."!PREFIX__!subrule"("package_def", "module")
    new $P722, "ResizablePMCArray"
    push $P722, $P721
    .return ($P722)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 315
    new $P735, "Undef"
    .lex "$*OUTERPACKAGE", $P735
.annotate 'line', 316
    new $P736, "Undef"
    .lex "$*PACKAGE-SETUP", $P736
.annotate 'line', 317
    new $P737, "Undef"
    .lex "$*PKGDECL", $P737
.annotate 'line', 10
    .local string rx738_tgt
    .local int rx738_pos
    .local int rx738_off
    .local int rx738_eos
    .local int rx738_rep
    .local pmc rx738_cur
    .local pmc rx738_debug
    (rx738_cur, rx738_pos, rx738_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx738_cur
    .local pmc match
    .lex "$/", match
    length rx738_eos, rx738_tgt
    gt rx738_pos, rx738_eos, rx738_done
    set rx738_off, 0
    lt rx738_pos, 2, rx738_start
    sub rx738_off, rx738_pos, 1
    substr rx738_tgt, rx738_tgt, rx738_off
  rx738_start:
    eq $I10, 1, rx738_restart
    if_null rx738_debug, debug_872
    rx738_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan742_done
    goto rxscan742_scan
  rxscan742_loop:
    (rx738_pos) = rx738_cur."from"()
    inc rx738_pos
    rx738_cur."!cursor_from"(rx738_pos)
    ge rx738_pos, rx738_eos, rxscan742_done
  rxscan742_scan:
    set_addr $I10, rxscan742_loop
    rx738_cur."!mark_push"(0, rx738_pos, $I10)
  rxscan742_done:
.annotate 'line', 315
    rx738_cur."!cursor_pos"(rx738_pos)
    find_dynamic_lex $P745, "$*PACKAGE"
    unless_null $P745, vivify_873
    get_hll_global $P743, "GLOBAL"
    get_who $P744, $P743
    set $P745, $P744["$PACKAGE"]
    unless_null $P745, vivify_874
    die "Contextual $*PACKAGE not found"
  vivify_874:
  vivify_873:
    store_lex "$*OUTERPACKAGE", $P745
.annotate 'line', 316
    rx738_cur."!cursor_pos"(rx738_pos)
    get_hll_global $P746, "GLOBAL"
    nqp_get_package_through_who $P747, $P746, "PAST"
    get_who $P748, $P747
    set $P749, $P748["Stmts"]
    $P750 = $P749."new"()
    store_lex "$*PACKAGE-SETUP", $P750
.annotate 'line', 317
    rx738_cur."!cursor_pos"(rx738_pos)
    new $P751, "String"
    assign $P751, "knowhow"
    store_lex "$*PKGDECL", $P751
.annotate 'line', 318
  # rx subcapture "sym"
    set_addr $I10, rxcap_752_fail
    rx738_cur."!mark_push"(0, rx738_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx738_pos, 7
    gt $I11, rx738_eos, rx738_fail
    sub $I11, rx738_pos, rx738_off
    substr $S10, rx738_tgt, $I11, 7
    ne $S10, "knowhow", rx738_fail
    add rx738_pos, 7
    set_addr $I10, rxcap_752_fail
    ($I12, $I11) = rx738_cur."!mark_peek"($I10)
    rx738_cur."!cursor_pos"($I11)
    ($P10) = rx738_cur."!cursor_start"()
    $P10."!cursor_pass"(rx738_pos, "")
    rx738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_752_done
  rxcap_752_fail:
    goto rx738_fail
  rxcap_752_done:
  # rx subrule "package_def" subtype=capture negate=
    rx738_cur."!cursor_pos"(rx738_pos)
    $P10 = rx738_cur."package_def"()
    unless $P10, rx738_fail
    rx738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx738_pos = $P10."pos"()
.annotate 'line', 314
  # rx pass
    rx738_cur."!cursor_pass"(rx738_pos, "package_declarator:sym<knowhow>")
    if_null rx738_debug, debug_875
    rx738_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx738_pos)
  debug_875:
    .return (rx738_cur)
  rx738_restart:
.annotate 'line', 10
    if_null rx738_debug, debug_876
    rx738_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_876:
  rx738_fail:
    (rx738_rep, rx738_pos, $I10, $P10) = rx738_cur."!mark_fail"(0)
    lt rx738_pos, -1, rx738_done
    eq rx738_pos, -1, rx738_fail
    jump $I10
  rx738_done:
    rx738_cur."!cursor_fail"()
    if_null rx738_debug, debug_877
    rx738_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_877:
    .return (rx738_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("143_1303923618.727") :method
.annotate 'line', 10
    $P740 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P741, "ResizablePMCArray"
    push $P741, $P740
    .return ($P741)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 321
    new $P754, "Undef"
    .lex "$*OUTERPACKAGE", $P754
.annotate 'line', 322
    new $P755, "Undef"
    .lex "$*PACKAGE-SETUP", $P755
.annotate 'line', 323
    new $P756, "Undef"
    .lex "$*PKGDECL", $P756
.annotate 'line', 10
    .local string rx757_tgt
    .local int rx757_pos
    .local int rx757_off
    .local int rx757_eos
    .local int rx757_rep
    .local pmc rx757_cur
    .local pmc rx757_debug
    (rx757_cur, rx757_pos, rx757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx757_cur
    .local pmc match
    .lex "$/", match
    length rx757_eos, rx757_tgt
    gt rx757_pos, rx757_eos, rx757_done
    set rx757_off, 0
    lt rx757_pos, 2, rx757_start
    sub rx757_off, rx757_pos, 1
    substr rx757_tgt, rx757_tgt, rx757_off
  rx757_start:
    eq $I10, 1, rx757_restart
    if_null rx757_debug, debug_878
    rx757_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_878:
    $I10 = self.'from'()
    ne $I10, -1, rxscan761_done
    goto rxscan761_scan
  rxscan761_loop:
    (rx757_pos) = rx757_cur."from"()
    inc rx757_pos
    rx757_cur."!cursor_from"(rx757_pos)
    ge rx757_pos, rx757_eos, rxscan761_done
  rxscan761_scan:
    set_addr $I10, rxscan761_loop
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxscan761_done:
.annotate 'line', 321
    rx757_cur."!cursor_pos"(rx757_pos)
    find_dynamic_lex $P764, "$*PACKAGE"
    unless_null $P764, vivify_879
    get_hll_global $P762, "GLOBAL"
    get_who $P763, $P762
    set $P764, $P763["$PACKAGE"]
    unless_null $P764, vivify_880
    die "Contextual $*PACKAGE not found"
  vivify_880:
  vivify_879:
    store_lex "$*OUTERPACKAGE", $P764
.annotate 'line', 322
    rx757_cur."!cursor_pos"(rx757_pos)
    get_hll_global $P765, "GLOBAL"
    nqp_get_package_through_who $P766, $P765, "PAST"
    get_who $P767, $P766
    set $P768, $P767["Stmts"]
    $P769 = $P768."new"()
    store_lex "$*PACKAGE-SETUP", $P769
.annotate 'line', 323
    rx757_cur."!cursor_pos"(rx757_pos)
    new $P770, "String"
    assign $P770, "class"
    store_lex "$*PKGDECL", $P770
.annotate 'line', 324
  # rx subcapture "sym"
    set_addr $I10, rxcap_771_fail
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  # rx literal  "class"
    add $I11, rx757_pos, 5
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    substr $S10, rx757_tgt, $I11, 5
    ne $S10, "class", rx757_fail
    add rx757_pos, 5
    set_addr $I10, rxcap_771_fail
    ($I12, $I11) = rx757_cur."!mark_peek"($I10)
    rx757_cur."!cursor_pos"($I11)
    ($P10) = rx757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx757_pos, "")
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_771_done
  rxcap_771_fail:
    goto rx757_fail
  rxcap_771_done:
  # rx subrule "package_def" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."package_def"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx757_pos = $P10."pos"()
.annotate 'line', 320
  # rx pass
    rx757_cur."!cursor_pass"(rx757_pos, "package_declarator:sym<class>")
    if_null rx757_debug, debug_881
    rx757_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx757_pos)
  debug_881:
    .return (rx757_cur)
  rx757_restart:
.annotate 'line', 10
    if_null rx757_debug, debug_882
    rx757_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_882:
  rx757_fail:
    (rx757_rep, rx757_pos, $I10, $P10) = rx757_cur."!mark_fail"(0)
    lt rx757_pos, -1, rx757_done
    eq rx757_pos, -1, rx757_fail
    jump $I10
  rx757_done:
    rx757_cur."!cursor_fail"()
    if_null rx757_debug, debug_883
    rx757_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_883:
    .return (rx757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("145_1303923618.727") :method
.annotate 'line', 10
    $P759 = self."!PREFIX__!subrule"("package_def", "class")
    new $P760, "ResizablePMCArray"
    push $P760, $P759
    .return ($P760)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 327
    new $P773, "Undef"
    .lex "$*OUTERPACKAGE", $P773
.annotate 'line', 328
    new $P774, "Undef"
    .lex "$*PACKAGE-SETUP", $P774
.annotate 'line', 329
    new $P775, "Undef"
    .lex "$*PKGDECL", $P775
.annotate 'line', 10
    .local string rx776_tgt
    .local int rx776_pos
    .local int rx776_off
    .local int rx776_eos
    .local int rx776_rep
    .local pmc rx776_cur
    .local pmc rx776_debug
    (rx776_cur, rx776_pos, rx776_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx776_cur
    .local pmc match
    .lex "$/", match
    length rx776_eos, rx776_tgt
    gt rx776_pos, rx776_eos, rx776_done
    set rx776_off, 0
    lt rx776_pos, 2, rx776_start
    sub rx776_off, rx776_pos, 1
    substr rx776_tgt, rx776_tgt, rx776_off
  rx776_start:
    eq $I10, 1, rx776_restart
    if_null rx776_debug, debug_884
    rx776_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan780_done
    goto rxscan780_scan
  rxscan780_loop:
    (rx776_pos) = rx776_cur."from"()
    inc rx776_pos
    rx776_cur."!cursor_from"(rx776_pos)
    ge rx776_pos, rx776_eos, rxscan780_done
  rxscan780_scan:
    set_addr $I10, rxscan780_loop
    rx776_cur."!mark_push"(0, rx776_pos, $I10)
  rxscan780_done:
.annotate 'line', 327
    rx776_cur."!cursor_pos"(rx776_pos)
    find_dynamic_lex $P783, "$*PACKAGE"
    unless_null $P783, vivify_885
    get_hll_global $P781, "GLOBAL"
    get_who $P782, $P781
    set $P783, $P782["$PACKAGE"]
    unless_null $P783, vivify_886
    die "Contextual $*PACKAGE not found"
  vivify_886:
  vivify_885:
    store_lex "$*OUTERPACKAGE", $P783
.annotate 'line', 328
    rx776_cur."!cursor_pos"(rx776_pos)
    get_hll_global $P784, "GLOBAL"
    nqp_get_package_through_who $P785, $P784, "PAST"
    get_who $P786, $P785
    set $P787, $P786["Stmts"]
    $P788 = $P787."new"()
    store_lex "$*PACKAGE-SETUP", $P788
.annotate 'line', 329
    rx776_cur."!cursor_pos"(rx776_pos)
    new $P789, "String"
    assign $P789, "grammar"
    store_lex "$*PKGDECL", $P789
.annotate 'line', 330
  # rx subcapture "sym"
    set_addr $I10, rxcap_790_fail
    rx776_cur."!mark_push"(0, rx776_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx776_pos, 7
    gt $I11, rx776_eos, rx776_fail
    sub $I11, rx776_pos, rx776_off
    substr $S10, rx776_tgt, $I11, 7
    ne $S10, "grammar", rx776_fail
    add rx776_pos, 7
    set_addr $I10, rxcap_790_fail
    ($I12, $I11) = rx776_cur."!mark_peek"($I10)
    rx776_cur."!cursor_pos"($I11)
    ($P10) = rx776_cur."!cursor_start"()
    $P10."!cursor_pass"(rx776_pos, "")
    rx776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_790_done
  rxcap_790_fail:
    goto rx776_fail
  rxcap_790_done:
  # rx subrule "package_def" subtype=capture negate=
    rx776_cur."!cursor_pos"(rx776_pos)
    $P10 = rx776_cur."package_def"()
    unless $P10, rx776_fail
    rx776_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx776_pos = $P10."pos"()
.annotate 'line', 326
  # rx pass
    rx776_cur."!cursor_pass"(rx776_pos, "package_declarator:sym<grammar>")
    if_null rx776_debug, debug_887
    rx776_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx776_pos)
  debug_887:
    .return (rx776_cur)
  rx776_restart:
.annotate 'line', 10
    if_null rx776_debug, debug_888
    rx776_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_888:
  rx776_fail:
    (rx776_rep, rx776_pos, $I10, $P10) = rx776_cur."!mark_fail"(0)
    lt rx776_pos, -1, rx776_done
    eq rx776_pos, -1, rx776_fail
    jump $I10
  rx776_done:
    rx776_cur."!cursor_fail"()
    if_null rx776_debug, debug_889
    rx776_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_889:
    .return (rx776_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("147_1303923618.727") :method
.annotate 'line', 10
    $P778 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P779, "ResizablePMCArray"
    push $P779, $P778
    .return ($P779)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 333
    new $P792, "Undef"
    .lex "$*OUTERPACKAGE", $P792
.annotate 'line', 334
    new $P793, "Undef"
    .lex "$*PACKAGE-SETUP", $P793
.annotate 'line', 335
    new $P794, "Undef"
    .lex "$*PKGDECL", $P794
.annotate 'line', 10
    .local string rx795_tgt
    .local int rx795_pos
    .local int rx795_off
    .local int rx795_eos
    .local int rx795_rep
    .local pmc rx795_cur
    .local pmc rx795_debug
    (rx795_cur, rx795_pos, rx795_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx795_cur
    .local pmc match
    .lex "$/", match
    length rx795_eos, rx795_tgt
    gt rx795_pos, rx795_eos, rx795_done
    set rx795_off, 0
    lt rx795_pos, 2, rx795_start
    sub rx795_off, rx795_pos, 1
    substr rx795_tgt, rx795_tgt, rx795_off
  rx795_start:
    eq $I10, 1, rx795_restart
    if_null rx795_debug, debug_890
    rx795_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_890:
    $I10 = self.'from'()
    ne $I10, -1, rxscan799_done
    goto rxscan799_scan
  rxscan799_loop:
    (rx795_pos) = rx795_cur."from"()
    inc rx795_pos
    rx795_cur."!cursor_from"(rx795_pos)
    ge rx795_pos, rx795_eos, rxscan799_done
  rxscan799_scan:
    set_addr $I10, rxscan799_loop
    rx795_cur."!mark_push"(0, rx795_pos, $I10)
  rxscan799_done:
.annotate 'line', 333
    rx795_cur."!cursor_pos"(rx795_pos)
    find_dynamic_lex $P802, "$*PACKAGE"
    unless_null $P802, vivify_891
    get_hll_global $P800, "GLOBAL"
    get_who $P801, $P800
    set $P802, $P801["$PACKAGE"]
    unless_null $P802, vivify_892
    die "Contextual $*PACKAGE not found"
  vivify_892:
  vivify_891:
    store_lex "$*OUTERPACKAGE", $P802
.annotate 'line', 334
    rx795_cur."!cursor_pos"(rx795_pos)
    get_hll_global $P803, "GLOBAL"
    nqp_get_package_through_who $P804, $P803, "PAST"
    get_who $P805, $P804
    set $P806, $P805["Stmts"]
    $P807 = $P806."new"()
    store_lex "$*PACKAGE-SETUP", $P807
.annotate 'line', 335
    rx795_cur."!cursor_pos"(rx795_pos)
    new $P808, "String"
    assign $P808, "role"
    store_lex "$*PKGDECL", $P808
.annotate 'line', 336
  # rx subcapture "sym"
    set_addr $I10, rxcap_809_fail
    rx795_cur."!mark_push"(0, rx795_pos, $I10)
  # rx literal  "role"
    add $I11, rx795_pos, 4
    gt $I11, rx795_eos, rx795_fail
    sub $I11, rx795_pos, rx795_off
    substr $S10, rx795_tgt, $I11, 4
    ne $S10, "role", rx795_fail
    add rx795_pos, 4
    set_addr $I10, rxcap_809_fail
    ($I12, $I11) = rx795_cur."!mark_peek"($I10)
    rx795_cur."!cursor_pos"($I11)
    ($P10) = rx795_cur."!cursor_start"()
    $P10."!cursor_pass"(rx795_pos, "")
    rx795_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_809_done
  rxcap_809_fail:
    goto rx795_fail
  rxcap_809_done:
  # rx subrule "package_def" subtype=capture negate=
    rx795_cur."!cursor_pos"(rx795_pos)
    $P10 = rx795_cur."package_def"()
    unless $P10, rx795_fail
    rx795_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx795_pos = $P10."pos"()
.annotate 'line', 332
  # rx pass
    rx795_cur."!cursor_pass"(rx795_pos, "package_declarator:sym<role>")
    if_null rx795_debug, debug_893
    rx795_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx795_pos)
  debug_893:
    .return (rx795_cur)
  rx795_restart:
.annotate 'line', 10
    if_null rx795_debug, debug_894
    rx795_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_894:
  rx795_fail:
    (rx795_rep, rx795_pos, $I10, $P10) = rx795_cur."!mark_fail"(0)
    lt rx795_pos, -1, rx795_done
    eq rx795_pos, -1, rx795_fail
    jump $I10
  rx795_done:
    rx795_cur."!cursor_fail"()
    if_null rx795_debug, debug_895
    rx795_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_895:
    .return (rx795_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("149_1303923618.727") :method
.annotate 'line', 10
    $P797 = self."!PREFIX__!subrule"("package_def", "role")
    new $P798, "ResizablePMCArray"
    push $P798, $P797
    .return ($P798)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 339
    new $P811, "Undef"
    .lex "$*OUTERPACKAGE", $P811
.annotate 'line', 340
    new $P812, "Undef"
    .lex "$*PACKAGE-SETUP", $P812
.annotate 'line', 341
    new $P813, "Undef"
    .lex "$*PKGDECL", $P813
.annotate 'line', 10
    .local string rx814_tgt
    .local int rx814_pos
    .local int rx814_off
    .local int rx814_eos
    .local int rx814_rep
    .local pmc rx814_cur
    .local pmc rx814_debug
    (rx814_cur, rx814_pos, rx814_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx814_cur
    .local pmc match
    .lex "$/", match
    length rx814_eos, rx814_tgt
    gt rx814_pos, rx814_eos, rx814_done
    set rx814_off, 0
    lt rx814_pos, 2, rx814_start
    sub rx814_off, rx814_pos, 1
    substr rx814_tgt, rx814_tgt, rx814_off
  rx814_start:
    eq $I10, 1, rx814_restart
    if_null rx814_debug, debug_896
    rx814_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan818_done
    goto rxscan818_scan
  rxscan818_loop:
    (rx814_pos) = rx814_cur."from"()
    inc rx814_pos
    rx814_cur."!cursor_from"(rx814_pos)
    ge rx814_pos, rx814_eos, rxscan818_done
  rxscan818_scan:
    set_addr $I10, rxscan818_loop
    rx814_cur."!mark_push"(0, rx814_pos, $I10)
  rxscan818_done:
.annotate 'line', 339
    rx814_cur."!cursor_pos"(rx814_pos)
    find_dynamic_lex $P821, "$*PACKAGE"
    unless_null $P821, vivify_897
    get_hll_global $P819, "GLOBAL"
    get_who $P820, $P819
    set $P821, $P820["$PACKAGE"]
    unless_null $P821, vivify_898
    die "Contextual $*PACKAGE not found"
  vivify_898:
  vivify_897:
    store_lex "$*OUTERPACKAGE", $P821
.annotate 'line', 340
    rx814_cur."!cursor_pos"(rx814_pos)
    get_hll_global $P822, "GLOBAL"
    nqp_get_package_through_who $P823, $P822, "PAST"
    get_who $P824, $P823
    set $P825, $P824["Stmts"]
    $P826 = $P825."new"()
    store_lex "$*PACKAGE-SETUP", $P826
.annotate 'line', 341
    rx814_cur."!cursor_pos"(rx814_pos)
    new $P827, "String"
    assign $P827, "native"
    store_lex "$*PKGDECL", $P827
.annotate 'line', 342
  # rx subcapture "sym"
    set_addr $I10, rxcap_828_fail
    rx814_cur."!mark_push"(0, rx814_pos, $I10)
  # rx literal  "native"
    add $I11, rx814_pos, 6
    gt $I11, rx814_eos, rx814_fail
    sub $I11, rx814_pos, rx814_off
    substr $S10, rx814_tgt, $I11, 6
    ne $S10, "native", rx814_fail
    add rx814_pos, 6
    set_addr $I10, rxcap_828_fail
    ($I12, $I11) = rx814_cur."!mark_peek"($I10)
    rx814_cur."!cursor_pos"($I11)
    ($P10) = rx814_cur."!cursor_start"()
    $P10."!cursor_pass"(rx814_pos, "")
    rx814_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_828_done
  rxcap_828_fail:
    goto rx814_fail
  rxcap_828_done:
  # rx subrule "package_def" subtype=capture negate=
    rx814_cur."!cursor_pos"(rx814_pos)
    $P10 = rx814_cur."package_def"()
    unless $P10, rx814_fail
    rx814_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx814_pos = $P10."pos"()
.annotate 'line', 338
  # rx pass
    rx814_cur."!cursor_pass"(rx814_pos, "package_declarator:sym<native>")
    if_null rx814_debug, debug_899
    rx814_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx814_pos)
  debug_899:
    .return (rx814_cur)
  rx814_restart:
.annotate 'line', 10
    if_null rx814_debug, debug_900
    rx814_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_900:
  rx814_fail:
    (rx814_rep, rx814_pos, $I10, $P10) = rx814_cur."!mark_fail"(0)
    lt rx814_pos, -1, rx814_done
    eq rx814_pos, -1, rx814_fail
    jump $I10
  rx814_done:
    rx814_cur."!cursor_fail"()
    if_null rx814_debug, debug_901
    rx814_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_901:
    .return (rx814_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("151_1303923618.727") :method
.annotate 'line', 10
    $P816 = self."!PREFIX__!subrule"("package_def", "native")
    new $P817, "ResizablePMCArray"
    push $P817, $P816
    .return ($P817)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P857 = "154_1303923618.727" 
    capture_lex $P857
.annotate 'line', 346
    new $P830, "Undef"
    .lex "$*PACKAGE", $P830
.annotate 'line', 347
    $P831 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P831
.annotate 'line', 10
    .local string rx832_tgt
    .local int rx832_pos
    .local int rx832_off
    .local int rx832_eos
    .local int rx832_rep
    .local pmc rx832_cur
    .local pmc rx832_debug
    (rx832_cur, rx832_pos, rx832_tgt, $I10) = self."!cursor_start"()
    rx832_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx832_cur
    .local pmc match
    .lex "$/", match
    length rx832_eos, rx832_tgt
    gt rx832_pos, rx832_eos, rx832_done
    set rx832_off, 0
    lt rx832_pos, 2, rx832_start
    sub rx832_off, rx832_pos, 1
    substr rx832_tgt, rx832_tgt, rx832_off
  rx832_start:
    eq $I10, 1, rx832_restart
    if_null rx832_debug, debug_902
    rx832_cur."!cursor_debug"("START", "package_def")
  debug_902:
    $I10 = self.'from'()
    ne $I10, -1, rxscan836_done
    goto rxscan836_scan
  rxscan836_loop:
    (rx832_pos) = rx832_cur."from"()
    inc rx832_pos
    rx832_cur."!cursor_from"(rx832_pos)
    ge rx832_pos, rx832_eos, rxscan836_done
  rxscan836_scan:
    set_addr $I10, rxscan836_loop
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxscan836_done:
.annotate 'line', 345
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 346
    rx832_cur."!cursor_pos"(rx832_pos)
    find_lex $P840, "$*PACKAGE"
    unless_null $P840, vivify_903
    get_hll_global $P838, "GLOBAL"
    get_who $P839, $P838
    set $P840, $P839["$PACKAGE"]
    unless_null $P840, vivify_904
    die "Contextual $*PACKAGE not found"
  vivify_904:
  vivify_903:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 347
    rx832_cur."!cursor_pos"(rx832_pos)
    find_lex $P844, "%*ATTR-CHECK"
    unless_null $P844, vivify_905
    get_hll_global $P842, "GLOBAL"
    get_who $P843, $P842
    set $P844, $P843["%ATTR-CHECK"]
    unless_null $P844, vivify_906
    die "Contextual %*ATTR-CHECK not found"
  vivify_906:
  vivify_905:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 349
  # rx subrule "name" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."name"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 350
  # rx rxquantr847 ** 0..1
    set_addr $I10, rxquantr847_done
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxquantr847_loop:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx832_pos, 2
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 2
    ne $S10, "is", rx832_fail
    add rx832_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx832_pos, 5
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 5
    ne $S10, "repr(", rx832_fail
    add rx832_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."quote_EXPR"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx832_pos, 1
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    ord $I11, rx832_tgt, $I11
    ne $I11, 41, rx832_fail
    add rx832_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    set_addr $I10, rxquantr847_done
    (rx832_rep) = rx832_cur."!mark_commit"($I10)
  rxquantr847_done:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 352
    rx832_cur."!cursor_pos"(rx832_pos)
    find_lex $P854, unicode:"$\x{a2}"
    $P855 = $P854."MATCH"()
    store_lex "$/", $P855
    .const 'Sub' $P857 = "154_1303923618.727" 
    capture_lex $P857
    $P979 = $P857()
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 380
  # rx rxquantr981 ** 0..1
    set_addr $I10, rxquantr981_done
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxquantr981_loop:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx832_pos, 2
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 2
    ne $S10, "is", rx832_fail
    add rx832_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."name"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    set_addr $I10, rxquantr981_done
    (rx832_rep) = rx832_cur."!mark_commit"($I10)
  rxquantr981_done:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 381
  # rx rxquantr986 ** 0..*
    set_addr $I10, rxquantr986_done
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
  rxquantr986_loop:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx832_pos, 4
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I11, 4
    ne $S10, "does", rx832_fail
    add rx832_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."name"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    set_addr $I10, rxquantr986_done
    (rx832_rep) = rx832_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr986_done
    rx832_cur."!mark_push"(rx832_rep, rx832_pos, $I10)
    goto rxquantr986_loop
  rxquantr986_done:
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  alt991_0:
.annotate 'line', 382
    set_addr $I10, alt991_1
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
.annotate 'line', 383
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx832_pos, 1
    gt $I11, rx832_eos, rx832_fail
    sub $I11, rx832_pos, rx832_off
    ord $I11, rx832_tgt, $I11
    ne $I11, 59, rx832_fail
    add rx832_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."comp_unit"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    goto alt991_end
  alt991_1:
    set_addr $I10, alt991_2
    rx832_cur."!mark_push"(0, rx832_pos, $I10)
.annotate 'line', 384
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx832_pos, rx832_off
    substr $S10, rx832_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx832_fail
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."block"()
    unless $P10, rx832_fail
    rx832_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
    goto alt991_end
  alt991_2:
.annotate 'line', 385
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."panic"("Malformed package declaration")
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
  alt991_end:
.annotate 'line', 386
  # rx subrule "ws" subtype=method negate=
    rx832_cur."!cursor_pos"(rx832_pos)
    $P10 = rx832_cur."ws"()
    unless $P10, rx832_fail
    rx832_pos = $P10."pos"()
.annotate 'line', 345
  # rx pass
    rx832_cur."!cursor_pass"(rx832_pos, "package_def")
    if_null rx832_debug, debug_974
    rx832_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx832_pos)
  debug_974:
    .return (rx832_cur)
  rx832_restart:
.annotate 'line', 10
    if_null rx832_debug, debug_975
    rx832_cur."!cursor_debug"("NEXT", "package_def")
  debug_975:
  rx832_fail:
    (rx832_rep, rx832_pos, $I10, $P10) = rx832_cur."!mark_fail"(0)
    lt rx832_pos, -1, rx832_done
    eq rx832_pos, -1, rx832_fail
    jump $I10
  rx832_done:
    rx832_cur."!cursor_fail"()
    if_null rx832_debug, debug_976
    rx832_cur."!cursor_debug"("FAIL", "package_def")
  debug_976:
    .return (rx832_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("153_1303923618.727") :method
.annotate 'line', 10
    $P834 = self."!PREFIX__!subrule"("ws", "")
    new $P835, "ResizablePMCArray"
    push $P835, $P834
    .return ($P835)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block856"  :anon :subid("154_1303923618.727") :outer("152_1303923618.727")
.annotate 'line', 355
    $P858 = root_new ['parrot';'Hash']
    .lex "%args", $P858
.annotate 'line', 352
    find_lex $P859, "%args"
    unless_null $P859, vivify_907
    $P859 = root_new ['parrot';'Hash']
  vivify_907:
.annotate 'line', 356
    find_lex $P860, "$/"
    unless_null $P860, vivify_908
    $P860 = root_new ['parrot';'Hash']
  vivify_908:
    set $P861, $P860["name"]
    unless_null $P861, vivify_909
    new $P861, "Undef"
  vivify_909:
    set $S862, $P861
    new $P863, 'String'
    set $P863, $S862
    find_lex $P864, "%args"
    unless_null $P864, vivify_910
    $P864 = root_new ['parrot';'Hash']
    store_lex "%args", $P864
  vivify_910:
    set $P864["name"], $P863
.annotate 'line', 357
    find_lex $P866, "$/"
    unless_null $P866, vivify_911
    $P866 = root_new ['parrot';'Hash']
  vivify_911:
    set $P867, $P866["repr"]
    unless_null $P867, vivify_912
    new $P867, "Undef"
  vivify_912:
    unless $P867, if_865_end
.annotate 'line', 358
    find_lex $P868, "$/"
    unless_null $P868, vivify_913
    $P868 = root_new ['parrot';'Hash']
  vivify_913:
    set $P869, $P868["repr"]
    unless_null $P869, vivify_914
    $P869 = root_new ['parrot';'ResizablePMCArray']
  vivify_914:
    set $P870, $P869[0]
    unless_null $P870, vivify_915
    $P870 = root_new ['parrot';'Hash']
  vivify_915:
    set $P871, $P870["quote_delimited"]
    unless_null $P871, vivify_916
    $P871 = root_new ['parrot';'Hash']
  vivify_916:
    set $P872, $P871["quote_atom"]
    unless_null $P872, vivify_917
    $P872 = root_new ['parrot';'ResizablePMCArray']
  vivify_917:
    set $P873, $P872[0]
    unless_null $P873, vivify_918
    new $P873, "Undef"
  vivify_918:
    set $S874, $P873
    new $P875, 'String'
    set $P875, $S874
    find_lex $P876, "%args"
    unless_null $P876, vivify_919
    $P876 = root_new ['parrot';'Hash']
    store_lex "%args", $P876
  vivify_919:
    set $P876["repr"], $P875
  if_865_end:
.annotate 'line', 360
    find_dynamic_lex $P879, "$*SC"
    unless_null $P879, vivify_920
    get_hll_global $P877, "GLOBAL"
    get_who $P878, $P877
    set $P879, $P878["$SC"]
    unless_null $P879, vivify_921
    die "Contextual $*SC not found"
  vivify_921:
  vivify_920:
    find_dynamic_lex $P882, "$*PKGDECL"
    unless_null $P882, vivify_922
    get_hll_global $P880, "GLOBAL"
    get_who $P881, $P880
    set $P882, $P881["$PKGDECL"]
    unless_null $P882, vivify_923
    die "Contextual $*PKGDECL not found"
  vivify_923:
  vivify_922:
    find_dynamic_lex $P885, "%*HOW"
    unless_null $P885, vivify_924
    get_hll_global $P883, "GLOBAL"
    get_who $P884, $P883
    set $P885, $P884["%HOW"]
    unless_null $P885, vivify_925
    die "Contextual %*HOW not found"
  vivify_925:
  vivify_924:
    set $P886, $P885[$P882]
    unless_null $P886, vivify_926
    new $P886, "Undef"
  vivify_926:
    find_lex $P887, "%args"
    unless_null $P887, vivify_927
    $P887 = root_new ['parrot';'Hash']
  vivify_927:
    $P888 = $P879."pkg_create_mo"($P886, $P887 :flat)
    store_dynamic_lex "$*PACKAGE", $P888
.annotate 'line', 363
    find_dynamic_lex $P895, "$*SCOPE"
    unless_null $P895, vivify_928
    get_hll_global $P893, "GLOBAL"
    get_who $P894, $P893
    set $P895, $P894["$SCOPE"]
    unless_null $P895, vivify_929
    die "Contextual $*SCOPE not found"
  vivify_929:
  vivify_928:
    set $S896, $P895
    iseq $I897, $S896, "our"
    unless $I897, unless_892
    new $P891, 'Integer'
    set $P891, $I897
    goto unless_892_end
  unless_892:
    find_dynamic_lex $P900, "$*SCOPE"
    unless_null $P900, vivify_930
    get_hll_global $P898, "GLOBAL"
    get_who $P899, $P898
    set $P900, $P899["$SCOPE"]
    unless_null $P900, vivify_931
    die "Contextual $*SCOPE not found"
  vivify_931:
  vivify_930:
    set $S901, $P900
    iseq $I902, $S901, ""
    new $P891, 'Integer'
    set $P891, $I902
  unless_892_end:
    if $P891, if_890
.annotate 'line', 369
    find_dynamic_lex $P943, "$*SCOPE"
    unless_null $P943, vivify_932
    get_hll_global $P941, "GLOBAL"
    get_who $P942, $P941
    set $P943, $P942["$SCOPE"]
    unless_null $P943, vivify_933
    die "Contextual $*SCOPE not found"
  vivify_933:
  vivify_932:
    set $S944, $P943
    iseq $I945, $S944, "my"
    if $I945, if_940
.annotate 'line', 376
    find_lex $P972, "$/"
    unless_null $P972, vivify_934
    new $P972, "Undef"
  vivify_934:
    $P973 = $P972."CURSOR"()
    find_dynamic_lex $P976, "$*SCOPE"
    unless_null $P976, vivify_935
    get_hll_global $P974, "GLOBAL"
    get_who $P975, $P974
    set $P976, $P975["$SCOPE"]
    unless_null $P976, vivify_936
    die "Contextual $*SCOPE not found"
  vivify_936:
  vivify_935:
    concat $P977, $P976, " scoped packages are not supported"
    $P978 = $P973."panic"($P977)
.annotate 'line', 375
    set $P939, $P978
.annotate 'line', 369
    goto if_940_end
  if_940:
.annotate 'line', 370
    find_lex $P947, "$/"
    unless_null $P947, vivify_937
    $P947 = root_new ['parrot';'Hash']
  vivify_937:
    set $P948, $P947["name"]
    unless_null $P948, vivify_938
    $P948 = root_new ['parrot';'Hash']
  vivify_938:
    set $P949, $P948["identifier"]
    unless_null $P949, vivify_939
    new $P949, "Undef"
  vivify_939:
    set $N950, $P949
    isne $I951, $N950, 1.0
    unless $I951, if_946_end
.annotate 'line', 371
    find_lex $P952, "$/"
    unless_null $P952, vivify_940
    $P952 = root_new ['parrot';'Hash']
  vivify_940:
    set $P953, $P952["name"]
    unless_null $P953, vivify_941
    new $P953, "Undef"
  vivify_941:
    $P954 = $P953."CURSOR"()
    $P954."panic"("A my scoped package cannot have a multi-part name yet")
  if_946_end:
.annotate 'line', 373
    find_dynamic_lex $P957, "$*SC"
    unless_null $P957, vivify_942
    get_hll_global $P955, "GLOBAL"
    get_who $P956, $P955
    set $P957, $P956["$SC"]
    unless_null $P957, vivify_943
    die "Contextual $*SC not found"
  vivify_943:
  vivify_942:
    get_hll_global $P958, "GLOBAL"
    nqp_get_package_through_who $P959, $P958, "NQP"
    nqp_get_package_through_who $P960, $P959, "Actions"
    get_who $P961, $P960
    set $P962, $P961["@BLOCK"]
    unless_null $P962, vivify_944
    $P962 = root_new ['parrot';'ResizablePMCArray']
  vivify_944:
    set $P963, $P962[0]
    unless_null $P963, vivify_945
    new $P963, "Undef"
  vivify_945:
    find_lex $P964, "$/"
    unless_null $P964, vivify_946
    $P964 = root_new ['parrot';'Hash']
  vivify_946:
    set $P965, $P964["name"]
    unless_null $P965, vivify_947
    $P965 = root_new ['parrot';'Hash']
  vivify_947:
    set $P966, $P965["identifier"]
    unless_null $P966, vivify_948
    $P966 = root_new ['parrot';'ResizablePMCArray']
  vivify_948:
    set $P967, $P966[0]
    unless_null $P967, vivify_949
    new $P967, "Undef"
  vivify_949:
    find_dynamic_lex $P970, "$*PACKAGE"
    unless_null $P970, vivify_950
    get_hll_global $P968, "GLOBAL"
    get_who $P969, $P968
    set $P970, $P969["$PACKAGE"]
    unless_null $P970, vivify_951
    die "Contextual $*PACKAGE not found"
  vivify_951:
  vivify_950:
    $P971 = $P957."install_lexical_symbol"($P963, $P967, $P970)
.annotate 'line', 369
    set $P939, $P971
  if_940_end:
    set $P889, $P939
.annotate 'line', 363
    goto if_890_end
  if_890:
.annotate 'line', 364
    find_dynamic_lex $P905, "$*SC"
    unless_null $P905, vivify_952
    get_hll_global $P903, "GLOBAL"
    get_who $P904, $P903
    set $P905, $P904["$SC"]
    unless_null $P905, vivify_953
    die "Contextual $*SC not found"
  vivify_953:
  vivify_952:
    find_dynamic_lex $P908, "$*OUTERPACKAGE"
    unless_null $P908, vivify_954
    get_hll_global $P906, "GLOBAL"
    get_who $P907, $P906
    set $P908, $P907["$OUTERPACKAGE"]
    unless_null $P908, vivify_955
    die "Contextual $*OUTERPACKAGE not found"
  vivify_955:
  vivify_954:
    find_lex $P909, "$/"
    unless_null $P909, vivify_956
    $P909 = root_new ['parrot';'Hash']
  vivify_956:
    set $P910, $P909["name"]
    unless_null $P910, vivify_957
    $P910 = root_new ['parrot';'Hash']
  vivify_957:
    set $P911, $P910["identifier"]
    unless_null $P911, vivify_958
    new $P911, "Undef"
  vivify_958:
    find_dynamic_lex $P914, "$*PACKAGE"
    unless_null $P914, vivify_959
    get_hll_global $P912, "GLOBAL"
    get_who $P913, $P912
    set $P914, $P913["$PACKAGE"]
    unless_null $P914, vivify_960
    die "Contextual $*PACKAGE not found"
  vivify_960:
  vivify_959:
    $P905."install_package_symbol"($P908, $P911, $P914)
.annotate 'line', 365
    find_lex $P917, "$/"
    unless_null $P917, vivify_961
    $P917 = root_new ['parrot';'Hash']
  vivify_961:
    set $P918, $P917["name"]
    unless_null $P918, vivify_962
    $P918 = root_new ['parrot';'Hash']
  vivify_962:
    set $P919, $P918["identifier"]
    unless_null $P919, vivify_963
    new $P919, "Undef"
  vivify_963:
    set $N920, $P919
    iseq $I921, $N920, 1.0
    if $I921, if_916
    new $P915, 'Integer'
    set $P915, $I921
    goto if_916_end
  if_916:
.annotate 'line', 366
    find_dynamic_lex $P924, "$*SC"
    unless_null $P924, vivify_964
    get_hll_global $P922, "GLOBAL"
    get_who $P923, $P922
    set $P924, $P923["$SC"]
    unless_null $P924, vivify_965
    die "Contextual $*SC not found"
  vivify_965:
  vivify_964:
    get_hll_global $P925, "GLOBAL"
    nqp_get_package_through_who $P926, $P925, "NQP"
    nqp_get_package_through_who $P927, $P926, "Actions"
    get_who $P928, $P927
    set $P929, $P928["@BLOCK"]
    unless_null $P929, vivify_966
    $P929 = root_new ['parrot';'ResizablePMCArray']
  vivify_966:
    set $P930, $P929[0]
    unless_null $P930, vivify_967
    new $P930, "Undef"
  vivify_967:
    find_lex $P931, "$/"
    unless_null $P931, vivify_968
    $P931 = root_new ['parrot';'Hash']
  vivify_968:
    set $P932, $P931["name"]
    unless_null $P932, vivify_969
    $P932 = root_new ['parrot';'Hash']
  vivify_969:
    set $P933, $P932["identifier"]
    unless_null $P933, vivify_970
    $P933 = root_new ['parrot';'ResizablePMCArray']
  vivify_970:
    set $P934, $P933[0]
    unless_null $P934, vivify_971
    new $P934, "Undef"
  vivify_971:
    find_dynamic_lex $P937, "$*PACKAGE"
    unless_null $P937, vivify_972
    get_hll_global $P935, "GLOBAL"
    get_who $P936, $P935
    set $P937, $P936["$PACKAGE"]
    unless_null $P937, vivify_973
    die "Contextual $*PACKAGE not found"
  vivify_973:
  vivify_972:
    $P938 = $P924."install_lexical_symbol"($P930, $P934, $P937)
.annotate 'line', 365
    set $P915, $P938
  if_916_end:
.annotate 'line', 363
    set $P889, $P915
  if_890_end:
.annotate 'line', 352
    .return ($P889)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1303923618.727")
    .param pmc param_1002
.annotate 'line', 389
    .lex "self", param_1002
    $P1003 = param_1002."!protoregex"("scope_declarator")
    .return ($P1003)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1303923618.727")
    .param pmc param_1005
.annotate 'line', 389
    .lex "self", param_1005
    $P1006 = param_1005."!PREFIX__!protoregex"("scope_declarator")
    .return ($P1006)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1008_tgt
    .local int rx1008_pos
    .local int rx1008_off
    .local int rx1008_eos
    .local int rx1008_rep
    .local pmc rx1008_cur
    .local pmc rx1008_debug
    (rx1008_cur, rx1008_pos, rx1008_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1008_cur
    .local pmc match
    .lex "$/", match
    length rx1008_eos, rx1008_tgt
    gt rx1008_pos, rx1008_eos, rx1008_done
    set rx1008_off, 0
    lt rx1008_pos, 2, rx1008_start
    sub rx1008_off, rx1008_pos, 1
    substr rx1008_tgt, rx1008_tgt, rx1008_off
  rx1008_start:
    eq $I10, 1, rx1008_restart
    if_null rx1008_debug, debug_977
    rx1008_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1012_done
    goto rxscan1012_scan
  rxscan1012_loop:
    (rx1008_pos) = rx1008_cur."from"()
    inc rx1008_pos
    rx1008_cur."!cursor_from"(rx1008_pos)
    ge rx1008_pos, rx1008_eos, rxscan1012_done
  rxscan1012_scan:
    set_addr $I10, rxscan1012_loop
    rx1008_cur."!mark_push"(0, rx1008_pos, $I10)
  rxscan1012_done:
.annotate 'line', 390
  # rx subcapture "sym"
    set_addr $I10, rxcap_1013_fail
    rx1008_cur."!mark_push"(0, rx1008_pos, $I10)
  # rx literal  "my"
    add $I11, rx1008_pos, 2
    gt $I11, rx1008_eos, rx1008_fail
    sub $I11, rx1008_pos, rx1008_off
    substr $S10, rx1008_tgt, $I11, 2
    ne $S10, "my", rx1008_fail
    add rx1008_pos, 2
    set_addr $I10, rxcap_1013_fail
    ($I12, $I11) = rx1008_cur."!mark_peek"($I10)
    rx1008_cur."!cursor_pos"($I11)
    ($P10) = rx1008_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1008_pos, "")
    rx1008_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1013_done
  rxcap_1013_fail:
    goto rx1008_fail
  rxcap_1013_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1008_cur."!cursor_pos"(rx1008_pos)
    $P10 = rx1008_cur."scoped"("my")
    unless $P10, rx1008_fail
    rx1008_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1008_pos = $P10."pos"()
  # rx pass
    rx1008_cur."!cursor_pass"(rx1008_pos, "scope_declarator:sym<my>")
    if_null rx1008_debug, debug_978
    rx1008_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx1008_pos)
  debug_978:
    .return (rx1008_cur)
  rx1008_restart:
.annotate 'line', 10
    if_null rx1008_debug, debug_979
    rx1008_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_979:
  rx1008_fail:
    (rx1008_rep, rx1008_pos, $I10, $P10) = rx1008_cur."!mark_fail"(0)
    lt rx1008_pos, -1, rx1008_done
    eq rx1008_pos, -1, rx1008_fail
    jump $I10
  rx1008_done:
    rx1008_cur."!cursor_fail"()
    if_null rx1008_debug, debug_980
    rx1008_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_980:
    .return (rx1008_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("158_1303923618.727") :method
.annotate 'line', 10
    $P1010 = self."!PREFIX__!subrule"("scoped", "my")
    new $P1011, "ResizablePMCArray"
    push $P1011, $P1010
    .return ($P1011)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1015_tgt
    .local int rx1015_pos
    .local int rx1015_off
    .local int rx1015_eos
    .local int rx1015_rep
    .local pmc rx1015_cur
    .local pmc rx1015_debug
    (rx1015_cur, rx1015_pos, rx1015_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1015_cur
    .local pmc match
    .lex "$/", match
    length rx1015_eos, rx1015_tgt
    gt rx1015_pos, rx1015_eos, rx1015_done
    set rx1015_off, 0
    lt rx1015_pos, 2, rx1015_start
    sub rx1015_off, rx1015_pos, 1
    substr rx1015_tgt, rx1015_tgt, rx1015_off
  rx1015_start:
    eq $I10, 1, rx1015_restart
    if_null rx1015_debug, debug_981
    rx1015_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1019_done
    goto rxscan1019_scan
  rxscan1019_loop:
    (rx1015_pos) = rx1015_cur."from"()
    inc rx1015_pos
    rx1015_cur."!cursor_from"(rx1015_pos)
    ge rx1015_pos, rx1015_eos, rxscan1019_done
  rxscan1019_scan:
    set_addr $I10, rxscan1019_loop
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  rxscan1019_done:
.annotate 'line', 391
  # rx subcapture "sym"
    set_addr $I10, rxcap_1020_fail
    rx1015_cur."!mark_push"(0, rx1015_pos, $I10)
  # rx literal  "our"
    add $I11, rx1015_pos, 3
    gt $I11, rx1015_eos, rx1015_fail
    sub $I11, rx1015_pos, rx1015_off
    substr $S10, rx1015_tgt, $I11, 3
    ne $S10, "our", rx1015_fail
    add rx1015_pos, 3
    set_addr $I10, rxcap_1020_fail
    ($I12, $I11) = rx1015_cur."!mark_peek"($I10)
    rx1015_cur."!cursor_pos"($I11)
    ($P10) = rx1015_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1015_pos, "")
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1020_done
  rxcap_1020_fail:
    goto rx1015_fail
  rxcap_1020_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1015_cur."!cursor_pos"(rx1015_pos)
    $P10 = rx1015_cur."scoped"("our")
    unless $P10, rx1015_fail
    rx1015_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1015_pos = $P10."pos"()
  # rx pass
    rx1015_cur."!cursor_pass"(rx1015_pos, "scope_declarator:sym<our>")
    if_null rx1015_debug, debug_982
    rx1015_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx1015_pos)
  debug_982:
    .return (rx1015_cur)
  rx1015_restart:
.annotate 'line', 10
    if_null rx1015_debug, debug_983
    rx1015_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_983:
  rx1015_fail:
    (rx1015_rep, rx1015_pos, $I10, $P10) = rx1015_cur."!mark_fail"(0)
    lt rx1015_pos, -1, rx1015_done
    eq rx1015_pos, -1, rx1015_fail
    jump $I10
  rx1015_done:
    rx1015_cur."!cursor_fail"()
    if_null rx1015_debug, debug_984
    rx1015_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_984:
    .return (rx1015_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("160_1303923618.727") :method
.annotate 'line', 10
    $P1017 = self."!PREFIX__!subrule"("scoped", "our")
    new $P1018, "ResizablePMCArray"
    push $P1018, $P1017
    .return ($P1018)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1022_tgt
    .local int rx1022_pos
    .local int rx1022_off
    .local int rx1022_eos
    .local int rx1022_rep
    .local pmc rx1022_cur
    .local pmc rx1022_debug
    (rx1022_cur, rx1022_pos, rx1022_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1022_cur
    .local pmc match
    .lex "$/", match
    length rx1022_eos, rx1022_tgt
    gt rx1022_pos, rx1022_eos, rx1022_done
    set rx1022_off, 0
    lt rx1022_pos, 2, rx1022_start
    sub rx1022_off, rx1022_pos, 1
    substr rx1022_tgt, rx1022_tgt, rx1022_off
  rx1022_start:
    eq $I10, 1, rx1022_restart
    if_null rx1022_debug, debug_985
    rx1022_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1026_done
    goto rxscan1026_scan
  rxscan1026_loop:
    (rx1022_pos) = rx1022_cur."from"()
    inc rx1022_pos
    rx1022_cur."!cursor_from"(rx1022_pos)
    ge rx1022_pos, rx1022_eos, rxscan1026_done
  rxscan1026_scan:
    set_addr $I10, rxscan1026_loop
    rx1022_cur."!mark_push"(0, rx1022_pos, $I10)
  rxscan1026_done:
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_1027_fail
    rx1022_cur."!mark_push"(0, rx1022_pos, $I10)
  # rx literal  "has"
    add $I11, rx1022_pos, 3
    gt $I11, rx1022_eos, rx1022_fail
    sub $I11, rx1022_pos, rx1022_off
    substr $S10, rx1022_tgt, $I11, 3
    ne $S10, "has", rx1022_fail
    add rx1022_pos, 3
    set_addr $I10, rxcap_1027_fail
    ($I12, $I11) = rx1022_cur."!mark_peek"($I10)
    rx1022_cur."!cursor_pos"($I11)
    ($P10) = rx1022_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1022_pos, "")
    rx1022_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1027_done
  rxcap_1027_fail:
    goto rx1022_fail
  rxcap_1027_done:
  # rx subrule "scoped" subtype=capture negate=
    rx1022_cur."!cursor_pos"(rx1022_pos)
    $P10 = rx1022_cur."scoped"("has")
    unless $P10, rx1022_fail
    rx1022_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx1022_pos = $P10."pos"()
  # rx pass
    rx1022_cur."!cursor_pass"(rx1022_pos, "scope_declarator:sym<has>")
    if_null rx1022_debug, debug_986
    rx1022_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx1022_pos)
  debug_986:
    .return (rx1022_cur)
  rx1022_restart:
.annotate 'line', 10
    if_null rx1022_debug, debug_987
    rx1022_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_987:
  rx1022_fail:
    (rx1022_rep, rx1022_pos, $I10, $P10) = rx1022_cur."!mark_fail"(0)
    lt rx1022_pos, -1, rx1022_done
    eq rx1022_pos, -1, rx1022_fail
    jump $I10
  rx1022_done:
    rx1022_cur."!cursor_fail"()
    if_null rx1022_debug, debug_988
    rx1022_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_988:
    .return (rx1022_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("162_1303923618.727") :method
.annotate 'line', 10
    $P1024 = self."!PREFIX__!subrule"("scoped", "has")
    new $P1025, "ResizablePMCArray"
    push $P1025, $P1024
    .return ($P1025)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1303923618.727") :method :outer("12_1303923618.727")
    .param pmc param_1029
.annotate 'line', 394
    .lex "$*SCOPE", param_1029
.annotate 'line', 10
    .local string rx1030_tgt
    .local int rx1030_pos
    .local int rx1030_off
    .local int rx1030_eos
    .local int rx1030_rep
    .local pmc rx1030_cur
    .local pmc rx1030_debug
    (rx1030_cur, rx1030_pos, rx1030_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1030_cur
    .local pmc match
    .lex "$/", match
    length rx1030_eos, rx1030_tgt
    gt rx1030_pos, rx1030_eos, rx1030_done
    set rx1030_off, 0
    lt rx1030_pos, 2, rx1030_start
    sub rx1030_off, rx1030_pos, 1
    substr rx1030_tgt, rx1030_tgt, rx1030_off
  rx1030_start:
    eq $I10, 1, rx1030_restart
    if_null rx1030_debug, debug_989
    rx1030_cur."!cursor_debug"("START", "scoped")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1036_done
    goto rxscan1036_scan
  rxscan1036_loop:
    (rx1030_pos) = rx1030_cur."from"()
    inc rx1030_pos
    rx1030_cur."!cursor_from"(rx1030_pos)
    ge rx1030_pos, rx1030_eos, rxscan1036_done
  rxscan1036_scan:
    set_addr $I10, rxscan1036_loop
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxscan1036_done:
  alt1037_0:
.annotate 'line', 394
    set_addr $I10, alt1037_1
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
.annotate 'line', 395
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."declarator"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1030_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
    goto alt1037_end
  alt1037_1:
    set_addr $I10, alt1037_2
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."multi_declarator"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx1030_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
    goto alt1037_end
  alt1037_2:
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."package_declarator"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx1030_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  alt1037_end:
.annotate 'line', 394
  # rx pass
    rx1030_cur."!cursor_pass"(rx1030_pos, "scoped")
    if_null rx1030_debug, debug_990
    rx1030_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx1030_pos)
  debug_990:
    .return (rx1030_cur)
  rx1030_restart:
.annotate 'line', 10
    if_null rx1030_debug, debug_991
    rx1030_cur."!cursor_debug"("NEXT", "scoped")
  debug_991:
  rx1030_fail:
    (rx1030_rep, rx1030_pos, $I10, $P10) = rx1030_cur."!mark_fail"(0)
    lt rx1030_pos, -1, rx1030_done
    eq rx1030_pos, -1, rx1030_fail
    jump $I10
  rx1030_done:
    rx1030_cur."!cursor_fail"()
    if_null rx1030_debug, debug_992
    rx1030_cur."!cursor_debug"("FAIL", "scoped")
  debug_992:
    .return (rx1030_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("164_1303923618.727") :method
.annotate 'line', 10
    $P1032 = self."!PREFIX__!subrule"("ws", "")
    $P1033 = self."!PREFIX__!subrule"("ws", "")
    $P1034 = self."!PREFIX__!subrule"("ws", "")
    new $P1035, "ResizablePMCArray"
    push $P1035, $P1032
    push $P1035, $P1033
    push $P1035, $P1034
    .return ($P1035)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1045_tgt
    .local int rx1045_pos
    .local int rx1045_off
    .local int rx1045_eos
    .local int rx1045_rep
    .local pmc rx1045_cur
    .local pmc rx1045_debug
    (rx1045_cur, rx1045_pos, rx1045_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1045_cur
    .local pmc match
    .lex "$/", match
    length rx1045_eos, rx1045_tgt
    gt rx1045_pos, rx1045_eos, rx1045_done
    set rx1045_off, 0
    lt rx1045_pos, 2, rx1045_start
    sub rx1045_off, rx1045_pos, 1
    substr rx1045_tgt, rx1045_tgt, rx1045_off
  rx1045_start:
    eq $I10, 1, rx1045_restart
    if_null rx1045_debug, debug_993
    rx1045_cur."!cursor_debug"("START", "typename")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1049_done
    goto rxscan1049_scan
  rxscan1049_loop:
    (rx1045_pos) = rx1045_cur."from"()
    inc rx1045_pos
    rx1045_cur."!cursor_from"(rx1045_pos)
    ge rx1045_pos, rx1045_eos, rxscan1049_done
  rxscan1049_scan:
    set_addr $I10, rxscan1049_loop
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  rxscan1049_done:
.annotate 'line', 400
  # rx subrule "name" subtype=capture negate=
    rx1045_cur."!cursor_pos"(rx1045_pos)
    $P10 = rx1045_cur."name"()
    unless $P10, rx1045_fail
    rx1045_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1045_pos = $P10."pos"()
  # rx pass
    rx1045_cur."!cursor_pass"(rx1045_pos, "typename")
    if_null rx1045_debug, debug_994
    rx1045_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1045_pos)
  debug_994:
    .return (rx1045_cur)
  rx1045_restart:
.annotate 'line', 10
    if_null rx1045_debug, debug_995
    rx1045_cur."!cursor_debug"("NEXT", "typename")
  debug_995:
  rx1045_fail:
    (rx1045_rep, rx1045_pos, $I10, $P10) = rx1045_cur."!mark_fail"(0)
    lt rx1045_pos, -1, rx1045_done
    eq rx1045_pos, -1, rx1045_fail
    jump $I10
  rx1045_done:
    rx1045_cur."!cursor_fail"()
    if_null rx1045_debug, debug_996
    rx1045_cur."!cursor_debug"("FAIL", "typename")
  debug_996:
    .return (rx1045_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("166_1303923618.727") :method
.annotate 'line', 10
    $P1047 = self."!PREFIX__!subrule"("name", "")
    new $P1048, "ResizablePMCArray"
    push $P1048, $P1047
    .return ($P1048)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("167_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1051_tgt
    .local int rx1051_pos
    .local int rx1051_off
    .local int rx1051_eos
    .local int rx1051_rep
    .local pmc rx1051_cur
    .local pmc rx1051_debug
    (rx1051_cur, rx1051_pos, rx1051_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1051_cur
    .local pmc match
    .lex "$/", match
    length rx1051_eos, rx1051_tgt
    gt rx1051_pos, rx1051_eos, rx1051_done
    set rx1051_off, 0
    lt rx1051_pos, 2, rx1051_start
    sub rx1051_off, rx1051_pos, 1
    substr rx1051_tgt, rx1051_tgt, rx1051_off
  rx1051_start:
    eq $I10, 1, rx1051_restart
    if_null rx1051_debug, debug_997
    rx1051_cur."!cursor_debug"("START", "declarator")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1056_done
    goto rxscan1056_scan
  rxscan1056_loop:
    (rx1051_pos) = rx1051_cur."from"()
    inc rx1051_pos
    rx1051_cur."!cursor_from"(rx1051_pos)
    ge rx1051_pos, rx1051_eos, rxscan1056_done
  rxscan1056_scan:
    set_addr $I10, rxscan1056_loop
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
  rxscan1056_done:
  alt1057_0:
.annotate 'line', 402
    set_addr $I10, alt1057_1
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
.annotate 'line', 403
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1051_cur."!cursor_pos"(rx1051_pos)
    $P10 = rx1051_cur."variable_declarator"()
    unless $P10, rx1051_fail
    rx1051_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1051_pos = $P10."pos"()
    goto alt1057_end
  alt1057_1:
.annotate 'line', 404
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1051_cur."!cursor_pos"(rx1051_pos)
    $P10 = rx1051_cur."routine_declarator"()
    unless $P10, rx1051_fail
    rx1051_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1051_pos = $P10."pos"()
  alt1057_end:
.annotate 'line', 402
  # rx pass
    rx1051_cur."!cursor_pass"(rx1051_pos, "declarator")
    if_null rx1051_debug, debug_998
    rx1051_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1051_pos)
  debug_998:
    .return (rx1051_cur)
  rx1051_restart:
.annotate 'line', 10
    if_null rx1051_debug, debug_999
    rx1051_cur."!cursor_debug"("NEXT", "declarator")
  debug_999:
  rx1051_fail:
    (rx1051_rep, rx1051_pos, $I10, $P10) = rx1051_cur."!mark_fail"(0)
    lt rx1051_pos, -1, rx1051_done
    eq rx1051_pos, -1, rx1051_fail
    jump $I10
  rx1051_done:
    rx1051_cur."!cursor_fail"()
    if_null rx1051_debug, debug_1000
    rx1051_cur."!cursor_debug"("FAIL", "declarator")
  debug_1000:
    .return (rx1051_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("168_1303923618.727") :method
.annotate 'line', 10
    $P1053 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1054 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1055, "ResizablePMCArray"
    push $P1055, $P1053
    push $P1055, $P1054
    .return ($P1055)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("169_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P1075 = "171_1303923618.727" 
    capture_lex $P1075
.annotate 'line', 409
    new $P1059, "Undef"
    .lex "$*IN_DECL", $P1059
.annotate 'line', 10
    .local string rx1060_tgt
    .local int rx1060_pos
    .local int rx1060_off
    .local int rx1060_eos
    .local int rx1060_rep
    .local pmc rx1060_cur
    .local pmc rx1060_debug
    (rx1060_cur, rx1060_pos, rx1060_tgt, $I10) = self."!cursor_start"()
    rx1060_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1060_cur
    .local pmc match
    .lex "$/", match
    length rx1060_eos, rx1060_tgt
    gt rx1060_pos, rx1060_eos, rx1060_done
    set rx1060_off, 0
    lt rx1060_pos, 2, rx1060_start
    sub rx1060_off, rx1060_pos, 1
    substr rx1060_tgt, rx1060_tgt, rx1060_off
  rx1060_start:
    eq $I10, 1, rx1060_restart
    if_null rx1060_debug, debug_1001
    rx1060_cur."!cursor_debug"("START", "variable_declarator")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1064_done
    goto rxscan1064_scan
  rxscan1064_loop:
    (rx1060_pos) = rx1060_cur."from"()
    inc rx1060_pos
    rx1060_cur."!cursor_from"(rx1060_pos)
    ge rx1060_pos, rx1060_eos, rxscan1064_done
  rxscan1064_scan:
    set_addr $I10, rxscan1064_loop
    rx1060_cur."!mark_push"(0, rx1060_pos, $I10)
  rxscan1064_done:
.annotate 'line', 407
  # rx subrule "ws" subtype=method negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."ws"()
    unless $P10, rx1060_fail
    rx1060_pos = $P10."pos"()
.annotate 'line', 408
  # rx rxquantr1066 ** 0..1
    set_addr $I10, rxquantr1066_done
    rx1060_cur."!mark_push"(0, rx1060_pos, $I10)
  rxquantr1066_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."typename"()
    unless $P10, rx1060_fail
    goto rxsubrule1067_pass
  rxsubrule1067_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1060_fail
  rxsubrule1067_pass:
    set_addr $I10, rxsubrule1067_back
    rx1060_cur."!mark_push"(0, rx1060_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1060_pos = $P10."pos"()
    set_addr $I10, rxquantr1066_done
    (rx1060_rep) = rx1060_cur."!mark_commit"($I10)
  rxquantr1066_done:
  # rx subrule "ws" subtype=method negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."ws"()
    unless $P10, rx1060_fail
    rx1060_pos = $P10."pos"()
.annotate 'line', 409
    rx1060_cur."!cursor_pos"(rx1060_pos)
    new $P1069, "String"
    assign $P1069, "variable"
    store_lex "$*IN_DECL", $P1069
  # rx subrule "ws" subtype=method negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."ws"()
    unless $P10, rx1060_fail
    rx1060_pos = $P10."pos"()
.annotate 'line', 410
  # rx subrule "variable" subtype=capture negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."variable"()
    unless $P10, rx1060_fail
    rx1060_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1060_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."ws"()
    unless $P10, rx1060_fail
    rx1060_pos = $P10."pos"()
.annotate 'line', 411
    rx1060_cur."!cursor_pos"(rx1060_pos)
    find_lex $P1072, unicode:"$\x{a2}"
    $P1073 = $P1072."MATCH"()
    store_lex "$/", $P1073
    .const 'Sub' $P1075 = "171_1303923618.727" 
    capture_lex $P1075
    $P1077 = $P1075()
  # rx subrule "ws" subtype=method negate=
    rx1060_cur."!cursor_pos"(rx1060_pos)
    $P10 = rx1060_cur."ws"()
    unless $P10, rx1060_fail
    rx1060_pos = $P10."pos"()
.annotate 'line', 407
  # rx pass
    rx1060_cur."!cursor_pass"(rx1060_pos, "variable_declarator")
    if_null rx1060_debug, debug_1002
    rx1060_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1060_pos)
  debug_1002:
    .return (rx1060_cur)
  rx1060_restart:
.annotate 'line', 10
    if_null rx1060_debug, debug_1003
    rx1060_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1003:
  rx1060_fail:
    (rx1060_rep, rx1060_pos, $I10, $P10) = rx1060_cur."!mark_fail"(0)
    lt rx1060_pos, -1, rx1060_done
    eq rx1060_pos, -1, rx1060_fail
    jump $I10
  rx1060_done:
    rx1060_cur."!cursor_fail"()
    if_null rx1060_debug, debug_1004
    rx1060_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1004:
    .return (rx1060_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("170_1303923618.727") :method
.annotate 'line', 10
    $P1062 = self."!PREFIX__!subrule"("ws", "")
    new $P1063, "ResizablePMCArray"
    push $P1063, $P1062
    .return ($P1063)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1074"  :anon :subid("171_1303923618.727") :outer("169_1303923618.727")
.annotate 'line', 411
    new $P1076, "Integer"
    assign $P1076, 0
    store_dynamic_lex "$*IN_DECL", $P1076
    .return ($P1076)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("172_1303923618.727")
    .param pmc param_1080
.annotate 'line', 414
    .lex "self", param_1080
    $P1081 = param_1080."!protoregex"("routine_declarator")
    .return ($P1081)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("173_1303923618.727")
    .param pmc param_1083
.annotate 'line', 414
    .lex "self", param_1083
    $P1084 = param_1083."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1084)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("174_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1086_tgt
    .local int rx1086_pos
    .local int rx1086_off
    .local int rx1086_eos
    .local int rx1086_rep
    .local pmc rx1086_cur
    .local pmc rx1086_debug
    (rx1086_cur, rx1086_pos, rx1086_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1086_cur
    .local pmc match
    .lex "$/", match
    length rx1086_eos, rx1086_tgt
    gt rx1086_pos, rx1086_eos, rx1086_done
    set rx1086_off, 0
    lt rx1086_pos, 2, rx1086_start
    sub rx1086_off, rx1086_pos, 1
    substr rx1086_tgt, rx1086_tgt, rx1086_off
  rx1086_start:
    eq $I10, 1, rx1086_restart
    if_null rx1086_debug, debug_1005
    rx1086_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1090_done
    goto rxscan1090_scan
  rxscan1090_loop:
    (rx1086_pos) = rx1086_cur."from"()
    inc rx1086_pos
    rx1086_cur."!cursor_from"(rx1086_pos)
    ge rx1086_pos, rx1086_eos, rxscan1090_done
  rxscan1090_scan:
    set_addr $I10, rxscan1090_loop
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
  rxscan1090_done:
.annotate 'line', 415
  # rx subcapture "sym"
    set_addr $I10, rxcap_1091_fail
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1086_pos, 3
    gt $I11, rx1086_eos, rx1086_fail
    sub $I11, rx1086_pos, rx1086_off
    substr $S10, rx1086_tgt, $I11, 3
    ne $S10, "sub", rx1086_fail
    add rx1086_pos, 3
    set_addr $I10, rxcap_1091_fail
    ($I12, $I11) = rx1086_cur."!mark_peek"($I10)
    rx1086_cur."!cursor_pos"($I11)
    ($P10) = rx1086_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1086_pos, "")
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1091_done
  rxcap_1091_fail:
    goto rx1086_fail
  rxcap_1091_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1086_cur."!cursor_pos"(rx1086_pos)
    $P10 = rx1086_cur."routine_def"()
    unless $P10, rx1086_fail
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1086_pos = $P10."pos"()
  # rx pass
    rx1086_cur."!cursor_pass"(rx1086_pos, "routine_declarator:sym<sub>")
    if_null rx1086_debug, debug_1006
    rx1086_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1086_pos)
  debug_1006:
    .return (rx1086_cur)
  rx1086_restart:
.annotate 'line', 10
    if_null rx1086_debug, debug_1007
    rx1086_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1007:
  rx1086_fail:
    (rx1086_rep, rx1086_pos, $I10, $P10) = rx1086_cur."!mark_fail"(0)
    lt rx1086_pos, -1, rx1086_done
    eq rx1086_pos, -1, rx1086_fail
    jump $I10
  rx1086_done:
    rx1086_cur."!cursor_fail"()
    if_null rx1086_debug, debug_1008
    rx1086_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1008:
    .return (rx1086_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("175_1303923618.727") :method
.annotate 'line', 10
    $P1088 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1089, "ResizablePMCArray"
    push $P1089, $P1088
    .return ($P1089)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("176_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1093_tgt
    .local int rx1093_pos
    .local int rx1093_off
    .local int rx1093_eos
    .local int rx1093_rep
    .local pmc rx1093_cur
    .local pmc rx1093_debug
    (rx1093_cur, rx1093_pos, rx1093_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1093_cur
    .local pmc match
    .lex "$/", match
    length rx1093_eos, rx1093_tgt
    gt rx1093_pos, rx1093_eos, rx1093_done
    set rx1093_off, 0
    lt rx1093_pos, 2, rx1093_start
    sub rx1093_off, rx1093_pos, 1
    substr rx1093_tgt, rx1093_tgt, rx1093_off
  rx1093_start:
    eq $I10, 1, rx1093_restart
    if_null rx1093_debug, debug_1009
    rx1093_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1097_done
    goto rxscan1097_scan
  rxscan1097_loop:
    (rx1093_pos) = rx1093_cur."from"()
    inc rx1093_pos
    rx1093_cur."!cursor_from"(rx1093_pos)
    ge rx1093_pos, rx1093_eos, rxscan1097_done
  rxscan1097_scan:
    set_addr $I10, rxscan1097_loop
    rx1093_cur."!mark_push"(0, rx1093_pos, $I10)
  rxscan1097_done:
.annotate 'line', 416
  # rx subcapture "sym"
    set_addr $I10, rxcap_1098_fail
    rx1093_cur."!mark_push"(0, rx1093_pos, $I10)
  # rx literal  "method"
    add $I11, rx1093_pos, 6
    gt $I11, rx1093_eos, rx1093_fail
    sub $I11, rx1093_pos, rx1093_off
    substr $S10, rx1093_tgt, $I11, 6
    ne $S10, "method", rx1093_fail
    add rx1093_pos, 6
    set_addr $I10, rxcap_1098_fail
    ($I12, $I11) = rx1093_cur."!mark_peek"($I10)
    rx1093_cur."!cursor_pos"($I11)
    ($P10) = rx1093_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1093_pos, "")
    rx1093_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1098_done
  rxcap_1098_fail:
    goto rx1093_fail
  rxcap_1098_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1093_cur."!cursor_pos"(rx1093_pos)
    $P10 = rx1093_cur."method_def"()
    unless $P10, rx1093_fail
    rx1093_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1093_pos = $P10."pos"()
  # rx pass
    rx1093_cur."!cursor_pass"(rx1093_pos, "routine_declarator:sym<method>")
    if_null rx1093_debug, debug_1010
    rx1093_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1093_pos)
  debug_1010:
    .return (rx1093_cur)
  rx1093_restart:
.annotate 'line', 10
    if_null rx1093_debug, debug_1011
    rx1093_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1011:
  rx1093_fail:
    (rx1093_rep, rx1093_pos, $I10, $P10) = rx1093_cur."!mark_fail"(0)
    lt rx1093_pos, -1, rx1093_done
    eq rx1093_pos, -1, rx1093_fail
    jump $I10
  rx1093_done:
    rx1093_cur."!cursor_fail"()
    if_null rx1093_debug, debug_1012
    rx1093_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1012:
    .return (rx1093_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("177_1303923618.727") :method
.annotate 'line', 10
    $P1095 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1096, "ResizablePMCArray"
    push $P1096, $P1095
    .return ($P1096)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("178_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 419
    new $P1100, "Undef"
    .lex "$*RETURN_USED", $P1100
.annotate 'line', 10
    .local string rx1101_tgt
    .local int rx1101_pos
    .local int rx1101_off
    .local int rx1101_eos
    .local int rx1101_rep
    .local pmc rx1101_cur
    .local pmc rx1101_debug
    (rx1101_cur, rx1101_pos, rx1101_tgt, $I10) = self."!cursor_start"()
    rx1101_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1101_cur
    .local pmc match
    .lex "$/", match
    length rx1101_eos, rx1101_tgt
    gt rx1101_pos, rx1101_eos, rx1101_done
    set rx1101_off, 0
    lt rx1101_pos, 2, rx1101_start
    sub rx1101_off, rx1101_pos, 1
    substr rx1101_tgt, rx1101_tgt, rx1101_off
  rx1101_start:
    eq $I10, 1, rx1101_restart
    if_null rx1101_debug, debug_1013
    rx1101_cur."!cursor_debug"("START", "routine_def")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1105_done
    goto rxscan1105_scan
  rxscan1105_loop:
    (rx1101_pos) = rx1101_cur."from"()
    inc rx1101_pos
    rx1101_cur."!cursor_from"(rx1101_pos)
    ge rx1101_pos, rx1101_eos, rxscan1105_done
  rxscan1105_scan:
    set_addr $I10, rxscan1105_loop
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
  rxscan1105_done:
.annotate 'line', 418
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
.annotate 'line', 419
    rx1101_cur."!cursor_pos"(rx1101_pos)
    new $P1107, "Integer"
    assign $P1107, 0
    store_lex "$*RETURN_USED", $P1107
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
.annotate 'line', 420
  # rx rxquantr1109 ** 0..1
    set_addr $I10, rxquantr1109_done
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
  rxquantr1109_loop:
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1112_fail
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
  # rx rxquantr1111 ** 0..1
    set_addr $I10, rxquantr1111_done
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
  rxquantr1111_loop:
  # rx literal  "&"
    add $I11, rx1101_pos, 1
    gt $I11, rx1101_eos, rx1101_fail
    sub $I11, rx1101_pos, rx1101_off
    ord $I11, rx1101_tgt, $I11
    ne $I11, 38, rx1101_fail
    add rx1101_pos, 1
    set_addr $I10, rxquantr1111_done
    (rx1101_rep) = rx1101_cur."!mark_commit"($I10)
  rxquantr1111_done:
    set_addr $I10, rxcap_1112_fail
    ($I12, $I11) = rx1101_cur."!mark_peek"($I10)
    rx1101_cur."!cursor_pos"($I11)
    ($P10) = rx1101_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1101_pos, "")
    rx1101_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1112_done
  rxcap_1112_fail:
    goto rx1101_fail
  rxcap_1112_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."deflongname"()
    unless $P10, rx1101_fail
    rx1101_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1101_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
    set_addr $I10, rxquantr1109_done
    (rx1101_rep) = rx1101_cur."!mark_commit"($I10)
  rxquantr1109_done:
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
.annotate 'line', 421
  # rx subrule "newpad" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."newpad"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  alt1116_0:
.annotate 'line', 422
    set_addr $I10, alt1116_1
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1101_pos, 1
    gt $I11, rx1101_eos, rx1101_fail
    sub $I11, rx1101_pos, rx1101_off
    ord $I11, rx1101_tgt, $I11
    ne $I11, 40, rx1101_fail
    add rx1101_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."signature"()
    unless $P10, rx1101_fail
    rx1101_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1101_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1101_pos, 1
    gt $I11, rx1101_eos, rx1101_fail
    sub $I11, rx1101_pos, rx1101_off
    ord $I11, rx1101_tgt, $I11
    ne $I11, 41, rx1101_fail
    add rx1101_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
    goto alt1116_end
  alt1116_1:
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  alt1116_end:
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
.annotate 'line', 424
  # rx rxquantr1124 ** 0..*
    set_addr $I10, rxquantr1124_done
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
  rxquantr1124_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."trait"()
    unless $P10, rx1101_fail
    goto rxsubrule1125_pass
  rxsubrule1125_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1101_fail
  rxsubrule1125_pass:
    set_addr $I10, rxsubrule1125_back
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1101_pos = $P10."pos"()
    set_addr $I10, rxquantr1124_done
    (rx1101_rep) = rx1101_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1124_done
    rx1101_cur."!mark_push"(rx1101_rep, rx1101_pos, $I10)
    goto rxquantr1124_loop
  rxquantr1124_done:
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  alt1127_0:
.annotate 'line', 425
    set_addr $I10, alt1127_1
    rx1101_cur."!mark_push"(0, rx1101_pos, $I10)
.annotate 'line', 426
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."onlystar"()
    unless $P10, rx1101_fail
    rx1101_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1101_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
    goto alt1127_end
  alt1127_1:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."blockoid"()
    unless $P10, rx1101_fail
    rx1101_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1101_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
  alt1127_end:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx1101_cur."!cursor_pos"(rx1101_pos)
    $P10 = rx1101_cur."ws"()
    unless $P10, rx1101_fail
    rx1101_pos = $P10."pos"()
.annotate 'line', 418
  # rx pass
    rx1101_cur."!cursor_pass"(rx1101_pos, "routine_def")
    if_null rx1101_debug, debug_1014
    rx1101_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1101_pos)
  debug_1014:
    .return (rx1101_cur)
  rx1101_restart:
.annotate 'line', 10
    if_null rx1101_debug, debug_1015
    rx1101_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1015:
  rx1101_fail:
    (rx1101_rep, rx1101_pos, $I10, $P10) = rx1101_cur."!mark_fail"(0)
    lt rx1101_pos, -1, rx1101_done
    eq rx1101_pos, -1, rx1101_fail
    jump $I10
  rx1101_done:
    rx1101_cur."!cursor_fail"()
    if_null rx1101_debug, debug_1016
    rx1101_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1016:
    .return (rx1101_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("179_1303923618.727") :method
.annotate 'line', 10
    $P1103 = self."!PREFIX__!subrule"("ws", "")
    new $P1104, "ResizablePMCArray"
    push $P1104, $P1103
    .return ($P1104)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("180_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P1164 = "182_1303923618.727" 
    capture_lex $P1164
.annotate 'line', 432
    new $P1134, "Undef"
    .lex "$*RETURN_USED", $P1134
.annotate 'line', 433
    new $P1135, "Undef"
    .lex "$*INVOCANT_OK", $P1135
.annotate 'line', 10
    .local string rx1136_tgt
    .local int rx1136_pos
    .local int rx1136_off
    .local int rx1136_eos
    .local int rx1136_rep
    .local pmc rx1136_cur
    .local pmc rx1136_debug
    (rx1136_cur, rx1136_pos, rx1136_tgt, $I10) = self."!cursor_start"()
    rx1136_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1136_cur
    .local pmc match
    .lex "$/", match
    length rx1136_eos, rx1136_tgt
    gt rx1136_pos, rx1136_eos, rx1136_done
    set rx1136_off, 0
    lt rx1136_pos, 2, rx1136_start
    sub rx1136_off, rx1136_pos, 1
    substr rx1136_tgt, rx1136_tgt, rx1136_off
  rx1136_start:
    eq $I10, 1, rx1136_restart
    if_null rx1136_debug, debug_1017
    rx1136_cur."!cursor_debug"("START", "method_def")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1140_done
    goto rxscan1140_scan
  rxscan1140_loop:
    (rx1136_pos) = rx1136_cur."from"()
    inc rx1136_pos
    rx1136_cur."!cursor_from"(rx1136_pos)
    ge rx1136_pos, rx1136_eos, rxscan1140_done
  rxscan1140_scan:
    set_addr $I10, rxscan1140_loop
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxscan1140_done:
.annotate 'line', 431
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
.annotate 'line', 432
    rx1136_cur."!cursor_pos"(rx1136_pos)
    new $P1142, "Integer"
    assign $P1142, 0
    store_lex "$*RETURN_USED", $P1142
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
.annotate 'line', 433
    rx1136_cur."!cursor_pos"(rx1136_pos)
    new $P1144, "Integer"
    assign $P1144, 1
    store_lex "$*INVOCANT_OK", $P1144
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
.annotate 'line', 434
  # rx subcapture "private"
    set_addr $I10, rxcap_1147_fail
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  # rx rxquantr1146 ** 0..1
    set_addr $I10, rxquantr1146_done
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxquantr1146_loop:
  # rx literal  "!"
    add $I11, rx1136_pos, 1
    gt $I11, rx1136_eos, rx1136_fail
    sub $I11, rx1136_pos, rx1136_off
    ord $I11, rx1136_tgt, $I11
    ne $I11, 33, rx1136_fail
    add rx1136_pos, 1
    set_addr $I10, rxquantr1146_done
    (rx1136_rep) = rx1136_cur."!mark_commit"($I10)
  rxquantr1146_done:
    set_addr $I10, rxcap_1147_fail
    ($I12, $I11) = rx1136_cur."!mark_peek"($I10)
    rx1136_cur."!cursor_pos"($I11)
    ($P10) = rx1136_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1136_pos, "")
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1147_done
  rxcap_1147_fail:
    goto rx1136_fail
  rxcap_1147_done:
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
.annotate 'line', 435
  # rx rxquantr1149 ** 0..1
    set_addr $I10, rxquantr1149_done
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxquantr1149_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."deflongname"()
    unless $P10, rx1136_fail
    goto rxsubrule1150_pass
  rxsubrule1150_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1136_fail
  rxsubrule1150_pass:
    set_addr $I10, rxsubrule1150_back
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1136_pos = $P10."pos"()
    set_addr $I10, rxquantr1149_done
    (rx1136_rep) = rx1136_cur."!mark_commit"($I10)
  rxquantr1149_done:
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
.annotate 'line', 436
  # rx subrule "newpad" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."newpad"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  alt1153_0:
.annotate 'line', 437
    set_addr $I10, alt1153_1
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1136_pos, 1
    gt $I11, rx1136_eos, rx1136_fail
    sub $I11, rx1136_pos, rx1136_off
    ord $I11, rx1136_tgt, $I11
    ne $I11, 40, rx1136_fail
    add rx1136_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."signature"()
    unless $P10, rx1136_fail
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1136_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1136_pos, 1
    gt $I11, rx1136_eos, rx1136_fail
    sub $I11, rx1136_pos, rx1136_off
    ord $I11, rx1136_tgt, $I11
    ne $I11, 41, rx1136_fail
    add rx1136_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
    goto alt1153_end
  alt1153_1:
.annotate 'line', 438
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  alt1153_end:
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
.annotate 'line', 439
    rx1136_cur."!cursor_pos"(rx1136_pos)
    find_lex $P1161, unicode:"$\x{a2}"
    $P1162 = $P1161."MATCH"()
    store_lex "$/", $P1162
    .const 'Sub' $P1164 = "182_1303923618.727" 
    capture_lex $P1164
    $P1166 = $P1164()
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
.annotate 'line', 440
  # rx rxquantr1168 ** 0..*
    set_addr $I10, rxquantr1168_done
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxquantr1168_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."trait"()
    unless $P10, rx1136_fail
    goto rxsubrule1169_pass
  rxsubrule1169_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1136_fail
  rxsubrule1169_pass:
    set_addr $I10, rxsubrule1169_back
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1136_pos = $P10."pos"()
    set_addr $I10, rxquantr1168_done
    (rx1136_rep) = rx1136_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1168_done
    rx1136_cur."!mark_push"(rx1136_rep, rx1136_pos, $I10)
    goto rxquantr1168_loop
  rxquantr1168_done:
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  alt1171_0:
.annotate 'line', 441
    set_addr $I10, alt1171_1
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."onlystar"()
    unless $P10, rx1136_fail
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1136_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
    goto alt1171_end
  alt1171_1:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."blockoid"()
    unless $P10, rx1136_fail
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1136_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  alt1171_end:
.annotate 'line', 444
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
.annotate 'line', 431
  # rx pass
    rx1136_cur."!cursor_pass"(rx1136_pos, "method_def")
    if_null rx1136_debug, debug_1018
    rx1136_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1136_pos)
  debug_1018:
    .return (rx1136_cur)
  rx1136_restart:
.annotate 'line', 10
    if_null rx1136_debug, debug_1019
    rx1136_cur."!cursor_debug"("NEXT", "method_def")
  debug_1019:
  rx1136_fail:
    (rx1136_rep, rx1136_pos, $I10, $P10) = rx1136_cur."!mark_fail"(0)
    lt rx1136_pos, -1, rx1136_done
    eq rx1136_pos, -1, rx1136_fail
    jump $I10
  rx1136_done:
    rx1136_cur."!cursor_fail"()
    if_null rx1136_debug, debug_1020
    rx1136_cur."!cursor_debug"("FAIL", "method_def")
  debug_1020:
    .return (rx1136_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("181_1303923618.727") :method
.annotate 'line', 10
    $P1138 = self."!PREFIX__!subrule"("ws", "")
    new $P1139, "ResizablePMCArray"
    push $P1139, $P1138
    .return ($P1139)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1163"  :anon :subid("182_1303923618.727") :outer("180_1303923618.727")
.annotate 'line', 439
    new $P1165, "Integer"
    assign $P1165, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1165
    .return ($P1165)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("183_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P1185 = "185_1303923618.727" 
    capture_lex $P1185
    .local string rx1178_tgt
    .local int rx1178_pos
    .local int rx1178_off
    .local int rx1178_eos
    .local int rx1178_rep
    .local pmc rx1178_cur
    .local pmc rx1178_debug
    (rx1178_cur, rx1178_pos, rx1178_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1178_cur
    .local pmc match
    .lex "$/", match
    length rx1178_eos, rx1178_tgt
    gt rx1178_pos, rx1178_eos, rx1178_done
    set rx1178_off, 0
    lt rx1178_pos, 2, rx1178_start
    sub rx1178_off, rx1178_pos, 1
    substr rx1178_tgt, rx1178_tgt, rx1178_off
  rx1178_start:
    eq $I10, 1, rx1178_restart
    if_null rx1178_debug, debug_1021
    rx1178_cur."!cursor_debug"("START", "onlystar")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1181_done
    goto rxscan1181_scan
  rxscan1181_loop:
    (rx1178_pos) = rx1178_cur."from"()
    inc rx1178_pos
    rx1178_cur."!cursor_from"(rx1178_pos)
    ge rx1178_pos, rx1178_eos, rxscan1181_done
  rxscan1181_scan:
    set_addr $I10, rxscan1181_loop
    rx1178_cur."!mark_push"(0, rx1178_pos, $I10)
  rxscan1181_done:
.annotate 'line', 448
    rx1178_cur."!cursor_pos"(rx1178_pos)
    find_lex $P1182, unicode:"$\x{a2}"
    $P1183 = $P1182."MATCH"()
    store_lex "$/", $P1183
    .const 'Sub' $P1185 = "185_1303923618.727" 
    capture_lex $P1185
    $P1191 = $P1185()
    unless $P1191, rx1178_fail
.annotate 'line', 449
  # rx literal  "{"
    add $I11, rx1178_pos, 1
    gt $I11, rx1178_eos, rx1178_fail
    sub $I11, rx1178_pos, rx1178_off
    ord $I11, rx1178_tgt, $I11
    ne $I11, 123, rx1178_fail
    add rx1178_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1178_cur."!cursor_pos"(rx1178_pos)
    $P10 = rx1178_cur."ws"()
    unless $P10, rx1178_fail
    rx1178_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1178_pos, 1
    gt $I11, rx1178_eos, rx1178_fail
    sub $I11, rx1178_pos, rx1178_off
    ord $I11, rx1178_tgt, $I11
    ne $I11, 42, rx1178_fail
    add rx1178_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1178_cur."!cursor_pos"(rx1178_pos)
    $P10 = rx1178_cur."ws"()
    unless $P10, rx1178_fail
    rx1178_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1178_pos, 1
    gt $I11, rx1178_eos, rx1178_fail
    sub $I11, rx1178_pos, rx1178_off
    ord $I11, rx1178_tgt, $I11
    ne $I11, 125, rx1178_fail
    add rx1178_pos, 1
.annotate 'line', 450
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1178_cur."!cursor_pos"(rx1178_pos)
    $P10 = rx1178_cur."ENDSTMT"()
    unless $P10, rx1178_fail
.annotate 'line', 451
  # rx subrule "finishpad" subtype=method negate=
    rx1178_cur."!cursor_pos"(rx1178_pos)
    $P10 = rx1178_cur."finishpad"()
    unless $P10, rx1178_fail
    rx1178_pos = $P10."pos"()
.annotate 'line', 447
  # rx pass
    rx1178_cur."!cursor_pass"(rx1178_pos, "onlystar")
    if_null rx1178_debug, debug_1024
    rx1178_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1178_pos)
  debug_1024:
    .return (rx1178_cur)
  rx1178_restart:
.annotate 'line', 10
    if_null rx1178_debug, debug_1025
    rx1178_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1025:
  rx1178_fail:
    (rx1178_rep, rx1178_pos, $I10, $P10) = rx1178_cur."!mark_fail"(0)
    lt rx1178_pos, -1, rx1178_done
    eq rx1178_pos, -1, rx1178_fail
    jump $I10
  rx1178_done:
    rx1178_cur."!cursor_fail"()
    if_null rx1178_debug, debug_1026
    rx1178_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1026:
    .return (rx1178_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("184_1303923618.727") :method
.annotate 'line', 10
    new $P1180, "ResizablePMCArray"
    push $P1180, ""
    .return ($P1180)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1184"  :anon :subid("185_1303923618.727") :outer("183_1303923618.727")
.annotate 'line', 448
    find_dynamic_lex $P1188, "$*MULTINESS"
    unless_null $P1188, vivify_1022
    get_hll_global $P1186, "GLOBAL"
    get_who $P1187, $P1186
    set $P1188, $P1187["$MULTINESS"]
    unless_null $P1188, vivify_1023
    die "Contextual $*MULTINESS not found"
  vivify_1023:
  vivify_1022:
    set $S1189, $P1188
    iseq $I1190, $S1189, "proto"
    .return ($I1190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("186_1303923618.727")
    .param pmc param_1193
.annotate 'line', 454
    .lex "self", param_1193
    $P1194 = param_1193."!protoregex"("multi_declarator")
    .return ($P1194)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("187_1303923618.727")
    .param pmc param_1196
.annotate 'line', 454
    .lex "self", param_1196
    $P1197 = param_1196."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("188_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 456
    new $P1199, "Undef"
    .lex "$*MULTINESS", $P1199
.annotate 'line', 10
    .local string rx1200_tgt
    .local int rx1200_pos
    .local int rx1200_off
    .local int rx1200_eos
    .local int rx1200_rep
    .local pmc rx1200_cur
    .local pmc rx1200_debug
    (rx1200_cur, rx1200_pos, rx1200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1200_cur
    .local pmc match
    .lex "$/", match
    length rx1200_eos, rx1200_tgt
    gt rx1200_pos, rx1200_eos, rx1200_done
    set rx1200_off, 0
    lt rx1200_pos, 2, rx1200_start
    sub rx1200_off, rx1200_pos, 1
    substr rx1200_tgt, rx1200_tgt, rx1200_off
  rx1200_start:
    eq $I10, 1, rx1200_restart
    if_null rx1200_debug, debug_1027
    rx1200_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1027:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1204_done
    goto rxscan1204_scan
  rxscan1204_loop:
    (rx1200_pos) = rx1200_cur."from"()
    inc rx1200_pos
    rx1200_cur."!cursor_from"(rx1200_pos)
    ge rx1200_pos, rx1200_eos, rxscan1204_done
  rxscan1204_scan:
    set_addr $I10, rxscan1204_loop
    rx1200_cur."!mark_push"(0, rx1200_pos, $I10)
  rxscan1204_done:
.annotate 'line', 456
    rx1200_cur."!cursor_pos"(rx1200_pos)
    new $P1205, "String"
    assign $P1205, "multi"
    store_lex "$*MULTINESS", $P1205
.annotate 'line', 457
  # rx subcapture "sym"
    set_addr $I10, rxcap_1206_fail
    rx1200_cur."!mark_push"(0, rx1200_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1200_pos, 5
    gt $I11, rx1200_eos, rx1200_fail
    sub $I11, rx1200_pos, rx1200_off
    substr $S10, rx1200_tgt, $I11, 5
    ne $S10, "multi", rx1200_fail
    add rx1200_pos, 5
    set_addr $I10, rxcap_1206_fail
    ($I12, $I11) = rx1200_cur."!mark_peek"($I10)
    rx1200_cur."!cursor_pos"($I11)
    ($P10) = rx1200_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1200_pos, "")
    rx1200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1206_done
  rxcap_1206_fail:
    goto rx1200_fail
  rxcap_1206_done:
.annotate 'line', 458
  # rx subrule "ws" subtype=method negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."ws"()
    unless $P10, rx1200_fail
    rx1200_pos = $P10."pos"()
  alt1207_0:
    set_addr $I10, alt1207_1
    rx1200_cur."!mark_push"(0, rx1200_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."declarator"()
    unless $P10, rx1200_fail
    rx1200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1200_pos = $P10."pos"()
    goto alt1207_end
  alt1207_1:
    set_addr $I10, alt1207_2
    rx1200_cur."!mark_push"(0, rx1200_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."routine_def"()
    unless $P10, rx1200_fail
    rx1200_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1200_pos = $P10."pos"()
    goto alt1207_end
  alt1207_2:
  # rx subrule "panic" subtype=method negate=
    rx1200_cur."!cursor_pos"(rx1200_pos)
    $P10 = rx1200_cur."panic"("Malformed multi")
    unless $P10, rx1200_fail
    rx1200_pos = $P10."pos"()
  alt1207_end:
.annotate 'line', 455
  # rx pass
    rx1200_cur."!cursor_pass"(rx1200_pos, "multi_declarator:sym<multi>")
    if_null rx1200_debug, debug_1028
    rx1200_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1200_pos)
  debug_1028:
    .return (rx1200_cur)
  rx1200_restart:
.annotate 'line', 10
    if_null rx1200_debug, debug_1029
    rx1200_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1029:
  rx1200_fail:
    (rx1200_rep, rx1200_pos, $I10, $P10) = rx1200_cur."!mark_fail"(0)
    lt rx1200_pos, -1, rx1200_done
    eq rx1200_pos, -1, rx1200_fail
    jump $I10
  rx1200_done:
    rx1200_cur."!cursor_fail"()
    if_null rx1200_debug, debug_1030
    rx1200_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1030:
    .return (rx1200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("189_1303923618.727") :method
.annotate 'line', 10
    $P1202 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1203, "ResizablePMCArray"
    push $P1203, $P1202
    .return ($P1203)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("190_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 461
    new $P1209, "Undef"
    .lex "$*MULTINESS", $P1209
.annotate 'line', 10
    .local string rx1210_tgt
    .local int rx1210_pos
    .local int rx1210_off
    .local int rx1210_eos
    .local int rx1210_rep
    .local pmc rx1210_cur
    .local pmc rx1210_debug
    (rx1210_cur, rx1210_pos, rx1210_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1210_cur
    .local pmc match
    .lex "$/", match
    length rx1210_eos, rx1210_tgt
    gt rx1210_pos, rx1210_eos, rx1210_done
    set rx1210_off, 0
    lt rx1210_pos, 2, rx1210_start
    sub rx1210_off, rx1210_pos, 1
    substr rx1210_tgt, rx1210_tgt, rx1210_off
  rx1210_start:
    eq $I10, 1, rx1210_restart
    if_null rx1210_debug, debug_1031
    rx1210_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1031:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1214_done
    goto rxscan1214_scan
  rxscan1214_loop:
    (rx1210_pos) = rx1210_cur."from"()
    inc rx1210_pos
    rx1210_cur."!cursor_from"(rx1210_pos)
    ge rx1210_pos, rx1210_eos, rxscan1214_done
  rxscan1214_scan:
    set_addr $I10, rxscan1214_loop
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  rxscan1214_done:
.annotate 'line', 461
    rx1210_cur."!cursor_pos"(rx1210_pos)
    new $P1215, "String"
    assign $P1215, "proto"
    store_lex "$*MULTINESS", $P1215
.annotate 'line', 462
  # rx subcapture "sym"
    set_addr $I10, rxcap_1216_fail
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1210_pos, 5
    gt $I11, rx1210_eos, rx1210_fail
    sub $I11, rx1210_pos, rx1210_off
    substr $S10, rx1210_tgt, $I11, 5
    ne $S10, "proto", rx1210_fail
    add rx1210_pos, 5
    set_addr $I10, rxcap_1216_fail
    ($I12, $I11) = rx1210_cur."!mark_peek"($I10)
    rx1210_cur."!cursor_pos"($I11)
    ($P10) = rx1210_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1210_pos, "")
    rx1210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1216_done
  rxcap_1216_fail:
    goto rx1210_fail
  rxcap_1216_done:
.annotate 'line', 463
  # rx subrule "ws" subtype=method negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."ws"()
    unless $P10, rx1210_fail
    rx1210_pos = $P10."pos"()
  alt1217_0:
    set_addr $I10, alt1217_1
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."declarator"()
    unless $P10, rx1210_fail
    rx1210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1210_pos = $P10."pos"()
    goto alt1217_end
  alt1217_1:
    set_addr $I10, alt1217_2
    rx1210_cur."!mark_push"(0, rx1210_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."routine_def"()
    unless $P10, rx1210_fail
    rx1210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1210_pos = $P10."pos"()
    goto alt1217_end
  alt1217_2:
  # rx subrule "panic" subtype=method negate=
    rx1210_cur."!cursor_pos"(rx1210_pos)
    $P10 = rx1210_cur."panic"("Malformed proto")
    unless $P10, rx1210_fail
    rx1210_pos = $P10."pos"()
  alt1217_end:
.annotate 'line', 460
  # rx pass
    rx1210_cur."!cursor_pass"(rx1210_pos, "multi_declarator:sym<proto>")
    if_null rx1210_debug, debug_1032
    rx1210_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1210_pos)
  debug_1032:
    .return (rx1210_cur)
  rx1210_restart:
.annotate 'line', 10
    if_null rx1210_debug, debug_1033
    rx1210_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1033:
  rx1210_fail:
    (rx1210_rep, rx1210_pos, $I10, $P10) = rx1210_cur."!mark_fail"(0)
    lt rx1210_pos, -1, rx1210_done
    eq rx1210_pos, -1, rx1210_fail
    jump $I10
  rx1210_done:
    rx1210_cur."!cursor_fail"()
    if_null rx1210_debug, debug_1034
    rx1210_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1034:
    .return (rx1210_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("191_1303923618.727") :method
.annotate 'line', 10
    $P1212 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1213, "ResizablePMCArray"
    push $P1213, $P1212
    .return ($P1213)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("192_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 466
    new $P1219, "Undef"
    .lex "$*MULTINESS", $P1219
.annotate 'line', 10
    .local string rx1220_tgt
    .local int rx1220_pos
    .local int rx1220_off
    .local int rx1220_eos
    .local int rx1220_rep
    .local pmc rx1220_cur
    .local pmc rx1220_debug
    (rx1220_cur, rx1220_pos, rx1220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1220_cur
    .local pmc match
    .lex "$/", match
    length rx1220_eos, rx1220_tgt
    gt rx1220_pos, rx1220_eos, rx1220_done
    set rx1220_off, 0
    lt rx1220_pos, 2, rx1220_start
    sub rx1220_off, rx1220_pos, 1
    substr rx1220_tgt, rx1220_tgt, rx1220_off
  rx1220_start:
    eq $I10, 1, rx1220_restart
    if_null rx1220_debug, debug_1035
    rx1220_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1035:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1220_pos) = rx1220_cur."from"()
    inc rx1220_pos
    rx1220_cur."!cursor_from"(rx1220_pos)
    ge rx1220_pos, rx1220_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1220_cur."!mark_push"(0, rx1220_pos, $I10)
  rxscan1224_done:
.annotate 'line', 466
    rx1220_cur."!cursor_pos"(rx1220_pos)
    new $P1225, "String"
    assign $P1225, ""
    store_lex "$*MULTINESS", $P1225
.annotate 'line', 467
  # rx subrule "declarator" subtype=capture negate=
    rx1220_cur."!cursor_pos"(rx1220_pos)
    $P10 = rx1220_cur."declarator"()
    unless $P10, rx1220_fail
    rx1220_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1220_pos = $P10."pos"()
.annotate 'line', 465
  # rx pass
    rx1220_cur."!cursor_pass"(rx1220_pos, "multi_declarator:sym<null>")
    if_null rx1220_debug, debug_1036
    rx1220_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1220_pos)
  debug_1036:
    .return (rx1220_cur)
  rx1220_restart:
.annotate 'line', 10
    if_null rx1220_debug, debug_1037
    rx1220_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1037:
  rx1220_fail:
    (rx1220_rep, rx1220_pos, $I10, $P10) = rx1220_cur."!mark_fail"(0)
    lt rx1220_pos, -1, rx1220_done
    eq rx1220_pos, -1, rx1220_fail
    jump $I10
  rx1220_done:
    rx1220_cur."!cursor_fail"()
    if_null rx1220_debug, debug_1038
    rx1220_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1038:
    .return (rx1220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("193_1303923618.727") :method
.annotate 'line', 10
    $P1222 = self."!PREFIX__!subrule"("declarator", "")
    new $P1223, "ResizablePMCArray"
    push $P1223, $P1222
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("194_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P1235 = "196_1303923618.727" 
    capture_lex $P1235
    .local string rx1227_tgt
    .local int rx1227_pos
    .local int rx1227_off
    .local int rx1227_eos
    .local int rx1227_rep
    .local pmc rx1227_cur
    .local pmc rx1227_debug
    (rx1227_cur, rx1227_pos, rx1227_tgt, $I10) = self."!cursor_start"()
    rx1227_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1227_cur
    .local pmc match
    .lex "$/", match
    length rx1227_eos, rx1227_tgt
    gt rx1227_pos, rx1227_eos, rx1227_done
    set rx1227_off, 0
    lt rx1227_pos, 2, rx1227_start
    sub rx1227_off, rx1227_pos, 1
    substr rx1227_tgt, rx1227_tgt, rx1227_off
  rx1227_start:
    eq $I10, 1, rx1227_restart
    if_null rx1227_debug, debug_1039
    rx1227_cur."!cursor_debug"("START", "signature")
  debug_1039:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1230_done
    goto rxscan1230_scan
  rxscan1230_loop:
    (rx1227_pos) = rx1227_cur."from"()
    inc rx1227_pos
    rx1227_cur."!cursor_from"(rx1227_pos)
    ge rx1227_pos, rx1227_eos, rxscan1230_done
  rxscan1230_scan:
    set_addr $I10, rxscan1230_loop
    rx1227_cur."!mark_push"(0, rx1227_pos, $I10)
  rxscan1230_done:
.annotate 'line', 471
  # rx rxquantr1231 ** 0..1
    set_addr $I10, rxquantr1231_done
    rx1227_cur."!mark_push"(0, rx1227_pos, $I10)
  rxquantr1231_loop:
    rx1227_cur."!cursor_pos"(rx1227_pos)
    find_lex $P1232, unicode:"$\x{a2}"
    $P1233 = $P1232."MATCH"()
    store_lex "$/", $P1233
    .const 'Sub' $P1235 = "196_1303923618.727" 
    capture_lex $P1235
    $P1239 = $P1235()
    unless $P1239, rx1227_fail
  # rx subrule "ws" subtype=method negate=
    rx1227_cur."!cursor_pos"(rx1227_pos)
    $P10 = rx1227_cur."ws"()
    unless $P10, rx1227_fail
    rx1227_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1227_cur."!cursor_pos"(rx1227_pos)
    $P10 = rx1227_cur."parameter"()
    unless $P10, rx1227_fail
    rx1227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1227_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1227_cur."!cursor_pos"(rx1227_pos)
    $P10 = rx1227_cur."ws"()
    unless $P10, rx1227_fail
    rx1227_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1227_pos, 1
    gt $I11, rx1227_eos, rx1227_fail
    sub $I11, rx1227_pos, rx1227_off
    ord $I11, rx1227_tgt, $I11
    ne $I11, 58, rx1227_fail
    add rx1227_pos, 1
    set_addr $I10, rxquantr1231_done
    (rx1227_rep) = rx1227_cur."!mark_commit"($I10)
  rxquantr1231_done:
.annotate 'line', 472
  # rx rxquantr1240 ** 0..1
    set_addr $I10, rxquantr1240_done
    rx1227_cur."!mark_push"(0, rx1227_pos, $I10)
  rxquantr1240_loop:
  # rx rxquantr1241 ** 1..*
    set_addr $I10, rxquantr1241_done
    rx1227_cur."!mark_push"(0, -1, $I10)
  rxquantr1241_loop:
  # rx subrule "ws" subtype=method negate=
    rx1227_cur."!cursor_pos"(rx1227_pos)
    $P10 = rx1227_cur."ws"()
    unless $P10, rx1227_fail
    rx1227_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1227_cur."!cursor_pos"(rx1227_pos)
    $P10 = rx1227_cur."parameter"()
    unless $P10, rx1227_fail
    rx1227_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1227_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1227_cur."!cursor_pos"(rx1227_pos)
    $P10 = rx1227_cur."ws"()
    unless $P10, rx1227_fail
    rx1227_pos = $P10."pos"()
    set_addr $I10, rxquantr1241_done
    (rx1227_rep) = rx1227_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1241_done
    rx1227_cur."!mark_push"(rx1227_rep, rx1227_pos, $I10)
  # rx literal  ","
    add $I11, rx1227_pos, 1
    gt $I11, rx1227_eos, rx1227_fail
    sub $I11, rx1227_pos, rx1227_off
    ord $I11, rx1227_tgt, $I11
    ne $I11, 44, rx1227_fail
    add rx1227_pos, 1
    goto rxquantr1241_loop
  rxquantr1241_done:
    set_addr $I10, rxquantr1240_done
    (rx1227_rep) = rx1227_cur."!mark_commit"($I10)
  rxquantr1240_done:
.annotate 'line', 470
  # rx pass
    rx1227_cur."!cursor_pass"(rx1227_pos, "signature")
    if_null rx1227_debug, debug_1042
    rx1227_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1227_pos)
  debug_1042:
    .return (rx1227_cur)
  rx1227_restart:
.annotate 'line', 10
    if_null rx1227_debug, debug_1043
    rx1227_cur."!cursor_debug"("NEXT", "signature")
  debug_1043:
  rx1227_fail:
    (rx1227_rep, rx1227_pos, $I10, $P10) = rx1227_cur."!mark_fail"(0)
    lt rx1227_pos, -1, rx1227_done
    eq rx1227_pos, -1, rx1227_fail
    jump $I10
  rx1227_done:
    rx1227_cur."!cursor_fail"()
    if_null rx1227_debug, debug_1044
    rx1227_cur."!cursor_debug"("FAIL", "signature")
  debug_1044:
    .return (rx1227_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("195_1303923618.727") :method
.annotate 'line', 10
    new $P1229, "ResizablePMCArray"
    push $P1229, ""
    .return ($P1229)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1234"  :anon :subid("196_1303923618.727") :outer("194_1303923618.727")
.annotate 'line', 471
    find_dynamic_lex $P1238, "$*INVOCANT_OK"
    unless_null $P1238, vivify_1040
    get_hll_global $P1236, "GLOBAL"
    get_who $P1237, $P1236
    set $P1238, $P1237["$INVOCANT_OK"]
    unless_null $P1238, vivify_1041
    die "Contextual $*INVOCANT_OK not found"
  vivify_1041:
  vivify_1040:
    .return ($P1238)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("197_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1243_tgt
    .local int rx1243_pos
    .local int rx1243_off
    .local int rx1243_eos
    .local int rx1243_rep
    .local pmc rx1243_cur
    .local pmc rx1243_debug
    (rx1243_cur, rx1243_pos, rx1243_tgt, $I10) = self."!cursor_start"()
    rx1243_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1243_cur
    .local pmc match
    .lex "$/", match
    length rx1243_eos, rx1243_tgt
    gt rx1243_pos, rx1243_eos, rx1243_done
    set rx1243_off, 0
    lt rx1243_pos, 2, rx1243_start
    sub rx1243_off, rx1243_pos, 1
    substr rx1243_tgt, rx1243_tgt, rx1243_off
  rx1243_start:
    eq $I10, 1, rx1243_restart
    if_null rx1243_debug, debug_1045
    rx1243_cur."!cursor_debug"("START", "parameter")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1246_done
    goto rxscan1246_scan
  rxscan1246_loop:
    (rx1243_pos) = rx1243_cur."from"()
    inc rx1243_pos
    rx1243_cur."!cursor_from"(rx1243_pos)
    ge rx1243_pos, rx1243_eos, rxscan1246_done
  rxscan1246_scan:
    set_addr $I10, rxscan1246_loop
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxscan1246_done:
.annotate 'line', 476
  # rx rxquantr1247 ** 0..*
    set_addr $I10, rxquantr1247_done
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxquantr1247_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."typename"()
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1243_pos = $P10."pos"()
  # rx rxquantr1248 ** 0..1
    set_addr $I10, rxquantr1248_done
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxquantr1248_loop:
  # rx literal  ":"
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 58, rx1243_fail
    add rx1243_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1249_fail
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1243_pos, rx1243_eos, rx1243_fail
    sub $I10, rx1243_pos, rx1243_off
    substr $S10, rx1243_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1243_fail
    inc rx1243_pos
    set_addr $I10, rxcap_1249_fail
    ($I12, $I11) = rx1243_cur."!mark_peek"($I10)
    rx1243_cur."!cursor_pos"($I11)
    ($P10) = rx1243_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1243_pos, "")
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1249_done
  rxcap_1249_fail:
    goto rx1243_fail
  rxcap_1249_done:
    set_addr $I10, rxquantr1248_done
    (rx1243_rep) = rx1243_cur."!mark_commit"($I10)
  rxquantr1248_done:
  # rx subrule "ws" subtype=method negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."ws"()
    unless $P10, rx1243_fail
    rx1243_pos = $P10."pos"()
    set_addr $I10, rxquantr1247_done
    (rx1243_rep) = rx1243_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1247_done
    rx1243_cur."!mark_push"(rx1243_rep, rx1243_pos, $I10)
    goto rxquantr1247_loop
  rxquantr1247_done:
  alt1250_0:
.annotate 'line', 477
    set_addr $I10, alt1250_1
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
.annotate 'line', 478
  # rx subcapture "quant"
    set_addr $I10, rxcap_1251_fail
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  # rx literal  "*"
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 42, rx1243_fail
    add rx1243_pos, 1
    set_addr $I10, rxcap_1251_fail
    ($I12, $I11) = rx1243_cur."!mark_peek"($I10)
    rx1243_cur."!cursor_pos"($I11)
    ($P10) = rx1243_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1243_pos, "")
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1251_done
  rxcap_1251_fail:
    goto rx1243_fail
  rxcap_1251_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."param_var"()
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1243_pos = $P10."pos"()
    goto alt1250_end
  alt1250_1:
  alt1252_0:
.annotate 'line', 479
    set_addr $I10, alt1252_1
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."param_var"()
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1243_pos = $P10."pos"()
    goto alt1252_end
  alt1252_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."named_param"()
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1243_pos = $P10."pos"()
  alt1252_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1254_fail
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  alt1253_0:
    set_addr $I10, alt1253_1
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  # rx literal  "?"
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 63, rx1243_fail
    add rx1243_pos, 1
    goto alt1253_end
  alt1253_1:
    set_addr $I10, alt1253_2
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  # rx literal  "!"
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 33, rx1243_fail
    add rx1243_pos, 1
    goto alt1253_end
  alt1253_2:
  alt1253_end:
    set_addr $I10, rxcap_1254_fail
    ($I12, $I11) = rx1243_cur."!mark_peek"($I10)
    rx1243_cur."!cursor_pos"($I11)
    ($P10) = rx1243_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1243_pos, "")
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1254_done
  rxcap_1254_fail:
    goto rx1243_fail
  rxcap_1254_done:
  alt1250_end:
.annotate 'line', 481
  # rx rxquantr1255 ** 0..1
    set_addr $I10, rxquantr1255_done
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxquantr1255_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."default_value"()
    unless $P10, rx1243_fail
    goto rxsubrule1256_pass
  rxsubrule1256_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1243_fail
  rxsubrule1256_pass:
    set_addr $I10, rxsubrule1256_back
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1243_pos = $P10."pos"()
    set_addr $I10, rxquantr1255_done
    (rx1243_rep) = rx1243_cur."!mark_commit"($I10)
  rxquantr1255_done:
.annotate 'line', 475
  # rx pass
    rx1243_cur."!cursor_pass"(rx1243_pos, "parameter")
    if_null rx1243_debug, debug_1046
    rx1243_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1243_pos)
  debug_1046:
    .return (rx1243_cur)
  rx1243_restart:
.annotate 'line', 10
    if_null rx1243_debug, debug_1047
    rx1243_cur."!cursor_debug"("NEXT", "parameter")
  debug_1047:
  rx1243_fail:
    (rx1243_rep, rx1243_pos, $I10, $P10) = rx1243_cur."!mark_fail"(0)
    lt rx1243_pos, -1, rx1243_done
    eq rx1243_pos, -1, rx1243_fail
    jump $I10
  rx1243_done:
    rx1243_cur."!cursor_fail"()
    if_null rx1243_debug, debug_1048
    rx1243_cur."!cursor_debug"("FAIL", "parameter")
  debug_1048:
    .return (rx1243_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("198_1303923618.727") :method
.annotate 'line', 10
    new $P1245, "ResizablePMCArray"
    push $P1245, ""
    .return ($P1245)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("199_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1258_tgt
    .local int rx1258_pos
    .local int rx1258_off
    .local int rx1258_eos
    .local int rx1258_rep
    .local pmc rx1258_cur
    .local pmc rx1258_debug
    (rx1258_cur, rx1258_pos, rx1258_tgt, $I10) = self."!cursor_start"()
    rx1258_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1258_cur
    .local pmc match
    .lex "$/", match
    length rx1258_eos, rx1258_tgt
    gt rx1258_pos, rx1258_eos, rx1258_done
    set rx1258_off, 0
    lt rx1258_pos, 2, rx1258_start
    sub rx1258_off, rx1258_pos, 1
    substr rx1258_tgt, rx1258_tgt, rx1258_off
  rx1258_start:
    eq $I10, 1, rx1258_restart
    if_null rx1258_debug, debug_1049
    rx1258_cur."!cursor_debug"("START", "param_var")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1262_done
    goto rxscan1262_scan
  rxscan1262_loop:
    (rx1258_pos) = rx1258_cur."from"()
    inc rx1258_pos
    rx1258_cur."!cursor_from"(rx1258_pos)
    ge rx1258_pos, rx1258_eos, rxscan1262_done
  rxscan1262_scan:
    set_addr $I10, rxscan1262_loop
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxscan1262_done:
.annotate 'line', 485
  # rx subrule "sigil" subtype=capture negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."sigil"()
    unless $P10, rx1258_fail
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1258_pos = $P10."pos"()
  # rx rxquantr1263 ** 0..1
    set_addr $I10, rxquantr1263_done
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxquantr1263_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."twigil"()
    unless $P10, rx1258_fail
    goto rxsubrule1264_pass
  rxsubrule1264_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1258_fail
  rxsubrule1264_pass:
    set_addr $I10, rxsubrule1264_back
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1258_pos = $P10."pos"()
    set_addr $I10, rxquantr1263_done
    (rx1258_rep) = rx1258_cur."!mark_commit"($I10)
  rxquantr1263_done:
  alt1265_0:
.annotate 'line', 486
    set_addr $I10, alt1265_1
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."ident"()
    unless $P10, rx1258_fail
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1258_pos = $P10."pos"()
    goto alt1265_end
  alt1265_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1266_fail
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1258_pos, rx1258_eos, rx1258_fail
    sub $I10, rx1258_pos, rx1258_off
    substr $S10, rx1258_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1258_fail
    inc rx1258_pos
    set_addr $I10, rxcap_1266_fail
    ($I12, $I11) = rx1258_cur."!mark_peek"($I10)
    rx1258_cur."!cursor_pos"($I11)
    ($P10) = rx1258_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1258_pos, "")
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1266_done
  rxcap_1266_fail:
    goto rx1258_fail
  rxcap_1266_done:
  alt1265_end:
.annotate 'line', 484
  # rx pass
    rx1258_cur."!cursor_pass"(rx1258_pos, "param_var")
    if_null rx1258_debug, debug_1050
    rx1258_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1258_pos)
  debug_1050:
    .return (rx1258_cur)
  rx1258_restart:
.annotate 'line', 10
    if_null rx1258_debug, debug_1051
    rx1258_cur."!cursor_debug"("NEXT", "param_var")
  debug_1051:
  rx1258_fail:
    (rx1258_rep, rx1258_pos, $I10, $P10) = rx1258_cur."!mark_fail"(0)
    lt rx1258_pos, -1, rx1258_done
    eq rx1258_pos, -1, rx1258_fail
    jump $I10
  rx1258_done:
    rx1258_cur."!cursor_fail"()
    if_null rx1258_debug, debug_1052
    rx1258_cur."!cursor_debug"("FAIL", "param_var")
  debug_1052:
    .return (rx1258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("200_1303923618.727") :method
.annotate 'line', 10
    $P1260 = self."!PREFIX__!subrule"("sigil", "")
    new $P1261, "ResizablePMCArray"
    push $P1261, $P1260
    .return ($P1261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("201_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1268_tgt
    .local int rx1268_pos
    .local int rx1268_off
    .local int rx1268_eos
    .local int rx1268_rep
    .local pmc rx1268_cur
    .local pmc rx1268_debug
    (rx1268_cur, rx1268_pos, rx1268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1268_cur
    .local pmc match
    .lex "$/", match
    length rx1268_eos, rx1268_tgt
    gt rx1268_pos, rx1268_eos, rx1268_done
    set rx1268_off, 0
    lt rx1268_pos, 2, rx1268_start
    sub rx1268_off, rx1268_pos, 1
    substr rx1268_tgt, rx1268_tgt, rx1268_off
  rx1268_start:
    eq $I10, 1, rx1268_restart
    if_null rx1268_debug, debug_1053
    rx1268_cur."!cursor_debug"("START", "named_param")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1272_done
    goto rxscan1272_scan
  rxscan1272_loop:
    (rx1268_pos) = rx1268_cur."from"()
    inc rx1268_pos
    rx1268_cur."!cursor_from"(rx1268_pos)
    ge rx1268_pos, rx1268_eos, rxscan1272_done
  rxscan1272_scan:
    set_addr $I10, rxscan1272_loop
    rx1268_cur."!mark_push"(0, rx1268_pos, $I10)
  rxscan1272_done:
.annotate 'line', 490
  # rx literal  ":"
    add $I11, rx1268_pos, 1
    gt $I11, rx1268_eos, rx1268_fail
    sub $I11, rx1268_pos, rx1268_off
    ord $I11, rx1268_tgt, $I11
    ne $I11, 58, rx1268_fail
    add rx1268_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1268_cur."!cursor_pos"(rx1268_pos)
    $P10 = rx1268_cur."param_var"()
    unless $P10, rx1268_fail
    rx1268_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1268_pos = $P10."pos"()
.annotate 'line', 489
  # rx pass
    rx1268_cur."!cursor_pass"(rx1268_pos, "named_param")
    if_null rx1268_debug, debug_1054
    rx1268_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1268_pos)
  debug_1054:
    .return (rx1268_cur)
  rx1268_restart:
.annotate 'line', 10
    if_null rx1268_debug, debug_1055
    rx1268_cur."!cursor_debug"("NEXT", "named_param")
  debug_1055:
  rx1268_fail:
    (rx1268_rep, rx1268_pos, $I10, $P10) = rx1268_cur."!mark_fail"(0)
    lt rx1268_pos, -1, rx1268_done
    eq rx1268_pos, -1, rx1268_fail
    jump $I10
  rx1268_done:
    rx1268_cur."!cursor_fail"()
    if_null rx1268_debug, debug_1056
    rx1268_cur."!cursor_debug"("FAIL", "named_param")
  debug_1056:
    .return (rx1268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("202_1303923618.727") :method
.annotate 'line', 10
    $P1270 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1271, "ResizablePMCArray"
    push $P1271, $P1270
    .return ($P1271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("203_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1274_tgt
    .local int rx1274_pos
    .local int rx1274_off
    .local int rx1274_eos
    .local int rx1274_rep
    .local pmc rx1274_cur
    .local pmc rx1274_debug
    (rx1274_cur, rx1274_pos, rx1274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1274_cur
    .local pmc match
    .lex "$/", match
    length rx1274_eos, rx1274_tgt
    gt rx1274_pos, rx1274_eos, rx1274_done
    set rx1274_off, 0
    lt rx1274_pos, 2, rx1274_start
    sub rx1274_off, rx1274_pos, 1
    substr rx1274_tgt, rx1274_tgt, rx1274_off
  rx1274_start:
    eq $I10, 1, rx1274_restart
    if_null rx1274_debug, debug_1057
    rx1274_cur."!cursor_debug"("START", "default_value")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1278_done
    goto rxscan1278_scan
  rxscan1278_loop:
    (rx1274_pos) = rx1274_cur."from"()
    inc rx1274_pos
    rx1274_cur."!cursor_from"(rx1274_pos)
    ge rx1274_pos, rx1274_eos, rxscan1278_done
  rxscan1278_scan:
    set_addr $I10, rxscan1278_loop
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  rxscan1278_done:
.annotate 'line', 493
  # rx subrule "ws" subtype=method negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."ws"()
    unless $P10, rx1274_fail
    rx1274_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1274_pos, 1
    gt $I11, rx1274_eos, rx1274_fail
    sub $I11, rx1274_pos, rx1274_off
    ord $I11, rx1274_tgt, $I11
    ne $I11, 61, rx1274_fail
    add rx1274_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."ws"()
    unless $P10, rx1274_fail
    rx1274_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."EXPR"("i=")
    unless $P10, rx1274_fail
    rx1274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1274_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."ws"()
    unless $P10, rx1274_fail
    rx1274_pos = $P10."pos"()
  # rx pass
    rx1274_cur."!cursor_pass"(rx1274_pos, "default_value")
    if_null rx1274_debug, debug_1058
    rx1274_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1274_pos)
  debug_1058:
    .return (rx1274_cur)
  rx1274_restart:
.annotate 'line', 10
    if_null rx1274_debug, debug_1059
    rx1274_cur."!cursor_debug"("NEXT", "default_value")
  debug_1059:
  rx1274_fail:
    (rx1274_rep, rx1274_pos, $I10, $P10) = rx1274_cur."!mark_fail"(0)
    lt rx1274_pos, -1, rx1274_done
    eq rx1274_pos, -1, rx1274_fail
    jump $I10
  rx1274_done:
    rx1274_cur."!cursor_fail"()
    if_null rx1274_debug, debug_1060
    rx1274_cur."!cursor_debug"("FAIL", "default_value")
  debug_1060:
    .return (rx1274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("204_1303923618.727") :method
.annotate 'line', 10
    $P1276 = self."!PREFIX__!subrule"("ws", "")
    new $P1277, "ResizablePMCArray"
    push $P1277, $P1276
    .return ($P1277)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("205_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1283_tgt
    .local int rx1283_pos
    .local int rx1283_off
    .local int rx1283_eos
    .local int rx1283_rep
    .local pmc rx1283_cur
    .local pmc rx1283_debug
    (rx1283_cur, rx1283_pos, rx1283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1283_cur
    .local pmc match
    .lex "$/", match
    length rx1283_eos, rx1283_tgt
    gt rx1283_pos, rx1283_eos, rx1283_done
    set rx1283_off, 0
    lt rx1283_pos, 2, rx1283_start
    sub rx1283_off, rx1283_pos, 1
    substr rx1283_tgt, rx1283_tgt, rx1283_off
  rx1283_start:
    eq $I10, 1, rx1283_restart
    if_null rx1283_debug, debug_1061
    rx1283_cur."!cursor_debug"("START", "trait")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1287_done
    goto rxscan1287_scan
  rxscan1287_loop:
    (rx1283_pos) = rx1283_cur."from"()
    inc rx1283_pos
    rx1283_cur."!cursor_from"(rx1283_pos)
    ge rx1283_pos, rx1283_eos, rxscan1287_done
  rxscan1287_scan:
    set_addr $I10, rxscan1287_loop
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  rxscan1287_done:
.annotate 'line', 495
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."trait_mod"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx pass
    rx1283_cur."!cursor_pass"(rx1283_pos, "trait")
    if_null rx1283_debug, debug_1062
    rx1283_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1283_pos)
  debug_1062:
    .return (rx1283_cur)
  rx1283_restart:
.annotate 'line', 10
    if_null rx1283_debug, debug_1063
    rx1283_cur."!cursor_debug"("NEXT", "trait")
  debug_1063:
  rx1283_fail:
    (rx1283_rep, rx1283_pos, $I10, $P10) = rx1283_cur."!mark_fail"(0)
    lt rx1283_pos, -1, rx1283_done
    eq rx1283_pos, -1, rx1283_fail
    jump $I10
  rx1283_done:
    rx1283_cur."!cursor_fail"()
    if_null rx1283_debug, debug_1064
    rx1283_cur."!cursor_debug"("FAIL", "trait")
  debug_1064:
    .return (rx1283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("206_1303923618.727") :method
.annotate 'line', 10
    $P1285 = self."!PREFIX__!subrule"("ws", "")
    new $P1286, "ResizablePMCArray"
    push $P1286, $P1285
    .return ($P1286)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("207_1303923618.727")
    .param pmc param_1291
.annotate 'line', 497
    .lex "self", param_1291
    $P1292 = param_1291."!protoregex"("trait_mod")
    .return ($P1292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("208_1303923618.727")
    .param pmc param_1294
.annotate 'line', 497
    .lex "self", param_1294
    $P1295 = param_1294."!PREFIX__!protoregex"("trait_mod")
    .return ($P1295)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("209_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1297_tgt
    .local int rx1297_pos
    .local int rx1297_off
    .local int rx1297_eos
    .local int rx1297_rep
    .local pmc rx1297_cur
    .local pmc rx1297_debug
    (rx1297_cur, rx1297_pos, rx1297_tgt, $I10) = self."!cursor_start"()
    rx1297_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1297_cur
    .local pmc match
    .lex "$/", match
    length rx1297_eos, rx1297_tgt
    gt rx1297_pos, rx1297_eos, rx1297_done
    set rx1297_off, 0
    lt rx1297_pos, 2, rx1297_start
    sub rx1297_off, rx1297_pos, 1
    substr rx1297_tgt, rx1297_tgt, rx1297_off
  rx1297_start:
    eq $I10, 1, rx1297_restart
    if_null rx1297_debug, debug_1065
    rx1297_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1301_done
    goto rxscan1301_scan
  rxscan1301_loop:
    (rx1297_pos) = rx1297_cur."from"()
    inc rx1297_pos
    rx1297_cur."!cursor_from"(rx1297_pos)
    ge rx1297_pos, rx1297_eos, rxscan1301_done
  rxscan1301_scan:
    set_addr $I10, rxscan1301_loop
    rx1297_cur."!mark_push"(0, rx1297_pos, $I10)
  rxscan1301_done:
.annotate 'line', 498
  # rx subcapture "sym"
    set_addr $I10, rxcap_1302_fail
    rx1297_cur."!mark_push"(0, rx1297_pos, $I10)
  # rx literal  "is"
    add $I11, rx1297_pos, 2
    gt $I11, rx1297_eos, rx1297_fail
    sub $I11, rx1297_pos, rx1297_off
    substr $S10, rx1297_tgt, $I11, 2
    ne $S10, "is", rx1297_fail
    add rx1297_pos, 2
    set_addr $I10, rxcap_1302_fail
    ($I12, $I11) = rx1297_cur."!mark_peek"($I10)
    rx1297_cur."!cursor_pos"($I11)
    ($P10) = rx1297_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1297_pos, "")
    rx1297_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1302_done
  rxcap_1302_fail:
    goto rx1297_fail
  rxcap_1302_done:
  # rx subrule "ws" subtype=method negate=
    rx1297_cur."!cursor_pos"(rx1297_pos)
    $P10 = rx1297_cur."ws"()
    unless $P10, rx1297_fail
    rx1297_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1297_cur."!cursor_pos"(rx1297_pos)
    $P10 = rx1297_cur."deflongname"()
    unless $P10, rx1297_fail
    rx1297_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1297_pos = $P10."pos"()
  # rx rxquantr1304 ** 0..1
    set_addr $I10, rxquantr1304_done
    rx1297_cur."!mark_push"(0, rx1297_pos, $I10)
  rxquantr1304_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1297_cur."!cursor_pos"(rx1297_pos)
    $P10 = rx1297_cur."circumfix"()
    unless $P10, rx1297_fail
    goto rxsubrule1305_pass
  rxsubrule1305_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1297_fail
  rxsubrule1305_pass:
    set_addr $I10, rxsubrule1305_back
    rx1297_cur."!mark_push"(0, rx1297_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1297_pos = $P10."pos"()
    set_addr $I10, rxquantr1304_done
    (rx1297_rep) = rx1297_cur."!mark_commit"($I10)
  rxquantr1304_done:
  # rx subrule "ws" subtype=method negate=
    rx1297_cur."!cursor_pos"(rx1297_pos)
    $P10 = rx1297_cur."ws"()
    unless $P10, rx1297_fail
    rx1297_pos = $P10."pos"()
  # rx pass
    rx1297_cur."!cursor_pass"(rx1297_pos, "trait_mod:sym<is>")
    if_null rx1297_debug, debug_1066
    rx1297_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1297_pos)
  debug_1066:
    .return (rx1297_cur)
  rx1297_restart:
.annotate 'line', 10
    if_null rx1297_debug, debug_1067
    rx1297_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1067:
  rx1297_fail:
    (rx1297_rep, rx1297_pos, $I10, $P10) = rx1297_cur."!mark_fail"(0)
    lt rx1297_pos, -1, rx1297_done
    eq rx1297_pos, -1, rx1297_fail
    jump $I10
  rx1297_done:
    rx1297_cur."!cursor_fail"()
    if_null rx1297_debug, debug_1068
    rx1297_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1068:
    .return (rx1297_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("210_1303923618.727") :method
.annotate 'line', 10
    $P1299 = self."!PREFIX__!subrule"("ws", "is")
    new $P1300, "ResizablePMCArray"
    push $P1300, $P1299
    .return ($P1300)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("211_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1308_tgt
    .local int rx1308_pos
    .local int rx1308_off
    .local int rx1308_eos
    .local int rx1308_rep
    .local pmc rx1308_cur
    .local pmc rx1308_debug
    (rx1308_cur, rx1308_pos, rx1308_tgt, $I10) = self."!cursor_start"()
    rx1308_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1308_cur
    .local pmc match
    .lex "$/", match
    length rx1308_eos, rx1308_tgt
    gt rx1308_pos, rx1308_eos, rx1308_done
    set rx1308_off, 0
    lt rx1308_pos, 2, rx1308_start
    sub rx1308_off, rx1308_pos, 1
    substr rx1308_tgt, rx1308_tgt, rx1308_off
  rx1308_start:
    eq $I10, 1, rx1308_restart
    if_null rx1308_debug, debug_1069
    rx1308_cur."!cursor_debug"("START", "regex_declarator")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1312_done
    goto rxscan1312_scan
  rxscan1312_loop:
    (rx1308_pos) = rx1308_cur."from"()
    inc rx1308_pos
    rx1308_cur."!cursor_from"(rx1308_pos)
    ge rx1308_pos, rx1308_eos, rxscan1312_done
  rxscan1312_scan:
    set_addr $I10, rxscan1312_loop
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  rxscan1312_done:
.annotate 'line', 500
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  alt1314_0:
.annotate 'line', 501
    set_addr $I10, alt1314_1
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
.annotate 'line', 502
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1316_fail
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1308_pos, 5
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 5
    ne $S10, "proto", rx1308_fail
    add rx1308_pos, 5
    set_addr $I10, rxcap_1316_fail
    ($I12, $I11) = rx1308_cur."!mark_peek"($I10)
    rx1308_cur."!cursor_pos"($I11)
    ($P10) = rx1308_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1308_pos, "")
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1316_done
  rxcap_1316_fail:
    goto rx1308_fail
  rxcap_1316_done:
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  alt1318_0:
    set_addr $I10, alt1318_1
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1308_pos, 5
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 5
    ne $S10, "regex", rx1308_fail
    add rx1308_pos, 5
    goto alt1318_end
  alt1318_1:
    set_addr $I10, alt1318_2
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  # rx literal  "token"
    add $I11, rx1308_pos, 5
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 5
    ne $S10, "token", rx1308_fail
    add rx1308_pos, 5
    goto alt1318_end
  alt1318_2:
  # rx literal  "rule"
    add $I11, rx1308_pos, 4
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 4
    ne $S10, "rule", rx1308_fail
    add rx1308_pos, 4
  alt1318_end:
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
.annotate 'line', 503
  # rx subrule "deflongname" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."deflongname"()
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1308_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  alt1321_0:
.annotate 'line', 504
    set_addr $I10, alt1321_1
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 123, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1308_pos, 5
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 5
    ne $S10, "<...>", rx1308_fail
    add rx1308_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 125, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ENDSTMT"()
    unless $P10, rx1308_fail
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
    goto alt1321_end
  alt1321_1:
    set_addr $I10, alt1321_2
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
.annotate 'line', 506
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 123, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1308_pos, 3
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 3
    ne $S10, "<*>", rx1308_fail
    add rx1308_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 125, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ENDSTMT"()
    unless $P10, rx1308_fail
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
    goto alt1321_end
  alt1321_2:
.annotate 'line', 507
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  alt1321_end:
.annotate 'line', 508
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
.annotate 'line', 502
    goto alt1314_end
  alt1314_1:
.annotate 'line', 509
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1335_fail
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  alt1334_0:
    set_addr $I10, alt1334_1
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1308_pos, 5
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 5
    ne $S10, "regex", rx1308_fail
    add rx1308_pos, 5
    goto alt1334_end
  alt1334_1:
    set_addr $I10, alt1334_2
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  # rx literal  "token"
    add $I11, rx1308_pos, 5
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 5
    ne $S10, "token", rx1308_fail
    add rx1308_pos, 5
    goto alt1334_end
  alt1334_2:
  # rx literal  "rule"
    add $I11, rx1308_pos, 4
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    substr $S10, rx1308_tgt, $I11, 4
    ne $S10, "rule", rx1308_fail
    add rx1308_pos, 4
  alt1334_end:
    set_addr $I10, rxcap_1335_fail
    ($I12, $I11) = rx1308_cur."!mark_peek"($I10)
    rx1308_cur."!cursor_pos"($I11)
    ($P10) = rx1308_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1308_pos, "")
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1335_done
  rxcap_1335_fail:
    goto rx1308_fail
  rxcap_1335_done:
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
.annotate 'line', 510
  # rx subrule "deflongname" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."deflongname"()
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1308_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
.annotate 'line', 511
  # rx subrule "newpad" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."newpad"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
.annotate 'line', 512
  # rx rxquantr1339 ** 0..1
    set_addr $I10, rxquantr1339_done
    rx1308_cur."!mark_push"(0, rx1308_pos, $I10)
  rxquantr1339_loop:
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 40, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."signature"()
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1308_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 41, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
    set_addr $I10, rxquantr1339_done
    (rx1308_rep) = rx1308_cur."!mark_commit"($I10)
  rxquantr1339_done:
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
.annotate 'line', 513
  # rx reduce name="regex_declarator" key="open"
    rx1308_cur."!cursor_pos"(rx1308_pos)
    rx1308_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
.annotate 'line', 514
  # rx literal  "{"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 123, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1308_fail
    rx1308_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1308_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1308_pos, 1
    gt $I11, rx1308_eos, rx1308_fail
    sub $I11, rx1308_pos, rx1308_off
    ord $I11, rx1308_tgt, $I11
    ne $I11, 125, rx1308_fail
    add rx1308_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ENDSTMT"()
    unless $P10, rx1308_fail
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
  alt1314_end:
.annotate 'line', 515
  # rx subrule "ws" subtype=method negate=
    rx1308_cur."!cursor_pos"(rx1308_pos)
    $P10 = rx1308_cur."ws"()
    unless $P10, rx1308_fail
    rx1308_pos = $P10."pos"()
.annotate 'line', 500
  # rx pass
    rx1308_cur."!cursor_pass"(rx1308_pos, "regex_declarator")
    if_null rx1308_debug, debug_1070
    rx1308_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1308_pos)
  debug_1070:
    .return (rx1308_cur)
  rx1308_restart:
.annotate 'line', 10
    if_null rx1308_debug, debug_1071
    rx1308_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1071:
  rx1308_fail:
    (rx1308_rep, rx1308_pos, $I10, $P10) = rx1308_cur."!mark_fail"(0)
    lt rx1308_pos, -1, rx1308_done
    eq rx1308_pos, -1, rx1308_fail
    jump $I10
  rx1308_done:
    rx1308_cur."!cursor_fail"()
    if_null rx1308_debug, debug_1072
    rx1308_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1072:
    .return (rx1308_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("212_1303923618.727") :method
.annotate 'line', 10
    $P1310 = self."!PREFIX__!subrule"("ws", "")
    new $P1311, "ResizablePMCArray"
    push $P1311, $P1310
    .return ($P1311)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("213_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1349_tgt
    .local int rx1349_pos
    .local int rx1349_off
    .local int rx1349_eos
    .local int rx1349_rep
    .local pmc rx1349_cur
    .local pmc rx1349_debug
    (rx1349_cur, rx1349_pos, rx1349_tgt, $I10) = self."!cursor_start"()
    rx1349_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1349_cur
    .local pmc match
    .lex "$/", match
    length rx1349_eos, rx1349_tgt
    gt rx1349_pos, rx1349_eos, rx1349_done
    set rx1349_off, 0
    lt rx1349_pos, 2, rx1349_start
    sub rx1349_off, rx1349_pos, 1
    substr rx1349_tgt, rx1349_tgt, rx1349_off
  rx1349_start:
    eq $I10, 1, rx1349_restart
    if_null rx1349_debug, debug_1073
    rx1349_cur."!cursor_debug"("START", "dotty")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    (rx1349_pos) = rx1349_cur."from"()
    inc rx1349_pos
    rx1349_cur."!cursor_from"(rx1349_pos)
    ge rx1349_pos, rx1349_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  rxscan1353_done:
.annotate 'line', 519
  # rx literal  "."
    add $I11, rx1349_pos, 1
    gt $I11, rx1349_eos, rx1349_fail
    sub $I11, rx1349_pos, rx1349_off
    ord $I11, rx1349_tgt, $I11
    ne $I11, 46, rx1349_fail
    add rx1349_pos, 1
  alt1354_0:
.annotate 'line', 520
    set_addr $I10, alt1354_1
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."deflongname"()
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1349_pos = $P10."pos"()
    goto alt1354_end
  alt1354_1:
.annotate 'line', 521
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1349_pos, rx1349_off
    substr $S10, rx1349_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1349_fail
  # rx subrule "quote" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."quote"()
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1349_pos = $P10."pos"()
  alt1355_0:
.annotate 'line', 522
    set_addr $I10, alt1355_1
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1349_pos, rx1349_off
    substr $S10, rx1349_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1349_fail
    goto alt1355_end
  alt1355_1:
  # rx subrule "panic" subtype=method negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1349_fail
    rx1349_pos = $P10."pos"()
  alt1355_end:
  alt1354_end:
.annotate 'line', 528
  # rx rxquantr1356 ** 0..1
    set_addr $I10, rxquantr1356_done
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
  rxquantr1356_loop:
  alt1357_0:
.annotate 'line', 525
    set_addr $I10, alt1357_1
    rx1349_cur."!mark_push"(0, rx1349_pos, $I10)
.annotate 'line', 526
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1349_pos, rx1349_off
    substr $S10, rx1349_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1349_fail
  # rx subrule "args" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."args"()
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1349_pos = $P10."pos"()
    goto alt1357_end
  alt1357_1:
.annotate 'line', 527
  # rx literal  ":"
    add $I11, rx1349_pos, 1
    gt $I11, rx1349_eos, rx1349_fail
    sub $I11, rx1349_pos, rx1349_off
    ord $I11, rx1349_tgt, $I11
    ne $I11, 58, rx1349_fail
    add rx1349_pos, 1
  # rx charclass s
    ge rx1349_pos, rx1349_eos, rx1349_fail
    sub $I10, rx1349_pos, rx1349_off
    is_cclass $I11, 32, rx1349_tgt, $I10
    unless $I11, rx1349_fail
    inc rx1349_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1349_cur."!cursor_pos"(rx1349_pos)
    $P10 = rx1349_cur."arglist"()
    unless $P10, rx1349_fail
    rx1349_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1349_pos = $P10."pos"()
  alt1357_end:
.annotate 'line', 528
    set_addr $I10, rxquantr1356_done
    (rx1349_rep) = rx1349_cur."!mark_commit"($I10)
  rxquantr1356_done:
.annotate 'line', 518
  # rx pass
    rx1349_cur."!cursor_pass"(rx1349_pos, "dotty")
    if_null rx1349_debug, debug_1074
    rx1349_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1349_pos)
  debug_1074:
    .return (rx1349_cur)
  rx1349_restart:
.annotate 'line', 10
    if_null rx1349_debug, debug_1075
    rx1349_cur."!cursor_debug"("NEXT", "dotty")
  debug_1075:
  rx1349_fail:
    (rx1349_rep, rx1349_pos, $I10, $P10) = rx1349_cur."!mark_fail"(0)
    lt rx1349_pos, -1, rx1349_done
    eq rx1349_pos, -1, rx1349_fail
    jump $I10
  rx1349_done:
    rx1349_cur."!cursor_fail"()
    if_null rx1349_debug, debug_1076
    rx1349_cur."!cursor_debug"("FAIL", "dotty")
  debug_1076:
    .return (rx1349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("214_1303923618.727") :method
.annotate 'line', 10
    $P1351 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1352, "ResizablePMCArray"
    push $P1352, "'"
    push $P1352, "\""
    push $P1352, $P1351
    .return ($P1352)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("215_1303923618.727")
    .param pmc param_1359
.annotate 'line', 532
    .lex "self", param_1359
    $P1360 = param_1359."!protoregex"("term")
    .return ($P1360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("216_1303923618.727")
    .param pmc param_1362
.annotate 'line', 532
    .lex "self", param_1362
    $P1363 = param_1362."!PREFIX__!protoregex"("term")
    .return ($P1363)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("217_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1365_tgt
    .local int rx1365_pos
    .local int rx1365_off
    .local int rx1365_eos
    .local int rx1365_rep
    .local pmc rx1365_cur
    .local pmc rx1365_debug
    (rx1365_cur, rx1365_pos, rx1365_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1365_cur
    .local pmc match
    .lex "$/", match
    length rx1365_eos, rx1365_tgt
    gt rx1365_pos, rx1365_eos, rx1365_done
    set rx1365_off, 0
    lt rx1365_pos, 2, rx1365_start
    sub rx1365_off, rx1365_pos, 1
    substr rx1365_tgt, rx1365_tgt, rx1365_off
  rx1365_start:
    eq $I10, 1, rx1365_restart
    if_null rx1365_debug, debug_1077
    rx1365_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1368_done
    goto rxscan1368_scan
  rxscan1368_loop:
    (rx1365_pos) = rx1365_cur."from"()
    inc rx1365_pos
    rx1365_cur."!cursor_from"(rx1365_pos)
    ge rx1365_pos, rx1365_eos, rxscan1368_done
  rxscan1368_scan:
    set_addr $I10, rxscan1368_loop
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  rxscan1368_done:
.annotate 'line', 534
  # rx subcapture "sym"
    set_addr $I10, rxcap_1369_fail
    rx1365_cur."!mark_push"(0, rx1365_pos, $I10)
  # rx literal  "self"
    add $I11, rx1365_pos, 4
    gt $I11, rx1365_eos, rx1365_fail
    sub $I11, rx1365_pos, rx1365_off
    substr $S10, rx1365_tgt, $I11, 4
    ne $S10, "self", rx1365_fail
    add rx1365_pos, 4
    set_addr $I10, rxcap_1369_fail
    ($I12, $I11) = rx1365_cur."!mark_peek"($I10)
    rx1365_cur."!cursor_pos"($I11)
    ($P10) = rx1365_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1365_pos, "")
    rx1365_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1369_done
  rxcap_1369_fail:
    goto rx1365_fail
  rxcap_1369_done:
  # rxanchor rwb
    le rx1365_pos, 0, rx1365_fail
    sub $I10, rx1365_pos, rx1365_off
    is_cclass $I11, 8192, rx1365_tgt, $I10
    if $I11, rx1365_fail
    dec $I10
    is_cclass $I11, 8192, rx1365_tgt, $I10
    unless $I11, rx1365_fail
  # rx pass
    rx1365_cur."!cursor_pass"(rx1365_pos, "term:sym<self>")
    if_null rx1365_debug, debug_1078
    rx1365_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1365_pos)
  debug_1078:
    .return (rx1365_cur)
  rx1365_restart:
.annotate 'line', 10
    if_null rx1365_debug, debug_1079
    rx1365_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1079:
  rx1365_fail:
    (rx1365_rep, rx1365_pos, $I10, $P10) = rx1365_cur."!mark_fail"(0)
    lt rx1365_pos, -1, rx1365_done
    eq rx1365_pos, -1, rx1365_fail
    jump $I10
  rx1365_done:
    rx1365_cur."!cursor_fail"()
    if_null rx1365_debug, debug_1080
    rx1365_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1080:
    .return (rx1365_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("218_1303923618.727") :method
.annotate 'line', 10
    new $P1367, "ResizablePMCArray"
    push $P1367, "self"
    .return ($P1367)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("219_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1371_tgt
    .local int rx1371_pos
    .local int rx1371_off
    .local int rx1371_eos
    .local int rx1371_rep
    .local pmc rx1371_cur
    .local pmc rx1371_debug
    (rx1371_cur, rx1371_pos, rx1371_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1371_cur
    .local pmc match
    .lex "$/", match
    length rx1371_eos, rx1371_tgt
    gt rx1371_pos, rx1371_eos, rx1371_done
    set rx1371_off, 0
    lt rx1371_pos, 2, rx1371_start
    sub rx1371_off, rx1371_pos, 1
    substr rx1371_tgt, rx1371_tgt, rx1371_off
  rx1371_start:
    eq $I10, 1, rx1371_restart
    if_null rx1371_debug, debug_1081
    rx1371_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1375_done
    goto rxscan1375_scan
  rxscan1375_loop:
    (rx1371_pos) = rx1371_cur."from"()
    inc rx1371_pos
    rx1371_cur."!cursor_from"(rx1371_pos)
    ge rx1371_pos, rx1371_eos, rxscan1375_done
  rxscan1375_scan:
    set_addr $I10, rxscan1375_loop
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxscan1375_done:
.annotate 'line', 537
  # rx subrule "deflongname" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."deflongname"()
    unless $P10, rx1371_fail
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1371_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1371_pos, rx1371_off
    substr $S10, rx1371_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1371_fail
  # rx subrule "args" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."args"()
    unless $P10, rx1371_fail
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1371_pos = $P10."pos"()
.annotate 'line', 536
  # rx pass
    rx1371_cur."!cursor_pass"(rx1371_pos, "term:sym<identifier>")
    if_null rx1371_debug, debug_1082
    rx1371_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1371_pos)
  debug_1082:
    .return (rx1371_cur)
  rx1371_restart:
.annotate 'line', 10
    if_null rx1371_debug, debug_1083
    rx1371_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1083:
  rx1371_fail:
    (rx1371_rep, rx1371_pos, $I10, $P10) = rx1371_cur."!mark_fail"(0)
    lt rx1371_pos, -1, rx1371_done
    eq rx1371_pos, -1, rx1371_fail
    jump $I10
  rx1371_done:
    rx1371_cur."!cursor_fail"()
    if_null rx1371_debug, debug_1084
    rx1371_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1084:
    .return (rx1371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("220_1303923618.727") :method
.annotate 'line', 10
    $P1373 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1374, "ResizablePMCArray"
    push $P1374, $P1373
    .return ($P1374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("221_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1377_tgt
    .local int rx1377_pos
    .local int rx1377_off
    .local int rx1377_eos
    .local int rx1377_rep
    .local pmc rx1377_cur
    .local pmc rx1377_debug
    (rx1377_cur, rx1377_pos, rx1377_tgt, $I10) = self."!cursor_start"()
    rx1377_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1377_cur
    .local pmc match
    .lex "$/", match
    length rx1377_eos, rx1377_tgt
    gt rx1377_pos, rx1377_eos, rx1377_done
    set rx1377_off, 0
    lt rx1377_pos, 2, rx1377_start
    sub rx1377_off, rx1377_pos, 1
    substr rx1377_tgt, rx1377_tgt, rx1377_off
  rx1377_start:
    eq $I10, 1, rx1377_restart
    if_null rx1377_debug, debug_1085
    rx1377_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1381_done
    goto rxscan1381_scan
  rxscan1381_loop:
    (rx1377_pos) = rx1377_cur."from"()
    inc rx1377_pos
    rx1377_cur."!cursor_from"(rx1377_pos)
    ge rx1377_pos, rx1377_eos, rxscan1381_done
  rxscan1381_scan:
    set_addr $I10, rxscan1381_loop
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxscan1381_done:
.annotate 'line', 541
  # rx subrule "name" subtype=capture negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."name"()
    unless $P10, rx1377_fail
    rx1377_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1377_pos = $P10."pos"()
  # rx rxquantr1382 ** 0..1
    set_addr $I10, rxquantr1382_done
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10)
  rxquantr1382_loop:
  # rx subrule "args" subtype=capture negate=
    rx1377_cur."!cursor_pos"(rx1377_pos)
    $P10 = rx1377_cur."args"()
    unless $P10, rx1377_fail
    goto rxsubrule1383_pass
  rxsubrule1383_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1377_fail
  rxsubrule1383_pass:
    set_addr $I10, rxsubrule1383_back
    rx1377_cur."!mark_push"(0, rx1377_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1377_pos = $P10."pos"()
    set_addr $I10, rxquantr1382_done
    (rx1377_rep) = rx1377_cur."!mark_commit"($I10)
  rxquantr1382_done:
.annotate 'line', 540
  # rx pass
    rx1377_cur."!cursor_pass"(rx1377_pos, "term:sym<name>")
    if_null rx1377_debug, debug_1086
    rx1377_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1377_pos)
  debug_1086:
    .return (rx1377_cur)
  rx1377_restart:
.annotate 'line', 10
    if_null rx1377_debug, debug_1087
    rx1377_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1087:
  rx1377_fail:
    (rx1377_rep, rx1377_pos, $I10, $P10) = rx1377_cur."!mark_fail"(0)
    lt rx1377_pos, -1, rx1377_done
    eq rx1377_pos, -1, rx1377_fail
    jump $I10
  rx1377_done:
    rx1377_cur."!cursor_fail"()
    if_null rx1377_debug, debug_1088
    rx1377_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1088:
    .return (rx1377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("222_1303923618.727") :method
.annotate 'line', 10
    $P1379 = self."!PREFIX__!subrule"("name", "")
    new $P1380, "ResizablePMCArray"
    push $P1380, $P1379
    .return ($P1380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("223_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1385_tgt
    .local int rx1385_pos
    .local int rx1385_off
    .local int rx1385_eos
    .local int rx1385_rep
    .local pmc rx1385_cur
    .local pmc rx1385_debug
    (rx1385_cur, rx1385_pos, rx1385_tgt, $I10) = self."!cursor_start"()
    rx1385_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1385_cur
    .local pmc match
    .lex "$/", match
    length rx1385_eos, rx1385_tgt
    gt rx1385_pos, rx1385_eos, rx1385_done
    set rx1385_off, 0
    lt rx1385_pos, 2, rx1385_start
    sub rx1385_off, rx1385_pos, 1
    substr rx1385_tgt, rx1385_tgt, rx1385_off
  rx1385_start:
    eq $I10, 1, rx1385_restart
    if_null rx1385_debug, debug_1089
    rx1385_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1388_done
    goto rxscan1388_scan
  rxscan1388_loop:
    (rx1385_pos) = rx1385_cur."from"()
    inc rx1385_pos
    rx1385_cur."!cursor_from"(rx1385_pos)
    ge rx1385_pos, rx1385_eos, rxscan1388_done
  rxscan1388_scan:
    set_addr $I10, rxscan1388_loop
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  rxscan1388_done:
.annotate 'line', 545
  # rx literal  "pir::"
    add $I11, rx1385_pos, 5
    gt $I11, rx1385_eos, rx1385_fail
    sub $I11, rx1385_pos, rx1385_off
    substr $S10, rx1385_tgt, $I11, 5
    ne $S10, "pir::", rx1385_fail
    add rx1385_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1389_fail
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1385_pos, rx1385_off
    find_not_cclass $I11, 8192, rx1385_tgt, $I10, rx1385_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1385_fail
    add rx1385_pos, rx1385_off, $I11
    set_addr $I10, rxcap_1389_fail
    ($I12, $I11) = rx1385_cur."!mark_peek"($I10)
    rx1385_cur."!cursor_pos"($I11)
    ($P10) = rx1385_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1385_pos, "")
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1389_done
  rxcap_1389_fail:
    goto rx1385_fail
  rxcap_1389_done:
  # rx rxquantr1390 ** 0..1
    set_addr $I10, rxquantr1390_done
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  rxquantr1390_loop:
  # rx subrule "args" subtype=capture negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."args"()
    unless $P10, rx1385_fail
    goto rxsubrule1391_pass
  rxsubrule1391_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1385_fail
  rxsubrule1391_pass:
    set_addr $I10, rxsubrule1391_back
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1385_pos = $P10."pos"()
    set_addr $I10, rxquantr1390_done
    (rx1385_rep) = rx1385_cur."!mark_commit"($I10)
  rxquantr1390_done:
.annotate 'line', 544
  # rx pass
    rx1385_cur."!cursor_pass"(rx1385_pos, "term:sym<pir::op>")
    if_null rx1385_debug, debug_1090
    rx1385_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1385_pos)
  debug_1090:
    .return (rx1385_cur)
  rx1385_restart:
.annotate 'line', 10
    if_null rx1385_debug, debug_1091
    rx1385_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1091:
  rx1385_fail:
    (rx1385_rep, rx1385_pos, $I10, $P10) = rx1385_cur."!mark_fail"(0)
    lt rx1385_pos, -1, rx1385_done
    eq rx1385_pos, -1, rx1385_fail
    jump $I10
  rx1385_done:
    rx1385_cur."!cursor_fail"()
    if_null rx1385_debug, debug_1092
    rx1385_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1092:
    .return (rx1385_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("224_1303923618.727") :method
.annotate 'line', 10
    new $P1387, "ResizablePMCArray"
    push $P1387, "pir::"
    .return ($P1387)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("225_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P1401 = "227_1303923618.727" 
    capture_lex $P1401
    .local string rx1393_tgt
    .local int rx1393_pos
    .local int rx1393_off
    .local int rx1393_eos
    .local int rx1393_rep
    .local pmc rx1393_cur
    .local pmc rx1393_debug
    (rx1393_cur, rx1393_pos, rx1393_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1393_cur
    .local pmc match
    .lex "$/", match
    length rx1393_eos, rx1393_tgt
    gt rx1393_pos, rx1393_eos, rx1393_done
    set rx1393_off, 0
    lt rx1393_pos, 2, rx1393_start
    sub rx1393_off, rx1393_pos, 1
    substr rx1393_tgt, rx1393_tgt, rx1393_off
  rx1393_start:
    eq $I10, 1, rx1393_restart
    if_null rx1393_debug, debug_1093
    rx1393_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1396_done
    goto rxscan1396_scan
  rxscan1396_loop:
    (rx1393_pos) = rx1393_cur."from"()
    inc rx1393_pos
    rx1393_cur."!cursor_from"(rx1393_pos)
    ge rx1393_pos, rx1393_eos, rxscan1396_done
  rxscan1396_scan:
    set_addr $I10, rxscan1396_loop
    rx1393_cur."!mark_push"(0, rx1393_pos, $I10)
  rxscan1396_done:
.annotate 'line', 549
  # rx literal  "{*}"
    add $I11, rx1393_pos, 3
    gt $I11, rx1393_eos, rx1393_fail
    sub $I11, rx1393_pos, rx1393_off
    substr $S10, rx1393_tgt, $I11, 3
    ne $S10, "{*}", rx1393_fail
    add rx1393_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1393_cur."!cursor_pos"(rx1393_pos)
    $P10 = rx1393_cur."ENDSTMT"()
    unless $P10, rx1393_fail
  alt1397_0:
.annotate 'line', 550
    set_addr $I10, alt1397_1
    rx1393_cur."!mark_push"(0, rx1393_pos, $I10)
    rx1393_cur."!cursor_pos"(rx1393_pos)
    find_lex $P1398, unicode:"$\x{a2}"
    $P1399 = $P1398."MATCH"()
    store_lex "$/", $P1399
    .const 'Sub' $P1401 = "227_1303923618.727" 
    capture_lex $P1401
    $P1407 = $P1401()
    unless $P1407, rx1393_fail
    goto alt1397_end
  alt1397_1:
  # rx subrule "panic" subtype=method negate=
    rx1393_cur."!cursor_pos"(rx1393_pos)
    $P10 = rx1393_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1393_fail
    rx1393_pos = $P10."pos"()
  alt1397_end:
.annotate 'line', 548
  # rx pass
    rx1393_cur."!cursor_pass"(rx1393_pos, "term:sym<onlystar>")
    if_null rx1393_debug, debug_1096
    rx1393_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1393_pos)
  debug_1096:
    .return (rx1393_cur)
  rx1393_restart:
.annotate 'line', 10
    if_null rx1393_debug, debug_1097
    rx1393_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1097:
  rx1393_fail:
    (rx1393_rep, rx1393_pos, $I10, $P10) = rx1393_cur."!mark_fail"(0)
    lt rx1393_pos, -1, rx1393_done
    eq rx1393_pos, -1, rx1393_fail
    jump $I10
  rx1393_done:
    rx1393_cur."!cursor_fail"()
    if_null rx1393_debug, debug_1098
    rx1393_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1098:
    .return (rx1393_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("226_1303923618.727") :method
.annotate 'line', 10
    new $P1395, "ResizablePMCArray"
    push $P1395, "{*}"
    .return ($P1395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1400"  :anon :subid("227_1303923618.727") :outer("225_1303923618.727")
.annotate 'line', 550
    find_dynamic_lex $P1404, "$*MULTINESS"
    unless_null $P1404, vivify_1094
    get_hll_global $P1402, "GLOBAL"
    get_who $P1403, $P1402
    set $P1404, $P1403["$MULTINESS"]
    unless_null $P1404, vivify_1095
    die "Contextual $*MULTINESS not found"
  vivify_1095:
  vivify_1094:
    set $S1405, $P1404
    iseq $I1406, $S1405, "proto"
    .return ($I1406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("228_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_1099
    rx1409_cur."!cursor_debug"("START", "args")
  debug_1099:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1413_done:
.annotate 'line', 554
  # rx literal  "("
    add $I11, rx1409_pos, 1
    gt $I11, rx1409_eos, rx1409_fail
    sub $I11, rx1409_pos, rx1409_off
    ord $I11, rx1409_tgt, $I11
    ne $I11, 40, rx1409_fail
    add rx1409_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."arglist"()
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1409_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1409_pos, 1
    gt $I11, rx1409_eos, rx1409_fail
    sub $I11, rx1409_pos, rx1409_off
    ord $I11, rx1409_tgt, $I11
    ne $I11, 41, rx1409_fail
    add rx1409_pos, 1
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "args")
    if_null rx1409_debug, debug_1100
    rx1409_cur."!cursor_debug"("PASS", "args", " at pos=", rx1409_pos)
  debug_1100:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 10
    if_null rx1409_debug, debug_1101
    rx1409_cur."!cursor_debug"("NEXT", "args")
  debug_1101:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_1102
    rx1409_cur."!cursor_debug"("FAIL", "args")
  debug_1102:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("229_1303923618.727") :method
.annotate 'line', 10
    $P1411 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1412, "ResizablePMCArray"
    push $P1412, $P1411
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("230_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1415_tgt
    .local int rx1415_pos
    .local int rx1415_off
    .local int rx1415_eos
    .local int rx1415_rep
    .local pmc rx1415_cur
    .local pmc rx1415_debug
    (rx1415_cur, rx1415_pos, rx1415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1415_cur
    .local pmc match
    .lex "$/", match
    length rx1415_eos, rx1415_tgt
    gt rx1415_pos, rx1415_eos, rx1415_done
    set rx1415_off, 0
    lt rx1415_pos, 2, rx1415_start
    sub rx1415_off, rx1415_pos, 1
    substr rx1415_tgt, rx1415_tgt, rx1415_off
  rx1415_start:
    eq $I10, 1, rx1415_restart
    if_null rx1415_debug, debug_1103
    rx1415_cur."!cursor_debug"("START", "arglist")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1419_done
    goto rxscan1419_scan
  rxscan1419_loop:
    (rx1415_pos) = rx1415_cur."from"()
    inc rx1415_pos
    rx1415_cur."!cursor_from"(rx1415_pos)
    ge rx1415_pos, rx1415_eos, rxscan1419_done
  rxscan1419_scan:
    set_addr $I10, rxscan1419_loop
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
  rxscan1419_done:
.annotate 'line', 558
  # rx subrule "ws" subtype=method negate=
    rx1415_cur."!cursor_pos"(rx1415_pos)
    $P10 = rx1415_cur."ws"()
    unless $P10, rx1415_fail
    rx1415_pos = $P10."pos"()
  alt1420_0:
.annotate 'line', 559
    set_addr $I10, alt1420_1
    rx1415_cur."!mark_push"(0, rx1415_pos, $I10)
.annotate 'line', 560
  # rx subrule "EXPR" subtype=capture negate=
    rx1415_cur."!cursor_pos"(rx1415_pos)
    $P10 = rx1415_cur."EXPR"("f=")
    unless $P10, rx1415_fail
    rx1415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1415_pos = $P10."pos"()
    goto alt1420_end
  alt1420_1:
  alt1420_end:
.annotate 'line', 557
  # rx pass
    rx1415_cur."!cursor_pass"(rx1415_pos, "arglist")
    if_null rx1415_debug, debug_1104
    rx1415_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1415_pos)
  debug_1104:
    .return (rx1415_cur)
  rx1415_restart:
.annotate 'line', 10
    if_null rx1415_debug, debug_1105
    rx1415_cur."!cursor_debug"("NEXT", "arglist")
  debug_1105:
  rx1415_fail:
    (rx1415_rep, rx1415_pos, $I10, $P10) = rx1415_cur."!mark_fail"(0)
    lt rx1415_pos, -1, rx1415_done
    eq rx1415_pos, -1, rx1415_fail
    jump $I10
  rx1415_done:
    rx1415_cur."!cursor_fail"()
    if_null rx1415_debug, debug_1106
    rx1415_cur."!cursor_debug"("FAIL", "arglist")
  debug_1106:
    .return (rx1415_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("231_1303923618.727") :method
.annotate 'line', 10
    $P1417 = self."!PREFIX__!subrule"("ws", "")
    new $P1418, "ResizablePMCArray"
    push $P1418, $P1417
    .return ($P1418)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("232_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1422_tgt
    .local int rx1422_pos
    .local int rx1422_off
    .local int rx1422_eos
    .local int rx1422_rep
    .local pmc rx1422_cur
    .local pmc rx1422_debug
    (rx1422_cur, rx1422_pos, rx1422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1422_cur
    .local pmc match
    .lex "$/", match
    length rx1422_eos, rx1422_tgt
    gt rx1422_pos, rx1422_eos, rx1422_done
    set rx1422_off, 0
    lt rx1422_pos, 2, rx1422_start
    sub rx1422_off, rx1422_pos, 1
    substr rx1422_tgt, rx1422_tgt, rx1422_off
  rx1422_start:
    eq $I10, 1, rx1422_restart
    if_null rx1422_debug, debug_1107
    rx1422_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1426_done
    goto rxscan1426_scan
  rxscan1426_loop:
    (rx1422_pos) = rx1422_cur."from"()
    inc rx1422_pos
    rx1422_cur."!cursor_from"(rx1422_pos)
    ge rx1422_pos, rx1422_eos, rxscan1426_done
  rxscan1426_scan:
    set_addr $I10, rxscan1426_loop
    rx1422_cur."!mark_push"(0, rx1422_pos, $I10)
  rxscan1426_done:
.annotate 'line', 566
  # rx subrule "value" subtype=capture negate=
    rx1422_cur."!cursor_pos"(rx1422_pos)
    $P10 = rx1422_cur."value"()
    unless $P10, rx1422_fail
    rx1422_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1422_pos = $P10."pos"()
  # rx pass
    rx1422_cur."!cursor_pass"(rx1422_pos, "term:sym<value>")
    if_null rx1422_debug, debug_1108
    rx1422_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1422_pos)
  debug_1108:
    .return (rx1422_cur)
  rx1422_restart:
.annotate 'line', 10
    if_null rx1422_debug, debug_1109
    rx1422_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1109:
  rx1422_fail:
    (rx1422_rep, rx1422_pos, $I10, $P10) = rx1422_cur."!mark_fail"(0)
    lt rx1422_pos, -1, rx1422_done
    eq rx1422_pos, -1, rx1422_fail
    jump $I10
  rx1422_done:
    rx1422_cur."!cursor_fail"()
    if_null rx1422_debug, debug_1110
    rx1422_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1110:
    .return (rx1422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("233_1303923618.727") :method
.annotate 'line', 10
    $P1424 = self."!PREFIX__!subrule"("value", "")
    new $P1425, "ResizablePMCArray"
    push $P1425, $P1424
    .return ($P1425)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("234_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1428_tgt
    .local int rx1428_pos
    .local int rx1428_off
    .local int rx1428_eos
    .local int rx1428_rep
    .local pmc rx1428_cur
    .local pmc rx1428_debug
    (rx1428_cur, rx1428_pos, rx1428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1428_cur
    .local pmc match
    .lex "$/", match
    length rx1428_eos, rx1428_tgt
    gt rx1428_pos, rx1428_eos, rx1428_done
    set rx1428_off, 0
    lt rx1428_pos, 2, rx1428_start
    sub rx1428_off, rx1428_pos, 1
    substr rx1428_tgt, rx1428_tgt, rx1428_off
  rx1428_start:
    eq $I10, 1, rx1428_restart
    if_null rx1428_debug, debug_1111
    rx1428_cur."!cursor_debug"("START", "value")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1433_done
    goto rxscan1433_scan
  rxscan1433_loop:
    (rx1428_pos) = rx1428_cur."from"()
    inc rx1428_pos
    rx1428_cur."!cursor_from"(rx1428_pos)
    ge rx1428_pos, rx1428_eos, rxscan1433_done
  rxscan1433_scan:
    set_addr $I10, rxscan1433_loop
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
  rxscan1433_done:
  alt1434_0:
.annotate 'line', 568
    set_addr $I10, alt1434_1
    rx1428_cur."!mark_push"(0, rx1428_pos, $I10)
.annotate 'line', 569
  # rx subrule "quote" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."quote"()
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1428_pos = $P10."pos"()
    goto alt1434_end
  alt1434_1:
.annotate 'line', 570
  # rx subrule "number" subtype=capture negate=
    rx1428_cur."!cursor_pos"(rx1428_pos)
    $P10 = rx1428_cur."number"()
    unless $P10, rx1428_fail
    rx1428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1428_pos = $P10."pos"()
  alt1434_end:
.annotate 'line', 568
  # rx pass
    rx1428_cur."!cursor_pass"(rx1428_pos, "value")
    if_null rx1428_debug, debug_1112
    rx1428_cur."!cursor_debug"("PASS", "value", " at pos=", rx1428_pos)
  debug_1112:
    .return (rx1428_cur)
  rx1428_restart:
.annotate 'line', 10
    if_null rx1428_debug, debug_1113
    rx1428_cur."!cursor_debug"("NEXT", "value")
  debug_1113:
  rx1428_fail:
    (rx1428_rep, rx1428_pos, $I10, $P10) = rx1428_cur."!mark_fail"(0)
    lt rx1428_pos, -1, rx1428_done
    eq rx1428_pos, -1, rx1428_fail
    jump $I10
  rx1428_done:
    rx1428_cur."!cursor_fail"()
    if_null rx1428_debug, debug_1114
    rx1428_cur."!cursor_debug"("FAIL", "value")
  debug_1114:
    .return (rx1428_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("235_1303923618.727") :method
.annotate 'line', 10
    $P1430 = self."!PREFIX__!subrule"("number", "")
    $P1431 = self."!PREFIX__!subrule"("quote", "")
    new $P1432, "ResizablePMCArray"
    push $P1432, $P1430
    push $P1432, $P1431
    .return ($P1432)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("236_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1436_tgt
    .local int rx1436_pos
    .local int rx1436_off
    .local int rx1436_eos
    .local int rx1436_rep
    .local pmc rx1436_cur
    .local pmc rx1436_debug
    (rx1436_cur, rx1436_pos, rx1436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1436_cur
    .local pmc match
    .lex "$/", match
    length rx1436_eos, rx1436_tgt
    gt rx1436_pos, rx1436_eos, rx1436_done
    set rx1436_off, 0
    lt rx1436_pos, 2, rx1436_start
    sub rx1436_off, rx1436_pos, 1
    substr rx1436_tgt, rx1436_tgt, rx1436_off
  rx1436_start:
    eq $I10, 1, rx1436_restart
    if_null rx1436_debug, debug_1115
    rx1436_cur."!cursor_debug"("START", "number")
  debug_1115:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1439_done
    goto rxscan1439_scan
  rxscan1439_loop:
    (rx1436_pos) = rx1436_cur."from"()
    inc rx1436_pos
    rx1436_cur."!cursor_from"(rx1436_pos)
    ge rx1436_pos, rx1436_eos, rxscan1439_done
  rxscan1439_scan:
    set_addr $I10, rxscan1439_loop
    rx1436_cur."!mark_push"(0, rx1436_pos, $I10)
  rxscan1439_done:
.annotate 'line', 574
  # rx subcapture "sign"
    set_addr $I10, rxcap_1441_fail
    rx1436_cur."!mark_push"(0, rx1436_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1436_pos, rx1436_off
    set rx1436_rep, 0
    sub $I12, rx1436_eos, rx1436_pos
    le $I12, 1, rxenumcharlistq1440_loop
    set $I12, 1
  rxenumcharlistq1440_loop:
    le $I12, 0, rxenumcharlistq1440_done
    substr $S10, rx1436_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1440_done
    inc rx1436_rep
  rxenumcharlistq1440_done:
    add rx1436_pos, rx1436_pos, rx1436_rep
    set_addr $I10, rxcap_1441_fail
    ($I12, $I11) = rx1436_cur."!mark_peek"($I10)
    rx1436_cur."!cursor_pos"($I11)
    ($P10) = rx1436_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1436_pos, "")
    rx1436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1441_done
  rxcap_1441_fail:
    goto rx1436_fail
  rxcap_1441_done:
  alt1442_0:
.annotate 'line', 575
    set_addr $I10, alt1442_1
    rx1436_cur."!mark_push"(0, rx1436_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1436_cur."!cursor_pos"(rx1436_pos)
    $P10 = rx1436_cur."dec_number"()
    unless $P10, rx1436_fail
    rx1436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1436_pos = $P10."pos"()
    goto alt1442_end
  alt1442_1:
  # rx subrule "integer" subtype=capture negate=
    rx1436_cur."!cursor_pos"(rx1436_pos)
    $P10 = rx1436_cur."integer"()
    unless $P10, rx1436_fail
    rx1436_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1436_pos = $P10."pos"()
  alt1442_end:
.annotate 'line', 573
  # rx pass
    rx1436_cur."!cursor_pass"(rx1436_pos, "number")
    if_null rx1436_debug, debug_1116
    rx1436_cur."!cursor_debug"("PASS", "number", " at pos=", rx1436_pos)
  debug_1116:
    .return (rx1436_cur)
  rx1436_restart:
.annotate 'line', 10
    if_null rx1436_debug, debug_1117
    rx1436_cur."!cursor_debug"("NEXT", "number")
  debug_1117:
  rx1436_fail:
    (rx1436_rep, rx1436_pos, $I10, $P10) = rx1436_cur."!mark_fail"(0)
    lt rx1436_pos, -1, rx1436_done
    eq rx1436_pos, -1, rx1436_fail
    jump $I10
  rx1436_done:
    rx1436_cur."!cursor_fail"()
    if_null rx1436_debug, debug_1118
    rx1436_cur."!cursor_debug"("FAIL", "number")
  debug_1118:
    .return (rx1436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("237_1303923618.727") :method
.annotate 'line', 10
    new $P1438, "ResizablePMCArray"
    push $P1438, ""
    .return ($P1438)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("238_1303923618.727")
    .param pmc param_1444
.annotate 'line', 578
    .lex "self", param_1444
    $P1445 = param_1444."!protoregex"("quote")
    .return ($P1445)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("239_1303923618.727")
    .param pmc param_1447
.annotate 'line', 578
    .lex "self", param_1447
    $P1448 = param_1447."!PREFIX__!protoregex"("quote")
    .return ($P1448)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("240_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1450_tgt
    .local int rx1450_pos
    .local int rx1450_off
    .local int rx1450_eos
    .local int rx1450_rep
    .local pmc rx1450_cur
    .local pmc rx1450_debug
    (rx1450_cur, rx1450_pos, rx1450_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1450_cur
    .local pmc match
    .lex "$/", match
    length rx1450_eos, rx1450_tgt
    gt rx1450_pos, rx1450_eos, rx1450_done
    set rx1450_off, 0
    lt rx1450_pos, 2, rx1450_start
    sub rx1450_off, rx1450_pos, 1
    substr rx1450_tgt, rx1450_tgt, rx1450_off
  rx1450_start:
    eq $I10, 1, rx1450_restart
    if_null rx1450_debug, debug_1119
    rx1450_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1119:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1453_done
    goto rxscan1453_scan
  rxscan1453_loop:
    (rx1450_pos) = rx1450_cur."from"()
    inc rx1450_pos
    rx1450_cur."!cursor_from"(rx1450_pos)
    ge rx1450_pos, rx1450_eos, rxscan1453_done
  rxscan1453_scan:
    set_addr $I10, rxscan1453_loop
    rx1450_cur."!mark_push"(0, rx1450_pos, $I10)
  rxscan1453_done:
.annotate 'line', 579
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1450_pos, rx1450_off
    substr $S10, rx1450_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1450_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1450_cur."!cursor_pos"(rx1450_pos)
    $P10 = rx1450_cur."quote_EXPR"(":q")
    unless $P10, rx1450_fail
    rx1450_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1450_pos = $P10."pos"()
  # rx pass
    rx1450_cur."!cursor_pass"(rx1450_pos, "quote:sym<apos>")
    if_null rx1450_debug, debug_1120
    rx1450_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1450_pos)
  debug_1120:
    .return (rx1450_cur)
  rx1450_restart:
.annotate 'line', 10
    if_null rx1450_debug, debug_1121
    rx1450_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1121:
  rx1450_fail:
    (rx1450_rep, rx1450_pos, $I10, $P10) = rx1450_cur."!mark_fail"(0)
    lt rx1450_pos, -1, rx1450_done
    eq rx1450_pos, -1, rx1450_fail
    jump $I10
  rx1450_done:
    rx1450_cur."!cursor_fail"()
    if_null rx1450_debug, debug_1122
    rx1450_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1122:
    .return (rx1450_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("241_1303923618.727") :method
.annotate 'line', 10
    new $P1452, "ResizablePMCArray"
    push $P1452, "'"
    .return ($P1452)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("242_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1455_tgt
    .local int rx1455_pos
    .local int rx1455_off
    .local int rx1455_eos
    .local int rx1455_rep
    .local pmc rx1455_cur
    .local pmc rx1455_debug
    (rx1455_cur, rx1455_pos, rx1455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1455_cur
    .local pmc match
    .lex "$/", match
    length rx1455_eos, rx1455_tgt
    gt rx1455_pos, rx1455_eos, rx1455_done
    set rx1455_off, 0
    lt rx1455_pos, 2, rx1455_start
    sub rx1455_off, rx1455_pos, 1
    substr rx1455_tgt, rx1455_tgt, rx1455_off
  rx1455_start:
    eq $I10, 1, rx1455_restart
    if_null rx1455_debug, debug_1123
    rx1455_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1123:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1458_done
    goto rxscan1458_scan
  rxscan1458_loop:
    (rx1455_pos) = rx1455_cur."from"()
    inc rx1455_pos
    rx1455_cur."!cursor_from"(rx1455_pos)
    ge rx1455_pos, rx1455_eos, rxscan1458_done
  rxscan1458_scan:
    set_addr $I10, rxscan1458_loop
    rx1455_cur."!mark_push"(0, rx1455_pos, $I10)
  rxscan1458_done:
.annotate 'line', 580
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1455_pos, rx1455_off
    substr $S10, rx1455_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1455_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."quote_EXPR"(":qq")
    unless $P10, rx1455_fail
    rx1455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1455_pos = $P10."pos"()
  # rx pass
    rx1455_cur."!cursor_pass"(rx1455_pos, "quote:sym<dblq>")
    if_null rx1455_debug, debug_1124
    rx1455_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1455_pos)
  debug_1124:
    .return (rx1455_cur)
  rx1455_restart:
.annotate 'line', 10
    if_null rx1455_debug, debug_1125
    rx1455_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1125:
  rx1455_fail:
    (rx1455_rep, rx1455_pos, $I10, $P10) = rx1455_cur."!mark_fail"(0)
    lt rx1455_pos, -1, rx1455_done
    eq rx1455_pos, -1, rx1455_fail
    jump $I10
  rx1455_done:
    rx1455_cur."!cursor_fail"()
    if_null rx1455_debug, debug_1126
    rx1455_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1126:
    .return (rx1455_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("243_1303923618.727") :method
.annotate 'line', 10
    new $P1457, "ResizablePMCArray"
    push $P1457, "\""
    .return ($P1457)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("244_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1460_tgt
    .local int rx1460_pos
    .local int rx1460_off
    .local int rx1460_eos
    .local int rx1460_rep
    .local pmc rx1460_cur
    .local pmc rx1460_debug
    (rx1460_cur, rx1460_pos, rx1460_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1460_cur
    .local pmc match
    .lex "$/", match
    length rx1460_eos, rx1460_tgt
    gt rx1460_pos, rx1460_eos, rx1460_done
    set rx1460_off, 0
    lt rx1460_pos, 2, rx1460_start
    sub rx1460_off, rx1460_pos, 1
    substr rx1460_tgt, rx1460_tgt, rx1460_off
  rx1460_start:
    eq $I10, 1, rx1460_restart
    if_null rx1460_debug, debug_1127
    rx1460_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1464_done
    goto rxscan1464_scan
  rxscan1464_loop:
    (rx1460_pos) = rx1460_cur."from"()
    inc rx1460_pos
    rx1460_cur."!cursor_from"(rx1460_pos)
    ge rx1460_pos, rx1460_eos, rxscan1464_done
  rxscan1464_scan:
    set_addr $I10, rxscan1464_loop
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  rxscan1464_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1465_fail
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  # rx literal  "q"
    add $I11, rx1460_pos, 1
    gt $I11, rx1460_eos, rx1460_fail
    sub $I11, rx1460_pos, rx1460_off
    ord $I11, rx1460_tgt, $I11
    ne $I11, 113, rx1460_fail
    add rx1460_pos, 1
    set_addr $I10, rxcap_1465_fail
    ($I12, $I11) = rx1460_cur."!mark_peek"($I10)
    rx1460_cur."!cursor_pos"($I11)
    ($P10) = rx1460_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1460_pos, "")
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1465_done
  rxcap_1465_fail:
    goto rx1460_fail
  rxcap_1465_done:
  # rxanchor rwb
    le rx1460_pos, 0, rx1460_fail
    sub $I10, rx1460_pos, rx1460_off
    is_cclass $I11, 8192, rx1460_tgt, $I10
    if $I11, rx1460_fail
    dec $I10
    is_cclass $I11, 8192, rx1460_tgt, $I10
    unless $I11, rx1460_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1460_pos, rx1460_off
    substr $S10, rx1460_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1460_fail
  # rx subrule "ws" subtype=method negate=
    rx1460_cur."!cursor_pos"(rx1460_pos)
    $P10 = rx1460_cur."ws"()
    unless $P10, rx1460_fail
    rx1460_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1460_cur."!cursor_pos"(rx1460_pos)
    $P10 = rx1460_cur."quote_EXPR"(":q")
    unless $P10, rx1460_fail
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1460_pos = $P10."pos"()
  # rx pass
    rx1460_cur."!cursor_pass"(rx1460_pos, "quote:sym<q>")
    if_null rx1460_debug, debug_1128
    rx1460_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1460_pos)
  debug_1128:
    .return (rx1460_cur)
  rx1460_restart:
.annotate 'line', 10
    if_null rx1460_debug, debug_1129
    rx1460_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1129:
  rx1460_fail:
    (rx1460_rep, rx1460_pos, $I10, $P10) = rx1460_cur."!mark_fail"(0)
    lt rx1460_pos, -1, rx1460_done
    eq rx1460_pos, -1, rx1460_fail
    jump $I10
  rx1460_done:
    rx1460_cur."!cursor_fail"()
    if_null rx1460_debug, debug_1130
    rx1460_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1130:
    .return (rx1460_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("245_1303923618.727") :method
.annotate 'line', 10
    $P1462 = self."!PREFIX__!subrule"("ws", "q")
    new $P1463, "ResizablePMCArray"
    push $P1463, $P1462
    .return ($P1463)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("246_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1467_tgt
    .local int rx1467_pos
    .local int rx1467_off
    .local int rx1467_eos
    .local int rx1467_rep
    .local pmc rx1467_cur
    .local pmc rx1467_debug
    (rx1467_cur, rx1467_pos, rx1467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1467_cur
    .local pmc match
    .lex "$/", match
    length rx1467_eos, rx1467_tgt
    gt rx1467_pos, rx1467_eos, rx1467_done
    set rx1467_off, 0
    lt rx1467_pos, 2, rx1467_start
    sub rx1467_off, rx1467_pos, 1
    substr rx1467_tgt, rx1467_tgt, rx1467_off
  rx1467_start:
    eq $I10, 1, rx1467_restart
    if_null rx1467_debug, debug_1131
    rx1467_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1131:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1471_done
    goto rxscan1471_scan
  rxscan1471_loop:
    (rx1467_pos) = rx1467_cur."from"()
    inc rx1467_pos
    rx1467_cur."!cursor_from"(rx1467_pos)
    ge rx1467_pos, rx1467_eos, rxscan1471_done
  rxscan1471_scan:
    set_addr $I10, rxscan1471_loop
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  rxscan1471_done:
.annotate 'line', 582
  # rx subcapture "sym"
    set_addr $I10, rxcap_1472_fail
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1467_pos, 2
    gt $I11, rx1467_eos, rx1467_fail
    sub $I11, rx1467_pos, rx1467_off
    substr $S10, rx1467_tgt, $I11, 2
    ne $S10, "qq", rx1467_fail
    add rx1467_pos, 2
    set_addr $I10, rxcap_1472_fail
    ($I12, $I11) = rx1467_cur."!mark_peek"($I10)
    rx1467_cur."!cursor_pos"($I11)
    ($P10) = rx1467_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1467_pos, "")
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1472_done
  rxcap_1472_fail:
    goto rx1467_fail
  rxcap_1472_done:
  # rxanchor rwb
    le rx1467_pos, 0, rx1467_fail
    sub $I10, rx1467_pos, rx1467_off
    is_cclass $I11, 8192, rx1467_tgt, $I10
    if $I11, rx1467_fail
    dec $I10
    is_cclass $I11, 8192, rx1467_tgt, $I10
    unless $I11, rx1467_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1467_pos, rx1467_off
    substr $S10, rx1467_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1467_fail
  # rx subrule "ws" subtype=method negate=
    rx1467_cur."!cursor_pos"(rx1467_pos)
    $P10 = rx1467_cur."ws"()
    unless $P10, rx1467_fail
    rx1467_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1467_cur."!cursor_pos"(rx1467_pos)
    $P10 = rx1467_cur."quote_EXPR"(":qq")
    unless $P10, rx1467_fail
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1467_pos = $P10."pos"()
  # rx pass
    rx1467_cur."!cursor_pass"(rx1467_pos, "quote:sym<qq>")
    if_null rx1467_debug, debug_1132
    rx1467_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1467_pos)
  debug_1132:
    .return (rx1467_cur)
  rx1467_restart:
.annotate 'line', 10
    if_null rx1467_debug, debug_1133
    rx1467_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1133:
  rx1467_fail:
    (rx1467_rep, rx1467_pos, $I10, $P10) = rx1467_cur."!mark_fail"(0)
    lt rx1467_pos, -1, rx1467_done
    eq rx1467_pos, -1, rx1467_fail
    jump $I10
  rx1467_done:
    rx1467_cur."!cursor_fail"()
    if_null rx1467_debug, debug_1134
    rx1467_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1134:
    .return (rx1467_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("247_1303923618.727") :method
.annotate 'line', 10
    $P1469 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1470, "ResizablePMCArray"
    push $P1470, $P1469
    .return ($P1470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("248_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1474_tgt
    .local int rx1474_pos
    .local int rx1474_off
    .local int rx1474_eos
    .local int rx1474_rep
    .local pmc rx1474_cur
    .local pmc rx1474_debug
    (rx1474_cur, rx1474_pos, rx1474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1474_cur
    .local pmc match
    .lex "$/", match
    length rx1474_eos, rx1474_tgt
    gt rx1474_pos, rx1474_eos, rx1474_done
    set rx1474_off, 0
    lt rx1474_pos, 2, rx1474_start
    sub rx1474_off, rx1474_pos, 1
    substr rx1474_tgt, rx1474_tgt, rx1474_off
  rx1474_start:
    eq $I10, 1, rx1474_restart
    if_null rx1474_debug, debug_1135
    rx1474_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1135:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1478_done
    goto rxscan1478_scan
  rxscan1478_loop:
    (rx1474_pos) = rx1474_cur."from"()
    inc rx1474_pos
    rx1474_cur."!cursor_from"(rx1474_pos)
    ge rx1474_pos, rx1474_eos, rxscan1478_done
  rxscan1478_scan:
    set_addr $I10, rxscan1478_loop
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  rxscan1478_done:
.annotate 'line', 583
  # rx subcapture "sym"
    set_addr $I10, rxcap_1479_fail
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1474_pos, 1
    gt $I11, rx1474_eos, rx1474_fail
    sub $I11, rx1474_pos, rx1474_off
    ord $I11, rx1474_tgt, $I11
    ne $I11, 81, rx1474_fail
    add rx1474_pos, 1
    set_addr $I10, rxcap_1479_fail
    ($I12, $I11) = rx1474_cur."!mark_peek"($I10)
    rx1474_cur."!cursor_pos"($I11)
    ($P10) = rx1474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1474_pos, "")
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1479_done
  rxcap_1479_fail:
    goto rx1474_fail
  rxcap_1479_done:
  # rxanchor rwb
    le rx1474_pos, 0, rx1474_fail
    sub $I10, rx1474_pos, rx1474_off
    is_cclass $I11, 8192, rx1474_tgt, $I10
    if $I11, rx1474_fail
    dec $I10
    is_cclass $I11, 8192, rx1474_tgt, $I10
    unless $I11, rx1474_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1474_pos, rx1474_off
    substr $S10, rx1474_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1474_fail
  # rx subrule "ws" subtype=method negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."ws"()
    unless $P10, rx1474_fail
    rx1474_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."quote_EXPR"()
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1474_pos = $P10."pos"()
  # rx pass
    rx1474_cur."!cursor_pass"(rx1474_pos, "quote:sym<Q>")
    if_null rx1474_debug, debug_1136
    rx1474_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1474_pos)
  debug_1136:
    .return (rx1474_cur)
  rx1474_restart:
.annotate 'line', 10
    if_null rx1474_debug, debug_1137
    rx1474_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1137:
  rx1474_fail:
    (rx1474_rep, rx1474_pos, $I10, $P10) = rx1474_cur."!mark_fail"(0)
    lt rx1474_pos, -1, rx1474_done
    eq rx1474_pos, -1, rx1474_fail
    jump $I10
  rx1474_done:
    rx1474_cur."!cursor_fail"()
    if_null rx1474_debug, debug_1138
    rx1474_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1138:
    .return (rx1474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("249_1303923618.727") :method
.annotate 'line', 10
    $P1476 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1477, "ResizablePMCArray"
    push $P1477, $P1476
    .return ($P1477)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("250_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1481_tgt
    .local int rx1481_pos
    .local int rx1481_off
    .local int rx1481_eos
    .local int rx1481_rep
    .local pmc rx1481_cur
    .local pmc rx1481_debug
    (rx1481_cur, rx1481_pos, rx1481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1481_cur
    .local pmc match
    .lex "$/", match
    length rx1481_eos, rx1481_tgt
    gt rx1481_pos, rx1481_eos, rx1481_done
    set rx1481_off, 0
    lt rx1481_pos, 2, rx1481_start
    sub rx1481_off, rx1481_pos, 1
    substr rx1481_tgt, rx1481_tgt, rx1481_off
  rx1481_start:
    eq $I10, 1, rx1481_restart
    if_null rx1481_debug, debug_1139
    rx1481_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1485_done
    goto rxscan1485_scan
  rxscan1485_loop:
    (rx1481_pos) = rx1481_cur."from"()
    inc rx1481_pos
    rx1481_cur."!cursor_from"(rx1481_pos)
    ge rx1481_pos, rx1481_eos, rxscan1485_done
  rxscan1485_scan:
    set_addr $I10, rxscan1485_loop
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  rxscan1485_done:
.annotate 'line', 584
  # rx subcapture "sym"
    set_addr $I10, rxcap_1486_fail
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1481_pos, 5
    gt $I11, rx1481_eos, rx1481_fail
    sub $I11, rx1481_pos, rx1481_off
    substr $S10, rx1481_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1481_fail
    add rx1481_pos, 5
    set_addr $I10, rxcap_1486_fail
    ($I12, $I11) = rx1481_cur."!mark_peek"($I10)
    rx1481_cur."!cursor_pos"($I11)
    ($P10) = rx1481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1481_pos, "")
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1486_done
  rxcap_1486_fail:
    goto rx1481_fail
  rxcap_1486_done:
  # rx subrule "ws" subtype=method negate=
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."ws"()
    unless $P10, rx1481_fail
    rx1481_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."quote_EXPR"()
    unless $P10, rx1481_fail
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1481_pos = $P10."pos"()
  # rx pass
    rx1481_cur."!cursor_pass"(rx1481_pos, "quote:sym<Q:PIR>")
    if_null rx1481_debug, debug_1140
    rx1481_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1481_pos)
  debug_1140:
    .return (rx1481_cur)
  rx1481_restart:
.annotate 'line', 10
    if_null rx1481_debug, debug_1141
    rx1481_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1141:
  rx1481_fail:
    (rx1481_rep, rx1481_pos, $I10, $P10) = rx1481_cur."!mark_fail"(0)
    lt rx1481_pos, -1, rx1481_done
    eq rx1481_pos, -1, rx1481_fail
    jump $I10
  rx1481_done:
    rx1481_cur."!cursor_fail"()
    if_null rx1481_debug, debug_1142
    rx1481_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1142:
    .return (rx1481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("251_1303923618.727") :method
.annotate 'line', 10
    $P1483 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1484, "ResizablePMCArray"
    push $P1484, $P1483
    .return ($P1484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("252_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1488_tgt
    .local int rx1488_pos
    .local int rx1488_off
    .local int rx1488_eos
    .local int rx1488_rep
    .local pmc rx1488_cur
    .local pmc rx1488_debug
    (rx1488_cur, rx1488_pos, rx1488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1488_cur
    .local pmc match
    .lex "$/", match
    length rx1488_eos, rx1488_tgt
    gt rx1488_pos, rx1488_eos, rx1488_done
    set rx1488_off, 0
    lt rx1488_pos, 2, rx1488_start
    sub rx1488_off, rx1488_pos, 1
    substr rx1488_tgt, rx1488_tgt, rx1488_off
  rx1488_start:
    eq $I10, 1, rx1488_restart
    if_null rx1488_debug, debug_1143
    rx1488_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1143:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1492_done
    goto rxscan1492_scan
  rxscan1492_loop:
    (rx1488_pos) = rx1488_cur."from"()
    inc rx1488_pos
    rx1488_cur."!cursor_from"(rx1488_pos)
    ge rx1488_pos, rx1488_eos, rxscan1492_done
  rxscan1492_scan:
    set_addr $I10, rxscan1492_loop
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  rxscan1492_done:
.annotate 'line', 586
  # rx literal  "/"
    add $I11, rx1488_pos, 1
    gt $I11, rx1488_eos, rx1488_fail
    sub $I11, rx1488_pos, rx1488_off
    ord $I11, rx1488_tgt, $I11
    ne $I11, 47, rx1488_fail
    add rx1488_pos, 1
.annotate 'line', 587
  # rx subrule "newpad" subtype=method negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."newpad"()
    unless $P10, rx1488_fail
    rx1488_pos = $P10."pos"()
.annotate 'line', 588
  # rx reduce name="quote:sym</ />" key="open"
    rx1488_cur."!cursor_pos"(rx1488_pos)
    rx1488_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 589
  # rx subrule "LANG" subtype=capture negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1488_fail
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1488_pos = $P10."pos"()
.annotate 'line', 590
  # rx literal  "/"
    add $I11, rx1488_pos, 1
    gt $I11, rx1488_eos, rx1488_fail
    sub $I11, rx1488_pos, rx1488_off
    ord $I11, rx1488_tgt, $I11
    ne $I11, 47, rx1488_fail
    add rx1488_pos, 1
.annotate 'line', 585
  # rx pass
    rx1488_cur."!cursor_pass"(rx1488_pos, "quote:sym</ />")
    if_null rx1488_debug, debug_1144
    rx1488_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1488_pos)
  debug_1144:
    .return (rx1488_cur)
  rx1488_restart:
.annotate 'line', 10
    if_null rx1488_debug, debug_1145
    rx1488_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1145:
  rx1488_fail:
    (rx1488_rep, rx1488_pos, $I10, $P10) = rx1488_cur."!mark_fail"(0)
    lt rx1488_pos, -1, rx1488_done
    eq rx1488_pos, -1, rx1488_fail
    jump $I10
  rx1488_done:
    rx1488_cur."!cursor_fail"()
    if_null rx1488_debug, debug_1146
    rx1488_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1146:
    .return (rx1488_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("253_1303923618.727") :method
.annotate 'line', 10
    $P1490 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1491, "ResizablePMCArray"
    push $P1491, $P1490
    .return ($P1491)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("254_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1494_tgt
    .local int rx1494_pos
    .local int rx1494_off
    .local int rx1494_eos
    .local int rx1494_rep
    .local pmc rx1494_cur
    .local pmc rx1494_debug
    (rx1494_cur, rx1494_pos, rx1494_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1494_cur
    .local pmc match
    .lex "$/", match
    length rx1494_eos, rx1494_tgt
    gt rx1494_pos, rx1494_eos, rx1494_done
    set rx1494_off, 0
    lt rx1494_pos, 2, rx1494_start
    sub rx1494_off, rx1494_pos, 1
    substr rx1494_tgt, rx1494_tgt, rx1494_off
  rx1494_start:
    eq $I10, 1, rx1494_restart
    if_null rx1494_debug, debug_1147
    rx1494_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1497_done
    goto rxscan1497_scan
  rxscan1497_loop:
    (rx1494_pos) = rx1494_cur."from"()
    inc rx1494_pos
    rx1494_cur."!cursor_from"(rx1494_pos)
    ge rx1494_pos, rx1494_eos, rxscan1497_done
  rxscan1497_scan:
    set_addr $I10, rxscan1497_loop
    rx1494_cur."!mark_push"(0, rx1494_pos, $I10)
  rxscan1497_done:
.annotate 'line', 593
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1494_pos, rx1494_off
    substr $S10, rx1494_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1494_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1494_cur."!cursor_pos"(rx1494_pos)
    $P10 = rx1494_cur."quotemod_check"("s")
    unless $P10, rx1494_fail
  # rx subrule "variable" subtype=capture negate=
    rx1494_cur."!cursor_pos"(rx1494_pos)
    $P10 = rx1494_cur."variable"()
    unless $P10, rx1494_fail
    rx1494_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1494_pos = $P10."pos"()
  # rx pass
    rx1494_cur."!cursor_pass"(rx1494_pos, "quote_escape:sym<$>")
    if_null rx1494_debug, debug_1148
    rx1494_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1494_pos)
  debug_1148:
    .return (rx1494_cur)
  rx1494_restart:
.annotate 'line', 10
    if_null rx1494_debug, debug_1149
    rx1494_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1149:
  rx1494_fail:
    (rx1494_rep, rx1494_pos, $I10, $P10) = rx1494_cur."!mark_fail"(0)
    lt rx1494_pos, -1, rx1494_done
    eq rx1494_pos, -1, rx1494_fail
    jump $I10
  rx1494_done:
    rx1494_cur."!cursor_fail"()
    if_null rx1494_debug, debug_1150
    rx1494_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1150:
    .return (rx1494_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("255_1303923618.727") :method
.annotate 'line', 10
    new $P1496, "ResizablePMCArray"
    push $P1496, "$"
    .return ($P1496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("256_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1499_tgt
    .local int rx1499_pos
    .local int rx1499_off
    .local int rx1499_eos
    .local int rx1499_rep
    .local pmc rx1499_cur
    .local pmc rx1499_debug
    (rx1499_cur, rx1499_pos, rx1499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1499_cur
    .local pmc match
    .lex "$/", match
    length rx1499_eos, rx1499_tgt
    gt rx1499_pos, rx1499_eos, rx1499_done
    set rx1499_off, 0
    lt rx1499_pos, 2, rx1499_start
    sub rx1499_off, rx1499_pos, 1
    substr rx1499_tgt, rx1499_tgt, rx1499_off
  rx1499_start:
    eq $I10, 1, rx1499_restart
    if_null rx1499_debug, debug_1151
    rx1499_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1502_done
    goto rxscan1502_scan
  rxscan1502_loop:
    (rx1499_pos) = rx1499_cur."from"()
    inc rx1499_pos
    rx1499_cur."!cursor_from"(rx1499_pos)
    ge rx1499_pos, rx1499_eos, rxscan1502_done
  rxscan1502_scan:
    set_addr $I10, rxscan1502_loop
    rx1499_cur."!mark_push"(0, rx1499_pos, $I10)
  rxscan1502_done:
.annotate 'line', 594
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1499_pos, rx1499_off
    substr $S10, rx1499_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1499_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1499_cur."!cursor_pos"(rx1499_pos)
    $P10 = rx1499_cur."quotemod_check"("c")
    unless $P10, rx1499_fail
  # rx subrule "block" subtype=capture negate=
    rx1499_cur."!cursor_pos"(rx1499_pos)
    $P10 = rx1499_cur."block"()
    unless $P10, rx1499_fail
    rx1499_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1499_pos = $P10."pos"()
  # rx pass
    rx1499_cur."!cursor_pass"(rx1499_pos, "quote_escape:sym<{ }>")
    if_null rx1499_debug, debug_1152
    rx1499_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1499_pos)
  debug_1152:
    .return (rx1499_cur)
  rx1499_restart:
.annotate 'line', 10
    if_null rx1499_debug, debug_1153
    rx1499_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1153:
  rx1499_fail:
    (rx1499_rep, rx1499_pos, $I10, $P10) = rx1499_cur."!mark_fail"(0)
    lt rx1499_pos, -1, rx1499_done
    eq rx1499_pos, -1, rx1499_fail
    jump $I10
  rx1499_done:
    rx1499_cur."!cursor_fail"()
    if_null rx1499_debug, debug_1154
    rx1499_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1154:
    .return (rx1499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("257_1303923618.727") :method
.annotate 'line', 10
    new $P1501, "ResizablePMCArray"
    push $P1501, "{"
    .return ($P1501)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("258_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1504_tgt
    .local int rx1504_pos
    .local int rx1504_off
    .local int rx1504_eos
    .local int rx1504_rep
    .local pmc rx1504_cur
    .local pmc rx1504_debug
    (rx1504_cur, rx1504_pos, rx1504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1504_cur
    .local pmc match
    .lex "$/", match
    length rx1504_eos, rx1504_tgt
    gt rx1504_pos, rx1504_eos, rx1504_done
    set rx1504_off, 0
    lt rx1504_pos, 2, rx1504_start
    sub rx1504_off, rx1504_pos, 1
    substr rx1504_tgt, rx1504_tgt, rx1504_off
  rx1504_start:
    eq $I10, 1, rx1504_restart
    if_null rx1504_debug, debug_1155
    rx1504_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1507_done
    goto rxscan1507_scan
  rxscan1507_loop:
    (rx1504_pos) = rx1504_cur."from"()
    inc rx1504_pos
    rx1504_cur."!cursor_from"(rx1504_pos)
    ge rx1504_pos, rx1504_eos, rxscan1507_done
  rxscan1507_scan:
    set_addr $I10, rxscan1507_loop
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  rxscan1507_done:
.annotate 'line', 595
  # rx literal  "\\e"
    add $I11, rx1504_pos, 2
    gt $I11, rx1504_eos, rx1504_fail
    sub $I11, rx1504_pos, rx1504_off
    substr $S10, rx1504_tgt, $I11, 2
    ne $S10, "\\e", rx1504_fail
    add rx1504_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."quotemod_check"("b")
    unless $P10, rx1504_fail
  # rx pass
    rx1504_cur."!cursor_pass"(rx1504_pos, "quote_escape:sym<esc>")
    if_null rx1504_debug, debug_1156
    rx1504_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1504_pos)
  debug_1156:
    .return (rx1504_cur)
  rx1504_restart:
.annotate 'line', 10
    if_null rx1504_debug, debug_1157
    rx1504_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1157:
  rx1504_fail:
    (rx1504_rep, rx1504_pos, $I10, $P10) = rx1504_cur."!mark_fail"(0)
    lt rx1504_pos, -1, rx1504_done
    eq rx1504_pos, -1, rx1504_fail
    jump $I10
  rx1504_done:
    rx1504_cur."!cursor_fail"()
    if_null rx1504_debug, debug_1158
    rx1504_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1158:
    .return (rx1504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("259_1303923618.727") :method
.annotate 'line', 10
    new $P1506, "ResizablePMCArray"
    push $P1506, "\\e"
    .return ($P1506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("260_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1509_tgt
    .local int rx1509_pos
    .local int rx1509_off
    .local int rx1509_eos
    .local int rx1509_rep
    .local pmc rx1509_cur
    .local pmc rx1509_debug
    (rx1509_cur, rx1509_pos, rx1509_tgt, $I10) = self."!cursor_start"()
    rx1509_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1509_cur
    .local pmc match
    .lex "$/", match
    length rx1509_eos, rx1509_tgt
    gt rx1509_pos, rx1509_eos, rx1509_done
    set rx1509_off, 0
    lt rx1509_pos, 2, rx1509_start
    sub rx1509_off, rx1509_pos, 1
    substr rx1509_tgt, rx1509_tgt, rx1509_off
  rx1509_start:
    eq $I10, 1, rx1509_restart
    if_null rx1509_debug, debug_1159
    rx1509_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1159:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1513_done
    goto rxscan1513_scan
  rxscan1513_loop:
    (rx1509_pos) = rx1509_cur."from"()
    inc rx1509_pos
    rx1509_cur."!cursor_from"(rx1509_pos)
    ge rx1509_pos, rx1509_eos, rxscan1513_done
  rxscan1513_scan:
    set_addr $I10, rxscan1513_loop
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  rxscan1513_done:
.annotate 'line', 597
  # rx literal  "("
    add $I11, rx1509_pos, 1
    gt $I11, rx1509_eos, rx1509_fail
    sub $I11, rx1509_pos, rx1509_off
    ord $I11, rx1509_tgt, $I11
    ne $I11, 40, rx1509_fail
    add rx1509_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1509_cur."!cursor_pos"(rx1509_pos)
    $P10 = rx1509_cur."ws"()
    unless $P10, rx1509_fail
    rx1509_pos = $P10."pos"()
  # rx rxquantr1514 ** 0..1
    set_addr $I10, rxquantr1514_done
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  rxquantr1514_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1509_cur."!cursor_pos"(rx1509_pos)
    $P10 = rx1509_cur."EXPR"()
    unless $P10, rx1509_fail
    goto rxsubrule1515_pass
  rxsubrule1515_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1509_fail
  rxsubrule1515_pass:
    set_addr $I10, rxsubrule1515_back
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1509_pos = $P10."pos"()
    set_addr $I10, rxquantr1514_done
    (rx1509_rep) = rx1509_cur."!mark_commit"($I10)
  rxquantr1514_done:
  # rx literal  ")"
    add $I11, rx1509_pos, 1
    gt $I11, rx1509_eos, rx1509_fail
    sub $I11, rx1509_pos, rx1509_off
    ord $I11, rx1509_tgt, $I11
    ne $I11, 41, rx1509_fail
    add rx1509_pos, 1
  # rx pass
    rx1509_cur."!cursor_pass"(rx1509_pos, "circumfix:sym<( )>")
    if_null rx1509_debug, debug_1160
    rx1509_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1509_pos)
  debug_1160:
    .return (rx1509_cur)
  rx1509_restart:
.annotate 'line', 10
    if_null rx1509_debug, debug_1161
    rx1509_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1161:
  rx1509_fail:
    (rx1509_rep, rx1509_pos, $I10, $P10) = rx1509_cur."!mark_fail"(0)
    lt rx1509_pos, -1, rx1509_done
    eq rx1509_pos, -1, rx1509_fail
    jump $I10
  rx1509_done:
    rx1509_cur."!cursor_fail"()
    if_null rx1509_debug, debug_1162
    rx1509_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1162:
    .return (rx1509_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("261_1303923618.727") :method
.annotate 'line', 10
    $P1511 = self."!PREFIX__!subrule"("ws", "(")
    new $P1512, "ResizablePMCArray"
    push $P1512, $P1511
    .return ($P1512)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("262_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1517_tgt
    .local int rx1517_pos
    .local int rx1517_off
    .local int rx1517_eos
    .local int rx1517_rep
    .local pmc rx1517_cur
    .local pmc rx1517_debug
    (rx1517_cur, rx1517_pos, rx1517_tgt, $I10) = self."!cursor_start"()
    rx1517_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1517_cur
    .local pmc match
    .lex "$/", match
    length rx1517_eos, rx1517_tgt
    gt rx1517_pos, rx1517_eos, rx1517_done
    set rx1517_off, 0
    lt rx1517_pos, 2, rx1517_start
    sub rx1517_off, rx1517_pos, 1
    substr rx1517_tgt, rx1517_tgt, rx1517_off
  rx1517_start:
    eq $I10, 1, rx1517_restart
    if_null rx1517_debug, debug_1163
    rx1517_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1163:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1521_done
    goto rxscan1521_scan
  rxscan1521_loop:
    (rx1517_pos) = rx1517_cur."from"()
    inc rx1517_pos
    rx1517_cur."!cursor_from"(rx1517_pos)
    ge rx1517_pos, rx1517_eos, rxscan1521_done
  rxscan1521_scan:
    set_addr $I10, rxscan1521_loop
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10)
  rxscan1521_done:
.annotate 'line', 598
  # rx literal  "["
    add $I11, rx1517_pos, 1
    gt $I11, rx1517_eos, rx1517_fail
    sub $I11, rx1517_pos, rx1517_off
    ord $I11, rx1517_tgt, $I11
    ne $I11, 91, rx1517_fail
    add rx1517_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1517_cur."!cursor_pos"(rx1517_pos)
    $P10 = rx1517_cur."ws"()
    unless $P10, rx1517_fail
    rx1517_pos = $P10."pos"()
  # rx rxquantr1522 ** 0..1
    set_addr $I10, rxquantr1522_done
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10)
  rxquantr1522_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1517_cur."!cursor_pos"(rx1517_pos)
    $P10 = rx1517_cur."EXPR"()
    unless $P10, rx1517_fail
    goto rxsubrule1523_pass
  rxsubrule1523_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1517_fail
  rxsubrule1523_pass:
    set_addr $I10, rxsubrule1523_back
    rx1517_cur."!mark_push"(0, rx1517_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1517_pos = $P10."pos"()
    set_addr $I10, rxquantr1522_done
    (rx1517_rep) = rx1517_cur."!mark_commit"($I10)
  rxquantr1522_done:
  # rx literal  "]"
    add $I11, rx1517_pos, 1
    gt $I11, rx1517_eos, rx1517_fail
    sub $I11, rx1517_pos, rx1517_off
    ord $I11, rx1517_tgt, $I11
    ne $I11, 93, rx1517_fail
    add rx1517_pos, 1
  # rx pass
    rx1517_cur."!cursor_pass"(rx1517_pos, "circumfix:sym<[ ]>")
    if_null rx1517_debug, debug_1164
    rx1517_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1517_pos)
  debug_1164:
    .return (rx1517_cur)
  rx1517_restart:
.annotate 'line', 10
    if_null rx1517_debug, debug_1165
    rx1517_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1165:
  rx1517_fail:
    (rx1517_rep, rx1517_pos, $I10, $P10) = rx1517_cur."!mark_fail"(0)
    lt rx1517_pos, -1, rx1517_done
    eq rx1517_pos, -1, rx1517_fail
    jump $I10
  rx1517_done:
    rx1517_cur."!cursor_fail"()
    if_null rx1517_debug, debug_1166
    rx1517_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1166:
    .return (rx1517_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("263_1303923618.727") :method
.annotate 'line', 10
    $P1519 = self."!PREFIX__!subrule"("ws", "[")
    new $P1520, "ResizablePMCArray"
    push $P1520, $P1519
    .return ($P1520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("264_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1525_tgt
    .local int rx1525_pos
    .local int rx1525_off
    .local int rx1525_eos
    .local int rx1525_rep
    .local pmc rx1525_cur
    .local pmc rx1525_debug
    (rx1525_cur, rx1525_pos, rx1525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1525_cur
    .local pmc match
    .lex "$/", match
    length rx1525_eos, rx1525_tgt
    gt rx1525_pos, rx1525_eos, rx1525_done
    set rx1525_off, 0
    lt rx1525_pos, 2, rx1525_start
    sub rx1525_off, rx1525_pos, 1
    substr rx1525_tgt, rx1525_tgt, rx1525_off
  rx1525_start:
    eq $I10, 1, rx1525_restart
    if_null rx1525_debug, debug_1167
    rx1525_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1167:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1528_done
    goto rxscan1528_scan
  rxscan1528_loop:
    (rx1525_pos) = rx1525_cur."from"()
    inc rx1525_pos
    rx1525_cur."!cursor_from"(rx1525_pos)
    ge rx1525_pos, rx1525_eos, rxscan1528_done
  rxscan1528_scan:
    set_addr $I10, rxscan1528_loop
    rx1525_cur."!mark_push"(0, rx1525_pos, $I10)
  rxscan1528_done:
.annotate 'line', 599
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1525_pos, rx1525_off
    substr $S10, rx1525_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1525_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1525_fail
    rx1525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1525_pos = $P10."pos"()
  # rx pass
    rx1525_cur."!cursor_pass"(rx1525_pos, "circumfix:sym<ang>")
    if_null rx1525_debug, debug_1168
    rx1525_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1525_pos)
  debug_1168:
    .return (rx1525_cur)
  rx1525_restart:
.annotate 'line', 10
    if_null rx1525_debug, debug_1169
    rx1525_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1169:
  rx1525_fail:
    (rx1525_rep, rx1525_pos, $I10, $P10) = rx1525_cur."!mark_fail"(0)
    lt rx1525_pos, -1, rx1525_done
    eq rx1525_pos, -1, rx1525_fail
    jump $I10
  rx1525_done:
    rx1525_cur."!cursor_fail"()
    if_null rx1525_debug, debug_1170
    rx1525_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1170:
    .return (rx1525_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("265_1303923618.727") :method
.annotate 'line', 10
    new $P1527, "ResizablePMCArray"
    push $P1527, "<"
    .return ($P1527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("266_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1530_tgt
    .local int rx1530_pos
    .local int rx1530_off
    .local int rx1530_eos
    .local int rx1530_rep
    .local pmc rx1530_cur
    .local pmc rx1530_debug
    (rx1530_cur, rx1530_pos, rx1530_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1530_cur
    .local pmc match
    .lex "$/", match
    length rx1530_eos, rx1530_tgt
    gt rx1530_pos, rx1530_eos, rx1530_done
    set rx1530_off, 0
    lt rx1530_pos, 2, rx1530_start
    sub rx1530_off, rx1530_pos, 1
    substr rx1530_tgt, rx1530_tgt, rx1530_off
  rx1530_start:
    eq $I10, 1, rx1530_restart
    if_null rx1530_debug, debug_1171
    rx1530_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1171:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1533_done
    goto rxscan1533_scan
  rxscan1533_loop:
    (rx1530_pos) = rx1530_cur."from"()
    inc rx1530_pos
    rx1530_cur."!cursor_from"(rx1530_pos)
    ge rx1530_pos, rx1530_eos, rxscan1533_done
  rxscan1533_scan:
    set_addr $I10, rxscan1533_loop
    rx1530_cur."!mark_push"(0, rx1530_pos, $I10)
  rxscan1533_done:
.annotate 'line', 600
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1530_pos, rx1530_off
    substr $S10, rx1530_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1530_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1530_cur."!cursor_pos"(rx1530_pos)
    $P10 = rx1530_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1530_fail
    rx1530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1530_pos = $P10."pos"()
  # rx pass
    rx1530_cur."!cursor_pass"(rx1530_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1530_debug, debug_1172
    rx1530_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1530_pos)
  debug_1172:
    .return (rx1530_cur)
  rx1530_restart:
.annotate 'line', 10
    if_null rx1530_debug, debug_1173
    rx1530_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1173:
  rx1530_fail:
    (rx1530_rep, rx1530_pos, $I10, $P10) = rx1530_cur."!mark_fail"(0)
    lt rx1530_pos, -1, rx1530_done
    eq rx1530_pos, -1, rx1530_fail
    jump $I10
  rx1530_done:
    rx1530_cur."!cursor_fail"()
    if_null rx1530_debug, debug_1174
    rx1530_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1174:
    .return (rx1530_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>") :subid("267_1303923618.727") :method
.annotate 'line', 10
    new $P1532, "ResizablePMCArray"
    push $P1532, unicode:"\x{ab}"
    .return ($P1532)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("268_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1535_tgt
    .local int rx1535_pos
    .local int rx1535_off
    .local int rx1535_eos
    .local int rx1535_rep
    .local pmc rx1535_cur
    .local pmc rx1535_debug
    (rx1535_cur, rx1535_pos, rx1535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1535_cur
    .local pmc match
    .lex "$/", match
    length rx1535_eos, rx1535_tgt
    gt rx1535_pos, rx1535_eos, rx1535_done
    set rx1535_off, 0
    lt rx1535_pos, 2, rx1535_start
    sub rx1535_off, rx1535_pos, 1
    substr rx1535_tgt, rx1535_tgt, rx1535_off
  rx1535_start:
    eq $I10, 1, rx1535_restart
    if_null rx1535_debug, debug_1175
    rx1535_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1175:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1535_pos) = rx1535_cur."from"()
    inc rx1535_pos
    rx1535_cur."!cursor_from"(rx1535_pos)
    ge rx1535_pos, rx1535_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  rxscan1538_done:
.annotate 'line', 601
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1535_pos, rx1535_off
    substr $S10, rx1535_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1535_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1535_cur."!cursor_pos"(rx1535_pos)
    $P10 = rx1535_cur."pblock"()
    unless $P10, rx1535_fail
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1535_pos = $P10."pos"()
  # rx pass
    rx1535_cur."!cursor_pass"(rx1535_pos, "circumfix:sym<{ }>")
    if_null rx1535_debug, debug_1176
    rx1535_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1535_pos)
  debug_1176:
    .return (rx1535_cur)
  rx1535_restart:
.annotate 'line', 10
    if_null rx1535_debug, debug_1177
    rx1535_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1177:
  rx1535_fail:
    (rx1535_rep, rx1535_pos, $I10, $P10) = rx1535_cur."!mark_fail"(0)
    lt rx1535_pos, -1, rx1535_done
    eq rx1535_pos, -1, rx1535_fail
    jump $I10
  rx1535_done:
    rx1535_cur."!cursor_fail"()
    if_null rx1535_debug, debug_1178
    rx1535_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1178:
    .return (rx1535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("269_1303923618.727") :method
.annotate 'line', 10
    new $P1537, "ResizablePMCArray"
    push $P1537, "{"
    .return ($P1537)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("270_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1540_tgt
    .local int rx1540_pos
    .local int rx1540_off
    .local int rx1540_eos
    .local int rx1540_rep
    .local pmc rx1540_cur
    .local pmc rx1540_debug
    (rx1540_cur, rx1540_pos, rx1540_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1540_cur
    .local pmc match
    .lex "$/", match
    length rx1540_eos, rx1540_tgt
    gt rx1540_pos, rx1540_eos, rx1540_done
    set rx1540_off, 0
    lt rx1540_pos, 2, rx1540_start
    sub rx1540_off, rx1540_pos, 1
    substr rx1540_tgt, rx1540_tgt, rx1540_off
  rx1540_start:
    eq $I10, 1, rx1540_restart
    if_null rx1540_debug, debug_1179
    rx1540_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1179:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1544_done
    goto rxscan1544_scan
  rxscan1544_loop:
    (rx1540_pos) = rx1540_cur."from"()
    inc rx1540_pos
    rx1540_cur."!cursor_from"(rx1540_pos)
    ge rx1540_pos, rx1540_eos, rxscan1544_done
  rxscan1544_scan:
    set_addr $I10, rxscan1544_loop
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  rxscan1544_done:
.annotate 'line', 602
  # rx subrule "sigil" subtype=capture negate=
    rx1540_cur."!cursor_pos"(rx1540_pos)
    $P10 = rx1540_cur."sigil"()
    unless $P10, rx1540_fail
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1540_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1540_pos, 1
    gt $I11, rx1540_eos, rx1540_fail
    sub $I11, rx1540_pos, rx1540_off
    ord $I11, rx1540_tgt, $I11
    ne $I11, 40, rx1540_fail
    add rx1540_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1540_cur."!cursor_pos"(rx1540_pos)
    $P10 = rx1540_cur."semilist"()
    unless $P10, rx1540_fail
    rx1540_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1540_pos = $P10."pos"()
  alt1545_0:
    set_addr $I10, alt1545_1
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10)
  # rx literal  ")"
    add $I11, rx1540_pos, 1
    gt $I11, rx1540_eos, rx1540_fail
    sub $I11, rx1540_pos, rx1540_off
    ord $I11, rx1540_tgt, $I11
    ne $I11, 41, rx1540_fail
    add rx1540_pos, 1
    goto alt1545_end
  alt1545_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1540_cur."!cursor_pos"(rx1540_pos)
    $P10 = rx1540_cur."FAILGOAL"("')'")
    unless $P10, rx1540_fail
    goto rxsubrule1547_pass
  rxsubrule1547_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1540_fail
  rxsubrule1547_pass:
    set_addr $I10, rxsubrule1547_back
    rx1540_cur."!mark_push"(0, rx1540_pos, $I10, $P10)
    rx1540_pos = $P10."pos"()
  alt1545_end:
  # rx pass
    rx1540_cur."!cursor_pass"(rx1540_pos, "circumfix:sym<sigil>")
    if_null rx1540_debug, debug_1180
    rx1540_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1540_pos)
  debug_1180:
    .return (rx1540_cur)
  rx1540_restart:
.annotate 'line', 10
    if_null rx1540_debug, debug_1181
    rx1540_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1181:
  rx1540_fail:
    (rx1540_rep, rx1540_pos, $I10, $P10) = rx1540_cur."!mark_fail"(0)
    lt rx1540_pos, -1, rx1540_done
    eq rx1540_pos, -1, rx1540_fail
    jump $I10
  rx1540_done:
    rx1540_cur."!cursor_fail"()
    if_null rx1540_debug, debug_1182
    rx1540_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1182:
    .return (rx1540_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("271_1303923618.727") :method
.annotate 'line', 10
    $P1542 = self."!PREFIX__!subrule"("sigil", "")
    new $P1543, "ResizablePMCArray"
    push $P1543, $P1542
    .return ($P1543)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("272_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1183
    rx1549_cur."!cursor_debug"("START", "semilist")
  debug_1183:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1553_done:
.annotate 'line', 604
  # rx subrule "ws" subtype=method negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."ws"()
    unless $P10, rx1549_fail
    rx1549_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."statement"()
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1549_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."ws"()
    unless $P10, rx1549_fail
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "semilist")
    if_null rx1549_debug, debug_1184
    rx1549_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1549_pos)
  debug_1184:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 10
    if_null rx1549_debug, debug_1185
    rx1549_cur."!cursor_debug"("NEXT", "semilist")
  debug_1185:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1186
    rx1549_cur."!cursor_debug"("FAIL", "semilist")
  debug_1186:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("273_1303923618.727") :method
.annotate 'line', 10
    $P1551 = self."!PREFIX__!subrule"("ws", "")
    new $P1552, "ResizablePMCArray"
    push $P1552, $P1551
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("274_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1557_tgt
    .local int rx1557_pos
    .local int rx1557_off
    .local int rx1557_eos
    .local int rx1557_rep
    .local pmc rx1557_cur
    .local pmc rx1557_debug
    (rx1557_cur, rx1557_pos, rx1557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1557_cur
    .local pmc match
    .lex "$/", match
    length rx1557_eos, rx1557_tgt
    gt rx1557_pos, rx1557_eos, rx1557_done
    set rx1557_off, 0
    lt rx1557_pos, 2, rx1557_start
    sub rx1557_off, rx1557_pos, 1
    substr rx1557_tgt, rx1557_tgt, rx1557_off
  rx1557_start:
    eq $I10, 1, rx1557_restart
    if_null rx1557_debug, debug_1187
    rx1557_cur."!cursor_debug"("START", "infixish")
  debug_1187:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1557_pos) = rx1557_cur."from"()
    inc rx1557_pos
    rx1557_cur."!cursor_from"(rx1557_pos)
    ge rx1557_pos, rx1557_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  rxscan1560_done:
.annotate 'line', 627
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1557_cur."!cursor_pos"(rx1557_pos)
    $P10 = rx1557_cur."infixstopper"()
    if $P10, rx1557_fail
  # rx subrule "infix" subtype=capture negate=
    rx1557_cur."!cursor_pos"(rx1557_pos)
    $P10 = rx1557_cur."infix"()
    unless $P10, rx1557_fail
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1557_pos = $P10."pos"()
  # rx pass
    rx1557_cur."!cursor_pass"(rx1557_pos, "infixish")
    if_null rx1557_debug, debug_1188
    rx1557_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1557_pos)
  debug_1188:
    .return (rx1557_cur)
  rx1557_restart:
.annotate 'line', 10
    if_null rx1557_debug, debug_1189
    rx1557_cur."!cursor_debug"("NEXT", "infixish")
  debug_1189:
  rx1557_fail:
    (rx1557_rep, rx1557_pos, $I10, $P10) = rx1557_cur."!mark_fail"(0)
    lt rx1557_pos, -1, rx1557_done
    eq rx1557_pos, -1, rx1557_fail
    jump $I10
  rx1557_done:
    rx1557_cur."!cursor_fail"()
    if_null rx1557_debug, debug_1190
    rx1557_cur."!cursor_debug"("FAIL", "infixish")
  debug_1190:
    .return (rx1557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("275_1303923618.727") :method
.annotate 'line', 10
    new $P1559, "ResizablePMCArray"
    push $P1559, ""
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("276_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1562_tgt
    .local int rx1562_pos
    .local int rx1562_off
    .local int rx1562_eos
    .local int rx1562_rep
    .local pmc rx1562_cur
    .local pmc rx1562_debug
    (rx1562_cur, rx1562_pos, rx1562_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1562_cur
    .local pmc match
    .lex "$/", match
    length rx1562_eos, rx1562_tgt
    gt rx1562_pos, rx1562_eos, rx1562_done
    set rx1562_off, 0
    lt rx1562_pos, 2, rx1562_start
    sub rx1562_off, rx1562_pos, 1
    substr rx1562_tgt, rx1562_tgt, rx1562_off
  rx1562_start:
    eq $I10, 1, rx1562_restart
    if_null rx1562_debug, debug_1191
    rx1562_cur."!cursor_debug"("START", "infixstopper")
  debug_1191:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1565_done
    goto rxscan1565_scan
  rxscan1565_loop:
    (rx1562_pos) = rx1562_cur."from"()
    inc rx1562_pos
    rx1562_cur."!cursor_from"(rx1562_pos)
    ge rx1562_pos, rx1562_eos, rxscan1565_done
  rxscan1565_scan:
    set_addr $I10, rxscan1565_loop
    rx1562_cur."!mark_push"(0, rx1562_pos, $I10)
  rxscan1565_done:
.annotate 'line', 628
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1562_cur."!cursor_pos"(rx1562_pos)
    $P10 = rx1562_cur."lambda"()
    unless $P10, rx1562_fail
  # rx pass
    rx1562_cur."!cursor_pass"(rx1562_pos, "infixstopper")
    if_null rx1562_debug, debug_1192
    rx1562_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1562_pos)
  debug_1192:
    .return (rx1562_cur)
  rx1562_restart:
.annotate 'line', 10
    if_null rx1562_debug, debug_1193
    rx1562_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1193:
  rx1562_fail:
    (rx1562_rep, rx1562_pos, $I10, $P10) = rx1562_cur."!mark_fail"(0)
    lt rx1562_pos, -1, rx1562_done
    eq rx1562_pos, -1, rx1562_fail
    jump $I10
  rx1562_done:
    rx1562_cur."!cursor_fail"()
    if_null rx1562_debug, debug_1194
    rx1562_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1194:
    .return (rx1562_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("277_1303923618.727") :method
.annotate 'line', 10
    new $P1564, "ResizablePMCArray"
    push $P1564, ""
    .return ($P1564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("278_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1567_tgt
    .local int rx1567_pos
    .local int rx1567_off
    .local int rx1567_eos
    .local int rx1567_rep
    .local pmc rx1567_cur
    .local pmc rx1567_debug
    (rx1567_cur, rx1567_pos, rx1567_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1567_cur
    .local pmc match
    .lex "$/", match
    length rx1567_eos, rx1567_tgt
    gt rx1567_pos, rx1567_eos, rx1567_done
    set rx1567_off, 0
    lt rx1567_pos, 2, rx1567_start
    sub rx1567_off, rx1567_pos, 1
    substr rx1567_tgt, rx1567_tgt, rx1567_off
  rx1567_start:
    eq $I10, 1, rx1567_restart
    if_null rx1567_debug, debug_1195
    rx1567_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1195:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1571_done
    goto rxscan1571_scan
  rxscan1571_loop:
    (rx1567_pos) = rx1567_cur."from"()
    inc rx1567_pos
    rx1567_cur."!cursor_from"(rx1567_pos)
    ge rx1567_pos, rx1567_eos, rxscan1571_done
  rxscan1571_scan:
    set_addr $I10, rxscan1571_loop
    rx1567_cur."!mark_push"(0, rx1567_pos, $I10)
  rxscan1571_done:
.annotate 'line', 631
  # rx literal  "["
    add $I11, rx1567_pos, 1
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    ord $I11, rx1567_tgt, $I11
    ne $I11, 91, rx1567_fail
    add rx1567_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."ws"()
    unless $P10, rx1567_fail
    rx1567_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."EXPR"()
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1567_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1567_pos, 1
    gt $I11, rx1567_eos, rx1567_fail
    sub $I11, rx1567_pos, rx1567_off
    ord $I11, rx1567_tgt, $I11
    ne $I11, 93, rx1567_fail
    add rx1567_pos, 1
.annotate 'line', 632
  # rx subrule "O" subtype=capture negate=
    rx1567_cur."!cursor_pos"(rx1567_pos)
    $P10 = rx1567_cur."O"("%methodop")
    unless $P10, rx1567_fail
    rx1567_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1567_pos = $P10."pos"()
.annotate 'line', 630
  # rx pass
    rx1567_cur."!cursor_pass"(rx1567_pos, "postcircumfix:sym<[ ]>")
    if_null rx1567_debug, debug_1196
    rx1567_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1567_pos)
  debug_1196:
    .return (rx1567_cur)
  rx1567_restart:
.annotate 'line', 10
    if_null rx1567_debug, debug_1197
    rx1567_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1197:
  rx1567_fail:
    (rx1567_rep, rx1567_pos, $I10, $P10) = rx1567_cur."!mark_fail"(0)
    lt rx1567_pos, -1, rx1567_done
    eq rx1567_pos, -1, rx1567_fail
    jump $I10
  rx1567_done:
    rx1567_cur."!cursor_fail"()
    if_null rx1567_debug, debug_1198
    rx1567_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1198:
    .return (rx1567_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("279_1303923618.727") :method
.annotate 'line', 10
    $P1569 = self."!PREFIX__!subrule"("ws", "[")
    new $P1570, "ResizablePMCArray"
    push $P1570, $P1569
    .return ($P1570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("280_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1573_tgt
    .local int rx1573_pos
    .local int rx1573_off
    .local int rx1573_eos
    .local int rx1573_rep
    .local pmc rx1573_cur
    .local pmc rx1573_debug
    (rx1573_cur, rx1573_pos, rx1573_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1573_cur
    .local pmc match
    .lex "$/", match
    length rx1573_eos, rx1573_tgt
    gt rx1573_pos, rx1573_eos, rx1573_done
    set rx1573_off, 0
    lt rx1573_pos, 2, rx1573_start
    sub rx1573_off, rx1573_pos, 1
    substr rx1573_tgt, rx1573_tgt, rx1573_off
  rx1573_start:
    eq $I10, 1, rx1573_restart
    if_null rx1573_debug, debug_1199
    rx1573_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1199:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1577_done
    goto rxscan1577_scan
  rxscan1577_loop:
    (rx1573_pos) = rx1573_cur."from"()
    inc rx1573_pos
    rx1573_cur."!cursor_from"(rx1573_pos)
    ge rx1573_pos, rx1573_eos, rxscan1577_done
  rxscan1577_scan:
    set_addr $I10, rxscan1577_loop
    rx1573_cur."!mark_push"(0, rx1573_pos, $I10)
  rxscan1577_done:
.annotate 'line', 636
  # rx literal  "{"
    add $I11, rx1573_pos, 1
    gt $I11, rx1573_eos, rx1573_fail
    sub $I11, rx1573_pos, rx1573_off
    ord $I11, rx1573_tgt, $I11
    ne $I11, 123, rx1573_fail
    add rx1573_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."ws"()
    unless $P10, rx1573_fail
    rx1573_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."EXPR"()
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1573_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1573_pos, 1
    gt $I11, rx1573_eos, rx1573_fail
    sub $I11, rx1573_pos, rx1573_off
    ord $I11, rx1573_tgt, $I11
    ne $I11, 125, rx1573_fail
    add rx1573_pos, 1
.annotate 'line', 637
  # rx subrule "O" subtype=capture negate=
    rx1573_cur."!cursor_pos"(rx1573_pos)
    $P10 = rx1573_cur."O"("%methodop")
    unless $P10, rx1573_fail
    rx1573_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1573_pos = $P10."pos"()
.annotate 'line', 635
  # rx pass
    rx1573_cur."!cursor_pass"(rx1573_pos, "postcircumfix:sym<{ }>")
    if_null rx1573_debug, debug_1200
    rx1573_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1573_pos)
  debug_1200:
    .return (rx1573_cur)
  rx1573_restart:
.annotate 'line', 10
    if_null rx1573_debug, debug_1201
    rx1573_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1201:
  rx1573_fail:
    (rx1573_rep, rx1573_pos, $I10, $P10) = rx1573_cur."!mark_fail"(0)
    lt rx1573_pos, -1, rx1573_done
    eq rx1573_pos, -1, rx1573_fail
    jump $I10
  rx1573_done:
    rx1573_cur."!cursor_fail"()
    if_null rx1573_debug, debug_1202
    rx1573_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1202:
    .return (rx1573_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("281_1303923618.727") :method
.annotate 'line', 10
    $P1575 = self."!PREFIX__!subrule"("ws", "{")
    new $P1576, "ResizablePMCArray"
    push $P1576, $P1575
    .return ($P1576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("282_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1579_tgt
    .local int rx1579_pos
    .local int rx1579_off
    .local int rx1579_eos
    .local int rx1579_rep
    .local pmc rx1579_cur
    .local pmc rx1579_debug
    (rx1579_cur, rx1579_pos, rx1579_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1579_cur
    .local pmc match
    .lex "$/", match
    length rx1579_eos, rx1579_tgt
    gt rx1579_pos, rx1579_eos, rx1579_done
    set rx1579_off, 0
    lt rx1579_pos, 2, rx1579_start
    sub rx1579_off, rx1579_pos, 1
    substr rx1579_tgt, rx1579_tgt, rx1579_off
  rx1579_start:
    eq $I10, 1, rx1579_restart
    if_null rx1579_debug, debug_1203
    rx1579_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1203:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1582_done
    goto rxscan1582_scan
  rxscan1582_loop:
    (rx1579_pos) = rx1579_cur."from"()
    inc rx1579_pos
    rx1579_cur."!cursor_from"(rx1579_pos)
    ge rx1579_pos, rx1579_eos, rxscan1582_done
  rxscan1582_scan:
    set_addr $I10, rxscan1582_loop
    rx1579_cur."!mark_push"(0, rx1579_pos, $I10)
  rxscan1582_done:
.annotate 'line', 641
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1579_pos, rx1579_off
    substr $S10, rx1579_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1579_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1579_cur."!cursor_pos"(rx1579_pos)
    $P10 = rx1579_cur."quote_EXPR"(":q")
    unless $P10, rx1579_fail
    rx1579_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1579_pos = $P10."pos"()
.annotate 'line', 642
  # rx subrule "O" subtype=capture negate=
    rx1579_cur."!cursor_pos"(rx1579_pos)
    $P10 = rx1579_cur."O"("%methodop")
    unless $P10, rx1579_fail
    rx1579_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1579_pos = $P10."pos"()
.annotate 'line', 640
  # rx pass
    rx1579_cur."!cursor_pass"(rx1579_pos, "postcircumfix:sym<ang>")
    if_null rx1579_debug, debug_1204
    rx1579_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1579_pos)
  debug_1204:
    .return (rx1579_cur)
  rx1579_restart:
.annotate 'line', 10
    if_null rx1579_debug, debug_1205
    rx1579_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1205:
  rx1579_fail:
    (rx1579_rep, rx1579_pos, $I10, $P10) = rx1579_cur."!mark_fail"(0)
    lt rx1579_pos, -1, rx1579_done
    eq rx1579_pos, -1, rx1579_fail
    jump $I10
  rx1579_done:
    rx1579_cur."!cursor_fail"()
    if_null rx1579_debug, debug_1206
    rx1579_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1206:
    .return (rx1579_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("283_1303923618.727") :method
.annotate 'line', 10
    new $P1581, "ResizablePMCArray"
    push $P1581, "<"
    .return ($P1581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("284_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1207
    rx1584_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1207:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 646
  # rx literal  "("
    add $I11, rx1584_pos, 1
    gt $I11, rx1584_eos, rx1584_fail
    sub $I11, rx1584_pos, rx1584_off
    ord $I11, rx1584_tgt, $I11
    ne $I11, 40, rx1584_fail
    add rx1584_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."ws"()
    unless $P10, rx1584_fail
    rx1584_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."arglist"()
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1584_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1584_pos, 1
    gt $I11, rx1584_eos, rx1584_fail
    sub $I11, rx1584_pos, rx1584_off
    ord $I11, rx1584_tgt, $I11
    ne $I11, 41, rx1584_fail
    add rx1584_pos, 1
.annotate 'line', 647
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%methodop")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
.annotate 'line', 645
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "postcircumfix:sym<( )>")
    if_null rx1584_debug, debug_1208
    rx1584_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1584_pos)
  debug_1208:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1209
    rx1584_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1209:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1210
    rx1584_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1210:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("285_1303923618.727") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("ws", "(")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("286_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1590_tgt
    .local int rx1590_pos
    .local int rx1590_off
    .local int rx1590_eos
    .local int rx1590_rep
    .local pmc rx1590_cur
    .local pmc rx1590_debug
    (rx1590_cur, rx1590_pos, rx1590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1590_cur
    .local pmc match
    .lex "$/", match
    length rx1590_eos, rx1590_tgt
    gt rx1590_pos, rx1590_eos, rx1590_done
    set rx1590_off, 0
    lt rx1590_pos, 2, rx1590_start
    sub rx1590_off, rx1590_pos, 1
    substr rx1590_tgt, rx1590_tgt, rx1590_off
  rx1590_start:
    eq $I10, 1, rx1590_restart
    if_null rx1590_debug, debug_1211
    rx1590_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1211:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1594_done
    goto rxscan1594_scan
  rxscan1594_loop:
    (rx1590_pos) = rx1590_cur."from"()
    inc rx1590_pos
    rx1590_cur."!cursor_from"(rx1590_pos)
    ge rx1590_pos, rx1590_eos, rxscan1594_done
  rxscan1594_scan:
    set_addr $I10, rxscan1594_loop
    rx1590_cur."!mark_push"(0, rx1590_pos, $I10)
  rxscan1594_done:
.annotate 'line', 650
  # rx subrule "dotty" subtype=capture negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."dotty"()
    unless $P10, rx1590_fail
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1590_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1590_cur."!cursor_pos"(rx1590_pos)
    $P10 = rx1590_cur."O"("%methodop")
    unless $P10, rx1590_fail
    rx1590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1590_pos = $P10."pos"()
  # rx pass
    rx1590_cur."!cursor_pass"(rx1590_pos, "postfix:sym<.>")
    if_null rx1590_debug, debug_1212
    rx1590_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1590_pos)
  debug_1212:
    .return (rx1590_cur)
  rx1590_restart:
.annotate 'line', 10
    if_null rx1590_debug, debug_1213
    rx1590_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1213:
  rx1590_fail:
    (rx1590_rep, rx1590_pos, $I10, $P10) = rx1590_cur."!mark_fail"(0)
    lt rx1590_pos, -1, rx1590_done
    eq rx1590_pos, -1, rx1590_fail
    jump $I10
  rx1590_done:
    rx1590_cur."!cursor_fail"()
    if_null rx1590_debug, debug_1214
    rx1590_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1214:
    .return (rx1590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("287_1303923618.727") :method
.annotate 'line', 10
    $P1592 = self."!PREFIX__!subrule"("dotty", "")
    new $P1593, "ResizablePMCArray"
    push $P1593, $P1592
    .return ($P1593)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("288_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1596_tgt
    .local int rx1596_pos
    .local int rx1596_off
    .local int rx1596_eos
    .local int rx1596_rep
    .local pmc rx1596_cur
    .local pmc rx1596_debug
    (rx1596_cur, rx1596_pos, rx1596_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1596_cur
    .local pmc match
    .lex "$/", match
    length rx1596_eos, rx1596_tgt
    gt rx1596_pos, rx1596_eos, rx1596_done
    set rx1596_off, 0
    lt rx1596_pos, 2, rx1596_start
    sub rx1596_off, rx1596_pos, 1
    substr rx1596_tgt, rx1596_tgt, rx1596_off
  rx1596_start:
    eq $I10, 1, rx1596_restart
    if_null rx1596_debug, debug_1215
    rx1596_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1215:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1600_done
    goto rxscan1600_scan
  rxscan1600_loop:
    (rx1596_pos) = rx1596_cur."from"()
    inc rx1596_pos
    rx1596_cur."!cursor_from"(rx1596_pos)
    ge rx1596_pos, rx1596_eos, rxscan1600_done
  rxscan1600_scan:
    set_addr $I10, rxscan1600_loop
    rx1596_cur."!mark_push"(0, rx1596_pos, $I10)
  rxscan1600_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1601_fail
    rx1596_cur."!mark_push"(0, rx1596_pos, $I10)
  # rx literal  "++"
    add $I11, rx1596_pos, 2
    gt $I11, rx1596_eos, rx1596_fail
    sub $I11, rx1596_pos, rx1596_off
    substr $S10, rx1596_tgt, $I11, 2
    ne $S10, "++", rx1596_fail
    add rx1596_pos, 2
    set_addr $I10, rxcap_1601_fail
    ($I12, $I11) = rx1596_cur."!mark_peek"($I10)
    rx1596_cur."!cursor_pos"($I11)
    ($P10) = rx1596_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1596_pos, "")
    rx1596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1601_done
  rxcap_1601_fail:
    goto rx1596_fail
  rxcap_1601_done:
  # rx subrule "O" subtype=capture negate=
    rx1596_cur."!cursor_pos"(rx1596_pos)
    $P10 = rx1596_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1596_fail
    rx1596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1596_pos = $P10."pos"()
  # rx pass
    rx1596_cur."!cursor_pass"(rx1596_pos, "prefix:sym<++>")
    if_null rx1596_debug, debug_1216
    rx1596_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1596_pos)
  debug_1216:
    .return (rx1596_cur)
  rx1596_restart:
.annotate 'line', 10
    if_null rx1596_debug, debug_1217
    rx1596_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1217:
  rx1596_fail:
    (rx1596_rep, rx1596_pos, $I10, $P10) = rx1596_cur."!mark_fail"(0)
    lt rx1596_pos, -1, rx1596_done
    eq rx1596_pos, -1, rx1596_fail
    jump $I10
  rx1596_done:
    rx1596_cur."!cursor_fail"()
    if_null rx1596_debug, debug_1218
    rx1596_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1218:
    .return (rx1596_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("289_1303923618.727") :method
.annotate 'line', 10
    $P1598 = self."!PREFIX__!subrule"("O", "++")
    new $P1599, "ResizablePMCArray"
    push $P1599, $P1598
    .return ($P1599)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("290_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1603_tgt
    .local int rx1603_pos
    .local int rx1603_off
    .local int rx1603_eos
    .local int rx1603_rep
    .local pmc rx1603_cur
    .local pmc rx1603_debug
    (rx1603_cur, rx1603_pos, rx1603_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1603_cur
    .local pmc match
    .lex "$/", match
    length rx1603_eos, rx1603_tgt
    gt rx1603_pos, rx1603_eos, rx1603_done
    set rx1603_off, 0
    lt rx1603_pos, 2, rx1603_start
    sub rx1603_off, rx1603_pos, 1
    substr rx1603_tgt, rx1603_tgt, rx1603_off
  rx1603_start:
    eq $I10, 1, rx1603_restart
    if_null rx1603_debug, debug_1219
    rx1603_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1219:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1607_done
    goto rxscan1607_scan
  rxscan1607_loop:
    (rx1603_pos) = rx1603_cur."from"()
    inc rx1603_pos
    rx1603_cur."!cursor_from"(rx1603_pos)
    ge rx1603_pos, rx1603_eos, rxscan1607_done
  rxscan1607_scan:
    set_addr $I10, rxscan1607_loop
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  rxscan1607_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1608_fail
    rx1603_cur."!mark_push"(0, rx1603_pos, $I10)
  # rx literal  "--"
    add $I11, rx1603_pos, 2
    gt $I11, rx1603_eos, rx1603_fail
    sub $I11, rx1603_pos, rx1603_off
    substr $S10, rx1603_tgt, $I11, 2
    ne $S10, "--", rx1603_fail
    add rx1603_pos, 2
    set_addr $I10, rxcap_1608_fail
    ($I12, $I11) = rx1603_cur."!mark_peek"($I10)
    rx1603_cur."!cursor_pos"($I11)
    ($P10) = rx1603_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1603_pos, "")
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1608_done
  rxcap_1608_fail:
    goto rx1603_fail
  rxcap_1608_done:
  # rx subrule "O" subtype=capture negate=
    rx1603_cur."!cursor_pos"(rx1603_pos)
    $P10 = rx1603_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1603_fail
    rx1603_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1603_pos = $P10."pos"()
  # rx pass
    rx1603_cur."!cursor_pass"(rx1603_pos, "prefix:sym<-->")
    if_null rx1603_debug, debug_1220
    rx1603_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1603_pos)
  debug_1220:
    .return (rx1603_cur)
  rx1603_restart:
.annotate 'line', 10
    if_null rx1603_debug, debug_1221
    rx1603_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1221:
  rx1603_fail:
    (rx1603_rep, rx1603_pos, $I10, $P10) = rx1603_cur."!mark_fail"(0)
    lt rx1603_pos, -1, rx1603_done
    eq rx1603_pos, -1, rx1603_fail
    jump $I10
  rx1603_done:
    rx1603_cur."!cursor_fail"()
    if_null rx1603_debug, debug_1222
    rx1603_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1222:
    .return (rx1603_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("291_1303923618.727") :method
.annotate 'line', 10
    $P1605 = self."!PREFIX__!subrule"("O", "--")
    new $P1606, "ResizablePMCArray"
    push $P1606, $P1605
    .return ($P1606)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("292_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1610_tgt
    .local int rx1610_pos
    .local int rx1610_off
    .local int rx1610_eos
    .local int rx1610_rep
    .local pmc rx1610_cur
    .local pmc rx1610_debug
    (rx1610_cur, rx1610_pos, rx1610_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1610_cur
    .local pmc match
    .lex "$/", match
    length rx1610_eos, rx1610_tgt
    gt rx1610_pos, rx1610_eos, rx1610_done
    set rx1610_off, 0
    lt rx1610_pos, 2, rx1610_start
    sub rx1610_off, rx1610_pos, 1
    substr rx1610_tgt, rx1610_tgt, rx1610_off
  rx1610_start:
    eq $I10, 1, rx1610_restart
    if_null rx1610_debug, debug_1223
    rx1610_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1223:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1614_done
    goto rxscan1614_scan
  rxscan1614_loop:
    (rx1610_pos) = rx1610_cur."from"()
    inc rx1610_pos
    rx1610_cur."!cursor_from"(rx1610_pos)
    ge rx1610_pos, rx1610_eos, rxscan1614_done
  rxscan1614_scan:
    set_addr $I10, rxscan1614_loop
    rx1610_cur."!mark_push"(0, rx1610_pos, $I10)
  rxscan1614_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1615_fail
    rx1610_cur."!mark_push"(0, rx1610_pos, $I10)
  # rx literal  "++"
    add $I11, rx1610_pos, 2
    gt $I11, rx1610_eos, rx1610_fail
    sub $I11, rx1610_pos, rx1610_off
    substr $S10, rx1610_tgt, $I11, 2
    ne $S10, "++", rx1610_fail
    add rx1610_pos, 2
    set_addr $I10, rxcap_1615_fail
    ($I12, $I11) = rx1610_cur."!mark_peek"($I10)
    rx1610_cur."!cursor_pos"($I11)
    ($P10) = rx1610_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1610_pos, "")
    rx1610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1615_done
  rxcap_1615_fail:
    goto rx1610_fail
  rxcap_1615_done:
  # rx subrule "O" subtype=capture negate=
    rx1610_cur."!cursor_pos"(rx1610_pos)
    $P10 = rx1610_cur."O"("%autoincrement")
    unless $P10, rx1610_fail
    rx1610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1610_pos = $P10."pos"()
  # rx pass
    rx1610_cur."!cursor_pass"(rx1610_pos, "postfix:sym<++>")
    if_null rx1610_debug, debug_1224
    rx1610_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1610_pos)
  debug_1224:
    .return (rx1610_cur)
  rx1610_restart:
.annotate 'line', 10
    if_null rx1610_debug, debug_1225
    rx1610_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1225:
  rx1610_fail:
    (rx1610_rep, rx1610_pos, $I10, $P10) = rx1610_cur."!mark_fail"(0)
    lt rx1610_pos, -1, rx1610_done
    eq rx1610_pos, -1, rx1610_fail
    jump $I10
  rx1610_done:
    rx1610_cur."!cursor_fail"()
    if_null rx1610_debug, debug_1226
    rx1610_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1226:
    .return (rx1610_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("293_1303923618.727") :method
.annotate 'line', 10
    $P1612 = self."!PREFIX__!subrule"("O", "++")
    new $P1613, "ResizablePMCArray"
    push $P1613, $P1612
    .return ($P1613)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("294_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1617_tgt
    .local int rx1617_pos
    .local int rx1617_off
    .local int rx1617_eos
    .local int rx1617_rep
    .local pmc rx1617_cur
    .local pmc rx1617_debug
    (rx1617_cur, rx1617_pos, rx1617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1617_cur
    .local pmc match
    .lex "$/", match
    length rx1617_eos, rx1617_tgt
    gt rx1617_pos, rx1617_eos, rx1617_done
    set rx1617_off, 0
    lt rx1617_pos, 2, rx1617_start
    sub rx1617_off, rx1617_pos, 1
    substr rx1617_tgt, rx1617_tgt, rx1617_off
  rx1617_start:
    eq $I10, 1, rx1617_restart
    if_null rx1617_debug, debug_1227
    rx1617_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1227:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1621_done
    goto rxscan1621_scan
  rxscan1621_loop:
    (rx1617_pos) = rx1617_cur."from"()
    inc rx1617_pos
    rx1617_cur."!cursor_from"(rx1617_pos)
    ge rx1617_pos, rx1617_eos, rxscan1621_done
  rxscan1621_scan:
    set_addr $I10, rxscan1621_loop
    rx1617_cur."!mark_push"(0, rx1617_pos, $I10)
  rxscan1621_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1622_fail
    rx1617_cur."!mark_push"(0, rx1617_pos, $I10)
  # rx literal  "--"
    add $I11, rx1617_pos, 2
    gt $I11, rx1617_eos, rx1617_fail
    sub $I11, rx1617_pos, rx1617_off
    substr $S10, rx1617_tgt, $I11, 2
    ne $S10, "--", rx1617_fail
    add rx1617_pos, 2
    set_addr $I10, rxcap_1622_fail
    ($I12, $I11) = rx1617_cur."!mark_peek"($I10)
    rx1617_cur."!cursor_pos"($I11)
    ($P10) = rx1617_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1617_pos, "")
    rx1617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1622_done
  rxcap_1622_fail:
    goto rx1617_fail
  rxcap_1622_done:
  # rx subrule "O" subtype=capture negate=
    rx1617_cur."!cursor_pos"(rx1617_pos)
    $P10 = rx1617_cur."O"("%autoincrement")
    unless $P10, rx1617_fail
    rx1617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1617_pos = $P10."pos"()
  # rx pass
    rx1617_cur."!cursor_pass"(rx1617_pos, "postfix:sym<-->")
    if_null rx1617_debug, debug_1228
    rx1617_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1617_pos)
  debug_1228:
    .return (rx1617_cur)
  rx1617_restart:
.annotate 'line', 10
    if_null rx1617_debug, debug_1229
    rx1617_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1229:
  rx1617_fail:
    (rx1617_rep, rx1617_pos, $I10, $P10) = rx1617_cur."!mark_fail"(0)
    lt rx1617_pos, -1, rx1617_done
    eq rx1617_pos, -1, rx1617_fail
    jump $I10
  rx1617_done:
    rx1617_cur."!cursor_fail"()
    if_null rx1617_debug, debug_1230
    rx1617_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1230:
    .return (rx1617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("295_1303923618.727") :method
.annotate 'line', 10
    $P1619 = self."!PREFIX__!subrule"("O", "--")
    new $P1620, "ResizablePMCArray"
    push $P1620, $P1619
    .return ($P1620)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("296_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1624_tgt
    .local int rx1624_pos
    .local int rx1624_off
    .local int rx1624_eos
    .local int rx1624_rep
    .local pmc rx1624_cur
    .local pmc rx1624_debug
    (rx1624_cur, rx1624_pos, rx1624_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1624_cur
    .local pmc match
    .lex "$/", match
    length rx1624_eos, rx1624_tgt
    gt rx1624_pos, rx1624_eos, rx1624_done
    set rx1624_off, 0
    lt rx1624_pos, 2, rx1624_start
    sub rx1624_off, rx1624_pos, 1
    substr rx1624_tgt, rx1624_tgt, rx1624_off
  rx1624_start:
    eq $I10, 1, rx1624_restart
    if_null rx1624_debug, debug_1231
    rx1624_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1628_done
    goto rxscan1628_scan
  rxscan1628_loop:
    (rx1624_pos) = rx1624_cur."from"()
    inc rx1624_pos
    rx1624_cur."!cursor_from"(rx1624_pos)
    ge rx1624_pos, rx1624_eos, rxscan1628_done
  rxscan1628_scan:
    set_addr $I10, rxscan1628_loop
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  rxscan1628_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1629_fail
    rx1624_cur."!mark_push"(0, rx1624_pos, $I10)
  # rx literal  "**"
    add $I11, rx1624_pos, 2
    gt $I11, rx1624_eos, rx1624_fail
    sub $I11, rx1624_pos, rx1624_off
    substr $S10, rx1624_tgt, $I11, 2
    ne $S10, "**", rx1624_fail
    add rx1624_pos, 2
    set_addr $I10, rxcap_1629_fail
    ($I12, $I11) = rx1624_cur."!mark_peek"($I10)
    rx1624_cur."!cursor_pos"($I11)
    ($P10) = rx1624_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1624_pos, "")
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1629_done
  rxcap_1629_fail:
    goto rx1624_fail
  rxcap_1629_done:
  # rx subrule "O" subtype=capture negate=
    rx1624_cur."!cursor_pos"(rx1624_pos)
    $P10 = rx1624_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1624_fail
    rx1624_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1624_pos = $P10."pos"()
  # rx pass
    rx1624_cur."!cursor_pass"(rx1624_pos, "infix:sym<**>")
    if_null rx1624_debug, debug_1232
    rx1624_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1624_pos)
  debug_1232:
    .return (rx1624_cur)
  rx1624_restart:
.annotate 'line', 10
    if_null rx1624_debug, debug_1233
    rx1624_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1233:
  rx1624_fail:
    (rx1624_rep, rx1624_pos, $I10, $P10) = rx1624_cur."!mark_fail"(0)
    lt rx1624_pos, -1, rx1624_done
    eq rx1624_pos, -1, rx1624_fail
    jump $I10
  rx1624_done:
    rx1624_cur."!cursor_fail"()
    if_null rx1624_debug, debug_1234
    rx1624_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1234:
    .return (rx1624_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("297_1303923618.727") :method
.annotate 'line', 10
    $P1626 = self."!PREFIX__!subrule"("O", "**")
    new $P1627, "ResizablePMCArray"
    push $P1627, $P1626
    .return ($P1627)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("298_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1631_tgt
    .local int rx1631_pos
    .local int rx1631_off
    .local int rx1631_eos
    .local int rx1631_rep
    .local pmc rx1631_cur
    .local pmc rx1631_debug
    (rx1631_cur, rx1631_pos, rx1631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1631_cur
    .local pmc match
    .lex "$/", match
    length rx1631_eos, rx1631_tgt
    gt rx1631_pos, rx1631_eos, rx1631_done
    set rx1631_off, 0
    lt rx1631_pos, 2, rx1631_start
    sub rx1631_off, rx1631_pos, 1
    substr rx1631_tgt, rx1631_tgt, rx1631_off
  rx1631_start:
    eq $I10, 1, rx1631_restart
    if_null rx1631_debug, debug_1235
    rx1631_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1635_done
    goto rxscan1635_scan
  rxscan1635_loop:
    (rx1631_pos) = rx1631_cur."from"()
    inc rx1631_pos
    rx1631_cur."!cursor_from"(rx1631_pos)
    ge rx1631_pos, rx1631_eos, rxscan1635_done
  rxscan1635_scan:
    set_addr $I10, rxscan1635_loop
    rx1631_cur."!mark_push"(0, rx1631_pos, $I10)
  rxscan1635_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1636_fail
    rx1631_cur."!mark_push"(0, rx1631_pos, $I10)
  # rx literal  "+"
    add $I11, rx1631_pos, 1
    gt $I11, rx1631_eos, rx1631_fail
    sub $I11, rx1631_pos, rx1631_off
    ord $I11, rx1631_tgt, $I11
    ne $I11, 43, rx1631_fail
    add rx1631_pos, 1
    set_addr $I10, rxcap_1636_fail
    ($I12, $I11) = rx1631_cur."!mark_peek"($I10)
    rx1631_cur."!cursor_pos"($I11)
    ($P10) = rx1631_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1631_pos, "")
    rx1631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1636_done
  rxcap_1636_fail:
    goto rx1631_fail
  rxcap_1636_done:
  # rx subrule "O" subtype=capture negate=
    rx1631_cur."!cursor_pos"(rx1631_pos)
    $P10 = rx1631_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1631_fail
    rx1631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1631_pos = $P10."pos"()
  # rx pass
    rx1631_cur."!cursor_pass"(rx1631_pos, "prefix:sym<+>")
    if_null rx1631_debug, debug_1236
    rx1631_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1631_pos)
  debug_1236:
    .return (rx1631_cur)
  rx1631_restart:
.annotate 'line', 10
    if_null rx1631_debug, debug_1237
    rx1631_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1237:
  rx1631_fail:
    (rx1631_rep, rx1631_pos, $I10, $P10) = rx1631_cur."!mark_fail"(0)
    lt rx1631_pos, -1, rx1631_done
    eq rx1631_pos, -1, rx1631_fail
    jump $I10
  rx1631_done:
    rx1631_cur."!cursor_fail"()
    if_null rx1631_debug, debug_1238
    rx1631_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1238:
    .return (rx1631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("299_1303923618.727") :method
.annotate 'line', 10
    $P1633 = self."!PREFIX__!subrule"("O", "+")
    new $P1634, "ResizablePMCArray"
    push $P1634, $P1633
    .return ($P1634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("300_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1638_tgt
    .local int rx1638_pos
    .local int rx1638_off
    .local int rx1638_eos
    .local int rx1638_rep
    .local pmc rx1638_cur
    .local pmc rx1638_debug
    (rx1638_cur, rx1638_pos, rx1638_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1638_cur
    .local pmc match
    .lex "$/", match
    length rx1638_eos, rx1638_tgt
    gt rx1638_pos, rx1638_eos, rx1638_done
    set rx1638_off, 0
    lt rx1638_pos, 2, rx1638_start
    sub rx1638_off, rx1638_pos, 1
    substr rx1638_tgt, rx1638_tgt, rx1638_off
  rx1638_start:
    eq $I10, 1, rx1638_restart
    if_null rx1638_debug, debug_1239
    rx1638_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1642_done
    goto rxscan1642_scan
  rxscan1642_loop:
    (rx1638_pos) = rx1638_cur."from"()
    inc rx1638_pos
    rx1638_cur."!cursor_from"(rx1638_pos)
    ge rx1638_pos, rx1638_eos, rxscan1642_done
  rxscan1642_scan:
    set_addr $I10, rxscan1642_loop
    rx1638_cur."!mark_push"(0, rx1638_pos, $I10)
  rxscan1642_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1643_fail
    rx1638_cur."!mark_push"(0, rx1638_pos, $I10)
  # rx literal  "~"
    add $I11, rx1638_pos, 1
    gt $I11, rx1638_eos, rx1638_fail
    sub $I11, rx1638_pos, rx1638_off
    ord $I11, rx1638_tgt, $I11
    ne $I11, 126, rx1638_fail
    add rx1638_pos, 1
    set_addr $I10, rxcap_1643_fail
    ($I12, $I11) = rx1638_cur."!mark_peek"($I10)
    rx1638_cur."!cursor_pos"($I11)
    ($P10) = rx1638_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1638_pos, "")
    rx1638_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1643_done
  rxcap_1643_fail:
    goto rx1638_fail
  rxcap_1643_done:
  # rx subrule "O" subtype=capture negate=
    rx1638_cur."!cursor_pos"(rx1638_pos)
    $P10 = rx1638_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1638_fail
    rx1638_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1638_pos = $P10."pos"()
  # rx pass
    rx1638_cur."!cursor_pass"(rx1638_pos, "prefix:sym<~>")
    if_null rx1638_debug, debug_1240
    rx1638_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1638_pos)
  debug_1240:
    .return (rx1638_cur)
  rx1638_restart:
.annotate 'line', 10
    if_null rx1638_debug, debug_1241
    rx1638_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1241:
  rx1638_fail:
    (rx1638_rep, rx1638_pos, $I10, $P10) = rx1638_cur."!mark_fail"(0)
    lt rx1638_pos, -1, rx1638_done
    eq rx1638_pos, -1, rx1638_fail
    jump $I10
  rx1638_done:
    rx1638_cur."!cursor_fail"()
    if_null rx1638_debug, debug_1242
    rx1638_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1242:
    .return (rx1638_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("301_1303923618.727") :method
.annotate 'line', 10
    $P1640 = self."!PREFIX__!subrule"("O", "~")
    new $P1641, "ResizablePMCArray"
    push $P1641, $P1640
    .return ($P1641)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("302_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1645_tgt
    .local int rx1645_pos
    .local int rx1645_off
    .local int rx1645_eos
    .local int rx1645_rep
    .local pmc rx1645_cur
    .local pmc rx1645_debug
    (rx1645_cur, rx1645_pos, rx1645_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1645_cur
    .local pmc match
    .lex "$/", match
    length rx1645_eos, rx1645_tgt
    gt rx1645_pos, rx1645_eos, rx1645_done
    set rx1645_off, 0
    lt rx1645_pos, 2, rx1645_start
    sub rx1645_off, rx1645_pos, 1
    substr rx1645_tgt, rx1645_tgt, rx1645_off
  rx1645_start:
    eq $I10, 1, rx1645_restart
    if_null rx1645_debug, debug_1243
    rx1645_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1648_done
    goto rxscan1648_scan
  rxscan1648_loop:
    (rx1645_pos) = rx1645_cur."from"()
    inc rx1645_pos
    rx1645_cur."!cursor_from"(rx1645_pos)
    ge rx1645_pos, rx1645_eos, rxscan1648_done
  rxscan1648_scan:
    set_addr $I10, rxscan1648_loop
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  rxscan1648_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1649_fail
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  # rx literal  "-"
    add $I11, rx1645_pos, 1
    gt $I11, rx1645_eos, rx1645_fail
    sub $I11, rx1645_pos, rx1645_off
    ord $I11, rx1645_tgt, $I11
    ne $I11, 45, rx1645_fail
    add rx1645_pos, 1
    set_addr $I10, rxcap_1649_fail
    ($I12, $I11) = rx1645_cur."!mark_peek"($I10)
    rx1645_cur."!cursor_pos"($I11)
    ($P10) = rx1645_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1645_pos, "")
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1649_done
  rxcap_1649_fail:
    goto rx1645_fail
  rxcap_1649_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1645_pos, rx1645_off
    substr $S10, rx1645_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1645_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."number"()
    if $P10, rx1645_fail
  # rx subrule "O" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1645_pos = $P10."pos"()
  # rx pass
    rx1645_cur."!cursor_pass"(rx1645_pos, "prefix:sym<->")
    if_null rx1645_debug, debug_1244
    rx1645_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1645_pos)
  debug_1244:
    .return (rx1645_cur)
  rx1645_restart:
.annotate 'line', 10
    if_null rx1645_debug, debug_1245
    rx1645_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1245:
  rx1645_fail:
    (rx1645_rep, rx1645_pos, $I10, $P10) = rx1645_cur."!mark_fail"(0)
    lt rx1645_pos, -1, rx1645_done
    eq rx1645_pos, -1, rx1645_fail
    jump $I10
  rx1645_done:
    rx1645_cur."!cursor_fail"()
    if_null rx1645_debug, debug_1246
    rx1645_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1246:
    .return (rx1645_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("303_1303923618.727") :method
.annotate 'line', 10
    new $P1647, "ResizablePMCArray"
    push $P1647, "-"
    .return ($P1647)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("304_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1651_tgt
    .local int rx1651_pos
    .local int rx1651_off
    .local int rx1651_eos
    .local int rx1651_rep
    .local pmc rx1651_cur
    .local pmc rx1651_debug
    (rx1651_cur, rx1651_pos, rx1651_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1651_cur
    .local pmc match
    .lex "$/", match
    length rx1651_eos, rx1651_tgt
    gt rx1651_pos, rx1651_eos, rx1651_done
    set rx1651_off, 0
    lt rx1651_pos, 2, rx1651_start
    sub rx1651_off, rx1651_pos, 1
    substr rx1651_tgt, rx1651_tgt, rx1651_off
  rx1651_start:
    eq $I10, 1, rx1651_restart
    if_null rx1651_debug, debug_1247
    rx1651_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1651_pos) = rx1651_cur."from"()
    inc rx1651_pos
    rx1651_cur."!cursor_from"(rx1651_pos)
    ge rx1651_pos, rx1651_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1651_cur."!mark_push"(0, rx1651_pos, $I10)
  rxscan1655_done:
.annotate 'line', 664
  # rx subcapture "sym"
    set_addr $I10, rxcap_1656_fail
    rx1651_cur."!mark_push"(0, rx1651_pos, $I10)
  # rx literal  "?"
    add $I11, rx1651_pos, 1
    gt $I11, rx1651_eos, rx1651_fail
    sub $I11, rx1651_pos, rx1651_off
    ord $I11, rx1651_tgt, $I11
    ne $I11, 63, rx1651_fail
    add rx1651_pos, 1
    set_addr $I10, rxcap_1656_fail
    ($I12, $I11) = rx1651_cur."!mark_peek"($I10)
    rx1651_cur."!cursor_pos"($I11)
    ($P10) = rx1651_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1651_pos, "")
    rx1651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1656_done
  rxcap_1656_fail:
    goto rx1651_fail
  rxcap_1656_done:
  # rx subrule "O" subtype=capture negate=
    rx1651_cur."!cursor_pos"(rx1651_pos)
    $P10 = rx1651_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1651_fail
    rx1651_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1651_pos = $P10."pos"()
  # rx pass
    rx1651_cur."!cursor_pass"(rx1651_pos, "prefix:sym<?>")
    if_null rx1651_debug, debug_1248
    rx1651_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1651_pos)
  debug_1248:
    .return (rx1651_cur)
  rx1651_restart:
.annotate 'line', 10
    if_null rx1651_debug, debug_1249
    rx1651_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1249:
  rx1651_fail:
    (rx1651_rep, rx1651_pos, $I10, $P10) = rx1651_cur."!mark_fail"(0)
    lt rx1651_pos, -1, rx1651_done
    eq rx1651_pos, -1, rx1651_fail
    jump $I10
  rx1651_done:
    rx1651_cur."!cursor_fail"()
    if_null rx1651_debug, debug_1250
    rx1651_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1250:
    .return (rx1651_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("305_1303923618.727") :method
.annotate 'line', 10
    $P1653 = self."!PREFIX__!subrule"("O", "?")
    new $P1654, "ResizablePMCArray"
    push $P1654, $P1653
    .return ($P1654)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("306_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1658_tgt
    .local int rx1658_pos
    .local int rx1658_off
    .local int rx1658_eos
    .local int rx1658_rep
    .local pmc rx1658_cur
    .local pmc rx1658_debug
    (rx1658_cur, rx1658_pos, rx1658_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1658_cur
    .local pmc match
    .lex "$/", match
    length rx1658_eos, rx1658_tgt
    gt rx1658_pos, rx1658_eos, rx1658_done
    set rx1658_off, 0
    lt rx1658_pos, 2, rx1658_start
    sub rx1658_off, rx1658_pos, 1
    substr rx1658_tgt, rx1658_tgt, rx1658_off
  rx1658_start:
    eq $I10, 1, rx1658_restart
    if_null rx1658_debug, debug_1251
    rx1658_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1662_done
    goto rxscan1662_scan
  rxscan1662_loop:
    (rx1658_pos) = rx1658_cur."from"()
    inc rx1658_pos
    rx1658_cur."!cursor_from"(rx1658_pos)
    ge rx1658_pos, rx1658_eos, rxscan1662_done
  rxscan1662_scan:
    set_addr $I10, rxscan1662_loop
    rx1658_cur."!mark_push"(0, rx1658_pos, $I10)
  rxscan1662_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1663_fail
    rx1658_cur."!mark_push"(0, rx1658_pos, $I10)
  # rx literal  "!"
    add $I11, rx1658_pos, 1
    gt $I11, rx1658_eos, rx1658_fail
    sub $I11, rx1658_pos, rx1658_off
    ord $I11, rx1658_tgt, $I11
    ne $I11, 33, rx1658_fail
    add rx1658_pos, 1
    set_addr $I10, rxcap_1663_fail
    ($I12, $I11) = rx1658_cur."!mark_peek"($I10)
    rx1658_cur."!cursor_pos"($I11)
    ($P10) = rx1658_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1658_pos, "")
    rx1658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1663_done
  rxcap_1663_fail:
    goto rx1658_fail
  rxcap_1663_done:
  # rx subrule "O" subtype=capture negate=
    rx1658_cur."!cursor_pos"(rx1658_pos)
    $P10 = rx1658_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1658_fail
    rx1658_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1658_pos = $P10."pos"()
  # rx pass
    rx1658_cur."!cursor_pass"(rx1658_pos, "prefix:sym<!>")
    if_null rx1658_debug, debug_1252
    rx1658_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1658_pos)
  debug_1252:
    .return (rx1658_cur)
  rx1658_restart:
.annotate 'line', 10
    if_null rx1658_debug, debug_1253
    rx1658_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1253:
  rx1658_fail:
    (rx1658_rep, rx1658_pos, $I10, $P10) = rx1658_cur."!mark_fail"(0)
    lt rx1658_pos, -1, rx1658_done
    eq rx1658_pos, -1, rx1658_fail
    jump $I10
  rx1658_done:
    rx1658_cur."!cursor_fail"()
    if_null rx1658_debug, debug_1254
    rx1658_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1254:
    .return (rx1658_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("307_1303923618.727") :method
.annotate 'line', 10
    $P1660 = self."!PREFIX__!subrule"("O", "!")
    new $P1661, "ResizablePMCArray"
    push $P1661, $P1660
    .return ($P1661)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("308_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1665_tgt
    .local int rx1665_pos
    .local int rx1665_off
    .local int rx1665_eos
    .local int rx1665_rep
    .local pmc rx1665_cur
    .local pmc rx1665_debug
    (rx1665_cur, rx1665_pos, rx1665_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1665_cur
    .local pmc match
    .lex "$/", match
    length rx1665_eos, rx1665_tgt
    gt rx1665_pos, rx1665_eos, rx1665_done
    set rx1665_off, 0
    lt rx1665_pos, 2, rx1665_start
    sub rx1665_off, rx1665_pos, 1
    substr rx1665_tgt, rx1665_tgt, rx1665_off
  rx1665_start:
    eq $I10, 1, rx1665_restart
    if_null rx1665_debug, debug_1255
    rx1665_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1669_done
    goto rxscan1669_scan
  rxscan1669_loop:
    (rx1665_pos) = rx1665_cur."from"()
    inc rx1665_pos
    rx1665_cur."!cursor_from"(rx1665_pos)
    ge rx1665_pos, rx1665_eos, rxscan1669_done
  rxscan1669_scan:
    set_addr $I10, rxscan1669_loop
    rx1665_cur."!mark_push"(0, rx1665_pos, $I10)
  rxscan1669_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1670_fail
    rx1665_cur."!mark_push"(0, rx1665_pos, $I10)
  # rx literal  "|"
    add $I11, rx1665_pos, 1
    gt $I11, rx1665_eos, rx1665_fail
    sub $I11, rx1665_pos, rx1665_off
    ord $I11, rx1665_tgt, $I11
    ne $I11, 124, rx1665_fail
    add rx1665_pos, 1
    set_addr $I10, rxcap_1670_fail
    ($I12, $I11) = rx1665_cur."!mark_peek"($I10)
    rx1665_cur."!cursor_pos"($I11)
    ($P10) = rx1665_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1665_pos, "")
    rx1665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1670_done
  rxcap_1670_fail:
    goto rx1665_fail
  rxcap_1670_done:
  # rx subrule "O" subtype=capture negate=
    rx1665_cur."!cursor_pos"(rx1665_pos)
    $P10 = rx1665_cur."O"("%symbolic_unary")
    unless $P10, rx1665_fail
    rx1665_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1665_pos = $P10."pos"()
  # rx pass
    rx1665_cur."!cursor_pass"(rx1665_pos, "prefix:sym<|>")
    if_null rx1665_debug, debug_1256
    rx1665_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1665_pos)
  debug_1256:
    .return (rx1665_cur)
  rx1665_restart:
.annotate 'line', 10
    if_null rx1665_debug, debug_1257
    rx1665_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1257:
  rx1665_fail:
    (rx1665_rep, rx1665_pos, $I10, $P10) = rx1665_cur."!mark_fail"(0)
    lt rx1665_pos, -1, rx1665_done
    eq rx1665_pos, -1, rx1665_fail
    jump $I10
  rx1665_done:
    rx1665_cur."!cursor_fail"()
    if_null rx1665_debug, debug_1258
    rx1665_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1258:
    .return (rx1665_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("309_1303923618.727") :method
.annotate 'line', 10
    $P1667 = self."!PREFIX__!subrule"("O", "|")
    new $P1668, "ResizablePMCArray"
    push $P1668, $P1667
    .return ($P1668)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("310_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1672_tgt
    .local int rx1672_pos
    .local int rx1672_off
    .local int rx1672_eos
    .local int rx1672_rep
    .local pmc rx1672_cur
    .local pmc rx1672_debug
    (rx1672_cur, rx1672_pos, rx1672_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1672_cur
    .local pmc match
    .lex "$/", match
    length rx1672_eos, rx1672_tgt
    gt rx1672_pos, rx1672_eos, rx1672_done
    set rx1672_off, 0
    lt rx1672_pos, 2, rx1672_start
    sub rx1672_off, rx1672_pos, 1
    substr rx1672_tgt, rx1672_tgt, rx1672_off
  rx1672_start:
    eq $I10, 1, rx1672_restart
    if_null rx1672_debug, debug_1259
    rx1672_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1676_done
    goto rxscan1676_scan
  rxscan1676_loop:
    (rx1672_pos) = rx1672_cur."from"()
    inc rx1672_pos
    rx1672_cur."!cursor_from"(rx1672_pos)
    ge rx1672_pos, rx1672_eos, rxscan1676_done
  rxscan1676_scan:
    set_addr $I10, rxscan1676_loop
    rx1672_cur."!mark_push"(0, rx1672_pos, $I10)
  rxscan1676_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1677_fail
    rx1672_cur."!mark_push"(0, rx1672_pos, $I10)
  # rx literal  "*"
    add $I11, rx1672_pos, 1
    gt $I11, rx1672_eos, rx1672_fail
    sub $I11, rx1672_pos, rx1672_off
    ord $I11, rx1672_tgt, $I11
    ne $I11, 42, rx1672_fail
    add rx1672_pos, 1
    set_addr $I10, rxcap_1677_fail
    ($I12, $I11) = rx1672_cur."!mark_peek"($I10)
    rx1672_cur."!cursor_pos"($I11)
    ($P10) = rx1672_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1672_pos, "")
    rx1672_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1677_done
  rxcap_1677_fail:
    goto rx1672_fail
  rxcap_1677_done:
  # rx subrule "O" subtype=capture negate=
    rx1672_cur."!cursor_pos"(rx1672_pos)
    $P10 = rx1672_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1672_fail
    rx1672_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1672_pos = $P10."pos"()
  # rx pass
    rx1672_cur."!cursor_pass"(rx1672_pos, "infix:sym<*>")
    if_null rx1672_debug, debug_1260
    rx1672_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1672_pos)
  debug_1260:
    .return (rx1672_cur)
  rx1672_restart:
.annotate 'line', 10
    if_null rx1672_debug, debug_1261
    rx1672_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1261:
  rx1672_fail:
    (rx1672_rep, rx1672_pos, $I10, $P10) = rx1672_cur."!mark_fail"(0)
    lt rx1672_pos, -1, rx1672_done
    eq rx1672_pos, -1, rx1672_fail
    jump $I10
  rx1672_done:
    rx1672_cur."!cursor_fail"()
    if_null rx1672_debug, debug_1262
    rx1672_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1262:
    .return (rx1672_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("311_1303923618.727") :method
.annotate 'line', 10
    $P1674 = self."!PREFIX__!subrule"("O", "*")
    new $P1675, "ResizablePMCArray"
    push $P1675, $P1674
    .return ($P1675)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("312_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1679_tgt
    .local int rx1679_pos
    .local int rx1679_off
    .local int rx1679_eos
    .local int rx1679_rep
    .local pmc rx1679_cur
    .local pmc rx1679_debug
    (rx1679_cur, rx1679_pos, rx1679_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1679_cur
    .local pmc match
    .lex "$/", match
    length rx1679_eos, rx1679_tgt
    gt rx1679_pos, rx1679_eos, rx1679_done
    set rx1679_off, 0
    lt rx1679_pos, 2, rx1679_start
    sub rx1679_off, rx1679_pos, 1
    substr rx1679_tgt, rx1679_tgt, rx1679_off
  rx1679_start:
    eq $I10, 1, rx1679_restart
    if_null rx1679_debug, debug_1263
    rx1679_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1263:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1683_done
    goto rxscan1683_scan
  rxscan1683_loop:
    (rx1679_pos) = rx1679_cur."from"()
    inc rx1679_pos
    rx1679_cur."!cursor_from"(rx1679_pos)
    ge rx1679_pos, rx1679_eos, rxscan1683_done
  rxscan1683_scan:
    set_addr $I10, rxscan1683_loop
    rx1679_cur."!mark_push"(0, rx1679_pos, $I10)
  rxscan1683_done:
.annotate 'line', 669
  # rx subcapture "sym"
    set_addr $I10, rxcap_1684_fail
    rx1679_cur."!mark_push"(0, rx1679_pos, $I10)
  # rx literal  "/"
    add $I11, rx1679_pos, 1
    gt $I11, rx1679_eos, rx1679_fail
    sub $I11, rx1679_pos, rx1679_off
    ord $I11, rx1679_tgt, $I11
    ne $I11, 47, rx1679_fail
    add rx1679_pos, 1
    set_addr $I10, rxcap_1684_fail
    ($I12, $I11) = rx1679_cur."!mark_peek"($I10)
    rx1679_cur."!cursor_pos"($I11)
    ($P10) = rx1679_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1679_pos, "")
    rx1679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1684_done
  rxcap_1684_fail:
    goto rx1679_fail
  rxcap_1684_done:
  # rx subrule "O" subtype=capture negate=
    rx1679_cur."!cursor_pos"(rx1679_pos)
    $P10 = rx1679_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1679_fail
    rx1679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1679_pos = $P10."pos"()
  # rx pass
    rx1679_cur."!cursor_pass"(rx1679_pos, "infix:sym</>")
    if_null rx1679_debug, debug_1264
    rx1679_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1679_pos)
  debug_1264:
    .return (rx1679_cur)
  rx1679_restart:
.annotate 'line', 10
    if_null rx1679_debug, debug_1265
    rx1679_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1265:
  rx1679_fail:
    (rx1679_rep, rx1679_pos, $I10, $P10) = rx1679_cur."!mark_fail"(0)
    lt rx1679_pos, -1, rx1679_done
    eq rx1679_pos, -1, rx1679_fail
    jump $I10
  rx1679_done:
    rx1679_cur."!cursor_fail"()
    if_null rx1679_debug, debug_1266
    rx1679_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1266:
    .return (rx1679_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("313_1303923618.727") :method
.annotate 'line', 10
    $P1681 = self."!PREFIX__!subrule"("O", "/")
    new $P1682, "ResizablePMCArray"
    push $P1682, $P1681
    .return ($P1682)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("314_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1686_tgt
    .local int rx1686_pos
    .local int rx1686_off
    .local int rx1686_eos
    .local int rx1686_rep
    .local pmc rx1686_cur
    .local pmc rx1686_debug
    (rx1686_cur, rx1686_pos, rx1686_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1686_cur
    .local pmc match
    .lex "$/", match
    length rx1686_eos, rx1686_tgt
    gt rx1686_pos, rx1686_eos, rx1686_done
    set rx1686_off, 0
    lt rx1686_pos, 2, rx1686_start
    sub rx1686_off, rx1686_pos, 1
    substr rx1686_tgt, rx1686_tgt, rx1686_off
  rx1686_start:
    eq $I10, 1, rx1686_restart
    if_null rx1686_debug, debug_1267
    rx1686_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1267:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1690_done
    goto rxscan1690_scan
  rxscan1690_loop:
    (rx1686_pos) = rx1686_cur."from"()
    inc rx1686_pos
    rx1686_cur."!cursor_from"(rx1686_pos)
    ge rx1686_pos, rx1686_eos, rxscan1690_done
  rxscan1690_scan:
    set_addr $I10, rxscan1690_loop
    rx1686_cur."!mark_push"(0, rx1686_pos, $I10)
  rxscan1690_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1691_fail
    rx1686_cur."!mark_push"(0, rx1686_pos, $I10)
  # rx literal  "%"
    add $I11, rx1686_pos, 1
    gt $I11, rx1686_eos, rx1686_fail
    sub $I11, rx1686_pos, rx1686_off
    ord $I11, rx1686_tgt, $I11
    ne $I11, 37, rx1686_fail
    add rx1686_pos, 1
    set_addr $I10, rxcap_1691_fail
    ($I12, $I11) = rx1686_cur."!mark_peek"($I10)
    rx1686_cur."!cursor_pos"($I11)
    ($P10) = rx1686_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1686_pos, "")
    rx1686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1691_done
  rxcap_1691_fail:
    goto rx1686_fail
  rxcap_1691_done:
  # rx subrule "O" subtype=capture negate=
    rx1686_cur."!cursor_pos"(rx1686_pos)
    $P10 = rx1686_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1686_fail
    rx1686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1686_pos = $P10."pos"()
  # rx pass
    rx1686_cur."!cursor_pass"(rx1686_pos, "infix:sym<%>")
    if_null rx1686_debug, debug_1268
    rx1686_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1686_pos)
  debug_1268:
    .return (rx1686_cur)
  rx1686_restart:
.annotate 'line', 10
    if_null rx1686_debug, debug_1269
    rx1686_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1269:
  rx1686_fail:
    (rx1686_rep, rx1686_pos, $I10, $P10) = rx1686_cur."!mark_fail"(0)
    lt rx1686_pos, -1, rx1686_done
    eq rx1686_pos, -1, rx1686_fail
    jump $I10
  rx1686_done:
    rx1686_cur."!cursor_fail"()
    if_null rx1686_debug, debug_1270
    rx1686_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1270:
    .return (rx1686_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("315_1303923618.727") :method
.annotate 'line', 10
    $P1688 = self."!PREFIX__!subrule"("O", "%")
    new $P1689, "ResizablePMCArray"
    push $P1689, $P1688
    .return ($P1689)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("316_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1693_tgt
    .local int rx1693_pos
    .local int rx1693_off
    .local int rx1693_eos
    .local int rx1693_rep
    .local pmc rx1693_cur
    .local pmc rx1693_debug
    (rx1693_cur, rx1693_pos, rx1693_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1693_cur
    .local pmc match
    .lex "$/", match
    length rx1693_eos, rx1693_tgt
    gt rx1693_pos, rx1693_eos, rx1693_done
    set rx1693_off, 0
    lt rx1693_pos, 2, rx1693_start
    sub rx1693_off, rx1693_pos, 1
    substr rx1693_tgt, rx1693_tgt, rx1693_off
  rx1693_start:
    eq $I10, 1, rx1693_restart
    if_null rx1693_debug, debug_1271
    rx1693_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1697_done
    goto rxscan1697_scan
  rxscan1697_loop:
    (rx1693_pos) = rx1693_cur."from"()
    inc rx1693_pos
    rx1693_cur."!cursor_from"(rx1693_pos)
    ge rx1693_pos, rx1693_eos, rxscan1697_done
  rxscan1697_scan:
    set_addr $I10, rxscan1697_loop
    rx1693_cur."!mark_push"(0, rx1693_pos, $I10)
  rxscan1697_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1698_fail
    rx1693_cur."!mark_push"(0, rx1693_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1693_pos, 2
    gt $I11, rx1693_eos, rx1693_fail
    sub $I11, rx1693_pos, rx1693_off
    substr $S10, rx1693_tgt, $I11, 2
    ne $S10, "+&", rx1693_fail
    add rx1693_pos, 2
    set_addr $I10, rxcap_1698_fail
    ($I12, $I11) = rx1693_cur."!mark_peek"($I10)
    rx1693_cur."!cursor_pos"($I11)
    ($P10) = rx1693_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1693_pos, "")
    rx1693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1698_done
  rxcap_1698_fail:
    goto rx1693_fail
  rxcap_1698_done:
  # rx subrule "O" subtype=capture negate=
    rx1693_cur."!cursor_pos"(rx1693_pos)
    $P10 = rx1693_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1693_fail
    rx1693_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1693_pos = $P10."pos"()
  # rx pass
    rx1693_cur."!cursor_pass"(rx1693_pos, "infix:sym<+&>")
    if_null rx1693_debug, debug_1272
    rx1693_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1693_pos)
  debug_1272:
    .return (rx1693_cur)
  rx1693_restart:
.annotate 'line', 10
    if_null rx1693_debug, debug_1273
    rx1693_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1273:
  rx1693_fail:
    (rx1693_rep, rx1693_pos, $I10, $P10) = rx1693_cur."!mark_fail"(0)
    lt rx1693_pos, -1, rx1693_done
    eq rx1693_pos, -1, rx1693_fail
    jump $I10
  rx1693_done:
    rx1693_cur."!cursor_fail"()
    if_null rx1693_debug, debug_1274
    rx1693_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1274:
    .return (rx1693_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("317_1303923618.727") :method
.annotate 'line', 10
    $P1695 = self."!PREFIX__!subrule"("O", "+&")
    new $P1696, "ResizablePMCArray"
    push $P1696, $P1695
    .return ($P1696)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("318_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1700_tgt
    .local int rx1700_pos
    .local int rx1700_off
    .local int rx1700_eos
    .local int rx1700_rep
    .local pmc rx1700_cur
    .local pmc rx1700_debug
    (rx1700_cur, rx1700_pos, rx1700_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1700_cur
    .local pmc match
    .lex "$/", match
    length rx1700_eos, rx1700_tgt
    gt rx1700_pos, rx1700_eos, rx1700_done
    set rx1700_off, 0
    lt rx1700_pos, 2, rx1700_start
    sub rx1700_off, rx1700_pos, 1
    substr rx1700_tgt, rx1700_tgt, rx1700_off
  rx1700_start:
    eq $I10, 1, rx1700_restart
    if_null rx1700_debug, debug_1275
    rx1700_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1704_done
    goto rxscan1704_scan
  rxscan1704_loop:
    (rx1700_pos) = rx1700_cur."from"()
    inc rx1700_pos
    rx1700_cur."!cursor_from"(rx1700_pos)
    ge rx1700_pos, rx1700_eos, rxscan1704_done
  rxscan1704_scan:
    set_addr $I10, rxscan1704_loop
    rx1700_cur."!mark_push"(0, rx1700_pos, $I10)
  rxscan1704_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1705_fail
    rx1700_cur."!mark_push"(0, rx1700_pos, $I10)
  # rx literal  "+"
    add $I11, rx1700_pos, 1
    gt $I11, rx1700_eos, rx1700_fail
    sub $I11, rx1700_pos, rx1700_off
    ord $I11, rx1700_tgt, $I11
    ne $I11, 43, rx1700_fail
    add rx1700_pos, 1
    set_addr $I10, rxcap_1705_fail
    ($I12, $I11) = rx1700_cur."!mark_peek"($I10)
    rx1700_cur."!cursor_pos"($I11)
    ($P10) = rx1700_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1700_pos, "")
    rx1700_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1705_done
  rxcap_1705_fail:
    goto rx1700_fail
  rxcap_1705_done:
  # rx subrule "O" subtype=capture negate=
    rx1700_cur."!cursor_pos"(rx1700_pos)
    $P10 = rx1700_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1700_fail
    rx1700_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1700_pos = $P10."pos"()
  # rx pass
    rx1700_cur."!cursor_pass"(rx1700_pos, "infix:sym<+>")
    if_null rx1700_debug, debug_1276
    rx1700_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1700_pos)
  debug_1276:
    .return (rx1700_cur)
  rx1700_restart:
.annotate 'line', 10
    if_null rx1700_debug, debug_1277
    rx1700_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1277:
  rx1700_fail:
    (rx1700_rep, rx1700_pos, $I10, $P10) = rx1700_cur."!mark_fail"(0)
    lt rx1700_pos, -1, rx1700_done
    eq rx1700_pos, -1, rx1700_fail
    jump $I10
  rx1700_done:
    rx1700_cur."!cursor_fail"()
    if_null rx1700_debug, debug_1278
    rx1700_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1278:
    .return (rx1700_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("319_1303923618.727") :method
.annotate 'line', 10
    $P1702 = self."!PREFIX__!subrule"("O", "+")
    new $P1703, "ResizablePMCArray"
    push $P1703, $P1702
    .return ($P1703)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("320_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1707_tgt
    .local int rx1707_pos
    .local int rx1707_off
    .local int rx1707_eos
    .local int rx1707_rep
    .local pmc rx1707_cur
    .local pmc rx1707_debug
    (rx1707_cur, rx1707_pos, rx1707_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1707_cur
    .local pmc match
    .lex "$/", match
    length rx1707_eos, rx1707_tgt
    gt rx1707_pos, rx1707_eos, rx1707_done
    set rx1707_off, 0
    lt rx1707_pos, 2, rx1707_start
    sub rx1707_off, rx1707_pos, 1
    substr rx1707_tgt, rx1707_tgt, rx1707_off
  rx1707_start:
    eq $I10, 1, rx1707_restart
    if_null rx1707_debug, debug_1279
    rx1707_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1711_done
    goto rxscan1711_scan
  rxscan1711_loop:
    (rx1707_pos) = rx1707_cur."from"()
    inc rx1707_pos
    rx1707_cur."!cursor_from"(rx1707_pos)
    ge rx1707_pos, rx1707_eos, rxscan1711_done
  rxscan1711_scan:
    set_addr $I10, rxscan1711_loop
    rx1707_cur."!mark_push"(0, rx1707_pos, $I10)
  rxscan1711_done:
.annotate 'line', 674
  # rx subcapture "sym"
    set_addr $I10, rxcap_1712_fail
    rx1707_cur."!mark_push"(0, rx1707_pos, $I10)
  # rx literal  "-"
    add $I11, rx1707_pos, 1
    gt $I11, rx1707_eos, rx1707_fail
    sub $I11, rx1707_pos, rx1707_off
    ord $I11, rx1707_tgt, $I11
    ne $I11, 45, rx1707_fail
    add rx1707_pos, 1
    set_addr $I10, rxcap_1712_fail
    ($I12, $I11) = rx1707_cur."!mark_peek"($I10)
    rx1707_cur."!cursor_pos"($I11)
    ($P10) = rx1707_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1707_pos, "")
    rx1707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1712_done
  rxcap_1712_fail:
    goto rx1707_fail
  rxcap_1712_done:
  # rx subrule "O" subtype=capture negate=
    rx1707_cur."!cursor_pos"(rx1707_pos)
    $P10 = rx1707_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1707_fail
    rx1707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1707_pos = $P10."pos"()
  # rx pass
    rx1707_cur."!cursor_pass"(rx1707_pos, "infix:sym<->")
    if_null rx1707_debug, debug_1280
    rx1707_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1707_pos)
  debug_1280:
    .return (rx1707_cur)
  rx1707_restart:
.annotate 'line', 10
    if_null rx1707_debug, debug_1281
    rx1707_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1281:
  rx1707_fail:
    (rx1707_rep, rx1707_pos, $I10, $P10) = rx1707_cur."!mark_fail"(0)
    lt rx1707_pos, -1, rx1707_done
    eq rx1707_pos, -1, rx1707_fail
    jump $I10
  rx1707_done:
    rx1707_cur."!cursor_fail"()
    if_null rx1707_debug, debug_1282
    rx1707_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1282:
    .return (rx1707_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("321_1303923618.727") :method
.annotate 'line', 10
    $P1709 = self."!PREFIX__!subrule"("O", "-")
    new $P1710, "ResizablePMCArray"
    push $P1710, $P1709
    .return ($P1710)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("322_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1714_tgt
    .local int rx1714_pos
    .local int rx1714_off
    .local int rx1714_eos
    .local int rx1714_rep
    .local pmc rx1714_cur
    .local pmc rx1714_debug
    (rx1714_cur, rx1714_pos, rx1714_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1714_cur
    .local pmc match
    .lex "$/", match
    length rx1714_eos, rx1714_tgt
    gt rx1714_pos, rx1714_eos, rx1714_done
    set rx1714_off, 0
    lt rx1714_pos, 2, rx1714_start
    sub rx1714_off, rx1714_pos, 1
    substr rx1714_tgt, rx1714_tgt, rx1714_off
  rx1714_start:
    eq $I10, 1, rx1714_restart
    if_null rx1714_debug, debug_1283
    rx1714_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1718_done
    goto rxscan1718_scan
  rxscan1718_loop:
    (rx1714_pos) = rx1714_cur."from"()
    inc rx1714_pos
    rx1714_cur."!cursor_from"(rx1714_pos)
    ge rx1714_pos, rx1714_eos, rxscan1718_done
  rxscan1718_scan:
    set_addr $I10, rxscan1718_loop
    rx1714_cur."!mark_push"(0, rx1714_pos, $I10)
  rxscan1718_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1719_fail
    rx1714_cur."!mark_push"(0, rx1714_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1714_pos, 2
    gt $I11, rx1714_eos, rx1714_fail
    sub $I11, rx1714_pos, rx1714_off
    substr $S10, rx1714_tgt, $I11, 2
    ne $S10, "+|", rx1714_fail
    add rx1714_pos, 2
    set_addr $I10, rxcap_1719_fail
    ($I12, $I11) = rx1714_cur."!mark_peek"($I10)
    rx1714_cur."!cursor_pos"($I11)
    ($P10) = rx1714_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1714_pos, "")
    rx1714_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1719_done
  rxcap_1719_fail:
    goto rx1714_fail
  rxcap_1719_done:
  # rx subrule "O" subtype=capture negate=
    rx1714_cur."!cursor_pos"(rx1714_pos)
    $P10 = rx1714_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1714_fail
    rx1714_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1714_pos = $P10."pos"()
  # rx pass
    rx1714_cur."!cursor_pass"(rx1714_pos, "infix:sym<+|>")
    if_null rx1714_debug, debug_1284
    rx1714_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1714_pos)
  debug_1284:
    .return (rx1714_cur)
  rx1714_restart:
.annotate 'line', 10
    if_null rx1714_debug, debug_1285
    rx1714_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1285:
  rx1714_fail:
    (rx1714_rep, rx1714_pos, $I10, $P10) = rx1714_cur."!mark_fail"(0)
    lt rx1714_pos, -1, rx1714_done
    eq rx1714_pos, -1, rx1714_fail
    jump $I10
  rx1714_done:
    rx1714_cur."!cursor_fail"()
    if_null rx1714_debug, debug_1286
    rx1714_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1286:
    .return (rx1714_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("323_1303923618.727") :method
.annotate 'line', 10
    $P1716 = self."!PREFIX__!subrule"("O", "+|")
    new $P1717, "ResizablePMCArray"
    push $P1717, $P1716
    .return ($P1717)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("324_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1721_tgt
    .local int rx1721_pos
    .local int rx1721_off
    .local int rx1721_eos
    .local int rx1721_rep
    .local pmc rx1721_cur
    .local pmc rx1721_debug
    (rx1721_cur, rx1721_pos, rx1721_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1721_cur
    .local pmc match
    .lex "$/", match
    length rx1721_eos, rx1721_tgt
    gt rx1721_pos, rx1721_eos, rx1721_done
    set rx1721_off, 0
    lt rx1721_pos, 2, rx1721_start
    sub rx1721_off, rx1721_pos, 1
    substr rx1721_tgt, rx1721_tgt, rx1721_off
  rx1721_start:
    eq $I10, 1, rx1721_restart
    if_null rx1721_debug, debug_1287
    rx1721_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1725_done
    goto rxscan1725_scan
  rxscan1725_loop:
    (rx1721_pos) = rx1721_cur."from"()
    inc rx1721_pos
    rx1721_cur."!cursor_from"(rx1721_pos)
    ge rx1721_pos, rx1721_eos, rxscan1725_done
  rxscan1725_scan:
    set_addr $I10, rxscan1725_loop
    rx1721_cur."!mark_push"(0, rx1721_pos, $I10)
  rxscan1725_done:
.annotate 'line', 676
  # rx subcapture "sym"
    set_addr $I10, rxcap_1726_fail
    rx1721_cur."!mark_push"(0, rx1721_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1721_pos, 2
    gt $I11, rx1721_eos, rx1721_fail
    sub $I11, rx1721_pos, rx1721_off
    substr $S10, rx1721_tgt, $I11, 2
    ne $S10, "+^", rx1721_fail
    add rx1721_pos, 2
    set_addr $I10, rxcap_1726_fail
    ($I12, $I11) = rx1721_cur."!mark_peek"($I10)
    rx1721_cur."!cursor_pos"($I11)
    ($P10) = rx1721_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1721_pos, "")
    rx1721_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1726_done
  rxcap_1726_fail:
    goto rx1721_fail
  rxcap_1726_done:
  # rx subrule "O" subtype=capture negate=
    rx1721_cur."!cursor_pos"(rx1721_pos)
    $P10 = rx1721_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1721_fail
    rx1721_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1721_pos = $P10."pos"()
  # rx pass
    rx1721_cur."!cursor_pass"(rx1721_pos, "infix:sym<+^>")
    if_null rx1721_debug, debug_1288
    rx1721_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1721_pos)
  debug_1288:
    .return (rx1721_cur)
  rx1721_restart:
.annotate 'line', 10
    if_null rx1721_debug, debug_1289
    rx1721_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1289:
  rx1721_fail:
    (rx1721_rep, rx1721_pos, $I10, $P10) = rx1721_cur."!mark_fail"(0)
    lt rx1721_pos, -1, rx1721_done
    eq rx1721_pos, -1, rx1721_fail
    jump $I10
  rx1721_done:
    rx1721_cur."!cursor_fail"()
    if_null rx1721_debug, debug_1290
    rx1721_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1290:
    .return (rx1721_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("325_1303923618.727") :method
.annotate 'line', 10
    $P1723 = self."!PREFIX__!subrule"("O", "+^")
    new $P1724, "ResizablePMCArray"
    push $P1724, $P1723
    .return ($P1724)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("326_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1728_tgt
    .local int rx1728_pos
    .local int rx1728_off
    .local int rx1728_eos
    .local int rx1728_rep
    .local pmc rx1728_cur
    .local pmc rx1728_debug
    (rx1728_cur, rx1728_pos, rx1728_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1728_cur
    .local pmc match
    .lex "$/", match
    length rx1728_eos, rx1728_tgt
    gt rx1728_pos, rx1728_eos, rx1728_done
    set rx1728_off, 0
    lt rx1728_pos, 2, rx1728_start
    sub rx1728_off, rx1728_pos, 1
    substr rx1728_tgt, rx1728_tgt, rx1728_off
  rx1728_start:
    eq $I10, 1, rx1728_restart
    if_null rx1728_debug, debug_1291
    rx1728_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1732_done
    goto rxscan1732_scan
  rxscan1732_loop:
    (rx1728_pos) = rx1728_cur."from"()
    inc rx1728_pos
    rx1728_cur."!cursor_from"(rx1728_pos)
    ge rx1728_pos, rx1728_eos, rxscan1732_done
  rxscan1732_scan:
    set_addr $I10, rxscan1732_loop
    rx1728_cur."!mark_push"(0, rx1728_pos, $I10)
  rxscan1732_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1733_fail
    rx1728_cur."!mark_push"(0, rx1728_pos, $I10)
  # rx literal  "~"
    add $I11, rx1728_pos, 1
    gt $I11, rx1728_eos, rx1728_fail
    sub $I11, rx1728_pos, rx1728_off
    ord $I11, rx1728_tgt, $I11
    ne $I11, 126, rx1728_fail
    add rx1728_pos, 1
    set_addr $I10, rxcap_1733_fail
    ($I12, $I11) = rx1728_cur."!mark_peek"($I10)
    rx1728_cur."!cursor_pos"($I11)
    ($P10) = rx1728_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1728_pos, "")
    rx1728_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1733_done
  rxcap_1733_fail:
    goto rx1728_fail
  rxcap_1733_done:
  # rx subrule "O" subtype=capture negate=
    rx1728_cur."!cursor_pos"(rx1728_pos)
    $P10 = rx1728_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1728_fail
    rx1728_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1728_pos = $P10."pos"()
  # rx pass
    rx1728_cur."!cursor_pass"(rx1728_pos, "infix:sym<~>")
    if_null rx1728_debug, debug_1292
    rx1728_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1728_pos)
  debug_1292:
    .return (rx1728_cur)
  rx1728_restart:
.annotate 'line', 10
    if_null rx1728_debug, debug_1293
    rx1728_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1293:
  rx1728_fail:
    (rx1728_rep, rx1728_pos, $I10, $P10) = rx1728_cur."!mark_fail"(0)
    lt rx1728_pos, -1, rx1728_done
    eq rx1728_pos, -1, rx1728_fail
    jump $I10
  rx1728_done:
    rx1728_cur."!cursor_fail"()
    if_null rx1728_debug, debug_1294
    rx1728_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1294:
    .return (rx1728_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("327_1303923618.727") :method
.annotate 'line', 10
    $P1730 = self."!PREFIX__!subrule"("O", "~")
    new $P1731, "ResizablePMCArray"
    push $P1731, $P1730
    .return ($P1731)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("328_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1735_tgt
    .local int rx1735_pos
    .local int rx1735_off
    .local int rx1735_eos
    .local int rx1735_rep
    .local pmc rx1735_cur
    .local pmc rx1735_debug
    (rx1735_cur, rx1735_pos, rx1735_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1735_cur
    .local pmc match
    .lex "$/", match
    length rx1735_eos, rx1735_tgt
    gt rx1735_pos, rx1735_eos, rx1735_done
    set rx1735_off, 0
    lt rx1735_pos, 2, rx1735_start
    sub rx1735_off, rx1735_pos, 1
    substr rx1735_tgt, rx1735_tgt, rx1735_off
  rx1735_start:
    eq $I10, 1, rx1735_restart
    if_null rx1735_debug, debug_1295
    rx1735_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1739_done
    goto rxscan1739_scan
  rxscan1739_loop:
    (rx1735_pos) = rx1735_cur."from"()
    inc rx1735_pos
    rx1735_cur."!cursor_from"(rx1735_pos)
    ge rx1735_pos, rx1735_eos, rxscan1739_done
  rxscan1739_scan:
    set_addr $I10, rxscan1739_loop
    rx1735_cur."!mark_push"(0, rx1735_pos, $I10)
  rxscan1739_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1740_fail
    rx1735_cur."!mark_push"(0, rx1735_pos, $I10)
  # rx literal  "=="
    add $I11, rx1735_pos, 2
    gt $I11, rx1735_eos, rx1735_fail
    sub $I11, rx1735_pos, rx1735_off
    substr $S10, rx1735_tgt, $I11, 2
    ne $S10, "==", rx1735_fail
    add rx1735_pos, 2
    set_addr $I10, rxcap_1740_fail
    ($I12, $I11) = rx1735_cur."!mark_peek"($I10)
    rx1735_cur."!cursor_pos"($I11)
    ($P10) = rx1735_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1735_pos, "")
    rx1735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1740_done
  rxcap_1740_fail:
    goto rx1735_fail
  rxcap_1740_done:
  # rx subrule "O" subtype=capture negate=
    rx1735_cur."!cursor_pos"(rx1735_pos)
    $P10 = rx1735_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1735_fail
    rx1735_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1735_pos = $P10."pos"()
  # rx pass
    rx1735_cur."!cursor_pass"(rx1735_pos, "infix:sym<==>")
    if_null rx1735_debug, debug_1296
    rx1735_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1735_pos)
  debug_1296:
    .return (rx1735_cur)
  rx1735_restart:
.annotate 'line', 10
    if_null rx1735_debug, debug_1297
    rx1735_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1297:
  rx1735_fail:
    (rx1735_rep, rx1735_pos, $I10, $P10) = rx1735_cur."!mark_fail"(0)
    lt rx1735_pos, -1, rx1735_done
    eq rx1735_pos, -1, rx1735_fail
    jump $I10
  rx1735_done:
    rx1735_cur."!cursor_fail"()
    if_null rx1735_debug, debug_1298
    rx1735_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1298:
    .return (rx1735_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("329_1303923618.727") :method
.annotate 'line', 10
    $P1737 = self."!PREFIX__!subrule"("O", "==")
    new $P1738, "ResizablePMCArray"
    push $P1738, $P1737
    .return ($P1738)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("330_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1742_tgt
    .local int rx1742_pos
    .local int rx1742_off
    .local int rx1742_eos
    .local int rx1742_rep
    .local pmc rx1742_cur
    .local pmc rx1742_debug
    (rx1742_cur, rx1742_pos, rx1742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1742_cur
    .local pmc match
    .lex "$/", match
    length rx1742_eos, rx1742_tgt
    gt rx1742_pos, rx1742_eos, rx1742_done
    set rx1742_off, 0
    lt rx1742_pos, 2, rx1742_start
    sub rx1742_off, rx1742_pos, 1
    substr rx1742_tgt, rx1742_tgt, rx1742_off
  rx1742_start:
    eq $I10, 1, rx1742_restart
    if_null rx1742_debug, debug_1299
    rx1742_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1746_done
    goto rxscan1746_scan
  rxscan1746_loop:
    (rx1742_pos) = rx1742_cur."from"()
    inc rx1742_pos
    rx1742_cur."!cursor_from"(rx1742_pos)
    ge rx1742_pos, rx1742_eos, rxscan1746_done
  rxscan1746_scan:
    set_addr $I10, rxscan1746_loop
    rx1742_cur."!mark_push"(0, rx1742_pos, $I10)
  rxscan1746_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1747_fail
    rx1742_cur."!mark_push"(0, rx1742_pos, $I10)
  # rx literal  "!="
    add $I11, rx1742_pos, 2
    gt $I11, rx1742_eos, rx1742_fail
    sub $I11, rx1742_pos, rx1742_off
    substr $S10, rx1742_tgt, $I11, 2
    ne $S10, "!=", rx1742_fail
    add rx1742_pos, 2
    set_addr $I10, rxcap_1747_fail
    ($I12, $I11) = rx1742_cur."!mark_peek"($I10)
    rx1742_cur."!cursor_pos"($I11)
    ($P10) = rx1742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1742_pos, "")
    rx1742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1747_done
  rxcap_1747_fail:
    goto rx1742_fail
  rxcap_1747_done:
  # rx subrule "O" subtype=capture negate=
    rx1742_cur."!cursor_pos"(rx1742_pos)
    $P10 = rx1742_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1742_fail
    rx1742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1742_pos = $P10."pos"()
  # rx pass
    rx1742_cur."!cursor_pass"(rx1742_pos, "infix:sym<!=>")
    if_null rx1742_debug, debug_1300
    rx1742_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1742_pos)
  debug_1300:
    .return (rx1742_cur)
  rx1742_restart:
.annotate 'line', 10
    if_null rx1742_debug, debug_1301
    rx1742_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1301:
  rx1742_fail:
    (rx1742_rep, rx1742_pos, $I10, $P10) = rx1742_cur."!mark_fail"(0)
    lt rx1742_pos, -1, rx1742_done
    eq rx1742_pos, -1, rx1742_fail
    jump $I10
  rx1742_done:
    rx1742_cur."!cursor_fail"()
    if_null rx1742_debug, debug_1302
    rx1742_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1302:
    .return (rx1742_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("331_1303923618.727") :method
.annotate 'line', 10
    $P1744 = self."!PREFIX__!subrule"("O", "!=")
    new $P1745, "ResizablePMCArray"
    push $P1745, $P1744
    .return ($P1745)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("332_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1749_tgt
    .local int rx1749_pos
    .local int rx1749_off
    .local int rx1749_eos
    .local int rx1749_rep
    .local pmc rx1749_cur
    .local pmc rx1749_debug
    (rx1749_cur, rx1749_pos, rx1749_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1749_cur
    .local pmc match
    .lex "$/", match
    length rx1749_eos, rx1749_tgt
    gt rx1749_pos, rx1749_eos, rx1749_done
    set rx1749_off, 0
    lt rx1749_pos, 2, rx1749_start
    sub rx1749_off, rx1749_pos, 1
    substr rx1749_tgt, rx1749_tgt, rx1749_off
  rx1749_start:
    eq $I10, 1, rx1749_restart
    if_null rx1749_debug, debug_1303
    rx1749_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1753_done
    goto rxscan1753_scan
  rxscan1753_loop:
    (rx1749_pos) = rx1749_cur."from"()
    inc rx1749_pos
    rx1749_cur."!cursor_from"(rx1749_pos)
    ge rx1749_pos, rx1749_eos, rxscan1753_done
  rxscan1753_scan:
    set_addr $I10, rxscan1753_loop
    rx1749_cur."!mark_push"(0, rx1749_pos, $I10)
  rxscan1753_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1754_fail
    rx1749_cur."!mark_push"(0, rx1749_pos, $I10)
  # rx literal  "<="
    add $I11, rx1749_pos, 2
    gt $I11, rx1749_eos, rx1749_fail
    sub $I11, rx1749_pos, rx1749_off
    substr $S10, rx1749_tgt, $I11, 2
    ne $S10, "<=", rx1749_fail
    add rx1749_pos, 2
    set_addr $I10, rxcap_1754_fail
    ($I12, $I11) = rx1749_cur."!mark_peek"($I10)
    rx1749_cur."!cursor_pos"($I11)
    ($P10) = rx1749_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1749_pos, "")
    rx1749_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1754_done
  rxcap_1754_fail:
    goto rx1749_fail
  rxcap_1754_done:
  # rx subrule "O" subtype=capture negate=
    rx1749_cur."!cursor_pos"(rx1749_pos)
    $P10 = rx1749_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1749_fail
    rx1749_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1749_pos = $P10."pos"()
  # rx pass
    rx1749_cur."!cursor_pass"(rx1749_pos, "infix:sym<<=>")
    if_null rx1749_debug, debug_1304
    rx1749_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1749_pos)
  debug_1304:
    .return (rx1749_cur)
  rx1749_restart:
.annotate 'line', 10
    if_null rx1749_debug, debug_1305
    rx1749_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1305:
  rx1749_fail:
    (rx1749_rep, rx1749_pos, $I10, $P10) = rx1749_cur."!mark_fail"(0)
    lt rx1749_pos, -1, rx1749_done
    eq rx1749_pos, -1, rx1749_fail
    jump $I10
  rx1749_done:
    rx1749_cur."!cursor_fail"()
    if_null rx1749_debug, debug_1306
    rx1749_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1306:
    .return (rx1749_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("333_1303923618.727") :method
.annotate 'line', 10
    $P1751 = self."!PREFIX__!subrule"("O", "<=")
    new $P1752, "ResizablePMCArray"
    push $P1752, $P1751
    .return ($P1752)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("334_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1756_tgt
    .local int rx1756_pos
    .local int rx1756_off
    .local int rx1756_eos
    .local int rx1756_rep
    .local pmc rx1756_cur
    .local pmc rx1756_debug
    (rx1756_cur, rx1756_pos, rx1756_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1756_cur
    .local pmc match
    .lex "$/", match
    length rx1756_eos, rx1756_tgt
    gt rx1756_pos, rx1756_eos, rx1756_done
    set rx1756_off, 0
    lt rx1756_pos, 2, rx1756_start
    sub rx1756_off, rx1756_pos, 1
    substr rx1756_tgt, rx1756_tgt, rx1756_off
  rx1756_start:
    eq $I10, 1, rx1756_restart
    if_null rx1756_debug, debug_1307
    rx1756_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1760_done
    goto rxscan1760_scan
  rxscan1760_loop:
    (rx1756_pos) = rx1756_cur."from"()
    inc rx1756_pos
    rx1756_cur."!cursor_from"(rx1756_pos)
    ge rx1756_pos, rx1756_eos, rxscan1760_done
  rxscan1760_scan:
    set_addr $I10, rxscan1760_loop
    rx1756_cur."!mark_push"(0, rx1756_pos, $I10)
  rxscan1760_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1761_fail
    rx1756_cur."!mark_push"(0, rx1756_pos, $I10)
  # rx literal  ">="
    add $I11, rx1756_pos, 2
    gt $I11, rx1756_eos, rx1756_fail
    sub $I11, rx1756_pos, rx1756_off
    substr $S10, rx1756_tgt, $I11, 2
    ne $S10, ">=", rx1756_fail
    add rx1756_pos, 2
    set_addr $I10, rxcap_1761_fail
    ($I12, $I11) = rx1756_cur."!mark_peek"($I10)
    rx1756_cur."!cursor_pos"($I11)
    ($P10) = rx1756_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1756_pos, "")
    rx1756_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1761_done
  rxcap_1761_fail:
    goto rx1756_fail
  rxcap_1761_done:
  # rx subrule "O" subtype=capture negate=
    rx1756_cur."!cursor_pos"(rx1756_pos)
    $P10 = rx1756_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1756_fail
    rx1756_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1756_pos = $P10."pos"()
  # rx pass
    rx1756_cur."!cursor_pass"(rx1756_pos, "infix:sym<>=>")
    if_null rx1756_debug, debug_1308
    rx1756_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1756_pos)
  debug_1308:
    .return (rx1756_cur)
  rx1756_restart:
.annotate 'line', 10
    if_null rx1756_debug, debug_1309
    rx1756_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1309:
  rx1756_fail:
    (rx1756_rep, rx1756_pos, $I10, $P10) = rx1756_cur."!mark_fail"(0)
    lt rx1756_pos, -1, rx1756_done
    eq rx1756_pos, -1, rx1756_fail
    jump $I10
  rx1756_done:
    rx1756_cur."!cursor_fail"()
    if_null rx1756_debug, debug_1310
    rx1756_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1310:
    .return (rx1756_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("335_1303923618.727") :method
.annotate 'line', 10
    $P1758 = self."!PREFIX__!subrule"("O", ">=")
    new $P1759, "ResizablePMCArray"
    push $P1759, $P1758
    .return ($P1759)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("336_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1763_tgt
    .local int rx1763_pos
    .local int rx1763_off
    .local int rx1763_eos
    .local int rx1763_rep
    .local pmc rx1763_cur
    .local pmc rx1763_debug
    (rx1763_cur, rx1763_pos, rx1763_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1763_cur
    .local pmc match
    .lex "$/", match
    length rx1763_eos, rx1763_tgt
    gt rx1763_pos, rx1763_eos, rx1763_done
    set rx1763_off, 0
    lt rx1763_pos, 2, rx1763_start
    sub rx1763_off, rx1763_pos, 1
    substr rx1763_tgt, rx1763_tgt, rx1763_off
  rx1763_start:
    eq $I10, 1, rx1763_restart
    if_null rx1763_debug, debug_1311
    rx1763_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1767_done
    goto rxscan1767_scan
  rxscan1767_loop:
    (rx1763_pos) = rx1763_cur."from"()
    inc rx1763_pos
    rx1763_cur."!cursor_from"(rx1763_pos)
    ge rx1763_pos, rx1763_eos, rxscan1767_done
  rxscan1767_scan:
    set_addr $I10, rxscan1767_loop
    rx1763_cur."!mark_push"(0, rx1763_pos, $I10)
  rxscan1767_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1768_fail
    rx1763_cur."!mark_push"(0, rx1763_pos, $I10)
  # rx literal  "<"
    add $I11, rx1763_pos, 1
    gt $I11, rx1763_eos, rx1763_fail
    sub $I11, rx1763_pos, rx1763_off
    ord $I11, rx1763_tgt, $I11
    ne $I11, 60, rx1763_fail
    add rx1763_pos, 1
    set_addr $I10, rxcap_1768_fail
    ($I12, $I11) = rx1763_cur."!mark_peek"($I10)
    rx1763_cur."!cursor_pos"($I11)
    ($P10) = rx1763_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1763_pos, "")
    rx1763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1768_done
  rxcap_1768_fail:
    goto rx1763_fail
  rxcap_1768_done:
  # rx subrule "O" subtype=capture negate=
    rx1763_cur."!cursor_pos"(rx1763_pos)
    $P10 = rx1763_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1763_fail
    rx1763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1763_pos = $P10."pos"()
  # rx pass
    rx1763_cur."!cursor_pass"(rx1763_pos, "infix:sym<<>")
    if_null rx1763_debug, debug_1312
    rx1763_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1763_pos)
  debug_1312:
    .return (rx1763_cur)
  rx1763_restart:
.annotate 'line', 10
    if_null rx1763_debug, debug_1313
    rx1763_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1313:
  rx1763_fail:
    (rx1763_rep, rx1763_pos, $I10, $P10) = rx1763_cur."!mark_fail"(0)
    lt rx1763_pos, -1, rx1763_done
    eq rx1763_pos, -1, rx1763_fail
    jump $I10
  rx1763_done:
    rx1763_cur."!cursor_fail"()
    if_null rx1763_debug, debug_1314
    rx1763_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1314:
    .return (rx1763_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("337_1303923618.727") :method
.annotate 'line', 10
    $P1765 = self."!PREFIX__!subrule"("O", "<")
    new $P1766, "ResizablePMCArray"
    push $P1766, $P1765
    .return ($P1766)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("338_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1770_tgt
    .local int rx1770_pos
    .local int rx1770_off
    .local int rx1770_eos
    .local int rx1770_rep
    .local pmc rx1770_cur
    .local pmc rx1770_debug
    (rx1770_cur, rx1770_pos, rx1770_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1770_cur
    .local pmc match
    .lex "$/", match
    length rx1770_eos, rx1770_tgt
    gt rx1770_pos, rx1770_eos, rx1770_done
    set rx1770_off, 0
    lt rx1770_pos, 2, rx1770_start
    sub rx1770_off, rx1770_pos, 1
    substr rx1770_tgt, rx1770_tgt, rx1770_off
  rx1770_start:
    eq $I10, 1, rx1770_restart
    if_null rx1770_debug, debug_1315
    rx1770_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1315:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1774_done
    goto rxscan1774_scan
  rxscan1774_loop:
    (rx1770_pos) = rx1770_cur."from"()
    inc rx1770_pos
    rx1770_cur."!cursor_from"(rx1770_pos)
    ge rx1770_pos, rx1770_eos, rxscan1774_done
  rxscan1774_scan:
    set_addr $I10, rxscan1774_loop
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
  rxscan1774_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1775_fail
    rx1770_cur."!mark_push"(0, rx1770_pos, $I10)
  # rx literal  ">"
    add $I11, rx1770_pos, 1
    gt $I11, rx1770_eos, rx1770_fail
    sub $I11, rx1770_pos, rx1770_off
    ord $I11, rx1770_tgt, $I11
    ne $I11, 62, rx1770_fail
    add rx1770_pos, 1
    set_addr $I10, rxcap_1775_fail
    ($I12, $I11) = rx1770_cur."!mark_peek"($I10)
    rx1770_cur."!cursor_pos"($I11)
    ($P10) = rx1770_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1770_pos, "")
    rx1770_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1775_done
  rxcap_1775_fail:
    goto rx1770_fail
  rxcap_1775_done:
  # rx subrule "O" subtype=capture negate=
    rx1770_cur."!cursor_pos"(rx1770_pos)
    $P10 = rx1770_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1770_fail
    rx1770_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1770_pos = $P10."pos"()
  # rx pass
    rx1770_cur."!cursor_pass"(rx1770_pos, "infix:sym<>>")
    if_null rx1770_debug, debug_1316
    rx1770_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1770_pos)
  debug_1316:
    .return (rx1770_cur)
  rx1770_restart:
.annotate 'line', 10
    if_null rx1770_debug, debug_1317
    rx1770_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1317:
  rx1770_fail:
    (rx1770_rep, rx1770_pos, $I10, $P10) = rx1770_cur."!mark_fail"(0)
    lt rx1770_pos, -1, rx1770_done
    eq rx1770_pos, -1, rx1770_fail
    jump $I10
  rx1770_done:
    rx1770_cur."!cursor_fail"()
    if_null rx1770_debug, debug_1318
    rx1770_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1318:
    .return (rx1770_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("339_1303923618.727") :method
.annotate 'line', 10
    $P1772 = self."!PREFIX__!subrule"("O", ">")
    new $P1773, "ResizablePMCArray"
    push $P1773, $P1772
    .return ($P1773)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("340_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1777_tgt
    .local int rx1777_pos
    .local int rx1777_off
    .local int rx1777_eos
    .local int rx1777_rep
    .local pmc rx1777_cur
    .local pmc rx1777_debug
    (rx1777_cur, rx1777_pos, rx1777_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1777_cur
    .local pmc match
    .lex "$/", match
    length rx1777_eos, rx1777_tgt
    gt rx1777_pos, rx1777_eos, rx1777_done
    set rx1777_off, 0
    lt rx1777_pos, 2, rx1777_start
    sub rx1777_off, rx1777_pos, 1
    substr rx1777_tgt, rx1777_tgt, rx1777_off
  rx1777_start:
    eq $I10, 1, rx1777_restart
    if_null rx1777_debug, debug_1319
    rx1777_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1781_done
    goto rxscan1781_scan
  rxscan1781_loop:
    (rx1777_pos) = rx1777_cur."from"()
    inc rx1777_pos
    rx1777_cur."!cursor_from"(rx1777_pos)
    ge rx1777_pos, rx1777_eos, rxscan1781_done
  rxscan1781_scan:
    set_addr $I10, rxscan1781_loop
    rx1777_cur."!mark_push"(0, rx1777_pos, $I10)
  rxscan1781_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1782_fail
    rx1777_cur."!mark_push"(0, rx1777_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1777_pos, 2
    gt $I11, rx1777_eos, rx1777_fail
    sub $I11, rx1777_pos, rx1777_off
    substr $S10, rx1777_tgt, $I11, 2
    ne $S10, "eq", rx1777_fail
    add rx1777_pos, 2
    set_addr $I10, rxcap_1782_fail
    ($I12, $I11) = rx1777_cur."!mark_peek"($I10)
    rx1777_cur."!cursor_pos"($I11)
    ($P10) = rx1777_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1777_pos, "")
    rx1777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1782_done
  rxcap_1782_fail:
    goto rx1777_fail
  rxcap_1782_done:
  # rx subrule "O" subtype=capture negate=
    rx1777_cur."!cursor_pos"(rx1777_pos)
    $P10 = rx1777_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1777_fail
    rx1777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1777_pos = $P10."pos"()
  # rx pass
    rx1777_cur."!cursor_pass"(rx1777_pos, "infix:sym<eq>")
    if_null rx1777_debug, debug_1320
    rx1777_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1777_pos)
  debug_1320:
    .return (rx1777_cur)
  rx1777_restart:
.annotate 'line', 10
    if_null rx1777_debug, debug_1321
    rx1777_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1321:
  rx1777_fail:
    (rx1777_rep, rx1777_pos, $I10, $P10) = rx1777_cur."!mark_fail"(0)
    lt rx1777_pos, -1, rx1777_done
    eq rx1777_pos, -1, rx1777_fail
    jump $I10
  rx1777_done:
    rx1777_cur."!cursor_fail"()
    if_null rx1777_debug, debug_1322
    rx1777_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1322:
    .return (rx1777_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("341_1303923618.727") :method
.annotate 'line', 10
    $P1779 = self."!PREFIX__!subrule"("O", "eq")
    new $P1780, "ResizablePMCArray"
    push $P1780, $P1779
    .return ($P1780)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("342_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1784_tgt
    .local int rx1784_pos
    .local int rx1784_off
    .local int rx1784_eos
    .local int rx1784_rep
    .local pmc rx1784_cur
    .local pmc rx1784_debug
    (rx1784_cur, rx1784_pos, rx1784_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1784_cur
    .local pmc match
    .lex "$/", match
    length rx1784_eos, rx1784_tgt
    gt rx1784_pos, rx1784_eos, rx1784_done
    set rx1784_off, 0
    lt rx1784_pos, 2, rx1784_start
    sub rx1784_off, rx1784_pos, 1
    substr rx1784_tgt, rx1784_tgt, rx1784_off
  rx1784_start:
    eq $I10, 1, rx1784_restart
    if_null rx1784_debug, debug_1323
    rx1784_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1323:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1788_done
    goto rxscan1788_scan
  rxscan1788_loop:
    (rx1784_pos) = rx1784_cur."from"()
    inc rx1784_pos
    rx1784_cur."!cursor_from"(rx1784_pos)
    ge rx1784_pos, rx1784_eos, rxscan1788_done
  rxscan1788_scan:
    set_addr $I10, rxscan1788_loop
    rx1784_cur."!mark_push"(0, rx1784_pos, $I10)
  rxscan1788_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1789_fail
    rx1784_cur."!mark_push"(0, rx1784_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1784_pos, 2
    gt $I11, rx1784_eos, rx1784_fail
    sub $I11, rx1784_pos, rx1784_off
    substr $S10, rx1784_tgt, $I11, 2
    ne $S10, "ne", rx1784_fail
    add rx1784_pos, 2
    set_addr $I10, rxcap_1789_fail
    ($I12, $I11) = rx1784_cur."!mark_peek"($I10)
    rx1784_cur."!cursor_pos"($I11)
    ($P10) = rx1784_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1784_pos, "")
    rx1784_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1789_done
  rxcap_1789_fail:
    goto rx1784_fail
  rxcap_1789_done:
  # rx subrule "O" subtype=capture negate=
    rx1784_cur."!cursor_pos"(rx1784_pos)
    $P10 = rx1784_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1784_fail
    rx1784_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1784_pos = $P10."pos"()
  # rx pass
    rx1784_cur."!cursor_pass"(rx1784_pos, "infix:sym<ne>")
    if_null rx1784_debug, debug_1324
    rx1784_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1784_pos)
  debug_1324:
    .return (rx1784_cur)
  rx1784_restart:
.annotate 'line', 10
    if_null rx1784_debug, debug_1325
    rx1784_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1325:
  rx1784_fail:
    (rx1784_rep, rx1784_pos, $I10, $P10) = rx1784_cur."!mark_fail"(0)
    lt rx1784_pos, -1, rx1784_done
    eq rx1784_pos, -1, rx1784_fail
    jump $I10
  rx1784_done:
    rx1784_cur."!cursor_fail"()
    if_null rx1784_debug, debug_1326
    rx1784_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1326:
    .return (rx1784_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("343_1303923618.727") :method
.annotate 'line', 10
    $P1786 = self."!PREFIX__!subrule"("O", "ne")
    new $P1787, "ResizablePMCArray"
    push $P1787, $P1786
    .return ($P1787)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("344_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1791_tgt
    .local int rx1791_pos
    .local int rx1791_off
    .local int rx1791_eos
    .local int rx1791_rep
    .local pmc rx1791_cur
    .local pmc rx1791_debug
    (rx1791_cur, rx1791_pos, rx1791_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1791_cur
    .local pmc match
    .lex "$/", match
    length rx1791_eos, rx1791_tgt
    gt rx1791_pos, rx1791_eos, rx1791_done
    set rx1791_off, 0
    lt rx1791_pos, 2, rx1791_start
    sub rx1791_off, rx1791_pos, 1
    substr rx1791_tgt, rx1791_tgt, rx1791_off
  rx1791_start:
    eq $I10, 1, rx1791_restart
    if_null rx1791_debug, debug_1327
    rx1791_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1327:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1795_done
    goto rxscan1795_scan
  rxscan1795_loop:
    (rx1791_pos) = rx1791_cur."from"()
    inc rx1791_pos
    rx1791_cur."!cursor_from"(rx1791_pos)
    ge rx1791_pos, rx1791_eos, rxscan1795_done
  rxscan1795_scan:
    set_addr $I10, rxscan1795_loop
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
  rxscan1795_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1796_fail
    rx1791_cur."!mark_push"(0, rx1791_pos, $I10)
  # rx literal  "le"
    add $I11, rx1791_pos, 2
    gt $I11, rx1791_eos, rx1791_fail
    sub $I11, rx1791_pos, rx1791_off
    substr $S10, rx1791_tgt, $I11, 2
    ne $S10, "le", rx1791_fail
    add rx1791_pos, 2
    set_addr $I10, rxcap_1796_fail
    ($I12, $I11) = rx1791_cur."!mark_peek"($I10)
    rx1791_cur."!cursor_pos"($I11)
    ($P10) = rx1791_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1791_pos, "")
    rx1791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1796_done
  rxcap_1796_fail:
    goto rx1791_fail
  rxcap_1796_done:
  # rx subrule "O" subtype=capture negate=
    rx1791_cur."!cursor_pos"(rx1791_pos)
    $P10 = rx1791_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1791_fail
    rx1791_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1791_pos = $P10."pos"()
  # rx pass
    rx1791_cur."!cursor_pass"(rx1791_pos, "infix:sym<le>")
    if_null rx1791_debug, debug_1328
    rx1791_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1791_pos)
  debug_1328:
    .return (rx1791_cur)
  rx1791_restart:
.annotate 'line', 10
    if_null rx1791_debug, debug_1329
    rx1791_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1329:
  rx1791_fail:
    (rx1791_rep, rx1791_pos, $I10, $P10) = rx1791_cur."!mark_fail"(0)
    lt rx1791_pos, -1, rx1791_done
    eq rx1791_pos, -1, rx1791_fail
    jump $I10
  rx1791_done:
    rx1791_cur."!cursor_fail"()
    if_null rx1791_debug, debug_1330
    rx1791_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1330:
    .return (rx1791_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("345_1303923618.727") :method
.annotate 'line', 10
    $P1793 = self."!PREFIX__!subrule"("O", "le")
    new $P1794, "ResizablePMCArray"
    push $P1794, $P1793
    .return ($P1794)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("346_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1798_tgt
    .local int rx1798_pos
    .local int rx1798_off
    .local int rx1798_eos
    .local int rx1798_rep
    .local pmc rx1798_cur
    .local pmc rx1798_debug
    (rx1798_cur, rx1798_pos, rx1798_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1798_cur
    .local pmc match
    .lex "$/", match
    length rx1798_eos, rx1798_tgt
    gt rx1798_pos, rx1798_eos, rx1798_done
    set rx1798_off, 0
    lt rx1798_pos, 2, rx1798_start
    sub rx1798_off, rx1798_pos, 1
    substr rx1798_tgt, rx1798_tgt, rx1798_off
  rx1798_start:
    eq $I10, 1, rx1798_restart
    if_null rx1798_debug, debug_1331
    rx1798_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1331:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1802_done
    goto rxscan1802_scan
  rxscan1802_loop:
    (rx1798_pos) = rx1798_cur."from"()
    inc rx1798_pos
    rx1798_cur."!cursor_from"(rx1798_pos)
    ge rx1798_pos, rx1798_eos, rxscan1802_done
  rxscan1802_scan:
    set_addr $I10, rxscan1802_loop
    rx1798_cur."!mark_push"(0, rx1798_pos, $I10)
  rxscan1802_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1803_fail
    rx1798_cur."!mark_push"(0, rx1798_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1798_pos, 2
    gt $I11, rx1798_eos, rx1798_fail
    sub $I11, rx1798_pos, rx1798_off
    substr $S10, rx1798_tgt, $I11, 2
    ne $S10, "ge", rx1798_fail
    add rx1798_pos, 2
    set_addr $I10, rxcap_1803_fail
    ($I12, $I11) = rx1798_cur."!mark_peek"($I10)
    rx1798_cur."!cursor_pos"($I11)
    ($P10) = rx1798_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1798_pos, "")
    rx1798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1803_done
  rxcap_1803_fail:
    goto rx1798_fail
  rxcap_1803_done:
  # rx subrule "O" subtype=capture negate=
    rx1798_cur."!cursor_pos"(rx1798_pos)
    $P10 = rx1798_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1798_fail
    rx1798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1798_pos = $P10."pos"()
  # rx pass
    rx1798_cur."!cursor_pass"(rx1798_pos, "infix:sym<ge>")
    if_null rx1798_debug, debug_1332
    rx1798_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1798_pos)
  debug_1332:
    .return (rx1798_cur)
  rx1798_restart:
.annotate 'line', 10
    if_null rx1798_debug, debug_1333
    rx1798_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1333:
  rx1798_fail:
    (rx1798_rep, rx1798_pos, $I10, $P10) = rx1798_cur."!mark_fail"(0)
    lt rx1798_pos, -1, rx1798_done
    eq rx1798_pos, -1, rx1798_fail
    jump $I10
  rx1798_done:
    rx1798_cur."!cursor_fail"()
    if_null rx1798_debug, debug_1334
    rx1798_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1334:
    .return (rx1798_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("347_1303923618.727") :method
.annotate 'line', 10
    $P1800 = self."!PREFIX__!subrule"("O", "ge")
    new $P1801, "ResizablePMCArray"
    push $P1801, $P1800
    .return ($P1801)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("348_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1805_tgt
    .local int rx1805_pos
    .local int rx1805_off
    .local int rx1805_eos
    .local int rx1805_rep
    .local pmc rx1805_cur
    .local pmc rx1805_debug
    (rx1805_cur, rx1805_pos, rx1805_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1805_cur
    .local pmc match
    .lex "$/", match
    length rx1805_eos, rx1805_tgt
    gt rx1805_pos, rx1805_eos, rx1805_done
    set rx1805_off, 0
    lt rx1805_pos, 2, rx1805_start
    sub rx1805_off, rx1805_pos, 1
    substr rx1805_tgt, rx1805_tgt, rx1805_off
  rx1805_start:
    eq $I10, 1, rx1805_restart
    if_null rx1805_debug, debug_1335
    rx1805_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1335:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1809_done
    goto rxscan1809_scan
  rxscan1809_loop:
    (rx1805_pos) = rx1805_cur."from"()
    inc rx1805_pos
    rx1805_cur."!cursor_from"(rx1805_pos)
    ge rx1805_pos, rx1805_eos, rxscan1809_done
  rxscan1809_scan:
    set_addr $I10, rxscan1809_loop
    rx1805_cur."!mark_push"(0, rx1805_pos, $I10)
  rxscan1809_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1810_fail
    rx1805_cur."!mark_push"(0, rx1805_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1805_pos, 2
    gt $I11, rx1805_eos, rx1805_fail
    sub $I11, rx1805_pos, rx1805_off
    substr $S10, rx1805_tgt, $I11, 2
    ne $S10, "lt", rx1805_fail
    add rx1805_pos, 2
    set_addr $I10, rxcap_1810_fail
    ($I12, $I11) = rx1805_cur."!mark_peek"($I10)
    rx1805_cur."!cursor_pos"($I11)
    ($P10) = rx1805_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1805_pos, "")
    rx1805_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1810_done
  rxcap_1810_fail:
    goto rx1805_fail
  rxcap_1810_done:
  # rx subrule "O" subtype=capture negate=
    rx1805_cur."!cursor_pos"(rx1805_pos)
    $P10 = rx1805_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1805_fail
    rx1805_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1805_pos = $P10."pos"()
  # rx pass
    rx1805_cur."!cursor_pass"(rx1805_pos, "infix:sym<lt>")
    if_null rx1805_debug, debug_1336
    rx1805_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1805_pos)
  debug_1336:
    .return (rx1805_cur)
  rx1805_restart:
.annotate 'line', 10
    if_null rx1805_debug, debug_1337
    rx1805_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1337:
  rx1805_fail:
    (rx1805_rep, rx1805_pos, $I10, $P10) = rx1805_cur."!mark_fail"(0)
    lt rx1805_pos, -1, rx1805_done
    eq rx1805_pos, -1, rx1805_fail
    jump $I10
  rx1805_done:
    rx1805_cur."!cursor_fail"()
    if_null rx1805_debug, debug_1338
    rx1805_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1338:
    .return (rx1805_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("349_1303923618.727") :method
.annotate 'line', 10
    $P1807 = self."!PREFIX__!subrule"("O", "lt")
    new $P1808, "ResizablePMCArray"
    push $P1808, $P1807
    .return ($P1808)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("350_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1812_tgt
    .local int rx1812_pos
    .local int rx1812_off
    .local int rx1812_eos
    .local int rx1812_rep
    .local pmc rx1812_cur
    .local pmc rx1812_debug
    (rx1812_cur, rx1812_pos, rx1812_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1812_cur
    .local pmc match
    .lex "$/", match
    length rx1812_eos, rx1812_tgt
    gt rx1812_pos, rx1812_eos, rx1812_done
    set rx1812_off, 0
    lt rx1812_pos, 2, rx1812_start
    sub rx1812_off, rx1812_pos, 1
    substr rx1812_tgt, rx1812_tgt, rx1812_off
  rx1812_start:
    eq $I10, 1, rx1812_restart
    if_null rx1812_debug, debug_1339
    rx1812_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1339:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1816_done
    goto rxscan1816_scan
  rxscan1816_loop:
    (rx1812_pos) = rx1812_cur."from"()
    inc rx1812_pos
    rx1812_cur."!cursor_from"(rx1812_pos)
    ge rx1812_pos, rx1812_eos, rxscan1816_done
  rxscan1816_scan:
    set_addr $I10, rxscan1816_loop
    rx1812_cur."!mark_push"(0, rx1812_pos, $I10)
  rxscan1816_done:
.annotate 'line', 691
  # rx subcapture "sym"
    set_addr $I10, rxcap_1817_fail
    rx1812_cur."!mark_push"(0, rx1812_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1812_pos, 2
    gt $I11, rx1812_eos, rx1812_fail
    sub $I11, rx1812_pos, rx1812_off
    substr $S10, rx1812_tgt, $I11, 2
    ne $S10, "gt", rx1812_fail
    add rx1812_pos, 2
    set_addr $I10, rxcap_1817_fail
    ($I12, $I11) = rx1812_cur."!mark_peek"($I10)
    rx1812_cur."!cursor_pos"($I11)
    ($P10) = rx1812_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1812_pos, "")
    rx1812_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1817_done
  rxcap_1817_fail:
    goto rx1812_fail
  rxcap_1817_done:
  # rx subrule "O" subtype=capture negate=
    rx1812_cur."!cursor_pos"(rx1812_pos)
    $P10 = rx1812_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1812_fail
    rx1812_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1812_pos = $P10."pos"()
  # rx pass
    rx1812_cur."!cursor_pass"(rx1812_pos, "infix:sym<gt>")
    if_null rx1812_debug, debug_1340
    rx1812_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1812_pos)
  debug_1340:
    .return (rx1812_cur)
  rx1812_restart:
.annotate 'line', 10
    if_null rx1812_debug, debug_1341
    rx1812_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1341:
  rx1812_fail:
    (rx1812_rep, rx1812_pos, $I10, $P10) = rx1812_cur."!mark_fail"(0)
    lt rx1812_pos, -1, rx1812_done
    eq rx1812_pos, -1, rx1812_fail
    jump $I10
  rx1812_done:
    rx1812_cur."!cursor_fail"()
    if_null rx1812_debug, debug_1342
    rx1812_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1342:
    .return (rx1812_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("351_1303923618.727") :method
.annotate 'line', 10
    $P1814 = self."!PREFIX__!subrule"("O", "gt")
    new $P1815, "ResizablePMCArray"
    push $P1815, $P1814
    .return ($P1815)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("352_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1819_tgt
    .local int rx1819_pos
    .local int rx1819_off
    .local int rx1819_eos
    .local int rx1819_rep
    .local pmc rx1819_cur
    .local pmc rx1819_debug
    (rx1819_cur, rx1819_pos, rx1819_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1819_cur
    .local pmc match
    .lex "$/", match
    length rx1819_eos, rx1819_tgt
    gt rx1819_pos, rx1819_eos, rx1819_done
    set rx1819_off, 0
    lt rx1819_pos, 2, rx1819_start
    sub rx1819_off, rx1819_pos, 1
    substr rx1819_tgt, rx1819_tgt, rx1819_off
  rx1819_start:
    eq $I10, 1, rx1819_restart
    if_null rx1819_debug, debug_1343
    rx1819_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1343:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1823_done
    goto rxscan1823_scan
  rxscan1823_loop:
    (rx1819_pos) = rx1819_cur."from"()
    inc rx1819_pos
    rx1819_cur."!cursor_from"(rx1819_pos)
    ge rx1819_pos, rx1819_eos, rxscan1823_done
  rxscan1823_scan:
    set_addr $I10, rxscan1823_loop
    rx1819_cur."!mark_push"(0, rx1819_pos, $I10)
  rxscan1823_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1824_fail
    rx1819_cur."!mark_push"(0, rx1819_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1819_pos, 3
    gt $I11, rx1819_eos, rx1819_fail
    sub $I11, rx1819_pos, rx1819_off
    substr $S10, rx1819_tgt, $I11, 3
    ne $S10, "=:=", rx1819_fail
    add rx1819_pos, 3
    set_addr $I10, rxcap_1824_fail
    ($I12, $I11) = rx1819_cur."!mark_peek"($I10)
    rx1819_cur."!cursor_pos"($I11)
    ($P10) = rx1819_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1819_pos, "")
    rx1819_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1824_done
  rxcap_1824_fail:
    goto rx1819_fail
  rxcap_1824_done:
  # rx subrule "O" subtype=capture negate=
    rx1819_cur."!cursor_pos"(rx1819_pos)
    $P10 = rx1819_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1819_fail
    rx1819_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1819_pos = $P10."pos"()
  # rx pass
    rx1819_cur."!cursor_pass"(rx1819_pos, "infix:sym<=:=>")
    if_null rx1819_debug, debug_1344
    rx1819_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1819_pos)
  debug_1344:
    .return (rx1819_cur)
  rx1819_restart:
.annotate 'line', 10
    if_null rx1819_debug, debug_1345
    rx1819_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1345:
  rx1819_fail:
    (rx1819_rep, rx1819_pos, $I10, $P10) = rx1819_cur."!mark_fail"(0)
    lt rx1819_pos, -1, rx1819_done
    eq rx1819_pos, -1, rx1819_fail
    jump $I10
  rx1819_done:
    rx1819_cur."!cursor_fail"()
    if_null rx1819_debug, debug_1346
    rx1819_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1346:
    .return (rx1819_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("353_1303923618.727") :method
.annotate 'line', 10
    $P1821 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1822, "ResizablePMCArray"
    push $P1822, $P1821
    .return ($P1822)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("354_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1826_tgt
    .local int rx1826_pos
    .local int rx1826_off
    .local int rx1826_eos
    .local int rx1826_rep
    .local pmc rx1826_cur
    .local pmc rx1826_debug
    (rx1826_cur, rx1826_pos, rx1826_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1826_cur
    .local pmc match
    .lex "$/", match
    length rx1826_eos, rx1826_tgt
    gt rx1826_pos, rx1826_eos, rx1826_done
    set rx1826_off, 0
    lt rx1826_pos, 2, rx1826_start
    sub rx1826_off, rx1826_pos, 1
    substr rx1826_tgt, rx1826_tgt, rx1826_off
  rx1826_start:
    eq $I10, 1, rx1826_restart
    if_null rx1826_debug, debug_1347
    rx1826_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1347:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1830_done
    goto rxscan1830_scan
  rxscan1830_loop:
    (rx1826_pos) = rx1826_cur."from"()
    inc rx1826_pos
    rx1826_cur."!cursor_from"(rx1826_pos)
    ge rx1826_pos, rx1826_eos, rxscan1830_done
  rxscan1830_scan:
    set_addr $I10, rxscan1830_loop
    rx1826_cur."!mark_push"(0, rx1826_pos, $I10)
  rxscan1830_done:
.annotate 'line', 693
  # rx subcapture "sym"
    set_addr $I10, rxcap_1831_fail
    rx1826_cur."!mark_push"(0, rx1826_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1826_pos, 2
    gt $I11, rx1826_eos, rx1826_fail
    sub $I11, rx1826_pos, rx1826_off
    substr $S10, rx1826_tgt, $I11, 2
    ne $S10, "~~", rx1826_fail
    add rx1826_pos, 2
    set_addr $I10, rxcap_1831_fail
    ($I12, $I11) = rx1826_cur."!mark_peek"($I10)
    rx1826_cur."!cursor_pos"($I11)
    ($P10) = rx1826_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1826_pos, "")
    rx1826_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1831_done
  rxcap_1831_fail:
    goto rx1826_fail
  rxcap_1831_done:
  # rx subrule "O" subtype=capture negate=
    rx1826_cur."!cursor_pos"(rx1826_pos)
    $P10 = rx1826_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1826_fail
    rx1826_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1826_pos = $P10."pos"()
  # rx pass
    rx1826_cur."!cursor_pass"(rx1826_pos, "infix:sym<~~>")
    if_null rx1826_debug, debug_1348
    rx1826_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1826_pos)
  debug_1348:
    .return (rx1826_cur)
  rx1826_restart:
.annotate 'line', 10
    if_null rx1826_debug, debug_1349
    rx1826_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1349:
  rx1826_fail:
    (rx1826_rep, rx1826_pos, $I10, $P10) = rx1826_cur."!mark_fail"(0)
    lt rx1826_pos, -1, rx1826_done
    eq rx1826_pos, -1, rx1826_fail
    jump $I10
  rx1826_done:
    rx1826_cur."!cursor_fail"()
    if_null rx1826_debug, debug_1350
    rx1826_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1350:
    .return (rx1826_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("355_1303923618.727") :method
.annotate 'line', 10
    $P1828 = self."!PREFIX__!subrule"("O", "~~")
    new $P1829, "ResizablePMCArray"
    push $P1829, $P1828
    .return ($P1829)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("356_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1833_tgt
    .local int rx1833_pos
    .local int rx1833_off
    .local int rx1833_eos
    .local int rx1833_rep
    .local pmc rx1833_cur
    .local pmc rx1833_debug
    (rx1833_cur, rx1833_pos, rx1833_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1833_cur
    .local pmc match
    .lex "$/", match
    length rx1833_eos, rx1833_tgt
    gt rx1833_pos, rx1833_eos, rx1833_done
    set rx1833_off, 0
    lt rx1833_pos, 2, rx1833_start
    sub rx1833_off, rx1833_pos, 1
    substr rx1833_tgt, rx1833_tgt, rx1833_off
  rx1833_start:
    eq $I10, 1, rx1833_restart
    if_null rx1833_debug, debug_1351
    rx1833_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1351:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1837_done
    goto rxscan1837_scan
  rxscan1837_loop:
    (rx1833_pos) = rx1833_cur."from"()
    inc rx1833_pos
    rx1833_cur."!cursor_from"(rx1833_pos)
    ge rx1833_pos, rx1833_eos, rxscan1837_done
  rxscan1837_scan:
    set_addr $I10, rxscan1837_loop
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  rxscan1837_done:
.annotate 'line', 695
  # rx subcapture "sym"
    set_addr $I10, rxcap_1838_fail
    rx1833_cur."!mark_push"(0, rx1833_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1833_pos, 2
    gt $I11, rx1833_eos, rx1833_fail
    sub $I11, rx1833_pos, rx1833_off
    substr $S10, rx1833_tgt, $I11, 2
    ne $S10, "&&", rx1833_fail
    add rx1833_pos, 2
    set_addr $I10, rxcap_1838_fail
    ($I12, $I11) = rx1833_cur."!mark_peek"($I10)
    rx1833_cur."!cursor_pos"($I11)
    ($P10) = rx1833_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1833_pos, "")
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1838_done
  rxcap_1838_fail:
    goto rx1833_fail
  rxcap_1838_done:
  # rx subrule "O" subtype=capture negate=
    rx1833_cur."!cursor_pos"(rx1833_pos)
    $P10 = rx1833_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1833_fail
    rx1833_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1833_pos = $P10."pos"()
  # rx pass
    rx1833_cur."!cursor_pass"(rx1833_pos, "infix:sym<&&>")
    if_null rx1833_debug, debug_1352
    rx1833_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1833_pos)
  debug_1352:
    .return (rx1833_cur)
  rx1833_restart:
.annotate 'line', 10
    if_null rx1833_debug, debug_1353
    rx1833_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1353:
  rx1833_fail:
    (rx1833_rep, rx1833_pos, $I10, $P10) = rx1833_cur."!mark_fail"(0)
    lt rx1833_pos, -1, rx1833_done
    eq rx1833_pos, -1, rx1833_fail
    jump $I10
  rx1833_done:
    rx1833_cur."!cursor_fail"()
    if_null rx1833_debug, debug_1354
    rx1833_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1354:
    .return (rx1833_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("357_1303923618.727") :method
.annotate 'line', 10
    $P1835 = self."!PREFIX__!subrule"("O", "&&")
    new $P1836, "ResizablePMCArray"
    push $P1836, $P1835
    .return ($P1836)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("358_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1840_tgt
    .local int rx1840_pos
    .local int rx1840_off
    .local int rx1840_eos
    .local int rx1840_rep
    .local pmc rx1840_cur
    .local pmc rx1840_debug
    (rx1840_cur, rx1840_pos, rx1840_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1840_cur
    .local pmc match
    .lex "$/", match
    length rx1840_eos, rx1840_tgt
    gt rx1840_pos, rx1840_eos, rx1840_done
    set rx1840_off, 0
    lt rx1840_pos, 2, rx1840_start
    sub rx1840_off, rx1840_pos, 1
    substr rx1840_tgt, rx1840_tgt, rx1840_off
  rx1840_start:
    eq $I10, 1, rx1840_restart
    if_null rx1840_debug, debug_1355
    rx1840_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1355:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1844_done
    goto rxscan1844_scan
  rxscan1844_loop:
    (rx1840_pos) = rx1840_cur."from"()
    inc rx1840_pos
    rx1840_cur."!cursor_from"(rx1840_pos)
    ge rx1840_pos, rx1840_eos, rxscan1844_done
  rxscan1844_scan:
    set_addr $I10, rxscan1844_loop
    rx1840_cur."!mark_push"(0, rx1840_pos, $I10)
  rxscan1844_done:
.annotate 'line', 697
  # rx subcapture "sym"
    set_addr $I10, rxcap_1845_fail
    rx1840_cur."!mark_push"(0, rx1840_pos, $I10)
  # rx literal  "||"
    add $I11, rx1840_pos, 2
    gt $I11, rx1840_eos, rx1840_fail
    sub $I11, rx1840_pos, rx1840_off
    substr $S10, rx1840_tgt, $I11, 2
    ne $S10, "||", rx1840_fail
    add rx1840_pos, 2
    set_addr $I10, rxcap_1845_fail
    ($I12, $I11) = rx1840_cur."!mark_peek"($I10)
    rx1840_cur."!cursor_pos"($I11)
    ($P10) = rx1840_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1840_pos, "")
    rx1840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1845_done
  rxcap_1845_fail:
    goto rx1840_fail
  rxcap_1845_done:
  # rx subrule "O" subtype=capture negate=
    rx1840_cur."!cursor_pos"(rx1840_pos)
    $P10 = rx1840_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1840_fail
    rx1840_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1840_pos = $P10."pos"()
  # rx pass
    rx1840_cur."!cursor_pass"(rx1840_pos, "infix:sym<||>")
    if_null rx1840_debug, debug_1356
    rx1840_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1840_pos)
  debug_1356:
    .return (rx1840_cur)
  rx1840_restart:
.annotate 'line', 10
    if_null rx1840_debug, debug_1357
    rx1840_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1357:
  rx1840_fail:
    (rx1840_rep, rx1840_pos, $I10, $P10) = rx1840_cur."!mark_fail"(0)
    lt rx1840_pos, -1, rx1840_done
    eq rx1840_pos, -1, rx1840_fail
    jump $I10
  rx1840_done:
    rx1840_cur."!cursor_fail"()
    if_null rx1840_debug, debug_1358
    rx1840_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1358:
    .return (rx1840_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("359_1303923618.727") :method
.annotate 'line', 10
    $P1842 = self."!PREFIX__!subrule"("O", "||")
    new $P1843, "ResizablePMCArray"
    push $P1843, $P1842
    .return ($P1843)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("360_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1847_tgt
    .local int rx1847_pos
    .local int rx1847_off
    .local int rx1847_eos
    .local int rx1847_rep
    .local pmc rx1847_cur
    .local pmc rx1847_debug
    (rx1847_cur, rx1847_pos, rx1847_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1847_cur
    .local pmc match
    .lex "$/", match
    length rx1847_eos, rx1847_tgt
    gt rx1847_pos, rx1847_eos, rx1847_done
    set rx1847_off, 0
    lt rx1847_pos, 2, rx1847_start
    sub rx1847_off, rx1847_pos, 1
    substr rx1847_tgt, rx1847_tgt, rx1847_off
  rx1847_start:
    eq $I10, 1, rx1847_restart
    if_null rx1847_debug, debug_1359
    rx1847_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1359:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1851_done
    goto rxscan1851_scan
  rxscan1851_loop:
    (rx1847_pos) = rx1847_cur."from"()
    inc rx1847_pos
    rx1847_cur."!cursor_from"(rx1847_pos)
    ge rx1847_pos, rx1847_eos, rxscan1851_done
  rxscan1851_scan:
    set_addr $I10, rxscan1851_loop
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  rxscan1851_done:
.annotate 'line', 698
  # rx subcapture "sym"
    set_addr $I10, rxcap_1852_fail
    rx1847_cur."!mark_push"(0, rx1847_pos, $I10)
  # rx literal  "//"
    add $I11, rx1847_pos, 2
    gt $I11, rx1847_eos, rx1847_fail
    sub $I11, rx1847_pos, rx1847_off
    substr $S10, rx1847_tgt, $I11, 2
    ne $S10, "//", rx1847_fail
    add rx1847_pos, 2
    set_addr $I10, rxcap_1852_fail
    ($I12, $I11) = rx1847_cur."!mark_peek"($I10)
    rx1847_cur."!cursor_pos"($I11)
    ($P10) = rx1847_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1847_pos, "")
    rx1847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1852_done
  rxcap_1852_fail:
    goto rx1847_fail
  rxcap_1852_done:
  # rx subrule "O" subtype=capture negate=
    rx1847_cur."!cursor_pos"(rx1847_pos)
    $P10 = rx1847_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1847_fail
    rx1847_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1847_pos = $P10."pos"()
  # rx pass
    rx1847_cur."!cursor_pass"(rx1847_pos, "infix:sym<//>")
    if_null rx1847_debug, debug_1360
    rx1847_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1847_pos)
  debug_1360:
    .return (rx1847_cur)
  rx1847_restart:
.annotate 'line', 10
    if_null rx1847_debug, debug_1361
    rx1847_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1361:
  rx1847_fail:
    (rx1847_rep, rx1847_pos, $I10, $P10) = rx1847_cur."!mark_fail"(0)
    lt rx1847_pos, -1, rx1847_done
    eq rx1847_pos, -1, rx1847_fail
    jump $I10
  rx1847_done:
    rx1847_cur."!cursor_fail"()
    if_null rx1847_debug, debug_1362
    rx1847_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1362:
    .return (rx1847_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("361_1303923618.727") :method
.annotate 'line', 10
    $P1849 = self."!PREFIX__!subrule"("O", "//")
    new $P1850, "ResizablePMCArray"
    push $P1850, $P1849
    .return ($P1850)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("362_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1854_tgt
    .local int rx1854_pos
    .local int rx1854_off
    .local int rx1854_eos
    .local int rx1854_rep
    .local pmc rx1854_cur
    .local pmc rx1854_debug
    (rx1854_cur, rx1854_pos, rx1854_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1854_cur
    .local pmc match
    .lex "$/", match
    length rx1854_eos, rx1854_tgt
    gt rx1854_pos, rx1854_eos, rx1854_done
    set rx1854_off, 0
    lt rx1854_pos, 2, rx1854_start
    sub rx1854_off, rx1854_pos, 1
    substr rx1854_tgt, rx1854_tgt, rx1854_off
  rx1854_start:
    eq $I10, 1, rx1854_restart
    if_null rx1854_debug, debug_1363
    rx1854_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1363:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1858_done
    goto rxscan1858_scan
  rxscan1858_loop:
    (rx1854_pos) = rx1854_cur."from"()
    inc rx1854_pos
    rx1854_cur."!cursor_from"(rx1854_pos)
    ge rx1854_pos, rx1854_eos, rxscan1858_done
  rxscan1858_scan:
    set_addr $I10, rxscan1858_loop
    rx1854_cur."!mark_push"(0, rx1854_pos, $I10)
  rxscan1858_done:
.annotate 'line', 701
  # rx literal  "??"
    add $I11, rx1854_pos, 2
    gt $I11, rx1854_eos, rx1854_fail
    sub $I11, rx1854_pos, rx1854_off
    substr $S10, rx1854_tgt, $I11, 2
    ne $S10, "??", rx1854_fail
    add rx1854_pos, 2
.annotate 'line', 702
  # rx subrule "ws" subtype=method negate=
    rx1854_cur."!cursor_pos"(rx1854_pos)
    $P10 = rx1854_cur."ws"()
    unless $P10, rx1854_fail
    rx1854_pos = $P10."pos"()
.annotate 'line', 703
  # rx subrule "EXPR" subtype=capture negate=
    rx1854_cur."!cursor_pos"(rx1854_pos)
    $P10 = rx1854_cur."EXPR"("i=")
    unless $P10, rx1854_fail
    rx1854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1854_pos = $P10."pos"()
.annotate 'line', 704
  # rx literal  "!!"
    add $I11, rx1854_pos, 2
    gt $I11, rx1854_eos, rx1854_fail
    sub $I11, rx1854_pos, rx1854_off
    substr $S10, rx1854_tgt, $I11, 2
    ne $S10, "!!", rx1854_fail
    add rx1854_pos, 2
.annotate 'line', 705
  # rx subrule "O" subtype=capture negate=
    rx1854_cur."!cursor_pos"(rx1854_pos)
    $P10 = rx1854_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1854_fail
    rx1854_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1854_pos = $P10."pos"()
.annotate 'line', 700
  # rx pass
    rx1854_cur."!cursor_pass"(rx1854_pos, "infix:sym<?? !!>")
    if_null rx1854_debug, debug_1364
    rx1854_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1854_pos)
  debug_1364:
    .return (rx1854_cur)
  rx1854_restart:
.annotate 'line', 10
    if_null rx1854_debug, debug_1365
    rx1854_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1365:
  rx1854_fail:
    (rx1854_rep, rx1854_pos, $I10, $P10) = rx1854_cur."!mark_fail"(0)
    lt rx1854_pos, -1, rx1854_done
    eq rx1854_pos, -1, rx1854_fail
    jump $I10
  rx1854_done:
    rx1854_cur."!cursor_fail"()
    if_null rx1854_debug, debug_1366
    rx1854_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1366:
    .return (rx1854_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("363_1303923618.727") :method
.annotate 'line', 10
    $P1856 = self."!PREFIX__!subrule"("ws", "??")
    new $P1857, "ResizablePMCArray"
    push $P1857, $P1856
    .return ($P1857)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("364_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1860_tgt
    .local int rx1860_pos
    .local int rx1860_off
    .local int rx1860_eos
    .local int rx1860_rep
    .local pmc rx1860_cur
    .local pmc rx1860_debug
    (rx1860_cur, rx1860_pos, rx1860_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1860_cur
    .local pmc match
    .lex "$/", match
    length rx1860_eos, rx1860_tgt
    gt rx1860_pos, rx1860_eos, rx1860_done
    set rx1860_off, 0
    lt rx1860_pos, 2, rx1860_start
    sub rx1860_off, rx1860_pos, 1
    substr rx1860_tgt, rx1860_tgt, rx1860_off
  rx1860_start:
    eq $I10, 1, rx1860_restart
    if_null rx1860_debug, debug_1367
    rx1860_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1367:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1864_done
    goto rxscan1864_scan
  rxscan1864_loop:
    (rx1860_pos) = rx1860_cur."from"()
    inc rx1860_pos
    rx1860_cur."!cursor_from"(rx1860_pos)
    ge rx1860_pos, rx1860_eos, rxscan1864_done
  rxscan1864_scan:
    set_addr $I10, rxscan1864_loop
    rx1860_cur."!mark_push"(0, rx1860_pos, $I10)
  rxscan1864_done:
.annotate 'line', 709
  # rx subcapture "sym"
    set_addr $I10, rxcap_1865_fail
    rx1860_cur."!mark_push"(0, rx1860_pos, $I10)
  # rx literal  "="
    add $I11, rx1860_pos, 1
    gt $I11, rx1860_eos, rx1860_fail
    sub $I11, rx1860_pos, rx1860_off
    ord $I11, rx1860_tgt, $I11
    ne $I11, 61, rx1860_fail
    add rx1860_pos, 1
    set_addr $I10, rxcap_1865_fail
    ($I12, $I11) = rx1860_cur."!mark_peek"($I10)
    rx1860_cur."!cursor_pos"($I11)
    ($P10) = rx1860_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1860_pos, "")
    rx1860_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1865_done
  rxcap_1865_fail:
    goto rx1860_fail
  rxcap_1865_done:
  # rx subrule "panic" subtype=method negate=
    rx1860_cur."!cursor_pos"(rx1860_pos)
    $P10 = rx1860_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1860_fail
    rx1860_pos = $P10."pos"()
.annotate 'line', 708
  # rx pass
    rx1860_cur."!cursor_pass"(rx1860_pos, "infix:sym<=>")
    if_null rx1860_debug, debug_1368
    rx1860_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1860_pos)
  debug_1368:
    .return (rx1860_cur)
  rx1860_restart:
.annotate 'line', 10
    if_null rx1860_debug, debug_1369
    rx1860_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1369:
  rx1860_fail:
    (rx1860_rep, rx1860_pos, $I10, $P10) = rx1860_cur."!mark_fail"(0)
    lt rx1860_pos, -1, rx1860_done
    eq rx1860_pos, -1, rx1860_fail
    jump $I10
  rx1860_done:
    rx1860_cur."!cursor_fail"()
    if_null rx1860_debug, debug_1370
    rx1860_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1370:
    .return (rx1860_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("365_1303923618.727") :method
.annotate 'line', 10
    $P1862 = self."!PREFIX__!subrule"("panic", "=")
    new $P1863, "ResizablePMCArray"
    push $P1863, $P1862
    .return ($P1863)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("366_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1867_tgt
    .local int rx1867_pos
    .local int rx1867_off
    .local int rx1867_eos
    .local int rx1867_rep
    .local pmc rx1867_cur
    .local pmc rx1867_debug
    (rx1867_cur, rx1867_pos, rx1867_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1867_cur
    .local pmc match
    .lex "$/", match
    length rx1867_eos, rx1867_tgt
    gt rx1867_pos, rx1867_eos, rx1867_done
    set rx1867_off, 0
    lt rx1867_pos, 2, rx1867_start
    sub rx1867_off, rx1867_pos, 1
    substr rx1867_tgt, rx1867_tgt, rx1867_off
  rx1867_start:
    eq $I10, 1, rx1867_restart
    if_null rx1867_debug, debug_1371
    rx1867_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1371:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1871_done
    goto rxscan1871_scan
  rxscan1871_loop:
    (rx1867_pos) = rx1867_cur."from"()
    inc rx1867_pos
    rx1867_cur."!cursor_from"(rx1867_pos)
    ge rx1867_pos, rx1867_eos, rxscan1871_done
  rxscan1871_scan:
    set_addr $I10, rxscan1871_loop
    rx1867_cur."!mark_push"(0, rx1867_pos, $I10)
  rxscan1871_done:
.annotate 'line', 711
  # rx subcapture "sym"
    set_addr $I10, rxcap_1872_fail
    rx1867_cur."!mark_push"(0, rx1867_pos, $I10)
  # rx literal  ":="
    add $I11, rx1867_pos, 2
    gt $I11, rx1867_eos, rx1867_fail
    sub $I11, rx1867_pos, rx1867_off
    substr $S10, rx1867_tgt, $I11, 2
    ne $S10, ":=", rx1867_fail
    add rx1867_pos, 2
    set_addr $I10, rxcap_1872_fail
    ($I12, $I11) = rx1867_cur."!mark_peek"($I10)
    rx1867_cur."!cursor_pos"($I11)
    ($P10) = rx1867_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1867_pos, "")
    rx1867_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1872_done
  rxcap_1872_fail:
    goto rx1867_fail
  rxcap_1872_done:
  # rx subrule "O" subtype=capture negate=
    rx1867_cur."!cursor_pos"(rx1867_pos)
    $P10 = rx1867_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1867_fail
    rx1867_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1867_pos = $P10."pos"()
  # rx pass
    rx1867_cur."!cursor_pass"(rx1867_pos, "infix:sym<:=>")
    if_null rx1867_debug, debug_1372
    rx1867_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1867_pos)
  debug_1372:
    .return (rx1867_cur)
  rx1867_restart:
.annotate 'line', 10
    if_null rx1867_debug, debug_1373
    rx1867_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1373:
  rx1867_fail:
    (rx1867_rep, rx1867_pos, $I10, $P10) = rx1867_cur."!mark_fail"(0)
    lt rx1867_pos, -1, rx1867_done
    eq rx1867_pos, -1, rx1867_fail
    jump $I10
  rx1867_done:
    rx1867_cur."!cursor_fail"()
    if_null rx1867_debug, debug_1374
    rx1867_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1374:
    .return (rx1867_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("367_1303923618.727") :method
.annotate 'line', 10
    $P1869 = self."!PREFIX__!subrule"("O", ":=")
    new $P1870, "ResizablePMCArray"
    push $P1870, $P1869
    .return ($P1870)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("368_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1874_tgt
    .local int rx1874_pos
    .local int rx1874_off
    .local int rx1874_eos
    .local int rx1874_rep
    .local pmc rx1874_cur
    .local pmc rx1874_debug
    (rx1874_cur, rx1874_pos, rx1874_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1874_cur
    .local pmc match
    .lex "$/", match
    length rx1874_eos, rx1874_tgt
    gt rx1874_pos, rx1874_eos, rx1874_done
    set rx1874_off, 0
    lt rx1874_pos, 2, rx1874_start
    sub rx1874_off, rx1874_pos, 1
    substr rx1874_tgt, rx1874_tgt, rx1874_off
  rx1874_start:
    eq $I10, 1, rx1874_restart
    if_null rx1874_debug, debug_1375
    rx1874_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1375:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1878_done
    goto rxscan1878_scan
  rxscan1878_loop:
    (rx1874_pos) = rx1874_cur."from"()
    inc rx1874_pos
    rx1874_cur."!cursor_from"(rx1874_pos)
    ge rx1874_pos, rx1874_eos, rxscan1878_done
  rxscan1878_scan:
    set_addr $I10, rxscan1878_loop
    rx1874_cur."!mark_push"(0, rx1874_pos, $I10)
  rxscan1878_done:
.annotate 'line', 712
  # rx subcapture "sym"
    set_addr $I10, rxcap_1879_fail
    rx1874_cur."!mark_push"(0, rx1874_pos, $I10)
  # rx literal  "::="
    add $I11, rx1874_pos, 3
    gt $I11, rx1874_eos, rx1874_fail
    sub $I11, rx1874_pos, rx1874_off
    substr $S10, rx1874_tgt, $I11, 3
    ne $S10, "::=", rx1874_fail
    add rx1874_pos, 3
    set_addr $I10, rxcap_1879_fail
    ($I12, $I11) = rx1874_cur."!mark_peek"($I10)
    rx1874_cur."!cursor_pos"($I11)
    ($P10) = rx1874_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1874_pos, "")
    rx1874_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1879_done
  rxcap_1879_fail:
    goto rx1874_fail
  rxcap_1879_done:
  # rx subrule "O" subtype=capture negate=
    rx1874_cur."!cursor_pos"(rx1874_pos)
    $P10 = rx1874_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1874_fail
    rx1874_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1874_pos = $P10."pos"()
  # rx pass
    rx1874_cur."!cursor_pass"(rx1874_pos, "infix:sym<::=>")
    if_null rx1874_debug, debug_1376
    rx1874_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1874_pos)
  debug_1376:
    .return (rx1874_cur)
  rx1874_restart:
.annotate 'line', 10
    if_null rx1874_debug, debug_1377
    rx1874_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1377:
  rx1874_fail:
    (rx1874_rep, rx1874_pos, $I10, $P10) = rx1874_cur."!mark_fail"(0)
    lt rx1874_pos, -1, rx1874_done
    eq rx1874_pos, -1, rx1874_fail
    jump $I10
  rx1874_done:
    rx1874_cur."!cursor_fail"()
    if_null rx1874_debug, debug_1378
    rx1874_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1378:
    .return (rx1874_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("369_1303923618.727") :method
.annotate 'line', 10
    $P1876 = self."!PREFIX__!subrule"("O", "::=")
    new $P1877, "ResizablePMCArray"
    push $P1877, $P1876
    .return ($P1877)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("370_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1881_tgt
    .local int rx1881_pos
    .local int rx1881_off
    .local int rx1881_eos
    .local int rx1881_rep
    .local pmc rx1881_cur
    .local pmc rx1881_debug
    (rx1881_cur, rx1881_pos, rx1881_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1881_cur
    .local pmc match
    .lex "$/", match
    length rx1881_eos, rx1881_tgt
    gt rx1881_pos, rx1881_eos, rx1881_done
    set rx1881_off, 0
    lt rx1881_pos, 2, rx1881_start
    sub rx1881_off, rx1881_pos, 1
    substr rx1881_tgt, rx1881_tgt, rx1881_off
  rx1881_start:
    eq $I10, 1, rx1881_restart
    if_null rx1881_debug, debug_1379
    rx1881_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1379:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1885_done
    goto rxscan1885_scan
  rxscan1885_loop:
    (rx1881_pos) = rx1881_cur."from"()
    inc rx1881_pos
    rx1881_cur."!cursor_from"(rx1881_pos)
    ge rx1881_pos, rx1881_eos, rxscan1885_done
  rxscan1885_scan:
    set_addr $I10, rxscan1885_loop
    rx1881_cur."!mark_push"(0, rx1881_pos, $I10)
  rxscan1885_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_1886_fail
    rx1881_cur."!mark_push"(0, rx1881_pos, $I10)
  # rx literal  ","
    add $I11, rx1881_pos, 1
    gt $I11, rx1881_eos, rx1881_fail
    sub $I11, rx1881_pos, rx1881_off
    ord $I11, rx1881_tgt, $I11
    ne $I11, 44, rx1881_fail
    add rx1881_pos, 1
    set_addr $I10, rxcap_1886_fail
    ($I12, $I11) = rx1881_cur."!mark_peek"($I10)
    rx1881_cur."!cursor_pos"($I11)
    ($P10) = rx1881_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1881_pos, "")
    rx1881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1886_done
  rxcap_1886_fail:
    goto rx1881_fail
  rxcap_1886_done:
  # rx subrule "O" subtype=capture negate=
    rx1881_cur."!cursor_pos"(rx1881_pos)
    $P10 = rx1881_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1881_fail
    rx1881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1881_pos = $P10."pos"()
  # rx pass
    rx1881_cur."!cursor_pass"(rx1881_pos, "infix:sym<,>")
    if_null rx1881_debug, debug_1380
    rx1881_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1881_pos)
  debug_1380:
    .return (rx1881_cur)
  rx1881_restart:
.annotate 'line', 10
    if_null rx1881_debug, debug_1381
    rx1881_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1381:
  rx1881_fail:
    (rx1881_rep, rx1881_pos, $I10, $P10) = rx1881_cur."!mark_fail"(0)
    lt rx1881_pos, -1, rx1881_done
    eq rx1881_pos, -1, rx1881_fail
    jump $I10
  rx1881_done:
    rx1881_cur."!cursor_fail"()
    if_null rx1881_debug, debug_1382
    rx1881_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1382:
    .return (rx1881_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("371_1303923618.727") :method
.annotate 'line', 10
    $P1883 = self."!PREFIX__!subrule"("O", ",")
    new $P1884, "ResizablePMCArray"
    push $P1884, $P1883
    .return ($P1884)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("372_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .const 'Sub' $P1896 = "374_1303923618.727" 
    capture_lex $P1896
    .local string rx1888_tgt
    .local int rx1888_pos
    .local int rx1888_off
    .local int rx1888_eos
    .local int rx1888_rep
    .local pmc rx1888_cur
    .local pmc rx1888_debug
    (rx1888_cur, rx1888_pos, rx1888_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1888_cur
    .local pmc match
    .lex "$/", match
    length rx1888_eos, rx1888_tgt
    gt rx1888_pos, rx1888_eos, rx1888_done
    set rx1888_off, 0
    lt rx1888_pos, 2, rx1888_start
    sub rx1888_off, rx1888_pos, 1
    substr rx1888_tgt, rx1888_tgt, rx1888_off
  rx1888_start:
    eq $I10, 1, rx1888_restart
    if_null rx1888_debug, debug_1383
    rx1888_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1383:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1891_done
    goto rxscan1891_scan
  rxscan1891_loop:
    (rx1888_pos) = rx1888_cur."from"()
    inc rx1888_pos
    rx1888_cur."!cursor_from"(rx1888_pos)
    ge rx1888_pos, rx1888_eos, rxscan1891_done
  rxscan1891_scan:
    set_addr $I10, rxscan1891_loop
    rx1888_cur."!mark_push"(0, rx1888_pos, $I10)
  rxscan1891_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1892_fail
    rx1888_cur."!mark_push"(0, rx1888_pos, $I10)
  # rx literal  "return"
    add $I11, rx1888_pos, 6
    gt $I11, rx1888_eos, rx1888_fail
    sub $I11, rx1888_pos, rx1888_off
    substr $S10, rx1888_tgt, $I11, 6
    ne $S10, "return", rx1888_fail
    add rx1888_pos, 6
    set_addr $I10, rxcap_1892_fail
    ($I12, $I11) = rx1888_cur."!mark_peek"($I10)
    rx1888_cur."!cursor_pos"($I11)
    ($P10) = rx1888_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1888_pos, "")
    rx1888_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1892_done
  rxcap_1892_fail:
    goto rx1888_fail
  rxcap_1892_done:
  # rx charclass s
    ge rx1888_pos, rx1888_eos, rx1888_fail
    sub $I10, rx1888_pos, rx1888_off
    is_cclass $I11, 32, rx1888_tgt, $I10
    unless $I11, rx1888_fail
    inc rx1888_pos
  # rx subrule "O" subtype=capture negate=
    rx1888_cur."!cursor_pos"(rx1888_pos)
    $P10 = rx1888_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1888_fail
    rx1888_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1888_pos = $P10."pos"()
    rx1888_cur."!cursor_pos"(rx1888_pos)
    find_lex $P1893, unicode:"$\x{a2}"
    $P1894 = $P1893."MATCH"()
    store_lex "$/", $P1894
    .const 'Sub' $P1896 = "374_1303923618.727" 
    capture_lex $P1896
    $P1898 = $P1896()
  # rx pass
    rx1888_cur."!cursor_pass"(rx1888_pos, "prefix:sym<return>")
    if_null rx1888_debug, debug_1384
    rx1888_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1888_pos)
  debug_1384:
    .return (rx1888_cur)
  rx1888_restart:
.annotate 'line', 10
    if_null rx1888_debug, debug_1385
    rx1888_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1385:
  rx1888_fail:
    (rx1888_rep, rx1888_pos, $I10, $P10) = rx1888_cur."!mark_fail"(0)
    lt rx1888_pos, -1, rx1888_done
    eq rx1888_pos, -1, rx1888_fail
    jump $I10
  rx1888_done:
    rx1888_cur."!cursor_fail"()
    if_null rx1888_debug, debug_1386
    rx1888_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1386:
    .return (rx1888_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("373_1303923618.727") :method
.annotate 'line', 10
    new $P1890, "ResizablePMCArray"
    push $P1890, "return"
    .return ($P1890)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1895"  :anon :subid("374_1303923618.727") :outer("372_1303923618.727")
.annotate 'line', 716
    new $P1897, "Integer"
    assign $P1897, 1
    store_dynamic_lex "$*RETURN_USED", $P1897
    .return ($P1897)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("375_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1900_tgt
    .local int rx1900_pos
    .local int rx1900_off
    .local int rx1900_eos
    .local int rx1900_rep
    .local pmc rx1900_cur
    .local pmc rx1900_debug
    (rx1900_cur, rx1900_pos, rx1900_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1900_cur
    .local pmc match
    .lex "$/", match
    length rx1900_eos, rx1900_tgt
    gt rx1900_pos, rx1900_eos, rx1900_done
    set rx1900_off, 0
    lt rx1900_pos, 2, rx1900_start
    sub rx1900_off, rx1900_pos, 1
    substr rx1900_tgt, rx1900_tgt, rx1900_off
  rx1900_start:
    eq $I10, 1, rx1900_restart
    if_null rx1900_debug, debug_1387
    rx1900_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1387:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1903_done
    goto rxscan1903_scan
  rxscan1903_loop:
    (rx1900_pos) = rx1900_cur."from"()
    inc rx1900_pos
    rx1900_cur."!cursor_from"(rx1900_pos)
    ge rx1900_pos, rx1900_eos, rxscan1903_done
  rxscan1903_scan:
    set_addr $I10, rxscan1903_loop
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  rxscan1903_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_1904_fail
    rx1900_cur."!mark_push"(0, rx1900_pos, $I10)
  # rx literal  "make"
    add $I11, rx1900_pos, 4
    gt $I11, rx1900_eos, rx1900_fail
    sub $I11, rx1900_pos, rx1900_off
    substr $S10, rx1900_tgt, $I11, 4
    ne $S10, "make", rx1900_fail
    add rx1900_pos, 4
    set_addr $I10, rxcap_1904_fail
    ($I12, $I11) = rx1900_cur."!mark_peek"($I10)
    rx1900_cur."!cursor_pos"($I11)
    ($P10) = rx1900_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1900_pos, "")
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1904_done
  rxcap_1904_fail:
    goto rx1900_fail
  rxcap_1904_done:
  # rx charclass s
    ge rx1900_pos, rx1900_eos, rx1900_fail
    sub $I10, rx1900_pos, rx1900_off
    is_cclass $I11, 32, rx1900_tgt, $I10
    unless $I11, rx1900_fail
    inc rx1900_pos
  # rx subrule "O" subtype=capture negate=
    rx1900_cur."!cursor_pos"(rx1900_pos)
    $P10 = rx1900_cur."O"("%list_prefix")
    unless $P10, rx1900_fail
    rx1900_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1900_pos = $P10."pos"()
  # rx pass
    rx1900_cur."!cursor_pass"(rx1900_pos, "prefix:sym<make>")
    if_null rx1900_debug, debug_1388
    rx1900_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1900_pos)
  debug_1388:
    .return (rx1900_cur)
  rx1900_restart:
.annotate 'line', 10
    if_null rx1900_debug, debug_1389
    rx1900_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1389:
  rx1900_fail:
    (rx1900_rep, rx1900_pos, $I10, $P10) = rx1900_cur."!mark_fail"(0)
    lt rx1900_pos, -1, rx1900_done
    eq rx1900_pos, -1, rx1900_fail
    jump $I10
  rx1900_done:
    rx1900_cur."!cursor_fail"()
    if_null rx1900_debug, debug_1390
    rx1900_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1390:
    .return (rx1900_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("376_1303923618.727") :method
.annotate 'line', 10
    new $P1902, "ResizablePMCArray"
    push $P1902, "make"
    .return ($P1902)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("377_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1906_tgt
    .local int rx1906_pos
    .local int rx1906_off
    .local int rx1906_eos
    .local int rx1906_rep
    .local pmc rx1906_cur
    .local pmc rx1906_debug
    (rx1906_cur, rx1906_pos, rx1906_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1906_cur
    .local pmc match
    .lex "$/", match
    length rx1906_eos, rx1906_tgt
    gt rx1906_pos, rx1906_eos, rx1906_done
    set rx1906_off, 0
    lt rx1906_pos, 2, rx1906_start
    sub rx1906_off, rx1906_pos, 1
    substr rx1906_tgt, rx1906_tgt, rx1906_off
  rx1906_start:
    eq $I10, 1, rx1906_restart
    if_null rx1906_debug, debug_1391
    rx1906_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1391:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1909_done
    goto rxscan1909_scan
  rxscan1909_loop:
    (rx1906_pos) = rx1906_cur."from"()
    inc rx1906_pos
    rx1906_cur."!cursor_from"(rx1906_pos)
    ge rx1906_pos, rx1906_eos, rxscan1909_done
  rxscan1909_scan:
    set_addr $I10, rxscan1909_loop
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  rxscan1909_done:
.annotate 'line', 718
  # rx subcapture "sym"
    set_addr $I10, rxcap_1910_fail
    rx1906_cur."!mark_push"(0, rx1906_pos, $I10)
  # rx literal  "last"
    add $I11, rx1906_pos, 4
    gt $I11, rx1906_eos, rx1906_fail
    sub $I11, rx1906_pos, rx1906_off
    substr $S10, rx1906_tgt, $I11, 4
    ne $S10, "last", rx1906_fail
    add rx1906_pos, 4
    set_addr $I10, rxcap_1910_fail
    ($I12, $I11) = rx1906_cur."!mark_peek"($I10)
    rx1906_cur."!cursor_pos"($I11)
    ($P10) = rx1906_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1906_pos, "")
    rx1906_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1910_done
  rxcap_1910_fail:
    goto rx1906_fail
  rxcap_1910_done:
  # rx pass
    rx1906_cur."!cursor_pass"(rx1906_pos, "term:sym<last>")
    if_null rx1906_debug, debug_1392
    rx1906_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1906_pos)
  debug_1392:
    .return (rx1906_cur)
  rx1906_restart:
.annotate 'line', 10
    if_null rx1906_debug, debug_1393
    rx1906_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1393:
  rx1906_fail:
    (rx1906_rep, rx1906_pos, $I10, $P10) = rx1906_cur."!mark_fail"(0)
    lt rx1906_pos, -1, rx1906_done
    eq rx1906_pos, -1, rx1906_fail
    jump $I10
  rx1906_done:
    rx1906_cur."!cursor_fail"()
    if_null rx1906_debug, debug_1394
    rx1906_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1394:
    .return (rx1906_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("378_1303923618.727") :method
.annotate 'line', 10
    new $P1908, "ResizablePMCArray"
    push $P1908, "last"
    .return ($P1908)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("379_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1912_tgt
    .local int rx1912_pos
    .local int rx1912_off
    .local int rx1912_eos
    .local int rx1912_rep
    .local pmc rx1912_cur
    .local pmc rx1912_debug
    (rx1912_cur, rx1912_pos, rx1912_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1912_cur
    .local pmc match
    .lex "$/", match
    length rx1912_eos, rx1912_tgt
    gt rx1912_pos, rx1912_eos, rx1912_done
    set rx1912_off, 0
    lt rx1912_pos, 2, rx1912_start
    sub rx1912_off, rx1912_pos, 1
    substr rx1912_tgt, rx1912_tgt, rx1912_off
  rx1912_start:
    eq $I10, 1, rx1912_restart
    if_null rx1912_debug, debug_1395
    rx1912_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1395:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1915_done
    goto rxscan1915_scan
  rxscan1915_loop:
    (rx1912_pos) = rx1912_cur."from"()
    inc rx1912_pos
    rx1912_cur."!cursor_from"(rx1912_pos)
    ge rx1912_pos, rx1912_eos, rxscan1915_done
  rxscan1915_scan:
    set_addr $I10, rxscan1915_loop
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  rxscan1915_done:
.annotate 'line', 719
  # rx subcapture "sym"
    set_addr $I10, rxcap_1916_fail
    rx1912_cur."!mark_push"(0, rx1912_pos, $I10)
  # rx literal  "next"
    add $I11, rx1912_pos, 4
    gt $I11, rx1912_eos, rx1912_fail
    sub $I11, rx1912_pos, rx1912_off
    substr $S10, rx1912_tgt, $I11, 4
    ne $S10, "next", rx1912_fail
    add rx1912_pos, 4
    set_addr $I10, rxcap_1916_fail
    ($I12, $I11) = rx1912_cur."!mark_peek"($I10)
    rx1912_cur."!cursor_pos"($I11)
    ($P10) = rx1912_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1912_pos, "")
    rx1912_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1916_done
  rxcap_1916_fail:
    goto rx1912_fail
  rxcap_1916_done:
  # rx pass
    rx1912_cur."!cursor_pass"(rx1912_pos, "term:sym<next>")
    if_null rx1912_debug, debug_1396
    rx1912_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1912_pos)
  debug_1396:
    .return (rx1912_cur)
  rx1912_restart:
.annotate 'line', 10
    if_null rx1912_debug, debug_1397
    rx1912_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1397:
  rx1912_fail:
    (rx1912_rep, rx1912_pos, $I10, $P10) = rx1912_cur."!mark_fail"(0)
    lt rx1912_pos, -1, rx1912_done
    eq rx1912_pos, -1, rx1912_fail
    jump $I10
  rx1912_done:
    rx1912_cur."!cursor_fail"()
    if_null rx1912_debug, debug_1398
    rx1912_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1398:
    .return (rx1912_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("380_1303923618.727") :method
.annotate 'line', 10
    new $P1914, "ResizablePMCArray"
    push $P1914, "next"
    .return ($P1914)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("381_1303923618.727") :method :outer("12_1303923618.727")
.annotate 'line', 10
    .local string rx1918_tgt
    .local int rx1918_pos
    .local int rx1918_off
    .local int rx1918_eos
    .local int rx1918_rep
    .local pmc rx1918_cur
    .local pmc rx1918_debug
    (rx1918_cur, rx1918_pos, rx1918_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1918_cur
    .local pmc match
    .lex "$/", match
    length rx1918_eos, rx1918_tgt
    gt rx1918_pos, rx1918_eos, rx1918_done
    set rx1918_off, 0
    lt rx1918_pos, 2, rx1918_start
    sub rx1918_off, rx1918_pos, 1
    substr rx1918_tgt, rx1918_tgt, rx1918_off
  rx1918_start:
    eq $I10, 1, rx1918_restart
    if_null rx1918_debug, debug_1399
    rx1918_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1399:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1921_done
    goto rxscan1921_scan
  rxscan1921_loop:
    (rx1918_pos) = rx1918_cur."from"()
    inc rx1918_pos
    rx1918_cur."!cursor_from"(rx1918_pos)
    ge rx1918_pos, rx1918_eos, rxscan1921_done
  rxscan1921_scan:
    set_addr $I10, rxscan1921_loop
    rx1918_cur."!mark_push"(0, rx1918_pos, $I10)
  rxscan1921_done:
.annotate 'line', 720
  # rx subcapture "sym"
    set_addr $I10, rxcap_1922_fail
    rx1918_cur."!mark_push"(0, rx1918_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1918_pos, 4
    gt $I11, rx1918_eos, rx1918_fail
    sub $I11, rx1918_pos, rx1918_off
    substr $S10, rx1918_tgt, $I11, 4
    ne $S10, "redo", rx1918_fail
    add rx1918_pos, 4
    set_addr $I10, rxcap_1922_fail
    ($I12, $I11) = rx1918_cur."!mark_peek"($I10)
    rx1918_cur."!cursor_pos"($I11)
    ($P10) = rx1918_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1918_pos, "")
    rx1918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1922_done
  rxcap_1922_fail:
    goto rx1918_fail
  rxcap_1922_done:
  # rx pass
    rx1918_cur."!cursor_pass"(rx1918_pos, "term:sym<redo>")
    if_null rx1918_debug, debug_1400
    rx1918_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1918_pos)
  debug_1400:
    .return (rx1918_cur)
  rx1918_restart:
.annotate 'line', 10
    if_null rx1918_debug, debug_1401
    rx1918_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1401:
  rx1918_fail:
    (rx1918_rep, rx1918_pos, $I10, $P10) = rx1918_cur."!mark_fail"(0)
    lt rx1918_pos, -1, rx1918_done
    eq rx1918_pos, -1, rx1918_fail
    jump $I10
  rx1918_done:
    rx1918_cur."!cursor_fail"()
    if_null rx1918_debug, debug_1402
    rx1918_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1402:
    .return (rx1918_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("382_1303923618.727") :method
.annotate 'line', 10
    new $P1920, "ResizablePMCArray"
    push $P1920, "redo"
    .return ($P1920)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("383_1303923618.727") :outer("12_1303923618.727")
    .param pmc param_1924
    .param pmc param_1925
.annotate 'line', 722
    .lex "self", param_1924
    .lex "$/", param_1925
.annotate 'line', 724
    new $P1926, "Undef"
    .lex "$t", $P1926
    find_lex $P1927, "$/"
    unless_null $P1927, vivify_1403
    $P1927 = root_new ['parrot';'ResizablePMCArray']
  vivify_1403:
    set $P1928, $P1927[0]
    unless_null $P1928, vivify_1404
    new $P1928, "Undef"
  vivify_1404:
    store_lex "$t", $P1928
    find_lex $P1929, "$/"
    unless_null $P1929, vivify_1405
    $P1929 = root_new ['parrot';'ResizablePMCArray']
  vivify_1405:
    set $P1930, $P1929[1]
    unless_null $P1930, vivify_1406
    new $P1930, "Undef"
  vivify_1406:
    find_lex $P1931, "$/"
    unless_null $P1931, vivify_1407
    $P1931 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1931
  vivify_1407:
    set $P1931[0], $P1930
    find_lex $P1932, "$t"
    unless_null $P1932, vivify_1408
    new $P1932, "Undef"
  vivify_1408:
    find_lex $P1933, "$/"
    unless_null $P1933, vivify_1409
    $P1933 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1933
  vivify_1409:
    set $P1933[1], $P1932
.annotate 'line', 722
    .return ($P1932)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2656"  :subid("385_1303923618.727") :outer("10_1303923618.727")
.annotate 'line', 728
    .const 'Sub' $P2722 = "406_1303923618.727" 
    capture_lex $P2722
    .const 'Sub' $P2715 = "404_1303923618.727" 
    capture_lex $P2715
    .const 'Sub' $P2710 = "402_1303923618.727" 
    capture_lex $P2710
    .const 'Sub' $P2698 = "399_1303923618.727" 
    capture_lex $P2698
    .const 'Sub' $P2688 = "396_1303923618.727" 
    capture_lex $P2688
    .const 'Sub' $P2683 = "394_1303923618.727" 
    capture_lex $P2683
    .const 'Sub' $P2674 = "391_1303923618.727" 
    capture_lex $P2674
    .const 'Sub' $P2669 = "389_1303923618.727" 
    capture_lex $P2669
    .const 'Sub' $P2660 = "386_1303923618.727" 
    capture_lex $P2660
    .lex "$?PACKAGE", $P2658
    .lex "$?CLASS", $P2659
    .const 'Sub' $P2715 = "404_1303923618.727" 
    capture_lex $P2715
    .return ($P2715)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1410") :outer("385_1303923618.727")
.annotate 'line', 728
    .const 'Sub' $P2657 = "385_1303923618.727" 
    .local pmc block
    set block, $P2657
    .const 'Sub' $P2722 = "406_1303923618.727" 
    capture_lex $P2722
    $P2722()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2721"  :anon :subid("406_1303923618.727") :outer("385_1303923618.727")
.annotate 'line', 728
    nqp_get_sc_object $P2723, "1303923606.34", 2
    .local pmc type_obj
    set type_obj, $P2723
    get_how $P2724, type_obj
    .const 'Sub' $P2725 = "386_1303923618.727" 
    $P2724."add_method"(type_obj, "metachar:sym<:my>", $P2725)
    get_how $P2726, type_obj
    get_global $P2727, "!PREFIX__metachar:sym<:my>"
    $P2726."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2727)
    get_how $P2728, type_obj
    .const 'Sub' $P2729 = "389_1303923618.727" 
    $P2728."add_method"(type_obj, "metachar:sym<{ }>", $P2729)
    get_how $P2730, type_obj
    get_global $P2731, "!PREFIX__metachar:sym<{ }>"
    $P2730."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2731)
    get_how $P2732, type_obj
    .const 'Sub' $P2733 = "391_1303923618.727" 
    $P2732."add_method"(type_obj, "metachar:sym<nqpvar>", $P2733)
    get_how $P2734, type_obj
    get_global $P2735, "!PREFIX__metachar:sym<nqpvar>"
    $P2734."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2735)
    get_how $P2736, type_obj
    .const 'Sub' $P2737 = "394_1303923618.727" 
    $P2736."add_method"(type_obj, "assertion:sym<{ }>", $P2737)
    get_how $P2738, type_obj
    get_global $P2739, "!PREFIX__assertion:sym<{ }>"
    $P2738."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2739)
    get_how $P2740, type_obj
    .const 'Sub' $P2741 = "396_1303923618.727" 
    $P2740."add_method"(type_obj, "assertion:sym<?{ }>", $P2741)
    get_how $P2742, type_obj
    get_global $P2743, "!PREFIX__assertion:sym<?{ }>"
    $P2742."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2743)
    get_how $P2744, type_obj
    .const 'Sub' $P2745 = "399_1303923618.727" 
    $P2744."add_method"(type_obj, "assertion:sym<name>", $P2745)
    get_how $P2746, type_obj
    get_global $P2747, "!PREFIX__assertion:sym<name>"
    $P2746."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2747)
    get_how $P2748, type_obj
    .const 'Sub' $P2749 = "402_1303923618.727" 
    $P2748."add_method"(type_obj, "assertion:sym<var>", $P2749)
    get_how $P2750, type_obj
    get_global $P2751, "!PREFIX__assertion:sym<var>"
    $P2750."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2751)
    get_how $P2752, type_obj
    .const 'Sub' $P2753 = "404_1303923618.727" 
    $P2752."add_method"(type_obj, "codeblock", $P2753)
    get_how $P2754, type_obj
    get_global $P2755, "!PREFIX__codeblock"
    $P2754."add_method"(type_obj, "!PREFIX__codeblock", $P2755)
    get_how $P2756, type_obj
    $P2757 = $P2756."compose"(type_obj)
    .return ($P2757)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("386_1303923618.727") :method :outer("385_1303923618.727")
.annotate 'line', 728
    .const 'Sub' $P2666 = "388_1303923618.727" 
    capture_lex $P2666
    .local string rx2661_tgt
    .local int rx2661_pos
    .local int rx2661_off
    .local int rx2661_eos
    .local int rx2661_rep
    .local pmc rx2661_cur
    .local pmc rx2661_debug
    (rx2661_cur, rx2661_pos, rx2661_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2661_cur
    .local pmc match
    .lex "$/", match
    length rx2661_eos, rx2661_tgt
    gt rx2661_pos, rx2661_eos, rx2661_done
    set rx2661_off, 0
    lt rx2661_pos, 2, rx2661_start
    sub rx2661_off, rx2661_pos, 1
    substr rx2661_tgt, rx2661_tgt, rx2661_off
  rx2661_start:
    eq $I10, 1, rx2661_restart
    if_null rx2661_debug, debug_1411
    rx2661_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1411:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2664_done
    goto rxscan2664_scan
  rxscan2664_loop:
    (rx2661_pos) = rx2661_cur."from"()
    inc rx2661_pos
    rx2661_cur."!cursor_from"(rx2661_pos)
    ge rx2661_pos, rx2661_eos, rxscan2664_done
  rxscan2664_scan:
    set_addr $I10, rxscan2664_loop
    rx2661_cur."!mark_push"(0, rx2661_pos, $I10)
  rxscan2664_done:
.annotate 'line', 730
  # rx literal  ":"
    add $I11, rx2661_pos, 1
    gt $I11, rx2661_eos, rx2661_fail
    sub $I11, rx2661_pos, rx2661_off
    ord $I11, rx2661_tgt, $I11
    ne $I11, 58, rx2661_fail
    add rx2661_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2661_cur."!cursor_pos"(rx2661_pos)
    .const 'Sub' $P2666 = "388_1303923618.727" 
    capture_lex $P2666
    $P10 = rx2661_cur."before"($P2666)
    unless $P10, rx2661_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2661_cur."!cursor_pos"(rx2661_pos)
    $P10 = rx2661_cur."LANG"("MAIN", "statement")
    unless $P10, rx2661_fail
    rx2661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2661_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2661_cur."!cursor_pos"(rx2661_pos)
    $P10 = rx2661_cur."ws"()
    unless $P10, rx2661_fail
    rx2661_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2661_pos, 1
    gt $I11, rx2661_eos, rx2661_fail
    sub $I11, rx2661_pos, rx2661_off
    ord $I11, rx2661_tgt, $I11
    ne $I11, 59, rx2661_fail
    add rx2661_pos, 1
.annotate 'line', 729
  # rx pass
    rx2661_cur."!cursor_pass"(rx2661_pos, "metachar:sym<:my>")
    if_null rx2661_debug, debug_1416
    rx2661_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2661_pos)
  debug_1416:
    .return (rx2661_cur)
  rx2661_restart:
.annotate 'line', 728
    if_null rx2661_debug, debug_1417
    rx2661_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1417:
  rx2661_fail:
    (rx2661_rep, rx2661_pos, $I10, $P10) = rx2661_cur."!mark_fail"(0)
    lt rx2661_pos, -1, rx2661_done
    eq rx2661_pos, -1, rx2661_fail
    jump $I10
  rx2661_done:
    rx2661_cur."!cursor_fail"()
    if_null rx2661_debug, debug_1418
    rx2661_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1418:
    .return (rx2661_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("387_1303923618.727") :method
.annotate 'line', 728
    new $P2663, "ResizablePMCArray"
    push $P2663, ":"
    .return ($P2663)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2665"  :anon :subid("388_1303923618.727") :method :outer("386_1303923618.727")
.annotate 'line', 730
    .local string rx2667_tgt
    .local int rx2667_pos
    .local int rx2667_off
    .local int rx2667_eos
    .local int rx2667_rep
    .local pmc rx2667_cur
    .local pmc rx2667_debug
    (rx2667_cur, rx2667_pos, rx2667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2667_cur
    .local pmc match
    .lex "$/", match
    length rx2667_eos, rx2667_tgt
    gt rx2667_pos, rx2667_eos, rx2667_done
    set rx2667_off, 0
    lt rx2667_pos, 2, rx2667_start
    sub rx2667_off, rx2667_pos, 1
    substr rx2667_tgt, rx2667_tgt, rx2667_off
  rx2667_start:
    eq $I10, 1, rx2667_restart
    if_null rx2667_debug, debug_1412
    rx2667_cur."!cursor_debug"("START", "")
  debug_1412:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2668_done
    goto rxscan2668_scan
  rxscan2668_loop:
    (rx2667_pos) = rx2667_cur."from"()
    inc rx2667_pos
    rx2667_cur."!cursor_from"(rx2667_pos)
    ge rx2667_pos, rx2667_eos, rxscan2668_done
  rxscan2668_scan:
    set_addr $I10, rxscan2668_loop
    rx2667_cur."!mark_push"(0, rx2667_pos, $I10)
  rxscan2668_done:
  # rx literal  "my"
    add $I11, rx2667_pos, 2
    gt $I11, rx2667_eos, rx2667_fail
    sub $I11, rx2667_pos, rx2667_off
    substr $S10, rx2667_tgt, $I11, 2
    ne $S10, "my", rx2667_fail
    add rx2667_pos, 2
  # rx pass
    rx2667_cur."!cursor_pass"(rx2667_pos, "")
    if_null rx2667_debug, debug_1413
    rx2667_cur."!cursor_debug"("PASS", "", " at pos=", rx2667_pos)
  debug_1413:
    .return (rx2667_cur)
  rx2667_restart:
    if_null rx2667_debug, debug_1414
    rx2667_cur."!cursor_debug"("NEXT", "")
  debug_1414:
  rx2667_fail:
    (rx2667_rep, rx2667_pos, $I10, $P10) = rx2667_cur."!mark_fail"(0)
    lt rx2667_pos, -1, rx2667_done
    eq rx2667_pos, -1, rx2667_fail
    jump $I10
  rx2667_done:
    rx2667_cur."!cursor_fail"()
    if_null rx2667_debug, debug_1415
    rx2667_cur."!cursor_debug"("FAIL", "")
  debug_1415:
    .return (rx2667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("389_1303923618.727") :method :outer("385_1303923618.727")
.annotate 'line', 728
    .local string rx2670_tgt
    .local int rx2670_pos
    .local int rx2670_off
    .local int rx2670_eos
    .local int rx2670_rep
    .local pmc rx2670_cur
    .local pmc rx2670_debug
    (rx2670_cur, rx2670_pos, rx2670_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2670_cur
    .local pmc match
    .lex "$/", match
    length rx2670_eos, rx2670_tgt
    gt rx2670_pos, rx2670_eos, rx2670_done
    set rx2670_off, 0
    lt rx2670_pos, 2, rx2670_start
    sub rx2670_off, rx2670_pos, 1
    substr rx2670_tgt, rx2670_tgt, rx2670_off
  rx2670_start:
    eq $I10, 1, rx2670_restart
    if_null rx2670_debug, debug_1419
    rx2670_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1419:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2673_done
    goto rxscan2673_scan
  rxscan2673_loop:
    (rx2670_pos) = rx2670_cur."from"()
    inc rx2670_pos
    rx2670_cur."!cursor_from"(rx2670_pos)
    ge rx2670_pos, rx2670_eos, rxscan2673_done
  rxscan2673_scan:
    set_addr $I10, rxscan2673_loop
    rx2670_cur."!mark_push"(0, rx2670_pos, $I10)
  rxscan2673_done:
.annotate 'line', 734
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2670_pos, rx2670_off
    substr $S10, rx2670_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2670_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2670_cur."!cursor_pos"(rx2670_pos)
    $P10 = rx2670_cur."codeblock"()
    unless $P10, rx2670_fail
    rx2670_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2670_pos = $P10."pos"()
.annotate 'line', 733
  # rx pass
    rx2670_cur."!cursor_pass"(rx2670_pos, "metachar:sym<{ }>")
    if_null rx2670_debug, debug_1420
    rx2670_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2670_pos)
  debug_1420:
    .return (rx2670_cur)
  rx2670_restart:
.annotate 'line', 728
    if_null rx2670_debug, debug_1421
    rx2670_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1421:
  rx2670_fail:
    (rx2670_rep, rx2670_pos, $I10, $P10) = rx2670_cur."!mark_fail"(0)
    lt rx2670_pos, -1, rx2670_done
    eq rx2670_pos, -1, rx2670_fail
    jump $I10
  rx2670_done:
    rx2670_cur."!cursor_fail"()
    if_null rx2670_debug, debug_1422
    rx2670_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1422:
    .return (rx2670_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("390_1303923618.727") :method
.annotate 'line', 728
    new $P2672, "ResizablePMCArray"
    push $P2672, "{"
    .return ($P2672)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("391_1303923618.727") :method :outer("385_1303923618.727")
.annotate 'line', 728
    .const 'Sub' $P2680 = "393_1303923618.727" 
    capture_lex $P2680
    .local string rx2675_tgt
    .local int rx2675_pos
    .local int rx2675_off
    .local int rx2675_eos
    .local int rx2675_rep
    .local pmc rx2675_cur
    .local pmc rx2675_debug
    (rx2675_cur, rx2675_pos, rx2675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2675_cur
    .local pmc match
    .lex "$/", match
    length rx2675_eos, rx2675_tgt
    gt rx2675_pos, rx2675_eos, rx2675_done
    set rx2675_off, 0
    lt rx2675_pos, 2, rx2675_start
    sub rx2675_off, rx2675_pos, 1
    substr rx2675_tgt, rx2675_tgt, rx2675_off
  rx2675_start:
    eq $I10, 1, rx2675_restart
    if_null rx2675_debug, debug_1423
    rx2675_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1423:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2678_done
    goto rxscan2678_scan
  rxscan2678_loop:
    (rx2675_pos) = rx2675_cur."from"()
    inc rx2675_pos
    rx2675_cur."!cursor_from"(rx2675_pos)
    ge rx2675_pos, rx2675_eos, rxscan2678_done
  rxscan2678_scan:
    set_addr $I10, rxscan2678_loop
    rx2675_cur."!mark_push"(0, rx2675_pos, $I10)
  rxscan2678_done:
.annotate 'line', 738
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2675_pos, rx2675_off
    substr $S10, rx2675_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2675_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2675_cur."!cursor_pos"(rx2675_pos)
    .const 'Sub' $P2680 = "393_1303923618.727" 
    capture_lex $P2680
    $P10 = rx2675_cur."before"($P2680)
    unless $P10, rx2675_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2675_cur."!cursor_pos"(rx2675_pos)
    $P10 = rx2675_cur."LANG"("MAIN", "variable")
    unless $P10, rx2675_fail
    rx2675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2675_pos = $P10."pos"()
.annotate 'line', 737
  # rx pass
    rx2675_cur."!cursor_pass"(rx2675_pos, "metachar:sym<nqpvar>")
    if_null rx2675_debug, debug_1428
    rx2675_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2675_pos)
  debug_1428:
    .return (rx2675_cur)
  rx2675_restart:
.annotate 'line', 728
    if_null rx2675_debug, debug_1429
    rx2675_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1429:
  rx2675_fail:
    (rx2675_rep, rx2675_pos, $I10, $P10) = rx2675_cur."!mark_fail"(0)
    lt rx2675_pos, -1, rx2675_done
    eq rx2675_pos, -1, rx2675_fail
    jump $I10
  rx2675_done:
    rx2675_cur."!cursor_fail"()
    if_null rx2675_debug, debug_1430
    rx2675_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1430:
    .return (rx2675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("392_1303923618.727") :method
.annotate 'line', 728
    new $P2677, "ResizablePMCArray"
    push $P2677, "$"
    push $P2677, "@"
    .return ($P2677)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2679"  :anon :subid("393_1303923618.727") :method :outer("391_1303923618.727")
.annotate 'line', 738
    .local string rx2681_tgt
    .local int rx2681_pos
    .local int rx2681_off
    .local int rx2681_eos
    .local int rx2681_rep
    .local pmc rx2681_cur
    .local pmc rx2681_debug
    (rx2681_cur, rx2681_pos, rx2681_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2681_cur
    .local pmc match
    .lex "$/", match
    length rx2681_eos, rx2681_tgt
    gt rx2681_pos, rx2681_eos, rx2681_done
    set rx2681_off, 0
    lt rx2681_pos, 2, rx2681_start
    sub rx2681_off, rx2681_pos, 1
    substr rx2681_tgt, rx2681_tgt, rx2681_off
  rx2681_start:
    eq $I10, 1, rx2681_restart
    if_null rx2681_debug, debug_1424
    rx2681_cur."!cursor_debug"("START", "")
  debug_1424:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2682_done
    goto rxscan2682_scan
  rxscan2682_loop:
    (rx2681_pos) = rx2681_cur."from"()
    inc rx2681_pos
    rx2681_cur."!cursor_from"(rx2681_pos)
    ge rx2681_pos, rx2681_eos, rxscan2682_done
  rxscan2682_scan:
    set_addr $I10, rxscan2682_loop
    rx2681_cur."!mark_push"(0, rx2681_pos, $I10)
  rxscan2682_done:
  # rx charclass .
    ge rx2681_pos, rx2681_eos, rx2681_fail
    inc rx2681_pos
  # rx charclass w
    ge rx2681_pos, rx2681_eos, rx2681_fail
    sub $I10, rx2681_pos, rx2681_off
    is_cclass $I11, 8192, rx2681_tgt, $I10
    unless $I11, rx2681_fail
    inc rx2681_pos
  # rx pass
    rx2681_cur."!cursor_pass"(rx2681_pos, "")
    if_null rx2681_debug, debug_1425
    rx2681_cur."!cursor_debug"("PASS", "", " at pos=", rx2681_pos)
  debug_1425:
    .return (rx2681_cur)
  rx2681_restart:
    if_null rx2681_debug, debug_1426
    rx2681_cur."!cursor_debug"("NEXT", "")
  debug_1426:
  rx2681_fail:
    (rx2681_rep, rx2681_pos, $I10, $P10) = rx2681_cur."!mark_fail"(0)
    lt rx2681_pos, -1, rx2681_done
    eq rx2681_pos, -1, rx2681_fail
    jump $I10
  rx2681_done:
    rx2681_cur."!cursor_fail"()
    if_null rx2681_debug, debug_1427
    rx2681_cur."!cursor_debug"("FAIL", "")
  debug_1427:
    .return (rx2681_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("394_1303923618.727") :method :outer("385_1303923618.727")
.annotate 'line', 728
    .local string rx2684_tgt
    .local int rx2684_pos
    .local int rx2684_off
    .local int rx2684_eos
    .local int rx2684_rep
    .local pmc rx2684_cur
    .local pmc rx2684_debug
    (rx2684_cur, rx2684_pos, rx2684_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2684_cur
    .local pmc match
    .lex "$/", match
    length rx2684_eos, rx2684_tgt
    gt rx2684_pos, rx2684_eos, rx2684_done
    set rx2684_off, 0
    lt rx2684_pos, 2, rx2684_start
    sub rx2684_off, rx2684_pos, 1
    substr rx2684_tgt, rx2684_tgt, rx2684_off
  rx2684_start:
    eq $I10, 1, rx2684_restart
    if_null rx2684_debug, debug_1431
    rx2684_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1431:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2687_done
    goto rxscan2687_scan
  rxscan2687_loop:
    (rx2684_pos) = rx2684_cur."from"()
    inc rx2684_pos
    rx2684_cur."!cursor_from"(rx2684_pos)
    ge rx2684_pos, rx2684_eos, rxscan2687_done
  rxscan2687_scan:
    set_addr $I10, rxscan2687_loop
    rx2684_cur."!mark_push"(0, rx2684_pos, $I10)
  rxscan2687_done:
.annotate 'line', 742
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2684_pos, rx2684_off
    substr $S10, rx2684_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2684_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2684_cur."!cursor_pos"(rx2684_pos)
    $P10 = rx2684_cur."codeblock"()
    unless $P10, rx2684_fail
    rx2684_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2684_pos = $P10."pos"()
.annotate 'line', 741
  # rx pass
    rx2684_cur."!cursor_pass"(rx2684_pos, "assertion:sym<{ }>")
    if_null rx2684_debug, debug_1432
    rx2684_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2684_pos)
  debug_1432:
    .return (rx2684_cur)
  rx2684_restart:
.annotate 'line', 728
    if_null rx2684_debug, debug_1433
    rx2684_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1433:
  rx2684_fail:
    (rx2684_rep, rx2684_pos, $I10, $P10) = rx2684_cur."!mark_fail"(0)
    lt rx2684_pos, -1, rx2684_done
    eq rx2684_pos, -1, rx2684_fail
    jump $I10
  rx2684_done:
    rx2684_cur."!cursor_fail"()
    if_null rx2684_debug, debug_1434
    rx2684_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1434:
    .return (rx2684_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("395_1303923618.727") :method
.annotate 'line', 728
    new $P2686, "ResizablePMCArray"
    push $P2686, "{"
    .return ($P2686)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("396_1303923618.727") :method :outer("385_1303923618.727")
.annotate 'line', 728
    .const 'Sub' $P2694 = "398_1303923618.727" 
    capture_lex $P2694
    .local string rx2689_tgt
    .local int rx2689_pos
    .local int rx2689_off
    .local int rx2689_eos
    .local int rx2689_rep
    .local pmc rx2689_cur
    .local pmc rx2689_debug
    (rx2689_cur, rx2689_pos, rx2689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2689_cur
    .local pmc match
    .lex "$/", match
    length rx2689_eos, rx2689_tgt
    gt rx2689_pos, rx2689_eos, rx2689_done
    set rx2689_off, 0
    lt rx2689_pos, 2, rx2689_start
    sub rx2689_off, rx2689_pos, 1
    substr rx2689_tgt, rx2689_tgt, rx2689_off
  rx2689_start:
    eq $I10, 1, rx2689_restart
    if_null rx2689_debug, debug_1435
    rx2689_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1435:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2692_done
    goto rxscan2692_scan
  rxscan2692_loop:
    (rx2689_pos) = rx2689_cur."from"()
    inc rx2689_pos
    rx2689_cur."!cursor_from"(rx2689_pos)
    ge rx2689_pos, rx2689_eos, rxscan2692_done
  rxscan2692_scan:
    set_addr $I10, rxscan2692_loop
    rx2689_cur."!mark_push"(0, rx2689_pos, $I10)
  rxscan2692_done:
.annotate 'line', 746
  # rx subcapture "zw"
    set_addr $I10, rxcap_2697_fail
    rx2689_cur."!mark_push"(0, rx2689_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2689_pos, rx2689_eos, rx2689_fail
    sub $I10, rx2689_pos, rx2689_off
    substr $S10, rx2689_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2689_fail
    inc rx2689_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2689_cur."!cursor_pos"(rx2689_pos)
    .const 'Sub' $P2694 = "398_1303923618.727" 
    capture_lex $P2694
    $P10 = rx2689_cur."before"($P2694)
    unless $P10, rx2689_fail
    set_addr $I10, rxcap_2697_fail
    ($I12, $I11) = rx2689_cur."!mark_peek"($I10)
    rx2689_cur."!cursor_pos"($I11)
    ($P10) = rx2689_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2689_pos, "")
    rx2689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2697_done
  rxcap_2697_fail:
    goto rx2689_fail
  rxcap_2697_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2689_cur."!cursor_pos"(rx2689_pos)
    $P10 = rx2689_cur."codeblock"()
    unless $P10, rx2689_fail
    rx2689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2689_pos = $P10."pos"()
.annotate 'line', 745
  # rx pass
    rx2689_cur."!cursor_pass"(rx2689_pos, "assertion:sym<?{ }>")
    if_null rx2689_debug, debug_1440
    rx2689_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2689_pos)
  debug_1440:
    .return (rx2689_cur)
  rx2689_restart:
.annotate 'line', 728
    if_null rx2689_debug, debug_1441
    rx2689_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1441:
  rx2689_fail:
    (rx2689_rep, rx2689_pos, $I10, $P10) = rx2689_cur."!mark_fail"(0)
    lt rx2689_pos, -1, rx2689_done
    eq rx2689_pos, -1, rx2689_fail
    jump $I10
  rx2689_done:
    rx2689_cur."!cursor_fail"()
    if_null rx2689_debug, debug_1442
    rx2689_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1442:
    .return (rx2689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("397_1303923618.727") :method
.annotate 'line', 728
    new $P2691, "ResizablePMCArray"
    push $P2691, "!"
    push $P2691, "?"
    .return ($P2691)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2693"  :anon :subid("398_1303923618.727") :method :outer("396_1303923618.727")
.annotate 'line', 746
    .local string rx2695_tgt
    .local int rx2695_pos
    .local int rx2695_off
    .local int rx2695_eos
    .local int rx2695_rep
    .local pmc rx2695_cur
    .local pmc rx2695_debug
    (rx2695_cur, rx2695_pos, rx2695_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2695_cur
    .local pmc match
    .lex "$/", match
    length rx2695_eos, rx2695_tgt
    gt rx2695_pos, rx2695_eos, rx2695_done
    set rx2695_off, 0
    lt rx2695_pos, 2, rx2695_start
    sub rx2695_off, rx2695_pos, 1
    substr rx2695_tgt, rx2695_tgt, rx2695_off
  rx2695_start:
    eq $I10, 1, rx2695_restart
    if_null rx2695_debug, debug_1436
    rx2695_cur."!cursor_debug"("START", "")
  debug_1436:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2696_done
    goto rxscan2696_scan
  rxscan2696_loop:
    (rx2695_pos) = rx2695_cur."from"()
    inc rx2695_pos
    rx2695_cur."!cursor_from"(rx2695_pos)
    ge rx2695_pos, rx2695_eos, rxscan2696_done
  rxscan2696_scan:
    set_addr $I10, rxscan2696_loop
    rx2695_cur."!mark_push"(0, rx2695_pos, $I10)
  rxscan2696_done:
  # rx literal  "{"
    add $I11, rx2695_pos, 1
    gt $I11, rx2695_eos, rx2695_fail
    sub $I11, rx2695_pos, rx2695_off
    ord $I11, rx2695_tgt, $I11
    ne $I11, 123, rx2695_fail
    add rx2695_pos, 1
  # rx pass
    rx2695_cur."!cursor_pass"(rx2695_pos, "")
    if_null rx2695_debug, debug_1437
    rx2695_cur."!cursor_debug"("PASS", "", " at pos=", rx2695_pos)
  debug_1437:
    .return (rx2695_cur)
  rx2695_restart:
    if_null rx2695_debug, debug_1438
    rx2695_cur."!cursor_debug"("NEXT", "")
  debug_1438:
  rx2695_fail:
    (rx2695_rep, rx2695_pos, $I10, $P10) = rx2695_cur."!mark_fail"(0)
    lt rx2695_pos, -1, rx2695_done
    eq rx2695_pos, -1, rx2695_fail
    jump $I10
  rx2695_done:
    rx2695_cur."!cursor_fail"()
    if_null rx2695_debug, debug_1439
    rx2695_cur."!cursor_debug"("FAIL", "")
  debug_1439:
    .return (rx2695_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("399_1303923618.727") :method :outer("385_1303923618.727")
.annotate 'line', 728
    .const 'Sub' $P2707 = "401_1303923618.727" 
    capture_lex $P2707
    .local string rx2699_tgt
    .local int rx2699_pos
    .local int rx2699_off
    .local int rx2699_eos
    .local int rx2699_rep
    .local pmc rx2699_cur
    .local pmc rx2699_debug
    (rx2699_cur, rx2699_pos, rx2699_tgt, $I10) = self."!cursor_start"()
    rx2699_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2699_cur
    .local pmc match
    .lex "$/", match
    length rx2699_eos, rx2699_tgt
    gt rx2699_pos, rx2699_eos, rx2699_done
    set rx2699_off, 0
    lt rx2699_pos, 2, rx2699_start
    sub rx2699_off, rx2699_pos, 1
    substr rx2699_tgt, rx2699_tgt, rx2699_off
  rx2699_start:
    eq $I10, 1, rx2699_restart
    if_null rx2699_debug, debug_1443
    rx2699_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1443:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2703_done
    goto rxscan2703_scan
  rxscan2703_loop:
    (rx2699_pos) = rx2699_cur."from"()
    inc rx2699_pos
    rx2699_cur."!cursor_from"(rx2699_pos)
    ge rx2699_pos, rx2699_eos, rxscan2703_done
  rxscan2703_scan:
    set_addr $I10, rxscan2703_loop
    rx2699_cur."!mark_push"(0, rx2699_pos, $I10)
  rxscan2703_done:
.annotate 'line', 750
  # rx subrule "identifier" subtype=capture negate=
    rx2699_cur."!cursor_pos"(rx2699_pos)
    $P10 = rx2699_cur."identifier"()
    unless $P10, rx2699_fail
    rx2699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2699_pos = $P10."pos"()
.annotate 'line', 757
  # rx rxquantr2704 ** 0..1
    set_addr $I10, rxquantr2704_done
    rx2699_cur."!mark_push"(0, rx2699_pos, $I10)
  rxquantr2704_loop:
  alt2705_0:
.annotate 'line', 751
    set_addr $I10, alt2705_1
    rx2699_cur."!mark_push"(0, rx2699_pos, $I10)
.annotate 'line', 752
  # rx subrule "before" subtype=zerowidth negate=
    rx2699_cur."!cursor_pos"(rx2699_pos)
    .const 'Sub' $P2707 = "401_1303923618.727" 
    capture_lex $P2707
    $P10 = rx2699_cur."before"($P2707)
    unless $P10, rx2699_fail
    goto alt2705_end
  alt2705_1:
    set_addr $I10, alt2705_2
    rx2699_cur."!mark_push"(0, rx2699_pos, $I10)
.annotate 'line', 753
  # rx literal  "="
    add $I11, rx2699_pos, 1
    gt $I11, rx2699_eos, rx2699_fail
    sub $I11, rx2699_pos, rx2699_off
    ord $I11, rx2699_tgt, $I11
    ne $I11, 61, rx2699_fail
    add rx2699_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2699_cur."!cursor_pos"(rx2699_pos)
    $P10 = rx2699_cur."assertion"()
    unless $P10, rx2699_fail
    rx2699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2699_pos = $P10."pos"()
    goto alt2705_end
  alt2705_2:
    set_addr $I10, alt2705_3
    rx2699_cur."!mark_push"(0, rx2699_pos, $I10)
.annotate 'line', 754
  # rx literal  ":"
    add $I11, rx2699_pos, 1
    gt $I11, rx2699_eos, rx2699_fail
    sub $I11, rx2699_pos, rx2699_off
    ord $I11, rx2699_tgt, $I11
    ne $I11, 58, rx2699_fail
    add rx2699_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2699_cur."!cursor_pos"(rx2699_pos)
    $P10 = rx2699_cur."arglist"()
    unless $P10, rx2699_fail
    rx2699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2699_pos = $P10."pos"()
    goto alt2705_end
  alt2705_3:
    set_addr $I10, alt2705_4
    rx2699_cur."!mark_push"(0, rx2699_pos, $I10)
.annotate 'line', 755
  # rx literal  "("
    add $I11, rx2699_pos, 1
    gt $I11, rx2699_eos, rx2699_fail
    sub $I11, rx2699_pos, rx2699_off
    ord $I11, rx2699_tgt, $I11
    ne $I11, 40, rx2699_fail
    add rx2699_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2699_cur."!cursor_pos"(rx2699_pos)
    $P10 = rx2699_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2699_fail
    rx2699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2699_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2699_pos, 1
    gt $I11, rx2699_eos, rx2699_fail
    sub $I11, rx2699_pos, rx2699_off
    ord $I11, rx2699_tgt, $I11
    ne $I11, 41, rx2699_fail
    add rx2699_pos, 1
    goto alt2705_end
  alt2705_4:
.annotate 'line', 756
  # rx subrule "normspace" subtype=method negate=
    rx2699_cur."!cursor_pos"(rx2699_pos)
    $P10 = rx2699_cur."normspace"()
    unless $P10, rx2699_fail
    rx2699_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2699_cur."!cursor_pos"(rx2699_pos)
    $P10 = rx2699_cur."nibbler"()
    unless $P10, rx2699_fail
    rx2699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2699_pos = $P10."pos"()
  alt2705_end:
.annotate 'line', 757
    set_addr $I10, rxquantr2704_done
    (rx2699_rep) = rx2699_cur."!mark_commit"($I10)
  rxquantr2704_done:
.annotate 'line', 749
  # rx pass
    rx2699_cur."!cursor_pass"(rx2699_pos, "assertion:sym<name>")
    if_null rx2699_debug, debug_1448
    rx2699_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2699_pos)
  debug_1448:
    .return (rx2699_cur)
  rx2699_restart:
.annotate 'line', 728
    if_null rx2699_debug, debug_1449
    rx2699_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1449:
  rx2699_fail:
    (rx2699_rep, rx2699_pos, $I10, $P10) = rx2699_cur."!mark_fail"(0)
    lt rx2699_pos, -1, rx2699_done
    eq rx2699_pos, -1, rx2699_fail
    jump $I10
  rx2699_done:
    rx2699_cur."!cursor_fail"()
    if_null rx2699_debug, debug_1450
    rx2699_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1450:
    .return (rx2699_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("400_1303923618.727") :method
.annotate 'line', 728
    $P2701 = self."!PREFIX__!subrule"("identifier", "")
    new $P2702, "ResizablePMCArray"
    push $P2702, $P2701
    .return ($P2702)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2706"  :anon :subid("401_1303923618.727") :method :outer("399_1303923618.727")
.annotate 'line', 752
    .local string rx2708_tgt
    .local int rx2708_pos
    .local int rx2708_off
    .local int rx2708_eos
    .local int rx2708_rep
    .local pmc rx2708_cur
    .local pmc rx2708_debug
    (rx2708_cur, rx2708_pos, rx2708_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2708_cur
    .local pmc match
    .lex "$/", match
    length rx2708_eos, rx2708_tgt
    gt rx2708_pos, rx2708_eos, rx2708_done
    set rx2708_off, 0
    lt rx2708_pos, 2, rx2708_start
    sub rx2708_off, rx2708_pos, 1
    substr rx2708_tgt, rx2708_tgt, rx2708_off
  rx2708_start:
    eq $I10, 1, rx2708_restart
    if_null rx2708_debug, debug_1444
    rx2708_cur."!cursor_debug"("START", "")
  debug_1444:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2709_done
    goto rxscan2709_scan
  rxscan2709_loop:
    (rx2708_pos) = rx2708_cur."from"()
    inc rx2708_pos
    rx2708_cur."!cursor_from"(rx2708_pos)
    ge rx2708_pos, rx2708_eos, rxscan2709_done
  rxscan2709_scan:
    set_addr $I10, rxscan2709_loop
    rx2708_cur."!mark_push"(0, rx2708_pos, $I10)
  rxscan2709_done:
  # rx literal  ">"
    add $I11, rx2708_pos, 1
    gt $I11, rx2708_eos, rx2708_fail
    sub $I11, rx2708_pos, rx2708_off
    ord $I11, rx2708_tgt, $I11
    ne $I11, 62, rx2708_fail
    add rx2708_pos, 1
  # rx pass
    rx2708_cur."!cursor_pass"(rx2708_pos, "")
    if_null rx2708_debug, debug_1445
    rx2708_cur."!cursor_debug"("PASS", "", " at pos=", rx2708_pos)
  debug_1445:
    .return (rx2708_cur)
  rx2708_restart:
    if_null rx2708_debug, debug_1446
    rx2708_cur."!cursor_debug"("NEXT", "")
  debug_1446:
  rx2708_fail:
    (rx2708_rep, rx2708_pos, $I10, $P10) = rx2708_cur."!mark_fail"(0)
    lt rx2708_pos, -1, rx2708_done
    eq rx2708_pos, -1, rx2708_fail
    jump $I10
  rx2708_done:
    rx2708_cur."!cursor_fail"()
    if_null rx2708_debug, debug_1447
    rx2708_cur."!cursor_debug"("FAIL", "")
  debug_1447:
    .return (rx2708_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("402_1303923618.727") :method :outer("385_1303923618.727")
.annotate 'line', 728
    .local string rx2711_tgt
    .local int rx2711_pos
    .local int rx2711_off
    .local int rx2711_eos
    .local int rx2711_rep
    .local pmc rx2711_cur
    .local pmc rx2711_debug
    (rx2711_cur, rx2711_pos, rx2711_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2711_cur
    .local pmc match
    .lex "$/", match
    length rx2711_eos, rx2711_tgt
    gt rx2711_pos, rx2711_eos, rx2711_done
    set rx2711_off, 0
    lt rx2711_pos, 2, rx2711_start
    sub rx2711_off, rx2711_pos, 1
    substr rx2711_tgt, rx2711_tgt, rx2711_off
  rx2711_start:
    eq $I10, 1, rx2711_restart
    if_null rx2711_debug, debug_1451
    rx2711_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1451:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2714_done
    goto rxscan2714_scan
  rxscan2714_loop:
    (rx2711_pos) = rx2711_cur."from"()
    inc rx2711_pos
    rx2711_cur."!cursor_from"(rx2711_pos)
    ge rx2711_pos, rx2711_eos, rxscan2714_done
  rxscan2714_scan:
    set_addr $I10, rxscan2714_loop
    rx2711_cur."!mark_push"(0, rx2711_pos, $I10)
  rxscan2714_done:
.annotate 'line', 761
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2711_pos, rx2711_off
    substr $S10, rx2711_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2711_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2711_cur."!cursor_pos"(rx2711_pos)
    $P10 = rx2711_cur."LANG"("MAIN", "variable")
    unless $P10, rx2711_fail
    rx2711_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2711_pos = $P10."pos"()
.annotate 'line', 760
  # rx pass
    rx2711_cur."!cursor_pass"(rx2711_pos, "assertion:sym<var>")
    if_null rx2711_debug, debug_1452
    rx2711_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2711_pos)
  debug_1452:
    .return (rx2711_cur)
  rx2711_restart:
.annotate 'line', 728
    if_null rx2711_debug, debug_1453
    rx2711_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1453:
  rx2711_fail:
    (rx2711_rep, rx2711_pos, $I10, $P10) = rx2711_cur."!mark_fail"(0)
    lt rx2711_pos, -1, rx2711_done
    eq rx2711_pos, -1, rx2711_fail
    jump $I10
  rx2711_done:
    rx2711_cur."!cursor_fail"()
    if_null rx2711_debug, debug_1454
    rx2711_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1454:
    .return (rx2711_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("403_1303923618.727") :method
.annotate 'line', 728
    new $P2713, "ResizablePMCArray"
    push $P2713, "$"
    push $P2713, "@"
    .return ($P2713)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("404_1303923618.727") :method :outer("385_1303923618.727")
.annotate 'line', 728
    .local string rx2716_tgt
    .local int rx2716_pos
    .local int rx2716_off
    .local int rx2716_eos
    .local int rx2716_rep
    .local pmc rx2716_cur
    .local pmc rx2716_debug
    (rx2716_cur, rx2716_pos, rx2716_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2716_cur
    .local pmc match
    .lex "$/", match
    length rx2716_eos, rx2716_tgt
    gt rx2716_pos, rx2716_eos, rx2716_done
    set rx2716_off, 0
    lt rx2716_pos, 2, rx2716_start
    sub rx2716_off, rx2716_pos, 1
    substr rx2716_tgt, rx2716_tgt, rx2716_off
  rx2716_start:
    eq $I10, 1, rx2716_restart
    if_null rx2716_debug, debug_1455
    rx2716_cur."!cursor_debug"("START", "codeblock")
  debug_1455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2720_done
    goto rxscan2720_scan
  rxscan2720_loop:
    (rx2716_pos) = rx2716_cur."from"()
    inc rx2716_pos
    rx2716_cur."!cursor_from"(rx2716_pos)
    ge rx2716_pos, rx2716_eos, rxscan2720_done
  rxscan2720_scan:
    set_addr $I10, rxscan2720_loop
    rx2716_cur."!mark_push"(0, rx2716_pos, $I10)
  rxscan2720_done:
.annotate 'line', 765
  # rx subrule "LANG" subtype=capture negate=
    rx2716_cur."!cursor_pos"(rx2716_pos)
    $P10 = rx2716_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2716_fail
    rx2716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2716_pos = $P10."pos"()
.annotate 'line', 764
  # rx pass
    rx2716_cur."!cursor_pass"(rx2716_pos, "codeblock")
    if_null rx2716_debug, debug_1456
    rx2716_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2716_pos)
  debug_1456:
    .return (rx2716_cur)
  rx2716_restart:
.annotate 'line', 728
    if_null rx2716_debug, debug_1457
    rx2716_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1457:
  rx2716_fail:
    (rx2716_rep, rx2716_pos, $I10, $P10) = rx2716_cur."!mark_fail"(0)
    lt rx2716_pos, -1, rx2716_done
    eq rx2716_pos, -1, rx2716_fail
    jump $I10
  rx2716_done:
    rx2716_cur."!cursor_fail"()
    if_null rx2716_debug, debug_1458
    rx2716_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1458:
    .return (rx2716_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("405_1303923618.727") :method
.annotate 'line', 728
    $P2718 = self."!PREFIX__!subrule"("LANG", "")
    new $P2719, "ResizablePMCArray"
    push $P2719, $P2718
    .return ($P2719)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2758"  :subid("407_1303923618.727") :outer("10_1303923618.727")
.annotate 'line', 771
    .const 'Sub' $P6925 = "577_1303923618.727" 
    capture_lex $P6925
    .const 'Sub' $P6908 = "576_1303923618.727" 
    capture_lex $P6908
    .const 'Sub' $P6903 = "575_1303923618.727" 
    capture_lex $P6903
    .const 'Sub' $P6898 = "574_1303923618.727" 
    capture_lex $P6898
    .const 'Sub' $P6893 = "573_1303923618.727" 
    capture_lex $P6893
    .const 'Sub' $P6876 = "572_1303923618.727" 
    capture_lex $P6876
    .const 'Sub' $P6865 = "571_1303923618.727" 
    capture_lex $P6865
    .const 'Sub' $P6854 = "570_1303923618.727" 
    capture_lex $P6854
    .const 'Sub' $P6846 = "569_1303923618.727" 
    capture_lex $P6846
    .const 'Sub' $P6841 = "568_1303923618.727" 
    capture_lex $P6841
    .const 'Sub' $P6826 = "567_1303923618.727" 
    capture_lex $P6826
    .const 'Sub' $P6818 = "566_1303923618.727" 
    capture_lex $P6818
    .const 'Sub' $P6757 = "565_1303923618.727" 
    capture_lex $P6757
    .const 'Sub' $P6742 = "564_1303923618.727" 
    capture_lex $P6742
    .const 'Sub' $P6734 = "563_1303923618.727" 
    capture_lex $P6734
    .const 'Sub' $P6726 = "562_1303923618.727" 
    capture_lex $P6726
    .const 'Sub' $P6718 = "561_1303923618.727" 
    capture_lex $P6718
    .const 'Sub' $P6710 = "560_1303923618.727" 
    capture_lex $P6710
    .const 'Sub' $P6702 = "559_1303923618.727" 
    capture_lex $P6702
    .const 'Sub' $P6673 = "558_1303923618.727" 
    capture_lex $P6673
    .const 'Sub' $P6658 = "557_1303923618.727" 
    capture_lex $P6658
    .const 'Sub' $P6650 = "556_1303923618.727" 
    capture_lex $P6650
    .const 'Sub' $P6636 = "555_1303923618.727" 
    capture_lex $P6636
    .const 'Sub' $P6622 = "554_1303923618.727" 
    capture_lex $P6622
    .const 'Sub' $P6608 = "553_1303923618.727" 
    capture_lex $P6608
    .const 'Sub' $P6600 = "552_1303923618.727" 
    capture_lex $P6600
    .const 'Sub' $P6570 = "551_1303923618.727" 
    capture_lex $P6570
    .const 'Sub' $P6532 = "549_1303923618.727" 
    capture_lex $P6532
    .const 'Sub' $P6524 = "548_1303923618.727" 
    capture_lex $P6524
    .const 'Sub' $P6516 = "547_1303923618.727" 
    capture_lex $P6516
    .const 'Sub' $P6485 = "546_1303923618.727" 
    capture_lex $P6485
    .const 'Sub' $P6466 = "545_1303923618.727" 
    capture_lex $P6466
    .const 'Sub' $P6458 = "544_1303923618.727" 
    capture_lex $P6458
    .const 'Sub' $P6450 = "543_1303923618.727" 
    capture_lex $P6450
    .const 'Sub' $P6342 = "540_1303923618.727" 
    capture_lex $P6342
    .const 'Sub' $P6334 = "539_1303923618.727" 
    capture_lex $P6334
    .const 'Sub' $P6324 = "538_1303923618.727" 
    capture_lex $P6324
    .const 'Sub' $P6290 = "537_1303923618.727" 
    capture_lex $P6290
    .const 'Sub' $P6248 = "535_1303923618.727" 
    capture_lex $P6248
    .const 'Sub' $P6234 = "534_1303923618.727" 
    capture_lex $P6234
    .const 'Sub' $P6224 = "533_1303923618.727" 
    capture_lex $P6224
    .const 'Sub' $P6172 = "532_1303923618.727" 
    capture_lex $P6172
    .const 'Sub' $P5896 = "528_1303923618.727" 
    capture_lex $P5896
    .const 'Sub' $P5814 = "526_1303923618.727" 
    capture_lex $P5814
    .const 'Sub' $P5806 = "525_1303923618.727" 
    capture_lex $P5806
    .const 'Sub' $P5790 = "524_1303923618.727" 
    capture_lex $P5790
    .const 'Sub' $P5775 = "523_1303923618.727" 
    capture_lex $P5775
    .const 'Sub' $P5752 = "522_1303923618.727" 
    capture_lex $P5752
    .const 'Sub' $P5649 = "521_1303923618.727" 
    capture_lex $P5649
    .const 'Sub' $P5595 = "518_1303923618.727" 
    capture_lex $P5595
    .const 'Sub' $P5414 = "515_1303923618.727" 
    capture_lex $P5414
    .const 'Sub' $P5087 = "508_1303923618.727" 
    capture_lex $P5087
    .const 'Sub' $P5079 = "507_1303923618.727" 
    capture_lex $P5079
    .const 'Sub' $P5071 = "506_1303923618.727" 
    capture_lex $P5071
    .const 'Sub' $P4946 = "504_1303923618.727" 
    capture_lex $P4946
    .const 'Sub' $P4938 = "503_1303923618.727" 
    capture_lex $P4938
    .const 'Sub' $P4923 = "502_1303923618.727" 
    capture_lex $P4923
    .const 'Sub' $P4908 = "501_1303923618.727" 
    capture_lex $P4908
    .const 'Sub' $P4893 = "500_1303923618.727" 
    capture_lex $P4893
    .const 'Sub' $P4871 = "499_1303923618.727" 
    capture_lex $P4871
    .const 'Sub' $P4863 = "498_1303923618.727" 
    capture_lex $P4863
    .const 'Sub' $P4855 = "497_1303923618.727" 
    capture_lex $P4855
    .const 'Sub' $P4847 = "496_1303923618.727" 
    capture_lex $P4847
    .const 'Sub' $P4539 = "490_1303923618.727" 
    capture_lex $P4539
    .const 'Sub' $P4531 = "489_1303923618.727" 
    capture_lex $P4531
    .const 'Sub' $P4523 = "488_1303923618.727" 
    capture_lex $P4523
    .const 'Sub' $P4515 = "487_1303923618.727" 
    capture_lex $P4515
    .const 'Sub' $P4507 = "486_1303923618.727" 
    capture_lex $P4507
    .const 'Sub' $P4499 = "485_1303923618.727" 
    capture_lex $P4499
    .const 'Sub' $P4491 = "484_1303923618.727" 
    capture_lex $P4491
    .const 'Sub' $P4288 = "478_1303923618.727" 
    capture_lex $P4288
    .const 'Sub' $P4261 = "477_1303923618.727" 
    capture_lex $P4261
    .const 'Sub' $P4247 = "476_1303923618.727" 
    capture_lex $P4247
    .const 'Sub' $P4239 = "475_1303923618.727" 
    capture_lex $P4239
    .const 'Sub' $P4231 = "474_1303923618.727" 
    capture_lex $P4231
    .const 'Sub' $P4223 = "473_1303923618.727" 
    capture_lex $P4223
    .const 'Sub' $P4215 = "472_1303923618.727" 
    capture_lex $P4215
    .const 'Sub' $P4207 = "471_1303923618.727" 
    capture_lex $P4207
    .const 'Sub' $P4199 = "470_1303923618.727" 
    capture_lex $P4199
    .const 'Sub' $P4191 = "469_1303923618.727" 
    capture_lex $P4191
    .const 'Sub' $P4183 = "468_1303923618.727" 
    capture_lex $P4183
    .const 'Sub' $P4175 = "467_1303923618.727" 
    capture_lex $P4175
    .const 'Sub' $P4167 = "466_1303923618.727" 
    capture_lex $P4167
    .const 'Sub' $P4159 = "465_1303923618.727" 
    capture_lex $P4159
    .const 'Sub' $P4151 = "464_1303923618.727" 
    capture_lex $P4151
    .const 'Sub' $P4143 = "463_1303923618.727" 
    capture_lex $P4143
    .const 'Sub' $P4127 = "462_1303923618.727" 
    capture_lex $P4127
    .const 'Sub' $P4073 = "461_1303923618.727" 
    capture_lex $P4073
    .const 'Sub' $P4056 = "460_1303923618.727" 
    capture_lex $P4056
    .const 'Sub' $P4032 = "459_1303923618.727" 
    capture_lex $P4032
    .const 'Sub' $P4009 = "458_1303923618.727" 
    capture_lex $P4009
    .const 'Sub' $P3982 = "457_1303923618.727" 
    capture_lex $P3982
    .const 'Sub' $P3945 = "456_1303923618.727" 
    capture_lex $P3945
    .const 'Sub' $P3930 = "455_1303923618.727" 
    capture_lex $P3930
    .const 'Sub' $P3918 = "454_1303923618.727" 
    capture_lex $P3918
    .const 'Sub' $P3867 = "452_1303923618.727" 
    capture_lex $P3867
    .const 'Sub' $P3842 = "451_1303923618.727" 
    capture_lex $P3842
    .const 'Sub' $P3835 = "450_1303923618.727" 
    capture_lex $P3835
    .const 'Sub' $P3793 = "449_1303923618.727" 
    capture_lex $P3793
    .const 'Sub' $P3743 = "447_1303923618.727" 
    capture_lex $P3743
    .const 'Sub' $P3726 = "446_1303923618.727" 
    capture_lex $P3726
    .const 'Sub' $P3687 = "444_1303923618.727" 
    capture_lex $P3687
    .const 'Sub' $P3679 = "443_1303923618.727" 
    capture_lex $P3679
    .const 'Sub' $P3671 = "442_1303923618.727" 
    capture_lex $P3671
    .const 'Sub' $P3654 = "441_1303923618.727" 
    capture_lex $P3654
    .const 'Sub' $P3558 = "439_1303923618.727" 
    capture_lex $P3558
    .const 'Sub' $P3514 = "437_1303923618.727" 
    capture_lex $P3514
    .const 'Sub' $P3399 = "436_1303923618.727" 
    capture_lex $P3399
    .const 'Sub' $P3368 = "435_1303923618.727" 
    capture_lex $P3368
    .const 'Sub' $P3360 = "434_1303923618.727" 
    capture_lex $P3360
    .const 'Sub' $P3231 = "428_1303923618.727" 
    capture_lex $P3231
    .const 'Sub' $P3196 = "426_1303923618.727" 
    capture_lex $P3196
    .const 'Sub' $P3191 = "425_1303923618.727" 
    capture_lex $P3191
    .const 'Sub' $P3186 = "424_1303923618.727" 
    capture_lex $P3186
    .const 'Sub' $P3073 = "421_1303923618.727" 
    capture_lex $P3073
    .const 'Sub' $P3055 = "420_1303923618.727" 
    capture_lex $P3055
    .const 'Sub' $P2972 = "418_1303923618.727" 
    capture_lex $P2972
    .const 'Sub' $P2957 = "417_1303923618.727" 
    capture_lex $P2957
    .const 'Sub' $P2870 = "416_1303923618.727" 
    capture_lex $P2870
    .const 'Sub' $P2844 = "414_1303923618.727" 
    capture_lex $P2844
    .const 'Sub' $P2828 = "413_1303923618.727" 
    capture_lex $P2828
    .const 'Sub' $P2804 = "412_1303923618.727" 
    capture_lex $P2804
    .const 'Sub' $P2768 = "409_1303923618.727" 
    capture_lex $P2768
    .const 'Sub' $P2760 = "408_1303923618.727" 
    capture_lex $P2760
.annotate 'line', 775
    .const 'Sub' $P2760 = "408_1303923618.727" 
    newclosure $P2767, $P2760
    .lex "xblock_immediate", $P2767
.annotate 'line', 780
    .const 'Sub' $P2768 = "409_1303923618.727" 
    newclosure $P2803, $P2768
    .lex "block_immediate", $P2803
.annotate 'line', 790
    .const 'Sub' $P2804 = "412_1303923618.727" 
    newclosure $P2827, $P2804
    .lex "vivitype", $P2827
.annotate 'line', 809
    .const 'Sub' $P2828 = "413_1303923618.727" 
    newclosure $P2843, $P2828
    .lex "colonpair_str", $P2843
.annotate 'line', 971
    .const 'Sub' $P2844 = "414_1303923618.727" 
    newclosure $P2869, $P2844
    .lex "import_HOW_exports", $P2869
.annotate 'line', 1076
    .const 'Sub' $P2870 = "416_1303923618.727" 
    newclosure $P2956, $P2870
    .lex "push_block_handler", $P2956
.annotate 'line', 1630
    .const 'Sub' $P2957 = "417_1303923618.727" 
    newclosure $P2971, $P2957
    .lex "only_star_block", $P2971
.annotate 'line', 1639
    .const 'Sub' $P2972 = "418_1303923618.727" 
    newclosure $P3054, $P2972
    .lex "attach_multi_signature", $P3054
.annotate 'line', 2105
    .const 'Sub' $P3055 = "420_1303923618.727" 
    newclosure $P3072, $P3055
    .lex "control", $P3072
.annotate 'line', 2124
    .const 'Sub' $P3073 = "421_1303923618.727" 
    newclosure $P3185, $P3073
    .lex "lexical_package_lookup", $P3185
.annotate 'line', 2173
    .const 'Sub' $P3186 = "424_1303923618.727" 
    newclosure $P3190, $P3186
    .lex "is_lexical", $P3190
.annotate 'line', 2179
    .const 'Sub' $P3191 = "425_1303923618.727" 
    newclosure $P3195, $P3191
    .lex "is_package", $P3195
.annotate 'line', 2185
    .const 'Sub' $P3196 = "426_1303923618.727" 
    newclosure $P3230, $P3196
    .lex "is_scope", $P3230
.annotate 'line', 2198
    .const 'Sub' $P3231 = "428_1303923618.727" 
    newclosure $P3351, $P3231
    .lex "find_sym", $P3351
.annotate 'line', 771
    .lex "$?PACKAGE", $P3352
    .lex "$?CLASS", $P3353
.annotate 'line', 773
    new $P3354, "ResizablePMCArray"
    find_lex $P3355, "$?PACKAGE"
    get_who $P3356, $P3355
    set $P3356["@BLOCK"], $P3354
    find_lex $P3357, "xblock_immediate"
    find_lex $P3358, "block_immediate"
    find_lex $P3359, "vivitype"
.annotate 'line', 801
    find_lex $P3398, "colonpair_str"
.annotate 'line', 954
    find_lex $P3792, "import_HOW_exports"
.annotate 'line', 1069
    find_lex $P4055, "push_block_handler"
.annotate 'line', 1557
    find_lex $P5593, "only_star_block"
    find_lex $P5594, "attach_multi_signature"
.annotate 'line', 2096
    find_lex $P6892, "control"
.annotate 'line', 2118
    find_lex $P6919, "lexical_package_lookup"
    find_lex $P6920, "is_lexical"
    find_lex $P6921, "is_package"
    find_lex $P6922, "is_scope"
    find_lex $P6923, "find_sym"
.annotate 'line', 771
    .return ($P6923)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1459") :outer("407_1303923618.727")
.annotate 'line', 771
    .const 'Sub' $P2759 = "407_1303923618.727" 
    .local pmc block
    set block, $P2759
    .const 'Sub' $P6925 = "577_1303923618.727" 
    capture_lex $P6925
    $P6925()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6924"  :anon :subid("577_1303923618.727") :outer("407_1303923618.727")
.annotate 'line', 771
    nqp_get_sc_object $P6926, "1303923606.34", 3
    .local pmc type_obj
    set type_obj, $P6926
    get_how $P6927, type_obj
    .const 'Sub' $P6928 = "434_1303923618.727" 
    $P6927."add_method"(type_obj, "TOP", $P6928)
    get_how $P6929, type_obj
    .const 'Sub' $P6930 = "435_1303923618.727" 
    $P6929."add_method"(type_obj, "deflongname", $P6930)
    get_how $P6931, type_obj
    .const 'Sub' $P6932 = "436_1303923618.727" 
    $P6931."add_method"(type_obj, "comp_unit", $P6932)
    get_how $P6933, type_obj
    .const 'Sub' $P6934 = "437_1303923618.727" 
    $P6933."add_method"(type_obj, "statementlist", $P6934)
    get_how $P6935, type_obj
    .const 'Sub' $P6936 = "439_1303923618.727" 
    $P6935."add_method"(type_obj, "statement", $P6936)
    get_how $P6937, type_obj
    .const 'Sub' $P6938 = "441_1303923618.727" 
    $P6937."add_method"(type_obj, "xblock", $P6938)
    get_how $P6939, type_obj
    .const 'Sub' $P6940 = "442_1303923618.727" 
    $P6939."add_method"(type_obj, "pblock", $P6940)
    get_how $P6941, type_obj
    .const 'Sub' $P6942 = "443_1303923618.727" 
    $P6941."add_method"(type_obj, "block", $P6942)
    get_how $P6943, type_obj
    .const 'Sub' $P6944 = "444_1303923618.727" 
    $P6943."add_method"(type_obj, "blockoid", $P6944)
    get_how $P6945, type_obj
    .const 'Sub' $P6946 = "446_1303923618.727" 
    $P6945."add_method"(type_obj, "newpad", $P6946)
    get_how $P6947, type_obj
    .const 'Sub' $P6948 = "447_1303923618.727" 
    $P6947."add_method"(type_obj, "outerctx", $P6948)
    get_how $P6949, type_obj
    .const 'Sub' $P6950 = "449_1303923618.727" 
    $P6949."add_method"(type_obj, "GLOBALish", $P6950)
    get_how $P6951, type_obj
    .const 'Sub' $P6952 = "450_1303923618.727" 
    $P6951."add_method"(type_obj, "you_are_here", $P6952)
    get_how $P6953, type_obj
    .const 'Sub' $P6954 = "451_1303923618.727" 
    $P6953."add_method"(type_obj, "statement_control:sym<use>", $P6954)
    get_how $P6955, type_obj
    .const 'Sub' $P6956 = "452_1303923618.727" 
    $P6955."add_method"(type_obj, "statement_control:sym<if>", $P6956)
    get_how $P6957, type_obj
    .const 'Sub' $P6958 = "454_1303923618.727" 
    $P6957."add_method"(type_obj, "statement_control:sym<unless>", $P6958)
    get_how $P6959, type_obj
    .const 'Sub' $P6960 = "455_1303923618.727" 
    $P6959."add_method"(type_obj, "statement_control:sym<while>", $P6960)
    get_how $P6961, type_obj
    .const 'Sub' $P6962 = "456_1303923618.727" 
    $P6961."add_method"(type_obj, "statement_control:sym<repeat>", $P6962)
    get_how $P6963, type_obj
    .const 'Sub' $P6964 = "457_1303923618.727" 
    $P6963."add_method"(type_obj, "statement_control:sym<for>", $P6964)
    get_how $P6965, type_obj
    .const 'Sub' $P6966 = "458_1303923618.727" 
    $P6965."add_method"(type_obj, "statement_control:sym<CATCH>", $P6966)
    get_how $P6967, type_obj
    .const 'Sub' $P6968 = "459_1303923618.727" 
    $P6967."add_method"(type_obj, "statement_control:sym<CONTROL>", $P6968)
    get_how $P6969, type_obj
    .const 'Sub' $P6970 = "460_1303923618.727" 
    $P6969."add_method"(type_obj, "statement_prefix:sym<INIT>", $P6970)
    get_how $P6971, type_obj
    .const 'Sub' $P6972 = "461_1303923618.727" 
    $P6971."add_method"(type_obj, "statement_prefix:sym<try>", $P6972)
    get_how $P6973, type_obj
    .const 'Sub' $P6974 = "462_1303923618.727" 
    $P6973."add_method"(type_obj, "blorst", $P6974)
    get_how $P6975, type_obj
    .const 'Sub' $P6976 = "463_1303923618.727" 
    $P6975."add_method"(type_obj, "statement_mod_cond:sym<if>", $P6976)
    get_how $P6977, type_obj
    .const 'Sub' $P6978 = "464_1303923618.727" 
    $P6977."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P6978)
    get_how $P6979, type_obj
    .const 'Sub' $P6980 = "465_1303923618.727" 
    $P6979."add_method"(type_obj, "statement_mod_loop:sym<while>", $P6980)
    get_how $P6981, type_obj
    .const 'Sub' $P6982 = "466_1303923618.727" 
    $P6981."add_method"(type_obj, "statement_mod_loop:sym<until>", $P6982)
    get_how $P6983, type_obj
    .const 'Sub' $P6984 = "467_1303923618.727" 
    $P6983."add_method"(type_obj, "term:sym<fatarrow>", $P6984)
    get_how $P6985, type_obj
    .const 'Sub' $P6986 = "468_1303923618.727" 
    $P6985."add_method"(type_obj, "term:sym<colonpair>", $P6986)
    get_how $P6987, type_obj
    .const 'Sub' $P6988 = "469_1303923618.727" 
    $P6987."add_method"(type_obj, "term:sym<variable>", $P6988)
    get_how $P6989, type_obj
    .const 'Sub' $P6990 = "470_1303923618.727" 
    $P6989."add_method"(type_obj, "term:sym<package_declarator>", $P6990)
    get_how $P6991, type_obj
    .const 'Sub' $P6992 = "471_1303923618.727" 
    $P6991."add_method"(type_obj, "term:sym<scope_declarator>", $P6992)
    get_how $P6993, type_obj
    .const 'Sub' $P6994 = "472_1303923618.727" 
    $P6993."add_method"(type_obj, "term:sym<routine_declarator>", $P6994)
    get_how $P6995, type_obj
    .const 'Sub' $P6996 = "473_1303923618.727" 
    $P6995."add_method"(type_obj, "term:sym<regex_declarator>", $P6996)
    get_how $P6997, type_obj
    .const 'Sub' $P6998 = "474_1303923618.727" 
    $P6997."add_method"(type_obj, "term:sym<statement_prefix>", $P6998)
    get_how $P6999, type_obj
    .const 'Sub' $P7000 = "475_1303923618.727" 
    $P6999."add_method"(type_obj, "term:sym<lambda>", $P7000)
    get_how $P7001, type_obj
    .const 'Sub' $P7002 = "476_1303923618.727" 
    $P7001."add_method"(type_obj, "fatarrow", $P7002)
    get_how $P7003, type_obj
    .const 'Sub' $P7004 = "477_1303923618.727" 
    $P7003."add_method"(type_obj, "colonpair", $P7004)
    get_how $P7005, type_obj
    .const 'Sub' $P7006 = "478_1303923618.727" 
    $P7005."add_method"(type_obj, "variable", $P7006)
    get_how $P7007, type_obj
    .const 'Sub' $P7008 = "484_1303923618.727" 
    $P7007."add_method"(type_obj, "package_declarator:sym<module>", $P7008)
    get_how $P7009, type_obj
    .const 'Sub' $P7010 = "485_1303923618.727" 
    $P7009."add_method"(type_obj, "package_declarator:sym<knowhow>", $P7010)
    get_how $P7011, type_obj
    .const 'Sub' $P7012 = "486_1303923618.727" 
    $P7011."add_method"(type_obj, "package_declarator:sym<class>", $P7012)
    get_how $P7013, type_obj
    .const 'Sub' $P7014 = "487_1303923618.727" 
    $P7013."add_method"(type_obj, "package_declarator:sym<grammar>", $P7014)
    get_how $P7015, type_obj
    .const 'Sub' $P7016 = "488_1303923618.727" 
    $P7015."add_method"(type_obj, "package_declarator:sym<role>", $P7016)
    get_how $P7017, type_obj
    .const 'Sub' $P7018 = "489_1303923618.727" 
    $P7017."add_method"(type_obj, "package_declarator:sym<native>", $P7018)
    get_how $P7019, type_obj
    .const 'Sub' $P7020 = "490_1303923618.727" 
    $P7019."add_method"(type_obj, "package_def", $P7020)
    get_how $P7021, type_obj
    .const 'Sub' $P7022 = "496_1303923618.727" 
    $P7021."add_method"(type_obj, "scope_declarator:sym<my>", $P7022)
    get_how $P7023, type_obj
    .const 'Sub' $P7024 = "497_1303923618.727" 
    $P7023."add_method"(type_obj, "scope_declarator:sym<our>", $P7024)
    get_how $P7025, type_obj
    .const 'Sub' $P7026 = "498_1303923618.727" 
    $P7025."add_method"(type_obj, "scope_declarator:sym<has>", $P7026)
    get_how $P7027, type_obj
    .const 'Sub' $P7028 = "499_1303923618.727" 
    $P7027."add_method"(type_obj, "scoped", $P7028)
    get_how $P7029, type_obj
    .const 'Sub' $P7030 = "500_1303923618.727" 
    $P7029."add_method"(type_obj, "declarator", $P7030)
    get_how $P7031, type_obj
    .const 'Sub' $P7032 = "501_1303923618.727" 
    $P7031."add_method"(type_obj, "multi_declarator:sym<multi>", $P7032)
    get_how $P7033, type_obj
    .const 'Sub' $P7034 = "502_1303923618.727" 
    $P7033."add_method"(type_obj, "multi_declarator:sym<proto>", $P7034)
    get_how $P7035, type_obj
    .const 'Sub' $P7036 = "503_1303923618.727" 
    $P7035."add_method"(type_obj, "multi_declarator:sym<null>", $P7036)
    get_how $P7037, type_obj
    .const 'Sub' $P7038 = "504_1303923618.727" 
    $P7037."add_method"(type_obj, "variable_declarator", $P7038)
    get_how $P7039, type_obj
    .const 'Sub' $P7040 = "506_1303923618.727" 
    $P7039."add_method"(type_obj, "routine_declarator:sym<sub>", $P7040)
    get_how $P7041, type_obj
    .const 'Sub' $P7042 = "507_1303923618.727" 
    $P7041."add_method"(type_obj, "routine_declarator:sym<method>", $P7042)
    get_how $P7043, type_obj
    .const 'Sub' $P7044 = "508_1303923618.727" 
    $P7043."add_method"(type_obj, "routine_def", $P7044)
    get_how $P7045, type_obj
    .const 'Sub' $P7046 = "515_1303923618.727" 
    $P7045."add_method"(type_obj, "method_def", $P7046)
    get_how $P7047, type_obj
    .const 'Sub' $P7048 = "518_1303923618.727" 
    $P7047."add_method"(type_obj, "signature", $P7048)
    get_how $P7049, type_obj
    .const 'Sub' $P7050 = "521_1303923618.727" 
    $P7049."add_method"(type_obj, "parameter", $P7050)
    get_how $P7051, type_obj
    .const 'Sub' $P7052 = "522_1303923618.727" 
    $P7051."add_method"(type_obj, "param_var", $P7052)
    get_how $P7053, type_obj
    .const 'Sub' $P7054 = "523_1303923618.727" 
    $P7053."add_method"(type_obj, "named_param", $P7054)
    get_how $P7055, type_obj
    .const 'Sub' $P7056 = "524_1303923618.727" 
    $P7055."add_method"(type_obj, "typename", $P7056)
    get_how $P7057, type_obj
    .const 'Sub' $P7058 = "525_1303923618.727" 
    $P7057."add_method"(type_obj, "trait", $P7058)
    get_how $P7059, type_obj
    .const 'Sub' $P7060 = "526_1303923618.727" 
    $P7059."add_method"(type_obj, "trait_mod:sym<is>", $P7060)
    get_how $P7061, type_obj
    .const 'Sub' $P7062 = "528_1303923618.727" 
    $P7061."add_method"(type_obj, "regex_declarator", $P7062)
    get_how $P7063, type_obj
    .const 'Sub' $P7064 = "532_1303923618.727" 
    $P7063."add_method"(type_obj, "dotty", $P7064)
    get_how $P7065, type_obj
    .const 'Sub' $P7066 = "533_1303923618.727" 
    $P7065."add_method"(type_obj, "term:sym<self>", $P7066)
    get_how $P7067, type_obj
    .const 'Sub' $P7068 = "534_1303923618.727" 
    $P7067."add_method"(type_obj, "term:sym<identifier>", $P7068)
    get_how $P7069, type_obj
    .const 'Sub' $P7070 = "535_1303923618.727" 
    $P7069."add_method"(type_obj, "term:sym<name>", $P7070)
    get_how $P7071, type_obj
    .const 'Sub' $P7072 = "537_1303923618.727" 
    $P7071."add_method"(type_obj, "term:sym<pir::op>", $P7072)
    get_how $P7073, type_obj
    .const 'Sub' $P7074 = "538_1303923618.727" 
    $P7073."add_method"(type_obj, "term:sym<onlystar>", $P7074)
    get_how $P7075, type_obj
    .const 'Sub' $P7076 = "539_1303923618.727" 
    $P7075."add_method"(type_obj, "args", $P7076)
    get_how $P7077, type_obj
    .const 'Sub' $P7078 = "540_1303923618.727" 
    $P7077."add_method"(type_obj, "arglist", $P7078)
    get_how $P7079, type_obj
    .const 'Sub' $P7080 = "543_1303923618.727" 
    $P7079."add_method"(type_obj, "term:sym<multi_declarator>", $P7080)
    get_how $P7081, type_obj
    .const 'Sub' $P7082 = "544_1303923618.727" 
    $P7081."add_method"(type_obj, "term:sym<value>", $P7082)
    get_how $P7083, type_obj
    .const 'Sub' $P7084 = "545_1303923618.727" 
    $P7083."add_method"(type_obj, "circumfix:sym<( )>", $P7084)
    get_how $P7085, type_obj
    .const 'Sub' $P7086 = "546_1303923618.727" 
    $P7085."add_method"(type_obj, "circumfix:sym<[ ]>", $P7086)
    get_how $P7087, type_obj
    .const 'Sub' $P7088 = "547_1303923618.727" 
    $P7087."add_method"(type_obj, "circumfix:sym<ang>", $P7088)
    get_how $P7089, type_obj
    .const 'Sub' $P7090 = "548_1303923618.727" 
    $P7089."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7090)
    get_how $P7091, type_obj
    .const 'Sub' $P7092 = "549_1303923618.727" 
    $P7091."add_method"(type_obj, "circumfix:sym<{ }>", $P7092)
    get_how $P7093, type_obj
    .const 'Sub' $P7094 = "551_1303923618.727" 
    $P7093."add_method"(type_obj, "circumfix:sym<sigil>", $P7094)
    get_how $P7095, type_obj
    .const 'Sub' $P7096 = "552_1303923618.727" 
    $P7095."add_method"(type_obj, "semilist", $P7096)
    get_how $P7097, type_obj
    .const 'Sub' $P7098 = "553_1303923618.727" 
    $P7097."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P7098)
    get_how $P7099, type_obj
    .const 'Sub' $P7100 = "554_1303923618.727" 
    $P7099."add_method"(type_obj, "postcircumfix:sym<{ }>", $P7100)
    get_how $P7101, type_obj
    .const 'Sub' $P7102 = "555_1303923618.727" 
    $P7101."add_method"(type_obj, "postcircumfix:sym<ang>", $P7102)
    get_how $P7103, type_obj
    .const 'Sub' $P7104 = "556_1303923618.727" 
    $P7103."add_method"(type_obj, "postcircumfix:sym<( )>", $P7104)
    get_how $P7105, type_obj
    .const 'Sub' $P7106 = "557_1303923618.727" 
    $P7105."add_method"(type_obj, "value", $P7106)
    get_how $P7107, type_obj
    .const 'Sub' $P7108 = "558_1303923618.727" 
    $P7107."add_method"(type_obj, "number", $P7108)
    get_how $P7109, type_obj
    .const 'Sub' $P7110 = "559_1303923618.727" 
    $P7109."add_method"(type_obj, "quote:sym<apos>", $P7110)
    get_how $P7111, type_obj
    .const 'Sub' $P7112 = "560_1303923618.727" 
    $P7111."add_method"(type_obj, "quote:sym<dblq>", $P7112)
    get_how $P7113, type_obj
    .const 'Sub' $P7114 = "561_1303923618.727" 
    $P7113."add_method"(type_obj, "quote:sym<qq>", $P7114)
    get_how $P7115, type_obj
    .const 'Sub' $P7116 = "562_1303923618.727" 
    $P7115."add_method"(type_obj, "quote:sym<q>", $P7116)
    get_how $P7117, type_obj
    .const 'Sub' $P7118 = "563_1303923618.727" 
    $P7117."add_method"(type_obj, "quote:sym<Q>", $P7118)
    get_how $P7119, type_obj
    .const 'Sub' $P7120 = "564_1303923618.727" 
    $P7119."add_method"(type_obj, "quote:sym<Q:PIR>", $P7120)
    get_how $P7121, type_obj
    .const 'Sub' $P7122 = "565_1303923618.727" 
    $P7121."add_method"(type_obj, "quote:sym</ />", $P7122)
    get_how $P7123, type_obj
    .const 'Sub' $P7124 = "566_1303923618.727" 
    $P7123."add_method"(type_obj, "quote_escape:sym<$>", $P7124)
    get_how $P7125, type_obj
    .const 'Sub' $P7126 = "567_1303923618.727" 
    $P7125."add_method"(type_obj, "quote_escape:sym<{ }>", $P7126)
    get_how $P7127, type_obj
    .const 'Sub' $P7128 = "568_1303923618.727" 
    $P7127."add_method"(type_obj, "quote_escape:sym<esc>", $P7128)
    get_how $P7129, type_obj
    .const 'Sub' $P7130 = "569_1303923618.727" 
    $P7129."add_method"(type_obj, "postfix:sym<.>", $P7130)
    get_how $P7131, type_obj
    .const 'Sub' $P7132 = "570_1303923618.727" 
    $P7131."add_method"(type_obj, "postfix:sym<++>", $P7132)
    get_how $P7133, type_obj
    .const 'Sub' $P7134 = "571_1303923618.727" 
    $P7133."add_method"(type_obj, "postfix:sym<-->", $P7134)
    get_how $P7135, type_obj
    .const 'Sub' $P7136 = "572_1303923618.727" 
    $P7135."add_method"(type_obj, "prefix:sym<make>", $P7136)
    get_how $P7137, type_obj
    .const 'Sub' $P7138 = "573_1303923618.727" 
    $P7137."add_method"(type_obj, "term:sym<next>", $P7138)
    get_how $P7139, type_obj
    .const 'Sub' $P7140 = "574_1303923618.727" 
    $P7139."add_method"(type_obj, "term:sym<last>", $P7140)
    get_how $P7141, type_obj
    .const 'Sub' $P7142 = "575_1303923618.727" 
    $P7141."add_method"(type_obj, "term:sym<redo>", $P7142)
    get_how $P7143, type_obj
    .const 'Sub' $P7144 = "576_1303923618.727" 
    $P7143."add_method"(type_obj, "infix:sym<~~>", $P7144)
    get_how $P7145, type_obj
    $P7146 = $P7145."compose"(type_obj)
    .return ($P7146)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("408_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_2761
.annotate 'line', 775
    .lex "$xblock", param_2761
.annotate 'line', 776
    find_lex $P2762, "$xblock"
    unless_null $P2762, vivify_1460
    $P2762 = root_new ['parrot';'ResizablePMCArray']
  vivify_1460:
    set $P2763, $P2762[1]
    unless_null $P2763, vivify_1461
    new $P2763, "Undef"
  vivify_1461:
    $P2764 = "block_immediate"($P2763)
    find_lex $P2765, "$xblock"
    unless_null $P2765, vivify_1462
    $P2765 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2765
  vivify_1462:
    set $P2765[1], $P2764
    find_lex $P2766, "$xblock"
    unless_null $P2766, vivify_1463
    new $P2766, "Undef"
  vivify_1463:
.annotate 'line', 775
    .return ($P2766)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("409_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_2769
.annotate 'line', 780
    .const 'Sub' $P2779 = "410_1303923618.727" 
    capture_lex $P2779
    .lex "$block", param_2769
.annotate 'line', 781
    find_lex $P2770, "$block"
    unless_null $P2770, vivify_1464
    new $P2770, "Undef"
  vivify_1464:
    $P2770."blocktype"("immediate")
.annotate 'line', 782
    find_lex $P2774, "$block"
    unless_null $P2774, vivify_1465
    new $P2774, "Undef"
  vivify_1465:
    $P2775 = $P2774."symtable"()
    unless $P2775, unless_2773
    set $P2772, $P2775
    goto unless_2773_end
  unless_2773:
    find_lex $P2776, "$block"
    unless_null $P2776, vivify_1466
    new $P2776, "Undef"
  vivify_1466:
    $P2777 = $P2776."handlers"()
    set $P2772, $P2777
  unless_2773_end:
    if $P2772, unless_2771_end
    .const 'Sub' $P2779 = "410_1303923618.727" 
    capture_lex $P2779
    $P2779()
  unless_2771_end:
    find_lex $P2802, "$block"
    unless_null $P2802, vivify_1473
    new $P2802, "Undef"
  vivify_1473:
.annotate 'line', 780
    .return ($P2802)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2778"  :anon :subid("410_1303923618.727") :outer("409_1303923618.727")
.annotate 'line', 782
    .const 'Sub' $P2793 = "411_1303923618.727" 
    capture_lex $P2793
.annotate 'line', 783
    new $P2780, "Undef"
    .lex "$stmts", $P2780
    get_hll_global $P2781, "GLOBAL"
    nqp_get_package_through_who $P2782, $P2781, "PAST"
    get_who $P2783, $P2782
    set $P2784, $P2783["Stmts"]
    find_lex $P2785, "$block"
    unless_null $P2785, vivify_1467
    new $P2785, "Undef"
  vivify_1467:
    $P2786 = $P2784."new"($P2785 :named("node"))
    store_lex "$stmts", $P2786
.annotate 'line', 784
    find_lex $P2788, "$block"
    unless_null $P2788, vivify_1468
    new $P2788, "Undef"
  vivify_1468:
    $P2789 = $P2788."list"()
    defined $I2790, $P2789
    unless $I2790, for_undef_1469
    iter $P2787, $P2789
    new $P2799, 'ExceptionHandler'
    set_label $P2799, loop2798_handler
    $P2799."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2799
  loop2798_test:
    unless $P2787, loop2798_done
    shift $P2791, $P2787
  loop2798_redo:
    .const 'Sub' $P2793 = "411_1303923618.727" 
    capture_lex $P2793
    $P2793($P2791)
  loop2798_next:
    goto loop2798_test
  loop2798_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2800, exception, 'type'
    eq $P2800, .CONTROL_LOOP_NEXT, loop2798_next
    eq $P2800, .CONTROL_LOOP_REDO, loop2798_redo
  loop2798_done:
    pop_eh 
  for_undef_1469:
.annotate 'line', 785
    find_lex $P2801, "$stmts"
    unless_null $P2801, vivify_1472
    new $P2801, "Undef"
  vivify_1472:
    store_lex "$block", $P2801
.annotate 'line', 782
    .return ($P2801)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2792"  :anon :subid("411_1303923618.727") :outer("410_1303923618.727")
    .param pmc param_2794
.annotate 'line', 784
    .lex "$_", param_2794
    find_lex $P2795, "$stmts"
    unless_null $P2795, vivify_1470
    new $P2795, "Undef"
  vivify_1470:
    find_lex $P2796, "$_"
    unless_null $P2796, vivify_1471
    new $P2796, "Undef"
  vivify_1471:
    $P2797 = $P2795."push"($P2796)
    .return ($P2797)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("412_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_2805
.annotate 'line', 790
    .lex "$sigil", param_2805
.annotate 'line', 791
    find_lex $P2808, "$sigil"
    unless_null $P2808, vivify_1474
    new $P2808, "Undef"
  vivify_1474:
    set $S2809, $P2808
    iseq $I2810, $S2809, "%"
    if $I2810, if_2807
.annotate 'line', 793
    find_lex $P2818, "$sigil"
    unless_null $P2818, vivify_1475
    new $P2818, "Undef"
  vivify_1475:
    set $S2819, $P2818
    iseq $I2820, $S2819, "@"
    if $I2820, if_2817
    new $P2826, "String"
    assign $P2826, "Undef"
    set $P2816, $P2826
    goto if_2817_end
  if_2817:
.annotate 'line', 794
    get_hll_global $P2821, "GLOBAL"
    nqp_get_package_through_who $P2822, $P2821, "PAST"
    get_who $P2823, $P2822
    set $P2824, $P2823["Op"]
    $P2825 = $P2824."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2816, $P2825
  if_2817_end:
    set $P2806, $P2816
.annotate 'line', 791
    goto if_2807_end
  if_2807:
.annotate 'line', 792
    get_hll_global $P2811, "GLOBAL"
    nqp_get_package_through_who $P2812, $P2811, "PAST"
    get_who $P2813, $P2812
    set $P2814, $P2813["Op"]
    $P2815 = $P2814."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2806, $P2815
  if_2807_end:
.annotate 'line', 790
    .return ($P2806)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("413_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_2829
.annotate 'line', 809
    .lex "$ast", param_2829
.annotate 'line', 810
    get_hll_global $P2832, "GLOBAL"
    nqp_get_package_through_who $P2833, $P2832, "PAST"
    get_who $P2834, $P2833
    set $P2835, $P2834["Op"]
    find_lex $P2836, "$ast"
    unless_null $P2836, vivify_1476
    new $P2836, "Undef"
  vivify_1476:
    $P2837 = $P2835."ACCEPTS"($P2836)
    if $P2837, if_2831
.annotate 'line', 812
    find_lex $P2841, "$ast"
    unless_null $P2841, vivify_1477
    new $P2841, "Undef"
  vivify_1477:
    $P2842 = $P2841."value"()
    set $P2830, $P2842
.annotate 'line', 810
    goto if_2831_end
  if_2831:
.annotate 'line', 811
    find_lex $P2838, "$ast"
    unless_null $P2838, vivify_1478
    new $P2838, "Undef"
  vivify_1478:
    $P2839 = $P2838."list"()
    join $S2840, " ", $P2839
    new $P2830, 'String'
    set $P2830, $S2840
  if_2831_end:
.annotate 'line', 809
    .return ($P2830)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("414_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_2845
.annotate 'line', 971
    .const 'Sub' $P2857 = "415_1303923618.727" 
    capture_lex $P2857
    .lex "$UNIT", param_2845
.annotate 'line', 973
    find_lex $P2848, "$UNIT"
    unless_null $P2848, vivify_1479
    new $P2848, "Undef"
  vivify_1479:
    exists $I2849, $P2848["EXPORTHOW"]
    if $I2849, if_2847
    new $P2846, 'Integer'
    set $P2846, $I2849
    goto if_2847_end
  if_2847:
.annotate 'line', 974
    find_lex $P2851, "$UNIT"
    unless_null $P2851, vivify_1480
    $P2851 = root_new ['parrot';'Hash']
  vivify_1480:
    set $P2852, $P2851["EXPORTHOW"]
    unless_null $P2852, vivify_1481
    new $P2852, "Undef"
  vivify_1481:
    get_who $P2853, $P2852
    defined $I2854, $P2853
    unless $I2854, for_undef_1482
    iter $P2850, $P2853
    new $P2867, 'ExceptionHandler'
    set_label $P2867, loop2866_handler
    $P2867."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2867
  loop2866_test:
    unless $P2850, loop2866_done
    shift $P2855, $P2850
  loop2866_redo:
    .const 'Sub' $P2857 = "415_1303923618.727" 
    capture_lex $P2857
    $P2857($P2855)
  loop2866_next:
    goto loop2866_test
  loop2866_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2868, exception, 'type'
    eq $P2868, .CONTROL_LOOP_NEXT, loop2866_next
    eq $P2868, .CONTROL_LOOP_REDO, loop2866_redo
  loop2866_done:
    pop_eh 
  for_undef_1482:
.annotate 'line', 973
    set $P2846, $P2850
  if_2847_end:
.annotate 'line', 971
    .return ($P2846)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2856"  :anon :subid("415_1303923618.727") :outer("414_1303923618.727")
    .param pmc param_2858
.annotate 'line', 974
    .lex "$_", param_2858
.annotate 'line', 975
    find_lex $P2859, "$_"
    unless_null $P2859, vivify_1483
    new $P2859, "Undef"
  vivify_1483:
    $P2860 = $P2859."value"()
    find_lex $P2861, "$_"
    unless_null $P2861, vivify_1484
    new $P2861, "Undef"
  vivify_1484:
    $P2862 = $P2861."key"()
    find_dynamic_lex $P2865, "%*HOW"
    unless_null $P2865, vivify_1485
    get_hll_global $P2863, "GLOBAL"
    get_who $P2864, $P2863
    set $P2865, $P2864["%HOW"]
    unless_null $P2865, vivify_1486
    die "Contextual %*HOW not found"
  vivify_1486:
    store_dynamic_lex "%*HOW", $P2865
  vivify_1485:
    set $P2865[$P2862], $P2860
.annotate 'line', 974
    .return ($P2860)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("416_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_2871
    .param pmc param_2872
.annotate 'line', 1076
    .lex "$/", param_2871
    .lex "$block", param_2872
.annotate 'line', 1077
    find_lex $P2874, "$?PACKAGE"
    get_who $P2875, $P2874
    set $P2876, $P2875["@BLOCK"]
    unless_null $P2876, vivify_1487
    $P2876 = root_new ['parrot';'ResizablePMCArray']
  vivify_1487:
    set $P2877, $P2876[0]
    unless_null $P2877, vivify_1488
    new $P2877, "Undef"
  vivify_1488:
    $P2878 = $P2877."handlers"()
    if $P2878, unless_2873_end
.annotate 'line', 1078
    find_lex $P2879, "$?PACKAGE"
    get_who $P2880, $P2879
    set $P2881, $P2880["@BLOCK"]
    unless_null $P2881, vivify_1489
    $P2881 = root_new ['parrot';'ResizablePMCArray']
  vivify_1489:
    set $P2882, $P2881[0]
    unless_null $P2882, vivify_1490
    new $P2882, "Undef"
  vivify_1490:
    new $P2883, "ResizablePMCArray"
    $P2882."handlers"($P2883)
  unless_2873_end:
.annotate 'line', 1080
    find_lex $P2885, "$block"
    unless_null $P2885, vivify_1491
    new $P2885, "Undef"
  vivify_1491:
    $P2886 = $P2885."arity"()
    if $P2886, unless_2884_end
.annotate 'line', 1081
    find_lex $P2887, "$block"
    unless_null $P2887, vivify_1492
    new $P2887, "Undef"
  vivify_1492:
.annotate 'line', 1082
    get_hll_global $P2888, "GLOBAL"
    nqp_get_package_through_who $P2889, $P2888, "PAST"
    get_who $P2890, $P2889
    set $P2891, $P2890["Op"]
.annotate 'line', 1083
    get_hll_global $P2892, "GLOBAL"
    nqp_get_package_through_who $P2893, $P2892, "PAST"
    get_who $P2894, $P2893
    set $P2895, $P2894["Var"]
    $P2896 = $P2895."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1084
    get_hll_global $P2897, "GLOBAL"
    nqp_get_package_through_who $P2898, $P2897, "PAST"
    get_who $P2899, $P2898
    set $P2900, $P2899["Var"]
    $P2901 = $P2900."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2902 = $P2891."new"($P2896, $P2901, "bind" :named("pasttype"))
.annotate 'line', 1082
    $P2887."unshift"($P2902)
.annotate 'line', 1087
    find_lex $P2903, "$block"
    unless_null $P2903, vivify_1493
    new $P2903, "Undef"
  vivify_1493:
    get_hll_global $P2904, "GLOBAL"
    nqp_get_package_through_who $P2905, $P2904, "PAST"
    get_who $P2906, $P2905
    set $P2907, $P2906["Var"]
    $P2908 = $P2907."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2903."unshift"($P2908)
.annotate 'line', 1088
    find_lex $P2909, "$block"
    unless_null $P2909, vivify_1494
    new $P2909, "Undef"
  vivify_1494:
    $P2909."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1089
    find_lex $P2910, "$block"
    unless_null $P2910, vivify_1495
    new $P2910, "Undef"
  vivify_1495:
    $P2910."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1090
    find_lex $P2911, "$block"
    unless_null $P2911, vivify_1496
    new $P2911, "Undef"
  vivify_1496:
    $P2911."arity"(1)
  unless_2884_end:
.annotate 'line', 1092
    find_lex $P2912, "$block"
    unless_null $P2912, vivify_1497
    new $P2912, "Undef"
  vivify_1497:
    $P2912."blocktype"("declaration")
.annotate 'line', 1093
    find_lex $P2913, "$?PACKAGE"
    get_who $P2914, $P2913
    set $P2915, $P2914["@BLOCK"]
    unless_null $P2915, vivify_1498
    $P2915 = root_new ['parrot';'ResizablePMCArray']
  vivify_1498:
    set $P2916, $P2915[0]
    unless_null $P2916, vivify_1499
    new $P2916, "Undef"
  vivify_1499:
    $P2917 = $P2916."handlers"()
.annotate 'line', 1094
    get_hll_global $P2918, "GLOBAL"
    nqp_get_package_through_who $P2919, $P2918, "PAST"
    get_who $P2920, $P2919
    set $P2921, $P2920["Control"]
    find_lex $P2922, "$/"
    unless_null $P2922, vivify_1500
    new $P2922, "Undef"
  vivify_1500:
.annotate 'line', 1096
    get_hll_global $P2923, "GLOBAL"
    nqp_get_package_through_who $P2924, $P2923, "PAST"
    get_who $P2925, $P2924
    set $P2926, $P2925["Stmts"]
.annotate 'line', 1097
    get_hll_global $P2927, "GLOBAL"
    nqp_get_package_through_who $P2928, $P2927, "PAST"
    get_who $P2929, $P2928
    set $P2930, $P2929["Op"]
    find_lex $P2931, "$block"
    unless_null $P2931, vivify_1501
    new $P2931, "Undef"
  vivify_1501:
.annotate 'line', 1099
    get_hll_global $P2932, "GLOBAL"
    nqp_get_package_through_who $P2933, $P2932, "PAST"
    get_who $P2934, $P2933
    set $P2935, $P2934["Var"]
    $P2936 = $P2935."new"("register" :named("scope"), "exception" :named("name"))
    $P2937 = $P2930."new"($P2931, $P2936, "call" :named("pasttype"))
.annotate 'line', 1101
    get_hll_global $P2938, "GLOBAL"
    nqp_get_package_through_who $P2939, $P2938, "PAST"
    get_who $P2940, $P2939
    set $P2941, $P2940["Op"]
.annotate 'line', 1102
    get_hll_global $P2942, "GLOBAL"
    nqp_get_package_through_who $P2943, $P2942, "PAST"
    get_who $P2944, $P2943
    set $P2945, $P2944["Var"]
.annotate 'line', 1103
    get_hll_global $P2946, "GLOBAL"
    nqp_get_package_through_who $P2947, $P2946, "PAST"
    get_who $P2948, $P2947
    set $P2949, $P2948["Var"]
    $P2950 = $P2949."new"("register" :named("scope"), "exception" :named("name"))
    $P2951 = $P2945."new"($P2950, "handled", "keyed" :named("scope"))
.annotate 'line', 1102
    $P2952 = $P2941."new"($P2951, 1, "bind" :named("pasttype"))
.annotate 'line', 1101
    $P2953 = $P2926."new"($P2937, $P2952)
.annotate 'line', 1096
    $P2954 = $P2921."new"($P2953, $P2922 :named("node"))
.annotate 'line', 1094
    $P2955 = $P2917."unshift"($P2954)
.annotate 'line', 1076
    .return ($P2955)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("417_1303923618.727") :outer("407_1303923618.727")
.annotate 'line', 1631
    new $P2958, "Undef"
    .lex "$past", $P2958
    find_lex $P2959, "$?PACKAGE"
    get_who $P2960, $P2959
    set $P2961, $P2960["@BLOCK"]
    unless_null $P2961, vivify_1502
    $P2961 = root_new ['parrot';'ResizablePMCArray']
  vivify_1502:
    $P2962 = $P2961."shift"()
    store_lex "$past", $P2962
.annotate 'line', 1632
    find_lex $P2963, "$past"
    unless_null $P2963, vivify_1503
    new $P2963, "Undef"
  vivify_1503:
    $P2963."closure"(1)
.annotate 'line', 1633
    find_lex $P2964, "$past"
    unless_null $P2964, vivify_1504
    new $P2964, "Undef"
  vivify_1504:
    get_hll_global $P2965, "GLOBAL"
    nqp_get_package_through_who $P2966, $P2965, "PAST"
    get_who $P2967, $P2966
    set $P2968, $P2967["Op"]
    $P2969 = $P2968."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2964."push"($P2969)
    find_lex $P2970, "$past"
    unless_null $P2970, vivify_1505
    new $P2970, "Undef"
  vivify_1505:
.annotate 'line', 1630
    .return ($P2970)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("418_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_2973
.annotate 'line', 1639
    .const 'Sub' $P2993 = "419_1303923618.727" 
    capture_lex $P2993
    .lex "$routine", param_2973
.annotate 'line', 1643
    new $P2974, "Undef"
    .lex "$types", $P2974
.annotate 'line', 1644
    new $P2975, "Undef"
    .lex "$definednesses", $P2975
.annotate 'line', 1643
    get_hll_global $P2976, "GLOBAL"
    nqp_get_package_through_who $P2977, $P2976, "PAST"
    get_who $P2978, $P2977
    set $P2979, $P2978["Op"]
    $P2980 = $P2979."new"("list" :named("pasttype"))
    store_lex "$types", $P2980
.annotate 'line', 1644
    get_hll_global $P2981, "GLOBAL"
    nqp_get_package_through_who $P2982, $P2981, "PAST"
    get_who $P2983, $P2982
    set $P2984, $P2983["Op"]
    $P2985 = $P2984."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2985
.annotate 'line', 1645
    find_lex $P2987, "$routine"
    unless_null $P2987, vivify_1506
    $P2987 = root_new ['parrot';'ResizablePMCArray']
  vivify_1506:
    set $P2988, $P2987[0]
    unless_null $P2988, vivify_1507
    new $P2988, "Undef"
  vivify_1507:
    $P2989 = $P2988."list"()
    defined $I2990, $P2989
    unless $I2990, for_undef_1508
    iter $P2986, $P2989
    new $P3037, 'ExceptionHandler'
    set_label $P3037, loop3036_handler
    $P3037."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3037
  loop3036_test:
    unless $P2986, loop3036_done
    shift $P2991, $P2986
  loop3036_redo:
    .const 'Sub' $P2993 = "419_1303923618.727" 
    capture_lex $P2993
    $P2993($P2991)
  loop3036_next:
    goto loop3036_test
  loop3036_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3038, exception, 'type'
    eq $P3038, .CONTROL_LOOP_NEXT, loop3036_next
    eq $P3038, .CONTROL_LOOP_REDO, loop3036_redo
  loop3036_done:
    pop_eh 
  for_undef_1508:
.annotate 'line', 1652
    find_lex $P3039, "$routine"
    unless_null $P3039, vivify_1518
    new $P3039, "Undef"
  vivify_1518:
    $P3040 = $P3039."loadinit"()
    get_hll_global $P3041, "GLOBAL"
    nqp_get_package_through_who $P3042, $P3041, "PAST"
    get_who $P3043, $P3042
    set $P3044, $P3043["Op"]
.annotate 'line', 1653
    get_hll_global $P3045, "GLOBAL"
    nqp_get_package_through_who $P3046, $P3045, "PAST"
    get_who $P3047, $P3046
    set $P3048, $P3047["Var"]
    $P3049 = $P3048."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P3050, "$types"
    unless_null $P3050, vivify_1519
    new $P3050, "Undef"
  vivify_1519:
    find_lex $P3051, "$definednesses"
    unless_null $P3051, vivify_1520
    new $P3051, "Undef"
  vivify_1520:
    $P3052 = $P3044."new"($P3049, $P3050, $P3051, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1652
    $P3053 = $P3040."push"($P3052)
.annotate 'line', 1639
    .return ($P3053)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2992"  :anon :subid("419_1303923618.727") :outer("418_1303923618.727")
    .param pmc param_2994
.annotate 'line', 1645
    .lex "$_", param_2994
.annotate 'line', 1646
    get_hll_global $P2999, "GLOBAL"
    nqp_get_package_through_who $P3000, $P2999, "PAST"
    get_who $P3001, $P3000
    set $P3002, $P3001["Var"]
    find_lex $P3003, "$_"
    unless_null $P3003, vivify_1509
    new $P3003, "Undef"
  vivify_1509:
    $P3004 = $P3002."ACCEPTS"($P3003)
    if $P3004, if_2998
    set $P2997, $P3004
    goto if_2998_end
  if_2998:
    find_lex $P3005, "$_"
    unless_null $P3005, vivify_1510
    new $P3005, "Undef"
  vivify_1510:
    $S3006 = $P3005."scope"()
    iseq $I3007, $S3006, "parameter"
    new $P2997, 'Integer'
    set $P2997, $I3007
  if_2998_end:
    if $P2997, if_2996
    set $P2995, $P2997
    goto if_2996_end
  if_2996:
.annotate 'line', 1647
    find_lex $P3008, "$types"
    unless_null $P3008, vivify_1511
    new $P3008, "Undef"
  vivify_1511:
    find_lex $P3010, "$_"
    unless_null $P3010, vivify_1512
    new $P3010, "Undef"
  vivify_1512:
    $P3011 = $P3010."multitype"()
    set $P3009, $P3011
    defined $I3013, $P3009
    if $I3013, default_3012
    get_hll_global $P3014, "GLOBAL"
    nqp_get_package_through_who $P3015, $P3014, "PAST"
    get_who $P3016, $P3015
    set $P3017, $P3016["Op"]
    $P3018 = $P3017."new"("null P" :named("pirop"))
    set $P3009, $P3018
  default_3012:
    $P3008."push"($P3009)
.annotate 'line', 1648
    find_lex $P3019, "$definednesses"
    unless_null $P3019, vivify_1513
    new $P3019, "Undef"
  vivify_1513:
    find_lex $P3022, "$_"
    unless_null $P3022, vivify_1514
    $P3022 = root_new ['parrot';'Hash']
  vivify_1514:
    set $P3023, $P3022["definedness"]
    unless_null $P3023, vivify_1515
    new $P3023, "Undef"
  vivify_1515:
    set $S3024, $P3023
    iseq $I3025, $S3024, "D"
    if $I3025, if_3021
.annotate 'line', 1649
    find_lex $P3029, "$_"
    unless_null $P3029, vivify_1516
    $P3029 = root_new ['parrot';'Hash']
  vivify_1516:
    set $P3030, $P3029["definedness"]
    unless_null $P3030, vivify_1517
    new $P3030, "Undef"
  vivify_1517:
    set $S3031, $P3030
    iseq $I3032, $S3031, "U"
    if $I3032, if_3028
    new $P3034, "Integer"
    assign $P3034, 0
    set $P3027, $P3034
    goto if_3028_end
  if_3028:
    new $P3033, "Integer"
    assign $P3033, 2
    set $P3027, $P3033
  if_3028_end:
    set $P3020, $P3027
.annotate 'line', 1648
    goto if_3021_end
  if_3021:
    new $P3026, "Integer"
    assign $P3026, 1
    set $P3020, $P3026
  if_3021_end:
    $P3035 = $P3019."push"($P3020)
.annotate 'line', 1646
    set $P2995, $P3035
  if_2996_end:
.annotate 'line', 1645
    .return ($P2995)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("420_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3056
    .param pmc param_3057
.annotate 'line', 2105
    .lex "$/", param_3056
    .lex "$type", param_3057
.annotate 'line', 2106
    find_lex $P3058, "$/"
    get_hll_global $P3059, "GLOBAL"
    nqp_get_package_through_who $P3060, $P3059, "PAST"
    get_who $P3061, $P3060
    set $P3062, $P3061["Op"]
    find_lex $P3063, "$/"
    unless_null $P3063, vivify_1521
    new $P3063, "Undef"
  vivify_1521:
.annotate 'line', 2110
    get_hll_global $P3064, "GLOBAL"
    nqp_get_package_through_who $P3065, $P3064, "PAST"
    get_who $P3066, $P3065
    set $P3067, $P3066["Val"]
    find_lex $P3068, "$type"
    unless_null $P3068, vivify_1522
    new $P3068, "Undef"
  vivify_1522:
    $P3069 = $P3067."new"($P3068 :named("value"), "!except_types" :named("returns"))
    $P3070 = $P3062."new"(0, $P3069, $P3063 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2106
    $P3071 = $P3058."!make"($P3070)
.annotate 'line', 2105
    .return ($P3071)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("421_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3076
    .param pmc param_3077
.annotate 'line', 2124
    .const 'Sub' $P3130 = "422_1303923618.727" 
    capture_lex $P3130
    new $P3075, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3075, control_3074
    push_eh $P3075
    .lex "@name", param_3076
    .lex "$/", param_3077
.annotate 'line', 2130
    new $P3078, "Undef"
    .lex "$final_name", $P3078
.annotate 'line', 2131
    new $P3079, "Undef"
    .lex "$lookup", $P3079
.annotate 'line', 2126
    find_lex $P3081, "@name"
    unless_null $P3081, vivify_1523
    $P3081 = root_new ['parrot';'ResizablePMCArray']
  vivify_1523:
    set $N3082, $P3081
    iseq $I3083, $N3082, 0.0
    unless $I3083, if_3080_end
    find_lex $P3084, "$/"
    unless_null $P3084, vivify_1524
    new $P3084, "Undef"
  vivify_1524:
    $P3085 = $P3084."CURSOR"()
    $P3085."panic"("Cannot compile empty name")
  if_3080_end:
.annotate 'line', 2130
    find_lex $P3086, "@name"
    unless_null $P3086, vivify_1525
    $P3086 = root_new ['parrot';'ResizablePMCArray']
  vivify_1525:
    $P3087 = $P3086."pop"()
    store_lex "$final_name", $P3087
.annotate 'line', 2131
    get_hll_global $P3088, "GLOBAL"
    nqp_get_package_through_who $P3089, $P3088, "PAST"
    get_who $P3090, $P3089
    set $P3091, $P3090["Var"]
    find_lex $P3092, "$final_name"
    unless_null $P3092, vivify_1526
    new $P3092, "Undef"
  vivify_1526:
    set $S3093, $P3092
    $P3094 = $P3091."new"($S3093, "keyed" :named("scope"))
    store_lex "$lookup", $P3094
.annotate 'line', 2135
    find_lex $P3096, "@name"
    unless_null $P3096, vivify_1527
    $P3096 = root_new ['parrot';'ResizablePMCArray']
  vivify_1527:
    set $N3097, $P3096
    iseq $I3098, $N3097, 0.0
    if $I3098, if_3095
.annotate 'line', 2153
    .const 'Sub' $P3130 = "422_1303923618.727" 
    capture_lex $P3130
    $P3130()
    goto if_3095_end
  if_3095:
.annotate 'line', 2136
    find_lex $P3099, "$lookup"
    unless_null $P3099, vivify_1540
    new $P3099, "Undef"
  vivify_1540:
    get_hll_global $P3100, "GLOBAL"
    nqp_get_package_through_who $P3101, $P3100, "PAST"
    get_who $P3102, $P3101
    set $P3103, $P3102["Op"]
.annotate 'line', 2138
    get_hll_global $P3104, "GLOBAL"
    nqp_get_package_through_who $P3105, $P3104, "PAST"
    get_who $P3106, $P3105
    set $P3107, $P3106["Var"]
    $P3108 = $P3107."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P3109 = $P3103."new"($P3108, "get_who PP" :named("pirop"))
.annotate 'line', 2136
    $P3099."unshift"($P3109)
.annotate 'line', 2140
    find_lex $P3110, "$lookup"
    unless_null $P3110, vivify_1541
    new $P3110, "Undef"
  vivify_1541:
    get_hll_global $P3111, "GLOBAL"
    nqp_get_package_through_who $P3112, $P3111, "PAST"
    get_who $P3113, $P3112
    set $P3114, $P3113["Var"]
.annotate 'line', 2142
    get_hll_global $P3115, "GLOBAL"
    nqp_get_package_through_who $P3116, $P3115, "PAST"
    get_who $P3117, $P3116
    set $P3118, $P3117["Op"]
.annotate 'line', 2144
    get_hll_global $P3119, "GLOBAL"
    nqp_get_package_through_who $P3120, $P3119, "PAST"
    get_who $P3121, $P3120
    set $P3122, $P3121["Var"]
    new $P3123, "ResizablePMCArray"
    $P3124 = $P3122."new"("GLOBAL" :named("name"), $P3123 :named("namespace"), "package" :named("scope"))
    $P3125 = $P3118."new"($P3124, "get_who PP" :named("pirop"))
.annotate 'line', 2146
    find_lex $P3126, "$final_name"
    unless_null $P3126, vivify_1542
    new $P3126, "Undef"
  vivify_1542:
    set $S3127, $P3126
    $P3128 = $P3114."new"($P3125, $S3127, "keyed" :named("scope"))
.annotate 'line', 2140
    $P3110."viviself"($P3128)
  if_3095_end:
.annotate 'line', 2168
    new $P3182, "Exception"
    set $P3182['type'], .CONTROL_RETURN
    find_lex $P3183, "$lookup"
    unless_null $P3183, vivify_1543
    new $P3183, "Undef"
  vivify_1543:
    setattribute $P3182, 'payload', $P3183
    throw $P3182
.annotate 'line', 2124
    .return ()
  control_3074:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3184, exception, "payload"
    .return ($P3184)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3129"  :anon :subid("422_1303923618.727") :outer("421_1303923618.727")
.annotate 'line', 2153
    .const 'Sub' $P3161 = "423_1303923618.727" 
    capture_lex $P3161
.annotate 'line', 2154
    new $P3131, "Undef"
    .lex "$path", $P3131
    find_lex $P3134, "@name"
    unless_null $P3134, vivify_1528
    $P3134 = root_new ['parrot';'ResizablePMCArray']
  vivify_1528:
    set $P3135, $P3134[0]
    unless_null $P3135, vivify_1529
    new $P3135, "Undef"
  vivify_1529:
    $P3136 = "is_lexical"($P3135)
    if $P3136, if_3133
.annotate 'line', 2156
    get_hll_global $P3144, "GLOBAL"
    nqp_get_package_through_who $P3145, $P3144, "PAST"
    get_who $P3146, $P3145
    set $P3147, $P3146["Var"]
    new $P3148, "ResizablePMCArray"
    $P3149 = $P3147."new"("GLOBAL" :named("name"), $P3148 :named("namespace"), "package" :named("scope"))
    set $P3132, $P3149
.annotate 'line', 2154
    goto if_3133_end
  if_3133:
.annotate 'line', 2155
    get_hll_global $P3137, "GLOBAL"
    nqp_get_package_through_who $P3138, $P3137, "PAST"
    get_who $P3139, $P3138
    set $P3140, $P3139["Var"]
    find_lex $P3141, "@name"
    unless_null $P3141, vivify_1530
    $P3141 = root_new ['parrot';'ResizablePMCArray']
  vivify_1530:
    $P3142 = $P3141."shift"()
    $P3143 = $P3140."new"($P3142 :named("name"), "lexical" :named("scope"))
    set $P3132, $P3143
  if_3133_end:
.annotate 'line', 2154
    store_lex "$path", $P3132
.annotate 'line', 2157
    find_lex $P3151, "@name"
    unless_null $P3151, vivify_1531
    $P3151 = root_new ['parrot';'ResizablePMCArray']
  vivify_1531:
    set $P3152, $P3151[0]
    unless_null $P3152, vivify_1532
    new $P3152, "Undef"
  vivify_1532:
    set $S3153, $P3152
    iseq $I3154, $S3153, "GLOBAL"
    unless $I3154, if_3150_end
.annotate 'line', 2158
    find_lex $P3155, "@name"
    unless_null $P3155, vivify_1533
    $P3155 = root_new ['parrot';'ResizablePMCArray']
  vivify_1533:
    $P3155."shift"()
  if_3150_end:
.annotate 'line', 2160
    find_lex $P3157, "@name"
    unless_null $P3157, vivify_1534
    $P3157 = root_new ['parrot';'ResizablePMCArray']
  vivify_1534:
    defined $I3158, $P3157
    unless $I3158, for_undef_1535
    iter $P3156, $P3157
    new $P3172, 'ExceptionHandler'
    set_label $P3172, loop3171_handler
    $P3172."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3172
  loop3171_test:
    unless $P3156, loop3171_done
    shift $P3159, $P3156
  loop3171_redo:
    .const 'Sub' $P3161 = "423_1303923618.727" 
    capture_lex $P3161
    $P3161($P3159)
  loop3171_next:
    goto loop3171_test
  loop3171_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3173, exception, 'type'
    eq $P3173, .CONTROL_LOOP_NEXT, loop3171_next
    eq $P3173, .CONTROL_LOOP_REDO, loop3171_redo
  loop3171_done:
    pop_eh 
  for_undef_1535:
.annotate 'line', 2165
    find_lex $P3174, "$lookup"
    unless_null $P3174, vivify_1538
    new $P3174, "Undef"
  vivify_1538:
    get_hll_global $P3175, "GLOBAL"
    nqp_get_package_through_who $P3176, $P3175, "PAST"
    get_who $P3177, $P3176
    set $P3178, $P3177["Op"]
    find_lex $P3179, "$path"
    unless_null $P3179, vivify_1539
    new $P3179, "Undef"
  vivify_1539:
    $P3180 = $P3178."new"($P3179, "get_who PP" :named("pirop"))
    $P3181 = $P3174."unshift"($P3180)
.annotate 'line', 2153
    .return ($P3181)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3160"  :anon :subid("423_1303923618.727") :outer("422_1303923618.727")
    .param pmc param_3162
.annotate 'line', 2160
    .lex "$_", param_3162
.annotate 'line', 2161
    get_hll_global $P3163, "GLOBAL"
    nqp_get_package_through_who $P3164, $P3163, "PAST"
    get_who $P3165, $P3164
    set $P3166, $P3165["Op"]
    find_lex $P3167, "$path"
    unless_null $P3167, vivify_1536
    new $P3167, "Undef"
  vivify_1536:
.annotate 'line', 2163
    find_lex $P3168, "$_"
    unless_null $P3168, vivify_1537
    new $P3168, "Undef"
  vivify_1537:
    set $S3169, $P3168
    $P3170 = $P3166."new"($P3167, $S3169, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2161
    store_lex "$path", $P3170
.annotate 'line', 2160
    .return ($P3170)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("424_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3187
.annotate 'line', 2173
    .lex "$name", param_3187
.annotate 'line', 2174
    find_lex $P3188, "$name"
    unless_null $P3188, vivify_1544
    new $P3188, "Undef"
  vivify_1544:
    $P3189 = "is_scope"($P3188, "lexical")
.annotate 'line', 2173
    .return ($P3189)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("425_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3192
.annotate 'line', 2179
    .lex "$name", param_3192
.annotate 'line', 2180
    find_lex $P3193, "$name"
    unless_null $P3193, vivify_1545
    new $P3193, "Undef"
  vivify_1545:
    $P3194 = "is_scope"($P3193, "package")
.annotate 'line', 2179
    .return ($P3194)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("426_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3199
    .param pmc param_3200
.annotate 'line', 2185
    .const 'Sub' $P3208 = "427_1303923618.727" 
    capture_lex $P3208
    new $P3198, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3198, control_3197
    push_eh $P3198
    .lex "$name", param_3199
    .lex "$wanted_scope", param_3200
.annotate 'line', 2186
    find_lex $P3202, "$?PACKAGE"
    get_who $P3203, $P3202
    set $P3204, $P3203["@BLOCK"]
    unless_null $P3204, vivify_1546
    $P3204 = root_new ['parrot';'ResizablePMCArray']
  vivify_1546:
    defined $I3205, $P3204
    unless $I3205, for_undef_1547
    iter $P3201, $P3204
    new $P3227, 'ExceptionHandler'
    set_label $P3227, loop3226_handler
    $P3227."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3227
  loop3226_test:
    unless $P3201, loop3226_done
    shift $P3206, $P3201
  loop3226_redo:
    .const 'Sub' $P3208 = "427_1303923618.727" 
    capture_lex $P3208
    $P3208($P3206)
  loop3226_next:
    goto loop3226_test
  loop3226_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3228, exception, 'type'
    eq $P3228, .CONTROL_LOOP_NEXT, loop3226_next
    eq $P3228, .CONTROL_LOOP_REDO, loop3226_redo
  loop3226_done:
    pop_eh 
  for_undef_1547:
.annotate 'line', 2185
    .return (0)
  control_3197:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3229, exception, "payload"
    .return ($P3229)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3207"  :anon :subid("427_1303923618.727") :outer("426_1303923618.727")
    .param pmc param_3210
.annotate 'line', 2187
    $P3209 = root_new ['parrot';'Hash']
    .lex "%sym", $P3209
    .lex "$_", param_3210
    find_lex $P3211, "$_"
    unless_null $P3211, vivify_1548
    new $P3211, "Undef"
  vivify_1548:
    find_lex $P3212, "$name"
    unless_null $P3212, vivify_1549
    new $P3212, "Undef"
  vivify_1549:
    $P3213 = $P3211."symbol"($P3212)
    store_lex "%sym", $P3213
.annotate 'line', 2188
    find_lex $P3216, "%sym"
    unless_null $P3216, vivify_1550
    $P3216 = root_new ['parrot';'Hash']
  vivify_1550:
    set $N3217, $P3216
    if $N3217, if_3215
    new $P3214, 'Float'
    set $P3214, $N3217
    goto if_3215_end
  if_3215:
.annotate 'line', 2189
    new $P3218, "Exception"
    set $P3218['type'], .CONTROL_RETURN
    find_lex $P3219, "%sym"
    unless_null $P3219, vivify_1551
    $P3219 = root_new ['parrot';'Hash']
  vivify_1551:
    set $P3220, $P3219["scope"]
    unless_null $P3220, vivify_1552
    new $P3220, "Undef"
  vivify_1552:
    set $S3221, $P3220
    find_lex $P3222, "$wanted_scope"
    unless_null $P3222, vivify_1553
    new $P3222, "Undef"
  vivify_1553:
    set $S3223, $P3222
    iseq $I3224, $S3221, $S3223
    new $P3225, 'Integer'
    set $P3225, $I3224
    setattribute $P3218, 'payload', $P3225
    throw $P3218
  if_3215_end:
.annotate 'line', 2186
    .return ($P3214)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("428_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3234
    .param pmc param_3235
.annotate 'line', 2198
    .const 'Sub' $P3329 = "433_1303923618.727" 
    capture_lex $P3329
    .const 'Sub' $P3289 = "431_1303923618.727" 
    capture_lex $P3289
    .const 'Sub' $P3247 = "429_1303923618.727" 
    capture_lex $P3247
    new $P3233, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P3233, control_3232
    push_eh $P3233
    .lex "@name", param_3234
    .lex "$/", param_3235
.annotate 'line', 2222
    new $P3236, "Undef"
    .lex "$result", $P3236
.annotate 'line', 2200
    find_lex $P3238, "@name"
    unless_null $P3238, vivify_1554
    $P3238 = root_new ['parrot';'ResizablePMCArray']
  vivify_1554:
    set $N3239, $P3238
    if $N3239, unless_3237_end
    find_lex $P3240, "$/"
    unless_null $P3240, vivify_1555
    new $P3240, "Undef"
  vivify_1555:
    $P3241 = $P3240."CURSOR"()
    $P3241."panic"("Cannot look up empty name")
  unless_3237_end:
.annotate 'line', 2204
    find_lex $P3243, "@name"
    unless_null $P3243, vivify_1556
    $P3243 = root_new ['parrot';'ResizablePMCArray']
  vivify_1556:
    set $N3244, $P3243
    iseq $I3245, $N3244, 1.0
    unless $I3245, if_3242_end
    .const 'Sub' $P3247 = "429_1303923618.727" 
    capture_lex $P3247
    $P3247()
  if_3242_end:
.annotate 'line', 2222
    find_dynamic_lex $P3283, "$*GLOBALish"
    unless_null $P3283, vivify_1568
    get_hll_global $P3281, "GLOBAL"
    get_who $P3282, $P3281
    set $P3283, $P3282["$GLOBALish"]
    unless_null $P3283, vivify_1569
    die "Contextual $*GLOBALish not found"
  vivify_1569:
  vivify_1568:
    store_lex "$result", $P3283
.annotate 'line', 2223
    find_lex $P3285, "@name"
    unless_null $P3285, vivify_1570
    $P3285 = root_new ['parrot';'ResizablePMCArray']
  vivify_1570:
    set $N3286, $P3285
    isge $I3287, $N3286, 2.0
    unless $I3287, if_3284_end
    .const 'Sub' $P3289 = "431_1303923618.727" 
    capture_lex $P3289
    $P3289()
  if_3284_end:
.annotate 'line', 2241
    find_lex $P3325, "@name"
    unless_null $P3325, vivify_1583
    $P3325 = root_new ['parrot';'ResizablePMCArray']
  vivify_1583:
    defined $I3326, $P3325
    unless $I3326, for_undef_1584
    iter $P3324, $P3325
    new $P3347, 'ExceptionHandler'
    set_label $P3347, loop3346_handler
    $P3347."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3347
  loop3346_test:
    unless $P3324, loop3346_done
    shift $P3327, $P3324
  loop3346_redo:
    .const 'Sub' $P3329 = "433_1303923618.727" 
    capture_lex $P3329
    $P3329($P3327)
  loop3346_next:
    goto loop3346_test
  loop3346_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3348, exception, 'type'
    eq $P3348, .CONTROL_LOOP_NEXT, loop3346_next
    eq $P3348, .CONTROL_LOOP_REDO, loop3346_redo
  loop3346_done:
    pop_eh 
  for_undef_1584:
    find_lex $P3349, "$result"
    unless_null $P3349, vivify_1591
    new $P3349, "Undef"
  vivify_1591:
.annotate 'line', 2198
    .return ($P3349)
  control_3232:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3350, exception, "payload"
    .return ($P3350)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3246"  :anon :subid("429_1303923618.727") :outer("428_1303923618.727")
.annotate 'line', 2204
    .const 'Sub' $P3258 = "430_1303923618.727" 
    capture_lex $P3258
.annotate 'line', 2205
    new $P3248, "Undef"
    .lex "$final_name", $P3248
    find_lex $P3249, "@name"
    unless_null $P3249, vivify_1557
    $P3249 = root_new ['parrot';'ResizablePMCArray']
  vivify_1557:
    set $P3250, $P3249[0]
    unless_null $P3250, vivify_1558
    new $P3250, "Undef"
  vivify_1558:
    store_lex "$final_name", $P3250
.annotate 'line', 2206
    find_lex $P3252, "$?PACKAGE"
    get_who $P3253, $P3252
    set $P3254, $P3253["@BLOCK"]
    unless_null $P3254, vivify_1559
    $P3254 = root_new ['parrot';'ResizablePMCArray']
  vivify_1559:
    defined $I3255, $P3254
    unless $I3255, for_undef_1560
    iter $P3251, $P3254
    new $P3279, 'ExceptionHandler'
    set_label $P3279, loop3278_handler
    $P3279."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3279
  loop3278_test:
    unless $P3251, loop3278_done
    shift $P3256, $P3251
  loop3278_redo:
    .const 'Sub' $P3258 = "430_1303923618.727" 
    capture_lex $P3258
    $P3258($P3256)
  loop3278_next:
    goto loop3278_test
  loop3278_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3280, exception, 'type'
    eq $P3280, .CONTROL_LOOP_NEXT, loop3278_next
    eq $P3280, .CONTROL_LOOP_REDO, loop3278_redo
  loop3278_done:
    pop_eh 
  for_undef_1560:
.annotate 'line', 2204
    .return ($P3251)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3257"  :anon :subid("430_1303923618.727") :outer("429_1303923618.727")
    .param pmc param_3260
.annotate 'line', 2207
    $P3259 = root_new ['parrot';'Hash']
    .lex "%sym", $P3259
    .lex "$_", param_3260
    find_lex $P3261, "$_"
    unless_null $P3261, vivify_1561
    new $P3261, "Undef"
  vivify_1561:
    find_lex $P3262, "$final_name"
    unless_null $P3262, vivify_1562
    new $P3262, "Undef"
  vivify_1562:
    $P3263 = $P3261."symbol"($P3262)
    store_lex "%sym", $P3263
.annotate 'line', 2208
    find_lex $P3266, "%sym"
    unless_null $P3266, vivify_1563
    $P3266 = root_new ['parrot';'Hash']
  vivify_1563:
    set $N3267, $P3266
    if $N3267, if_3265
    new $P3264, 'Float'
    set $P3264, $N3267
    goto if_3265_end
  if_3265:
.annotate 'line', 2209
    find_lex $P3270, "%sym"
    unless_null $P3270, vivify_1564
    $P3270 = root_new ['parrot';'Hash']
  vivify_1564:
    exists $I3271, $P3270["value"]
    if $I3271, if_3269
.annotate 'line', 2213
    new $P3275, 'String'
    set $P3275, "No compile-time value for "
    find_lex $P3276, "$final_name"
    unless_null $P3276, vivify_1565
    new $P3276, "Undef"
  vivify_1565:
    concat $P3277, $P3275, $P3276
    die $P3277
.annotate 'line', 2212
    goto if_3269_end
  if_3269:
.annotate 'line', 2210
    new $P3272, "Exception"
    set $P3272['type'], .CONTROL_RETURN
    find_lex $P3273, "%sym"
    unless_null $P3273, vivify_1566
    $P3273 = root_new ['parrot';'Hash']
  vivify_1566:
    set $P3274, $P3273["value"]
    unless_null $P3274, vivify_1567
    new $P3274, "Undef"
  vivify_1567:
    setattribute $P3272, 'payload', $P3274
    throw $P3272
  if_3269_end:
.annotate 'line', 2208
    set $P3264, $P3268
  if_3265_end:
.annotate 'line', 2206
    .return ($P3264)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3288"  :anon :subid("431_1303923618.727") :outer("428_1303923618.727")
.annotate 'line', 2223
    .const 'Sub' $P3300 = "432_1303923618.727" 
    capture_lex $P3300
.annotate 'line', 2224
    new $P3290, "Undef"
    .lex "$first", $P3290
    find_lex $P3291, "@name"
    unless_null $P3291, vivify_1571
    $P3291 = root_new ['parrot';'ResizablePMCArray']
  vivify_1571:
    set $P3292, $P3291[0]
    unless_null $P3292, vivify_1572
    new $P3292, "Undef"
  vivify_1572:
    store_lex "$first", $P3292
.annotate 'line', 2225
    find_lex $P3294, "$?PACKAGE"
    get_who $P3295, $P3294
    set $P3296, $P3295["@BLOCK"]
    unless_null $P3296, vivify_1573
    $P3296 = root_new ['parrot';'ResizablePMCArray']
  vivify_1573:
    defined $I3297, $P3296
    unless $I3297, for_undef_1574
    iter $P3293, $P3296
    new $P3322, 'ExceptionHandler'
    set_label $P3322, loop3321_handler
    $P3322."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3322
  loop3321_test:
    unless $P3293, loop3321_done
    shift $P3298, $P3293
  loop3321_redo:
    .const 'Sub' $P3300 = "432_1303923618.727" 
    capture_lex $P3300
    $P3300($P3298)
  loop3321_next:
    goto loop3321_test
  loop3321_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3323, exception, 'type'
    eq $P3323, .CONTROL_LOOP_NEXT, loop3321_next
    eq $P3323, .CONTROL_LOOP_REDO, loop3321_redo
  loop3321_done:
    pop_eh 
  for_undef_1574:
.annotate 'line', 2223
    .return ($P3293)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3299"  :anon :subid("432_1303923618.727") :outer("431_1303923618.727")
    .param pmc param_3302
.annotate 'line', 2226
    $P3301 = root_new ['parrot';'Hash']
    .lex "%sym", $P3301
    .lex "$_", param_3302
    find_lex $P3303, "$_"
    unless_null $P3303, vivify_1575
    new $P3303, "Undef"
  vivify_1575:
    find_lex $P3304, "$first"
    unless_null $P3304, vivify_1576
    new $P3304, "Undef"
  vivify_1576:
    $P3305 = $P3303."symbol"($P3304)
    store_lex "%sym", $P3305
.annotate 'line', 2227
    find_lex $P3308, "%sym"
    unless_null $P3308, vivify_1577
    $P3308 = root_new ['parrot';'Hash']
  vivify_1577:
    set $N3309, $P3308
    if $N3309, if_3307
    new $P3306, 'Float'
    set $P3306, $N3309
    goto if_3307_end
  if_3307:
.annotate 'line', 2228
    find_lex $P3312, "%sym"
    unless_null $P3312, vivify_1578
    $P3312 = root_new ['parrot';'Hash']
  vivify_1578:
    exists $I3313, $P3312["value"]
    if $I3313, if_3311
.annotate 'line', 2234
    new $P3318, 'String'
    set $P3318, "No compile-time value for "
    find_lex $P3319, "$first"
    unless_null $P3319, vivify_1579
    new $P3319, "Undef"
  vivify_1579:
    concat $P3320, $P3318, $P3319
    die $P3320
.annotate 'line', 2233
    goto if_3311_end
  if_3311:
.annotate 'line', 2229
    find_lex $P3314, "%sym"
    unless_null $P3314, vivify_1580
    $P3314 = root_new ['parrot';'Hash']
  vivify_1580:
    set $P3315, $P3314["value"]
    unless_null $P3315, vivify_1581
    new $P3315, "Undef"
  vivify_1581:
    store_lex "$result", $P3315
.annotate 'line', 2230
    find_lex $P3316, "@name"
    unless_null $P3316, vivify_1582
    $P3316 = root_new ['parrot';'ResizablePMCArray']
  vivify_1582:
    $P3316."shift"()
.annotate 'line', 2231
    set $I3317, .CONTROL_LOOP_LAST
    die 0, $I3317
  if_3311_end:
.annotate 'line', 2227
    set $P3306, $P3310
  if_3307_end:
.annotate 'line', 2225
    .return ($P3306)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3328"  :anon :subid("433_1303923618.727") :outer("428_1303923618.727")
    .param pmc param_3330
.annotate 'line', 2241
    .lex "$_", param_3330
.annotate 'line', 2242
    find_lex $P3335, "$_"
    unless_null $P3335, vivify_1585
    new $P3335, "Undef"
  vivify_1585:
    set $S3336, $P3335
    find_lex $P3333, "$result"
    unless_null $P3333, vivify_1586
    new $P3333, "Undef"
  vivify_1586:
    get_who $P3334, $P3333
    exists $I3337, $P3334[$S3336]
    if $I3337, if_3332
.annotate 'line', 2246
    new $P3342, "String"
    assign $P3342, "Could not locate compile-time value for symbol "
.annotate 'line', 2247
    find_lex $P3343, "@name"
    unless_null $P3343, vivify_1587
    $P3343 = root_new ['parrot';'ResizablePMCArray']
  vivify_1587:
    join $S3344, "::", $P3343
    concat $P3345, $P3342, $S3344
.annotate 'line', 2246
    die $P3345
.annotate 'line', 2245
    goto if_3332_end
  if_3332:
.annotate 'line', 2243
    find_lex $P3338, "$_"
    unless_null $P3338, vivify_1588
    new $P3338, "Undef"
  vivify_1588:
    find_lex $P3339, "$result"
    unless_null $P3339, vivify_1589
    new $P3339, "Undef"
  vivify_1589:
    get_who $P3340, $P3339
    set $P3341, $P3340[$P3338]
    unless_null $P3341, vivify_1590
    new $P3341, "Undef"
  vivify_1590:
    store_lex "$result", $P3341
.annotate 'line', 2242
    set $P3331, $P3341
  if_3332_end:
.annotate 'line', 2241
    .return ($P3331)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("434_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3361
    .param pmc param_3362
.annotate 'line', 799
    .lex "self", param_3361
    .lex "$/", param_3362
    find_lex $P3363, "$/"
    find_lex $P3364, "$/"
    unless_null $P3364, vivify_1592
    $P3364 = root_new ['parrot';'Hash']
  vivify_1592:
    set $P3365, $P3364["comp_unit"]
    unless_null $P3365, vivify_1593
    new $P3365, "Undef"
  vivify_1593:
    $P3366 = $P3365."ast"()
    $P3367 = $P3363."!make"($P3366)
    .return ($P3367)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("435_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3369
    .param pmc param_3370
.annotate 'line', 801
    .lex "self", param_3369
    .lex "$/", param_3370
.annotate 'line', 802
    find_lex $P3371, "$/"
.annotate 'line', 803
    find_lex $P3374, "$/"
    unless_null $P3374, vivify_1594
    $P3374 = root_new ['parrot';'Hash']
  vivify_1594:
    set $P3375, $P3374["colonpair"]
    unless_null $P3375, vivify_1595
    new $P3375, "Undef"
  vivify_1595:
    if $P3375, if_3373
.annotate 'line', 805
    find_lex $P3395, "$/"
    unless_null $P3395, vivify_1596
    new $P3395, "Undef"
  vivify_1596:
    set $S3396, $P3395
    new $P3372, 'String'
    set $P3372, $S3396
.annotate 'line', 803
    goto if_3373_end
  if_3373:
    find_lex $P3376, "$/"
    unless_null $P3376, vivify_1597
    $P3376 = root_new ['parrot';'Hash']
  vivify_1597:
    set $P3377, $P3376["identifier"]
    unless_null $P3377, vivify_1598
    new $P3377, "Undef"
  vivify_1598:
    set $S3378, $P3377
    new $P3379, 'String'
    set $P3379, $S3378
    concat $P3380, $P3379, ":"
    find_lex $P3381, "$/"
    unless_null $P3381, vivify_1599
    $P3381 = root_new ['parrot';'Hash']
  vivify_1599:
    set $P3382, $P3381["colonpair"]
    unless_null $P3382, vivify_1600
    $P3382 = root_new ['parrot';'ResizablePMCArray']
  vivify_1600:
    set $P3383, $P3382[0]
    unless_null $P3383, vivify_1601
    new $P3383, "Undef"
  vivify_1601:
    $P3384 = $P3383."ast"()
    $S3385 = $P3384."named"()
    concat $P3386, $P3380, $S3385
    concat $P3387, $P3386, "<"
.annotate 'line', 804
    find_lex $P3388, "$/"
    unless_null $P3388, vivify_1602
    $P3388 = root_new ['parrot';'Hash']
  vivify_1602:
    set $P3389, $P3388["colonpair"]
    unless_null $P3389, vivify_1603
    $P3389 = root_new ['parrot';'ResizablePMCArray']
  vivify_1603:
    set $P3390, $P3389[0]
    unless_null $P3390, vivify_1604
    new $P3390, "Undef"
  vivify_1604:
    $P3391 = $P3390."ast"()
    $S3392 = "colonpair_str"($P3391)
    concat $P3393, $P3387, $S3392
    concat $P3394, $P3393, ">"
    set $P3372, $P3394
  if_3373_end:
.annotate 'line', 803
    $P3397 = $P3371."!make"($P3372)
.annotate 'line', 801
    .return ($P3397)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("436_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3400
    .param pmc param_3401
.annotate 'line', 815
    .lex "self", param_3400
    .lex "$/", param_3401
.annotate 'line', 816
    new $P3402, "Undef"
    .lex "$mainline", $P3402
.annotate 'line', 817
    new $P3403, "Undef"
    .lex "$unit", $P3403
.annotate 'line', 816
    find_lex $P3404, "$/"
    unless_null $P3404, vivify_1605
    $P3404 = root_new ['parrot';'Hash']
  vivify_1605:
    set $P3405, $P3404["statementlist"]
    unless_null $P3405, vivify_1606
    new $P3405, "Undef"
  vivify_1606:
    $P3406 = $P3405."ast"()
    store_lex "$mainline", $P3406
.annotate 'line', 817
    find_lex $P3407, "$?PACKAGE"
    get_who $P3408, $P3407
    set $P3409, $P3408["@BLOCK"]
    unless_null $P3409, vivify_1607
    $P3409 = root_new ['parrot';'ResizablePMCArray']
  vivify_1607:
    $P3410 = $P3409."shift"()
    store_lex "$unit", $P3410
.annotate 'line', 821
    find_lex $P3411, "$unit"
    unless_null $P3411, vivify_1608
    new $P3411, "Undef"
  vivify_1608:
    $P3412 = $P3411."loadinit"()
    find_dynamic_lex $P3415, "$*SC"
    unless_null $P3415, vivify_1609
    get_hll_global $P3413, "GLOBAL"
    get_who $P3414, $P3413
    set $P3415, $P3414["$SC"]
    unless_null $P3415, vivify_1610
    die "Contextual $*SC not found"
  vivify_1610:
  vivify_1609:
    $P3416 = $P3415."to_past"()
    $P3412."push"($P3416)
.annotate 'line', 826
    find_lex $P3417, "$unit"
    unless_null $P3417, vivify_1611
    new $P3417, "Undef"
  vivify_1611:
    $P3418 = $P3417."loadinit"()
    get_hll_global $P3419, "GLOBAL"
    nqp_get_package_through_who $P3420, $P3419, "PAST"
    get_who $P3421, $P3420
    set $P3422, $P3421["Op"]
.annotate 'line', 828
    get_hll_global $P3423, "GLOBAL"
    nqp_get_package_through_who $P3424, $P3423, "PAST"
    get_who $P3425, $P3424
    set $P3426, $P3425["Var"]
    new $P3427, "ResizablePMCArray"
    $P3428 = $P3426."new"("GLOBAL" :named("name"), $P3427 :named("namespace"), "package" :named("scope"))
.annotate 'line', 829
    find_dynamic_lex $P3431, "$*SC"
    unless_null $P3431, vivify_1612
    get_hll_global $P3429, "GLOBAL"
    get_who $P3430, $P3429
    set $P3431, $P3430["$SC"]
    unless_null $P3431, vivify_1613
    die "Contextual $*SC not found"
  vivify_1613:
  vivify_1612:
    find_dynamic_lex $P3434, "$*PACKAGE"
    unless_null $P3434, vivify_1614
    get_hll_global $P3432, "GLOBAL"
    get_who $P3433, $P3432
    set $P3434, $P3433["$PACKAGE"]
    unless_null $P3434, vivify_1615
    die "Contextual $*PACKAGE not found"
  vivify_1615:
  vivify_1614:
    $P3435 = $P3431."get_slot_past_for_object"($P3434)
    $P3436 = $P3422."new"($P3428, $P3435, "bind" :named("pasttype"))
.annotate 'line', 826
    $P3418."push"($P3436)
.annotate 'line', 835
    find_dynamic_lex $P3440, "$*HAS_YOU_ARE_HERE"
    unless_null $P3440, vivify_1616
    get_hll_global $P3438, "GLOBAL"
    get_who $P3439, $P3438
    set $P3440, $P3439["$HAS_YOU_ARE_HERE"]
    unless_null $P3440, vivify_1617
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1617:
  vivify_1616:
    if $P3440, unless_3437_end
.annotate 'line', 836
    find_lex $P3441, "$unit"
    unless_null $P3441, vivify_1618
    new $P3441, "Undef"
  vivify_1618:
    find_lex $P3442, "self"
    $P3443 = $P3442."CTXSAVE"()
    $P3441."push"($P3443)
  unless_3437_end:
.annotate 'line', 840
    find_lex $P3444, "$unit"
    unless_null $P3444, vivify_1619
    new $P3444, "Undef"
  vivify_1619:
    $P3444."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 844
    find_dynamic_lex $P3448, "$*MAIN_SUB"
    unless_null $P3448, vivify_1620
    get_hll_global $P3446, "GLOBAL"
    get_who $P3447, $P3446
    set $P3448, $P3447["$MAIN_SUB"]
    unless_null $P3448, vivify_1621
    die "Contextual $*MAIN_SUB not found"
  vivify_1621:
  vivify_1620:
    unless $P3448, if_3445_end
.annotate 'line', 845
    find_lex $P3449, "$unit"
    unless_null $P3449, vivify_1622
    new $P3449, "Undef"
  vivify_1622:
    get_hll_global $P3450, "GLOBAL"
    nqp_get_package_through_who $P3451, $P3450, "PAST"
    get_who $P3452, $P3451
    set $P3453, $P3452["Var"]
    $P3454 = $P3453."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P3449."unshift"($P3454)
.annotate 'line', 846
    find_lex $P3455, "$mainline"
    unless_null $P3455, vivify_1623
    new $P3455, "Undef"
  vivify_1623:
    get_hll_global $P3456, "GLOBAL"
    nqp_get_package_through_who $P3457, $P3456, "PAST"
    get_who $P3458, $P3457
    set $P3459, $P3458["Op"]
.annotate 'line', 848
    get_hll_global $P3460, "GLOBAL"
    nqp_get_package_through_who $P3461, $P3460, "PAST"
    get_who $P3462, $P3461
    set $P3463, $P3462["Var"]
    $P3464 = $P3463."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 849
    get_hll_global $P3465, "GLOBAL"
    nqp_get_package_through_who $P3466, $P3465, "PAST"
    get_who $P3467, $P3466
    set $P3468, $P3467["Op"]
.annotate 'line', 850
    get_hll_global $P3469, "GLOBAL"
    nqp_get_package_through_who $P3470, $P3469, "PAST"
    get_who $P3471, $P3470
    set $P3472, $P3471["Val"]
    find_dynamic_lex $P3475, "$*MAIN_SUB"
    unless_null $P3475, vivify_1624
    get_hll_global $P3473, "GLOBAL"
    get_who $P3474, $P3473
    set $P3475, $P3474["$MAIN_SUB"]
    unless_null $P3475, vivify_1625
    die "Contextual $*MAIN_SUB not found"
  vivify_1625:
  vivify_1624:
    $P3476 = $P3472."new"($P3475 :named("value"))
.annotate 'line', 851
    get_hll_global $P3477, "GLOBAL"
    nqp_get_package_through_who $P3478, $P3477, "PAST"
    get_who $P3479, $P3478
    set $P3480, $P3479["Var"]
    $P3481 = $P3480."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P3482 = $P3468."new"($P3476, $P3481, "call" :named("pasttype"))
.annotate 'line', 849
    $P3483 = $P3459."new"($P3464, $P3482, "if" :named("pasttype"))
.annotate 'line', 846
    $P3455."push"($P3483)
  if_3445_end:
.annotate 'line', 859
    find_lex $P3484, "$unit"
    unless_null $P3484, vivify_1626
    new $P3484, "Undef"
  vivify_1626:
.annotate 'line', 860
    get_hll_global $P3485, "GLOBAL"
    nqp_get_package_through_who $P3486, $P3485, "PAST"
    get_who $P3487, $P3486
    set $P3488, $P3487["Op"]
    find_lex $P3489, "$mainline"
    unless_null $P3489, vivify_1627
    new $P3489, "Undef"
  vivify_1627:
    $P3490 = $P3488."new"($P3489, "return" :named("pirop"))
    $P3484."push"($P3490)
.annotate 'line', 865
    find_lex $P3491, "$unit"
    unless_null $P3491, vivify_1628
    new $P3491, "Undef"
  vivify_1628:
.annotate 'line', 866
    get_hll_global $P3492, "GLOBAL"
    nqp_get_package_through_who $P3493, $P3492, "PAST"
    get_who $P3494, $P3493
    set $P3495, $P3494["Block"]
.annotate 'line', 868
    get_hll_global $P3496, "GLOBAL"
    nqp_get_package_through_who $P3497, $P3496, "PAST"
    get_who $P3498, $P3497
    set $P3499, $P3498["Op"]
    get_hll_global $P3500, "GLOBAL"
    nqp_get_package_through_who $P3501, $P3500, "PAST"
    get_who $P3502, $P3501
    set $P3503, $P3502["Val"]
    find_lex $P3504, "$unit"
    unless_null $P3504, vivify_1629
    new $P3504, "Undef"
  vivify_1629:
    $P3505 = $P3503."new"($P3504 :named("value"))
    $P3506 = $P3499."new"($P3505, "call" :named("pasttype"))
    $P3507 = $P3495."new"($P3506, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 866
    $P3491."push"($P3507)
.annotate 'line', 871
    find_lex $P3508, "$unit"
    unless_null $P3508, vivify_1630
    new $P3508, "Undef"
  vivify_1630:
    find_lex $P3509, "$/"
    unless_null $P3509, vivify_1631
    new $P3509, "Undef"
  vivify_1631:
    $P3508."node"($P3509)
.annotate 'line', 874
    find_lex $P3510, "$unit"
    unless_null $P3510, vivify_1632
    new $P3510, "Undef"
  vivify_1632:
    $P3510."hll"("nqp")
.annotate 'line', 876
    find_lex $P3511, "$/"
    find_lex $P3512, "$unit"
    unless_null $P3512, vivify_1633
    new $P3512, "Undef"
  vivify_1633:
    $P3513 = $P3511."!make"($P3512)
.annotate 'line', 815
    .return ($P3513)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("437_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3515
    .param pmc param_3516
.annotate 'line', 879
    .const 'Sub' $P3533 = "438_1303923618.727" 
    capture_lex $P3533
    .lex "self", param_3515
    .lex "$/", param_3516
.annotate 'line', 880
    new $P3517, "Undef"
    .lex "$past", $P3517
    get_hll_global $P3518, "GLOBAL"
    nqp_get_package_through_who $P3519, $P3518, "PAST"
    get_who $P3520, $P3519
    set $P3521, $P3520["Stmts"]
    find_lex $P3522, "$/"
    unless_null $P3522, vivify_1634
    new $P3522, "Undef"
  vivify_1634:
    $P3523 = $P3521."new"($P3522 :named("node"))
    store_lex "$past", $P3523
.annotate 'line', 881
    find_lex $P3525, "$/"
    unless_null $P3525, vivify_1635
    $P3525 = root_new ['parrot';'Hash']
  vivify_1635:
    set $P3526, $P3525["statement"]
    unless_null $P3526, vivify_1636
    new $P3526, "Undef"
  vivify_1636:
    unless $P3526, if_3524_end
.annotate 'line', 882
    find_lex $P3528, "$/"
    unless_null $P3528, vivify_1637
    $P3528 = root_new ['parrot';'Hash']
  vivify_1637:
    set $P3529, $P3528["statement"]
    unless_null $P3529, vivify_1638
    new $P3529, "Undef"
  vivify_1638:
    defined $I3530, $P3529
    unless $I3530, for_undef_1639
    iter $P3527, $P3529
    new $P3553, 'ExceptionHandler'
    set_label $P3553, loop3552_handler
    $P3553."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3553
  loop3552_test:
    unless $P3527, loop3552_done
    shift $P3531, $P3527
  loop3552_redo:
    .const 'Sub' $P3533 = "438_1303923618.727" 
    capture_lex $P3533
    $P3533($P3531)
  loop3552_next:
    goto loop3552_test
  loop3552_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3554, exception, 'type'
    eq $P3554, .CONTROL_LOOP_NEXT, loop3552_next
    eq $P3554, .CONTROL_LOOP_REDO, loop3552_redo
  loop3552_done:
    pop_eh 
  for_undef_1639:
  if_3524_end:
.annotate 'line', 889
    find_lex $P3555, "$/"
    find_lex $P3556, "$past"
    unless_null $P3556, vivify_1650
    new $P3556, "Undef"
  vivify_1650:
    $P3557 = $P3555."!make"($P3556)
.annotate 'line', 879
    .return ($P3557)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3532"  :anon :subid("438_1303923618.727") :outer("437_1303923618.727")
    .param pmc param_3535
.annotate 'line', 883
    new $P3534, "Undef"
    .lex "$ast", $P3534
    .lex "$_", param_3535
    find_lex $P3536, "$_"
    unless_null $P3536, vivify_1640
    new $P3536, "Undef"
  vivify_1640:
    $P3537 = $P3536."ast"()
    store_lex "$ast", $P3537
.annotate 'line', 884
    find_lex $P3539, "$ast"
    unless_null $P3539, vivify_1641
    $P3539 = root_new ['parrot';'Hash']
  vivify_1641:
    set $P3540, $P3539["sink"]
    unless_null $P3540, vivify_1642
    new $P3540, "Undef"
  vivify_1642:
    defined $I3541, $P3540
    unless $I3541, if_3538_end
    find_lex $P3542, "$ast"
    unless_null $P3542, vivify_1643
    $P3542 = root_new ['parrot';'Hash']
  vivify_1643:
    set $P3543, $P3542["sink"]
    unless_null $P3543, vivify_1644
    new $P3543, "Undef"
  vivify_1644:
    store_lex "$ast", $P3543
  if_3538_end:
.annotate 'line', 885
    find_lex $P3545, "$ast"
    unless_null $P3545, vivify_1645
    $P3545 = root_new ['parrot';'Hash']
  vivify_1645:
    set $P3546, $P3545["bareblock"]
    unless_null $P3546, vivify_1646
    new $P3546, "Undef"
  vivify_1646:
    unless $P3546, if_3544_end
    find_lex $P3547, "$ast"
    unless_null $P3547, vivify_1647
    new $P3547, "Undef"
  vivify_1647:
    $P3548 = "block_immediate"($P3547)
    store_lex "$ast", $P3548
  if_3544_end:
.annotate 'line', 886
    find_lex $P3549, "$past"
    unless_null $P3549, vivify_1648
    new $P3549, "Undef"
  vivify_1648:
    find_lex $P3550, "$ast"
    unless_null $P3550, vivify_1649
    new $P3550, "Undef"
  vivify_1649:
    $P3551 = $P3549."push"($P3550)
.annotate 'line', 882
    .return ($P3551)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("439_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3559
    .param pmc param_3560
    .param pmc param_3561 :optional
    .param int has_param_3561 :opt_flag
.annotate 'line', 892
    .const 'Sub' $P3569 = "440_1303923618.727" 
    capture_lex $P3569
    .lex "self", param_3559
    .lex "$/", param_3560
    if has_param_3561, optparam_1651
    new $P3562, "Undef"
    set param_3561, $P3562
  optparam_1651:
    .lex "$key", param_3561
.annotate 'line', 893
    new $P3563, "Undef"
    .lex "$past", $P3563
.annotate 'line', 892
    find_lex $P3564, "$past"
    unless_null $P3564, vivify_1652
    new $P3564, "Undef"
  vivify_1652:
.annotate 'line', 894
    find_lex $P3566, "$/"
    unless_null $P3566, vivify_1653
    $P3566 = root_new ['parrot';'Hash']
  vivify_1653:
    set $P3567, $P3566["EXPR"]
    unless_null $P3567, vivify_1654
    new $P3567, "Undef"
  vivify_1654:
    if $P3567, if_3565
.annotate 'line', 915
    find_lex $P3645, "$/"
    unless_null $P3645, vivify_1655
    $P3645 = root_new ['parrot';'Hash']
  vivify_1655:
    set $P3646, $P3645["statement_control"]
    unless_null $P3646, vivify_1656
    new $P3646, "Undef"
  vivify_1656:
    if $P3646, if_3644
.annotate 'line', 916
    new $P3650, "Integer"
    assign $P3650, 0
    store_lex "$past", $P3650
    goto if_3644_end
  if_3644:
.annotate 'line', 915
    find_lex $P3647, "$/"
    unless_null $P3647, vivify_1657
    $P3647 = root_new ['parrot';'Hash']
  vivify_1657:
    set $P3648, $P3647["statement_control"]
    unless_null $P3648, vivify_1658
    new $P3648, "Undef"
  vivify_1658:
    $P3649 = $P3648."ast"()
    store_lex "$past", $P3649
  if_3644_end:
    goto if_3565_end
  if_3565:
.annotate 'line', 894
    .const 'Sub' $P3569 = "440_1303923618.727" 
    capture_lex $P3569
    $P3569()
  if_3565_end:
.annotate 'line', 917
    find_lex $P3651, "$/"
    find_lex $P3652, "$past"
    unless_null $P3652, vivify_1692
    new $P3652, "Undef"
  vivify_1692:
    $P3653 = $P3651."!make"($P3652)
.annotate 'line', 892
    .return ($P3653)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3568"  :anon :subid("440_1303923618.727") :outer("439_1303923618.727")
.annotate 'line', 895
    new $P3570, "Undef"
    .lex "$mc", $P3570
.annotate 'line', 896
    new $P3571, "Undef"
    .lex "$ml", $P3571
.annotate 'line', 895
    find_lex $P3572, "$/"
    unless_null $P3572, vivify_1659
    $P3572 = root_new ['parrot';'Hash']
  vivify_1659:
    set $P3573, $P3572["statement_mod_cond"]
    unless_null $P3573, vivify_1660
    $P3573 = root_new ['parrot';'ResizablePMCArray']
  vivify_1660:
    set $P3574, $P3573[0]
    unless_null $P3574, vivify_1661
    new $P3574, "Undef"
  vivify_1661:
    store_lex "$mc", $P3574
.annotate 'line', 896
    find_lex $P3575, "$/"
    unless_null $P3575, vivify_1662
    $P3575 = root_new ['parrot';'Hash']
  vivify_1662:
    set $P3576, $P3575["statement_mod_loop"]
    unless_null $P3576, vivify_1663
    $P3576 = root_new ['parrot';'ResizablePMCArray']
  vivify_1663:
    set $P3577, $P3576[0]
    unless_null $P3577, vivify_1664
    new $P3577, "Undef"
  vivify_1664:
    store_lex "$ml", $P3577
.annotate 'line', 897
    find_lex $P3578, "$/"
    unless_null $P3578, vivify_1665
    $P3578 = root_new ['parrot';'Hash']
  vivify_1665:
    set $P3579, $P3578["EXPR"]
    unless_null $P3579, vivify_1666
    new $P3579, "Undef"
  vivify_1666:
    $P3580 = $P3579."ast"()
    store_lex "$past", $P3580
.annotate 'line', 898
    find_lex $P3582, "$mc"
    unless_null $P3582, vivify_1667
    new $P3582, "Undef"
  vivify_1667:
    unless $P3582, if_3581_end
.annotate 'line', 899
    get_hll_global $P3583, "GLOBAL"
    nqp_get_package_through_who $P3584, $P3583, "PAST"
    get_who $P3585, $P3584
    set $P3586, $P3585["Op"]
    find_lex $P3587, "$mc"
    unless_null $P3587, vivify_1668
    $P3587 = root_new ['parrot';'Hash']
  vivify_1668:
    set $P3588, $P3587["cond"]
    unless_null $P3588, vivify_1669
    new $P3588, "Undef"
  vivify_1669:
    $P3589 = $P3588."ast"()
    find_lex $P3590, "$past"
    unless_null $P3590, vivify_1670
    new $P3590, "Undef"
  vivify_1670:
    find_lex $P3591, "$mc"
    unless_null $P3591, vivify_1671
    $P3591 = root_new ['parrot';'Hash']
  vivify_1671:
    set $P3592, $P3591["sym"]
    unless_null $P3592, vivify_1672
    new $P3592, "Undef"
  vivify_1672:
    set $S3593, $P3592
    find_lex $P3594, "$/"
    unless_null $P3594, vivify_1673
    new $P3594, "Undef"
  vivify_1673:
    $P3595 = $P3586."new"($P3589, $P3590, $S3593 :named("pasttype"), $P3594 :named("node"))
    store_lex "$past", $P3595
  if_3581_end:
.annotate 'line', 901
    find_lex $P3598, "$ml"
    unless_null $P3598, vivify_1674
    new $P3598, "Undef"
  vivify_1674:
    if $P3598, if_3597
    set $P3596, $P3598
    goto if_3597_end
  if_3597:
.annotate 'line', 902
    find_lex $P3601, "$ml"
    unless_null $P3601, vivify_1675
    $P3601 = root_new ['parrot';'Hash']
  vivify_1675:
    set $P3602, $P3601["sym"]
    unless_null $P3602, vivify_1676
    new $P3602, "Undef"
  vivify_1676:
    set $S3603, $P3602
    iseq $I3604, $S3603, "for"
    if $I3604, if_3600
.annotate 'line', 911
    get_hll_global $P3631, "GLOBAL"
    nqp_get_package_through_who $P3632, $P3631, "PAST"
    get_who $P3633, $P3632
    set $P3634, $P3633["Op"]
    find_lex $P3635, "$ml"
    unless_null $P3635, vivify_1677
    $P3635 = root_new ['parrot';'Hash']
  vivify_1677:
    set $P3636, $P3635["cond"]
    unless_null $P3636, vivify_1678
    new $P3636, "Undef"
  vivify_1678:
    $P3637 = $P3636."ast"()
    find_lex $P3638, "$past"
    unless_null $P3638, vivify_1679
    new $P3638, "Undef"
  vivify_1679:
    find_lex $P3639, "$ml"
    unless_null $P3639, vivify_1680
    $P3639 = root_new ['parrot';'Hash']
  vivify_1680:
    set $P3640, $P3639["sym"]
    unless_null $P3640, vivify_1681
    new $P3640, "Undef"
  vivify_1681:
    set $S3641, $P3640
    find_lex $P3642, "$/"
    unless_null $P3642, vivify_1682
    new $P3642, "Undef"
  vivify_1682:
    $P3643 = $P3634."new"($P3637, $P3638, $S3641 :named("pasttype"), $P3642 :named("node"))
    store_lex "$past", $P3643
.annotate 'line', 910
    set $P3599, $P3643
.annotate 'line', 902
    goto if_3600_end
  if_3600:
.annotate 'line', 903
    get_hll_global $P3605, "GLOBAL"
    nqp_get_package_through_who $P3606, $P3605, "PAST"
    get_who $P3607, $P3606
    set $P3608, $P3607["Block"]
.annotate 'line', 904
    get_hll_global $P3609, "GLOBAL"
    nqp_get_package_through_who $P3610, $P3609, "PAST"
    get_who $P3611, $P3610
    set $P3612, $P3611["Var"]
    $P3613 = $P3612."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P3614, "$past"
    unless_null $P3614, vivify_1683
    new $P3614, "Undef"
  vivify_1683:
    $P3615 = $P3608."new"($P3613, $P3614, "immediate" :named("blocktype"))
.annotate 'line', 903
    store_lex "$past", $P3615
.annotate 'line', 906
    find_lex $P3616, "$past"
    unless_null $P3616, vivify_1684
    new $P3616, "Undef"
  vivify_1684:
    $P3616."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 907
    find_lex $P3617, "$past"
    unless_null $P3617, vivify_1685
    new $P3617, "Undef"
  vivify_1685:
    $P3617."arity"(1)
.annotate 'line', 908
    get_hll_global $P3618, "GLOBAL"
    nqp_get_package_through_who $P3619, $P3618, "PAST"
    get_who $P3620, $P3619
    set $P3621, $P3620["Op"]
    find_lex $P3622, "$ml"
    unless_null $P3622, vivify_1686
    $P3622 = root_new ['parrot';'Hash']
  vivify_1686:
    set $P3623, $P3622["cond"]
    unless_null $P3623, vivify_1687
    new $P3623, "Undef"
  vivify_1687:
    $P3624 = $P3623."ast"()
    find_lex $P3625, "$past"
    unless_null $P3625, vivify_1688
    new $P3625, "Undef"
  vivify_1688:
    find_lex $P3626, "$ml"
    unless_null $P3626, vivify_1689
    $P3626 = root_new ['parrot';'Hash']
  vivify_1689:
    set $P3627, $P3626["sym"]
    unless_null $P3627, vivify_1690
    new $P3627, "Undef"
  vivify_1690:
    set $S3628, $P3627
    find_lex $P3629, "$/"
    unless_null $P3629, vivify_1691
    new $P3629, "Undef"
  vivify_1691:
    $P3630 = $P3621."new"($P3624, $P3625, $S3628 :named("pasttype"), $P3629 :named("node"))
    store_lex "$past", $P3630
.annotate 'line', 902
    set $P3599, $P3630
  if_3600_end:
.annotate 'line', 901
    set $P3596, $P3599
  if_3597_end:
.annotate 'line', 894
    .return ($P3596)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("441_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3655
    .param pmc param_3656
.annotate 'line', 920
    .lex "self", param_3655
    .lex "$/", param_3656
.annotate 'line', 921
    find_lex $P3657, "$/"
    get_hll_global $P3658, "GLOBAL"
    nqp_get_package_through_who $P3659, $P3658, "PAST"
    get_who $P3660, $P3659
    set $P3661, $P3660["Op"]
    find_lex $P3662, "$/"
    unless_null $P3662, vivify_1693
    $P3662 = root_new ['parrot';'Hash']
  vivify_1693:
    set $P3663, $P3662["EXPR"]
    unless_null $P3663, vivify_1694
    new $P3663, "Undef"
  vivify_1694:
    $P3664 = $P3663."ast"()
    find_lex $P3665, "$/"
    unless_null $P3665, vivify_1695
    $P3665 = root_new ['parrot';'Hash']
  vivify_1695:
    set $P3666, $P3665["pblock"]
    unless_null $P3666, vivify_1696
    new $P3666, "Undef"
  vivify_1696:
    $P3667 = $P3666."ast"()
    find_lex $P3668, "$/"
    unless_null $P3668, vivify_1697
    new $P3668, "Undef"
  vivify_1697:
    $P3669 = $P3661."new"($P3664, $P3667, "if" :named("pasttype"), $P3668 :named("node"))
    $P3670 = $P3657."!make"($P3669)
.annotate 'line', 920
    .return ($P3670)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("442_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3672
    .param pmc param_3673
.annotate 'line', 924
    .lex "self", param_3672
    .lex "$/", param_3673
.annotate 'line', 925
    find_lex $P3674, "$/"
    find_lex $P3675, "$/"
    unless_null $P3675, vivify_1698
    $P3675 = root_new ['parrot';'Hash']
  vivify_1698:
    set $P3676, $P3675["blockoid"]
    unless_null $P3676, vivify_1699
    new $P3676, "Undef"
  vivify_1699:
    $P3677 = $P3676."ast"()
    $P3678 = $P3674."!make"($P3677)
.annotate 'line', 924
    .return ($P3678)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("443_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3680
    .param pmc param_3681
.annotate 'line', 928
    .lex "self", param_3680
    .lex "$/", param_3681
.annotate 'line', 929
    find_lex $P3682, "$/"
    find_lex $P3683, "$/"
    unless_null $P3683, vivify_1700
    $P3683 = root_new ['parrot';'Hash']
  vivify_1700:
    set $P3684, $P3683["blockoid"]
    unless_null $P3684, vivify_1701
    new $P3684, "Undef"
  vivify_1701:
    $P3685 = $P3684."ast"()
    $P3686 = $P3682."!make"($P3685)
.annotate 'line', 928
    .return ($P3686)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("444_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3688
    .param pmc param_3689
.annotate 'line', 932
    .const 'Sub' $P3700 = "445_1303923618.727" 
    capture_lex $P3700
    .lex "self", param_3688
    .lex "$/", param_3689
.annotate 'line', 933
    new $P3690, "Undef"
    .lex "$BLOCK", $P3690
    find_lex $P3691, "$?PACKAGE"
    get_who $P3692, $P3691
    set $P3693, $P3692["@BLOCK"]
    unless_null $P3693, vivify_1702
    $P3693 = root_new ['parrot';'ResizablePMCArray']
  vivify_1702:
    $P3694 = $P3693."shift"()
    store_lex "$BLOCK", $P3694
.annotate 'line', 934
    find_lex $P3697, "$/"
    unless_null $P3697, vivify_1703
    $P3697 = root_new ['parrot';'Hash']
  vivify_1703:
    set $P3698, $P3697["statementlist"]
    unless_null $P3698, vivify_1704
    new $P3698, "Undef"
  vivify_1704:
    if $P3698, if_3696
.annotate 'line', 942
    find_dynamic_lex $P3717, "$*HAS_YOU_ARE_HERE"
    unless_null $P3717, vivify_1705
    get_hll_global $P3715, "GLOBAL"
    get_who $P3716, $P3715
    set $P3717, $P3716["$HAS_YOU_ARE_HERE"]
    unless_null $P3717, vivify_1706
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1706:
  vivify_1705:
    unless $P3717, if_3714_end
.annotate 'line', 943
    find_lex $P3718, "$/"
    unless_null $P3718, vivify_1707
    new $P3718, "Undef"
  vivify_1707:
    $P3719 = $P3718."CURSOR"()
    $P3719."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3714_end:
.annotate 'line', 945
    new $P3720, "Integer"
    assign $P3720, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3720
.annotate 'line', 946
    find_lex $P3721, "$/"
    find_lex $P3722, "$/"
    unless_null $P3722, vivify_1708
    $P3722 = root_new ['parrot';'Hash']
  vivify_1708:
    set $P3723, $P3722["you_are_here"]
    unless_null $P3723, vivify_1709
    new $P3723, "Undef"
  vivify_1709:
    $P3724 = $P3723."ast"()
    $P3725 = $P3721."!make"($P3724)
.annotate 'line', 941
    set $P3695, $P3725
.annotate 'line', 934
    goto if_3696_end
  if_3696:
    .const 'Sub' $P3700 = "445_1303923618.727" 
    capture_lex $P3700
    $P3713 = $P3700()
    set $P3695, $P3713
  if_3696_end:
.annotate 'line', 932
    .return ($P3695)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3699"  :anon :subid("445_1303923618.727") :outer("444_1303923618.727")
.annotate 'line', 935
    new $P3701, "Undef"
    .lex "$past", $P3701
    find_lex $P3702, "$/"
    unless_null $P3702, vivify_1710
    $P3702 = root_new ['parrot';'Hash']
  vivify_1710:
    set $P3703, $P3702["statementlist"]
    unless_null $P3703, vivify_1711
    new $P3703, "Undef"
  vivify_1711:
    $P3704 = $P3703."ast"()
    store_lex "$past", $P3704
.annotate 'line', 936
    find_lex $P3705, "$BLOCK"
    unless_null $P3705, vivify_1712
    new $P3705, "Undef"
  vivify_1712:
    find_lex $P3706, "$past"
    unless_null $P3706, vivify_1713
    new $P3706, "Undef"
  vivify_1713:
    $P3705."push"($P3706)
.annotate 'line', 937
    find_lex $P3707, "$BLOCK"
    unless_null $P3707, vivify_1714
    new $P3707, "Undef"
  vivify_1714:
    find_lex $P3708, "$/"
    unless_null $P3708, vivify_1715
    new $P3708, "Undef"
  vivify_1715:
    $P3707."node"($P3708)
.annotate 'line', 938
    find_lex $P3709, "$BLOCK"
    unless_null $P3709, vivify_1716
    new $P3709, "Undef"
  vivify_1716:
    $P3709."closure"(1)
.annotate 'line', 939
    find_dynamic_lex $P3710, "$/"
    find_lex $P3711, "$BLOCK"
    unless_null $P3711, vivify_1717
    new $P3711, "Undef"
  vivify_1717:
    $P3712 = $P3710."!make"($P3711)
.annotate 'line', 934
    .return ($P3712)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("446_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3727
    .param pmc param_3728
.annotate 'line', 950
    .lex "self", param_3727
    .lex "$/", param_3728
.annotate 'line', 951
    find_lex $P3729, "$?PACKAGE"
    get_who $P3730, $P3729
    set $P3731, $P3730["@BLOCK"]
    unless_null $P3731, vivify_1718
    $P3731 = root_new ['parrot';'ResizablePMCArray']
  vivify_1718:
    get_hll_global $P3732, "GLOBAL"
    nqp_get_package_through_who $P3733, $P3732, "PAST"
    get_who $P3734, $P3733
    set $P3735, $P3734["Block"]
    get_hll_global $P3736, "GLOBAL"
    nqp_get_package_through_who $P3737, $P3736, "PAST"
    get_who $P3738, $P3737
    set $P3739, $P3738["Stmts"]
    $P3740 = $P3739."new"()
    $P3741 = $P3735."new"($P3740)
    $P3742 = $P3731."unshift"($P3741)
.annotate 'line', 950
    .return ($P3742)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("447_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3744
    .param pmc param_3745
.annotate 'line', 954
    .const 'Sub' $P3754 = "448_1303923618.727" 
    capture_lex $P3754
    .lex "self", param_3744
    .lex "$/", param_3745
.annotate 'line', 955
    find_dynamic_lex $P3749, "%*COMPILING"
    unless_null $P3749, vivify_1719
    get_hll_global $P3747, "GLOBAL"
    get_who $P3748, $P3747
    set $P3749, $P3748["%COMPILING"]
    unless_null $P3749, vivify_1720
    die "Contextual %*COMPILING not found"
  vivify_1720:
  vivify_1719:
    set $P3750, $P3749["%?OPTIONS"]
    unless_null $P3750, vivify_1721
    $P3750 = root_new ['parrot';'Hash']
  vivify_1721:
    set $P3751, $P3750["outer_ctx"]
    unless_null $P3751, vivify_1722
    new $P3751, "Undef"
  vivify_1722:
    defined $I3752, $P3751
    if $I3752, unless_3746_end
    .const 'Sub' $P3754 = "448_1303923618.727" 
    capture_lex $P3754
    $P3754()
  unless_3746_end:
.annotate 'line', 968
    find_lex $P3786, "self"
    find_lex $P3787, "$?PACKAGE"
    get_who $P3788, $P3787
    set $P3789, $P3788["@BLOCK"]
    unless_null $P3789, vivify_1738
    $P3789 = root_new ['parrot';'ResizablePMCArray']
  vivify_1738:
    set $P3790, $P3789[0]
    unless_null $P3790, vivify_1739
    new $P3790, "Undef"
  vivify_1739:
    $P3791 = $P3786."SET_BLOCK_OUTER_CTX"($P3790)
.annotate 'line', 954
    .return ($P3791)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3753"  :anon :subid("448_1303923618.727") :outer("447_1303923618.727")
.annotate 'line', 958
    new $P3755, "Undef"
    .lex "$SETTING", $P3755
    find_dynamic_lex $P3758, "$*SC"
    unless_null $P3758, vivify_1723
    get_hll_global $P3756, "GLOBAL"
    get_who $P3757, $P3756
    set $P3758, $P3757["$SC"]
    unless_null $P3758, vivify_1724
    die "Contextual $*SC not found"
  vivify_1724:
  vivify_1723:
    find_dynamic_lex $P3762, "%*COMPILING"
    unless_null $P3762, vivify_1725
    get_hll_global $P3760, "GLOBAL"
    get_who $P3761, $P3760
    set $P3762, $P3761["%COMPILING"]
    unless_null $P3762, vivify_1726
    die "Contextual %*COMPILING not found"
  vivify_1726:
  vivify_1725:
    set $P3763, $P3762["%?OPTIONS"]
    unless_null $P3763, vivify_1727
    $P3763 = root_new ['parrot';'Hash']
  vivify_1727:
    set $P3764, $P3763["setting"]
    unless_null $P3764, vivify_1728
    new $P3764, "Undef"
  vivify_1728:
    set $P3759, $P3764
    defined $I3766, $P3759
    if $I3766, default_3765
    new $P3767, "String"
    assign $P3767, "NQPCORE"
    set $P3759, $P3767
  default_3765:
    $P3768 = $P3758."load_setting"($P3759)
    store_lex "$SETTING", $P3768
.annotate 'line', 963
    find_dynamic_lex $P3773, "%*COMPILING"
    unless_null $P3773, vivify_1729
    get_hll_global $P3771, "GLOBAL"
    get_who $P3772, $P3771
    set $P3773, $P3772["%COMPILING"]
    unless_null $P3773, vivify_1730
    die "Contextual %*COMPILING not found"
  vivify_1730:
  vivify_1729:
    set $P3774, $P3773["%?OPTIONS"]
    unless_null $P3774, vivify_1731
    $P3774 = root_new ['parrot';'Hash']
  vivify_1731:
    set $P3775, $P3774["setting"]
    unless_null $P3775, vivify_1732
    new $P3775, "Undef"
  vivify_1732:
    set $S3776, $P3775
    iseq $I3777, $S3776, "NULL"
    unless $I3777, unless_3770
    new $P3769, 'Integer'
    set $P3769, $I3777
    goto unless_3770_end
  unless_3770:
.annotate 'line', 964
    find_lex $P3778, "$SETTING"
    unless_null $P3778, vivify_1733
    new $P3778, "Undef"
  vivify_1733:
    "import_HOW_exports"($P3778)
.annotate 'line', 965
    find_dynamic_lex $P3781, "$*SC"
    unless_null $P3781, vivify_1734
    get_hll_global $P3779, "GLOBAL"
    get_who $P3780, $P3779
    set $P3781, $P3780["$SC"]
    unless_null $P3781, vivify_1735
    die "Contextual $*SC not found"
  vivify_1735:
  vivify_1734:
    find_dynamic_lex $P3784, "$*GLOBALish"
    unless_null $P3784, vivify_1736
    get_hll_global $P3782, "GLOBAL"
    get_who $P3783, $P3782
    set $P3784, $P3783["$GLOBALish"]
    unless_null $P3784, vivify_1737
    die "Contextual $*GLOBALish not found"
  vivify_1737:
  vivify_1736:
    $P3785 = $P3781."load_module"("Regex", $P3784)
.annotate 'line', 963
    set $P3769, $P3785
  unless_3770_end:
.annotate 'line', 955
    .return ($P3769)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("449_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3794
    .param pmc param_3795
.annotate 'line', 980
    .lex "self", param_3794
    .lex "$/", param_3795
.annotate 'line', 984
    find_dynamic_lex $P3798, "$*SC"
    unless_null $P3798, vivify_1740
    get_hll_global $P3796, "GLOBAL"
    get_who $P3797, $P3796
    set $P3798, $P3797["$SC"]
    unless_null $P3798, vivify_1741
    die "Contextual $*SC not found"
  vivify_1741:
  vivify_1740:
    find_dynamic_lex $P3801, "%*HOW"
    unless_null $P3801, vivify_1742
    get_hll_global $P3799, "GLOBAL"
    get_who $P3800, $P3799
    set $P3801, $P3800["%HOW"]
    unless_null $P3801, vivify_1743
    die "Contextual %*HOW not found"
  vivify_1743:
  vivify_1742:
    set $P3802, $P3801["knowhow"]
    unless_null $P3802, vivify_1744
    new $P3802, "Undef"
  vivify_1744:
    $P3803 = $P3798."pkg_create_mo"($P3802, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3803
.annotate 'line', 985
    find_dynamic_lex $P3806, "$*GLOBALish"
    unless_null $P3806, vivify_1745
    get_hll_global $P3804, "GLOBAL"
    get_who $P3805, $P3804
    set $P3806, $P3805["$GLOBALish"]
    unless_null $P3806, vivify_1746
    die "Contextual $*GLOBALish not found"
  vivify_1746:
  vivify_1745:
    get_how $P3807, $P3806
    find_dynamic_lex $P3810, "$*GLOBALish"
    unless_null $P3810, vivify_1747
    get_hll_global $P3808, "GLOBAL"
    get_who $P3809, $P3808
    set $P3810, $P3809["$GLOBALish"]
    unless_null $P3810, vivify_1748
    die "Contextual $*GLOBALish not found"
  vivify_1748:
  vivify_1747:
    $P3807."compose"($P3810)
.annotate 'line', 986
    find_dynamic_lex $P3813, "$*SC"
    unless_null $P3813, vivify_1749
    get_hll_global $P3811, "GLOBAL"
    get_who $P3812, $P3811
    set $P3813, $P3812["$SC"]
    unless_null $P3813, vivify_1750
    die "Contextual $*SC not found"
  vivify_1750:
  vivify_1749:
    find_lex $P3814, "$?PACKAGE"
    get_who $P3815, $P3814
    set $P3816, $P3815["@BLOCK"]
    unless_null $P3816, vivify_1751
    $P3816 = root_new ['parrot';'ResizablePMCArray']
  vivify_1751:
    set $P3817, $P3816[0]
    unless_null $P3817, vivify_1752
    new $P3817, "Undef"
  vivify_1752:
    find_dynamic_lex $P3820, "$*GLOBALish"
    unless_null $P3820, vivify_1753
    get_hll_global $P3818, "GLOBAL"
    get_who $P3819, $P3818
    set $P3820, $P3819["$GLOBALish"]
    unless_null $P3820, vivify_1754
    die "Contextual $*GLOBALish not found"
  vivify_1754:
  vivify_1753:
    $P3813."install_lexical_symbol"($P3817, "GLOBALish", $P3820)
.annotate 'line', 989
    find_dynamic_lex $P3823, "$*GLOBALish"
    unless_null $P3823, vivify_1755
    get_hll_global $P3821, "GLOBAL"
    get_who $P3822, $P3821
    set $P3823, $P3822["$GLOBALish"]
    unless_null $P3823, vivify_1756
    die "Contextual $*GLOBALish not found"
  vivify_1756:
  vivify_1755:
    store_dynamic_lex "$*PACKAGE", $P3823
.annotate 'line', 990
    find_dynamic_lex $P3826, "$*SC"
    unless_null $P3826, vivify_1757
    get_hll_global $P3824, "GLOBAL"
    get_who $P3825, $P3824
    set $P3826, $P3825["$SC"]
    unless_null $P3826, vivify_1758
    die "Contextual $*SC not found"
  vivify_1758:
  vivify_1757:
    find_lex $P3827, "$?PACKAGE"
    get_who $P3828, $P3827
    set $P3829, $P3828["@BLOCK"]
    unless_null $P3829, vivify_1759
    $P3829 = root_new ['parrot';'ResizablePMCArray']
  vivify_1759:
    set $P3830, $P3829[0]
    unless_null $P3830, vivify_1760
    new $P3830, "Undef"
  vivify_1760:
    find_dynamic_lex $P3833, "$*PACKAGE"
    unless_null $P3833, vivify_1761
    get_hll_global $P3831, "GLOBAL"
    get_who $P3832, $P3831
    set $P3833, $P3832["$PACKAGE"]
    unless_null $P3833, vivify_1762
    die "Contextual $*PACKAGE not found"
  vivify_1762:
  vivify_1761:
    $P3834 = $P3826."install_lexical_symbol"($P3830, "$?PACKAGE", $P3833)
.annotate 'line', 980
    .return ($P3834)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("450_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3836
    .param pmc param_3837
.annotate 'line', 993
    .lex "self", param_3836
    .lex "$/", param_3837
.annotate 'line', 994
    find_lex $P3838, "$/"
    find_lex $P3839, "self"
    $P3840 = $P3839."CTXSAVE"()
    $P3841 = $P3838."!make"($P3840)
.annotate 'line', 993
    .return ($P3841)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("451_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3843
    .param pmc param_3844
.annotate 'line', 999
    .lex "self", param_3843
    .lex "$/", param_3844
.annotate 'line', 1000
    new $P3845, "Undef"
    .lex "$module", $P3845
    find_dynamic_lex $P3848, "$*SC"
    unless_null $P3848, vivify_1763
    get_hll_global $P3846, "GLOBAL"
    get_who $P3847, $P3846
    set $P3848, $P3847["$SC"]
    unless_null $P3848, vivify_1764
    die "Contextual $*SC not found"
  vivify_1764:
  vivify_1763:
    find_lex $P3849, "$/"
    unless_null $P3849, vivify_1765
    $P3849 = root_new ['parrot';'Hash']
  vivify_1765:
    set $P3850, $P3849["name"]
    unless_null $P3850, vivify_1766
    new $P3850, "Undef"
  vivify_1766:
    set $S3851, $P3850
    find_dynamic_lex $P3854, "$*GLOBALish"
    unless_null $P3854, vivify_1767
    get_hll_global $P3852, "GLOBAL"
    get_who $P3853, $P3852
    set $P3854, $P3853["$GLOBALish"]
    unless_null $P3854, vivify_1768
    die "Contextual $*GLOBALish not found"
  vivify_1768:
  vivify_1767:
    $P3855 = $P3848."load_module"($S3851, $P3854)
    store_lex "$module", $P3855
.annotate 'line', 1001
    find_lex $P3857, "$module"
    unless_null $P3857, vivify_1769
    new $P3857, "Undef"
  vivify_1769:
    defined $I3858, $P3857
    unless $I3858, if_3856_end
.annotate 'line', 1002
    find_lex $P3859, "$module"
    unless_null $P3859, vivify_1770
    new $P3859, "Undef"
  vivify_1770:
    "import_HOW_exports"($P3859)
  if_3856_end:
.annotate 'line', 1004
    find_lex $P3860, "$/"
    get_hll_global $P3861, "GLOBAL"
    nqp_get_package_through_who $P3862, $P3861, "PAST"
    get_who $P3863, $P3862
    set $P3864, $P3863["Stmts"]
    $P3865 = $P3864."new"()
    $P3866 = $P3860."!make"($P3865)
.annotate 'line', 999
    .return ($P3866)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("452_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3868
    .param pmc param_3869
.annotate 'line', 1007
    .const 'Sub' $P3897 = "453_1303923618.727" 
    capture_lex $P3897
    .lex "self", param_3868
    .lex "$/", param_3869
.annotate 'line', 1008
    new $P3870, "Undef"
    .lex "$count", $P3870
.annotate 'line', 1009
    new $P3871, "Undef"
    .lex "$past", $P3871
.annotate 'line', 1008
    find_lex $P3872, "$/"
    unless_null $P3872, vivify_1771
    $P3872 = root_new ['parrot';'Hash']
  vivify_1771:
    set $P3873, $P3872["xblock"]
    unless_null $P3873, vivify_1772
    new $P3873, "Undef"
  vivify_1772:
    set $N3874, $P3873
    new $P3875, 'Float'
    set $P3875, $N3874
    sub $P3876, $P3875, 1
    store_lex "$count", $P3876
.annotate 'line', 1009
    find_lex $P3877, "$count"
    unless_null $P3877, vivify_1773
    new $P3877, "Undef"
  vivify_1773:
    set $I3878, $P3877
    find_lex $P3879, "$/"
    unless_null $P3879, vivify_1774
    $P3879 = root_new ['parrot';'Hash']
  vivify_1774:
    set $P3880, $P3879["xblock"]
    unless_null $P3880, vivify_1775
    $P3880 = root_new ['parrot';'ResizablePMCArray']
  vivify_1775:
    set $P3881, $P3880[$I3878]
    unless_null $P3881, vivify_1776
    new $P3881, "Undef"
  vivify_1776:
    $P3882 = $P3881."ast"()
    $P3883 = "xblock_immediate"($P3882)
    store_lex "$past", $P3883
.annotate 'line', 1010
    find_lex $P3885, "$/"
    unless_null $P3885, vivify_1777
    $P3885 = root_new ['parrot';'Hash']
  vivify_1777:
    set $P3886, $P3885["else"]
    unless_null $P3886, vivify_1778
    new $P3886, "Undef"
  vivify_1778:
    unless $P3886, if_3884_end
.annotate 'line', 1011
    find_lex $P3887, "$past"
    unless_null $P3887, vivify_1779
    new $P3887, "Undef"
  vivify_1779:
    find_lex $P3888, "$/"
    unless_null $P3888, vivify_1780
    $P3888 = root_new ['parrot';'Hash']
  vivify_1780:
    set $P3889, $P3888["else"]
    unless_null $P3889, vivify_1781
    $P3889 = root_new ['parrot';'ResizablePMCArray']
  vivify_1781:
    set $P3890, $P3889[0]
    unless_null $P3890, vivify_1782
    new $P3890, "Undef"
  vivify_1782:
    $P3891 = $P3890."ast"()
    $P3892 = "block_immediate"($P3891)
    $P3887."push"($P3892)
  if_3884_end:
.annotate 'line', 1014
    new $P3913, 'ExceptionHandler'
    set_label $P3913, loop3912_handler
    $P3913."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3913
  loop3912_test:
    find_lex $P3893, "$count"
    unless_null $P3893, vivify_1783
    new $P3893, "Undef"
  vivify_1783:
    set $N3894, $P3893
    isgt $I3895, $N3894, 0.0
    unless $I3895, loop3912_done
  loop3912_redo:
    .const 'Sub' $P3897 = "453_1303923618.727" 
    capture_lex $P3897
    $P3897()
  loop3912_next:
    goto loop3912_test
  loop3912_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3914, exception, 'type'
    eq $P3914, .CONTROL_LOOP_NEXT, loop3912_next
    eq $P3914, .CONTROL_LOOP_REDO, loop3912_redo
  loop3912_done:
    pop_eh 
.annotate 'line', 1020
    find_lex $P3915, "$/"
    find_lex $P3916, "$past"
    unless_null $P3916, vivify_1792
    new $P3916, "Undef"
  vivify_1792:
    $P3917 = $P3915."!make"($P3916)
.annotate 'line', 1007
    .return ($P3917)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3896"  :anon :subid("453_1303923618.727") :outer("452_1303923618.727")
.annotate 'line', 1016
    new $P3898, "Undef"
    .lex "$else", $P3898
.annotate 'line', 1014
    find_lex $P3899, "$count"
    unless_null $P3899, vivify_1784
    new $P3899, "Undef"
  vivify_1784:
    clone $P3900, $P3899
    dec $P3899
.annotate 'line', 1016
    find_lex $P3901, "$past"
    unless_null $P3901, vivify_1785
    new $P3901, "Undef"
  vivify_1785:
    store_lex "$else", $P3901
.annotate 'line', 1017
    find_lex $P3902, "$count"
    unless_null $P3902, vivify_1786
    new $P3902, "Undef"
  vivify_1786:
    set $I3903, $P3902
    find_lex $P3904, "$/"
    unless_null $P3904, vivify_1787
    $P3904 = root_new ['parrot';'Hash']
  vivify_1787:
    set $P3905, $P3904["xblock"]
    unless_null $P3905, vivify_1788
    $P3905 = root_new ['parrot';'ResizablePMCArray']
  vivify_1788:
    set $P3906, $P3905[$I3903]
    unless_null $P3906, vivify_1789
    new $P3906, "Undef"
  vivify_1789:
    $P3907 = $P3906."ast"()
    $P3908 = "xblock_immediate"($P3907)
    store_lex "$past", $P3908
.annotate 'line', 1018
    find_lex $P3909, "$past"
    unless_null $P3909, vivify_1790
    new $P3909, "Undef"
  vivify_1790:
    find_lex $P3910, "$else"
    unless_null $P3910, vivify_1791
    new $P3910, "Undef"
  vivify_1791:
    $P3911 = $P3909."push"($P3910)
.annotate 'line', 1014
    .return ($P3911)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("454_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3919
    .param pmc param_3920
.annotate 'line', 1023
    .lex "self", param_3919
    .lex "$/", param_3920
.annotate 'line', 1024
    new $P3921, "Undef"
    .lex "$past", $P3921
    find_lex $P3922, "$/"
    unless_null $P3922, vivify_1793
    $P3922 = root_new ['parrot';'Hash']
  vivify_1793:
    set $P3923, $P3922["xblock"]
    unless_null $P3923, vivify_1794
    new $P3923, "Undef"
  vivify_1794:
    $P3924 = $P3923."ast"()
    $P3925 = "xblock_immediate"($P3924)
    store_lex "$past", $P3925
.annotate 'line', 1025
    find_lex $P3926, "$past"
    unless_null $P3926, vivify_1795
    new $P3926, "Undef"
  vivify_1795:
    $P3926."pasttype"("unless")
.annotate 'line', 1026
    find_lex $P3927, "$/"
    find_lex $P3928, "$past"
    unless_null $P3928, vivify_1796
    new $P3928, "Undef"
  vivify_1796:
    $P3929 = $P3927."!make"($P3928)
.annotate 'line', 1023
    .return ($P3929)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("455_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3931
    .param pmc param_3932
.annotate 'line', 1029
    .lex "self", param_3931
    .lex "$/", param_3932
.annotate 'line', 1030
    new $P3933, "Undef"
    .lex "$past", $P3933
    find_lex $P3934, "$/"
    unless_null $P3934, vivify_1797
    $P3934 = root_new ['parrot';'Hash']
  vivify_1797:
    set $P3935, $P3934["xblock"]
    unless_null $P3935, vivify_1798
    new $P3935, "Undef"
  vivify_1798:
    $P3936 = $P3935."ast"()
    $P3937 = "xblock_immediate"($P3936)
    store_lex "$past", $P3937
.annotate 'line', 1031
    find_lex $P3938, "$past"
    unless_null $P3938, vivify_1799
    new $P3938, "Undef"
  vivify_1799:
    find_lex $P3939, "$/"
    unless_null $P3939, vivify_1800
    $P3939 = root_new ['parrot';'Hash']
  vivify_1800:
    set $P3940, $P3939["sym"]
    unless_null $P3940, vivify_1801
    new $P3940, "Undef"
  vivify_1801:
    set $S3941, $P3940
    $P3938."pasttype"($S3941)
.annotate 'line', 1032
    find_lex $P3942, "$/"
    find_lex $P3943, "$past"
    unless_null $P3943, vivify_1802
    new $P3943, "Undef"
  vivify_1802:
    $P3944 = $P3942."!make"($P3943)
.annotate 'line', 1029
    .return ($P3944)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("456_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3946
    .param pmc param_3947
.annotate 'line', 1035
    .lex "self", param_3946
    .lex "$/", param_3947
.annotate 'line', 1036
    new $P3948, "Undef"
    .lex "$pasttype", $P3948
.annotate 'line', 1037
    new $P3949, "Undef"
    .lex "$past", $P3949
.annotate 'line', 1036
    new $P3950, "String"
    assign $P3950, "repeat_"
    find_lex $P3951, "$/"
    unless_null $P3951, vivify_1803
    $P3951 = root_new ['parrot';'Hash']
  vivify_1803:
    set $P3952, $P3951["wu"]
    unless_null $P3952, vivify_1804
    new $P3952, "Undef"
  vivify_1804:
    set $S3953, $P3952
    concat $P3954, $P3950, $S3953
    store_lex "$pasttype", $P3954
    find_lex $P3955, "$past"
    unless_null $P3955, vivify_1805
    new $P3955, "Undef"
  vivify_1805:
.annotate 'line', 1038
    find_lex $P3957, "$/"
    unless_null $P3957, vivify_1806
    $P3957 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P3958, $P3957["xblock"]
    unless_null $P3958, vivify_1807
    new $P3958, "Undef"
  vivify_1807:
    if $P3958, if_3956
.annotate 'line', 1043
    get_hll_global $P3965, "GLOBAL"
    nqp_get_package_through_who $P3966, $P3965, "PAST"
    get_who $P3967, $P3966
    set $P3968, $P3967["Op"]
    find_lex $P3969, "$/"
    unless_null $P3969, vivify_1808
    $P3969 = root_new ['parrot';'Hash']
  vivify_1808:
    set $P3970, $P3969["EXPR"]
    unless_null $P3970, vivify_1809
    new $P3970, "Undef"
  vivify_1809:
    $P3971 = $P3970."ast"()
    find_lex $P3972, "$/"
    unless_null $P3972, vivify_1810
    $P3972 = root_new ['parrot';'Hash']
  vivify_1810:
    set $P3973, $P3972["pblock"]
    unless_null $P3973, vivify_1811
    new $P3973, "Undef"
  vivify_1811:
    $P3974 = $P3973."ast"()
    $P3975 = "block_immediate"($P3974)
    find_lex $P3976, "$pasttype"
    unless_null $P3976, vivify_1812
    new $P3976, "Undef"
  vivify_1812:
    find_lex $P3977, "$/"
    unless_null $P3977, vivify_1813
    new $P3977, "Undef"
  vivify_1813:
    $P3978 = $P3968."new"($P3971, $P3975, $P3976 :named("pasttype"), $P3977 :named("node"))
    store_lex "$past", $P3978
.annotate 'line', 1042
    goto if_3956_end
  if_3956:
.annotate 'line', 1039
    find_lex $P3959, "$/"
    unless_null $P3959, vivify_1814
    $P3959 = root_new ['parrot';'Hash']
  vivify_1814:
    set $P3960, $P3959["xblock"]
    unless_null $P3960, vivify_1815
    new $P3960, "Undef"
  vivify_1815:
    $P3961 = $P3960."ast"()
    $P3962 = "xblock_immediate"($P3961)
    store_lex "$past", $P3962
.annotate 'line', 1040
    find_lex $P3963, "$past"
    unless_null $P3963, vivify_1816
    new $P3963, "Undef"
  vivify_1816:
    find_lex $P3964, "$pasttype"
    unless_null $P3964, vivify_1817
    new $P3964, "Undef"
  vivify_1817:
    $P3963."pasttype"($P3964)
  if_3956_end:
.annotate 'line', 1046
    find_lex $P3979, "$/"
    find_lex $P3980, "$past"
    unless_null $P3980, vivify_1818
    new $P3980, "Undef"
  vivify_1818:
    $P3981 = $P3979."!make"($P3980)
.annotate 'line', 1035
    .return ($P3981)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("457_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_3983
    .param pmc param_3984
.annotate 'line', 1049
    .lex "self", param_3983
    .lex "$/", param_3984
.annotate 'line', 1050
    new $P3985, "Undef"
    .lex "$past", $P3985
.annotate 'line', 1052
    new $P3986, "Undef"
    .lex "$block", $P3986
.annotate 'line', 1050
    find_lex $P3987, "$/"
    unless_null $P3987, vivify_1819
    $P3987 = root_new ['parrot';'Hash']
  vivify_1819:
    set $P3988, $P3987["xblock"]
    unless_null $P3988, vivify_1820
    new $P3988, "Undef"
  vivify_1820:
    $P3989 = $P3988."ast"()
    store_lex "$past", $P3989
.annotate 'line', 1051
    find_lex $P3990, "$past"
    unless_null $P3990, vivify_1821
    new $P3990, "Undef"
  vivify_1821:
    $P3990."pasttype"("for")
.annotate 'line', 1052
    find_lex $P3991, "$past"
    unless_null $P3991, vivify_1822
    $P3991 = root_new ['parrot';'ResizablePMCArray']
  vivify_1822:
    set $P3992, $P3991[1]
    unless_null $P3992, vivify_1823
    new $P3992, "Undef"
  vivify_1823:
    store_lex "$block", $P3992
.annotate 'line', 1053
    find_lex $P3994, "$block"
    unless_null $P3994, vivify_1824
    new $P3994, "Undef"
  vivify_1824:
    $P3995 = $P3994."arity"()
    if $P3995, unless_3993_end
.annotate 'line', 1054
    find_lex $P3996, "$block"
    unless_null $P3996, vivify_1825
    $P3996 = root_new ['parrot';'ResizablePMCArray']
  vivify_1825:
    set $P3997, $P3996[0]
    unless_null $P3997, vivify_1826
    new $P3997, "Undef"
  vivify_1826:
    get_hll_global $P3998, "GLOBAL"
    nqp_get_package_through_who $P3999, $P3998, "PAST"
    get_who $P4000, $P3999
    set $P4001, $P4000["Var"]
    $P4002 = $P4001."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3997."push"($P4002)
.annotate 'line', 1055
    find_lex $P4003, "$block"
    unless_null $P4003, vivify_1827
    new $P4003, "Undef"
  vivify_1827:
    $P4003."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1056
    find_lex $P4004, "$block"
    unless_null $P4004, vivify_1828
    new $P4004, "Undef"
  vivify_1828:
    $P4004."arity"(1)
  unless_3993_end:
.annotate 'line', 1058
    find_lex $P4005, "$block"
    unless_null $P4005, vivify_1829
    new $P4005, "Undef"
  vivify_1829:
    $P4005."blocktype"("immediate")
.annotate 'line', 1059
    find_lex $P4006, "$/"
    find_lex $P4007, "$past"
    unless_null $P4007, vivify_1830
    new $P4007, "Undef"
  vivify_1830:
    $P4008 = $P4006."!make"($P4007)
.annotate 'line', 1049
    .return ($P4008)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("458_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4010
    .param pmc param_4011
.annotate 'line', 1062
    .lex "self", param_4010
    .lex "$/", param_4011
.annotate 'line', 1063
    new $P4012, "Undef"
    .lex "$block", $P4012
    find_lex $P4013, "$/"
    unless_null $P4013, vivify_1831
    $P4013 = root_new ['parrot';'Hash']
  vivify_1831:
    set $P4014, $P4013["block"]
    unless_null $P4014, vivify_1832
    new $P4014, "Undef"
  vivify_1832:
    $P4015 = $P4014."ast"()
    store_lex "$block", $P4015
.annotate 'line', 1064
    find_lex $P4016, "$/"
    unless_null $P4016, vivify_1833
    new $P4016, "Undef"
  vivify_1833:
    find_lex $P4017, "$block"
    unless_null $P4017, vivify_1834
    new $P4017, "Undef"
  vivify_1834:
    "push_block_handler"($P4016, $P4017)
.annotate 'line', 1065
    find_lex $P4018, "$?PACKAGE"
    get_who $P4019, $P4018
    set $P4020, $P4019["@BLOCK"]
    unless_null $P4020, vivify_1835
    $P4020 = root_new ['parrot';'ResizablePMCArray']
  vivify_1835:
    set $P4021, $P4020[0]
    unless_null $P4021, vivify_1836
    new $P4021, "Undef"
  vivify_1836:
    $P4022 = $P4021."handlers"()
    set $P4023, $P4022[0]
    unless_null $P4023, vivify_1837
    new $P4023, "Undef"
  vivify_1837:
    $P4023."handle_types_except"("CONTROL")
.annotate 'line', 1066
    find_lex $P4024, "$/"
    get_hll_global $P4025, "GLOBAL"
    nqp_get_package_through_who $P4026, $P4025, "PAST"
    get_who $P4027, $P4026
    set $P4028, $P4027["Stmts"]
    find_lex $P4029, "$/"
    unless_null $P4029, vivify_1838
    new $P4029, "Undef"
  vivify_1838:
    $P4030 = $P4028."new"($P4029 :named("node"))
    $P4031 = $P4024."!make"($P4030)
.annotate 'line', 1062
    .return ($P4031)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("459_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4033
    .param pmc param_4034
.annotate 'line', 1069
    .lex "self", param_4033
    .lex "$/", param_4034
.annotate 'line', 1070
    new $P4035, "Undef"
    .lex "$block", $P4035
    find_lex $P4036, "$/"
    unless_null $P4036, vivify_1839
    $P4036 = root_new ['parrot';'Hash']
  vivify_1839:
    set $P4037, $P4036["block"]
    unless_null $P4037, vivify_1840
    new $P4037, "Undef"
  vivify_1840:
    $P4038 = $P4037."ast"()
    store_lex "$block", $P4038
.annotate 'line', 1071
    find_lex $P4039, "$/"
    unless_null $P4039, vivify_1841
    new $P4039, "Undef"
  vivify_1841:
    find_lex $P4040, "$block"
    unless_null $P4040, vivify_1842
    new $P4040, "Undef"
  vivify_1842:
    "push_block_handler"($P4039, $P4040)
.annotate 'line', 1072
    find_lex $P4041, "$?PACKAGE"
    get_who $P4042, $P4041
    set $P4043, $P4042["@BLOCK"]
    unless_null $P4043, vivify_1843
    $P4043 = root_new ['parrot';'ResizablePMCArray']
  vivify_1843:
    set $P4044, $P4043[0]
    unless_null $P4044, vivify_1844
    new $P4044, "Undef"
  vivify_1844:
    $P4045 = $P4044."handlers"()
    set $P4046, $P4045[0]
    unless_null $P4046, vivify_1845
    new $P4046, "Undef"
  vivify_1845:
    $P4046."handle_types"("CONTROL")
.annotate 'line', 1073
    find_lex $P4047, "$/"
    get_hll_global $P4048, "GLOBAL"
    nqp_get_package_through_who $P4049, $P4048, "PAST"
    get_who $P4050, $P4049
    set $P4051, $P4050["Stmts"]
    find_lex $P4052, "$/"
    unless_null $P4052, vivify_1846
    new $P4052, "Undef"
  vivify_1846:
    $P4053 = $P4051."new"($P4052 :named("node"))
    $P4054 = $P4047."!make"($P4053)
.annotate 'line', 1069
    .return ($P4054)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("460_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4057
    .param pmc param_4058
.annotate 'line', 1113
    .lex "self", param_4057
    .lex "$/", param_4058
.annotate 'line', 1114
    find_lex $P4059, "$?PACKAGE"
    get_who $P4060, $P4059
    set $P4061, $P4060["@BLOCK"]
    unless_null $P4061, vivify_1847
    $P4061 = root_new ['parrot';'ResizablePMCArray']
  vivify_1847:
    set $P4062, $P4061[0]
    unless_null $P4062, vivify_1848
    new $P4062, "Undef"
  vivify_1848:
    find_lex $P4063, "$/"
    unless_null $P4063, vivify_1849
    $P4063 = root_new ['parrot';'Hash']
  vivify_1849:
    set $P4064, $P4063["blorst"]
    unless_null $P4064, vivify_1850
    new $P4064, "Undef"
  vivify_1850:
    $P4065 = $P4064."ast"()
    $P4062."push"($P4065)
.annotate 'line', 1115
    find_lex $P4066, "$/"
    get_hll_global $P4067, "GLOBAL"
    nqp_get_package_through_who $P4068, $P4067, "PAST"
    get_who $P4069, $P4068
    set $P4070, $P4069["Stmts"]
    $P4071 = $P4070."new"()
    $P4072 = $P4066."!make"($P4071)
.annotate 'line', 1113
    .return ($P4072)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("461_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4074
    .param pmc param_4075
.annotate 'line', 1118
    .lex "self", param_4074
    .lex "$/", param_4075
.annotate 'line', 1119
    new $P4076, "Undef"
    .lex "$past", $P4076
    find_lex $P4077, "$/"
    unless_null $P4077, vivify_1851
    $P4077 = root_new ['parrot';'Hash']
  vivify_1851:
    set $P4078, $P4077["blorst"]
    unless_null $P4078, vivify_1852
    new $P4078, "Undef"
  vivify_1852:
    $P4079 = $P4078."ast"()
    store_lex "$past", $P4079
.annotate 'line', 1120
    get_hll_global $P4081, "GLOBAL"
    nqp_get_package_through_who $P4082, $P4081, "PAST"
    get_who $P4083, $P4082
    set $P4084, $P4083["Block"]
    find_lex $P4085, "$past"
    unless_null $P4085, vivify_1853
    new $P4085, "Undef"
  vivify_1853:
    $P4086 = $P4084."ACCEPTS"($P4085)
    if $P4086, unless_4080_end
.annotate 'line', 1121
    get_hll_global $P4087, "GLOBAL"
    nqp_get_package_through_who $P4088, $P4087, "PAST"
    get_who $P4089, $P4088
    set $P4090, $P4089["Block"]
    find_lex $P4091, "$past"
    unless_null $P4091, vivify_1854
    new $P4091, "Undef"
  vivify_1854:
    find_lex $P4092, "$/"
    unless_null $P4092, vivify_1855
    new $P4092, "Undef"
  vivify_1855:
    $P4093 = $P4090."new"($P4091, "immediate" :named("blocktype"), $P4092 :named("node"))
    store_lex "$past", $P4093
  unless_4080_end:
.annotate 'line', 1123
    find_lex $P4095, "$past"
    unless_null $P4095, vivify_1856
    new $P4095, "Undef"
  vivify_1856:
    $P4096 = $P4095."handlers"()
    if $P4096, unless_4094_end
.annotate 'line', 1124
    find_lex $P4097, "$past"
    unless_null $P4097, vivify_1857
    new $P4097, "Undef"
  vivify_1857:
    get_hll_global $P4098, "GLOBAL"
    nqp_get_package_through_who $P4099, $P4098, "PAST"
    get_who $P4100, $P4099
    set $P4101, $P4100["Control"]
.annotate 'line', 1126
    get_hll_global $P4102, "GLOBAL"
    nqp_get_package_through_who $P4103, $P4102, "PAST"
    get_who $P4104, $P4103
    set $P4105, $P4104["Stmts"]
.annotate 'line', 1127
    get_hll_global $P4106, "GLOBAL"
    nqp_get_package_through_who $P4107, $P4106, "PAST"
    get_who $P4108, $P4107
    set $P4109, $P4108["Op"]
.annotate 'line', 1128
    get_hll_global $P4110, "GLOBAL"
    nqp_get_package_through_who $P4111, $P4110, "PAST"
    get_who $P4112, $P4111
    set $P4113, $P4112["Var"]
.annotate 'line', 1129
    get_hll_global $P4114, "GLOBAL"
    nqp_get_package_through_who $P4115, $P4114, "PAST"
    get_who $P4116, $P4115
    set $P4117, $P4116["Var"]
    $P4118 = $P4117."new"("register" :named("scope"), "exception" :named("name"))
    $P4119 = $P4113."new"($P4118, "handled", "keyed" :named("scope"))
.annotate 'line', 1128
    $P4120 = $P4109."new"($P4119, 1, "bind" :named("pasttype"))
.annotate 'line', 1127
    $P4121 = $P4105."new"($P4120)
.annotate 'line', 1126
    $P4122 = $P4101."new"($P4121, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1124
    new $P4123, "ResizablePMCArray"
    push $P4123, $P4122
    $P4097."handlers"($P4123)
  unless_4094_end:
.annotate 'line', 1138
    find_lex $P4124, "$/"
    find_lex $P4125, "$past"
    unless_null $P4125, vivify_1858
    new $P4125, "Undef"
  vivify_1858:
    $P4126 = $P4124."!make"($P4125)
.annotate 'line', 1118
    .return ($P4126)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("462_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4128
    .param pmc param_4129
.annotate 'line', 1141
    .lex "self", param_4128
    .lex "$/", param_4129
.annotate 'line', 1142
    find_lex $P4130, "$/"
.annotate 'line', 1143
    find_lex $P4133, "$/"
    unless_null $P4133, vivify_1859
    $P4133 = root_new ['parrot';'Hash']
  vivify_1859:
    set $P4134, $P4133["block"]
    unless_null $P4134, vivify_1860
    new $P4134, "Undef"
  vivify_1860:
    if $P4134, if_4132
.annotate 'line', 1144
    find_lex $P4139, "$/"
    unless_null $P4139, vivify_1861
    $P4139 = root_new ['parrot';'Hash']
  vivify_1861:
    set $P4140, $P4139["statement"]
    unless_null $P4140, vivify_1862
    new $P4140, "Undef"
  vivify_1862:
    $P4141 = $P4140."ast"()
    set $P4131, $P4141
.annotate 'line', 1143
    goto if_4132_end
  if_4132:
    find_lex $P4135, "$/"
    unless_null $P4135, vivify_1863
    $P4135 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P4136, $P4135["block"]
    unless_null $P4136, vivify_1864
    new $P4136, "Undef"
  vivify_1864:
    $P4137 = $P4136."ast"()
    $P4138 = "block_immediate"($P4137)
    set $P4131, $P4138
  if_4132_end:
    $P4142 = $P4130."!make"($P4131)
.annotate 'line', 1141
    .return ($P4142)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("463_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4144
    .param pmc param_4145
.annotate 'line', 1149
    .lex "self", param_4144
    .lex "$/", param_4145
    find_lex $P4146, "$/"
    find_lex $P4147, "$/"
    unless_null $P4147, vivify_1865
    $P4147 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P4148, $P4147["cond"]
    unless_null $P4148, vivify_1866
    new $P4148, "Undef"
  vivify_1866:
    $P4149 = $P4148."ast"()
    $P4150 = $P4146."!make"($P4149)
    .return ($P4150)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("464_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4152
    .param pmc param_4153
.annotate 'line', 1150
    .lex "self", param_4152
    .lex "$/", param_4153
    find_lex $P4154, "$/"
    find_lex $P4155, "$/"
    unless_null $P4155, vivify_1867
    $P4155 = root_new ['parrot';'Hash']
  vivify_1867:
    set $P4156, $P4155["cond"]
    unless_null $P4156, vivify_1868
    new $P4156, "Undef"
  vivify_1868:
    $P4157 = $P4156."ast"()
    $P4158 = $P4154."!make"($P4157)
    .return ($P4158)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("465_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4160
    .param pmc param_4161
.annotate 'line', 1152
    .lex "self", param_4160
    .lex "$/", param_4161
    find_lex $P4162, "$/"
    find_lex $P4163, "$/"
    unless_null $P4163, vivify_1869
    $P4163 = root_new ['parrot';'Hash']
  vivify_1869:
    set $P4164, $P4163["cond"]
    unless_null $P4164, vivify_1870
    new $P4164, "Undef"
  vivify_1870:
    $P4165 = $P4164."ast"()
    $P4166 = $P4162."!make"($P4165)
    .return ($P4166)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("466_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4168
    .param pmc param_4169
.annotate 'line', 1153
    .lex "self", param_4168
    .lex "$/", param_4169
    find_lex $P4170, "$/"
    find_lex $P4171, "$/"
    unless_null $P4171, vivify_1871
    $P4171 = root_new ['parrot';'Hash']
  vivify_1871:
    set $P4172, $P4171["cond"]
    unless_null $P4172, vivify_1872
    new $P4172, "Undef"
  vivify_1872:
    $P4173 = $P4172."ast"()
    $P4174 = $P4170."!make"($P4173)
    .return ($P4174)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("467_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4176
    .param pmc param_4177
.annotate 'line', 1157
    .lex "self", param_4176
    .lex "$/", param_4177
    find_lex $P4178, "$/"
    find_lex $P4179, "$/"
    unless_null $P4179, vivify_1873
    $P4179 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P4180, $P4179["fatarrow"]
    unless_null $P4180, vivify_1874
    new $P4180, "Undef"
  vivify_1874:
    $P4181 = $P4180."ast"()
    $P4182 = $P4178."!make"($P4181)
    .return ($P4182)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("468_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4184
    .param pmc param_4185
.annotate 'line', 1158
    .lex "self", param_4184
    .lex "$/", param_4185
    find_lex $P4186, "$/"
    find_lex $P4187, "$/"
    unless_null $P4187, vivify_1875
    $P4187 = root_new ['parrot';'Hash']
  vivify_1875:
    set $P4188, $P4187["colonpair"]
    unless_null $P4188, vivify_1876
    new $P4188, "Undef"
  vivify_1876:
    $P4189 = $P4188."ast"()
    $P4190 = $P4186."!make"($P4189)
    .return ($P4190)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("469_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4192
    .param pmc param_4193
.annotate 'line', 1159
    .lex "self", param_4192
    .lex "$/", param_4193
    find_lex $P4194, "$/"
    find_lex $P4195, "$/"
    unless_null $P4195, vivify_1877
    $P4195 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P4196, $P4195["variable"]
    unless_null $P4196, vivify_1878
    new $P4196, "Undef"
  vivify_1878:
    $P4197 = $P4196."ast"()
    $P4198 = $P4194."!make"($P4197)
    .return ($P4198)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("470_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4200
    .param pmc param_4201
.annotate 'line', 1160
    .lex "self", param_4200
    .lex "$/", param_4201
    find_lex $P4202, "$/"
    find_lex $P4203, "$/"
    unless_null $P4203, vivify_1879
    $P4203 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P4204, $P4203["package_declarator"]
    unless_null $P4204, vivify_1880
    new $P4204, "Undef"
  vivify_1880:
    $P4205 = $P4204."ast"()
    $P4206 = $P4202."!make"($P4205)
    .return ($P4206)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("471_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4208
    .param pmc param_4209
.annotate 'line', 1161
    .lex "self", param_4208
    .lex "$/", param_4209
    find_lex $P4210, "$/"
    find_lex $P4211, "$/"
    unless_null $P4211, vivify_1881
    $P4211 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P4212, $P4211["scope_declarator"]
    unless_null $P4212, vivify_1882
    new $P4212, "Undef"
  vivify_1882:
    $P4213 = $P4212."ast"()
    $P4214 = $P4210."!make"($P4213)
    .return ($P4214)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("472_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4216
    .param pmc param_4217
.annotate 'line', 1162
    .lex "self", param_4216
    .lex "$/", param_4217
    find_lex $P4218, "$/"
    find_lex $P4219, "$/"
    unless_null $P4219, vivify_1883
    $P4219 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P4220, $P4219["routine_declarator"]
    unless_null $P4220, vivify_1884
    new $P4220, "Undef"
  vivify_1884:
    $P4221 = $P4220."ast"()
    $P4222 = $P4218."!make"($P4221)
    .return ($P4222)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("473_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4224
    .param pmc param_4225
.annotate 'line', 1163
    .lex "self", param_4224
    .lex "$/", param_4225
    find_lex $P4226, "$/"
    find_lex $P4227, "$/"
    unless_null $P4227, vivify_1885
    $P4227 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P4228, $P4227["regex_declarator"]
    unless_null $P4228, vivify_1886
    new $P4228, "Undef"
  vivify_1886:
    $P4229 = $P4228."ast"()
    $P4230 = $P4226."!make"($P4229)
    .return ($P4230)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("474_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4232
    .param pmc param_4233
.annotate 'line', 1164
    .lex "self", param_4232
    .lex "$/", param_4233
    find_lex $P4234, "$/"
    find_lex $P4235, "$/"
    unless_null $P4235, vivify_1887
    $P4235 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P4236, $P4235["statement_prefix"]
    unless_null $P4236, vivify_1888
    new $P4236, "Undef"
  vivify_1888:
    $P4237 = $P4236."ast"()
    $P4238 = $P4234."!make"($P4237)
    .return ($P4238)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("475_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4240
    .param pmc param_4241
.annotate 'line', 1165
    .lex "self", param_4240
    .lex "$/", param_4241
    find_lex $P4242, "$/"
    find_lex $P4243, "$/"
    unless_null $P4243, vivify_1889
    $P4243 = root_new ['parrot';'Hash']
  vivify_1889:
    set $P4244, $P4243["pblock"]
    unless_null $P4244, vivify_1890
    new $P4244, "Undef"
  vivify_1890:
    $P4245 = $P4244."ast"()
    $P4246 = $P4242."!make"($P4245)
    .return ($P4246)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("476_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4248
    .param pmc param_4249
.annotate 'line', 1167
    .lex "self", param_4248
    .lex "$/", param_4249
.annotate 'line', 1168
    new $P4250, "Undef"
    .lex "$past", $P4250
    find_lex $P4251, "$/"
    unless_null $P4251, vivify_1891
    $P4251 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P4252, $P4251["val"]
    unless_null $P4252, vivify_1892
    new $P4252, "Undef"
  vivify_1892:
    $P4253 = $P4252."ast"()
    store_lex "$past", $P4253
.annotate 'line', 1169
    find_lex $P4254, "$past"
    unless_null $P4254, vivify_1893
    new $P4254, "Undef"
  vivify_1893:
    find_lex $P4255, "$/"
    unless_null $P4255, vivify_1894
    $P4255 = root_new ['parrot';'Hash']
  vivify_1894:
    set $P4256, $P4255["key"]
    unless_null $P4256, vivify_1895
    new $P4256, "Undef"
  vivify_1895:
    $P4257 = $P4256."Str"()
    $P4254."named"($P4257)
.annotate 'line', 1170
    find_lex $P4258, "$/"
    find_lex $P4259, "$past"
    unless_null $P4259, vivify_1896
    new $P4259, "Undef"
  vivify_1896:
    $P4260 = $P4258."!make"($P4259)
.annotate 'line', 1167
    .return ($P4260)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("477_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4262
    .param pmc param_4263
.annotate 'line', 1173
    .lex "self", param_4262
    .lex "$/", param_4263
.annotate 'line', 1174
    new $P4264, "Undef"
    .lex "$past", $P4264
.annotate 'line', 1175
    find_lex $P4267, "$/"
    unless_null $P4267, vivify_1897
    $P4267 = root_new ['parrot';'Hash']
  vivify_1897:
    set $P4268, $P4267["circumfix"]
    unless_null $P4268, vivify_1898
    new $P4268, "Undef"
  vivify_1898:
    if $P4268, if_4266
.annotate 'line', 1176
    get_hll_global $P4273, "GLOBAL"
    nqp_get_package_through_who $P4274, $P4273, "PAST"
    get_who $P4275, $P4274
    set $P4276, $P4275["Val"]
    find_lex $P4277, "$/"
    unless_null $P4277, vivify_1899
    $P4277 = root_new ['parrot';'Hash']
  vivify_1899:
    set $P4278, $P4277["not"]
    unless_null $P4278, vivify_1900
    new $P4278, "Undef"
  vivify_1900:
    isfalse $I4279, $P4278
    $P4280 = $P4276."new"($I4279 :named("value"))
    set $P4265, $P4280
.annotate 'line', 1175
    goto if_4266_end
  if_4266:
    find_lex $P4269, "$/"
    unless_null $P4269, vivify_1901
    $P4269 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P4270, $P4269["circumfix"]
    unless_null $P4270, vivify_1902
    $P4270 = root_new ['parrot';'ResizablePMCArray']
  vivify_1902:
    set $P4271, $P4270[0]
    unless_null $P4271, vivify_1903
    new $P4271, "Undef"
  vivify_1903:
    $P4272 = $P4271."ast"()
    set $P4265, $P4272
  if_4266_end:
    store_lex "$past", $P4265
.annotate 'line', 1177
    find_lex $P4281, "$past"
    unless_null $P4281, vivify_1904
    new $P4281, "Undef"
  vivify_1904:
    find_lex $P4282, "$/"
    unless_null $P4282, vivify_1905
    $P4282 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P4283, $P4282["identifier"]
    unless_null $P4283, vivify_1906
    new $P4283, "Undef"
  vivify_1906:
    set $S4284, $P4283
    $P4281."named"($S4284)
.annotate 'line', 1178
    find_lex $P4285, "$/"
    find_lex $P4286, "$past"
    unless_null $P4286, vivify_1907
    new $P4286, "Undef"
  vivify_1907:
    $P4287 = $P4285."!make"($P4286)
.annotate 'line', 1173
    .return ($P4287)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("478_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4289
    .param pmc param_4290
.annotate 'line', 1181
    .const 'Sub' $P4306 = "479_1303923618.727" 
    capture_lex $P4306
    .lex "self", param_4289
    .lex "$/", param_4290
.annotate 'line', 1182
    new $P4291, "Undef"
    .lex "$past", $P4291
.annotate 'line', 1181
    find_lex $P4292, "$past"
    unless_null $P4292, vivify_1908
    new $P4292, "Undef"
  vivify_1908:
.annotate 'line', 1183
    find_lex $P4294, "$/"
    unless_null $P4294, vivify_1909
    $P4294 = root_new ['parrot';'Hash']
  vivify_1909:
    set $P4295, $P4294["postcircumfix"]
    unless_null $P4295, vivify_1910
    new $P4295, "Undef"
  vivify_1910:
    if $P4295, if_4293
.annotate 'line', 1187
    .const 'Sub' $P4306 = "479_1303923618.727" 
    capture_lex $P4306
    $P4306()
    goto if_4293_end
  if_4293:
.annotate 'line', 1184
    find_lex $P4296, "$/"
    unless_null $P4296, vivify_1967
    $P4296 = root_new ['parrot';'Hash']
  vivify_1967:
    set $P4297, $P4296["postcircumfix"]
    unless_null $P4297, vivify_1968
    new $P4297, "Undef"
  vivify_1968:
    $P4298 = $P4297."ast"()
    store_lex "$past", $P4298
.annotate 'line', 1185
    find_lex $P4299, "$past"
    unless_null $P4299, vivify_1969
    new $P4299, "Undef"
  vivify_1969:
    get_hll_global $P4300, "GLOBAL"
    nqp_get_package_through_who $P4301, $P4300, "PAST"
    get_who $P4302, $P4301
    set $P4303, $P4302["Var"]
    $P4304 = $P4303."new"("$/" :named("name"))
    $P4299."unshift"($P4304)
  if_4293_end:
.annotate 'line', 1246
    find_lex $P4488, "$/"
    find_lex $P4489, "$past"
    unless_null $P4489, vivify_1970
    new $P4489, "Undef"
  vivify_1970:
    $P4490 = $P4488."!make"($P4489)
.annotate 'line', 1181
    .return ($P4490)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4305"  :anon :subid("479_1303923618.727") :outer("478_1303923618.727")
.annotate 'line', 1187
    .const 'Sub' $P4382 = "481_1303923618.727" 
    capture_lex $P4382
    .const 'Sub' $P4341 = "480_1303923618.727" 
    capture_lex $P4341
.annotate 'line', 1188
    $P4307 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4307
    get_hll_global $P4308, "GLOBAL"
    nqp_get_package_through_who $P4309, $P4308, "NQP"
    get_who $P4310, $P4309
    set $P4311, $P4310["Compiler"]
    find_lex $P4312, "$/"
    unless_null $P4312, vivify_1911
    new $P4312, "Undef"
  vivify_1911:
    set $S4313, $P4312
    $P4314 = $P4311."parse_name"($S4313)
    store_lex "@name", $P4314
.annotate 'line', 1189
    find_lex $P4317, "@name"
    unless_null $P4317, vivify_1912
    $P4317 = root_new ['parrot';'ResizablePMCArray']
  vivify_1912:
    set $N4318, $P4317
    isgt $I4319, $N4318, 1.0
    if $I4319, if_4316
.annotate 'line', 1196
    find_lex $P4335, "$/"
    unless_null $P4335, vivify_1913
    $P4335 = root_new ['parrot';'Hash']
  vivify_1913:
    set $P4336, $P4335["twigil"]
    unless_null $P4336, vivify_1914
    $P4336 = root_new ['parrot';'ResizablePMCArray']
  vivify_1914:
    set $P4337, $P4336[0]
    unless_null $P4337, vivify_1915
    new $P4337, "Undef"
  vivify_1915:
    set $S4338, $P4337
    iseq $I4339, $S4338, "*"
    if $I4339, if_4334
.annotate 'line', 1207
    find_lex $P4376, "$/"
    unless_null $P4376, vivify_1916
    $P4376 = root_new ['parrot';'Hash']
  vivify_1916:
    set $P4377, $P4376["twigil"]
    unless_null $P4377, vivify_1917
    $P4377 = root_new ['parrot';'ResizablePMCArray']
  vivify_1917:
    set $P4378, $P4377[0]
    unless_null $P4378, vivify_1918
    new $P4378, "Undef"
  vivify_1918:
    set $S4379, $P4378
    iseq $I4380, $S4379, "!"
    if $I4380, if_4375
.annotate 'line', 1236
    find_lex $P4465, "@name"
    unless_null $P4465, vivify_1919
    $P4465 = root_new ['parrot';'ResizablePMCArray']
  vivify_1919:
    set $P4466, $P4465[0]
    unless_null $P4466, vivify_1920
    new $P4466, "Undef"
  vivify_1920:
    set $S4467, $P4466
    $P4468 = "is_package"($S4467)
    if $P4468, if_4464
.annotate 'line', 1241
    get_hll_global $P4477, "GLOBAL"
    nqp_get_package_through_who $P4478, $P4477, "PAST"
    get_who $P4479, $P4478
    set $P4480, $P4479["Var"]
.annotate 'line', 1242
    find_lex $P4481, "@name"
    unless_null $P4481, vivify_1921
    $P4481 = root_new ['parrot';'ResizablePMCArray']
  vivify_1921:
    $P4482 = $P4481."pop"()
    set $S4483, $P4482
    find_lex $P4484, "$/"
    unless_null $P4484, vivify_1922
    $P4484 = root_new ['parrot';'Hash']
  vivify_1922:
    set $P4485, $P4484["sigil"]
    unless_null $P4485, vivify_1923
    new $P4485, "Undef"
  vivify_1923:
    $P4486 = "vivitype"($P4485)
    $P4487 = $P4480."new"($S4483 :named("name"), $P4486 :named("viviself"))
.annotate 'line', 1241
    store_lex "$past", $P4487
.annotate 'line', 1240
    set $P4463, $P4487
.annotate 'line', 1236
    goto if_4464_end
  if_4464:
.annotate 'line', 1237
    find_lex $P4469, "@name"
    unless_null $P4469, vivify_1924
    $P4469 = root_new ['parrot';'ResizablePMCArray']
  vivify_1924:
    find_lex $P4470, "$/"
    unless_null $P4470, vivify_1925
    new $P4470, "Undef"
  vivify_1925:
    $P4471 = "lexical_package_lookup"($P4469, $P4470)
    store_lex "$past", $P4471
.annotate 'line', 1238
    find_lex $P4472, "$past"
    unless_null $P4472, vivify_1926
    new $P4472, "Undef"
  vivify_1926:
    find_lex $P4473, "$/"
    unless_null $P4473, vivify_1927
    $P4473 = root_new ['parrot';'Hash']
  vivify_1927:
    set $P4474, $P4473["sigil"]
    unless_null $P4474, vivify_1928
    new $P4474, "Undef"
  vivify_1928:
    $P4475 = "vivitype"($P4474)
    $P4476 = $P4472."viviself"($P4475)
.annotate 'line', 1236
    set $P4463, $P4476
  if_4464_end:
    set $P4374, $P4463
.annotate 'line', 1207
    goto if_4375_end
  if_4375:
    .const 'Sub' $P4382 = "481_1303923618.727" 
    capture_lex $P4382
    $P4462 = $P4382()
    set $P4374, $P4462
  if_4375_end:
    set $P4333, $P4374
.annotate 'line', 1196
    goto if_4334_end
  if_4334:
    .const 'Sub' $P4341 = "480_1303923618.727" 
    capture_lex $P4341
    $P4373 = $P4341()
    set $P4333, $P4373
  if_4334_end:
    set $P4315, $P4333
.annotate 'line', 1189
    goto if_4316_end
  if_4316:
.annotate 'line', 1190
    find_lex $P4321, "$/"
    unless_null $P4321, vivify_1959
    $P4321 = root_new ['parrot';'Hash']
  vivify_1959:
    set $P4322, $P4321["twigil"]
    unless_null $P4322, vivify_1960
    new $P4322, "Undef"
  vivify_1960:
    unless $P4322, if_4320_end
.annotate 'line', 1191
    find_lex $P4323, "$/"
    unless_null $P4323, vivify_1961
    new $P4323, "Undef"
  vivify_1961:
    $P4324 = $P4323."CURSOR"()
    $P4324."panic"("Twigil not allowed on multi-part name")
  if_4320_end:
.annotate 'line', 1193
    find_lex $P4325, "@name"
    unless_null $P4325, vivify_1962
    $P4325 = root_new ['parrot';'ResizablePMCArray']
  vivify_1962:
    find_lex $P4326, "$/"
    unless_null $P4326, vivify_1963
    new $P4326, "Undef"
  vivify_1963:
    $P4327 = "lexical_package_lookup"($P4325, $P4326)
    store_lex "$past", $P4327
.annotate 'line', 1194
    find_lex $P4328, "$past"
    unless_null $P4328, vivify_1964
    new $P4328, "Undef"
  vivify_1964:
    find_lex $P4329, "$/"
    unless_null $P4329, vivify_1965
    $P4329 = root_new ['parrot';'Hash']
  vivify_1965:
    set $P4330, $P4329["sigil"]
    unless_null $P4330, vivify_1966
    new $P4330, "Undef"
  vivify_1966:
    $P4331 = "vivitype"($P4330)
    $P4332 = $P4328."viviself"($P4331)
.annotate 'line', 1189
    set $P4315, $P4332
  if_4316_end:
.annotate 'line', 1187
    .return ($P4315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4381"  :anon :subid("481_1303923618.727") :outer("479_1303923618.727")
.annotate 'line', 1207
    .const 'Sub' $P4413 = "482_1303923618.727" 
    capture_lex $P4413
.annotate 'line', 1209
    new $P4383, "Undef"
    .lex "$name", $P4383
    find_lex $P4384, "@name"
    unless_null $P4384, vivify_1929
    $P4384 = root_new ['parrot';'ResizablePMCArray']
  vivify_1929:
    $P4385 = $P4384."pop"()
    set $S4386, $P4385
    new $P4387, 'String'
    set $P4387, $S4386
    store_lex "$name", $P4387
.annotate 'line', 1210
    get_hll_global $P4388, "GLOBAL"
    nqp_get_package_through_who $P4389, $P4388, "PAST"
    get_who $P4390, $P4389
    set $P4391, $P4390["Var"]
    find_lex $P4392, "$name"
    unless_null $P4392, vivify_1930
    new $P4392, "Undef"
  vivify_1930:
.annotate 'line', 1212
    find_lex $P4393, "$/"
    unless_null $P4393, vivify_1931
    $P4393 = root_new ['parrot';'Hash']
  vivify_1931:
    set $P4394, $P4393["sigil"]
    unless_null $P4394, vivify_1932
    new $P4394, "Undef"
  vivify_1932:
    $P4395 = "vivitype"($P4394)
.annotate 'line', 1213
    get_hll_global $P4396, "GLOBAL"
    nqp_get_package_through_who $P4397, $P4396, "PAST"
    get_who $P4398, $P4397
    set $P4399, $P4398["Var"]
    $P4400 = $P4399."new"("self" :named("name"))
.annotate 'line', 1214
    get_hll_global $P4401, "GLOBAL"
    nqp_get_package_through_who $P4402, $P4401, "PAST"
    get_who $P4403, $P4402
    set $P4404, $P4403["Var"]
    $P4405 = $P4404."new"("$?CLASS" :named("name"))
    $P4406 = $P4391."new"($P4400, $P4405, $P4392 :named("name"), "attribute_6model" :named("scope"), $P4395 :named("viviself"))
.annotate 'line', 1210
    store_lex "$past", $P4406
.annotate 'line', 1218
    find_dynamic_lex $P4411, "$*IN_DECL"
    unless_null $P4411, vivify_1933
    get_hll_global $P4409, "GLOBAL"
    get_who $P4410, $P4409
    set $P4411, $P4410["$IN_DECL"]
    unless_null $P4411, vivify_1934
    die "Contextual $*IN_DECL not found"
  vivify_1934:
  vivify_1933:
    unless $P4411, unless_4408
    set $P4407, $P4411
    goto unless_4408_end
  unless_4408:
    .const 'Sub' $P4413 = "482_1303923618.727" 
    capture_lex $P4413
    $P4461 = $P4413()
    set $P4407, $P4461
  unless_4408_end:
.annotate 'line', 1207
    .return ($P4407)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4412"  :anon :subid("482_1303923618.727") :outer("481_1303923618.727")
.annotate 'line', 1218
    .const 'Sub' $P4428 = "483_1303923618.727" 
    capture_lex $P4428
.annotate 'line', 1219
    new $P4414, "Undef"
    .lex "$attr", $P4414
.annotate 'line', 1218
    find_lex $P4415, "$attr"
    unless_null $P4415, vivify_1935
    new $P4415, "Undef"
  vivify_1935:
.annotate 'line', 1220
    find_dynamic_lex $P4419, "$*PACKAGE"
    unless_null $P4419, vivify_1936
    get_hll_global $P4417, "GLOBAL"
    get_who $P4418, $P4417
    set $P4419, $P4418["$PACKAGE"]
    unless_null $P4419, vivify_1937
    die "Contextual $*PACKAGE not found"
  vivify_1937:
  vivify_1936:
    get_how $P4420, $P4419
    find_dynamic_lex $P4423, "$*PACKAGE"
    unless_null $P4423, vivify_1938
    get_hll_global $P4421, "GLOBAL"
    get_who $P4422, $P4421
    set $P4423, $P4422["$PACKAGE"]
    unless_null $P4423, vivify_1939
    die "Contextual $*PACKAGE not found"
  vivify_1939:
  vivify_1938:
    $P4424 = $P4420."attributes"($P4423, 1 :named("local"))
    defined $I4425, $P4424
    unless $I4425, for_undef_1940
    iter $P4416, $P4424
    new $P4440, 'ExceptionHandler'
    set_label $P4440, loop4439_handler
    $P4440."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4440
  loop4439_test:
    unless $P4416, loop4439_done
    shift $P4426, $P4416
  loop4439_redo:
    .const 'Sub' $P4428 = "483_1303923618.727" 
    capture_lex $P4428
    $P4428($P4426)
  loop4439_next:
    goto loop4439_test
  loop4439_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4441, exception, 'type'
    eq $P4441, .CONTROL_LOOP_NEXT, loop4439_next
    eq $P4441, .CONTROL_LOOP_REDO, loop4439_redo
  loop4439_done:
    pop_eh 
  for_undef_1940:
.annotate 'line', 1226
    find_lex $P4444, "$attr"
    unless_null $P4444, vivify_1944
    new $P4444, "Undef"
  vivify_1944:
    defined $I4445, $P4444
    if $I4445, if_4443
.annotate 'line', 1232
    find_lex $P4454, "$/"
    unless_null $P4454, vivify_1945
    new $P4454, "Undef"
  vivify_1945:
    $P4455 = $P4454."CURSOR"()
    new $P4456, 'String'
    set $P4456, "Attribute '"
    find_lex $P4457, "$name"
    unless_null $P4457, vivify_1946
    new $P4457, "Undef"
  vivify_1946:
    concat $P4458, $P4456, $P4457
    concat $P4459, $P4458, "' not declared"
    $P4460 = $P4455."panic"($P4459)
.annotate 'line', 1231
    set $P4442, $P4460
.annotate 'line', 1226
    goto if_4443_end
  if_4443:
.annotate 'line', 1227
    find_lex $P4448, "$attr"
    unless_null $P4448, vivify_1947
    new $P4448, "Undef"
  vivify_1947:
    can $I4449, $P4448, "type"
    if $I4449, if_4447
    new $P4446, 'Integer'
    set $P4446, $I4449
    goto if_4447_end
  if_4447:
.annotate 'line', 1228
    find_lex $P4450, "$past"
    unless_null $P4450, vivify_1948
    new $P4450, "Undef"
  vivify_1948:
    find_lex $P4451, "$attr"
    unless_null $P4451, vivify_1949
    new $P4451, "Undef"
  vivify_1949:
    $P4452 = $P4451."type"()
    $P4453 = $P4450."type"($P4452)
.annotate 'line', 1227
    set $P4446, $P4453
  if_4447_end:
.annotate 'line', 1226
    set $P4442, $P4446
  if_4443_end:
.annotate 'line', 1218
    .return ($P4442)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4427"  :anon :subid("483_1303923618.727") :outer("482_1303923618.727")
    .param pmc param_4429
.annotate 'line', 1220
    .lex "$_", param_4429
.annotate 'line', 1221
    find_lex $P4432, "$_"
    unless_null $P4432, vivify_1941
    new $P4432, "Undef"
  vivify_1941:
    $S4433 = $P4432."name"()
    find_lex $P4434, "$name"
    unless_null $P4434, vivify_1942
    new $P4434, "Undef"
  vivify_1942:
    set $S4435, $P4434
    iseq $I4436, $S4433, $S4435
    if $I4436, if_4431
    new $P4430, 'Integer'
    set $P4430, $I4436
    goto if_4431_end
  if_4431:
.annotate 'line', 1222
    find_lex $P4437, "$_"
    unless_null $P4437, vivify_1943
    new $P4437, "Undef"
  vivify_1943:
    store_lex "$attr", $P4437
.annotate 'line', 1223
    set $I4438, .CONTROL_LOOP_LAST
    die 0, $I4438
  if_4431_end:
.annotate 'line', 1220
    .return ($P4430)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4340"  :anon :subid("480_1303923618.727") :outer("479_1303923618.727")
.annotate 'line', 1197
    new $P4342, "Undef"
    .lex "$global_fallback", $P4342
    find_lex $P4343, "$/"
    unless_null $P4343, vivify_1950
    $P4343 = root_new ['parrot';'Hash']
  vivify_1950:
    set $P4344, $P4343["sigil"]
    unless_null $P4344, vivify_1951
    new $P4344, "Undef"
  vivify_1951:
    set $S4345, $P4344
    new $P4346, 'String'
    set $P4346, $S4345
    find_lex $P4347, "$/"
    unless_null $P4347, vivify_1952
    $P4347 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P4348, $P4347["desigilname"]
    unless_null $P4348, vivify_1953
    new $P4348, "Undef"
  vivify_1953:
    concat $P4349, $P4346, $P4348
    new $P4350, "ResizablePMCArray"
    push $P4350, "GLOBAL"
    push $P4350, $P4349
    find_lex $P4351, "$/"
    unless_null $P4351, vivify_1954
    new $P4351, "Undef"
  vivify_1954:
    $P4352 = "lexical_package_lookup"($P4350, $P4351)
    store_lex "$global_fallback", $P4352
.annotate 'line', 1198
    find_lex $P4353, "$global_fallback"
    unless_null $P4353, vivify_1955
    new $P4353, "Undef"
  vivify_1955:
    get_hll_global $P4354, "GLOBAL"
    nqp_get_package_through_who $P4355, $P4354, "PAST"
    get_who $P4356, $P4355
    set $P4357, $P4356["Op"]
.annotate 'line', 1199
    new $P4358, "String"
    assign $P4358, "Contextual "
    find_lex $P4359, "$/"
    unless_null $P4359, vivify_1956
    new $P4359, "Undef"
  vivify_1956:
    set $S4360, $P4359
    concat $P4361, $P4358, $S4360
    concat $P4362, $P4361, " not found"
    $P4363 = $P4357."new"($P4362, "die" :named("pirop"))
.annotate 'line', 1198
    $P4353."viviself"($P4363)
.annotate 'line', 1202
    get_hll_global $P4364, "GLOBAL"
    nqp_get_package_through_who $P4365, $P4364, "PAST"
    get_who $P4366, $P4365
    set $P4367, $P4366["Var"]
.annotate 'line', 1203
    find_lex $P4368, "@name"
    unless_null $P4368, vivify_1957
    $P4368 = root_new ['parrot';'ResizablePMCArray']
  vivify_1957:
    $P4369 = $P4368."pop"()
    set $S4370, $P4369
    find_lex $P4371, "$global_fallback"
    unless_null $P4371, vivify_1958
    new $P4371, "Undef"
  vivify_1958:
    $P4372 = $P4367."new"($S4370 :named("name"), "contextual" :named("scope"), $P4371 :named("viviself"))
.annotate 'line', 1202
    store_lex "$past", $P4372
.annotate 'line', 1196
    .return ($P4372)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("484_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4492
    .param pmc param_4493
.annotate 'line', 1249
    .lex "self", param_4492
    .lex "$/", param_4493
    find_lex $P4494, "$/"
    find_lex $P4495, "$/"
    unless_null $P4495, vivify_1971
    $P4495 = root_new ['parrot';'Hash']
  vivify_1971:
    set $P4496, $P4495["package_def"]
    unless_null $P4496, vivify_1972
    new $P4496, "Undef"
  vivify_1972:
    $P4497 = $P4496."ast"()
    $P4498 = $P4494."!make"($P4497)
    .return ($P4498)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("485_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4500
    .param pmc param_4501
.annotate 'line', 1250
    .lex "self", param_4500
    .lex "$/", param_4501
    find_lex $P4502, "$/"
    find_lex $P4503, "$/"
    unless_null $P4503, vivify_1973
    $P4503 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P4504, $P4503["package_def"]
    unless_null $P4504, vivify_1974
    new $P4504, "Undef"
  vivify_1974:
    $P4505 = $P4504."ast"()
    $P4506 = $P4502."!make"($P4505)
    .return ($P4506)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("486_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4508
    .param pmc param_4509
.annotate 'line', 1251
    .lex "self", param_4508
    .lex "$/", param_4509
    find_lex $P4510, "$/"
    find_lex $P4511, "$/"
    unless_null $P4511, vivify_1975
    $P4511 = root_new ['parrot';'Hash']
  vivify_1975:
    set $P4512, $P4511["package_def"]
    unless_null $P4512, vivify_1976
    new $P4512, "Undef"
  vivify_1976:
    $P4513 = $P4512."ast"()
    $P4514 = $P4510."!make"($P4513)
    .return ($P4514)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("487_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4516
    .param pmc param_4517
.annotate 'line', 1252
    .lex "self", param_4516
    .lex "$/", param_4517
    find_lex $P4518, "$/"
    find_lex $P4519, "$/"
    unless_null $P4519, vivify_1977
    $P4519 = root_new ['parrot';'Hash']
  vivify_1977:
    set $P4520, $P4519["package_def"]
    unless_null $P4520, vivify_1978
    new $P4520, "Undef"
  vivify_1978:
    $P4521 = $P4520."ast"()
    $P4522 = $P4518."!make"($P4521)
    .return ($P4522)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("488_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4524
    .param pmc param_4525
.annotate 'line', 1253
    .lex "self", param_4524
    .lex "$/", param_4525
    find_lex $P4526, "$/"
    find_lex $P4527, "$/"
    unless_null $P4527, vivify_1979
    $P4527 = root_new ['parrot';'Hash']
  vivify_1979:
    set $P4528, $P4527["package_def"]
    unless_null $P4528, vivify_1980
    new $P4528, "Undef"
  vivify_1980:
    $P4529 = $P4528."ast"()
    $P4530 = $P4526."!make"($P4529)
    .return ($P4530)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("489_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4532
    .param pmc param_4533
.annotate 'line', 1254
    .lex "self", param_4532
    .lex "$/", param_4533
    find_lex $P4534, "$/"
    find_lex $P4535, "$/"
    unless_null $P4535, vivify_1981
    $P4535 = root_new ['parrot';'Hash']
  vivify_1981:
    set $P4536, $P4535["package_def"]
    unless_null $P4536, vivify_1982
    new $P4536, "Undef"
  vivify_1982:
    $P4537 = $P4536."ast"()
    $P4538 = $P4534."!make"($P4537)
    .return ($P4538)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("490_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4540
    .param pmc param_4541
.annotate 'line', 1256
    .const 'Sub' $P4768 = "494_1303923618.727" 
    capture_lex $P4768
    .const 'Sub' $P4738 = "493_1303923618.727" 
    capture_lex $P4738
    .const 'Sub' $P4691 = "491_1303923618.727" 
    capture_lex $P4691
    .lex "self", param_4540
    .lex "$/", param_4541
.annotate 'line', 1258
    $P4542 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4542
.annotate 'line', 1259
    new $P4543, "Undef"
    .lex "$name", $P4543
.annotate 'line', 1260
    new $P4544, "Undef"
    .lex "$how", $P4544
.annotate 'line', 1263
    new $P4545, "Undef"
    .lex "$past", $P4545
.annotate 'line', 1258
    find_lex $P4546, "$/"
    unless_null $P4546, vivify_1983
    $P4546 = root_new ['parrot';'Hash']
  vivify_1983:
    set $P4547, $P4546["name"]
    unless_null $P4547, vivify_1984
    $P4547 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P4548, $P4547["identifier"]
    unless_null $P4548, vivify_1985
    new $P4548, "Undef"
  vivify_1985:
    clone $P4549, $P4548
    store_lex "@ns", $P4549
.annotate 'line', 1259
    find_lex $P4550, "@ns"
    unless_null $P4550, vivify_1986
    $P4550 = root_new ['parrot';'ResizablePMCArray']
  vivify_1986:
    $P4551 = $P4550."pop"()
    set $S4552, $P4551
    new $P4553, 'String'
    set $P4553, $S4552
    store_lex "$name", $P4553
.annotate 'line', 1260
    find_dynamic_lex $P4556, "$*PKGDECL"
    unless_null $P4556, vivify_1987
    get_hll_global $P4554, "GLOBAL"
    get_who $P4555, $P4554
    set $P4556, $P4555["$PKGDECL"]
    unless_null $P4556, vivify_1988
    die "Contextual $*PKGDECL not found"
  vivify_1988:
  vivify_1987:
    find_dynamic_lex $P4559, "%*HOW"
    unless_null $P4559, vivify_1989
    get_hll_global $P4557, "GLOBAL"
    get_who $P4558, $P4557
    set $P4559, $P4558["%HOW"]
    unless_null $P4559, vivify_1990
    die "Contextual %*HOW not found"
  vivify_1990:
  vivify_1989:
    set $P4560, $P4559[$P4556]
    unless_null $P4560, vivify_1991
    new $P4560, "Undef"
  vivify_1991:
    store_lex "$how", $P4560
.annotate 'line', 1263
    find_lex $P4563, "$/"
    unless_null $P4563, vivify_1992
    $P4563 = root_new ['parrot';'Hash']
  vivify_1992:
    set $P4564, $P4563["block"]
    unless_null $P4564, vivify_1993
    new $P4564, "Undef"
  vivify_1993:
    if $P4564, if_4562
    find_lex $P4568, "$/"
    unless_null $P4568, vivify_1994
    $P4568 = root_new ['parrot';'Hash']
  vivify_1994:
    set $P4569, $P4568["comp_unit"]
    unless_null $P4569, vivify_1995
    new $P4569, "Undef"
  vivify_1995:
    $P4570 = $P4569."ast"()
    set $P4561, $P4570
    goto if_4562_end
  if_4562:
    find_lex $P4565, "$/"
    unless_null $P4565, vivify_1996
    $P4565 = root_new ['parrot';'Hash']
  vivify_1996:
    set $P4566, $P4565["block"]
    unless_null $P4566, vivify_1997
    new $P4566, "Undef"
  vivify_1997:
    $P4567 = $P4566."ast"()
    set $P4561, $P4567
  if_4562_end:
    store_lex "$past", $P4561
.annotate 'line', 1264
    find_dynamic_lex $P4576, "$*SCOPE"
    unless_null $P4576, vivify_1998
    get_hll_global $P4574, "GLOBAL"
    get_who $P4575, $P4574
    set $P4576, $P4575["$SCOPE"]
    unless_null $P4576, vivify_1999
    die "Contextual $*SCOPE not found"
  vivify_1999:
  vivify_1998:
    set $S4577, $P4576
    iseq $I4578, $S4577, "our"
    unless $I4578, unless_4573
    new $P4572, 'Integer'
    set $P4572, $I4578
    goto unless_4573_end
  unless_4573:
    find_dynamic_lex $P4581, "$*SCOPE"
    unless_null $P4581, vivify_2000
    get_hll_global $P4579, "GLOBAL"
    get_who $P4580, $P4579
    set $P4581, $P4580["$SCOPE"]
    unless_null $P4581, vivify_2001
    die "Contextual $*SCOPE not found"
  vivify_2001:
  vivify_2000:
    set $S4582, $P4581
    iseq $I4583, $S4582, ""
    new $P4572, 'Integer'
    set $P4572, $I4583
  unless_4573_end:
    unless $P4572, if_4571_end
.annotate 'line', 1265
    find_lex $P4584, "$past"
    unless_null $P4584, vivify_2002
    new $P4584, "Undef"
  vivify_2002:
    find_lex $P4585, "$/"
    unless_null $P4585, vivify_2003
    $P4585 = root_new ['parrot';'Hash']
  vivify_2003:
    set $P4586, $P4585["name"]
    unless_null $P4586, vivify_2004
    $P4586 = root_new ['parrot';'Hash']
  vivify_2004:
    set $P4587, $P4586["identifier"]
    unless_null $P4587, vivify_2005
    new $P4587, "Undef"
  vivify_2005:
    $P4584."namespace"($P4587)
  if_4571_end:
.annotate 'line', 1269
    find_dynamic_lex $P4590, "$*PACKAGE-SETUP"
    unless_null $P4590, vivify_2006
    get_hll_global $P4588, "GLOBAL"
    get_who $P4589, $P4588
    set $P4590, $P4589["$PACKAGE-SETUP"]
    unless_null $P4590, vivify_2007
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2007:
  vivify_2006:
    get_hll_global $P4591, "GLOBAL"
    nqp_get_package_through_who $P4592, $P4591, "PAST"
    get_who $P4593, $P4592
    set $P4594, $P4593["Stmts"]
.annotate 'line', 1270
    get_hll_global $P4595, "GLOBAL"
    nqp_get_package_through_who $P4596, $P4595, "PAST"
    get_who $P4597, $P4596
    set $P4598, $P4597["Op"]
.annotate 'line', 1271
    get_hll_global $P4599, "GLOBAL"
    nqp_get_package_through_who $P4600, $P4599, "PAST"
    get_who $P4601, $P4600
    set $P4602, $P4601["Var"]
    $P4603 = $P4602."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1272
    find_dynamic_lex $P4606, "$*SC"
    unless_null $P4606, vivify_2008
    get_hll_global $P4604, "GLOBAL"
    get_who $P4605, $P4604
    set $P4606, $P4605["$SC"]
    unless_null $P4606, vivify_2009
    die "Contextual $*SC not found"
  vivify_2009:
  vivify_2008:
    find_dynamic_lex $P4609, "$*PACKAGE"
    unless_null $P4609, vivify_2010
    get_hll_global $P4607, "GLOBAL"
    get_who $P4608, $P4607
    set $P4609, $P4608["$PACKAGE"]
    unless_null $P4609, vivify_2011
    die "Contextual $*PACKAGE not found"
  vivify_2011:
  vivify_2010:
    $P4610 = $P4606."get_slot_past_for_object"($P4609)
    $P4611 = $P4598."new"($P4603, $P4610, "bind" :named("pasttype"))
.annotate 'line', 1270
    $P4612 = $P4594."new"($P4611)
.annotate 'line', 1269
    $P4590."unshift"($P4612)
.annotate 'line', 1280
    find_lex $P4616, "$how"
    unless_null $P4616, vivify_2012
    new $P4616, "Undef"
  vivify_2012:
    can $I4617, $P4616, "parametric"
    if $I4617, if_4615
    new $P4614, 'Integer'
    set $P4614, $I4617
    goto if_4615_end
  if_4615:
    find_lex $P4618, "$how"
    unless_null $P4618, vivify_2013
    new $P4618, "Undef"
  vivify_2013:
    find_lex $P4619, "$how"
    unless_null $P4619, vivify_2014
    new $P4619, "Undef"
  vivify_2014:
    $P4620 = $P4618."parametric"($P4619)
    set $P4614, $P4620
  if_4615_end:
    if $P4614, if_4613
.annotate 'line', 1298
    find_lex $P4672, "$past"
    unless_null $P4672, vivify_2015
    new $P4672, "Undef"
  vivify_2015:
    $P4672."blocktype"("immediate")
.annotate 'line', 1299
    find_dynamic_lex $P4675, "$*SC"
    unless_null $P4675, vivify_2016
    get_hll_global $P4673, "GLOBAL"
    get_who $P4674, $P4673
    set $P4675, $P4674["$SC"]
    unless_null $P4675, vivify_2017
    die "Contextual $*SC not found"
  vivify_2017:
  vivify_2016:
    find_lex $P4676, "$past"
    unless_null $P4676, vivify_2018
    new $P4676, "Undef"
  vivify_2018:
    find_dynamic_lex $P4679, "$*PACKAGE"
    unless_null $P4679, vivify_2019
    get_hll_global $P4677, "GLOBAL"
    get_who $P4678, $P4677
    set $P4679, $P4678["$PACKAGE"]
    unless_null $P4679, vivify_2020
    die "Contextual $*PACKAGE not found"
  vivify_2020:
  vivify_2019:
    $P4675."install_lexical_symbol"($P4676, "$?PACKAGE", $P4679)
.annotate 'line', 1300
    find_dynamic_lex $P4682, "$*SC"
    unless_null $P4682, vivify_2021
    get_hll_global $P4680, "GLOBAL"
    get_who $P4681, $P4680
    set $P4682, $P4681["$SC"]
    unless_null $P4682, vivify_2022
    die "Contextual $*SC not found"
  vivify_2022:
  vivify_2021:
    find_lex $P4683, "$past"
    unless_null $P4683, vivify_2023
    new $P4683, "Undef"
  vivify_2023:
    find_dynamic_lex $P4686, "$*PACKAGE"
    unless_null $P4686, vivify_2024
    get_hll_global $P4684, "GLOBAL"
    get_who $P4685, $P4684
    set $P4686, $P4685["$PACKAGE"]
    unless_null $P4686, vivify_2025
    die "Contextual $*PACKAGE not found"
  vivify_2025:
  vivify_2024:
    $P4682."install_lexical_symbol"($P4683, "$?CLASS", $P4686)
.annotate 'line', 1297
    goto if_4613_end
  if_4613:
.annotate 'line', 1281
    find_lex $P4621, "$past"
    unless_null $P4621, vivify_2026
    new $P4621, "Undef"
  vivify_2026:
    $P4621."blocktype"("declaration")
.annotate 'line', 1282
    find_lex $P4622, "$past"
    unless_null $P4622, vivify_2027
    new $P4622, "Undef"
  vivify_2027:
    get_hll_global $P4623, "GLOBAL"
    nqp_get_package_through_who $P4624, $P4623, "PAST"
    get_who $P4625, $P4624
    set $P4626, $P4625["Var"]
    $P4627 = $P4626."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P4622."unshift"($P4627)
.annotate 'line', 1283
    find_lex $P4628, "$past"
    unless_null $P4628, vivify_2028
    new $P4628, "Undef"
  vivify_2028:
    $P4628."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1284
    find_dynamic_lex $P4631, "$*PACKAGE-SETUP"
    unless_null $P4631, vivify_2029
    get_hll_global $P4629, "GLOBAL"
    get_who $P4630, $P4629
    set $P4631, $P4630["$PACKAGE-SETUP"]
    unless_null $P4631, vivify_2030
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2030:
  vivify_2029:
    get_hll_global $P4632, "GLOBAL"
    nqp_get_package_through_who $P4633, $P4632, "PAST"
    get_who $P4634, $P4633
    set $P4635, $P4634["Op"]
.annotate 'line', 1286
    get_hll_global $P4636, "GLOBAL"
    nqp_get_package_through_who $P4637, $P4636, "PAST"
    get_who $P4638, $P4637
    set $P4639, $P4638["Op"]
.annotate 'line', 1289
    get_hll_global $P4640, "GLOBAL"
    nqp_get_package_through_who $P4641, $P4640, "PAST"
    get_who $P4642, $P4641
    set $P4643, $P4642["Var"]
    $P4644 = $P4643."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4645 = $P4639."new"($P4644, "get_how PP" :named("pirop"))
.annotate 'line', 1291
    get_hll_global $P4646, "GLOBAL"
    nqp_get_package_through_who $P4647, $P4646, "PAST"
    get_who $P4648, $P4647
    set $P4649, $P4648["Var"]
    $P4650 = $P4649."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1292
    get_hll_global $P4651, "GLOBAL"
    nqp_get_package_through_who $P4652, $P4651, "PAST"
    get_who $P4653, $P4652
    set $P4654, $P4653["Val"]
    find_lex $P4655, "$past"
    unless_null $P4655, vivify_2031
    new $P4655, "Undef"
  vivify_2031:
    $P4656 = $P4654."new"($P4655 :named("value"))
    $P4657 = $P4635."new"($P4645, $P4650, $P4656, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1284
    $P4631."push"($P4657)
.annotate 'line', 1294
    find_dynamic_lex $P4660, "$*SC"
    unless_null $P4660, vivify_2032
    get_hll_global $P4658, "GLOBAL"
    get_who $P4659, $P4658
    set $P4660, $P4659["$SC"]
    unless_null $P4660, vivify_2033
    die "Contextual $*SC not found"
  vivify_2033:
  vivify_2032:
    find_lex $P4661, "$past"
    unless_null $P4661, vivify_2034
    new $P4661, "Undef"
  vivify_2034:
    find_dynamic_lex $P4664, "$*PACKAGE"
    unless_null $P4664, vivify_2035
    get_hll_global $P4662, "GLOBAL"
    get_who $P4663, $P4662
    set $P4664, $P4663["$PACKAGE"]
    unless_null $P4664, vivify_2036
    die "Contextual $*PACKAGE not found"
  vivify_2036:
  vivify_2035:
    $P4660."install_lexical_symbol"($P4661, "$?PACKAGE", $P4664)
.annotate 'line', 1295
    find_dynamic_lex $P4667, "$*SC"
    unless_null $P4667, vivify_2037
    get_hll_global $P4665, "GLOBAL"
    get_who $P4666, $P4665
    set $P4667, $P4666["$SC"]
    unless_null $P4667, vivify_2038
    die "Contextual $*SC not found"
  vivify_2038:
  vivify_2037:
    find_lex $P4668, "$past"
    unless_null $P4668, vivify_2039
    new $P4668, "Undef"
  vivify_2039:
    find_dynamic_lex $P4671, "$*PACKAGE"
    unless_null $P4671, vivify_2040
    get_hll_global $P4669, "GLOBAL"
    get_who $P4670, $P4669
    set $P4671, $P4670["$PACKAGE"]
    unless_null $P4671, vivify_2041
    die "Contextual $*PACKAGE not found"
  vivify_2041:
  vivify_2040:
    $P4667."install_lexical_symbol"($P4668, "$?ROLE", $P4671)
  if_4613_end:
.annotate 'line', 1304
    find_lex $P4688, "$/"
    unless_null $P4688, vivify_2042
    $P4688 = root_new ['parrot';'Hash']
  vivify_2042:
    set $P4689, $P4688["parent"]
    unless_null $P4689, vivify_2043
    new $P4689, "Undef"
  vivify_2043:
    if $P4689, if_4687
.annotate 'line', 1318
    find_lex $P4735, "$how"
    unless_null $P4735, vivify_2044
    new $P4735, "Undef"
  vivify_2044:
    can $I4736, $P4735, "set_default_parent"
    unless $I4736, if_4734_end
    .const 'Sub' $P4738 = "493_1303923618.727" 
    capture_lex $P4738
    $P4738()
  if_4734_end:
    goto if_4687_end
  if_4687:
.annotate 'line', 1304
    .const 'Sub' $P4691 = "491_1303923618.727" 
    capture_lex $P4691
    $P4691()
  if_4687_end:
.annotate 'line', 1325
    find_lex $P4760, "$/"
    unless_null $P4760, vivify_2070
    $P4760 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P4761, $P4760["role"]
    unless_null $P4761, vivify_2071
    new $P4761, "Undef"
  vivify_2071:
    unless $P4761, if_4759_end
.annotate 'line', 1326
    find_lex $P4763, "$/"
    unless_null $P4763, vivify_2072
    $P4763 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P4764, $P4763["role"]
    unless_null $P4764, vivify_2073
    new $P4764, "Undef"
  vivify_2073:
    defined $I4765, $P4764
    unless $I4765, for_undef_2074
    iter $P4762, $P4764
    new $P4809, 'ExceptionHandler'
    set_label $P4809, loop4808_handler
    $P4809."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4809
  loop4808_test:
    unless $P4762, loop4808_done
    shift $P4766, $P4762
  loop4808_redo:
    .const 'Sub' $P4768 = "494_1303923618.727" 
    capture_lex $P4768
    $P4768($P4766)
  loop4808_next:
    goto loop4808_test
  loop4808_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4810, exception, 'type'
    eq $P4810, .CONTROL_LOOP_NEXT, loop4808_next
    eq $P4810, .CONTROL_LOOP_REDO, loop4808_redo
  loop4808_done:
    pop_eh 
  for_undef_2074:
  if_4759_end:
.annotate 'line', 1343
    find_dynamic_lex $P4813, "$*PACKAGE-SETUP"
    unless_null $P4813, vivify_2088
    get_hll_global $P4811, "GLOBAL"
    get_who $P4812, $P4811
    set $P4813, $P4812["$PACKAGE-SETUP"]
    unless_null $P4813, vivify_2089
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2089:
  vivify_2088:
    get_hll_global $P4814, "GLOBAL"
    nqp_get_package_through_who $P4815, $P4814, "PAST"
    get_who $P4816, $P4815
    set $P4817, $P4816["Op"]
.annotate 'line', 1345
    get_hll_global $P4818, "GLOBAL"
    nqp_get_package_through_who $P4819, $P4818, "PAST"
    get_who $P4820, $P4819
    set $P4821, $P4820["Op"]
.annotate 'line', 1348
    get_hll_global $P4822, "GLOBAL"
    nqp_get_package_through_who $P4823, $P4822, "PAST"
    get_who $P4824, $P4823
    set $P4825, $P4824["Var"]
    $P4826 = $P4825."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4827 = $P4821."new"($P4826, "get_how PP" :named("pirop"))
.annotate 'line', 1350
    get_hll_global $P4828, "GLOBAL"
    nqp_get_package_through_who $P4829, $P4828, "PAST"
    get_who $P4830, $P4829
    set $P4831, $P4830["Var"]
    $P4832 = $P4831."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4833 = $P4817."new"($P4827, $P4832, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1343
    $P4813."push"($P4833)
.annotate 'line', 1354
    find_lex $P4834, "$past"
    unless_null $P4834, vivify_2090
    new $P4834, "Undef"
  vivify_2090:
    $P4835 = $P4834."loadinit"()
    get_hll_global $P4836, "GLOBAL"
    nqp_get_package_through_who $P4837, $P4836, "PAST"
    get_who $P4838, $P4837
    set $P4839, $P4838["Block"]
    find_dynamic_lex $P4842, "$*PACKAGE-SETUP"
    unless_null $P4842, vivify_2091
    get_hll_global $P4840, "GLOBAL"
    get_who $P4841, $P4840
    set $P4842, $P4841["$PACKAGE-SETUP"]
    unless_null $P4842, vivify_2092
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2092:
  vivify_2091:
    $P4843 = $P4839."new"($P4842, "immediate" :named("blocktype"))
    $P4835."push"($P4843)
.annotate 'line', 1356
    find_lex $P4844, "$/"
    find_lex $P4845, "$past"
    unless_null $P4845, vivify_2093
    new $P4845, "Undef"
  vivify_2093:
    $P4846 = $P4844."!make"($P4845)
.annotate 'line', 1256
    .return ($P4846)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4737"  :anon :subid("493_1303923618.727") :outer("490_1303923618.727")
.annotate 'line', 1319
    new $P4739, "Undef"
    .lex "$default", $P4739
    find_dynamic_lex $P4744, "$*PKGDECL"
    unless_null $P4744, vivify_2045
    get_hll_global $P4742, "GLOBAL"
    get_who $P4743, $P4742
    set $P4744, $P4743["$PKGDECL"]
    unless_null $P4744, vivify_2046
    die "Contextual $*PKGDECL not found"
  vivify_2046:
  vivify_2045:
    set $S4745, $P4744
    iseq $I4746, $S4745, "grammar"
    if $I4746, if_4741
    new $P4748, "ResizablePMCArray"
    push $P4748, "NQPMu"
    set $P4740, $P4748
    goto if_4741_end
  if_4741:
    new $P4747, "ResizablePMCArray"
    push $P4747, "Regex"
    push $P4747, "Cursor"
    set $P4740, $P4747
  if_4741_end:
    store_lex "$default", $P4740
.annotate 'line', 1320
    find_dynamic_lex $P4751, "$*SC"
    unless_null $P4751, vivify_2047
    get_hll_global $P4749, "GLOBAL"
    get_who $P4750, $P4749
    set $P4751, $P4750["$SC"]
    unless_null $P4751, vivify_2048
    die "Contextual $*SC not found"
  vivify_2048:
  vivify_2047:
    find_dynamic_lex $P4754, "$*PACKAGE"
    unless_null $P4754, vivify_2049
    get_hll_global $P4752, "GLOBAL"
    get_who $P4753, $P4752
    set $P4754, $P4753["$PACKAGE"]
    unless_null $P4754, vivify_2050
    die "Contextual $*PACKAGE not found"
  vivify_2050:
  vivify_2049:
.annotate 'line', 1321
    find_lex $P4755, "$default"
    unless_null $P4755, vivify_2051
    new $P4755, "Undef"
  vivify_2051:
    find_lex $P4756, "$/"
    unless_null $P4756, vivify_2052
    new $P4756, "Undef"
  vivify_2052:
    $P4757 = "find_sym"($P4755, $P4756)
    $P4758 = $P4751."pkg_add_parent_or_role"($P4754, "set_default_parent", $P4757)
.annotate 'line', 1318
    .return ($P4758)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4690"  :anon :subid("491_1303923618.727") :outer("490_1303923618.727")
.annotate 'line', 1304
    .const 'Sub' $P4697 = "492_1303923618.727" 
    capture_lex $P4697
.annotate 'line', 1305
    new $P4692, "Undef"
    .lex "$parent", $P4692
.annotate 'line', 1306
    new $P4693, "Undef"
    .lex "$parent_found", $P4693
.annotate 'line', 1304
    find_lex $P4694, "$parent"
    unless_null $P4694, vivify_2053
    new $P4694, "Undef"
  vivify_2053:
    find_lex $P4695, "$parent_found"
    unless_null $P4695, vivify_2054
    new $P4695, "Undef"
  vivify_2054:
.annotate 'line', 1307
    .const 'Sub' $P4697 = "492_1303923618.727" 
    capture_lex $P4697
    $P4697()
.annotate 'line', 1311
    find_lex $P4715, "$parent_found"
    unless_null $P4715, vivify_2060
    new $P4715, "Undef"
  vivify_2060:
    if $P4715, if_4714
.annotate 'line', 1315
    find_lex $P4724, "$/"
    unless_null $P4724, vivify_2061
    new $P4724, "Undef"
  vivify_2061:
    $P4725 = $P4724."CURSOR"()
    new $P4726, "String"
    assign $P4726, "Could not find parent class '"
    find_lex $P4727, "$/"
    unless_null $P4727, vivify_2062
    $P4727 = root_new ['parrot';'Hash']
  vivify_2062:
    set $P4728, $P4727["parent"]
    unless_null $P4728, vivify_2063
    $P4728 = root_new ['parrot';'ResizablePMCArray']
  vivify_2063:
    set $P4729, $P4728[0]
    unless_null $P4729, vivify_2064
    new $P4729, "Undef"
  vivify_2064:
    set $S4730, $P4729
    concat $P4731, $P4726, $S4730
    concat $P4732, $P4731, "'"
    $P4733 = $P4725."panic"($P4732)
.annotate 'line', 1314
    set $P4713, $P4733
.annotate 'line', 1311
    goto if_4714_end
  if_4714:
.annotate 'line', 1312
    find_dynamic_lex $P4718, "$*SC"
    unless_null $P4718, vivify_2065
    get_hll_global $P4716, "GLOBAL"
    get_who $P4717, $P4716
    set $P4718, $P4717["$SC"]
    unless_null $P4718, vivify_2066
    die "Contextual $*SC not found"
  vivify_2066:
  vivify_2065:
    find_dynamic_lex $P4721, "$*PACKAGE"
    unless_null $P4721, vivify_2067
    get_hll_global $P4719, "GLOBAL"
    get_who $P4720, $P4719
    set $P4721, $P4720["$PACKAGE"]
    unless_null $P4721, vivify_2068
    die "Contextual $*PACKAGE not found"
  vivify_2068:
  vivify_2067:
    find_lex $P4722, "$parent"
    unless_null $P4722, vivify_2069
    new $P4722, "Undef"
  vivify_2069:
    $P4723 = $P4718."pkg_add_parent_or_role"($P4721, "add_parent", $P4722)
.annotate 'line', 1311
    set $P4713, $P4723
  if_4714_end:
.annotate 'line', 1304
    .return ($P4713)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4696"  :anon :subid("492_1303923618.727") :outer("491_1303923618.727")
.annotate 'line', 1307
    new $P4708, 'ExceptionHandler'
    set_label $P4708, control_4707
    $P4708."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4708
.annotate 'line', 1308
    find_lex $P4698, "$/"
    unless_null $P4698, vivify_2055
    $P4698 = root_new ['parrot';'Hash']
  vivify_2055:
    set $P4699, $P4698["parent"]
    unless_null $P4699, vivify_2056
    $P4699 = root_new ['parrot';'ResizablePMCArray']
  vivify_2056:
    set $P4700, $P4699[0]
    unless_null $P4700, vivify_2057
    $P4700 = root_new ['parrot';'Hash']
  vivify_2057:
    set $P4701, $P4700["identifier"]
    unless_null $P4701, vivify_2058
    new $P4701, "Undef"
  vivify_2058:
    clone $P4702, $P4701
    find_lex $P4703, "$/"
    unless_null $P4703, vivify_2059
    new $P4703, "Undef"
  vivify_2059:
    $P4704 = "find_sym"($P4702, $P4703)
    store_lex "$parent", $P4704
.annotate 'line', 1309
    new $P4705, "Integer"
    assign $P4705, 1
    store_lex "$parent_found", $P4705
.annotate 'line', 1307
    pop_eh 
    goto skip_handler_4706
  control_4707:
    .local pmc exception 
    .get_results (exception) 
    new $P4711, 'Integer'
    set $P4711, 1
    set exception["handled"], $P4711
    set $I4712, exception["handled"]
    ne $I4712, 1, nothandled_4710
  handled_4709:
    .return (exception)
  nothandled_4710:
    rethrow exception
  skip_handler_4706:
    .return ($P4705)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4767"  :anon :subid("494_1303923618.727") :outer("490_1303923618.727")
    .param pmc param_4771
.annotate 'line', 1326
    .const 'Sub' $P4775 = "495_1303923618.727" 
    capture_lex $P4775
.annotate 'line', 1327
    new $P4769, "Undef"
    .lex "$role", $P4769
.annotate 'line', 1328
    new $P4770, "Undef"
    .lex "$role_found", $P4770
    .lex "$_", param_4771
.annotate 'line', 1326
    find_lex $P4772, "$role"
    unless_null $P4772, vivify_2075
    new $P4772, "Undef"
  vivify_2075:
    find_lex $P4773, "$role_found"
    unless_null $P4773, vivify_2076
    new $P4773, "Undef"
  vivify_2076:
.annotate 'line', 1329
    .const 'Sub' $P4775 = "495_1303923618.727" 
    capture_lex $P4775
    $P4775()
.annotate 'line', 1333
    find_lex $P4791, "$role_found"
    unless_null $P4791, vivify_2080
    new $P4791, "Undef"
  vivify_2080:
    if $P4791, if_4790
.annotate 'line', 1337
    find_lex $P4800, "$/"
    unless_null $P4800, vivify_2081
    new $P4800, "Undef"
  vivify_2081:
    $P4801 = $P4800."CURSOR"()
    new $P4802, "String"
    assign $P4802, "Could not find role '"
    find_lex $P4803, "$_"
    unless_null $P4803, vivify_2082
    new $P4803, "Undef"
  vivify_2082:
    set $S4804, $P4803
    concat $P4805, $P4802, $S4804
    concat $P4806, $P4805, "'"
    $P4807 = $P4801."panic"($P4806)
.annotate 'line', 1336
    set $P4789, $P4807
.annotate 'line', 1333
    goto if_4790_end
  if_4790:
.annotate 'line', 1334
    find_dynamic_lex $P4794, "$*SC"
    unless_null $P4794, vivify_2083
    get_hll_global $P4792, "GLOBAL"
    get_who $P4793, $P4792
    set $P4794, $P4793["$SC"]
    unless_null $P4794, vivify_2084
    die "Contextual $*SC not found"
  vivify_2084:
  vivify_2083:
    find_dynamic_lex $P4797, "$*PACKAGE"
    unless_null $P4797, vivify_2085
    get_hll_global $P4795, "GLOBAL"
    get_who $P4796, $P4795
    set $P4797, $P4796["$PACKAGE"]
    unless_null $P4797, vivify_2086
    die "Contextual $*PACKAGE not found"
  vivify_2086:
  vivify_2085:
    find_lex $P4798, "$role"
    unless_null $P4798, vivify_2087
    new $P4798, "Undef"
  vivify_2087:
    $P4799 = $P4794."pkg_add_parent_or_role"($P4797, "add_role", $P4798)
.annotate 'line', 1333
    set $P4789, $P4799
  if_4790_end:
.annotate 'line', 1326
    .return ($P4789)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4774"  :anon :subid("495_1303923618.727") :outer("494_1303923618.727")
.annotate 'line', 1329
    new $P4784, 'ExceptionHandler'
    set_label $P4784, control_4783
    $P4784."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4784
.annotate 'line', 1330
    find_lex $P4776, "$_"
    unless_null $P4776, vivify_2077
    $P4776 = root_new ['parrot';'Hash']
  vivify_2077:
    set $P4777, $P4776["identifier"]
    unless_null $P4777, vivify_2078
    new $P4777, "Undef"
  vivify_2078:
    clone $P4778, $P4777
    find_lex $P4779, "$/"
    unless_null $P4779, vivify_2079
    new $P4779, "Undef"
  vivify_2079:
    $P4780 = "find_sym"($P4778, $P4779)
    store_lex "$role", $P4780
.annotate 'line', 1331
    new $P4781, "Integer"
    assign $P4781, 1
    store_lex "$role_found", $P4781
.annotate 'line', 1329
    pop_eh 
    goto skip_handler_4782
  control_4783:
    .local pmc exception 
    .get_results (exception) 
    new $P4787, 'Integer'
    set $P4787, 1
    set exception["handled"], $P4787
    set $I4788, exception["handled"]
    ne $I4788, 1, nothandled_4786
  handled_4785:
    .return (exception)
  nothandled_4786:
    rethrow exception
  skip_handler_4782:
    .return ($P4781)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("496_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4848
    .param pmc param_4849
.annotate 'line', 1359
    .lex "self", param_4848
    .lex "$/", param_4849
    find_lex $P4850, "$/"
    find_lex $P4851, "$/"
    unless_null $P4851, vivify_2094
    $P4851 = root_new ['parrot';'Hash']
  vivify_2094:
    set $P4852, $P4851["scoped"]
    unless_null $P4852, vivify_2095
    new $P4852, "Undef"
  vivify_2095:
    $P4853 = $P4852."ast"()
    $P4854 = $P4850."!make"($P4853)
    .return ($P4854)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("497_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4856
    .param pmc param_4857
.annotate 'line', 1360
    .lex "self", param_4856
    .lex "$/", param_4857
    find_lex $P4858, "$/"
    find_lex $P4859, "$/"
    unless_null $P4859, vivify_2096
    $P4859 = root_new ['parrot';'Hash']
  vivify_2096:
    set $P4860, $P4859["scoped"]
    unless_null $P4860, vivify_2097
    new $P4860, "Undef"
  vivify_2097:
    $P4861 = $P4860."ast"()
    $P4862 = $P4858."!make"($P4861)
    .return ($P4862)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("498_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4864
    .param pmc param_4865
.annotate 'line', 1361
    .lex "self", param_4864
    .lex "$/", param_4865
    find_lex $P4866, "$/"
    find_lex $P4867, "$/"
    unless_null $P4867, vivify_2098
    $P4867 = root_new ['parrot';'Hash']
  vivify_2098:
    set $P4868, $P4867["scoped"]
    unless_null $P4868, vivify_2099
    new $P4868, "Undef"
  vivify_2099:
    $P4869 = $P4868."ast"()
    $P4870 = $P4866."!make"($P4869)
    .return ($P4870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("499_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4872
    .param pmc param_4873
.annotate 'line', 1363
    .lex "self", param_4872
    .lex "$/", param_4873
.annotate 'line', 1364
    find_lex $P4874, "$/"
    find_lex $P4877, "$/"
    unless_null $P4877, vivify_2100
    $P4877 = root_new ['parrot';'Hash']
  vivify_2100:
    set $P4878, $P4877["declarator"]
    unless_null $P4878, vivify_2101
    new $P4878, "Undef"
  vivify_2101:
    if $P4878, if_4876
.annotate 'line', 1365
    find_lex $P4884, "$/"
    unless_null $P4884, vivify_2102
    $P4884 = root_new ['parrot';'Hash']
  vivify_2102:
    set $P4885, $P4884["multi_declarator"]
    unless_null $P4885, vivify_2103
    new $P4885, "Undef"
  vivify_2103:
    if $P4885, if_4883
.annotate 'line', 1366
    find_lex $P4889, "$/"
    unless_null $P4889, vivify_2104
    $P4889 = root_new ['parrot';'Hash']
  vivify_2104:
    set $P4890, $P4889["package_declarator"]
    unless_null $P4890, vivify_2105
    new $P4890, "Undef"
  vivify_2105:
    $P4891 = $P4890."ast"()
    set $P4882, $P4891
.annotate 'line', 1365
    goto if_4883_end
  if_4883:
    find_lex $P4886, "$/"
    unless_null $P4886, vivify_2106
    $P4886 = root_new ['parrot';'Hash']
  vivify_2106:
    set $P4887, $P4886["multi_declarator"]
    unless_null $P4887, vivify_2107
    new $P4887, "Undef"
  vivify_2107:
    $P4888 = $P4887."ast"()
    set $P4882, $P4888
  if_4883_end:
    set $P4875, $P4882
.annotate 'line', 1364
    goto if_4876_end
  if_4876:
    find_lex $P4879, "$/"
    unless_null $P4879, vivify_2108
    $P4879 = root_new ['parrot';'Hash']
  vivify_2108:
    set $P4880, $P4879["declarator"]
    unless_null $P4880, vivify_2109
    new $P4880, "Undef"
  vivify_2109:
    $P4881 = $P4880."ast"()
    set $P4875, $P4881
  if_4876_end:
    $P4892 = $P4874."!make"($P4875)
.annotate 'line', 1363
    .return ($P4892)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("500_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4894
    .param pmc param_4895
.annotate 'line', 1369
    .lex "self", param_4894
    .lex "$/", param_4895
.annotate 'line', 1370
    find_lex $P4896, "$/"
.annotate 'line', 1371
    find_lex $P4899, "$/"
    unless_null $P4899, vivify_2110
    $P4899 = root_new ['parrot';'Hash']
  vivify_2110:
    set $P4900, $P4899["routine_declarator"]
    unless_null $P4900, vivify_2111
    new $P4900, "Undef"
  vivify_2111:
    if $P4900, if_4898
.annotate 'line', 1372
    find_lex $P4904, "$/"
    unless_null $P4904, vivify_2112
    $P4904 = root_new ['parrot';'Hash']
  vivify_2112:
    set $P4905, $P4904["variable_declarator"]
    unless_null $P4905, vivify_2113
    new $P4905, "Undef"
  vivify_2113:
    $P4906 = $P4905."ast"()
    set $P4897, $P4906
.annotate 'line', 1371
    goto if_4898_end
  if_4898:
    find_lex $P4901, "$/"
    unless_null $P4901, vivify_2114
    $P4901 = root_new ['parrot';'Hash']
  vivify_2114:
    set $P4902, $P4901["routine_declarator"]
    unless_null $P4902, vivify_2115
    new $P4902, "Undef"
  vivify_2115:
    $P4903 = $P4902."ast"()
    set $P4897, $P4903
  if_4898_end:
    $P4907 = $P4896."!make"($P4897)
.annotate 'line', 1369
    .return ($P4907)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("501_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4909
    .param pmc param_4910
.annotate 'line', 1375
    .lex "self", param_4909
    .lex "$/", param_4910
    find_lex $P4911, "$/"
    find_lex $P4914, "$/"
    unless_null $P4914, vivify_2116
    $P4914 = root_new ['parrot';'Hash']
  vivify_2116:
    set $P4915, $P4914["declarator"]
    unless_null $P4915, vivify_2117
    new $P4915, "Undef"
  vivify_2117:
    if $P4915, if_4913
    find_lex $P4919, "$/"
    unless_null $P4919, vivify_2118
    $P4919 = root_new ['parrot';'Hash']
  vivify_2118:
    set $P4920, $P4919["routine_def"]
    unless_null $P4920, vivify_2119
    new $P4920, "Undef"
  vivify_2119:
    $P4921 = $P4920."ast"()
    set $P4912, $P4921
    goto if_4913_end
  if_4913:
    find_lex $P4916, "$/"
    unless_null $P4916, vivify_2120
    $P4916 = root_new ['parrot';'Hash']
  vivify_2120:
    set $P4917, $P4916["declarator"]
    unless_null $P4917, vivify_2121
    new $P4917, "Undef"
  vivify_2121:
    $P4918 = $P4917."ast"()
    set $P4912, $P4918
  if_4913_end:
    $P4922 = $P4911."!make"($P4912)
    .return ($P4922)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("502_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4924
    .param pmc param_4925
.annotate 'line', 1376
    .lex "self", param_4924
    .lex "$/", param_4925
    find_lex $P4926, "$/"
    find_lex $P4929, "$/"
    unless_null $P4929, vivify_2122
    $P4929 = root_new ['parrot';'Hash']
  vivify_2122:
    set $P4930, $P4929["declarator"]
    unless_null $P4930, vivify_2123
    new $P4930, "Undef"
  vivify_2123:
    if $P4930, if_4928
    find_lex $P4934, "$/"
    unless_null $P4934, vivify_2124
    $P4934 = root_new ['parrot';'Hash']
  vivify_2124:
    set $P4935, $P4934["routine_def"]
    unless_null $P4935, vivify_2125
    new $P4935, "Undef"
  vivify_2125:
    $P4936 = $P4935."ast"()
    set $P4927, $P4936
    goto if_4928_end
  if_4928:
    find_lex $P4931, "$/"
    unless_null $P4931, vivify_2126
    $P4931 = root_new ['parrot';'Hash']
  vivify_2126:
    set $P4932, $P4931["declarator"]
    unless_null $P4932, vivify_2127
    new $P4932, "Undef"
  vivify_2127:
    $P4933 = $P4932."ast"()
    set $P4927, $P4933
  if_4928_end:
    $P4937 = $P4926."!make"($P4927)
    .return ($P4937)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("503_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4939
    .param pmc param_4940
.annotate 'line', 1377
    .lex "self", param_4939
    .lex "$/", param_4940
    find_lex $P4941, "$/"
    find_lex $P4942, "$/"
    unless_null $P4942, vivify_2128
    $P4942 = root_new ['parrot';'Hash']
  vivify_2128:
    set $P4943, $P4942["declarator"]
    unless_null $P4943, vivify_2129
    new $P4943, "Undef"
  vivify_2129:
    $P4944 = $P4943."ast"()
    $P4945 = $P4941."!make"($P4944)
    .return ($P4945)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("504_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_4947
    .param pmc param_4948
.annotate 'line', 1380
    .const 'Sub' $P4982 = "505_1303923618.727" 
    capture_lex $P4982
    .lex "self", param_4947
    .lex "$/", param_4948
.annotate 'line', 1381
    new $P4949, "Undef"
    .lex "$past", $P4949
.annotate 'line', 1382
    new $P4950, "Undef"
    .lex "$sigil", $P4950
.annotate 'line', 1383
    new $P4951, "Undef"
    .lex "$name", $P4951
.annotate 'line', 1384
    new $P4952, "Undef"
    .lex "$BLOCK", $P4952
.annotate 'line', 1381
    find_lex $P4953, "$/"
    unless_null $P4953, vivify_2130
    $P4953 = root_new ['parrot';'Hash']
  vivify_2130:
    set $P4954, $P4953["variable"]
    unless_null $P4954, vivify_2131
    new $P4954, "Undef"
  vivify_2131:
    $P4955 = $P4954."ast"()
    store_lex "$past", $P4955
.annotate 'line', 1382
    find_lex $P4956, "$/"
    unless_null $P4956, vivify_2132
    $P4956 = root_new ['parrot';'Hash']
  vivify_2132:
    set $P4957, $P4956["variable"]
    unless_null $P4957, vivify_2133
    $P4957 = root_new ['parrot';'Hash']
  vivify_2133:
    set $P4958, $P4957["sigil"]
    unless_null $P4958, vivify_2134
    new $P4958, "Undef"
  vivify_2134:
    store_lex "$sigil", $P4958
.annotate 'line', 1383
    find_lex $P4959, "$past"
    unless_null $P4959, vivify_2135
    new $P4959, "Undef"
  vivify_2135:
    $P4960 = $P4959."name"()
    store_lex "$name", $P4960
.annotate 'line', 1384
    find_lex $P4961, "$?PACKAGE"
    get_who $P4962, $P4961
    set $P4963, $P4962["@BLOCK"]
    unless_null $P4963, vivify_2136
    $P4963 = root_new ['parrot';'ResizablePMCArray']
  vivify_2136:
    set $P4964, $P4963[0]
    unless_null $P4964, vivify_2137
    new $P4964, "Undef"
  vivify_2137:
    store_lex "$BLOCK", $P4964
.annotate 'line', 1385
    find_lex $P4968, "$name"
    unless_null $P4968, vivify_2138
    new $P4968, "Undef"
  vivify_2138:
    if $P4968, if_4967
    set $P4966, $P4968
    goto if_4967_end
  if_4967:
    find_lex $P4969, "$BLOCK"
    unless_null $P4969, vivify_2139
    new $P4969, "Undef"
  vivify_2139:
    find_lex $P4970, "$name"
    unless_null $P4970, vivify_2140
    new $P4970, "Undef"
  vivify_2140:
    $P4971 = $P4969."symbol"($P4970)
    set $P4966, $P4971
  if_4967_end:
    unless $P4966, if_4965_end
.annotate 'line', 1386
    find_lex $P4972, "$/"
    unless_null $P4972, vivify_2141
    new $P4972, "Undef"
  vivify_2141:
    $P4973 = $P4972."CURSOR"()
    find_lex $P4974, "$name"
    unless_null $P4974, vivify_2142
    new $P4974, "Undef"
  vivify_2142:
    $P4973."panic"("Redeclaration of symbol ", $P4974)
  if_4965_end:
.annotate 'line', 1388
    find_dynamic_lex $P4978, "$*SCOPE"
    unless_null $P4978, vivify_2143
    get_hll_global $P4976, "GLOBAL"
    get_who $P4977, $P4976
    set $P4978, $P4977["$SCOPE"]
    unless_null $P4978, vivify_2144
    die "Contextual $*SCOPE not found"
  vivify_2144:
  vivify_2143:
    set $S4979, $P4978
    iseq $I4980, $S4979, "has"
    if $I4980, if_4975
.annotate 'line', 1408
    find_dynamic_lex $P5039, "$*SCOPE"
    unless_null $P5039, vivify_2145
    get_hll_global $P5037, "GLOBAL"
    get_who $P5038, $P5037
    set $P5039, $P5038["$SCOPE"]
    unless_null $P5039, vivify_2146
    die "Contextual $*SCOPE not found"
  vivify_2146:
  vivify_2145:
    set $S5040, $P5039
    iseq $I5041, $S5040, "our"
    if $I5041, if_5036
.annotate 'line', 1418
    find_lex $P5055, "$BLOCK"
    unless_null $P5055, vivify_2147
    $P5055 = root_new ['parrot';'ResizablePMCArray']
  vivify_2147:
    set $P5056, $P5055[0]
    unless_null $P5056, vivify_2148
    new $P5056, "Undef"
  vivify_2148:
    get_hll_global $P5057, "GLOBAL"
    nqp_get_package_through_who $P5058, $P5057, "PAST"
    get_who $P5059, $P5058
    set $P5060, $P5059["Var"]
    find_lex $P5061, "$name"
    unless_null $P5061, vivify_2149
    new $P5061, "Undef"
  vivify_2149:
.annotate 'line', 1420
    find_lex $P5062, "$sigil"
    unless_null $P5062, vivify_2150
    new $P5062, "Undef"
  vivify_2150:
    $P5063 = "vivitype"($P5062)
    find_lex $P5064, "$/"
    unless_null $P5064, vivify_2151
    new $P5064, "Undef"
  vivify_2151:
    $P5065 = $P5060."new"($P5061 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P5063 :named("viviself"), $P5064 :named("node"))
.annotate 'line', 1418
    $P5056."push"($P5065)
.annotate 'line', 1423
    find_lex $P5066, "$BLOCK"
    unless_null $P5066, vivify_2152
    new $P5066, "Undef"
  vivify_2152:
    find_lex $P5067, "$name"
    unless_null $P5067, vivify_2153
    new $P5067, "Undef"
  vivify_2153:
    $P5066."symbol"($P5067, "lexical" :named("scope"))
.annotate 'line', 1417
    goto if_5036_end
  if_5036:
.annotate 'line', 1412
    find_lex $P5042, "$/"
    unless_null $P5042, vivify_2154
    $P5042 = root_new ['parrot';'Hash']
  vivify_2154:
    set $P5043, $P5042["variable"]
    unless_null $P5043, vivify_2155
    new $P5043, "Undef"
  vivify_2155:
    set $S5044, $P5043
    new $P5045, 'String'
    set $P5045, $S5044
    store_lex "$name", $P5045
.annotate 'line', 1413
    find_lex $P5046, "$name"
    unless_null $P5046, vivify_2156
    new $P5046, "Undef"
  vivify_2156:
    new $P5047, "ResizablePMCArray"
    push $P5047, $P5046
    find_lex $P5048, "$/"
    unless_null $P5048, vivify_2157
    new $P5048, "Undef"
  vivify_2157:
    $P5049 = "lexical_package_lookup"($P5047, $P5048)
    store_lex "$past", $P5049
.annotate 'line', 1414
    find_lex $P5050, "$past"
    unless_null $P5050, vivify_2158
    new $P5050, "Undef"
  vivify_2158:
    find_lex $P5051, "$sigil"
    unless_null $P5051, vivify_2159
    new $P5051, "Undef"
  vivify_2159:
    $P5052 = "vivitype"($P5051)
    $P5050."viviself"($P5052)
.annotate 'line', 1415
    find_lex $P5053, "$BLOCK"
    unless_null $P5053, vivify_2160
    new $P5053, "Undef"
  vivify_2160:
    find_lex $P5054, "$name"
    unless_null $P5054, vivify_2161
    new $P5054, "Undef"
  vivify_2161:
    $P5053."symbol"($P5054, "package" :named("scope"))
  if_5036_end:
.annotate 'line', 1408
    goto if_4975_end
  if_4975:
.annotate 'line', 1388
    .const 'Sub' $P4982 = "505_1303923618.727" 
    capture_lex $P4982
    $P4982()
  if_4975_end:
.annotate 'line', 1425
    find_lex $P5068, "$/"
    find_lex $P5069, "$past"
    unless_null $P5069, vivify_2191
    new $P5069, "Undef"
  vivify_2191:
    $P5070 = $P5068."!make"($P5069)
.annotate 'line', 1380
    .return ($P5070)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4981"  :anon :subid("505_1303923618.727") :outer("504_1303923618.727")
.annotate 'line', 1395
    $P4983 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P4983
.annotate 'line', 1396
    $P4984 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P4984
.annotate 'line', 1390
    find_dynamic_lex $P4991, "$*PKGDECL"
    unless_null $P4991, vivify_2162
    get_hll_global $P4989, "GLOBAL"
    get_who $P4990, $P4989
    set $P4991, $P4990["$PKGDECL"]
    unless_null $P4991, vivify_2163
    die "Contextual $*PKGDECL not found"
  vivify_2163:
  vivify_2162:
    concat $P4992, $P4991, "-attr"
    find_dynamic_lex $P4988, "%*HOW"
    unless_null $P4988, vivify_2164
    get_hll_global $P4986, "GLOBAL"
    get_who $P4987, $P4986
    set $P4988, $P4987["%HOW"]
    unless_null $P4988, vivify_2165
    die "Contextual %*HOW not found"
  vivify_2165:
  vivify_2164:
    exists $I4993, $P4988[$P4992]
    if $I4993, unless_4985_end
.annotate 'line', 1391
    find_lex $P4994, "$/"
    unless_null $P4994, vivify_2166
    new $P4994, "Undef"
  vivify_2166:
    $P4995 = $P4994."CURSOR"()
    find_dynamic_lex $P4998, "$*PKGDECL"
    unless_null $P4998, vivify_2167
    get_hll_global $P4996, "GLOBAL"
    get_who $P4997, $P4996
    set $P4998, $P4997["$PKGDECL"]
    unless_null $P4998, vivify_2168
    die "Contextual $*PKGDECL not found"
  vivify_2168:
  vivify_2167:
    concat $P4999, $P4998, " packages do not support attributes"
    $P4995."panic"($P4999)
  unless_4985_end:
.annotate 'line', 1390
    find_lex $P5000, "%lit_args"
    unless_null $P5000, vivify_2169
    $P5000 = root_new ['parrot';'Hash']
  vivify_2169:
    find_lex $P5001, "%obj_args"
    unless_null $P5001, vivify_2170
    $P5001 = root_new ['parrot';'Hash']
  vivify_2170:
.annotate 'line', 1397
    find_lex $P5002, "$name"
    unless_null $P5002, vivify_2171
    new $P5002, "Undef"
  vivify_2171:
    find_lex $P5003, "%lit_args"
    unless_null $P5003, vivify_2172
    $P5003 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P5003
  vivify_2172:
    set $P5003["name"], $P5002
.annotate 'line', 1398
    find_lex $P5005, "$/"
    unless_null $P5005, vivify_2173
    $P5005 = root_new ['parrot';'Hash']
  vivify_2173:
    set $P5006, $P5005["typename"]
    unless_null $P5006, vivify_2174
    new $P5006, "Undef"
  vivify_2174:
    unless $P5006, if_5004_end
.annotate 'line', 1399
    find_lex $P5007, "$/"
    unless_null $P5007, vivify_2175
    $P5007 = root_new ['parrot';'Hash']
  vivify_2175:
    set $P5008, $P5007["typename"]
    unless_null $P5008, vivify_2176
    $P5008 = root_new ['parrot';'ResizablePMCArray']
  vivify_2176:
    set $P5009, $P5008[0]
    unless_null $P5009, vivify_2177
    new $P5009, "Undef"
  vivify_2177:
    set $S5010, $P5009
    new $P5011, "ResizablePMCArray"
    push $P5011, $S5010
    find_lex $P5012, "$/"
    unless_null $P5012, vivify_2178
    new $P5012, "Undef"
  vivify_2178:
    $P5013 = "find_sym"($P5011, $P5012)
    find_lex $P5014, "%obj_args"
    unless_null $P5014, vivify_2179
    $P5014 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P5014
  vivify_2179:
    set $P5014["type"], $P5013
  if_5004_end:
.annotate 'line', 1403
    find_dynamic_lex $P5017, "$*SC"
    unless_null $P5017, vivify_2180
    get_hll_global $P5015, "GLOBAL"
    get_who $P5016, $P5015
    set $P5017, $P5016["$SC"]
    unless_null $P5017, vivify_2181
    die "Contextual $*SC not found"
  vivify_2181:
  vivify_2180:
    find_dynamic_lex $P5020, "$*PACKAGE"
    unless_null $P5020, vivify_2182
    get_hll_global $P5018, "GLOBAL"
    get_who $P5019, $P5018
    set $P5020, $P5019["$PACKAGE"]
    unless_null $P5020, vivify_2183
    die "Contextual $*PACKAGE not found"
  vivify_2183:
  vivify_2182:
    find_dynamic_lex $P5023, "$*PKGDECL"
    unless_null $P5023, vivify_2184
    get_hll_global $P5021, "GLOBAL"
    get_who $P5022, $P5021
    set $P5023, $P5022["$PKGDECL"]
    unless_null $P5023, vivify_2185
    die "Contextual $*PKGDECL not found"
  vivify_2185:
  vivify_2184:
    concat $P5024, $P5023, "-attr"
    find_dynamic_lex $P5027, "%*HOW"
    unless_null $P5027, vivify_2186
    get_hll_global $P5025, "GLOBAL"
    get_who $P5026, $P5025
    set $P5027, $P5026["%HOW"]
    unless_null $P5027, vivify_2187
    die "Contextual %*HOW not found"
  vivify_2187:
  vivify_2186:
    set $P5028, $P5027[$P5024]
    unless_null $P5028, vivify_2188
    new $P5028, "Undef"
  vivify_2188:
    find_lex $P5029, "%lit_args"
    unless_null $P5029, vivify_2189
    $P5029 = root_new ['parrot';'Hash']
  vivify_2189:
    find_lex $P5030, "%obj_args"
    unless_null $P5030, vivify_2190
    $P5030 = root_new ['parrot';'Hash']
  vivify_2190:
    $P5017."pkg_add_attribute"($P5020, $P5028, $P5029, $P5030)
.annotate 'line', 1406
    get_hll_global $P5031, "GLOBAL"
    nqp_get_package_through_who $P5032, $P5031, "PAST"
    get_who $P5033, $P5032
    set $P5034, $P5033["Stmts"]
    $P5035 = $P5034."new"()
    store_lex "$past", $P5035
.annotate 'line', 1388
    .return ($P5035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("506_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5072
    .param pmc param_5073
.annotate 'line', 1428
    .lex "self", param_5072
    .lex "$/", param_5073
    find_lex $P5074, "$/"
    find_lex $P5075, "$/"
    unless_null $P5075, vivify_2192
    $P5075 = root_new ['parrot';'Hash']
  vivify_2192:
    set $P5076, $P5075["routine_def"]
    unless_null $P5076, vivify_2193
    new $P5076, "Undef"
  vivify_2193:
    $P5077 = $P5076."ast"()
    $P5078 = $P5074."!make"($P5077)
    .return ($P5078)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("507_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5080
    .param pmc param_5081
.annotate 'line', 1429
    .lex "self", param_5080
    .lex "$/", param_5081
    find_lex $P5082, "$/"
    find_lex $P5083, "$/"
    unless_null $P5083, vivify_2194
    $P5083 = root_new ['parrot';'Hash']
  vivify_2194:
    set $P5084, $P5083["method_def"]
    unless_null $P5084, vivify_2195
    new $P5084, "Undef"
  vivify_2195:
    $P5085 = $P5084."ast"()
    $P5086 = $P5082."!make"($P5085)
    .return ($P5086)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("508_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5088
    .param pmc param_5089
.annotate 'line', 1431
    .const 'Sub' $P5402 = "514_1303923618.727" 
    capture_lex $P5402
    .const 'Sub' $P5111 = "509_1303923618.727" 
    capture_lex $P5111
    .lex "self", param_5088
    .lex "$/", param_5089
.annotate 'line', 1434
    new $P5090, "Undef"
    .lex "$past", $P5090
.annotate 'line', 1445
    new $P5091, "Undef"
    .lex "$block", $P5091
.annotate 'line', 1431
    find_lex $P5092, "$past"
    unless_null $P5092, vivify_2196
    new $P5092, "Undef"
  vivify_2196:
.annotate 'line', 1435
    find_lex $P5094, "$/"
    unless_null $P5094, vivify_2197
    $P5094 = root_new ['parrot';'Hash']
  vivify_2197:
    set $P5095, $P5094["onlystar"]
    unless_null $P5095, vivify_2198
    new $P5095, "Undef"
  vivify_2198:
    if $P5095, if_5093
.annotate 'line', 1439
    find_lex $P5097, "$/"
    unless_null $P5097, vivify_2199
    $P5097 = root_new ['parrot';'Hash']
  vivify_2199:
    set $P5098, $P5097["blockoid"]
    unless_null $P5098, vivify_2200
    new $P5098, "Undef"
  vivify_2200:
    $P5099 = $P5098."ast"()
    store_lex "$past", $P5099
.annotate 'line', 1440
    find_lex $P5100, "$past"
    unless_null $P5100, vivify_2201
    new $P5100, "Undef"
  vivify_2201:
    $P5100."blocktype"("declaration")
.annotate 'line', 1441
    find_dynamic_lex $P5104, "$*RETURN_USED"
    unless_null $P5104, vivify_2202
    get_hll_global $P5102, "GLOBAL"
    get_who $P5103, $P5102
    set $P5104, $P5103["$RETURN_USED"]
    unless_null $P5104, vivify_2203
    die "Contextual $*RETURN_USED not found"
  vivify_2203:
  vivify_2202:
    unless $P5104, if_5101_end
.annotate 'line', 1442
    find_lex $P5105, "$past"
    unless_null $P5105, vivify_2204
    new $P5105, "Undef"
  vivify_2204:
    $P5105."control"("return_pir")
  if_5101_end:
.annotate 'line', 1438
    goto if_5093_end
  if_5093:
.annotate 'line', 1436
    $P5096 = "only_star_block"()
    store_lex "$past", $P5096
  if_5093_end:
.annotate 'line', 1445
    find_lex $P5106, "$past"
    unless_null $P5106, vivify_2205
    new $P5106, "Undef"
  vivify_2205:
    store_lex "$block", $P5106
.annotate 'line', 1447
    find_lex $P5108, "$/"
    unless_null $P5108, vivify_2206
    $P5108 = root_new ['parrot';'Hash']
  vivify_2206:
    set $P5109, $P5108["deflongname"]
    unless_null $P5109, vivify_2207
    new $P5109, "Undef"
  vivify_2207:
    unless $P5109, if_5107_end
    .const 'Sub' $P5111 = "509_1303923618.727" 
    capture_lex $P5111
    $P5111()
  if_5107_end:
.annotate 'line', 1548
    find_lex $P5391, "$block"
    unless_null $P5391, vivify_2313
    new $P5391, "Undef"
  vivify_2313:
    find_lex $P5392, "$past"
    unless_null $P5392, vivify_2314
    $P5392 = root_new ['parrot';'Hash']
    store_lex "$past", $P5392
  vivify_2314:
    set $P5392["block_past"], $P5391
.annotate 'line', 1549
    find_lex $P5394, "$/"
    unless_null $P5394, vivify_2315
    $P5394 = root_new ['parrot';'Hash']
  vivify_2315:
    set $P5395, $P5394["trait"]
    unless_null $P5395, vivify_2316
    new $P5395, "Undef"
  vivify_2316:
    unless $P5395, if_5393_end
.annotate 'line', 1550
    find_lex $P5397, "$/"
    unless_null $P5397, vivify_2317
    $P5397 = root_new ['parrot';'Hash']
  vivify_2317:
    set $P5398, $P5397["trait"]
    unless_null $P5398, vivify_2318
    new $P5398, "Undef"
  vivify_2318:
    defined $I5399, $P5398
    unless $I5399, for_undef_2319
    iter $P5396, $P5398
    new $P5409, 'ExceptionHandler'
    set_label $P5409, loop5408_handler
    $P5409."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5409
  loop5408_test:
    unless $P5396, loop5408_done
    shift $P5400, $P5396
  loop5408_redo:
    .const 'Sub' $P5402 = "514_1303923618.727" 
    capture_lex $P5402
    $P5402($P5400)
  loop5408_next:
    goto loop5408_test
  loop5408_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5410, exception, 'type'
    eq $P5410, .CONTROL_LOOP_NEXT, loop5408_next
    eq $P5410, .CONTROL_LOOP_REDO, loop5408_redo
  loop5408_done:
    pop_eh 
  for_undef_2319:
  if_5393_end:
.annotate 'line', 1553
    find_lex $P5411, "$/"
    find_lex $P5412, "$past"
    unless_null $P5412, vivify_2322
    new $P5412, "Undef"
  vivify_2322:
    $P5413 = $P5411."!make"($P5412)
.annotate 'line', 1431
    .return ($P5413)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5110"  :anon :subid("509_1303923618.727") :outer("508_1303923618.727")
.annotate 'line', 1447
    .const 'Sub' $P5265 = "513_1303923618.727" 
    capture_lex $P5265
    .const 'Sub' $P5152 = "510_1303923618.727" 
    capture_lex $P5152
.annotate 'line', 1448
    new $P5112, "Undef"
    .lex "$name", $P5112
    find_lex $P5113, "$/"
    unless_null $P5113, vivify_2208
    $P5113 = root_new ['parrot';'Hash']
  vivify_2208:
    set $P5114, $P5113["sigil"]
    unless_null $P5114, vivify_2209
    $P5114 = root_new ['parrot';'ResizablePMCArray']
  vivify_2209:
    set $P5115, $P5114[0]
    unless_null $P5115, vivify_2210
    new $P5115, "Undef"
  vivify_2210:
    set $S5116, $P5115
    new $P5117, 'String'
    set $P5117, $S5116
    find_lex $P5118, "$/"
    unless_null $P5118, vivify_2211
    $P5118 = root_new ['parrot';'Hash']
  vivify_2211:
    set $P5119, $P5118["deflongname"]
    unless_null $P5119, vivify_2212
    $P5119 = root_new ['parrot';'ResizablePMCArray']
  vivify_2212:
    set $P5120, $P5119[0]
    unless_null $P5120, vivify_2213
    new $P5120, "Undef"
  vivify_2213:
    $S5121 = $P5120."ast"()
    concat $P5122, $P5117, $S5121
    store_lex "$name", $P5122
.annotate 'line', 1449
    find_lex $P5123, "$past"
    unless_null $P5123, vivify_2214
    new $P5123, "Undef"
  vivify_2214:
    find_lex $P5124, "$name"
    unless_null $P5124, vivify_2215
    new $P5124, "Undef"
  vivify_2215:
    $P5123."name"($P5124)
.annotate 'line', 1450
    find_dynamic_lex $P5132, "$*SCOPE"
    unless_null $P5132, vivify_2216
    get_hll_global $P5130, "GLOBAL"
    get_who $P5131, $P5130
    set $P5132, $P5131["$SCOPE"]
    unless_null $P5132, vivify_2217
    die "Contextual $*SCOPE not found"
  vivify_2217:
  vivify_2216:
    set $S5133, $P5132
    iseq $I5134, $S5133, ""
    unless $I5134, unless_5129
    new $P5128, 'Integer'
    set $P5128, $I5134
    goto unless_5129_end
  unless_5129:
    find_dynamic_lex $P5137, "$*SCOPE"
    unless_null $P5137, vivify_2218
    get_hll_global $P5135, "GLOBAL"
    get_who $P5136, $P5135
    set $P5137, $P5136["$SCOPE"]
    unless_null $P5137, vivify_2219
    die "Contextual $*SCOPE not found"
  vivify_2219:
  vivify_2218:
    set $S5138, $P5137
    iseq $I5139, $S5138, "my"
    new $P5128, 'Integer'
    set $P5128, $I5139
  unless_5129_end:
    unless $P5128, unless_5127
    set $P5126, $P5128
    goto unless_5127_end
  unless_5127:
    find_dynamic_lex $P5142, "$*SCOPE"
    unless_null $P5142, vivify_2220
    get_hll_global $P5140, "GLOBAL"
    get_who $P5141, $P5140
    set $P5142, $P5141["$SCOPE"]
    unless_null $P5142, vivify_2221
    die "Contextual $*SCOPE not found"
  vivify_2221:
  vivify_2220:
    set $S5143, $P5142
    iseq $I5144, $S5143, "our"
    new $P5126, 'Integer'
    set $P5126, $I5144
  unless_5127_end:
    if $P5126, if_5125
.annotate 'line', 1538
    find_lex $P5372, "$/"
    unless_null $P5372, vivify_2222
    new $P5372, "Undef"
  vivify_2222:
    $P5373 = $P5372."CURSOR"()
    find_dynamic_lex $P5376, "$*SCOPE"
    unless_null $P5376, vivify_2223
    get_hll_global $P5374, "GLOBAL"
    get_who $P5375, $P5374
    set $P5376, $P5375["$SCOPE"]
    unless_null $P5376, vivify_2224
    die "Contextual $*SCOPE not found"
  vivify_2224:
  vivify_2223:
    concat $P5377, $P5376, " scoped routines are not supported yet"
    $P5373."panic"($P5377)
.annotate 'line', 1537
    goto if_5125_end
  if_5125:
.annotate 'line', 1451
    find_dynamic_lex $P5148, "$*MULTINESS"
    unless_null $P5148, vivify_2225
    get_hll_global $P5146, "GLOBAL"
    get_who $P5147, $P5146
    set $P5148, $P5147["$MULTINESS"]
    unless_null $P5148, vivify_2226
    die "Contextual $*MULTINESS not found"
  vivify_2226:
  vivify_2225:
    set $S5149, $P5148
    iseq $I5150, $S5149, "multi"
    if $I5150, if_5145
.annotate 'line', 1502
    find_dynamic_lex $P5261, "$*MULTINESS"
    unless_null $P5261, vivify_2227
    get_hll_global $P5259, "GLOBAL"
    get_who $P5260, $P5259
    set $P5261, $P5260["$MULTINESS"]
    unless_null $P5261, vivify_2228
    die "Contextual $*MULTINESS not found"
  vivify_2228:
  vivify_2227:
    set $S5262, $P5261
    iseq $I5263, $S5262, "proto"
    if $I5263, if_5258
.annotate 'line', 1521
    find_lex $P5315, "$?PACKAGE"
    get_who $P5316, $P5315
    set $P5317, $P5316["@BLOCK"]
    unless_null $P5317, vivify_2229
    $P5317 = root_new ['parrot';'ResizablePMCArray']
  vivify_2229:
    set $P5318, $P5317[0]
    unless_null $P5318, vivify_2230
    $P5318 = root_new ['parrot';'ResizablePMCArray']
  vivify_2230:
    set $P5319, $P5318[0]
    unless_null $P5319, vivify_2231
    new $P5319, "Undef"
  vivify_2231:
    get_hll_global $P5320, "GLOBAL"
    nqp_get_package_through_who $P5321, $P5320, "PAST"
    get_who $P5322, $P5321
    set $P5323, $P5322["Var"]
    find_lex $P5324, "$name"
    unless_null $P5324, vivify_2232
    new $P5324, "Undef"
  vivify_2232:
    find_lex $P5325, "$past"
    unless_null $P5325, vivify_2233
    new $P5325, "Undef"
  vivify_2233:
    $P5326 = $P5323."new"($P5324 :named("name"), 1 :named("isdecl"), $P5325 :named("viviself"), "lexical" :named("scope"))
    $P5319."push"($P5326)
.annotate 'line', 1523
    find_lex $P5327, "$?PACKAGE"
    get_who $P5328, $P5327
    set $P5329, $P5328["@BLOCK"]
    unless_null $P5329, vivify_2234
    $P5329 = root_new ['parrot';'ResizablePMCArray']
  vivify_2234:
    set $P5330, $P5329[0]
    unless_null $P5330, vivify_2235
    new $P5330, "Undef"
  vivify_2235:
    find_lex $P5331, "$name"
    unless_null $P5331, vivify_2236
    new $P5331, "Undef"
  vivify_2236:
    $P5330."symbol"($P5331, "lexical" :named("scope"))
.annotate 'line', 1524
    find_dynamic_lex $P5335, "$*SCOPE"
    unless_null $P5335, vivify_2237
    get_hll_global $P5333, "GLOBAL"
    get_who $P5334, $P5333
    set $P5335, $P5334["$SCOPE"]
    unless_null $P5335, vivify_2238
    die "Contextual $*SCOPE not found"
  vivify_2238:
  vivify_2237:
    set $S5336, $P5335
    iseq $I5337, $S5336, "our"
    unless $I5337, if_5332_end
.annotate 'line', 1527
    find_dynamic_lex $P5340, "$*SC"
    unless_null $P5340, vivify_2239
    get_hll_global $P5338, "GLOBAL"
    get_who $P5339, $P5338
    set $P5340, $P5339["$SC"]
    unless_null $P5340, vivify_2240
    die "Contextual $*SC not found"
  vivify_2240:
  vivify_2239:
    find_dynamic_lex $P5343, "$*PACKAGE"
    unless_null $P5343, vivify_2241
    get_hll_global $P5341, "GLOBAL"
    get_who $P5342, $P5341
    set $P5343, $P5342["$PACKAGE"]
    unless_null $P5343, vivify_2242
    die "Contextual $*PACKAGE not found"
  vivify_2242:
  vivify_2241:
    find_lex $P5344, "$name"
    unless_null $P5344, vivify_2243
    new $P5344, "Undef"
  vivify_2243:
    find_lex $P5345, "$past"
    unless_null $P5345, vivify_2244
    new $P5345, "Undef"
  vivify_2244:
    $P5340."install_package_routine"($P5343, $P5344, $P5345)
.annotate 'line', 1528
    find_lex $P5346, "$?PACKAGE"
    get_who $P5347, $P5346
    set $P5348, $P5347["@BLOCK"]
    unless_null $P5348, vivify_2245
    $P5348 = root_new ['parrot';'ResizablePMCArray']
  vivify_2245:
    set $P5349, $P5348[0]
    unless_null $P5349, vivify_2246
    $P5349 = root_new ['parrot';'ResizablePMCArray']
  vivify_2246:
    set $P5350, $P5349[0]
    unless_null $P5350, vivify_2247
    new $P5350, "Undef"
  vivify_2247:
    get_hll_global $P5351, "GLOBAL"
    nqp_get_package_through_who $P5352, $P5351, "PAST"
    get_who $P5353, $P5352
    set $P5354, $P5353["Op"]
.annotate 'line', 1530
    find_lex $P5355, "$name"
    unless_null $P5355, vivify_2248
    new $P5355, "Undef"
  vivify_2248:
    new $P5356, "ResizablePMCArray"
    push $P5356, $P5355
    find_lex $P5357, "$/"
    unless_null $P5357, vivify_2249
    new $P5357, "Undef"
  vivify_2249:
    $P5358 = "lexical_package_lookup"($P5356, $P5357)
.annotate 'line', 1531
    get_hll_global $P5359, "GLOBAL"
    nqp_get_package_through_who $P5360, $P5359, "PAST"
    get_who $P5361, $P5360
    set $P5362, $P5361["Var"]
    find_lex $P5363, "$name"
    unless_null $P5363, vivify_2250
    new $P5363, "Undef"
  vivify_2250:
    $P5364 = $P5362."new"($P5363 :named("name"), "lexical" :named("scope"))
    $P5365 = $P5354."new"($P5358, $P5364, "bind" :named("pasttype"))
.annotate 'line', 1528
    $P5350."push"($P5365)
  if_5332_end:
.annotate 'line', 1520
    goto if_5258_end
  if_5258:
.annotate 'line', 1502
    .const 'Sub' $P5265 = "513_1303923618.727" 
    capture_lex $P5265
    $P5265()
  if_5258_end:
    goto if_5145_end
  if_5145:
.annotate 'line', 1451
    .const 'Sub' $P5152 = "510_1303923618.727" 
    capture_lex $P5152
    $P5152()
  if_5145_end:
.annotate 'line', 1535
    get_hll_global $P5366, "GLOBAL"
    nqp_get_package_through_who $P5367, $P5366, "PAST"
    get_who $P5368, $P5367
    set $P5369, $P5368["Var"]
    find_lex $P5370, "$name"
    unless_null $P5370, vivify_2308
    new $P5370, "Undef"
  vivify_2308:
    $P5371 = $P5369."new"($P5370 :named("name"))
    store_lex "$past", $P5371
  if_5125_end:
.annotate 'line', 1542
    find_lex $P5382, "$name"
    unless_null $P5382, vivify_2309
    new $P5382, "Undef"
  vivify_2309:
    set $S5383, $P5382
    iseq $I5384, $S5383, "MAIN"
    if $I5384, if_5381
    new $P5380, 'Integer'
    set $P5380, $I5384
    goto if_5381_end
  if_5381:
    find_dynamic_lex $P5387, "$*MULTINESS"
    unless_null $P5387, vivify_2310
    get_hll_global $P5385, "GLOBAL"
    get_who $P5386, $P5385
    set $P5387, $P5386["$MULTINESS"]
    unless_null $P5387, vivify_2311
    die "Contextual $*MULTINESS not found"
  vivify_2311:
  vivify_2310:
    set $S5388, $P5387
    isne $I5389, $S5388, "multi"
    new $P5380, 'Integer'
    set $P5380, $I5389
  if_5381_end:
    if $P5380, if_5379
    set $P5378, $P5380
    goto if_5379_end
  if_5379:
.annotate 'line', 1543
    find_lex $P5390, "$block"
    unless_null $P5390, vivify_2312
    new $P5390, "Undef"
  vivify_2312:
    store_dynamic_lex "$*MAIN_SUB", $P5390
.annotate 'line', 1542
    set $P5378, $P5390
  if_5379_end:
.annotate 'line', 1447
    .return ($P5378)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5264"  :anon :subid("513_1303923618.727") :outer("509_1303923618.727")
.annotate 'line', 1507
    new $P5266, "Undef"
    .lex "$cholder", $P5266
.annotate 'line', 1506
    find_dynamic_lex $P5270, "$*SCOPE"
    unless_null $P5270, vivify_2251
    get_hll_global $P5268, "GLOBAL"
    get_who $P5269, $P5268
    set $P5270, $P5269["$SCOPE"]
    unless_null $P5270, vivify_2252
    die "Contextual $*SCOPE not found"
  vivify_2252:
  vivify_2251:
    set $S5271, $P5270
    iseq $I5272, $S5271, "our"
    unless $I5272, if_5267_end
    die "our-scoped protos not yet implemented"
  if_5267_end:
.annotate 'line', 1507
    get_hll_global $P5273, "GLOBAL"
    nqp_get_package_through_who $P5274, $P5273, "PAST"
    get_who $P5275, $P5274
    set $P5276, $P5275["Op"]
    $P5277 = $P5276."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5277
.annotate 'line', 1508
    find_lex $P5278, "$?PACKAGE"
    get_who $P5279, $P5278
    set $P5280, $P5279["@BLOCK"]
    unless_null $P5280, vivify_2253
    $P5280 = root_new ['parrot';'ResizablePMCArray']
  vivify_2253:
    set $P5281, $P5280[0]
    unless_null $P5281, vivify_2254
    $P5281 = root_new ['parrot';'ResizablePMCArray']
  vivify_2254:
    set $P5282, $P5281[0]
    unless_null $P5282, vivify_2255
    new $P5282, "Undef"
  vivify_2255:
    get_hll_global $P5283, "GLOBAL"
    nqp_get_package_through_who $P5284, $P5283, "PAST"
    get_who $P5285, $P5284
    set $P5286, $P5285["Var"]
    find_lex $P5287, "$name"
    unless_null $P5287, vivify_2256
    new $P5287, "Undef"
  vivify_2256:
    find_lex $P5288, "$past"
    unless_null $P5288, vivify_2257
    new $P5288, "Undef"
  vivify_2257:
    $P5289 = $P5286."new"($P5287 :named("name"), 1 :named("isdecl"), $P5288 :named("viviself"), "lexical" :named("scope"))
    $P5282."push"($P5289)
.annotate 'line', 1510
    find_lex $P5290, "$?PACKAGE"
    get_who $P5291, $P5290
    set $P5292, $P5291["@BLOCK"]
    unless_null $P5292, vivify_2258
    $P5292 = root_new ['parrot';'ResizablePMCArray']
  vivify_2258:
    set $P5293, $P5292[0]
    unless_null $P5293, vivify_2259
    $P5293 = root_new ['parrot';'ResizablePMCArray']
  vivify_2259:
    set $P5294, $P5293[0]
    unless_null $P5294, vivify_2260
    new $P5294, "Undef"
  vivify_2260:
    get_hll_global $P5295, "GLOBAL"
    nqp_get_package_through_who $P5296, $P5295, "PAST"
    get_who $P5297, $P5296
    set $P5298, $P5297["Op"]
.annotate 'line', 1512
    get_hll_global $P5299, "GLOBAL"
    nqp_get_package_through_who $P5300, $P5299, "PAST"
    get_who $P5301, $P5300
    set $P5302, $P5301["Var"]
    find_lex $P5303, "$name"
    unless_null $P5303, vivify_2261
    new $P5303, "Undef"
  vivify_2261:
    $P5304 = $P5302."new"($P5303 :named("name"))
    find_lex $P5305, "$cholder"
    unless_null $P5305, vivify_2262
    new $P5305, "Undef"
  vivify_2262:
    $P5306 = $P5298."new"($P5304, $P5305, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1510
    $P5294."push"($P5306)
.annotate 'line', 1515
    find_lex $P5307, "$?PACKAGE"
    get_who $P5308, $P5307
    set $P5309, $P5308["@BLOCK"]
    unless_null $P5309, vivify_2263
    $P5309 = root_new ['parrot';'ResizablePMCArray']
  vivify_2263:
    set $P5310, $P5309[0]
    unless_null $P5310, vivify_2264
    new $P5310, "Undef"
  vivify_2264:
    find_lex $P5311, "$name"
    unless_null $P5311, vivify_2265
    new $P5311, "Undef"
  vivify_2265:
    find_lex $P5312, "$cholder"
    unless_null $P5312, vivify_2266
    new $P5312, "Undef"
  vivify_2266:
    $P5310."symbol"($P5311, "lexical" :named("scope"), 1 :named("proto"), $P5312 :named("cholder"))
.annotate 'line', 1518
    find_lex $P5313, "$past"
    unless_null $P5313, vivify_2267
    new $P5313, "Undef"
  vivify_2267:
    $P5314 = $P5313."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1502
    .return ($P5314)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5151"  :anon :subid("510_1303923618.727") :outer("509_1303923618.727")
.annotate 'line', 1451
    .const 'Sub' $P5174 = "511_1303923618.727" 
    capture_lex $P5174
.annotate 'line', 1454
    new $P5153, "Undef"
    .lex "$cholder", $P5153
.annotate 'line', 1455
    $P5154 = root_new ['parrot';'Hash']
    .lex "%sym", $P5154
.annotate 'line', 1453
    find_dynamic_lex $P5158, "$*SCOPE"
    unless_null $P5158, vivify_2268
    get_hll_global $P5156, "GLOBAL"
    get_who $P5157, $P5156
    set $P5158, $P5157["$SCOPE"]
    unless_null $P5158, vivify_2269
    die "Contextual $*SCOPE not found"
  vivify_2269:
  vivify_2268:
    set $S5159, $P5158
    iseq $I5160, $S5159, "our"
    unless $I5160, if_5155_end
    die "our-scoped multis not yet implemented"
  if_5155_end:
    find_lex $P5161, "$cholder"
    unless_null $P5161, vivify_2270
    new $P5161, "Undef"
  vivify_2270:
.annotate 'line', 1455
    find_lex $P5162, "$?PACKAGE"
    get_who $P5163, $P5162
    set $P5164, $P5163["@BLOCK"]
    unless_null $P5164, vivify_2271
    $P5164 = root_new ['parrot';'ResizablePMCArray']
  vivify_2271:
    set $P5165, $P5164[0]
    unless_null $P5165, vivify_2272
    new $P5165, "Undef"
  vivify_2272:
    find_lex $P5166, "$name"
    unless_null $P5166, vivify_2273
    new $P5166, "Undef"
  vivify_2273:
    $P5167 = $P5165."symbol"($P5166)
    store_lex "%sym", $P5167
.annotate 'line', 1456
    find_lex $P5169, "%sym"
    unless_null $P5169, vivify_2274
    $P5169 = root_new ['parrot';'Hash']
  vivify_2274:
    set $P5170, $P5169["cholder"]
    unless_null $P5170, vivify_2275
    new $P5170, "Undef"
  vivify_2275:
    if $P5170, if_5168
.annotate 'line', 1461
    .const 'Sub' $P5174 = "511_1303923618.727" 
    capture_lex $P5174
    $P5174()
    goto if_5168_end
  if_5168:
.annotate 'line', 1457
    find_lex $P5171, "%sym"
    unless_null $P5171, vivify_2303
    $P5171 = root_new ['parrot';'Hash']
  vivify_2303:
    set $P5172, $P5171["cholder"]
    unless_null $P5172, vivify_2304
    new $P5172, "Undef"
  vivify_2304:
    store_lex "$cholder", $P5172
  if_5168_end:
.annotate 'line', 1497
    find_lex $P5254, "$cholder"
    unless_null $P5254, vivify_2305
    new $P5254, "Undef"
  vivify_2305:
    find_lex $P5255, "$past"
    unless_null $P5255, vivify_2306
    new $P5255, "Undef"
  vivify_2306:
    $P5254."push"($P5255)
.annotate 'line', 1500
    find_lex $P5256, "$past"
    unless_null $P5256, vivify_2307
    new $P5256, "Undef"
  vivify_2307:
    $P5257 = "attach_multi_signature"($P5256)
.annotate 'line', 1451
    .return ($P5257)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5173"  :anon :subid("511_1303923618.727") :outer("510_1303923618.727")
.annotate 'line', 1461
    .const 'Sub' $P5190 = "512_1303923618.727" 
    capture_lex $P5190
.annotate 'line', 1468
    new $P5175, "Undef"
    .lex "$found_proto", $P5175
.annotate 'line', 1486
    new $P5176, "Undef"
    .lex "$dispatch_setup", $P5176
.annotate 'line', 1463
    find_lex $P5178, "%sym"
    unless_null $P5178, vivify_2276
    $P5178 = root_new ['parrot';'Hash']
  vivify_2276:
    set $P5179, $P5178["proto"]
    unless_null $P5179, vivify_2277
    new $P5179, "Undef"
  vivify_2277:
    unless $P5179, if_5177_end
.annotate 'line', 1466
    find_lex $P5180, "$/"
    unless_null $P5180, vivify_2278
    new $P5180, "Undef"
  vivify_2278:
    $P5181 = $P5180."CURSOR"()
    $P5181."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_5177_end:
.annotate 'line', 1463
    find_lex $P5182, "$found_proto"
    unless_null $P5182, vivify_2279
    new $P5182, "Undef"
  vivify_2279:
.annotate 'line', 1469
    find_lex $P5184, "$?PACKAGE"
    get_who $P5185, $P5184
    set $P5186, $P5185["@BLOCK"]
    unless_null $P5186, vivify_2280
    $P5186 = root_new ['parrot';'ResizablePMCArray']
  vivify_2280:
    defined $I5187, $P5186
    unless $I5187, for_undef_2281
    iter $P5183, $P5186
    new $P5212, 'ExceptionHandler'
    set_label $P5212, loop5211_handler
    $P5212."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5212
  loop5211_test:
    unless $P5183, loop5211_done
    shift $P5188, $P5183
  loop5211_redo:
    .const 'Sub' $P5190 = "512_1303923618.727" 
    capture_lex $P5190
    $P5190($P5188)
  loop5211_next:
    goto loop5211_test
  loop5211_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5213, exception, 'type'
    eq $P5213, .CONTROL_LOOP_NEXT, loop5211_next
    eq $P5213, .CONTROL_LOOP_REDO, loop5211_redo
  loop5211_done:
    pop_eh 
  for_undef_2281:
.annotate 'line', 1480
    find_lex $P5215, "$found_proto"
    unless_null $P5215, vivify_2290
    new $P5215, "Undef"
  vivify_2290:
    if $P5215, unless_5214_end
.annotate 'line', 1481
    find_lex $P5216, "$/"
    unless_null $P5216, vivify_2291
    new $P5216, "Undef"
  vivify_2291:
    $P5217 = $P5216."CURSOR"()
    $P5217."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_5214_end:
.annotate 'line', 1485
    get_hll_global $P5218, "GLOBAL"
    nqp_get_package_through_who $P5219, $P5218, "PAST"
    get_who $P5220, $P5219
    set $P5221, $P5220["Op"]
    $P5222 = $P5221."new"("list" :named("pasttype"))
    store_lex "$cholder", $P5222
.annotate 'line', 1486
    get_hll_global $P5223, "GLOBAL"
    nqp_get_package_through_who $P5224, $P5223, "PAST"
    get_who $P5225, $P5224
    set $P5226, $P5225["Op"]
.annotate 'line', 1488
    get_hll_global $P5227, "GLOBAL"
    nqp_get_package_through_who $P5228, $P5227, "PAST"
    get_who $P5229, $P5228
    set $P5230, $P5229["Var"]
    find_lex $P5231, "$name"
    unless_null $P5231, vivify_2292
    new $P5231, "Undef"
  vivify_2292:
    $P5232 = $P5230."new"($P5231 :named("name"), "outer" :named("scope"))
    find_lex $P5233, "$cholder"
    unless_null $P5233, vivify_2293
    new $P5233, "Undef"
  vivify_2293:
    $P5234 = $P5226."new"($P5232, $P5233, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1486
    store_lex "$dispatch_setup", $P5234
.annotate 'line', 1491
    find_lex $P5235, "$?PACKAGE"
    get_who $P5236, $P5235
    set $P5237, $P5236["@BLOCK"]
    unless_null $P5237, vivify_2294
    $P5237 = root_new ['parrot';'ResizablePMCArray']
  vivify_2294:
    set $P5238, $P5237[0]
    unless_null $P5238, vivify_2295
    $P5238 = root_new ['parrot';'ResizablePMCArray']
  vivify_2295:
    set $P5239, $P5238[0]
    unless_null $P5239, vivify_2296
    new $P5239, "Undef"
  vivify_2296:
    get_hll_global $P5240, "GLOBAL"
    nqp_get_package_through_who $P5241, $P5240, "PAST"
    get_who $P5242, $P5241
    set $P5243, $P5242["Var"]
    find_lex $P5244, "$name"
    unless_null $P5244, vivify_2297
    new $P5244, "Undef"
  vivify_2297:
    find_lex $P5245, "$dispatch_setup"
    unless_null $P5245, vivify_2298
    new $P5245, "Undef"
  vivify_2298:
    $P5246 = $P5243."new"($P5244 :named("name"), 1 :named("isdecl"), $P5245 :named("viviself"), "lexical" :named("scope"))
    $P5239."push"($P5246)
.annotate 'line', 1493
    find_lex $P5247, "$?PACKAGE"
    get_who $P5248, $P5247
    set $P5249, $P5248["@BLOCK"]
    unless_null $P5249, vivify_2299
    $P5249 = root_new ['parrot';'ResizablePMCArray']
  vivify_2299:
    set $P5250, $P5249[0]
    unless_null $P5250, vivify_2300
    new $P5250, "Undef"
  vivify_2300:
    find_lex $P5251, "$name"
    unless_null $P5251, vivify_2301
    new $P5251, "Undef"
  vivify_2301:
    find_lex $P5252, "$cholder"
    unless_null $P5252, vivify_2302
    new $P5252, "Undef"
  vivify_2302:
    $P5253 = $P5250."symbol"($P5251, "lexical" :named("scope"), $P5252 :named("cholder"))
.annotate 'line', 1461
    .return ($P5253)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5189"  :anon :subid("512_1303923618.727") :outer("511_1303923618.727")
    .param pmc param_5192
.annotate 'line', 1470
    $P5191 = root_new ['parrot';'Hash']
    .lex "%sym", $P5191
    .lex "$_", param_5192
    find_lex $P5193, "$_"
    unless_null $P5193, vivify_2282
    new $P5193, "Undef"
  vivify_2282:
    find_lex $P5194, "$name"
    unless_null $P5194, vivify_2283
    new $P5194, "Undef"
  vivify_2283:
    $P5195 = $P5193."symbol"($P5194)
    store_lex "%sym", $P5195
.annotate 'line', 1471
    find_lex $P5200, "%sym"
    unless_null $P5200, vivify_2284
    $P5200 = root_new ['parrot';'Hash']
  vivify_2284:
    set $P5201, $P5200["proto"]
    unless_null $P5201, vivify_2285
    new $P5201, "Undef"
  vivify_2285:
    unless $P5201, unless_5199
    set $P5198, $P5201
    goto unless_5199_end
  unless_5199:
    find_lex $P5202, "%sym"
    unless_null $P5202, vivify_2286
    $P5202 = root_new ['parrot';'Hash']
  vivify_2286:
    set $P5203, $P5202["cholder"]
    unless_null $P5203, vivify_2287
    new $P5203, "Undef"
  vivify_2287:
    set $P5198, $P5203
  unless_5199_end:
    if $P5198, if_5197
.annotate 'line', 1474
    find_lex $P5207, "%sym"
    unless_null $P5207, vivify_2288
    $P5207 = root_new ['parrot';'Hash']
  vivify_2288:
    if $P5207, if_5206
    set $P5205, $P5207
    goto if_5206_end
  if_5206:
.annotate 'line', 1475
    find_lex $P5208, "$/"
    unless_null $P5208, vivify_2289
    new $P5208, "Undef"
  vivify_2289:
    $P5209 = $P5208."CURSOR"()
    $P5210 = $P5209."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1474
    set $P5205, $P5210
  if_5206_end:
    set $P5196, $P5205
.annotate 'line', 1471
    goto if_5197_end
  if_5197:
.annotate 'line', 1472
    new $P5204, "Integer"
    assign $P5204, 1
    store_lex "$found_proto", $P5204
.annotate 'line', 1471
    set $P5196, $P5204
  if_5197_end:
.annotate 'line', 1469
    .return ($P5196)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5401"  :anon :subid("514_1303923618.727") :outer("508_1303923618.727")
    .param pmc param_5403
.annotate 'line', 1550
    .lex "$_", param_5403
    find_lex $P5404, "$_"
    unless_null $P5404, vivify_2320
    new $P5404, "Undef"
  vivify_2320:
    $P5405 = $P5404."ast"()
    find_lex $P5406, "$/"
    unless_null $P5406, vivify_2321
    new $P5406, "Undef"
  vivify_2321:
    $P5407 = $P5405($P5406)
    .return ($P5407)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("515_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5415
    .param pmc param_5416
.annotate 'line', 1557
    .const 'Sub' $P5584 = "517_1303923618.727" 
    capture_lex $P5584
    .const 'Sub' $P5452 = "516_1303923618.727" 
    capture_lex $P5452
    .lex "self", param_5415
    .lex "$/", param_5416
.annotate 'line', 1560
    new $P5417, "Undef"
    .lex "$past", $P5417
.annotate 'line', 1557
    find_lex $P5418, "$past"
    unless_null $P5418, vivify_2323
    new $P5418, "Undef"
  vivify_2323:
.annotate 'line', 1561
    find_lex $P5420, "$/"
    unless_null $P5420, vivify_2324
    $P5420 = root_new ['parrot';'Hash']
  vivify_2324:
    set $P5421, $P5420["onlystar"]
    unless_null $P5421, vivify_2325
    new $P5421, "Undef"
  vivify_2325:
    if $P5421, if_5419
.annotate 'line', 1565
    find_lex $P5423, "$/"
    unless_null $P5423, vivify_2326
    $P5423 = root_new ['parrot';'Hash']
  vivify_2326:
    set $P5424, $P5423["blockoid"]
    unless_null $P5424, vivify_2327
    new $P5424, "Undef"
  vivify_2327:
    $P5425 = $P5424."ast"()
    store_lex "$past", $P5425
.annotate 'line', 1566
    find_lex $P5426, "$past"
    unless_null $P5426, vivify_2328
    new $P5426, "Undef"
  vivify_2328:
    $P5426."blocktype"("declaration")
.annotate 'line', 1567
    find_dynamic_lex $P5430, "$*RETURN_USED"
    unless_null $P5430, vivify_2329
    get_hll_global $P5428, "GLOBAL"
    get_who $P5429, $P5428
    set $P5430, $P5429["$RETURN_USED"]
    unless_null $P5430, vivify_2330
    die "Contextual $*RETURN_USED not found"
  vivify_2330:
  vivify_2329:
    unless $P5430, if_5427_end
.annotate 'line', 1568
    find_lex $P5431, "$past"
    unless_null $P5431, vivify_2331
    new $P5431, "Undef"
  vivify_2331:
    $P5431."control"("return_pir")
  if_5427_end:
.annotate 'line', 1564
    goto if_5419_end
  if_5419:
.annotate 'line', 1562
    $P5422 = "only_star_block"()
    store_lex "$past", $P5422
  if_5419_end:
.annotate 'line', 1573
    find_lex $P5433, "$past"
    unless_null $P5433, vivify_2332
    $P5433 = root_new ['parrot';'Hash']
  vivify_2332:
    set $P5434, $P5433["signature_has_invocant"]
    unless_null $P5434, vivify_2333
    new $P5434, "Undef"
  vivify_2333:
    if $P5434, unless_5432_end
.annotate 'line', 1574
    find_lex $P5435, "$past"
    unless_null $P5435, vivify_2334
    $P5435 = root_new ['parrot';'ResizablePMCArray']
  vivify_2334:
    set $P5436, $P5435[0]
    unless_null $P5436, vivify_2335
    new $P5436, "Undef"
  vivify_2335:
    get_hll_global $P5437, "GLOBAL"
    nqp_get_package_through_who $P5438, $P5437, "PAST"
    get_who $P5439, $P5438
    set $P5440, $P5439["Var"]
.annotate 'line', 1576
    get_hll_global $P5441, "GLOBAL"
    nqp_get_package_through_who $P5442, $P5441, "PAST"
    get_who $P5443, $P5442
    set $P5444, $P5443["Var"]
    $P5445 = $P5444."new"("$?CLASS" :named("name"))
    $P5446 = $P5440."new"("self" :named("name"), "parameter" :named("scope"), $P5445 :named("multitype"))
.annotate 'line', 1574
    $P5436."unshift"($P5446)
  unless_5432_end:
.annotate 'line', 1579
    find_lex $P5447, "$past"
    unless_null $P5447, vivify_2336
    new $P5447, "Undef"
  vivify_2336:
    $P5447."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1582
    find_lex $P5449, "$/"
    unless_null $P5449, vivify_2337
    $P5449 = root_new ['parrot';'Hash']
  vivify_2337:
    set $P5450, $P5449["deflongname"]
    unless_null $P5450, vivify_2338
    new $P5450, "Undef"
  vivify_2338:
    unless $P5450, if_5448_end
    .const 'Sub' $P5452 = "516_1303923618.727" 
    capture_lex $P5452
    $P5452()
  if_5448_end:
.annotate 'line', 1623
    find_lex $P5570, "$/"
    find_lex $P5571, "$past"
    unless_null $P5571, vivify_2372
    new $P5571, "Undef"
  vivify_2372:
    $P5570."!make"($P5571)
.annotate 'line', 1624
    find_lex $P5572, "$past"
    unless_null $P5572, vivify_2373
    new $P5572, "Undef"
  vivify_2373:
    find_lex $P5573, "$past"
    unless_null $P5573, vivify_2374
    $P5573 = root_new ['parrot';'Hash']
    store_lex "$past", $P5573
  vivify_2374:
    set $P5573["block_past"], $P5572
.annotate 'line', 1625
    find_lex $P5576, "$/"
    unless_null $P5576, vivify_2375
    $P5576 = root_new ['parrot';'Hash']
  vivify_2375:
    set $P5577, $P5576["trait"]
    unless_null $P5577, vivify_2376
    new $P5577, "Undef"
  vivify_2376:
    if $P5577, if_5575
    set $P5574, $P5577
    goto if_5575_end
  if_5575:
.annotate 'line', 1626
    find_lex $P5579, "$/"
    unless_null $P5579, vivify_2377
    $P5579 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P5580, $P5579["trait"]
    unless_null $P5580, vivify_2378
    new $P5580, "Undef"
  vivify_2378:
    defined $I5581, $P5580
    unless $I5581, for_undef_2379
    iter $P5578, $P5580
    new $P5591, 'ExceptionHandler'
    set_label $P5591, loop5590_handler
    $P5591."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5591
  loop5590_test:
    unless $P5578, loop5590_done
    shift $P5582, $P5578
  loop5590_redo:
    .const 'Sub' $P5584 = "517_1303923618.727" 
    capture_lex $P5584
    $P5584($P5582)
  loop5590_next:
    goto loop5590_test
  loop5590_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5592, exception, 'type'
    eq $P5592, .CONTROL_LOOP_NEXT, loop5590_next
    eq $P5592, .CONTROL_LOOP_REDO, loop5590_redo
  loop5590_done:
    pop_eh 
  for_undef_2379:
.annotate 'line', 1625
    set $P5574, $P5578
  if_5575_end:
.annotate 'line', 1557
    .return ($P5574)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5451"  :anon :subid("516_1303923618.727") :outer("515_1303923618.727")
.annotate 'line', 1584
    new $P5453, "Undef"
    .lex "$name", $P5453
.annotate 'line', 1589
    new $P5454, "Undef"
    .lex "$to_add", $P5454
.annotate 'line', 1584
    find_lex $P5455, "$/"
    unless_null $P5455, vivify_2339
    $P5455 = root_new ['parrot';'Hash']
  vivify_2339:
    set $P5456, $P5455["private"]
    unless_null $P5456, vivify_2340
    new $P5456, "Undef"
  vivify_2340:
    set $S5457, $P5456
    new $P5458, 'String'
    set $P5458, $S5457
    find_lex $P5459, "$/"
    unless_null $P5459, vivify_2341
    $P5459 = root_new ['parrot';'Hash']
  vivify_2341:
    set $P5460, $P5459["deflongname"]
    unless_null $P5460, vivify_2342
    $P5460 = root_new ['parrot';'ResizablePMCArray']
  vivify_2342:
    set $P5461, $P5460[0]
    unless_null $P5461, vivify_2343
    new $P5461, "Undef"
  vivify_2343:
    $P5462 = $P5461."ast"()
    set $S5463, $P5462
    concat $P5464, $P5458, $S5463
    store_lex "$name", $P5464
.annotate 'line', 1585
    find_lex $P5465, "$past"
    unless_null $P5465, vivify_2344
    new $P5465, "Undef"
  vivify_2344:
    find_lex $P5466, "$name"
    unless_null $P5466, vivify_2345
    new $P5466, "Undef"
  vivify_2345:
    $P5465."name"($P5466)
.annotate 'line', 1589
    find_dynamic_lex $P5471, "$*MULTINESS"
    unless_null $P5471, vivify_2346
    get_hll_global $P5469, "GLOBAL"
    get_who $P5470, $P5469
    set $P5471, $P5470["$MULTINESS"]
    unless_null $P5471, vivify_2347
    die "Contextual $*MULTINESS not found"
  vivify_2347:
  vivify_2346:
    set $S5472, $P5471
    isne $I5473, $S5472, "proto"
    if $I5473, if_5468
.annotate 'line', 1591
    get_hll_global $P5480, "GLOBAL"
    nqp_get_package_through_who $P5481, $P5480, "PAST"
    get_who $P5482, $P5481
    set $P5483, $P5482["Op"]
.annotate 'line', 1593
    get_hll_global $P5484, "GLOBAL"
    nqp_get_package_through_who $P5485, $P5484, "PAST"
    get_who $P5486, $P5485
    set $P5487, $P5486["Val"]
    find_lex $P5488, "$past"
    unless_null $P5488, vivify_2348
    new $P5488, "Undef"
  vivify_2348:
    $P5489 = $P5487."new"($P5488 :named("value"))
.annotate 'line', 1594
    get_hll_global $P5490, "GLOBAL"
    nqp_get_package_through_who $P5491, $P5490, "PAST"
    get_who $P5492, $P5491
    set $P5493, $P5492["Op"]
    $P5494 = $P5493."new"("list" :named("pasttype"))
    $P5495 = $P5483."new"($P5489, $P5494, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1591
    set $P5467, $P5495
.annotate 'line', 1589
    goto if_5468_end
  if_5468:
.annotate 'line', 1590
    get_hll_global $P5474, "GLOBAL"
    nqp_get_package_through_who $P5475, $P5474, "PAST"
    get_who $P5476, $P5475
    set $P5477, $P5476["Val"]
    find_lex $P5478, "$past"
    unless_null $P5478, vivify_2349
    new $P5478, "Undef"
  vivify_2349:
    $P5479 = $P5477."new"($P5478 :named("value"))
    set $P5467, $P5479
  if_5468_end:
.annotate 'line', 1589
    store_lex "$to_add", $P5467
.annotate 'line', 1596
    find_dynamic_lex $P5499, "$*MULTINESS"
    unless_null $P5499, vivify_2350
    get_hll_global $P5497, "GLOBAL"
    get_who $P5498, $P5497
    set $P5499, $P5498["$MULTINESS"]
    unless_null $P5499, vivify_2351
    die "Contextual $*MULTINESS not found"
  vivify_2351:
  vivify_2350:
    set $S5500, $P5499
    iseq $I5501, $S5500, "proto"
    unless $I5501, if_5496_end
    find_lex $P5502, "$past"
    unless_null $P5502, vivify_2352
    new $P5502, "Undef"
  vivify_2352:
    $P5502."pirflags"(":instanceof(\"DispatcherSub\")")
  if_5496_end:
.annotate 'line', 1600
    find_dynamic_lex $P5506, "$*MULTINESS"
    unless_null $P5506, vivify_2353
    get_hll_global $P5504, "GLOBAL"
    get_who $P5505, $P5504
    set $P5506, $P5505["$MULTINESS"]
    unless_null $P5506, vivify_2354
    die "Contextual $*MULTINESS not found"
  vivify_2354:
  vivify_2353:
    set $S5507, $P5506
    iseq $I5508, $S5507, "multi"
    unless $I5508, if_5503_end
    find_lex $P5509, "$past"
    unless_null $P5509, vivify_2355
    new $P5509, "Undef"
  vivify_2355:
    "attach_multi_signature"($P5509)
  if_5503_end:
.annotate 'line', 1603
    find_dynamic_lex $P5513, "$*PACKAGE-SETUP"
    unless_null $P5513, vivify_2356
    get_hll_global $P5511, "GLOBAL"
    get_who $P5512, $P5511
    set $P5513, $P5512["$PACKAGE-SETUP"]
    unless_null $P5513, vivify_2357
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2357:
  vivify_2356:
    defined $I5514, $P5513
    unless $I5514, if_5510_end
.annotate 'line', 1604
    find_dynamic_lex $P5517, "$*PACKAGE-SETUP"
    unless_null $P5517, vivify_2358
    get_hll_global $P5515, "GLOBAL"
    get_who $P5516, $P5515
    set $P5517, $P5516["$PACKAGE-SETUP"]
    unless_null $P5517, vivify_2359
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2359:
  vivify_2358:
    get_hll_global $P5518, "GLOBAL"
    nqp_get_package_through_who $P5519, $P5518, "PAST"
    get_who $P5520, $P5519
    set $P5521, $P5520["Op"]
.annotate 'line', 1605
    find_dynamic_lex $P5526, "$*MULTINESS"
    unless_null $P5526, vivify_2360
    get_hll_global $P5524, "GLOBAL"
    get_who $P5525, $P5524
    set $P5526, $P5525["$MULTINESS"]
    unless_null $P5526, vivify_2361
    die "Contextual $*MULTINESS not found"
  vivify_2361:
  vivify_2360:
    set $S5527, $P5526
    iseq $I5528, $S5527, "multi"
    if $I5528, if_5523
    new $P5530, "String"
    assign $P5530, "add_method"
    set $P5522, $P5530
    goto if_5523_end
  if_5523:
    new $P5529, "String"
    assign $P5529, "add_multi_method"
    set $P5522, $P5529
  if_5523_end:
.annotate 'line', 1606
    get_hll_global $P5531, "GLOBAL"
    nqp_get_package_through_who $P5532, $P5531, "PAST"
    get_who $P5533, $P5532
    set $P5534, $P5533["Op"]
.annotate 'line', 1609
    get_hll_global $P5535, "GLOBAL"
    nqp_get_package_through_who $P5536, $P5535, "PAST"
    get_who $P5537, $P5536
    set $P5538, $P5537["Var"]
    $P5539 = $P5538."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5540 = $P5534."new"($P5539, "get_how PP" :named("pirop"))
.annotate 'line', 1611
    get_hll_global $P5541, "GLOBAL"
    nqp_get_package_through_who $P5542, $P5541, "PAST"
    get_who $P5543, $P5542
    set $P5544, $P5543["Var"]
    $P5545 = $P5544."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1612
    get_hll_global $P5546, "GLOBAL"
    nqp_get_package_through_who $P5547, $P5546, "PAST"
    get_who $P5548, $P5547
    set $P5549, $P5548["Val"]
    find_lex $P5550, "$name"
    unless_null $P5550, vivify_2362
    new $P5550, "Undef"
  vivify_2362:
    $P5551 = $P5549."new"($P5550 :named("value"))
    find_lex $P5552, "$to_add"
    unless_null $P5552, vivify_2363
    new $P5552, "Undef"
  vivify_2363:
    $P5553 = $P5521."new"($P5540, $P5545, $P5551, $P5552, "callmethod" :named("pasttype"), $P5522 :named("name"))
.annotate 'line', 1604
    $P5517."push"($P5553)
  if_5510_end:
.annotate 'line', 1617
    find_dynamic_lex $P5558, "$*SCOPE"
    unless_null $P5558, vivify_2364
    get_hll_global $P5556, "GLOBAL"
    get_who $P5557, $P5556
    set $P5558, $P5557["$SCOPE"]
    unless_null $P5558, vivify_2365
    die "Contextual $*SCOPE not found"
  vivify_2365:
  vivify_2364:
    set $S5559, $P5558
    iseq $I5560, $S5559, "our"
    if $I5560, if_5555
    new $P5554, 'Integer'
    set $P5554, $I5560
    goto if_5555_end
  if_5555:
.annotate 'line', 1618
    find_dynamic_lex $P5563, "$*SC"
    unless_null $P5563, vivify_2366
    get_hll_global $P5561, "GLOBAL"
    get_who $P5562, $P5561
    set $P5563, $P5562["$SC"]
    unless_null $P5563, vivify_2367
    die "Contextual $*SC not found"
  vivify_2367:
  vivify_2366:
    find_dynamic_lex $P5566, "$*PACKAGE"
    unless_null $P5566, vivify_2368
    get_hll_global $P5564, "GLOBAL"
    get_who $P5565, $P5564
    set $P5566, $P5565["$PACKAGE"]
    unless_null $P5566, vivify_2369
    die "Contextual $*PACKAGE not found"
  vivify_2369:
  vivify_2368:
    find_lex $P5567, "$name"
    unless_null $P5567, vivify_2370
    new $P5567, "Undef"
  vivify_2370:
    find_lex $P5568, "$past"
    unless_null $P5568, vivify_2371
    new $P5568, "Undef"
  vivify_2371:
    $P5569 = $P5563."install_package_routine"($P5566, $P5567, $P5568)
.annotate 'line', 1617
    set $P5554, $P5569
  if_5555_end:
.annotate 'line', 1582
    .return ($P5554)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5583"  :anon :subid("517_1303923618.727") :outer("515_1303923618.727")
    .param pmc param_5585
.annotate 'line', 1626
    .lex "$_", param_5585
    find_lex $P5586, "$_"
    unless_null $P5586, vivify_2380
    new $P5586, "Undef"
  vivify_2380:
    $P5587 = $P5586."ast"()
    find_lex $P5588, "$/"
    unless_null $P5588, vivify_2381
    new $P5588, "Undef"
  vivify_2381:
    $P5589 = $P5587($P5588)
    .return ($P5589)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("518_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5596
    .param pmc param_5597
.annotate 'line', 1658
    .const 'Sub' $P5640 = "520_1303923618.727" 
    capture_lex $P5640
    .const 'Sub' $P5608 = "519_1303923618.727" 
    capture_lex $P5608
    .lex "self", param_5596
    .lex "$/", param_5597
.annotate 'line', 1659
    new $P5598, "Undef"
    .lex "$BLOCKINIT", $P5598
    find_lex $P5599, "$?PACKAGE"
    get_who $P5600, $P5599
    set $P5601, $P5600["@BLOCK"]
    unless_null $P5601, vivify_2382
    $P5601 = root_new ['parrot';'ResizablePMCArray']
  vivify_2382:
    set $P5602, $P5601[0]
    unless_null $P5602, vivify_2383
    $P5602 = root_new ['parrot';'ResizablePMCArray']
  vivify_2383:
    set $P5603, $P5602[0]
    unless_null $P5603, vivify_2384
    new $P5603, "Undef"
  vivify_2384:
    store_lex "$BLOCKINIT", $P5603
.annotate 'line', 1660
    find_lex $P5605, "$/"
    unless_null $P5605, vivify_2385
    $P5605 = root_new ['parrot';'Hash']
  vivify_2385:
    set $P5606, $P5605["invocant"]
    unless_null $P5606, vivify_2386
    new $P5606, "Undef"
  vivify_2386:
    unless $P5606, if_5604_end
    .const 'Sub' $P5608 = "519_1303923618.727" 
    capture_lex $P5608
    $P5608()
  if_5604_end:
.annotate 'line', 1669
    find_lex $P5635, "$/"
    unless_null $P5635, vivify_2396
    $P5635 = root_new ['parrot';'Hash']
  vivify_2396:
    set $P5636, $P5635["parameter"]
    unless_null $P5636, vivify_2397
    new $P5636, "Undef"
  vivify_2397:
    defined $I5637, $P5636
    unless $I5637, for_undef_2398
    iter $P5634, $P5636
    new $P5647, 'ExceptionHandler'
    set_label $P5647, loop5646_handler
    $P5647."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5647
  loop5646_test:
    unless $P5634, loop5646_done
    shift $P5638, $P5634
  loop5646_redo:
    .const 'Sub' $P5640 = "520_1303923618.727" 
    capture_lex $P5640
    $P5640($P5638)
  loop5646_next:
    goto loop5646_test
  loop5646_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5648, exception, 'type'
    eq $P5648, .CONTROL_LOOP_NEXT, loop5646_next
    eq $P5648, .CONTROL_LOOP_REDO, loop5646_redo
  loop5646_done:
    pop_eh 
  for_undef_2398:
.annotate 'line', 1658
    .return ($P5634)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5607"  :anon :subid("519_1303923618.727") :outer("518_1303923618.727")
.annotate 'line', 1661
    new $P5609, "Undef"
    .lex "$inv", $P5609
    find_lex $P5610, "$/"
    unless_null $P5610, vivify_2387
    $P5610 = root_new ['parrot';'Hash']
  vivify_2387:
    set $P5611, $P5610["invocant"]
    unless_null $P5611, vivify_2388
    $P5611 = root_new ['parrot';'ResizablePMCArray']
  vivify_2388:
    set $P5612, $P5611[0]
    unless_null $P5612, vivify_2389
    new $P5612, "Undef"
  vivify_2389:
    $P5613 = $P5612."ast"()
    store_lex "$inv", $P5613
.annotate 'line', 1662
    find_lex $P5614, "$BLOCKINIT"
    unless_null $P5614, vivify_2390
    new $P5614, "Undef"
  vivify_2390:
    find_lex $P5615, "$inv"
    unless_null $P5615, vivify_2391
    new $P5615, "Undef"
  vivify_2391:
    $P5614."push"($P5615)
.annotate 'line', 1663
    find_lex $P5616, "$BLOCKINIT"
    unless_null $P5616, vivify_2392
    new $P5616, "Undef"
  vivify_2392:
    get_hll_global $P5617, "GLOBAL"
    nqp_get_package_through_who $P5618, $P5617, "PAST"
    get_who $P5619, $P5618
    set $P5620, $P5619["Var"]
.annotate 'line', 1665
    get_hll_global $P5621, "GLOBAL"
    nqp_get_package_through_who $P5622, $P5621, "PAST"
    get_who $P5623, $P5622
    set $P5624, $P5623["Var"]
    find_lex $P5625, "$inv"
    unless_null $P5625, vivify_2393
    new $P5625, "Undef"
  vivify_2393:
    $P5626 = $P5625."name"()
    $P5627 = $P5624."new"("lexical" :named("scope"), $P5626 :named("name"))
    $P5628 = $P5620."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P5627 :named("viviself"))
.annotate 'line', 1663
    $P5616."push"($P5628)
.annotate 'line', 1667
    new $P5629, "Integer"
    assign $P5629, 1
    find_lex $P5630, "$?PACKAGE"
    get_who $P5631, $P5630
    set $P5632, $P5631["@BLOCK"]
    unless_null $P5632, vivify_2394
    $P5632 = root_new ['parrot';'ResizablePMCArray']
    set $P5631["@BLOCK"], $P5632
  vivify_2394:
    set $P5633, $P5632[0]
    unless_null $P5633, vivify_2395
    $P5633 = root_new ['parrot';'Hash']
    set $P5632[0], $P5633
  vivify_2395:
    set $P5633["signature_has_invocant"], $P5629
.annotate 'line', 1660
    .return ($P5629)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5639"  :anon :subid("520_1303923618.727") :outer("518_1303923618.727")
    .param pmc param_5641
.annotate 'line', 1669
    .lex "$_", param_5641
    find_lex $P5642, "$BLOCKINIT"
    unless_null $P5642, vivify_2399
    new $P5642, "Undef"
  vivify_2399:
    find_lex $P5643, "$_"
    unless_null $P5643, vivify_2400
    new $P5643, "Undef"
  vivify_2400:
    $P5644 = $P5643."ast"()
    $P5645 = $P5642."push"($P5644)
    .return ($P5645)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("521_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5650
    .param pmc param_5651
.annotate 'line', 1672
    .lex "self", param_5650
    .lex "$/", param_5651
.annotate 'line', 1673
    new $P5652, "Undef"
    .lex "$quant", $P5652
.annotate 'line', 1674
    new $P5653, "Undef"
    .lex "$past", $P5653
.annotate 'line', 1673
    find_lex $P5654, "$/"
    unless_null $P5654, vivify_2401
    $P5654 = root_new ['parrot';'Hash']
  vivify_2401:
    set $P5655, $P5654["quant"]
    unless_null $P5655, vivify_2402
    new $P5655, "Undef"
  vivify_2402:
    store_lex "$quant", $P5655
    find_lex $P5656, "$past"
    unless_null $P5656, vivify_2403
    new $P5656, "Undef"
  vivify_2403:
.annotate 'line', 1675
    find_lex $P5658, "$/"
    unless_null $P5658, vivify_2404
    $P5658 = root_new ['parrot';'Hash']
  vivify_2404:
    set $P5659, $P5658["named_param"]
    unless_null $P5659, vivify_2405
    new $P5659, "Undef"
  vivify_2405:
    if $P5659, if_5657
.annotate 'line', 1682
    find_lex $P5673, "$/"
    unless_null $P5673, vivify_2406
    $P5673 = root_new ['parrot';'Hash']
  vivify_2406:
    set $P5674, $P5673["param_var"]
    unless_null $P5674, vivify_2407
    new $P5674, "Undef"
  vivify_2407:
    $P5675 = $P5674."ast"()
    store_lex "$past", $P5675
.annotate 'line', 1683
    find_lex $P5677, "$quant"
    unless_null $P5677, vivify_2408
    new $P5677, "Undef"
  vivify_2408:
    set $S5678, $P5677
    iseq $I5679, $S5678, "*"
    if $I5679, if_5676
.annotate 'line', 1687
    find_lex $P5688, "$quant"
    unless_null $P5688, vivify_2409
    new $P5688, "Undef"
  vivify_2409:
    set $S5689, $P5688
    iseq $I5690, $S5689, "?"
    unless $I5690, if_5687_end
.annotate 'line', 1688
    find_lex $P5691, "$past"
    unless_null $P5691, vivify_2410
    new $P5691, "Undef"
  vivify_2410:
    find_lex $P5692, "$/"
    unless_null $P5692, vivify_2411
    $P5692 = root_new ['parrot';'Hash']
  vivify_2411:
    set $P5693, $P5692["param_var"]
    unless_null $P5693, vivify_2412
    $P5693 = root_new ['parrot';'Hash']
  vivify_2412:
    set $P5694, $P5693["sigil"]
    unless_null $P5694, vivify_2413
    new $P5694, "Undef"
  vivify_2413:
    $P5695 = "vivitype"($P5694)
    $P5691."viviself"($P5695)
  if_5687_end:
.annotate 'line', 1687
    goto if_5676_end
  if_5676:
.annotate 'line', 1684
    find_lex $P5680, "$past"
    unless_null $P5680, vivify_2414
    new $P5680, "Undef"
  vivify_2414:
    $P5680."slurpy"(1)
.annotate 'line', 1685
    find_lex $P5681, "$past"
    unless_null $P5681, vivify_2415
    new $P5681, "Undef"
  vivify_2415:
    find_lex $P5682, "$/"
    unless_null $P5682, vivify_2416
    $P5682 = root_new ['parrot';'Hash']
  vivify_2416:
    set $P5683, $P5682["param_var"]
    unless_null $P5683, vivify_2417
    $P5683 = root_new ['parrot';'Hash']
  vivify_2417:
    set $P5684, $P5683["sigil"]
    unless_null $P5684, vivify_2418
    new $P5684, "Undef"
  vivify_2418:
    set $S5685, $P5684
    iseq $I5686, $S5685, "%"
    $P5681."named"($I5686)
  if_5676_end:
.annotate 'line', 1681
    goto if_5657_end
  if_5657:
.annotate 'line', 1676
    find_lex $P5660, "$/"
    unless_null $P5660, vivify_2419
    $P5660 = root_new ['parrot';'Hash']
  vivify_2419:
    set $P5661, $P5660["named_param"]
    unless_null $P5661, vivify_2420
    new $P5661, "Undef"
  vivify_2420:
    $P5662 = $P5661."ast"()
    store_lex "$past", $P5662
.annotate 'line', 1677
    find_lex $P5664, "$quant"
    unless_null $P5664, vivify_2421
    new $P5664, "Undef"
  vivify_2421:
    set $S5665, $P5664
    isne $I5666, $S5665, "!"
    unless $I5666, if_5663_end
.annotate 'line', 1678
    find_lex $P5667, "$past"
    unless_null $P5667, vivify_2422
    new $P5667, "Undef"
  vivify_2422:
    find_lex $P5668, "$/"
    unless_null $P5668, vivify_2423
    $P5668 = root_new ['parrot';'Hash']
  vivify_2423:
    set $P5669, $P5668["named_param"]
    unless_null $P5669, vivify_2424
    $P5669 = root_new ['parrot';'Hash']
  vivify_2424:
    set $P5670, $P5669["param_var"]
    unless_null $P5670, vivify_2425
    $P5670 = root_new ['parrot';'Hash']
  vivify_2425:
    set $P5671, $P5670["sigil"]
    unless_null $P5671, vivify_2426
    new $P5671, "Undef"
  vivify_2426:
    $P5672 = "vivitype"($P5671)
    $P5667."viviself"($P5672)
  if_5663_end:
  if_5657_end:
.annotate 'line', 1691
    find_lex $P5697, "$/"
    unless_null $P5697, vivify_2427
    $P5697 = root_new ['parrot';'Hash']
  vivify_2427:
    set $P5698, $P5697["default_value"]
    unless_null $P5698, vivify_2428
    new $P5698, "Undef"
  vivify_2428:
    unless $P5698, if_5696_end
.annotate 'line', 1692
    find_lex $P5700, "$quant"
    unless_null $P5700, vivify_2429
    new $P5700, "Undef"
  vivify_2429:
    set $S5701, $P5700
    iseq $I5702, $S5701, "*"
    unless $I5702, if_5699_end
.annotate 'line', 1693
    find_lex $P5703, "$/"
    unless_null $P5703, vivify_2430
    new $P5703, "Undef"
  vivify_2430:
    $P5704 = $P5703."CURSOR"()
    $P5704."panic"("Can't put default on slurpy parameter")
  if_5699_end:
.annotate 'line', 1695
    find_lex $P5706, "$quant"
    unless_null $P5706, vivify_2431
    new $P5706, "Undef"
  vivify_2431:
    set $S5707, $P5706
    iseq $I5708, $S5707, "!"
    unless $I5708, if_5705_end
.annotate 'line', 1696
    find_lex $P5709, "$/"
    unless_null $P5709, vivify_2432
    new $P5709, "Undef"
  vivify_2432:
    $P5710 = $P5709."CURSOR"()
    $P5710."panic"("Can't put default on required parameter")
  if_5705_end:
.annotate 'line', 1698
    find_lex $P5711, "$past"
    unless_null $P5711, vivify_2433
    new $P5711, "Undef"
  vivify_2433:
    find_lex $P5712, "$/"
    unless_null $P5712, vivify_2434
    $P5712 = root_new ['parrot';'Hash']
  vivify_2434:
    set $P5713, $P5712["default_value"]
    unless_null $P5713, vivify_2435
    $P5713 = root_new ['parrot';'ResizablePMCArray']
  vivify_2435:
    set $P5714, $P5713[0]
    unless_null $P5714, vivify_2436
    $P5714 = root_new ['parrot';'Hash']
  vivify_2436:
    set $P5715, $P5714["EXPR"]
    unless_null $P5715, vivify_2437
    new $P5715, "Undef"
  vivify_2437:
    $P5716 = $P5715."ast"()
    $P5711."viviself"($P5716)
  if_5696_end:
.annotate 'line', 1700
    find_lex $P5718, "$past"
    unless_null $P5718, vivify_2438
    new $P5718, "Undef"
  vivify_2438:
    $P5719 = $P5718."viviself"()
    if $P5719, unless_5717_end
    find_lex $P5720, "$?PACKAGE"
    get_who $P5721, $P5720
    set $P5722, $P5721["@BLOCK"]
    unless_null $P5722, vivify_2439
    $P5722 = root_new ['parrot';'ResizablePMCArray']
  vivify_2439:
    set $P5723, $P5722[0]
    unless_null $P5723, vivify_2440
    new $P5723, "Undef"
  vivify_2440:
    find_lex $P5724, "$?PACKAGE"
    get_who $P5725, $P5724
    set $P5726, $P5725["@BLOCK"]
    unless_null $P5726, vivify_2441
    $P5726 = root_new ['parrot';'ResizablePMCArray']
  vivify_2441:
    set $P5727, $P5726[0]
    unless_null $P5727, vivify_2442
    new $P5727, "Undef"
  vivify_2442:
    $P5728 = $P5727."arity"()
    set $N5729, $P5728
    new $P5730, 'Float'
    set $P5730, $N5729
    add $P5731, $P5730, 1
    $P5723."arity"($P5731)
  unless_5717_end:
.annotate 'line', 1704
    find_lex $P5733, "$/"
    unless_null $P5733, vivify_2443
    $P5733 = root_new ['parrot';'Hash']
  vivify_2443:
    set $P5734, $P5733["typename"]
    unless_null $P5734, vivify_2444
    new $P5734, "Undef"
  vivify_2444:
    unless $P5734, if_5732_end
.annotate 'line', 1705
    find_lex $P5735, "$past"
    unless_null $P5735, vivify_2445
    new $P5735, "Undef"
  vivify_2445:
    find_lex $P5736, "$/"
    unless_null $P5736, vivify_2446
    $P5736 = root_new ['parrot';'Hash']
  vivify_2446:
    set $P5737, $P5736["typename"]
    unless_null $P5737, vivify_2447
    $P5737 = root_new ['parrot';'ResizablePMCArray']
  vivify_2447:
    set $P5738, $P5737[0]
    unless_null $P5738, vivify_2448
    new $P5738, "Undef"
  vivify_2448:
    $P5739 = $P5738."ast"()
    $P5735."multitype"($P5739)
  if_5732_end:
.annotate 'line', 1709
    find_lex $P5741, "$/"
    unless_null $P5741, vivify_2449
    $P5741 = root_new ['parrot';'Hash']
  vivify_2449:
    set $P5742, $P5741["definedness"]
    unless_null $P5742, vivify_2450
    new $P5742, "Undef"
  vivify_2450:
    unless $P5742, if_5740_end
.annotate 'line', 1710
    find_lex $P5743, "$/"
    unless_null $P5743, vivify_2451
    $P5743 = root_new ['parrot';'Hash']
  vivify_2451:
    set $P5744, $P5743["definedness"]
    unless_null $P5744, vivify_2452
    $P5744 = root_new ['parrot';'ResizablePMCArray']
  vivify_2452:
    set $P5745, $P5744[0]
    unless_null $P5745, vivify_2453
    new $P5745, "Undef"
  vivify_2453:
    set $S5746, $P5745
    new $P5747, 'String'
    set $P5747, $S5746
    find_lex $P5748, "$past"
    unless_null $P5748, vivify_2454
    $P5748 = root_new ['parrot';'Hash']
    store_lex "$past", $P5748
  vivify_2454:
    set $P5748["definedness"], $P5747
  if_5740_end:
.annotate 'line', 1713
    find_lex $P5749, "$/"
    find_lex $P5750, "$past"
    unless_null $P5750, vivify_2455
    new $P5750, "Undef"
  vivify_2455:
    $P5751 = $P5749."!make"($P5750)
.annotate 'line', 1672
    .return ($P5751)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("522_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5753
    .param pmc param_5754
.annotate 'line', 1716
    .lex "self", param_5753
    .lex "$/", param_5754
.annotate 'line', 1717
    new $P5755, "Undef"
    .lex "$name", $P5755
.annotate 'line', 1718
    new $P5756, "Undef"
    .lex "$past", $P5756
.annotate 'line', 1717
    find_lex $P5757, "$/"
    unless_null $P5757, vivify_2456
    new $P5757, "Undef"
  vivify_2456:
    set $S5758, $P5757
    new $P5759, 'String'
    set $P5759, $S5758
    store_lex "$name", $P5759
.annotate 'line', 1718
    get_hll_global $P5760, "GLOBAL"
    nqp_get_package_through_who $P5761, $P5760, "PAST"
    get_who $P5762, $P5761
    set $P5763, $P5762["Var"]
    find_lex $P5764, "$name"
    unless_null $P5764, vivify_2457
    new $P5764, "Undef"
  vivify_2457:
    find_lex $P5765, "$/"
    unless_null $P5765, vivify_2458
    new $P5765, "Undef"
  vivify_2458:
    $P5766 = $P5763."new"($P5764 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P5765 :named("node"))
    store_lex "$past", $P5766
.annotate 'line', 1720
    find_lex $P5767, "$?PACKAGE"
    get_who $P5768, $P5767
    set $P5769, $P5768["@BLOCK"]
    unless_null $P5769, vivify_2459
    $P5769 = root_new ['parrot';'ResizablePMCArray']
  vivify_2459:
    set $P5770, $P5769[0]
    unless_null $P5770, vivify_2460
    new $P5770, "Undef"
  vivify_2460:
    find_lex $P5771, "$name"
    unless_null $P5771, vivify_2461
    new $P5771, "Undef"
  vivify_2461:
    $P5770."symbol"($P5771, "lexical" :named("scope"))
.annotate 'line', 1721
    find_lex $P5772, "$/"
    find_lex $P5773, "$past"
    unless_null $P5773, vivify_2462
    new $P5773, "Undef"
  vivify_2462:
    $P5774 = $P5772."!make"($P5773)
.annotate 'line', 1716
    .return ($P5774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("523_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5776
    .param pmc param_5777
.annotate 'line', 1724
    .lex "self", param_5776
    .lex "$/", param_5777
.annotate 'line', 1725
    new $P5778, "Undef"
    .lex "$past", $P5778
    find_lex $P5779, "$/"
    unless_null $P5779, vivify_2463
    $P5779 = root_new ['parrot';'Hash']
  vivify_2463:
    set $P5780, $P5779["param_var"]
    unless_null $P5780, vivify_2464
    new $P5780, "Undef"
  vivify_2464:
    $P5781 = $P5780."ast"()
    store_lex "$past", $P5781
.annotate 'line', 1726
    find_lex $P5782, "$past"
    unless_null $P5782, vivify_2465
    new $P5782, "Undef"
  vivify_2465:
    find_lex $P5783, "$/"
    unless_null $P5783, vivify_2466
    $P5783 = root_new ['parrot';'Hash']
  vivify_2466:
    set $P5784, $P5783["param_var"]
    unless_null $P5784, vivify_2467
    $P5784 = root_new ['parrot';'Hash']
  vivify_2467:
    set $P5785, $P5784["name"]
    unless_null $P5785, vivify_2468
    new $P5785, "Undef"
  vivify_2468:
    set $S5786, $P5785
    $P5782."named"($S5786)
.annotate 'line', 1727
    find_lex $P5787, "$/"
    find_lex $P5788, "$past"
    unless_null $P5788, vivify_2469
    new $P5788, "Undef"
  vivify_2469:
    $P5789 = $P5787."!make"($P5788)
.annotate 'line', 1724
    .return ($P5789)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("524_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5791
    .param pmc param_5792
.annotate 'line', 1730
    .lex "self", param_5791
    .lex "$/", param_5792
.annotate 'line', 1731
    $P5793 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P5793
    get_hll_global $P5794, "GLOBAL"
    nqp_get_package_through_who $P5795, $P5794, "HLL"
    get_who $P5796, $P5795
    set $P5797, $P5796["Compiler"]
    find_lex $P5798, "$/"
    unless_null $P5798, vivify_2470
    new $P5798, "Undef"
  vivify_2470:
    set $S5799, $P5798
    $P5800 = $P5797."parse_name"($S5799)
    store_lex "@name", $P5800
.annotate 'line', 1732
    find_lex $P5801, "$/"
    find_lex $P5802, "@name"
    unless_null $P5802, vivify_2471
    $P5802 = root_new ['parrot';'ResizablePMCArray']
  vivify_2471:
    find_lex $P5803, "$/"
    unless_null $P5803, vivify_2472
    new $P5803, "Undef"
  vivify_2472:
    $P5804 = "lexical_package_lookup"($P5802, $P5803)
    $P5805 = $P5801."!make"($P5804)
.annotate 'line', 1730
    .return ($P5805)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("525_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5807
    .param pmc param_5808
.annotate 'line', 1735
    .lex "self", param_5807
    .lex "$/", param_5808
.annotate 'line', 1736
    find_lex $P5809, "$/"
    find_lex $P5810, "$/"
    unless_null $P5810, vivify_2473
    $P5810 = root_new ['parrot';'Hash']
  vivify_2473:
    set $P5811, $P5810["trait_mod"]
    unless_null $P5811, vivify_2474
    new $P5811, "Undef"
  vivify_2474:
    $P5812 = $P5811."ast"()
    $P5813 = $P5809."!make"($P5812)
.annotate 'line', 1735
    .return ($P5813)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("526_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5815
    .param pmc param_5816
.annotate 'line', 1739
    .const 'Sub' $P5839 = "527_1303923618.727" 
    capture_lex $P5839
    .lex "self", param_5815
    .lex "$/", param_5816
.annotate 'line', 1740
    new $P5817, "Undef"
    .lex "$cpast", $P5817
    find_lex $P5818, "$/"
    unless_null $P5818, vivify_2475
    $P5818 = root_new ['parrot';'Hash']
  vivify_2475:
    set $P5819, $P5818["circumfix"]
    unless_null $P5819, vivify_2476
    $P5819 = root_new ['parrot';'ResizablePMCArray']
  vivify_2476:
    set $P5820, $P5819[0]
    unless_null $P5820, vivify_2477
    new $P5820, "Undef"
  vivify_2477:
    $P5821 = $P5820."ast"()
    store_lex "$cpast", $P5821
.annotate 'line', 1741
    find_lex $P5824, "$/"
    unless_null $P5824, vivify_2478
    $P5824 = root_new ['parrot';'Hash']
  vivify_2478:
    set $P5825, $P5824["longname"]
    unless_null $P5825, vivify_2479
    new $P5825, "Undef"
  vivify_2479:
    set $S5826, $P5825
    iseq $I5827, $S5826, "parrot_vtable"
    if $I5827, if_5823
.annotate 'line', 1761
    find_lex $P5881, "$/"
    unless_null $P5881, vivify_2480
    $P5881 = root_new ['parrot';'Hash']
  vivify_2480:
    set $P5882, $P5881["longname"]
    unless_null $P5882, vivify_2481
    new $P5882, "Undef"
  vivify_2481:
    set $S5883, $P5882
    iseq $I5884, $S5883, "pirflags"
    if $I5884, if_5880
.annotate 'line', 1765
    find_lex $P5888, "$/"
    unless_null $P5888, vivify_2482
    new $P5888, "Undef"
  vivify_2482:
    $P5889 = $P5888."CURSOR"()
    new $P5890, 'String'
    set $P5890, "Trait '"
    find_lex $P5891, "$/"
    unless_null $P5891, vivify_2483
    $P5891 = root_new ['parrot';'Hash']
  vivify_2483:
    set $P5892, $P5891["longname"]
    unless_null $P5892, vivify_2484
    new $P5892, "Undef"
  vivify_2484:
    concat $P5893, $P5890, $P5892
    concat $P5894, $P5893, "' not implemented"
    $P5895 = $P5889."panic"($P5894)
.annotate 'line', 1764
    set $P5879, $P5895
.annotate 'line', 1761
    goto if_5880_end
  if_5880:
.annotate 'line', 1762
    find_lex $P5885, "$/"
    unless_null $P5885, vivify_2485
    new $P5885, "Undef"
  vivify_2485:
    $P5886 = $P5885."CURSOR"()
    $P5887 = $P5886."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1761
    set $P5879, $P5887
  if_5880_end:
    set $P5822, $P5879
.annotate 'line', 1741
    goto if_5823_end
  if_5823:
.annotate 'line', 1744
    get_hll_global $P5829, "GLOBAL"
    nqp_get_package_through_who $P5830, $P5829, "PAST"
    get_who $P5831, $P5830
    set $P5832, $P5831["Val"]
    find_lex $P5833, "$cpast"
    unless_null $P5833, vivify_2486
    new $P5833, "Undef"
  vivify_2486:
    $P5834 = $P5832."ACCEPTS"($P5833)
    if $P5834, unless_5828_end
.annotate 'line', 1743
    find_lex $P5835, "$/"
    unless_null $P5835, vivify_2487
    new $P5835, "Undef"
  vivify_2487:
    $P5836 = $P5835."CURSOR"()
    $P5836."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_5828_end:
.annotate 'line', 1745
    find_lex $P5837, "$/"
    .const 'Sub' $P5839 = "527_1303923618.727" 
    newclosure $P5877, $P5839
    $P5878 = $P5837."!make"($P5877)
.annotate 'line', 1741
    set $P5822, $P5878
  if_5823_end:
.annotate 'line', 1739
    .return ($P5822)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5838"  :anon :subid("527_1303923618.727") :outer("526_1303923618.727")
    .param pmc param_5840
.annotate 'line', 1745
    .lex "$match", param_5840
.annotate 'line', 1746
    new $P5841, "Undef"
    .lex "$meth", $P5841
    find_lex $P5842, "$match"
    unless_null $P5842, vivify_2488
    new $P5842, "Undef"
  vivify_2488:
    $P5843 = $P5842."ast"()
    set $P5844, $P5843["block_past"]
    unless_null $P5844, vivify_2489
    new $P5844, "Undef"
  vivify_2489:
    store_lex "$meth", $P5844
.annotate 'line', 1747
    find_dynamic_lex $P5849, "$*PACKAGE-SETUP"
    unless_null $P5849, vivify_2490
    get_hll_global $P5847, "GLOBAL"
    get_who $P5848, $P5847
    set $P5849, $P5848["$PACKAGE-SETUP"]
    unless_null $P5849, vivify_2491
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2491:
  vivify_2490:
    defined $I5850, $P5849
    if $I5850, if_5846
    new $P5845, 'Integer'
    set $P5845, $I5850
    goto if_5846_end
  if_5846:
.annotate 'line', 1748
    find_dynamic_lex $P5853, "$*PACKAGE-SETUP"
    unless_null $P5853, vivify_2492
    get_hll_global $P5851, "GLOBAL"
    get_who $P5852, $P5851
    set $P5853, $P5852["$PACKAGE-SETUP"]
    unless_null $P5853, vivify_2493
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2493:
  vivify_2492:
    get_hll_global $P5854, "GLOBAL"
    nqp_get_package_through_who $P5855, $P5854, "PAST"
    get_who $P5856, $P5855
    set $P5857, $P5856["Op"]
.annotate 'line', 1750
    get_hll_global $P5858, "GLOBAL"
    nqp_get_package_through_who $P5859, $P5858, "PAST"
    get_who $P5860, $P5859
    set $P5861, $P5860["Op"]
.annotate 'line', 1753
    get_hll_global $P5862, "GLOBAL"
    nqp_get_package_through_who $P5863, $P5862, "PAST"
    get_who $P5864, $P5863
    set $P5865, $P5864["Var"]
    $P5866 = $P5865."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5867 = $P5861."new"($P5866, "get_how PP" :named("pirop"))
.annotate 'line', 1755
    get_hll_global $P5868, "GLOBAL"
    nqp_get_package_through_who $P5869, $P5868, "PAST"
    get_who $P5870, $P5869
    set $P5871, $P5870["Var"]
    $P5872 = $P5871."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P5873, "$cpast"
    unless_null $P5873, vivify_2494
    new $P5873, "Undef"
  vivify_2494:
    find_lex $P5874, "$meth"
    unless_null $P5874, vivify_2495
    new $P5874, "Undef"
  vivify_2495:
    $P5875 = $P5857."new"($P5867, $P5872, $P5873, $P5874, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1748
    $P5876 = $P5853."push"($P5875)
.annotate 'line', 1747
    set $P5845, $P5876
  if_5846_end:
.annotate 'line', 1745
    .return ($P5845)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("528_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_5899
    .param pmc param_5900
    .param pmc param_5901 :optional
    .param int has_param_5901 :opt_flag
.annotate 'line', 1769
    .const 'Sub' $P6055 = "531_1303923618.727" 
    capture_lex $P6055
    .const 'Sub' $P6017 = "530_1303923618.727" 
    capture_lex $P6017
    .const 'Sub' $P5970 = "529_1303923618.727" 
    capture_lex $P5970
    new $P5898, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5898, control_5897
    push_eh $P5898
    .lex "self", param_5899
    .lex "$/", param_5900
    if has_param_5901, optparam_2496
    new $P5902, "Undef"
    set param_5901, $P5902
  optparam_2496:
    .lex "$key", param_5901
.annotate 'line', 1770
    $P5903 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5903
.annotate 'line', 1771
    new $P5904, "Undef"
    .lex "$name", $P5904
.annotate 'line', 1772
    new $P5905, "Undef"
    .lex "$past", $P5905
.annotate 'line', 1770
    get_hll_global $P5906, "GLOBAL"
    nqp_get_package_through_who $P5907, $P5906, "Regex"
    nqp_get_package_through_who $P5908, $P5907, "P6Regex"
    nqp_get_package_through_who $P5909, $P5908, "Actions"
    get_who $P5910, $P5909
    set $P5911, $P5910["@MODIFIERS"]
    unless_null $P5911, vivify_2497
    $P5911 = root_new ['parrot';'ResizablePMCArray']
  vivify_2497:
    store_lex "@MODIFIERS", $P5911
.annotate 'line', 1771
    find_lex $P5912, "$/"
    unless_null $P5912, vivify_2498
    $P5912 = root_new ['parrot';'Hash']
  vivify_2498:
    set $P5913, $P5912["deflongname"]
    unless_null $P5913, vivify_2499
    new $P5913, "Undef"
  vivify_2499:
    $P5914 = $P5913."ast"()
    set $S5915, $P5914
    new $P5916, 'String'
    set $P5916, $S5915
    store_lex "$name", $P5916
    find_lex $P5917, "$past"
    unless_null $P5917, vivify_2500
    new $P5917, "Undef"
  vivify_2500:
.annotate 'line', 1773
    find_lex $P5919, "$/"
    unless_null $P5919, vivify_2501
    $P5919 = root_new ['parrot';'Hash']
  vivify_2501:
    set $P5920, $P5919["proto"]
    unless_null $P5920, vivify_2502
    new $P5920, "Undef"
  vivify_2502:
    if $P5920, if_5918
.annotate 'line', 1812
    find_lex $P6013, "$key"
    unless_null $P6013, vivify_2503
    new $P6013, "Undef"
  vivify_2503:
    set $S6014, $P6013
    iseq $I6015, $S6014, "open"
    if $I6015, if_6012
.annotate 'line', 1822
    .const 'Sub' $P6055 = "531_1303923618.727" 
    capture_lex $P6055
    $P6055()
    goto if_6012_end
  if_6012:
.annotate 'line', 1812
    .const 'Sub' $P6017 = "530_1303923618.727" 
    capture_lex $P6017
    $P6017()
  if_6012_end:
    goto if_5918_end
  if_5918:
.annotate 'line', 1775
    get_hll_global $P5921, "GLOBAL"
    nqp_get_package_through_who $P5922, $P5921, "PAST"
    get_who $P5923, $P5922
    set $P5924, $P5923["Stmts"]
.annotate 'line', 1776
    get_hll_global $P5925, "GLOBAL"
    nqp_get_package_through_who $P5926, $P5925, "PAST"
    get_who $P5927, $P5926
    set $P5928, $P5927["Block"]
    find_lex $P5929, "$name"
    unless_null $P5929, vivify_2538
    new $P5929, "Undef"
  vivify_2538:
.annotate 'line', 1777
    get_hll_global $P5930, "GLOBAL"
    nqp_get_package_through_who $P5931, $P5930, "PAST"
    get_who $P5932, $P5931
    set $P5933, $P5932["Op"]
.annotate 'line', 1778
    get_hll_global $P5934, "GLOBAL"
    nqp_get_package_through_who $P5935, $P5934, "PAST"
    get_who $P5936, $P5935
    set $P5937, $P5936["Var"]
    $P5938 = $P5937."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5939, "$name"
    unless_null $P5939, vivify_2539
    new $P5939, "Undef"
  vivify_2539:
    $P5940 = $P5933."new"($P5938, $P5939, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1777
    find_lex $P5941, "$/"
    unless_null $P5941, vivify_2540
    new $P5941, "Undef"
  vivify_2540:
    $P5942 = $P5928."new"($P5940, $P5929 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5941 :named("node"))
.annotate 'line', 1787
    get_hll_global $P5943, "GLOBAL"
    nqp_get_package_through_who $P5944, $P5943, "PAST"
    get_who $P5945, $P5944
    set $P5946, $P5945["Block"]
    new $P5947, "String"
    assign $P5947, "!PREFIX__"
    find_lex $P5948, "$name"
    unless_null $P5948, vivify_2541
    new $P5948, "Undef"
  vivify_2541:
    concat $P5949, $P5947, $P5948
.annotate 'line', 1788
    get_hll_global $P5950, "GLOBAL"
    nqp_get_package_through_who $P5951, $P5950, "PAST"
    get_who $P5952, $P5951
    set $P5953, $P5952["Op"]
.annotate 'line', 1789
    get_hll_global $P5954, "GLOBAL"
    nqp_get_package_through_who $P5955, $P5954, "PAST"
    get_who $P5956, $P5955
    set $P5957, $P5956["Var"]
    $P5958 = $P5957."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5959, "$name"
    unless_null $P5959, vivify_2542
    new $P5959, "Undef"
  vivify_2542:
    $P5960 = $P5953."new"($P5958, $P5959, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1788
    find_lex $P5961, "$/"
    unless_null $P5961, vivify_2543
    new $P5961, "Undef"
  vivify_2543:
    $P5962 = $P5946."new"($P5960, $P5949 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5961 :named("node"))
.annotate 'line', 1787
    $P5963 = $P5924."new"($P5942, $P5962)
.annotate 'line', 1775
    store_lex "$past", $P5963
.annotate 'line', 1799
    find_lex $P5965, "$past"
    unless_null $P5965, vivify_2544
    new $P5965, "Undef"
  vivify_2544:
    $P5966 = $P5965."list"()
    defined $I5967, $P5966
    unless $I5967, for_undef_2545
    iter $P5964, $P5966
    new $P6010, 'ExceptionHandler'
    set_label $P6010, loop6009_handler
    $P6010."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6010
  loop6009_test:
    unless $P5964, loop6009_done
    shift $P5968, $P5964
  loop6009_redo:
    .const 'Sub' $P5970 = "529_1303923618.727" 
    capture_lex $P5970
    $P5970($P5968)
  loop6009_next:
    goto loop6009_test
  loop6009_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6011, exception, 'type'
    eq $P6011, .CONTROL_LOOP_NEXT, loop6009_next
    eq $P6011, .CONTROL_LOOP_REDO, loop6009_redo
  loop6009_done:
    pop_eh 
  for_undef_2545:
  if_5918_end:
.annotate 'line', 1858
    find_lex $P6168, "$/"
    find_lex $P6169, "$past"
    unless_null $P6169, vivify_2550
    new $P6169, "Undef"
  vivify_2550:
    $P6170 = $P6168."!make"($P6169)
.annotate 'line', 1769
    .return ($P6170)
  control_5897:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6171, exception, "payload"
    .return ($P6171)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6054"  :anon :subid("531_1303923618.727") :outer("528_1303923618.727")
.annotate 'line', 1823
    new $P6056, "Undef"
    .lex "$regex", $P6056
.annotate 'line', 1824
    get_hll_global $P6057, "GLOBAL"
    nqp_get_package_through_who $P6058, $P6057, "Regex"
    nqp_get_package_through_who $P6059, $P6058, "P6Regex"
    nqp_get_package_through_who $P6060, $P6059, "Actions"
    get_who $P6061, $P6060
    set $P6062, $P6061["buildsub"]
    find_lex $P6063, "$/"
    unless_null $P6063, vivify_2504
    $P6063 = root_new ['parrot';'Hash']
  vivify_2504:
    set $P6064, $P6063["p6regex"]
    unless_null $P6064, vivify_2505
    new $P6064, "Undef"
  vivify_2505:
    $P6065 = $P6064."ast"()
    find_lex $P6066, "$?PACKAGE"
    get_who $P6067, $P6066
    set $P6068, $P6067["@BLOCK"]
    unless_null $P6068, vivify_2506
    $P6068 = root_new ['parrot';'ResizablePMCArray']
  vivify_2506:
    $P6069 = $P6068."shift"()
    $P6070 = $P6062($P6065, $P6069)
    store_lex "$regex", $P6070
.annotate 'line', 1825
    find_lex $P6071, "$regex"
    unless_null $P6071, vivify_2507
    new $P6071, "Undef"
  vivify_2507:
    find_lex $P6072, "$name"
    unless_null $P6072, vivify_2508
    new $P6072, "Undef"
  vivify_2508:
    $P6071."name"($P6072)
.annotate 'line', 1827
    get_hll_global $P6073, "GLOBAL"
    nqp_get_package_through_who $P6074, $P6073, "PAST"
    get_who $P6075, $P6074
    set $P6076, $P6075["Op"]
.annotate 'line', 1829
    get_hll_global $P6077, "GLOBAL"
    nqp_get_package_through_who $P6078, $P6077, "PAST"
    get_who $P6079, $P6078
    set $P6080, $P6079["Var"]
    new $P6081, "ResizablePMCArray"
    push $P6081, "Regex"
    $P6082 = $P6080."new"("Method" :named("name"), $P6081 :named("namespace"), "package" :named("scope"))
    find_lex $P6083, "$regex"
    unless_null $P6083, vivify_2509
    new $P6083, "Undef"
  vivify_2509:
    $P6084 = $P6076."new"($P6082, $P6083, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1827
    store_lex "$past", $P6084
.annotate 'line', 1832
    find_dynamic_lex $P6088, "$*PACKAGE-SETUP"
    unless_null $P6088, vivify_2510
    get_hll_global $P6086, "GLOBAL"
    get_who $P6087, $P6086
    set $P6088, $P6087["$PACKAGE-SETUP"]
    unless_null $P6088, vivify_2511
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2511:
  vivify_2510:
    defined $I6089, $P6088
    unless $I6089, if_6085_end
.annotate 'line', 1833
    find_dynamic_lex $P6092, "$*PACKAGE-SETUP"
    unless_null $P6092, vivify_2512
    get_hll_global $P6090, "GLOBAL"
    get_who $P6091, $P6090
    set $P6092, $P6091["$PACKAGE-SETUP"]
    unless_null $P6092, vivify_2513
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2513:
  vivify_2512:
    get_hll_global $P6093, "GLOBAL"
    nqp_get_package_through_who $P6094, $P6093, "PAST"
    get_who $P6095, $P6094
    set $P6096, $P6095["Op"]
.annotate 'line', 1835
    get_hll_global $P6097, "GLOBAL"
    nqp_get_package_through_who $P6098, $P6097, "PAST"
    get_who $P6099, $P6098
    set $P6100, $P6099["Op"]
.annotate 'line', 1837
    get_hll_global $P6101, "GLOBAL"
    nqp_get_package_through_who $P6102, $P6101, "PAST"
    get_who $P6103, $P6102
    set $P6104, $P6103["Var"]
    $P6105 = $P6104."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6106 = $P6100."new"($P6105, "get_how PP" :named("pirop"))
.annotate 'line', 1839
    get_hll_global $P6107, "GLOBAL"
    nqp_get_package_through_who $P6108, $P6107, "PAST"
    get_who $P6109, $P6108
    set $P6110, $P6109["Var"]
    $P6111 = $P6110."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1840
    get_hll_global $P6112, "GLOBAL"
    nqp_get_package_through_who $P6113, $P6112, "PAST"
    get_who $P6114, $P6113
    set $P6115, $P6114["Val"]
    find_lex $P6116, "$name"
    unless_null $P6116, vivify_2514
    new $P6116, "Undef"
  vivify_2514:
    $P6117 = $P6115."new"($P6116 :named("value"))
.annotate 'line', 1841
    get_hll_global $P6118, "GLOBAL"
    nqp_get_package_through_who $P6119, $P6118, "PAST"
    get_who $P6120, $P6119
    set $P6121, $P6120["Val"]
    find_lex $P6122, "$regex"
    unless_null $P6122, vivify_2515
    new $P6122, "Undef"
  vivify_2515:
    $P6123 = $P6121."new"($P6122 :named("value"))
    $P6124 = $P6096."new"($P6106, $P6111, $P6117, $P6123, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1833
    $P6092."push"($P6124)
.annotate 'line', 1843
    find_dynamic_lex $P6127, "$*PACKAGE-SETUP"
    unless_null $P6127, vivify_2516
    get_hll_global $P6125, "GLOBAL"
    get_who $P6126, $P6125
    set $P6127, $P6126["$PACKAGE-SETUP"]
    unless_null $P6127, vivify_2517
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2517:
  vivify_2516:
    get_hll_global $P6128, "GLOBAL"
    nqp_get_package_through_who $P6129, $P6128, "PAST"
    get_who $P6130, $P6129
    set $P6131, $P6130["Op"]
.annotate 'line', 1845
    get_hll_global $P6132, "GLOBAL"
    nqp_get_package_through_who $P6133, $P6132, "PAST"
    get_who $P6134, $P6133
    set $P6135, $P6134["Op"]
.annotate 'line', 1847
    get_hll_global $P6136, "GLOBAL"
    nqp_get_package_through_who $P6137, $P6136, "PAST"
    get_who $P6138, $P6137
    set $P6139, $P6138["Var"]
    $P6140 = $P6139."new"("type_obj" :named("name"), "register" :named("scope"))
    $P6141 = $P6135."new"($P6140, "get_how PP" :named("pirop"))
.annotate 'line', 1849
    get_hll_global $P6142, "GLOBAL"
    nqp_get_package_through_who $P6143, $P6142, "PAST"
    get_who $P6144, $P6143
    set $P6145, $P6144["Var"]
    $P6146 = $P6145."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1850
    get_hll_global $P6147, "GLOBAL"
    nqp_get_package_through_who $P6148, $P6147, "PAST"
    get_who $P6149, $P6148
    set $P6150, $P6149["Val"]
    new $P6151, "String"
    assign $P6151, "!PREFIX__"
    find_lex $P6152, "$name"
    unless_null $P6152, vivify_2518
    new $P6152, "Undef"
  vivify_2518:
    concat $P6153, $P6151, $P6152
    $P6154 = $P6150."new"($P6153 :named("value"))
.annotate 'line', 1851
    get_hll_global $P6155, "GLOBAL"
    nqp_get_package_through_who $P6156, $P6155, "PAST"
    get_who $P6157, $P6156
    set $P6158, $P6157["Var"]
    new $P6159, "String"
    assign $P6159, "!PREFIX__"
    find_lex $P6160, "$name"
    unless_null $P6160, vivify_2519
    new $P6160, "Undef"
  vivify_2519:
    concat $P6161, $P6159, $P6160
    $P6162 = $P6158."new"($P6161 :named("name"), "package" :named("scope"))
    $P6163 = $P6131."new"($P6141, $P6146, $P6154, $P6162, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1843
    $P6127."push"($P6163)
  if_6085_end:
.annotate 'line', 1855
    find_lex $P6164, "$regex"
    unless_null $P6164, vivify_2520
    new $P6164, "Undef"
  vivify_2520:
    find_lex $P6165, "$past"
    unless_null $P6165, vivify_2521
    $P6165 = root_new ['parrot';'Hash']
    store_lex "$past", $P6165
  vivify_2521:
    set $P6165["sink"], $P6164
.annotate 'line', 1856
    find_lex $P6166, "@MODIFIERS"
    unless_null $P6166, vivify_2522
    $P6166 = root_new ['parrot';'ResizablePMCArray']
  vivify_2522:
    $P6167 = $P6166."shift"()
.annotate 'line', 1822
    .return ($P6167)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6016"  :anon :subid("530_1303923618.727") :outer("528_1303923618.727")
.annotate 'line', 1813
    $P6018 = root_new ['parrot';'Hash']
    .lex "%h", $P6018
.annotate 'line', 1812
    find_lex $P6019, "%h"
    unless_null $P6019, vivify_2523
    $P6019 = root_new ['parrot';'Hash']
  vivify_2523:
.annotate 'line', 1814
    find_lex $P6021, "$/"
    unless_null $P6021, vivify_2524
    $P6021 = root_new ['parrot';'Hash']
  vivify_2524:
    set $P6022, $P6021["sym"]
    unless_null $P6022, vivify_2525
    new $P6022, "Undef"
  vivify_2525:
    set $S6023, $P6022
    iseq $I6024, $S6023, "token"
    unless $I6024, if_6020_end
    new $P6025, "Integer"
    assign $P6025, 1
    find_lex $P6026, "%h"
    unless_null $P6026, vivify_2526
    $P6026 = root_new ['parrot';'Hash']
    store_lex "%h", $P6026
  vivify_2526:
    set $P6026["r"], $P6025
  if_6020_end:
.annotate 'line', 1815
    find_lex $P6028, "$/"
    unless_null $P6028, vivify_2527
    $P6028 = root_new ['parrot';'Hash']
  vivify_2527:
    set $P6029, $P6028["sym"]
    unless_null $P6029, vivify_2528
    new $P6029, "Undef"
  vivify_2528:
    set $S6030, $P6029
    iseq $I6031, $S6030, "rule"
    unless $I6031, if_6027_end
    new $P6032, "Integer"
    assign $P6032, 1
    find_lex $P6033, "%h"
    unless_null $P6033, vivify_2529
    $P6033 = root_new ['parrot';'Hash']
    store_lex "%h", $P6033
  vivify_2529:
    set $P6033["r"], $P6032
    new $P6034, "Integer"
    assign $P6034, 1
    find_lex $P6035, "%h"
    unless_null $P6035, vivify_2530
    $P6035 = root_new ['parrot';'Hash']
    store_lex "%h", $P6035
  vivify_2530:
    set $P6035["s"], $P6034
  if_6027_end:
.annotate 'line', 1816
    find_lex $P6036, "@MODIFIERS"
    unless_null $P6036, vivify_2531
    $P6036 = root_new ['parrot';'ResizablePMCArray']
  vivify_2531:
    find_lex $P6037, "%h"
    unless_null $P6037, vivify_2532
    $P6037 = root_new ['parrot';'Hash']
  vivify_2532:
    $P6036."unshift"($P6037)
.annotate 'line', 1817
    find_lex $P6038, "$name"
    unless_null $P6038, vivify_2533
    new $P6038, "Undef"
  vivify_2533:
    get_hll_global $P6039, "GLOBAL"
    nqp_get_package_through_who $P6040, $P6039, "Regex"
    nqp_get_package_through_who $P6041, $P6040, "P6Regex"
    nqp_get_package_through_who $P6042, $P6041, "Actions"
    get_who $P6043, $P6042
    set $P6043["$REGEXNAME"], $P6038
.annotate 'line', 1818
    find_lex $P6044, "$?PACKAGE"
    get_who $P6045, $P6044
    set $P6046, $P6045["@BLOCK"]
    unless_null $P6046, vivify_2534
    $P6046 = root_new ['parrot';'ResizablePMCArray']
  vivify_2534:
    set $P6047, $P6046[0]
    unless_null $P6047, vivify_2535
    new $P6047, "Undef"
  vivify_2535:
    $P6047."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1819
    find_lex $P6048, "$?PACKAGE"
    get_who $P6049, $P6048
    set $P6050, $P6049["@BLOCK"]
    unless_null $P6050, vivify_2536
    $P6050 = root_new ['parrot';'ResizablePMCArray']
  vivify_2536:
    set $P6051, $P6050[0]
    unless_null $P6051, vivify_2537
    new $P6051, "Undef"
  vivify_2537:
    $P6051."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1820
    new $P6052, "Exception"
    set $P6052['type'], .CONTROL_RETURN
    new $P6053, "Integer"
    assign $P6053, 0
    setattribute $P6052, 'payload', $P6053
    throw $P6052
.annotate 'line', 1812
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5969"  :anon :subid("529_1303923618.727") :outer("528_1303923618.727")
    .param pmc param_5971
.annotate 'line', 1799
    .lex "$_", param_5971
.annotate 'line', 1800
    find_dynamic_lex $P5974, "$*PACKAGE-SETUP"
    unless_null $P5974, vivify_2546
    get_hll_global $P5972, "GLOBAL"
    get_who $P5973, $P5972
    set $P5974, $P5973["$PACKAGE-SETUP"]
    unless_null $P5974, vivify_2547
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_2547:
  vivify_2546:
    get_hll_global $P5975, "GLOBAL"
    nqp_get_package_through_who $P5976, $P5975, "PAST"
    get_who $P5977, $P5976
    set $P5978, $P5977["Op"]
.annotate 'line', 1802
    get_hll_global $P5979, "GLOBAL"
    nqp_get_package_through_who $P5980, $P5979, "PAST"
    get_who $P5981, $P5980
    set $P5982, $P5981["Op"]
.annotate 'line', 1804
    get_hll_global $P5983, "GLOBAL"
    nqp_get_package_through_who $P5984, $P5983, "PAST"
    get_who $P5985, $P5984
    set $P5986, $P5985["Var"]
    $P5987 = $P5986."new"("type_obj" :named("name"), "register" :named("scope"))
    $P5988 = $P5982."new"($P5987, "get_how PP" :named("pirop"))
.annotate 'line', 1806
    get_hll_global $P5989, "GLOBAL"
    nqp_get_package_through_who $P5990, $P5989, "PAST"
    get_who $P5991, $P5990
    set $P5992, $P5991["Var"]
    $P5993 = $P5992."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1807
    get_hll_global $P5994, "GLOBAL"
    nqp_get_package_through_who $P5995, $P5994, "PAST"
    get_who $P5996, $P5995
    set $P5997, $P5996["Val"]
    find_lex $P5998, "$_"
    unless_null $P5998, vivify_2548
    new $P5998, "Undef"
  vivify_2548:
    $P5999 = $P5998."name"()
    $P6000 = $P5997."new"($P5999 :named("value"))
.annotate 'line', 1808
    get_hll_global $P6001, "GLOBAL"
    nqp_get_package_through_who $P6002, $P6001, "PAST"
    get_who $P6003, $P6002
    set $P6004, $P6003["Val"]
    find_lex $P6005, "$_"
    unless_null $P6005, vivify_2549
    new $P6005, "Undef"
  vivify_2549:
    $P6006 = $P6004."new"($P6005 :named("value"))
    $P6007 = $P5978."new"($P5988, $P5993, $P6000, $P6006, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1800
    $P6008 = $P5974."push"($P6007)
.annotate 'line', 1799
    .return ($P6008)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("532_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6173
    .param pmc param_6174
.annotate 'line', 1862
    .lex "self", param_6173
    .lex "$/", param_6174
.annotate 'line', 1863
    new $P6175, "Undef"
    .lex "$past", $P6175
    find_lex $P6178, "$/"
    unless_null $P6178, vivify_2551
    $P6178 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P6179, $P6178["args"]
    unless_null $P6179, vivify_2552
    new $P6179, "Undef"
  vivify_2552:
    if $P6179, if_6177
    get_hll_global $P6184, "GLOBAL"
    nqp_get_package_through_who $P6185, $P6184, "PAST"
    get_who $P6186, $P6185
    set $P6187, $P6186["Op"]
    find_lex $P6188, "$/"
    unless_null $P6188, vivify_2553
    new $P6188, "Undef"
  vivify_2553:
    $P6189 = $P6187."new"($P6188 :named("node"))
    set $P6176, $P6189
    goto if_6177_end
  if_6177:
    find_lex $P6180, "$/"
    unless_null $P6180, vivify_2554
    $P6180 = root_new ['parrot';'Hash']
  vivify_2554:
    set $P6181, $P6180["args"]
    unless_null $P6181, vivify_2555
    $P6181 = root_new ['parrot';'ResizablePMCArray']
  vivify_2555:
    set $P6182, $P6181[0]
    unless_null $P6182, vivify_2556
    new $P6182, "Undef"
  vivify_2556:
    $P6183 = $P6182."ast"()
    set $P6176, $P6183
  if_6177_end:
    store_lex "$past", $P6176
.annotate 'line', 1864
    find_lex $P6191, "$/"
    unless_null $P6191, vivify_2557
    $P6191 = root_new ['parrot';'Hash']
  vivify_2557:
    set $P6192, $P6191["quote"]
    unless_null $P6192, vivify_2558
    new $P6192, "Undef"
  vivify_2558:
    if $P6192, if_6190
.annotate 'line', 1868
    find_lex $P6199, "$/"
    unless_null $P6199, vivify_2559
    $P6199 = root_new ['parrot';'Hash']
  vivify_2559:
    set $P6200, $P6199["longname"]
    unless_null $P6200, vivify_2560
    new $P6200, "Undef"
  vivify_2560:
    set $S6201, $P6200
    iseq $I6202, $S6201, "HOW"
    if $I6202, if_6198
.annotate 'line', 1871
    find_lex $P6205, "$/"
    unless_null $P6205, vivify_2561
    $P6205 = root_new ['parrot';'Hash']
  vivify_2561:
    set $P6206, $P6205["longname"]
    unless_null $P6206, vivify_2562
    new $P6206, "Undef"
  vivify_2562:
    set $S6207, $P6206
    iseq $I6208, $S6207, "WHAT"
    if $I6208, if_6204
.annotate 'line', 1874
    find_lex $P6211, "$/"
    unless_null $P6211, vivify_2563
    $P6211 = root_new ['parrot';'Hash']
  vivify_2563:
    set $P6212, $P6211["longname"]
    unless_null $P6212, vivify_2564
    new $P6212, "Undef"
  vivify_2564:
    set $S6213, $P6212
    iseq $I6214, $S6213, "WHO"
    if $I6214, if_6210
.annotate 'line', 1878
    find_lex $P6216, "$past"
    unless_null $P6216, vivify_2565
    new $P6216, "Undef"
  vivify_2565:
    find_lex $P6217, "$/"
    unless_null $P6217, vivify_2566
    $P6217 = root_new ['parrot';'Hash']
  vivify_2566:
    set $P6218, $P6217["longname"]
    unless_null $P6218, vivify_2567
    new $P6218, "Undef"
  vivify_2567:
    set $S6219, $P6218
    $P6216."name"($S6219)
.annotate 'line', 1879
    find_lex $P6220, "$past"
    unless_null $P6220, vivify_2568
    new $P6220, "Undef"
  vivify_2568:
    $P6220."pasttype"("callmethod")
.annotate 'line', 1877
    goto if_6210_end
  if_6210:
.annotate 'line', 1875
    find_lex $P6215, "$past"
    unless_null $P6215, vivify_2569
    new $P6215, "Undef"
  vivify_2569:
    $P6215."pirop"("get_who PP")
  if_6210_end:
.annotate 'line', 1874
    goto if_6204_end
  if_6204:
.annotate 'line', 1872
    find_lex $P6209, "$past"
    unless_null $P6209, vivify_2570
    new $P6209, "Undef"
  vivify_2570:
    $P6209."pirop"("get_what PP")
  if_6204_end:
.annotate 'line', 1871
    goto if_6198_end
  if_6198:
.annotate 'line', 1869
    find_lex $P6203, "$past"
    unless_null $P6203, vivify_2571
    new $P6203, "Undef"
  vivify_2571:
    $P6203."pirop"("get_how PP")
  if_6198_end:
.annotate 'line', 1868
    goto if_6190_end
  if_6190:
.annotate 'line', 1865
    find_lex $P6193, "$past"
    unless_null $P6193, vivify_2572
    new $P6193, "Undef"
  vivify_2572:
    find_lex $P6194, "$/"
    unless_null $P6194, vivify_2573
    $P6194 = root_new ['parrot';'Hash']
  vivify_2573:
    set $P6195, $P6194["quote"]
    unless_null $P6195, vivify_2574
    new $P6195, "Undef"
  vivify_2574:
    $P6196 = $P6195."ast"()
    $P6193."name"($P6196)
.annotate 'line', 1866
    find_lex $P6197, "$past"
    unless_null $P6197, vivify_2575
    new $P6197, "Undef"
  vivify_2575:
    $P6197."pasttype"("callmethod")
  if_6190_end:
.annotate 'line', 1881
    find_lex $P6221, "$/"
    find_lex $P6222, "$past"
    unless_null $P6222, vivify_2576
    new $P6222, "Undef"
  vivify_2576:
    $P6223 = $P6221."!make"($P6222)
.annotate 'line', 1862
    .return ($P6223)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("533_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6225
    .param pmc param_6226
.annotate 'line', 1886
    .lex "self", param_6225
    .lex "$/", param_6226
.annotate 'line', 1887
    find_lex $P6227, "$/"
    get_hll_global $P6228, "GLOBAL"
    nqp_get_package_through_who $P6229, $P6228, "PAST"
    get_who $P6230, $P6229
    set $P6231, $P6230["Var"]
    $P6232 = $P6231."new"("self" :named("name"))
    $P6233 = $P6227."!make"($P6232)
.annotate 'line', 1886
    .return ($P6233)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("534_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6235
    .param pmc param_6236
.annotate 'line', 1890
    .lex "self", param_6235
    .lex "$/", param_6236
.annotate 'line', 1891
    new $P6237, "Undef"
    .lex "$past", $P6237
    find_lex $P6238, "$/"
    unless_null $P6238, vivify_2577
    $P6238 = root_new ['parrot';'Hash']
  vivify_2577:
    set $P6239, $P6238["args"]
    unless_null $P6239, vivify_2578
    new $P6239, "Undef"
  vivify_2578:
    $P6240 = $P6239."ast"()
    store_lex "$past", $P6240
.annotate 'line', 1892
    find_lex $P6241, "$past"
    unless_null $P6241, vivify_2579
    new $P6241, "Undef"
  vivify_2579:
    find_lex $P6242, "$/"
    unless_null $P6242, vivify_2580
    $P6242 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P6243, $P6242["deflongname"]
    unless_null $P6243, vivify_2581
    new $P6243, "Undef"
  vivify_2581:
    set $S6244, $P6243
    $P6241."name"($S6244)
.annotate 'line', 1893
    find_lex $P6245, "$/"
    find_lex $P6246, "$past"
    unless_null $P6246, vivify_2582
    new $P6246, "Undef"
  vivify_2582:
    $P6247 = $P6245."!make"($P6246)
.annotate 'line', 1890
    .return ($P6247)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("535_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6249
    .param pmc param_6250
.annotate 'line', 1896
    .const 'Sub' $P6268 = "536_1303923618.727" 
    capture_lex $P6268
    .lex "self", param_6249
    .lex "$/", param_6250
.annotate 'line', 1898
    new $P6251, "Undef"
    .lex "$var", $P6251
.annotate 'line', 1908
    new $P6252, "Undef"
    .lex "$past", $P6252
.annotate 'line', 1896
    find_lex $P6253, "$var"
    unless_null $P6253, vivify_2583
    new $P6253, "Undef"
  vivify_2583:
.annotate 'line', 1899
    find_lex $P6255, "$/"
    unless_null $P6255, vivify_2584
    $P6255 = root_new ['parrot';'Hash']
  vivify_2584:
    set $P6256, $P6255["name"]
    unless_null $P6256, vivify_2585
    new $P6256, "Undef"
  vivify_2585:
    set $S6257, $P6256
    $P6258 = "is_lexical"($S6257)
    if $P6258, if_6254
.annotate 'line', 1902
    .const 'Sub' $P6268 = "536_1303923618.727" 
    capture_lex $P6268
    $P6268()
    goto if_6254_end
  if_6254:
.annotate 'line', 1900
    get_hll_global $P6259, "GLOBAL"
    nqp_get_package_through_who $P6260, $P6259, "PAST"
    get_who $P6261, $P6260
    set $P6262, $P6261["Var"]
    find_lex $P6263, "$/"
    unless_null $P6263, vivify_2591
    $P6263 = root_new ['parrot';'Hash']
  vivify_2591:
    set $P6264, $P6263["name"]
    unless_null $P6264, vivify_2592
    new $P6264, "Undef"
  vivify_2592:
    set $S6265, $P6264
    $P6266 = $P6262."new"($S6265 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P6266
  if_6254_end:
.annotate 'line', 1908
    find_lex $P6277, "$var"
    unless_null $P6277, vivify_2593
    new $P6277, "Undef"
  vivify_2593:
    store_lex "$past", $P6277
.annotate 'line', 1909
    find_lex $P6279, "$/"
    unless_null $P6279, vivify_2594
    $P6279 = root_new ['parrot';'Hash']
  vivify_2594:
    set $P6280, $P6279["args"]
    unless_null $P6280, vivify_2595
    new $P6280, "Undef"
  vivify_2595:
    unless $P6280, if_6278_end
.annotate 'line', 1910
    find_lex $P6281, "$/"
    unless_null $P6281, vivify_2596
    $P6281 = root_new ['parrot';'Hash']
  vivify_2596:
    set $P6282, $P6281["args"]
    unless_null $P6282, vivify_2597
    $P6282 = root_new ['parrot';'ResizablePMCArray']
  vivify_2597:
    set $P6283, $P6282[0]
    unless_null $P6283, vivify_2598
    new $P6283, "Undef"
  vivify_2598:
    $P6284 = $P6283."ast"()
    store_lex "$past", $P6284
.annotate 'line', 1911
    find_lex $P6285, "$past"
    unless_null $P6285, vivify_2599
    new $P6285, "Undef"
  vivify_2599:
    find_lex $P6286, "$var"
    unless_null $P6286, vivify_2600
    new $P6286, "Undef"
  vivify_2600:
    $P6285."unshift"($P6286)
  if_6278_end:
.annotate 'line', 1913
    find_lex $P6287, "$/"
    find_lex $P6288, "$past"
    unless_null $P6288, vivify_2601
    new $P6288, "Undef"
  vivify_2601:
    $P6289 = $P6287."!make"($P6288)
.annotate 'line', 1896
    .return ($P6289)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6267"  :anon :subid("536_1303923618.727") :outer("535_1303923618.727")
.annotate 'line', 1903
    $P6269 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P6269
    find_lex $P6270, "$/"
    unless_null $P6270, vivify_2586
    $P6270 = root_new ['parrot';'Hash']
  vivify_2586:
    set $P6271, $P6270["name"]
    unless_null $P6271, vivify_2587
    $P6271 = root_new ['parrot';'Hash']
  vivify_2587:
    set $P6272, $P6271["identifier"]
    unless_null $P6272, vivify_2588
    new $P6272, "Undef"
  vivify_2588:
    clone $P6273, $P6272
    store_lex "@ns", $P6273
.annotate 'line', 1904
    find_lex $P6274, "@ns"
    unless_null $P6274, vivify_2589
    $P6274 = root_new ['parrot';'ResizablePMCArray']
  vivify_2589:
    find_lex $P6275, "$/"
    unless_null $P6275, vivify_2590
    new $P6275, "Undef"
  vivify_2590:
    $P6276 = "lexical_package_lookup"($P6274, $P6275)
    store_lex "$var", $P6276
.annotate 'line', 1902
    .return ($P6276)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("537_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6291
    .param pmc param_6292
.annotate 'line', 1916
    .lex "self", param_6291
    .lex "$/", param_6292
.annotate 'line', 1917
    new $P6293, "Undef"
    .lex "$past", $P6293
.annotate 'line', 1918
    new $P6294, "Undef"
    .lex "$pirop", $P6294
.annotate 'line', 1917
    find_lex $P6297, "$/"
    unless_null $P6297, vivify_2602
    $P6297 = root_new ['parrot';'Hash']
  vivify_2602:
    set $P6298, $P6297["args"]
    unless_null $P6298, vivify_2603
    new $P6298, "Undef"
  vivify_2603:
    if $P6298, if_6296
    get_hll_global $P6303, "GLOBAL"
    nqp_get_package_through_who $P6304, $P6303, "PAST"
    get_who $P6305, $P6304
    set $P6306, $P6305["Op"]
    find_lex $P6307, "$/"
    unless_null $P6307, vivify_2604
    new $P6307, "Undef"
  vivify_2604:
    $P6308 = $P6306."new"($P6307 :named("node"))
    set $P6295, $P6308
    goto if_6296_end
  if_6296:
    find_lex $P6299, "$/"
    unless_null $P6299, vivify_2605
    $P6299 = root_new ['parrot';'Hash']
  vivify_2605:
    set $P6300, $P6299["args"]
    unless_null $P6300, vivify_2606
    $P6300 = root_new ['parrot';'ResizablePMCArray']
  vivify_2606:
    set $P6301, $P6300[0]
    unless_null $P6301, vivify_2607
    new $P6301, "Undef"
  vivify_2607:
    $P6302 = $P6301."ast"()
    set $P6295, $P6302
  if_6296_end:
    store_lex "$past", $P6295
.annotate 'line', 1918
    find_lex $P6309, "$/"
    unless_null $P6309, vivify_2608
    $P6309 = root_new ['parrot';'Hash']
  vivify_2608:
    set $P6310, $P6309["op"]
    unless_null $P6310, vivify_2609
    new $P6310, "Undef"
  vivify_2609:
    set $S6311, $P6310
    new $P6312, 'String'
    set $P6312, $S6311
    store_lex "$pirop", $P6312
.annotate 'line', 1919
    find_lex $P6313, "$pirop"
    unless_null $P6313, vivify_2610
    new $P6313, "Undef"
  vivify_2610:
    set $S6314, $P6313
    split $P6315, "__", $S6314
    join $S6316, " ", $P6315
    new $P6317, 'String'
    set $P6317, $S6316
    store_lex "$pirop", $P6317
.annotate 'line', 1920
    find_lex $P6318, "$past"
    unless_null $P6318, vivify_2611
    new $P6318, "Undef"
  vivify_2611:
    find_lex $P6319, "$pirop"
    unless_null $P6319, vivify_2612
    new $P6319, "Undef"
  vivify_2612:
    $P6318."pirop"($P6319)
.annotate 'line', 1921
    find_lex $P6320, "$past"
    unless_null $P6320, vivify_2613
    new $P6320, "Undef"
  vivify_2613:
    $P6320."pasttype"("pirop")
.annotate 'line', 1922
    find_lex $P6321, "$/"
    find_lex $P6322, "$past"
    unless_null $P6322, vivify_2614
    new $P6322, "Undef"
  vivify_2614:
    $P6323 = $P6321."!make"($P6322)
.annotate 'line', 1916
    .return ($P6323)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("538_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6325
    .param pmc param_6326
.annotate 'line', 1925
    .lex "self", param_6325
    .lex "$/", param_6326
.annotate 'line', 1926
    find_lex $P6327, "$/"
    get_hll_global $P6328, "GLOBAL"
    nqp_get_package_through_who $P6329, $P6328, "PAST"
    get_who $P6330, $P6329
    set $P6331, $P6330["Op"]
    $P6332 = $P6331."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P6333 = $P6327."!make"($P6332)
.annotate 'line', 1925
    .return ($P6333)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("539_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6335
    .param pmc param_6336
.annotate 'line', 1931
    .lex "self", param_6335
    .lex "$/", param_6336
    find_lex $P6337, "$/"
    find_lex $P6338, "$/"
    unless_null $P6338, vivify_2615
    $P6338 = root_new ['parrot';'Hash']
  vivify_2615:
    set $P6339, $P6338["arglist"]
    unless_null $P6339, vivify_2616
    new $P6339, "Undef"
  vivify_2616:
    $P6340 = $P6339."ast"()
    $P6341 = $P6337."!make"($P6340)
    .return ($P6341)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("540_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6343
    .param pmc param_6344
.annotate 'line', 1933
    .const 'Sub' $P6358 = "541_1303923618.727" 
    capture_lex $P6358
    .lex "self", param_6343
    .lex "$/", param_6344
.annotate 'line', 1934
    new $P6345, "Undef"
    .lex "$past", $P6345
.annotate 'line', 1942
    new $P6346, "Undef"
    .lex "$i", $P6346
.annotate 'line', 1943
    new $P6347, "Undef"
    .lex "$n", $P6347
.annotate 'line', 1934
    get_hll_global $P6348, "GLOBAL"
    nqp_get_package_through_who $P6349, $P6348, "PAST"
    get_who $P6350, $P6349
    set $P6351, $P6350["Op"]
    find_lex $P6352, "$/"
    unless_null $P6352, vivify_2617
    new $P6352, "Undef"
  vivify_2617:
    $P6353 = $P6351."new"("call" :named("pasttype"), $P6352 :named("node"))
    store_lex "$past", $P6353
.annotate 'line', 1935
    find_lex $P6355, "$/"
    unless_null $P6355, vivify_2618
    $P6355 = root_new ['parrot';'Hash']
  vivify_2618:
    set $P6356, $P6355["EXPR"]
    unless_null $P6356, vivify_2619
    new $P6356, "Undef"
  vivify_2619:
    unless $P6356, if_6354_end
    .const 'Sub' $P6358 = "541_1303923618.727" 
    capture_lex $P6358
    $P6358()
  if_6354_end:
.annotate 'line', 1942
    new $P6390, "Integer"
    assign $P6390, 0
    store_lex "$i", $P6390
.annotate 'line', 1943
    find_lex $P6391, "$past"
    unless_null $P6391, vivify_2630
    new $P6391, "Undef"
  vivify_2630:
    $P6392 = $P6391."list"()
    set $N6393, $P6392
    new $P6394, 'Float'
    set $P6394, $N6393
    store_lex "$n", $P6394
.annotate 'line', 1944
    new $P6445, 'ExceptionHandler'
    set_label $P6445, loop6444_handler
    $P6445."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6445
  loop6444_test:
    find_lex $P6395, "$i"
    unless_null $P6395, vivify_2631
    new $P6395, "Undef"
  vivify_2631:
    set $N6396, $P6395
    find_lex $P6397, "$n"
    unless_null $P6397, vivify_2632
    new $P6397, "Undef"
  vivify_2632:
    set $N6398, $P6397
    islt $I6399, $N6396, $N6398
    unless $I6399, loop6444_done
  loop6444_redo:
.annotate 'line', 1945
    find_lex $P6401, "$i"
    unless_null $P6401, vivify_2633
    new $P6401, "Undef"
  vivify_2633:
    set $I6402, $P6401
    find_lex $P6403, "$past"
    unless_null $P6403, vivify_2634
    $P6403 = root_new ['parrot';'ResizablePMCArray']
  vivify_2634:
    set $P6404, $P6403[$I6402]
    unless_null $P6404, vivify_2635
    new $P6404, "Undef"
  vivify_2635:
    $S6405 = $P6404."name"()
    iseq $I6406, $S6405, "&prefix:<|>"
    unless $I6406, if_6400_end
.annotate 'line', 1946
    find_lex $P6407, "$i"
    unless_null $P6407, vivify_2636
    new $P6407, "Undef"
  vivify_2636:
    set $I6408, $P6407
    find_lex $P6409, "$past"
    unless_null $P6409, vivify_2637
    $P6409 = root_new ['parrot';'ResizablePMCArray']
  vivify_2637:
    set $P6410, $P6409[$I6408]
    unless_null $P6410, vivify_2638
    $P6410 = root_new ['parrot';'ResizablePMCArray']
  vivify_2638:
    set $P6411, $P6410[0]
    unless_null $P6411, vivify_2639
    new $P6411, "Undef"
  vivify_2639:
    find_lex $P6412, "$i"
    unless_null $P6412, vivify_2640
    new $P6412, "Undef"
  vivify_2640:
    set $I6413, $P6412
    find_lex $P6414, "$past"
    unless_null $P6414, vivify_2641
    $P6414 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P6414
  vivify_2641:
    set $P6414[$I6413], $P6411
.annotate 'line', 1947
    find_lex $P6415, "$i"
    unless_null $P6415, vivify_2642
    new $P6415, "Undef"
  vivify_2642:
    set $I6416, $P6415
    find_lex $P6417, "$past"
    unless_null $P6417, vivify_2643
    $P6417 = root_new ['parrot';'ResizablePMCArray']
  vivify_2643:
    set $P6418, $P6417[$I6416]
    unless_null $P6418, vivify_2644
    new $P6418, "Undef"
  vivify_2644:
    $P6418."flat"(1)
.annotate 'line', 1948
    find_lex $P6422, "$i"
    unless_null $P6422, vivify_2645
    new $P6422, "Undef"
  vivify_2645:
    set $I6423, $P6422
    find_lex $P6424, "$past"
    unless_null $P6424, vivify_2646
    $P6424 = root_new ['parrot';'ResizablePMCArray']
  vivify_2646:
    set $P6425, $P6424[$I6423]
    unless_null $P6425, vivify_2647
    new $P6425, "Undef"
  vivify_2647:
    get_hll_global $P6426, "GLOBAL"
    nqp_get_package_through_who $P6427, $P6426, "PAST"
    get_who $P6428, $P6427
    set $P6429, $P6428["Val"]
    $P6430 = $P6425."isa"($P6429)
    if $P6430, if_6421
    set $P6420, $P6430
    goto if_6421_end
  if_6421:
.annotate 'line', 1949
    find_lex $P6431, "$i"
    unless_null $P6431, vivify_2648
    new $P6431, "Undef"
  vivify_2648:
    set $I6432, $P6431
    find_lex $P6433, "$past"
    unless_null $P6433, vivify_2649
    $P6433 = root_new ['parrot';'ResizablePMCArray']
  vivify_2649:
    set $P6434, $P6433[$I6432]
    unless_null $P6434, vivify_2650
    new $P6434, "Undef"
  vivify_2650:
    $S6435 = $P6434."name"()
    substr $S6436, $S6435, 0, 1
    iseq $I6437, $S6436, "%"
    new $P6420, 'Integer'
    set $P6420, $I6437
  if_6421_end:
    unless $P6420, if_6419_end
.annotate 'line', 1950
    find_lex $P6438, "$i"
    unless_null $P6438, vivify_2651
    new $P6438, "Undef"
  vivify_2651:
    set $I6439, $P6438
    find_lex $P6440, "$past"
    unless_null $P6440, vivify_2652
    $P6440 = root_new ['parrot';'ResizablePMCArray']
  vivify_2652:
    set $P6441, $P6440[$I6439]
    unless_null $P6441, vivify_2653
    new $P6441, "Undef"
  vivify_2653:
    $P6441."named"(1)
  if_6419_end:
  if_6400_end:
.annotate 'line', 1945
    find_lex $P6442, "$i"
    unless_null $P6442, vivify_2654
    new $P6442, "Undef"
  vivify_2654:
    clone $P6443, $P6442
    inc $P6442
  loop6444_next:
.annotate 'line', 1944
    goto loop6444_test
  loop6444_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6446, exception, 'type'
    eq $P6446, .CONTROL_LOOP_NEXT, loop6444_next
    eq $P6446, .CONTROL_LOOP_REDO, loop6444_redo
  loop6444_done:
    pop_eh 
.annotate 'line', 1955
    find_lex $P6447, "$/"
    find_lex $P6448, "$past"
    unless_null $P6448, vivify_2655
    new $P6448, "Undef"
  vivify_2655:
    $P6449 = $P6447."!make"($P6448)
.annotate 'line', 1933
    .return ($P6449)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6357"  :anon :subid("541_1303923618.727") :outer("540_1303923618.727")
.annotate 'line', 1935
    .const 'Sub' $P6379 = "542_1303923618.727" 
    capture_lex $P6379
.annotate 'line', 1936
    new $P6359, "Undef"
    .lex "$expr", $P6359
    find_lex $P6360, "$/"
    unless_null $P6360, vivify_2620
    $P6360 = root_new ['parrot';'Hash']
  vivify_2620:
    set $P6361, $P6360["EXPR"]
    unless_null $P6361, vivify_2621
    new $P6361, "Undef"
  vivify_2621:
    $P6362 = $P6361."ast"()
    store_lex "$expr", $P6362
.annotate 'line', 1937
    find_lex $P6367, "$expr"
    unless_null $P6367, vivify_2622
    new $P6367, "Undef"
  vivify_2622:
    $S6368 = $P6367."name"()
    iseq $I6369, $S6368, "&infix:<,>"
    if $I6369, if_6366
    new $P6365, 'Integer'
    set $P6365, $I6369
    goto if_6366_end
  if_6366:
    find_lex $P6370, "$expr"
    unless_null $P6370, vivify_2623
    new $P6370, "Undef"
  vivify_2623:
    $P6371 = $P6370."named"()
    isfalse $I6372, $P6371
    new $P6365, 'Integer'
    set $P6365, $I6372
  if_6366_end:
    if $P6365, if_6364
.annotate 'line', 1940
    find_lex $P6387, "$past"
    unless_null $P6387, vivify_2624
    new $P6387, "Undef"
  vivify_2624:
    find_lex $P6388, "$expr"
    unless_null $P6388, vivify_2625
    new $P6388, "Undef"
  vivify_2625:
    $P6389 = $P6387."push"($P6388)
    set $P6363, $P6389
.annotate 'line', 1937
    goto if_6364_end
  if_6364:
.annotate 'line', 1938
    find_lex $P6374, "$expr"
    unless_null $P6374, vivify_2626
    new $P6374, "Undef"
  vivify_2626:
    $P6375 = $P6374."list"()
    defined $I6376, $P6375
    unless $I6376, for_undef_2627
    iter $P6373, $P6375
    new $P6385, 'ExceptionHandler'
    set_label $P6385, loop6384_handler
    $P6385."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P6385
  loop6384_test:
    unless $P6373, loop6384_done
    shift $P6377, $P6373
  loop6384_redo:
    .const 'Sub' $P6379 = "542_1303923618.727" 
    capture_lex $P6379
    $P6379($P6377)
  loop6384_next:
    goto loop6384_test
  loop6384_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6386, exception, 'type'
    eq $P6386, .CONTROL_LOOP_NEXT, loop6384_next
    eq $P6386, .CONTROL_LOOP_REDO, loop6384_redo
  loop6384_done:
    pop_eh 
  for_undef_2627:
.annotate 'line', 1937
    set $P6363, $P6373
  if_6364_end:
.annotate 'line', 1935
    .return ($P6363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6378"  :anon :subid("542_1303923618.727") :outer("541_1303923618.727")
    .param pmc param_6380
.annotate 'line', 1938
    .lex "$_", param_6380
    find_lex $P6381, "$past"
    unless_null $P6381, vivify_2628
    new $P6381, "Undef"
  vivify_2628:
    find_lex $P6382, "$_"
    unless_null $P6382, vivify_2629
    new $P6382, "Undef"
  vivify_2629:
    $P6383 = $P6381."push"($P6382)
    .return ($P6383)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("543_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6451
    .param pmc param_6452
.annotate 'line', 1958
    .lex "self", param_6451
    .lex "$/", param_6452
    find_lex $P6453, "$/"
    find_lex $P6454, "$/"
    unless_null $P6454, vivify_2656
    $P6454 = root_new ['parrot';'Hash']
  vivify_2656:
    set $P6455, $P6454["multi_declarator"]
    unless_null $P6455, vivify_2657
    new $P6455, "Undef"
  vivify_2657:
    $P6456 = $P6455."ast"()
    $P6457 = $P6453."!make"($P6456)
    .return ($P6457)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("544_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6459
    .param pmc param_6460
.annotate 'line', 1960
    .lex "self", param_6459
    .lex "$/", param_6460
    find_lex $P6461, "$/"
    find_lex $P6462, "$/"
    unless_null $P6462, vivify_2658
    $P6462 = root_new ['parrot';'Hash']
  vivify_2658:
    set $P6463, $P6462["value"]
    unless_null $P6463, vivify_2659
    new $P6463, "Undef"
  vivify_2659:
    $P6464 = $P6463."ast"()
    $P6465 = $P6461."!make"($P6464)
    .return ($P6465)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("545_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6467
    .param pmc param_6468
.annotate 'line', 1962
    .lex "self", param_6467
    .lex "$/", param_6468
.annotate 'line', 1963
    find_lex $P6469, "$/"
.annotate 'line', 1964
    find_lex $P6472, "$/"
    unless_null $P6472, vivify_2660
    $P6472 = root_new ['parrot';'Hash']
  vivify_2660:
    set $P6473, $P6472["EXPR"]
    unless_null $P6473, vivify_2661
    new $P6473, "Undef"
  vivify_2661:
    if $P6473, if_6471
.annotate 'line', 1965
    get_hll_global $P6478, "GLOBAL"
    nqp_get_package_through_who $P6479, $P6478, "PAST"
    get_who $P6480, $P6479
    set $P6481, $P6480["Op"]
    find_lex $P6482, "$/"
    unless_null $P6482, vivify_2662
    new $P6482, "Undef"
  vivify_2662:
    $P6483 = $P6481."new"("list" :named("pasttype"), $P6482 :named("node"))
    set $P6470, $P6483
.annotate 'line', 1964
    goto if_6471_end
  if_6471:
    find_lex $P6474, "$/"
    unless_null $P6474, vivify_2663
    $P6474 = root_new ['parrot';'Hash']
  vivify_2663:
    set $P6475, $P6474["EXPR"]
    unless_null $P6475, vivify_2664
    $P6475 = root_new ['parrot';'ResizablePMCArray']
  vivify_2664:
    set $P6476, $P6475[0]
    unless_null $P6476, vivify_2665
    new $P6476, "Undef"
  vivify_2665:
    $P6477 = $P6476."ast"()
    set $P6470, $P6477
  if_6471_end:
    $P6484 = $P6469."!make"($P6470)
.annotate 'line', 1962
    .return ($P6484)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("546_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6486
    .param pmc param_6487
.annotate 'line', 1968
    .lex "self", param_6486
    .lex "$/", param_6487
.annotate 'line', 1969
    new $P6488, "Undef"
    .lex "$past", $P6488
.annotate 'line', 1968
    find_lex $P6489, "$past"
    unless_null $P6489, vivify_2666
    new $P6489, "Undef"
  vivify_2666:
.annotate 'line', 1970
    find_lex $P6491, "$/"
    unless_null $P6491, vivify_2667
    $P6491 = root_new ['parrot';'Hash']
  vivify_2667:
    set $P6492, $P6491["EXPR"]
    unless_null $P6492, vivify_2668
    new $P6492, "Undef"
  vivify_2668:
    if $P6492, if_6490
.annotate 'line', 1977
    get_hll_global $P6507, "GLOBAL"
    nqp_get_package_through_who $P6508, $P6507, "PAST"
    get_who $P6509, $P6508
    set $P6510, $P6509["Op"]
    $P6511 = $P6510."new"("list" :named("pasttype"))
    store_lex "$past", $P6511
.annotate 'line', 1976
    goto if_6490_end
  if_6490:
.annotate 'line', 1971
    find_lex $P6493, "$/"
    unless_null $P6493, vivify_2669
    $P6493 = root_new ['parrot';'Hash']
  vivify_2669:
    set $P6494, $P6493["EXPR"]
    unless_null $P6494, vivify_2670
    $P6494 = root_new ['parrot';'ResizablePMCArray']
  vivify_2670:
    set $P6495, $P6494[0]
    unless_null $P6495, vivify_2671
    new $P6495, "Undef"
  vivify_2671:
    $P6496 = $P6495."ast"()
    store_lex "$past", $P6496
.annotate 'line', 1972
    find_lex $P6498, "$past"
    unless_null $P6498, vivify_2672
    new $P6498, "Undef"
  vivify_2672:
    $S6499 = $P6498."name"()
    isne $I6500, $S6499, "&infix:<,>"
    unless $I6500, if_6497_end
.annotate 'line', 1973
    get_hll_global $P6501, "GLOBAL"
    nqp_get_package_through_who $P6502, $P6501, "PAST"
    get_who $P6503, $P6502
    set $P6504, $P6503["Op"]
    find_lex $P6505, "$past"
    unless_null $P6505, vivify_2673
    new $P6505, "Undef"
  vivify_2673:
    $P6506 = $P6504."new"($P6505, "list" :named("pasttype"))
    store_lex "$past", $P6506
  if_6497_end:
  if_6490_end:
.annotate 'line', 1979
    find_lex $P6512, "$past"
    unless_null $P6512, vivify_2674
    new $P6512, "Undef"
  vivify_2674:
    $P6512."name"("&circumfix:<[ ]>")
.annotate 'line', 1980
    find_lex $P6513, "$/"
    find_lex $P6514, "$past"
    unless_null $P6514, vivify_2675
    new $P6514, "Undef"
  vivify_2675:
    $P6515 = $P6513."!make"($P6514)
.annotate 'line', 1968
    .return ($P6515)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("547_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6517
    .param pmc param_6518
.annotate 'line', 1983
    .lex "self", param_6517
    .lex "$/", param_6518
    find_lex $P6519, "$/"
    find_lex $P6520, "$/"
    unless_null $P6520, vivify_2676
    $P6520 = root_new ['parrot';'Hash']
  vivify_2676:
    set $P6521, $P6520["quote_EXPR"]
    unless_null $P6521, vivify_2677
    new $P6521, "Undef"
  vivify_2677:
    $P6522 = $P6521."ast"()
    $P6523 = $P6519."!make"($P6522)
    .return ($P6523)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("548_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6525
    .param pmc param_6526
.annotate 'line', 1984
    .lex "self", param_6525
    .lex "$/", param_6526
    find_lex $P6527, "$/"
    find_lex $P6528, "$/"
    unless_null $P6528, vivify_2678
    $P6528 = root_new ['parrot';'Hash']
  vivify_2678:
    set $P6529, $P6528["quote_EXPR"]
    unless_null $P6529, vivify_2679
    new $P6529, "Undef"
  vivify_2679:
    $P6530 = $P6529."ast"()
    $P6531 = $P6527."!make"($P6530)
    .return ($P6531)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("549_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6533
    .param pmc param_6534
.annotate 'line', 1986
    .const 'Sub' $P6545 = "550_1303923618.727" 
    capture_lex $P6545
    .lex "self", param_6533
    .lex "$/", param_6534
.annotate 'line', 1987
    find_lex $P6537, "$/"
    unless_null $P6537, vivify_2680
    $P6537 = root_new ['parrot';'Hash']
  vivify_2680:
    set $P6538, $P6537["pblock"]
    unless_null $P6538, vivify_2681
    $P6538 = root_new ['parrot';'Hash']
  vivify_2681:
    set $P6539, $P6538["blockoid"]
    unless_null $P6539, vivify_2682
    $P6539 = root_new ['parrot';'Hash']
  vivify_2682:
    set $P6540, $P6539["statementlist"]
    unless_null $P6540, vivify_2683
    $P6540 = root_new ['parrot';'Hash']
  vivify_2683:
    set $P6541, $P6540["statement"]
    unless_null $P6541, vivify_2684
    new $P6541, "Undef"
  vivify_2684:
    set $N6542, $P6541
    isgt $I6543, $N6542, 0.0
    if $I6543, if_6536
.annotate 'line', 1992
    find_lex $P6558, "$/"
    unless_null $P6558, vivify_2685
    $P6558 = root_new ['parrot';'Hash']
  vivify_2685:
    set $P6559, $P6558["pblock"]
    unless_null $P6559, vivify_2686
    $P6559 = root_new ['parrot';'Hash']
  vivify_2686:
    set $P6560, $P6559["blockoid"]
    unless_null $P6560, vivify_2687
    $P6560 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P6561, $P6560["you_are_here"]
    unless_null $P6561, vivify_2688
    new $P6561, "Undef"
  vivify_2688:
    if $P6561, if_6557
.annotate 'line', 1996
    find_lex $P6567, "$/"
    $P6568 = "vivitype"("%")
    $P6569 = $P6567."!make"($P6568)
.annotate 'line', 1995
    set $P6556, $P6569
.annotate 'line', 1992
    goto if_6557_end
  if_6557:
.annotate 'line', 1993
    find_lex $P6562, "$/"
    find_lex $P6563, "$/"
    unless_null $P6563, vivify_2689
    $P6563 = root_new ['parrot';'Hash']
  vivify_2689:
    set $P6564, $P6563["pblock"]
    unless_null $P6564, vivify_2690
    new $P6564, "Undef"
  vivify_2690:
    $P6565 = $P6564."ast"()
    $P6566 = $P6562."!make"($P6565)
.annotate 'line', 1992
    set $P6556, $P6566
  if_6557_end:
    set $P6535, $P6556
.annotate 'line', 1987
    goto if_6536_end
  if_6536:
    .const 'Sub' $P6545 = "550_1303923618.727" 
    capture_lex $P6545
    $P6555 = $P6545()
    set $P6535, $P6555
  if_6536_end:
.annotate 'line', 1986
    .return ($P6535)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block6544"  :anon :subid("550_1303923618.727") :outer("549_1303923618.727")
.annotate 'line', 1988
    new $P6546, "Undef"
    .lex "$past", $P6546
    find_lex $P6547, "$/"
    unless_null $P6547, vivify_2691
    $P6547 = root_new ['parrot';'Hash']
  vivify_2691:
    set $P6548, $P6547["pblock"]
    unless_null $P6548, vivify_2692
    new $P6548, "Undef"
  vivify_2692:
    $P6549 = $P6548."ast"()
    store_lex "$past", $P6549
.annotate 'line', 1989
    new $P6550, "Integer"
    assign $P6550, 1
    find_lex $P6551, "$past"
    unless_null $P6551, vivify_2693
    $P6551 = root_new ['parrot';'Hash']
    store_lex "$past", $P6551
  vivify_2693:
    set $P6551["bareblock"], $P6550
.annotate 'line', 1990
    find_dynamic_lex $P6552, "$/"
    find_lex $P6553, "$past"
    unless_null $P6553, vivify_2694
    new $P6553, "Undef"
  vivify_2694:
    $P6554 = $P6552."!make"($P6553)
.annotate 'line', 1987
    .return ($P6554)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("551_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6571
    .param pmc param_6572
.annotate 'line', 2000
    .lex "self", param_6571
    .lex "$/", param_6572
.annotate 'line', 2001
    new $P6573, "Undef"
    .lex "$name", $P6573
    find_lex $P6576, "$/"
    unless_null $P6576, vivify_2695
    $P6576 = root_new ['parrot';'Hash']
  vivify_2695:
    set $P6577, $P6576["sigil"]
    unless_null $P6577, vivify_2696
    new $P6577, "Undef"
  vivify_2696:
    set $S6578, $P6577
    iseq $I6579, $S6578, "@"
    if $I6579, if_6575
.annotate 'line', 2002
    find_lex $P6583, "$/"
    unless_null $P6583, vivify_2697
    $P6583 = root_new ['parrot';'Hash']
  vivify_2697:
    set $P6584, $P6583["sigil"]
    unless_null $P6584, vivify_2698
    new $P6584, "Undef"
  vivify_2698:
    set $S6585, $P6584
    iseq $I6586, $S6585, "%"
    if $I6586, if_6582
    new $P6588, "String"
    assign $P6588, "item"
    set $P6581, $P6588
    goto if_6582_end
  if_6582:
    new $P6587, "String"
    assign $P6587, "hash"
    set $P6581, $P6587
  if_6582_end:
    set $P6574, $P6581
.annotate 'line', 2001
    goto if_6575_end
  if_6575:
    new $P6580, "String"
    assign $P6580, "list"
    set $P6574, $P6580
  if_6575_end:
    store_lex "$name", $P6574
.annotate 'line', 2004
    find_lex $P6589, "$/"
    get_hll_global $P6590, "GLOBAL"
    nqp_get_package_through_who $P6591, $P6590, "PAST"
    get_who $P6592, $P6591
    set $P6593, $P6592["Op"]
    find_lex $P6594, "$name"
    unless_null $P6594, vivify_2699
    new $P6594, "Undef"
  vivify_2699:
    find_lex $P6595, "$/"
    unless_null $P6595, vivify_2700
    $P6595 = root_new ['parrot';'Hash']
  vivify_2700:
    set $P6596, $P6595["semilist"]
    unless_null $P6596, vivify_2701
    new $P6596, "Undef"
  vivify_2701:
    $P6597 = $P6596."ast"()
    $P6598 = $P6593."new"($P6597, "callmethod" :named("pasttype"), $P6594 :named("name"))
    $P6599 = $P6589."!make"($P6598)
.annotate 'line', 2000
    .return ($P6599)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("552_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6601
    .param pmc param_6602
.annotate 'line', 2007
    .lex "self", param_6601
    .lex "$/", param_6602
    find_lex $P6603, "$/"
    find_lex $P6604, "$/"
    unless_null $P6604, vivify_2702
    $P6604 = root_new ['parrot';'Hash']
  vivify_2702:
    set $P6605, $P6604["statement"]
    unless_null $P6605, vivify_2703
    new $P6605, "Undef"
  vivify_2703:
    $P6606 = $P6605."ast"()
    $P6607 = $P6603."!make"($P6606)
    .return ($P6607)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("553_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6609
    .param pmc param_6610
.annotate 'line', 2009
    .lex "self", param_6609
    .lex "$/", param_6610
.annotate 'line', 2010
    find_lex $P6611, "$/"
    get_hll_global $P6612, "GLOBAL"
    nqp_get_package_through_who $P6613, $P6612, "PAST"
    get_who $P6614, $P6613
    set $P6615, $P6614["Var"]
    find_lex $P6616, "$/"
    unless_null $P6616, vivify_2704
    $P6616 = root_new ['parrot';'Hash']
  vivify_2704:
    set $P6617, $P6616["EXPR"]
    unless_null $P6617, vivify_2705
    new $P6617, "Undef"
  vivify_2705:
    $P6618 = $P6617."ast"()
.annotate 'line', 2012
    $P6619 = "vivitype"("@")
    $P6620 = $P6615."new"($P6618, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P6619 :named("vivibase"))
.annotate 'line', 2010
    $P6621 = $P6611."!make"($P6620)
.annotate 'line', 2009
    .return ($P6621)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("554_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6623
    .param pmc param_6624
.annotate 'line', 2015
    .lex "self", param_6623
    .lex "$/", param_6624
.annotate 'line', 2016
    find_lex $P6625, "$/"
    get_hll_global $P6626, "GLOBAL"
    nqp_get_package_through_who $P6627, $P6626, "PAST"
    get_who $P6628, $P6627
    set $P6629, $P6628["Var"]
    find_lex $P6630, "$/"
    unless_null $P6630, vivify_2706
    $P6630 = root_new ['parrot';'Hash']
  vivify_2706:
    set $P6631, $P6630["EXPR"]
    unless_null $P6631, vivify_2707
    new $P6631, "Undef"
  vivify_2707:
    $P6632 = $P6631."ast"()
.annotate 'line', 2018
    $P6633 = "vivitype"("%")
    $P6634 = $P6629."new"($P6632, "keyed" :named("scope"), "Undef" :named("viviself"), $P6633 :named("vivibase"))
.annotate 'line', 2016
    $P6635 = $P6625."!make"($P6634)
.annotate 'line', 2015
    .return ($P6635)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("555_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6637
    .param pmc param_6638
.annotate 'line', 2021
    .lex "self", param_6637
    .lex "$/", param_6638
.annotate 'line', 2022
    find_lex $P6639, "$/"
    get_hll_global $P6640, "GLOBAL"
    nqp_get_package_through_who $P6641, $P6640, "PAST"
    get_who $P6642, $P6641
    set $P6643, $P6642["Var"]
    find_lex $P6644, "$/"
    unless_null $P6644, vivify_2708
    $P6644 = root_new ['parrot';'Hash']
  vivify_2708:
    set $P6645, $P6644["quote_EXPR"]
    unless_null $P6645, vivify_2709
    new $P6645, "Undef"
  vivify_2709:
    $P6646 = $P6645."ast"()
.annotate 'line', 2024
    $P6647 = "vivitype"("%")
    $P6648 = $P6643."new"($P6646, "keyed" :named("scope"), "Undef" :named("viviself"), $P6647 :named("vivibase"))
.annotate 'line', 2022
    $P6649 = $P6639."!make"($P6648)
.annotate 'line', 2021
    .return ($P6649)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("556_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6651
    .param pmc param_6652
.annotate 'line', 2027
    .lex "self", param_6651
    .lex "$/", param_6652
.annotate 'line', 2028
    find_lex $P6653, "$/"
    find_lex $P6654, "$/"
    unless_null $P6654, vivify_2710
    $P6654 = root_new ['parrot';'Hash']
  vivify_2710:
    set $P6655, $P6654["arglist"]
    unless_null $P6655, vivify_2711
    new $P6655, "Undef"
  vivify_2711:
    $P6656 = $P6655."ast"()
    $P6657 = $P6653."!make"($P6656)
.annotate 'line', 2027
    .return ($P6657)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("557_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6659
    .param pmc param_6660
.annotate 'line', 2031
    .lex "self", param_6659
    .lex "$/", param_6660
.annotate 'line', 2032
    find_lex $P6661, "$/"
    find_lex $P6664, "$/"
    unless_null $P6664, vivify_2712
    $P6664 = root_new ['parrot';'Hash']
  vivify_2712:
    set $P6665, $P6664["quote"]
    unless_null $P6665, vivify_2713
    new $P6665, "Undef"
  vivify_2713:
    if $P6665, if_6663
    find_lex $P6669, "$/"
    unless_null $P6669, vivify_2714
    $P6669 = root_new ['parrot';'Hash']
  vivify_2714:
    set $P6670, $P6669["number"]
    unless_null $P6670, vivify_2715
    new $P6670, "Undef"
  vivify_2715:
    $P6671 = $P6670."ast"()
    set $P6662, $P6671
    goto if_6663_end
  if_6663:
    find_lex $P6666, "$/"
    unless_null $P6666, vivify_2716
    $P6666 = root_new ['parrot';'Hash']
  vivify_2716:
    set $P6667, $P6666["quote"]
    unless_null $P6667, vivify_2717
    new $P6667, "Undef"
  vivify_2717:
    $P6668 = $P6667."ast"()
    set $P6662, $P6668
  if_6663_end:
    $P6672 = $P6661."!make"($P6662)
.annotate 'line', 2031
    .return ($P6672)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("558_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6674
    .param pmc param_6675
.annotate 'line', 2035
    .lex "self", param_6674
    .lex "$/", param_6675
.annotate 'line', 2036
    new $P6676, "Undef"
    .lex "$value", $P6676
    find_lex $P6679, "$/"
    unless_null $P6679, vivify_2718
    $P6679 = root_new ['parrot';'Hash']
  vivify_2718:
    set $P6680, $P6679["dec_number"]
    unless_null $P6680, vivify_2719
    new $P6680, "Undef"
  vivify_2719:
    if $P6680, if_6678
    find_lex $P6684, "$/"
    unless_null $P6684, vivify_2720
    $P6684 = root_new ['parrot';'Hash']
  vivify_2720:
    set $P6685, $P6684["integer"]
    unless_null $P6685, vivify_2721
    new $P6685, "Undef"
  vivify_2721:
    $P6686 = $P6685."ast"()
    set $P6677, $P6686
    goto if_6678_end
  if_6678:
    find_lex $P6681, "$/"
    unless_null $P6681, vivify_2722
    $P6681 = root_new ['parrot';'Hash']
  vivify_2722:
    set $P6682, $P6681["dec_number"]
    unless_null $P6682, vivify_2723
    new $P6682, "Undef"
  vivify_2723:
    $P6683 = $P6682."ast"()
    set $P6677, $P6683
  if_6678_end:
    store_lex "$value", $P6677
.annotate 'line', 2037
    find_lex $P6688, "$/"
    unless_null $P6688, vivify_2724
    $P6688 = root_new ['parrot';'Hash']
  vivify_2724:
    set $P6689, $P6688["sign"]
    unless_null $P6689, vivify_2725
    new $P6689, "Undef"
  vivify_2725:
    set $S6690, $P6689
    iseq $I6691, $S6690, "-"
    unless $I6691, if_6687_end
    find_lex $P6692, "$value"
    unless_null $P6692, vivify_2726
    new $P6692, "Undef"
  vivify_2726:
    neg $P6693, $P6692
    store_lex "$value", $P6693
  if_6687_end:
.annotate 'line', 2038
    find_lex $P6694, "$/"
    get_hll_global $P6695, "GLOBAL"
    nqp_get_package_through_who $P6696, $P6695, "PAST"
    get_who $P6697, $P6696
    set $P6698, $P6697["Val"]
    find_lex $P6699, "$value"
    unless_null $P6699, vivify_2727
    new $P6699, "Undef"
  vivify_2727:
    $P6700 = $P6698."new"($P6699 :named("value"))
    $P6701 = $P6694."!make"($P6700)
.annotate 'line', 2035
    .return ($P6701)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("559_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6703
    .param pmc param_6704
.annotate 'line', 2041
    .lex "self", param_6703
    .lex "$/", param_6704
    find_lex $P6705, "$/"
    find_lex $P6706, "$/"
    unless_null $P6706, vivify_2728
    $P6706 = root_new ['parrot';'Hash']
  vivify_2728:
    set $P6707, $P6706["quote_EXPR"]
    unless_null $P6707, vivify_2729
    new $P6707, "Undef"
  vivify_2729:
    $P6708 = $P6707."ast"()
    $P6709 = $P6705."!make"($P6708)
    .return ($P6709)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("560_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6711
    .param pmc param_6712
.annotate 'line', 2042
    .lex "self", param_6711
    .lex "$/", param_6712
    find_lex $P6713, "$/"
    find_lex $P6714, "$/"
    unless_null $P6714, vivify_2730
    $P6714 = root_new ['parrot';'Hash']
  vivify_2730:
    set $P6715, $P6714["quote_EXPR"]
    unless_null $P6715, vivify_2731
    new $P6715, "Undef"
  vivify_2731:
    $P6716 = $P6715."ast"()
    $P6717 = $P6713."!make"($P6716)
    .return ($P6717)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("561_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6719
    .param pmc param_6720
.annotate 'line', 2043
    .lex "self", param_6719
    .lex "$/", param_6720
    find_lex $P6721, "$/"
    find_lex $P6722, "$/"
    unless_null $P6722, vivify_2732
    $P6722 = root_new ['parrot';'Hash']
  vivify_2732:
    set $P6723, $P6722["quote_EXPR"]
    unless_null $P6723, vivify_2733
    new $P6723, "Undef"
  vivify_2733:
    $P6724 = $P6723."ast"()
    $P6725 = $P6721."!make"($P6724)
    .return ($P6725)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("562_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6727
    .param pmc param_6728
.annotate 'line', 2044
    .lex "self", param_6727
    .lex "$/", param_6728
    find_lex $P6729, "$/"
    find_lex $P6730, "$/"
    unless_null $P6730, vivify_2734
    $P6730 = root_new ['parrot';'Hash']
  vivify_2734:
    set $P6731, $P6730["quote_EXPR"]
    unless_null $P6731, vivify_2735
    new $P6731, "Undef"
  vivify_2735:
    $P6732 = $P6731."ast"()
    $P6733 = $P6729."!make"($P6732)
    .return ($P6733)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("563_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6735
    .param pmc param_6736
.annotate 'line', 2045
    .lex "self", param_6735
    .lex "$/", param_6736
    find_lex $P6737, "$/"
    find_lex $P6738, "$/"
    unless_null $P6738, vivify_2736
    $P6738 = root_new ['parrot';'Hash']
  vivify_2736:
    set $P6739, $P6738["quote_EXPR"]
    unless_null $P6739, vivify_2737
    new $P6739, "Undef"
  vivify_2737:
    $P6740 = $P6739."ast"()
    $P6741 = $P6737."!make"($P6740)
    .return ($P6741)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("564_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6743
    .param pmc param_6744
.annotate 'line', 2046
    .lex "self", param_6743
    .lex "$/", param_6744
.annotate 'line', 2047
    find_lex $P6745, "$/"
    get_hll_global $P6746, "GLOBAL"
    nqp_get_package_through_who $P6747, $P6746, "PAST"
    get_who $P6748, $P6747
    set $P6749, $P6748["Op"]
    find_lex $P6750, "$/"
    unless_null $P6750, vivify_2738
    $P6750 = root_new ['parrot';'Hash']
  vivify_2738:
    set $P6751, $P6750["quote_EXPR"]
    unless_null $P6751, vivify_2739
    new $P6751, "Undef"
  vivify_2739:
    $P6752 = $P6751."ast"()
    $P6753 = $P6752."value"()
    find_lex $P6754, "$/"
    unless_null $P6754, vivify_2740
    new $P6754, "Undef"
  vivify_2740:
    $P6755 = $P6749."new"($P6753 :named("inline"), "inline" :named("pasttype"), $P6754 :named("node"))
    $P6756 = $P6745."!make"($P6755)
.annotate 'line', 2046
    .return ($P6756)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("565_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6760
    .param pmc param_6761
    .param pmc param_6762 :optional
    .param int has_param_6762 :opt_flag
.annotate 'line', 2052
    new $P6759, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P6759, control_6758
    push_eh $P6759
    .lex "self", param_6760
    .lex "$/", param_6761
    if has_param_6762, optparam_2741
    new $P6763, "Undef"
    set param_6762, $P6763
  optparam_2741:
    .lex "$key", param_6762
.annotate 'line', 2059
    new $P6764, "Undef"
    .lex "$regex", $P6764
.annotate 'line', 2061
    new $P6765, "Undef"
    .lex "$past", $P6765
.annotate 'line', 2053
    find_lex $P6767, "$key"
    unless_null $P6767, vivify_2742
    new $P6767, "Undef"
  vivify_2742:
    set $S6768, $P6767
    iseq $I6769, $S6768, "open"
    unless $I6769, if_6766_end
.annotate 'line', 2054
    null $P6770
    get_hll_global $P6771, "GLOBAL"
    nqp_get_package_through_who $P6772, $P6771, "Regex"
    nqp_get_package_through_who $P6773, $P6772, "P6Regex"
    nqp_get_package_through_who $P6774, $P6773, "Actions"
    get_who $P6775, $P6774
    set $P6775["$REGEXNAME"], $P6770
.annotate 'line', 2055
    find_lex $P6776, "$?PACKAGE"
    get_who $P6777, $P6776
    set $P6778, $P6777["@BLOCK"]
    unless_null $P6778, vivify_2743
    $P6778 = root_new ['parrot';'ResizablePMCArray']
  vivify_2743:
    set $P6779, $P6778[0]
    unless_null $P6779, vivify_2744
    new $P6779, "Undef"
  vivify_2744:
    $P6779."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2056
    find_lex $P6780, "$?PACKAGE"
    get_who $P6781, $P6780
    set $P6782, $P6781["@BLOCK"]
    unless_null $P6782, vivify_2745
    $P6782 = root_new ['parrot';'ResizablePMCArray']
  vivify_2745:
    set $P6783, $P6782[0]
    unless_null $P6783, vivify_2746
    new $P6783, "Undef"
  vivify_2746:
    $P6783."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2057
    new $P6784, "Exception"
    set $P6784['type'], .CONTROL_RETURN
    new $P6785, "Integer"
    assign $P6785, 0
    setattribute $P6784, 'payload', $P6785
    throw $P6784
  if_6766_end:
.annotate 'line', 2060
    get_hll_global $P6786, "GLOBAL"
    nqp_get_package_through_who $P6787, $P6786, "Regex"
    nqp_get_package_through_who $P6788, $P6787, "P6Regex"
    nqp_get_package_through_who $P6789, $P6788, "Actions"
    get_who $P6790, $P6789
    set $P6791, $P6790["buildsub"]
    find_lex $P6792, "$/"
    unless_null $P6792, vivify_2747
    $P6792 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P6793, $P6792["p6regex"]
    unless_null $P6793, vivify_2748
    new $P6793, "Undef"
  vivify_2748:
    $P6794 = $P6793."ast"()
    find_lex $P6795, "$?PACKAGE"
    get_who $P6796, $P6795
    set $P6797, $P6796["@BLOCK"]
    unless_null $P6797, vivify_2749
    $P6797 = root_new ['parrot';'ResizablePMCArray']
  vivify_2749:
    $P6798 = $P6797."shift"()
    $P6799 = $P6791($P6794, $P6798)
    store_lex "$regex", $P6799
.annotate 'line', 2062
    get_hll_global $P6800, "GLOBAL"
    nqp_get_package_through_who $P6801, $P6800, "PAST"
    get_who $P6802, $P6801
    set $P6803, $P6802["Op"]
.annotate 'line', 2064
    get_hll_global $P6804, "GLOBAL"
    nqp_get_package_through_who $P6805, $P6804, "PAST"
    get_who $P6806, $P6805
    set $P6807, $P6806["Var"]
    new $P6808, "ResizablePMCArray"
    push $P6808, "Regex"
    $P6809 = $P6807."new"("Regex" :named("name"), $P6808 :named("namespace"), "package" :named("scope"))
    find_lex $P6810, "$regex"
    unless_null $P6810, vivify_2750
    new $P6810, "Undef"
  vivify_2750:
    $P6811 = $P6803."new"($P6809, $P6810, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2062
    store_lex "$past", $P6811
.annotate 'line', 2068
    find_lex $P6812, "$regex"
    unless_null $P6812, vivify_2751
    new $P6812, "Undef"
  vivify_2751:
    find_lex $P6813, "$past"
    unless_null $P6813, vivify_2752
    $P6813 = root_new ['parrot';'Hash']
    store_lex "$past", $P6813
  vivify_2752:
    set $P6813["sink"], $P6812
.annotate 'line', 2069
    find_lex $P6814, "$/"
    find_lex $P6815, "$past"
    unless_null $P6815, vivify_2753
    new $P6815, "Undef"
  vivify_2753:
    $P6816 = $P6814."!make"($P6815)
.annotate 'line', 2052
    .return ($P6816)
  control_6758:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P6817, exception, "payload"
    .return ($P6817)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("566_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6819
    .param pmc param_6820
.annotate 'line', 2072
    .lex "self", param_6819
    .lex "$/", param_6820
    find_lex $P6821, "$/"
    find_lex $P6822, "$/"
    unless_null $P6822, vivify_2754
    $P6822 = root_new ['parrot';'Hash']
  vivify_2754:
    set $P6823, $P6822["variable"]
    unless_null $P6823, vivify_2755
    new $P6823, "Undef"
  vivify_2755:
    $P6824 = $P6823."ast"()
    $P6825 = $P6821."!make"($P6824)
    .return ($P6825)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("567_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6827
    .param pmc param_6828
.annotate 'line', 2073
    .lex "self", param_6827
    .lex "$/", param_6828
.annotate 'line', 2074
    find_lex $P6829, "$/"
    get_hll_global $P6830, "GLOBAL"
    nqp_get_package_through_who $P6831, $P6830, "PAST"
    get_who $P6832, $P6831
    set $P6833, $P6832["Op"]
.annotate 'line', 2075
    find_lex $P6834, "$/"
    unless_null $P6834, vivify_2756
    $P6834 = root_new ['parrot';'Hash']
  vivify_2756:
    set $P6835, $P6834["block"]
    unless_null $P6835, vivify_2757
    new $P6835, "Undef"
  vivify_2757:
    $P6836 = $P6835."ast"()
    $P6837 = "block_immediate"($P6836)
    find_lex $P6838, "$/"
    unless_null $P6838, vivify_2758
    new $P6838, "Undef"
  vivify_2758:
    $P6839 = $P6833."new"($P6837, "set S*" :named("pirop"), $P6838 :named("node"))
.annotate 'line', 2074
    $P6840 = $P6829."!make"($P6839)
.annotate 'line', 2073
    .return ($P6840)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("568_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6842
    .param pmc param_6843
.annotate 'line', 2078
    .lex "self", param_6842
    .lex "$/", param_6843
    find_lex $P6844, "$/"
    $P6845 = $P6844."!make"("\e")
    .return ($P6845)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("569_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6847
    .param pmc param_6848
.annotate 'line', 2082
    .lex "self", param_6847
    .lex "$/", param_6848
    find_lex $P6849, "$/"
    find_lex $P6850, "$/"
    unless_null $P6850, vivify_2759
    $P6850 = root_new ['parrot';'Hash']
  vivify_2759:
    set $P6851, $P6850["dotty"]
    unless_null $P6851, vivify_2760
    new $P6851, "Undef"
  vivify_2760:
    $P6852 = $P6851."ast"()
    $P6853 = $P6849."!make"($P6852)
    .return ($P6853)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("570_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6855
    .param pmc param_6856
.annotate 'line', 2084
    .lex "self", param_6855
    .lex "$/", param_6856
.annotate 'line', 2085
    find_lex $P6857, "$/"
    get_hll_global $P6858, "GLOBAL"
    nqp_get_package_through_who $P6859, $P6858, "PAST"
    get_who $P6860, $P6859
    set $P6861, $P6860["Op"]
.annotate 'line', 2086
    new $P6862, "ResizablePMCArray"
    push $P6862, "    clone %r, %0"
    push $P6862, "    inc %0"
    $P6863 = $P6861."new"("postfix:<++>" :named("name"), $P6862 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2085
    $P6864 = $P6857."!make"($P6863)
.annotate 'line', 2084
    .return ($P6864)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("571_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6866
    .param pmc param_6867
.annotate 'line', 2090
    .lex "self", param_6866
    .lex "$/", param_6867
.annotate 'line', 2091
    find_lex $P6868, "$/"
    get_hll_global $P6869, "GLOBAL"
    nqp_get_package_through_who $P6870, $P6869, "PAST"
    get_who $P6871, $P6870
    set $P6872, $P6871["Op"]
.annotate 'line', 2092
    new $P6873, "ResizablePMCArray"
    push $P6873, "    clone %r, %0"
    push $P6873, "    dec %0"
    $P6874 = $P6872."new"("postfix:<-->" :named("name"), $P6873 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2091
    $P6875 = $P6868."!make"($P6874)
.annotate 'line', 2090
    .return ($P6875)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("572_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6877
    .param pmc param_6878
.annotate 'line', 2096
    .lex "self", param_6877
    .lex "$/", param_6878
.annotate 'line', 2097
    find_lex $P6879, "$/"
    get_hll_global $P6880, "GLOBAL"
    nqp_get_package_through_who $P6881, $P6880, "PAST"
    get_who $P6882, $P6881
    set $P6883, $P6882["Op"]
.annotate 'line', 2098
    get_hll_global $P6884, "GLOBAL"
    nqp_get_package_through_who $P6885, $P6884, "PAST"
    get_who $P6886, $P6885
    set $P6887, $P6886["Var"]
    $P6888 = $P6887."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P6889, "$/"
    unless_null $P6889, vivify_2761
    new $P6889, "Undef"
  vivify_2761:
    $P6890 = $P6883."new"($P6888, "callmethod" :named("pasttype"), "!make" :named("name"), $P6889 :named("node"))
.annotate 'line', 2097
    $P6891 = $P6879."!make"($P6890)
.annotate 'line', 2096
    .return ($P6891)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("573_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6894
    .param pmc param_6895
.annotate 'line', 2114
    .lex "self", param_6894
    .lex "$/", param_6895
    find_lex $P6896, "$/"
    unless_null $P6896, vivify_2762
    new $P6896, "Undef"
  vivify_2762:
    $P6897 = "control"($P6896, "CONTROL_LOOP_NEXT")
    .return ($P6897)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("574_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6899
    .param pmc param_6900
.annotate 'line', 2115
    .lex "self", param_6899
    .lex "$/", param_6900
    find_lex $P6901, "$/"
    unless_null $P6901, vivify_2763
    new $P6901, "Undef"
  vivify_2763:
    $P6902 = "control"($P6901, "CONTROL_LOOP_LAST")
    .return ($P6902)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("575_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6904
    .param pmc param_6905
.annotate 'line', 2116
    .lex "self", param_6904
    .lex "$/", param_6905
    find_lex $P6906, "$/"
    unless_null $P6906, vivify_2764
    new $P6906, "Undef"
  vivify_2764:
    $P6907 = "control"($P6906, "CONTROL_LOOP_REDO")
    .return ($P6907)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("576_1303923618.727") :outer("407_1303923618.727")
    .param pmc param_6909
    .param pmc param_6910
.annotate 'line', 2118
    .lex "self", param_6909
    .lex "$/", param_6910
.annotate 'line', 2119
    find_lex $P6911, "$/"
    get_hll_global $P6912, "GLOBAL"
    nqp_get_package_through_who $P6913, $P6912, "PAST"
    get_who $P6914, $P6913
    set $P6915, $P6914["Op"]
    find_lex $P6916, "$/"
    unless_null $P6916, vivify_2765
    new $P6916, "Undef"
  vivify_2765:
    $P6917 = $P6915."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P6916 :named("node"))
    $P6918 = $P6911."!make"($P6917)
.annotate 'line', 2118
    .return ($P6918)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7147"  :subid("578_1303923618.727") :outer("10_1303923618.727")
.annotate 'line', 2255
    .const 'Sub' $P7281 = "586_1303923618.727" 
    capture_lex $P7281
    .const 'Sub' $P7241 = "585_1303923618.727" 
    capture_lex $P7241
    .const 'Sub' $P7227 = "584_1303923618.727" 
    capture_lex $P7227
    .const 'Sub' $P7209 = "583_1303923618.727" 
    capture_lex $P7209
    .const 'Sub' $P7195 = "582_1303923618.727" 
    capture_lex $P7195
    .const 'Sub' $P7181 = "581_1303923618.727" 
    capture_lex $P7181
    .const 'Sub' $P7167 = "580_1303923618.727" 
    capture_lex $P7167
    .const 'Sub' $P7151 = "579_1303923618.727" 
    capture_lex $P7151
    .lex "$?PACKAGE", $P7149
    .lex "$?CLASS", $P7150
.annotate 'line', 2289
    .const 'Sub' $P7241 = "585_1303923618.727" 
    newclosure $P7279, $P7241
.annotate 'line', 2255
    .return ($P7279)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2766") :outer("578_1303923618.727")
.annotate 'line', 2255
    .const 'Sub' $P7148 = "578_1303923618.727" 
    .local pmc block
    set block, $P7148
    .const 'Sub' $P7281 = "586_1303923618.727" 
    capture_lex $P7281
    $P7281()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block7280"  :anon :subid("586_1303923618.727") :outer("578_1303923618.727")
.annotate 'line', 2255
    nqp_get_sc_object $P7282, "1303923606.34", 4
    .local pmc type_obj
    set type_obj, $P7282
    get_how $P7283, type_obj
    .const 'Sub' $P7284 = "579_1303923618.727" 
    $P7283."add_method"(type_obj, "metachar:sym<:my>", $P7284)
    get_how $P7285, type_obj
    .const 'Sub' $P7286 = "580_1303923618.727" 
    $P7285."add_method"(type_obj, "metachar:sym<{ }>", $P7286)
    get_how $P7287, type_obj
    .const 'Sub' $P7288 = "581_1303923618.727" 
    $P7287."add_method"(type_obj, "metachar:sym<nqpvar>", $P7288)
    get_how $P7289, type_obj
    .const 'Sub' $P7290 = "582_1303923618.727" 
    $P7289."add_method"(type_obj, "assertion:sym<{ }>", $P7290)
    get_how $P7291, type_obj
    .const 'Sub' $P7292 = "583_1303923618.727" 
    $P7291."add_method"(type_obj, "assertion:sym<?{ }>", $P7292)
    get_how $P7293, type_obj
    .const 'Sub' $P7294 = "584_1303923618.727" 
    $P7293."add_method"(type_obj, "assertion:sym<var>", $P7294)
    get_how $P7295, type_obj
    .const 'Sub' $P7296 = "585_1303923618.727" 
    $P7295."add_method"(type_obj, "codeblock", $P7296)
    get_how $P7297, type_obj
    $P7298 = $P7297."compose"(type_obj)
    .return ($P7298)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("579_1303923618.727") :outer("578_1303923618.727")
    .param pmc param_7152
    .param pmc param_7153
.annotate 'line', 2257
    .lex "self", param_7152
    .lex "$/", param_7153
.annotate 'line', 2258
    new $P7154, "Undef"
    .lex "$past", $P7154
    find_lex $P7155, "$/"
    unless_null $P7155, vivify_2767
    $P7155 = root_new ['parrot';'Hash']
  vivify_2767:
    set $P7156, $P7155["statement"]
    unless_null $P7156, vivify_2768
    new $P7156, "Undef"
  vivify_2768:
    $P7157 = $P7156."ast"()
    store_lex "$past", $P7157
.annotate 'line', 2259
    find_lex $P7158, "$/"
    get_hll_global $P7159, "GLOBAL"
    nqp_get_package_through_who $P7160, $P7159, "PAST"
    get_who $P7161, $P7160
    set $P7162, $P7161["Regex"]
    find_lex $P7163, "$past"
    unless_null $P7163, vivify_2769
    new $P7163, "Undef"
  vivify_2769:
    find_lex $P7164, "$/"
    unless_null $P7164, vivify_2770
    new $P7164, "Undef"
  vivify_2770:
    $P7165 = $P7162."new"($P7163, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P7164 :named("node"))
    $P7166 = $P7158."!make"($P7165)
.annotate 'line', 2257
    .return ($P7166)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("580_1303923618.727") :outer("578_1303923618.727")
    .param pmc param_7168
    .param pmc param_7169
.annotate 'line', 2263
    .lex "self", param_7168
    .lex "$/", param_7169
.annotate 'line', 2264
    find_lex $P7170, "$/"
    get_hll_global $P7171, "GLOBAL"
    nqp_get_package_through_who $P7172, $P7171, "PAST"
    get_who $P7173, $P7172
    set $P7174, $P7173["Regex"]
    find_lex $P7175, "$/"
    unless_null $P7175, vivify_2771
    $P7175 = root_new ['parrot';'Hash']
  vivify_2771:
    set $P7176, $P7175["codeblock"]
    unless_null $P7176, vivify_2772
    new $P7176, "Undef"
  vivify_2772:
    $P7177 = $P7176."ast"()
    find_lex $P7178, "$/"
    unless_null $P7178, vivify_2773
    new $P7178, "Undef"
  vivify_2773:
    $P7179 = $P7174."new"($P7177, "pastnode" :named("pasttype"), $P7178 :named("node"))
    $P7180 = $P7170."!make"($P7179)
.annotate 'line', 2263
    .return ($P7180)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("581_1303923618.727") :outer("578_1303923618.727")
    .param pmc param_7182
    .param pmc param_7183
.annotate 'line', 2268
    .lex "self", param_7182
    .lex "$/", param_7183
.annotate 'line', 2269
    find_lex $P7184, "$/"
    get_hll_global $P7185, "GLOBAL"
    nqp_get_package_through_who $P7186, $P7185, "PAST"
    get_who $P7187, $P7186
    set $P7188, $P7187["Regex"]
    find_lex $P7189, "$/"
    unless_null $P7189, vivify_2774
    $P7189 = root_new ['parrot';'Hash']
  vivify_2774:
    set $P7190, $P7189["var"]
    unless_null $P7190, vivify_2775
    new $P7190, "Undef"
  vivify_2775:
    $P7191 = $P7190."ast"()
    find_lex $P7192, "$/"
    unless_null $P7192, vivify_2776
    new $P7192, "Undef"
  vivify_2776:
    $P7193 = $P7188."new"("!INTERPOLATE", $P7191, "subrule" :named("pasttype"), "method" :named("subtype"), $P7192 :named("node"))
    $P7194 = $P7184."!make"($P7193)
.annotate 'line', 2268
    .return ($P7194)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("582_1303923618.727") :outer("578_1303923618.727")
    .param pmc param_7196
    .param pmc param_7197
.annotate 'line', 2273
    .lex "self", param_7196
    .lex "$/", param_7197
.annotate 'line', 2274
    find_lex $P7198, "$/"
    get_hll_global $P7199, "GLOBAL"
    nqp_get_package_through_who $P7200, $P7199, "PAST"
    get_who $P7201, $P7200
    set $P7202, $P7201["Regex"]
    find_lex $P7203, "$/"
    unless_null $P7203, vivify_2777
    $P7203 = root_new ['parrot';'Hash']
  vivify_2777:
    set $P7204, $P7203["codeblock"]
    unless_null $P7204, vivify_2778
    new $P7204, "Undef"
  vivify_2778:
    $P7205 = $P7204."ast"()
    find_lex $P7206, "$/"
    unless_null $P7206, vivify_2779
    new $P7206, "Undef"
  vivify_2779:
    $P7207 = $P7202."new"("!INTERPOLATE_REGEX", $P7205, "subrule" :named("pasttype"), "method" :named("subtype"), $P7206 :named("node"))
    $P7208 = $P7198."!make"($P7207)
.annotate 'line', 2273
    .return ($P7208)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("583_1303923618.727") :outer("578_1303923618.727")
    .param pmc param_7210
    .param pmc param_7211
.annotate 'line', 2278
    .lex "self", param_7210
    .lex "$/", param_7211
.annotate 'line', 2279
    find_lex $P7212, "$/"
    get_hll_global $P7213, "GLOBAL"
    nqp_get_package_through_who $P7214, $P7213, "PAST"
    get_who $P7215, $P7214
    set $P7216, $P7215["Regex"]
    find_lex $P7217, "$/"
    unless_null $P7217, vivify_2780
    $P7217 = root_new ['parrot';'Hash']
  vivify_2780:
    set $P7218, $P7217["codeblock"]
    unless_null $P7218, vivify_2781
    new $P7218, "Undef"
  vivify_2781:
    $P7219 = $P7218."ast"()
.annotate 'line', 2280
    find_lex $P7220, "$/"
    unless_null $P7220, vivify_2782
    $P7220 = root_new ['parrot';'Hash']
  vivify_2782:
    set $P7221, $P7220["zw"]
    unless_null $P7221, vivify_2783
    new $P7221, "Undef"
  vivify_2783:
    set $S7222, $P7221
    iseq $I7223, $S7222, "!"
    find_lex $P7224, "$/"
    unless_null $P7224, vivify_2784
    new $P7224, "Undef"
  vivify_2784:
    $P7225 = $P7216."new"($P7219, "zerowidth" :named("subtype"), $I7223 :named("negate"), "pastnode" :named("pasttype"), $P7224 :named("node"))
.annotate 'line', 2279
    $P7226 = $P7212."!make"($P7225)
.annotate 'line', 2278
    .return ($P7226)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("584_1303923618.727") :outer("578_1303923618.727")
    .param pmc param_7228
    .param pmc param_7229
.annotate 'line', 2284
    .lex "self", param_7228
    .lex "$/", param_7229
.annotate 'line', 2285
    find_lex $P7230, "$/"
    get_hll_global $P7231, "GLOBAL"
    nqp_get_package_through_who $P7232, $P7231, "PAST"
    get_who $P7233, $P7232
    set $P7234, $P7233["Regex"]
    find_lex $P7235, "$/"
    unless_null $P7235, vivify_2785
    $P7235 = root_new ['parrot';'Hash']
  vivify_2785:
    set $P7236, $P7235["var"]
    unless_null $P7236, vivify_2786
    new $P7236, "Undef"
  vivify_2786:
    $P7237 = $P7236."ast"()
    find_lex $P7238, "$/"
    unless_null $P7238, vivify_2787
    new $P7238, "Undef"
  vivify_2787:
    $P7239 = $P7234."new"("!INTERPOLATE_REGEX", $P7237, "subrule" :named("pasttype"), "method" :named("subtype"), $P7238 :named("node"))
    $P7240 = $P7230."!make"($P7239)
.annotate 'line', 2284
    .return ($P7240)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("585_1303923618.727") :outer("578_1303923618.727")
    .param pmc param_7242
    .param pmc param_7243
.annotate 'line', 2289
    .lex "self", param_7242
    .lex "$/", param_7243
.annotate 'line', 2290
    new $P7244, "Undef"
    .lex "$block", $P7244
.annotate 'line', 2292
    new $P7245, "Undef"
    .lex "$past", $P7245
.annotate 'line', 2290
    find_lex $P7246, "$/"
    unless_null $P7246, vivify_2788
    $P7246 = root_new ['parrot';'Hash']
  vivify_2788:
    set $P7247, $P7246["block"]
    unless_null $P7247, vivify_2789
    new $P7247, "Undef"
  vivify_2789:
    $P7248 = $P7247."ast"()
    store_lex "$block", $P7248
.annotate 'line', 2291
    find_lex $P7249, "$block"
    unless_null $P7249, vivify_2790
    new $P7249, "Undef"
  vivify_2790:
    $P7249."blocktype"("immediate")
.annotate 'line', 2293
    get_hll_global $P7250, "GLOBAL"
    nqp_get_package_through_who $P7251, $P7250, "PAST"
    get_who $P7252, $P7251
    set $P7253, $P7252["Stmts"]
.annotate 'line', 2294
    get_hll_global $P7254, "GLOBAL"
    nqp_get_package_through_who $P7255, $P7254, "PAST"
    get_who $P7256, $P7255
    set $P7257, $P7256["Op"]
.annotate 'line', 2295
    get_hll_global $P7258, "GLOBAL"
    nqp_get_package_through_who $P7259, $P7258, "PAST"
    get_who $P7260, $P7259
    set $P7261, $P7260["Var"]
    $P7262 = $P7261."new"("$/" :named("name"))
.annotate 'line', 2296
    get_hll_global $P7263, "GLOBAL"
    nqp_get_package_through_who $P7264, $P7263, "PAST"
    get_who $P7265, $P7264
    set $P7266, $P7265["Op"]
.annotate 'line', 2297
    get_hll_global $P7267, "GLOBAL"
    nqp_get_package_through_who $P7268, $P7267, "PAST"
    get_who $P7269, $P7268
    set $P7270, $P7269["Var"]
    $P7271 = $P7270."new"(unicode:"$\x{a2}" :named("name"))
    $P7272 = $P7266."new"($P7271, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2296
    $P7273 = $P7257."new"($P7262, $P7272, "bind" :named("pasttype"))
.annotate 'line', 2294
    find_lex $P7274, "$block"
    unless_null $P7274, vivify_2791
    new $P7274, "Undef"
  vivify_2791:
    $P7275 = $P7253."new"($P7273, $P7274)
.annotate 'line', 2293
    store_lex "$past", $P7275
.annotate 'line', 2305
    find_lex $P7276, "$/"
    find_lex $P7277, "$past"
    unless_null $P7277, vivify_2792
    new $P7277, "Undef"
  vivify_2792:
    $P7278 = $P7276."!make"($P7277)
.annotate 'line', 2289
    .return ($P7278)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7299"  :subid("587_1303923618.727") :outer("10_1303923618.727")
.annotate 'line', 2310
    .const 'Sub' $P7304 = "588_1303923618.727" 
    capture_lex $P7304
    .lex "$?PACKAGE", $P7301
    .lex "$?CLASS", $P7302
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2793") :outer("587_1303923618.727")
.annotate 'line', 2310
    .const 'Sub' $P7300 = "587_1303923618.727" 
    .local pmc block
    set block, $P7300
    .const 'Sub' $P7304 = "588_1303923618.727" 
    capture_lex $P7304
    $P7304()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block7303"  :anon :subid("588_1303923618.727") :outer("587_1303923618.727")
.annotate 'line', 2310
    nqp_get_sc_object $P7305, "1303923606.34", 5
    .local pmc type_obj
    set type_obj, $P7305
    get_how $P7306, type_obj
    $P7307 = $P7306."compose"(type_obj)
    .return ($P7307)
.end


.HLL "nqp"

.namespace []
.sub "_block7315" :load :anon :subid("589_1303923618.727")
.annotate 'line', 1
    .const 'Sub' $P7317 = "10_1303923618.727" 
    $P7318 = $P7317()
    .return ($P7318)
.end

