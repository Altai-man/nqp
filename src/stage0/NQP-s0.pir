# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup
.end
### .include 'gen/nqp-how.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298839204.312")
.annotate 'line', 0
    get_hll_global $P2653, ["str"], "_block2652" 
    capture_lex $P2653
    get_hll_global $P2644, ["num"], "_block2643" 
    capture_lex $P2644
    get_hll_global $P2635, ["int"], "_block2634" 
    capture_lex $P2635
    get_hll_global $P2481, ["NQPMu"], "_block2480" 
    capture_lex $P2481
    get_hll_global $P2392, ["NQPModuleHOW"], "_block2391" 
    capture_lex $P2392
    get_hll_global $P2162, ["RoleToRoleApplier"], "_block2161" 
    capture_lex $P2162
    get_hll_global $P1946, ["RoleToClassApplier"], "_block1945" 
    capture_lex $P1946
    get_hll_global $P1590, ["NQPParametricRoleHOW"], "_block1589" 
    capture_lex $P1590
    get_hll_global $P1268, ["NQPConcreteRoleHOW"], "_block1267" 
    capture_lex $P1268
    get_hll_global $P1184, ["NQPAttribute"], "_block1183" 
    capture_lex $P1184
    get_hll_global $P1096, ["NQPNativeHOW"], "_block1095" 
    capture_lex $P1096
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, "str"
    get_hll_global $P14, "num"
    get_hll_global $P15, "int"
    get_hll_global $P16, "NQPMu"
    get_hll_global $P17, "NQPModuleHOW"
    get_hll_global $P18, "RoleToRoleApplier"
    get_hll_global $P19, "RoleToClassApplier"
    get_hll_global $P20, "NQPParametricRoleHOW"
    get_hll_global $P21, "NQPConcreteRoleHOW"
    get_hll_global $P22, "NQPAttribute"
    get_hll_global $P23, "NQPNativeHOW"
    get_hll_global $P24, "NQPClassHOW"
    get_hll_global $P25, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
    $P27()
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    $P53()
.annotate 'line', 451
    get_hll_global $P1096, ["NQPNativeHOW"], "_block1095" 
    capture_lex $P1096
    $P1096()
.annotate 'line', 495
    get_hll_global $P1184, ["NQPAttribute"], "_block1183" 
    capture_lex $P1184
    $P1184()
.annotate 'line', 528
    get_hll_global $P1268, ["NQPConcreteRoleHOW"], "_block1267" 
    capture_lex $P1268
    $P1268()
.annotate 'line', 677
    get_hll_global $P1590, ["NQPParametricRoleHOW"], "_block1589" 
    capture_lex $P1590
    $P1590()
.annotate 'line', 843
    get_hll_global $P1946, ["RoleToClassApplier"], "_block1945" 
    capture_lex $P1946
    $P1946()
.annotate 'line', 915
    get_hll_global $P2162, ["RoleToRoleApplier"], "_block2161" 
    capture_lex $P2162
    $P2162()
.annotate 'line', 1005
    get_hll_global $P2392, ["NQPModuleHOW"], "_block2391" 
    capture_lex $P2392
    $P2392()
.annotate 'line', 1050
    get_hll_global $P2481, ["NQPMu"], "_block2480" 
    capture_lex $P2481
    $P2481()
.annotate 'line', 1099
    get_hll_global $P2635, ["int"], "_block2634" 
    capture_lex $P2635
    $P2635()
.annotate 'line', 1101
    get_hll_global $P2644, ["num"], "_block2643" 
    capture_lex $P2644
    $P2644()
.annotate 'line', 1103
    get_hll_global $P2653, ["str"], "_block2652" 
    capture_lex $P2653
    $P2661 = $P2653()
.annotate 'line', 1
    .return ($P2661)
    .const 'Sub' $P2663 = "185_1298839204.312" 
    .return ($P2663)
.end


.namespace ["KnowHOWAttribute"]
.sub "_block26"  :subid("11_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 10
    .const 'Sub' $P43 = "14_1298839204.312" 
    capture_lex $P43
    .const 'Sub' $P37 = "13_1298839204.312" 
    capture_lex $P37
    .const 'Sub' $P29 = "12_1298839204.312" 
    capture_lex $P29
    get_global $P28, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P37 = "13_1298839204.312" 
    newclosure $P41, $P37
.annotate 'line', 10
    .return ($P41)
.end


.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post186") :outer("11_1298839204.312")
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    .local pmc block
    set block, $P27
    .const 'Sub' $P43 = "14_1298839204.312" 
    capture_lex $P43
    $P43()
.end


.namespace ["KnowHOWAttribute"]
.sub "_block42"  :anon :subid("14_1298839204.312") :outer("11_1298839204.312")
.annotate 'line', 10
    get_hll_global $P44, "KnowHOW"
    $P45 = $P44."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P45
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P46, type_obj
    .const 'Sub' $P47 = "12_1298839204.312" 
    $P46."add_method"(type_obj, "new", $P47)
    get_how $P48, type_obj
    .const 'Sub' $P49 = "13_1298839204.312" 
    $P48."add_method"(type_obj, "name", $P49)
    get_how $P50, type_obj
    $P51 = $P50."compose"(type_obj)
    .return ($P51)
.end


.namespace ["KnowHOWAttribute"]
.sub "new"  :subid("12_1298839204.312") :outer("11_1298839204.312")
    .param pmc param_30
    .param pmc param_31 :optional :named("name")
    .param int has_param_31 :opt_flag
.annotate 'line', 11
    .lex "self", param_30
    if has_param_31, optparam_187
    new $P32, "Undef"
    set param_31, $P32
  optparam_187:
    .lex "$name", param_31
.annotate 'line', 12
    find_lex $P33, "$name"
    set $S34, $P33
    get_hll_global $P35, "KnowHOWAttribute"
    repr_box_str $P36, $S34, $P35
.annotate 'line', 11
    .return ($P36)
.end


.namespace ["KnowHOWAttribute"]
.sub "name"  :subid("13_1298839204.312") :outer("11_1298839204.312")
    .param pmc param_38
.annotate 'line', 14
    .lex "self", param_38
.annotate 'line', 15
    find_lex $P39, "self"
    repr_unbox_str $S40, $P39
.annotate 'line', 14
    .return ($S40)
.end


.namespace ["NQPClassHOW"]
.sub "_block52"  :subid("15_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 26
    .const 'Sub' $P1004 = "69_1298839204.312" 
    capture_lex $P1004
    .const 'Sub' $P967 = "67_1298839204.312" 
    capture_lex $P967
    .const 'Sub' $P931 = "65_1298839204.312" 
    capture_lex $P931
    .const 'Sub' $P897 = "64_1298839204.312" 
    capture_lex $P897
    .const 'Sub' $P860 = "63_1298839204.312" 
    capture_lex $P860
    .const 'Sub' $P853 = "62_1298839204.312" 
    capture_lex $P853
    .const 'Sub' $P830 = "60_1298839204.312" 
    capture_lex $P830
    .const 'Sub' $P824 = "59_1298839204.312" 
    capture_lex $P824
    .const 'Sub' $P818 = "58_1298839204.312" 
    capture_lex $P818
    .const 'Sub' $P795 = "56_1298839204.312" 
    capture_lex $P795
    .const 'Sub' $P788 = "55_1298839204.312" 
    capture_lex $P788
    .const 'Sub' $P774 = "54_1298839204.312" 
    capture_lex $P774
    .const 'Sub' $P725 = "51_1298839204.312" 
    capture_lex $P725
    .const 'Sub' $P680 = "48_1298839204.312" 
    capture_lex $P680
    .const 'Sub' $P643 = "45_1298839204.312" 
    capture_lex $P643
    .const 'Sub' $P513 = "40_1298839204.312" 
    capture_lex $P513
    .const 'Sub' $P424 = "37_1298839204.312" 
    capture_lex $P424
    .const 'Sub' $P398 = "36_1298839204.312" 
    capture_lex $P398
    .const 'Sub' $P364 = "34_1298839204.312" 
    capture_lex $P364
    .const 'Sub' $P326 = "32_1298839204.312" 
    capture_lex $P326
    .const 'Sub' $P305 = "31_1298839204.312" 
    capture_lex $P305
    .const 'Sub' $P284 = "30_1298839204.312" 
    capture_lex $P284
    .const 'Sub' $P265 = "29_1298839204.312" 
    capture_lex $P265
    .const 'Sub' $P251 = "28_1298839204.312" 
    capture_lex $P251
    .const 'Sub' $P244 = "27_1298839204.312" 
    capture_lex $P244
    .const 'Sub' $P234 = "26_1298839204.312" 
    capture_lex $P234
    .const 'Sub' $P97 = "19_1298839204.312" 
    capture_lex $P97
    .const 'Sub' $P55 = "16_1298839204.312" 
    capture_lex $P55
    get_global $P54, "$?CLASS"
.annotate 'line', 232
    .const 'Sub' $P55 = "16_1298839204.312" 
    newclosure $P96, $P55
    .lex "compute_c3_mro", $P96
.annotate 'line', 254
    .const 'Sub' $P97 = "19_1298839204.312" 
    newclosure $P233, $P97
    .lex "c3_merge", $P233
.annotate 'line', 178
    find_lex $P641, "compute_c3_mro"
    find_lex $P642, "c3_merge"
.annotate 'line', 438
    .const 'Sub' $P967 = "67_1298839204.312" 
    newclosure $P1002, $P967
.annotate 'line', 26
    .return ($P1002)
.end


.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post188") :outer("15_1298839204.312")
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    .local pmc block
    set block, $P53
    .const 'Sub' $P1004 = "69_1298839204.312" 
    capture_lex $P1004
    $P1004()
.end


.namespace ["NQPClassHOW"]
.sub "_block1003"  :anon :subid("69_1298839204.312") :outer("15_1298839204.312")
.annotate 'line', 26
    get_hll_global $P1005, "KnowHOW"
    $P1006 = $P1005."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1006
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1007, type_obj
    get_hll_global $P1008, "KnowHOWAttribute"
    $P1009 = $P1008."new"("$!name" :named("name"))
    $P1007."add_attribute"(type_obj, $P1009)
    get_how $P1010, type_obj
    get_hll_global $P1011, "KnowHOWAttribute"
    $P1012 = $P1011."new"("%!attributes" :named("name"))
    $P1010."add_attribute"(type_obj, $P1012)
    get_how $P1013, type_obj
    get_hll_global $P1014, "KnowHOWAttribute"
    $P1015 = $P1014."new"("%!methods" :named("name"))
    $P1013."add_attribute"(type_obj, $P1015)
    get_how $P1016, type_obj
    get_hll_global $P1017, "KnowHOWAttribute"
    $P1018 = $P1017."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1016."add_attribute"(type_obj, $P1018)
    get_how $P1019, type_obj
    get_hll_global $P1020, "KnowHOWAttribute"
    $P1021 = $P1020."new"("@!parents" :named("name"))
    $P1019."add_attribute"(type_obj, $P1021)
    get_how $P1022, type_obj
    get_hll_global $P1023, "KnowHOWAttribute"
    $P1024 = $P1023."new"("@!roles" :named("name"))
    $P1022."add_attribute"(type_obj, $P1024)
    get_how $P1025, type_obj
    get_hll_global $P1026, "KnowHOWAttribute"
    $P1027 = $P1026."new"("@!vtable" :named("name"))
    $P1025."add_attribute"(type_obj, $P1027)
    get_how $P1028, type_obj
    get_hll_global $P1029, "KnowHOWAttribute"
    $P1030 = $P1029."new"("%!method-vtable-slots" :named("name"))
    $P1028."add_attribute"(type_obj, $P1030)
    get_how $P1031, type_obj
    get_hll_global $P1032, "KnowHOWAttribute"
    $P1033 = $P1032."new"("$!composed" :named("name"))
    $P1031."add_attribute"(type_obj, $P1033)
    get_how $P1034, type_obj
    get_hll_global $P1035, "KnowHOWAttribute"
    $P1036 = $P1035."new"("@!mro" :named("name"))
    $P1034."add_attribute"(type_obj, $P1036)
    get_how $P1037, type_obj
    get_hll_global $P1038, "KnowHOWAttribute"
    $P1039 = $P1038."new"("@!done" :named("name"))
    $P1037."add_attribute"(type_obj, $P1039)
    get_how $P1040, type_obj
    get_hll_global $P1041, "KnowHOWAttribute"
    $P1042 = $P1041."new"("%!parrot_vtable_mapping" :named("name"))
    $P1040."add_attribute"(type_obj, $P1042)
    get_how $P1043, type_obj
    .const 'Sub' $P1044 = "26_1298839204.312" 
    $P1043."add_method"(type_obj, "new", $P1044)
    get_how $P1045, type_obj
    .const 'Sub' $P1046 = "27_1298839204.312" 
    $P1045."add_method"(type_obj, "BUILD", $P1046)
    get_how $P1047, type_obj
    .const 'Sub' $P1048 = "28_1298839204.312" 
    $P1047."add_method"(type_obj, "new_type", $P1048)
    get_how $P1049, type_obj
    .const 'Sub' $P1050 = "29_1298839204.312" 
    $P1049."add_method"(type_obj, "add_method", $P1050)
    get_how $P1051, type_obj
    .const 'Sub' $P1052 = "30_1298839204.312" 
    $P1051."add_method"(type_obj, "add_multi_method", $P1052)
    get_how $P1053, type_obj
    .const 'Sub' $P1054 = "31_1298839204.312" 
    $P1053."add_method"(type_obj, "add_attribute", $P1054)
    get_how $P1055, type_obj
    .const 'Sub' $P1056 = "32_1298839204.312" 
    $P1055."add_method"(type_obj, "add_parent", $P1056)
    get_how $P1057, type_obj
    .const 'Sub' $P1058 = "34_1298839204.312" 
    $P1057."add_method"(type_obj, "add_role", $P1058)
    get_how $P1059, type_obj
    .const 'Sub' $P1060 = "36_1298839204.312" 
    $P1059."add_method"(type_obj, "add_parrot_vtable_mapping", $P1060)
    get_how $P1061, type_obj
    .const 'Sub' $P1062 = "37_1298839204.312" 
    $P1061."add_method"(type_obj, "compose", $P1062)
    get_how $P1063, type_obj
    .const 'Sub' $P1064 = "40_1298839204.312" 
    $P1063."add_method"(type_obj, "incorporate_multi_candidates", $P1064)
    get_how $P1065, type_obj
    .const 'Sub' $P1066 = "45_1298839204.312" 
    $P1065."add_method"(type_obj, "publish_type_cache", $P1066)
    get_how $P1067, type_obj
    .const 'Sub' $P1068 = "48_1298839204.312" 
    $P1067."add_method"(type_obj, "publish_method_cache", $P1068)
    get_how $P1069, type_obj
    .const 'Sub' $P1070 = "51_1298839204.312" 
    $P1069."add_method"(type_obj, "publish_parrot_vtable_mapping", $P1070)
    get_how $P1071, type_obj
    .const 'Sub' $P1072 = "54_1298839204.312" 
    $P1071."add_method"(type_obj, "parents", $P1072)
    get_how $P1073, type_obj
    .const 'Sub' $P1074 = "55_1298839204.312" 
    $P1073."add_method"(type_obj, "roles", $P1074)
    get_how $P1075, type_obj
    .const 'Sub' $P1076 = "56_1298839204.312" 
    $P1075."add_method"(type_obj, "methods", $P1076)
    get_how $P1077, type_obj
    .const 'Sub' $P1078 = "58_1298839204.312" 
    $P1077."add_method"(type_obj, "method_table", $P1078)
    get_how $P1079, type_obj
    .const 'Sub' $P1080 = "59_1298839204.312" 
    $P1079."add_method"(type_obj, "name", $P1080)
    get_how $P1081, type_obj
    .const 'Sub' $P1082 = "60_1298839204.312" 
    $P1081."add_method"(type_obj, "attributes", $P1082)
    get_how $P1083, type_obj
    .const 'Sub' $P1084 = "62_1298839204.312" 
    $P1083."add_method"(type_obj, "parrot_vtable_mappings", $P1084)
    get_how $P1085, type_obj
    .const 'Sub' $P1086 = "63_1298839204.312" 
    $P1085."add_method"(type_obj, "isa", $P1086)
    get_how $P1087, type_obj
    .const 'Sub' $P1088 = "64_1298839204.312" 
    $P1087."add_method"(type_obj, "does", $P1088)
    get_how $P1089, type_obj
    .const 'Sub' $P1090 = "65_1298839204.312" 
    $P1089."add_method"(type_obj, "can", $P1090)
    get_how $P1091, type_obj
    .const 'Sub' $P1092 = "67_1298839204.312" 
    $P1091."add_method"(type_obj, "find_method", $P1092)
    get_how $P1093, type_obj
    $P1094 = $P1093."compose"(type_obj)
    .return ($P1094)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_58
.annotate 'line', 232
    .const 'Sub' $P70 = "17_1298839204.312" 
    capture_lex $P70
    new $P57, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P57, control_56
    push_eh $P57
    .lex "$class", param_58
.annotate 'line', 233
    $P59 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P59
.annotate 'line', 236
    $P60 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P60
.annotate 'line', 233
    find_lex $P61, "$class"
    get_how $P62, $P61
    find_lex $P63, "$class"
    $P64 = $P62."parents"($P63, 1 :named("local"))
    store_lex "@immediate_parents", $P64
    find_lex $P65, "@result"
.annotate 'line', 237
    find_lex $P67, "@immediate_parents"
    set $N68, $P67
    unless $N68, if_66_end
    .const 'Sub' $P70 = "17_1298839204.312" 
    capture_lex $P70
    $P70()
  if_66_end:
.annotate 'line', 249
    find_lex $P91, "@result"
    find_lex $P92, "$class"
    $P91."unshift"($P92)
.annotate 'line', 250
    new $P93, "Exception"
    set $P93['type'], .CONTROL_RETURN
    find_lex $P94, "@result"
    setattribute $P93, 'payload', $P94
    throw $P93
.annotate 'line', 232
    .return ()
  control_56:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P95, exception, "payload"
    .return ($P95)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block69"  :anon :subid("17_1298839204.312") :outer("16_1298839204.312")
.annotate 'line', 237
    .const 'Sub' $P78 = "18_1298839204.312" 
    capture_lex $P78
.annotate 'line', 240
    $P71 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P71
.annotate 'line', 237
    find_lex $P72, "@merge_list"
.annotate 'line', 241
    find_lex $P74, "@immediate_parents"
    defined $I75, $P74
    unless $I75, for_undef_189
    iter $P73, $P74
    new $P85, 'ExceptionHandler'
    set_label $P85, loop84_handler
    $P85."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P85
  loop84_test:
    unless $P73, loop84_done
    shift $P76, $P73
  loop84_redo:
    .const 'Sub' $P78 = "18_1298839204.312" 
    capture_lex $P78
    $P78($P76)
  loop84_next:
    goto loop84_test
  loop84_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P86, exception, 'type'
    eq $P86, .CONTROL_LOOP_NEXT, loop84_next
    eq $P86, .CONTROL_LOOP_REDO, loop84_redo
  loop84_done:
    pop_eh 
  for_undef_189:
.annotate 'line', 244
    find_lex $P87, "@merge_list"
    find_lex $P88, "@immediate_parents"
    $P87."push"($P88)
.annotate 'line', 245
    find_lex $P89, "@merge_list"
    $P90 = "c3_merge"($P89)
    store_lex "@result", $P90
.annotate 'line', 237
    .return ($P90)
.end


.namespace ["NQPClassHOW"]
.sub "_block77"  :anon :subid("18_1298839204.312") :outer("17_1298839204.312")
    .param pmc param_79
.annotate 'line', 241
    .lex "$_", param_79
.annotate 'line', 242
    find_lex $P80, "@merge_list"
    find_lex $P81, "$_"
    $P82 = "compute_c3_mro"($P81)
    $P83 = $P80."push"($P82)
.annotate 'line', 241
    .return ($P83)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_100
.annotate 'line', 254
    .const 'Sub' $P193 = "24_1298839204.312" 
    capture_lex $P193
    .const 'Sub' $P115 = "20_1298839204.312" 
    capture_lex $P115
    new $P99, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P99, control_98
    push_eh $P99
    .lex "@merge_list", param_100
.annotate 'line', 255
    $P101 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P101
.annotate 'line', 256
    new $P102, "Undef"
    .lex "$accepted", $P102
.annotate 'line', 257
    new $P103, "Undef"
    .lex "$something_accepted", $P103
.annotate 'line', 258
    new $P104, "Undef"
    .lex "$cand_count", $P104
.annotate 'line', 301
    new $P105, "Undef"
    .lex "$i", $P105
.annotate 'line', 254
    find_lex $P106, "@result"
    find_lex $P107, "$accepted"
.annotate 'line', 257
    new $P108, "Integer"
    assign $P108, 0
    store_lex "$something_accepted", $P108
.annotate 'line', 258
    new $P109, "Integer"
    assign $P109, 0
    store_lex "$cand_count", $P109
.annotate 'line', 261
    find_lex $P111, "@merge_list"
    defined $I112, $P111
    unless $I112, for_undef_190
    iter $P110, $P111
    new $P176, 'ExceptionHandler'
    set_label $P176, loop175_handler
    $P176."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P176
  loop175_test:
    unless $P110, loop175_done
    shift $P113, $P110
  loop175_redo:
    .const 'Sub' $P115 = "20_1298839204.312" 
    capture_lex $P115
    $P115($P113)
  loop175_next:
    goto loop175_test
  loop175_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P177, exception, 'type'
    eq $P177, .CONTROL_LOOP_NEXT, loop175_next
    eq $P177, .CONTROL_LOOP_REDO, loop175_redo
  loop175_done:
    pop_eh 
  for_undef_190:
.annotate 'line', 291
    find_lex $P179, "$cand_count"
    set $N180, $P179
    iseq $I181, $N180, 0.0
    unless $I181, if_178_end
.annotate 'line', 292
    new $P182, "Exception"
    set $P182['type'], .CONTROL_RETURN
    find_lex $P183, "@result"
    setattribute $P182, 'payload', $P183
    throw $P182
  if_178_end:
.annotate 'line', 296
    find_lex $P185, "$something_accepted"
    if $P185, unless_184_end
.annotate 'line', 297
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_184_end:
.annotate 'line', 301
    new $P186, "Integer"
    assign $P186, 0
    store_lex "$i", $P186
.annotate 'line', 302
    new $P224, 'ExceptionHandler'
    set_label $P224, loop223_handler
    $P224."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P224
  loop223_test:
    find_lex $P187, "$i"
    set $N188, $P187
    find_lex $P189, "@merge_list"
    set $N190, $P189
    islt $I191, $N188, $N190
    unless $I191, loop223_done
  loop223_redo:
    .const 'Sub' $P193 = "24_1298839204.312" 
    capture_lex $P193
    $P193()
  loop223_next:
    goto loop223_test
  loop223_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P225, exception, 'type'
    eq $P225, .CONTROL_LOOP_NEXT, loop223_next
    eq $P225, .CONTROL_LOOP_REDO, loop223_redo
  loop223_done:
    pop_eh 
.annotate 'line', 315
    find_lex $P226, "@merge_list"
    $P227 = "c3_merge"($P226)
    store_lex "@result", $P227
.annotate 'line', 316
    find_lex $P228, "@result"
    find_lex $P229, "$accepted"
    $P228."unshift"($P229)
.annotate 'line', 317
    new $P230, "Exception"
    set $P230['type'], .CONTROL_RETURN
    find_lex $P231, "@result"
    setattribute $P230, 'payload', $P231
    throw $P230
.annotate 'line', 254
    .return ()
  control_98:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P232, exception, "payload"
    .return ($P232)
.end


.namespace ["NQPClassHOW"]
.sub "_block114"  :anon :subid("20_1298839204.312") :outer("19_1298839204.312")
    .param pmc param_117
.annotate 'line', 261
    .const 'Sub' $P124 = "21_1298839204.312" 
    capture_lex $P124
.annotate 'line', 262
    $P116 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P116
    .lex "$_", param_117
    find_lex $P118, "$_"
    store_lex "@cand_list", $P118
.annotate 'line', 263
    find_lex $P121, "@cand_list"
    set $N122, $P121
    if $N122, if_120
    new $P119, 'Float'
    set $P119, $N122
    goto if_120_end
  if_120:
    .const 'Sub' $P124 = "21_1298839204.312" 
    capture_lex $P124
    $P174 = $P124()
    set $P119, $P174
  if_120_end:
.annotate 'line', 261
    .return ($P119)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block123"  :anon :subid("21_1298839204.312") :outer("20_1298839204.312")
.annotate 'line', 263
    .const 'Sub' $P137 = "22_1298839204.312" 
    capture_lex $P137
.annotate 'line', 264
    new $P125, "Undef"
    .lex "$rejected", $P125
.annotate 'line', 265
    new $P126, "Undef"
    .lex "$cand_class", $P126
.annotate 'line', 264
    new $P127, "Integer"
    assign $P127, 0
    store_lex "$rejected", $P127
.annotate 'line', 265
    find_lex $P128, "@cand_list"
    unless_null $P128, vivify_191
    $P128 = root_new ['parrot';'ResizablePMCArray']
  vivify_191:
    set $P129, $P128[0]
    unless_null $P129, vivify_192
    new $P129, "Undef"
  vivify_192:
    store_lex "$cand_class", $P129
.annotate 'line', 266
    find_lex $P130, "$cand_count"
    add $P131, $P130, 1
    store_lex "$cand_count", $P131
.annotate 'line', 267
    find_lex $P133, "@merge_list"
    defined $I134, $P133
    unless $I134, for_undef_193
    iter $P132, $P133
    new $P172, 'ExceptionHandler'
    set_label $P172, loop171_handler
    $P172."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P172
  loop171_test:
    unless $P132, loop171_done
    shift $P135, $P132
  loop171_redo:
    .const 'Sub' $P137 = "22_1298839204.312" 
    capture_lex $P137
    $P137($P135)
  loop171_next:
    goto loop171_test
  loop171_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P173, exception, 'type'
    eq $P173, .CONTROL_LOOP_NEXT, loop171_next
    eq $P173, .CONTROL_LOOP_REDO, loop171_redo
  loop171_done:
    pop_eh 
  for_undef_193:
.annotate 'line', 263
    .return ($P132)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block136"  :anon :subid("22_1298839204.312") :outer("21_1298839204.312")
    .param pmc param_138
.annotate 'line', 267
    .const 'Sub' $P144 = "23_1298839204.312" 
    capture_lex $P144
    .lex "$_", param_138
.annotate 'line', 269
    find_lex $P140, "$_"
    find_lex $P141, "@cand_list"
    issame $I142, $P140, $P141
    if $I142, unless_139_end
    .const 'Sub' $P144 = "23_1298839204.312" 
    capture_lex $P144
    $P144()
  unless_139_end:
.annotate 'line', 281
    find_lex $P167, "$rejected"
    unless $P167, unless_166
    set $P165, $P167
    goto unless_166_end
  unless_166:
.annotate 'line', 282
    find_lex $P168, "$cand_class"
    store_lex "$accepted", $P168
.annotate 'line', 283
    new $P169, "Integer"
    assign $P169, 1
    store_lex "$something_accepted", $P169
.annotate 'line', 284
    set $I170, .CONTROL_LOOP_LAST
    die 0, $I170
  unless_166_end:
.annotate 'line', 267
    .return ($P165)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block143"  :anon :subid("23_1298839204.312") :outer("22_1298839204.312")
.annotate 'line', 271
    new $P145, "Undef"
    .lex "$cur_pos", $P145
    new $P146, "Integer"
    assign $P146, 1
    store_lex "$cur_pos", $P146
.annotate 'line', 272
    new $P163, 'ExceptionHandler'
    set_label $P163, loop162_handler
    $P163."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P163
  loop162_test:
    find_lex $P147, "$cur_pos"
    set $N148, $P147
    find_lex $P149, "$_"
    set $N150, $P149
    isle $I151, $N148, $N150
    unless $I151, loop162_done
  loop162_redo:
.annotate 'line', 273
    find_lex $P153, "$cur_pos"
    set $I154, $P153
    find_lex $P155, "$_"
    unless_null $P155, vivify_194
    $P155 = root_new ['parrot';'ResizablePMCArray']
  vivify_194:
    set $P156, $P155[$I154]
    unless_null $P156, vivify_195
    new $P156, "Undef"
  vivify_195:
    find_lex $P157, "$cand_class"
    issame $I158, $P156, $P157
    unless $I158, if_152_end
.annotate 'line', 274
    new $P159, "Integer"
    assign $P159, 1
    store_lex "$rejected", $P159
  if_152_end:
.annotate 'line', 276
    find_lex $P160, "$cur_pos"
    add $P161, $P160, 1
    store_lex "$cur_pos", $P161
  loop162_next:
.annotate 'line', 272
    goto loop162_test
  loop162_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P164, exception, 'type'
    eq $P164, .CONTROL_LOOP_NEXT, loop162_next
    eq $P164, .CONTROL_LOOP_REDO, loop162_redo
  loop162_done:
    pop_eh 
.annotate 'line', 269
    .return ($I151)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block192"  :anon :subid("24_1298839204.312") :outer("19_1298839204.312")
.annotate 'line', 302
    .const 'Sub' $P204 = "25_1298839204.312" 
    capture_lex $P204
.annotate 'line', 303
    $P194 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P194
.annotate 'line', 302
    find_lex $P195, "@new_list"
.annotate 'line', 304
    find_lex $P197, "$i"
    set $I198, $P197
    find_lex $P199, "@merge_list"
    unless_null $P199, vivify_196
    $P199 = root_new ['parrot';'ResizablePMCArray']
  vivify_196:
    set $P200, $P199[$I198]
    unless_null $P200, vivify_197
    new $P200, "Undef"
  vivify_197:
    defined $I201, $P200
    unless $I201, for_undef_198
    iter $P196, $P200
    new $P215, 'ExceptionHandler'
    set_label $P215, loop214_handler
    $P215."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P215
  loop214_test:
    unless $P196, loop214_done
    shift $P202, $P196
  loop214_redo:
    .const 'Sub' $P204 = "25_1298839204.312" 
    capture_lex $P204
    $P204($P202)
  loop214_next:
    goto loop214_test
  loop214_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P216, exception, 'type'
    eq $P216, .CONTROL_LOOP_NEXT, loop214_next
    eq $P216, .CONTROL_LOOP_REDO, loop214_redo
  loop214_done:
    pop_eh 
  for_undef_198:
.annotate 'line', 309
    find_lex $P217, "@new_list"
    find_lex $P218, "$i"
    set $I219, $P218
    find_lex $P220, "@merge_list"
    unless_null $P220, vivify_199
    $P220 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P220
  vivify_199:
    set $P220[$I219], $P217
.annotate 'line', 310
    find_lex $P221, "$i"
    add $P222, $P221, 1
    store_lex "$i", $P222
.annotate 'line', 302
    .return ($P222)
.end


.namespace ["NQPClassHOW"]
.sub "_block203"  :anon :subid("25_1298839204.312") :outer("24_1298839204.312")
    .param pmc param_205
.annotate 'line', 304
    .lex "$_", param_205
.annotate 'line', 305
    find_lex $P208, "$_"
    find_lex $P209, "$accepted"
    issame $I210, $P208, $P209
    unless $I210, unless_207
    new $P206, 'Integer'
    set $P206, $I210
    goto unless_207_end
  unless_207:
.annotate 'line', 306
    find_lex $P211, "@new_list"
    find_lex $P212, "$_"
    $P213 = $P211."push"($P212)
.annotate 'line', 305
    set $P206, $P213
  unless_207_end:
.annotate 'line', 304
    .return ($P206)
.end


.namespace ["NQPClassHOW"]
.sub "new"  :subid("26_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_235
    .param pmc param_236 :optional :named("name")
    .param int has_param_236 :opt_flag
.annotate 'line', 62
    .lex "self", param_235
    if has_param_236, optparam_200
    new $P237, "Undef"
    set param_236, $P237
  optparam_200:
    .lex "$name", param_236
.annotate 'line', 63
    new $P238, "Undef"
    .lex "$obj", $P238
    find_lex $P239, "self"
    repr_instance_of $P240, $P239
    store_lex "$obj", $P240
.annotate 'line', 64
    find_lex $P241, "$obj"
    find_lex $P242, "$name"
    $P241."BUILD"($P242 :named("name"))
    find_lex $P243, "$obj"
.annotate 'line', 62
    .return ($P243)
.end


.namespace ["NQPClassHOW"]
.sub "BUILD"  :subid("27_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_245
    .param pmc param_246 :optional :named("name")
    .param int has_param_246 :opt_flag
.annotate 'line', 68
    .lex "self", param_245
    if has_param_246, optparam_201
    new $P247, "Undef"
    set param_246, $P247
  optparam_201:
    .lex "$name", param_246
.annotate 'line', 69
    find_lex $P248, "$name"
    find_lex $P249, "self"
    get_global $P250, "$?CLASS"
    setattribute $P249, $P250, "$!name", $P248
.annotate 'line', 68
    .return ($P248)
.end


.namespace ["NQPClassHOW"]
.sub "new_type"  :subid("28_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_252
    .param pmc param_253 :optional :named("name")
    .param int has_param_253 :opt_flag
    .param pmc param_255 :optional :named("repr")
    .param int has_param_255 :opt_flag
.annotate 'line', 74
    .lex "self", param_252
    if has_param_253, optparam_202
    new $P254, "String"
    assign $P254, "<anon>"
    set param_253, $P254
  optparam_202:
    .lex "$name", param_253
    if has_param_255, optparam_203
    new $P256, "String"
    assign $P256, "P6opaque"
    set param_255, $P256
  optparam_203:
    .lex "$repr", param_255
.annotate 'line', 75
    new $P257, "Undef"
    .lex "$metaclass", $P257
    find_lex $P258, "self"
    find_lex $P259, "$name"
    $P260 = $P258."new"($P259 :named("name"))
    store_lex "$metaclass", $P260
.annotate 'line', 76
    find_lex $P261, "$metaclass"
    find_lex $P262, "$repr"
    set $S263, $P262
    repr_type_object_for $P264, $P261, $S263
.annotate 'line', 74
    .return ($P264)
.end


.namespace ["NQPClassHOW"]
.sub "add_method"  :subid("29_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_266
    .param pmc param_267
    .param pmc param_268
    .param pmc param_269
.annotate 'line', 79
    .lex "self", param_266
    .lex "$obj", param_267
    .lex "$name", param_268
    .lex "$code_obj", param_269
.annotate 'line', 80
    find_lex $P271, "$name"
    find_lex $P272, "self"
    get_global $P273, "$?CLASS"
    getattribute $P274, $P272, $P273, "%!methods"
    unless_null $P274, vivify_204
    $P274 = root_new ['parrot';'Hash']
  vivify_204:
    set $P275, $P274[$P271]
    unless_null $P275, vivify_205
    new $P275, "Undef"
  vivify_205:
    unless $P275, if_270_end
.annotate 'line', 81
    new $P276, "String"
    assign $P276, "This class already has a method named "
    find_lex $P277, "$name"
    concat $P278, $P276, $P277
    die $P278
  if_270_end:
.annotate 'line', 83
    find_lex $P279, "$code_obj"
    find_lex $P280, "$name"
    find_lex $P281, "self"
    get_global $P282, "$?CLASS"
    getattribute $P283, $P281, $P282, "%!methods"
    unless_null $P283, vivify_206
    $P283 = root_new ['parrot';'Hash']
    setattribute $P281, $P282, "%!methods", $P283
  vivify_206:
    set $P283[$P280], $P279
.annotate 'line', 79
    .return ($P279)
.end


.namespace ["NQPClassHOW"]
.sub "add_multi_method"  :subid("30_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_285
    .param pmc param_286
    .param pmc param_287
    .param pmc param_288
.annotate 'line', 86
    .lex "self", param_285
    .lex "$obj", param_286
    .lex "$name", param_287
    .lex "$code_obj", param_288
.annotate 'line', 92
    $P289 = root_new ['parrot';'Hash']
    .lex "%todo", $P289
.annotate 'line', 86
    find_lex $P290, "%todo"
.annotate 'line', 93
    find_lex $P291, "$name"
    find_lex $P292, "%todo"
    unless_null $P292, vivify_207
    $P292 = root_new ['parrot';'Hash']
    store_lex "%todo", $P292
  vivify_207:
    set $P292["name"], $P291
.annotate 'line', 94
    find_lex $P293, "$code_obj"
    find_lex $P294, "%todo"
    unless_null $P294, vivify_208
    $P294 = root_new ['parrot';'Hash']
    store_lex "%todo", $P294
  vivify_208:
    set $P294["code"], $P293
.annotate 'line', 95
    find_lex $P295, "%todo"
    find_lex $P296, "self"
    get_global $P297, "$?CLASS"
    getattribute $P298, $P296, $P297, "@!multi_methods_to_incorporate"
    unless_null $P298, vivify_209
    $P298 = root_new ['parrot';'ResizablePMCArray']
  vivify_209:
    set $N299, $P298
    set $I300, $N299
    find_lex $P301, "self"
    get_global $P302, "$?CLASS"
    getattribute $P303, $P301, $P302, "@!multi_methods_to_incorporate"
    unless_null $P303, vivify_210
    $P303 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P301, $P302, "@!multi_methods_to_incorporate", $P303
  vivify_210:
    set $P303[$I300], $P295
    find_lex $P304, "$code_obj"
.annotate 'line', 86
    .return ($P304)
.end


.namespace ["NQPClassHOW"]
.sub "add_attribute"  :subid("31_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_306
    .param pmc param_307
    .param pmc param_308
.annotate 'line', 99
    .lex "self", param_306
    .lex "$obj", param_307
    .lex "$meta_attr", param_308
.annotate 'line', 100
    new $P309, "Undef"
    .lex "$name", $P309
    find_lex $P310, "$meta_attr"
    $P311 = $P310."name"()
    store_lex "$name", $P311
.annotate 'line', 101
    find_lex $P313, "$name"
    find_lex $P314, "self"
    get_global $P315, "$?CLASS"
    getattribute $P316, $P314, $P315, "%!attributes"
    unless_null $P316, vivify_211
    $P316 = root_new ['parrot';'Hash']
  vivify_211:
    set $P317, $P316[$P313]
    unless_null $P317, vivify_212
    new $P317, "Undef"
  vivify_212:
    unless $P317, if_312_end
.annotate 'line', 102
    new $P318, "String"
    assign $P318, "This class already has an attribute named "
    find_lex $P319, "$name"
    concat $P320, $P318, $P319
    die $P320
  if_312_end:
.annotate 'line', 104
    find_lex $P321, "$meta_attr"
    find_lex $P322, "$name"
    find_lex $P323, "self"
    get_global $P324, "$?CLASS"
    getattribute $P325, $P323, $P324, "%!attributes"
    unless_null $P325, vivify_213
    $P325 = root_new ['parrot';'Hash']
    setattribute $P323, $P324, "%!attributes", $P325
  vivify_213:
    set $P325[$P322], $P321
.annotate 'line', 99
    .return ($P321)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_327
    .param pmc param_328
    .param pmc param_329
.annotate 'line', 107
    .const 'Sub' $P341 = "33_1298839204.312" 
    capture_lex $P341
    .lex "self", param_327
    .lex "$obj", param_328
    .lex "$parent", param_329
.annotate 'line', 108
    find_lex $P331, "self"
    get_global $P332, "$?CLASS"
    getattribute $P333, $P331, $P332, "$!composed"
    unless_null $P333, vivify_214
    new $P333, "Undef"
  vivify_214:
    unless $P333, if_330_end
.annotate 'line', 109
    die "NQPClassHOW does not support adding parents after being composed."
  if_330_end:
.annotate 'line', 111
    find_lex $P335, "self"
    get_global $P336, "$?CLASS"
    getattribute $P337, $P335, $P336, "@!parents"
    unless_null $P337, vivify_215
    $P337 = root_new ['parrot';'ResizablePMCArray']
  vivify_215:
    defined $I338, $P337
    unless $I338, for_undef_216
    iter $P334, $P337
    new $P353, 'ExceptionHandler'
    set_label $P353, loop352_handler
    $P353."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P353
  loop352_test:
    unless $P334, loop352_done
    shift $P339, $P334
  loop352_redo:
    .const 'Sub' $P341 = "33_1298839204.312" 
    capture_lex $P341
    $P341($P339)
  loop352_next:
    goto loop352_test
  loop352_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P354, exception, 'type'
    eq $P354, .CONTROL_LOOP_NEXT, loop352_next
    eq $P354, .CONTROL_LOOP_REDO, loop352_redo
  loop352_done:
    pop_eh 
  for_undef_216:
.annotate 'line', 116
    find_lex $P355, "$parent"
    find_lex $P356, "self"
    get_global $P357, "$?CLASS"
    getattribute $P358, $P356, $P357, "@!parents"
    unless_null $P358, vivify_217
    $P358 = root_new ['parrot';'ResizablePMCArray']
  vivify_217:
    set $N359, $P358
    set $I360, $N359
    find_lex $P361, "self"
    get_global $P362, "$?CLASS"
    getattribute $P363, $P361, $P362, "@!parents"
    unless_null $P363, vivify_218
    $P363 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P361, $P362, "@!parents", $P363
  vivify_218:
    set $P363[$I360], $P355
.annotate 'line', 107
    .return ($P355)
.end


.namespace ["NQPClassHOW"]
.sub "_block340"  :anon :subid("33_1298839204.312") :outer("32_1298839204.312")
    .param pmc param_342
.annotate 'line', 111
    .lex "$_", param_342
.annotate 'line', 112
    find_lex $P345, "$_"
    find_lex $P346, "$parent"
    issame $I347, $P345, $P346
    if $I347, if_344
    new $P343, 'Integer'
    set $P343, $I347
    goto if_344_end
  if_344:
.annotate 'line', 113
    new $P348, "String"
    assign $P348, "Already have "
    find_lex $P349, "$parent"
    concat $P350, $P348, $P349
    concat $P351, $P350, " as a parent class."
    die $P351
  if_344_end:
.annotate 'line', 111
    .return ($P343)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_role"  :subid("34_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_365
    .param pmc param_366
    .param pmc param_367
.annotate 'line', 119
    .const 'Sub' $P375 = "35_1298839204.312" 
    capture_lex $P375
    .lex "self", param_365
    .lex "$obj", param_366
    .lex "$role", param_367
.annotate 'line', 120
    find_lex $P369, "self"
    get_global $P370, "$?CLASS"
    getattribute $P371, $P369, $P370, "@!roles"
    unless_null $P371, vivify_219
    $P371 = root_new ['parrot';'ResizablePMCArray']
  vivify_219:
    defined $I372, $P371
    unless $I372, for_undef_220
    iter $P368, $P371
    new $P387, 'ExceptionHandler'
    set_label $P387, loop386_handler
    $P387."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P387
  loop386_test:
    unless $P368, loop386_done
    shift $P373, $P368
  loop386_redo:
    .const 'Sub' $P375 = "35_1298839204.312" 
    capture_lex $P375
    $P375($P373)
  loop386_next:
    goto loop386_test
  loop386_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P388, exception, 'type'
    eq $P388, .CONTROL_LOOP_NEXT, loop386_next
    eq $P388, .CONTROL_LOOP_REDO, loop386_redo
  loop386_done:
    pop_eh 
  for_undef_220:
.annotate 'line', 125
    find_lex $P389, "$role"
    find_lex $P390, "self"
    get_global $P391, "$?CLASS"
    getattribute $P392, $P390, $P391, "@!roles"
    unless_null $P392, vivify_221
    $P392 = root_new ['parrot';'ResizablePMCArray']
  vivify_221:
    set $N393, $P392
    set $I394, $N393
    find_lex $P395, "self"
    get_global $P396, "$?CLASS"
    getattribute $P397, $P395, $P396, "@!roles"
    unless_null $P397, vivify_222
    $P397 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P395, $P396, "@!roles", $P397
  vivify_222:
    set $P397[$I394], $P389
.annotate 'line', 119
    .return ($P389)
.end


.namespace ["NQPClassHOW"]
.sub "_block374"  :anon :subid("35_1298839204.312") :outer("34_1298839204.312")
    .param pmc param_376
.annotate 'line', 120
    .lex "$_", param_376
.annotate 'line', 121
    find_lex $P379, "$_"
    find_lex $P380, "$role"
    issame $I381, $P379, $P380
    if $I381, if_378
    new $P377, 'Integer'
    set $P377, $I381
    goto if_378_end
  if_378:
.annotate 'line', 122
    new $P382, "String"
    assign $P382, "The role "
    find_lex $P383, "$role"
    concat $P384, $P382, $P383
    concat $P385, $P384, " has already been added."
    die $P385
  if_378_end:
.annotate 'line', 120
    .return ($P377)
.end


.namespace ["NQPClassHOW"]
.sub "add_parrot_vtable_mapping"  :subid("36_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_399
    .param pmc param_400
    .param pmc param_401
    .param pmc param_402
.annotate 'line', 128
    .lex "self", param_399
    .lex "$obj", param_400
    .lex "$name", param_401
    .lex "$meth", param_402
.annotate 'line', 129
    find_lex $P404, "$name"
    find_lex $P405, "self"
    get_global $P406, "$?CLASS"
    getattribute $P407, $P405, $P406, "%!parrot_vtable_mapping"
    unless_null $P407, vivify_223
    $P407 = root_new ['parrot';'Hash']
  vivify_223:
    set $P408, $P407[$P404]
    unless_null $P408, vivify_224
    new $P408, "Undef"
  vivify_224:
    defined $I409, $P408
    unless $I409, if_403_end
.annotate 'line', 130
    new $P410, "String"
    assign $P410, "Class '"
    find_lex $P411, "self"
    get_global $P412, "$?CLASS"
    getattribute $P413, $P411, $P412, "$!name"
    unless_null $P413, vivify_225
    new $P413, "Undef"
  vivify_225:
    concat $P414, $P410, $P413
    concat $P415, $P414, "' already has a Parrot v-table override for '"
    find_lex $P416, "$name"
    concat $P417, $P415, $P416
.annotate 'line', 131
    concat $P418, $P417, "'"
.annotate 'line', 132
    die $P418
  if_403_end:
.annotate 'line', 134
    find_lex $P419, "$meth"
    find_lex $P420, "$name"
    find_lex $P421, "self"
    get_global $P422, "$?CLASS"
    getattribute $P423, $P421, $P422, "%!parrot_vtable_mapping"
    unless_null $P423, vivify_226
    $P423 = root_new ['parrot';'Hash']
    setattribute $P421, $P422, "%!parrot_vtable_mapping", $P423
  vivify_226:
    set $P423[$P420], $P419
.annotate 'line', 128
    .return ($P419)
.end


.namespace ["NQPClassHOW"]
.sub "compose"  :subid("37_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_425
    .param pmc param_426
.annotate 'line', 137
    .const 'Sub' $P432 = "38_1298839204.312" 
    capture_lex $P432
    .lex "self", param_425
    .lex "$obj", param_426
.annotate 'line', 141
    find_lex $P428, "self"
    get_global $P429, "$?CLASS"
    getattribute $P430, $P428, $P429, "@!roles"
    unless_null $P430, vivify_227
    $P430 = root_new ['parrot';'ResizablePMCArray']
  vivify_227:
    unless $P430, if_427_end
    .const 'Sub' $P432 = "38_1298839204.312" 
    capture_lex $P432
    $P432()
  if_427_end:
.annotate 'line', 154
    find_lex $P480, "self"
    get_global $P481, "$?CLASS"
    getattribute $P482, $P480, $P481, "@!parents"
    unless_null $P482, vivify_234
    $P482 = root_new ['parrot';'ResizablePMCArray']
  vivify_234:
    set $N483, $P482
    iseq $I484, $N483, 0.0
    if $I484, if_479
    new $P478, 'Integer'
    set $P478, $I484
    goto if_479_end
  if_479:
    find_lex $P485, "self"
    get_global $P486, "$?CLASS"
    getattribute $P487, $P485, $P486, "$!name"
    unless_null $P487, vivify_235
    new $P487, "Undef"
  vivify_235:
    set $S488, $P487
    isne $I489, $S488, "NQPMu"
    new $P478, 'Integer'
    set $P478, $I489
  if_479_end:
    unless $P478, if_477_end
.annotate 'line', 155
    find_lex $P490, "self"
    find_lex $P491, "$obj"
    get_hll_global $P492, "NQPMu"
    $P490."add_parent"($P491, $P492)
  if_477_end:
.annotate 'line', 160
    find_lex $P494, "self"
    get_global $P495, "$?CLASS"
    getattribute $P496, $P494, $P495, "$!composed"
    unless_null $P496, vivify_236
    new $P496, "Undef"
  vivify_236:
    if $P496, unless_493_end
.annotate 'line', 161
    find_lex $P497, "$obj"
    $P498 = "compute_c3_mro"($P497)
    find_lex $P499, "self"
    get_global $P500, "$?CLASS"
    setattribute $P499, $P500, "@!mro", $P498
.annotate 'line', 162
    new $P501, "Integer"
    assign $P501, 1
    find_lex $P502, "self"
    get_global $P503, "$?CLASS"
    setattribute $P502, $P503, "$!composed", $P501
  unless_493_end:
.annotate 'line', 166
    find_lex $P504, "self"
    find_lex $P505, "$obj"
    $P504."incorporate_multi_candidates"($P505)
.annotate 'line', 169
    find_lex $P506, "self"
    find_lex $P507, "$obj"
    $P506."publish_type_cache"($P507)
.annotate 'line', 170
    find_lex $P508, "self"
    find_lex $P509, "$obj"
    $P508."publish_method_cache"($P509)
.annotate 'line', 173
    find_lex $P510, "self"
    find_lex $P511, "$obj"
    $P510."publish_parrot_vtable_mapping"($P511)
    find_lex $P512, "$obj"
.annotate 'line', 137
    .return ($P512)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block431"  :anon :subid("38_1298839204.312") :outer("37_1298839204.312")
.annotate 'line', 141
    .const 'Sub' $P442 = "39_1298839204.312" 
    capture_lex $P442
.annotate 'line', 142
    $P433 = root_new ['parrot';'ResizablePMCArray']
    .lex "@instantiated_roles", $P433
.annotate 'line', 141
    find_lex $P434, "@instantiated_roles"
.annotate 'line', 143
    find_lex $P436, "self"
    get_global $P437, "$?CLASS"
    getattribute $P438, $P436, $P437, "@!roles"
    unless_null $P438, vivify_228
    $P438 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    defined $I439, $P438
    unless $I439, for_undef_229
    iter $P435, $P438
    new $P471, 'ExceptionHandler'
    set_label $P471, loop470_handler
    $P471."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P471
  loop470_test:
    unless $P435, loop470_done
    shift $P440, $P435
  loop470_redo:
    .const 'Sub' $P442 = "39_1298839204.312" 
    capture_lex $P442
    $P442($P440)
  loop470_next:
    goto loop470_test
  loop470_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P472, exception, 'type'
    eq $P472, .CONTROL_LOOP_NEXT, loop470_next
    eq $P472, .CONTROL_LOOP_REDO, loop470_redo
  loop470_done:
    pop_eh 
  for_undef_229:
.annotate 'line', 149
    get_hll_global $P473, "RoleToClassApplier"
    find_lex $P474, "$obj"
    find_lex $P475, "@instantiated_roles"
    $P476 = $P473."apply"($P474, $P475)
.annotate 'line', 141
    .return ($P476)
.end


.namespace ["NQPClassHOW"]
.sub "_block441"  :anon :subid("39_1298839204.312") :outer("38_1298839204.312")
    .param pmc param_444
.annotate 'line', 144
    new $P443, "Undef"
    .lex "$ins", $P443
    .lex "$_", param_444
    find_lex $P445, "$_"
    get_how $P446, $P445
    find_lex $P447, "$_"
    find_lex $P448, "$obj"
    $P449 = $P446."instantiate"($P447, $P448)
    store_lex "$ins", $P449
.annotate 'line', 145
    find_lex $P450, "@instantiated_roles"
    find_lex $P451, "$ins"
    $P450."push"($P451)
.annotate 'line', 146
    find_lex $P452, "$_"
    find_lex $P453, "self"
    get_global $P454, "$?CLASS"
    getattribute $P455, $P453, $P454, "@!done"
    unless_null $P455, vivify_230
    $P455 = root_new ['parrot';'ResizablePMCArray']
  vivify_230:
    set $N456, $P455
    set $I457, $N456
    find_lex $P458, "self"
    get_global $P459, "$?CLASS"
    getattribute $P460, $P458, $P459, "@!done"
    unless_null $P460, vivify_231
    $P460 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P458, $P459, "@!done", $P460
  vivify_231:
    set $P460[$I457], $P452
.annotate 'line', 147
    find_lex $P461, "$ins"
    find_lex $P462, "self"
    get_global $P463, "$?CLASS"
    getattribute $P464, $P462, $P463, "@!done"
    unless_null $P464, vivify_232
    $P464 = root_new ['parrot';'ResizablePMCArray']
  vivify_232:
    set $N465, $P464
    set $I466, $N465
    find_lex $P467, "self"
    get_global $P468, "$?CLASS"
    getattribute $P469, $P467, $P468, "@!done"
    unless_null $P469, vivify_233
    $P469 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P467, $P468, "@!done", $P469
  vivify_233:
    set $P469[$I466], $P461
.annotate 'line', 143
    .return ($P461)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("40_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_514
    .param pmc param_515
.annotate 'line', 178
    .const 'Sub' $P530 = "41_1298839204.312" 
    capture_lex $P530
    .lex "self", param_514
    .lex "$obj", param_515
.annotate 'line', 179
    new $P516, "Undef"
    .lex "$num_todo", $P516
.annotate 'line', 180
    new $P517, "Undef"
    .lex "$i", $P517
.annotate 'line', 179
    find_lex $P518, "self"
    get_global $P519, "$?CLASS"
    getattribute $P520, $P518, $P519, "@!multi_methods_to_incorporate"
    unless_null $P520, vivify_237
    $P520 = root_new ['parrot';'ResizablePMCArray']
  vivify_237:
    set $N521, $P520
    new $P522, 'Float'
    set $P522, $N521
    store_lex "$num_todo", $P522
.annotate 'line', 180
    new $P523, "Integer"
    assign $P523, 0
    store_lex "$i", $P523
.annotate 'line', 181
    new $P639, 'ExceptionHandler'
    set_label $P639, loop638_handler
    $P639."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P639
  loop638_test:
    find_lex $P524, "$i"
    set $N525, $P524
    find_lex $P526, "$num_todo"
    set $N527, $P526
    isne $I528, $N525, $N527
    unless $I528, loop638_done
  loop638_redo:
    .const 'Sub' $P530 = "41_1298839204.312" 
    capture_lex $P530
    $P530()
  loop638_next:
    goto loop638_test
  loop638_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P640, exception, 'type'
    eq $P640, .CONTROL_LOOP_NEXT, loop638_next
    eq $P640, .CONTROL_LOOP_REDO, loop638_redo
  loop638_done:
    pop_eh 
.annotate 'line', 178
    .return ($I528)
.end


.namespace ["NQPClassHOW"]
.sub "_block529"  :anon :subid("41_1298839204.312") :outer("40_1298839204.312")
.annotate 'line', 181
    .const 'Sub' $P566 = "42_1298839204.312" 
    capture_lex $P566
.annotate 'line', 183
    new $P531, "Undef"
    .lex "$name", $P531
.annotate 'line', 184
    new $P532, "Undef"
    .lex "$code", $P532
.annotate 'line', 188
    new $P533, "Undef"
    .lex "$dispatcher", $P533
.annotate 'line', 183
    find_lex $P534, "$i"
    set $I535, $P534
    find_lex $P536, "self"
    get_global $P537, "$?CLASS"
    getattribute $P538, $P536, $P537, "@!multi_methods_to_incorporate"
    unless_null $P538, vivify_238
    $P538 = root_new ['parrot';'ResizablePMCArray']
  vivify_238:
    set $P539, $P538[$I535]
    unless_null $P539, vivify_239
    $P539 = root_new ['parrot';'Hash']
  vivify_239:
    set $P540, $P539["name"]
    unless_null $P540, vivify_240
    new $P540, "Undef"
  vivify_240:
    store_lex "$name", $P540
.annotate 'line', 184
    find_lex $P541, "$i"
    set $I542, $P541
    find_lex $P543, "self"
    get_global $P544, "$?CLASS"
    getattribute $P545, $P543, $P544, "@!multi_methods_to_incorporate"
    unless_null $P545, vivify_241
    $P545 = root_new ['parrot';'ResizablePMCArray']
  vivify_241:
    set $P546, $P545[$I542]
    unless_null $P546, vivify_242
    $P546 = root_new ['parrot';'Hash']
  vivify_242:
    set $P547, $P546["code"]
    unless_null $P547, vivify_243
    new $P547, "Undef"
  vivify_243:
    store_lex "$code", $P547
.annotate 'line', 188
    find_lex $P548, "$name"
    find_lex $P549, "self"
    get_global $P550, "$?CLASS"
    getattribute $P551, $P549, $P550, "%!methods"
    unless_null $P551, vivify_244
    $P551 = root_new ['parrot';'Hash']
  vivify_244:
    set $P552, $P551[$P548]
    unless_null $P552, vivify_245
    new $P552, "Undef"
  vivify_245:
    store_lex "$dispatcher", $P552
.annotate 'line', 189
    find_lex $P554, "$dispatcher"
    defined $I555, $P554
    if $I555, if_553
.annotate 'line', 199
    .const 'Sub' $P566 = "42_1298839204.312" 
    capture_lex $P566
    $P566()
    goto if_553_end
  if_553:
.annotate 'line', 192
    find_lex $P557, "$dispatcher"
    is_dispatcher $I558, $P557
    if $I558, if_556
.annotate 'line', 196
    new $P561, 'String'
    set $P561, "Cannot have a multi candidate for "
    find_lex $P562, "$name"
    concat $P563, $P561, $P562
    concat $P564, $P563, " when an only method is also in the class"
    die $P564
.annotate 'line', 195
    goto if_556_end
  if_556:
.annotate 'line', 193
    find_lex $P559, "$dispatcher"
    find_lex $P560, "$code"
    push_dispatchee $P559, $P560
  if_556_end:
  if_553_end:
.annotate 'line', 227
    find_lex $P636, "$i"
    add $P637, $P636, 1
    store_lex "$i", $P637
.annotate 'line', 181
    .return ($P637)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block565"  :anon :subid("42_1298839204.312") :outer("41_1298839204.312")
.annotate 'line', 199
    .const 'Sub' $P583 = "43_1298839204.312" 
    capture_lex $P583
.annotate 'line', 201
    new $P567, "Undef"
    .lex "$j", $P567
.annotate 'line', 202
    new $P568, "Undef"
    .lex "$found", $P568
.annotate 'line', 201
    new $P569, "Integer"
    assign $P569, 1
    store_lex "$j", $P569
.annotate 'line', 202
    new $P570, "Integer"
    assign $P570, 0
    store_lex "$found", $P570
.annotate 'line', 203
    new $P627, 'ExceptionHandler'
    set_label $P627, loop626_handler
    $P627."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P627
  loop626_test:
    find_lex $P573, "$j"
    set $N574, $P573
    find_lex $P575, "self"
    get_global $P576, "$?CLASS"
    getattribute $P577, $P575, $P576, "@!mro"
    unless_null $P577, vivify_246
    $P577 = root_new ['parrot';'ResizablePMCArray']
  vivify_246:
    set $N578, $P577
    isne $I579, $N574, $N578
    if $I579, if_572
    new $P571, 'Integer'
    set $P571, $I579
    goto if_572_end
  if_572:
    find_lex $P580, "$found"
    isfalse $I581, $P580
    new $P571, 'Integer'
    set $P571, $I581
  if_572_end:
    unless $P571, loop626_done
  loop626_redo:
    .const 'Sub' $P583 = "43_1298839204.312" 
    capture_lex $P583
    $P583()
  loop626_next:
    goto loop626_test
  loop626_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P628, exception, 'type'
    eq $P628, .CONTROL_LOOP_NEXT, loop626_next
    eq $P628, .CONTROL_LOOP_REDO, loop626_redo
  loop626_done:
    pop_eh 
.annotate 'line', 223
    find_lex $P631, "$found"
    unless $P631, unless_630
    set $P629, $P631
    goto unless_630_end
  unless_630:
.annotate 'line', 224
    new $P632, 'String'
    set $P632, "Could not find a proto for multi "
    find_lex $P633, "$name"
    concat $P634, $P632, $P633
    concat $P635, $P634, ", and proto generation is NYI"
    die $P635
  unless_630_end:
.annotate 'line', 199
    .return ($P629)
.end


.namespace ["NQPClassHOW"]
.sub "_block582"  :anon :subid("43_1298839204.312") :outer("42_1298839204.312")
.annotate 'line', 203
    .const 'Sub' $P607 = "44_1298839204.312" 
    capture_lex $P607
.annotate 'line', 204
    new $P584, "Undef"
    .lex "$parent", $P584
.annotate 'line', 205
    $P585 = root_new ['parrot';'Hash']
    .lex "%meths", $P585
.annotate 'line', 206
    new $P586, "Undef"
    .lex "$dispatcher", $P586
.annotate 'line', 204
    find_lex $P587, "$j"
    set $I588, $P587
    find_lex $P589, "self"
    get_global $P590, "$?CLASS"
    getattribute $P591, $P589, $P590, "@!mro"
    unless_null $P591, vivify_247
    $P591 = root_new ['parrot';'ResizablePMCArray']
  vivify_247:
    set $P592, $P591[$I588]
    unless_null $P592, vivify_248
    new $P592, "Undef"
  vivify_248:
    store_lex "$parent", $P592
.annotate 'line', 205
    find_lex $P593, "$parent"
    get_how $P594, $P593
    find_lex $P595, "$parent"
    $P596 = $P594."method_table"($P595)
    store_lex "%meths", $P596
.annotate 'line', 206
    find_lex $P597, "$name"
    find_lex $P598, "%meths"
    unless_null $P598, vivify_249
    $P598 = root_new ['parrot';'Hash']
  vivify_249:
    set $P599, $P598[$P597]
    unless_null $P599, vivify_250
    new $P599, "Undef"
  vivify_250:
    store_lex "$dispatcher", $P599
.annotate 'line', 207
    find_lex $P601, "$dispatcher"
    defined $I602, $P601
    unless $I602, if_600_end
.annotate 'line', 210
    find_lex $P604, "$dispatcher"
    is_dispatcher $I605, $P604
    if $I605, if_603
.annotate 'line', 218
    new $P620, 'String'
    set $P620, "Could not find a proto for multi "
    find_lex $P621, "$name"
    concat $P622, $P620, $P621
    concat $P623, $P622, " (it may exist, but an only is hiding it if so)"
    die $P623
.annotate 'line', 217
    goto if_603_end
  if_603:
.annotate 'line', 210
    .const 'Sub' $P607 = "44_1298839204.312" 
    capture_lex $P607
    $P607()
  if_603_end:
  if_600_end:
.annotate 'line', 221
    find_lex $P624, "$j"
    add $P625, $P624, 1
    store_lex "$j", $P625
.annotate 'line', 203
    .return ($P625)
.end


.namespace ["NQPClassHOW"]
.sub "_block606"  :anon :subid("44_1298839204.312") :outer("43_1298839204.312")
.annotate 'line', 212
    $P608 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P608
.annotate 'line', 210
    find_lex $P609, "@new_dispatchees"
.annotate 'line', 213
    find_lex $P610, "$code"
    find_lex $P611, "@new_dispatchees"
    unless_null $P611, vivify_251
    $P611 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P611
  vivify_251:
    set $P611[0], $P610
.annotate 'line', 214
    find_lex $P612, "$dispatcher"
    find_lex $P613, "@new_dispatchees"
    create_dispatch_and_add_candidates $P614, $P612, $P613
    find_lex $P615, "$name"
    find_lex $P616, "self"
    get_global $P617, "$?CLASS"
    getattribute $P618, $P616, $P617, "%!methods"
    unless_null $P618, vivify_252
    $P618 = root_new ['parrot';'Hash']
    setattribute $P616, $P617, "%!methods", $P618
  vivify_252:
    set $P618[$P615], $P614
.annotate 'line', 215
    new $P619, "Integer"
    assign $P619, 1
    store_lex "$found", $P619
.annotate 'line', 210
    .return ($P619)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_type_cache"  :subid("45_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_644
    .param pmc param_645
.annotate 'line', 320
    .const 'Sub' $P670 = "47_1298839204.312" 
    capture_lex $P670
    .const 'Sub' $P655 = "46_1298839204.312" 
    capture_lex $P655
    .lex "self", param_644
    .lex "$obj", param_645
.annotate 'line', 321
    $P646 = root_new ['parrot';'ResizablePMCArray']
    .lex "@tc", $P646
.annotate 'line', 320
    find_lex $P647, "@tc"
.annotate 'line', 322
    find_lex $P649, "self"
    get_global $P650, "$?CLASS"
    getattribute $P651, $P649, $P650, "@!mro"
    unless_null $P651, vivify_253
    $P651 = root_new ['parrot';'ResizablePMCArray']
  vivify_253:
    defined $I652, $P651
    unless $I652, for_undef_254
    iter $P648, $P651
    new $P661, 'ExceptionHandler'
    set_label $P661, loop660_handler
    $P661."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P661
  loop660_test:
    unless $P648, loop660_done
    shift $P653, $P648
  loop660_redo:
    .const 'Sub' $P655 = "46_1298839204.312" 
    capture_lex $P655
    $P655($P653)
  loop660_next:
    goto loop660_test
  loop660_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P662, exception, 'type'
    eq $P662, .CONTROL_LOOP_NEXT, loop660_next
    eq $P662, .CONTROL_LOOP_REDO, loop660_redo
  loop660_done:
    pop_eh 
  for_undef_254:
.annotate 'line', 323
    find_lex $P664, "self"
    get_global $P665, "$?CLASS"
    getattribute $P666, $P664, $P665, "@!done"
    unless_null $P666, vivify_255
    $P666 = root_new ['parrot';'ResizablePMCArray']
  vivify_255:
    defined $I667, $P666
    unless $I667, for_undef_256
    iter $P663, $P666
    new $P676, 'ExceptionHandler'
    set_label $P676, loop675_handler
    $P676."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P676
  loop675_test:
    unless $P663, loop675_done
    shift $P668, $P663
  loop675_redo:
    .const 'Sub' $P670 = "47_1298839204.312" 
    capture_lex $P670
    $P670($P668)
  loop675_next:
    goto loop675_test
  loop675_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P677, exception, 'type'
    eq $P677, .CONTROL_LOOP_NEXT, loop675_next
    eq $P677, .CONTROL_LOOP_REDO, loop675_redo
  loop675_done:
    pop_eh 
  for_undef_256:
.annotate 'line', 324
    find_lex $P678, "$obj"
    find_lex $P679, "@tc"
    publish_type_check_cache $P678, $P679
.annotate 'line', 320
    .return ()
.end


.namespace ["NQPClassHOW"]
.sub "_block654"  :anon :subid("46_1298839204.312") :outer("45_1298839204.312")
    .param pmc param_656
.annotate 'line', 322
    .lex "$_", param_656
    find_lex $P657, "@tc"
    find_lex $P658, "$_"
    $P659 = $P657."push"($P658)
    .return ($P659)
.end


.namespace ["NQPClassHOW"]
.sub "_block669"  :anon :subid("47_1298839204.312") :outer("45_1298839204.312")
    .param pmc param_671
.annotate 'line', 323
    .lex "$_", param_671
    find_lex $P672, "@tc"
    find_lex $P673, "$_"
    $P674 = $P672."push"($P673)
    .return ($P674)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("48_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_681
    .param pmc param_682
.annotate 'line', 327
    .const 'Sub' $P692 = "49_1298839204.312" 
    capture_lex $P692
    .lex "self", param_681
    .lex "$obj", param_682
.annotate 'line', 330
    $P683 = root_new ['parrot';'Hash']
    .lex "%cache", $P683
.annotate 'line', 327
    find_lex $P684, "%cache"
.annotate 'line', 331
    find_lex $P686, "self"
    get_global $P687, "$?CLASS"
    getattribute $P688, $P686, $P687, "@!mro"
    unless_null $P688, vivify_257
    $P688 = root_new ['parrot';'ResizablePMCArray']
  vivify_257:
    defined $I689, $P688
    unless $I689, for_undef_258
    iter $P685, $P688
    new $P721, 'ExceptionHandler'
    set_label $P721, loop720_handler
    $P721."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P721
  loop720_test:
    unless $P685, loop720_done
    shift $P690, $P685
  loop720_redo:
    .const 'Sub' $P692 = "49_1298839204.312" 
    capture_lex $P692
    $P692($P690)
  loop720_next:
    goto loop720_test
  loop720_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P722, exception, 'type'
    eq $P722, .CONTROL_LOOP_NEXT, loop720_next
    eq $P722, .CONTROL_LOOP_REDO, loop720_redo
  loop720_done:
    pop_eh 
  for_undef_258:
.annotate 'line', 339
    find_lex $P723, "$obj"
    find_lex $P724, "%cache"
    publish_method_cache $P723, $P724
.annotate 'line', 327
    .return ()
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block691"  :anon :subid("49_1298839204.312") :outer("48_1298839204.312")
    .param pmc param_694
.annotate 'line', 331
    .const 'Sub' $P704 = "50_1298839204.312" 
    capture_lex $P704
.annotate 'line', 332
    $P693 = root_new ['parrot';'Hash']
    .lex "%methods", $P693
    .lex "$_", param_694
    find_lex $P695, "$_"
    get_how $P696, $P695
    find_lex $P697, "$_"
    $P698 = $P696."method_table"($P697)
    store_lex "%methods", $P698
.annotate 'line', 333
    find_lex $P700, "%methods"
    defined $I701, $P700
    unless $I701, for_undef_259
    iter $P699, $P700
    new $P718, 'ExceptionHandler'
    set_label $P718, loop717_handler
    $P718."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P718
  loop717_test:
    unless $P699, loop717_done
    shift $P702, $P699
  loop717_redo:
    .const 'Sub' $P704 = "50_1298839204.312" 
    capture_lex $P704
    $P704($P702)
  loop717_next:
    goto loop717_test
  loop717_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P719, exception, 'type'
    eq $P719, .CONTROL_LOOP_NEXT, loop717_next
    eq $P719, .CONTROL_LOOP_REDO, loop717_redo
  loop717_done:
    pop_eh 
  for_undef_259:
.annotate 'line', 331
    .return ($P699)
.end


.namespace ["NQPClassHOW"]
.sub "_block703"  :anon :subid("50_1298839204.312") :outer("49_1298839204.312")
    .param pmc param_705
.annotate 'line', 333
    .lex "$_", param_705
.annotate 'line', 334
    find_lex $P708, "$_"
    $P709 = $P708."key"()
    find_lex $P710, "%cache"
    unless_null $P710, vivify_260
    $P710 = root_new ['parrot';'Hash']
  vivify_260:
    set $P711, $P710[$P709]
    unless_null $P711, vivify_261
    new $P711, "Undef"
  vivify_261:
    unless $P711, unless_707
    set $P706, $P711
    goto unless_707_end
  unless_707:
.annotate 'line', 335
    find_lex $P712, "$_"
    $P713 = $P712."value"()
    find_lex $P714, "$_"
    $P715 = $P714."key"()
    find_lex $P716, "%cache"
    unless_null $P716, vivify_262
    $P716 = root_new ['parrot';'Hash']
    store_lex "%cache", $P716
  vivify_262:
    set $P716[$P715], $P713
.annotate 'line', 334
    set $P706, $P713
  unless_707_end:
.annotate 'line', 333
    .return ($P706)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_parrot_vtable_mapping"  :subid("51_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_726
    .param pmc param_727
.annotate 'line', 342
    .const 'Sub' $P737 = "52_1298839204.312" 
    capture_lex $P737
    .lex "self", param_726
    .lex "$obj", param_727
.annotate 'line', 343
    $P728 = root_new ['parrot';'Hash']
    .lex "%mapping", $P728
.annotate 'line', 342
    find_lex $P729, "%mapping"
.annotate 'line', 344
    find_lex $P731, "self"
    get_global $P732, "$?CLASS"
    getattribute $P733, $P731, $P732, "@!mro"
    unless_null $P733, vivify_263
    $P733 = root_new ['parrot';'ResizablePMCArray']
  vivify_263:
    defined $I734, $P733
    unless $I734, for_undef_264
    iter $P730, $P733
    new $P766, 'ExceptionHandler'
    set_label $P766, loop765_handler
    $P766."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P766
  loop765_test:
    unless $P730, loop765_done
    shift $P735, $P730
  loop765_redo:
    .const 'Sub' $P737 = "52_1298839204.312" 
    capture_lex $P737
    $P737($P735)
  loop765_next:
    goto loop765_test
  loop765_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P767, exception, 'type'
    eq $P767, .CONTROL_LOOP_NEXT, loop765_next
    eq $P767, .CONTROL_LOOP_REDO, loop765_redo
  loop765_done:
    pop_eh 
  for_undef_264:
.annotate 'line', 352
    find_lex $P770, "%mapping"
    set $N771, $P770
    if $N771, if_769
    new $P768, 'Float'
    set $P768, $N771
    goto if_769_end
  if_769:
.annotate 'line', 353
    find_lex $P772, "$obj"
    find_lex $P773, "%mapping"
    stable_publish_vtable_mapping $P772, $P773
  if_769_end:
.annotate 'line', 342
    .return ($P768)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block736"  :anon :subid("52_1298839204.312") :outer("51_1298839204.312")
    .param pmc param_739
.annotate 'line', 344
    .const 'Sub' $P749 = "53_1298839204.312" 
    capture_lex $P749
.annotate 'line', 345
    $P738 = root_new ['parrot';'Hash']
    .lex "%map", $P738
    .lex "$_", param_739
    find_lex $P740, "$_"
    get_how $P741, $P740
    find_lex $P742, "$_"
    $P743 = $P741."parrot_vtable_mappings"($P742, 1 :named("local"))
    store_lex "%map", $P743
.annotate 'line', 346
    find_lex $P745, "%map"
    defined $I746, $P745
    unless $I746, for_undef_265
    iter $P744, $P745
    new $P763, 'ExceptionHandler'
    set_label $P763, loop762_handler
    $P763."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P763
  loop762_test:
    unless $P744, loop762_done
    shift $P747, $P744
  loop762_redo:
    .const 'Sub' $P749 = "53_1298839204.312" 
    capture_lex $P749
    $P749($P747)
  loop762_next:
    goto loop762_test
  loop762_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P764, exception, 'type'
    eq $P764, .CONTROL_LOOP_NEXT, loop762_next
    eq $P764, .CONTROL_LOOP_REDO, loop762_redo
  loop762_done:
    pop_eh 
  for_undef_265:
.annotate 'line', 344
    .return ($P744)
.end


.namespace ["NQPClassHOW"]
.sub "_block748"  :anon :subid("53_1298839204.312") :outer("52_1298839204.312")
    .param pmc param_750
.annotate 'line', 346
    .lex "$_", param_750
.annotate 'line', 347
    find_lex $P753, "$_"
    $P754 = $P753."key"()
    find_lex $P755, "%mapping"
    unless_null $P755, vivify_266
    $P755 = root_new ['parrot';'Hash']
  vivify_266:
    set $P756, $P755[$P754]
    unless_null $P756, vivify_267
    new $P756, "Undef"
  vivify_267:
    unless $P756, unless_752
    set $P751, $P756
    goto unless_752_end
  unless_752:
.annotate 'line', 348
    find_lex $P757, "$_"
    $P758 = $P757."value"()
    find_lex $P759, "$_"
    $P760 = $P759."key"()
    find_lex $P761, "%mapping"
    unless_null $P761, vivify_268
    $P761 = root_new ['parrot';'Hash']
    store_lex "%mapping", $P761
  vivify_268:
    set $P761[$P760], $P758
.annotate 'line', 347
    set $P751, $P758
  unless_752_end:
.annotate 'line', 346
    .return ($P751)
.end


.namespace ["NQPClassHOW"]
.sub "parents"  :subid("54_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_775
    .param pmc param_776
    .param pmc param_777 :optional :named("local")
    .param int has_param_777 :opt_flag
.annotate 'line', 361
    .lex "self", param_775
    .lex "$obj", param_776
    if has_param_777, optparam_269
    new $P778, "Undef"
    set param_777, $P778
  optparam_269:
    .lex "$local", param_777
.annotate 'line', 362
    find_lex $P781, "$local"
    if $P781, if_780
    find_lex $P785, "self"
    get_global $P786, "$?CLASS"
    getattribute $P787, $P785, $P786, "@!mro"
    unless_null $P787, vivify_270
    $P787 = root_new ['parrot';'ResizablePMCArray']
  vivify_270:
    set $P779, $P787
    goto if_780_end
  if_780:
    find_lex $P782, "self"
    get_global $P783, "$?CLASS"
    getattribute $P784, $P782, $P783, "@!parents"
    unless_null $P784, vivify_271
    $P784 = root_new ['parrot';'ResizablePMCArray']
  vivify_271:
    set $P779, $P784
  if_780_end:
.annotate 'line', 361
    .return ($P779)
.end


.namespace ["NQPClassHOW"]
.sub "roles"  :subid("55_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_789
    .param pmc param_790
    .param pmc param_791 :named("local")
.annotate 'line', 365
    .lex "self", param_789
    .lex "$obj", param_790
    .lex "$local", param_791
    find_lex $P792, "self"
    get_global $P793, "$?CLASS"
    getattribute $P794, $P792, $P793, "@!roles"
    unless_null $P794, vivify_272
    $P794 = root_new ['parrot';'ResizablePMCArray']
  vivify_272:
    .return ($P794)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("56_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_796
    .param pmc param_797
    .param pmc param_798 :named("local")
.annotate 'line', 369
    .const 'Sub' $P808 = "57_1298839204.312" 
    capture_lex $P808
    .lex "self", param_796
    .lex "$obj", param_797
    .lex "$local", param_798
.annotate 'line', 370
    $P799 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P799
.annotate 'line', 369
    find_lex $P800, "@meths"
.annotate 'line', 371
    find_lex $P802, "self"
    get_global $P803, "$?CLASS"
    getattribute $P804, $P802, $P803, "%!methods"
    unless_null $P804, vivify_273
    $P804 = root_new ['parrot';'Hash']
  vivify_273:
    defined $I805, $P804
    unless $I805, for_undef_274
    iter $P801, $P804
    new $P815, 'ExceptionHandler'
    set_label $P815, loop814_handler
    $P815."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P815
  loop814_test:
    unless $P801, loop814_done
    shift $P806, $P801
  loop814_redo:
    .const 'Sub' $P808 = "57_1298839204.312" 
    capture_lex $P808
    $P808($P806)
  loop814_next:
    goto loop814_test
  loop814_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P816, exception, 'type'
    eq $P816, .CONTROL_LOOP_NEXT, loop814_next
    eq $P816, .CONTROL_LOOP_REDO, loop814_redo
  loop814_done:
    pop_eh 
  for_undef_274:
    find_lex $P817, "@meths"
.annotate 'line', 369
    .return ($P817)
.end


.namespace ["NQPClassHOW"]
.sub "_block807"  :anon :subid("57_1298839204.312") :outer("56_1298839204.312")
    .param pmc param_809
.annotate 'line', 371
    .lex "$_", param_809
.annotate 'line', 372
    find_lex $P810, "@meths"
    find_lex $P811, "$_"
    $P812 = $P811."value"()
    $P813 = $P810."push"($P812)
.annotate 'line', 371
    .return ($P813)
.end


.namespace ["NQPClassHOW"]
.sub "method_table"  :subid("58_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_819
    .param pmc param_820
.annotate 'line', 377
    .lex "self", param_819
    .lex "$obj", param_820
    find_lex $P821, "self"
    get_global $P822, "$?CLASS"
    getattribute $P823, $P821, $P822, "%!methods"
    unless_null $P823, vivify_275
    $P823 = root_new ['parrot';'Hash']
  vivify_275:
    .return ($P823)
.end


.namespace ["NQPClassHOW"]
.sub "name"  :subid("59_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_825
    .param pmc param_826
.annotate 'line', 381
    .lex "self", param_825
    .lex "$obj", param_826
    find_lex $P827, "self"
    get_global $P828, "$?CLASS"
    getattribute $P829, $P827, $P828, "$!name"
    unless_null $P829, vivify_276
    new $P829, "Undef"
  vivify_276:
    .return ($P829)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("60_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_831
    .param pmc param_832
    .param pmc param_833 :named("local")
.annotate 'line', 385
    .const 'Sub' $P843 = "61_1298839204.312" 
    capture_lex $P843
    .lex "self", param_831
    .lex "$obj", param_832
    .lex "$local", param_833
.annotate 'line', 386
    $P834 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P834
.annotate 'line', 385
    find_lex $P835, "@attrs"
.annotate 'line', 387
    find_lex $P837, "self"
    get_global $P838, "$?CLASS"
    getattribute $P839, $P837, $P838, "%!attributes"
    unless_null $P839, vivify_277
    $P839 = root_new ['parrot';'Hash']
  vivify_277:
    defined $I840, $P839
    unless $I840, for_undef_278
    iter $P836, $P839
    new $P850, 'ExceptionHandler'
    set_label $P850, loop849_handler
    $P850."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P850
  loop849_test:
    unless $P836, loop849_done
    shift $P841, $P836
  loop849_redo:
    .const 'Sub' $P843 = "61_1298839204.312" 
    capture_lex $P843
    $P843($P841)
  loop849_next:
    goto loop849_test
  loop849_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P851, exception, 'type'
    eq $P851, .CONTROL_LOOP_NEXT, loop849_next
    eq $P851, .CONTROL_LOOP_REDO, loop849_redo
  loop849_done:
    pop_eh 
  for_undef_278:
    find_lex $P852, "@attrs"
.annotate 'line', 385
    .return ($P852)
.end


.namespace ["NQPClassHOW"]
.sub "_block842"  :anon :subid("61_1298839204.312") :outer("60_1298839204.312")
    .param pmc param_844
.annotate 'line', 387
    .lex "$_", param_844
.annotate 'line', 388
    find_lex $P845, "@attrs"
    find_lex $P846, "$_"
    $P847 = $P846."value"()
    $P848 = $P845."push"($P847)
.annotate 'line', 387
    .return ($P848)
.end


.namespace ["NQPClassHOW"]
.sub "parrot_vtable_mappings"  :subid("62_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_854
    .param pmc param_855
    .param pmc param_856 :named("local")
.annotate 'line', 393
    .lex "self", param_854
    .lex "$obj", param_855
    .lex "$local", param_856
    find_lex $P857, "self"
    get_global $P858, "$?CLASS"
    getattribute $P859, $P857, $P858, "%!parrot_vtable_mapping"
    unless_null $P859, vivify_279
    $P859 = root_new ['parrot';'Hash']
  vivify_279:
    .return ($P859)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("63_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_863
    .param pmc param_864
    .param pmc param_865
.annotate 'line', 401
    new $P862, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P862, control_861
    push_eh $P862
    .lex "self", param_863
    .lex "$obj", param_864
    .lex "$check", param_865
.annotate 'line', 402
    new $P866, "Undef"
    .lex "$check-class", $P866
.annotate 'line', 403
    new $P867, "Undef"
    .lex "$i", $P867
.annotate 'line', 402
    find_lex $P868, "$check"
    get_what $P869, $P868
    store_lex "$check-class", $P869
.annotate 'line', 403
    find_lex $P870, "self"
    get_global $P871, "$?CLASS"
    getattribute $P872, $P870, $P871, "@!mro"
    unless_null $P872, vivify_280
    $P872 = root_new ['parrot';'ResizablePMCArray']
  vivify_280:
    set $N873, $P872
    new $P874, 'Float'
    set $P874, $N873
    store_lex "$i", $P874
.annotate 'line', 404
    new $P892, 'ExceptionHandler'
    set_label $P892, loop891_handler
    $P892."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P892
  loop891_test:
    find_lex $P875, "$i"
    set $N876, $P875
    isgt $I877, $N876, 0.0
    unless $I877, loop891_done
  loop891_redo:
.annotate 'line', 405
    find_lex $P878, "$i"
    sub $P879, $P878, 1
    store_lex "$i", $P879
.annotate 'line', 406
    find_lex $P881, "$i"
    set $I882, $P881
    find_lex $P883, "self"
    get_global $P884, "$?CLASS"
    getattribute $P885, $P883, $P884, "@!mro"
    unless_null $P885, vivify_281
    $P885 = root_new ['parrot';'ResizablePMCArray']
  vivify_281:
    set $P886, $P885[$I882]
    unless_null $P886, vivify_282
    new $P886, "Undef"
  vivify_282:
    find_lex $P887, "$check-class"
    issame $I888, $P886, $P887
    unless $I888, if_880_end
.annotate 'line', 407
    new $P889, "Exception"
    set $P889['type'], .CONTROL_RETURN
    new $P890, "Integer"
    assign $P890, 1
    setattribute $P889, 'payload', $P890
    throw $P889
  if_880_end:
  loop891_next:
.annotate 'line', 404
    goto loop891_test
  loop891_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P893, exception, 'type'
    eq $P893, .CONTROL_LOOP_NEXT, loop891_next
    eq $P893, .CONTROL_LOOP_REDO, loop891_redo
  loop891_done:
    pop_eh 
.annotate 'line', 410
    new $P894, "Exception"
    set $P894['type'], .CONTROL_RETURN
    new $P895, "Integer"
    assign $P895, 0
    setattribute $P894, 'payload', $P895
    throw $P894
.annotate 'line', 401
    .return ()
  control_861:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P896, exception, "payload"
    .return ($P896)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("64_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_900
    .param pmc param_901
    .param pmc param_902
.annotate 'line', 413
    new $P899, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P899, control_898
    push_eh $P899
    .lex "self", param_900
    .lex "$obj", param_901
    .lex "$check", param_902
.annotate 'line', 414
    new $P903, "Undef"
    .lex "$i", $P903
    find_lex $P904, "self"
    get_global $P905, "$?CLASS"
    getattribute $P906, $P904, $P905, "@!done"
    unless_null $P906, vivify_283
    $P906 = root_new ['parrot';'ResizablePMCArray']
  vivify_283:
    set $N907, $P906
    new $P908, 'Float'
    set $P908, $N907
    store_lex "$i", $P908
.annotate 'line', 415
    new $P926, 'ExceptionHandler'
    set_label $P926, loop925_handler
    $P926."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P926
  loop925_test:
    find_lex $P909, "$i"
    set $N910, $P909
    isgt $I911, $N910, 0.0
    unless $I911, loop925_done
  loop925_redo:
.annotate 'line', 416
    find_lex $P912, "$i"
    sub $P913, $P912, 1
    store_lex "$i", $P913
.annotate 'line', 417
    find_lex $P915, "$i"
    set $I916, $P915
    find_lex $P917, "self"
    get_global $P918, "$?CLASS"
    getattribute $P919, $P917, $P918, "@!done"
    unless_null $P919, vivify_284
    $P919 = root_new ['parrot';'ResizablePMCArray']
  vivify_284:
    set $P920, $P919[$I916]
    unless_null $P920, vivify_285
    new $P920, "Undef"
  vivify_285:
    find_lex $P921, "$check"
    issame $I922, $P920, $P921
    unless $I922, if_914_end
.annotate 'line', 418
    new $P923, "Exception"
    set $P923['type'], .CONTROL_RETURN
    new $P924, "Integer"
    assign $P924, 1
    setattribute $P923, 'payload', $P924
    throw $P923
  if_914_end:
  loop925_next:
.annotate 'line', 415
    goto loop925_test
  loop925_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P927, exception, 'type'
    eq $P927, .CONTROL_LOOP_NEXT, loop925_next
    eq $P927, .CONTROL_LOOP_REDO, loop925_redo
  loop925_done:
    pop_eh 
.annotate 'line', 421
    new $P928, "Exception"
    set $P928['type'], .CONTROL_RETURN
    new $P929, "Integer"
    assign $P929, 0
    setattribute $P928, 'payload', $P929
    throw $P928
.annotate 'line', 413
    .return ()
  control_898:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P930, exception, "payload"
    .return ($P930)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("65_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_934
    .param pmc param_935
    .param pmc param_936
.annotate 'line', 424
    .const 'Sub' $P944 = "66_1298839204.312" 
    capture_lex $P944
    new $P933, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P933, control_932
    push_eh $P933
    .lex "self", param_934
    .lex "$obj", param_935
    .lex "$name", param_936
.annotate 'line', 425
    find_lex $P938, "self"
    get_global $P939, "$?CLASS"
    getattribute $P940, $P938, $P939, "@!mro"
    unless_null $P940, vivify_286
    $P940 = root_new ['parrot';'ResizablePMCArray']
  vivify_286:
    defined $I941, $P940
    unless $I941, for_undef_287
    iter $P937, $P940
    new $P962, 'ExceptionHandler'
    set_label $P962, loop961_handler
    $P962."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P962
  loop961_test:
    unless $P937, loop961_done
    shift $P942, $P937
  loop961_redo:
    .const 'Sub' $P944 = "66_1298839204.312" 
    capture_lex $P944
    $P944($P942)
  loop961_next:
    goto loop961_test
  loop961_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P963, exception, 'type'
    eq $P963, .CONTROL_LOOP_NEXT, loop961_next
    eq $P963, .CONTROL_LOOP_REDO, loop961_redo
  loop961_done:
    pop_eh 
  for_undef_287:
.annotate 'line', 432
    new $P964, "Exception"
    set $P964['type'], .CONTROL_RETURN
    new $P965, "Integer"
    assign $P965, 0
    setattribute $P964, 'payload', $P965
    throw $P964
.annotate 'line', 424
    .return ()
  control_932:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P966, exception, "payload"
    .return ($P966)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block943"  :anon :subid("66_1298839204.312") :outer("65_1298839204.312")
    .param pmc param_947
.annotate 'line', 426
    $P945 = root_new ['parrot';'Hash']
    .lex "%meths", $P945
.annotate 'line', 427
    new $P946, "Undef"
    .lex "$can", $P946
    .lex "$_", param_947
.annotate 'line', 426
    find_lex $P948, "$_"
    get_how $P949, $P948
    find_lex $P950, "$obj"
    $P951 = $P949."method_table"($P950)
    store_lex "%meths", $P951
.annotate 'line', 427
    find_lex $P952, "$name"
    find_lex $P953, "%meths"
    unless_null $P953, vivify_288
    $P953 = root_new ['parrot';'Hash']
  vivify_288:
    set $P954, $P953[$P952]
    unless_null $P954, vivify_289
    new $P954, "Undef"
  vivify_289:
    store_lex "$can", $P954
.annotate 'line', 428
    find_lex $P957, "$can"
    defined $I958, $P957
    if $I958, if_956
    new $P955, 'Integer'
    set $P955, $I958
    goto if_956_end
  if_956:
.annotate 'line', 429
    new $P959, "Exception"
    set $P959['type'], .CONTROL_RETURN
    find_lex $P960, "$can"
    setattribute $P959, 'payload', $P960
    throw $P959
  if_956_end:
.annotate 'line', 425
    .return ($P955)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("67_1298839204.312") :outer("15_1298839204.312")
    .param pmc param_970
    .param pmc param_971
    .param pmc param_972
.annotate 'line', 438
    .const 'Sub' $P980 = "68_1298839204.312" 
    capture_lex $P980
    new $P969, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P969, control_968
    push_eh $P969
    .lex "self", param_970
    .lex "$obj", param_971
    .lex "$name", param_972
.annotate 'line', 439
    find_lex $P974, "self"
    get_global $P975, "$?CLASS"
    getattribute $P976, $P974, $P975, "@!mro"
    unless_null $P976, vivify_290
    $P976 = root_new ['parrot';'ResizablePMCArray']
  vivify_290:
    defined $I977, $P976
    unless $I977, for_undef_291
    iter $P973, $P976
    new $P998, 'ExceptionHandler'
    set_label $P998, loop997_handler
    $P998."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P998
  loop997_test:
    unless $P973, loop997_done
    shift $P978, $P973
  loop997_redo:
    .const 'Sub' $P980 = "68_1298839204.312" 
    capture_lex $P980
    $P980($P978)
  loop997_next:
    goto loop997_test
  loop997_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P999, exception, 'type'
    eq $P999, .CONTROL_LOOP_NEXT, loop997_next
    eq $P999, .CONTROL_LOOP_REDO, loop997_redo
  loop997_done:
    pop_eh 
  for_undef_291:
.annotate 'line', 446
    null $P1000
.annotate 'line', 438
    .return ($P1000)
  control_968:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1001, exception, "payload"
    .return ($P1001)
.end


.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block979"  :anon :subid("68_1298839204.312") :outer("67_1298839204.312")
    .param pmc param_983
.annotate 'line', 440
    $P981 = root_new ['parrot';'Hash']
    .lex "%meths", $P981
.annotate 'line', 441
    new $P982, "Undef"
    .lex "$found", $P982
    .lex "$_", param_983
.annotate 'line', 440
    find_lex $P984, "$_"
    get_how $P985, $P984
    find_lex $P986, "$obj"
    $P987 = $P985."method_table"($P986)
    store_lex "%meths", $P987
.annotate 'line', 441
    find_lex $P988, "$name"
    find_lex $P989, "%meths"
    unless_null $P989, vivify_292
    $P989 = root_new ['parrot';'Hash']
  vivify_292:
    set $P990, $P989[$P988]
    unless_null $P990, vivify_293
    new $P990, "Undef"
  vivify_293:
    store_lex "$found", $P990
.annotate 'line', 442
    find_lex $P993, "$found"
    defined $I994, $P993
    if $I994, if_992
    new $P991, 'Integer'
    set $P991, $I994
    goto if_992_end
  if_992:
.annotate 'line', 443
    new $P995, "Exception"
    set $P995['type'], .CONTROL_RETURN
    find_lex $P996, "$found"
    setattribute $P995, 'payload', $P996
    throw $P995
  if_992_end:
.annotate 'line', 439
    .return ($P991)
.end


.namespace ["NQPNativeHOW"]
.sub "_block1095"  :subid("70_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 451
    .const 'Sub' $P1156 = "79_1298839204.312" 
    capture_lex $P1156
    .const 'Sub' $P1148 = "78_1298839204.312" 
    capture_lex $P1148
    .const 'Sub' $P1142 = "77_1298839204.312" 
    capture_lex $P1142
    .const 'Sub' $P1138 = "76_1298839204.312" 
    capture_lex $P1138
    .const 'Sub' $P1133 = "75_1298839204.312" 
    capture_lex $P1133
    .const 'Sub' $P1128 = "74_1298839204.312" 
    capture_lex $P1128
    .const 'Sub' $P1115 = "73_1298839204.312" 
    capture_lex $P1115
    .const 'Sub' $P1108 = "72_1298839204.312" 
    capture_lex $P1108
    .const 'Sub' $P1098 = "71_1298839204.312" 
    capture_lex $P1098
    get_global $P1097, "$?CLASS"
.annotate 'line', 489
    .const 'Sub' $P1148 = "78_1298839204.312" 
    newclosure $P1154, $P1148
.annotate 'line', 451
    .return ($P1154)
.end


.namespace ["NQPNativeHOW"]
.sub "" :load :init :subid("post294") :outer("70_1298839204.312")
.annotate 'line', 451
    get_hll_global $P1096, ["NQPNativeHOW"], "_block1095" 
    .local pmc block
    set block, $P1096
    .const 'Sub' $P1156 = "79_1298839204.312" 
    capture_lex $P1156
    $P1156()
.end


.namespace ["NQPNativeHOW"]
.sub "_block1155"  :anon :subid("79_1298839204.312") :outer("70_1298839204.312")
.annotate 'line', 451
    get_hll_global $P1157, "KnowHOW"
    $P1158 = $P1157."new_type"("NQPNativeHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1158
    set_hll_global "NQPNativeHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1159, type_obj
    get_hll_global $P1160, "KnowHOWAttribute"
    $P1161 = $P1160."new"("$!name" :named("name"))
    $P1159."add_attribute"(type_obj, $P1161)
    get_how $P1162, type_obj
    get_hll_global $P1163, "KnowHOWAttribute"
    $P1164 = $P1163."new"("$!composed" :named("name"))
    $P1162."add_attribute"(type_obj, $P1164)
    get_how $P1165, type_obj
    .const 'Sub' $P1166 = "71_1298839204.312" 
    $P1165."add_method"(type_obj, "new", $P1166)
    get_how $P1167, type_obj
    .const 'Sub' $P1168 = "72_1298839204.312" 
    $P1167."add_method"(type_obj, "BUILD", $P1168)
    get_how $P1169, type_obj
    .const 'Sub' $P1170 = "73_1298839204.312" 
    $P1169."add_method"(type_obj, "new_type", $P1170)
    get_how $P1171, type_obj
    .const 'Sub' $P1172 = "74_1298839204.312" 
    $P1171."add_method"(type_obj, "add_method", $P1172)
    get_how $P1173, type_obj
    .const 'Sub' $P1174 = "75_1298839204.312" 
    $P1173."add_method"(type_obj, "add_multi_method", $P1174)
    get_how $P1175, type_obj
    .const 'Sub' $P1176 = "76_1298839204.312" 
    $P1175."add_method"(type_obj, "add_attribute", $P1176)
    get_how $P1177, type_obj
    .const 'Sub' $P1178 = "77_1298839204.312" 
    $P1177."add_method"(type_obj, "compose", $P1178)
    get_how $P1179, type_obj
    .const 'Sub' $P1180 = "78_1298839204.312" 
    $P1179."add_method"(type_obj, "name", $P1180)
    get_how $P1181, type_obj
    $P1182 = $P1181."compose"(type_obj)
    .return ($P1182)
.end


.namespace ["NQPNativeHOW"]
.sub "new"  :subid("71_1298839204.312") :outer("70_1298839204.312")
    .param pmc param_1099
    .param pmc param_1100 :optional :named("name")
    .param int has_param_1100 :opt_flag
.annotate 'line', 455
    .lex "self", param_1099
    if has_param_1100, optparam_295
    new $P1101, "Undef"
    set param_1100, $P1101
  optparam_295:
    .lex "$name", param_1100
.annotate 'line', 456
    new $P1102, "Undef"
    .lex "$obj", $P1102
    find_lex $P1103, "self"
    repr_instance_of $P1104, $P1103
    store_lex "$obj", $P1104
.annotate 'line', 457
    find_lex $P1105, "$obj"
    find_lex $P1106, "$name"
    $P1105."BUILD"($P1106 :named("name"))
    find_lex $P1107, "$obj"
.annotate 'line', 455
    .return ($P1107)
.end


.namespace ["NQPNativeHOW"]
.sub "BUILD"  :subid("72_1298839204.312") :outer("70_1298839204.312")
    .param pmc param_1109
    .param pmc param_1110 :optional :named("name")
    .param int has_param_1110 :opt_flag
.annotate 'line', 461
    .lex "self", param_1109
    if has_param_1110, optparam_296
    new $P1111, "Undef"
    set param_1110, $P1111
  optparam_296:
    .lex "$name", param_1110
.annotate 'line', 462
    find_lex $P1112, "$name"
    find_lex $P1113, "self"
    get_global $P1114, "$?CLASS"
    setattribute $P1113, $P1114, "$!name", $P1112
.annotate 'line', 461
    .return ($P1112)
.end


.namespace ["NQPNativeHOW"]
.sub "new_type"  :subid("73_1298839204.312") :outer("70_1298839204.312")
    .param pmc param_1116
    .param pmc param_1119 :named("repr")
    .param pmc param_1117 :optional :named("name")
    .param int has_param_1117 :opt_flag
.annotate 'line', 468
    .lex "self", param_1116
    if has_param_1117, optparam_297
    new $P1118, "String"
    assign $P1118, "<anon>"
    set param_1117, $P1118
  optparam_297:
    .lex "$name", param_1117
    .lex "$repr", param_1119
.annotate 'line', 469
    new $P1120, "Undef"
    .lex "$metaclass", $P1120
    find_lex $P1121, "self"
    find_lex $P1122, "$name"
    $P1123 = $P1121."new"($P1122 :named("name"))
    store_lex "$metaclass", $P1123
.annotate 'line', 470
    find_lex $P1124, "$metaclass"
    find_lex $P1125, "$repr"
    set $S1126, $P1125
    repr_type_object_for $P1127, $P1124, $S1126
.annotate 'line', 468
    .return ($P1127)
.end


.namespace ["NQPNativeHOW"]
.sub "add_method"  :subid("74_1298839204.312") :outer("70_1298839204.312")
    .param pmc param_1129
    .param pmc param_1130
    .param pmc param_1131
    .param pmc param_1132
.annotate 'line', 473
    .lex "self", param_1129
    .lex "$obj", param_1130
    .lex "$name", param_1131
    .lex "$code_obj", param_1132
.annotate 'line', 474
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 473
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_multi_method"  :subid("75_1298839204.312") :outer("70_1298839204.312")
    .param pmc param_1134
    .param pmc param_1135
    .param pmc param_1136
    .param pmc param_1137
.annotate 'line', 477
    .lex "self", param_1134
    .lex "$obj", param_1135
    .lex "$name", param_1136
    .lex "$code_obj", param_1137
.annotate 'line', 478
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 477
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "add_attribute"  :subid("76_1298839204.312") :outer("70_1298839204.312")
    .param pmc param_1139
    .param pmc param_1140
    .param pmc param_1141
.annotate 'line', 481
    .lex "self", param_1139
    .lex "$obj", param_1140
    .lex "$meta_attr", param_1141
.annotate 'line', 482
    die "Native types may not have attributes"
.annotate 'line', 481
    .return ()
.end


.namespace ["NQPNativeHOW"]
.sub "compose"  :subid("77_1298839204.312") :outer("70_1298839204.312")
    .param pmc param_1143
    .param pmc param_1144
.annotate 'line', 485
    .lex "self", param_1143
    .lex "$obj", param_1144
.annotate 'line', 486
    new $P1145, "Integer"
    assign $P1145, 1
    find_lex $P1146, "self"
    get_global $P1147, "$?CLASS"
    setattribute $P1146, $P1147, "$!composed", $P1145
.annotate 'line', 485
    .return ($P1145)
.end


.namespace ["NQPNativeHOW"]
.sub "name"  :subid("78_1298839204.312") :outer("70_1298839204.312")
    .param pmc param_1149
    .param pmc param_1150
.annotate 'line', 489
    .lex "self", param_1149
    .lex "$obj", param_1150
    find_lex $P1151, "self"
    get_global $P1152, "$?CLASS"
    getattribute $P1153, $P1151, $P1152, "$!name"
    unless_null $P1153, vivify_298
    new $P1153, "Undef"
  vivify_298:
    .return ($P1153)
.end


.namespace ["NQPAttribute"]
.sub "_block1183"  :subid("80_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 495
    .const 'Sub' $P1243 = "86_1298839204.312" 
    capture_lex $P1243
    .const 'Sub' $P1232 = "85_1298839204.312" 
    capture_lex $P1232
    .const 'Sub' $P1223 = "84_1298839204.312" 
    capture_lex $P1223
    .const 'Sub' $P1218 = "83_1298839204.312" 
    capture_lex $P1218
    .const 'Sub' $P1201 = "82_1298839204.312" 
    capture_lex $P1201
    .const 'Sub' $P1186 = "81_1298839204.312" 
    capture_lex $P1186
    get_global $P1185, "$?CLASS"
.annotate 'line', 520
    .const 'Sub' $P1232 = "85_1298839204.312" 
    newclosure $P1241, $P1232
.annotate 'line', 495
    .return ($P1241)
.end


.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post299") :outer("80_1298839204.312")
.annotate 'line', 495
    get_hll_global $P1184, ["NQPAttribute"], "_block1183" 
    .local pmc block
    set block, $P1184
    .const 'Sub' $P1243 = "86_1298839204.312" 
    capture_lex $P1243
    $P1243()
.end


.namespace ["NQPAttribute"]
.sub "_block1242"  :anon :subid("86_1298839204.312") :outer("80_1298839204.312")
.annotate 'line', 495
    get_hll_global $P1244, "KnowHOW"
    $P1245 = $P1244."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P1245
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1246, type_obj
    get_hll_global $P1247, "KnowHOWAttribute"
    $P1248 = $P1247."new"("$!name" :named("name"))
    $P1246."add_attribute"(type_obj, $P1248)
    get_how $P1249, type_obj
    get_hll_global $P1250, "KnowHOWAttribute"
    $P1251 = $P1250."new"("$!type" :named("name"))
    $P1249."add_attribute"(type_obj, $P1251)
    get_how $P1252, type_obj
    get_hll_global $P1253, "KnowHOWAttribute"
    $P1254 = $P1253."new"("$!box_target" :named("name"))
    $P1252."add_attribute"(type_obj, $P1254)
    get_how $P1255, type_obj
    .const 'Sub' $P1256 = "81_1298839204.312" 
    $P1255."add_method"(type_obj, "new", $P1256)
    get_how $P1257, type_obj
    .const 'Sub' $P1258 = "82_1298839204.312" 
    $P1257."add_method"(type_obj, "BUILD", $P1258)
    get_how $P1259, type_obj
    .const 'Sub' $P1260 = "83_1298839204.312" 
    $P1259."add_method"(type_obj, "name", $P1260)
    get_how $P1261, type_obj
    .const 'Sub' $P1262 = "84_1298839204.312" 
    $P1261."add_method"(type_obj, "type", $P1262)
    get_how $P1263, type_obj
    .const 'Sub' $P1264 = "85_1298839204.312" 
    $P1263."add_method"(type_obj, "box_target", $P1264)
    get_how $P1265, type_obj
    $P1266 = $P1265."compose"(type_obj)
    .return ($P1266)
.end


.namespace ["NQPAttribute"]
.sub "new"  :subid("81_1298839204.312") :outer("80_1298839204.312")
    .param pmc param_1187
    .param pmc param_1188 :named("name")
    .param pmc param_1189 :optional :named("type")
    .param int has_param_1189 :opt_flag
    .param pmc param_1191 :optional :named("box_target")
    .param int has_param_1191 :opt_flag
.annotate 'line', 500
    .lex "self", param_1187
    .lex "$name", param_1188
    if has_param_1189, optparam_300
    new $P1190, "Undef"
    set param_1189, $P1190
  optparam_300:
    .lex "$type", param_1189
    if has_param_1191, optparam_301
    new $P1192, "Undef"
    set param_1191, $P1192
  optparam_301:
    .lex "$box_target", param_1191
.annotate 'line', 501
    new $P1193, "Undef"
    .lex "$attr", $P1193
    find_lex $P1194, "self"
    repr_instance_of $P1195, $P1194
    store_lex "$attr", $P1195
.annotate 'line', 502
    find_lex $P1196, "$attr"
    find_lex $P1197, "$name"
    find_lex $P1198, "$type"
    find_lex $P1199, "$box_target"
    $P1196."BUILD"($P1197 :named("name"), $P1198 :named("type"), $P1199 :named("box_target"))
    find_lex $P1200, "$attr"
.annotate 'line', 500
    .return ($P1200)
.end


.namespace ["NQPAttribute"]
.sub "BUILD"  :subid("82_1298839204.312") :outer("80_1298839204.312")
    .param pmc param_1202
    .param pmc param_1203 :optional :named("name")
    .param int has_param_1203 :opt_flag
    .param pmc param_1205 :optional :named("type")
    .param int has_param_1205 :opt_flag
    .param pmc param_1207 :optional :named("box_target")
    .param int has_param_1207 :opt_flag
.annotate 'line', 506
    .lex "self", param_1202
    if has_param_1203, optparam_302
    new $P1204, "Undef"
    set param_1203, $P1204
  optparam_302:
    .lex "$name", param_1203
    if has_param_1205, optparam_303
    new $P1206, "Undef"
    set param_1205, $P1206
  optparam_303:
    .lex "$type", param_1205
    if has_param_1207, optparam_304
    new $P1208, "Undef"
    set param_1207, $P1208
  optparam_304:
    .lex "$box_target", param_1207
.annotate 'line', 507
    find_lex $P1209, "$name"
    find_lex $P1210, "self"
    get_global $P1211, "$?CLASS"
    setattribute $P1210, $P1211, "$!name", $P1209
.annotate 'line', 508
    find_lex $P1212, "$type"
    find_lex $P1213, "self"
    get_global $P1214, "$?CLASS"
    setattribute $P1213, $P1214, "$!type", $P1212
.annotate 'line', 509
    find_lex $P1215, "$box_target"
    find_lex $P1216, "self"
    get_global $P1217, "$?CLASS"
    setattribute $P1216, $P1217, "$!box_target", $P1215
.annotate 'line', 506
    .return ($P1215)
.end


.namespace ["NQPAttribute"]
.sub "name"  :subid("83_1298839204.312") :outer("80_1298839204.312")
    .param pmc param_1219
.annotate 'line', 512
    .lex "self", param_1219
    find_lex $P1220, "self"
    get_global $P1221, "$?CLASS"
    getattribute $P1222, $P1220, $P1221, "$!name"
    unless_null $P1222, vivify_305
    new $P1222, "Undef"
  vivify_305:
    .return ($P1222)
.end


.namespace ["NQPAttribute"]
.sub "type"  :subid("84_1298839204.312") :outer("80_1298839204.312")
    .param pmc param_1224
.annotate 'line', 516
    .lex "self", param_1224
.annotate 'line', 517
    find_lex $P1226, "self"
    get_global $P1227, "$?CLASS"
    getattribute $P1228, $P1226, $P1227, "$!type"
    unless_null $P1228, vivify_306
    new $P1228, "Undef"
  vivify_306:
    set $P1225, $P1228
    defined $I1230, $P1225
    if $I1230, default_1229
    null $P1231
    set $P1225, $P1231
  default_1229:
.annotate 'line', 516
    .return ($P1225)
.end


.namespace ["NQPAttribute"]
.sub "box_target"  :subid("85_1298839204.312") :outer("80_1298839204.312")
    .param pmc param_1233
.annotate 'line', 520
    .lex "self", param_1233
.annotate 'line', 521
    find_lex $P1236, "self"
    get_global $P1237, "$?CLASS"
    getattribute $P1238, $P1236, $P1237, "$!box_target"
    unless_null $P1238, vivify_307
    new $P1238, "Undef"
  vivify_307:
    if $P1238, if_1235
    new $P1240, "Integer"
    assign $P1240, 0
    set $P1234, $P1240
    goto if_1235_end
  if_1235:
    new $P1239, "Integer"
    assign $P1239, 1
    set $P1234, $P1239
  if_1235_end:
.annotate 'line', 520
    .return ($P1234)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1267"  :subid("87_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 528
    .const 'Sub' $P1523 = "108_1298839204.312" 
    capture_lex $P1523
    .const 'Sub' $P1515 = "107_1298839204.312" 
    capture_lex $P1515
    .const 'Sub' $P1509 = "106_1298839204.312" 
    capture_lex $P1509
    .const 'Sub' $P1487 = "104_1298839204.312" 
    capture_lex $P1487
    .const 'Sub' $P1481 = "103_1298839204.312" 
    capture_lex $P1481
    .const 'Sub' $P1475 = "102_1298839204.312" 
    capture_lex $P1475
    .const 'Sub' $P1469 = "101_1298839204.312" 
    capture_lex $P1469
    .const 'Sub' $P1447 = "99_1298839204.312" 
    capture_lex $P1447
    .const 'Sub' $P1398 = "97_1298839204.312" 
    capture_lex $P1398
    .const 'Sub' $P1385 = "96_1298839204.312" 
    capture_lex $P1385
    .const 'Sub' $P1372 = "95_1298839204.312" 
    capture_lex $P1372
    .const 'Sub' $P1368 = "94_1298839204.312" 
    capture_lex $P1368
    .const 'Sub' $P1347 = "93_1298839204.312" 
    capture_lex $P1347
    .const 'Sub' $P1326 = "92_1298839204.312" 
    capture_lex $P1326
    .const 'Sub' $P1307 = "91_1298839204.312" 
    capture_lex $P1307
    .const 'Sub' $P1291 = "90_1298839204.312" 
    capture_lex $P1291
    .const 'Sub' $P1281 = "89_1298839204.312" 
    capture_lex $P1281
    .const 'Sub' $P1270 = "88_1298839204.312" 
    capture_lex $P1270
    get_global $P1269, "$?CLASS"
.annotate 'line', 667
    .const 'Sub' $P1515 = "107_1298839204.312" 
    newclosure $P1521, $P1515
.annotate 'line', 528
    .return ($P1521)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "" :load :init :subid("post308") :outer("87_1298839204.312")
.annotate 'line', 528
    get_hll_global $P1268, ["NQPConcreteRoleHOW"], "_block1267" 
    .local pmc block
    set block, $P1268
    .const 'Sub' $P1523 = "108_1298839204.312" 
    capture_lex $P1523
    $P1523()
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1522"  :anon :subid("108_1298839204.312") :outer("87_1298839204.312")
.annotate 'line', 528
    get_hll_global $P1524, "KnowHOW"
    $P1525 = $P1524."new_type"("NQPConcreteRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1525
    set_hll_global "NQPConcreteRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1526, type_obj
    get_hll_global $P1527, "KnowHOWAttribute"
    $P1528 = $P1527."new"("$!name" :named("name"))
    $P1526."add_attribute"(type_obj, $P1528)
    get_how $P1529, type_obj
    get_hll_global $P1530, "KnowHOWAttribute"
    $P1531 = $P1530."new"("$!instance_of" :named("name"))
    $P1529."add_attribute"(type_obj, $P1531)
    get_how $P1532, type_obj
    get_hll_global $P1533, "KnowHOWAttribute"
    $P1534 = $P1533."new"("%!attributes" :named("name"))
    $P1532."add_attribute"(type_obj, $P1534)
    get_how $P1535, type_obj
    get_hll_global $P1536, "KnowHOWAttribute"
    $P1537 = $P1536."new"("%!methods" :named("name"))
    $P1535."add_attribute"(type_obj, $P1537)
    get_how $P1538, type_obj
    get_hll_global $P1539, "KnowHOWAttribute"
    $P1540 = $P1539."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1538."add_attribute"(type_obj, $P1540)
    get_how $P1541, type_obj
    get_hll_global $P1542, "KnowHOWAttribute"
    $P1543 = $P1542."new"("@!collisions" :named("name"))
    $P1541."add_attribute"(type_obj, $P1543)
    get_how $P1544, type_obj
    get_hll_global $P1545, "KnowHOWAttribute"
    $P1546 = $P1545."new"("@!roles" :named("name"))
    $P1544."add_attribute"(type_obj, $P1546)
    get_how $P1547, type_obj
    get_hll_global $P1548, "KnowHOWAttribute"
    $P1549 = $P1548."new"("@!done" :named("name"))
    $P1547."add_attribute"(type_obj, $P1549)
    get_how $P1550, type_obj
    get_hll_global $P1551, "KnowHOWAttribute"
    $P1552 = $P1551."new"("$!composed" :named("name"))
    $P1550."add_attribute"(type_obj, $P1552)
    get_how $P1553, type_obj
    .const 'Sub' $P1554 = "88_1298839204.312" 
    $P1553."add_method"(type_obj, "new", $P1554)
    get_how $P1555, type_obj
    .const 'Sub' $P1556 = "89_1298839204.312" 
    $P1555."add_method"(type_obj, "BUILD", $P1556)
    get_how $P1557, type_obj
    .const 'Sub' $P1558 = "90_1298839204.312" 
    $P1557."add_method"(type_obj, "new_type", $P1558)
    get_how $P1559, type_obj
    .const 'Sub' $P1560 = "91_1298839204.312" 
    $P1559."add_method"(type_obj, "add_method", $P1560)
    get_how $P1561, type_obj
    .const 'Sub' $P1562 = "92_1298839204.312" 
    $P1561."add_method"(type_obj, "add_multi_method", $P1562)
    get_how $P1563, type_obj
    .const 'Sub' $P1564 = "93_1298839204.312" 
    $P1563."add_method"(type_obj, "add_attribute", $P1564)
    get_how $P1565, type_obj
    .const 'Sub' $P1566 = "94_1298839204.312" 
    $P1565."add_method"(type_obj, "add_parent", $P1566)
    get_how $P1567, type_obj
    .const 'Sub' $P1568 = "95_1298839204.312" 
    $P1567."add_method"(type_obj, "add_role", $P1568)
    get_how $P1569, type_obj
    .const 'Sub' $P1570 = "96_1298839204.312" 
    $P1569."add_method"(type_obj, "add_collision", $P1570)
    get_how $P1571, type_obj
    .const 'Sub' $P1572 = "97_1298839204.312" 
    $P1571."add_method"(type_obj, "compose", $P1572)
    get_how $P1573, type_obj
    .const 'Sub' $P1574 = "99_1298839204.312" 
    $P1573."add_method"(type_obj, "methods", $P1574)
    get_how $P1575, type_obj
    .const 'Sub' $P1576 = "101_1298839204.312" 
    $P1575."add_method"(type_obj, "method_table", $P1576)
    get_how $P1577, type_obj
    .const 'Sub' $P1578 = "102_1298839204.312" 
    $P1577."add_method"(type_obj, "collisions", $P1578)
    get_how $P1579, type_obj
    .const 'Sub' $P1580 = "103_1298839204.312" 
    $P1579."add_method"(type_obj, "name", $P1580)
    get_how $P1581, type_obj
    .const 'Sub' $P1582 = "104_1298839204.312" 
    $P1581."add_method"(type_obj, "attributes", $P1582)
    get_how $P1583, type_obj
    .const 'Sub' $P1584 = "106_1298839204.312" 
    $P1583."add_method"(type_obj, "roles", $P1584)
    get_how $P1585, type_obj
    .const 'Sub' $P1586 = "107_1298839204.312" 
    $P1585."add_method"(type_obj, "instance_of", $P1586)
    get_how $P1587, type_obj
    $P1588 = $P1587."compose"(type_obj)
    .return ($P1588)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "new"  :subid("88_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1271
    .param pmc param_1272 :named("name")
    .param pmc param_1273 :named("instance_of")
.annotate 'line', 560
    .lex "self", param_1271
    .lex "$name", param_1272
    .lex "$instance_of", param_1273
.annotate 'line', 561
    new $P1274, "Undef"
    .lex "$obj", $P1274
    find_lex $P1275, "self"
    repr_instance_of $P1276, $P1275
    store_lex "$obj", $P1276
.annotate 'line', 562
    find_lex $P1277, "$obj"
    find_lex $P1278, "$name"
    find_lex $P1279, "$instance_of"
    $P1277."BUILD"($P1278 :named("name"), $P1279 :named("instance_of"))
    find_lex $P1280, "$obj"
.annotate 'line', 560
    .return ($P1280)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "BUILD"  :subid("89_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1282
    .param pmc param_1283 :named("name")
    .param pmc param_1284 :named("instance_of")
.annotate 'line', 566
    .lex "self", param_1282
    .lex "$name", param_1283
    .lex "$instance_of", param_1284
.annotate 'line', 567
    find_lex $P1285, "$name"
    find_lex $P1286, "self"
    get_global $P1287, "$?CLASS"
    setattribute $P1286, $P1287, "$!name", $P1285
.annotate 'line', 568
    find_lex $P1288, "$instance_of"
    find_lex $P1289, "self"
    get_global $P1290, "$?CLASS"
    setattribute $P1289, $P1290, "$!instance_of", $P1288
.annotate 'line', 566
    .return ($P1288)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "new_type"  :subid("90_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1292
    .param pmc param_1297 :named("instance_of")
    .param pmc param_1293 :optional :named("name")
    .param int has_param_1293 :opt_flag
    .param pmc param_1295 :optional :named("repr")
    .param int has_param_1295 :opt_flag
.annotate 'line', 573
    .lex "self", param_1292
    if has_param_1293, optparam_309
    new $P1294, "String"
    assign $P1294, "<anon>"
    set param_1293, $P1294
  optparam_309:
    .lex "$name", param_1293
    if has_param_1295, optparam_310
    new $P1296, "String"
    assign $P1296, "P6opaque"
    set param_1295, $P1296
  optparam_310:
    .lex "$repr", param_1295
    .lex "$instance_of", param_1297
.annotate 'line', 574
    new $P1298, "Undef"
    .lex "$metarole", $P1298
    find_lex $P1299, "self"
    find_lex $P1300, "$name"
    find_lex $P1301, "$instance_of"
    $P1302 = $P1299."new"($P1300 :named("name"), $P1301 :named("instance_of"))
    store_lex "$metarole", $P1302
.annotate 'line', 575
    find_lex $P1303, "$metarole"
    find_lex $P1304, "$repr"
    set $S1305, $P1304
    repr_type_object_for $P1306, $P1303, $S1305
.annotate 'line', 573
    .return ($P1306)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_method"  :subid("91_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1308
    .param pmc param_1309
    .param pmc param_1310
    .param pmc param_1311
.annotate 'line', 578
    .lex "self", param_1308
    .lex "$obj", param_1309
    .lex "$name", param_1310
    .lex "$code_obj", param_1311
.annotate 'line', 579
    find_lex $P1313, "$name"
    find_lex $P1314, "self"
    get_global $P1315, "$?CLASS"
    getattribute $P1316, $P1314, $P1315, "%!methods"
    unless_null $P1316, vivify_311
    $P1316 = root_new ['parrot';'Hash']
  vivify_311:
    set $P1317, $P1316[$P1313]
    unless_null $P1317, vivify_312
    new $P1317, "Undef"
  vivify_312:
    unless $P1317, if_1312_end
.annotate 'line', 580
    new $P1318, "String"
    assign $P1318, "This role already has a method named "
    find_lex $P1319, "$name"
    concat $P1320, $P1318, $P1319
    die $P1320
  if_1312_end:
.annotate 'line', 582
    find_lex $P1321, "$code_obj"
    find_lex $P1322, "$name"
    find_lex $P1323, "self"
    get_global $P1324, "$?CLASS"
    getattribute $P1325, $P1323, $P1324, "%!methods"
    unless_null $P1325, vivify_313
    $P1325 = root_new ['parrot';'Hash']
    setattribute $P1323, $P1324, "%!methods", $P1325
  vivify_313:
    set $P1325[$P1322], $P1321
.annotate 'line', 578
    .return ($P1321)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_multi_method"  :subid("92_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1327
    .param pmc param_1328
    .param pmc param_1329
    .param pmc param_1330
.annotate 'line', 585
    .lex "self", param_1327
    .lex "$obj", param_1328
    .lex "$name", param_1329
    .lex "$code_obj", param_1330
.annotate 'line', 586
    $P1331 = root_new ['parrot';'Hash']
    .lex "%todo", $P1331
.annotate 'line', 585
    find_lex $P1332, "%todo"
.annotate 'line', 587
    find_lex $P1333, "$name"
    find_lex $P1334, "%todo"
    unless_null $P1334, vivify_314
    $P1334 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1334
  vivify_314:
    set $P1334["name"], $P1333
.annotate 'line', 588
    find_lex $P1335, "$code_obj"
    find_lex $P1336, "%todo"
    unless_null $P1336, vivify_315
    $P1336 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1336
  vivify_315:
    set $P1336["code"], $P1335
.annotate 'line', 589
    find_lex $P1337, "%todo"
    find_lex $P1338, "self"
    get_global $P1339, "$?CLASS"
    getattribute $P1340, $P1338, $P1339, "@!multi_methods_to_incorporate"
    unless_null $P1340, vivify_316
    $P1340 = root_new ['parrot';'ResizablePMCArray']
  vivify_316:
    set $N1341, $P1340
    set $I1342, $N1341
    find_lex $P1343, "self"
    get_global $P1344, "$?CLASS"
    getattribute $P1345, $P1343, $P1344, "@!multi_methods_to_incorporate"
    unless_null $P1345, vivify_317
    $P1345 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1343, $P1344, "@!multi_methods_to_incorporate", $P1345
  vivify_317:
    set $P1345[$I1342], $P1337
    find_lex $P1346, "$code_obj"
.annotate 'line', 585
    .return ($P1346)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_attribute"  :subid("93_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1348
    .param pmc param_1349
    .param pmc param_1350
.annotate 'line', 593
    .lex "self", param_1348
    .lex "$obj", param_1349
    .lex "$meta_attr", param_1350
.annotate 'line', 594
    new $P1351, "Undef"
    .lex "$name", $P1351
    find_lex $P1352, "$meta_attr"
    $P1353 = $P1352."name"()
    store_lex "$name", $P1353
.annotate 'line', 595
    find_lex $P1355, "$name"
    find_lex $P1356, "self"
    get_global $P1357, "$?CLASS"
    getattribute $P1358, $P1356, $P1357, "%!attributes"
    unless_null $P1358, vivify_318
    $P1358 = root_new ['parrot';'Hash']
  vivify_318:
    set $P1359, $P1358[$P1355]
    unless_null $P1359, vivify_319
    new $P1359, "Undef"
  vivify_319:
    unless $P1359, if_1354_end
.annotate 'line', 596
    new $P1360, "String"
    assign $P1360, "This role already has an attribute named "
    find_lex $P1361, "$name"
    concat $P1362, $P1360, $P1361
    die $P1362
  if_1354_end:
.annotate 'line', 598
    find_lex $P1363, "$meta_attr"
    find_lex $P1364, "$name"
    find_lex $P1365, "self"
    get_global $P1366, "$?CLASS"
    getattribute $P1367, $P1365, $P1366, "%!attributes"
    unless_null $P1367, vivify_320
    $P1367 = root_new ['parrot';'Hash']
    setattribute $P1365, $P1366, "%!attributes", $P1367
  vivify_320:
    set $P1367[$P1364], $P1363
.annotate 'line', 593
    .return ($P1363)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_parent"  :subid("94_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1369
    .param pmc param_1370
    .param pmc param_1371
.annotate 'line', 601
    .lex "self", param_1369
    .lex "$obj", param_1370
    .lex "$parent", param_1371
.annotate 'line', 602
    die "A role cannot inherit from a class in NQP"
.annotate 'line', 601
    .return ()
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_role"  :subid("95_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1373
    .param pmc param_1374
    .param pmc param_1375
.annotate 'line', 605
    .lex "self", param_1373
    .lex "$obj", param_1374
    .lex "$role", param_1375
.annotate 'line', 606
    find_lex $P1376, "$role"
    find_lex $P1377, "self"
    get_global $P1378, "$?CLASS"
    getattribute $P1379, $P1377, $P1378, "@!roles"
    unless_null $P1379, vivify_321
    $P1379 = root_new ['parrot';'ResizablePMCArray']
  vivify_321:
    set $N1380, $P1379
    set $I1381, $N1380
    find_lex $P1382, "self"
    get_global $P1383, "$?CLASS"
    getattribute $P1384, $P1382, $P1383, "@!roles"
    unless_null $P1384, vivify_322
    $P1384 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1382, $P1383, "@!roles", $P1384
  vivify_322:
    set $P1384[$I1381], $P1376
.annotate 'line', 605
    .return ($P1376)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "add_collision"  :subid("96_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1386
    .param pmc param_1387
    .param pmc param_1388
.annotate 'line', 609
    .lex "self", param_1386
    .lex "$obj", param_1387
    .lex "$colliding_name", param_1388
.annotate 'line', 610
    find_lex $P1389, "$colliding_name"
    find_lex $P1390, "self"
    get_global $P1391, "$?CLASS"
    getattribute $P1392, $P1390, $P1391, "@!collisions"
    unless_null $P1392, vivify_323
    $P1392 = root_new ['parrot';'ResizablePMCArray']
  vivify_323:
    set $N1393, $P1392
    set $I1394, $N1393
    find_lex $P1395, "self"
    get_global $P1396, "$?CLASS"
    getattribute $P1397, $P1395, $P1396, "@!collisions"
    unless_null $P1397, vivify_324
    $P1397 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1395, $P1396, "@!collisions", $P1397
  vivify_324:
    set $P1397[$I1394], $P1389
.annotate 'line', 609
    .return ($P1389)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("97_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1399
    .param pmc param_1400
.annotate 'line', 614
    .const 'Sub' $P1412 = "98_1298839204.312" 
    capture_lex $P1412
    .lex "self", param_1399
    .lex "$obj", param_1400
.annotate 'line', 617
    find_lex $P1402, "self"
    get_global $P1403, "$?CLASS"
    getattribute $P1404, $P1402, $P1403, "@!roles"
    unless_null $P1404, vivify_325
    $P1404 = root_new ['parrot';'ResizablePMCArray']
  vivify_325:
    unless $P1404, if_1401_end
.annotate 'line', 618
    find_lex $P1406, "self"
    get_global $P1407, "$?CLASS"
    getattribute $P1408, $P1406, $P1407, "@!roles"
    unless_null $P1408, vivify_326
    $P1408 = root_new ['parrot';'ResizablePMCArray']
  vivify_326:
    defined $I1409, $P1408
    unless $I1409, for_undef_327
    iter $P1405, $P1408
    new $P1436, 'ExceptionHandler'
    set_label $P1436, loop1435_handler
    $P1436."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1436
  loop1435_test:
    unless $P1405, loop1435_done
    shift $P1410, $P1405
  loop1435_redo:
    .const 'Sub' $P1412 = "98_1298839204.312" 
    capture_lex $P1412
    $P1412($P1410)
  loop1435_next:
    goto loop1435_test
  loop1435_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1437, exception, 'type'
    eq $P1437, .CONTROL_LOOP_NEXT, loop1435_next
    eq $P1437, .CONTROL_LOOP_REDO, loop1435_redo
  loop1435_done:
    pop_eh 
  for_undef_327:
.annotate 'line', 622
    get_hll_global $P1438, "RoleToRoleApplier"
    find_lex $P1439, "$obj"
    find_lex $P1440, "self"
    get_global $P1441, "$?CLASS"
    getattribute $P1442, $P1440, $P1441, "@!roles"
    unless_null $P1442, vivify_332
    $P1442 = root_new ['parrot';'ResizablePMCArray']
  vivify_332:
    $P1438."apply"($P1439, $P1442)
  if_1401_end:
.annotate 'line', 626
    new $P1443, "Integer"
    assign $P1443, 1
    find_lex $P1444, "self"
    get_global $P1445, "$?CLASS"
    setattribute $P1444, $P1445, "$!composed", $P1443
    find_lex $P1446, "$obj"
.annotate 'line', 614
    .return ($P1446)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1411"  :anon :subid("98_1298839204.312") :outer("97_1298839204.312")
    .param pmc param_1413
.annotate 'line', 618
    .lex "$_", param_1413
.annotate 'line', 619
    find_lex $P1414, "$_"
    find_lex $P1415, "self"
    get_global $P1416, "$?CLASS"
    getattribute $P1417, $P1415, $P1416, "@!done"
    unless_null $P1417, vivify_328
    $P1417 = root_new ['parrot';'ResizablePMCArray']
  vivify_328:
    set $N1418, $P1417
    set $I1419, $N1418
    find_lex $P1420, "self"
    get_global $P1421, "$?CLASS"
    getattribute $P1422, $P1420, $P1421, "@!done"
    unless_null $P1422, vivify_329
    $P1422 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1420, $P1421, "@!done", $P1422
  vivify_329:
    set $P1422[$I1419], $P1414
.annotate 'line', 620
    find_lex $P1423, "$_"
    get_how $P1424, $P1423
    find_lex $P1425, "$_"
    $P1426 = $P1424."instance_of"($P1425)
    find_lex $P1427, "self"
    get_global $P1428, "$?CLASS"
    getattribute $P1429, $P1427, $P1428, "@!done"
    unless_null $P1429, vivify_330
    $P1429 = root_new ['parrot';'ResizablePMCArray']
  vivify_330:
    set $N1430, $P1429
    set $I1431, $N1430
    find_lex $P1432, "self"
    get_global $P1433, "$?CLASS"
    getattribute $P1434, $P1432, $P1433, "@!done"
    unless_null $P1434, vivify_331
    $P1434 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1432, $P1433, "@!done", $P1434
  vivify_331:
    set $P1434[$I1431], $P1426
.annotate 'line', 618
    .return ($P1426)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("99_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1448
    .param pmc param_1449
.annotate 'line', 635
    .const 'Sub' $P1459 = "100_1298839204.312" 
    capture_lex $P1459
    .lex "self", param_1448
    .lex "$obj", param_1449
.annotate 'line', 636
    $P1450 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1450
.annotate 'line', 635
    find_lex $P1451, "@meths"
.annotate 'line', 637
    find_lex $P1453, "self"
    get_global $P1454, "$?CLASS"
    getattribute $P1455, $P1453, $P1454, "%!methods"
    unless_null $P1455, vivify_333
    $P1455 = root_new ['parrot';'Hash']
  vivify_333:
    defined $I1456, $P1455
    unless $I1456, for_undef_334
    iter $P1452, $P1455
    new $P1466, 'ExceptionHandler'
    set_label $P1466, loop1465_handler
    $P1466."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1466
  loop1465_test:
    unless $P1452, loop1465_done
    shift $P1457, $P1452
  loop1465_redo:
    .const 'Sub' $P1459 = "100_1298839204.312" 
    capture_lex $P1459
    $P1459($P1457)
  loop1465_next:
    goto loop1465_test
  loop1465_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1467, exception, 'type'
    eq $P1467, .CONTROL_LOOP_NEXT, loop1465_next
    eq $P1467, .CONTROL_LOOP_REDO, loop1465_redo
  loop1465_done:
    pop_eh 
  for_undef_334:
    find_lex $P1468, "@meths"
.annotate 'line', 635
    .return ($P1468)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1458"  :anon :subid("100_1298839204.312") :outer("99_1298839204.312")
    .param pmc param_1460
.annotate 'line', 637
    .lex "$_", param_1460
.annotate 'line', 638
    find_lex $P1461, "@meths"
    find_lex $P1462, "$_"
    $P1463 = $P1462."value"()
    $P1464 = $P1461."push"($P1463)
.annotate 'line', 637
    .return ($P1464)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "method_table"  :subid("101_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1470
    .param pmc param_1471
.annotate 'line', 643
    .lex "self", param_1470
    .lex "$obj", param_1471
    find_lex $P1472, "self"
    get_global $P1473, "$?CLASS"
    getattribute $P1474, $P1472, $P1473, "%!methods"
    unless_null $P1474, vivify_335
    $P1474 = root_new ['parrot';'Hash']
  vivify_335:
    .return ($P1474)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "collisions"  :subid("102_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1476
    .param pmc param_1477
.annotate 'line', 647
    .lex "self", param_1476
    .lex "$obj", param_1477
    find_lex $P1478, "self"
    get_global $P1479, "$?CLASS"
    getattribute $P1480, $P1478, $P1479, "@!collisions"
    unless_null $P1480, vivify_336
    $P1480 = root_new ['parrot';'ResizablePMCArray']
  vivify_336:
    .return ($P1480)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "name"  :subid("103_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1482
    .param pmc param_1483
.annotate 'line', 651
    .lex "self", param_1482
    .lex "$obj", param_1483
    find_lex $P1484, "self"
    get_global $P1485, "$?CLASS"
    getattribute $P1486, $P1484, $P1485, "$!name"
    unless_null $P1486, vivify_337
    new $P1486, "Undef"
  vivify_337:
    .return ($P1486)
.end


.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("104_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1488
    .param pmc param_1489
.annotate 'line', 655
    .const 'Sub' $P1499 = "105_1298839204.312" 
    capture_lex $P1499
    .lex "self", param_1488
    .lex "$obj", param_1489
.annotate 'line', 656
    $P1490 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1490
.annotate 'line', 655
    find_lex $P1491, "@attrs"
.annotate 'line', 657
    find_lex $P1493, "self"
    get_global $P1494, "$?CLASS"
    getattribute $P1495, $P1493, $P1494, "%!attributes"
    unless_null $P1495, vivify_338
    $P1495 = root_new ['parrot';'Hash']
  vivify_338:
    defined $I1496, $P1495
    unless $I1496, for_undef_339
    iter $P1492, $P1495
    new $P1506, 'ExceptionHandler'
    set_label $P1506, loop1505_handler
    $P1506."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1506
  loop1505_test:
    unless $P1492, loop1505_done
    shift $P1497, $P1492
  loop1505_redo:
    .const 'Sub' $P1499 = "105_1298839204.312" 
    capture_lex $P1499
    $P1499($P1497)
  loop1505_next:
    goto loop1505_test
  loop1505_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1507, exception, 'type'
    eq $P1507, .CONTROL_LOOP_NEXT, loop1505_next
    eq $P1507, .CONTROL_LOOP_REDO, loop1505_redo
  loop1505_done:
    pop_eh 
  for_undef_339:
    find_lex $P1508, "@attrs"
.annotate 'line', 655
    .return ($P1508)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "_block1498"  :anon :subid("105_1298839204.312") :outer("104_1298839204.312")
    .param pmc param_1500
.annotate 'line', 657
    .lex "$_", param_1500
.annotate 'line', 658
    find_lex $P1501, "@attrs"
    find_lex $P1502, "$_"
    $P1503 = $P1502."value"()
    $P1504 = $P1501."push"($P1503)
.annotate 'line', 657
    .return ($P1504)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "roles"  :subid("106_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1510
    .param pmc param_1511
.annotate 'line', 663
    .lex "self", param_1510
    .lex "$obj", param_1511
    find_lex $P1512, "self"
    get_global $P1513, "$?CLASS"
    getattribute $P1514, $P1512, $P1513, "@!roles"
    unless_null $P1514, vivify_340
    $P1514 = root_new ['parrot';'ResizablePMCArray']
  vivify_340:
    .return ($P1514)
.end


.namespace ["NQPConcreteRoleHOW"]
.sub "instance_of"  :subid("107_1298839204.312") :outer("87_1298839204.312")
    .param pmc param_1516
    .param pmc param_1517
.annotate 'line', 667
    .lex "self", param_1516
    .lex "$obj", param_1517
    find_lex $P1518, "self"
    get_global $P1519, "$?CLASS"
    getattribute $P1520, $P1518, $P1519, "$!instance_of"
    unless_null $P1520, vivify_341
    new $P1520, "Undef"
  vivify_341:
    .return ($P1520)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1589"  :subid("109_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 677
    .const 'Sub' $P1887 = "132_1298839204.312" 
    capture_lex $P1887
    .const 'Sub' $P1879 = "131_1298839204.312" 
    capture_lex $P1879
    .const 'Sub' $P1857 = "129_1298839204.312" 
    capture_lex $P1857
    .const 'Sub' $P1851 = "128_1298839204.312" 
    capture_lex $P1851
    .const 'Sub' $P1845 = "127_1298839204.312" 
    capture_lex $P1845
    .const 'Sub' $P1823 = "125_1298839204.312" 
    capture_lex $P1823
    .const 'Sub' $P1717 = "120_1298839204.312" 
    capture_lex $P1717
    .const 'Sub' $P1714 = "119_1298839204.312" 
    capture_lex $P1714
    .const 'Sub' $P1707 = "118_1298839204.312" 
    capture_lex $P1707
    .const 'Sub' $P1694 = "117_1298839204.312" 
    capture_lex $P1694
    .const 'Sub' $P1690 = "116_1298839204.312" 
    capture_lex $P1690
    .const 'Sub' $P1669 = "115_1298839204.312" 
    capture_lex $P1669
    .const 'Sub' $P1648 = "114_1298839204.312" 
    capture_lex $P1648
    .const 'Sub' $P1629 = "113_1298839204.312" 
    capture_lex $P1629
    .const 'Sub' $P1613 = "112_1298839204.312" 
    capture_lex $P1613
    .const 'Sub' $P1603 = "111_1298839204.312" 
    capture_lex $P1603
    .const 'Sub' $P1592 = "110_1298839204.312" 
    capture_lex $P1592
    get_global $P1591, "$?CLASS"
.annotate 'line', 837
    .const 'Sub' $P1879 = "131_1298839204.312" 
    newclosure $P1885, $P1879
.annotate 'line', 677
    .return ($P1885)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "" :load :init :subid("post342") :outer("109_1298839204.312")
.annotate 'line', 677
    get_hll_global $P1590, ["NQPParametricRoleHOW"], "_block1589" 
    .local pmc block
    set block, $P1590
    .const 'Sub' $P1887 = "132_1298839204.312" 
    capture_lex $P1887
    $P1887()
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1886"  :anon :subid("132_1298839204.312") :outer("109_1298839204.312")
.annotate 'line', 677
    get_hll_global $P1888, "KnowHOW"
    $P1889 = $P1888."new_type"("NQPParametricRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1889
    set_hll_global "NQPParametricRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1890, type_obj
    get_hll_global $P1891, "KnowHOWAttribute"
    $P1892 = $P1891."new"("$!name" :named("name"))
    $P1890."add_attribute"(type_obj, $P1892)
    get_how $P1893, type_obj
    get_hll_global $P1894, "KnowHOWAttribute"
    $P1895 = $P1894."new"("%!attributes" :named("name"))
    $P1893."add_attribute"(type_obj, $P1895)
    get_how $P1896, type_obj
    get_hll_global $P1897, "KnowHOWAttribute"
    $P1898 = $P1897."new"("%!methods" :named("name"))
    $P1896."add_attribute"(type_obj, $P1898)
    get_how $P1899, type_obj
    get_hll_global $P1900, "KnowHOWAttribute"
    $P1901 = $P1900."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1899."add_attribute"(type_obj, $P1901)
    get_how $P1902, type_obj
    get_hll_global $P1903, "KnowHOWAttribute"
    $P1904 = $P1903."new"("@!roles" :named("name"))
    $P1902."add_attribute"(type_obj, $P1904)
    get_how $P1905, type_obj
    get_hll_global $P1906, "KnowHOWAttribute"
    $P1907 = $P1906."new"("$!composed" :named("name"))
    $P1905."add_attribute"(type_obj, $P1907)
    get_how $P1908, type_obj
    get_hll_global $P1909, "KnowHOWAttribute"
    $P1910 = $P1909."new"("$!body_block" :named("name"))
    $P1908."add_attribute"(type_obj, $P1910)
    get_how $P1911, type_obj
    .const 'Sub' $P1912 = "110_1298839204.312" 
    $P1911."add_method"(type_obj, "new", $P1912)
    get_how $P1913, type_obj
    .const 'Sub' $P1914 = "111_1298839204.312" 
    $P1913."add_method"(type_obj, "BUILD", $P1914)
    get_how $P1915, type_obj
    .const 'Sub' $P1916 = "112_1298839204.312" 
    $P1915."add_method"(type_obj, "new_type", $P1916)
    get_how $P1917, type_obj
    .const 'Sub' $P1918 = "113_1298839204.312" 
    $P1917."add_method"(type_obj, "add_method", $P1918)
    get_how $P1919, type_obj
    .const 'Sub' $P1920 = "114_1298839204.312" 
    $P1919."add_method"(type_obj, "add_multi_method", $P1920)
    get_how $P1921, type_obj
    .const 'Sub' $P1922 = "115_1298839204.312" 
    $P1921."add_method"(type_obj, "add_attribute", $P1922)
    get_how $P1923, type_obj
    .const 'Sub' $P1924 = "116_1298839204.312" 
    $P1923."add_method"(type_obj, "add_parent", $P1924)
    get_how $P1925, type_obj
    .const 'Sub' $P1926 = "117_1298839204.312" 
    $P1925."add_method"(type_obj, "add_role", $P1926)
    get_how $P1927, type_obj
    .const 'Sub' $P1928 = "118_1298839204.312" 
    $P1927."add_method"(type_obj, "compose", $P1928)
    get_how $P1929, type_obj
    .const 'Sub' $P1930 = "119_1298839204.312" 
    $P1929."add_method"(type_obj, "parametric", $P1930)
    get_how $P1931, type_obj
    .const 'Sub' $P1932 = "120_1298839204.312" 
    $P1931."add_method"(type_obj, "instantiate", $P1932)
    get_how $P1933, type_obj
    .const 'Sub' $P1934 = "125_1298839204.312" 
    $P1933."add_method"(type_obj, "methods", $P1934)
    get_how $P1935, type_obj
    .const 'Sub' $P1936 = "127_1298839204.312" 
    $P1935."add_method"(type_obj, "method_table", $P1936)
    get_how $P1937, type_obj
    .const 'Sub' $P1938 = "128_1298839204.312" 
    $P1937."add_method"(type_obj, "name", $P1938)
    get_how $P1939, type_obj
    .const 'Sub' $P1940 = "129_1298839204.312" 
    $P1939."add_method"(type_obj, "attributes", $P1940)
    get_how $P1941, type_obj
    .const 'Sub' $P1942 = "131_1298839204.312" 
    $P1941."add_method"(type_obj, "roles", $P1942)
    get_how $P1943, type_obj
    $P1944 = $P1943."compose"(type_obj)
    .return ($P1944)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "new"  :subid("110_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1593
    .param pmc param_1594 :named("name")
    .param pmc param_1595 :named("body_block")
.annotate 'line', 707
    .lex "self", param_1593
    .lex "$name", param_1594
    .lex "$body_block", param_1595
.annotate 'line', 708
    new $P1596, "Undef"
    .lex "$obj", $P1596
    find_lex $P1597, "self"
    repr_instance_of $P1598, $P1597
    store_lex "$obj", $P1598
.annotate 'line', 709
    find_lex $P1599, "$obj"
    find_lex $P1600, "$name"
    find_lex $P1601, "$body_block"
    $P1599."BUILD"($P1600 :named("name"), $P1601 :named("body_block"))
    find_lex $P1602, "$obj"
.annotate 'line', 707
    .return ($P1602)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "BUILD"  :subid("111_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1604
    .param pmc param_1605 :named("name")
    .param pmc param_1606 :named("body_block")
.annotate 'line', 713
    .lex "self", param_1604
    .lex "$name", param_1605
    .lex "$body_block", param_1606
.annotate 'line', 714
    find_lex $P1607, "$name"
    find_lex $P1608, "self"
    get_global $P1609, "$?CLASS"
    setattribute $P1608, $P1609, "$!name", $P1607
.annotate 'line', 715
    find_lex $P1610, "$body_block"
    find_lex $P1611, "self"
    get_global $P1612, "$?CLASS"
    setattribute $P1611, $P1612, "$!body_block", $P1610
.annotate 'line', 713
    .return ($P1610)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "new_type"  :subid("112_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1614
    .param pmc param_1615 :named("body_block")
    .param pmc param_1616 :optional :named("name")
    .param int has_param_1616 :opt_flag
    .param pmc param_1618 :optional :named("repr")
    .param int has_param_1618 :opt_flag
.annotate 'line', 720
    .lex "self", param_1614
    .lex "$body_block", param_1615
    if has_param_1616, optparam_343
    new $P1617, "String"
    assign $P1617, "<anon>"
    set param_1616, $P1617
  optparam_343:
    .lex "$name", param_1616
    if has_param_1618, optparam_344
    new $P1619, "String"
    assign $P1619, "P6opaque"
    set param_1618, $P1619
  optparam_344:
    .lex "$repr", param_1618
.annotate 'line', 721
    new $P1620, "Undef"
    .lex "$metarole", $P1620
    find_lex $P1621, "self"
    find_lex $P1622, "$name"
    find_lex $P1623, "$body_block"
    $P1624 = $P1621."new"($P1622 :named("name"), $P1623 :named("body_block"))
    store_lex "$metarole", $P1624
.annotate 'line', 722
    find_lex $P1625, "$metarole"
    find_lex $P1626, "$repr"
    set $S1627, $P1626
    repr_type_object_for $P1628, $P1625, $S1627
.annotate 'line', 720
    .return ($P1628)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_method"  :subid("113_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1630
    .param pmc param_1631
    .param pmc param_1632
    .param pmc param_1633
.annotate 'line', 725
    .lex "self", param_1630
    .lex "$obj", param_1631
    .lex "$name", param_1632
    .lex "$code_obj", param_1633
.annotate 'line', 726
    find_lex $P1635, "$name"
    find_lex $P1636, "self"
    get_global $P1637, "$?CLASS"
    getattribute $P1638, $P1636, $P1637, "%!methods"
    unless_null $P1638, vivify_345
    $P1638 = root_new ['parrot';'Hash']
  vivify_345:
    set $P1639, $P1638[$P1635]
    unless_null $P1639, vivify_346
    new $P1639, "Undef"
  vivify_346:
    unless $P1639, if_1634_end
.annotate 'line', 727
    new $P1640, "String"
    assign $P1640, "This role already has a method named "
    find_lex $P1641, "$name"
    concat $P1642, $P1640, $P1641
    die $P1642
  if_1634_end:
.annotate 'line', 729
    find_lex $P1643, "$code_obj"
    find_lex $P1644, "$name"
    find_lex $P1645, "self"
    get_global $P1646, "$?CLASS"
    getattribute $P1647, $P1645, $P1646, "%!methods"
    unless_null $P1647, vivify_347
    $P1647 = root_new ['parrot';'Hash']
    setattribute $P1645, $P1646, "%!methods", $P1647
  vivify_347:
    set $P1647[$P1644], $P1643
.annotate 'line', 725
    .return ($P1643)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_multi_method"  :subid("114_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1649
    .param pmc param_1650
    .param pmc param_1651
    .param pmc param_1652
.annotate 'line', 732
    .lex "self", param_1649
    .lex "$obj", param_1650
    .lex "$name", param_1651
    .lex "$code_obj", param_1652
.annotate 'line', 733
    $P1653 = root_new ['parrot';'Hash']
    .lex "%todo", $P1653
.annotate 'line', 732
    find_lex $P1654, "%todo"
.annotate 'line', 734
    find_lex $P1655, "$name"
    find_lex $P1656, "%todo"
    unless_null $P1656, vivify_348
    $P1656 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1656
  vivify_348:
    set $P1656["name"], $P1655
.annotate 'line', 735
    find_lex $P1657, "$code_obj"
    find_lex $P1658, "%todo"
    unless_null $P1658, vivify_349
    $P1658 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1658
  vivify_349:
    set $P1658["code"], $P1657
.annotate 'line', 736
    find_lex $P1659, "%todo"
    find_lex $P1660, "self"
    get_global $P1661, "$?CLASS"
    getattribute $P1662, $P1660, $P1661, "@!multi_methods_to_incorporate"
    unless_null $P1662, vivify_350
    $P1662 = root_new ['parrot';'ResizablePMCArray']
  vivify_350:
    set $N1663, $P1662
    set $I1664, $N1663
    find_lex $P1665, "self"
    get_global $P1666, "$?CLASS"
    getattribute $P1667, $P1665, $P1666, "@!multi_methods_to_incorporate"
    unless_null $P1667, vivify_351
    $P1667 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1665, $P1666, "@!multi_methods_to_incorporate", $P1667
  vivify_351:
    set $P1667[$I1664], $P1659
    find_lex $P1668, "$code_obj"
.annotate 'line', 732
    .return ($P1668)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_attribute"  :subid("115_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1670
    .param pmc param_1671
    .param pmc param_1672
.annotate 'line', 740
    .lex "self", param_1670
    .lex "$obj", param_1671
    .lex "$meta_attr", param_1672
.annotate 'line', 741
    new $P1673, "Undef"
    .lex "$name", $P1673
    find_lex $P1674, "$meta_attr"
    $P1675 = $P1674."name"()
    store_lex "$name", $P1675
.annotate 'line', 742
    find_lex $P1677, "$name"
    find_lex $P1678, "self"
    get_global $P1679, "$?CLASS"
    getattribute $P1680, $P1678, $P1679, "%!attributes"
    unless_null $P1680, vivify_352
    $P1680 = root_new ['parrot';'Hash']
  vivify_352:
    set $P1681, $P1680[$P1677]
    unless_null $P1681, vivify_353
    new $P1681, "Undef"
  vivify_353:
    unless $P1681, if_1676_end
.annotate 'line', 743
    new $P1682, "String"
    assign $P1682, "This role already has an attribute named "
    find_lex $P1683, "$name"
    concat $P1684, $P1682, $P1683
    die $P1684
  if_1676_end:
.annotate 'line', 745
    find_lex $P1685, "$meta_attr"
    find_lex $P1686, "$name"
    find_lex $P1687, "self"
    get_global $P1688, "$?CLASS"
    getattribute $P1689, $P1687, $P1688, "%!attributes"
    unless_null $P1689, vivify_354
    $P1689 = root_new ['parrot';'Hash']
    setattribute $P1687, $P1688, "%!attributes", $P1689
  vivify_354:
    set $P1689[$P1686], $P1685
.annotate 'line', 740
    .return ($P1685)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_parent"  :subid("116_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1691
    .param pmc param_1692
    .param pmc param_1693
.annotate 'line', 748
    .lex "self", param_1691
    .lex "$obj", param_1692
    .lex "$parent", param_1693
.annotate 'line', 749
    die "A role cannot inherit from a class"
.annotate 'line', 748
    .return ()
.end


.namespace ["NQPParametricRoleHOW"]
.sub "add_role"  :subid("117_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1695
    .param pmc param_1696
    .param pmc param_1697
.annotate 'line', 752
    .lex "self", param_1695
    .lex "$obj", param_1696
    .lex "$role", param_1697
.annotate 'line', 753
    find_lex $P1698, "$role"
    find_lex $P1699, "self"
    get_global $P1700, "$?CLASS"
    getattribute $P1701, $P1699, $P1700, "@!roles"
    unless_null $P1701, vivify_355
    $P1701 = root_new ['parrot';'ResizablePMCArray']
  vivify_355:
    set $N1702, $P1701
    set $I1703, $N1702
    find_lex $P1704, "self"
    get_global $P1705, "$?CLASS"
    getattribute $P1706, $P1704, $P1705, "@!roles"
    unless_null $P1706, vivify_356
    $P1706 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1704, $P1705, "@!roles", $P1706
  vivify_356:
    set $P1706[$I1703], $P1698
.annotate 'line', 752
    .return ($P1698)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "compose"  :subid("118_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1708
    .param pmc param_1709
.annotate 'line', 757
    .lex "self", param_1708
    .lex "$obj", param_1709
.annotate 'line', 758
    new $P1710, "Integer"
    assign $P1710, 1
    find_lex $P1711, "self"
    get_global $P1712, "$?CLASS"
    setattribute $P1711, $P1712, "$!composed", $P1710
    find_lex $P1713, "$obj"
.annotate 'line', 757
    .return ($P1713)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "parametric"  :subid("119_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1715
    .param pmc param_1716
.annotate 'line', 768
    .lex "self", param_1715
    .lex "$obj", param_1716
    .return (1)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "instantiate"  :subid("120_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1720
    .param pmc param_1721
    .param pmc param_1722
.annotate 'line', 774
    .const 'Sub' $P1801 = "124_1298839204.312" 
    capture_lex $P1801
    .const 'Sub' $P1780 = "123_1298839204.312" 
    capture_lex $P1780
    .const 'Sub' $P1759 = "122_1298839204.312" 
    capture_lex $P1759
    .const 'Sub' $P1741 = "121_1298839204.312" 
    capture_lex $P1741
    new $P1719, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1719, control_1718
    push_eh $P1719
    .lex "self", param_1720
    .lex "$obj", param_1721
    .lex "$class_arg", param_1722
.annotate 'line', 780
    new $P1723, "Undef"
    .lex "$irole", $P1723
.annotate 'line', 777
    find_lex $P1724, "self"
    get_global $P1725, "$?CLASS"
    getattribute $P1726, $P1724, $P1725, "$!body_block"
    unless_null $P1726, vivify_357
    new $P1726, "Undef"
  vivify_357:
    find_lex $P1727, "$class_arg"
    $P1726($P1727)
.annotate 'line', 780
    get_hll_global $P1728, "NQPConcreteRoleHOW"
    find_lex $P1729, "self"
    get_global $P1730, "$?CLASS"
    getattribute $P1731, $P1729, $P1730, "$!name"
    unless_null $P1731, vivify_358
    new $P1731, "Undef"
  vivify_358:
    find_lex $P1732, "$obj"
    $P1733 = $P1728."new_type"($P1731 :named("name"), $P1732 :named("instance_of"))
    store_lex "$irole", $P1733
.annotate 'line', 784
    find_lex $P1735, "self"
    get_global $P1736, "$?CLASS"
    getattribute $P1737, $P1735, $P1736, "%!attributes"
    unless_null $P1737, vivify_359
    $P1737 = root_new ['parrot';'Hash']
  vivify_359:
    defined $I1738, $P1737
    unless $I1738, for_undef_360
    iter $P1734, $P1737
    new $P1750, 'ExceptionHandler'
    set_label $P1750, loop1749_handler
    $P1750."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1750
  loop1749_test:
    unless $P1734, loop1749_done
    shift $P1739, $P1734
  loop1749_redo:
    .const 'Sub' $P1741 = "121_1298839204.312" 
    capture_lex $P1741
    $P1741($P1739)
  loop1749_next:
    goto loop1749_test
  loop1749_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1751, exception, 'type'
    eq $P1751, .CONTROL_LOOP_NEXT, loop1749_next
    eq $P1751, .CONTROL_LOOP_REDO, loop1749_redo
  loop1749_done:
    pop_eh 
  for_undef_360:
.annotate 'line', 790
    find_lex $P1753, "self"
    get_global $P1754, "$?CLASS"
    getattribute $P1755, $P1753, $P1754, "%!methods"
    unless_null $P1755, vivify_361
    $P1755 = root_new ['parrot';'Hash']
  vivify_361:
    defined $I1756, $P1755
    unless $I1756, for_undef_362
    iter $P1752, $P1755
    new $P1771, 'ExceptionHandler'
    set_label $P1771, loop1770_handler
    $P1771."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1771
  loop1770_test:
    unless $P1752, loop1770_done
    shift $P1757, $P1752
  loop1770_redo:
    .const 'Sub' $P1759 = "122_1298839204.312" 
    capture_lex $P1759
    $P1759($P1757)
  loop1770_next:
    goto loop1770_test
  loop1770_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1772, exception, 'type'
    eq $P1772, .CONTROL_LOOP_NEXT, loop1770_next
    eq $P1772, .CONTROL_LOOP_REDO, loop1770_redo
  loop1770_done:
    pop_eh 
  for_undef_362:
.annotate 'line', 793
    find_lex $P1774, "self"
    get_global $P1775, "$?CLASS"
    getattribute $P1776, $P1774, $P1775, "@!multi_methods_to_incorporate"
    unless_null $P1776, vivify_363
    $P1776 = root_new ['parrot';'ResizablePMCArray']
  vivify_363:
    defined $I1777, $P1776
    unless $I1777, for_undef_364
    iter $P1773, $P1776
    new $P1792, 'ExceptionHandler'
    set_label $P1792, loop1791_handler
    $P1792."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1792
  loop1791_test:
    unless $P1773, loop1791_done
    shift $P1778, $P1773
  loop1791_redo:
    .const 'Sub' $P1780 = "123_1298839204.312" 
    capture_lex $P1780
    $P1780($P1778)
  loop1791_next:
    goto loop1791_test
  loop1791_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1793, exception, 'type'
    eq $P1793, .CONTROL_LOOP_NEXT, loop1791_next
    eq $P1793, .CONTROL_LOOP_REDO, loop1791_redo
  loop1791_done:
    pop_eh 
  for_undef_364:
.annotate 'line', 798
    find_lex $P1795, "self"
    get_global $P1796, "$?CLASS"
    getattribute $P1797, $P1795, $P1796, "@!roles"
    unless_null $P1797, vivify_369
    $P1797 = root_new ['parrot';'ResizablePMCArray']
  vivify_369:
    defined $I1798, $P1797
    unless $I1798, for_undef_370
    iter $P1794, $P1797
    new $P1815, 'ExceptionHandler'
    set_label $P1815, loop1814_handler
    $P1815."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1815
  loop1814_test:
    unless $P1794, loop1814_done
    shift $P1799, $P1794
  loop1814_redo:
    .const 'Sub' $P1801 = "124_1298839204.312" 
    capture_lex $P1801
    $P1801($P1799)
  loop1814_next:
    goto loop1814_test
  loop1814_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1816, exception, 'type'
    eq $P1816, .CONTROL_LOOP_NEXT, loop1814_next
    eq $P1816, .CONTROL_LOOP_REDO, loop1814_redo
  loop1814_done:
    pop_eh 
  for_undef_370:
.annotate 'line', 804
    find_lex $P1817, "$irole"
    get_how $P1818, $P1817
    find_lex $P1819, "$irole"
    $P1818."compose"($P1819)
.annotate 'line', 805
    new $P1820, "Exception"
    set $P1820['type'], .CONTROL_RETURN
    find_lex $P1821, "$irole"
    setattribute $P1820, 'payload', $P1821
    throw $P1820
.annotate 'line', 774
    .return ()
  control_1718:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1822, exception, "payload"
    .return ($P1822)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1740"  :anon :subid("121_1298839204.312") :outer("120_1298839204.312")
    .param pmc param_1742
.annotate 'line', 784
    .lex "$_", param_1742
.annotate 'line', 785
    find_lex $P1743, "$irole"
    get_how $P1744, $P1743
    find_lex $P1745, "$irole"
    find_lex $P1746, "$_"
    $P1747 = $P1746."value"()
    $P1748 = $P1744."add_attribute"($P1745, $P1747)
.annotate 'line', 784
    .return ($P1748)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1758"  :anon :subid("122_1298839204.312") :outer("120_1298839204.312")
    .param pmc param_1760
.annotate 'line', 790
    .lex "$_", param_1760
.annotate 'line', 791
    find_lex $P1761, "$irole"
    get_how $P1762, $P1761
    find_lex $P1763, "$irole"
    find_lex $P1764, "$_"
    $P1765 = $P1764."key"()
    find_lex $P1766, "$_"
    $P1767 = $P1766."value"()
    clone $P1768, $P1767
    $P1769 = $P1762."add_method"($P1763, $P1765, $P1768)
.annotate 'line', 790
    .return ($P1769)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1779"  :anon :subid("123_1298839204.312") :outer("120_1298839204.312")
    .param pmc param_1781
.annotate 'line', 793
    .lex "$_", param_1781
.annotate 'line', 794
    find_lex $P1782, "$irole"
    get_how $P1783, $P1782
    find_lex $P1784, "$irole"
    find_lex $P1785, "$_"
    unless_null $P1785, vivify_365
    $P1785 = root_new ['parrot';'Hash']
  vivify_365:
    set $P1786, $P1785["name"]
    unless_null $P1786, vivify_366
    new $P1786, "Undef"
  vivify_366:
    find_lex $P1787, "$_"
    unless_null $P1787, vivify_367
    $P1787 = root_new ['parrot';'Hash']
  vivify_367:
    set $P1788, $P1787["code"]
    unless_null $P1788, vivify_368
    new $P1788, "Undef"
  vivify_368:
    clone $P1789, $P1788
    $P1790 = $P1783."add_multi_method"($P1784, $P1786, $P1789)
.annotate 'line', 793
    .return ($P1790)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1800"  :anon :subid("124_1298839204.312") :outer("120_1298839204.312")
    .param pmc param_1803
.annotate 'line', 799
    new $P1802, "Undef"
    .lex "$instantiated", $P1802
    .lex "$_", param_1803
    find_lex $P1804, "$irole"
    get_how $P1805, $P1804
    find_lex $P1806, "$irole"
    find_lex $P1807, "$class_arg"
    $P1808 = $P1805."instantiate"($P1806, $P1807)
    store_lex "$instantiated", $P1808
.annotate 'line', 800
    find_lex $P1809, "$irole"
    get_how $P1810, $P1809
    find_lex $P1811, "$irole"
    find_lex $P1812, "$instantiated"
    $P1813 = $P1810."add_role"($P1811, $P1812)
.annotate 'line', 798
    .return ($P1813)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("125_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1824
    .param pmc param_1825
.annotate 'line', 813
    .const 'Sub' $P1835 = "126_1298839204.312" 
    capture_lex $P1835
    .lex "self", param_1824
    .lex "$obj", param_1825
.annotate 'line', 814
    $P1826 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1826
.annotate 'line', 813
    find_lex $P1827, "@meths"
.annotate 'line', 815
    find_lex $P1829, "self"
    get_global $P1830, "$?CLASS"
    getattribute $P1831, $P1829, $P1830, "%!methods"
    unless_null $P1831, vivify_371
    $P1831 = root_new ['parrot';'Hash']
  vivify_371:
    defined $I1832, $P1831
    unless $I1832, for_undef_372
    iter $P1828, $P1831
    new $P1842, 'ExceptionHandler'
    set_label $P1842, loop1841_handler
    $P1842."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1842
  loop1841_test:
    unless $P1828, loop1841_done
    shift $P1833, $P1828
  loop1841_redo:
    .const 'Sub' $P1835 = "126_1298839204.312" 
    capture_lex $P1835
    $P1835($P1833)
  loop1841_next:
    goto loop1841_test
  loop1841_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1843, exception, 'type'
    eq $P1843, .CONTROL_LOOP_NEXT, loop1841_next
    eq $P1843, .CONTROL_LOOP_REDO, loop1841_redo
  loop1841_done:
    pop_eh 
  for_undef_372:
    find_lex $P1844, "@meths"
.annotate 'line', 813
    .return ($P1844)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1834"  :anon :subid("126_1298839204.312") :outer("125_1298839204.312")
    .param pmc param_1836
.annotate 'line', 815
    .lex "$_", param_1836
.annotate 'line', 816
    find_lex $P1837, "@meths"
    find_lex $P1838, "$_"
    $P1839 = $P1838."value"()
    $P1840 = $P1837."push"($P1839)
.annotate 'line', 815
    .return ($P1840)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "method_table"  :subid("127_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1846
    .param pmc param_1847
.annotate 'line', 821
    .lex "self", param_1846
    .lex "$obj", param_1847
    find_lex $P1848, "self"
    get_global $P1849, "$?CLASS"
    getattribute $P1850, $P1848, $P1849, "%!methods"
    unless_null $P1850, vivify_373
    $P1850 = root_new ['parrot';'Hash']
  vivify_373:
    .return ($P1850)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "name"  :subid("128_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1852
    .param pmc param_1853
.annotate 'line', 825
    .lex "self", param_1852
    .lex "$obj", param_1853
    find_lex $P1854, "self"
    get_global $P1855, "$?CLASS"
    getattribute $P1856, $P1854, $P1855, "$!name"
    unless_null $P1856, vivify_374
    new $P1856, "Undef"
  vivify_374:
    .return ($P1856)
.end


.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("129_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1858
    .param pmc param_1859
.annotate 'line', 829
    .const 'Sub' $P1869 = "130_1298839204.312" 
    capture_lex $P1869
    .lex "self", param_1858
    .lex "$obj", param_1859
.annotate 'line', 830
    $P1860 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1860
.annotate 'line', 829
    find_lex $P1861, "@attrs"
.annotate 'line', 831
    find_lex $P1863, "self"
    get_global $P1864, "$?CLASS"
    getattribute $P1865, $P1863, $P1864, "%!attributes"
    unless_null $P1865, vivify_375
    $P1865 = root_new ['parrot';'Hash']
  vivify_375:
    defined $I1866, $P1865
    unless $I1866, for_undef_376
    iter $P1862, $P1865
    new $P1876, 'ExceptionHandler'
    set_label $P1876, loop1875_handler
    $P1876."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1876
  loop1875_test:
    unless $P1862, loop1875_done
    shift $P1867, $P1862
  loop1875_redo:
    .const 'Sub' $P1869 = "130_1298839204.312" 
    capture_lex $P1869
    $P1869($P1867)
  loop1875_next:
    goto loop1875_test
  loop1875_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1877, exception, 'type'
    eq $P1877, .CONTROL_LOOP_NEXT, loop1875_next
    eq $P1877, .CONTROL_LOOP_REDO, loop1875_redo
  loop1875_done:
    pop_eh 
  for_undef_376:
    find_lex $P1878, "@attrs"
.annotate 'line', 829
    .return ($P1878)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "_block1868"  :anon :subid("130_1298839204.312") :outer("129_1298839204.312")
    .param pmc param_1870
.annotate 'line', 831
    .lex "$_", param_1870
.annotate 'line', 832
    find_lex $P1871, "@attrs"
    find_lex $P1872, "$_"
    $P1873 = $P1872."value"()
    $P1874 = $P1871."push"($P1873)
.annotate 'line', 831
    .return ($P1874)
.end


.namespace ["NQPParametricRoleHOW"]
.sub "roles"  :subid("131_1298839204.312") :outer("109_1298839204.312")
    .param pmc param_1880
    .param pmc param_1881
.annotate 'line', 837
    .lex "self", param_1880
    .lex "$obj", param_1881
    find_lex $P1882, "self"
    get_global $P1883, "$?CLASS"
    getattribute $P1884, $P1882, $P1883, "@!roles"
    unless_null $P1884, vivify_377
    $P1884 = root_new ['parrot';'ResizablePMCArray']
  vivify_377:
    .return ($P1884)
.end


.namespace ["RoleToClassApplier"]
.sub "_block1945"  :subid("133_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 843
    .const 'Sub' $P2154 = "143_1298839204.312" 
    capture_lex $P2154
    .const 'Sub' $P2018 = "138_1298839204.312" 
    capture_lex $P2018
    .const 'Sub' $P1983 = "136_1298839204.312" 
    capture_lex $P1983
    .const 'Sub' $P1948 = "134_1298839204.312" 
    capture_lex $P1948
    get_global $P1947, "$?CLASS"
.annotate 'line', 845
    .const 'Sub' $P1948 = "134_1298839204.312" 
    newclosure $P1982, $P1948
    .lex "has_method", $P1982
.annotate 'line', 853
    .const 'Sub' $P1983 = "136_1298839204.312" 
    newclosure $P2015, $P1983
    .lex "has_attribute", $P2015
.annotate 'line', 843
    find_lex $P2016, "has_method"
    find_lex $P2017, "has_attribute"
.annotate 'line', 861
    .const 'Sub' $P2018 = "138_1298839204.312" 
    newclosure $P2152, $P2018
.annotate 'line', 843
    .return ($P2152)
.end


.namespace ["RoleToClassApplier"]
.sub "" :load :init :subid("post378") :outer("133_1298839204.312")
.annotate 'line', 843
    get_hll_global $P1946, ["RoleToClassApplier"], "_block1945" 
    .local pmc block
    set block, $P1946
    .const 'Sub' $P2154 = "143_1298839204.312" 
    capture_lex $P2154
    $P2154()
.end


.namespace ["RoleToClassApplier"]
.sub "_block2153"  :anon :subid("143_1298839204.312") :outer("133_1298839204.312")
.annotate 'line', 843
    get_hll_global $P2155, "KnowHOW"
    $P2156 = $P2155."new_type"("RoleToClassApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2156
    set_hll_global "RoleToClassApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2157, type_obj
    .const 'Sub' $P2158 = "138_1298839204.312" 
    $P2157."add_method"(type_obj, "apply", $P2158)
    get_how $P2159, type_obj
    $P2160 = $P2159."compose"(type_obj)
    .return ($P2160)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_method"  :subid("134_1298839204.312") :outer("133_1298839204.312")
    .param pmc param_1951
    .param pmc param_1952
    .param pmc param_1953
.annotate 'line', 845
    .const 'Sub' $P1965 = "135_1298839204.312" 
    capture_lex $P1965
    new $P1950, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1950, control_1949
    push_eh $P1950
    .lex "$target", param_1951
    .lex "$name", param_1952
    .lex "$local", param_1953
.annotate 'line', 846
    $P1954 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P1954
    find_lex $P1955, "$target"
    get_how $P1956, $P1955
    find_lex $P1957, "$target"
    find_lex $P1958, "$local"
    $P1959 = $P1956."methods"($P1957, $P1958 :named("local"))
    store_lex "@methods", $P1959
.annotate 'line', 847
    find_lex $P1961, "@methods"
    defined $I1962, $P1961
    unless $I1962, for_undef_379
    iter $P1960, $P1961
    new $P1977, 'ExceptionHandler'
    set_label $P1977, loop1976_handler
    $P1977."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1977
  loop1976_test:
    unless $P1960, loop1976_done
    shift $P1963, $P1960
  loop1976_redo:
    .const 'Sub' $P1965 = "135_1298839204.312" 
    capture_lex $P1965
    $P1965($P1963)
  loop1976_next:
    goto loop1976_test
  loop1976_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1978, exception, 'type'
    eq $P1978, .CONTROL_LOOP_NEXT, loop1976_next
    eq $P1978, .CONTROL_LOOP_REDO, loop1976_redo
  loop1976_done:
    pop_eh 
  for_undef_379:
.annotate 'line', 850
    new $P1979, "Exception"
    set $P1979['type'], .CONTROL_RETURN
    new $P1980, "Integer"
    assign $P1980, 0
    setattribute $P1979, 'payload', $P1980
    throw $P1979
.annotate 'line', 845
    .return ()
  control_1949:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1981, exception, "payload"
    .return ($P1981)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block1964"  :anon :subid("135_1298839204.312") :outer("134_1298839204.312")
    .param pmc param_1966
.annotate 'line', 847
    .lex "$_", param_1966
.annotate 'line', 848
    find_lex $P1969, "$_"
    set $S1970, $P1969
    find_lex $P1971, "$name"
    set $S1972, $P1971
    iseq $I1973, $S1970, $S1972
    if $I1973, if_1968
    new $P1967, 'Integer'
    set $P1967, $I1973
    goto if_1968_end
  if_1968:
    new $P1974, "Exception"
    set $P1974['type'], .CONTROL_RETURN
    new $P1975, "Integer"
    assign $P1975, 1
    setattribute $P1974, 'payload', $P1975
    throw $P1974
  if_1968_end:
.annotate 'line', 847
    .return ($P1967)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_attribute"  :subid("136_1298839204.312") :outer("133_1298839204.312")
    .param pmc param_1986
    .param pmc param_1987
.annotate 'line', 853
    .const 'Sub' $P1998 = "137_1298839204.312" 
    capture_lex $P1998
    new $P1985, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1985, control_1984
    push_eh $P1985
    .lex "$target", param_1986
    .lex "$name", param_1987
.annotate 'line', 854
    $P1988 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P1988
    find_lex $P1989, "$target"
    get_how $P1990, $P1989
    find_lex $P1991, "$target"
    $P1992 = $P1990."attributes"($P1991, 1 :named("local"))
    store_lex "@attributes", $P1992
.annotate 'line', 855
    find_lex $P1994, "@attributes"
    defined $I1995, $P1994
    unless $I1995, for_undef_380
    iter $P1993, $P1994
    new $P2010, 'ExceptionHandler'
    set_label $P2010, loop2009_handler
    $P2010."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2010
  loop2009_test:
    unless $P1993, loop2009_done
    shift $P1996, $P1993
  loop2009_redo:
    .const 'Sub' $P1998 = "137_1298839204.312" 
    capture_lex $P1998
    $P1998($P1996)
  loop2009_next:
    goto loop2009_test
  loop2009_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2011, exception, 'type'
    eq $P2011, .CONTROL_LOOP_NEXT, loop2009_next
    eq $P2011, .CONTROL_LOOP_REDO, loop2009_redo
  loop2009_done:
    pop_eh 
  for_undef_380:
.annotate 'line', 858
    new $P2012, "Exception"
    set $P2012['type'], .CONTROL_RETURN
    new $P2013, "Integer"
    assign $P2013, 0
    setattribute $P2012, 'payload', $P2013
    throw $P2012
.annotate 'line', 853
    .return ()
  control_1984:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2014, exception, "payload"
    .return ($P2014)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block1997"  :anon :subid("137_1298839204.312") :outer("136_1298839204.312")
    .param pmc param_1999
.annotate 'line', 855
    .lex "$_", param_1999
.annotate 'line', 856
    find_lex $P2002, "$_"
    $S2003 = $P2002."name"()
    find_lex $P2004, "$name"
    set $S2005, $P2004
    iseq $I2006, $S2003, $S2005
    if $I2006, if_2001
    new $P2000, 'Integer'
    set $P2000, $I2006
    goto if_2001_end
  if_2001:
    new $P2007, "Exception"
    set $P2007['type'], .CONTROL_RETURN
    new $P2008, "Integer"
    assign $P2008, 1
    setattribute $P2007, 'payload', $P2008
    throw $P2007
  if_2001_end:
.annotate 'line', 855
    .return ($P2000)
.end


.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("138_1298839204.312") :outer("133_1298839204.312")
    .param pmc param_2019
    .param pmc param_2020
    .param pmc param_2021
.annotate 'line', 861
    .const 'Sub' $P2123 = "142_1298839204.312" 
    capture_lex $P2123
    .const 'Sub' $P2097 = "141_1298839204.312" 
    capture_lex $P2097
    .const 'Sub' $P2068 = "140_1298839204.312" 
    capture_lex $P2068
    .const 'Sub' $P2048 = "139_1298839204.312" 
    capture_lex $P2048
    .lex "self", param_2019
    .lex "$target", param_2020
    .lex "@roles", param_2021
.annotate 'line', 864
    new $P2022, "Undef"
    .lex "$to_compose", $P2022
.annotate 'line', 865
    new $P2023, "Undef"
    .lex "$to_compose_meta", $P2023
.annotate 'line', 880
    $P2024 = root_new ['parrot';'ResizablePMCArray']
    .lex "@collisions", $P2024
.annotate 'line', 889
    $P2025 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2025
.annotate 'line', 897
    $P2026 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2026
.annotate 'line', 909
    $P2027 = root_new ['parrot';'ResizablePMCArray']
    .lex "@done", $P2027
.annotate 'line', 861
    find_lex $P2028, "$to_compose"
    find_lex $P2029, "$to_compose_meta"
.annotate 'line', 866
    find_lex $P2031, "@roles"
    set $N2032, $P2031
    iseq $I2033, $N2032, 1.0
    if $I2033, if_2030
.annotate 'line', 871
    get_hll_global $P2038, "NQPConcreteRoleHOW"
    get_hll_global $P2039, "NQPMu"
    $P2040 = $P2038."new_type"($P2039 :named("instance_of"))
    store_lex "$to_compose", $P2040
.annotate 'line', 872
    find_lex $P2041, "$to_compose"
    get_how $P2042, $P2041
    store_lex "$to_compose_meta", $P2042
.annotate 'line', 873
    find_lex $P2044, "@roles"
    defined $I2045, $P2044
    unless $I2045, for_undef_381
    iter $P2043, $P2044
    new $P2055, 'ExceptionHandler'
    set_label $P2055, loop2054_handler
    $P2055."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2055
  loop2054_test:
    unless $P2043, loop2054_done
    shift $P2046, $P2043
  loop2054_redo:
    .const 'Sub' $P2048 = "139_1298839204.312" 
    capture_lex $P2048
    $P2048($P2046)
  loop2054_next:
    goto loop2054_test
  loop2054_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2056, exception, 'type'
    eq $P2056, .CONTROL_LOOP_NEXT, loop2054_next
    eq $P2056, .CONTROL_LOOP_REDO, loop2054_redo
  loop2054_done:
    pop_eh 
  for_undef_381:
.annotate 'line', 876
    find_lex $P2057, "$to_compose_meta"
    find_lex $P2058, "$to_compose"
    $P2059 = $P2057."compose"($P2058)
    store_lex "$to_compose", $P2059
.annotate 'line', 870
    goto if_2030_end
  if_2030:
.annotate 'line', 867
    find_lex $P2034, "@roles"
    unless_null $P2034, vivify_382
    $P2034 = root_new ['parrot';'ResizablePMCArray']
  vivify_382:
    set $P2035, $P2034[0]
    unless_null $P2035, vivify_383
    new $P2035, "Undef"
  vivify_383:
    store_lex "$to_compose", $P2035
.annotate 'line', 868
    find_lex $P2036, "$to_compose"
    get_how $P2037, $P2036
    store_lex "$to_compose_meta", $P2037
  if_2030_end:
.annotate 'line', 880
    find_lex $P2060, "$to_compose_meta"
    find_lex $P2061, "$to_compose"
    $P2062 = $P2060."collisions"($P2061)
    store_lex "@collisions", $P2062
.annotate 'line', 881
    find_lex $P2064, "@collisions"
    defined $I2065, $P2064
    unless $I2065, for_undef_384
    iter $P2063, $P2064
    new $P2087, 'ExceptionHandler'
    set_label $P2087, loop2086_handler
    $P2087."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2087
  loop2086_test:
    unless $P2063, loop2086_done
    shift $P2066, $P2063
  loop2086_redo:
    .const 'Sub' $P2068 = "140_1298839204.312" 
    capture_lex $P2068
    $P2068($P2066)
  loop2086_next:
    goto loop2086_test
  loop2086_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2088, exception, 'type'
    eq $P2088, .CONTROL_LOOP_NEXT, loop2086_next
    eq $P2088, .CONTROL_LOOP_REDO, loop2086_redo
  loop2086_done:
    pop_eh 
  for_undef_384:
.annotate 'line', 889
    find_lex $P2089, "$to_compose_meta"
    find_lex $P2090, "$to_compose"
    $P2091 = $P2089."methods"($P2090)
    store_lex "@methods", $P2091
.annotate 'line', 890
    find_lex $P2093, "@methods"
    defined $I2094, $P2093
    unless $I2094, for_undef_385
    iter $P2092, $P2093
    new $P2113, 'ExceptionHandler'
    set_label $P2113, loop2112_handler
    $P2113."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2113
  loop2112_test:
    unless $P2092, loop2112_done
    shift $P2095, $P2092
  loop2112_redo:
    .const 'Sub' $P2097 = "141_1298839204.312" 
    capture_lex $P2097
    $P2097($P2095)
  loop2112_next:
    goto loop2112_test
  loop2112_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2114, exception, 'type'
    eq $P2114, .CONTROL_LOOP_NEXT, loop2112_next
    eq $P2114, .CONTROL_LOOP_REDO, loop2112_redo
  loop2112_done:
    pop_eh 
  for_undef_385:
.annotate 'line', 897
    find_lex $P2115, "$to_compose_meta"
    find_lex $P2116, "$to_compose"
    $P2117 = $P2115."attributes"($P2116)
    store_lex "@attributes", $P2117
.annotate 'line', 898
    find_lex $P2119, "@attributes"
    defined $I2120, $P2119
    unless $I2120, for_undef_386
    iter $P2118, $P2119
    new $P2147, 'ExceptionHandler'
    set_label $P2147, loop2146_handler
    $P2147."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2147
  loop2146_test:
    unless $P2118, loop2146_done
    shift $P2121, $P2118
  loop2146_redo:
    .const 'Sub' $P2123 = "142_1298839204.312" 
    capture_lex $P2123
    $P2123($P2121)
  loop2146_next:
    goto loop2146_test
  loop2146_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2148, exception, 'type'
    eq $P2148, .CONTROL_LOOP_NEXT, loop2146_next
    eq $P2148, .CONTROL_LOOP_REDO, loop2146_redo
  loop2146_done:
    pop_eh 
  for_undef_386:
    find_lex $P2149, "@done"
.annotate 'line', 910
    find_lex $P2150, "$to_compose"
    find_lex $P2151, "@done"
    unless_null $P2151, vivify_387
    $P2151 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@done", $P2151
  vivify_387:
    set $P2151[0], $P2150
.annotate 'line', 861
    .return ($P2150)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2047"  :anon :subid("139_1298839204.312") :outer("138_1298839204.312")
    .param pmc param_2049
.annotate 'line', 873
    .lex "$_", param_2049
.annotate 'line', 874
    find_lex $P2050, "$to_compose_meta"
    find_lex $P2051, "$to_compose"
    find_lex $P2052, "$_"
    $P2053 = $P2050."add_role"($P2051, $P2052)
.annotate 'line', 873
    .return ($P2053)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2067"  :anon :subid("140_1298839204.312") :outer("138_1298839204.312")
    .param pmc param_2069
.annotate 'line', 881
    .lex "$_", param_2069
.annotate 'line', 882
    find_lex $P2072, "$target"
    find_lex $P2073, "$_"
    set $S2074, $P2073
    $P2075 = "has_method"($P2072, $S2074, 1)
    unless $P2075, unless_2071
    set $P2070, $P2075
    goto unless_2071_end
  unless_2071:
.annotate 'line', 883
    new $P2076, 'String'
    set $P2076, "Method '"
    find_lex $P2077, "$_"
    concat $P2078, $P2076, $P2077
    concat $P2079, $P2078, "' collides and a resolution must be provided by the class '"
.annotate 'line', 884
    find_lex $P2080, "$target"
    get_how $P2081, $P2080
    find_lex $P2082, "$target"
    $S2083 = $P2081."name"($P2082)
    concat $P2084, $P2079, $S2083
.annotate 'line', 883
    concat $P2085, $P2084, "'"
.annotate 'line', 884
    die $P2085
  unless_2071_end:
.annotate 'line', 881
    .return ($P2070)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2096"  :anon :subid("141_1298839204.312") :outer("138_1298839204.312")
    .param pmc param_2098
.annotate 'line', 890
    .lex "$_", param_2098
.annotate 'line', 891
    find_lex $P2101, "$target"
    find_lex $P2102, "$_"
    set $S2103, $P2102
    $P2104 = "has_method"($P2101, $S2103, 0)
    unless $P2104, unless_2100
    set $P2099, $P2104
    goto unless_2100_end
  unless_2100:
.annotate 'line', 892
    find_lex $P2105, "$target"
    get_how $P2106, $P2105
    find_lex $P2107, "$target"
    find_lex $P2108, "$_"
    set $S2109, $P2108
    find_lex $P2110, "$_"
    $P2111 = $P2106."add_method"($P2107, $S2109, $P2110)
.annotate 'line', 891
    set $P2099, $P2111
  unless_2100_end:
.annotate 'line', 890
    .return ($P2099)
.end


.namespace ["RoleToClassApplier"]
.sub "_block2122"  :anon :subid("142_1298839204.312") :outer("138_1298839204.312")
    .param pmc param_2124
.annotate 'line', 898
    .lex "$_", param_2124
.annotate 'line', 899
    find_lex $P2126, "$target"
    find_lex $P2127, "$_"
    $P2128 = $P2127."name"()
    $P2129 = "has_attribute"($P2126, $P2128)
    unless $P2129, if_2125_end
.annotate 'line', 900
    new $P2130, "String"
    assign $P2130, "Attribute '"
    find_lex $P2131, "$_"
    $S2132 = $P2131."name"()
    concat $P2133, $P2130, $S2132
    concat $P2134, $P2133, "' already exists in the class '"
.annotate 'line', 901
    find_lex $P2135, "$target"
    get_how $P2136, $P2135
    find_lex $P2137, "$target"
    $S2138 = $P2136."name"($P2137)
    concat $P2139, $P2134, $S2138
.annotate 'line', 900
    concat $P2140, $P2139, "', but a role also wishes to compose it"
.annotate 'line', 901
    die $P2140
  if_2125_end:
.annotate 'line', 903
    find_lex $P2141, "$target"
    get_how $P2142, $P2141
    find_lex $P2143, "$target"
    find_lex $P2144, "$_"
    $P2145 = $P2142."add_attribute"($P2143, $P2144)
.annotate 'line', 898
    .return ($P2145)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2161"  :subid("144_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 915
    .const 'Sub' $P2384 = "154_1298839204.312" 
    capture_lex $P2384
    .const 'Sub' $P2164 = "145_1298839204.312" 
    capture_lex $P2164
    get_global $P2163, "$?CLASS"
.annotate 'line', 916
    .const 'Sub' $P2164 = "145_1298839204.312" 
    newclosure $P2382, $P2164
.annotate 'line', 915
    .return ($P2382)
.end


.namespace ["RoleToRoleApplier"]
.sub "" :load :init :subid("post388") :outer("144_1298839204.312")
.annotate 'line', 915
    get_hll_global $P2162, ["RoleToRoleApplier"], "_block2161" 
    .local pmc block
    set block, $P2162
    .const 'Sub' $P2384 = "154_1298839204.312" 
    capture_lex $P2384
    $P2384()
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2383"  :anon :subid("154_1298839204.312") :outer("144_1298839204.312")
.annotate 'line', 915
    get_hll_global $P2385, "KnowHOW"
    $P2386 = $P2385."new_type"("RoleToRoleApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2386
    set_hll_global "RoleToRoleApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2387, type_obj
    .const 'Sub' $P2388 = "145_1298839204.312" 
    $P2387."add_method"(type_obj, "apply", $P2388)
    get_how $P2389, type_obj
    $P2390 = $P2389."compose"(type_obj)
    .return ($P2390)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("145_1298839204.312") :outer("144_1298839204.312")
    .param pmc param_2167
    .param pmc param_2168
    .param pmc param_2169
.annotate 'line', 916
    .const 'Sub' $P2309 = "151_1298839204.312" 
    capture_lex $P2309
    .const 'Sub' $P2267 = "150_1298839204.312" 
    capture_lex $P2267
    .const 'Sub' $P2253 = "149_1298839204.312" 
    capture_lex $P2253
    .const 'Sub' $P2180 = "146_1298839204.312" 
    capture_lex $P2180
    new $P2166, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2166, control_2165
    push_eh $P2166
    .lex "self", param_2167
    .lex "$target", param_2168
    .lex "@roles", param_2169
.annotate 'line', 918
    $P2170 = root_new ['parrot';'Hash']
    .lex "%meth_info", $P2170
.annotate 'line', 944
    $P2171 = root_new ['parrot';'Hash']
    .lex "%target_meth_info", $P2171
.annotate 'line', 945
    $P2172 = root_new ['parrot';'ResizablePMCArray']
    .lex "@target_meths", $P2172
.annotate 'line', 970
    $P2173 = root_new ['parrot';'ResizablePMCArray']
    .lex "@all_roles", $P2173
.annotate 'line', 916
    find_lex $P2174, "%meth_info"
.annotate 'line', 919
    find_lex $P2176, "@roles"
    defined $I2177, $P2176
    unless $I2177, for_undef_389
    iter $P2175, $P2176
    new $P2241, 'ExceptionHandler'
    set_label $P2241, loop2240_handler
    $P2241."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2241
  loop2240_test:
    unless $P2175, loop2240_done
    shift $P2178, $P2175
  loop2240_redo:
    .const 'Sub' $P2180 = "146_1298839204.312" 
    capture_lex $P2180
    $P2180($P2178)
  loop2240_next:
    goto loop2240_test
  loop2240_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2242, exception, 'type'
    eq $P2242, .CONTROL_LOOP_NEXT, loop2240_next
    eq $P2242, .CONTROL_LOOP_REDO, loop2240_redo
  loop2240_done:
    pop_eh 
  for_undef_389:
    find_lex $P2243, "%target_meth_info"
.annotate 'line', 945
    find_lex $P2244, "$target"
    get_how $P2245, $P2244
    find_lex $P2246, "$target"
    $P2247 = $P2245."methods"($P2246)
    store_lex "@target_meths", $P2247
.annotate 'line', 946
    find_lex $P2249, "@target_meths"
    defined $I2250, $P2249
    unless $I2250, for_undef_397
    iter $P2248, $P2249
    new $P2260, 'ExceptionHandler'
    set_label $P2260, loop2259_handler
    $P2260."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2260
  loop2259_test:
    unless $P2248, loop2259_done
    shift $P2251, $P2248
  loop2259_redo:
    .const 'Sub' $P2253 = "149_1298839204.312" 
    capture_lex $P2253
    $P2253($P2251)
  loop2259_next:
    goto loop2259_test
  loop2259_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2261, exception, 'type'
    eq $P2261, .CONTROL_LOOP_NEXT, loop2259_next
    eq $P2261, .CONTROL_LOOP_REDO, loop2259_redo
  loop2259_done:
    pop_eh 
  for_undef_397:
.annotate 'line', 951
    find_lex $P2263, "%meth_info"
    defined $I2264, $P2263
    unless $I2264, for_undef_399
    iter $P2262, $P2263
    new $P2301, 'ExceptionHandler'
    set_label $P2301, loop2300_handler
    $P2301."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2301
  loop2300_test:
    unless $P2262, loop2300_done
    shift $P2265, $P2262
  loop2300_redo:
    .const 'Sub' $P2267 = "150_1298839204.312" 
    capture_lex $P2267
    $P2267($P2265)
  loop2300_next:
    goto loop2300_test
  loop2300_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2302, exception, 'type'
    eq $P2302, .CONTROL_LOOP_NEXT, loop2300_next
    eq $P2302, .CONTROL_LOOP_REDO, loop2300_redo
  loop2300_done:
    pop_eh 
  for_undef_399:
    find_lex $P2303, "@all_roles"
.annotate 'line', 971
    find_lex $P2305, "@roles"
    defined $I2306, $P2305
    unless $I2306, for_undef_406
    iter $P2304, $P2305
    new $P2377, 'ExceptionHandler'
    set_label $P2377, loop2376_handler
    $P2377."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2377
  loop2376_test:
    unless $P2304, loop2376_done
    shift $P2307, $P2304
  loop2376_redo:
    .const 'Sub' $P2309 = "151_1298839204.312" 
    capture_lex $P2309
    $P2309($P2307)
  loop2376_next:
    goto loop2376_test
  loop2376_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2378, exception, 'type'
    eq $P2378, .CONTROL_LOOP_NEXT, loop2376_next
    eq $P2378, .CONTROL_LOOP_REDO, loop2376_redo
  loop2376_done:
    pop_eh 
  for_undef_406:
.annotate 'line', 1000
    new $P2379, "Exception"
    set $P2379['type'], .CONTROL_RETURN
    find_lex $P2380, "@all_roles"
    setattribute $P2379, 'payload', $P2380
    throw $P2379
.annotate 'line', 916
    .return ()
  control_2165:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2381, exception, "payload"
    .return ($P2381)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2179"  :anon :subid("146_1298839204.312") :outer("145_1298839204.312")
    .param pmc param_2182
.annotate 'line', 919
    .const 'Sub' $P2192 = "147_1298839204.312" 
    capture_lex $P2192
.annotate 'line', 920
    $P2181 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2181
    .lex "$_", param_2182
    find_lex $P2183, "$_"
    get_how $P2184, $P2183
    find_lex $P2185, "$_"
    $P2186 = $P2184."methods"($P2185)
    store_lex "@methods", $P2186
.annotate 'line', 921
    find_lex $P2188, "@methods"
    defined $I2189, $P2188
    unless $I2189, for_undef_390
    iter $P2187, $P2188
    new $P2238, 'ExceptionHandler'
    set_label $P2238, loop2237_handler
    $P2238."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2238
  loop2237_test:
    unless $P2187, loop2237_done
    shift $P2190, $P2187
  loop2237_redo:
    .const 'Sub' $P2192 = "147_1298839204.312" 
    capture_lex $P2192
    $P2192($P2190)
  loop2237_next:
    goto loop2237_test
  loop2237_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2239, exception, 'type'
    eq $P2239, .CONTROL_LOOP_NEXT, loop2237_next
    eq $P2239, .CONTROL_LOOP_REDO, loop2237_redo
  loop2237_done:
    pop_eh 
  for_undef_390:
.annotate 'line', 919
    .return ($P2187)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2191"  :anon :subid("147_1298839204.312") :outer("146_1298839204.312")
    .param pmc param_2197
.annotate 'line', 921
    .const 'Sub' $P2220 = "148_1298839204.312" 
    capture_lex $P2220
.annotate 'line', 922
    new $P2193, "Undef"
    .lex "$name", $P2193
.annotate 'line', 923
    new $P2194, "Undef"
    .lex "$meth", $P2194
.annotate 'line', 924
    $P2195 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meth_list", $P2195
.annotate 'line', 931
    new $P2196, "Undef"
    .lex "$found", $P2196
    .lex "$_", param_2197
.annotate 'line', 922
    find_lex $P2198, "$_"
    set $S2199, $P2198
    new $P2200, 'String'
    set $P2200, $S2199
    store_lex "$name", $P2200
.annotate 'line', 923
    find_lex $P2201, "$_"
    store_lex "$meth", $P2201
    find_lex $P2202, "@meth_list"
.annotate 'line', 925
    find_lex $P2204, "$name"
    find_lex $P2205, "%meth_info"
    unless_null $P2205, vivify_391
    $P2205 = root_new ['parrot';'Hash']
  vivify_391:
    set $P2206, $P2205[$P2204]
    unless_null $P2206, vivify_392
    new $P2206, "Undef"
  vivify_392:
    defined $I2207, $P2206
    if $I2207, if_2203
.annotate 'line', 929
    find_lex $P2211, "@meth_list"
    find_lex $P2212, "$name"
    find_lex $P2213, "%meth_info"
    unless_null $P2213, vivify_393
    $P2213 = root_new ['parrot';'Hash']
    store_lex "%meth_info", $P2213
  vivify_393:
    set $P2213[$P2212], $P2211
.annotate 'line', 928
    goto if_2203_end
  if_2203:
.annotate 'line', 926
    find_lex $P2208, "$name"
    find_lex $P2209, "%meth_info"
    unless_null $P2209, vivify_394
    $P2209 = root_new ['parrot';'Hash']
  vivify_394:
    set $P2210, $P2209[$P2208]
    unless_null $P2210, vivify_395
    new $P2210, "Undef"
  vivify_395:
    store_lex "@meth_list", $P2210
  if_2203_end:
.annotate 'line', 931
    new $P2214, "Integer"
    assign $P2214, 0
    store_lex "$found", $P2214
.annotate 'line', 932
    find_lex $P2216, "@meth_list"
    defined $I2217, $P2216
    unless $I2217, for_undef_396
    iter $P2215, $P2216
    new $P2229, 'ExceptionHandler'
    set_label $P2229, loop2228_handler
    $P2229."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2229
  loop2228_test:
    unless $P2215, loop2228_done
    shift $P2218, $P2215
  loop2228_redo:
    .const 'Sub' $P2220 = "148_1298839204.312" 
    capture_lex $P2220
    $P2220($P2218)
  loop2228_next:
    goto loop2228_test
  loop2228_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2230, exception, 'type'
    eq $P2230, .CONTROL_LOOP_NEXT, loop2228_next
    eq $P2230, .CONTROL_LOOP_REDO, loop2228_redo
  loop2228_done:
    pop_eh 
  for_undef_396:
.annotate 'line', 937
    find_lex $P2233, "$found"
    unless $P2233, unless_2232
    set $P2231, $P2233
    goto unless_2232_end
  unless_2232:
.annotate 'line', 938
    find_lex $P2234, "@meth_list"
    find_lex $P2235, "$meth"
    $P2236 = $P2234."push"($P2235)
.annotate 'line', 937
    set $P2231, $P2236
  unless_2232_end:
.annotate 'line', 921
    .return ($P2231)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2219"  :anon :subid("148_1298839204.312") :outer("147_1298839204.312")
    .param pmc param_2221
.annotate 'line', 932
    .lex "$_", param_2221
.annotate 'line', 933
    find_lex $P2224, "$meth"
    find_lex $P2225, "$_"
    issame $I2226, $P2224, $P2225
    if $I2226, if_2223
    new $P2222, 'Integer'
    set $P2222, $I2226
    goto if_2223_end
  if_2223:
.annotate 'line', 934
    new $P2227, "Integer"
    assign $P2227, 1
    store_lex "$found", $P2227
.annotate 'line', 933
    set $P2222, $P2227
  if_2223_end:
.annotate 'line', 932
    .return ($P2222)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2252"  :anon :subid("149_1298839204.312") :outer("145_1298839204.312")
    .param pmc param_2254
.annotate 'line', 946
    .lex "$_", param_2254
.annotate 'line', 947
    find_lex $P2255, "$_"
    find_lex $P2256, "$_"
    set $S2257, $P2256
    find_lex $P2258, "%target_meth_info"
    unless_null $P2258, vivify_398
    $P2258 = root_new ['parrot';'Hash']
    store_lex "%target_meth_info", $P2258
  vivify_398:
    set $P2258[$S2257], $P2255
.annotate 'line', 946
    .return ($P2255)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2266"  :anon :subid("150_1298839204.312") :outer("145_1298839204.312")
    .param pmc param_2270
.annotate 'line', 952
    new $P2268, "Undef"
    .lex "$name", $P2268
.annotate 'line', 953
    $P2269 = root_new ['parrot';'ResizablePMCArray']
    .lex "@add_meths", $P2269
    .lex "$_", param_2270
.annotate 'line', 952
    find_lex $P2271, "$_"
    set $S2272, $P2271
    new $P2273, 'String'
    set $P2273, $S2272
    store_lex "$name", $P2273
.annotate 'line', 953
    find_lex $P2274, "$name"
    find_lex $P2275, "%meth_info"
    unless_null $P2275, vivify_400
    $P2275 = root_new ['parrot';'Hash']
  vivify_400:
    set $P2276, $P2275[$P2274]
    unless_null $P2276, vivify_401
    new $P2276, "Undef"
  vivify_401:
    store_lex "@add_meths", $P2276
.annotate 'line', 957
    find_lex $P2279, "$name"
    find_lex $P2280, "%target_meth_info"
    unless_null $P2280, vivify_402
    $P2280 = root_new ['parrot';'Hash']
  vivify_402:
    set $P2281, $P2280[$P2279]
    unless_null $P2281, vivify_403
    new $P2281, "Undef"
  vivify_403:
    defined $I2282, $P2281
    unless $I2282, unless_2278
    new $P2277, 'Integer'
    set $P2277, $I2282
    goto unless_2278_end
  unless_2278:
.annotate 'line', 959
    find_lex $P2285, "@add_meths"
    set $N2286, $P2285
    iseq $I2287, $N2286, 1.0
    if $I2287, if_2284
.annotate 'line', 964
    find_lex $P2295, "$target"
    get_how $P2296, $P2295
    find_lex $P2297, "$target"
    find_lex $P2298, "$name"
    $P2299 = $P2296."add_collision"($P2297, $P2298)
.annotate 'line', 962
    set $P2283, $P2299
.annotate 'line', 959
    goto if_2284_end
  if_2284:
.annotate 'line', 960
    find_lex $P2288, "$target"
    get_how $P2289, $P2288
    find_lex $P2290, "$target"
    find_lex $P2291, "$name"
    find_lex $P2292, "@add_meths"
    unless_null $P2292, vivify_404
    $P2292 = root_new ['parrot';'ResizablePMCArray']
  vivify_404:
    set $P2293, $P2292[0]
    unless_null $P2293, vivify_405
    new $P2293, "Undef"
  vivify_405:
    $P2294 = $P2289."add_method"($P2290, $P2291, $P2293)
.annotate 'line', 959
    set $P2283, $P2294
  if_2284_end:
.annotate 'line', 957
    set $P2277, $P2283
  unless_2278_end:
.annotate 'line', 951
    .return ($P2277)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2308"  :anon :subid("151_1298839204.312") :outer("145_1298839204.312")
    .param pmc param_2312
.annotate 'line', 971
    .const 'Sub' $P2323 = "152_1298839204.312" 
    capture_lex $P2323
.annotate 'line', 972
    new $P2310, "Undef"
    .lex "$how", $P2310
.annotate 'line', 975
    $P2311 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2311
    .lex "$_", param_2312
.annotate 'line', 972
    find_lex $P2313, "$_"
    get_how $P2314, $P2313
    store_lex "$how", $P2314
.annotate 'line', 975
    find_lex $P2315, "$how"
    find_lex $P2316, "$_"
    $P2317 = $P2315."attributes"($P2316)
    store_lex "@attributes", $P2317
.annotate 'line', 976
    find_lex $P2319, "@attributes"
    defined $I2320, $P2319
    unless $I2320, for_undef_407
    iter $P2318, $P2319
    new $P2371, 'ExceptionHandler'
    set_label $P2371, loop2370_handler
    $P2371."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2371
  loop2370_test:
    unless $P2318, loop2370_done
    shift $P2321, $P2318
  loop2370_redo:
    .const 'Sub' $P2323 = "152_1298839204.312" 
    capture_lex $P2323
    $P2323($P2321)
  loop2370_next:
    goto loop2370_test
  loop2370_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2372, exception, 'type'
    eq $P2372, .CONTROL_LOOP_NEXT, loop2370_next
    eq $P2372, .CONTROL_LOOP_REDO, loop2370_redo
  loop2370_done:
    pop_eh 
  for_undef_407:
.annotate 'line', 997
    find_lex $P2373, "@all_roles"
    find_lex $P2374, "$_"
    $P2375 = $P2373."push"($P2374)
.annotate 'line', 971
    .return ($P2375)
.end


.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2322"  :anon :subid("152_1298839204.312") :outer("151_1298839204.312")
    .param pmc param_2327
.annotate 'line', 976
    .const 'Sub' $P2339 = "153_1298839204.312" 
    capture_lex $P2339
.annotate 'line', 977
    new $P2324, "Undef"
    .lex "$add_attr", $P2324
.annotate 'line', 978
    new $P2325, "Undef"
    .lex "$skip", $P2325
.annotate 'line', 979
    $P2326 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cur_attrs", $P2326
    .lex "$_", param_2327
.annotate 'line', 977
    find_lex $P2328, "$_"
    store_lex "$add_attr", $P2328
.annotate 'line', 978
    new $P2329, "Integer"
    assign $P2329, 0
    store_lex "$skip", $P2329
.annotate 'line', 979
    find_lex $P2330, "$target"
    get_how $P2331, $P2330
    find_lex $P2332, "$target"
    $P2333 = $P2331."attributes"($P2332)
    store_lex "@cur_attrs", $P2333
.annotate 'line', 980
    find_lex $P2335, "@cur_attrs"
    defined $I2336, $P2335
    unless $I2336, for_undef_408
    iter $P2334, $P2335
    new $P2360, 'ExceptionHandler'
    set_label $P2360, loop2359_handler
    $P2360."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2360
  loop2359_test:
    unless $P2334, loop2359_done
    shift $P2337, $P2334
  loop2359_redo:
    .const 'Sub' $P2339 = "153_1298839204.312" 
    capture_lex $P2339
    $P2339($P2337)
  loop2359_next:
    goto loop2359_test
  loop2359_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2361, exception, 'type'
    eq $P2361, .CONTROL_LOOP_NEXT, loop2359_next
    eq $P2361, .CONTROL_LOOP_REDO, loop2359_redo
  loop2359_done:
    pop_eh 
  for_undef_408:
.annotate 'line', 990
    find_lex $P2364, "$skip"
    unless $P2364, unless_2363
    set $P2362, $P2364
    goto unless_2363_end
  unless_2363:
.annotate 'line', 991
    find_lex $P2365, "$target"
    get_how $P2366, $P2365
    find_lex $P2367, "$target"
    find_lex $P2368, "$add_attr"
    $P2369 = $P2366."add_attribute"($P2367, $P2368)
.annotate 'line', 990
    set $P2362, $P2369
  unless_2363_end:
.annotate 'line', 976
    .return ($P2362)
.end


.namespace ["RoleToRoleApplier"]
.sub "_block2338"  :anon :subid("153_1298839204.312") :outer("152_1298839204.312")
    .param pmc param_2340
.annotate 'line', 980
    .lex "$_", param_2340
.annotate 'line', 981
    find_lex $P2343, "$_"
    find_lex $P2344, "$add_attr"
    issame $I2345, $P2343, $P2344
    if $I2345, if_2342
.annotate 'line', 985
    find_lex $P2349, "$_"
    $S2350 = $P2349."name"()
    find_lex $P2351, "$add_attr"
    $S2352 = $P2351."name"()
    iseq $I2353, $S2350, $S2352
    if $I2353, if_2348
    new $P2347, 'Integer'
    set $P2347, $I2353
    goto if_2348_end
  if_2348:
.annotate 'line', 986
    new $P2354, "String"
    assign $P2354, "Attribute '"
    find_lex $P2355, "$_"
    $S2356 = $P2355."name"()
    concat $P2357, $P2354, $S2356
    concat $P2358, $P2357, "' conflicts in role composition"
    die $P2358
  if_2348_end:
.annotate 'line', 984
    set $P2341, $P2347
.annotate 'line', 981
    goto if_2342_end
  if_2342:
.annotate 'line', 982
    new $P2346, "Integer"
    assign $P2346, 1
    store_lex "$skip", $P2346
.annotate 'line', 981
    set $P2341, $P2346
  if_2342_end:
.annotate 'line', 980
    .return ($P2341)
.end


.namespace ["NQPModuleHOW"]
.sub "_block2391"  :subid("155_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 1005
    .const 'Sub' $P2453 = "164_1298839204.312" 
    capture_lex $P2453
    .const 'Sub' $P2445 = "163_1298839204.312" 
    capture_lex $P2445
    .const 'Sub' $P2439 = "162_1298839204.312" 
    capture_lex $P2439
    .const 'Sub' $P2435 = "161_1298839204.312" 
    capture_lex $P2435
    .const 'Sub' $P2430 = "160_1298839204.312" 
    capture_lex $P2430
    .const 'Sub' $P2425 = "159_1298839204.312" 
    capture_lex $P2425
    .const 'Sub' $P2411 = "158_1298839204.312" 
    capture_lex $P2411
    .const 'Sub' $P2404 = "157_1298839204.312" 
    capture_lex $P2404
    .const 'Sub' $P2394 = "156_1298839204.312" 
    capture_lex $P2394
    get_global $P2393, "$?CLASS"
.annotate 'line', 1044
    .const 'Sub' $P2445 = "163_1298839204.312" 
    newclosure $P2451, $P2445
.annotate 'line', 1005
    .return ($P2451)
.end


.namespace ["NQPModuleHOW"]
.sub "" :load :init :subid("post409") :outer("155_1298839204.312")
.annotate 'line', 1005
    get_hll_global $P2392, ["NQPModuleHOW"], "_block2391" 
    .local pmc block
    set block, $P2392
    .const 'Sub' $P2453 = "164_1298839204.312" 
    capture_lex $P2453
    $P2453()
.end


.namespace ["NQPModuleHOW"]
.sub "_block2452"  :anon :subid("164_1298839204.312") :outer("155_1298839204.312")
.annotate 'line', 1005
    get_hll_global $P2454, "KnowHOW"
    $P2455 = $P2454."new_type"("NQPModuleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2455
    set_hll_global "NQPModuleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2456, type_obj
    get_hll_global $P2457, "KnowHOWAttribute"
    $P2458 = $P2457."new"("$!name" :named("name"))
    $P2456."add_attribute"(type_obj, $P2458)
    get_how $P2459, type_obj
    get_hll_global $P2460, "KnowHOWAttribute"
    $P2461 = $P2460."new"("$!composed" :named("name"))
    $P2459."add_attribute"(type_obj, $P2461)
    get_how $P2462, type_obj
    .const 'Sub' $P2463 = "156_1298839204.312" 
    $P2462."add_method"(type_obj, "new", $P2463)
    get_how $P2464, type_obj
    .const 'Sub' $P2465 = "157_1298839204.312" 
    $P2464."add_method"(type_obj, "BUILD", $P2465)
    get_how $P2466, type_obj
    .const 'Sub' $P2467 = "158_1298839204.312" 
    $P2466."add_method"(type_obj, "new_type", $P2467)
    get_how $P2468, type_obj
    .const 'Sub' $P2469 = "159_1298839204.312" 
    $P2468."add_method"(type_obj, "add_method", $P2469)
    get_how $P2470, type_obj
    .const 'Sub' $P2471 = "160_1298839204.312" 
    $P2470."add_method"(type_obj, "add_multi_method", $P2471)
    get_how $P2472, type_obj
    .const 'Sub' $P2473 = "161_1298839204.312" 
    $P2472."add_method"(type_obj, "add_attribute", $P2473)
    get_how $P2474, type_obj
    .const 'Sub' $P2475 = "162_1298839204.312" 
    $P2474."add_method"(type_obj, "compose", $P2475)
    get_how $P2476, type_obj
    .const 'Sub' $P2477 = "163_1298839204.312" 
    $P2476."add_method"(type_obj, "name", $P2477)
    get_how $P2478, type_obj
    $P2479 = $P2478."compose"(type_obj)
    .return ($P2479)
.end


.namespace ["NQPModuleHOW"]
.sub "new"  :subid("156_1298839204.312") :outer("155_1298839204.312")
    .param pmc param_2395
    .param pmc param_2396 :optional :named("name")
    .param int has_param_2396 :opt_flag
.annotate 'line', 1009
    .lex "self", param_2395
    if has_param_2396, optparam_410
    new $P2397, "Undef"
    set param_2396, $P2397
  optparam_410:
    .lex "$name", param_2396
.annotate 'line', 1010
    new $P2398, "Undef"
    .lex "$obj", $P2398
    find_lex $P2399, "self"
    repr_instance_of $P2400, $P2399
    store_lex "$obj", $P2400
.annotate 'line', 1011
    find_lex $P2401, "$obj"
    find_lex $P2402, "$name"
    $P2401."BUILD"($P2402 :named("name"))
    find_lex $P2403, "$obj"
.annotate 'line', 1009
    .return ($P2403)
.end


.namespace ["NQPModuleHOW"]
.sub "BUILD"  :subid("157_1298839204.312") :outer("155_1298839204.312")
    .param pmc param_2405
    .param pmc param_2406 :optional :named("name")
    .param int has_param_2406 :opt_flag
.annotate 'line', 1015
    .lex "self", param_2405
    if has_param_2406, optparam_411
    new $P2407, "Undef"
    set param_2406, $P2407
  optparam_411:
    .lex "$name", param_2406
.annotate 'line', 1016
    find_lex $P2408, "$name"
    find_lex $P2409, "self"
    get_global $P2410, "$?CLASS"
    setattribute $P2409, $P2410, "$!name", $P2408
.annotate 'line', 1015
    .return ($P2408)
.end


.namespace ["NQPModuleHOW"]
.sub "new_type"  :subid("158_1298839204.312") :outer("155_1298839204.312")
    .param pmc param_2412
    .param pmc param_2413 :optional :named("name")
    .param int has_param_2413 :opt_flag
    .param pmc param_2415 :optional :named("repr")
    .param int has_param_2415 :opt_flag
.annotate 'line', 1021
    .lex "self", param_2412
    if has_param_2413, optparam_412
    new $P2414, "String"
    assign $P2414, "<anon>"
    set param_2413, $P2414
  optparam_412:
    .lex "$name", param_2413
    if has_param_2415, optparam_413
    new $P2416, "String"
    assign $P2416, "P6opaque"
    set param_2415, $P2416
  optparam_413:
    .lex "$repr", param_2415
.annotate 'line', 1022
    new $P2417, "Undef"
    .lex "$metaclass", $P2417
    find_lex $P2418, "self"
    find_lex $P2419, "$name"
    $P2420 = $P2418."new"($P2419 :named("name"))
    store_lex "$metaclass", $P2420
.annotate 'line', 1023
    find_lex $P2421, "$metaclass"
    find_lex $P2422, "$repr"
    set $S2423, $P2422
    repr_type_object_for $P2424, $P2421, $S2423
.annotate 'line', 1021
    .return ($P2424)
.end


.namespace ["NQPModuleHOW"]
.sub "add_method"  :subid("159_1298839204.312") :outer("155_1298839204.312")
    .param pmc param_2426
    .param pmc param_2427
    .param pmc param_2428
    .param pmc param_2429
.annotate 'line', 1026
    .lex "self", param_2426
    .lex "$obj", param_2427
    .lex "$name", param_2428
    .lex "$code_obj", param_2429
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "add_multi_method"  :subid("160_1298839204.312") :outer("155_1298839204.312")
    .param pmc param_2431
    .param pmc param_2432
    .param pmc param_2433
    .param pmc param_2434
.annotate 'line', 1032
    .lex "self", param_2431
    .lex "$obj", param_2432
    .lex "$name", param_2433
    .lex "$code_obj", param_2434
.annotate 'line', 1033
    die "Modules may not have methods"
.annotate 'line', 1032
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "add_attribute"  :subid("161_1298839204.312") :outer("155_1298839204.312")
    .param pmc param_2436
    .param pmc param_2437
    .param pmc param_2438
.annotate 'line', 1036
    .lex "self", param_2436
    .lex "$obj", param_2437
    .lex "$meta_attr", param_2438
.annotate 'line', 1037
    die "Modules may not have attributes"
.annotate 'line', 1036
    .return ()
.end


.namespace ["NQPModuleHOW"]
.sub "compose"  :subid("162_1298839204.312") :outer("155_1298839204.312")
    .param pmc param_2440
    .param pmc param_2441
.annotate 'line', 1040
    .lex "self", param_2440
    .lex "$obj", param_2441
.annotate 'line', 1041
    new $P2442, "Integer"
    assign $P2442, 1
    find_lex $P2443, "self"
    get_global $P2444, "$?CLASS"
    setattribute $P2443, $P2444, "$!composed", $P2442
.annotate 'line', 1040
    .return ($P2442)
.end


.namespace ["NQPModuleHOW"]
.sub "name"  :subid("163_1298839204.312") :outer("155_1298839204.312")
    .param pmc param_2446
    .param pmc param_2447
.annotate 'line', 1044
    .lex "self", param_2446
    .lex "$obj", param_2447
    find_lex $P2448, "self"
    get_global $P2449, "$?CLASS"
    getattribute $P2450, $P2448, $P2449, "$!name"
    unless_null $P2450, vivify_414
    new $P2450, "Undef"
  vivify_414:
    .return ($P2450)
.end


.namespace ["NQPMu"]
.sub "_block2480"  :subid("165_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 1050
    .const 'Sub' $P2602 = "178_1298839204.312" 
    capture_lex $P2602
    .const 'Sub' $P2592 = "177_1298839204.312" 
    capture_lex $P2592
    .const 'Sub' $P2580 = "176_1298839204.312" 
    capture_lex $P2580
    .const 'Sub' $P2576 = "175_1298839204.312" 
    capture_lex $P2576
    .const 'Sub' $P2565 = "174_1298839204.312" 
    capture_lex $P2565
    .const 'Sub' $P2562 = "173_1298839204.312" 
    capture_lex $P2562
    .const 'Sub' $P2556 = "172_1298839204.312" 
    capture_lex $P2556
    .const 'Sub' $P2518 = "170_1298839204.312" 
    capture_lex $P2518
    .const 'Sub' $P2497 = "168_1298839204.312" 
    capture_lex $P2497
    .const 'Sub' $P2487 = "167_1298839204.312" 
    capture_lex $P2487
    .const 'Sub' $P2483 = "166_1298839204.312" 
    capture_lex $P2483
    get_global $P2482, "$?CLASS"
.annotate 'line', 1092
    .const 'Sub' $P2592 = "177_1298839204.312" 
    newclosure $P2600, $P2592
.annotate 'line', 1050
    .return ($P2600)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post415") :outer("165_1298839204.312")
.annotate 'line', 1050
    get_hll_global $P2481, ["NQPMu"], "_block2480" 
    .local pmc block
    set block, $P2481
    .const 'Sub' $P2602 = "178_1298839204.312" 
    capture_lex $P2602
    $P2602()
.end


.namespace ["NQPMu"]
.sub "_block2601"  :anon :subid("178_1298839204.312") :outer("165_1298839204.312")
.annotate 'line', 1050
    .const 'Sub' $P2619 = "173_1298839204.312" 
    capture_lex $P2619
    get_hll_global $P2603, "NQPClassHOW"
    $P2604 = $P2603."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P2604
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2605, type_obj
    .const 'Sub' $P2606 = "166_1298839204.312" 
    $P2605."add_method"(type_obj, "CREATE", $P2606)
    get_how $P2607, type_obj
    .const 'Sub' $P2608 = "167_1298839204.312" 
    $P2607."add_method"(type_obj, "bless", $P2608)
    get_how $P2609, type_obj
    .const 'Sub' $P2610 = "168_1298839204.312" 
    $P2609."add_method"(type_obj, "BUILDALL", $P2610)
    get_how $P2611, type_obj
    .const 'Sub' $P2612 = "170_1298839204.312" 
    $P2611."add_method"(type_obj, "BUILD_MAGIC", $P2612)
    get_how $P2613, type_obj
    .const 'Sub' $P2614 = "172_1298839204.312" 
    $P2613."add_method"(type_obj, "new", $P2614)
    get_how $P2615, type_obj
    .const 'Sub' $P2616 = "173_1298839204.312" 
    new $P2617, "ResizablePMCArray"
    set_dispatchees $P2616, $P2617
    $P2615."add_method"(type_obj, "Str", $P2616)
    get_how $P2618, type_obj
    .const 'Sub' $P2619 = "173_1298839204.312" 
    newclosure $P2622, $P2619
    $P2618."add_parrot_vtable_mapping"(type_obj, "get_string", $P2622)
    get_how $P2623, type_obj
    .const 'Sub' $P2624 = "174_1298839204.312" 
    $P2623."add_multi_method"(type_obj, "Str", $P2624)
    get_how $P2625, type_obj
    .const 'Sub' $P2626 = "175_1298839204.312" 
    new $P2627, "ResizablePMCArray"
    set_dispatchees $P2626, $P2627
    $P2625."add_method"(type_obj, "ACCEPTS", $P2626)
    get_how $P2628, type_obj
    .const 'Sub' $P2629 = "176_1298839204.312" 
    $P2628."add_multi_method"(type_obj, "ACCEPTS", $P2629)
    get_how $P2630, type_obj
    .const 'Sub' $P2631 = "177_1298839204.312" 
    $P2630."add_method"(type_obj, "isa", $P2631)
    get_how $P2632, type_obj
    $P2633 = $P2632."compose"(type_obj)
    .return ($P2633)
.end


.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("173_1298839204.312") :outer("178_1298839204.312")
    .param pmc param_2620
.annotate 'line', 1050
    .lex "self", param_2620
    multi_dispatch_over_lexical_candidates $P2621
    .return ($P2621)
.end


.namespace ["NQPMu"]
.sub "CREATE"  :subid("166_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2484
.annotate 'line', 1051
    .lex "self", param_2484
.annotate 'line', 1052
    find_lex $P2485, "self"
    repr_instance_of $P2486, $P2485
.annotate 'line', 1051
    .return ($P2486)
.end


.namespace ["NQPMu"]
.sub "bless"  :subid("167_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2488
    .param pmc param_2490 :slurpy :named
.annotate 'line', 1056
    .lex "$self", param_2488
    find_lex $P2489, "$self"
    .lex "self", $P2489
    .lex "%attributes", param_2490
.annotate 'line', 1057
    new $P2491, "Undef"
    .lex "$instance", $P2491
    find_lex $P2492, "self"
    $P2493 = $P2492."CREATE"()
    store_lex "$instance", $P2493
.annotate 'line', 1058
    find_lex $P2494, "$instance"
    find_lex $P2495, "%attributes"
    $P2494."BUILDALL"($P2495 :flat)
    find_lex $P2496, "$instance"
.annotate 'line', 1056
    .return ($P2496)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILDALL"  :subid("168_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2498
    .param pmc param_2500 :slurpy :named
.annotate 'line', 1062
    .const 'Sub' $P2509 = "169_1298839204.312" 
    capture_lex $P2509
    .lex "$self", param_2498
    find_lex $P2499, "$self"
    .lex "self", $P2499
    .lex "%attributes", param_2500
.annotate 'line', 1063
    find_lex $P2502, "$self"
    get_how $P2503, $P2502
    find_lex $P2504, "$self"
    $P2505 = $P2503."parents"($P2504)
    defined $I2506, $P2505
    unless $I2506, for_undef_416
    iter $P2501, $P2505
    new $P2516, 'ExceptionHandler'
    set_label $P2516, loop2515_handler
    $P2516."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2516
  loop2515_test:
    unless $P2501, loop2515_done
    shift $P2507, $P2501
  loop2515_redo:
    .const 'Sub' $P2509 = "169_1298839204.312" 
    capture_lex $P2509
    $P2509($P2507)
  loop2515_next:
    goto loop2515_test
  loop2515_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2517, exception, 'type'
    eq $P2517, .CONTROL_LOOP_NEXT, loop2515_next
    eq $P2517, .CONTROL_LOOP_REDO, loop2515_redo
  loop2515_done:
    pop_eh 
  for_undef_416:
.annotate 'line', 1062
    .return ($P2501)
.end


.namespace ["NQPMu"]
.sub "_block2508"  :anon :subid("169_1298839204.312") :outer("168_1298839204.312")
    .param pmc param_2510
.annotate 'line', 1063
    .lex "$class", param_2510
.annotate 'line', 1064
    find_lex $P2511, "$self"
    find_lex $P2512, "$class"
    find_lex $P2513, "%attributes"
    $P2514 = $P2511."BUILD_MAGIC"($P2512, $P2513 :flat)
.annotate 'line', 1063
    .return ($P2514)
.end


.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILD_MAGIC"  :subid("170_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2519
    .param pmc param_2521
    .param pmc param_2522 :slurpy :named
.annotate 'line', 1068
    .const 'Sub' $P2531 = "171_1298839204.312" 
    capture_lex $P2531
    .lex "$self", param_2519
    find_lex $P2520, "$self"
    .lex "self", $P2520
    .lex "$type", param_2521
    .lex "%attributes", param_2522
.annotate 'line', 1069
    find_lex $P2524, "$type"
    get_how $P2525, $P2524
    find_lex $P2526, "$type"
    $P2527 = $P2525."attributes"($P2526, 1 :named("local"))
    defined $I2528, $P2527
    unless $I2528, for_undef_417
    iter $P2523, $P2527
    new $P2554, 'ExceptionHandler'
    set_label $P2554, loop2553_handler
    $P2554."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2554
  loop2553_test:
    unless $P2523, loop2553_done
    shift $P2529, $P2523
  loop2553_redo:
    .const 'Sub' $P2531 = "171_1298839204.312" 
    capture_lex $P2531
    $P2531($P2529)
  loop2553_next:
    goto loop2553_test
  loop2553_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2555, exception, 'type'
    eq $P2555, .CONTROL_LOOP_NEXT, loop2553_next
    eq $P2555, .CONTROL_LOOP_REDO, loop2553_redo
  loop2553_done:
    pop_eh 
  for_undef_417:
.annotate 'line', 1068
    .return ($P2523)
.end


.namespace ["NQPMu"]
.sub "_block2530"  :anon :subid("171_1298839204.312") :outer("170_1298839204.312")
    .param pmc param_2534
.annotate 'line', 1070
    new $P2532, "Undef"
    .lex "$name", $P2532
.annotate 'line', 1071
    new $P2533, "Undef"
    .lex "$shortname", $P2533
    .lex "$_", param_2534
.annotate 'line', 1070
    find_lex $P2535, "$_"
    $P2536 = $P2535."name"()
    store_lex "$name", $P2536
.annotate 'line', 1071
    find_lex $P2537, "$name"
    set $S2538, $P2537
    substr $S2539, $S2538, 2
    new $P2540, 'String'
    set $P2540, $S2539
    store_lex "$shortname", $P2540
.annotate 'line', 1072
    find_lex $P2544, "$shortname"
    find_lex $P2543, "%attributes"
    exists $I2545, $P2543[$P2544]
    if $I2545, if_2542
    new $P2541, 'Integer'
    set $P2541, $I2545
    goto if_2542_end
  if_2542:
.annotate 'line', 1073
    find_lex $P2546, "$self"
    find_lex $P2547, "$type"
    find_lex $P2548, "$name"
    set $S2549, $P2548
    find_lex $P2550, "$shortname"
    find_lex $P2551, "%attributes"
    unless_null $P2551, vivify_418
    $P2551 = root_new ['parrot';'Hash']
  vivify_418:
    set $P2552, $P2551[$P2550]
    unless_null $P2552, vivify_419
    new $P2552, "Undef"
  vivify_419:
    setattribute $P2546, $P2547, $S2549, $P2552
  if_2542_end:
.annotate 'line', 1069
    .return ($P2541)
.end


.namespace ["NQPMu"]
.sub "new"  :subid("172_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2557
    .param pmc param_2558 :slurpy :named
.annotate 'line', 1078
    .lex "self", param_2557
    .lex "%attributes", param_2558
.annotate 'line', 1079
    find_lex $P2559, "self"
    find_lex $P2560, "%attributes"
    $P2561 = $P2559."bless"($P2560 :flat)
.annotate 'line', 1078
    .return ($P2561)
.end


.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("173_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2563
.annotate 'line', 1078
    .lex "self", param_2563
    multi_dispatch_over_lexical_candidates $P2564
    .return ($P2564)
.end


.namespace ["NQPMu"]
.sub "Str"  :subid("174_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2566
.annotate 'line', 1083
    .lex "$self", param_2566
    find_lex $P2567, "$self"
    .lex "self", $P2567
.annotate 'line', 1084
    find_lex $P2568, "self"
    get_how $P2569, $P2568
    find_lex $P2570, "self"
    $P2571 = $P2569."name"($P2570)
    concat $P2572, $P2571, "()"
.annotate 'line', 1083
    .return ($P2572)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post420") :outer("174_1298839204.312")
.annotate 'line', 1083
    .const 'Sub' $P2565 = "174_1298839204.312" 
    .local pmc block
    set block, $P2565
    get_hll_global $P2573, "Mu"
    new $P2574, "ResizablePMCArray"
    push $P2574, $P2573
    new $P2575, "ResizablePMCArray"
    push $P2575, 2
    set_sub_multisig block, $P2574, $P2575
.end


.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("175_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2577
    .param pmc param_2578
.annotate 'line', 1083
    .lex "self", param_2577
.annotate 'line', 1087
    .lex "$topic", param_2578
.annotate 'line', 1083
    multi_dispatch_over_lexical_candidates $P2579
    .return ($P2579)
.end


.namespace ["NQPMu"]
.sub "ACCEPTS"  :subid("176_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2581
    .param pmc param_2583
.annotate 'line', 1088
    .lex "$self", param_2581
    find_lex $P2582, "$self"
    .lex "self", $P2582
    .lex "$topic", param_2583
.annotate 'line', 1089
    find_lex $P2584, "$topic"
    find_lex $P2585, "self"
    get_what $P2586, $P2585
    type_check $I2587, $P2584, $P2586
.annotate 'line', 1088
    .return ($I2587)
.end


.namespace ["NQPMu"]
.sub "" :load :init :subid("post421") :outer("176_1298839204.312")
.annotate 'line', 1088
    .const 'Sub' $P2580 = "176_1298839204.312" 
    .local pmc block
    set block, $P2580
    get_hll_global $P2588, "NQPMu"
    null $P2589
    new $P2590, "ResizablePMCArray"
    push $P2590, $P2588
    push $P2590, $P2589
    new $P2591, "ResizablePMCArray"
    push $P2591, 2
    push $P2591, 0
    set_sub_multisig block, $P2590, $P2591
.end


.namespace ["NQPMu"]
.sub "isa"  :subid("177_1298839204.312") :outer("165_1298839204.312")
    .param pmc param_2593
    .param pmc param_2594
.annotate 'line', 1092
    .lex "self", param_2593
    .lex "$type", param_2594
.annotate 'line', 1093
    find_lex $P2595, "self"
    get_how $P2596, $P2595
    find_lex $P2597, "self"
    find_lex $P2598, "$type"
    $P2599 = $P2596."isa"($P2597, $P2598)
.annotate 'line', 1092
    .return ($P2599)
.end


.namespace ["int"]
.sub "_block2634"  :subid("179_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 1099
    .const 'Sub' $P2638 = "180_1298839204.312" 
    capture_lex $P2638
    get_global $P2636, "$?CLASS"
    .return ()
.end


.namespace ["int"]
.sub "" :load :init :subid("post422") :outer("179_1298839204.312")
.annotate 'line', 1099
    get_hll_global $P2635, ["int"], "_block2634" 
    .local pmc block
    set block, $P2635
    .const 'Sub' $P2638 = "180_1298839204.312" 
    capture_lex $P2638
    $P2638()
.end


.namespace ["int"]
.sub "_block2637"  :anon :subid("180_1298839204.312") :outer("179_1298839204.312")
.annotate 'line', 1099
    get_hll_global $P2639, "NQPNativeHOW"
    $P2640 = $P2639."new_type"("int" :named("name"), "P6int" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2640
    set_hll_global "int", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2641, type_obj
    $P2642 = $P2641."compose"(type_obj)
    .return ($P2642)
.end


.namespace ["num"]
.sub "_block2643"  :subid("181_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 1101
    .const 'Sub' $P2647 = "182_1298839204.312" 
    capture_lex $P2647
    get_global $P2645, "$?CLASS"
    .return ()
.end


.namespace ["num"]
.sub "" :load :init :subid("post423") :outer("181_1298839204.312")
.annotate 'line', 1101
    get_hll_global $P2644, ["num"], "_block2643" 
    .local pmc block
    set block, $P2644
    .const 'Sub' $P2647 = "182_1298839204.312" 
    capture_lex $P2647
    $P2647()
.end


.namespace ["num"]
.sub "_block2646"  :anon :subid("182_1298839204.312") :outer("181_1298839204.312")
.annotate 'line', 1101
    get_hll_global $P2648, "NQPNativeHOW"
    $P2649 = $P2648."new_type"("num" :named("name"), "P6num" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2649
    set_hll_global "num", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2650, type_obj
    $P2651 = $P2650."compose"(type_obj)
    .return ($P2651)
.end


.namespace ["str"]
.sub "_block2652"  :subid("183_1298839204.312") :outer("10_1298839204.312")
.annotate 'line', 1103
    .const 'Sub' $P2656 = "184_1298839204.312" 
    capture_lex $P2656
    get_global $P2654, "$?CLASS"
    .return ()
.end


.namespace ["str"]
.sub "" :load :init :subid("post424") :outer("183_1298839204.312")
.annotate 'line', 1103
    get_hll_global $P2653, ["str"], "_block2652" 
    .local pmc block
    set block, $P2653
    .const 'Sub' $P2656 = "184_1298839204.312" 
    capture_lex $P2656
    $P2656()
.end


.namespace ["str"]
.sub "_block2655"  :anon :subid("184_1298839204.312") :outer("183_1298839204.312")
.annotate 'line', 1103
    get_hll_global $P2657, "NQPNativeHOW"
    $P2658 = $P2657."new_type"("str" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2658
    set_hll_global "str", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2659, type_obj
    $P2660 = $P2659."compose"(type_obj)
    .return ($P2660)
.end


.namespace []
.sub "_block2662" :load :anon :subid("185_1298839204.312")
.annotate 'line', 1
    .const 'Sub' $P2664 = "10_1298839204.312" 
    $P2665 = $P2664()
    .return ($P2665)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
.end

### .include 'gen/nqp-grammar.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298839231.515")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
    $P2428 = $P15()
.annotate 'line', 1
    .return ($P2428)
    .const 'Sub' $P2430 = "402_1298839231.515" 
    .return ($P2430)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block14"  :subid("11_1298839231.515") :outer("10_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P1713 = "401_1298839231.515" 
    capture_lex $P1713
    get_hll_global $P1604, ["NQP";"Regex"], "_block1603" 
    capture_lex $P1604
    .const 'Sub' $P1592 = "377_1298839231.515" 
    capture_lex $P1592
    .const 'Sub' $P1586 = "375_1298839231.515" 
    capture_lex $P1586
    .const 'Sub' $P1580 = "373_1298839231.515" 
    capture_lex $P1580
    .const 'Sub' $P1574 = "371_1298839231.515" 
    capture_lex $P1574
    .const 'Sub' $P1568 = "369_1298839231.515" 
    capture_lex $P1568
    .const 'Sub' $P1556 = "366_1298839231.515" 
    capture_lex $P1556
    .const 'Sub' $P1549 = "364_1298839231.515" 
    capture_lex $P1549
    .const 'Sub' $P1542 = "362_1298839231.515" 
    capture_lex $P1542
    .const 'Sub' $P1535 = "360_1298839231.515" 
    capture_lex $P1535
    .const 'Sub' $P1528 = "358_1298839231.515" 
    capture_lex $P1528
    .const 'Sub' $P1522 = "356_1298839231.515" 
    capture_lex $P1522
    .const 'Sub' $P1515 = "354_1298839231.515" 
    capture_lex $P1515
    .const 'Sub' $P1508 = "352_1298839231.515" 
    capture_lex $P1508
    .const 'Sub' $P1501 = "350_1298839231.515" 
    capture_lex $P1501
    .const 'Sub' $P1494 = "348_1298839231.515" 
    capture_lex $P1494
    .const 'Sub' $P1487 = "346_1298839231.515" 
    capture_lex $P1487
    .const 'Sub' $P1480 = "344_1298839231.515" 
    capture_lex $P1480
    .const 'Sub' $P1473 = "342_1298839231.515" 
    capture_lex $P1473
    .const 'Sub' $P1466 = "340_1298839231.515" 
    capture_lex $P1466
    .const 'Sub' $P1459 = "338_1298839231.515" 
    capture_lex $P1459
    .const 'Sub' $P1452 = "336_1298839231.515" 
    capture_lex $P1452
    .const 'Sub' $P1445 = "334_1298839231.515" 
    capture_lex $P1445
    .const 'Sub' $P1438 = "332_1298839231.515" 
    capture_lex $P1438
    .const 'Sub' $P1431 = "330_1298839231.515" 
    capture_lex $P1431
    .const 'Sub' $P1424 = "328_1298839231.515" 
    capture_lex $P1424
    .const 'Sub' $P1417 = "326_1298839231.515" 
    capture_lex $P1417
    .const 'Sub' $P1410 = "324_1298839231.515" 
    capture_lex $P1410
    .const 'Sub' $P1403 = "322_1298839231.515" 
    capture_lex $P1403
    .const 'Sub' $P1396 = "320_1298839231.515" 
    capture_lex $P1396
    .const 'Sub' $P1389 = "318_1298839231.515" 
    capture_lex $P1389
    .const 'Sub' $P1382 = "316_1298839231.515" 
    capture_lex $P1382
    .const 'Sub' $P1375 = "314_1298839231.515" 
    capture_lex $P1375
    .const 'Sub' $P1368 = "312_1298839231.515" 
    capture_lex $P1368
    .const 'Sub' $P1361 = "310_1298839231.515" 
    capture_lex $P1361
    .const 'Sub' $P1354 = "308_1298839231.515" 
    capture_lex $P1354
    .const 'Sub' $P1347 = "306_1298839231.515" 
    capture_lex $P1347
    .const 'Sub' $P1340 = "304_1298839231.515" 
    capture_lex $P1340
    .const 'Sub' $P1333 = "302_1298839231.515" 
    capture_lex $P1333
    .const 'Sub' $P1326 = "300_1298839231.515" 
    capture_lex $P1326
    .const 'Sub' $P1319 = "298_1298839231.515" 
    capture_lex $P1319
    .const 'Sub' $P1313 = "296_1298839231.515" 
    capture_lex $P1313
    .const 'Sub' $P1306 = "294_1298839231.515" 
    capture_lex $P1306
    .const 'Sub' $P1299 = "292_1298839231.515" 
    capture_lex $P1299
    .const 'Sub' $P1292 = "290_1298839231.515" 
    capture_lex $P1292
    .const 'Sub' $P1285 = "288_1298839231.515" 
    capture_lex $P1285
    .const 'Sub' $P1278 = "286_1298839231.515" 
    capture_lex $P1278
    .const 'Sub' $P1271 = "284_1298839231.515" 
    capture_lex $P1271
    .const 'Sub' $P1264 = "282_1298839231.515" 
    capture_lex $P1264
    .const 'Sub' $P1258 = "280_1298839231.515" 
    capture_lex $P1258
    .const 'Sub' $P1252 = "278_1298839231.515" 
    capture_lex $P1252
    .const 'Sub' $P1247 = "276_1298839231.515" 
    capture_lex $P1247
    .const 'Sub' $P1241 = "274_1298839231.515" 
    capture_lex $P1241
    .const 'Sub' $P1235 = "272_1298839231.515" 
    capture_lex $P1235
    .const 'Sub' $P1230 = "270_1298839231.515" 
    capture_lex $P1230
    .const 'Sub' $P1225 = "268_1298839231.515" 
    capture_lex $P1225
    .const 'Sub' $P1209 = "267_1298839231.515" 
    capture_lex $P1209
    .const 'Sub' $P1200 = "265_1298839231.515" 
    capture_lex $P1200
    .const 'Sub' $P1191 = "263_1298839231.515" 
    capture_lex $P1191
    .const 'Sub' $P1186 = "261_1298839231.515" 
    capture_lex $P1186
    .const 'Sub' $P1181 = "259_1298839231.515" 
    capture_lex $P1181
    .const 'Sub' $P1176 = "257_1298839231.515" 
    capture_lex $P1176
    .const 'Sub' $P1168 = "255_1298839231.515" 
    capture_lex $P1168
    .const 'Sub' $P1160 = "253_1298839231.515" 
    capture_lex $P1160
    .const 'Sub' $P1155 = "251_1298839231.515" 
    capture_lex $P1155
    .const 'Sub' $P1150 = "249_1298839231.515" 
    capture_lex $P1150
    .const 'Sub' $P1145 = "247_1298839231.515" 
    capture_lex $P1145
    .const 'Sub' $P1139 = "245_1298839231.515" 
    capture_lex $P1139
    .const 'Sub' $P1133 = "243_1298839231.515" 
    capture_lex $P1133
    .const 'Sub' $P1127 = "241_1298839231.515" 
    capture_lex $P1127
    .const 'Sub' $P1121 = "239_1298839231.515" 
    capture_lex $P1121
    .const 'Sub' $P1115 = "237_1298839231.515" 
    capture_lex $P1115
    .const 'Sub' $P1110 = "235_1298839231.515" 
    capture_lex $P1110
    .const 'Sub' $P1105 = "233_1298839231.515" 
    capture_lex $P1105
    .const 'Sub' $P1091 = "229_1298839231.515" 
    capture_lex $P1091
    .const 'Sub' $P1083 = "227_1298839231.515" 
    capture_lex $P1083
    .const 'Sub' $P1077 = "225_1298839231.515" 
    capture_lex $P1077
    .const 'Sub' $P1070 = "223_1298839231.515" 
    capture_lex $P1070
    .const 'Sub' $P1064 = "221_1298839231.515" 
    capture_lex $P1064
    .const 'Sub' $P1050 = "218_1298839231.515" 
    capture_lex $P1050
    .const 'Sub' $P1042 = "216_1298839231.515" 
    capture_lex $P1042
    .const 'Sub' $P1034 = "214_1298839231.515" 
    capture_lex $P1034
    .const 'Sub' $P1028 = "212_1298839231.515" 
    capture_lex $P1028
    .const 'Sub' $P1022 = "210_1298839231.515" 
    capture_lex $P1022
    .const 'Sub' $P1006 = "206_1298839231.515" 
    capture_lex $P1006
    .const 'Sub' $P965 = "204_1298839231.515" 
    capture_lex $P965
    .const 'Sub' $P954 = "202_1298839231.515" 
    capture_lex $P954
    .const 'Sub' $P940 = "198_1298839231.515" 
    capture_lex $P940
    .const 'Sub' $P931 = "196_1298839231.515" 
    capture_lex $P931
    .const 'Sub' $P925 = "194_1298839231.515" 
    capture_lex $P925
    .const 'Sub' $P915 = "192_1298839231.515" 
    capture_lex $P915
    .const 'Sub' $P900 = "190_1298839231.515" 
    capture_lex $P900
    .const 'Sub' $P886 = "187_1298839231.515" 
    capture_lex $P886
    .const 'Sub' $P878 = "185_1298839231.515" 
    capture_lex $P878
    .const 'Sub' $P868 = "183_1298839231.515" 
    capture_lex $P868
    .const 'Sub' $P858 = "181_1298839231.515" 
    capture_lex $P858
    .const 'Sub' $P839 = "176_1298839231.515" 
    capture_lex $P839
    .const 'Sub' $P795 = "173_1298839231.515" 
    capture_lex $P795
    .const 'Sub' $P761 = "171_1298839231.515" 
    capture_lex $P761
    .const 'Sub' $P754 = "169_1298839231.515" 
    capture_lex $P754
    .const 'Sub' $P747 = "167_1298839231.515" 
    capture_lex $P747
    .const 'Sub' $P730 = "163_1298839231.515" 
    capture_lex $P730
    .const 'Sub' $P722 = "161_1298839231.515" 
    capture_lex $P722
    .const 'Sub' $P716 = "159_1298839231.515" 
    capture_lex $P716
    .const 'Sub' $P703 = "157_1298839231.515" 
    capture_lex $P703
    .const 'Sub' $P696 = "155_1298839231.515" 
    capture_lex $P696
    .const 'Sub' $P689 = "153_1298839231.515" 
    capture_lex $P689
    .const 'Sub' $P682 = "151_1298839231.515" 
    capture_lex $P682
    .const 'Sub' $P641 = "147_1298839231.515" 
    capture_lex $P641
    .const 'Sub' $P629 = "145_1298839231.515" 
    capture_lex $P629
    .const 'Sub' $P617 = "143_1298839231.515" 
    capture_lex $P617
    .const 'Sub' $P605 = "141_1298839231.515" 
    capture_lex $P605
    .const 'Sub' $P593 = "139_1298839231.515" 
    capture_lex $P593
    .const 'Sub' $P581 = "137_1298839231.515" 
    capture_lex $P581
    .const 'Sub' $P569 = "135_1298839231.515" 
    capture_lex $P569
    .const 'Sub' $P558 = "131_1298839231.515" 
    capture_lex $P558
    .const 'Sub' $P553 = "129_1298839231.515" 
    capture_lex $P553
    .const 'Sub' $P541 = "127_1298839231.515" 
    capture_lex $P541
    .const 'Sub' $P529 = "125_1298839231.515" 
    capture_lex $P529
    .const 'Sub' $P522 = "123_1298839231.515" 
    capture_lex $P522
    .const 'Sub' $P517 = "121_1298839231.515" 
    capture_lex $P517
    .const 'Sub' $P511 = "119_1298839231.515" 
    capture_lex $P511
    .const 'Sub' $P505 = "117_1298839231.515" 
    capture_lex $P505
    .const 'Sub' $P490 = "113_1298839231.515" 
    capture_lex $P490
    .const 'Sub' $P484 = "111_1298839231.515" 
    capture_lex $P484
    .const 'Sub' $P478 = "109_1298839231.515" 
    capture_lex $P478
    .const 'Sub' $P472 = "107_1298839231.515" 
    capture_lex $P472
    .const 'Sub' $P466 = "105_1298839231.515" 
    capture_lex $P466
    .const 'Sub' $P460 = "103_1298839231.515" 
    capture_lex $P460
    .const 'Sub' $P454 = "101_1298839231.515" 
    capture_lex $P454
    .const 'Sub' $P445 = "99_1298839231.515" 
    capture_lex $P445
    .const 'Sub' $P436 = "97_1298839231.515" 
    capture_lex $P436
    .const 'Sub' $P427 = "95_1298839231.515" 
    capture_lex $P427
    .const 'Sub' $P412 = "91_1298839231.515" 
    capture_lex $P412
    .const 'Sub' $P403 = "89_1298839231.515" 
    capture_lex $P403
    .const 'Sub' $P391 = "85_1298839231.515" 
    capture_lex $P391
    .const 'Sub' $P384 = "83_1298839231.515" 
    capture_lex $P384
    .const 'Sub' $P377 = "81_1298839231.515" 
    capture_lex $P377
    .const 'Sub' $P363 = "77_1298839231.515" 
    capture_lex $P363
    .const 'Sub' $P355 = "75_1298839231.515" 
    capture_lex $P355
    .const 'Sub' $P347 = "73_1298839231.515" 
    capture_lex $P347
    .const 'Sub' $P327 = "71_1298839231.515" 
    capture_lex $P327
    .const 'Sub' $P318 = "69_1298839231.515" 
    capture_lex $P318
    .const 'Sub' $P300 = "66_1298839231.515" 
    capture_lex $P300
    .const 'Sub' $P282 = "64_1298839231.515" 
    capture_lex $P282
    .const 'Sub' $P271 = "60_1298839231.515" 
    capture_lex $P271
    .const 'Sub' $P266 = "58_1298839231.515" 
    capture_lex $P266
    .const 'Sub' $P255 = "54_1298839231.515" 
    capture_lex $P255
    .const 'Sub' $P250 = "52_1298839231.515" 
    capture_lex $P250
    .const 'Sub' $P245 = "50_1298839231.515" 
    capture_lex $P245
    .const 'Sub' $P240 = "48_1298839231.515" 
    capture_lex $P240
    .const 'Sub' $P230 = "46_1298839231.515" 
    capture_lex $P230
    .const 'Sub' $P223 = "44_1298839231.515" 
    capture_lex $P223
    .const 'Sub' $P217 = "42_1298839231.515" 
    capture_lex $P217
    .const 'Sub' $P209 = "40_1298839231.515" 
    capture_lex $P209
    .const 'Sub' $P203 = "38_1298839231.515" 
    capture_lex $P203
    .const 'Sub' $P197 = "36_1298839231.515" 
    capture_lex $P197
    .const 'Sub' $P182 = "33_1298839231.515" 
    capture_lex $P182
    .const 'Sub' $P168 = "31_1298839231.515" 
    capture_lex $P168
    .const 'Sub' $P161 = "29_1298839231.515" 
    capture_lex $P161
    .const 'Sub' $P122 = "26_1298839231.515" 
    capture_lex $P122
    .const 'Sub' $P107 = "23_1298839231.515" 
    capture_lex $P107
    .const 'Sub' $P96 = "21_1298839231.515" 
    capture_lex $P96
    .const 'Sub' $P84 = "19_1298839231.515" 
    capture_lex $P84
    .const 'Sub' $P76 = "17_1298839231.515" 
    capture_lex $P76
    .const 'Sub' $P69 = "15_1298839231.515" 
    capture_lex $P69
    .const 'Sub' $P62 = "13_1298839231.515" 
    capture_lex $P62
    .const 'Sub' $P18 = "12_1298839231.515" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1209 = "267_1298839231.515" 
    capture_lex $P1209
    $P1209()
.annotate 'line', 662
    get_hll_global $P1604, ["NQP";"Regex"], "_block1603" 
    capture_lex $P1604
    $P1707 = $P1604()
.annotate 'line', 4
    .return ($P1707)
    .const 'Sub' $P1709 = "400_1298839231.515" 
    .return ($P1709)
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post403") :outer("11_1298839231.515")
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P1713 = "401_1298839231.515" 
    capture_lex $P1713
    $P1713()
.end


.namespace ["NQP";"Grammar"]
.sub "_block1712"  :anon :subid("401_1298839231.515") :outer("11_1298839231.515")
.annotate 'line', 4
    get_hll_global $P1714, "NQPClassHOW"
    $P1715 = $P1714."new_type"("Grammar" :named("name"))
    .local pmc type_obj
    set type_obj, $P1715
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "12_1298839231.515" 
    $P1716."add_method"(type_obj, "TOP", $P1717)
    get_how $P1718, type_obj
    .const 'Sub' $P1719 = "13_1298839231.515" 
    $P1718."add_method"(type_obj, "identifier", $P1719)
    get_how $P1720, type_obj
    get_global $P1721, "!PREFIX__identifier"
    $P1720."add_method"(type_obj, "!PREFIX__identifier", $P1721)
    get_how $P1722, type_obj
    .const 'Sub' $P1723 = "15_1298839231.515" 
    $P1722."add_method"(type_obj, "name", $P1723)
    get_how $P1724, type_obj
    get_global $P1725, "!PREFIX__name"
    $P1724."add_method"(type_obj, "!PREFIX__name", $P1725)
    get_how $P1726, type_obj
    .const 'Sub' $P1727 = "17_1298839231.515" 
    $P1726."add_method"(type_obj, "deflongname", $P1727)
    get_how $P1728, type_obj
    get_global $P1729, "!PREFIX__deflongname"
    $P1728."add_method"(type_obj, "!PREFIX__deflongname", $P1729)
    get_how $P1730, type_obj
    .const 'Sub' $P1731 = "19_1298839231.515" 
    $P1730."add_method"(type_obj, "ENDSTMT", $P1731)
    get_how $P1732, type_obj
    get_global $P1733, "!PREFIX__ENDSTMT"
    $P1732."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1733)
    get_how $P1734, type_obj
    .const 'Sub' $P1735 = "21_1298839231.515" 
    $P1734."add_method"(type_obj, "ws", $P1735)
    get_how $P1736, type_obj
    get_global $P1737, "!PREFIX__ws"
    $P1736."add_method"(type_obj, "!PREFIX__ws", $P1737)
    get_how $P1738, type_obj
    .const 'Sub' $P1739 = "23_1298839231.515" 
    $P1738."add_method"(type_obj, "unv", $P1739)
    get_how $P1740, type_obj
    get_global $P1741, "!PREFIX__unv"
    $P1740."add_method"(type_obj, "!PREFIX__unv", $P1741)
    get_how $P1742, type_obj
    .const 'Sub' $P1743 = "26_1298839231.515" 
    $P1742."add_method"(type_obj, "pod_comment", $P1743)
    get_how $P1744, type_obj
    get_global $P1745, "!PREFIX__pod_comment"
    $P1744."add_method"(type_obj, "!PREFIX__pod_comment", $P1745)
    get_how $P1746, type_obj
    .const 'Sub' $P1747 = "29_1298839231.515" 
    $P1746."add_method"(type_obj, "comp_unit", $P1747)
    get_how $P1748, type_obj
    get_global $P1749, "!PREFIX__comp_unit"
    $P1748."add_method"(type_obj, "!PREFIX__comp_unit", $P1749)
    get_how $P1750, type_obj
    .const 'Sub' $P1751 = "31_1298839231.515" 
    $P1750."add_method"(type_obj, "statementlist", $P1751)
    get_how $P1752, type_obj
    get_global $P1753, "!PREFIX__statementlist"
    $P1752."add_method"(type_obj, "!PREFIX__statementlist", $P1753)
    get_how $P1754, type_obj
    .const 'Sub' $P1755 = "33_1298839231.515" 
    $P1754."add_method"(type_obj, "statement", $P1755)
    get_how $P1756, type_obj
    get_global $P1757, "!PREFIX__statement"
    $P1756."add_method"(type_obj, "!PREFIX__statement", $P1757)
    get_how $P1758, type_obj
    .const 'Sub' $P1759 = "36_1298839231.515" 
    $P1758."add_method"(type_obj, "eat_terminator", $P1759)
    get_how $P1760, type_obj
    get_global $P1761, "!PREFIX__eat_terminator"
    $P1760."add_method"(type_obj, "!PREFIX__eat_terminator", $P1761)
    get_how $P1762, type_obj
    .const 'Sub' $P1763 = "38_1298839231.515" 
    $P1762."add_method"(type_obj, "xblock", $P1763)
    get_how $P1764, type_obj
    get_global $P1765, "!PREFIX__xblock"
    $P1764."add_method"(type_obj, "!PREFIX__xblock", $P1765)
    get_how $P1766, type_obj
    .const 'Sub' $P1767 = "40_1298839231.515" 
    $P1766."add_method"(type_obj, "pblock", $P1767)
    get_how $P1768, type_obj
    get_global $P1769, "!PREFIX__pblock"
    $P1768."add_method"(type_obj, "!PREFIX__pblock", $P1769)
    get_how $P1770, type_obj
    .const 'Sub' $P1771 = "42_1298839231.515" 
    $P1770."add_method"(type_obj, "lambda", $P1771)
    get_how $P1772, type_obj
    get_global $P1773, "!PREFIX__lambda"
    $P1772."add_method"(type_obj, "!PREFIX__lambda", $P1773)
    get_how $P1774, type_obj
    .const 'Sub' $P1775 = "44_1298839231.515" 
    $P1774."add_method"(type_obj, "block", $P1775)
    get_how $P1776, type_obj
    get_global $P1777, "!PREFIX__block"
    $P1776."add_method"(type_obj, "!PREFIX__block", $P1777)
    get_how $P1778, type_obj
    .const 'Sub' $P1779 = "46_1298839231.515" 
    $P1778."add_method"(type_obj, "blockoid", $P1779)
    get_how $P1780, type_obj
    get_global $P1781, "!PREFIX__blockoid"
    $P1780."add_method"(type_obj, "!PREFIX__blockoid", $P1781)
    get_how $P1782, type_obj
    .const 'Sub' $P1783 = "48_1298839231.515" 
    $P1782."add_method"(type_obj, "newpad", $P1783)
    get_how $P1784, type_obj
    get_global $P1785, "!PREFIX__newpad"
    $P1784."add_method"(type_obj, "!PREFIX__newpad", $P1785)
    get_how $P1786, type_obj
    .const 'Sub' $P1787 = "50_1298839231.515" 
    $P1786."add_method"(type_obj, "outerctx", $P1787)
    get_how $P1788, type_obj
    get_global $P1789, "!PREFIX__outerctx"
    $P1788."add_method"(type_obj, "!PREFIX__outerctx", $P1789)
    get_how $P1790, type_obj
    .const 'Sub' $P1791 = "52_1298839231.515" 
    $P1790."add_method"(type_obj, "finishpad", $P1791)
    get_how $P1792, type_obj
    get_global $P1793, "!PREFIX__finishpad"
    $P1792."add_method"(type_obj, "!PREFIX__finishpad", $P1793)
    get_how $P1794, type_obj
    .const 'Sub' $P1795 = "54_1298839231.515" 
    $P1794."add_method"(type_obj, "you_are_here", $P1795)
    get_how $P1796, type_obj
    get_global $P1797, "!PREFIX__you_are_here"
    $P1796."add_method"(type_obj, "!PREFIX__you_are_here", $P1797)
    get_how $P1798, type_obj
    .const 'Sub' $P1799 = "56_1298839231.515" 
    $P1798."add_method"(type_obj, "terminator", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "57_1298839231.515" 
    $P1800."add_method"(type_obj, "!PREFIX__terminator", $P1801)
    get_how $P1802, type_obj
    .const 'Sub' $P1803 = "58_1298839231.515" 
    $P1802."add_method"(type_obj, "terminator:sym<;>", $P1803)
    get_how $P1804, type_obj
    get_global $P1805, "!PREFIX__terminator:sym<;>"
    $P1804."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1805)
    get_how $P1806, type_obj
    .const 'Sub' $P1807 = "60_1298839231.515" 
    $P1806."add_method"(type_obj, "terminator:sym<}>", $P1807)
    get_how $P1808, type_obj
    get_global $P1809, "!PREFIX__terminator:sym<}>"
    $P1808."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1809)
    get_how $P1810, type_obj
    .const 'Sub' $P1811 = "62_1298839231.515" 
    $P1810."add_method"(type_obj, "statement_control", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "63_1298839231.515" 
    $P1812."add_method"(type_obj, "!PREFIX__statement_control", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "64_1298839231.515" 
    $P1814."add_method"(type_obj, "statement_control:sym<if>", $P1815)
    get_how $P1816, type_obj
    get_global $P1817, "!PREFIX__statement_control:sym<if>"
    $P1816."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1817)
    get_how $P1818, type_obj
    .const 'Sub' $P1819 = "66_1298839231.515" 
    $P1818."add_method"(type_obj, "statement_control:sym<unless>", $P1819)
    get_how $P1820, type_obj
    get_global $P1821, "!PREFIX__statement_control:sym<unless>"
    $P1820."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1821)
    get_how $P1822, type_obj
    .const 'Sub' $P1823 = "69_1298839231.515" 
    $P1822."add_method"(type_obj, "statement_control:sym<while>", $P1823)
    get_how $P1824, type_obj
    get_global $P1825, "!PREFIX__statement_control:sym<while>"
    $P1824."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1825)
    get_how $P1826, type_obj
    .const 'Sub' $P1827 = "71_1298839231.515" 
    $P1826."add_method"(type_obj, "statement_control:sym<repeat>", $P1827)
    get_how $P1828, type_obj
    get_global $P1829, "!PREFIX__statement_control:sym<repeat>"
    $P1828."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1829)
    get_how $P1830, type_obj
    .const 'Sub' $P1831 = "73_1298839231.515" 
    $P1830."add_method"(type_obj, "statement_control:sym<for>", $P1831)
    get_how $P1832, type_obj
    get_global $P1833, "!PREFIX__statement_control:sym<for>"
    $P1832."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1833)
    get_how $P1834, type_obj
    .const 'Sub' $P1835 = "75_1298839231.515" 
    $P1834."add_method"(type_obj, "statement_control:sym<CATCH>", $P1835)
    get_how $P1836, type_obj
    get_global $P1837, "!PREFIX__statement_control:sym<CATCH>"
    $P1836."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1837)
    get_how $P1838, type_obj
    .const 'Sub' $P1839 = "77_1298839231.515" 
    $P1838."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1839)
    get_how $P1840, type_obj
    get_global $P1841, "!PREFIX__statement_control:sym<CONTROL>"
    $P1840."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1841)
    get_how $P1842, type_obj
    .const 'Sub' $P1843 = "79_1298839231.515" 
    $P1842."add_method"(type_obj, "statement_prefix", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "80_1298839231.515" 
    $P1844."add_method"(type_obj, "!PREFIX__statement_prefix", $P1845)
    get_how $P1846, type_obj
    .const 'Sub' $P1847 = "81_1298839231.515" 
    $P1846."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1847)
    get_how $P1848, type_obj
    get_global $P1849, "!PREFIX__statement_prefix:sym<INIT>"
    $P1848."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1849)
    get_how $P1850, type_obj
    .const 'Sub' $P1851 = "83_1298839231.515" 
    $P1850."add_method"(type_obj, "statement_prefix:sym<try>", $P1851)
    get_how $P1852, type_obj
    get_global $P1853, "!PREFIX__statement_prefix:sym<try>"
    $P1852."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1853)
    get_how $P1854, type_obj
    .const 'Sub' $P1855 = "85_1298839231.515" 
    $P1854."add_method"(type_obj, "blorst", $P1855)
    get_how $P1856, type_obj
    get_global $P1857, "!PREFIX__blorst"
    $P1856."add_method"(type_obj, "!PREFIX__blorst", $P1857)
    get_how $P1858, type_obj
    .const 'Sub' $P1859 = "87_1298839231.515" 
    $P1858."add_method"(type_obj, "statement_mod_cond", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "88_1298839231.515" 
    $P1860."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "89_1298839231.515" 
    $P1862."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1863)
    get_how $P1864, type_obj
    get_global $P1865, "!PREFIX__statement_mod_cond:sym<if>"
    $P1864."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1865)
    get_how $P1866, type_obj
    .const 'Sub' $P1867 = "91_1298839231.515" 
    $P1866."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1867)
    get_how $P1868, type_obj
    get_global $P1869, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1868."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1869)
    get_how $P1870, type_obj
    .const 'Sub' $P1871 = "93_1298839231.515" 
    $P1870."add_method"(type_obj, "statement_mod_loop", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "94_1298839231.515" 
    $P1872."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1873)
    get_how $P1874, type_obj
    .const 'Sub' $P1875 = "95_1298839231.515" 
    $P1874."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1875)
    get_how $P1876, type_obj
    get_global $P1877, "!PREFIX__statement_mod_loop:sym<while>"
    $P1876."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1877)
    get_how $P1878, type_obj
    .const 'Sub' $P1879 = "97_1298839231.515" 
    $P1878."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1879)
    get_how $P1880, type_obj
    get_global $P1881, "!PREFIX__statement_mod_loop:sym<until>"
    $P1880."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1881)
    get_how $P1882, type_obj
    .const 'Sub' $P1883 = "99_1298839231.515" 
    $P1882."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1883)
    get_how $P1884, type_obj
    get_global $P1885, "!PREFIX__statement_mod_loop:sym<for>"
    $P1884."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1885)
    get_how $P1886, type_obj
    .const 'Sub' $P1887 = "101_1298839231.515" 
    $P1886."add_method"(type_obj, "term:sym<fatarrow>", $P1887)
    get_how $P1888, type_obj
    get_global $P1889, "!PREFIX__term:sym<fatarrow>"
    $P1888."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1889)
    get_how $P1890, type_obj
    .const 'Sub' $P1891 = "103_1298839231.515" 
    $P1890."add_method"(type_obj, "term:sym<colonpair>", $P1891)
    get_how $P1892, type_obj
    get_global $P1893, "!PREFIX__term:sym<colonpair>"
    $P1892."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1893)
    get_how $P1894, type_obj
    .const 'Sub' $P1895 = "105_1298839231.515" 
    $P1894."add_method"(type_obj, "term:sym<variable>", $P1895)
    get_how $P1896, type_obj
    get_global $P1897, "!PREFIX__term:sym<variable>"
    $P1896."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1897)
    get_how $P1898, type_obj
    .const 'Sub' $P1899 = "107_1298839231.515" 
    $P1898."add_method"(type_obj, "term:sym<package_declarator>", $P1899)
    get_how $P1900, type_obj
    get_global $P1901, "!PREFIX__term:sym<package_declarator>"
    $P1900."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1901)
    get_how $P1902, type_obj
    .const 'Sub' $P1903 = "109_1298839231.515" 
    $P1902."add_method"(type_obj, "term:sym<scope_declarator>", $P1903)
    get_how $P1904, type_obj
    get_global $P1905, "!PREFIX__term:sym<scope_declarator>"
    $P1904."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1905)
    get_how $P1906, type_obj
    .const 'Sub' $P1907 = "111_1298839231.515" 
    $P1906."add_method"(type_obj, "term:sym<routine_declarator>", $P1907)
    get_how $P1908, type_obj
    get_global $P1909, "!PREFIX__term:sym<routine_declarator>"
    $P1908."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1909)
    get_how $P1910, type_obj
    .const 'Sub' $P1911 = "113_1298839231.515" 
    $P1910."add_method"(type_obj, "term:sym<multi_declarator>", $P1911)
    get_how $P1912, type_obj
    get_global $P1913, "!PREFIX__term:sym<multi_declarator>"
    $P1912."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1913)
    get_how $P1914, type_obj
    .const 'Sub' $P1915 = "117_1298839231.515" 
    $P1914."add_method"(type_obj, "term:sym<regex_declarator>", $P1915)
    get_how $P1916, type_obj
    get_global $P1917, "!PREFIX__term:sym<regex_declarator>"
    $P1916."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1917)
    get_how $P1918, type_obj
    .const 'Sub' $P1919 = "119_1298839231.515" 
    $P1918."add_method"(type_obj, "term:sym<statement_prefix>", $P1919)
    get_how $P1920, type_obj
    get_global $P1921, "!PREFIX__term:sym<statement_prefix>"
    $P1920."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1921)
    get_how $P1922, type_obj
    .const 'Sub' $P1923 = "121_1298839231.515" 
    $P1922."add_method"(type_obj, "term:sym<lambda>", $P1923)
    get_how $P1924, type_obj
    get_global $P1925, "!PREFIX__term:sym<lambda>"
    $P1924."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1925)
    get_how $P1926, type_obj
    .const 'Sub' $P1927 = "123_1298839231.515" 
    $P1926."add_method"(type_obj, "fatarrow", $P1927)
    get_how $P1928, type_obj
    get_global $P1929, "!PREFIX__fatarrow"
    $P1928."add_method"(type_obj, "!PREFIX__fatarrow", $P1929)
    get_how $P1930, type_obj
    .const 'Sub' $P1931 = "125_1298839231.515" 
    $P1930."add_method"(type_obj, "colonpair", $P1931)
    get_how $P1932, type_obj
    get_global $P1933, "!PREFIX__colonpair"
    $P1932."add_method"(type_obj, "!PREFIX__colonpair", $P1933)
    get_how $P1934, type_obj
    .const 'Sub' $P1935 = "127_1298839231.515" 
    $P1934."add_method"(type_obj, "variable", $P1935)
    get_how $P1936, type_obj
    get_global $P1937, "!PREFIX__variable"
    $P1936."add_method"(type_obj, "!PREFIX__variable", $P1937)
    get_how $P1938, type_obj
    .const 'Sub' $P1939 = "129_1298839231.515" 
    $P1938."add_method"(type_obj, "sigil", $P1939)
    get_how $P1940, type_obj
    get_global $P1941, "!PREFIX__sigil"
    $P1940."add_method"(type_obj, "!PREFIX__sigil", $P1941)
    get_how $P1942, type_obj
    .const 'Sub' $P1943 = "131_1298839231.515" 
    $P1942."add_method"(type_obj, "twigil", $P1943)
    get_how $P1944, type_obj
    get_global $P1945, "!PREFIX__twigil"
    $P1944."add_method"(type_obj, "!PREFIX__twigil", $P1945)
    get_how $P1946, type_obj
    .const 'Sub' $P1947 = "133_1298839231.515" 
    $P1946."add_method"(type_obj, "package_declarator", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "134_1298839231.515" 
    $P1948."add_method"(type_obj, "!PREFIX__package_declarator", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "135_1298839231.515" 
    $P1950."add_method"(type_obj, "package_declarator:sym<module>", $P1951)
    get_how $P1952, type_obj
    get_global $P1953, "!PREFIX__package_declarator:sym<module>"
    $P1952."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1953)
    get_how $P1954, type_obj
    .const 'Sub' $P1955 = "137_1298839231.515" 
    $P1954."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1955)
    get_how $P1956, type_obj
    get_global $P1957, "!PREFIX__package_declarator:sym<knowhow>"
    $P1956."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1957)
    get_how $P1958, type_obj
    .const 'Sub' $P1959 = "139_1298839231.515" 
    $P1958."add_method"(type_obj, "package_declarator:sym<class>", $P1959)
    get_how $P1960, type_obj
    get_global $P1961, "!PREFIX__package_declarator:sym<class>"
    $P1960."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1961)
    get_how $P1962, type_obj
    .const 'Sub' $P1963 = "141_1298839231.515" 
    $P1962."add_method"(type_obj, "package_declarator:sym<grammar>", $P1963)
    get_how $P1964, type_obj
    get_global $P1965, "!PREFIX__package_declarator:sym<grammar>"
    $P1964."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1965)
    get_how $P1966, type_obj
    .const 'Sub' $P1967 = "143_1298839231.515" 
    $P1966."add_method"(type_obj, "package_declarator:sym<role>", $P1967)
    get_how $P1968, type_obj
    get_global $P1969, "!PREFIX__package_declarator:sym<role>"
    $P1968."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1969)
    get_how $P1970, type_obj
    .const 'Sub' $P1971 = "145_1298839231.515" 
    $P1970."add_method"(type_obj, "package_declarator:sym<native>", $P1971)
    get_how $P1972, type_obj
    get_global $P1973, "!PREFIX__package_declarator:sym<native>"
    $P1972."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1973)
    get_how $P1974, type_obj
    .const 'Sub' $P1975 = "147_1298839231.515" 
    $P1974."add_method"(type_obj, "package_def", $P1975)
    get_how $P1976, type_obj
    get_global $P1977, "!PREFIX__package_def"
    $P1976."add_method"(type_obj, "!PREFIX__package_def", $P1977)
    get_how $P1978, type_obj
    .const 'Sub' $P1979 = "149_1298839231.515" 
    $P1978."add_method"(type_obj, "scope_declarator", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "150_1298839231.515" 
    $P1980."add_method"(type_obj, "!PREFIX__scope_declarator", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "151_1298839231.515" 
    $P1982."add_method"(type_obj, "scope_declarator:sym<my>", $P1983)
    get_how $P1984, type_obj
    get_global $P1985, "!PREFIX__scope_declarator:sym<my>"
    $P1984."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1985)
    get_how $P1986, type_obj
    .const 'Sub' $P1987 = "153_1298839231.515" 
    $P1986."add_method"(type_obj, "scope_declarator:sym<our>", $P1987)
    get_how $P1988, type_obj
    get_global $P1989, "!PREFIX__scope_declarator:sym<our>"
    $P1988."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1989)
    get_how $P1990, type_obj
    .const 'Sub' $P1991 = "155_1298839231.515" 
    $P1990."add_method"(type_obj, "scope_declarator:sym<has>", $P1991)
    get_how $P1992, type_obj
    get_global $P1993, "!PREFIX__scope_declarator:sym<has>"
    $P1992."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1993)
    get_how $P1994, type_obj
    .const 'Sub' $P1995 = "157_1298839231.515" 
    $P1994."add_method"(type_obj, "scoped", $P1995)
    get_how $P1996, type_obj
    get_global $P1997, "!PREFIX__scoped"
    $P1996."add_method"(type_obj, "!PREFIX__scoped", $P1997)
    get_how $P1998, type_obj
    .const 'Sub' $P1999 = "159_1298839231.515" 
    $P1998."add_method"(type_obj, "typename", $P1999)
    get_how $P2000, type_obj
    get_global $P2001, "!PREFIX__typename"
    $P2000."add_method"(type_obj, "!PREFIX__typename", $P2001)
    get_how $P2002, type_obj
    .const 'Sub' $P2003 = "161_1298839231.515" 
    $P2002."add_method"(type_obj, "declarator", $P2003)
    get_how $P2004, type_obj
    get_global $P2005, "!PREFIX__declarator"
    $P2004."add_method"(type_obj, "!PREFIX__declarator", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "163_1298839231.515" 
    $P2006."add_method"(type_obj, "variable_declarator", $P2007)
    get_how $P2008, type_obj
    get_global $P2009, "!PREFIX__variable_declarator"
    $P2008."add_method"(type_obj, "!PREFIX__variable_declarator", $P2009)
    get_how $P2010, type_obj
    .const 'Sub' $P2011 = "165_1298839231.515" 
    $P2010."add_method"(type_obj, "routine_declarator", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "166_1298839231.515" 
    $P2012."add_method"(type_obj, "!PREFIX__routine_declarator", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "167_1298839231.515" 
    $P2014."add_method"(type_obj, "routine_declarator:sym<sub>", $P2015)
    get_how $P2016, type_obj
    get_global $P2017, "!PREFIX__routine_declarator:sym<sub>"
    $P2016."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2017)
    get_how $P2018, type_obj
    .const 'Sub' $P2019 = "169_1298839231.515" 
    $P2018."add_method"(type_obj, "routine_declarator:sym<method>", $P2019)
    get_how $P2020, type_obj
    get_global $P2021, "!PREFIX__routine_declarator:sym<method>"
    $P2020."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2021)
    get_how $P2022, type_obj
    .const 'Sub' $P2023 = "171_1298839231.515" 
    $P2022."add_method"(type_obj, "routine_def", $P2023)
    get_how $P2024, type_obj
    get_global $P2025, "!PREFIX__routine_def"
    $P2024."add_method"(type_obj, "!PREFIX__routine_def", $P2025)
    get_how $P2026, type_obj
    .const 'Sub' $P2027 = "173_1298839231.515" 
    $P2026."add_method"(type_obj, "method_def", $P2027)
    get_how $P2028, type_obj
    get_global $P2029, "!PREFIX__method_def"
    $P2028."add_method"(type_obj, "!PREFIX__method_def", $P2029)
    get_how $P2030, type_obj
    .const 'Sub' $P2031 = "176_1298839231.515" 
    $P2030."add_method"(type_obj, "onlystar", $P2031)
    get_how $P2032, type_obj
    get_global $P2033, "!PREFIX__onlystar"
    $P2032."add_method"(type_obj, "!PREFIX__onlystar", $P2033)
    get_how $P2034, type_obj
    .const 'Sub' $P2035 = "179_1298839231.515" 
    $P2034."add_method"(type_obj, "multi_declarator", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "180_1298839231.515" 
    $P2036."add_method"(type_obj, "!PREFIX__multi_declarator", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "181_1298839231.515" 
    $P2038."add_method"(type_obj, "multi_declarator:sym<multi>", $P2039)
    get_how $P2040, type_obj
    get_global $P2041, "!PREFIX__multi_declarator:sym<multi>"
    $P2040."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2041)
    get_how $P2042, type_obj
    .const 'Sub' $P2043 = "183_1298839231.515" 
    $P2042."add_method"(type_obj, "multi_declarator:sym<proto>", $P2043)
    get_how $P2044, type_obj
    get_global $P2045, "!PREFIX__multi_declarator:sym<proto>"
    $P2044."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "185_1298839231.515" 
    $P2046."add_method"(type_obj, "multi_declarator:sym<null>", $P2047)
    get_how $P2048, type_obj
    get_global $P2049, "!PREFIX__multi_declarator:sym<null>"
    $P2048."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2049)
    get_how $P2050, type_obj
    .const 'Sub' $P2051 = "187_1298839231.515" 
    $P2050."add_method"(type_obj, "signature", $P2051)
    get_how $P2052, type_obj
    get_global $P2053, "!PREFIX__signature"
    $P2052."add_method"(type_obj, "!PREFIX__signature", $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "190_1298839231.515" 
    $P2054."add_method"(type_obj, "parameter", $P2055)
    get_how $P2056, type_obj
    get_global $P2057, "!PREFIX__parameter"
    $P2056."add_method"(type_obj, "!PREFIX__parameter", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "192_1298839231.515" 
    $P2058."add_method"(type_obj, "param_var", $P2059)
    get_how $P2060, type_obj
    get_global $P2061, "!PREFIX__param_var"
    $P2060."add_method"(type_obj, "!PREFIX__param_var", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "194_1298839231.515" 
    $P2062."add_method"(type_obj, "named_param", $P2063)
    get_how $P2064, type_obj
    get_global $P2065, "!PREFIX__named_param"
    $P2064."add_method"(type_obj, "!PREFIX__named_param", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "196_1298839231.515" 
    $P2066."add_method"(type_obj, "default_value", $P2067)
    get_how $P2068, type_obj
    get_global $P2069, "!PREFIX__default_value"
    $P2068."add_method"(type_obj, "!PREFIX__default_value", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "198_1298839231.515" 
    $P2070."add_method"(type_obj, "trait", $P2071)
    get_how $P2072, type_obj
    get_global $P2073, "!PREFIX__trait"
    $P2072."add_method"(type_obj, "!PREFIX__trait", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "200_1298839231.515" 
    $P2074."add_method"(type_obj, "trait_mod", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "201_1298839231.515" 
    $P2076."add_method"(type_obj, "!PREFIX__trait_mod", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "202_1298839231.515" 
    $P2078."add_method"(type_obj, "trait_mod:sym<is>", $P2079)
    get_how $P2080, type_obj
    get_global $P2081, "!PREFIX__trait_mod:sym<is>"
    $P2080."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "204_1298839231.515" 
    $P2082."add_method"(type_obj, "regex_declarator", $P2083)
    get_how $P2084, type_obj
    get_global $P2085, "!PREFIX__regex_declarator"
    $P2084."add_method"(type_obj, "!PREFIX__regex_declarator", $P2085)
    get_how $P2086, type_obj
    .const 'Sub' $P2087 = "206_1298839231.515" 
    $P2086."add_method"(type_obj, "dotty", $P2087)
    get_how $P2088, type_obj
    get_global $P2089, "!PREFIX__dotty"
    $P2088."add_method"(type_obj, "!PREFIX__dotty", $P2089)
    get_how $P2090, type_obj
    .const 'Sub' $P2091 = "208_1298839231.515" 
    $P2090."add_method"(type_obj, "term", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "209_1298839231.515" 
    $P2092."add_method"(type_obj, "!PREFIX__term", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "210_1298839231.515" 
    $P2094."add_method"(type_obj, "term:sym<self>", $P2095)
    get_how $P2096, type_obj
    get_global $P2097, "!PREFIX__term:sym<self>"
    $P2096."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2097)
    get_how $P2098, type_obj
    .const 'Sub' $P2099 = "212_1298839231.515" 
    $P2098."add_method"(type_obj, "term:sym<identifier>", $P2099)
    get_how $P2100, type_obj
    get_global $P2101, "!PREFIX__term:sym<identifier>"
    $P2100."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2101)
    get_how $P2102, type_obj
    .const 'Sub' $P2103 = "214_1298839231.515" 
    $P2102."add_method"(type_obj, "term:sym<name>", $P2103)
    get_how $P2104, type_obj
    get_global $P2105, "!PREFIX__term:sym<name>"
    $P2104."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "216_1298839231.515" 
    $P2106."add_method"(type_obj, "term:sym<pir::op>", $P2107)
    get_how $P2108, type_obj
    get_global $P2109, "!PREFIX__term:sym<pir::op>"
    $P2108."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2109)
    get_how $P2110, type_obj
    .const 'Sub' $P2111 = "218_1298839231.515" 
    $P2110."add_method"(type_obj, "term:sym<onlystar>", $P2111)
    get_how $P2112, type_obj
    get_global $P2113, "!PREFIX__term:sym<onlystar>"
    $P2112."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2113)
    get_how $P2114, type_obj
    .const 'Sub' $P2115 = "221_1298839231.515" 
    $P2114."add_method"(type_obj, "args", $P2115)
    get_how $P2116, type_obj
    get_global $P2117, "!PREFIX__args"
    $P2116."add_method"(type_obj, "!PREFIX__args", $P2117)
    get_how $P2118, type_obj
    .const 'Sub' $P2119 = "223_1298839231.515" 
    $P2118."add_method"(type_obj, "arglist", $P2119)
    get_how $P2120, type_obj
    get_global $P2121, "!PREFIX__arglist"
    $P2120."add_method"(type_obj, "!PREFIX__arglist", $P2121)
    get_how $P2122, type_obj
    .const 'Sub' $P2123 = "225_1298839231.515" 
    $P2122."add_method"(type_obj, "term:sym<value>", $P2123)
    get_how $P2124, type_obj
    get_global $P2125, "!PREFIX__term:sym<value>"
    $P2124."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2125)
    get_how $P2126, type_obj
    .const 'Sub' $P2127 = "227_1298839231.515" 
    $P2126."add_method"(type_obj, "value", $P2127)
    get_how $P2128, type_obj
    get_global $P2129, "!PREFIX__value"
    $P2128."add_method"(type_obj, "!PREFIX__value", $P2129)
    get_how $P2130, type_obj
    .const 'Sub' $P2131 = "229_1298839231.515" 
    $P2130."add_method"(type_obj, "number", $P2131)
    get_how $P2132, type_obj
    get_global $P2133, "!PREFIX__number"
    $P2132."add_method"(type_obj, "!PREFIX__number", $P2133)
    get_how $P2134, type_obj
    .const 'Sub' $P2135 = "231_1298839231.515" 
    $P2134."add_method"(type_obj, "quote", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "232_1298839231.515" 
    $P2136."add_method"(type_obj, "!PREFIX__quote", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "233_1298839231.515" 
    $P2138."add_method"(type_obj, "quote:sym<apos>", $P2139)
    get_how $P2140, type_obj
    get_global $P2141, "!PREFIX__quote:sym<apos>"
    $P2140."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2141)
    get_how $P2142, type_obj
    .const 'Sub' $P2143 = "235_1298839231.515" 
    $P2142."add_method"(type_obj, "quote:sym<dblq>", $P2143)
    get_how $P2144, type_obj
    get_global $P2145, "!PREFIX__quote:sym<dblq>"
    $P2144."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2145)
    get_how $P2146, type_obj
    .const 'Sub' $P2147 = "237_1298839231.515" 
    $P2146."add_method"(type_obj, "quote:sym<q>", $P2147)
    get_how $P2148, type_obj
    get_global $P2149, "!PREFIX__quote:sym<q>"
    $P2148."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2149)
    get_how $P2150, type_obj
    .const 'Sub' $P2151 = "239_1298839231.515" 
    $P2150."add_method"(type_obj, "quote:sym<qq>", $P2151)
    get_how $P2152, type_obj
    get_global $P2153, "!PREFIX__quote:sym<qq>"
    $P2152."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2153)
    get_how $P2154, type_obj
    .const 'Sub' $P2155 = "241_1298839231.515" 
    $P2154."add_method"(type_obj, "quote:sym<Q>", $P2155)
    get_how $P2156, type_obj
    get_global $P2157, "!PREFIX__quote:sym<Q>"
    $P2156."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2157)
    get_how $P2158, type_obj
    .const 'Sub' $P2159 = "243_1298839231.515" 
    $P2158."add_method"(type_obj, "quote:sym<Q:PIR>", $P2159)
    get_how $P2160, type_obj
    get_global $P2161, "!PREFIX__quote:sym<Q:PIR>"
    $P2160."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2161)
    get_how $P2162, type_obj
    .const 'Sub' $P2163 = "245_1298839231.515" 
    $P2162."add_method"(type_obj, "quote:sym</ />", $P2163)
    get_how $P2164, type_obj
    get_global $P2165, "!PREFIX__quote:sym</ />"
    $P2164."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2165)
    get_how $P2166, type_obj
    .const 'Sub' $P2167 = "247_1298839231.515" 
    $P2166."add_method"(type_obj, "quote_escape:sym<$>", $P2167)
    get_how $P2168, type_obj
    get_global $P2169, "!PREFIX__quote_escape:sym<$>"
    $P2168."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2169)
    get_how $P2170, type_obj
    .const 'Sub' $P2171 = "249_1298839231.515" 
    $P2170."add_method"(type_obj, "quote_escape:sym<{ }>", $P2171)
    get_how $P2172, type_obj
    get_global $P2173, "!PREFIX__quote_escape:sym<{ }>"
    $P2172."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2173)
    get_how $P2174, type_obj
    .const 'Sub' $P2175 = "251_1298839231.515" 
    $P2174."add_method"(type_obj, "quote_escape:sym<esc>", $P2175)
    get_how $P2176, type_obj
    get_global $P2177, "!PREFIX__quote_escape:sym<esc>"
    $P2176."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2177)
    get_how $P2178, type_obj
    .const 'Sub' $P2179 = "253_1298839231.515" 
    $P2178."add_method"(type_obj, "circumfix:sym<( )>", $P2179)
    get_how $P2180, type_obj
    get_global $P2181, "!PREFIX__circumfix:sym<( )>"
    $P2180."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2181)
    get_how $P2182, type_obj
    .const 'Sub' $P2183 = "255_1298839231.515" 
    $P2182."add_method"(type_obj, "circumfix:sym<[ ]>", $P2183)
    get_how $P2184, type_obj
    get_global $P2185, "!PREFIX__circumfix:sym<[ ]>"
    $P2184."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2185)
    get_how $P2186, type_obj
    .const 'Sub' $P2187 = "257_1298839231.515" 
    $P2186."add_method"(type_obj, "circumfix:sym<ang>", $P2187)
    get_how $P2188, type_obj
    get_global $P2189, "!PREFIX__circumfix:sym<ang>"
    $P2188."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2189)
    get_how $P2190, type_obj
    .const 'Sub' $P2191 = "259_1298839231.515" 
    $P2190."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2191)
    get_how $P2192, type_obj
    get_global $P2193, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2192."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2193)
    get_how $P2194, type_obj
    .const 'Sub' $P2195 = "261_1298839231.515" 
    $P2194."add_method"(type_obj, "circumfix:sym<{ }>", $P2195)
    get_how $P2196, type_obj
    get_global $P2197, "!PREFIX__circumfix:sym<{ }>"
    $P2196."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2197)
    get_how $P2198, type_obj
    .const 'Sub' $P2199 = "263_1298839231.515" 
    $P2198."add_method"(type_obj, "circumfix:sym<sigil>", $P2199)
    get_how $P2200, type_obj
    get_global $P2201, "!PREFIX__circumfix:sym<sigil>"
    $P2200."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2201)
    get_how $P2202, type_obj
    .const 'Sub' $P2203 = "265_1298839231.515" 
    $P2202."add_method"(type_obj, "semilist", $P2203)
    get_how $P2204, type_obj
    get_global $P2205, "!PREFIX__semilist"
    $P2204."add_method"(type_obj, "!PREFIX__semilist", $P2205)
    get_how $P2206, type_obj
    .const 'Sub' $P2207 = "268_1298839231.515" 
    $P2206."add_method"(type_obj, "infixish", $P2207)
    get_how $P2208, type_obj
    get_global $P2209, "!PREFIX__infixish"
    $P2208."add_method"(type_obj, "!PREFIX__infixish", $P2209)
    get_how $P2210, type_obj
    .const 'Sub' $P2211 = "270_1298839231.515" 
    $P2210."add_method"(type_obj, "infixstopper", $P2211)
    get_how $P2212, type_obj
    get_global $P2213, "!PREFIX__infixstopper"
    $P2212."add_method"(type_obj, "!PREFIX__infixstopper", $P2213)
    get_how $P2214, type_obj
    .const 'Sub' $P2215 = "272_1298839231.515" 
    $P2214."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2215)
    get_how $P2216, type_obj
    get_global $P2217, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2216."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2217)
    get_how $P2218, type_obj
    .const 'Sub' $P2219 = "274_1298839231.515" 
    $P2218."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2219)
    get_how $P2220, type_obj
    get_global $P2221, "!PREFIX__postcircumfix:sym<{ }>"
    $P2220."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2221)
    get_how $P2222, type_obj
    .const 'Sub' $P2223 = "276_1298839231.515" 
    $P2222."add_method"(type_obj, "postcircumfix:sym<ang>", $P2223)
    get_how $P2224, type_obj
    get_global $P2225, "!PREFIX__postcircumfix:sym<ang>"
    $P2224."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2225)
    get_how $P2226, type_obj
    .const 'Sub' $P2227 = "278_1298839231.515" 
    $P2226."add_method"(type_obj, "postcircumfix:sym<( )>", $P2227)
    get_how $P2228, type_obj
    get_global $P2229, "!PREFIX__postcircumfix:sym<( )>"
    $P2228."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2229)
    get_how $P2230, type_obj
    .const 'Sub' $P2231 = "280_1298839231.515" 
    $P2230."add_method"(type_obj, "postfix:sym<.>", $P2231)
    get_how $P2232, type_obj
    get_global $P2233, "!PREFIX__postfix:sym<.>"
    $P2232."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2233)
    get_how $P2234, type_obj
    .const 'Sub' $P2235 = "282_1298839231.515" 
    $P2234."add_method"(type_obj, "prefix:sym<++>", $P2235)
    get_how $P2236, type_obj
    get_global $P2237, "!PREFIX__prefix:sym<++>"
    $P2236."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2237)
    get_how $P2238, type_obj
    .const 'Sub' $P2239 = "284_1298839231.515" 
    $P2238."add_method"(type_obj, "prefix:sym<-->", $P2239)
    get_how $P2240, type_obj
    get_global $P2241, "!PREFIX__prefix:sym<-->"
    $P2240."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2241)
    get_how $P2242, type_obj
    .const 'Sub' $P2243 = "286_1298839231.515" 
    $P2242."add_method"(type_obj, "postfix:sym<++>", $P2243)
    get_how $P2244, type_obj
    get_global $P2245, "!PREFIX__postfix:sym<++>"
    $P2244."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2245)
    get_how $P2246, type_obj
    .const 'Sub' $P2247 = "288_1298839231.515" 
    $P2246."add_method"(type_obj, "postfix:sym<-->", $P2247)
    get_how $P2248, type_obj
    get_global $P2249, "!PREFIX__postfix:sym<-->"
    $P2248."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2249)
    get_how $P2250, type_obj
    .const 'Sub' $P2251 = "290_1298839231.515" 
    $P2250."add_method"(type_obj, "infix:sym<**>", $P2251)
    get_how $P2252, type_obj
    get_global $P2253, "!PREFIX__infix:sym<**>"
    $P2252."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2253)
    get_how $P2254, type_obj
    .const 'Sub' $P2255 = "292_1298839231.515" 
    $P2254."add_method"(type_obj, "prefix:sym<+>", $P2255)
    get_how $P2256, type_obj
    get_global $P2257, "!PREFIX__prefix:sym<+>"
    $P2256."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2257)
    get_how $P2258, type_obj
    .const 'Sub' $P2259 = "294_1298839231.515" 
    $P2258."add_method"(type_obj, "prefix:sym<~>", $P2259)
    get_how $P2260, type_obj
    get_global $P2261, "!PREFIX__prefix:sym<~>"
    $P2260."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2261)
    get_how $P2262, type_obj
    .const 'Sub' $P2263 = "296_1298839231.515" 
    $P2262."add_method"(type_obj, "prefix:sym<->", $P2263)
    get_how $P2264, type_obj
    get_global $P2265, "!PREFIX__prefix:sym<->"
    $P2264."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2265)
    get_how $P2266, type_obj
    .const 'Sub' $P2267 = "298_1298839231.515" 
    $P2266."add_method"(type_obj, "prefix:sym<?>", $P2267)
    get_how $P2268, type_obj
    get_global $P2269, "!PREFIX__prefix:sym<?>"
    $P2268."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2269)
    get_how $P2270, type_obj
    .const 'Sub' $P2271 = "300_1298839231.515" 
    $P2270."add_method"(type_obj, "prefix:sym<!>", $P2271)
    get_how $P2272, type_obj
    get_global $P2273, "!PREFIX__prefix:sym<!>"
    $P2272."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2273)
    get_how $P2274, type_obj
    .const 'Sub' $P2275 = "302_1298839231.515" 
    $P2274."add_method"(type_obj, "prefix:sym<|>", $P2275)
    get_how $P2276, type_obj
    get_global $P2277, "!PREFIX__prefix:sym<|>"
    $P2276."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2277)
    get_how $P2278, type_obj
    .const 'Sub' $P2279 = "304_1298839231.515" 
    $P2278."add_method"(type_obj, "infix:sym<*>", $P2279)
    get_how $P2280, type_obj
    get_global $P2281, "!PREFIX__infix:sym<*>"
    $P2280."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2281)
    get_how $P2282, type_obj
    .const 'Sub' $P2283 = "306_1298839231.515" 
    $P2282."add_method"(type_obj, "infix:sym</>", $P2283)
    get_how $P2284, type_obj
    get_global $P2285, "!PREFIX__infix:sym</>"
    $P2284."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2285)
    get_how $P2286, type_obj
    .const 'Sub' $P2287 = "308_1298839231.515" 
    $P2286."add_method"(type_obj, "infix:sym<%>", $P2287)
    get_how $P2288, type_obj
    get_global $P2289, "!PREFIX__infix:sym<%>"
    $P2288."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2289)
    get_how $P2290, type_obj
    .const 'Sub' $P2291 = "310_1298839231.515" 
    $P2290."add_method"(type_obj, "infix:sym<+&>", $P2291)
    get_how $P2292, type_obj
    get_global $P2293, "!PREFIX__infix:sym<+&>"
    $P2292."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2293)
    get_how $P2294, type_obj
    .const 'Sub' $P2295 = "312_1298839231.515" 
    $P2294."add_method"(type_obj, "infix:sym<+>", $P2295)
    get_how $P2296, type_obj
    get_global $P2297, "!PREFIX__infix:sym<+>"
    $P2296."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2297)
    get_how $P2298, type_obj
    .const 'Sub' $P2299 = "314_1298839231.515" 
    $P2298."add_method"(type_obj, "infix:sym<->", $P2299)
    get_how $P2300, type_obj
    get_global $P2301, "!PREFIX__infix:sym<->"
    $P2300."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2301)
    get_how $P2302, type_obj
    .const 'Sub' $P2303 = "316_1298839231.515" 
    $P2302."add_method"(type_obj, "infix:sym<+|>", $P2303)
    get_how $P2304, type_obj
    get_global $P2305, "!PREFIX__infix:sym<+|>"
    $P2304."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2305)
    get_how $P2306, type_obj
    .const 'Sub' $P2307 = "318_1298839231.515" 
    $P2306."add_method"(type_obj, "infix:sym<+^>", $P2307)
    get_how $P2308, type_obj
    get_global $P2309, "!PREFIX__infix:sym<+^>"
    $P2308."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2309)
    get_how $P2310, type_obj
    .const 'Sub' $P2311 = "320_1298839231.515" 
    $P2310."add_method"(type_obj, "infix:sym<~>", $P2311)
    get_how $P2312, type_obj
    get_global $P2313, "!PREFIX__infix:sym<~>"
    $P2312."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2313)
    get_how $P2314, type_obj
    .const 'Sub' $P2315 = "322_1298839231.515" 
    $P2314."add_method"(type_obj, "infix:sym<==>", $P2315)
    get_how $P2316, type_obj
    get_global $P2317, "!PREFIX__infix:sym<==>"
    $P2316."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2317)
    get_how $P2318, type_obj
    .const 'Sub' $P2319 = "324_1298839231.515" 
    $P2318."add_method"(type_obj, "infix:sym<!=>", $P2319)
    get_how $P2320, type_obj
    get_global $P2321, "!PREFIX__infix:sym<!=>"
    $P2320."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2321)
    get_how $P2322, type_obj
    .const 'Sub' $P2323 = "326_1298839231.515" 
    $P2322."add_method"(type_obj, "infix:sym<<=>", $P2323)
    get_how $P2324, type_obj
    get_global $P2325, "!PREFIX__infix:sym<<=>"
    $P2324."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2325)
    get_how $P2326, type_obj
    .const 'Sub' $P2327 = "328_1298839231.515" 
    $P2326."add_method"(type_obj, "infix:sym<>=>", $P2327)
    get_how $P2328, type_obj
    get_global $P2329, "!PREFIX__infix:sym<>=>"
    $P2328."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2329)
    get_how $P2330, type_obj
    .const 'Sub' $P2331 = "330_1298839231.515" 
    $P2330."add_method"(type_obj, "infix:sym<<>", $P2331)
    get_how $P2332, type_obj
    get_global $P2333, "!PREFIX__infix:sym<<>"
    $P2332."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2333)
    get_how $P2334, type_obj
    .const 'Sub' $P2335 = "332_1298839231.515" 
    $P2334."add_method"(type_obj, "infix:sym<>>", $P2335)
    get_how $P2336, type_obj
    get_global $P2337, "!PREFIX__infix:sym<>>"
    $P2336."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2337)
    get_how $P2338, type_obj
    .const 'Sub' $P2339 = "334_1298839231.515" 
    $P2338."add_method"(type_obj, "infix:sym<eq>", $P2339)
    get_how $P2340, type_obj
    get_global $P2341, "!PREFIX__infix:sym<eq>"
    $P2340."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2341)
    get_how $P2342, type_obj
    .const 'Sub' $P2343 = "336_1298839231.515" 
    $P2342."add_method"(type_obj, "infix:sym<ne>", $P2343)
    get_how $P2344, type_obj
    get_global $P2345, "!PREFIX__infix:sym<ne>"
    $P2344."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2345)
    get_how $P2346, type_obj
    .const 'Sub' $P2347 = "338_1298839231.515" 
    $P2346."add_method"(type_obj, "infix:sym<le>", $P2347)
    get_how $P2348, type_obj
    get_global $P2349, "!PREFIX__infix:sym<le>"
    $P2348."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2349)
    get_how $P2350, type_obj
    .const 'Sub' $P2351 = "340_1298839231.515" 
    $P2350."add_method"(type_obj, "infix:sym<ge>", $P2351)
    get_how $P2352, type_obj
    get_global $P2353, "!PREFIX__infix:sym<ge>"
    $P2352."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2353)
    get_how $P2354, type_obj
    .const 'Sub' $P2355 = "342_1298839231.515" 
    $P2354."add_method"(type_obj, "infix:sym<lt>", $P2355)
    get_how $P2356, type_obj
    get_global $P2357, "!PREFIX__infix:sym<lt>"
    $P2356."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2357)
    get_how $P2358, type_obj
    .const 'Sub' $P2359 = "344_1298839231.515" 
    $P2358."add_method"(type_obj, "infix:sym<gt>", $P2359)
    get_how $P2360, type_obj
    get_global $P2361, "!PREFIX__infix:sym<gt>"
    $P2360."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2361)
    get_how $P2362, type_obj
    .const 'Sub' $P2363 = "346_1298839231.515" 
    $P2362."add_method"(type_obj, "infix:sym<=:=>", $P2363)
    get_how $P2364, type_obj
    get_global $P2365, "!PREFIX__infix:sym<=:=>"
    $P2364."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2365)
    get_how $P2366, type_obj
    .const 'Sub' $P2367 = "348_1298839231.515" 
    $P2366."add_method"(type_obj, "infix:sym<~~>", $P2367)
    get_how $P2368, type_obj
    get_global $P2369, "!PREFIX__infix:sym<~~>"
    $P2368."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2369)
    get_how $P2370, type_obj
    .const 'Sub' $P2371 = "350_1298839231.515" 
    $P2370."add_method"(type_obj, "infix:sym<&&>", $P2371)
    get_how $P2372, type_obj
    get_global $P2373, "!PREFIX__infix:sym<&&>"
    $P2372."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2373)
    get_how $P2374, type_obj
    .const 'Sub' $P2375 = "352_1298839231.515" 
    $P2374."add_method"(type_obj, "infix:sym<||>", $P2375)
    get_how $P2376, type_obj
    get_global $P2377, "!PREFIX__infix:sym<||>"
    $P2376."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2377)
    get_how $P2378, type_obj
    .const 'Sub' $P2379 = "354_1298839231.515" 
    $P2378."add_method"(type_obj, "infix:sym<//>", $P2379)
    get_how $P2380, type_obj
    get_global $P2381, "!PREFIX__infix:sym<//>"
    $P2380."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2381)
    get_how $P2382, type_obj
    .const 'Sub' $P2383 = "356_1298839231.515" 
    $P2382."add_method"(type_obj, "infix:sym<?? !!>", $P2383)
    get_how $P2384, type_obj
    get_global $P2385, "!PREFIX__infix:sym<?? !!>"
    $P2384."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2385)
    get_how $P2386, type_obj
    .const 'Sub' $P2387 = "358_1298839231.515" 
    $P2386."add_method"(type_obj, "infix:sym<=>", $P2387)
    get_how $P2388, type_obj
    get_global $P2389, "!PREFIX__infix:sym<=>"
    $P2388."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2389)
    get_how $P2390, type_obj
    .const 'Sub' $P2391 = "360_1298839231.515" 
    $P2390."add_method"(type_obj, "infix:sym<:=>", $P2391)
    get_how $P2392, type_obj
    get_global $P2393, "!PREFIX__infix:sym<:=>"
    $P2392."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2393)
    get_how $P2394, type_obj
    .const 'Sub' $P2395 = "362_1298839231.515" 
    $P2394."add_method"(type_obj, "infix:sym<::=>", $P2395)
    get_how $P2396, type_obj
    get_global $P2397, "!PREFIX__infix:sym<::=>"
    $P2396."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2397)
    get_how $P2398, type_obj
    .const 'Sub' $P2399 = "364_1298839231.515" 
    $P2398."add_method"(type_obj, "infix:sym<,>", $P2399)
    get_how $P2400, type_obj
    get_global $P2401, "!PREFIX__infix:sym<,>"
    $P2400."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2401)
    get_how $P2402, type_obj
    .const 'Sub' $P2403 = "366_1298839231.515" 
    $P2402."add_method"(type_obj, "prefix:sym<return>", $P2403)
    get_how $P2404, type_obj
    get_global $P2405, "!PREFIX__prefix:sym<return>"
    $P2404."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2405)
    get_how $P2406, type_obj
    .const 'Sub' $P2407 = "369_1298839231.515" 
    $P2406."add_method"(type_obj, "prefix:sym<make>", $P2407)
    get_how $P2408, type_obj
    get_global $P2409, "!PREFIX__prefix:sym<make>"
    $P2408."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2409)
    get_how $P2410, type_obj
    .const 'Sub' $P2411 = "371_1298839231.515" 
    $P2410."add_method"(type_obj, "term:sym<last>", $P2411)
    get_how $P2412, type_obj
    get_global $P2413, "!PREFIX__term:sym<last>"
    $P2412."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2413)
    get_how $P2414, type_obj
    .const 'Sub' $P2415 = "373_1298839231.515" 
    $P2414."add_method"(type_obj, "term:sym<next>", $P2415)
    get_how $P2416, type_obj
    get_global $P2417, "!PREFIX__term:sym<next>"
    $P2416."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2417)
    get_how $P2418, type_obj
    .const 'Sub' $P2419 = "375_1298839231.515" 
    $P2418."add_method"(type_obj, "term:sym<redo>", $P2419)
    get_how $P2420, type_obj
    get_global $P2421, "!PREFIX__term:sym<redo>"
    $P2420."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2421)
    get_how $P2422, type_obj
    .const 'Sub' $P2423 = "377_1298839231.515" 
    $P2422."add_method"(type_obj, "smartmatch", $P2423)
    get_how $P2424, type_obj
    get_hll_global $P2425, ["HLL"], "Grammar"
    $P2424."add_parent"(type_obj, $P2425)
    get_how $P2426, type_obj
    $P2427 = $P2426."compose"(type_obj)
    .return ($P2427)
.end


.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1298839231.515") :outer("11_1298839231.515")
    .param pmc param_19
.annotate 'line', 4
    .lex "self", param_19
.annotate 'line', 5
    $P20 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P20
.annotate 'line', 12
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P21
.annotate 'line', 21
    new $P22, "Undef"
    .lex "$*DEFAULT-METAATTR", $P22
.annotate 'line', 22
    $P23 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P23
.annotate 'line', 25
    new $P24, "Undef"
    .lex "$*SCOPE", $P24
.annotate 'line', 26
    new $P25, "Undef"
    .lex "$*MULTINESS", $P25
.annotate 'line', 27
    new $P26, "Undef"
    .lex "$*INVOCANT_OK", $P26
.annotate 'line', 28
    new $P27, "Undef"
    .lex "$*RETURN_USED", $P27
.annotate 'line', 29
    new $P28, "Undef"
    .lex "$*PACKAGE-SETUP", $P28
.annotate 'line', 4
    find_lex $P29, "%*LANG"
    unless_null $P29, vivify_404
    get_hll_global $P29, "%LANG"
    unless_null $P29, vivify_405
    die "Contextual %*LANG not found"
  vivify_405:
  vivify_404:
.annotate 'line', 6
    get_hll_global $P30, ["NQP"], "Regex"
    find_lex $P31, "%*LANG"
    unless_null $P31, vivify_406
    get_hll_global $P31, "%LANG"
    unless_null $P31, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
    store_lex "%*LANG", $P31
  vivify_406:
    set $P31["Regex"], $P30
.annotate 'line', 7
    get_hll_global $P32, ["NQP"], "RegexActions"
    find_lex $P33, "%*LANG"
    unless_null $P33, vivify_408
    get_hll_global $P33, "%LANG"
    unless_null $P33, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P33
  vivify_408:
    set $P33["Regex-actions"], $P32
.annotate 'line', 8
    get_hll_global $P34, ["NQP"], "Grammar"
    find_lex $P35, "%*LANG"
    unless_null $P35, vivify_410
    get_hll_global $P35, "%LANG"
    unless_null $P35, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P35
  vivify_410:
    set $P35["MAIN"], $P34
.annotate 'line', 9
    get_hll_global $P36, ["NQP"], "Actions"
    find_lex $P37, "%*LANG"
    unless_null $P37, vivify_412
    get_hll_global $P37, "%LANG"
    unless_null $P37, vivify_413
    die "Contextual %*LANG not found"
  vivify_413:
    store_lex "%*LANG", $P37
  vivify_412:
    set $P37["MAIN-actions"], $P36
    find_lex $P38, "%*HOW"
    unless_null $P38, vivify_414
    get_hll_global $P38, "%HOW"
    unless_null $P38, vivify_415
    die "Contextual %*HOW not found"
  vivify_415:
  vivify_414:
.annotate 'line', 13
    get_hll_global $P39, "KnowHOW"
    find_lex $P40, "%*HOW"
    unless_null $P40, vivify_416
    get_hll_global $P40, "%HOW"
    unless_null $P40, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
    store_lex "%*HOW", $P40
  vivify_416:
    set $P40["knowhow"], $P39
.annotate 'line', 14
    get_hll_global $P41, "NQPModuleHOW"
    find_lex $P42, "%*HOW"
    unless_null $P42, vivify_418
    get_hll_global $P42, "%HOW"
    unless_null $P42, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P42
  vivify_418:
    set $P42["module"], $P41
.annotate 'line', 15
    get_hll_global $P43, "NQPClassHOW"
    find_lex $P44, "%*HOW"
    unless_null $P44, vivify_420
    get_hll_global $P44, "%HOW"
    unless_null $P44, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P44
  vivify_420:
    set $P44["class"], $P43
.annotate 'line', 16
    get_hll_global $P45, "NQPClassHOW"
    find_lex $P46, "%*HOW"
    unless_null $P46, vivify_422
    get_hll_global $P46, "%HOW"
    unless_null $P46, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P46
  vivify_422:
    set $P46["grammar"], $P45
.annotate 'line', 17
    get_hll_global $P47, "NQPParametricRoleHOW"
    find_lex $P48, "%*HOW"
    unless_null $P48, vivify_424
    get_hll_global $P48, "%HOW"
    unless_null $P48, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
    store_lex "%*HOW", $P48
  vivify_424:
    set $P48["role"], $P47
.annotate 'line', 18
    get_hll_global $P49, "NQPNativeHOW"
    find_lex $P50, "%*HOW"
    unless_null $P50, vivify_426
    get_hll_global $P50, "%HOW"
    unless_null $P50, vivify_427
    die "Contextual %*HOW not found"
  vivify_427:
    store_lex "%*HOW", $P50
  vivify_426:
    set $P50["native"], $P49
.annotate 'line', 21
    new $P51, "String"
    assign $P51, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P51
    find_lex $P52, "%*HOW-METAATTR"
    unless_null $P52, vivify_428
    get_hll_global $P52, "%HOW-METAATTR"
    unless_null $P52, vivify_429
    die "Contextual %*HOW-METAATTR not found"
  vivify_429:
  vivify_428:
.annotate 'line', 23
    new $P53, "String"
    assign $P53, "KnowHOWAttribute"
    find_lex $P54, "%*HOW-METAATTR"
    unless_null $P54, vivify_430
    get_hll_global $P54, "%HOW-METAATTR"
    unless_null $P54, vivify_431
    die "Contextual %*HOW-METAATTR not found"
  vivify_431:
    store_lex "%*HOW-METAATTR", $P54
  vivify_430:
    set $P54["knowhow"], $P53
.annotate 'line', 25
    new $P55, "String"
    assign $P55, ""
    store_lex "$*SCOPE", $P55
.annotate 'line', 26
    new $P56, "String"
    assign $P56, ""
    store_lex "$*MULTINESS", $P56
.annotate 'line', 27
    new $P57, "Integer"
    assign $P57, 0
    store_lex "$*INVOCANT_OK", $P57
.annotate 'line', 28
    new $P58, "Integer"
    assign $P58, 0
    store_lex "$*RETURN_USED", $P58
    find_lex $P59, "$*PACKAGE-SETUP"
    unless_null $P59, vivify_432
    get_hll_global $P59, "$PACKAGE-SETUP"
    unless_null $P59, vivify_433
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_433:
  vivify_432:
.annotate 'line', 30
    find_lex $P60, "self"
    $P61 = $P60."comp_unit"()
.annotate 'line', 4
    .return ($P61)
.end


.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx63_tgt
    .local int rx63_pos
    .local int rx63_off
    .local int rx63_eos
    .local int rx63_rep
    .local pmc rx63_cur
    .local pmc rx63_debug
    (rx63_cur, rx63_pos, rx63_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx63_cur
    .local pmc match
    .lex "$/", match
    length rx63_eos, rx63_tgt
    gt rx63_pos, rx63_eos, rx63_done
    set rx63_off, 0
    lt rx63_pos, 2, rx63_start
    sub rx63_off, rx63_pos, 1
    substr rx63_tgt, rx63_tgt, rx63_off
  rx63_start:
    eq $I10, 1, rx63_restart
    if_null rx63_debug, debug_434
    rx63_cur."!cursor_debug"("START", "identifier")
  debug_434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan67_done
    goto rxscan67_scan
  rxscan67_loop:
    (rx63_pos) = rx63_cur."from"()
    inc rx63_pos
    rx63_cur."!cursor_from"(rx63_pos)
    ge rx63_pos, rx63_eos, rxscan67_done
  rxscan67_scan:
    set_addr $I10, rxscan67_loop
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxscan67_done:
.annotate 'line', 35
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
  # rx rxquantr68 ** 0..*
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxquantr68_loop:
  # rx enumcharlist negate=0 
    ge rx63_pos, rx63_eos, rx63_fail
    sub $I10, rx63_pos, rx63_off
    substr $S10, rx63_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx63_fail
    inc rx63_pos
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
    set_addr $I10, rxquantr68_done
    (rx63_rep) = rx63_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(rx63_rep, rx63_pos, $I10)
    goto rxquantr68_loop
  rxquantr68_done:
  # rx pass
    rx63_cur."!cursor_pass"(rx63_pos, "identifier")
    if_null rx63_debug, debug_435
    rx63_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx63_pos)
  debug_435:
    .return (rx63_cur)
  rx63_restart:
.annotate 'line', 4
    if_null rx63_debug, debug_436
    rx63_cur."!cursor_debug"("NEXT", "identifier")
  debug_436:
  rx63_fail:
    (rx63_rep, rx63_pos, $I10, $P10) = rx63_cur."!mark_fail"(0)
    lt rx63_pos, -1, rx63_done
    eq rx63_pos, -1, rx63_fail
    jump $I10
  rx63_done:
    rx63_cur."!cursor_fail"()
    if_null rx63_debug, debug_437
    rx63_cur."!cursor_debug"("FAIL", "identifier")
  debug_437:
    .return (rx63_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1298839231.515") :method
.annotate 'line', 4
    $P65 = self."!PREFIX__!subrule"("ident", "")
    new $P66, "ResizablePMCArray"
    push $P66, $P65
    .return ($P66)
.end


.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx70_tgt
    .local int rx70_pos
    .local int rx70_off
    .local int rx70_eos
    .local int rx70_rep
    .local pmc rx70_cur
    .local pmc rx70_debug
    (rx70_cur, rx70_pos, rx70_tgt, $I10) = self."!cursor_start"()
    rx70_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx70_cur
    .local pmc match
    .lex "$/", match
    length rx70_eos, rx70_tgt
    gt rx70_pos, rx70_eos, rx70_done
    set rx70_off, 0
    lt rx70_pos, 2, rx70_start
    sub rx70_off, rx70_pos, 1
    substr rx70_tgt, rx70_tgt, rx70_off
  rx70_start:
    eq $I10, 1, rx70_restart
    if_null rx70_debug, debug_438
    rx70_cur."!cursor_debug"("START", "name")
  debug_438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan73_done
    goto rxscan73_scan
  rxscan73_loop:
    (rx70_pos) = rx70_cur."from"()
    inc rx70_pos
    rx70_cur."!cursor_from"(rx70_pos)
    ge rx70_pos, rx70_eos, rxscan73_done
  rxscan73_scan:
    set_addr $I10, rxscan73_loop
    rx70_cur."!mark_push"(0, rx70_pos, $I10)
  rxscan73_done:
.annotate 'line', 37
  # rx rxquantr74 ** 1..*
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(0, -1, $I10)
  rxquantr74_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx70_cur."!cursor_pos"(rx70_pos)
    $P10 = rx70_cur."identifier"()
    unless $P10, rx70_fail
    goto rxsubrule75_pass
  rxsubrule75_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx70_fail
  rxsubrule75_pass:
    set_addr $I10, rxsubrule75_back
    rx70_cur."!mark_push"(0, rx70_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx70_pos = $P10."pos"()
    set_addr $I10, rxquantr74_done
    (rx70_rep) = rx70_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(rx70_rep, rx70_pos, $I10)
  # rx literal  "::"
    add $I11, rx70_pos, 2
    gt $I11, rx70_eos, rx70_fail
    sub $I11, rx70_pos, rx70_off
    substr $S10, rx70_tgt, $I11, 2
    ne $S10, "::", rx70_fail
    add rx70_pos, 2
    goto rxquantr74_loop
  rxquantr74_done:
  # rx pass
    rx70_cur."!cursor_pass"(rx70_pos, "name")
    if_null rx70_debug, debug_439
    rx70_cur."!cursor_debug"("PASS", "name", " at pos=", rx70_pos)
  debug_439:
    .return (rx70_cur)
  rx70_restart:
.annotate 'line', 4
    if_null rx70_debug, debug_440
    rx70_cur."!cursor_debug"("NEXT", "name")
  debug_440:
  rx70_fail:
    (rx70_rep, rx70_pos, $I10, $P10) = rx70_cur."!mark_fail"(0)
    lt rx70_pos, -1, rx70_done
    eq rx70_pos, -1, rx70_fail
    jump $I10
  rx70_done:
    rx70_cur."!cursor_fail"()
    if_null rx70_debug, debug_441
    rx70_cur."!cursor_debug"("FAIL", "name")
  debug_441:
    .return (rx70_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1298839231.515") :method
.annotate 'line', 4
    new $P72, "ResizablePMCArray"
    push $P72, ""
    .return ($P72)
.end


.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx77_tgt
    .local int rx77_pos
    .local int rx77_off
    .local int rx77_eos
    .local int rx77_rep
    .local pmc rx77_cur
    .local pmc rx77_debug
    (rx77_cur, rx77_pos, rx77_tgt, $I10) = self."!cursor_start"()
    rx77_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx77_cur
    .local pmc match
    .lex "$/", match
    length rx77_eos, rx77_tgt
    gt rx77_pos, rx77_eos, rx77_done
    set rx77_off, 0
    lt rx77_pos, 2, rx77_start
    sub rx77_off, rx77_pos, 1
    substr rx77_tgt, rx77_tgt, rx77_off
  rx77_start:
    eq $I10, 1, rx77_restart
    if_null rx77_debug, debug_442
    rx77_cur."!cursor_debug"("START", "deflongname")
  debug_442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan81_done
    goto rxscan81_scan
  rxscan81_loop:
    (rx77_pos) = rx77_cur."from"()
    inc rx77_pos
    rx77_cur."!cursor_from"(rx77_pos)
    ge rx77_pos, rx77_eos, rxscan81_done
  rxscan81_scan:
    set_addr $I10, rxscan81_loop
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxscan81_done:
.annotate 'line', 40
  # rx subrule "identifier" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."identifier"()
    unless $P10, rx77_fail
    rx77_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx77_pos = $P10."pos"()
  # rx rxquantr82 ** 0..1
    set_addr $I10, rxquantr82_done
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxquantr82_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."colonpair"()
    unless $P10, rx77_fail
    goto rxsubrule83_pass
  rxsubrule83_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx77_fail
  rxsubrule83_pass:
    set_addr $I10, rxsubrule83_back
    rx77_cur."!mark_push"(0, rx77_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx77_pos = $P10."pos"()
    set_addr $I10, rxquantr82_done
    (rx77_rep) = rx77_cur."!mark_commit"($I10)
  rxquantr82_done:
.annotate 'line', 39
  # rx pass
    rx77_cur."!cursor_pass"(rx77_pos, "deflongname")
    if_null rx77_debug, debug_443
    rx77_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx77_pos)
  debug_443:
    .return (rx77_cur)
  rx77_restart:
.annotate 'line', 4
    if_null rx77_debug, debug_444
    rx77_cur."!cursor_debug"("NEXT", "deflongname")
  debug_444:
  rx77_fail:
    (rx77_rep, rx77_pos, $I10, $P10) = rx77_cur."!mark_fail"(0)
    lt rx77_pos, -1, rx77_done
    eq rx77_pos, -1, rx77_fail
    jump $I10
  rx77_done:
    rx77_cur."!cursor_fail"()
    if_null rx77_debug, debug_445
    rx77_cur."!cursor_debug"("FAIL", "deflongname")
  debug_445:
    .return (rx77_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1298839231.515") :method
.annotate 'line', 4
    $P79 = self."!PREFIX__!subrule"("identifier", "")
    new $P80, "ResizablePMCArray"
    push $P80, $P79
    .return ($P80)
.end


.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx85_tgt
    .local int rx85_pos
    .local int rx85_off
    .local int rx85_eos
    .local int rx85_rep
    .local pmc rx85_cur
    .local pmc rx85_debug
    (rx85_cur, rx85_pos, rx85_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx85_cur
    .local pmc match
    .lex "$/", match
    length rx85_eos, rx85_tgt
    gt rx85_pos, rx85_eos, rx85_done
    set rx85_off, 0
    lt rx85_pos, 2, rx85_start
    sub rx85_off, rx85_pos, 1
    substr rx85_tgt, rx85_tgt, rx85_off
  rx85_start:
    eq $I10, 1, rx85_restart
    if_null rx85_debug, debug_446
    rx85_cur."!cursor_debug"("START", "ENDSTMT")
  debug_446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan88_done
    goto rxscan88_scan
  rxscan88_loop:
    (rx85_pos) = rx85_cur."from"()
    inc rx85_pos
    rx85_cur."!cursor_from"(rx85_pos)
    ge rx85_pos, rx85_eos, rxscan88_done
  rxscan88_scan:
    set_addr $I10, rxscan88_loop
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxscan88_done:
.annotate 'line', 47
  # rx rxquantr89 ** 0..1
    set_addr $I10, rxquantr89_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr89_loop:
  alt90_0:
.annotate 'line', 44
    set_addr $I10, alt90_1
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
.annotate 'line', 45
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx85_pos, rx85_off
    set rx85_rep, 0
    sub $I12, rx85_eos, rx85_pos
  rxenumcharlistq91_loop:
    le $I12, 0, rxenumcharlistq91_done
    substr $S10, rx85_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq91_done
    inc rx85_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq91_loop
  rxenumcharlistq91_done:
    add rx85_pos, rx85_pos, rx85_rep
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor92_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor92_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor92_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
    goto alt90_end
  alt90_1:
.annotate 'line', 46
  # rx rxquantr93 ** 0..1
    set_addr $I10, rxquantr93_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr93_loop:
  # rx subrule "unv" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."unv"()
    unless $P10, rx85_fail
    goto rxsubrule94_pass
  rxsubrule94_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx85_fail
  rxsubrule94_pass:
    set_addr $I10, rxsubrule94_back
    rx85_cur."!mark_push"(0, rx85_pos, $I10, $P10)
    rx85_pos = $P10."pos"()
    set_addr $I10, rxquantr93_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr93_done:
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor95_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor95_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor95_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
  alt90_end:
.annotate 'line', 47
    set_addr $I10, rxquantr89_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr89_done:
.annotate 'line', 43
  # rx pass
    rx85_cur."!cursor_pass"(rx85_pos, "ENDSTMT")
    if_null rx85_debug, debug_447
    rx85_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx85_pos)
  debug_447:
    .return (rx85_cur)
  rx85_restart:
.annotate 'line', 4
    if_null rx85_debug, debug_448
    rx85_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_448:
  rx85_fail:
    (rx85_rep, rx85_pos, $I10, $P10) = rx85_cur."!mark_fail"(0)
    lt rx85_pos, -1, rx85_done
    eq rx85_pos, -1, rx85_fail
    jump $I10
  rx85_done:
    rx85_cur."!cursor_fail"()
    if_null rx85_debug, debug_449
    rx85_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_449:
    .return (rx85_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1298839231.515") :method
.annotate 'line', 4
    new $P87, "ResizablePMCArray"
    push $P87, ""
    .return ($P87)
.end


.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx97_tgt
    .local int rx97_pos
    .local int rx97_off
    .local int rx97_eos
    .local int rx97_rep
    .local pmc rx97_cur
    .local pmc rx97_debug
    (rx97_cur, rx97_pos, rx97_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx97_cur
    .local pmc match
    .lex "$/", match
    length rx97_eos, rx97_tgt
    gt rx97_pos, rx97_eos, rx97_done
    set rx97_off, 0
    lt rx97_pos, 2, rx97_start
    sub rx97_off, rx97_pos, 1
    substr rx97_tgt, rx97_tgt, rx97_off
  rx97_start:
    eq $I10, 1, rx97_restart
    if_null rx97_debug, debug_450
    rx97_cur."!cursor_debug"("START", "ws")
  debug_450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan100_done
    goto rxscan100_scan
  rxscan100_loop:
    (rx97_pos) = rx97_cur."from"()
    inc rx97_pos
    rx97_cur."!cursor_from"(rx97_pos)
    ge rx97_pos, rx97_eos, rxscan100_done
  rxscan100_scan:
    set_addr $I10, rxscan100_loop
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxscan100_done:
  alt101_0:
.annotate 'line', 50
    set_addr $I10, alt101_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 51
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKED"("ws")
    unless $P10, rx97_fail
    goto alt101_end
  alt101_1:
.annotate 'line', 52
  # rx subrule "ww" subtype=zerowidth negate=1
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."ww"()
    if $P10, rx97_fail
.annotate 'line', 57
  # rx rxquantr102 ** 0..*
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxquantr102_loop:
  alt103_0:
.annotate 'line', 53
    set_addr $I10, alt103_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq104_loop:
    le $I12, 0, rxenumcharlistq104_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq104_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq104_loop
  rxenumcharlistq104_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
    goto alt103_end
  alt103_1:
    set_addr $I10, alt103_2
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 54
  # rx literal  "#"
    add $I11, rx97_pos, 1
    gt $I11, rx97_eos, rx97_fail
    sub $I11, rx97_pos, rx97_off
    ord $I11, rx97_tgt, $I11
    ne $I11, 35, rx97_fail
    add rx97_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx97_pos, rx97_off
    find_cclass $I11, 4096, rx97_tgt, $I10, rx97_eos
    add rx97_pos, rx97_off, $I11
    goto alt103_end
  alt103_2:
    set_addr $I10, alt103_3
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 55
  # rxanchor bol
    eq rx97_pos, 0, rxanchor105_done
    ge rx97_pos, rx97_eos, rx97_fail
    sub $I10, rx97_pos, rx97_off
    dec $I10
    is_cclass $I11, 4096, rx97_tgt, $I10
    unless $I11, rx97_fail
  rxanchor105_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."pod_comment"()
    unless $P10, rx97_fail
    rx97_pos = $P10."pos"()
    goto alt103_end
  alt103_3:
.annotate 'line', 56
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq106_loop:
    le $I12, 0, rxenumcharlistq106_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq106_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq106_loop
  rxenumcharlistq106_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
  alt103_end:
.annotate 'line', 57
    set_addr $I10, rxquantr102_done
    (rx97_rep) = rx97_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(rx97_rep, rx97_pos, $I10)
    goto rxquantr102_loop
  rxquantr102_done:
.annotate 'line', 58
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKER"("ws")
    unless $P10, rx97_fail
  alt101_end:
.annotate 'line', 50
  # rx pass
    rx97_cur."!cursor_pass"(rx97_pos, "ws")
    if_null rx97_debug, debug_451
    rx97_cur."!cursor_debug"("PASS", "ws", " at pos=", rx97_pos)
  debug_451:
    .return (rx97_cur)
  rx97_restart:
.annotate 'line', 4
    if_null rx97_debug, debug_452
    rx97_cur."!cursor_debug"("NEXT", "ws")
  debug_452:
  rx97_fail:
    (rx97_rep, rx97_pos, $I10, $P10) = rx97_cur."!mark_fail"(0)
    lt rx97_pos, -1, rx97_done
    eq rx97_pos, -1, rx97_fail
    jump $I10
  rx97_done:
    rx97_cur."!cursor_fail"()
    if_null rx97_debug, debug_453
    rx97_cur."!cursor_debug"("FAIL", "ws")
  debug_453:
    .return (rx97_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1298839231.515") :method
.annotate 'line', 4
    new $P99, "ResizablePMCArray"
    push $P99, ""
    push $P99, ""
    .return ($P99)
.end


.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P115 = "25_1298839231.515" 
    capture_lex $P115
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_454
    rx108_cur."!cursor_debug"("START", "unv")
  debug_454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
  alt112_0:
.annotate 'line', 63
    set_addr $I10, alt112_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 64
  # rxanchor bol
    eq rx108_pos, 0, rxanchor113_done
    ge rx108_pos, rx108_eos, rx108_fail
    sub $I10, rx108_pos, rx108_off
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    unless $I11, rx108_fail
  rxanchor113_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    .const 'Sub' $P115 = "25_1298839231.515" 
    capture_lex $P115
    $P10 = rx108_cur."before"($P115)
    unless $P10, rx108_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."pod_comment"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
    goto alt112_end
  alt112_1:
    set_addr $I10, alt112_2
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 65
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq120_loop:
    le $I12, 0, rxenumcharlistq120_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq120_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq120_loop
  rxenumcharlistq120_done:
    add rx108_pos, rx108_pos, rx108_rep
  # rx literal  "#"
    add $I11, rx108_pos, 1
    gt $I11, rx108_eos, rx108_fail
    sub $I11, rx108_pos, rx108_off
    ord $I11, rx108_tgt, $I11
    ne $I11, 35, rx108_fail
    add rx108_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx108_pos, rx108_off
    find_cclass $I11, 4096, rx108_tgt, $I10, rx108_eos
    add rx108_pos, rx108_off, $I11
    goto alt112_end
  alt112_2:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq121_loop:
    le $I12, 0, rxenumcharlistq121_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq121_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq121_loop
  rxenumcharlistq121_done:
    lt rx108_rep, 1, rx108_fail
    add rx108_pos, rx108_pos, rx108_rep
  alt112_end:
.annotate 'line', 61
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "unv")
    if_null rx108_debug, debug_459
    rx108_cur."!cursor_debug"("PASS", "unv", " at pos=", rx108_pos)
  debug_459:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 4
    if_null rx108_debug, debug_460
    rx108_cur."!cursor_debug"("NEXT", "unv")
  debug_460:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_461
    rx108_cur."!cursor_debug"("FAIL", "unv")
  debug_461:
    .return (rx108_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1298839231.515") :method
.annotate 'line', 4
    new $P110, "ResizablePMCArray"
    push $P110, ""
    push $P110, ""
    push $P110, ""
    .return ($P110)
.end


.namespace ["NQP";"Grammar"]
.sub "_block114"  :anon :subid("25_1298839231.515") :method :outer("23_1298839231.515")
.annotate 'line', 64
    .local string rx116_tgt
    .local int rx116_pos
    .local int rx116_off
    .local int rx116_eos
    .local int rx116_rep
    .local pmc rx116_cur
    .local pmc rx116_debug
    (rx116_cur, rx116_pos, rx116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx116_cur
    .local pmc match
    .lex "$/", match
    length rx116_eos, rx116_tgt
    gt rx116_pos, rx116_eos, rx116_done
    set rx116_off, 0
    lt rx116_pos, 2, rx116_start
    sub rx116_off, rx116_pos, 1
    substr rx116_tgt, rx116_tgt, rx116_off
  rx116_start:
    eq $I10, 1, rx116_restart
    if_null rx116_debug, debug_455
    rx116_cur."!cursor_debug"("START", "")
  debug_455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan117_done
    goto rxscan117_scan
  rxscan117_loop:
    (rx116_pos) = rx116_cur."from"()
    inc rx116_pos
    rx116_cur."!cursor_from"(rx116_pos)
    ge rx116_pos, rx116_eos, rxscan117_done
  rxscan117_scan:
    set_addr $I10, rxscan117_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  rxscan117_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq118_loop:
    le $I12, 0, rxenumcharlistq118_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq118_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq118_loop
  rxenumcharlistq118_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "="
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 61, rx116_fail
    add rx116_pos, 1
  alt119_0:
    set_addr $I10, alt119_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rx charclass w
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
    inc rx116_pos
    goto alt119_end
  alt119_1:
  # rx literal  "\\"
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 92, rx116_fail
    add rx116_pos, 1
  alt119_end:
  # rx pass
    rx116_cur."!cursor_pass"(rx116_pos, "")
    if_null rx116_debug, debug_456
    rx116_cur."!cursor_debug"("PASS", "", " at pos=", rx116_pos)
  debug_456:
    .return (rx116_cur)
  rx116_restart:
    if_null rx116_debug, debug_457
    rx116_cur."!cursor_debug"("NEXT", "")
  debug_457:
  rx116_fail:
    (rx116_rep, rx116_pos, $I10, $P10) = rx116_cur."!mark_fail"(0)
    lt rx116_pos, -1, rx116_done
    eq rx116_pos, -1, rx116_fail
    jump $I10
  rx116_done:
    rx116_cur."!cursor_fail"()
    if_null rx116_debug, debug_458
    rx116_cur."!cursor_debug"("FAIL", "")
  debug_458:
    .return (rx116_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P154 = "28_1298839231.515" 
    capture_lex $P154
    .local string rx123_tgt
    .local int rx123_pos
    .local int rx123_off
    .local int rx123_eos
    .local int rx123_rep
    .local pmc rx123_cur
    .local pmc rx123_debug
    (rx123_cur, rx123_pos, rx123_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx123_cur
    .local pmc match
    .lex "$/", match
    length rx123_eos, rx123_tgt
    gt rx123_pos, rx123_eos, rx123_done
    set rx123_off, 0
    lt rx123_pos, 2, rx123_start
    sub rx123_off, rx123_pos, 1
    substr rx123_tgt, rx123_tgt, rx123_off
  rx123_start:
    eq $I10, 1, rx123_restart
    if_null rx123_debug, debug_462
    rx123_cur."!cursor_debug"("START", "pod_comment")
  debug_462:
    $I10 = self.'from'()
    ne $I10, -1, rxscan126_done
    goto rxscan126_scan
  rxscan126_loop:
    (rx123_pos) = rx123_cur."from"()
    inc rx123_pos
    rx123_cur."!cursor_from"(rx123_pos)
    ge rx123_pos, rx123_eos, rxscan126_done
  rxscan126_scan:
    set_addr $I10, rxscan126_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  rxscan126_done:
.annotate 'line', 71
  # rxanchor bol
    eq rx123_pos, 0, rxanchor127_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor127_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq128_loop:
    le $I12, 0, rxenumcharlistq128_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq128_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq128_loop
  rxenumcharlistq128_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "="
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 61, rx123_fail
    add rx123_pos, 1
  alt129_0:
.annotate 'line', 72
    set_addr $I10, alt129_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 73
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq130_loop:
    le $I12, 0, rxenumcharlistq130_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq130_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq130_loop
  rxenumcharlistq130_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  alt131_0:
.annotate 'line', 74
    set_addr $I10, alt131_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx rxquantf132 ** 0..*
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf132_done
  rxquantf132_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf132_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq135_loop:
    le $I12, 0, rxenumcharlistq135_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq135_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq135_loop
  rxenumcharlistq135_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt131_end
  alt131_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_not_cclass $I11, 65535, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt131_end:
.annotate 'line', 73
    goto alt129_end
  alt129_1:
    set_addr $I10, alt129_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 75
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq136_loop:
    le $I12, 0, rxenumcharlistq136_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq136_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq136_loop
  rxenumcharlistq136_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
  alt137_0:
.annotate 'line', 76
    set_addr $I10, alt137_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 77
  # rx rxquantf138 ** 0..*
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf138_done
  rxquantf138_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf138_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq140_loop:
    le $I12, 0, rxenumcharlistq140_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq140_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq140_loop
  rxenumcharlistq140_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."!BACKREF"("identifier")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt137_end
  alt137_1:
.annotate 'line', 78
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt137_end:
.annotate 'line', 75
    goto alt129_end
  alt129_2:
    set_addr $I10, alt129_3
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx123_pos, rx123_pos, rx123_rep
  alt144_0:
.annotate 'line', 81
    set_addr $I10, alt144_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rxanchor eol
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rxanchor145_done
    ne rx123_pos, rx123_eos, rx123_fail
    eq rx123_pos, 0, rxanchor145_done
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rx123_fail
  rxanchor145_done:
    goto alt144_end
  alt144_1:
    set_addr $I10, alt144_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx literal  "#"
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 35, rx123_fail
    add rx123_pos, 1
    goto alt144_end
  alt144_2:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt144_end:
  alt146_0:
.annotate 'line', 82
    set_addr $I10, alt146_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 83
  # rx rxquantf147 ** 0..*
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf147_done
  rxquantf147_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf147_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq149_loop:
    le $I12, 0, rxenumcharlistq149_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq149_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq149_loop
  rxenumcharlistq149_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt146_end
  alt146_1:
.annotate 'line', 84
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt146_end:
.annotate 'line', 80
    goto alt129_end
  alt129_3:
    set_addr $I10, alt129_4
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 86
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
.annotate 'line', 87
  # rx rxquantf150 ** 0..*
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf150_done
  rxquantf150_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf150_done:
  # rxanchor bol
    eq rx123_pos, 0, rxanchor152_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor152_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    .const 'Sub' $P154 = "28_1298839231.515" 
    capture_lex $P154
    $P10 = rx123_cur."before"($P154)
    unless $P10, rx123_fail
.annotate 'line', 86
    goto alt129_end
  alt129_4:
  alt160_0:
.annotate 'line', 93
    set_addr $I10, alt160_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx charclass s
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 32, rx123_tgt, $I10
    unless $I11, rx123_fail
    inc rx123_pos
    goto alt160_end
  alt160_1:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Illegal pod directive")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 94
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt129_end:
.annotate 'line', 70
  # rx pass
    rx123_cur."!cursor_pass"(rx123_pos, "pod_comment")
    if_null rx123_debug, debug_467
    rx123_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx123_pos)
  debug_467:
    .return (rx123_cur)
  rx123_restart:
.annotate 'line', 4
    if_null rx123_debug, debug_468
    rx123_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_468:
  rx123_fail:
    (rx123_rep, rx123_pos, $I10, $P10) = rx123_cur."!mark_fail"(0)
    lt rx123_pos, -1, rx123_done
    eq rx123_pos, -1, rx123_fail
    jump $I10
  rx123_done:
    rx123_cur."!cursor_fail"()
    if_null rx123_debug, debug_469
    rx123_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_469:
    .return (rx123_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1298839231.515") :method
.annotate 'line', 4
    new $P125, "ResizablePMCArray"
    push $P125, ""
    .return ($P125)
.end


.namespace ["NQP";"Grammar"]
.sub "_block153"  :anon :subid("28_1298839231.515") :method :outer("26_1298839231.515")
.annotate 'line', 87
    .local string rx155_tgt
    .local int rx155_pos
    .local int rx155_off
    .local int rx155_eos
    .local int rx155_rep
    .local pmc rx155_cur
    .local pmc rx155_debug
    (rx155_cur, rx155_pos, rx155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx155_cur
    .local pmc match
    .lex "$/", match
    length rx155_eos, rx155_tgt
    gt rx155_pos, rx155_eos, rx155_done
    set rx155_off, 0
    lt rx155_pos, 2, rx155_start
    sub rx155_off, rx155_pos, 1
    substr rx155_tgt, rx155_tgt, rx155_off
  rx155_start:
    eq $I10, 1, rx155_restart
    if_null rx155_debug, debug_463
    rx155_cur."!cursor_debug"("START", "")
  debug_463:
    $I10 = self.'from'()
    ne $I10, -1, rxscan156_done
    goto rxscan156_scan
  rxscan156_loop:
    (rx155_pos) = rx155_cur."from"()
    inc rx155_pos
    rx155_cur."!cursor_from"(rx155_pos)
    ge rx155_pos, rx155_eos, rxscan156_done
  rxscan156_scan:
    set_addr $I10, rxscan156_loop
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxscan156_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx155_pos, rx155_off
    set rx155_rep, 0
    sub $I12, rx155_eos, rx155_pos
  rxenumcharlistq157_loop:
    le $I12, 0, rxenumcharlistq157_done
    substr $S10, rx155_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq157_done
    inc rx155_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq157_loop
  rxenumcharlistq157_done:
    add rx155_pos, rx155_pos, rx155_rep
  alt158_0:
    set_addr $I10, alt158_1
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
.annotate 'line', 88
  # rx literal  "="
    add $I11, rx155_pos, 1
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    ord $I11, rx155_tgt, $I11
    ne $I11, 61, rx155_fail
    add rx155_pos, 1
.annotate 'line', 90
  # rx rxquantr159 ** 0..1
    set_addr $I10, rxquantr159_done
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxquantr159_loop:
.annotate 'line', 89
  # rx literal  "cut"
    add $I11, rx155_pos, 3
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    substr $S10, rx155_tgt, $I11, 3
    ne $S10, "cut", rx155_fail
    add rx155_pos, 3
  # rxanchor rwb
    le rx155_pos, 0, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 8192, rx155_tgt, $I10
    if $I11, rx155_fail
    dec $I10
    is_cclass $I11, 8192, rx155_tgt, $I10
    unless $I11, rx155_fail
.annotate 'line', 90
  # rx subrule "panic" subtype=method negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx155_fail
    rx155_pos = $P10."pos"()
    set_addr $I10, rxquantr159_done
    (rx155_rep) = rx155_cur."!mark_commit"($I10)
  rxquantr159_done:
.annotate 'line', 87
    goto alt158_end
  alt158_1:
.annotate 'line', 91
  # rx charclass nl
    ge rx155_pos, rx155_eos, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 4096, rx155_tgt, $I10
    unless $I11, rx155_fail
    substr $S10, rx155_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx155_pos, $I11
    inc rx155_pos
  alt158_end:
.annotate 'line', 87
  # rx pass
    rx155_cur."!cursor_pass"(rx155_pos, "")
    if_null rx155_debug, debug_464
    rx155_cur."!cursor_debug"("PASS", "", " at pos=", rx155_pos)
  debug_464:
    .return (rx155_cur)
  rx155_restart:
    if_null rx155_debug, debug_465
    rx155_cur."!cursor_debug"("NEXT", "")
  debug_465:
  rx155_fail:
    (rx155_rep, rx155_pos, $I10, $P10) = rx155_cur."!mark_fail"(0)
    lt rx155_pos, -1, rx155_done
    eq rx155_pos, -1, rx155_fail
    jump $I10
  rx155_done:
    rx155_cur."!cursor_fail"()
    if_null rx155_debug, debug_466
    rx155_cur."!cursor_debug"("FAIL", "")
  debug_466:
    .return (rx155_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx162_tgt
    .local int rx162_pos
    .local int rx162_off
    .local int rx162_eos
    .local int rx162_rep
    .local pmc rx162_cur
    .local pmc rx162_debug
    (rx162_cur, rx162_pos, rx162_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx162_cur
    .local pmc match
    .lex "$/", match
    length rx162_eos, rx162_tgt
    gt rx162_pos, rx162_eos, rx162_done
    set rx162_off, 0
    lt rx162_pos, 2, rx162_start
    sub rx162_off, rx162_pos, 1
    substr rx162_tgt, rx162_tgt, rx162_off
  rx162_start:
    eq $I10, 1, rx162_restart
    if_null rx162_debug, debug_470
    rx162_cur."!cursor_debug"("START", "comp_unit")
  debug_470:
    $I10 = self.'from'()
    ne $I10, -1, rxscan166_done
    goto rxscan166_scan
  rxscan166_loop:
    (rx162_pos) = rx162_cur."from"()
    inc rx162_pos
    rx162_cur."!cursor_from"(rx162_pos)
    ge rx162_pos, rx162_eos, rxscan166_done
  rxscan166_scan:
    set_addr $I10, rxscan166_loop
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
  rxscan166_done:
.annotate 'line', 102
  # rx subrule "newpad" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."newpad"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
.annotate 'line', 103
  # rx subrule "outerctx" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."outerctx"()
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
.annotate 'line', 104
  # rx subrule "statementlist" subtype=capture negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."statementlist"()
    unless $P10, rx162_fail
    rx162_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx162_pos = $P10."pos"()
  alt167_0:
.annotate 'line', 105
    set_addr $I10, alt167_1
    rx162_cur."!mark_push"(0, rx162_pos, $I10)
  # rxanchor eos
    ne rx162_pos, rx162_eos, rx162_fail
    goto alt167_end
  alt167_1:
  # rx subrule "panic" subtype=method negate=
    rx162_cur."!cursor_pos"(rx162_pos)
    $P10 = rx162_cur."panic"("Confused")
    unless $P10, rx162_fail
    rx162_pos = $P10."pos"()
  alt167_end:
.annotate 'line', 101
  # rx pass
    rx162_cur."!cursor_pass"(rx162_pos, "comp_unit")
    if_null rx162_debug, debug_471
    rx162_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx162_pos)
  debug_471:
    .return (rx162_cur)
  rx162_restart:
.annotate 'line', 4
    if_null rx162_debug, debug_472
    rx162_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_472:
  rx162_fail:
    (rx162_rep, rx162_pos, $I10, $P10) = rx162_cur."!mark_fail"(0)
    lt rx162_pos, -1, rx162_done
    eq rx162_pos, -1, rx162_fail
    jump $I10
  rx162_done:
    rx162_cur."!cursor_fail"()
    if_null rx162_debug, debug_473
    rx162_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_473:
    .return (rx162_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1298839231.515") :method
.annotate 'line', 4
    $P164 = self."!PREFIX__!subrule"("newpad", "")
    new $P165, "ResizablePMCArray"
    push $P165, $P164
    .return ($P165)
.end


.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx169_tgt
    .local int rx169_pos
    .local int rx169_off
    .local int rx169_eos
    .local int rx169_rep
    .local pmc rx169_cur
    .local pmc rx169_debug
    (rx169_cur, rx169_pos, rx169_tgt, $I10) = self."!cursor_start"()
    rx169_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx169_cur
    .local pmc match
    .lex "$/", match
    length rx169_eos, rx169_tgt
    gt rx169_pos, rx169_eos, rx169_done
    set rx169_off, 0
    lt rx169_pos, 2, rx169_start
    sub rx169_off, rx169_pos, 1
    substr rx169_tgt, rx169_tgt, rx169_off
  rx169_start:
    eq $I10, 1, rx169_restart
    if_null rx169_debug, debug_474
    rx169_cur."!cursor_debug"("START", "statementlist")
  debug_474:
    $I10 = self.'from'()
    ne $I10, -1, rxscan174_done
    goto rxscan174_scan
  rxscan174_loop:
    (rx169_pos) = rx169_cur."from"()
    inc rx169_pos
    rx169_cur."!cursor_from"(rx169_pos)
    ge rx169_pos, rx169_eos, rxscan174_done
  rxscan174_scan:
    set_addr $I10, rxscan174_loop
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
  rxscan174_done:
  alt175_0:
.annotate 'line', 108
    set_addr $I10, alt175_1
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
.annotate 'line', 109
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rxanchor eos
    ne rx169_pos, rx169_eos, rx169_fail
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
    goto alt175_end
  alt175_1:
.annotate 'line', 110
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rx rxquantr179 ** 0..*
    set_addr $I10, rxquantr179_done
    rx169_cur."!mark_push"(0, rx169_pos, $I10)
  rxquantr179_loop:
  # rx subrule "statement" subtype=capture negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."statement"()
    unless $P10, rx169_fail
    rx169_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx169_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."eat_terminator"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
    set_addr $I10, rxquantr179_done
    (rx169_rep) = rx169_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr179_done
    rx169_cur."!mark_push"(rx169_rep, rx169_pos, $I10)
    goto rxquantr179_loop
  rxquantr179_done:
  # rx subrule "ws" subtype=method negate=
    rx169_cur."!cursor_pos"(rx169_pos)
    $P10 = rx169_cur."ws"()
    unless $P10, rx169_fail
    rx169_pos = $P10."pos"()
  alt175_end:
.annotate 'line', 108
  # rx pass
    rx169_cur."!cursor_pass"(rx169_pos, "statementlist")
    if_null rx169_debug, debug_475
    rx169_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx169_pos)
  debug_475:
    .return (rx169_cur)
  rx169_restart:
.annotate 'line', 4
    if_null rx169_debug, debug_476
    rx169_cur."!cursor_debug"("NEXT", "statementlist")
  debug_476:
  rx169_fail:
    (rx169_rep, rx169_pos, $I10, $P10) = rx169_cur."!mark_fail"(0)
    lt rx169_pos, -1, rx169_done
    eq rx169_pos, -1, rx169_fail
    jump $I10
  rx169_done:
    rx169_cur."!cursor_fail"()
    if_null rx169_debug, debug_477
    rx169_cur."!cursor_debug"("FAIL", "statementlist")
  debug_477:
    .return (rx169_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1298839231.515") :method
.annotate 'line', 4
    $P171 = self."!PREFIX__!subrule"("ws", "")
    $P172 = self."!PREFIX__!subrule"("ws", "")
    new $P173, "ResizablePMCArray"
    push $P173, $P171
    push $P173, $P172
    .return ($P173)
.end


.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P188 = "35_1298839231.515" 
    capture_lex $P188
    .local string rx183_tgt
    .local int rx183_pos
    .local int rx183_off
    .local int rx183_eos
    .local int rx183_rep
    .local pmc rx183_cur
    .local pmc rx183_debug
    (rx183_cur, rx183_pos, rx183_tgt, $I10) = self."!cursor_start"()
    rx183_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx183_cur
    .local pmc match
    .lex "$/", match
    length rx183_eos, rx183_tgt
    gt rx183_pos, rx183_eos, rx183_done
    set rx183_off, 0
    lt rx183_pos, 2, rx183_start
    sub rx183_off, rx183_pos, 1
    substr rx183_tgt, rx183_tgt, rx183_off
  rx183_start:
    eq $I10, 1, rx183_restart
    if_null rx183_debug, debug_478
    rx183_cur."!cursor_debug"("START", "statement")
  debug_478:
    $I10 = self.'from'()
    ne $I10, -1, rxscan186_done
    goto rxscan186_scan
  rxscan186_loop:
    (rx183_pos) = rx183_cur."from"()
    inc rx183_pos
    rx183_cur."!cursor_from"(rx183_pos)
    ge rx183_pos, rx183_eos, rxscan186_done
  rxscan186_scan:
    set_addr $I10, rxscan186_loop
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxscan186_done:
.annotate 'line', 114
  # rx subrule "before" subtype=zerowidth negate=1
    rx183_cur."!cursor_pos"(rx183_pos)
    .const 'Sub' $P188 = "35_1298839231.515" 
    capture_lex $P188
    $P10 = rx183_cur."before"($P188)
    if $P10, rx183_fail
  alt192_0:
.annotate 'line', 115
    set_addr $I10, alt192_1
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 116
  # rx subrule "statement_control" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_control"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx183_pos = $P10."pos"()
    goto alt192_end
  alt192_1:
.annotate 'line', 117
  # rx subrule "EXPR" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."EXPR"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx183_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."ws"()
    unless $P10, rx183_fail
    rx183_pos = $P10."pos"()
.annotate 'line', 122
  # rx rxquantr193 ** 0..1
    set_addr $I10, rxquantr193_done
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxquantr193_loop:
  alt194_0:
.annotate 'line', 118
    set_addr $I10, alt194_1
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 119
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."MARKED"("endstmt")
    unless $P10, rx183_fail
    goto alt194_end
  alt194_1:
    set_addr $I10, alt194_2
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
.annotate 'line', 120
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_cond"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx183_pos = $P10."pos"()
  # rx rxquantr195 ** 0..1
    set_addr $I10, rxquantr195_done
    rx183_cur."!mark_push"(0, rx183_pos, $I10)
  rxquantr195_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_loop"()
    unless $P10, rx183_fail
    goto rxsubrule196_pass
  rxsubrule196_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx183_fail
  rxsubrule196_pass:
    set_addr $I10, rxsubrule196_back
    rx183_cur."!mark_push"(0, rx183_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx183_pos = $P10."pos"()
    set_addr $I10, rxquantr195_done
    (rx183_rep) = rx183_cur."!mark_commit"($I10)
  rxquantr195_done:
    goto alt194_end
  alt194_2:
.annotate 'line', 121
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx183_cur."!cursor_pos"(rx183_pos)
    $P10 = rx183_cur."statement_mod_loop"()
    unless $P10, rx183_fail
    rx183_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx183_pos = $P10."pos"()
  alt194_end:
.annotate 'line', 122
    set_addr $I10, rxquantr193_done
    (rx183_rep) = rx183_cur."!mark_commit"($I10)
  rxquantr193_done:
  alt192_end:
.annotate 'line', 113
  # rx pass
    rx183_cur."!cursor_pass"(rx183_pos, "statement")
    if_null rx183_debug, debug_483
    rx183_cur."!cursor_debug"("PASS", "statement", " at pos=", rx183_pos)
  debug_483:
    .return (rx183_cur)
  rx183_restart:
.annotate 'line', 4
    if_null rx183_debug, debug_484
    rx183_cur."!cursor_debug"("NEXT", "statement")
  debug_484:
  rx183_fail:
    (rx183_rep, rx183_pos, $I10, $P10) = rx183_cur."!mark_fail"(0)
    lt rx183_pos, -1, rx183_done
    eq rx183_pos, -1, rx183_fail
    jump $I10
  rx183_done:
    rx183_cur."!cursor_fail"()
    if_null rx183_debug, debug_485
    rx183_cur."!cursor_debug"("FAIL", "statement")
  debug_485:
    .return (rx183_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1298839231.515") :method
.annotate 'line', 4
    new $P185, "ResizablePMCArray"
    push $P185, ""
    .return ($P185)
.end


.namespace ["NQP";"Grammar"]
.sub "_block187"  :anon :subid("35_1298839231.515") :method :outer("33_1298839231.515")
.annotate 'line', 114
    .local string rx189_tgt
    .local int rx189_pos
    .local int rx189_off
    .local int rx189_eos
    .local int rx189_rep
    .local pmc rx189_cur
    .local pmc rx189_debug
    (rx189_cur, rx189_pos, rx189_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx189_cur
    .local pmc match
    .lex "$/", match
    length rx189_eos, rx189_tgt
    gt rx189_pos, rx189_eos, rx189_done
    set rx189_off, 0
    lt rx189_pos, 2, rx189_start
    sub rx189_off, rx189_pos, 1
    substr rx189_tgt, rx189_tgt, rx189_off
  rx189_start:
    eq $I10, 1, rx189_restart
    if_null rx189_debug, debug_479
    rx189_cur."!cursor_debug"("START", "")
  debug_479:
    $I10 = self.'from'()
    ne $I10, -1, rxscan190_done
    goto rxscan190_scan
  rxscan190_loop:
    (rx189_pos) = rx189_cur."from"()
    inc rx189_pos
    rx189_cur."!cursor_from"(rx189_pos)
    ge rx189_pos, rx189_eos, rxscan190_done
  rxscan190_scan:
    set_addr $I10, rxscan190_loop
    rx189_cur."!mark_push"(0, rx189_pos, $I10)
  rxscan190_done:
  alt191_0:
    set_addr $I10, alt191_1
    rx189_cur."!mark_push"(0, rx189_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx189_pos, rx189_eos, rx189_fail
    sub $I10, rx189_pos, rx189_off
    substr $S10, rx189_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx189_fail
    inc rx189_pos
    goto alt191_end
  alt191_1:
  # rxanchor eos
    ne rx189_pos, rx189_eos, rx189_fail
  alt191_end:
  # rx pass
    rx189_cur."!cursor_pass"(rx189_pos, "")
    if_null rx189_debug, debug_480
    rx189_cur."!cursor_debug"("PASS", "", " at pos=", rx189_pos)
  debug_480:
    .return (rx189_cur)
  rx189_restart:
    if_null rx189_debug, debug_481
    rx189_cur."!cursor_debug"("NEXT", "")
  debug_481:
  rx189_fail:
    (rx189_rep, rx189_pos, $I10, $P10) = rx189_cur."!mark_fail"(0)
    lt rx189_pos, -1, rx189_done
    eq rx189_pos, -1, rx189_fail
    jump $I10
  rx189_done:
    rx189_cur."!cursor_fail"()
    if_null rx189_debug, debug_482
    rx189_cur."!cursor_debug"("FAIL", "")
  debug_482:
    .return (rx189_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx198_tgt
    .local int rx198_pos
    .local int rx198_off
    .local int rx198_eos
    .local int rx198_rep
    .local pmc rx198_cur
    .local pmc rx198_debug
    (rx198_cur, rx198_pos, rx198_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx198_cur
    .local pmc match
    .lex "$/", match
    length rx198_eos, rx198_tgt
    gt rx198_pos, rx198_eos, rx198_done
    set rx198_off, 0
    lt rx198_pos, 2, rx198_start
    sub rx198_off, rx198_pos, 1
    substr rx198_tgt, rx198_tgt, rx198_off
  rx198_start:
    eq $I10, 1, rx198_restart
    if_null rx198_debug, debug_486
    rx198_cur."!cursor_debug"("START", "eat_terminator")
  debug_486:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx198_pos) = rx198_cur."from"()
    inc rx198_pos
    rx198_cur."!cursor_from"(rx198_pos)
    ge rx198_pos, rx198_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
  rxscan201_done:
  alt202_0:
.annotate 'line', 126
    set_addr $I10, alt202_1
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 127
  # rx literal  ";"
    add $I11, rx198_pos, 1
    gt $I11, rx198_eos, rx198_fail
    sub $I11, rx198_pos, rx198_off
    ord $I11, rx198_tgt, $I11
    ne $I11, 59, rx198_fail
    add rx198_pos, 1
    goto alt202_end
  alt202_1:
    set_addr $I10, alt202_2
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 128
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx198_cur."!cursor_pos"(rx198_pos)
    $P10 = rx198_cur."MARKED"("endstmt")
    unless $P10, rx198_fail
    goto alt202_end
  alt202_2:
    set_addr $I10, alt202_3
    rx198_cur."!mark_push"(0, rx198_pos, $I10)
.annotate 'line', 129
  # rx subrule "terminator" subtype=zerowidth negate=
    rx198_cur."!cursor_pos"(rx198_pos)
    $P10 = rx198_cur."terminator"()
    unless $P10, rx198_fail
    goto alt202_end
  alt202_3:
.annotate 'line', 130
  # rxanchor eos
    ne rx198_pos, rx198_eos, rx198_fail
  alt202_end:
.annotate 'line', 126
  # rx pass
    rx198_cur."!cursor_pass"(rx198_pos, "eat_terminator")
    if_null rx198_debug, debug_487
    rx198_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx198_pos)
  debug_487:
    .return (rx198_cur)
  rx198_restart:
.annotate 'line', 4
    if_null rx198_debug, debug_488
    rx198_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_488:
  rx198_fail:
    (rx198_rep, rx198_pos, $I10, $P10) = rx198_cur."!mark_fail"(0)
    lt rx198_pos, -1, rx198_done
    eq rx198_pos, -1, rx198_fail
    jump $I10
  rx198_done:
    rx198_cur."!cursor_fail"()
    if_null rx198_debug, debug_489
    rx198_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_489:
    .return (rx198_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1298839231.515") :method
.annotate 'line', 4
    new $P200, "ResizablePMCArray"
    push $P200, ""
    push $P200, ""
    push $P200, ""
    push $P200, ";"
    .return ($P200)
.end


.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx204_tgt
    .local int rx204_pos
    .local int rx204_off
    .local int rx204_eos
    .local int rx204_rep
    .local pmc rx204_cur
    .local pmc rx204_debug
    (rx204_cur, rx204_pos, rx204_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx204_cur
    .local pmc match
    .lex "$/", match
    length rx204_eos, rx204_tgt
    gt rx204_pos, rx204_eos, rx204_done
    set rx204_off, 0
    lt rx204_pos, 2, rx204_start
    sub rx204_off, rx204_pos, 1
    substr rx204_tgt, rx204_tgt, rx204_off
  rx204_start:
    eq $I10, 1, rx204_restart
    if_null rx204_debug, debug_490
    rx204_cur."!cursor_debug"("START", "xblock")
  debug_490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan208_done
    goto rxscan208_scan
  rxscan208_loop:
    (rx204_pos) = rx204_cur."from"()
    inc rx204_pos
    rx204_cur."!cursor_from"(rx204_pos)
    ge rx204_pos, rx204_eos, rxscan208_done
  rxscan208_scan:
    set_addr $I10, rxscan208_loop
    rx204_cur."!mark_push"(0, rx204_pos, $I10)
  rxscan208_done:
.annotate 'line', 134
  # rx subrule "EXPR" subtype=capture negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."EXPR"()
    unless $P10, rx204_fail
    rx204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx204_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."ws"()
    unless $P10, rx204_fail
    rx204_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx204_cur."!cursor_pos"(rx204_pos)
    $P10 = rx204_cur."pblock"()
    unless $P10, rx204_fail
    rx204_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx204_pos = $P10."pos"()
.annotate 'line', 133
  # rx pass
    rx204_cur."!cursor_pass"(rx204_pos, "xblock")
    if_null rx204_debug, debug_491
    rx204_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx204_pos)
  debug_491:
    .return (rx204_cur)
  rx204_restart:
.annotate 'line', 4
    if_null rx204_debug, debug_492
    rx204_cur."!cursor_debug"("NEXT", "xblock")
  debug_492:
  rx204_fail:
    (rx204_rep, rx204_pos, $I10, $P10) = rx204_cur."!mark_fail"(0)
    lt rx204_pos, -1, rx204_done
    eq rx204_pos, -1, rx204_fail
    jump $I10
  rx204_done:
    rx204_cur."!cursor_fail"()
    if_null rx204_debug, debug_493
    rx204_cur."!cursor_debug"("FAIL", "xblock")
  debug_493:
    .return (rx204_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1298839231.515") :method
.annotate 'line', 4
    $P206 = self."!PREFIX__!subrule"("EXPR", "")
    new $P207, "ResizablePMCArray"
    push $P207, $P206
    .return ($P207)
.end


.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx210_tgt
    .local int rx210_pos
    .local int rx210_off
    .local int rx210_eos
    .local int rx210_rep
    .local pmc rx210_cur
    .local pmc rx210_debug
    (rx210_cur, rx210_pos, rx210_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx210_cur
    .local pmc match
    .lex "$/", match
    length rx210_eos, rx210_tgt
    gt rx210_pos, rx210_eos, rx210_done
    set rx210_off, 0
    lt rx210_pos, 2, rx210_start
    sub rx210_off, rx210_pos, 1
    substr rx210_tgt, rx210_tgt, rx210_off
  rx210_start:
    eq $I10, 1, rx210_restart
    if_null rx210_debug, debug_494
    rx210_cur."!cursor_debug"("START", "pblock")
  debug_494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan215_done
    goto rxscan215_scan
  rxscan215_loop:
    (rx210_pos) = rx210_cur."from"()
    inc rx210_pos
    rx210_cur."!cursor_from"(rx210_pos)
    ge rx210_pos, rx210_eos, rxscan215_done
  rxscan215_scan:
    set_addr $I10, rxscan215_loop
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxscan215_done:
  alt216_0:
.annotate 'line', 137
    set_addr $I10, alt216_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 138
  # rx subrule "lambda" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."lambda"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 139
  # rx subrule "newpad" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."newpad"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 140
  # rx subrule "signature" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."signature"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx210_pos = $P10."pos"()
.annotate 'line', 141
  # rx subrule "blockoid" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."blockoid"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx210_pos = $P10."pos"()
.annotate 'line', 138
    goto alt216_end
  alt216_1:
    set_addr $I10, alt216_2
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 142
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx210_pos, rx210_off
    substr $S10, rx210_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx210_fail
.annotate 'line', 143
  # rx subrule "newpad" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."newpad"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 144
  # rx subrule "blockoid" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."blockoid"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx210_pos = $P10."pos"()
.annotate 'line', 142
    goto alt216_end
  alt216_2:
.annotate 'line', 145
  # rx subrule "panic" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."panic"("Missing block")
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
  alt216_end:
.annotate 'line', 137
  # rx pass
    rx210_cur."!cursor_pass"(rx210_pos, "pblock")
    if_null rx210_debug, debug_495
    rx210_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx210_pos)
  debug_495:
    .return (rx210_cur)
  rx210_restart:
.annotate 'line', 4
    if_null rx210_debug, debug_496
    rx210_cur."!cursor_debug"("NEXT", "pblock")
  debug_496:
  rx210_fail:
    (rx210_rep, rx210_pos, $I10, $P10) = rx210_cur."!mark_fail"(0)
    lt rx210_pos, -1, rx210_done
    eq rx210_pos, -1, rx210_fail
    jump $I10
  rx210_done:
    rx210_cur."!cursor_fail"()
    if_null rx210_debug, debug_497
    rx210_cur."!cursor_debug"("FAIL", "pblock")
  debug_497:
    .return (rx210_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1298839231.515") :method
.annotate 'line', 4
    $P212 = self."!PREFIX__!subrule"("panic", "")
    $P213 = self."!PREFIX__!subrule"("lambda", "")
    new $P214, "ResizablePMCArray"
    push $P214, $P212
    push $P214, "{"
    push $P214, $P213
    .return ($P214)
.end


.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx218_tgt
    .local int rx218_pos
    .local int rx218_off
    .local int rx218_eos
    .local int rx218_rep
    .local pmc rx218_cur
    .local pmc rx218_debug
    (rx218_cur, rx218_pos, rx218_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx218_cur
    .local pmc match
    .lex "$/", match
    length rx218_eos, rx218_tgt
    gt rx218_pos, rx218_eos, rx218_done
    set rx218_off, 0
    lt rx218_pos, 2, rx218_start
    sub rx218_off, rx218_pos, 1
    substr rx218_tgt, rx218_tgt, rx218_off
  rx218_start:
    eq $I10, 1, rx218_restart
    if_null rx218_debug, debug_498
    rx218_cur."!cursor_debug"("START", "lambda")
  debug_498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan221_done
    goto rxscan221_scan
  rxscan221_loop:
    (rx218_pos) = rx218_cur."from"()
    inc rx218_pos
    rx218_cur."!cursor_from"(rx218_pos)
    ge rx218_pos, rx218_eos, rxscan221_done
  rxscan221_scan:
    set_addr $I10, rxscan221_loop
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  rxscan221_done:
  alt222_0:
.annotate 'line', 148
    set_addr $I10, alt222_1
    rx218_cur."!mark_push"(0, rx218_pos, $I10)
  # rx literal  "->"
    add $I11, rx218_pos, 2
    gt $I11, rx218_eos, rx218_fail
    sub $I11, rx218_pos, rx218_off
    substr $S10, rx218_tgt, $I11, 2
    ne $S10, "->", rx218_fail
    add rx218_pos, 2
    goto alt222_end
  alt222_1:
  # rx literal  "<->"
    add $I11, rx218_pos, 3
    gt $I11, rx218_eos, rx218_fail
    sub $I11, rx218_pos, rx218_off
    substr $S10, rx218_tgt, $I11, 3
    ne $S10, "<->", rx218_fail
    add rx218_pos, 3
  alt222_end:
  # rx pass
    rx218_cur."!cursor_pass"(rx218_pos, "lambda")
    if_null rx218_debug, debug_499
    rx218_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx218_pos)
  debug_499:
    .return (rx218_cur)
  rx218_restart:
.annotate 'line', 4
    if_null rx218_debug, debug_500
    rx218_cur."!cursor_debug"("NEXT", "lambda")
  debug_500:
  rx218_fail:
    (rx218_rep, rx218_pos, $I10, $P10) = rx218_cur."!mark_fail"(0)
    lt rx218_pos, -1, rx218_done
    eq rx218_pos, -1, rx218_fail
    jump $I10
  rx218_done:
    rx218_cur."!cursor_fail"()
    if_null rx218_debug, debug_501
    rx218_cur."!cursor_debug"("FAIL", "lambda")
  debug_501:
    .return (rx218_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1298839231.515") :method
.annotate 'line', 4
    new $P220, "ResizablePMCArray"
    push $P220, "<->"
    push $P220, "->"
    .return ($P220)
.end


.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx224_tgt
    .local int rx224_pos
    .local int rx224_off
    .local int rx224_eos
    .local int rx224_rep
    .local pmc rx224_cur
    .local pmc rx224_debug
    (rx224_cur, rx224_pos, rx224_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx224_cur
    .local pmc match
    .lex "$/", match
    length rx224_eos, rx224_tgt
    gt rx224_pos, rx224_eos, rx224_done
    set rx224_off, 0
    lt rx224_pos, 2, rx224_start
    sub rx224_off, rx224_pos, 1
    substr rx224_tgt, rx224_tgt, rx224_off
  rx224_start:
    eq $I10, 1, rx224_restart
    if_null rx224_debug, debug_502
    rx224_cur."!cursor_debug"("START", "block")
  debug_502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx224_pos) = rx224_cur."from"()
    inc rx224_pos
    rx224_cur."!cursor_from"(rx224_pos)
    ge rx224_pos, rx224_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 151
    set_addr $I10, alt229_1
    rx224_cur."!mark_push"(0, rx224_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx224_pos, rx224_off
    substr $S10, rx224_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx224_fail
    goto alt229_end
  alt229_1:
  # rx subrule "panic" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."panic"("Missing block")
    unless $P10, rx224_fail
    rx224_pos = $P10."pos"()
  alt229_end:
.annotate 'line', 152
  # rx subrule "newpad" subtype=method negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."newpad"()
    unless $P10, rx224_fail
    rx224_pos = $P10."pos"()
.annotate 'line', 153
  # rx subrule "blockoid" subtype=capture negate=
    rx224_cur."!cursor_pos"(rx224_pos)
    $P10 = rx224_cur."blockoid"()
    unless $P10, rx224_fail
    rx224_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx224_pos = $P10."pos"()
.annotate 'line', 150
  # rx pass
    rx224_cur."!cursor_pass"(rx224_pos, "block")
    if_null rx224_debug, debug_503
    rx224_cur."!cursor_debug"("PASS", "block", " at pos=", rx224_pos)
  debug_503:
    .return (rx224_cur)
  rx224_restart:
.annotate 'line', 4
    if_null rx224_debug, debug_504
    rx224_cur."!cursor_debug"("NEXT", "block")
  debug_504:
  rx224_fail:
    (rx224_rep, rx224_pos, $I10, $P10) = rx224_cur."!mark_fail"(0)
    lt rx224_pos, -1, rx224_done
    eq rx224_pos, -1, rx224_fail
    jump $I10
  rx224_done:
    rx224_cur."!cursor_fail"()
    if_null rx224_debug, debug_505
    rx224_cur."!cursor_debug"("FAIL", "block")
  debug_505:
    .return (rx224_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1298839231.515") :method
.annotate 'line', 4
    $P226 = self."!PREFIX__!subrule"("panic", "")
    new $P227, "ResizablePMCArray"
    push $P227, $P226
    push $P227, "{"
    .return ($P227)
.end


.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_506
    rx231_cur."!cursor_debug"("START", "blockoid")
  debug_506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan235_done:
.annotate 'line', 157
  # rx subrule "finishpad" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."finishpad"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
  alt236_0:
.annotate 'line', 158
    set_addr $I10, alt236_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
.annotate 'line', 159
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx231_pos, 14
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    substr $S10, rx231_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx231_fail
    add rx231_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."you_are_here"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx231_pos = $P10."pos"()
    goto alt236_end
  alt236_1:
.annotate 'line', 160
  # rx literal  "{"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 123, rx231_fail
    add rx231_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."statementlist"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx231_pos = $P10."pos"()
  alt237_0:
    set_addr $I10, alt237_1
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  # rx literal  "}"
    add $I11, rx231_pos, 1
    gt $I11, rx231_eos, rx231_fail
    sub $I11, rx231_pos, rx231_off
    ord $I11, rx231_tgt, $I11
    ne $I11, 125, rx231_fail
    add rx231_pos, 1
    goto alt237_end
  alt237_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."FAILGOAL"("'}'")
    unless $P10, rx231_fail
    goto rxsubrule239_pass
  rxsubrule239_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx231_fail
  rxsubrule239_pass:
    set_addr $I10, rxsubrule239_back
    rx231_cur."!mark_push"(0, rx231_pos, $I10, $P10)
    rx231_pos = $P10."pos"()
  alt237_end:
  alt236_end:
.annotate 'line', 162
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."ENDSTMT"()
    unless $P10, rx231_fail
.annotate 'line', 156
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "blockoid")
    if_null rx231_debug, debug_507
    rx231_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx231_pos)
  debug_507:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 4
    if_null rx231_debug, debug_508
    rx231_cur."!cursor_debug"("NEXT", "blockoid")
  debug_508:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_509
    rx231_cur."!cursor_debug"("FAIL", "blockoid")
  debug_509:
    .return (rx231_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1298839231.515") :method
.annotate 'line', 4
    $P233 = self."!PREFIX__!subrule"("finishpad", "")
    new $P234, "ResizablePMCArray"
    push $P234, $P233
    .return ($P234)
.end


.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx241_tgt
    .local int rx241_pos
    .local int rx241_off
    .local int rx241_eos
    .local int rx241_rep
    .local pmc rx241_cur
    .local pmc rx241_debug
    (rx241_cur, rx241_pos, rx241_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx241_cur
    .local pmc match
    .lex "$/", match
    length rx241_eos, rx241_tgt
    gt rx241_pos, rx241_eos, rx241_done
    set rx241_off, 0
    lt rx241_pos, 2, rx241_start
    sub rx241_off, rx241_pos, 1
    substr rx241_tgt, rx241_tgt, rx241_off
  rx241_start:
    eq $I10, 1, rx241_restart
    if_null rx241_debug, debug_510
    rx241_cur."!cursor_debug"("START", "newpad")
  debug_510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan244_done
    goto rxscan244_scan
  rxscan244_loop:
    (rx241_pos) = rx241_cur."from"()
    inc rx241_pos
    rx241_cur."!cursor_from"(rx241_pos)
    ge rx241_pos, rx241_eos, rxscan244_done
  rxscan244_scan:
    set_addr $I10, rxscan244_loop
    rx241_cur."!mark_push"(0, rx241_pos, $I10)
  rxscan244_done:
.annotate 'line', 165
  # rx pass
    rx241_cur."!cursor_pass"(rx241_pos, "newpad")
    if_null rx241_debug, debug_511
    rx241_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx241_pos)
  debug_511:
    .return (rx241_cur)
  rx241_restart:
.annotate 'line', 4
    if_null rx241_debug, debug_512
    rx241_cur."!cursor_debug"("NEXT", "newpad")
  debug_512:
  rx241_fail:
    (rx241_rep, rx241_pos, $I10, $P10) = rx241_cur."!mark_fail"(0)
    lt rx241_pos, -1, rx241_done
    eq rx241_pos, -1, rx241_fail
    jump $I10
  rx241_done:
    rx241_cur."!cursor_fail"()
    if_null rx241_debug, debug_513
    rx241_cur."!cursor_debug"("FAIL", "newpad")
  debug_513:
    .return (rx241_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1298839231.515") :method
.annotate 'line', 4
    new $P243, "ResizablePMCArray"
    push $P243, ""
    .return ($P243)
.end


.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx246_tgt
    .local int rx246_pos
    .local int rx246_off
    .local int rx246_eos
    .local int rx246_rep
    .local pmc rx246_cur
    .local pmc rx246_debug
    (rx246_cur, rx246_pos, rx246_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx246_cur
    .local pmc match
    .lex "$/", match
    length rx246_eos, rx246_tgt
    gt rx246_pos, rx246_eos, rx246_done
    set rx246_off, 0
    lt rx246_pos, 2, rx246_start
    sub rx246_off, rx246_pos, 1
    substr rx246_tgt, rx246_tgt, rx246_off
  rx246_start:
    eq $I10, 1, rx246_restart
    if_null rx246_debug, debug_514
    rx246_cur."!cursor_debug"("START", "outerctx")
  debug_514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan249_done
    goto rxscan249_scan
  rxscan249_loop:
    (rx246_pos) = rx246_cur."from"()
    inc rx246_pos
    rx246_cur."!cursor_from"(rx246_pos)
    ge rx246_pos, rx246_eos, rxscan249_done
  rxscan249_scan:
    set_addr $I10, rxscan249_loop
    rx246_cur."!mark_push"(0, rx246_pos, $I10)
  rxscan249_done:
.annotate 'line', 166
  # rx pass
    rx246_cur."!cursor_pass"(rx246_pos, "outerctx")
    if_null rx246_debug, debug_515
    rx246_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx246_pos)
  debug_515:
    .return (rx246_cur)
  rx246_restart:
.annotate 'line', 4
    if_null rx246_debug, debug_516
    rx246_cur."!cursor_debug"("NEXT", "outerctx")
  debug_516:
  rx246_fail:
    (rx246_rep, rx246_pos, $I10, $P10) = rx246_cur."!mark_fail"(0)
    lt rx246_pos, -1, rx246_done
    eq rx246_pos, -1, rx246_fail
    jump $I10
  rx246_done:
    rx246_cur."!cursor_fail"()
    if_null rx246_debug, debug_517
    rx246_cur."!cursor_debug"("FAIL", "outerctx")
  debug_517:
    .return (rx246_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1298839231.515") :method
.annotate 'line', 4
    new $P248, "ResizablePMCArray"
    push $P248, ""
    .return ($P248)
.end


.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx251_tgt
    .local int rx251_pos
    .local int rx251_off
    .local int rx251_eos
    .local int rx251_rep
    .local pmc rx251_cur
    .local pmc rx251_debug
    (rx251_cur, rx251_pos, rx251_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx251_cur
    .local pmc match
    .lex "$/", match
    length rx251_eos, rx251_tgt
    gt rx251_pos, rx251_eos, rx251_done
    set rx251_off, 0
    lt rx251_pos, 2, rx251_start
    sub rx251_off, rx251_pos, 1
    substr rx251_tgt, rx251_tgt, rx251_off
  rx251_start:
    eq $I10, 1, rx251_restart
    if_null rx251_debug, debug_518
    rx251_cur."!cursor_debug"("START", "finishpad")
  debug_518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan254_done
    goto rxscan254_scan
  rxscan254_loop:
    (rx251_pos) = rx251_cur."from"()
    inc rx251_pos
    rx251_cur."!cursor_from"(rx251_pos)
    ge rx251_pos, rx251_eos, rxscan254_done
  rxscan254_scan:
    set_addr $I10, rxscan254_loop
    rx251_cur."!mark_push"(0, rx251_pos, $I10)
  rxscan254_done:
.annotate 'line', 167
  # rx pass
    rx251_cur."!cursor_pass"(rx251_pos, "finishpad")
    if_null rx251_debug, debug_519
    rx251_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx251_pos)
  debug_519:
    .return (rx251_cur)
  rx251_restart:
.annotate 'line', 4
    if_null rx251_debug, debug_520
    rx251_cur."!cursor_debug"("NEXT", "finishpad")
  debug_520:
  rx251_fail:
    (rx251_rep, rx251_pos, $I10, $P10) = rx251_cur."!mark_fail"(0)
    lt rx251_pos, -1, rx251_done
    eq rx251_pos, -1, rx251_fail
    jump $I10
  rx251_done:
    rx251_cur."!cursor_fail"()
    if_null rx251_debug, debug_521
    rx251_cur."!cursor_debug"("FAIL", "finishpad")
  debug_521:
    .return (rx251_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1298839231.515") :method
.annotate 'line', 4
    new $P253, "ResizablePMCArray"
    push $P253, ""
    .return ($P253)
.end


.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("54_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx256_tgt
    .local int rx256_pos
    .local int rx256_off
    .local int rx256_eos
    .local int rx256_rep
    .local pmc rx256_cur
    .local pmc rx256_debug
    (rx256_cur, rx256_pos, rx256_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx256_cur
    .local pmc match
    .lex "$/", match
    length rx256_eos, rx256_tgt
    gt rx256_pos, rx256_eos, rx256_done
    set rx256_off, 0
    lt rx256_pos, 2, rx256_start
    sub rx256_off, rx256_pos, 1
    substr rx256_tgt, rx256_tgt, rx256_off
  rx256_start:
    eq $I10, 1, rx256_restart
    if_null rx256_debug, debug_522
    rx256_cur."!cursor_debug"("START", "you_are_here")
  debug_522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan259_done
    goto rxscan259_scan
  rxscan259_loop:
    (rx256_pos) = rx256_cur."from"()
    inc rx256_pos
    rx256_cur."!cursor_from"(rx256_pos)
    ge rx256_pos, rx256_eos, rxscan259_done
  rxscan259_scan:
    set_addr $I10, rxscan259_loop
    rx256_cur."!mark_push"(0, rx256_pos, $I10)
  rxscan259_done:
.annotate 'line', 168
  # rx pass
    rx256_cur."!cursor_pass"(rx256_pos, "you_are_here")
    if_null rx256_debug, debug_523
    rx256_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx256_pos)
  debug_523:
    .return (rx256_cur)
  rx256_restart:
.annotate 'line', 4
    if_null rx256_debug, debug_524
    rx256_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_524:
  rx256_fail:
    (rx256_rep, rx256_pos, $I10, $P10) = rx256_cur."!mark_fail"(0)
    lt rx256_pos, -1, rx256_done
    eq rx256_pos, -1, rx256_fail
    jump $I10
  rx256_done:
    rx256_cur."!cursor_fail"()
    if_null rx256_debug, debug_525
    rx256_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_525:
    .return (rx256_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("55_1298839231.515") :method
.annotate 'line', 4
    new $P258, "ResizablePMCArray"
    push $P258, ""
    .return ($P258)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("56_1298839231.515")
    .param pmc param_261
.annotate 'line', 170
    .lex "self", param_261
    $P262 = param_261."!protoregex"("terminator")
    .return ($P262)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("57_1298839231.515")
    .param pmc param_264
.annotate 'line', 170
    .lex "self", param_264
    $P265 = param_264."!PREFIX__!protoregex"("terminator")
    .return ($P265)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("58_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx267_tgt
    .local int rx267_pos
    .local int rx267_off
    .local int rx267_eos
    .local int rx267_rep
    .local pmc rx267_cur
    .local pmc rx267_debug
    (rx267_cur, rx267_pos, rx267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx267_cur
    .local pmc match
    .lex "$/", match
    length rx267_eos, rx267_tgt
    gt rx267_pos, rx267_eos, rx267_done
    set rx267_off, 0
    lt rx267_pos, 2, rx267_start
    sub rx267_off, rx267_pos, 1
    substr rx267_tgt, rx267_tgt, rx267_off
  rx267_start:
    eq $I10, 1, rx267_restart
    if_null rx267_debug, debug_526
    rx267_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan270_done
    goto rxscan270_scan
  rxscan270_loop:
    (rx267_pos) = rx267_cur."from"()
    inc rx267_pos
    rx267_cur."!cursor_from"(rx267_pos)
    ge rx267_pos, rx267_eos, rxscan270_done
  rxscan270_scan:
    set_addr $I10, rxscan270_loop
    rx267_cur."!mark_push"(0, rx267_pos, $I10)
  rxscan270_done:
.annotate 'line', 172
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx267_pos, rx267_off
    substr $S10, rx267_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx267_fail
  # rx pass
    rx267_cur."!cursor_pass"(rx267_pos, "terminator:sym<;>")
    if_null rx267_debug, debug_527
    rx267_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx267_pos)
  debug_527:
    .return (rx267_cur)
  rx267_restart:
.annotate 'line', 4
    if_null rx267_debug, debug_528
    rx267_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_528:
  rx267_fail:
    (rx267_rep, rx267_pos, $I10, $P10) = rx267_cur."!mark_fail"(0)
    lt rx267_pos, -1, rx267_done
    eq rx267_pos, -1, rx267_fail
    jump $I10
  rx267_done:
    rx267_cur."!cursor_fail"()
    if_null rx267_debug, debug_529
    rx267_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_529:
    .return (rx267_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("59_1298839231.515") :method
.annotate 'line', 4
    new $P269, "ResizablePMCArray"
    push $P269, ";"
    .return ($P269)
.end


.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("60_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx272_tgt
    .local int rx272_pos
    .local int rx272_off
    .local int rx272_eos
    .local int rx272_rep
    .local pmc rx272_cur
    .local pmc rx272_debug
    (rx272_cur, rx272_pos, rx272_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx272_cur
    .local pmc match
    .lex "$/", match
    length rx272_eos, rx272_tgt
    gt rx272_pos, rx272_eos, rx272_done
    set rx272_off, 0
    lt rx272_pos, 2, rx272_start
    sub rx272_off, rx272_pos, 1
    substr rx272_tgt, rx272_tgt, rx272_off
  rx272_start:
    eq $I10, 1, rx272_restart
    if_null rx272_debug, debug_530
    rx272_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_530:
    $I10 = self.'from'()
    ne $I10, -1, rxscan275_done
    goto rxscan275_scan
  rxscan275_loop:
    (rx272_pos) = rx272_cur."from"()
    inc rx272_pos
    rx272_cur."!cursor_from"(rx272_pos)
    ge rx272_pos, rx272_eos, rxscan275_done
  rxscan275_scan:
    set_addr $I10, rxscan275_loop
    rx272_cur."!mark_push"(0, rx272_pos, $I10)
  rxscan275_done:
.annotate 'line', 173
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx272_pos, rx272_off
    substr $S10, rx272_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx272_fail
  # rx pass
    rx272_cur."!cursor_pass"(rx272_pos, "terminator:sym<}>")
    if_null rx272_debug, debug_531
    rx272_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx272_pos)
  debug_531:
    .return (rx272_cur)
  rx272_restart:
.annotate 'line', 4
    if_null rx272_debug, debug_532
    rx272_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_532:
  rx272_fail:
    (rx272_rep, rx272_pos, $I10, $P10) = rx272_cur."!mark_fail"(0)
    lt rx272_pos, -1, rx272_done
    eq rx272_pos, -1, rx272_fail
    jump $I10
  rx272_done:
    rx272_cur."!cursor_fail"()
    if_null rx272_debug, debug_533
    rx272_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_533:
    .return (rx272_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("61_1298839231.515") :method
.annotate 'line', 4
    new $P274, "ResizablePMCArray"
    push $P274, "}"
    .return ($P274)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("62_1298839231.515")
    .param pmc param_277
.annotate 'line', 177
    .lex "self", param_277
    $P278 = param_277."!protoregex"("statement_control")
    .return ($P278)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("63_1298839231.515")
    .param pmc param_280
.annotate 'line', 177
    .lex "self", param_280
    $P281 = param_280."!PREFIX__!protoregex"("statement_control")
    .return ($P281)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("64_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx283_tgt
    .local int rx283_pos
    .local int rx283_off
    .local int rx283_eos
    .local int rx283_rep
    .local pmc rx283_cur
    .local pmc rx283_debug
    (rx283_cur, rx283_pos, rx283_tgt, $I10) = self."!cursor_start"()
    rx283_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx283_cur
    .local pmc match
    .lex "$/", match
    length rx283_eos, rx283_tgt
    gt rx283_pos, rx283_eos, rx283_done
    set rx283_off, 0
    lt rx283_pos, 2, rx283_start
    sub rx283_off, rx283_pos, 1
    substr rx283_tgt, rx283_tgt, rx283_off
  rx283_start:
    eq $I10, 1, rx283_restart
    if_null rx283_debug, debug_534
    rx283_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_534:
    $I10 = self.'from'()
    ne $I10, -1, rxscan286_done
    goto rxscan286_scan
  rxscan286_loop:
    (rx283_pos) = rx283_cur."from"()
    inc rx283_pos
    rx283_cur."!cursor_from"(rx283_pos)
    ge rx283_pos, rx283_eos, rxscan286_done
  rxscan286_scan:
    set_addr $I10, rxscan286_loop
    rx283_cur."!mark_push"(0, rx283_pos, $I10)
  rxscan286_done:
.annotate 'line', 180
  # rx subcapture "sym"
    set_addr $I10, rxcap_287_fail
    rx283_cur."!mark_push"(0, rx283_pos, $I10)
  # rx literal  "if"
    add $I11, rx283_pos, 2
    gt $I11, rx283_eos, rx283_fail
    sub $I11, rx283_pos, rx283_off
    substr $S10, rx283_tgt, $I11, 2
    ne $S10, "if", rx283_fail
    add rx283_pos, 2
    set_addr $I10, rxcap_287_fail
    ($I12, $I11) = rx283_cur."!mark_peek"($I10)
    rx283_cur."!cursor_pos"($I11)
    ($P10) = rx283_cur."!cursor_start"()
    $P10."!cursor_pass"(rx283_pos, "")
    rx283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_287_done
  rxcap_287_fail:
    goto rx283_fail
  rxcap_287_done:
  # rx charclass s
    ge rx283_pos, rx283_eos, rx283_fail
    sub $I10, rx283_pos, rx283_off
    is_cclass $I11, 32, rx283_tgt, $I10
    unless $I11, rx283_fail
    inc rx283_pos
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
.annotate 'line', 181
  # rx subrule "xblock" subtype=capture negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."xblock"()
    unless $P10, rx283_fail
    rx283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
.annotate 'line', 182
  # rx rxquantr290 ** 0..*
    set_addr $I10, rxquantr290_done
    rx283_cur."!mark_push"(0, rx283_pos, $I10)
  rxquantr290_loop:
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx283_pos, 5
    gt $I11, rx283_eos, rx283_fail
    sub $I11, rx283_pos, rx283_off
    substr $S10, rx283_tgt, $I11, 5
    ne $S10, "elsif", rx283_fail
    add rx283_pos, 5
  # rx charclass s
    ge rx283_pos, rx283_eos, rx283_fail
    sub $I10, rx283_pos, rx283_off
    is_cclass $I11, 32, rx283_tgt, $I10
    unless $I11, rx283_fail
    inc rx283_pos
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."xblock"()
    unless $P10, rx283_fail
    rx283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
    set_addr $I10, rxquantr290_done
    (rx283_rep) = rx283_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr290_done
    rx283_cur."!mark_push"(rx283_rep, rx283_pos, $I10)
    goto rxquantr290_loop
  rxquantr290_done:
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
.annotate 'line', 183
  # rx rxquantr295 ** 0..1
    set_addr $I10, rxquantr295_done
    rx283_cur."!mark_push"(0, rx283_pos, $I10)
  rxquantr295_loop:
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx283_pos, 4
    gt $I11, rx283_eos, rx283_fail
    sub $I11, rx283_pos, rx283_off
    substr $S10, rx283_tgt, $I11, 4
    ne $S10, "else", rx283_fail
    add rx283_pos, 4
  # rx charclass s
    ge rx283_pos, rx283_eos, rx283_fail
    sub $I10, rx283_pos, rx283_off
    is_cclass $I11, 32, rx283_tgt, $I10
    unless $I11, rx283_fail
    inc rx283_pos
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."pblock"()
    unless $P10, rx283_fail
    rx283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
    set_addr $I10, rxquantr295_done
    (rx283_rep) = rx283_cur."!mark_commit"($I10)
  rxquantr295_done:
  # rx subrule "ws" subtype=method negate=
    rx283_cur."!cursor_pos"(rx283_pos)
    $P10 = rx283_cur."ws"()
    unless $P10, rx283_fail
    rx283_pos = $P10."pos"()
.annotate 'line', 179
  # rx pass
    rx283_cur."!cursor_pass"(rx283_pos, "statement_control:sym<if>")
    if_null rx283_debug, debug_535
    rx283_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx283_pos)
  debug_535:
    .return (rx283_cur)
  rx283_restart:
.annotate 'line', 4
    if_null rx283_debug, debug_536
    rx283_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_536:
  rx283_fail:
    (rx283_rep, rx283_pos, $I10, $P10) = rx283_cur."!mark_fail"(0)
    lt rx283_pos, -1, rx283_done
    eq rx283_pos, -1, rx283_fail
    jump $I10
  rx283_done:
    rx283_cur."!cursor_fail"()
    if_null rx283_debug, debug_537
    rx283_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_537:
    .return (rx283_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("65_1298839231.515") :method
.annotate 'line', 4
    new $P285, "ResizablePMCArray"
    push $P285, "if"
    .return ($P285)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("66_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P311 = "68_1298839231.515" 
    capture_lex $P311
    .local string rx301_tgt
    .local int rx301_pos
    .local int rx301_off
    .local int rx301_eos
    .local int rx301_rep
    .local pmc rx301_cur
    .local pmc rx301_debug
    (rx301_cur, rx301_pos, rx301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx301_cur
    .local pmc match
    .lex "$/", match
    length rx301_eos, rx301_tgt
    gt rx301_pos, rx301_eos, rx301_done
    set rx301_off, 0
    lt rx301_pos, 2, rx301_start
    sub rx301_off, rx301_pos, 1
    substr rx301_tgt, rx301_tgt, rx301_off
  rx301_start:
    eq $I10, 1, rx301_restart
    if_null rx301_debug, debug_538
    rx301_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan304_done
    goto rxscan304_scan
  rxscan304_loop:
    (rx301_pos) = rx301_cur."from"()
    inc rx301_pos
    rx301_cur."!cursor_from"(rx301_pos)
    ge rx301_pos, rx301_eos, rxscan304_done
  rxscan304_scan:
    set_addr $I10, rxscan304_loop
    rx301_cur."!mark_push"(0, rx301_pos, $I10)
  rxscan304_done:
.annotate 'line', 187
  # rx subcapture "sym"
    set_addr $I10, rxcap_305_fail
    rx301_cur."!mark_push"(0, rx301_pos, $I10)
  # rx literal  "unless"
    add $I11, rx301_pos, 6
    gt $I11, rx301_eos, rx301_fail
    sub $I11, rx301_pos, rx301_off
    substr $S10, rx301_tgt, $I11, 6
    ne $S10, "unless", rx301_fail
    add rx301_pos, 6
    set_addr $I10, rxcap_305_fail
    ($I12, $I11) = rx301_cur."!mark_peek"($I10)
    rx301_cur."!cursor_pos"($I11)
    ($P10) = rx301_cur."!cursor_start"()
    $P10."!cursor_pass"(rx301_pos, "")
    rx301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_305_done
  rxcap_305_fail:
    goto rx301_fail
  rxcap_305_done:
  # rx charclass s
    ge rx301_pos, rx301_eos, rx301_fail
    sub $I10, rx301_pos, rx301_off
    is_cclass $I11, 32, rx301_tgt, $I10
    unless $I11, rx301_fail
    inc rx301_pos
  # rx subrule "ws" subtype=method negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."ws"()
    unless $P10, rx301_fail
    rx301_pos = $P10."pos"()
.annotate 'line', 188
  # rx subrule "xblock" subtype=capture negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."xblock"()
    unless $P10, rx301_fail
    rx301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx301_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."ws"()
    unless $P10, rx301_fail
    rx301_pos = $P10."pos"()
  alt308_0:
.annotate 'line', 189
    set_addr $I10, alt308_1
    rx301_cur."!mark_push"(0, rx301_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."ws"()
    unless $P10, rx301_fail
    rx301_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx301_cur."!cursor_pos"(rx301_pos)
    .const 'Sub' $P311 = "68_1298839231.515" 
    capture_lex $P311
    $P10 = rx301_cur."before"($P311)
    if $P10, rx301_fail
  # rx subrule "ws" subtype=method negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."ws"()
    unless $P10, rx301_fail
    rx301_pos = $P10."pos"()
    goto alt308_end
  alt308_1:
  # rx subrule "ws" subtype=method negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."ws"()
    unless $P10, rx301_fail
    rx301_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx301_fail
    rx301_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."ws"()
    unless $P10, rx301_fail
    rx301_pos = $P10."pos"()
  alt308_end:
  # rx subrule "ws" subtype=method negate=
    rx301_cur."!cursor_pos"(rx301_pos)
    $P10 = rx301_cur."ws"()
    unless $P10, rx301_fail
    rx301_pos = $P10."pos"()
.annotate 'line', 186
  # rx pass
    rx301_cur."!cursor_pass"(rx301_pos, "statement_control:sym<unless>")
    if_null rx301_debug, debug_543
    rx301_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx301_pos)
  debug_543:
    .return (rx301_cur)
  rx301_restart:
.annotate 'line', 4
    if_null rx301_debug, debug_544
    rx301_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_544:
  rx301_fail:
    (rx301_rep, rx301_pos, $I10, $P10) = rx301_cur."!mark_fail"(0)
    lt rx301_pos, -1, rx301_done
    eq rx301_pos, -1, rx301_fail
    jump $I10
  rx301_done:
    rx301_cur."!cursor_fail"()
    if_null rx301_debug, debug_545
    rx301_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_545:
    .return (rx301_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("67_1298839231.515") :method
.annotate 'line', 4
    new $P303, "ResizablePMCArray"
    push $P303, "unless"
    .return ($P303)
.end


.namespace ["NQP";"Grammar"]
.sub "_block310"  :anon :subid("68_1298839231.515") :method :outer("66_1298839231.515")
.annotate 'line', 189
    .local string rx312_tgt
    .local int rx312_pos
    .local int rx312_off
    .local int rx312_eos
    .local int rx312_rep
    .local pmc rx312_cur
    .local pmc rx312_debug
    (rx312_cur, rx312_pos, rx312_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx312_cur
    .local pmc match
    .lex "$/", match
    length rx312_eos, rx312_tgt
    gt rx312_pos, rx312_eos, rx312_done
    set rx312_off, 0
    lt rx312_pos, 2, rx312_start
    sub rx312_off, rx312_pos, 1
    substr rx312_tgt, rx312_tgt, rx312_off
  rx312_start:
    eq $I10, 1, rx312_restart
    if_null rx312_debug, debug_539
    rx312_cur."!cursor_debug"("START", "")
  debug_539:
    $I10 = self.'from'()
    ne $I10, -1, rxscan313_done
    goto rxscan313_scan
  rxscan313_loop:
    (rx312_pos) = rx312_cur."from"()
    inc rx312_pos
    rx312_cur."!cursor_from"(rx312_pos)
    ge rx312_pos, rx312_eos, rxscan313_done
  rxscan313_scan:
    set_addr $I10, rxscan313_loop
    rx312_cur."!mark_push"(0, rx312_pos, $I10)
  rxscan313_done:
  # rx literal  "else"
    add $I11, rx312_pos, 4
    gt $I11, rx312_eos, rx312_fail
    sub $I11, rx312_pos, rx312_off
    substr $S10, rx312_tgt, $I11, 4
    ne $S10, "else", rx312_fail
    add rx312_pos, 4
  # rx pass
    rx312_cur."!cursor_pass"(rx312_pos, "")
    if_null rx312_debug, debug_540
    rx312_cur."!cursor_debug"("PASS", "", " at pos=", rx312_pos)
  debug_540:
    .return (rx312_cur)
  rx312_restart:
    if_null rx312_debug, debug_541
    rx312_cur."!cursor_debug"("NEXT", "")
  debug_541:
  rx312_fail:
    (rx312_rep, rx312_pos, $I10, $P10) = rx312_cur."!mark_fail"(0)
    lt rx312_pos, -1, rx312_done
    eq rx312_pos, -1, rx312_fail
    jump $I10
  rx312_done:
    rx312_cur."!cursor_fail"()
    if_null rx312_debug, debug_542
    rx312_cur."!cursor_debug"("FAIL", "")
  debug_542:
    .return (rx312_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("69_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx319_tgt
    .local int rx319_pos
    .local int rx319_off
    .local int rx319_eos
    .local int rx319_rep
    .local pmc rx319_cur
    .local pmc rx319_debug
    (rx319_cur, rx319_pos, rx319_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx319_cur
    .local pmc match
    .lex "$/", match
    length rx319_eos, rx319_tgt
    gt rx319_pos, rx319_eos, rx319_done
    set rx319_off, 0
    lt rx319_pos, 2, rx319_start
    sub rx319_off, rx319_pos, 1
    substr rx319_tgt, rx319_tgt, rx319_off
  rx319_start:
    eq $I10, 1, rx319_restart
    if_null rx319_debug, debug_546
    rx319_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan322_done
    goto rxscan322_scan
  rxscan322_loop:
    (rx319_pos) = rx319_cur."from"()
    inc rx319_pos
    rx319_cur."!cursor_from"(rx319_pos)
    ge rx319_pos, rx319_eos, rxscan322_done
  rxscan322_scan:
    set_addr $I10, rxscan322_loop
    rx319_cur."!mark_push"(0, rx319_pos, $I10)
  rxscan322_done:
.annotate 'line', 193
  # rx subcapture "sym"
    set_addr $I10, rxcap_324_fail
    rx319_cur."!mark_push"(0, rx319_pos, $I10)
  alt323_0:
    set_addr $I10, alt323_1
    rx319_cur."!mark_push"(0, rx319_pos, $I10)
  # rx literal  "while"
    add $I11, rx319_pos, 5
    gt $I11, rx319_eos, rx319_fail
    sub $I11, rx319_pos, rx319_off
    substr $S10, rx319_tgt, $I11, 5
    ne $S10, "while", rx319_fail
    add rx319_pos, 5
    goto alt323_end
  alt323_1:
  # rx literal  "until"
    add $I11, rx319_pos, 5
    gt $I11, rx319_eos, rx319_fail
    sub $I11, rx319_pos, rx319_off
    substr $S10, rx319_tgt, $I11, 5
    ne $S10, "until", rx319_fail
    add rx319_pos, 5
  alt323_end:
    set_addr $I10, rxcap_324_fail
    ($I12, $I11) = rx319_cur."!mark_peek"($I10)
    rx319_cur."!cursor_pos"($I11)
    ($P10) = rx319_cur."!cursor_start"()
    $P10."!cursor_pass"(rx319_pos, "")
    rx319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_324_done
  rxcap_324_fail:
    goto rx319_fail
  rxcap_324_done:
  # rx charclass s
    ge rx319_pos, rx319_eos, rx319_fail
    sub $I10, rx319_pos, rx319_off
    is_cclass $I11, 32, rx319_tgt, $I10
    unless $I11, rx319_fail
    inc rx319_pos
  # rx subrule "ws" subtype=method negate=
    rx319_cur."!cursor_pos"(rx319_pos)
    $P10 = rx319_cur."ws"()
    unless $P10, rx319_fail
    rx319_pos = $P10."pos"()
.annotate 'line', 194
  # rx subrule "xblock" subtype=capture negate=
    rx319_cur."!cursor_pos"(rx319_pos)
    $P10 = rx319_cur."xblock"()
    unless $P10, rx319_fail
    rx319_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx319_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx319_cur."!cursor_pos"(rx319_pos)
    $P10 = rx319_cur."ws"()
    unless $P10, rx319_fail
    rx319_pos = $P10."pos"()
.annotate 'line', 192
  # rx pass
    rx319_cur."!cursor_pass"(rx319_pos, "statement_control:sym<while>")
    if_null rx319_debug, debug_547
    rx319_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx319_pos)
  debug_547:
    .return (rx319_cur)
  rx319_restart:
.annotate 'line', 4
    if_null rx319_debug, debug_548
    rx319_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_548:
  rx319_fail:
    (rx319_rep, rx319_pos, $I10, $P10) = rx319_cur."!mark_fail"(0)
    lt rx319_pos, -1, rx319_done
    eq rx319_pos, -1, rx319_fail
    jump $I10
  rx319_done:
    rx319_cur."!cursor_fail"()
    if_null rx319_debug, debug_549
    rx319_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_549:
    .return (rx319_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("70_1298839231.515") :method
.annotate 'line', 4
    new $P321, "ResizablePMCArray"
    push $P321, "until"
    push $P321, "while"
    .return ($P321)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("71_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx328_tgt
    .local int rx328_pos
    .local int rx328_off
    .local int rx328_eos
    .local int rx328_rep
    .local pmc rx328_cur
    .local pmc rx328_debug
    (rx328_cur, rx328_pos, rx328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx328_cur
    .local pmc match
    .lex "$/", match
    length rx328_eos, rx328_tgt
    gt rx328_pos, rx328_eos, rx328_done
    set rx328_off, 0
    lt rx328_pos, 2, rx328_start
    sub rx328_off, rx328_pos, 1
    substr rx328_tgt, rx328_tgt, rx328_off
  rx328_start:
    eq $I10, 1, rx328_restart
    if_null rx328_debug, debug_550
    rx328_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_550:
    $I10 = self.'from'()
    ne $I10, -1, rxscan331_done
    goto rxscan331_scan
  rxscan331_loop:
    (rx328_pos) = rx328_cur."from"()
    inc rx328_pos
    rx328_cur."!cursor_from"(rx328_pos)
    ge rx328_pos, rx328_eos, rxscan331_done
  rxscan331_scan:
    set_addr $I10, rxscan331_loop
    rx328_cur."!mark_push"(0, rx328_pos, $I10)
  rxscan331_done:
.annotate 'line', 198
  # rx subcapture "sym"
    set_addr $I10, rxcap_332_fail
    rx328_cur."!mark_push"(0, rx328_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx328_pos, 6
    gt $I11, rx328_eos, rx328_fail
    sub $I11, rx328_pos, rx328_off
    substr $S10, rx328_tgt, $I11, 6
    ne $S10, "repeat", rx328_fail
    add rx328_pos, 6
    set_addr $I10, rxcap_332_fail
    ($I12, $I11) = rx328_cur."!mark_peek"($I10)
    rx328_cur."!cursor_pos"($I11)
    ($P10) = rx328_cur."!cursor_start"()
    $P10."!cursor_pass"(rx328_pos, "")
    rx328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_332_done
  rxcap_332_fail:
    goto rx328_fail
  rxcap_332_done:
  # rx charclass s
    ge rx328_pos, rx328_eos, rx328_fail
    sub $I10, rx328_pos, rx328_off
    is_cclass $I11, 32, rx328_tgt, $I10
    unless $I11, rx328_fail
    inc rx328_pos
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
  alt334_0:
.annotate 'line', 199
    set_addr $I10, alt334_1
    rx328_cur."!mark_push"(0, rx328_pos, $I10)
.annotate 'line', 200
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_337_fail
    rx328_cur."!mark_push"(0, rx328_pos, $I10)
  alt336_0:
    set_addr $I10, alt336_1
    rx328_cur."!mark_push"(0, rx328_pos, $I10)
  # rx literal  "while"
    add $I11, rx328_pos, 5
    gt $I11, rx328_eos, rx328_fail
    sub $I11, rx328_pos, rx328_off
    substr $S10, rx328_tgt, $I11, 5
    ne $S10, "while", rx328_fail
    add rx328_pos, 5
    goto alt336_end
  alt336_1:
  # rx literal  "until"
    add $I11, rx328_pos, 5
    gt $I11, rx328_eos, rx328_fail
    sub $I11, rx328_pos, rx328_off
    substr $S10, rx328_tgt, $I11, 5
    ne $S10, "until", rx328_fail
    add rx328_pos, 5
  alt336_end:
    set_addr $I10, rxcap_337_fail
    ($I12, $I11) = rx328_cur."!mark_peek"($I10)
    rx328_cur."!cursor_pos"($I11)
    ($P10) = rx328_cur."!cursor_start"()
    $P10."!cursor_pass"(rx328_pos, "")
    rx328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_337_done
  rxcap_337_fail:
    goto rx328_fail
  rxcap_337_done:
  # rx charclass s
    ge rx328_pos, rx328_eos, rx328_fail
    sub $I10, rx328_pos, rx328_off
    is_cclass $I11, 32, rx328_tgt, $I10
    unless $I11, rx328_fail
    inc rx328_pos
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."xblock"()
    unless $P10, rx328_fail
    rx328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx328_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
    goto alt334_end
  alt334_1:
.annotate 'line', 201
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."pblock"()
    unless $P10, rx328_fail
    rx328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx328_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_343_fail
    rx328_cur."!mark_push"(0, rx328_pos, $I10)
  alt342_0:
    set_addr $I10, alt342_1
    rx328_cur."!mark_push"(0, rx328_pos, $I10)
  # rx literal  "while"
    add $I11, rx328_pos, 5
    gt $I11, rx328_eos, rx328_fail
    sub $I11, rx328_pos, rx328_off
    substr $S10, rx328_tgt, $I11, 5
    ne $S10, "while", rx328_fail
    add rx328_pos, 5
    goto alt342_end
  alt342_1:
  # rx literal  "until"
    add $I11, rx328_pos, 5
    gt $I11, rx328_eos, rx328_fail
    sub $I11, rx328_pos, rx328_off
    substr $S10, rx328_tgt, $I11, 5
    ne $S10, "until", rx328_fail
    add rx328_pos, 5
  alt342_end:
    set_addr $I10, rxcap_343_fail
    ($I12, $I11) = rx328_cur."!mark_peek"($I10)
    rx328_cur."!cursor_pos"($I11)
    ($P10) = rx328_cur."!cursor_start"()
    $P10."!cursor_pass"(rx328_pos, "")
    rx328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_343_done
  rxcap_343_fail:
    goto rx328_fail
  rxcap_343_done:
  # rx charclass s
    ge rx328_pos, rx328_eos, rx328_fail
    sub $I10, rx328_pos, rx328_off
    is_cclass $I11, 32, rx328_tgt, $I10
    unless $I11, rx328_fail
    inc rx328_pos
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."EXPR"()
    unless $P10, rx328_fail
    rx328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx328_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
  alt334_end:
.annotate 'line', 202
  # rx subrule "ws" subtype=method negate=
    rx328_cur."!cursor_pos"(rx328_pos)
    $P10 = rx328_cur."ws"()
    unless $P10, rx328_fail
    rx328_pos = $P10."pos"()
.annotate 'line', 197
  # rx pass
    rx328_cur."!cursor_pass"(rx328_pos, "statement_control:sym<repeat>")
    if_null rx328_debug, debug_551
    rx328_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx328_pos)
  debug_551:
    .return (rx328_cur)
  rx328_restart:
.annotate 'line', 4
    if_null rx328_debug, debug_552
    rx328_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_552:
  rx328_fail:
    (rx328_rep, rx328_pos, $I10, $P10) = rx328_cur."!mark_fail"(0)
    lt rx328_pos, -1, rx328_done
    eq rx328_pos, -1, rx328_fail
    jump $I10
  rx328_done:
    rx328_cur."!cursor_fail"()
    if_null rx328_debug, debug_553
    rx328_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_553:
    .return (rx328_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("72_1298839231.515") :method
.annotate 'line', 4
    new $P330, "ResizablePMCArray"
    push $P330, "repeat"
    .return ($P330)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("73_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx348_tgt
    .local int rx348_pos
    .local int rx348_off
    .local int rx348_eos
    .local int rx348_rep
    .local pmc rx348_cur
    .local pmc rx348_debug
    (rx348_cur, rx348_pos, rx348_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx348_cur
    .local pmc match
    .lex "$/", match
    length rx348_eos, rx348_tgt
    gt rx348_pos, rx348_eos, rx348_done
    set rx348_off, 0
    lt rx348_pos, 2, rx348_start
    sub rx348_off, rx348_pos, 1
    substr rx348_tgt, rx348_tgt, rx348_off
  rx348_start:
    eq $I10, 1, rx348_restart
    if_null rx348_debug, debug_554
    rx348_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan351_done
    goto rxscan351_scan
  rxscan351_loop:
    (rx348_pos) = rx348_cur."from"()
    inc rx348_pos
    rx348_cur."!cursor_from"(rx348_pos)
    ge rx348_pos, rx348_eos, rxscan351_done
  rxscan351_scan:
    set_addr $I10, rxscan351_loop
    rx348_cur."!mark_push"(0, rx348_pos, $I10)
  rxscan351_done:
.annotate 'line', 206
  # rx subcapture "sym"
    set_addr $I10, rxcap_352_fail
    rx348_cur."!mark_push"(0, rx348_pos, $I10)
  # rx literal  "for"
    add $I11, rx348_pos, 3
    gt $I11, rx348_eos, rx348_fail
    sub $I11, rx348_pos, rx348_off
    substr $S10, rx348_tgt, $I11, 3
    ne $S10, "for", rx348_fail
    add rx348_pos, 3
    set_addr $I10, rxcap_352_fail
    ($I12, $I11) = rx348_cur."!mark_peek"($I10)
    rx348_cur."!cursor_pos"($I11)
    ($P10) = rx348_cur."!cursor_start"()
    $P10."!cursor_pass"(rx348_pos, "")
    rx348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_352_done
  rxcap_352_fail:
    goto rx348_fail
  rxcap_352_done:
  # rx charclass s
    ge rx348_pos, rx348_eos, rx348_fail
    sub $I10, rx348_pos, rx348_off
    is_cclass $I11, 32, rx348_tgt, $I10
    unless $I11, rx348_fail
    inc rx348_pos
  # rx subrule "ws" subtype=method negate=
    rx348_cur."!cursor_pos"(rx348_pos)
    $P10 = rx348_cur."ws"()
    unless $P10, rx348_fail
    rx348_pos = $P10."pos"()
.annotate 'line', 207
  # rx subrule "xblock" subtype=capture negate=
    rx348_cur."!cursor_pos"(rx348_pos)
    $P10 = rx348_cur."xblock"()
    unless $P10, rx348_fail
    rx348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx348_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx348_cur."!cursor_pos"(rx348_pos)
    $P10 = rx348_cur."ws"()
    unless $P10, rx348_fail
    rx348_pos = $P10."pos"()
.annotate 'line', 205
  # rx pass
    rx348_cur."!cursor_pass"(rx348_pos, "statement_control:sym<for>")
    if_null rx348_debug, debug_555
    rx348_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx348_pos)
  debug_555:
    .return (rx348_cur)
  rx348_restart:
.annotate 'line', 4
    if_null rx348_debug, debug_556
    rx348_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_556:
  rx348_fail:
    (rx348_rep, rx348_pos, $I10, $P10) = rx348_cur."!mark_fail"(0)
    lt rx348_pos, -1, rx348_done
    eq rx348_pos, -1, rx348_fail
    jump $I10
  rx348_done:
    rx348_cur."!cursor_fail"()
    if_null rx348_debug, debug_557
    rx348_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_557:
    .return (rx348_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("74_1298839231.515") :method
.annotate 'line', 4
    new $P350, "ResizablePMCArray"
    push $P350, "for"
    .return ($P350)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("75_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx356_tgt
    .local int rx356_pos
    .local int rx356_off
    .local int rx356_eos
    .local int rx356_rep
    .local pmc rx356_cur
    .local pmc rx356_debug
    (rx356_cur, rx356_pos, rx356_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx356_cur
    .local pmc match
    .lex "$/", match
    length rx356_eos, rx356_tgt
    gt rx356_pos, rx356_eos, rx356_done
    set rx356_off, 0
    lt rx356_pos, 2, rx356_start
    sub rx356_off, rx356_pos, 1
    substr rx356_tgt, rx356_tgt, rx356_off
  rx356_start:
    eq $I10, 1, rx356_restart
    if_null rx356_debug, debug_558
    rx356_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan359_done
    goto rxscan359_scan
  rxscan359_loop:
    (rx356_pos) = rx356_cur."from"()
    inc rx356_pos
    rx356_cur."!cursor_from"(rx356_pos)
    ge rx356_pos, rx356_eos, rxscan359_done
  rxscan359_scan:
    set_addr $I10, rxscan359_loop
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
  rxscan359_done:
.annotate 'line', 211
  # rx subcapture "sym"
    set_addr $I10, rxcap_360_fail
    rx356_cur."!mark_push"(0, rx356_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx356_pos, 5
    gt $I11, rx356_eos, rx356_fail
    sub $I11, rx356_pos, rx356_off
    substr $S10, rx356_tgt, $I11, 5
    ne $S10, "CATCH", rx356_fail
    add rx356_pos, 5
    set_addr $I10, rxcap_360_fail
    ($I12, $I11) = rx356_cur."!mark_peek"($I10)
    rx356_cur."!cursor_pos"($I11)
    ($P10) = rx356_cur."!cursor_start"()
    $P10."!cursor_pass"(rx356_pos, "")
    rx356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_360_done
  rxcap_360_fail:
    goto rx356_fail
  rxcap_360_done:
  # rx charclass s
    ge rx356_pos, rx356_eos, rx356_fail
    sub $I10, rx356_pos, rx356_off
    is_cclass $I11, 32, rx356_tgt, $I10
    unless $I11, rx356_fail
    inc rx356_pos
  # rx subrule "ws" subtype=method negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."ws"()
    unless $P10, rx356_fail
    rx356_pos = $P10."pos"()
.annotate 'line', 212
  # rx subrule "block" subtype=capture negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."block"()
    unless $P10, rx356_fail
    rx356_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx356_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx356_cur."!cursor_pos"(rx356_pos)
    $P10 = rx356_cur."ws"()
    unless $P10, rx356_fail
    rx356_pos = $P10."pos"()
.annotate 'line', 210
  # rx pass
    rx356_cur."!cursor_pass"(rx356_pos, "statement_control:sym<CATCH>")
    if_null rx356_debug, debug_559
    rx356_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx356_pos)
  debug_559:
    .return (rx356_cur)
  rx356_restart:
.annotate 'line', 4
    if_null rx356_debug, debug_560
    rx356_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_560:
  rx356_fail:
    (rx356_rep, rx356_pos, $I10, $P10) = rx356_cur."!mark_fail"(0)
    lt rx356_pos, -1, rx356_done
    eq rx356_pos, -1, rx356_fail
    jump $I10
  rx356_done:
    rx356_cur."!cursor_fail"()
    if_null rx356_debug, debug_561
    rx356_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_561:
    .return (rx356_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("76_1298839231.515") :method
.annotate 'line', 4
    new $P358, "ResizablePMCArray"
    push $P358, "CATCH"
    .return ($P358)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("77_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx364_tgt
    .local int rx364_pos
    .local int rx364_off
    .local int rx364_eos
    .local int rx364_rep
    .local pmc rx364_cur
    .local pmc rx364_debug
    (rx364_cur, rx364_pos, rx364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx364_cur
    .local pmc match
    .lex "$/", match
    length rx364_eos, rx364_tgt
    gt rx364_pos, rx364_eos, rx364_done
    set rx364_off, 0
    lt rx364_pos, 2, rx364_start
    sub rx364_off, rx364_pos, 1
    substr rx364_tgt, rx364_tgt, rx364_off
  rx364_start:
    eq $I10, 1, rx364_restart
    if_null rx364_debug, debug_562
    rx364_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan367_done
    goto rxscan367_scan
  rxscan367_loop:
    (rx364_pos) = rx364_cur."from"()
    inc rx364_pos
    rx364_cur."!cursor_from"(rx364_pos)
    ge rx364_pos, rx364_eos, rxscan367_done
  rxscan367_scan:
    set_addr $I10, rxscan367_loop
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  rxscan367_done:
.annotate 'line', 216
  # rx subcapture "sym"
    set_addr $I10, rxcap_368_fail
    rx364_cur."!mark_push"(0, rx364_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx364_pos, 7
    gt $I11, rx364_eos, rx364_fail
    sub $I11, rx364_pos, rx364_off
    substr $S10, rx364_tgt, $I11, 7
    ne $S10, "CONTROL", rx364_fail
    add rx364_pos, 7
    set_addr $I10, rxcap_368_fail
    ($I12, $I11) = rx364_cur."!mark_peek"($I10)
    rx364_cur."!cursor_pos"($I11)
    ($P10) = rx364_cur."!cursor_start"()
    $P10."!cursor_pass"(rx364_pos, "")
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_368_done
  rxcap_368_fail:
    goto rx364_fail
  rxcap_368_done:
  # rx charclass s
    ge rx364_pos, rx364_eos, rx364_fail
    sub $I10, rx364_pos, rx364_off
    is_cclass $I11, 32, rx364_tgt, $I10
    unless $I11, rx364_fail
    inc rx364_pos
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
.annotate 'line', 217
  # rx subrule "block" subtype=capture negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."block"()
    unless $P10, rx364_fail
    rx364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx364_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx364_cur."!cursor_pos"(rx364_pos)
    $P10 = rx364_cur."ws"()
    unless $P10, rx364_fail
    rx364_pos = $P10."pos"()
.annotate 'line', 215
  # rx pass
    rx364_cur."!cursor_pass"(rx364_pos, "statement_control:sym<CONTROL>")
    if_null rx364_debug, debug_563
    rx364_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx364_pos)
  debug_563:
    .return (rx364_cur)
  rx364_restart:
.annotate 'line', 4
    if_null rx364_debug, debug_564
    rx364_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_564:
  rx364_fail:
    (rx364_rep, rx364_pos, $I10, $P10) = rx364_cur."!mark_fail"(0)
    lt rx364_pos, -1, rx364_done
    eq rx364_pos, -1, rx364_fail
    jump $I10
  rx364_done:
    rx364_cur."!cursor_fail"()
    if_null rx364_debug, debug_565
    rx364_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_565:
    .return (rx364_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("78_1298839231.515") :method
.annotate 'line', 4
    new $P366, "ResizablePMCArray"
    push $P366, "CONTROL"
    .return ($P366)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("79_1298839231.515")
    .param pmc param_372
.annotate 'line', 220
    .lex "self", param_372
    $P373 = param_372."!protoregex"("statement_prefix")
    .return ($P373)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("80_1298839231.515")
    .param pmc param_375
.annotate 'line', 220
    .lex "self", param_375
    $P376 = param_375."!PREFIX__!protoregex"("statement_prefix")
    .return ($P376)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("81_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx378_tgt
    .local int rx378_pos
    .local int rx378_off
    .local int rx378_eos
    .local int rx378_rep
    .local pmc rx378_cur
    .local pmc rx378_debug
    (rx378_cur, rx378_pos, rx378_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx378_cur
    .local pmc match
    .lex "$/", match
    length rx378_eos, rx378_tgt
    gt rx378_pos, rx378_eos, rx378_done
    set rx378_off, 0
    lt rx378_pos, 2, rx378_start
    sub rx378_off, rx378_pos, 1
    substr rx378_tgt, rx378_tgt, rx378_off
  rx378_start:
    eq $I10, 1, rx378_restart
    if_null rx378_debug, debug_566
    rx378_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan382_done
    goto rxscan382_scan
  rxscan382_loop:
    (rx378_pos) = rx378_cur."from"()
    inc rx378_pos
    rx378_cur."!cursor_from"(rx378_pos)
    ge rx378_pos, rx378_eos, rxscan382_done
  rxscan382_scan:
    set_addr $I10, rxscan382_loop
    rx378_cur."!mark_push"(0, rx378_pos, $I10)
  rxscan382_done:
.annotate 'line', 221
  # rx subcapture "sym"
    set_addr $I10, rxcap_383_fail
    rx378_cur."!mark_push"(0, rx378_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx378_pos, 4
    gt $I11, rx378_eos, rx378_fail
    sub $I11, rx378_pos, rx378_off
    substr $S10, rx378_tgt, $I11, 4
    ne $S10, "INIT", rx378_fail
    add rx378_pos, 4
    set_addr $I10, rxcap_383_fail
    ($I12, $I11) = rx378_cur."!mark_peek"($I10)
    rx378_cur."!cursor_pos"($I11)
    ($P10) = rx378_cur."!cursor_start"()
    $P10."!cursor_pass"(rx378_pos, "")
    rx378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_383_done
  rxcap_383_fail:
    goto rx378_fail
  rxcap_383_done:
  # rx subrule "blorst" subtype=capture negate=
    rx378_cur."!cursor_pos"(rx378_pos)
    $P10 = rx378_cur."blorst"()
    unless $P10, rx378_fail
    rx378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx378_pos = $P10."pos"()
  # rx pass
    rx378_cur."!cursor_pass"(rx378_pos, "statement_prefix:sym<INIT>")
    if_null rx378_debug, debug_567
    rx378_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx378_pos)
  debug_567:
    .return (rx378_cur)
  rx378_restart:
.annotate 'line', 4
    if_null rx378_debug, debug_568
    rx378_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_568:
  rx378_fail:
    (rx378_rep, rx378_pos, $I10, $P10) = rx378_cur."!mark_fail"(0)
    lt rx378_pos, -1, rx378_done
    eq rx378_pos, -1, rx378_fail
    jump $I10
  rx378_done:
    rx378_cur."!cursor_fail"()
    if_null rx378_debug, debug_569
    rx378_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_569:
    .return (rx378_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("82_1298839231.515") :method
.annotate 'line', 4
    $P380 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P381, "ResizablePMCArray"
    push $P381, $P380
    .return ($P381)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("83_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx385_tgt
    .local int rx385_pos
    .local int rx385_off
    .local int rx385_eos
    .local int rx385_rep
    .local pmc rx385_cur
    .local pmc rx385_debug
    (rx385_cur, rx385_pos, rx385_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx385_cur
    .local pmc match
    .lex "$/", match
    length rx385_eos, rx385_tgt
    gt rx385_pos, rx385_eos, rx385_done
    set rx385_off, 0
    lt rx385_pos, 2, rx385_start
    sub rx385_off, rx385_pos, 1
    substr rx385_tgt, rx385_tgt, rx385_off
  rx385_start:
    eq $I10, 1, rx385_restart
    if_null rx385_debug, debug_570
    rx385_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan389_done
    goto rxscan389_scan
  rxscan389_loop:
    (rx385_pos) = rx385_cur."from"()
    inc rx385_pos
    rx385_cur."!cursor_from"(rx385_pos)
    ge rx385_pos, rx385_eos, rxscan389_done
  rxscan389_scan:
    set_addr $I10, rxscan389_loop
    rx385_cur."!mark_push"(0, rx385_pos, $I10)
  rxscan389_done:
.annotate 'line', 224
  # rx subcapture "sym"
    set_addr $I10, rxcap_390_fail
    rx385_cur."!mark_push"(0, rx385_pos, $I10)
  # rx literal  "try"
    add $I11, rx385_pos, 3
    gt $I11, rx385_eos, rx385_fail
    sub $I11, rx385_pos, rx385_off
    substr $S10, rx385_tgt, $I11, 3
    ne $S10, "try", rx385_fail
    add rx385_pos, 3
    set_addr $I10, rxcap_390_fail
    ($I12, $I11) = rx385_cur."!mark_peek"($I10)
    rx385_cur."!cursor_pos"($I11)
    ($P10) = rx385_cur."!cursor_start"()
    $P10."!cursor_pass"(rx385_pos, "")
    rx385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_390_done
  rxcap_390_fail:
    goto rx385_fail
  rxcap_390_done:
.annotate 'line', 225
  # rx subrule "blorst" subtype=capture negate=
    rx385_cur."!cursor_pos"(rx385_pos)
    $P10 = rx385_cur."blorst"()
    unless $P10, rx385_fail
    rx385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx385_pos = $P10."pos"()
.annotate 'line', 223
  # rx pass
    rx385_cur."!cursor_pass"(rx385_pos, "statement_prefix:sym<try>")
    if_null rx385_debug, debug_571
    rx385_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx385_pos)
  debug_571:
    .return (rx385_cur)
  rx385_restart:
.annotate 'line', 4
    if_null rx385_debug, debug_572
    rx385_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_572:
  rx385_fail:
    (rx385_rep, rx385_pos, $I10, $P10) = rx385_cur."!mark_fail"(0)
    lt rx385_pos, -1, rx385_done
    eq rx385_pos, -1, rx385_fail
    jump $I10
  rx385_done:
    rx385_cur."!cursor_fail"()
    if_null rx385_debug, debug_573
    rx385_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_573:
    .return (rx385_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("84_1298839231.515") :method
.annotate 'line', 4
    $P387 = self."!PREFIX__!subrule"("blorst", "try")
    new $P388, "ResizablePMCArray"
    push $P388, $P387
    .return ($P388)
.end


.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("85_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx392_tgt
    .local int rx392_pos
    .local int rx392_off
    .local int rx392_eos
    .local int rx392_rep
    .local pmc rx392_cur
    .local pmc rx392_debug
    (rx392_cur, rx392_pos, rx392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx392_cur
    .local pmc match
    .lex "$/", match
    length rx392_eos, rx392_tgt
    gt rx392_pos, rx392_eos, rx392_done
    set rx392_off, 0
    lt rx392_pos, 2, rx392_start
    sub rx392_off, rx392_pos, 1
    substr rx392_tgt, rx392_tgt, rx392_off
  rx392_start:
    eq $I10, 1, rx392_restart
    if_null rx392_debug, debug_574
    rx392_cur."!cursor_debug"("START", "blorst")
  debug_574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan395_done
    goto rxscan395_scan
  rxscan395_loop:
    (rx392_pos) = rx392_cur."from"()
    inc rx392_pos
    rx392_cur."!cursor_from"(rx392_pos)
    ge rx392_pos, rx392_eos, rxscan395_done
  rxscan395_scan:
    set_addr $I10, rxscan395_loop
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  rxscan395_done:
.annotate 'line', 229
  # rx charclass s
    ge rx392_pos, rx392_eos, rx392_fail
    sub $I10, rx392_pos, rx392_off
    is_cclass $I11, 32, rx392_tgt, $I10
    unless $I11, rx392_fail
    inc rx392_pos
  # rx subrule "ws" subtype=method negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."ws"()
    unless $P10, rx392_fail
    rx392_pos = $P10."pos"()
  alt396_0:
    set_addr $I10, alt396_1
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx392_pos, rx392_off
    substr $S10, rx392_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx392_fail
  # rx subrule "block" subtype=capture negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."block"()
    unless $P10, rx392_fail
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx392_pos = $P10."pos"()
    goto alt396_end
  alt396_1:
  # rx subrule "statement" subtype=capture negate=
    rx392_cur."!cursor_pos"(rx392_pos)
    $P10 = rx392_cur."statement"()
    unless $P10, rx392_fail
    rx392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx392_pos = $P10."pos"()
  alt396_end:
.annotate 'line', 228
  # rx pass
    rx392_cur."!cursor_pass"(rx392_pos, "blorst")
    if_null rx392_debug, debug_575
    rx392_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx392_pos)
  debug_575:
    .return (rx392_cur)
  rx392_restart:
.annotate 'line', 4
    if_null rx392_debug, debug_576
    rx392_cur."!cursor_debug"("NEXT", "blorst")
  debug_576:
  rx392_fail:
    (rx392_rep, rx392_pos, $I10, $P10) = rx392_cur."!mark_fail"(0)
    lt rx392_pos, -1, rx392_done
    eq rx392_pos, -1, rx392_fail
    jump $I10
  rx392_done:
    rx392_cur."!cursor_fail"()
    if_null rx392_debug, debug_577
    rx392_cur."!cursor_debug"("FAIL", "blorst")
  debug_577:
    .return (rx392_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("86_1298839231.515") :method
.annotate 'line', 4
    new $P394, "ResizablePMCArray"
    push $P394, ""
    .return ($P394)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("87_1298839231.515")
    .param pmc param_398
.annotate 'line', 234
    .lex "self", param_398
    $P399 = param_398."!protoregex"("statement_mod_cond")
    .return ($P399)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("88_1298839231.515")
    .param pmc param_401
.annotate 'line', 234
    .lex "self", param_401
    $P402 = param_401."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P402)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("89_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx404_tgt
    .local int rx404_pos
    .local int rx404_off
    .local int rx404_eos
    .local int rx404_rep
    .local pmc rx404_cur
    .local pmc rx404_debug
    (rx404_cur, rx404_pos, rx404_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx404_cur
    .local pmc match
    .lex "$/", match
    length rx404_eos, rx404_tgt
    gt rx404_pos, rx404_eos, rx404_done
    set rx404_off, 0
    lt rx404_pos, 2, rx404_start
    sub rx404_off, rx404_pos, 1
    substr rx404_tgt, rx404_tgt, rx404_off
  rx404_start:
    eq $I10, 1, rx404_restart
    if_null rx404_debug, debug_578
    rx404_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan408_done
    goto rxscan408_scan
  rxscan408_loop:
    (rx404_pos) = rx404_cur."from"()
    inc rx404_pos
    rx404_cur."!cursor_from"(rx404_pos)
    ge rx404_pos, rx404_eos, rxscan408_done
  rxscan408_scan:
    set_addr $I10, rxscan408_loop
    rx404_cur."!mark_push"(0, rx404_pos, $I10)
  rxscan408_done:
.annotate 'line', 236
  # rx subcapture "sym"
    set_addr $I10, rxcap_409_fail
    rx404_cur."!mark_push"(0, rx404_pos, $I10)
  # rx literal  "if"
    add $I11, rx404_pos, 2
    gt $I11, rx404_eos, rx404_fail
    sub $I11, rx404_pos, rx404_off
    substr $S10, rx404_tgt, $I11, 2
    ne $S10, "if", rx404_fail
    add rx404_pos, 2
    set_addr $I10, rxcap_409_fail
    ($I12, $I11) = rx404_cur."!mark_peek"($I10)
    rx404_cur."!cursor_pos"($I11)
    ($P10) = rx404_cur."!cursor_start"()
    $P10."!cursor_pass"(rx404_pos, "")
    rx404_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_409_done
  rxcap_409_fail:
    goto rx404_fail
  rxcap_409_done:
  # rx subrule "ws" subtype=method negate=
    rx404_cur."!cursor_pos"(rx404_pos)
    $P10 = rx404_cur."ws"()
    unless $P10, rx404_fail
    rx404_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx404_cur."!cursor_pos"(rx404_pos)
    $P10 = rx404_cur."EXPR"()
    unless $P10, rx404_fail
    rx404_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx404_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx404_cur."!cursor_pos"(rx404_pos)
    $P10 = rx404_cur."ws"()
    unless $P10, rx404_fail
    rx404_pos = $P10."pos"()
  # rx pass
    rx404_cur."!cursor_pass"(rx404_pos, "statement_mod_cond:sym<if>")
    if_null rx404_debug, debug_579
    rx404_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx404_pos)
  debug_579:
    .return (rx404_cur)
  rx404_restart:
.annotate 'line', 4
    if_null rx404_debug, debug_580
    rx404_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_580:
  rx404_fail:
    (rx404_rep, rx404_pos, $I10, $P10) = rx404_cur."!mark_fail"(0)
    lt rx404_pos, -1, rx404_done
    eq rx404_pos, -1, rx404_fail
    jump $I10
  rx404_done:
    rx404_cur."!cursor_fail"()
    if_null rx404_debug, debug_581
    rx404_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_581:
    .return (rx404_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("90_1298839231.515") :method
.annotate 'line', 4
    $P406 = self."!PREFIX__!subrule"("ws", "if")
    new $P407, "ResizablePMCArray"
    push $P407, $P406
    .return ($P407)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("91_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx413_tgt
    .local int rx413_pos
    .local int rx413_off
    .local int rx413_eos
    .local int rx413_rep
    .local pmc rx413_cur
    .local pmc rx413_debug
    (rx413_cur, rx413_pos, rx413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx413_cur
    .local pmc match
    .lex "$/", match
    length rx413_eos, rx413_tgt
    gt rx413_pos, rx413_eos, rx413_done
    set rx413_off, 0
    lt rx413_pos, 2, rx413_start
    sub rx413_off, rx413_pos, 1
    substr rx413_tgt, rx413_tgt, rx413_off
  rx413_start:
    eq $I10, 1, rx413_restart
    if_null rx413_debug, debug_582
    rx413_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan417_done
    goto rxscan417_scan
  rxscan417_loop:
    (rx413_pos) = rx413_cur."from"()
    inc rx413_pos
    rx413_cur."!cursor_from"(rx413_pos)
    ge rx413_pos, rx413_eos, rxscan417_done
  rxscan417_scan:
    set_addr $I10, rxscan417_loop
    rx413_cur."!mark_push"(0, rx413_pos, $I10)
  rxscan417_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_418_fail
    rx413_cur."!mark_push"(0, rx413_pos, $I10)
  # rx literal  "unless"
    add $I11, rx413_pos, 6
    gt $I11, rx413_eos, rx413_fail
    sub $I11, rx413_pos, rx413_off
    substr $S10, rx413_tgt, $I11, 6
    ne $S10, "unless", rx413_fail
    add rx413_pos, 6
    set_addr $I10, rxcap_418_fail
    ($I12, $I11) = rx413_cur."!mark_peek"($I10)
    rx413_cur."!cursor_pos"($I11)
    ($P10) = rx413_cur."!cursor_start"()
    $P10."!cursor_pass"(rx413_pos, "")
    rx413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_418_done
  rxcap_418_fail:
    goto rx413_fail
  rxcap_418_done:
  # rx subrule "ws" subtype=method negate=
    rx413_cur."!cursor_pos"(rx413_pos)
    $P10 = rx413_cur."ws"()
    unless $P10, rx413_fail
    rx413_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx413_cur."!cursor_pos"(rx413_pos)
    $P10 = rx413_cur."EXPR"()
    unless $P10, rx413_fail
    rx413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx413_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx413_cur."!cursor_pos"(rx413_pos)
    $P10 = rx413_cur."ws"()
    unless $P10, rx413_fail
    rx413_pos = $P10."pos"()
  # rx pass
    rx413_cur."!cursor_pass"(rx413_pos, "statement_mod_cond:sym<unless>")
    if_null rx413_debug, debug_583
    rx413_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx413_pos)
  debug_583:
    .return (rx413_cur)
  rx413_restart:
.annotate 'line', 4
    if_null rx413_debug, debug_584
    rx413_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_584:
  rx413_fail:
    (rx413_rep, rx413_pos, $I10, $P10) = rx413_cur."!mark_fail"(0)
    lt rx413_pos, -1, rx413_done
    eq rx413_pos, -1, rx413_fail
    jump $I10
  rx413_done:
    rx413_cur."!cursor_fail"()
    if_null rx413_debug, debug_585
    rx413_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_585:
    .return (rx413_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("92_1298839231.515") :method
.annotate 'line', 4
    $P415 = self."!PREFIX__!subrule"("ws", "unless")
    new $P416, "ResizablePMCArray"
    push $P416, $P415
    .return ($P416)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("93_1298839231.515")
    .param pmc param_422
.annotate 'line', 239
    .lex "self", param_422
    $P423 = param_422."!protoregex"("statement_mod_loop")
    .return ($P423)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("94_1298839231.515")
    .param pmc param_425
.annotate 'line', 239
    .lex "self", param_425
    $P426 = param_425."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P426)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("95_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx428_tgt
    .local int rx428_pos
    .local int rx428_off
    .local int rx428_eos
    .local int rx428_rep
    .local pmc rx428_cur
    .local pmc rx428_debug
    (rx428_cur, rx428_pos, rx428_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx428_cur
    .local pmc match
    .lex "$/", match
    length rx428_eos, rx428_tgt
    gt rx428_pos, rx428_eos, rx428_done
    set rx428_off, 0
    lt rx428_pos, 2, rx428_start
    sub rx428_off, rx428_pos, 1
    substr rx428_tgt, rx428_tgt, rx428_off
  rx428_start:
    eq $I10, 1, rx428_restart
    if_null rx428_debug, debug_586
    rx428_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan432_done
    goto rxscan432_scan
  rxscan432_loop:
    (rx428_pos) = rx428_cur."from"()
    inc rx428_pos
    rx428_cur."!cursor_from"(rx428_pos)
    ge rx428_pos, rx428_eos, rxscan432_done
  rxscan432_scan:
    set_addr $I10, rxscan432_loop
    rx428_cur."!mark_push"(0, rx428_pos, $I10)
  rxscan432_done:
.annotate 'line', 241
  # rx subcapture "sym"
    set_addr $I10, rxcap_433_fail
    rx428_cur."!mark_push"(0, rx428_pos, $I10)
  # rx literal  "while"
    add $I11, rx428_pos, 5
    gt $I11, rx428_eos, rx428_fail
    sub $I11, rx428_pos, rx428_off
    substr $S10, rx428_tgt, $I11, 5
    ne $S10, "while", rx428_fail
    add rx428_pos, 5
    set_addr $I10, rxcap_433_fail
    ($I12, $I11) = rx428_cur."!mark_peek"($I10)
    rx428_cur."!cursor_pos"($I11)
    ($P10) = rx428_cur."!cursor_start"()
    $P10."!cursor_pass"(rx428_pos, "")
    rx428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_433_done
  rxcap_433_fail:
    goto rx428_fail
  rxcap_433_done:
  # rx subrule "ws" subtype=method negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."ws"()
    unless $P10, rx428_fail
    rx428_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."EXPR"()
    unless $P10, rx428_fail
    rx428_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx428_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx428_cur."!cursor_pos"(rx428_pos)
    $P10 = rx428_cur."ws"()
    unless $P10, rx428_fail
    rx428_pos = $P10."pos"()
  # rx pass
    rx428_cur."!cursor_pass"(rx428_pos, "statement_mod_loop:sym<while>")
    if_null rx428_debug, debug_587
    rx428_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx428_pos)
  debug_587:
    .return (rx428_cur)
  rx428_restart:
.annotate 'line', 4
    if_null rx428_debug, debug_588
    rx428_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_588:
  rx428_fail:
    (rx428_rep, rx428_pos, $I10, $P10) = rx428_cur."!mark_fail"(0)
    lt rx428_pos, -1, rx428_done
    eq rx428_pos, -1, rx428_fail
    jump $I10
  rx428_done:
    rx428_cur."!cursor_fail"()
    if_null rx428_debug, debug_589
    rx428_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_589:
    .return (rx428_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("96_1298839231.515") :method
.annotate 'line', 4
    $P430 = self."!PREFIX__!subrule"("ws", "while")
    new $P431, "ResizablePMCArray"
    push $P431, $P430
    .return ($P431)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("97_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx437_tgt
    .local int rx437_pos
    .local int rx437_off
    .local int rx437_eos
    .local int rx437_rep
    .local pmc rx437_cur
    .local pmc rx437_debug
    (rx437_cur, rx437_pos, rx437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx437_cur
    .local pmc match
    .lex "$/", match
    length rx437_eos, rx437_tgt
    gt rx437_pos, rx437_eos, rx437_done
    set rx437_off, 0
    lt rx437_pos, 2, rx437_start
    sub rx437_off, rx437_pos, 1
    substr rx437_tgt, rx437_tgt, rx437_off
  rx437_start:
    eq $I10, 1, rx437_restart
    if_null rx437_debug, debug_590
    rx437_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan441_done
    goto rxscan441_scan
  rxscan441_loop:
    (rx437_pos) = rx437_cur."from"()
    inc rx437_pos
    rx437_cur."!cursor_from"(rx437_pos)
    ge rx437_pos, rx437_eos, rxscan441_done
  rxscan441_scan:
    set_addr $I10, rxscan441_loop
    rx437_cur."!mark_push"(0, rx437_pos, $I10)
  rxscan441_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_442_fail
    rx437_cur."!mark_push"(0, rx437_pos, $I10)
  # rx literal  "until"
    add $I11, rx437_pos, 5
    gt $I11, rx437_eos, rx437_fail
    sub $I11, rx437_pos, rx437_off
    substr $S10, rx437_tgt, $I11, 5
    ne $S10, "until", rx437_fail
    add rx437_pos, 5
    set_addr $I10, rxcap_442_fail
    ($I12, $I11) = rx437_cur."!mark_peek"($I10)
    rx437_cur."!cursor_pos"($I11)
    ($P10) = rx437_cur."!cursor_start"()
    $P10."!cursor_pass"(rx437_pos, "")
    rx437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_442_done
  rxcap_442_fail:
    goto rx437_fail
  rxcap_442_done:
  # rx subrule "ws" subtype=method negate=
    rx437_cur."!cursor_pos"(rx437_pos)
    $P10 = rx437_cur."ws"()
    unless $P10, rx437_fail
    rx437_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx437_cur."!cursor_pos"(rx437_pos)
    $P10 = rx437_cur."EXPR"()
    unless $P10, rx437_fail
    rx437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx437_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx437_cur."!cursor_pos"(rx437_pos)
    $P10 = rx437_cur."ws"()
    unless $P10, rx437_fail
    rx437_pos = $P10."pos"()
  # rx pass
    rx437_cur."!cursor_pass"(rx437_pos, "statement_mod_loop:sym<until>")
    if_null rx437_debug, debug_591
    rx437_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx437_pos)
  debug_591:
    .return (rx437_cur)
  rx437_restart:
.annotate 'line', 4
    if_null rx437_debug, debug_592
    rx437_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_592:
  rx437_fail:
    (rx437_rep, rx437_pos, $I10, $P10) = rx437_cur."!mark_fail"(0)
    lt rx437_pos, -1, rx437_done
    eq rx437_pos, -1, rx437_fail
    jump $I10
  rx437_done:
    rx437_cur."!cursor_fail"()
    if_null rx437_debug, debug_593
    rx437_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_593:
    .return (rx437_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("98_1298839231.515") :method
.annotate 'line', 4
    $P439 = self."!PREFIX__!subrule"("ws", "until")
    new $P440, "ResizablePMCArray"
    push $P440, $P439
    .return ($P440)
.end


.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("99_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx446_tgt
    .local int rx446_pos
    .local int rx446_off
    .local int rx446_eos
    .local int rx446_rep
    .local pmc rx446_cur
    .local pmc rx446_debug
    (rx446_cur, rx446_pos, rx446_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx446_cur
    .local pmc match
    .lex "$/", match
    length rx446_eos, rx446_tgt
    gt rx446_pos, rx446_eos, rx446_done
    set rx446_off, 0
    lt rx446_pos, 2, rx446_start
    sub rx446_off, rx446_pos, 1
    substr rx446_tgt, rx446_tgt, rx446_off
  rx446_start:
    eq $I10, 1, rx446_restart
    if_null rx446_debug, debug_594
    rx446_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan450_done
    goto rxscan450_scan
  rxscan450_loop:
    (rx446_pos) = rx446_cur."from"()
    inc rx446_pos
    rx446_cur."!cursor_from"(rx446_pos)
    ge rx446_pos, rx446_eos, rxscan450_done
  rxscan450_scan:
    set_addr $I10, rxscan450_loop
    rx446_cur."!mark_push"(0, rx446_pos, $I10)
  rxscan450_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_451_fail
    rx446_cur."!mark_push"(0, rx446_pos, $I10)
  # rx literal  "for"
    add $I11, rx446_pos, 3
    gt $I11, rx446_eos, rx446_fail
    sub $I11, rx446_pos, rx446_off
    substr $S10, rx446_tgt, $I11, 3
    ne $S10, "for", rx446_fail
    add rx446_pos, 3
    set_addr $I10, rxcap_451_fail
    ($I12, $I11) = rx446_cur."!mark_peek"($I10)
    rx446_cur."!cursor_pos"($I11)
    ($P10) = rx446_cur."!cursor_start"()
    $P10."!cursor_pass"(rx446_pos, "")
    rx446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_451_done
  rxcap_451_fail:
    goto rx446_fail
  rxcap_451_done:
  # rx subrule "ws" subtype=method negate=
    rx446_cur."!cursor_pos"(rx446_pos)
    $P10 = rx446_cur."ws"()
    unless $P10, rx446_fail
    rx446_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx446_cur."!cursor_pos"(rx446_pos)
    $P10 = rx446_cur."EXPR"()
    unless $P10, rx446_fail
    rx446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx446_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx446_cur."!cursor_pos"(rx446_pos)
    $P10 = rx446_cur."ws"()
    unless $P10, rx446_fail
    rx446_pos = $P10."pos"()
  # rx pass
    rx446_cur."!cursor_pass"(rx446_pos, "statement_mod_loop:sym<for>")
    if_null rx446_debug, debug_595
    rx446_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx446_pos)
  debug_595:
    .return (rx446_cur)
  rx446_restart:
.annotate 'line', 4
    if_null rx446_debug, debug_596
    rx446_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_596:
  rx446_fail:
    (rx446_rep, rx446_pos, $I10, $P10) = rx446_cur."!mark_fail"(0)
    lt rx446_pos, -1, rx446_done
    eq rx446_pos, -1, rx446_fail
    jump $I10
  rx446_done:
    rx446_cur."!cursor_fail"()
    if_null rx446_debug, debug_597
    rx446_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_597:
    .return (rx446_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("100_1298839231.515") :method
.annotate 'line', 4
    $P448 = self."!PREFIX__!subrule"("ws", "for")
    new $P449, "ResizablePMCArray"
    push $P449, $P448
    .return ($P449)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("101_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx455_tgt
    .local int rx455_pos
    .local int rx455_off
    .local int rx455_eos
    .local int rx455_rep
    .local pmc rx455_cur
    .local pmc rx455_debug
    (rx455_cur, rx455_pos, rx455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx455_cur
    .local pmc match
    .lex "$/", match
    length rx455_eos, rx455_tgt
    gt rx455_pos, rx455_eos, rx455_done
    set rx455_off, 0
    lt rx455_pos, 2, rx455_start
    sub rx455_off, rx455_pos, 1
    substr rx455_tgt, rx455_tgt, rx455_off
  rx455_start:
    eq $I10, 1, rx455_restart
    if_null rx455_debug, debug_598
    rx455_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan459_done
    goto rxscan459_scan
  rxscan459_loop:
    (rx455_pos) = rx455_cur."from"()
    inc rx455_pos
    rx455_cur."!cursor_from"(rx455_pos)
    ge rx455_pos, rx455_eos, rxscan459_done
  rxscan459_scan:
    set_addr $I10, rxscan459_loop
    rx455_cur."!mark_push"(0, rx455_pos, $I10)
  rxscan459_done:
.annotate 'line', 247
  # rx subrule "fatarrow" subtype=capture negate=
    rx455_cur."!cursor_pos"(rx455_pos)
    $P10 = rx455_cur."fatarrow"()
    unless $P10, rx455_fail
    rx455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx455_pos = $P10."pos"()
  # rx pass
    rx455_cur."!cursor_pass"(rx455_pos, "term:sym<fatarrow>")
    if_null rx455_debug, debug_599
    rx455_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx455_pos)
  debug_599:
    .return (rx455_cur)
  rx455_restart:
.annotate 'line', 4
    if_null rx455_debug, debug_600
    rx455_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_600:
  rx455_fail:
    (rx455_rep, rx455_pos, $I10, $P10) = rx455_cur."!mark_fail"(0)
    lt rx455_pos, -1, rx455_done
    eq rx455_pos, -1, rx455_fail
    jump $I10
  rx455_done:
    rx455_cur."!cursor_fail"()
    if_null rx455_debug, debug_601
    rx455_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_601:
    .return (rx455_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("102_1298839231.515") :method
.annotate 'line', 4
    $P457 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P458, "ResizablePMCArray"
    push $P458, $P457
    .return ($P458)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("103_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx461_tgt
    .local int rx461_pos
    .local int rx461_off
    .local int rx461_eos
    .local int rx461_rep
    .local pmc rx461_cur
    .local pmc rx461_debug
    (rx461_cur, rx461_pos, rx461_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx461_cur
    .local pmc match
    .lex "$/", match
    length rx461_eos, rx461_tgt
    gt rx461_pos, rx461_eos, rx461_done
    set rx461_off, 0
    lt rx461_pos, 2, rx461_start
    sub rx461_off, rx461_pos, 1
    substr rx461_tgt, rx461_tgt, rx461_off
  rx461_start:
    eq $I10, 1, rx461_restart
    if_null rx461_debug, debug_602
    rx461_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan465_done
    goto rxscan465_scan
  rxscan465_loop:
    (rx461_pos) = rx461_cur."from"()
    inc rx461_pos
    rx461_cur."!cursor_from"(rx461_pos)
    ge rx461_pos, rx461_eos, rxscan465_done
  rxscan465_scan:
    set_addr $I10, rxscan465_loop
    rx461_cur."!mark_push"(0, rx461_pos, $I10)
  rxscan465_done:
.annotate 'line', 248
  # rx subrule "colonpair" subtype=capture negate=
    rx461_cur."!cursor_pos"(rx461_pos)
    $P10 = rx461_cur."colonpair"()
    unless $P10, rx461_fail
    rx461_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx461_pos = $P10."pos"()
  # rx pass
    rx461_cur."!cursor_pass"(rx461_pos, "term:sym<colonpair>")
    if_null rx461_debug, debug_603
    rx461_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx461_pos)
  debug_603:
    .return (rx461_cur)
  rx461_restart:
.annotate 'line', 4
    if_null rx461_debug, debug_604
    rx461_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_604:
  rx461_fail:
    (rx461_rep, rx461_pos, $I10, $P10) = rx461_cur."!mark_fail"(0)
    lt rx461_pos, -1, rx461_done
    eq rx461_pos, -1, rx461_fail
    jump $I10
  rx461_done:
    rx461_cur."!cursor_fail"()
    if_null rx461_debug, debug_605
    rx461_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_605:
    .return (rx461_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("104_1298839231.515") :method
.annotate 'line', 4
    $P463 = self."!PREFIX__!subrule"("colonpair", "")
    new $P464, "ResizablePMCArray"
    push $P464, $P463
    .return ($P464)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("105_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx467_tgt
    .local int rx467_pos
    .local int rx467_off
    .local int rx467_eos
    .local int rx467_rep
    .local pmc rx467_cur
    .local pmc rx467_debug
    (rx467_cur, rx467_pos, rx467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx467_cur
    .local pmc match
    .lex "$/", match
    length rx467_eos, rx467_tgt
    gt rx467_pos, rx467_eos, rx467_done
    set rx467_off, 0
    lt rx467_pos, 2, rx467_start
    sub rx467_off, rx467_pos, 1
    substr rx467_tgt, rx467_tgt, rx467_off
  rx467_start:
    eq $I10, 1, rx467_restart
    if_null rx467_debug, debug_606
    rx467_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan471_done
    goto rxscan471_scan
  rxscan471_loop:
    (rx467_pos) = rx467_cur."from"()
    inc rx467_pos
    rx467_cur."!cursor_from"(rx467_pos)
    ge rx467_pos, rx467_eos, rxscan471_done
  rxscan471_scan:
    set_addr $I10, rxscan471_loop
    rx467_cur."!mark_push"(0, rx467_pos, $I10)
  rxscan471_done:
.annotate 'line', 249
  # rx subrule "variable" subtype=capture negate=
    rx467_cur."!cursor_pos"(rx467_pos)
    $P10 = rx467_cur."variable"()
    unless $P10, rx467_fail
    rx467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx467_pos = $P10."pos"()
  # rx pass
    rx467_cur."!cursor_pass"(rx467_pos, "term:sym<variable>")
    if_null rx467_debug, debug_607
    rx467_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx467_pos)
  debug_607:
    .return (rx467_cur)
  rx467_restart:
.annotate 'line', 4
    if_null rx467_debug, debug_608
    rx467_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_608:
  rx467_fail:
    (rx467_rep, rx467_pos, $I10, $P10) = rx467_cur."!mark_fail"(0)
    lt rx467_pos, -1, rx467_done
    eq rx467_pos, -1, rx467_fail
    jump $I10
  rx467_done:
    rx467_cur."!cursor_fail"()
    if_null rx467_debug, debug_609
    rx467_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_609:
    .return (rx467_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("106_1298839231.515") :method
.annotate 'line', 4
    $P469 = self."!PREFIX__!subrule"("variable", "")
    new $P470, "ResizablePMCArray"
    push $P470, $P469
    .return ($P470)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("107_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx473_tgt
    .local int rx473_pos
    .local int rx473_off
    .local int rx473_eos
    .local int rx473_rep
    .local pmc rx473_cur
    .local pmc rx473_debug
    (rx473_cur, rx473_pos, rx473_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx473_cur
    .local pmc match
    .lex "$/", match
    length rx473_eos, rx473_tgt
    gt rx473_pos, rx473_eos, rx473_done
    set rx473_off, 0
    lt rx473_pos, 2, rx473_start
    sub rx473_off, rx473_pos, 1
    substr rx473_tgt, rx473_tgt, rx473_off
  rx473_start:
    eq $I10, 1, rx473_restart
    if_null rx473_debug, debug_610
    rx473_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan477_done
    goto rxscan477_scan
  rxscan477_loop:
    (rx473_pos) = rx473_cur."from"()
    inc rx473_pos
    rx473_cur."!cursor_from"(rx473_pos)
    ge rx473_pos, rx473_eos, rxscan477_done
  rxscan477_scan:
    set_addr $I10, rxscan477_loop
    rx473_cur."!mark_push"(0, rx473_pos, $I10)
  rxscan477_done:
.annotate 'line', 250
  # rx subrule "package_declarator" subtype=capture negate=
    rx473_cur."!cursor_pos"(rx473_pos)
    $P10 = rx473_cur."package_declarator"()
    unless $P10, rx473_fail
    rx473_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx473_pos = $P10."pos"()
  # rx pass
    rx473_cur."!cursor_pass"(rx473_pos, "term:sym<package_declarator>")
    if_null rx473_debug, debug_611
    rx473_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx473_pos)
  debug_611:
    .return (rx473_cur)
  rx473_restart:
.annotate 'line', 4
    if_null rx473_debug, debug_612
    rx473_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_612:
  rx473_fail:
    (rx473_rep, rx473_pos, $I10, $P10) = rx473_cur."!mark_fail"(0)
    lt rx473_pos, -1, rx473_done
    eq rx473_pos, -1, rx473_fail
    jump $I10
  rx473_done:
    rx473_cur."!cursor_fail"()
    if_null rx473_debug, debug_613
    rx473_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_613:
    .return (rx473_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("108_1298839231.515") :method
.annotate 'line', 4
    $P475 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P476, "ResizablePMCArray"
    push $P476, $P475
    .return ($P476)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("109_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx479_tgt
    .local int rx479_pos
    .local int rx479_off
    .local int rx479_eos
    .local int rx479_rep
    .local pmc rx479_cur
    .local pmc rx479_debug
    (rx479_cur, rx479_pos, rx479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx479_cur
    .local pmc match
    .lex "$/", match
    length rx479_eos, rx479_tgt
    gt rx479_pos, rx479_eos, rx479_done
    set rx479_off, 0
    lt rx479_pos, 2, rx479_start
    sub rx479_off, rx479_pos, 1
    substr rx479_tgt, rx479_tgt, rx479_off
  rx479_start:
    eq $I10, 1, rx479_restart
    if_null rx479_debug, debug_614
    rx479_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan483_done
    goto rxscan483_scan
  rxscan483_loop:
    (rx479_pos) = rx479_cur."from"()
    inc rx479_pos
    rx479_cur."!cursor_from"(rx479_pos)
    ge rx479_pos, rx479_eos, rxscan483_done
  rxscan483_scan:
    set_addr $I10, rxscan483_loop
    rx479_cur."!mark_push"(0, rx479_pos, $I10)
  rxscan483_done:
.annotate 'line', 251
  # rx subrule "scope_declarator" subtype=capture negate=
    rx479_cur."!cursor_pos"(rx479_pos)
    $P10 = rx479_cur."scope_declarator"()
    unless $P10, rx479_fail
    rx479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx479_pos = $P10."pos"()
  # rx pass
    rx479_cur."!cursor_pass"(rx479_pos, "term:sym<scope_declarator>")
    if_null rx479_debug, debug_615
    rx479_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx479_pos)
  debug_615:
    .return (rx479_cur)
  rx479_restart:
.annotate 'line', 4
    if_null rx479_debug, debug_616
    rx479_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_616:
  rx479_fail:
    (rx479_rep, rx479_pos, $I10, $P10) = rx479_cur."!mark_fail"(0)
    lt rx479_pos, -1, rx479_done
    eq rx479_pos, -1, rx479_fail
    jump $I10
  rx479_done:
    rx479_cur."!cursor_fail"()
    if_null rx479_debug, debug_617
    rx479_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_617:
    .return (rx479_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("110_1298839231.515") :method
.annotate 'line', 4
    $P481 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P482, "ResizablePMCArray"
    push $P482, $P481
    .return ($P482)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("111_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx485_tgt
    .local int rx485_pos
    .local int rx485_off
    .local int rx485_eos
    .local int rx485_rep
    .local pmc rx485_cur
    .local pmc rx485_debug
    (rx485_cur, rx485_pos, rx485_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx485_cur
    .local pmc match
    .lex "$/", match
    length rx485_eos, rx485_tgt
    gt rx485_pos, rx485_eos, rx485_done
    set rx485_off, 0
    lt rx485_pos, 2, rx485_start
    sub rx485_off, rx485_pos, 1
    substr rx485_tgt, rx485_tgt, rx485_off
  rx485_start:
    eq $I10, 1, rx485_restart
    if_null rx485_debug, debug_618
    rx485_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan489_done
    goto rxscan489_scan
  rxscan489_loop:
    (rx485_pos) = rx485_cur."from"()
    inc rx485_pos
    rx485_cur."!cursor_from"(rx485_pos)
    ge rx485_pos, rx485_eos, rxscan489_done
  rxscan489_scan:
    set_addr $I10, rxscan489_loop
    rx485_cur."!mark_push"(0, rx485_pos, $I10)
  rxscan489_done:
.annotate 'line', 252
  # rx subrule "routine_declarator" subtype=capture negate=
    rx485_cur."!cursor_pos"(rx485_pos)
    $P10 = rx485_cur."routine_declarator"()
    unless $P10, rx485_fail
    rx485_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx485_pos = $P10."pos"()
  # rx pass
    rx485_cur."!cursor_pass"(rx485_pos, "term:sym<routine_declarator>")
    if_null rx485_debug, debug_619
    rx485_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx485_pos)
  debug_619:
    .return (rx485_cur)
  rx485_restart:
.annotate 'line', 4
    if_null rx485_debug, debug_620
    rx485_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_620:
  rx485_fail:
    (rx485_rep, rx485_pos, $I10, $P10) = rx485_cur."!mark_fail"(0)
    lt rx485_pos, -1, rx485_done
    eq rx485_pos, -1, rx485_fail
    jump $I10
  rx485_done:
    rx485_cur."!cursor_fail"()
    if_null rx485_debug, debug_621
    rx485_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_621:
    .return (rx485_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("112_1298839231.515") :method
.annotate 'line', 4
    $P487 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P488, "ResizablePMCArray"
    push $P488, $P487
    .return ($P488)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("113_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P501 = "116_1298839231.515" 
    capture_lex $P501
    .const 'Sub' $P496 = "115_1298839231.515" 
    capture_lex $P496
    .local string rx491_tgt
    .local int rx491_pos
    .local int rx491_off
    .local int rx491_eos
    .local int rx491_rep
    .local pmc rx491_cur
    .local pmc rx491_debug
    (rx491_cur, rx491_pos, rx491_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx491_cur
    .local pmc match
    .lex "$/", match
    length rx491_eos, rx491_tgt
    gt rx491_pos, rx491_eos, rx491_done
    set rx491_off, 0
    lt rx491_pos, 2, rx491_start
    sub rx491_off, rx491_pos, 1
    substr rx491_tgt, rx491_tgt, rx491_off
  rx491_start:
    eq $I10, 1, rx491_restart
    if_null rx491_debug, debug_622
    rx491_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan494_done
    goto rxscan494_scan
  rxscan494_loop:
    (rx491_pos) = rx491_cur."from"()
    inc rx491_pos
    rx491_cur."!cursor_from"(rx491_pos)
    ge rx491_pos, rx491_eos, rxscan494_done
  rxscan494_scan:
    set_addr $I10, rxscan494_loop
    rx491_cur."!mark_push"(0, rx491_pos, $I10)
  rxscan494_done:
.annotate 'line', 254
  # rx subrule "before" subtype=zerowidth negate=
    rx491_cur."!cursor_pos"(rx491_pos)
    .const 'Sub' $P496 = "115_1298839231.515" 
    capture_lex $P496
    $P10 = rx491_cur."before"($P496)
    unless $P10, rx491_fail
.annotate 'line', 255
  # rx subrule "before" subtype=zerowidth negate=1
    rx491_cur."!cursor_pos"(rx491_pos)
    .const 'Sub' $P501 = "116_1298839231.515" 
    capture_lex $P501
    $P10 = rx491_cur."before"($P501)
    if $P10, rx491_fail
.annotate 'line', 256
  # rx subrule "multi_declarator" subtype=capture negate=
    rx491_cur."!cursor_pos"(rx491_pos)
    $P10 = rx491_cur."multi_declarator"()
    unless $P10, rx491_fail
    rx491_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx491_pos = $P10."pos"()
.annotate 'line', 253
  # rx pass
    rx491_cur."!cursor_pass"(rx491_pos, "term:sym<multi_declarator>")
    if_null rx491_debug, debug_631
    rx491_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx491_pos)
  debug_631:
    .return (rx491_cur)
  rx491_restart:
.annotate 'line', 4
    if_null rx491_debug, debug_632
    rx491_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_632:
  rx491_fail:
    (rx491_rep, rx491_pos, $I10, $P10) = rx491_cur."!mark_fail"(0)
    lt rx491_pos, -1, rx491_done
    eq rx491_pos, -1, rx491_fail
    jump $I10
  rx491_done:
    rx491_cur."!cursor_fail"()
    if_null rx491_debug, debug_633
    rx491_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_633:
    .return (rx491_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("114_1298839231.515") :method
.annotate 'line', 4
    new $P493, "ResizablePMCArray"
    push $P493, ""
    .return ($P493)
.end


.namespace ["NQP";"Grammar"]
.sub "_block495"  :anon :subid("115_1298839231.515") :method :outer("113_1298839231.515")
.annotate 'line', 254
    .local string rx497_tgt
    .local int rx497_pos
    .local int rx497_off
    .local int rx497_eos
    .local int rx497_rep
    .local pmc rx497_cur
    .local pmc rx497_debug
    (rx497_cur, rx497_pos, rx497_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx497_cur
    .local pmc match
    .lex "$/", match
    length rx497_eos, rx497_tgt
    gt rx497_pos, rx497_eos, rx497_done
    set rx497_off, 0
    lt rx497_pos, 2, rx497_start
    sub rx497_off, rx497_pos, 1
    substr rx497_tgt, rx497_tgt, rx497_off
  rx497_start:
    eq $I10, 1, rx497_restart
    if_null rx497_debug, debug_623
    rx497_cur."!cursor_debug"("START", "")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan498_done
    goto rxscan498_scan
  rxscan498_loop:
    (rx497_pos) = rx497_cur."from"()
    inc rx497_pos
    rx497_cur."!cursor_from"(rx497_pos)
    ge rx497_pos, rx497_eos, rxscan498_done
  rxscan498_scan:
    set_addr $I10, rxscan498_loop
    rx497_cur."!mark_push"(0, rx497_pos, $I10)
  rxscan498_done:
  alt499_0:
    set_addr $I10, alt499_1
    rx497_cur."!mark_push"(0, rx497_pos, $I10)
  # rx literal  "multi"
    add $I11, rx497_pos, 5
    gt $I11, rx497_eos, rx497_fail
    sub $I11, rx497_pos, rx497_off
    substr $S10, rx497_tgt, $I11, 5
    ne $S10, "multi", rx497_fail
    add rx497_pos, 5
    goto alt499_end
  alt499_1:
    set_addr $I10, alt499_2
    rx497_cur."!mark_push"(0, rx497_pos, $I10)
  # rx literal  "proto"
    add $I11, rx497_pos, 5
    gt $I11, rx497_eos, rx497_fail
    sub $I11, rx497_pos, rx497_off
    substr $S10, rx497_tgt, $I11, 5
    ne $S10, "proto", rx497_fail
    add rx497_pos, 5
    goto alt499_end
  alt499_2:
  # rx literal  "only"
    add $I11, rx497_pos, 4
    gt $I11, rx497_eos, rx497_fail
    sub $I11, rx497_pos, rx497_off
    substr $S10, rx497_tgt, $I11, 4
    ne $S10, "only", rx497_fail
    add rx497_pos, 4
  alt499_end:
  # rx pass
    rx497_cur."!cursor_pass"(rx497_pos, "")
    if_null rx497_debug, debug_624
    rx497_cur."!cursor_debug"("PASS", "", " at pos=", rx497_pos)
  debug_624:
    .return (rx497_cur)
  rx497_restart:
    if_null rx497_debug, debug_625
    rx497_cur."!cursor_debug"("NEXT", "")
  debug_625:
  rx497_fail:
    (rx497_rep, rx497_pos, $I10, $P10) = rx497_cur."!mark_fail"(0)
    lt rx497_pos, -1, rx497_done
    eq rx497_pos, -1, rx497_fail
    jump $I10
  rx497_done:
    rx497_cur."!cursor_fail"()
    if_null rx497_debug, debug_626
    rx497_cur."!cursor_debug"("FAIL", "")
  debug_626:
    .return (rx497_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "_block500"  :anon :subid("116_1298839231.515") :method :outer("113_1298839231.515")
.annotate 'line', 255
    .local string rx502_tgt
    .local int rx502_pos
    .local int rx502_off
    .local int rx502_eos
    .local int rx502_rep
    .local pmc rx502_cur
    .local pmc rx502_debug
    (rx502_cur, rx502_pos, rx502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx502_cur
    .local pmc match
    .lex "$/", match
    length rx502_eos, rx502_tgt
    gt rx502_pos, rx502_eos, rx502_done
    set rx502_off, 0
    lt rx502_pos, 2, rx502_start
    sub rx502_off, rx502_pos, 1
    substr rx502_tgt, rx502_tgt, rx502_off
  rx502_start:
    eq $I10, 1, rx502_restart
    if_null rx502_debug, debug_627
    rx502_cur."!cursor_debug"("START", "")
  debug_627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan503_done
    goto rxscan503_scan
  rxscan503_loop:
    (rx502_pos) = rx502_cur."from"()
    inc rx502_pos
    rx502_cur."!cursor_from"(rx502_pos)
    ge rx502_pos, rx502_eos, rxscan503_done
  rxscan503_scan:
    set_addr $I10, rxscan503_loop
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  rxscan503_done:
  # rx literal  "proto"
    add $I11, rx502_pos, 5
    gt $I11, rx502_eos, rx502_fail
    sub $I11, rx502_pos, rx502_off
    substr $S10, rx502_tgt, $I11, 5
    ne $S10, "proto", rx502_fail
    add rx502_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."ws"()
    unless $P10, rx502_fail
    rx502_pos = $P10."pos"()
  alt504_0:
    set_addr $I10, alt504_1
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  # rx literal  "regex"
    add $I11, rx502_pos, 5
    gt $I11, rx502_eos, rx502_fail
    sub $I11, rx502_pos, rx502_off
    substr $S10, rx502_tgt, $I11, 5
    ne $S10, "regex", rx502_fail
    add rx502_pos, 5
    goto alt504_end
  alt504_1:
    set_addr $I10, alt504_2
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  # rx literal  "token"
    add $I11, rx502_pos, 5
    gt $I11, rx502_eos, rx502_fail
    sub $I11, rx502_pos, rx502_off
    substr $S10, rx502_tgt, $I11, 5
    ne $S10, "token", rx502_fail
    add rx502_pos, 5
    goto alt504_end
  alt504_2:
  # rx literal  "rule"
    add $I11, rx502_pos, 4
    gt $I11, rx502_eos, rx502_fail
    sub $I11, rx502_pos, rx502_off
    substr $S10, rx502_tgt, $I11, 4
    ne $S10, "rule", rx502_fail
    add rx502_pos, 4
  alt504_end:
  # rx pass
    rx502_cur."!cursor_pass"(rx502_pos, "")
    if_null rx502_debug, debug_628
    rx502_cur."!cursor_debug"("PASS", "", " at pos=", rx502_pos)
  debug_628:
    .return (rx502_cur)
  rx502_restart:
    if_null rx502_debug, debug_629
    rx502_cur."!cursor_debug"("NEXT", "")
  debug_629:
  rx502_fail:
    (rx502_rep, rx502_pos, $I10, $P10) = rx502_cur."!mark_fail"(0)
    lt rx502_pos, -1, rx502_done
    eq rx502_pos, -1, rx502_fail
    jump $I10
  rx502_done:
    rx502_cur."!cursor_fail"()
    if_null rx502_debug, debug_630
    rx502_cur."!cursor_debug"("FAIL", "")
  debug_630:
    .return (rx502_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("117_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx506_tgt
    .local int rx506_pos
    .local int rx506_off
    .local int rx506_eos
    .local int rx506_rep
    .local pmc rx506_cur
    .local pmc rx506_debug
    (rx506_cur, rx506_pos, rx506_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx506_cur
    .local pmc match
    .lex "$/", match
    length rx506_eos, rx506_tgt
    gt rx506_pos, rx506_eos, rx506_done
    set rx506_off, 0
    lt rx506_pos, 2, rx506_start
    sub rx506_off, rx506_pos, 1
    substr rx506_tgt, rx506_tgt, rx506_off
  rx506_start:
    eq $I10, 1, rx506_restart
    if_null rx506_debug, debug_634
    rx506_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan510_done
    goto rxscan510_scan
  rxscan510_loop:
    (rx506_pos) = rx506_cur."from"()
    inc rx506_pos
    rx506_cur."!cursor_from"(rx506_pos)
    ge rx506_pos, rx506_eos, rxscan510_done
  rxscan510_scan:
    set_addr $I10, rxscan510_loop
    rx506_cur."!mark_push"(0, rx506_pos, $I10)
  rxscan510_done:
.annotate 'line', 258
  # rx subrule "regex_declarator" subtype=capture negate=
    rx506_cur."!cursor_pos"(rx506_pos)
    $P10 = rx506_cur."regex_declarator"()
    unless $P10, rx506_fail
    rx506_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx506_pos = $P10."pos"()
  # rx pass
    rx506_cur."!cursor_pass"(rx506_pos, "term:sym<regex_declarator>")
    if_null rx506_debug, debug_635
    rx506_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx506_pos)
  debug_635:
    .return (rx506_cur)
  rx506_restart:
.annotate 'line', 4
    if_null rx506_debug, debug_636
    rx506_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_636:
  rx506_fail:
    (rx506_rep, rx506_pos, $I10, $P10) = rx506_cur."!mark_fail"(0)
    lt rx506_pos, -1, rx506_done
    eq rx506_pos, -1, rx506_fail
    jump $I10
  rx506_done:
    rx506_cur."!cursor_fail"()
    if_null rx506_debug, debug_637
    rx506_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_637:
    .return (rx506_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("118_1298839231.515") :method
.annotate 'line', 4
    $P508 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P509, "ResizablePMCArray"
    push $P509, $P508
    .return ($P509)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("119_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx512_tgt
    .local int rx512_pos
    .local int rx512_off
    .local int rx512_eos
    .local int rx512_rep
    .local pmc rx512_cur
    .local pmc rx512_debug
    (rx512_cur, rx512_pos, rx512_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx512_cur
    .local pmc match
    .lex "$/", match
    length rx512_eos, rx512_tgt
    gt rx512_pos, rx512_eos, rx512_done
    set rx512_off, 0
    lt rx512_pos, 2, rx512_start
    sub rx512_off, rx512_pos, 1
    substr rx512_tgt, rx512_tgt, rx512_off
  rx512_start:
    eq $I10, 1, rx512_restart
    if_null rx512_debug, debug_638
    rx512_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan516_done
    goto rxscan516_scan
  rxscan516_loop:
    (rx512_pos) = rx512_cur."from"()
    inc rx512_pos
    rx512_cur."!cursor_from"(rx512_pos)
    ge rx512_pos, rx512_eos, rxscan516_done
  rxscan516_scan:
    set_addr $I10, rxscan516_loop
    rx512_cur."!mark_push"(0, rx512_pos, $I10)
  rxscan516_done:
.annotate 'line', 259
  # rx subrule "statement_prefix" subtype=capture negate=
    rx512_cur."!cursor_pos"(rx512_pos)
    $P10 = rx512_cur."statement_prefix"()
    unless $P10, rx512_fail
    rx512_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx512_pos = $P10."pos"()
  # rx pass
    rx512_cur."!cursor_pass"(rx512_pos, "term:sym<statement_prefix>")
    if_null rx512_debug, debug_639
    rx512_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx512_pos)
  debug_639:
    .return (rx512_cur)
  rx512_restart:
.annotate 'line', 4
    if_null rx512_debug, debug_640
    rx512_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_640:
  rx512_fail:
    (rx512_rep, rx512_pos, $I10, $P10) = rx512_cur."!mark_fail"(0)
    lt rx512_pos, -1, rx512_done
    eq rx512_pos, -1, rx512_fail
    jump $I10
  rx512_done:
    rx512_cur."!cursor_fail"()
    if_null rx512_debug, debug_641
    rx512_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_641:
    .return (rx512_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("120_1298839231.515") :method
.annotate 'line', 4
    $P514 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P515, "ResizablePMCArray"
    push $P515, $P514
    .return ($P515)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("121_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx518_tgt
    .local int rx518_pos
    .local int rx518_off
    .local int rx518_eos
    .local int rx518_rep
    .local pmc rx518_cur
    .local pmc rx518_debug
    (rx518_cur, rx518_pos, rx518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx518_cur
    .local pmc match
    .lex "$/", match
    length rx518_eos, rx518_tgt
    gt rx518_pos, rx518_eos, rx518_done
    set rx518_off, 0
    lt rx518_pos, 2, rx518_start
    sub rx518_off, rx518_pos, 1
    substr rx518_tgt, rx518_tgt, rx518_off
  rx518_start:
    eq $I10, 1, rx518_restart
    if_null rx518_debug, debug_642
    rx518_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan521_done
    goto rxscan521_scan
  rxscan521_loop:
    (rx518_pos) = rx518_cur."from"()
    inc rx518_pos
    rx518_cur."!cursor_from"(rx518_pos)
    ge rx518_pos, rx518_eos, rxscan521_done
  rxscan521_scan:
    set_addr $I10, rxscan521_loop
    rx518_cur."!mark_push"(0, rx518_pos, $I10)
  rxscan521_done:
.annotate 'line', 260
  # rx subrule "lambda" subtype=zerowidth negate=
    rx518_cur."!cursor_pos"(rx518_pos)
    $P10 = rx518_cur."lambda"()
    unless $P10, rx518_fail
  # rx subrule "pblock" subtype=capture negate=
    rx518_cur."!cursor_pos"(rx518_pos)
    $P10 = rx518_cur."pblock"()
    unless $P10, rx518_fail
    rx518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx518_pos = $P10."pos"()
  # rx pass
    rx518_cur."!cursor_pass"(rx518_pos, "term:sym<lambda>")
    if_null rx518_debug, debug_643
    rx518_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx518_pos)
  debug_643:
    .return (rx518_cur)
  rx518_restart:
.annotate 'line', 4
    if_null rx518_debug, debug_644
    rx518_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_644:
  rx518_fail:
    (rx518_rep, rx518_pos, $I10, $P10) = rx518_cur."!mark_fail"(0)
    lt rx518_pos, -1, rx518_done
    eq rx518_pos, -1, rx518_fail
    jump $I10
  rx518_done:
    rx518_cur."!cursor_fail"()
    if_null rx518_debug, debug_645
    rx518_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_645:
    .return (rx518_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("122_1298839231.515") :method
.annotate 'line', 4
    new $P520, "ResizablePMCArray"
    push $P520, ""
    .return ($P520)
.end


.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("123_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx523_tgt
    .local int rx523_pos
    .local int rx523_off
    .local int rx523_eos
    .local int rx523_rep
    .local pmc rx523_cur
    .local pmc rx523_debug
    (rx523_cur, rx523_pos, rx523_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx523_cur
    .local pmc match
    .lex "$/", match
    length rx523_eos, rx523_tgt
    gt rx523_pos, rx523_eos, rx523_done
    set rx523_off, 0
    lt rx523_pos, 2, rx523_start
    sub rx523_off, rx523_pos, 1
    substr rx523_tgt, rx523_tgt, rx523_off
  rx523_start:
    eq $I10, 1, rx523_restart
    if_null rx523_debug, debug_646
    rx523_cur."!cursor_debug"("START", "fatarrow")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan527_done
    goto rxscan527_scan
  rxscan527_loop:
    (rx523_pos) = rx523_cur."from"()
    inc rx523_pos
    rx523_cur."!cursor_from"(rx523_pos)
    ge rx523_pos, rx523_eos, rxscan527_done
  rxscan527_scan:
    set_addr $I10, rxscan527_loop
    rx523_cur."!mark_push"(0, rx523_pos, $I10)
  rxscan527_done:
.annotate 'line', 263
  # rx subrule "identifier" subtype=capture negate=
    rx523_cur."!cursor_pos"(rx523_pos)
    $P10 = rx523_cur."identifier"()
    unless $P10, rx523_fail
    rx523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx523_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx523_pos, rx523_off
    set rx523_rep, 0
    sub $I12, rx523_eos, rx523_pos
  rxenumcharlistq528_loop:
    le $I12, 0, rxenumcharlistq528_done
    substr $S10, rx523_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq528_done
    inc rx523_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq528_loop
  rxenumcharlistq528_done:
    add rx523_pos, rx523_pos, rx523_rep
  # rx literal  "=>"
    add $I11, rx523_pos, 2
    gt $I11, rx523_eos, rx523_fail
    sub $I11, rx523_pos, rx523_off
    substr $S10, rx523_tgt, $I11, 2
    ne $S10, "=>", rx523_fail
    add rx523_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx523_cur."!cursor_pos"(rx523_pos)
    $P10 = rx523_cur."ws"()
    unless $P10, rx523_fail
    rx523_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx523_cur."!cursor_pos"(rx523_pos)
    $P10 = rx523_cur."EXPR"("i=")
    unless $P10, rx523_fail
    rx523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx523_pos = $P10."pos"()
.annotate 'line', 262
  # rx pass
    rx523_cur."!cursor_pass"(rx523_pos, "fatarrow")
    if_null rx523_debug, debug_647
    rx523_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx523_pos)
  debug_647:
    .return (rx523_cur)
  rx523_restart:
.annotate 'line', 4
    if_null rx523_debug, debug_648
    rx523_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_648:
  rx523_fail:
    (rx523_rep, rx523_pos, $I10, $P10) = rx523_cur."!mark_fail"(0)
    lt rx523_pos, -1, rx523_done
    eq rx523_pos, -1, rx523_fail
    jump $I10
  rx523_done:
    rx523_cur."!cursor_fail"()
    if_null rx523_debug, debug_649
    rx523_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_649:
    .return (rx523_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("124_1298839231.515") :method
.annotate 'line', 4
    $P525 = self."!PREFIX__!subrule"("identifier", "")
    new $P526, "ResizablePMCArray"
    push $P526, $P525
    .return ($P526)
.end


.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("125_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx530_tgt
    .local int rx530_pos
    .local int rx530_off
    .local int rx530_eos
    .local int rx530_rep
    .local pmc rx530_cur
    .local pmc rx530_debug
    (rx530_cur, rx530_pos, rx530_tgt, $I10) = self."!cursor_start"()
    rx530_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx530_cur
    .local pmc match
    .lex "$/", match
    length rx530_eos, rx530_tgt
    gt rx530_pos, rx530_eos, rx530_done
    set rx530_off, 0
    lt rx530_pos, 2, rx530_start
    sub rx530_off, rx530_pos, 1
    substr rx530_tgt, rx530_tgt, rx530_off
  rx530_start:
    eq $I10, 1, rx530_restart
    if_null rx530_debug, debug_650
    rx530_cur."!cursor_debug"("START", "colonpair")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan536_done
    goto rxscan536_scan
  rxscan536_loop:
    (rx530_pos) = rx530_cur."from"()
    inc rx530_pos
    rx530_cur."!cursor_from"(rx530_pos)
    ge rx530_pos, rx530_eos, rxscan536_done
  rxscan536_scan:
    set_addr $I10, rxscan536_loop
    rx530_cur."!mark_push"(0, rx530_pos, $I10)
  rxscan536_done:
.annotate 'line', 267
  # rx literal  ":"
    add $I11, rx530_pos, 1
    gt $I11, rx530_eos, rx530_fail
    sub $I11, rx530_pos, rx530_off
    ord $I11, rx530_tgt, $I11
    ne $I11, 58, rx530_fail
    add rx530_pos, 1
  alt537_0:
.annotate 'line', 268
    set_addr $I10, alt537_1
    rx530_cur."!mark_push"(0, rx530_pos, $I10)
.annotate 'line', 269
  # rx subcapture "not"
    set_addr $I10, rxcap_538_fail
    rx530_cur."!mark_push"(0, rx530_pos, $I10)
  # rx literal  "!"
    add $I11, rx530_pos, 1
    gt $I11, rx530_eos, rx530_fail
    sub $I11, rx530_pos, rx530_off
    ord $I11, rx530_tgt, $I11
    ne $I11, 33, rx530_fail
    add rx530_pos, 1
    set_addr $I10, rxcap_538_fail
    ($I12, $I11) = rx530_cur."!mark_peek"($I10)
    rx530_cur."!cursor_pos"($I11)
    ($P10) = rx530_cur."!cursor_start"()
    $P10."!cursor_pass"(rx530_pos, "")
    rx530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_538_done
  rxcap_538_fail:
    goto rx530_fail
  rxcap_538_done:
  # rx subrule "identifier" subtype=capture negate=
    rx530_cur."!cursor_pos"(rx530_pos)
    $P10 = rx530_cur."identifier"()
    unless $P10, rx530_fail
    rx530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx530_pos = $P10."pos"()
    goto alt537_end
  alt537_1:
    set_addr $I10, alt537_2
    rx530_cur."!mark_push"(0, rx530_pos, $I10)
.annotate 'line', 270
  # rx subrule "identifier" subtype=capture negate=
    rx530_cur."!cursor_pos"(rx530_pos)
    $P10 = rx530_cur."identifier"()
    unless $P10, rx530_fail
    rx530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx530_pos = $P10."pos"()
  # rx rxquantr539 ** 0..1
    set_addr $I10, rxquantr539_done
    rx530_cur."!mark_push"(0, rx530_pos, $I10)
  rxquantr539_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx530_cur."!cursor_pos"(rx530_pos)
    $P10 = rx530_cur."circumfix"()
    unless $P10, rx530_fail
    goto rxsubrule540_pass
  rxsubrule540_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx530_fail
  rxsubrule540_pass:
    set_addr $I10, rxsubrule540_back
    rx530_cur."!mark_push"(0, rx530_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx530_pos = $P10."pos"()
    set_addr $I10, rxquantr539_done
    (rx530_rep) = rx530_cur."!mark_commit"($I10)
  rxquantr539_done:
    goto alt537_end
  alt537_2:
.annotate 'line', 271
  # rx subrule "circumfix" subtype=capture negate=
    rx530_cur."!cursor_pos"(rx530_pos)
    $P10 = rx530_cur."circumfix"()
    unless $P10, rx530_fail
    rx530_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx530_pos = $P10."pos"()
  alt537_end:
.annotate 'line', 266
  # rx pass
    rx530_cur."!cursor_pass"(rx530_pos, "colonpair")
    if_null rx530_debug, debug_651
    rx530_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx530_pos)
  debug_651:
    .return (rx530_cur)
  rx530_restart:
.annotate 'line', 4
    if_null rx530_debug, debug_652
    rx530_cur."!cursor_debug"("NEXT", "colonpair")
  debug_652:
  rx530_fail:
    (rx530_rep, rx530_pos, $I10, $P10) = rx530_cur."!mark_fail"(0)
    lt rx530_pos, -1, rx530_done
    eq rx530_pos, -1, rx530_fail
    jump $I10
  rx530_done:
    rx530_cur."!cursor_fail"()
    if_null rx530_debug, debug_653
    rx530_cur."!cursor_debug"("FAIL", "colonpair")
  debug_653:
    .return (rx530_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("126_1298839231.515") :method
.annotate 'line', 4
    $P532 = self."!PREFIX__!subrule"("circumfix", ":")
    $P533 = self."!PREFIX__!subrule"("identifier", ":")
    $P534 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P535, "ResizablePMCArray"
    push $P535, $P532
    push $P535, $P533
    push $P535, $P534
    .return ($P535)
.end


.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("127_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx542_tgt
    .local int rx542_pos
    .local int rx542_off
    .local int rx542_eos
    .local int rx542_rep
    .local pmc rx542_cur
    .local pmc rx542_debug
    (rx542_cur, rx542_pos, rx542_tgt, $I10) = self."!cursor_start"()
    rx542_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx542_cur
    .local pmc match
    .lex "$/", match
    length rx542_eos, rx542_tgt
    gt rx542_pos, rx542_eos, rx542_done
    set rx542_off, 0
    lt rx542_pos, 2, rx542_start
    sub rx542_off, rx542_pos, 1
    substr rx542_tgt, rx542_tgt, rx542_off
  rx542_start:
    eq $I10, 1, rx542_restart
    if_null rx542_debug, debug_654
    rx542_cur."!cursor_debug"("START", "variable")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan547_done
    goto rxscan547_scan
  rxscan547_loop:
    (rx542_pos) = rx542_cur."from"()
    inc rx542_pos
    rx542_cur."!cursor_from"(rx542_pos)
    ge rx542_pos, rx542_eos, rxscan547_done
  rxscan547_scan:
    set_addr $I10, rxscan547_loop
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  rxscan547_done:
  alt548_0:
.annotate 'line', 275
    set_addr $I10, alt548_1
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
.annotate 'line', 276
  # rx subrule "sigil" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."sigil"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx542_pos = $P10."pos"()
  # rx rxquantr549 ** 0..1
    set_addr $I10, rxquantr549_done
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  rxquantr549_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."twigil"()
    unless $P10, rx542_fail
    goto rxsubrule550_pass
  rxsubrule550_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx542_fail
  rxsubrule550_pass:
    set_addr $I10, rxsubrule550_back
    rx542_cur."!mark_push"(0, rx542_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx542_pos = $P10."pos"()
    set_addr $I10, rxquantr549_done
    (rx542_rep) = rx542_cur."!mark_commit"($I10)
  rxquantr549_done:
  # rx subrule "name" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."name"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx542_pos = $P10."pos"()
    goto alt548_end
  alt548_1:
    set_addr $I10, alt548_2
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
.annotate 'line', 277
  # rx subrule "sigil" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."sigil"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx542_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx542_pos, rx542_off
    substr $S10, rx542_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx542_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx542_cur."!cursor_pos"(rx542_pos)
    $P10 = rx542_cur."postcircumfix"()
    unless $P10, rx542_fail
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx542_pos = $P10."pos"()
    goto alt548_end
  alt548_2:
.annotate 'line', 278
  # rx subcapture "sigil"
    set_addr $I10, rxcap_551_fail
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  # rx literal  "$"
    add $I11, rx542_pos, 1
    gt $I11, rx542_eos, rx542_fail
    sub $I11, rx542_pos, rx542_off
    ord $I11, rx542_tgt, $I11
    ne $I11, 36, rx542_fail
    add rx542_pos, 1
    set_addr $I10, rxcap_551_fail
    ($I12, $I11) = rx542_cur."!mark_peek"($I10)
    rx542_cur."!cursor_pos"($I11)
    ($P10) = rx542_cur."!cursor_start"()
    $P10."!cursor_pass"(rx542_pos, "")
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_551_done
  rxcap_551_fail:
    goto rx542_fail
  rxcap_551_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_552_fail
    rx542_cur."!mark_push"(0, rx542_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx542_pos, rx542_eos, rx542_fail
    sub $I10, rx542_pos, rx542_off
    substr $S10, rx542_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx542_fail
    inc rx542_pos
    set_addr $I10, rxcap_552_fail
    ($I12, $I11) = rx542_cur."!mark_peek"($I10)
    rx542_cur."!cursor_pos"($I11)
    ($P10) = rx542_cur."!cursor_start"()
    $P10."!cursor_pass"(rx542_pos, "")
    rx542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_552_done
  rxcap_552_fail:
    goto rx542_fail
  rxcap_552_done:
  alt548_end:
.annotate 'line', 275
  # rx pass
    rx542_cur."!cursor_pass"(rx542_pos, "variable")
    if_null rx542_debug, debug_655
    rx542_cur."!cursor_debug"("PASS", "variable", " at pos=", rx542_pos)
  debug_655:
    .return (rx542_cur)
  rx542_restart:
.annotate 'line', 4
    if_null rx542_debug, debug_656
    rx542_cur."!cursor_debug"("NEXT", "variable")
  debug_656:
  rx542_fail:
    (rx542_rep, rx542_pos, $I10, $P10) = rx542_cur."!mark_fail"(0)
    lt rx542_pos, -1, rx542_done
    eq rx542_pos, -1, rx542_fail
    jump $I10
  rx542_done:
    rx542_cur."!cursor_fail"()
    if_null rx542_debug, debug_657
    rx542_cur."!cursor_debug"("FAIL", "variable")
  debug_657:
    .return (rx542_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("128_1298839231.515") :method
.annotate 'line', 4
    $P544 = self."!PREFIX__!subrule"("sigil", "")
    $P545 = self."!PREFIX__!subrule"("sigil", "")
    new $P546, "ResizablePMCArray"
    push $P546, "$!"
    push $P546, "$_"
    push $P546, "$/"
    push $P546, $P544
    push $P546, $P545
    .return ($P546)
.end


.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("129_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx554_tgt
    .local int rx554_pos
    .local int rx554_off
    .local int rx554_eos
    .local int rx554_rep
    .local pmc rx554_cur
    .local pmc rx554_debug
    (rx554_cur, rx554_pos, rx554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx554_cur
    .local pmc match
    .lex "$/", match
    length rx554_eos, rx554_tgt
    gt rx554_pos, rx554_eos, rx554_done
    set rx554_off, 0
    lt rx554_pos, 2, rx554_start
    sub rx554_off, rx554_pos, 1
    substr rx554_tgt, rx554_tgt, rx554_off
  rx554_start:
    eq $I10, 1, rx554_restart
    if_null rx554_debug, debug_658
    rx554_cur."!cursor_debug"("START", "sigil")
  debug_658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan557_done
    goto rxscan557_scan
  rxscan557_loop:
    (rx554_pos) = rx554_cur."from"()
    inc rx554_pos
    rx554_cur."!cursor_from"(rx554_pos)
    ge rx554_pos, rx554_eos, rxscan557_done
  rxscan557_scan:
    set_addr $I10, rxscan557_loop
    rx554_cur."!mark_push"(0, rx554_pos, $I10)
  rxscan557_done:
.annotate 'line', 281
  # rx enumcharlist negate=0 
    ge rx554_pos, rx554_eos, rx554_fail
    sub $I10, rx554_pos, rx554_off
    substr $S10, rx554_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx554_fail
    inc rx554_pos
  # rx pass
    rx554_cur."!cursor_pass"(rx554_pos, "sigil")
    if_null rx554_debug, debug_659
    rx554_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx554_pos)
  debug_659:
    .return (rx554_cur)
  rx554_restart:
.annotate 'line', 4
    if_null rx554_debug, debug_660
    rx554_cur."!cursor_debug"("NEXT", "sigil")
  debug_660:
  rx554_fail:
    (rx554_rep, rx554_pos, $I10, $P10) = rx554_cur."!mark_fail"(0)
    lt rx554_pos, -1, rx554_done
    eq rx554_pos, -1, rx554_fail
    jump $I10
  rx554_done:
    rx554_cur."!cursor_fail"()
    if_null rx554_debug, debug_661
    rx554_cur."!cursor_debug"("FAIL", "sigil")
  debug_661:
    .return (rx554_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("130_1298839231.515") :method
.annotate 'line', 4
    new $P556, "ResizablePMCArray"
    push $P556, "&"
    push $P556, "%"
    push $P556, "@"
    push $P556, "$"
    .return ($P556)
.end


.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("131_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx559_tgt
    .local int rx559_pos
    .local int rx559_off
    .local int rx559_eos
    .local int rx559_rep
    .local pmc rx559_cur
    .local pmc rx559_debug
    (rx559_cur, rx559_pos, rx559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx559_cur
    .local pmc match
    .lex "$/", match
    length rx559_eos, rx559_tgt
    gt rx559_pos, rx559_eos, rx559_done
    set rx559_off, 0
    lt rx559_pos, 2, rx559_start
    sub rx559_off, rx559_pos, 1
    substr rx559_tgt, rx559_tgt, rx559_off
  rx559_start:
    eq $I10, 1, rx559_restart
    if_null rx559_debug, debug_662
    rx559_cur."!cursor_debug"("START", "twigil")
  debug_662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan562_done
    goto rxscan562_scan
  rxscan562_loop:
    (rx559_pos) = rx559_cur."from"()
    inc rx559_pos
    rx559_cur."!cursor_from"(rx559_pos)
    ge rx559_pos, rx559_eos, rxscan562_done
  rxscan562_scan:
    set_addr $I10, rxscan562_loop
    rx559_cur."!mark_push"(0, rx559_pos, $I10)
  rxscan562_done:
.annotate 'line', 283
  # rx enumcharlist negate=0 
    ge rx559_pos, rx559_eos, rx559_fail
    sub $I10, rx559_pos, rx559_off
    substr $S10, rx559_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx559_fail
    inc rx559_pos
  # rx pass
    rx559_cur."!cursor_pass"(rx559_pos, "twigil")
    if_null rx559_debug, debug_663
    rx559_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx559_pos)
  debug_663:
    .return (rx559_cur)
  rx559_restart:
.annotate 'line', 4
    if_null rx559_debug, debug_664
    rx559_cur."!cursor_debug"("NEXT", "twigil")
  debug_664:
  rx559_fail:
    (rx559_rep, rx559_pos, $I10, $P10) = rx559_cur."!mark_fail"(0)
    lt rx559_pos, -1, rx559_done
    eq rx559_pos, -1, rx559_fail
    jump $I10
  rx559_done:
    rx559_cur."!cursor_fail"()
    if_null rx559_debug, debug_665
    rx559_cur."!cursor_debug"("FAIL", "twigil")
  debug_665:
    .return (rx559_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("132_1298839231.515") :method
.annotate 'line', 4
    new $P561, "ResizablePMCArray"
    push $P561, "?"
    push $P561, "!"
    push $P561, "*"
    .return ($P561)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("133_1298839231.515")
    .param pmc param_564
.annotate 'line', 285
    .lex "self", param_564
    $P565 = param_564."!protoregex"("package_declarator")
    .return ($P565)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("134_1298839231.515")
    .param pmc param_567
.annotate 'line', 285
    .lex "self", param_567
    $P568 = param_567."!PREFIX__!protoregex"("package_declarator")
    .return ($P568)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("135_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 287
    new $P570, "Undef"
    .lex "$*PACKAGE-SETUP", $P570
.annotate 'line', 288
    new $P571, "Undef"
    .lex "$*PKGDECL", $P571
.annotate 'line', 4
    .local string rx572_tgt
    .local int rx572_pos
    .local int rx572_off
    .local int rx572_eos
    .local int rx572_rep
    .local pmc rx572_cur
    .local pmc rx572_debug
    (rx572_cur, rx572_pos, rx572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx572_cur
    .local pmc match
    .lex "$/", match
    length rx572_eos, rx572_tgt
    gt rx572_pos, rx572_eos, rx572_done
    set rx572_off, 0
    lt rx572_pos, 2, rx572_start
    sub rx572_off, rx572_pos, 1
    substr rx572_tgt, rx572_tgt, rx572_off
  rx572_start:
    eq $I10, 1, rx572_restart
    if_null rx572_debug, debug_666
    rx572_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan576_done
    goto rxscan576_scan
  rxscan576_loop:
    (rx572_pos) = rx572_cur."from"()
    inc rx572_pos
    rx572_cur."!cursor_from"(rx572_pos)
    ge rx572_pos, rx572_eos, rxscan576_done
  rxscan576_scan:
    set_addr $I10, rxscan576_loop
    rx572_cur."!mark_push"(0, rx572_pos, $I10)
  rxscan576_done:
.annotate 'line', 287
    rx572_cur."!cursor_pos"(rx572_pos)
    get_hll_global $P577, ["PAST"], "Stmts"
    $P578 = $P577."new"()
    store_lex "$*PACKAGE-SETUP", $P578
.annotate 'line', 288
    rx572_cur."!cursor_pos"(rx572_pos)
    new $P579, "String"
    assign $P579, "module"
    store_lex "$*PKGDECL", $P579
.annotate 'line', 289
  # rx subcapture "sym"
    set_addr $I10, rxcap_580_fail
    rx572_cur."!mark_push"(0, rx572_pos, $I10)
  # rx literal  "module"
    add $I11, rx572_pos, 6
    gt $I11, rx572_eos, rx572_fail
    sub $I11, rx572_pos, rx572_off
    substr $S10, rx572_tgt, $I11, 6
    ne $S10, "module", rx572_fail
    add rx572_pos, 6
    set_addr $I10, rxcap_580_fail
    ($I12, $I11) = rx572_cur."!mark_peek"($I10)
    rx572_cur."!cursor_pos"($I11)
    ($P10) = rx572_cur."!cursor_start"()
    $P10."!cursor_pass"(rx572_pos, "")
    rx572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_580_done
  rxcap_580_fail:
    goto rx572_fail
  rxcap_580_done:
  # rx subrule "package_def" subtype=capture negate=
    rx572_cur."!cursor_pos"(rx572_pos)
    $P10 = rx572_cur."package_def"()
    unless $P10, rx572_fail
    rx572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx572_pos = $P10."pos"()
.annotate 'line', 286
  # rx pass
    rx572_cur."!cursor_pass"(rx572_pos, "package_declarator:sym<module>")
    if_null rx572_debug, debug_667
    rx572_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx572_pos)
  debug_667:
    .return (rx572_cur)
  rx572_restart:
.annotate 'line', 4
    if_null rx572_debug, debug_668
    rx572_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_668:
  rx572_fail:
    (rx572_rep, rx572_pos, $I10, $P10) = rx572_cur."!mark_fail"(0)
    lt rx572_pos, -1, rx572_done
    eq rx572_pos, -1, rx572_fail
    jump $I10
  rx572_done:
    rx572_cur."!cursor_fail"()
    if_null rx572_debug, debug_669
    rx572_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_669:
    .return (rx572_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("136_1298839231.515") :method
.annotate 'line', 4
    $P574 = self."!PREFIX__!subrule"("package_def", "module")
    new $P575, "ResizablePMCArray"
    push $P575, $P574
    .return ($P575)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("137_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 292
    new $P582, "Undef"
    .lex "$*PACKAGE-SETUP", $P582
.annotate 'line', 293
    new $P583, "Undef"
    .lex "$*PKGDECL", $P583
.annotate 'line', 4
    .local string rx584_tgt
    .local int rx584_pos
    .local int rx584_off
    .local int rx584_eos
    .local int rx584_rep
    .local pmc rx584_cur
    .local pmc rx584_debug
    (rx584_cur, rx584_pos, rx584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx584_cur
    .local pmc match
    .lex "$/", match
    length rx584_eos, rx584_tgt
    gt rx584_pos, rx584_eos, rx584_done
    set rx584_off, 0
    lt rx584_pos, 2, rx584_start
    sub rx584_off, rx584_pos, 1
    substr rx584_tgt, rx584_tgt, rx584_off
  rx584_start:
    eq $I10, 1, rx584_restart
    if_null rx584_debug, debug_670
    rx584_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan588_done
    goto rxscan588_scan
  rxscan588_loop:
    (rx584_pos) = rx584_cur."from"()
    inc rx584_pos
    rx584_cur."!cursor_from"(rx584_pos)
    ge rx584_pos, rx584_eos, rxscan588_done
  rxscan588_scan:
    set_addr $I10, rxscan588_loop
    rx584_cur."!mark_push"(0, rx584_pos, $I10)
  rxscan588_done:
.annotate 'line', 292
    rx584_cur."!cursor_pos"(rx584_pos)
    get_hll_global $P589, ["PAST"], "Stmts"
    $P590 = $P589."new"()
    store_lex "$*PACKAGE-SETUP", $P590
.annotate 'line', 293
    rx584_cur."!cursor_pos"(rx584_pos)
    new $P591, "String"
    assign $P591, "knowhow"
    store_lex "$*PKGDECL", $P591
.annotate 'line', 294
  # rx subcapture "sym"
    set_addr $I10, rxcap_592_fail
    rx584_cur."!mark_push"(0, rx584_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx584_pos, 7
    gt $I11, rx584_eos, rx584_fail
    sub $I11, rx584_pos, rx584_off
    substr $S10, rx584_tgt, $I11, 7
    ne $S10, "knowhow", rx584_fail
    add rx584_pos, 7
    set_addr $I10, rxcap_592_fail
    ($I12, $I11) = rx584_cur."!mark_peek"($I10)
    rx584_cur."!cursor_pos"($I11)
    ($P10) = rx584_cur."!cursor_start"()
    $P10."!cursor_pass"(rx584_pos, "")
    rx584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_592_done
  rxcap_592_fail:
    goto rx584_fail
  rxcap_592_done:
  # rx subrule "package_def" subtype=capture negate=
    rx584_cur."!cursor_pos"(rx584_pos)
    $P10 = rx584_cur."package_def"()
    unless $P10, rx584_fail
    rx584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx584_pos = $P10."pos"()
.annotate 'line', 291
  # rx pass
    rx584_cur."!cursor_pass"(rx584_pos, "package_declarator:sym<knowhow>")
    if_null rx584_debug, debug_671
    rx584_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx584_pos)
  debug_671:
    .return (rx584_cur)
  rx584_restart:
.annotate 'line', 4
    if_null rx584_debug, debug_672
    rx584_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_672:
  rx584_fail:
    (rx584_rep, rx584_pos, $I10, $P10) = rx584_cur."!mark_fail"(0)
    lt rx584_pos, -1, rx584_done
    eq rx584_pos, -1, rx584_fail
    jump $I10
  rx584_done:
    rx584_cur."!cursor_fail"()
    if_null rx584_debug, debug_673
    rx584_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_673:
    .return (rx584_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("138_1298839231.515") :method
.annotate 'line', 4
    $P586 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P587, "ResizablePMCArray"
    push $P587, $P586
    .return ($P587)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("139_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 297
    new $P594, "Undef"
    .lex "$*PACKAGE-SETUP", $P594
.annotate 'line', 298
    new $P595, "Undef"
    .lex "$*PKGDECL", $P595
.annotate 'line', 4
    .local string rx596_tgt
    .local int rx596_pos
    .local int rx596_off
    .local int rx596_eos
    .local int rx596_rep
    .local pmc rx596_cur
    .local pmc rx596_debug
    (rx596_cur, rx596_pos, rx596_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx596_cur
    .local pmc match
    .lex "$/", match
    length rx596_eos, rx596_tgt
    gt rx596_pos, rx596_eos, rx596_done
    set rx596_off, 0
    lt rx596_pos, 2, rx596_start
    sub rx596_off, rx596_pos, 1
    substr rx596_tgt, rx596_tgt, rx596_off
  rx596_start:
    eq $I10, 1, rx596_restart
    if_null rx596_debug, debug_674
    rx596_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan600_done
    goto rxscan600_scan
  rxscan600_loop:
    (rx596_pos) = rx596_cur."from"()
    inc rx596_pos
    rx596_cur."!cursor_from"(rx596_pos)
    ge rx596_pos, rx596_eos, rxscan600_done
  rxscan600_scan:
    set_addr $I10, rxscan600_loop
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  rxscan600_done:
.annotate 'line', 297
    rx596_cur."!cursor_pos"(rx596_pos)
    get_hll_global $P601, ["PAST"], "Stmts"
    $P602 = $P601."new"()
    store_lex "$*PACKAGE-SETUP", $P602
.annotate 'line', 298
    rx596_cur."!cursor_pos"(rx596_pos)
    new $P603, "String"
    assign $P603, "class"
    store_lex "$*PKGDECL", $P603
.annotate 'line', 299
  # rx subcapture "sym"
    set_addr $I10, rxcap_604_fail
    rx596_cur."!mark_push"(0, rx596_pos, $I10)
  # rx literal  "class"
    add $I11, rx596_pos, 5
    gt $I11, rx596_eos, rx596_fail
    sub $I11, rx596_pos, rx596_off
    substr $S10, rx596_tgt, $I11, 5
    ne $S10, "class", rx596_fail
    add rx596_pos, 5
    set_addr $I10, rxcap_604_fail
    ($I12, $I11) = rx596_cur."!mark_peek"($I10)
    rx596_cur."!cursor_pos"($I11)
    ($P10) = rx596_cur."!cursor_start"()
    $P10."!cursor_pass"(rx596_pos, "")
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_604_done
  rxcap_604_fail:
    goto rx596_fail
  rxcap_604_done:
  # rx subrule "package_def" subtype=capture negate=
    rx596_cur."!cursor_pos"(rx596_pos)
    $P10 = rx596_cur."package_def"()
    unless $P10, rx596_fail
    rx596_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx596_pos = $P10."pos"()
.annotate 'line', 296
  # rx pass
    rx596_cur."!cursor_pass"(rx596_pos, "package_declarator:sym<class>")
    if_null rx596_debug, debug_675
    rx596_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx596_pos)
  debug_675:
    .return (rx596_cur)
  rx596_restart:
.annotate 'line', 4
    if_null rx596_debug, debug_676
    rx596_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_676:
  rx596_fail:
    (rx596_rep, rx596_pos, $I10, $P10) = rx596_cur."!mark_fail"(0)
    lt rx596_pos, -1, rx596_done
    eq rx596_pos, -1, rx596_fail
    jump $I10
  rx596_done:
    rx596_cur."!cursor_fail"()
    if_null rx596_debug, debug_677
    rx596_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_677:
    .return (rx596_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("140_1298839231.515") :method
.annotate 'line', 4
    $P598 = self."!PREFIX__!subrule"("package_def", "class")
    new $P599, "ResizablePMCArray"
    push $P599, $P598
    .return ($P599)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("141_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 302
    new $P606, "Undef"
    .lex "$*PACKAGE-SETUP", $P606
.annotate 'line', 303
    new $P607, "Undef"
    .lex "$*PKGDECL", $P607
.annotate 'line', 4
    .local string rx608_tgt
    .local int rx608_pos
    .local int rx608_off
    .local int rx608_eos
    .local int rx608_rep
    .local pmc rx608_cur
    .local pmc rx608_debug
    (rx608_cur, rx608_pos, rx608_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx608_cur
    .local pmc match
    .lex "$/", match
    length rx608_eos, rx608_tgt
    gt rx608_pos, rx608_eos, rx608_done
    set rx608_off, 0
    lt rx608_pos, 2, rx608_start
    sub rx608_off, rx608_pos, 1
    substr rx608_tgt, rx608_tgt, rx608_off
  rx608_start:
    eq $I10, 1, rx608_restart
    if_null rx608_debug, debug_678
    rx608_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan612_done
    goto rxscan612_scan
  rxscan612_loop:
    (rx608_pos) = rx608_cur."from"()
    inc rx608_pos
    rx608_cur."!cursor_from"(rx608_pos)
    ge rx608_pos, rx608_eos, rxscan612_done
  rxscan612_scan:
    set_addr $I10, rxscan612_loop
    rx608_cur."!mark_push"(0, rx608_pos, $I10)
  rxscan612_done:
.annotate 'line', 302
    rx608_cur."!cursor_pos"(rx608_pos)
    get_hll_global $P613, ["PAST"], "Stmts"
    $P614 = $P613."new"()
    store_lex "$*PACKAGE-SETUP", $P614
.annotate 'line', 303
    rx608_cur."!cursor_pos"(rx608_pos)
    new $P615, "String"
    assign $P615, "grammar"
    store_lex "$*PKGDECL", $P615
.annotate 'line', 304
  # rx subcapture "sym"
    set_addr $I10, rxcap_616_fail
    rx608_cur."!mark_push"(0, rx608_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx608_pos, 7
    gt $I11, rx608_eos, rx608_fail
    sub $I11, rx608_pos, rx608_off
    substr $S10, rx608_tgt, $I11, 7
    ne $S10, "grammar", rx608_fail
    add rx608_pos, 7
    set_addr $I10, rxcap_616_fail
    ($I12, $I11) = rx608_cur."!mark_peek"($I10)
    rx608_cur."!cursor_pos"($I11)
    ($P10) = rx608_cur."!cursor_start"()
    $P10."!cursor_pass"(rx608_pos, "")
    rx608_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_616_done
  rxcap_616_fail:
    goto rx608_fail
  rxcap_616_done:
  # rx subrule "package_def" subtype=capture negate=
    rx608_cur."!cursor_pos"(rx608_pos)
    $P10 = rx608_cur."package_def"()
    unless $P10, rx608_fail
    rx608_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx608_pos = $P10."pos"()
.annotate 'line', 301
  # rx pass
    rx608_cur."!cursor_pass"(rx608_pos, "package_declarator:sym<grammar>")
    if_null rx608_debug, debug_679
    rx608_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx608_pos)
  debug_679:
    .return (rx608_cur)
  rx608_restart:
.annotate 'line', 4
    if_null rx608_debug, debug_680
    rx608_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_680:
  rx608_fail:
    (rx608_rep, rx608_pos, $I10, $P10) = rx608_cur."!mark_fail"(0)
    lt rx608_pos, -1, rx608_done
    eq rx608_pos, -1, rx608_fail
    jump $I10
  rx608_done:
    rx608_cur."!cursor_fail"()
    if_null rx608_debug, debug_681
    rx608_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_681:
    .return (rx608_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("142_1298839231.515") :method
.annotate 'line', 4
    $P610 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P611, "ResizablePMCArray"
    push $P611, $P610
    .return ($P611)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("143_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 307
    new $P618, "Undef"
    .lex "$*PACKAGE-SETUP", $P618
.annotate 'line', 308
    new $P619, "Undef"
    .lex "$*PKGDECL", $P619
.annotate 'line', 4
    .local string rx620_tgt
    .local int rx620_pos
    .local int rx620_off
    .local int rx620_eos
    .local int rx620_rep
    .local pmc rx620_cur
    .local pmc rx620_debug
    (rx620_cur, rx620_pos, rx620_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx620_cur
    .local pmc match
    .lex "$/", match
    length rx620_eos, rx620_tgt
    gt rx620_pos, rx620_eos, rx620_done
    set rx620_off, 0
    lt rx620_pos, 2, rx620_start
    sub rx620_off, rx620_pos, 1
    substr rx620_tgt, rx620_tgt, rx620_off
  rx620_start:
    eq $I10, 1, rx620_restart
    if_null rx620_debug, debug_682
    rx620_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan624_done
    goto rxscan624_scan
  rxscan624_loop:
    (rx620_pos) = rx620_cur."from"()
    inc rx620_pos
    rx620_cur."!cursor_from"(rx620_pos)
    ge rx620_pos, rx620_eos, rxscan624_done
  rxscan624_scan:
    set_addr $I10, rxscan624_loop
    rx620_cur."!mark_push"(0, rx620_pos, $I10)
  rxscan624_done:
.annotate 'line', 307
    rx620_cur."!cursor_pos"(rx620_pos)
    get_hll_global $P625, ["PAST"], "Stmts"
    $P626 = $P625."new"()
    store_lex "$*PACKAGE-SETUP", $P626
.annotate 'line', 308
    rx620_cur."!cursor_pos"(rx620_pos)
    new $P627, "String"
    assign $P627, "role"
    store_lex "$*PKGDECL", $P627
.annotate 'line', 309
  # rx subcapture "sym"
    set_addr $I10, rxcap_628_fail
    rx620_cur."!mark_push"(0, rx620_pos, $I10)
  # rx literal  "role"
    add $I11, rx620_pos, 4
    gt $I11, rx620_eos, rx620_fail
    sub $I11, rx620_pos, rx620_off
    substr $S10, rx620_tgt, $I11, 4
    ne $S10, "role", rx620_fail
    add rx620_pos, 4
    set_addr $I10, rxcap_628_fail
    ($I12, $I11) = rx620_cur."!mark_peek"($I10)
    rx620_cur."!cursor_pos"($I11)
    ($P10) = rx620_cur."!cursor_start"()
    $P10."!cursor_pass"(rx620_pos, "")
    rx620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_628_done
  rxcap_628_fail:
    goto rx620_fail
  rxcap_628_done:
  # rx subrule "package_def" subtype=capture negate=
    rx620_cur."!cursor_pos"(rx620_pos)
    $P10 = rx620_cur."package_def"()
    unless $P10, rx620_fail
    rx620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx620_pos = $P10."pos"()
.annotate 'line', 306
  # rx pass
    rx620_cur."!cursor_pass"(rx620_pos, "package_declarator:sym<role>")
    if_null rx620_debug, debug_683
    rx620_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx620_pos)
  debug_683:
    .return (rx620_cur)
  rx620_restart:
.annotate 'line', 4
    if_null rx620_debug, debug_684
    rx620_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_684:
  rx620_fail:
    (rx620_rep, rx620_pos, $I10, $P10) = rx620_cur."!mark_fail"(0)
    lt rx620_pos, -1, rx620_done
    eq rx620_pos, -1, rx620_fail
    jump $I10
  rx620_done:
    rx620_cur."!cursor_fail"()
    if_null rx620_debug, debug_685
    rx620_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_685:
    .return (rx620_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("144_1298839231.515") :method
.annotate 'line', 4
    $P622 = self."!PREFIX__!subrule"("package_def", "role")
    new $P623, "ResizablePMCArray"
    push $P623, $P622
    .return ($P623)
.end


.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("145_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 312
    new $P630, "Undef"
    .lex "$*PACKAGE-SETUP", $P630
.annotate 'line', 313
    new $P631, "Undef"
    .lex "$*PKGDECL", $P631
.annotate 'line', 4
    .local string rx632_tgt
    .local int rx632_pos
    .local int rx632_off
    .local int rx632_eos
    .local int rx632_rep
    .local pmc rx632_cur
    .local pmc rx632_debug
    (rx632_cur, rx632_pos, rx632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx632_cur
    .local pmc match
    .lex "$/", match
    length rx632_eos, rx632_tgt
    gt rx632_pos, rx632_eos, rx632_done
    set rx632_off, 0
    lt rx632_pos, 2, rx632_start
    sub rx632_off, rx632_pos, 1
    substr rx632_tgt, rx632_tgt, rx632_off
  rx632_start:
    eq $I10, 1, rx632_restart
    if_null rx632_debug, debug_686
    rx632_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan636_done
    goto rxscan636_scan
  rxscan636_loop:
    (rx632_pos) = rx632_cur."from"()
    inc rx632_pos
    rx632_cur."!cursor_from"(rx632_pos)
    ge rx632_pos, rx632_eos, rxscan636_done
  rxscan636_scan:
    set_addr $I10, rxscan636_loop
    rx632_cur."!mark_push"(0, rx632_pos, $I10)
  rxscan636_done:
.annotate 'line', 312
    rx632_cur."!cursor_pos"(rx632_pos)
    get_hll_global $P637, ["PAST"], "Stmts"
    $P638 = $P637."new"()
    store_lex "$*PACKAGE-SETUP", $P638
.annotate 'line', 313
    rx632_cur."!cursor_pos"(rx632_pos)
    new $P639, "String"
    assign $P639, "native"
    store_lex "$*PKGDECL", $P639
.annotate 'line', 314
  # rx subcapture "sym"
    set_addr $I10, rxcap_640_fail
    rx632_cur."!mark_push"(0, rx632_pos, $I10)
  # rx literal  "native"
    add $I11, rx632_pos, 6
    gt $I11, rx632_eos, rx632_fail
    sub $I11, rx632_pos, rx632_off
    substr $S10, rx632_tgt, $I11, 6
    ne $S10, "native", rx632_fail
    add rx632_pos, 6
    set_addr $I10, rxcap_640_fail
    ($I12, $I11) = rx632_cur."!mark_peek"($I10)
    rx632_cur."!cursor_pos"($I11)
    ($P10) = rx632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx632_pos, "")
    rx632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_640_done
  rxcap_640_fail:
    goto rx632_fail
  rxcap_640_done:
  # rx subrule "package_def" subtype=capture negate=
    rx632_cur."!cursor_pos"(rx632_pos)
    $P10 = rx632_cur."package_def"()
    unless $P10, rx632_fail
    rx632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx632_pos = $P10."pos"()
.annotate 'line', 311
  # rx pass
    rx632_cur."!cursor_pass"(rx632_pos, "package_declarator:sym<native>")
    if_null rx632_debug, debug_687
    rx632_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx632_pos)
  debug_687:
    .return (rx632_cur)
  rx632_restart:
.annotate 'line', 4
    if_null rx632_debug, debug_688
    rx632_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_688:
  rx632_fail:
    (rx632_rep, rx632_pos, $I10, $P10) = rx632_cur."!mark_fail"(0)
    lt rx632_pos, -1, rx632_done
    eq rx632_pos, -1, rx632_fail
    jump $I10
  rx632_done:
    rx632_cur."!cursor_fail"()
    if_null rx632_debug, debug_689
    rx632_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_689:
    .return (rx632_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("146_1298839231.515") :method
.annotate 'line', 4
    $P634 = self."!PREFIX__!subrule"("package_def", "native")
    new $P635, "ResizablePMCArray"
    push $P635, $P634
    .return ($P635)
.end


.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("147_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx642_tgt
    .local int rx642_pos
    .local int rx642_off
    .local int rx642_eos
    .local int rx642_rep
    .local pmc rx642_cur
    .local pmc rx642_debug
    (rx642_cur, rx642_pos, rx642_tgt, $I10) = self."!cursor_start"()
    rx642_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx642_cur
    .local pmc match
    .lex "$/", match
    length rx642_eos, rx642_tgt
    gt rx642_pos, rx642_eos, rx642_done
    set rx642_off, 0
    lt rx642_pos, 2, rx642_start
    sub rx642_off, rx642_pos, 1
    substr rx642_tgt, rx642_tgt, rx642_off
  rx642_start:
    eq $I10, 1, rx642_restart
    if_null rx642_debug, debug_690
    rx642_cur."!cursor_debug"("START", "package_def")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan646_done
    goto rxscan646_scan
  rxscan646_loop:
    (rx642_pos) = rx642_cur."from"()
    inc rx642_pos
    rx642_cur."!cursor_from"(rx642_pos)
    ge rx642_pos, rx642_eos, rxscan646_done
  rxscan646_scan:
    set_addr $I10, rxscan646_loop
    rx642_cur."!mark_push"(0, rx642_pos, $I10)
  rxscan646_done:
.annotate 'line', 317
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
.annotate 'line', 318
  # rx subrule "name" subtype=capture negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."name"()
    unless $P10, rx642_fail
    rx642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx642_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
.annotate 'line', 319
  # rx rxquantr649 ** 0..1
    set_addr $I10, rxquantr649_done
    rx642_cur."!mark_push"(0, rx642_pos, $I10)
  rxquantr649_loop:
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx642_pos, 2
    gt $I11, rx642_eos, rx642_fail
    sub $I11, rx642_pos, rx642_off
    substr $S10, rx642_tgt, $I11, 2
    ne $S10, "is", rx642_fail
    add rx642_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx642_pos, 5
    gt $I11, rx642_eos, rx642_fail
    sub $I11, rx642_pos, rx642_off
    substr $S10, rx642_tgt, $I11, 5
    ne $S10, "repr(", rx642_fail
    add rx642_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."quote_EXPR"()
    unless $P10, rx642_fail
    rx642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx642_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx642_pos, 1
    gt $I11, rx642_eos, rx642_fail
    sub $I11, rx642_pos, rx642_off
    ord $I11, rx642_tgt, $I11
    ne $I11, 41, rx642_fail
    add rx642_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
    set_addr $I10, rxquantr649_done
    (rx642_rep) = rx642_cur."!mark_commit"($I10)
  rxquantr649_done:
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
.annotate 'line', 320
  # rx rxquantr656 ** 0..1
    set_addr $I10, rxquantr656_done
    rx642_cur."!mark_push"(0, rx642_pos, $I10)
  rxquantr656_loop:
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx642_pos, 2
    gt $I11, rx642_eos, rx642_fail
    sub $I11, rx642_pos, rx642_off
    substr $S10, rx642_tgt, $I11, 2
    ne $S10, "is", rx642_fail
    add rx642_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."name"()
    unless $P10, rx642_fail
    rx642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx642_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
    set_addr $I10, rxquantr656_done
    (rx642_rep) = rx642_cur."!mark_commit"($I10)
  rxquantr656_done:
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
.annotate 'line', 321
  # rx rxquantr661 ** 0..*
    set_addr $I10, rxquantr661_done
    rx642_cur."!mark_push"(0, rx642_pos, $I10)
  rxquantr661_loop:
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx642_pos, 4
    gt $I11, rx642_eos, rx642_fail
    sub $I11, rx642_pos, rx642_off
    substr $S10, rx642_tgt, $I11, 4
    ne $S10, "does", rx642_fail
    add rx642_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."name"()
    unless $P10, rx642_fail
    rx642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx642_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
    set_addr $I10, rxquantr661_done
    (rx642_rep) = rx642_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr661_done
    rx642_cur."!mark_push"(rx642_rep, rx642_pos, $I10)
    goto rxquantr661_loop
  rxquantr661_done:
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  alt666_0:
.annotate 'line', 322
    set_addr $I10, alt666_1
    rx642_cur."!mark_push"(0, rx642_pos, $I10)
.annotate 'line', 323
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx642_pos, 1
    gt $I11, rx642_eos, rx642_fail
    sub $I11, rx642_pos, rx642_off
    ord $I11, rx642_tgt, $I11
    ne $I11, 59, rx642_fail
    add rx642_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."comp_unit"()
    unless $P10, rx642_fail
    rx642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx642_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
    goto alt666_end
  alt666_1:
    set_addr $I10, alt666_2
    rx642_cur."!mark_push"(0, rx642_pos, $I10)
.annotate 'line', 324
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx642_pos, rx642_off
    substr $S10, rx642_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx642_fail
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."block"()
    unless $P10, rx642_fail
    rx642_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx642_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
    goto alt666_end
  alt666_2:
.annotate 'line', 325
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."panic"("Malformed package declaration")
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
  alt666_end:
.annotate 'line', 326
  # rx subrule "ws" subtype=method negate=
    rx642_cur."!cursor_pos"(rx642_pos)
    $P10 = rx642_cur."ws"()
    unless $P10, rx642_fail
    rx642_pos = $P10."pos"()
.annotate 'line', 317
  # rx pass
    rx642_cur."!cursor_pass"(rx642_pos, "package_def")
    if_null rx642_debug, debug_691
    rx642_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx642_pos)
  debug_691:
    .return (rx642_cur)
  rx642_restart:
.annotate 'line', 4
    if_null rx642_debug, debug_692
    rx642_cur."!cursor_debug"("NEXT", "package_def")
  debug_692:
  rx642_fail:
    (rx642_rep, rx642_pos, $I10, $P10) = rx642_cur."!mark_fail"(0)
    lt rx642_pos, -1, rx642_done
    eq rx642_pos, -1, rx642_fail
    jump $I10
  rx642_done:
    rx642_cur."!cursor_fail"()
    if_null rx642_debug, debug_693
    rx642_cur."!cursor_debug"("FAIL", "package_def")
  debug_693:
    .return (rx642_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("148_1298839231.515") :method
.annotate 'line', 4
    $P644 = self."!PREFIX__!subrule"("ws", "")
    new $P645, "ResizablePMCArray"
    push $P645, $P644
    .return ($P645)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("149_1298839231.515")
    .param pmc param_677
.annotate 'line', 329
    .lex "self", param_677
    $P678 = param_677."!protoregex"("scope_declarator")
    .return ($P678)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("150_1298839231.515")
    .param pmc param_680
.annotate 'line', 329
    .lex "self", param_680
    $P681 = param_680."!PREFIX__!protoregex"("scope_declarator")
    .return ($P681)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("151_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx683_tgt
    .local int rx683_pos
    .local int rx683_off
    .local int rx683_eos
    .local int rx683_rep
    .local pmc rx683_cur
    .local pmc rx683_debug
    (rx683_cur, rx683_pos, rx683_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx683_cur
    .local pmc match
    .lex "$/", match
    length rx683_eos, rx683_tgt
    gt rx683_pos, rx683_eos, rx683_done
    set rx683_off, 0
    lt rx683_pos, 2, rx683_start
    sub rx683_off, rx683_pos, 1
    substr rx683_tgt, rx683_tgt, rx683_off
  rx683_start:
    eq $I10, 1, rx683_restart
    if_null rx683_debug, debug_694
    rx683_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan687_done
    goto rxscan687_scan
  rxscan687_loop:
    (rx683_pos) = rx683_cur."from"()
    inc rx683_pos
    rx683_cur."!cursor_from"(rx683_pos)
    ge rx683_pos, rx683_eos, rxscan687_done
  rxscan687_scan:
    set_addr $I10, rxscan687_loop
    rx683_cur."!mark_push"(0, rx683_pos, $I10)
  rxscan687_done:
.annotate 'line', 330
  # rx subcapture "sym"
    set_addr $I10, rxcap_688_fail
    rx683_cur."!mark_push"(0, rx683_pos, $I10)
  # rx literal  "my"
    add $I11, rx683_pos, 2
    gt $I11, rx683_eos, rx683_fail
    sub $I11, rx683_pos, rx683_off
    substr $S10, rx683_tgt, $I11, 2
    ne $S10, "my", rx683_fail
    add rx683_pos, 2
    set_addr $I10, rxcap_688_fail
    ($I12, $I11) = rx683_cur."!mark_peek"($I10)
    rx683_cur."!cursor_pos"($I11)
    ($P10) = rx683_cur."!cursor_start"()
    $P10."!cursor_pass"(rx683_pos, "")
    rx683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_688_done
  rxcap_688_fail:
    goto rx683_fail
  rxcap_688_done:
  # rx subrule "scoped" subtype=capture negate=
    rx683_cur."!cursor_pos"(rx683_pos)
    $P10 = rx683_cur."scoped"("my")
    unless $P10, rx683_fail
    rx683_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx683_pos = $P10."pos"()
  # rx pass
    rx683_cur."!cursor_pass"(rx683_pos, "scope_declarator:sym<my>")
    if_null rx683_debug, debug_695
    rx683_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx683_pos)
  debug_695:
    .return (rx683_cur)
  rx683_restart:
.annotate 'line', 4
    if_null rx683_debug, debug_696
    rx683_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_696:
  rx683_fail:
    (rx683_rep, rx683_pos, $I10, $P10) = rx683_cur."!mark_fail"(0)
    lt rx683_pos, -1, rx683_done
    eq rx683_pos, -1, rx683_fail
    jump $I10
  rx683_done:
    rx683_cur."!cursor_fail"()
    if_null rx683_debug, debug_697
    rx683_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_697:
    .return (rx683_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("152_1298839231.515") :method
.annotate 'line', 4
    $P685 = self."!PREFIX__!subrule"("scoped", "my")
    new $P686, "ResizablePMCArray"
    push $P686, $P685
    .return ($P686)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("153_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx690_tgt
    .local int rx690_pos
    .local int rx690_off
    .local int rx690_eos
    .local int rx690_rep
    .local pmc rx690_cur
    .local pmc rx690_debug
    (rx690_cur, rx690_pos, rx690_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx690_cur
    .local pmc match
    .lex "$/", match
    length rx690_eos, rx690_tgt
    gt rx690_pos, rx690_eos, rx690_done
    set rx690_off, 0
    lt rx690_pos, 2, rx690_start
    sub rx690_off, rx690_pos, 1
    substr rx690_tgt, rx690_tgt, rx690_off
  rx690_start:
    eq $I10, 1, rx690_restart
    if_null rx690_debug, debug_698
    rx690_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan694_done
    goto rxscan694_scan
  rxscan694_loop:
    (rx690_pos) = rx690_cur."from"()
    inc rx690_pos
    rx690_cur."!cursor_from"(rx690_pos)
    ge rx690_pos, rx690_eos, rxscan694_done
  rxscan694_scan:
    set_addr $I10, rxscan694_loop
    rx690_cur."!mark_push"(0, rx690_pos, $I10)
  rxscan694_done:
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_695_fail
    rx690_cur."!mark_push"(0, rx690_pos, $I10)
  # rx literal  "our"
    add $I11, rx690_pos, 3
    gt $I11, rx690_eos, rx690_fail
    sub $I11, rx690_pos, rx690_off
    substr $S10, rx690_tgt, $I11, 3
    ne $S10, "our", rx690_fail
    add rx690_pos, 3
    set_addr $I10, rxcap_695_fail
    ($I12, $I11) = rx690_cur."!mark_peek"($I10)
    rx690_cur."!cursor_pos"($I11)
    ($P10) = rx690_cur."!cursor_start"()
    $P10."!cursor_pass"(rx690_pos, "")
    rx690_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_695_done
  rxcap_695_fail:
    goto rx690_fail
  rxcap_695_done:
  # rx subrule "scoped" subtype=capture negate=
    rx690_cur."!cursor_pos"(rx690_pos)
    $P10 = rx690_cur."scoped"("our")
    unless $P10, rx690_fail
    rx690_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx690_pos = $P10."pos"()
  # rx pass
    rx690_cur."!cursor_pass"(rx690_pos, "scope_declarator:sym<our>")
    if_null rx690_debug, debug_699
    rx690_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx690_pos)
  debug_699:
    .return (rx690_cur)
  rx690_restart:
.annotate 'line', 4
    if_null rx690_debug, debug_700
    rx690_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_700:
  rx690_fail:
    (rx690_rep, rx690_pos, $I10, $P10) = rx690_cur."!mark_fail"(0)
    lt rx690_pos, -1, rx690_done
    eq rx690_pos, -1, rx690_fail
    jump $I10
  rx690_done:
    rx690_cur."!cursor_fail"()
    if_null rx690_debug, debug_701
    rx690_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_701:
    .return (rx690_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("154_1298839231.515") :method
.annotate 'line', 4
    $P692 = self."!PREFIX__!subrule"("scoped", "our")
    new $P693, "ResizablePMCArray"
    push $P693, $P692
    .return ($P693)
.end


.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("155_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx697_tgt
    .local int rx697_pos
    .local int rx697_off
    .local int rx697_eos
    .local int rx697_rep
    .local pmc rx697_cur
    .local pmc rx697_debug
    (rx697_cur, rx697_pos, rx697_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx697_cur
    .local pmc match
    .lex "$/", match
    length rx697_eos, rx697_tgt
    gt rx697_pos, rx697_eos, rx697_done
    set rx697_off, 0
    lt rx697_pos, 2, rx697_start
    sub rx697_off, rx697_pos, 1
    substr rx697_tgt, rx697_tgt, rx697_off
  rx697_start:
    eq $I10, 1, rx697_restart
    if_null rx697_debug, debug_702
    rx697_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan701_done
    goto rxscan701_scan
  rxscan701_loop:
    (rx697_pos) = rx697_cur."from"()
    inc rx697_pos
    rx697_cur."!cursor_from"(rx697_pos)
    ge rx697_pos, rx697_eos, rxscan701_done
  rxscan701_scan:
    set_addr $I10, rxscan701_loop
    rx697_cur."!mark_push"(0, rx697_pos, $I10)
  rxscan701_done:
.annotate 'line', 332
  # rx subcapture "sym"
    set_addr $I10, rxcap_702_fail
    rx697_cur."!mark_push"(0, rx697_pos, $I10)
  # rx literal  "has"
    add $I11, rx697_pos, 3
    gt $I11, rx697_eos, rx697_fail
    sub $I11, rx697_pos, rx697_off
    substr $S10, rx697_tgt, $I11, 3
    ne $S10, "has", rx697_fail
    add rx697_pos, 3
    set_addr $I10, rxcap_702_fail
    ($I12, $I11) = rx697_cur."!mark_peek"($I10)
    rx697_cur."!cursor_pos"($I11)
    ($P10) = rx697_cur."!cursor_start"()
    $P10."!cursor_pass"(rx697_pos, "")
    rx697_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_702_done
  rxcap_702_fail:
    goto rx697_fail
  rxcap_702_done:
  # rx subrule "scoped" subtype=capture negate=
    rx697_cur."!cursor_pos"(rx697_pos)
    $P10 = rx697_cur."scoped"("has")
    unless $P10, rx697_fail
    rx697_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx697_pos = $P10."pos"()
  # rx pass
    rx697_cur."!cursor_pass"(rx697_pos, "scope_declarator:sym<has>")
    if_null rx697_debug, debug_703
    rx697_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx697_pos)
  debug_703:
    .return (rx697_cur)
  rx697_restart:
.annotate 'line', 4
    if_null rx697_debug, debug_704
    rx697_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_704:
  rx697_fail:
    (rx697_rep, rx697_pos, $I10, $P10) = rx697_cur."!mark_fail"(0)
    lt rx697_pos, -1, rx697_done
    eq rx697_pos, -1, rx697_fail
    jump $I10
  rx697_done:
    rx697_cur."!cursor_fail"()
    if_null rx697_debug, debug_705
    rx697_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_705:
    .return (rx697_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("156_1298839231.515") :method
.annotate 'line', 4
    $P699 = self."!PREFIX__!subrule"("scoped", "has")
    new $P700, "ResizablePMCArray"
    push $P700, $P699
    .return ($P700)
.end


.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("157_1298839231.515") :method :outer("11_1298839231.515")
    .param pmc param_704
.annotate 'line', 334
    .lex "$*SCOPE", param_704
.annotate 'line', 4
    .local string rx705_tgt
    .local int rx705_pos
    .local int rx705_off
    .local int rx705_eos
    .local int rx705_rep
    .local pmc rx705_cur
    .local pmc rx705_debug
    (rx705_cur, rx705_pos, rx705_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx705_cur
    .local pmc match
    .lex "$/", match
    length rx705_eos, rx705_tgt
    gt rx705_pos, rx705_eos, rx705_done
    set rx705_off, 0
    lt rx705_pos, 2, rx705_start
    sub rx705_off, rx705_pos, 1
    substr rx705_tgt, rx705_tgt, rx705_off
  rx705_start:
    eq $I10, 1, rx705_restart
    if_null rx705_debug, debug_706
    rx705_cur."!cursor_debug"("START", "scoped")
  debug_706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan710_done
    goto rxscan710_scan
  rxscan710_loop:
    (rx705_pos) = rx705_cur."from"()
    inc rx705_pos
    rx705_cur."!cursor_from"(rx705_pos)
    ge rx705_pos, rx705_eos, rxscan710_done
  rxscan710_scan:
    set_addr $I10, rxscan710_loop
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
  rxscan710_done:
  alt711_0:
.annotate 'line', 334
    set_addr $I10, alt711_1
    rx705_cur."!mark_push"(0, rx705_pos, $I10)
.annotate 'line', 335
  # rx subrule "ws" subtype=method negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."ws"()
    unless $P10, rx705_fail
    rx705_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."declarator"()
    unless $P10, rx705_fail
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx705_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."ws"()
    unless $P10, rx705_fail
    rx705_pos = $P10."pos"()
    goto alt711_end
  alt711_1:
.annotate 'line', 336
  # rx subrule "ws" subtype=method negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."ws"()
    unless $P10, rx705_fail
    rx705_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."multi_declarator"()
    unless $P10, rx705_fail
    rx705_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx705_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx705_cur."!cursor_pos"(rx705_pos)
    $P10 = rx705_cur."ws"()
    unless $P10, rx705_fail
    rx705_pos = $P10."pos"()
  alt711_end:
.annotate 'line', 334
  # rx pass
    rx705_cur."!cursor_pass"(rx705_pos, "scoped")
    if_null rx705_debug, debug_707
    rx705_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx705_pos)
  debug_707:
    .return (rx705_cur)
  rx705_restart:
.annotate 'line', 4
    if_null rx705_debug, debug_708
    rx705_cur."!cursor_debug"("NEXT", "scoped")
  debug_708:
  rx705_fail:
    (rx705_rep, rx705_pos, $I10, $P10) = rx705_cur."!mark_fail"(0)
    lt rx705_pos, -1, rx705_done
    eq rx705_pos, -1, rx705_fail
    jump $I10
  rx705_done:
    rx705_cur."!cursor_fail"()
    if_null rx705_debug, debug_709
    rx705_cur."!cursor_debug"("FAIL", "scoped")
  debug_709:
    .return (rx705_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("158_1298839231.515") :method
.annotate 'line', 4
    $P707 = self."!PREFIX__!subrule"("ws", "")
    $P708 = self."!PREFIX__!subrule"("ws", "")
    new $P709, "ResizablePMCArray"
    push $P709, $P707
    push $P709, $P708
    .return ($P709)
.end


.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("159_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx717_tgt
    .local int rx717_pos
    .local int rx717_off
    .local int rx717_eos
    .local int rx717_rep
    .local pmc rx717_cur
    .local pmc rx717_debug
    (rx717_cur, rx717_pos, rx717_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx717_cur
    .local pmc match
    .lex "$/", match
    length rx717_eos, rx717_tgt
    gt rx717_pos, rx717_eos, rx717_done
    set rx717_off, 0
    lt rx717_pos, 2, rx717_start
    sub rx717_off, rx717_pos, 1
    substr rx717_tgt, rx717_tgt, rx717_off
  rx717_start:
    eq $I10, 1, rx717_restart
    if_null rx717_debug, debug_710
    rx717_cur."!cursor_debug"("START", "typename")
  debug_710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan721_done
    goto rxscan721_scan
  rxscan721_loop:
    (rx717_pos) = rx717_cur."from"()
    inc rx717_pos
    rx717_cur."!cursor_from"(rx717_pos)
    ge rx717_pos, rx717_eos, rxscan721_done
  rxscan721_scan:
    set_addr $I10, rxscan721_loop
    rx717_cur."!mark_push"(0, rx717_pos, $I10)
  rxscan721_done:
.annotate 'line', 339
  # rx subrule "name" subtype=capture negate=
    rx717_cur."!cursor_pos"(rx717_pos)
    $P10 = rx717_cur."name"()
    unless $P10, rx717_fail
    rx717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx717_pos = $P10."pos"()
  # rx pass
    rx717_cur."!cursor_pass"(rx717_pos, "typename")
    if_null rx717_debug, debug_711
    rx717_cur."!cursor_debug"("PASS", "typename", " at pos=", rx717_pos)
  debug_711:
    .return (rx717_cur)
  rx717_restart:
.annotate 'line', 4
    if_null rx717_debug, debug_712
    rx717_cur."!cursor_debug"("NEXT", "typename")
  debug_712:
  rx717_fail:
    (rx717_rep, rx717_pos, $I10, $P10) = rx717_cur."!mark_fail"(0)
    lt rx717_pos, -1, rx717_done
    eq rx717_pos, -1, rx717_fail
    jump $I10
  rx717_done:
    rx717_cur."!cursor_fail"()
    if_null rx717_debug, debug_713
    rx717_cur."!cursor_debug"("FAIL", "typename")
  debug_713:
    .return (rx717_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("160_1298839231.515") :method
.annotate 'line', 4
    $P719 = self."!PREFIX__!subrule"("name", "")
    new $P720, "ResizablePMCArray"
    push $P720, $P719
    .return ($P720)
.end


.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("161_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx723_tgt
    .local int rx723_pos
    .local int rx723_off
    .local int rx723_eos
    .local int rx723_rep
    .local pmc rx723_cur
    .local pmc rx723_debug
    (rx723_cur, rx723_pos, rx723_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx723_cur
    .local pmc match
    .lex "$/", match
    length rx723_eos, rx723_tgt
    gt rx723_pos, rx723_eos, rx723_done
    set rx723_off, 0
    lt rx723_pos, 2, rx723_start
    sub rx723_off, rx723_pos, 1
    substr rx723_tgt, rx723_tgt, rx723_off
  rx723_start:
    eq $I10, 1, rx723_restart
    if_null rx723_debug, debug_714
    rx723_cur."!cursor_debug"("START", "declarator")
  debug_714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan728_done
    goto rxscan728_scan
  rxscan728_loop:
    (rx723_pos) = rx723_cur."from"()
    inc rx723_pos
    rx723_cur."!cursor_from"(rx723_pos)
    ge rx723_pos, rx723_eos, rxscan728_done
  rxscan728_scan:
    set_addr $I10, rxscan728_loop
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
  rxscan728_done:
  alt729_0:
.annotate 'line', 341
    set_addr $I10, alt729_1
    rx723_cur."!mark_push"(0, rx723_pos, $I10)
.annotate 'line', 342
  # rx subrule "variable_declarator" subtype=capture negate=
    rx723_cur."!cursor_pos"(rx723_pos)
    $P10 = rx723_cur."variable_declarator"()
    unless $P10, rx723_fail
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx723_pos = $P10."pos"()
    goto alt729_end
  alt729_1:
.annotate 'line', 343
  # rx subrule "routine_declarator" subtype=capture negate=
    rx723_cur."!cursor_pos"(rx723_pos)
    $P10 = rx723_cur."routine_declarator"()
    unless $P10, rx723_fail
    rx723_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx723_pos = $P10."pos"()
  alt729_end:
.annotate 'line', 341
  # rx pass
    rx723_cur."!cursor_pass"(rx723_pos, "declarator")
    if_null rx723_debug, debug_715
    rx723_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx723_pos)
  debug_715:
    .return (rx723_cur)
  rx723_restart:
.annotate 'line', 4
    if_null rx723_debug, debug_716
    rx723_cur."!cursor_debug"("NEXT", "declarator")
  debug_716:
  rx723_fail:
    (rx723_rep, rx723_pos, $I10, $P10) = rx723_cur."!mark_fail"(0)
    lt rx723_pos, -1, rx723_done
    eq rx723_pos, -1, rx723_fail
    jump $I10
  rx723_done:
    rx723_cur."!cursor_fail"()
    if_null rx723_debug, debug_717
    rx723_cur."!cursor_debug"("FAIL", "declarator")
  debug_717:
    .return (rx723_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("162_1298839231.515") :method
.annotate 'line', 4
    $P725 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P726 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P727, "ResizablePMCArray"
    push $P727, $P725
    push $P727, $P726
    .return ($P727)
.end


.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("163_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx731_tgt
    .local int rx731_pos
    .local int rx731_off
    .local int rx731_eos
    .local int rx731_rep
    .local pmc rx731_cur
    .local pmc rx731_debug
    (rx731_cur, rx731_pos, rx731_tgt, $I10) = self."!cursor_start"()
    rx731_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx731_cur
    .local pmc match
    .lex "$/", match
    length rx731_eos, rx731_tgt
    gt rx731_pos, rx731_eos, rx731_done
    set rx731_off, 0
    lt rx731_pos, 2, rx731_start
    sub rx731_off, rx731_pos, 1
    substr rx731_tgt, rx731_tgt, rx731_off
  rx731_start:
    eq $I10, 1, rx731_restart
    if_null rx731_debug, debug_718
    rx731_cur."!cursor_debug"("START", "variable_declarator")
  debug_718:
    $I10 = self.'from'()
    ne $I10, -1, rxscan735_done
    goto rxscan735_scan
  rxscan735_loop:
    (rx731_pos) = rx731_cur."from"()
    inc rx731_pos
    rx731_cur."!cursor_from"(rx731_pos)
    ge rx731_pos, rx731_eos, rxscan735_done
  rxscan735_scan:
    set_addr $I10, rxscan735_loop
    rx731_cur."!mark_push"(0, rx731_pos, $I10)
  rxscan735_done:
.annotate 'line', 346
  # rx subrule "ws" subtype=method negate=
    rx731_cur."!cursor_pos"(rx731_pos)
    $P10 = rx731_cur."ws"()
    unless $P10, rx731_fail
    rx731_pos = $P10."pos"()
  # rx rxquantr737 ** 0..1
    set_addr $I10, rxquantr737_done
    rx731_cur."!mark_push"(0, rx731_pos, $I10)
  rxquantr737_loop:
  # rx subrule "typename" subtype=capture negate=
    rx731_cur."!cursor_pos"(rx731_pos)
    $P10 = rx731_cur."typename"()
    unless $P10, rx731_fail
    goto rxsubrule738_pass
  rxsubrule738_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx731_fail
  rxsubrule738_pass:
    set_addr $I10, rxsubrule738_back
    rx731_cur."!mark_push"(0, rx731_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx731_pos = $P10."pos"()
    set_addr $I10, rxquantr737_done
    (rx731_rep) = rx731_cur."!mark_commit"($I10)
  rxquantr737_done:
  # rx subrule "ws" subtype=method negate=
    rx731_cur."!cursor_pos"(rx731_pos)
    $P10 = rx731_cur."ws"()
    unless $P10, rx731_fail
    rx731_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx731_cur."!cursor_pos"(rx731_pos)
    $P10 = rx731_cur."variable"()
    unless $P10, rx731_fail
    rx731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx731_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx731_cur."!cursor_pos"(rx731_pos)
    $P10 = rx731_cur."ws"()
    unless $P10, rx731_fail
    rx731_pos = $P10."pos"()
  # rx pass
    rx731_cur."!cursor_pass"(rx731_pos, "variable_declarator")
    if_null rx731_debug, debug_719
    rx731_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx731_pos)
  debug_719:
    .return (rx731_cur)
  rx731_restart:
.annotate 'line', 4
    if_null rx731_debug, debug_720
    rx731_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_720:
  rx731_fail:
    (rx731_rep, rx731_pos, $I10, $P10) = rx731_cur."!mark_fail"(0)
    lt rx731_pos, -1, rx731_done
    eq rx731_pos, -1, rx731_fail
    jump $I10
  rx731_done:
    rx731_cur."!cursor_fail"()
    if_null rx731_debug, debug_721
    rx731_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_721:
    .return (rx731_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("164_1298839231.515") :method
.annotate 'line', 4
    $P733 = self."!PREFIX__!subrule"("ws", "")
    new $P734, "ResizablePMCArray"
    push $P734, $P733
    .return ($P734)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("165_1298839231.515")
    .param pmc param_742
.annotate 'line', 348
    .lex "self", param_742
    $P743 = param_742."!protoregex"("routine_declarator")
    .return ($P743)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("166_1298839231.515")
    .param pmc param_745
.annotate 'line', 348
    .lex "self", param_745
    $P746 = param_745."!PREFIX__!protoregex"("routine_declarator")
    .return ($P746)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("167_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx748_tgt
    .local int rx748_pos
    .local int rx748_off
    .local int rx748_eos
    .local int rx748_rep
    .local pmc rx748_cur
    .local pmc rx748_debug
    (rx748_cur, rx748_pos, rx748_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx748_cur
    .local pmc match
    .lex "$/", match
    length rx748_eos, rx748_tgt
    gt rx748_pos, rx748_eos, rx748_done
    set rx748_off, 0
    lt rx748_pos, 2, rx748_start
    sub rx748_off, rx748_pos, 1
    substr rx748_tgt, rx748_tgt, rx748_off
  rx748_start:
    eq $I10, 1, rx748_restart
    if_null rx748_debug, debug_722
    rx748_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan752_done
    goto rxscan752_scan
  rxscan752_loop:
    (rx748_pos) = rx748_cur."from"()
    inc rx748_pos
    rx748_cur."!cursor_from"(rx748_pos)
    ge rx748_pos, rx748_eos, rxscan752_done
  rxscan752_scan:
    set_addr $I10, rxscan752_loop
    rx748_cur."!mark_push"(0, rx748_pos, $I10)
  rxscan752_done:
.annotate 'line', 349
  # rx subcapture "sym"
    set_addr $I10, rxcap_753_fail
    rx748_cur."!mark_push"(0, rx748_pos, $I10)
  # rx literal  "sub"
    add $I11, rx748_pos, 3
    gt $I11, rx748_eos, rx748_fail
    sub $I11, rx748_pos, rx748_off
    substr $S10, rx748_tgt, $I11, 3
    ne $S10, "sub", rx748_fail
    add rx748_pos, 3
    set_addr $I10, rxcap_753_fail
    ($I12, $I11) = rx748_cur."!mark_peek"($I10)
    rx748_cur."!cursor_pos"($I11)
    ($P10) = rx748_cur."!cursor_start"()
    $P10."!cursor_pass"(rx748_pos, "")
    rx748_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_753_done
  rxcap_753_fail:
    goto rx748_fail
  rxcap_753_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx748_cur."!cursor_pos"(rx748_pos)
    $P10 = rx748_cur."routine_def"()
    unless $P10, rx748_fail
    rx748_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx748_pos = $P10."pos"()
  # rx pass
    rx748_cur."!cursor_pass"(rx748_pos, "routine_declarator:sym<sub>")
    if_null rx748_debug, debug_723
    rx748_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx748_pos)
  debug_723:
    .return (rx748_cur)
  rx748_restart:
.annotate 'line', 4
    if_null rx748_debug, debug_724
    rx748_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_724:
  rx748_fail:
    (rx748_rep, rx748_pos, $I10, $P10) = rx748_cur."!mark_fail"(0)
    lt rx748_pos, -1, rx748_done
    eq rx748_pos, -1, rx748_fail
    jump $I10
  rx748_done:
    rx748_cur."!cursor_fail"()
    if_null rx748_debug, debug_725
    rx748_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_725:
    .return (rx748_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("168_1298839231.515") :method
.annotate 'line', 4
    $P750 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P751, "ResizablePMCArray"
    push $P751, $P750
    .return ($P751)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("169_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx755_tgt
    .local int rx755_pos
    .local int rx755_off
    .local int rx755_eos
    .local int rx755_rep
    .local pmc rx755_cur
    .local pmc rx755_debug
    (rx755_cur, rx755_pos, rx755_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx755_cur
    .local pmc match
    .lex "$/", match
    length rx755_eos, rx755_tgt
    gt rx755_pos, rx755_eos, rx755_done
    set rx755_off, 0
    lt rx755_pos, 2, rx755_start
    sub rx755_off, rx755_pos, 1
    substr rx755_tgt, rx755_tgt, rx755_off
  rx755_start:
    eq $I10, 1, rx755_restart
    if_null rx755_debug, debug_726
    rx755_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_726:
    $I10 = self.'from'()
    ne $I10, -1, rxscan759_done
    goto rxscan759_scan
  rxscan759_loop:
    (rx755_pos) = rx755_cur."from"()
    inc rx755_pos
    rx755_cur."!cursor_from"(rx755_pos)
    ge rx755_pos, rx755_eos, rxscan759_done
  rxscan759_scan:
    set_addr $I10, rxscan759_loop
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  rxscan759_done:
.annotate 'line', 350
  # rx subcapture "sym"
    set_addr $I10, rxcap_760_fail
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  # rx literal  "method"
    add $I11, rx755_pos, 6
    gt $I11, rx755_eos, rx755_fail
    sub $I11, rx755_pos, rx755_off
    substr $S10, rx755_tgt, $I11, 6
    ne $S10, "method", rx755_fail
    add rx755_pos, 6
    set_addr $I10, rxcap_760_fail
    ($I12, $I11) = rx755_cur."!mark_peek"($I10)
    rx755_cur."!cursor_pos"($I11)
    ($P10) = rx755_cur."!cursor_start"()
    $P10."!cursor_pass"(rx755_pos, "")
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_760_done
  rxcap_760_fail:
    goto rx755_fail
  rxcap_760_done:
  # rx subrule "method_def" subtype=capture negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."method_def"()
    unless $P10, rx755_fail
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx755_pos = $P10."pos"()
  # rx pass
    rx755_cur."!cursor_pass"(rx755_pos, "routine_declarator:sym<method>")
    if_null rx755_debug, debug_727
    rx755_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx755_pos)
  debug_727:
    .return (rx755_cur)
  rx755_restart:
.annotate 'line', 4
    if_null rx755_debug, debug_728
    rx755_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_728:
  rx755_fail:
    (rx755_rep, rx755_pos, $I10, $P10) = rx755_cur."!mark_fail"(0)
    lt rx755_pos, -1, rx755_done
    eq rx755_pos, -1, rx755_fail
    jump $I10
  rx755_done:
    rx755_cur."!cursor_fail"()
    if_null rx755_debug, debug_729
    rx755_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_729:
    .return (rx755_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("170_1298839231.515") :method
.annotate 'line', 4
    $P757 = self."!PREFIX__!subrule"("method_def", "method")
    new $P758, "ResizablePMCArray"
    push $P758, $P757
    .return ($P758)
.end


.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("171_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 353
    new $P762, "Undef"
    .lex "$*RETURN_USED", $P762
.annotate 'line', 4
    .local string rx763_tgt
    .local int rx763_pos
    .local int rx763_off
    .local int rx763_eos
    .local int rx763_rep
    .local pmc rx763_cur
    .local pmc rx763_debug
    (rx763_cur, rx763_pos, rx763_tgt, $I10) = self."!cursor_start"()
    rx763_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx763_cur
    .local pmc match
    .lex "$/", match
    length rx763_eos, rx763_tgt
    gt rx763_pos, rx763_eos, rx763_done
    set rx763_off, 0
    lt rx763_pos, 2, rx763_start
    sub rx763_off, rx763_pos, 1
    substr rx763_tgt, rx763_tgt, rx763_off
  rx763_start:
    eq $I10, 1, rx763_restart
    if_null rx763_debug, debug_730
    rx763_cur."!cursor_debug"("START", "routine_def")
  debug_730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan767_done
    goto rxscan767_scan
  rxscan767_loop:
    (rx763_pos) = rx763_cur."from"()
    inc rx763_pos
    rx763_cur."!cursor_from"(rx763_pos)
    ge rx763_pos, rx763_eos, rxscan767_done
  rxscan767_scan:
    set_addr $I10, rxscan767_loop
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
  rxscan767_done:
.annotate 'line', 352
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
.annotate 'line', 353
    rx763_cur."!cursor_pos"(rx763_pos)
    new $P769, "Integer"
    assign $P769, 0
    store_lex "$*RETURN_USED", $P769
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
.annotate 'line', 354
  # rx rxquantr771 ** 0..1
    set_addr $I10, rxquantr771_done
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
  rxquantr771_loop:
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_774_fail
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
  # rx rxquantr773 ** 0..1
    set_addr $I10, rxquantr773_done
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
  rxquantr773_loop:
  # rx literal  "&"
    add $I11, rx763_pos, 1
    gt $I11, rx763_eos, rx763_fail
    sub $I11, rx763_pos, rx763_off
    ord $I11, rx763_tgt, $I11
    ne $I11, 38, rx763_fail
    add rx763_pos, 1
    set_addr $I10, rxquantr773_done
    (rx763_rep) = rx763_cur."!mark_commit"($I10)
  rxquantr773_done:
    set_addr $I10, rxcap_774_fail
    ($I12, $I11) = rx763_cur."!mark_peek"($I10)
    rx763_cur."!cursor_pos"($I11)
    ($P10) = rx763_cur."!cursor_start"()
    $P10."!cursor_pass"(rx763_pos, "")
    rx763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_774_done
  rxcap_774_fail:
    goto rx763_fail
  rxcap_774_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."deflongname"()
    unless $P10, rx763_fail
    rx763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx763_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
    set_addr $I10, rxquantr771_done
    (rx763_rep) = rx763_cur."!mark_commit"($I10)
  rxquantr771_done:
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
.annotate 'line', 355
  # rx subrule "newpad" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."newpad"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  alt778_0:
.annotate 'line', 356
    set_addr $I10, alt778_1
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx763_pos, 1
    gt $I11, rx763_eos, rx763_fail
    sub $I11, rx763_pos, rx763_off
    ord $I11, rx763_tgt, $I11
    ne $I11, 40, rx763_fail
    add rx763_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."signature"()
    unless $P10, rx763_fail
    rx763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx763_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx763_pos, 1
    gt $I11, rx763_eos, rx763_fail
    sub $I11, rx763_pos, rx763_off
    ord $I11, rx763_tgt, $I11
    ne $I11, 41, rx763_fail
    add rx763_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
    goto alt778_end
  alt778_1:
.annotate 'line', 357
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  alt778_end:
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
.annotate 'line', 358
  # rx rxquantr786 ** 0..*
    set_addr $I10, rxquantr786_done
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
  rxquantr786_loop:
  # rx subrule "trait" subtype=capture negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."trait"()
    unless $P10, rx763_fail
    goto rxsubrule787_pass
  rxsubrule787_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx763_fail
  rxsubrule787_pass:
    set_addr $I10, rxsubrule787_back
    rx763_cur."!mark_push"(0, rx763_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx763_pos = $P10."pos"()
    set_addr $I10, rxquantr786_done
    (rx763_rep) = rx763_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr786_done
    rx763_cur."!mark_push"(rx763_rep, rx763_pos, $I10)
    goto rxquantr786_loop
  rxquantr786_done:
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  alt789_0:
.annotate 'line', 359
    set_addr $I10, alt789_1
    rx763_cur."!mark_push"(0, rx763_pos, $I10)
.annotate 'line', 360
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."onlystar"()
    unless $P10, rx763_fail
    rx763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx763_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
    goto alt789_end
  alt789_1:
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."blockoid"()
    unless $P10, rx763_fail
    rx763_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx763_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
  alt789_end:
.annotate 'line', 362
  # rx subrule "ws" subtype=method negate=
    rx763_cur."!cursor_pos"(rx763_pos)
    $P10 = rx763_cur."ws"()
    unless $P10, rx763_fail
    rx763_pos = $P10."pos"()
.annotate 'line', 352
  # rx pass
    rx763_cur."!cursor_pass"(rx763_pos, "routine_def")
    if_null rx763_debug, debug_731
    rx763_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx763_pos)
  debug_731:
    .return (rx763_cur)
  rx763_restart:
.annotate 'line', 4
    if_null rx763_debug, debug_732
    rx763_cur."!cursor_debug"("NEXT", "routine_def")
  debug_732:
  rx763_fail:
    (rx763_rep, rx763_pos, $I10, $P10) = rx763_cur."!mark_fail"(0)
    lt rx763_pos, -1, rx763_done
    eq rx763_pos, -1, rx763_fail
    jump $I10
  rx763_done:
    rx763_cur."!cursor_fail"()
    if_null rx763_debug, debug_733
    rx763_cur."!cursor_debug"("FAIL", "routine_def")
  debug_733:
    .return (rx763_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("172_1298839231.515") :method
.annotate 'line', 4
    $P765 = self."!PREFIX__!subrule"("ws", "")
    new $P766, "ResizablePMCArray"
    push $P766, $P765
    .return ($P766)
.end


.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("173_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P826 = "175_1298839231.515" 
    capture_lex $P826
.annotate 'line', 366
    new $P796, "Undef"
    .lex "$*RETURN_USED", $P796
.annotate 'line', 367
    new $P797, "Undef"
    .lex "$*INVOCANT_OK", $P797
.annotate 'line', 4
    .local string rx798_tgt
    .local int rx798_pos
    .local int rx798_off
    .local int rx798_eos
    .local int rx798_rep
    .local pmc rx798_cur
    .local pmc rx798_debug
    (rx798_cur, rx798_pos, rx798_tgt, $I10) = self."!cursor_start"()
    rx798_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx798_cur
    .local pmc match
    .lex "$/", match
    length rx798_eos, rx798_tgt
    gt rx798_pos, rx798_eos, rx798_done
    set rx798_off, 0
    lt rx798_pos, 2, rx798_start
    sub rx798_off, rx798_pos, 1
    substr rx798_tgt, rx798_tgt, rx798_off
  rx798_start:
    eq $I10, 1, rx798_restart
    if_null rx798_debug, debug_734
    rx798_cur."!cursor_debug"("START", "method_def")
  debug_734:
    $I10 = self.'from'()
    ne $I10, -1, rxscan802_done
    goto rxscan802_scan
  rxscan802_loop:
    (rx798_pos) = rx798_cur."from"()
    inc rx798_pos
    rx798_cur."!cursor_from"(rx798_pos)
    ge rx798_pos, rx798_eos, rxscan802_done
  rxscan802_scan:
    set_addr $I10, rxscan802_loop
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  rxscan802_done:
.annotate 'line', 365
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
.annotate 'line', 366
    rx798_cur."!cursor_pos"(rx798_pos)
    new $P804, "Integer"
    assign $P804, 0
    store_lex "$*RETURN_USED", $P804
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
.annotate 'line', 367
    rx798_cur."!cursor_pos"(rx798_pos)
    new $P806, "Integer"
    assign $P806, 1
    store_lex "$*INVOCANT_OK", $P806
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
.annotate 'line', 368
  # rx subcapture "private"
    set_addr $I10, rxcap_809_fail
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  # rx rxquantr808 ** 0..1
    set_addr $I10, rxquantr808_done
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  rxquantr808_loop:
  # rx literal  "!"
    add $I11, rx798_pos, 1
    gt $I11, rx798_eos, rx798_fail
    sub $I11, rx798_pos, rx798_off
    ord $I11, rx798_tgt, $I11
    ne $I11, 33, rx798_fail
    add rx798_pos, 1
    set_addr $I10, rxquantr808_done
    (rx798_rep) = rx798_cur."!mark_commit"($I10)
  rxquantr808_done:
    set_addr $I10, rxcap_809_fail
    ($I12, $I11) = rx798_cur."!mark_peek"($I10)
    rx798_cur."!cursor_pos"($I11)
    ($P10) = rx798_cur."!cursor_start"()
    $P10."!cursor_pass"(rx798_pos, "")
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_809_done
  rxcap_809_fail:
    goto rx798_fail
  rxcap_809_done:
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
.annotate 'line', 369
  # rx rxquantr811 ** 0..1
    set_addr $I10, rxquantr811_done
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  rxquantr811_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."deflongname"()
    unless $P10, rx798_fail
    goto rxsubrule812_pass
  rxsubrule812_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx798_fail
  rxsubrule812_pass:
    set_addr $I10, rxsubrule812_back
    rx798_cur."!mark_push"(0, rx798_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx798_pos = $P10."pos"()
    set_addr $I10, rxquantr811_done
    (rx798_rep) = rx798_cur."!mark_commit"($I10)
  rxquantr811_done:
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
.annotate 'line', 370
  # rx subrule "newpad" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."newpad"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  alt815_0:
.annotate 'line', 371
    set_addr $I10, alt815_1
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx798_pos, 1
    gt $I11, rx798_eos, rx798_fail
    sub $I11, rx798_pos, rx798_off
    ord $I11, rx798_tgt, $I11
    ne $I11, 40, rx798_fail
    add rx798_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."signature"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx798_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx798_pos, 1
    gt $I11, rx798_eos, rx798_fail
    sub $I11, rx798_pos, rx798_off
    ord $I11, rx798_tgt, $I11
    ne $I11, 41, rx798_fail
    add rx798_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
    goto alt815_end
  alt815_1:
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  alt815_end:
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
.annotate 'line', 373
    rx798_cur."!cursor_pos"(rx798_pos)
    find_lex $P823, unicode:"$\x{a2}"
    $P824 = $P823."MATCH"()
    store_lex "$/", $P824
    .const 'Sub' $P826 = "175_1298839231.515" 
    capture_lex $P826
    $P828 = $P826()
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
.annotate 'line', 374
  # rx rxquantr830 ** 0..*
    set_addr $I10, rxquantr830_done
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  rxquantr830_loop:
  # rx subrule "trait" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."trait"()
    unless $P10, rx798_fail
    goto rxsubrule831_pass
  rxsubrule831_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx798_fail
  rxsubrule831_pass:
    set_addr $I10, rxsubrule831_back
    rx798_cur."!mark_push"(0, rx798_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx798_pos = $P10."pos"()
    set_addr $I10, rxquantr830_done
    (rx798_rep) = rx798_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr830_done
    rx798_cur."!mark_push"(rx798_rep, rx798_pos, $I10)
    goto rxquantr830_loop
  rxquantr830_done:
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  alt833_0:
.annotate 'line', 375
    set_addr $I10, alt833_1
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
.annotate 'line', 376
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."onlystar"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx798_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
    goto alt833_end
  alt833_1:
.annotate 'line', 377
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."blockoid"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx798_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
  alt833_end:
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."ws"()
    unless $P10, rx798_fail
    rx798_pos = $P10."pos"()
.annotate 'line', 365
  # rx pass
    rx798_cur."!cursor_pass"(rx798_pos, "method_def")
    if_null rx798_debug, debug_735
    rx798_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx798_pos)
  debug_735:
    .return (rx798_cur)
  rx798_restart:
.annotate 'line', 4
    if_null rx798_debug, debug_736
    rx798_cur."!cursor_debug"("NEXT", "method_def")
  debug_736:
  rx798_fail:
    (rx798_rep, rx798_pos, $I10, $P10) = rx798_cur."!mark_fail"(0)
    lt rx798_pos, -1, rx798_done
    eq rx798_pos, -1, rx798_fail
    jump $I10
  rx798_done:
    rx798_cur."!cursor_fail"()
    if_null rx798_debug, debug_737
    rx798_cur."!cursor_debug"("FAIL", "method_def")
  debug_737:
    .return (rx798_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("174_1298839231.515") :method
.annotate 'line', 4
    $P800 = self."!PREFIX__!subrule"("ws", "")
    new $P801, "ResizablePMCArray"
    push $P801, $P800
    .return ($P801)
.end


.namespace ["NQP";"Grammar"]
.sub "_block825"  :anon :subid("175_1298839231.515") :outer("173_1298839231.515")
.annotate 'line', 373
    new $P827, "Integer"
    assign $P827, 0
    store_dynamic_lex "$*INVOCANT_OK", $P827
    .return ($P827)
.end


.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("176_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P847 = "178_1298839231.515" 
    capture_lex $P847
    .local string rx840_tgt
    .local int rx840_pos
    .local int rx840_off
    .local int rx840_eos
    .local int rx840_rep
    .local pmc rx840_cur
    .local pmc rx840_debug
    (rx840_cur, rx840_pos, rx840_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx840_cur
    .local pmc match
    .lex "$/", match
    length rx840_eos, rx840_tgt
    gt rx840_pos, rx840_eos, rx840_done
    set rx840_off, 0
    lt rx840_pos, 2, rx840_start
    sub rx840_off, rx840_pos, 1
    substr rx840_tgt, rx840_tgt, rx840_off
  rx840_start:
    eq $I10, 1, rx840_restart
    if_null rx840_debug, debug_738
    rx840_cur."!cursor_debug"("START", "onlystar")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan843_done
    goto rxscan843_scan
  rxscan843_loop:
    (rx840_pos) = rx840_cur."from"()
    inc rx840_pos
    rx840_cur."!cursor_from"(rx840_pos)
    ge rx840_pos, rx840_eos, rxscan843_done
  rxscan843_scan:
    set_addr $I10, rxscan843_loop
    rx840_cur."!mark_push"(0, rx840_pos, $I10)
  rxscan843_done:
.annotate 'line', 382
    rx840_cur."!cursor_pos"(rx840_pos)
    find_lex $P844, unicode:"$\x{a2}"
    $P845 = $P844."MATCH"()
    store_lex "$/", $P845
    .const 'Sub' $P847 = "178_1298839231.515" 
    capture_lex $P847
    $P851 = $P847()
    unless $P851, rx840_fail
.annotate 'line', 383
  # rx literal  "{"
    add $I11, rx840_pos, 1
    gt $I11, rx840_eos, rx840_fail
    sub $I11, rx840_pos, rx840_off
    ord $I11, rx840_tgt, $I11
    ne $I11, 123, rx840_fail
    add rx840_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx840_cur."!cursor_pos"(rx840_pos)
    $P10 = rx840_cur."ws"()
    unless $P10, rx840_fail
    rx840_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx840_pos, 1
    gt $I11, rx840_eos, rx840_fail
    sub $I11, rx840_pos, rx840_off
    ord $I11, rx840_tgt, $I11
    ne $I11, 42, rx840_fail
    add rx840_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx840_cur."!cursor_pos"(rx840_pos)
    $P10 = rx840_cur."ws"()
    unless $P10, rx840_fail
    rx840_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx840_pos, 1
    gt $I11, rx840_eos, rx840_fail
    sub $I11, rx840_pos, rx840_off
    ord $I11, rx840_tgt, $I11
    ne $I11, 125, rx840_fail
    add rx840_pos, 1
.annotate 'line', 384
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx840_cur."!cursor_pos"(rx840_pos)
    $P10 = rx840_cur."ENDSTMT"()
    unless $P10, rx840_fail
.annotate 'line', 385
  # rx subrule "finishpad" subtype=method negate=
    rx840_cur."!cursor_pos"(rx840_pos)
    $P10 = rx840_cur."finishpad"()
    unless $P10, rx840_fail
    rx840_pos = $P10."pos"()
.annotate 'line', 381
  # rx pass
    rx840_cur."!cursor_pass"(rx840_pos, "onlystar")
    if_null rx840_debug, debug_741
    rx840_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx840_pos)
  debug_741:
    .return (rx840_cur)
  rx840_restart:
.annotate 'line', 4
    if_null rx840_debug, debug_742
    rx840_cur."!cursor_debug"("NEXT", "onlystar")
  debug_742:
  rx840_fail:
    (rx840_rep, rx840_pos, $I10, $P10) = rx840_cur."!mark_fail"(0)
    lt rx840_pos, -1, rx840_done
    eq rx840_pos, -1, rx840_fail
    jump $I10
  rx840_done:
    rx840_cur."!cursor_fail"()
    if_null rx840_debug, debug_743
    rx840_cur."!cursor_debug"("FAIL", "onlystar")
  debug_743:
    .return (rx840_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("177_1298839231.515") :method
.annotate 'line', 4
    new $P842, "ResizablePMCArray"
    push $P842, ""
    .return ($P842)
.end


.namespace ["NQP";"Grammar"]
.sub "_block846"  :anon :subid("178_1298839231.515") :outer("176_1298839231.515")
.annotate 'line', 382
    find_dynamic_lex $P848, "$*MULTINESS"
    unless_null $P848, vivify_739
    get_hll_global $P848, "$MULTINESS"
    unless_null $P848, vivify_740
    die "Contextual $*MULTINESS not found"
  vivify_740:
  vivify_739:
    set $S849, $P848
    iseq $I850, $S849, "proto"
    .return ($I850)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("179_1298839231.515")
    .param pmc param_853
.annotate 'line', 388
    .lex "self", param_853
    $P854 = param_853."!protoregex"("multi_declarator")
    .return ($P854)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("180_1298839231.515")
    .param pmc param_856
.annotate 'line', 388
    .lex "self", param_856
    $P857 = param_856."!PREFIX__!protoregex"("multi_declarator")
    .return ($P857)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("181_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 390
    new $P859, "Undef"
    .lex "$*MULTINESS", $P859
.annotate 'line', 4
    .local string rx860_tgt
    .local int rx860_pos
    .local int rx860_off
    .local int rx860_eos
    .local int rx860_rep
    .local pmc rx860_cur
    .local pmc rx860_debug
    (rx860_cur, rx860_pos, rx860_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx860_cur
    .local pmc match
    .lex "$/", match
    length rx860_eos, rx860_tgt
    gt rx860_pos, rx860_eos, rx860_done
    set rx860_off, 0
    lt rx860_pos, 2, rx860_start
    sub rx860_off, rx860_pos, 1
    substr rx860_tgt, rx860_tgt, rx860_off
  rx860_start:
    eq $I10, 1, rx860_restart
    if_null rx860_debug, debug_744
    rx860_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan864_done
    goto rxscan864_scan
  rxscan864_loop:
    (rx860_pos) = rx860_cur."from"()
    inc rx860_pos
    rx860_cur."!cursor_from"(rx860_pos)
    ge rx860_pos, rx860_eos, rxscan864_done
  rxscan864_scan:
    set_addr $I10, rxscan864_loop
    rx860_cur."!mark_push"(0, rx860_pos, $I10)
  rxscan864_done:
.annotate 'line', 390
    rx860_cur."!cursor_pos"(rx860_pos)
    new $P865, "String"
    assign $P865, "multi"
    store_lex "$*MULTINESS", $P865
.annotate 'line', 391
  # rx subcapture "sym"
    set_addr $I10, rxcap_866_fail
    rx860_cur."!mark_push"(0, rx860_pos, $I10)
  # rx literal  "multi"
    add $I11, rx860_pos, 5
    gt $I11, rx860_eos, rx860_fail
    sub $I11, rx860_pos, rx860_off
    substr $S10, rx860_tgt, $I11, 5
    ne $S10, "multi", rx860_fail
    add rx860_pos, 5
    set_addr $I10, rxcap_866_fail
    ($I12, $I11) = rx860_cur."!mark_peek"($I10)
    rx860_cur."!cursor_pos"($I11)
    ($P10) = rx860_cur."!cursor_start"()
    $P10."!cursor_pass"(rx860_pos, "")
    rx860_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_866_done
  rxcap_866_fail:
    goto rx860_fail
  rxcap_866_done:
.annotate 'line', 392
  # rx subrule "ws" subtype=method negate=
    rx860_cur."!cursor_pos"(rx860_pos)
    $P10 = rx860_cur."ws"()
    unless $P10, rx860_fail
    rx860_pos = $P10."pos"()
  alt867_0:
    set_addr $I10, alt867_1
    rx860_cur."!mark_push"(0, rx860_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx860_cur."!cursor_pos"(rx860_pos)
    $P10 = rx860_cur."declarator"()
    unless $P10, rx860_fail
    rx860_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx860_pos = $P10."pos"()
    goto alt867_end
  alt867_1:
    set_addr $I10, alt867_2
    rx860_cur."!mark_push"(0, rx860_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx860_cur."!cursor_pos"(rx860_pos)
    $P10 = rx860_cur."routine_def"()
    unless $P10, rx860_fail
    rx860_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx860_pos = $P10."pos"()
    goto alt867_end
  alt867_2:
  # rx subrule "panic" subtype=method negate=
    rx860_cur."!cursor_pos"(rx860_pos)
    $P10 = rx860_cur."panic"("Malformed multi")
    unless $P10, rx860_fail
    rx860_pos = $P10."pos"()
  alt867_end:
.annotate 'line', 389
  # rx pass
    rx860_cur."!cursor_pass"(rx860_pos, "multi_declarator:sym<multi>")
    if_null rx860_debug, debug_745
    rx860_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx860_pos)
  debug_745:
    .return (rx860_cur)
  rx860_restart:
.annotate 'line', 4
    if_null rx860_debug, debug_746
    rx860_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_746:
  rx860_fail:
    (rx860_rep, rx860_pos, $I10, $P10) = rx860_cur."!mark_fail"(0)
    lt rx860_pos, -1, rx860_done
    eq rx860_pos, -1, rx860_fail
    jump $I10
  rx860_done:
    rx860_cur."!cursor_fail"()
    if_null rx860_debug, debug_747
    rx860_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_747:
    .return (rx860_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("182_1298839231.515") :method
.annotate 'line', 4
    $P862 = self."!PREFIX__!subrule"("ws", "multi")
    new $P863, "ResizablePMCArray"
    push $P863, $P862
    .return ($P863)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("183_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 395
    new $P869, "Undef"
    .lex "$*MULTINESS", $P869
.annotate 'line', 4
    .local string rx870_tgt
    .local int rx870_pos
    .local int rx870_off
    .local int rx870_eos
    .local int rx870_rep
    .local pmc rx870_cur
    .local pmc rx870_debug
    (rx870_cur, rx870_pos, rx870_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx870_cur
    .local pmc match
    .lex "$/", match
    length rx870_eos, rx870_tgt
    gt rx870_pos, rx870_eos, rx870_done
    set rx870_off, 0
    lt rx870_pos, 2, rx870_start
    sub rx870_off, rx870_pos, 1
    substr rx870_tgt, rx870_tgt, rx870_off
  rx870_start:
    eq $I10, 1, rx870_restart
    if_null rx870_debug, debug_748
    rx870_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan874_done
    goto rxscan874_scan
  rxscan874_loop:
    (rx870_pos) = rx870_cur."from"()
    inc rx870_pos
    rx870_cur."!cursor_from"(rx870_pos)
    ge rx870_pos, rx870_eos, rxscan874_done
  rxscan874_scan:
    set_addr $I10, rxscan874_loop
    rx870_cur."!mark_push"(0, rx870_pos, $I10)
  rxscan874_done:
.annotate 'line', 395
    rx870_cur."!cursor_pos"(rx870_pos)
    new $P875, "String"
    assign $P875, "proto"
    store_lex "$*MULTINESS", $P875
.annotate 'line', 396
  # rx subcapture "sym"
    set_addr $I10, rxcap_876_fail
    rx870_cur."!mark_push"(0, rx870_pos, $I10)
  # rx literal  "proto"
    add $I11, rx870_pos, 5
    gt $I11, rx870_eos, rx870_fail
    sub $I11, rx870_pos, rx870_off
    substr $S10, rx870_tgt, $I11, 5
    ne $S10, "proto", rx870_fail
    add rx870_pos, 5
    set_addr $I10, rxcap_876_fail
    ($I12, $I11) = rx870_cur."!mark_peek"($I10)
    rx870_cur."!cursor_pos"($I11)
    ($P10) = rx870_cur."!cursor_start"()
    $P10."!cursor_pass"(rx870_pos, "")
    rx870_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_876_done
  rxcap_876_fail:
    goto rx870_fail
  rxcap_876_done:
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx870_cur."!cursor_pos"(rx870_pos)
    $P10 = rx870_cur."ws"()
    unless $P10, rx870_fail
    rx870_pos = $P10."pos"()
  alt877_0:
    set_addr $I10, alt877_1
    rx870_cur."!mark_push"(0, rx870_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx870_cur."!cursor_pos"(rx870_pos)
    $P10 = rx870_cur."declarator"()
    unless $P10, rx870_fail
    rx870_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx870_pos = $P10."pos"()
    goto alt877_end
  alt877_1:
    set_addr $I10, alt877_2
    rx870_cur."!mark_push"(0, rx870_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx870_cur."!cursor_pos"(rx870_pos)
    $P10 = rx870_cur."routine_def"()
    unless $P10, rx870_fail
    rx870_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx870_pos = $P10."pos"()
    goto alt877_end
  alt877_2:
  # rx subrule "panic" subtype=method negate=
    rx870_cur."!cursor_pos"(rx870_pos)
    $P10 = rx870_cur."panic"("Malformed proto")
    unless $P10, rx870_fail
    rx870_pos = $P10."pos"()
  alt877_end:
.annotate 'line', 394
  # rx pass
    rx870_cur."!cursor_pass"(rx870_pos, "multi_declarator:sym<proto>")
    if_null rx870_debug, debug_749
    rx870_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx870_pos)
  debug_749:
    .return (rx870_cur)
  rx870_restart:
.annotate 'line', 4
    if_null rx870_debug, debug_750
    rx870_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_750:
  rx870_fail:
    (rx870_rep, rx870_pos, $I10, $P10) = rx870_cur."!mark_fail"(0)
    lt rx870_pos, -1, rx870_done
    eq rx870_pos, -1, rx870_fail
    jump $I10
  rx870_done:
    rx870_cur."!cursor_fail"()
    if_null rx870_debug, debug_751
    rx870_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_751:
    .return (rx870_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("184_1298839231.515") :method
.annotate 'line', 4
    $P872 = self."!PREFIX__!subrule"("ws", "proto")
    new $P873, "ResizablePMCArray"
    push $P873, $P872
    .return ($P873)
.end


.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("185_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 400
    new $P879, "Undef"
    .lex "$*MULTINESS", $P879
.annotate 'line', 4
    .local string rx880_tgt
    .local int rx880_pos
    .local int rx880_off
    .local int rx880_eos
    .local int rx880_rep
    .local pmc rx880_cur
    .local pmc rx880_debug
    (rx880_cur, rx880_pos, rx880_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx880_cur
    .local pmc match
    .lex "$/", match
    length rx880_eos, rx880_tgt
    gt rx880_pos, rx880_eos, rx880_done
    set rx880_off, 0
    lt rx880_pos, 2, rx880_start
    sub rx880_off, rx880_pos, 1
    substr rx880_tgt, rx880_tgt, rx880_off
  rx880_start:
    eq $I10, 1, rx880_restart
    if_null rx880_debug, debug_752
    rx880_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan884_done
    goto rxscan884_scan
  rxscan884_loop:
    (rx880_pos) = rx880_cur."from"()
    inc rx880_pos
    rx880_cur."!cursor_from"(rx880_pos)
    ge rx880_pos, rx880_eos, rxscan884_done
  rxscan884_scan:
    set_addr $I10, rxscan884_loop
    rx880_cur."!mark_push"(0, rx880_pos, $I10)
  rxscan884_done:
.annotate 'line', 400
    rx880_cur."!cursor_pos"(rx880_pos)
    new $P885, "String"
    assign $P885, ""
    store_lex "$*MULTINESS", $P885
.annotate 'line', 401
  # rx subrule "declarator" subtype=capture negate=
    rx880_cur."!cursor_pos"(rx880_pos)
    $P10 = rx880_cur."declarator"()
    unless $P10, rx880_fail
    rx880_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx880_pos = $P10."pos"()
.annotate 'line', 399
  # rx pass
    rx880_cur."!cursor_pass"(rx880_pos, "multi_declarator:sym<null>")
    if_null rx880_debug, debug_753
    rx880_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx880_pos)
  debug_753:
    .return (rx880_cur)
  rx880_restart:
.annotate 'line', 4
    if_null rx880_debug, debug_754
    rx880_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_754:
  rx880_fail:
    (rx880_rep, rx880_pos, $I10, $P10) = rx880_cur."!mark_fail"(0)
    lt rx880_pos, -1, rx880_done
    eq rx880_pos, -1, rx880_fail
    jump $I10
  rx880_done:
    rx880_cur."!cursor_fail"()
    if_null rx880_debug, debug_755
    rx880_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_755:
    .return (rx880_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("186_1298839231.515") :method
.annotate 'line', 4
    $P882 = self."!PREFIX__!subrule"("declarator", "")
    new $P883, "ResizablePMCArray"
    push $P883, $P882
    .return ($P883)
.end


.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("187_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P895 = "189_1298839231.515" 
    capture_lex $P895
    .local string rx887_tgt
    .local int rx887_pos
    .local int rx887_off
    .local int rx887_eos
    .local int rx887_rep
    .local pmc rx887_cur
    .local pmc rx887_debug
    (rx887_cur, rx887_pos, rx887_tgt, $I10) = self."!cursor_start"()
    rx887_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx887_cur
    .local pmc match
    .lex "$/", match
    length rx887_eos, rx887_tgt
    gt rx887_pos, rx887_eos, rx887_done
    set rx887_off, 0
    lt rx887_pos, 2, rx887_start
    sub rx887_off, rx887_pos, 1
    substr rx887_tgt, rx887_tgt, rx887_off
  rx887_start:
    eq $I10, 1, rx887_restart
    if_null rx887_debug, debug_756
    rx887_cur."!cursor_debug"("START", "signature")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan890_done
    goto rxscan890_scan
  rxscan890_loop:
    (rx887_pos) = rx887_cur."from"()
    inc rx887_pos
    rx887_cur."!cursor_from"(rx887_pos)
    ge rx887_pos, rx887_eos, rxscan890_done
  rxscan890_scan:
    set_addr $I10, rxscan890_loop
    rx887_cur."!mark_push"(0, rx887_pos, $I10)
  rxscan890_done:
.annotate 'line', 405
  # rx rxquantr891 ** 0..1
    set_addr $I10, rxquantr891_done
    rx887_cur."!mark_push"(0, rx887_pos, $I10)
  rxquantr891_loop:
    rx887_cur."!cursor_pos"(rx887_pos)
    find_lex $P892, unicode:"$\x{a2}"
    $P893 = $P892."MATCH"()
    store_lex "$/", $P893
    .const 'Sub' $P895 = "189_1298839231.515" 
    capture_lex $P895
    $P897 = $P895()
    unless $P897, rx887_fail
  # rx subrule "ws" subtype=method negate=
    rx887_cur."!cursor_pos"(rx887_pos)
    $P10 = rx887_cur."ws"()
    unless $P10, rx887_fail
    rx887_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx887_cur."!cursor_pos"(rx887_pos)
    $P10 = rx887_cur."parameter"()
    unless $P10, rx887_fail
    rx887_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx887_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx887_cur."!cursor_pos"(rx887_pos)
    $P10 = rx887_cur."ws"()
    unless $P10, rx887_fail
    rx887_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx887_pos, 1
    gt $I11, rx887_eos, rx887_fail
    sub $I11, rx887_pos, rx887_off
    ord $I11, rx887_tgt, $I11
    ne $I11, 58, rx887_fail
    add rx887_pos, 1
    set_addr $I10, rxquantr891_done
    (rx887_rep) = rx887_cur."!mark_commit"($I10)
  rxquantr891_done:
.annotate 'line', 406
  # rx rxquantr898 ** 0..1
    set_addr $I10, rxquantr898_done
    rx887_cur."!mark_push"(0, rx887_pos, $I10)
  rxquantr898_loop:
  # rx rxquantr899 ** 1..*
    set_addr $I10, rxquantr899_done
    rx887_cur."!mark_push"(0, -1, $I10)
  rxquantr899_loop:
  # rx subrule "ws" subtype=method negate=
    rx887_cur."!cursor_pos"(rx887_pos)
    $P10 = rx887_cur."ws"()
    unless $P10, rx887_fail
    rx887_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx887_cur."!cursor_pos"(rx887_pos)
    $P10 = rx887_cur."parameter"()
    unless $P10, rx887_fail
    rx887_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx887_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx887_cur."!cursor_pos"(rx887_pos)
    $P10 = rx887_cur."ws"()
    unless $P10, rx887_fail
    rx887_pos = $P10."pos"()
    set_addr $I10, rxquantr899_done
    (rx887_rep) = rx887_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr899_done
    rx887_cur."!mark_push"(rx887_rep, rx887_pos, $I10)
  # rx literal  ","
    add $I11, rx887_pos, 1
    gt $I11, rx887_eos, rx887_fail
    sub $I11, rx887_pos, rx887_off
    ord $I11, rx887_tgt, $I11
    ne $I11, 44, rx887_fail
    add rx887_pos, 1
    goto rxquantr899_loop
  rxquantr899_done:
    set_addr $I10, rxquantr898_done
    (rx887_rep) = rx887_cur."!mark_commit"($I10)
  rxquantr898_done:
.annotate 'line', 404
  # rx pass
    rx887_cur."!cursor_pass"(rx887_pos, "signature")
    if_null rx887_debug, debug_759
    rx887_cur."!cursor_debug"("PASS", "signature", " at pos=", rx887_pos)
  debug_759:
    .return (rx887_cur)
  rx887_restart:
.annotate 'line', 4
    if_null rx887_debug, debug_760
    rx887_cur."!cursor_debug"("NEXT", "signature")
  debug_760:
  rx887_fail:
    (rx887_rep, rx887_pos, $I10, $P10) = rx887_cur."!mark_fail"(0)
    lt rx887_pos, -1, rx887_done
    eq rx887_pos, -1, rx887_fail
    jump $I10
  rx887_done:
    rx887_cur."!cursor_fail"()
    if_null rx887_debug, debug_761
    rx887_cur."!cursor_debug"("FAIL", "signature")
  debug_761:
    .return (rx887_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("188_1298839231.515") :method
.annotate 'line', 4
    new $P889, "ResizablePMCArray"
    push $P889, ""
    .return ($P889)
.end


.namespace ["NQP";"Grammar"]
.sub "_block894"  :anon :subid("189_1298839231.515") :outer("187_1298839231.515")
.annotate 'line', 405
    find_dynamic_lex $P896, "$*INVOCANT_OK"
    unless_null $P896, vivify_757
    get_hll_global $P896, "$INVOCANT_OK"
    unless_null $P896, vivify_758
    die "Contextual $*INVOCANT_OK not found"
  vivify_758:
  vivify_757:
    .return ($P896)
.end


.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("190_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx901_tgt
    .local int rx901_pos
    .local int rx901_off
    .local int rx901_eos
    .local int rx901_rep
    .local pmc rx901_cur
    .local pmc rx901_debug
    (rx901_cur, rx901_pos, rx901_tgt, $I10) = self."!cursor_start"()
    rx901_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx901_cur
    .local pmc match
    .lex "$/", match
    length rx901_eos, rx901_tgt
    gt rx901_pos, rx901_eos, rx901_done
    set rx901_off, 0
    lt rx901_pos, 2, rx901_start
    sub rx901_off, rx901_pos, 1
    substr rx901_tgt, rx901_tgt, rx901_off
  rx901_start:
    eq $I10, 1, rx901_restart
    if_null rx901_debug, debug_762
    rx901_cur."!cursor_debug"("START", "parameter")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan904_done
    goto rxscan904_scan
  rxscan904_loop:
    (rx901_pos) = rx901_cur."from"()
    inc rx901_pos
    rx901_cur."!cursor_from"(rx901_pos)
    ge rx901_pos, rx901_eos, rxscan904_done
  rxscan904_scan:
    set_addr $I10, rxscan904_loop
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  rxscan904_done:
.annotate 'line', 410
  # rx rxquantr905 ** 0..*
    set_addr $I10, rxquantr905_done
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  rxquantr905_loop:
  # rx subrule "typename" subtype=capture negate=
    rx901_cur."!cursor_pos"(rx901_pos)
    $P10 = rx901_cur."typename"()
    unless $P10, rx901_fail
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx901_pos = $P10."pos"()
  # rx rxquantr906 ** 0..1
    set_addr $I10, rxquantr906_done
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  rxquantr906_loop:
  # rx literal  ":"
    add $I11, rx901_pos, 1
    gt $I11, rx901_eos, rx901_fail
    sub $I11, rx901_pos, rx901_off
    ord $I11, rx901_tgt, $I11
    ne $I11, 58, rx901_fail
    add rx901_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_907_fail
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx901_pos, rx901_eos, rx901_fail
    sub $I10, rx901_pos, rx901_off
    substr $S10, rx901_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx901_fail
    inc rx901_pos
    set_addr $I10, rxcap_907_fail
    ($I12, $I11) = rx901_cur."!mark_peek"($I10)
    rx901_cur."!cursor_pos"($I11)
    ($P10) = rx901_cur."!cursor_start"()
    $P10."!cursor_pass"(rx901_pos, "")
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_907_done
  rxcap_907_fail:
    goto rx901_fail
  rxcap_907_done:
    set_addr $I10, rxquantr906_done
    (rx901_rep) = rx901_cur."!mark_commit"($I10)
  rxquantr906_done:
  # rx subrule "ws" subtype=method negate=
    rx901_cur."!cursor_pos"(rx901_pos)
    $P10 = rx901_cur."ws"()
    unless $P10, rx901_fail
    rx901_pos = $P10."pos"()
    set_addr $I10, rxquantr905_done
    (rx901_rep) = rx901_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr905_done
    rx901_cur."!mark_push"(rx901_rep, rx901_pos, $I10)
    goto rxquantr905_loop
  rxquantr905_done:
  alt908_0:
.annotate 'line', 411
    set_addr $I10, alt908_1
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
.annotate 'line', 412
  # rx subcapture "quant"
    set_addr $I10, rxcap_909_fail
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  # rx literal  "*"
    add $I11, rx901_pos, 1
    gt $I11, rx901_eos, rx901_fail
    sub $I11, rx901_pos, rx901_off
    ord $I11, rx901_tgt, $I11
    ne $I11, 42, rx901_fail
    add rx901_pos, 1
    set_addr $I10, rxcap_909_fail
    ($I12, $I11) = rx901_cur."!mark_peek"($I10)
    rx901_cur."!cursor_pos"($I11)
    ($P10) = rx901_cur."!cursor_start"()
    $P10."!cursor_pass"(rx901_pos, "")
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_909_done
  rxcap_909_fail:
    goto rx901_fail
  rxcap_909_done:
  # rx subrule "param_var" subtype=capture negate=
    rx901_cur."!cursor_pos"(rx901_pos)
    $P10 = rx901_cur."param_var"()
    unless $P10, rx901_fail
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx901_pos = $P10."pos"()
    goto alt908_end
  alt908_1:
  alt910_0:
.annotate 'line', 413
    set_addr $I10, alt910_1
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx901_cur."!cursor_pos"(rx901_pos)
    $P10 = rx901_cur."param_var"()
    unless $P10, rx901_fail
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx901_pos = $P10."pos"()
    goto alt910_end
  alt910_1:
  # rx subrule "named_param" subtype=capture negate=
    rx901_cur."!cursor_pos"(rx901_pos)
    $P10 = rx901_cur."named_param"()
    unless $P10, rx901_fail
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx901_pos = $P10."pos"()
  alt910_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_912_fail
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  alt911_0:
    set_addr $I10, alt911_1
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  # rx literal  "?"
    add $I11, rx901_pos, 1
    gt $I11, rx901_eos, rx901_fail
    sub $I11, rx901_pos, rx901_off
    ord $I11, rx901_tgt, $I11
    ne $I11, 63, rx901_fail
    add rx901_pos, 1
    goto alt911_end
  alt911_1:
    set_addr $I10, alt911_2
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  # rx literal  "!"
    add $I11, rx901_pos, 1
    gt $I11, rx901_eos, rx901_fail
    sub $I11, rx901_pos, rx901_off
    ord $I11, rx901_tgt, $I11
    ne $I11, 33, rx901_fail
    add rx901_pos, 1
    goto alt911_end
  alt911_2:
  alt911_end:
    set_addr $I10, rxcap_912_fail
    ($I12, $I11) = rx901_cur."!mark_peek"($I10)
    rx901_cur."!cursor_pos"($I11)
    ($P10) = rx901_cur."!cursor_start"()
    $P10."!cursor_pass"(rx901_pos, "")
    rx901_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_912_done
  rxcap_912_fail:
    goto rx901_fail
  rxcap_912_done:
  alt908_end:
.annotate 'line', 415
  # rx rxquantr913 ** 0..1
    set_addr $I10, rxquantr913_done
    rx901_cur."!mark_push"(0, rx901_pos, $I10)
  rxquantr913_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx901_cur."!cursor_pos"(rx901_pos)
    $P10 = rx901_cur."default_value"()
    unless $P10, rx901_fail
    goto rxsubrule914_pass
  rxsubrule914_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx901_fail
  rxsubrule914_pass:
    set_addr $I10, rxsubrule914_back
    rx901_cur."!mark_push"(0, rx901_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx901_pos = $P10."pos"()
    set_addr $I10, rxquantr913_done
    (rx901_rep) = rx901_cur."!mark_commit"($I10)
  rxquantr913_done:
.annotate 'line', 409
  # rx pass
    rx901_cur."!cursor_pass"(rx901_pos, "parameter")
    if_null rx901_debug, debug_763
    rx901_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx901_pos)
  debug_763:
    .return (rx901_cur)
  rx901_restart:
.annotate 'line', 4
    if_null rx901_debug, debug_764
    rx901_cur."!cursor_debug"("NEXT", "parameter")
  debug_764:
  rx901_fail:
    (rx901_rep, rx901_pos, $I10, $P10) = rx901_cur."!mark_fail"(0)
    lt rx901_pos, -1, rx901_done
    eq rx901_pos, -1, rx901_fail
    jump $I10
  rx901_done:
    rx901_cur."!cursor_fail"()
    if_null rx901_debug, debug_765
    rx901_cur."!cursor_debug"("FAIL", "parameter")
  debug_765:
    .return (rx901_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("191_1298839231.515") :method
.annotate 'line', 4
    new $P903, "ResizablePMCArray"
    push $P903, ""
    .return ($P903)
.end


.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("192_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx916_tgt
    .local int rx916_pos
    .local int rx916_off
    .local int rx916_eos
    .local int rx916_rep
    .local pmc rx916_cur
    .local pmc rx916_debug
    (rx916_cur, rx916_pos, rx916_tgt, $I10) = self."!cursor_start"()
    rx916_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx916_cur
    .local pmc match
    .lex "$/", match
    length rx916_eos, rx916_tgt
    gt rx916_pos, rx916_eos, rx916_done
    set rx916_off, 0
    lt rx916_pos, 2, rx916_start
    sub rx916_off, rx916_pos, 1
    substr rx916_tgt, rx916_tgt, rx916_off
  rx916_start:
    eq $I10, 1, rx916_restart
    if_null rx916_debug, debug_766
    rx916_cur."!cursor_debug"("START", "param_var")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan920_done
    goto rxscan920_scan
  rxscan920_loop:
    (rx916_pos) = rx916_cur."from"()
    inc rx916_pos
    rx916_cur."!cursor_from"(rx916_pos)
    ge rx916_pos, rx916_eos, rxscan920_done
  rxscan920_scan:
    set_addr $I10, rxscan920_loop
    rx916_cur."!mark_push"(0, rx916_pos, $I10)
  rxscan920_done:
.annotate 'line', 419
  # rx subrule "sigil" subtype=capture negate=
    rx916_cur."!cursor_pos"(rx916_pos)
    $P10 = rx916_cur."sigil"()
    unless $P10, rx916_fail
    rx916_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx916_pos = $P10."pos"()
  # rx rxquantr921 ** 0..1
    set_addr $I10, rxquantr921_done
    rx916_cur."!mark_push"(0, rx916_pos, $I10)
  rxquantr921_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx916_cur."!cursor_pos"(rx916_pos)
    $P10 = rx916_cur."twigil"()
    unless $P10, rx916_fail
    goto rxsubrule922_pass
  rxsubrule922_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx916_fail
  rxsubrule922_pass:
    set_addr $I10, rxsubrule922_back
    rx916_cur."!mark_push"(0, rx916_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx916_pos = $P10."pos"()
    set_addr $I10, rxquantr921_done
    (rx916_rep) = rx916_cur."!mark_commit"($I10)
  rxquantr921_done:
  alt923_0:
.annotate 'line', 420
    set_addr $I10, alt923_1
    rx916_cur."!mark_push"(0, rx916_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx916_cur."!cursor_pos"(rx916_pos)
    $P10 = rx916_cur."ident"()
    unless $P10, rx916_fail
    rx916_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx916_pos = $P10."pos"()
    goto alt923_end
  alt923_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_924_fail
    rx916_cur."!mark_push"(0, rx916_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx916_pos, rx916_eos, rx916_fail
    sub $I10, rx916_pos, rx916_off
    substr $S10, rx916_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx916_fail
    inc rx916_pos
    set_addr $I10, rxcap_924_fail
    ($I12, $I11) = rx916_cur."!mark_peek"($I10)
    rx916_cur."!cursor_pos"($I11)
    ($P10) = rx916_cur."!cursor_start"()
    $P10."!cursor_pass"(rx916_pos, "")
    rx916_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_924_done
  rxcap_924_fail:
    goto rx916_fail
  rxcap_924_done:
  alt923_end:
.annotate 'line', 418
  # rx pass
    rx916_cur."!cursor_pass"(rx916_pos, "param_var")
    if_null rx916_debug, debug_767
    rx916_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx916_pos)
  debug_767:
    .return (rx916_cur)
  rx916_restart:
.annotate 'line', 4
    if_null rx916_debug, debug_768
    rx916_cur."!cursor_debug"("NEXT", "param_var")
  debug_768:
  rx916_fail:
    (rx916_rep, rx916_pos, $I10, $P10) = rx916_cur."!mark_fail"(0)
    lt rx916_pos, -1, rx916_done
    eq rx916_pos, -1, rx916_fail
    jump $I10
  rx916_done:
    rx916_cur."!cursor_fail"()
    if_null rx916_debug, debug_769
    rx916_cur."!cursor_debug"("FAIL", "param_var")
  debug_769:
    .return (rx916_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("193_1298839231.515") :method
.annotate 'line', 4
    $P918 = self."!PREFIX__!subrule"("sigil", "")
    new $P919, "ResizablePMCArray"
    push $P919, $P918
    .return ($P919)
.end


.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("194_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx926_tgt
    .local int rx926_pos
    .local int rx926_off
    .local int rx926_eos
    .local int rx926_rep
    .local pmc rx926_cur
    .local pmc rx926_debug
    (rx926_cur, rx926_pos, rx926_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx926_cur
    .local pmc match
    .lex "$/", match
    length rx926_eos, rx926_tgt
    gt rx926_pos, rx926_eos, rx926_done
    set rx926_off, 0
    lt rx926_pos, 2, rx926_start
    sub rx926_off, rx926_pos, 1
    substr rx926_tgt, rx926_tgt, rx926_off
  rx926_start:
    eq $I10, 1, rx926_restart
    if_null rx926_debug, debug_770
    rx926_cur."!cursor_debug"("START", "named_param")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan930_done
    goto rxscan930_scan
  rxscan930_loop:
    (rx926_pos) = rx926_cur."from"()
    inc rx926_pos
    rx926_cur."!cursor_from"(rx926_pos)
    ge rx926_pos, rx926_eos, rxscan930_done
  rxscan930_scan:
    set_addr $I10, rxscan930_loop
    rx926_cur."!mark_push"(0, rx926_pos, $I10)
  rxscan930_done:
.annotate 'line', 424
  # rx literal  ":"
    add $I11, rx926_pos, 1
    gt $I11, rx926_eos, rx926_fail
    sub $I11, rx926_pos, rx926_off
    ord $I11, rx926_tgt, $I11
    ne $I11, 58, rx926_fail
    add rx926_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx926_cur."!cursor_pos"(rx926_pos)
    $P10 = rx926_cur."param_var"()
    unless $P10, rx926_fail
    rx926_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx926_pos = $P10."pos"()
.annotate 'line', 423
  # rx pass
    rx926_cur."!cursor_pass"(rx926_pos, "named_param")
    if_null rx926_debug, debug_771
    rx926_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx926_pos)
  debug_771:
    .return (rx926_cur)
  rx926_restart:
.annotate 'line', 4
    if_null rx926_debug, debug_772
    rx926_cur."!cursor_debug"("NEXT", "named_param")
  debug_772:
  rx926_fail:
    (rx926_rep, rx926_pos, $I10, $P10) = rx926_cur."!mark_fail"(0)
    lt rx926_pos, -1, rx926_done
    eq rx926_pos, -1, rx926_fail
    jump $I10
  rx926_done:
    rx926_cur."!cursor_fail"()
    if_null rx926_debug, debug_773
    rx926_cur."!cursor_debug"("FAIL", "named_param")
  debug_773:
    .return (rx926_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("195_1298839231.515") :method
.annotate 'line', 4
    $P928 = self."!PREFIX__!subrule"("param_var", ":")
    new $P929, "ResizablePMCArray"
    push $P929, $P928
    .return ($P929)
.end


.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("196_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx932_tgt
    .local int rx932_pos
    .local int rx932_off
    .local int rx932_eos
    .local int rx932_rep
    .local pmc rx932_cur
    .local pmc rx932_debug
    (rx932_cur, rx932_pos, rx932_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx932_cur
    .local pmc match
    .lex "$/", match
    length rx932_eos, rx932_tgt
    gt rx932_pos, rx932_eos, rx932_done
    set rx932_off, 0
    lt rx932_pos, 2, rx932_start
    sub rx932_off, rx932_pos, 1
    substr rx932_tgt, rx932_tgt, rx932_off
  rx932_start:
    eq $I10, 1, rx932_restart
    if_null rx932_debug, debug_774
    rx932_cur."!cursor_debug"("START", "default_value")
  debug_774:
    $I10 = self.'from'()
    ne $I10, -1, rxscan936_done
    goto rxscan936_scan
  rxscan936_loop:
    (rx932_pos) = rx932_cur."from"()
    inc rx932_pos
    rx932_cur."!cursor_from"(rx932_pos)
    ge rx932_pos, rx932_eos, rxscan936_done
  rxscan936_scan:
    set_addr $I10, rxscan936_loop
    rx932_cur."!mark_push"(0, rx932_pos, $I10)
  rxscan936_done:
.annotate 'line', 427
  # rx subrule "ws" subtype=method negate=
    rx932_cur."!cursor_pos"(rx932_pos)
    $P10 = rx932_cur."ws"()
    unless $P10, rx932_fail
    rx932_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx932_pos, 1
    gt $I11, rx932_eos, rx932_fail
    sub $I11, rx932_pos, rx932_off
    ord $I11, rx932_tgt, $I11
    ne $I11, 61, rx932_fail
    add rx932_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx932_cur."!cursor_pos"(rx932_pos)
    $P10 = rx932_cur."ws"()
    unless $P10, rx932_fail
    rx932_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx932_cur."!cursor_pos"(rx932_pos)
    $P10 = rx932_cur."EXPR"("i=")
    unless $P10, rx932_fail
    rx932_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx932_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx932_cur."!cursor_pos"(rx932_pos)
    $P10 = rx932_cur."ws"()
    unless $P10, rx932_fail
    rx932_pos = $P10."pos"()
  # rx pass
    rx932_cur."!cursor_pass"(rx932_pos, "default_value")
    if_null rx932_debug, debug_775
    rx932_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx932_pos)
  debug_775:
    .return (rx932_cur)
  rx932_restart:
.annotate 'line', 4
    if_null rx932_debug, debug_776
    rx932_cur."!cursor_debug"("NEXT", "default_value")
  debug_776:
  rx932_fail:
    (rx932_rep, rx932_pos, $I10, $P10) = rx932_cur."!mark_fail"(0)
    lt rx932_pos, -1, rx932_done
    eq rx932_pos, -1, rx932_fail
    jump $I10
  rx932_done:
    rx932_cur."!cursor_fail"()
    if_null rx932_debug, debug_777
    rx932_cur."!cursor_debug"("FAIL", "default_value")
  debug_777:
    .return (rx932_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("197_1298839231.515") :method
.annotate 'line', 4
    $P934 = self."!PREFIX__!subrule"("ws", "")
    new $P935, "ResizablePMCArray"
    push $P935, $P934
    .return ($P935)
.end


.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("198_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx941_tgt
    .local int rx941_pos
    .local int rx941_off
    .local int rx941_eos
    .local int rx941_rep
    .local pmc rx941_cur
    .local pmc rx941_debug
    (rx941_cur, rx941_pos, rx941_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx941_cur
    .local pmc match
    .lex "$/", match
    length rx941_eos, rx941_tgt
    gt rx941_pos, rx941_eos, rx941_done
    set rx941_off, 0
    lt rx941_pos, 2, rx941_start
    sub rx941_off, rx941_pos, 1
    substr rx941_tgt, rx941_tgt, rx941_off
  rx941_start:
    eq $I10, 1, rx941_restart
    if_null rx941_debug, debug_778
    rx941_cur."!cursor_debug"("START", "trait")
  debug_778:
    $I10 = self.'from'()
    ne $I10, -1, rxscan945_done
    goto rxscan945_scan
  rxscan945_loop:
    (rx941_pos) = rx941_cur."from"()
    inc rx941_pos
    rx941_cur."!cursor_from"(rx941_pos)
    ge rx941_pos, rx941_eos, rxscan945_done
  rxscan945_scan:
    set_addr $I10, rxscan945_loop
    rx941_cur."!mark_push"(0, rx941_pos, $I10)
  rxscan945_done:
.annotate 'line', 429
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."trait_mod"()
    unless $P10, rx941_fail
    rx941_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx941_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx941_cur."!cursor_pos"(rx941_pos)
    $P10 = rx941_cur."ws"()
    unless $P10, rx941_fail
    rx941_pos = $P10."pos"()
  # rx pass
    rx941_cur."!cursor_pass"(rx941_pos, "trait")
    if_null rx941_debug, debug_779
    rx941_cur."!cursor_debug"("PASS", "trait", " at pos=", rx941_pos)
  debug_779:
    .return (rx941_cur)
  rx941_restart:
.annotate 'line', 4
    if_null rx941_debug, debug_780
    rx941_cur."!cursor_debug"("NEXT", "trait")
  debug_780:
  rx941_fail:
    (rx941_rep, rx941_pos, $I10, $P10) = rx941_cur."!mark_fail"(0)
    lt rx941_pos, -1, rx941_done
    eq rx941_pos, -1, rx941_fail
    jump $I10
  rx941_done:
    rx941_cur."!cursor_fail"()
    if_null rx941_debug, debug_781
    rx941_cur."!cursor_debug"("FAIL", "trait")
  debug_781:
    .return (rx941_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("199_1298839231.515") :method
.annotate 'line', 4
    $P943 = self."!PREFIX__!subrule"("ws", "")
    new $P944, "ResizablePMCArray"
    push $P944, $P943
    .return ($P944)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("200_1298839231.515")
    .param pmc param_949
.annotate 'line', 431
    .lex "self", param_949
    $P950 = param_949."!protoregex"("trait_mod")
    .return ($P950)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("201_1298839231.515")
    .param pmc param_952
.annotate 'line', 431
    .lex "self", param_952
    $P953 = param_952."!PREFIX__!protoregex"("trait_mod")
    .return ($P953)
.end


.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("202_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx955_tgt
    .local int rx955_pos
    .local int rx955_off
    .local int rx955_eos
    .local int rx955_rep
    .local pmc rx955_cur
    .local pmc rx955_debug
    (rx955_cur, rx955_pos, rx955_tgt, $I10) = self."!cursor_start"()
    rx955_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx955_cur
    .local pmc match
    .lex "$/", match
    length rx955_eos, rx955_tgt
    gt rx955_pos, rx955_eos, rx955_done
    set rx955_off, 0
    lt rx955_pos, 2, rx955_start
    sub rx955_off, rx955_pos, 1
    substr rx955_tgt, rx955_tgt, rx955_off
  rx955_start:
    eq $I10, 1, rx955_restart
    if_null rx955_debug, debug_782
    rx955_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_782:
    $I10 = self.'from'()
    ne $I10, -1, rxscan959_done
    goto rxscan959_scan
  rxscan959_loop:
    (rx955_pos) = rx955_cur."from"()
    inc rx955_pos
    rx955_cur."!cursor_from"(rx955_pos)
    ge rx955_pos, rx955_eos, rxscan959_done
  rxscan959_scan:
    set_addr $I10, rxscan959_loop
    rx955_cur."!mark_push"(0, rx955_pos, $I10)
  rxscan959_done:
.annotate 'line', 432
  # rx subcapture "sym"
    set_addr $I10, rxcap_960_fail
    rx955_cur."!mark_push"(0, rx955_pos, $I10)
  # rx literal  "is"
    add $I11, rx955_pos, 2
    gt $I11, rx955_eos, rx955_fail
    sub $I11, rx955_pos, rx955_off
    substr $S10, rx955_tgt, $I11, 2
    ne $S10, "is", rx955_fail
    add rx955_pos, 2
    set_addr $I10, rxcap_960_fail
    ($I12, $I11) = rx955_cur."!mark_peek"($I10)
    rx955_cur."!cursor_pos"($I11)
    ($P10) = rx955_cur."!cursor_start"()
    $P10."!cursor_pass"(rx955_pos, "")
    rx955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_960_done
  rxcap_960_fail:
    goto rx955_fail
  rxcap_960_done:
  # rx subrule "ws" subtype=method negate=
    rx955_cur."!cursor_pos"(rx955_pos)
    $P10 = rx955_cur."ws"()
    unless $P10, rx955_fail
    rx955_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx955_cur."!cursor_pos"(rx955_pos)
    $P10 = rx955_cur."deflongname"()
    unless $P10, rx955_fail
    rx955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx955_pos = $P10."pos"()
  # rx rxquantr962 ** 0..1
    set_addr $I10, rxquantr962_done
    rx955_cur."!mark_push"(0, rx955_pos, $I10)
  rxquantr962_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx955_cur."!cursor_pos"(rx955_pos)
    $P10 = rx955_cur."circumfix"()
    unless $P10, rx955_fail
    goto rxsubrule963_pass
  rxsubrule963_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx955_fail
  rxsubrule963_pass:
    set_addr $I10, rxsubrule963_back
    rx955_cur."!mark_push"(0, rx955_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx955_pos = $P10."pos"()
    set_addr $I10, rxquantr962_done
    (rx955_rep) = rx955_cur."!mark_commit"($I10)
  rxquantr962_done:
  # rx subrule "ws" subtype=method negate=
    rx955_cur."!cursor_pos"(rx955_pos)
    $P10 = rx955_cur."ws"()
    unless $P10, rx955_fail
    rx955_pos = $P10."pos"()
  # rx pass
    rx955_cur."!cursor_pass"(rx955_pos, "trait_mod:sym<is>")
    if_null rx955_debug, debug_783
    rx955_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx955_pos)
  debug_783:
    .return (rx955_cur)
  rx955_restart:
.annotate 'line', 4
    if_null rx955_debug, debug_784
    rx955_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_784:
  rx955_fail:
    (rx955_rep, rx955_pos, $I10, $P10) = rx955_cur."!mark_fail"(0)
    lt rx955_pos, -1, rx955_done
    eq rx955_pos, -1, rx955_fail
    jump $I10
  rx955_done:
    rx955_cur."!cursor_fail"()
    if_null rx955_debug, debug_785
    rx955_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_785:
    .return (rx955_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("203_1298839231.515") :method
.annotate 'line', 4
    $P957 = self."!PREFIX__!subrule"("ws", "is")
    new $P958, "ResizablePMCArray"
    push $P958, $P957
    .return ($P958)
.end


.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("204_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx966_tgt
    .local int rx966_pos
    .local int rx966_off
    .local int rx966_eos
    .local int rx966_rep
    .local pmc rx966_cur
    .local pmc rx966_debug
    (rx966_cur, rx966_pos, rx966_tgt, $I10) = self."!cursor_start"()
    rx966_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx966_cur
    .local pmc match
    .lex "$/", match
    length rx966_eos, rx966_tgt
    gt rx966_pos, rx966_eos, rx966_done
    set rx966_off, 0
    lt rx966_pos, 2, rx966_start
    sub rx966_off, rx966_pos, 1
    substr rx966_tgt, rx966_tgt, rx966_off
  rx966_start:
    eq $I10, 1, rx966_restart
    if_null rx966_debug, debug_786
    rx966_cur."!cursor_debug"("START", "regex_declarator")
  debug_786:
    $I10 = self.'from'()
    ne $I10, -1, rxscan970_done
    goto rxscan970_scan
  rxscan970_loop:
    (rx966_pos) = rx966_cur."from"()
    inc rx966_pos
    rx966_cur."!cursor_from"(rx966_pos)
    ge rx966_pos, rx966_eos, rxscan970_done
  rxscan970_scan:
    set_addr $I10, rxscan970_loop
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  rxscan970_done:
.annotate 'line', 434
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  alt972_0:
.annotate 'line', 435
    set_addr $I10, alt972_1
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
.annotate 'line', 436
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_974_fail
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx literal  "proto"
    add $I11, rx966_pos, 5
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 5
    ne $S10, "proto", rx966_fail
    add rx966_pos, 5
    set_addr $I10, rxcap_974_fail
    ($I12, $I11) = rx966_cur."!mark_peek"($I10)
    rx966_cur."!cursor_pos"($I11)
    ($P10) = rx966_cur."!cursor_start"()
    $P10."!cursor_pass"(rx966_pos, "")
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_974_done
  rxcap_974_fail:
    goto rx966_fail
  rxcap_974_done:
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  alt976_0:
    set_addr $I10, alt976_1
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx literal  "regex"
    add $I11, rx966_pos, 5
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 5
    ne $S10, "regex", rx966_fail
    add rx966_pos, 5
    goto alt976_end
  alt976_1:
    set_addr $I10, alt976_2
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx literal  "token"
    add $I11, rx966_pos, 5
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 5
    ne $S10, "token", rx966_fail
    add rx966_pos, 5
    goto alt976_end
  alt976_2:
  # rx literal  "rule"
    add $I11, rx966_pos, 4
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 4
    ne $S10, "rule", rx966_fail
    add rx966_pos, 4
  alt976_end:
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
.annotate 'line', 437
  # rx subrule "deflongname" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."deflongname"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx966_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  alt979_0:
.annotate 'line', 438
    set_addr $I10, alt979_1
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
.annotate 'line', 439
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 123, rx966_fail
    add rx966_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx966_pos, 5
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 5
    ne $S10, "<...>", rx966_fail
    add rx966_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 125, rx966_fail
    add rx966_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ENDSTMT"()
    unless $P10, rx966_fail
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
    goto alt979_end
  alt979_1:
    set_addr $I10, alt979_2
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 123, rx966_fail
    add rx966_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx966_pos, 3
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 3
    ne $S10, "<*>", rx966_fail
    add rx966_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 125, rx966_fail
    add rx966_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ENDSTMT"()
    unless $P10, rx966_fail
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
    goto alt979_end
  alt979_2:
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  alt979_end:
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
.annotate 'line', 436
    goto alt972_end
  alt972_1:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_993_fail
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  alt992_0:
    set_addr $I10, alt992_1
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx literal  "regex"
    add $I11, rx966_pos, 5
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 5
    ne $S10, "regex", rx966_fail
    add rx966_pos, 5
    goto alt992_end
  alt992_1:
    set_addr $I10, alt992_2
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  # rx literal  "token"
    add $I11, rx966_pos, 5
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 5
    ne $S10, "token", rx966_fail
    add rx966_pos, 5
    goto alt992_end
  alt992_2:
  # rx literal  "rule"
    add $I11, rx966_pos, 4
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    substr $S10, rx966_tgt, $I11, 4
    ne $S10, "rule", rx966_fail
    add rx966_pos, 4
  alt992_end:
    set_addr $I10, rxcap_993_fail
    ($I12, $I11) = rx966_cur."!mark_peek"($I10)
    rx966_cur."!cursor_pos"($I11)
    ($P10) = rx966_cur."!cursor_start"()
    $P10."!cursor_pass"(rx966_pos, "")
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_993_done
  rxcap_993_fail:
    goto rx966_fail
  rxcap_993_done:
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
.annotate 'line', 444
  # rx subrule "deflongname" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."deflongname"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx966_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
.annotate 'line', 445
  # rx subrule "newpad" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."newpad"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
.annotate 'line', 446
  # rx rxquantr997 ** 0..1
    set_addr $I10, rxquantr997_done
    rx966_cur."!mark_push"(0, rx966_pos, $I10)
  rxquantr997_loop:
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 40, rx966_fail
    add rx966_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."signature"()
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx966_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 41, rx966_fail
    add rx966_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
    set_addr $I10, rxquantr997_done
    (rx966_rep) = rx966_cur."!mark_commit"($I10)
  rxquantr997_done:
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
.annotate 'line', 447
  # rx reduce name="regex_declarator" key="open"
    rx966_cur."!cursor_pos"(rx966_pos)
    rx966_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
.annotate 'line', 448
  # rx literal  "{"
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 123, rx966_fail
    add rx966_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."LANG"("Regex", "nibbler")
    unless $P10, rx966_fail
    rx966_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx966_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx966_pos, 1
    gt $I11, rx966_eos, rx966_fail
    sub $I11, rx966_pos, rx966_off
    ord $I11, rx966_tgt, $I11
    ne $I11, 125, rx966_fail
    add rx966_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ENDSTMT"()
    unless $P10, rx966_fail
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
  alt972_end:
.annotate 'line', 449
  # rx subrule "ws" subtype=method negate=
    rx966_cur."!cursor_pos"(rx966_pos)
    $P10 = rx966_cur."ws"()
    unless $P10, rx966_fail
    rx966_pos = $P10."pos"()
.annotate 'line', 434
  # rx pass
    rx966_cur."!cursor_pass"(rx966_pos, "regex_declarator")
    if_null rx966_debug, debug_787
    rx966_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx966_pos)
  debug_787:
    .return (rx966_cur)
  rx966_restart:
.annotate 'line', 4
    if_null rx966_debug, debug_788
    rx966_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_788:
  rx966_fail:
    (rx966_rep, rx966_pos, $I10, $P10) = rx966_cur."!mark_fail"(0)
    lt rx966_pos, -1, rx966_done
    eq rx966_pos, -1, rx966_fail
    jump $I10
  rx966_done:
    rx966_cur."!cursor_fail"()
    if_null rx966_debug, debug_789
    rx966_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_789:
    .return (rx966_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("205_1298839231.515") :method
.annotate 'line', 4
    $P968 = self."!PREFIX__!subrule"("ws", "")
    new $P969, "ResizablePMCArray"
    push $P969, $P968
    .return ($P969)
.end


.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("206_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1007_tgt
    .local int rx1007_pos
    .local int rx1007_off
    .local int rx1007_eos
    .local int rx1007_rep
    .local pmc rx1007_cur
    .local pmc rx1007_debug
    (rx1007_cur, rx1007_pos, rx1007_tgt, $I10) = self."!cursor_start"()
    rx1007_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1007_cur
    .local pmc match
    .lex "$/", match
    length rx1007_eos, rx1007_tgt
    gt rx1007_pos, rx1007_eos, rx1007_done
    set rx1007_off, 0
    lt rx1007_pos, 2, rx1007_start
    sub rx1007_off, rx1007_pos, 1
    substr rx1007_tgt, rx1007_tgt, rx1007_off
  rx1007_start:
    eq $I10, 1, rx1007_restart
    if_null rx1007_debug, debug_790
    rx1007_cur."!cursor_debug"("START", "dotty")
  debug_790:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1011_done
    goto rxscan1011_scan
  rxscan1011_loop:
    (rx1007_pos) = rx1007_cur."from"()
    inc rx1007_pos
    rx1007_cur."!cursor_from"(rx1007_pos)
    ge rx1007_pos, rx1007_eos, rxscan1011_done
  rxscan1011_scan:
    set_addr $I10, rxscan1011_loop
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  rxscan1011_done:
.annotate 'line', 453
  # rx literal  "."
    add $I11, rx1007_pos, 1
    gt $I11, rx1007_eos, rx1007_fail
    sub $I11, rx1007_pos, rx1007_off
    ord $I11, rx1007_tgt, $I11
    ne $I11, 46, rx1007_fail
    add rx1007_pos, 1
  alt1012_0:
.annotate 'line', 454
    set_addr $I10, alt1012_1
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."deflongname"()
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1007_pos = $P10."pos"()
    goto alt1012_end
  alt1012_1:
.annotate 'line', 455
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1007_pos, rx1007_off
    substr $S10, rx1007_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1007_fail
  # rx subrule "quote" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."quote"()
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1007_pos = $P10."pos"()
  alt1013_0:
.annotate 'line', 456
    set_addr $I10, alt1013_1
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1007_pos, rx1007_off
    substr $S10, rx1007_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1007_fail
    goto alt1013_end
  alt1013_1:
  # rx subrule "panic" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  alt1013_end:
  alt1012_end:
.annotate 'line', 462
  # rx rxquantr1014 ** 0..1
    set_addr $I10, rxquantr1014_done
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  rxquantr1014_loop:
  alt1015_0:
.annotate 'line', 459
    set_addr $I10, alt1015_1
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
.annotate 'line', 460
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1007_pos, rx1007_off
    substr $S10, rx1007_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1007_fail
  # rx subrule "args" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."args"()
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1007_pos = $P10."pos"()
    goto alt1015_end
  alt1015_1:
.annotate 'line', 461
  # rx literal  ":"
    add $I11, rx1007_pos, 1
    gt $I11, rx1007_eos, rx1007_fail
    sub $I11, rx1007_pos, rx1007_off
    ord $I11, rx1007_tgt, $I11
    ne $I11, 58, rx1007_fail
    add rx1007_pos, 1
  # rx charclass s
    ge rx1007_pos, rx1007_eos, rx1007_fail
    sub $I10, rx1007_pos, rx1007_off
    is_cclass $I11, 32, rx1007_tgt, $I10
    unless $I11, rx1007_fail
    inc rx1007_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."arglist"()
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1007_pos = $P10."pos"()
  alt1015_end:
.annotate 'line', 462
    set_addr $I10, rxquantr1014_done
    (rx1007_rep) = rx1007_cur."!mark_commit"($I10)
  rxquantr1014_done:
.annotate 'line', 452
  # rx pass
    rx1007_cur."!cursor_pass"(rx1007_pos, "dotty")
    if_null rx1007_debug, debug_791
    rx1007_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1007_pos)
  debug_791:
    .return (rx1007_cur)
  rx1007_restart:
.annotate 'line', 4
    if_null rx1007_debug, debug_792
    rx1007_cur."!cursor_debug"("NEXT", "dotty")
  debug_792:
  rx1007_fail:
    (rx1007_rep, rx1007_pos, $I10, $P10) = rx1007_cur."!mark_fail"(0)
    lt rx1007_pos, -1, rx1007_done
    eq rx1007_pos, -1, rx1007_fail
    jump $I10
  rx1007_done:
    rx1007_cur."!cursor_fail"()
    if_null rx1007_debug, debug_793
    rx1007_cur."!cursor_debug"("FAIL", "dotty")
  debug_793:
    .return (rx1007_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("207_1298839231.515") :method
.annotate 'line', 4
    $P1009 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1010, "ResizablePMCArray"
    push $P1010, "'"
    push $P1010, "\""
    push $P1010, $P1009
    .return ($P1010)
.end


.namespace ["NQP";"Grammar"]
.sub "term"  :subid("208_1298839231.515")
    .param pmc param_1017
.annotate 'line', 466
    .lex "self", param_1017
    $P1018 = param_1017."!protoregex"("term")
    .return ($P1018)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("209_1298839231.515")
    .param pmc param_1020
.annotate 'line', 466
    .lex "self", param_1020
    $P1021 = param_1020."!PREFIX__!protoregex"("term")
    .return ($P1021)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("210_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1023_tgt
    .local int rx1023_pos
    .local int rx1023_off
    .local int rx1023_eos
    .local int rx1023_rep
    .local pmc rx1023_cur
    .local pmc rx1023_debug
    (rx1023_cur, rx1023_pos, rx1023_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1023_cur
    .local pmc match
    .lex "$/", match
    length rx1023_eos, rx1023_tgt
    gt rx1023_pos, rx1023_eos, rx1023_done
    set rx1023_off, 0
    lt rx1023_pos, 2, rx1023_start
    sub rx1023_off, rx1023_pos, 1
    substr rx1023_tgt, rx1023_tgt, rx1023_off
  rx1023_start:
    eq $I10, 1, rx1023_restart
    if_null rx1023_debug, debug_794
    rx1023_cur."!cursor_debug"("START", "term:sym<self>")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1026_done
    goto rxscan1026_scan
  rxscan1026_loop:
    (rx1023_pos) = rx1023_cur."from"()
    inc rx1023_pos
    rx1023_cur."!cursor_from"(rx1023_pos)
    ge rx1023_pos, rx1023_eos, rxscan1026_done
  rxscan1026_scan:
    set_addr $I10, rxscan1026_loop
    rx1023_cur."!mark_push"(0, rx1023_pos, $I10)
  rxscan1026_done:
.annotate 'line', 468
  # rx subcapture "sym"
    set_addr $I10, rxcap_1027_fail
    rx1023_cur."!mark_push"(0, rx1023_pos, $I10)
  # rx literal  "self"
    add $I11, rx1023_pos, 4
    gt $I11, rx1023_eos, rx1023_fail
    sub $I11, rx1023_pos, rx1023_off
    substr $S10, rx1023_tgt, $I11, 4
    ne $S10, "self", rx1023_fail
    add rx1023_pos, 4
    set_addr $I10, rxcap_1027_fail
    ($I12, $I11) = rx1023_cur."!mark_peek"($I10)
    rx1023_cur."!cursor_pos"($I11)
    ($P10) = rx1023_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1023_pos, "")
    rx1023_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1027_done
  rxcap_1027_fail:
    goto rx1023_fail
  rxcap_1027_done:
  # rxanchor rwb
    le rx1023_pos, 0, rx1023_fail
    sub $I10, rx1023_pos, rx1023_off
    is_cclass $I11, 8192, rx1023_tgt, $I10
    if $I11, rx1023_fail
    dec $I10
    is_cclass $I11, 8192, rx1023_tgt, $I10
    unless $I11, rx1023_fail
  # rx pass
    rx1023_cur."!cursor_pass"(rx1023_pos, "term:sym<self>")
    if_null rx1023_debug, debug_795
    rx1023_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1023_pos)
  debug_795:
    .return (rx1023_cur)
  rx1023_restart:
.annotate 'line', 4
    if_null rx1023_debug, debug_796
    rx1023_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_796:
  rx1023_fail:
    (rx1023_rep, rx1023_pos, $I10, $P10) = rx1023_cur."!mark_fail"(0)
    lt rx1023_pos, -1, rx1023_done
    eq rx1023_pos, -1, rx1023_fail
    jump $I10
  rx1023_done:
    rx1023_cur."!cursor_fail"()
    if_null rx1023_debug, debug_797
    rx1023_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_797:
    .return (rx1023_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("211_1298839231.515") :method
.annotate 'line', 4
    new $P1025, "ResizablePMCArray"
    push $P1025, "self"
    .return ($P1025)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("212_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1029_tgt
    .local int rx1029_pos
    .local int rx1029_off
    .local int rx1029_eos
    .local int rx1029_rep
    .local pmc rx1029_cur
    .local pmc rx1029_debug
    (rx1029_cur, rx1029_pos, rx1029_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1029_cur
    .local pmc match
    .lex "$/", match
    length rx1029_eos, rx1029_tgt
    gt rx1029_pos, rx1029_eos, rx1029_done
    set rx1029_off, 0
    lt rx1029_pos, 2, rx1029_start
    sub rx1029_off, rx1029_pos, 1
    substr rx1029_tgt, rx1029_tgt, rx1029_off
  rx1029_start:
    eq $I10, 1, rx1029_restart
    if_null rx1029_debug, debug_798
    rx1029_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_798:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1033_done
    goto rxscan1033_scan
  rxscan1033_loop:
    (rx1029_pos) = rx1029_cur."from"()
    inc rx1029_pos
    rx1029_cur."!cursor_from"(rx1029_pos)
    ge rx1029_pos, rx1029_eos, rxscan1033_done
  rxscan1033_scan:
    set_addr $I10, rxscan1033_loop
    rx1029_cur."!mark_push"(0, rx1029_pos, $I10)
  rxscan1033_done:
.annotate 'line', 471
  # rx subrule "deflongname" subtype=capture negate=
    rx1029_cur."!cursor_pos"(rx1029_pos)
    $P10 = rx1029_cur."deflongname"()
    unless $P10, rx1029_fail
    rx1029_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1029_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1029_pos, rx1029_off
    substr $S10, rx1029_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1029_fail
  # rx subrule "args" subtype=capture negate=
    rx1029_cur."!cursor_pos"(rx1029_pos)
    $P10 = rx1029_cur."args"()
    unless $P10, rx1029_fail
    rx1029_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1029_pos = $P10."pos"()
.annotate 'line', 470
  # rx pass
    rx1029_cur."!cursor_pass"(rx1029_pos, "term:sym<identifier>")
    if_null rx1029_debug, debug_799
    rx1029_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1029_pos)
  debug_799:
    .return (rx1029_cur)
  rx1029_restart:
.annotate 'line', 4
    if_null rx1029_debug, debug_800
    rx1029_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_800:
  rx1029_fail:
    (rx1029_rep, rx1029_pos, $I10, $P10) = rx1029_cur."!mark_fail"(0)
    lt rx1029_pos, -1, rx1029_done
    eq rx1029_pos, -1, rx1029_fail
    jump $I10
  rx1029_done:
    rx1029_cur."!cursor_fail"()
    if_null rx1029_debug, debug_801
    rx1029_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_801:
    .return (rx1029_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("213_1298839231.515") :method
.annotate 'line', 4
    $P1031 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1032, "ResizablePMCArray"
    push $P1032, $P1031
    .return ($P1032)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("214_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1035_tgt
    .local int rx1035_pos
    .local int rx1035_off
    .local int rx1035_eos
    .local int rx1035_rep
    .local pmc rx1035_cur
    .local pmc rx1035_debug
    (rx1035_cur, rx1035_pos, rx1035_tgt, $I10) = self."!cursor_start"()
    rx1035_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1035_cur
    .local pmc match
    .lex "$/", match
    length rx1035_eos, rx1035_tgt
    gt rx1035_pos, rx1035_eos, rx1035_done
    set rx1035_off, 0
    lt rx1035_pos, 2, rx1035_start
    sub rx1035_off, rx1035_pos, 1
    substr rx1035_tgt, rx1035_tgt, rx1035_off
  rx1035_start:
    eq $I10, 1, rx1035_restart
    if_null rx1035_debug, debug_802
    rx1035_cur."!cursor_debug"("START", "term:sym<name>")
  debug_802:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1039_done
    goto rxscan1039_scan
  rxscan1039_loop:
    (rx1035_pos) = rx1035_cur."from"()
    inc rx1035_pos
    rx1035_cur."!cursor_from"(rx1035_pos)
    ge rx1035_pos, rx1035_eos, rxscan1039_done
  rxscan1039_scan:
    set_addr $I10, rxscan1039_loop
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10)
  rxscan1039_done:
.annotate 'line', 475
  # rx subrule "name" subtype=capture negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."name"()
    unless $P10, rx1035_fail
    rx1035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1035_pos = $P10."pos"()
  # rx rxquantr1040 ** 0..1
    set_addr $I10, rxquantr1040_done
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10)
  rxquantr1040_loop:
  # rx subrule "args" subtype=capture negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."args"()
    unless $P10, rx1035_fail
    goto rxsubrule1041_pass
  rxsubrule1041_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1035_fail
  rxsubrule1041_pass:
    set_addr $I10, rxsubrule1041_back
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1035_pos = $P10."pos"()
    set_addr $I10, rxquantr1040_done
    (rx1035_rep) = rx1035_cur."!mark_commit"($I10)
  rxquantr1040_done:
.annotate 'line', 474
  # rx pass
    rx1035_cur."!cursor_pass"(rx1035_pos, "term:sym<name>")
    if_null rx1035_debug, debug_803
    rx1035_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1035_pos)
  debug_803:
    .return (rx1035_cur)
  rx1035_restart:
.annotate 'line', 4
    if_null rx1035_debug, debug_804
    rx1035_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_804:
  rx1035_fail:
    (rx1035_rep, rx1035_pos, $I10, $P10) = rx1035_cur."!mark_fail"(0)
    lt rx1035_pos, -1, rx1035_done
    eq rx1035_pos, -1, rx1035_fail
    jump $I10
  rx1035_done:
    rx1035_cur."!cursor_fail"()
    if_null rx1035_debug, debug_805
    rx1035_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_805:
    .return (rx1035_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("215_1298839231.515") :method
.annotate 'line', 4
    $P1037 = self."!PREFIX__!subrule"("name", "")
    new $P1038, "ResizablePMCArray"
    push $P1038, $P1037
    .return ($P1038)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("216_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1043_tgt
    .local int rx1043_pos
    .local int rx1043_off
    .local int rx1043_eos
    .local int rx1043_rep
    .local pmc rx1043_cur
    .local pmc rx1043_debug
    (rx1043_cur, rx1043_pos, rx1043_tgt, $I10) = self."!cursor_start"()
    rx1043_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1043_cur
    .local pmc match
    .lex "$/", match
    length rx1043_eos, rx1043_tgt
    gt rx1043_pos, rx1043_eos, rx1043_done
    set rx1043_off, 0
    lt rx1043_pos, 2, rx1043_start
    sub rx1043_off, rx1043_pos, 1
    substr rx1043_tgt, rx1043_tgt, rx1043_off
  rx1043_start:
    eq $I10, 1, rx1043_restart
    if_null rx1043_debug, debug_806
    rx1043_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_806:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1046_done
    goto rxscan1046_scan
  rxscan1046_loop:
    (rx1043_pos) = rx1043_cur."from"()
    inc rx1043_pos
    rx1043_cur."!cursor_from"(rx1043_pos)
    ge rx1043_pos, rx1043_eos, rxscan1046_done
  rxscan1046_scan:
    set_addr $I10, rxscan1046_loop
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10)
  rxscan1046_done:
.annotate 'line', 479
  # rx literal  "pir::"
    add $I11, rx1043_pos, 5
    gt $I11, rx1043_eos, rx1043_fail
    sub $I11, rx1043_pos, rx1043_off
    substr $S10, rx1043_tgt, $I11, 5
    ne $S10, "pir::", rx1043_fail
    add rx1043_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1047_fail
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1043_pos, rx1043_off
    find_not_cclass $I11, 8192, rx1043_tgt, $I10, rx1043_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1043_fail
    add rx1043_pos, rx1043_off, $I11
    set_addr $I10, rxcap_1047_fail
    ($I12, $I11) = rx1043_cur."!mark_peek"($I10)
    rx1043_cur."!cursor_pos"($I11)
    ($P10) = rx1043_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1043_pos, "")
    rx1043_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1047_done
  rxcap_1047_fail:
    goto rx1043_fail
  rxcap_1047_done:
  # rx rxquantr1048 ** 0..1
    set_addr $I10, rxquantr1048_done
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10)
  rxquantr1048_loop:
  # rx subrule "args" subtype=capture negate=
    rx1043_cur."!cursor_pos"(rx1043_pos)
    $P10 = rx1043_cur."args"()
    unless $P10, rx1043_fail
    goto rxsubrule1049_pass
  rxsubrule1049_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1043_fail
  rxsubrule1049_pass:
    set_addr $I10, rxsubrule1049_back
    rx1043_cur."!mark_push"(0, rx1043_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1043_pos = $P10."pos"()
    set_addr $I10, rxquantr1048_done
    (rx1043_rep) = rx1043_cur."!mark_commit"($I10)
  rxquantr1048_done:
.annotate 'line', 478
  # rx pass
    rx1043_cur."!cursor_pass"(rx1043_pos, "term:sym<pir::op>")
    if_null rx1043_debug, debug_807
    rx1043_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1043_pos)
  debug_807:
    .return (rx1043_cur)
  rx1043_restart:
.annotate 'line', 4
    if_null rx1043_debug, debug_808
    rx1043_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_808:
  rx1043_fail:
    (rx1043_rep, rx1043_pos, $I10, $P10) = rx1043_cur."!mark_fail"(0)
    lt rx1043_pos, -1, rx1043_done
    eq rx1043_pos, -1, rx1043_fail
    jump $I10
  rx1043_done:
    rx1043_cur."!cursor_fail"()
    if_null rx1043_debug, debug_809
    rx1043_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_809:
    .return (rx1043_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("217_1298839231.515") :method
.annotate 'line', 4
    new $P1045, "ResizablePMCArray"
    push $P1045, "pir::"
    .return ($P1045)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("218_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P1059 = "220_1298839231.515" 
    capture_lex $P1059
    .local string rx1051_tgt
    .local int rx1051_pos
    .local int rx1051_off
    .local int rx1051_eos
    .local int rx1051_rep
    .local pmc rx1051_cur
    .local pmc rx1051_debug
    (rx1051_cur, rx1051_pos, rx1051_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1051_cur
    .local pmc match
    .lex "$/", match
    length rx1051_eos, rx1051_tgt
    gt rx1051_pos, rx1051_eos, rx1051_done
    set rx1051_off, 0
    lt rx1051_pos, 2, rx1051_start
    sub rx1051_off, rx1051_pos, 1
    substr rx1051_tgt, rx1051_tgt, rx1051_off
  rx1051_start:
    eq $I10, 1, rx1051_restart
    if_null rx1051_debug, debug_810
    rx1051_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1054_done
    goto rxscan1054_scan
  rxscan1054_loop:
    (rx1051_pos) = rx1051_cur."from"()
    inc rx1051_pos
    rx1051_cur."!cursor_from"(rx1051_pos)
    ge rx1051_pos, rx1051_eos, rxscan1054_done
  rxscan1054_scan:
    set_addr $I10, rxscan1054_loop
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
  rxscan1054_done:
.annotate 'line', 483
  # rx literal  "{*}"
    add $I11, rx1051_pos, 3
    gt $I11, rx1051_eos, rx1051_fail
    sub $I11, rx1051_pos, rx1051_off
    substr $S10, rx1051_tgt, $I11, 3
    ne $S10, "{*}", rx1051_fail
    add rx1051_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1051_cur."!cursor_pos"(rx1051_pos)
    $P10 = rx1051_cur."ENDSTMT"()
    unless $P10, rx1051_fail
  alt1055_0:
.annotate 'line', 484
    set_addr $I10, alt1055_1
    rx1051_cur."!mark_push"(0, rx1051_pos, $I10)
    rx1051_cur."!cursor_pos"(rx1051_pos)
    find_lex $P1056, unicode:"$\x{a2}"
    $P1057 = $P1056."MATCH"()
    store_lex "$/", $P1057
    .const 'Sub' $P1059 = "220_1298839231.515" 
    capture_lex $P1059
    $P1063 = $P1059()
    unless $P1063, rx1051_fail
    goto alt1055_end
  alt1055_1:
  # rx subrule "panic" subtype=method negate=
    rx1051_cur."!cursor_pos"(rx1051_pos)
    $P10 = rx1051_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1051_fail
    rx1051_pos = $P10."pos"()
  alt1055_end:
.annotate 'line', 482
  # rx pass
    rx1051_cur."!cursor_pass"(rx1051_pos, "term:sym<onlystar>")
    if_null rx1051_debug, debug_813
    rx1051_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1051_pos)
  debug_813:
    .return (rx1051_cur)
  rx1051_restart:
.annotate 'line', 4
    if_null rx1051_debug, debug_814
    rx1051_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_814:
  rx1051_fail:
    (rx1051_rep, rx1051_pos, $I10, $P10) = rx1051_cur."!mark_fail"(0)
    lt rx1051_pos, -1, rx1051_done
    eq rx1051_pos, -1, rx1051_fail
    jump $I10
  rx1051_done:
    rx1051_cur."!cursor_fail"()
    if_null rx1051_debug, debug_815
    rx1051_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_815:
    .return (rx1051_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("219_1298839231.515") :method
.annotate 'line', 4
    new $P1053, "ResizablePMCArray"
    push $P1053, "{*}"
    .return ($P1053)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1058"  :anon :subid("220_1298839231.515") :outer("218_1298839231.515")
.annotate 'line', 484
    find_dynamic_lex $P1060, "$*MULTINESS"
    unless_null $P1060, vivify_811
    get_hll_global $P1060, "$MULTINESS"
    unless_null $P1060, vivify_812
    die "Contextual $*MULTINESS not found"
  vivify_812:
  vivify_811:
    set $S1061, $P1060
    iseq $I1062, $S1061, "proto"
    .return ($I1062)
.end


.namespace ["NQP";"Grammar"]
.sub "args"  :subid("221_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1065_tgt
    .local int rx1065_pos
    .local int rx1065_off
    .local int rx1065_eos
    .local int rx1065_rep
    .local pmc rx1065_cur
    .local pmc rx1065_debug
    (rx1065_cur, rx1065_pos, rx1065_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1065_cur
    .local pmc match
    .lex "$/", match
    length rx1065_eos, rx1065_tgt
    gt rx1065_pos, rx1065_eos, rx1065_done
    set rx1065_off, 0
    lt rx1065_pos, 2, rx1065_start
    sub rx1065_off, rx1065_pos, 1
    substr rx1065_tgt, rx1065_tgt, rx1065_off
  rx1065_start:
    eq $I10, 1, rx1065_restart
    if_null rx1065_debug, debug_816
    rx1065_cur."!cursor_debug"("START", "args")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1069_done
    goto rxscan1069_scan
  rxscan1069_loop:
    (rx1065_pos) = rx1065_cur."from"()
    inc rx1065_pos
    rx1065_cur."!cursor_from"(rx1065_pos)
    ge rx1065_pos, rx1065_eos, rxscan1069_done
  rxscan1069_scan:
    set_addr $I10, rxscan1069_loop
    rx1065_cur."!mark_push"(0, rx1065_pos, $I10)
  rxscan1069_done:
.annotate 'line', 488
  # rx literal  "("
    add $I11, rx1065_pos, 1
    gt $I11, rx1065_eos, rx1065_fail
    sub $I11, rx1065_pos, rx1065_off
    ord $I11, rx1065_tgt, $I11
    ne $I11, 40, rx1065_fail
    add rx1065_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1065_cur."!cursor_pos"(rx1065_pos)
    $P10 = rx1065_cur."arglist"()
    unless $P10, rx1065_fail
    rx1065_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1065_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1065_pos, 1
    gt $I11, rx1065_eos, rx1065_fail
    sub $I11, rx1065_pos, rx1065_off
    ord $I11, rx1065_tgt, $I11
    ne $I11, 41, rx1065_fail
    add rx1065_pos, 1
  # rx pass
    rx1065_cur."!cursor_pass"(rx1065_pos, "args")
    if_null rx1065_debug, debug_817
    rx1065_cur."!cursor_debug"("PASS", "args", " at pos=", rx1065_pos)
  debug_817:
    .return (rx1065_cur)
  rx1065_restart:
.annotate 'line', 4
    if_null rx1065_debug, debug_818
    rx1065_cur."!cursor_debug"("NEXT", "args")
  debug_818:
  rx1065_fail:
    (rx1065_rep, rx1065_pos, $I10, $P10) = rx1065_cur."!mark_fail"(0)
    lt rx1065_pos, -1, rx1065_done
    eq rx1065_pos, -1, rx1065_fail
    jump $I10
  rx1065_done:
    rx1065_cur."!cursor_fail"()
    if_null rx1065_debug, debug_819
    rx1065_cur."!cursor_debug"("FAIL", "args")
  debug_819:
    .return (rx1065_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("222_1298839231.515") :method
.annotate 'line', 4
    $P1067 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1068, "ResizablePMCArray"
    push $P1068, $P1067
    .return ($P1068)
.end


.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("223_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1071_tgt
    .local int rx1071_pos
    .local int rx1071_off
    .local int rx1071_eos
    .local int rx1071_rep
    .local pmc rx1071_cur
    .local pmc rx1071_debug
    (rx1071_cur, rx1071_pos, rx1071_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1071_cur
    .local pmc match
    .lex "$/", match
    length rx1071_eos, rx1071_tgt
    gt rx1071_pos, rx1071_eos, rx1071_done
    set rx1071_off, 0
    lt rx1071_pos, 2, rx1071_start
    sub rx1071_off, rx1071_pos, 1
    substr rx1071_tgt, rx1071_tgt, rx1071_off
  rx1071_start:
    eq $I10, 1, rx1071_restart
    if_null rx1071_debug, debug_820
    rx1071_cur."!cursor_debug"("START", "arglist")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1075_done
    goto rxscan1075_scan
  rxscan1075_loop:
    (rx1071_pos) = rx1071_cur."from"()
    inc rx1071_pos
    rx1071_cur."!cursor_from"(rx1071_pos)
    ge rx1071_pos, rx1071_eos, rxscan1075_done
  rxscan1075_scan:
    set_addr $I10, rxscan1075_loop
    rx1071_cur."!mark_push"(0, rx1071_pos, $I10)
  rxscan1075_done:
.annotate 'line', 492
  # rx subrule "ws" subtype=method negate=
    rx1071_cur."!cursor_pos"(rx1071_pos)
    $P10 = rx1071_cur."ws"()
    unless $P10, rx1071_fail
    rx1071_pos = $P10."pos"()
  alt1076_0:
.annotate 'line', 493
    set_addr $I10, alt1076_1
    rx1071_cur."!mark_push"(0, rx1071_pos, $I10)
.annotate 'line', 494
  # rx subrule "EXPR" subtype=capture negate=
    rx1071_cur."!cursor_pos"(rx1071_pos)
    $P10 = rx1071_cur."EXPR"("f=")
    unless $P10, rx1071_fail
    rx1071_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1071_pos = $P10."pos"()
    goto alt1076_end
  alt1076_1:
  alt1076_end:
.annotate 'line', 491
  # rx pass
    rx1071_cur."!cursor_pass"(rx1071_pos, "arglist")
    if_null rx1071_debug, debug_821
    rx1071_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1071_pos)
  debug_821:
    .return (rx1071_cur)
  rx1071_restart:
.annotate 'line', 4
    if_null rx1071_debug, debug_822
    rx1071_cur."!cursor_debug"("NEXT", "arglist")
  debug_822:
  rx1071_fail:
    (rx1071_rep, rx1071_pos, $I10, $P10) = rx1071_cur."!mark_fail"(0)
    lt rx1071_pos, -1, rx1071_done
    eq rx1071_pos, -1, rx1071_fail
    jump $I10
  rx1071_done:
    rx1071_cur."!cursor_fail"()
    if_null rx1071_debug, debug_823
    rx1071_cur."!cursor_debug"("FAIL", "arglist")
  debug_823:
    .return (rx1071_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("224_1298839231.515") :method
.annotate 'line', 4
    $P1073 = self."!PREFIX__!subrule"("ws", "")
    new $P1074, "ResizablePMCArray"
    push $P1074, $P1073
    .return ($P1074)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("225_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1078_tgt
    .local int rx1078_pos
    .local int rx1078_off
    .local int rx1078_eos
    .local int rx1078_rep
    .local pmc rx1078_cur
    .local pmc rx1078_debug
    (rx1078_cur, rx1078_pos, rx1078_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1078_cur
    .local pmc match
    .lex "$/", match
    length rx1078_eos, rx1078_tgt
    gt rx1078_pos, rx1078_eos, rx1078_done
    set rx1078_off, 0
    lt rx1078_pos, 2, rx1078_start
    sub rx1078_off, rx1078_pos, 1
    substr rx1078_tgt, rx1078_tgt, rx1078_off
  rx1078_start:
    eq $I10, 1, rx1078_restart
    if_null rx1078_debug, debug_824
    rx1078_cur."!cursor_debug"("START", "term:sym<value>")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1082_done
    goto rxscan1082_scan
  rxscan1082_loop:
    (rx1078_pos) = rx1078_cur."from"()
    inc rx1078_pos
    rx1078_cur."!cursor_from"(rx1078_pos)
    ge rx1078_pos, rx1078_eos, rxscan1082_done
  rxscan1082_scan:
    set_addr $I10, rxscan1082_loop
    rx1078_cur."!mark_push"(0, rx1078_pos, $I10)
  rxscan1082_done:
.annotate 'line', 500
  # rx subrule "value" subtype=capture negate=
    rx1078_cur."!cursor_pos"(rx1078_pos)
    $P10 = rx1078_cur."value"()
    unless $P10, rx1078_fail
    rx1078_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1078_pos = $P10."pos"()
  # rx pass
    rx1078_cur."!cursor_pass"(rx1078_pos, "term:sym<value>")
    if_null rx1078_debug, debug_825
    rx1078_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1078_pos)
  debug_825:
    .return (rx1078_cur)
  rx1078_restart:
.annotate 'line', 4
    if_null rx1078_debug, debug_826
    rx1078_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_826:
  rx1078_fail:
    (rx1078_rep, rx1078_pos, $I10, $P10) = rx1078_cur."!mark_fail"(0)
    lt rx1078_pos, -1, rx1078_done
    eq rx1078_pos, -1, rx1078_fail
    jump $I10
  rx1078_done:
    rx1078_cur."!cursor_fail"()
    if_null rx1078_debug, debug_827
    rx1078_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_827:
    .return (rx1078_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("226_1298839231.515") :method
.annotate 'line', 4
    $P1080 = self."!PREFIX__!subrule"("value", "")
    new $P1081, "ResizablePMCArray"
    push $P1081, $P1080
    .return ($P1081)
.end


.namespace ["NQP";"Grammar"]
.sub "value"  :subid("227_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1084_tgt
    .local int rx1084_pos
    .local int rx1084_off
    .local int rx1084_eos
    .local int rx1084_rep
    .local pmc rx1084_cur
    .local pmc rx1084_debug
    (rx1084_cur, rx1084_pos, rx1084_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1084_cur
    .local pmc match
    .lex "$/", match
    length rx1084_eos, rx1084_tgt
    gt rx1084_pos, rx1084_eos, rx1084_done
    set rx1084_off, 0
    lt rx1084_pos, 2, rx1084_start
    sub rx1084_off, rx1084_pos, 1
    substr rx1084_tgt, rx1084_tgt, rx1084_off
  rx1084_start:
    eq $I10, 1, rx1084_restart
    if_null rx1084_debug, debug_828
    rx1084_cur."!cursor_debug"("START", "value")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1089_done
    goto rxscan1089_scan
  rxscan1089_loop:
    (rx1084_pos) = rx1084_cur."from"()
    inc rx1084_pos
    rx1084_cur."!cursor_from"(rx1084_pos)
    ge rx1084_pos, rx1084_eos, rxscan1089_done
  rxscan1089_scan:
    set_addr $I10, rxscan1089_loop
    rx1084_cur."!mark_push"(0, rx1084_pos, $I10)
  rxscan1089_done:
  alt1090_0:
.annotate 'line', 502
    set_addr $I10, alt1090_1
    rx1084_cur."!mark_push"(0, rx1084_pos, $I10)
.annotate 'line', 503
  # rx subrule "quote" subtype=capture negate=
    rx1084_cur."!cursor_pos"(rx1084_pos)
    $P10 = rx1084_cur."quote"()
    unless $P10, rx1084_fail
    rx1084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1084_pos = $P10."pos"()
    goto alt1090_end
  alt1090_1:
.annotate 'line', 504
  # rx subrule "number" subtype=capture negate=
    rx1084_cur."!cursor_pos"(rx1084_pos)
    $P10 = rx1084_cur."number"()
    unless $P10, rx1084_fail
    rx1084_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1084_pos = $P10."pos"()
  alt1090_end:
.annotate 'line', 502
  # rx pass
    rx1084_cur."!cursor_pass"(rx1084_pos, "value")
    if_null rx1084_debug, debug_829
    rx1084_cur."!cursor_debug"("PASS", "value", " at pos=", rx1084_pos)
  debug_829:
    .return (rx1084_cur)
  rx1084_restart:
.annotate 'line', 4
    if_null rx1084_debug, debug_830
    rx1084_cur."!cursor_debug"("NEXT", "value")
  debug_830:
  rx1084_fail:
    (rx1084_rep, rx1084_pos, $I10, $P10) = rx1084_cur."!mark_fail"(0)
    lt rx1084_pos, -1, rx1084_done
    eq rx1084_pos, -1, rx1084_fail
    jump $I10
  rx1084_done:
    rx1084_cur."!cursor_fail"()
    if_null rx1084_debug, debug_831
    rx1084_cur."!cursor_debug"("FAIL", "value")
  debug_831:
    .return (rx1084_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("228_1298839231.515") :method
.annotate 'line', 4
    $P1086 = self."!PREFIX__!subrule"("number", "")
    $P1087 = self."!PREFIX__!subrule"("quote", "")
    new $P1088, "ResizablePMCArray"
    push $P1088, $P1086
    push $P1088, $P1087
    .return ($P1088)
.end


.namespace ["NQP";"Grammar"]
.sub "number"  :subid("229_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1092_tgt
    .local int rx1092_pos
    .local int rx1092_off
    .local int rx1092_eos
    .local int rx1092_rep
    .local pmc rx1092_cur
    .local pmc rx1092_debug
    (rx1092_cur, rx1092_pos, rx1092_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1092_cur
    .local pmc match
    .lex "$/", match
    length rx1092_eos, rx1092_tgt
    gt rx1092_pos, rx1092_eos, rx1092_done
    set rx1092_off, 0
    lt rx1092_pos, 2, rx1092_start
    sub rx1092_off, rx1092_pos, 1
    substr rx1092_tgt, rx1092_tgt, rx1092_off
  rx1092_start:
    eq $I10, 1, rx1092_restart
    if_null rx1092_debug, debug_832
    rx1092_cur."!cursor_debug"("START", "number")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1095_done
    goto rxscan1095_scan
  rxscan1095_loop:
    (rx1092_pos) = rx1092_cur."from"()
    inc rx1092_pos
    rx1092_cur."!cursor_from"(rx1092_pos)
    ge rx1092_pos, rx1092_eos, rxscan1095_done
  rxscan1095_scan:
    set_addr $I10, rxscan1095_loop
    rx1092_cur."!mark_push"(0, rx1092_pos, $I10)
  rxscan1095_done:
.annotate 'line', 508
  # rx subcapture "sign"
    set_addr $I10, rxcap_1097_fail
    rx1092_cur."!mark_push"(0, rx1092_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1092_pos, rx1092_off
    set rx1092_rep, 0
    sub $I12, rx1092_eos, rx1092_pos
    le $I12, 1, rxenumcharlistq1096_loop
    set $I12, 1
  rxenumcharlistq1096_loop:
    le $I12, 0, rxenumcharlistq1096_done
    substr $S10, rx1092_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1096_done
    inc rx1092_rep
  rxenumcharlistq1096_done:
    add rx1092_pos, rx1092_pos, rx1092_rep
    set_addr $I10, rxcap_1097_fail
    ($I12, $I11) = rx1092_cur."!mark_peek"($I10)
    rx1092_cur."!cursor_pos"($I11)
    ($P10) = rx1092_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1092_pos, "")
    rx1092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1097_done
  rxcap_1097_fail:
    goto rx1092_fail
  rxcap_1097_done:
  alt1098_0:
.annotate 'line', 509
    set_addr $I10, alt1098_1
    rx1092_cur."!mark_push"(0, rx1092_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1092_cur."!cursor_pos"(rx1092_pos)
    $P10 = rx1092_cur."dec_number"()
    unless $P10, rx1092_fail
    rx1092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1092_pos = $P10."pos"()
    goto alt1098_end
  alt1098_1:
  # rx subrule "integer" subtype=capture negate=
    rx1092_cur."!cursor_pos"(rx1092_pos)
    $P10 = rx1092_cur."integer"()
    unless $P10, rx1092_fail
    rx1092_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1092_pos = $P10."pos"()
  alt1098_end:
.annotate 'line', 507
  # rx pass
    rx1092_cur."!cursor_pass"(rx1092_pos, "number")
    if_null rx1092_debug, debug_833
    rx1092_cur."!cursor_debug"("PASS", "number", " at pos=", rx1092_pos)
  debug_833:
    .return (rx1092_cur)
  rx1092_restart:
.annotate 'line', 4
    if_null rx1092_debug, debug_834
    rx1092_cur."!cursor_debug"("NEXT", "number")
  debug_834:
  rx1092_fail:
    (rx1092_rep, rx1092_pos, $I10, $P10) = rx1092_cur."!mark_fail"(0)
    lt rx1092_pos, -1, rx1092_done
    eq rx1092_pos, -1, rx1092_fail
    jump $I10
  rx1092_done:
    rx1092_cur."!cursor_fail"()
    if_null rx1092_debug, debug_835
    rx1092_cur."!cursor_debug"("FAIL", "number")
  debug_835:
    .return (rx1092_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("230_1298839231.515") :method
.annotate 'line', 4
    new $P1094, "ResizablePMCArray"
    push $P1094, ""
    .return ($P1094)
.end


.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("231_1298839231.515")
    .param pmc param_1100
.annotate 'line', 512
    .lex "self", param_1100
    $P1101 = param_1100."!protoregex"("quote")
    .return ($P1101)
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("232_1298839231.515")
    .param pmc param_1103
.annotate 'line', 512
    .lex "self", param_1103
    $P1104 = param_1103."!PREFIX__!protoregex"("quote")
    .return ($P1104)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("233_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1106_tgt
    .local int rx1106_pos
    .local int rx1106_off
    .local int rx1106_eos
    .local int rx1106_rep
    .local pmc rx1106_cur
    .local pmc rx1106_debug
    (rx1106_cur, rx1106_pos, rx1106_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1106_cur
    .local pmc match
    .lex "$/", match
    length rx1106_eos, rx1106_tgt
    gt rx1106_pos, rx1106_eos, rx1106_done
    set rx1106_off, 0
    lt rx1106_pos, 2, rx1106_start
    sub rx1106_off, rx1106_pos, 1
    substr rx1106_tgt, rx1106_tgt, rx1106_off
  rx1106_start:
    eq $I10, 1, rx1106_restart
    if_null rx1106_debug, debug_836
    rx1106_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1109_done
    goto rxscan1109_scan
  rxscan1109_loop:
    (rx1106_pos) = rx1106_cur."from"()
    inc rx1106_pos
    rx1106_cur."!cursor_from"(rx1106_pos)
    ge rx1106_pos, rx1106_eos, rxscan1109_done
  rxscan1109_scan:
    set_addr $I10, rxscan1109_loop
    rx1106_cur."!mark_push"(0, rx1106_pos, $I10)
  rxscan1109_done:
.annotate 'line', 513
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1106_pos, rx1106_off
    substr $S10, rx1106_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1106_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1106_cur."!cursor_pos"(rx1106_pos)
    $P10 = rx1106_cur."quote_EXPR"(":q")
    unless $P10, rx1106_fail
    rx1106_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1106_pos = $P10."pos"()
  # rx pass
    rx1106_cur."!cursor_pass"(rx1106_pos, "quote:sym<apos>")
    if_null rx1106_debug, debug_837
    rx1106_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1106_pos)
  debug_837:
    .return (rx1106_cur)
  rx1106_restart:
.annotate 'line', 4
    if_null rx1106_debug, debug_838
    rx1106_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_838:
  rx1106_fail:
    (rx1106_rep, rx1106_pos, $I10, $P10) = rx1106_cur."!mark_fail"(0)
    lt rx1106_pos, -1, rx1106_done
    eq rx1106_pos, -1, rx1106_fail
    jump $I10
  rx1106_done:
    rx1106_cur."!cursor_fail"()
    if_null rx1106_debug, debug_839
    rx1106_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_839:
    .return (rx1106_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("234_1298839231.515") :method
.annotate 'line', 4
    new $P1108, "ResizablePMCArray"
    push $P1108, "'"
    .return ($P1108)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("235_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1111_tgt
    .local int rx1111_pos
    .local int rx1111_off
    .local int rx1111_eos
    .local int rx1111_rep
    .local pmc rx1111_cur
    .local pmc rx1111_debug
    (rx1111_cur, rx1111_pos, rx1111_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1111_cur
    .local pmc match
    .lex "$/", match
    length rx1111_eos, rx1111_tgt
    gt rx1111_pos, rx1111_eos, rx1111_done
    set rx1111_off, 0
    lt rx1111_pos, 2, rx1111_start
    sub rx1111_off, rx1111_pos, 1
    substr rx1111_tgt, rx1111_tgt, rx1111_off
  rx1111_start:
    eq $I10, 1, rx1111_restart
    if_null rx1111_debug, debug_840
    rx1111_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1114_done
    goto rxscan1114_scan
  rxscan1114_loop:
    (rx1111_pos) = rx1111_cur."from"()
    inc rx1111_pos
    rx1111_cur."!cursor_from"(rx1111_pos)
    ge rx1111_pos, rx1111_eos, rxscan1114_done
  rxscan1114_scan:
    set_addr $I10, rxscan1114_loop
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxscan1114_done:
.annotate 'line', 514
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1111_pos, rx1111_off
    substr $S10, rx1111_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1111_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."quote_EXPR"(":qq")
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1111_pos = $P10."pos"()
  # rx pass
    rx1111_cur."!cursor_pass"(rx1111_pos, "quote:sym<dblq>")
    if_null rx1111_debug, debug_841
    rx1111_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1111_pos)
  debug_841:
    .return (rx1111_cur)
  rx1111_restart:
.annotate 'line', 4
    if_null rx1111_debug, debug_842
    rx1111_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_842:
  rx1111_fail:
    (rx1111_rep, rx1111_pos, $I10, $P10) = rx1111_cur."!mark_fail"(0)
    lt rx1111_pos, -1, rx1111_done
    eq rx1111_pos, -1, rx1111_fail
    jump $I10
  rx1111_done:
    rx1111_cur."!cursor_fail"()
    if_null rx1111_debug, debug_843
    rx1111_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_843:
    .return (rx1111_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("236_1298839231.515") :method
.annotate 'line', 4
    new $P1113, "ResizablePMCArray"
    push $P1113, "\""
    .return ($P1113)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("237_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1116_tgt
    .local int rx1116_pos
    .local int rx1116_off
    .local int rx1116_eos
    .local int rx1116_rep
    .local pmc rx1116_cur
    .local pmc rx1116_debug
    (rx1116_cur, rx1116_pos, rx1116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1116_cur
    .local pmc match
    .lex "$/", match
    length rx1116_eos, rx1116_tgt
    gt rx1116_pos, rx1116_eos, rx1116_done
    set rx1116_off, 0
    lt rx1116_pos, 2, rx1116_start
    sub rx1116_off, rx1116_pos, 1
    substr rx1116_tgt, rx1116_tgt, rx1116_off
  rx1116_start:
    eq $I10, 1, rx1116_restart
    if_null rx1116_debug, debug_844
    rx1116_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1120_done
    goto rxscan1120_scan
  rxscan1120_loop:
    (rx1116_pos) = rx1116_cur."from"()
    inc rx1116_pos
    rx1116_cur."!cursor_from"(rx1116_pos)
    ge rx1116_pos, rx1116_eos, rxscan1120_done
  rxscan1120_scan:
    set_addr $I10, rxscan1120_loop
    rx1116_cur."!mark_push"(0, rx1116_pos, $I10)
  rxscan1120_done:
.annotate 'line', 515
  # rx literal  "q"
    add $I11, rx1116_pos, 1
    gt $I11, rx1116_eos, rx1116_fail
    sub $I11, rx1116_pos, rx1116_off
    ord $I11, rx1116_tgt, $I11
    ne $I11, 113, rx1116_fail
    add rx1116_pos, 1
  # rxanchor rwb
    le rx1116_pos, 0, rx1116_fail
    sub $I10, rx1116_pos, rx1116_off
    is_cclass $I11, 8192, rx1116_tgt, $I10
    if $I11, rx1116_fail
    dec $I10
    is_cclass $I11, 8192, rx1116_tgt, $I10
    unless $I11, rx1116_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1116_pos, rx1116_off
    substr $S10, rx1116_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1116_fail
  # rx subrule "ws" subtype=method negate=
    rx1116_cur."!cursor_pos"(rx1116_pos)
    $P10 = rx1116_cur."ws"()
    unless $P10, rx1116_fail
    rx1116_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1116_cur."!cursor_pos"(rx1116_pos)
    $P10 = rx1116_cur."quote_EXPR"(":q")
    unless $P10, rx1116_fail
    rx1116_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1116_pos = $P10."pos"()
  # rx pass
    rx1116_cur."!cursor_pass"(rx1116_pos, "quote:sym<q>")
    if_null rx1116_debug, debug_845
    rx1116_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1116_pos)
  debug_845:
    .return (rx1116_cur)
  rx1116_restart:
.annotate 'line', 4
    if_null rx1116_debug, debug_846
    rx1116_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_846:
  rx1116_fail:
    (rx1116_rep, rx1116_pos, $I10, $P10) = rx1116_cur."!mark_fail"(0)
    lt rx1116_pos, -1, rx1116_done
    eq rx1116_pos, -1, rx1116_fail
    jump $I10
  rx1116_done:
    rx1116_cur."!cursor_fail"()
    if_null rx1116_debug, debug_847
    rx1116_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_847:
    .return (rx1116_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("238_1298839231.515") :method
.annotate 'line', 4
    $P1118 = self."!PREFIX__!subrule"("ws", "q")
    new $P1119, "ResizablePMCArray"
    push $P1119, $P1118
    .return ($P1119)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("239_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1122_tgt
    .local int rx1122_pos
    .local int rx1122_off
    .local int rx1122_eos
    .local int rx1122_rep
    .local pmc rx1122_cur
    .local pmc rx1122_debug
    (rx1122_cur, rx1122_pos, rx1122_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1122_cur
    .local pmc match
    .lex "$/", match
    length rx1122_eos, rx1122_tgt
    gt rx1122_pos, rx1122_eos, rx1122_done
    set rx1122_off, 0
    lt rx1122_pos, 2, rx1122_start
    sub rx1122_off, rx1122_pos, 1
    substr rx1122_tgt, rx1122_tgt, rx1122_off
  rx1122_start:
    eq $I10, 1, rx1122_restart
    if_null rx1122_debug, debug_848
    rx1122_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1126_done
    goto rxscan1126_scan
  rxscan1126_loop:
    (rx1122_pos) = rx1122_cur."from"()
    inc rx1122_pos
    rx1122_cur."!cursor_from"(rx1122_pos)
    ge rx1122_pos, rx1122_eos, rxscan1126_done
  rxscan1126_scan:
    set_addr $I10, rxscan1126_loop
    rx1122_cur."!mark_push"(0, rx1122_pos, $I10)
  rxscan1126_done:
.annotate 'line', 516
  # rx literal  "qq"
    add $I11, rx1122_pos, 2
    gt $I11, rx1122_eos, rx1122_fail
    sub $I11, rx1122_pos, rx1122_off
    substr $S10, rx1122_tgt, $I11, 2
    ne $S10, "qq", rx1122_fail
    add rx1122_pos, 2
  # rxanchor rwb
    le rx1122_pos, 0, rx1122_fail
    sub $I10, rx1122_pos, rx1122_off
    is_cclass $I11, 8192, rx1122_tgt, $I10
    if $I11, rx1122_fail
    dec $I10
    is_cclass $I11, 8192, rx1122_tgt, $I10
    unless $I11, rx1122_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1122_pos, rx1122_off
    substr $S10, rx1122_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1122_fail
  # rx subrule "ws" subtype=method negate=
    rx1122_cur."!cursor_pos"(rx1122_pos)
    $P10 = rx1122_cur."ws"()
    unless $P10, rx1122_fail
    rx1122_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1122_cur."!cursor_pos"(rx1122_pos)
    $P10 = rx1122_cur."quote_EXPR"(":qq")
    unless $P10, rx1122_fail
    rx1122_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1122_pos = $P10."pos"()
  # rx pass
    rx1122_cur."!cursor_pass"(rx1122_pos, "quote:sym<qq>")
    if_null rx1122_debug, debug_849
    rx1122_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1122_pos)
  debug_849:
    .return (rx1122_cur)
  rx1122_restart:
.annotate 'line', 4
    if_null rx1122_debug, debug_850
    rx1122_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_850:
  rx1122_fail:
    (rx1122_rep, rx1122_pos, $I10, $P10) = rx1122_cur."!mark_fail"(0)
    lt rx1122_pos, -1, rx1122_done
    eq rx1122_pos, -1, rx1122_fail
    jump $I10
  rx1122_done:
    rx1122_cur."!cursor_fail"()
    if_null rx1122_debug, debug_851
    rx1122_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_851:
    .return (rx1122_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("240_1298839231.515") :method
.annotate 'line', 4
    $P1124 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1125, "ResizablePMCArray"
    push $P1125, $P1124
    .return ($P1125)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("241_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1128_tgt
    .local int rx1128_pos
    .local int rx1128_off
    .local int rx1128_eos
    .local int rx1128_rep
    .local pmc rx1128_cur
    .local pmc rx1128_debug
    (rx1128_cur, rx1128_pos, rx1128_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1128_cur
    .local pmc match
    .lex "$/", match
    length rx1128_eos, rx1128_tgt
    gt rx1128_pos, rx1128_eos, rx1128_done
    set rx1128_off, 0
    lt rx1128_pos, 2, rx1128_start
    sub rx1128_off, rx1128_pos, 1
    substr rx1128_tgt, rx1128_tgt, rx1128_off
  rx1128_start:
    eq $I10, 1, rx1128_restart
    if_null rx1128_debug, debug_852
    rx1128_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1132_done
    goto rxscan1132_scan
  rxscan1132_loop:
    (rx1128_pos) = rx1128_cur."from"()
    inc rx1128_pos
    rx1128_cur."!cursor_from"(rx1128_pos)
    ge rx1128_pos, rx1128_eos, rxscan1132_done
  rxscan1132_scan:
    set_addr $I10, rxscan1132_loop
    rx1128_cur."!mark_push"(0, rx1128_pos, $I10)
  rxscan1132_done:
.annotate 'line', 517
  # rx literal  "Q"
    add $I11, rx1128_pos, 1
    gt $I11, rx1128_eos, rx1128_fail
    sub $I11, rx1128_pos, rx1128_off
    ord $I11, rx1128_tgt, $I11
    ne $I11, 81, rx1128_fail
    add rx1128_pos, 1
  # rxanchor rwb
    le rx1128_pos, 0, rx1128_fail
    sub $I10, rx1128_pos, rx1128_off
    is_cclass $I11, 8192, rx1128_tgt, $I10
    if $I11, rx1128_fail
    dec $I10
    is_cclass $I11, 8192, rx1128_tgt, $I10
    unless $I11, rx1128_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1128_pos, rx1128_off
    substr $S10, rx1128_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1128_fail
  # rx subrule "ws" subtype=method negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."ws"()
    unless $P10, rx1128_fail
    rx1128_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1128_cur."!cursor_pos"(rx1128_pos)
    $P10 = rx1128_cur."quote_EXPR"()
    unless $P10, rx1128_fail
    rx1128_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1128_pos = $P10."pos"()
  # rx pass
    rx1128_cur."!cursor_pass"(rx1128_pos, "quote:sym<Q>")
    if_null rx1128_debug, debug_853
    rx1128_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1128_pos)
  debug_853:
    .return (rx1128_cur)
  rx1128_restart:
.annotate 'line', 4
    if_null rx1128_debug, debug_854
    rx1128_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_854:
  rx1128_fail:
    (rx1128_rep, rx1128_pos, $I10, $P10) = rx1128_cur."!mark_fail"(0)
    lt rx1128_pos, -1, rx1128_done
    eq rx1128_pos, -1, rx1128_fail
    jump $I10
  rx1128_done:
    rx1128_cur."!cursor_fail"()
    if_null rx1128_debug, debug_855
    rx1128_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_855:
    .return (rx1128_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("242_1298839231.515") :method
.annotate 'line', 4
    $P1130 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1131, "ResizablePMCArray"
    push $P1131, $P1130
    .return ($P1131)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("243_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1134_tgt
    .local int rx1134_pos
    .local int rx1134_off
    .local int rx1134_eos
    .local int rx1134_rep
    .local pmc rx1134_cur
    .local pmc rx1134_debug
    (rx1134_cur, rx1134_pos, rx1134_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1134_cur
    .local pmc match
    .lex "$/", match
    length rx1134_eos, rx1134_tgt
    gt rx1134_pos, rx1134_eos, rx1134_done
    set rx1134_off, 0
    lt rx1134_pos, 2, rx1134_start
    sub rx1134_off, rx1134_pos, 1
    substr rx1134_tgt, rx1134_tgt, rx1134_off
  rx1134_start:
    eq $I10, 1, rx1134_restart
    if_null rx1134_debug, debug_856
    rx1134_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1138_done
    goto rxscan1138_scan
  rxscan1138_loop:
    (rx1134_pos) = rx1134_cur."from"()
    inc rx1134_pos
    rx1134_cur."!cursor_from"(rx1134_pos)
    ge rx1134_pos, rx1134_eos, rxscan1138_done
  rxscan1138_scan:
    set_addr $I10, rxscan1138_loop
    rx1134_cur."!mark_push"(0, rx1134_pos, $I10)
  rxscan1138_done:
.annotate 'line', 518
  # rx literal  "Q:PIR"
    add $I11, rx1134_pos, 5
    gt $I11, rx1134_eos, rx1134_fail
    sub $I11, rx1134_pos, rx1134_off
    substr $S10, rx1134_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1134_fail
    add rx1134_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."ws"()
    unless $P10, rx1134_fail
    rx1134_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1134_cur."!cursor_pos"(rx1134_pos)
    $P10 = rx1134_cur."quote_EXPR"()
    unless $P10, rx1134_fail
    rx1134_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1134_pos = $P10."pos"()
  # rx pass
    rx1134_cur."!cursor_pass"(rx1134_pos, "quote:sym<Q:PIR>")
    if_null rx1134_debug, debug_857
    rx1134_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1134_pos)
  debug_857:
    .return (rx1134_cur)
  rx1134_restart:
.annotate 'line', 4
    if_null rx1134_debug, debug_858
    rx1134_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_858:
  rx1134_fail:
    (rx1134_rep, rx1134_pos, $I10, $P10) = rx1134_cur."!mark_fail"(0)
    lt rx1134_pos, -1, rx1134_done
    eq rx1134_pos, -1, rx1134_fail
    jump $I10
  rx1134_done:
    rx1134_cur."!cursor_fail"()
    if_null rx1134_debug, debug_859
    rx1134_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_859:
    .return (rx1134_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("244_1298839231.515") :method
.annotate 'line', 4
    $P1136 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1137, "ResizablePMCArray"
    push $P1137, $P1136
    .return ($P1137)
.end


.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("245_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1140_tgt
    .local int rx1140_pos
    .local int rx1140_off
    .local int rx1140_eos
    .local int rx1140_rep
    .local pmc rx1140_cur
    .local pmc rx1140_debug
    (rx1140_cur, rx1140_pos, rx1140_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1140_cur
    .local pmc match
    .lex "$/", match
    length rx1140_eos, rx1140_tgt
    gt rx1140_pos, rx1140_eos, rx1140_done
    set rx1140_off, 0
    lt rx1140_pos, 2, rx1140_start
    sub rx1140_off, rx1140_pos, 1
    substr rx1140_tgt, rx1140_tgt, rx1140_off
  rx1140_start:
    eq $I10, 1, rx1140_restart
    if_null rx1140_debug, debug_860
    rx1140_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1144_done
    goto rxscan1144_scan
  rxscan1144_loop:
    (rx1140_pos) = rx1140_cur."from"()
    inc rx1140_pos
    rx1140_cur."!cursor_from"(rx1140_pos)
    ge rx1140_pos, rx1140_eos, rxscan1144_done
  rxscan1144_scan:
    set_addr $I10, rxscan1144_loop
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
  rxscan1144_done:
.annotate 'line', 520
  # rx literal  "/"
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 47, rx1140_fail
    add rx1140_pos, 1
.annotate 'line', 521
  # rx subrule "newpad" subtype=method negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."newpad"()
    unless $P10, rx1140_fail
    rx1140_pos = $P10."pos"()
.annotate 'line', 522
  # rx reduce name="quote:sym</ />" key="open"
    rx1140_cur."!cursor_pos"(rx1140_pos)
    rx1140_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 523
  # rx subrule "LANG" subtype=capture negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1140_fail
    rx1140_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1140_pos = $P10."pos"()
.annotate 'line', 524
  # rx literal  "/"
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 47, rx1140_fail
    add rx1140_pos, 1
.annotate 'line', 519
  # rx pass
    rx1140_cur."!cursor_pass"(rx1140_pos, "quote:sym</ />")
    if_null rx1140_debug, debug_861
    rx1140_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1140_pos)
  debug_861:
    .return (rx1140_cur)
  rx1140_restart:
.annotate 'line', 4
    if_null rx1140_debug, debug_862
    rx1140_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_862:
  rx1140_fail:
    (rx1140_rep, rx1140_pos, $I10, $P10) = rx1140_cur."!mark_fail"(0)
    lt rx1140_pos, -1, rx1140_done
    eq rx1140_pos, -1, rx1140_fail
    jump $I10
  rx1140_done:
    rx1140_cur."!cursor_fail"()
    if_null rx1140_debug, debug_863
    rx1140_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_863:
    .return (rx1140_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("246_1298839231.515") :method
.annotate 'line', 4
    $P1142 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1143, "ResizablePMCArray"
    push $P1143, $P1142
    .return ($P1143)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("247_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1146_tgt
    .local int rx1146_pos
    .local int rx1146_off
    .local int rx1146_eos
    .local int rx1146_rep
    .local pmc rx1146_cur
    .local pmc rx1146_debug
    (rx1146_cur, rx1146_pos, rx1146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1146_cur
    .local pmc match
    .lex "$/", match
    length rx1146_eos, rx1146_tgt
    gt rx1146_pos, rx1146_eos, rx1146_done
    set rx1146_off, 0
    lt rx1146_pos, 2, rx1146_start
    sub rx1146_off, rx1146_pos, 1
    substr rx1146_tgt, rx1146_tgt, rx1146_off
  rx1146_start:
    eq $I10, 1, rx1146_restart
    if_null rx1146_debug, debug_864
    rx1146_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1149_done
    goto rxscan1149_scan
  rxscan1149_loop:
    (rx1146_pos) = rx1146_cur."from"()
    inc rx1146_pos
    rx1146_cur."!cursor_from"(rx1146_pos)
    ge rx1146_pos, rx1146_eos, rxscan1149_done
  rxscan1149_scan:
    set_addr $I10, rxscan1149_loop
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  rxscan1149_done:
.annotate 'line', 527
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1146_pos, rx1146_off
    substr $S10, rx1146_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1146_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."quotemod_check"("s")
    unless $P10, rx1146_fail
  # rx subrule "variable" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."variable"()
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1146_pos = $P10."pos"()
  # rx pass
    rx1146_cur."!cursor_pass"(rx1146_pos, "quote_escape:sym<$>")
    if_null rx1146_debug, debug_865
    rx1146_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1146_pos)
  debug_865:
    .return (rx1146_cur)
  rx1146_restart:
.annotate 'line', 4
    if_null rx1146_debug, debug_866
    rx1146_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_866:
  rx1146_fail:
    (rx1146_rep, rx1146_pos, $I10, $P10) = rx1146_cur."!mark_fail"(0)
    lt rx1146_pos, -1, rx1146_done
    eq rx1146_pos, -1, rx1146_fail
    jump $I10
  rx1146_done:
    rx1146_cur."!cursor_fail"()
    if_null rx1146_debug, debug_867
    rx1146_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_867:
    .return (rx1146_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("248_1298839231.515") :method
.annotate 'line', 4
    new $P1148, "ResizablePMCArray"
    push $P1148, "$"
    .return ($P1148)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("249_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1151_tgt
    .local int rx1151_pos
    .local int rx1151_off
    .local int rx1151_eos
    .local int rx1151_rep
    .local pmc rx1151_cur
    .local pmc rx1151_debug
    (rx1151_cur, rx1151_pos, rx1151_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1151_cur
    .local pmc match
    .lex "$/", match
    length rx1151_eos, rx1151_tgt
    gt rx1151_pos, rx1151_eos, rx1151_done
    set rx1151_off, 0
    lt rx1151_pos, 2, rx1151_start
    sub rx1151_off, rx1151_pos, 1
    substr rx1151_tgt, rx1151_tgt, rx1151_off
  rx1151_start:
    eq $I10, 1, rx1151_restart
    if_null rx1151_debug, debug_868
    rx1151_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1154_done
    goto rxscan1154_scan
  rxscan1154_loop:
    (rx1151_pos) = rx1151_cur."from"()
    inc rx1151_pos
    rx1151_cur."!cursor_from"(rx1151_pos)
    ge rx1151_pos, rx1151_eos, rxscan1154_done
  rxscan1154_scan:
    set_addr $I10, rxscan1154_loop
    rx1151_cur."!mark_push"(0, rx1151_pos, $I10)
  rxscan1154_done:
.annotate 'line', 528
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1151_pos, rx1151_off
    substr $S10, rx1151_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1151_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."quotemod_check"("c")
    unless $P10, rx1151_fail
  # rx subrule "block" subtype=capture negate=
    rx1151_cur."!cursor_pos"(rx1151_pos)
    $P10 = rx1151_cur."block"()
    unless $P10, rx1151_fail
    rx1151_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1151_pos = $P10."pos"()
  # rx pass
    rx1151_cur."!cursor_pass"(rx1151_pos, "quote_escape:sym<{ }>")
    if_null rx1151_debug, debug_869
    rx1151_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1151_pos)
  debug_869:
    .return (rx1151_cur)
  rx1151_restart:
.annotate 'line', 4
    if_null rx1151_debug, debug_870
    rx1151_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_870:
  rx1151_fail:
    (rx1151_rep, rx1151_pos, $I10, $P10) = rx1151_cur."!mark_fail"(0)
    lt rx1151_pos, -1, rx1151_done
    eq rx1151_pos, -1, rx1151_fail
    jump $I10
  rx1151_done:
    rx1151_cur."!cursor_fail"()
    if_null rx1151_debug, debug_871
    rx1151_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_871:
    .return (rx1151_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("250_1298839231.515") :method
.annotate 'line', 4
    new $P1153, "ResizablePMCArray"
    push $P1153, "{"
    .return ($P1153)
.end


.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("251_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1156_tgt
    .local int rx1156_pos
    .local int rx1156_off
    .local int rx1156_eos
    .local int rx1156_rep
    .local pmc rx1156_cur
    .local pmc rx1156_debug
    (rx1156_cur, rx1156_pos, rx1156_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1156_cur
    .local pmc match
    .lex "$/", match
    length rx1156_eos, rx1156_tgt
    gt rx1156_pos, rx1156_eos, rx1156_done
    set rx1156_off, 0
    lt rx1156_pos, 2, rx1156_start
    sub rx1156_off, rx1156_pos, 1
    substr rx1156_tgt, rx1156_tgt, rx1156_off
  rx1156_start:
    eq $I10, 1, rx1156_restart
    if_null rx1156_debug, debug_872
    rx1156_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1159_done
    goto rxscan1159_scan
  rxscan1159_loop:
    (rx1156_pos) = rx1156_cur."from"()
    inc rx1156_pos
    rx1156_cur."!cursor_from"(rx1156_pos)
    ge rx1156_pos, rx1156_eos, rxscan1159_done
  rxscan1159_scan:
    set_addr $I10, rxscan1159_loop
    rx1156_cur."!mark_push"(0, rx1156_pos, $I10)
  rxscan1159_done:
.annotate 'line', 529
  # rx literal  "\\e"
    add $I11, rx1156_pos, 2
    gt $I11, rx1156_eos, rx1156_fail
    sub $I11, rx1156_pos, rx1156_off
    substr $S10, rx1156_tgt, $I11, 2
    ne $S10, "\\e", rx1156_fail
    add rx1156_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1156_cur."!cursor_pos"(rx1156_pos)
    $P10 = rx1156_cur."quotemod_check"("b")
    unless $P10, rx1156_fail
  # rx pass
    rx1156_cur."!cursor_pass"(rx1156_pos, "quote_escape:sym<esc>")
    if_null rx1156_debug, debug_873
    rx1156_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1156_pos)
  debug_873:
    .return (rx1156_cur)
  rx1156_restart:
.annotate 'line', 4
    if_null rx1156_debug, debug_874
    rx1156_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_874:
  rx1156_fail:
    (rx1156_rep, rx1156_pos, $I10, $P10) = rx1156_cur."!mark_fail"(0)
    lt rx1156_pos, -1, rx1156_done
    eq rx1156_pos, -1, rx1156_fail
    jump $I10
  rx1156_done:
    rx1156_cur."!cursor_fail"()
    if_null rx1156_debug, debug_875
    rx1156_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_875:
    .return (rx1156_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("252_1298839231.515") :method
.annotate 'line', 4
    new $P1158, "ResizablePMCArray"
    push $P1158, "\\e"
    .return ($P1158)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("253_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1161_tgt
    .local int rx1161_pos
    .local int rx1161_off
    .local int rx1161_eos
    .local int rx1161_rep
    .local pmc rx1161_cur
    .local pmc rx1161_debug
    (rx1161_cur, rx1161_pos, rx1161_tgt, $I10) = self."!cursor_start"()
    rx1161_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1161_cur
    .local pmc match
    .lex "$/", match
    length rx1161_eos, rx1161_tgt
    gt rx1161_pos, rx1161_eos, rx1161_done
    set rx1161_off, 0
    lt rx1161_pos, 2, rx1161_start
    sub rx1161_off, rx1161_pos, 1
    substr rx1161_tgt, rx1161_tgt, rx1161_off
  rx1161_start:
    eq $I10, 1, rx1161_restart
    if_null rx1161_debug, debug_876
    rx1161_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1165_done
    goto rxscan1165_scan
  rxscan1165_loop:
    (rx1161_pos) = rx1161_cur."from"()
    inc rx1161_pos
    rx1161_cur."!cursor_from"(rx1161_pos)
    ge rx1161_pos, rx1161_eos, rxscan1165_done
  rxscan1165_scan:
    set_addr $I10, rxscan1165_loop
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
  rxscan1165_done:
.annotate 'line', 531
  # rx literal  "("
    add $I11, rx1161_pos, 1
    gt $I11, rx1161_eos, rx1161_fail
    sub $I11, rx1161_pos, rx1161_off
    ord $I11, rx1161_tgt, $I11
    ne $I11, 40, rx1161_fail
    add rx1161_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1161_cur."!cursor_pos"(rx1161_pos)
    $P10 = rx1161_cur."ws"()
    unless $P10, rx1161_fail
    rx1161_pos = $P10."pos"()
  # rx rxquantr1166 ** 0..1
    set_addr $I10, rxquantr1166_done
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10)
  rxquantr1166_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1161_cur."!cursor_pos"(rx1161_pos)
    $P10 = rx1161_cur."EXPR"()
    unless $P10, rx1161_fail
    goto rxsubrule1167_pass
  rxsubrule1167_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1161_fail
  rxsubrule1167_pass:
    set_addr $I10, rxsubrule1167_back
    rx1161_cur."!mark_push"(0, rx1161_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1161_pos = $P10."pos"()
    set_addr $I10, rxquantr1166_done
    (rx1161_rep) = rx1161_cur."!mark_commit"($I10)
  rxquantr1166_done:
  # rx literal  ")"
    add $I11, rx1161_pos, 1
    gt $I11, rx1161_eos, rx1161_fail
    sub $I11, rx1161_pos, rx1161_off
    ord $I11, rx1161_tgt, $I11
    ne $I11, 41, rx1161_fail
    add rx1161_pos, 1
  # rx pass
    rx1161_cur."!cursor_pass"(rx1161_pos, "circumfix:sym<( )>")
    if_null rx1161_debug, debug_877
    rx1161_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1161_pos)
  debug_877:
    .return (rx1161_cur)
  rx1161_restart:
.annotate 'line', 4
    if_null rx1161_debug, debug_878
    rx1161_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_878:
  rx1161_fail:
    (rx1161_rep, rx1161_pos, $I10, $P10) = rx1161_cur."!mark_fail"(0)
    lt rx1161_pos, -1, rx1161_done
    eq rx1161_pos, -1, rx1161_fail
    jump $I10
  rx1161_done:
    rx1161_cur."!cursor_fail"()
    if_null rx1161_debug, debug_879
    rx1161_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_879:
    .return (rx1161_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("254_1298839231.515") :method
.annotate 'line', 4
    $P1163 = self."!PREFIX__!subrule"("ws", "(")
    new $P1164, "ResizablePMCArray"
    push $P1164, $P1163
    .return ($P1164)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("255_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1169_tgt
    .local int rx1169_pos
    .local int rx1169_off
    .local int rx1169_eos
    .local int rx1169_rep
    .local pmc rx1169_cur
    .local pmc rx1169_debug
    (rx1169_cur, rx1169_pos, rx1169_tgt, $I10) = self."!cursor_start"()
    rx1169_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1169_cur
    .local pmc match
    .lex "$/", match
    length rx1169_eos, rx1169_tgt
    gt rx1169_pos, rx1169_eos, rx1169_done
    set rx1169_off, 0
    lt rx1169_pos, 2, rx1169_start
    sub rx1169_off, rx1169_pos, 1
    substr rx1169_tgt, rx1169_tgt, rx1169_off
  rx1169_start:
    eq $I10, 1, rx1169_restart
    if_null rx1169_debug, debug_880
    rx1169_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1173_done
    goto rxscan1173_scan
  rxscan1173_loop:
    (rx1169_pos) = rx1169_cur."from"()
    inc rx1169_pos
    rx1169_cur."!cursor_from"(rx1169_pos)
    ge rx1169_pos, rx1169_eos, rxscan1173_done
  rxscan1173_scan:
    set_addr $I10, rxscan1173_loop
    rx1169_cur."!mark_push"(0, rx1169_pos, $I10)
  rxscan1173_done:
.annotate 'line', 532
  # rx literal  "["
    add $I11, rx1169_pos, 1
    gt $I11, rx1169_eos, rx1169_fail
    sub $I11, rx1169_pos, rx1169_off
    ord $I11, rx1169_tgt, $I11
    ne $I11, 91, rx1169_fail
    add rx1169_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."ws"()
    unless $P10, rx1169_fail
    rx1169_pos = $P10."pos"()
  # rx rxquantr1174 ** 0..1
    set_addr $I10, rxquantr1174_done
    rx1169_cur."!mark_push"(0, rx1169_pos, $I10)
  rxquantr1174_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1169_cur."!cursor_pos"(rx1169_pos)
    $P10 = rx1169_cur."EXPR"()
    unless $P10, rx1169_fail
    goto rxsubrule1175_pass
  rxsubrule1175_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1169_fail
  rxsubrule1175_pass:
    set_addr $I10, rxsubrule1175_back
    rx1169_cur."!mark_push"(0, rx1169_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1169_pos = $P10."pos"()
    set_addr $I10, rxquantr1174_done
    (rx1169_rep) = rx1169_cur."!mark_commit"($I10)
  rxquantr1174_done:
  # rx literal  "]"
    add $I11, rx1169_pos, 1
    gt $I11, rx1169_eos, rx1169_fail
    sub $I11, rx1169_pos, rx1169_off
    ord $I11, rx1169_tgt, $I11
    ne $I11, 93, rx1169_fail
    add rx1169_pos, 1
  # rx pass
    rx1169_cur."!cursor_pass"(rx1169_pos, "circumfix:sym<[ ]>")
    if_null rx1169_debug, debug_881
    rx1169_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1169_pos)
  debug_881:
    .return (rx1169_cur)
  rx1169_restart:
.annotate 'line', 4
    if_null rx1169_debug, debug_882
    rx1169_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_882:
  rx1169_fail:
    (rx1169_rep, rx1169_pos, $I10, $P10) = rx1169_cur."!mark_fail"(0)
    lt rx1169_pos, -1, rx1169_done
    eq rx1169_pos, -1, rx1169_fail
    jump $I10
  rx1169_done:
    rx1169_cur."!cursor_fail"()
    if_null rx1169_debug, debug_883
    rx1169_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_883:
    .return (rx1169_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("256_1298839231.515") :method
.annotate 'line', 4
    $P1171 = self."!PREFIX__!subrule"("ws", "[")
    new $P1172, "ResizablePMCArray"
    push $P1172, $P1171
    .return ($P1172)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("257_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1177_tgt
    .local int rx1177_pos
    .local int rx1177_off
    .local int rx1177_eos
    .local int rx1177_rep
    .local pmc rx1177_cur
    .local pmc rx1177_debug
    (rx1177_cur, rx1177_pos, rx1177_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1177_cur
    .local pmc match
    .lex "$/", match
    length rx1177_eos, rx1177_tgt
    gt rx1177_pos, rx1177_eos, rx1177_done
    set rx1177_off, 0
    lt rx1177_pos, 2, rx1177_start
    sub rx1177_off, rx1177_pos, 1
    substr rx1177_tgt, rx1177_tgt, rx1177_off
  rx1177_start:
    eq $I10, 1, rx1177_restart
    if_null rx1177_debug, debug_884
    rx1177_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1180_done
    goto rxscan1180_scan
  rxscan1180_loop:
    (rx1177_pos) = rx1177_cur."from"()
    inc rx1177_pos
    rx1177_cur."!cursor_from"(rx1177_pos)
    ge rx1177_pos, rx1177_eos, rxscan1180_done
  rxscan1180_scan:
    set_addr $I10, rxscan1180_loop
    rx1177_cur."!mark_push"(0, rx1177_pos, $I10)
  rxscan1180_done:
.annotate 'line', 533
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1177_pos, rx1177_off
    substr $S10, rx1177_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1177_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1177_cur."!cursor_pos"(rx1177_pos)
    $P10 = rx1177_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1177_fail
    rx1177_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1177_pos = $P10."pos"()
  # rx pass
    rx1177_cur."!cursor_pass"(rx1177_pos, "circumfix:sym<ang>")
    if_null rx1177_debug, debug_885
    rx1177_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1177_pos)
  debug_885:
    .return (rx1177_cur)
  rx1177_restart:
.annotate 'line', 4
    if_null rx1177_debug, debug_886
    rx1177_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_886:
  rx1177_fail:
    (rx1177_rep, rx1177_pos, $I10, $P10) = rx1177_cur."!mark_fail"(0)
    lt rx1177_pos, -1, rx1177_done
    eq rx1177_pos, -1, rx1177_fail
    jump $I10
  rx1177_done:
    rx1177_cur."!cursor_fail"()
    if_null rx1177_debug, debug_887
    rx1177_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_887:
    .return (rx1177_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("258_1298839231.515") :method
.annotate 'line', 4
    new $P1179, "ResizablePMCArray"
    push $P1179, "<"
    .return ($P1179)
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("259_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1182_tgt
    .local int rx1182_pos
    .local int rx1182_off
    .local int rx1182_eos
    .local int rx1182_rep
    .local pmc rx1182_cur
    .local pmc rx1182_debug
    (rx1182_cur, rx1182_pos, rx1182_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1182_cur
    .local pmc match
    .lex "$/", match
    length rx1182_eos, rx1182_tgt
    gt rx1182_pos, rx1182_eos, rx1182_done
    set rx1182_off, 0
    lt rx1182_pos, 2, rx1182_start
    sub rx1182_off, rx1182_pos, 1
    substr rx1182_tgt, rx1182_tgt, rx1182_off
  rx1182_start:
    eq $I10, 1, rx1182_restart
    if_null rx1182_debug, debug_888
    rx1182_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1185_done
    goto rxscan1185_scan
  rxscan1185_loop:
    (rx1182_pos) = rx1182_cur."from"()
    inc rx1182_pos
    rx1182_cur."!cursor_from"(rx1182_pos)
    ge rx1182_pos, rx1182_eos, rxscan1185_done
  rxscan1185_scan:
    set_addr $I10, rxscan1185_loop
    rx1182_cur."!mark_push"(0, rx1182_pos, $I10)
  rxscan1185_done:
.annotate 'line', 534
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1182_pos, rx1182_off
    substr $S10, rx1182_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1182_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1182_cur."!cursor_pos"(rx1182_pos)
    $P10 = rx1182_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1182_fail
    rx1182_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1182_pos = $P10."pos"()
  # rx pass
    rx1182_cur."!cursor_pass"(rx1182_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1182_debug, debug_889
    rx1182_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1182_pos)
  debug_889:
    .return (rx1182_cur)
  rx1182_restart:
.annotate 'line', 4
    if_null rx1182_debug, debug_890
    rx1182_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_890:
  rx1182_fail:
    (rx1182_rep, rx1182_pos, $I10, $P10) = rx1182_cur."!mark_fail"(0)
    lt rx1182_pos, -1, rx1182_done
    eq rx1182_pos, -1, rx1182_fail
    jump $I10
  rx1182_done:
    rx1182_cur."!cursor_fail"()
    if_null rx1182_debug, debug_891
    rx1182_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_891:
    .return (rx1182_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("260_1298839231.515") :method
.annotate 'line', 4
    new $P1184, "ResizablePMCArray"
    push $P1184, unicode:"\x{ab}"
    .return ($P1184)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("261_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1187_tgt
    .local int rx1187_pos
    .local int rx1187_off
    .local int rx1187_eos
    .local int rx1187_rep
    .local pmc rx1187_cur
    .local pmc rx1187_debug
    (rx1187_cur, rx1187_pos, rx1187_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1187_cur
    .local pmc match
    .lex "$/", match
    length rx1187_eos, rx1187_tgt
    gt rx1187_pos, rx1187_eos, rx1187_done
    set rx1187_off, 0
    lt rx1187_pos, 2, rx1187_start
    sub rx1187_off, rx1187_pos, 1
    substr rx1187_tgt, rx1187_tgt, rx1187_off
  rx1187_start:
    eq $I10, 1, rx1187_restart
    if_null rx1187_debug, debug_892
    rx1187_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1190_done
    goto rxscan1190_scan
  rxscan1190_loop:
    (rx1187_pos) = rx1187_cur."from"()
    inc rx1187_pos
    rx1187_cur."!cursor_from"(rx1187_pos)
    ge rx1187_pos, rx1187_eos, rxscan1190_done
  rxscan1190_scan:
    set_addr $I10, rxscan1190_loop
    rx1187_cur."!mark_push"(0, rx1187_pos, $I10)
  rxscan1190_done:
.annotate 'line', 535
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1187_pos, rx1187_off
    substr $S10, rx1187_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1187_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1187_cur."!cursor_pos"(rx1187_pos)
    $P10 = rx1187_cur."pblock"()
    unless $P10, rx1187_fail
    rx1187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1187_pos = $P10."pos"()
  # rx pass
    rx1187_cur."!cursor_pass"(rx1187_pos, "circumfix:sym<{ }>")
    if_null rx1187_debug, debug_893
    rx1187_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1187_pos)
  debug_893:
    .return (rx1187_cur)
  rx1187_restart:
.annotate 'line', 4
    if_null rx1187_debug, debug_894
    rx1187_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_894:
  rx1187_fail:
    (rx1187_rep, rx1187_pos, $I10, $P10) = rx1187_cur."!mark_fail"(0)
    lt rx1187_pos, -1, rx1187_done
    eq rx1187_pos, -1, rx1187_fail
    jump $I10
  rx1187_done:
    rx1187_cur."!cursor_fail"()
    if_null rx1187_debug, debug_895
    rx1187_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_895:
    .return (rx1187_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("262_1298839231.515") :method
.annotate 'line', 4
    new $P1189, "ResizablePMCArray"
    push $P1189, "{"
    .return ($P1189)
.end


.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("263_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1192_tgt
    .local int rx1192_pos
    .local int rx1192_off
    .local int rx1192_eos
    .local int rx1192_rep
    .local pmc rx1192_cur
    .local pmc rx1192_debug
    (rx1192_cur, rx1192_pos, rx1192_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1192_cur
    .local pmc match
    .lex "$/", match
    length rx1192_eos, rx1192_tgt
    gt rx1192_pos, rx1192_eos, rx1192_done
    set rx1192_off, 0
    lt rx1192_pos, 2, rx1192_start
    sub rx1192_off, rx1192_pos, 1
    substr rx1192_tgt, rx1192_tgt, rx1192_off
  rx1192_start:
    eq $I10, 1, rx1192_restart
    if_null rx1192_debug, debug_896
    rx1192_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1196_done
    goto rxscan1196_scan
  rxscan1196_loop:
    (rx1192_pos) = rx1192_cur."from"()
    inc rx1192_pos
    rx1192_cur."!cursor_from"(rx1192_pos)
    ge rx1192_pos, rx1192_eos, rxscan1196_done
  rxscan1196_scan:
    set_addr $I10, rxscan1196_loop
    rx1192_cur."!mark_push"(0, rx1192_pos, $I10)
  rxscan1196_done:
.annotate 'line', 536
  # rx subrule "sigil" subtype=capture negate=
    rx1192_cur."!cursor_pos"(rx1192_pos)
    $P10 = rx1192_cur."sigil"()
    unless $P10, rx1192_fail
    rx1192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1192_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1192_pos, 1
    gt $I11, rx1192_eos, rx1192_fail
    sub $I11, rx1192_pos, rx1192_off
    ord $I11, rx1192_tgt, $I11
    ne $I11, 40, rx1192_fail
    add rx1192_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1192_cur."!cursor_pos"(rx1192_pos)
    $P10 = rx1192_cur."semilist"()
    unless $P10, rx1192_fail
    rx1192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1192_pos = $P10."pos"()
  alt1197_0:
    set_addr $I10, alt1197_1
    rx1192_cur."!mark_push"(0, rx1192_pos, $I10)
  # rx literal  ")"
    add $I11, rx1192_pos, 1
    gt $I11, rx1192_eos, rx1192_fail
    sub $I11, rx1192_pos, rx1192_off
    ord $I11, rx1192_tgt, $I11
    ne $I11, 41, rx1192_fail
    add rx1192_pos, 1
    goto alt1197_end
  alt1197_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1192_cur."!cursor_pos"(rx1192_pos)
    $P10 = rx1192_cur."FAILGOAL"("')'")
    unless $P10, rx1192_fail
    goto rxsubrule1199_pass
  rxsubrule1199_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1192_fail
  rxsubrule1199_pass:
    set_addr $I10, rxsubrule1199_back
    rx1192_cur."!mark_push"(0, rx1192_pos, $I10, $P10)
    rx1192_pos = $P10."pos"()
  alt1197_end:
  # rx pass
    rx1192_cur."!cursor_pass"(rx1192_pos, "circumfix:sym<sigil>")
    if_null rx1192_debug, debug_897
    rx1192_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1192_pos)
  debug_897:
    .return (rx1192_cur)
  rx1192_restart:
.annotate 'line', 4
    if_null rx1192_debug, debug_898
    rx1192_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_898:
  rx1192_fail:
    (rx1192_rep, rx1192_pos, $I10, $P10) = rx1192_cur."!mark_fail"(0)
    lt rx1192_pos, -1, rx1192_done
    eq rx1192_pos, -1, rx1192_fail
    jump $I10
  rx1192_done:
    rx1192_cur."!cursor_fail"()
    if_null rx1192_debug, debug_899
    rx1192_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_899:
    .return (rx1192_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("264_1298839231.515") :method
.annotate 'line', 4
    $P1194 = self."!PREFIX__!subrule"("sigil", "")
    new $P1195, "ResizablePMCArray"
    push $P1195, $P1194
    .return ($P1195)
.end


.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("265_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1201_tgt
    .local int rx1201_pos
    .local int rx1201_off
    .local int rx1201_eos
    .local int rx1201_rep
    .local pmc rx1201_cur
    .local pmc rx1201_debug
    (rx1201_cur, rx1201_pos, rx1201_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1201_cur
    .local pmc match
    .lex "$/", match
    length rx1201_eos, rx1201_tgt
    gt rx1201_pos, rx1201_eos, rx1201_done
    set rx1201_off, 0
    lt rx1201_pos, 2, rx1201_start
    sub rx1201_off, rx1201_pos, 1
    substr rx1201_tgt, rx1201_tgt, rx1201_off
  rx1201_start:
    eq $I10, 1, rx1201_restart
    if_null rx1201_debug, debug_900
    rx1201_cur."!cursor_debug"("START", "semilist")
  debug_900:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1205_done
    goto rxscan1205_scan
  rxscan1205_loop:
    (rx1201_pos) = rx1201_cur."from"()
    inc rx1201_pos
    rx1201_cur."!cursor_from"(rx1201_pos)
    ge rx1201_pos, rx1201_eos, rxscan1205_done
  rxscan1205_scan:
    set_addr $I10, rxscan1205_loop
    rx1201_cur."!mark_push"(0, rx1201_pos, $I10)
  rxscan1205_done:
.annotate 'line', 538
  # rx subrule "ws" subtype=method negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."ws"()
    unless $P10, rx1201_fail
    rx1201_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."statement"()
    unless $P10, rx1201_fail
    rx1201_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1201_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1201_cur."!cursor_pos"(rx1201_pos)
    $P10 = rx1201_cur."ws"()
    unless $P10, rx1201_fail
    rx1201_pos = $P10."pos"()
  # rx pass
    rx1201_cur."!cursor_pass"(rx1201_pos, "semilist")
    if_null rx1201_debug, debug_901
    rx1201_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1201_pos)
  debug_901:
    .return (rx1201_cur)
  rx1201_restart:
.annotate 'line', 4
    if_null rx1201_debug, debug_902
    rx1201_cur."!cursor_debug"("NEXT", "semilist")
  debug_902:
  rx1201_fail:
    (rx1201_rep, rx1201_pos, $I10, $P10) = rx1201_cur."!mark_fail"(0)
    lt rx1201_pos, -1, rx1201_done
    eq rx1201_pos, -1, rx1201_fail
    jump $I10
  rx1201_done:
    rx1201_cur."!cursor_fail"()
    if_null rx1201_debug, debug_903
    rx1201_cur."!cursor_debug"("FAIL", "semilist")
  debug_903:
    .return (rx1201_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("266_1298839231.515") :method
.annotate 'line', 4
    $P1203 = self."!PREFIX__!subrule"("ws", "")
    new $P1204, "ResizablePMCArray"
    push $P1204, $P1203
    .return ($P1204)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1208"  :anon :subid("267_1298839231.515") :outer("11_1298839231.515")
.annotate 'line', 4
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post904") :outer("267_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P1209 = "267_1298839231.515" 
    .local pmc block
    set block, $P1209
.annotate 'line', 543
    get_hll_global $P1210, ["NQP"], "Grammar"
    $P1210."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 544
    get_hll_global $P1211, ["NQP"], "Grammar"
    $P1211."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 545
    get_hll_global $P1212, ["NQP"], "Grammar"
    $P1212."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 546
    get_hll_global $P1213, ["NQP"], "Grammar"
    $P1213."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 547
    get_hll_global $P1214, ["NQP"], "Grammar"
    $P1214."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 548
    get_hll_global $P1215, ["NQP"], "Grammar"
    $P1215."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 549
    get_hll_global $P1216, ["NQP"], "Grammar"
    $P1216."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 550
    get_hll_global $P1217, ["NQP"], "Grammar"
    $P1217."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 551
    get_hll_global $P1218, ["NQP"], "Grammar"
    $P1218."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 552
    get_hll_global $P1219, ["NQP"], "Grammar"
    $P1219."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 553
    get_hll_global $P1220, ["NQP"], "Grammar"
    $P1220."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 554
    get_hll_global $P1221, ["NQP"], "Grammar"
    $P1221."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 555
    get_hll_global $P1222, ["NQP"], "Grammar"
    $P1222."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 556
    get_hll_global $P1223, ["NQP"], "Grammar"
    $P1223."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 557
    get_hll_global $P1224, ["NQP"], "Grammar"
    $P1224."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("268_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1226_tgt
    .local int rx1226_pos
    .local int rx1226_off
    .local int rx1226_eos
    .local int rx1226_rep
    .local pmc rx1226_cur
    .local pmc rx1226_debug
    (rx1226_cur, rx1226_pos, rx1226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1226_cur
    .local pmc match
    .lex "$/", match
    length rx1226_eos, rx1226_tgt
    gt rx1226_pos, rx1226_eos, rx1226_done
    set rx1226_off, 0
    lt rx1226_pos, 2, rx1226_start
    sub rx1226_off, rx1226_pos, 1
    substr rx1226_tgt, rx1226_tgt, rx1226_off
  rx1226_start:
    eq $I10, 1, rx1226_restart
    if_null rx1226_debug, debug_905
    rx1226_cur."!cursor_debug"("START", "infixish")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1229_done
    goto rxscan1229_scan
  rxscan1229_loop:
    (rx1226_pos) = rx1226_cur."from"()
    inc rx1226_pos
    rx1226_cur."!cursor_from"(rx1226_pos)
    ge rx1226_pos, rx1226_eos, rxscan1229_done
  rxscan1229_scan:
    set_addr $I10, rxscan1229_loop
    rx1226_cur."!mark_push"(0, rx1226_pos, $I10)
  rxscan1229_done:
.annotate 'line', 561
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."infixstopper"()
    if $P10, rx1226_fail
  # rx subrule "infix" subtype=capture negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."infix"()
    unless $P10, rx1226_fail
    rx1226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1226_pos = $P10."pos"()
  # rx pass
    rx1226_cur."!cursor_pass"(rx1226_pos, "infixish")
    if_null rx1226_debug, debug_906
    rx1226_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1226_pos)
  debug_906:
    .return (rx1226_cur)
  rx1226_restart:
.annotate 'line', 4
    if_null rx1226_debug, debug_907
    rx1226_cur."!cursor_debug"("NEXT", "infixish")
  debug_907:
  rx1226_fail:
    (rx1226_rep, rx1226_pos, $I10, $P10) = rx1226_cur."!mark_fail"(0)
    lt rx1226_pos, -1, rx1226_done
    eq rx1226_pos, -1, rx1226_fail
    jump $I10
  rx1226_done:
    rx1226_cur."!cursor_fail"()
    if_null rx1226_debug, debug_908
    rx1226_cur."!cursor_debug"("FAIL", "infixish")
  debug_908:
    .return (rx1226_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("269_1298839231.515") :method
.annotate 'line', 4
    new $P1228, "ResizablePMCArray"
    push $P1228, ""
    .return ($P1228)
.end


.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("270_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1231_tgt
    .local int rx1231_pos
    .local int rx1231_off
    .local int rx1231_eos
    .local int rx1231_rep
    .local pmc rx1231_cur
    .local pmc rx1231_debug
    (rx1231_cur, rx1231_pos, rx1231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1231_cur
    .local pmc match
    .lex "$/", match
    length rx1231_eos, rx1231_tgt
    gt rx1231_pos, rx1231_eos, rx1231_done
    set rx1231_off, 0
    lt rx1231_pos, 2, rx1231_start
    sub rx1231_off, rx1231_pos, 1
    substr rx1231_tgt, rx1231_tgt, rx1231_off
  rx1231_start:
    eq $I10, 1, rx1231_restart
    if_null rx1231_debug, debug_909
    rx1231_cur."!cursor_debug"("START", "infixstopper")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1231_pos) = rx1231_cur."from"()
    inc rx1231_pos
    rx1231_cur."!cursor_from"(rx1231_pos)
    ge rx1231_pos, rx1231_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
  rxscan1234_done:
.annotate 'line', 562
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."lambda"()
    unless $P10, rx1231_fail
  # rx pass
    rx1231_cur."!cursor_pass"(rx1231_pos, "infixstopper")
    if_null rx1231_debug, debug_910
    rx1231_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1231_pos)
  debug_910:
    .return (rx1231_cur)
  rx1231_restart:
.annotate 'line', 4
    if_null rx1231_debug, debug_911
    rx1231_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_911:
  rx1231_fail:
    (rx1231_rep, rx1231_pos, $I10, $P10) = rx1231_cur."!mark_fail"(0)
    lt rx1231_pos, -1, rx1231_done
    eq rx1231_pos, -1, rx1231_fail
    jump $I10
  rx1231_done:
    rx1231_cur."!cursor_fail"()
    if_null rx1231_debug, debug_912
    rx1231_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_912:
    .return (rx1231_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("271_1298839231.515") :method
.annotate 'line', 4
    new $P1233, "ResizablePMCArray"
    push $P1233, ""
    .return ($P1233)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("272_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1236_tgt
    .local int rx1236_pos
    .local int rx1236_off
    .local int rx1236_eos
    .local int rx1236_rep
    .local pmc rx1236_cur
    .local pmc rx1236_debug
    (rx1236_cur, rx1236_pos, rx1236_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1236_cur
    .local pmc match
    .lex "$/", match
    length rx1236_eos, rx1236_tgt
    gt rx1236_pos, rx1236_eos, rx1236_done
    set rx1236_off, 0
    lt rx1236_pos, 2, rx1236_start
    sub rx1236_off, rx1236_pos, 1
    substr rx1236_tgt, rx1236_tgt, rx1236_off
  rx1236_start:
    eq $I10, 1, rx1236_restart
    if_null rx1236_debug, debug_913
    rx1236_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1236_pos) = rx1236_cur."from"()
    inc rx1236_pos
    rx1236_cur."!cursor_from"(rx1236_pos)
    ge rx1236_pos, rx1236_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxscan1240_done:
.annotate 'line', 565
  # rx literal  "["
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 91, rx1236_fail
    add rx1236_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."ws"()
    unless $P10, rx1236_fail
    rx1236_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."EXPR"()
    unless $P10, rx1236_fail
    rx1236_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1236_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 93, rx1236_fail
    add rx1236_pos, 1
.annotate 'line', 566
  # rx subrule "O" subtype=capture negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."O"("%methodop")
    unless $P10, rx1236_fail
    rx1236_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1236_pos = $P10."pos"()
.annotate 'line', 564
  # rx pass
    rx1236_cur."!cursor_pass"(rx1236_pos, "postcircumfix:sym<[ ]>")
    if_null rx1236_debug, debug_914
    rx1236_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1236_pos)
  debug_914:
    .return (rx1236_cur)
  rx1236_restart:
.annotate 'line', 4
    if_null rx1236_debug, debug_915
    rx1236_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_915:
  rx1236_fail:
    (rx1236_rep, rx1236_pos, $I10, $P10) = rx1236_cur."!mark_fail"(0)
    lt rx1236_pos, -1, rx1236_done
    eq rx1236_pos, -1, rx1236_fail
    jump $I10
  rx1236_done:
    rx1236_cur."!cursor_fail"()
    if_null rx1236_debug, debug_916
    rx1236_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_916:
    .return (rx1236_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("273_1298839231.515") :method
.annotate 'line', 4
    $P1238 = self."!PREFIX__!subrule"("ws", "[")
    new $P1239, "ResizablePMCArray"
    push $P1239, $P1238
    .return ($P1239)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("274_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1242_tgt
    .local int rx1242_pos
    .local int rx1242_off
    .local int rx1242_eos
    .local int rx1242_rep
    .local pmc rx1242_cur
    .local pmc rx1242_debug
    (rx1242_cur, rx1242_pos, rx1242_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1242_cur
    .local pmc match
    .lex "$/", match
    length rx1242_eos, rx1242_tgt
    gt rx1242_pos, rx1242_eos, rx1242_done
    set rx1242_off, 0
    lt rx1242_pos, 2, rx1242_start
    sub rx1242_off, rx1242_pos, 1
    substr rx1242_tgt, rx1242_tgt, rx1242_off
  rx1242_start:
    eq $I10, 1, rx1242_restart
    if_null rx1242_debug, debug_917
    rx1242_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1246_done
    goto rxscan1246_scan
  rxscan1246_loop:
    (rx1242_pos) = rx1242_cur."from"()
    inc rx1242_pos
    rx1242_cur."!cursor_from"(rx1242_pos)
    ge rx1242_pos, rx1242_eos, rxscan1246_done
  rxscan1246_scan:
    set_addr $I10, rxscan1246_loop
    rx1242_cur."!mark_push"(0, rx1242_pos, $I10)
  rxscan1246_done:
.annotate 'line', 570
  # rx literal  "{"
    add $I11, rx1242_pos, 1
    gt $I11, rx1242_eos, rx1242_fail
    sub $I11, rx1242_pos, rx1242_off
    ord $I11, rx1242_tgt, $I11
    ne $I11, 123, rx1242_fail
    add rx1242_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."ws"()
    unless $P10, rx1242_fail
    rx1242_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."EXPR"()
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1242_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1242_pos, 1
    gt $I11, rx1242_eos, rx1242_fail
    sub $I11, rx1242_pos, rx1242_off
    ord $I11, rx1242_tgt, $I11
    ne $I11, 125, rx1242_fail
    add rx1242_pos, 1
.annotate 'line', 571
  # rx subrule "O" subtype=capture negate=
    rx1242_cur."!cursor_pos"(rx1242_pos)
    $P10 = rx1242_cur."O"("%methodop")
    unless $P10, rx1242_fail
    rx1242_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1242_pos = $P10."pos"()
.annotate 'line', 569
  # rx pass
    rx1242_cur."!cursor_pass"(rx1242_pos, "postcircumfix:sym<{ }>")
    if_null rx1242_debug, debug_918
    rx1242_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1242_pos)
  debug_918:
    .return (rx1242_cur)
  rx1242_restart:
.annotate 'line', 4
    if_null rx1242_debug, debug_919
    rx1242_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_919:
  rx1242_fail:
    (rx1242_rep, rx1242_pos, $I10, $P10) = rx1242_cur."!mark_fail"(0)
    lt rx1242_pos, -1, rx1242_done
    eq rx1242_pos, -1, rx1242_fail
    jump $I10
  rx1242_done:
    rx1242_cur."!cursor_fail"()
    if_null rx1242_debug, debug_920
    rx1242_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_920:
    .return (rx1242_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("275_1298839231.515") :method
.annotate 'line', 4
    $P1244 = self."!PREFIX__!subrule"("ws", "{")
    new $P1245, "ResizablePMCArray"
    push $P1245, $P1244
    .return ($P1245)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("276_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1248_tgt
    .local int rx1248_pos
    .local int rx1248_off
    .local int rx1248_eos
    .local int rx1248_rep
    .local pmc rx1248_cur
    .local pmc rx1248_debug
    (rx1248_cur, rx1248_pos, rx1248_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1248_cur
    .local pmc match
    .lex "$/", match
    length rx1248_eos, rx1248_tgt
    gt rx1248_pos, rx1248_eos, rx1248_done
    set rx1248_off, 0
    lt rx1248_pos, 2, rx1248_start
    sub rx1248_off, rx1248_pos, 1
    substr rx1248_tgt, rx1248_tgt, rx1248_off
  rx1248_start:
    eq $I10, 1, rx1248_restart
    if_null rx1248_debug, debug_921
    rx1248_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1251_done
    goto rxscan1251_scan
  rxscan1251_loop:
    (rx1248_pos) = rx1248_cur."from"()
    inc rx1248_pos
    rx1248_cur."!cursor_from"(rx1248_pos)
    ge rx1248_pos, rx1248_eos, rxscan1251_done
  rxscan1251_scan:
    set_addr $I10, rxscan1251_loop
    rx1248_cur."!mark_push"(0, rx1248_pos, $I10)
  rxscan1251_done:
.annotate 'line', 575
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1248_pos, rx1248_off
    substr $S10, rx1248_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1248_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1248_cur."!cursor_pos"(rx1248_pos)
    $P10 = rx1248_cur."quote_EXPR"(":q")
    unless $P10, rx1248_fail
    rx1248_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1248_pos = $P10."pos"()
.annotate 'line', 576
  # rx subrule "O" subtype=capture negate=
    rx1248_cur."!cursor_pos"(rx1248_pos)
    $P10 = rx1248_cur."O"("%methodop")
    unless $P10, rx1248_fail
    rx1248_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1248_pos = $P10."pos"()
.annotate 'line', 574
  # rx pass
    rx1248_cur."!cursor_pass"(rx1248_pos, "postcircumfix:sym<ang>")
    if_null rx1248_debug, debug_922
    rx1248_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1248_pos)
  debug_922:
    .return (rx1248_cur)
  rx1248_restart:
.annotate 'line', 4
    if_null rx1248_debug, debug_923
    rx1248_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_923:
  rx1248_fail:
    (rx1248_rep, rx1248_pos, $I10, $P10) = rx1248_cur."!mark_fail"(0)
    lt rx1248_pos, -1, rx1248_done
    eq rx1248_pos, -1, rx1248_fail
    jump $I10
  rx1248_done:
    rx1248_cur."!cursor_fail"()
    if_null rx1248_debug, debug_924
    rx1248_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_924:
    .return (rx1248_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("277_1298839231.515") :method
.annotate 'line', 4
    new $P1250, "ResizablePMCArray"
    push $P1250, "<"
    .return ($P1250)
.end


.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("278_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1253_tgt
    .local int rx1253_pos
    .local int rx1253_off
    .local int rx1253_eos
    .local int rx1253_rep
    .local pmc rx1253_cur
    .local pmc rx1253_debug
    (rx1253_cur, rx1253_pos, rx1253_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1253_cur
    .local pmc match
    .lex "$/", match
    length rx1253_eos, rx1253_tgt
    gt rx1253_pos, rx1253_eos, rx1253_done
    set rx1253_off, 0
    lt rx1253_pos, 2, rx1253_start
    sub rx1253_off, rx1253_pos, 1
    substr rx1253_tgt, rx1253_tgt, rx1253_off
  rx1253_start:
    eq $I10, 1, rx1253_restart
    if_null rx1253_debug, debug_925
    rx1253_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1257_done
    goto rxscan1257_scan
  rxscan1257_loop:
    (rx1253_pos) = rx1253_cur."from"()
    inc rx1253_pos
    rx1253_cur."!cursor_from"(rx1253_pos)
    ge rx1253_pos, rx1253_eos, rxscan1257_done
  rxscan1257_scan:
    set_addr $I10, rxscan1257_loop
    rx1253_cur."!mark_push"(0, rx1253_pos, $I10)
  rxscan1257_done:
.annotate 'line', 580
  # rx literal  "("
    add $I11, rx1253_pos, 1
    gt $I11, rx1253_eos, rx1253_fail
    sub $I11, rx1253_pos, rx1253_off
    ord $I11, rx1253_tgt, $I11
    ne $I11, 40, rx1253_fail
    add rx1253_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1253_cur."!cursor_pos"(rx1253_pos)
    $P10 = rx1253_cur."ws"()
    unless $P10, rx1253_fail
    rx1253_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1253_cur."!cursor_pos"(rx1253_pos)
    $P10 = rx1253_cur."arglist"()
    unless $P10, rx1253_fail
    rx1253_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1253_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1253_pos, 1
    gt $I11, rx1253_eos, rx1253_fail
    sub $I11, rx1253_pos, rx1253_off
    ord $I11, rx1253_tgt, $I11
    ne $I11, 41, rx1253_fail
    add rx1253_pos, 1
.annotate 'line', 581
  # rx subrule "O" subtype=capture negate=
    rx1253_cur."!cursor_pos"(rx1253_pos)
    $P10 = rx1253_cur."O"("%methodop")
    unless $P10, rx1253_fail
    rx1253_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1253_pos = $P10."pos"()
.annotate 'line', 579
  # rx pass
    rx1253_cur."!cursor_pass"(rx1253_pos, "postcircumfix:sym<( )>")
    if_null rx1253_debug, debug_926
    rx1253_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1253_pos)
  debug_926:
    .return (rx1253_cur)
  rx1253_restart:
.annotate 'line', 4
    if_null rx1253_debug, debug_927
    rx1253_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_927:
  rx1253_fail:
    (rx1253_rep, rx1253_pos, $I10, $P10) = rx1253_cur."!mark_fail"(0)
    lt rx1253_pos, -1, rx1253_done
    eq rx1253_pos, -1, rx1253_fail
    jump $I10
  rx1253_done:
    rx1253_cur."!cursor_fail"()
    if_null rx1253_debug, debug_928
    rx1253_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_928:
    .return (rx1253_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("279_1298839231.515") :method
.annotate 'line', 4
    $P1255 = self."!PREFIX__!subrule"("ws", "(")
    new $P1256, "ResizablePMCArray"
    push $P1256, $P1255
    .return ($P1256)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("280_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1259_tgt
    .local int rx1259_pos
    .local int rx1259_off
    .local int rx1259_eos
    .local int rx1259_rep
    .local pmc rx1259_cur
    .local pmc rx1259_debug
    (rx1259_cur, rx1259_pos, rx1259_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1259_cur
    .local pmc match
    .lex "$/", match
    length rx1259_eos, rx1259_tgt
    gt rx1259_pos, rx1259_eos, rx1259_done
    set rx1259_off, 0
    lt rx1259_pos, 2, rx1259_start
    sub rx1259_off, rx1259_pos, 1
    substr rx1259_tgt, rx1259_tgt, rx1259_off
  rx1259_start:
    eq $I10, 1, rx1259_restart
    if_null rx1259_debug, debug_929
    rx1259_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_929:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1263_done
    goto rxscan1263_scan
  rxscan1263_loop:
    (rx1259_pos) = rx1259_cur."from"()
    inc rx1259_pos
    rx1259_cur."!cursor_from"(rx1259_pos)
    ge rx1259_pos, rx1259_eos, rxscan1263_done
  rxscan1263_scan:
    set_addr $I10, rxscan1263_loop
    rx1259_cur."!mark_push"(0, rx1259_pos, $I10)
  rxscan1263_done:
.annotate 'line', 584
  # rx subrule "dotty" subtype=capture negate=
    rx1259_cur."!cursor_pos"(rx1259_pos)
    $P10 = rx1259_cur."dotty"()
    unless $P10, rx1259_fail
    rx1259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1259_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1259_cur."!cursor_pos"(rx1259_pos)
    $P10 = rx1259_cur."O"("%methodop")
    unless $P10, rx1259_fail
    rx1259_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1259_pos = $P10."pos"()
  # rx pass
    rx1259_cur."!cursor_pass"(rx1259_pos, "postfix:sym<.>")
    if_null rx1259_debug, debug_930
    rx1259_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1259_pos)
  debug_930:
    .return (rx1259_cur)
  rx1259_restart:
.annotate 'line', 4
    if_null rx1259_debug, debug_931
    rx1259_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_931:
  rx1259_fail:
    (rx1259_rep, rx1259_pos, $I10, $P10) = rx1259_cur."!mark_fail"(0)
    lt rx1259_pos, -1, rx1259_done
    eq rx1259_pos, -1, rx1259_fail
    jump $I10
  rx1259_done:
    rx1259_cur."!cursor_fail"()
    if_null rx1259_debug, debug_932
    rx1259_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_932:
    .return (rx1259_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("281_1298839231.515") :method
.annotate 'line', 4
    $P1261 = self."!PREFIX__!subrule"("dotty", "")
    new $P1262, "ResizablePMCArray"
    push $P1262, $P1261
    .return ($P1262)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("282_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1265_tgt
    .local int rx1265_pos
    .local int rx1265_off
    .local int rx1265_eos
    .local int rx1265_rep
    .local pmc rx1265_cur
    .local pmc rx1265_debug
    (rx1265_cur, rx1265_pos, rx1265_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1265_cur
    .local pmc match
    .lex "$/", match
    length rx1265_eos, rx1265_tgt
    gt rx1265_pos, rx1265_eos, rx1265_done
    set rx1265_off, 0
    lt rx1265_pos, 2, rx1265_start
    sub rx1265_off, rx1265_pos, 1
    substr rx1265_tgt, rx1265_tgt, rx1265_off
  rx1265_start:
    eq $I10, 1, rx1265_restart
    if_null rx1265_debug, debug_933
    rx1265_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1269_done
    goto rxscan1269_scan
  rxscan1269_loop:
    (rx1265_pos) = rx1265_cur."from"()
    inc rx1265_pos
    rx1265_cur."!cursor_from"(rx1265_pos)
    ge rx1265_pos, rx1265_eos, rxscan1269_done
  rxscan1269_scan:
    set_addr $I10, rxscan1269_loop
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
  rxscan1269_done:
.annotate 'line', 586
  # rx subcapture "sym"
    set_addr $I10, rxcap_1270_fail
    rx1265_cur."!mark_push"(0, rx1265_pos, $I10)
  # rx literal  "++"
    add $I11, rx1265_pos, 2
    gt $I11, rx1265_eos, rx1265_fail
    sub $I11, rx1265_pos, rx1265_off
    substr $S10, rx1265_tgt, $I11, 2
    ne $S10, "++", rx1265_fail
    add rx1265_pos, 2
    set_addr $I10, rxcap_1270_fail
    ($I12, $I11) = rx1265_cur."!mark_peek"($I10)
    rx1265_cur."!cursor_pos"($I11)
    ($P10) = rx1265_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1265_pos, "")
    rx1265_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1270_done
  rxcap_1270_fail:
    goto rx1265_fail
  rxcap_1270_done:
  # rx subrule "O" subtype=capture negate=
    rx1265_cur."!cursor_pos"(rx1265_pos)
    $P10 = rx1265_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1265_fail
    rx1265_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1265_pos = $P10."pos"()
  # rx pass
    rx1265_cur."!cursor_pass"(rx1265_pos, "prefix:sym<++>")
    if_null rx1265_debug, debug_934
    rx1265_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1265_pos)
  debug_934:
    .return (rx1265_cur)
  rx1265_restart:
.annotate 'line', 4
    if_null rx1265_debug, debug_935
    rx1265_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_935:
  rx1265_fail:
    (rx1265_rep, rx1265_pos, $I10, $P10) = rx1265_cur."!mark_fail"(0)
    lt rx1265_pos, -1, rx1265_done
    eq rx1265_pos, -1, rx1265_fail
    jump $I10
  rx1265_done:
    rx1265_cur."!cursor_fail"()
    if_null rx1265_debug, debug_936
    rx1265_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_936:
    .return (rx1265_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("283_1298839231.515") :method
.annotate 'line', 4
    $P1267 = self."!PREFIX__!subrule"("O", "++")
    new $P1268, "ResizablePMCArray"
    push $P1268, $P1267
    .return ($P1268)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("284_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1272_tgt
    .local int rx1272_pos
    .local int rx1272_off
    .local int rx1272_eos
    .local int rx1272_rep
    .local pmc rx1272_cur
    .local pmc rx1272_debug
    (rx1272_cur, rx1272_pos, rx1272_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1272_cur
    .local pmc match
    .lex "$/", match
    length rx1272_eos, rx1272_tgt
    gt rx1272_pos, rx1272_eos, rx1272_done
    set rx1272_off, 0
    lt rx1272_pos, 2, rx1272_start
    sub rx1272_off, rx1272_pos, 1
    substr rx1272_tgt, rx1272_tgt, rx1272_off
  rx1272_start:
    eq $I10, 1, rx1272_restart
    if_null rx1272_debug, debug_937
    rx1272_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1276_done
    goto rxscan1276_scan
  rxscan1276_loop:
    (rx1272_pos) = rx1272_cur."from"()
    inc rx1272_pos
    rx1272_cur."!cursor_from"(rx1272_pos)
    ge rx1272_pos, rx1272_eos, rxscan1276_done
  rxscan1276_scan:
    set_addr $I10, rxscan1276_loop
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  rxscan1276_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1277_fail
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  # rx literal  "--"
    add $I11, rx1272_pos, 2
    gt $I11, rx1272_eos, rx1272_fail
    sub $I11, rx1272_pos, rx1272_off
    substr $S10, rx1272_tgt, $I11, 2
    ne $S10, "--", rx1272_fail
    add rx1272_pos, 2
    set_addr $I10, rxcap_1277_fail
    ($I12, $I11) = rx1272_cur."!mark_peek"($I10)
    rx1272_cur."!cursor_pos"($I11)
    ($P10) = rx1272_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1272_pos, "")
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1277_done
  rxcap_1277_fail:
    goto rx1272_fail
  rxcap_1277_done:
  # rx subrule "O" subtype=capture negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1272_fail
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1272_pos = $P10."pos"()
  # rx pass
    rx1272_cur."!cursor_pass"(rx1272_pos, "prefix:sym<-->")
    if_null rx1272_debug, debug_938
    rx1272_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1272_pos)
  debug_938:
    .return (rx1272_cur)
  rx1272_restart:
.annotate 'line', 4
    if_null rx1272_debug, debug_939
    rx1272_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_939:
  rx1272_fail:
    (rx1272_rep, rx1272_pos, $I10, $P10) = rx1272_cur."!mark_fail"(0)
    lt rx1272_pos, -1, rx1272_done
    eq rx1272_pos, -1, rx1272_fail
    jump $I10
  rx1272_done:
    rx1272_cur."!cursor_fail"()
    if_null rx1272_debug, debug_940
    rx1272_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_940:
    .return (rx1272_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("285_1298839231.515") :method
.annotate 'line', 4
    $P1274 = self."!PREFIX__!subrule"("O", "--")
    new $P1275, "ResizablePMCArray"
    push $P1275, $P1274
    .return ($P1275)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("286_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1279_tgt
    .local int rx1279_pos
    .local int rx1279_off
    .local int rx1279_eos
    .local int rx1279_rep
    .local pmc rx1279_cur
    .local pmc rx1279_debug
    (rx1279_cur, rx1279_pos, rx1279_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1279_cur
    .local pmc match
    .lex "$/", match
    length rx1279_eos, rx1279_tgt
    gt rx1279_pos, rx1279_eos, rx1279_done
    set rx1279_off, 0
    lt rx1279_pos, 2, rx1279_start
    sub rx1279_off, rx1279_pos, 1
    substr rx1279_tgt, rx1279_tgt, rx1279_off
  rx1279_start:
    eq $I10, 1, rx1279_restart
    if_null rx1279_debug, debug_941
    rx1279_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1283_done
    goto rxscan1283_scan
  rxscan1283_loop:
    (rx1279_pos) = rx1279_cur."from"()
    inc rx1279_pos
    rx1279_cur."!cursor_from"(rx1279_pos)
    ge rx1279_pos, rx1279_eos, rxscan1283_done
  rxscan1283_scan:
    set_addr $I10, rxscan1283_loop
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  rxscan1283_done:
.annotate 'line', 590
  # rx subcapture "sym"
    set_addr $I10, rxcap_1284_fail
    rx1279_cur."!mark_push"(0, rx1279_pos, $I10)
  # rx literal  "++"
    add $I11, rx1279_pos, 2
    gt $I11, rx1279_eos, rx1279_fail
    sub $I11, rx1279_pos, rx1279_off
    substr $S10, rx1279_tgt, $I11, 2
    ne $S10, "++", rx1279_fail
    add rx1279_pos, 2
    set_addr $I10, rxcap_1284_fail
    ($I12, $I11) = rx1279_cur."!mark_peek"($I10)
    rx1279_cur."!cursor_pos"($I11)
    ($P10) = rx1279_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1279_pos, "")
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1284_done
  rxcap_1284_fail:
    goto rx1279_fail
  rxcap_1284_done:
  # rx subrule "O" subtype=capture negate=
    rx1279_cur."!cursor_pos"(rx1279_pos)
    $P10 = rx1279_cur."O"("%autoincrement")
    unless $P10, rx1279_fail
    rx1279_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1279_pos = $P10."pos"()
  # rx pass
    rx1279_cur."!cursor_pass"(rx1279_pos, "postfix:sym<++>")
    if_null rx1279_debug, debug_942
    rx1279_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1279_pos)
  debug_942:
    .return (rx1279_cur)
  rx1279_restart:
.annotate 'line', 4
    if_null rx1279_debug, debug_943
    rx1279_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_943:
  rx1279_fail:
    (rx1279_rep, rx1279_pos, $I10, $P10) = rx1279_cur."!mark_fail"(0)
    lt rx1279_pos, -1, rx1279_done
    eq rx1279_pos, -1, rx1279_fail
    jump $I10
  rx1279_done:
    rx1279_cur."!cursor_fail"()
    if_null rx1279_debug, debug_944
    rx1279_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_944:
    .return (rx1279_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("287_1298839231.515") :method
.annotate 'line', 4
    $P1281 = self."!PREFIX__!subrule"("O", "++")
    new $P1282, "ResizablePMCArray"
    push $P1282, $P1281
    .return ($P1282)
.end


.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("288_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1286_tgt
    .local int rx1286_pos
    .local int rx1286_off
    .local int rx1286_eos
    .local int rx1286_rep
    .local pmc rx1286_cur
    .local pmc rx1286_debug
    (rx1286_cur, rx1286_pos, rx1286_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1286_cur
    .local pmc match
    .lex "$/", match
    length rx1286_eos, rx1286_tgt
    gt rx1286_pos, rx1286_eos, rx1286_done
    set rx1286_off, 0
    lt rx1286_pos, 2, rx1286_start
    sub rx1286_off, rx1286_pos, 1
    substr rx1286_tgt, rx1286_tgt, rx1286_off
  rx1286_start:
    eq $I10, 1, rx1286_restart
    if_null rx1286_debug, debug_945
    rx1286_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1290_done
    goto rxscan1290_scan
  rxscan1290_loop:
    (rx1286_pos) = rx1286_cur."from"()
    inc rx1286_pos
    rx1286_cur."!cursor_from"(rx1286_pos)
    ge rx1286_pos, rx1286_eos, rxscan1290_done
  rxscan1290_scan:
    set_addr $I10, rxscan1290_loop
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  rxscan1290_done:
.annotate 'line', 591
  # rx subcapture "sym"
    set_addr $I10, rxcap_1291_fail
    rx1286_cur."!mark_push"(0, rx1286_pos, $I10)
  # rx literal  "--"
    add $I11, rx1286_pos, 2
    gt $I11, rx1286_eos, rx1286_fail
    sub $I11, rx1286_pos, rx1286_off
    substr $S10, rx1286_tgt, $I11, 2
    ne $S10, "--", rx1286_fail
    add rx1286_pos, 2
    set_addr $I10, rxcap_1291_fail
    ($I12, $I11) = rx1286_cur."!mark_peek"($I10)
    rx1286_cur."!cursor_pos"($I11)
    ($P10) = rx1286_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1286_pos, "")
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1291_done
  rxcap_1291_fail:
    goto rx1286_fail
  rxcap_1291_done:
  # rx subrule "O" subtype=capture negate=
    rx1286_cur."!cursor_pos"(rx1286_pos)
    $P10 = rx1286_cur."O"("%autoincrement")
    unless $P10, rx1286_fail
    rx1286_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1286_pos = $P10."pos"()
  # rx pass
    rx1286_cur."!cursor_pass"(rx1286_pos, "postfix:sym<-->")
    if_null rx1286_debug, debug_946
    rx1286_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1286_pos)
  debug_946:
    .return (rx1286_cur)
  rx1286_restart:
.annotate 'line', 4
    if_null rx1286_debug, debug_947
    rx1286_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_947:
  rx1286_fail:
    (rx1286_rep, rx1286_pos, $I10, $P10) = rx1286_cur."!mark_fail"(0)
    lt rx1286_pos, -1, rx1286_done
    eq rx1286_pos, -1, rx1286_fail
    jump $I10
  rx1286_done:
    rx1286_cur."!cursor_fail"()
    if_null rx1286_debug, debug_948
    rx1286_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_948:
    .return (rx1286_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("289_1298839231.515") :method
.annotate 'line', 4
    $P1288 = self."!PREFIX__!subrule"("O", "--")
    new $P1289, "ResizablePMCArray"
    push $P1289, $P1288
    .return ($P1289)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("290_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1293_tgt
    .local int rx1293_pos
    .local int rx1293_off
    .local int rx1293_eos
    .local int rx1293_rep
    .local pmc rx1293_cur
    .local pmc rx1293_debug
    (rx1293_cur, rx1293_pos, rx1293_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1293_cur
    .local pmc match
    .lex "$/", match
    length rx1293_eos, rx1293_tgt
    gt rx1293_pos, rx1293_eos, rx1293_done
    set rx1293_off, 0
    lt rx1293_pos, 2, rx1293_start
    sub rx1293_off, rx1293_pos, 1
    substr rx1293_tgt, rx1293_tgt, rx1293_off
  rx1293_start:
    eq $I10, 1, rx1293_restart
    if_null rx1293_debug, debug_949
    rx1293_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1297_done
    goto rxscan1297_scan
  rxscan1297_loop:
    (rx1293_pos) = rx1293_cur."from"()
    inc rx1293_pos
    rx1293_cur."!cursor_from"(rx1293_pos)
    ge rx1293_pos, rx1293_eos, rxscan1297_done
  rxscan1297_scan:
    set_addr $I10, rxscan1297_loop
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  rxscan1297_done:
.annotate 'line', 593
  # rx subcapture "sym"
    set_addr $I10, rxcap_1298_fail
    rx1293_cur."!mark_push"(0, rx1293_pos, $I10)
  # rx literal  "**"
    add $I11, rx1293_pos, 2
    gt $I11, rx1293_eos, rx1293_fail
    sub $I11, rx1293_pos, rx1293_off
    substr $S10, rx1293_tgt, $I11, 2
    ne $S10, "**", rx1293_fail
    add rx1293_pos, 2
    set_addr $I10, rxcap_1298_fail
    ($I12, $I11) = rx1293_cur."!mark_peek"($I10)
    rx1293_cur."!cursor_pos"($I11)
    ($P10) = rx1293_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1293_pos, "")
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1298_done
  rxcap_1298_fail:
    goto rx1293_fail
  rxcap_1298_done:
  # rx subrule "O" subtype=capture negate=
    rx1293_cur."!cursor_pos"(rx1293_pos)
    $P10 = rx1293_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1293_fail
    rx1293_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1293_pos = $P10."pos"()
  # rx pass
    rx1293_cur."!cursor_pass"(rx1293_pos, "infix:sym<**>")
    if_null rx1293_debug, debug_950
    rx1293_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1293_pos)
  debug_950:
    .return (rx1293_cur)
  rx1293_restart:
.annotate 'line', 4
    if_null rx1293_debug, debug_951
    rx1293_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_951:
  rx1293_fail:
    (rx1293_rep, rx1293_pos, $I10, $P10) = rx1293_cur."!mark_fail"(0)
    lt rx1293_pos, -1, rx1293_done
    eq rx1293_pos, -1, rx1293_fail
    jump $I10
  rx1293_done:
    rx1293_cur."!cursor_fail"()
    if_null rx1293_debug, debug_952
    rx1293_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_952:
    .return (rx1293_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("291_1298839231.515") :method
.annotate 'line', 4
    $P1295 = self."!PREFIX__!subrule"("O", "**")
    new $P1296, "ResizablePMCArray"
    push $P1296, $P1295
    .return ($P1296)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("292_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1300_tgt
    .local int rx1300_pos
    .local int rx1300_off
    .local int rx1300_eos
    .local int rx1300_rep
    .local pmc rx1300_cur
    .local pmc rx1300_debug
    (rx1300_cur, rx1300_pos, rx1300_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1300_cur
    .local pmc match
    .lex "$/", match
    length rx1300_eos, rx1300_tgt
    gt rx1300_pos, rx1300_eos, rx1300_done
    set rx1300_off, 0
    lt rx1300_pos, 2, rx1300_start
    sub rx1300_off, rx1300_pos, 1
    substr rx1300_tgt, rx1300_tgt, rx1300_off
  rx1300_start:
    eq $I10, 1, rx1300_restart
    if_null rx1300_debug, debug_953
    rx1300_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1304_done
    goto rxscan1304_scan
  rxscan1304_loop:
    (rx1300_pos) = rx1300_cur."from"()
    inc rx1300_pos
    rx1300_cur."!cursor_from"(rx1300_pos)
    ge rx1300_pos, rx1300_eos, rxscan1304_done
  rxscan1304_scan:
    set_addr $I10, rxscan1304_loop
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  rxscan1304_done:
.annotate 'line', 595
  # rx subcapture "sym"
    set_addr $I10, rxcap_1305_fail
    rx1300_cur."!mark_push"(0, rx1300_pos, $I10)
  # rx literal  "+"
    add $I11, rx1300_pos, 1
    gt $I11, rx1300_eos, rx1300_fail
    sub $I11, rx1300_pos, rx1300_off
    ord $I11, rx1300_tgt, $I11
    ne $I11, 43, rx1300_fail
    add rx1300_pos, 1
    set_addr $I10, rxcap_1305_fail
    ($I12, $I11) = rx1300_cur."!mark_peek"($I10)
    rx1300_cur."!cursor_pos"($I11)
    ($P10) = rx1300_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1300_pos, "")
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1305_done
  rxcap_1305_fail:
    goto rx1300_fail
  rxcap_1305_done:
  # rx subrule "O" subtype=capture negate=
    rx1300_cur."!cursor_pos"(rx1300_pos)
    $P10 = rx1300_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1300_fail
    rx1300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1300_pos = $P10."pos"()
  # rx pass
    rx1300_cur."!cursor_pass"(rx1300_pos, "prefix:sym<+>")
    if_null rx1300_debug, debug_954
    rx1300_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1300_pos)
  debug_954:
    .return (rx1300_cur)
  rx1300_restart:
.annotate 'line', 4
    if_null rx1300_debug, debug_955
    rx1300_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_955:
  rx1300_fail:
    (rx1300_rep, rx1300_pos, $I10, $P10) = rx1300_cur."!mark_fail"(0)
    lt rx1300_pos, -1, rx1300_done
    eq rx1300_pos, -1, rx1300_fail
    jump $I10
  rx1300_done:
    rx1300_cur."!cursor_fail"()
    if_null rx1300_debug, debug_956
    rx1300_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_956:
    .return (rx1300_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("293_1298839231.515") :method
.annotate 'line', 4
    $P1302 = self."!PREFIX__!subrule"("O", "+")
    new $P1303, "ResizablePMCArray"
    push $P1303, $P1302
    .return ($P1303)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("294_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1307_tgt
    .local int rx1307_pos
    .local int rx1307_off
    .local int rx1307_eos
    .local int rx1307_rep
    .local pmc rx1307_cur
    .local pmc rx1307_debug
    (rx1307_cur, rx1307_pos, rx1307_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1307_cur
    .local pmc match
    .lex "$/", match
    length rx1307_eos, rx1307_tgt
    gt rx1307_pos, rx1307_eos, rx1307_done
    set rx1307_off, 0
    lt rx1307_pos, 2, rx1307_start
    sub rx1307_off, rx1307_pos, 1
    substr rx1307_tgt, rx1307_tgt, rx1307_off
  rx1307_start:
    eq $I10, 1, rx1307_restart
    if_null rx1307_debug, debug_957
    rx1307_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1311_done
    goto rxscan1311_scan
  rxscan1311_loop:
    (rx1307_pos) = rx1307_cur."from"()
    inc rx1307_pos
    rx1307_cur."!cursor_from"(rx1307_pos)
    ge rx1307_pos, rx1307_eos, rxscan1311_done
  rxscan1311_scan:
    set_addr $I10, rxscan1311_loop
    rx1307_cur."!mark_push"(0, rx1307_pos, $I10)
  rxscan1311_done:
.annotate 'line', 596
  # rx subcapture "sym"
    set_addr $I10, rxcap_1312_fail
    rx1307_cur."!mark_push"(0, rx1307_pos, $I10)
  # rx literal  "~"
    add $I11, rx1307_pos, 1
    gt $I11, rx1307_eos, rx1307_fail
    sub $I11, rx1307_pos, rx1307_off
    ord $I11, rx1307_tgt, $I11
    ne $I11, 126, rx1307_fail
    add rx1307_pos, 1
    set_addr $I10, rxcap_1312_fail
    ($I12, $I11) = rx1307_cur."!mark_peek"($I10)
    rx1307_cur."!cursor_pos"($I11)
    ($P10) = rx1307_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1307_pos, "")
    rx1307_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1312_done
  rxcap_1312_fail:
    goto rx1307_fail
  rxcap_1312_done:
  # rx subrule "O" subtype=capture negate=
    rx1307_cur."!cursor_pos"(rx1307_pos)
    $P10 = rx1307_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1307_fail
    rx1307_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1307_pos = $P10."pos"()
  # rx pass
    rx1307_cur."!cursor_pass"(rx1307_pos, "prefix:sym<~>")
    if_null rx1307_debug, debug_958
    rx1307_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1307_pos)
  debug_958:
    .return (rx1307_cur)
  rx1307_restart:
.annotate 'line', 4
    if_null rx1307_debug, debug_959
    rx1307_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_959:
  rx1307_fail:
    (rx1307_rep, rx1307_pos, $I10, $P10) = rx1307_cur."!mark_fail"(0)
    lt rx1307_pos, -1, rx1307_done
    eq rx1307_pos, -1, rx1307_fail
    jump $I10
  rx1307_done:
    rx1307_cur."!cursor_fail"()
    if_null rx1307_debug, debug_960
    rx1307_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_960:
    .return (rx1307_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("295_1298839231.515") :method
.annotate 'line', 4
    $P1309 = self."!PREFIX__!subrule"("O", "~")
    new $P1310, "ResizablePMCArray"
    push $P1310, $P1309
    .return ($P1310)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("296_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1314_tgt
    .local int rx1314_pos
    .local int rx1314_off
    .local int rx1314_eos
    .local int rx1314_rep
    .local pmc rx1314_cur
    .local pmc rx1314_debug
    (rx1314_cur, rx1314_pos, rx1314_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1314_cur
    .local pmc match
    .lex "$/", match
    length rx1314_eos, rx1314_tgt
    gt rx1314_pos, rx1314_eos, rx1314_done
    set rx1314_off, 0
    lt rx1314_pos, 2, rx1314_start
    sub rx1314_off, rx1314_pos, 1
    substr rx1314_tgt, rx1314_tgt, rx1314_off
  rx1314_start:
    eq $I10, 1, rx1314_restart
    if_null rx1314_debug, debug_961
    rx1314_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1317_done
    goto rxscan1317_scan
  rxscan1317_loop:
    (rx1314_pos) = rx1314_cur."from"()
    inc rx1314_pos
    rx1314_cur."!cursor_from"(rx1314_pos)
    ge rx1314_pos, rx1314_eos, rxscan1317_done
  rxscan1317_scan:
    set_addr $I10, rxscan1317_loop
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  rxscan1317_done:
.annotate 'line', 597
  # rx subcapture "sym"
    set_addr $I10, rxcap_1318_fail
    rx1314_cur."!mark_push"(0, rx1314_pos, $I10)
  # rx literal  "-"
    add $I11, rx1314_pos, 1
    gt $I11, rx1314_eos, rx1314_fail
    sub $I11, rx1314_pos, rx1314_off
    ord $I11, rx1314_tgt, $I11
    ne $I11, 45, rx1314_fail
    add rx1314_pos, 1
    set_addr $I10, rxcap_1318_fail
    ($I12, $I11) = rx1314_cur."!mark_peek"($I10)
    rx1314_cur."!cursor_pos"($I11)
    ($P10) = rx1314_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1314_pos, "")
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1318_done
  rxcap_1318_fail:
    goto rx1314_fail
  rxcap_1318_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1314_pos, rx1314_off
    substr $S10, rx1314_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1314_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."number"()
    if $P10, rx1314_fail
  # rx subrule "O" subtype=capture negate=
    rx1314_cur."!cursor_pos"(rx1314_pos)
    $P10 = rx1314_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1314_fail
    rx1314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1314_pos = $P10."pos"()
  # rx pass
    rx1314_cur."!cursor_pass"(rx1314_pos, "prefix:sym<->")
    if_null rx1314_debug, debug_962
    rx1314_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1314_pos)
  debug_962:
    .return (rx1314_cur)
  rx1314_restart:
.annotate 'line', 4
    if_null rx1314_debug, debug_963
    rx1314_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_963:
  rx1314_fail:
    (rx1314_rep, rx1314_pos, $I10, $P10) = rx1314_cur."!mark_fail"(0)
    lt rx1314_pos, -1, rx1314_done
    eq rx1314_pos, -1, rx1314_fail
    jump $I10
  rx1314_done:
    rx1314_cur."!cursor_fail"()
    if_null rx1314_debug, debug_964
    rx1314_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_964:
    .return (rx1314_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("297_1298839231.515") :method
.annotate 'line', 4
    new $P1316, "ResizablePMCArray"
    push $P1316, "-"
    .return ($P1316)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("298_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1320_tgt
    .local int rx1320_pos
    .local int rx1320_off
    .local int rx1320_eos
    .local int rx1320_rep
    .local pmc rx1320_cur
    .local pmc rx1320_debug
    (rx1320_cur, rx1320_pos, rx1320_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1320_cur
    .local pmc match
    .lex "$/", match
    length rx1320_eos, rx1320_tgt
    gt rx1320_pos, rx1320_eos, rx1320_done
    set rx1320_off, 0
    lt rx1320_pos, 2, rx1320_start
    sub rx1320_off, rx1320_pos, 1
    substr rx1320_tgt, rx1320_tgt, rx1320_off
  rx1320_start:
    eq $I10, 1, rx1320_restart
    if_null rx1320_debug, debug_965
    rx1320_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1324_done
    goto rxscan1324_scan
  rxscan1324_loop:
    (rx1320_pos) = rx1320_cur."from"()
    inc rx1320_pos
    rx1320_cur."!cursor_from"(rx1320_pos)
    ge rx1320_pos, rx1320_eos, rxscan1324_done
  rxscan1324_scan:
    set_addr $I10, rxscan1324_loop
    rx1320_cur."!mark_push"(0, rx1320_pos, $I10)
  rxscan1324_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1325_fail
    rx1320_cur."!mark_push"(0, rx1320_pos, $I10)
  # rx literal  "?"
    add $I11, rx1320_pos, 1
    gt $I11, rx1320_eos, rx1320_fail
    sub $I11, rx1320_pos, rx1320_off
    ord $I11, rx1320_tgt, $I11
    ne $I11, 63, rx1320_fail
    add rx1320_pos, 1
    set_addr $I10, rxcap_1325_fail
    ($I12, $I11) = rx1320_cur."!mark_peek"($I10)
    rx1320_cur."!cursor_pos"($I11)
    ($P10) = rx1320_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1320_pos, "")
    rx1320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1325_done
  rxcap_1325_fail:
    goto rx1320_fail
  rxcap_1325_done:
  # rx subrule "O" subtype=capture negate=
    rx1320_cur."!cursor_pos"(rx1320_pos)
    $P10 = rx1320_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1320_fail
    rx1320_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1320_pos = $P10."pos"()
  # rx pass
    rx1320_cur."!cursor_pass"(rx1320_pos, "prefix:sym<?>")
    if_null rx1320_debug, debug_966
    rx1320_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1320_pos)
  debug_966:
    .return (rx1320_cur)
  rx1320_restart:
.annotate 'line', 4
    if_null rx1320_debug, debug_967
    rx1320_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_967:
  rx1320_fail:
    (rx1320_rep, rx1320_pos, $I10, $P10) = rx1320_cur."!mark_fail"(0)
    lt rx1320_pos, -1, rx1320_done
    eq rx1320_pos, -1, rx1320_fail
    jump $I10
  rx1320_done:
    rx1320_cur."!cursor_fail"()
    if_null rx1320_debug, debug_968
    rx1320_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_968:
    .return (rx1320_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("299_1298839231.515") :method
.annotate 'line', 4
    $P1322 = self."!PREFIX__!subrule"("O", "?")
    new $P1323, "ResizablePMCArray"
    push $P1323, $P1322
    .return ($P1323)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("300_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1327_tgt
    .local int rx1327_pos
    .local int rx1327_off
    .local int rx1327_eos
    .local int rx1327_rep
    .local pmc rx1327_cur
    .local pmc rx1327_debug
    (rx1327_cur, rx1327_pos, rx1327_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1327_cur
    .local pmc match
    .lex "$/", match
    length rx1327_eos, rx1327_tgt
    gt rx1327_pos, rx1327_eos, rx1327_done
    set rx1327_off, 0
    lt rx1327_pos, 2, rx1327_start
    sub rx1327_off, rx1327_pos, 1
    substr rx1327_tgt, rx1327_tgt, rx1327_off
  rx1327_start:
    eq $I10, 1, rx1327_restart
    if_null rx1327_debug, debug_969
    rx1327_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1331_done
    goto rxscan1331_scan
  rxscan1331_loop:
    (rx1327_pos) = rx1327_cur."from"()
    inc rx1327_pos
    rx1327_cur."!cursor_from"(rx1327_pos)
    ge rx1327_pos, rx1327_eos, rxscan1331_done
  rxscan1331_scan:
    set_addr $I10, rxscan1331_loop
    rx1327_cur."!mark_push"(0, rx1327_pos, $I10)
  rxscan1331_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1332_fail
    rx1327_cur."!mark_push"(0, rx1327_pos, $I10)
  # rx literal  "!"
    add $I11, rx1327_pos, 1
    gt $I11, rx1327_eos, rx1327_fail
    sub $I11, rx1327_pos, rx1327_off
    ord $I11, rx1327_tgt, $I11
    ne $I11, 33, rx1327_fail
    add rx1327_pos, 1
    set_addr $I10, rxcap_1332_fail
    ($I12, $I11) = rx1327_cur."!mark_peek"($I10)
    rx1327_cur."!cursor_pos"($I11)
    ($P10) = rx1327_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1327_pos, "")
    rx1327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1332_done
  rxcap_1332_fail:
    goto rx1327_fail
  rxcap_1332_done:
  # rx subrule "O" subtype=capture negate=
    rx1327_cur."!cursor_pos"(rx1327_pos)
    $P10 = rx1327_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1327_fail
    rx1327_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1327_pos = $P10."pos"()
  # rx pass
    rx1327_cur."!cursor_pass"(rx1327_pos, "prefix:sym<!>")
    if_null rx1327_debug, debug_970
    rx1327_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1327_pos)
  debug_970:
    .return (rx1327_cur)
  rx1327_restart:
.annotate 'line', 4
    if_null rx1327_debug, debug_971
    rx1327_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_971:
  rx1327_fail:
    (rx1327_rep, rx1327_pos, $I10, $P10) = rx1327_cur."!mark_fail"(0)
    lt rx1327_pos, -1, rx1327_done
    eq rx1327_pos, -1, rx1327_fail
    jump $I10
  rx1327_done:
    rx1327_cur."!cursor_fail"()
    if_null rx1327_debug, debug_972
    rx1327_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_972:
    .return (rx1327_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("301_1298839231.515") :method
.annotate 'line', 4
    $P1329 = self."!PREFIX__!subrule"("O", "!")
    new $P1330, "ResizablePMCArray"
    push $P1330, $P1329
    .return ($P1330)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("302_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1334_tgt
    .local int rx1334_pos
    .local int rx1334_off
    .local int rx1334_eos
    .local int rx1334_rep
    .local pmc rx1334_cur
    .local pmc rx1334_debug
    (rx1334_cur, rx1334_pos, rx1334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1334_cur
    .local pmc match
    .lex "$/", match
    length rx1334_eos, rx1334_tgt
    gt rx1334_pos, rx1334_eos, rx1334_done
    set rx1334_off, 0
    lt rx1334_pos, 2, rx1334_start
    sub rx1334_off, rx1334_pos, 1
    substr rx1334_tgt, rx1334_tgt, rx1334_off
  rx1334_start:
    eq $I10, 1, rx1334_restart
    if_null rx1334_debug, debug_973
    rx1334_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1338_done
    goto rxscan1338_scan
  rxscan1338_loop:
    (rx1334_pos) = rx1334_cur."from"()
    inc rx1334_pos
    rx1334_cur."!cursor_from"(rx1334_pos)
    ge rx1334_pos, rx1334_eos, rxscan1338_done
  rxscan1338_scan:
    set_addr $I10, rxscan1338_loop
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxscan1338_done:
.annotate 'line', 600
  # rx subcapture "sym"
    set_addr $I10, rxcap_1339_fail
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  # rx literal  "|"
    add $I11, rx1334_pos, 1
    gt $I11, rx1334_eos, rx1334_fail
    sub $I11, rx1334_pos, rx1334_off
    ord $I11, rx1334_tgt, $I11
    ne $I11, 124, rx1334_fail
    add rx1334_pos, 1
    set_addr $I10, rxcap_1339_fail
    ($I12, $I11) = rx1334_cur."!mark_peek"($I10)
    rx1334_cur."!cursor_pos"($I11)
    ($P10) = rx1334_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1334_pos, "")
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1339_done
  rxcap_1339_fail:
    goto rx1334_fail
  rxcap_1339_done:
  # rx subrule "O" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."O"("%symbolic_unary")
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1334_pos = $P10."pos"()
  # rx pass
    rx1334_cur."!cursor_pass"(rx1334_pos, "prefix:sym<|>")
    if_null rx1334_debug, debug_974
    rx1334_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1334_pos)
  debug_974:
    .return (rx1334_cur)
  rx1334_restart:
.annotate 'line', 4
    if_null rx1334_debug, debug_975
    rx1334_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_975:
  rx1334_fail:
    (rx1334_rep, rx1334_pos, $I10, $P10) = rx1334_cur."!mark_fail"(0)
    lt rx1334_pos, -1, rx1334_done
    eq rx1334_pos, -1, rx1334_fail
    jump $I10
  rx1334_done:
    rx1334_cur."!cursor_fail"()
    if_null rx1334_debug, debug_976
    rx1334_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_976:
    .return (rx1334_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("303_1298839231.515") :method
.annotate 'line', 4
    $P1336 = self."!PREFIX__!subrule"("O", "|")
    new $P1337, "ResizablePMCArray"
    push $P1337, $P1336
    .return ($P1337)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("304_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1341_tgt
    .local int rx1341_pos
    .local int rx1341_off
    .local int rx1341_eos
    .local int rx1341_rep
    .local pmc rx1341_cur
    .local pmc rx1341_debug
    (rx1341_cur, rx1341_pos, rx1341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1341_cur
    .local pmc match
    .lex "$/", match
    length rx1341_eos, rx1341_tgt
    gt rx1341_pos, rx1341_eos, rx1341_done
    set rx1341_off, 0
    lt rx1341_pos, 2, rx1341_start
    sub rx1341_off, rx1341_pos, 1
    substr rx1341_tgt, rx1341_tgt, rx1341_off
  rx1341_start:
    eq $I10, 1, rx1341_restart
    if_null rx1341_debug, debug_977
    rx1341_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1345_done
    goto rxscan1345_scan
  rxscan1345_loop:
    (rx1341_pos) = rx1341_cur."from"()
    inc rx1341_pos
    rx1341_cur."!cursor_from"(rx1341_pos)
    ge rx1341_pos, rx1341_eos, rxscan1345_done
  rxscan1345_scan:
    set_addr $I10, rxscan1345_loop
    rx1341_cur."!mark_push"(0, rx1341_pos, $I10)
  rxscan1345_done:
.annotate 'line', 602
  # rx subcapture "sym"
    set_addr $I10, rxcap_1346_fail
    rx1341_cur."!mark_push"(0, rx1341_pos, $I10)
  # rx literal  "*"
    add $I11, rx1341_pos, 1
    gt $I11, rx1341_eos, rx1341_fail
    sub $I11, rx1341_pos, rx1341_off
    ord $I11, rx1341_tgt, $I11
    ne $I11, 42, rx1341_fail
    add rx1341_pos, 1
    set_addr $I10, rxcap_1346_fail
    ($I12, $I11) = rx1341_cur."!mark_peek"($I10)
    rx1341_cur."!cursor_pos"($I11)
    ($P10) = rx1341_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1341_pos, "")
    rx1341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1346_done
  rxcap_1346_fail:
    goto rx1341_fail
  rxcap_1346_done:
  # rx subrule "O" subtype=capture negate=
    rx1341_cur."!cursor_pos"(rx1341_pos)
    $P10 = rx1341_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1341_fail
    rx1341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1341_pos = $P10."pos"()
  # rx pass
    rx1341_cur."!cursor_pass"(rx1341_pos, "infix:sym<*>")
    if_null rx1341_debug, debug_978
    rx1341_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1341_pos)
  debug_978:
    .return (rx1341_cur)
  rx1341_restart:
.annotate 'line', 4
    if_null rx1341_debug, debug_979
    rx1341_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_979:
  rx1341_fail:
    (rx1341_rep, rx1341_pos, $I10, $P10) = rx1341_cur."!mark_fail"(0)
    lt rx1341_pos, -1, rx1341_done
    eq rx1341_pos, -1, rx1341_fail
    jump $I10
  rx1341_done:
    rx1341_cur."!cursor_fail"()
    if_null rx1341_debug, debug_980
    rx1341_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_980:
    .return (rx1341_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("305_1298839231.515") :method
.annotate 'line', 4
    $P1343 = self."!PREFIX__!subrule"("O", "*")
    new $P1344, "ResizablePMCArray"
    push $P1344, $P1343
    .return ($P1344)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("306_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1348_tgt
    .local int rx1348_pos
    .local int rx1348_off
    .local int rx1348_eos
    .local int rx1348_rep
    .local pmc rx1348_cur
    .local pmc rx1348_debug
    (rx1348_cur, rx1348_pos, rx1348_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1348_cur
    .local pmc match
    .lex "$/", match
    length rx1348_eos, rx1348_tgt
    gt rx1348_pos, rx1348_eos, rx1348_done
    set rx1348_off, 0
    lt rx1348_pos, 2, rx1348_start
    sub rx1348_off, rx1348_pos, 1
    substr rx1348_tgt, rx1348_tgt, rx1348_off
  rx1348_start:
    eq $I10, 1, rx1348_restart
    if_null rx1348_debug, debug_981
    rx1348_cur."!cursor_debug"("START", "infix:sym</>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1352_done
    goto rxscan1352_scan
  rxscan1352_loop:
    (rx1348_pos) = rx1348_cur."from"()
    inc rx1348_pos
    rx1348_cur."!cursor_from"(rx1348_pos)
    ge rx1348_pos, rx1348_eos, rxscan1352_done
  rxscan1352_scan:
    set_addr $I10, rxscan1352_loop
    rx1348_cur."!mark_push"(0, rx1348_pos, $I10)
  rxscan1352_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1353_fail
    rx1348_cur."!mark_push"(0, rx1348_pos, $I10)
  # rx literal  "/"
    add $I11, rx1348_pos, 1
    gt $I11, rx1348_eos, rx1348_fail
    sub $I11, rx1348_pos, rx1348_off
    ord $I11, rx1348_tgt, $I11
    ne $I11, 47, rx1348_fail
    add rx1348_pos, 1
    set_addr $I10, rxcap_1353_fail
    ($I12, $I11) = rx1348_cur."!mark_peek"($I10)
    rx1348_cur."!cursor_pos"($I11)
    ($P10) = rx1348_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1348_pos, "")
    rx1348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1353_done
  rxcap_1353_fail:
    goto rx1348_fail
  rxcap_1353_done:
  # rx subrule "O" subtype=capture negate=
    rx1348_cur."!cursor_pos"(rx1348_pos)
    $P10 = rx1348_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1348_fail
    rx1348_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1348_pos = $P10."pos"()
  # rx pass
    rx1348_cur."!cursor_pass"(rx1348_pos, "infix:sym</>")
    if_null rx1348_debug, debug_982
    rx1348_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1348_pos)
  debug_982:
    .return (rx1348_cur)
  rx1348_restart:
.annotate 'line', 4
    if_null rx1348_debug, debug_983
    rx1348_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_983:
  rx1348_fail:
    (rx1348_rep, rx1348_pos, $I10, $P10) = rx1348_cur."!mark_fail"(0)
    lt rx1348_pos, -1, rx1348_done
    eq rx1348_pos, -1, rx1348_fail
    jump $I10
  rx1348_done:
    rx1348_cur."!cursor_fail"()
    if_null rx1348_debug, debug_984
    rx1348_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_984:
    .return (rx1348_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("307_1298839231.515") :method
.annotate 'line', 4
    $P1350 = self."!PREFIX__!subrule"("O", "/")
    new $P1351, "ResizablePMCArray"
    push $P1351, $P1350
    .return ($P1351)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("308_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1355_tgt
    .local int rx1355_pos
    .local int rx1355_off
    .local int rx1355_eos
    .local int rx1355_rep
    .local pmc rx1355_cur
    .local pmc rx1355_debug
    (rx1355_cur, rx1355_pos, rx1355_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1355_cur
    .local pmc match
    .lex "$/", match
    length rx1355_eos, rx1355_tgt
    gt rx1355_pos, rx1355_eos, rx1355_done
    set rx1355_off, 0
    lt rx1355_pos, 2, rx1355_start
    sub rx1355_off, rx1355_pos, 1
    substr rx1355_tgt, rx1355_tgt, rx1355_off
  rx1355_start:
    eq $I10, 1, rx1355_restart
    if_null rx1355_debug, debug_985
    rx1355_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1359_done
    goto rxscan1359_scan
  rxscan1359_loop:
    (rx1355_pos) = rx1355_cur."from"()
    inc rx1355_pos
    rx1355_cur."!cursor_from"(rx1355_pos)
    ge rx1355_pos, rx1355_eos, rxscan1359_done
  rxscan1359_scan:
    set_addr $I10, rxscan1359_loop
    rx1355_cur."!mark_push"(0, rx1355_pos, $I10)
  rxscan1359_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1360_fail
    rx1355_cur."!mark_push"(0, rx1355_pos, $I10)
  # rx literal  "%"
    add $I11, rx1355_pos, 1
    gt $I11, rx1355_eos, rx1355_fail
    sub $I11, rx1355_pos, rx1355_off
    ord $I11, rx1355_tgt, $I11
    ne $I11, 37, rx1355_fail
    add rx1355_pos, 1
    set_addr $I10, rxcap_1360_fail
    ($I12, $I11) = rx1355_cur."!mark_peek"($I10)
    rx1355_cur."!cursor_pos"($I11)
    ($P10) = rx1355_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1355_pos, "")
    rx1355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1360_done
  rxcap_1360_fail:
    goto rx1355_fail
  rxcap_1360_done:
  # rx subrule "O" subtype=capture negate=
    rx1355_cur."!cursor_pos"(rx1355_pos)
    $P10 = rx1355_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1355_fail
    rx1355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1355_pos = $P10."pos"()
  # rx pass
    rx1355_cur."!cursor_pass"(rx1355_pos, "infix:sym<%>")
    if_null rx1355_debug, debug_986
    rx1355_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1355_pos)
  debug_986:
    .return (rx1355_cur)
  rx1355_restart:
.annotate 'line', 4
    if_null rx1355_debug, debug_987
    rx1355_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_987:
  rx1355_fail:
    (rx1355_rep, rx1355_pos, $I10, $P10) = rx1355_cur."!mark_fail"(0)
    lt rx1355_pos, -1, rx1355_done
    eq rx1355_pos, -1, rx1355_fail
    jump $I10
  rx1355_done:
    rx1355_cur."!cursor_fail"()
    if_null rx1355_debug, debug_988
    rx1355_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_988:
    .return (rx1355_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("309_1298839231.515") :method
.annotate 'line', 4
    $P1357 = self."!PREFIX__!subrule"("O", "%")
    new $P1358, "ResizablePMCArray"
    push $P1358, $P1357
    .return ($P1358)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("310_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1362_tgt
    .local int rx1362_pos
    .local int rx1362_off
    .local int rx1362_eos
    .local int rx1362_rep
    .local pmc rx1362_cur
    .local pmc rx1362_debug
    (rx1362_cur, rx1362_pos, rx1362_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1362_cur
    .local pmc match
    .lex "$/", match
    length rx1362_eos, rx1362_tgt
    gt rx1362_pos, rx1362_eos, rx1362_done
    set rx1362_off, 0
    lt rx1362_pos, 2, rx1362_start
    sub rx1362_off, rx1362_pos, 1
    substr rx1362_tgt, rx1362_tgt, rx1362_off
  rx1362_start:
    eq $I10, 1, rx1362_restart
    if_null rx1362_debug, debug_989
    rx1362_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1366_done
    goto rxscan1366_scan
  rxscan1366_loop:
    (rx1362_pos) = rx1362_cur."from"()
    inc rx1362_pos
    rx1362_cur."!cursor_from"(rx1362_pos)
    ge rx1362_pos, rx1362_eos, rxscan1366_done
  rxscan1366_scan:
    set_addr $I10, rxscan1366_loop
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  rxscan1366_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1367_fail
    rx1362_cur."!mark_push"(0, rx1362_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1362_pos, 2
    gt $I11, rx1362_eos, rx1362_fail
    sub $I11, rx1362_pos, rx1362_off
    substr $S10, rx1362_tgt, $I11, 2
    ne $S10, "+&", rx1362_fail
    add rx1362_pos, 2
    set_addr $I10, rxcap_1367_fail
    ($I12, $I11) = rx1362_cur."!mark_peek"($I10)
    rx1362_cur."!cursor_pos"($I11)
    ($P10) = rx1362_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1362_pos, "")
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1367_done
  rxcap_1367_fail:
    goto rx1362_fail
  rxcap_1367_done:
  # rx subrule "O" subtype=capture negate=
    rx1362_cur."!cursor_pos"(rx1362_pos)
    $P10 = rx1362_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1362_fail
    rx1362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1362_pos = $P10."pos"()
  # rx pass
    rx1362_cur."!cursor_pass"(rx1362_pos, "infix:sym<+&>")
    if_null rx1362_debug, debug_990
    rx1362_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1362_pos)
  debug_990:
    .return (rx1362_cur)
  rx1362_restart:
.annotate 'line', 4
    if_null rx1362_debug, debug_991
    rx1362_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_991:
  rx1362_fail:
    (rx1362_rep, rx1362_pos, $I10, $P10) = rx1362_cur."!mark_fail"(0)
    lt rx1362_pos, -1, rx1362_done
    eq rx1362_pos, -1, rx1362_fail
    jump $I10
  rx1362_done:
    rx1362_cur."!cursor_fail"()
    if_null rx1362_debug, debug_992
    rx1362_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_992:
    .return (rx1362_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("311_1298839231.515") :method
.annotate 'line', 4
    $P1364 = self."!PREFIX__!subrule"("O", "+&")
    new $P1365, "ResizablePMCArray"
    push $P1365, $P1364
    .return ($P1365)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("312_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1369_tgt
    .local int rx1369_pos
    .local int rx1369_off
    .local int rx1369_eos
    .local int rx1369_rep
    .local pmc rx1369_cur
    .local pmc rx1369_debug
    (rx1369_cur, rx1369_pos, rx1369_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1369_cur
    .local pmc match
    .lex "$/", match
    length rx1369_eos, rx1369_tgt
    gt rx1369_pos, rx1369_eos, rx1369_done
    set rx1369_off, 0
    lt rx1369_pos, 2, rx1369_start
    sub rx1369_off, rx1369_pos, 1
    substr rx1369_tgt, rx1369_tgt, rx1369_off
  rx1369_start:
    eq $I10, 1, rx1369_restart
    if_null rx1369_debug, debug_993
    rx1369_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1373_done
    goto rxscan1373_scan
  rxscan1373_loop:
    (rx1369_pos) = rx1369_cur."from"()
    inc rx1369_pos
    rx1369_cur."!cursor_from"(rx1369_pos)
    ge rx1369_pos, rx1369_eos, rxscan1373_done
  rxscan1373_scan:
    set_addr $I10, rxscan1373_loop
    rx1369_cur."!mark_push"(0, rx1369_pos, $I10)
  rxscan1373_done:
.annotate 'line', 607
  # rx subcapture "sym"
    set_addr $I10, rxcap_1374_fail
    rx1369_cur."!mark_push"(0, rx1369_pos, $I10)
  # rx literal  "+"
    add $I11, rx1369_pos, 1
    gt $I11, rx1369_eos, rx1369_fail
    sub $I11, rx1369_pos, rx1369_off
    ord $I11, rx1369_tgt, $I11
    ne $I11, 43, rx1369_fail
    add rx1369_pos, 1
    set_addr $I10, rxcap_1374_fail
    ($I12, $I11) = rx1369_cur."!mark_peek"($I10)
    rx1369_cur."!cursor_pos"($I11)
    ($P10) = rx1369_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1369_pos, "")
    rx1369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1374_done
  rxcap_1374_fail:
    goto rx1369_fail
  rxcap_1374_done:
  # rx subrule "O" subtype=capture negate=
    rx1369_cur."!cursor_pos"(rx1369_pos)
    $P10 = rx1369_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1369_fail
    rx1369_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1369_pos = $P10."pos"()
  # rx pass
    rx1369_cur."!cursor_pass"(rx1369_pos, "infix:sym<+>")
    if_null rx1369_debug, debug_994
    rx1369_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1369_pos)
  debug_994:
    .return (rx1369_cur)
  rx1369_restart:
.annotate 'line', 4
    if_null rx1369_debug, debug_995
    rx1369_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_995:
  rx1369_fail:
    (rx1369_rep, rx1369_pos, $I10, $P10) = rx1369_cur."!mark_fail"(0)
    lt rx1369_pos, -1, rx1369_done
    eq rx1369_pos, -1, rx1369_fail
    jump $I10
  rx1369_done:
    rx1369_cur."!cursor_fail"()
    if_null rx1369_debug, debug_996
    rx1369_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_996:
    .return (rx1369_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("313_1298839231.515") :method
.annotate 'line', 4
    $P1371 = self."!PREFIX__!subrule"("O", "+")
    new $P1372, "ResizablePMCArray"
    push $P1372, $P1371
    .return ($P1372)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("314_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1376_tgt
    .local int rx1376_pos
    .local int rx1376_off
    .local int rx1376_eos
    .local int rx1376_rep
    .local pmc rx1376_cur
    .local pmc rx1376_debug
    (rx1376_cur, rx1376_pos, rx1376_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1376_cur
    .local pmc match
    .lex "$/", match
    length rx1376_eos, rx1376_tgt
    gt rx1376_pos, rx1376_eos, rx1376_done
    set rx1376_off, 0
    lt rx1376_pos, 2, rx1376_start
    sub rx1376_off, rx1376_pos, 1
    substr rx1376_tgt, rx1376_tgt, rx1376_off
  rx1376_start:
    eq $I10, 1, rx1376_restart
    if_null rx1376_debug, debug_997
    rx1376_cur."!cursor_debug"("START", "infix:sym<->")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1380_done
    goto rxscan1380_scan
  rxscan1380_loop:
    (rx1376_pos) = rx1376_cur."from"()
    inc rx1376_pos
    rx1376_cur."!cursor_from"(rx1376_pos)
    ge rx1376_pos, rx1376_eos, rxscan1380_done
  rxscan1380_scan:
    set_addr $I10, rxscan1380_loop
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10)
  rxscan1380_done:
.annotate 'line', 608
  # rx subcapture "sym"
    set_addr $I10, rxcap_1381_fail
    rx1376_cur."!mark_push"(0, rx1376_pos, $I10)
  # rx literal  "-"
    add $I11, rx1376_pos, 1
    gt $I11, rx1376_eos, rx1376_fail
    sub $I11, rx1376_pos, rx1376_off
    ord $I11, rx1376_tgt, $I11
    ne $I11, 45, rx1376_fail
    add rx1376_pos, 1
    set_addr $I10, rxcap_1381_fail
    ($I12, $I11) = rx1376_cur."!mark_peek"($I10)
    rx1376_cur."!cursor_pos"($I11)
    ($P10) = rx1376_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1376_pos, "")
    rx1376_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1381_done
  rxcap_1381_fail:
    goto rx1376_fail
  rxcap_1381_done:
  # rx subrule "O" subtype=capture negate=
    rx1376_cur."!cursor_pos"(rx1376_pos)
    $P10 = rx1376_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1376_fail
    rx1376_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1376_pos = $P10."pos"()
  # rx pass
    rx1376_cur."!cursor_pass"(rx1376_pos, "infix:sym<->")
    if_null rx1376_debug, debug_998
    rx1376_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1376_pos)
  debug_998:
    .return (rx1376_cur)
  rx1376_restart:
.annotate 'line', 4
    if_null rx1376_debug, debug_999
    rx1376_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_999:
  rx1376_fail:
    (rx1376_rep, rx1376_pos, $I10, $P10) = rx1376_cur."!mark_fail"(0)
    lt rx1376_pos, -1, rx1376_done
    eq rx1376_pos, -1, rx1376_fail
    jump $I10
  rx1376_done:
    rx1376_cur."!cursor_fail"()
    if_null rx1376_debug, debug_1000
    rx1376_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1000:
    .return (rx1376_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("315_1298839231.515") :method
.annotate 'line', 4
    $P1378 = self."!PREFIX__!subrule"("O", "-")
    new $P1379, "ResizablePMCArray"
    push $P1379, $P1378
    .return ($P1379)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("316_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1383_tgt
    .local int rx1383_pos
    .local int rx1383_off
    .local int rx1383_eos
    .local int rx1383_rep
    .local pmc rx1383_cur
    .local pmc rx1383_debug
    (rx1383_cur, rx1383_pos, rx1383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1383_cur
    .local pmc match
    .lex "$/", match
    length rx1383_eos, rx1383_tgt
    gt rx1383_pos, rx1383_eos, rx1383_done
    set rx1383_off, 0
    lt rx1383_pos, 2, rx1383_start
    sub rx1383_off, rx1383_pos, 1
    substr rx1383_tgt, rx1383_tgt, rx1383_off
  rx1383_start:
    eq $I10, 1, rx1383_restart
    if_null rx1383_debug, debug_1001
    rx1383_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1387_done
    goto rxscan1387_scan
  rxscan1387_loop:
    (rx1383_pos) = rx1383_cur."from"()
    inc rx1383_pos
    rx1383_cur."!cursor_from"(rx1383_pos)
    ge rx1383_pos, rx1383_eos, rxscan1387_done
  rxscan1387_scan:
    set_addr $I10, rxscan1387_loop
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  rxscan1387_done:
.annotate 'line', 609
  # rx subcapture "sym"
    set_addr $I10, rxcap_1388_fail
    rx1383_cur."!mark_push"(0, rx1383_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1383_pos, 2
    gt $I11, rx1383_eos, rx1383_fail
    sub $I11, rx1383_pos, rx1383_off
    substr $S10, rx1383_tgt, $I11, 2
    ne $S10, "+|", rx1383_fail
    add rx1383_pos, 2
    set_addr $I10, rxcap_1388_fail
    ($I12, $I11) = rx1383_cur."!mark_peek"($I10)
    rx1383_cur."!cursor_pos"($I11)
    ($P10) = rx1383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1383_pos, "")
    rx1383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1388_done
  rxcap_1388_fail:
    goto rx1383_fail
  rxcap_1388_done:
  # rx subrule "O" subtype=capture negate=
    rx1383_cur."!cursor_pos"(rx1383_pos)
    $P10 = rx1383_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1383_fail
    rx1383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1383_pos = $P10."pos"()
  # rx pass
    rx1383_cur."!cursor_pass"(rx1383_pos, "infix:sym<+|>")
    if_null rx1383_debug, debug_1002
    rx1383_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1383_pos)
  debug_1002:
    .return (rx1383_cur)
  rx1383_restart:
.annotate 'line', 4
    if_null rx1383_debug, debug_1003
    rx1383_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1003:
  rx1383_fail:
    (rx1383_rep, rx1383_pos, $I10, $P10) = rx1383_cur."!mark_fail"(0)
    lt rx1383_pos, -1, rx1383_done
    eq rx1383_pos, -1, rx1383_fail
    jump $I10
  rx1383_done:
    rx1383_cur."!cursor_fail"()
    if_null rx1383_debug, debug_1004
    rx1383_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1004:
    .return (rx1383_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("317_1298839231.515") :method
.annotate 'line', 4
    $P1385 = self."!PREFIX__!subrule"("O", "+|")
    new $P1386, "ResizablePMCArray"
    push $P1386, $P1385
    .return ($P1386)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("318_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1390_tgt
    .local int rx1390_pos
    .local int rx1390_off
    .local int rx1390_eos
    .local int rx1390_rep
    .local pmc rx1390_cur
    .local pmc rx1390_debug
    (rx1390_cur, rx1390_pos, rx1390_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1390_cur
    .local pmc match
    .lex "$/", match
    length rx1390_eos, rx1390_tgt
    gt rx1390_pos, rx1390_eos, rx1390_done
    set rx1390_off, 0
    lt rx1390_pos, 2, rx1390_start
    sub rx1390_off, rx1390_pos, 1
    substr rx1390_tgt, rx1390_tgt, rx1390_off
  rx1390_start:
    eq $I10, 1, rx1390_restart
    if_null rx1390_debug, debug_1005
    rx1390_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1394_done
    goto rxscan1394_scan
  rxscan1394_loop:
    (rx1390_pos) = rx1390_cur."from"()
    inc rx1390_pos
    rx1390_cur."!cursor_from"(rx1390_pos)
    ge rx1390_pos, rx1390_eos, rxscan1394_done
  rxscan1394_scan:
    set_addr $I10, rxscan1394_loop
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
  rxscan1394_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1395_fail
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1390_pos, 2
    gt $I11, rx1390_eos, rx1390_fail
    sub $I11, rx1390_pos, rx1390_off
    substr $S10, rx1390_tgt, $I11, 2
    ne $S10, "+^", rx1390_fail
    add rx1390_pos, 2
    set_addr $I10, rxcap_1395_fail
    ($I12, $I11) = rx1390_cur."!mark_peek"($I10)
    rx1390_cur."!cursor_pos"($I11)
    ($P10) = rx1390_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1390_pos, "")
    rx1390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1395_done
  rxcap_1395_fail:
    goto rx1390_fail
  rxcap_1395_done:
  # rx subrule "O" subtype=capture negate=
    rx1390_cur."!cursor_pos"(rx1390_pos)
    $P10 = rx1390_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1390_fail
    rx1390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1390_pos = $P10."pos"()
  # rx pass
    rx1390_cur."!cursor_pass"(rx1390_pos, "infix:sym<+^>")
    if_null rx1390_debug, debug_1006
    rx1390_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1390_pos)
  debug_1006:
    .return (rx1390_cur)
  rx1390_restart:
.annotate 'line', 4
    if_null rx1390_debug, debug_1007
    rx1390_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1007:
  rx1390_fail:
    (rx1390_rep, rx1390_pos, $I10, $P10) = rx1390_cur."!mark_fail"(0)
    lt rx1390_pos, -1, rx1390_done
    eq rx1390_pos, -1, rx1390_fail
    jump $I10
  rx1390_done:
    rx1390_cur."!cursor_fail"()
    if_null rx1390_debug, debug_1008
    rx1390_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1008:
    .return (rx1390_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("319_1298839231.515") :method
.annotate 'line', 4
    $P1392 = self."!PREFIX__!subrule"("O", "+^")
    new $P1393, "ResizablePMCArray"
    push $P1393, $P1392
    .return ($P1393)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("320_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1397_tgt
    .local int rx1397_pos
    .local int rx1397_off
    .local int rx1397_eos
    .local int rx1397_rep
    .local pmc rx1397_cur
    .local pmc rx1397_debug
    (rx1397_cur, rx1397_pos, rx1397_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1397_cur
    .local pmc match
    .lex "$/", match
    length rx1397_eos, rx1397_tgt
    gt rx1397_pos, rx1397_eos, rx1397_done
    set rx1397_off, 0
    lt rx1397_pos, 2, rx1397_start
    sub rx1397_off, rx1397_pos, 1
    substr rx1397_tgt, rx1397_tgt, rx1397_off
  rx1397_start:
    eq $I10, 1, rx1397_restart
    if_null rx1397_debug, debug_1009
    rx1397_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1401_done
    goto rxscan1401_scan
  rxscan1401_loop:
    (rx1397_pos) = rx1397_cur."from"()
    inc rx1397_pos
    rx1397_cur."!cursor_from"(rx1397_pos)
    ge rx1397_pos, rx1397_eos, rxscan1401_done
  rxscan1401_scan:
    set_addr $I10, rxscan1401_loop
    rx1397_cur."!mark_push"(0, rx1397_pos, $I10)
  rxscan1401_done:
.annotate 'line', 612
  # rx subcapture "sym"
    set_addr $I10, rxcap_1402_fail
    rx1397_cur."!mark_push"(0, rx1397_pos, $I10)
  # rx literal  "~"
    add $I11, rx1397_pos, 1
    gt $I11, rx1397_eos, rx1397_fail
    sub $I11, rx1397_pos, rx1397_off
    ord $I11, rx1397_tgt, $I11
    ne $I11, 126, rx1397_fail
    add rx1397_pos, 1
    set_addr $I10, rxcap_1402_fail
    ($I12, $I11) = rx1397_cur."!mark_peek"($I10)
    rx1397_cur."!cursor_pos"($I11)
    ($P10) = rx1397_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1397_pos, "")
    rx1397_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1402_done
  rxcap_1402_fail:
    goto rx1397_fail
  rxcap_1402_done:
  # rx subrule "O" subtype=capture negate=
    rx1397_cur."!cursor_pos"(rx1397_pos)
    $P10 = rx1397_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1397_fail
    rx1397_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1397_pos = $P10."pos"()
  # rx pass
    rx1397_cur."!cursor_pass"(rx1397_pos, "infix:sym<~>")
    if_null rx1397_debug, debug_1010
    rx1397_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1397_pos)
  debug_1010:
    .return (rx1397_cur)
  rx1397_restart:
.annotate 'line', 4
    if_null rx1397_debug, debug_1011
    rx1397_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1011:
  rx1397_fail:
    (rx1397_rep, rx1397_pos, $I10, $P10) = rx1397_cur."!mark_fail"(0)
    lt rx1397_pos, -1, rx1397_done
    eq rx1397_pos, -1, rx1397_fail
    jump $I10
  rx1397_done:
    rx1397_cur."!cursor_fail"()
    if_null rx1397_debug, debug_1012
    rx1397_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1012:
    .return (rx1397_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("321_1298839231.515") :method
.annotate 'line', 4
    $P1399 = self."!PREFIX__!subrule"("O", "~")
    new $P1400, "ResizablePMCArray"
    push $P1400, $P1399
    .return ($P1400)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("322_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1404_tgt
    .local int rx1404_pos
    .local int rx1404_off
    .local int rx1404_eos
    .local int rx1404_rep
    .local pmc rx1404_cur
    .local pmc rx1404_debug
    (rx1404_cur, rx1404_pos, rx1404_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1404_cur
    .local pmc match
    .lex "$/", match
    length rx1404_eos, rx1404_tgt
    gt rx1404_pos, rx1404_eos, rx1404_done
    set rx1404_off, 0
    lt rx1404_pos, 2, rx1404_start
    sub rx1404_off, rx1404_pos, 1
    substr rx1404_tgt, rx1404_tgt, rx1404_off
  rx1404_start:
    eq $I10, 1, rx1404_restart
    if_null rx1404_debug, debug_1013
    rx1404_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1408_done
    goto rxscan1408_scan
  rxscan1408_loop:
    (rx1404_pos) = rx1404_cur."from"()
    inc rx1404_pos
    rx1404_cur."!cursor_from"(rx1404_pos)
    ge rx1404_pos, rx1404_eos, rxscan1408_done
  rxscan1408_scan:
    set_addr $I10, rxscan1408_loop
    rx1404_cur."!mark_push"(0, rx1404_pos, $I10)
  rxscan1408_done:
.annotate 'line', 614
  # rx subcapture "sym"
    set_addr $I10, rxcap_1409_fail
    rx1404_cur."!mark_push"(0, rx1404_pos, $I10)
  # rx literal  "=="
    add $I11, rx1404_pos, 2
    gt $I11, rx1404_eos, rx1404_fail
    sub $I11, rx1404_pos, rx1404_off
    substr $S10, rx1404_tgt, $I11, 2
    ne $S10, "==", rx1404_fail
    add rx1404_pos, 2
    set_addr $I10, rxcap_1409_fail
    ($I12, $I11) = rx1404_cur."!mark_peek"($I10)
    rx1404_cur."!cursor_pos"($I11)
    ($P10) = rx1404_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1404_pos, "")
    rx1404_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1409_done
  rxcap_1409_fail:
    goto rx1404_fail
  rxcap_1409_done:
  # rx subrule "O" subtype=capture negate=
    rx1404_cur."!cursor_pos"(rx1404_pos)
    $P10 = rx1404_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1404_fail
    rx1404_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1404_pos = $P10."pos"()
  # rx pass
    rx1404_cur."!cursor_pass"(rx1404_pos, "infix:sym<==>")
    if_null rx1404_debug, debug_1014
    rx1404_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1404_pos)
  debug_1014:
    .return (rx1404_cur)
  rx1404_restart:
.annotate 'line', 4
    if_null rx1404_debug, debug_1015
    rx1404_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1015:
  rx1404_fail:
    (rx1404_rep, rx1404_pos, $I10, $P10) = rx1404_cur."!mark_fail"(0)
    lt rx1404_pos, -1, rx1404_done
    eq rx1404_pos, -1, rx1404_fail
    jump $I10
  rx1404_done:
    rx1404_cur."!cursor_fail"()
    if_null rx1404_debug, debug_1016
    rx1404_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1016:
    .return (rx1404_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("323_1298839231.515") :method
.annotate 'line', 4
    $P1406 = self."!PREFIX__!subrule"("O", "==")
    new $P1407, "ResizablePMCArray"
    push $P1407, $P1406
    .return ($P1407)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("324_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1411_tgt
    .local int rx1411_pos
    .local int rx1411_off
    .local int rx1411_eos
    .local int rx1411_rep
    .local pmc rx1411_cur
    .local pmc rx1411_debug
    (rx1411_cur, rx1411_pos, rx1411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1411_cur
    .local pmc match
    .lex "$/", match
    length rx1411_eos, rx1411_tgt
    gt rx1411_pos, rx1411_eos, rx1411_done
    set rx1411_off, 0
    lt rx1411_pos, 2, rx1411_start
    sub rx1411_off, rx1411_pos, 1
    substr rx1411_tgt, rx1411_tgt, rx1411_off
  rx1411_start:
    eq $I10, 1, rx1411_restart
    if_null rx1411_debug, debug_1017
    rx1411_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1415_done
    goto rxscan1415_scan
  rxscan1415_loop:
    (rx1411_pos) = rx1411_cur."from"()
    inc rx1411_pos
    rx1411_cur."!cursor_from"(rx1411_pos)
    ge rx1411_pos, rx1411_eos, rxscan1415_done
  rxscan1415_scan:
    set_addr $I10, rxscan1415_loop
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  rxscan1415_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1416_fail
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx literal  "!="
    add $I11, rx1411_pos, 2
    gt $I11, rx1411_eos, rx1411_fail
    sub $I11, rx1411_pos, rx1411_off
    substr $S10, rx1411_tgt, $I11, 2
    ne $S10, "!=", rx1411_fail
    add rx1411_pos, 2
    set_addr $I10, rxcap_1416_fail
    ($I12, $I11) = rx1411_cur."!mark_peek"($I10)
    rx1411_cur."!cursor_pos"($I11)
    ($P10) = rx1411_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1411_pos, "")
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1416_done
  rxcap_1416_fail:
    goto rx1411_fail
  rxcap_1416_done:
  # rx subrule "O" subtype=capture negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1411_fail
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1411_pos = $P10."pos"()
  # rx pass
    rx1411_cur."!cursor_pass"(rx1411_pos, "infix:sym<!=>")
    if_null rx1411_debug, debug_1018
    rx1411_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1411_pos)
  debug_1018:
    .return (rx1411_cur)
  rx1411_restart:
.annotate 'line', 4
    if_null rx1411_debug, debug_1019
    rx1411_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1019:
  rx1411_fail:
    (rx1411_rep, rx1411_pos, $I10, $P10) = rx1411_cur."!mark_fail"(0)
    lt rx1411_pos, -1, rx1411_done
    eq rx1411_pos, -1, rx1411_fail
    jump $I10
  rx1411_done:
    rx1411_cur."!cursor_fail"()
    if_null rx1411_debug, debug_1020
    rx1411_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1020:
    .return (rx1411_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("325_1298839231.515") :method
.annotate 'line', 4
    $P1413 = self."!PREFIX__!subrule"("O", "!=")
    new $P1414, "ResizablePMCArray"
    push $P1414, $P1413
    .return ($P1414)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("326_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1418_tgt
    .local int rx1418_pos
    .local int rx1418_off
    .local int rx1418_eos
    .local int rx1418_rep
    .local pmc rx1418_cur
    .local pmc rx1418_debug
    (rx1418_cur, rx1418_pos, rx1418_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1418_cur
    .local pmc match
    .lex "$/", match
    length rx1418_eos, rx1418_tgt
    gt rx1418_pos, rx1418_eos, rx1418_done
    set rx1418_off, 0
    lt rx1418_pos, 2, rx1418_start
    sub rx1418_off, rx1418_pos, 1
    substr rx1418_tgt, rx1418_tgt, rx1418_off
  rx1418_start:
    eq $I10, 1, rx1418_restart
    if_null rx1418_debug, debug_1021
    rx1418_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1422_done
    goto rxscan1422_scan
  rxscan1422_loop:
    (rx1418_pos) = rx1418_cur."from"()
    inc rx1418_pos
    rx1418_cur."!cursor_from"(rx1418_pos)
    ge rx1418_pos, rx1418_eos, rxscan1422_done
  rxscan1422_scan:
    set_addr $I10, rxscan1422_loop
    rx1418_cur."!mark_push"(0, rx1418_pos, $I10)
  rxscan1422_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1423_fail
    rx1418_cur."!mark_push"(0, rx1418_pos, $I10)
  # rx literal  "<="
    add $I11, rx1418_pos, 2
    gt $I11, rx1418_eos, rx1418_fail
    sub $I11, rx1418_pos, rx1418_off
    substr $S10, rx1418_tgt, $I11, 2
    ne $S10, "<=", rx1418_fail
    add rx1418_pos, 2
    set_addr $I10, rxcap_1423_fail
    ($I12, $I11) = rx1418_cur."!mark_peek"($I10)
    rx1418_cur."!cursor_pos"($I11)
    ($P10) = rx1418_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1418_pos, "")
    rx1418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1423_done
  rxcap_1423_fail:
    goto rx1418_fail
  rxcap_1423_done:
  # rx subrule "O" subtype=capture negate=
    rx1418_cur."!cursor_pos"(rx1418_pos)
    $P10 = rx1418_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1418_fail
    rx1418_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1418_pos = $P10."pos"()
  # rx pass
    rx1418_cur."!cursor_pass"(rx1418_pos, "infix:sym<<=>")
    if_null rx1418_debug, debug_1022
    rx1418_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1418_pos)
  debug_1022:
    .return (rx1418_cur)
  rx1418_restart:
.annotate 'line', 4
    if_null rx1418_debug, debug_1023
    rx1418_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1023:
  rx1418_fail:
    (rx1418_rep, rx1418_pos, $I10, $P10) = rx1418_cur."!mark_fail"(0)
    lt rx1418_pos, -1, rx1418_done
    eq rx1418_pos, -1, rx1418_fail
    jump $I10
  rx1418_done:
    rx1418_cur."!cursor_fail"()
    if_null rx1418_debug, debug_1024
    rx1418_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1024:
    .return (rx1418_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("327_1298839231.515") :method
.annotate 'line', 4
    $P1420 = self."!PREFIX__!subrule"("O", "<=")
    new $P1421, "ResizablePMCArray"
    push $P1421, $P1420
    .return ($P1421)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("328_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1425_tgt
    .local int rx1425_pos
    .local int rx1425_off
    .local int rx1425_eos
    .local int rx1425_rep
    .local pmc rx1425_cur
    .local pmc rx1425_debug
    (rx1425_cur, rx1425_pos, rx1425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1425_cur
    .local pmc match
    .lex "$/", match
    length rx1425_eos, rx1425_tgt
    gt rx1425_pos, rx1425_eos, rx1425_done
    set rx1425_off, 0
    lt rx1425_pos, 2, rx1425_start
    sub rx1425_off, rx1425_pos, 1
    substr rx1425_tgt, rx1425_tgt, rx1425_off
  rx1425_start:
    eq $I10, 1, rx1425_restart
    if_null rx1425_debug, debug_1025
    rx1425_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1429_done
    goto rxscan1429_scan
  rxscan1429_loop:
    (rx1425_pos) = rx1425_cur."from"()
    inc rx1425_pos
    rx1425_cur."!cursor_from"(rx1425_pos)
    ge rx1425_pos, rx1425_eos, rxscan1429_done
  rxscan1429_scan:
    set_addr $I10, rxscan1429_loop
    rx1425_cur."!mark_push"(0, rx1425_pos, $I10)
  rxscan1429_done:
.annotate 'line', 617
  # rx subcapture "sym"
    set_addr $I10, rxcap_1430_fail
    rx1425_cur."!mark_push"(0, rx1425_pos, $I10)
  # rx literal  ">="
    add $I11, rx1425_pos, 2
    gt $I11, rx1425_eos, rx1425_fail
    sub $I11, rx1425_pos, rx1425_off
    substr $S10, rx1425_tgt, $I11, 2
    ne $S10, ">=", rx1425_fail
    add rx1425_pos, 2
    set_addr $I10, rxcap_1430_fail
    ($I12, $I11) = rx1425_cur."!mark_peek"($I10)
    rx1425_cur."!cursor_pos"($I11)
    ($P10) = rx1425_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1425_pos, "")
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1430_done
  rxcap_1430_fail:
    goto rx1425_fail
  rxcap_1430_done:
  # rx subrule "O" subtype=capture negate=
    rx1425_cur."!cursor_pos"(rx1425_pos)
    $P10 = rx1425_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1425_fail
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1425_pos = $P10."pos"()
  # rx pass
    rx1425_cur."!cursor_pass"(rx1425_pos, "infix:sym<>=>")
    if_null rx1425_debug, debug_1026
    rx1425_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1425_pos)
  debug_1026:
    .return (rx1425_cur)
  rx1425_restart:
.annotate 'line', 4
    if_null rx1425_debug, debug_1027
    rx1425_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1027:
  rx1425_fail:
    (rx1425_rep, rx1425_pos, $I10, $P10) = rx1425_cur."!mark_fail"(0)
    lt rx1425_pos, -1, rx1425_done
    eq rx1425_pos, -1, rx1425_fail
    jump $I10
  rx1425_done:
    rx1425_cur."!cursor_fail"()
    if_null rx1425_debug, debug_1028
    rx1425_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1028:
    .return (rx1425_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("329_1298839231.515") :method
.annotate 'line', 4
    $P1427 = self."!PREFIX__!subrule"("O", ">=")
    new $P1428, "ResizablePMCArray"
    push $P1428, $P1427
    .return ($P1428)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("330_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1432_tgt
    .local int rx1432_pos
    .local int rx1432_off
    .local int rx1432_eos
    .local int rx1432_rep
    .local pmc rx1432_cur
    .local pmc rx1432_debug
    (rx1432_cur, rx1432_pos, rx1432_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1432_cur
    .local pmc match
    .lex "$/", match
    length rx1432_eos, rx1432_tgt
    gt rx1432_pos, rx1432_eos, rx1432_done
    set rx1432_off, 0
    lt rx1432_pos, 2, rx1432_start
    sub rx1432_off, rx1432_pos, 1
    substr rx1432_tgt, rx1432_tgt, rx1432_off
  rx1432_start:
    eq $I10, 1, rx1432_restart
    if_null rx1432_debug, debug_1029
    rx1432_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    (rx1432_pos) = rx1432_cur."from"()
    inc rx1432_pos
    rx1432_cur."!cursor_from"(rx1432_pos)
    ge rx1432_pos, rx1432_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  rxscan1436_done:
.annotate 'line', 618
  # rx subcapture "sym"
    set_addr $I10, rxcap_1437_fail
    rx1432_cur."!mark_push"(0, rx1432_pos, $I10)
  # rx literal  "<"
    add $I11, rx1432_pos, 1
    gt $I11, rx1432_eos, rx1432_fail
    sub $I11, rx1432_pos, rx1432_off
    ord $I11, rx1432_tgt, $I11
    ne $I11, 60, rx1432_fail
    add rx1432_pos, 1
    set_addr $I10, rxcap_1437_fail
    ($I12, $I11) = rx1432_cur."!mark_peek"($I10)
    rx1432_cur."!cursor_pos"($I11)
    ($P10) = rx1432_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1432_pos, "")
    rx1432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1437_done
  rxcap_1437_fail:
    goto rx1432_fail
  rxcap_1437_done:
  # rx subrule "O" subtype=capture negate=
    rx1432_cur."!cursor_pos"(rx1432_pos)
    $P10 = rx1432_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1432_fail
    rx1432_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1432_pos = $P10."pos"()
  # rx pass
    rx1432_cur."!cursor_pass"(rx1432_pos, "infix:sym<<>")
    if_null rx1432_debug, debug_1030
    rx1432_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1432_pos)
  debug_1030:
    .return (rx1432_cur)
  rx1432_restart:
.annotate 'line', 4
    if_null rx1432_debug, debug_1031
    rx1432_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1031:
  rx1432_fail:
    (rx1432_rep, rx1432_pos, $I10, $P10) = rx1432_cur."!mark_fail"(0)
    lt rx1432_pos, -1, rx1432_done
    eq rx1432_pos, -1, rx1432_fail
    jump $I10
  rx1432_done:
    rx1432_cur."!cursor_fail"()
    if_null rx1432_debug, debug_1032
    rx1432_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1032:
    .return (rx1432_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("331_1298839231.515") :method
.annotate 'line', 4
    $P1434 = self."!PREFIX__!subrule"("O", "<")
    new $P1435, "ResizablePMCArray"
    push $P1435, $P1434
    .return ($P1435)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("332_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1439_tgt
    .local int rx1439_pos
    .local int rx1439_off
    .local int rx1439_eos
    .local int rx1439_rep
    .local pmc rx1439_cur
    .local pmc rx1439_debug
    (rx1439_cur, rx1439_pos, rx1439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1439_cur
    .local pmc match
    .lex "$/", match
    length rx1439_eos, rx1439_tgt
    gt rx1439_pos, rx1439_eos, rx1439_done
    set rx1439_off, 0
    lt rx1439_pos, 2, rx1439_start
    sub rx1439_off, rx1439_pos, 1
    substr rx1439_tgt, rx1439_tgt, rx1439_off
  rx1439_start:
    eq $I10, 1, rx1439_restart
    if_null rx1439_debug, debug_1033
    rx1439_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1443_done
    goto rxscan1443_scan
  rxscan1443_loop:
    (rx1439_pos) = rx1439_cur."from"()
    inc rx1439_pos
    rx1439_cur."!cursor_from"(rx1439_pos)
    ge rx1439_pos, rx1439_eos, rxscan1443_done
  rxscan1443_scan:
    set_addr $I10, rxscan1443_loop
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  rxscan1443_done:
.annotate 'line', 619
  # rx subcapture "sym"
    set_addr $I10, rxcap_1444_fail
    rx1439_cur."!mark_push"(0, rx1439_pos, $I10)
  # rx literal  ">"
    add $I11, rx1439_pos, 1
    gt $I11, rx1439_eos, rx1439_fail
    sub $I11, rx1439_pos, rx1439_off
    ord $I11, rx1439_tgt, $I11
    ne $I11, 62, rx1439_fail
    add rx1439_pos, 1
    set_addr $I10, rxcap_1444_fail
    ($I12, $I11) = rx1439_cur."!mark_peek"($I10)
    rx1439_cur."!cursor_pos"($I11)
    ($P10) = rx1439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1439_pos, "")
    rx1439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1444_done
  rxcap_1444_fail:
    goto rx1439_fail
  rxcap_1444_done:
  # rx subrule "O" subtype=capture negate=
    rx1439_cur."!cursor_pos"(rx1439_pos)
    $P10 = rx1439_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1439_fail
    rx1439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1439_pos = $P10."pos"()
  # rx pass
    rx1439_cur."!cursor_pass"(rx1439_pos, "infix:sym<>>")
    if_null rx1439_debug, debug_1034
    rx1439_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1439_pos)
  debug_1034:
    .return (rx1439_cur)
  rx1439_restart:
.annotate 'line', 4
    if_null rx1439_debug, debug_1035
    rx1439_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1035:
  rx1439_fail:
    (rx1439_rep, rx1439_pos, $I10, $P10) = rx1439_cur."!mark_fail"(0)
    lt rx1439_pos, -1, rx1439_done
    eq rx1439_pos, -1, rx1439_fail
    jump $I10
  rx1439_done:
    rx1439_cur."!cursor_fail"()
    if_null rx1439_debug, debug_1036
    rx1439_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1036:
    .return (rx1439_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("333_1298839231.515") :method
.annotate 'line', 4
    $P1441 = self."!PREFIX__!subrule"("O", ">")
    new $P1442, "ResizablePMCArray"
    push $P1442, $P1441
    .return ($P1442)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("334_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1446_tgt
    .local int rx1446_pos
    .local int rx1446_off
    .local int rx1446_eos
    .local int rx1446_rep
    .local pmc rx1446_cur
    .local pmc rx1446_debug
    (rx1446_cur, rx1446_pos, rx1446_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1446_cur
    .local pmc match
    .lex "$/", match
    length rx1446_eos, rx1446_tgt
    gt rx1446_pos, rx1446_eos, rx1446_done
    set rx1446_off, 0
    lt rx1446_pos, 2, rx1446_start
    sub rx1446_off, rx1446_pos, 1
    substr rx1446_tgt, rx1446_tgt, rx1446_off
  rx1446_start:
    eq $I10, 1, rx1446_restart
    if_null rx1446_debug, debug_1037
    rx1446_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    (rx1446_pos) = rx1446_cur."from"()
    inc rx1446_pos
    rx1446_cur."!cursor_from"(rx1446_pos)
    ge rx1446_pos, rx1446_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  rxscan1450_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1451_fail
    rx1446_cur."!mark_push"(0, rx1446_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1446_pos, 2
    gt $I11, rx1446_eos, rx1446_fail
    sub $I11, rx1446_pos, rx1446_off
    substr $S10, rx1446_tgt, $I11, 2
    ne $S10, "eq", rx1446_fail
    add rx1446_pos, 2
    set_addr $I10, rxcap_1451_fail
    ($I12, $I11) = rx1446_cur."!mark_peek"($I10)
    rx1446_cur."!cursor_pos"($I11)
    ($P10) = rx1446_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1446_pos, "")
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1451_done
  rxcap_1451_fail:
    goto rx1446_fail
  rxcap_1451_done:
  # rx subrule "O" subtype=capture negate=
    rx1446_cur."!cursor_pos"(rx1446_pos)
    $P10 = rx1446_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1446_fail
    rx1446_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1446_pos = $P10."pos"()
  # rx pass
    rx1446_cur."!cursor_pass"(rx1446_pos, "infix:sym<eq>")
    if_null rx1446_debug, debug_1038
    rx1446_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1446_pos)
  debug_1038:
    .return (rx1446_cur)
  rx1446_restart:
.annotate 'line', 4
    if_null rx1446_debug, debug_1039
    rx1446_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1039:
  rx1446_fail:
    (rx1446_rep, rx1446_pos, $I10, $P10) = rx1446_cur."!mark_fail"(0)
    lt rx1446_pos, -1, rx1446_done
    eq rx1446_pos, -1, rx1446_fail
    jump $I10
  rx1446_done:
    rx1446_cur."!cursor_fail"()
    if_null rx1446_debug, debug_1040
    rx1446_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1040:
    .return (rx1446_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("335_1298839231.515") :method
.annotate 'line', 4
    $P1448 = self."!PREFIX__!subrule"("O", "eq")
    new $P1449, "ResizablePMCArray"
    push $P1449, $P1448
    .return ($P1449)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("336_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1453_tgt
    .local int rx1453_pos
    .local int rx1453_off
    .local int rx1453_eos
    .local int rx1453_rep
    .local pmc rx1453_cur
    .local pmc rx1453_debug
    (rx1453_cur, rx1453_pos, rx1453_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1453_cur
    .local pmc match
    .lex "$/", match
    length rx1453_eos, rx1453_tgt
    gt rx1453_pos, rx1453_eos, rx1453_done
    set rx1453_off, 0
    lt rx1453_pos, 2, rx1453_start
    sub rx1453_off, rx1453_pos, 1
    substr rx1453_tgt, rx1453_tgt, rx1453_off
  rx1453_start:
    eq $I10, 1, rx1453_restart
    if_null rx1453_debug, debug_1041
    rx1453_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1457_done
    goto rxscan1457_scan
  rxscan1457_loop:
    (rx1453_pos) = rx1453_cur."from"()
    inc rx1453_pos
    rx1453_cur."!cursor_from"(rx1453_pos)
    ge rx1453_pos, rx1453_eos, rxscan1457_done
  rxscan1457_scan:
    set_addr $I10, rxscan1457_loop
    rx1453_cur."!mark_push"(0, rx1453_pos, $I10)
  rxscan1457_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1458_fail
    rx1453_cur."!mark_push"(0, rx1453_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1453_pos, 2
    gt $I11, rx1453_eos, rx1453_fail
    sub $I11, rx1453_pos, rx1453_off
    substr $S10, rx1453_tgt, $I11, 2
    ne $S10, "ne", rx1453_fail
    add rx1453_pos, 2
    set_addr $I10, rxcap_1458_fail
    ($I12, $I11) = rx1453_cur."!mark_peek"($I10)
    rx1453_cur."!cursor_pos"($I11)
    ($P10) = rx1453_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1453_pos, "")
    rx1453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1458_done
  rxcap_1458_fail:
    goto rx1453_fail
  rxcap_1458_done:
  # rx subrule "O" subtype=capture negate=
    rx1453_cur."!cursor_pos"(rx1453_pos)
    $P10 = rx1453_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1453_fail
    rx1453_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1453_pos = $P10."pos"()
  # rx pass
    rx1453_cur."!cursor_pass"(rx1453_pos, "infix:sym<ne>")
    if_null rx1453_debug, debug_1042
    rx1453_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1453_pos)
  debug_1042:
    .return (rx1453_cur)
  rx1453_restart:
.annotate 'line', 4
    if_null rx1453_debug, debug_1043
    rx1453_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1043:
  rx1453_fail:
    (rx1453_rep, rx1453_pos, $I10, $P10) = rx1453_cur."!mark_fail"(0)
    lt rx1453_pos, -1, rx1453_done
    eq rx1453_pos, -1, rx1453_fail
    jump $I10
  rx1453_done:
    rx1453_cur."!cursor_fail"()
    if_null rx1453_debug, debug_1044
    rx1453_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1044:
    .return (rx1453_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("337_1298839231.515") :method
.annotate 'line', 4
    $P1455 = self."!PREFIX__!subrule"("O", "ne")
    new $P1456, "ResizablePMCArray"
    push $P1456, $P1455
    .return ($P1456)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("338_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1460_tgt
    .local int rx1460_pos
    .local int rx1460_off
    .local int rx1460_eos
    .local int rx1460_rep
    .local pmc rx1460_cur
    .local pmc rx1460_debug
    (rx1460_cur, rx1460_pos, rx1460_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1460_cur
    .local pmc match
    .lex "$/", match
    length rx1460_eos, rx1460_tgt
    gt rx1460_pos, rx1460_eos, rx1460_done
    set rx1460_off, 0
    lt rx1460_pos, 2, rx1460_start
    sub rx1460_off, rx1460_pos, 1
    substr rx1460_tgt, rx1460_tgt, rx1460_off
  rx1460_start:
    eq $I10, 1, rx1460_restart
    if_null rx1460_debug, debug_1045
    rx1460_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1464_done
    goto rxscan1464_scan
  rxscan1464_loop:
    (rx1460_pos) = rx1460_cur."from"()
    inc rx1460_pos
    rx1460_cur."!cursor_from"(rx1460_pos)
    ge rx1460_pos, rx1460_eos, rxscan1464_done
  rxscan1464_scan:
    set_addr $I10, rxscan1464_loop
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  rxscan1464_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1465_fail
    rx1460_cur."!mark_push"(0, rx1460_pos, $I10)
  # rx literal  "le"
    add $I11, rx1460_pos, 2
    gt $I11, rx1460_eos, rx1460_fail
    sub $I11, rx1460_pos, rx1460_off
    substr $S10, rx1460_tgt, $I11, 2
    ne $S10, "le", rx1460_fail
    add rx1460_pos, 2
    set_addr $I10, rxcap_1465_fail
    ($I12, $I11) = rx1460_cur."!mark_peek"($I10)
    rx1460_cur."!cursor_pos"($I11)
    ($P10) = rx1460_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1460_pos, "")
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1465_done
  rxcap_1465_fail:
    goto rx1460_fail
  rxcap_1465_done:
  # rx subrule "O" subtype=capture negate=
    rx1460_cur."!cursor_pos"(rx1460_pos)
    $P10 = rx1460_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1460_fail
    rx1460_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1460_pos = $P10."pos"()
  # rx pass
    rx1460_cur."!cursor_pass"(rx1460_pos, "infix:sym<le>")
    if_null rx1460_debug, debug_1046
    rx1460_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1460_pos)
  debug_1046:
    .return (rx1460_cur)
  rx1460_restart:
.annotate 'line', 4
    if_null rx1460_debug, debug_1047
    rx1460_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1047:
  rx1460_fail:
    (rx1460_rep, rx1460_pos, $I10, $P10) = rx1460_cur."!mark_fail"(0)
    lt rx1460_pos, -1, rx1460_done
    eq rx1460_pos, -1, rx1460_fail
    jump $I10
  rx1460_done:
    rx1460_cur."!cursor_fail"()
    if_null rx1460_debug, debug_1048
    rx1460_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1048:
    .return (rx1460_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("339_1298839231.515") :method
.annotate 'line', 4
    $P1462 = self."!PREFIX__!subrule"("O", "le")
    new $P1463, "ResizablePMCArray"
    push $P1463, $P1462
    .return ($P1463)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("340_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1467_tgt
    .local int rx1467_pos
    .local int rx1467_off
    .local int rx1467_eos
    .local int rx1467_rep
    .local pmc rx1467_cur
    .local pmc rx1467_debug
    (rx1467_cur, rx1467_pos, rx1467_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1467_cur
    .local pmc match
    .lex "$/", match
    length rx1467_eos, rx1467_tgt
    gt rx1467_pos, rx1467_eos, rx1467_done
    set rx1467_off, 0
    lt rx1467_pos, 2, rx1467_start
    sub rx1467_off, rx1467_pos, 1
    substr rx1467_tgt, rx1467_tgt, rx1467_off
  rx1467_start:
    eq $I10, 1, rx1467_restart
    if_null rx1467_debug, debug_1049
    rx1467_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1471_done
    goto rxscan1471_scan
  rxscan1471_loop:
    (rx1467_pos) = rx1467_cur."from"()
    inc rx1467_pos
    rx1467_cur."!cursor_from"(rx1467_pos)
    ge rx1467_pos, rx1467_eos, rxscan1471_done
  rxscan1471_scan:
    set_addr $I10, rxscan1471_loop
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  rxscan1471_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1472_fail
    rx1467_cur."!mark_push"(0, rx1467_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1467_pos, 2
    gt $I11, rx1467_eos, rx1467_fail
    sub $I11, rx1467_pos, rx1467_off
    substr $S10, rx1467_tgt, $I11, 2
    ne $S10, "ge", rx1467_fail
    add rx1467_pos, 2
    set_addr $I10, rxcap_1472_fail
    ($I12, $I11) = rx1467_cur."!mark_peek"($I10)
    rx1467_cur."!cursor_pos"($I11)
    ($P10) = rx1467_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1467_pos, "")
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1472_done
  rxcap_1472_fail:
    goto rx1467_fail
  rxcap_1472_done:
  # rx subrule "O" subtype=capture negate=
    rx1467_cur."!cursor_pos"(rx1467_pos)
    $P10 = rx1467_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1467_fail
    rx1467_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1467_pos = $P10."pos"()
  # rx pass
    rx1467_cur."!cursor_pass"(rx1467_pos, "infix:sym<ge>")
    if_null rx1467_debug, debug_1050
    rx1467_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1467_pos)
  debug_1050:
    .return (rx1467_cur)
  rx1467_restart:
.annotate 'line', 4
    if_null rx1467_debug, debug_1051
    rx1467_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1051:
  rx1467_fail:
    (rx1467_rep, rx1467_pos, $I10, $P10) = rx1467_cur."!mark_fail"(0)
    lt rx1467_pos, -1, rx1467_done
    eq rx1467_pos, -1, rx1467_fail
    jump $I10
  rx1467_done:
    rx1467_cur."!cursor_fail"()
    if_null rx1467_debug, debug_1052
    rx1467_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1052:
    .return (rx1467_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("341_1298839231.515") :method
.annotate 'line', 4
    $P1469 = self."!PREFIX__!subrule"("O", "ge")
    new $P1470, "ResizablePMCArray"
    push $P1470, $P1469
    .return ($P1470)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("342_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1474_tgt
    .local int rx1474_pos
    .local int rx1474_off
    .local int rx1474_eos
    .local int rx1474_rep
    .local pmc rx1474_cur
    .local pmc rx1474_debug
    (rx1474_cur, rx1474_pos, rx1474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1474_cur
    .local pmc match
    .lex "$/", match
    length rx1474_eos, rx1474_tgt
    gt rx1474_pos, rx1474_eos, rx1474_done
    set rx1474_off, 0
    lt rx1474_pos, 2, rx1474_start
    sub rx1474_off, rx1474_pos, 1
    substr rx1474_tgt, rx1474_tgt, rx1474_off
  rx1474_start:
    eq $I10, 1, rx1474_restart
    if_null rx1474_debug, debug_1053
    rx1474_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1478_done
    goto rxscan1478_scan
  rxscan1478_loop:
    (rx1474_pos) = rx1474_cur."from"()
    inc rx1474_pos
    rx1474_cur."!cursor_from"(rx1474_pos)
    ge rx1474_pos, rx1474_eos, rxscan1478_done
  rxscan1478_scan:
    set_addr $I10, rxscan1478_loop
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  rxscan1478_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1479_fail
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1474_pos, 2
    gt $I11, rx1474_eos, rx1474_fail
    sub $I11, rx1474_pos, rx1474_off
    substr $S10, rx1474_tgt, $I11, 2
    ne $S10, "lt", rx1474_fail
    add rx1474_pos, 2
    set_addr $I10, rxcap_1479_fail
    ($I12, $I11) = rx1474_cur."!mark_peek"($I10)
    rx1474_cur."!cursor_pos"($I11)
    ($P10) = rx1474_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1474_pos, "")
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1479_done
  rxcap_1479_fail:
    goto rx1474_fail
  rxcap_1479_done:
  # rx subrule "O" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1474_pos = $P10."pos"()
  # rx pass
    rx1474_cur."!cursor_pass"(rx1474_pos, "infix:sym<lt>")
    if_null rx1474_debug, debug_1054
    rx1474_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1474_pos)
  debug_1054:
    .return (rx1474_cur)
  rx1474_restart:
.annotate 'line', 4
    if_null rx1474_debug, debug_1055
    rx1474_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1055:
  rx1474_fail:
    (rx1474_rep, rx1474_pos, $I10, $P10) = rx1474_cur."!mark_fail"(0)
    lt rx1474_pos, -1, rx1474_done
    eq rx1474_pos, -1, rx1474_fail
    jump $I10
  rx1474_done:
    rx1474_cur."!cursor_fail"()
    if_null rx1474_debug, debug_1056
    rx1474_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1056:
    .return (rx1474_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("343_1298839231.515") :method
.annotate 'line', 4
    $P1476 = self."!PREFIX__!subrule"("O", "lt")
    new $P1477, "ResizablePMCArray"
    push $P1477, $P1476
    .return ($P1477)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("344_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1481_tgt
    .local int rx1481_pos
    .local int rx1481_off
    .local int rx1481_eos
    .local int rx1481_rep
    .local pmc rx1481_cur
    .local pmc rx1481_debug
    (rx1481_cur, rx1481_pos, rx1481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1481_cur
    .local pmc match
    .lex "$/", match
    length rx1481_eos, rx1481_tgt
    gt rx1481_pos, rx1481_eos, rx1481_done
    set rx1481_off, 0
    lt rx1481_pos, 2, rx1481_start
    sub rx1481_off, rx1481_pos, 1
    substr rx1481_tgt, rx1481_tgt, rx1481_off
  rx1481_start:
    eq $I10, 1, rx1481_restart
    if_null rx1481_debug, debug_1057
    rx1481_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1485_done
    goto rxscan1485_scan
  rxscan1485_loop:
    (rx1481_pos) = rx1481_cur."from"()
    inc rx1481_pos
    rx1481_cur."!cursor_from"(rx1481_pos)
    ge rx1481_pos, rx1481_eos, rxscan1485_done
  rxscan1485_scan:
    set_addr $I10, rxscan1485_loop
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  rxscan1485_done:
.annotate 'line', 625
  # rx subcapture "sym"
    set_addr $I10, rxcap_1486_fail
    rx1481_cur."!mark_push"(0, rx1481_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1481_pos, 2
    gt $I11, rx1481_eos, rx1481_fail
    sub $I11, rx1481_pos, rx1481_off
    substr $S10, rx1481_tgt, $I11, 2
    ne $S10, "gt", rx1481_fail
    add rx1481_pos, 2
    set_addr $I10, rxcap_1486_fail
    ($I12, $I11) = rx1481_cur."!mark_peek"($I10)
    rx1481_cur."!cursor_pos"($I11)
    ($P10) = rx1481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1481_pos, "")
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1486_done
  rxcap_1486_fail:
    goto rx1481_fail
  rxcap_1486_done:
  # rx subrule "O" subtype=capture negate=
    rx1481_cur."!cursor_pos"(rx1481_pos)
    $P10 = rx1481_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1481_fail
    rx1481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1481_pos = $P10."pos"()
  # rx pass
    rx1481_cur."!cursor_pass"(rx1481_pos, "infix:sym<gt>")
    if_null rx1481_debug, debug_1058
    rx1481_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1481_pos)
  debug_1058:
    .return (rx1481_cur)
  rx1481_restart:
.annotate 'line', 4
    if_null rx1481_debug, debug_1059
    rx1481_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1059:
  rx1481_fail:
    (rx1481_rep, rx1481_pos, $I10, $P10) = rx1481_cur."!mark_fail"(0)
    lt rx1481_pos, -1, rx1481_done
    eq rx1481_pos, -1, rx1481_fail
    jump $I10
  rx1481_done:
    rx1481_cur."!cursor_fail"()
    if_null rx1481_debug, debug_1060
    rx1481_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1060:
    .return (rx1481_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("345_1298839231.515") :method
.annotate 'line', 4
    $P1483 = self."!PREFIX__!subrule"("O", "gt")
    new $P1484, "ResizablePMCArray"
    push $P1484, $P1483
    .return ($P1484)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("346_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1488_tgt
    .local int rx1488_pos
    .local int rx1488_off
    .local int rx1488_eos
    .local int rx1488_rep
    .local pmc rx1488_cur
    .local pmc rx1488_debug
    (rx1488_cur, rx1488_pos, rx1488_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1488_cur
    .local pmc match
    .lex "$/", match
    length rx1488_eos, rx1488_tgt
    gt rx1488_pos, rx1488_eos, rx1488_done
    set rx1488_off, 0
    lt rx1488_pos, 2, rx1488_start
    sub rx1488_off, rx1488_pos, 1
    substr rx1488_tgt, rx1488_tgt, rx1488_off
  rx1488_start:
    eq $I10, 1, rx1488_restart
    if_null rx1488_debug, debug_1061
    rx1488_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1492_done
    goto rxscan1492_scan
  rxscan1492_loop:
    (rx1488_pos) = rx1488_cur."from"()
    inc rx1488_pos
    rx1488_cur."!cursor_from"(rx1488_pos)
    ge rx1488_pos, rx1488_eos, rxscan1492_done
  rxscan1492_scan:
    set_addr $I10, rxscan1492_loop
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  rxscan1492_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1493_fail
    rx1488_cur."!mark_push"(0, rx1488_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1488_pos, 3
    gt $I11, rx1488_eos, rx1488_fail
    sub $I11, rx1488_pos, rx1488_off
    substr $S10, rx1488_tgt, $I11, 3
    ne $S10, "=:=", rx1488_fail
    add rx1488_pos, 3
    set_addr $I10, rxcap_1493_fail
    ($I12, $I11) = rx1488_cur."!mark_peek"($I10)
    rx1488_cur."!cursor_pos"($I11)
    ($P10) = rx1488_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1488_pos, "")
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1493_done
  rxcap_1493_fail:
    goto rx1488_fail
  rxcap_1493_done:
  # rx subrule "O" subtype=capture negate=
    rx1488_cur."!cursor_pos"(rx1488_pos)
    $P10 = rx1488_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1488_fail
    rx1488_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1488_pos = $P10."pos"()
  # rx pass
    rx1488_cur."!cursor_pass"(rx1488_pos, "infix:sym<=:=>")
    if_null rx1488_debug, debug_1062
    rx1488_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1488_pos)
  debug_1062:
    .return (rx1488_cur)
  rx1488_restart:
.annotate 'line', 4
    if_null rx1488_debug, debug_1063
    rx1488_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1063:
  rx1488_fail:
    (rx1488_rep, rx1488_pos, $I10, $P10) = rx1488_cur."!mark_fail"(0)
    lt rx1488_pos, -1, rx1488_done
    eq rx1488_pos, -1, rx1488_fail
    jump $I10
  rx1488_done:
    rx1488_cur."!cursor_fail"()
    if_null rx1488_debug, debug_1064
    rx1488_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1064:
    .return (rx1488_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("347_1298839231.515") :method
.annotate 'line', 4
    $P1490 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1491, "ResizablePMCArray"
    push $P1491, $P1490
    .return ($P1491)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("348_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1495_tgt
    .local int rx1495_pos
    .local int rx1495_off
    .local int rx1495_eos
    .local int rx1495_rep
    .local pmc rx1495_cur
    .local pmc rx1495_debug
    (rx1495_cur, rx1495_pos, rx1495_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1495_cur
    .local pmc match
    .lex "$/", match
    length rx1495_eos, rx1495_tgt
    gt rx1495_pos, rx1495_eos, rx1495_done
    set rx1495_off, 0
    lt rx1495_pos, 2, rx1495_start
    sub rx1495_off, rx1495_pos, 1
    substr rx1495_tgt, rx1495_tgt, rx1495_off
  rx1495_start:
    eq $I10, 1, rx1495_restart
    if_null rx1495_debug, debug_1065
    rx1495_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1499_done
    goto rxscan1499_scan
  rxscan1499_loop:
    (rx1495_pos) = rx1495_cur."from"()
    inc rx1495_pos
    rx1495_cur."!cursor_from"(rx1495_pos)
    ge rx1495_pos, rx1495_eos, rxscan1499_done
  rxscan1499_scan:
    set_addr $I10, rxscan1499_loop
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  rxscan1499_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1500_fail
    rx1495_cur."!mark_push"(0, rx1495_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1495_pos, 2
    gt $I11, rx1495_eos, rx1495_fail
    sub $I11, rx1495_pos, rx1495_off
    substr $S10, rx1495_tgt, $I11, 2
    ne $S10, "~~", rx1495_fail
    add rx1495_pos, 2
    set_addr $I10, rxcap_1500_fail
    ($I12, $I11) = rx1495_cur."!mark_peek"($I10)
    rx1495_cur."!cursor_pos"($I11)
    ($P10) = rx1495_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1495_pos, "")
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1500_done
  rxcap_1500_fail:
    goto rx1495_fail
  rxcap_1500_done:
  # rx subrule "O" subtype=capture negate=
    rx1495_cur."!cursor_pos"(rx1495_pos)
    $P10 = rx1495_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1495_fail
    rx1495_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1495_pos = $P10."pos"()
  # rx pass
    rx1495_cur."!cursor_pass"(rx1495_pos, "infix:sym<~~>")
    if_null rx1495_debug, debug_1066
    rx1495_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1495_pos)
  debug_1066:
    .return (rx1495_cur)
  rx1495_restart:
.annotate 'line', 4
    if_null rx1495_debug, debug_1067
    rx1495_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1067:
  rx1495_fail:
    (rx1495_rep, rx1495_pos, $I10, $P10) = rx1495_cur."!mark_fail"(0)
    lt rx1495_pos, -1, rx1495_done
    eq rx1495_pos, -1, rx1495_fail
    jump $I10
  rx1495_done:
    rx1495_cur."!cursor_fail"()
    if_null rx1495_debug, debug_1068
    rx1495_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1068:
    .return (rx1495_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("349_1298839231.515") :method
.annotate 'line', 4
    $P1497 = self."!PREFIX__!subrule"("O", "~~")
    new $P1498, "ResizablePMCArray"
    push $P1498, $P1497
    .return ($P1498)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("350_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1502_tgt
    .local int rx1502_pos
    .local int rx1502_off
    .local int rx1502_eos
    .local int rx1502_rep
    .local pmc rx1502_cur
    .local pmc rx1502_debug
    (rx1502_cur, rx1502_pos, rx1502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1502_cur
    .local pmc match
    .lex "$/", match
    length rx1502_eos, rx1502_tgt
    gt rx1502_pos, rx1502_eos, rx1502_done
    set rx1502_off, 0
    lt rx1502_pos, 2, rx1502_start
    sub rx1502_off, rx1502_pos, 1
    substr rx1502_tgt, rx1502_tgt, rx1502_off
  rx1502_start:
    eq $I10, 1, rx1502_restart
    if_null rx1502_debug, debug_1069
    rx1502_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1506_done
    goto rxscan1506_scan
  rxscan1506_loop:
    (rx1502_pos) = rx1502_cur."from"()
    inc rx1502_pos
    rx1502_cur."!cursor_from"(rx1502_pos)
    ge rx1502_pos, rx1502_eos, rxscan1506_done
  rxscan1506_scan:
    set_addr $I10, rxscan1506_loop
    rx1502_cur."!mark_push"(0, rx1502_pos, $I10)
  rxscan1506_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1507_fail
    rx1502_cur."!mark_push"(0, rx1502_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1502_pos, 2
    gt $I11, rx1502_eos, rx1502_fail
    sub $I11, rx1502_pos, rx1502_off
    substr $S10, rx1502_tgt, $I11, 2
    ne $S10, "&&", rx1502_fail
    add rx1502_pos, 2
    set_addr $I10, rxcap_1507_fail
    ($I12, $I11) = rx1502_cur."!mark_peek"($I10)
    rx1502_cur."!cursor_pos"($I11)
    ($P10) = rx1502_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1502_pos, "")
    rx1502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1507_done
  rxcap_1507_fail:
    goto rx1502_fail
  rxcap_1507_done:
  # rx subrule "O" subtype=capture negate=
    rx1502_cur."!cursor_pos"(rx1502_pos)
    $P10 = rx1502_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1502_fail
    rx1502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1502_pos = $P10."pos"()
  # rx pass
    rx1502_cur."!cursor_pass"(rx1502_pos, "infix:sym<&&>")
    if_null rx1502_debug, debug_1070
    rx1502_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1502_pos)
  debug_1070:
    .return (rx1502_cur)
  rx1502_restart:
.annotate 'line', 4
    if_null rx1502_debug, debug_1071
    rx1502_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1071:
  rx1502_fail:
    (rx1502_rep, rx1502_pos, $I10, $P10) = rx1502_cur."!mark_fail"(0)
    lt rx1502_pos, -1, rx1502_done
    eq rx1502_pos, -1, rx1502_fail
    jump $I10
  rx1502_done:
    rx1502_cur."!cursor_fail"()
    if_null rx1502_debug, debug_1072
    rx1502_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1072:
    .return (rx1502_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("351_1298839231.515") :method
.annotate 'line', 4
    $P1504 = self."!PREFIX__!subrule"("O", "&&")
    new $P1505, "ResizablePMCArray"
    push $P1505, $P1504
    .return ($P1505)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("352_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1509_tgt
    .local int rx1509_pos
    .local int rx1509_off
    .local int rx1509_eos
    .local int rx1509_rep
    .local pmc rx1509_cur
    .local pmc rx1509_debug
    (rx1509_cur, rx1509_pos, rx1509_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1509_cur
    .local pmc match
    .lex "$/", match
    length rx1509_eos, rx1509_tgt
    gt rx1509_pos, rx1509_eos, rx1509_done
    set rx1509_off, 0
    lt rx1509_pos, 2, rx1509_start
    sub rx1509_off, rx1509_pos, 1
    substr rx1509_tgt, rx1509_tgt, rx1509_off
  rx1509_start:
    eq $I10, 1, rx1509_restart
    if_null rx1509_debug, debug_1073
    rx1509_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1513_done
    goto rxscan1513_scan
  rxscan1513_loop:
    (rx1509_pos) = rx1509_cur."from"()
    inc rx1509_pos
    rx1509_cur."!cursor_from"(rx1509_pos)
    ge rx1509_pos, rx1509_eos, rxscan1513_done
  rxscan1513_scan:
    set_addr $I10, rxscan1513_loop
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  rxscan1513_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1514_fail
    rx1509_cur."!mark_push"(0, rx1509_pos, $I10)
  # rx literal  "||"
    add $I11, rx1509_pos, 2
    gt $I11, rx1509_eos, rx1509_fail
    sub $I11, rx1509_pos, rx1509_off
    substr $S10, rx1509_tgt, $I11, 2
    ne $S10, "||", rx1509_fail
    add rx1509_pos, 2
    set_addr $I10, rxcap_1514_fail
    ($I12, $I11) = rx1509_cur."!mark_peek"($I10)
    rx1509_cur."!cursor_pos"($I11)
    ($P10) = rx1509_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1509_pos, "")
    rx1509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1514_done
  rxcap_1514_fail:
    goto rx1509_fail
  rxcap_1514_done:
  # rx subrule "O" subtype=capture negate=
    rx1509_cur."!cursor_pos"(rx1509_pos)
    $P10 = rx1509_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1509_fail
    rx1509_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1509_pos = $P10."pos"()
  # rx pass
    rx1509_cur."!cursor_pass"(rx1509_pos, "infix:sym<||>")
    if_null rx1509_debug, debug_1074
    rx1509_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1509_pos)
  debug_1074:
    .return (rx1509_cur)
  rx1509_restart:
.annotate 'line', 4
    if_null rx1509_debug, debug_1075
    rx1509_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1075:
  rx1509_fail:
    (rx1509_rep, rx1509_pos, $I10, $P10) = rx1509_cur."!mark_fail"(0)
    lt rx1509_pos, -1, rx1509_done
    eq rx1509_pos, -1, rx1509_fail
    jump $I10
  rx1509_done:
    rx1509_cur."!cursor_fail"()
    if_null rx1509_debug, debug_1076
    rx1509_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1076:
    .return (rx1509_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("353_1298839231.515") :method
.annotate 'line', 4
    $P1511 = self."!PREFIX__!subrule"("O", "||")
    new $P1512, "ResizablePMCArray"
    push $P1512, $P1511
    .return ($P1512)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("354_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1516_tgt
    .local int rx1516_pos
    .local int rx1516_off
    .local int rx1516_eos
    .local int rx1516_rep
    .local pmc rx1516_cur
    .local pmc rx1516_debug
    (rx1516_cur, rx1516_pos, rx1516_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1516_cur
    .local pmc match
    .lex "$/", match
    length rx1516_eos, rx1516_tgt
    gt rx1516_pos, rx1516_eos, rx1516_done
    set rx1516_off, 0
    lt rx1516_pos, 2, rx1516_start
    sub rx1516_off, rx1516_pos, 1
    substr rx1516_tgt, rx1516_tgt, rx1516_off
  rx1516_start:
    eq $I10, 1, rx1516_restart
    if_null rx1516_debug, debug_1077
    rx1516_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1520_done
    goto rxscan1520_scan
  rxscan1520_loop:
    (rx1516_pos) = rx1516_cur."from"()
    inc rx1516_pos
    rx1516_cur."!cursor_from"(rx1516_pos)
    ge rx1516_pos, rx1516_eos, rxscan1520_done
  rxscan1520_scan:
    set_addr $I10, rxscan1520_loop
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  rxscan1520_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1521_fail
    rx1516_cur."!mark_push"(0, rx1516_pos, $I10)
  # rx literal  "//"
    add $I11, rx1516_pos, 2
    gt $I11, rx1516_eos, rx1516_fail
    sub $I11, rx1516_pos, rx1516_off
    substr $S10, rx1516_tgt, $I11, 2
    ne $S10, "//", rx1516_fail
    add rx1516_pos, 2
    set_addr $I10, rxcap_1521_fail
    ($I12, $I11) = rx1516_cur."!mark_peek"($I10)
    rx1516_cur."!cursor_pos"($I11)
    ($P10) = rx1516_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1516_pos, "")
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1521_done
  rxcap_1521_fail:
    goto rx1516_fail
  rxcap_1521_done:
  # rx subrule "O" subtype=capture negate=
    rx1516_cur."!cursor_pos"(rx1516_pos)
    $P10 = rx1516_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1516_fail
    rx1516_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1516_pos = $P10."pos"()
  # rx pass
    rx1516_cur."!cursor_pass"(rx1516_pos, "infix:sym<//>")
    if_null rx1516_debug, debug_1078
    rx1516_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1516_pos)
  debug_1078:
    .return (rx1516_cur)
  rx1516_restart:
.annotate 'line', 4
    if_null rx1516_debug, debug_1079
    rx1516_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1079:
  rx1516_fail:
    (rx1516_rep, rx1516_pos, $I10, $P10) = rx1516_cur."!mark_fail"(0)
    lt rx1516_pos, -1, rx1516_done
    eq rx1516_pos, -1, rx1516_fail
    jump $I10
  rx1516_done:
    rx1516_cur."!cursor_fail"()
    if_null rx1516_debug, debug_1080
    rx1516_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1080:
    .return (rx1516_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("355_1298839231.515") :method
.annotate 'line', 4
    $P1518 = self."!PREFIX__!subrule"("O", "//")
    new $P1519, "ResizablePMCArray"
    push $P1519, $P1518
    .return ($P1519)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("356_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1523_tgt
    .local int rx1523_pos
    .local int rx1523_off
    .local int rx1523_eos
    .local int rx1523_rep
    .local pmc rx1523_cur
    .local pmc rx1523_debug
    (rx1523_cur, rx1523_pos, rx1523_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1523_cur
    .local pmc match
    .lex "$/", match
    length rx1523_eos, rx1523_tgt
    gt rx1523_pos, rx1523_eos, rx1523_done
    set rx1523_off, 0
    lt rx1523_pos, 2, rx1523_start
    sub rx1523_off, rx1523_pos, 1
    substr rx1523_tgt, rx1523_tgt, rx1523_off
  rx1523_start:
    eq $I10, 1, rx1523_restart
    if_null rx1523_debug, debug_1081
    rx1523_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1527_done
    goto rxscan1527_scan
  rxscan1527_loop:
    (rx1523_pos) = rx1523_cur."from"()
    inc rx1523_pos
    rx1523_cur."!cursor_from"(rx1523_pos)
    ge rx1523_pos, rx1523_eos, rxscan1527_done
  rxscan1527_scan:
    set_addr $I10, rxscan1527_loop
    rx1523_cur."!mark_push"(0, rx1523_pos, $I10)
  rxscan1527_done:
.annotate 'line', 635
  # rx literal  "??"
    add $I11, rx1523_pos, 2
    gt $I11, rx1523_eos, rx1523_fail
    sub $I11, rx1523_pos, rx1523_off
    substr $S10, rx1523_tgt, $I11, 2
    ne $S10, "??", rx1523_fail
    add rx1523_pos, 2
.annotate 'line', 636
  # rx subrule "ws" subtype=method negate=
    rx1523_cur."!cursor_pos"(rx1523_pos)
    $P10 = rx1523_cur."ws"()
    unless $P10, rx1523_fail
    rx1523_pos = $P10."pos"()
.annotate 'line', 637
  # rx subrule "EXPR" subtype=capture negate=
    rx1523_cur."!cursor_pos"(rx1523_pos)
    $P10 = rx1523_cur."EXPR"("i=")
    unless $P10, rx1523_fail
    rx1523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1523_pos = $P10."pos"()
.annotate 'line', 638
  # rx literal  "!!"
    add $I11, rx1523_pos, 2
    gt $I11, rx1523_eos, rx1523_fail
    sub $I11, rx1523_pos, rx1523_off
    substr $S10, rx1523_tgt, $I11, 2
    ne $S10, "!!", rx1523_fail
    add rx1523_pos, 2
.annotate 'line', 639
  # rx subrule "O" subtype=capture negate=
    rx1523_cur."!cursor_pos"(rx1523_pos)
    $P10 = rx1523_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1523_fail
    rx1523_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1523_pos = $P10."pos"()
.annotate 'line', 634
  # rx pass
    rx1523_cur."!cursor_pass"(rx1523_pos, "infix:sym<?? !!>")
    if_null rx1523_debug, debug_1082
    rx1523_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1523_pos)
  debug_1082:
    .return (rx1523_cur)
  rx1523_restart:
.annotate 'line', 4
    if_null rx1523_debug, debug_1083
    rx1523_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1083:
  rx1523_fail:
    (rx1523_rep, rx1523_pos, $I10, $P10) = rx1523_cur."!mark_fail"(0)
    lt rx1523_pos, -1, rx1523_done
    eq rx1523_pos, -1, rx1523_fail
    jump $I10
  rx1523_done:
    rx1523_cur."!cursor_fail"()
    if_null rx1523_debug, debug_1084
    rx1523_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1084:
    .return (rx1523_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("357_1298839231.515") :method
.annotate 'line', 4
    $P1525 = self."!PREFIX__!subrule"("ws", "??")
    new $P1526, "ResizablePMCArray"
    push $P1526, $P1525
    .return ($P1526)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("358_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1529_tgt
    .local int rx1529_pos
    .local int rx1529_off
    .local int rx1529_eos
    .local int rx1529_rep
    .local pmc rx1529_cur
    .local pmc rx1529_debug
    (rx1529_cur, rx1529_pos, rx1529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1529_cur
    .local pmc match
    .lex "$/", match
    length rx1529_eos, rx1529_tgt
    gt rx1529_pos, rx1529_eos, rx1529_done
    set rx1529_off, 0
    lt rx1529_pos, 2, rx1529_start
    sub rx1529_off, rx1529_pos, 1
    substr rx1529_tgt, rx1529_tgt, rx1529_off
  rx1529_start:
    eq $I10, 1, rx1529_restart
    if_null rx1529_debug, debug_1085
    rx1529_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1533_done
    goto rxscan1533_scan
  rxscan1533_loop:
    (rx1529_pos) = rx1529_cur."from"()
    inc rx1529_pos
    rx1529_cur."!cursor_from"(rx1529_pos)
    ge rx1529_pos, rx1529_eos, rxscan1533_done
  rxscan1533_scan:
    set_addr $I10, rxscan1533_loop
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  rxscan1533_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1534_fail
    rx1529_cur."!mark_push"(0, rx1529_pos, $I10)
  # rx literal  "="
    add $I11, rx1529_pos, 1
    gt $I11, rx1529_eos, rx1529_fail
    sub $I11, rx1529_pos, rx1529_off
    ord $I11, rx1529_tgt, $I11
    ne $I11, 61, rx1529_fail
    add rx1529_pos, 1
    set_addr $I10, rxcap_1534_fail
    ($I12, $I11) = rx1529_cur."!mark_peek"($I10)
    rx1529_cur."!cursor_pos"($I11)
    ($P10) = rx1529_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1529_pos, "")
    rx1529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1534_done
  rxcap_1534_fail:
    goto rx1529_fail
  rxcap_1534_done:
  # rx subrule "panic" subtype=method negate=
    rx1529_cur."!cursor_pos"(rx1529_pos)
    $P10 = rx1529_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1529_fail
    rx1529_pos = $P10."pos"()
.annotate 'line', 642
  # rx pass
    rx1529_cur."!cursor_pass"(rx1529_pos, "infix:sym<=>")
    if_null rx1529_debug, debug_1086
    rx1529_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1529_pos)
  debug_1086:
    .return (rx1529_cur)
  rx1529_restart:
.annotate 'line', 4
    if_null rx1529_debug, debug_1087
    rx1529_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1087:
  rx1529_fail:
    (rx1529_rep, rx1529_pos, $I10, $P10) = rx1529_cur."!mark_fail"(0)
    lt rx1529_pos, -1, rx1529_done
    eq rx1529_pos, -1, rx1529_fail
    jump $I10
  rx1529_done:
    rx1529_cur."!cursor_fail"()
    if_null rx1529_debug, debug_1088
    rx1529_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1088:
    .return (rx1529_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("359_1298839231.515") :method
.annotate 'line', 4
    $P1531 = self."!PREFIX__!subrule"("panic", "=")
    new $P1532, "ResizablePMCArray"
    push $P1532, $P1531
    .return ($P1532)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("360_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1536_tgt
    .local int rx1536_pos
    .local int rx1536_off
    .local int rx1536_eos
    .local int rx1536_rep
    .local pmc rx1536_cur
    .local pmc rx1536_debug
    (rx1536_cur, rx1536_pos, rx1536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1536_cur
    .local pmc match
    .lex "$/", match
    length rx1536_eos, rx1536_tgt
    gt rx1536_pos, rx1536_eos, rx1536_done
    set rx1536_off, 0
    lt rx1536_pos, 2, rx1536_start
    sub rx1536_off, rx1536_pos, 1
    substr rx1536_tgt, rx1536_tgt, rx1536_off
  rx1536_start:
    eq $I10, 1, rx1536_restart
    if_null rx1536_debug, debug_1089
    rx1536_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1540_done
    goto rxscan1540_scan
  rxscan1540_loop:
    (rx1536_pos) = rx1536_cur."from"()
    inc rx1536_pos
    rx1536_cur."!cursor_from"(rx1536_pos)
    ge rx1536_pos, rx1536_eos, rxscan1540_done
  rxscan1540_scan:
    set_addr $I10, rxscan1540_loop
    rx1536_cur."!mark_push"(0, rx1536_pos, $I10)
  rxscan1540_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1541_fail
    rx1536_cur."!mark_push"(0, rx1536_pos, $I10)
  # rx literal  ":="
    add $I11, rx1536_pos, 2
    gt $I11, rx1536_eos, rx1536_fail
    sub $I11, rx1536_pos, rx1536_off
    substr $S10, rx1536_tgt, $I11, 2
    ne $S10, ":=", rx1536_fail
    add rx1536_pos, 2
    set_addr $I10, rxcap_1541_fail
    ($I12, $I11) = rx1536_cur."!mark_peek"($I10)
    rx1536_cur."!cursor_pos"($I11)
    ($P10) = rx1536_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1536_pos, "")
    rx1536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1541_done
  rxcap_1541_fail:
    goto rx1536_fail
  rxcap_1541_done:
  # rx subrule "O" subtype=capture negate=
    rx1536_cur."!cursor_pos"(rx1536_pos)
    $P10 = rx1536_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1536_fail
    rx1536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1536_pos = $P10."pos"()
  # rx pass
    rx1536_cur."!cursor_pass"(rx1536_pos, "infix:sym<:=>")
    if_null rx1536_debug, debug_1090
    rx1536_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1536_pos)
  debug_1090:
    .return (rx1536_cur)
  rx1536_restart:
.annotate 'line', 4
    if_null rx1536_debug, debug_1091
    rx1536_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1091:
  rx1536_fail:
    (rx1536_rep, rx1536_pos, $I10, $P10) = rx1536_cur."!mark_fail"(0)
    lt rx1536_pos, -1, rx1536_done
    eq rx1536_pos, -1, rx1536_fail
    jump $I10
  rx1536_done:
    rx1536_cur."!cursor_fail"()
    if_null rx1536_debug, debug_1092
    rx1536_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1092:
    .return (rx1536_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("361_1298839231.515") :method
.annotate 'line', 4
    $P1538 = self."!PREFIX__!subrule"("O", ":=")
    new $P1539, "ResizablePMCArray"
    push $P1539, $P1538
    .return ($P1539)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("362_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1543_tgt
    .local int rx1543_pos
    .local int rx1543_off
    .local int rx1543_eos
    .local int rx1543_rep
    .local pmc rx1543_cur
    .local pmc rx1543_debug
    (rx1543_cur, rx1543_pos, rx1543_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1543_cur
    .local pmc match
    .lex "$/", match
    length rx1543_eos, rx1543_tgt
    gt rx1543_pos, rx1543_eos, rx1543_done
    set rx1543_off, 0
    lt rx1543_pos, 2, rx1543_start
    sub rx1543_off, rx1543_pos, 1
    substr rx1543_tgt, rx1543_tgt, rx1543_off
  rx1543_start:
    eq $I10, 1, rx1543_restart
    if_null rx1543_debug, debug_1093
    rx1543_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1547_done
    goto rxscan1547_scan
  rxscan1547_loop:
    (rx1543_pos) = rx1543_cur."from"()
    inc rx1543_pos
    rx1543_cur."!cursor_from"(rx1543_pos)
    ge rx1543_pos, rx1543_eos, rxscan1547_done
  rxscan1547_scan:
    set_addr $I10, rxscan1547_loop
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  rxscan1547_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1548_fail
    rx1543_cur."!mark_push"(0, rx1543_pos, $I10)
  # rx literal  "::="
    add $I11, rx1543_pos, 3
    gt $I11, rx1543_eos, rx1543_fail
    sub $I11, rx1543_pos, rx1543_off
    substr $S10, rx1543_tgt, $I11, 3
    ne $S10, "::=", rx1543_fail
    add rx1543_pos, 3
    set_addr $I10, rxcap_1548_fail
    ($I12, $I11) = rx1543_cur."!mark_peek"($I10)
    rx1543_cur."!cursor_pos"($I11)
    ($P10) = rx1543_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1543_pos, "")
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1548_done
  rxcap_1548_fail:
    goto rx1543_fail
  rxcap_1548_done:
  # rx subrule "O" subtype=capture negate=
    rx1543_cur."!cursor_pos"(rx1543_pos)
    $P10 = rx1543_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1543_fail
    rx1543_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1543_pos = $P10."pos"()
  # rx pass
    rx1543_cur."!cursor_pass"(rx1543_pos, "infix:sym<::=>")
    if_null rx1543_debug, debug_1094
    rx1543_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1543_pos)
  debug_1094:
    .return (rx1543_cur)
  rx1543_restart:
.annotate 'line', 4
    if_null rx1543_debug, debug_1095
    rx1543_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1095:
  rx1543_fail:
    (rx1543_rep, rx1543_pos, $I10, $P10) = rx1543_cur."!mark_fail"(0)
    lt rx1543_pos, -1, rx1543_done
    eq rx1543_pos, -1, rx1543_fail
    jump $I10
  rx1543_done:
    rx1543_cur."!cursor_fail"()
    if_null rx1543_debug, debug_1096
    rx1543_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1096:
    .return (rx1543_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("363_1298839231.515") :method
.annotate 'line', 4
    $P1545 = self."!PREFIX__!subrule"("O", "::=")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("364_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1550_tgt
    .local int rx1550_pos
    .local int rx1550_off
    .local int rx1550_eos
    .local int rx1550_rep
    .local pmc rx1550_cur
    .local pmc rx1550_debug
    (rx1550_cur, rx1550_pos, rx1550_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1550_cur
    .local pmc match
    .lex "$/", match
    length rx1550_eos, rx1550_tgt
    gt rx1550_pos, rx1550_eos, rx1550_done
    set rx1550_off, 0
    lt rx1550_pos, 2, rx1550_start
    sub rx1550_off, rx1550_pos, 1
    substr rx1550_tgt, rx1550_tgt, rx1550_off
  rx1550_start:
    eq $I10, 1, rx1550_restart
    if_null rx1550_debug, debug_1097
    rx1550_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1554_done
    goto rxscan1554_scan
  rxscan1554_loop:
    (rx1550_pos) = rx1550_cur."from"()
    inc rx1550_pos
    rx1550_cur."!cursor_from"(rx1550_pos)
    ge rx1550_pos, rx1550_eos, rxscan1554_done
  rxscan1554_scan:
    set_addr $I10, rxscan1554_loop
    rx1550_cur."!mark_push"(0, rx1550_pos, $I10)
  rxscan1554_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1555_fail
    rx1550_cur."!mark_push"(0, rx1550_pos, $I10)
  # rx literal  ","
    add $I11, rx1550_pos, 1
    gt $I11, rx1550_eos, rx1550_fail
    sub $I11, rx1550_pos, rx1550_off
    ord $I11, rx1550_tgt, $I11
    ne $I11, 44, rx1550_fail
    add rx1550_pos, 1
    set_addr $I10, rxcap_1555_fail
    ($I12, $I11) = rx1550_cur."!mark_peek"($I10)
    rx1550_cur."!cursor_pos"($I11)
    ($P10) = rx1550_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1550_pos, "")
    rx1550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1555_done
  rxcap_1555_fail:
    goto rx1550_fail
  rxcap_1555_done:
  # rx subrule "O" subtype=capture negate=
    rx1550_cur."!cursor_pos"(rx1550_pos)
    $P10 = rx1550_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1550_fail
    rx1550_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1550_pos = $P10."pos"()
  # rx pass
    rx1550_cur."!cursor_pass"(rx1550_pos, "infix:sym<,>")
    if_null rx1550_debug, debug_1098
    rx1550_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1550_pos)
  debug_1098:
    .return (rx1550_cur)
  rx1550_restart:
.annotate 'line', 4
    if_null rx1550_debug, debug_1099
    rx1550_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1099:
  rx1550_fail:
    (rx1550_rep, rx1550_pos, $I10, $P10) = rx1550_cur."!mark_fail"(0)
    lt rx1550_pos, -1, rx1550_done
    eq rx1550_pos, -1, rx1550_fail
    jump $I10
  rx1550_done:
    rx1550_cur."!cursor_fail"()
    if_null rx1550_debug, debug_1100
    rx1550_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1100:
    .return (rx1550_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("365_1298839231.515") :method
.annotate 'line', 4
    $P1552 = self."!PREFIX__!subrule"("O", ",")
    new $P1553, "ResizablePMCArray"
    push $P1553, $P1552
    .return ($P1553)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("366_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P1565 = "368_1298839231.515" 
    capture_lex $P1565
    .local string rx1557_tgt
    .local int rx1557_pos
    .local int rx1557_off
    .local int rx1557_eos
    .local int rx1557_rep
    .local pmc rx1557_cur
    .local pmc rx1557_debug
    (rx1557_cur, rx1557_pos, rx1557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1557_cur
    .local pmc match
    .lex "$/", match
    length rx1557_eos, rx1557_tgt
    gt rx1557_pos, rx1557_eos, rx1557_done
    set rx1557_off, 0
    lt rx1557_pos, 2, rx1557_start
    sub rx1557_off, rx1557_pos, 1
    substr rx1557_tgt, rx1557_tgt, rx1557_off
  rx1557_start:
    eq $I10, 1, rx1557_restart
    if_null rx1557_debug, debug_1101
    rx1557_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1557_pos) = rx1557_cur."from"()
    inc rx1557_pos
    rx1557_cur."!cursor_from"(rx1557_pos)
    ge rx1557_pos, rx1557_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  rxscan1560_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1561_fail
    rx1557_cur."!mark_push"(0, rx1557_pos, $I10)
  # rx literal  "return"
    add $I11, rx1557_pos, 6
    gt $I11, rx1557_eos, rx1557_fail
    sub $I11, rx1557_pos, rx1557_off
    substr $S10, rx1557_tgt, $I11, 6
    ne $S10, "return", rx1557_fail
    add rx1557_pos, 6
    set_addr $I10, rxcap_1561_fail
    ($I12, $I11) = rx1557_cur."!mark_peek"($I10)
    rx1557_cur."!cursor_pos"($I11)
    ($P10) = rx1557_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1557_pos, "")
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1561_done
  rxcap_1561_fail:
    goto rx1557_fail
  rxcap_1561_done:
  # rx charclass s
    ge rx1557_pos, rx1557_eos, rx1557_fail
    sub $I10, rx1557_pos, rx1557_off
    is_cclass $I11, 32, rx1557_tgt, $I10
    unless $I11, rx1557_fail
    inc rx1557_pos
  # rx subrule "O" subtype=capture negate=
    rx1557_cur."!cursor_pos"(rx1557_pos)
    $P10 = rx1557_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1557_fail
    rx1557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1557_pos = $P10."pos"()
    rx1557_cur."!cursor_pos"(rx1557_pos)
    find_lex $P1562, unicode:"$\x{a2}"
    $P1563 = $P1562."MATCH"()
    store_lex "$/", $P1563
    .const 'Sub' $P1565 = "368_1298839231.515" 
    capture_lex $P1565
    $P1567 = $P1565()
  # rx pass
    rx1557_cur."!cursor_pass"(rx1557_pos, "prefix:sym<return>")
    if_null rx1557_debug, debug_1102
    rx1557_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1557_pos)
  debug_1102:
    .return (rx1557_cur)
  rx1557_restart:
.annotate 'line', 4
    if_null rx1557_debug, debug_1103
    rx1557_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1103:
  rx1557_fail:
    (rx1557_rep, rx1557_pos, $I10, $P10) = rx1557_cur."!mark_fail"(0)
    lt rx1557_pos, -1, rx1557_done
    eq rx1557_pos, -1, rx1557_fail
    jump $I10
  rx1557_done:
    rx1557_cur."!cursor_fail"()
    if_null rx1557_debug, debug_1104
    rx1557_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1104:
    .return (rx1557_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("367_1298839231.515") :method
.annotate 'line', 4
    new $P1559, "ResizablePMCArray"
    push $P1559, "return"
    .return ($P1559)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1564"  :anon :subid("368_1298839231.515") :outer("366_1298839231.515")
.annotate 'line', 650
    new $P1566, "Integer"
    assign $P1566, 1
    store_dynamic_lex "$*RETURN_USED", $P1566
    .return ($P1566)
.end


.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("369_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1569_tgt
    .local int rx1569_pos
    .local int rx1569_off
    .local int rx1569_eos
    .local int rx1569_rep
    .local pmc rx1569_cur
    .local pmc rx1569_debug
    (rx1569_cur, rx1569_pos, rx1569_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1569_cur
    .local pmc match
    .lex "$/", match
    length rx1569_eos, rx1569_tgt
    gt rx1569_pos, rx1569_eos, rx1569_done
    set rx1569_off, 0
    lt rx1569_pos, 2, rx1569_start
    sub rx1569_off, rx1569_pos, 1
    substr rx1569_tgt, rx1569_tgt, rx1569_off
  rx1569_start:
    eq $I10, 1, rx1569_restart
    if_null rx1569_debug, debug_1105
    rx1569_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1572_done
    goto rxscan1572_scan
  rxscan1572_loop:
    (rx1569_pos) = rx1569_cur."from"()
    inc rx1569_pos
    rx1569_cur."!cursor_from"(rx1569_pos)
    ge rx1569_pos, rx1569_eos, rxscan1572_done
  rxscan1572_scan:
    set_addr $I10, rxscan1572_loop
    rx1569_cur."!mark_push"(0, rx1569_pos, $I10)
  rxscan1572_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1573_fail
    rx1569_cur."!mark_push"(0, rx1569_pos, $I10)
  # rx literal  "make"
    add $I11, rx1569_pos, 4
    gt $I11, rx1569_eos, rx1569_fail
    sub $I11, rx1569_pos, rx1569_off
    substr $S10, rx1569_tgt, $I11, 4
    ne $S10, "make", rx1569_fail
    add rx1569_pos, 4
    set_addr $I10, rxcap_1573_fail
    ($I12, $I11) = rx1569_cur."!mark_peek"($I10)
    rx1569_cur."!cursor_pos"($I11)
    ($P10) = rx1569_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1569_pos, "")
    rx1569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1573_done
  rxcap_1573_fail:
    goto rx1569_fail
  rxcap_1573_done:
  # rx charclass s
    ge rx1569_pos, rx1569_eos, rx1569_fail
    sub $I10, rx1569_pos, rx1569_off
    is_cclass $I11, 32, rx1569_tgt, $I10
    unless $I11, rx1569_fail
    inc rx1569_pos
  # rx subrule "O" subtype=capture negate=
    rx1569_cur."!cursor_pos"(rx1569_pos)
    $P10 = rx1569_cur."O"("%list_prefix")
    unless $P10, rx1569_fail
    rx1569_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1569_pos = $P10."pos"()
  # rx pass
    rx1569_cur."!cursor_pass"(rx1569_pos, "prefix:sym<make>")
    if_null rx1569_debug, debug_1106
    rx1569_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1569_pos)
  debug_1106:
    .return (rx1569_cur)
  rx1569_restart:
.annotate 'line', 4
    if_null rx1569_debug, debug_1107
    rx1569_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1107:
  rx1569_fail:
    (rx1569_rep, rx1569_pos, $I10, $P10) = rx1569_cur."!mark_fail"(0)
    lt rx1569_pos, -1, rx1569_done
    eq rx1569_pos, -1, rx1569_fail
    jump $I10
  rx1569_done:
    rx1569_cur."!cursor_fail"()
    if_null rx1569_debug, debug_1108
    rx1569_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1108:
    .return (rx1569_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("370_1298839231.515") :method
.annotate 'line', 4
    new $P1571, "ResizablePMCArray"
    push $P1571, "make"
    .return ($P1571)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("371_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1575_tgt
    .local int rx1575_pos
    .local int rx1575_off
    .local int rx1575_eos
    .local int rx1575_rep
    .local pmc rx1575_cur
    .local pmc rx1575_debug
    (rx1575_cur, rx1575_pos, rx1575_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1575_cur
    .local pmc match
    .lex "$/", match
    length rx1575_eos, rx1575_tgt
    gt rx1575_pos, rx1575_eos, rx1575_done
    set rx1575_off, 0
    lt rx1575_pos, 2, rx1575_start
    sub rx1575_off, rx1575_pos, 1
    substr rx1575_tgt, rx1575_tgt, rx1575_off
  rx1575_start:
    eq $I10, 1, rx1575_restart
    if_null rx1575_debug, debug_1109
    rx1575_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1578_done
    goto rxscan1578_scan
  rxscan1578_loop:
    (rx1575_pos) = rx1575_cur."from"()
    inc rx1575_pos
    rx1575_cur."!cursor_from"(rx1575_pos)
    ge rx1575_pos, rx1575_eos, rxscan1578_done
  rxscan1578_scan:
    set_addr $I10, rxscan1578_loop
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  rxscan1578_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1579_fail
    rx1575_cur."!mark_push"(0, rx1575_pos, $I10)
  # rx literal  "last"
    add $I11, rx1575_pos, 4
    gt $I11, rx1575_eos, rx1575_fail
    sub $I11, rx1575_pos, rx1575_off
    substr $S10, rx1575_tgt, $I11, 4
    ne $S10, "last", rx1575_fail
    add rx1575_pos, 4
    set_addr $I10, rxcap_1579_fail
    ($I12, $I11) = rx1575_cur."!mark_peek"($I10)
    rx1575_cur."!cursor_pos"($I11)
    ($P10) = rx1575_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1575_pos, "")
    rx1575_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1579_done
  rxcap_1579_fail:
    goto rx1575_fail
  rxcap_1579_done:
  # rx pass
    rx1575_cur."!cursor_pass"(rx1575_pos, "term:sym<last>")
    if_null rx1575_debug, debug_1110
    rx1575_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1575_pos)
  debug_1110:
    .return (rx1575_cur)
  rx1575_restart:
.annotate 'line', 4
    if_null rx1575_debug, debug_1111
    rx1575_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1111:
  rx1575_fail:
    (rx1575_rep, rx1575_pos, $I10, $P10) = rx1575_cur."!mark_fail"(0)
    lt rx1575_pos, -1, rx1575_done
    eq rx1575_pos, -1, rx1575_fail
    jump $I10
  rx1575_done:
    rx1575_cur."!cursor_fail"()
    if_null rx1575_debug, debug_1112
    rx1575_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1112:
    .return (rx1575_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("372_1298839231.515") :method
.annotate 'line', 4
    new $P1577, "ResizablePMCArray"
    push $P1577, "last"
    .return ($P1577)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("373_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1581_tgt
    .local int rx1581_pos
    .local int rx1581_off
    .local int rx1581_eos
    .local int rx1581_rep
    .local pmc rx1581_cur
    .local pmc rx1581_debug
    (rx1581_cur, rx1581_pos, rx1581_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1581_cur
    .local pmc match
    .lex "$/", match
    length rx1581_eos, rx1581_tgt
    gt rx1581_pos, rx1581_eos, rx1581_done
    set rx1581_off, 0
    lt rx1581_pos, 2, rx1581_start
    sub rx1581_off, rx1581_pos, 1
    substr rx1581_tgt, rx1581_tgt, rx1581_off
  rx1581_start:
    eq $I10, 1, rx1581_restart
    if_null rx1581_debug, debug_1113
    rx1581_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1584_done
    goto rxscan1584_scan
  rxscan1584_loop:
    (rx1581_pos) = rx1581_cur."from"()
    inc rx1581_pos
    rx1581_cur."!cursor_from"(rx1581_pos)
    ge rx1581_pos, rx1581_eos, rxscan1584_done
  rxscan1584_scan:
    set_addr $I10, rxscan1584_loop
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  rxscan1584_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1585_fail
    rx1581_cur."!mark_push"(0, rx1581_pos, $I10)
  # rx literal  "next"
    add $I11, rx1581_pos, 4
    gt $I11, rx1581_eos, rx1581_fail
    sub $I11, rx1581_pos, rx1581_off
    substr $S10, rx1581_tgt, $I11, 4
    ne $S10, "next", rx1581_fail
    add rx1581_pos, 4
    set_addr $I10, rxcap_1585_fail
    ($I12, $I11) = rx1581_cur."!mark_peek"($I10)
    rx1581_cur."!cursor_pos"($I11)
    ($P10) = rx1581_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1581_pos, "")
    rx1581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1585_done
  rxcap_1585_fail:
    goto rx1581_fail
  rxcap_1585_done:
  # rx pass
    rx1581_cur."!cursor_pass"(rx1581_pos, "term:sym<next>")
    if_null rx1581_debug, debug_1114
    rx1581_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1581_pos)
  debug_1114:
    .return (rx1581_cur)
  rx1581_restart:
.annotate 'line', 4
    if_null rx1581_debug, debug_1115
    rx1581_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1115:
  rx1581_fail:
    (rx1581_rep, rx1581_pos, $I10, $P10) = rx1581_cur."!mark_fail"(0)
    lt rx1581_pos, -1, rx1581_done
    eq rx1581_pos, -1, rx1581_fail
    jump $I10
  rx1581_done:
    rx1581_cur."!cursor_fail"()
    if_null rx1581_debug, debug_1116
    rx1581_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1116:
    .return (rx1581_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("374_1298839231.515") :method
.annotate 'line', 4
    new $P1583, "ResizablePMCArray"
    push $P1583, "next"
    .return ($P1583)
.end


.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("375_1298839231.515") :method :outer("11_1298839231.515")
.annotate 'line', 4
    .local string rx1587_tgt
    .local int rx1587_pos
    .local int rx1587_off
    .local int rx1587_eos
    .local int rx1587_rep
    .local pmc rx1587_cur
    .local pmc rx1587_debug
    (rx1587_cur, rx1587_pos, rx1587_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1587_cur
    .local pmc match
    .lex "$/", match
    length rx1587_eos, rx1587_tgt
    gt rx1587_pos, rx1587_eos, rx1587_done
    set rx1587_off, 0
    lt rx1587_pos, 2, rx1587_start
    sub rx1587_off, rx1587_pos, 1
    substr rx1587_tgt, rx1587_tgt, rx1587_off
  rx1587_start:
    eq $I10, 1, rx1587_restart
    if_null rx1587_debug, debug_1117
    rx1587_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1117:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1590_done
    goto rxscan1590_scan
  rxscan1590_loop:
    (rx1587_pos) = rx1587_cur."from"()
    inc rx1587_pos
    rx1587_cur."!cursor_from"(rx1587_pos)
    ge rx1587_pos, rx1587_eos, rxscan1590_done
  rxscan1590_scan:
    set_addr $I10, rxscan1590_loop
    rx1587_cur."!mark_push"(0, rx1587_pos, $I10)
  rxscan1590_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1591_fail
    rx1587_cur."!mark_push"(0, rx1587_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1587_pos, 4
    gt $I11, rx1587_eos, rx1587_fail
    sub $I11, rx1587_pos, rx1587_off
    substr $S10, rx1587_tgt, $I11, 4
    ne $S10, "redo", rx1587_fail
    add rx1587_pos, 4
    set_addr $I10, rxcap_1591_fail
    ($I12, $I11) = rx1587_cur."!mark_peek"($I10)
    rx1587_cur."!cursor_pos"($I11)
    ($P10) = rx1587_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1587_pos, "")
    rx1587_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1591_done
  rxcap_1591_fail:
    goto rx1587_fail
  rxcap_1591_done:
  # rx pass
    rx1587_cur."!cursor_pass"(rx1587_pos, "term:sym<redo>")
    if_null rx1587_debug, debug_1118
    rx1587_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1587_pos)
  debug_1118:
    .return (rx1587_cur)
  rx1587_restart:
.annotate 'line', 4
    if_null rx1587_debug, debug_1119
    rx1587_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1119:
  rx1587_fail:
    (rx1587_rep, rx1587_pos, $I10, $P10) = rx1587_cur."!mark_fail"(0)
    lt rx1587_pos, -1, rx1587_done
    eq rx1587_pos, -1, rx1587_fail
    jump $I10
  rx1587_done:
    rx1587_cur."!cursor_fail"()
    if_null rx1587_debug, debug_1120
    rx1587_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1120:
    .return (rx1587_cur)
    .return ()
.end


.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("376_1298839231.515") :method
.annotate 'line', 4
    new $P1589, "ResizablePMCArray"
    push $P1589, "redo"
    .return ($P1589)
.end


.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("377_1298839231.515") :outer("11_1298839231.515")
    .param pmc param_1593
    .param pmc param_1594
.annotate 'line', 656
    .lex "self", param_1593
    .lex "$/", param_1594
.annotate 'line', 658
    new $P1595, "Undef"
    .lex "$t", $P1595
    find_lex $P1596, "$/"
    unless_null $P1596, vivify_1121
    $P1596 = root_new ['parrot';'ResizablePMCArray']
  vivify_1121:
    set $P1597, $P1596[0]
    unless_null $P1597, vivify_1122
    new $P1597, "Undef"
  vivify_1122:
    store_lex "$t", $P1597
    find_lex $P1598, "$/"
    unless_null $P1598, vivify_1123
    $P1598 = root_new ['parrot';'ResizablePMCArray']
  vivify_1123:
    set $P1599, $P1598[1]
    unless_null $P1599, vivify_1124
    new $P1599, "Undef"
  vivify_1124:
    find_lex $P1600, "$/"
    unless_null $P1600, vivify_1125
    $P1600 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1600
  vivify_1125:
    set $P1600[0], $P1599
    find_lex $P1601, "$t"
    find_lex $P1602, "$/"
    unless_null $P1602, vivify_1126
    $P1602 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1602
  vivify_1126:
    set $P1602[1], $P1601
.annotate 'line', 656
    .return ($P1601)
.end


.namespace ["NQP";"Regex"]
.sub "_block1603"  :subid("378_1298839231.515") :outer("11_1298839231.515")
.annotate 'line', 662
    .const 'Sub' $P1668 = "399_1298839231.515" 
    capture_lex $P1668
    .const 'Sub' $P1661 = "397_1298839231.515" 
    capture_lex $P1661
    .const 'Sub' $P1656 = "395_1298839231.515" 
    capture_lex $P1656
    .const 'Sub' $P1644 = "392_1298839231.515" 
    capture_lex $P1644
    .const 'Sub' $P1634 = "389_1298839231.515" 
    capture_lex $P1634
    .const 'Sub' $P1629 = "387_1298839231.515" 
    capture_lex $P1629
    .const 'Sub' $P1620 = "384_1298839231.515" 
    capture_lex $P1620
    .const 'Sub' $P1615 = "382_1298839231.515" 
    capture_lex $P1615
    .const 'Sub' $P1606 = "379_1298839231.515" 
    capture_lex $P1606
    get_global $P1605, "$?CLASS"
    .const 'Sub' $P1661 = "397_1298839231.515" 
    capture_lex $P1661
    .return ($P1661)
.end


.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1127") :outer("378_1298839231.515")
.annotate 'line', 662
    get_hll_global $P1604, ["NQP";"Regex"], "_block1603" 
    .local pmc block
    set block, $P1604
    .const 'Sub' $P1668 = "399_1298839231.515" 
    capture_lex $P1668
    $P1668()
.end


.namespace ["NQP";"Regex"]
.sub "_block1667"  :anon :subid("399_1298839231.515") :outer("378_1298839231.515")
.annotate 'line', 662
    get_hll_global $P1669, "NQPClassHOW"
    $P1670 = $P1669."new_type"("Regex" :named("name"))
    .local pmc type_obj
    set type_obj, $P1670
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1671, type_obj
    .const 'Sub' $P1672 = "379_1298839231.515" 
    $P1671."add_method"(type_obj, "metachar:sym<:my>", $P1672)
    get_how $P1673, type_obj
    get_global $P1674, "!PREFIX__metachar:sym<:my>"
    $P1673."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1674)
    get_how $P1675, type_obj
    .const 'Sub' $P1676 = "382_1298839231.515" 
    $P1675."add_method"(type_obj, "metachar:sym<{ }>", $P1676)
    get_how $P1677, type_obj
    get_global $P1678, "!PREFIX__metachar:sym<{ }>"
    $P1677."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1678)
    get_how $P1679, type_obj
    .const 'Sub' $P1680 = "384_1298839231.515" 
    $P1679."add_method"(type_obj, "metachar:sym<nqpvar>", $P1680)
    get_how $P1681, type_obj
    get_global $P1682, "!PREFIX__metachar:sym<nqpvar>"
    $P1681."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1682)
    get_how $P1683, type_obj
    .const 'Sub' $P1684 = "387_1298839231.515" 
    $P1683."add_method"(type_obj, "assertion:sym<{ }>", $P1684)
    get_how $P1685, type_obj
    get_global $P1686, "!PREFIX__assertion:sym<{ }>"
    $P1685."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1686)
    get_how $P1687, type_obj
    .const 'Sub' $P1688 = "389_1298839231.515" 
    $P1687."add_method"(type_obj, "assertion:sym<?{ }>", $P1688)
    get_how $P1689, type_obj
    get_global $P1690, "!PREFIX__assertion:sym<?{ }>"
    $P1689."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1690)
    get_how $P1691, type_obj
    .const 'Sub' $P1692 = "392_1298839231.515" 
    $P1691."add_method"(type_obj, "assertion:sym<name>", $P1692)
    get_how $P1693, type_obj
    get_global $P1694, "!PREFIX__assertion:sym<name>"
    $P1693."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1694)
    get_how $P1695, type_obj
    .const 'Sub' $P1696 = "395_1298839231.515" 
    $P1695."add_method"(type_obj, "assertion:sym<var>", $P1696)
    get_how $P1697, type_obj
    get_global $P1698, "!PREFIX__assertion:sym<var>"
    $P1697."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1698)
    get_how $P1699, type_obj
    .const 'Sub' $P1700 = "397_1298839231.515" 
    $P1699."add_method"(type_obj, "codeblock", $P1700)
    get_how $P1701, type_obj
    get_global $P1702, "!PREFIX__codeblock"
    $P1701."add_method"(type_obj, "!PREFIX__codeblock", $P1702)
    get_how $P1703, type_obj
    get_hll_global $P1704, ["Regex";"P6Regex"], "Grammar"
    $P1703."add_parent"(type_obj, $P1704)
    get_how $P1705, type_obj
    $P1706 = $P1705."compose"(type_obj)
    .return ($P1706)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("379_1298839231.515") :method :outer("378_1298839231.515")
.annotate 'line', 662
    .const 'Sub' $P1612 = "381_1298839231.515" 
    capture_lex $P1612
    .local string rx1607_tgt
    .local int rx1607_pos
    .local int rx1607_off
    .local int rx1607_eos
    .local int rx1607_rep
    .local pmc rx1607_cur
    .local pmc rx1607_debug
    (rx1607_cur, rx1607_pos, rx1607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1607_cur
    .local pmc match
    .lex "$/", match
    length rx1607_eos, rx1607_tgt
    gt rx1607_pos, rx1607_eos, rx1607_done
    set rx1607_off, 0
    lt rx1607_pos, 2, rx1607_start
    sub rx1607_off, rx1607_pos, 1
    substr rx1607_tgt, rx1607_tgt, rx1607_off
  rx1607_start:
    eq $I10, 1, rx1607_restart
    if_null rx1607_debug, debug_1128
    rx1607_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1610_done
    goto rxscan1610_scan
  rxscan1610_loop:
    (rx1607_pos) = rx1607_cur."from"()
    inc rx1607_pos
    rx1607_cur."!cursor_from"(rx1607_pos)
    ge rx1607_pos, rx1607_eos, rxscan1610_done
  rxscan1610_scan:
    set_addr $I10, rxscan1610_loop
    rx1607_cur."!mark_push"(0, rx1607_pos, $I10)
  rxscan1610_done:
.annotate 'line', 664
  # rx literal  ":"
    add $I11, rx1607_pos, 1
    gt $I11, rx1607_eos, rx1607_fail
    sub $I11, rx1607_pos, rx1607_off
    ord $I11, rx1607_tgt, $I11
    ne $I11, 58, rx1607_fail
    add rx1607_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1607_cur."!cursor_pos"(rx1607_pos)
    .const 'Sub' $P1612 = "381_1298839231.515" 
    capture_lex $P1612
    $P10 = rx1607_cur."before"($P1612)
    unless $P10, rx1607_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1607_cur."!cursor_pos"(rx1607_pos)
    $P10 = rx1607_cur."LANG"("MAIN", "statement")
    unless $P10, rx1607_fail
    rx1607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1607_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1607_cur."!cursor_pos"(rx1607_pos)
    $P10 = rx1607_cur."ws"()
    unless $P10, rx1607_fail
    rx1607_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1607_pos, 1
    gt $I11, rx1607_eos, rx1607_fail
    sub $I11, rx1607_pos, rx1607_off
    ord $I11, rx1607_tgt, $I11
    ne $I11, 59, rx1607_fail
    add rx1607_pos, 1
.annotate 'line', 663
  # rx pass
    rx1607_cur."!cursor_pass"(rx1607_pos, "metachar:sym<:my>")
    if_null rx1607_debug, debug_1133
    rx1607_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1607_pos)
  debug_1133:
    .return (rx1607_cur)
  rx1607_restart:
.annotate 'line', 662
    if_null rx1607_debug, debug_1134
    rx1607_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1134:
  rx1607_fail:
    (rx1607_rep, rx1607_pos, $I10, $P10) = rx1607_cur."!mark_fail"(0)
    lt rx1607_pos, -1, rx1607_done
    eq rx1607_pos, -1, rx1607_fail
    jump $I10
  rx1607_done:
    rx1607_cur."!cursor_fail"()
    if_null rx1607_debug, debug_1135
    rx1607_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1135:
    .return (rx1607_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("380_1298839231.515") :method
.annotate 'line', 662
    new $P1609, "ResizablePMCArray"
    push $P1609, ":"
    .return ($P1609)
.end


.namespace ["NQP";"Regex"]
.sub "_block1611"  :anon :subid("381_1298839231.515") :method :outer("379_1298839231.515")
.annotate 'line', 664
    .local string rx1613_tgt
    .local int rx1613_pos
    .local int rx1613_off
    .local int rx1613_eos
    .local int rx1613_rep
    .local pmc rx1613_cur
    .local pmc rx1613_debug
    (rx1613_cur, rx1613_pos, rx1613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1613_cur
    .local pmc match
    .lex "$/", match
    length rx1613_eos, rx1613_tgt
    gt rx1613_pos, rx1613_eos, rx1613_done
    set rx1613_off, 0
    lt rx1613_pos, 2, rx1613_start
    sub rx1613_off, rx1613_pos, 1
    substr rx1613_tgt, rx1613_tgt, rx1613_off
  rx1613_start:
    eq $I10, 1, rx1613_restart
    if_null rx1613_debug, debug_1129
    rx1613_cur."!cursor_debug"("START", "")
  debug_1129:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1614_done
    goto rxscan1614_scan
  rxscan1614_loop:
    (rx1613_pos) = rx1613_cur."from"()
    inc rx1613_pos
    rx1613_cur."!cursor_from"(rx1613_pos)
    ge rx1613_pos, rx1613_eos, rxscan1614_done
  rxscan1614_scan:
    set_addr $I10, rxscan1614_loop
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  rxscan1614_done:
  # rx literal  "my"
    add $I11, rx1613_pos, 2
    gt $I11, rx1613_eos, rx1613_fail
    sub $I11, rx1613_pos, rx1613_off
    substr $S10, rx1613_tgt, $I11, 2
    ne $S10, "my", rx1613_fail
    add rx1613_pos, 2
  # rx pass
    rx1613_cur."!cursor_pass"(rx1613_pos, "")
    if_null rx1613_debug, debug_1130
    rx1613_cur."!cursor_debug"("PASS", "", " at pos=", rx1613_pos)
  debug_1130:
    .return (rx1613_cur)
  rx1613_restart:
    if_null rx1613_debug, debug_1131
    rx1613_cur."!cursor_debug"("NEXT", "")
  debug_1131:
  rx1613_fail:
    (rx1613_rep, rx1613_pos, $I10, $P10) = rx1613_cur."!mark_fail"(0)
    lt rx1613_pos, -1, rx1613_done
    eq rx1613_pos, -1, rx1613_fail
    jump $I10
  rx1613_done:
    rx1613_cur."!cursor_fail"()
    if_null rx1613_debug, debug_1132
    rx1613_cur."!cursor_debug"("FAIL", "")
  debug_1132:
    .return (rx1613_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("382_1298839231.515") :method :outer("378_1298839231.515")
.annotate 'line', 662
    .local string rx1616_tgt
    .local int rx1616_pos
    .local int rx1616_off
    .local int rx1616_eos
    .local int rx1616_rep
    .local pmc rx1616_cur
    .local pmc rx1616_debug
    (rx1616_cur, rx1616_pos, rx1616_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1616_cur
    .local pmc match
    .lex "$/", match
    length rx1616_eos, rx1616_tgt
    gt rx1616_pos, rx1616_eos, rx1616_done
    set rx1616_off, 0
    lt rx1616_pos, 2, rx1616_start
    sub rx1616_off, rx1616_pos, 1
    substr rx1616_tgt, rx1616_tgt, rx1616_off
  rx1616_start:
    eq $I10, 1, rx1616_restart
    if_null rx1616_debug, debug_1136
    rx1616_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1619_done
    goto rxscan1619_scan
  rxscan1619_loop:
    (rx1616_pos) = rx1616_cur."from"()
    inc rx1616_pos
    rx1616_cur."!cursor_from"(rx1616_pos)
    ge rx1616_pos, rx1616_eos, rxscan1619_done
  rxscan1619_scan:
    set_addr $I10, rxscan1619_loop
    rx1616_cur."!mark_push"(0, rx1616_pos, $I10)
  rxscan1619_done:
.annotate 'line', 668
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1616_pos, rx1616_off
    substr $S10, rx1616_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1616_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1616_cur."!cursor_pos"(rx1616_pos)
    $P10 = rx1616_cur."codeblock"()
    unless $P10, rx1616_fail
    rx1616_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1616_pos = $P10."pos"()
.annotate 'line', 667
  # rx pass
    rx1616_cur."!cursor_pass"(rx1616_pos, "metachar:sym<{ }>")
    if_null rx1616_debug, debug_1137
    rx1616_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1616_pos)
  debug_1137:
    .return (rx1616_cur)
  rx1616_restart:
.annotate 'line', 662
    if_null rx1616_debug, debug_1138
    rx1616_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1138:
  rx1616_fail:
    (rx1616_rep, rx1616_pos, $I10, $P10) = rx1616_cur."!mark_fail"(0)
    lt rx1616_pos, -1, rx1616_done
    eq rx1616_pos, -1, rx1616_fail
    jump $I10
  rx1616_done:
    rx1616_cur."!cursor_fail"()
    if_null rx1616_debug, debug_1139
    rx1616_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1139:
    .return (rx1616_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("383_1298839231.515") :method
.annotate 'line', 662
    new $P1618, "ResizablePMCArray"
    push $P1618, "{"
    .return ($P1618)
.end


.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("384_1298839231.515") :method :outer("378_1298839231.515")
.annotate 'line', 662
    .const 'Sub' $P1626 = "386_1298839231.515" 
    capture_lex $P1626
    .local string rx1621_tgt
    .local int rx1621_pos
    .local int rx1621_off
    .local int rx1621_eos
    .local int rx1621_rep
    .local pmc rx1621_cur
    .local pmc rx1621_debug
    (rx1621_cur, rx1621_pos, rx1621_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1621_cur
    .local pmc match
    .lex "$/", match
    length rx1621_eos, rx1621_tgt
    gt rx1621_pos, rx1621_eos, rx1621_done
    set rx1621_off, 0
    lt rx1621_pos, 2, rx1621_start
    sub rx1621_off, rx1621_pos, 1
    substr rx1621_tgt, rx1621_tgt, rx1621_off
  rx1621_start:
    eq $I10, 1, rx1621_restart
    if_null rx1621_debug, debug_1140
    rx1621_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1624_done
    goto rxscan1624_scan
  rxscan1624_loop:
    (rx1621_pos) = rx1621_cur."from"()
    inc rx1621_pos
    rx1621_cur."!cursor_from"(rx1621_pos)
    ge rx1621_pos, rx1621_eos, rxscan1624_done
  rxscan1624_scan:
    set_addr $I10, rxscan1624_loop
    rx1621_cur."!mark_push"(0, rx1621_pos, $I10)
  rxscan1624_done:
.annotate 'line', 672
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1621_pos, rx1621_off
    substr $S10, rx1621_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1621_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1621_cur."!cursor_pos"(rx1621_pos)
    .const 'Sub' $P1626 = "386_1298839231.515" 
    capture_lex $P1626
    $P10 = rx1621_cur."before"($P1626)
    unless $P10, rx1621_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1621_cur."!cursor_pos"(rx1621_pos)
    $P10 = rx1621_cur."LANG"("MAIN", "variable")
    unless $P10, rx1621_fail
    rx1621_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1621_pos = $P10."pos"()
.annotate 'line', 671
  # rx pass
    rx1621_cur."!cursor_pass"(rx1621_pos, "metachar:sym<nqpvar>")
    if_null rx1621_debug, debug_1145
    rx1621_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1621_pos)
  debug_1145:
    .return (rx1621_cur)
  rx1621_restart:
.annotate 'line', 662
    if_null rx1621_debug, debug_1146
    rx1621_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1146:
  rx1621_fail:
    (rx1621_rep, rx1621_pos, $I10, $P10) = rx1621_cur."!mark_fail"(0)
    lt rx1621_pos, -1, rx1621_done
    eq rx1621_pos, -1, rx1621_fail
    jump $I10
  rx1621_done:
    rx1621_cur."!cursor_fail"()
    if_null rx1621_debug, debug_1147
    rx1621_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1147:
    .return (rx1621_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("385_1298839231.515") :method
.annotate 'line', 662
    new $P1623, "ResizablePMCArray"
    push $P1623, "$"
    push $P1623, "@"
    .return ($P1623)
.end


.namespace ["NQP";"Regex"]
.sub "_block1625"  :anon :subid("386_1298839231.515") :method :outer("384_1298839231.515")
.annotate 'line', 672
    .local string rx1627_tgt
    .local int rx1627_pos
    .local int rx1627_off
    .local int rx1627_eos
    .local int rx1627_rep
    .local pmc rx1627_cur
    .local pmc rx1627_debug
    (rx1627_cur, rx1627_pos, rx1627_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1627_cur
    .local pmc match
    .lex "$/", match
    length rx1627_eos, rx1627_tgt
    gt rx1627_pos, rx1627_eos, rx1627_done
    set rx1627_off, 0
    lt rx1627_pos, 2, rx1627_start
    sub rx1627_off, rx1627_pos, 1
    substr rx1627_tgt, rx1627_tgt, rx1627_off
  rx1627_start:
    eq $I10, 1, rx1627_restart
    if_null rx1627_debug, debug_1141
    rx1627_cur."!cursor_debug"("START", "")
  debug_1141:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1628_done
    goto rxscan1628_scan
  rxscan1628_loop:
    (rx1627_pos) = rx1627_cur."from"()
    inc rx1627_pos
    rx1627_cur."!cursor_from"(rx1627_pos)
    ge rx1627_pos, rx1627_eos, rxscan1628_done
  rxscan1628_scan:
    set_addr $I10, rxscan1628_loop
    rx1627_cur."!mark_push"(0, rx1627_pos, $I10)
  rxscan1628_done:
  # rx charclass .
    ge rx1627_pos, rx1627_eos, rx1627_fail
    inc rx1627_pos
  # rx charclass w
    ge rx1627_pos, rx1627_eos, rx1627_fail
    sub $I10, rx1627_pos, rx1627_off
    is_cclass $I11, 8192, rx1627_tgt, $I10
    unless $I11, rx1627_fail
    inc rx1627_pos
  # rx pass
    rx1627_cur."!cursor_pass"(rx1627_pos, "")
    if_null rx1627_debug, debug_1142
    rx1627_cur."!cursor_debug"("PASS", "", " at pos=", rx1627_pos)
  debug_1142:
    .return (rx1627_cur)
  rx1627_restart:
    if_null rx1627_debug, debug_1143
    rx1627_cur."!cursor_debug"("NEXT", "")
  debug_1143:
  rx1627_fail:
    (rx1627_rep, rx1627_pos, $I10, $P10) = rx1627_cur."!mark_fail"(0)
    lt rx1627_pos, -1, rx1627_done
    eq rx1627_pos, -1, rx1627_fail
    jump $I10
  rx1627_done:
    rx1627_cur."!cursor_fail"()
    if_null rx1627_debug, debug_1144
    rx1627_cur."!cursor_debug"("FAIL", "")
  debug_1144:
    .return (rx1627_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("387_1298839231.515") :method :outer("378_1298839231.515")
.annotate 'line', 662
    .local string rx1630_tgt
    .local int rx1630_pos
    .local int rx1630_off
    .local int rx1630_eos
    .local int rx1630_rep
    .local pmc rx1630_cur
    .local pmc rx1630_debug
    (rx1630_cur, rx1630_pos, rx1630_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1630_cur
    .local pmc match
    .lex "$/", match
    length rx1630_eos, rx1630_tgt
    gt rx1630_pos, rx1630_eos, rx1630_done
    set rx1630_off, 0
    lt rx1630_pos, 2, rx1630_start
    sub rx1630_off, rx1630_pos, 1
    substr rx1630_tgt, rx1630_tgt, rx1630_off
  rx1630_start:
    eq $I10, 1, rx1630_restart
    if_null rx1630_debug, debug_1148
    rx1630_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1633_done
    goto rxscan1633_scan
  rxscan1633_loop:
    (rx1630_pos) = rx1630_cur."from"()
    inc rx1630_pos
    rx1630_cur."!cursor_from"(rx1630_pos)
    ge rx1630_pos, rx1630_eos, rxscan1633_done
  rxscan1633_scan:
    set_addr $I10, rxscan1633_loop
    rx1630_cur."!mark_push"(0, rx1630_pos, $I10)
  rxscan1633_done:
.annotate 'line', 676
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1630_pos, rx1630_off
    substr $S10, rx1630_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1630_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1630_cur."!cursor_pos"(rx1630_pos)
    $P10 = rx1630_cur."codeblock"()
    unless $P10, rx1630_fail
    rx1630_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1630_pos = $P10."pos"()
.annotate 'line', 675
  # rx pass
    rx1630_cur."!cursor_pass"(rx1630_pos, "assertion:sym<{ }>")
    if_null rx1630_debug, debug_1149
    rx1630_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1630_pos)
  debug_1149:
    .return (rx1630_cur)
  rx1630_restart:
.annotate 'line', 662
    if_null rx1630_debug, debug_1150
    rx1630_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1150:
  rx1630_fail:
    (rx1630_rep, rx1630_pos, $I10, $P10) = rx1630_cur."!mark_fail"(0)
    lt rx1630_pos, -1, rx1630_done
    eq rx1630_pos, -1, rx1630_fail
    jump $I10
  rx1630_done:
    rx1630_cur."!cursor_fail"()
    if_null rx1630_debug, debug_1151
    rx1630_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1151:
    .return (rx1630_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("388_1298839231.515") :method
.annotate 'line', 662
    new $P1632, "ResizablePMCArray"
    push $P1632, "{"
    .return ($P1632)
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("389_1298839231.515") :method :outer("378_1298839231.515")
.annotate 'line', 662
    .const 'Sub' $P1640 = "391_1298839231.515" 
    capture_lex $P1640
    .local string rx1635_tgt
    .local int rx1635_pos
    .local int rx1635_off
    .local int rx1635_eos
    .local int rx1635_rep
    .local pmc rx1635_cur
    .local pmc rx1635_debug
    (rx1635_cur, rx1635_pos, rx1635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1635_cur
    .local pmc match
    .lex "$/", match
    length rx1635_eos, rx1635_tgt
    gt rx1635_pos, rx1635_eos, rx1635_done
    set rx1635_off, 0
    lt rx1635_pos, 2, rx1635_start
    sub rx1635_off, rx1635_pos, 1
    substr rx1635_tgt, rx1635_tgt, rx1635_off
  rx1635_start:
    eq $I10, 1, rx1635_restart
    if_null rx1635_debug, debug_1152
    rx1635_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1638_done
    goto rxscan1638_scan
  rxscan1638_loop:
    (rx1635_pos) = rx1635_cur."from"()
    inc rx1635_pos
    rx1635_cur."!cursor_from"(rx1635_pos)
    ge rx1635_pos, rx1635_eos, rxscan1638_done
  rxscan1638_scan:
    set_addr $I10, rxscan1638_loop
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  rxscan1638_done:
.annotate 'line', 680
  # rx subcapture "zw"
    set_addr $I10, rxcap_1643_fail
    rx1635_cur."!mark_push"(0, rx1635_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1635_pos, rx1635_eos, rx1635_fail
    sub $I10, rx1635_pos, rx1635_off
    substr $S10, rx1635_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1635_fail
    inc rx1635_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    .const 'Sub' $P1640 = "391_1298839231.515" 
    capture_lex $P1640
    $P10 = rx1635_cur."before"($P1640)
    unless $P10, rx1635_fail
    set_addr $I10, rxcap_1643_fail
    ($I12, $I11) = rx1635_cur."!mark_peek"($I10)
    rx1635_cur."!cursor_pos"($I11)
    ($P10) = rx1635_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1635_pos, "")
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1643_done
  rxcap_1643_fail:
    goto rx1635_fail
  rxcap_1643_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1635_cur."!cursor_pos"(rx1635_pos)
    $P10 = rx1635_cur."codeblock"()
    unless $P10, rx1635_fail
    rx1635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1635_pos = $P10."pos"()
.annotate 'line', 679
  # rx pass
    rx1635_cur."!cursor_pass"(rx1635_pos, "assertion:sym<?{ }>")
    if_null rx1635_debug, debug_1157
    rx1635_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1635_pos)
  debug_1157:
    .return (rx1635_cur)
  rx1635_restart:
.annotate 'line', 662
    if_null rx1635_debug, debug_1158
    rx1635_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1158:
  rx1635_fail:
    (rx1635_rep, rx1635_pos, $I10, $P10) = rx1635_cur."!mark_fail"(0)
    lt rx1635_pos, -1, rx1635_done
    eq rx1635_pos, -1, rx1635_fail
    jump $I10
  rx1635_done:
    rx1635_cur."!cursor_fail"()
    if_null rx1635_debug, debug_1159
    rx1635_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1159:
    .return (rx1635_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("390_1298839231.515") :method
.annotate 'line', 662
    new $P1637, "ResizablePMCArray"
    push $P1637, "!"
    push $P1637, "?"
    .return ($P1637)
.end


.namespace ["NQP";"Regex"]
.sub "_block1639"  :anon :subid("391_1298839231.515") :method :outer("389_1298839231.515")
.annotate 'line', 680
    .local string rx1641_tgt
    .local int rx1641_pos
    .local int rx1641_off
    .local int rx1641_eos
    .local int rx1641_rep
    .local pmc rx1641_cur
    .local pmc rx1641_debug
    (rx1641_cur, rx1641_pos, rx1641_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1641_cur
    .local pmc match
    .lex "$/", match
    length rx1641_eos, rx1641_tgt
    gt rx1641_pos, rx1641_eos, rx1641_done
    set rx1641_off, 0
    lt rx1641_pos, 2, rx1641_start
    sub rx1641_off, rx1641_pos, 1
    substr rx1641_tgt, rx1641_tgt, rx1641_off
  rx1641_start:
    eq $I10, 1, rx1641_restart
    if_null rx1641_debug, debug_1153
    rx1641_cur."!cursor_debug"("START", "")
  debug_1153:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1642_done
    goto rxscan1642_scan
  rxscan1642_loop:
    (rx1641_pos) = rx1641_cur."from"()
    inc rx1641_pos
    rx1641_cur."!cursor_from"(rx1641_pos)
    ge rx1641_pos, rx1641_eos, rxscan1642_done
  rxscan1642_scan:
    set_addr $I10, rxscan1642_loop
    rx1641_cur."!mark_push"(0, rx1641_pos, $I10)
  rxscan1642_done:
  # rx literal  "{"
    add $I11, rx1641_pos, 1
    gt $I11, rx1641_eos, rx1641_fail
    sub $I11, rx1641_pos, rx1641_off
    ord $I11, rx1641_tgt, $I11
    ne $I11, 123, rx1641_fail
    add rx1641_pos, 1
  # rx pass
    rx1641_cur."!cursor_pass"(rx1641_pos, "")
    if_null rx1641_debug, debug_1154
    rx1641_cur."!cursor_debug"("PASS", "", " at pos=", rx1641_pos)
  debug_1154:
    .return (rx1641_cur)
  rx1641_restart:
    if_null rx1641_debug, debug_1155
    rx1641_cur."!cursor_debug"("NEXT", "")
  debug_1155:
  rx1641_fail:
    (rx1641_rep, rx1641_pos, $I10, $P10) = rx1641_cur."!mark_fail"(0)
    lt rx1641_pos, -1, rx1641_done
    eq rx1641_pos, -1, rx1641_fail
    jump $I10
  rx1641_done:
    rx1641_cur."!cursor_fail"()
    if_null rx1641_debug, debug_1156
    rx1641_cur."!cursor_debug"("FAIL", "")
  debug_1156:
    .return (rx1641_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("392_1298839231.515") :method :outer("378_1298839231.515")
.annotate 'line', 662
    .const 'Sub' $P1653 = "394_1298839231.515" 
    capture_lex $P1653
    .local string rx1645_tgt
    .local int rx1645_pos
    .local int rx1645_off
    .local int rx1645_eos
    .local int rx1645_rep
    .local pmc rx1645_cur
    .local pmc rx1645_debug
    (rx1645_cur, rx1645_pos, rx1645_tgt, $I10) = self."!cursor_start"()
    rx1645_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1645_cur
    .local pmc match
    .lex "$/", match
    length rx1645_eos, rx1645_tgt
    gt rx1645_pos, rx1645_eos, rx1645_done
    set rx1645_off, 0
    lt rx1645_pos, 2, rx1645_start
    sub rx1645_off, rx1645_pos, 1
    substr rx1645_tgt, rx1645_tgt, rx1645_off
  rx1645_start:
    eq $I10, 1, rx1645_restart
    if_null rx1645_debug, debug_1160
    rx1645_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1649_done
    goto rxscan1649_scan
  rxscan1649_loop:
    (rx1645_pos) = rx1645_cur."from"()
    inc rx1645_pos
    rx1645_cur."!cursor_from"(rx1645_pos)
    ge rx1645_pos, rx1645_eos, rxscan1649_done
  rxscan1649_scan:
    set_addr $I10, rxscan1649_loop
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  rxscan1649_done:
.annotate 'line', 684
  # rx subrule "identifier" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."identifier"()
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1645_pos = $P10."pos"()
.annotate 'line', 691
  # rx rxquantr1650 ** 0..1
    set_addr $I10, rxquantr1650_done
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
  rxquantr1650_loop:
  alt1651_0:
.annotate 'line', 685
    set_addr $I10, alt1651_1
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
.annotate 'line', 686
  # rx subrule "before" subtype=zerowidth negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    .const 'Sub' $P1653 = "394_1298839231.515" 
    capture_lex $P1653
    $P10 = rx1645_cur."before"($P1653)
    unless $P10, rx1645_fail
    goto alt1651_end
  alt1651_1:
    set_addr $I10, alt1651_2
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
.annotate 'line', 687
  # rx literal  "="
    add $I11, rx1645_pos, 1
    gt $I11, rx1645_eos, rx1645_fail
    sub $I11, rx1645_pos, rx1645_off
    ord $I11, rx1645_tgt, $I11
    ne $I11, 61, rx1645_fail
    add rx1645_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."assertion"()
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1645_pos = $P10."pos"()
    goto alt1651_end
  alt1651_2:
    set_addr $I10, alt1651_3
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
.annotate 'line', 688
  # rx literal  ":"
    add $I11, rx1645_pos, 1
    gt $I11, rx1645_eos, rx1645_fail
    sub $I11, rx1645_pos, rx1645_off
    ord $I11, rx1645_tgt, $I11
    ne $I11, 58, rx1645_fail
    add rx1645_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."arglist"()
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1645_pos = $P10."pos"()
    goto alt1651_end
  alt1651_3:
    set_addr $I10, alt1651_4
    rx1645_cur."!mark_push"(0, rx1645_pos, $I10)
.annotate 'line', 689
  # rx literal  "("
    add $I11, rx1645_pos, 1
    gt $I11, rx1645_eos, rx1645_fail
    sub $I11, rx1645_pos, rx1645_off
    ord $I11, rx1645_tgt, $I11
    ne $I11, 40, rx1645_fail
    add rx1645_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1645_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1645_pos, 1
    gt $I11, rx1645_eos, rx1645_fail
    sub $I11, rx1645_pos, rx1645_off
    ord $I11, rx1645_tgt, $I11
    ne $I11, 41, rx1645_fail
    add rx1645_pos, 1
    goto alt1651_end
  alt1651_4:
.annotate 'line', 690
  # rx subrule "normspace" subtype=method negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."normspace"()
    unless $P10, rx1645_fail
    rx1645_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1645_cur."!cursor_pos"(rx1645_pos)
    $P10 = rx1645_cur."nibbler"()
    unless $P10, rx1645_fail
    rx1645_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1645_pos = $P10."pos"()
  alt1651_end:
.annotate 'line', 691
    set_addr $I10, rxquantr1650_done
    (rx1645_rep) = rx1645_cur."!mark_commit"($I10)
  rxquantr1650_done:
.annotate 'line', 683
  # rx pass
    rx1645_cur."!cursor_pass"(rx1645_pos, "assertion:sym<name>")
    if_null rx1645_debug, debug_1165
    rx1645_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1645_pos)
  debug_1165:
    .return (rx1645_cur)
  rx1645_restart:
.annotate 'line', 662
    if_null rx1645_debug, debug_1166
    rx1645_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1166:
  rx1645_fail:
    (rx1645_rep, rx1645_pos, $I10, $P10) = rx1645_cur."!mark_fail"(0)
    lt rx1645_pos, -1, rx1645_done
    eq rx1645_pos, -1, rx1645_fail
    jump $I10
  rx1645_done:
    rx1645_cur."!cursor_fail"()
    if_null rx1645_debug, debug_1167
    rx1645_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1167:
    .return (rx1645_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("393_1298839231.515") :method
.annotate 'line', 662
    $P1647 = self."!PREFIX__!subrule"("identifier", "")
    new $P1648, "ResizablePMCArray"
    push $P1648, $P1647
    .return ($P1648)
.end


.namespace ["NQP";"Regex"]
.sub "_block1652"  :anon :subid("394_1298839231.515") :method :outer("392_1298839231.515")
.annotate 'line', 686
    .local string rx1654_tgt
    .local int rx1654_pos
    .local int rx1654_off
    .local int rx1654_eos
    .local int rx1654_rep
    .local pmc rx1654_cur
    .local pmc rx1654_debug
    (rx1654_cur, rx1654_pos, rx1654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1654_cur
    .local pmc match
    .lex "$/", match
    length rx1654_eos, rx1654_tgt
    gt rx1654_pos, rx1654_eos, rx1654_done
    set rx1654_off, 0
    lt rx1654_pos, 2, rx1654_start
    sub rx1654_off, rx1654_pos, 1
    substr rx1654_tgt, rx1654_tgt, rx1654_off
  rx1654_start:
    eq $I10, 1, rx1654_restart
    if_null rx1654_debug, debug_1161
    rx1654_cur."!cursor_debug"("START", "")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1654_pos) = rx1654_cur."from"()
    inc rx1654_pos
    rx1654_cur."!cursor_from"(rx1654_pos)
    ge rx1654_pos, rx1654_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  rxscan1655_done:
  # rx literal  ">"
    add $I11, rx1654_pos, 1
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    ord $I11, rx1654_tgt, $I11
    ne $I11, 62, rx1654_fail
    add rx1654_pos, 1
  # rx pass
    rx1654_cur."!cursor_pass"(rx1654_pos, "")
    if_null rx1654_debug, debug_1162
    rx1654_cur."!cursor_debug"("PASS", "", " at pos=", rx1654_pos)
  debug_1162:
    .return (rx1654_cur)
  rx1654_restart:
    if_null rx1654_debug, debug_1163
    rx1654_cur."!cursor_debug"("NEXT", "")
  debug_1163:
  rx1654_fail:
    (rx1654_rep, rx1654_pos, $I10, $P10) = rx1654_cur."!mark_fail"(0)
    lt rx1654_pos, -1, rx1654_done
    eq rx1654_pos, -1, rx1654_fail
    jump $I10
  rx1654_done:
    rx1654_cur."!cursor_fail"()
    if_null rx1654_debug, debug_1164
    rx1654_cur."!cursor_debug"("FAIL", "")
  debug_1164:
    .return (rx1654_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("395_1298839231.515") :method :outer("378_1298839231.515")
.annotate 'line', 662
    .local string rx1657_tgt
    .local int rx1657_pos
    .local int rx1657_off
    .local int rx1657_eos
    .local int rx1657_rep
    .local pmc rx1657_cur
    .local pmc rx1657_debug
    (rx1657_cur, rx1657_pos, rx1657_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1657_cur
    .local pmc match
    .lex "$/", match
    length rx1657_eos, rx1657_tgt
    gt rx1657_pos, rx1657_eos, rx1657_done
    set rx1657_off, 0
    lt rx1657_pos, 2, rx1657_start
    sub rx1657_off, rx1657_pos, 1
    substr rx1657_tgt, rx1657_tgt, rx1657_off
  rx1657_start:
    eq $I10, 1, rx1657_restart
    if_null rx1657_debug, debug_1168
    rx1657_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1168:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1660_done
    goto rxscan1660_scan
  rxscan1660_loop:
    (rx1657_pos) = rx1657_cur."from"()
    inc rx1657_pos
    rx1657_cur."!cursor_from"(rx1657_pos)
    ge rx1657_pos, rx1657_eos, rxscan1660_done
  rxscan1660_scan:
    set_addr $I10, rxscan1660_loop
    rx1657_cur."!mark_push"(0, rx1657_pos, $I10)
  rxscan1660_done:
.annotate 'line', 695
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1657_pos, rx1657_off
    substr $S10, rx1657_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1657_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1657_cur."!cursor_pos"(rx1657_pos)
    $P10 = rx1657_cur."LANG"("MAIN", "variable")
    unless $P10, rx1657_fail
    rx1657_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1657_pos = $P10."pos"()
.annotate 'line', 694
  # rx pass
    rx1657_cur."!cursor_pass"(rx1657_pos, "assertion:sym<var>")
    if_null rx1657_debug, debug_1169
    rx1657_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1657_pos)
  debug_1169:
    .return (rx1657_cur)
  rx1657_restart:
.annotate 'line', 662
    if_null rx1657_debug, debug_1170
    rx1657_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1170:
  rx1657_fail:
    (rx1657_rep, rx1657_pos, $I10, $P10) = rx1657_cur."!mark_fail"(0)
    lt rx1657_pos, -1, rx1657_done
    eq rx1657_pos, -1, rx1657_fail
    jump $I10
  rx1657_done:
    rx1657_cur."!cursor_fail"()
    if_null rx1657_debug, debug_1171
    rx1657_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1171:
    .return (rx1657_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("396_1298839231.515") :method
.annotate 'line', 662
    new $P1659, "ResizablePMCArray"
    push $P1659, "$"
    push $P1659, "@"
    .return ($P1659)
.end


.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("397_1298839231.515") :method :outer("378_1298839231.515")
.annotate 'line', 662
    .local string rx1662_tgt
    .local int rx1662_pos
    .local int rx1662_off
    .local int rx1662_eos
    .local int rx1662_rep
    .local pmc rx1662_cur
    .local pmc rx1662_debug
    (rx1662_cur, rx1662_pos, rx1662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1662_cur
    .local pmc match
    .lex "$/", match
    length rx1662_eos, rx1662_tgt
    gt rx1662_pos, rx1662_eos, rx1662_done
    set rx1662_off, 0
    lt rx1662_pos, 2, rx1662_start
    sub rx1662_off, rx1662_pos, 1
    substr rx1662_tgt, rx1662_tgt, rx1662_off
  rx1662_start:
    eq $I10, 1, rx1662_restart
    if_null rx1662_debug, debug_1172
    rx1662_cur."!cursor_debug"("START", "codeblock")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1666_done
    goto rxscan1666_scan
  rxscan1666_loop:
    (rx1662_pos) = rx1662_cur."from"()
    inc rx1662_pos
    rx1662_cur."!cursor_from"(rx1662_pos)
    ge rx1662_pos, rx1662_eos, rxscan1666_done
  rxscan1666_scan:
    set_addr $I10, rxscan1666_loop
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxscan1666_done:
.annotate 'line', 699
  # rx subrule "LANG" subtype=capture negate=
    rx1662_cur."!cursor_pos"(rx1662_pos)
    $P10 = rx1662_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1662_fail
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1662_pos = $P10."pos"()
.annotate 'line', 698
  # rx pass
    rx1662_cur."!cursor_pass"(rx1662_pos, "codeblock")
    if_null rx1662_debug, debug_1173
    rx1662_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1662_pos)
  debug_1173:
    .return (rx1662_cur)
  rx1662_restart:
.annotate 'line', 662
    if_null rx1662_debug, debug_1174
    rx1662_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1174:
  rx1662_fail:
    (rx1662_rep, rx1662_pos, $I10, $P10) = rx1662_cur."!mark_fail"(0)
    lt rx1662_pos, -1, rx1662_done
    eq rx1662_pos, -1, rx1662_fail
    jump $I10
  rx1662_done:
    rx1662_cur."!cursor_fail"()
    if_null rx1662_debug, debug_1175
    rx1662_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1175:
    .return (rx1662_cur)
    .return ()
.end


.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("398_1298839231.515") :method
.annotate 'line', 662
    $P1664 = self."!PREFIX__!subrule"("LANG", "")
    new $P1665, "ResizablePMCArray"
    push $P1665, $P1664
    .return ($P1665)
.end


.namespace ["NQP";"Grammar"]
.sub "_block1708" :load :anon :subid("400_1298839231.515")
.annotate 'line', 4
    .const 'Sub' $P1710 = "11_1298839231.515" 
    $P1711 = $P1710()
    .return ($P1711)
.end


.namespace []
.sub "_block2429" :load :anon :subid("402_1298839231.515")
.annotate 'line', 1
    .const 'Sub' $P2431 = "10_1298839231.515" 
    $P2432 = $P2431()
    .return ($P2432)
.end

### .include 'gen/nqp-actions.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298839287.218")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
    $P3233 = $P15()
.annotate 'line', 1
    .return ($P3233)
    .const 'Sub' $P3235 = "170_1298839287.218" 
    .return ($P3235)
.end


.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block14"  :subid("11_1298839287.218") :outer("10_1298839287.218")
.annotate 'line', 3
    .const 'Sub' $P3012 = "169_1298839287.218" 
    capture_lex $P3012
    get_hll_global $P2886, ["NQP";"RegexActions"], "_block2885" 
    capture_lex $P2886
    .const 'Sub' $P2877 = "158_1298839287.218" 
    capture_lex $P2877
    .const 'Sub' $P2872 = "157_1298839287.218" 
    capture_lex $P2872
    .const 'Sub' $P2867 = "156_1298839287.218" 
    capture_lex $P2867
    .const 'Sub' $P2862 = "155_1298839287.218" 
    capture_lex $P2862
    .const 'Sub' $P2851 = "154_1298839287.218" 
    capture_lex $P2851
    .const 'Sub' $P2843 = "153_1298839287.218" 
    capture_lex $P2843
    .const 'Sub' $P2835 = "152_1298839287.218" 
    capture_lex $P2835
    .const 'Sub' $P2827 = "151_1298839287.218" 
    capture_lex $P2827
    .const 'Sub' $P2822 = "150_1298839287.218" 
    capture_lex $P2822
    .const 'Sub' $P2810 = "149_1298839287.218" 
    capture_lex $P2810
    .const 'Sub' $P2802 = "148_1298839287.218" 
    capture_lex $P2802
    .const 'Sub' $P2764 = "147_1298839287.218" 
    capture_lex $P2764
    .const 'Sub' $P2752 = "146_1298839287.218" 
    capture_lex $P2752
    .const 'Sub' $P2744 = "145_1298839287.218" 
    capture_lex $P2744
    .const 'Sub' $P2736 = "144_1298839287.218" 
    capture_lex $P2736
    .const 'Sub' $P2728 = "143_1298839287.218" 
    capture_lex $P2728
    .const 'Sub' $P2720 = "142_1298839287.218" 
    capture_lex $P2720
    .const 'Sub' $P2712 = "141_1298839287.218" 
    capture_lex $P2712
    .const 'Sub' $P2686 = "140_1298839287.218" 
    capture_lex $P2686
    .const 'Sub' $P2671 = "139_1298839287.218" 
    capture_lex $P2671
    .const 'Sub' $P2663 = "138_1298839287.218" 
    capture_lex $P2663
    .const 'Sub' $P2652 = "137_1298839287.218" 
    capture_lex $P2652
    .const 'Sub' $P2641 = "136_1298839287.218" 
    capture_lex $P2641
    .const 'Sub' $P2630 = "135_1298839287.218" 
    capture_lex $P2630
    .const 'Sub' $P2622 = "134_1298839287.218" 
    capture_lex $P2622
    .const 'Sub' $P2595 = "133_1298839287.218" 
    capture_lex $P2595
    .const 'Sub' $P2573 = "132_1298839287.218" 
    capture_lex $P2573
    .const 'Sub' $P2565 = "131_1298839287.218" 
    capture_lex $P2565
    .const 'Sub' $P2557 = "130_1298839287.218" 
    capture_lex $P2557
    .const 'Sub' $P2532 = "129_1298839287.218" 
    capture_lex $P2532
    .const 'Sub' $P2516 = "128_1298839287.218" 
    capture_lex $P2516
    .const 'Sub' $P2508 = "127_1298839287.218" 
    capture_lex $P2508
    .const 'Sub' $P2500 = "126_1298839287.218" 
    capture_lex $P2500
    .const 'Sub' $P2398 = "123_1298839287.218" 
    capture_lex $P2398
    .const 'Sub' $P2390 = "122_1298839287.218" 
    capture_lex $P2390
    .const 'Sub' $P2383 = "121_1298839287.218" 
    capture_lex $P2383
    .const 'Sub' $P2356 = "120_1298839287.218" 
    capture_lex $P2356
    .const 'Sub' $P2316 = "119_1298839287.218" 
    capture_lex $P2316
    .const 'Sub' $P2302 = "118_1298839287.218" 
    capture_lex $P2302
    .const 'Sub' $P2295 = "117_1298839287.218" 
    capture_lex $P2295
    .const 'Sub' $P2251 = "116_1298839287.218" 
    capture_lex $P2251
    .const 'Sub' $P2086 = "112_1298839287.218" 
    capture_lex $P2086
    .const 'Sub' $P2023 = "110_1298839287.218" 
    capture_lex $P2023
    .const 'Sub' $P2015 = "109_1298839287.218" 
    capture_lex $P2015
    .const 'Sub' $P2000 = "108_1298839287.218" 
    capture_lex $P2000
    .const 'Sub' $P1985 = "107_1298839287.218" 
    capture_lex $P1985
    .const 'Sub' $P1967 = "106_1298839287.218" 
    capture_lex $P1967
    .const 'Sub' $P1868 = "105_1298839287.218" 
    capture_lex $P1868
    .const 'Sub' $P1824 = "102_1298839287.218" 
    capture_lex $P1824
    .const 'Sub' $P1699 = "99_1298839287.218" 
    capture_lex $P1699
    .const 'Sub' $P1457 = "92_1298839287.218" 
    capture_lex $P1457
    .const 'Sub' $P1449 = "91_1298839287.218" 
    capture_lex $P1449
    .const 'Sub' $P1441 = "90_1298839287.218" 
    capture_lex $P1441
    .const 'Sub' $P1340 = "86_1298839287.218" 
    capture_lex $P1340
    .const 'Sub' $P1332 = "85_1298839287.218" 
    capture_lex $P1332
    .const 'Sub' $P1317 = "84_1298839287.218" 
    capture_lex $P1317
    .const 'Sub' $P1302 = "83_1298839287.218" 
    capture_lex $P1302
    .const 'Sub' $P1287 = "82_1298839287.218" 
    capture_lex $P1287
    .const 'Sub' $P1272 = "81_1298839287.218" 
    capture_lex $P1272
    .const 'Sub' $P1264 = "80_1298839287.218" 
    capture_lex $P1264
    .const 'Sub' $P1256 = "79_1298839287.218" 
    capture_lex $P1256
    .const 'Sub' $P1248 = "78_1298839287.218" 
    capture_lex $P1248
    .const 'Sub' $P1034 = "74_1298839287.218" 
    capture_lex $P1034
    .const 'Sub' $P1026 = "73_1298839287.218" 
    capture_lex $P1026
    .const 'Sub' $P1018 = "72_1298839287.218" 
    capture_lex $P1018
    .const 'Sub' $P1010 = "71_1298839287.218" 
    capture_lex $P1010
    .const 'Sub' $P1002 = "70_1298839287.218" 
    capture_lex $P1002
    .const 'Sub' $P994 = "69_1298839287.218" 
    capture_lex $P994
    .const 'Sub' $P986 = "68_1298839287.218" 
    capture_lex $P986
    .const 'Sub' $P896 = "66_1298839287.218" 
    capture_lex $P896
    .const 'Sub' $P872 = "65_1298839287.218" 
    capture_lex $P872
    .const 'Sub' $P858 = "64_1298839287.218" 
    capture_lex $P858
    .const 'Sub' $P850 = "63_1298839287.218" 
    capture_lex $P850
    .const 'Sub' $P842 = "62_1298839287.218" 
    capture_lex $P842
    .const 'Sub' $P834 = "61_1298839287.218" 
    capture_lex $P834
    .const 'Sub' $P826 = "60_1298839287.218" 
    capture_lex $P826
    .const 'Sub' $P818 = "59_1298839287.218" 
    capture_lex $P818
    .const 'Sub' $P810 = "58_1298839287.218" 
    capture_lex $P810
    .const 'Sub' $P802 = "57_1298839287.218" 
    capture_lex $P802
    .const 'Sub' $P794 = "56_1298839287.218" 
    capture_lex $P794
    .const 'Sub' $P786 = "55_1298839287.218" 
    capture_lex $P786
    .const 'Sub' $P778 = "54_1298839287.218" 
    capture_lex $P778
    .const 'Sub' $P770 = "53_1298839287.218" 
    capture_lex $P770
    .const 'Sub' $P762 = "52_1298839287.218" 
    capture_lex $P762
    .const 'Sub' $P754 = "51_1298839287.218" 
    capture_lex $P754
    .const 'Sub' $P738 = "50_1298839287.218" 
    capture_lex $P738
    .const 'Sub' $P705 = "49_1298839287.218" 
    capture_lex $P705
    .const 'Sub' $P691 = "48_1298839287.218" 
    capture_lex $P691
    .const 'Sub' $P672 = "47_1298839287.218" 
    capture_lex $P672
    .const 'Sub' $P654 = "46_1298839287.218" 
    capture_lex $P654
    .const 'Sub' $P630 = "45_1298839287.218" 
    capture_lex $P630
    .const 'Sub' $P596 = "44_1298839287.218" 
    capture_lex $P596
    .const 'Sub' $P581 = "43_1298839287.218" 
    capture_lex $P581
    .const 'Sub' $P569 = "42_1298839287.218" 
    capture_lex $P569
    .const 'Sub' $P518 = "40_1298839287.218" 
    capture_lex $P518
    .const 'Sub' $P511 = "39_1298839287.218" 
    capture_lex $P511
    .const 'Sub' $P502 = "38_1298839287.218" 
    capture_lex $P502
    .const 'Sub' $P491 = "37_1298839287.218" 
    capture_lex $P491
    .const 'Sub' $P461 = "35_1298839287.218" 
    capture_lex $P461
    .const 'Sub' $P453 = "34_1298839287.218" 
    capture_lex $P453
    .const 'Sub' $P445 = "33_1298839287.218" 
    capture_lex $P445
    .const 'Sub' $P431 = "32_1298839287.218" 
    capture_lex $P431
    .const 'Sub' $P350 = "30_1298839287.218" 
    capture_lex $P350
    .const 'Sub' $P309 = "28_1298839287.218" 
    capture_lex $P309
    .const 'Sub' $P275 = "27_1298839287.218" 
    capture_lex $P275
    .const 'Sub' $P244 = "26_1298839287.218" 
    capture_lex $P244
    .const 'Sub' $P236 = "25_1298839287.218" 
    capture_lex $P236
    .const 'Sub' $P228 = "23_1298839287.218" 
    capture_lex $P228
    .const 'Sub' $P214 = "22_1298839287.218" 
    capture_lex $P214
    .const 'Sub' $P149 = "20_1298839287.218" 
    capture_lex $P149
    .const 'Sub' $P139 = "19_1298839287.218" 
    capture_lex $P139
    .const 'Sub' $P91 = "18_1298839287.218" 
    capture_lex $P91
    .const 'Sub' $P78 = "17_1298839287.218" 
    capture_lex $P78
    .const 'Sub' $P60 = "16_1298839287.218" 
    capture_lex $P60
    .const 'Sub' $P27 = "13_1298839287.218" 
    capture_lex $P27
    .const 'Sub' $P19 = "12_1298839287.218" 
    capture_lex $P19
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "RegexActions"
    get_global $P18, "@BLOCK"
    unless_null $P18, vivify_172
    $P18 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P18
  vivify_172:
.annotate 'line', 9
    .const 'Sub' $P19 = "12_1298839287.218" 
    newclosure $P26, $P19
    .lex "xblock_immediate", $P26
.annotate 'line', 14
    .const 'Sub' $P27 = "13_1298839287.218" 
    newclosure $P59, $P27
    .lex "block_immediate", $P59
.annotate 'line', 24
    .const 'Sub' $P60 = "16_1298839287.218" 
    newclosure $P77, $P60
    .lex "vivitype", $P77
.annotate 'line', 43
    .const 'Sub' $P78 = "17_1298839287.218" 
    newclosure $P90, $P78
    .lex "colonpair_str", $P90
.annotate 'line', 232
    .const 'Sub' $P91 = "18_1298839287.218" 
    newclosure $P138, $P91
    .lex "push_block_handler", $P138
.annotate 'line', 771
    .const 'Sub' $P139 = "19_1298839287.218" 
    newclosure $P148, $P139
    .lex "only_star_block", $P148
.annotate 'line', 780
    .const 'Sub' $P149 = "20_1298839287.218" 
    newclosure $P213, $P149
    .lex "attach_multi_signature", $P213
.annotate 'line', 1250
    .const 'Sub' $P214 = "22_1298839287.218" 
    newclosure $P225, $P214
    .lex "control", $P225
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P226, "@BLOCK"
    .const 'Sub' $P228 = "23_1298839287.218" 
    capture_lex $P228
    $P228()
    find_lex $P233, "xblock_immediate"
    find_lex $P234, "block_immediate"
    find_lex $P235, "vivitype"
.annotate 'line', 35
    find_lex $P274, "colonpair_str"
.annotate 'line', 225
    find_lex $P690, "push_block_handler"
.annotate 'line', 699
    find_lex $P1822, "only_star_block"
    find_lex $P1823, "attach_multi_signature"
.annotate 'line', 1241
    find_lex $P2861, "control"
.annotate 'line', 1268
    get_hll_global $P2886, ["NQP";"RegexActions"], "_block2885" 
    capture_lex $P2886
    $P3006 = $P2886()
.annotate 'line', 3
    .return ($P3006)
    .const 'Sub' $P3008 = "168_1298839287.218" 
    .return ($P3008)
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post171") :outer("11_1298839287.218")
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P3012 = "169_1298839287.218" 
    capture_lex $P3012
    $P3012()
.end


.namespace ["NQP";"Actions"]
.sub "_block3011"  :anon :subid("169_1298839287.218") :outer("11_1298839287.218")
.annotate 'line', 3
    get_hll_global $P3013, "NQPClassHOW"
    $P3014 = $P3013."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3014
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3015, type_obj
    .const 'Sub' $P3016 = "25_1298839287.218" 
    $P3015."add_method"(type_obj, "TOP", $P3016)
    get_how $P3017, type_obj
    .const 'Sub' $P3018 = "26_1298839287.218" 
    $P3017."add_method"(type_obj, "deflongname", $P3018)
    get_how $P3019, type_obj
    .const 'Sub' $P3020 = "27_1298839287.218" 
    $P3019."add_method"(type_obj, "comp_unit", $P3020)
    get_how $P3021, type_obj
    .const 'Sub' $P3022 = "28_1298839287.218" 
    $P3021."add_method"(type_obj, "statementlist", $P3022)
    get_how $P3023, type_obj
    .const 'Sub' $P3024 = "30_1298839287.218" 
    $P3023."add_method"(type_obj, "statement", $P3024)
    get_how $P3025, type_obj
    .const 'Sub' $P3026 = "32_1298839287.218" 
    $P3025."add_method"(type_obj, "xblock", $P3026)
    get_how $P3027, type_obj
    .const 'Sub' $P3028 = "33_1298839287.218" 
    $P3027."add_method"(type_obj, "pblock", $P3028)
    get_how $P3029, type_obj
    .const 'Sub' $P3030 = "34_1298839287.218" 
    $P3029."add_method"(type_obj, "block", $P3030)
    get_how $P3031, type_obj
    .const 'Sub' $P3032 = "35_1298839287.218" 
    $P3031."add_method"(type_obj, "blockoid", $P3032)
    get_how $P3033, type_obj
    .const 'Sub' $P3034 = "37_1298839287.218" 
    $P3033."add_method"(type_obj, "newpad", $P3034)
    get_how $P3035, type_obj
    .const 'Sub' $P3036 = "38_1298839287.218" 
    $P3035."add_method"(type_obj, "outerctx", $P3036)
    get_how $P3037, type_obj
    .const 'Sub' $P3038 = "39_1298839287.218" 
    $P3037."add_method"(type_obj, "you_are_here", $P3038)
    get_how $P3039, type_obj
    .const 'Sub' $P3040 = "40_1298839287.218" 
    $P3039."add_method"(type_obj, "statement_control:sym<if>", $P3040)
    get_how $P3041, type_obj
    .const 'Sub' $P3042 = "42_1298839287.218" 
    $P3041."add_method"(type_obj, "statement_control:sym<unless>", $P3042)
    get_how $P3043, type_obj
    .const 'Sub' $P3044 = "43_1298839287.218" 
    $P3043."add_method"(type_obj, "statement_control:sym<while>", $P3044)
    get_how $P3045, type_obj
    .const 'Sub' $P3046 = "44_1298839287.218" 
    $P3045."add_method"(type_obj, "statement_control:sym<repeat>", $P3046)
    get_how $P3047, type_obj
    .const 'Sub' $P3048 = "45_1298839287.218" 
    $P3047."add_method"(type_obj, "statement_control:sym<for>", $P3048)
    get_how $P3049, type_obj
    .const 'Sub' $P3050 = "46_1298839287.218" 
    $P3049."add_method"(type_obj, "statement_control:sym<CATCH>", $P3050)
    get_how $P3051, type_obj
    .const 'Sub' $P3052 = "47_1298839287.218" 
    $P3051."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3052)
    get_how $P3053, type_obj
    .const 'Sub' $P3054 = "48_1298839287.218" 
    $P3053."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3054)
    get_how $P3055, type_obj
    .const 'Sub' $P3056 = "49_1298839287.218" 
    $P3055."add_method"(type_obj, "statement_prefix:sym<try>", $P3056)
    get_how $P3057, type_obj
    .const 'Sub' $P3058 = "50_1298839287.218" 
    $P3057."add_method"(type_obj, "blorst", $P3058)
    get_how $P3059, type_obj
    .const 'Sub' $P3060 = "51_1298839287.218" 
    $P3059."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3060)
    get_how $P3061, type_obj
    .const 'Sub' $P3062 = "52_1298839287.218" 
    $P3061."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3062)
    get_how $P3063, type_obj
    .const 'Sub' $P3064 = "53_1298839287.218" 
    $P3063."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3064)
    get_how $P3065, type_obj
    .const 'Sub' $P3066 = "54_1298839287.218" 
    $P3065."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3066)
    get_how $P3067, type_obj
    .const 'Sub' $P3068 = "55_1298839287.218" 
    $P3067."add_method"(type_obj, "term:sym<fatarrow>", $P3068)
    get_how $P3069, type_obj
    .const 'Sub' $P3070 = "56_1298839287.218" 
    $P3069."add_method"(type_obj, "term:sym<colonpair>", $P3070)
    get_how $P3071, type_obj
    .const 'Sub' $P3072 = "57_1298839287.218" 
    $P3071."add_method"(type_obj, "term:sym<variable>", $P3072)
    get_how $P3073, type_obj
    .const 'Sub' $P3074 = "58_1298839287.218" 
    $P3073."add_method"(type_obj, "term:sym<package_declarator>", $P3074)
    get_how $P3075, type_obj
    .const 'Sub' $P3076 = "59_1298839287.218" 
    $P3075."add_method"(type_obj, "term:sym<scope_declarator>", $P3076)
    get_how $P3077, type_obj
    .const 'Sub' $P3078 = "60_1298839287.218" 
    $P3077."add_method"(type_obj, "term:sym<routine_declarator>", $P3078)
    get_how $P3079, type_obj
    .const 'Sub' $P3080 = "61_1298839287.218" 
    $P3079."add_method"(type_obj, "term:sym<regex_declarator>", $P3080)
    get_how $P3081, type_obj
    .const 'Sub' $P3082 = "62_1298839287.218" 
    $P3081."add_method"(type_obj, "term:sym<statement_prefix>", $P3082)
    get_how $P3083, type_obj
    .const 'Sub' $P3084 = "63_1298839287.218" 
    $P3083."add_method"(type_obj, "term:sym<lambda>", $P3084)
    get_how $P3085, type_obj
    .const 'Sub' $P3086 = "64_1298839287.218" 
    $P3085."add_method"(type_obj, "fatarrow", $P3086)
    get_how $P3087, type_obj
    .const 'Sub' $P3088 = "65_1298839287.218" 
    $P3087."add_method"(type_obj, "colonpair", $P3088)
    get_how $P3089, type_obj
    .const 'Sub' $P3090 = "66_1298839287.218" 
    $P3089."add_method"(type_obj, "variable", $P3090)
    get_how $P3091, type_obj
    .const 'Sub' $P3092 = "68_1298839287.218" 
    $P3091."add_method"(type_obj, "package_declarator:sym<module>", $P3092)
    get_how $P3093, type_obj
    .const 'Sub' $P3094 = "69_1298839287.218" 
    $P3093."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3094)
    get_how $P3095, type_obj
    .const 'Sub' $P3096 = "70_1298839287.218" 
    $P3095."add_method"(type_obj, "package_declarator:sym<class>", $P3096)
    get_how $P3097, type_obj
    .const 'Sub' $P3098 = "71_1298839287.218" 
    $P3097."add_method"(type_obj, "package_declarator:sym<grammar>", $P3098)
    get_how $P3099, type_obj
    .const 'Sub' $P3100 = "72_1298839287.218" 
    $P3099."add_method"(type_obj, "package_declarator:sym<role>", $P3100)
    get_how $P3101, type_obj
    .const 'Sub' $P3102 = "73_1298839287.218" 
    $P3101."add_method"(type_obj, "package_declarator:sym<native>", $P3102)
    get_how $P3103, type_obj
    .const 'Sub' $P3104 = "74_1298839287.218" 
    $P3103."add_method"(type_obj, "package_def", $P3104)
    get_how $P3105, type_obj
    .const 'Sub' $P3106 = "78_1298839287.218" 
    $P3105."add_method"(type_obj, "scope_declarator:sym<my>", $P3106)
    get_how $P3107, type_obj
    .const 'Sub' $P3108 = "79_1298839287.218" 
    $P3107."add_method"(type_obj, "scope_declarator:sym<our>", $P3108)
    get_how $P3109, type_obj
    .const 'Sub' $P3110 = "80_1298839287.218" 
    $P3109."add_method"(type_obj, "scope_declarator:sym<has>", $P3110)
    get_how $P3111, type_obj
    .const 'Sub' $P3112 = "81_1298839287.218" 
    $P3111."add_method"(type_obj, "scoped", $P3112)
    get_how $P3113, type_obj
    .const 'Sub' $P3114 = "82_1298839287.218" 
    $P3113."add_method"(type_obj, "declarator", $P3114)
    get_how $P3115, type_obj
    .const 'Sub' $P3116 = "83_1298839287.218" 
    $P3115."add_method"(type_obj, "multi_declarator:sym<multi>", $P3116)
    get_how $P3117, type_obj
    .const 'Sub' $P3118 = "84_1298839287.218" 
    $P3117."add_method"(type_obj, "multi_declarator:sym<proto>", $P3118)
    get_how $P3119, type_obj
    .const 'Sub' $P3120 = "85_1298839287.218" 
    $P3119."add_method"(type_obj, "multi_declarator:sym<null>", $P3120)
    get_how $P3121, type_obj
    .const 'Sub' $P3122 = "86_1298839287.218" 
    $P3121."add_method"(type_obj, "variable_declarator", $P3122)
    get_how $P3123, type_obj
    .const 'Sub' $P3124 = "90_1298839287.218" 
    $P3123."add_method"(type_obj, "routine_declarator:sym<sub>", $P3124)
    get_how $P3125, type_obj
    .const 'Sub' $P3126 = "91_1298839287.218" 
    $P3125."add_method"(type_obj, "routine_declarator:sym<method>", $P3126)
    get_how $P3127, type_obj
    .const 'Sub' $P3128 = "92_1298839287.218" 
    $P3127."add_method"(type_obj, "routine_def", $P3128)
    get_how $P3129, type_obj
    .const 'Sub' $P3130 = "99_1298839287.218" 
    $P3129."add_method"(type_obj, "method_def", $P3130)
    get_how $P3131, type_obj
    .const 'Sub' $P3132 = "102_1298839287.218" 
    $P3131."add_method"(type_obj, "signature", $P3132)
    get_how $P3133, type_obj
    .const 'Sub' $P3134 = "105_1298839287.218" 
    $P3133."add_method"(type_obj, "parameter", $P3134)
    get_how $P3135, type_obj
    .const 'Sub' $P3136 = "106_1298839287.218" 
    $P3135."add_method"(type_obj, "param_var", $P3136)
    get_how $P3137, type_obj
    .const 'Sub' $P3138 = "107_1298839287.218" 
    $P3137."add_method"(type_obj, "named_param", $P3138)
    get_how $P3139, type_obj
    .const 'Sub' $P3140 = "108_1298839287.218" 
    $P3139."add_method"(type_obj, "typename", $P3140)
    get_how $P3141, type_obj
    .const 'Sub' $P3142 = "109_1298839287.218" 
    $P3141."add_method"(type_obj, "trait", $P3142)
    get_how $P3143, type_obj
    .const 'Sub' $P3144 = "110_1298839287.218" 
    $P3143."add_method"(type_obj, "trait_mod:sym<is>", $P3144)
    get_how $P3145, type_obj
    .const 'Sub' $P3146 = "112_1298839287.218" 
    $P3145."add_method"(type_obj, "regex_declarator", $P3146)
    get_how $P3147, type_obj
    .const 'Sub' $P3148 = "116_1298839287.218" 
    $P3147."add_method"(type_obj, "dotty", $P3148)
    get_how $P3149, type_obj
    .const 'Sub' $P3150 = "117_1298839287.218" 
    $P3149."add_method"(type_obj, "term:sym<self>", $P3150)
    get_how $P3151, type_obj
    .const 'Sub' $P3152 = "118_1298839287.218" 
    $P3151."add_method"(type_obj, "term:sym<identifier>", $P3152)
    get_how $P3153, type_obj
    .const 'Sub' $P3154 = "119_1298839287.218" 
    $P3153."add_method"(type_obj, "term:sym<name>", $P3154)
    get_how $P3155, type_obj
    .const 'Sub' $P3156 = "120_1298839287.218" 
    $P3155."add_method"(type_obj, "term:sym<pir::op>", $P3156)
    get_how $P3157, type_obj
    .const 'Sub' $P3158 = "121_1298839287.218" 
    $P3157."add_method"(type_obj, "term:sym<onlystar>", $P3158)
    get_how $P3159, type_obj
    .const 'Sub' $P3160 = "122_1298839287.218" 
    $P3159."add_method"(type_obj, "args", $P3160)
    get_how $P3161, type_obj
    .const 'Sub' $P3162 = "123_1298839287.218" 
    $P3161."add_method"(type_obj, "arglist", $P3162)
    get_how $P3163, type_obj
    .const 'Sub' $P3164 = "126_1298839287.218" 
    $P3163."add_method"(type_obj, "term:sym<multi_declarator>", $P3164)
    get_how $P3165, type_obj
    .const 'Sub' $P3166 = "127_1298839287.218" 
    $P3165."add_method"(type_obj, "term:sym<value>", $P3166)
    get_how $P3167, type_obj
    .const 'Sub' $P3168 = "128_1298839287.218" 
    $P3167."add_method"(type_obj, "circumfix:sym<( )>", $P3168)
    get_how $P3169, type_obj
    .const 'Sub' $P3170 = "129_1298839287.218" 
    $P3169."add_method"(type_obj, "circumfix:sym<[ ]>", $P3170)
    get_how $P3171, type_obj
    .const 'Sub' $P3172 = "130_1298839287.218" 
    $P3171."add_method"(type_obj, "circumfix:sym<ang>", $P3172)
    get_how $P3173, type_obj
    .const 'Sub' $P3174 = "131_1298839287.218" 
    $P3173."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3174)
    get_how $P3175, type_obj
    .const 'Sub' $P3176 = "132_1298839287.218" 
    $P3175."add_method"(type_obj, "circumfix:sym<{ }>", $P3176)
    get_how $P3177, type_obj
    .const 'Sub' $P3178 = "133_1298839287.218" 
    $P3177."add_method"(type_obj, "circumfix:sym<sigil>", $P3178)
    get_how $P3179, type_obj
    .const 'Sub' $P3180 = "134_1298839287.218" 
    $P3179."add_method"(type_obj, "semilist", $P3180)
    get_how $P3181, type_obj
    .const 'Sub' $P3182 = "135_1298839287.218" 
    $P3181."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3182)
    get_how $P3183, type_obj
    .const 'Sub' $P3184 = "136_1298839287.218" 
    $P3183."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3184)
    get_how $P3185, type_obj
    .const 'Sub' $P3186 = "137_1298839287.218" 
    $P3185."add_method"(type_obj, "postcircumfix:sym<ang>", $P3186)
    get_how $P3187, type_obj
    .const 'Sub' $P3188 = "138_1298839287.218" 
    $P3187."add_method"(type_obj, "postcircumfix:sym<( )>", $P3188)
    get_how $P3189, type_obj
    .const 'Sub' $P3190 = "139_1298839287.218" 
    $P3189."add_method"(type_obj, "value", $P3190)
    get_how $P3191, type_obj
    .const 'Sub' $P3192 = "140_1298839287.218" 
    $P3191."add_method"(type_obj, "number", $P3192)
    get_how $P3193, type_obj
    .const 'Sub' $P3194 = "141_1298839287.218" 
    $P3193."add_method"(type_obj, "quote:sym<apos>", $P3194)
    get_how $P3195, type_obj
    .const 'Sub' $P3196 = "142_1298839287.218" 
    $P3195."add_method"(type_obj, "quote:sym<dblq>", $P3196)
    get_how $P3197, type_obj
    .const 'Sub' $P3198 = "143_1298839287.218" 
    $P3197."add_method"(type_obj, "quote:sym<qq>", $P3198)
    get_how $P3199, type_obj
    .const 'Sub' $P3200 = "144_1298839287.218" 
    $P3199."add_method"(type_obj, "quote:sym<q>", $P3200)
    get_how $P3201, type_obj
    .const 'Sub' $P3202 = "145_1298839287.218" 
    $P3201."add_method"(type_obj, "quote:sym<Q>", $P3202)
    get_how $P3203, type_obj
    .const 'Sub' $P3204 = "146_1298839287.218" 
    $P3203."add_method"(type_obj, "quote:sym<Q:PIR>", $P3204)
    get_how $P3205, type_obj
    .const 'Sub' $P3206 = "147_1298839287.218" 
    $P3205."add_method"(type_obj, "quote:sym</ />", $P3206)
    get_how $P3207, type_obj
    .const 'Sub' $P3208 = "148_1298839287.218" 
    $P3207."add_method"(type_obj, "quote_escape:sym<$>", $P3208)
    get_how $P3209, type_obj
    .const 'Sub' $P3210 = "149_1298839287.218" 
    $P3209."add_method"(type_obj, "quote_escape:sym<{ }>", $P3210)
    get_how $P3211, type_obj
    .const 'Sub' $P3212 = "150_1298839287.218" 
    $P3211."add_method"(type_obj, "quote_escape:sym<esc>", $P3212)
    get_how $P3213, type_obj
    .const 'Sub' $P3214 = "151_1298839287.218" 
    $P3213."add_method"(type_obj, "postfix:sym<.>", $P3214)
    get_how $P3215, type_obj
    .const 'Sub' $P3216 = "152_1298839287.218" 
    $P3215."add_method"(type_obj, "postfix:sym<++>", $P3216)
    get_how $P3217, type_obj
    .const 'Sub' $P3218 = "153_1298839287.218" 
    $P3217."add_method"(type_obj, "postfix:sym<-->", $P3218)
    get_how $P3219, type_obj
    .const 'Sub' $P3220 = "154_1298839287.218" 
    $P3219."add_method"(type_obj, "prefix:sym<make>", $P3220)
    get_how $P3221, type_obj
    .const 'Sub' $P3222 = "155_1298839287.218" 
    $P3221."add_method"(type_obj, "term:sym<next>", $P3222)
    get_how $P3223, type_obj
    .const 'Sub' $P3224 = "156_1298839287.218" 
    $P3223."add_method"(type_obj, "term:sym<last>", $P3224)
    get_how $P3225, type_obj
    .const 'Sub' $P3226 = "157_1298839287.218" 
    $P3225."add_method"(type_obj, "term:sym<redo>", $P3226)
    get_how $P3227, type_obj
    .const 'Sub' $P3228 = "158_1298839287.218" 
    $P3227."add_method"(type_obj, "infix:sym<~~>", $P3228)
    get_how $P3229, type_obj
    get_hll_global $P3230, ["HLL"], "Actions"
    $P3229."add_parent"(type_obj, $P3230)
    get_how $P3231, type_obj
    $P3232 = $P3231."compose"(type_obj)
    .return ($P3232)
.end


.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_20
.annotate 'line', 9
    .lex "$xblock", param_20
.annotate 'line', 10
    find_lex $P21, "$xblock"
    unless_null $P21, vivify_173
    $P21 = root_new ['parrot';'ResizablePMCArray']
  vivify_173:
    set $P22, $P21[1]
    unless_null $P22, vivify_174
    new $P22, "Undef"
  vivify_174:
    $P23 = "block_immediate"($P22)
    find_lex $P24, "$xblock"
    unless_null $P24, vivify_175
    $P24 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P24
  vivify_175:
    set $P24[1], $P23
    find_lex $P25, "$xblock"
.annotate 'line', 9
    .return ($P25)
.end


.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_28
.annotate 'line', 14
    .const 'Sub' $P38 = "14_1298839287.218" 
    capture_lex $P38
    .lex "$block", param_28
.annotate 'line', 15
    find_lex $P29, "$block"
    $P29."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P33, "$block"
    $P34 = $P33."symtable"()
    unless $P34, unless_32
    set $P31, $P34
    goto unless_32_end
  unless_32:
    find_lex $P35, "$block"
    $P36 = $P35."handlers"()
    set $P31, $P36
  unless_32_end:
    if $P31, unless_30_end
    .const 'Sub' $P38 = "14_1298839287.218" 
    capture_lex $P38
    $P38()
  unless_30_end:
    find_lex $P58, "$block"
.annotate 'line', 14
    .return ($P58)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block37"  :anon :subid("14_1298839287.218") :outer("13_1298839287.218")
.annotate 'line', 16
    .const 'Sub' $P49 = "15_1298839287.218" 
    capture_lex $P49
.annotate 'line', 17
    new $P39, "Undef"
    .lex "$stmts", $P39
    get_hll_global $P40, ["PAST"], "Stmts"
    find_lex $P41, "$block"
    $P42 = $P40."new"($P41 :named("node"))
    store_lex "$stmts", $P42
.annotate 'line', 18
    find_lex $P44, "$block"
    $P45 = $P44."list"()
    defined $I46, $P45
    unless $I46, for_undef_176
    iter $P43, $P45
    new $P55, 'ExceptionHandler'
    set_label $P55, loop54_handler
    $P55."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P55
  loop54_test:
    unless $P43, loop54_done
    shift $P47, $P43
  loop54_redo:
    .const 'Sub' $P49 = "15_1298839287.218" 
    capture_lex $P49
    $P49($P47)
  loop54_next:
    goto loop54_test
  loop54_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P56, exception, 'type'
    eq $P56, .CONTROL_LOOP_NEXT, loop54_next
    eq $P56, .CONTROL_LOOP_REDO, loop54_redo
  loop54_done:
    pop_eh 
  for_undef_176:
.annotate 'line', 19
    find_lex $P57, "$stmts"
    store_lex "$block", $P57
.annotate 'line', 16
    .return ($P57)
.end


.namespace ["NQP";"Actions"]
.sub "_block48"  :anon :subid("15_1298839287.218") :outer("14_1298839287.218")
    .param pmc param_50
.annotate 'line', 18
    .lex "$_", param_50
    find_lex $P51, "$stmts"
    find_lex $P52, "$_"
    $P53 = $P51."push"($P52)
    .return ($P53)
.end


.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_61
.annotate 'line', 24
    .lex "$sigil", param_61
.annotate 'line', 25
    find_lex $P64, "$sigil"
    set $S65, $P64
    iseq $I66, $S65, "%"
    if $I66, if_63
.annotate 'line', 27
    find_lex $P71, "$sigil"
    set $S72, $P71
    iseq $I73, $S72, "@"
    if $I73, if_70
    new $P76, "String"
    assign $P76, "Undef"
    set $P69, $P76
    goto if_70_end
  if_70:
.annotate 'line', 28
    get_hll_global $P74, ["PAST"], "Op"
    $P75 = $P74."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P69, $P75
  if_70_end:
    set $P62, $P69
.annotate 'line', 25
    goto if_63_end
  if_63:
.annotate 'line', 26
    get_hll_global $P67, ["PAST"], "Op"
    $P68 = $P67."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P62, $P68
  if_63_end:
.annotate 'line', 24
    .return ($P62)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_79
.annotate 'line', 43
    .lex "$ast", param_79
.annotate 'line', 44
    get_hll_global $P82, ["PAST"], "Op"
    find_lex $P83, "$ast"
    $P84 = $P82."ACCEPTS"($P83)
    if $P84, if_81
.annotate 'line', 46
    find_lex $P88, "$ast"
    $P89 = $P88."value"()
    set $P80, $P89
.annotate 'line', 44
    goto if_81_end
  if_81:
.annotate 'line', 45
    find_lex $P85, "$ast"
    $P86 = $P85."list"()
    join $S87, " ", $P86
    new $P80, 'String'
    set $P80, $S87
  if_81_end:
.annotate 'line', 43
    .return ($P80)
.end


.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_92
    .param pmc param_93
.annotate 'line', 232
    .lex "$/", param_92
    .lex "$block", param_93
.annotate 'line', 233
    get_global $P95, "@BLOCK"
    unless_null $P95, vivify_177
    $P95 = root_new ['parrot';'ResizablePMCArray']
  vivify_177:
    set $P96, $P95[0]
    unless_null $P96, vivify_178
    new $P96, "Undef"
  vivify_178:
    $P97 = $P96."handlers"()
    if $P97, unless_94_end
.annotate 'line', 234
    get_global $P98, "@BLOCK"
    unless_null $P98, vivify_179
    $P98 = root_new ['parrot';'ResizablePMCArray']
  vivify_179:
    set $P99, $P98[0]
    unless_null $P99, vivify_180
    new $P99, "Undef"
  vivify_180:
    new $P100, "ResizablePMCArray"
    $P99."handlers"($P100)
  unless_94_end:
.annotate 'line', 236
    find_lex $P102, "$block"
    $P103 = $P102."arity"()
    if $P103, unless_101_end
.annotate 'line', 237
    find_lex $P104, "$block"
.annotate 'line', 238
    get_hll_global $P105, ["PAST"], "Op"
.annotate 'line', 239
    get_hll_global $P106, ["PAST"], "Var"
    $P107 = $P106."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 240
    get_hll_global $P108, ["PAST"], "Var"
    $P109 = $P108."new"("lexical" :named("scope"), "$_" :named("name"))
    $P110 = $P105."new"($P107, $P109, "bind" :named("pasttype"))
.annotate 'line', 238
    $P104."unshift"($P110)
.annotate 'line', 243
    find_lex $P111, "$block"
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("$_" :named("name"), "parameter" :named("scope"))
    $P111."unshift"($P113)
.annotate 'line', 244
    find_lex $P114, "$block"
    $P114."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 245
    find_lex $P115, "$block"
    $P115."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 246
    find_lex $P116, "$block"
    $P116."arity"(1)
  unless_101_end:
.annotate 'line', 248
    find_lex $P117, "$block"
    $P117."blocktype"("declaration")
.annotate 'line', 249
    get_global $P118, "@BLOCK"
    unless_null $P118, vivify_181
    $P118 = root_new ['parrot';'ResizablePMCArray']
  vivify_181:
    set $P119, $P118[0]
    unless_null $P119, vivify_182
    new $P119, "Undef"
  vivify_182:
    $P120 = $P119."handlers"()
.annotate 'line', 250
    get_hll_global $P121, ["PAST"], "Control"
    find_lex $P122, "$/"
.annotate 'line', 252
    get_hll_global $P123, ["PAST"], "Stmts"
.annotate 'line', 253
    get_hll_global $P124, ["PAST"], "Op"
    find_lex $P125, "$block"
.annotate 'line', 255
    get_hll_global $P126, ["PAST"], "Var"
    $P127 = $P126."new"("register" :named("scope"), "exception" :named("name"))
    $P128 = $P124."new"($P125, $P127, "call" :named("pasttype"))
.annotate 'line', 257
    get_hll_global $P129, ["PAST"], "Op"
.annotate 'line', 258
    get_hll_global $P130, ["PAST"], "Var"
.annotate 'line', 259
    get_hll_global $P131, ["PAST"], "Var"
    $P132 = $P131."new"("register" :named("scope"), "exception" :named("name"))
    $P133 = $P130."new"($P132, "handled", "keyed" :named("scope"))
.annotate 'line', 258
    $P134 = $P129."new"($P133, 1, "bind" :named("pasttype"))
.annotate 'line', 257
    $P135 = $P123."new"($P128, $P134)
.annotate 'line', 252
    $P136 = $P121."new"($P135, $P122 :named("node"))
.annotate 'line', 250
    $P137 = $P120."unshift"($P136)
.annotate 'line', 232
    .return ($P137)
.end


.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1298839287.218") :outer("11_1298839287.218")
.annotate 'line', 772
    new $P140, "Undef"
    .lex "$past", $P140
    get_global $P141, "@BLOCK"
    $P142 = $P141."shift"()
    store_lex "$past", $P142
.annotate 'line', 773
    find_lex $P143, "$past"
    $P143."closure"(1)
.annotate 'line', 774
    find_lex $P144, "$past"
    get_hll_global $P145, ["PAST"], "Op"
    $P146 = $P145."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P144."push"($P146)
    find_lex $P147, "$past"
.annotate 'line', 771
    .return ($P147)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_150
.annotate 'line', 780
    .const 'Sub' $P164 = "21_1298839287.218" 
    capture_lex $P164
    .lex "$routine", param_150
.annotate 'line', 784
    new $P151, "Undef"
    .lex "$types", $P151
.annotate 'line', 785
    new $P152, "Undef"
    .lex "$definednesses", $P152
.annotate 'line', 784
    get_hll_global $P153, ["PAST"], "Op"
    $P154 = $P153."new"("list" :named("pasttype"))
    store_lex "$types", $P154
.annotate 'line', 785
    get_hll_global $P155, ["PAST"], "Op"
    $P156 = $P155."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P156
.annotate 'line', 786
    find_lex $P158, "$routine"
    unless_null $P158, vivify_183
    $P158 = root_new ['parrot';'ResizablePMCArray']
  vivify_183:
    set $P159, $P158[0]
    unless_null $P159, vivify_184
    new $P159, "Undef"
  vivify_184:
    $P160 = $P159."list"()
    defined $I161, $P160
    unless $I161, for_undef_185
    iter $P157, $P160
    new $P202, 'ExceptionHandler'
    set_label $P202, loop201_handler
    $P202."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P202
  loop201_test:
    unless $P157, loop201_done
    shift $P162, $P157
  loop201_redo:
    .const 'Sub' $P164 = "21_1298839287.218" 
    capture_lex $P164
    $P164($P162)
  loop201_next:
    goto loop201_test
  loop201_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P203, exception, 'type'
    eq $P203, .CONTROL_LOOP_NEXT, loop201_next
    eq $P203, .CONTROL_LOOP_REDO, loop201_redo
  loop201_done:
    pop_eh 
  for_undef_185:
.annotate 'line', 793
    find_lex $P204, "$routine"
    $P205 = $P204."loadinit"()
    get_hll_global $P206, ["PAST"], "Op"
.annotate 'line', 794
    get_hll_global $P207, ["PAST"], "Var"
    $P208 = $P207."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P209, "$types"
    find_lex $P210, "$definednesses"
    $P211 = $P206."new"($P208, $P209, $P210, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 793
    $P212 = $P205."push"($P211)
.annotate 'line', 780
    .return ($P212)
.end


.namespace ["NQP";"Actions"]
.sub "_block163"  :anon :subid("21_1298839287.218") :outer("20_1298839287.218")
    .param pmc param_165
.annotate 'line', 786
    .lex "$_", param_165
.annotate 'line', 787
    get_hll_global $P170, ["PAST"], "Var"
    find_lex $P171, "$_"
    $P172 = $P170."ACCEPTS"($P171)
    if $P172, if_169
    set $P168, $P172
    goto if_169_end
  if_169:
    find_lex $P173, "$_"
    $S174 = $P173."scope"()
    iseq $I175, $S174, "parameter"
    new $P168, 'Integer'
    set $P168, $I175
  if_169_end:
    if $P168, if_167
    set $P166, $P168
    goto if_167_end
  if_167:
.annotate 'line', 788
    find_lex $P176, "$types"
    find_lex $P178, "$_"
    $P179 = $P178."multitype"()
    set $P177, $P179
    defined $I181, $P177
    if $I181, default_180
    get_hll_global $P182, ["PAST"], "Op"
    $P183 = $P182."new"("null P" :named("pirop"))
    set $P177, $P183
  default_180:
    $P176."push"($P177)
.annotate 'line', 789
    find_lex $P184, "$definednesses"
    find_lex $P187, "$_"
    unless_null $P187, vivify_186
    $P187 = root_new ['parrot';'Hash']
  vivify_186:
    set $P188, $P187["definedness"]
    unless_null $P188, vivify_187
    new $P188, "Undef"
  vivify_187:
    set $S189, $P188
    iseq $I190, $S189, "D"
    if $I190, if_186
.annotate 'line', 790
    find_lex $P194, "$_"
    unless_null $P194, vivify_188
    $P194 = root_new ['parrot';'Hash']
  vivify_188:
    set $P195, $P194["definedness"]
    unless_null $P195, vivify_189
    new $P195, "Undef"
  vivify_189:
    set $S196, $P195
    iseq $I197, $S196, "U"
    if $I197, if_193
    new $P199, "Integer"
    assign $P199, 0
    set $P192, $P199
    goto if_193_end
  if_193:
    new $P198, "Integer"
    assign $P198, 2
    set $P192, $P198
  if_193_end:
    set $P185, $P192
.annotate 'line', 789
    goto if_186_end
  if_186:
    new $P191, "Integer"
    assign $P191, 1
    set $P185, $P191
  if_186_end:
    $P200 = $P184."push"($P185)
.annotate 'line', 787
    set $P166, $P200
  if_167_end:
.annotate 'line', 786
    .return ($P166)
.end


.namespace ["NQP";"Actions"]
.sub "control"  :subid("22_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_215
    .param pmc param_216
.annotate 'line', 1250
    .lex "$/", param_215
    .lex "$type", param_216
.annotate 'line', 1251
    find_lex $P217, "$/"
    get_hll_global $P218, ["PAST"], "Op"
    find_lex $P219, "$/"
.annotate 'line', 1255
    get_hll_global $P220, ["PAST"], "Val"
    find_lex $P221, "$type"
    $P222 = $P220."new"($P221 :named("value"), "!except_types" :named("returns"))
    $P223 = $P218."new"(0, $P222, $P219 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1251
    $P224 = $P217."!make"($P223)
.annotate 'line', 1250
    .return ($P224)
.end


.namespace ["NQP";"Actions"]
.sub "_block227"  :anon :subid("23_1298839287.218") :outer("11_1298839287.218")
.annotate 'line', 3
    .const 'Sub' $P230 = "24_1298839287.218" 
    capture_lex $P230
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post190") :outer("23_1298839287.218")
.annotate 'line', 3
    .const 'Sub' $P228 = "23_1298839287.218" 
    .local pmc block
    set block, $P228
.annotate 'line', 5
    .const 'Sub' $P230 = "24_1298839287.218" 
    capture_lex $P230
    $P230()
.end


.namespace ["NQP";"Actions"]
.sub "_block229"  :anon :subid("24_1298839287.218") :outer("23_1298839287.218")
.annotate 'line', 6
    get_global $P231, "@BLOCK"
    unless_null $P231, vivify_191
    $P231 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P231
  vivify_191:
 $P232 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P232
.annotate 'line', 5
    .return ($P232)
.end


.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("25_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_237
    .param pmc param_238
.annotate 'line', 33
    .lex "self", param_237
    .lex "$/", param_238
    find_lex $P239, "$/"
    find_lex $P240, "$/"
    unless_null $P240, vivify_192
    $P240 = root_new ['parrot';'Hash']
  vivify_192:
    set $P241, $P240["comp_unit"]
    unless_null $P241, vivify_193
    new $P241, "Undef"
  vivify_193:
    $P242 = $P241."ast"()
    $P243 = $P239."!make"($P242)
    .return ($P243)
.end


.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("26_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_245
    .param pmc param_246
.annotate 'line', 35
    .lex "self", param_245
    .lex "$/", param_246
.annotate 'line', 36
    find_lex $P247, "$/"
.annotate 'line', 37
    find_lex $P250, "$/"
    unless_null $P250, vivify_194
    $P250 = root_new ['parrot';'Hash']
  vivify_194:
    set $P251, $P250["colonpair"]
    unless_null $P251, vivify_195
    new $P251, "Undef"
  vivify_195:
    if $P251, if_249
.annotate 'line', 39
    find_lex $P271, "$/"
    set $S272, $P271
    new $P248, 'String'
    set $P248, $S272
.annotate 'line', 37
    goto if_249_end
  if_249:
    find_lex $P252, "$/"
    unless_null $P252, vivify_196
    $P252 = root_new ['parrot';'Hash']
  vivify_196:
    set $P253, $P252["identifier"]
    unless_null $P253, vivify_197
    new $P253, "Undef"
  vivify_197:
    set $S254, $P253
    new $P255, 'String'
    set $P255, $S254
    concat $P256, $P255, ":"
    find_lex $P257, "$/"
    unless_null $P257, vivify_198
    $P257 = root_new ['parrot';'Hash']
  vivify_198:
    set $P258, $P257["colonpair"]
    unless_null $P258, vivify_199
    $P258 = root_new ['parrot';'ResizablePMCArray']
  vivify_199:
    set $P259, $P258[0]
    unless_null $P259, vivify_200
    new $P259, "Undef"
  vivify_200:
    $P260 = $P259."ast"()
    $S261 = $P260."named"()
    concat $P262, $P256, $S261
    concat $P263, $P262, "<"
.annotate 'line', 38
    find_lex $P264, "$/"
    unless_null $P264, vivify_201
    $P264 = root_new ['parrot';'Hash']
  vivify_201:
    set $P265, $P264["colonpair"]
    unless_null $P265, vivify_202
    $P265 = root_new ['parrot';'ResizablePMCArray']
  vivify_202:
    set $P266, $P265[0]
    unless_null $P266, vivify_203
    new $P266, "Undef"
  vivify_203:
    $P267 = $P266."ast"()
    $S268 = "colonpair_str"($P267)
    concat $P269, $P263, $S268
    concat $P270, $P269, ">"
    set $P248, $P270
  if_249_end:
.annotate 'line', 37
    $P273 = $P247."!make"($P248)
.annotate 'line', 35
    .return ($P273)
.end


.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("27_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_276
    .param pmc param_277
.annotate 'line', 49
    .lex "self", param_276
    .lex "$/", param_277
.annotate 'line', 50
    new $P278, "Undef"
    .lex "$mainline", $P278
.annotate 'line', 51
    new $P279, "Undef"
    .lex "$unit", $P279
.annotate 'line', 50
    find_lex $P280, "$/"
    unless_null $P280, vivify_204
    $P280 = root_new ['parrot';'Hash']
  vivify_204:
    set $P281, $P280["statementlist"]
    unless_null $P281, vivify_205
    new $P281, "Undef"
  vivify_205:
    $P282 = $P281."ast"()
    store_lex "$mainline", $P282
.annotate 'line', 51
    get_global $P283, "@BLOCK"
    $P284 = $P283."shift"()
    store_lex "$unit", $P284
.annotate 'line', 55
    find_lex $P285, "$unit"
    find_lex $P286, "self"
    $P287 = $P286."CTXSAVE"()
    $P285."push"($P287)
.annotate 'line', 58
    find_lex $P288, "$unit"
    $P288."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 59
    find_lex $P289, "$unit"
    get_hll_global $P290, ["PAST"], "Op"
    $P291 = $P290."new"("nqp_dynop_setup v" :named("pirop"))
    $P289."unshift"($P291)
.annotate 'line', 64
    find_lex $P292, "$unit"
.annotate 'line', 65
    get_hll_global $P293, ["PAST"], "Op"
    find_lex $P294, "$mainline"
    $P295 = $P293."new"($P294, "return" :named("pirop"))
    $P292."push"($P295)
.annotate 'line', 70
    find_lex $P296, "$unit"
.annotate 'line', 71
    get_hll_global $P297, ["PAST"], "Block"
.annotate 'line', 73
    get_hll_global $P298, ["PAST"], "Op"
    get_hll_global $P299, ["PAST"], "Val"
    find_lex $P300, "$unit"
    $P301 = $P299."new"($P300 :named("value"))
    $P302 = $P298."new"($P301, "call" :named("pasttype"))
    $P303 = $P297."new"($P302, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 71
    $P296."push"($P303)
.annotate 'line', 76
    find_lex $P304, "$unit"
    find_lex $P305, "$/"
    $P304."node"($P305)
.annotate 'line', 77
    find_lex $P306, "$/"
    find_lex $P307, "$unit"
    $P308 = $P306."!make"($P307)
.annotate 'line', 49
    .return ($P308)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("28_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_310
    .param pmc param_311
.annotate 'line', 80
    .const 'Sub' $P325 = "29_1298839287.218" 
    capture_lex $P325
    .lex "self", param_310
    .lex "$/", param_311
.annotate 'line', 81
    new $P312, "Undef"
    .lex "$past", $P312
    get_hll_global $P313, ["PAST"], "Stmts"
    find_lex $P314, "$/"
    $P315 = $P313."new"($P314 :named("node"))
    store_lex "$past", $P315
.annotate 'line', 82
    find_lex $P317, "$/"
    unless_null $P317, vivify_206
    $P317 = root_new ['parrot';'Hash']
  vivify_206:
    set $P318, $P317["statement"]
    unless_null $P318, vivify_207
    new $P318, "Undef"
  vivify_207:
    unless $P318, if_316_end
.annotate 'line', 83
    find_lex $P320, "$/"
    unless_null $P320, vivify_208
    $P320 = root_new ['parrot';'Hash']
  vivify_208:
    set $P321, $P320["statement"]
    unless_null $P321, vivify_209
    new $P321, "Undef"
  vivify_209:
    defined $I322, $P321
    unless $I322, for_undef_210
    iter $P319, $P321
    new $P345, 'ExceptionHandler'
    set_label $P345, loop344_handler
    $P345."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P345
  loop344_test:
    unless $P319, loop344_done
    shift $P323, $P319
  loop344_redo:
    .const 'Sub' $P325 = "29_1298839287.218" 
    capture_lex $P325
    $P325($P323)
  loop344_next:
    goto loop344_test
  loop344_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P346, exception, 'type'
    eq $P346, .CONTROL_LOOP_NEXT, loop344_next
    eq $P346, .CONTROL_LOOP_REDO, loop344_redo
  loop344_done:
    pop_eh 
  for_undef_210:
  if_316_end:
.annotate 'line', 90
    find_lex $P347, "$/"
    find_lex $P348, "$past"
    $P349 = $P347."!make"($P348)
.annotate 'line', 80
    .return ($P349)
.end


.namespace ["NQP";"Actions"]
.sub "_block324"  :anon :subid("29_1298839287.218") :outer("28_1298839287.218")
    .param pmc param_327
.annotate 'line', 84
    new $P326, "Undef"
    .lex "$ast", $P326
    .lex "$_", param_327
    find_lex $P328, "$_"
    $P329 = $P328."ast"()
    store_lex "$ast", $P329
.annotate 'line', 85
    find_lex $P331, "$ast"
    unless_null $P331, vivify_211
    $P331 = root_new ['parrot';'Hash']
  vivify_211:
    set $P332, $P331["sink"]
    unless_null $P332, vivify_212
    new $P332, "Undef"
  vivify_212:
    defined $I333, $P332
    unless $I333, if_330_end
    find_lex $P334, "$ast"
    unless_null $P334, vivify_213
    $P334 = root_new ['parrot';'Hash']
  vivify_213:
    set $P335, $P334["sink"]
    unless_null $P335, vivify_214
    new $P335, "Undef"
  vivify_214:
    store_lex "$ast", $P335
  if_330_end:
.annotate 'line', 86
    find_lex $P337, "$ast"
    unless_null $P337, vivify_215
    $P337 = root_new ['parrot';'Hash']
  vivify_215:
    set $P338, $P337["bareblock"]
    unless_null $P338, vivify_216
    new $P338, "Undef"
  vivify_216:
    unless $P338, if_336_end
    find_lex $P339, "$ast"
    $P340 = "block_immediate"($P339)
    store_lex "$ast", $P340
  if_336_end:
.annotate 'line', 87
    find_lex $P341, "$past"
    find_lex $P342, "$ast"
    $P343 = $P341."push"($P342)
.annotate 'line', 83
    .return ($P343)
.end


.namespace ["NQP";"Actions"]
.sub "statement"  :subid("30_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_351
    .param pmc param_352
    .param pmc param_353 :optional
    .param int has_param_353 :opt_flag
.annotate 'line', 93
    .const 'Sub' $P361 = "31_1298839287.218" 
    capture_lex $P361
    .lex "self", param_351
    .lex "$/", param_352
    if has_param_353, optparam_217
    new $P354, "Undef"
    set param_353, $P354
  optparam_217:
    .lex "$key", param_353
.annotate 'line', 94
    new $P355, "Undef"
    .lex "$past", $P355
.annotate 'line', 93
    find_lex $P356, "$past"
.annotate 'line', 95
    find_lex $P358, "$/"
    unless_null $P358, vivify_218
    $P358 = root_new ['parrot';'Hash']
  vivify_218:
    set $P359, $P358["EXPR"]
    unless_null $P359, vivify_219
    new $P359, "Undef"
  vivify_219:
    if $P359, if_357
.annotate 'line', 116
    find_lex $P422, "$/"
    unless_null $P422, vivify_220
    $P422 = root_new ['parrot';'Hash']
  vivify_220:
    set $P423, $P422["statement_control"]
    unless_null $P423, vivify_221
    new $P423, "Undef"
  vivify_221:
    if $P423, if_421
.annotate 'line', 117
    new $P427, "Integer"
    assign $P427, 0
    store_lex "$past", $P427
    goto if_421_end
  if_421:
.annotate 'line', 116
    find_lex $P424, "$/"
    unless_null $P424, vivify_222
    $P424 = root_new ['parrot';'Hash']
  vivify_222:
    set $P425, $P424["statement_control"]
    unless_null $P425, vivify_223
    new $P425, "Undef"
  vivify_223:
    $P426 = $P425."ast"()
    store_lex "$past", $P426
  if_421_end:
    goto if_357_end
  if_357:
.annotate 'line', 95
    .const 'Sub' $P361 = "31_1298839287.218" 
    capture_lex $P361
    $P361()
  if_357_end:
.annotate 'line', 118
    find_lex $P428, "$/"
    find_lex $P429, "$past"
    $P430 = $P428."!make"($P429)
.annotate 'line', 93
    .return ($P430)
.end


.namespace ["NQP";"Actions"]
.sub "_block360"  :anon :subid("31_1298839287.218") :outer("30_1298839287.218")
.annotate 'line', 96
    new $P362, "Undef"
    .lex "$mc", $P362
.annotate 'line', 97
    new $P363, "Undef"
    .lex "$ml", $P363
.annotate 'line', 96
    find_lex $P364, "$/"
    unless_null $P364, vivify_224
    $P364 = root_new ['parrot';'Hash']
  vivify_224:
    set $P365, $P364["statement_mod_cond"]
    unless_null $P365, vivify_225
    $P365 = root_new ['parrot';'ResizablePMCArray']
  vivify_225:
    set $P366, $P365[0]
    unless_null $P366, vivify_226
    new $P366, "Undef"
  vivify_226:
    store_lex "$mc", $P366
.annotate 'line', 97
    find_lex $P367, "$/"
    unless_null $P367, vivify_227
    $P367 = root_new ['parrot';'Hash']
  vivify_227:
    set $P368, $P367["statement_mod_loop"]
    unless_null $P368, vivify_228
    $P368 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    set $P369, $P368[0]
    unless_null $P369, vivify_229
    new $P369, "Undef"
  vivify_229:
    store_lex "$ml", $P369
.annotate 'line', 98
    find_lex $P370, "$/"
    unless_null $P370, vivify_230
    $P370 = root_new ['parrot';'Hash']
  vivify_230:
    set $P371, $P370["EXPR"]
    unless_null $P371, vivify_231
    new $P371, "Undef"
  vivify_231:
    $P372 = $P371."ast"()
    store_lex "$past", $P372
.annotate 'line', 99
    find_lex $P374, "$mc"
    unless $P374, if_373_end
.annotate 'line', 100
    get_hll_global $P375, ["PAST"], "Op"
    find_lex $P376, "$mc"
    unless_null $P376, vivify_232
    $P376 = root_new ['parrot';'Hash']
  vivify_232:
    set $P377, $P376["cond"]
    unless_null $P377, vivify_233
    new $P377, "Undef"
  vivify_233:
    $P378 = $P377."ast"()
    find_lex $P379, "$past"
    find_lex $P380, "$mc"
    unless_null $P380, vivify_234
    $P380 = root_new ['parrot';'Hash']
  vivify_234:
    set $P381, $P380["sym"]
    unless_null $P381, vivify_235
    new $P381, "Undef"
  vivify_235:
    set $S382, $P381
    find_lex $P383, "$/"
    $P384 = $P375."new"($P378, $P379, $S382 :named("pasttype"), $P383 :named("node"))
    store_lex "$past", $P384
  if_373_end:
.annotate 'line', 102
    find_lex $P387, "$ml"
    if $P387, if_386
    set $P385, $P387
    goto if_386_end
  if_386:
.annotate 'line', 103
    find_lex $P390, "$ml"
    unless_null $P390, vivify_236
    $P390 = root_new ['parrot';'Hash']
  vivify_236:
    set $P391, $P390["sym"]
    unless_null $P391, vivify_237
    new $P391, "Undef"
  vivify_237:
    set $S392, $P391
    iseq $I393, $S392, "for"
    if $I393, if_389
.annotate 'line', 112
    get_hll_global $P411, ["PAST"], "Op"
    find_lex $P412, "$ml"
    unless_null $P412, vivify_238
    $P412 = root_new ['parrot';'Hash']
  vivify_238:
    set $P413, $P412["cond"]
    unless_null $P413, vivify_239
    new $P413, "Undef"
  vivify_239:
    $P414 = $P413."ast"()
    find_lex $P415, "$past"
    find_lex $P416, "$ml"
    unless_null $P416, vivify_240
    $P416 = root_new ['parrot';'Hash']
  vivify_240:
    set $P417, $P416["sym"]
    unless_null $P417, vivify_241
    new $P417, "Undef"
  vivify_241:
    set $S418, $P417
    find_lex $P419, "$/"
    $P420 = $P411."new"($P414, $P415, $S418 :named("pasttype"), $P419 :named("node"))
    store_lex "$past", $P420
.annotate 'line', 111
    set $P388, $P420
.annotate 'line', 103
    goto if_389_end
  if_389:
.annotate 'line', 104
    get_hll_global $P394, ["PAST"], "Block"
.annotate 'line', 105
    get_hll_global $P395, ["PAST"], "Var"
    $P396 = $P395."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P397, "$past"
    $P398 = $P394."new"($P396, $P397, "immediate" :named("blocktype"))
.annotate 'line', 104
    store_lex "$past", $P398
.annotate 'line', 107
    find_lex $P399, "$past"
    $P399."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 108
    find_lex $P400, "$past"
    $P400."arity"(1)
.annotate 'line', 109
    get_hll_global $P401, ["PAST"], "Op"
    find_lex $P402, "$ml"
    unless_null $P402, vivify_242
    $P402 = root_new ['parrot';'Hash']
  vivify_242:
    set $P403, $P402["cond"]
    unless_null $P403, vivify_243
    new $P403, "Undef"
  vivify_243:
    $P404 = $P403."ast"()
    find_lex $P405, "$past"
    find_lex $P406, "$ml"
    unless_null $P406, vivify_244
    $P406 = root_new ['parrot';'Hash']
  vivify_244:
    set $P407, $P406["sym"]
    unless_null $P407, vivify_245
    new $P407, "Undef"
  vivify_245:
    set $S408, $P407
    find_lex $P409, "$/"
    $P410 = $P401."new"($P404, $P405, $S408 :named("pasttype"), $P409 :named("node"))
    store_lex "$past", $P410
.annotate 'line', 103
    set $P388, $P410
  if_389_end:
.annotate 'line', 102
    set $P385, $P388
  if_386_end:
.annotate 'line', 95
    .return ($P385)
.end


.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("32_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_432
    .param pmc param_433
.annotate 'line', 121
    .lex "self", param_432
    .lex "$/", param_433
.annotate 'line', 122
    find_lex $P434, "$/"
    get_hll_global $P435, ["PAST"], "Op"
    find_lex $P436, "$/"
    unless_null $P436, vivify_246
    $P436 = root_new ['parrot';'Hash']
  vivify_246:
    set $P437, $P436["EXPR"]
    unless_null $P437, vivify_247
    new $P437, "Undef"
  vivify_247:
    $P438 = $P437."ast"()
    find_lex $P439, "$/"
    unless_null $P439, vivify_248
    $P439 = root_new ['parrot';'Hash']
  vivify_248:
    set $P440, $P439["pblock"]
    unless_null $P440, vivify_249
    new $P440, "Undef"
  vivify_249:
    $P441 = $P440."ast"()
    find_lex $P442, "$/"
    $P443 = $P435."new"($P438, $P441, "if" :named("pasttype"), $P442 :named("node"))
    $P444 = $P434."!make"($P443)
.annotate 'line', 121
    .return ($P444)
.end


.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("33_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_446
    .param pmc param_447
.annotate 'line', 125
    .lex "self", param_446
    .lex "$/", param_447
.annotate 'line', 126
    find_lex $P448, "$/"
    find_lex $P449, "$/"
    unless_null $P449, vivify_250
    $P449 = root_new ['parrot';'Hash']
  vivify_250:
    set $P450, $P449["blockoid"]
    unless_null $P450, vivify_251
    new $P450, "Undef"
  vivify_251:
    $P451 = $P450."ast"()
    $P452 = $P448."!make"($P451)
.annotate 'line', 125
    .return ($P452)
.end


.namespace ["NQP";"Actions"]
.sub "block"  :subid("34_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_454
    .param pmc param_455
.annotate 'line', 129
    .lex "self", param_454
    .lex "$/", param_455
.annotate 'line', 130
    find_lex $P456, "$/"
    find_lex $P457, "$/"
    unless_null $P457, vivify_252
    $P457 = root_new ['parrot';'Hash']
  vivify_252:
    set $P458, $P457["blockoid"]
    unless_null $P458, vivify_253
    new $P458, "Undef"
  vivify_253:
    $P459 = $P458."ast"()
    $P460 = $P456."!make"($P459)
.annotate 'line', 129
    .return ($P460)
.end


.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("35_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_462
    .param pmc param_463
.annotate 'line', 133
    .const 'Sub' $P469 = "36_1298839287.218" 
    capture_lex $P469
    .lex "self", param_462
    .lex "$/", param_463
.annotate 'line', 134
    find_lex $P466, "$/"
    unless_null $P466, vivify_254
    $P466 = root_new ['parrot';'Hash']
  vivify_254:
    set $P467, $P466["statementlist"]
    unless_null $P467, vivify_255
    new $P467, "Undef"
  vivify_255:
    if $P467, if_465
.annotate 'line', 143
    find_lex $P486, "$/"
    find_lex $P487, "$/"
    unless_null $P487, vivify_256
    $P487 = root_new ['parrot';'Hash']
  vivify_256:
    set $P488, $P487["you_are_here"]
    unless_null $P488, vivify_257
    new $P488, "Undef"
  vivify_257:
    $P489 = $P488."ast"()
    $P490 = $P486."!make"($P489)
.annotate 'line', 142
    set $P464, $P490
.annotate 'line', 134
    goto if_465_end
  if_465:
    .const 'Sub' $P469 = "36_1298839287.218" 
    capture_lex $P469
    $P485 = $P469()
    set $P464, $P485
  if_465_end:
.annotate 'line', 133
    .return ($P464)
.end


.namespace ["NQP";"Actions"]
.sub "_block468"  :anon :subid("36_1298839287.218") :outer("35_1298839287.218")
.annotate 'line', 135
    new $P470, "Undef"
    .lex "$past", $P470
.annotate 'line', 136
    new $P471, "Undef"
    .lex "$BLOCK", $P471
.annotate 'line', 135
    find_lex $P472, "$/"
    unless_null $P472, vivify_258
    $P472 = root_new ['parrot';'Hash']
  vivify_258:
    set $P473, $P472["statementlist"]
    unless_null $P473, vivify_259
    new $P473, "Undef"
  vivify_259:
    $P474 = $P473."ast"()
    store_lex "$past", $P474
.annotate 'line', 136
    get_global $P475, "@BLOCK"
    $P476 = $P475."shift"()
    store_lex "$BLOCK", $P476
.annotate 'line', 137
    find_lex $P477, "$BLOCK"
    find_lex $P478, "$past"
    $P477."push"($P478)
.annotate 'line', 138
    find_lex $P479, "$BLOCK"
    find_lex $P480, "$/"
    $P479."node"($P480)
.annotate 'line', 139
    find_lex $P481, "$BLOCK"
    $P481."closure"(1)
.annotate 'line', 140
    find_dynamic_lex $P482, "$/"
    find_lex $P483, "$BLOCK"
    $P484 = $P482."!make"($P483)
.annotate 'line', 134
    .return ($P484)
.end


.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("37_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_492
    .param pmc param_493
.annotate 'line', 147
    .lex "self", param_492
    .lex "$/", param_493
.annotate 'line', 148
    get_global $P494, "@BLOCK"
    unless_null $P494, vivify_260
    $P494 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P494
  vivify_260:
.annotate 'line', 147
    get_global $P495, "@BLOCK"
.annotate 'line', 149
    get_global $P496, "@BLOCK"
    get_hll_global $P497, ["PAST"], "Block"
    get_hll_global $P498, ["PAST"], "Stmts"
    $P499 = $P498."new"()
    $P500 = $P497."new"($P499)
    $P501 = $P496."unshift"($P500)
.annotate 'line', 147
    .return ($P501)
.end


.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("38_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_503
    .param pmc param_504
.annotate 'line', 152
    .lex "self", param_503
    .lex "$/", param_504
.annotate 'line', 153
    get_global $P505, "@BLOCK"
    unless_null $P505, vivify_261
    $P505 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P505
  vivify_261:
.annotate 'line', 152
    get_global $P506, "@BLOCK"
.annotate 'line', 154
    find_lex $P507, "self"
    get_global $P508, "@BLOCK"
    unless_null $P508, vivify_262
    $P508 = root_new ['parrot';'ResizablePMCArray']
  vivify_262:
    set $P509, $P508[0]
    unless_null $P509, vivify_263
    new $P509, "Undef"
  vivify_263:
    $P510 = $P507."SET_BLOCK_OUTER_CTX"($P509)
.annotate 'line', 152
    .return ($P510)
.end


.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("39_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_512
    .param pmc param_513
.annotate 'line', 157
    .lex "self", param_512
    .lex "$/", param_513
.annotate 'line', 158
    find_lex $P514, "$/"
    find_lex $P515, "self"
    $P516 = $P515."CTXSAVE"()
    $P517 = $P514."!make"($P516)
.annotate 'line', 157
    .return ($P517)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("40_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_519
    .param pmc param_520
.annotate 'line', 163
    .const 'Sub' $P548 = "41_1298839287.218" 
    capture_lex $P548
    .lex "self", param_519
    .lex "$/", param_520
.annotate 'line', 164
    new $P521, "Undef"
    .lex "$count", $P521
.annotate 'line', 165
    new $P522, "Undef"
    .lex "$past", $P522
.annotate 'line', 164
    find_lex $P523, "$/"
    unless_null $P523, vivify_264
    $P523 = root_new ['parrot';'Hash']
  vivify_264:
    set $P524, $P523["xblock"]
    unless_null $P524, vivify_265
    new $P524, "Undef"
  vivify_265:
    set $N525, $P524
    new $P526, 'Float'
    set $P526, $N525
    sub $P527, $P526, 1
    store_lex "$count", $P527
.annotate 'line', 165
    find_lex $P528, "$count"
    set $I529, $P528
    find_lex $P530, "$/"
    unless_null $P530, vivify_266
    $P530 = root_new ['parrot';'Hash']
  vivify_266:
    set $P531, $P530["xblock"]
    unless_null $P531, vivify_267
    $P531 = root_new ['parrot';'ResizablePMCArray']
  vivify_267:
    set $P532, $P531[$I529]
    unless_null $P532, vivify_268
    new $P532, "Undef"
  vivify_268:
    $P533 = $P532."ast"()
    $P534 = "xblock_immediate"($P533)
    store_lex "$past", $P534
.annotate 'line', 166
    find_lex $P536, "$/"
    unless_null $P536, vivify_269
    $P536 = root_new ['parrot';'Hash']
  vivify_269:
    set $P537, $P536["else"]
    unless_null $P537, vivify_270
    new $P537, "Undef"
  vivify_270:
    unless $P537, if_535_end
.annotate 'line', 167
    find_lex $P538, "$past"
    find_lex $P539, "$/"
    unless_null $P539, vivify_271
    $P539 = root_new ['parrot';'Hash']
  vivify_271:
    set $P540, $P539["else"]
    unless_null $P540, vivify_272
    $P540 = root_new ['parrot';'ResizablePMCArray']
  vivify_272:
    set $P541, $P540[0]
    unless_null $P541, vivify_273
    new $P541, "Undef"
  vivify_273:
    $P542 = $P541."ast"()
    $P543 = "block_immediate"($P542)
    $P538."push"($P543)
  if_535_end:
.annotate 'line', 170
    new $P564, 'ExceptionHandler'
    set_label $P564, loop563_handler
    $P564."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P564
  loop563_test:
    find_lex $P544, "$count"
    set $N545, $P544
    isgt $I546, $N545, 0.0
    unless $I546, loop563_done
  loop563_redo:
    .const 'Sub' $P548 = "41_1298839287.218" 
    capture_lex $P548
    $P548()
  loop563_next:
    goto loop563_test
  loop563_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P565, exception, 'type'
    eq $P565, .CONTROL_LOOP_NEXT, loop563_next
    eq $P565, .CONTROL_LOOP_REDO, loop563_redo
  loop563_done:
    pop_eh 
.annotate 'line', 176
    find_lex $P566, "$/"
    find_lex $P567, "$past"
    $P568 = $P566."!make"($P567)
.annotate 'line', 163
    .return ($P568)
.end


.namespace ["NQP";"Actions"]
.sub "_block547"  :anon :subid("41_1298839287.218") :outer("40_1298839287.218")
.annotate 'line', 172
    new $P549, "Undef"
    .lex "$else", $P549
.annotate 'line', 170
    find_lex $P550, "$count"
    clone $P551, $P550
    dec $P550
.annotate 'line', 172
    find_lex $P552, "$past"
    store_lex "$else", $P552
.annotate 'line', 173
    find_lex $P553, "$count"
    set $I554, $P553
    find_lex $P555, "$/"
    unless_null $P555, vivify_274
    $P555 = root_new ['parrot';'Hash']
  vivify_274:
    set $P556, $P555["xblock"]
    unless_null $P556, vivify_275
    $P556 = root_new ['parrot';'ResizablePMCArray']
  vivify_275:
    set $P557, $P556[$I554]
    unless_null $P557, vivify_276
    new $P557, "Undef"
  vivify_276:
    $P558 = $P557."ast"()
    $P559 = "xblock_immediate"($P558)
    store_lex "$past", $P559
.annotate 'line', 174
    find_lex $P560, "$past"
    find_lex $P561, "$else"
    $P562 = $P560."push"($P561)
.annotate 'line', 170
    .return ($P562)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("42_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_570
    .param pmc param_571
.annotate 'line', 179
    .lex "self", param_570
    .lex "$/", param_571
.annotate 'line', 180
    new $P572, "Undef"
    .lex "$past", $P572
    find_lex $P573, "$/"
    unless_null $P573, vivify_277
    $P573 = root_new ['parrot';'Hash']
  vivify_277:
    set $P574, $P573["xblock"]
    unless_null $P574, vivify_278
    new $P574, "Undef"
  vivify_278:
    $P575 = $P574."ast"()
    $P576 = "xblock_immediate"($P575)
    store_lex "$past", $P576
.annotate 'line', 181
    find_lex $P577, "$past"
    $P577."pasttype"("unless")
.annotate 'line', 182
    find_lex $P578, "$/"
    find_lex $P579, "$past"
    $P580 = $P578."!make"($P579)
.annotate 'line', 179
    .return ($P580)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("43_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_582
    .param pmc param_583
.annotate 'line', 185
    .lex "self", param_582
    .lex "$/", param_583
.annotate 'line', 186
    new $P584, "Undef"
    .lex "$past", $P584
    find_lex $P585, "$/"
    unless_null $P585, vivify_279
    $P585 = root_new ['parrot';'Hash']
  vivify_279:
    set $P586, $P585["xblock"]
    unless_null $P586, vivify_280
    new $P586, "Undef"
  vivify_280:
    $P587 = $P586."ast"()
    $P588 = "xblock_immediate"($P587)
    store_lex "$past", $P588
.annotate 'line', 187
    find_lex $P589, "$past"
    find_lex $P590, "$/"
    unless_null $P590, vivify_281
    $P590 = root_new ['parrot';'Hash']
  vivify_281:
    set $P591, $P590["sym"]
    unless_null $P591, vivify_282
    new $P591, "Undef"
  vivify_282:
    set $S592, $P591
    $P589."pasttype"($S592)
.annotate 'line', 188
    find_lex $P593, "$/"
    find_lex $P594, "$past"
    $P595 = $P593."!make"($P594)
.annotate 'line', 185
    .return ($P595)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("44_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_597
    .param pmc param_598
.annotate 'line', 191
    .lex "self", param_597
    .lex "$/", param_598
.annotate 'line', 192
    new $P599, "Undef"
    .lex "$pasttype", $P599
.annotate 'line', 193
    new $P600, "Undef"
    .lex "$past", $P600
.annotate 'line', 192
    new $P601, "String"
    assign $P601, "repeat_"
    find_lex $P602, "$/"
    unless_null $P602, vivify_283
    $P602 = root_new ['parrot';'Hash']
  vivify_283:
    set $P603, $P602["wu"]
    unless_null $P603, vivify_284
    new $P603, "Undef"
  vivify_284:
    set $S604, $P603
    concat $P605, $P601, $S604
    store_lex "$pasttype", $P605
    find_lex $P606, "$past"
.annotate 'line', 194
    find_lex $P608, "$/"
    unless_null $P608, vivify_285
    $P608 = root_new ['parrot';'Hash']
  vivify_285:
    set $P609, $P608["xblock"]
    unless_null $P609, vivify_286
    new $P609, "Undef"
  vivify_286:
    if $P609, if_607
.annotate 'line', 199
    get_hll_global $P616, ["PAST"], "Op"
    find_lex $P617, "$/"
    unless_null $P617, vivify_287
    $P617 = root_new ['parrot';'Hash']
  vivify_287:
    set $P618, $P617["EXPR"]
    unless_null $P618, vivify_288
    new $P618, "Undef"
  vivify_288:
    $P619 = $P618."ast"()
    find_lex $P620, "$/"
    unless_null $P620, vivify_289
    $P620 = root_new ['parrot';'Hash']
  vivify_289:
    set $P621, $P620["pblock"]
    unless_null $P621, vivify_290
    new $P621, "Undef"
  vivify_290:
    $P622 = $P621."ast"()
    $P623 = "block_immediate"($P622)
    find_lex $P624, "$pasttype"
    find_lex $P625, "$/"
    $P626 = $P616."new"($P619, $P623, $P624 :named("pasttype"), $P625 :named("node"))
    store_lex "$past", $P626
.annotate 'line', 198
    goto if_607_end
  if_607:
.annotate 'line', 195
    find_lex $P610, "$/"
    unless_null $P610, vivify_291
    $P610 = root_new ['parrot';'Hash']
  vivify_291:
    set $P611, $P610["xblock"]
    unless_null $P611, vivify_292
    new $P611, "Undef"
  vivify_292:
    $P612 = $P611."ast"()
    $P613 = "xblock_immediate"($P612)
    store_lex "$past", $P613
.annotate 'line', 196
    find_lex $P614, "$past"
    find_lex $P615, "$pasttype"
    $P614."pasttype"($P615)
  if_607_end:
.annotate 'line', 202
    find_lex $P627, "$/"
    find_lex $P628, "$past"
    $P629 = $P627."!make"($P628)
.annotate 'line', 191
    .return ($P629)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("45_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_631
    .param pmc param_632
.annotate 'line', 205
    .lex "self", param_631
    .lex "$/", param_632
.annotate 'line', 206
    new $P633, "Undef"
    .lex "$past", $P633
.annotate 'line', 208
    new $P634, "Undef"
    .lex "$block", $P634
.annotate 'line', 206
    find_lex $P635, "$/"
    unless_null $P635, vivify_293
    $P635 = root_new ['parrot';'Hash']
  vivify_293:
    set $P636, $P635["xblock"]
    unless_null $P636, vivify_294
    new $P636, "Undef"
  vivify_294:
    $P637 = $P636."ast"()
    store_lex "$past", $P637
.annotate 'line', 207
    find_lex $P638, "$past"
    $P638."pasttype"("for")
.annotate 'line', 208
    find_lex $P639, "$past"
    unless_null $P639, vivify_295
    $P639 = root_new ['parrot';'ResizablePMCArray']
  vivify_295:
    set $P640, $P639[1]
    unless_null $P640, vivify_296
    new $P640, "Undef"
  vivify_296:
    store_lex "$block", $P640
.annotate 'line', 209
    find_lex $P642, "$block"
    $P643 = $P642."arity"()
    if $P643, unless_641_end
.annotate 'line', 210
    find_lex $P644, "$block"
    unless_null $P644, vivify_297
    $P644 = root_new ['parrot';'ResizablePMCArray']
  vivify_297:
    set $P645, $P644[0]
    unless_null $P645, vivify_298
    new $P645, "Undef"
  vivify_298:
    get_hll_global $P646, ["PAST"], "Var"
    $P647 = $P646."new"("$_" :named("name"), "parameter" :named("scope"))
    $P645."push"($P647)
.annotate 'line', 211
    find_lex $P648, "$block"
    $P648."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 212
    find_lex $P649, "$block"
    $P649."arity"(1)
  unless_641_end:
.annotate 'line', 214
    find_lex $P650, "$block"
    $P650."blocktype"("immediate")
.annotate 'line', 215
    find_lex $P651, "$/"
    find_lex $P652, "$past"
    $P653 = $P651."!make"($P652)
.annotate 'line', 205
    .return ($P653)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("46_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_655
    .param pmc param_656
.annotate 'line', 218
    .lex "self", param_655
    .lex "$/", param_656
.annotate 'line', 219
    new $P657, "Undef"
    .lex "$block", $P657
    find_lex $P658, "$/"
    unless_null $P658, vivify_299
    $P658 = root_new ['parrot';'Hash']
  vivify_299:
    set $P659, $P658["block"]
    unless_null $P659, vivify_300
    new $P659, "Undef"
  vivify_300:
    $P660 = $P659."ast"()
    store_lex "$block", $P660
.annotate 'line', 220
    find_lex $P661, "$/"
    find_lex $P662, "$block"
    "push_block_handler"($P661, $P662)
.annotate 'line', 221
    get_global $P663, "@BLOCK"
    unless_null $P663, vivify_301
    $P663 = root_new ['parrot';'ResizablePMCArray']
  vivify_301:
    set $P664, $P663[0]
    unless_null $P664, vivify_302
    new $P664, "Undef"
  vivify_302:
    $P665 = $P664."handlers"()
    set $P666, $P665[0]
    unless_null $P666, vivify_303
    new $P666, "Undef"
  vivify_303:
    $P666."handle_types_except"("CONTROL")
.annotate 'line', 222
    find_lex $P667, "$/"
    get_hll_global $P668, ["PAST"], "Stmts"
    find_lex $P669, "$/"
    $P670 = $P668."new"($P669 :named("node"))
    $P671 = $P667."!make"($P670)
.annotate 'line', 218
    .return ($P671)
.end


.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("47_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_673
    .param pmc param_674
.annotate 'line', 225
    .lex "self", param_673
    .lex "$/", param_674
.annotate 'line', 226
    new $P675, "Undef"
    .lex "$block", $P675
    find_lex $P676, "$/"
    unless_null $P676, vivify_304
    $P676 = root_new ['parrot';'Hash']
  vivify_304:
    set $P677, $P676["block"]
    unless_null $P677, vivify_305
    new $P677, "Undef"
  vivify_305:
    $P678 = $P677."ast"()
    store_lex "$block", $P678
.annotate 'line', 227
    find_lex $P679, "$/"
    find_lex $P680, "$block"
    "push_block_handler"($P679, $P680)
.annotate 'line', 228
    get_global $P681, "@BLOCK"
    unless_null $P681, vivify_306
    $P681 = root_new ['parrot';'ResizablePMCArray']
  vivify_306:
    set $P682, $P681[0]
    unless_null $P682, vivify_307
    new $P682, "Undef"
  vivify_307:
    $P683 = $P682."handlers"()
    set $P684, $P683[0]
    unless_null $P684, vivify_308
    new $P684, "Undef"
  vivify_308:
    $P684."handle_types"("CONTROL")
.annotate 'line', 229
    find_lex $P685, "$/"
    get_hll_global $P686, ["PAST"], "Stmts"
    find_lex $P687, "$/"
    $P688 = $P686."new"($P687 :named("node"))
    $P689 = $P685."!make"($P688)
.annotate 'line', 225
    .return ($P689)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("48_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_692
    .param pmc param_693
.annotate 'line', 269
    .lex "self", param_692
    .lex "$/", param_693
.annotate 'line', 270
    new $P694, "Undef"
    .lex "$init_block", $P694
    get_hll_global $P695, ["PAST"], "Block"
    $P696 = $P695."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P696
.annotate 'line', 271
    find_lex $P697, "$init_block"
    $P698 = $P697."loadinit"()
    find_lex $P699, "$/"
    unless_null $P699, vivify_309
    $P699 = root_new ['parrot';'Hash']
  vivify_309:
    set $P700, $P699["blorst"]
    unless_null $P700, vivify_310
    new $P700, "Undef"
  vivify_310:
    $P701 = $P700."ast"()
    $P698."push"($P701)
.annotate 'line', 272
    find_lex $P702, "$/"
    find_lex $P703, "$init_block"
    $P704 = $P702."!make"($P703)
.annotate 'line', 269
    .return ($P704)
.end


.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("49_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_706
    .param pmc param_707
.annotate 'line', 275
    .lex "self", param_706
    .lex "$/", param_707
.annotate 'line', 276
    new $P708, "Undef"
    .lex "$past", $P708
    find_lex $P709, "$/"
    unless_null $P709, vivify_311
    $P709 = root_new ['parrot';'Hash']
  vivify_311:
    set $P710, $P709["blorst"]
    unless_null $P710, vivify_312
    new $P710, "Undef"
  vivify_312:
    $P711 = $P710."ast"()
    store_lex "$past", $P711
.annotate 'line', 277
    get_hll_global $P713, ["PAST"], "Block"
    find_lex $P714, "$past"
    $P715 = $P713."ACCEPTS"($P714)
    if $P715, unless_712_end
.annotate 'line', 278
    get_hll_global $P716, ["PAST"], "Block"
    find_lex $P717, "$past"
    find_lex $P718, "$/"
    $P719 = $P716."new"($P717, "immediate" :named("blocktype"), $P718 :named("node"))
    store_lex "$past", $P719
  unless_712_end:
.annotate 'line', 280
    find_lex $P721, "$past"
    $P722 = $P721."handlers"()
    if $P722, unless_720_end
.annotate 'line', 281
    find_lex $P723, "$past"
    get_hll_global $P724, ["PAST"], "Control"
.annotate 'line', 283
    get_hll_global $P725, ["PAST"], "Stmts"
.annotate 'line', 284
    get_hll_global $P726, ["PAST"], "Op"
.annotate 'line', 285
    get_hll_global $P727, ["PAST"], "Var"
.annotate 'line', 286
    get_hll_global $P728, ["PAST"], "Var"
    $P729 = $P728."new"("register" :named("scope"), "exception" :named("name"))
    $P730 = $P727."new"($P729, "handled", "keyed" :named("scope"))
.annotate 'line', 285
    $P731 = $P726."new"($P730, 1, "bind" :named("pasttype"))
.annotate 'line', 284
    $P732 = $P725."new"($P731)
.annotate 'line', 283
    $P733 = $P724."new"($P732, "CONTROL" :named("handle_types_except"))
.annotate 'line', 281
    new $P734, "ResizablePMCArray"
    push $P734, $P733
    $P723."handlers"($P734)
  unless_720_end:
.annotate 'line', 295
    find_lex $P735, "$/"
    find_lex $P736, "$past"
    $P737 = $P735."!make"($P736)
.annotate 'line', 275
    .return ($P737)
.end


.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("50_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_739
    .param pmc param_740
.annotate 'line', 298
    .lex "self", param_739
    .lex "$/", param_740
.annotate 'line', 299
    find_lex $P741, "$/"
.annotate 'line', 300
    find_lex $P744, "$/"
    unless_null $P744, vivify_313
    $P744 = root_new ['parrot';'Hash']
  vivify_313:
    set $P745, $P744["block"]
    unless_null $P745, vivify_314
    new $P745, "Undef"
  vivify_314:
    if $P745, if_743
.annotate 'line', 301
    find_lex $P750, "$/"
    unless_null $P750, vivify_315
    $P750 = root_new ['parrot';'Hash']
  vivify_315:
    set $P751, $P750["statement"]
    unless_null $P751, vivify_316
    new $P751, "Undef"
  vivify_316:
    $P752 = $P751."ast"()
    set $P742, $P752
.annotate 'line', 300
    goto if_743_end
  if_743:
    find_lex $P746, "$/"
    unless_null $P746, vivify_317
    $P746 = root_new ['parrot';'Hash']
  vivify_317:
    set $P747, $P746["block"]
    unless_null $P747, vivify_318
    new $P747, "Undef"
  vivify_318:
    $P748 = $P747."ast"()
    $P749 = "block_immediate"($P748)
    set $P742, $P749
  if_743_end:
    $P753 = $P741."!make"($P742)
.annotate 'line', 298
    .return ($P753)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("51_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_755
    .param pmc param_756
.annotate 'line', 306
    .lex "self", param_755
    .lex "$/", param_756
    find_lex $P757, "$/"
    find_lex $P758, "$/"
    unless_null $P758, vivify_319
    $P758 = root_new ['parrot';'Hash']
  vivify_319:
    set $P759, $P758["cond"]
    unless_null $P759, vivify_320
    new $P759, "Undef"
  vivify_320:
    $P760 = $P759."ast"()
    $P761 = $P757."!make"($P760)
    .return ($P761)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("52_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_763
    .param pmc param_764
.annotate 'line', 307
    .lex "self", param_763
    .lex "$/", param_764
    find_lex $P765, "$/"
    find_lex $P766, "$/"
    unless_null $P766, vivify_321
    $P766 = root_new ['parrot';'Hash']
  vivify_321:
    set $P767, $P766["cond"]
    unless_null $P767, vivify_322
    new $P767, "Undef"
  vivify_322:
    $P768 = $P767."ast"()
    $P769 = $P765."!make"($P768)
    .return ($P769)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("53_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_771
    .param pmc param_772
.annotate 'line', 309
    .lex "self", param_771
    .lex "$/", param_772
    find_lex $P773, "$/"
    find_lex $P774, "$/"
    unless_null $P774, vivify_323
    $P774 = root_new ['parrot';'Hash']
  vivify_323:
    set $P775, $P774["cond"]
    unless_null $P775, vivify_324
    new $P775, "Undef"
  vivify_324:
    $P776 = $P775."ast"()
    $P777 = $P773."!make"($P776)
    .return ($P777)
.end


.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("54_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_779
    .param pmc param_780
.annotate 'line', 310
    .lex "self", param_779
    .lex "$/", param_780
    find_lex $P781, "$/"
    find_lex $P782, "$/"
    unless_null $P782, vivify_325
    $P782 = root_new ['parrot';'Hash']
  vivify_325:
    set $P783, $P782["cond"]
    unless_null $P783, vivify_326
    new $P783, "Undef"
  vivify_326:
    $P784 = $P783."ast"()
    $P785 = $P781."!make"($P784)
    .return ($P785)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("55_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_787
    .param pmc param_788
.annotate 'line', 314
    .lex "self", param_787
    .lex "$/", param_788
    find_lex $P789, "$/"
    find_lex $P790, "$/"
    unless_null $P790, vivify_327
    $P790 = root_new ['parrot';'Hash']
  vivify_327:
    set $P791, $P790["fatarrow"]
    unless_null $P791, vivify_328
    new $P791, "Undef"
  vivify_328:
    $P792 = $P791."ast"()
    $P793 = $P789."!make"($P792)
    .return ($P793)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("56_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_795
    .param pmc param_796
.annotate 'line', 315
    .lex "self", param_795
    .lex "$/", param_796
    find_lex $P797, "$/"
    find_lex $P798, "$/"
    unless_null $P798, vivify_329
    $P798 = root_new ['parrot';'Hash']
  vivify_329:
    set $P799, $P798["colonpair"]
    unless_null $P799, vivify_330
    new $P799, "Undef"
  vivify_330:
    $P800 = $P799."ast"()
    $P801 = $P797."!make"($P800)
    .return ($P801)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("57_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_803
    .param pmc param_804
.annotate 'line', 316
    .lex "self", param_803
    .lex "$/", param_804
    find_lex $P805, "$/"
    find_lex $P806, "$/"
    unless_null $P806, vivify_331
    $P806 = root_new ['parrot';'Hash']
  vivify_331:
    set $P807, $P806["variable"]
    unless_null $P807, vivify_332
    new $P807, "Undef"
  vivify_332:
    $P808 = $P807."ast"()
    $P809 = $P805."!make"($P808)
    .return ($P809)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("58_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_811
    .param pmc param_812
.annotate 'line', 317
    .lex "self", param_811
    .lex "$/", param_812
    find_lex $P813, "$/"
    find_lex $P814, "$/"
    unless_null $P814, vivify_333
    $P814 = root_new ['parrot';'Hash']
  vivify_333:
    set $P815, $P814["package_declarator"]
    unless_null $P815, vivify_334
    new $P815, "Undef"
  vivify_334:
    $P816 = $P815."ast"()
    $P817 = $P813."!make"($P816)
    .return ($P817)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("59_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_819
    .param pmc param_820
.annotate 'line', 318
    .lex "self", param_819
    .lex "$/", param_820
    find_lex $P821, "$/"
    find_lex $P822, "$/"
    unless_null $P822, vivify_335
    $P822 = root_new ['parrot';'Hash']
  vivify_335:
    set $P823, $P822["scope_declarator"]
    unless_null $P823, vivify_336
    new $P823, "Undef"
  vivify_336:
    $P824 = $P823."ast"()
    $P825 = $P821."!make"($P824)
    .return ($P825)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("60_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_827
    .param pmc param_828
.annotate 'line', 319
    .lex "self", param_827
    .lex "$/", param_828
    find_lex $P829, "$/"
    find_lex $P830, "$/"
    unless_null $P830, vivify_337
    $P830 = root_new ['parrot';'Hash']
  vivify_337:
    set $P831, $P830["routine_declarator"]
    unless_null $P831, vivify_338
    new $P831, "Undef"
  vivify_338:
    $P832 = $P831."ast"()
    $P833 = $P829."!make"($P832)
    .return ($P833)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("61_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_835
    .param pmc param_836
.annotate 'line', 320
    .lex "self", param_835
    .lex "$/", param_836
    find_lex $P837, "$/"
    find_lex $P838, "$/"
    unless_null $P838, vivify_339
    $P838 = root_new ['parrot';'Hash']
  vivify_339:
    set $P839, $P838["regex_declarator"]
    unless_null $P839, vivify_340
    new $P839, "Undef"
  vivify_340:
    $P840 = $P839."ast"()
    $P841 = $P837."!make"($P840)
    .return ($P841)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("62_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_843
    .param pmc param_844
.annotate 'line', 321
    .lex "self", param_843
    .lex "$/", param_844
    find_lex $P845, "$/"
    find_lex $P846, "$/"
    unless_null $P846, vivify_341
    $P846 = root_new ['parrot';'Hash']
  vivify_341:
    set $P847, $P846["statement_prefix"]
    unless_null $P847, vivify_342
    new $P847, "Undef"
  vivify_342:
    $P848 = $P847."ast"()
    $P849 = $P845."!make"($P848)
    .return ($P849)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("63_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_851
    .param pmc param_852
.annotate 'line', 322
    .lex "self", param_851
    .lex "$/", param_852
    find_lex $P853, "$/"
    find_lex $P854, "$/"
    unless_null $P854, vivify_343
    $P854 = root_new ['parrot';'Hash']
  vivify_343:
    set $P855, $P854["pblock"]
    unless_null $P855, vivify_344
    new $P855, "Undef"
  vivify_344:
    $P856 = $P855."ast"()
    $P857 = $P853."!make"($P856)
    .return ($P857)
.end


.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("64_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_859
    .param pmc param_860
.annotate 'line', 324
    .lex "self", param_859
    .lex "$/", param_860
.annotate 'line', 325
    new $P861, "Undef"
    .lex "$past", $P861
    find_lex $P862, "$/"
    unless_null $P862, vivify_345
    $P862 = root_new ['parrot';'Hash']
  vivify_345:
    set $P863, $P862["val"]
    unless_null $P863, vivify_346
    new $P863, "Undef"
  vivify_346:
    $P864 = $P863."ast"()
    store_lex "$past", $P864
.annotate 'line', 326
    find_lex $P865, "$past"
    find_lex $P866, "$/"
    unless_null $P866, vivify_347
    $P866 = root_new ['parrot';'Hash']
  vivify_347:
    set $P867, $P866["key"]
    unless_null $P867, vivify_348
    new $P867, "Undef"
  vivify_348:
    $P868 = $P867."Str"()
    $P865."named"($P868)
.annotate 'line', 327
    find_lex $P869, "$/"
    find_lex $P870, "$past"
    $P871 = $P869."!make"($P870)
.annotate 'line', 324
    .return ($P871)
.end


.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("65_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_873
    .param pmc param_874
.annotate 'line', 330
    .lex "self", param_873
    .lex "$/", param_874
.annotate 'line', 331
    new $P875, "Undef"
    .lex "$past", $P875
.annotate 'line', 332
    find_lex $P878, "$/"
    unless_null $P878, vivify_349
    $P878 = root_new ['parrot';'Hash']
  vivify_349:
    set $P879, $P878["circumfix"]
    unless_null $P879, vivify_350
    new $P879, "Undef"
  vivify_350:
    if $P879, if_877
.annotate 'line', 333
    get_hll_global $P884, ["PAST"], "Val"
    find_lex $P885, "$/"
    unless_null $P885, vivify_351
    $P885 = root_new ['parrot';'Hash']
  vivify_351:
    set $P886, $P885["not"]
    unless_null $P886, vivify_352
    new $P886, "Undef"
  vivify_352:
    isfalse $I887, $P886
    $P888 = $P884."new"($I887 :named("value"))
    set $P876, $P888
.annotate 'line', 332
    goto if_877_end
  if_877:
    find_lex $P880, "$/"
    unless_null $P880, vivify_353
    $P880 = root_new ['parrot';'Hash']
  vivify_353:
    set $P881, $P880["circumfix"]
    unless_null $P881, vivify_354
    $P881 = root_new ['parrot';'ResizablePMCArray']
  vivify_354:
    set $P882, $P881[0]
    unless_null $P882, vivify_355
    new $P882, "Undef"
  vivify_355:
    $P883 = $P882."ast"()
    set $P876, $P883
  if_877_end:
    store_lex "$past", $P876
.annotate 'line', 334
    find_lex $P889, "$past"
    find_lex $P890, "$/"
    unless_null $P890, vivify_356
    $P890 = root_new ['parrot';'Hash']
  vivify_356:
    set $P891, $P890["identifier"]
    unless_null $P891, vivify_357
    new $P891, "Undef"
  vivify_357:
    set $S892, $P891
    $P889."named"($S892)
.annotate 'line', 335
    find_lex $P893, "$/"
    find_lex $P894, "$past"
    $P895 = $P893."!make"($P894)
.annotate 'line', 330
    .return ($P895)
.end


.namespace ["NQP";"Actions"]
.sub "variable"  :subid("66_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_897
    .param pmc param_898
.annotate 'line', 338
    .const 'Sub' $P911 = "67_1298839287.218" 
    capture_lex $P911
    .lex "self", param_897
    .lex "$/", param_898
.annotate 'line', 339
    new $P899, "Undef"
    .lex "$past", $P899
.annotate 'line', 338
    find_lex $P900, "$past"
.annotate 'line', 340
    find_lex $P902, "$/"
    unless_null $P902, vivify_358
    $P902 = root_new ['parrot';'Hash']
  vivify_358:
    set $P903, $P902["postcircumfix"]
    unless_null $P903, vivify_359
    new $P903, "Undef"
  vivify_359:
    if $P903, if_901
.annotate 'line', 344
    .const 'Sub' $P911 = "67_1298839287.218" 
    capture_lex $P911
    $P911()
    goto if_901_end
  if_901:
.annotate 'line', 341
    find_lex $P904, "$/"
    unless_null $P904, vivify_376
    $P904 = root_new ['parrot';'Hash']
  vivify_376:
    set $P905, $P904["postcircumfix"]
    unless_null $P905, vivify_377
    new $P905, "Undef"
  vivify_377:
    $P906 = $P905."ast"()
    store_lex "$past", $P906
.annotate 'line', 342
    find_lex $P907, "$past"
    get_hll_global $P908, ["PAST"], "Var"
    $P909 = $P908."new"("$/" :named("name"))
    $P907."unshift"($P909)
  if_901_end:
.annotate 'line', 374
    find_lex $P983, "$/"
    find_lex $P984, "$past"
    $P985 = $P983."!make"($P984)
.annotate 'line', 338
    .return ($P985)
.end


.namespace ["NQP";"Actions"]
.sub "_block910"  :anon :subid("67_1298839287.218") :outer("66_1298839287.218")
.annotate 'line', 345
    $P912 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P912
    get_hll_global $P913, ["NQP"], "Compiler"
    find_lex $P914, "$/"
    set $S915, $P914
    $P916 = $P913."parse_name"($S915)
    store_lex "@name", $P916
.annotate 'line', 346
    get_hll_global $P917, ["PAST"], "Var"
    find_lex $P918, "@name"
    $P919 = $P918."pop"()
    set $S920, $P919
    $P921 = $P917."new"($S920 :named("name"))
    store_lex "$past", $P921
.annotate 'line', 347
    find_lex $P923, "@name"
    unless $P923, if_922_end
.annotate 'line', 348
    find_lex $P925, "@name"
    unless_null $P925, vivify_360
    $P925 = root_new ['parrot';'ResizablePMCArray']
  vivify_360:
    set $P926, $P925[0]
    unless_null $P926, vivify_361
    new $P926, "Undef"
  vivify_361:
    set $S927, $P926
    iseq $I928, $S927, "GLOBAL"
    unless $I928, if_924_end
    find_lex $P929, "@name"
    $P929."shift"()
  if_924_end:
.annotate 'line', 349
    find_lex $P930, "$past"
    find_lex $P931, "@name"
    $P930."namespace"($P931)
.annotate 'line', 350
    find_lex $P932, "$past"
    $P932."scope"("package")
.annotate 'line', 351
    find_lex $P933, "$past"
    find_lex $P934, "$/"
    unless_null $P934, vivify_362
    $P934 = root_new ['parrot';'Hash']
  vivify_362:
    set $P935, $P934["sigil"]
    unless_null $P935, vivify_363
    new $P935, "Undef"
  vivify_363:
    $P936 = "vivitype"($P935)
    $P933."viviself"($P936)
.annotate 'line', 352
    find_lex $P937, "$past"
    $P937."lvalue"(1)
  if_922_end:
.annotate 'line', 354
    find_lex $P940, "$/"
    unless_null $P940, vivify_364
    $P940 = root_new ['parrot';'Hash']
  vivify_364:
    set $P941, $P940["twigil"]
    unless_null $P941, vivify_365
    $P941 = root_new ['parrot';'ResizablePMCArray']
  vivify_365:
    set $P942, $P941[0]
    unless_null $P942, vivify_366
    new $P942, "Undef"
  vivify_366:
    set $S943, $P942
    iseq $I944, $S943, "*"
    if $I944, if_939
.annotate 'line', 367
    find_lex $P966, "$/"
    unless_null $P966, vivify_367
    $P966 = root_new ['parrot';'Hash']
  vivify_367:
    set $P967, $P966["twigil"]
    unless_null $P967, vivify_368
    $P967 = root_new ['parrot';'ResizablePMCArray']
  vivify_368:
    set $P968, $P967[0]
    unless_null $P968, vivify_369
    new $P968, "Undef"
  vivify_369:
    set $S969, $P968
    iseq $I970, $S969, "!"
    if $I970, if_965
    new $P964, 'Integer'
    set $P964, $I970
    goto if_965_end
  if_965:
.annotate 'line', 368
    find_lex $P971, "$past"
    get_hll_global $P972, ["PAST"], "Var"
    $P973 = $P972."new"("self" :named("name"))
    $P971."push"($P973)
.annotate 'line', 369
    find_lex $P974, "$past"
    $P974."scope"("attribute")
.annotate 'line', 370
    find_lex $P975, "$past"
    find_lex $P976, "$/"
    unless_null $P976, vivify_370
    $P976 = root_new ['parrot';'Hash']
  vivify_370:
    set $P977, $P976["sigil"]
    unless_null $P977, vivify_371
    new $P977, "Undef"
  vivify_371:
    $P978 = "vivitype"($P977)
    $P975."viviself"($P978)
.annotate 'line', 371
    find_lex $P979, "$past"
    get_hll_global $P980, ["PAST"], "Var"
    $P981 = $P980."new"("$?CLASS" :named("name"))
    $P982 = $P979."push"($P981)
.annotate 'line', 367
    set $P964, $P982
  if_965_end:
    set $P938, $P964
.annotate 'line', 354
    goto if_939_end
  if_939:
.annotate 'line', 355
    find_lex $P945, "$past"
    $P945."scope"("contextual")
.annotate 'line', 356
    find_lex $P946, "$past"
.annotate 'line', 357
    get_hll_global $P947, ["PAST"], "Var"
.annotate 'line', 359
    find_lex $P948, "$/"
    unless_null $P948, vivify_372
    $P948 = root_new ['parrot';'Hash']
  vivify_372:
    set $P949, $P948["sigil"]
    unless_null $P949, vivify_373
    new $P949, "Undef"
  vivify_373:
    set $S950, $P949
    new $P951, 'String'
    set $P951, $S950
    find_lex $P952, "$/"
    unless_null $P952, vivify_374
    $P952 = root_new ['parrot';'Hash']
  vivify_374:
    set $P953, $P952["desigilname"]
    unless_null $P953, vivify_375
    new $P953, "Undef"
  vivify_375:
    concat $P954, $P951, $P953
.annotate 'line', 361
    get_hll_global $P955, ["PAST"], "Op"
    new $P956, "String"
    assign $P956, "Contextual "
    find_lex $P957, "$/"
    set $S958, $P957
    concat $P959, $P956, $S958
    concat $P960, $P959, " not found"
    $P961 = $P955."new"($P960, "die" :named("pirop"))
    $P962 = $P947."new"("package" :named("scope"), "" :named("namespace"), $P954 :named("name"), $P961 :named("viviself"))
.annotate 'line', 357
    $P963 = $P946."viviself"($P962)
.annotate 'line', 354
    set $P938, $P963
  if_939_end:
.annotate 'line', 344
    .return ($P938)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("68_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_987
    .param pmc param_988
.annotate 'line', 377
    .lex "self", param_987
    .lex "$/", param_988
    find_lex $P989, "$/"
    find_lex $P990, "$/"
    unless_null $P990, vivify_378
    $P990 = root_new ['parrot';'Hash']
  vivify_378:
    set $P991, $P990["package_def"]
    unless_null $P991, vivify_379
    new $P991, "Undef"
  vivify_379:
    $P992 = $P991."ast"()
    $P993 = $P989."!make"($P992)
    .return ($P993)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("69_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_995
    .param pmc param_996
.annotate 'line', 378
    .lex "self", param_995
    .lex "$/", param_996
    find_lex $P997, "$/"
    find_lex $P998, "$/"
    unless_null $P998, vivify_380
    $P998 = root_new ['parrot';'Hash']
  vivify_380:
    set $P999, $P998["package_def"]
    unless_null $P999, vivify_381
    new $P999, "Undef"
  vivify_381:
    $P1000 = $P999."ast"()
    $P1001 = $P997."!make"($P1000)
    .return ($P1001)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("70_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1003
    .param pmc param_1004
.annotate 'line', 379
    .lex "self", param_1003
    .lex "$/", param_1004
    find_lex $P1005, "$/"
    find_lex $P1006, "$/"
    unless_null $P1006, vivify_382
    $P1006 = root_new ['parrot';'Hash']
  vivify_382:
    set $P1007, $P1006["package_def"]
    unless_null $P1007, vivify_383
    new $P1007, "Undef"
  vivify_383:
    $P1008 = $P1007."ast"()
    $P1009 = $P1005."!make"($P1008)
    .return ($P1009)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("71_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1011
    .param pmc param_1012
.annotate 'line', 380
    .lex "self", param_1011
    .lex "$/", param_1012
    find_lex $P1013, "$/"
    find_lex $P1014, "$/"
    unless_null $P1014, vivify_384
    $P1014 = root_new ['parrot';'Hash']
  vivify_384:
    set $P1015, $P1014["package_def"]
    unless_null $P1015, vivify_385
    new $P1015, "Undef"
  vivify_385:
    $P1016 = $P1015."ast"()
    $P1017 = $P1013."!make"($P1016)
    .return ($P1017)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("72_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1019
    .param pmc param_1020
.annotate 'line', 381
    .lex "self", param_1019
    .lex "$/", param_1020
    find_lex $P1021, "$/"
    find_lex $P1022, "$/"
    unless_null $P1022, vivify_386
    $P1022 = root_new ['parrot';'Hash']
  vivify_386:
    set $P1023, $P1022["package_def"]
    unless_null $P1023, vivify_387
    new $P1023, "Undef"
  vivify_387:
    $P1024 = $P1023."ast"()
    $P1025 = $P1021."!make"($P1024)
    .return ($P1025)
.end


.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("73_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1027
    .param pmc param_1028
.annotate 'line', 382
    .lex "self", param_1027
    .lex "$/", param_1028
    find_lex $P1029, "$/"
    find_lex $P1030, "$/"
    unless_null $P1030, vivify_388
    $P1030 = root_new ['parrot';'Hash']
  vivify_388:
    set $P1031, $P1030["package_def"]
    unless_null $P1031, vivify_389
    new $P1031, "Undef"
  vivify_389:
    $P1032 = $P1031."ast"()
    $P1033 = $P1029."!make"($P1032)
    .return ($P1033)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("74_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1035
    .param pmc param_1036
.annotate 'line', 384
    .const 'Sub' $P1195 = "77_1298839287.218" 
    capture_lex $P1195
    .const 'Sub' $P1144 = "76_1298839287.218" 
    capture_lex $P1144
    .const 'Sub' $P1102 = "75_1298839287.218" 
    capture_lex $P1102
    .lex "self", param_1035
    .lex "$/", param_1036
.annotate 'line', 386
    $P1037 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1037
.annotate 'line', 387
    new $P1038, "Undef"
    .lex "$name", $P1038
.annotate 'line', 388
    new $P1039, "Undef"
    .lex "$how", $P1039
.annotate 'line', 391
    new $P1040, "Undef"
    .lex "$past", $P1040
.annotate 'line', 386
    find_lex $P1041, "$/"
    unless_null $P1041, vivify_390
    $P1041 = root_new ['parrot';'Hash']
  vivify_390:
    set $P1042, $P1041["name"]
    unless_null $P1042, vivify_391
    $P1042 = root_new ['parrot';'Hash']
  vivify_391:
    set $P1043, $P1042["identifier"]
    unless_null $P1043, vivify_392
    new $P1043, "Undef"
  vivify_392:
    clone $P1044, $P1043
    store_lex "@ns", $P1044
.annotate 'line', 387
    find_lex $P1045, "@ns"
    $P1046 = $P1045."pop"()
    set $S1047, $P1046
    new $P1048, 'String'
    set $P1048, $S1047
    store_lex "$name", $P1048
.annotate 'line', 388
    find_dynamic_lex $P1049, "$*PKGDECL"
    unless_null $P1049, vivify_393
    get_hll_global $P1049, "$PKGDECL"
    unless_null $P1049, vivify_394
    die "Contextual $*PKGDECL not found"
  vivify_394:
  vivify_393:
    find_dynamic_lex $P1050, "%*HOW"
    unless_null $P1050, vivify_395
    get_hll_global $P1050, "%HOW"
    unless_null $P1050, vivify_396
    die "Contextual %*HOW not found"
  vivify_396:
  vivify_395:
    set $P1051, $P1050[$P1049]
    unless_null $P1051, vivify_397
    new $P1051, "Undef"
  vivify_397:
    store_lex "$how", $P1051
.annotate 'line', 391
    find_lex $P1054, "$/"
    unless_null $P1054, vivify_398
    $P1054 = root_new ['parrot';'Hash']
  vivify_398:
    set $P1055, $P1054["block"]
    unless_null $P1055, vivify_399
    new $P1055, "Undef"
  vivify_399:
    if $P1055, if_1053
    find_lex $P1059, "$/"
    unless_null $P1059, vivify_400
    $P1059 = root_new ['parrot';'Hash']
  vivify_400:
    set $P1060, $P1059["comp_unit"]
    unless_null $P1060, vivify_401
    new $P1060, "Undef"
  vivify_401:
    $P1061 = $P1060."ast"()
    set $P1052, $P1061
    goto if_1053_end
  if_1053:
    find_lex $P1056, "$/"
    unless_null $P1056, vivify_402
    $P1056 = root_new ['parrot';'Hash']
  vivify_402:
    set $P1057, $P1056["block"]
    unless_null $P1057, vivify_403
    new $P1057, "Undef"
  vivify_403:
    $P1058 = $P1057."ast"()
    set $P1052, $P1058
  if_1053_end:
    store_lex "$past", $P1052
.annotate 'line', 392
    find_lex $P1062, "$past"
    find_lex $P1063, "$/"
    unless_null $P1063, vivify_404
    $P1063 = root_new ['parrot';'Hash']
  vivify_404:
    set $P1064, $P1063["name"]
    unless_null $P1064, vivify_405
    $P1064 = root_new ['parrot';'Hash']
  vivify_405:
    set $P1065, $P1064["identifier"]
    unless_null $P1065, vivify_406
    new $P1065, "Undef"
  vivify_406:
    $P1062."namespace"($P1065)
.annotate 'line', 396
    find_dynamic_lex $P1066, "$*PACKAGE-SETUP"
    unless_null $P1066, vivify_407
    get_hll_global $P1066, "$PACKAGE-SETUP"
    unless_null $P1066, vivify_408
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_408:
  vivify_407:
    get_hll_global $P1067, ["PAST"], "Stmts"
.annotate 'line', 397
    get_hll_global $P1068, ["PAST"], "Op"
.annotate 'line', 398
    get_hll_global $P1069, ["PAST"], "Var"
    $P1070 = $P1069."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 399
    get_hll_global $P1071, ["PAST"], "Op"
.annotate 'line', 401
    get_hll_global $P1072, ["PAST"], "Var"
    find_lex $P1073, "$how"
    get_how $P1074, $P1073
    find_lex $P1075, "$how"
    $P1076 = $P1074."name"($P1075)
    $P1077 = $P1072."new"($P1076 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 402
    get_hll_global $P1078, ["PAST"], "Val"
    find_lex $P1079, "$name"
    $P1080 = $P1078."new"($P1079 :named("value"), "name" :named("named"))
    $P1081 = $P1071."new"($P1077, $P1080, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 399
    $P1082 = $P1068."new"($P1070, $P1081, "bind" :named("pasttype"))
.annotate 'line', 405
    get_hll_global $P1083, ["PAST"], "Op"
.annotate 'line', 406
    get_hll_global $P1084, ["PAST"], "Var"
    find_lex $P1085, "$name"
    find_lex $P1086, "@ns"
    $P1087 = $P1084."new"($P1085 :named("name"), $P1086 :named("namespace"), "package" :named("scope"))
.annotate 'line', 407
    get_hll_global $P1088, ["PAST"], "Var"
    $P1089 = $P1088."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1090 = $P1083."new"($P1087, $P1089, "bind" :named("pasttype"))
.annotate 'line', 409
    get_hll_global $P1091, ["PAST"], "Op"
.annotate 'line', 410
    get_hll_global $P1092, ["PAST"], "Var"
    $P1093 = $P1092."new"("$?CLASS" :named("name"))
.annotate 'line', 411
    get_hll_global $P1094, ["PAST"], "Var"
    $P1095 = $P1094."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1096 = $P1091."new"($P1093, $P1095, "bind" :named("pasttype"))
.annotate 'line', 409
    $P1097 = $P1067."new"($P1082, $P1090, $P1096)
.annotate 'line', 396
    $P1066."unshift"($P1097)
.annotate 'line', 416
    find_lex $P1099, "$/"
    unless_null $P1099, vivify_409
    $P1099 = root_new ['parrot';'Hash']
  vivify_409:
    set $P1100, $P1099["repr"]
    unless_null $P1100, vivify_410
    new $P1100, "Undef"
  vivify_410:
    unless $P1100, if_1098_end
    .const 'Sub' $P1102 = "75_1298839287.218" 
    capture_lex $P1102
    $P1102()
  if_1098_end:
.annotate 'line', 427
    find_lex $P1118, "$how"
    can $I1119, $P1118, "parametric"
    if $I1119, if_1117
    new $P1116, 'Integer'
    set $P1116, $I1119
    goto if_1117_end
  if_1117:
    find_lex $P1120, "$how"
    find_lex $P1121, "$how"
    $P1122 = $P1120."parametric"($P1121)
    set $P1116, $P1122
  if_1117_end:
    if $P1116, if_1115
.annotate 'line', 434
    find_lex $P1135, "$past"
    $P1135."blocktype"("immediate")
.annotate 'line', 435
    find_lex $P1136, "$past"
    get_hll_global $P1137, ["PAST"], "Var"
    $P1138 = $P1137."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1136."unshift"($P1138)
.annotate 'line', 436
    find_lex $P1139, "$past"
    $P1139."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 433
    goto if_1115_end
  if_1115:
.annotate 'line', 428
    find_lex $P1123, "$past"
    $P1123."blocktype"("declaration")
.annotate 'line', 429
    find_lex $P1124, "$past"
    get_hll_global $P1125, ["PAST"], "Var"
    $P1126 = $P1125."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1124."unshift"($P1126)
.annotate 'line', 430
    find_lex $P1127, "$past"
    $P1127."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 431
    find_dynamic_lex $P1128, "$*PACKAGE-SETUP"
    unless_null $P1128, vivify_419
    get_hll_global $P1128, "$PACKAGE-SETUP"
    unless_null $P1128, vivify_420
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_420:
  vivify_419:
    set $P1129, $P1128[0]
    unless_null $P1129, vivify_421
    $P1129 = root_new ['parrot';'ResizablePMCArray']
  vivify_421:
    set $P1130, $P1129[0]
    unless_null $P1130, vivify_422
    $P1130 = root_new ['parrot';'ResizablePMCArray']
  vivify_422:
    set $P1131, $P1130[1]
    unless_null $P1131, vivify_423
    new $P1131, "Undef"
  vivify_423:
    get_hll_global $P1132, ["PAST"], "Val"
    find_lex $P1133, "$past"
    $P1134 = $P1132."new"($P1133 :named("value"), "body_block" :named("named"))
    $P1131."push"($P1134)
  if_1115_end:
.annotate 'line', 441
    find_lex $P1141, "$/"
    unless_null $P1141, vivify_424
    $P1141 = root_new ['parrot';'Hash']
  vivify_424:
    set $P1142, $P1141["parent"]
    unless_null $P1142, vivify_425
    new $P1142, "Undef"
  vivify_425:
    if $P1142, if_1140
.annotate 'line', 455
    find_dynamic_lex $P1172, "$*PKGDECL"
    unless_null $P1172, vivify_426
    get_hll_global $P1172, "$PKGDECL"
    unless_null $P1172, vivify_427
    die "Contextual $*PKGDECL not found"
  vivify_427:
  vivify_426:
    set $S1173, $P1172
    iseq $I1174, $S1173, "grammar"
    unless $I1174, if_1171_end
.annotate 'line', 456
    find_dynamic_lex $P1175, "$*PACKAGE-SETUP"
    unless_null $P1175, vivify_428
    get_hll_global $P1175, "$PACKAGE-SETUP"
    unless_null $P1175, vivify_429
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_429:
  vivify_428:
    get_hll_global $P1176, ["PAST"], "Op"
.annotate 'line', 458
    get_hll_global $P1177, ["PAST"], "Op"
.annotate 'line', 461
    get_hll_global $P1178, ["PAST"], "Var"
    $P1179 = $P1178."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1180 = $P1177."new"($P1179, "get_how PP" :named("pirop"))
.annotate 'line', 463
    get_hll_global $P1181, ["PAST"], "Var"
    $P1182 = $P1181."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 464
    get_hll_global $P1183, ["PAST"], "Var"
    $P1184 = $P1183."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1185 = $P1176."new"($P1180, $P1182, $P1184, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 456
    $P1175."push"($P1185)
  if_1171_end:
.annotate 'line', 455
    goto if_1140_end
  if_1140:
.annotate 'line', 441
    .const 'Sub' $P1144 = "76_1298839287.218" 
    capture_lex $P1144
    $P1144()
  if_1140_end:
.annotate 'line', 469
    find_lex $P1187, "$/"
    unless_null $P1187, vivify_436
    $P1187 = root_new ['parrot';'Hash']
  vivify_436:
    set $P1188, $P1187["role"]
    unless_null $P1188, vivify_437
    new $P1188, "Undef"
  vivify_437:
    unless $P1188, if_1186_end
.annotate 'line', 470
    find_lex $P1190, "$/"
    unless_null $P1190, vivify_438
    $P1190 = root_new ['parrot';'Hash']
  vivify_438:
    set $P1191, $P1190["role"]
    unless_null $P1191, vivify_439
    new $P1191, "Undef"
  vivify_439:
    defined $I1192, $P1191
    unless $I1192, for_undef_440
    iter $P1189, $P1191
    new $P1222, 'ExceptionHandler'
    set_label $P1222, loop1221_handler
    $P1222."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1222
  loop1221_test:
    unless $P1189, loop1221_done
    shift $P1193, $P1189
  loop1221_redo:
    .const 'Sub' $P1195 = "77_1298839287.218" 
    capture_lex $P1195
    $P1195($P1193)
  loop1221_next:
    goto loop1221_test
  loop1221_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1223, exception, 'type'
    eq $P1223, .CONTROL_LOOP_NEXT, loop1221_next
    eq $P1223, .CONTROL_LOOP_REDO, loop1221_redo
  loop1221_done:
    pop_eh 
  for_undef_440:
  if_1186_end:
.annotate 'line', 487
    find_dynamic_lex $P1224, "$*PACKAGE-SETUP"
    unless_null $P1224, vivify_445
    get_hll_global $P1224, "$PACKAGE-SETUP"
    unless_null $P1224, vivify_446
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_446:
  vivify_445:
    get_hll_global $P1225, ["PAST"], "Op"
.annotate 'line', 489
    get_hll_global $P1226, ["PAST"], "Op"
.annotate 'line', 492
    get_hll_global $P1227, ["PAST"], "Var"
    $P1228 = $P1227."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1229 = $P1226."new"($P1228, "get_how PP" :named("pirop"))
.annotate 'line', 494
    get_hll_global $P1230, ["PAST"], "Var"
    $P1231 = $P1230."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1232 = $P1225."new"($P1229, $P1231, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 487
    $P1224."push"($P1232)
.annotate 'line', 498
    get_global $P1233, "@BLOCK"
    unless_null $P1233, vivify_447
    $P1233 = root_new ['parrot';'ResizablePMCArray']
  vivify_447:
    set $P1234, $P1233[0]
    unless_null $P1234, vivify_448
    $P1234 = root_new ['parrot';'ResizablePMCArray']
  vivify_448:
    set $P1235, $P1234[0]
    unless_null $P1235, vivify_449
    new $P1235, "Undef"
  vivify_449:
    get_hll_global $P1236, ["PAST"], "Var"
    find_lex $P1237, "$name"
    find_lex $P1238, "@ns"
    $P1239 = $P1236."new"($P1237 :named("name"), $P1238 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P1235."unshift"($P1239)
.annotate 'line', 501
    find_lex $P1240, "$past"
    $P1241 = $P1240."loadinit"()
    get_hll_global $P1242, ["PAST"], "Block"
    find_dynamic_lex $P1243, "$*PACKAGE-SETUP"
    unless_null $P1243, vivify_450
    get_hll_global $P1243, "$PACKAGE-SETUP"
    unless_null $P1243, vivify_451
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_451:
  vivify_450:
    $P1244 = $P1242."new"($P1243, "immediate" :named("blocktype"))
    $P1241."push"($P1244)
.annotate 'line', 503
    find_lex $P1245, "$/"
    find_lex $P1246, "$past"
    $P1247 = $P1245."!make"($P1246)
.annotate 'line', 384
    .return ($P1247)
.end


.namespace ["NQP";"Actions"]
.sub "_block1101"  :anon :subid("75_1298839287.218") :outer("74_1298839287.218")
.annotate 'line', 417
    new $P1103, "Undef"
    .lex "$repr_name", $P1103
    find_lex $P1104, "$/"
    unless_null $P1104, vivify_411
    $P1104 = root_new ['parrot';'Hash']
  vivify_411:
    set $P1105, $P1104["repr"]
    unless_null $P1105, vivify_412
    $P1105 = root_new ['parrot';'ResizablePMCArray']
  vivify_412:
    set $P1106, $P1105[0]
    unless_null $P1106, vivify_413
    new $P1106, "Undef"
  vivify_413:
    $P1107 = $P1106."ast"()
    store_lex "$repr_name", $P1107
.annotate 'line', 418
    find_lex $P1108, "$repr_name"
    $P1108."named"("repr")
.annotate 'line', 419
    find_dynamic_lex $P1109, "$*PACKAGE-SETUP"
    unless_null $P1109, vivify_414
    get_hll_global $P1109, "$PACKAGE-SETUP"
    unless_null $P1109, vivify_415
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_415:
  vivify_414:
    set $P1110, $P1109[0]
    unless_null $P1110, vivify_416
    $P1110 = root_new ['parrot';'ResizablePMCArray']
  vivify_416:
    set $P1111, $P1110[0]
    unless_null $P1111, vivify_417
    $P1111 = root_new ['parrot';'ResizablePMCArray']
  vivify_417:
    set $P1112, $P1111[1]
    unless_null $P1112, vivify_418
    new $P1112, "Undef"
  vivify_418:
    find_lex $P1113, "$repr_name"
    $P1114 = $P1112."push"($P1113)
.annotate 'line', 416
    .return ($P1114)
.end


.namespace ["NQP";"Actions"]
.sub "_block1143"  :anon :subid("76_1298839287.218") :outer("74_1298839287.218")
.annotate 'line', 442
    $P1145 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1145
.annotate 'line', 443
    new $P1146, "Undef"
    .lex "$name", $P1146
.annotate 'line', 442
    find_lex $P1147, "$/"
    unless_null $P1147, vivify_430
    $P1147 = root_new ['parrot';'Hash']
  vivify_430:
    set $P1148, $P1147["parent"]
    unless_null $P1148, vivify_431
    $P1148 = root_new ['parrot';'ResizablePMCArray']
  vivify_431:
    set $P1149, $P1148[0]
    unless_null $P1149, vivify_432
    $P1149 = root_new ['parrot';'Hash']
  vivify_432:
    set $P1150, $P1149["identifier"]
    unless_null $P1150, vivify_433
    new $P1150, "Undef"
  vivify_433:
    clone $P1151, $P1150
    store_lex "@ns", $P1151
.annotate 'line', 443
    find_lex $P1152, "@ns"
    $P1153 = $P1152."pop"()
    set $S1154, $P1153
    new $P1155, 'String'
    set $P1155, $S1154
    store_lex "$name", $P1155
.annotate 'line', 444
    find_dynamic_lex $P1156, "$*PACKAGE-SETUP"
    unless_null $P1156, vivify_434
    get_hll_global $P1156, "$PACKAGE-SETUP"
    unless_null $P1156, vivify_435
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_435:
  vivify_434:
    get_hll_global $P1157, ["PAST"], "Op"
.annotate 'line', 446
    get_hll_global $P1158, ["PAST"], "Op"
.annotate 'line', 449
    get_hll_global $P1159, ["PAST"], "Var"
    $P1160 = $P1159."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1161 = $P1158."new"($P1160, "get_how PP" :named("pirop"))
.annotate 'line', 451
    get_hll_global $P1162, ["PAST"], "Var"
    $P1163 = $P1162."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 452
    get_hll_global $P1164, ["PAST"], "Var"
    find_lex $P1165, "$name"
    set $S1166, $P1165
    find_lex $P1167, "@ns"
    $P1168 = $P1164."new"($S1166 :named("name"), $P1167 :named("namespace"), "package" :named("scope"))
    $P1169 = $P1157."new"($P1161, $P1163, $P1168, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 444
    $P1170 = $P1156."push"($P1169)
.annotate 'line', 441
    .return ($P1170)
.end


.namespace ["NQP";"Actions"]
.sub "_block1194"  :anon :subid("77_1298839287.218") :outer("74_1298839287.218")
    .param pmc param_1198
.annotate 'line', 471
    $P1196 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1196
.annotate 'line', 472
    new $P1197, "Undef"
    .lex "$name", $P1197
    .lex "$_", param_1198
.annotate 'line', 471
    find_lex $P1199, "$_"
    unless_null $P1199, vivify_441
    $P1199 = root_new ['parrot';'Hash']
  vivify_441:
    set $P1200, $P1199["identifier"]
    unless_null $P1200, vivify_442
    new $P1200, "Undef"
  vivify_442:
    clone $P1201, $P1200
    store_lex "@ns", $P1201
.annotate 'line', 472
    find_lex $P1202, "@ns"
    $P1203 = $P1202."pop"()
    set $S1204, $P1203
    new $P1205, 'String'
    set $P1205, $S1204
    store_lex "$name", $P1205
.annotate 'line', 473
    find_dynamic_lex $P1206, "$*PACKAGE-SETUP"
    unless_null $P1206, vivify_443
    get_hll_global $P1206, "$PACKAGE-SETUP"
    unless_null $P1206, vivify_444
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_444:
  vivify_443:
    get_hll_global $P1207, ["PAST"], "Op"
.annotate 'line', 475
    get_hll_global $P1208, ["PAST"], "Op"
.annotate 'line', 478
    get_hll_global $P1209, ["PAST"], "Var"
    $P1210 = $P1209."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1211 = $P1208."new"($P1210, "get_how PP" :named("pirop"))
.annotate 'line', 480
    get_hll_global $P1212, ["PAST"], "Var"
    $P1213 = $P1212."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 481
    get_hll_global $P1214, ["PAST"], "Var"
    find_lex $P1215, "$name"
    set $S1216, $P1215
    find_lex $P1217, "@ns"
    $P1218 = $P1214."new"($S1216 :named("name"), $P1217 :named("namespace"), "package" :named("scope"))
    $P1219 = $P1207."new"($P1211, $P1213, $P1218, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 473
    $P1220 = $P1206."push"($P1219)
.annotate 'line', 470
    .return ($P1220)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("78_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1249
    .param pmc param_1250
.annotate 'line', 506
    .lex "self", param_1249
    .lex "$/", param_1250
    find_lex $P1251, "$/"
    find_lex $P1252, "$/"
    unless_null $P1252, vivify_452
    $P1252 = root_new ['parrot';'Hash']
  vivify_452:
    set $P1253, $P1252["scoped"]
    unless_null $P1253, vivify_453
    new $P1253, "Undef"
  vivify_453:
    $P1254 = $P1253."ast"()
    $P1255 = $P1251."!make"($P1254)
    .return ($P1255)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("79_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1257
    .param pmc param_1258
.annotate 'line', 507
    .lex "self", param_1257
    .lex "$/", param_1258
    find_lex $P1259, "$/"
    find_lex $P1260, "$/"
    unless_null $P1260, vivify_454
    $P1260 = root_new ['parrot';'Hash']
  vivify_454:
    set $P1261, $P1260["scoped"]
    unless_null $P1261, vivify_455
    new $P1261, "Undef"
  vivify_455:
    $P1262 = $P1261."ast"()
    $P1263 = $P1259."!make"($P1262)
    .return ($P1263)
.end


.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("80_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1265
    .param pmc param_1266
.annotate 'line', 508
    .lex "self", param_1265
    .lex "$/", param_1266
    find_lex $P1267, "$/"
    find_lex $P1268, "$/"
    unless_null $P1268, vivify_456
    $P1268 = root_new ['parrot';'Hash']
  vivify_456:
    set $P1269, $P1268["scoped"]
    unless_null $P1269, vivify_457
    new $P1269, "Undef"
  vivify_457:
    $P1270 = $P1269."ast"()
    $P1271 = $P1267."!make"($P1270)
    .return ($P1271)
.end


.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("81_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1273
    .param pmc param_1274
.annotate 'line', 510
    .lex "self", param_1273
    .lex "$/", param_1274
.annotate 'line', 511
    find_lex $P1275, "$/"
.annotate 'line', 512
    find_lex $P1278, "$/"
    unless_null $P1278, vivify_458
    $P1278 = root_new ['parrot';'Hash']
  vivify_458:
    set $P1279, $P1278["declarator"]
    unless_null $P1279, vivify_459
    new $P1279, "Undef"
  vivify_459:
    if $P1279, if_1277
.annotate 'line', 513
    find_lex $P1283, "$/"
    unless_null $P1283, vivify_460
    $P1283 = root_new ['parrot';'Hash']
  vivify_460:
    set $P1284, $P1283["multi_declarator"]
    unless_null $P1284, vivify_461
    new $P1284, "Undef"
  vivify_461:
    $P1285 = $P1284."ast"()
    set $P1276, $P1285
.annotate 'line', 512
    goto if_1277_end
  if_1277:
    find_lex $P1280, "$/"
    unless_null $P1280, vivify_462
    $P1280 = root_new ['parrot';'Hash']
  vivify_462:
    set $P1281, $P1280["declarator"]
    unless_null $P1281, vivify_463
    new $P1281, "Undef"
  vivify_463:
    $P1282 = $P1281."ast"()
    set $P1276, $P1282
  if_1277_end:
    $P1286 = $P1275."!make"($P1276)
.annotate 'line', 510
    .return ($P1286)
.end


.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("82_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1288
    .param pmc param_1289
.annotate 'line', 516
    .lex "self", param_1288
    .lex "$/", param_1289
.annotate 'line', 517
    find_lex $P1290, "$/"
.annotate 'line', 518
    find_lex $P1293, "$/"
    unless_null $P1293, vivify_464
    $P1293 = root_new ['parrot';'Hash']
  vivify_464:
    set $P1294, $P1293["routine_declarator"]
    unless_null $P1294, vivify_465
    new $P1294, "Undef"
  vivify_465:
    if $P1294, if_1292
.annotate 'line', 519
    find_lex $P1298, "$/"
    unless_null $P1298, vivify_466
    $P1298 = root_new ['parrot';'Hash']
  vivify_466:
    set $P1299, $P1298["variable_declarator"]
    unless_null $P1299, vivify_467
    new $P1299, "Undef"
  vivify_467:
    $P1300 = $P1299."ast"()
    set $P1291, $P1300
.annotate 'line', 518
    goto if_1292_end
  if_1292:
    find_lex $P1295, "$/"
    unless_null $P1295, vivify_468
    $P1295 = root_new ['parrot';'Hash']
  vivify_468:
    set $P1296, $P1295["routine_declarator"]
    unless_null $P1296, vivify_469
    new $P1296, "Undef"
  vivify_469:
    $P1297 = $P1296."ast"()
    set $P1291, $P1297
  if_1292_end:
    $P1301 = $P1290."!make"($P1291)
.annotate 'line', 516
    .return ($P1301)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("83_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1303
    .param pmc param_1304
.annotate 'line', 522
    .lex "self", param_1303
    .lex "$/", param_1304
    find_lex $P1305, "$/"
    find_lex $P1308, "$/"
    unless_null $P1308, vivify_470
    $P1308 = root_new ['parrot';'Hash']
  vivify_470:
    set $P1309, $P1308["declarator"]
    unless_null $P1309, vivify_471
    new $P1309, "Undef"
  vivify_471:
    if $P1309, if_1307
    find_lex $P1313, "$/"
    unless_null $P1313, vivify_472
    $P1313 = root_new ['parrot';'Hash']
  vivify_472:
    set $P1314, $P1313["routine_def"]
    unless_null $P1314, vivify_473
    new $P1314, "Undef"
  vivify_473:
    $P1315 = $P1314."ast"()
    set $P1306, $P1315
    goto if_1307_end
  if_1307:
    find_lex $P1310, "$/"
    unless_null $P1310, vivify_474
    $P1310 = root_new ['parrot';'Hash']
  vivify_474:
    set $P1311, $P1310["declarator"]
    unless_null $P1311, vivify_475
    new $P1311, "Undef"
  vivify_475:
    $P1312 = $P1311."ast"()
    set $P1306, $P1312
  if_1307_end:
    $P1316 = $P1305."!make"($P1306)
    .return ($P1316)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("84_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1318
    .param pmc param_1319
.annotate 'line', 523
    .lex "self", param_1318
    .lex "$/", param_1319
    find_lex $P1320, "$/"
    find_lex $P1323, "$/"
    unless_null $P1323, vivify_476
    $P1323 = root_new ['parrot';'Hash']
  vivify_476:
    set $P1324, $P1323["declarator"]
    unless_null $P1324, vivify_477
    new $P1324, "Undef"
  vivify_477:
    if $P1324, if_1322
    find_lex $P1328, "$/"
    unless_null $P1328, vivify_478
    $P1328 = root_new ['parrot';'Hash']
  vivify_478:
    set $P1329, $P1328["routine_def"]
    unless_null $P1329, vivify_479
    new $P1329, "Undef"
  vivify_479:
    $P1330 = $P1329."ast"()
    set $P1321, $P1330
    goto if_1322_end
  if_1322:
    find_lex $P1325, "$/"
    unless_null $P1325, vivify_480
    $P1325 = root_new ['parrot';'Hash']
  vivify_480:
    set $P1326, $P1325["declarator"]
    unless_null $P1326, vivify_481
    new $P1326, "Undef"
  vivify_481:
    $P1327 = $P1326."ast"()
    set $P1321, $P1327
  if_1322_end:
    $P1331 = $P1320."!make"($P1321)
    .return ($P1331)
.end


.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("85_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1333
    .param pmc param_1334
.annotate 'line', 524
    .lex "self", param_1333
    .lex "$/", param_1334
    find_lex $P1335, "$/"
    find_lex $P1336, "$/"
    unless_null $P1336, vivify_482
    $P1336 = root_new ['parrot';'Hash']
  vivify_482:
    set $P1337, $P1336["declarator"]
    unless_null $P1337, vivify_483
    new $P1337, "Undef"
  vivify_483:
    $P1338 = $P1337."ast"()
    $P1339 = $P1335."!make"($P1338)
    .return ($P1339)
.end


.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("86_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1341
    .param pmc param_1342
.annotate 'line', 527
    .const 'Sub' $P1414 = "89_1298839287.218" 
    capture_lex $P1414
    .const 'Sub' $P1369 = "87_1298839287.218" 
    capture_lex $P1369
    .lex "self", param_1341
    .lex "$/", param_1342
.annotate 'line', 528
    new $P1343, "Undef"
    .lex "$past", $P1343
.annotate 'line', 529
    new $P1344, "Undef"
    .lex "$sigil", $P1344
.annotate 'line', 530
    new $P1345, "Undef"
    .lex "$name", $P1345
.annotate 'line', 531
    new $P1346, "Undef"
    .lex "$BLOCK", $P1346
.annotate 'line', 528
    find_lex $P1347, "$/"
    unless_null $P1347, vivify_484
    $P1347 = root_new ['parrot';'Hash']
  vivify_484:
    set $P1348, $P1347["variable"]
    unless_null $P1348, vivify_485
    new $P1348, "Undef"
  vivify_485:
    $P1349 = $P1348."ast"()
    store_lex "$past", $P1349
.annotate 'line', 529
    find_lex $P1350, "$/"
    unless_null $P1350, vivify_486
    $P1350 = root_new ['parrot';'Hash']
  vivify_486:
    set $P1351, $P1350["variable"]
    unless_null $P1351, vivify_487
    $P1351 = root_new ['parrot';'Hash']
  vivify_487:
    set $P1352, $P1351["sigil"]
    unless_null $P1352, vivify_488
    new $P1352, "Undef"
  vivify_488:
    store_lex "$sigil", $P1352
.annotate 'line', 530
    find_lex $P1353, "$past"
    $P1354 = $P1353."name"()
    store_lex "$name", $P1354
.annotate 'line', 531
    get_global $P1355, "@BLOCK"
    unless_null $P1355, vivify_489
    $P1355 = root_new ['parrot';'ResizablePMCArray']
  vivify_489:
    set $P1356, $P1355[0]
    unless_null $P1356, vivify_490
    new $P1356, "Undef"
  vivify_490:
    store_lex "$BLOCK", $P1356
.annotate 'line', 532
    find_lex $P1358, "$BLOCK"
    find_lex $P1359, "$name"
    $P1360 = $P1358."symbol"($P1359)
    unless $P1360, if_1357_end
.annotate 'line', 533
    find_lex $P1361, "$/"
    $P1362 = $P1361."CURSOR"()
    find_lex $P1363, "$name"
    $P1362."panic"("Redeclaration of symbol ", $P1363)
  if_1357_end:
.annotate 'line', 535
    find_dynamic_lex $P1365, "$*SCOPE"
    unless_null $P1365, vivify_491
    get_hll_global $P1365, "$SCOPE"
    unless_null $P1365, vivify_492
    die "Contextual $*SCOPE not found"
  vivify_492:
  vivify_491:
    set $S1366, $P1365
    iseq $I1367, $S1366, "has"
    if $I1367, if_1364
.annotate 'line', 560
    .const 'Sub' $P1414 = "89_1298839287.218" 
    capture_lex $P1414
    $P1414()
    goto if_1364_end
  if_1364:
.annotate 'line', 535
    .const 'Sub' $P1369 = "87_1298839287.218" 
    capture_lex $P1369
    $P1369()
  if_1364_end:
.annotate 'line', 568
    find_lex $P1438, "$/"
    find_lex $P1439, "$past"
    $P1440 = $P1438."!make"($P1439)
.annotate 'line', 527
    .return ($P1440)
.end


.namespace ["NQP";"Actions"]
.sub "_block1413"  :anon :subid("89_1298839287.218") :outer("86_1298839287.218")
.annotate 'line', 561
    new $P1415, "Undef"
    .lex "$scope", $P1415
.annotate 'line', 562
    new $P1416, "Undef"
    .lex "$decl", $P1416
.annotate 'line', 561
    find_dynamic_lex $P1419, "$*SCOPE"
    unless_null $P1419, vivify_493
    get_hll_global $P1419, "$SCOPE"
    unless_null $P1419, vivify_494
    die "Contextual $*SCOPE not found"
  vivify_494:
  vivify_493:
    set $S1420, $P1419
    iseq $I1421, $S1420, "our"
    if $I1421, if_1418
    new $P1423, "String"
    assign $P1423, "lexical"
    set $P1417, $P1423
    goto if_1418_end
  if_1418:
    new $P1422, "String"
    assign $P1422, "package"
    set $P1417, $P1422
  if_1418_end:
    store_lex "$scope", $P1417
.annotate 'line', 562
    get_hll_global $P1424, ["PAST"], "Var"
    find_lex $P1425, "$name"
    find_lex $P1426, "$scope"
.annotate 'line', 563
    find_lex $P1427, "$sigil"
    $P1428 = "vivitype"($P1427)
    find_lex $P1429, "$/"
    $P1430 = $P1424."new"($P1425 :named("name"), $P1426 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1428 :named("viviself"), $P1429 :named("node"))
.annotate 'line', 562
    store_lex "$decl", $P1430
.annotate 'line', 565
    find_lex $P1431, "$BLOCK"
    find_lex $P1432, "$name"
    find_lex $P1433, "$scope"
    $P1431."symbol"($P1432, $P1433 :named("scope"))
.annotate 'line', 566
    find_lex $P1434, "$BLOCK"
    unless_null $P1434, vivify_495
    $P1434 = root_new ['parrot';'ResizablePMCArray']
  vivify_495:
    set $P1435, $P1434[0]
    unless_null $P1435, vivify_496
    new $P1435, "Undef"
  vivify_496:
    find_lex $P1436, "$decl"
    $P1437 = $P1435."push"($P1436)
.annotate 'line', 560
    .return ($P1437)
.end


.namespace ["NQP";"Actions"]
.sub "_block1368"  :anon :subid("87_1298839287.218") :outer("86_1298839287.218")
.annotate 'line', 535
    .const 'Sub' $P1399 = "88_1298839287.218" 
    capture_lex $P1399
.annotate 'line', 537
    new $P1370, "Undef"
    .lex "$meta-attr-type", $P1370
.annotate 'line', 545
    new $P1371, "Undef"
    .lex "$meta_args", $P1371
.annotate 'line', 537
    find_dynamic_lex $P1374, "$*PKGDECL"
    unless_null $P1374, vivify_497
    get_hll_global $P1374, "$PKGDECL"
    unless_null $P1374, vivify_498
    die "Contextual $*PKGDECL not found"
  vivify_498:
  vivify_497:
    find_dynamic_lex $P1375, "%*HOW-METAATTR"
    unless_null $P1375, vivify_499
    get_hll_global $P1375, "%HOW-METAATTR"
    unless_null $P1375, vivify_500
    die "Contextual %*HOW-METAATTR not found"
  vivify_500:
  vivify_499:
    set $P1376, $P1375[$P1374]
    unless_null $P1376, vivify_501
    new $P1376, "Undef"
  vivify_501:
    unless $P1376, unless_1373
    set $P1372, $P1376
    goto unless_1373_end
  unless_1373:
    find_dynamic_lex $P1377, "$*DEFAULT-METAATTR"
    unless_null $P1377, vivify_502
    get_hll_global $P1377, "$DEFAULT-METAATTR"
    unless_null $P1377, vivify_503
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_503:
  vivify_502:
    set $P1372, $P1377
  unless_1373_end:
    store_lex "$meta-attr-type", $P1372
.annotate 'line', 538
    find_dynamic_lex $P1378, "$*PACKAGE-SETUP"
    unless_null $P1378, vivify_504
    get_hll_global $P1378, "$PACKAGE-SETUP"
    unless_null $P1378, vivify_505
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_505:
  vivify_504:
    get_hll_global $P1379, ["PAST"], "Op"
.annotate 'line', 540
    get_hll_global $P1380, ["PAST"], "Op"
.annotate 'line', 542
    get_hll_global $P1381, ["PAST"], "Var"
    $P1382 = $P1381."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1383 = $P1380."new"($P1382, "get_how PP" :named("pirop"))
.annotate 'line', 544
    get_hll_global $P1384, ["PAST"], "Var"
    $P1385 = $P1384."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 545
    get_hll_global $P1386, ["PAST"], "Op"
.annotate 'line', 547
    get_hll_global $P1387, ["PAST"], "Var"
    find_lex $P1388, "$meta-attr-type"
    $P1389 = $P1387."new"($P1388 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 548
    get_hll_global $P1390, ["PAST"], "Val"
    find_lex $P1391, "$name"
    $P1392 = $P1390."new"($P1391 :named("value"), "name" :named("named"))
    $P1393 = $P1386."new"($P1389, $P1392, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 545
    store_lex "$meta_args", $P1393
    $P1394 = $P1379."new"($P1383, $P1385, $P1393, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 538
    $P1378."push"($P1394)
.annotate 'line', 551
    find_lex $P1396, "$/"
    unless_null $P1396, vivify_506
    $P1396 = root_new ['parrot';'Hash']
  vivify_506:
    set $P1397, $P1396["typename"]
    unless_null $P1397, vivify_507
    new $P1397, "Undef"
  vivify_507:
    unless $P1397, if_1395_end
    .const 'Sub' $P1399 = "88_1298839287.218" 
    capture_lex $P1399
    $P1399()
  if_1395_end:
.annotate 'line', 557
    find_lex $P1409, "$BLOCK"
    find_lex $P1410, "$name"
    $P1409."symbol"($P1410, "attribute" :named("scope"))
.annotate 'line', 558
    get_hll_global $P1411, ["PAST"], "Stmts"
    $P1412 = $P1411."new"()
    store_lex "$past", $P1412
.annotate 'line', 535
    .return ($P1412)
.end


.namespace ["NQP";"Actions"]
.sub "_block1398"  :anon :subid("88_1298839287.218") :outer("87_1298839287.218")
.annotate 'line', 552
    new $P1400, "Undef"
    .lex "$type", $P1400
    find_lex $P1401, "$/"
    unless_null $P1401, vivify_508
    $P1401 = root_new ['parrot';'Hash']
  vivify_508:
    set $P1402, $P1401["typename"]
    unless_null $P1402, vivify_509
    $P1402 = root_new ['parrot';'ResizablePMCArray']
  vivify_509:
    set $P1403, $P1402[0]
    unless_null $P1403, vivify_510
    new $P1403, "Undef"
  vivify_510:
    $P1404 = $P1403."ast"()
    store_lex "$type", $P1404
.annotate 'line', 553
    find_lex $P1405, "$type"
    $P1405."named"("type")
.annotate 'line', 554
    find_lex $P1406, "$meta_args"
    find_lex $P1407, "$type"
    $P1408 = $P1406."push"($P1407)
.annotate 'line', 551
    .return ($P1408)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("90_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1442
    .param pmc param_1443
.annotate 'line', 571
    .lex "self", param_1442
    .lex "$/", param_1443
    find_lex $P1444, "$/"
    find_lex $P1445, "$/"
    unless_null $P1445, vivify_511
    $P1445 = root_new ['parrot';'Hash']
  vivify_511:
    set $P1446, $P1445["routine_def"]
    unless_null $P1446, vivify_512
    new $P1446, "Undef"
  vivify_512:
    $P1447 = $P1446."ast"()
    $P1448 = $P1444."!make"($P1447)
    .return ($P1448)
.end


.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("91_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1450
    .param pmc param_1451
.annotate 'line', 572
    .lex "self", param_1450
    .lex "$/", param_1451
    find_lex $P1452, "$/"
    find_lex $P1453, "$/"
    unless_null $P1453, vivify_513
    $P1453 = root_new ['parrot';'Hash']
  vivify_513:
    set $P1454, $P1453["method_def"]
    unless_null $P1454, vivify_514
    new $P1454, "Undef"
  vivify_514:
    $P1455 = $P1454."ast"()
    $P1456 = $P1452."!make"($P1455)
    .return ($P1456)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("92_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1458
    .param pmc param_1459
.annotate 'line', 574
    .const 'Sub' $P1687 = "98_1298839287.218" 
    capture_lex $P1687
    .const 'Sub' $P1479 = "93_1298839287.218" 
    capture_lex $P1479
    .lex "self", param_1458
    .lex "$/", param_1459
.annotate 'line', 577
    new $P1460, "Undef"
    .lex "$past", $P1460
.annotate 'line', 588
    new $P1461, "Undef"
    .lex "$block", $P1461
.annotate 'line', 574
    find_lex $P1462, "$past"
.annotate 'line', 578
    find_lex $P1464, "$/"
    unless_null $P1464, vivify_515
    $P1464 = root_new ['parrot';'Hash']
  vivify_515:
    set $P1465, $P1464["onlystar"]
    unless_null $P1465, vivify_516
    new $P1465, "Undef"
  vivify_516:
    if $P1465, if_1463
.annotate 'line', 582
    find_lex $P1467, "$/"
    unless_null $P1467, vivify_517
    $P1467 = root_new ['parrot';'Hash']
  vivify_517:
    set $P1468, $P1467["blockoid"]
    unless_null $P1468, vivify_518
    new $P1468, "Undef"
  vivify_518:
    $P1469 = $P1468."ast"()
    store_lex "$past", $P1469
.annotate 'line', 583
    find_lex $P1470, "$past"
    $P1470."blocktype"("declaration")
.annotate 'line', 584
    find_dynamic_lex $P1472, "$*RETURN_USED"
    unless_null $P1472, vivify_519
    get_hll_global $P1472, "$RETURN_USED"
    unless_null $P1472, vivify_520
    die "Contextual $*RETURN_USED not found"
  vivify_520:
  vivify_519:
    unless $P1472, if_1471_end
.annotate 'line', 585
    find_lex $P1473, "$past"
    $P1473."control"("return_pir")
  if_1471_end:
.annotate 'line', 581
    goto if_1463_end
  if_1463:
.annotate 'line', 579
    $P1466 = "only_star_block"()
    store_lex "$past", $P1466
  if_1463_end:
.annotate 'line', 588
    find_lex $P1474, "$past"
    store_lex "$block", $P1474
.annotate 'line', 590
    find_lex $P1476, "$/"
    unless_null $P1476, vivify_521
    $P1476 = root_new ['parrot';'Hash']
  vivify_521:
    set $P1477, $P1476["deflongname"]
    unless_null $P1477, vivify_522
    new $P1477, "Undef"
  vivify_522:
    unless $P1477, if_1475_end
    .const 'Sub' $P1479 = "93_1298839287.218" 
    capture_lex $P1479
    $P1479()
  if_1475_end:
.annotate 'line', 690
    find_lex $P1676, "$block"
    find_lex $P1677, "$past"
    unless_null $P1677, vivify_583
    $P1677 = root_new ['parrot';'Hash']
    store_lex "$past", $P1677
  vivify_583:
    set $P1677["block_past"], $P1676
.annotate 'line', 691
    find_lex $P1679, "$/"
    unless_null $P1679, vivify_584
    $P1679 = root_new ['parrot';'Hash']
  vivify_584:
    set $P1680, $P1679["trait"]
    unless_null $P1680, vivify_585
    new $P1680, "Undef"
  vivify_585:
    unless $P1680, if_1678_end
.annotate 'line', 692
    find_lex $P1682, "$/"
    unless_null $P1682, vivify_586
    $P1682 = root_new ['parrot';'Hash']
  vivify_586:
    set $P1683, $P1682["trait"]
    unless_null $P1683, vivify_587
    new $P1683, "Undef"
  vivify_587:
    defined $I1684, $P1683
    unless $I1684, for_undef_588
    iter $P1681, $P1683
    new $P1694, 'ExceptionHandler'
    set_label $P1694, loop1693_handler
    $P1694."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1694
  loop1693_test:
    unless $P1681, loop1693_done
    shift $P1685, $P1681
  loop1693_redo:
    .const 'Sub' $P1687 = "98_1298839287.218" 
    capture_lex $P1687
    $P1687($P1685)
  loop1693_next:
    goto loop1693_test
  loop1693_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1695, exception, 'type'
    eq $P1695, .CONTROL_LOOP_NEXT, loop1693_next
    eq $P1695, .CONTROL_LOOP_REDO, loop1693_redo
  loop1693_done:
    pop_eh 
  for_undef_588:
  if_1678_end:
.annotate 'line', 695
    find_lex $P1696, "$/"
    find_lex $P1697, "$past"
    $P1698 = $P1696."!make"($P1697)
.annotate 'line', 574
    .return ($P1698)
.end


.namespace ["NQP";"Actions"]
.sub "_block1478"  :anon :subid("93_1298839287.218") :outer("92_1298839287.218")
.annotate 'line', 590
    .const 'Sub' $P1602 = "97_1298839287.218" 
    capture_lex $P1602
    .const 'Sub' $P1513 = "94_1298839287.218" 
    capture_lex $P1513
.annotate 'line', 591
    new $P1480, "Undef"
    .lex "$name", $P1480
    find_lex $P1481, "$/"
    unless_null $P1481, vivify_523
    $P1481 = root_new ['parrot';'Hash']
  vivify_523:
    set $P1482, $P1481["sigil"]
    unless_null $P1482, vivify_524
    $P1482 = root_new ['parrot';'ResizablePMCArray']
  vivify_524:
    set $P1483, $P1482[0]
    unless_null $P1483, vivify_525
    new $P1483, "Undef"
  vivify_525:
    set $S1484, $P1483
    new $P1485, 'String'
    set $P1485, $S1484
    find_lex $P1486, "$/"
    unless_null $P1486, vivify_526
    $P1486 = root_new ['parrot';'Hash']
  vivify_526:
    set $P1487, $P1486["deflongname"]
    unless_null $P1487, vivify_527
    $P1487 = root_new ['parrot';'ResizablePMCArray']
  vivify_527:
    set $P1488, $P1487[0]
    unless_null $P1488, vivify_528
    new $P1488, "Undef"
  vivify_528:
    $S1489 = $P1488."ast"()
    concat $P1490, $P1485, $S1489
    store_lex "$name", $P1490
.annotate 'line', 592
    find_lex $P1491, "$past"
    find_lex $P1492, "$name"
    $P1491."name"($P1492)
.annotate 'line', 593
    find_dynamic_lex $P1499, "$*SCOPE"
    unless_null $P1499, vivify_529
    get_hll_global $P1499, "$SCOPE"
    unless_null $P1499, vivify_530
    die "Contextual $*SCOPE not found"
  vivify_530:
  vivify_529:
    set $S1500, $P1499
    iseq $I1501, $S1500, ""
    unless $I1501, unless_1498
    new $P1497, 'Integer'
    set $P1497, $I1501
    goto unless_1498_end
  unless_1498:
    find_dynamic_lex $P1502, "$*SCOPE"
    unless_null $P1502, vivify_531
    get_hll_global $P1502, "$SCOPE"
    unless_null $P1502, vivify_532
    die "Contextual $*SCOPE not found"
  vivify_532:
  vivify_531:
    set $S1503, $P1502
    iseq $I1504, $S1503, "my"
    new $P1497, 'Integer'
    set $P1497, $I1504
  unless_1498_end:
    unless $P1497, unless_1496
    set $P1495, $P1497
    goto unless_1496_end
  unless_1496:
    find_dynamic_lex $P1505, "$*SCOPE"
    unless_null $P1505, vivify_533
    get_hll_global $P1505, "$SCOPE"
    unless_null $P1505, vivify_534
    die "Contextual $*SCOPE not found"
  vivify_534:
  vivify_533:
    set $S1506, $P1505
    iseq $I1507, $S1506, "our"
    new $P1495, 'Integer'
    set $P1495, $I1507
  unless_1496_end:
    if $P1495, if_1494
.annotate 'line', 685
    find_lex $P1671, "$/"
    $P1672 = $P1671."CURSOR"()
    find_dynamic_lex $P1673, "$*SCOPE"
    unless_null $P1673, vivify_535
    get_hll_global $P1673, "$SCOPE"
    unless_null $P1673, vivify_536
    die "Contextual $*SCOPE not found"
  vivify_536:
  vivify_535:
    concat $P1674, $P1673, " scoped routines are not supported yet"
    $P1675 = $P1672."panic"($P1674)
.annotate 'line', 684
    set $P1493, $P1675
.annotate 'line', 593
    goto if_1494_end
  if_1494:
.annotate 'line', 594
    find_dynamic_lex $P1509, "$*MULTINESS"
    unless_null $P1509, vivify_537
    get_hll_global $P1509, "$MULTINESS"
    unless_null $P1509, vivify_538
    die "Contextual $*MULTINESS not found"
  vivify_538:
  vivify_537:
    set $S1510, $P1509
    iseq $I1511, $S1510, "multi"
    if $I1511, if_1508
.annotate 'line', 645
    find_dynamic_lex $P1598, "$*MULTINESS"
    unless_null $P1598, vivify_539
    get_hll_global $P1598, "$MULTINESS"
    unless_null $P1598, vivify_540
    die "Contextual $*MULTINESS not found"
  vivify_540:
  vivify_539:
    set $S1599, $P1598
    iseq $I1600, $S1599, "proto"
    if $I1600, if_1597
.annotate 'line', 664
    get_global $P1632, "@BLOCK"
    unless_null $P1632, vivify_541
    $P1632 = root_new ['parrot';'ResizablePMCArray']
  vivify_541:
    set $P1633, $P1632[0]
    unless_null $P1633, vivify_542
    $P1633 = root_new ['parrot';'ResizablePMCArray']
  vivify_542:
    set $P1634, $P1633[0]
    unless_null $P1634, vivify_543
    new $P1634, "Undef"
  vivify_543:
    get_hll_global $P1635, ["PAST"], "Var"
    find_lex $P1636, "$name"
    find_lex $P1637, "$past"
    $P1638 = $P1635."new"($P1636 :named("name"), 1 :named("isdecl"), $P1637 :named("viviself"), "lexical" :named("scope"))
    $P1634."push"($P1638)
.annotate 'line', 666
    get_global $P1639, "@BLOCK"
    unless_null $P1639, vivify_544
    $P1639 = root_new ['parrot';'ResizablePMCArray']
  vivify_544:
    set $P1640, $P1639[0]
    unless_null $P1640, vivify_545
    new $P1640, "Undef"
  vivify_545:
    find_lex $P1641, "$name"
    $P1640."symbol"($P1641, "lexical" :named("scope"))
.annotate 'line', 667
    find_dynamic_lex $P1643, "$*SCOPE"
    unless_null $P1643, vivify_546
    get_hll_global $P1643, "$SCOPE"
    unless_null $P1643, vivify_547
    die "Contextual $*SCOPE not found"
  vivify_547:
  vivify_546:
    set $S1644, $P1643
    iseq $I1645, $S1644, "our"
    unless $I1645, if_1642_end
.annotate 'line', 670
    get_global $P1646, "@BLOCK"
    unless_null $P1646, vivify_548
    $P1646 = root_new ['parrot';'ResizablePMCArray']
  vivify_548:
    set $P1647, $P1646[0]
    unless_null $P1647, vivify_549
    $P1647 = root_new ['parrot';'ResizablePMCArray']
  vivify_549:
    set $P1648, $P1647[0]
    unless_null $P1648, vivify_550
    new $P1648, "Undef"
  vivify_550:
    get_hll_global $P1649, ["PAST"], "Op"
.annotate 'line', 672
    get_hll_global $P1650, ["PAST"], "Var"
    find_lex $P1651, "$name"
    $P1652 = $P1650."new"($P1651 :named("name"), "package" :named("scope"))
.annotate 'line', 673
    get_hll_global $P1653, ["PAST"], "Var"
    find_lex $P1654, "$name"
    $P1655 = $P1653."new"($P1654 :named("name"), "lexical" :named("scope"))
    $P1656 = $P1649."new"($P1652, $P1655, "bind" :named("pasttype"))
.annotate 'line', 670
    $P1648."push"($P1656)
.annotate 'line', 675
    get_global $P1657, "@BLOCK"
    unless_null $P1657, vivify_551
    $P1657 = root_new ['parrot';'ResizablePMCArray']
  vivify_551:
    set $P1658, $P1657[0]
    unless_null $P1658, vivify_552
    new $P1658, "Undef"
  vivify_552:
    $P1659 = $P1658."loadinit"()
    get_hll_global $P1660, ["PAST"], "Op"
.annotate 'line', 677
    get_hll_global $P1661, ["PAST"], "Var"
    find_lex $P1662, "$name"
    $P1663 = $P1661."new"($P1662 :named("name"), "package" :named("scope"))
.annotate 'line', 678
    get_hll_global $P1664, ["PAST"], "Val"
    find_lex $P1665, "$past"
    $P1666 = $P1664."new"($P1665 :named("value"))
    $P1667 = $P1660."new"($P1663, $P1666, "bind" :named("pasttype"))
.annotate 'line', 675
    $P1659."push"($P1667)
  if_1642_end:
.annotate 'line', 663
    goto if_1597_end
  if_1597:
.annotate 'line', 645
    .const 'Sub' $P1602 = "97_1298839287.218" 
    capture_lex $P1602
    $P1602()
  if_1597_end:
    goto if_1508_end
  if_1508:
.annotate 'line', 594
    .const 'Sub' $P1513 = "94_1298839287.218" 
    capture_lex $P1513
    $P1513()
  if_1508_end:
.annotate 'line', 682
    get_hll_global $P1668, ["PAST"], "Var"
    find_lex $P1669, "$name"
    $P1670 = $P1668."new"($P1669 :named("name"))
    store_lex "$past", $P1670
.annotate 'line', 593
    set $P1493, $P1670
  if_1494_end:
.annotate 'line', 590
    .return ($P1493)
.end


.namespace ["NQP";"Actions"]
.sub "_block1601"  :anon :subid("97_1298839287.218") :outer("93_1298839287.218")
.annotate 'line', 650
    new $P1603, "Undef"
    .lex "$cholder", $P1603
.annotate 'line', 649
    find_dynamic_lex $P1605, "$*SCOPE"
    unless_null $P1605, vivify_553
    get_hll_global $P1605, "$SCOPE"
    unless_null $P1605, vivify_554
    die "Contextual $*SCOPE not found"
  vivify_554:
  vivify_553:
    set $S1606, $P1605
    iseq $I1607, $S1606, "our"
    unless $I1607, if_1604_end
    die "our-scoped protos not yet implemented"
  if_1604_end:
.annotate 'line', 650
    get_hll_global $P1608, ["PAST"], "Op"
    $P1609 = $P1608."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1609
.annotate 'line', 651
    get_global $P1610, "@BLOCK"
    unless_null $P1610, vivify_555
    $P1610 = root_new ['parrot';'ResizablePMCArray']
  vivify_555:
    set $P1611, $P1610[0]
    unless_null $P1611, vivify_556
    $P1611 = root_new ['parrot';'ResizablePMCArray']
  vivify_556:
    set $P1612, $P1611[0]
    unless_null $P1612, vivify_557
    new $P1612, "Undef"
  vivify_557:
    get_hll_global $P1613, ["PAST"], "Var"
    find_lex $P1614, "$name"
    find_lex $P1615, "$past"
    $P1616 = $P1613."new"($P1614 :named("name"), 1 :named("isdecl"), $P1615 :named("viviself"), "lexical" :named("scope"))
    $P1612."push"($P1616)
.annotate 'line', 653
    get_global $P1617, "@BLOCK"
    unless_null $P1617, vivify_558
    $P1617 = root_new ['parrot';'ResizablePMCArray']
  vivify_558:
    set $P1618, $P1617[0]
    unless_null $P1618, vivify_559
    $P1618 = root_new ['parrot';'ResizablePMCArray']
  vivify_559:
    set $P1619, $P1618[0]
    unless_null $P1619, vivify_560
    new $P1619, "Undef"
  vivify_560:
    get_hll_global $P1620, ["PAST"], "Op"
.annotate 'line', 655
    get_hll_global $P1621, ["PAST"], "Var"
    find_lex $P1622, "$name"
    $P1623 = $P1621."new"($P1622 :named("name"))
    find_lex $P1624, "$cholder"
    $P1625 = $P1620."new"($P1623, $P1624, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 653
    $P1619."push"($P1625)
.annotate 'line', 658
    get_global $P1626, "@BLOCK"
    unless_null $P1626, vivify_561
    $P1626 = root_new ['parrot';'ResizablePMCArray']
  vivify_561:
    set $P1627, $P1626[0]
    unless_null $P1627, vivify_562
    new $P1627, "Undef"
  vivify_562:
    find_lex $P1628, "$name"
    find_lex $P1629, "$cholder"
    $P1627."symbol"($P1628, "lexical" :named("scope"), 1 :named("proto"), $P1629 :named("cholder"))
.annotate 'line', 661
    find_lex $P1630, "$past"
    $P1631 = $P1630."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 645
    .return ($P1631)
.end


.namespace ["NQP";"Actions"]
.sub "_block1512"  :anon :subid("94_1298839287.218") :outer("93_1298839287.218")
.annotate 'line', 594
    .const 'Sub' $P1531 = "95_1298839287.218" 
    capture_lex $P1531
.annotate 'line', 597
    new $P1514, "Undef"
    .lex "$cholder", $P1514
.annotate 'line', 598
    $P1515 = root_new ['parrot';'Hash']
    .lex "%sym", $P1515
.annotate 'line', 596
    find_dynamic_lex $P1517, "$*SCOPE"
    unless_null $P1517, vivify_563
    get_hll_global $P1517, "$SCOPE"
    unless_null $P1517, vivify_564
    die "Contextual $*SCOPE not found"
  vivify_564:
  vivify_563:
    set $S1518, $P1517
    iseq $I1519, $S1518, "our"
    unless $I1519, if_1516_end
    die "our-scoped multis not yet implemented"
  if_1516_end:
    find_lex $P1520, "$cholder"
.annotate 'line', 598
    get_global $P1521, "@BLOCK"
    unless_null $P1521, vivify_565
    $P1521 = root_new ['parrot';'ResizablePMCArray']
  vivify_565:
    set $P1522, $P1521[0]
    unless_null $P1522, vivify_566
    new $P1522, "Undef"
  vivify_566:
    find_lex $P1523, "$name"
    $P1524 = $P1522."symbol"($P1523)
    store_lex "%sym", $P1524
.annotate 'line', 599
    find_lex $P1526, "%sym"
    unless_null $P1526, vivify_567
    $P1526 = root_new ['parrot';'Hash']
  vivify_567:
    set $P1527, $P1526["cholder"]
    unless_null $P1527, vivify_568
    new $P1527, "Undef"
  vivify_568:
    if $P1527, if_1525
.annotate 'line', 604
    .const 'Sub' $P1531 = "95_1298839287.218" 
    capture_lex $P1531
    $P1531()
    goto if_1525_end
  if_1525:
.annotate 'line', 600
    find_lex $P1528, "%sym"
    unless_null $P1528, vivify_581
    $P1528 = root_new ['parrot';'Hash']
  vivify_581:
    set $P1529, $P1528["cholder"]
    unless_null $P1529, vivify_582
    new $P1529, "Undef"
  vivify_582:
    store_lex "$cholder", $P1529
  if_1525_end:
.annotate 'line', 640
    find_lex $P1593, "$cholder"
    find_lex $P1594, "$past"
    $P1593."push"($P1594)
.annotate 'line', 643
    find_lex $P1595, "$past"
    $P1596 = "attach_multi_signature"($P1595)
.annotate 'line', 594
    .return ($P1596)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1530"  :anon :subid("95_1298839287.218") :outer("94_1298839287.218")
.annotate 'line', 604
    .const 'Sub' $P1545 = "96_1298839287.218" 
    capture_lex $P1545
.annotate 'line', 611
    new $P1532, "Undef"
    .lex "$found_proto", $P1532
.annotate 'line', 629
    new $P1533, "Undef"
    .lex "$dispatch_setup", $P1533
.annotate 'line', 606
    find_lex $P1535, "%sym"
    unless_null $P1535, vivify_569
    $P1535 = root_new ['parrot';'Hash']
  vivify_569:
    set $P1536, $P1535["proto"]
    unless_null $P1536, vivify_570
    new $P1536, "Undef"
  vivify_570:
    unless $P1536, if_1534_end
.annotate 'line', 609
    find_lex $P1537, "$/"
    $P1538 = $P1537."CURSOR"()
    $P1538."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1534_end:
.annotate 'line', 606
    find_lex $P1539, "$found_proto"
.annotate 'line', 612
    get_global $P1541, "@BLOCK"
    defined $I1542, $P1541
    unless $I1542, for_undef_571
    iter $P1540, $P1541
    new $P1567, 'ExceptionHandler'
    set_label $P1567, loop1566_handler
    $P1567."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1567
  loop1566_test:
    unless $P1540, loop1566_done
    shift $P1543, $P1540
  loop1566_redo:
    .const 'Sub' $P1545 = "96_1298839287.218" 
    capture_lex $P1545
    $P1545($P1543)
  loop1566_next:
    goto loop1566_test
  loop1566_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1568, exception, 'type'
    eq $P1568, .CONTROL_LOOP_NEXT, loop1566_next
    eq $P1568, .CONTROL_LOOP_REDO, loop1566_redo
  loop1566_done:
    pop_eh 
  for_undef_571:
.annotate 'line', 623
    find_lex $P1570, "$found_proto"
    if $P1570, unless_1569_end
.annotate 'line', 624
    find_lex $P1571, "$/"
    $P1572 = $P1571."CURSOR"()
    $P1572."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1569_end:
.annotate 'line', 628
    get_hll_global $P1573, ["PAST"], "Op"
    $P1574 = $P1573."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1574
.annotate 'line', 629
    get_hll_global $P1575, ["PAST"], "Op"
.annotate 'line', 631
    get_hll_global $P1576, ["PAST"], "Var"
    find_lex $P1577, "$name"
    $P1578 = $P1576."new"($P1577 :named("name"), "outer" :named("scope"))
    find_lex $P1579, "$cholder"
    $P1580 = $P1575."new"($P1578, $P1579, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 629
    store_lex "$dispatch_setup", $P1580
.annotate 'line', 634
    get_global $P1581, "@BLOCK"
    unless_null $P1581, vivify_576
    $P1581 = root_new ['parrot';'ResizablePMCArray']
  vivify_576:
    set $P1582, $P1581[0]
    unless_null $P1582, vivify_577
    $P1582 = root_new ['parrot';'ResizablePMCArray']
  vivify_577:
    set $P1583, $P1582[0]
    unless_null $P1583, vivify_578
    new $P1583, "Undef"
  vivify_578:
    get_hll_global $P1584, ["PAST"], "Var"
    find_lex $P1585, "$name"
    find_lex $P1586, "$dispatch_setup"
    $P1587 = $P1584."new"($P1585 :named("name"), 1 :named("isdecl"), $P1586 :named("viviself"), "lexical" :named("scope"))
    $P1583."push"($P1587)
.annotate 'line', 636
    get_global $P1588, "@BLOCK"
    unless_null $P1588, vivify_579
    $P1588 = root_new ['parrot';'ResizablePMCArray']
  vivify_579:
    set $P1589, $P1588[0]
    unless_null $P1589, vivify_580
    new $P1589, "Undef"
  vivify_580:
    find_lex $P1590, "$name"
    find_lex $P1591, "$cholder"
    $P1592 = $P1589."symbol"($P1590, "lexical" :named("scope"), $P1591 :named("cholder"))
.annotate 'line', 604
    .return ($P1592)
.end


.namespace ["NQP";"Actions"]
.sub "_block1544"  :anon :subid("96_1298839287.218") :outer("95_1298839287.218")
    .param pmc param_1547
.annotate 'line', 613
    $P1546 = root_new ['parrot';'Hash']
    .lex "%sym", $P1546
    .lex "$_", param_1547
    find_lex $P1548, "$_"
    find_lex $P1549, "$name"
    $P1550 = $P1548."symbol"($P1549)
    store_lex "%sym", $P1550
.annotate 'line', 614
    find_lex $P1555, "%sym"
    unless_null $P1555, vivify_572
    $P1555 = root_new ['parrot';'Hash']
  vivify_572:
    set $P1556, $P1555["proto"]
    unless_null $P1556, vivify_573
    new $P1556, "Undef"
  vivify_573:
    unless $P1556, unless_1554
    set $P1553, $P1556
    goto unless_1554_end
  unless_1554:
    find_lex $P1557, "%sym"
    unless_null $P1557, vivify_574
    $P1557 = root_new ['parrot';'Hash']
  vivify_574:
    set $P1558, $P1557["cholder"]
    unless_null $P1558, vivify_575
    new $P1558, "Undef"
  vivify_575:
    set $P1553, $P1558
  unless_1554_end:
    if $P1553, if_1552
.annotate 'line', 617
    find_lex $P1562, "%sym"
    if $P1562, if_1561
    set $P1560, $P1562
    goto if_1561_end
  if_1561:
.annotate 'line', 618
    find_lex $P1563, "$/"
    $P1564 = $P1563."CURSOR"()
    $P1565 = $P1564."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 617
    set $P1560, $P1565
  if_1561_end:
    set $P1551, $P1560
.annotate 'line', 614
    goto if_1552_end
  if_1552:
.annotate 'line', 615
    new $P1559, "Integer"
    assign $P1559, 1
    store_lex "$found_proto", $P1559
.annotate 'line', 614
    set $P1551, $P1559
  if_1552_end:
.annotate 'line', 612
    .return ($P1551)
.end


.namespace ["NQP";"Actions"]
.sub "_block1686"  :anon :subid("98_1298839287.218") :outer("92_1298839287.218")
    .param pmc param_1688
.annotate 'line', 692
    .lex "$_", param_1688
    find_lex $P1689, "$_"
    $P1690 = $P1689."ast"()
    find_lex $P1691, "$/"
    $P1692 = $P1690($P1691)
    .return ($P1692)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("99_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1700
    .param pmc param_1701
.annotate 'line', 699
    .const 'Sub' $P1813 = "101_1298839287.218" 
    capture_lex $P1813
    .const 'Sub' $P1729 = "100_1298839287.218" 
    capture_lex $P1729
    .lex "self", param_1700
    .lex "$/", param_1701
.annotate 'line', 702
    new $P1702, "Undef"
    .lex "$past", $P1702
.annotate 'line', 699
    find_lex $P1703, "$past"
.annotate 'line', 703
    find_lex $P1705, "$/"
    unless_null $P1705, vivify_589
    $P1705 = root_new ['parrot';'Hash']
  vivify_589:
    set $P1706, $P1705["onlystar"]
    unless_null $P1706, vivify_590
    new $P1706, "Undef"
  vivify_590:
    if $P1706, if_1704
.annotate 'line', 707
    find_lex $P1708, "$/"
    unless_null $P1708, vivify_591
    $P1708 = root_new ['parrot';'Hash']
  vivify_591:
    set $P1709, $P1708["blockoid"]
    unless_null $P1709, vivify_592
    new $P1709, "Undef"
  vivify_592:
    $P1710 = $P1709."ast"()
    store_lex "$past", $P1710
.annotate 'line', 708
    find_lex $P1711, "$past"
    $P1711."blocktype"("declaration")
.annotate 'line', 709
    find_dynamic_lex $P1713, "$*RETURN_USED"
    unless_null $P1713, vivify_593
    get_hll_global $P1713, "$RETURN_USED"
    unless_null $P1713, vivify_594
    die "Contextual $*RETURN_USED not found"
  vivify_594:
  vivify_593:
    unless $P1713, if_1712_end
.annotate 'line', 710
    find_lex $P1714, "$past"
    $P1714."control"("return_pir")
  if_1712_end:
.annotate 'line', 706
    goto if_1704_end
  if_1704:
.annotate 'line', 704
    $P1707 = "only_star_block"()
    store_lex "$past", $P1707
  if_1704_end:
.annotate 'line', 715
    find_lex $P1716, "$past"
    unless_null $P1716, vivify_595
    $P1716 = root_new ['parrot';'Hash']
  vivify_595:
    set $P1717, $P1716["signature_has_invocant"]
    unless_null $P1717, vivify_596
    new $P1717, "Undef"
  vivify_596:
    if $P1717, unless_1715_end
.annotate 'line', 716
    find_lex $P1718, "$past"
    unless_null $P1718, vivify_597
    $P1718 = root_new ['parrot';'ResizablePMCArray']
  vivify_597:
    set $P1719, $P1718[0]
    unless_null $P1719, vivify_598
    new $P1719, "Undef"
  vivify_598:
    get_hll_global $P1720, ["PAST"], "Var"
.annotate 'line', 718
    get_hll_global $P1721, ["PAST"], "Var"
    $P1722 = $P1721."new"("$?CLASS" :named("name"))
    $P1723 = $P1720."new"("self" :named("name"), "parameter" :named("scope"), $P1722 :named("multitype"))
.annotate 'line', 716
    $P1719."unshift"($P1723)
  unless_1715_end:
.annotate 'line', 721
    find_lex $P1724, "$past"
    $P1724."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 724
    find_lex $P1726, "$/"
    unless_null $P1726, vivify_599
    $P1726 = root_new ['parrot';'Hash']
  vivify_599:
    set $P1727, $P1726["deflongname"]
    unless_null $P1727, vivify_600
    new $P1727, "Undef"
  vivify_600:
    unless $P1727, if_1725_end
    .const 'Sub' $P1729 = "100_1298839287.218" 
    capture_lex $P1729
    $P1729()
  if_1725_end:
.annotate 'line', 759
    find_dynamic_lex $P1795, "$*SCOPE"
    unless_null $P1795, vivify_618
    get_hll_global $P1795, "$SCOPE"
    unless_null $P1795, vivify_619
    die "Contextual $*SCOPE not found"
  vivify_619:
  vivify_618:
    set $S1796, $P1795
    iseq $I1797, $S1796, "our"
    unless $I1797, if_1794_end
.annotate 'line', 760
    find_lex $P1798, "$past"
    $P1798."pirflags"(":nsentry")
  if_1794_end:
.annotate 'line', 764
    find_lex $P1799, "$/"
    find_lex $P1800, "$past"
    $P1799."!make"($P1800)
.annotate 'line', 765
    find_lex $P1801, "$past"
    find_lex $P1802, "$past"
    unless_null $P1802, vivify_620
    $P1802 = root_new ['parrot';'Hash']
    store_lex "$past", $P1802
  vivify_620:
    set $P1802["block_past"], $P1801
.annotate 'line', 766
    find_lex $P1805, "$/"
    unless_null $P1805, vivify_621
    $P1805 = root_new ['parrot';'Hash']
  vivify_621:
    set $P1806, $P1805["trait"]
    unless_null $P1806, vivify_622
    new $P1806, "Undef"
  vivify_622:
    if $P1806, if_1804
    set $P1803, $P1806
    goto if_1804_end
  if_1804:
.annotate 'line', 767
    find_lex $P1808, "$/"
    unless_null $P1808, vivify_623
    $P1808 = root_new ['parrot';'Hash']
  vivify_623:
    set $P1809, $P1808["trait"]
    unless_null $P1809, vivify_624
    new $P1809, "Undef"
  vivify_624:
    defined $I1810, $P1809
    unless $I1810, for_undef_625
    iter $P1807, $P1809
    new $P1820, 'ExceptionHandler'
    set_label $P1820, loop1819_handler
    $P1820."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1820
  loop1819_test:
    unless $P1807, loop1819_done
    shift $P1811, $P1807
  loop1819_redo:
    .const 'Sub' $P1813 = "101_1298839287.218" 
    capture_lex $P1813
    $P1813($P1811)
  loop1819_next:
    goto loop1819_test
  loop1819_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1821, exception, 'type'
    eq $P1821, .CONTROL_LOOP_NEXT, loop1819_next
    eq $P1821, .CONTROL_LOOP_REDO, loop1819_redo
  loop1819_done:
    pop_eh 
  for_undef_625:
.annotate 'line', 766
    set $P1803, $P1807
  if_1804_end:
.annotate 'line', 699
    .return ($P1803)
.end


.namespace ["NQP";"Actions"]
.sub "_block1728"  :anon :subid("100_1298839287.218") :outer("99_1298839287.218")
.annotate 'line', 726
    new $P1730, "Undef"
    .lex "$name", $P1730
.annotate 'line', 731
    new $P1731, "Undef"
    .lex "$to_add", $P1731
.annotate 'line', 726
    find_lex $P1732, "$/"
    unless_null $P1732, vivify_601
    $P1732 = root_new ['parrot';'Hash']
  vivify_601:
    set $P1733, $P1732["private"]
    unless_null $P1733, vivify_602
    new $P1733, "Undef"
  vivify_602:
    set $S1734, $P1733
    new $P1735, 'String'
    set $P1735, $S1734
    find_lex $P1736, "$/"
    unless_null $P1736, vivify_603
    $P1736 = root_new ['parrot';'Hash']
  vivify_603:
    set $P1737, $P1736["deflongname"]
    unless_null $P1737, vivify_604
    $P1737 = root_new ['parrot';'ResizablePMCArray']
  vivify_604:
    set $P1738, $P1737[0]
    unless_null $P1738, vivify_605
    new $P1738, "Undef"
  vivify_605:
    $P1739 = $P1738."ast"()
    set $S1740, $P1739
    concat $P1741, $P1735, $S1740
    store_lex "$name", $P1741
.annotate 'line', 727
    find_lex $P1742, "$past"
    find_lex $P1743, "$name"
    $P1742."name"($P1743)
.annotate 'line', 731
    find_dynamic_lex $P1746, "$*MULTINESS"
    unless_null $P1746, vivify_606
    get_hll_global $P1746, "$MULTINESS"
    unless_null $P1746, vivify_607
    die "Contextual $*MULTINESS not found"
  vivify_607:
  vivify_606:
    set $S1747, $P1746
    isne $I1748, $S1747, "proto"
    if $I1748, if_1745
.annotate 'line', 733
    get_hll_global $P1752, ["PAST"], "Op"
.annotate 'line', 735
    get_hll_global $P1753, ["PAST"], "Val"
    find_lex $P1754, "$past"
    $P1755 = $P1753."new"($P1754 :named("value"))
.annotate 'line', 736
    get_hll_global $P1756, ["PAST"], "Op"
    $P1757 = $P1756."new"("list" :named("pasttype"))
    $P1758 = $P1752."new"($P1755, $P1757, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 733
    set $P1744, $P1758
.annotate 'line', 731
    goto if_1745_end
  if_1745:
.annotate 'line', 732
    get_hll_global $P1749, ["PAST"], "Val"
    find_lex $P1750, "$past"
    $P1751 = $P1749."new"($P1750 :named("value"))
    set $P1744, $P1751
  if_1745_end:
.annotate 'line', 731
    store_lex "$to_add", $P1744
.annotate 'line', 738
    find_dynamic_lex $P1760, "$*MULTINESS"
    unless_null $P1760, vivify_608
    get_hll_global $P1760, "$MULTINESS"
    unless_null $P1760, vivify_609
    die "Contextual $*MULTINESS not found"
  vivify_609:
  vivify_608:
    set $S1761, $P1760
    iseq $I1762, $S1761, "proto"
    unless $I1762, if_1759_end
    find_lex $P1763, "$past"
    $P1763."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1759_end:
.annotate 'line', 742
    find_dynamic_lex $P1765, "$*MULTINESS"
    unless_null $P1765, vivify_610
    get_hll_global $P1765, "$MULTINESS"
    unless_null $P1765, vivify_611
    die "Contextual $*MULTINESS not found"
  vivify_611:
  vivify_610:
    set $S1766, $P1765
    iseq $I1767, $S1766, "multi"
    unless $I1767, if_1764_end
    find_lex $P1768, "$past"
    "attach_multi_signature"($P1768)
  if_1764_end:
.annotate 'line', 745
    find_dynamic_lex $P1771, "$*PACKAGE-SETUP"
    unless_null $P1771, vivify_612
    get_hll_global $P1771, "$PACKAGE-SETUP"
    unless_null $P1771, vivify_613
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_613:
  vivify_612:
    defined $I1772, $P1771
    if $I1772, if_1770
    new $P1769, 'Integer'
    set $P1769, $I1772
    goto if_1770_end
  if_1770:
.annotate 'line', 746
    find_dynamic_lex $P1773, "$*PACKAGE-SETUP"
    unless_null $P1773, vivify_614
    get_hll_global $P1773, "$PACKAGE-SETUP"
    unless_null $P1773, vivify_615
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_615:
  vivify_614:
    get_hll_global $P1774, ["PAST"], "Op"
.annotate 'line', 747
    find_dynamic_lex $P1777, "$*MULTINESS"
    unless_null $P1777, vivify_616
    get_hll_global $P1777, "$MULTINESS"
    unless_null $P1777, vivify_617
    die "Contextual $*MULTINESS not found"
  vivify_617:
  vivify_616:
    set $S1778, $P1777
    iseq $I1779, $S1778, "multi"
    if $I1779, if_1776
    new $P1781, "String"
    assign $P1781, "add_method"
    set $P1775, $P1781
    goto if_1776_end
  if_1776:
    new $P1780, "String"
    assign $P1780, "add_multi_method"
    set $P1775, $P1780
  if_1776_end:
.annotate 'line', 748
    get_hll_global $P1782, ["PAST"], "Op"
.annotate 'line', 751
    get_hll_global $P1783, ["PAST"], "Var"
    $P1784 = $P1783."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1785 = $P1782."new"($P1784, "get_how PP" :named("pirop"))
.annotate 'line', 753
    get_hll_global $P1786, ["PAST"], "Var"
    $P1787 = $P1786."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 754
    get_hll_global $P1788, ["PAST"], "Val"
    find_lex $P1789, "$name"
    $P1790 = $P1788."new"($P1789 :named("value"))
    find_lex $P1791, "$to_add"
    $P1792 = $P1774."new"($P1785, $P1787, $P1790, $P1791, "callmethod" :named("pasttype"), $P1775 :named("name"))
.annotate 'line', 746
    $P1793 = $P1773."push"($P1792)
.annotate 'line', 745
    set $P1769, $P1793
  if_1770_end:
.annotate 'line', 724
    .return ($P1769)
.end


.namespace ["NQP";"Actions"]
.sub "_block1812"  :anon :subid("101_1298839287.218") :outer("99_1298839287.218")
    .param pmc param_1814
.annotate 'line', 767
    .lex "$_", param_1814
    find_lex $P1815, "$_"
    $P1816 = $P1815."ast"()
    find_lex $P1817, "$/"
    $P1818 = $P1816($P1817)
    .return ($P1818)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("102_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1825
    .param pmc param_1826
.annotate 'line', 799
    .const 'Sub' $P1859 = "104_1298839287.218" 
    capture_lex $P1859
    .const 'Sub' $P1835 = "103_1298839287.218" 
    capture_lex $P1835
    .lex "self", param_1825
    .lex "$/", param_1826
.annotate 'line', 800
    new $P1827, "Undef"
    .lex "$BLOCKINIT", $P1827
    get_global $P1828, "@BLOCK"
    unless_null $P1828, vivify_626
    $P1828 = root_new ['parrot';'ResizablePMCArray']
  vivify_626:
    set $P1829, $P1828[0]
    unless_null $P1829, vivify_627
    $P1829 = root_new ['parrot';'ResizablePMCArray']
  vivify_627:
    set $P1830, $P1829[0]
    unless_null $P1830, vivify_628
    new $P1830, "Undef"
  vivify_628:
    store_lex "$BLOCKINIT", $P1830
.annotate 'line', 801
    find_lex $P1832, "$/"
    unless_null $P1832, vivify_629
    $P1832 = root_new ['parrot';'Hash']
  vivify_629:
    set $P1833, $P1832["invocant"]
    unless_null $P1833, vivify_630
    new $P1833, "Undef"
  vivify_630:
    unless $P1833, if_1831_end
    .const 'Sub' $P1835 = "103_1298839287.218" 
    capture_lex $P1835
    $P1835()
  if_1831_end:
.annotate 'line', 810
    find_lex $P1854, "$/"
    unless_null $P1854, vivify_636
    $P1854 = root_new ['parrot';'Hash']
  vivify_636:
    set $P1855, $P1854["parameter"]
    unless_null $P1855, vivify_637
    new $P1855, "Undef"
  vivify_637:
    defined $I1856, $P1855
    unless $I1856, for_undef_638
    iter $P1853, $P1855
    new $P1866, 'ExceptionHandler'
    set_label $P1866, loop1865_handler
    $P1866."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1866
  loop1865_test:
    unless $P1853, loop1865_done
    shift $P1857, $P1853
  loop1865_redo:
    .const 'Sub' $P1859 = "104_1298839287.218" 
    capture_lex $P1859
    $P1859($P1857)
  loop1865_next:
    goto loop1865_test
  loop1865_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1867, exception, 'type'
    eq $P1867, .CONTROL_LOOP_NEXT, loop1865_next
    eq $P1867, .CONTROL_LOOP_REDO, loop1865_redo
  loop1865_done:
    pop_eh 
  for_undef_638:
.annotate 'line', 799
    .return ($P1853)
.end


.namespace ["NQP";"Actions"]
.sub "_block1834"  :anon :subid("103_1298839287.218") :outer("102_1298839287.218")
.annotate 'line', 802
    new $P1836, "Undef"
    .lex "$inv", $P1836
    find_lex $P1837, "$/"
    unless_null $P1837, vivify_631
    $P1837 = root_new ['parrot';'Hash']
  vivify_631:
    set $P1838, $P1837["invocant"]
    unless_null $P1838, vivify_632
    $P1838 = root_new ['parrot';'ResizablePMCArray']
  vivify_632:
    set $P1839, $P1838[0]
    unless_null $P1839, vivify_633
    new $P1839, "Undef"
  vivify_633:
    $P1840 = $P1839."ast"()
    store_lex "$inv", $P1840
.annotate 'line', 803
    find_lex $P1841, "$BLOCKINIT"
    find_lex $P1842, "$inv"
    $P1841."push"($P1842)
.annotate 'line', 804
    find_lex $P1843, "$BLOCKINIT"
    get_hll_global $P1844, ["PAST"], "Var"
.annotate 'line', 806
    get_hll_global $P1845, ["PAST"], "Var"
    find_lex $P1846, "$inv"
    $P1847 = $P1846."name"()
    $P1848 = $P1845."new"("lexical" :named("scope"), $P1847 :named("name"))
    $P1849 = $P1844."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1848 :named("viviself"))
.annotate 'line', 804
    $P1843."push"($P1849)
.annotate 'line', 808
    new $P1850, "Integer"
    assign $P1850, 1
    get_global $P1851, "@BLOCK"
    unless_null $P1851, vivify_634
    $P1851 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1851
  vivify_634:
    set $P1852, $P1851[0]
    unless_null $P1852, vivify_635
    $P1852 = root_new ['parrot';'Hash']
    set $P1851[0], $P1852
  vivify_635:
    set $P1852["signature_has_invocant"], $P1850
.annotate 'line', 801
    .return ($P1850)
.end


.namespace ["NQP";"Actions"]
.sub "_block1858"  :anon :subid("104_1298839287.218") :outer("102_1298839287.218")
    .param pmc param_1860
.annotate 'line', 810
    .lex "$_", param_1860
    find_lex $P1861, "$BLOCKINIT"
    find_lex $P1862, "$_"
    $P1863 = $P1862."ast"()
    $P1864 = $P1861."push"($P1863)
    .return ($P1864)
.end


.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("105_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1869
    .param pmc param_1870
.annotate 'line', 813
    .lex "self", param_1869
    .lex "$/", param_1870
.annotate 'line', 814
    new $P1871, "Undef"
    .lex "$quant", $P1871
.annotate 'line', 815
    new $P1872, "Undef"
    .lex "$past", $P1872
.annotate 'line', 814
    find_lex $P1873, "$/"
    unless_null $P1873, vivify_639
    $P1873 = root_new ['parrot';'Hash']
  vivify_639:
    set $P1874, $P1873["quant"]
    unless_null $P1874, vivify_640
    new $P1874, "Undef"
  vivify_640:
    store_lex "$quant", $P1874
    find_lex $P1875, "$past"
.annotate 'line', 816
    find_lex $P1877, "$/"
    unless_null $P1877, vivify_641
    $P1877 = root_new ['parrot';'Hash']
  vivify_641:
    set $P1878, $P1877["named_param"]
    unless_null $P1878, vivify_642
    new $P1878, "Undef"
  vivify_642:
    if $P1878, if_1876
.annotate 'line', 823
    find_lex $P1892, "$/"
    unless_null $P1892, vivify_643
    $P1892 = root_new ['parrot';'Hash']
  vivify_643:
    set $P1893, $P1892["param_var"]
    unless_null $P1893, vivify_644
    new $P1893, "Undef"
  vivify_644:
    $P1894 = $P1893."ast"()
    store_lex "$past", $P1894
.annotate 'line', 824
    find_lex $P1896, "$quant"
    set $S1897, $P1896
    iseq $I1898, $S1897, "*"
    if $I1898, if_1895
.annotate 'line', 828
    find_lex $P1907, "$quant"
    set $S1908, $P1907
    iseq $I1909, $S1908, "?"
    unless $I1909, if_1906_end
.annotate 'line', 829
    find_lex $P1910, "$past"
    find_lex $P1911, "$/"
    unless_null $P1911, vivify_645
    $P1911 = root_new ['parrot';'Hash']
  vivify_645:
    set $P1912, $P1911["param_var"]
    unless_null $P1912, vivify_646
    $P1912 = root_new ['parrot';'Hash']
  vivify_646:
    set $P1913, $P1912["sigil"]
    unless_null $P1913, vivify_647
    new $P1913, "Undef"
  vivify_647:
    $P1914 = "vivitype"($P1913)
    $P1910."viviself"($P1914)
  if_1906_end:
.annotate 'line', 828
    goto if_1895_end
  if_1895:
.annotate 'line', 825
    find_lex $P1899, "$past"
    $P1899."slurpy"(1)
.annotate 'line', 826
    find_lex $P1900, "$past"
    find_lex $P1901, "$/"
    unless_null $P1901, vivify_648
    $P1901 = root_new ['parrot';'Hash']
  vivify_648:
    set $P1902, $P1901["param_var"]
    unless_null $P1902, vivify_649
    $P1902 = root_new ['parrot';'Hash']
  vivify_649:
    set $P1903, $P1902["sigil"]
    unless_null $P1903, vivify_650
    new $P1903, "Undef"
  vivify_650:
    set $S1904, $P1903
    iseq $I1905, $S1904, "%"
    $P1900."named"($I1905)
  if_1895_end:
.annotate 'line', 822
    goto if_1876_end
  if_1876:
.annotate 'line', 817
    find_lex $P1879, "$/"
    unless_null $P1879, vivify_651
    $P1879 = root_new ['parrot';'Hash']
  vivify_651:
    set $P1880, $P1879["named_param"]
    unless_null $P1880, vivify_652
    new $P1880, "Undef"
  vivify_652:
    $P1881 = $P1880."ast"()
    store_lex "$past", $P1881
.annotate 'line', 818
    find_lex $P1883, "$quant"
    set $S1884, $P1883
    isne $I1885, $S1884, "!"
    unless $I1885, if_1882_end
.annotate 'line', 819
    find_lex $P1886, "$past"
    find_lex $P1887, "$/"
    unless_null $P1887, vivify_653
    $P1887 = root_new ['parrot';'Hash']
  vivify_653:
    set $P1888, $P1887["named_param"]
    unless_null $P1888, vivify_654
    $P1888 = root_new ['parrot';'Hash']
  vivify_654:
    set $P1889, $P1888["param_var"]
    unless_null $P1889, vivify_655
    $P1889 = root_new ['parrot';'Hash']
  vivify_655:
    set $P1890, $P1889["sigil"]
    unless_null $P1890, vivify_656
    new $P1890, "Undef"
  vivify_656:
    $P1891 = "vivitype"($P1890)
    $P1886."viviself"($P1891)
  if_1882_end:
  if_1876_end:
.annotate 'line', 832
    find_lex $P1916, "$/"
    unless_null $P1916, vivify_657
    $P1916 = root_new ['parrot';'Hash']
  vivify_657:
    set $P1917, $P1916["default_value"]
    unless_null $P1917, vivify_658
    new $P1917, "Undef"
  vivify_658:
    unless $P1917, if_1915_end
.annotate 'line', 833
    find_lex $P1919, "$quant"
    set $S1920, $P1919
    iseq $I1921, $S1920, "*"
    unless $I1921, if_1918_end
.annotate 'line', 834
    find_lex $P1922, "$/"
    $P1923 = $P1922."CURSOR"()
    $P1923."panic"("Can't put default on slurpy parameter")
  if_1918_end:
.annotate 'line', 836
    find_lex $P1925, "$quant"
    set $S1926, $P1925
    iseq $I1927, $S1926, "!"
    unless $I1927, if_1924_end
.annotate 'line', 837
    find_lex $P1928, "$/"
    $P1929 = $P1928."CURSOR"()
    $P1929."panic"("Can't put default on required parameter")
  if_1924_end:
.annotate 'line', 839
    find_lex $P1930, "$past"
    find_lex $P1931, "$/"
    unless_null $P1931, vivify_659
    $P1931 = root_new ['parrot';'Hash']
  vivify_659:
    set $P1932, $P1931["default_value"]
    unless_null $P1932, vivify_660
    $P1932 = root_new ['parrot';'ResizablePMCArray']
  vivify_660:
    set $P1933, $P1932[0]
    unless_null $P1933, vivify_661
    $P1933 = root_new ['parrot';'Hash']
  vivify_661:
    set $P1934, $P1933["EXPR"]
    unless_null $P1934, vivify_662
    new $P1934, "Undef"
  vivify_662:
    $P1935 = $P1934."ast"()
    $P1930."viviself"($P1935)
  if_1915_end:
.annotate 'line', 841
    find_lex $P1937, "$past"
    $P1938 = $P1937."viviself"()
    if $P1938, unless_1936_end
    get_global $P1939, "@BLOCK"
    unless_null $P1939, vivify_663
    $P1939 = root_new ['parrot';'ResizablePMCArray']
  vivify_663:
    set $P1940, $P1939[0]
    unless_null $P1940, vivify_664
    new $P1940, "Undef"
  vivify_664:
    get_global $P1941, "@BLOCK"
    unless_null $P1941, vivify_665
    $P1941 = root_new ['parrot';'ResizablePMCArray']
  vivify_665:
    set $P1942, $P1941[0]
    unless_null $P1942, vivify_666
    new $P1942, "Undef"
  vivify_666:
    $P1943 = $P1942."arity"()
    set $N1944, $P1943
    new $P1945, 'Float'
    set $P1945, $N1944
    add $P1946, $P1945, 1
    $P1940."arity"($P1946)
  unless_1936_end:
.annotate 'line', 845
    find_lex $P1948, "$/"
    unless_null $P1948, vivify_667
    $P1948 = root_new ['parrot';'Hash']
  vivify_667:
    set $P1949, $P1948["typename"]
    unless_null $P1949, vivify_668
    new $P1949, "Undef"
  vivify_668:
    unless $P1949, if_1947_end
.annotate 'line', 846
    find_lex $P1950, "$past"
    find_lex $P1951, "$/"
    unless_null $P1951, vivify_669
    $P1951 = root_new ['parrot';'Hash']
  vivify_669:
    set $P1952, $P1951["typename"]
    unless_null $P1952, vivify_670
    $P1952 = root_new ['parrot';'ResizablePMCArray']
  vivify_670:
    set $P1953, $P1952[0]
    unless_null $P1953, vivify_671
    new $P1953, "Undef"
  vivify_671:
    $P1954 = $P1953."ast"()
    $P1950."multitype"($P1954)
  if_1947_end:
.annotate 'line', 850
    find_lex $P1956, "$/"
    unless_null $P1956, vivify_672
    $P1956 = root_new ['parrot';'Hash']
  vivify_672:
    set $P1957, $P1956["definedness"]
    unless_null $P1957, vivify_673
    new $P1957, "Undef"
  vivify_673:
    unless $P1957, if_1955_end
.annotate 'line', 851
    find_lex $P1958, "$/"
    unless_null $P1958, vivify_674
    $P1958 = root_new ['parrot';'Hash']
  vivify_674:
    set $P1959, $P1958["definedness"]
    unless_null $P1959, vivify_675
    $P1959 = root_new ['parrot';'ResizablePMCArray']
  vivify_675:
    set $P1960, $P1959[0]
    unless_null $P1960, vivify_676
    new $P1960, "Undef"
  vivify_676:
    set $S1961, $P1960
    new $P1962, 'String'
    set $P1962, $S1961
    find_lex $P1963, "$past"
    unless_null $P1963, vivify_677
    $P1963 = root_new ['parrot';'Hash']
    store_lex "$past", $P1963
  vivify_677:
    set $P1963["definedness"], $P1962
  if_1955_end:
.annotate 'line', 854
    find_lex $P1964, "$/"
    find_lex $P1965, "$past"
    $P1966 = $P1964."!make"($P1965)
.annotate 'line', 813
    .return ($P1966)
.end


.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("106_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1968
    .param pmc param_1969
.annotate 'line', 857
    .lex "self", param_1968
    .lex "$/", param_1969
.annotate 'line', 858
    new $P1970, "Undef"
    .lex "$name", $P1970
.annotate 'line', 859
    new $P1971, "Undef"
    .lex "$past", $P1971
.annotate 'line', 858
    find_lex $P1972, "$/"
    set $S1973, $P1972
    new $P1974, 'String'
    set $P1974, $S1973
    store_lex "$name", $P1974
.annotate 'line', 859
    get_hll_global $P1975, ["PAST"], "Var"
    find_lex $P1976, "$name"
    find_lex $P1977, "$/"
    $P1978 = $P1975."new"($P1976 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P1977 :named("node"))
    store_lex "$past", $P1978
.annotate 'line', 861
    get_global $P1979, "@BLOCK"
    unless_null $P1979, vivify_678
    $P1979 = root_new ['parrot';'ResizablePMCArray']
  vivify_678:
    set $P1980, $P1979[0]
    unless_null $P1980, vivify_679
    new $P1980, "Undef"
  vivify_679:
    find_lex $P1981, "$name"
    $P1980."symbol"($P1981, "lexical" :named("scope"))
.annotate 'line', 862
    find_lex $P1982, "$/"
    find_lex $P1983, "$past"
    $P1984 = $P1982."!make"($P1983)
.annotate 'line', 857
    .return ($P1984)
.end


.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("107_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_1986
    .param pmc param_1987
.annotate 'line', 865
    .lex "self", param_1986
    .lex "$/", param_1987
.annotate 'line', 866
    new $P1988, "Undef"
    .lex "$past", $P1988
    find_lex $P1989, "$/"
    unless_null $P1989, vivify_680
    $P1989 = root_new ['parrot';'Hash']
  vivify_680:
    set $P1990, $P1989["param_var"]
    unless_null $P1990, vivify_681
    new $P1990, "Undef"
  vivify_681:
    $P1991 = $P1990."ast"()
    store_lex "$past", $P1991
.annotate 'line', 867
    find_lex $P1992, "$past"
    find_lex $P1993, "$/"
    unless_null $P1993, vivify_682
    $P1993 = root_new ['parrot';'Hash']
  vivify_682:
    set $P1994, $P1993["param_var"]
    unless_null $P1994, vivify_683
    $P1994 = root_new ['parrot';'Hash']
  vivify_683:
    set $P1995, $P1994["name"]
    unless_null $P1995, vivify_684
    new $P1995, "Undef"
  vivify_684:
    set $S1996, $P1995
    $P1992."named"($S1996)
.annotate 'line', 868
    find_lex $P1997, "$/"
    find_lex $P1998, "$past"
    $P1999 = $P1997."!make"($P1998)
.annotate 'line', 865
    .return ($P1999)
.end


.namespace ["NQP";"Actions"]
.sub "typename"  :subid("108_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2001
    .param pmc param_2002
.annotate 'line', 871
    .lex "self", param_2001
    .lex "$/", param_2002
.annotate 'line', 872
    $P2003 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P2003
    get_hll_global $P2004, ["HLL"], "Compiler"
    find_lex $P2005, "$/"
    set $S2006, $P2005
    $P2007 = $P2004."parse_name"($S2006)
    store_lex "@name", $P2007
.annotate 'line', 873
    find_lex $P2008, "$/"
    get_hll_global $P2009, ["PAST"], "Var"
.annotate 'line', 874
    find_lex $P2010, "@name"
    $P2011 = $P2010."pop"()
    find_lex $P2012, "@name"
    $P2013 = $P2009."new"($P2011 :named("name"), $P2012 :named("namespace"), "package" :named("scope"))
.annotate 'line', 873
    $P2014 = $P2008."!make"($P2013)
.annotate 'line', 871
    .return ($P2014)
.end


.namespace ["NQP";"Actions"]
.sub "trait"  :subid("109_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2016
    .param pmc param_2017
.annotate 'line', 880
    .lex "self", param_2016
    .lex "$/", param_2017
.annotate 'line', 881
    find_lex $P2018, "$/"
    find_lex $P2019, "$/"
    unless_null $P2019, vivify_685
    $P2019 = root_new ['parrot';'Hash']
  vivify_685:
    set $P2020, $P2019["trait_mod"]
    unless_null $P2020, vivify_686
    new $P2020, "Undef"
  vivify_686:
    $P2021 = $P2020."ast"()
    $P2022 = $P2018."!make"($P2021)
.annotate 'line', 880
    .return ($P2022)
.end


.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("110_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2024
    .param pmc param_2025
.annotate 'line', 884
    .const 'Sub' $P2045 = "111_1298839287.218" 
    capture_lex $P2045
    .lex "self", param_2024
    .lex "$/", param_2025
.annotate 'line', 885
    new $P2026, "Undef"
    .lex "$cpast", $P2026
    find_lex $P2027, "$/"
    unless_null $P2027, vivify_687
    $P2027 = root_new ['parrot';'Hash']
  vivify_687:
    set $P2028, $P2027["circumfix"]
    unless_null $P2028, vivify_688
    $P2028 = root_new ['parrot';'ResizablePMCArray']
  vivify_688:
    set $P2029, $P2028[0]
    unless_null $P2029, vivify_689
    new $P2029, "Undef"
  vivify_689:
    $P2030 = $P2029."ast"()
    store_lex "$cpast", $P2030
.annotate 'line', 886
    find_lex $P2033, "$/"
    unless_null $P2033, vivify_690
    $P2033 = root_new ['parrot';'Hash']
  vivify_690:
    set $P2034, $P2033["longname"]
    unless_null $P2034, vivify_691
    new $P2034, "Undef"
  vivify_691:
    set $S2035, $P2034
    iseq $I2036, $S2035, "parrot_vtable"
    if $I2036, if_2032
.annotate 'line', 906
    find_lex $P2071, "$/"
    unless_null $P2071, vivify_692
    $P2071 = root_new ['parrot';'Hash']
  vivify_692:
    set $P2072, $P2071["longname"]
    unless_null $P2072, vivify_693
    new $P2072, "Undef"
  vivify_693:
    set $S2073, $P2072
    iseq $I2074, $S2073, "pirflags"
    if $I2074, if_2070
.annotate 'line', 910
    find_lex $P2078, "$/"
    $P2079 = $P2078."CURSOR"()
    new $P2080, 'String'
    set $P2080, "Trait '"
    find_lex $P2081, "$/"
    unless_null $P2081, vivify_694
    $P2081 = root_new ['parrot';'Hash']
  vivify_694:
    set $P2082, $P2081["longname"]
    unless_null $P2082, vivify_695
    new $P2082, "Undef"
  vivify_695:
    concat $P2083, $P2080, $P2082
    concat $P2084, $P2083, "' not implemented"
    $P2085 = $P2079."panic"($P2084)
.annotate 'line', 909
    set $P2069, $P2085
.annotate 'line', 906
    goto if_2070_end
  if_2070:
.annotate 'line', 907
    find_lex $P2075, "$/"
    $P2076 = $P2075."CURSOR"()
    $P2077 = $P2076."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 906
    set $P2069, $P2077
  if_2070_end:
    set $P2031, $P2069
.annotate 'line', 886
    goto if_2032_end
  if_2032:
.annotate 'line', 889
    get_hll_global $P2038, ["PAST"], "Val"
    find_lex $P2039, "$cpast"
    $P2040 = $P2038."ACCEPTS"($P2039)
    if $P2040, unless_2037_end
.annotate 'line', 888
    find_lex $P2041, "$/"
    $P2042 = $P2041."CURSOR"()
    $P2042."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2037_end:
.annotate 'line', 890
    find_lex $P2043, "$/"
    .const 'Sub' $P2045 = "111_1298839287.218" 
    newclosure $P2067, $P2045
    $P2068 = $P2043."!make"($P2067)
.annotate 'line', 886
    set $P2031, $P2068
  if_2032_end:
.annotate 'line', 884
    .return ($P2031)
.end


.namespace ["NQP";"Actions"]
.sub "_block2044"  :anon :subid("111_1298839287.218") :outer("110_1298839287.218")
    .param pmc param_2046
.annotate 'line', 890
    .lex "$match", param_2046
.annotate 'line', 891
    new $P2047, "Undef"
    .lex "$meth", $P2047
    find_lex $P2048, "$match"
    $P2049 = $P2048."ast"()
    set $P2050, $P2049["block_past"]
    unless_null $P2050, vivify_696
    new $P2050, "Undef"
  vivify_696:
    store_lex "$meth", $P2050
.annotate 'line', 892
    find_dynamic_lex $P2053, "$*PACKAGE-SETUP"
    unless_null $P2053, vivify_697
    get_hll_global $P2053, "$PACKAGE-SETUP"
    unless_null $P2053, vivify_698
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_698:
  vivify_697:
    defined $I2054, $P2053
    if $I2054, if_2052
    new $P2051, 'Integer'
    set $P2051, $I2054
    goto if_2052_end
  if_2052:
.annotate 'line', 893
    find_dynamic_lex $P2055, "$*PACKAGE-SETUP"
    unless_null $P2055, vivify_699
    get_hll_global $P2055, "$PACKAGE-SETUP"
    unless_null $P2055, vivify_700
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_700:
  vivify_699:
    get_hll_global $P2056, ["PAST"], "Op"
.annotate 'line', 895
    get_hll_global $P2057, ["PAST"], "Op"
.annotate 'line', 898
    get_hll_global $P2058, ["PAST"], "Var"
    $P2059 = $P2058."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2060 = $P2057."new"($P2059, "get_how PP" :named("pirop"))
.annotate 'line', 900
    get_hll_global $P2061, ["PAST"], "Var"
    $P2062 = $P2061."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2063, "$cpast"
    find_lex $P2064, "$meth"
    $P2065 = $P2056."new"($P2060, $P2062, $P2063, $P2064, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 893
    $P2066 = $P2055."push"($P2065)
.annotate 'line', 892
    set $P2051, $P2066
  if_2052_end:
.annotate 'line', 890
    .return ($P2051)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("112_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2089
    .param pmc param_2090
    .param pmc param_2091 :optional
    .param int has_param_2091 :opt_flag
.annotate 'line', 914
    .const 'Sub' $P2189 = "115_1298839287.218" 
    capture_lex $P2189
    .const 'Sub' $P2161 = "114_1298839287.218" 
    capture_lex $P2161
    .const 'Sub' $P2134 = "113_1298839287.218" 
    capture_lex $P2134
    new $P2088, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2088, control_2087
    push_eh $P2088
    .lex "self", param_2089
    .lex "$/", param_2090
    if has_param_2091, optparam_701
    new $P2092, "Undef"
    set param_2091, $P2092
  optparam_701:
    .lex "$key", param_2091
.annotate 'line', 915
    $P2093 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2093
.annotate 'line', 918
    new $P2094, "Undef"
    .lex "$name", $P2094
.annotate 'line', 919
    new $P2095, "Undef"
    .lex "$past", $P2095
.annotate 'line', 915

        $P2096 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2096
.annotate 'line', 918
    find_lex $P2097, "$/"
    unless_null $P2097, vivify_702
    $P2097 = root_new ['parrot';'Hash']
  vivify_702:
    set $P2098, $P2097["deflongname"]
    unless_null $P2098, vivify_703
    new $P2098, "Undef"
  vivify_703:
    $P2099 = $P2098."ast"()
    set $S2100, $P2099
    new $P2101, 'String'
    set $P2101, $S2100
    store_lex "$name", $P2101
    find_lex $P2102, "$past"
.annotate 'line', 920
    find_lex $P2104, "$/"
    unless_null $P2104, vivify_704
    $P2104 = root_new ['parrot';'Hash']
  vivify_704:
    set $P2105, $P2104["proto"]
    unless_null $P2105, vivify_705
    new $P2105, "Undef"
  vivify_705:
    if $P2105, if_2103
.annotate 'line', 959
    find_lex $P2157, "$key"
    set $S2158, $P2157
    iseq $I2159, $S2158, "open"
    if $I2159, if_2156
.annotate 'line', 972
    .const 'Sub' $P2189 = "115_1298839287.218" 
    capture_lex $P2189
    $P2189()
    goto if_2156_end
  if_2156:
.annotate 'line', 959
    .const 'Sub' $P2161 = "114_1298839287.218" 
    capture_lex $P2161
    $P2161()
  if_2156_end:
    goto if_2103_end
  if_2103:
.annotate 'line', 922
    get_hll_global $P2106, ["PAST"], "Stmts"
.annotate 'line', 923
    get_hll_global $P2107, ["PAST"], "Block"
    find_lex $P2108, "$name"
.annotate 'line', 924
    get_hll_global $P2109, ["PAST"], "Op"
.annotate 'line', 925
    get_hll_global $P2110, ["PAST"], "Var"
    $P2111 = $P2110."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2112, "$name"
    $P2113 = $P2109."new"($P2111, $P2112, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 924
    find_lex $P2114, "$/"
    $P2115 = $P2107."new"($P2113, $P2108 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2114 :named("node"))
.annotate 'line', 934
    get_hll_global $P2116, ["PAST"], "Block"
    new $P2117, "String"
    assign $P2117, "!PREFIX__"
    find_lex $P2118, "$name"
    concat $P2119, $P2117, $P2118
.annotate 'line', 935
    get_hll_global $P2120, ["PAST"], "Op"
.annotate 'line', 936
    get_hll_global $P2121, ["PAST"], "Var"
    $P2122 = $P2121."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2123, "$name"
    $P2124 = $P2120."new"($P2122, $P2123, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 935
    find_lex $P2125, "$/"
    $P2126 = $P2116."new"($P2124, $P2119 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2125 :named("node"))
.annotate 'line', 934
    $P2127 = $P2106."new"($P2115, $P2126)
.annotate 'line', 922
    store_lex "$past", $P2127
.annotate 'line', 946
    find_lex $P2129, "$past"
    $P2130 = $P2129."list"()
    defined $I2131, $P2130
    unless $I2131, for_undef_726
    iter $P2128, $P2130
    new $P2154, 'ExceptionHandler'
    set_label $P2154, loop2153_handler
    $P2154."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2154
  loop2153_test:
    unless $P2128, loop2153_done
    shift $P2132, $P2128
  loop2153_redo:
    .const 'Sub' $P2134 = "113_1298839287.218" 
    capture_lex $P2134
    $P2134($P2132)
  loop2153_next:
    goto loop2153_test
  loop2153_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2155, exception, 'type'
    eq $P2155, .CONTROL_LOOP_NEXT, loop2153_next
    eq $P2155, .CONTROL_LOOP_REDO, loop2153_redo
  loop2153_done:
    pop_eh 
  for_undef_726:
  if_2103_end:
.annotate 'line', 1008
    find_lex $P2247, "$/"
    find_lex $P2248, "$past"
    $P2249 = $P2247."!make"($P2248)
.annotate 'line', 914
    .return ($P2249)
  control_2087:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2250, exception, "payload"
    .return ($P2250)
.end


.namespace ["NQP";"Actions"]
.sub "_block2188"  :anon :subid("115_1298839287.218") :outer("112_1298839287.218")
.annotate 'line', 973
    new $P2190, "Undef"
    .lex "$regex", $P2190
.annotate 'line', 974
    get_hll_global $P2191, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2192, "$/"
    unless_null $P2192, vivify_706
    $P2192 = root_new ['parrot';'Hash']
  vivify_706:
    set $P2193, $P2192["p6regex"]
    unless_null $P2193, vivify_707
    new $P2193, "Undef"
  vivify_707:
    $P2194 = $P2193."ast"()
    get_global $P2195, "@BLOCK"
    $P2196 = $P2195."shift"()
    $P2197 = $P2191($P2194, $P2196)
    store_lex "$regex", $P2197
.annotate 'line', 975
    find_lex $P2198, "$regex"
    find_lex $P2199, "$name"
    $P2198."name"($P2199)
.annotate 'line', 977
    get_hll_global $P2200, ["PAST"], "Op"
.annotate 'line', 979
    get_hll_global $P2201, ["PAST"], "Var"
    new $P2202, "ResizablePMCArray"
    push $P2202, "Regex"
    $P2203 = $P2201."new"("Method" :named("name"), $P2202 :named("namespace"), "package" :named("scope"))
    find_lex $P2204, "$regex"
    $P2205 = $P2200."new"($P2203, $P2204, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 977
    store_lex "$past", $P2205
.annotate 'line', 982
    find_dynamic_lex $P2207, "$*PACKAGE-SETUP"
    unless_null $P2207, vivify_708
    get_hll_global $P2207, "$PACKAGE-SETUP"
    unless_null $P2207, vivify_709
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_709:
  vivify_708:
    defined $I2208, $P2207
    unless $I2208, if_2206_end
.annotate 'line', 983
    find_dynamic_lex $P2209, "$*PACKAGE-SETUP"
    unless_null $P2209, vivify_710
    get_hll_global $P2209, "$PACKAGE-SETUP"
    unless_null $P2209, vivify_711
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_711:
  vivify_710:
    get_hll_global $P2210, ["PAST"], "Op"
.annotate 'line', 985
    get_hll_global $P2211, ["PAST"], "Op"
.annotate 'line', 987
    get_hll_global $P2212, ["PAST"], "Var"
    $P2213 = $P2212."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2214 = $P2211."new"($P2213, "get_how PP" :named("pirop"))
.annotate 'line', 989
    get_hll_global $P2215, ["PAST"], "Var"
    $P2216 = $P2215."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 990
    get_hll_global $P2217, ["PAST"], "Val"
    find_lex $P2218, "$name"
    $P2219 = $P2217."new"($P2218 :named("value"))
.annotate 'line', 991
    get_hll_global $P2220, ["PAST"], "Val"
    find_lex $P2221, "$regex"
    $P2222 = $P2220."new"($P2221 :named("value"))
    $P2223 = $P2210."new"($P2214, $P2216, $P2219, $P2222, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 983
    $P2209."push"($P2223)
.annotate 'line', 993
    find_dynamic_lex $P2224, "$*PACKAGE-SETUP"
    unless_null $P2224, vivify_712
    get_hll_global $P2224, "$PACKAGE-SETUP"
    unless_null $P2224, vivify_713
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_713:
  vivify_712:
    get_hll_global $P2225, ["PAST"], "Op"
.annotate 'line', 995
    get_hll_global $P2226, ["PAST"], "Op"
.annotate 'line', 997
    get_hll_global $P2227, ["PAST"], "Var"
    $P2228 = $P2227."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2229 = $P2226."new"($P2228, "get_how PP" :named("pirop"))
.annotate 'line', 999
    get_hll_global $P2230, ["PAST"], "Var"
    $P2231 = $P2230."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1000
    get_hll_global $P2232, ["PAST"], "Val"
    new $P2233, "String"
    assign $P2233, "!PREFIX__"
    find_lex $P2234, "$name"
    concat $P2235, $P2233, $P2234
    $P2236 = $P2232."new"($P2235 :named("value"))
.annotate 'line', 1001
    get_hll_global $P2237, ["PAST"], "Var"
    new $P2238, "String"
    assign $P2238, "!PREFIX__"
    find_lex $P2239, "$name"
    concat $P2240, $P2238, $P2239
    $P2241 = $P2237."new"($P2240 :named("name"), "package" :named("scope"))
    $P2242 = $P2225."new"($P2229, $P2231, $P2236, $P2241, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 993
    $P2224."push"($P2242)
  if_2206_end:
.annotate 'line', 1005
    find_lex $P2243, "$regex"
    find_lex $P2244, "$past"
    unless_null $P2244, vivify_714
    $P2244 = root_new ['parrot';'Hash']
    store_lex "$past", $P2244
  vivify_714:
    set $P2244["sink"], $P2243
.annotate 'line', 1006
    find_lex $P2245, "@MODIFIERS"
    $P2246 = $P2245."shift"()
.annotate 'line', 972
    .return ($P2246)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2160"  :anon :subid("114_1298839287.218") :outer("112_1298839287.218")
.annotate 'line', 960
    $P2162 = root_new ['parrot';'Hash']
    .lex "%h", $P2162
.annotate 'line', 959
    find_lex $P2163, "%h"
.annotate 'line', 961
    find_lex $P2165, "$/"
    unless_null $P2165, vivify_715
    $P2165 = root_new ['parrot';'Hash']
  vivify_715:
    set $P2166, $P2165["sym"]
    unless_null $P2166, vivify_716
    new $P2166, "Undef"
  vivify_716:
    set $S2167, $P2166
    iseq $I2168, $S2167, "token"
    unless $I2168, if_2164_end
    new $P2169, "Integer"
    assign $P2169, 1
    find_lex $P2170, "%h"
    unless_null $P2170, vivify_717
    $P2170 = root_new ['parrot';'Hash']
    store_lex "%h", $P2170
  vivify_717:
    set $P2170["r"], $P2169
  if_2164_end:
.annotate 'line', 962
    find_lex $P2172, "$/"
    unless_null $P2172, vivify_718
    $P2172 = root_new ['parrot';'Hash']
  vivify_718:
    set $P2173, $P2172["sym"]
    unless_null $P2173, vivify_719
    new $P2173, "Undef"
  vivify_719:
    set $S2174, $P2173
    iseq $I2175, $S2174, "rule"
    unless $I2175, if_2171_end
    new $P2176, "Integer"
    assign $P2176, 1
    find_lex $P2177, "%h"
    unless_null $P2177, vivify_720
    $P2177 = root_new ['parrot';'Hash']
    store_lex "%h", $P2177
  vivify_720:
    set $P2177["r"], $P2176
    new $P2178, "Integer"
    assign $P2178, 1
    find_lex $P2179, "%h"
    unless_null $P2179, vivify_721
    $P2179 = root_new ['parrot';'Hash']
    store_lex "%h", $P2179
  vivify_721:
    set $P2179["s"], $P2178
  if_2171_end:
.annotate 'line', 963
    find_lex $P2180, "@MODIFIERS"
    find_lex $P2181, "%h"
    $P2180."unshift"($P2181)
.annotate 'line', 964

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 968
    get_global $P2182, "@BLOCK"
    unless_null $P2182, vivify_722
    $P2182 = root_new ['parrot';'ResizablePMCArray']
  vivify_722:
    set $P2183, $P2182[0]
    unless_null $P2183, vivify_723
    new $P2183, "Undef"
  vivify_723:
    $P2183."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 969
    get_global $P2184, "@BLOCK"
    unless_null $P2184, vivify_724
    $P2184 = root_new ['parrot';'ResizablePMCArray']
  vivify_724:
    set $P2185, $P2184[0]
    unless_null $P2185, vivify_725
    new $P2185, "Undef"
  vivify_725:
    $P2185."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 970
    new $P2186, "Exception"
    set $P2186['type'], .CONTROL_RETURN
    new $P2187, "Integer"
    assign $P2187, 0
    setattribute $P2186, 'payload', $P2187
    throw $P2186
.annotate 'line', 959
    .return ()
.end


.namespace ["NQP";"Actions"]
.sub "_block2133"  :anon :subid("113_1298839287.218") :outer("112_1298839287.218")
    .param pmc param_2135
.annotate 'line', 946
    .lex "$_", param_2135
.annotate 'line', 947
    find_dynamic_lex $P2136, "$*PACKAGE-SETUP"
    unless_null $P2136, vivify_727
    get_hll_global $P2136, "$PACKAGE-SETUP"
    unless_null $P2136, vivify_728
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_728:
  vivify_727:
    get_hll_global $P2137, ["PAST"], "Op"
.annotate 'line', 949
    get_hll_global $P2138, ["PAST"], "Op"
.annotate 'line', 951
    get_hll_global $P2139, ["PAST"], "Var"
    $P2140 = $P2139."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2141 = $P2138."new"($P2140, "get_how PP" :named("pirop"))
.annotate 'line', 953
    get_hll_global $P2142, ["PAST"], "Var"
    $P2143 = $P2142."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 954
    get_hll_global $P2144, ["PAST"], "Val"
    find_lex $P2145, "$_"
    $P2146 = $P2145."name"()
    $P2147 = $P2144."new"($P2146 :named("value"))
.annotate 'line', 955
    get_hll_global $P2148, ["PAST"], "Val"
    find_lex $P2149, "$_"
    $P2150 = $P2148."new"($P2149 :named("value"))
    $P2151 = $P2137."new"($P2141, $P2143, $P2147, $P2150, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 947
    $P2152 = $P2136."push"($P2151)
.annotate 'line', 946
    .return ($P2152)
.end


.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("116_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2252
    .param pmc param_2253
.annotate 'line', 1012
    .lex "self", param_2252
    .lex "$/", param_2253
.annotate 'line', 1013
    new $P2254, "Undef"
    .lex "$past", $P2254
    find_lex $P2257, "$/"
    unless_null $P2257, vivify_729
    $P2257 = root_new ['parrot';'Hash']
  vivify_729:
    set $P2258, $P2257["args"]
    unless_null $P2258, vivify_730
    new $P2258, "Undef"
  vivify_730:
    if $P2258, if_2256
    get_hll_global $P2263, ["PAST"], "Op"
    find_lex $P2264, "$/"
    $P2265 = $P2263."new"($P2264 :named("node"))
    set $P2255, $P2265
    goto if_2256_end
  if_2256:
    find_lex $P2259, "$/"
    unless_null $P2259, vivify_731
    $P2259 = root_new ['parrot';'Hash']
  vivify_731:
    set $P2260, $P2259["args"]
    unless_null $P2260, vivify_732
    $P2260 = root_new ['parrot';'ResizablePMCArray']
  vivify_732:
    set $P2261, $P2260[0]
    unless_null $P2261, vivify_733
    new $P2261, "Undef"
  vivify_733:
    $P2262 = $P2261."ast"()
    set $P2255, $P2262
  if_2256_end:
    store_lex "$past", $P2255
.annotate 'line', 1014
    find_lex $P2267, "$/"
    unless_null $P2267, vivify_734
    $P2267 = root_new ['parrot';'Hash']
  vivify_734:
    set $P2268, $P2267["quote"]
    unless_null $P2268, vivify_735
    new $P2268, "Undef"
  vivify_735:
    if $P2268, if_2266
.annotate 'line', 1018
    find_lex $P2275, "$/"
    unless_null $P2275, vivify_736
    $P2275 = root_new ['parrot';'Hash']
  vivify_736:
    set $P2276, $P2275["longname"]
    unless_null $P2276, vivify_737
    new $P2276, "Undef"
  vivify_737:
    set $S2277, $P2276
    iseq $I2278, $S2277, "HOW"
    if $I2278, if_2274
.annotate 'line', 1022
    find_lex $P2282, "$/"
    unless_null $P2282, vivify_738
    $P2282 = root_new ['parrot';'Hash']
  vivify_738:
    set $P2283, $P2282["longname"]
    unless_null $P2283, vivify_739
    new $P2283, "Undef"
  vivify_739:
    set $S2284, $P2283
    iseq $I2285, $S2284, "WHAT"
    if $I2285, if_2281
.annotate 'line', 1026
    find_lex $P2287, "$past"
    find_lex $P2288, "$/"
    unless_null $P2288, vivify_740
    $P2288 = root_new ['parrot';'Hash']
  vivify_740:
    set $P2289, $P2288["longname"]
    unless_null $P2289, vivify_741
    new $P2289, "Undef"
  vivify_741:
    set $S2290, $P2289
    $P2287."name"($S2290)
.annotate 'line', 1027
    find_lex $P2291, "$past"
    $P2291."pasttype"("callmethod")
.annotate 'line', 1025
    goto if_2281_end
  if_2281:
.annotate 'line', 1023
    find_lex $P2286, "$past"
    $P2286."pirop"("get_what PP")
  if_2281_end:
.annotate 'line', 1022
    goto if_2274_end
  if_2274:
.annotate 'line', 1019
    find_lex $P2279, "$past"
    $P2279."pirop"("get_how PP")
.annotate 'line', 1020
    find_lex $P2280, "$past"
    $P2280."pasttype"("pirop")
  if_2274_end:
.annotate 'line', 1018
    goto if_2266_end
  if_2266:
.annotate 'line', 1015
    find_lex $P2269, "$past"
    find_lex $P2270, "$/"
    unless_null $P2270, vivify_742
    $P2270 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2271, $P2270["quote"]
    unless_null $P2271, vivify_743
    new $P2271, "Undef"
  vivify_743:
    $P2272 = $P2271."ast"()
    $P2269."name"($P2272)
.annotate 'line', 1016
    find_lex $P2273, "$past"
    $P2273."pasttype"("callmethod")
  if_2266_end:
.annotate 'line', 1029
    find_lex $P2292, "$/"
    find_lex $P2293, "$past"
    $P2294 = $P2292."!make"($P2293)
.annotate 'line', 1012
    .return ($P2294)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("117_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2296
    .param pmc param_2297
.annotate 'line', 1034
    .lex "self", param_2296
    .lex "$/", param_2297
.annotate 'line', 1035
    find_lex $P2298, "$/"
    get_hll_global $P2299, ["PAST"], "Var"
    $P2300 = $P2299."new"("self" :named("name"))
    $P2301 = $P2298."!make"($P2300)
.annotate 'line', 1034
    .return ($P2301)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("118_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2303
    .param pmc param_2304
.annotate 'line', 1038
    .lex "self", param_2303
    .lex "$/", param_2304
.annotate 'line', 1039
    new $P2305, "Undef"
    .lex "$past", $P2305
    find_lex $P2306, "$/"
    unless_null $P2306, vivify_744
    $P2306 = root_new ['parrot';'Hash']
  vivify_744:
    set $P2307, $P2306["args"]
    unless_null $P2307, vivify_745
    new $P2307, "Undef"
  vivify_745:
    $P2308 = $P2307."ast"()
    store_lex "$past", $P2308
.annotate 'line', 1040
    find_lex $P2309, "$past"
    find_lex $P2310, "$/"
    unless_null $P2310, vivify_746
    $P2310 = root_new ['parrot';'Hash']
  vivify_746:
    set $P2311, $P2310["deflongname"]
    unless_null $P2311, vivify_747
    new $P2311, "Undef"
  vivify_747:
    set $S2312, $P2311
    $P2309."name"($S2312)
.annotate 'line', 1041
    find_lex $P2313, "$/"
    find_lex $P2314, "$past"
    $P2315 = $P2313."!make"($P2314)
.annotate 'line', 1038
    .return ($P2315)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("119_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2317
    .param pmc param_2318
.annotate 'line', 1044
    .lex "self", param_2317
    .lex "$/", param_2318
.annotate 'line', 1045
    $P2319 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2319
.annotate 'line', 1046
    new $P2320, "Undef"
    .lex "$name", $P2320
.annotate 'line', 1048
    new $P2321, "Undef"
    .lex "$var", $P2321
.annotate 'line', 1050
    new $P2322, "Undef"
    .lex "$past", $P2322
.annotate 'line', 1045
    find_lex $P2323, "$/"
    unless_null $P2323, vivify_748
    $P2323 = root_new ['parrot';'Hash']
  vivify_748:
    set $P2324, $P2323["name"]
    unless_null $P2324, vivify_749
    $P2324 = root_new ['parrot';'Hash']
  vivify_749:
    set $P2325, $P2324["identifier"]
    unless_null $P2325, vivify_750
    new $P2325, "Undef"
  vivify_750:
    clone $P2326, $P2325
    store_lex "@ns", $P2326
.annotate 'line', 1046
    find_lex $P2327, "@ns"
    $P2328 = $P2327."pop"()
    store_lex "$name", $P2328
.annotate 'line', 1047
    find_lex $P2332, "@ns"
    if $P2332, if_2331
    set $P2330, $P2332
    goto if_2331_end
  if_2331:
    find_lex $P2333, "@ns"
    unless_null $P2333, vivify_751
    $P2333 = root_new ['parrot';'ResizablePMCArray']
  vivify_751:
    set $P2334, $P2333[0]
    unless_null $P2334, vivify_752
    new $P2334, "Undef"
  vivify_752:
    set $S2335, $P2334
    iseq $I2336, $S2335, "GLOBAL"
    new $P2330, 'Integer'
    set $P2330, $I2336
  if_2331_end:
    unless $P2330, if_2329_end
    find_lex $P2337, "@ns"
    $P2337."shift"()
  if_2329_end:
.annotate 'line', 1049
    get_hll_global $P2338, ["PAST"], "Var"
    find_lex $P2339, "$name"
    set $S2340, $P2339
    find_lex $P2341, "@ns"
    $P2342 = $P2338."new"($S2340 :named("name"), $P2341 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2342
.annotate 'line', 1050
    find_lex $P2343, "$var"
    store_lex "$past", $P2343
.annotate 'line', 1051
    find_lex $P2345, "$/"
    unless_null $P2345, vivify_753
    $P2345 = root_new ['parrot';'Hash']
  vivify_753:
    set $P2346, $P2345["args"]
    unless_null $P2346, vivify_754
    new $P2346, "Undef"
  vivify_754:
    unless $P2346, if_2344_end
.annotate 'line', 1052
    find_lex $P2347, "$/"
    unless_null $P2347, vivify_755
    $P2347 = root_new ['parrot';'Hash']
  vivify_755:
    set $P2348, $P2347["args"]
    unless_null $P2348, vivify_756
    $P2348 = root_new ['parrot';'ResizablePMCArray']
  vivify_756:
    set $P2349, $P2348[0]
    unless_null $P2349, vivify_757
    new $P2349, "Undef"
  vivify_757:
    $P2350 = $P2349."ast"()
    store_lex "$past", $P2350
.annotate 'line', 1053
    find_lex $P2351, "$past"
    find_lex $P2352, "$var"
    $P2351."unshift"($P2352)
  if_2344_end:
.annotate 'line', 1055
    find_lex $P2353, "$/"
    find_lex $P2354, "$past"
    $P2355 = $P2353."!make"($P2354)
.annotate 'line', 1044
    .return ($P2355)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("120_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2357
    .param pmc param_2358
.annotate 'line', 1058
    .lex "self", param_2357
    .lex "$/", param_2358
.annotate 'line', 1059
    new $P2359, "Undef"
    .lex "$past", $P2359
.annotate 'line', 1060
    new $P2360, "Undef"
    .lex "$pirop", $P2360
.annotate 'line', 1059
    find_lex $P2363, "$/"
    unless_null $P2363, vivify_758
    $P2363 = root_new ['parrot';'Hash']
  vivify_758:
    set $P2364, $P2363["args"]
    unless_null $P2364, vivify_759
    new $P2364, "Undef"
  vivify_759:
    if $P2364, if_2362
    get_hll_global $P2369, ["PAST"], "Op"
    find_lex $P2370, "$/"
    $P2371 = $P2369."new"($P2370 :named("node"))
    set $P2361, $P2371
    goto if_2362_end
  if_2362:
    find_lex $P2365, "$/"
    unless_null $P2365, vivify_760
    $P2365 = root_new ['parrot';'Hash']
  vivify_760:
    set $P2366, $P2365["args"]
    unless_null $P2366, vivify_761
    $P2366 = root_new ['parrot';'ResizablePMCArray']
  vivify_761:
    set $P2367, $P2366[0]
    unless_null $P2367, vivify_762
    new $P2367, "Undef"
  vivify_762:
    $P2368 = $P2367."ast"()
    set $P2361, $P2368
  if_2362_end:
    store_lex "$past", $P2361
.annotate 'line', 1060
    find_lex $P2372, "$/"
    unless_null $P2372, vivify_763
    $P2372 = root_new ['parrot';'Hash']
  vivify_763:
    set $P2373, $P2372["op"]
    unless_null $P2373, vivify_764
    new $P2373, "Undef"
  vivify_764:
    set $S2374, $P2373
    new $P2375, 'String'
    set $P2375, $S2374
    store_lex "$pirop", $P2375
.annotate 'line', 1061

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2376 = box $S0
    
    store_lex "$pirop", $P2376
.annotate 'line', 1068
    find_lex $P2377, "$past"
    find_lex $P2378, "$pirop"
    $P2377."pirop"($P2378)
.annotate 'line', 1069
    find_lex $P2379, "$past"
    $P2379."pasttype"("pirop")
.annotate 'line', 1070
    find_lex $P2380, "$/"
    find_lex $P2381, "$past"
    $P2382 = $P2380."!make"($P2381)
.annotate 'line', 1058
    .return ($P2382)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("121_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2384
    .param pmc param_2385
.annotate 'line', 1073
    .lex "self", param_2384
    .lex "$/", param_2385
.annotate 'line', 1074
    find_lex $P2386, "$/"
    get_hll_global $P2387, ["PAST"], "Op"
    $P2388 = $P2387."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2389 = $P2386."!make"($P2388)
.annotate 'line', 1073
    .return ($P2389)
.end


.namespace ["NQP";"Actions"]
.sub "args"  :subid("122_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2391
    .param pmc param_2392
.annotate 'line', 1079
    .lex "self", param_2391
    .lex "$/", param_2392
    find_lex $P2393, "$/"
    find_lex $P2394, "$/"
    unless_null $P2394, vivify_765
    $P2394 = root_new ['parrot';'Hash']
  vivify_765:
    set $P2395, $P2394["arglist"]
    unless_null $P2395, vivify_766
    new $P2395, "Undef"
  vivify_766:
    $P2396 = $P2395."ast"()
    $P2397 = $P2393."!make"($P2396)
    .return ($P2397)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("123_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2399
    .param pmc param_2400
.annotate 'line', 1081
    .const 'Sub' $P2411 = "124_1298839287.218" 
    capture_lex $P2411
    .lex "self", param_2399
    .lex "$/", param_2400
.annotate 'line', 1082
    new $P2401, "Undef"
    .lex "$past", $P2401
.annotate 'line', 1090
    new $P2402, "Undef"
    .lex "$i", $P2402
.annotate 'line', 1091
    new $P2403, "Undef"
    .lex "$n", $P2403
.annotate 'line', 1082
    get_hll_global $P2404, ["PAST"], "Op"
    find_lex $P2405, "$/"
    $P2406 = $P2404."new"("call" :named("pasttype"), $P2405 :named("node"))
    store_lex "$past", $P2406
.annotate 'line', 1083
    find_lex $P2408, "$/"
    unless_null $P2408, vivify_767
    $P2408 = root_new ['parrot';'Hash']
  vivify_767:
    set $P2409, $P2408["EXPR"]
    unless_null $P2409, vivify_768
    new $P2409, "Undef"
  vivify_768:
    unless $P2409, if_2407_end
    .const 'Sub' $P2411 = "124_1298839287.218" 
    capture_lex $P2411
    $P2411()
  if_2407_end:
.annotate 'line', 1090
    new $P2443, "Integer"
    assign $P2443, 0
    store_lex "$i", $P2443
.annotate 'line', 1091
    find_lex $P2444, "$past"
    $P2445 = $P2444."list"()
    set $N2446, $P2445
    new $P2447, 'Float'
    set $P2447, $N2446
    store_lex "$n", $P2447
.annotate 'line', 1092
    new $P2495, 'ExceptionHandler'
    set_label $P2495, loop2494_handler
    $P2495."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2495
  loop2494_test:
    find_lex $P2448, "$i"
    set $N2449, $P2448
    find_lex $P2450, "$n"
    set $N2451, $P2450
    islt $I2452, $N2449, $N2451
    unless $I2452, loop2494_done
  loop2494_redo:
.annotate 'line', 1093
    find_lex $P2454, "$i"
    set $I2455, $P2454
    find_lex $P2456, "$past"
    unless_null $P2456, vivify_772
    $P2456 = root_new ['parrot';'ResizablePMCArray']
  vivify_772:
    set $P2457, $P2456[$I2455]
    unless_null $P2457, vivify_773
    new $P2457, "Undef"
  vivify_773:
    $S2458 = $P2457."name"()
    iseq $I2459, $S2458, "&prefix:<|>"
    unless $I2459, if_2453_end
.annotate 'line', 1094
    find_lex $P2460, "$i"
    set $I2461, $P2460
    find_lex $P2462, "$past"
    unless_null $P2462, vivify_774
    $P2462 = root_new ['parrot';'ResizablePMCArray']
  vivify_774:
    set $P2463, $P2462[$I2461]
    unless_null $P2463, vivify_775
    $P2463 = root_new ['parrot';'ResizablePMCArray']
  vivify_775:
    set $P2464, $P2463[0]
    unless_null $P2464, vivify_776
    new $P2464, "Undef"
  vivify_776:
    find_lex $P2465, "$i"
    set $I2466, $P2465
    find_lex $P2467, "$past"
    unless_null $P2467, vivify_777
    $P2467 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2467
  vivify_777:
    set $P2467[$I2466], $P2464
.annotate 'line', 1095
    find_lex $P2468, "$i"
    set $I2469, $P2468
    find_lex $P2470, "$past"
    unless_null $P2470, vivify_778
    $P2470 = root_new ['parrot';'ResizablePMCArray']
  vivify_778:
    set $P2471, $P2470[$I2469]
    unless_null $P2471, vivify_779
    new $P2471, "Undef"
  vivify_779:
    $P2471."flat"(1)
.annotate 'line', 1096
    find_lex $P2475, "$i"
    set $I2476, $P2475
    find_lex $P2477, "$past"
    unless_null $P2477, vivify_780
    $P2477 = root_new ['parrot';'ResizablePMCArray']
  vivify_780:
    set $P2478, $P2477[$I2476]
    unless_null $P2478, vivify_781
    new $P2478, "Undef"
  vivify_781:
    get_hll_global $P2479, ["PAST"], "Val"
    $P2480 = $P2478."isa"($P2479)
    if $P2480, if_2474
    set $P2473, $P2480
    goto if_2474_end
  if_2474:
.annotate 'line', 1097
    find_lex $P2481, "$i"
    set $I2482, $P2481
    find_lex $P2483, "$past"
    unless_null $P2483, vivify_782
    $P2483 = root_new ['parrot';'ResizablePMCArray']
  vivify_782:
    set $P2484, $P2483[$I2482]
    unless_null $P2484, vivify_783
    new $P2484, "Undef"
  vivify_783:
    $S2485 = $P2484."name"()
    substr $S2486, $S2485, 0, 1
    iseq $I2487, $S2486, "%"
    new $P2473, 'Integer'
    set $P2473, $I2487
  if_2474_end:
    unless $P2473, if_2472_end
.annotate 'line', 1098
    find_lex $P2488, "$i"
    set $I2489, $P2488
    find_lex $P2490, "$past"
    unless_null $P2490, vivify_784
    $P2490 = root_new ['parrot';'ResizablePMCArray']
  vivify_784:
    set $P2491, $P2490[$I2489]
    unless_null $P2491, vivify_785
    new $P2491, "Undef"
  vivify_785:
    $P2491."named"(1)
  if_2472_end:
  if_2453_end:
.annotate 'line', 1093
    find_lex $P2492, "$i"
    clone $P2493, $P2492
    inc $P2492
  loop2494_next:
.annotate 'line', 1092
    goto loop2494_test
  loop2494_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2496, exception, 'type'
    eq $P2496, .CONTROL_LOOP_NEXT, loop2494_next
    eq $P2496, .CONTROL_LOOP_REDO, loop2494_redo
  loop2494_done:
    pop_eh 
.annotate 'line', 1103
    find_lex $P2497, "$/"
    find_lex $P2498, "$past"
    $P2499 = $P2497."!make"($P2498)
.annotate 'line', 1081
    .return ($P2499)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2410"  :anon :subid("124_1298839287.218") :outer("123_1298839287.218")
.annotate 'line', 1083
    .const 'Sub' $P2432 = "125_1298839287.218" 
    capture_lex $P2432
.annotate 'line', 1084
    new $P2412, "Undef"
    .lex "$expr", $P2412
    find_lex $P2413, "$/"
    unless_null $P2413, vivify_769
    $P2413 = root_new ['parrot';'Hash']
  vivify_769:
    set $P2414, $P2413["EXPR"]
    unless_null $P2414, vivify_770
    new $P2414, "Undef"
  vivify_770:
    $P2415 = $P2414."ast"()
    store_lex "$expr", $P2415
.annotate 'line', 1085
    find_lex $P2420, "$expr"
    $S2421 = $P2420."name"()
    iseq $I2422, $S2421, "&infix:<,>"
    if $I2422, if_2419
    new $P2418, 'Integer'
    set $P2418, $I2422
    goto if_2419_end
  if_2419:
    find_lex $P2423, "$expr"
    $P2424 = $P2423."named"()
    isfalse $I2425, $P2424
    new $P2418, 'Integer'
    set $P2418, $I2425
  if_2419_end:
    if $P2418, if_2417
.annotate 'line', 1088
    find_lex $P2440, "$past"
    find_lex $P2441, "$expr"
    $P2442 = $P2440."push"($P2441)
    set $P2416, $P2442
.annotate 'line', 1085
    goto if_2417_end
  if_2417:
.annotate 'line', 1086
    find_lex $P2427, "$expr"
    $P2428 = $P2427."list"()
    defined $I2429, $P2428
    unless $I2429, for_undef_771
    iter $P2426, $P2428
    new $P2438, 'ExceptionHandler'
    set_label $P2438, loop2437_handler
    $P2438."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2438
  loop2437_test:
    unless $P2426, loop2437_done
    shift $P2430, $P2426
  loop2437_redo:
    .const 'Sub' $P2432 = "125_1298839287.218" 
    capture_lex $P2432
    $P2432($P2430)
  loop2437_next:
    goto loop2437_test
  loop2437_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2439, exception, 'type'
    eq $P2439, .CONTROL_LOOP_NEXT, loop2437_next
    eq $P2439, .CONTROL_LOOP_REDO, loop2437_redo
  loop2437_done:
    pop_eh 
  for_undef_771:
.annotate 'line', 1085
    set $P2416, $P2426
  if_2417_end:
.annotate 'line', 1083
    .return ($P2416)
.end


.namespace ["NQP";"Actions"]
.sub "_block2431"  :anon :subid("125_1298839287.218") :outer("124_1298839287.218")
    .param pmc param_2433
.annotate 'line', 1086
    .lex "$_", param_2433
    find_lex $P2434, "$past"
    find_lex $P2435, "$_"
    $P2436 = $P2434."push"($P2435)
    .return ($P2436)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("126_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2501
    .param pmc param_2502
.annotate 'line', 1106
    .lex "self", param_2501
    .lex "$/", param_2502
    find_lex $P2503, "$/"
    find_lex $P2504, "$/"
    unless_null $P2504, vivify_786
    $P2504 = root_new ['parrot';'Hash']
  vivify_786:
    set $P2505, $P2504["multi_declarator"]
    unless_null $P2505, vivify_787
    new $P2505, "Undef"
  vivify_787:
    $P2506 = $P2505."ast"()
    $P2507 = $P2503."!make"($P2506)
    .return ($P2507)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("127_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2509
    .param pmc param_2510
.annotate 'line', 1108
    .lex "self", param_2509
    .lex "$/", param_2510
    find_lex $P2511, "$/"
    find_lex $P2512, "$/"
    unless_null $P2512, vivify_788
    $P2512 = root_new ['parrot';'Hash']
  vivify_788:
    set $P2513, $P2512["value"]
    unless_null $P2513, vivify_789
    new $P2513, "Undef"
  vivify_789:
    $P2514 = $P2513."ast"()
    $P2515 = $P2511."!make"($P2514)
    .return ($P2515)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("128_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2517
    .param pmc param_2518
.annotate 'line', 1110
    .lex "self", param_2517
    .lex "$/", param_2518
.annotate 'line', 1111
    find_lex $P2519, "$/"
.annotate 'line', 1112
    find_lex $P2522, "$/"
    unless_null $P2522, vivify_790
    $P2522 = root_new ['parrot';'Hash']
  vivify_790:
    set $P2523, $P2522["EXPR"]
    unless_null $P2523, vivify_791
    new $P2523, "Undef"
  vivify_791:
    if $P2523, if_2521
.annotate 'line', 1113
    get_hll_global $P2528, ["PAST"], "Op"
    find_lex $P2529, "$/"
    $P2530 = $P2528."new"("list" :named("pasttype"), $P2529 :named("node"))
    set $P2520, $P2530
.annotate 'line', 1112
    goto if_2521_end
  if_2521:
    find_lex $P2524, "$/"
    unless_null $P2524, vivify_792
    $P2524 = root_new ['parrot';'Hash']
  vivify_792:
    set $P2525, $P2524["EXPR"]
    unless_null $P2525, vivify_793
    $P2525 = root_new ['parrot';'ResizablePMCArray']
  vivify_793:
    set $P2526, $P2525[0]
    unless_null $P2526, vivify_794
    new $P2526, "Undef"
  vivify_794:
    $P2527 = $P2526."ast"()
    set $P2520, $P2527
  if_2521_end:
    $P2531 = $P2519."!make"($P2520)
.annotate 'line', 1110
    .return ($P2531)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("129_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2533
    .param pmc param_2534
.annotate 'line', 1116
    .lex "self", param_2533
    .lex "$/", param_2534
.annotate 'line', 1117
    new $P2535, "Undef"
    .lex "$past", $P2535
.annotate 'line', 1116
    find_lex $P2536, "$past"
.annotate 'line', 1118
    find_lex $P2538, "$/"
    unless_null $P2538, vivify_795
    $P2538 = root_new ['parrot';'Hash']
  vivify_795:
    set $P2539, $P2538["EXPR"]
    unless_null $P2539, vivify_796
    new $P2539, "Undef"
  vivify_796:
    if $P2539, if_2537
.annotate 'line', 1125
    get_hll_global $P2551, ["PAST"], "Op"
    $P2552 = $P2551."new"("list" :named("pasttype"))
    store_lex "$past", $P2552
.annotate 'line', 1124
    goto if_2537_end
  if_2537:
.annotate 'line', 1119
    find_lex $P2540, "$/"
    unless_null $P2540, vivify_797
    $P2540 = root_new ['parrot';'Hash']
  vivify_797:
    set $P2541, $P2540["EXPR"]
    unless_null $P2541, vivify_798
    $P2541 = root_new ['parrot';'ResizablePMCArray']
  vivify_798:
    set $P2542, $P2541[0]
    unless_null $P2542, vivify_799
    new $P2542, "Undef"
  vivify_799:
    $P2543 = $P2542."ast"()
    store_lex "$past", $P2543
.annotate 'line', 1120
    find_lex $P2545, "$past"
    $S2546 = $P2545."name"()
    isne $I2547, $S2546, "&infix:<,>"
    unless $I2547, if_2544_end
.annotate 'line', 1121
    get_hll_global $P2548, ["PAST"], "Op"
    find_lex $P2549, "$past"
    $P2550 = $P2548."new"($P2549, "list" :named("pasttype"))
    store_lex "$past", $P2550
  if_2544_end:
  if_2537_end:
.annotate 'line', 1127
    find_lex $P2553, "$past"
    $P2553."name"("&circumfix:<[ ]>")
.annotate 'line', 1128
    find_lex $P2554, "$/"
    find_lex $P2555, "$past"
    $P2556 = $P2554."!make"($P2555)
.annotate 'line', 1116
    .return ($P2556)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("130_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2558
    .param pmc param_2559
.annotate 'line', 1131
    .lex "self", param_2558
    .lex "$/", param_2559
    find_lex $P2560, "$/"
    find_lex $P2561, "$/"
    unless_null $P2561, vivify_800
    $P2561 = root_new ['parrot';'Hash']
  vivify_800:
    set $P2562, $P2561["quote_EXPR"]
    unless_null $P2562, vivify_801
    new $P2562, "Undef"
  vivify_801:
    $P2563 = $P2562."ast"()
    $P2564 = $P2560."!make"($P2563)
    .return ($P2564)
.end


.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("131_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2566
    .param pmc param_2567
.annotate 'line', 1132
    .lex "self", param_2566
    .lex "$/", param_2567
    find_lex $P2568, "$/"
    find_lex $P2569, "$/"
    unless_null $P2569, vivify_802
    $P2569 = root_new ['parrot';'Hash']
  vivify_802:
    set $P2570, $P2569["quote_EXPR"]
    unless_null $P2570, vivify_803
    new $P2570, "Undef"
  vivify_803:
    $P2571 = $P2570."ast"()
    $P2572 = $P2568."!make"($P2571)
    .return ($P2572)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("132_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2574
    .param pmc param_2575
.annotate 'line', 1134
    .lex "self", param_2574
    .lex "$/", param_2575
.annotate 'line', 1135
    new $P2576, "Undef"
    .lex "$past", $P2576
    find_lex $P2579, "$/"
    unless_null $P2579, vivify_804
    $P2579 = root_new ['parrot';'Hash']
  vivify_804:
    set $P2580, $P2579["pblock"]
    unless_null $P2580, vivify_805
    $P2580 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2581, $P2580["blockoid"]
    unless_null $P2581, vivify_806
    $P2581 = root_new ['parrot';'Hash']
  vivify_806:
    set $P2582, $P2581["statementlist"]
    unless_null $P2582, vivify_807
    $P2582 = root_new ['parrot';'Hash']
  vivify_807:
    set $P2583, $P2582["statement"]
    unless_null $P2583, vivify_808
    new $P2583, "Undef"
  vivify_808:
    set $N2584, $P2583
    isgt $I2585, $N2584, 0.0
    if $I2585, if_2578
.annotate 'line', 1137
    $P2589 = "vivitype"("%")
    set $P2577, $P2589
.annotate 'line', 1135
    goto if_2578_end
  if_2578:
.annotate 'line', 1136
    find_lex $P2586, "$/"
    unless_null $P2586, vivify_809
    $P2586 = root_new ['parrot';'Hash']
  vivify_809:
    set $P2587, $P2586["pblock"]
    unless_null $P2587, vivify_810
    new $P2587, "Undef"
  vivify_810:
    $P2588 = $P2587."ast"()
    set $P2577, $P2588
  if_2578_end:
    store_lex "$past", $P2577
.annotate 'line', 1138
    new $P2590, "Integer"
    assign $P2590, 1
    find_lex $P2591, "$past"
    unless_null $P2591, vivify_811
    $P2591 = root_new ['parrot';'Hash']
    store_lex "$past", $P2591
  vivify_811:
    set $P2591["bareblock"], $P2590
.annotate 'line', 1139
    find_lex $P2592, "$/"
    find_lex $P2593, "$past"
    $P2594 = $P2592."!make"($P2593)
.annotate 'line', 1134
    .return ($P2594)
.end


.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("133_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2596
    .param pmc param_2597
.annotate 'line', 1142
    .lex "self", param_2596
    .lex "$/", param_2597
.annotate 'line', 1143
    new $P2598, "Undef"
    .lex "$name", $P2598
    find_lex $P2601, "$/"
    unless_null $P2601, vivify_812
    $P2601 = root_new ['parrot';'Hash']
  vivify_812:
    set $P2602, $P2601["sigil"]
    unless_null $P2602, vivify_813
    new $P2602, "Undef"
  vivify_813:
    set $S2603, $P2602
    iseq $I2604, $S2603, "@"
    if $I2604, if_2600
.annotate 'line', 1144
    find_lex $P2608, "$/"
    unless_null $P2608, vivify_814
    $P2608 = root_new ['parrot';'Hash']
  vivify_814:
    set $P2609, $P2608["sigil"]
    unless_null $P2609, vivify_815
    new $P2609, "Undef"
  vivify_815:
    set $S2610, $P2609
    iseq $I2611, $S2610, "%"
    if $I2611, if_2607
    new $P2613, "String"
    assign $P2613, "item"
    set $P2606, $P2613
    goto if_2607_end
  if_2607:
    new $P2612, "String"
    assign $P2612, "hash"
    set $P2606, $P2612
  if_2607_end:
    set $P2599, $P2606
.annotate 'line', 1143
    goto if_2600_end
  if_2600:
    new $P2605, "String"
    assign $P2605, "list"
    set $P2599, $P2605
  if_2600_end:
    store_lex "$name", $P2599
.annotate 'line', 1146
    find_lex $P2614, "$/"
    get_hll_global $P2615, ["PAST"], "Op"
    find_lex $P2616, "$name"
    find_lex $P2617, "$/"
    unless_null $P2617, vivify_816
    $P2617 = root_new ['parrot';'Hash']
  vivify_816:
    set $P2618, $P2617["semilist"]
    unless_null $P2618, vivify_817
    new $P2618, "Undef"
  vivify_817:
    $P2619 = $P2618."ast"()
    $P2620 = $P2615."new"($P2619, "callmethod" :named("pasttype"), $P2616 :named("name"))
    $P2621 = $P2614."!make"($P2620)
.annotate 'line', 1142
    .return ($P2621)
.end


.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("134_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2623
    .param pmc param_2624
.annotate 'line', 1149
    .lex "self", param_2623
    .lex "$/", param_2624
    find_lex $P2625, "$/"
    find_lex $P2626, "$/"
    unless_null $P2626, vivify_818
    $P2626 = root_new ['parrot';'Hash']
  vivify_818:
    set $P2627, $P2626["statement"]
    unless_null $P2627, vivify_819
    new $P2627, "Undef"
  vivify_819:
    $P2628 = $P2627."ast"()
    $P2629 = $P2625."!make"($P2628)
    .return ($P2629)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("135_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2631
    .param pmc param_2632
.annotate 'line', 1151
    .lex "self", param_2631
    .lex "$/", param_2632
.annotate 'line', 1152
    find_lex $P2633, "$/"
    get_hll_global $P2634, ["PAST"], "Var"
    find_lex $P2635, "$/"
    unless_null $P2635, vivify_820
    $P2635 = root_new ['parrot';'Hash']
  vivify_820:
    set $P2636, $P2635["EXPR"]
    unless_null $P2636, vivify_821
    new $P2636, "Undef"
  vivify_821:
    $P2637 = $P2636."ast"()
.annotate 'line', 1154
    $P2638 = "vivitype"("@")
    $P2639 = $P2634."new"($P2637, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2638 :named("vivibase"))
.annotate 'line', 1152
    $P2640 = $P2633."!make"($P2639)
.annotate 'line', 1151
    .return ($P2640)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("136_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2642
    .param pmc param_2643
.annotate 'line', 1157
    .lex "self", param_2642
    .lex "$/", param_2643
.annotate 'line', 1158
    find_lex $P2644, "$/"
    get_hll_global $P2645, ["PAST"], "Var"
    find_lex $P2646, "$/"
    unless_null $P2646, vivify_822
    $P2646 = root_new ['parrot';'Hash']
  vivify_822:
    set $P2647, $P2646["EXPR"]
    unless_null $P2647, vivify_823
    new $P2647, "Undef"
  vivify_823:
    $P2648 = $P2647."ast"()
.annotate 'line', 1160
    $P2649 = "vivitype"("%")
    $P2650 = $P2645."new"($P2648, "keyed" :named("scope"), "Undef" :named("viviself"), $P2649 :named("vivibase"))
.annotate 'line', 1158
    $P2651 = $P2644."!make"($P2650)
.annotate 'line', 1157
    .return ($P2651)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("137_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2653
    .param pmc param_2654
.annotate 'line', 1163
    .lex "self", param_2653
    .lex "$/", param_2654
.annotate 'line', 1164
    find_lex $P2655, "$/"
    get_hll_global $P2656, ["PAST"], "Var"
    find_lex $P2657, "$/"
    unless_null $P2657, vivify_824
    $P2657 = root_new ['parrot';'Hash']
  vivify_824:
    set $P2658, $P2657["quote_EXPR"]
    unless_null $P2658, vivify_825
    new $P2658, "Undef"
  vivify_825:
    $P2659 = $P2658."ast"()
.annotate 'line', 1166
    $P2660 = "vivitype"("%")
    $P2661 = $P2656."new"($P2659, "keyed" :named("scope"), "Undef" :named("viviself"), $P2660 :named("vivibase"))
.annotate 'line', 1164
    $P2662 = $P2655."!make"($P2661)
.annotate 'line', 1163
    .return ($P2662)
.end


.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("138_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2664
    .param pmc param_2665
.annotate 'line', 1169
    .lex "self", param_2664
    .lex "$/", param_2665
.annotate 'line', 1170
    find_lex $P2666, "$/"
    find_lex $P2667, "$/"
    unless_null $P2667, vivify_826
    $P2667 = root_new ['parrot';'Hash']
  vivify_826:
    set $P2668, $P2667["arglist"]
    unless_null $P2668, vivify_827
    new $P2668, "Undef"
  vivify_827:
    $P2669 = $P2668."ast"()
    $P2670 = $P2666."!make"($P2669)
.annotate 'line', 1169
    .return ($P2670)
.end


.namespace ["NQP";"Actions"]
.sub "value"  :subid("139_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2672
    .param pmc param_2673
.annotate 'line', 1173
    .lex "self", param_2672
    .lex "$/", param_2673
.annotate 'line', 1174
    find_lex $P2674, "$/"
    find_lex $P2677, "$/"
    unless_null $P2677, vivify_828
    $P2677 = root_new ['parrot';'Hash']
  vivify_828:
    set $P2678, $P2677["quote"]
    unless_null $P2678, vivify_829
    new $P2678, "Undef"
  vivify_829:
    if $P2678, if_2676
    find_lex $P2682, "$/"
    unless_null $P2682, vivify_830
    $P2682 = root_new ['parrot';'Hash']
  vivify_830:
    set $P2683, $P2682["number"]
    unless_null $P2683, vivify_831
    new $P2683, "Undef"
  vivify_831:
    $P2684 = $P2683."ast"()
    set $P2675, $P2684
    goto if_2676_end
  if_2676:
    find_lex $P2679, "$/"
    unless_null $P2679, vivify_832
    $P2679 = root_new ['parrot';'Hash']
  vivify_832:
    set $P2680, $P2679["quote"]
    unless_null $P2680, vivify_833
    new $P2680, "Undef"
  vivify_833:
    $P2681 = $P2680."ast"()
    set $P2675, $P2681
  if_2676_end:
    $P2685 = $P2674."!make"($P2675)
.annotate 'line', 1173
    .return ($P2685)
.end


.namespace ["NQP";"Actions"]
.sub "number"  :subid("140_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2687
    .param pmc param_2688
.annotate 'line', 1177
    .lex "self", param_2687
    .lex "$/", param_2688
.annotate 'line', 1178
    new $P2689, "Undef"
    .lex "$value", $P2689
    find_lex $P2692, "$/"
    unless_null $P2692, vivify_834
    $P2692 = root_new ['parrot';'Hash']
  vivify_834:
    set $P2693, $P2692["dec_number"]
    unless_null $P2693, vivify_835
    new $P2693, "Undef"
  vivify_835:
    if $P2693, if_2691
    find_lex $P2697, "$/"
    unless_null $P2697, vivify_836
    $P2697 = root_new ['parrot';'Hash']
  vivify_836:
    set $P2698, $P2697["integer"]
    unless_null $P2698, vivify_837
    new $P2698, "Undef"
  vivify_837:
    $P2699 = $P2698."ast"()
    set $P2690, $P2699
    goto if_2691_end
  if_2691:
    find_lex $P2694, "$/"
    unless_null $P2694, vivify_838
    $P2694 = root_new ['parrot';'Hash']
  vivify_838:
    set $P2695, $P2694["dec_number"]
    unless_null $P2695, vivify_839
    new $P2695, "Undef"
  vivify_839:
    $P2696 = $P2695."ast"()
    set $P2690, $P2696
  if_2691_end:
    store_lex "$value", $P2690
.annotate 'line', 1179
    find_lex $P2701, "$/"
    unless_null $P2701, vivify_840
    $P2701 = root_new ['parrot';'Hash']
  vivify_840:
    set $P2702, $P2701["sign"]
    unless_null $P2702, vivify_841
    new $P2702, "Undef"
  vivify_841:
    set $S2703, $P2702
    iseq $I2704, $S2703, "-"
    unless $I2704, if_2700_end
    find_lex $P2705, "$value"
    neg $P2706, $P2705
    store_lex "$value", $P2706
  if_2700_end:
.annotate 'line', 1180
    find_lex $P2707, "$/"
    get_hll_global $P2708, ["PAST"], "Val"
    find_lex $P2709, "$value"
    $P2710 = $P2708."new"($P2709 :named("value"))
    $P2711 = $P2707."!make"($P2710)
.annotate 'line', 1177
    .return ($P2711)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("141_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2713
    .param pmc param_2714
.annotate 'line', 1183
    .lex "self", param_2713
    .lex "$/", param_2714
    find_lex $P2715, "$/"
    find_lex $P2716, "$/"
    unless_null $P2716, vivify_842
    $P2716 = root_new ['parrot';'Hash']
  vivify_842:
    set $P2717, $P2716["quote_EXPR"]
    unless_null $P2717, vivify_843
    new $P2717, "Undef"
  vivify_843:
    $P2718 = $P2717."ast"()
    $P2719 = $P2715."!make"($P2718)
    .return ($P2719)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("142_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2721
    .param pmc param_2722
.annotate 'line', 1184
    .lex "self", param_2721
    .lex "$/", param_2722
    find_lex $P2723, "$/"
    find_lex $P2724, "$/"
    unless_null $P2724, vivify_844
    $P2724 = root_new ['parrot';'Hash']
  vivify_844:
    set $P2725, $P2724["quote_EXPR"]
    unless_null $P2725, vivify_845
    new $P2725, "Undef"
  vivify_845:
    $P2726 = $P2725."ast"()
    $P2727 = $P2723."!make"($P2726)
    .return ($P2727)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("143_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2729
    .param pmc param_2730
.annotate 'line', 1185
    .lex "self", param_2729
    .lex "$/", param_2730
    find_lex $P2731, "$/"
    find_lex $P2732, "$/"
    unless_null $P2732, vivify_846
    $P2732 = root_new ['parrot';'Hash']
  vivify_846:
    set $P2733, $P2732["quote_EXPR"]
    unless_null $P2733, vivify_847
    new $P2733, "Undef"
  vivify_847:
    $P2734 = $P2733."ast"()
    $P2735 = $P2731."!make"($P2734)
    .return ($P2735)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("144_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2737
    .param pmc param_2738
.annotate 'line', 1186
    .lex "self", param_2737
    .lex "$/", param_2738
    find_lex $P2739, "$/"
    find_lex $P2740, "$/"
    unless_null $P2740, vivify_848
    $P2740 = root_new ['parrot';'Hash']
  vivify_848:
    set $P2741, $P2740["quote_EXPR"]
    unless_null $P2741, vivify_849
    new $P2741, "Undef"
  vivify_849:
    $P2742 = $P2741."ast"()
    $P2743 = $P2739."!make"($P2742)
    .return ($P2743)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("145_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2745
    .param pmc param_2746
.annotate 'line', 1187
    .lex "self", param_2745
    .lex "$/", param_2746
    find_lex $P2747, "$/"
    find_lex $P2748, "$/"
    unless_null $P2748, vivify_850
    $P2748 = root_new ['parrot';'Hash']
  vivify_850:
    set $P2749, $P2748["quote_EXPR"]
    unless_null $P2749, vivify_851
    new $P2749, "Undef"
  vivify_851:
    $P2750 = $P2749."ast"()
    $P2751 = $P2747."!make"($P2750)
    .return ($P2751)
.end


.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("146_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2753
    .param pmc param_2754
.annotate 'line', 1188
    .lex "self", param_2753
    .lex "$/", param_2754
.annotate 'line', 1189
    find_lex $P2755, "$/"
    get_hll_global $P2756, ["PAST"], "Op"
    find_lex $P2757, "$/"
    unless_null $P2757, vivify_852
    $P2757 = root_new ['parrot';'Hash']
  vivify_852:
    set $P2758, $P2757["quote_EXPR"]
    unless_null $P2758, vivify_853
    new $P2758, "Undef"
  vivify_853:
    $P2759 = $P2758."ast"()
    $P2760 = $P2759."value"()
    find_lex $P2761, "$/"
    $P2762 = $P2756."new"($P2760 :named("inline"), "inline" :named("pasttype"), $P2761 :named("node"))
    $P2763 = $P2755."!make"($P2762)
.annotate 'line', 1188
    .return ($P2763)
.end


.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("147_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2767
    .param pmc param_2768
    .param pmc param_2769 :optional
    .param int has_param_2769 :opt_flag
.annotate 'line', 1194
    new $P2766, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2766, control_2765
    push_eh $P2766
    .lex "self", param_2767
    .lex "$/", param_2768
    if has_param_2769, optparam_854
    new $P2770, "Undef"
    set param_2769, $P2770
  optparam_854:
    .lex "$key", param_2769
.annotate 'line', 1204
    new $P2771, "Undef"
    .lex "$regex", $P2771
.annotate 'line', 1206
    new $P2772, "Undef"
    .lex "$past", $P2772
.annotate 'line', 1195
    find_lex $P2774, "$key"
    set $S2775, $P2774
    iseq $I2776, $S2775, "open"
    unless $I2776, if_2773_end
.annotate 'line', 1196

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1200
    get_global $P2777, "@BLOCK"
    unless_null $P2777, vivify_855
    $P2777 = root_new ['parrot';'ResizablePMCArray']
  vivify_855:
    set $P2778, $P2777[0]
    unless_null $P2778, vivify_856
    new $P2778, "Undef"
  vivify_856:
    $P2778."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1201
    get_global $P2779, "@BLOCK"
    unless_null $P2779, vivify_857
    $P2779 = root_new ['parrot';'ResizablePMCArray']
  vivify_857:
    set $P2780, $P2779[0]
    unless_null $P2780, vivify_858
    new $P2780, "Undef"
  vivify_858:
    $P2780."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1202
    new $P2781, "Exception"
    set $P2781['type'], .CONTROL_RETURN
    new $P2782, "Integer"
    assign $P2782, 0
    setattribute $P2781, 'payload', $P2782
    throw $P2781
  if_2773_end:
.annotate 'line', 1205
    get_hll_global $P2783, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2784, "$/"
    unless_null $P2784, vivify_859
    $P2784 = root_new ['parrot';'Hash']
  vivify_859:
    set $P2785, $P2784["p6regex"]
    unless_null $P2785, vivify_860
    new $P2785, "Undef"
  vivify_860:
    $P2786 = $P2785."ast"()
    get_global $P2787, "@BLOCK"
    $P2788 = $P2787."shift"()
    $P2789 = $P2783($P2786, $P2788)
    store_lex "$regex", $P2789
.annotate 'line', 1207
    get_hll_global $P2790, ["PAST"], "Op"
.annotate 'line', 1209
    get_hll_global $P2791, ["PAST"], "Var"
    new $P2792, "ResizablePMCArray"
    push $P2792, "Regex"
    $P2793 = $P2791."new"("Regex" :named("name"), $P2792 :named("namespace"), "package" :named("scope"))
    find_lex $P2794, "$regex"
    $P2795 = $P2790."new"($P2793, $P2794, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1207
    store_lex "$past", $P2795
.annotate 'line', 1213
    find_lex $P2796, "$regex"
    find_lex $P2797, "$past"
    unless_null $P2797, vivify_861
    $P2797 = root_new ['parrot';'Hash']
    store_lex "$past", $P2797
  vivify_861:
    set $P2797["sink"], $P2796
.annotate 'line', 1214
    find_lex $P2798, "$/"
    find_lex $P2799, "$past"
    $P2800 = $P2798."!make"($P2799)
.annotate 'line', 1194
    .return ($P2800)
  control_2765:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2801, exception, "payload"
    .return ($P2801)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("148_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2803
    .param pmc param_2804
.annotate 'line', 1217
    .lex "self", param_2803
    .lex "$/", param_2804
    find_lex $P2805, "$/"
    find_lex $P2806, "$/"
    unless_null $P2806, vivify_862
    $P2806 = root_new ['parrot';'Hash']
  vivify_862:
    set $P2807, $P2806["variable"]
    unless_null $P2807, vivify_863
    new $P2807, "Undef"
  vivify_863:
    $P2808 = $P2807."ast"()
    $P2809 = $P2805."!make"($P2808)
    .return ($P2809)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("149_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2811
    .param pmc param_2812
.annotate 'line', 1218
    .lex "self", param_2811
    .lex "$/", param_2812
.annotate 'line', 1219
    find_lex $P2813, "$/"
    get_hll_global $P2814, ["PAST"], "Op"
.annotate 'line', 1220
    find_lex $P2815, "$/"
    unless_null $P2815, vivify_864
    $P2815 = root_new ['parrot';'Hash']
  vivify_864:
    set $P2816, $P2815["block"]
    unless_null $P2816, vivify_865
    new $P2816, "Undef"
  vivify_865:
    $P2817 = $P2816."ast"()
    $P2818 = "block_immediate"($P2817)
    find_lex $P2819, "$/"
    $P2820 = $P2814."new"($P2818, "set S*" :named("pirop"), $P2819 :named("node"))
.annotate 'line', 1219
    $P2821 = $P2813."!make"($P2820)
.annotate 'line', 1218
    .return ($P2821)
.end


.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("150_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2823
    .param pmc param_2824
.annotate 'line', 1223
    .lex "self", param_2823
    .lex "$/", param_2824
    find_lex $P2825, "$/"
    $P2826 = $P2825."!make"("\e")
    .return ($P2826)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("151_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2828
    .param pmc param_2829
.annotate 'line', 1227
    .lex "self", param_2828
    .lex "$/", param_2829
    find_lex $P2830, "$/"
    find_lex $P2831, "$/"
    unless_null $P2831, vivify_866
    $P2831 = root_new ['parrot';'Hash']
  vivify_866:
    set $P2832, $P2831["dotty"]
    unless_null $P2832, vivify_867
    new $P2832, "Undef"
  vivify_867:
    $P2833 = $P2832."ast"()
    $P2834 = $P2830."!make"($P2833)
    .return ($P2834)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("152_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2836
    .param pmc param_2837
.annotate 'line', 1229
    .lex "self", param_2836
    .lex "$/", param_2837
.annotate 'line', 1230
    find_lex $P2838, "$/"
    get_hll_global $P2839, ["PAST"], "Op"
.annotate 'line', 1231
    new $P2840, "ResizablePMCArray"
    push $P2840, "    clone %r, %0"
    push $P2840, "    inc %0"
    $P2841 = $P2839."new"("postfix:<++>" :named("name"), $P2840 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1230
    $P2842 = $P2838."!make"($P2841)
.annotate 'line', 1229
    .return ($P2842)
.end


.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("153_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2844
    .param pmc param_2845
.annotate 'line', 1235
    .lex "self", param_2844
    .lex "$/", param_2845
.annotate 'line', 1236
    find_lex $P2846, "$/"
    get_hll_global $P2847, ["PAST"], "Op"
.annotate 'line', 1237
    new $P2848, "ResizablePMCArray"
    push $P2848, "    clone %r, %0"
    push $P2848, "    dec %0"
    $P2849 = $P2847."new"("postfix:<-->" :named("name"), $P2848 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1236
    $P2850 = $P2846."!make"($P2849)
.annotate 'line', 1235
    .return ($P2850)
.end


.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("154_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2852
    .param pmc param_2853
.annotate 'line', 1241
    .lex "self", param_2852
    .lex "$/", param_2853
.annotate 'line', 1242
    find_lex $P2854, "$/"
    get_hll_global $P2855, ["PAST"], "Op"
.annotate 'line', 1243
    get_hll_global $P2856, ["PAST"], "Var"
    $P2857 = $P2856."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2858, "$/"
    $P2859 = $P2855."new"($P2857, "callmethod" :named("pasttype"), "!make" :named("name"), $P2858 :named("node"))
.annotate 'line', 1242
    $P2860 = $P2854."!make"($P2859)
.annotate 'line', 1241
    .return ($P2860)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("155_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2863
    .param pmc param_2864
.annotate 'line', 1259
    .lex "self", param_2863
    .lex "$/", param_2864
    find_lex $P2865, "$/"
    $P2866 = "control"($P2865, "CONTROL_LOOP_NEXT")
    .return ($P2866)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("156_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2868
    .param pmc param_2869
.annotate 'line', 1260
    .lex "self", param_2868
    .lex "$/", param_2869
    find_lex $P2870, "$/"
    $P2871 = "control"($P2870, "CONTROL_LOOP_LAST")
    .return ($P2871)
.end


.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("157_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2873
    .param pmc param_2874
.annotate 'line', 1261
    .lex "self", param_2873
    .lex "$/", param_2874
    find_lex $P2875, "$/"
    $P2876 = "control"($P2875, "CONTROL_LOOP_REDO")
    .return ($P2876)
.end


.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("158_1298839287.218") :outer("11_1298839287.218")
    .param pmc param_2878
    .param pmc param_2879
.annotate 'line', 1263
    .lex "self", param_2878
    .lex "$/", param_2879
.annotate 'line', 1264
    find_lex $P2880, "$/"
    get_hll_global $P2881, ["PAST"], "Op"
    find_lex $P2882, "$/"
    $P2883 = $P2881."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2882 :named("node"))
    $P2884 = $P2880."!make"($P2883)
.annotate 'line', 1263
    .return ($P2884)
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2885"  :subid("159_1298839287.218") :outer("11_1298839287.218")
.annotate 'line', 1268
    .const 'Sub' $P2985 = "167_1298839287.218" 
    capture_lex $P2985
    .const 'Sub' $P2960 = "166_1298839287.218" 
    capture_lex $P2960
    .const 'Sub' $P2949 = "165_1298839287.218" 
    capture_lex $P2949
    .const 'Sub' $P2934 = "164_1298839287.218" 
    capture_lex $P2934
    .const 'Sub' $P2923 = "163_1298839287.218" 
    capture_lex $P2923
    .const 'Sub' $P2912 = "162_1298839287.218" 
    capture_lex $P2912
    .const 'Sub' $P2901 = "161_1298839287.218" 
    capture_lex $P2901
    .const 'Sub' $P2888 = "160_1298839287.218" 
    capture_lex $P2888
    get_global $P2887, "$?CLASS"
.annotate 'line', 1302
    .const 'Sub' $P2960 = "166_1298839287.218" 
    newclosure $P2983, $P2960
.annotate 'line', 1268
    .return ($P2983)
.end


.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post868") :outer("159_1298839287.218")
.annotate 'line', 1268
    get_hll_global $P2886, ["NQP";"RegexActions"], "_block2885" 
    .local pmc block
    set block, $P2886
    .const 'Sub' $P2985 = "167_1298839287.218" 
    capture_lex $P2985
    $P2985()
.end


.namespace ["NQP";"RegexActions"]
.sub "_block2984"  :anon :subid("167_1298839287.218") :outer("159_1298839287.218")
.annotate 'line', 1268
    get_hll_global $P2986, "NQPClassHOW"
    $P2987 = $P2986."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P2987
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2988, type_obj
    .const 'Sub' $P2989 = "160_1298839287.218" 
    $P2988."add_method"(type_obj, "metachar:sym<:my>", $P2989)
    get_how $P2990, type_obj
    .const 'Sub' $P2991 = "161_1298839287.218" 
    $P2990."add_method"(type_obj, "metachar:sym<{ }>", $P2991)
    get_how $P2992, type_obj
    .const 'Sub' $P2993 = "162_1298839287.218" 
    $P2992."add_method"(type_obj, "metachar:sym<nqpvar>", $P2993)
    get_how $P2994, type_obj
    .const 'Sub' $P2995 = "163_1298839287.218" 
    $P2994."add_method"(type_obj, "assertion:sym<{ }>", $P2995)
    get_how $P2996, type_obj
    .const 'Sub' $P2997 = "164_1298839287.218" 
    $P2996."add_method"(type_obj, "assertion:sym<?{ }>", $P2997)
    get_how $P2998, type_obj
    .const 'Sub' $P2999 = "165_1298839287.218" 
    $P2998."add_method"(type_obj, "assertion:sym<var>", $P2999)
    get_how $P3000, type_obj
    .const 'Sub' $P3001 = "166_1298839287.218" 
    $P3000."add_method"(type_obj, "codeblock", $P3001)
    get_how $P3002, type_obj
    get_hll_global $P3003, ["Regex";"P6Regex"], "Actions"
    $P3002."add_parent"(type_obj, $P3003)
    get_how $P3004, type_obj
    $P3005 = $P3004."compose"(type_obj)
    .return ($P3005)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("160_1298839287.218") :outer("159_1298839287.218")
    .param pmc param_2889
    .param pmc param_2890
.annotate 'line', 1270
    .lex "self", param_2889
    .lex "$/", param_2890
.annotate 'line', 1271
    new $P2891, "Undef"
    .lex "$past", $P2891
    find_lex $P2892, "$/"
    unless_null $P2892, vivify_869
    $P2892 = root_new ['parrot';'Hash']
  vivify_869:
    set $P2893, $P2892["statement"]
    unless_null $P2893, vivify_870
    new $P2893, "Undef"
  vivify_870:
    $P2894 = $P2893."ast"()
    store_lex "$past", $P2894
.annotate 'line', 1272
    find_lex $P2895, "$/"
    get_hll_global $P2896, ["PAST"], "Regex"
    find_lex $P2897, "$past"
    find_lex $P2898, "$/"
    $P2899 = $P2896."new"($P2897, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2898 :named("node"))
    $P2900 = $P2895."!make"($P2899)
.annotate 'line', 1270
    .return ($P2900)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("161_1298839287.218") :outer("159_1298839287.218")
    .param pmc param_2902
    .param pmc param_2903
.annotate 'line', 1276
    .lex "self", param_2902
    .lex "$/", param_2903
.annotate 'line', 1277
    find_lex $P2904, "$/"
    get_hll_global $P2905, ["PAST"], "Regex"
    find_lex $P2906, "$/"
    unless_null $P2906, vivify_871
    $P2906 = root_new ['parrot';'Hash']
  vivify_871:
    set $P2907, $P2906["codeblock"]
    unless_null $P2907, vivify_872
    new $P2907, "Undef"
  vivify_872:
    $P2908 = $P2907."ast"()
    find_lex $P2909, "$/"
    $P2910 = $P2905."new"($P2908, "pastnode" :named("pasttype"), $P2909 :named("node"))
    $P2911 = $P2904."!make"($P2910)
.annotate 'line', 1276
    .return ($P2911)
.end


.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("162_1298839287.218") :outer("159_1298839287.218")
    .param pmc param_2913
    .param pmc param_2914
.annotate 'line', 1281
    .lex "self", param_2913
    .lex "$/", param_2914
.annotate 'line', 1282
    find_lex $P2915, "$/"
    get_hll_global $P2916, ["PAST"], "Regex"
    find_lex $P2917, "$/"
    unless_null $P2917, vivify_873
    $P2917 = root_new ['parrot';'Hash']
  vivify_873:
    set $P2918, $P2917["var"]
    unless_null $P2918, vivify_874
    new $P2918, "Undef"
  vivify_874:
    $P2919 = $P2918."ast"()
    find_lex $P2920, "$/"
    $P2921 = $P2916."new"("!INTERPOLATE", $P2919, "subrule" :named("pasttype"), "method" :named("subtype"), $P2920 :named("node"))
    $P2922 = $P2915."!make"($P2921)
.annotate 'line', 1281
    .return ($P2922)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("163_1298839287.218") :outer("159_1298839287.218")
    .param pmc param_2924
    .param pmc param_2925
.annotate 'line', 1286
    .lex "self", param_2924
    .lex "$/", param_2925
.annotate 'line', 1287
    find_lex $P2926, "$/"
    get_hll_global $P2927, ["PAST"], "Regex"
    find_lex $P2928, "$/"
    unless_null $P2928, vivify_875
    $P2928 = root_new ['parrot';'Hash']
  vivify_875:
    set $P2929, $P2928["codeblock"]
    unless_null $P2929, vivify_876
    new $P2929, "Undef"
  vivify_876:
    $P2930 = $P2929."ast"()
    find_lex $P2931, "$/"
    $P2932 = $P2927."new"("!INTERPOLATE_REGEX", $P2930, "subrule" :named("pasttype"), "method" :named("subtype"), $P2931 :named("node"))
    $P2933 = $P2926."!make"($P2932)
.annotate 'line', 1286
    .return ($P2933)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("164_1298839287.218") :outer("159_1298839287.218")
    .param pmc param_2935
    .param pmc param_2936
.annotate 'line', 1291
    .lex "self", param_2935
    .lex "$/", param_2936
.annotate 'line', 1292
    find_lex $P2937, "$/"
    get_hll_global $P2938, ["PAST"], "Regex"
    find_lex $P2939, "$/"
    unless_null $P2939, vivify_877
    $P2939 = root_new ['parrot';'Hash']
  vivify_877:
    set $P2940, $P2939["codeblock"]
    unless_null $P2940, vivify_878
    new $P2940, "Undef"
  vivify_878:
    $P2941 = $P2940."ast"()
.annotate 'line', 1293
    find_lex $P2942, "$/"
    unless_null $P2942, vivify_879
    $P2942 = root_new ['parrot';'Hash']
  vivify_879:
    set $P2943, $P2942["zw"]
    unless_null $P2943, vivify_880
    new $P2943, "Undef"
  vivify_880:
    set $S2944, $P2943
    iseq $I2945, $S2944, "!"
    find_lex $P2946, "$/"
    $P2947 = $P2938."new"($P2941, "zerowidth" :named("subtype"), $I2945 :named("negate"), "pastnode" :named("pasttype"), $P2946 :named("node"))
.annotate 'line', 1292
    $P2948 = $P2937."!make"($P2947)
.annotate 'line', 1291
    .return ($P2948)
.end


.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("165_1298839287.218") :outer("159_1298839287.218")
    .param pmc param_2950
    .param pmc param_2951
.annotate 'line', 1297
    .lex "self", param_2950
    .lex "$/", param_2951
.annotate 'line', 1298
    find_lex $P2952, "$/"
    get_hll_global $P2953, ["PAST"], "Regex"
    find_lex $P2954, "$/"
    unless_null $P2954, vivify_881
    $P2954 = root_new ['parrot';'Hash']
  vivify_881:
    set $P2955, $P2954["var"]
    unless_null $P2955, vivify_882
    new $P2955, "Undef"
  vivify_882:
    $P2956 = $P2955."ast"()
    find_lex $P2957, "$/"
    $P2958 = $P2953."new"("!INTERPOLATE_REGEX", $P2956, "subrule" :named("pasttype"), "method" :named("subtype"), $P2957 :named("node"))
    $P2959 = $P2952."!make"($P2958)
.annotate 'line', 1297
    .return ($P2959)
.end


.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("166_1298839287.218") :outer("159_1298839287.218")
    .param pmc param_2961
    .param pmc param_2962
.annotate 'line', 1302
    .lex "self", param_2961
    .lex "$/", param_2962
.annotate 'line', 1303
    new $P2963, "Undef"
    .lex "$block", $P2963
.annotate 'line', 1305
    new $P2964, "Undef"
    .lex "$past", $P2964
.annotate 'line', 1303
    find_lex $P2965, "$/"
    unless_null $P2965, vivify_883
    $P2965 = root_new ['parrot';'Hash']
  vivify_883:
    set $P2966, $P2965["block"]
    unless_null $P2966, vivify_884
    new $P2966, "Undef"
  vivify_884:
    $P2967 = $P2966."ast"()
    store_lex "$block", $P2967
.annotate 'line', 1304
    find_lex $P2968, "$block"
    $P2968."blocktype"("immediate")
.annotate 'line', 1306
    get_hll_global $P2969, ["PAST"], "Stmts"
.annotate 'line', 1307
    get_hll_global $P2970, ["PAST"], "Op"
.annotate 'line', 1308
    get_hll_global $P2971, ["PAST"], "Var"
    $P2972 = $P2971."new"("$/" :named("name"))
.annotate 'line', 1309
    get_hll_global $P2973, ["PAST"], "Op"
.annotate 'line', 1310
    get_hll_global $P2974, ["PAST"], "Var"
    $P2975 = $P2974."new"(unicode:"$\x{a2}" :named("name"))
    $P2976 = $P2973."new"($P2975, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1309
    $P2977 = $P2970."new"($P2972, $P2976, "bind" :named("pasttype"))
.annotate 'line', 1307
    find_lex $P2978, "$block"
    $P2979 = $P2969."new"($P2977, $P2978)
.annotate 'line', 1306
    store_lex "$past", $P2979
.annotate 'line', 1318
    find_lex $P2980, "$/"
    find_lex $P2981, "$past"
    $P2982 = $P2980."!make"($P2981)
.annotate 'line', 1302
    .return ($P2982)
.end


.namespace ["NQP";"Actions"]
.sub "_block3007" :load :anon :subid("168_1298839287.218")
.annotate 'line', 3
    .const 'Sub' $P3009 = "11_1298839287.218" 
    $P3010 = $P3009()
    .return ($P3010)
.end


.namespace []
.sub "_block3234" :load :anon :subid("170_1298839287.218")
.annotate 'line', 1
    .const 'Sub' $P3236 = "10_1298839287.218" 
    $P3237 = $P3236()
    .return ($P3237)
.end

### .include 'gen/nqp-compiler.pir'

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1298839296.109")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
    $P25 = $P15()
    .return ($P25)
    .const 'Sub' $P27 = "13_1298839296.109" 
    .return ($P27)
.end


.namespace ["NQP";"Compiler"]
.sub "_block14"  :subid("11_1298839296.109") :outer("10_1298839296.109")
.annotate 'line', 1
    .const 'Sub' $P18 = "12_1298839296.109" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    .return ()
.end


.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post14") :outer("11_1298839296.109")
.annotate 'line', 1
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P18 = "12_1298839296.109" 
    capture_lex $P18
    $P18()
.end


.namespace ["NQP";"Compiler"]
.sub "_block17"  :anon :subid("12_1298839296.109") :outer("11_1298839296.109")
.annotate 'line', 1
    get_hll_global $P19, "NQPClassHOW"
    $P20 = $P19."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P20
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P21, type_obj
    get_hll_global $P22, ["HLL"], "Compiler"
    $P21."add_parent"(type_obj, $P22)
    get_how $P23, type_obj
    $P24 = $P23."compose"(type_obj)
    .return ($P24)
.end


.namespace []
.sub "_block26" :load :anon :subid("13_1298839296.109")
.annotate 'line', 1
    .const 'Sub' $P28 = "10_1298839296.109" 
    $P29 = $P28()
    .return ($P29)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " - "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'skip'
    .param string desc

    print 'ok '
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    print " # SKIP "
    print desc
    print "\n"
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('NQP-rx')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
    push $P0, 'setting=s'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'NQP-rx'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
