
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1304516047.681")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    .const 'Sub' $P6163 = "589_1304516047.681" 
    capture_lex $P6163
    .const 'Sub' $P6030 = "581_1304516047.681" 
    capture_lex $P6030
    .const 'Sub' $P1976 = "406_1304516047.681" 
    capture_lex $P1976
    .const 'Sub' $P1911 = "385_1304516047.681" 
    capture_lex $P1911
    .const 'Sub' $P47 = "12_1304516047.681" 
    capture_lex $P47
    .const 'Sub' $P16 = "11_1304516047.681" 
    capture_lex $P16
.annotate 'line', 1
    .lex "@ARGS", param_13
    .lex "GLOBALish", $P14
    .lex "$?PACKAGE", $P15
.annotate 'line', 2269
    .const 'Sub' $P16 = "11_1304516047.681" 
    newclosure $P45, $P16
    .lex "MAIN", $P45
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    .const 'Sub' $P47 = "12_1304516047.681" 
    capture_lex $P47
    $P47()
.annotate 'line', 725
    .const 'Sub' $P1911 = "385_1304516047.681" 
    capture_lex $P1911
    $P1911()
.annotate 'line', 768
    .const 'Sub' $P1976 = "406_1304516047.681" 
    capture_lex $P1976
    $P1976()
.annotate 'line', 2211
    .const 'Sub' $P6030 = "581_1304516047.681" 
    capture_lex $P6030
    $P6030()
.annotate 'line', 2266
    .const 'Sub' $P6163 = "589_1304516047.681" 
    capture_lex $P6163
    $P6163()
    find_lex $P6166, "MAIN"
    find_lex $P6169, "@ARGS"
    if $P6169, if_6168
    set $P6167, $P6169
    goto if_6168_end
  if_6168:
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6170, "ModuleLoader"
    getinterp $P6171
    set $P6172, $P6171["context"]
    $P6170."set_mainline_module"($P6172)
    .const 'Sub' $P6173 = "11_1304516047.681" 
    find_lex $P6174, "@ARGS"
    $P6175 = $P6173($P6174 :flat)
    set $P6167, $P6175
  if_6168_end:
.annotate 'line', 1
    .return ($P6167)
    .const 'Sub' $P6177 = "590_1304516047.681" 
    .return ($P6177)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post591") :outer("10_1304516047.681")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1304516047.681" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P6181, "1304516035.536"
    isnull $I6182, $P6181
    if $I6182, if_6180
    .const 'Sub' $P8284 = "10_1304516047.681" 
    $P8285 = $P8284."get_lexinfo"()
    nqp_get_sc_object $P8286, "1304516035.536", 0
    $P8285."set_static_lexpad_value"("GLOBALish", $P8286)
    .const 'Sub' $P8287 = "10_1304516047.681" 
    $P8288 = $P8287."get_lexinfo"()
    $P8288."finish_static_lexpad"()
    .const 'Sub' $P8289 = "10_1304516047.681" 
    $P8290 = $P8289."get_lexinfo"()
    nqp_get_sc_object $P8291, "1304516035.536", 0
    $P8290."set_static_lexpad_value"("$?PACKAGE", $P8291)
    .const 'Sub' $P8292 = "10_1304516047.681" 
    $P8293 = $P8292."get_lexinfo"()
    $P8293."finish_static_lexpad"()
    nqp_get_sc_object $P8294, "1304516035.536", 2
    .const 'Sub' $P8295 = "13_1304516047.681" 
    assign $P8294, $P8295
    nqp_get_sc_object $P8296, "1304516035.536", 3
    .const 'Sub' $P8297 = "14_1304516047.681" 
    assign $P8296, $P8297
    nqp_get_sc_object $P8298, "1304516035.536", 4
    .const 'Sub' $P8299 = "15_1304516047.681" 
    assign $P8298, $P8299
    nqp_get_sc_object $P8300, "1304516035.536", 5
    .const 'Sub' $P8301 = "16_1304516047.681" 
    assign $P8300, $P8301
    nqp_get_sc_object $P8302, "1304516035.536", 6
    .const 'Sub' $P8303 = "17_1304516047.681" 
    assign $P8302, $P8303
    nqp_get_sc_object $P8304, "1304516035.536", 7
    .const 'Sub' $P8305 = "18_1304516047.681" 
    assign $P8304, $P8305
    nqp_get_sc_object $P8306, "1304516035.536", 8
    .const 'Sub' $P8307 = "19_1304516047.681" 
    assign $P8306, $P8307
    nqp_get_sc_object $P8308, "1304516035.536", 9
    .const 'Sub' $P8309 = "20_1304516047.681" 
    assign $P8308, $P8309
    nqp_get_sc_object $P8310, "1304516035.536", 10
    .const 'Sub' $P8311 = "21_1304516047.681" 
    assign $P8310, $P8311
    nqp_get_sc_object $P8312, "1304516035.536", 11
    .const 'Sub' $P8313 = "22_1304516047.681" 
    assign $P8312, $P8313
    nqp_get_sc_object $P8314, "1304516035.536", 12
    .const 'Sub' $P8315 = "23_1304516047.681" 
    assign $P8314, $P8315
    nqp_get_sc_object $P8316, "1304516035.536", 13
    .const 'Sub' $P8317 = "24_1304516047.681" 
    assign $P8316, $P8317
    nqp_get_sc_object $P8318, "1304516035.536", 14
    .const 'Sub' $P8319 = "26_1304516047.681" 
    assign $P8318, $P8319
    nqp_get_sc_object $P8320, "1304516035.536", 15
    .const 'Sub' $P8321 = "27_1304516047.681" 
    assign $P8320, $P8321
    nqp_get_sc_object $P8322, "1304516035.536", 16
    .const 'Sub' $P8323 = "29_1304516047.681" 
    assign $P8322, $P8323
    nqp_get_sc_object $P8324, "1304516035.536", 17
    .const 'Sub' $P8325 = "30_1304516047.681" 
    assign $P8324, $P8325
    nqp_get_sc_object $P8326, "1304516035.536", 18
    .const 'Sub' $P8327 = "31_1304516047.681" 
    assign $P8326, $P8327
    nqp_get_sc_object $P8328, "1304516035.536", 19
    .const 'Sub' $P8329 = "32_1304516047.681" 
    assign $P8328, $P8329
    nqp_get_sc_object $P8330, "1304516035.536", 20
    .const 'Sub' $P8331 = "33_1304516047.681" 
    assign $P8330, $P8331
    nqp_get_sc_object $P8332, "1304516035.536", 21
    .const 'Sub' $P8333 = "34_1304516047.681" 
    assign $P8332, $P8333
    nqp_get_sc_object $P8334, "1304516035.536", 22
    .const 'Sub' $P8335 = "36_1304516047.681" 
    assign $P8334, $P8335
    nqp_get_sc_object $P8336, "1304516035.536", 23
    .const 'Sub' $P8337 = "37_1304516047.681" 
    assign $P8336, $P8337
    nqp_get_sc_object $P8338, "1304516035.536", 24
    .const 'Sub' $P8339 = "38_1304516047.681" 
    assign $P8338, $P8339
    nqp_get_sc_object $P8340, "1304516035.536", 25
    .const 'Sub' $P8341 = "39_1304516047.681" 
    assign $P8340, $P8341
    nqp_get_sc_object $P8342, "1304516035.536", 26
    .const 'Sub' $P8343 = "40_1304516047.681" 
    assign $P8342, $P8343
    nqp_get_sc_object $P8344, "1304516035.536", 27
    .const 'Sub' $P8345 = "41_1304516047.681" 
    assign $P8344, $P8345
    nqp_get_sc_object $P8346, "1304516035.536", 28
    .const 'Sub' $P8347 = "42_1304516047.681" 
    assign $P8346, $P8347
    nqp_get_sc_object $P8348, "1304516035.536", 29
    .const 'Sub' $P8349 = "43_1304516047.681" 
    assign $P8348, $P8349
    nqp_get_sc_object $P8350, "1304516035.536", 30
    .const 'Sub' $P8351 = "44_1304516047.681" 
    assign $P8350, $P8351
    nqp_get_sc_object $P8352, "1304516035.536", 31
    .const 'Sub' $P8353 = "45_1304516047.681" 
    assign $P8352, $P8353
    nqp_get_sc_object $P8354, "1304516035.536", 32
    .const 'Sub' $P8355 = "46_1304516047.681" 
    assign $P8354, $P8355
    nqp_get_sc_object $P8356, "1304516035.536", 33
    .const 'Sub' $P8357 = "47_1304516047.681" 
    assign $P8356, $P8357
    nqp_get_sc_object $P8358, "1304516035.536", 34
    .const 'Sub' $P8359 = "48_1304516047.681" 
    assign $P8358, $P8359
    nqp_get_sc_object $P8360, "1304516035.536", 35
    .const 'Sub' $P8361 = "49_1304516047.681" 
    assign $P8360, $P8361
    nqp_get_sc_object $P8362, "1304516035.536", 36
    .const 'Sub' $P8363 = "50_1304516047.681" 
    assign $P8362, $P8363
    nqp_get_sc_object $P8364, "1304516035.536", 37
    .const 'Sub' $P8365 = "51_1304516047.681" 
    assign $P8364, $P8365
    nqp_get_sc_object $P8366, "1304516035.536", 38
    .const 'Sub' $P8367 = "52_1304516047.681" 
    assign $P8366, $P8367
    nqp_get_sc_object $P8368, "1304516035.536", 39
    .const 'Sub' $P8369 = "53_1304516047.681" 
    assign $P8368, $P8369
    nqp_get_sc_object $P8370, "1304516035.536", 40
    .const 'Sub' $P8371 = "54_1304516047.681" 
    assign $P8370, $P8371
    nqp_get_sc_object $P8372, "1304516035.536", 41
    .const 'Sub' $P8373 = "55_1304516047.681" 
    assign $P8372, $P8373
    nqp_get_sc_object $P8374, "1304516035.536", 42
    .const 'Sub' $P8375 = "56_1304516047.681" 
    assign $P8374, $P8375
    nqp_get_sc_object $P8376, "1304516035.536", 43
    .const 'Sub' $P8377 = "57_1304516047.681" 
    assign $P8376, $P8377
    nqp_get_sc_object $P8378, "1304516035.536", 44
    .const 'Sub' $P8379 = "58_1304516047.681" 
    assign $P8378, $P8379
    nqp_get_sc_object $P8380, "1304516035.536", 45
    .const 'Sub' $P8381 = "59_1304516047.681" 
    assign $P8380, $P8381
    nqp_get_sc_object $P8382, "1304516035.536", 46
    .const 'Sub' $P8383 = "60_1304516047.681" 
    assign $P8382, $P8383
    nqp_get_sc_object $P8384, "1304516035.536", 47
    .const 'Sub' $P8385 = "61_1304516047.681" 
    assign $P8384, $P8385
    nqp_get_sc_object $P8386, "1304516035.536", 48
    .const 'Sub' $P8387 = "62_1304516047.681" 
    assign $P8386, $P8387
    nqp_get_sc_object $P8388, "1304516035.536", 49
    .const 'Sub' $P8389 = "63_1304516047.681" 
    assign $P8388, $P8389
    nqp_get_sc_object $P8390, "1304516035.536", 50
    .const 'Sub' $P8391 = "64_1304516047.681" 
    assign $P8390, $P8391
    nqp_get_sc_object $P8392, "1304516035.536", 51
    .const 'Sub' $P8393 = "65_1304516047.681" 
    assign $P8392, $P8393
    nqp_get_sc_object $P8394, "1304516035.536", 52
    .const 'Sub' $P8395 = "66_1304516047.681" 
    assign $P8394, $P8395
    nqp_get_sc_object $P8396, "1304516035.536", 53
    .const 'Sub' $P8397 = "67_1304516047.681" 
    assign $P8396, $P8397
    nqp_get_sc_object $P8398, "1304516035.536", 54
    .const 'Sub' $P8399 = "68_1304516047.681" 
    assign $P8398, $P8399
    nqp_get_sc_object $P8400, "1304516035.536", 55
    .const 'Sub' $P8401 = "69_1304516047.681" 
    assign $P8400, $P8401
    nqp_get_sc_object $P8402, "1304516035.536", 56
    .const 'Sub' $P8403 = "70_1304516047.681" 
    assign $P8402, $P8403
    nqp_get_sc_object $P8404, "1304516035.536", 57
    .const 'Sub' $P8405 = "71_1304516047.681" 
    assign $P8404, $P8405
    nqp_get_sc_object $P8406, "1304516035.536", 58
    .const 'Sub' $P8407 = "73_1304516047.681" 
    assign $P8406, $P8407
    nqp_get_sc_object $P8408, "1304516035.536", 59
    .const 'Sub' $P8409 = "74_1304516047.681" 
    assign $P8408, $P8409
    nqp_get_sc_object $P8410, "1304516035.536", 60
    .const 'Sub' $P8411 = "75_1304516047.681" 
    assign $P8410, $P8411
    nqp_get_sc_object $P8412, "1304516035.536", 61
    .const 'Sub' $P8413 = "76_1304516047.681" 
    assign $P8412, $P8413
    nqp_get_sc_object $P8414, "1304516035.536", 62
    .const 'Sub' $P8415 = "77_1304516047.681" 
    assign $P8414, $P8415
    nqp_get_sc_object $P8416, "1304516035.536", 63
    .const 'Sub' $P8417 = "78_1304516047.681" 
    assign $P8416, $P8417
    nqp_get_sc_object $P8418, "1304516035.536", 64
    .const 'Sub' $P8419 = "79_1304516047.681" 
    assign $P8418, $P8419
    nqp_get_sc_object $P8420, "1304516035.536", 65
    .const 'Sub' $P8421 = "80_1304516047.681" 
    assign $P8420, $P8421
    nqp_get_sc_object $P8422, "1304516035.536", 66
    .const 'Sub' $P8423 = "81_1304516047.681" 
    assign $P8422, $P8423
    nqp_get_sc_object $P8424, "1304516035.536", 67
    .const 'Sub' $P8425 = "82_1304516047.681" 
    assign $P8424, $P8425
    nqp_get_sc_object $P8426, "1304516035.536", 68
    .const 'Sub' $P8427 = "83_1304516047.681" 
    assign $P8426, $P8427
    nqp_get_sc_object $P8428, "1304516035.536", 69
    .const 'Sub' $P8429 = "84_1304516047.681" 
    assign $P8428, $P8429
    nqp_get_sc_object $P8430, "1304516035.536", 70
    .const 'Sub' $P8431 = "85_1304516047.681" 
    assign $P8430, $P8431
    nqp_get_sc_object $P8432, "1304516035.536", 71
    .const 'Sub' $P8433 = "86_1304516047.681" 
    assign $P8432, $P8433
    nqp_get_sc_object $P8434, "1304516035.536", 72
    .const 'Sub' $P8435 = "87_1304516047.681" 
    assign $P8434, $P8435
    nqp_get_sc_object $P8436, "1304516035.536", 73
    .const 'Sub' $P8437 = "88_1304516047.681" 
    assign $P8436, $P8437
    nqp_get_sc_object $P8438, "1304516035.536", 74
    .const 'Sub' $P8439 = "89_1304516047.681" 
    assign $P8438, $P8439
    nqp_get_sc_object $P8440, "1304516035.536", 75
    .const 'Sub' $P8441 = "90_1304516047.681" 
    assign $P8440, $P8441
    nqp_get_sc_object $P8442, "1304516035.536", 76
    .const 'Sub' $P8443 = "91_1304516047.681" 
    assign $P8442, $P8443
    nqp_get_sc_object $P8444, "1304516035.536", 77
    .const 'Sub' $P8445 = "92_1304516047.681" 
    assign $P8444, $P8445
    nqp_get_sc_object $P8446, "1304516035.536", 78
    .const 'Sub' $P8447 = "93_1304516047.681" 
    assign $P8446, $P8447
    nqp_get_sc_object $P8448, "1304516035.536", 79
    .const 'Sub' $P8449 = "94_1304516047.681" 
    assign $P8448, $P8449
    nqp_get_sc_object $P8450, "1304516035.536", 80
    .const 'Sub' $P8451 = "95_1304516047.681" 
    assign $P8450, $P8451
    nqp_get_sc_object $P8452, "1304516035.536", 81
    .const 'Sub' $P8453 = "96_1304516047.681" 
    assign $P8452, $P8453
    nqp_get_sc_object $P8454, "1304516035.536", 82
    .const 'Sub' $P8455 = "97_1304516047.681" 
    assign $P8454, $P8455
    nqp_get_sc_object $P8456, "1304516035.536", 83
    .const 'Sub' $P8457 = "98_1304516047.681" 
    assign $P8456, $P8457
    nqp_get_sc_object $P8458, "1304516035.536", 84
    .const 'Sub' $P8459 = "99_1304516047.681" 
    assign $P8458, $P8459
    nqp_get_sc_object $P8460, "1304516035.536", 85
    .const 'Sub' $P8461 = "100_1304516047.681" 
    assign $P8460, $P8461
    nqp_get_sc_object $P8462, "1304516035.536", 86
    .const 'Sub' $P8463 = "101_1304516047.681" 
    assign $P8462, $P8463
    nqp_get_sc_object $P8464, "1304516035.536", 87
    .const 'Sub' $P8465 = "102_1304516047.681" 
    assign $P8464, $P8465
    nqp_get_sc_object $P8466, "1304516035.536", 88
    .const 'Sub' $P8467 = "103_1304516047.681" 
    assign $P8466, $P8467
    nqp_get_sc_object $P8468, "1304516035.536", 89
    .const 'Sub' $P8469 = "104_1304516047.681" 
    assign $P8468, $P8469
    nqp_get_sc_object $P8470, "1304516035.536", 90
    .const 'Sub' $P8471 = "105_1304516047.681" 
    assign $P8470, $P8471
    nqp_get_sc_object $P8472, "1304516035.536", 91
    .const 'Sub' $P8473 = "106_1304516047.681" 
    assign $P8472, $P8473
    nqp_get_sc_object $P8474, "1304516035.536", 92
    .const 'Sub' $P8475 = "107_1304516047.681" 
    assign $P8474, $P8475
    nqp_get_sc_object $P8476, "1304516035.536", 93
    .const 'Sub' $P8477 = "108_1304516047.681" 
    assign $P8476, $P8477
    nqp_get_sc_object $P8478, "1304516035.536", 94
    .const 'Sub' $P8479 = "109_1304516047.681" 
    assign $P8478, $P8479
    nqp_get_sc_object $P8480, "1304516035.536", 95
    .const 'Sub' $P8481 = "110_1304516047.681" 
    assign $P8480, $P8481
    nqp_get_sc_object $P8482, "1304516035.536", 96
    .const 'Sub' $P8483 = "111_1304516047.681" 
    assign $P8482, $P8483
    nqp_get_sc_object $P8484, "1304516035.536", 97
    .const 'Sub' $P8485 = "112_1304516047.681" 
    assign $P8484, $P8485
    nqp_get_sc_object $P8486, "1304516035.536", 98
    .const 'Sub' $P8487 = "113_1304516047.681" 
    assign $P8486, $P8487
    nqp_get_sc_object $P8488, "1304516035.536", 99
    .const 'Sub' $P8489 = "114_1304516047.681" 
    assign $P8488, $P8489
    nqp_get_sc_object $P8490, "1304516035.536", 100
    .const 'Sub' $P8491 = "115_1304516047.681" 
    assign $P8490, $P8491
    nqp_get_sc_object $P8492, "1304516035.536", 101
    .const 'Sub' $P8493 = "116_1304516047.681" 
    assign $P8492, $P8493
    nqp_get_sc_object $P8494, "1304516035.536", 102
    .const 'Sub' $P8495 = "117_1304516047.681" 
    assign $P8494, $P8495
    nqp_get_sc_object $P8496, "1304516035.536", 103
    .const 'Sub' $P8497 = "118_1304516047.681" 
    assign $P8496, $P8497
    nqp_get_sc_object $P8498, "1304516035.536", 104
    .const 'Sub' $P8499 = "121_1304516047.681" 
    assign $P8498, $P8499
    nqp_get_sc_object $P8500, "1304516035.536", 105
    .const 'Sub' $P8501 = "122_1304516047.681" 
    assign $P8500, $P8501
    nqp_get_sc_object $P8502, "1304516035.536", 106
    .const 'Sub' $P8503 = "123_1304516047.681" 
    assign $P8502, $P8503
    nqp_get_sc_object $P8504, "1304516035.536", 107
    .const 'Sub' $P8505 = "124_1304516047.681" 
    assign $P8504, $P8505
    nqp_get_sc_object $P8506, "1304516035.536", 108
    .const 'Sub' $P8507 = "125_1304516047.681" 
    assign $P8506, $P8507
    nqp_get_sc_object $P8508, "1304516035.536", 109
    .const 'Sub' $P8509 = "126_1304516047.681" 
    assign $P8508, $P8509
    nqp_get_sc_object $P8510, "1304516035.536", 110
    .const 'Sub' $P8511 = "127_1304516047.681" 
    assign $P8510, $P8511
    nqp_get_sc_object $P8512, "1304516035.536", 111
    .const 'Sub' $P8513 = "128_1304516047.681" 
    assign $P8512, $P8513
    nqp_get_sc_object $P8514, "1304516035.536", 112
    .const 'Sub' $P8515 = "129_1304516047.681" 
    assign $P8514, $P8515
    nqp_get_sc_object $P8516, "1304516035.536", 113
    .const 'Sub' $P8517 = "130_1304516047.681" 
    assign $P8516, $P8517
    nqp_get_sc_object $P8518, "1304516035.536", 114
    .const 'Sub' $P8519 = "131_1304516047.681" 
    assign $P8518, $P8519
    nqp_get_sc_object $P8520, "1304516035.536", 115
    .const 'Sub' $P8521 = "132_1304516047.681" 
    assign $P8520, $P8521
    nqp_get_sc_object $P8522, "1304516035.536", 116
    .const 'Sub' $P8523 = "133_1304516047.681" 
    assign $P8522, $P8523
    nqp_get_sc_object $P8524, "1304516035.536", 117
    .const 'Sub' $P8525 = "134_1304516047.681" 
    assign $P8524, $P8525
    nqp_get_sc_object $P8526, "1304516035.536", 118
    .const 'Sub' $P8527 = "135_1304516047.681" 
    assign $P8526, $P8527
    nqp_get_sc_object $P8528, "1304516035.536", 119
    .const 'Sub' $P8529 = "136_1304516047.681" 
    assign $P8528, $P8529
    nqp_get_sc_object $P8530, "1304516035.536", 120
    .const 'Sub' $P8531 = "137_1304516047.681" 
    assign $P8530, $P8531
    nqp_get_sc_object $P8532, "1304516035.536", 121
    .const 'Sub' $P8533 = "138_1304516047.681" 
    assign $P8532, $P8533
    nqp_get_sc_object $P8534, "1304516035.536", 122
    .const 'Sub' $P8535 = "139_1304516047.681" 
    assign $P8534, $P8535
    nqp_get_sc_object $P8536, "1304516035.536", 123
    .const 'Sub' $P8537 = "140_1304516047.681" 
    assign $P8536, $P8537
    nqp_get_sc_object $P8538, "1304516035.536", 124
    .const 'Sub' $P8539 = "141_1304516047.681" 
    assign $P8538, $P8539
    nqp_get_sc_object $P8540, "1304516035.536", 125
    .const 'Sub' $P8541 = "142_1304516047.681" 
    assign $P8540, $P8541
    nqp_get_sc_object $P8542, "1304516035.536", 126
    .const 'Sub' $P8543 = "143_1304516047.681" 
    assign $P8542, $P8543
    nqp_get_sc_object $P8544, "1304516035.536", 127
    .const 'Sub' $P8545 = "144_1304516047.681" 
    assign $P8544, $P8545
    nqp_get_sc_object $P8546, "1304516035.536", 128
    .const 'Sub' $P8547 = "145_1304516047.681" 
    assign $P8546, $P8547
    nqp_get_sc_object $P8548, "1304516035.536", 129
    .const 'Sub' $P8549 = "146_1304516047.681" 
    assign $P8548, $P8549
    nqp_get_sc_object $P8550, "1304516035.536", 130
    .const 'Sub' $P8551 = "147_1304516047.681" 
    assign $P8550, $P8551
    nqp_get_sc_object $P8552, "1304516035.536", 131
    .const 'Sub' $P8553 = "148_1304516047.681" 
    assign $P8552, $P8553
    nqp_get_sc_object $P8554, "1304516035.536", 132
    .const 'Sub' $P8555 = "149_1304516047.681" 
    assign $P8554, $P8555
    nqp_get_sc_object $P8556, "1304516035.536", 133
    .const 'Sub' $P8557 = "150_1304516047.681" 
    assign $P8556, $P8557
    nqp_get_sc_object $P8558, "1304516035.536", 134
    .const 'Sub' $P8559 = "151_1304516047.681" 
    assign $P8558, $P8559
    nqp_get_sc_object $P8560, "1304516035.536", 135
    .const 'Sub' $P8561 = "152_1304516047.681" 
    assign $P8560, $P8561
    nqp_get_sc_object $P8562, "1304516035.536", 136
    .const 'Sub' $P8563 = "154_1304516047.681" 
    assign $P8562, $P8563
    nqp_get_sc_object $P8564, "1304516035.536", 137
    .const 'Sub' $P8565 = "155_1304516047.681" 
    assign $P8564, $P8565
    nqp_get_sc_object $P8566, "1304516035.536", 138
    .const 'Sub' $P8567 = "156_1304516047.681" 
    assign $P8566, $P8567
    nqp_get_sc_object $P8568, "1304516035.536", 139
    .const 'Sub' $P8569 = "157_1304516047.681" 
    assign $P8568, $P8569
    nqp_get_sc_object $P8570, "1304516035.536", 140
    .const 'Sub' $P8571 = "158_1304516047.681" 
    assign $P8570, $P8571
    nqp_get_sc_object $P8572, "1304516035.536", 141
    .const 'Sub' $P8573 = "159_1304516047.681" 
    assign $P8572, $P8573
    nqp_get_sc_object $P8574, "1304516035.536", 142
    .const 'Sub' $P8575 = "160_1304516047.681" 
    assign $P8574, $P8575
    nqp_get_sc_object $P8576, "1304516035.536", 143
    .const 'Sub' $P8577 = "161_1304516047.681" 
    assign $P8576, $P8577
    nqp_get_sc_object $P8578, "1304516035.536", 144
    .const 'Sub' $P8579 = "162_1304516047.681" 
    assign $P8578, $P8579
    nqp_get_sc_object $P8580, "1304516035.536", 145
    .const 'Sub' $P8581 = "163_1304516047.681" 
    assign $P8580, $P8581
    nqp_get_sc_object $P8582, "1304516035.536", 146
    .const 'Sub' $P8583 = "164_1304516047.681" 
    assign $P8582, $P8583
    nqp_get_sc_object $P8584, "1304516035.536", 147
    .const 'Sub' $P8585 = "165_1304516047.681" 
    assign $P8584, $P8585
    nqp_get_sc_object $P8586, "1304516035.536", 148
    .const 'Sub' $P8587 = "167_1304516047.681" 
    assign $P8586, $P8587
    nqp_get_sc_object $P8588, "1304516035.536", 149
    .const 'Sub' $P8589 = "168_1304516047.681" 
    assign $P8588, $P8589
    nqp_get_sc_object $P8590, "1304516035.536", 150
    .const 'Sub' $P8591 = "169_1304516047.681" 
    assign $P8590, $P8591
    nqp_get_sc_object $P8592, "1304516035.536", 151
    .const 'Sub' $P8593 = "170_1304516047.681" 
    assign $P8592, $P8593
    nqp_get_sc_object $P8594, "1304516035.536", 152
    .const 'Sub' $P8595 = "172_1304516047.681" 
    assign $P8594, $P8595
    nqp_get_sc_object $P8596, "1304516035.536", 153
    .const 'Sub' $P8597 = "173_1304516047.681" 
    assign $P8596, $P8597
    nqp_get_sc_object $P8598, "1304516035.536", 154
    .const 'Sub' $P8599 = "174_1304516047.681" 
    assign $P8598, $P8599
    nqp_get_sc_object $P8600, "1304516035.536", 155
    .const 'Sub' $P8601 = "175_1304516047.681" 
    assign $P8600, $P8601
    nqp_get_sc_object $P8602, "1304516035.536", 156
    .const 'Sub' $P8603 = "176_1304516047.681" 
    assign $P8602, $P8603
    nqp_get_sc_object $P8604, "1304516035.536", 157
    .const 'Sub' $P8605 = "177_1304516047.681" 
    assign $P8604, $P8605
    nqp_get_sc_object $P8606, "1304516035.536", 158
    .const 'Sub' $P8607 = "178_1304516047.681" 
    assign $P8606, $P8607
    nqp_get_sc_object $P8608, "1304516035.536", 159
    .const 'Sub' $P8609 = "179_1304516047.681" 
    assign $P8608, $P8609
    nqp_get_sc_object $P8610, "1304516035.536", 160
    .const 'Sub' $P8611 = "180_1304516047.681" 
    assign $P8610, $P8611
    nqp_get_sc_object $P8612, "1304516035.536", 161
    .const 'Sub' $P8613 = "181_1304516047.681" 
    assign $P8612, $P8613
    nqp_get_sc_object $P8614, "1304516035.536", 162
    .const 'Sub' $P8615 = "183_1304516047.681" 
    assign $P8614, $P8615
    nqp_get_sc_object $P8616, "1304516035.536", 163
    .const 'Sub' $P8617 = "184_1304516047.681" 
    assign $P8616, $P8617
    nqp_get_sc_object $P8618, "1304516035.536", 164
    .const 'Sub' $P8619 = "186_1304516047.681" 
    assign $P8618, $P8619
    nqp_get_sc_object $P8620, "1304516035.536", 165
    .const 'Sub' $P8621 = "187_1304516047.681" 
    assign $P8620, $P8621
    nqp_get_sc_object $P8622, "1304516035.536", 166
    .const 'Sub' $P8623 = "188_1304516047.681" 
    assign $P8622, $P8623
    nqp_get_sc_object $P8624, "1304516035.536", 167
    .const 'Sub' $P8625 = "189_1304516047.681" 
    assign $P8624, $P8625
    nqp_get_sc_object $P8626, "1304516035.536", 168
    .const 'Sub' $P8627 = "190_1304516047.681" 
    assign $P8626, $P8627
    nqp_get_sc_object $P8628, "1304516035.536", 169
    .const 'Sub' $P8629 = "191_1304516047.681" 
    assign $P8628, $P8629
    nqp_get_sc_object $P8630, "1304516035.536", 170
    .const 'Sub' $P8631 = "192_1304516047.681" 
    assign $P8630, $P8631
    nqp_get_sc_object $P8632, "1304516035.536", 171
    .const 'Sub' $P8633 = "193_1304516047.681" 
    assign $P8632, $P8633
    nqp_get_sc_object $P8634, "1304516035.536", 172
    .const 'Sub' $P8635 = "194_1304516047.681" 
    assign $P8634, $P8635
    nqp_get_sc_object $P8636, "1304516035.536", 173
    .const 'Sub' $P8637 = "195_1304516047.681" 
    assign $P8636, $P8637
    nqp_get_sc_object $P8638, "1304516035.536", 174
    .const 'Sub' $P8639 = "197_1304516047.681" 
    assign $P8638, $P8639
    nqp_get_sc_object $P8640, "1304516035.536", 175
    .const 'Sub' $P8641 = "198_1304516047.681" 
    assign $P8640, $P8641
    nqp_get_sc_object $P8642, "1304516035.536", 176
    .const 'Sub' $P8643 = "199_1304516047.681" 
    assign $P8642, $P8643
    nqp_get_sc_object $P8644, "1304516035.536", 177
    .const 'Sub' $P8645 = "200_1304516047.681" 
    assign $P8644, $P8645
    nqp_get_sc_object $P8646, "1304516035.536", 178
    .const 'Sub' $P8647 = "201_1304516047.681" 
    assign $P8646, $P8647
    nqp_get_sc_object $P8648, "1304516035.536", 179
    .const 'Sub' $P8649 = "202_1304516047.681" 
    assign $P8648, $P8649
    nqp_get_sc_object $P8650, "1304516035.536", 180
    .const 'Sub' $P8651 = "203_1304516047.681" 
    assign $P8650, $P8651
    nqp_get_sc_object $P8652, "1304516035.536", 181
    .const 'Sub' $P8653 = "204_1304516047.681" 
    assign $P8652, $P8653
    nqp_get_sc_object $P8654, "1304516035.536", 182
    .const 'Sub' $P8655 = "205_1304516047.681" 
    assign $P8654, $P8655
    nqp_get_sc_object $P8656, "1304516035.536", 183
    .const 'Sub' $P8657 = "206_1304516047.681" 
    assign $P8656, $P8657
    nqp_get_sc_object $P8658, "1304516035.536", 184
    .const 'Sub' $P8659 = "207_1304516047.681" 
    assign $P8658, $P8659
    nqp_get_sc_object $P8660, "1304516035.536", 185
    .const 'Sub' $P8661 = "208_1304516047.681" 
    assign $P8660, $P8661
    nqp_get_sc_object $P8662, "1304516035.536", 186
    .const 'Sub' $P8663 = "209_1304516047.681" 
    assign $P8662, $P8663
    nqp_get_sc_object $P8664, "1304516035.536", 187
    .const 'Sub' $P8665 = "210_1304516047.681" 
    assign $P8664, $P8665
    nqp_get_sc_object $P8666, "1304516035.536", 188
    .const 'Sub' $P8667 = "211_1304516047.681" 
    assign $P8666, $P8667
    nqp_get_sc_object $P8668, "1304516035.536", 189
    .const 'Sub' $P8669 = "212_1304516047.681" 
    assign $P8668, $P8669
    nqp_get_sc_object $P8670, "1304516035.536", 190
    .const 'Sub' $P8671 = "213_1304516047.681" 
    assign $P8670, $P8671
    nqp_get_sc_object $P8672, "1304516035.536", 191
    .const 'Sub' $P8673 = "214_1304516047.681" 
    assign $P8672, $P8673
    nqp_get_sc_object $P8674, "1304516035.536", 192
    .const 'Sub' $P8675 = "215_1304516047.681" 
    assign $P8674, $P8675
    nqp_get_sc_object $P8676, "1304516035.536", 193
    .const 'Sub' $P8677 = "216_1304516047.681" 
    assign $P8676, $P8677
    nqp_get_sc_object $P8678, "1304516035.536", 194
    .const 'Sub' $P8679 = "217_1304516047.681" 
    assign $P8678, $P8679
    nqp_get_sc_object $P8680, "1304516035.536", 195
    .const 'Sub' $P8681 = "218_1304516047.681" 
    assign $P8680, $P8681
    nqp_get_sc_object $P8682, "1304516035.536", 196
    .const 'Sub' $P8683 = "219_1304516047.681" 
    assign $P8682, $P8683
    nqp_get_sc_object $P8684, "1304516035.536", 197
    .const 'Sub' $P8685 = "220_1304516047.681" 
    assign $P8684, $P8685
    nqp_get_sc_object $P8686, "1304516035.536", 198
    .const 'Sub' $P8687 = "221_1304516047.681" 
    assign $P8686, $P8687
    nqp_get_sc_object $P8688, "1304516035.536", 199
    .const 'Sub' $P8689 = "222_1304516047.681" 
    assign $P8688, $P8689
    nqp_get_sc_object $P8690, "1304516035.536", 200
    .const 'Sub' $P8691 = "223_1304516047.681" 
    assign $P8690, $P8691
    nqp_get_sc_object $P8692, "1304516035.536", 201
    .const 'Sub' $P8693 = "224_1304516047.681" 
    assign $P8692, $P8693
    nqp_get_sc_object $P8694, "1304516035.536", 202
    .const 'Sub' $P8695 = "225_1304516047.681" 
    assign $P8694, $P8695
    nqp_get_sc_object $P8696, "1304516035.536", 203
    .const 'Sub' $P8697 = "226_1304516047.681" 
    assign $P8696, $P8697
    nqp_get_sc_object $P8698, "1304516035.536", 204
    .const 'Sub' $P8699 = "228_1304516047.681" 
    assign $P8698, $P8699
    nqp_get_sc_object $P8700, "1304516035.536", 205
    .const 'Sub' $P8701 = "229_1304516047.681" 
    assign $P8700, $P8701
    nqp_get_sc_object $P8702, "1304516035.536", 206
    .const 'Sub' $P8703 = "230_1304516047.681" 
    assign $P8702, $P8703
    nqp_get_sc_object $P8704, "1304516035.536", 207
    .const 'Sub' $P8705 = "231_1304516047.681" 
    assign $P8704, $P8705
    nqp_get_sc_object $P8706, "1304516035.536", 208
    .const 'Sub' $P8707 = "232_1304516047.681" 
    assign $P8706, $P8707
    nqp_get_sc_object $P8708, "1304516035.536", 209
    .const 'Sub' $P8709 = "233_1304516047.681" 
    assign $P8708, $P8709
    nqp_get_sc_object $P8710, "1304516035.536", 210
    .const 'Sub' $P8711 = "234_1304516047.681" 
    assign $P8710, $P8711
    nqp_get_sc_object $P8712, "1304516035.536", 211
    .const 'Sub' $P8713 = "235_1304516047.681" 
    assign $P8712, $P8713
    nqp_get_sc_object $P8714, "1304516035.536", 212
    .const 'Sub' $P8715 = "236_1304516047.681" 
    assign $P8714, $P8715
    nqp_get_sc_object $P8716, "1304516035.536", 213
    .const 'Sub' $P8717 = "237_1304516047.681" 
    assign $P8716, $P8717
    nqp_get_sc_object $P8718, "1304516035.536", 214
    .const 'Sub' $P8719 = "238_1304516047.681" 
    assign $P8718, $P8719
    nqp_get_sc_object $P8720, "1304516035.536", 215
    .const 'Sub' $P8721 = "239_1304516047.681" 
    assign $P8720, $P8721
    nqp_get_sc_object $P8722, "1304516035.536", 216
    .const 'Sub' $P8723 = "240_1304516047.681" 
    assign $P8722, $P8723
    nqp_get_sc_object $P8724, "1304516035.536", 217
    .const 'Sub' $P8725 = "241_1304516047.681" 
    assign $P8724, $P8725
    nqp_get_sc_object $P8726, "1304516035.536", 218
    .const 'Sub' $P8727 = "242_1304516047.681" 
    assign $P8726, $P8727
    nqp_get_sc_object $P8728, "1304516035.536", 219
    .const 'Sub' $P8729 = "243_1304516047.681" 
    assign $P8728, $P8729
    nqp_get_sc_object $P8730, "1304516035.536", 220
    .const 'Sub' $P8731 = "244_1304516047.681" 
    assign $P8730, $P8731
    nqp_get_sc_object $P8732, "1304516035.536", 221
    .const 'Sub' $P8733 = "245_1304516047.681" 
    assign $P8732, $P8733
    nqp_get_sc_object $P8734, "1304516035.536", 222
    .const 'Sub' $P8735 = "246_1304516047.681" 
    assign $P8734, $P8735
    nqp_get_sc_object $P8736, "1304516035.536", 223
    .const 'Sub' $P8737 = "247_1304516047.681" 
    assign $P8736, $P8737
    nqp_get_sc_object $P8738, "1304516035.536", 224
    .const 'Sub' $P8739 = "248_1304516047.681" 
    assign $P8738, $P8739
    nqp_get_sc_object $P8740, "1304516035.536", 225
    .const 'Sub' $P8741 = "249_1304516047.681" 
    assign $P8740, $P8741
    nqp_get_sc_object $P8742, "1304516035.536", 226
    .const 'Sub' $P8743 = "250_1304516047.681" 
    assign $P8742, $P8743
    nqp_get_sc_object $P8744, "1304516035.536", 227
    .const 'Sub' $P8745 = "251_1304516047.681" 
    assign $P8744, $P8745
    nqp_get_sc_object $P8746, "1304516035.536", 228
    .const 'Sub' $P8747 = "252_1304516047.681" 
    assign $P8746, $P8747
    nqp_get_sc_object $P8748, "1304516035.536", 229
    .const 'Sub' $P8749 = "253_1304516047.681" 
    assign $P8748, $P8749
    nqp_get_sc_object $P8750, "1304516035.536", 230
    .const 'Sub' $P8751 = "254_1304516047.681" 
    assign $P8750, $P8751
    nqp_get_sc_object $P8752, "1304516035.536", 231
    .const 'Sub' $P8753 = "255_1304516047.681" 
    assign $P8752, $P8753
    nqp_get_sc_object $P8754, "1304516035.536", 232
    .const 'Sub' $P8755 = "256_1304516047.681" 
    assign $P8754, $P8755
    nqp_get_sc_object $P8756, "1304516035.536", 233
    .const 'Sub' $P8757 = "257_1304516047.681" 
    assign $P8756, $P8757
    nqp_get_sc_object $P8758, "1304516035.536", 234
    .const 'Sub' $P8759 = "258_1304516047.681" 
    assign $P8758, $P8759
    nqp_get_sc_object $P8760, "1304516035.536", 235
    .const 'Sub' $P8761 = "259_1304516047.681" 
    assign $P8760, $P8761
    nqp_get_sc_object $P8762, "1304516035.536", 236
    .const 'Sub' $P8763 = "260_1304516047.681" 
    assign $P8762, $P8763
    nqp_get_sc_object $P8764, "1304516035.536", 237
    .const 'Sub' $P8765 = "261_1304516047.681" 
    assign $P8764, $P8765
    nqp_get_sc_object $P8766, "1304516035.536", 238
    .const 'Sub' $P8767 = "262_1304516047.681" 
    assign $P8766, $P8767
    nqp_get_sc_object $P8768, "1304516035.536", 239
    .const 'Sub' $P8769 = "263_1304516047.681" 
    assign $P8768, $P8769
    nqp_get_sc_object $P8770, "1304516035.536", 240
    .const 'Sub' $P8771 = "264_1304516047.681" 
    assign $P8770, $P8771
    nqp_get_sc_object $P8772, "1304516035.536", 241
    .const 'Sub' $P8773 = "265_1304516047.681" 
    assign $P8772, $P8773
    nqp_get_sc_object $P8774, "1304516035.536", 242
    .const 'Sub' $P8775 = "266_1304516047.681" 
    assign $P8774, $P8775
    nqp_get_sc_object $P8776, "1304516035.536", 243
    .const 'Sub' $P8777 = "267_1304516047.681" 
    assign $P8776, $P8777
    nqp_get_sc_object $P8778, "1304516035.536", 244
    .const 'Sub' $P8779 = "268_1304516047.681" 
    assign $P8778, $P8779
    nqp_get_sc_object $P8780, "1304516035.536", 245
    .const 'Sub' $P8781 = "269_1304516047.681" 
    assign $P8780, $P8781
    nqp_get_sc_object $P8782, "1304516035.536", 246
    .const 'Sub' $P8783 = "270_1304516047.681" 
    assign $P8782, $P8783
    nqp_get_sc_object $P8784, "1304516035.536", 247
    .const 'Sub' $P8785 = "271_1304516047.681" 
    assign $P8784, $P8785
    nqp_get_sc_object $P8786, "1304516035.536", 248
    .const 'Sub' $P8787 = "272_1304516047.681" 
    assign $P8786, $P8787
    nqp_get_sc_object $P8788, "1304516035.536", 249
    .const 'Sub' $P8789 = "273_1304516047.681" 
    assign $P8788, $P8789
    nqp_get_sc_object $P8790, "1304516035.536", 250
    .const 'Sub' $P8791 = "274_1304516047.681" 
    assign $P8790, $P8791
    nqp_get_sc_object $P8792, "1304516035.536", 251
    .const 'Sub' $P8793 = "275_1304516047.681" 
    assign $P8792, $P8793
    nqp_get_sc_object $P8794, "1304516035.536", 252
    .const 'Sub' $P8795 = "276_1304516047.681" 
    assign $P8794, $P8795
    nqp_get_sc_object $P8796, "1304516035.536", 253
    .const 'Sub' $P8797 = "277_1304516047.681" 
    assign $P8796, $P8797
    nqp_get_sc_object $P8798, "1304516035.536", 254
    .const 'Sub' $P8799 = "278_1304516047.681" 
    assign $P8798, $P8799
    nqp_get_sc_object $P8800, "1304516035.536", 255
    .const 'Sub' $P8801 = "279_1304516047.681" 
    assign $P8800, $P8801
    nqp_get_sc_object $P8802, "1304516035.536", 256
    .const 'Sub' $P8803 = "280_1304516047.681" 
    assign $P8802, $P8803
    nqp_get_sc_object $P8804, "1304516035.536", 257
    .const 'Sub' $P8805 = "281_1304516047.681" 
    assign $P8804, $P8805
    nqp_get_sc_object $P8806, "1304516035.536", 258
    .const 'Sub' $P8807 = "282_1304516047.681" 
    assign $P8806, $P8807
    nqp_get_sc_object $P8808, "1304516035.536", 259
    .const 'Sub' $P8809 = "283_1304516047.681" 
    assign $P8808, $P8809
    nqp_get_sc_object $P8810, "1304516035.536", 260
    .const 'Sub' $P8811 = "284_1304516047.681" 
    assign $P8810, $P8811
    nqp_get_sc_object $P8812, "1304516035.536", 261
    .const 'Sub' $P8813 = "285_1304516047.681" 
    assign $P8812, $P8813
    nqp_get_sc_object $P8814, "1304516035.536", 262
    .const 'Sub' $P8815 = "286_1304516047.681" 
    assign $P8814, $P8815
    nqp_get_sc_object $P8816, "1304516035.536", 263
    .const 'Sub' $P8817 = "287_1304516047.681" 
    assign $P8816, $P8817
    nqp_get_sc_object $P8818, "1304516035.536", 264
    .const 'Sub' $P8819 = "288_1304516047.681" 
    assign $P8818, $P8819
    nqp_get_sc_object $P8820, "1304516035.536", 265
    .const 'Sub' $P8821 = "289_1304516047.681" 
    assign $P8820, $P8821
    nqp_get_sc_object $P8822, "1304516035.536", 266
    .const 'Sub' $P8823 = "290_1304516047.681" 
    assign $P8822, $P8823
    nqp_get_sc_object $P8824, "1304516035.536", 267
    .const 'Sub' $P8825 = "291_1304516047.681" 
    assign $P8824, $P8825
    nqp_get_sc_object $P8826, "1304516035.536", 268
    .const 'Sub' $P8827 = "292_1304516047.681" 
    assign $P8826, $P8827
    nqp_get_sc_object $P8828, "1304516035.536", 269
    .const 'Sub' $P8829 = "293_1304516047.681" 
    assign $P8828, $P8829
    nqp_get_sc_object $P8830, "1304516035.536", 270
    .const 'Sub' $P8831 = "294_1304516047.681" 
    assign $P8830, $P8831
    nqp_get_sc_object $P8832, "1304516035.536", 271
    .const 'Sub' $P8833 = "295_1304516047.681" 
    assign $P8832, $P8833
    nqp_get_sc_object $P8834, "1304516035.536", 272
    .const 'Sub' $P8835 = "296_1304516047.681" 
    assign $P8834, $P8835
    nqp_get_sc_object $P8836, "1304516035.536", 273
    .const 'Sub' $P8837 = "297_1304516047.681" 
    assign $P8836, $P8837
    nqp_get_sc_object $P8838, "1304516035.536", 274
    .const 'Sub' $P8839 = "298_1304516047.681" 
    assign $P8838, $P8839
    nqp_get_sc_object $P8840, "1304516035.536", 275
    .const 'Sub' $P8841 = "299_1304516047.681" 
    assign $P8840, $P8841
    nqp_get_sc_object $P8842, "1304516035.536", 276
    .const 'Sub' $P8843 = "300_1304516047.681" 
    assign $P8842, $P8843
    nqp_get_sc_object $P8844, "1304516035.536", 277
    .const 'Sub' $P8845 = "301_1304516047.681" 
    assign $P8844, $P8845
    nqp_get_sc_object $P8846, "1304516035.536", 278
    .const 'Sub' $P8847 = "302_1304516047.681" 
    assign $P8846, $P8847
    nqp_get_sc_object $P8848, "1304516035.536", 279
    .const 'Sub' $P8849 = "303_1304516047.681" 
    assign $P8848, $P8849
    nqp_get_sc_object $P8850, "1304516035.536", 280
    .const 'Sub' $P8851 = "304_1304516047.681" 
    assign $P8850, $P8851
    nqp_get_sc_object $P8852, "1304516035.536", 281
    .const 'Sub' $P8853 = "305_1304516047.681" 
    assign $P8852, $P8853
    nqp_get_sc_object $P8854, "1304516035.536", 282
    .const 'Sub' $P8855 = "306_1304516047.681" 
    assign $P8854, $P8855
    nqp_get_sc_object $P8856, "1304516035.536", 283
    .const 'Sub' $P8857 = "307_1304516047.681" 
    assign $P8856, $P8857
    nqp_get_sc_object $P8858, "1304516035.536", 284
    .const 'Sub' $P8859 = "308_1304516047.681" 
    assign $P8858, $P8859
    nqp_get_sc_object $P8860, "1304516035.536", 285
    .const 'Sub' $P8861 = "309_1304516047.681" 
    assign $P8860, $P8861
    nqp_get_sc_object $P8862, "1304516035.536", 286
    .const 'Sub' $P8863 = "310_1304516047.681" 
    assign $P8862, $P8863
    nqp_get_sc_object $P8864, "1304516035.536", 287
    .const 'Sub' $P8865 = "311_1304516047.681" 
    assign $P8864, $P8865
    nqp_get_sc_object $P8866, "1304516035.536", 288
    .const 'Sub' $P8867 = "312_1304516047.681" 
    assign $P8866, $P8867
    nqp_get_sc_object $P8868, "1304516035.536", 289
    .const 'Sub' $P8869 = "313_1304516047.681" 
    assign $P8868, $P8869
    nqp_get_sc_object $P8870, "1304516035.536", 290
    .const 'Sub' $P8871 = "314_1304516047.681" 
    assign $P8870, $P8871
    nqp_get_sc_object $P8872, "1304516035.536", 291
    .const 'Sub' $P8873 = "315_1304516047.681" 
    assign $P8872, $P8873
    nqp_get_sc_object $P8874, "1304516035.536", 292
    .const 'Sub' $P8875 = "316_1304516047.681" 
    assign $P8874, $P8875
    nqp_get_sc_object $P8876, "1304516035.536", 293
    .const 'Sub' $P8877 = "317_1304516047.681" 
    assign $P8876, $P8877
    nqp_get_sc_object $P8878, "1304516035.536", 294
    .const 'Sub' $P8879 = "318_1304516047.681" 
    assign $P8878, $P8879
    nqp_get_sc_object $P8880, "1304516035.536", 295
    .const 'Sub' $P8881 = "319_1304516047.681" 
    assign $P8880, $P8881
    nqp_get_sc_object $P8882, "1304516035.536", 296
    .const 'Sub' $P8883 = "320_1304516047.681" 
    assign $P8882, $P8883
    nqp_get_sc_object $P8884, "1304516035.536", 297
    .const 'Sub' $P8885 = "321_1304516047.681" 
    assign $P8884, $P8885
    nqp_get_sc_object $P8886, "1304516035.536", 298
    .const 'Sub' $P8887 = "322_1304516047.681" 
    assign $P8886, $P8887
    nqp_get_sc_object $P8888, "1304516035.536", 299
    .const 'Sub' $P8889 = "323_1304516047.681" 
    assign $P8888, $P8889
    nqp_get_sc_object $P8890, "1304516035.536", 300
    .const 'Sub' $P8891 = "324_1304516047.681" 
    assign $P8890, $P8891
    nqp_get_sc_object $P8892, "1304516035.536", 301
    .const 'Sub' $P8893 = "325_1304516047.681" 
    assign $P8892, $P8893
    nqp_get_sc_object $P8894, "1304516035.536", 302
    .const 'Sub' $P8895 = "326_1304516047.681" 
    assign $P8894, $P8895
    nqp_get_sc_object $P8896, "1304516035.536", 303
    .const 'Sub' $P8897 = "327_1304516047.681" 
    assign $P8896, $P8897
    nqp_get_sc_object $P8898, "1304516035.536", 304
    .const 'Sub' $P8899 = "328_1304516047.681" 
    assign $P8898, $P8899
    nqp_get_sc_object $P8900, "1304516035.536", 305
    .const 'Sub' $P8901 = "329_1304516047.681" 
    assign $P8900, $P8901
    nqp_get_sc_object $P8902, "1304516035.536", 306
    .const 'Sub' $P8903 = "330_1304516047.681" 
    assign $P8902, $P8903
    nqp_get_sc_object $P8904, "1304516035.536", 307
    .const 'Sub' $P8905 = "331_1304516047.681" 
    assign $P8904, $P8905
    nqp_get_sc_object $P8906, "1304516035.536", 308
    .const 'Sub' $P8907 = "332_1304516047.681" 
    assign $P8906, $P8907
    nqp_get_sc_object $P8908, "1304516035.536", 309
    .const 'Sub' $P8909 = "333_1304516047.681" 
    assign $P8908, $P8909
    nqp_get_sc_object $P8910, "1304516035.536", 310
    .const 'Sub' $P8911 = "334_1304516047.681" 
    assign $P8910, $P8911
    nqp_get_sc_object $P8912, "1304516035.536", 311
    .const 'Sub' $P8913 = "335_1304516047.681" 
    assign $P8912, $P8913
    nqp_get_sc_object $P8914, "1304516035.536", 312
    .const 'Sub' $P8915 = "336_1304516047.681" 
    assign $P8914, $P8915
    nqp_get_sc_object $P8916, "1304516035.536", 313
    .const 'Sub' $P8917 = "337_1304516047.681" 
    assign $P8916, $P8917
    nqp_get_sc_object $P8918, "1304516035.536", 314
    .const 'Sub' $P8919 = "338_1304516047.681" 
    assign $P8918, $P8919
    nqp_get_sc_object $P8920, "1304516035.536", 315
    .const 'Sub' $P8921 = "339_1304516047.681" 
    assign $P8920, $P8921
    nqp_get_sc_object $P8922, "1304516035.536", 316
    .const 'Sub' $P8923 = "340_1304516047.681" 
    assign $P8922, $P8923
    nqp_get_sc_object $P8924, "1304516035.536", 317
    .const 'Sub' $P8925 = "341_1304516047.681" 
    assign $P8924, $P8925
    nqp_get_sc_object $P8926, "1304516035.536", 318
    .const 'Sub' $P8927 = "342_1304516047.681" 
    assign $P8926, $P8927
    nqp_get_sc_object $P8928, "1304516035.536", 319
    .const 'Sub' $P8929 = "343_1304516047.681" 
    assign $P8928, $P8929
    nqp_get_sc_object $P8930, "1304516035.536", 320
    .const 'Sub' $P8931 = "344_1304516047.681" 
    assign $P8930, $P8931
    nqp_get_sc_object $P8932, "1304516035.536", 321
    .const 'Sub' $P8933 = "345_1304516047.681" 
    assign $P8932, $P8933
    nqp_get_sc_object $P8934, "1304516035.536", 322
    .const 'Sub' $P8935 = "346_1304516047.681" 
    assign $P8934, $P8935
    nqp_get_sc_object $P8936, "1304516035.536", 323
    .const 'Sub' $P8937 = "347_1304516047.681" 
    assign $P8936, $P8937
    nqp_get_sc_object $P8938, "1304516035.536", 324
    .const 'Sub' $P8939 = "348_1304516047.681" 
    assign $P8938, $P8939
    nqp_get_sc_object $P8940, "1304516035.536", 325
    .const 'Sub' $P8941 = "349_1304516047.681" 
    assign $P8940, $P8941
    nqp_get_sc_object $P8942, "1304516035.536", 326
    .const 'Sub' $P8943 = "350_1304516047.681" 
    assign $P8942, $P8943
    nqp_get_sc_object $P8944, "1304516035.536", 327
    .const 'Sub' $P8945 = "351_1304516047.681" 
    assign $P8944, $P8945
    nqp_get_sc_object $P8946, "1304516035.536", 328
    .const 'Sub' $P8947 = "352_1304516047.681" 
    assign $P8946, $P8947
    nqp_get_sc_object $P8948, "1304516035.536", 329
    .const 'Sub' $P8949 = "353_1304516047.681" 
    assign $P8948, $P8949
    nqp_get_sc_object $P8950, "1304516035.536", 330
    .const 'Sub' $P8951 = "354_1304516047.681" 
    assign $P8950, $P8951
    nqp_get_sc_object $P8952, "1304516035.536", 331
    .const 'Sub' $P8953 = "355_1304516047.681" 
    assign $P8952, $P8953
    nqp_get_sc_object $P8954, "1304516035.536", 332
    .const 'Sub' $P8955 = "356_1304516047.681" 
    assign $P8954, $P8955
    nqp_get_sc_object $P8956, "1304516035.536", 333
    .const 'Sub' $P8957 = "357_1304516047.681" 
    assign $P8956, $P8957
    nqp_get_sc_object $P8958, "1304516035.536", 334
    .const 'Sub' $P8959 = "358_1304516047.681" 
    assign $P8958, $P8959
    nqp_get_sc_object $P8960, "1304516035.536", 335
    .const 'Sub' $P8961 = "359_1304516047.681" 
    assign $P8960, $P8961
    nqp_get_sc_object $P8962, "1304516035.536", 336
    .const 'Sub' $P8963 = "360_1304516047.681" 
    assign $P8962, $P8963
    nqp_get_sc_object $P8964, "1304516035.536", 337
    .const 'Sub' $P8965 = "361_1304516047.681" 
    assign $P8964, $P8965
    nqp_get_sc_object $P8966, "1304516035.536", 338
    .const 'Sub' $P8967 = "362_1304516047.681" 
    assign $P8966, $P8967
    nqp_get_sc_object $P8968, "1304516035.536", 339
    .const 'Sub' $P8969 = "363_1304516047.681" 
    assign $P8968, $P8969
    nqp_get_sc_object $P8970, "1304516035.536", 340
    .const 'Sub' $P8971 = "364_1304516047.681" 
    assign $P8970, $P8971
    nqp_get_sc_object $P8972, "1304516035.536", 341
    .const 'Sub' $P8973 = "365_1304516047.681" 
    assign $P8972, $P8973
    nqp_get_sc_object $P8974, "1304516035.536", 342
    .const 'Sub' $P8975 = "366_1304516047.681" 
    assign $P8974, $P8975
    nqp_get_sc_object $P8976, "1304516035.536", 343
    .const 'Sub' $P8977 = "367_1304516047.681" 
    assign $P8976, $P8977
    nqp_get_sc_object $P8978, "1304516035.536", 344
    .const 'Sub' $P8979 = "368_1304516047.681" 
    assign $P8978, $P8979
    nqp_get_sc_object $P8980, "1304516035.536", 345
    .const 'Sub' $P8981 = "369_1304516047.681" 
    assign $P8980, $P8981
    nqp_get_sc_object $P8982, "1304516035.536", 346
    .const 'Sub' $P8983 = "370_1304516047.681" 
    assign $P8982, $P8983
    nqp_get_sc_object $P8984, "1304516035.536", 347
    .const 'Sub' $P8985 = "371_1304516047.681" 
    assign $P8984, $P8985
    nqp_get_sc_object $P8986, "1304516035.536", 348
    .const 'Sub' $P8987 = "372_1304516047.681" 
    assign $P8986, $P8987
    nqp_get_sc_object $P8988, "1304516035.536", 349
    .const 'Sub' $P8989 = "373_1304516047.681" 
    assign $P8988, $P8989
    nqp_get_sc_object $P8990, "1304516035.536", 350
    .const 'Sub' $P8991 = "375_1304516047.681" 
    assign $P8990, $P8991
    nqp_get_sc_object $P8992, "1304516035.536", 351
    .const 'Sub' $P8993 = "376_1304516047.681" 
    assign $P8992, $P8993
    nqp_get_sc_object $P8994, "1304516035.536", 352
    .const 'Sub' $P8995 = "377_1304516047.681" 
    assign $P8994, $P8995
    nqp_get_sc_object $P8996, "1304516035.536", 353
    .const 'Sub' $P8997 = "378_1304516047.681" 
    assign $P8996, $P8997
    nqp_get_sc_object $P8998, "1304516035.536", 354
    .const 'Sub' $P8999 = "379_1304516047.681" 
    assign $P8998, $P8999
    nqp_get_sc_object $P9000, "1304516035.536", 355
    .const 'Sub' $P9001 = "380_1304516047.681" 
    assign $P9000, $P9001
    nqp_get_sc_object $P9002, "1304516035.536", 356
    .const 'Sub' $P9003 = "381_1304516047.681" 
    assign $P9002, $P9003
    nqp_get_sc_object $P9004, "1304516035.536", 357
    .const 'Sub' $P9005 = "382_1304516047.681" 
    assign $P9004, $P9005
    nqp_get_sc_object $P9006, "1304516035.536", 358
    .const 'Sub' $P9007 = "383_1304516047.681" 
    assign $P9006, $P9007
    nqp_get_sc_object $P9008, "1304516035.536", 359
    .const 'Sub' $P9009 = "384_1304516047.681" 
    assign $P9008, $P9009
    .const 'Sub' $P9010 = "12_1304516047.681" 
    $P9011 = $P9010."get_lexinfo"()
    nqp_get_sc_object $P9012, "1304516035.536", 1
    $P9011."set_static_lexpad_value"("$?PACKAGE", $P9012)
    .const 'Sub' $P9013 = "12_1304516047.681" 
    $P9014 = $P9013."get_lexinfo"()
    $P9014."finish_static_lexpad"()
    .const 'Sub' $P9015 = "12_1304516047.681" 
    $P9016 = $P9015."get_lexinfo"()
    nqp_get_sc_object $P9017, "1304516035.536", 1
    $P9016."set_static_lexpad_value"("$?CLASS", $P9017)
    .const 'Sub' $P9018 = "12_1304516047.681" 
    $P9019 = $P9018."get_lexinfo"()
    $P9019."finish_static_lexpad"()
    nqp_get_sc_object $P9020, "1304516035.536", 361
    .const 'Sub' $P9021 = "386_1304516047.681" 
    assign $P9020, $P9021
    nqp_get_sc_object $P9022, "1304516035.536", 362
    .const 'Sub' $P9023 = "388_1304516047.681" 
    assign $P9022, $P9023
    nqp_get_sc_object $P9024, "1304516035.536", 363
    .const 'Sub' $P9025 = "389_1304516047.681" 
    assign $P9024, $P9025
    nqp_get_sc_object $P9026, "1304516035.536", 364
    .const 'Sub' $P9027 = "390_1304516047.681" 
    assign $P9026, $P9027
    nqp_get_sc_object $P9028, "1304516035.536", 365
    .const 'Sub' $P9029 = "391_1304516047.681" 
    assign $P9028, $P9029
    nqp_get_sc_object $P9030, "1304516035.536", 366
    .const 'Sub' $P9031 = "393_1304516047.681" 
    assign $P9030, $P9031
    nqp_get_sc_object $P9032, "1304516035.536", 367
    .const 'Sub' $P9033 = "394_1304516047.681" 
    assign $P9032, $P9033
    nqp_get_sc_object $P9034, "1304516035.536", 368
    .const 'Sub' $P9035 = "395_1304516047.681" 
    assign $P9034, $P9035
    nqp_get_sc_object $P9036, "1304516035.536", 369
    .const 'Sub' $P9037 = "396_1304516047.681" 
    assign $P9036, $P9037
    nqp_get_sc_object $P9038, "1304516035.536", 370
    .const 'Sub' $P9039 = "398_1304516047.681" 
    assign $P9038, $P9039
    nqp_get_sc_object $P9040, "1304516035.536", 371
    .const 'Sub' $P9041 = "399_1304516047.681" 
    assign $P9040, $P9041
    nqp_get_sc_object $P9042, "1304516035.536", 372
    .const 'Sub' $P9043 = "401_1304516047.681" 
    assign $P9042, $P9043
    nqp_get_sc_object $P9044, "1304516035.536", 373
    .const 'Sub' $P9045 = "402_1304516047.681" 
    assign $P9044, $P9045
    nqp_get_sc_object $P9046, "1304516035.536", 374
    .const 'Sub' $P9047 = "403_1304516047.681" 
    assign $P9046, $P9047
    nqp_get_sc_object $P9048, "1304516035.536", 375
    .const 'Sub' $P9049 = "404_1304516047.681" 
    assign $P9048, $P9049
    nqp_get_sc_object $P9050, "1304516035.536", 376
    .const 'Sub' $P9051 = "405_1304516047.681" 
    assign $P9050, $P9051
    .const 'Sub' $P9052 = "385_1304516047.681" 
    $P9053 = $P9052."get_lexinfo"()
    nqp_get_sc_object $P9054, "1304516035.536", 360
    $P9053."set_static_lexpad_value"("$?PACKAGE", $P9054)
    .const 'Sub' $P9055 = "385_1304516047.681" 
    $P9056 = $P9055."get_lexinfo"()
    $P9056."finish_static_lexpad"()
    .const 'Sub' $P9057 = "385_1304516047.681" 
    $P9058 = $P9057."get_lexinfo"()
    nqp_get_sc_object $P9059, "1304516035.536", 360
    $P9058."set_static_lexpad_value"("$?CLASS", $P9059)
    .const 'Sub' $P9060 = "385_1304516047.681" 
    $P9061 = $P9060."get_lexinfo"()
    $P9061."finish_static_lexpad"()
    nqp_get_sc_object $P9062, "1304516035.536", 378
    .const 'Sub' $P9063 = "433_1304516047.681" 
    assign $P9062, $P9063
    nqp_get_sc_object $P9064, "1304516035.536", 379
    .const 'Sub' $P9065 = "434_1304516047.681" 
    assign $P9064, $P9065
    nqp_get_sc_object $P9066, "1304516035.536", 380
    .const 'Sub' $P9067 = "435_1304516047.681" 
    assign $P9066, $P9067
    nqp_get_sc_object $P9068, "1304516035.536", 381
    .const 'Sub' $P9069 = "436_1304516047.681" 
    assign $P9068, $P9069
    nqp_get_sc_object $P9070, "1304516035.536", 382
    .const 'Sub' $P9071 = "438_1304516047.681" 
    assign $P9070, $P9071
    nqp_get_sc_object $P9072, "1304516035.536", 383
    .const 'Sub' $P9073 = "440_1304516047.681" 
    assign $P9072, $P9073
    nqp_get_sc_object $P9074, "1304516035.536", 384
    .const 'Sub' $P9075 = "441_1304516047.681" 
    assign $P9074, $P9075
    nqp_get_sc_object $P9076, "1304516035.536", 385
    .const 'Sub' $P9077 = "442_1304516047.681" 
    assign $P9076, $P9077
    nqp_get_sc_object $P9078, "1304516035.536", 386
    .const 'Sub' $P9079 = "443_1304516047.681" 
    assign $P9078, $P9079
    nqp_get_sc_object $P9080, "1304516035.536", 387
    .const 'Sub' $P9081 = "445_1304516047.681" 
    assign $P9080, $P9081
    nqp_get_sc_object $P9082, "1304516035.536", 388
    .const 'Sub' $P9083 = "446_1304516047.681" 
    assign $P9082, $P9083
    nqp_get_sc_object $P9084, "1304516035.536", 389
    .const 'Sub' $P9085 = "448_1304516047.681" 
    assign $P9084, $P9085
    nqp_get_sc_object $P9086, "1304516035.536", 390
    .const 'Sub' $P9087 = "449_1304516047.681" 
    assign $P9086, $P9087
    nqp_get_sc_object $P9088, "1304516035.536", 391
    .const 'Sub' $P9089 = "450_1304516047.681" 
    assign $P9088, $P9089
    nqp_get_sc_object $P9090, "1304516035.536", 392
    .const 'Sub' $P9091 = "451_1304516047.681" 
    assign $P9090, $P9091
    nqp_get_sc_object $P9092, "1304516035.536", 393
    .const 'Sub' $P9093 = "453_1304516047.681" 
    assign $P9092, $P9093
    nqp_get_sc_object $P9094, "1304516035.536", 394
    .const 'Sub' $P9095 = "454_1304516047.681" 
    assign $P9094, $P9095
    nqp_get_sc_object $P9096, "1304516035.536", 395
    .const 'Sub' $P9097 = "455_1304516047.681" 
    assign $P9096, $P9097
    nqp_get_sc_object $P9098, "1304516035.536", 396
    .const 'Sub' $P9099 = "456_1304516047.681" 
    assign $P9098, $P9099
    nqp_get_sc_object $P9100, "1304516035.536", 397
    .const 'Sub' $P9101 = "457_1304516047.681" 
    assign $P9100, $P9101
    nqp_get_sc_object $P9102, "1304516035.536", 398
    .const 'Sub' $P9103 = "458_1304516047.681" 
    assign $P9102, $P9103
    nqp_get_sc_object $P9104, "1304516035.536", 399
    .const 'Sub' $P9105 = "459_1304516047.681" 
    assign $P9104, $P9105
    nqp_get_sc_object $P9106, "1304516035.536", 400
    .const 'Sub' $P9107 = "460_1304516047.681" 
    assign $P9106, $P9107
    nqp_get_sc_object $P9108, "1304516035.536", 401
    .const 'Sub' $P9109 = "461_1304516047.681" 
    assign $P9108, $P9109
    nqp_get_sc_object $P9110, "1304516035.536", 402
    .const 'Sub' $P9111 = "462_1304516047.681" 
    assign $P9110, $P9111
    nqp_get_sc_object $P9112, "1304516035.536", 403
    .const 'Sub' $P9113 = "463_1304516047.681" 
    assign $P9112, $P9113
    nqp_get_sc_object $P9114, "1304516035.536", 404
    .const 'Sub' $P9115 = "464_1304516047.681" 
    assign $P9114, $P9115
    nqp_get_sc_object $P9116, "1304516035.536", 405
    .const 'Sub' $P9117 = "465_1304516047.681" 
    assign $P9116, $P9117
    nqp_get_sc_object $P9118, "1304516035.536", 406
    .const 'Sub' $P9119 = "466_1304516047.681" 
    assign $P9118, $P9119
    nqp_get_sc_object $P9120, "1304516035.536", 407
    .const 'Sub' $P9121 = "467_1304516047.681" 
    assign $P9120, $P9121
    nqp_get_sc_object $P9122, "1304516035.536", 408
    .const 'Sub' $P9123 = "468_1304516047.681" 
    assign $P9122, $P9123
    nqp_get_sc_object $P9124, "1304516035.536", 409
    .const 'Sub' $P9125 = "469_1304516047.681" 
    assign $P9124, $P9125
    nqp_get_sc_object $P9126, "1304516035.536", 410
    .const 'Sub' $P9127 = "470_1304516047.681" 
    assign $P9126, $P9127
    nqp_get_sc_object $P9128, "1304516035.536", 411
    .const 'Sub' $P9129 = "471_1304516047.681" 
    assign $P9128, $P9129
    nqp_get_sc_object $P9130, "1304516035.536", 412
    .const 'Sub' $P9131 = "472_1304516047.681" 
    assign $P9130, $P9131
    nqp_get_sc_object $P9132, "1304516035.536", 413
    .const 'Sub' $P9133 = "473_1304516047.681" 
    assign $P9132, $P9133
    nqp_get_sc_object $P9134, "1304516035.536", 414
    .const 'Sub' $P9135 = "474_1304516047.681" 
    assign $P9134, $P9135
    nqp_get_sc_object $P9136, "1304516035.536", 415
    .const 'Sub' $P9137 = "475_1304516047.681" 
    assign $P9136, $P9137
    nqp_get_sc_object $P9138, "1304516035.536", 416
    .const 'Sub' $P9139 = "476_1304516047.681" 
    assign $P9138, $P9139
    nqp_get_sc_object $P9140, "1304516035.536", 417
    .const 'Sub' $P9141 = "477_1304516047.681" 
    assign $P9140, $P9141
    nqp_get_sc_object $P9142, "1304516035.536", 418
    .const 'Sub' $P9143 = "483_1304516047.681" 
    assign $P9142, $P9143
    nqp_get_sc_object $P9144, "1304516035.536", 419
    .const 'Sub' $P9145 = "484_1304516047.681" 
    assign $P9144, $P9145
    nqp_get_sc_object $P9146, "1304516035.536", 420
    .const 'Sub' $P9147 = "485_1304516047.681" 
    assign $P9146, $P9147
    nqp_get_sc_object $P9148, "1304516035.536", 421
    .const 'Sub' $P9149 = "486_1304516047.681" 
    assign $P9148, $P9149
    nqp_get_sc_object $P9150, "1304516035.536", 422
    .const 'Sub' $P9151 = "487_1304516047.681" 
    assign $P9150, $P9151
    nqp_get_sc_object $P9152, "1304516035.536", 423
    .const 'Sub' $P9153 = "488_1304516047.681" 
    assign $P9152, $P9153
    nqp_get_sc_object $P9154, "1304516035.536", 424
    .const 'Sub' $P9155 = "489_1304516047.681" 
    assign $P9154, $P9155
    nqp_get_sc_object $P9156, "1304516035.536", 425
    .const 'Sub' $P9157 = "495_1304516047.681" 
    assign $P9156, $P9157
    nqp_get_sc_object $P9158, "1304516035.536", 426
    .const 'Sub' $P9159 = "496_1304516047.681" 
    assign $P9158, $P9159
    nqp_get_sc_object $P9160, "1304516035.536", 427
    .const 'Sub' $P9161 = "497_1304516047.681" 
    assign $P9160, $P9161
    nqp_get_sc_object $P9162, "1304516035.536", 428
    .const 'Sub' $P9163 = "498_1304516047.681" 
    assign $P9162, $P9163
    nqp_get_sc_object $P9164, "1304516035.536", 429
    .const 'Sub' $P9165 = "499_1304516047.681" 
    assign $P9164, $P9165
    nqp_get_sc_object $P9166, "1304516035.536", 430
    .const 'Sub' $P9167 = "500_1304516047.681" 
    assign $P9166, $P9167
    nqp_get_sc_object $P9168, "1304516035.536", 431
    .const 'Sub' $P9169 = "501_1304516047.681" 
    assign $P9168, $P9169
    nqp_get_sc_object $P9170, "1304516035.536", 432
    .const 'Sub' $P9171 = "502_1304516047.681" 
    assign $P9170, $P9171
    nqp_get_sc_object $P9172, "1304516035.536", 433
    .const 'Sub' $P9173 = "503_1304516047.681" 
    assign $P9172, $P9173
    nqp_get_sc_object $P9174, "1304516035.536", 434
    .const 'Sub' $P9175 = "505_1304516047.681" 
    assign $P9174, $P9175
    nqp_get_sc_object $P9176, "1304516035.536", 435
    .const 'Sub' $P9177 = "506_1304516047.681" 
    assign $P9176, $P9177
    nqp_get_sc_object $P9178, "1304516035.536", 436
    .const 'Sub' $P9179 = "507_1304516047.681" 
    assign $P9178, $P9179
    nqp_get_sc_object $P9180, "1304516035.536", 437
    .const 'Sub' $P9181 = "514_1304516047.681" 
    assign $P9180, $P9181
    nqp_get_sc_object $P9182, "1304516035.536", 438
    .const 'Sub' $P9183 = "517_1304516047.681" 
    assign $P9182, $P9183
    nqp_get_sc_object $P9184, "1304516035.536", 439
    .const 'Sub' $P9185 = "520_1304516047.681" 
    assign $P9184, $P9185
    nqp_get_sc_object $P9186, "1304516035.536", 440
    .const 'Sub' $P9187 = "521_1304516047.681" 
    assign $P9186, $P9187
    nqp_get_sc_object $P9188, "1304516035.536", 441
    .const 'Sub' $P9189 = "522_1304516047.681" 
    assign $P9188, $P9189
    nqp_get_sc_object $P9190, "1304516035.536", 442
    .const 'Sub' $P9191 = "523_1304516047.681" 
    assign $P9190, $P9191
    nqp_get_sc_object $P9192, "1304516035.536", 443
    .const 'Sub' $P9193 = "525_1304516047.681" 
    assign $P9192, $P9193
    nqp_get_sc_object $P9194, "1304516035.536", 444
    .const 'Sub' $P9195 = "526_1304516047.681" 
    assign $P9194, $P9195
    nqp_get_sc_object $P9196, "1304516035.536", 445
    .const 'Sub' $P9197 = "529_1304516047.681" 
    assign $P9196, $P9197
    nqp_get_sc_object $P9198, "1304516035.536", 446
    .const 'Sub' $P9199 = "534_1304516047.681" 
    assign $P9198, $P9199
    nqp_get_sc_object $P9200, "1304516035.536", 447
    .const 'Sub' $P9201 = "535_1304516047.681" 
    assign $P9200, $P9201
    nqp_get_sc_object $P9202, "1304516035.536", 448
    .const 'Sub' $P9203 = "536_1304516047.681" 
    assign $P9202, $P9203
    nqp_get_sc_object $P9204, "1304516035.536", 449
    .const 'Sub' $P9205 = "537_1304516047.681" 
    assign $P9204, $P9205
    nqp_get_sc_object $P9206, "1304516035.536", 450
    .const 'Sub' $P9207 = "539_1304516047.681" 
    assign $P9206, $P9207
    nqp_get_sc_object $P9208, "1304516035.536", 451
    .const 'Sub' $P9209 = "540_1304516047.681" 
    assign $P9208, $P9209
    nqp_get_sc_object $P9210, "1304516035.536", 452
    .const 'Sub' $P9211 = "541_1304516047.681" 
    assign $P9210, $P9211
    nqp_get_sc_object $P9212, "1304516035.536", 453
    .const 'Sub' $P9213 = "542_1304516047.681" 
    assign $P9212, $P9213
    nqp_get_sc_object $P9214, "1304516035.536", 454
    .const 'Sub' $P9215 = "545_1304516047.681" 
    assign $P9214, $P9215
    nqp_get_sc_object $P9216, "1304516035.536", 455
    .const 'Sub' $P9217 = "546_1304516047.681" 
    assign $P9216, $P9217
    nqp_get_sc_object $P9218, "1304516035.536", 456
    .const 'Sub' $P9219 = "547_1304516047.681" 
    assign $P9218, $P9219
    nqp_get_sc_object $P9220, "1304516035.536", 457
    .const 'Sub' $P9221 = "548_1304516047.681" 
    assign $P9220, $P9221
    nqp_get_sc_object $P9222, "1304516035.536", 458
    .const 'Sub' $P9223 = "549_1304516047.681" 
    assign $P9222, $P9223
    nqp_get_sc_object $P9224, "1304516035.536", 459
    .const 'Sub' $P9225 = "550_1304516047.681" 
    assign $P9224, $P9225
    nqp_get_sc_object $P9226, "1304516035.536", 460
    .const 'Sub' $P9227 = "551_1304516047.681" 
    assign $P9226, $P9227
    nqp_get_sc_object $P9228, "1304516035.536", 461
    .const 'Sub' $P9229 = "553_1304516047.681" 
    assign $P9228, $P9229
    nqp_get_sc_object $P9230, "1304516035.536", 462
    .const 'Sub' $P9231 = "554_1304516047.681" 
    assign $P9230, $P9231
    nqp_get_sc_object $P9232, "1304516035.536", 463
    .const 'Sub' $P9233 = "555_1304516047.681" 
    assign $P9232, $P9233
    nqp_get_sc_object $P9234, "1304516035.536", 464
    .const 'Sub' $P9235 = "556_1304516047.681" 
    assign $P9234, $P9235
    nqp_get_sc_object $P9236, "1304516035.536", 465
    .const 'Sub' $P9237 = "557_1304516047.681" 
    assign $P9236, $P9237
    nqp_get_sc_object $P9238, "1304516035.536", 466
    .const 'Sub' $P9239 = "558_1304516047.681" 
    assign $P9238, $P9239
    nqp_get_sc_object $P9240, "1304516035.536", 467
    .const 'Sub' $P9241 = "559_1304516047.681" 
    assign $P9240, $P9241
    nqp_get_sc_object $P9242, "1304516035.536", 468
    .const 'Sub' $P9243 = "560_1304516047.681" 
    assign $P9242, $P9243
    nqp_get_sc_object $P9244, "1304516035.536", 469
    .const 'Sub' $P9245 = "561_1304516047.681" 
    assign $P9244, $P9245
    nqp_get_sc_object $P9246, "1304516035.536", 470
    .const 'Sub' $P9247 = "562_1304516047.681" 
    assign $P9246, $P9247
    nqp_get_sc_object $P9248, "1304516035.536", 471
    .const 'Sub' $P9249 = "563_1304516047.681" 
    assign $P9248, $P9249
    nqp_get_sc_object $P9250, "1304516035.536", 472
    .const 'Sub' $P9251 = "564_1304516047.681" 
    assign $P9250, $P9251
    nqp_get_sc_object $P9252, "1304516035.536", 473
    .const 'Sub' $P9253 = "565_1304516047.681" 
    assign $P9252, $P9253
    nqp_get_sc_object $P9254, "1304516035.536", 474
    .const 'Sub' $P9255 = "566_1304516047.681" 
    assign $P9254, $P9255
    nqp_get_sc_object $P9256, "1304516035.536", 475
    .const 'Sub' $P9257 = "567_1304516047.681" 
    assign $P9256, $P9257
    nqp_get_sc_object $P9258, "1304516035.536", 476
    .const 'Sub' $P9259 = "568_1304516047.681" 
    assign $P9258, $P9259
    nqp_get_sc_object $P9260, "1304516035.536", 477
    .const 'Sub' $P9261 = "569_1304516047.681" 
    assign $P9260, $P9261
    nqp_get_sc_object $P9262, "1304516035.536", 478
    .const 'Sub' $P9263 = "570_1304516047.681" 
    assign $P9262, $P9263
    nqp_get_sc_object $P9264, "1304516035.536", 479
    .const 'Sub' $P9265 = "571_1304516047.681" 
    assign $P9264, $P9265
    nqp_get_sc_object $P9266, "1304516035.536", 480
    .const 'Sub' $P9267 = "572_1304516047.681" 
    assign $P9266, $P9267
    nqp_get_sc_object $P9268, "1304516035.536", 481
    .const 'Sub' $P9269 = "573_1304516047.681" 
    assign $P9268, $P9269
    nqp_get_sc_object $P9270, "1304516035.536", 482
    .const 'Sub' $P9271 = "574_1304516047.681" 
    assign $P9270, $P9271
    nqp_get_sc_object $P9272, "1304516035.536", 483
    .const 'Sub' $P9273 = "575_1304516047.681" 
    assign $P9272, $P9273
    nqp_get_sc_object $P9274, "1304516035.536", 484
    .const 'Sub' $P9275 = "576_1304516047.681" 
    assign $P9274, $P9275
    nqp_get_sc_object $P9276, "1304516035.536", 485
    .const 'Sub' $P9277 = "577_1304516047.681" 
    assign $P9276, $P9277
    nqp_get_sc_object $P9278, "1304516035.536", 486
    .const 'Sub' $P9279 = "578_1304516047.681" 
    assign $P9278, $P9279
    nqp_get_sc_object $P9280, "1304516035.536", 487
    .const 'Sub' $P9281 = "579_1304516047.681" 
    assign $P9280, $P9281
    .const 'Sub' $P9282 = "406_1304516047.681" 
    $P9283 = $P9282."get_lexinfo"()
    nqp_get_sc_object $P9284, "1304516035.536", 377
    $P9283."set_static_lexpad_value"("$?PACKAGE", $P9284)
    .const 'Sub' $P9285 = "406_1304516047.681" 
    $P9286 = $P9285."get_lexinfo"()
    $P9286."finish_static_lexpad"()
    .const 'Sub' $P9287 = "406_1304516047.681" 
    $P9288 = $P9287."get_lexinfo"()
    nqp_get_sc_object $P9289, "1304516035.536", 377
    $P9288."set_static_lexpad_value"("$?CLASS", $P9289)
    .const 'Sub' $P9290 = "406_1304516047.681" 
    $P9291 = $P9290."get_lexinfo"()
    $P9291."finish_static_lexpad"()
    nqp_get_sc_object $P9292, "1304516035.536", 489
    .const 'Sub' $P9293 = "582_1304516047.681" 
    assign $P9292, $P9293
    nqp_get_sc_object $P9294, "1304516035.536", 490
    .const 'Sub' $P9295 = "583_1304516047.681" 
    assign $P9294, $P9295
    nqp_get_sc_object $P9296, "1304516035.536", 491
    .const 'Sub' $P9297 = "584_1304516047.681" 
    assign $P9296, $P9297
    nqp_get_sc_object $P9298, "1304516035.536", 492
    .const 'Sub' $P9299 = "585_1304516047.681" 
    assign $P9298, $P9299
    nqp_get_sc_object $P9300, "1304516035.536", 493
    .const 'Sub' $P9301 = "586_1304516047.681" 
    assign $P9300, $P9301
    nqp_get_sc_object $P9302, "1304516035.536", 494
    .const 'Sub' $P9303 = "587_1304516047.681" 
    assign $P9302, $P9303
    nqp_get_sc_object $P9304, "1304516035.536", 495
    .const 'Sub' $P9305 = "588_1304516047.681" 
    assign $P9304, $P9305
    .const 'Sub' $P9306 = "581_1304516047.681" 
    $P9307 = $P9306."get_lexinfo"()
    nqp_get_sc_object $P9308, "1304516035.536", 488
    $P9307."set_static_lexpad_value"("$?PACKAGE", $P9308)
    .const 'Sub' $P9309 = "581_1304516047.681" 
    $P9310 = $P9309."get_lexinfo"()
    $P9310."finish_static_lexpad"()
    .const 'Sub' $P9311 = "581_1304516047.681" 
    $P9312 = $P9311."get_lexinfo"()
    nqp_get_sc_object $P9313, "1304516035.536", 488
    $P9312."set_static_lexpad_value"("$?CLASS", $P9313)
    .const 'Sub' $P9314 = "581_1304516047.681" 
    $P9315 = $P9314."get_lexinfo"()
    $P9315."finish_static_lexpad"()
    .const 'Sub' $P9316 = "589_1304516047.681" 
    $P9317 = $P9316."get_lexinfo"()
    nqp_get_sc_object $P9318, "1304516035.536", 496
    $P9317."set_static_lexpad_value"("$?PACKAGE", $P9318)
    .const 'Sub' $P9319 = "589_1304516047.681" 
    $P9320 = $P9319."get_lexinfo"()
    $P9320."finish_static_lexpad"()
    .const 'Sub' $P9321 = "589_1304516047.681" 
    $P9322 = $P9321."get_lexinfo"()
    nqp_get_sc_object $P9323, "1304516035.536", 496
    $P9322."set_static_lexpad_value"("$?CLASS", $P9323)
    .const 'Sub' $P9324 = "589_1304516047.681" 
    $P9325 = $P9324."get_lexinfo"()
    $P9325."finish_static_lexpad"()
    goto if_6180_end
  if_6180:
    nqp_dynop_setup 
    getinterp $P6183
    get_class $P6184, "LexPad"
    get_class $P6185, "NQPLexPad"
    $P6183."hll_map"($P6184, $P6185)
    nqp_create_sc $P6186, "1304516035.536"
    .local pmc cur_sc
    set cur_sc, $P6186
    nqp_get_sc_object $P6187, "__6MODEL_CORE__", 0
    $P6188 = $P6187."new_type"("GLOBALish" :named("name"))
    nqp_set_sc_for_object $P6188, cur_sc
    nqp_set_sc_object "1304516035.536", 0, $P6188
    .const 'Sub' $P6189 = "10_1304516047.681" 
    $P6190 = $P6189."get_lexinfo"()
    nqp_get_sc_object $P6191, "1304516035.536", 0
    $P6190."set_static_lexpad_value"("GLOBALish", $P6191)
    .const 'Sub' $P6192 = "10_1304516047.681" 
    $P6193 = $P6192."get_lexinfo"()
    $P6193."finish_static_lexpad"()
    .const 'Sub' $P6194 = "10_1304516047.681" 
    $P6195 = $P6194."get_lexinfo"()
    nqp_get_sc_object $P6196, "1304516035.536", 0
    $P6195."set_static_lexpad_value"("$?PACKAGE", $P6196)
    .const 'Sub' $P6197 = "10_1304516047.681" 
    $P6198 = $P6197."get_lexinfo"()
    $P6198."finish_static_lexpad"()
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6199, "ModuleLoader"
    $P6200 = $P6199."load_setting"("NQPCORE")
    block."set_outer_ctx"($P6200)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6201, "ModuleLoader"
    nqp_get_sc_object $P6202, "1304516035.536", 0
    $P6201."load_module"("NQPRegex", $P6202)
    load_bytecode "ModuleLoader.pbc"
    get_hll_global $P6203, "ModuleLoader"
    nqp_get_sc_object $P6204, "1304516035.536", 0
    $P6203."load_module"("NQPP6Regex", $P6204)
    nqp_get_sc_object $P6205, "1304516008.504", 41
    $P6206 = $P6205."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P6206, cur_sc
    nqp_set_sc_object "1304516035.536", 1, $P6206
    nqp_get_sc_object $P6207, "1304516035.536", 1
    nqp_get_sc_object $P6208, "1304516035.536", 0
    nqp_get_package_through_who $P6209, $P6208, "NQP"
    get_who $P6210, $P6209
    set $P6210["Grammar"], $P6207
    nqp_get_sc_object $P6211, "1304516035.536", 1
    get_how $P6212, $P6211
    nqp_get_sc_object $P6213, "1304516035.536", 1
    .const 'Sub' $P6214 = "13_1304516047.681" 
    $P6212."add_method"($P6213, "TOP", $P6214)
    nqp_get_sc_object $P6215, "1304516035.536", 1
    get_how $P6216, $P6215
    nqp_get_sc_object $P6217, "1304516035.536", 1
    .const 'Sub' $P6218 = "14_1304516047.681" 
    $P6216."add_method"($P6217, "identifier", $P6218)
    nqp_get_sc_object $P6219, "1304516035.536", 1
    get_how $P6220, $P6219
    nqp_get_sc_object $P6221, "1304516035.536", 1
    .const 'Sub' $P6222 = "15_1304516047.681" 
    $P6220."add_method"($P6221, "!PREFIX__identifier", $P6222)
    nqp_get_sc_object $P6223, "1304516035.536", 1
    get_how $P6224, $P6223
    nqp_get_sc_object $P6225, "1304516035.536", 1
    .const 'Sub' $P6226 = "16_1304516047.681" 
    $P6224."add_method"($P6225, "name", $P6226)
    nqp_get_sc_object $P6227, "1304516035.536", 1
    get_how $P6228, $P6227
    nqp_get_sc_object $P6229, "1304516035.536", 1
    .const 'Sub' $P6230 = "17_1304516047.681" 
    $P6228."add_method"($P6229, "!PREFIX__name", $P6230)
    nqp_get_sc_object $P6231, "1304516035.536", 1
    get_how $P6232, $P6231
    nqp_get_sc_object $P6233, "1304516035.536", 1
    .const 'Sub' $P6234 = "18_1304516047.681" 
    $P6232."add_method"($P6233, "deflongname", $P6234)
    nqp_get_sc_object $P6235, "1304516035.536", 1
    get_how $P6236, $P6235
    nqp_get_sc_object $P6237, "1304516035.536", 1
    .const 'Sub' $P6238 = "19_1304516047.681" 
    $P6236."add_method"($P6237, "!PREFIX__deflongname", $P6238)
    nqp_get_sc_object $P6239, "1304516035.536", 1
    get_how $P6240, $P6239
    nqp_get_sc_object $P6241, "1304516035.536", 1
    .const 'Sub' $P6242 = "20_1304516047.681" 
    $P6240."add_method"($P6241, "ENDSTMT", $P6242)
    nqp_get_sc_object $P6243, "1304516035.536", 1
    get_how $P6244, $P6243
    nqp_get_sc_object $P6245, "1304516035.536", 1
    .const 'Sub' $P6246 = "21_1304516047.681" 
    $P6244."add_method"($P6245, "!PREFIX__ENDSTMT", $P6246)
    nqp_get_sc_object $P6247, "1304516035.536", 1
    get_how $P6248, $P6247
    nqp_get_sc_object $P6249, "1304516035.536", 1
    .const 'Sub' $P6250 = "22_1304516047.681" 
    $P6248."add_method"($P6249, "ws", $P6250)
    nqp_get_sc_object $P6251, "1304516035.536", 1
    get_how $P6252, $P6251
    nqp_get_sc_object $P6253, "1304516035.536", 1
    .const 'Sub' $P6254 = "23_1304516047.681" 
    $P6252."add_method"($P6253, "!PREFIX__ws", $P6254)
    nqp_get_sc_object $P6255, "1304516035.536", 1
    get_how $P6256, $P6255
    nqp_get_sc_object $P6257, "1304516035.536", 1
    .const 'Sub' $P6258 = "24_1304516047.681" 
    $P6256."add_method"($P6257, "unv", $P6258)
    nqp_get_sc_object $P6259, "1304516035.536", 1
    get_how $P6260, $P6259
    nqp_get_sc_object $P6261, "1304516035.536", 1
    .const 'Sub' $P6262 = "26_1304516047.681" 
    $P6260."add_method"($P6261, "!PREFIX__unv", $P6262)
    nqp_get_sc_object $P6263, "1304516035.536", 1
    get_how $P6264, $P6263
    nqp_get_sc_object $P6265, "1304516035.536", 1
    .const 'Sub' $P6266 = "27_1304516047.681" 
    $P6264."add_method"($P6265, "pod_comment", $P6266)
    nqp_get_sc_object $P6267, "1304516035.536", 1
    get_how $P6268, $P6267
    nqp_get_sc_object $P6269, "1304516035.536", 1
    .const 'Sub' $P6270 = "29_1304516047.681" 
    $P6268."add_method"($P6269, "!PREFIX__pod_comment", $P6270)
    nqp_get_sc_object $P6271, "1304516035.536", 1
    get_how $P6272, $P6271
    nqp_get_sc_object $P6273, "1304516035.536", 1
    .const 'Sub' $P6274 = "30_1304516047.681" 
    $P6272."add_method"($P6273, "comp_unit", $P6274)
    nqp_get_sc_object $P6275, "1304516035.536", 1
    get_how $P6276, $P6275
    nqp_get_sc_object $P6277, "1304516035.536", 1
    .const 'Sub' $P6278 = "31_1304516047.681" 
    $P6276."add_method"($P6277, "!PREFIX__comp_unit", $P6278)
    nqp_get_sc_object $P6279, "1304516035.536", 1
    get_how $P6280, $P6279
    nqp_get_sc_object $P6281, "1304516035.536", 1
    .const 'Sub' $P6282 = "32_1304516047.681" 
    $P6280."add_method"($P6281, "statementlist", $P6282)
    nqp_get_sc_object $P6283, "1304516035.536", 1
    get_how $P6284, $P6283
    nqp_get_sc_object $P6285, "1304516035.536", 1
    .const 'Sub' $P6286 = "33_1304516047.681" 
    $P6284."add_method"($P6285, "!PREFIX__statementlist", $P6286)
    nqp_get_sc_object $P6287, "1304516035.536", 1
    get_how $P6288, $P6287
    nqp_get_sc_object $P6289, "1304516035.536", 1
    .const 'Sub' $P6290 = "34_1304516047.681" 
    $P6288."add_method"($P6289, "statement", $P6290)
    nqp_get_sc_object $P6291, "1304516035.536", 1
    get_how $P6292, $P6291
    nqp_get_sc_object $P6293, "1304516035.536", 1
    .const 'Sub' $P6294 = "36_1304516047.681" 
    $P6292."add_method"($P6293, "!PREFIX__statement", $P6294)
    nqp_get_sc_object $P6295, "1304516035.536", 1
    get_how $P6296, $P6295
    nqp_get_sc_object $P6297, "1304516035.536", 1
    .const 'Sub' $P6298 = "37_1304516047.681" 
    $P6296."add_method"($P6297, "eat_terminator", $P6298)
    nqp_get_sc_object $P6299, "1304516035.536", 1
    get_how $P6300, $P6299
    nqp_get_sc_object $P6301, "1304516035.536", 1
    .const 'Sub' $P6302 = "38_1304516047.681" 
    $P6300."add_method"($P6301, "!PREFIX__eat_terminator", $P6302)
    nqp_get_sc_object $P6303, "1304516035.536", 1
    get_how $P6304, $P6303
    nqp_get_sc_object $P6305, "1304516035.536", 1
    .const 'Sub' $P6306 = "39_1304516047.681" 
    $P6304."add_method"($P6305, "xblock", $P6306)
    nqp_get_sc_object $P6307, "1304516035.536", 1
    get_how $P6308, $P6307
    nqp_get_sc_object $P6309, "1304516035.536", 1
    .const 'Sub' $P6310 = "40_1304516047.681" 
    $P6308."add_method"($P6309, "!PREFIX__xblock", $P6310)
    nqp_get_sc_object $P6311, "1304516035.536", 1
    get_how $P6312, $P6311
    nqp_get_sc_object $P6313, "1304516035.536", 1
    .const 'Sub' $P6314 = "41_1304516047.681" 
    $P6312."add_method"($P6313, "pblock", $P6314)
    nqp_get_sc_object $P6315, "1304516035.536", 1
    get_how $P6316, $P6315
    nqp_get_sc_object $P6317, "1304516035.536", 1
    .const 'Sub' $P6318 = "42_1304516047.681" 
    $P6316."add_method"($P6317, "!PREFIX__pblock", $P6318)
    nqp_get_sc_object $P6319, "1304516035.536", 1
    get_how $P6320, $P6319
    nqp_get_sc_object $P6321, "1304516035.536", 1
    .const 'Sub' $P6322 = "43_1304516047.681" 
    $P6320."add_method"($P6321, "lambda", $P6322)
    nqp_get_sc_object $P6323, "1304516035.536", 1
    get_how $P6324, $P6323
    nqp_get_sc_object $P6325, "1304516035.536", 1
    .const 'Sub' $P6326 = "44_1304516047.681" 
    $P6324."add_method"($P6325, "!PREFIX__lambda", $P6326)
    nqp_get_sc_object $P6327, "1304516035.536", 1
    get_how $P6328, $P6327
    nqp_get_sc_object $P6329, "1304516035.536", 1
    .const 'Sub' $P6330 = "45_1304516047.681" 
    $P6328."add_method"($P6329, "block", $P6330)
    nqp_get_sc_object $P6331, "1304516035.536", 1
    get_how $P6332, $P6331
    nqp_get_sc_object $P6333, "1304516035.536", 1
    .const 'Sub' $P6334 = "46_1304516047.681" 
    $P6332."add_method"($P6333, "!PREFIX__block", $P6334)
    nqp_get_sc_object $P6335, "1304516035.536", 1
    get_how $P6336, $P6335
    nqp_get_sc_object $P6337, "1304516035.536", 1
    .const 'Sub' $P6338 = "47_1304516047.681" 
    $P6336."add_method"($P6337, "blockoid", $P6338)
    nqp_get_sc_object $P6339, "1304516035.536", 1
    get_how $P6340, $P6339
    nqp_get_sc_object $P6341, "1304516035.536", 1
    .const 'Sub' $P6342 = "48_1304516047.681" 
    $P6340."add_method"($P6341, "!PREFIX__blockoid", $P6342)
    nqp_get_sc_object $P6343, "1304516035.536", 1
    get_how $P6344, $P6343
    nqp_get_sc_object $P6345, "1304516035.536", 1
    .const 'Sub' $P6346 = "49_1304516047.681" 
    $P6344."add_method"($P6345, "newpad", $P6346)
    nqp_get_sc_object $P6347, "1304516035.536", 1
    get_how $P6348, $P6347
    nqp_get_sc_object $P6349, "1304516035.536", 1
    .const 'Sub' $P6350 = "50_1304516047.681" 
    $P6348."add_method"($P6349, "!PREFIX__newpad", $P6350)
    nqp_get_sc_object $P6351, "1304516035.536", 1
    get_how $P6352, $P6351
    nqp_get_sc_object $P6353, "1304516035.536", 1
    .const 'Sub' $P6354 = "51_1304516047.681" 
    $P6352."add_method"($P6353, "outerctx", $P6354)
    nqp_get_sc_object $P6355, "1304516035.536", 1
    get_how $P6356, $P6355
    nqp_get_sc_object $P6357, "1304516035.536", 1
    .const 'Sub' $P6358 = "52_1304516047.681" 
    $P6356."add_method"($P6357, "!PREFIX__outerctx", $P6358)
    nqp_get_sc_object $P6359, "1304516035.536", 1
    get_how $P6360, $P6359
    nqp_get_sc_object $P6361, "1304516035.536", 1
    .const 'Sub' $P6362 = "53_1304516047.681" 
    $P6360."add_method"($P6361, "GLOBALish", $P6362)
    nqp_get_sc_object $P6363, "1304516035.536", 1
    get_how $P6364, $P6363
    nqp_get_sc_object $P6365, "1304516035.536", 1
    .const 'Sub' $P6366 = "54_1304516047.681" 
    $P6364."add_method"($P6365, "!PREFIX__GLOBALish", $P6366)
    nqp_get_sc_object $P6367, "1304516035.536", 1
    get_how $P6368, $P6367
    nqp_get_sc_object $P6369, "1304516035.536", 1
    .const 'Sub' $P6370 = "55_1304516047.681" 
    $P6368."add_method"($P6369, "finishpad", $P6370)
    nqp_get_sc_object $P6371, "1304516035.536", 1
    get_how $P6372, $P6371
    nqp_get_sc_object $P6373, "1304516035.536", 1
    .const 'Sub' $P6374 = "56_1304516047.681" 
    $P6372."add_method"($P6373, "!PREFIX__finishpad", $P6374)
    nqp_get_sc_object $P6375, "1304516035.536", 1
    get_how $P6376, $P6375
    nqp_get_sc_object $P6377, "1304516035.536", 1
    .const 'Sub' $P6378 = "57_1304516047.681" 
    $P6376."add_method"($P6377, "you_are_here", $P6378)
    nqp_get_sc_object $P6379, "1304516035.536", 1
    get_how $P6380, $P6379
    nqp_get_sc_object $P6381, "1304516035.536", 1
    .const 'Sub' $P6382 = "58_1304516047.681" 
    $P6380."add_method"($P6381, "!PREFIX__you_are_here", $P6382)
    nqp_get_sc_object $P6383, "1304516035.536", 1
    get_how $P6384, $P6383
    nqp_get_sc_object $P6385, "1304516035.536", 1
    .const 'Sub' $P6386 = "59_1304516047.681" 
    $P6384."add_method"($P6385, "terminator", $P6386)
    nqp_get_sc_object $P6387, "1304516035.536", 1
    get_how $P6388, $P6387
    nqp_get_sc_object $P6389, "1304516035.536", 1
    .const 'Sub' $P6390 = "60_1304516047.681" 
    $P6388."add_method"($P6389, "!PREFIX__terminator", $P6390)
    nqp_get_sc_object $P6391, "1304516035.536", 1
    get_how $P6392, $P6391
    nqp_get_sc_object $P6393, "1304516035.536", 1
    .const 'Sub' $P6394 = "61_1304516047.681" 
    $P6392."add_method"($P6393, "terminator:sym<;>", $P6394)
    nqp_get_sc_object $P6395, "1304516035.536", 1
    get_how $P6396, $P6395
    nqp_get_sc_object $P6397, "1304516035.536", 1
    .const 'Sub' $P6398 = "62_1304516047.681" 
    $P6396."add_method"($P6397, "!PREFIX__terminator:sym<;>", $P6398)
    nqp_get_sc_object $P6399, "1304516035.536", 1
    get_how $P6400, $P6399
    nqp_get_sc_object $P6401, "1304516035.536", 1
    .const 'Sub' $P6402 = "63_1304516047.681" 
    $P6400."add_method"($P6401, "terminator:sym<}>", $P6402)
    nqp_get_sc_object $P6403, "1304516035.536", 1
    get_how $P6404, $P6403
    nqp_get_sc_object $P6405, "1304516035.536", 1
    .const 'Sub' $P6406 = "64_1304516047.681" 
    $P6404."add_method"($P6405, "!PREFIX__terminator:sym<}>", $P6406)
    nqp_get_sc_object $P6407, "1304516035.536", 1
    get_how $P6408, $P6407
    nqp_get_sc_object $P6409, "1304516035.536", 1
    .const 'Sub' $P6410 = "65_1304516047.681" 
    $P6408."add_method"($P6409, "statement_control", $P6410)
    nqp_get_sc_object $P6411, "1304516035.536", 1
    get_how $P6412, $P6411
    nqp_get_sc_object $P6413, "1304516035.536", 1
    .const 'Sub' $P6414 = "66_1304516047.681" 
    $P6412."add_method"($P6413, "!PREFIX__statement_control", $P6414)
    nqp_get_sc_object $P6415, "1304516035.536", 1
    get_how $P6416, $P6415
    nqp_get_sc_object $P6417, "1304516035.536", 1
    .const 'Sub' $P6418 = "67_1304516047.681" 
    $P6416."add_method"($P6417, "statement_control:sym<use>", $P6418)
    nqp_get_sc_object $P6419, "1304516035.536", 1
    get_how $P6420, $P6419
    nqp_get_sc_object $P6421, "1304516035.536", 1
    .const 'Sub' $P6422 = "68_1304516047.681" 
    $P6420."add_method"($P6421, "!PREFIX__statement_control:sym<use>", $P6422)
    nqp_get_sc_object $P6423, "1304516035.536", 1
    get_how $P6424, $P6423
    nqp_get_sc_object $P6425, "1304516035.536", 1
    .const 'Sub' $P6426 = "69_1304516047.681" 
    $P6424."add_method"($P6425, "statement_control:sym<if>", $P6426)
    nqp_get_sc_object $P6427, "1304516035.536", 1
    get_how $P6428, $P6427
    nqp_get_sc_object $P6429, "1304516035.536", 1
    .const 'Sub' $P6430 = "70_1304516047.681" 
    $P6428."add_method"($P6429, "!PREFIX__statement_control:sym<if>", $P6430)
    nqp_get_sc_object $P6431, "1304516035.536", 1
    get_how $P6432, $P6431
    nqp_get_sc_object $P6433, "1304516035.536", 1
    .const 'Sub' $P6434 = "71_1304516047.681" 
    $P6432."add_method"($P6433, "statement_control:sym<unless>", $P6434)
    nqp_get_sc_object $P6435, "1304516035.536", 1
    get_how $P6436, $P6435
    nqp_get_sc_object $P6437, "1304516035.536", 1
    .const 'Sub' $P6438 = "73_1304516047.681" 
    $P6436."add_method"($P6437, "!PREFIX__statement_control:sym<unless>", $P6438)
    nqp_get_sc_object $P6439, "1304516035.536", 1
    get_how $P6440, $P6439
    nqp_get_sc_object $P6441, "1304516035.536", 1
    .const 'Sub' $P6442 = "74_1304516047.681" 
    $P6440."add_method"($P6441, "statement_control:sym<while>", $P6442)
    nqp_get_sc_object $P6443, "1304516035.536", 1
    get_how $P6444, $P6443
    nqp_get_sc_object $P6445, "1304516035.536", 1
    .const 'Sub' $P6446 = "75_1304516047.681" 
    $P6444."add_method"($P6445, "!PREFIX__statement_control:sym<while>", $P6446)
    nqp_get_sc_object $P6447, "1304516035.536", 1
    get_how $P6448, $P6447
    nqp_get_sc_object $P6449, "1304516035.536", 1
    .const 'Sub' $P6450 = "76_1304516047.681" 
    $P6448."add_method"($P6449, "statement_control:sym<repeat>", $P6450)
    nqp_get_sc_object $P6451, "1304516035.536", 1
    get_how $P6452, $P6451
    nqp_get_sc_object $P6453, "1304516035.536", 1
    .const 'Sub' $P6454 = "77_1304516047.681" 
    $P6452."add_method"($P6453, "!PREFIX__statement_control:sym<repeat>", $P6454)
    nqp_get_sc_object $P6455, "1304516035.536", 1
    get_how $P6456, $P6455
    nqp_get_sc_object $P6457, "1304516035.536", 1
    .const 'Sub' $P6458 = "78_1304516047.681" 
    $P6456."add_method"($P6457, "statement_control:sym<for>", $P6458)
    nqp_get_sc_object $P6459, "1304516035.536", 1
    get_how $P6460, $P6459
    nqp_get_sc_object $P6461, "1304516035.536", 1
    .const 'Sub' $P6462 = "79_1304516047.681" 
    $P6460."add_method"($P6461, "!PREFIX__statement_control:sym<for>", $P6462)
    nqp_get_sc_object $P6463, "1304516035.536", 1
    get_how $P6464, $P6463
    nqp_get_sc_object $P6465, "1304516035.536", 1
    .const 'Sub' $P6466 = "80_1304516047.681" 
    $P6464."add_method"($P6465, "statement_control:sym<CATCH>", $P6466)
    nqp_get_sc_object $P6467, "1304516035.536", 1
    get_how $P6468, $P6467
    nqp_get_sc_object $P6469, "1304516035.536", 1
    .const 'Sub' $P6470 = "81_1304516047.681" 
    $P6468."add_method"($P6469, "!PREFIX__statement_control:sym<CATCH>", $P6470)
    nqp_get_sc_object $P6471, "1304516035.536", 1
    get_how $P6472, $P6471
    nqp_get_sc_object $P6473, "1304516035.536", 1
    .const 'Sub' $P6474 = "82_1304516047.681" 
    $P6472."add_method"($P6473, "statement_control:sym<CONTROL>", $P6474)
    nqp_get_sc_object $P6475, "1304516035.536", 1
    get_how $P6476, $P6475
    nqp_get_sc_object $P6477, "1304516035.536", 1
    .const 'Sub' $P6478 = "83_1304516047.681" 
    $P6476."add_method"($P6477, "!PREFIX__statement_control:sym<CONTROL>", $P6478)
    nqp_get_sc_object $P6479, "1304516035.536", 1
    get_how $P6480, $P6479
    nqp_get_sc_object $P6481, "1304516035.536", 1
    .const 'Sub' $P6482 = "84_1304516047.681" 
    $P6480."add_method"($P6481, "statement_prefix", $P6482)
    nqp_get_sc_object $P6483, "1304516035.536", 1
    get_how $P6484, $P6483
    nqp_get_sc_object $P6485, "1304516035.536", 1
    .const 'Sub' $P6486 = "85_1304516047.681" 
    $P6484."add_method"($P6485, "!PREFIX__statement_prefix", $P6486)
    nqp_get_sc_object $P6487, "1304516035.536", 1
    get_how $P6488, $P6487
    nqp_get_sc_object $P6489, "1304516035.536", 1
    .const 'Sub' $P6490 = "86_1304516047.681" 
    $P6488."add_method"($P6489, "statement_prefix:sym<INIT>", $P6490)
    nqp_get_sc_object $P6491, "1304516035.536", 1
    get_how $P6492, $P6491
    nqp_get_sc_object $P6493, "1304516035.536", 1
    .const 'Sub' $P6494 = "87_1304516047.681" 
    $P6492."add_method"($P6493, "!PREFIX__statement_prefix:sym<INIT>", $P6494)
    nqp_get_sc_object $P6495, "1304516035.536", 1
    get_how $P6496, $P6495
    nqp_get_sc_object $P6497, "1304516035.536", 1
    .const 'Sub' $P6498 = "88_1304516047.681" 
    $P6496."add_method"($P6497, "statement_prefix:sym<try>", $P6498)
    nqp_get_sc_object $P6499, "1304516035.536", 1
    get_how $P6500, $P6499
    nqp_get_sc_object $P6501, "1304516035.536", 1
    .const 'Sub' $P6502 = "89_1304516047.681" 
    $P6500."add_method"($P6501, "!PREFIX__statement_prefix:sym<try>", $P6502)
    nqp_get_sc_object $P6503, "1304516035.536", 1
    get_how $P6504, $P6503
    nqp_get_sc_object $P6505, "1304516035.536", 1
    .const 'Sub' $P6506 = "90_1304516047.681" 
    $P6504."add_method"($P6505, "blorst", $P6506)
    nqp_get_sc_object $P6507, "1304516035.536", 1
    get_how $P6508, $P6507
    nqp_get_sc_object $P6509, "1304516035.536", 1
    .const 'Sub' $P6510 = "91_1304516047.681" 
    $P6508."add_method"($P6509, "!PREFIX__blorst", $P6510)
    nqp_get_sc_object $P6511, "1304516035.536", 1
    get_how $P6512, $P6511
    nqp_get_sc_object $P6513, "1304516035.536", 1
    .const 'Sub' $P6514 = "92_1304516047.681" 
    $P6512."add_method"($P6513, "statement_mod_cond", $P6514)
    nqp_get_sc_object $P6515, "1304516035.536", 1
    get_how $P6516, $P6515
    nqp_get_sc_object $P6517, "1304516035.536", 1
    .const 'Sub' $P6518 = "93_1304516047.681" 
    $P6516."add_method"($P6517, "!PREFIX__statement_mod_cond", $P6518)
    nqp_get_sc_object $P6519, "1304516035.536", 1
    get_how $P6520, $P6519
    nqp_get_sc_object $P6521, "1304516035.536", 1
    .const 'Sub' $P6522 = "94_1304516047.681" 
    $P6520."add_method"($P6521, "statement_mod_cond:sym<if>", $P6522)
    nqp_get_sc_object $P6523, "1304516035.536", 1
    get_how $P6524, $P6523
    nqp_get_sc_object $P6525, "1304516035.536", 1
    .const 'Sub' $P6526 = "95_1304516047.681" 
    $P6524."add_method"($P6525, "!PREFIX__statement_mod_cond:sym<if>", $P6526)
    nqp_get_sc_object $P6527, "1304516035.536", 1
    get_how $P6528, $P6527
    nqp_get_sc_object $P6529, "1304516035.536", 1
    .const 'Sub' $P6530 = "96_1304516047.681" 
    $P6528."add_method"($P6529, "statement_mod_cond:sym<unless>", $P6530)
    nqp_get_sc_object $P6531, "1304516035.536", 1
    get_how $P6532, $P6531
    nqp_get_sc_object $P6533, "1304516035.536", 1
    .const 'Sub' $P6534 = "97_1304516047.681" 
    $P6532."add_method"($P6533, "!PREFIX__statement_mod_cond:sym<unless>", $P6534)
    nqp_get_sc_object $P6535, "1304516035.536", 1
    get_how $P6536, $P6535
    nqp_get_sc_object $P6537, "1304516035.536", 1
    .const 'Sub' $P6538 = "98_1304516047.681" 
    $P6536."add_method"($P6537, "statement_mod_loop", $P6538)
    nqp_get_sc_object $P6539, "1304516035.536", 1
    get_how $P6540, $P6539
    nqp_get_sc_object $P6541, "1304516035.536", 1
    .const 'Sub' $P6542 = "99_1304516047.681" 
    $P6540."add_method"($P6541, "!PREFIX__statement_mod_loop", $P6542)
    nqp_get_sc_object $P6543, "1304516035.536", 1
    get_how $P6544, $P6543
    nqp_get_sc_object $P6545, "1304516035.536", 1
    .const 'Sub' $P6546 = "100_1304516047.681" 
    $P6544."add_method"($P6545, "statement_mod_loop:sym<while>", $P6546)
    nqp_get_sc_object $P6547, "1304516035.536", 1
    get_how $P6548, $P6547
    nqp_get_sc_object $P6549, "1304516035.536", 1
    .const 'Sub' $P6550 = "101_1304516047.681" 
    $P6548."add_method"($P6549, "!PREFIX__statement_mod_loop:sym<while>", $P6550)
    nqp_get_sc_object $P6551, "1304516035.536", 1
    get_how $P6552, $P6551
    nqp_get_sc_object $P6553, "1304516035.536", 1
    .const 'Sub' $P6554 = "102_1304516047.681" 
    $P6552."add_method"($P6553, "statement_mod_loop:sym<until>", $P6554)
    nqp_get_sc_object $P6555, "1304516035.536", 1
    get_how $P6556, $P6555
    nqp_get_sc_object $P6557, "1304516035.536", 1
    .const 'Sub' $P6558 = "103_1304516047.681" 
    $P6556."add_method"($P6557, "!PREFIX__statement_mod_loop:sym<until>", $P6558)
    nqp_get_sc_object $P6559, "1304516035.536", 1
    get_how $P6560, $P6559
    nqp_get_sc_object $P6561, "1304516035.536", 1
    .const 'Sub' $P6562 = "104_1304516047.681" 
    $P6560."add_method"($P6561, "statement_mod_loop:sym<for>", $P6562)
    nqp_get_sc_object $P6563, "1304516035.536", 1
    get_how $P6564, $P6563
    nqp_get_sc_object $P6565, "1304516035.536", 1
    .const 'Sub' $P6566 = "105_1304516047.681" 
    $P6564."add_method"($P6565, "!PREFIX__statement_mod_loop:sym<for>", $P6566)
    nqp_get_sc_object $P6567, "1304516035.536", 1
    get_how $P6568, $P6567
    nqp_get_sc_object $P6569, "1304516035.536", 1
    .const 'Sub' $P6570 = "106_1304516047.681" 
    $P6568."add_method"($P6569, "term:sym<fatarrow>", $P6570)
    nqp_get_sc_object $P6571, "1304516035.536", 1
    get_how $P6572, $P6571
    nqp_get_sc_object $P6573, "1304516035.536", 1
    .const 'Sub' $P6574 = "107_1304516047.681" 
    $P6572."add_method"($P6573, "!PREFIX__term:sym<fatarrow>", $P6574)
    nqp_get_sc_object $P6575, "1304516035.536", 1
    get_how $P6576, $P6575
    nqp_get_sc_object $P6577, "1304516035.536", 1
    .const 'Sub' $P6578 = "108_1304516047.681" 
    $P6576."add_method"($P6577, "term:sym<colonpair>", $P6578)
    nqp_get_sc_object $P6579, "1304516035.536", 1
    get_how $P6580, $P6579
    nqp_get_sc_object $P6581, "1304516035.536", 1
    .const 'Sub' $P6582 = "109_1304516047.681" 
    $P6580."add_method"($P6581, "!PREFIX__term:sym<colonpair>", $P6582)
    nqp_get_sc_object $P6583, "1304516035.536", 1
    get_how $P6584, $P6583
    nqp_get_sc_object $P6585, "1304516035.536", 1
    .const 'Sub' $P6586 = "110_1304516047.681" 
    $P6584."add_method"($P6585, "term:sym<variable>", $P6586)
    nqp_get_sc_object $P6587, "1304516035.536", 1
    get_how $P6588, $P6587
    nqp_get_sc_object $P6589, "1304516035.536", 1
    .const 'Sub' $P6590 = "111_1304516047.681" 
    $P6588."add_method"($P6589, "!PREFIX__term:sym<variable>", $P6590)
    nqp_get_sc_object $P6591, "1304516035.536", 1
    get_how $P6592, $P6591
    nqp_get_sc_object $P6593, "1304516035.536", 1
    .const 'Sub' $P6594 = "112_1304516047.681" 
    $P6592."add_method"($P6593, "term:sym<package_declarator>", $P6594)
    nqp_get_sc_object $P6595, "1304516035.536", 1
    get_how $P6596, $P6595
    nqp_get_sc_object $P6597, "1304516035.536", 1
    .const 'Sub' $P6598 = "113_1304516047.681" 
    $P6596."add_method"($P6597, "!PREFIX__term:sym<package_declarator>", $P6598)
    nqp_get_sc_object $P6599, "1304516035.536", 1
    get_how $P6600, $P6599
    nqp_get_sc_object $P6601, "1304516035.536", 1
    .const 'Sub' $P6602 = "114_1304516047.681" 
    $P6600."add_method"($P6601, "term:sym<scope_declarator>", $P6602)
    nqp_get_sc_object $P6603, "1304516035.536", 1
    get_how $P6604, $P6603
    nqp_get_sc_object $P6605, "1304516035.536", 1
    .const 'Sub' $P6606 = "115_1304516047.681" 
    $P6604."add_method"($P6605, "!PREFIX__term:sym<scope_declarator>", $P6606)
    nqp_get_sc_object $P6607, "1304516035.536", 1
    get_how $P6608, $P6607
    nqp_get_sc_object $P6609, "1304516035.536", 1
    .const 'Sub' $P6610 = "116_1304516047.681" 
    $P6608."add_method"($P6609, "term:sym<routine_declarator>", $P6610)
    nqp_get_sc_object $P6611, "1304516035.536", 1
    get_how $P6612, $P6611
    nqp_get_sc_object $P6613, "1304516035.536", 1
    .const 'Sub' $P6614 = "117_1304516047.681" 
    $P6612."add_method"($P6613, "!PREFIX__term:sym<routine_declarator>", $P6614)
    nqp_get_sc_object $P6615, "1304516035.536", 1
    get_how $P6616, $P6615
    nqp_get_sc_object $P6617, "1304516035.536", 1
    .const 'Sub' $P6618 = "118_1304516047.681" 
    $P6616."add_method"($P6617, "term:sym<multi_declarator>", $P6618)
    nqp_get_sc_object $P6619, "1304516035.536", 1
    get_how $P6620, $P6619
    nqp_get_sc_object $P6621, "1304516035.536", 1
    .const 'Sub' $P6622 = "121_1304516047.681" 
    $P6620."add_method"($P6621, "!PREFIX__term:sym<multi_declarator>", $P6622)
    nqp_get_sc_object $P6623, "1304516035.536", 1
    get_how $P6624, $P6623
    nqp_get_sc_object $P6625, "1304516035.536", 1
    .const 'Sub' $P6626 = "122_1304516047.681" 
    $P6624."add_method"($P6625, "term:sym<regex_declarator>", $P6626)
    nqp_get_sc_object $P6627, "1304516035.536", 1
    get_how $P6628, $P6627
    nqp_get_sc_object $P6629, "1304516035.536", 1
    .const 'Sub' $P6630 = "123_1304516047.681" 
    $P6628."add_method"($P6629, "!PREFIX__term:sym<regex_declarator>", $P6630)
    nqp_get_sc_object $P6631, "1304516035.536", 1
    get_how $P6632, $P6631
    nqp_get_sc_object $P6633, "1304516035.536", 1
    .const 'Sub' $P6634 = "124_1304516047.681" 
    $P6632."add_method"($P6633, "term:sym<statement_prefix>", $P6634)
    nqp_get_sc_object $P6635, "1304516035.536", 1
    get_how $P6636, $P6635
    nqp_get_sc_object $P6637, "1304516035.536", 1
    .const 'Sub' $P6638 = "125_1304516047.681" 
    $P6636."add_method"($P6637, "!PREFIX__term:sym<statement_prefix>", $P6638)
    nqp_get_sc_object $P6639, "1304516035.536", 1
    get_how $P6640, $P6639
    nqp_get_sc_object $P6641, "1304516035.536", 1
    .const 'Sub' $P6642 = "126_1304516047.681" 
    $P6640."add_method"($P6641, "term:sym<lambda>", $P6642)
    nqp_get_sc_object $P6643, "1304516035.536", 1
    get_how $P6644, $P6643
    nqp_get_sc_object $P6645, "1304516035.536", 1
    .const 'Sub' $P6646 = "127_1304516047.681" 
    $P6644."add_method"($P6645, "!PREFIX__term:sym<lambda>", $P6646)
    nqp_get_sc_object $P6647, "1304516035.536", 1
    get_how $P6648, $P6647
    nqp_get_sc_object $P6649, "1304516035.536", 1
    .const 'Sub' $P6650 = "128_1304516047.681" 
    $P6648."add_method"($P6649, "fatarrow", $P6650)
    nqp_get_sc_object $P6651, "1304516035.536", 1
    get_how $P6652, $P6651
    nqp_get_sc_object $P6653, "1304516035.536", 1
    .const 'Sub' $P6654 = "129_1304516047.681" 
    $P6652."add_method"($P6653, "!PREFIX__fatarrow", $P6654)
    nqp_get_sc_object $P6655, "1304516035.536", 1
    get_how $P6656, $P6655
    nqp_get_sc_object $P6657, "1304516035.536", 1
    .const 'Sub' $P6658 = "130_1304516047.681" 
    $P6656."add_method"($P6657, "colonpair", $P6658)
    nqp_get_sc_object $P6659, "1304516035.536", 1
    get_how $P6660, $P6659
    nqp_get_sc_object $P6661, "1304516035.536", 1
    .const 'Sub' $P6662 = "131_1304516047.681" 
    $P6660."add_method"($P6661, "!PREFIX__colonpair", $P6662)
    nqp_get_sc_object $P6663, "1304516035.536", 1
    get_how $P6664, $P6663
    nqp_get_sc_object $P6665, "1304516035.536", 1
    .const 'Sub' $P6666 = "132_1304516047.681" 
    $P6664."add_method"($P6665, "variable", $P6666)
    nqp_get_sc_object $P6667, "1304516035.536", 1
    get_how $P6668, $P6667
    nqp_get_sc_object $P6669, "1304516035.536", 1
    .const 'Sub' $P6670 = "133_1304516047.681" 
    $P6668."add_method"($P6669, "!PREFIX__variable", $P6670)
    nqp_get_sc_object $P6671, "1304516035.536", 1
    get_how $P6672, $P6671
    nqp_get_sc_object $P6673, "1304516035.536", 1
    .const 'Sub' $P6674 = "134_1304516047.681" 
    $P6672."add_method"($P6673, "sigil", $P6674)
    nqp_get_sc_object $P6675, "1304516035.536", 1
    get_how $P6676, $P6675
    nqp_get_sc_object $P6677, "1304516035.536", 1
    .const 'Sub' $P6678 = "135_1304516047.681" 
    $P6676."add_method"($P6677, "!PREFIX__sigil", $P6678)
    nqp_get_sc_object $P6679, "1304516035.536", 1
    get_how $P6680, $P6679
    nqp_get_sc_object $P6681, "1304516035.536", 1
    .const 'Sub' $P6682 = "136_1304516047.681" 
    $P6680."add_method"($P6681, "twigil", $P6682)
    nqp_get_sc_object $P6683, "1304516035.536", 1
    get_how $P6684, $P6683
    nqp_get_sc_object $P6685, "1304516035.536", 1
    .const 'Sub' $P6686 = "137_1304516047.681" 
    $P6684."add_method"($P6685, "!PREFIX__twigil", $P6686)
    nqp_get_sc_object $P6687, "1304516035.536", 1
    get_how $P6688, $P6687
    nqp_get_sc_object $P6689, "1304516035.536", 1
    .const 'Sub' $P6690 = "138_1304516047.681" 
    $P6688."add_method"($P6689, "package_declarator", $P6690)
    nqp_get_sc_object $P6691, "1304516035.536", 1
    get_how $P6692, $P6691
    nqp_get_sc_object $P6693, "1304516035.536", 1
    .const 'Sub' $P6694 = "139_1304516047.681" 
    $P6692."add_method"($P6693, "!PREFIX__package_declarator", $P6694)
    nqp_get_sc_object $P6695, "1304516035.536", 1
    get_how $P6696, $P6695
    nqp_get_sc_object $P6697, "1304516035.536", 1
    .const 'Sub' $P6698 = "140_1304516047.681" 
    $P6696."add_method"($P6697, "package_declarator:sym<module>", $P6698)
    nqp_get_sc_object $P6699, "1304516035.536", 1
    get_how $P6700, $P6699
    nqp_get_sc_object $P6701, "1304516035.536", 1
    .const 'Sub' $P6702 = "141_1304516047.681" 
    $P6700."add_method"($P6701, "!PREFIX__package_declarator:sym<module>", $P6702)
    nqp_get_sc_object $P6703, "1304516035.536", 1
    get_how $P6704, $P6703
    nqp_get_sc_object $P6705, "1304516035.536", 1
    .const 'Sub' $P6706 = "142_1304516047.681" 
    $P6704."add_method"($P6705, "package_declarator:sym<knowhow>", $P6706)
    nqp_get_sc_object $P6707, "1304516035.536", 1
    get_how $P6708, $P6707
    nqp_get_sc_object $P6709, "1304516035.536", 1
    .const 'Sub' $P6710 = "143_1304516047.681" 
    $P6708."add_method"($P6709, "!PREFIX__package_declarator:sym<knowhow>", $P6710)
    nqp_get_sc_object $P6711, "1304516035.536", 1
    get_how $P6712, $P6711
    nqp_get_sc_object $P6713, "1304516035.536", 1
    .const 'Sub' $P6714 = "144_1304516047.681" 
    $P6712."add_method"($P6713, "package_declarator:sym<class>", $P6714)
    nqp_get_sc_object $P6715, "1304516035.536", 1
    get_how $P6716, $P6715
    nqp_get_sc_object $P6717, "1304516035.536", 1
    .const 'Sub' $P6718 = "145_1304516047.681" 
    $P6716."add_method"($P6717, "!PREFIX__package_declarator:sym<class>", $P6718)
    nqp_get_sc_object $P6719, "1304516035.536", 1
    get_how $P6720, $P6719
    nqp_get_sc_object $P6721, "1304516035.536", 1
    .const 'Sub' $P6722 = "146_1304516047.681" 
    $P6720."add_method"($P6721, "package_declarator:sym<grammar>", $P6722)
    nqp_get_sc_object $P6723, "1304516035.536", 1
    get_how $P6724, $P6723
    nqp_get_sc_object $P6725, "1304516035.536", 1
    .const 'Sub' $P6726 = "147_1304516047.681" 
    $P6724."add_method"($P6725, "!PREFIX__package_declarator:sym<grammar>", $P6726)
    nqp_get_sc_object $P6727, "1304516035.536", 1
    get_how $P6728, $P6727
    nqp_get_sc_object $P6729, "1304516035.536", 1
    .const 'Sub' $P6730 = "148_1304516047.681" 
    $P6728."add_method"($P6729, "package_declarator:sym<role>", $P6730)
    nqp_get_sc_object $P6731, "1304516035.536", 1
    get_how $P6732, $P6731
    nqp_get_sc_object $P6733, "1304516035.536", 1
    .const 'Sub' $P6734 = "149_1304516047.681" 
    $P6732."add_method"($P6733, "!PREFIX__package_declarator:sym<role>", $P6734)
    nqp_get_sc_object $P6735, "1304516035.536", 1
    get_how $P6736, $P6735
    nqp_get_sc_object $P6737, "1304516035.536", 1
    .const 'Sub' $P6738 = "150_1304516047.681" 
    $P6736."add_method"($P6737, "package_declarator:sym<native>", $P6738)
    nqp_get_sc_object $P6739, "1304516035.536", 1
    get_how $P6740, $P6739
    nqp_get_sc_object $P6741, "1304516035.536", 1
    .const 'Sub' $P6742 = "151_1304516047.681" 
    $P6740."add_method"($P6741, "!PREFIX__package_declarator:sym<native>", $P6742)
    nqp_get_sc_object $P6743, "1304516035.536", 1
    get_how $P6744, $P6743
    nqp_get_sc_object $P6745, "1304516035.536", 1
    .const 'Sub' $P6746 = "152_1304516047.681" 
    $P6744."add_method"($P6745, "package_def", $P6746)
    nqp_get_sc_object $P6747, "1304516035.536", 1
    get_how $P6748, $P6747
    nqp_get_sc_object $P6749, "1304516035.536", 1
    .const 'Sub' $P6750 = "154_1304516047.681" 
    $P6748."add_method"($P6749, "!PREFIX__package_def", $P6750)
    nqp_get_sc_object $P6751, "1304516035.536", 1
    get_how $P6752, $P6751
    nqp_get_sc_object $P6753, "1304516035.536", 1
    .const 'Sub' $P6754 = "155_1304516047.681" 
    $P6752."add_method"($P6753, "scope_declarator", $P6754)
    nqp_get_sc_object $P6755, "1304516035.536", 1
    get_how $P6756, $P6755
    nqp_get_sc_object $P6757, "1304516035.536", 1
    .const 'Sub' $P6758 = "156_1304516047.681" 
    $P6756."add_method"($P6757, "!PREFIX__scope_declarator", $P6758)
    nqp_get_sc_object $P6759, "1304516035.536", 1
    get_how $P6760, $P6759
    nqp_get_sc_object $P6761, "1304516035.536", 1
    .const 'Sub' $P6762 = "157_1304516047.681" 
    $P6760."add_method"($P6761, "scope_declarator:sym<my>", $P6762)
    nqp_get_sc_object $P6763, "1304516035.536", 1
    get_how $P6764, $P6763
    nqp_get_sc_object $P6765, "1304516035.536", 1
    .const 'Sub' $P6766 = "158_1304516047.681" 
    $P6764."add_method"($P6765, "!PREFIX__scope_declarator:sym<my>", $P6766)
    nqp_get_sc_object $P6767, "1304516035.536", 1
    get_how $P6768, $P6767
    nqp_get_sc_object $P6769, "1304516035.536", 1
    .const 'Sub' $P6770 = "159_1304516047.681" 
    $P6768."add_method"($P6769, "scope_declarator:sym<our>", $P6770)
    nqp_get_sc_object $P6771, "1304516035.536", 1
    get_how $P6772, $P6771
    nqp_get_sc_object $P6773, "1304516035.536", 1
    .const 'Sub' $P6774 = "160_1304516047.681" 
    $P6772."add_method"($P6773, "!PREFIX__scope_declarator:sym<our>", $P6774)
    nqp_get_sc_object $P6775, "1304516035.536", 1
    get_how $P6776, $P6775
    nqp_get_sc_object $P6777, "1304516035.536", 1
    .const 'Sub' $P6778 = "161_1304516047.681" 
    $P6776."add_method"($P6777, "scope_declarator:sym<has>", $P6778)
    nqp_get_sc_object $P6779, "1304516035.536", 1
    get_how $P6780, $P6779
    nqp_get_sc_object $P6781, "1304516035.536", 1
    .const 'Sub' $P6782 = "162_1304516047.681" 
    $P6780."add_method"($P6781, "!PREFIX__scope_declarator:sym<has>", $P6782)
    nqp_get_sc_object $P6783, "1304516035.536", 1
    get_how $P6784, $P6783
    nqp_get_sc_object $P6785, "1304516035.536", 1
    .const 'Sub' $P6786 = "163_1304516047.681" 
    $P6784."add_method"($P6785, "scoped", $P6786)
    nqp_get_sc_object $P6787, "1304516035.536", 1
    get_how $P6788, $P6787
    nqp_get_sc_object $P6789, "1304516035.536", 1
    .const 'Sub' $P6790 = "164_1304516047.681" 
    $P6788."add_method"($P6789, "!PREFIX__scoped", $P6790)
    nqp_get_sc_object $P6791, "1304516035.536", 1
    get_how $P6792, $P6791
    nqp_get_sc_object $P6793, "1304516035.536", 1
    .const 'Sub' $P6794 = "165_1304516047.681" 
    $P6792."add_method"($P6793, "typename", $P6794)
    nqp_get_sc_object $P6795, "1304516035.536", 1
    get_how $P6796, $P6795
    nqp_get_sc_object $P6797, "1304516035.536", 1
    .const 'Sub' $P6798 = "167_1304516047.681" 
    $P6796."add_method"($P6797, "!PREFIX__typename", $P6798)
    nqp_get_sc_object $P6799, "1304516035.536", 1
    get_how $P6800, $P6799
    nqp_get_sc_object $P6801, "1304516035.536", 1
    .const 'Sub' $P6802 = "168_1304516047.681" 
    $P6800."add_method"($P6801, "declarator", $P6802)
    nqp_get_sc_object $P6803, "1304516035.536", 1
    get_how $P6804, $P6803
    nqp_get_sc_object $P6805, "1304516035.536", 1
    .const 'Sub' $P6806 = "169_1304516047.681" 
    $P6804."add_method"($P6805, "!PREFIX__declarator", $P6806)
    nqp_get_sc_object $P6807, "1304516035.536", 1
    get_how $P6808, $P6807
    nqp_get_sc_object $P6809, "1304516035.536", 1
    .const 'Sub' $P6810 = "170_1304516047.681" 
    $P6808."add_method"($P6809, "variable_declarator", $P6810)
    nqp_get_sc_object $P6811, "1304516035.536", 1
    get_how $P6812, $P6811
    nqp_get_sc_object $P6813, "1304516035.536", 1
    .const 'Sub' $P6814 = "172_1304516047.681" 
    $P6812."add_method"($P6813, "!PREFIX__variable_declarator", $P6814)
    nqp_get_sc_object $P6815, "1304516035.536", 1
    get_how $P6816, $P6815
    nqp_get_sc_object $P6817, "1304516035.536", 1
    .const 'Sub' $P6818 = "173_1304516047.681" 
    $P6816."add_method"($P6817, "routine_declarator", $P6818)
    nqp_get_sc_object $P6819, "1304516035.536", 1
    get_how $P6820, $P6819
    nqp_get_sc_object $P6821, "1304516035.536", 1
    .const 'Sub' $P6822 = "174_1304516047.681" 
    $P6820."add_method"($P6821, "!PREFIX__routine_declarator", $P6822)
    nqp_get_sc_object $P6823, "1304516035.536", 1
    get_how $P6824, $P6823
    nqp_get_sc_object $P6825, "1304516035.536", 1
    .const 'Sub' $P6826 = "175_1304516047.681" 
    $P6824."add_method"($P6825, "routine_declarator:sym<sub>", $P6826)
    nqp_get_sc_object $P6827, "1304516035.536", 1
    get_how $P6828, $P6827
    nqp_get_sc_object $P6829, "1304516035.536", 1
    .const 'Sub' $P6830 = "176_1304516047.681" 
    $P6828."add_method"($P6829, "!PREFIX__routine_declarator:sym<sub>", $P6830)
    nqp_get_sc_object $P6831, "1304516035.536", 1
    get_how $P6832, $P6831
    nqp_get_sc_object $P6833, "1304516035.536", 1
    .const 'Sub' $P6834 = "177_1304516047.681" 
    $P6832."add_method"($P6833, "routine_declarator:sym<method>", $P6834)
    nqp_get_sc_object $P6835, "1304516035.536", 1
    get_how $P6836, $P6835
    nqp_get_sc_object $P6837, "1304516035.536", 1
    .const 'Sub' $P6838 = "178_1304516047.681" 
    $P6836."add_method"($P6837, "!PREFIX__routine_declarator:sym<method>", $P6838)
    nqp_get_sc_object $P6839, "1304516035.536", 1
    get_how $P6840, $P6839
    nqp_get_sc_object $P6841, "1304516035.536", 1
    .const 'Sub' $P6842 = "179_1304516047.681" 
    $P6840."add_method"($P6841, "routine_def", $P6842)
    nqp_get_sc_object $P6843, "1304516035.536", 1
    get_how $P6844, $P6843
    nqp_get_sc_object $P6845, "1304516035.536", 1
    .const 'Sub' $P6846 = "180_1304516047.681" 
    $P6844."add_method"($P6845, "!PREFIX__routine_def", $P6846)
    nqp_get_sc_object $P6847, "1304516035.536", 1
    get_how $P6848, $P6847
    nqp_get_sc_object $P6849, "1304516035.536", 1
    .const 'Sub' $P6850 = "181_1304516047.681" 
    $P6848."add_method"($P6849, "method_def", $P6850)
    nqp_get_sc_object $P6851, "1304516035.536", 1
    get_how $P6852, $P6851
    nqp_get_sc_object $P6853, "1304516035.536", 1
    .const 'Sub' $P6854 = "183_1304516047.681" 
    $P6852."add_method"($P6853, "!PREFIX__method_def", $P6854)
    nqp_get_sc_object $P6855, "1304516035.536", 1
    get_how $P6856, $P6855
    nqp_get_sc_object $P6857, "1304516035.536", 1
    .const 'Sub' $P6858 = "184_1304516047.681" 
    $P6856."add_method"($P6857, "onlystar", $P6858)
    nqp_get_sc_object $P6859, "1304516035.536", 1
    get_how $P6860, $P6859
    nqp_get_sc_object $P6861, "1304516035.536", 1
    .const 'Sub' $P6862 = "186_1304516047.681" 
    $P6860."add_method"($P6861, "!PREFIX__onlystar", $P6862)
    nqp_get_sc_object $P6863, "1304516035.536", 1
    get_how $P6864, $P6863
    nqp_get_sc_object $P6865, "1304516035.536", 1
    .const 'Sub' $P6866 = "187_1304516047.681" 
    $P6864."add_method"($P6865, "multi_declarator", $P6866)
    nqp_get_sc_object $P6867, "1304516035.536", 1
    get_how $P6868, $P6867
    nqp_get_sc_object $P6869, "1304516035.536", 1
    .const 'Sub' $P6870 = "188_1304516047.681" 
    $P6868."add_method"($P6869, "!PREFIX__multi_declarator", $P6870)
    nqp_get_sc_object $P6871, "1304516035.536", 1
    get_how $P6872, $P6871
    nqp_get_sc_object $P6873, "1304516035.536", 1
    .const 'Sub' $P6874 = "189_1304516047.681" 
    $P6872."add_method"($P6873, "multi_declarator:sym<multi>", $P6874)
    nqp_get_sc_object $P6875, "1304516035.536", 1
    get_how $P6876, $P6875
    nqp_get_sc_object $P6877, "1304516035.536", 1
    .const 'Sub' $P6878 = "190_1304516047.681" 
    $P6876."add_method"($P6877, "!PREFIX__multi_declarator:sym<multi>", $P6878)
    nqp_get_sc_object $P6879, "1304516035.536", 1
    get_how $P6880, $P6879
    nqp_get_sc_object $P6881, "1304516035.536", 1
    .const 'Sub' $P6882 = "191_1304516047.681" 
    $P6880."add_method"($P6881, "multi_declarator:sym<proto>", $P6882)
    nqp_get_sc_object $P6883, "1304516035.536", 1
    get_how $P6884, $P6883
    nqp_get_sc_object $P6885, "1304516035.536", 1
    .const 'Sub' $P6886 = "192_1304516047.681" 
    $P6884."add_method"($P6885, "!PREFIX__multi_declarator:sym<proto>", $P6886)
    nqp_get_sc_object $P6887, "1304516035.536", 1
    get_how $P6888, $P6887
    nqp_get_sc_object $P6889, "1304516035.536", 1
    .const 'Sub' $P6890 = "193_1304516047.681" 
    $P6888."add_method"($P6889, "multi_declarator:sym<null>", $P6890)
    nqp_get_sc_object $P6891, "1304516035.536", 1
    get_how $P6892, $P6891
    nqp_get_sc_object $P6893, "1304516035.536", 1
    .const 'Sub' $P6894 = "194_1304516047.681" 
    $P6892."add_method"($P6893, "!PREFIX__multi_declarator:sym<null>", $P6894)
    nqp_get_sc_object $P6895, "1304516035.536", 1
    get_how $P6896, $P6895
    nqp_get_sc_object $P6897, "1304516035.536", 1
    .const 'Sub' $P6898 = "195_1304516047.681" 
    $P6896."add_method"($P6897, "signature", $P6898)
    nqp_get_sc_object $P6899, "1304516035.536", 1
    get_how $P6900, $P6899
    nqp_get_sc_object $P6901, "1304516035.536", 1
    .const 'Sub' $P6902 = "197_1304516047.681" 
    $P6900."add_method"($P6901, "!PREFIX__signature", $P6902)
    nqp_get_sc_object $P6903, "1304516035.536", 1
    get_how $P6904, $P6903
    nqp_get_sc_object $P6905, "1304516035.536", 1
    .const 'Sub' $P6906 = "198_1304516047.681" 
    $P6904."add_method"($P6905, "parameter", $P6906)
    nqp_get_sc_object $P6907, "1304516035.536", 1
    get_how $P6908, $P6907
    nqp_get_sc_object $P6909, "1304516035.536", 1
    .const 'Sub' $P6910 = "199_1304516047.681" 
    $P6908."add_method"($P6909, "!PREFIX__parameter", $P6910)
    nqp_get_sc_object $P6911, "1304516035.536", 1
    get_how $P6912, $P6911
    nqp_get_sc_object $P6913, "1304516035.536", 1
    .const 'Sub' $P6914 = "200_1304516047.681" 
    $P6912."add_method"($P6913, "param_var", $P6914)
    nqp_get_sc_object $P6915, "1304516035.536", 1
    get_how $P6916, $P6915
    nqp_get_sc_object $P6917, "1304516035.536", 1
    .const 'Sub' $P6918 = "201_1304516047.681" 
    $P6916."add_method"($P6917, "!PREFIX__param_var", $P6918)
    nqp_get_sc_object $P6919, "1304516035.536", 1
    get_how $P6920, $P6919
    nqp_get_sc_object $P6921, "1304516035.536", 1
    .const 'Sub' $P6922 = "202_1304516047.681" 
    $P6920."add_method"($P6921, "named_param", $P6922)
    nqp_get_sc_object $P6923, "1304516035.536", 1
    get_how $P6924, $P6923
    nqp_get_sc_object $P6925, "1304516035.536", 1
    .const 'Sub' $P6926 = "203_1304516047.681" 
    $P6924."add_method"($P6925, "!PREFIX__named_param", $P6926)
    nqp_get_sc_object $P6927, "1304516035.536", 1
    get_how $P6928, $P6927
    nqp_get_sc_object $P6929, "1304516035.536", 1
    .const 'Sub' $P6930 = "204_1304516047.681" 
    $P6928."add_method"($P6929, "default_value", $P6930)
    nqp_get_sc_object $P6931, "1304516035.536", 1
    get_how $P6932, $P6931
    nqp_get_sc_object $P6933, "1304516035.536", 1
    .const 'Sub' $P6934 = "205_1304516047.681" 
    $P6932."add_method"($P6933, "!PREFIX__default_value", $P6934)
    nqp_get_sc_object $P6935, "1304516035.536", 1
    get_how $P6936, $P6935
    nqp_get_sc_object $P6937, "1304516035.536", 1
    .const 'Sub' $P6938 = "206_1304516047.681" 
    $P6936."add_method"($P6937, "trait", $P6938)
    nqp_get_sc_object $P6939, "1304516035.536", 1
    get_how $P6940, $P6939
    nqp_get_sc_object $P6941, "1304516035.536", 1
    .const 'Sub' $P6942 = "207_1304516047.681" 
    $P6940."add_method"($P6941, "!PREFIX__trait", $P6942)
    nqp_get_sc_object $P6943, "1304516035.536", 1
    get_how $P6944, $P6943
    nqp_get_sc_object $P6945, "1304516035.536", 1
    .const 'Sub' $P6946 = "208_1304516047.681" 
    $P6944."add_method"($P6945, "trait_mod", $P6946)
    nqp_get_sc_object $P6947, "1304516035.536", 1
    get_how $P6948, $P6947
    nqp_get_sc_object $P6949, "1304516035.536", 1
    .const 'Sub' $P6950 = "209_1304516047.681" 
    $P6948."add_method"($P6949, "!PREFIX__trait_mod", $P6950)
    nqp_get_sc_object $P6951, "1304516035.536", 1
    get_how $P6952, $P6951
    nqp_get_sc_object $P6953, "1304516035.536", 1
    .const 'Sub' $P6954 = "210_1304516047.681" 
    $P6952."add_method"($P6953, "trait_mod:sym<is>", $P6954)
    nqp_get_sc_object $P6955, "1304516035.536", 1
    get_how $P6956, $P6955
    nqp_get_sc_object $P6957, "1304516035.536", 1
    .const 'Sub' $P6958 = "211_1304516047.681" 
    $P6956."add_method"($P6957, "!PREFIX__trait_mod:sym<is>", $P6958)
    nqp_get_sc_object $P6959, "1304516035.536", 1
    get_how $P6960, $P6959
    nqp_get_sc_object $P6961, "1304516035.536", 1
    .const 'Sub' $P6962 = "212_1304516047.681" 
    $P6960."add_method"($P6961, "regex_declarator", $P6962)
    nqp_get_sc_object $P6963, "1304516035.536", 1
    get_how $P6964, $P6963
    nqp_get_sc_object $P6965, "1304516035.536", 1
    .const 'Sub' $P6966 = "213_1304516047.681" 
    $P6964."add_method"($P6965, "!PREFIX__regex_declarator", $P6966)
    nqp_get_sc_object $P6967, "1304516035.536", 1
    get_how $P6968, $P6967
    nqp_get_sc_object $P6969, "1304516035.536", 1
    .const 'Sub' $P6970 = "214_1304516047.681" 
    $P6968."add_method"($P6969, "dotty", $P6970)
    nqp_get_sc_object $P6971, "1304516035.536", 1
    get_how $P6972, $P6971
    nqp_get_sc_object $P6973, "1304516035.536", 1
    .const 'Sub' $P6974 = "215_1304516047.681" 
    $P6972."add_method"($P6973, "!PREFIX__dotty", $P6974)
    nqp_get_sc_object $P6975, "1304516035.536", 1
    get_how $P6976, $P6975
    nqp_get_sc_object $P6977, "1304516035.536", 1
    .const 'Sub' $P6978 = "216_1304516047.681" 
    $P6976."add_method"($P6977, "term", $P6978)
    nqp_get_sc_object $P6979, "1304516035.536", 1
    get_how $P6980, $P6979
    nqp_get_sc_object $P6981, "1304516035.536", 1
    .const 'Sub' $P6982 = "217_1304516047.681" 
    $P6980."add_method"($P6981, "!PREFIX__term", $P6982)
    nqp_get_sc_object $P6983, "1304516035.536", 1
    get_how $P6984, $P6983
    nqp_get_sc_object $P6985, "1304516035.536", 1
    .const 'Sub' $P6986 = "218_1304516047.681" 
    $P6984."add_method"($P6985, "term:sym<self>", $P6986)
    nqp_get_sc_object $P6987, "1304516035.536", 1
    get_how $P6988, $P6987
    nqp_get_sc_object $P6989, "1304516035.536", 1
    .const 'Sub' $P6990 = "219_1304516047.681" 
    $P6988."add_method"($P6989, "!PREFIX__term:sym<self>", $P6990)
    nqp_get_sc_object $P6991, "1304516035.536", 1
    get_how $P6992, $P6991
    nqp_get_sc_object $P6993, "1304516035.536", 1
    .const 'Sub' $P6994 = "220_1304516047.681" 
    $P6992."add_method"($P6993, "term:sym<identifier>", $P6994)
    nqp_get_sc_object $P6995, "1304516035.536", 1
    get_how $P6996, $P6995
    nqp_get_sc_object $P6997, "1304516035.536", 1
    .const 'Sub' $P6998 = "221_1304516047.681" 
    $P6996."add_method"($P6997, "!PREFIX__term:sym<identifier>", $P6998)
    nqp_get_sc_object $P6999, "1304516035.536", 1
    get_how $P7000, $P6999
    nqp_get_sc_object $P7001, "1304516035.536", 1
    .const 'Sub' $P7002 = "222_1304516047.681" 
    $P7000."add_method"($P7001, "term:sym<name>", $P7002)
    nqp_get_sc_object $P7003, "1304516035.536", 1
    get_how $P7004, $P7003
    nqp_get_sc_object $P7005, "1304516035.536", 1
    .const 'Sub' $P7006 = "223_1304516047.681" 
    $P7004."add_method"($P7005, "!PREFIX__term:sym<name>", $P7006)
    nqp_get_sc_object $P7007, "1304516035.536", 1
    get_how $P7008, $P7007
    nqp_get_sc_object $P7009, "1304516035.536", 1
    .const 'Sub' $P7010 = "224_1304516047.681" 
    $P7008."add_method"($P7009, "term:sym<pir::op>", $P7010)
    nqp_get_sc_object $P7011, "1304516035.536", 1
    get_how $P7012, $P7011
    nqp_get_sc_object $P7013, "1304516035.536", 1
    .const 'Sub' $P7014 = "225_1304516047.681" 
    $P7012."add_method"($P7013, "!PREFIX__term:sym<pir::op>", $P7014)
    nqp_get_sc_object $P7015, "1304516035.536", 1
    get_how $P7016, $P7015
    nqp_get_sc_object $P7017, "1304516035.536", 1
    .const 'Sub' $P7018 = "226_1304516047.681" 
    $P7016."add_method"($P7017, "term:sym<onlystar>", $P7018)
    nqp_get_sc_object $P7019, "1304516035.536", 1
    get_how $P7020, $P7019
    nqp_get_sc_object $P7021, "1304516035.536", 1
    .const 'Sub' $P7022 = "228_1304516047.681" 
    $P7020."add_method"($P7021, "!PREFIX__term:sym<onlystar>", $P7022)
    nqp_get_sc_object $P7023, "1304516035.536", 1
    get_how $P7024, $P7023
    nqp_get_sc_object $P7025, "1304516035.536", 1
    .const 'Sub' $P7026 = "229_1304516047.681" 
    $P7024."add_method"($P7025, "args", $P7026)
    nqp_get_sc_object $P7027, "1304516035.536", 1
    get_how $P7028, $P7027
    nqp_get_sc_object $P7029, "1304516035.536", 1
    .const 'Sub' $P7030 = "230_1304516047.681" 
    $P7028."add_method"($P7029, "!PREFIX__args", $P7030)
    nqp_get_sc_object $P7031, "1304516035.536", 1
    get_how $P7032, $P7031
    nqp_get_sc_object $P7033, "1304516035.536", 1
    .const 'Sub' $P7034 = "231_1304516047.681" 
    $P7032."add_method"($P7033, "arglist", $P7034)
    nqp_get_sc_object $P7035, "1304516035.536", 1
    get_how $P7036, $P7035
    nqp_get_sc_object $P7037, "1304516035.536", 1
    .const 'Sub' $P7038 = "232_1304516047.681" 
    $P7036."add_method"($P7037, "!PREFIX__arglist", $P7038)
    nqp_get_sc_object $P7039, "1304516035.536", 1
    get_how $P7040, $P7039
    nqp_get_sc_object $P7041, "1304516035.536", 1
    .const 'Sub' $P7042 = "233_1304516047.681" 
    $P7040."add_method"($P7041, "term:sym<value>", $P7042)
    nqp_get_sc_object $P7043, "1304516035.536", 1
    get_how $P7044, $P7043
    nqp_get_sc_object $P7045, "1304516035.536", 1
    .const 'Sub' $P7046 = "234_1304516047.681" 
    $P7044."add_method"($P7045, "!PREFIX__term:sym<value>", $P7046)
    nqp_get_sc_object $P7047, "1304516035.536", 1
    get_how $P7048, $P7047
    nqp_get_sc_object $P7049, "1304516035.536", 1
    .const 'Sub' $P7050 = "235_1304516047.681" 
    $P7048."add_method"($P7049, "value", $P7050)
    nqp_get_sc_object $P7051, "1304516035.536", 1
    get_how $P7052, $P7051
    nqp_get_sc_object $P7053, "1304516035.536", 1
    .const 'Sub' $P7054 = "236_1304516047.681" 
    $P7052."add_method"($P7053, "!PREFIX__value", $P7054)
    nqp_get_sc_object $P7055, "1304516035.536", 1
    get_how $P7056, $P7055
    nqp_get_sc_object $P7057, "1304516035.536", 1
    .const 'Sub' $P7058 = "237_1304516047.681" 
    $P7056."add_method"($P7057, "number", $P7058)
    nqp_get_sc_object $P7059, "1304516035.536", 1
    get_how $P7060, $P7059
    nqp_get_sc_object $P7061, "1304516035.536", 1
    .const 'Sub' $P7062 = "238_1304516047.681" 
    $P7060."add_method"($P7061, "!PREFIX__number", $P7062)
    nqp_get_sc_object $P7063, "1304516035.536", 1
    get_how $P7064, $P7063
    nqp_get_sc_object $P7065, "1304516035.536", 1
    .const 'Sub' $P7066 = "239_1304516047.681" 
    $P7064."add_method"($P7065, "quote", $P7066)
    nqp_get_sc_object $P7067, "1304516035.536", 1
    get_how $P7068, $P7067
    nqp_get_sc_object $P7069, "1304516035.536", 1
    .const 'Sub' $P7070 = "240_1304516047.681" 
    $P7068."add_method"($P7069, "!PREFIX__quote", $P7070)
    nqp_get_sc_object $P7071, "1304516035.536", 1
    get_how $P7072, $P7071
    nqp_get_sc_object $P7073, "1304516035.536", 1
    .const 'Sub' $P7074 = "241_1304516047.681" 
    $P7072."add_method"($P7073, "quote:sym<apos>", $P7074)
    nqp_get_sc_object $P7075, "1304516035.536", 1
    get_how $P7076, $P7075
    nqp_get_sc_object $P7077, "1304516035.536", 1
    .const 'Sub' $P7078 = "242_1304516047.681" 
    $P7076."add_method"($P7077, "!PREFIX__quote:sym<apos>", $P7078)
    nqp_get_sc_object $P7079, "1304516035.536", 1
    get_how $P7080, $P7079
    nqp_get_sc_object $P7081, "1304516035.536", 1
    .const 'Sub' $P7082 = "243_1304516047.681" 
    $P7080."add_method"($P7081, "quote:sym<dblq>", $P7082)
    nqp_get_sc_object $P7083, "1304516035.536", 1
    get_how $P7084, $P7083
    nqp_get_sc_object $P7085, "1304516035.536", 1
    .const 'Sub' $P7086 = "244_1304516047.681" 
    $P7084."add_method"($P7085, "!PREFIX__quote:sym<dblq>", $P7086)
    nqp_get_sc_object $P7087, "1304516035.536", 1
    get_how $P7088, $P7087
    nqp_get_sc_object $P7089, "1304516035.536", 1
    .const 'Sub' $P7090 = "245_1304516047.681" 
    $P7088."add_method"($P7089, "quote:sym<q>", $P7090)
    nqp_get_sc_object $P7091, "1304516035.536", 1
    get_how $P7092, $P7091
    nqp_get_sc_object $P7093, "1304516035.536", 1
    .const 'Sub' $P7094 = "246_1304516047.681" 
    $P7092."add_method"($P7093, "!PREFIX__quote:sym<q>", $P7094)
    nqp_get_sc_object $P7095, "1304516035.536", 1
    get_how $P7096, $P7095
    nqp_get_sc_object $P7097, "1304516035.536", 1
    .const 'Sub' $P7098 = "247_1304516047.681" 
    $P7096."add_method"($P7097, "quote:sym<qq>", $P7098)
    nqp_get_sc_object $P7099, "1304516035.536", 1
    get_how $P7100, $P7099
    nqp_get_sc_object $P7101, "1304516035.536", 1
    .const 'Sub' $P7102 = "248_1304516047.681" 
    $P7100."add_method"($P7101, "!PREFIX__quote:sym<qq>", $P7102)
    nqp_get_sc_object $P7103, "1304516035.536", 1
    get_how $P7104, $P7103
    nqp_get_sc_object $P7105, "1304516035.536", 1
    .const 'Sub' $P7106 = "249_1304516047.681" 
    $P7104."add_method"($P7105, "quote:sym<Q>", $P7106)
    nqp_get_sc_object $P7107, "1304516035.536", 1
    get_how $P7108, $P7107
    nqp_get_sc_object $P7109, "1304516035.536", 1
    .const 'Sub' $P7110 = "250_1304516047.681" 
    $P7108."add_method"($P7109, "!PREFIX__quote:sym<Q>", $P7110)
    nqp_get_sc_object $P7111, "1304516035.536", 1
    get_how $P7112, $P7111
    nqp_get_sc_object $P7113, "1304516035.536", 1
    .const 'Sub' $P7114 = "251_1304516047.681" 
    $P7112."add_method"($P7113, "quote:sym<Q:PIR>", $P7114)
    nqp_get_sc_object $P7115, "1304516035.536", 1
    get_how $P7116, $P7115
    nqp_get_sc_object $P7117, "1304516035.536", 1
    .const 'Sub' $P7118 = "252_1304516047.681" 
    $P7116."add_method"($P7117, "!PREFIX__quote:sym<Q:PIR>", $P7118)
    nqp_get_sc_object $P7119, "1304516035.536", 1
    get_how $P7120, $P7119
    nqp_get_sc_object $P7121, "1304516035.536", 1
    .const 'Sub' $P7122 = "253_1304516047.681" 
    $P7120."add_method"($P7121, "quote:sym</ />", $P7122)
    nqp_get_sc_object $P7123, "1304516035.536", 1
    get_how $P7124, $P7123
    nqp_get_sc_object $P7125, "1304516035.536", 1
    .const 'Sub' $P7126 = "254_1304516047.681" 
    $P7124."add_method"($P7125, "!PREFIX__quote:sym</ />", $P7126)
    nqp_get_sc_object $P7127, "1304516035.536", 1
    get_how $P7128, $P7127
    nqp_get_sc_object $P7129, "1304516035.536", 1
    .const 'Sub' $P7130 = "255_1304516047.681" 
    $P7128."add_method"($P7129, "quote_escape:sym<$>", $P7130)
    nqp_get_sc_object $P7131, "1304516035.536", 1
    get_how $P7132, $P7131
    nqp_get_sc_object $P7133, "1304516035.536", 1
    .const 'Sub' $P7134 = "256_1304516047.681" 
    $P7132."add_method"($P7133, "!PREFIX__quote_escape:sym<$>", $P7134)
    nqp_get_sc_object $P7135, "1304516035.536", 1
    get_how $P7136, $P7135
    nqp_get_sc_object $P7137, "1304516035.536", 1
    .const 'Sub' $P7138 = "257_1304516047.681" 
    $P7136."add_method"($P7137, "quote_escape:sym<{ }>", $P7138)
    nqp_get_sc_object $P7139, "1304516035.536", 1
    get_how $P7140, $P7139
    nqp_get_sc_object $P7141, "1304516035.536", 1
    .const 'Sub' $P7142 = "258_1304516047.681" 
    $P7140."add_method"($P7141, "!PREFIX__quote_escape:sym<{ }>", $P7142)
    nqp_get_sc_object $P7143, "1304516035.536", 1
    get_how $P7144, $P7143
    nqp_get_sc_object $P7145, "1304516035.536", 1
    .const 'Sub' $P7146 = "259_1304516047.681" 
    $P7144."add_method"($P7145, "quote_escape:sym<esc>", $P7146)
    nqp_get_sc_object $P7147, "1304516035.536", 1
    get_how $P7148, $P7147
    nqp_get_sc_object $P7149, "1304516035.536", 1
    .const 'Sub' $P7150 = "260_1304516047.681" 
    $P7148."add_method"($P7149, "!PREFIX__quote_escape:sym<esc>", $P7150)
    nqp_get_sc_object $P7151, "1304516035.536", 1
    get_how $P7152, $P7151
    nqp_get_sc_object $P7153, "1304516035.536", 1
    .const 'Sub' $P7154 = "261_1304516047.681" 
    $P7152."add_method"($P7153, "circumfix:sym<( )>", $P7154)
    nqp_get_sc_object $P7155, "1304516035.536", 1
    get_how $P7156, $P7155
    nqp_get_sc_object $P7157, "1304516035.536", 1
    .const 'Sub' $P7158 = "262_1304516047.681" 
    $P7156."add_method"($P7157, "!PREFIX__circumfix:sym<( )>", $P7158)
    nqp_get_sc_object $P7159, "1304516035.536", 1
    get_how $P7160, $P7159
    nqp_get_sc_object $P7161, "1304516035.536", 1
    .const 'Sub' $P7162 = "263_1304516047.681" 
    $P7160."add_method"($P7161, "circumfix:sym<[ ]>", $P7162)
    nqp_get_sc_object $P7163, "1304516035.536", 1
    get_how $P7164, $P7163
    nqp_get_sc_object $P7165, "1304516035.536", 1
    .const 'Sub' $P7166 = "264_1304516047.681" 
    $P7164."add_method"($P7165, "!PREFIX__circumfix:sym<[ ]>", $P7166)
    nqp_get_sc_object $P7167, "1304516035.536", 1
    get_how $P7168, $P7167
    nqp_get_sc_object $P7169, "1304516035.536", 1
    .const 'Sub' $P7170 = "265_1304516047.681" 
    $P7168."add_method"($P7169, "circumfix:sym<ang>", $P7170)
    nqp_get_sc_object $P7171, "1304516035.536", 1
    get_how $P7172, $P7171
    nqp_get_sc_object $P7173, "1304516035.536", 1
    .const 'Sub' $P7174 = "266_1304516047.681" 
    $P7172."add_method"($P7173, "!PREFIX__circumfix:sym<ang>", $P7174)
    nqp_get_sc_object $P7175, "1304516035.536", 1
    get_how $P7176, $P7175
    nqp_get_sc_object $P7177, "1304516035.536", 1
    .const 'Sub' $P7178 = "267_1304516047.681" 
    $P7176."add_method"($P7177, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P7178)
    nqp_get_sc_object $P7179, "1304516035.536", 1
    get_how $P7180, $P7179
    nqp_get_sc_object $P7181, "1304516035.536", 1
    .const 'Sub' $P7182 = "268_1304516047.681" 
    $P7180."add_method"($P7181, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P7182)
    nqp_get_sc_object $P7183, "1304516035.536", 1
    get_how $P7184, $P7183
    nqp_get_sc_object $P7185, "1304516035.536", 1
    .const 'Sub' $P7186 = "269_1304516047.681" 
    $P7184."add_method"($P7185, "circumfix:sym<{ }>", $P7186)
    nqp_get_sc_object $P7187, "1304516035.536", 1
    get_how $P7188, $P7187
    nqp_get_sc_object $P7189, "1304516035.536", 1
    .const 'Sub' $P7190 = "270_1304516047.681" 
    $P7188."add_method"($P7189, "!PREFIX__circumfix:sym<{ }>", $P7190)
    nqp_get_sc_object $P7191, "1304516035.536", 1
    get_how $P7192, $P7191
    nqp_get_sc_object $P7193, "1304516035.536", 1
    .const 'Sub' $P7194 = "271_1304516047.681" 
    $P7192."add_method"($P7193, "circumfix:sym<sigil>", $P7194)
    nqp_get_sc_object $P7195, "1304516035.536", 1
    get_how $P7196, $P7195
    nqp_get_sc_object $P7197, "1304516035.536", 1
    .const 'Sub' $P7198 = "272_1304516047.681" 
    $P7196."add_method"($P7197, "!PREFIX__circumfix:sym<sigil>", $P7198)
    nqp_get_sc_object $P7199, "1304516035.536", 1
    get_how $P7200, $P7199
    nqp_get_sc_object $P7201, "1304516035.536", 1
    .const 'Sub' $P7202 = "273_1304516047.681" 
    $P7200."add_method"($P7201, "semilist", $P7202)
    nqp_get_sc_object $P7203, "1304516035.536", 1
    get_how $P7204, $P7203
    nqp_get_sc_object $P7205, "1304516035.536", 1
    .const 'Sub' $P7206 = "274_1304516047.681" 
    $P7204."add_method"($P7205, "!PREFIX__semilist", $P7206)
    nqp_get_sc_object $P7207, "1304516035.536", 1
    get_how $P7208, $P7207
    nqp_get_sc_object $P7209, "1304516035.536", 1
    .const 'Sub' $P7210 = "275_1304516047.681" 
    $P7208."add_method"($P7209, "infixish", $P7210)
    nqp_get_sc_object $P7211, "1304516035.536", 1
    get_how $P7212, $P7211
    nqp_get_sc_object $P7213, "1304516035.536", 1
    .const 'Sub' $P7214 = "276_1304516047.681" 
    $P7212."add_method"($P7213, "!PREFIX__infixish", $P7214)
    nqp_get_sc_object $P7215, "1304516035.536", 1
    get_how $P7216, $P7215
    nqp_get_sc_object $P7217, "1304516035.536", 1
    .const 'Sub' $P7218 = "277_1304516047.681" 
    $P7216."add_method"($P7217, "infixstopper", $P7218)
    nqp_get_sc_object $P7219, "1304516035.536", 1
    get_how $P7220, $P7219
    nqp_get_sc_object $P7221, "1304516035.536", 1
    .const 'Sub' $P7222 = "278_1304516047.681" 
    $P7220."add_method"($P7221, "!PREFIX__infixstopper", $P7222)
    nqp_get_sc_object $P7223, "1304516035.536", 1
    get_how $P7224, $P7223
    nqp_get_sc_object $P7225, "1304516035.536", 1
    .const 'Sub' $P7226 = "279_1304516047.681" 
    $P7224."add_method"($P7225, "postcircumfix:sym<[ ]>", $P7226)
    nqp_get_sc_object $P7227, "1304516035.536", 1
    get_how $P7228, $P7227
    nqp_get_sc_object $P7229, "1304516035.536", 1
    .const 'Sub' $P7230 = "280_1304516047.681" 
    $P7228."add_method"($P7229, "!PREFIX__postcircumfix:sym<[ ]>", $P7230)
    nqp_get_sc_object $P7231, "1304516035.536", 1
    get_how $P7232, $P7231
    nqp_get_sc_object $P7233, "1304516035.536", 1
    .const 'Sub' $P7234 = "281_1304516047.681" 
    $P7232."add_method"($P7233, "postcircumfix:sym<{ }>", $P7234)
    nqp_get_sc_object $P7235, "1304516035.536", 1
    get_how $P7236, $P7235
    nqp_get_sc_object $P7237, "1304516035.536", 1
    .const 'Sub' $P7238 = "282_1304516047.681" 
    $P7236."add_method"($P7237, "!PREFIX__postcircumfix:sym<{ }>", $P7238)
    nqp_get_sc_object $P7239, "1304516035.536", 1
    get_how $P7240, $P7239
    nqp_get_sc_object $P7241, "1304516035.536", 1
    .const 'Sub' $P7242 = "283_1304516047.681" 
    $P7240."add_method"($P7241, "postcircumfix:sym<ang>", $P7242)
    nqp_get_sc_object $P7243, "1304516035.536", 1
    get_how $P7244, $P7243
    nqp_get_sc_object $P7245, "1304516035.536", 1
    .const 'Sub' $P7246 = "284_1304516047.681" 
    $P7244."add_method"($P7245, "!PREFIX__postcircumfix:sym<ang>", $P7246)
    nqp_get_sc_object $P7247, "1304516035.536", 1
    get_how $P7248, $P7247
    nqp_get_sc_object $P7249, "1304516035.536", 1
    .const 'Sub' $P7250 = "285_1304516047.681" 
    $P7248."add_method"($P7249, "postcircumfix:sym<( )>", $P7250)
    nqp_get_sc_object $P7251, "1304516035.536", 1
    get_how $P7252, $P7251
    nqp_get_sc_object $P7253, "1304516035.536", 1
    .const 'Sub' $P7254 = "286_1304516047.681" 
    $P7252."add_method"($P7253, "!PREFIX__postcircumfix:sym<( )>", $P7254)
    nqp_get_sc_object $P7255, "1304516035.536", 1
    get_how $P7256, $P7255
    nqp_get_sc_object $P7257, "1304516035.536", 1
    .const 'Sub' $P7258 = "287_1304516047.681" 
    $P7256."add_method"($P7257, "postfix:sym<.>", $P7258)
    nqp_get_sc_object $P7259, "1304516035.536", 1
    get_how $P7260, $P7259
    nqp_get_sc_object $P7261, "1304516035.536", 1
    .const 'Sub' $P7262 = "288_1304516047.681" 
    $P7260."add_method"($P7261, "!PREFIX__postfix:sym<.>", $P7262)
    nqp_get_sc_object $P7263, "1304516035.536", 1
    get_how $P7264, $P7263
    nqp_get_sc_object $P7265, "1304516035.536", 1
    .const 'Sub' $P7266 = "289_1304516047.681" 
    $P7264."add_method"($P7265, "prefix:sym<++>", $P7266)
    nqp_get_sc_object $P7267, "1304516035.536", 1
    get_how $P7268, $P7267
    nqp_get_sc_object $P7269, "1304516035.536", 1
    .const 'Sub' $P7270 = "290_1304516047.681" 
    $P7268."add_method"($P7269, "!PREFIX__prefix:sym<++>", $P7270)
    nqp_get_sc_object $P7271, "1304516035.536", 1
    get_how $P7272, $P7271
    nqp_get_sc_object $P7273, "1304516035.536", 1
    .const 'Sub' $P7274 = "291_1304516047.681" 
    $P7272."add_method"($P7273, "prefix:sym<-->", $P7274)
    nqp_get_sc_object $P7275, "1304516035.536", 1
    get_how $P7276, $P7275
    nqp_get_sc_object $P7277, "1304516035.536", 1
    .const 'Sub' $P7278 = "292_1304516047.681" 
    $P7276."add_method"($P7277, "!PREFIX__prefix:sym<-->", $P7278)
    nqp_get_sc_object $P7279, "1304516035.536", 1
    get_how $P7280, $P7279
    nqp_get_sc_object $P7281, "1304516035.536", 1
    .const 'Sub' $P7282 = "293_1304516047.681" 
    $P7280."add_method"($P7281, "postfix:sym<++>", $P7282)
    nqp_get_sc_object $P7283, "1304516035.536", 1
    get_how $P7284, $P7283
    nqp_get_sc_object $P7285, "1304516035.536", 1
    .const 'Sub' $P7286 = "294_1304516047.681" 
    $P7284."add_method"($P7285, "!PREFIX__postfix:sym<++>", $P7286)
    nqp_get_sc_object $P7287, "1304516035.536", 1
    get_how $P7288, $P7287
    nqp_get_sc_object $P7289, "1304516035.536", 1
    .const 'Sub' $P7290 = "295_1304516047.681" 
    $P7288."add_method"($P7289, "postfix:sym<-->", $P7290)
    nqp_get_sc_object $P7291, "1304516035.536", 1
    get_how $P7292, $P7291
    nqp_get_sc_object $P7293, "1304516035.536", 1
    .const 'Sub' $P7294 = "296_1304516047.681" 
    $P7292."add_method"($P7293, "!PREFIX__postfix:sym<-->", $P7294)
    nqp_get_sc_object $P7295, "1304516035.536", 1
    get_how $P7296, $P7295
    nqp_get_sc_object $P7297, "1304516035.536", 1
    .const 'Sub' $P7298 = "297_1304516047.681" 
    $P7296."add_method"($P7297, "infix:sym<**>", $P7298)
    nqp_get_sc_object $P7299, "1304516035.536", 1
    get_how $P7300, $P7299
    nqp_get_sc_object $P7301, "1304516035.536", 1
    .const 'Sub' $P7302 = "298_1304516047.681" 
    $P7300."add_method"($P7301, "!PREFIX__infix:sym<**>", $P7302)
    nqp_get_sc_object $P7303, "1304516035.536", 1
    get_how $P7304, $P7303
    nqp_get_sc_object $P7305, "1304516035.536", 1
    .const 'Sub' $P7306 = "299_1304516047.681" 
    $P7304."add_method"($P7305, "prefix:sym<+>", $P7306)
    nqp_get_sc_object $P7307, "1304516035.536", 1
    get_how $P7308, $P7307
    nqp_get_sc_object $P7309, "1304516035.536", 1
    .const 'Sub' $P7310 = "300_1304516047.681" 
    $P7308."add_method"($P7309, "!PREFIX__prefix:sym<+>", $P7310)
    nqp_get_sc_object $P7311, "1304516035.536", 1
    get_how $P7312, $P7311
    nqp_get_sc_object $P7313, "1304516035.536", 1
    .const 'Sub' $P7314 = "301_1304516047.681" 
    $P7312."add_method"($P7313, "prefix:sym<~>", $P7314)
    nqp_get_sc_object $P7315, "1304516035.536", 1
    get_how $P7316, $P7315
    nqp_get_sc_object $P7317, "1304516035.536", 1
    .const 'Sub' $P7318 = "302_1304516047.681" 
    $P7316."add_method"($P7317, "!PREFIX__prefix:sym<~>", $P7318)
    nqp_get_sc_object $P7319, "1304516035.536", 1
    get_how $P7320, $P7319
    nqp_get_sc_object $P7321, "1304516035.536", 1
    .const 'Sub' $P7322 = "303_1304516047.681" 
    $P7320."add_method"($P7321, "prefix:sym<->", $P7322)
    nqp_get_sc_object $P7323, "1304516035.536", 1
    get_how $P7324, $P7323
    nqp_get_sc_object $P7325, "1304516035.536", 1
    .const 'Sub' $P7326 = "304_1304516047.681" 
    $P7324."add_method"($P7325, "!PREFIX__prefix:sym<->", $P7326)
    nqp_get_sc_object $P7327, "1304516035.536", 1
    get_how $P7328, $P7327
    nqp_get_sc_object $P7329, "1304516035.536", 1
    .const 'Sub' $P7330 = "305_1304516047.681" 
    $P7328."add_method"($P7329, "prefix:sym<?>", $P7330)
    nqp_get_sc_object $P7331, "1304516035.536", 1
    get_how $P7332, $P7331
    nqp_get_sc_object $P7333, "1304516035.536", 1
    .const 'Sub' $P7334 = "306_1304516047.681" 
    $P7332."add_method"($P7333, "!PREFIX__prefix:sym<?>", $P7334)
    nqp_get_sc_object $P7335, "1304516035.536", 1
    get_how $P7336, $P7335
    nqp_get_sc_object $P7337, "1304516035.536", 1
    .const 'Sub' $P7338 = "307_1304516047.681" 
    $P7336."add_method"($P7337, "prefix:sym<!>", $P7338)
    nqp_get_sc_object $P7339, "1304516035.536", 1
    get_how $P7340, $P7339
    nqp_get_sc_object $P7341, "1304516035.536", 1
    .const 'Sub' $P7342 = "308_1304516047.681" 
    $P7340."add_method"($P7341, "!PREFIX__prefix:sym<!>", $P7342)
    nqp_get_sc_object $P7343, "1304516035.536", 1
    get_how $P7344, $P7343
    nqp_get_sc_object $P7345, "1304516035.536", 1
    .const 'Sub' $P7346 = "309_1304516047.681" 
    $P7344."add_method"($P7345, "prefix:sym<|>", $P7346)
    nqp_get_sc_object $P7347, "1304516035.536", 1
    get_how $P7348, $P7347
    nqp_get_sc_object $P7349, "1304516035.536", 1
    .const 'Sub' $P7350 = "310_1304516047.681" 
    $P7348."add_method"($P7349, "!PREFIX__prefix:sym<|>", $P7350)
    nqp_get_sc_object $P7351, "1304516035.536", 1
    get_how $P7352, $P7351
    nqp_get_sc_object $P7353, "1304516035.536", 1
    .const 'Sub' $P7354 = "311_1304516047.681" 
    $P7352."add_method"($P7353, "infix:sym<*>", $P7354)
    nqp_get_sc_object $P7355, "1304516035.536", 1
    get_how $P7356, $P7355
    nqp_get_sc_object $P7357, "1304516035.536", 1
    .const 'Sub' $P7358 = "312_1304516047.681" 
    $P7356."add_method"($P7357, "!PREFIX__infix:sym<*>", $P7358)
    nqp_get_sc_object $P7359, "1304516035.536", 1
    get_how $P7360, $P7359
    nqp_get_sc_object $P7361, "1304516035.536", 1
    .const 'Sub' $P7362 = "313_1304516047.681" 
    $P7360."add_method"($P7361, "infix:sym</>", $P7362)
    nqp_get_sc_object $P7363, "1304516035.536", 1
    get_how $P7364, $P7363
    nqp_get_sc_object $P7365, "1304516035.536", 1
    .const 'Sub' $P7366 = "314_1304516047.681" 
    $P7364."add_method"($P7365, "!PREFIX__infix:sym</>", $P7366)
    nqp_get_sc_object $P7367, "1304516035.536", 1
    get_how $P7368, $P7367
    nqp_get_sc_object $P7369, "1304516035.536", 1
    .const 'Sub' $P7370 = "315_1304516047.681" 
    $P7368."add_method"($P7369, "infix:sym<%>", $P7370)
    nqp_get_sc_object $P7371, "1304516035.536", 1
    get_how $P7372, $P7371
    nqp_get_sc_object $P7373, "1304516035.536", 1
    .const 'Sub' $P7374 = "316_1304516047.681" 
    $P7372."add_method"($P7373, "!PREFIX__infix:sym<%>", $P7374)
    nqp_get_sc_object $P7375, "1304516035.536", 1
    get_how $P7376, $P7375
    nqp_get_sc_object $P7377, "1304516035.536", 1
    .const 'Sub' $P7378 = "317_1304516047.681" 
    $P7376."add_method"($P7377, "infix:sym<+&>", $P7378)
    nqp_get_sc_object $P7379, "1304516035.536", 1
    get_how $P7380, $P7379
    nqp_get_sc_object $P7381, "1304516035.536", 1
    .const 'Sub' $P7382 = "318_1304516047.681" 
    $P7380."add_method"($P7381, "!PREFIX__infix:sym<+&>", $P7382)
    nqp_get_sc_object $P7383, "1304516035.536", 1
    get_how $P7384, $P7383
    nqp_get_sc_object $P7385, "1304516035.536", 1
    .const 'Sub' $P7386 = "319_1304516047.681" 
    $P7384."add_method"($P7385, "infix:sym<+>", $P7386)
    nqp_get_sc_object $P7387, "1304516035.536", 1
    get_how $P7388, $P7387
    nqp_get_sc_object $P7389, "1304516035.536", 1
    .const 'Sub' $P7390 = "320_1304516047.681" 
    $P7388."add_method"($P7389, "!PREFIX__infix:sym<+>", $P7390)
    nqp_get_sc_object $P7391, "1304516035.536", 1
    get_how $P7392, $P7391
    nqp_get_sc_object $P7393, "1304516035.536", 1
    .const 'Sub' $P7394 = "321_1304516047.681" 
    $P7392."add_method"($P7393, "infix:sym<->", $P7394)
    nqp_get_sc_object $P7395, "1304516035.536", 1
    get_how $P7396, $P7395
    nqp_get_sc_object $P7397, "1304516035.536", 1
    .const 'Sub' $P7398 = "322_1304516047.681" 
    $P7396."add_method"($P7397, "!PREFIX__infix:sym<->", $P7398)
    nqp_get_sc_object $P7399, "1304516035.536", 1
    get_how $P7400, $P7399
    nqp_get_sc_object $P7401, "1304516035.536", 1
    .const 'Sub' $P7402 = "323_1304516047.681" 
    $P7400."add_method"($P7401, "infix:sym<+|>", $P7402)
    nqp_get_sc_object $P7403, "1304516035.536", 1
    get_how $P7404, $P7403
    nqp_get_sc_object $P7405, "1304516035.536", 1
    .const 'Sub' $P7406 = "324_1304516047.681" 
    $P7404."add_method"($P7405, "!PREFIX__infix:sym<+|>", $P7406)
    nqp_get_sc_object $P7407, "1304516035.536", 1
    get_how $P7408, $P7407
    nqp_get_sc_object $P7409, "1304516035.536", 1
    .const 'Sub' $P7410 = "325_1304516047.681" 
    $P7408."add_method"($P7409, "infix:sym<+^>", $P7410)
    nqp_get_sc_object $P7411, "1304516035.536", 1
    get_how $P7412, $P7411
    nqp_get_sc_object $P7413, "1304516035.536", 1
    .const 'Sub' $P7414 = "326_1304516047.681" 
    $P7412."add_method"($P7413, "!PREFIX__infix:sym<+^>", $P7414)
    nqp_get_sc_object $P7415, "1304516035.536", 1
    get_how $P7416, $P7415
    nqp_get_sc_object $P7417, "1304516035.536", 1
    .const 'Sub' $P7418 = "327_1304516047.681" 
    $P7416."add_method"($P7417, "infix:sym<~>", $P7418)
    nqp_get_sc_object $P7419, "1304516035.536", 1
    get_how $P7420, $P7419
    nqp_get_sc_object $P7421, "1304516035.536", 1
    .const 'Sub' $P7422 = "328_1304516047.681" 
    $P7420."add_method"($P7421, "!PREFIX__infix:sym<~>", $P7422)
    nqp_get_sc_object $P7423, "1304516035.536", 1
    get_how $P7424, $P7423
    nqp_get_sc_object $P7425, "1304516035.536", 1
    .const 'Sub' $P7426 = "329_1304516047.681" 
    $P7424."add_method"($P7425, "infix:sym<==>", $P7426)
    nqp_get_sc_object $P7427, "1304516035.536", 1
    get_how $P7428, $P7427
    nqp_get_sc_object $P7429, "1304516035.536", 1
    .const 'Sub' $P7430 = "330_1304516047.681" 
    $P7428."add_method"($P7429, "!PREFIX__infix:sym<==>", $P7430)
    nqp_get_sc_object $P7431, "1304516035.536", 1
    get_how $P7432, $P7431
    nqp_get_sc_object $P7433, "1304516035.536", 1
    .const 'Sub' $P7434 = "331_1304516047.681" 
    $P7432."add_method"($P7433, "infix:sym<!=>", $P7434)
    nqp_get_sc_object $P7435, "1304516035.536", 1
    get_how $P7436, $P7435
    nqp_get_sc_object $P7437, "1304516035.536", 1
    .const 'Sub' $P7438 = "332_1304516047.681" 
    $P7436."add_method"($P7437, "!PREFIX__infix:sym<!=>", $P7438)
    nqp_get_sc_object $P7439, "1304516035.536", 1
    get_how $P7440, $P7439
    nqp_get_sc_object $P7441, "1304516035.536", 1
    .const 'Sub' $P7442 = "333_1304516047.681" 
    $P7440."add_method"($P7441, "infix:sym<<=>", $P7442)
    nqp_get_sc_object $P7443, "1304516035.536", 1
    get_how $P7444, $P7443
    nqp_get_sc_object $P7445, "1304516035.536", 1
    .const 'Sub' $P7446 = "334_1304516047.681" 
    $P7444."add_method"($P7445, "!PREFIX__infix:sym<<=>", $P7446)
    nqp_get_sc_object $P7447, "1304516035.536", 1
    get_how $P7448, $P7447
    nqp_get_sc_object $P7449, "1304516035.536", 1
    .const 'Sub' $P7450 = "335_1304516047.681" 
    $P7448."add_method"($P7449, "infix:sym<>=>", $P7450)
    nqp_get_sc_object $P7451, "1304516035.536", 1
    get_how $P7452, $P7451
    nqp_get_sc_object $P7453, "1304516035.536", 1
    .const 'Sub' $P7454 = "336_1304516047.681" 
    $P7452."add_method"($P7453, "!PREFIX__infix:sym<>=>", $P7454)
    nqp_get_sc_object $P7455, "1304516035.536", 1
    get_how $P7456, $P7455
    nqp_get_sc_object $P7457, "1304516035.536", 1
    .const 'Sub' $P7458 = "337_1304516047.681" 
    $P7456."add_method"($P7457, "infix:sym<<>", $P7458)
    nqp_get_sc_object $P7459, "1304516035.536", 1
    get_how $P7460, $P7459
    nqp_get_sc_object $P7461, "1304516035.536", 1
    .const 'Sub' $P7462 = "338_1304516047.681" 
    $P7460."add_method"($P7461, "!PREFIX__infix:sym<<>", $P7462)
    nqp_get_sc_object $P7463, "1304516035.536", 1
    get_how $P7464, $P7463
    nqp_get_sc_object $P7465, "1304516035.536", 1
    .const 'Sub' $P7466 = "339_1304516047.681" 
    $P7464."add_method"($P7465, "infix:sym<>>", $P7466)
    nqp_get_sc_object $P7467, "1304516035.536", 1
    get_how $P7468, $P7467
    nqp_get_sc_object $P7469, "1304516035.536", 1
    .const 'Sub' $P7470 = "340_1304516047.681" 
    $P7468."add_method"($P7469, "!PREFIX__infix:sym<>>", $P7470)
    nqp_get_sc_object $P7471, "1304516035.536", 1
    get_how $P7472, $P7471
    nqp_get_sc_object $P7473, "1304516035.536", 1
    .const 'Sub' $P7474 = "341_1304516047.681" 
    $P7472."add_method"($P7473, "infix:sym<eq>", $P7474)
    nqp_get_sc_object $P7475, "1304516035.536", 1
    get_how $P7476, $P7475
    nqp_get_sc_object $P7477, "1304516035.536", 1
    .const 'Sub' $P7478 = "342_1304516047.681" 
    $P7476."add_method"($P7477, "!PREFIX__infix:sym<eq>", $P7478)
    nqp_get_sc_object $P7479, "1304516035.536", 1
    get_how $P7480, $P7479
    nqp_get_sc_object $P7481, "1304516035.536", 1
    .const 'Sub' $P7482 = "343_1304516047.681" 
    $P7480."add_method"($P7481, "infix:sym<ne>", $P7482)
    nqp_get_sc_object $P7483, "1304516035.536", 1
    get_how $P7484, $P7483
    nqp_get_sc_object $P7485, "1304516035.536", 1
    .const 'Sub' $P7486 = "344_1304516047.681" 
    $P7484."add_method"($P7485, "!PREFIX__infix:sym<ne>", $P7486)
    nqp_get_sc_object $P7487, "1304516035.536", 1
    get_how $P7488, $P7487
    nqp_get_sc_object $P7489, "1304516035.536", 1
    .const 'Sub' $P7490 = "345_1304516047.681" 
    $P7488."add_method"($P7489, "infix:sym<le>", $P7490)
    nqp_get_sc_object $P7491, "1304516035.536", 1
    get_how $P7492, $P7491
    nqp_get_sc_object $P7493, "1304516035.536", 1
    .const 'Sub' $P7494 = "346_1304516047.681" 
    $P7492."add_method"($P7493, "!PREFIX__infix:sym<le>", $P7494)
    nqp_get_sc_object $P7495, "1304516035.536", 1
    get_how $P7496, $P7495
    nqp_get_sc_object $P7497, "1304516035.536", 1
    .const 'Sub' $P7498 = "347_1304516047.681" 
    $P7496."add_method"($P7497, "infix:sym<ge>", $P7498)
    nqp_get_sc_object $P7499, "1304516035.536", 1
    get_how $P7500, $P7499
    nqp_get_sc_object $P7501, "1304516035.536", 1
    .const 'Sub' $P7502 = "348_1304516047.681" 
    $P7500."add_method"($P7501, "!PREFIX__infix:sym<ge>", $P7502)
    nqp_get_sc_object $P7503, "1304516035.536", 1
    get_how $P7504, $P7503
    nqp_get_sc_object $P7505, "1304516035.536", 1
    .const 'Sub' $P7506 = "349_1304516047.681" 
    $P7504."add_method"($P7505, "infix:sym<lt>", $P7506)
    nqp_get_sc_object $P7507, "1304516035.536", 1
    get_how $P7508, $P7507
    nqp_get_sc_object $P7509, "1304516035.536", 1
    .const 'Sub' $P7510 = "350_1304516047.681" 
    $P7508."add_method"($P7509, "!PREFIX__infix:sym<lt>", $P7510)
    nqp_get_sc_object $P7511, "1304516035.536", 1
    get_how $P7512, $P7511
    nqp_get_sc_object $P7513, "1304516035.536", 1
    .const 'Sub' $P7514 = "351_1304516047.681" 
    $P7512."add_method"($P7513, "infix:sym<gt>", $P7514)
    nqp_get_sc_object $P7515, "1304516035.536", 1
    get_how $P7516, $P7515
    nqp_get_sc_object $P7517, "1304516035.536", 1
    .const 'Sub' $P7518 = "352_1304516047.681" 
    $P7516."add_method"($P7517, "!PREFIX__infix:sym<gt>", $P7518)
    nqp_get_sc_object $P7519, "1304516035.536", 1
    get_how $P7520, $P7519
    nqp_get_sc_object $P7521, "1304516035.536", 1
    .const 'Sub' $P7522 = "353_1304516047.681" 
    $P7520."add_method"($P7521, "infix:sym<=:=>", $P7522)
    nqp_get_sc_object $P7523, "1304516035.536", 1
    get_how $P7524, $P7523
    nqp_get_sc_object $P7525, "1304516035.536", 1
    .const 'Sub' $P7526 = "354_1304516047.681" 
    $P7524."add_method"($P7525, "!PREFIX__infix:sym<=:=>", $P7526)
    nqp_get_sc_object $P7527, "1304516035.536", 1
    get_how $P7528, $P7527
    nqp_get_sc_object $P7529, "1304516035.536", 1
    .const 'Sub' $P7530 = "355_1304516047.681" 
    $P7528."add_method"($P7529, "infix:sym<~~>", $P7530)
    nqp_get_sc_object $P7531, "1304516035.536", 1
    get_how $P7532, $P7531
    nqp_get_sc_object $P7533, "1304516035.536", 1
    .const 'Sub' $P7534 = "356_1304516047.681" 
    $P7532."add_method"($P7533, "!PREFIX__infix:sym<~~>", $P7534)
    nqp_get_sc_object $P7535, "1304516035.536", 1
    get_how $P7536, $P7535
    nqp_get_sc_object $P7537, "1304516035.536", 1
    .const 'Sub' $P7538 = "357_1304516047.681" 
    $P7536."add_method"($P7537, "infix:sym<&&>", $P7538)
    nqp_get_sc_object $P7539, "1304516035.536", 1
    get_how $P7540, $P7539
    nqp_get_sc_object $P7541, "1304516035.536", 1
    .const 'Sub' $P7542 = "358_1304516047.681" 
    $P7540."add_method"($P7541, "!PREFIX__infix:sym<&&>", $P7542)
    nqp_get_sc_object $P7543, "1304516035.536", 1
    get_how $P7544, $P7543
    nqp_get_sc_object $P7545, "1304516035.536", 1
    .const 'Sub' $P7546 = "359_1304516047.681" 
    $P7544."add_method"($P7545, "infix:sym<||>", $P7546)
    nqp_get_sc_object $P7547, "1304516035.536", 1
    get_how $P7548, $P7547
    nqp_get_sc_object $P7549, "1304516035.536", 1
    .const 'Sub' $P7550 = "360_1304516047.681" 
    $P7548."add_method"($P7549, "!PREFIX__infix:sym<||>", $P7550)
    nqp_get_sc_object $P7551, "1304516035.536", 1
    get_how $P7552, $P7551
    nqp_get_sc_object $P7553, "1304516035.536", 1
    .const 'Sub' $P7554 = "361_1304516047.681" 
    $P7552."add_method"($P7553, "infix:sym<//>", $P7554)
    nqp_get_sc_object $P7555, "1304516035.536", 1
    get_how $P7556, $P7555
    nqp_get_sc_object $P7557, "1304516035.536", 1
    .const 'Sub' $P7558 = "362_1304516047.681" 
    $P7556."add_method"($P7557, "!PREFIX__infix:sym<//>", $P7558)
    nqp_get_sc_object $P7559, "1304516035.536", 1
    get_how $P7560, $P7559
    nqp_get_sc_object $P7561, "1304516035.536", 1
    .const 'Sub' $P7562 = "363_1304516047.681" 
    $P7560."add_method"($P7561, "infix:sym<?? !!>", $P7562)
    nqp_get_sc_object $P7563, "1304516035.536", 1
    get_how $P7564, $P7563
    nqp_get_sc_object $P7565, "1304516035.536", 1
    .const 'Sub' $P7566 = "364_1304516047.681" 
    $P7564."add_method"($P7565, "!PREFIX__infix:sym<?? !!>", $P7566)
    nqp_get_sc_object $P7567, "1304516035.536", 1
    get_how $P7568, $P7567
    nqp_get_sc_object $P7569, "1304516035.536", 1
    .const 'Sub' $P7570 = "365_1304516047.681" 
    $P7568."add_method"($P7569, "infix:sym<=>", $P7570)
    nqp_get_sc_object $P7571, "1304516035.536", 1
    get_how $P7572, $P7571
    nqp_get_sc_object $P7573, "1304516035.536", 1
    .const 'Sub' $P7574 = "366_1304516047.681" 
    $P7572."add_method"($P7573, "!PREFIX__infix:sym<=>", $P7574)
    nqp_get_sc_object $P7575, "1304516035.536", 1
    get_how $P7576, $P7575
    nqp_get_sc_object $P7577, "1304516035.536", 1
    .const 'Sub' $P7578 = "367_1304516047.681" 
    $P7576."add_method"($P7577, "infix:sym<:=>", $P7578)
    nqp_get_sc_object $P7579, "1304516035.536", 1
    get_how $P7580, $P7579
    nqp_get_sc_object $P7581, "1304516035.536", 1
    .const 'Sub' $P7582 = "368_1304516047.681" 
    $P7580."add_method"($P7581, "!PREFIX__infix:sym<:=>", $P7582)
    nqp_get_sc_object $P7583, "1304516035.536", 1
    get_how $P7584, $P7583
    nqp_get_sc_object $P7585, "1304516035.536", 1
    .const 'Sub' $P7586 = "369_1304516047.681" 
    $P7584."add_method"($P7585, "infix:sym<::=>", $P7586)
    nqp_get_sc_object $P7587, "1304516035.536", 1
    get_how $P7588, $P7587
    nqp_get_sc_object $P7589, "1304516035.536", 1
    .const 'Sub' $P7590 = "370_1304516047.681" 
    $P7588."add_method"($P7589, "!PREFIX__infix:sym<::=>", $P7590)
    nqp_get_sc_object $P7591, "1304516035.536", 1
    get_how $P7592, $P7591
    nqp_get_sc_object $P7593, "1304516035.536", 1
    .const 'Sub' $P7594 = "371_1304516047.681" 
    $P7592."add_method"($P7593, "infix:sym<,>", $P7594)
    nqp_get_sc_object $P7595, "1304516035.536", 1
    get_how $P7596, $P7595
    nqp_get_sc_object $P7597, "1304516035.536", 1
    .const 'Sub' $P7598 = "372_1304516047.681" 
    $P7596."add_method"($P7597, "!PREFIX__infix:sym<,>", $P7598)
    nqp_get_sc_object $P7599, "1304516035.536", 1
    get_how $P7600, $P7599
    nqp_get_sc_object $P7601, "1304516035.536", 1
    .const 'Sub' $P7602 = "373_1304516047.681" 
    $P7600."add_method"($P7601, "prefix:sym<return>", $P7602)
    nqp_get_sc_object $P7603, "1304516035.536", 1
    get_how $P7604, $P7603
    nqp_get_sc_object $P7605, "1304516035.536", 1
    .const 'Sub' $P7606 = "375_1304516047.681" 
    $P7604."add_method"($P7605, "!PREFIX__prefix:sym<return>", $P7606)
    nqp_get_sc_object $P7607, "1304516035.536", 1
    get_how $P7608, $P7607
    nqp_get_sc_object $P7609, "1304516035.536", 1
    .const 'Sub' $P7610 = "376_1304516047.681" 
    $P7608."add_method"($P7609, "prefix:sym<make>", $P7610)
    nqp_get_sc_object $P7611, "1304516035.536", 1
    get_how $P7612, $P7611
    nqp_get_sc_object $P7613, "1304516035.536", 1
    .const 'Sub' $P7614 = "377_1304516047.681" 
    $P7612."add_method"($P7613, "!PREFIX__prefix:sym<make>", $P7614)
    nqp_get_sc_object $P7615, "1304516035.536", 1
    get_how $P7616, $P7615
    nqp_get_sc_object $P7617, "1304516035.536", 1
    .const 'Sub' $P7618 = "378_1304516047.681" 
    $P7616."add_method"($P7617, "term:sym<last>", $P7618)
    nqp_get_sc_object $P7619, "1304516035.536", 1
    get_how $P7620, $P7619
    nqp_get_sc_object $P7621, "1304516035.536", 1
    .const 'Sub' $P7622 = "379_1304516047.681" 
    $P7620."add_method"($P7621, "!PREFIX__term:sym<last>", $P7622)
    nqp_get_sc_object $P7623, "1304516035.536", 1
    get_how $P7624, $P7623
    nqp_get_sc_object $P7625, "1304516035.536", 1
    .const 'Sub' $P7626 = "380_1304516047.681" 
    $P7624."add_method"($P7625, "term:sym<next>", $P7626)
    nqp_get_sc_object $P7627, "1304516035.536", 1
    get_how $P7628, $P7627
    nqp_get_sc_object $P7629, "1304516035.536", 1
    .const 'Sub' $P7630 = "381_1304516047.681" 
    $P7628."add_method"($P7629, "!PREFIX__term:sym<next>", $P7630)
    nqp_get_sc_object $P7631, "1304516035.536", 1
    get_how $P7632, $P7631
    nqp_get_sc_object $P7633, "1304516035.536", 1
    .const 'Sub' $P7634 = "382_1304516047.681" 
    $P7632."add_method"($P7633, "term:sym<redo>", $P7634)
    nqp_get_sc_object $P7635, "1304516035.536", 1
    get_how $P7636, $P7635
    nqp_get_sc_object $P7637, "1304516035.536", 1
    .const 'Sub' $P7638 = "383_1304516047.681" 
    $P7636."add_method"($P7637, "!PREFIX__term:sym<redo>", $P7638)
    nqp_get_sc_object $P7639, "1304516035.536", 1
    get_how $P7640, $P7639
    nqp_get_sc_object $P7641, "1304516035.536", 1
    .const 'Sub' $P7642 = "384_1304516047.681" 
    $P7640."add_method"($P7641, "smartmatch", $P7642)
    .const 'Sub' $P7643 = "12_1304516047.681" 
    $P7644 = $P7643."get_lexinfo"()
    nqp_get_sc_object $P7645, "1304516035.536", 1
    $P7644."set_static_lexpad_value"("$?PACKAGE", $P7645)
    .const 'Sub' $P7646 = "12_1304516047.681" 
    $P7647 = $P7646."get_lexinfo"()
    $P7647."finish_static_lexpad"()
    .const 'Sub' $P7648 = "12_1304516047.681" 
    $P7649 = $P7648."get_lexinfo"()
    nqp_get_sc_object $P7650, "1304516035.536", 1
    $P7649."set_static_lexpad_value"("$?CLASS", $P7650)
    .const 'Sub' $P7651 = "12_1304516047.681" 
    $P7652 = $P7651."get_lexinfo"()
    $P7652."finish_static_lexpad"()
    nqp_get_sc_object $P7653, "1304516035.536", 1
    get_how $P7654, $P7653
    nqp_get_sc_object $P7655, "1304516035.536", 1
    nqp_get_sc_object $P7656, "1304516016.343", 1
    $P7654."add_parent"($P7655, $P7656)
    nqp_get_sc_object $P7657, "1304516035.536", 1
    get_how $P7658, $P7657
    nqp_get_sc_object $P7659, "1304516035.536", 1
    $P7658."compose"($P7659)
    nqp_get_sc_object $P7660, "1304516008.504", 41
    $P7661 = $P7660."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P7661, cur_sc
    nqp_set_sc_object "1304516035.536", 360, $P7661
    nqp_get_sc_object $P7662, "1304516035.536", 360
    nqp_get_sc_object $P7663, "1304516035.536", 0
    nqp_get_package_through_who $P7664, $P7663, "NQP"
    get_who $P7665, $P7664
    set $P7665["Regex"], $P7662
    nqp_get_sc_object $P7666, "1304516035.536", 360
    get_how $P7667, $P7666
    nqp_get_sc_object $P7668, "1304516035.536", 360
    .const 'Sub' $P7669 = "386_1304516047.681" 
    $P7667."add_method"($P7668, "metachar:sym<:my>", $P7669)
    nqp_get_sc_object $P7670, "1304516035.536", 360
    get_how $P7671, $P7670
    nqp_get_sc_object $P7672, "1304516035.536", 360
    .const 'Sub' $P7673 = "388_1304516047.681" 
    $P7671."add_method"($P7672, "!PREFIX__metachar:sym<:my>", $P7673)
    nqp_get_sc_object $P7674, "1304516035.536", 360
    get_how $P7675, $P7674
    nqp_get_sc_object $P7676, "1304516035.536", 360
    .const 'Sub' $P7677 = "389_1304516047.681" 
    $P7675."add_method"($P7676, "metachar:sym<{ }>", $P7677)
    nqp_get_sc_object $P7678, "1304516035.536", 360
    get_how $P7679, $P7678
    nqp_get_sc_object $P7680, "1304516035.536", 360
    .const 'Sub' $P7681 = "390_1304516047.681" 
    $P7679."add_method"($P7680, "!PREFIX__metachar:sym<{ }>", $P7681)
    nqp_get_sc_object $P7682, "1304516035.536", 360
    get_how $P7683, $P7682
    nqp_get_sc_object $P7684, "1304516035.536", 360
    .const 'Sub' $P7685 = "391_1304516047.681" 
    $P7683."add_method"($P7684, "metachar:sym<nqpvar>", $P7685)
    nqp_get_sc_object $P7686, "1304516035.536", 360
    get_how $P7687, $P7686
    nqp_get_sc_object $P7688, "1304516035.536", 360
    .const 'Sub' $P7689 = "393_1304516047.681" 
    $P7687."add_method"($P7688, "!PREFIX__metachar:sym<nqpvar>", $P7689)
    nqp_get_sc_object $P7690, "1304516035.536", 360
    get_how $P7691, $P7690
    nqp_get_sc_object $P7692, "1304516035.536", 360
    .const 'Sub' $P7693 = "394_1304516047.681" 
    $P7691."add_method"($P7692, "assertion:sym<{ }>", $P7693)
    nqp_get_sc_object $P7694, "1304516035.536", 360
    get_how $P7695, $P7694
    nqp_get_sc_object $P7696, "1304516035.536", 360
    .const 'Sub' $P7697 = "395_1304516047.681" 
    $P7695."add_method"($P7696, "!PREFIX__assertion:sym<{ }>", $P7697)
    nqp_get_sc_object $P7698, "1304516035.536", 360
    get_how $P7699, $P7698
    nqp_get_sc_object $P7700, "1304516035.536", 360
    .const 'Sub' $P7701 = "396_1304516047.681" 
    $P7699."add_method"($P7700, "assertion:sym<?{ }>", $P7701)
    nqp_get_sc_object $P7702, "1304516035.536", 360
    get_how $P7703, $P7702
    nqp_get_sc_object $P7704, "1304516035.536", 360
    .const 'Sub' $P7705 = "398_1304516047.681" 
    $P7703."add_method"($P7704, "!PREFIX__assertion:sym<?{ }>", $P7705)
    nqp_get_sc_object $P7706, "1304516035.536", 360
    get_how $P7707, $P7706
    nqp_get_sc_object $P7708, "1304516035.536", 360
    .const 'Sub' $P7709 = "399_1304516047.681" 
    $P7707."add_method"($P7708, "assertion:sym<name>", $P7709)
    nqp_get_sc_object $P7710, "1304516035.536", 360
    get_how $P7711, $P7710
    nqp_get_sc_object $P7712, "1304516035.536", 360
    .const 'Sub' $P7713 = "401_1304516047.681" 
    $P7711."add_method"($P7712, "!PREFIX__assertion:sym<name>", $P7713)
    nqp_get_sc_object $P7714, "1304516035.536", 360
    get_how $P7715, $P7714
    nqp_get_sc_object $P7716, "1304516035.536", 360
    .const 'Sub' $P7717 = "402_1304516047.681" 
    $P7715."add_method"($P7716, "assertion:sym<var>", $P7717)
    nqp_get_sc_object $P7718, "1304516035.536", 360
    get_how $P7719, $P7718
    nqp_get_sc_object $P7720, "1304516035.536", 360
    .const 'Sub' $P7721 = "403_1304516047.681" 
    $P7719."add_method"($P7720, "!PREFIX__assertion:sym<var>", $P7721)
    nqp_get_sc_object $P7722, "1304516035.536", 360
    get_how $P7723, $P7722
    nqp_get_sc_object $P7724, "1304516035.536", 360
    .const 'Sub' $P7725 = "404_1304516047.681" 
    $P7723."add_method"($P7724, "codeblock", $P7725)
    nqp_get_sc_object $P7726, "1304516035.536", 360
    get_how $P7727, $P7726
    nqp_get_sc_object $P7728, "1304516035.536", 360
    .const 'Sub' $P7729 = "405_1304516047.681" 
    $P7727."add_method"($P7728, "!PREFIX__codeblock", $P7729)
    .const 'Sub' $P7730 = "385_1304516047.681" 
    $P7731 = $P7730."get_lexinfo"()
    nqp_get_sc_object $P7732, "1304516035.536", 360
    $P7731."set_static_lexpad_value"("$?PACKAGE", $P7732)
    .const 'Sub' $P7733 = "385_1304516047.681" 
    $P7734 = $P7733."get_lexinfo"()
    $P7734."finish_static_lexpad"()
    .const 'Sub' $P7735 = "385_1304516047.681" 
    $P7736 = $P7735."get_lexinfo"()
    nqp_get_sc_object $P7737, "1304516035.536", 360
    $P7736."set_static_lexpad_value"("$?CLASS", $P7737)
    .const 'Sub' $P7738 = "385_1304516047.681" 
    $P7739 = $P7738."get_lexinfo"()
    $P7739."finish_static_lexpad"()
    nqp_get_sc_object $P7740, "1304516035.536", 360
    get_how $P7741, $P7740
    nqp_get_sc_object $P7742, "1304516035.536", 360
    nqp_get_sc_object $P7743, "1304516028.563", 1
    $P7741."add_parent"($P7742, $P7743)
    nqp_get_sc_object $P7744, "1304516035.536", 360
    get_how $P7745, $P7744
    nqp_get_sc_object $P7746, "1304516035.536", 360
    $P7745."compose"($P7746)
    nqp_get_sc_object $P7747, "1304516008.504", 41
    $P7748 = $P7747."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P7748, cur_sc
    nqp_set_sc_object "1304516035.536", 377, $P7748
    nqp_get_sc_object $P7749, "1304516035.536", 377
    nqp_get_sc_object $P7750, "1304516035.536", 0
    nqp_get_package_through_who $P7751, $P7750, "NQP"
    get_who $P7752, $P7751
    set $P7752["Actions"], $P7749
    nqp_get_sc_object $P7753, "1304516035.536", 377
    get_how $P7754, $P7753
    nqp_get_sc_object $P7755, "1304516035.536", 377
    .const 'Sub' $P7756 = "433_1304516047.681" 
    $P7754."add_method"($P7755, "TOP", $P7756)
    nqp_get_sc_object $P7757, "1304516035.536", 377
    get_how $P7758, $P7757
    nqp_get_sc_object $P7759, "1304516035.536", 377
    .const 'Sub' $P7760 = "434_1304516047.681" 
    $P7758."add_method"($P7759, "deflongname", $P7760)
    nqp_get_sc_object $P7761, "1304516035.536", 377
    get_how $P7762, $P7761
    nqp_get_sc_object $P7763, "1304516035.536", 377
    .const 'Sub' $P7764 = "435_1304516047.681" 
    $P7762."add_method"($P7763, "comp_unit", $P7764)
    nqp_get_sc_object $P7765, "1304516035.536", 377
    get_how $P7766, $P7765
    nqp_get_sc_object $P7767, "1304516035.536", 377
    .const 'Sub' $P7768 = "436_1304516047.681" 
    $P7766."add_method"($P7767, "statementlist", $P7768)
    nqp_get_sc_object $P7769, "1304516035.536", 377
    get_how $P7770, $P7769
    nqp_get_sc_object $P7771, "1304516035.536", 377
    .const 'Sub' $P7772 = "438_1304516047.681" 
    $P7770."add_method"($P7771, "statement", $P7772)
    nqp_get_sc_object $P7773, "1304516035.536", 377
    get_how $P7774, $P7773
    nqp_get_sc_object $P7775, "1304516035.536", 377
    .const 'Sub' $P7776 = "440_1304516047.681" 
    $P7774."add_method"($P7775, "xblock", $P7776)
    nqp_get_sc_object $P7777, "1304516035.536", 377
    get_how $P7778, $P7777
    nqp_get_sc_object $P7779, "1304516035.536", 377
    .const 'Sub' $P7780 = "441_1304516047.681" 
    $P7778."add_method"($P7779, "pblock", $P7780)
    nqp_get_sc_object $P7781, "1304516035.536", 377
    get_how $P7782, $P7781
    nqp_get_sc_object $P7783, "1304516035.536", 377
    .const 'Sub' $P7784 = "442_1304516047.681" 
    $P7782."add_method"($P7783, "block", $P7784)
    nqp_get_sc_object $P7785, "1304516035.536", 377
    get_how $P7786, $P7785
    nqp_get_sc_object $P7787, "1304516035.536", 377
    .const 'Sub' $P7788 = "443_1304516047.681" 
    $P7786."add_method"($P7787, "blockoid", $P7788)
    nqp_get_sc_object $P7789, "1304516035.536", 377
    get_how $P7790, $P7789
    nqp_get_sc_object $P7791, "1304516035.536", 377
    .const 'Sub' $P7792 = "445_1304516047.681" 
    $P7790."add_method"($P7791, "newpad", $P7792)
    nqp_get_sc_object $P7793, "1304516035.536", 377
    get_how $P7794, $P7793
    nqp_get_sc_object $P7795, "1304516035.536", 377
    .const 'Sub' $P7796 = "446_1304516047.681" 
    $P7794."add_method"($P7795, "outerctx", $P7796)
    nqp_get_sc_object $P7797, "1304516035.536", 377
    get_how $P7798, $P7797
    nqp_get_sc_object $P7799, "1304516035.536", 377
    .const 'Sub' $P7800 = "448_1304516047.681" 
    $P7798."add_method"($P7799, "GLOBALish", $P7800)
    nqp_get_sc_object $P7801, "1304516035.536", 377
    get_how $P7802, $P7801
    nqp_get_sc_object $P7803, "1304516035.536", 377
    .const 'Sub' $P7804 = "449_1304516047.681" 
    $P7802."add_method"($P7803, "you_are_here", $P7804)
    nqp_get_sc_object $P7805, "1304516035.536", 377
    get_how $P7806, $P7805
    nqp_get_sc_object $P7807, "1304516035.536", 377
    .const 'Sub' $P7808 = "450_1304516047.681" 
    $P7806."add_method"($P7807, "statement_control:sym<use>", $P7808)
    nqp_get_sc_object $P7809, "1304516035.536", 377
    get_how $P7810, $P7809
    nqp_get_sc_object $P7811, "1304516035.536", 377
    .const 'Sub' $P7812 = "451_1304516047.681" 
    $P7810."add_method"($P7811, "statement_control:sym<if>", $P7812)
    nqp_get_sc_object $P7813, "1304516035.536", 377
    get_how $P7814, $P7813
    nqp_get_sc_object $P7815, "1304516035.536", 377
    .const 'Sub' $P7816 = "453_1304516047.681" 
    $P7814."add_method"($P7815, "statement_control:sym<unless>", $P7816)
    nqp_get_sc_object $P7817, "1304516035.536", 377
    get_how $P7818, $P7817
    nqp_get_sc_object $P7819, "1304516035.536", 377
    .const 'Sub' $P7820 = "454_1304516047.681" 
    $P7818."add_method"($P7819, "statement_control:sym<while>", $P7820)
    nqp_get_sc_object $P7821, "1304516035.536", 377
    get_how $P7822, $P7821
    nqp_get_sc_object $P7823, "1304516035.536", 377
    .const 'Sub' $P7824 = "455_1304516047.681" 
    $P7822."add_method"($P7823, "statement_control:sym<repeat>", $P7824)
    nqp_get_sc_object $P7825, "1304516035.536", 377
    get_how $P7826, $P7825
    nqp_get_sc_object $P7827, "1304516035.536", 377
    .const 'Sub' $P7828 = "456_1304516047.681" 
    $P7826."add_method"($P7827, "statement_control:sym<for>", $P7828)
    nqp_get_sc_object $P7829, "1304516035.536", 377
    get_how $P7830, $P7829
    nqp_get_sc_object $P7831, "1304516035.536", 377
    .const 'Sub' $P7832 = "457_1304516047.681" 
    $P7830."add_method"($P7831, "statement_control:sym<CATCH>", $P7832)
    nqp_get_sc_object $P7833, "1304516035.536", 377
    get_how $P7834, $P7833
    nqp_get_sc_object $P7835, "1304516035.536", 377
    .const 'Sub' $P7836 = "458_1304516047.681" 
    $P7834."add_method"($P7835, "statement_control:sym<CONTROL>", $P7836)
    nqp_get_sc_object $P7837, "1304516035.536", 377
    get_how $P7838, $P7837
    nqp_get_sc_object $P7839, "1304516035.536", 377
    .const 'Sub' $P7840 = "459_1304516047.681" 
    $P7838."add_method"($P7839, "statement_prefix:sym<INIT>", $P7840)
    nqp_get_sc_object $P7841, "1304516035.536", 377
    get_how $P7842, $P7841
    nqp_get_sc_object $P7843, "1304516035.536", 377
    .const 'Sub' $P7844 = "460_1304516047.681" 
    $P7842."add_method"($P7843, "statement_prefix:sym<try>", $P7844)
    nqp_get_sc_object $P7845, "1304516035.536", 377
    get_how $P7846, $P7845
    nqp_get_sc_object $P7847, "1304516035.536", 377
    .const 'Sub' $P7848 = "461_1304516047.681" 
    $P7846."add_method"($P7847, "blorst", $P7848)
    nqp_get_sc_object $P7849, "1304516035.536", 377
    get_how $P7850, $P7849
    nqp_get_sc_object $P7851, "1304516035.536", 377
    .const 'Sub' $P7852 = "462_1304516047.681" 
    $P7850."add_method"($P7851, "statement_mod_cond:sym<if>", $P7852)
    nqp_get_sc_object $P7853, "1304516035.536", 377
    get_how $P7854, $P7853
    nqp_get_sc_object $P7855, "1304516035.536", 377
    .const 'Sub' $P7856 = "463_1304516047.681" 
    $P7854."add_method"($P7855, "statement_mod_cond:sym<unless>", $P7856)
    nqp_get_sc_object $P7857, "1304516035.536", 377
    get_how $P7858, $P7857
    nqp_get_sc_object $P7859, "1304516035.536", 377
    .const 'Sub' $P7860 = "464_1304516047.681" 
    $P7858."add_method"($P7859, "statement_mod_loop:sym<while>", $P7860)
    nqp_get_sc_object $P7861, "1304516035.536", 377
    get_how $P7862, $P7861
    nqp_get_sc_object $P7863, "1304516035.536", 377
    .const 'Sub' $P7864 = "465_1304516047.681" 
    $P7862."add_method"($P7863, "statement_mod_loop:sym<until>", $P7864)
    nqp_get_sc_object $P7865, "1304516035.536", 377
    get_how $P7866, $P7865
    nqp_get_sc_object $P7867, "1304516035.536", 377
    .const 'Sub' $P7868 = "466_1304516047.681" 
    $P7866."add_method"($P7867, "term:sym<fatarrow>", $P7868)
    nqp_get_sc_object $P7869, "1304516035.536", 377
    get_how $P7870, $P7869
    nqp_get_sc_object $P7871, "1304516035.536", 377
    .const 'Sub' $P7872 = "467_1304516047.681" 
    $P7870."add_method"($P7871, "term:sym<colonpair>", $P7872)
    nqp_get_sc_object $P7873, "1304516035.536", 377
    get_how $P7874, $P7873
    nqp_get_sc_object $P7875, "1304516035.536", 377
    .const 'Sub' $P7876 = "468_1304516047.681" 
    $P7874."add_method"($P7875, "term:sym<variable>", $P7876)
    nqp_get_sc_object $P7877, "1304516035.536", 377
    get_how $P7878, $P7877
    nqp_get_sc_object $P7879, "1304516035.536", 377
    .const 'Sub' $P7880 = "469_1304516047.681" 
    $P7878."add_method"($P7879, "term:sym<package_declarator>", $P7880)
    nqp_get_sc_object $P7881, "1304516035.536", 377
    get_how $P7882, $P7881
    nqp_get_sc_object $P7883, "1304516035.536", 377
    .const 'Sub' $P7884 = "470_1304516047.681" 
    $P7882."add_method"($P7883, "term:sym<scope_declarator>", $P7884)
    nqp_get_sc_object $P7885, "1304516035.536", 377
    get_how $P7886, $P7885
    nqp_get_sc_object $P7887, "1304516035.536", 377
    .const 'Sub' $P7888 = "471_1304516047.681" 
    $P7886."add_method"($P7887, "term:sym<routine_declarator>", $P7888)
    nqp_get_sc_object $P7889, "1304516035.536", 377
    get_how $P7890, $P7889
    nqp_get_sc_object $P7891, "1304516035.536", 377
    .const 'Sub' $P7892 = "472_1304516047.681" 
    $P7890."add_method"($P7891, "term:sym<regex_declarator>", $P7892)
    nqp_get_sc_object $P7893, "1304516035.536", 377
    get_how $P7894, $P7893
    nqp_get_sc_object $P7895, "1304516035.536", 377
    .const 'Sub' $P7896 = "473_1304516047.681" 
    $P7894."add_method"($P7895, "term:sym<statement_prefix>", $P7896)
    nqp_get_sc_object $P7897, "1304516035.536", 377
    get_how $P7898, $P7897
    nqp_get_sc_object $P7899, "1304516035.536", 377
    .const 'Sub' $P7900 = "474_1304516047.681" 
    $P7898."add_method"($P7899, "term:sym<lambda>", $P7900)
    nqp_get_sc_object $P7901, "1304516035.536", 377
    get_how $P7902, $P7901
    nqp_get_sc_object $P7903, "1304516035.536", 377
    .const 'Sub' $P7904 = "475_1304516047.681" 
    $P7902."add_method"($P7903, "fatarrow", $P7904)
    nqp_get_sc_object $P7905, "1304516035.536", 377
    get_how $P7906, $P7905
    nqp_get_sc_object $P7907, "1304516035.536", 377
    .const 'Sub' $P7908 = "476_1304516047.681" 
    $P7906."add_method"($P7907, "colonpair", $P7908)
    nqp_get_sc_object $P7909, "1304516035.536", 377
    get_how $P7910, $P7909
    nqp_get_sc_object $P7911, "1304516035.536", 377
    .const 'Sub' $P7912 = "477_1304516047.681" 
    $P7910."add_method"($P7911, "variable", $P7912)
    nqp_get_sc_object $P7913, "1304516035.536", 377
    get_how $P7914, $P7913
    nqp_get_sc_object $P7915, "1304516035.536", 377
    .const 'Sub' $P7916 = "483_1304516047.681" 
    $P7914."add_method"($P7915, "package_declarator:sym<module>", $P7916)
    nqp_get_sc_object $P7917, "1304516035.536", 377
    get_how $P7918, $P7917
    nqp_get_sc_object $P7919, "1304516035.536", 377
    .const 'Sub' $P7920 = "484_1304516047.681" 
    $P7918."add_method"($P7919, "package_declarator:sym<knowhow>", $P7920)
    nqp_get_sc_object $P7921, "1304516035.536", 377
    get_how $P7922, $P7921
    nqp_get_sc_object $P7923, "1304516035.536", 377
    .const 'Sub' $P7924 = "485_1304516047.681" 
    $P7922."add_method"($P7923, "package_declarator:sym<class>", $P7924)
    nqp_get_sc_object $P7925, "1304516035.536", 377
    get_how $P7926, $P7925
    nqp_get_sc_object $P7927, "1304516035.536", 377
    .const 'Sub' $P7928 = "486_1304516047.681" 
    $P7926."add_method"($P7927, "package_declarator:sym<grammar>", $P7928)
    nqp_get_sc_object $P7929, "1304516035.536", 377
    get_how $P7930, $P7929
    nqp_get_sc_object $P7931, "1304516035.536", 377
    .const 'Sub' $P7932 = "487_1304516047.681" 
    $P7930."add_method"($P7931, "package_declarator:sym<role>", $P7932)
    nqp_get_sc_object $P7933, "1304516035.536", 377
    get_how $P7934, $P7933
    nqp_get_sc_object $P7935, "1304516035.536", 377
    .const 'Sub' $P7936 = "488_1304516047.681" 
    $P7934."add_method"($P7935, "package_declarator:sym<native>", $P7936)
    nqp_get_sc_object $P7937, "1304516035.536", 377
    get_how $P7938, $P7937
    nqp_get_sc_object $P7939, "1304516035.536", 377
    .const 'Sub' $P7940 = "489_1304516047.681" 
    $P7938."add_method"($P7939, "package_def", $P7940)
    nqp_get_sc_object $P7941, "1304516035.536", 377
    get_how $P7942, $P7941
    nqp_get_sc_object $P7943, "1304516035.536", 377
    .const 'Sub' $P7944 = "495_1304516047.681" 
    $P7942."add_method"($P7943, "scope_declarator:sym<my>", $P7944)
    nqp_get_sc_object $P7945, "1304516035.536", 377
    get_how $P7946, $P7945
    nqp_get_sc_object $P7947, "1304516035.536", 377
    .const 'Sub' $P7948 = "496_1304516047.681" 
    $P7946."add_method"($P7947, "scope_declarator:sym<our>", $P7948)
    nqp_get_sc_object $P7949, "1304516035.536", 377
    get_how $P7950, $P7949
    nqp_get_sc_object $P7951, "1304516035.536", 377
    .const 'Sub' $P7952 = "497_1304516047.681" 
    $P7950."add_method"($P7951, "scope_declarator:sym<has>", $P7952)
    nqp_get_sc_object $P7953, "1304516035.536", 377
    get_how $P7954, $P7953
    nqp_get_sc_object $P7955, "1304516035.536", 377
    .const 'Sub' $P7956 = "498_1304516047.681" 
    $P7954."add_method"($P7955, "scoped", $P7956)
    nqp_get_sc_object $P7957, "1304516035.536", 377
    get_how $P7958, $P7957
    nqp_get_sc_object $P7959, "1304516035.536", 377
    .const 'Sub' $P7960 = "499_1304516047.681" 
    $P7958."add_method"($P7959, "declarator", $P7960)
    nqp_get_sc_object $P7961, "1304516035.536", 377
    get_how $P7962, $P7961
    nqp_get_sc_object $P7963, "1304516035.536", 377
    .const 'Sub' $P7964 = "500_1304516047.681" 
    $P7962."add_method"($P7963, "multi_declarator:sym<multi>", $P7964)
    nqp_get_sc_object $P7965, "1304516035.536", 377
    get_how $P7966, $P7965
    nqp_get_sc_object $P7967, "1304516035.536", 377
    .const 'Sub' $P7968 = "501_1304516047.681" 
    $P7966."add_method"($P7967, "multi_declarator:sym<proto>", $P7968)
    nqp_get_sc_object $P7969, "1304516035.536", 377
    get_how $P7970, $P7969
    nqp_get_sc_object $P7971, "1304516035.536", 377
    .const 'Sub' $P7972 = "502_1304516047.681" 
    $P7970."add_method"($P7971, "multi_declarator:sym<null>", $P7972)
    nqp_get_sc_object $P7973, "1304516035.536", 377
    get_how $P7974, $P7973
    nqp_get_sc_object $P7975, "1304516035.536", 377
    .const 'Sub' $P7976 = "503_1304516047.681" 
    $P7974."add_method"($P7975, "variable_declarator", $P7976)
    nqp_get_sc_object $P7977, "1304516035.536", 377
    get_how $P7978, $P7977
    nqp_get_sc_object $P7979, "1304516035.536", 377
    .const 'Sub' $P7980 = "505_1304516047.681" 
    $P7978."add_method"($P7979, "routine_declarator:sym<sub>", $P7980)
    nqp_get_sc_object $P7981, "1304516035.536", 377
    get_how $P7982, $P7981
    nqp_get_sc_object $P7983, "1304516035.536", 377
    .const 'Sub' $P7984 = "506_1304516047.681" 
    $P7982."add_method"($P7983, "routine_declarator:sym<method>", $P7984)
    nqp_get_sc_object $P7985, "1304516035.536", 377
    get_how $P7986, $P7985
    nqp_get_sc_object $P7987, "1304516035.536", 377
    .const 'Sub' $P7988 = "507_1304516047.681" 
    $P7986."add_method"($P7987, "routine_def", $P7988)
    nqp_get_sc_object $P7989, "1304516035.536", 377
    get_how $P7990, $P7989
    nqp_get_sc_object $P7991, "1304516035.536", 377
    .const 'Sub' $P7992 = "514_1304516047.681" 
    $P7990."add_method"($P7991, "method_def", $P7992)
    nqp_get_sc_object $P7993, "1304516035.536", 377
    get_how $P7994, $P7993
    nqp_get_sc_object $P7995, "1304516035.536", 377
    .const 'Sub' $P7996 = "517_1304516047.681" 
    $P7994."add_method"($P7995, "signature", $P7996)
    nqp_get_sc_object $P7997, "1304516035.536", 377
    get_how $P7998, $P7997
    nqp_get_sc_object $P7999, "1304516035.536", 377
    .const 'Sub' $P8000 = "520_1304516047.681" 
    $P7998."add_method"($P7999, "parameter", $P8000)
    nqp_get_sc_object $P8001, "1304516035.536", 377
    get_how $P8002, $P8001
    nqp_get_sc_object $P8003, "1304516035.536", 377
    .const 'Sub' $P8004 = "521_1304516047.681" 
    $P8002."add_method"($P8003, "param_var", $P8004)
    nqp_get_sc_object $P8005, "1304516035.536", 377
    get_how $P8006, $P8005
    nqp_get_sc_object $P8007, "1304516035.536", 377
    .const 'Sub' $P8008 = "522_1304516047.681" 
    $P8006."add_method"($P8007, "named_param", $P8008)
    nqp_get_sc_object $P8009, "1304516035.536", 377
    get_how $P8010, $P8009
    nqp_get_sc_object $P8011, "1304516035.536", 377
    .const 'Sub' $P8012 = "523_1304516047.681" 
    $P8010."add_method"($P8011, "typename", $P8012)
    nqp_get_sc_object $P8013, "1304516035.536", 377
    get_how $P8014, $P8013
    nqp_get_sc_object $P8015, "1304516035.536", 377
    .const 'Sub' $P8016 = "525_1304516047.681" 
    $P8014."add_method"($P8015, "trait", $P8016)
    nqp_get_sc_object $P8017, "1304516035.536", 377
    get_how $P8018, $P8017
    nqp_get_sc_object $P8019, "1304516035.536", 377
    .const 'Sub' $P8020 = "526_1304516047.681" 
    $P8018."add_method"($P8019, "trait_mod:sym<is>", $P8020)
    nqp_get_sc_object $P8021, "1304516035.536", 377
    get_how $P8022, $P8021
    nqp_get_sc_object $P8023, "1304516035.536", 377
    .const 'Sub' $P8024 = "529_1304516047.681" 
    $P8022."add_method"($P8023, "regex_declarator", $P8024)
    nqp_get_sc_object $P8025, "1304516035.536", 377
    get_how $P8026, $P8025
    nqp_get_sc_object $P8027, "1304516035.536", 377
    .const 'Sub' $P8028 = "534_1304516047.681" 
    $P8026."add_method"($P8027, "dotty", $P8028)
    nqp_get_sc_object $P8029, "1304516035.536", 377
    get_how $P8030, $P8029
    nqp_get_sc_object $P8031, "1304516035.536", 377
    .const 'Sub' $P8032 = "535_1304516047.681" 
    $P8030."add_method"($P8031, "term:sym<self>", $P8032)
    nqp_get_sc_object $P8033, "1304516035.536", 377
    get_how $P8034, $P8033
    nqp_get_sc_object $P8035, "1304516035.536", 377
    .const 'Sub' $P8036 = "536_1304516047.681" 
    $P8034."add_method"($P8035, "term:sym<identifier>", $P8036)
    nqp_get_sc_object $P8037, "1304516035.536", 377
    get_how $P8038, $P8037
    nqp_get_sc_object $P8039, "1304516035.536", 377
    .const 'Sub' $P8040 = "537_1304516047.681" 
    $P8038."add_method"($P8039, "term:sym<name>", $P8040)
    nqp_get_sc_object $P8041, "1304516035.536", 377
    get_how $P8042, $P8041
    nqp_get_sc_object $P8043, "1304516035.536", 377
    .const 'Sub' $P8044 = "539_1304516047.681" 
    $P8042."add_method"($P8043, "term:sym<pir::op>", $P8044)
    nqp_get_sc_object $P8045, "1304516035.536", 377
    get_how $P8046, $P8045
    nqp_get_sc_object $P8047, "1304516035.536", 377
    .const 'Sub' $P8048 = "540_1304516047.681" 
    $P8046."add_method"($P8047, "term:sym<onlystar>", $P8048)
    nqp_get_sc_object $P8049, "1304516035.536", 377
    get_how $P8050, $P8049
    nqp_get_sc_object $P8051, "1304516035.536", 377
    .const 'Sub' $P8052 = "541_1304516047.681" 
    $P8050."add_method"($P8051, "args", $P8052)
    nqp_get_sc_object $P8053, "1304516035.536", 377
    get_how $P8054, $P8053
    nqp_get_sc_object $P8055, "1304516035.536", 377
    .const 'Sub' $P8056 = "542_1304516047.681" 
    $P8054."add_method"($P8055, "arglist", $P8056)
    nqp_get_sc_object $P8057, "1304516035.536", 377
    get_how $P8058, $P8057
    nqp_get_sc_object $P8059, "1304516035.536", 377
    .const 'Sub' $P8060 = "545_1304516047.681" 
    $P8058."add_method"($P8059, "term:sym<multi_declarator>", $P8060)
    nqp_get_sc_object $P8061, "1304516035.536", 377
    get_how $P8062, $P8061
    nqp_get_sc_object $P8063, "1304516035.536", 377
    .const 'Sub' $P8064 = "546_1304516047.681" 
    $P8062."add_method"($P8063, "term:sym<value>", $P8064)
    nqp_get_sc_object $P8065, "1304516035.536", 377
    get_how $P8066, $P8065
    nqp_get_sc_object $P8067, "1304516035.536", 377
    .const 'Sub' $P8068 = "547_1304516047.681" 
    $P8066."add_method"($P8067, "circumfix:sym<( )>", $P8068)
    nqp_get_sc_object $P8069, "1304516035.536", 377
    get_how $P8070, $P8069
    nqp_get_sc_object $P8071, "1304516035.536", 377
    .const 'Sub' $P8072 = "548_1304516047.681" 
    $P8070."add_method"($P8071, "circumfix:sym<[ ]>", $P8072)
    nqp_get_sc_object $P8073, "1304516035.536", 377
    get_how $P8074, $P8073
    nqp_get_sc_object $P8075, "1304516035.536", 377
    .const 'Sub' $P8076 = "549_1304516047.681" 
    $P8074."add_method"($P8075, "circumfix:sym<ang>", $P8076)
    nqp_get_sc_object $P8077, "1304516035.536", 377
    get_how $P8078, $P8077
    nqp_get_sc_object $P8079, "1304516035.536", 377
    .const 'Sub' $P8080 = "550_1304516047.681" 
    $P8078."add_method"($P8079, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P8080)
    nqp_get_sc_object $P8081, "1304516035.536", 377
    get_how $P8082, $P8081
    nqp_get_sc_object $P8083, "1304516035.536", 377
    .const 'Sub' $P8084 = "551_1304516047.681" 
    $P8082."add_method"($P8083, "circumfix:sym<{ }>", $P8084)
    nqp_get_sc_object $P8085, "1304516035.536", 377
    get_how $P8086, $P8085
    nqp_get_sc_object $P8087, "1304516035.536", 377
    .const 'Sub' $P8088 = "553_1304516047.681" 
    $P8086."add_method"($P8087, "circumfix:sym<sigil>", $P8088)
    nqp_get_sc_object $P8089, "1304516035.536", 377
    get_how $P8090, $P8089
    nqp_get_sc_object $P8091, "1304516035.536", 377
    .const 'Sub' $P8092 = "554_1304516047.681" 
    $P8090."add_method"($P8091, "semilist", $P8092)
    nqp_get_sc_object $P8093, "1304516035.536", 377
    get_how $P8094, $P8093
    nqp_get_sc_object $P8095, "1304516035.536", 377
    .const 'Sub' $P8096 = "555_1304516047.681" 
    $P8094."add_method"($P8095, "postcircumfix:sym<[ ]>", $P8096)
    nqp_get_sc_object $P8097, "1304516035.536", 377
    get_how $P8098, $P8097
    nqp_get_sc_object $P8099, "1304516035.536", 377
    .const 'Sub' $P8100 = "556_1304516047.681" 
    $P8098."add_method"($P8099, "postcircumfix:sym<{ }>", $P8100)
    nqp_get_sc_object $P8101, "1304516035.536", 377
    get_how $P8102, $P8101
    nqp_get_sc_object $P8103, "1304516035.536", 377
    .const 'Sub' $P8104 = "557_1304516047.681" 
    $P8102."add_method"($P8103, "postcircumfix:sym<ang>", $P8104)
    nqp_get_sc_object $P8105, "1304516035.536", 377
    get_how $P8106, $P8105
    nqp_get_sc_object $P8107, "1304516035.536", 377
    .const 'Sub' $P8108 = "558_1304516047.681" 
    $P8106."add_method"($P8107, "postcircumfix:sym<( )>", $P8108)
    nqp_get_sc_object $P8109, "1304516035.536", 377
    get_how $P8110, $P8109
    nqp_get_sc_object $P8111, "1304516035.536", 377
    .const 'Sub' $P8112 = "559_1304516047.681" 
    $P8110."add_method"($P8111, "value", $P8112)
    nqp_get_sc_object $P8113, "1304516035.536", 377
    get_how $P8114, $P8113
    nqp_get_sc_object $P8115, "1304516035.536", 377
    .const 'Sub' $P8116 = "560_1304516047.681" 
    $P8114."add_method"($P8115, "number", $P8116)
    nqp_get_sc_object $P8117, "1304516035.536", 377
    get_how $P8118, $P8117
    nqp_get_sc_object $P8119, "1304516035.536", 377
    .const 'Sub' $P8120 = "561_1304516047.681" 
    $P8118."add_method"($P8119, "quote:sym<apos>", $P8120)
    nqp_get_sc_object $P8121, "1304516035.536", 377
    get_how $P8122, $P8121
    nqp_get_sc_object $P8123, "1304516035.536", 377
    .const 'Sub' $P8124 = "562_1304516047.681" 
    $P8122."add_method"($P8123, "quote:sym<dblq>", $P8124)
    nqp_get_sc_object $P8125, "1304516035.536", 377
    get_how $P8126, $P8125
    nqp_get_sc_object $P8127, "1304516035.536", 377
    .const 'Sub' $P8128 = "563_1304516047.681" 
    $P8126."add_method"($P8127, "quote:sym<qq>", $P8128)
    nqp_get_sc_object $P8129, "1304516035.536", 377
    get_how $P8130, $P8129
    nqp_get_sc_object $P8131, "1304516035.536", 377
    .const 'Sub' $P8132 = "564_1304516047.681" 
    $P8130."add_method"($P8131, "quote:sym<q>", $P8132)
    nqp_get_sc_object $P8133, "1304516035.536", 377
    get_how $P8134, $P8133
    nqp_get_sc_object $P8135, "1304516035.536", 377
    .const 'Sub' $P8136 = "565_1304516047.681" 
    $P8134."add_method"($P8135, "quote:sym<Q>", $P8136)
    nqp_get_sc_object $P8137, "1304516035.536", 377
    get_how $P8138, $P8137
    nqp_get_sc_object $P8139, "1304516035.536", 377
    .const 'Sub' $P8140 = "566_1304516047.681" 
    $P8138."add_method"($P8139, "quote:sym<Q:PIR>", $P8140)
    nqp_get_sc_object $P8141, "1304516035.536", 377
    get_how $P8142, $P8141
    nqp_get_sc_object $P8143, "1304516035.536", 377
    .const 'Sub' $P8144 = "567_1304516047.681" 
    $P8142."add_method"($P8143, "quote:sym</ />", $P8144)
    nqp_get_sc_object $P8145, "1304516035.536", 377
    get_how $P8146, $P8145
    nqp_get_sc_object $P8147, "1304516035.536", 377
    .const 'Sub' $P8148 = "568_1304516047.681" 
    $P8146."add_method"($P8147, "quote_escape:sym<$>", $P8148)
    nqp_get_sc_object $P8149, "1304516035.536", 377
    get_how $P8150, $P8149
    nqp_get_sc_object $P8151, "1304516035.536", 377
    .const 'Sub' $P8152 = "569_1304516047.681" 
    $P8150."add_method"($P8151, "quote_escape:sym<{ }>", $P8152)
    nqp_get_sc_object $P8153, "1304516035.536", 377
    get_how $P8154, $P8153
    nqp_get_sc_object $P8155, "1304516035.536", 377
    .const 'Sub' $P8156 = "570_1304516047.681" 
    $P8154."add_method"($P8155, "quote_escape:sym<esc>", $P8156)
    nqp_get_sc_object $P8157, "1304516035.536", 377
    get_how $P8158, $P8157
    nqp_get_sc_object $P8159, "1304516035.536", 377
    .const 'Sub' $P8160 = "571_1304516047.681" 
    $P8158."add_method"($P8159, "postfix:sym<.>", $P8160)
    nqp_get_sc_object $P8161, "1304516035.536", 377
    get_how $P8162, $P8161
    nqp_get_sc_object $P8163, "1304516035.536", 377
    .const 'Sub' $P8164 = "572_1304516047.681" 
    $P8162."add_method"($P8163, "postfix:sym<++>", $P8164)
    nqp_get_sc_object $P8165, "1304516035.536", 377
    get_how $P8166, $P8165
    nqp_get_sc_object $P8167, "1304516035.536", 377
    .const 'Sub' $P8168 = "573_1304516047.681" 
    $P8166."add_method"($P8167, "postfix:sym<-->", $P8168)
    nqp_get_sc_object $P8169, "1304516035.536", 377
    get_how $P8170, $P8169
    nqp_get_sc_object $P8171, "1304516035.536", 377
    .const 'Sub' $P8172 = "574_1304516047.681" 
    $P8170."add_method"($P8171, "prefix:sym<make>", $P8172)
    nqp_get_sc_object $P8173, "1304516035.536", 377
    get_how $P8174, $P8173
    nqp_get_sc_object $P8175, "1304516035.536", 377
    .const 'Sub' $P8176 = "575_1304516047.681" 
    $P8174."add_method"($P8175, "term:sym<next>", $P8176)
    nqp_get_sc_object $P8177, "1304516035.536", 377
    get_how $P8178, $P8177
    nqp_get_sc_object $P8179, "1304516035.536", 377
    .const 'Sub' $P8180 = "576_1304516047.681" 
    $P8178."add_method"($P8179, "term:sym<last>", $P8180)
    nqp_get_sc_object $P8181, "1304516035.536", 377
    get_how $P8182, $P8181
    nqp_get_sc_object $P8183, "1304516035.536", 377
    .const 'Sub' $P8184 = "577_1304516047.681" 
    $P8182."add_method"($P8183, "term:sym<redo>", $P8184)
    nqp_get_sc_object $P8185, "1304516035.536", 377
    get_how $P8186, $P8185
    nqp_get_sc_object $P8187, "1304516035.536", 377
    .const 'Sub' $P8188 = "578_1304516047.681" 
    $P8186."add_method"($P8187, "infix:sym<~~>", $P8188)
    nqp_get_sc_object $P8189, "1304516035.536", 377
    get_how $P8190, $P8189
    nqp_get_sc_object $P8191, "1304516035.536", 377
    .const 'Sub' $P8192 = "579_1304516047.681" 
    $P8190."add_method"($P8191, "known_sym", $P8192)
    .const 'Sub' $P8193 = "406_1304516047.681" 
    $P8194 = $P8193."get_lexinfo"()
    nqp_get_sc_object $P8195, "1304516035.536", 377
    $P8194."set_static_lexpad_value"("$?PACKAGE", $P8195)
    .const 'Sub' $P8196 = "406_1304516047.681" 
    $P8197 = $P8196."get_lexinfo"()
    $P8197."finish_static_lexpad"()
    .const 'Sub' $P8198 = "406_1304516047.681" 
    $P8199 = $P8198."get_lexinfo"()
    nqp_get_sc_object $P8200, "1304516035.536", 377
    $P8199."set_static_lexpad_value"("$?CLASS", $P8200)
    .const 'Sub' $P8201 = "406_1304516047.681" 
    $P8202 = $P8201."get_lexinfo"()
    $P8202."finish_static_lexpad"()
    nqp_get_sc_object $P8203, "1304516035.536", 377
    get_how $P8204, $P8203
    nqp_get_sc_object $P8205, "1304516035.536", 377
    nqp_get_sc_object $P8206, "1304516016.343", 105
    $P8204."add_parent"($P8205, $P8206)
    nqp_get_sc_object $P8207, "1304516035.536", 377
    get_how $P8208, $P8207
    nqp_get_sc_object $P8209, "1304516035.536", 377
    $P8208."compose"($P8209)
    nqp_get_sc_object $P8210, "1304516008.504", 41
    $P8211 = $P8210."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P8211, cur_sc
    nqp_set_sc_object "1304516035.536", 488, $P8211
    nqp_get_sc_object $P8212, "1304516035.536", 488
    nqp_get_sc_object $P8213, "1304516035.536", 0
    nqp_get_package_through_who $P8214, $P8213, "NQP"
    get_who $P8215, $P8214
    set $P8215["RegexActions"], $P8212
    nqp_get_sc_object $P8216, "1304516035.536", 488
    get_how $P8217, $P8216
    nqp_get_sc_object $P8218, "1304516035.536", 488
    .const 'Sub' $P8219 = "582_1304516047.681" 
    $P8217."add_method"($P8218, "metachar:sym<:my>", $P8219)
    nqp_get_sc_object $P8220, "1304516035.536", 488
    get_how $P8221, $P8220
    nqp_get_sc_object $P8222, "1304516035.536", 488
    .const 'Sub' $P8223 = "583_1304516047.681" 
    $P8221."add_method"($P8222, "metachar:sym<{ }>", $P8223)
    nqp_get_sc_object $P8224, "1304516035.536", 488
    get_how $P8225, $P8224
    nqp_get_sc_object $P8226, "1304516035.536", 488
    .const 'Sub' $P8227 = "584_1304516047.681" 
    $P8225."add_method"($P8226, "metachar:sym<nqpvar>", $P8227)
    nqp_get_sc_object $P8228, "1304516035.536", 488
    get_how $P8229, $P8228
    nqp_get_sc_object $P8230, "1304516035.536", 488
    .const 'Sub' $P8231 = "585_1304516047.681" 
    $P8229."add_method"($P8230, "assertion:sym<{ }>", $P8231)
    nqp_get_sc_object $P8232, "1304516035.536", 488
    get_how $P8233, $P8232
    nqp_get_sc_object $P8234, "1304516035.536", 488
    .const 'Sub' $P8235 = "586_1304516047.681" 
    $P8233."add_method"($P8234, "assertion:sym<?{ }>", $P8235)
    nqp_get_sc_object $P8236, "1304516035.536", 488
    get_how $P8237, $P8236
    nqp_get_sc_object $P8238, "1304516035.536", 488
    .const 'Sub' $P8239 = "587_1304516047.681" 
    $P8237."add_method"($P8238, "assertion:sym<var>", $P8239)
    nqp_get_sc_object $P8240, "1304516035.536", 488
    get_how $P8241, $P8240
    nqp_get_sc_object $P8242, "1304516035.536", 488
    .const 'Sub' $P8243 = "588_1304516047.681" 
    $P8241."add_method"($P8242, "codeblock", $P8243)
    .const 'Sub' $P8244 = "581_1304516047.681" 
    $P8245 = $P8244."get_lexinfo"()
    nqp_get_sc_object $P8246, "1304516035.536", 488
    $P8245."set_static_lexpad_value"("$?PACKAGE", $P8246)
    .const 'Sub' $P8247 = "581_1304516047.681" 
    $P8248 = $P8247."get_lexinfo"()
    $P8248."finish_static_lexpad"()
    .const 'Sub' $P8249 = "581_1304516047.681" 
    $P8250 = $P8249."get_lexinfo"()
    nqp_get_sc_object $P8251, "1304516035.536", 488
    $P8250."set_static_lexpad_value"("$?CLASS", $P8251)
    .const 'Sub' $P8252 = "581_1304516047.681" 
    $P8253 = $P8252."get_lexinfo"()
    $P8253."finish_static_lexpad"()
    nqp_get_sc_object $P8254, "1304516035.536", 488
    get_how $P8255, $P8254
    nqp_get_sc_object $P8256, "1304516035.536", 488
    nqp_get_sc_object $P8257, "1304516028.563", 145
    $P8255."add_parent"($P8256, $P8257)
    nqp_get_sc_object $P8258, "1304516035.536", 488
    get_how $P8259, $P8258
    nqp_get_sc_object $P8260, "1304516035.536", 488
    $P8259."compose"($P8260)
    nqp_get_sc_object $P8261, "1304516008.504", 41
    $P8262 = $P8261."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P8262, cur_sc
    nqp_set_sc_object "1304516035.536", 496, $P8262
    nqp_get_sc_object $P8263, "1304516035.536", 496
    nqp_get_sc_object $P8264, "1304516035.536", 0
    nqp_get_package_through_who $P8265, $P8264, "NQP"
    get_who $P8266, $P8265
    set $P8266["Compiler"], $P8263
    .const 'Sub' $P8267 = "589_1304516047.681" 
    $P8268 = $P8267."get_lexinfo"()
    nqp_get_sc_object $P8269, "1304516035.536", 496
    $P8268."set_static_lexpad_value"("$?PACKAGE", $P8269)
    .const 'Sub' $P8270 = "589_1304516047.681" 
    $P8271 = $P8270."get_lexinfo"()
    $P8271."finish_static_lexpad"()
    .const 'Sub' $P8272 = "589_1304516047.681" 
    $P8273 = $P8272."get_lexinfo"()
    nqp_get_sc_object $P8274, "1304516035.536", 496
    $P8273."set_static_lexpad_value"("$?CLASS", $P8274)
    .const 'Sub' $P8275 = "589_1304516047.681" 
    $P8276 = $P8275."get_lexinfo"()
    $P8276."finish_static_lexpad"()
    nqp_get_sc_object $P8277, "1304516035.536", 496
    get_how $P8278, $P8277
    nqp_get_sc_object $P8279, "1304516035.536", 496
    nqp_get_sc_object $P8280, "1304516016.343", 138
    $P8278."add_parent"($P8279, $P8280)
    nqp_get_sc_object $P8281, "1304516035.536", 496
    get_how $P8282, $P8281
    nqp_get_sc_object $P8283, "1304516035.536", 496
    $P8282."compose"($P8283)
  if_6180_end:
    nqp_get_sc_object $P9326, "1304516035.536", 0
    set_hll_global "GLOBAL", $P9326
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1304516047.681") :outer("10_1304516047.681")
    .param pmc param_17
.annotate 'line', 2269
    .lex "@ARGS", param_17
.annotate 'line', 2271
    new $P18, "Undef"
    .lex "$nqpcomp", $P18
.annotate 'line', 2277
    $P19 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P19
.annotate 'line', 2271
    get_hll_global $P20, "GLOBAL"
    nqp_get_package_through_who $P21, $P20, "NQP"
    get_who $P22, $P21
    set $P23, $P22["Compiler"]
    $P24 = $P23."new"()
    store_lex "$nqpcomp", $P24
.annotate 'line', 2272
    find_lex $P25, "$nqpcomp"
    unless_null $P25, vivify_592
    new $P25, "Undef"
  vivify_592:
    $P25."language"("nqp")
.annotate 'line', 2273
    find_lex $P26, "$nqpcomp"
    unless_null $P26, vivify_593
    new $P26, "Undef"
  vivify_593:
    get_hll_global $P27, "GLOBAL"
    nqp_get_package_through_who $P28, $P27, "NQP"
    get_who $P29, $P28
    set $P30, $P29["Grammar"]
    $P26."parsegrammar"($P30)
.annotate 'line', 2274
    find_lex $P31, "$nqpcomp"
    unless_null $P31, vivify_594
    new $P31, "Undef"
  vivify_594:
    get_hll_global $P32, "GLOBAL"
    nqp_get_package_through_who $P33, $P32, "NQP"
    get_who $P34, $P33
    set $P35, $P34["Actions"]
    $P31."parseactions"($P35)
.annotate 'line', 2277
    find_lex $P36, "$nqpcomp"
    unless_null $P36, vivify_595
    new $P36, "Undef"
  vivify_595:
    $P37 = $P36."commandline_options"()
    store_lex "@clo", $P37
.annotate 'line', 2278
    find_lex $P38, "@clo"
    unless_null $P38, vivify_596
    $P38 = root_new ['parrot';'ResizablePMCArray']
  vivify_596:
    $P38."push"("parsetrace")
.annotate 'line', 2279
    find_lex $P39, "@clo"
    unless_null $P39, vivify_597
    $P39 = root_new ['parrot';'ResizablePMCArray']
  vivify_597:
    $P39."push"("setting=s")
.annotate 'line', 2280
    find_lex $P40, "@clo"
    unless_null $P40, vivify_598
    $P40 = root_new ['parrot';'ResizablePMCArray']
  vivify_598:
    $P40."push"("setting-path=s")
.annotate 'line', 2281
    find_lex $P41, "@clo"
    unless_null $P41, vivify_599
    $P41 = root_new ['parrot';'ResizablePMCArray']
  vivify_599:
    $P41."push"("module-path=s")
.annotate 'line', 2284
    find_lex $P42, "$nqpcomp"
    unless_null $P42, vivify_600
    new $P42, "Undef"
  vivify_600:
    find_lex $P43, "@ARGS"
    unless_null $P43, vivify_601
    $P43 = root_new ['parrot';'ResizablePMCArray']
  vivify_601:
    $P44 = $P42."command_line"($P43, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2269
    .return ($P44)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block46"  :subid("12_1304516047.681") :outer("10_1304516047.681")
.annotate 'line', 9
    .const 'Sub' $P1898 = "384_1304516047.681" 
    capture_lex $P1898
    .const 'Sub' $P1896 = "383_1304516047.681" 
    capture_lex $P1896
    .const 'Sub' $P1892 = "382_1304516047.681" 
    capture_lex $P1892
    .const 'Sub' $P1890 = "381_1304516047.681" 
    capture_lex $P1890
    .const 'Sub' $P1886 = "380_1304516047.681" 
    capture_lex $P1886
    .const 'Sub' $P1884 = "379_1304516047.681" 
    capture_lex $P1884
    .const 'Sub' $P1880 = "378_1304516047.681" 
    capture_lex $P1880
    .const 'Sub' $P1878 = "377_1304516047.681" 
    capture_lex $P1878
    .const 'Sub' $P1874 = "376_1304516047.681" 
    capture_lex $P1874
    .const 'Sub' $P1872 = "375_1304516047.681" 
    capture_lex $P1872
    .const 'Sub' $P1862 = "373_1304516047.681" 
    capture_lex $P1862
    .const 'Sub' $P1859 = "372_1304516047.681" 
    capture_lex $P1859
    .const 'Sub' $P1855 = "371_1304516047.681" 
    capture_lex $P1855
    .const 'Sub' $P1852 = "370_1304516047.681" 
    capture_lex $P1852
    .const 'Sub' $P1848 = "369_1304516047.681" 
    capture_lex $P1848
    .const 'Sub' $P1845 = "368_1304516047.681" 
    capture_lex $P1845
    .const 'Sub' $P1841 = "367_1304516047.681" 
    capture_lex $P1841
    .const 'Sub' $P1838 = "366_1304516047.681" 
    capture_lex $P1838
    .const 'Sub' $P1834 = "365_1304516047.681" 
    capture_lex $P1834
    .const 'Sub' $P1831 = "364_1304516047.681" 
    capture_lex $P1831
    .const 'Sub' $P1828 = "363_1304516047.681" 
    capture_lex $P1828
    .const 'Sub' $P1825 = "362_1304516047.681" 
    capture_lex $P1825
    .const 'Sub' $P1821 = "361_1304516047.681" 
    capture_lex $P1821
    .const 'Sub' $P1818 = "360_1304516047.681" 
    capture_lex $P1818
    .const 'Sub' $P1814 = "359_1304516047.681" 
    capture_lex $P1814
    .const 'Sub' $P1811 = "358_1304516047.681" 
    capture_lex $P1811
    .const 'Sub' $P1807 = "357_1304516047.681" 
    capture_lex $P1807
    .const 'Sub' $P1804 = "356_1304516047.681" 
    capture_lex $P1804
    .const 'Sub' $P1800 = "355_1304516047.681" 
    capture_lex $P1800
    .const 'Sub' $P1797 = "354_1304516047.681" 
    capture_lex $P1797
    .const 'Sub' $P1793 = "353_1304516047.681" 
    capture_lex $P1793
    .const 'Sub' $P1790 = "352_1304516047.681" 
    capture_lex $P1790
    .const 'Sub' $P1786 = "351_1304516047.681" 
    capture_lex $P1786
    .const 'Sub' $P1783 = "350_1304516047.681" 
    capture_lex $P1783
    .const 'Sub' $P1779 = "349_1304516047.681" 
    capture_lex $P1779
    .const 'Sub' $P1776 = "348_1304516047.681" 
    capture_lex $P1776
    .const 'Sub' $P1772 = "347_1304516047.681" 
    capture_lex $P1772
    .const 'Sub' $P1769 = "346_1304516047.681" 
    capture_lex $P1769
    .const 'Sub' $P1765 = "345_1304516047.681" 
    capture_lex $P1765
    .const 'Sub' $P1762 = "344_1304516047.681" 
    capture_lex $P1762
    .const 'Sub' $P1758 = "343_1304516047.681" 
    capture_lex $P1758
    .const 'Sub' $P1755 = "342_1304516047.681" 
    capture_lex $P1755
    .const 'Sub' $P1751 = "341_1304516047.681" 
    capture_lex $P1751
    .const 'Sub' $P1748 = "340_1304516047.681" 
    capture_lex $P1748
    .const 'Sub' $P1744 = "339_1304516047.681" 
    capture_lex $P1744
    .const 'Sub' $P1741 = "338_1304516047.681" 
    capture_lex $P1741
    .const 'Sub' $P1737 = "337_1304516047.681" 
    capture_lex $P1737
    .const 'Sub' $P1734 = "336_1304516047.681" 
    capture_lex $P1734
    .const 'Sub' $P1730 = "335_1304516047.681" 
    capture_lex $P1730
    .const 'Sub' $P1727 = "334_1304516047.681" 
    capture_lex $P1727
    .const 'Sub' $P1723 = "333_1304516047.681" 
    capture_lex $P1723
    .const 'Sub' $P1720 = "332_1304516047.681" 
    capture_lex $P1720
    .const 'Sub' $P1716 = "331_1304516047.681" 
    capture_lex $P1716
    .const 'Sub' $P1713 = "330_1304516047.681" 
    capture_lex $P1713
    .const 'Sub' $P1709 = "329_1304516047.681" 
    capture_lex $P1709
    .const 'Sub' $P1706 = "328_1304516047.681" 
    capture_lex $P1706
    .const 'Sub' $P1702 = "327_1304516047.681" 
    capture_lex $P1702
    .const 'Sub' $P1699 = "326_1304516047.681" 
    capture_lex $P1699
    .const 'Sub' $P1695 = "325_1304516047.681" 
    capture_lex $P1695
    .const 'Sub' $P1692 = "324_1304516047.681" 
    capture_lex $P1692
    .const 'Sub' $P1688 = "323_1304516047.681" 
    capture_lex $P1688
    .const 'Sub' $P1685 = "322_1304516047.681" 
    capture_lex $P1685
    .const 'Sub' $P1681 = "321_1304516047.681" 
    capture_lex $P1681
    .const 'Sub' $P1678 = "320_1304516047.681" 
    capture_lex $P1678
    .const 'Sub' $P1674 = "319_1304516047.681" 
    capture_lex $P1674
    .const 'Sub' $P1671 = "318_1304516047.681" 
    capture_lex $P1671
    .const 'Sub' $P1667 = "317_1304516047.681" 
    capture_lex $P1667
    .const 'Sub' $P1664 = "316_1304516047.681" 
    capture_lex $P1664
    .const 'Sub' $P1660 = "315_1304516047.681" 
    capture_lex $P1660
    .const 'Sub' $P1657 = "314_1304516047.681" 
    capture_lex $P1657
    .const 'Sub' $P1653 = "313_1304516047.681" 
    capture_lex $P1653
    .const 'Sub' $P1650 = "312_1304516047.681" 
    capture_lex $P1650
    .const 'Sub' $P1646 = "311_1304516047.681" 
    capture_lex $P1646
    .const 'Sub' $P1643 = "310_1304516047.681" 
    capture_lex $P1643
    .const 'Sub' $P1639 = "309_1304516047.681" 
    capture_lex $P1639
    .const 'Sub' $P1636 = "308_1304516047.681" 
    capture_lex $P1636
    .const 'Sub' $P1632 = "307_1304516047.681" 
    capture_lex $P1632
    .const 'Sub' $P1629 = "306_1304516047.681" 
    capture_lex $P1629
    .const 'Sub' $P1625 = "305_1304516047.681" 
    capture_lex $P1625
    .const 'Sub' $P1623 = "304_1304516047.681" 
    capture_lex $P1623
    .const 'Sub' $P1619 = "303_1304516047.681" 
    capture_lex $P1619
    .const 'Sub' $P1616 = "302_1304516047.681" 
    capture_lex $P1616
    .const 'Sub' $P1612 = "301_1304516047.681" 
    capture_lex $P1612
    .const 'Sub' $P1609 = "300_1304516047.681" 
    capture_lex $P1609
    .const 'Sub' $P1605 = "299_1304516047.681" 
    capture_lex $P1605
    .const 'Sub' $P1602 = "298_1304516047.681" 
    capture_lex $P1602
    .const 'Sub' $P1598 = "297_1304516047.681" 
    capture_lex $P1598
    .const 'Sub' $P1595 = "296_1304516047.681" 
    capture_lex $P1595
    .const 'Sub' $P1591 = "295_1304516047.681" 
    capture_lex $P1591
    .const 'Sub' $P1588 = "294_1304516047.681" 
    capture_lex $P1588
    .const 'Sub' $P1584 = "293_1304516047.681" 
    capture_lex $P1584
    .const 'Sub' $P1581 = "292_1304516047.681" 
    capture_lex $P1581
    .const 'Sub' $P1577 = "291_1304516047.681" 
    capture_lex $P1577
    .const 'Sub' $P1574 = "290_1304516047.681" 
    capture_lex $P1574
    .const 'Sub' $P1570 = "289_1304516047.681" 
    capture_lex $P1570
    .const 'Sub' $P1567 = "288_1304516047.681" 
    capture_lex $P1567
    .const 'Sub' $P1564 = "287_1304516047.681" 
    capture_lex $P1564
    .const 'Sub' $P1561 = "286_1304516047.681" 
    capture_lex $P1561
    .const 'Sub' $P1558 = "285_1304516047.681" 
    capture_lex $P1558
    .const 'Sub' $P1556 = "284_1304516047.681" 
    capture_lex $P1556
    .const 'Sub' $P1553 = "283_1304516047.681" 
    capture_lex $P1553
    .const 'Sub' $P1550 = "282_1304516047.681" 
    capture_lex $P1550
    .const 'Sub' $P1547 = "281_1304516047.681" 
    capture_lex $P1547
    .const 'Sub' $P1544 = "280_1304516047.681" 
    capture_lex $P1544
    .const 'Sub' $P1541 = "279_1304516047.681" 
    capture_lex $P1541
    .const 'Sub' $P1539 = "278_1304516047.681" 
    capture_lex $P1539
    .const 'Sub' $P1536 = "277_1304516047.681" 
    capture_lex $P1536
    .const 'Sub' $P1534 = "276_1304516047.681" 
    capture_lex $P1534
    .const 'Sub' $P1531 = "275_1304516047.681" 
    capture_lex $P1531
    .const 'Sub' $P1528 = "274_1304516047.681" 
    capture_lex $P1528
    .const 'Sub' $P1523 = "273_1304516047.681" 
    capture_lex $P1523
    .const 'Sub' $P1520 = "272_1304516047.681" 
    capture_lex $P1520
    .const 'Sub' $P1514 = "271_1304516047.681" 
    capture_lex $P1514
    .const 'Sub' $P1512 = "270_1304516047.681" 
    capture_lex $P1512
    .const 'Sub' $P1509 = "269_1304516047.681" 
    capture_lex $P1509
    .const 'Sub' $P1507 = "268_1304516047.681" 
    capture_lex $P1507
    .const 'Sub' $P1504 = "267_1304516047.681" 
    capture_lex $P1504
    .const 'Sub' $P1502 = "266_1304516047.681" 
    capture_lex $P1502
    .const 'Sub' $P1499 = "265_1304516047.681" 
    capture_lex $P1499
    .const 'Sub' $P1496 = "264_1304516047.681" 
    capture_lex $P1496
    .const 'Sub' $P1491 = "263_1304516047.681" 
    capture_lex $P1491
    .const 'Sub' $P1488 = "262_1304516047.681" 
    capture_lex $P1488
    .const 'Sub' $P1483 = "261_1304516047.681" 
    capture_lex $P1483
    .const 'Sub' $P1481 = "260_1304516047.681" 
    capture_lex $P1481
    .const 'Sub' $P1478 = "259_1304516047.681" 
    capture_lex $P1478
    .const 'Sub' $P1476 = "258_1304516047.681" 
    capture_lex $P1476
    .const 'Sub' $P1473 = "257_1304516047.681" 
    capture_lex $P1473
    .const 'Sub' $P1471 = "256_1304516047.681" 
    capture_lex $P1471
    .const 'Sub' $P1468 = "255_1304516047.681" 
    capture_lex $P1468
    .const 'Sub' $P1465 = "254_1304516047.681" 
    capture_lex $P1465
    .const 'Sub' $P1462 = "253_1304516047.681" 
    capture_lex $P1462
    .const 'Sub' $P1459 = "252_1304516047.681" 
    capture_lex $P1459
    .const 'Sub' $P1455 = "251_1304516047.681" 
    capture_lex $P1455
    .const 'Sub' $P1452 = "250_1304516047.681" 
    capture_lex $P1452
    .const 'Sub' $P1448 = "249_1304516047.681" 
    capture_lex $P1448
    .const 'Sub' $P1445 = "248_1304516047.681" 
    capture_lex $P1445
    .const 'Sub' $P1441 = "247_1304516047.681" 
    capture_lex $P1441
    .const 'Sub' $P1438 = "246_1304516047.681" 
    capture_lex $P1438
    .const 'Sub' $P1434 = "245_1304516047.681" 
    capture_lex $P1434
    .const 'Sub' $P1432 = "244_1304516047.681" 
    capture_lex $P1432
    .const 'Sub' $P1429 = "243_1304516047.681" 
    capture_lex $P1429
    .const 'Sub' $P1427 = "242_1304516047.681" 
    capture_lex $P1427
    .const 'Sub' $P1424 = "241_1304516047.681" 
    capture_lex $P1424
    .const 'Sub' $P1416 = "238_1304516047.681" 
    capture_lex $P1416
    .const 'Sub' $P1410 = "237_1304516047.681" 
    capture_lex $P1410
    .const 'Sub' $P1406 = "236_1304516047.681" 
    capture_lex $P1406
    .const 'Sub' $P1402 = "235_1304516047.681" 
    capture_lex $P1402
    .const 'Sub' $P1399 = "234_1304516047.681" 
    capture_lex $P1399
    .const 'Sub' $P1396 = "233_1304516047.681" 
    capture_lex $P1396
    .const 'Sub' $P1393 = "232_1304516047.681" 
    capture_lex $P1393
    .const 'Sub' $P1389 = "231_1304516047.681" 
    capture_lex $P1389
    .const 'Sub' $P1386 = "230_1304516047.681" 
    capture_lex $P1386
    .const 'Sub' $P1383 = "229_1304516047.681" 
    capture_lex $P1383
    .const 'Sub' $P1381 = "228_1304516047.681" 
    capture_lex $P1381
    .const 'Sub' $P1367 = "226_1304516047.681" 
    capture_lex $P1367
    .const 'Sub' $P1365 = "225_1304516047.681" 
    capture_lex $P1365
    .const 'Sub' $P1359 = "224_1304516047.681" 
    capture_lex $P1359
    .const 'Sub' $P1356 = "223_1304516047.681" 
    capture_lex $P1356
    .const 'Sub' $P1351 = "222_1304516047.681" 
    capture_lex $P1351
    .const 'Sub' $P1348 = "221_1304516047.681" 
    capture_lex $P1348
    .const 'Sub' $P1345 = "220_1304516047.681" 
    capture_lex $P1345
    .const 'Sub' $P1343 = "219_1304516047.681" 
    capture_lex $P1343
    .const 'Sub' $P1339 = "218_1304516047.681" 
    capture_lex $P1339
    .const 'Sub' $P1330 = "215_1304516047.681" 
    capture_lex $P1330
    .const 'Sub' $P1323 = "214_1304516047.681" 
    capture_lex $P1323
    .const 'Sub' $P1320 = "213_1304516047.681" 
    capture_lex $P1320
    .const 'Sub' $P1282 = "212_1304516047.681" 
    capture_lex $P1282
    .const 'Sub' $P1279 = "211_1304516047.681" 
    capture_lex $P1279
    .const 'Sub' $P1271 = "210_1304516047.681" 
    capture_lex $P1271
    .const 'Sub' $P1262 = "207_1304516047.681" 
    capture_lex $P1262
    .const 'Sub' $P1257 = "206_1304516047.681" 
    capture_lex $P1257
    .const 'Sub' $P1254 = "205_1304516047.681" 
    capture_lex $P1254
    .const 'Sub' $P1248 = "204_1304516047.681" 
    capture_lex $P1248
    .const 'Sub' $P1245 = "203_1304516047.681" 
    capture_lex $P1245
    .const 'Sub' $P1242 = "202_1304516047.681" 
    capture_lex $P1242
    .const 'Sub' $P1239 = "201_1304516047.681" 
    capture_lex $P1239
    .const 'Sub' $P1232 = "200_1304516047.681" 
    capture_lex $P1232
    .const 'Sub' $P1230 = "199_1304516047.681" 
    capture_lex $P1230
    .const 'Sub' $P1217 = "198_1304516047.681" 
    capture_lex $P1217
    .const 'Sub' $P1215 = "197_1304516047.681" 
    capture_lex $P1215
    .const 'Sub' $P1201 = "195_1304516047.681" 
    capture_lex $P1201
    .const 'Sub' $P1198 = "194_1304516047.681" 
    capture_lex $P1198
    .const 'Sub' $P1193 = "193_1304516047.681" 
    capture_lex $P1193
    .const 'Sub' $P1190 = "192_1304516047.681" 
    capture_lex $P1190
    .const 'Sub' $P1183 = "191_1304516047.681" 
    capture_lex $P1183
    .const 'Sub' $P1180 = "190_1304516047.681" 
    capture_lex $P1180
    .const 'Sub' $P1173 = "189_1304516047.681" 
    capture_lex $P1173
    .const 'Sub' $P1165 = "186_1304516047.681" 
    capture_lex $P1165
    .const 'Sub' $P1152 = "184_1304516047.681" 
    capture_lex $P1152
    .const 'Sub' $P1149 = "183_1304516047.681" 
    capture_lex $P1149
    .const 'Sub' $P1108 = "181_1304516047.681" 
    capture_lex $P1108
    .const 'Sub' $P1105 = "180_1304516047.681" 
    capture_lex $P1105
    .const 'Sub' $P1074 = "179_1304516047.681" 
    capture_lex $P1074
    .const 'Sub' $P1071 = "178_1304516047.681" 
    capture_lex $P1071
    .const 'Sub' $P1067 = "177_1304516047.681" 
    capture_lex $P1067
    .const 'Sub' $P1064 = "176_1304516047.681" 
    capture_lex $P1064
    .const 'Sub' $P1060 = "175_1304516047.681" 
    capture_lex $P1060
    .const 'Sub' $P1051 = "172_1304516047.681" 
    capture_lex $P1051
    .const 'Sub' $P1033 = "170_1304516047.681" 
    capture_lex $P1033
    .const 'Sub' $P1029 = "169_1304516047.681" 
    capture_lex $P1029
    .const 'Sub' $P1025 = "168_1304516047.681" 
    capture_lex $P1025
    .const 'Sub' $P1022 = "167_1304516047.681" 
    capture_lex $P1022
    .const 'Sub' $P1006 = "165_1304516047.681" 
    capture_lex $P1006
    .const 'Sub' $P1001 = "164_1304516047.681" 
    capture_lex $P1001
    .const 'Sub' $P990 = "163_1304516047.681" 
    capture_lex $P990
    .const 'Sub' $P987 = "162_1304516047.681" 
    capture_lex $P987
    .const 'Sub' $P983 = "161_1304516047.681" 
    capture_lex $P983
    .const 'Sub' $P980 = "160_1304516047.681" 
    capture_lex $P980
    .const 'Sub' $P976 = "159_1304516047.681" 
    capture_lex $P976
    .const 'Sub' $P973 = "158_1304516047.681" 
    capture_lex $P973
    .const 'Sub' $P969 = "157_1304516047.681" 
    capture_lex $P969
    .const 'Sub' $P960 = "154_1304516047.681" 
    capture_lex $P960
    .const 'Sub' $P791 = "152_1304516047.681" 
    capture_lex $P791
    .const 'Sub' $P788 = "151_1304516047.681" 
    capture_lex $P788
    .const 'Sub' $P778 = "150_1304516047.681" 
    capture_lex $P778
    .const 'Sub' $P775 = "149_1304516047.681" 
    capture_lex $P775
    .const 'Sub' $P765 = "148_1304516047.681" 
    capture_lex $P765
    .const 'Sub' $P762 = "147_1304516047.681" 
    capture_lex $P762
    .const 'Sub' $P752 = "146_1304516047.681" 
    capture_lex $P752
    .const 'Sub' $P749 = "145_1304516047.681" 
    capture_lex $P749
    .const 'Sub' $P739 = "144_1304516047.681" 
    capture_lex $P739
    .const 'Sub' $P736 = "143_1304516047.681" 
    capture_lex $P736
    .const 'Sub' $P726 = "142_1304516047.681" 
    capture_lex $P726
    .const 'Sub' $P723 = "141_1304516047.681" 
    capture_lex $P723
    .const 'Sub' $P713 = "140_1304516047.681" 
    capture_lex $P713
    .const 'Sub' $P705 = "137_1304516047.681" 
    capture_lex $P705
    .const 'Sub' $P702 = "136_1304516047.681" 
    capture_lex $P702
    .const 'Sub' $P700 = "135_1304516047.681" 
    capture_lex $P700
    .const 'Sub' $P697 = "134_1304516047.681" 
    capture_lex $P697
    .const 'Sub' $P693 = "133_1304516047.681" 
    capture_lex $P693
    .const 'Sub' $P685 = "132_1304516047.681" 
    capture_lex $P685
    .const 'Sub' $P680 = "131_1304516047.681" 
    capture_lex $P680
    .const 'Sub' $P673 = "130_1304516047.681" 
    capture_lex $P673
    .const 'Sub' $P670 = "129_1304516047.681" 
    capture_lex $P670
    .const 'Sub' $P666 = "128_1304516047.681" 
    capture_lex $P666
    .const 'Sub' $P664 = "127_1304516047.681" 
    capture_lex $P664
    .const 'Sub' $P661 = "126_1304516047.681" 
    capture_lex $P661
    .const 'Sub' $P658 = "125_1304516047.681" 
    capture_lex $P658
    .const 'Sub' $P655 = "124_1304516047.681" 
    capture_lex $P655
    .const 'Sub' $P652 = "123_1304516047.681" 
    capture_lex $P652
    .const 'Sub' $P649 = "122_1304516047.681" 
    capture_lex $P649
    .const 'Sub' $P647 = "121_1304516047.681" 
    capture_lex $P647
    .const 'Sub' $P634 = "118_1304516047.681" 
    capture_lex $P634
    .const 'Sub' $P631 = "117_1304516047.681" 
    capture_lex $P631
    .const 'Sub' $P628 = "116_1304516047.681" 
    capture_lex $P628
    .const 'Sub' $P625 = "115_1304516047.681" 
    capture_lex $P625
    .const 'Sub' $P622 = "114_1304516047.681" 
    capture_lex $P622
    .const 'Sub' $P619 = "113_1304516047.681" 
    capture_lex $P619
    .const 'Sub' $P616 = "112_1304516047.681" 
    capture_lex $P616
    .const 'Sub' $P613 = "111_1304516047.681" 
    capture_lex $P613
    .const 'Sub' $P610 = "110_1304516047.681" 
    capture_lex $P610
    .const 'Sub' $P607 = "109_1304516047.681" 
    capture_lex $P607
    .const 'Sub' $P604 = "108_1304516047.681" 
    capture_lex $P604
    .const 'Sub' $P601 = "107_1304516047.681" 
    capture_lex $P601
    .const 'Sub' $P598 = "106_1304516047.681" 
    capture_lex $P598
    .const 'Sub' $P595 = "105_1304516047.681" 
    capture_lex $P595
    .const 'Sub' $P589 = "104_1304516047.681" 
    capture_lex $P589
    .const 'Sub' $P586 = "103_1304516047.681" 
    capture_lex $P586
    .const 'Sub' $P580 = "102_1304516047.681" 
    capture_lex $P580
    .const 'Sub' $P577 = "101_1304516047.681" 
    capture_lex $P577
    .const 'Sub' $P571 = "100_1304516047.681" 
    capture_lex $P571
    .const 'Sub' $P562 = "97_1304516047.681" 
    capture_lex $P562
    .const 'Sub' $P556 = "96_1304516047.681" 
    capture_lex $P556
    .const 'Sub' $P553 = "95_1304516047.681" 
    capture_lex $P553
    .const 'Sub' $P547 = "94_1304516047.681" 
    capture_lex $P547
    .const 'Sub' $P539 = "91_1304516047.681" 
    capture_lex $P539
    .const 'Sub' $P535 = "90_1304516047.681" 
    capture_lex $P535
    .const 'Sub' $P532 = "89_1304516047.681" 
    capture_lex $P532
    .const 'Sub' $P528 = "88_1304516047.681" 
    capture_lex $P528
    .const 'Sub' $P525 = "87_1304516047.681" 
    capture_lex $P525
    .const 'Sub' $P521 = "86_1304516047.681" 
    capture_lex $P521
    .const 'Sub' $P513 = "83_1304516047.681" 
    capture_lex $P513
    .const 'Sub' $P507 = "82_1304516047.681" 
    capture_lex $P507
    .const 'Sub' $P505 = "81_1304516047.681" 
    capture_lex $P505
    .const 'Sub' $P499 = "80_1304516047.681" 
    capture_lex $P499
    .const 'Sub' $P497 = "79_1304516047.681" 
    capture_lex $P497
    .const 'Sub' $P491 = "78_1304516047.681" 
    capture_lex $P491
    .const 'Sub' $P489 = "77_1304516047.681" 
    capture_lex $P489
    .const 'Sub' $P471 = "76_1304516047.681" 
    capture_lex $P471
    .const 'Sub' $P469 = "75_1304516047.681" 
    capture_lex $P469
    .const 'Sub' $P462 = "74_1304516047.681" 
    capture_lex $P462
    .const 'Sub' $P460 = "73_1304516047.681" 
    capture_lex $P460
    .const 'Sub' $P444 = "71_1304516047.681" 
    capture_lex $P444
    .const 'Sub' $P442 = "70_1304516047.681" 
    capture_lex $P442
    .const 'Sub' $P426 = "69_1304516047.681" 
    capture_lex $P426
    .const 'Sub' $P424 = "68_1304516047.681" 
    capture_lex $P424
    .const 'Sub' $P418 = "67_1304516047.681" 
    capture_lex $P418
    .const 'Sub' $P410 = "64_1304516047.681" 
    capture_lex $P410
    .const 'Sub' $P407 = "63_1304516047.681" 
    capture_lex $P407
    .const 'Sub' $P405 = "62_1304516047.681" 
    capture_lex $P405
    .const 'Sub' $P402 = "61_1304516047.681" 
    capture_lex $P402
    .const 'Sub' $P394 = "58_1304516047.681" 
    capture_lex $P394
    .const 'Sub' $P391 = "57_1304516047.681" 
    capture_lex $P391
    .const 'Sub' $P389 = "56_1304516047.681" 
    capture_lex $P389
    .const 'Sub' $P386 = "55_1304516047.681" 
    capture_lex $P386
    .const 'Sub' $P384 = "54_1304516047.681" 
    capture_lex $P384
    .const 'Sub' $P381 = "53_1304516047.681" 
    capture_lex $P381
    .const 'Sub' $P379 = "52_1304516047.681" 
    capture_lex $P379
    .const 'Sub' $P376 = "51_1304516047.681" 
    capture_lex $P376
    .const 'Sub' $P374 = "50_1304516047.681" 
    capture_lex $P374
    .const 'Sub' $P371 = "49_1304516047.681" 
    capture_lex $P371
    .const 'Sub' $P368 = "48_1304516047.681" 
    capture_lex $P368
    .const 'Sub' $P361 = "47_1304516047.681" 
    capture_lex $P361
    .const 'Sub' $P358 = "46_1304516047.681" 
    capture_lex $P358
    .const 'Sub' $P354 = "45_1304516047.681" 
    capture_lex $P354
    .const 'Sub' $P352 = "44_1304516047.681" 
    capture_lex $P352
    .const 'Sub' $P348 = "43_1304516047.681" 
    capture_lex $P348
    .const 'Sub' $P344 = "42_1304516047.681" 
    capture_lex $P344
    .const 'Sub' $P340 = "41_1304516047.681" 
    capture_lex $P340
    .const 'Sub' $P337 = "40_1304516047.681" 
    capture_lex $P337
    .const 'Sub' $P334 = "39_1304516047.681" 
    capture_lex $P334
    .const 'Sub' $P332 = "38_1304516047.681" 
    capture_lex $P332
    .const 'Sub' $P328 = "37_1304516047.681" 
    capture_lex $P328
    .const 'Sub' $P326 = "36_1304516047.681" 
    capture_lex $P326
    .const 'Sub' $P313 = "34_1304516047.681" 
    capture_lex $P313
    .const 'Sub' $P309 = "33_1304516047.681" 
    capture_lex $P309
    .const 'Sub' $P299 = "32_1304516047.681" 
    capture_lex $P299
    .const 'Sub' $P296 = "31_1304516047.681" 
    capture_lex $P296
    .const 'Sub' $P276 = "30_1304516047.681" 
    capture_lex $P276
    .const 'Sub' $P274 = "29_1304516047.681" 
    capture_lex $P274
    .const 'Sub' $P237 = "27_1304516047.681" 
    capture_lex $P237
    .const 'Sub' $P235 = "26_1304516047.681" 
    capture_lex $P235
    .const 'Sub' $P222 = "24_1304516047.681" 
    capture_lex $P222
    .const 'Sub' $P220 = "23_1304516047.681" 
    capture_lex $P220
    .const 'Sub' $P211 = "22_1304516047.681" 
    capture_lex $P211
    .const 'Sub' $P209 = "21_1304516047.681" 
    capture_lex $P209
    .const 'Sub' $P199 = "20_1304516047.681" 
    capture_lex $P199
    .const 'Sub' $P196 = "19_1304516047.681" 
    capture_lex $P196
    .const 'Sub' $P191 = "18_1304516047.681" 
    capture_lex $P191
    .const 'Sub' $P189 = "17_1304516047.681" 
    capture_lex $P189
    .const 'Sub' $P184 = "16_1304516047.681" 
    capture_lex $P184
    .const 'Sub' $P181 = "15_1304516047.681" 
    capture_lex $P181
    .const 'Sub' $P177 = "14_1304516047.681" 
    capture_lex $P177
    .const 'Sub' $P110 = "13_1304516047.681" 
    capture_lex $P110
    .lex "$?PACKAGE", $P48
    .lex "$?CLASS", $P49
.annotate 'line', 606
    get_hll_global $P50, "GLOBAL"
    nqp_get_package_through_who $P51, $P50, "NQP"
    get_who $P52, $P51
    set $P53, $P52["Grammar"]
    $P53."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 607
    get_hll_global $P54, "GLOBAL"
    nqp_get_package_through_who $P55, $P54, "NQP"
    get_who $P56, $P55
    set $P57, $P56["Grammar"]
    $P57."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 608
    get_hll_global $P58, "GLOBAL"
    nqp_get_package_through_who $P59, $P58, "NQP"
    get_who $P60, $P59
    set $P61, $P60["Grammar"]
    $P61."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 609
    get_hll_global $P62, "GLOBAL"
    nqp_get_package_through_who $P63, $P62, "NQP"
    get_who $P64, $P63
    set $P65, $P64["Grammar"]
    $P65."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 610
    get_hll_global $P66, "GLOBAL"
    nqp_get_package_through_who $P67, $P66, "NQP"
    get_who $P68, $P67
    set $P69, $P68["Grammar"]
    $P69."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 611
    get_hll_global $P70, "GLOBAL"
    nqp_get_package_through_who $P71, $P70, "NQP"
    get_who $P72, $P71
    set $P73, $P72["Grammar"]
    $P73."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 612
    get_hll_global $P74, "GLOBAL"
    nqp_get_package_through_who $P75, $P74, "NQP"
    get_who $P76, $P75
    set $P77, $P76["Grammar"]
    $P77."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 613
    get_hll_global $P78, "GLOBAL"
    nqp_get_package_through_who $P79, $P78, "NQP"
    get_who $P80, $P79
    set $P81, $P80["Grammar"]
    $P81."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 614
    get_hll_global $P82, "GLOBAL"
    nqp_get_package_through_who $P83, $P82, "NQP"
    get_who $P84, $P83
    set $P85, $P84["Grammar"]
    $P85."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 615
    get_hll_global $P86, "GLOBAL"
    nqp_get_package_through_who $P87, $P86, "NQP"
    get_who $P88, $P87
    set $P89, $P88["Grammar"]
    $P89."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 616
    get_hll_global $P90, "GLOBAL"
    nqp_get_package_through_who $P91, $P90, "NQP"
    get_who $P92, $P91
    set $P93, $P92["Grammar"]
    $P93."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 617
    get_hll_global $P94, "GLOBAL"
    nqp_get_package_through_who $P95, $P94, "NQP"
    get_who $P96, $P95
    set $P97, $P96["Grammar"]
    $P97."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 618
    get_hll_global $P98, "GLOBAL"
    nqp_get_package_through_who $P99, $P98, "NQP"
    get_who $P100, $P99
    set $P101, $P100["Grammar"]
    $P101."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 619
    get_hll_global $P102, "GLOBAL"
    nqp_get_package_through_who $P103, $P102, "NQP"
    get_who $P104, $P103
    set $P105, $P104["Grammar"]
    $P105."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 620
    get_hll_global $P106, "GLOBAL"
    nqp_get_package_through_who $P107, $P106, "NQP"
    get_who $P108, $P107
    set $P109, $P108["Grammar"]
    $P109."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.annotate 'line', 719
    .const 'Sub' $P1898 = "384_1304516047.681" 
    newclosure $P1909, $P1898
.annotate 'line', 9
    .return ($P1909)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1304516047.681") :outer("12_1304516047.681")
    .param pmc param_111
.annotate 'line', 10
    .lex "self", param_111
.annotate 'line', 12
    $P112 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P112
.annotate 'line', 21
    $P113 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P113
.annotate 'line', 28
    new $P114, "Undef"
    .lex "$*SC", $P114
.annotate 'line', 32
    new $P115, "Undef"
    .lex "$*SCOPE", $P115
.annotate 'line', 33
    new $P116, "Undef"
    .lex "$*MULTINESS", $P116
.annotate 'line', 34
    new $P117, "Undef"
    .lex "$*PKGDECL", $P117
.annotate 'line', 35
    new $P118, "Undef"
    .lex "$*INVOCANT_OK", $P118
.annotate 'line', 36
    new $P119, "Undef"
    .lex "$*RETURN_USED", $P119
.annotate 'line', 10
    find_lex $P122, "%*LANG"
    unless_null $P122, vivify_602
    get_hll_global $P120, "GLOBAL"
    get_who $P121, $P120
    set $P122, $P121["%LANG"]
    unless_null $P122, vivify_603
    die "Contextual %*LANG not found"
  vivify_603:
  vivify_602:
.annotate 'line', 13
    get_hll_global $P123, "GLOBAL"
    nqp_get_package_through_who $P124, $P123, "NQP"
    get_who $P125, $P124
    set $P126, $P125["Regex"]
    find_lex $P129, "%*LANG"
    unless_null $P129, vivify_604
    get_hll_global $P127, "GLOBAL"
    get_who $P128, $P127
    set $P129, $P128["%LANG"]
    unless_null $P129, vivify_605
    die "Contextual %*LANG not found"
  vivify_605:
    store_lex "%*LANG", $P129
  vivify_604:
    set $P129["Regex"], $P126
.annotate 'line', 14
    get_hll_global $P130, "GLOBAL"
    nqp_get_package_through_who $P131, $P130, "NQP"
    get_who $P132, $P131
    set $P133, $P132["RegexActions"]
    find_lex $P136, "%*LANG"
    unless_null $P136, vivify_606
    get_hll_global $P134, "GLOBAL"
    get_who $P135, $P134
    set $P136, $P135["%LANG"]
    unless_null $P136, vivify_607
    die "Contextual %*LANG not found"
  vivify_607:
    store_lex "%*LANG", $P136
  vivify_606:
    set $P136["Regex-actions"], $P133
.annotate 'line', 15
    get_hll_global $P137, "GLOBAL"
    nqp_get_package_through_who $P138, $P137, "NQP"
    get_who $P139, $P138
    set $P140, $P139["Grammar"]
    find_lex $P143, "%*LANG"
    unless_null $P143, vivify_608
    get_hll_global $P141, "GLOBAL"
    get_who $P142, $P141
    set $P143, $P142["%LANG"]
    unless_null $P143, vivify_609
    die "Contextual %*LANG not found"
  vivify_609:
    store_lex "%*LANG", $P143
  vivify_608:
    set $P143["MAIN"], $P140
.annotate 'line', 16
    get_hll_global $P144, "GLOBAL"
    nqp_get_package_through_who $P145, $P144, "NQP"
    get_who $P146, $P145
    set $P147, $P146["Actions"]
    find_lex $P150, "%*LANG"
    unless_null $P150, vivify_610
    get_hll_global $P148, "GLOBAL"
    get_who $P149, $P148
    set $P150, $P149["%LANG"]
    unless_null $P150, vivify_611
    die "Contextual %*LANG not found"
  vivify_611:
    store_lex "%*LANG", $P150
  vivify_610:
    set $P150["MAIN-actions"], $P147
    find_lex $P153, "%*HOW"
    unless_null $P153, vivify_612
    get_hll_global $P151, "GLOBAL"
    get_who $P152, $P151
    set $P153, $P152["%HOW"]
    unless_null $P153, vivify_613
    die "Contextual %*HOW not found"
  vivify_613:
  vivify_612:
.annotate 'line', 22
    get_knowhow $P154
    find_lex $P157, "%*HOW"
    unless_null $P157, vivify_614
    get_hll_global $P155, "GLOBAL"
    get_who $P156, $P155
    set $P157, $P156["%HOW"]
    unless_null $P157, vivify_615
    die "Contextual %*HOW not found"
  vivify_615:
    store_lex "%*HOW", $P157
  vivify_614:
    set $P157["knowhow"], $P154
.annotate 'line', 23
    get_knowhow_attribute $P158
    find_lex $P161, "%*HOW"
    unless_null $P161, vivify_616
    get_hll_global $P159, "GLOBAL"
    get_who $P160, $P159
    set $P161, $P160["%HOW"]
    unless_null $P161, vivify_617
    die "Contextual %*HOW not found"
  vivify_617:
    store_lex "%*HOW", $P161
  vivify_616:
    set $P161["knowhow-attr"], $P158
.annotate 'line', 28
    get_hll_global $P162, "GLOBAL"
    nqp_get_package_through_who $P163, $P162, "HLL"
    nqp_get_package_through_who $P164, $P163, "Compiler"
    get_who $P165, $P164
    set $P166, $P165["SerializationContextBuilder"]
.annotate 'line', 30
    time $N167
    set $S168, $N167
    $P169 = $P166."new"($S168 :named("handle"))
.annotate 'line', 28
    store_lex "$*SC", $P169
.annotate 'line', 32
    new $P170, "String"
    assign $P170, ""
    store_lex "$*SCOPE", $P170
.annotate 'line', 33
    new $P171, "String"
    assign $P171, ""
    store_lex "$*MULTINESS", $P171
.annotate 'line', 34
    new $P172, "String"
    assign $P172, ""
    store_lex "$*PKGDECL", $P172
.annotate 'line', 35
    new $P173, "Integer"
    assign $P173, 0
    store_lex "$*INVOCANT_OK", $P173
.annotate 'line', 36
    new $P174, "Integer"
    assign $P174, 0
    store_lex "$*RETURN_USED", $P174
.annotate 'line', 37
    find_lex $P175, "self"
    $P176 = $P175."comp_unit"()
.annotate 'line', 10
    .return ($P176)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx178_tgt
    .local int rx178_pos
    .local int rx178_off
    .local int rx178_eos
    .local int rx178_rep
    .local pmc rx178_cur
    .local pmc rx178_debug
    (rx178_cur, rx178_pos, rx178_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx178_cur
    .local pmc match
    .lex "$/", match
    length rx178_eos, rx178_tgt
    gt rx178_pos, rx178_eos, rx178_done
    set rx178_off, 0
    lt rx178_pos, 2, rx178_start
    sub rx178_off, rx178_pos, 1
    substr rx178_tgt, rx178_tgt, rx178_off
  rx178_start:
    eq $I10, 1, rx178_restart
    if_null rx178_debug, debug_618
    rx178_cur."!cursor_debug"("START", "identifier")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan179_done
    goto rxscan179_scan
  rxscan179_loop:
    (rx178_pos) = rx178_cur."from"()
    inc rx178_pos
    rx178_cur."!cursor_from"(rx178_pos)
    ge rx178_pos, rx178_eos, rxscan179_done
  rxscan179_scan:
    set_addr $I10, rxscan179_loop
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxscan179_done:
.annotate 'line', 42
  # rx subrule "ident" subtype=method negate=
    rx178_cur."!cursor_pos"(rx178_pos)
    $P10 = rx178_cur."ident"()
    unless $P10, rx178_fail
    rx178_pos = $P10."pos"()
  # rx rxquantr180 ** 0..*
    set_addr $I10, rxquantr180_done
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxquantr180_loop:
  # rx enumcharlist negate=0 
    ge rx178_pos, rx178_eos, rx178_fail
    sub $I10, rx178_pos, rx178_off
    substr $S10, rx178_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx178_fail
    inc rx178_pos
  # rx subrule "ident" subtype=method negate=
    rx178_cur."!cursor_pos"(rx178_pos)
    $P10 = rx178_cur."ident"()
    unless $P10, rx178_fail
    rx178_pos = $P10."pos"()
    set_addr $I10, rxquantr180_done
    (rx178_rep) = rx178_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr180_done
    rx178_cur."!mark_push"(rx178_rep, rx178_pos, $I10)
    goto rxquantr180_loop
  rxquantr180_done:
  # rx pass
    rx178_cur."!cursor_pass"(rx178_pos, "identifier")
    if_null rx178_debug, debug_619
    rx178_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx178_pos)
  debug_619:
    .return (rx178_cur)
  rx178_restart:
.annotate 'line', 10
    if_null rx178_debug, debug_620
    rx178_cur."!cursor_debug"("NEXT", "identifier")
  debug_620:
  rx178_fail:
    (rx178_rep, rx178_pos, $I10, $P10) = rx178_cur."!mark_fail"(0)
    lt rx178_pos, -1, rx178_done
    eq rx178_pos, -1, rx178_fail
    jump $I10
  rx178_done:
    rx178_cur."!cursor_fail"()
    if_null rx178_debug, debug_621
    rx178_cur."!cursor_debug"("FAIL", "identifier")
  debug_621:
    .return (rx178_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :subid("15_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P182 = self."!PREFIX__!subrule"("ident", "")
    new $P183, "ResizablePMCArray"
    push $P183, $P182
    .return ($P183)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx185_tgt
    .local int rx185_pos
    .local int rx185_off
    .local int rx185_eos
    .local int rx185_rep
    .local pmc rx185_cur
    .local pmc rx185_debug
    (rx185_cur, rx185_pos, rx185_tgt, $I10) = self."!cursor_start"()
    rx185_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx185_cur
    .local pmc match
    .lex "$/", match
    length rx185_eos, rx185_tgt
    gt rx185_pos, rx185_eos, rx185_done
    set rx185_off, 0
    lt rx185_pos, 2, rx185_start
    sub rx185_off, rx185_pos, 1
    substr rx185_tgt, rx185_tgt, rx185_off
  rx185_start:
    eq $I10, 1, rx185_restart
    if_null rx185_debug, debug_622
    rx185_cur."!cursor_debug"("START", "name")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan186_done
    goto rxscan186_scan
  rxscan186_loop:
    (rx185_pos) = rx185_cur."from"()
    inc rx185_pos
    rx185_cur."!cursor_from"(rx185_pos)
    ge rx185_pos, rx185_eos, rxscan186_done
  rxscan186_scan:
    set_addr $I10, rxscan186_loop
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxscan186_done:
.annotate 'line', 44
  # rx rxquantr187 ** 1..*
    set_addr $I10, rxquantr187_done
    rx185_cur."!mark_push"(0, -1, $I10)
  rxquantr187_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."identifier"()
    unless $P10, rx185_fail
    goto rxsubrule188_pass
  rxsubrule188_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx185_fail
  rxsubrule188_pass:
    set_addr $I10, rxsubrule188_back
    rx185_cur."!mark_push"(0, rx185_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx185_pos = $P10."pos"()
    set_addr $I10, rxquantr187_done
    (rx185_rep) = rx185_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr187_done
    rx185_cur."!mark_push"(rx185_rep, rx185_pos, $I10)
  # rx literal  "::"
    add $I11, rx185_pos, 2
    gt $I11, rx185_eos, rx185_fail
    sub $I11, rx185_pos, rx185_off
    substr $S10, rx185_tgt, $I11, 2
    ne $S10, "::", rx185_fail
    add rx185_pos, 2
    goto rxquantr187_loop
  rxquantr187_done:
  # rx pass
    rx185_cur."!cursor_pass"(rx185_pos, "name")
    if_null rx185_debug, debug_623
    rx185_cur."!cursor_debug"("PASS", "name", " at pos=", rx185_pos)
  debug_623:
    .return (rx185_cur)
  rx185_restart:
.annotate 'line', 10
    if_null rx185_debug, debug_624
    rx185_cur."!cursor_debug"("NEXT", "name")
  debug_624:
  rx185_fail:
    (rx185_rep, rx185_pos, $I10, $P10) = rx185_cur."!mark_fail"(0)
    lt rx185_pos, -1, rx185_done
    eq rx185_pos, -1, rx185_fail
    jump $I10
  rx185_done:
    rx185_cur."!cursor_fail"()
    if_null rx185_debug, debug_625
    rx185_cur."!cursor_debug"("FAIL", "name")
  debug_625:
    .return (rx185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :subid("17_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P190, "ResizablePMCArray"
    push $P190, ""
    .return ($P190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx192_tgt
    .local int rx192_pos
    .local int rx192_off
    .local int rx192_eos
    .local int rx192_rep
    .local pmc rx192_cur
    .local pmc rx192_debug
    (rx192_cur, rx192_pos, rx192_tgt, $I10) = self."!cursor_start"()
    rx192_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx192_cur
    .local pmc match
    .lex "$/", match
    length rx192_eos, rx192_tgt
    gt rx192_pos, rx192_eos, rx192_done
    set rx192_off, 0
    lt rx192_pos, 2, rx192_start
    sub rx192_off, rx192_pos, 1
    substr rx192_tgt, rx192_tgt, rx192_off
  rx192_start:
    eq $I10, 1, rx192_restart
    if_null rx192_debug, debug_626
    rx192_cur."!cursor_debug"("START", "deflongname")
  debug_626:
    $I10 = self.'from'()
    ne $I10, -1, rxscan193_done
    goto rxscan193_scan
  rxscan193_loop:
    (rx192_pos) = rx192_cur."from"()
    inc rx192_pos
    rx192_cur."!cursor_from"(rx192_pos)
    ge rx192_pos, rx192_eos, rxscan193_done
  rxscan193_scan:
    set_addr $I10, rxscan193_loop
    rx192_cur."!mark_push"(0, rx192_pos, $I10)
  rxscan193_done:
.annotate 'line', 47
  # rx subrule "identifier" subtype=capture negate=
    rx192_cur."!cursor_pos"(rx192_pos)
    $P10 = rx192_cur."identifier"()
    unless $P10, rx192_fail
    rx192_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx192_pos = $P10."pos"()
  # rx rxquantr194 ** 0..1
    set_addr $I10, rxquantr194_done
    rx192_cur."!mark_push"(0, rx192_pos, $I10)
  rxquantr194_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx192_cur."!cursor_pos"(rx192_pos)
    $P10 = rx192_cur."colonpair"()
    unless $P10, rx192_fail
    goto rxsubrule195_pass
  rxsubrule195_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx192_fail
  rxsubrule195_pass:
    set_addr $I10, rxsubrule195_back
    rx192_cur."!mark_push"(0, rx192_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx192_pos = $P10."pos"()
    set_addr $I10, rxquantr194_done
    (rx192_rep) = rx192_cur."!mark_commit"($I10)
  rxquantr194_done:
.annotate 'line', 46
  # rx pass
    rx192_cur."!cursor_pass"(rx192_pos, "deflongname")
    if_null rx192_debug, debug_627
    rx192_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx192_pos)
  debug_627:
    .return (rx192_cur)
  rx192_restart:
.annotate 'line', 10
    if_null rx192_debug, debug_628
    rx192_cur."!cursor_debug"("NEXT", "deflongname")
  debug_628:
  rx192_fail:
    (rx192_rep, rx192_pos, $I10, $P10) = rx192_cur."!mark_fail"(0)
    lt rx192_pos, -1, rx192_done
    eq rx192_pos, -1, rx192_fail
    jump $I10
  rx192_done:
    rx192_cur."!cursor_fail"()
    if_null rx192_debug, debug_629
    rx192_cur."!cursor_debug"("FAIL", "deflongname")
  debug_629:
    .return (rx192_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :subid("19_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P197 = self."!PREFIX__!subrule"("identifier", "")
    new $P198, "ResizablePMCArray"
    push $P198, $P197
    .return ($P198)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_630
    rx200_cur."!cursor_debug"("START", "ENDSTMT")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan201_done:
.annotate 'line', 54
  # rx rxquantr202 ** 0..1
    set_addr $I10, rxquantr202_done
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxquantr202_loop:
  alt203_0:
.annotate 'line', 51
    set_addr $I10, alt203_1
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 52
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx200_pos, rx200_off
    set rx200_rep, 0
    sub $I12, rx200_eos, rx200_pos
  rxenumcharlistq204_loop:
    le $I12, 0, rxenumcharlistq204_done
    substr $S10, rx200_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq204_done
    inc rx200_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq204_loop
  rxenumcharlistq204_done:
    add rx200_pos, rx200_pos, rx200_rep
  # rxanchor eol
    sub $I10, rx200_pos, rx200_off
    is_cclass $I11, 4096, rx200_tgt, $I10
    if $I11, rxanchor205_done
    ne rx200_pos, rx200_eos, rx200_fail
    eq rx200_pos, 0, rxanchor205_done
    dec $I10
    is_cclass $I11, 4096, rx200_tgt, $I10
    if $I11, rx200_fail
  rxanchor205_done:
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."MARKER"("endstmt")
    unless $P10, rx200_fail
    goto alt203_end
  alt203_1:
.annotate 'line', 53
  # rx rxquantr206 ** 0..1
    set_addr $I10, rxquantr206_done
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxquantr206_loop:
  # rx subrule "unv" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."unv"()
    unless $P10, rx200_fail
    goto rxsubrule207_pass
  rxsubrule207_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx200_fail
  rxsubrule207_pass:
    set_addr $I10, rxsubrule207_back
    rx200_cur."!mark_push"(0, rx200_pos, $I10, $P10)
    rx200_pos = $P10."pos"()
    set_addr $I10, rxquantr206_done
    (rx200_rep) = rx200_cur."!mark_commit"($I10)
  rxquantr206_done:
  # rxanchor eol
    sub $I10, rx200_pos, rx200_off
    is_cclass $I11, 4096, rx200_tgt, $I10
    if $I11, rxanchor208_done
    ne rx200_pos, rx200_eos, rx200_fail
    eq rx200_pos, 0, rxanchor208_done
    dec $I10
    is_cclass $I11, 4096, rx200_tgt, $I10
    if $I11, rx200_fail
  rxanchor208_done:
  # rx subrule "ws" subtype=method negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."ws"()
    unless $P10, rx200_fail
    rx200_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."MARKER"("endstmt")
    unless $P10, rx200_fail
  alt203_end:
.annotate 'line', 54
    set_addr $I10, rxquantr202_done
    (rx200_rep) = rx200_cur."!mark_commit"($I10)
  rxquantr202_done:
.annotate 'line', 50
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "ENDSTMT")
    if_null rx200_debug, debug_631
    rx200_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx200_pos)
  debug_631:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 10
    if_null rx200_debug, debug_632
    rx200_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_632:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_633
    rx200_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_633:
    .return (rx200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :subid("21_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P210, "ResizablePMCArray"
    push $P210, ""
    .return ($P210)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx212_tgt
    .local int rx212_pos
    .local int rx212_off
    .local int rx212_eos
    .local int rx212_rep
    .local pmc rx212_cur
    .local pmc rx212_debug
    (rx212_cur, rx212_pos, rx212_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx212_cur
    .local pmc match
    .lex "$/", match
    length rx212_eos, rx212_tgt
    gt rx212_pos, rx212_eos, rx212_done
    set rx212_off, 0
    lt rx212_pos, 2, rx212_start
    sub rx212_off, rx212_pos, 1
    substr rx212_tgt, rx212_tgt, rx212_off
  rx212_start:
    eq $I10, 1, rx212_restart
    if_null rx212_debug, debug_634
    rx212_cur."!cursor_debug"("START", "ws")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan213_done
    goto rxscan213_scan
  rxscan213_loop:
    (rx212_pos) = rx212_cur."from"()
    inc rx212_pos
    rx212_cur."!cursor_from"(rx212_pos)
    ge rx212_pos, rx212_eos, rxscan213_done
  rxscan213_scan:
    set_addr $I10, rxscan213_loop
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  rxscan213_done:
  alt214_0:
.annotate 'line', 57
    set_addr $I10, alt214_1
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 58
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."MARKED"("ws")
    unless $P10, rx212_fail
    goto alt214_end
  alt214_1:
.annotate 'line', 59
  # rx subrule "ww" subtype=zerowidth negate=1
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."ww"()
    if $P10, rx212_fail
.annotate 'line', 64
  # rx rxquantr215 ** 0..*
    set_addr $I10, rxquantr215_done
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  rxquantr215_loop:
  alt216_0:
.annotate 'line', 60
    set_addr $I10, alt216_1
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx212_pos, rx212_off
    set rx212_rep, 0
    sub $I12, rx212_eos, rx212_pos
  rxenumcharlistq217_loop:
    le $I12, 0, rxenumcharlistq217_done
    substr $S10, rx212_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq217_done
    inc rx212_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq217_loop
  rxenumcharlistq217_done:
    lt rx212_rep, 1, rx212_fail
    add rx212_pos, rx212_pos, rx212_rep
    goto alt216_end
  alt216_1:
    set_addr $I10, alt216_2
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 61
  # rx literal  "#"
    add $I11, rx212_pos, 1
    gt $I11, rx212_eos, rx212_fail
    sub $I11, rx212_pos, rx212_off
    ord $I11, rx212_tgt, $I11
    ne $I11, 35, rx212_fail
    add rx212_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx212_pos, rx212_off
    find_cclass $I11, 4096, rx212_tgt, $I10, rx212_eos
    add rx212_pos, rx212_off, $I11
    goto alt216_end
  alt216_2:
    set_addr $I10, alt216_3
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 62
  # rxanchor bol
    eq rx212_pos, 0, rxanchor218_done
    ge rx212_pos, rx212_eos, rx212_fail
    sub $I10, rx212_pos, rx212_off
    dec $I10
    is_cclass $I11, 4096, rx212_tgt, $I10
    unless $I11, rx212_fail
  rxanchor218_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."pod_comment"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
    goto alt216_end
  alt216_3:
.annotate 'line', 63
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx212_pos, rx212_off
    set rx212_rep, 0
    sub $I12, rx212_eos, rx212_pos
  rxenumcharlistq219_loop:
    le $I12, 0, rxenumcharlistq219_done
    substr $S10, rx212_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq219_done
    inc rx212_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq219_loop
  rxenumcharlistq219_done:
    lt rx212_rep, 1, rx212_fail
    add rx212_pos, rx212_pos, rx212_rep
  alt216_end:
.annotate 'line', 64
    set_addr $I10, rxquantr215_done
    (rx212_rep) = rx212_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr215_done
    rx212_cur."!mark_push"(rx212_rep, rx212_pos, $I10)
    goto rxquantr215_loop
  rxquantr215_done:
.annotate 'line', 65
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."MARKER"("ws")
    unless $P10, rx212_fail
  alt214_end:
.annotate 'line', 57
  # rx pass
    rx212_cur."!cursor_pass"(rx212_pos, "ws")
    if_null rx212_debug, debug_635
    rx212_cur."!cursor_debug"("PASS", "ws", " at pos=", rx212_pos)
  debug_635:
    .return (rx212_cur)
  rx212_restart:
.annotate 'line', 10
    if_null rx212_debug, debug_636
    rx212_cur."!cursor_debug"("NEXT", "ws")
  debug_636:
  rx212_fail:
    (rx212_rep, rx212_pos, $I10, $P10) = rx212_cur."!mark_fail"(0)
    lt rx212_pos, -1, rx212_done
    eq rx212_pos, -1, rx212_fail
    jump $I10
  rx212_done:
    rx212_cur."!cursor_fail"()
    if_null rx212_debug, debug_637
    rx212_cur."!cursor_debug"("FAIL", "ws")
  debug_637:
    .return (rx212_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :subid("23_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P221, "ResizablePMCArray"
    push $P221, ""
    push $P221, ""
    .return ($P221)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P228 = "25_1304516047.681" 
    capture_lex $P228
    .local string rx223_tgt
    .local int rx223_pos
    .local int rx223_off
    .local int rx223_eos
    .local int rx223_rep
    .local pmc rx223_cur
    .local pmc rx223_debug
    (rx223_cur, rx223_pos, rx223_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx223_cur
    .local pmc match
    .lex "$/", match
    length rx223_eos, rx223_tgt
    gt rx223_pos, rx223_eos, rx223_done
    set rx223_off, 0
    lt rx223_pos, 2, rx223_start
    sub rx223_off, rx223_pos, 1
    substr rx223_tgt, rx223_tgt, rx223_off
  rx223_start:
    eq $I10, 1, rx223_restart
    if_null rx223_debug, debug_638
    rx223_cur."!cursor_debug"("START", "unv")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan224_done
    goto rxscan224_scan
  rxscan224_loop:
    (rx223_pos) = rx223_cur."from"()
    inc rx223_pos
    rx223_cur."!cursor_from"(rx223_pos)
    ge rx223_pos, rx223_eos, rxscan224_done
  rxscan224_scan:
    set_addr $I10, rxscan224_loop
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
  rxscan224_done:
  alt225_0:
.annotate 'line', 70
    set_addr $I10, alt225_1
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
.annotate 'line', 71
  # rxanchor bol
    eq rx223_pos, 0, rxanchor226_done
    ge rx223_pos, rx223_eos, rx223_fail
    sub $I10, rx223_pos, rx223_off
    dec $I10
    is_cclass $I11, 4096, rx223_tgt, $I10
    unless $I11, rx223_fail
  rxanchor226_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    .const 'Sub' $P228 = "25_1304516047.681" 
    capture_lex $P228
    $P10 = rx223_cur."before"($P228)
    unless $P10, rx223_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx223_cur."!cursor_pos"(rx223_pos)
    $P10 = rx223_cur."pod_comment"()
    unless $P10, rx223_fail
    rx223_pos = $P10."pos"()
    goto alt225_end
  alt225_1:
    set_addr $I10, alt225_2
    rx223_cur."!mark_push"(0, rx223_pos, $I10)
.annotate 'line', 72
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx223_pos, rx223_off
    set rx223_rep, 0
    sub $I12, rx223_eos, rx223_pos
  rxenumcharlistq233_loop:
    le $I12, 0, rxenumcharlistq233_done
    substr $S10, rx223_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq233_done
    inc rx223_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq233_loop
  rxenumcharlistq233_done:
    add rx223_pos, rx223_pos, rx223_rep
  # rx literal  "#"
    add $I11, rx223_pos, 1
    gt $I11, rx223_eos, rx223_fail
    sub $I11, rx223_pos, rx223_off
    ord $I11, rx223_tgt, $I11
    ne $I11, 35, rx223_fail
    add rx223_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx223_pos, rx223_off
    find_cclass $I11, 4096, rx223_tgt, $I10, rx223_eos
    add rx223_pos, rx223_off, $I11
    goto alt225_end
  alt225_2:
.annotate 'line', 73
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx223_pos, rx223_off
    set rx223_rep, 0
    sub $I12, rx223_eos, rx223_pos
  rxenumcharlistq234_loop:
    le $I12, 0, rxenumcharlistq234_done
    substr $S10, rx223_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq234_done
    inc rx223_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq234_loop
  rxenumcharlistq234_done:
    lt rx223_rep, 1, rx223_fail
    add rx223_pos, rx223_pos, rx223_rep
  alt225_end:
.annotate 'line', 68
  # rx pass
    rx223_cur."!cursor_pass"(rx223_pos, "unv")
    if_null rx223_debug, debug_643
    rx223_cur."!cursor_debug"("PASS", "unv", " at pos=", rx223_pos)
  debug_643:
    .return (rx223_cur)
  rx223_restart:
.annotate 'line', 10
    if_null rx223_debug, debug_644
    rx223_cur."!cursor_debug"("NEXT", "unv")
  debug_644:
  rx223_fail:
    (rx223_rep, rx223_pos, $I10, $P10) = rx223_cur."!mark_fail"(0)
    lt rx223_pos, -1, rx223_done
    eq rx223_pos, -1, rx223_fail
    jump $I10
  rx223_done:
    rx223_cur."!cursor_fail"()
    if_null rx223_debug, debug_645
    rx223_cur."!cursor_debug"("FAIL", "unv")
  debug_645:
    .return (rx223_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block227"  :anon :subid("25_1304516047.681") :method :outer("24_1304516047.681")
.annotate 'line', 71
    .local string rx229_tgt
    .local int rx229_pos
    .local int rx229_off
    .local int rx229_eos
    .local int rx229_rep
    .local pmc rx229_cur
    .local pmc rx229_debug
    (rx229_cur, rx229_pos, rx229_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx229_cur
    .local pmc match
    .lex "$/", match
    length rx229_eos, rx229_tgt
    gt rx229_pos, rx229_eos, rx229_done
    set rx229_off, 0
    lt rx229_pos, 2, rx229_start
    sub rx229_off, rx229_pos, 1
    substr rx229_tgt, rx229_tgt, rx229_off
  rx229_start:
    eq $I10, 1, rx229_restart
    if_null rx229_debug, debug_639
    rx229_cur."!cursor_debug"("START", "")
  debug_639:
    $I10 = self.'from'()
    ne $I10, -1, rxscan230_done
    goto rxscan230_scan
  rxscan230_loop:
    (rx229_pos) = rx229_cur."from"()
    inc rx229_pos
    rx229_cur."!cursor_from"(rx229_pos)
    ge rx229_pos, rx229_eos, rxscan230_done
  rxscan230_scan:
    set_addr $I10, rxscan230_loop
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  rxscan230_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx229_pos, rx229_off
    set rx229_rep, 0
    sub $I12, rx229_eos, rx229_pos
  rxenumcharlistq231_loop:
    le $I12, 0, rxenumcharlistq231_done
    substr $S10, rx229_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq231_done
    inc rx229_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq231_loop
  rxenumcharlistq231_done:
    add rx229_pos, rx229_pos, rx229_rep
  # rx literal  "="
    add $I11, rx229_pos, 1
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    ord $I11, rx229_tgt, $I11
    ne $I11, 61, rx229_fail
    add rx229_pos, 1
  alt232_0:
    set_addr $I10, alt232_1
    rx229_cur."!mark_push"(0, rx229_pos, $I10)
  # rx charclass w
    ge rx229_pos, rx229_eos, rx229_fail
    sub $I10, rx229_pos, rx229_off
    is_cclass $I11, 8192, rx229_tgt, $I10
    unless $I11, rx229_fail
    inc rx229_pos
    goto alt232_end
  alt232_1:
  # rx literal  "\\"
    add $I11, rx229_pos, 1
    gt $I11, rx229_eos, rx229_fail
    sub $I11, rx229_pos, rx229_off
    ord $I11, rx229_tgt, $I11
    ne $I11, 92, rx229_fail
    add rx229_pos, 1
  alt232_end:
  # rx pass
    rx229_cur."!cursor_pass"(rx229_pos, "")
    if_null rx229_debug, debug_640
    rx229_cur."!cursor_debug"("PASS", "", " at pos=", rx229_pos)
  debug_640:
    .return (rx229_cur)
  rx229_restart:
    if_null rx229_debug, debug_641
    rx229_cur."!cursor_debug"("NEXT", "")
  debug_641:
  rx229_fail:
    (rx229_rep, rx229_pos, $I10, $P10) = rx229_cur."!mark_fail"(0)
    lt rx229_pos, -1, rx229_done
    eq rx229_pos, -1, rx229_fail
    jump $I10
  rx229_done:
    rx229_cur."!cursor_fail"()
    if_null rx229_debug, debug_642
    rx229_cur."!cursor_debug"("FAIL", "")
  debug_642:
    .return (rx229_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :subid("26_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P236, "ResizablePMCArray"
    push $P236, ""
    push $P236, ""
    push $P236, ""
    .return ($P236)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P267 = "28_1304516047.681" 
    capture_lex $P267
    .local string rx238_tgt
    .local int rx238_pos
    .local int rx238_off
    .local int rx238_eos
    .local int rx238_rep
    .local pmc rx238_cur
    .local pmc rx238_debug
    (rx238_cur, rx238_pos, rx238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx238_cur
    .local pmc match
    .lex "$/", match
    length rx238_eos, rx238_tgt
    gt rx238_pos, rx238_eos, rx238_done
    set rx238_off, 0
    lt rx238_pos, 2, rx238_start
    sub rx238_off, rx238_pos, 1
    substr rx238_tgt, rx238_tgt, rx238_off
  rx238_start:
    eq $I10, 1, rx238_restart
    if_null rx238_debug, debug_646
    rx238_cur."!cursor_debug"("START", "pod_comment")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan239_done
    goto rxscan239_scan
  rxscan239_loop:
    (rx238_pos) = rx238_cur."from"()
    inc rx238_pos
    rx238_cur."!cursor_from"(rx238_pos)
    ge rx238_pos, rx238_eos, rxscan239_done
  rxscan239_scan:
    set_addr $I10, rxscan239_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  rxscan239_done:
.annotate 'line', 78
  # rxanchor bol
    eq rx238_pos, 0, rxanchor240_done
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    dec $I10
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
  rxanchor240_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq241_loop:
    le $I12, 0, rxenumcharlistq241_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq241_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq241_loop
  rxenumcharlistq241_done:
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "="
    add $I11, rx238_pos, 1
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    ord $I11, rx238_tgt, $I11
    ne $I11, 61, rx238_fail
    add rx238_pos, 1
  alt242_0:
.annotate 'line', 79
    set_addr $I10, alt242_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx238_pos, 5
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 5
    ne $S10, "begin", rx238_fail
    add rx238_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq243_loop:
    le $I12, 0, rxenumcharlistq243_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq243_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq243_loop
  rxenumcharlistq243_done:
    lt rx238_rep, 1, rx238_fail
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "END"
    add $I11, rx238_pos, 3
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 3
    ne $S10, "END", rx238_fail
    add rx238_pos, 3
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  alt244_0:
.annotate 'line', 81
    set_addr $I10, alt244_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx rxquantf245 ** 0..*
    set_addr $I10, rxquantf245_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
    goto rxquantf245_done
  rxquantf245_loop:
  # rx charclass .
    ge rx238_pos, rx238_eos, rx238_fail
    inc rx238_pos
    set_addr $I10, rxquantf245_loop
    rx238_cur."!mark_push"(rx238_rep, rx238_pos, $I10)
  rxquantf245_done:
  # rx charclass nl
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
    substr $S10, rx238_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx238_pos, $I11
    inc rx238_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq247_loop:
    le $I12, 0, rxenumcharlistq247_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq247_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq247_loop
  rxenumcharlistq247_done:
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "=end"
    add $I11, rx238_pos, 4
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 4
    ne $S10, "=end", rx238_fail
    add rx238_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq248_loop:
    le $I12, 0, rxenumcharlistq248_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq248_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq248_loop
  rxenumcharlistq248_done:
    lt rx238_rep, 1, rx238_fail
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "END"
    add $I11, rx238_pos, 3
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 3
    ne $S10, "END", rx238_fail
    add rx238_pos, 3
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_cclass $I11, 4096, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
    goto alt244_end
  alt244_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_not_cclass $I11, 65535, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
  alt244_end:
.annotate 'line', 80
    goto alt242_end
  alt242_1:
    set_addr $I10, alt242_2
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 82
  # rx literal  "begin"
    add $I11, rx238_pos, 5
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 5
    ne $S10, "begin", rx238_fail
    add rx238_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq249_loop:
    le $I12, 0, rxenumcharlistq249_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq249_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq249_loop
  rxenumcharlistq249_done:
    lt rx238_rep, 1, rx238_fail
    add rx238_pos, rx238_pos, rx238_rep
  # rx subrule "identifier" subtype=capture negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."identifier"()
    unless $P10, rx238_fail
    rx238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx238_pos = $P10."pos"()
  alt250_0:
.annotate 'line', 83
    set_addr $I10, alt250_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 84
  # rx rxquantf251 ** 0..*
    set_addr $I10, rxquantf251_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
    goto rxquantf251_done
  rxquantf251_loop:
  # rx charclass .
    ge rx238_pos, rx238_eos, rx238_fail
    inc rx238_pos
    set_addr $I10, rxquantf251_loop
    rx238_cur."!mark_push"(rx238_rep, rx238_pos, $I10)
  rxquantf251_done:
  # rx charclass nl
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
    substr $S10, rx238_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx238_pos, $I11
    inc rx238_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq253_loop:
    le $I12, 0, rxenumcharlistq253_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq253_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq253_loop
  rxenumcharlistq253_done:
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "=end"
    add $I11, rx238_pos, 4
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 4
    ne $S10, "=end", rx238_fail
    add rx238_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq254_loop:
    le $I12, 0, rxenumcharlistq254_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq254_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq254_loop
  rxenumcharlistq254_done:
    lt rx238_rep, 1, rx238_fail
    add rx238_pos, rx238_pos, rx238_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."!BACKREF"("identifier")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_cclass $I11, 4096, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
    goto alt250_end
  alt250_1:
.annotate 'line', 85
  # rx subrule "panic" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."panic"("=begin without matching =end")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt250_end:
.annotate 'line', 82
    goto alt242_end
  alt242_2:
    set_addr $I10, alt242_3
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx238_pos, 5
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 5
    ne $S10, "begin", rx238_fail
    add rx238_pos, 5
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq256_loop:
    le $I12, 0, rxenumcharlistq256_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq256_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq256_loop
  rxenumcharlistq256_done:
    add rx238_pos, rx238_pos, rx238_rep
  alt257_0:
.annotate 'line', 88
    set_addr $I10, alt257_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rxanchor eol
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 4096, rx238_tgt, $I10
    if $I11, rxanchor258_done
    ne rx238_pos, rx238_eos, rx238_fail
    eq rx238_pos, 0, rxanchor258_done
    dec $I10
    is_cclass $I11, 4096, rx238_tgt, $I10
    if $I11, rx238_fail
  rxanchor258_done:
    goto alt257_end
  alt257_1:
    set_addr $I10, alt257_2
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx literal  "#"
    add $I11, rx238_pos, 1
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    ord $I11, rx238_tgt, $I11
    ne $I11, 35, rx238_fail
    add rx238_pos, 1
    goto alt257_end
  alt257_2:
  # rx subrule "panic" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt257_end:
  alt259_0:
.annotate 'line', 89
    set_addr $I10, alt259_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 90
  # rx rxquantf260 ** 0..*
    set_addr $I10, rxquantf260_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
    goto rxquantf260_done
  rxquantf260_loop:
  # rx charclass .
    ge rx238_pos, rx238_eos, rx238_fail
    inc rx238_pos
    set_addr $I10, rxquantf260_loop
    rx238_cur."!mark_push"(rx238_rep, rx238_pos, $I10)
  rxquantf260_done:
  # rx charclass nl
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
    substr $S10, rx238_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx238_pos, $I11
    inc rx238_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx238_pos, rx238_off
    set rx238_rep, 0
    sub $I12, rx238_eos, rx238_pos
  rxenumcharlistq262_loop:
    le $I12, 0, rxenumcharlistq262_done
    substr $S10, rx238_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq262_done
    inc rx238_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq262_loop
  rxenumcharlistq262_done:
    add rx238_pos, rx238_pos, rx238_rep
  # rx literal  "=end"
    add $I11, rx238_pos, 4
    gt $I11, rx238_eos, rx238_fail
    sub $I11, rx238_pos, rx238_off
    substr $S10, rx238_tgt, $I11, 4
    ne $S10, "=end", rx238_fail
    add rx238_pos, 4
  # rxanchor rwb
    le rx238_pos, 0, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 8192, rx238_tgt, $I10
    if $I11, rx238_fail
    dec $I10
    is_cclass $I11, 8192, rx238_tgt, $I10
    unless $I11, rx238_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_cclass $I11, 4096, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
    goto alt259_end
  alt259_1:
.annotate 'line', 91
  # rx subrule "panic" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."panic"("=begin without matching =end")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt259_end:
.annotate 'line', 87
    goto alt242_end
  alt242_3:
    set_addr $I10, alt242_4
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
.annotate 'line', 93
  # rx subrule "identifier" subtype=capture negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."identifier"()
    unless $P10, rx238_fail
    rx238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx238_pos = $P10."pos"()
.annotate 'line', 94
  # rx rxquantf263 ** 0..*
    set_addr $I10, rxquantf263_loop
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
    goto rxquantf263_done
  rxquantf263_loop:
  # rx charclass .
    ge rx238_pos, rx238_eos, rx238_fail
    inc rx238_pos
    set_addr $I10, rxquantf263_loop
    rx238_cur."!mark_push"(rx238_rep, rx238_pos, $I10)
  rxquantf263_done:
  # rxanchor bol
    eq rx238_pos, 0, rxanchor265_done
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    dec $I10
    is_cclass $I11, 4096, rx238_tgt, $I10
    unless $I11, rx238_fail
  rxanchor265_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    .const 'Sub' $P267 = "28_1304516047.681" 
    capture_lex $P267
    $P10 = rx238_cur."before"($P267)
    unless $P10, rx238_fail
.annotate 'line', 93
    goto alt242_end
  alt242_4:
  alt273_0:
.annotate 'line', 100
    set_addr $I10, alt273_1
    rx238_cur."!mark_push"(0, rx238_pos, $I10)
  # rx charclass s
    ge rx238_pos, rx238_eos, rx238_fail
    sub $I10, rx238_pos, rx238_off
    is_cclass $I11, 32, rx238_tgt, $I10
    unless $I11, rx238_fail
    inc rx238_pos
    goto alt273_end
  alt273_1:
  # rx subrule "panic" subtype=method negate=
    rx238_cur."!cursor_pos"(rx238_pos)
    $P10 = rx238_cur."panic"("Illegal pod directive")
    unless $P10, rx238_fail
    rx238_pos = $P10."pos"()
  alt273_end:
.annotate 'line', 101
  # rx charclass_q N r 0..-1
    sub $I10, rx238_pos, rx238_off
    find_cclass $I11, 4096, rx238_tgt, $I10, rx238_eos
    add rx238_pos, rx238_off, $I11
  alt242_end:
.annotate 'line', 77
  # rx pass
    rx238_cur."!cursor_pass"(rx238_pos, "pod_comment")
    if_null rx238_debug, debug_651
    rx238_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx238_pos)
  debug_651:
    .return (rx238_cur)
  rx238_restart:
.annotate 'line', 10
    if_null rx238_debug, debug_652
    rx238_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_652:
  rx238_fail:
    (rx238_rep, rx238_pos, $I10, $P10) = rx238_cur."!mark_fail"(0)
    lt rx238_pos, -1, rx238_done
    eq rx238_pos, -1, rx238_fail
    jump $I10
  rx238_done:
    rx238_cur."!cursor_fail"()
    if_null rx238_debug, debug_653
    rx238_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_653:
    .return (rx238_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block266"  :anon :subid("28_1304516047.681") :method :outer("27_1304516047.681")
.annotate 'line', 94
    .local string rx268_tgt
    .local int rx268_pos
    .local int rx268_off
    .local int rx268_eos
    .local int rx268_rep
    .local pmc rx268_cur
    .local pmc rx268_debug
    (rx268_cur, rx268_pos, rx268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx268_cur
    .local pmc match
    .lex "$/", match
    length rx268_eos, rx268_tgt
    gt rx268_pos, rx268_eos, rx268_done
    set rx268_off, 0
    lt rx268_pos, 2, rx268_start
    sub rx268_off, rx268_pos, 1
    substr rx268_tgt, rx268_tgt, rx268_off
  rx268_start:
    eq $I10, 1, rx268_restart
    if_null rx268_debug, debug_647
    rx268_cur."!cursor_debug"("START", "")
  debug_647:
    $I10 = self.'from'()
    ne $I10, -1, rxscan269_done
    goto rxscan269_scan
  rxscan269_loop:
    (rx268_pos) = rx268_cur."from"()
    inc rx268_pos
    rx268_cur."!cursor_from"(rx268_pos)
    ge rx268_pos, rx268_eos, rxscan269_done
  rxscan269_scan:
    set_addr $I10, rxscan269_loop
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxscan269_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx268_pos, rx268_off
    set rx268_rep, 0
    sub $I12, rx268_eos, rx268_pos
  rxenumcharlistq270_loop:
    le $I12, 0, rxenumcharlistq270_done
    substr $S10, rx268_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq270_done
    inc rx268_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq270_loop
  rxenumcharlistq270_done:
    add rx268_pos, rx268_pos, rx268_rep
  alt271_0:
    set_addr $I10, alt271_1
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
.annotate 'line', 95
  # rx literal  "="
    add $I11, rx268_pos, 1
    gt $I11, rx268_eos, rx268_fail
    sub $I11, rx268_pos, rx268_off
    ord $I11, rx268_tgt, $I11
    ne $I11, 61, rx268_fail
    add rx268_pos, 1
.annotate 'line', 97
  # rx rxquantr272 ** 0..1
    set_addr $I10, rxquantr272_done
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxquantr272_loop:
.annotate 'line', 96
  # rx literal  "cut"
    add $I11, rx268_pos, 3
    gt $I11, rx268_eos, rx268_fail
    sub $I11, rx268_pos, rx268_off
    substr $S10, rx268_tgt, $I11, 3
    ne $S10, "cut", rx268_fail
    add rx268_pos, 3
  # rxanchor rwb
    le rx268_pos, 0, rx268_fail
    sub $I10, rx268_pos, rx268_off
    is_cclass $I11, 8192, rx268_tgt, $I10
    if $I11, rx268_fail
    dec $I10
    is_cclass $I11, 8192, rx268_tgt, $I10
    unless $I11, rx268_fail
.annotate 'line', 97
  # rx subrule "panic" subtype=method negate=
    rx268_cur."!cursor_pos"(rx268_pos)
    $P10 = rx268_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx268_fail
    rx268_pos = $P10."pos"()
    set_addr $I10, rxquantr272_done
    (rx268_rep) = rx268_cur."!mark_commit"($I10)
  rxquantr272_done:
.annotate 'line', 94
    goto alt271_end
  alt271_1:
.annotate 'line', 98
  # rx charclass nl
    ge rx268_pos, rx268_eos, rx268_fail
    sub $I10, rx268_pos, rx268_off
    is_cclass $I11, 4096, rx268_tgt, $I10
    unless $I11, rx268_fail
    substr $S10, rx268_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx268_pos, $I11
    inc rx268_pos
  alt271_end:
.annotate 'line', 94
  # rx pass
    rx268_cur."!cursor_pass"(rx268_pos, "")
    if_null rx268_debug, debug_648
    rx268_cur."!cursor_debug"("PASS", "", " at pos=", rx268_pos)
  debug_648:
    .return (rx268_cur)
  rx268_restart:
    if_null rx268_debug, debug_649
    rx268_cur."!cursor_debug"("NEXT", "")
  debug_649:
  rx268_fail:
    (rx268_rep, rx268_pos, $I10, $P10) = rx268_cur."!mark_fail"(0)
    lt rx268_pos, -1, rx268_done
    eq rx268_pos, -1, rx268_fail
    jump $I10
  rx268_done:
    rx268_cur."!cursor_fail"()
    if_null rx268_debug, debug_650
    rx268_cur."!cursor_debug"("FAIL", "")
  debug_650:
    .return (rx268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :subid("29_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P275, "ResizablePMCArray"
    push $P275, ""
    .return ($P275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 109
    new $P277, "Undef"
    .lex "$*IN_DECL", $P277
.annotate 'line', 111
    new $P278, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P278
.annotate 'line', 112
    new $P279, "Undef"
    .lex "$*MAIN_SUB", $P279
.annotate 'line', 115
    new $P280, "Undef"
    .lex "$*PACKAGE", $P280
.annotate 'line', 116
    new $P281, "Undef"
    .lex "$*GLOBALish", $P281
.annotate 'line', 10
    .local string rx282_tgt
    .local int rx282_pos
    .local int rx282_off
    .local int rx282_eos
    .local int rx282_rep
    .local pmc rx282_cur
    .local pmc rx282_debug
    (rx282_cur, rx282_pos, rx282_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx282_cur
    .local pmc match
    .lex "$/", match
    length rx282_eos, rx282_tgt
    gt rx282_pos, rx282_eos, rx282_done
    set rx282_off, 0
    lt rx282_pos, 2, rx282_start
    sub rx282_off, rx282_pos, 1
    substr rx282_tgt, rx282_tgt, rx282_off
  rx282_start:
    eq $I10, 1, rx282_restart
    if_null rx282_debug, debug_654
    rx282_cur."!cursor_debug"("START", "comp_unit")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan283_done
    goto rxscan283_scan
  rxscan283_loop:
    (rx282_pos) = rx282_cur."from"()
    inc rx282_pos
    rx282_cur."!cursor_from"(rx282_pos)
    ge rx282_pos, rx282_eos, rxscan283_done
  rxscan283_scan:
    set_addr $I10, rxscan283_loop
    rx282_cur."!mark_push"(0, rx282_pos, $I10)
  rxscan283_done:
.annotate 'line', 109
    rx282_cur."!cursor_pos"(rx282_pos)
    new $P284, "String"
    assign $P284, ""
    store_lex "$*IN_DECL", $P284
.annotate 'line', 111
    rx282_cur."!cursor_pos"(rx282_pos)
    new $P285, "Integer"
    assign $P285, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P285
.annotate 'line', 112
    rx282_cur."!cursor_pos"(rx282_pos)
    find_lex $P288, "$*MAIN_SUB"
    unless_null $P288, vivify_655
    get_hll_global $P286, "GLOBAL"
    get_who $P287, $P286
    set $P288, $P287["$MAIN_SUB"]
    unless_null $P288, vivify_656
    die "Contextual $*MAIN_SUB not found"
  vivify_656:
  vivify_655:
.annotate 'line', 113
  # rx subrule "newpad" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."newpad"()
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
.annotate 'line', 115
    rx282_cur."!cursor_pos"(rx282_pos)
    find_lex $P291, "$*PACKAGE"
    unless_null $P291, vivify_657
    get_hll_global $P289, "GLOBAL"
    get_who $P290, $P289
    set $P291, $P290["$PACKAGE"]
    unless_null $P291, vivify_658
    die "Contextual $*PACKAGE not found"
  vivify_658:
  vivify_657:
.annotate 'line', 116
    rx282_cur."!cursor_pos"(rx282_pos)
    find_lex $P294, "$*GLOBALish"
    unless_null $P294, vivify_659
    get_hll_global $P292, "GLOBAL"
    get_who $P293, $P292
    set $P294, $P293["$GLOBALish"]
    unless_null $P294, vivify_660
    die "Contextual $*GLOBALish not found"
  vivify_660:
  vivify_659:
.annotate 'line', 117
  # rx subrule "GLOBALish" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."GLOBALish"()
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."outerctx"()
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
.annotate 'line', 121
  # rx subrule "statementlist" subtype=capture negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."statementlist"()
    unless $P10, rx282_fail
    rx282_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx282_pos = $P10."pos"()
  alt295_0:
.annotate 'line', 122
    set_addr $I10, alt295_1
    rx282_cur."!mark_push"(0, rx282_pos, $I10)
  # rxanchor eos
    ne rx282_pos, rx282_eos, rx282_fail
    goto alt295_end
  alt295_1:
  # rx subrule "panic" subtype=method negate=
    rx282_cur."!cursor_pos"(rx282_pos)
    $P10 = rx282_cur."panic"("Confused")
    unless $P10, rx282_fail
    rx282_pos = $P10."pos"()
  alt295_end:
.annotate 'line', 108
  # rx pass
    rx282_cur."!cursor_pass"(rx282_pos, "comp_unit")
    if_null rx282_debug, debug_661
    rx282_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx282_pos)
  debug_661:
    .return (rx282_cur)
  rx282_restart:
.annotate 'line', 10
    if_null rx282_debug, debug_662
    rx282_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_662:
  rx282_fail:
    (rx282_rep, rx282_pos, $I10, $P10) = rx282_cur."!mark_fail"(0)
    lt rx282_pos, -1, rx282_done
    eq rx282_pos, -1, rx282_fail
    jump $I10
  rx282_done:
    rx282_cur."!cursor_fail"()
    if_null rx282_debug, debug_663
    rx282_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_663:
    .return (rx282_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :subid("31_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P297 = self."!PREFIX__!subrule"("newpad", "")
    new $P298, "ResizablePMCArray"
    push $P298, $P297
    .return ($P298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx300_tgt
    .local int rx300_pos
    .local int rx300_off
    .local int rx300_eos
    .local int rx300_rep
    .local pmc rx300_cur
    .local pmc rx300_debug
    (rx300_cur, rx300_pos, rx300_tgt, $I10) = self."!cursor_start"()
    rx300_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx300_cur
    .local pmc match
    .lex "$/", match
    length rx300_eos, rx300_tgt
    gt rx300_pos, rx300_eos, rx300_done
    set rx300_off, 0
    lt rx300_pos, 2, rx300_start
    sub rx300_off, rx300_pos, 1
    substr rx300_tgt, rx300_tgt, rx300_off
  rx300_start:
    eq $I10, 1, rx300_restart
    if_null rx300_debug, debug_664
    rx300_cur."!cursor_debug"("START", "statementlist")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan301_done
    goto rxscan301_scan
  rxscan301_loop:
    (rx300_pos) = rx300_cur."from"()
    inc rx300_pos
    rx300_cur."!cursor_from"(rx300_pos)
    ge rx300_pos, rx300_eos, rxscan301_done
  rxscan301_scan:
    set_addr $I10, rxscan301_loop
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
  rxscan301_done:
  alt302_0:
.annotate 'line', 125
    set_addr $I10, alt302_1
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
.annotate 'line', 126
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  # rxanchor eos
    ne rx300_pos, rx300_eos, rx300_fail
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
    goto alt302_end
  alt302_1:
.annotate 'line', 127
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  # rx rxquantr306 ** 0..*
    set_addr $I10, rxquantr306_done
    rx300_cur."!mark_push"(0, rx300_pos, $I10)
  rxquantr306_loop:
  # rx subrule "statement" subtype=capture negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."statement"()
    unless $P10, rx300_fail
    rx300_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx300_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."eat_terminator"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
    set_addr $I10, rxquantr306_done
    (rx300_rep) = rx300_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr306_done
    rx300_cur."!mark_push"(rx300_rep, rx300_pos, $I10)
    goto rxquantr306_loop
  rxquantr306_done:
  # rx subrule "ws" subtype=method negate=
    rx300_cur."!cursor_pos"(rx300_pos)
    $P10 = rx300_cur."ws"()
    unless $P10, rx300_fail
    rx300_pos = $P10."pos"()
  alt302_end:
.annotate 'line', 125
  # rx pass
    rx300_cur."!cursor_pass"(rx300_pos, "statementlist")
    if_null rx300_debug, debug_665
    rx300_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx300_pos)
  debug_665:
    .return (rx300_cur)
  rx300_restart:
.annotate 'line', 10
    if_null rx300_debug, debug_666
    rx300_cur."!cursor_debug"("NEXT", "statementlist")
  debug_666:
  rx300_fail:
    (rx300_rep, rx300_pos, $I10, $P10) = rx300_cur."!mark_fail"(0)
    lt rx300_pos, -1, rx300_done
    eq rx300_pos, -1, rx300_fail
    jump $I10
  rx300_done:
    rx300_cur."!cursor_fail"()
    if_null rx300_debug, debug_667
    rx300_cur."!cursor_debug"("FAIL", "statementlist")
  debug_667:
    .return (rx300_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :subid("33_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P310 = self."!PREFIX__!subrule"("ws", "")
    $P311 = self."!PREFIX__!subrule"("ws", "")
    new $P312, "ResizablePMCArray"
    push $P312, $P310
    push $P312, $P311
    .return ($P312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P317 = "35_1304516047.681" 
    capture_lex $P317
    .local string rx314_tgt
    .local int rx314_pos
    .local int rx314_off
    .local int rx314_eos
    .local int rx314_rep
    .local pmc rx314_cur
    .local pmc rx314_debug
    (rx314_cur, rx314_pos, rx314_tgt, $I10) = self."!cursor_start"()
    rx314_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx314_cur
    .local pmc match
    .lex "$/", match
    length rx314_eos, rx314_tgt
    gt rx314_pos, rx314_eos, rx314_done
    set rx314_off, 0
    lt rx314_pos, 2, rx314_start
    sub rx314_off, rx314_pos, 1
    substr rx314_tgt, rx314_tgt, rx314_off
  rx314_start:
    eq $I10, 1, rx314_restart
    if_null rx314_debug, debug_668
    rx314_cur."!cursor_debug"("START", "statement")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan315_done
    goto rxscan315_scan
  rxscan315_loop:
    (rx314_pos) = rx314_cur."from"()
    inc rx314_pos
    rx314_cur."!cursor_from"(rx314_pos)
    ge rx314_pos, rx314_eos, rxscan315_done
  rxscan315_scan:
    set_addr $I10, rxscan315_loop
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxscan315_done:
.annotate 'line', 131
  # rx subrule "before" subtype=zerowidth negate=1
    rx314_cur."!cursor_pos"(rx314_pos)
    .const 'Sub' $P317 = "35_1304516047.681" 
    capture_lex $P317
    $P10 = rx314_cur."before"($P317)
    if $P10, rx314_fail
  alt321_0:
.annotate 'line', 132
    set_addr $I10, alt321_1
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
.annotate 'line', 133
  # rx subrule "statement_control" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."statement_control"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx314_pos = $P10."pos"()
    goto alt321_end
  alt321_1:
.annotate 'line', 134
  # rx subrule "EXPR" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."EXPR"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx314_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."ws"()
    unless $P10, rx314_fail
    rx314_pos = $P10."pos"()
.annotate 'line', 139
  # rx rxquantr322 ** 0..1
    set_addr $I10, rxquantr322_done
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxquantr322_loop:
  alt323_0:
.annotate 'line', 135
    set_addr $I10, alt323_1
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
.annotate 'line', 136
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."MARKED"("endstmt")
    unless $P10, rx314_fail
    goto alt323_end
  alt323_1:
    set_addr $I10, alt323_2
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
.annotate 'line', 137
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."statement_mod_cond"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx314_pos = $P10."pos"()
  # rx rxquantr324 ** 0..1
    set_addr $I10, rxquantr324_done
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxquantr324_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."statement_mod_loop"()
    unless $P10, rx314_fail
    goto rxsubrule325_pass
  rxsubrule325_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx314_fail
  rxsubrule325_pass:
    set_addr $I10, rxsubrule325_back
    rx314_cur."!mark_push"(0, rx314_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx314_pos = $P10."pos"()
    set_addr $I10, rxquantr324_done
    (rx314_rep) = rx314_cur."!mark_commit"($I10)
  rxquantr324_done:
    goto alt323_end
  alt323_2:
.annotate 'line', 138
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx314_cur."!cursor_pos"(rx314_pos)
    $P10 = rx314_cur."statement_mod_loop"()
    unless $P10, rx314_fail
    rx314_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx314_pos = $P10."pos"()
  alt323_end:
.annotate 'line', 139
    set_addr $I10, rxquantr322_done
    (rx314_rep) = rx314_cur."!mark_commit"($I10)
  rxquantr322_done:
  alt321_end:
.annotate 'line', 130
  # rx pass
    rx314_cur."!cursor_pass"(rx314_pos, "statement")
    if_null rx314_debug, debug_673
    rx314_cur."!cursor_debug"("PASS", "statement", " at pos=", rx314_pos)
  debug_673:
    .return (rx314_cur)
  rx314_restart:
.annotate 'line', 10
    if_null rx314_debug, debug_674
    rx314_cur."!cursor_debug"("NEXT", "statement")
  debug_674:
  rx314_fail:
    (rx314_rep, rx314_pos, $I10, $P10) = rx314_cur."!mark_fail"(0)
    lt rx314_pos, -1, rx314_done
    eq rx314_pos, -1, rx314_fail
    jump $I10
  rx314_done:
    rx314_cur."!cursor_fail"()
    if_null rx314_debug, debug_675
    rx314_cur."!cursor_debug"("FAIL", "statement")
  debug_675:
    .return (rx314_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block316"  :anon :subid("35_1304516047.681") :method :outer("34_1304516047.681")
.annotate 'line', 131
    .local string rx318_tgt
    .local int rx318_pos
    .local int rx318_off
    .local int rx318_eos
    .local int rx318_rep
    .local pmc rx318_cur
    .local pmc rx318_debug
    (rx318_cur, rx318_pos, rx318_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx318_cur
    .local pmc match
    .lex "$/", match
    length rx318_eos, rx318_tgt
    gt rx318_pos, rx318_eos, rx318_done
    set rx318_off, 0
    lt rx318_pos, 2, rx318_start
    sub rx318_off, rx318_pos, 1
    substr rx318_tgt, rx318_tgt, rx318_off
  rx318_start:
    eq $I10, 1, rx318_restart
    if_null rx318_debug, debug_669
    rx318_cur."!cursor_debug"("START", "")
  debug_669:
    $I10 = self.'from'()
    ne $I10, -1, rxscan319_done
    goto rxscan319_scan
  rxscan319_loop:
    (rx318_pos) = rx318_cur."from"()
    inc rx318_pos
    rx318_cur."!cursor_from"(rx318_pos)
    ge rx318_pos, rx318_eos, rxscan319_done
  rxscan319_scan:
    set_addr $I10, rxscan319_loop
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxscan319_done:
  alt320_0:
    set_addr $I10, alt320_1
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx318_fail
    inc rx318_pos
    goto alt320_end
  alt320_1:
  # rxanchor eos
    ne rx318_pos, rx318_eos, rx318_fail
  alt320_end:
  # rx pass
    rx318_cur."!cursor_pass"(rx318_pos, "")
    if_null rx318_debug, debug_670
    rx318_cur."!cursor_debug"("PASS", "", " at pos=", rx318_pos)
  debug_670:
    .return (rx318_cur)
  rx318_restart:
    if_null rx318_debug, debug_671
    rx318_cur."!cursor_debug"("NEXT", "")
  debug_671:
  rx318_fail:
    (rx318_rep, rx318_pos, $I10, $P10) = rx318_cur."!mark_fail"(0)
    lt rx318_pos, -1, rx318_done
    eq rx318_pos, -1, rx318_fail
    jump $I10
  rx318_done:
    rx318_cur."!cursor_fail"()
    if_null rx318_debug, debug_672
    rx318_cur."!cursor_debug"("FAIL", "")
  debug_672:
    .return (rx318_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :subid("36_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P327, "ResizablePMCArray"
    push $P327, ""
    .return ($P327)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx329_tgt
    .local int rx329_pos
    .local int rx329_off
    .local int rx329_eos
    .local int rx329_rep
    .local pmc rx329_cur
    .local pmc rx329_debug
    (rx329_cur, rx329_pos, rx329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx329_cur
    .local pmc match
    .lex "$/", match
    length rx329_eos, rx329_tgt
    gt rx329_pos, rx329_eos, rx329_done
    set rx329_off, 0
    lt rx329_pos, 2, rx329_start
    sub rx329_off, rx329_pos, 1
    substr rx329_tgt, rx329_tgt, rx329_off
  rx329_start:
    eq $I10, 1, rx329_restart
    if_null rx329_debug, debug_676
    rx329_cur."!cursor_debug"("START", "eat_terminator")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan330_done
    goto rxscan330_scan
  rxscan330_loop:
    (rx329_pos) = rx329_cur."from"()
    inc rx329_pos
    rx329_cur."!cursor_from"(rx329_pos)
    ge rx329_pos, rx329_eos, rxscan330_done
  rxscan330_scan:
    set_addr $I10, rxscan330_loop
    rx329_cur."!mark_push"(0, rx329_pos, $I10)
  rxscan330_done:
  alt331_0:
.annotate 'line', 143
    set_addr $I10, alt331_1
    rx329_cur."!mark_push"(0, rx329_pos, $I10)
.annotate 'line', 144
  # rx literal  ";"
    add $I11, rx329_pos, 1
    gt $I11, rx329_eos, rx329_fail
    sub $I11, rx329_pos, rx329_off
    ord $I11, rx329_tgt, $I11
    ne $I11, 59, rx329_fail
    add rx329_pos, 1
    goto alt331_end
  alt331_1:
    set_addr $I10, alt331_2
    rx329_cur."!mark_push"(0, rx329_pos, $I10)
.annotate 'line', 145
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx329_cur."!cursor_pos"(rx329_pos)
    $P10 = rx329_cur."MARKED"("endstmt")
    unless $P10, rx329_fail
    goto alt331_end
  alt331_2:
    set_addr $I10, alt331_3
    rx329_cur."!mark_push"(0, rx329_pos, $I10)
.annotate 'line', 146
  # rx subrule "terminator" subtype=zerowidth negate=
    rx329_cur."!cursor_pos"(rx329_pos)
    $P10 = rx329_cur."terminator"()
    unless $P10, rx329_fail
    goto alt331_end
  alt331_3:
.annotate 'line', 147
  # rxanchor eos
    ne rx329_pos, rx329_eos, rx329_fail
  alt331_end:
.annotate 'line', 143
  # rx pass
    rx329_cur."!cursor_pass"(rx329_pos, "eat_terminator")
    if_null rx329_debug, debug_677
    rx329_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx329_pos)
  debug_677:
    .return (rx329_cur)
  rx329_restart:
.annotate 'line', 10
    if_null rx329_debug, debug_678
    rx329_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_678:
  rx329_fail:
    (rx329_rep, rx329_pos, $I10, $P10) = rx329_cur."!mark_fail"(0)
    lt rx329_pos, -1, rx329_done
    eq rx329_pos, -1, rx329_fail
    jump $I10
  rx329_done:
    rx329_cur."!cursor_fail"()
    if_null rx329_debug, debug_679
    rx329_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_679:
    .return (rx329_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :subid("38_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P333, "ResizablePMCArray"
    push $P333, ""
    push $P333, ""
    push $P333, ""
    push $P333, ";"
    .return ($P333)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx335_tgt
    .local int rx335_pos
    .local int rx335_off
    .local int rx335_eos
    .local int rx335_rep
    .local pmc rx335_cur
    .local pmc rx335_debug
    (rx335_cur, rx335_pos, rx335_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx335_cur
    .local pmc match
    .lex "$/", match
    length rx335_eos, rx335_tgt
    gt rx335_pos, rx335_eos, rx335_done
    set rx335_off, 0
    lt rx335_pos, 2, rx335_start
    sub rx335_off, rx335_pos, 1
    substr rx335_tgt, rx335_tgt, rx335_off
  rx335_start:
    eq $I10, 1, rx335_restart
    if_null rx335_debug, debug_680
    rx335_cur."!cursor_debug"("START", "xblock")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan336_done
    goto rxscan336_scan
  rxscan336_loop:
    (rx335_pos) = rx335_cur."from"()
    inc rx335_pos
    rx335_cur."!cursor_from"(rx335_pos)
    ge rx335_pos, rx335_eos, rxscan336_done
  rxscan336_scan:
    set_addr $I10, rxscan336_loop
    rx335_cur."!mark_push"(0, rx335_pos, $I10)
  rxscan336_done:
.annotate 'line', 151
  # rx subrule "EXPR" subtype=capture negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."EXPR"()
    unless $P10, rx335_fail
    rx335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx335_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."ws"()
    unless $P10, rx335_fail
    rx335_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx335_cur."!cursor_pos"(rx335_pos)
    $P10 = rx335_cur."pblock"()
    unless $P10, rx335_fail
    rx335_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx335_pos = $P10."pos"()
.annotate 'line', 150
  # rx pass
    rx335_cur."!cursor_pass"(rx335_pos, "xblock")
    if_null rx335_debug, debug_681
    rx335_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx335_pos)
  debug_681:
    .return (rx335_cur)
  rx335_restart:
.annotate 'line', 10
    if_null rx335_debug, debug_682
    rx335_cur."!cursor_debug"("NEXT", "xblock")
  debug_682:
  rx335_fail:
    (rx335_rep, rx335_pos, $I10, $P10) = rx335_cur."!mark_fail"(0)
    lt rx335_pos, -1, rx335_done
    eq rx335_pos, -1, rx335_fail
    jump $I10
  rx335_done:
    rx335_cur."!cursor_fail"()
    if_null rx335_debug, debug_683
    rx335_cur."!cursor_debug"("FAIL", "xblock")
  debug_683:
    .return (rx335_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :subid("40_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P338 = self."!PREFIX__!subrule"("EXPR", "")
    new $P339, "ResizablePMCArray"
    push $P339, $P338
    .return ($P339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx341_tgt
    .local int rx341_pos
    .local int rx341_off
    .local int rx341_eos
    .local int rx341_rep
    .local pmc rx341_cur
    .local pmc rx341_debug
    (rx341_cur, rx341_pos, rx341_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx341_cur
    .local pmc match
    .lex "$/", match
    length rx341_eos, rx341_tgt
    gt rx341_pos, rx341_eos, rx341_done
    set rx341_off, 0
    lt rx341_pos, 2, rx341_start
    sub rx341_off, rx341_pos, 1
    substr rx341_tgt, rx341_tgt, rx341_off
  rx341_start:
    eq $I10, 1, rx341_restart
    if_null rx341_debug, debug_684
    rx341_cur."!cursor_debug"("START", "pblock")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan342_done
    goto rxscan342_scan
  rxscan342_loop:
    (rx341_pos) = rx341_cur."from"()
    inc rx341_pos
    rx341_cur."!cursor_from"(rx341_pos)
    ge rx341_pos, rx341_eos, rxscan342_done
  rxscan342_scan:
    set_addr $I10, rxscan342_loop
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
  rxscan342_done:
  alt343_0:
.annotate 'line', 154
    set_addr $I10, alt343_1
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
.annotate 'line', 155
  # rx subrule "lambda" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."lambda"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
.annotate 'line', 156
  # rx subrule "newpad" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."newpad"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "signature" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."signature"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx341_pos = $P10."pos"()
.annotate 'line', 158
  # rx subrule "blockoid" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."blockoid"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx341_pos = $P10."pos"()
.annotate 'line', 155
    goto alt343_end
  alt343_1:
    set_addr $I10, alt343_2
    rx341_cur."!mark_push"(0, rx341_pos, $I10)
.annotate 'line', 159
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx341_pos, rx341_off
    substr $S10, rx341_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx341_fail
.annotate 'line', 160
  # rx subrule "newpad" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."newpad"()
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
.annotate 'line', 161
  # rx subrule "blockoid" subtype=capture negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."blockoid"()
    unless $P10, rx341_fail
    rx341_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx341_pos = $P10."pos"()
.annotate 'line', 159
    goto alt343_end
  alt343_2:
.annotate 'line', 162
  # rx subrule "panic" subtype=method negate=
    rx341_cur."!cursor_pos"(rx341_pos)
    $P10 = rx341_cur."panic"("Missing block")
    unless $P10, rx341_fail
    rx341_pos = $P10."pos"()
  alt343_end:
.annotate 'line', 154
  # rx pass
    rx341_cur."!cursor_pass"(rx341_pos, "pblock")
    if_null rx341_debug, debug_685
    rx341_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx341_pos)
  debug_685:
    .return (rx341_cur)
  rx341_restart:
.annotate 'line', 10
    if_null rx341_debug, debug_686
    rx341_cur."!cursor_debug"("NEXT", "pblock")
  debug_686:
  rx341_fail:
    (rx341_rep, rx341_pos, $I10, $P10) = rx341_cur."!mark_fail"(0)
    lt rx341_pos, -1, rx341_done
    eq rx341_pos, -1, rx341_fail
    jump $I10
  rx341_done:
    rx341_cur."!cursor_fail"()
    if_null rx341_debug, debug_687
    rx341_cur."!cursor_debug"("FAIL", "pblock")
  debug_687:
    .return (rx341_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :subid("42_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P345 = self."!PREFIX__!subrule"("panic", "")
    $P346 = self."!PREFIX__!subrule"("lambda", "")
    new $P347, "ResizablePMCArray"
    push $P347, $P345
    push $P347, "{"
    push $P347, $P346
    .return ($P347)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx349_tgt
    .local int rx349_pos
    .local int rx349_off
    .local int rx349_eos
    .local int rx349_rep
    .local pmc rx349_cur
    .local pmc rx349_debug
    (rx349_cur, rx349_pos, rx349_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx349_cur
    .local pmc match
    .lex "$/", match
    length rx349_eos, rx349_tgt
    gt rx349_pos, rx349_eos, rx349_done
    set rx349_off, 0
    lt rx349_pos, 2, rx349_start
    sub rx349_off, rx349_pos, 1
    substr rx349_tgt, rx349_tgt, rx349_off
  rx349_start:
    eq $I10, 1, rx349_restart
    if_null rx349_debug, debug_688
    rx349_cur."!cursor_debug"("START", "lambda")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan350_done
    goto rxscan350_scan
  rxscan350_loop:
    (rx349_pos) = rx349_cur."from"()
    inc rx349_pos
    rx349_cur."!cursor_from"(rx349_pos)
    ge rx349_pos, rx349_eos, rxscan350_done
  rxscan350_scan:
    set_addr $I10, rxscan350_loop
    rx349_cur."!mark_push"(0, rx349_pos, $I10)
  rxscan350_done:
  alt351_0:
.annotate 'line', 165
    set_addr $I10, alt351_1
    rx349_cur."!mark_push"(0, rx349_pos, $I10)
  # rx literal  "->"
    add $I11, rx349_pos, 2
    gt $I11, rx349_eos, rx349_fail
    sub $I11, rx349_pos, rx349_off
    substr $S10, rx349_tgt, $I11, 2
    ne $S10, "->", rx349_fail
    add rx349_pos, 2
    goto alt351_end
  alt351_1:
  # rx literal  "<->"
    add $I11, rx349_pos, 3
    gt $I11, rx349_eos, rx349_fail
    sub $I11, rx349_pos, rx349_off
    substr $S10, rx349_tgt, $I11, 3
    ne $S10, "<->", rx349_fail
    add rx349_pos, 3
  alt351_end:
  # rx pass
    rx349_cur."!cursor_pass"(rx349_pos, "lambda")
    if_null rx349_debug, debug_689
    rx349_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx349_pos)
  debug_689:
    .return (rx349_cur)
  rx349_restart:
.annotate 'line', 10
    if_null rx349_debug, debug_690
    rx349_cur."!cursor_debug"("NEXT", "lambda")
  debug_690:
  rx349_fail:
    (rx349_rep, rx349_pos, $I10, $P10) = rx349_cur."!mark_fail"(0)
    lt rx349_pos, -1, rx349_done
    eq rx349_pos, -1, rx349_fail
    jump $I10
  rx349_done:
    rx349_cur."!cursor_fail"()
    if_null rx349_debug, debug_691
    rx349_cur."!cursor_debug"("FAIL", "lambda")
  debug_691:
    .return (rx349_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :subid("44_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P353, "ResizablePMCArray"
    push $P353, "<->"
    push $P353, "->"
    .return ($P353)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx355_tgt
    .local int rx355_pos
    .local int rx355_off
    .local int rx355_eos
    .local int rx355_rep
    .local pmc rx355_cur
    .local pmc rx355_debug
    (rx355_cur, rx355_pos, rx355_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx355_cur
    .local pmc match
    .lex "$/", match
    length rx355_eos, rx355_tgt
    gt rx355_pos, rx355_eos, rx355_done
    set rx355_off, 0
    lt rx355_pos, 2, rx355_start
    sub rx355_off, rx355_pos, 1
    substr rx355_tgt, rx355_tgt, rx355_off
  rx355_start:
    eq $I10, 1, rx355_restart
    if_null rx355_debug, debug_692
    rx355_cur."!cursor_debug"("START", "block")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan356_done
    goto rxscan356_scan
  rxscan356_loop:
    (rx355_pos) = rx355_cur."from"()
    inc rx355_pos
    rx355_cur."!cursor_from"(rx355_pos)
    ge rx355_pos, rx355_eos, rxscan356_done
  rxscan356_scan:
    set_addr $I10, rxscan356_loop
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  rxscan356_done:
  alt357_0:
.annotate 'line', 168
    set_addr $I10, alt357_1
    rx355_cur."!mark_push"(0, rx355_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx355_pos, rx355_off
    substr $S10, rx355_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx355_fail
    goto alt357_end
  alt357_1:
  # rx subrule "panic" subtype=method negate=
    rx355_cur."!cursor_pos"(rx355_pos)
    $P10 = rx355_cur."panic"("Missing block")
    unless $P10, rx355_fail
    rx355_pos = $P10."pos"()
  alt357_end:
.annotate 'line', 169
  # rx subrule "newpad" subtype=method negate=
    rx355_cur."!cursor_pos"(rx355_pos)
    $P10 = rx355_cur."newpad"()
    unless $P10, rx355_fail
    rx355_pos = $P10."pos"()
.annotate 'line', 170
  # rx subrule "blockoid" subtype=capture negate=
    rx355_cur."!cursor_pos"(rx355_pos)
    $P10 = rx355_cur."blockoid"()
    unless $P10, rx355_fail
    rx355_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx355_pos = $P10."pos"()
.annotate 'line', 167
  # rx pass
    rx355_cur."!cursor_pass"(rx355_pos, "block")
    if_null rx355_debug, debug_693
    rx355_cur."!cursor_debug"("PASS", "block", " at pos=", rx355_pos)
  debug_693:
    .return (rx355_cur)
  rx355_restart:
.annotate 'line', 10
    if_null rx355_debug, debug_694
    rx355_cur."!cursor_debug"("NEXT", "block")
  debug_694:
  rx355_fail:
    (rx355_rep, rx355_pos, $I10, $P10) = rx355_cur."!mark_fail"(0)
    lt rx355_pos, -1, rx355_done
    eq rx355_pos, -1, rx355_fail
    jump $I10
  rx355_done:
    rx355_cur."!cursor_fail"()
    if_null rx355_debug, debug_695
    rx355_cur."!cursor_debug"("FAIL", "block")
  debug_695:
    .return (rx355_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :subid("46_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P359 = self."!PREFIX__!subrule"("panic", "")
    new $P360, "ResizablePMCArray"
    push $P360, $P359
    push $P360, "{"
    .return ($P360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx362_tgt
    .local int rx362_pos
    .local int rx362_off
    .local int rx362_eos
    .local int rx362_rep
    .local pmc rx362_cur
    .local pmc rx362_debug
    (rx362_cur, rx362_pos, rx362_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx362_cur
    .local pmc match
    .lex "$/", match
    length rx362_eos, rx362_tgt
    gt rx362_pos, rx362_eos, rx362_done
    set rx362_off, 0
    lt rx362_pos, 2, rx362_start
    sub rx362_off, rx362_pos, 1
    substr rx362_tgt, rx362_tgt, rx362_off
  rx362_start:
    eq $I10, 1, rx362_restart
    if_null rx362_debug, debug_696
    rx362_cur."!cursor_debug"("START", "blockoid")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan363_done
    goto rxscan363_scan
  rxscan363_loop:
    (rx362_pos) = rx362_cur."from"()
    inc rx362_pos
    rx362_cur."!cursor_from"(rx362_pos)
    ge rx362_pos, rx362_eos, rxscan363_done
  rxscan363_scan:
    set_addr $I10, rxscan363_loop
    rx362_cur."!mark_push"(0, rx362_pos, $I10)
  rxscan363_done:
.annotate 'line', 174
  # rx subrule "finishpad" subtype=method negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."finishpad"()
    unless $P10, rx362_fail
    rx362_pos = $P10."pos"()
  alt364_0:
.annotate 'line', 175
    set_addr $I10, alt364_1
    rx362_cur."!mark_push"(0, rx362_pos, $I10)
.annotate 'line', 176
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx362_pos, 14
    gt $I11, rx362_eos, rx362_fail
    sub $I11, rx362_pos, rx362_off
    substr $S10, rx362_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx362_fail
    add rx362_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."you_are_here"()
    unless $P10, rx362_fail
    rx362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx362_pos = $P10."pos"()
    goto alt364_end
  alt364_1:
.annotate 'line', 177
  # rx literal  "{"
    add $I11, rx362_pos, 1
    gt $I11, rx362_eos, rx362_fail
    sub $I11, rx362_pos, rx362_off
    ord $I11, rx362_tgt, $I11
    ne $I11, 123, rx362_fail
    add rx362_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."statementlist"()
    unless $P10, rx362_fail
    rx362_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx362_pos = $P10."pos"()
  alt365_0:
    set_addr $I10, alt365_1
    rx362_cur."!mark_push"(0, rx362_pos, $I10)
  # rx literal  "}"
    add $I11, rx362_pos, 1
    gt $I11, rx362_eos, rx362_fail
    sub $I11, rx362_pos, rx362_off
    ord $I11, rx362_tgt, $I11
    ne $I11, 125, rx362_fail
    add rx362_pos, 1
    goto alt365_end
  alt365_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."FAILGOAL"("'}'")
    unless $P10, rx362_fail
    goto rxsubrule367_pass
  rxsubrule367_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx362_fail
  rxsubrule367_pass:
    set_addr $I10, rxsubrule367_back
    rx362_cur."!mark_push"(0, rx362_pos, $I10, $P10)
    rx362_pos = $P10."pos"()
  alt365_end:
  alt364_end:
.annotate 'line', 179
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx362_cur."!cursor_pos"(rx362_pos)
    $P10 = rx362_cur."ENDSTMT"()
    unless $P10, rx362_fail
.annotate 'line', 173
  # rx pass
    rx362_cur."!cursor_pass"(rx362_pos, "blockoid")
    if_null rx362_debug, debug_697
    rx362_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx362_pos)
  debug_697:
    .return (rx362_cur)
  rx362_restart:
.annotate 'line', 10
    if_null rx362_debug, debug_698
    rx362_cur."!cursor_debug"("NEXT", "blockoid")
  debug_698:
  rx362_fail:
    (rx362_rep, rx362_pos, $I10, $P10) = rx362_cur."!mark_fail"(0)
    lt rx362_pos, -1, rx362_done
    eq rx362_pos, -1, rx362_fail
    jump $I10
  rx362_done:
    rx362_cur."!cursor_fail"()
    if_null rx362_debug, debug_699
    rx362_cur."!cursor_debug"("FAIL", "blockoid")
  debug_699:
    .return (rx362_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :subid("48_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P369 = self."!PREFIX__!subrule"("finishpad", "")
    new $P370, "ResizablePMCArray"
    push $P370, $P369
    .return ($P370)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx372_tgt
    .local int rx372_pos
    .local int rx372_off
    .local int rx372_eos
    .local int rx372_rep
    .local pmc rx372_cur
    .local pmc rx372_debug
    (rx372_cur, rx372_pos, rx372_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx372_cur
    .local pmc match
    .lex "$/", match
    length rx372_eos, rx372_tgt
    gt rx372_pos, rx372_eos, rx372_done
    set rx372_off, 0
    lt rx372_pos, 2, rx372_start
    sub rx372_off, rx372_pos, 1
    substr rx372_tgt, rx372_tgt, rx372_off
  rx372_start:
    eq $I10, 1, rx372_restart
    if_null rx372_debug, debug_700
    rx372_cur."!cursor_debug"("START", "newpad")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan373_done
    goto rxscan373_scan
  rxscan373_loop:
    (rx372_pos) = rx372_cur."from"()
    inc rx372_pos
    rx372_cur."!cursor_from"(rx372_pos)
    ge rx372_pos, rx372_eos, rxscan373_done
  rxscan373_scan:
    set_addr $I10, rxscan373_loop
    rx372_cur."!mark_push"(0, rx372_pos, $I10)
  rxscan373_done:
.annotate 'line', 182
  # rx pass
    rx372_cur."!cursor_pass"(rx372_pos, "newpad")
    if_null rx372_debug, debug_701
    rx372_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx372_pos)
  debug_701:
    .return (rx372_cur)
  rx372_restart:
.annotate 'line', 10
    if_null rx372_debug, debug_702
    rx372_cur."!cursor_debug"("NEXT", "newpad")
  debug_702:
  rx372_fail:
    (rx372_rep, rx372_pos, $I10, $P10) = rx372_cur."!mark_fail"(0)
    lt rx372_pos, -1, rx372_done
    eq rx372_pos, -1, rx372_fail
    jump $I10
  rx372_done:
    rx372_cur."!cursor_fail"()
    if_null rx372_debug, debug_703
    rx372_cur."!cursor_debug"("FAIL", "newpad")
  debug_703:
    .return (rx372_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :subid("50_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P375, "ResizablePMCArray"
    push $P375, ""
    .return ($P375)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx377_tgt
    .local int rx377_pos
    .local int rx377_off
    .local int rx377_eos
    .local int rx377_rep
    .local pmc rx377_cur
    .local pmc rx377_debug
    (rx377_cur, rx377_pos, rx377_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx377_cur
    .local pmc match
    .lex "$/", match
    length rx377_eos, rx377_tgt
    gt rx377_pos, rx377_eos, rx377_done
    set rx377_off, 0
    lt rx377_pos, 2, rx377_start
    sub rx377_off, rx377_pos, 1
    substr rx377_tgt, rx377_tgt, rx377_off
  rx377_start:
    eq $I10, 1, rx377_restart
    if_null rx377_debug, debug_704
    rx377_cur."!cursor_debug"("START", "outerctx")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan378_done
    goto rxscan378_scan
  rxscan378_loop:
    (rx377_pos) = rx377_cur."from"()
    inc rx377_pos
    rx377_cur."!cursor_from"(rx377_pos)
    ge rx377_pos, rx377_eos, rxscan378_done
  rxscan378_scan:
    set_addr $I10, rxscan378_loop
    rx377_cur."!mark_push"(0, rx377_pos, $I10)
  rxscan378_done:
.annotate 'line', 183
  # rx pass
    rx377_cur."!cursor_pass"(rx377_pos, "outerctx")
    if_null rx377_debug, debug_705
    rx377_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx377_pos)
  debug_705:
    .return (rx377_cur)
  rx377_restart:
.annotate 'line', 10
    if_null rx377_debug, debug_706
    rx377_cur."!cursor_debug"("NEXT", "outerctx")
  debug_706:
  rx377_fail:
    (rx377_rep, rx377_pos, $I10, $P10) = rx377_cur."!mark_fail"(0)
    lt rx377_pos, -1, rx377_done
    eq rx377_pos, -1, rx377_fail
    jump $I10
  rx377_done:
    rx377_cur."!cursor_fail"()
    if_null rx377_debug, debug_707
    rx377_cur."!cursor_debug"("FAIL", "outerctx")
  debug_707:
    .return (rx377_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :subid("52_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P380, "ResizablePMCArray"
    push $P380, ""
    .return ($P380)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "GLOBALish"  :subid("53_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx382_tgt
    .local int rx382_pos
    .local int rx382_off
    .local int rx382_eos
    .local int rx382_rep
    .local pmc rx382_cur
    .local pmc rx382_debug
    (rx382_cur, rx382_pos, rx382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx382_cur
    .local pmc match
    .lex "$/", match
    length rx382_eos, rx382_tgt
    gt rx382_pos, rx382_eos, rx382_done
    set rx382_off, 0
    lt rx382_pos, 2, rx382_start
    sub rx382_off, rx382_pos, 1
    substr rx382_tgt, rx382_tgt, rx382_off
  rx382_start:
    eq $I10, 1, rx382_restart
    if_null rx382_debug, debug_708
    rx382_cur."!cursor_debug"("START", "GLOBALish")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan383_done
    goto rxscan383_scan
  rxscan383_loop:
    (rx382_pos) = rx382_cur."from"()
    inc rx382_pos
    rx382_cur."!cursor_from"(rx382_pos)
    ge rx382_pos, rx382_eos, rxscan383_done
  rxscan383_scan:
    set_addr $I10, rxscan383_loop
    rx382_cur."!mark_push"(0, rx382_pos, $I10)
  rxscan383_done:
.annotate 'line', 184
  # rx pass
    rx382_cur."!cursor_pass"(rx382_pos, "GLOBALish")
    if_null rx382_debug, debug_709
    rx382_cur."!cursor_debug"("PASS", "GLOBALish", " at pos=", rx382_pos)
  debug_709:
    .return (rx382_cur)
  rx382_restart:
.annotate 'line', 10
    if_null rx382_debug, debug_710
    rx382_cur."!cursor_debug"("NEXT", "GLOBALish")
  debug_710:
  rx382_fail:
    (rx382_rep, rx382_pos, $I10, $P10) = rx382_cur."!mark_fail"(0)
    lt rx382_pos, -1, rx382_done
    eq rx382_pos, -1, rx382_fail
    jump $I10
  rx382_done:
    rx382_cur."!cursor_fail"()
    if_null rx382_debug, debug_711
    rx382_cur."!cursor_debug"("FAIL", "GLOBALish")
  debug_711:
    .return (rx382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__GLOBALish"  :subid("54_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, ""
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("55_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx387_tgt
    .local int rx387_pos
    .local int rx387_off
    .local int rx387_eos
    .local int rx387_rep
    .local pmc rx387_cur
    .local pmc rx387_debug
    (rx387_cur, rx387_pos, rx387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx387_cur
    .local pmc match
    .lex "$/", match
    length rx387_eos, rx387_tgt
    gt rx387_pos, rx387_eos, rx387_done
    set rx387_off, 0
    lt rx387_pos, 2, rx387_start
    sub rx387_off, rx387_pos, 1
    substr rx387_tgt, rx387_tgt, rx387_off
  rx387_start:
    eq $I10, 1, rx387_restart
    if_null rx387_debug, debug_712
    rx387_cur."!cursor_debug"("START", "finishpad")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan388_done
    goto rxscan388_scan
  rxscan388_loop:
    (rx387_pos) = rx387_cur."from"()
    inc rx387_pos
    rx387_cur."!cursor_from"(rx387_pos)
    ge rx387_pos, rx387_eos, rxscan388_done
  rxscan388_scan:
    set_addr $I10, rxscan388_loop
    rx387_cur."!mark_push"(0, rx387_pos, $I10)
  rxscan388_done:
.annotate 'line', 185
  # rx pass
    rx387_cur."!cursor_pass"(rx387_pos, "finishpad")
    if_null rx387_debug, debug_713
    rx387_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx387_pos)
  debug_713:
    .return (rx387_cur)
  rx387_restart:
.annotate 'line', 10
    if_null rx387_debug, debug_714
    rx387_cur."!cursor_debug"("NEXT", "finishpad")
  debug_714:
  rx387_fail:
    (rx387_rep, rx387_pos, $I10, $P10) = rx387_cur."!mark_fail"(0)
    lt rx387_pos, -1, rx387_done
    eq rx387_pos, -1, rx387_fail
    jump $I10
  rx387_done:
    rx387_cur."!cursor_fail"()
    if_null rx387_debug, debug_715
    rx387_cur."!cursor_debug"("FAIL", "finishpad")
  debug_715:
    .return (rx387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :subid("56_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P390, "ResizablePMCArray"
    push $P390, ""
    .return ($P390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("57_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx392_tgt
    .local int rx392_pos
    .local int rx392_off
    .local int rx392_eos
    .local int rx392_rep
    .local pmc rx392_cur
    .local pmc rx392_debug
    (rx392_cur, rx392_pos, rx392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx392_cur
    .local pmc match
    .lex "$/", match
    length rx392_eos, rx392_tgt
    gt rx392_pos, rx392_eos, rx392_done
    set rx392_off, 0
    lt rx392_pos, 2, rx392_start
    sub rx392_off, rx392_pos, 1
    substr rx392_tgt, rx392_tgt, rx392_off
  rx392_start:
    eq $I10, 1, rx392_restart
    if_null rx392_debug, debug_716
    rx392_cur."!cursor_debug"("START", "you_are_here")
  debug_716:
    $I10 = self.'from'()
    ne $I10, -1, rxscan393_done
    goto rxscan393_scan
  rxscan393_loop:
    (rx392_pos) = rx392_cur."from"()
    inc rx392_pos
    rx392_cur."!cursor_from"(rx392_pos)
    ge rx392_pos, rx392_eos, rxscan393_done
  rxscan393_scan:
    set_addr $I10, rxscan393_loop
    rx392_cur."!mark_push"(0, rx392_pos, $I10)
  rxscan393_done:
.annotate 'line', 186
  # rx pass
    rx392_cur."!cursor_pass"(rx392_pos, "you_are_here")
    if_null rx392_debug, debug_717
    rx392_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx392_pos)
  debug_717:
    .return (rx392_cur)
  rx392_restart:
.annotate 'line', 10
    if_null rx392_debug, debug_718
    rx392_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_718:
  rx392_fail:
    (rx392_rep, rx392_pos, $I10, $P10) = rx392_cur."!mark_fail"(0)
    lt rx392_pos, -1, rx392_done
    eq rx392_pos, -1, rx392_fail
    jump $I10
  rx392_done:
    rx392_cur."!cursor_fail"()
    if_null rx392_debug, debug_719
    rx392_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_719:
    .return (rx392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :subid("58_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P395, "ResizablePMCArray"
    push $P395, ""
    .return ($P395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("59_1304516047.681")
    .param pmc param_397
.annotate 'line', 188
    .lex "self", param_397
    $P398 = param_397."!protoregex"("terminator")
    .return ($P398)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("60_1304516047.681")
    .param pmc param_400
.annotate 'line', 188
    .lex "self", param_400
    $P401 = param_400."!PREFIX__!protoregex"("terminator")
    .return ($P401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("61_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx403_tgt
    .local int rx403_pos
    .local int rx403_off
    .local int rx403_eos
    .local int rx403_rep
    .local pmc rx403_cur
    .local pmc rx403_debug
    (rx403_cur, rx403_pos, rx403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx403_cur
    .local pmc match
    .lex "$/", match
    length rx403_eos, rx403_tgt
    gt rx403_pos, rx403_eos, rx403_done
    set rx403_off, 0
    lt rx403_pos, 2, rx403_start
    sub rx403_off, rx403_pos, 1
    substr rx403_tgt, rx403_tgt, rx403_off
  rx403_start:
    eq $I10, 1, rx403_restart
    if_null rx403_debug, debug_720
    rx403_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan404_done
    goto rxscan404_scan
  rxscan404_loop:
    (rx403_pos) = rx403_cur."from"()
    inc rx403_pos
    rx403_cur."!cursor_from"(rx403_pos)
    ge rx403_pos, rx403_eos, rxscan404_done
  rxscan404_scan:
    set_addr $I10, rxscan404_loop
    rx403_cur."!mark_push"(0, rx403_pos, $I10)
  rxscan404_done:
.annotate 'line', 190
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx403_pos, rx403_off
    substr $S10, rx403_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx403_fail
  # rx pass
    rx403_cur."!cursor_pass"(rx403_pos, "terminator:sym<;>")
    if_null rx403_debug, debug_721
    rx403_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx403_pos)
  debug_721:
    .return (rx403_cur)
  rx403_restart:
.annotate 'line', 10
    if_null rx403_debug, debug_722
    rx403_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_722:
  rx403_fail:
    (rx403_rep, rx403_pos, $I10, $P10) = rx403_cur."!mark_fail"(0)
    lt rx403_pos, -1, rx403_done
    eq rx403_pos, -1, rx403_fail
    jump $I10
  rx403_done:
    rx403_cur."!cursor_fail"()
    if_null rx403_debug, debug_723
    rx403_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_723:
    .return (rx403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :subid("62_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P406, "ResizablePMCArray"
    push $P406, ";"
    .return ($P406)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("63_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx408_tgt
    .local int rx408_pos
    .local int rx408_off
    .local int rx408_eos
    .local int rx408_rep
    .local pmc rx408_cur
    .local pmc rx408_debug
    (rx408_cur, rx408_pos, rx408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx408_cur
    .local pmc match
    .lex "$/", match
    length rx408_eos, rx408_tgt
    gt rx408_pos, rx408_eos, rx408_done
    set rx408_off, 0
    lt rx408_pos, 2, rx408_start
    sub rx408_off, rx408_pos, 1
    substr rx408_tgt, rx408_tgt, rx408_off
  rx408_start:
    eq $I10, 1, rx408_restart
    if_null rx408_debug, debug_724
    rx408_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan409_done
    goto rxscan409_scan
  rxscan409_loop:
    (rx408_pos) = rx408_cur."from"()
    inc rx408_pos
    rx408_cur."!cursor_from"(rx408_pos)
    ge rx408_pos, rx408_eos, rxscan409_done
  rxscan409_scan:
    set_addr $I10, rxscan409_loop
    rx408_cur."!mark_push"(0, rx408_pos, $I10)
  rxscan409_done:
.annotate 'line', 191
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx408_pos, rx408_off
    substr $S10, rx408_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx408_fail
  # rx pass
    rx408_cur."!cursor_pass"(rx408_pos, "terminator:sym<}>")
    if_null rx408_debug, debug_725
    rx408_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx408_pos)
  debug_725:
    .return (rx408_cur)
  rx408_restart:
.annotate 'line', 10
    if_null rx408_debug, debug_726
    rx408_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_726:
  rx408_fail:
    (rx408_rep, rx408_pos, $I10, $P10) = rx408_cur."!mark_fail"(0)
    lt rx408_pos, -1, rx408_done
    eq rx408_pos, -1, rx408_fail
    jump $I10
  rx408_done:
    rx408_cur."!cursor_fail"()
    if_null rx408_debug, debug_727
    rx408_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_727:
    .return (rx408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :subid("64_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P411, "ResizablePMCArray"
    push $P411, "}"
    .return ($P411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("65_1304516047.681")
    .param pmc param_413
.annotate 'line', 195
    .lex "self", param_413
    $P414 = param_413."!protoregex"("statement_control")
    .return ($P414)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("66_1304516047.681")
    .param pmc param_416
.annotate 'line', 195
    .lex "self", param_416
    $P417 = param_416."!PREFIX__!protoregex"("statement_control")
    .return ($P417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("67_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx419_tgt
    .local int rx419_pos
    .local int rx419_off
    .local int rx419_eos
    .local int rx419_rep
    .local pmc rx419_cur
    .local pmc rx419_debug
    (rx419_cur, rx419_pos, rx419_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx419_cur
    .local pmc match
    .lex "$/", match
    length rx419_eos, rx419_tgt
    gt rx419_pos, rx419_eos, rx419_done
    set rx419_off, 0
    lt rx419_pos, 2, rx419_start
    sub rx419_off, rx419_pos, 1
    substr rx419_tgt, rx419_tgt, rx419_off
  rx419_start:
    eq $I10, 1, rx419_restart
    if_null rx419_debug, debug_728
    rx419_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan420_done
    goto rxscan420_scan
  rxscan420_loop:
    (rx419_pos) = rx419_cur."from"()
    inc rx419_pos
    rx419_cur."!cursor_from"(rx419_pos)
    ge rx419_pos, rx419_eos, rxscan420_done
  rxscan420_scan:
    set_addr $I10, rxscan420_loop
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  rxscan420_done:
.annotate 'line', 198
  # rx subcapture "sym"
    set_addr $I10, rxcap_421_fail
    rx419_cur."!mark_push"(0, rx419_pos, $I10)
  # rx literal  "use"
    add $I11, rx419_pos, 3
    gt $I11, rx419_eos, rx419_fail
    sub $I11, rx419_pos, rx419_off
    substr $S10, rx419_tgt, $I11, 3
    ne $S10, "use", rx419_fail
    add rx419_pos, 3
    set_addr $I10, rxcap_421_fail
    ($I12, $I11) = rx419_cur."!mark_peek"($I10)
    rx419_cur."!cursor_pos"($I11)
    ($P10) = rx419_cur."!cursor_start"()
    $P10."!cursor_pass"(rx419_pos, "")
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_421_done
  rxcap_421_fail:
    goto rx419_fail
  rxcap_421_done:
  # rx charclass s
    ge rx419_pos, rx419_eos, rx419_fail
    sub $I10, rx419_pos, rx419_off
    is_cclass $I11, 32, rx419_tgt, $I10
    unless $I11, rx419_fail
    inc rx419_pos
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."name"()
    unless $P10, rx419_fail
    rx419_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx419_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx419_cur."!cursor_pos"(rx419_pos)
    $P10 = rx419_cur."ws"()
    unless $P10, rx419_fail
    rx419_pos = $P10."pos"()
.annotate 'line', 197
  # rx pass
    rx419_cur."!cursor_pass"(rx419_pos, "statement_control:sym<use>")
    if_null rx419_debug, debug_729
    rx419_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx419_pos)
  debug_729:
    .return (rx419_cur)
  rx419_restart:
.annotate 'line', 10
    if_null rx419_debug, debug_730
    rx419_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_730:
  rx419_fail:
    (rx419_rep, rx419_pos, $I10, $P10) = rx419_cur."!mark_fail"(0)
    lt rx419_pos, -1, rx419_done
    eq rx419_pos, -1, rx419_fail
    jump $I10
  rx419_done:
    rx419_cur."!cursor_fail"()
    if_null rx419_debug, debug_731
    rx419_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_731:
    .return (rx419_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :subid("68_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P425, "ResizablePMCArray"
    push $P425, "use"
    .return ($P425)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("69_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx427_tgt
    .local int rx427_pos
    .local int rx427_off
    .local int rx427_eos
    .local int rx427_rep
    .local pmc rx427_cur
    .local pmc rx427_debug
    (rx427_cur, rx427_pos, rx427_tgt, $I10) = self."!cursor_start"()
    rx427_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx427_cur
    .local pmc match
    .lex "$/", match
    length rx427_eos, rx427_tgt
    gt rx427_pos, rx427_eos, rx427_done
    set rx427_off, 0
    lt rx427_pos, 2, rx427_start
    sub rx427_off, rx427_pos, 1
    substr rx427_tgt, rx427_tgt, rx427_off
  rx427_start:
    eq $I10, 1, rx427_restart
    if_null rx427_debug, debug_732
    rx427_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan428_done
    goto rxscan428_scan
  rxscan428_loop:
    (rx427_pos) = rx427_cur."from"()
    inc rx427_pos
    rx427_cur."!cursor_from"(rx427_pos)
    ge rx427_pos, rx427_eos, rxscan428_done
  rxscan428_scan:
    set_addr $I10, rxscan428_loop
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxscan428_done:
.annotate 'line', 202
  # rx subcapture "sym"
    set_addr $I10, rxcap_429_fail
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  # rx literal  "if"
    add $I11, rx427_pos, 2
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 2
    ne $S10, "if", rx427_fail
    add rx427_pos, 2
    set_addr $I10, rxcap_429_fail
    ($I12, $I11) = rx427_cur."!mark_peek"($I10)
    rx427_cur."!cursor_pos"($I11)
    ($P10) = rx427_cur."!cursor_start"()
    $P10."!cursor_pass"(rx427_pos, "")
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_429_done
  rxcap_429_fail:
    goto rx427_fail
  rxcap_429_done:
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 203
  # rx subrule "xblock" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."xblock"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 204
  # rx rxquantr432 ** 0..*
    set_addr $I10, rxquantr432_done
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxquantr432_loop:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx427_pos, 5
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 5
    ne $S10, "elsif", rx427_fail
    add rx427_pos, 5
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."xblock"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
    set_addr $I10, rxquantr432_done
    (rx427_rep) = rx427_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr432_done
    rx427_cur."!mark_push"(rx427_rep, rx427_pos, $I10)
    goto rxquantr432_loop
  rxquantr432_done:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 205
  # rx rxquantr437 ** 0..1
    set_addr $I10, rxquantr437_done
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxquantr437_loop:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx427_pos, 4
    gt $I11, rx427_eos, rx427_fail
    sub $I11, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I11, 4
    ne $S10, "else", rx427_fail
    add rx427_pos, 4
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."pblock"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx427_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
    set_addr $I10, rxquantr437_done
    (rx427_rep) = rx427_cur."!mark_commit"($I10)
  rxquantr437_done:
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
.annotate 'line', 201
  # rx pass
    rx427_cur."!cursor_pass"(rx427_pos, "statement_control:sym<if>")
    if_null rx427_debug, debug_733
    rx427_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx427_pos)
  debug_733:
    .return (rx427_cur)
  rx427_restart:
.annotate 'line', 10
    if_null rx427_debug, debug_734
    rx427_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_734:
  rx427_fail:
    (rx427_rep, rx427_pos, $I10, $P10) = rx427_cur."!mark_fail"(0)
    lt rx427_pos, -1, rx427_done
    eq rx427_pos, -1, rx427_fail
    jump $I10
  rx427_done:
    rx427_cur."!cursor_fail"()
    if_null rx427_debug, debug_735
    rx427_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_735:
    .return (rx427_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :subid("70_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P443, "ResizablePMCArray"
    push $P443, "if"
    .return ($P443)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("71_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P453 = "72_1304516047.681" 
    capture_lex $P453
    .local string rx445_tgt
    .local int rx445_pos
    .local int rx445_off
    .local int rx445_eos
    .local int rx445_rep
    .local pmc rx445_cur
    .local pmc rx445_debug
    (rx445_cur, rx445_pos, rx445_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx445_cur
    .local pmc match
    .lex "$/", match
    length rx445_eos, rx445_tgt
    gt rx445_pos, rx445_eos, rx445_done
    set rx445_off, 0
    lt rx445_pos, 2, rx445_start
    sub rx445_off, rx445_pos, 1
    substr rx445_tgt, rx445_tgt, rx445_off
  rx445_start:
    eq $I10, 1, rx445_restart
    if_null rx445_debug, debug_736
    rx445_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan446_done
    goto rxscan446_scan
  rxscan446_loop:
    (rx445_pos) = rx445_cur."from"()
    inc rx445_pos
    rx445_cur."!cursor_from"(rx445_pos)
    ge rx445_pos, rx445_eos, rxscan446_done
  rxscan446_scan:
    set_addr $I10, rxscan446_loop
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  rxscan446_done:
.annotate 'line', 209
  # rx subcapture "sym"
    set_addr $I10, rxcap_447_fail
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  # rx literal  "unless"
    add $I11, rx445_pos, 6
    gt $I11, rx445_eos, rx445_fail
    sub $I11, rx445_pos, rx445_off
    substr $S10, rx445_tgt, $I11, 6
    ne $S10, "unless", rx445_fail
    add rx445_pos, 6
    set_addr $I10, rxcap_447_fail
    ($I12, $I11) = rx445_cur."!mark_peek"($I10)
    rx445_cur."!cursor_pos"($I11)
    ($P10) = rx445_cur."!cursor_start"()
    $P10."!cursor_pass"(rx445_pos, "")
    rx445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_447_done
  rxcap_447_fail:
    goto rx445_fail
  rxcap_447_done:
  # rx charclass s
    ge rx445_pos, rx445_eos, rx445_fail
    sub $I10, rx445_pos, rx445_off
    is_cclass $I11, 32, rx445_tgt, $I10
    unless $I11, rx445_fail
    inc rx445_pos
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
.annotate 'line', 210
  # rx subrule "xblock" subtype=capture negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."xblock"()
    unless $P10, rx445_fail
    rx445_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx445_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  alt450_0:
.annotate 'line', 211
    set_addr $I10, alt450_1
    rx445_cur."!mark_push"(0, rx445_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx445_cur."!cursor_pos"(rx445_pos)
    .const 'Sub' $P453 = "72_1304516047.681" 
    capture_lex $P453
    $P10 = rx445_cur."before"($P453)
    if $P10, rx445_fail
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
    goto alt450_end
  alt450_1:
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
  alt450_end:
  # rx subrule "ws" subtype=method negate=
    rx445_cur."!cursor_pos"(rx445_pos)
    $P10 = rx445_cur."ws"()
    unless $P10, rx445_fail
    rx445_pos = $P10."pos"()
.annotate 'line', 208
  # rx pass
    rx445_cur."!cursor_pass"(rx445_pos, "statement_control:sym<unless>")
    if_null rx445_debug, debug_741
    rx445_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx445_pos)
  debug_741:
    .return (rx445_cur)
  rx445_restart:
.annotate 'line', 10
    if_null rx445_debug, debug_742
    rx445_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_742:
  rx445_fail:
    (rx445_rep, rx445_pos, $I10, $P10) = rx445_cur."!mark_fail"(0)
    lt rx445_pos, -1, rx445_done
    eq rx445_pos, -1, rx445_fail
    jump $I10
  rx445_done:
    rx445_cur."!cursor_fail"()
    if_null rx445_debug, debug_743
    rx445_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_743:
    .return (rx445_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block452"  :anon :subid("72_1304516047.681") :method :outer("71_1304516047.681")
.annotate 'line', 211
    .local string rx454_tgt
    .local int rx454_pos
    .local int rx454_off
    .local int rx454_eos
    .local int rx454_rep
    .local pmc rx454_cur
    .local pmc rx454_debug
    (rx454_cur, rx454_pos, rx454_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx454_cur
    .local pmc match
    .lex "$/", match
    length rx454_eos, rx454_tgt
    gt rx454_pos, rx454_eos, rx454_done
    set rx454_off, 0
    lt rx454_pos, 2, rx454_start
    sub rx454_off, rx454_pos, 1
    substr rx454_tgt, rx454_tgt, rx454_off
  rx454_start:
    eq $I10, 1, rx454_restart
    if_null rx454_debug, debug_737
    rx454_cur."!cursor_debug"("START", "")
  debug_737:
    $I10 = self.'from'()
    ne $I10, -1, rxscan455_done
    goto rxscan455_scan
  rxscan455_loop:
    (rx454_pos) = rx454_cur."from"()
    inc rx454_pos
    rx454_cur."!cursor_from"(rx454_pos)
    ge rx454_pos, rx454_eos, rxscan455_done
  rxscan455_scan:
    set_addr $I10, rxscan455_loop
    rx454_cur."!mark_push"(0, rx454_pos, $I10)
  rxscan455_done:
  # rx literal  "else"
    add $I11, rx454_pos, 4
    gt $I11, rx454_eos, rx454_fail
    sub $I11, rx454_pos, rx454_off
    substr $S10, rx454_tgt, $I11, 4
    ne $S10, "else", rx454_fail
    add rx454_pos, 4
  # rx pass
    rx454_cur."!cursor_pass"(rx454_pos, "")
    if_null rx454_debug, debug_738
    rx454_cur."!cursor_debug"("PASS", "", " at pos=", rx454_pos)
  debug_738:
    .return (rx454_cur)
  rx454_restart:
    if_null rx454_debug, debug_739
    rx454_cur."!cursor_debug"("NEXT", "")
  debug_739:
  rx454_fail:
    (rx454_rep, rx454_pos, $I10, $P10) = rx454_cur."!mark_fail"(0)
    lt rx454_pos, -1, rx454_done
    eq rx454_pos, -1, rx454_fail
    jump $I10
  rx454_done:
    rx454_cur."!cursor_fail"()
    if_null rx454_debug, debug_740
    rx454_cur."!cursor_debug"("FAIL", "")
  debug_740:
    .return (rx454_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :subid("73_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P461, "ResizablePMCArray"
    push $P461, "unless"
    .return ($P461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("74_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_744
    rx463_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan464_done
    goto rxscan464_scan
  rxscan464_loop:
    (rx463_pos) = rx463_cur."from"()
    inc rx463_pos
    rx463_cur."!cursor_from"(rx463_pos)
    ge rx463_pos, rx463_eos, rxscan464_done
  rxscan464_scan:
    set_addr $I10, rxscan464_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan464_done:
.annotate 'line', 215
  # rx subcapture "sym"
    set_addr $I10, rxcap_466_fail
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  alt465_0:
    set_addr $I10, alt465_1
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  # rx literal  "while"
    add $I11, rx463_pos, 5
    gt $I11, rx463_eos, rx463_fail
    sub $I11, rx463_pos, rx463_off
    substr $S10, rx463_tgt, $I11, 5
    ne $S10, "while", rx463_fail
    add rx463_pos, 5
    goto alt465_end
  alt465_1:
  # rx literal  "until"
    add $I11, rx463_pos, 5
    gt $I11, rx463_eos, rx463_fail
    sub $I11, rx463_pos, rx463_off
    substr $S10, rx463_tgt, $I11, 5
    ne $S10, "until", rx463_fail
    add rx463_pos, 5
  alt465_end:
    set_addr $I10, rxcap_466_fail
    ($I12, $I11) = rx463_cur."!mark_peek"($I10)
    rx463_cur."!cursor_pos"($I11)
    ($P10) = rx463_cur."!cursor_start"()
    $P10."!cursor_pass"(rx463_pos, "")
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_466_done
  rxcap_466_fail:
    goto rx463_fail
  rxcap_466_done:
  # rx charclass s
    ge rx463_pos, rx463_eos, rx463_fail
    sub $I10, rx463_pos, rx463_off
    is_cclass $I11, 32, rx463_tgt, $I10
    unless $I11, rx463_fail
    inc rx463_pos
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
.annotate 'line', 216
  # rx subrule "xblock" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."xblock"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx463_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
.annotate 'line', 214
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "statement_control:sym<while>")
    if_null rx463_debug, debug_745
    rx463_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx463_pos)
  debug_745:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 10
    if_null rx463_debug, debug_746
    rx463_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_746:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_747
    rx463_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_747:
    .return (rx463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :subid("75_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P470, "ResizablePMCArray"
    push $P470, "until"
    push $P470, "while"
    .return ($P470)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("76_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx472_tgt
    .local int rx472_pos
    .local int rx472_off
    .local int rx472_eos
    .local int rx472_rep
    .local pmc rx472_cur
    .local pmc rx472_debug
    (rx472_cur, rx472_pos, rx472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx472_cur
    .local pmc match
    .lex "$/", match
    length rx472_eos, rx472_tgt
    gt rx472_pos, rx472_eos, rx472_done
    set rx472_off, 0
    lt rx472_pos, 2, rx472_start
    sub rx472_off, rx472_pos, 1
    substr rx472_tgt, rx472_tgt, rx472_off
  rx472_start:
    eq $I10, 1, rx472_restart
    if_null rx472_debug, debug_748
    rx472_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan473_done
    goto rxscan473_scan
  rxscan473_loop:
    (rx472_pos) = rx472_cur."from"()
    inc rx472_pos
    rx472_cur."!cursor_from"(rx472_pos)
    ge rx472_pos, rx472_eos, rxscan473_done
  rxscan473_scan:
    set_addr $I10, rxscan473_loop
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  rxscan473_done:
.annotate 'line', 220
  # rx subcapture "sym"
    set_addr $I10, rxcap_474_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx472_pos, 6
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 6
    ne $S10, "repeat", rx472_fail
    add rx472_pos, 6
    set_addr $I10, rxcap_474_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_474_done
  rxcap_474_fail:
    goto rx472_fail
  rxcap_474_done:
  # rx charclass s
    ge rx472_pos, rx472_eos, rx472_fail
    sub $I10, rx472_pos, rx472_off
    is_cclass $I11, 32, rx472_tgt, $I10
    unless $I11, rx472_fail
    inc rx472_pos
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  alt476_0:
.annotate 'line', 221
    set_addr $I10, alt476_1
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
.annotate 'line', 222
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_479_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  alt478_0:
    set_addr $I10, alt478_1
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "while"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "while", rx472_fail
    add rx472_pos, 5
    goto alt478_end
  alt478_1:
  # rx literal  "until"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "until", rx472_fail
    add rx472_pos, 5
  alt478_end:
    set_addr $I10, rxcap_479_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_479_done
  rxcap_479_fail:
    goto rx472_fail
  rxcap_479_done:
  # rx charclass s
    ge rx472_pos, rx472_eos, rx472_fail
    sub $I10, rx472_pos, rx472_off
    is_cclass $I11, 32, rx472_tgt, $I10
    unless $I11, rx472_fail
    inc rx472_pos
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."xblock"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
    goto alt476_end
  alt476_1:
.annotate 'line', 223
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."pblock"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_485_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  alt484_0:
    set_addr $I10, alt484_1
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "while"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "while", rx472_fail
    add rx472_pos, 5
    goto alt484_end
  alt484_1:
  # rx literal  "until"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "until", rx472_fail
    add rx472_pos, 5
  alt484_end:
    set_addr $I10, rxcap_485_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_485_done
  rxcap_485_fail:
    goto rx472_fail
  rxcap_485_done:
  # rx charclass s
    ge rx472_pos, rx472_eos, rx472_fail
    sub $I10, rx472_pos, rx472_off
    is_cclass $I11, 32, rx472_tgt, $I10
    unless $I11, rx472_fail
    inc rx472_pos
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."EXPR"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  alt476_end:
.annotate 'line', 224
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
.annotate 'line', 219
  # rx pass
    rx472_cur."!cursor_pass"(rx472_pos, "statement_control:sym<repeat>")
    if_null rx472_debug, debug_749
    rx472_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx472_pos)
  debug_749:
    .return (rx472_cur)
  rx472_restart:
.annotate 'line', 10
    if_null rx472_debug, debug_750
    rx472_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_750:
  rx472_fail:
    (rx472_rep, rx472_pos, $I10, $P10) = rx472_cur."!mark_fail"(0)
    lt rx472_pos, -1, rx472_done
    eq rx472_pos, -1, rx472_fail
    jump $I10
  rx472_done:
    rx472_cur."!cursor_fail"()
    if_null rx472_debug, debug_751
    rx472_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_751:
    .return (rx472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :subid("77_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P490, "ResizablePMCArray"
    push $P490, "repeat"
    .return ($P490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("78_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx492_tgt
    .local int rx492_pos
    .local int rx492_off
    .local int rx492_eos
    .local int rx492_rep
    .local pmc rx492_cur
    .local pmc rx492_debug
    (rx492_cur, rx492_pos, rx492_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx492_cur
    .local pmc match
    .lex "$/", match
    length rx492_eos, rx492_tgt
    gt rx492_pos, rx492_eos, rx492_done
    set rx492_off, 0
    lt rx492_pos, 2, rx492_start
    sub rx492_off, rx492_pos, 1
    substr rx492_tgt, rx492_tgt, rx492_off
  rx492_start:
    eq $I10, 1, rx492_restart
    if_null rx492_debug, debug_752
    rx492_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan493_done
    goto rxscan493_scan
  rxscan493_loop:
    (rx492_pos) = rx492_cur."from"()
    inc rx492_pos
    rx492_cur."!cursor_from"(rx492_pos)
    ge rx492_pos, rx492_eos, rxscan493_done
  rxscan493_scan:
    set_addr $I10, rxscan493_loop
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  rxscan493_done:
.annotate 'line', 228
  # rx subcapture "sym"
    set_addr $I10, rxcap_494_fail
    rx492_cur."!mark_push"(0, rx492_pos, $I10)
  # rx literal  "for"
    add $I11, rx492_pos, 3
    gt $I11, rx492_eos, rx492_fail
    sub $I11, rx492_pos, rx492_off
    substr $S10, rx492_tgt, $I11, 3
    ne $S10, "for", rx492_fail
    add rx492_pos, 3
    set_addr $I10, rxcap_494_fail
    ($I12, $I11) = rx492_cur."!mark_peek"($I10)
    rx492_cur."!cursor_pos"($I11)
    ($P10) = rx492_cur."!cursor_start"()
    $P10."!cursor_pass"(rx492_pos, "")
    rx492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_494_done
  rxcap_494_fail:
    goto rx492_fail
  rxcap_494_done:
  # rx charclass s
    ge rx492_pos, rx492_eos, rx492_fail
    sub $I10, rx492_pos, rx492_off
    is_cclass $I11, 32, rx492_tgt, $I10
    unless $I11, rx492_fail
    inc rx492_pos
  # rx subrule "ws" subtype=method negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."ws"()
    unless $P10, rx492_fail
    rx492_pos = $P10."pos"()
.annotate 'line', 229
  # rx subrule "xblock" subtype=capture negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."xblock"()
    unless $P10, rx492_fail
    rx492_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx492_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx492_cur."!cursor_pos"(rx492_pos)
    $P10 = rx492_cur."ws"()
    unless $P10, rx492_fail
    rx492_pos = $P10."pos"()
.annotate 'line', 227
  # rx pass
    rx492_cur."!cursor_pass"(rx492_pos, "statement_control:sym<for>")
    if_null rx492_debug, debug_753
    rx492_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx492_pos)
  debug_753:
    .return (rx492_cur)
  rx492_restart:
.annotate 'line', 10
    if_null rx492_debug, debug_754
    rx492_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_754:
  rx492_fail:
    (rx492_rep, rx492_pos, $I10, $P10) = rx492_cur."!mark_fail"(0)
    lt rx492_pos, -1, rx492_done
    eq rx492_pos, -1, rx492_fail
    jump $I10
  rx492_done:
    rx492_cur."!cursor_fail"()
    if_null rx492_debug, debug_755
    rx492_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_755:
    .return (rx492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :subid("79_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P498, "ResizablePMCArray"
    push $P498, "for"
    .return ($P498)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("80_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx500_tgt
    .local int rx500_pos
    .local int rx500_off
    .local int rx500_eos
    .local int rx500_rep
    .local pmc rx500_cur
    .local pmc rx500_debug
    (rx500_cur, rx500_pos, rx500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx500_cur
    .local pmc match
    .lex "$/", match
    length rx500_eos, rx500_tgt
    gt rx500_pos, rx500_eos, rx500_done
    set rx500_off, 0
    lt rx500_pos, 2, rx500_start
    sub rx500_off, rx500_pos, 1
    substr rx500_tgt, rx500_tgt, rx500_off
  rx500_start:
    eq $I10, 1, rx500_restart
    if_null rx500_debug, debug_756
    rx500_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan501_done
    goto rxscan501_scan
  rxscan501_loop:
    (rx500_pos) = rx500_cur."from"()
    inc rx500_pos
    rx500_cur."!cursor_from"(rx500_pos)
    ge rx500_pos, rx500_eos, rxscan501_done
  rxscan501_scan:
    set_addr $I10, rxscan501_loop
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  rxscan501_done:
.annotate 'line', 233
  # rx subcapture "sym"
    set_addr $I10, rxcap_502_fail
    rx500_cur."!mark_push"(0, rx500_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx500_pos, 5
    gt $I11, rx500_eos, rx500_fail
    sub $I11, rx500_pos, rx500_off
    substr $S10, rx500_tgt, $I11, 5
    ne $S10, "CATCH", rx500_fail
    add rx500_pos, 5
    set_addr $I10, rxcap_502_fail
    ($I12, $I11) = rx500_cur."!mark_peek"($I10)
    rx500_cur."!cursor_pos"($I11)
    ($P10) = rx500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx500_pos, "")
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_502_done
  rxcap_502_fail:
    goto rx500_fail
  rxcap_502_done:
  # rx charclass s
    ge rx500_pos, rx500_eos, rx500_fail
    sub $I10, rx500_pos, rx500_off
    is_cclass $I11, 32, rx500_tgt, $I10
    unless $I11, rx500_fail
    inc rx500_pos
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
.annotate 'line', 234
  # rx subrule "block" subtype=capture negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."block"()
    unless $P10, rx500_fail
    rx500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx500_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx500_cur."!cursor_pos"(rx500_pos)
    $P10 = rx500_cur."ws"()
    unless $P10, rx500_fail
    rx500_pos = $P10."pos"()
.annotate 'line', 232
  # rx pass
    rx500_cur."!cursor_pass"(rx500_pos, "statement_control:sym<CATCH>")
    if_null rx500_debug, debug_757
    rx500_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx500_pos)
  debug_757:
    .return (rx500_cur)
  rx500_restart:
.annotate 'line', 10
    if_null rx500_debug, debug_758
    rx500_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_758:
  rx500_fail:
    (rx500_rep, rx500_pos, $I10, $P10) = rx500_cur."!mark_fail"(0)
    lt rx500_pos, -1, rx500_done
    eq rx500_pos, -1, rx500_fail
    jump $I10
  rx500_done:
    rx500_cur."!cursor_fail"()
    if_null rx500_debug, debug_759
    rx500_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_759:
    .return (rx500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :subid("81_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P506, "ResizablePMCArray"
    push $P506, "CATCH"
    .return ($P506)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("82_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_760
    rx508_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan509_done
    goto rxscan509_scan
  rxscan509_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan509_done
  rxscan509_scan:
    set_addr $I10, rxscan509_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan509_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_510_fail
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx508_pos, 7
    gt $I11, rx508_eos, rx508_fail
    sub $I11, rx508_pos, rx508_off
    substr $S10, rx508_tgt, $I11, 7
    ne $S10, "CONTROL", rx508_fail
    add rx508_pos, 7
    set_addr $I10, rxcap_510_fail
    ($I12, $I11) = rx508_cur."!mark_peek"($I10)
    rx508_cur."!cursor_pos"($I11)
    ($P10) = rx508_cur."!cursor_start"()
    $P10."!cursor_pass"(rx508_pos, "")
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_510_done
  rxcap_510_fail:
    goto rx508_fail
  rxcap_510_done:
  # rx charclass s
    ge rx508_pos, rx508_eos, rx508_fail
    sub $I10, rx508_pos, rx508_off
    is_cclass $I11, 32, rx508_tgt, $I10
    unless $I11, rx508_fail
    inc rx508_pos
  # rx subrule "ws" subtype=method negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."ws"()
    unless $P10, rx508_fail
    rx508_pos = $P10."pos"()
.annotate 'line', 239
  # rx subrule "block" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."block"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx508_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."ws"()
    unless $P10, rx508_fail
    rx508_pos = $P10."pos"()
.annotate 'line', 237
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "statement_control:sym<CONTROL>")
    if_null rx508_debug, debug_761
    rx508_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx508_pos)
  debug_761:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 10
    if_null rx508_debug, debug_762
    rx508_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_762:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_763
    rx508_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_763:
    .return (rx508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :subid("83_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P514, "ResizablePMCArray"
    push $P514, "CONTROL"
    .return ($P514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("84_1304516047.681")
    .param pmc param_516
.annotate 'line', 242
    .lex "self", param_516
    $P517 = param_516."!protoregex"("statement_prefix")
    .return ($P517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("85_1304516047.681")
    .param pmc param_519
.annotate 'line', 242
    .lex "self", param_519
    $P520 = param_519."!PREFIX__!protoregex"("statement_prefix")
    .return ($P520)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("86_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx522_tgt
    .local int rx522_pos
    .local int rx522_off
    .local int rx522_eos
    .local int rx522_rep
    .local pmc rx522_cur
    .local pmc rx522_debug
    (rx522_cur, rx522_pos, rx522_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx522_cur
    .local pmc match
    .lex "$/", match
    length rx522_eos, rx522_tgt
    gt rx522_pos, rx522_eos, rx522_done
    set rx522_off, 0
    lt rx522_pos, 2, rx522_start
    sub rx522_off, rx522_pos, 1
    substr rx522_tgt, rx522_tgt, rx522_off
  rx522_start:
    eq $I10, 1, rx522_restart
    if_null rx522_debug, debug_764
    rx522_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan523_done
    goto rxscan523_scan
  rxscan523_loop:
    (rx522_pos) = rx522_cur."from"()
    inc rx522_pos
    rx522_cur."!cursor_from"(rx522_pos)
    ge rx522_pos, rx522_eos, rxscan523_done
  rxscan523_scan:
    set_addr $I10, rxscan523_loop
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
  rxscan523_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_524_fail
    rx522_cur."!mark_push"(0, rx522_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx522_pos, 4
    gt $I11, rx522_eos, rx522_fail
    sub $I11, rx522_pos, rx522_off
    substr $S10, rx522_tgt, $I11, 4
    ne $S10, "INIT", rx522_fail
    add rx522_pos, 4
    set_addr $I10, rxcap_524_fail
    ($I12, $I11) = rx522_cur."!mark_peek"($I10)
    rx522_cur."!cursor_pos"($I11)
    ($P10) = rx522_cur."!cursor_start"()
    $P10."!cursor_pass"(rx522_pos, "")
    rx522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_524_done
  rxcap_524_fail:
    goto rx522_fail
  rxcap_524_done:
  # rx subrule "blorst" subtype=capture negate=
    rx522_cur."!cursor_pos"(rx522_pos)
    $P10 = rx522_cur."blorst"()
    unless $P10, rx522_fail
    rx522_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx522_pos = $P10."pos"()
  # rx pass
    rx522_cur."!cursor_pass"(rx522_pos, "statement_prefix:sym<INIT>")
    if_null rx522_debug, debug_765
    rx522_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx522_pos)
  debug_765:
    .return (rx522_cur)
  rx522_restart:
.annotate 'line', 10
    if_null rx522_debug, debug_766
    rx522_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_766:
  rx522_fail:
    (rx522_rep, rx522_pos, $I10, $P10) = rx522_cur."!mark_fail"(0)
    lt rx522_pos, -1, rx522_done
    eq rx522_pos, -1, rx522_fail
    jump $I10
  rx522_done:
    rx522_cur."!cursor_fail"()
    if_null rx522_debug, debug_767
    rx522_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_767:
    .return (rx522_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :subid("87_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P526 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P527, "ResizablePMCArray"
    push $P527, $P526
    .return ($P527)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("88_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx529_tgt
    .local int rx529_pos
    .local int rx529_off
    .local int rx529_eos
    .local int rx529_rep
    .local pmc rx529_cur
    .local pmc rx529_debug
    (rx529_cur, rx529_pos, rx529_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx529_cur
    .local pmc match
    .lex "$/", match
    length rx529_eos, rx529_tgt
    gt rx529_pos, rx529_eos, rx529_done
    set rx529_off, 0
    lt rx529_pos, 2, rx529_start
    sub rx529_off, rx529_pos, 1
    substr rx529_tgt, rx529_tgt, rx529_off
  rx529_start:
    eq $I10, 1, rx529_restart
    if_null rx529_debug, debug_768
    rx529_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan530_done
    goto rxscan530_scan
  rxscan530_loop:
    (rx529_pos) = rx529_cur."from"()
    inc rx529_pos
    rx529_cur."!cursor_from"(rx529_pos)
    ge rx529_pos, rx529_eos, rxscan530_done
  rxscan530_scan:
    set_addr $I10, rxscan530_loop
    rx529_cur."!mark_push"(0, rx529_pos, $I10)
  rxscan530_done:
.annotate 'line', 246
  # rx subcapture "sym"
    set_addr $I10, rxcap_531_fail
    rx529_cur."!mark_push"(0, rx529_pos, $I10)
  # rx literal  "try"
    add $I11, rx529_pos, 3
    gt $I11, rx529_eos, rx529_fail
    sub $I11, rx529_pos, rx529_off
    substr $S10, rx529_tgt, $I11, 3
    ne $S10, "try", rx529_fail
    add rx529_pos, 3
    set_addr $I10, rxcap_531_fail
    ($I12, $I11) = rx529_cur."!mark_peek"($I10)
    rx529_cur."!cursor_pos"($I11)
    ($P10) = rx529_cur."!cursor_start"()
    $P10."!cursor_pass"(rx529_pos, "")
    rx529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_531_done
  rxcap_531_fail:
    goto rx529_fail
  rxcap_531_done:
.annotate 'line', 247
  # rx subrule "blorst" subtype=capture negate=
    rx529_cur."!cursor_pos"(rx529_pos)
    $P10 = rx529_cur."blorst"()
    unless $P10, rx529_fail
    rx529_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx529_pos = $P10."pos"()
.annotate 'line', 245
  # rx pass
    rx529_cur."!cursor_pass"(rx529_pos, "statement_prefix:sym<try>")
    if_null rx529_debug, debug_769
    rx529_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx529_pos)
  debug_769:
    .return (rx529_cur)
  rx529_restart:
.annotate 'line', 10
    if_null rx529_debug, debug_770
    rx529_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_770:
  rx529_fail:
    (rx529_rep, rx529_pos, $I10, $P10) = rx529_cur."!mark_fail"(0)
    lt rx529_pos, -1, rx529_done
    eq rx529_pos, -1, rx529_fail
    jump $I10
  rx529_done:
    rx529_cur."!cursor_fail"()
    if_null rx529_debug, debug_771
    rx529_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_771:
    .return (rx529_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :subid("89_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P533 = self."!PREFIX__!subrule"("blorst", "try")
    new $P534, "ResizablePMCArray"
    push $P534, $P533
    .return ($P534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("90_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx536_tgt
    .local int rx536_pos
    .local int rx536_off
    .local int rx536_eos
    .local int rx536_rep
    .local pmc rx536_cur
    .local pmc rx536_debug
    (rx536_cur, rx536_pos, rx536_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx536_cur
    .local pmc match
    .lex "$/", match
    length rx536_eos, rx536_tgt
    gt rx536_pos, rx536_eos, rx536_done
    set rx536_off, 0
    lt rx536_pos, 2, rx536_start
    sub rx536_off, rx536_pos, 1
    substr rx536_tgt, rx536_tgt, rx536_off
  rx536_start:
    eq $I10, 1, rx536_restart
    if_null rx536_debug, debug_772
    rx536_cur."!cursor_debug"("START", "blorst")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan537_done
    goto rxscan537_scan
  rxscan537_loop:
    (rx536_pos) = rx536_cur."from"()
    inc rx536_pos
    rx536_cur."!cursor_from"(rx536_pos)
    ge rx536_pos, rx536_eos, rxscan537_done
  rxscan537_scan:
    set_addr $I10, rxscan537_loop
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  rxscan537_done:
.annotate 'line', 251
  # rx charclass s
    ge rx536_pos, rx536_eos, rx536_fail
    sub $I10, rx536_pos, rx536_off
    is_cclass $I11, 32, rx536_tgt, $I10
    unless $I11, rx536_fail
    inc rx536_pos
  # rx subrule "ws" subtype=method negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."ws"()
    unless $P10, rx536_fail
    rx536_pos = $P10."pos"()
  alt538_0:
    set_addr $I10, alt538_1
    rx536_cur."!mark_push"(0, rx536_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx536_pos, rx536_off
    substr $S10, rx536_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx536_fail
  # rx subrule "block" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."block"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx536_pos = $P10."pos"()
    goto alt538_end
  alt538_1:
  # rx subrule "statement" subtype=capture negate=
    rx536_cur."!cursor_pos"(rx536_pos)
    $P10 = rx536_cur."statement"()
    unless $P10, rx536_fail
    rx536_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx536_pos = $P10."pos"()
  alt538_end:
.annotate 'line', 250
  # rx pass
    rx536_cur."!cursor_pass"(rx536_pos, "blorst")
    if_null rx536_debug, debug_773
    rx536_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx536_pos)
  debug_773:
    .return (rx536_cur)
  rx536_restart:
.annotate 'line', 10
    if_null rx536_debug, debug_774
    rx536_cur."!cursor_debug"("NEXT", "blorst")
  debug_774:
  rx536_fail:
    (rx536_rep, rx536_pos, $I10, $P10) = rx536_cur."!mark_fail"(0)
    lt rx536_pos, -1, rx536_done
    eq rx536_pos, -1, rx536_fail
    jump $I10
  rx536_done:
    rx536_cur."!cursor_fail"()
    if_null rx536_debug, debug_775
    rx536_cur."!cursor_debug"("FAIL", "blorst")
  debug_775:
    .return (rx536_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :subid("91_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P540, "ResizablePMCArray"
    push $P540, ""
    .return ($P540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("92_1304516047.681")
    .param pmc param_542
.annotate 'line', 256
    .lex "self", param_542
    $P543 = param_542."!protoregex"("statement_mod_cond")
    .return ($P543)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("93_1304516047.681")
    .param pmc param_545
.annotate 'line', 256
    .lex "self", param_545
    $P546 = param_545."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("94_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx548_tgt
    .local int rx548_pos
    .local int rx548_off
    .local int rx548_eos
    .local int rx548_rep
    .local pmc rx548_cur
    .local pmc rx548_debug
    (rx548_cur, rx548_pos, rx548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx548_cur
    .local pmc match
    .lex "$/", match
    length rx548_eos, rx548_tgt
    gt rx548_pos, rx548_eos, rx548_done
    set rx548_off, 0
    lt rx548_pos, 2, rx548_start
    sub rx548_off, rx548_pos, 1
    substr rx548_tgt, rx548_tgt, rx548_off
  rx548_start:
    eq $I10, 1, rx548_restart
    if_null rx548_debug, debug_776
    rx548_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan549_done
    goto rxscan549_scan
  rxscan549_loop:
    (rx548_pos) = rx548_cur."from"()
    inc rx548_pos
    rx548_cur."!cursor_from"(rx548_pos)
    ge rx548_pos, rx548_eos, rxscan549_done
  rxscan549_scan:
    set_addr $I10, rxscan549_loop
    rx548_cur."!mark_push"(0, rx548_pos, $I10)
  rxscan549_done:
.annotate 'line', 258
  # rx subcapture "sym"
    set_addr $I10, rxcap_550_fail
    rx548_cur."!mark_push"(0, rx548_pos, $I10)
  # rx literal  "if"
    add $I11, rx548_pos, 2
    gt $I11, rx548_eos, rx548_fail
    sub $I11, rx548_pos, rx548_off
    substr $S10, rx548_tgt, $I11, 2
    ne $S10, "if", rx548_fail
    add rx548_pos, 2
    set_addr $I10, rxcap_550_fail
    ($I12, $I11) = rx548_cur."!mark_peek"($I10)
    rx548_cur."!cursor_pos"($I11)
    ($P10) = rx548_cur."!cursor_start"()
    $P10."!cursor_pass"(rx548_pos, "")
    rx548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_550_done
  rxcap_550_fail:
    goto rx548_fail
  rxcap_550_done:
  # rx subrule "ws" subtype=method negate=
    rx548_cur."!cursor_pos"(rx548_pos)
    $P10 = rx548_cur."ws"()
    unless $P10, rx548_fail
    rx548_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx548_cur."!cursor_pos"(rx548_pos)
    $P10 = rx548_cur."EXPR"()
    unless $P10, rx548_fail
    rx548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx548_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx548_cur."!cursor_pos"(rx548_pos)
    $P10 = rx548_cur."ws"()
    unless $P10, rx548_fail
    rx548_pos = $P10."pos"()
  # rx pass
    rx548_cur."!cursor_pass"(rx548_pos, "statement_mod_cond:sym<if>")
    if_null rx548_debug, debug_777
    rx548_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx548_pos)
  debug_777:
    .return (rx548_cur)
  rx548_restart:
.annotate 'line', 10
    if_null rx548_debug, debug_778
    rx548_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_778:
  rx548_fail:
    (rx548_rep, rx548_pos, $I10, $P10) = rx548_cur."!mark_fail"(0)
    lt rx548_pos, -1, rx548_done
    eq rx548_pos, -1, rx548_fail
    jump $I10
  rx548_done:
    rx548_cur."!cursor_fail"()
    if_null rx548_debug, debug_779
    rx548_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_779:
    .return (rx548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :subid("95_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P554 = self."!PREFIX__!subrule"("ws", "if")
    new $P555, "ResizablePMCArray"
    push $P555, $P554
    .return ($P555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("96_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx557_tgt
    .local int rx557_pos
    .local int rx557_off
    .local int rx557_eos
    .local int rx557_rep
    .local pmc rx557_cur
    .local pmc rx557_debug
    (rx557_cur, rx557_pos, rx557_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx557_cur
    .local pmc match
    .lex "$/", match
    length rx557_eos, rx557_tgt
    gt rx557_pos, rx557_eos, rx557_done
    set rx557_off, 0
    lt rx557_pos, 2, rx557_start
    sub rx557_off, rx557_pos, 1
    substr rx557_tgt, rx557_tgt, rx557_off
  rx557_start:
    eq $I10, 1, rx557_restart
    if_null rx557_debug, debug_780
    rx557_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan558_done
    goto rxscan558_scan
  rxscan558_loop:
    (rx557_pos) = rx557_cur."from"()
    inc rx557_pos
    rx557_cur."!cursor_from"(rx557_pos)
    ge rx557_pos, rx557_eos, rxscan558_done
  rxscan558_scan:
    set_addr $I10, rxscan558_loop
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
  rxscan558_done:
.annotate 'line', 259
  # rx subcapture "sym"
    set_addr $I10, rxcap_559_fail
    rx557_cur."!mark_push"(0, rx557_pos, $I10)
  # rx literal  "unless"
    add $I11, rx557_pos, 6
    gt $I11, rx557_eos, rx557_fail
    sub $I11, rx557_pos, rx557_off
    substr $S10, rx557_tgt, $I11, 6
    ne $S10, "unless", rx557_fail
    add rx557_pos, 6
    set_addr $I10, rxcap_559_fail
    ($I12, $I11) = rx557_cur."!mark_peek"($I10)
    rx557_cur."!cursor_pos"($I11)
    ($P10) = rx557_cur."!cursor_start"()
    $P10."!cursor_pass"(rx557_pos, "")
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_559_done
  rxcap_559_fail:
    goto rx557_fail
  rxcap_559_done:
  # rx subrule "ws" subtype=method negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."ws"()
    unless $P10, rx557_fail
    rx557_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."EXPR"()
    unless $P10, rx557_fail
    rx557_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx557_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx557_cur."!cursor_pos"(rx557_pos)
    $P10 = rx557_cur."ws"()
    unless $P10, rx557_fail
    rx557_pos = $P10."pos"()
  # rx pass
    rx557_cur."!cursor_pass"(rx557_pos, "statement_mod_cond:sym<unless>")
    if_null rx557_debug, debug_781
    rx557_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx557_pos)
  debug_781:
    .return (rx557_cur)
  rx557_restart:
.annotate 'line', 10
    if_null rx557_debug, debug_782
    rx557_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_782:
  rx557_fail:
    (rx557_rep, rx557_pos, $I10, $P10) = rx557_cur."!mark_fail"(0)
    lt rx557_pos, -1, rx557_done
    eq rx557_pos, -1, rx557_fail
    jump $I10
  rx557_done:
    rx557_cur."!cursor_fail"()
    if_null rx557_debug, debug_783
    rx557_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_783:
    .return (rx557_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :subid("97_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P563 = self."!PREFIX__!subrule"("ws", "unless")
    new $P564, "ResizablePMCArray"
    push $P564, $P563
    .return ($P564)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("98_1304516047.681")
    .param pmc param_566
.annotate 'line', 261
    .lex "self", param_566
    $P567 = param_566."!protoregex"("statement_mod_loop")
    .return ($P567)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("99_1304516047.681")
    .param pmc param_569
.annotate 'line', 261
    .lex "self", param_569
    $P570 = param_569."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("100_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx572_tgt
    .local int rx572_pos
    .local int rx572_off
    .local int rx572_eos
    .local int rx572_rep
    .local pmc rx572_cur
    .local pmc rx572_debug
    (rx572_cur, rx572_pos, rx572_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx572_cur
    .local pmc match
    .lex "$/", match
    length rx572_eos, rx572_tgt
    gt rx572_pos, rx572_eos, rx572_done
    set rx572_off, 0
    lt rx572_pos, 2, rx572_start
    sub rx572_off, rx572_pos, 1
    substr rx572_tgt, rx572_tgt, rx572_off
  rx572_start:
    eq $I10, 1, rx572_restart
    if_null rx572_debug, debug_784
    rx572_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan573_done
    goto rxscan573_scan
  rxscan573_loop:
    (rx572_pos) = rx572_cur."from"()
    inc rx572_pos
    rx572_cur."!cursor_from"(rx572_pos)
    ge rx572_pos, rx572_eos, rxscan573_done
  rxscan573_scan:
    set_addr $I10, rxscan573_loop
    rx572_cur."!mark_push"(0, rx572_pos, $I10)
  rxscan573_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_574_fail
    rx572_cur."!mark_push"(0, rx572_pos, $I10)
  # rx literal  "while"
    add $I11, rx572_pos, 5
    gt $I11, rx572_eos, rx572_fail
    sub $I11, rx572_pos, rx572_off
    substr $S10, rx572_tgt, $I11, 5
    ne $S10, "while", rx572_fail
    add rx572_pos, 5
    set_addr $I10, rxcap_574_fail
    ($I12, $I11) = rx572_cur."!mark_peek"($I10)
    rx572_cur."!cursor_pos"($I11)
    ($P10) = rx572_cur."!cursor_start"()
    $P10."!cursor_pass"(rx572_pos, "")
    rx572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_574_done
  rxcap_574_fail:
    goto rx572_fail
  rxcap_574_done:
  # rx subrule "ws" subtype=method negate=
    rx572_cur."!cursor_pos"(rx572_pos)
    $P10 = rx572_cur."ws"()
    unless $P10, rx572_fail
    rx572_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx572_cur."!cursor_pos"(rx572_pos)
    $P10 = rx572_cur."EXPR"()
    unless $P10, rx572_fail
    rx572_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx572_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx572_cur."!cursor_pos"(rx572_pos)
    $P10 = rx572_cur."ws"()
    unless $P10, rx572_fail
    rx572_pos = $P10."pos"()
  # rx pass
    rx572_cur."!cursor_pass"(rx572_pos, "statement_mod_loop:sym<while>")
    if_null rx572_debug, debug_785
    rx572_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx572_pos)
  debug_785:
    .return (rx572_cur)
  rx572_restart:
.annotate 'line', 10
    if_null rx572_debug, debug_786
    rx572_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_786:
  rx572_fail:
    (rx572_rep, rx572_pos, $I10, $P10) = rx572_cur."!mark_fail"(0)
    lt rx572_pos, -1, rx572_done
    eq rx572_pos, -1, rx572_fail
    jump $I10
  rx572_done:
    rx572_cur."!cursor_fail"()
    if_null rx572_debug, debug_787
    rx572_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_787:
    .return (rx572_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :subid("101_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P578 = self."!PREFIX__!subrule"("ws", "while")
    new $P579, "ResizablePMCArray"
    push $P579, $P578
    .return ($P579)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("102_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx581_tgt
    .local int rx581_pos
    .local int rx581_off
    .local int rx581_eos
    .local int rx581_rep
    .local pmc rx581_cur
    .local pmc rx581_debug
    (rx581_cur, rx581_pos, rx581_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx581_cur
    .local pmc match
    .lex "$/", match
    length rx581_eos, rx581_tgt
    gt rx581_pos, rx581_eos, rx581_done
    set rx581_off, 0
    lt rx581_pos, 2, rx581_start
    sub rx581_off, rx581_pos, 1
    substr rx581_tgt, rx581_tgt, rx581_off
  rx581_start:
    eq $I10, 1, rx581_restart
    if_null rx581_debug, debug_788
    rx581_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx581_pos) = rx581_cur."from"()
    inc rx581_pos
    rx581_cur."!cursor_from"(rx581_pos)
    ge rx581_pos, rx581_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx581_cur."!mark_push"(0, rx581_pos, $I10)
  rxscan582_done:
.annotate 'line', 264
  # rx subcapture "sym"
    set_addr $I10, rxcap_583_fail
    rx581_cur."!mark_push"(0, rx581_pos, $I10)
  # rx literal  "until"
    add $I11, rx581_pos, 5
    gt $I11, rx581_eos, rx581_fail
    sub $I11, rx581_pos, rx581_off
    substr $S10, rx581_tgt, $I11, 5
    ne $S10, "until", rx581_fail
    add rx581_pos, 5
    set_addr $I10, rxcap_583_fail
    ($I12, $I11) = rx581_cur."!mark_peek"($I10)
    rx581_cur."!cursor_pos"($I11)
    ($P10) = rx581_cur."!cursor_start"()
    $P10."!cursor_pass"(rx581_pos, "")
    rx581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_583_done
  rxcap_583_fail:
    goto rx581_fail
  rxcap_583_done:
  # rx subrule "ws" subtype=method negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."ws"()
    unless $P10, rx581_fail
    rx581_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."EXPR"()
    unless $P10, rx581_fail
    rx581_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx581_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx581_cur."!cursor_pos"(rx581_pos)
    $P10 = rx581_cur."ws"()
    unless $P10, rx581_fail
    rx581_pos = $P10."pos"()
  # rx pass
    rx581_cur."!cursor_pass"(rx581_pos, "statement_mod_loop:sym<until>")
    if_null rx581_debug, debug_789
    rx581_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx581_pos)
  debug_789:
    .return (rx581_cur)
  rx581_restart:
.annotate 'line', 10
    if_null rx581_debug, debug_790
    rx581_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_790:
  rx581_fail:
    (rx581_rep, rx581_pos, $I10, $P10) = rx581_cur."!mark_fail"(0)
    lt rx581_pos, -1, rx581_done
    eq rx581_pos, -1, rx581_fail
    jump $I10
  rx581_done:
    rx581_cur."!cursor_fail"()
    if_null rx581_debug, debug_791
    rx581_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_791:
    .return (rx581_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :subid("103_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P587 = self."!PREFIX__!subrule"("ws", "until")
    new $P588, "ResizablePMCArray"
    push $P588, $P587
    .return ($P588)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("104_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx590_tgt
    .local int rx590_pos
    .local int rx590_off
    .local int rx590_eos
    .local int rx590_rep
    .local pmc rx590_cur
    .local pmc rx590_debug
    (rx590_cur, rx590_pos, rx590_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx590_cur
    .local pmc match
    .lex "$/", match
    length rx590_eos, rx590_tgt
    gt rx590_pos, rx590_eos, rx590_done
    set rx590_off, 0
    lt rx590_pos, 2, rx590_start
    sub rx590_off, rx590_pos, 1
    substr rx590_tgt, rx590_tgt, rx590_off
  rx590_start:
    eq $I10, 1, rx590_restart
    if_null rx590_debug, debug_792
    rx590_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan591_done
    goto rxscan591_scan
  rxscan591_loop:
    (rx590_pos) = rx590_cur."from"()
    inc rx590_pos
    rx590_cur."!cursor_from"(rx590_pos)
    ge rx590_pos, rx590_eos, rxscan591_done
  rxscan591_scan:
    set_addr $I10, rxscan591_loop
    rx590_cur."!mark_push"(0, rx590_pos, $I10)
  rxscan591_done:
.annotate 'line', 265
  # rx subcapture "sym"
    set_addr $I10, rxcap_592_fail
    rx590_cur."!mark_push"(0, rx590_pos, $I10)
  # rx literal  "for"
    add $I11, rx590_pos, 3
    gt $I11, rx590_eos, rx590_fail
    sub $I11, rx590_pos, rx590_off
    substr $S10, rx590_tgt, $I11, 3
    ne $S10, "for", rx590_fail
    add rx590_pos, 3
    set_addr $I10, rxcap_592_fail
    ($I12, $I11) = rx590_cur."!mark_peek"($I10)
    rx590_cur."!cursor_pos"($I11)
    ($P10) = rx590_cur."!cursor_start"()
    $P10."!cursor_pass"(rx590_pos, "")
    rx590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_592_done
  rxcap_592_fail:
    goto rx590_fail
  rxcap_592_done:
  # rx subrule "ws" subtype=method negate=
    rx590_cur."!cursor_pos"(rx590_pos)
    $P10 = rx590_cur."ws"()
    unless $P10, rx590_fail
    rx590_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx590_cur."!cursor_pos"(rx590_pos)
    $P10 = rx590_cur."EXPR"()
    unless $P10, rx590_fail
    rx590_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx590_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx590_cur."!cursor_pos"(rx590_pos)
    $P10 = rx590_cur."ws"()
    unless $P10, rx590_fail
    rx590_pos = $P10."pos"()
  # rx pass
    rx590_cur."!cursor_pass"(rx590_pos, "statement_mod_loop:sym<for>")
    if_null rx590_debug, debug_793
    rx590_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx590_pos)
  debug_793:
    .return (rx590_cur)
  rx590_restart:
.annotate 'line', 10
    if_null rx590_debug, debug_794
    rx590_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_794:
  rx590_fail:
    (rx590_rep, rx590_pos, $I10, $P10) = rx590_cur."!mark_fail"(0)
    lt rx590_pos, -1, rx590_done
    eq rx590_pos, -1, rx590_fail
    jump $I10
  rx590_done:
    rx590_cur."!cursor_fail"()
    if_null rx590_debug, debug_795
    rx590_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_795:
    .return (rx590_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :subid("105_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P596 = self."!PREFIX__!subrule"("ws", "for")
    new $P597, "ResizablePMCArray"
    push $P597, $P596
    .return ($P597)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("106_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx599_tgt
    .local int rx599_pos
    .local int rx599_off
    .local int rx599_eos
    .local int rx599_rep
    .local pmc rx599_cur
    .local pmc rx599_debug
    (rx599_cur, rx599_pos, rx599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx599_cur
    .local pmc match
    .lex "$/", match
    length rx599_eos, rx599_tgt
    gt rx599_pos, rx599_eos, rx599_done
    set rx599_off, 0
    lt rx599_pos, 2, rx599_start
    sub rx599_off, rx599_pos, 1
    substr rx599_tgt, rx599_tgt, rx599_off
  rx599_start:
    eq $I10, 1, rx599_restart
    if_null rx599_debug, debug_796
    rx599_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan600_done
    goto rxscan600_scan
  rxscan600_loop:
    (rx599_pos) = rx599_cur."from"()
    inc rx599_pos
    rx599_cur."!cursor_from"(rx599_pos)
    ge rx599_pos, rx599_eos, rxscan600_done
  rxscan600_scan:
    set_addr $I10, rxscan600_loop
    rx599_cur."!mark_push"(0, rx599_pos, $I10)
  rxscan600_done:
.annotate 'line', 269
  # rx subrule "fatarrow" subtype=capture negate=
    rx599_cur."!cursor_pos"(rx599_pos)
    $P10 = rx599_cur."fatarrow"()
    unless $P10, rx599_fail
    rx599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx599_pos = $P10."pos"()
  # rx pass
    rx599_cur."!cursor_pass"(rx599_pos, "term:sym<fatarrow>")
    if_null rx599_debug, debug_797
    rx599_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx599_pos)
  debug_797:
    .return (rx599_cur)
  rx599_restart:
.annotate 'line', 10
    if_null rx599_debug, debug_798
    rx599_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_798:
  rx599_fail:
    (rx599_rep, rx599_pos, $I10, $P10) = rx599_cur."!mark_fail"(0)
    lt rx599_pos, -1, rx599_done
    eq rx599_pos, -1, rx599_fail
    jump $I10
  rx599_done:
    rx599_cur."!cursor_fail"()
    if_null rx599_debug, debug_799
    rx599_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_799:
    .return (rx599_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :subid("107_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P602 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P603, "ResizablePMCArray"
    push $P603, $P602
    .return ($P603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("108_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx605_tgt
    .local int rx605_pos
    .local int rx605_off
    .local int rx605_eos
    .local int rx605_rep
    .local pmc rx605_cur
    .local pmc rx605_debug
    (rx605_cur, rx605_pos, rx605_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx605_cur
    .local pmc match
    .lex "$/", match
    length rx605_eos, rx605_tgt
    gt rx605_pos, rx605_eos, rx605_done
    set rx605_off, 0
    lt rx605_pos, 2, rx605_start
    sub rx605_off, rx605_pos, 1
    substr rx605_tgt, rx605_tgt, rx605_off
  rx605_start:
    eq $I10, 1, rx605_restart
    if_null rx605_debug, debug_800
    rx605_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_800:
    $I10 = self.'from'()
    ne $I10, -1, rxscan606_done
    goto rxscan606_scan
  rxscan606_loop:
    (rx605_pos) = rx605_cur."from"()
    inc rx605_pos
    rx605_cur."!cursor_from"(rx605_pos)
    ge rx605_pos, rx605_eos, rxscan606_done
  rxscan606_scan:
    set_addr $I10, rxscan606_loop
    rx605_cur."!mark_push"(0, rx605_pos, $I10)
  rxscan606_done:
.annotate 'line', 270
  # rx subrule "colonpair" subtype=capture negate=
    rx605_cur."!cursor_pos"(rx605_pos)
    $P10 = rx605_cur."colonpair"()
    unless $P10, rx605_fail
    rx605_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx605_pos = $P10."pos"()
  # rx pass
    rx605_cur."!cursor_pass"(rx605_pos, "term:sym<colonpair>")
    if_null rx605_debug, debug_801
    rx605_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx605_pos)
  debug_801:
    .return (rx605_cur)
  rx605_restart:
.annotate 'line', 10
    if_null rx605_debug, debug_802
    rx605_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_802:
  rx605_fail:
    (rx605_rep, rx605_pos, $I10, $P10) = rx605_cur."!mark_fail"(0)
    lt rx605_pos, -1, rx605_done
    eq rx605_pos, -1, rx605_fail
    jump $I10
  rx605_done:
    rx605_cur."!cursor_fail"()
    if_null rx605_debug, debug_803
    rx605_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_803:
    .return (rx605_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :subid("109_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P608 = self."!PREFIX__!subrule"("colonpair", "")
    new $P609, "ResizablePMCArray"
    push $P609, $P608
    .return ($P609)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("110_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx611_tgt
    .local int rx611_pos
    .local int rx611_off
    .local int rx611_eos
    .local int rx611_rep
    .local pmc rx611_cur
    .local pmc rx611_debug
    (rx611_cur, rx611_pos, rx611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx611_cur
    .local pmc match
    .lex "$/", match
    length rx611_eos, rx611_tgt
    gt rx611_pos, rx611_eos, rx611_done
    set rx611_off, 0
    lt rx611_pos, 2, rx611_start
    sub rx611_off, rx611_pos, 1
    substr rx611_tgt, rx611_tgt, rx611_off
  rx611_start:
    eq $I10, 1, rx611_restart
    if_null rx611_debug, debug_804
    rx611_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_804:
    $I10 = self.'from'()
    ne $I10, -1, rxscan612_done
    goto rxscan612_scan
  rxscan612_loop:
    (rx611_pos) = rx611_cur."from"()
    inc rx611_pos
    rx611_cur."!cursor_from"(rx611_pos)
    ge rx611_pos, rx611_eos, rxscan612_done
  rxscan612_scan:
    set_addr $I10, rxscan612_loop
    rx611_cur."!mark_push"(0, rx611_pos, $I10)
  rxscan612_done:
.annotate 'line', 271
  # rx subrule "variable" subtype=capture negate=
    rx611_cur."!cursor_pos"(rx611_pos)
    $P10 = rx611_cur."variable"()
    unless $P10, rx611_fail
    rx611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx611_pos = $P10."pos"()
  # rx pass
    rx611_cur."!cursor_pass"(rx611_pos, "term:sym<variable>")
    if_null rx611_debug, debug_805
    rx611_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx611_pos)
  debug_805:
    .return (rx611_cur)
  rx611_restart:
.annotate 'line', 10
    if_null rx611_debug, debug_806
    rx611_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_806:
  rx611_fail:
    (rx611_rep, rx611_pos, $I10, $P10) = rx611_cur."!mark_fail"(0)
    lt rx611_pos, -1, rx611_done
    eq rx611_pos, -1, rx611_fail
    jump $I10
  rx611_done:
    rx611_cur."!cursor_fail"()
    if_null rx611_debug, debug_807
    rx611_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_807:
    .return (rx611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :subid("111_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P614 = self."!PREFIX__!subrule"("variable", "")
    new $P615, "ResizablePMCArray"
    push $P615, $P614
    .return ($P615)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("112_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx617_tgt
    .local int rx617_pos
    .local int rx617_off
    .local int rx617_eos
    .local int rx617_rep
    .local pmc rx617_cur
    .local pmc rx617_debug
    (rx617_cur, rx617_pos, rx617_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx617_cur
    .local pmc match
    .lex "$/", match
    length rx617_eos, rx617_tgt
    gt rx617_pos, rx617_eos, rx617_done
    set rx617_off, 0
    lt rx617_pos, 2, rx617_start
    sub rx617_off, rx617_pos, 1
    substr rx617_tgt, rx617_tgt, rx617_off
  rx617_start:
    eq $I10, 1, rx617_restart
    if_null rx617_debug, debug_808
    rx617_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan618_done
    goto rxscan618_scan
  rxscan618_loop:
    (rx617_pos) = rx617_cur."from"()
    inc rx617_pos
    rx617_cur."!cursor_from"(rx617_pos)
    ge rx617_pos, rx617_eos, rxscan618_done
  rxscan618_scan:
    set_addr $I10, rxscan618_loop
    rx617_cur."!mark_push"(0, rx617_pos, $I10)
  rxscan618_done:
.annotate 'line', 272
  # rx subrule "package_declarator" subtype=capture negate=
    rx617_cur."!cursor_pos"(rx617_pos)
    $P10 = rx617_cur."package_declarator"()
    unless $P10, rx617_fail
    rx617_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx617_pos = $P10."pos"()
  # rx pass
    rx617_cur."!cursor_pass"(rx617_pos, "term:sym<package_declarator>")
    if_null rx617_debug, debug_809
    rx617_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx617_pos)
  debug_809:
    .return (rx617_cur)
  rx617_restart:
.annotate 'line', 10
    if_null rx617_debug, debug_810
    rx617_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_810:
  rx617_fail:
    (rx617_rep, rx617_pos, $I10, $P10) = rx617_cur."!mark_fail"(0)
    lt rx617_pos, -1, rx617_done
    eq rx617_pos, -1, rx617_fail
    jump $I10
  rx617_done:
    rx617_cur."!cursor_fail"()
    if_null rx617_debug, debug_811
    rx617_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_811:
    .return (rx617_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :subid("113_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P620 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P621, "ResizablePMCArray"
    push $P621, $P620
    .return ($P621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("114_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx623_tgt
    .local int rx623_pos
    .local int rx623_off
    .local int rx623_eos
    .local int rx623_rep
    .local pmc rx623_cur
    .local pmc rx623_debug
    (rx623_cur, rx623_pos, rx623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx623_cur
    .local pmc match
    .lex "$/", match
    length rx623_eos, rx623_tgt
    gt rx623_pos, rx623_eos, rx623_done
    set rx623_off, 0
    lt rx623_pos, 2, rx623_start
    sub rx623_off, rx623_pos, 1
    substr rx623_tgt, rx623_tgt, rx623_off
  rx623_start:
    eq $I10, 1, rx623_restart
    if_null rx623_debug, debug_812
    rx623_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan624_done
    goto rxscan624_scan
  rxscan624_loop:
    (rx623_pos) = rx623_cur."from"()
    inc rx623_pos
    rx623_cur."!cursor_from"(rx623_pos)
    ge rx623_pos, rx623_eos, rxscan624_done
  rxscan624_scan:
    set_addr $I10, rxscan624_loop
    rx623_cur."!mark_push"(0, rx623_pos, $I10)
  rxscan624_done:
.annotate 'line', 273
  # rx subrule "scope_declarator" subtype=capture negate=
    rx623_cur."!cursor_pos"(rx623_pos)
    $P10 = rx623_cur."scope_declarator"()
    unless $P10, rx623_fail
    rx623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx623_pos = $P10."pos"()
  # rx pass
    rx623_cur."!cursor_pass"(rx623_pos, "term:sym<scope_declarator>")
    if_null rx623_debug, debug_813
    rx623_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx623_pos)
  debug_813:
    .return (rx623_cur)
  rx623_restart:
.annotate 'line', 10
    if_null rx623_debug, debug_814
    rx623_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_814:
  rx623_fail:
    (rx623_rep, rx623_pos, $I10, $P10) = rx623_cur."!mark_fail"(0)
    lt rx623_pos, -1, rx623_done
    eq rx623_pos, -1, rx623_fail
    jump $I10
  rx623_done:
    rx623_cur."!cursor_fail"()
    if_null rx623_debug, debug_815
    rx623_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_815:
    .return (rx623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :subid("115_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P626 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P627, "ResizablePMCArray"
    push $P627, $P626
    .return ($P627)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("116_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx629_tgt
    .local int rx629_pos
    .local int rx629_off
    .local int rx629_eos
    .local int rx629_rep
    .local pmc rx629_cur
    .local pmc rx629_debug
    (rx629_cur, rx629_pos, rx629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx629_cur
    .local pmc match
    .lex "$/", match
    length rx629_eos, rx629_tgt
    gt rx629_pos, rx629_eos, rx629_done
    set rx629_off, 0
    lt rx629_pos, 2, rx629_start
    sub rx629_off, rx629_pos, 1
    substr rx629_tgt, rx629_tgt, rx629_off
  rx629_start:
    eq $I10, 1, rx629_restart
    if_null rx629_debug, debug_816
    rx629_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan630_done
    goto rxscan630_scan
  rxscan630_loop:
    (rx629_pos) = rx629_cur."from"()
    inc rx629_pos
    rx629_cur."!cursor_from"(rx629_pos)
    ge rx629_pos, rx629_eos, rxscan630_done
  rxscan630_scan:
    set_addr $I10, rxscan630_loop
    rx629_cur."!mark_push"(0, rx629_pos, $I10)
  rxscan630_done:
.annotate 'line', 274
  # rx subrule "routine_declarator" subtype=capture negate=
    rx629_cur."!cursor_pos"(rx629_pos)
    $P10 = rx629_cur."routine_declarator"()
    unless $P10, rx629_fail
    rx629_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx629_pos = $P10."pos"()
  # rx pass
    rx629_cur."!cursor_pass"(rx629_pos, "term:sym<routine_declarator>")
    if_null rx629_debug, debug_817
    rx629_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx629_pos)
  debug_817:
    .return (rx629_cur)
  rx629_restart:
.annotate 'line', 10
    if_null rx629_debug, debug_818
    rx629_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_818:
  rx629_fail:
    (rx629_rep, rx629_pos, $I10, $P10) = rx629_cur."!mark_fail"(0)
    lt rx629_pos, -1, rx629_done
    eq rx629_pos, -1, rx629_fail
    jump $I10
  rx629_done:
    rx629_cur."!cursor_fail"()
    if_null rx629_debug, debug_819
    rx629_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_819:
    .return (rx629_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :subid("117_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P632 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P633, "ResizablePMCArray"
    push $P633, $P632
    .return ($P633)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("118_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P643 = "120_1304516047.681" 
    capture_lex $P643
    .const 'Sub' $P638 = "119_1304516047.681" 
    capture_lex $P638
    .local string rx635_tgt
    .local int rx635_pos
    .local int rx635_off
    .local int rx635_eos
    .local int rx635_rep
    .local pmc rx635_cur
    .local pmc rx635_debug
    (rx635_cur, rx635_pos, rx635_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx635_cur
    .local pmc match
    .lex "$/", match
    length rx635_eos, rx635_tgt
    gt rx635_pos, rx635_eos, rx635_done
    set rx635_off, 0
    lt rx635_pos, 2, rx635_start
    sub rx635_off, rx635_pos, 1
    substr rx635_tgt, rx635_tgt, rx635_off
  rx635_start:
    eq $I10, 1, rx635_restart
    if_null rx635_debug, debug_820
    rx635_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan636_done
    goto rxscan636_scan
  rxscan636_loop:
    (rx635_pos) = rx635_cur."from"()
    inc rx635_pos
    rx635_cur."!cursor_from"(rx635_pos)
    ge rx635_pos, rx635_eos, rxscan636_done
  rxscan636_scan:
    set_addr $I10, rxscan636_loop
    rx635_cur."!mark_push"(0, rx635_pos, $I10)
  rxscan636_done:
.annotate 'line', 276
  # rx subrule "before" subtype=zerowidth negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    .const 'Sub' $P638 = "119_1304516047.681" 
    capture_lex $P638
    $P10 = rx635_cur."before"($P638)
    unless $P10, rx635_fail
.annotate 'line', 277
  # rx subrule "before" subtype=zerowidth negate=1
    rx635_cur."!cursor_pos"(rx635_pos)
    .const 'Sub' $P643 = "120_1304516047.681" 
    capture_lex $P643
    $P10 = rx635_cur."before"($P643)
    if $P10, rx635_fail
.annotate 'line', 278
  # rx subrule "multi_declarator" subtype=capture negate=
    rx635_cur."!cursor_pos"(rx635_pos)
    $P10 = rx635_cur."multi_declarator"()
    unless $P10, rx635_fail
    rx635_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx635_pos = $P10."pos"()
.annotate 'line', 275
  # rx pass
    rx635_cur."!cursor_pass"(rx635_pos, "term:sym<multi_declarator>")
    if_null rx635_debug, debug_829
    rx635_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx635_pos)
  debug_829:
    .return (rx635_cur)
  rx635_restart:
.annotate 'line', 10
    if_null rx635_debug, debug_830
    rx635_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_830:
  rx635_fail:
    (rx635_rep, rx635_pos, $I10, $P10) = rx635_cur."!mark_fail"(0)
    lt rx635_pos, -1, rx635_done
    eq rx635_pos, -1, rx635_fail
    jump $I10
  rx635_done:
    rx635_cur."!cursor_fail"()
    if_null rx635_debug, debug_831
    rx635_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_831:
    .return (rx635_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block637"  :anon :subid("119_1304516047.681") :method :outer("118_1304516047.681")
.annotate 'line', 276
    .local string rx639_tgt
    .local int rx639_pos
    .local int rx639_off
    .local int rx639_eos
    .local int rx639_rep
    .local pmc rx639_cur
    .local pmc rx639_debug
    (rx639_cur, rx639_pos, rx639_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx639_cur
    .local pmc match
    .lex "$/", match
    length rx639_eos, rx639_tgt
    gt rx639_pos, rx639_eos, rx639_done
    set rx639_off, 0
    lt rx639_pos, 2, rx639_start
    sub rx639_off, rx639_pos, 1
    substr rx639_tgt, rx639_tgt, rx639_off
  rx639_start:
    eq $I10, 1, rx639_restart
    if_null rx639_debug, debug_821
    rx639_cur."!cursor_debug"("START", "")
  debug_821:
    $I10 = self.'from'()
    ne $I10, -1, rxscan640_done
    goto rxscan640_scan
  rxscan640_loop:
    (rx639_pos) = rx639_cur."from"()
    inc rx639_pos
    rx639_cur."!cursor_from"(rx639_pos)
    ge rx639_pos, rx639_eos, rxscan640_done
  rxscan640_scan:
    set_addr $I10, rxscan640_loop
    rx639_cur."!mark_push"(0, rx639_pos, $I10)
  rxscan640_done:
  alt641_0:
    set_addr $I10, alt641_1
    rx639_cur."!mark_push"(0, rx639_pos, $I10)
  # rx literal  "multi"
    add $I11, rx639_pos, 5
    gt $I11, rx639_eos, rx639_fail
    sub $I11, rx639_pos, rx639_off
    substr $S10, rx639_tgt, $I11, 5
    ne $S10, "multi", rx639_fail
    add rx639_pos, 5
    goto alt641_end
  alt641_1:
    set_addr $I10, alt641_2
    rx639_cur."!mark_push"(0, rx639_pos, $I10)
  # rx literal  "proto"
    add $I11, rx639_pos, 5
    gt $I11, rx639_eos, rx639_fail
    sub $I11, rx639_pos, rx639_off
    substr $S10, rx639_tgt, $I11, 5
    ne $S10, "proto", rx639_fail
    add rx639_pos, 5
    goto alt641_end
  alt641_2:
  # rx literal  "only"
    add $I11, rx639_pos, 4
    gt $I11, rx639_eos, rx639_fail
    sub $I11, rx639_pos, rx639_off
    substr $S10, rx639_tgt, $I11, 4
    ne $S10, "only", rx639_fail
    add rx639_pos, 4
  alt641_end:
  # rx pass
    rx639_cur."!cursor_pass"(rx639_pos, "")
    if_null rx639_debug, debug_822
    rx639_cur."!cursor_debug"("PASS", "", " at pos=", rx639_pos)
  debug_822:
    .return (rx639_cur)
  rx639_restart:
    if_null rx639_debug, debug_823
    rx639_cur."!cursor_debug"("NEXT", "")
  debug_823:
  rx639_fail:
    (rx639_rep, rx639_pos, $I10, $P10) = rx639_cur."!mark_fail"(0)
    lt rx639_pos, -1, rx639_done
    eq rx639_pos, -1, rx639_fail
    jump $I10
  rx639_done:
    rx639_cur."!cursor_fail"()
    if_null rx639_debug, debug_824
    rx639_cur."!cursor_debug"("FAIL", "")
  debug_824:
    .return (rx639_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block642"  :anon :subid("120_1304516047.681") :method :outer("118_1304516047.681")
.annotate 'line', 277
    .local string rx644_tgt
    .local int rx644_pos
    .local int rx644_off
    .local int rx644_eos
    .local int rx644_rep
    .local pmc rx644_cur
    .local pmc rx644_debug
    (rx644_cur, rx644_pos, rx644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx644_cur
    .local pmc match
    .lex "$/", match
    length rx644_eos, rx644_tgt
    gt rx644_pos, rx644_eos, rx644_done
    set rx644_off, 0
    lt rx644_pos, 2, rx644_start
    sub rx644_off, rx644_pos, 1
    substr rx644_tgt, rx644_tgt, rx644_off
  rx644_start:
    eq $I10, 1, rx644_restart
    if_null rx644_debug, debug_825
    rx644_cur."!cursor_debug"("START", "")
  debug_825:
    $I10 = self.'from'()
    ne $I10, -1, rxscan645_done
    goto rxscan645_scan
  rxscan645_loop:
    (rx644_pos) = rx644_cur."from"()
    inc rx644_pos
    rx644_cur."!cursor_from"(rx644_pos)
    ge rx644_pos, rx644_eos, rxscan645_done
  rxscan645_scan:
    set_addr $I10, rxscan645_loop
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxscan645_done:
  # rx literal  "proto"
    add $I11, rx644_pos, 5
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 5
    ne $S10, "proto", rx644_fail
    add rx644_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  alt646_0:
    set_addr $I10, alt646_1
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  # rx literal  "regex"
    add $I11, rx644_pos, 5
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 5
    ne $S10, "regex", rx644_fail
    add rx644_pos, 5
    goto alt646_end
  alt646_1:
    set_addr $I10, alt646_2
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  # rx literal  "token"
    add $I11, rx644_pos, 5
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 5
    ne $S10, "token", rx644_fail
    add rx644_pos, 5
    goto alt646_end
  alt646_2:
  # rx literal  "rule"
    add $I11, rx644_pos, 4
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 4
    ne $S10, "rule", rx644_fail
    add rx644_pos, 4
  alt646_end:
  # rx pass
    rx644_cur."!cursor_pass"(rx644_pos, "")
    if_null rx644_debug, debug_826
    rx644_cur."!cursor_debug"("PASS", "", " at pos=", rx644_pos)
  debug_826:
    .return (rx644_cur)
  rx644_restart:
    if_null rx644_debug, debug_827
    rx644_cur."!cursor_debug"("NEXT", "")
  debug_827:
  rx644_fail:
    (rx644_rep, rx644_pos, $I10, $P10) = rx644_cur."!mark_fail"(0)
    lt rx644_pos, -1, rx644_done
    eq rx644_pos, -1, rx644_fail
    jump $I10
  rx644_done:
    rx644_cur."!cursor_fail"()
    if_null rx644_debug, debug_828
    rx644_cur."!cursor_debug"("FAIL", "")
  debug_828:
    .return (rx644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :subid("121_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P648, "ResizablePMCArray"
    push $P648, ""
    .return ($P648)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("122_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx650_tgt
    .local int rx650_pos
    .local int rx650_off
    .local int rx650_eos
    .local int rx650_rep
    .local pmc rx650_cur
    .local pmc rx650_debug
    (rx650_cur, rx650_pos, rx650_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx650_cur
    .local pmc match
    .lex "$/", match
    length rx650_eos, rx650_tgt
    gt rx650_pos, rx650_eos, rx650_done
    set rx650_off, 0
    lt rx650_pos, 2, rx650_start
    sub rx650_off, rx650_pos, 1
    substr rx650_tgt, rx650_tgt, rx650_off
  rx650_start:
    eq $I10, 1, rx650_restart
    if_null rx650_debug, debug_832
    rx650_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan651_done
    goto rxscan651_scan
  rxscan651_loop:
    (rx650_pos) = rx650_cur."from"()
    inc rx650_pos
    rx650_cur."!cursor_from"(rx650_pos)
    ge rx650_pos, rx650_eos, rxscan651_done
  rxscan651_scan:
    set_addr $I10, rxscan651_loop
    rx650_cur."!mark_push"(0, rx650_pos, $I10)
  rxscan651_done:
.annotate 'line', 280
  # rx subrule "regex_declarator" subtype=capture negate=
    rx650_cur."!cursor_pos"(rx650_pos)
    $P10 = rx650_cur."regex_declarator"()
    unless $P10, rx650_fail
    rx650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx650_pos = $P10."pos"()
  # rx pass
    rx650_cur."!cursor_pass"(rx650_pos, "term:sym<regex_declarator>")
    if_null rx650_debug, debug_833
    rx650_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx650_pos)
  debug_833:
    .return (rx650_cur)
  rx650_restart:
.annotate 'line', 10
    if_null rx650_debug, debug_834
    rx650_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_834:
  rx650_fail:
    (rx650_rep, rx650_pos, $I10, $P10) = rx650_cur."!mark_fail"(0)
    lt rx650_pos, -1, rx650_done
    eq rx650_pos, -1, rx650_fail
    jump $I10
  rx650_done:
    rx650_cur."!cursor_fail"()
    if_null rx650_debug, debug_835
    rx650_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_835:
    .return (rx650_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :subid("123_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P653 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P654, "ResizablePMCArray"
    push $P654, $P653
    .return ($P654)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("124_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx656_tgt
    .local int rx656_pos
    .local int rx656_off
    .local int rx656_eos
    .local int rx656_rep
    .local pmc rx656_cur
    .local pmc rx656_debug
    (rx656_cur, rx656_pos, rx656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx656_cur
    .local pmc match
    .lex "$/", match
    length rx656_eos, rx656_tgt
    gt rx656_pos, rx656_eos, rx656_done
    set rx656_off, 0
    lt rx656_pos, 2, rx656_start
    sub rx656_off, rx656_pos, 1
    substr rx656_tgt, rx656_tgt, rx656_off
  rx656_start:
    eq $I10, 1, rx656_restart
    if_null rx656_debug, debug_836
    rx656_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan657_done
    goto rxscan657_scan
  rxscan657_loop:
    (rx656_pos) = rx656_cur."from"()
    inc rx656_pos
    rx656_cur."!cursor_from"(rx656_pos)
    ge rx656_pos, rx656_eos, rxscan657_done
  rxscan657_scan:
    set_addr $I10, rxscan657_loop
    rx656_cur."!mark_push"(0, rx656_pos, $I10)
  rxscan657_done:
.annotate 'line', 281
  # rx subrule "statement_prefix" subtype=capture negate=
    rx656_cur."!cursor_pos"(rx656_pos)
    $P10 = rx656_cur."statement_prefix"()
    unless $P10, rx656_fail
    rx656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx656_pos = $P10."pos"()
  # rx pass
    rx656_cur."!cursor_pass"(rx656_pos, "term:sym<statement_prefix>")
    if_null rx656_debug, debug_837
    rx656_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx656_pos)
  debug_837:
    .return (rx656_cur)
  rx656_restart:
.annotate 'line', 10
    if_null rx656_debug, debug_838
    rx656_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_838:
  rx656_fail:
    (rx656_rep, rx656_pos, $I10, $P10) = rx656_cur."!mark_fail"(0)
    lt rx656_pos, -1, rx656_done
    eq rx656_pos, -1, rx656_fail
    jump $I10
  rx656_done:
    rx656_cur."!cursor_fail"()
    if_null rx656_debug, debug_839
    rx656_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_839:
    .return (rx656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :subid("125_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P659 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P660, "ResizablePMCArray"
    push $P660, $P659
    .return ($P660)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("126_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx662_tgt
    .local int rx662_pos
    .local int rx662_off
    .local int rx662_eos
    .local int rx662_rep
    .local pmc rx662_cur
    .local pmc rx662_debug
    (rx662_cur, rx662_pos, rx662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx662_cur
    .local pmc match
    .lex "$/", match
    length rx662_eos, rx662_tgt
    gt rx662_pos, rx662_eos, rx662_done
    set rx662_off, 0
    lt rx662_pos, 2, rx662_start
    sub rx662_off, rx662_pos, 1
    substr rx662_tgt, rx662_tgt, rx662_off
  rx662_start:
    eq $I10, 1, rx662_restart
    if_null rx662_debug, debug_840
    rx662_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan663_done
    goto rxscan663_scan
  rxscan663_loop:
    (rx662_pos) = rx662_cur."from"()
    inc rx662_pos
    rx662_cur."!cursor_from"(rx662_pos)
    ge rx662_pos, rx662_eos, rxscan663_done
  rxscan663_scan:
    set_addr $I10, rxscan663_loop
    rx662_cur."!mark_push"(0, rx662_pos, $I10)
  rxscan663_done:
.annotate 'line', 282
  # rx subrule "lambda" subtype=zerowidth negate=
    rx662_cur."!cursor_pos"(rx662_pos)
    $P10 = rx662_cur."lambda"()
    unless $P10, rx662_fail
  # rx subrule "pblock" subtype=capture negate=
    rx662_cur."!cursor_pos"(rx662_pos)
    $P10 = rx662_cur."pblock"()
    unless $P10, rx662_fail
    rx662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx662_pos = $P10."pos"()
  # rx pass
    rx662_cur."!cursor_pass"(rx662_pos, "term:sym<lambda>")
    if_null rx662_debug, debug_841
    rx662_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx662_pos)
  debug_841:
    .return (rx662_cur)
  rx662_restart:
.annotate 'line', 10
    if_null rx662_debug, debug_842
    rx662_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_842:
  rx662_fail:
    (rx662_rep, rx662_pos, $I10, $P10) = rx662_cur."!mark_fail"(0)
    lt rx662_pos, -1, rx662_done
    eq rx662_pos, -1, rx662_fail
    jump $I10
  rx662_done:
    rx662_cur."!cursor_fail"()
    if_null rx662_debug, debug_843
    rx662_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_843:
    .return (rx662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :subid("127_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P665, "ResizablePMCArray"
    push $P665, ""
    .return ($P665)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("128_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx667_tgt
    .local int rx667_pos
    .local int rx667_off
    .local int rx667_eos
    .local int rx667_rep
    .local pmc rx667_cur
    .local pmc rx667_debug
    (rx667_cur, rx667_pos, rx667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx667_cur
    .local pmc match
    .lex "$/", match
    length rx667_eos, rx667_tgt
    gt rx667_pos, rx667_eos, rx667_done
    set rx667_off, 0
    lt rx667_pos, 2, rx667_start
    sub rx667_off, rx667_pos, 1
    substr rx667_tgt, rx667_tgt, rx667_off
  rx667_start:
    eq $I10, 1, rx667_restart
    if_null rx667_debug, debug_844
    rx667_cur."!cursor_debug"("START", "fatarrow")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan668_done
    goto rxscan668_scan
  rxscan668_loop:
    (rx667_pos) = rx667_cur."from"()
    inc rx667_pos
    rx667_cur."!cursor_from"(rx667_pos)
    ge rx667_pos, rx667_eos, rxscan668_done
  rxscan668_scan:
    set_addr $I10, rxscan668_loop
    rx667_cur."!mark_push"(0, rx667_pos, $I10)
  rxscan668_done:
.annotate 'line', 285
  # rx subrule "identifier" subtype=capture negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."identifier"()
    unless $P10, rx667_fail
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx667_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx667_pos, rx667_off
    set rx667_rep, 0
    sub $I12, rx667_eos, rx667_pos
  rxenumcharlistq669_loop:
    le $I12, 0, rxenumcharlistq669_done
    substr $S10, rx667_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq669_done
    inc rx667_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq669_loop
  rxenumcharlistq669_done:
    add rx667_pos, rx667_pos, rx667_rep
  # rx literal  "=>"
    add $I11, rx667_pos, 2
    gt $I11, rx667_eos, rx667_fail
    sub $I11, rx667_pos, rx667_off
    substr $S10, rx667_tgt, $I11, 2
    ne $S10, "=>", rx667_fail
    add rx667_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."ws"()
    unless $P10, rx667_fail
    rx667_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."EXPR"("i=")
    unless $P10, rx667_fail
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx667_pos = $P10."pos"()
.annotate 'line', 284
  # rx pass
    rx667_cur."!cursor_pass"(rx667_pos, "fatarrow")
    if_null rx667_debug, debug_845
    rx667_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx667_pos)
  debug_845:
    .return (rx667_cur)
  rx667_restart:
.annotate 'line', 10
    if_null rx667_debug, debug_846
    rx667_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_846:
  rx667_fail:
    (rx667_rep, rx667_pos, $I10, $P10) = rx667_cur."!mark_fail"(0)
    lt rx667_pos, -1, rx667_done
    eq rx667_pos, -1, rx667_fail
    jump $I10
  rx667_done:
    rx667_cur."!cursor_fail"()
    if_null rx667_debug, debug_847
    rx667_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_847:
    .return (rx667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :subid("129_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P671 = self."!PREFIX__!subrule"("identifier", "")
    new $P672, "ResizablePMCArray"
    push $P672, $P671
    .return ($P672)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("130_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx674_tgt
    .local int rx674_pos
    .local int rx674_off
    .local int rx674_eos
    .local int rx674_rep
    .local pmc rx674_cur
    .local pmc rx674_debug
    (rx674_cur, rx674_pos, rx674_tgt, $I10) = self."!cursor_start"()
    rx674_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx674_cur
    .local pmc match
    .lex "$/", match
    length rx674_eos, rx674_tgt
    gt rx674_pos, rx674_eos, rx674_done
    set rx674_off, 0
    lt rx674_pos, 2, rx674_start
    sub rx674_off, rx674_pos, 1
    substr rx674_tgt, rx674_tgt, rx674_off
  rx674_start:
    eq $I10, 1, rx674_restart
    if_null rx674_debug, debug_848
    rx674_cur."!cursor_debug"("START", "colonpair")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan675_done
    goto rxscan675_scan
  rxscan675_loop:
    (rx674_pos) = rx674_cur."from"()
    inc rx674_pos
    rx674_cur."!cursor_from"(rx674_pos)
    ge rx674_pos, rx674_eos, rxscan675_done
  rxscan675_scan:
    set_addr $I10, rxscan675_loop
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
  rxscan675_done:
.annotate 'line', 289
  # rx literal  ":"
    add $I11, rx674_pos, 1
    gt $I11, rx674_eos, rx674_fail
    sub $I11, rx674_pos, rx674_off
    ord $I11, rx674_tgt, $I11
    ne $I11, 58, rx674_fail
    add rx674_pos, 1
  alt676_0:
.annotate 'line', 290
    set_addr $I10, alt676_1
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
.annotate 'line', 291
  # rx subcapture "not"
    set_addr $I10, rxcap_677_fail
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
  # rx literal  "!"
    add $I11, rx674_pos, 1
    gt $I11, rx674_eos, rx674_fail
    sub $I11, rx674_pos, rx674_off
    ord $I11, rx674_tgt, $I11
    ne $I11, 33, rx674_fail
    add rx674_pos, 1
    set_addr $I10, rxcap_677_fail
    ($I12, $I11) = rx674_cur."!mark_peek"($I10)
    rx674_cur."!cursor_pos"($I11)
    ($P10) = rx674_cur."!cursor_start"()
    $P10."!cursor_pass"(rx674_pos, "")
    rx674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_677_done
  rxcap_677_fail:
    goto rx674_fail
  rxcap_677_done:
  # rx subrule "identifier" subtype=capture negate=
    rx674_cur."!cursor_pos"(rx674_pos)
    $P10 = rx674_cur."identifier"()
    unless $P10, rx674_fail
    rx674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx674_pos = $P10."pos"()
    goto alt676_end
  alt676_1:
    set_addr $I10, alt676_2
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
.annotate 'line', 292
  # rx subrule "identifier" subtype=capture negate=
    rx674_cur."!cursor_pos"(rx674_pos)
    $P10 = rx674_cur."identifier"()
    unless $P10, rx674_fail
    rx674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx674_pos = $P10."pos"()
  # rx rxquantr678 ** 0..1
    set_addr $I10, rxquantr678_done
    rx674_cur."!mark_push"(0, rx674_pos, $I10)
  rxquantr678_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx674_cur."!cursor_pos"(rx674_pos)
    $P10 = rx674_cur."circumfix"()
    unless $P10, rx674_fail
    goto rxsubrule679_pass
  rxsubrule679_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx674_fail
  rxsubrule679_pass:
    set_addr $I10, rxsubrule679_back
    rx674_cur."!mark_push"(0, rx674_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx674_pos = $P10."pos"()
    set_addr $I10, rxquantr678_done
    (rx674_rep) = rx674_cur."!mark_commit"($I10)
  rxquantr678_done:
    goto alt676_end
  alt676_2:
.annotate 'line', 293
  # rx subrule "circumfix" subtype=capture negate=
    rx674_cur."!cursor_pos"(rx674_pos)
    $P10 = rx674_cur."circumfix"()
    unless $P10, rx674_fail
    rx674_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx674_pos = $P10."pos"()
  alt676_end:
.annotate 'line', 288
  # rx pass
    rx674_cur."!cursor_pass"(rx674_pos, "colonpair")
    if_null rx674_debug, debug_849
    rx674_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx674_pos)
  debug_849:
    .return (rx674_cur)
  rx674_restart:
.annotate 'line', 10
    if_null rx674_debug, debug_850
    rx674_cur."!cursor_debug"("NEXT", "colonpair")
  debug_850:
  rx674_fail:
    (rx674_rep, rx674_pos, $I10, $P10) = rx674_cur."!mark_fail"(0)
    lt rx674_pos, -1, rx674_done
    eq rx674_pos, -1, rx674_fail
    jump $I10
  rx674_done:
    rx674_cur."!cursor_fail"()
    if_null rx674_debug, debug_851
    rx674_cur."!cursor_debug"("FAIL", "colonpair")
  debug_851:
    .return (rx674_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :subid("131_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P681 = self."!PREFIX__!subrule"("circumfix", ":")
    $P682 = self."!PREFIX__!subrule"("identifier", ":")
    $P683 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P684, "ResizablePMCArray"
    push $P684, $P681
    push $P684, $P682
    push $P684, $P683
    .return ($P684)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("132_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx686_tgt
    .local int rx686_pos
    .local int rx686_off
    .local int rx686_eos
    .local int rx686_rep
    .local pmc rx686_cur
    .local pmc rx686_debug
    (rx686_cur, rx686_pos, rx686_tgt, $I10) = self."!cursor_start"()
    rx686_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx686_cur
    .local pmc match
    .lex "$/", match
    length rx686_eos, rx686_tgt
    gt rx686_pos, rx686_eos, rx686_done
    set rx686_off, 0
    lt rx686_pos, 2, rx686_start
    sub rx686_off, rx686_pos, 1
    substr rx686_tgt, rx686_tgt, rx686_off
  rx686_start:
    eq $I10, 1, rx686_restart
    if_null rx686_debug, debug_852
    rx686_cur."!cursor_debug"("START", "variable")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan687_done
    goto rxscan687_scan
  rxscan687_loop:
    (rx686_pos) = rx686_cur."from"()
    inc rx686_pos
    rx686_cur."!cursor_from"(rx686_pos)
    ge rx686_pos, rx686_eos, rxscan687_done
  rxscan687_scan:
    set_addr $I10, rxscan687_loop
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
  rxscan687_done:
  alt688_0:
.annotate 'line', 297
    set_addr $I10, alt688_1
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
.annotate 'line', 298
  # rx subrule "sigil" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."sigil"()
    unless $P10, rx686_fail
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx686_pos = $P10."pos"()
  # rx rxquantr689 ** 0..1
    set_addr $I10, rxquantr689_done
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
  rxquantr689_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."twigil"()
    unless $P10, rx686_fail
    goto rxsubrule690_pass
  rxsubrule690_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx686_fail
  rxsubrule690_pass:
    set_addr $I10, rxsubrule690_back
    rx686_cur."!mark_push"(0, rx686_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx686_pos = $P10."pos"()
    set_addr $I10, rxquantr689_done
    (rx686_rep) = rx686_cur."!mark_commit"($I10)
  rxquantr689_done:
  # rx subrule "name" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."name"()
    unless $P10, rx686_fail
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx686_pos = $P10."pos"()
    goto alt688_end
  alt688_1:
    set_addr $I10, alt688_2
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
.annotate 'line', 299
  # rx subrule "sigil" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."sigil"()
    unless $P10, rx686_fail
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx686_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx686_pos, rx686_off
    substr $S10, rx686_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx686_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx686_cur."!cursor_pos"(rx686_pos)
    $P10 = rx686_cur."postcircumfix"()
    unless $P10, rx686_fail
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx686_pos = $P10."pos"()
    goto alt688_end
  alt688_2:
.annotate 'line', 300
  # rx subcapture "sigil"
    set_addr $I10, rxcap_691_fail
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
  # rx literal  "$"
    add $I11, rx686_pos, 1
    gt $I11, rx686_eos, rx686_fail
    sub $I11, rx686_pos, rx686_off
    ord $I11, rx686_tgt, $I11
    ne $I11, 36, rx686_fail
    add rx686_pos, 1
    set_addr $I10, rxcap_691_fail
    ($I12, $I11) = rx686_cur."!mark_peek"($I10)
    rx686_cur."!cursor_pos"($I11)
    ($P10) = rx686_cur."!cursor_start"()
    $P10."!cursor_pass"(rx686_pos, "")
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_691_done
  rxcap_691_fail:
    goto rx686_fail
  rxcap_691_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_692_fail
    rx686_cur."!mark_push"(0, rx686_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx686_pos, rx686_eos, rx686_fail
    sub $I10, rx686_pos, rx686_off
    substr $S10, rx686_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx686_fail
    inc rx686_pos
    set_addr $I10, rxcap_692_fail
    ($I12, $I11) = rx686_cur."!mark_peek"($I10)
    rx686_cur."!cursor_pos"($I11)
    ($P10) = rx686_cur."!cursor_start"()
    $P10."!cursor_pass"(rx686_pos, "")
    rx686_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_692_done
  rxcap_692_fail:
    goto rx686_fail
  rxcap_692_done:
  alt688_end:
.annotate 'line', 297
  # rx pass
    rx686_cur."!cursor_pass"(rx686_pos, "variable")
    if_null rx686_debug, debug_853
    rx686_cur."!cursor_debug"("PASS", "variable", " at pos=", rx686_pos)
  debug_853:
    .return (rx686_cur)
  rx686_restart:
.annotate 'line', 10
    if_null rx686_debug, debug_854
    rx686_cur."!cursor_debug"("NEXT", "variable")
  debug_854:
  rx686_fail:
    (rx686_rep, rx686_pos, $I10, $P10) = rx686_cur."!mark_fail"(0)
    lt rx686_pos, -1, rx686_done
    eq rx686_pos, -1, rx686_fail
    jump $I10
  rx686_done:
    rx686_cur."!cursor_fail"()
    if_null rx686_debug, debug_855
    rx686_cur."!cursor_debug"("FAIL", "variable")
  debug_855:
    .return (rx686_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :subid("133_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P694 = self."!PREFIX__!subrule"("sigil", "")
    $P695 = self."!PREFIX__!subrule"("sigil", "")
    new $P696, "ResizablePMCArray"
    push $P696, "/"
    push $P696, "_"
    push $P696, "!"
    push $P696, $P694
    push $P696, $P695
    .return ($P696)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("134_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx698_tgt
    .local int rx698_pos
    .local int rx698_off
    .local int rx698_eos
    .local int rx698_rep
    .local pmc rx698_cur
    .local pmc rx698_debug
    (rx698_cur, rx698_pos, rx698_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx698_cur
    .local pmc match
    .lex "$/", match
    length rx698_eos, rx698_tgt
    gt rx698_pos, rx698_eos, rx698_done
    set rx698_off, 0
    lt rx698_pos, 2, rx698_start
    sub rx698_off, rx698_pos, 1
    substr rx698_tgt, rx698_tgt, rx698_off
  rx698_start:
    eq $I10, 1, rx698_restart
    if_null rx698_debug, debug_856
    rx698_cur."!cursor_debug"("START", "sigil")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan699_done
    goto rxscan699_scan
  rxscan699_loop:
    (rx698_pos) = rx698_cur."from"()
    inc rx698_pos
    rx698_cur."!cursor_from"(rx698_pos)
    ge rx698_pos, rx698_eos, rxscan699_done
  rxscan699_scan:
    set_addr $I10, rxscan699_loop
    rx698_cur."!mark_push"(0, rx698_pos, $I10)
  rxscan699_done:
.annotate 'line', 303
  # rx enumcharlist negate=0 
    ge rx698_pos, rx698_eos, rx698_fail
    sub $I10, rx698_pos, rx698_off
    substr $S10, rx698_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx698_fail
    inc rx698_pos
  # rx pass
    rx698_cur."!cursor_pass"(rx698_pos, "sigil")
    if_null rx698_debug, debug_857
    rx698_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx698_pos)
  debug_857:
    .return (rx698_cur)
  rx698_restart:
.annotate 'line', 10
    if_null rx698_debug, debug_858
    rx698_cur."!cursor_debug"("NEXT", "sigil")
  debug_858:
  rx698_fail:
    (rx698_rep, rx698_pos, $I10, $P10) = rx698_cur."!mark_fail"(0)
    lt rx698_pos, -1, rx698_done
    eq rx698_pos, -1, rx698_fail
    jump $I10
  rx698_done:
    rx698_cur."!cursor_fail"()
    if_null rx698_debug, debug_859
    rx698_cur."!cursor_debug"("FAIL", "sigil")
  debug_859:
    .return (rx698_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :subid("135_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P701, "ResizablePMCArray"
    push $P701, "$"
    push $P701, "@"
    push $P701, "%"
    push $P701, "&"
    .return ($P701)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("136_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx703_tgt
    .local int rx703_pos
    .local int rx703_off
    .local int rx703_eos
    .local int rx703_rep
    .local pmc rx703_cur
    .local pmc rx703_debug
    (rx703_cur, rx703_pos, rx703_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx703_cur
    .local pmc match
    .lex "$/", match
    length rx703_eos, rx703_tgt
    gt rx703_pos, rx703_eos, rx703_done
    set rx703_off, 0
    lt rx703_pos, 2, rx703_start
    sub rx703_off, rx703_pos, 1
    substr rx703_tgt, rx703_tgt, rx703_off
  rx703_start:
    eq $I10, 1, rx703_restart
    if_null rx703_debug, debug_860
    rx703_cur."!cursor_debug"("START", "twigil")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan704_done
    goto rxscan704_scan
  rxscan704_loop:
    (rx703_pos) = rx703_cur."from"()
    inc rx703_pos
    rx703_cur."!cursor_from"(rx703_pos)
    ge rx703_pos, rx703_eos, rxscan704_done
  rxscan704_scan:
    set_addr $I10, rxscan704_loop
    rx703_cur."!mark_push"(0, rx703_pos, $I10)
  rxscan704_done:
.annotate 'line', 305
  # rx enumcharlist negate=0 
    ge rx703_pos, rx703_eos, rx703_fail
    sub $I10, rx703_pos, rx703_off
    substr $S10, rx703_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx703_fail
    inc rx703_pos
  # rx pass
    rx703_cur."!cursor_pass"(rx703_pos, "twigil")
    if_null rx703_debug, debug_861
    rx703_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx703_pos)
  debug_861:
    .return (rx703_cur)
  rx703_restart:
.annotate 'line', 10
    if_null rx703_debug, debug_862
    rx703_cur."!cursor_debug"("NEXT", "twigil")
  debug_862:
  rx703_fail:
    (rx703_rep, rx703_pos, $I10, $P10) = rx703_cur."!mark_fail"(0)
    lt rx703_pos, -1, rx703_done
    eq rx703_pos, -1, rx703_fail
    jump $I10
  rx703_done:
    rx703_cur."!cursor_fail"()
    if_null rx703_debug, debug_863
    rx703_cur."!cursor_debug"("FAIL", "twigil")
  debug_863:
    .return (rx703_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :subid("137_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P706, "ResizablePMCArray"
    push $P706, "*"
    push $P706, "!"
    push $P706, "?"
    .return ($P706)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("138_1304516047.681")
    .param pmc param_708
.annotate 'line', 307
    .lex "self", param_708
    $P709 = param_708."!protoregex"("package_declarator")
    .return ($P709)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("139_1304516047.681")
    .param pmc param_711
.annotate 'line', 307
    .lex "self", param_711
    $P712 = param_711."!PREFIX__!protoregex"("package_declarator")
    .return ($P712)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("140_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 309
    new $P714, "Undef"
    .lex "$*OUTERPACKAGE", $P714
.annotate 'line', 310
    new $P715, "Undef"
    .lex "$*PKGDECL", $P715
.annotate 'line', 10
    .local string rx716_tgt
    .local int rx716_pos
    .local int rx716_off
    .local int rx716_eos
    .local int rx716_rep
    .local pmc rx716_cur
    .local pmc rx716_debug
    (rx716_cur, rx716_pos, rx716_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx716_cur
    .local pmc match
    .lex "$/", match
    length rx716_eos, rx716_tgt
    gt rx716_pos, rx716_eos, rx716_done
    set rx716_off, 0
    lt rx716_pos, 2, rx716_start
    sub rx716_off, rx716_pos, 1
    substr rx716_tgt, rx716_tgt, rx716_off
  rx716_start:
    eq $I10, 1, rx716_restart
    if_null rx716_debug, debug_864
    rx716_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan717_done
    goto rxscan717_scan
  rxscan717_loop:
    (rx716_pos) = rx716_cur."from"()
    inc rx716_pos
    rx716_cur."!cursor_from"(rx716_pos)
    ge rx716_pos, rx716_eos, rxscan717_done
  rxscan717_scan:
    set_addr $I10, rxscan717_loop
    rx716_cur."!mark_push"(0, rx716_pos, $I10)
  rxscan717_done:
.annotate 'line', 309
    rx716_cur."!cursor_pos"(rx716_pos)
    find_dynamic_lex $P720, "$*PACKAGE"
    unless_null $P720, vivify_865
    get_hll_global $P718, "GLOBAL"
    get_who $P719, $P718
    set $P720, $P719["$PACKAGE"]
    unless_null $P720, vivify_866
    die "Contextual $*PACKAGE not found"
  vivify_866:
  vivify_865:
    store_lex "$*OUTERPACKAGE", $P720
.annotate 'line', 310
    rx716_cur."!cursor_pos"(rx716_pos)
    new $P721, "String"
    assign $P721, "module"
    store_lex "$*PKGDECL", $P721
.annotate 'line', 311
  # rx subcapture "sym"
    set_addr $I10, rxcap_722_fail
    rx716_cur."!mark_push"(0, rx716_pos, $I10)
  # rx literal  "module"
    add $I11, rx716_pos, 6
    gt $I11, rx716_eos, rx716_fail
    sub $I11, rx716_pos, rx716_off
    substr $S10, rx716_tgt, $I11, 6
    ne $S10, "module", rx716_fail
    add rx716_pos, 6
    set_addr $I10, rxcap_722_fail
    ($I12, $I11) = rx716_cur."!mark_peek"($I10)
    rx716_cur."!cursor_pos"($I11)
    ($P10) = rx716_cur."!cursor_start"()
    $P10."!cursor_pass"(rx716_pos, "")
    rx716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_722_done
  rxcap_722_fail:
    goto rx716_fail
  rxcap_722_done:
  # rx subrule "package_def" subtype=capture negate=
    rx716_cur."!cursor_pos"(rx716_pos)
    $P10 = rx716_cur."package_def"()
    unless $P10, rx716_fail
    rx716_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx716_pos = $P10."pos"()
.annotate 'line', 308
  # rx pass
    rx716_cur."!cursor_pass"(rx716_pos, "package_declarator:sym<module>")
    if_null rx716_debug, debug_867
    rx716_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx716_pos)
  debug_867:
    .return (rx716_cur)
  rx716_restart:
.annotate 'line', 10
    if_null rx716_debug, debug_868
    rx716_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_868:
  rx716_fail:
    (rx716_rep, rx716_pos, $I10, $P10) = rx716_cur."!mark_fail"(0)
    lt rx716_pos, -1, rx716_done
    eq rx716_pos, -1, rx716_fail
    jump $I10
  rx716_done:
    rx716_cur."!cursor_fail"()
    if_null rx716_debug, debug_869
    rx716_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_869:
    .return (rx716_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :subid("141_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P724 = self."!PREFIX__!subrule"("package_def", "module")
    new $P725, "ResizablePMCArray"
    push $P725, $P724
    .return ($P725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("142_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 314
    new $P727, "Undef"
    .lex "$*OUTERPACKAGE", $P727
.annotate 'line', 315
    new $P728, "Undef"
    .lex "$*PKGDECL", $P728
.annotate 'line', 10
    .local string rx729_tgt
    .local int rx729_pos
    .local int rx729_off
    .local int rx729_eos
    .local int rx729_rep
    .local pmc rx729_cur
    .local pmc rx729_debug
    (rx729_cur, rx729_pos, rx729_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx729_cur
    .local pmc match
    .lex "$/", match
    length rx729_eos, rx729_tgt
    gt rx729_pos, rx729_eos, rx729_done
    set rx729_off, 0
    lt rx729_pos, 2, rx729_start
    sub rx729_off, rx729_pos, 1
    substr rx729_tgt, rx729_tgt, rx729_off
  rx729_start:
    eq $I10, 1, rx729_restart
    if_null rx729_debug, debug_870
    rx729_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_870:
    $I10 = self.'from'()
    ne $I10, -1, rxscan730_done
    goto rxscan730_scan
  rxscan730_loop:
    (rx729_pos) = rx729_cur."from"()
    inc rx729_pos
    rx729_cur."!cursor_from"(rx729_pos)
    ge rx729_pos, rx729_eos, rxscan730_done
  rxscan730_scan:
    set_addr $I10, rxscan730_loop
    rx729_cur."!mark_push"(0, rx729_pos, $I10)
  rxscan730_done:
.annotate 'line', 314
    rx729_cur."!cursor_pos"(rx729_pos)
    find_dynamic_lex $P733, "$*PACKAGE"
    unless_null $P733, vivify_871
    get_hll_global $P731, "GLOBAL"
    get_who $P732, $P731
    set $P733, $P732["$PACKAGE"]
    unless_null $P733, vivify_872
    die "Contextual $*PACKAGE not found"
  vivify_872:
  vivify_871:
    store_lex "$*OUTERPACKAGE", $P733
.annotate 'line', 315
    rx729_cur."!cursor_pos"(rx729_pos)
    new $P734, "String"
    assign $P734, "knowhow"
    store_lex "$*PKGDECL", $P734
.annotate 'line', 316
  # rx subcapture "sym"
    set_addr $I10, rxcap_735_fail
    rx729_cur."!mark_push"(0, rx729_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx729_pos, 7
    gt $I11, rx729_eos, rx729_fail
    sub $I11, rx729_pos, rx729_off
    substr $S10, rx729_tgt, $I11, 7
    ne $S10, "knowhow", rx729_fail
    add rx729_pos, 7
    set_addr $I10, rxcap_735_fail
    ($I12, $I11) = rx729_cur."!mark_peek"($I10)
    rx729_cur."!cursor_pos"($I11)
    ($P10) = rx729_cur."!cursor_start"()
    $P10."!cursor_pass"(rx729_pos, "")
    rx729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_735_done
  rxcap_735_fail:
    goto rx729_fail
  rxcap_735_done:
  # rx subrule "package_def" subtype=capture negate=
    rx729_cur."!cursor_pos"(rx729_pos)
    $P10 = rx729_cur."package_def"()
    unless $P10, rx729_fail
    rx729_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx729_pos = $P10."pos"()
.annotate 'line', 313
  # rx pass
    rx729_cur."!cursor_pass"(rx729_pos, "package_declarator:sym<knowhow>")
    if_null rx729_debug, debug_873
    rx729_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx729_pos)
  debug_873:
    .return (rx729_cur)
  rx729_restart:
.annotate 'line', 10
    if_null rx729_debug, debug_874
    rx729_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_874:
  rx729_fail:
    (rx729_rep, rx729_pos, $I10, $P10) = rx729_cur."!mark_fail"(0)
    lt rx729_pos, -1, rx729_done
    eq rx729_pos, -1, rx729_fail
    jump $I10
  rx729_done:
    rx729_cur."!cursor_fail"()
    if_null rx729_debug, debug_875
    rx729_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_875:
    .return (rx729_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :subid("143_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P737 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P738, "ResizablePMCArray"
    push $P738, $P737
    .return ($P738)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("144_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 319
    new $P740, "Undef"
    .lex "$*OUTERPACKAGE", $P740
.annotate 'line', 320
    new $P741, "Undef"
    .lex "$*PKGDECL", $P741
.annotate 'line', 10
    .local string rx742_tgt
    .local int rx742_pos
    .local int rx742_off
    .local int rx742_eos
    .local int rx742_rep
    .local pmc rx742_cur
    .local pmc rx742_debug
    (rx742_cur, rx742_pos, rx742_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx742_cur
    .local pmc match
    .lex "$/", match
    length rx742_eos, rx742_tgt
    gt rx742_pos, rx742_eos, rx742_done
    set rx742_off, 0
    lt rx742_pos, 2, rx742_start
    sub rx742_off, rx742_pos, 1
    substr rx742_tgt, rx742_tgt, rx742_off
  rx742_start:
    eq $I10, 1, rx742_restart
    if_null rx742_debug, debug_876
    rx742_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan743_done
    goto rxscan743_scan
  rxscan743_loop:
    (rx742_pos) = rx742_cur."from"()
    inc rx742_pos
    rx742_cur."!cursor_from"(rx742_pos)
    ge rx742_pos, rx742_eos, rxscan743_done
  rxscan743_scan:
    set_addr $I10, rxscan743_loop
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  rxscan743_done:
.annotate 'line', 319
    rx742_cur."!cursor_pos"(rx742_pos)
    find_dynamic_lex $P746, "$*PACKAGE"
    unless_null $P746, vivify_877
    get_hll_global $P744, "GLOBAL"
    get_who $P745, $P744
    set $P746, $P745["$PACKAGE"]
    unless_null $P746, vivify_878
    die "Contextual $*PACKAGE not found"
  vivify_878:
  vivify_877:
    store_lex "$*OUTERPACKAGE", $P746
.annotate 'line', 320
    rx742_cur."!cursor_pos"(rx742_pos)
    new $P747, "String"
    assign $P747, "class"
    store_lex "$*PKGDECL", $P747
.annotate 'line', 321
  # rx subcapture "sym"
    set_addr $I10, rxcap_748_fail
    rx742_cur."!mark_push"(0, rx742_pos, $I10)
  # rx literal  "class"
    add $I11, rx742_pos, 5
    gt $I11, rx742_eos, rx742_fail
    sub $I11, rx742_pos, rx742_off
    substr $S10, rx742_tgt, $I11, 5
    ne $S10, "class", rx742_fail
    add rx742_pos, 5
    set_addr $I10, rxcap_748_fail
    ($I12, $I11) = rx742_cur."!mark_peek"($I10)
    rx742_cur."!cursor_pos"($I11)
    ($P10) = rx742_cur."!cursor_start"()
    $P10."!cursor_pass"(rx742_pos, "")
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_748_done
  rxcap_748_fail:
    goto rx742_fail
  rxcap_748_done:
  # rx subrule "package_def" subtype=capture negate=
    rx742_cur."!cursor_pos"(rx742_pos)
    $P10 = rx742_cur."package_def"()
    unless $P10, rx742_fail
    rx742_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx742_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx742_cur."!cursor_pass"(rx742_pos, "package_declarator:sym<class>")
    if_null rx742_debug, debug_879
    rx742_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx742_pos)
  debug_879:
    .return (rx742_cur)
  rx742_restart:
.annotate 'line', 10
    if_null rx742_debug, debug_880
    rx742_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_880:
  rx742_fail:
    (rx742_rep, rx742_pos, $I10, $P10) = rx742_cur."!mark_fail"(0)
    lt rx742_pos, -1, rx742_done
    eq rx742_pos, -1, rx742_fail
    jump $I10
  rx742_done:
    rx742_cur."!cursor_fail"()
    if_null rx742_debug, debug_881
    rx742_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_881:
    .return (rx742_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :subid("145_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P750 = self."!PREFIX__!subrule"("package_def", "class")
    new $P751, "ResizablePMCArray"
    push $P751, $P750
    .return ($P751)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("146_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 324
    new $P753, "Undef"
    .lex "$*OUTERPACKAGE", $P753
.annotate 'line', 325
    new $P754, "Undef"
    .lex "$*PKGDECL", $P754
.annotate 'line', 10
    .local string rx755_tgt
    .local int rx755_pos
    .local int rx755_off
    .local int rx755_eos
    .local int rx755_rep
    .local pmc rx755_cur
    .local pmc rx755_debug
    (rx755_cur, rx755_pos, rx755_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx755_cur
    .local pmc match
    .lex "$/", match
    length rx755_eos, rx755_tgt
    gt rx755_pos, rx755_eos, rx755_done
    set rx755_off, 0
    lt rx755_pos, 2, rx755_start
    sub rx755_off, rx755_pos, 1
    substr rx755_tgt, rx755_tgt, rx755_off
  rx755_start:
    eq $I10, 1, rx755_restart
    if_null rx755_debug, debug_882
    rx755_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_882:
    $I10 = self.'from'()
    ne $I10, -1, rxscan756_done
    goto rxscan756_scan
  rxscan756_loop:
    (rx755_pos) = rx755_cur."from"()
    inc rx755_pos
    rx755_cur."!cursor_from"(rx755_pos)
    ge rx755_pos, rx755_eos, rxscan756_done
  rxscan756_scan:
    set_addr $I10, rxscan756_loop
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  rxscan756_done:
.annotate 'line', 324
    rx755_cur."!cursor_pos"(rx755_pos)
    find_dynamic_lex $P759, "$*PACKAGE"
    unless_null $P759, vivify_883
    get_hll_global $P757, "GLOBAL"
    get_who $P758, $P757
    set $P759, $P758["$PACKAGE"]
    unless_null $P759, vivify_884
    die "Contextual $*PACKAGE not found"
  vivify_884:
  vivify_883:
    store_lex "$*OUTERPACKAGE", $P759
.annotate 'line', 325
    rx755_cur."!cursor_pos"(rx755_pos)
    new $P760, "String"
    assign $P760, "grammar"
    store_lex "$*PKGDECL", $P760
.annotate 'line', 326
  # rx subcapture "sym"
    set_addr $I10, rxcap_761_fail
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx755_pos, 7
    gt $I11, rx755_eos, rx755_fail
    sub $I11, rx755_pos, rx755_off
    substr $S10, rx755_tgt, $I11, 7
    ne $S10, "grammar", rx755_fail
    add rx755_pos, 7
    set_addr $I10, rxcap_761_fail
    ($I12, $I11) = rx755_cur."!mark_peek"($I10)
    rx755_cur."!cursor_pos"($I11)
    ($P10) = rx755_cur."!cursor_start"()
    $P10."!cursor_pass"(rx755_pos, "")
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_761_done
  rxcap_761_fail:
    goto rx755_fail
  rxcap_761_done:
  # rx subrule "package_def" subtype=capture negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."package_def"()
    unless $P10, rx755_fail
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx755_pos = $P10."pos"()
.annotate 'line', 323
  # rx pass
    rx755_cur."!cursor_pass"(rx755_pos, "package_declarator:sym<grammar>")
    if_null rx755_debug, debug_885
    rx755_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx755_pos)
  debug_885:
    .return (rx755_cur)
  rx755_restart:
.annotate 'line', 10
    if_null rx755_debug, debug_886
    rx755_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_886:
  rx755_fail:
    (rx755_rep, rx755_pos, $I10, $P10) = rx755_cur."!mark_fail"(0)
    lt rx755_pos, -1, rx755_done
    eq rx755_pos, -1, rx755_fail
    jump $I10
  rx755_done:
    rx755_cur."!cursor_fail"()
    if_null rx755_debug, debug_887
    rx755_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_887:
    .return (rx755_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :subid("147_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P763 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P764, "ResizablePMCArray"
    push $P764, $P763
    .return ($P764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("148_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 329
    new $P766, "Undef"
    .lex "$*OUTERPACKAGE", $P766
.annotate 'line', 330
    new $P767, "Undef"
    .lex "$*PKGDECL", $P767
.annotate 'line', 10
    .local string rx768_tgt
    .local int rx768_pos
    .local int rx768_off
    .local int rx768_eos
    .local int rx768_rep
    .local pmc rx768_cur
    .local pmc rx768_debug
    (rx768_cur, rx768_pos, rx768_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx768_cur
    .local pmc match
    .lex "$/", match
    length rx768_eos, rx768_tgt
    gt rx768_pos, rx768_eos, rx768_done
    set rx768_off, 0
    lt rx768_pos, 2, rx768_start
    sub rx768_off, rx768_pos, 1
    substr rx768_tgt, rx768_tgt, rx768_off
  rx768_start:
    eq $I10, 1, rx768_restart
    if_null rx768_debug, debug_888
    rx768_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan769_done
    goto rxscan769_scan
  rxscan769_loop:
    (rx768_pos) = rx768_cur."from"()
    inc rx768_pos
    rx768_cur."!cursor_from"(rx768_pos)
    ge rx768_pos, rx768_eos, rxscan769_done
  rxscan769_scan:
    set_addr $I10, rxscan769_loop
    rx768_cur."!mark_push"(0, rx768_pos, $I10)
  rxscan769_done:
.annotate 'line', 329
    rx768_cur."!cursor_pos"(rx768_pos)
    find_dynamic_lex $P772, "$*PACKAGE"
    unless_null $P772, vivify_889
    get_hll_global $P770, "GLOBAL"
    get_who $P771, $P770
    set $P772, $P771["$PACKAGE"]
    unless_null $P772, vivify_890
    die "Contextual $*PACKAGE not found"
  vivify_890:
  vivify_889:
    store_lex "$*OUTERPACKAGE", $P772
.annotate 'line', 330
    rx768_cur."!cursor_pos"(rx768_pos)
    new $P773, "String"
    assign $P773, "role"
    store_lex "$*PKGDECL", $P773
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_774_fail
    rx768_cur."!mark_push"(0, rx768_pos, $I10)
  # rx literal  "role"
    add $I11, rx768_pos, 4
    gt $I11, rx768_eos, rx768_fail
    sub $I11, rx768_pos, rx768_off
    substr $S10, rx768_tgt, $I11, 4
    ne $S10, "role", rx768_fail
    add rx768_pos, 4
    set_addr $I10, rxcap_774_fail
    ($I12, $I11) = rx768_cur."!mark_peek"($I10)
    rx768_cur."!cursor_pos"($I11)
    ($P10) = rx768_cur."!cursor_start"()
    $P10."!cursor_pass"(rx768_pos, "")
    rx768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_774_done
  rxcap_774_fail:
    goto rx768_fail
  rxcap_774_done:
  # rx subrule "package_def" subtype=capture negate=
    rx768_cur."!cursor_pos"(rx768_pos)
    $P10 = rx768_cur."package_def"()
    unless $P10, rx768_fail
    rx768_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx768_pos = $P10."pos"()
.annotate 'line', 328
  # rx pass
    rx768_cur."!cursor_pass"(rx768_pos, "package_declarator:sym<role>")
    if_null rx768_debug, debug_891
    rx768_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx768_pos)
  debug_891:
    .return (rx768_cur)
  rx768_restart:
.annotate 'line', 10
    if_null rx768_debug, debug_892
    rx768_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_892:
  rx768_fail:
    (rx768_rep, rx768_pos, $I10, $P10) = rx768_cur."!mark_fail"(0)
    lt rx768_pos, -1, rx768_done
    eq rx768_pos, -1, rx768_fail
    jump $I10
  rx768_done:
    rx768_cur."!cursor_fail"()
    if_null rx768_debug, debug_893
    rx768_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_893:
    .return (rx768_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :subid("149_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P776 = self."!PREFIX__!subrule"("package_def", "role")
    new $P777, "ResizablePMCArray"
    push $P777, $P776
    .return ($P777)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("150_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 334
    new $P779, "Undef"
    .lex "$*OUTERPACKAGE", $P779
.annotate 'line', 335
    new $P780, "Undef"
    .lex "$*PKGDECL", $P780
.annotate 'line', 10
    .local string rx781_tgt
    .local int rx781_pos
    .local int rx781_off
    .local int rx781_eos
    .local int rx781_rep
    .local pmc rx781_cur
    .local pmc rx781_debug
    (rx781_cur, rx781_pos, rx781_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx781_cur
    .local pmc match
    .lex "$/", match
    length rx781_eos, rx781_tgt
    gt rx781_pos, rx781_eos, rx781_done
    set rx781_off, 0
    lt rx781_pos, 2, rx781_start
    sub rx781_off, rx781_pos, 1
    substr rx781_tgt, rx781_tgt, rx781_off
  rx781_start:
    eq $I10, 1, rx781_restart
    if_null rx781_debug, debug_894
    rx781_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_894:
    $I10 = self.'from'()
    ne $I10, -1, rxscan782_done
    goto rxscan782_scan
  rxscan782_loop:
    (rx781_pos) = rx781_cur."from"()
    inc rx781_pos
    rx781_cur."!cursor_from"(rx781_pos)
    ge rx781_pos, rx781_eos, rxscan782_done
  rxscan782_scan:
    set_addr $I10, rxscan782_loop
    rx781_cur."!mark_push"(0, rx781_pos, $I10)
  rxscan782_done:
.annotate 'line', 334
    rx781_cur."!cursor_pos"(rx781_pos)
    find_dynamic_lex $P785, "$*PACKAGE"
    unless_null $P785, vivify_895
    get_hll_global $P783, "GLOBAL"
    get_who $P784, $P783
    set $P785, $P784["$PACKAGE"]
    unless_null $P785, vivify_896
    die "Contextual $*PACKAGE not found"
  vivify_896:
  vivify_895:
    store_lex "$*OUTERPACKAGE", $P785
.annotate 'line', 335
    rx781_cur."!cursor_pos"(rx781_pos)
    new $P786, "String"
    assign $P786, "native"
    store_lex "$*PKGDECL", $P786
.annotate 'line', 336
  # rx subcapture "sym"
    set_addr $I10, rxcap_787_fail
    rx781_cur."!mark_push"(0, rx781_pos, $I10)
  # rx literal  "native"
    add $I11, rx781_pos, 6
    gt $I11, rx781_eos, rx781_fail
    sub $I11, rx781_pos, rx781_off
    substr $S10, rx781_tgt, $I11, 6
    ne $S10, "native", rx781_fail
    add rx781_pos, 6
    set_addr $I10, rxcap_787_fail
    ($I12, $I11) = rx781_cur."!mark_peek"($I10)
    rx781_cur."!cursor_pos"($I11)
    ($P10) = rx781_cur."!cursor_start"()
    $P10."!cursor_pass"(rx781_pos, "")
    rx781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_787_done
  rxcap_787_fail:
    goto rx781_fail
  rxcap_787_done:
  # rx subrule "package_def" subtype=capture negate=
    rx781_cur."!cursor_pos"(rx781_pos)
    $P10 = rx781_cur."package_def"()
    unless $P10, rx781_fail
    rx781_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx781_pos = $P10."pos"()
.annotate 'line', 333
  # rx pass
    rx781_cur."!cursor_pass"(rx781_pos, "package_declarator:sym<native>")
    if_null rx781_debug, debug_897
    rx781_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx781_pos)
  debug_897:
    .return (rx781_cur)
  rx781_restart:
.annotate 'line', 10
    if_null rx781_debug, debug_898
    rx781_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_898:
  rx781_fail:
    (rx781_rep, rx781_pos, $I10, $P10) = rx781_cur."!mark_fail"(0)
    lt rx781_pos, -1, rx781_done
    eq rx781_pos, -1, rx781_fail
    jump $I10
  rx781_done:
    rx781_cur."!cursor_fail"()
    if_null rx781_debug, debug_899
    rx781_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_899:
    .return (rx781_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :subid("151_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P789 = self."!PREFIX__!subrule"("package_def", "native")
    new $P790, "ResizablePMCArray"
    push $P790, $P789
    .return ($P790)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("152_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P816 = "153_1304516047.681" 
    capture_lex $P816
.annotate 'line', 340
    new $P792, "Undef"
    .lex "$*PACKAGE", $P792
.annotate 'line', 341
    $P793 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P793
.annotate 'line', 10
    .local string rx794_tgt
    .local int rx794_pos
    .local int rx794_off
    .local int rx794_eos
    .local int rx794_rep
    .local pmc rx794_cur
    .local pmc rx794_debug
    (rx794_cur, rx794_pos, rx794_tgt, $I10) = self."!cursor_start"()
    rx794_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx794_cur
    .local pmc match
    .lex "$/", match
    length rx794_eos, rx794_tgt
    gt rx794_pos, rx794_eos, rx794_done
    set rx794_off, 0
    lt rx794_pos, 2, rx794_start
    sub rx794_off, rx794_pos, 1
    substr rx794_tgt, rx794_tgt, rx794_off
  rx794_start:
    eq $I10, 1, rx794_restart
    if_null rx794_debug, debug_900
    rx794_cur."!cursor_debug"("START", "package_def")
  debug_900:
    $I10 = self.'from'()
    ne $I10, -1, rxscan795_done
    goto rxscan795_scan
  rxscan795_loop:
    (rx794_pos) = rx794_cur."from"()
    inc rx794_pos
    rx794_cur."!cursor_from"(rx794_pos)
    ge rx794_pos, rx794_eos, rxscan795_done
  rxscan795_scan:
    set_addr $I10, rxscan795_loop
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxscan795_done:
.annotate 'line', 339
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 340
    rx794_cur."!cursor_pos"(rx794_pos)
    find_lex $P799, "$*PACKAGE"
    unless_null $P799, vivify_901
    get_hll_global $P797, "GLOBAL"
    get_who $P798, $P797
    set $P799, $P798["$PACKAGE"]
    unless_null $P799, vivify_902
    die "Contextual $*PACKAGE not found"
  vivify_902:
  vivify_901:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 341
    rx794_cur."!cursor_pos"(rx794_pos)
    find_lex $P803, "%*ATTR-CHECK"
    unless_null $P803, vivify_903
    get_hll_global $P801, "GLOBAL"
    get_who $P802, $P801
    set $P803, $P802["%ATTR-CHECK"]
    unless_null $P803, vivify_904
    die "Contextual %*ATTR-CHECK not found"
  vivify_904:
  vivify_903:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 343
  # rx subrule "name" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."name"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 344
  # rx rxquantr806 ** 0..1
    set_addr $I10, rxquantr806_done
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxquantr806_loop:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx794_pos, 2
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 2
    ne $S10, "is", rx794_fail
    add rx794_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx794_pos, 5
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 5
    ne $S10, "repr(", rx794_fail
    add rx794_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."quote_EXPR"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx794_pos, 1
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    ord $I11, rx794_tgt, $I11
    ne $I11, 41, rx794_fail
    add rx794_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    set_addr $I10, rxquantr806_done
    (rx794_rep) = rx794_cur."!mark_commit"($I10)
  rxquantr806_done:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 346
    rx794_cur."!cursor_pos"(rx794_pos)
    find_lex $P813, unicode:"$\x{a2}"
    $P814 = $P813."MATCH"()
    store_lex "$/", $P814
    .const 'Sub' $P816 = "153_1304516047.681" 
    capture_lex $P816
    $P938 = $P816()
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 374
  # rx rxquantr940 ** 0..1
    set_addr $I10, rxquantr940_done
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxquantr940_loop:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx794_pos, 2
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 2
    ne $S10, "is", rx794_fail
    add rx794_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."name"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    set_addr $I10, rxquantr940_done
    (rx794_rep) = rx794_cur."!mark_commit"($I10)
  rxquantr940_done:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 375
  # rx rxquantr945 ** 0..*
    set_addr $I10, rxquantr945_done
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
  rxquantr945_loop:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx794_pos, 4
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I11, 4
    ne $S10, "does", rx794_fail
    add rx794_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."name"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    set_addr $I10, rxquantr945_done
    (rx794_rep) = rx794_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr945_done
    rx794_cur."!mark_push"(rx794_rep, rx794_pos, $I10)
    goto rxquantr945_loop
  rxquantr945_done:
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  alt950_0:
.annotate 'line', 376
    set_addr $I10, alt950_1
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
.annotate 'line', 377
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx794_pos, 1
    gt $I11, rx794_eos, rx794_fail
    sub $I11, rx794_pos, rx794_off
    ord $I11, rx794_tgt, $I11
    ne $I11, 59, rx794_fail
    add rx794_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."comp_unit"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    goto alt950_end
  alt950_1:
    set_addr $I10, alt950_2
    rx794_cur."!mark_push"(0, rx794_pos, $I10)
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx794_pos, rx794_off
    substr $S10, rx794_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx794_fail
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."block"()
    unless $P10, rx794_fail
    rx794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
    goto alt950_end
  alt950_2:
.annotate 'line', 379
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."panic"("Malformed package declaration")
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
  alt950_end:
.annotate 'line', 380
  # rx subrule "ws" subtype=method negate=
    rx794_cur."!cursor_pos"(rx794_pos)
    $P10 = rx794_cur."ws"()
    unless $P10, rx794_fail
    rx794_pos = $P10."pos"()
.annotate 'line', 339
  # rx pass
    rx794_cur."!cursor_pass"(rx794_pos, "package_def")
    if_null rx794_debug, debug_972
    rx794_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx794_pos)
  debug_972:
    .return (rx794_cur)
  rx794_restart:
.annotate 'line', 10
    if_null rx794_debug, debug_973
    rx794_cur."!cursor_debug"("NEXT", "package_def")
  debug_973:
  rx794_fail:
    (rx794_rep, rx794_pos, $I10, $P10) = rx794_cur."!mark_fail"(0)
    lt rx794_pos, -1, rx794_done
    eq rx794_pos, -1, rx794_fail
    jump $I10
  rx794_done:
    rx794_cur."!cursor_fail"()
    if_null rx794_debug, debug_974
    rx794_cur."!cursor_debug"("FAIL", "package_def")
  debug_974:
    .return (rx794_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block815"  :anon :subid("153_1304516047.681") :outer("152_1304516047.681")
.annotate 'line', 349
    $P817 = root_new ['parrot';'Hash']
    .lex "%args", $P817
.annotate 'line', 346
    find_lex $P818, "%args"
    unless_null $P818, vivify_905
    $P818 = root_new ['parrot';'Hash']
  vivify_905:
.annotate 'line', 350
    find_lex $P819, "$/"
    unless_null $P819, vivify_906
    $P819 = root_new ['parrot';'Hash']
  vivify_906:
    set $P820, $P819["name"]
    unless_null $P820, vivify_907
    new $P820, "Undef"
  vivify_907:
    set $S821, $P820
    new $P822, 'String'
    set $P822, $S821
    find_lex $P823, "%args"
    unless_null $P823, vivify_908
    $P823 = root_new ['parrot';'Hash']
    store_lex "%args", $P823
  vivify_908:
    set $P823["name"], $P822
.annotate 'line', 351
    find_lex $P825, "$/"
    unless_null $P825, vivify_909
    $P825 = root_new ['parrot';'Hash']
  vivify_909:
    set $P826, $P825["repr"]
    unless_null $P826, vivify_910
    new $P826, "Undef"
  vivify_910:
    unless $P826, if_824_end
.annotate 'line', 352
    find_lex $P827, "$/"
    unless_null $P827, vivify_911
    $P827 = root_new ['parrot';'Hash']
  vivify_911:
    set $P828, $P827["repr"]
    unless_null $P828, vivify_912
    $P828 = root_new ['parrot';'ResizablePMCArray']
  vivify_912:
    set $P829, $P828[0]
    unless_null $P829, vivify_913
    $P829 = root_new ['parrot';'Hash']
  vivify_913:
    set $P830, $P829["quote_delimited"]
    unless_null $P830, vivify_914
    $P830 = root_new ['parrot';'Hash']
  vivify_914:
    set $P831, $P830["quote_atom"]
    unless_null $P831, vivify_915
    $P831 = root_new ['parrot';'ResizablePMCArray']
  vivify_915:
    set $P832, $P831[0]
    unless_null $P832, vivify_916
    new $P832, "Undef"
  vivify_916:
    set $S833, $P832
    new $P834, 'String'
    set $P834, $S833
    find_lex $P835, "%args"
    unless_null $P835, vivify_917
    $P835 = root_new ['parrot';'Hash']
    store_lex "%args", $P835
  vivify_917:
    set $P835["repr"], $P834
  if_824_end:
.annotate 'line', 354
    find_dynamic_lex $P838, "$*SC"
    unless_null $P838, vivify_918
    get_hll_global $P836, "GLOBAL"
    get_who $P837, $P836
    set $P838, $P837["$SC"]
    unless_null $P838, vivify_919
    die "Contextual $*SC not found"
  vivify_919:
  vivify_918:
    find_dynamic_lex $P841, "$*PKGDECL"
    unless_null $P841, vivify_920
    get_hll_global $P839, "GLOBAL"
    get_who $P840, $P839
    set $P841, $P840["$PKGDECL"]
    unless_null $P841, vivify_921
    die "Contextual $*PKGDECL not found"
  vivify_921:
  vivify_920:
    find_dynamic_lex $P844, "%*HOW"
    unless_null $P844, vivify_922
    get_hll_global $P842, "GLOBAL"
    get_who $P843, $P842
    set $P844, $P843["%HOW"]
    unless_null $P844, vivify_923
    die "Contextual %*HOW not found"
  vivify_923:
  vivify_922:
    set $P845, $P844[$P841]
    unless_null $P845, vivify_924
    new $P845, "Undef"
  vivify_924:
    find_lex $P846, "%args"
    unless_null $P846, vivify_925
    $P846 = root_new ['parrot';'Hash']
  vivify_925:
    $P847 = $P838."pkg_create_mo"($P845, $P846 :flat)
    store_dynamic_lex "$*PACKAGE", $P847
.annotate 'line', 357
    find_dynamic_lex $P854, "$*SCOPE"
    unless_null $P854, vivify_926
    get_hll_global $P852, "GLOBAL"
    get_who $P853, $P852
    set $P854, $P853["$SCOPE"]
    unless_null $P854, vivify_927
    die "Contextual $*SCOPE not found"
  vivify_927:
  vivify_926:
    set $S855, $P854
    iseq $I856, $S855, "our"
    unless $I856, unless_851
    new $P850, 'Integer'
    set $P850, $I856
    goto unless_851_end
  unless_851:
    find_dynamic_lex $P859, "$*SCOPE"
    unless_null $P859, vivify_928
    get_hll_global $P857, "GLOBAL"
    get_who $P858, $P857
    set $P859, $P858["$SCOPE"]
    unless_null $P859, vivify_929
    die "Contextual $*SCOPE not found"
  vivify_929:
  vivify_928:
    set $S860, $P859
    iseq $I861, $S860, ""
    new $P850, 'Integer'
    set $P850, $I861
  unless_851_end:
    if $P850, if_849
.annotate 'line', 363
    find_dynamic_lex $P902, "$*SCOPE"
    unless_null $P902, vivify_930
    get_hll_global $P900, "GLOBAL"
    get_who $P901, $P900
    set $P902, $P901["$SCOPE"]
    unless_null $P902, vivify_931
    die "Contextual $*SCOPE not found"
  vivify_931:
  vivify_930:
    set $S903, $P902
    iseq $I904, $S903, "my"
    if $I904, if_899
.annotate 'line', 370
    find_lex $P931, "$/"
    unless_null $P931, vivify_932
    new $P931, "Undef"
  vivify_932:
    $P932 = $P931."CURSOR"()
    find_dynamic_lex $P935, "$*SCOPE"
    unless_null $P935, vivify_933
    get_hll_global $P933, "GLOBAL"
    get_who $P934, $P933
    set $P935, $P934["$SCOPE"]
    unless_null $P935, vivify_934
    die "Contextual $*SCOPE not found"
  vivify_934:
  vivify_933:
    concat $P936, $P935, " scoped packages are not supported"
    $P937 = $P932."panic"($P936)
.annotate 'line', 369
    set $P898, $P937
.annotate 'line', 363
    goto if_899_end
  if_899:
.annotate 'line', 364
    find_lex $P906, "$/"
    unless_null $P906, vivify_935
    $P906 = root_new ['parrot';'Hash']
  vivify_935:
    set $P907, $P906["name"]
    unless_null $P907, vivify_936
    $P907 = root_new ['parrot';'Hash']
  vivify_936:
    set $P908, $P907["identifier"]
    unless_null $P908, vivify_937
    new $P908, "Undef"
  vivify_937:
    set $N909, $P908
    isne $I910, $N909, 1.0
    unless $I910, if_905_end
.annotate 'line', 365
    find_lex $P911, "$/"
    unless_null $P911, vivify_938
    $P911 = root_new ['parrot';'Hash']
  vivify_938:
    set $P912, $P911["name"]
    unless_null $P912, vivify_939
    new $P912, "Undef"
  vivify_939:
    $P913 = $P912."CURSOR"()
    $P913."panic"("A my scoped package cannot have a multi-part name yet")
  if_905_end:
.annotate 'line', 367
    find_dynamic_lex $P916, "$*SC"
    unless_null $P916, vivify_940
    get_hll_global $P914, "GLOBAL"
    get_who $P915, $P914
    set $P916, $P915["$SC"]
    unless_null $P916, vivify_941
    die "Contextual $*SC not found"
  vivify_941:
  vivify_940:
    get_hll_global $P917, "GLOBAL"
    nqp_get_package_through_who $P918, $P917, "NQP"
    nqp_get_package_through_who $P919, $P918, "Actions"
    get_who $P920, $P919
    set $P921, $P920["@BLOCK"]
    unless_null $P921, vivify_942
    $P921 = root_new ['parrot';'ResizablePMCArray']
  vivify_942:
    set $P922, $P921[0]
    unless_null $P922, vivify_943
    new $P922, "Undef"
  vivify_943:
    find_lex $P923, "$/"
    unless_null $P923, vivify_944
    $P923 = root_new ['parrot';'Hash']
  vivify_944:
    set $P924, $P923["name"]
    unless_null $P924, vivify_945
    $P924 = root_new ['parrot';'Hash']
  vivify_945:
    set $P925, $P924["identifier"]
    unless_null $P925, vivify_946
    $P925 = root_new ['parrot';'ResizablePMCArray']
  vivify_946:
    set $P926, $P925[0]
    unless_null $P926, vivify_947
    new $P926, "Undef"
  vivify_947:
    find_dynamic_lex $P929, "$*PACKAGE"
    unless_null $P929, vivify_948
    get_hll_global $P927, "GLOBAL"
    get_who $P928, $P927
    set $P929, $P928["$PACKAGE"]
    unless_null $P929, vivify_949
    die "Contextual $*PACKAGE not found"
  vivify_949:
  vivify_948:
    $P930 = $P916."install_lexical_symbol"($P922, $P926, $P929)
.annotate 'line', 363
    set $P898, $P930
  if_899_end:
    set $P848, $P898
.annotate 'line', 357
    goto if_849_end
  if_849:
.annotate 'line', 358
    find_dynamic_lex $P864, "$*SC"
    unless_null $P864, vivify_950
    get_hll_global $P862, "GLOBAL"
    get_who $P863, $P862
    set $P864, $P863["$SC"]
    unless_null $P864, vivify_951
    die "Contextual $*SC not found"
  vivify_951:
  vivify_950:
    find_dynamic_lex $P867, "$*OUTERPACKAGE"
    unless_null $P867, vivify_952
    get_hll_global $P865, "GLOBAL"
    get_who $P866, $P865
    set $P867, $P866["$OUTERPACKAGE"]
    unless_null $P867, vivify_953
    die "Contextual $*OUTERPACKAGE not found"
  vivify_953:
  vivify_952:
    find_lex $P868, "$/"
    unless_null $P868, vivify_954
    $P868 = root_new ['parrot';'Hash']
  vivify_954:
    set $P869, $P868["name"]
    unless_null $P869, vivify_955
    $P869 = root_new ['parrot';'Hash']
  vivify_955:
    set $P870, $P869["identifier"]
    unless_null $P870, vivify_956
    new $P870, "Undef"
  vivify_956:
    find_dynamic_lex $P873, "$*PACKAGE"
    unless_null $P873, vivify_957
    get_hll_global $P871, "GLOBAL"
    get_who $P872, $P871
    set $P873, $P872["$PACKAGE"]
    unless_null $P873, vivify_958
    die "Contextual $*PACKAGE not found"
  vivify_958:
  vivify_957:
    $P864."install_package_symbol"($P867, $P870, $P873)
.annotate 'line', 359
    find_lex $P876, "$/"
    unless_null $P876, vivify_959
    $P876 = root_new ['parrot';'Hash']
  vivify_959:
    set $P877, $P876["name"]
    unless_null $P877, vivify_960
    $P877 = root_new ['parrot';'Hash']
  vivify_960:
    set $P878, $P877["identifier"]
    unless_null $P878, vivify_961
    new $P878, "Undef"
  vivify_961:
    set $N879, $P878
    iseq $I880, $N879, 1.0
    if $I880, if_875
    new $P874, 'Integer'
    set $P874, $I880
    goto if_875_end
  if_875:
.annotate 'line', 360
    find_dynamic_lex $P883, "$*SC"
    unless_null $P883, vivify_962
    get_hll_global $P881, "GLOBAL"
    get_who $P882, $P881
    set $P883, $P882["$SC"]
    unless_null $P883, vivify_963
    die "Contextual $*SC not found"
  vivify_963:
  vivify_962:
    get_hll_global $P884, "GLOBAL"
    nqp_get_package_through_who $P885, $P884, "NQP"
    nqp_get_package_through_who $P886, $P885, "Actions"
    get_who $P887, $P886
    set $P888, $P887["@BLOCK"]
    unless_null $P888, vivify_964
    $P888 = root_new ['parrot';'ResizablePMCArray']
  vivify_964:
    set $P889, $P888[0]
    unless_null $P889, vivify_965
    new $P889, "Undef"
  vivify_965:
    find_lex $P890, "$/"
    unless_null $P890, vivify_966
    $P890 = root_new ['parrot';'Hash']
  vivify_966:
    set $P891, $P890["name"]
    unless_null $P891, vivify_967
    $P891 = root_new ['parrot';'Hash']
  vivify_967:
    set $P892, $P891["identifier"]
    unless_null $P892, vivify_968
    $P892 = root_new ['parrot';'ResizablePMCArray']
  vivify_968:
    set $P893, $P892[0]
    unless_null $P893, vivify_969
    new $P893, "Undef"
  vivify_969:
    find_dynamic_lex $P896, "$*PACKAGE"
    unless_null $P896, vivify_970
    get_hll_global $P894, "GLOBAL"
    get_who $P895, $P894
    set $P896, $P895["$PACKAGE"]
    unless_null $P896, vivify_971
    die "Contextual $*PACKAGE not found"
  vivify_971:
  vivify_970:
    $P897 = $P883."install_lexical_symbol"($P889, $P893, $P896)
.annotate 'line', 359
    set $P874, $P897
  if_875_end:
.annotate 'line', 357
    set $P848, $P874
  if_849_end:
.annotate 'line', 346
    .return ($P848)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :subid("154_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P961 = self."!PREFIX__!subrule"("ws", "")
    new $P962, "ResizablePMCArray"
    push $P962, $P961
    .return ($P962)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("155_1304516047.681")
    .param pmc param_964
.annotate 'line', 383
    .lex "self", param_964
    $P965 = param_964."!protoregex"("scope_declarator")
    .return ($P965)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("156_1304516047.681")
    .param pmc param_967
.annotate 'line', 383
    .lex "self", param_967
    $P968 = param_967."!PREFIX__!protoregex"("scope_declarator")
    .return ($P968)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("157_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx970_tgt
    .local int rx970_pos
    .local int rx970_off
    .local int rx970_eos
    .local int rx970_rep
    .local pmc rx970_cur
    .local pmc rx970_debug
    (rx970_cur, rx970_pos, rx970_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx970_cur
    .local pmc match
    .lex "$/", match
    length rx970_eos, rx970_tgt
    gt rx970_pos, rx970_eos, rx970_done
    set rx970_off, 0
    lt rx970_pos, 2, rx970_start
    sub rx970_off, rx970_pos, 1
    substr rx970_tgt, rx970_tgt, rx970_off
  rx970_start:
    eq $I10, 1, rx970_restart
    if_null rx970_debug, debug_975
    rx970_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan971_done
    goto rxscan971_scan
  rxscan971_loop:
    (rx970_pos) = rx970_cur."from"()
    inc rx970_pos
    rx970_cur."!cursor_from"(rx970_pos)
    ge rx970_pos, rx970_eos, rxscan971_done
  rxscan971_scan:
    set_addr $I10, rxscan971_loop
    rx970_cur."!mark_push"(0, rx970_pos, $I10)
  rxscan971_done:
.annotate 'line', 384
  # rx subcapture "sym"
    set_addr $I10, rxcap_972_fail
    rx970_cur."!mark_push"(0, rx970_pos, $I10)
  # rx literal  "my"
    add $I11, rx970_pos, 2
    gt $I11, rx970_eos, rx970_fail
    sub $I11, rx970_pos, rx970_off
    substr $S10, rx970_tgt, $I11, 2
    ne $S10, "my", rx970_fail
    add rx970_pos, 2
    set_addr $I10, rxcap_972_fail
    ($I12, $I11) = rx970_cur."!mark_peek"($I10)
    rx970_cur."!cursor_pos"($I11)
    ($P10) = rx970_cur."!cursor_start"()
    $P10."!cursor_pass"(rx970_pos, "")
    rx970_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_972_done
  rxcap_972_fail:
    goto rx970_fail
  rxcap_972_done:
  # rx subrule "scoped" subtype=capture negate=
    rx970_cur."!cursor_pos"(rx970_pos)
    $P10 = rx970_cur."scoped"("my")
    unless $P10, rx970_fail
    rx970_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx970_pos = $P10."pos"()
  # rx pass
    rx970_cur."!cursor_pass"(rx970_pos, "scope_declarator:sym<my>")
    if_null rx970_debug, debug_976
    rx970_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx970_pos)
  debug_976:
    .return (rx970_cur)
  rx970_restart:
.annotate 'line', 10
    if_null rx970_debug, debug_977
    rx970_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_977:
  rx970_fail:
    (rx970_rep, rx970_pos, $I10, $P10) = rx970_cur."!mark_fail"(0)
    lt rx970_pos, -1, rx970_done
    eq rx970_pos, -1, rx970_fail
    jump $I10
  rx970_done:
    rx970_cur."!cursor_fail"()
    if_null rx970_debug, debug_978
    rx970_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_978:
    .return (rx970_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :subid("158_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P974 = self."!PREFIX__!subrule"("scoped", "my")
    new $P975, "ResizablePMCArray"
    push $P975, $P974
    .return ($P975)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("159_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx977_tgt
    .local int rx977_pos
    .local int rx977_off
    .local int rx977_eos
    .local int rx977_rep
    .local pmc rx977_cur
    .local pmc rx977_debug
    (rx977_cur, rx977_pos, rx977_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx977_cur
    .local pmc match
    .lex "$/", match
    length rx977_eos, rx977_tgt
    gt rx977_pos, rx977_eos, rx977_done
    set rx977_off, 0
    lt rx977_pos, 2, rx977_start
    sub rx977_off, rx977_pos, 1
    substr rx977_tgt, rx977_tgt, rx977_off
  rx977_start:
    eq $I10, 1, rx977_restart
    if_null rx977_debug, debug_979
    rx977_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan978_done
    goto rxscan978_scan
  rxscan978_loop:
    (rx977_pos) = rx977_cur."from"()
    inc rx977_pos
    rx977_cur."!cursor_from"(rx977_pos)
    ge rx977_pos, rx977_eos, rxscan978_done
  rxscan978_scan:
    set_addr $I10, rxscan978_loop
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  rxscan978_done:
.annotate 'line', 385
  # rx subcapture "sym"
    set_addr $I10, rxcap_979_fail
    rx977_cur."!mark_push"(0, rx977_pos, $I10)
  # rx literal  "our"
    add $I11, rx977_pos, 3
    gt $I11, rx977_eos, rx977_fail
    sub $I11, rx977_pos, rx977_off
    substr $S10, rx977_tgt, $I11, 3
    ne $S10, "our", rx977_fail
    add rx977_pos, 3
    set_addr $I10, rxcap_979_fail
    ($I12, $I11) = rx977_cur."!mark_peek"($I10)
    rx977_cur."!cursor_pos"($I11)
    ($P10) = rx977_cur."!cursor_start"()
    $P10."!cursor_pass"(rx977_pos, "")
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_979_done
  rxcap_979_fail:
    goto rx977_fail
  rxcap_979_done:
  # rx subrule "scoped" subtype=capture negate=
    rx977_cur."!cursor_pos"(rx977_pos)
    $P10 = rx977_cur."scoped"("our")
    unless $P10, rx977_fail
    rx977_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx977_pos = $P10."pos"()
  # rx pass
    rx977_cur."!cursor_pass"(rx977_pos, "scope_declarator:sym<our>")
    if_null rx977_debug, debug_980
    rx977_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx977_pos)
  debug_980:
    .return (rx977_cur)
  rx977_restart:
.annotate 'line', 10
    if_null rx977_debug, debug_981
    rx977_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_981:
  rx977_fail:
    (rx977_rep, rx977_pos, $I10, $P10) = rx977_cur."!mark_fail"(0)
    lt rx977_pos, -1, rx977_done
    eq rx977_pos, -1, rx977_fail
    jump $I10
  rx977_done:
    rx977_cur."!cursor_fail"()
    if_null rx977_debug, debug_982
    rx977_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_982:
    .return (rx977_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :subid("160_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P981 = self."!PREFIX__!subrule"("scoped", "our")
    new $P982, "ResizablePMCArray"
    push $P982, $P981
    .return ($P982)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("161_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx984_tgt
    .local int rx984_pos
    .local int rx984_off
    .local int rx984_eos
    .local int rx984_rep
    .local pmc rx984_cur
    .local pmc rx984_debug
    (rx984_cur, rx984_pos, rx984_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx984_cur
    .local pmc match
    .lex "$/", match
    length rx984_eos, rx984_tgt
    gt rx984_pos, rx984_eos, rx984_done
    set rx984_off, 0
    lt rx984_pos, 2, rx984_start
    sub rx984_off, rx984_pos, 1
    substr rx984_tgt, rx984_tgt, rx984_off
  rx984_start:
    eq $I10, 1, rx984_restart
    if_null rx984_debug, debug_983
    rx984_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan985_done
    goto rxscan985_scan
  rxscan985_loop:
    (rx984_pos) = rx984_cur."from"()
    inc rx984_pos
    rx984_cur."!cursor_from"(rx984_pos)
    ge rx984_pos, rx984_eos, rxscan985_done
  rxscan985_scan:
    set_addr $I10, rxscan985_loop
    rx984_cur."!mark_push"(0, rx984_pos, $I10)
  rxscan985_done:
.annotate 'line', 386
  # rx subcapture "sym"
    set_addr $I10, rxcap_986_fail
    rx984_cur."!mark_push"(0, rx984_pos, $I10)
  # rx literal  "has"
    add $I11, rx984_pos, 3
    gt $I11, rx984_eos, rx984_fail
    sub $I11, rx984_pos, rx984_off
    substr $S10, rx984_tgt, $I11, 3
    ne $S10, "has", rx984_fail
    add rx984_pos, 3
    set_addr $I10, rxcap_986_fail
    ($I12, $I11) = rx984_cur."!mark_peek"($I10)
    rx984_cur."!cursor_pos"($I11)
    ($P10) = rx984_cur."!cursor_start"()
    $P10."!cursor_pass"(rx984_pos, "")
    rx984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_986_done
  rxcap_986_fail:
    goto rx984_fail
  rxcap_986_done:
  # rx subrule "scoped" subtype=capture negate=
    rx984_cur."!cursor_pos"(rx984_pos)
    $P10 = rx984_cur."scoped"("has")
    unless $P10, rx984_fail
    rx984_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx984_pos = $P10."pos"()
  # rx pass
    rx984_cur."!cursor_pass"(rx984_pos, "scope_declarator:sym<has>")
    if_null rx984_debug, debug_984
    rx984_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx984_pos)
  debug_984:
    .return (rx984_cur)
  rx984_restart:
.annotate 'line', 10
    if_null rx984_debug, debug_985
    rx984_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_985:
  rx984_fail:
    (rx984_rep, rx984_pos, $I10, $P10) = rx984_cur."!mark_fail"(0)
    lt rx984_pos, -1, rx984_done
    eq rx984_pos, -1, rx984_fail
    jump $I10
  rx984_done:
    rx984_cur."!cursor_fail"()
    if_null rx984_debug, debug_986
    rx984_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_986:
    .return (rx984_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :subid("162_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P988 = self."!PREFIX__!subrule"("scoped", "has")
    new $P989, "ResizablePMCArray"
    push $P989, $P988
    .return ($P989)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("163_1304516047.681") :method :outer("12_1304516047.681")
    .param pmc param_991
.annotate 'line', 388
    .lex "$*SCOPE", param_991
.annotate 'line', 10
    .local string rx992_tgt
    .local int rx992_pos
    .local int rx992_off
    .local int rx992_eos
    .local int rx992_rep
    .local pmc rx992_cur
    .local pmc rx992_debug
    (rx992_cur, rx992_pos, rx992_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx992_cur
    .local pmc match
    .lex "$/", match
    length rx992_eos, rx992_tgt
    gt rx992_pos, rx992_eos, rx992_done
    set rx992_off, 0
    lt rx992_pos, 2, rx992_start
    sub rx992_off, rx992_pos, 1
    substr rx992_tgt, rx992_tgt, rx992_off
  rx992_start:
    eq $I10, 1, rx992_restart
    if_null rx992_debug, debug_987
    rx992_cur."!cursor_debug"("START", "scoped")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan993_done
    goto rxscan993_scan
  rxscan993_loop:
    (rx992_pos) = rx992_cur."from"()
    inc rx992_pos
    rx992_cur."!cursor_from"(rx992_pos)
    ge rx992_pos, rx992_eos, rxscan993_done
  rxscan993_scan:
    set_addr $I10, rxscan993_loop
    rx992_cur."!mark_push"(0, rx992_pos, $I10)
  rxscan993_done:
  alt994_0:
.annotate 'line', 388
    set_addr $I10, alt994_1
    rx992_cur."!mark_push"(0, rx992_pos, $I10)
.annotate 'line', 389
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."declarator"()
    unless $P10, rx992_fail
    rx992_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx992_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
    goto alt994_end
  alt994_1:
    set_addr $I10, alt994_2
    rx992_cur."!mark_push"(0, rx992_pos, $I10)
.annotate 'line', 390
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."multi_declarator"()
    unless $P10, rx992_fail
    rx992_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx992_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
    goto alt994_end
  alt994_2:
.annotate 'line', 391
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."package_declarator"()
    unless $P10, rx992_fail
    rx992_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx992_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx992_cur."!cursor_pos"(rx992_pos)
    $P10 = rx992_cur."ws"()
    unless $P10, rx992_fail
    rx992_pos = $P10."pos"()
  alt994_end:
.annotate 'line', 388
  # rx pass
    rx992_cur."!cursor_pass"(rx992_pos, "scoped")
    if_null rx992_debug, debug_988
    rx992_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx992_pos)
  debug_988:
    .return (rx992_cur)
  rx992_restart:
.annotate 'line', 10
    if_null rx992_debug, debug_989
    rx992_cur."!cursor_debug"("NEXT", "scoped")
  debug_989:
  rx992_fail:
    (rx992_rep, rx992_pos, $I10, $P10) = rx992_cur."!mark_fail"(0)
    lt rx992_pos, -1, rx992_done
    eq rx992_pos, -1, rx992_fail
    jump $I10
  rx992_done:
    rx992_cur."!cursor_fail"()
    if_null rx992_debug, debug_990
    rx992_cur."!cursor_debug"("FAIL", "scoped")
  debug_990:
    .return (rx992_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :subid("164_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1002 = self."!PREFIX__!subrule"("ws", "")
    $P1003 = self."!PREFIX__!subrule"("ws", "")
    $P1004 = self."!PREFIX__!subrule"("ws", "")
    new $P1005, "ResizablePMCArray"
    push $P1005, $P1002
    push $P1005, $P1003
    push $P1005, $P1004
    .return ($P1005)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("165_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P1012 = "166_1304516047.681" 
    capture_lex $P1012
    .local string rx1007_tgt
    .local int rx1007_pos
    .local int rx1007_off
    .local int rx1007_eos
    .local int rx1007_rep
    .local pmc rx1007_cur
    .local pmc rx1007_debug
    (rx1007_cur, rx1007_pos, rx1007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1007_cur
    .local pmc match
    .lex "$/", match
    length rx1007_eos, rx1007_tgt
    gt rx1007_pos, rx1007_eos, rx1007_done
    set rx1007_off, 0
    lt rx1007_pos, 2, rx1007_start
    sub rx1007_off, rx1007_pos, 1
    substr rx1007_tgt, rx1007_tgt, rx1007_off
  rx1007_start:
    eq $I10, 1, rx1007_restart
    if_null rx1007_debug, debug_991
    rx1007_cur."!cursor_debug"("START", "typename")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1008_done
    goto rxscan1008_scan
  rxscan1008_loop:
    (rx1007_pos) = rx1007_cur."from"()
    inc rx1007_pos
    rx1007_cur."!cursor_from"(rx1007_pos)
    ge rx1007_pos, rx1007_eos, rxscan1008_done
  rxscan1008_scan:
    set_addr $I10, rxscan1008_loop
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  rxscan1008_done:
.annotate 'line', 395
  # rx subrule "name" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."name"()
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1007_pos = $P10."pos"()
.annotate 'line', 396
    rx1007_cur."!cursor_pos"(rx1007_pos)
    find_lex $P1009, unicode:"$\x{a2}"
    $P1010 = $P1009."MATCH"()
    store_lex "$/", $P1010
    .const 'Sub' $P1012 = "166_1304516047.681" 
    capture_lex $P1012
    $P1021 = $P1012()
    unless $P1021, rx1007_fail
.annotate 'line', 394
  # rx pass
    rx1007_cur."!cursor_pass"(rx1007_pos, "typename")
    if_null rx1007_debug, debug_998
    rx1007_cur."!cursor_debug"("PASS", "typename", " at pos=", rx1007_pos)
  debug_998:
    .return (rx1007_cur)
  rx1007_restart:
.annotate 'line', 10
    if_null rx1007_debug, debug_999
    rx1007_cur."!cursor_debug"("NEXT", "typename")
  debug_999:
  rx1007_fail:
    (rx1007_rep, rx1007_pos, $I10, $P10) = rx1007_cur."!mark_fail"(0)
    lt rx1007_pos, -1, rx1007_done
    eq rx1007_pos, -1, rx1007_fail
    jump $I10
  rx1007_done:
    rx1007_cur."!cursor_fail"()
    if_null rx1007_debug, debug_1000
    rx1007_cur."!cursor_debug"("FAIL", "typename")
  debug_1000:
    .return (rx1007_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1011"  :anon :subid("166_1304516047.681") :outer("165_1304516047.681")
.annotate 'line', 396
    find_dynamic_lex $P1015, "$*ACTIONS"
    unless_null $P1015, vivify_992
    get_hll_global $P1013, "GLOBAL"
    get_who $P1014, $P1013
    set $P1015, $P1014["$ACTIONS"]
    unless_null $P1015, vivify_993
    die "Contextual $*ACTIONS not found"
  vivify_993:
  vivify_992:
    find_lex $P1016, "$/"
    unless_null $P1016, vivify_994
    new $P1016, "Undef"
  vivify_994:
    find_lex $P1017, "$/"
    unless_null $P1017, vivify_995
    $P1017 = root_new ['parrot';'Hash']
  vivify_995:
    set $P1018, $P1017["name"]
    unless_null $P1018, vivify_996
    $P1018 = root_new ['parrot';'Hash']
  vivify_996:
    set $P1019, $P1018["identifier"]
    unless_null $P1019, vivify_997
    new $P1019, "Undef"
  vivify_997:
    $P1020 = $P1015."known_sym"($P1016, $P1019)
    .return ($P1020)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :subid("167_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1023 = self."!PREFIX__!subrule"("name", "")
    new $P1024, "ResizablePMCArray"
    push $P1024, $P1023
    .return ($P1024)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("168_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1026_tgt
    .local int rx1026_pos
    .local int rx1026_off
    .local int rx1026_eos
    .local int rx1026_rep
    .local pmc rx1026_cur
    .local pmc rx1026_debug
    (rx1026_cur, rx1026_pos, rx1026_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1026_cur
    .local pmc match
    .lex "$/", match
    length rx1026_eos, rx1026_tgt
    gt rx1026_pos, rx1026_eos, rx1026_done
    set rx1026_off, 0
    lt rx1026_pos, 2, rx1026_start
    sub rx1026_off, rx1026_pos, 1
    substr rx1026_tgt, rx1026_tgt, rx1026_off
  rx1026_start:
    eq $I10, 1, rx1026_restart
    if_null rx1026_debug, debug_1001
    rx1026_cur."!cursor_debug"("START", "declarator")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1027_done
    goto rxscan1027_scan
  rxscan1027_loop:
    (rx1026_pos) = rx1026_cur."from"()
    inc rx1026_pos
    rx1026_cur."!cursor_from"(rx1026_pos)
    ge rx1026_pos, rx1026_eos, rxscan1027_done
  rxscan1027_scan:
    set_addr $I10, rxscan1027_loop
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
  rxscan1027_done:
  alt1028_0:
.annotate 'line', 399
    set_addr $I10, alt1028_1
    rx1026_cur."!mark_push"(0, rx1026_pos, $I10)
.annotate 'line', 400
  # rx subrule "variable_declarator" subtype=capture negate=
    rx1026_cur."!cursor_pos"(rx1026_pos)
    $P10 = rx1026_cur."variable_declarator"()
    unless $P10, rx1026_fail
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx1026_pos = $P10."pos"()
    goto alt1028_end
  alt1028_1:
.annotate 'line', 401
  # rx subrule "routine_declarator" subtype=capture negate=
    rx1026_cur."!cursor_pos"(rx1026_pos)
    $P10 = rx1026_cur."routine_declarator"()
    unless $P10, rx1026_fail
    rx1026_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx1026_pos = $P10."pos"()
  alt1028_end:
.annotate 'line', 399
  # rx pass
    rx1026_cur."!cursor_pass"(rx1026_pos, "declarator")
    if_null rx1026_debug, debug_1002
    rx1026_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx1026_pos)
  debug_1002:
    .return (rx1026_cur)
  rx1026_restart:
.annotate 'line', 10
    if_null rx1026_debug, debug_1003
    rx1026_cur."!cursor_debug"("NEXT", "declarator")
  debug_1003:
  rx1026_fail:
    (rx1026_rep, rx1026_pos, $I10, $P10) = rx1026_cur."!mark_fail"(0)
    lt rx1026_pos, -1, rx1026_done
    eq rx1026_pos, -1, rx1026_fail
    jump $I10
  rx1026_done:
    rx1026_cur."!cursor_fail"()
    if_null rx1026_debug, debug_1004
    rx1026_cur."!cursor_debug"("FAIL", "declarator")
  debug_1004:
    .return (rx1026_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :subid("169_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1030 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P1031 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P1032, "ResizablePMCArray"
    push $P1032, $P1030
    push $P1032, $P1031
    .return ($P1032)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("170_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P1047 = "171_1304516047.681" 
    capture_lex $P1047
.annotate 'line', 406
    new $P1034, "Undef"
    .lex "$*IN_DECL", $P1034
.annotate 'line', 10
    .local string rx1035_tgt
    .local int rx1035_pos
    .local int rx1035_off
    .local int rx1035_eos
    .local int rx1035_rep
    .local pmc rx1035_cur
    .local pmc rx1035_debug
    (rx1035_cur, rx1035_pos, rx1035_tgt, $I10) = self."!cursor_start"()
    rx1035_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx1035_cur
    .local pmc match
    .lex "$/", match
    length rx1035_eos, rx1035_tgt
    gt rx1035_pos, rx1035_eos, rx1035_done
    set rx1035_off, 0
    lt rx1035_pos, 2, rx1035_start
    sub rx1035_off, rx1035_pos, 1
    substr rx1035_tgt, rx1035_tgt, rx1035_off
  rx1035_start:
    eq $I10, 1, rx1035_restart
    if_null rx1035_debug, debug_1005
    rx1035_cur."!cursor_debug"("START", "variable_declarator")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1036_done
    goto rxscan1036_scan
  rxscan1036_loop:
    (rx1035_pos) = rx1035_cur."from"()
    inc rx1035_pos
    rx1035_cur."!cursor_from"(rx1035_pos)
    ge rx1035_pos, rx1035_eos, rxscan1036_done
  rxscan1036_scan:
    set_addr $I10, rxscan1036_loop
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10)
  rxscan1036_done:
.annotate 'line', 404
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 405
  # rx rxquantr1038 ** 0..1
    set_addr $I10, rxquantr1038_done
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10)
  rxquantr1038_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."typename"()
    unless $P10, rx1035_fail
    goto rxsubrule1039_pass
  rxsubrule1039_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1035_fail
  rxsubrule1039_pass:
    set_addr $I10, rxsubrule1039_back
    rx1035_cur."!mark_push"(0, rx1035_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx1035_pos = $P10."pos"()
    set_addr $I10, rxquantr1038_done
    (rx1035_rep) = rx1035_cur."!mark_commit"($I10)
  rxquantr1038_done:
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 406
    rx1035_cur."!cursor_pos"(rx1035_pos)
    new $P1041, "String"
    assign $P1041, "variable"
    store_lex "$*IN_DECL", $P1041
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 407
  # rx subrule "variable" subtype=capture negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."variable"()
    unless $P10, rx1035_fail
    rx1035_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1035_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 408
    rx1035_cur."!cursor_pos"(rx1035_pos)
    find_lex $P1044, unicode:"$\x{a2}"
    $P1045 = $P1044."MATCH"()
    store_lex "$/", $P1045
    .const 'Sub' $P1047 = "171_1304516047.681" 
    capture_lex $P1047
    $P1049 = $P1047()
  # rx subrule "ws" subtype=method negate=
    rx1035_cur."!cursor_pos"(rx1035_pos)
    $P10 = rx1035_cur."ws"()
    unless $P10, rx1035_fail
    rx1035_pos = $P10."pos"()
.annotate 'line', 404
  # rx pass
    rx1035_cur."!cursor_pass"(rx1035_pos, "variable_declarator")
    if_null rx1035_debug, debug_1006
    rx1035_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx1035_pos)
  debug_1006:
    .return (rx1035_cur)
  rx1035_restart:
.annotate 'line', 10
    if_null rx1035_debug, debug_1007
    rx1035_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_1007:
  rx1035_fail:
    (rx1035_rep, rx1035_pos, $I10, $P10) = rx1035_cur."!mark_fail"(0)
    lt rx1035_pos, -1, rx1035_done
    eq rx1035_pos, -1, rx1035_fail
    jump $I10
  rx1035_done:
    rx1035_cur."!cursor_fail"()
    if_null rx1035_debug, debug_1008
    rx1035_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_1008:
    .return (rx1035_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1046"  :anon :subid("171_1304516047.681") :outer("170_1304516047.681")
.annotate 'line', 408
    new $P1048, "Integer"
    assign $P1048, 0
    store_dynamic_lex "$*IN_DECL", $P1048
    .return ($P1048)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :subid("172_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1052 = self."!PREFIX__!subrule"("ws", "")
    new $P1053, "ResizablePMCArray"
    push $P1053, $P1052
    .return ($P1053)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("173_1304516047.681")
    .param pmc param_1055
.annotate 'line', 411
    .lex "self", param_1055
    $P1056 = param_1055."!protoregex"("routine_declarator")
    .return ($P1056)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("174_1304516047.681")
    .param pmc param_1058
.annotate 'line', 411
    .lex "self", param_1058
    $P1059 = param_1058."!PREFIX__!protoregex"("routine_declarator")
    .return ($P1059)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("175_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1061_tgt
    .local int rx1061_pos
    .local int rx1061_off
    .local int rx1061_eos
    .local int rx1061_rep
    .local pmc rx1061_cur
    .local pmc rx1061_debug
    (rx1061_cur, rx1061_pos, rx1061_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1061_cur
    .local pmc match
    .lex "$/", match
    length rx1061_eos, rx1061_tgt
    gt rx1061_pos, rx1061_eos, rx1061_done
    set rx1061_off, 0
    lt rx1061_pos, 2, rx1061_start
    sub rx1061_off, rx1061_pos, 1
    substr rx1061_tgt, rx1061_tgt, rx1061_off
  rx1061_start:
    eq $I10, 1, rx1061_restart
    if_null rx1061_debug, debug_1009
    rx1061_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1062_done
    goto rxscan1062_scan
  rxscan1062_loop:
    (rx1061_pos) = rx1061_cur."from"()
    inc rx1061_pos
    rx1061_cur."!cursor_from"(rx1061_pos)
    ge rx1061_pos, rx1061_eos, rxscan1062_done
  rxscan1062_scan:
    set_addr $I10, rxscan1062_loop
    rx1061_cur."!mark_push"(0, rx1061_pos, $I10)
  rxscan1062_done:
.annotate 'line', 412
  # rx subcapture "sym"
    set_addr $I10, rxcap_1063_fail
    rx1061_cur."!mark_push"(0, rx1061_pos, $I10)
  # rx literal  "sub"
    add $I11, rx1061_pos, 3
    gt $I11, rx1061_eos, rx1061_fail
    sub $I11, rx1061_pos, rx1061_off
    substr $S10, rx1061_tgt, $I11, 3
    ne $S10, "sub", rx1061_fail
    add rx1061_pos, 3
    set_addr $I10, rxcap_1063_fail
    ($I12, $I11) = rx1061_cur."!mark_peek"($I10)
    rx1061_cur."!cursor_pos"($I11)
    ($P10) = rx1061_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1061_pos, "")
    rx1061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1063_done
  rxcap_1063_fail:
    goto rx1061_fail
  rxcap_1063_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx1061_cur."!cursor_pos"(rx1061_pos)
    $P10 = rx1061_cur."routine_def"()
    unless $P10, rx1061_fail
    rx1061_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1061_pos = $P10."pos"()
  # rx pass
    rx1061_cur."!cursor_pass"(rx1061_pos, "routine_declarator:sym<sub>")
    if_null rx1061_debug, debug_1010
    rx1061_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx1061_pos)
  debug_1010:
    .return (rx1061_cur)
  rx1061_restart:
.annotate 'line', 10
    if_null rx1061_debug, debug_1011
    rx1061_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_1011:
  rx1061_fail:
    (rx1061_rep, rx1061_pos, $I10, $P10) = rx1061_cur."!mark_fail"(0)
    lt rx1061_pos, -1, rx1061_done
    eq rx1061_pos, -1, rx1061_fail
    jump $I10
  rx1061_done:
    rx1061_cur."!cursor_fail"()
    if_null rx1061_debug, debug_1012
    rx1061_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_1012:
    .return (rx1061_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :subid("176_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1065 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P1066, "ResizablePMCArray"
    push $P1066, $P1065
    .return ($P1066)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("177_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1068_tgt
    .local int rx1068_pos
    .local int rx1068_off
    .local int rx1068_eos
    .local int rx1068_rep
    .local pmc rx1068_cur
    .local pmc rx1068_debug
    (rx1068_cur, rx1068_pos, rx1068_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1068_cur
    .local pmc match
    .lex "$/", match
    length rx1068_eos, rx1068_tgt
    gt rx1068_pos, rx1068_eos, rx1068_done
    set rx1068_off, 0
    lt rx1068_pos, 2, rx1068_start
    sub rx1068_off, rx1068_pos, 1
    substr rx1068_tgt, rx1068_tgt, rx1068_off
  rx1068_start:
    eq $I10, 1, rx1068_restart
    if_null rx1068_debug, debug_1013
    rx1068_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1069_done
    goto rxscan1069_scan
  rxscan1069_loop:
    (rx1068_pos) = rx1068_cur."from"()
    inc rx1068_pos
    rx1068_cur."!cursor_from"(rx1068_pos)
    ge rx1068_pos, rx1068_eos, rxscan1069_done
  rxscan1069_scan:
    set_addr $I10, rxscan1069_loop
    rx1068_cur."!mark_push"(0, rx1068_pos, $I10)
  rxscan1069_done:
.annotate 'line', 413
  # rx subcapture "sym"
    set_addr $I10, rxcap_1070_fail
    rx1068_cur."!mark_push"(0, rx1068_pos, $I10)
  # rx literal  "method"
    add $I11, rx1068_pos, 6
    gt $I11, rx1068_eos, rx1068_fail
    sub $I11, rx1068_pos, rx1068_off
    substr $S10, rx1068_tgt, $I11, 6
    ne $S10, "method", rx1068_fail
    add rx1068_pos, 6
    set_addr $I10, rxcap_1070_fail
    ($I12, $I11) = rx1068_cur."!mark_peek"($I10)
    rx1068_cur."!cursor_pos"($I11)
    ($P10) = rx1068_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1068_pos, "")
    rx1068_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1070_done
  rxcap_1070_fail:
    goto rx1068_fail
  rxcap_1070_done:
  # rx subrule "method_def" subtype=capture negate=
    rx1068_cur."!cursor_pos"(rx1068_pos)
    $P10 = rx1068_cur."method_def"()
    unless $P10, rx1068_fail
    rx1068_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx1068_pos = $P10."pos"()
  # rx pass
    rx1068_cur."!cursor_pass"(rx1068_pos, "routine_declarator:sym<method>")
    if_null rx1068_debug, debug_1014
    rx1068_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx1068_pos)
  debug_1014:
    .return (rx1068_cur)
  rx1068_restart:
.annotate 'line', 10
    if_null rx1068_debug, debug_1015
    rx1068_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_1015:
  rx1068_fail:
    (rx1068_rep, rx1068_pos, $I10, $P10) = rx1068_cur."!mark_fail"(0)
    lt rx1068_pos, -1, rx1068_done
    eq rx1068_pos, -1, rx1068_fail
    jump $I10
  rx1068_done:
    rx1068_cur."!cursor_fail"()
    if_null rx1068_debug, debug_1016
    rx1068_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_1016:
    .return (rx1068_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :subid("178_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1072 = self."!PREFIX__!subrule"("method_def", "method")
    new $P1073, "ResizablePMCArray"
    push $P1073, $P1072
    .return ($P1073)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("179_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 416
    new $P1075, "Undef"
    .lex "$*RETURN_USED", $P1075
.annotate 'line', 10
    .local string rx1076_tgt
    .local int rx1076_pos
    .local int rx1076_off
    .local int rx1076_eos
    .local int rx1076_rep
    .local pmc rx1076_cur
    .local pmc rx1076_debug
    (rx1076_cur, rx1076_pos, rx1076_tgt, $I10) = self."!cursor_start"()
    rx1076_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1076_cur
    .local pmc match
    .lex "$/", match
    length rx1076_eos, rx1076_tgt
    gt rx1076_pos, rx1076_eos, rx1076_done
    set rx1076_off, 0
    lt rx1076_pos, 2, rx1076_start
    sub rx1076_off, rx1076_pos, 1
    substr rx1076_tgt, rx1076_tgt, rx1076_off
  rx1076_start:
    eq $I10, 1, rx1076_restart
    if_null rx1076_debug, debug_1017
    rx1076_cur."!cursor_debug"("START", "routine_def")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1077_done
    goto rxscan1077_scan
  rxscan1077_loop:
    (rx1076_pos) = rx1076_cur."from"()
    inc rx1076_pos
    rx1076_cur."!cursor_from"(rx1076_pos)
    ge rx1076_pos, rx1076_eos, rxscan1077_done
  rxscan1077_scan:
    set_addr $I10, rxscan1077_loop
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxscan1077_done:
.annotate 'line', 415
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 416
    rx1076_cur."!cursor_pos"(rx1076_pos)
    new $P1079, "Integer"
    assign $P1079, 0
    store_lex "$*RETURN_USED", $P1079
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 417
  # rx rxquantr1081 ** 0..1
    set_addr $I10, rxquantr1081_done
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxquantr1081_loop:
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_1084_fail
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  # rx rxquantr1083 ** 0..1
    set_addr $I10, rxquantr1083_done
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxquantr1083_loop:
  # rx literal  "&"
    add $I11, rx1076_pos, 1
    gt $I11, rx1076_eos, rx1076_fail
    sub $I11, rx1076_pos, rx1076_off
    ord $I11, rx1076_tgt, $I11
    ne $I11, 38, rx1076_fail
    add rx1076_pos, 1
    set_addr $I10, rxquantr1083_done
    (rx1076_rep) = rx1076_cur."!mark_commit"($I10)
  rxquantr1083_done:
    set_addr $I10, rxcap_1084_fail
    ($I12, $I11) = rx1076_cur."!mark_peek"($I10)
    rx1076_cur."!cursor_pos"($I11)
    ($P10) = rx1076_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1076_pos, "")
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_1084_done
  rxcap_1084_fail:
    goto rx1076_fail
  rxcap_1084_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."deflongname"()
    unless $P10, rx1076_fail
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
    set_addr $I10, rxquantr1081_done
    (rx1076_rep) = rx1076_cur."!mark_commit"($I10)
  rxquantr1081_done:
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 418
  # rx subrule "newpad" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."newpad"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  alt1088_0:
.annotate 'line', 419
    set_addr $I10, alt1088_1
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1076_pos, 1
    gt $I11, rx1076_eos, rx1076_fail
    sub $I11, rx1076_pos, rx1076_off
    ord $I11, rx1076_tgt, $I11
    ne $I11, 40, rx1076_fail
    add rx1076_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."signature"()
    unless $P10, rx1076_fail
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1076_pos, 1
    gt $I11, rx1076_eos, rx1076_fail
    sub $I11, rx1076_pos, rx1076_off
    ord $I11, rx1076_tgt, $I11
    ne $I11, 41, rx1076_fail
    add rx1076_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
    goto alt1088_end
  alt1088_1:
.annotate 'line', 420
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  alt1088_end:
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 421
  # rx rxquantr1096 ** 0..*
    set_addr $I10, rxquantr1096_done
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
  rxquantr1096_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."trait"()
    unless $P10, rx1076_fail
    goto rxsubrule1097_pass
  rxsubrule1097_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1076_fail
  rxsubrule1097_pass:
    set_addr $I10, rxsubrule1097_back
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1076_pos = $P10."pos"()
    set_addr $I10, rxquantr1096_done
    (rx1076_rep) = rx1076_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1096_done
    rx1076_cur."!mark_push"(rx1076_rep, rx1076_pos, $I10)
    goto rxquantr1096_loop
  rxquantr1096_done:
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  alt1099_0:
.annotate 'line', 422
    set_addr $I10, alt1099_1
    rx1076_cur."!mark_push"(0, rx1076_pos, $I10)
.annotate 'line', 423
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."onlystar"()
    unless $P10, rx1076_fail
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
    goto alt1099_end
  alt1099_1:
.annotate 'line', 424
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."blockoid"()
    unless $P10, rx1076_fail
    rx1076_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1076_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
  alt1099_end:
.annotate 'line', 425
  # rx subrule "ws" subtype=method negate=
    rx1076_cur."!cursor_pos"(rx1076_pos)
    $P10 = rx1076_cur."ws"()
    unless $P10, rx1076_fail
    rx1076_pos = $P10."pos"()
.annotate 'line', 415
  # rx pass
    rx1076_cur."!cursor_pass"(rx1076_pos, "routine_def")
    if_null rx1076_debug, debug_1018
    rx1076_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx1076_pos)
  debug_1018:
    .return (rx1076_cur)
  rx1076_restart:
.annotate 'line', 10
    if_null rx1076_debug, debug_1019
    rx1076_cur."!cursor_debug"("NEXT", "routine_def")
  debug_1019:
  rx1076_fail:
    (rx1076_rep, rx1076_pos, $I10, $P10) = rx1076_cur."!mark_fail"(0)
    lt rx1076_pos, -1, rx1076_done
    eq rx1076_pos, -1, rx1076_fail
    jump $I10
  rx1076_done:
    rx1076_cur."!cursor_fail"()
    if_null rx1076_debug, debug_1020
    rx1076_cur."!cursor_debug"("FAIL", "routine_def")
  debug_1020:
    .return (rx1076_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :subid("180_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1106 = self."!PREFIX__!subrule"("ws", "")
    new $P1107, "ResizablePMCArray"
    push $P1107, $P1106
    .return ($P1107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("181_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P1136 = "182_1304516047.681" 
    capture_lex $P1136
.annotate 'line', 429
    new $P1109, "Undef"
    .lex "$*RETURN_USED", $P1109
.annotate 'line', 430
    new $P1110, "Undef"
    .lex "$*INVOCANT_OK", $P1110
.annotate 'line', 10
    .local string rx1111_tgt
    .local int rx1111_pos
    .local int rx1111_off
    .local int rx1111_eos
    .local int rx1111_rep
    .local pmc rx1111_cur
    .local pmc rx1111_debug
    (rx1111_cur, rx1111_pos, rx1111_tgt, $I10) = self."!cursor_start"()
    rx1111_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx1111_cur
    .local pmc match
    .lex "$/", match
    length rx1111_eos, rx1111_tgt
    gt rx1111_pos, rx1111_eos, rx1111_done
    set rx1111_off, 0
    lt rx1111_pos, 2, rx1111_start
    sub rx1111_off, rx1111_pos, 1
    substr rx1111_tgt, rx1111_tgt, rx1111_off
  rx1111_start:
    eq $I10, 1, rx1111_restart
    if_null rx1111_debug, debug_1021
    rx1111_cur."!cursor_debug"("START", "method_def")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1112_done
    goto rxscan1112_scan
  rxscan1112_loop:
    (rx1111_pos) = rx1111_cur."from"()
    inc rx1111_pos
    rx1111_cur."!cursor_from"(rx1111_pos)
    ge rx1111_pos, rx1111_eos, rxscan1112_done
  rxscan1112_scan:
    set_addr $I10, rxscan1112_loop
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxscan1112_done:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 429
    rx1111_cur."!cursor_pos"(rx1111_pos)
    new $P1114, "Integer"
    assign $P1114, 0
    store_lex "$*RETURN_USED", $P1114
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 430
    rx1111_cur."!cursor_pos"(rx1111_pos)
    new $P1116, "Integer"
    assign $P1116, 1
    store_lex "$*INVOCANT_OK", $P1116
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 431
  # rx subcapture "private"
    set_addr $I10, rxcap_1119_fail
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  # rx rxquantr1118 ** 0..1
    set_addr $I10, rxquantr1118_done
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxquantr1118_loop:
  # rx literal  "!"
    add $I11, rx1111_pos, 1
    gt $I11, rx1111_eos, rx1111_fail
    sub $I11, rx1111_pos, rx1111_off
    ord $I11, rx1111_tgt, $I11
    ne $I11, 33, rx1111_fail
    add rx1111_pos, 1
    set_addr $I10, rxquantr1118_done
    (rx1111_rep) = rx1111_cur."!mark_commit"($I10)
  rxquantr1118_done:
    set_addr $I10, rxcap_1119_fail
    ($I12, $I11) = rx1111_cur."!mark_peek"($I10)
    rx1111_cur."!cursor_pos"($I11)
    ($P10) = rx1111_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1111_pos, "")
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_1119_done
  rxcap_1119_fail:
    goto rx1111_fail
  rxcap_1119_done:
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 432
  # rx rxquantr1121 ** 0..1
    set_addr $I10, rxquantr1121_done
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxquantr1121_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."deflongname"()
    unless $P10, rx1111_fail
    goto rxsubrule1122_pass
  rxsubrule1122_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1111_fail
  rxsubrule1122_pass:
    set_addr $I10, rxsubrule1122_back
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx1111_pos = $P10."pos"()
    set_addr $I10, rxquantr1121_done
    (rx1111_rep) = rx1111_cur."!mark_commit"($I10)
  rxquantr1121_done:
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 433
  # rx subrule "newpad" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."newpad"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  alt1125_0:
.annotate 'line', 434
    set_addr $I10, alt1125_1
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1111_pos, 1
    gt $I11, rx1111_eos, rx1111_fail
    sub $I11, rx1111_pos, rx1111_off
    ord $I11, rx1111_tgt, $I11
    ne $I11, 40, rx1111_fail
    add rx1111_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."signature"()
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1111_pos, 1
    gt $I11, rx1111_eos, rx1111_fail
    sub $I11, rx1111_pos, rx1111_off
    ord $I11, rx1111_tgt, $I11
    ne $I11, 41, rx1111_fail
    add rx1111_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
    goto alt1125_end
  alt1125_1:
.annotate 'line', 435
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  alt1125_end:
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 436
    rx1111_cur."!cursor_pos"(rx1111_pos)
    find_lex $P1133, unicode:"$\x{a2}"
    $P1134 = $P1133."MATCH"()
    store_lex "$/", $P1134
    .const 'Sub' $P1136 = "182_1304516047.681" 
    capture_lex $P1136
    $P1138 = $P1136()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 437
  # rx rxquantr1140 ** 0..*
    set_addr $I10, rxquantr1140_done
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
  rxquantr1140_loop:
  # rx subrule "trait" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."trait"()
    unless $P10, rx1111_fail
    goto rxsubrule1141_pass
  rxsubrule1141_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1111_fail
  rxsubrule1141_pass:
    set_addr $I10, rxsubrule1141_back
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx1111_pos = $P10."pos"()
    set_addr $I10, rxquantr1140_done
    (rx1111_rep) = rx1111_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1140_done
    rx1111_cur."!mark_push"(rx1111_rep, rx1111_pos, $I10)
    goto rxquantr1140_loop
  rxquantr1140_done:
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  alt1143_0:
.annotate 'line', 438
    set_addr $I10, alt1143_1
    rx1111_cur."!mark_push"(0, rx1111_pos, $I10)
.annotate 'line', 439
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."onlystar"()
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
    goto alt1143_end
  alt1143_1:
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."blockoid"()
    unless $P10, rx1111_fail
    rx1111_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx1111_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
  alt1143_end:
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx1111_cur."!cursor_pos"(rx1111_pos)
    $P10 = rx1111_cur."ws"()
    unless $P10, rx1111_fail
    rx1111_pos = $P10."pos"()
.annotate 'line', 428
  # rx pass
    rx1111_cur."!cursor_pass"(rx1111_pos, "method_def")
    if_null rx1111_debug, debug_1022
    rx1111_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx1111_pos)
  debug_1022:
    .return (rx1111_cur)
  rx1111_restart:
.annotate 'line', 10
    if_null rx1111_debug, debug_1023
    rx1111_cur."!cursor_debug"("NEXT", "method_def")
  debug_1023:
  rx1111_fail:
    (rx1111_rep, rx1111_pos, $I10, $P10) = rx1111_cur."!mark_fail"(0)
    lt rx1111_pos, -1, rx1111_done
    eq rx1111_pos, -1, rx1111_fail
    jump $I10
  rx1111_done:
    rx1111_cur."!cursor_fail"()
    if_null rx1111_debug, debug_1024
    rx1111_cur."!cursor_debug"("FAIL", "method_def")
  debug_1024:
    .return (rx1111_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1135"  :anon :subid("182_1304516047.681") :outer("181_1304516047.681")
.annotate 'line', 436
    new $P1137, "Integer"
    assign $P1137, 0
    store_dynamic_lex "$*INVOCANT_OK", $P1137
    .return ($P1137)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :subid("183_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1150 = self."!PREFIX__!subrule"("ws", "")
    new $P1151, "ResizablePMCArray"
    push $P1151, $P1150
    .return ($P1151)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("184_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P1158 = "185_1304516047.681" 
    capture_lex $P1158
    .local string rx1153_tgt
    .local int rx1153_pos
    .local int rx1153_off
    .local int rx1153_eos
    .local int rx1153_rep
    .local pmc rx1153_cur
    .local pmc rx1153_debug
    (rx1153_cur, rx1153_pos, rx1153_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1153_cur
    .local pmc match
    .lex "$/", match
    length rx1153_eos, rx1153_tgt
    gt rx1153_pos, rx1153_eos, rx1153_done
    set rx1153_off, 0
    lt rx1153_pos, 2, rx1153_start
    sub rx1153_off, rx1153_pos, 1
    substr rx1153_tgt, rx1153_tgt, rx1153_off
  rx1153_start:
    eq $I10, 1, rx1153_restart
    if_null rx1153_debug, debug_1025
    rx1153_cur."!cursor_debug"("START", "onlystar")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1154_done
    goto rxscan1154_scan
  rxscan1154_loop:
    (rx1153_pos) = rx1153_cur."from"()
    inc rx1153_pos
    rx1153_cur."!cursor_from"(rx1153_pos)
    ge rx1153_pos, rx1153_eos, rxscan1154_done
  rxscan1154_scan:
    set_addr $I10, rxscan1154_loop
    rx1153_cur."!mark_push"(0, rx1153_pos, $I10)
  rxscan1154_done:
.annotate 'line', 445
    rx1153_cur."!cursor_pos"(rx1153_pos)
    find_lex $P1155, unicode:"$\x{a2}"
    $P1156 = $P1155."MATCH"()
    store_lex "$/", $P1156
    .const 'Sub' $P1158 = "185_1304516047.681" 
    capture_lex $P1158
    $P1164 = $P1158()
    unless $P1164, rx1153_fail
.annotate 'line', 446
  # rx literal  "{"
    add $I11, rx1153_pos, 1
    gt $I11, rx1153_eos, rx1153_fail
    sub $I11, rx1153_pos, rx1153_off
    ord $I11, rx1153_tgt, $I11
    ne $I11, 123, rx1153_fail
    add rx1153_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."ws"()
    unless $P10, rx1153_fail
    rx1153_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx1153_pos, 1
    gt $I11, rx1153_eos, rx1153_fail
    sub $I11, rx1153_pos, rx1153_off
    ord $I11, rx1153_tgt, $I11
    ne $I11, 42, rx1153_fail
    add rx1153_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."ws"()
    unless $P10, rx1153_fail
    rx1153_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1153_pos, 1
    gt $I11, rx1153_eos, rx1153_fail
    sub $I11, rx1153_pos, rx1153_off
    ord $I11, rx1153_tgt, $I11
    ne $I11, 125, rx1153_fail
    add rx1153_pos, 1
.annotate 'line', 447
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."ENDSTMT"()
    unless $P10, rx1153_fail
.annotate 'line', 448
  # rx subrule "finishpad" subtype=method negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."finishpad"()
    unless $P10, rx1153_fail
    rx1153_pos = $P10."pos"()
.annotate 'line', 444
  # rx pass
    rx1153_cur."!cursor_pass"(rx1153_pos, "onlystar")
    if_null rx1153_debug, debug_1028
    rx1153_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx1153_pos)
  debug_1028:
    .return (rx1153_cur)
  rx1153_restart:
.annotate 'line', 10
    if_null rx1153_debug, debug_1029
    rx1153_cur."!cursor_debug"("NEXT", "onlystar")
  debug_1029:
  rx1153_fail:
    (rx1153_rep, rx1153_pos, $I10, $P10) = rx1153_cur."!mark_fail"(0)
    lt rx1153_pos, -1, rx1153_done
    eq rx1153_pos, -1, rx1153_fail
    jump $I10
  rx1153_done:
    rx1153_cur."!cursor_fail"()
    if_null rx1153_debug, debug_1030
    rx1153_cur."!cursor_debug"("FAIL", "onlystar")
  debug_1030:
    .return (rx1153_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1157"  :anon :subid("185_1304516047.681") :outer("184_1304516047.681")
.annotate 'line', 445
    find_dynamic_lex $P1161, "$*MULTINESS"
    unless_null $P1161, vivify_1026
    get_hll_global $P1159, "GLOBAL"
    get_who $P1160, $P1159
    set $P1161, $P1160["$MULTINESS"]
    unless_null $P1161, vivify_1027
    die "Contextual $*MULTINESS not found"
  vivify_1027:
  vivify_1026:
    set $S1162, $P1161
    iseq $I1163, $S1162, "proto"
    .return ($I1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :subid("186_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1166, "ResizablePMCArray"
    push $P1166, ""
    .return ($P1166)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("187_1304516047.681")
    .param pmc param_1168
.annotate 'line', 451
    .lex "self", param_1168
    $P1169 = param_1168."!protoregex"("multi_declarator")
    .return ($P1169)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("188_1304516047.681")
    .param pmc param_1171
.annotate 'line', 451
    .lex "self", param_1171
    $P1172 = param_1171."!PREFIX__!protoregex"("multi_declarator")
    .return ($P1172)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("189_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 453
    new $P1174, "Undef"
    .lex "$*MULTINESS", $P1174
.annotate 'line', 10
    .local string rx1175_tgt
    .local int rx1175_pos
    .local int rx1175_off
    .local int rx1175_eos
    .local int rx1175_rep
    .local pmc rx1175_cur
    .local pmc rx1175_debug
    (rx1175_cur, rx1175_pos, rx1175_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1175_cur
    .local pmc match
    .lex "$/", match
    length rx1175_eos, rx1175_tgt
    gt rx1175_pos, rx1175_eos, rx1175_done
    set rx1175_off, 0
    lt rx1175_pos, 2, rx1175_start
    sub rx1175_off, rx1175_pos, 1
    substr rx1175_tgt, rx1175_tgt, rx1175_off
  rx1175_start:
    eq $I10, 1, rx1175_restart
    if_null rx1175_debug, debug_1031
    rx1175_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_1031:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1176_done
    goto rxscan1176_scan
  rxscan1176_loop:
    (rx1175_pos) = rx1175_cur."from"()
    inc rx1175_pos
    rx1175_cur."!cursor_from"(rx1175_pos)
    ge rx1175_pos, rx1175_eos, rxscan1176_done
  rxscan1176_scan:
    set_addr $I10, rxscan1176_loop
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  rxscan1176_done:
.annotate 'line', 453
    rx1175_cur."!cursor_pos"(rx1175_pos)
    new $P1177, "String"
    assign $P1177, "multi"
    store_lex "$*MULTINESS", $P1177
.annotate 'line', 454
  # rx subcapture "sym"
    set_addr $I10, rxcap_1178_fail
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  # rx literal  "multi"
    add $I11, rx1175_pos, 5
    gt $I11, rx1175_eos, rx1175_fail
    sub $I11, rx1175_pos, rx1175_off
    substr $S10, rx1175_tgt, $I11, 5
    ne $S10, "multi", rx1175_fail
    add rx1175_pos, 5
    set_addr $I10, rxcap_1178_fail
    ($I12, $I11) = rx1175_cur."!mark_peek"($I10)
    rx1175_cur."!cursor_pos"($I11)
    ($P10) = rx1175_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1175_pos, "")
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1178_done
  rxcap_1178_fail:
    goto rx1175_fail
  rxcap_1178_done:
.annotate 'line', 455
  # rx subrule "ws" subtype=method negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."ws"()
    unless $P10, rx1175_fail
    rx1175_pos = $P10."pos"()
  alt1179_0:
    set_addr $I10, alt1179_1
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."declarator"()
    unless $P10, rx1175_fail
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1175_pos = $P10."pos"()
    goto alt1179_end
  alt1179_1:
    set_addr $I10, alt1179_2
    rx1175_cur."!mark_push"(0, rx1175_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."routine_def"()
    unless $P10, rx1175_fail
    rx1175_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1175_pos = $P10."pos"()
    goto alt1179_end
  alt1179_2:
  # rx subrule "panic" subtype=method negate=
    rx1175_cur."!cursor_pos"(rx1175_pos)
    $P10 = rx1175_cur."panic"("Malformed multi")
    unless $P10, rx1175_fail
    rx1175_pos = $P10."pos"()
  alt1179_end:
.annotate 'line', 452
  # rx pass
    rx1175_cur."!cursor_pass"(rx1175_pos, "multi_declarator:sym<multi>")
    if_null rx1175_debug, debug_1032
    rx1175_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx1175_pos)
  debug_1032:
    .return (rx1175_cur)
  rx1175_restart:
.annotate 'line', 10
    if_null rx1175_debug, debug_1033
    rx1175_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_1033:
  rx1175_fail:
    (rx1175_rep, rx1175_pos, $I10, $P10) = rx1175_cur."!mark_fail"(0)
    lt rx1175_pos, -1, rx1175_done
    eq rx1175_pos, -1, rx1175_fail
    jump $I10
  rx1175_done:
    rx1175_cur."!cursor_fail"()
    if_null rx1175_debug, debug_1034
    rx1175_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_1034:
    .return (rx1175_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :subid("190_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1181 = self."!PREFIX__!subrule"("ws", "multi")
    new $P1182, "ResizablePMCArray"
    push $P1182, $P1181
    .return ($P1182)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("191_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 458
    new $P1184, "Undef"
    .lex "$*MULTINESS", $P1184
.annotate 'line', 10
    .local string rx1185_tgt
    .local int rx1185_pos
    .local int rx1185_off
    .local int rx1185_eos
    .local int rx1185_rep
    .local pmc rx1185_cur
    .local pmc rx1185_debug
    (rx1185_cur, rx1185_pos, rx1185_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1185_cur
    .local pmc match
    .lex "$/", match
    length rx1185_eos, rx1185_tgt
    gt rx1185_pos, rx1185_eos, rx1185_done
    set rx1185_off, 0
    lt rx1185_pos, 2, rx1185_start
    sub rx1185_off, rx1185_pos, 1
    substr rx1185_tgt, rx1185_tgt, rx1185_off
  rx1185_start:
    eq $I10, 1, rx1185_restart
    if_null rx1185_debug, debug_1035
    rx1185_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_1035:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1186_done
    goto rxscan1186_scan
  rxscan1186_loop:
    (rx1185_pos) = rx1185_cur."from"()
    inc rx1185_pos
    rx1185_cur."!cursor_from"(rx1185_pos)
    ge rx1185_pos, rx1185_eos, rxscan1186_done
  rxscan1186_scan:
    set_addr $I10, rxscan1186_loop
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  rxscan1186_done:
.annotate 'line', 458
    rx1185_cur."!cursor_pos"(rx1185_pos)
    new $P1187, "String"
    assign $P1187, "proto"
    store_lex "$*MULTINESS", $P1187
.annotate 'line', 459
  # rx subcapture "sym"
    set_addr $I10, rxcap_1188_fail
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1185_pos, 5
    gt $I11, rx1185_eos, rx1185_fail
    sub $I11, rx1185_pos, rx1185_off
    substr $S10, rx1185_tgt, $I11, 5
    ne $S10, "proto", rx1185_fail
    add rx1185_pos, 5
    set_addr $I10, rxcap_1188_fail
    ($I12, $I11) = rx1185_cur."!mark_peek"($I10)
    rx1185_cur."!cursor_pos"($I11)
    ($P10) = rx1185_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1185_pos, "")
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1188_done
  rxcap_1188_fail:
    goto rx1185_fail
  rxcap_1188_done:
.annotate 'line', 460
  # rx subrule "ws" subtype=method negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."ws"()
    unless $P10, rx1185_fail
    rx1185_pos = $P10."pos"()
  alt1189_0:
    set_addr $I10, alt1189_1
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."declarator"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1185_pos = $P10."pos"()
    goto alt1189_end
  alt1189_1:
    set_addr $I10, alt1189_2
    rx1185_cur."!mark_push"(0, rx1185_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."routine_def"()
    unless $P10, rx1185_fail
    rx1185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx1185_pos = $P10."pos"()
    goto alt1189_end
  alt1189_2:
  # rx subrule "panic" subtype=method negate=
    rx1185_cur."!cursor_pos"(rx1185_pos)
    $P10 = rx1185_cur."panic"("Malformed proto")
    unless $P10, rx1185_fail
    rx1185_pos = $P10."pos"()
  alt1189_end:
.annotate 'line', 457
  # rx pass
    rx1185_cur."!cursor_pass"(rx1185_pos, "multi_declarator:sym<proto>")
    if_null rx1185_debug, debug_1036
    rx1185_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx1185_pos)
  debug_1036:
    .return (rx1185_cur)
  rx1185_restart:
.annotate 'line', 10
    if_null rx1185_debug, debug_1037
    rx1185_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_1037:
  rx1185_fail:
    (rx1185_rep, rx1185_pos, $I10, $P10) = rx1185_cur."!mark_fail"(0)
    lt rx1185_pos, -1, rx1185_done
    eq rx1185_pos, -1, rx1185_fail
    jump $I10
  rx1185_done:
    rx1185_cur."!cursor_fail"()
    if_null rx1185_debug, debug_1038
    rx1185_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_1038:
    .return (rx1185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :subid("192_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1191 = self."!PREFIX__!subrule"("ws", "proto")
    new $P1192, "ResizablePMCArray"
    push $P1192, $P1191
    .return ($P1192)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("193_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 463
    new $P1194, "Undef"
    .lex "$*MULTINESS", $P1194
.annotate 'line', 10
    .local string rx1195_tgt
    .local int rx1195_pos
    .local int rx1195_off
    .local int rx1195_eos
    .local int rx1195_rep
    .local pmc rx1195_cur
    .local pmc rx1195_debug
    (rx1195_cur, rx1195_pos, rx1195_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1195_cur
    .local pmc match
    .lex "$/", match
    length rx1195_eos, rx1195_tgt
    gt rx1195_pos, rx1195_eos, rx1195_done
    set rx1195_off, 0
    lt rx1195_pos, 2, rx1195_start
    sub rx1195_off, rx1195_pos, 1
    substr rx1195_tgt, rx1195_tgt, rx1195_off
  rx1195_start:
    eq $I10, 1, rx1195_restart
    if_null rx1195_debug, debug_1039
    rx1195_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_1039:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1196_done
    goto rxscan1196_scan
  rxscan1196_loop:
    (rx1195_pos) = rx1195_cur."from"()
    inc rx1195_pos
    rx1195_cur."!cursor_from"(rx1195_pos)
    ge rx1195_pos, rx1195_eos, rxscan1196_done
  rxscan1196_scan:
    set_addr $I10, rxscan1196_loop
    rx1195_cur."!mark_push"(0, rx1195_pos, $I10)
  rxscan1196_done:
.annotate 'line', 463
    rx1195_cur."!cursor_pos"(rx1195_pos)
    new $P1197, "String"
    assign $P1197, ""
    store_lex "$*MULTINESS", $P1197
.annotate 'line', 464
  # rx subrule "declarator" subtype=capture negate=
    rx1195_cur."!cursor_pos"(rx1195_pos)
    $P10 = rx1195_cur."declarator"()
    unless $P10, rx1195_fail
    rx1195_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx1195_pos = $P10."pos"()
.annotate 'line', 462
  # rx pass
    rx1195_cur."!cursor_pass"(rx1195_pos, "multi_declarator:sym<null>")
    if_null rx1195_debug, debug_1040
    rx1195_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx1195_pos)
  debug_1040:
    .return (rx1195_cur)
  rx1195_restart:
.annotate 'line', 10
    if_null rx1195_debug, debug_1041
    rx1195_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_1041:
  rx1195_fail:
    (rx1195_rep, rx1195_pos, $I10, $P10) = rx1195_cur."!mark_fail"(0)
    lt rx1195_pos, -1, rx1195_done
    eq rx1195_pos, -1, rx1195_fail
    jump $I10
  rx1195_done:
    rx1195_cur."!cursor_fail"()
    if_null rx1195_debug, debug_1042
    rx1195_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_1042:
    .return (rx1195_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :subid("194_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1199 = self."!PREFIX__!subrule"("declarator", "")
    new $P1200, "ResizablePMCArray"
    push $P1200, $P1199
    .return ($P1200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("195_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P1208 = "196_1304516047.681" 
    capture_lex $P1208
    .local string rx1202_tgt
    .local int rx1202_pos
    .local int rx1202_off
    .local int rx1202_eos
    .local int rx1202_rep
    .local pmc rx1202_cur
    .local pmc rx1202_debug
    (rx1202_cur, rx1202_pos, rx1202_tgt, $I10) = self."!cursor_start"()
    rx1202_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx1202_cur
    .local pmc match
    .lex "$/", match
    length rx1202_eos, rx1202_tgt
    gt rx1202_pos, rx1202_eos, rx1202_done
    set rx1202_off, 0
    lt rx1202_pos, 2, rx1202_start
    sub rx1202_off, rx1202_pos, 1
    substr rx1202_tgt, rx1202_tgt, rx1202_off
  rx1202_start:
    eq $I10, 1, rx1202_restart
    if_null rx1202_debug, debug_1043
    rx1202_cur."!cursor_debug"("START", "signature")
  debug_1043:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1203_done
    goto rxscan1203_scan
  rxscan1203_loop:
    (rx1202_pos) = rx1202_cur."from"()
    inc rx1202_pos
    rx1202_cur."!cursor_from"(rx1202_pos)
    ge rx1202_pos, rx1202_eos, rxscan1203_done
  rxscan1203_scan:
    set_addr $I10, rxscan1203_loop
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  rxscan1203_done:
.annotate 'line', 468
  # rx rxquantr1204 ** 0..1
    set_addr $I10, rxquantr1204_done
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  rxquantr1204_loop:
    rx1202_cur."!cursor_pos"(rx1202_pos)
    find_lex $P1205, unicode:"$\x{a2}"
    $P1206 = $P1205."MATCH"()
    store_lex "$/", $P1206
    .const 'Sub' $P1208 = "196_1304516047.681" 
    capture_lex $P1208
    $P1212 = $P1208()
    unless $P1212, rx1202_fail
  # rx subrule "ws" subtype=method negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."ws"()
    unless $P10, rx1202_fail
    rx1202_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."parameter"()
    unless $P10, rx1202_fail
    rx1202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx1202_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."ws"()
    unless $P10, rx1202_fail
    rx1202_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx1202_pos, 1
    gt $I11, rx1202_eos, rx1202_fail
    sub $I11, rx1202_pos, rx1202_off
    ord $I11, rx1202_tgt, $I11
    ne $I11, 58, rx1202_fail
    add rx1202_pos, 1
    set_addr $I10, rxquantr1204_done
    (rx1202_rep) = rx1202_cur."!mark_commit"($I10)
  rxquantr1204_done:
.annotate 'line', 469
  # rx rxquantr1213 ** 0..1
    set_addr $I10, rxquantr1213_done
    rx1202_cur."!mark_push"(0, rx1202_pos, $I10)
  rxquantr1213_loop:
  # rx rxquantr1214 ** 1..*
    set_addr $I10, rxquantr1214_done
    rx1202_cur."!mark_push"(0, -1, $I10)
  rxquantr1214_loop:
  # rx subrule "ws" subtype=method negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."ws"()
    unless $P10, rx1202_fail
    rx1202_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."parameter"()
    unless $P10, rx1202_fail
    rx1202_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx1202_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1202_cur."!cursor_pos"(rx1202_pos)
    $P10 = rx1202_cur."ws"()
    unless $P10, rx1202_fail
    rx1202_pos = $P10."pos"()
    set_addr $I10, rxquantr1214_done
    (rx1202_rep) = rx1202_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1214_done
    rx1202_cur."!mark_push"(rx1202_rep, rx1202_pos, $I10)
  # rx literal  ","
    add $I11, rx1202_pos, 1
    gt $I11, rx1202_eos, rx1202_fail
    sub $I11, rx1202_pos, rx1202_off
    ord $I11, rx1202_tgt, $I11
    ne $I11, 44, rx1202_fail
    add rx1202_pos, 1
    goto rxquantr1214_loop
  rxquantr1214_done:
    set_addr $I10, rxquantr1213_done
    (rx1202_rep) = rx1202_cur."!mark_commit"($I10)
  rxquantr1213_done:
.annotate 'line', 467
  # rx pass
    rx1202_cur."!cursor_pass"(rx1202_pos, "signature")
    if_null rx1202_debug, debug_1046
    rx1202_cur."!cursor_debug"("PASS", "signature", " at pos=", rx1202_pos)
  debug_1046:
    .return (rx1202_cur)
  rx1202_restart:
.annotate 'line', 10
    if_null rx1202_debug, debug_1047
    rx1202_cur."!cursor_debug"("NEXT", "signature")
  debug_1047:
  rx1202_fail:
    (rx1202_rep, rx1202_pos, $I10, $P10) = rx1202_cur."!mark_fail"(0)
    lt rx1202_pos, -1, rx1202_done
    eq rx1202_pos, -1, rx1202_fail
    jump $I10
  rx1202_done:
    rx1202_cur."!cursor_fail"()
    if_null rx1202_debug, debug_1048
    rx1202_cur."!cursor_debug"("FAIL", "signature")
  debug_1048:
    .return (rx1202_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1207"  :anon :subid("196_1304516047.681") :outer("195_1304516047.681")
.annotate 'line', 468
    find_dynamic_lex $P1211, "$*INVOCANT_OK"
    unless_null $P1211, vivify_1044
    get_hll_global $P1209, "GLOBAL"
    get_who $P1210, $P1209
    set $P1211, $P1210["$INVOCANT_OK"]
    unless_null $P1211, vivify_1045
    die "Contextual $*INVOCANT_OK not found"
  vivify_1045:
  vivify_1044:
    .return ($P1211)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :subid("197_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1216, "ResizablePMCArray"
    push $P1216, ""
    .return ($P1216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("198_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1218_tgt
    .local int rx1218_pos
    .local int rx1218_off
    .local int rx1218_eos
    .local int rx1218_rep
    .local pmc rx1218_cur
    .local pmc rx1218_debug
    (rx1218_cur, rx1218_pos, rx1218_tgt, $I10) = self."!cursor_start"()
    rx1218_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx1218_cur
    .local pmc match
    .lex "$/", match
    length rx1218_eos, rx1218_tgt
    gt rx1218_pos, rx1218_eos, rx1218_done
    set rx1218_off, 0
    lt rx1218_pos, 2, rx1218_start
    sub rx1218_off, rx1218_pos, 1
    substr rx1218_tgt, rx1218_tgt, rx1218_off
  rx1218_start:
    eq $I10, 1, rx1218_restart
    if_null rx1218_debug, debug_1049
    rx1218_cur."!cursor_debug"("START", "parameter")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1219_done
    goto rxscan1219_scan
  rxscan1219_loop:
    (rx1218_pos) = rx1218_cur."from"()
    inc rx1218_pos
    rx1218_cur."!cursor_from"(rx1218_pos)
    ge rx1218_pos, rx1218_eos, rxscan1219_done
  rxscan1219_scan:
    set_addr $I10, rxscan1219_loop
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxscan1219_done:
.annotate 'line', 473
  # rx rxquantr1220 ** 0..*
    set_addr $I10, rxquantr1220_done
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxquantr1220_loop:
  # rx subrule "typename" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."typename"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx1218_pos = $P10."pos"()
  # rx rxquantr1221 ** 0..1
    set_addr $I10, rxquantr1221_done
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxquantr1221_loop:
  # rx literal  ":"
    add $I11, rx1218_pos, 1
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    ord $I11, rx1218_tgt, $I11
    ne $I11, 58, rx1218_fail
    add rx1218_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_1222_fail
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1218_pos, rx1218_eos, rx1218_fail
    sub $I10, rx1218_pos, rx1218_off
    substr $S10, rx1218_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx1218_fail
    inc rx1218_pos
    set_addr $I10, rxcap_1222_fail
    ($I12, $I11) = rx1218_cur."!mark_peek"($I10)
    rx1218_cur."!cursor_pos"($I11)
    ($P10) = rx1218_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1218_pos, "")
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_1222_done
  rxcap_1222_fail:
    goto rx1218_fail
  rxcap_1222_done:
    set_addr $I10, rxquantr1221_done
    (rx1218_rep) = rx1218_cur."!mark_commit"($I10)
  rxquantr1221_done:
  # rx subrule "ws" subtype=method negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."ws"()
    unless $P10, rx1218_fail
    rx1218_pos = $P10."pos"()
    set_addr $I10, rxquantr1220_done
    (rx1218_rep) = rx1218_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr1220_done
    rx1218_cur."!mark_push"(rx1218_rep, rx1218_pos, $I10)
    goto rxquantr1220_loop
  rxquantr1220_done:
  alt1223_0:
.annotate 'line', 474
    set_addr $I10, alt1223_1
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
.annotate 'line', 475
  # rx subcapture "quant"
    set_addr $I10, rxcap_1224_fail
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx literal  "*"
    add $I11, rx1218_pos, 1
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    ord $I11, rx1218_tgt, $I11
    ne $I11, 42, rx1218_fail
    add rx1218_pos, 1
    set_addr $I10, rxcap_1224_fail
    ($I12, $I11) = rx1218_cur."!mark_peek"($I10)
    rx1218_cur."!cursor_pos"($I11)
    ($P10) = rx1218_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1218_pos, "")
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1224_done
  rxcap_1224_fail:
    goto rx1218_fail
  rxcap_1224_done:
  # rx subrule "param_var" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."param_var"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1218_pos = $P10."pos"()
    goto alt1223_end
  alt1223_1:
  alt1225_0:
.annotate 'line', 476
    set_addr $I10, alt1225_1
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."param_var"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1218_pos = $P10."pos"()
    goto alt1225_end
  alt1225_1:
  # rx subrule "named_param" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."named_param"()
    unless $P10, rx1218_fail
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx1218_pos = $P10."pos"()
  alt1225_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_1227_fail
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  alt1226_0:
    set_addr $I10, alt1226_1
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx literal  "?"
    add $I11, rx1218_pos, 1
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    ord $I11, rx1218_tgt, $I11
    ne $I11, 63, rx1218_fail
    add rx1218_pos, 1
    goto alt1226_end
  alt1226_1:
    set_addr $I10, alt1226_2
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  # rx literal  "!"
    add $I11, rx1218_pos, 1
    gt $I11, rx1218_eos, rx1218_fail
    sub $I11, rx1218_pos, rx1218_off
    ord $I11, rx1218_tgt, $I11
    ne $I11, 33, rx1218_fail
    add rx1218_pos, 1
    goto alt1226_end
  alt1226_2:
  alt1226_end:
    set_addr $I10, rxcap_1227_fail
    ($I12, $I11) = rx1218_cur."!mark_peek"($I10)
    rx1218_cur."!cursor_pos"($I11)
    ($P10) = rx1218_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1218_pos, "")
    rx1218_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_1227_done
  rxcap_1227_fail:
    goto rx1218_fail
  rxcap_1227_done:
  alt1223_end:
.annotate 'line', 478
  # rx rxquantr1228 ** 0..1
    set_addr $I10, rxquantr1228_done
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10)
  rxquantr1228_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx1218_cur."!cursor_pos"(rx1218_pos)
    $P10 = rx1218_cur."default_value"()
    unless $P10, rx1218_fail
    goto rxsubrule1229_pass
  rxsubrule1229_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1218_fail
  rxsubrule1229_pass:
    set_addr $I10, rxsubrule1229_back
    rx1218_cur."!mark_push"(0, rx1218_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx1218_pos = $P10."pos"()
    set_addr $I10, rxquantr1228_done
    (rx1218_rep) = rx1218_cur."!mark_commit"($I10)
  rxquantr1228_done:
.annotate 'line', 472
  # rx pass
    rx1218_cur."!cursor_pass"(rx1218_pos, "parameter")
    if_null rx1218_debug, debug_1050
    rx1218_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx1218_pos)
  debug_1050:
    .return (rx1218_cur)
  rx1218_restart:
.annotate 'line', 10
    if_null rx1218_debug, debug_1051
    rx1218_cur."!cursor_debug"("NEXT", "parameter")
  debug_1051:
  rx1218_fail:
    (rx1218_rep, rx1218_pos, $I10, $P10) = rx1218_cur."!mark_fail"(0)
    lt rx1218_pos, -1, rx1218_done
    eq rx1218_pos, -1, rx1218_fail
    jump $I10
  rx1218_done:
    rx1218_cur."!cursor_fail"()
    if_null rx1218_debug, debug_1052
    rx1218_cur."!cursor_debug"("FAIL", "parameter")
  debug_1052:
    .return (rx1218_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :subid("199_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1231, "ResizablePMCArray"
    push $P1231, ""
    .return ($P1231)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("200_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1233_tgt
    .local int rx1233_pos
    .local int rx1233_off
    .local int rx1233_eos
    .local int rx1233_rep
    .local pmc rx1233_cur
    .local pmc rx1233_debug
    (rx1233_cur, rx1233_pos, rx1233_tgt, $I10) = self."!cursor_start"()
    rx1233_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx1233_cur
    .local pmc match
    .lex "$/", match
    length rx1233_eos, rx1233_tgt
    gt rx1233_pos, rx1233_eos, rx1233_done
    set rx1233_off, 0
    lt rx1233_pos, 2, rx1233_start
    sub rx1233_off, rx1233_pos, 1
    substr rx1233_tgt, rx1233_tgt, rx1233_off
  rx1233_start:
    eq $I10, 1, rx1233_restart
    if_null rx1233_debug, debug_1053
    rx1233_cur."!cursor_debug"("START", "param_var")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1233_pos) = rx1233_cur."from"()
    inc rx1233_pos
    rx1233_cur."!cursor_from"(rx1233_pos)
    ge rx1233_pos, rx1233_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  rxscan1234_done:
.annotate 'line', 482
  # rx subrule "sigil" subtype=capture negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."sigil"()
    unless $P10, rx1233_fail
    rx1233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1233_pos = $P10."pos"()
  # rx rxquantr1235 ** 0..1
    set_addr $I10, rxquantr1235_done
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  rxquantr1235_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."twigil"()
    unless $P10, rx1233_fail
    goto rxsubrule1236_pass
  rxsubrule1236_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1233_fail
  rxsubrule1236_pass:
    set_addr $I10, rxsubrule1236_back
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx1233_pos = $P10."pos"()
    set_addr $I10, rxquantr1235_done
    (rx1233_rep) = rx1233_cur."!mark_commit"($I10)
  rxquantr1235_done:
  alt1237_0:
.annotate 'line', 483
    set_addr $I10, alt1237_1
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."ident"()
    unless $P10, rx1233_fail
    rx1233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1233_pos = $P10."pos"()
    goto alt1237_end
  alt1237_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_1238_fail
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1233_pos, rx1233_eos, rx1233_fail
    sub $I10, rx1233_pos, rx1233_off
    substr $S10, rx1233_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx1233_fail
    inc rx1233_pos
    set_addr $I10, rxcap_1238_fail
    ($I12, $I11) = rx1233_cur."!mark_peek"($I10)
    rx1233_cur."!cursor_pos"($I11)
    ($P10) = rx1233_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1233_pos, "")
    rx1233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_1238_done
  rxcap_1238_fail:
    goto rx1233_fail
  rxcap_1238_done:
  alt1237_end:
.annotate 'line', 481
  # rx pass
    rx1233_cur."!cursor_pass"(rx1233_pos, "param_var")
    if_null rx1233_debug, debug_1054
    rx1233_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx1233_pos)
  debug_1054:
    .return (rx1233_cur)
  rx1233_restart:
.annotate 'line', 10
    if_null rx1233_debug, debug_1055
    rx1233_cur."!cursor_debug"("NEXT", "param_var")
  debug_1055:
  rx1233_fail:
    (rx1233_rep, rx1233_pos, $I10, $P10) = rx1233_cur."!mark_fail"(0)
    lt rx1233_pos, -1, rx1233_done
    eq rx1233_pos, -1, rx1233_fail
    jump $I10
  rx1233_done:
    rx1233_cur."!cursor_fail"()
    if_null rx1233_debug, debug_1056
    rx1233_cur."!cursor_debug"("FAIL", "param_var")
  debug_1056:
    .return (rx1233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :subid("201_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1240 = self."!PREFIX__!subrule"("sigil", "")
    new $P1241, "ResizablePMCArray"
    push $P1241, $P1240
    .return ($P1241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("202_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1243_tgt
    .local int rx1243_pos
    .local int rx1243_off
    .local int rx1243_eos
    .local int rx1243_rep
    .local pmc rx1243_cur
    .local pmc rx1243_debug
    (rx1243_cur, rx1243_pos, rx1243_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1243_cur
    .local pmc match
    .lex "$/", match
    length rx1243_eos, rx1243_tgt
    gt rx1243_pos, rx1243_eos, rx1243_done
    set rx1243_off, 0
    lt rx1243_pos, 2, rx1243_start
    sub rx1243_off, rx1243_pos, 1
    substr rx1243_tgt, rx1243_tgt, rx1243_off
  rx1243_start:
    eq $I10, 1, rx1243_restart
    if_null rx1243_debug, debug_1057
    rx1243_cur."!cursor_debug"("START", "named_param")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1244_done
    goto rxscan1244_scan
  rxscan1244_loop:
    (rx1243_pos) = rx1243_cur."from"()
    inc rx1243_pos
    rx1243_cur."!cursor_from"(rx1243_pos)
    ge rx1243_pos, rx1243_eos, rxscan1244_done
  rxscan1244_scan:
    set_addr $I10, rxscan1244_loop
    rx1243_cur."!mark_push"(0, rx1243_pos, $I10)
  rxscan1244_done:
.annotate 'line', 487
  # rx literal  ":"
    add $I11, rx1243_pos, 1
    gt $I11, rx1243_eos, rx1243_fail
    sub $I11, rx1243_pos, rx1243_off
    ord $I11, rx1243_tgt, $I11
    ne $I11, 58, rx1243_fail
    add rx1243_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1243_cur."!cursor_pos"(rx1243_pos)
    $P10 = rx1243_cur."param_var"()
    unless $P10, rx1243_fail
    rx1243_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1243_pos = $P10."pos"()
.annotate 'line', 486
  # rx pass
    rx1243_cur."!cursor_pass"(rx1243_pos, "named_param")
    if_null rx1243_debug, debug_1058
    rx1243_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1243_pos)
  debug_1058:
    .return (rx1243_cur)
  rx1243_restart:
.annotate 'line', 10
    if_null rx1243_debug, debug_1059
    rx1243_cur."!cursor_debug"("NEXT", "named_param")
  debug_1059:
  rx1243_fail:
    (rx1243_rep, rx1243_pos, $I10, $P10) = rx1243_cur."!mark_fail"(0)
    lt rx1243_pos, -1, rx1243_done
    eq rx1243_pos, -1, rx1243_fail
    jump $I10
  rx1243_done:
    rx1243_cur."!cursor_fail"()
    if_null rx1243_debug, debug_1060
    rx1243_cur."!cursor_debug"("FAIL", "named_param")
  debug_1060:
    .return (rx1243_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :subid("203_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1246 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("204_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1249_tgt
    .local int rx1249_pos
    .local int rx1249_off
    .local int rx1249_eos
    .local int rx1249_rep
    .local pmc rx1249_cur
    .local pmc rx1249_debug
    (rx1249_cur, rx1249_pos, rx1249_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1249_cur
    .local pmc match
    .lex "$/", match
    length rx1249_eos, rx1249_tgt
    gt rx1249_pos, rx1249_eos, rx1249_done
    set rx1249_off, 0
    lt rx1249_pos, 2, rx1249_start
    sub rx1249_off, rx1249_pos, 1
    substr rx1249_tgt, rx1249_tgt, rx1249_off
  rx1249_start:
    eq $I10, 1, rx1249_restart
    if_null rx1249_debug, debug_1061
    rx1249_cur."!cursor_debug"("START", "default_value")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1250_done
    goto rxscan1250_scan
  rxscan1250_loop:
    (rx1249_pos) = rx1249_cur."from"()
    inc rx1249_pos
    rx1249_cur."!cursor_from"(rx1249_pos)
    ge rx1249_pos, rx1249_eos, rxscan1250_done
  rxscan1250_scan:
    set_addr $I10, rxscan1250_loop
    rx1249_cur."!mark_push"(0, rx1249_pos, $I10)
  rxscan1250_done:
.annotate 'line', 490
  # rx subrule "ws" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."ws"()
    unless $P10, rx1249_fail
    rx1249_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1249_pos, 1
    gt $I11, rx1249_eos, rx1249_fail
    sub $I11, rx1249_pos, rx1249_off
    ord $I11, rx1249_tgt, $I11
    ne $I11, 61, rx1249_fail
    add rx1249_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."ws"()
    unless $P10, rx1249_fail
    rx1249_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."EXPR"("i=")
    unless $P10, rx1249_fail
    rx1249_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1249_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1249_cur."!cursor_pos"(rx1249_pos)
    $P10 = rx1249_cur."ws"()
    unless $P10, rx1249_fail
    rx1249_pos = $P10."pos"()
  # rx pass
    rx1249_cur."!cursor_pass"(rx1249_pos, "default_value")
    if_null rx1249_debug, debug_1062
    rx1249_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1249_pos)
  debug_1062:
    .return (rx1249_cur)
  rx1249_restart:
.annotate 'line', 10
    if_null rx1249_debug, debug_1063
    rx1249_cur."!cursor_debug"("NEXT", "default_value")
  debug_1063:
  rx1249_fail:
    (rx1249_rep, rx1249_pos, $I10, $P10) = rx1249_cur."!mark_fail"(0)
    lt rx1249_pos, -1, rx1249_done
    eq rx1249_pos, -1, rx1249_fail
    jump $I10
  rx1249_done:
    rx1249_cur."!cursor_fail"()
    if_null rx1249_debug, debug_1064
    rx1249_cur."!cursor_debug"("FAIL", "default_value")
  debug_1064:
    .return (rx1249_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :subid("205_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1255 = self."!PREFIX__!subrule"("ws", "")
    new $P1256, "ResizablePMCArray"
    push $P1256, $P1255
    .return ($P1256)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("206_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1258_tgt
    .local int rx1258_pos
    .local int rx1258_off
    .local int rx1258_eos
    .local int rx1258_rep
    .local pmc rx1258_cur
    .local pmc rx1258_debug
    (rx1258_cur, rx1258_pos, rx1258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1258_cur
    .local pmc match
    .lex "$/", match
    length rx1258_eos, rx1258_tgt
    gt rx1258_pos, rx1258_eos, rx1258_done
    set rx1258_off, 0
    lt rx1258_pos, 2, rx1258_start
    sub rx1258_off, rx1258_pos, 1
    substr rx1258_tgt, rx1258_tgt, rx1258_off
  rx1258_start:
    eq $I10, 1, rx1258_restart
    if_null rx1258_debug, debug_1065
    rx1258_cur."!cursor_debug"("START", "trait")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1259_done
    goto rxscan1259_scan
  rxscan1259_loop:
    (rx1258_pos) = rx1258_cur."from"()
    inc rx1258_pos
    rx1258_cur."!cursor_from"(rx1258_pos)
    ge rx1258_pos, rx1258_eos, rxscan1259_done
  rxscan1259_scan:
    set_addr $I10, rxscan1259_loop
    rx1258_cur."!mark_push"(0, rx1258_pos, $I10)
  rxscan1259_done:
.annotate 'line', 492
  # rx subrule "ws" subtype=method negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."ws"()
    unless $P10, rx1258_fail
    rx1258_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."trait_mod"()
    unless $P10, rx1258_fail
    rx1258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1258_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1258_cur."!cursor_pos"(rx1258_pos)
    $P10 = rx1258_cur."ws"()
    unless $P10, rx1258_fail
    rx1258_pos = $P10."pos"()
  # rx pass
    rx1258_cur."!cursor_pass"(rx1258_pos, "trait")
    if_null rx1258_debug, debug_1066
    rx1258_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1258_pos)
  debug_1066:
    .return (rx1258_cur)
  rx1258_restart:
.annotate 'line', 10
    if_null rx1258_debug, debug_1067
    rx1258_cur."!cursor_debug"("NEXT", "trait")
  debug_1067:
  rx1258_fail:
    (rx1258_rep, rx1258_pos, $I10, $P10) = rx1258_cur."!mark_fail"(0)
    lt rx1258_pos, -1, rx1258_done
    eq rx1258_pos, -1, rx1258_fail
    jump $I10
  rx1258_done:
    rx1258_cur."!cursor_fail"()
    if_null rx1258_debug, debug_1068
    rx1258_cur."!cursor_debug"("FAIL", "trait")
  debug_1068:
    .return (rx1258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :subid("207_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1263 = self."!PREFIX__!subrule"("ws", "")
    new $P1264, "ResizablePMCArray"
    push $P1264, $P1263
    .return ($P1264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("208_1304516047.681")
    .param pmc param_1266
.annotate 'line', 494
    .lex "self", param_1266
    $P1267 = param_1266."!protoregex"("trait_mod")
    .return ($P1267)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("209_1304516047.681")
    .param pmc param_1269
.annotate 'line', 494
    .lex "self", param_1269
    $P1270 = param_1269."!PREFIX__!protoregex"("trait_mod")
    .return ($P1270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("210_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1272_tgt
    .local int rx1272_pos
    .local int rx1272_off
    .local int rx1272_eos
    .local int rx1272_rep
    .local pmc rx1272_cur
    .local pmc rx1272_debug
    (rx1272_cur, rx1272_pos, rx1272_tgt, $I10) = self."!cursor_start"()
    rx1272_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1272_cur
    .local pmc match
    .lex "$/", match
    length rx1272_eos, rx1272_tgt
    gt rx1272_pos, rx1272_eos, rx1272_done
    set rx1272_off, 0
    lt rx1272_pos, 2, rx1272_start
    sub rx1272_off, rx1272_pos, 1
    substr rx1272_tgt, rx1272_tgt, rx1272_off
  rx1272_start:
    eq $I10, 1, rx1272_restart
    if_null rx1272_debug, debug_1069
    rx1272_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1273_done
    goto rxscan1273_scan
  rxscan1273_loop:
    (rx1272_pos) = rx1272_cur."from"()
    inc rx1272_pos
    rx1272_cur."!cursor_from"(rx1272_pos)
    ge rx1272_pos, rx1272_eos, rxscan1273_done
  rxscan1273_scan:
    set_addr $I10, rxscan1273_loop
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  rxscan1273_done:
.annotate 'line', 495
  # rx subcapture "sym"
    set_addr $I10, rxcap_1274_fail
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  # rx literal  "is"
    add $I11, rx1272_pos, 2
    gt $I11, rx1272_eos, rx1272_fail
    sub $I11, rx1272_pos, rx1272_off
    substr $S10, rx1272_tgt, $I11, 2
    ne $S10, "is", rx1272_fail
    add rx1272_pos, 2
    set_addr $I10, rxcap_1274_fail
    ($I12, $I11) = rx1272_cur."!mark_peek"($I10)
    rx1272_cur."!cursor_pos"($I11)
    ($P10) = rx1272_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1272_pos, "")
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1274_done
  rxcap_1274_fail:
    goto rx1272_fail
  rxcap_1274_done:
  # rx subrule "ws" subtype=method negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."ws"()
    unless $P10, rx1272_fail
    rx1272_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."deflongname"()
    unless $P10, rx1272_fail
    rx1272_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1272_pos = $P10."pos"()
  # rx rxquantr1276 ** 0..1
    set_addr $I10, rxquantr1276_done
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10)
  rxquantr1276_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."circumfix"()
    unless $P10, rx1272_fail
    goto rxsubrule1277_pass
  rxsubrule1277_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1272_fail
  rxsubrule1277_pass:
    set_addr $I10, rxsubrule1277_back
    rx1272_cur."!mark_push"(0, rx1272_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1272_pos = $P10."pos"()
    set_addr $I10, rxquantr1276_done
    (rx1272_rep) = rx1272_cur."!mark_commit"($I10)
  rxquantr1276_done:
  # rx subrule "ws" subtype=method negate=
    rx1272_cur."!cursor_pos"(rx1272_pos)
    $P10 = rx1272_cur."ws"()
    unless $P10, rx1272_fail
    rx1272_pos = $P10."pos"()
  # rx pass
    rx1272_cur."!cursor_pass"(rx1272_pos, "trait_mod:sym<is>")
    if_null rx1272_debug, debug_1070
    rx1272_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1272_pos)
  debug_1070:
    .return (rx1272_cur)
  rx1272_restart:
.annotate 'line', 10
    if_null rx1272_debug, debug_1071
    rx1272_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_1071:
  rx1272_fail:
    (rx1272_rep, rx1272_pos, $I10, $P10) = rx1272_cur."!mark_fail"(0)
    lt rx1272_pos, -1, rx1272_done
    eq rx1272_pos, -1, rx1272_fail
    jump $I10
  rx1272_done:
    rx1272_cur."!cursor_fail"()
    if_null rx1272_debug, debug_1072
    rx1272_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_1072:
    .return (rx1272_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :subid("211_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1280 = self."!PREFIX__!subrule"("ws", "is")
    new $P1281, "ResizablePMCArray"
    push $P1281, $P1280
    .return ($P1281)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("212_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1283_tgt
    .local int rx1283_pos
    .local int rx1283_off
    .local int rx1283_eos
    .local int rx1283_rep
    .local pmc rx1283_cur
    .local pmc rx1283_debug
    (rx1283_cur, rx1283_pos, rx1283_tgt, $I10) = self."!cursor_start"()
    rx1283_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1283_cur
    .local pmc match
    .lex "$/", match
    length rx1283_eos, rx1283_tgt
    gt rx1283_pos, rx1283_eos, rx1283_done
    set rx1283_off, 0
    lt rx1283_pos, 2, rx1283_start
    sub rx1283_off, rx1283_pos, 1
    substr rx1283_tgt, rx1283_tgt, rx1283_off
  rx1283_start:
    eq $I10, 1, rx1283_restart
    if_null rx1283_debug, debug_1073
    rx1283_cur."!cursor_debug"("START", "regex_declarator")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1284_done
    goto rxscan1284_scan
  rxscan1284_loop:
    (rx1283_pos) = rx1283_cur."from"()
    inc rx1283_pos
    rx1283_cur."!cursor_from"(rx1283_pos)
    ge rx1283_pos, rx1283_eos, rxscan1284_done
  rxscan1284_scan:
    set_addr $I10, rxscan1284_loop
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  rxscan1284_done:
.annotate 'line', 497
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1286_0:
.annotate 'line', 498
    set_addr $I10, alt1286_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
.annotate 'line', 499
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1288_fail
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "proto", rx1283_fail
    add rx1283_pos, 5
    set_addr $I10, rxcap_1288_fail
    ($I12, $I11) = rx1283_cur."!mark_peek"($I10)
    rx1283_cur."!cursor_pos"($I11)
    ($P10) = rx1283_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1283_pos, "")
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1288_done
  rxcap_1288_fail:
    goto rx1283_fail
  rxcap_1288_done:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1290_0:
    set_addr $I10, alt1290_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "regex", rx1283_fail
    add rx1283_pos, 5
    goto alt1290_end
  alt1290_1:
    set_addr $I10, alt1290_2
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "token"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "token", rx1283_fail
    add rx1283_pos, 5
    goto alt1290_end
  alt1290_2:
  # rx literal  "rule"
    add $I11, rx1283_pos, 4
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 4
    ne $S10, "rule", rx1283_fail
    add rx1283_pos, 4
  alt1290_end:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 500
  # rx subrule "deflongname" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."deflongname"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1293_0:
.annotate 'line', 501
    set_addr $I10, alt1293_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
.annotate 'line', 502
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 123, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "<...>", rx1283_fail
    add rx1283_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 125, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ENDSTMT"()
    unless $P10, rx1283_fail
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
    goto alt1293_end
  alt1293_1:
    set_addr $I10, alt1293_2
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
.annotate 'line', 503
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 123, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1283_pos, 3
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 3
    ne $S10, "<*>", rx1283_fail
    add rx1283_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 125, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ENDSTMT"()
    unless $P10, rx1283_fail
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
    goto alt1293_end
  alt1293_2:
.annotate 'line', 504
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1293_end:
.annotate 'line', 505
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 499
    goto alt1286_end
  alt1286_1:
.annotate 'line', 506
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1307_fail
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  alt1306_0:
    set_addr $I10, alt1306_1
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "regex", rx1283_fail
    add rx1283_pos, 5
    goto alt1306_end
  alt1306_1:
    set_addr $I10, alt1306_2
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  # rx literal  "token"
    add $I11, rx1283_pos, 5
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 5
    ne $S10, "token", rx1283_fail
    add rx1283_pos, 5
    goto alt1306_end
  alt1306_2:
  # rx literal  "rule"
    add $I11, rx1283_pos, 4
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    substr $S10, rx1283_tgt, $I11, 4
    ne $S10, "rule", rx1283_fail
    add rx1283_pos, 4
  alt1306_end:
    set_addr $I10, rxcap_1307_fail
    ($I12, $I11) = rx1283_cur."!mark_peek"($I10)
    rx1283_cur."!cursor_pos"($I11)
    ($P10) = rx1283_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1283_pos, "")
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1307_done
  rxcap_1307_fail:
    goto rx1283_fail
  rxcap_1307_done:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 507
  # rx subrule "deflongname" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."deflongname"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 508
  # rx subrule "newpad" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."newpad"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 509
  # rx rxquantr1311 ** 0..1
    set_addr $I10, rxquantr1311_done
    rx1283_cur."!mark_push"(0, rx1283_pos, $I10)
  rxquantr1311_loop:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 40, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."signature"()
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1283_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 41, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
    set_addr $I10, rxquantr1311_done
    (rx1283_rep) = rx1283_cur."!mark_commit"($I10)
  rxquantr1311_done:
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 510
  # rx reduce name="regex_declarator" key="open"
    rx1283_cur."!cursor_pos"(rx1283_pos)
    rx1283_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 511
  # rx literal  "{"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 123, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1283_fail
    rx1283_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1283_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1283_pos, 1
    gt $I11, rx1283_eos, rx1283_fail
    sub $I11, rx1283_pos, rx1283_off
    ord $I11, rx1283_tgt, $I11
    ne $I11, 125, rx1283_fail
    add rx1283_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ENDSTMT"()
    unless $P10, rx1283_fail
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
  alt1286_end:
.annotate 'line', 512
  # rx subrule "ws" subtype=method negate=
    rx1283_cur."!cursor_pos"(rx1283_pos)
    $P10 = rx1283_cur."ws"()
    unless $P10, rx1283_fail
    rx1283_pos = $P10."pos"()
.annotate 'line', 497
  # rx pass
    rx1283_cur."!cursor_pass"(rx1283_pos, "regex_declarator")
    if_null rx1283_debug, debug_1074
    rx1283_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1283_pos)
  debug_1074:
    .return (rx1283_cur)
  rx1283_restart:
.annotate 'line', 10
    if_null rx1283_debug, debug_1075
    rx1283_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_1075:
  rx1283_fail:
    (rx1283_rep, rx1283_pos, $I10, $P10) = rx1283_cur."!mark_fail"(0)
    lt rx1283_pos, -1, rx1283_done
    eq rx1283_pos, -1, rx1283_fail
    jump $I10
  rx1283_done:
    rx1283_cur."!cursor_fail"()
    if_null rx1283_debug, debug_1076
    rx1283_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_1076:
    .return (rx1283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :subid("213_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1321 = self."!PREFIX__!subrule"("ws", "")
    new $P1322, "ResizablePMCArray"
    push $P1322, $P1321
    .return ($P1322)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("214_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1324_tgt
    .local int rx1324_pos
    .local int rx1324_off
    .local int rx1324_eos
    .local int rx1324_rep
    .local pmc rx1324_cur
    .local pmc rx1324_debug
    (rx1324_cur, rx1324_pos, rx1324_tgt, $I10) = self."!cursor_start"()
    rx1324_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1324_cur
    .local pmc match
    .lex "$/", match
    length rx1324_eos, rx1324_tgt
    gt rx1324_pos, rx1324_eos, rx1324_done
    set rx1324_off, 0
    lt rx1324_pos, 2, rx1324_start
    sub rx1324_off, rx1324_pos, 1
    substr rx1324_tgt, rx1324_tgt, rx1324_off
  rx1324_start:
    eq $I10, 1, rx1324_restart
    if_null rx1324_debug, debug_1077
    rx1324_cur."!cursor_debug"("START", "dotty")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1325_done
    goto rxscan1325_scan
  rxscan1325_loop:
    (rx1324_pos) = rx1324_cur."from"()
    inc rx1324_pos
    rx1324_cur."!cursor_from"(rx1324_pos)
    ge rx1324_pos, rx1324_eos, rxscan1325_done
  rxscan1325_scan:
    set_addr $I10, rxscan1325_loop
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  rxscan1325_done:
.annotate 'line', 516
  # rx literal  "."
    add $I11, rx1324_pos, 1
    gt $I11, rx1324_eos, rx1324_fail
    sub $I11, rx1324_pos, rx1324_off
    ord $I11, rx1324_tgt, $I11
    ne $I11, 46, rx1324_fail
    add rx1324_pos, 1
  alt1326_0:
.annotate 'line', 517
    set_addr $I10, alt1326_1
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."deflongname"()
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1324_pos = $P10."pos"()
    goto alt1326_end
  alt1326_1:
.annotate 'line', 518
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1324_pos, rx1324_off
    substr $S10, rx1324_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1324_fail
  # rx subrule "quote" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."quote"()
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1324_pos = $P10."pos"()
  alt1327_0:
.annotate 'line', 519
    set_addr $I10, alt1327_1
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1324_pos, rx1324_off
    substr $S10, rx1324_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1324_fail
    goto alt1327_end
  alt1327_1:
  # rx subrule "panic" subtype=method negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1324_fail
    rx1324_pos = $P10."pos"()
  alt1327_end:
  alt1326_end:
.annotate 'line', 525
  # rx rxquantr1328 ** 0..1
    set_addr $I10, rxquantr1328_done
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
  rxquantr1328_loop:
  alt1329_0:
.annotate 'line', 522
    set_addr $I10, alt1329_1
    rx1324_cur."!mark_push"(0, rx1324_pos, $I10)
.annotate 'line', 523
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1324_pos, rx1324_off
    substr $S10, rx1324_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1324_fail
  # rx subrule "args" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."args"()
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1324_pos = $P10."pos"()
    goto alt1329_end
  alt1329_1:
.annotate 'line', 524
  # rx literal  ":"
    add $I11, rx1324_pos, 1
    gt $I11, rx1324_eos, rx1324_fail
    sub $I11, rx1324_pos, rx1324_off
    ord $I11, rx1324_tgt, $I11
    ne $I11, 58, rx1324_fail
    add rx1324_pos, 1
  # rx charclass s
    ge rx1324_pos, rx1324_eos, rx1324_fail
    sub $I10, rx1324_pos, rx1324_off
    is_cclass $I11, 32, rx1324_tgt, $I10
    unless $I11, rx1324_fail
    inc rx1324_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1324_cur."!cursor_pos"(rx1324_pos)
    $P10 = rx1324_cur."arglist"()
    unless $P10, rx1324_fail
    rx1324_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1324_pos = $P10."pos"()
  alt1329_end:
.annotate 'line', 525
    set_addr $I10, rxquantr1328_done
    (rx1324_rep) = rx1324_cur."!mark_commit"($I10)
  rxquantr1328_done:
.annotate 'line', 515
  # rx pass
    rx1324_cur."!cursor_pass"(rx1324_pos, "dotty")
    if_null rx1324_debug, debug_1078
    rx1324_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1324_pos)
  debug_1078:
    .return (rx1324_cur)
  rx1324_restart:
.annotate 'line', 10
    if_null rx1324_debug, debug_1079
    rx1324_cur."!cursor_debug"("NEXT", "dotty")
  debug_1079:
  rx1324_fail:
    (rx1324_rep, rx1324_pos, $I10, $P10) = rx1324_cur."!mark_fail"(0)
    lt rx1324_pos, -1, rx1324_done
    eq rx1324_pos, -1, rx1324_fail
    jump $I10
  rx1324_done:
    rx1324_cur."!cursor_fail"()
    if_null rx1324_debug, debug_1080
    rx1324_cur."!cursor_debug"("FAIL", "dotty")
  debug_1080:
    .return (rx1324_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :subid("215_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1331 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1332, "ResizablePMCArray"
    push $P1332, "'"
    push $P1332, "\""
    push $P1332, $P1331
    .return ($P1332)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("216_1304516047.681")
    .param pmc param_1334
.annotate 'line', 529
    .lex "self", param_1334
    $P1335 = param_1334."!protoregex"("term")
    .return ($P1335)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("217_1304516047.681")
    .param pmc param_1337
.annotate 'line', 529
    .lex "self", param_1337
    $P1338 = param_1337."!PREFIX__!protoregex"("term")
    .return ($P1338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("218_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1340_tgt
    .local int rx1340_pos
    .local int rx1340_off
    .local int rx1340_eos
    .local int rx1340_rep
    .local pmc rx1340_cur
    .local pmc rx1340_debug
    (rx1340_cur, rx1340_pos, rx1340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1340_cur
    .local pmc match
    .lex "$/", match
    length rx1340_eos, rx1340_tgt
    gt rx1340_pos, rx1340_eos, rx1340_done
    set rx1340_off, 0
    lt rx1340_pos, 2, rx1340_start
    sub rx1340_off, rx1340_pos, 1
    substr rx1340_tgt, rx1340_tgt, rx1340_off
  rx1340_start:
    eq $I10, 1, rx1340_restart
    if_null rx1340_debug, debug_1081
    rx1340_cur."!cursor_debug"("START", "term:sym<self>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1341_done
    goto rxscan1341_scan
  rxscan1341_loop:
    (rx1340_pos) = rx1340_cur."from"()
    inc rx1340_pos
    rx1340_cur."!cursor_from"(rx1340_pos)
    ge rx1340_pos, rx1340_eos, rxscan1341_done
  rxscan1341_scan:
    set_addr $I10, rxscan1341_loop
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxscan1341_done:
.annotate 'line', 531
  # rx subcapture "sym"
    set_addr $I10, rxcap_1342_fail
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  # rx literal  "self"
    add $I11, rx1340_pos, 4
    gt $I11, rx1340_eos, rx1340_fail
    sub $I11, rx1340_pos, rx1340_off
    substr $S10, rx1340_tgt, $I11, 4
    ne $S10, "self", rx1340_fail
    add rx1340_pos, 4
    set_addr $I10, rxcap_1342_fail
    ($I12, $I11) = rx1340_cur."!mark_peek"($I10)
    rx1340_cur."!cursor_pos"($I11)
    ($P10) = rx1340_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1340_pos, "")
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1342_done
  rxcap_1342_fail:
    goto rx1340_fail
  rxcap_1342_done:
  # rxanchor rwb
    le rx1340_pos, 0, rx1340_fail
    sub $I10, rx1340_pos, rx1340_off
    is_cclass $I11, 8192, rx1340_tgt, $I10
    if $I11, rx1340_fail
    dec $I10
    is_cclass $I11, 8192, rx1340_tgt, $I10
    unless $I11, rx1340_fail
  # rx pass
    rx1340_cur."!cursor_pass"(rx1340_pos, "term:sym<self>")
    if_null rx1340_debug, debug_1082
    rx1340_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1340_pos)
  debug_1082:
    .return (rx1340_cur)
  rx1340_restart:
.annotate 'line', 10
    if_null rx1340_debug, debug_1083
    rx1340_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_1083:
  rx1340_fail:
    (rx1340_rep, rx1340_pos, $I10, $P10) = rx1340_cur."!mark_fail"(0)
    lt rx1340_pos, -1, rx1340_done
    eq rx1340_pos, -1, rx1340_fail
    jump $I10
  rx1340_done:
    rx1340_cur."!cursor_fail"()
    if_null rx1340_debug, debug_1084
    rx1340_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_1084:
    .return (rx1340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :subid("219_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1344, "ResizablePMCArray"
    push $P1344, "self"
    .return ($P1344)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("220_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1346_tgt
    .local int rx1346_pos
    .local int rx1346_off
    .local int rx1346_eos
    .local int rx1346_rep
    .local pmc rx1346_cur
    .local pmc rx1346_debug
    (rx1346_cur, rx1346_pos, rx1346_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1346_cur
    .local pmc match
    .lex "$/", match
    length rx1346_eos, rx1346_tgt
    gt rx1346_pos, rx1346_eos, rx1346_done
    set rx1346_off, 0
    lt rx1346_pos, 2, rx1346_start
    sub rx1346_off, rx1346_pos, 1
    substr rx1346_tgt, rx1346_tgt, rx1346_off
  rx1346_start:
    eq $I10, 1, rx1346_restart
    if_null rx1346_debug, debug_1085
    rx1346_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1346_pos) = rx1346_cur."from"()
    inc rx1346_pos
    rx1346_cur."!cursor_from"(rx1346_pos)
    ge rx1346_pos, rx1346_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1346_cur."!mark_push"(0, rx1346_pos, $I10)
  rxscan1347_done:
.annotate 'line', 534
  # rx subrule "deflongname" subtype=capture negate=
    rx1346_cur."!cursor_pos"(rx1346_pos)
    $P10 = rx1346_cur."deflongname"()
    unless $P10, rx1346_fail
    rx1346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1346_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1346_pos, rx1346_off
    substr $S10, rx1346_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1346_fail
  # rx subrule "args" subtype=capture negate=
    rx1346_cur."!cursor_pos"(rx1346_pos)
    $P10 = rx1346_cur."args"()
    unless $P10, rx1346_fail
    rx1346_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1346_pos = $P10."pos"()
.annotate 'line', 533
  # rx pass
    rx1346_cur."!cursor_pass"(rx1346_pos, "term:sym<identifier>")
    if_null rx1346_debug, debug_1086
    rx1346_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1346_pos)
  debug_1086:
    .return (rx1346_cur)
  rx1346_restart:
.annotate 'line', 10
    if_null rx1346_debug, debug_1087
    rx1346_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_1087:
  rx1346_fail:
    (rx1346_rep, rx1346_pos, $I10, $P10) = rx1346_cur."!mark_fail"(0)
    lt rx1346_pos, -1, rx1346_done
    eq rx1346_pos, -1, rx1346_fail
    jump $I10
  rx1346_done:
    rx1346_cur."!cursor_fail"()
    if_null rx1346_debug, debug_1088
    rx1346_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_1088:
    .return (rx1346_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :subid("221_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1349 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1350, "ResizablePMCArray"
    push $P1350, $P1349
    .return ($P1350)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("222_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1352_tgt
    .local int rx1352_pos
    .local int rx1352_off
    .local int rx1352_eos
    .local int rx1352_rep
    .local pmc rx1352_cur
    .local pmc rx1352_debug
    (rx1352_cur, rx1352_pos, rx1352_tgt, $I10) = self."!cursor_start"()
    rx1352_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1352_cur
    .local pmc match
    .lex "$/", match
    length rx1352_eos, rx1352_tgt
    gt rx1352_pos, rx1352_eos, rx1352_done
    set rx1352_off, 0
    lt rx1352_pos, 2, rx1352_start
    sub rx1352_off, rx1352_pos, 1
    substr rx1352_tgt, rx1352_tgt, rx1352_off
  rx1352_start:
    eq $I10, 1, rx1352_restart
    if_null rx1352_debug, debug_1089
    rx1352_cur."!cursor_debug"("START", "term:sym<name>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1353_done
    goto rxscan1353_scan
  rxscan1353_loop:
    (rx1352_pos) = rx1352_cur."from"()
    inc rx1352_pos
    rx1352_cur."!cursor_from"(rx1352_pos)
    ge rx1352_pos, rx1352_eos, rxscan1353_done
  rxscan1353_scan:
    set_addr $I10, rxscan1353_loop
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxscan1353_done:
.annotate 'line', 538
  # rx subrule "name" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."name"()
    unless $P10, rx1352_fail
    rx1352_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1352_pos = $P10."pos"()
  # rx rxquantr1354 ** 0..1
    set_addr $I10, rxquantr1354_done
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10)
  rxquantr1354_loop:
  # rx subrule "args" subtype=capture negate=
    rx1352_cur."!cursor_pos"(rx1352_pos)
    $P10 = rx1352_cur."args"()
    unless $P10, rx1352_fail
    goto rxsubrule1355_pass
  rxsubrule1355_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1352_fail
  rxsubrule1355_pass:
    set_addr $I10, rxsubrule1355_back
    rx1352_cur."!mark_push"(0, rx1352_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1352_pos = $P10."pos"()
    set_addr $I10, rxquantr1354_done
    (rx1352_rep) = rx1352_cur."!mark_commit"($I10)
  rxquantr1354_done:
.annotate 'line', 537
  # rx pass
    rx1352_cur."!cursor_pass"(rx1352_pos, "term:sym<name>")
    if_null rx1352_debug, debug_1090
    rx1352_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1352_pos)
  debug_1090:
    .return (rx1352_cur)
  rx1352_restart:
.annotate 'line', 10
    if_null rx1352_debug, debug_1091
    rx1352_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1091:
  rx1352_fail:
    (rx1352_rep, rx1352_pos, $I10, $P10) = rx1352_cur."!mark_fail"(0)
    lt rx1352_pos, -1, rx1352_done
    eq rx1352_pos, -1, rx1352_fail
    jump $I10
  rx1352_done:
    rx1352_cur."!cursor_fail"()
    if_null rx1352_debug, debug_1092
    rx1352_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1092:
    .return (rx1352_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :subid("223_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1357 = self."!PREFIX__!subrule"("name", "")
    new $P1358, "ResizablePMCArray"
    push $P1358, $P1357
    .return ($P1358)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("224_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1360_tgt
    .local int rx1360_pos
    .local int rx1360_off
    .local int rx1360_eos
    .local int rx1360_rep
    .local pmc rx1360_cur
    .local pmc rx1360_debug
    (rx1360_cur, rx1360_pos, rx1360_tgt, $I10) = self."!cursor_start"()
    rx1360_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1360_cur
    .local pmc match
    .lex "$/", match
    length rx1360_eos, rx1360_tgt
    gt rx1360_pos, rx1360_eos, rx1360_done
    set rx1360_off, 0
    lt rx1360_pos, 2, rx1360_start
    sub rx1360_off, rx1360_pos, 1
    substr rx1360_tgt, rx1360_tgt, rx1360_off
  rx1360_start:
    eq $I10, 1, rx1360_restart
    if_null rx1360_debug, debug_1093
    rx1360_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1361_done
    goto rxscan1361_scan
  rxscan1361_loop:
    (rx1360_pos) = rx1360_cur."from"()
    inc rx1360_pos
    rx1360_cur."!cursor_from"(rx1360_pos)
    ge rx1360_pos, rx1360_eos, rxscan1361_done
  rxscan1361_scan:
    set_addr $I10, rxscan1361_loop
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  rxscan1361_done:
.annotate 'line', 542
  # rx literal  "pir::"
    add $I11, rx1360_pos, 5
    gt $I11, rx1360_eos, rx1360_fail
    sub $I11, rx1360_pos, rx1360_off
    substr $S10, rx1360_tgt, $I11, 5
    ne $S10, "pir::", rx1360_fail
    add rx1360_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1362_fail
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1360_pos, rx1360_off
    find_not_cclass $I11, 8192, rx1360_tgt, $I10, rx1360_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1360_fail
    add rx1360_pos, rx1360_off, $I11
    set_addr $I10, rxcap_1362_fail
    ($I12, $I11) = rx1360_cur."!mark_peek"($I10)
    rx1360_cur."!cursor_pos"($I11)
    ($P10) = rx1360_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1360_pos, "")
    rx1360_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1362_done
  rxcap_1362_fail:
    goto rx1360_fail
  rxcap_1362_done:
  # rx rxquantr1363 ** 0..1
    set_addr $I10, rxquantr1363_done
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10)
  rxquantr1363_loop:
  # rx subrule "args" subtype=capture negate=
    rx1360_cur."!cursor_pos"(rx1360_pos)
    $P10 = rx1360_cur."args"()
    unless $P10, rx1360_fail
    goto rxsubrule1364_pass
  rxsubrule1364_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1360_fail
  rxsubrule1364_pass:
    set_addr $I10, rxsubrule1364_back
    rx1360_cur."!mark_push"(0, rx1360_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1360_pos = $P10."pos"()
    set_addr $I10, rxquantr1363_done
    (rx1360_rep) = rx1360_cur."!mark_commit"($I10)
  rxquantr1363_done:
.annotate 'line', 541
  # rx pass
    rx1360_cur."!cursor_pass"(rx1360_pos, "term:sym<pir::op>")
    if_null rx1360_debug, debug_1094
    rx1360_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1360_pos)
  debug_1094:
    .return (rx1360_cur)
  rx1360_restart:
.annotate 'line', 10
    if_null rx1360_debug, debug_1095
    rx1360_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1095:
  rx1360_fail:
    (rx1360_rep, rx1360_pos, $I10, $P10) = rx1360_cur."!mark_fail"(0)
    lt rx1360_pos, -1, rx1360_done
    eq rx1360_pos, -1, rx1360_fail
    jump $I10
  rx1360_done:
    rx1360_cur."!cursor_fail"()
    if_null rx1360_debug, debug_1096
    rx1360_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1096:
    .return (rx1360_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :subid("225_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1366, "ResizablePMCArray"
    push $P1366, "pir::"
    .return ($P1366)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("226_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P1374 = "227_1304516047.681" 
    capture_lex $P1374
    .local string rx1368_tgt
    .local int rx1368_pos
    .local int rx1368_off
    .local int rx1368_eos
    .local int rx1368_rep
    .local pmc rx1368_cur
    .local pmc rx1368_debug
    (rx1368_cur, rx1368_pos, rx1368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1368_cur
    .local pmc match
    .lex "$/", match
    length rx1368_eos, rx1368_tgt
    gt rx1368_pos, rx1368_eos, rx1368_done
    set rx1368_off, 0
    lt rx1368_pos, 2, rx1368_start
    sub rx1368_off, rx1368_pos, 1
    substr rx1368_tgt, rx1368_tgt, rx1368_off
  rx1368_start:
    eq $I10, 1, rx1368_restart
    if_null rx1368_debug, debug_1097
    rx1368_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1369_done
    goto rxscan1369_scan
  rxscan1369_loop:
    (rx1368_pos) = rx1368_cur."from"()
    inc rx1368_pos
    rx1368_cur."!cursor_from"(rx1368_pos)
    ge rx1368_pos, rx1368_eos, rxscan1369_done
  rxscan1369_scan:
    set_addr $I10, rxscan1369_loop
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  rxscan1369_done:
.annotate 'line', 546
  # rx literal  "{*}"
    add $I11, rx1368_pos, 3
    gt $I11, rx1368_eos, rx1368_fail
    sub $I11, rx1368_pos, rx1368_off
    substr $S10, rx1368_tgt, $I11, 3
    ne $S10, "{*}", rx1368_fail
    add rx1368_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1368_cur."!cursor_pos"(rx1368_pos)
    $P10 = rx1368_cur."ENDSTMT"()
    unless $P10, rx1368_fail
  alt1370_0:
.annotate 'line', 547
    set_addr $I10, alt1370_1
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
    rx1368_cur."!cursor_pos"(rx1368_pos)
    find_lex $P1371, unicode:"$\x{a2}"
    $P1372 = $P1371."MATCH"()
    store_lex "$/", $P1372
    .const 'Sub' $P1374 = "227_1304516047.681" 
    capture_lex $P1374
    $P1380 = $P1374()
    unless $P1380, rx1368_fail
    goto alt1370_end
  alt1370_1:
  # rx subrule "panic" subtype=method negate=
    rx1368_cur."!cursor_pos"(rx1368_pos)
    $P10 = rx1368_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1368_fail
    rx1368_pos = $P10."pos"()
  alt1370_end:
.annotate 'line', 545
  # rx pass
    rx1368_cur."!cursor_pass"(rx1368_pos, "term:sym<onlystar>")
    if_null rx1368_debug, debug_1100
    rx1368_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1368_pos)
  debug_1100:
    .return (rx1368_cur)
  rx1368_restart:
.annotate 'line', 10
    if_null rx1368_debug, debug_1101
    rx1368_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1101:
  rx1368_fail:
    (rx1368_rep, rx1368_pos, $I10, $P10) = rx1368_cur."!mark_fail"(0)
    lt rx1368_pos, -1, rx1368_done
    eq rx1368_pos, -1, rx1368_fail
    jump $I10
  rx1368_done:
    rx1368_cur."!cursor_fail"()
    if_null rx1368_debug, debug_1102
    rx1368_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1102:
    .return (rx1368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1373"  :anon :subid("227_1304516047.681") :outer("226_1304516047.681")
.annotate 'line', 547
    find_dynamic_lex $P1377, "$*MULTINESS"
    unless_null $P1377, vivify_1098
    get_hll_global $P1375, "GLOBAL"
    get_who $P1376, $P1375
    set $P1377, $P1376["$MULTINESS"]
    unless_null $P1377, vivify_1099
    die "Contextual $*MULTINESS not found"
  vivify_1099:
  vivify_1098:
    set $S1378, $P1377
    iseq $I1379, $S1378, "proto"
    .return ($I1379)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :subid("228_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1382, "ResizablePMCArray"
    push $P1382, "{*}"
    .return ($P1382)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("229_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1384_tgt
    .local int rx1384_pos
    .local int rx1384_off
    .local int rx1384_eos
    .local int rx1384_rep
    .local pmc rx1384_cur
    .local pmc rx1384_debug
    (rx1384_cur, rx1384_pos, rx1384_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1384_cur
    .local pmc match
    .lex "$/", match
    length rx1384_eos, rx1384_tgt
    gt rx1384_pos, rx1384_eos, rx1384_done
    set rx1384_off, 0
    lt rx1384_pos, 2, rx1384_start
    sub rx1384_off, rx1384_pos, 1
    substr rx1384_tgt, rx1384_tgt, rx1384_off
  rx1384_start:
    eq $I10, 1, rx1384_restart
    if_null rx1384_debug, debug_1103
    rx1384_cur."!cursor_debug"("START", "args")
  debug_1103:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1385_done
    goto rxscan1385_scan
  rxscan1385_loop:
    (rx1384_pos) = rx1384_cur."from"()
    inc rx1384_pos
    rx1384_cur."!cursor_from"(rx1384_pos)
    ge rx1384_pos, rx1384_eos, rxscan1385_done
  rxscan1385_scan:
    set_addr $I10, rxscan1385_loop
    rx1384_cur."!mark_push"(0, rx1384_pos, $I10)
  rxscan1385_done:
.annotate 'line', 551
  # rx literal  "("
    add $I11, rx1384_pos, 1
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    ord $I11, rx1384_tgt, $I11
    ne $I11, 40, rx1384_fail
    add rx1384_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1384_cur."!cursor_pos"(rx1384_pos)
    $P10 = rx1384_cur."arglist"()
    unless $P10, rx1384_fail
    rx1384_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1384_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1384_pos, 1
    gt $I11, rx1384_eos, rx1384_fail
    sub $I11, rx1384_pos, rx1384_off
    ord $I11, rx1384_tgt, $I11
    ne $I11, 41, rx1384_fail
    add rx1384_pos, 1
  # rx pass
    rx1384_cur."!cursor_pass"(rx1384_pos, "args")
    if_null rx1384_debug, debug_1104
    rx1384_cur."!cursor_debug"("PASS", "args", " at pos=", rx1384_pos)
  debug_1104:
    .return (rx1384_cur)
  rx1384_restart:
.annotate 'line', 10
    if_null rx1384_debug, debug_1105
    rx1384_cur."!cursor_debug"("NEXT", "args")
  debug_1105:
  rx1384_fail:
    (rx1384_rep, rx1384_pos, $I10, $P10) = rx1384_cur."!mark_fail"(0)
    lt rx1384_pos, -1, rx1384_done
    eq rx1384_pos, -1, rx1384_fail
    jump $I10
  rx1384_done:
    rx1384_cur."!cursor_fail"()
    if_null rx1384_debug, debug_1106
    rx1384_cur."!cursor_debug"("FAIL", "args")
  debug_1106:
    .return (rx1384_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :subid("230_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1387 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1388, "ResizablePMCArray"
    push $P1388, $P1387
    .return ($P1388)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("231_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1390_tgt
    .local int rx1390_pos
    .local int rx1390_off
    .local int rx1390_eos
    .local int rx1390_rep
    .local pmc rx1390_cur
    .local pmc rx1390_debug
    (rx1390_cur, rx1390_pos, rx1390_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1390_cur
    .local pmc match
    .lex "$/", match
    length rx1390_eos, rx1390_tgt
    gt rx1390_pos, rx1390_eos, rx1390_done
    set rx1390_off, 0
    lt rx1390_pos, 2, rx1390_start
    sub rx1390_off, rx1390_pos, 1
    substr rx1390_tgt, rx1390_tgt, rx1390_off
  rx1390_start:
    eq $I10, 1, rx1390_restart
    if_null rx1390_debug, debug_1107
    rx1390_cur."!cursor_debug"("START", "arglist")
  debug_1107:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1391_done
    goto rxscan1391_scan
  rxscan1391_loop:
    (rx1390_pos) = rx1390_cur."from"()
    inc rx1390_pos
    rx1390_cur."!cursor_from"(rx1390_pos)
    ge rx1390_pos, rx1390_eos, rxscan1391_done
  rxscan1391_scan:
    set_addr $I10, rxscan1391_loop
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
  rxscan1391_done:
.annotate 'line', 555
  # rx subrule "ws" subtype=method negate=
    rx1390_cur."!cursor_pos"(rx1390_pos)
    $P10 = rx1390_cur."ws"()
    unless $P10, rx1390_fail
    rx1390_pos = $P10."pos"()
  alt1392_0:
.annotate 'line', 556
    set_addr $I10, alt1392_1
    rx1390_cur."!mark_push"(0, rx1390_pos, $I10)
.annotate 'line', 557
  # rx subrule "EXPR" subtype=capture negate=
    rx1390_cur."!cursor_pos"(rx1390_pos)
    $P10 = rx1390_cur."EXPR"("f=")
    unless $P10, rx1390_fail
    rx1390_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1390_pos = $P10."pos"()
    goto alt1392_end
  alt1392_1:
  alt1392_end:
.annotate 'line', 554
  # rx pass
    rx1390_cur."!cursor_pass"(rx1390_pos, "arglist")
    if_null rx1390_debug, debug_1108
    rx1390_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1390_pos)
  debug_1108:
    .return (rx1390_cur)
  rx1390_restart:
.annotate 'line', 10
    if_null rx1390_debug, debug_1109
    rx1390_cur."!cursor_debug"("NEXT", "arglist")
  debug_1109:
  rx1390_fail:
    (rx1390_rep, rx1390_pos, $I10, $P10) = rx1390_cur."!mark_fail"(0)
    lt rx1390_pos, -1, rx1390_done
    eq rx1390_pos, -1, rx1390_fail
    jump $I10
  rx1390_done:
    rx1390_cur."!cursor_fail"()
    if_null rx1390_debug, debug_1110
    rx1390_cur."!cursor_debug"("FAIL", "arglist")
  debug_1110:
    .return (rx1390_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :subid("232_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1394 = self."!PREFIX__!subrule"("ws", "")
    new $P1395, "ResizablePMCArray"
    push $P1395, $P1394
    .return ($P1395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("233_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1397_tgt
    .local int rx1397_pos
    .local int rx1397_off
    .local int rx1397_eos
    .local int rx1397_rep
    .local pmc rx1397_cur
    .local pmc rx1397_debug
    (rx1397_cur, rx1397_pos, rx1397_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1397_cur
    .local pmc match
    .lex "$/", match
    length rx1397_eos, rx1397_tgt
    gt rx1397_pos, rx1397_eos, rx1397_done
    set rx1397_off, 0
    lt rx1397_pos, 2, rx1397_start
    sub rx1397_off, rx1397_pos, 1
    substr rx1397_tgt, rx1397_tgt, rx1397_off
  rx1397_start:
    eq $I10, 1, rx1397_restart
    if_null rx1397_debug, debug_1111
    rx1397_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1111:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1398_done
    goto rxscan1398_scan
  rxscan1398_loop:
    (rx1397_pos) = rx1397_cur."from"()
    inc rx1397_pos
    rx1397_cur."!cursor_from"(rx1397_pos)
    ge rx1397_pos, rx1397_eos, rxscan1398_done
  rxscan1398_scan:
    set_addr $I10, rxscan1398_loop
    rx1397_cur."!mark_push"(0, rx1397_pos, $I10)
  rxscan1398_done:
.annotate 'line', 563
  # rx subrule "value" subtype=capture negate=
    rx1397_cur."!cursor_pos"(rx1397_pos)
    $P10 = rx1397_cur."value"()
    unless $P10, rx1397_fail
    rx1397_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1397_pos = $P10."pos"()
  # rx pass
    rx1397_cur."!cursor_pass"(rx1397_pos, "term:sym<value>")
    if_null rx1397_debug, debug_1112
    rx1397_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1397_pos)
  debug_1112:
    .return (rx1397_cur)
  rx1397_restart:
.annotate 'line', 10
    if_null rx1397_debug, debug_1113
    rx1397_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1113:
  rx1397_fail:
    (rx1397_rep, rx1397_pos, $I10, $P10) = rx1397_cur."!mark_fail"(0)
    lt rx1397_pos, -1, rx1397_done
    eq rx1397_pos, -1, rx1397_fail
    jump $I10
  rx1397_done:
    rx1397_cur."!cursor_fail"()
    if_null rx1397_debug, debug_1114
    rx1397_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1114:
    .return (rx1397_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :subid("234_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1400 = self."!PREFIX__!subrule"("value", "")
    new $P1401, "ResizablePMCArray"
    push $P1401, $P1400
    .return ($P1401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("235_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1403_tgt
    .local int rx1403_pos
    .local int rx1403_off
    .local int rx1403_eos
    .local int rx1403_rep
    .local pmc rx1403_cur
    .local pmc rx1403_debug
    (rx1403_cur, rx1403_pos, rx1403_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1403_cur
    .local pmc match
    .lex "$/", match
    length rx1403_eos, rx1403_tgt
    gt rx1403_pos, rx1403_eos, rx1403_done
    set rx1403_off, 0
    lt rx1403_pos, 2, rx1403_start
    sub rx1403_off, rx1403_pos, 1
    substr rx1403_tgt, rx1403_tgt, rx1403_off
  rx1403_start:
    eq $I10, 1, rx1403_restart
    if_null rx1403_debug, debug_1115
    rx1403_cur."!cursor_debug"("START", "value")
  debug_1115:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1404_done
    goto rxscan1404_scan
  rxscan1404_loop:
    (rx1403_pos) = rx1403_cur."from"()
    inc rx1403_pos
    rx1403_cur."!cursor_from"(rx1403_pos)
    ge rx1403_pos, rx1403_eos, rxscan1404_done
  rxscan1404_scan:
    set_addr $I10, rxscan1404_loop
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
  rxscan1404_done:
  alt1405_0:
.annotate 'line', 565
    set_addr $I10, alt1405_1
    rx1403_cur."!mark_push"(0, rx1403_pos, $I10)
.annotate 'line', 566
  # rx subrule "quote" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."quote"()
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1403_pos = $P10."pos"()
    goto alt1405_end
  alt1405_1:
.annotate 'line', 567
  # rx subrule "number" subtype=capture negate=
    rx1403_cur."!cursor_pos"(rx1403_pos)
    $P10 = rx1403_cur."number"()
    unless $P10, rx1403_fail
    rx1403_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1403_pos = $P10."pos"()
  alt1405_end:
.annotate 'line', 565
  # rx pass
    rx1403_cur."!cursor_pass"(rx1403_pos, "value")
    if_null rx1403_debug, debug_1116
    rx1403_cur."!cursor_debug"("PASS", "value", " at pos=", rx1403_pos)
  debug_1116:
    .return (rx1403_cur)
  rx1403_restart:
.annotate 'line', 10
    if_null rx1403_debug, debug_1117
    rx1403_cur."!cursor_debug"("NEXT", "value")
  debug_1117:
  rx1403_fail:
    (rx1403_rep, rx1403_pos, $I10, $P10) = rx1403_cur."!mark_fail"(0)
    lt rx1403_pos, -1, rx1403_done
    eq rx1403_pos, -1, rx1403_fail
    jump $I10
  rx1403_done:
    rx1403_cur."!cursor_fail"()
    if_null rx1403_debug, debug_1118
    rx1403_cur."!cursor_debug"("FAIL", "value")
  debug_1118:
    .return (rx1403_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :subid("236_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1407 = self."!PREFIX__!subrule"("number", "")
    $P1408 = self."!PREFIX__!subrule"("quote", "")
    new $P1409, "ResizablePMCArray"
    push $P1409, $P1407
    push $P1409, $P1408
    .return ($P1409)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("237_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1411_tgt
    .local int rx1411_pos
    .local int rx1411_off
    .local int rx1411_eos
    .local int rx1411_rep
    .local pmc rx1411_cur
    .local pmc rx1411_debug
    (rx1411_cur, rx1411_pos, rx1411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1411_cur
    .local pmc match
    .lex "$/", match
    length rx1411_eos, rx1411_tgt
    gt rx1411_pos, rx1411_eos, rx1411_done
    set rx1411_off, 0
    lt rx1411_pos, 2, rx1411_start
    sub rx1411_off, rx1411_pos, 1
    substr rx1411_tgt, rx1411_tgt, rx1411_off
  rx1411_start:
    eq $I10, 1, rx1411_restart
    if_null rx1411_debug, debug_1119
    rx1411_cur."!cursor_debug"("START", "number")
  debug_1119:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1412_done
    goto rxscan1412_scan
  rxscan1412_loop:
    (rx1411_pos) = rx1411_cur."from"()
    inc rx1411_pos
    rx1411_cur."!cursor_from"(rx1411_pos)
    ge rx1411_pos, rx1411_eos, rxscan1412_done
  rxscan1412_scan:
    set_addr $I10, rxscan1412_loop
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  rxscan1412_done:
.annotate 'line', 571
  # rx subcapture "sign"
    set_addr $I10, rxcap_1414_fail
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1411_pos, rx1411_off
    set rx1411_rep, 0
    sub $I12, rx1411_eos, rx1411_pos
    le $I12, 1, rxenumcharlistq1413_loop
    set $I12, 1
  rxenumcharlistq1413_loop:
    le $I12, 0, rxenumcharlistq1413_done
    substr $S10, rx1411_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1413_done
    inc rx1411_rep
  rxenumcharlistq1413_done:
    add rx1411_pos, rx1411_pos, rx1411_rep
    set_addr $I10, rxcap_1414_fail
    ($I12, $I11) = rx1411_cur."!mark_peek"($I10)
    rx1411_cur."!cursor_pos"($I11)
    ($P10) = rx1411_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1411_pos, "")
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1414_done
  rxcap_1414_fail:
    goto rx1411_fail
  rxcap_1414_done:
  alt1415_0:
.annotate 'line', 572
    set_addr $I10, alt1415_1
    rx1411_cur."!mark_push"(0, rx1411_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."dec_number"()
    unless $P10, rx1411_fail
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1411_pos = $P10."pos"()
    goto alt1415_end
  alt1415_1:
  # rx subrule "integer" subtype=capture negate=
    rx1411_cur."!cursor_pos"(rx1411_pos)
    $P10 = rx1411_cur."integer"()
    unless $P10, rx1411_fail
    rx1411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1411_pos = $P10."pos"()
  alt1415_end:
.annotate 'line', 570
  # rx pass
    rx1411_cur."!cursor_pass"(rx1411_pos, "number")
    if_null rx1411_debug, debug_1120
    rx1411_cur."!cursor_debug"("PASS", "number", " at pos=", rx1411_pos)
  debug_1120:
    .return (rx1411_cur)
  rx1411_restart:
.annotate 'line', 10
    if_null rx1411_debug, debug_1121
    rx1411_cur."!cursor_debug"("NEXT", "number")
  debug_1121:
  rx1411_fail:
    (rx1411_rep, rx1411_pos, $I10, $P10) = rx1411_cur."!mark_fail"(0)
    lt rx1411_pos, -1, rx1411_done
    eq rx1411_pos, -1, rx1411_fail
    jump $I10
  rx1411_done:
    rx1411_cur."!cursor_fail"()
    if_null rx1411_debug, debug_1122
    rx1411_cur."!cursor_debug"("FAIL", "number")
  debug_1122:
    .return (rx1411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :subid("238_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1417, "ResizablePMCArray"
    push $P1417, ""
    .return ($P1417)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("239_1304516047.681")
    .param pmc param_1419
.annotate 'line', 575
    .lex "self", param_1419
    $P1420 = param_1419."!protoregex"("quote")
    .return ($P1420)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("240_1304516047.681")
    .param pmc param_1422
.annotate 'line', 575
    .lex "self", param_1422
    $P1423 = param_1422."!PREFIX__!protoregex"("quote")
    .return ($P1423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("241_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1425_tgt
    .local int rx1425_pos
    .local int rx1425_off
    .local int rx1425_eos
    .local int rx1425_rep
    .local pmc rx1425_cur
    .local pmc rx1425_debug
    (rx1425_cur, rx1425_pos, rx1425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1425_cur
    .local pmc match
    .lex "$/", match
    length rx1425_eos, rx1425_tgt
    gt rx1425_pos, rx1425_eos, rx1425_done
    set rx1425_off, 0
    lt rx1425_pos, 2, rx1425_start
    sub rx1425_off, rx1425_pos, 1
    substr rx1425_tgt, rx1425_tgt, rx1425_off
  rx1425_start:
    eq $I10, 1, rx1425_restart
    if_null rx1425_debug, debug_1123
    rx1425_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1123:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1426_done
    goto rxscan1426_scan
  rxscan1426_loop:
    (rx1425_pos) = rx1425_cur."from"()
    inc rx1425_pos
    rx1425_cur."!cursor_from"(rx1425_pos)
    ge rx1425_pos, rx1425_eos, rxscan1426_done
  rxscan1426_scan:
    set_addr $I10, rxscan1426_loop
    rx1425_cur."!mark_push"(0, rx1425_pos, $I10)
  rxscan1426_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1425_pos, rx1425_off
    substr $S10, rx1425_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1425_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1425_cur."!cursor_pos"(rx1425_pos)
    $P10 = rx1425_cur."quote_EXPR"(":q")
    unless $P10, rx1425_fail
    rx1425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1425_pos = $P10."pos"()
  # rx pass
    rx1425_cur."!cursor_pass"(rx1425_pos, "quote:sym<apos>")
    if_null rx1425_debug, debug_1124
    rx1425_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1425_pos)
  debug_1124:
    .return (rx1425_cur)
  rx1425_restart:
.annotate 'line', 10
    if_null rx1425_debug, debug_1125
    rx1425_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1125:
  rx1425_fail:
    (rx1425_rep, rx1425_pos, $I10, $P10) = rx1425_cur."!mark_fail"(0)
    lt rx1425_pos, -1, rx1425_done
    eq rx1425_pos, -1, rx1425_fail
    jump $I10
  rx1425_done:
    rx1425_cur."!cursor_fail"()
    if_null rx1425_debug, debug_1126
    rx1425_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1126:
    .return (rx1425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :subid("242_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1428, "ResizablePMCArray"
    push $P1428, "'"
    .return ($P1428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("243_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1127
    rx1430_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1127:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1431_done
    goto rxscan1431_scan
  rxscan1431_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1431_done
  rxscan1431_scan:
    set_addr $I10, rxscan1431_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1431_done:
.annotate 'line', 577
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1430_pos, rx1430_off
    substr $S10, rx1430_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1430_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."quote_EXPR"(":qq")
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1430_pos = $P10."pos"()
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "quote:sym<dblq>")
    if_null rx1430_debug, debug_1128
    rx1430_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1430_pos)
  debug_1128:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1129
    rx1430_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1129:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1130
    rx1430_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1130:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :subid("244_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1433, "ResizablePMCArray"
    push $P1433, "\""
    .return ($P1433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("245_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1435_tgt
    .local int rx1435_pos
    .local int rx1435_off
    .local int rx1435_eos
    .local int rx1435_rep
    .local pmc rx1435_cur
    .local pmc rx1435_debug
    (rx1435_cur, rx1435_pos, rx1435_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1435_cur
    .local pmc match
    .lex "$/", match
    length rx1435_eos, rx1435_tgt
    gt rx1435_pos, rx1435_eos, rx1435_done
    set rx1435_off, 0
    lt rx1435_pos, 2, rx1435_start
    sub rx1435_off, rx1435_pos, 1
    substr rx1435_tgt, rx1435_tgt, rx1435_off
  rx1435_start:
    eq $I10, 1, rx1435_restart
    if_null rx1435_debug, debug_1131
    rx1435_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1131:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1436_done
    goto rxscan1436_scan
  rxscan1436_loop:
    (rx1435_pos) = rx1435_cur."from"()
    inc rx1435_pos
    rx1435_cur."!cursor_from"(rx1435_pos)
    ge rx1435_pos, rx1435_eos, rxscan1436_done
  rxscan1436_scan:
    set_addr $I10, rxscan1436_loop
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  rxscan1436_done:
.annotate 'line', 578
  # rx subcapture "sym"
    set_addr $I10, rxcap_1437_fail
    rx1435_cur."!mark_push"(0, rx1435_pos, $I10)
  # rx literal  "q"
    add $I11, rx1435_pos, 1
    gt $I11, rx1435_eos, rx1435_fail
    sub $I11, rx1435_pos, rx1435_off
    ord $I11, rx1435_tgt, $I11
    ne $I11, 113, rx1435_fail
    add rx1435_pos, 1
    set_addr $I10, rxcap_1437_fail
    ($I12, $I11) = rx1435_cur."!mark_peek"($I10)
    rx1435_cur."!cursor_pos"($I11)
    ($P10) = rx1435_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1435_pos, "")
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1437_done
  rxcap_1437_fail:
    goto rx1435_fail
  rxcap_1437_done:
  # rxanchor rwb
    le rx1435_pos, 0, rx1435_fail
    sub $I10, rx1435_pos, rx1435_off
    is_cclass $I11, 8192, rx1435_tgt, $I10
    if $I11, rx1435_fail
    dec $I10
    is_cclass $I11, 8192, rx1435_tgt, $I10
    unless $I11, rx1435_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1435_pos, rx1435_off
    substr $S10, rx1435_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1435_fail
  # rx subrule "ws" subtype=method negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."ws"()
    unless $P10, rx1435_fail
    rx1435_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1435_cur."!cursor_pos"(rx1435_pos)
    $P10 = rx1435_cur."quote_EXPR"(":q")
    unless $P10, rx1435_fail
    rx1435_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1435_pos = $P10."pos"()
  # rx pass
    rx1435_cur."!cursor_pass"(rx1435_pos, "quote:sym<q>")
    if_null rx1435_debug, debug_1132
    rx1435_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1435_pos)
  debug_1132:
    .return (rx1435_cur)
  rx1435_restart:
.annotate 'line', 10
    if_null rx1435_debug, debug_1133
    rx1435_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1133:
  rx1435_fail:
    (rx1435_rep, rx1435_pos, $I10, $P10) = rx1435_cur."!mark_fail"(0)
    lt rx1435_pos, -1, rx1435_done
    eq rx1435_pos, -1, rx1435_fail
    jump $I10
  rx1435_done:
    rx1435_cur."!cursor_fail"()
    if_null rx1435_debug, debug_1134
    rx1435_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1134:
    .return (rx1435_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :subid("246_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1439 = self."!PREFIX__!subrule"("ws", "q")
    new $P1440, "ResizablePMCArray"
    push $P1440, $P1439
    .return ($P1440)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("247_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1442_tgt
    .local int rx1442_pos
    .local int rx1442_off
    .local int rx1442_eos
    .local int rx1442_rep
    .local pmc rx1442_cur
    .local pmc rx1442_debug
    (rx1442_cur, rx1442_pos, rx1442_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1442_cur
    .local pmc match
    .lex "$/", match
    length rx1442_eos, rx1442_tgt
    gt rx1442_pos, rx1442_eos, rx1442_done
    set rx1442_off, 0
    lt rx1442_pos, 2, rx1442_start
    sub rx1442_off, rx1442_pos, 1
    substr rx1442_tgt, rx1442_tgt, rx1442_off
  rx1442_start:
    eq $I10, 1, rx1442_restart
    if_null rx1442_debug, debug_1135
    rx1442_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1135:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1443_done
    goto rxscan1443_scan
  rxscan1443_loop:
    (rx1442_pos) = rx1442_cur."from"()
    inc rx1442_pos
    rx1442_cur."!cursor_from"(rx1442_pos)
    ge rx1442_pos, rx1442_eos, rxscan1443_done
  rxscan1443_scan:
    set_addr $I10, rxscan1443_loop
    rx1442_cur."!mark_push"(0, rx1442_pos, $I10)
  rxscan1443_done:
.annotate 'line', 579
  # rx subcapture "sym"
    set_addr $I10, rxcap_1444_fail
    rx1442_cur."!mark_push"(0, rx1442_pos, $I10)
  # rx literal  "qq"
    add $I11, rx1442_pos, 2
    gt $I11, rx1442_eos, rx1442_fail
    sub $I11, rx1442_pos, rx1442_off
    substr $S10, rx1442_tgt, $I11, 2
    ne $S10, "qq", rx1442_fail
    add rx1442_pos, 2
    set_addr $I10, rxcap_1444_fail
    ($I12, $I11) = rx1442_cur."!mark_peek"($I10)
    rx1442_cur."!cursor_pos"($I11)
    ($P10) = rx1442_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1442_pos, "")
    rx1442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1444_done
  rxcap_1444_fail:
    goto rx1442_fail
  rxcap_1444_done:
  # rxanchor rwb
    le rx1442_pos, 0, rx1442_fail
    sub $I10, rx1442_pos, rx1442_off
    is_cclass $I11, 8192, rx1442_tgt, $I10
    if $I11, rx1442_fail
    dec $I10
    is_cclass $I11, 8192, rx1442_tgt, $I10
    unless $I11, rx1442_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1442_pos, rx1442_off
    substr $S10, rx1442_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1442_fail
  # rx subrule "ws" subtype=method negate=
    rx1442_cur."!cursor_pos"(rx1442_pos)
    $P10 = rx1442_cur."ws"()
    unless $P10, rx1442_fail
    rx1442_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1442_cur."!cursor_pos"(rx1442_pos)
    $P10 = rx1442_cur."quote_EXPR"(":qq")
    unless $P10, rx1442_fail
    rx1442_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1442_pos = $P10."pos"()
  # rx pass
    rx1442_cur."!cursor_pass"(rx1442_pos, "quote:sym<qq>")
    if_null rx1442_debug, debug_1136
    rx1442_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1442_pos)
  debug_1136:
    .return (rx1442_cur)
  rx1442_restart:
.annotate 'line', 10
    if_null rx1442_debug, debug_1137
    rx1442_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1137:
  rx1442_fail:
    (rx1442_rep, rx1442_pos, $I10, $P10) = rx1442_cur."!mark_fail"(0)
    lt rx1442_pos, -1, rx1442_done
    eq rx1442_pos, -1, rx1442_fail
    jump $I10
  rx1442_done:
    rx1442_cur."!cursor_fail"()
    if_null rx1442_debug, debug_1138
    rx1442_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1138:
    .return (rx1442_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :subid("248_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1446 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1447, "ResizablePMCArray"
    push $P1447, $P1446
    .return ($P1447)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("249_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1449_tgt
    .local int rx1449_pos
    .local int rx1449_off
    .local int rx1449_eos
    .local int rx1449_rep
    .local pmc rx1449_cur
    .local pmc rx1449_debug
    (rx1449_cur, rx1449_pos, rx1449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1449_cur
    .local pmc match
    .lex "$/", match
    length rx1449_eos, rx1449_tgt
    gt rx1449_pos, rx1449_eos, rx1449_done
    set rx1449_off, 0
    lt rx1449_pos, 2, rx1449_start
    sub rx1449_off, rx1449_pos, 1
    substr rx1449_tgt, rx1449_tgt, rx1449_off
  rx1449_start:
    eq $I10, 1, rx1449_restart
    if_null rx1449_debug, debug_1139
    rx1449_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1139:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1450_done
    goto rxscan1450_scan
  rxscan1450_loop:
    (rx1449_pos) = rx1449_cur."from"()
    inc rx1449_pos
    rx1449_cur."!cursor_from"(rx1449_pos)
    ge rx1449_pos, rx1449_eos, rxscan1450_done
  rxscan1450_scan:
    set_addr $I10, rxscan1450_loop
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  rxscan1450_done:
.annotate 'line', 580
  # rx subcapture "sym"
    set_addr $I10, rxcap_1451_fail
    rx1449_cur."!mark_push"(0, rx1449_pos, $I10)
  # rx literal  "Q"
    add $I11, rx1449_pos, 1
    gt $I11, rx1449_eos, rx1449_fail
    sub $I11, rx1449_pos, rx1449_off
    ord $I11, rx1449_tgt, $I11
    ne $I11, 81, rx1449_fail
    add rx1449_pos, 1
    set_addr $I10, rxcap_1451_fail
    ($I12, $I11) = rx1449_cur."!mark_peek"($I10)
    rx1449_cur."!cursor_pos"($I11)
    ($P10) = rx1449_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1449_pos, "")
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1451_done
  rxcap_1451_fail:
    goto rx1449_fail
  rxcap_1451_done:
  # rxanchor rwb
    le rx1449_pos, 0, rx1449_fail
    sub $I10, rx1449_pos, rx1449_off
    is_cclass $I11, 8192, rx1449_tgt, $I10
    if $I11, rx1449_fail
    dec $I10
    is_cclass $I11, 8192, rx1449_tgt, $I10
    unless $I11, rx1449_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1449_pos, rx1449_off
    substr $S10, rx1449_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1449_fail
  # rx subrule "ws" subtype=method negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."ws"()
    unless $P10, rx1449_fail
    rx1449_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1449_cur."!cursor_pos"(rx1449_pos)
    $P10 = rx1449_cur."quote_EXPR"()
    unless $P10, rx1449_fail
    rx1449_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1449_pos = $P10."pos"()
  # rx pass
    rx1449_cur."!cursor_pass"(rx1449_pos, "quote:sym<Q>")
    if_null rx1449_debug, debug_1140
    rx1449_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1449_pos)
  debug_1140:
    .return (rx1449_cur)
  rx1449_restart:
.annotate 'line', 10
    if_null rx1449_debug, debug_1141
    rx1449_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1141:
  rx1449_fail:
    (rx1449_rep, rx1449_pos, $I10, $P10) = rx1449_cur."!mark_fail"(0)
    lt rx1449_pos, -1, rx1449_done
    eq rx1449_pos, -1, rx1449_fail
    jump $I10
  rx1449_done:
    rx1449_cur."!cursor_fail"()
    if_null rx1449_debug, debug_1142
    rx1449_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1142:
    .return (rx1449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :subid("250_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1453 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1454, "ResizablePMCArray"
    push $P1454, $P1453
    .return ($P1454)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("251_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1456_tgt
    .local int rx1456_pos
    .local int rx1456_off
    .local int rx1456_eos
    .local int rx1456_rep
    .local pmc rx1456_cur
    .local pmc rx1456_debug
    (rx1456_cur, rx1456_pos, rx1456_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1456_cur
    .local pmc match
    .lex "$/", match
    length rx1456_eos, rx1456_tgt
    gt rx1456_pos, rx1456_eos, rx1456_done
    set rx1456_off, 0
    lt rx1456_pos, 2, rx1456_start
    sub rx1456_off, rx1456_pos, 1
    substr rx1456_tgt, rx1456_tgt, rx1456_off
  rx1456_start:
    eq $I10, 1, rx1456_restart
    if_null rx1456_debug, debug_1143
    rx1456_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1143:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1457_done
    goto rxscan1457_scan
  rxscan1457_loop:
    (rx1456_pos) = rx1456_cur."from"()
    inc rx1456_pos
    rx1456_cur."!cursor_from"(rx1456_pos)
    ge rx1456_pos, rx1456_eos, rxscan1457_done
  rxscan1457_scan:
    set_addr $I10, rxscan1457_loop
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  rxscan1457_done:
.annotate 'line', 581
  # rx subcapture "sym"
    set_addr $I10, rxcap_1458_fail
    rx1456_cur."!mark_push"(0, rx1456_pos, $I10)
  # rx literal  "Q:PIR"
    add $I11, rx1456_pos, 5
    gt $I11, rx1456_eos, rx1456_fail
    sub $I11, rx1456_pos, rx1456_off
    substr $S10, rx1456_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1456_fail
    add rx1456_pos, 5
    set_addr $I10, rxcap_1458_fail
    ($I12, $I11) = rx1456_cur."!mark_peek"($I10)
    rx1456_cur."!cursor_pos"($I11)
    ($P10) = rx1456_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1456_pos, "")
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1458_done
  rxcap_1458_fail:
    goto rx1456_fail
  rxcap_1458_done:
  # rx subrule "ws" subtype=method negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."ws"()
    unless $P10, rx1456_fail
    rx1456_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1456_cur."!cursor_pos"(rx1456_pos)
    $P10 = rx1456_cur."quote_EXPR"()
    unless $P10, rx1456_fail
    rx1456_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1456_pos = $P10."pos"()
  # rx pass
    rx1456_cur."!cursor_pass"(rx1456_pos, "quote:sym<Q:PIR>")
    if_null rx1456_debug, debug_1144
    rx1456_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1456_pos)
  debug_1144:
    .return (rx1456_cur)
  rx1456_restart:
.annotate 'line', 10
    if_null rx1456_debug, debug_1145
    rx1456_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1145:
  rx1456_fail:
    (rx1456_rep, rx1456_pos, $I10, $P10) = rx1456_cur."!mark_fail"(0)
    lt rx1456_pos, -1, rx1456_done
    eq rx1456_pos, -1, rx1456_fail
    jump $I10
  rx1456_done:
    rx1456_cur."!cursor_fail"()
    if_null rx1456_debug, debug_1146
    rx1456_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1146:
    .return (rx1456_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :subid("252_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1460 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1461, "ResizablePMCArray"
    push $P1461, $P1460
    .return ($P1461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("253_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1463_tgt
    .local int rx1463_pos
    .local int rx1463_off
    .local int rx1463_eos
    .local int rx1463_rep
    .local pmc rx1463_cur
    .local pmc rx1463_debug
    (rx1463_cur, rx1463_pos, rx1463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1463_cur
    .local pmc match
    .lex "$/", match
    length rx1463_eos, rx1463_tgt
    gt rx1463_pos, rx1463_eos, rx1463_done
    set rx1463_off, 0
    lt rx1463_pos, 2, rx1463_start
    sub rx1463_off, rx1463_pos, 1
    substr rx1463_tgt, rx1463_tgt, rx1463_off
  rx1463_start:
    eq $I10, 1, rx1463_restart
    if_null rx1463_debug, debug_1147
    rx1463_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1147:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1464_done
    goto rxscan1464_scan
  rxscan1464_loop:
    (rx1463_pos) = rx1463_cur."from"()
    inc rx1463_pos
    rx1463_cur."!cursor_from"(rx1463_pos)
    ge rx1463_pos, rx1463_eos, rxscan1464_done
  rxscan1464_scan:
    set_addr $I10, rxscan1464_loop
    rx1463_cur."!mark_push"(0, rx1463_pos, $I10)
  rxscan1464_done:
.annotate 'line', 583
  # rx literal  "/"
    add $I11, rx1463_pos, 1
    gt $I11, rx1463_eos, rx1463_fail
    sub $I11, rx1463_pos, rx1463_off
    ord $I11, rx1463_tgt, $I11
    ne $I11, 47, rx1463_fail
    add rx1463_pos, 1
.annotate 'line', 584
  # rx subrule "newpad" subtype=method negate=
    rx1463_cur."!cursor_pos"(rx1463_pos)
    $P10 = rx1463_cur."newpad"()
    unless $P10, rx1463_fail
    rx1463_pos = $P10."pos"()
.annotate 'line', 585
  # rx reduce name="quote:sym</ />" key="open"
    rx1463_cur."!cursor_pos"(rx1463_pos)
    rx1463_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 586
  # rx subrule "LANG" subtype=capture negate=
    rx1463_cur."!cursor_pos"(rx1463_pos)
    $P10 = rx1463_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1463_fail
    rx1463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1463_pos = $P10."pos"()
.annotate 'line', 587
  # rx literal  "/"
    add $I11, rx1463_pos, 1
    gt $I11, rx1463_eos, rx1463_fail
    sub $I11, rx1463_pos, rx1463_off
    ord $I11, rx1463_tgt, $I11
    ne $I11, 47, rx1463_fail
    add rx1463_pos, 1
.annotate 'line', 582
  # rx pass
    rx1463_cur."!cursor_pass"(rx1463_pos, "quote:sym</ />")
    if_null rx1463_debug, debug_1148
    rx1463_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1463_pos)
  debug_1148:
    .return (rx1463_cur)
  rx1463_restart:
.annotate 'line', 10
    if_null rx1463_debug, debug_1149
    rx1463_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1149:
  rx1463_fail:
    (rx1463_rep, rx1463_pos, $I10, $P10) = rx1463_cur."!mark_fail"(0)
    lt rx1463_pos, -1, rx1463_done
    eq rx1463_pos, -1, rx1463_fail
    jump $I10
  rx1463_done:
    rx1463_cur."!cursor_fail"()
    if_null rx1463_debug, debug_1150
    rx1463_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1150:
    .return (rx1463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :subid("254_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1466 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1467, "ResizablePMCArray"
    push $P1467, $P1466
    .return ($P1467)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("255_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1469_tgt
    .local int rx1469_pos
    .local int rx1469_off
    .local int rx1469_eos
    .local int rx1469_rep
    .local pmc rx1469_cur
    .local pmc rx1469_debug
    (rx1469_cur, rx1469_pos, rx1469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1469_cur
    .local pmc match
    .lex "$/", match
    length rx1469_eos, rx1469_tgt
    gt rx1469_pos, rx1469_eos, rx1469_done
    set rx1469_off, 0
    lt rx1469_pos, 2, rx1469_start
    sub rx1469_off, rx1469_pos, 1
    substr rx1469_tgt, rx1469_tgt, rx1469_off
  rx1469_start:
    eq $I10, 1, rx1469_restart
    if_null rx1469_debug, debug_1151
    rx1469_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1151:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1470_done
    goto rxscan1470_scan
  rxscan1470_loop:
    (rx1469_pos) = rx1469_cur."from"()
    inc rx1469_pos
    rx1469_cur."!cursor_from"(rx1469_pos)
    ge rx1469_pos, rx1469_eos, rxscan1470_done
  rxscan1470_scan:
    set_addr $I10, rxscan1470_loop
    rx1469_cur."!mark_push"(0, rx1469_pos, $I10)
  rxscan1470_done:
.annotate 'line', 590
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1469_pos, rx1469_off
    substr $S10, rx1469_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1469_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."quotemod_check"("s")
    unless $P10, rx1469_fail
  # rx subrule "variable" subtype=capture negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."variable"()
    unless $P10, rx1469_fail
    rx1469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1469_pos = $P10."pos"()
  # rx pass
    rx1469_cur."!cursor_pass"(rx1469_pos, "quote_escape:sym<$>")
    if_null rx1469_debug, debug_1152
    rx1469_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1469_pos)
  debug_1152:
    .return (rx1469_cur)
  rx1469_restart:
.annotate 'line', 10
    if_null rx1469_debug, debug_1153
    rx1469_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1153:
  rx1469_fail:
    (rx1469_rep, rx1469_pos, $I10, $P10) = rx1469_cur."!mark_fail"(0)
    lt rx1469_pos, -1, rx1469_done
    eq rx1469_pos, -1, rx1469_fail
    jump $I10
  rx1469_done:
    rx1469_cur."!cursor_fail"()
    if_null rx1469_debug, debug_1154
    rx1469_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1154:
    .return (rx1469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :subid("256_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1472, "ResizablePMCArray"
    push $P1472, "$"
    .return ($P1472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("257_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1474_tgt
    .local int rx1474_pos
    .local int rx1474_off
    .local int rx1474_eos
    .local int rx1474_rep
    .local pmc rx1474_cur
    .local pmc rx1474_debug
    (rx1474_cur, rx1474_pos, rx1474_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1474_cur
    .local pmc match
    .lex "$/", match
    length rx1474_eos, rx1474_tgt
    gt rx1474_pos, rx1474_eos, rx1474_done
    set rx1474_off, 0
    lt rx1474_pos, 2, rx1474_start
    sub rx1474_off, rx1474_pos, 1
    substr rx1474_tgt, rx1474_tgt, rx1474_off
  rx1474_start:
    eq $I10, 1, rx1474_restart
    if_null rx1474_debug, debug_1155
    rx1474_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1155:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1475_done
    goto rxscan1475_scan
  rxscan1475_loop:
    (rx1474_pos) = rx1474_cur."from"()
    inc rx1474_pos
    rx1474_cur."!cursor_from"(rx1474_pos)
    ge rx1474_pos, rx1474_eos, rxscan1475_done
  rxscan1475_scan:
    set_addr $I10, rxscan1475_loop
    rx1474_cur."!mark_push"(0, rx1474_pos, $I10)
  rxscan1475_done:
.annotate 'line', 591
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1474_pos, rx1474_off
    substr $S10, rx1474_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1474_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."quotemod_check"("c")
    unless $P10, rx1474_fail
  # rx subrule "block" subtype=capture negate=
    rx1474_cur."!cursor_pos"(rx1474_pos)
    $P10 = rx1474_cur."block"()
    unless $P10, rx1474_fail
    rx1474_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1474_pos = $P10."pos"()
  # rx pass
    rx1474_cur."!cursor_pass"(rx1474_pos, "quote_escape:sym<{ }>")
    if_null rx1474_debug, debug_1156
    rx1474_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1474_pos)
  debug_1156:
    .return (rx1474_cur)
  rx1474_restart:
.annotate 'line', 10
    if_null rx1474_debug, debug_1157
    rx1474_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1157:
  rx1474_fail:
    (rx1474_rep, rx1474_pos, $I10, $P10) = rx1474_cur."!mark_fail"(0)
    lt rx1474_pos, -1, rx1474_done
    eq rx1474_pos, -1, rx1474_fail
    jump $I10
  rx1474_done:
    rx1474_cur."!cursor_fail"()
    if_null rx1474_debug, debug_1158
    rx1474_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1158:
    .return (rx1474_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :subid("258_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1477, "ResizablePMCArray"
    push $P1477, "{"
    .return ($P1477)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("259_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1479_tgt
    .local int rx1479_pos
    .local int rx1479_off
    .local int rx1479_eos
    .local int rx1479_rep
    .local pmc rx1479_cur
    .local pmc rx1479_debug
    (rx1479_cur, rx1479_pos, rx1479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1479_cur
    .local pmc match
    .lex "$/", match
    length rx1479_eos, rx1479_tgt
    gt rx1479_pos, rx1479_eos, rx1479_done
    set rx1479_off, 0
    lt rx1479_pos, 2, rx1479_start
    sub rx1479_off, rx1479_pos, 1
    substr rx1479_tgt, rx1479_tgt, rx1479_off
  rx1479_start:
    eq $I10, 1, rx1479_restart
    if_null rx1479_debug, debug_1159
    rx1479_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1159:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1480_done
    goto rxscan1480_scan
  rxscan1480_loop:
    (rx1479_pos) = rx1479_cur."from"()
    inc rx1479_pos
    rx1479_cur."!cursor_from"(rx1479_pos)
    ge rx1479_pos, rx1479_eos, rxscan1480_done
  rxscan1480_scan:
    set_addr $I10, rxscan1480_loop
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  rxscan1480_done:
.annotate 'line', 592
  # rx literal  "\\e"
    add $I11, rx1479_pos, 2
    gt $I11, rx1479_eos, rx1479_fail
    sub $I11, rx1479_pos, rx1479_off
    substr $S10, rx1479_tgt, $I11, 2
    ne $S10, "\\e", rx1479_fail
    add rx1479_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1479_cur."!cursor_pos"(rx1479_pos)
    $P10 = rx1479_cur."quotemod_check"("b")
    unless $P10, rx1479_fail
  # rx pass
    rx1479_cur."!cursor_pass"(rx1479_pos, "quote_escape:sym<esc>")
    if_null rx1479_debug, debug_1160
    rx1479_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1479_pos)
  debug_1160:
    .return (rx1479_cur)
  rx1479_restart:
.annotate 'line', 10
    if_null rx1479_debug, debug_1161
    rx1479_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1161:
  rx1479_fail:
    (rx1479_rep, rx1479_pos, $I10, $P10) = rx1479_cur."!mark_fail"(0)
    lt rx1479_pos, -1, rx1479_done
    eq rx1479_pos, -1, rx1479_fail
    jump $I10
  rx1479_done:
    rx1479_cur."!cursor_fail"()
    if_null rx1479_debug, debug_1162
    rx1479_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1162:
    .return (rx1479_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :subid("260_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1482, "ResizablePMCArray"
    push $P1482, "\\e"
    .return ($P1482)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("261_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1484_tgt
    .local int rx1484_pos
    .local int rx1484_off
    .local int rx1484_eos
    .local int rx1484_rep
    .local pmc rx1484_cur
    .local pmc rx1484_debug
    (rx1484_cur, rx1484_pos, rx1484_tgt, $I10) = self."!cursor_start"()
    rx1484_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1484_cur
    .local pmc match
    .lex "$/", match
    length rx1484_eos, rx1484_tgt
    gt rx1484_pos, rx1484_eos, rx1484_done
    set rx1484_off, 0
    lt rx1484_pos, 2, rx1484_start
    sub rx1484_off, rx1484_pos, 1
    substr rx1484_tgt, rx1484_tgt, rx1484_off
  rx1484_start:
    eq $I10, 1, rx1484_restart
    if_null rx1484_debug, debug_1163
    rx1484_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1163:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1485_done
    goto rxscan1485_scan
  rxscan1485_loop:
    (rx1484_pos) = rx1484_cur."from"()
    inc rx1484_pos
    rx1484_cur."!cursor_from"(rx1484_pos)
    ge rx1484_pos, rx1484_eos, rxscan1485_done
  rxscan1485_scan:
    set_addr $I10, rxscan1485_loop
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  rxscan1485_done:
.annotate 'line', 594
  # rx literal  "("
    add $I11, rx1484_pos, 1
    gt $I11, rx1484_eos, rx1484_fail
    sub $I11, rx1484_pos, rx1484_off
    ord $I11, rx1484_tgt, $I11
    ne $I11, 40, rx1484_fail
    add rx1484_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1484_cur."!cursor_pos"(rx1484_pos)
    $P10 = rx1484_cur."ws"()
    unless $P10, rx1484_fail
    rx1484_pos = $P10."pos"()
  # rx rxquantr1486 ** 0..1
    set_addr $I10, rxquantr1486_done
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10)
  rxquantr1486_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1484_cur."!cursor_pos"(rx1484_pos)
    $P10 = rx1484_cur."EXPR"()
    unless $P10, rx1484_fail
    goto rxsubrule1487_pass
  rxsubrule1487_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1484_fail
  rxsubrule1487_pass:
    set_addr $I10, rxsubrule1487_back
    rx1484_cur."!mark_push"(0, rx1484_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1484_pos = $P10."pos"()
    set_addr $I10, rxquantr1486_done
    (rx1484_rep) = rx1484_cur."!mark_commit"($I10)
  rxquantr1486_done:
  # rx literal  ")"
    add $I11, rx1484_pos, 1
    gt $I11, rx1484_eos, rx1484_fail
    sub $I11, rx1484_pos, rx1484_off
    ord $I11, rx1484_tgt, $I11
    ne $I11, 41, rx1484_fail
    add rx1484_pos, 1
  # rx pass
    rx1484_cur."!cursor_pass"(rx1484_pos, "circumfix:sym<( )>")
    if_null rx1484_debug, debug_1164
    rx1484_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1484_pos)
  debug_1164:
    .return (rx1484_cur)
  rx1484_restart:
.annotate 'line', 10
    if_null rx1484_debug, debug_1165
    rx1484_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1165:
  rx1484_fail:
    (rx1484_rep, rx1484_pos, $I10, $P10) = rx1484_cur."!mark_fail"(0)
    lt rx1484_pos, -1, rx1484_done
    eq rx1484_pos, -1, rx1484_fail
    jump $I10
  rx1484_done:
    rx1484_cur."!cursor_fail"()
    if_null rx1484_debug, debug_1166
    rx1484_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1166:
    .return (rx1484_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :subid("262_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1489 = self."!PREFIX__!subrule"("ws", "(")
    new $P1490, "ResizablePMCArray"
    push $P1490, $P1489
    .return ($P1490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("263_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1492_tgt
    .local int rx1492_pos
    .local int rx1492_off
    .local int rx1492_eos
    .local int rx1492_rep
    .local pmc rx1492_cur
    .local pmc rx1492_debug
    (rx1492_cur, rx1492_pos, rx1492_tgt, $I10) = self."!cursor_start"()
    rx1492_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1492_cur
    .local pmc match
    .lex "$/", match
    length rx1492_eos, rx1492_tgt
    gt rx1492_pos, rx1492_eos, rx1492_done
    set rx1492_off, 0
    lt rx1492_pos, 2, rx1492_start
    sub rx1492_off, rx1492_pos, 1
    substr rx1492_tgt, rx1492_tgt, rx1492_off
  rx1492_start:
    eq $I10, 1, rx1492_restart
    if_null rx1492_debug, debug_1167
    rx1492_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1167:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1493_done
    goto rxscan1493_scan
  rxscan1493_loop:
    (rx1492_pos) = rx1492_cur."from"()
    inc rx1492_pos
    rx1492_cur."!cursor_from"(rx1492_pos)
    ge rx1492_pos, rx1492_eos, rxscan1493_done
  rxscan1493_scan:
    set_addr $I10, rxscan1493_loop
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  rxscan1493_done:
.annotate 'line', 595
  # rx literal  "["
    add $I11, rx1492_pos, 1
    gt $I11, rx1492_eos, rx1492_fail
    sub $I11, rx1492_pos, rx1492_off
    ord $I11, rx1492_tgt, $I11
    ne $I11, 91, rx1492_fail
    add rx1492_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."ws"()
    unless $P10, rx1492_fail
    rx1492_pos = $P10."pos"()
  # rx rxquantr1494 ** 0..1
    set_addr $I10, rxquantr1494_done
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10)
  rxquantr1494_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1492_cur."!cursor_pos"(rx1492_pos)
    $P10 = rx1492_cur."EXPR"()
    unless $P10, rx1492_fail
    goto rxsubrule1495_pass
  rxsubrule1495_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1492_fail
  rxsubrule1495_pass:
    set_addr $I10, rxsubrule1495_back
    rx1492_cur."!mark_push"(0, rx1492_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1492_pos = $P10."pos"()
    set_addr $I10, rxquantr1494_done
    (rx1492_rep) = rx1492_cur."!mark_commit"($I10)
  rxquantr1494_done:
  # rx literal  "]"
    add $I11, rx1492_pos, 1
    gt $I11, rx1492_eos, rx1492_fail
    sub $I11, rx1492_pos, rx1492_off
    ord $I11, rx1492_tgt, $I11
    ne $I11, 93, rx1492_fail
    add rx1492_pos, 1
  # rx pass
    rx1492_cur."!cursor_pass"(rx1492_pos, "circumfix:sym<[ ]>")
    if_null rx1492_debug, debug_1168
    rx1492_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1492_pos)
  debug_1168:
    .return (rx1492_cur)
  rx1492_restart:
.annotate 'line', 10
    if_null rx1492_debug, debug_1169
    rx1492_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1169:
  rx1492_fail:
    (rx1492_rep, rx1492_pos, $I10, $P10) = rx1492_cur."!mark_fail"(0)
    lt rx1492_pos, -1, rx1492_done
    eq rx1492_pos, -1, rx1492_fail
    jump $I10
  rx1492_done:
    rx1492_cur."!cursor_fail"()
    if_null rx1492_debug, debug_1170
    rx1492_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1170:
    .return (rx1492_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :subid("264_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1497 = self."!PREFIX__!subrule"("ws", "[")
    new $P1498, "ResizablePMCArray"
    push $P1498, $P1497
    .return ($P1498)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("265_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1171
    rx1500_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1171:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1501_done:
.annotate 'line', 596
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1500_pos, rx1500_off
    substr $S10, rx1500_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1500_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "circumfix:sym<ang>")
    if_null rx1500_debug, debug_1172
    rx1500_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1500_pos)
  debug_1172:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 10
    if_null rx1500_debug, debug_1173
    rx1500_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1173:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1174
    rx1500_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1174:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :subid("266_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1503, "ResizablePMCArray"
    push $P1503, "<"
    .return ($P1503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("267_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1505_tgt
    .local int rx1505_pos
    .local int rx1505_off
    .local int rx1505_eos
    .local int rx1505_rep
    .local pmc rx1505_cur
    .local pmc rx1505_debug
    (rx1505_cur, rx1505_pos, rx1505_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1505_cur
    .local pmc match
    .lex "$/", match
    length rx1505_eos, rx1505_tgt
    gt rx1505_pos, rx1505_eos, rx1505_done
    set rx1505_off, 0
    lt rx1505_pos, 2, rx1505_start
    sub rx1505_off, rx1505_pos, 1
    substr rx1505_tgt, rx1505_tgt, rx1505_off
  rx1505_start:
    eq $I10, 1, rx1505_restart
    if_null rx1505_debug, debug_1175
    rx1505_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1175:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1506_done
    goto rxscan1506_scan
  rxscan1506_loop:
    (rx1505_pos) = rx1505_cur."from"()
    inc rx1505_pos
    rx1505_cur."!cursor_from"(rx1505_pos)
    ge rx1505_pos, rx1505_eos, rxscan1506_done
  rxscan1506_scan:
    set_addr $I10, rxscan1506_loop
    rx1505_cur."!mark_push"(0, rx1505_pos, $I10)
  rxscan1506_done:
.annotate 'line', 597
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1505_pos, rx1505_off
    substr $S10, rx1505_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1505_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1505_cur."!cursor_pos"(rx1505_pos)
    $P10 = rx1505_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1505_fail
    rx1505_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1505_pos = $P10."pos"()
  # rx pass
    rx1505_cur."!cursor_pass"(rx1505_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1505_debug, debug_1176
    rx1505_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1505_pos)
  debug_1176:
    .return (rx1505_cur)
  rx1505_restart:
.annotate 'line', 10
    if_null rx1505_debug, debug_1177
    rx1505_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1177:
  rx1505_fail:
    (rx1505_rep, rx1505_pos, $I10, $P10) = rx1505_cur."!mark_fail"(0)
    lt rx1505_pos, -1, rx1505_done
    eq rx1505_pos, -1, rx1505_fail
    jump $I10
  rx1505_done:
    rx1505_cur."!cursor_fail"()
    if_null rx1505_debug, debug_1178
    rx1505_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1178:
    .return (rx1505_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :subid("268_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1508, "ResizablePMCArray"
    push $P1508, unicode:"\x{ab}"
    .return ($P1508)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("269_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1510_tgt
    .local int rx1510_pos
    .local int rx1510_off
    .local int rx1510_eos
    .local int rx1510_rep
    .local pmc rx1510_cur
    .local pmc rx1510_debug
    (rx1510_cur, rx1510_pos, rx1510_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1510_cur
    .local pmc match
    .lex "$/", match
    length rx1510_eos, rx1510_tgt
    gt rx1510_pos, rx1510_eos, rx1510_done
    set rx1510_off, 0
    lt rx1510_pos, 2, rx1510_start
    sub rx1510_off, rx1510_pos, 1
    substr rx1510_tgt, rx1510_tgt, rx1510_off
  rx1510_start:
    eq $I10, 1, rx1510_restart
    if_null rx1510_debug, debug_1179
    rx1510_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1179:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1510_pos) = rx1510_cur."from"()
    inc rx1510_pos
    rx1510_cur."!cursor_from"(rx1510_pos)
    ge rx1510_pos, rx1510_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1510_cur."!mark_push"(0, rx1510_pos, $I10)
  rxscan1511_done:
.annotate 'line', 598
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1510_pos, rx1510_off
    substr $S10, rx1510_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1510_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1510_cur."!cursor_pos"(rx1510_pos)
    $P10 = rx1510_cur."pblock"()
    unless $P10, rx1510_fail
    rx1510_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1510_pos = $P10."pos"()
  # rx pass
    rx1510_cur."!cursor_pass"(rx1510_pos, "circumfix:sym<{ }>")
    if_null rx1510_debug, debug_1180
    rx1510_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1510_pos)
  debug_1180:
    .return (rx1510_cur)
  rx1510_restart:
.annotate 'line', 10
    if_null rx1510_debug, debug_1181
    rx1510_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1181:
  rx1510_fail:
    (rx1510_rep, rx1510_pos, $I10, $P10) = rx1510_cur."!mark_fail"(0)
    lt rx1510_pos, -1, rx1510_done
    eq rx1510_pos, -1, rx1510_fail
    jump $I10
  rx1510_done:
    rx1510_cur."!cursor_fail"()
    if_null rx1510_debug, debug_1182
    rx1510_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1182:
    .return (rx1510_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :subid("270_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1513, "ResizablePMCArray"
    push $P1513, "{"
    .return ($P1513)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("271_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1515_tgt
    .local int rx1515_pos
    .local int rx1515_off
    .local int rx1515_eos
    .local int rx1515_rep
    .local pmc rx1515_cur
    .local pmc rx1515_debug
    (rx1515_cur, rx1515_pos, rx1515_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1515_cur
    .local pmc match
    .lex "$/", match
    length rx1515_eos, rx1515_tgt
    gt rx1515_pos, rx1515_eos, rx1515_done
    set rx1515_off, 0
    lt rx1515_pos, 2, rx1515_start
    sub rx1515_off, rx1515_pos, 1
    substr rx1515_tgt, rx1515_tgt, rx1515_off
  rx1515_start:
    eq $I10, 1, rx1515_restart
    if_null rx1515_debug, debug_1183
    rx1515_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1183:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1516_done
    goto rxscan1516_scan
  rxscan1516_loop:
    (rx1515_pos) = rx1515_cur."from"()
    inc rx1515_pos
    rx1515_cur."!cursor_from"(rx1515_pos)
    ge rx1515_pos, rx1515_eos, rxscan1516_done
  rxscan1516_scan:
    set_addr $I10, rxscan1516_loop
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10)
  rxscan1516_done:
.annotate 'line', 599
  # rx subrule "sigil" subtype=capture negate=
    rx1515_cur."!cursor_pos"(rx1515_pos)
    $P10 = rx1515_cur."sigil"()
    unless $P10, rx1515_fail
    rx1515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1515_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1515_pos, 1
    gt $I11, rx1515_eos, rx1515_fail
    sub $I11, rx1515_pos, rx1515_off
    ord $I11, rx1515_tgt, $I11
    ne $I11, 40, rx1515_fail
    add rx1515_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1515_cur."!cursor_pos"(rx1515_pos)
    $P10 = rx1515_cur."semilist"()
    unless $P10, rx1515_fail
    rx1515_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1515_pos = $P10."pos"()
  alt1517_0:
    set_addr $I10, alt1517_1
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10)
  # rx literal  ")"
    add $I11, rx1515_pos, 1
    gt $I11, rx1515_eos, rx1515_fail
    sub $I11, rx1515_pos, rx1515_off
    ord $I11, rx1515_tgt, $I11
    ne $I11, 41, rx1515_fail
    add rx1515_pos, 1
    goto alt1517_end
  alt1517_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1515_cur."!cursor_pos"(rx1515_pos)
    $P10 = rx1515_cur."FAILGOAL"("')'")
    unless $P10, rx1515_fail
    goto rxsubrule1519_pass
  rxsubrule1519_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1515_fail
  rxsubrule1519_pass:
    set_addr $I10, rxsubrule1519_back
    rx1515_cur."!mark_push"(0, rx1515_pos, $I10, $P10)
    rx1515_pos = $P10."pos"()
  alt1517_end:
  # rx pass
    rx1515_cur."!cursor_pass"(rx1515_pos, "circumfix:sym<sigil>")
    if_null rx1515_debug, debug_1184
    rx1515_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1515_pos)
  debug_1184:
    .return (rx1515_cur)
  rx1515_restart:
.annotate 'line', 10
    if_null rx1515_debug, debug_1185
    rx1515_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1185:
  rx1515_fail:
    (rx1515_rep, rx1515_pos, $I10, $P10) = rx1515_cur."!mark_fail"(0)
    lt rx1515_pos, -1, rx1515_done
    eq rx1515_pos, -1, rx1515_fail
    jump $I10
  rx1515_done:
    rx1515_cur."!cursor_fail"()
    if_null rx1515_debug, debug_1186
    rx1515_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1186:
    .return (rx1515_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :subid("272_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1521 = self."!PREFIX__!subrule"("sigil", "")
    new $P1522, "ResizablePMCArray"
    push $P1522, $P1521
    .return ($P1522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("273_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1524_tgt
    .local int rx1524_pos
    .local int rx1524_off
    .local int rx1524_eos
    .local int rx1524_rep
    .local pmc rx1524_cur
    .local pmc rx1524_debug
    (rx1524_cur, rx1524_pos, rx1524_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1524_cur
    .local pmc match
    .lex "$/", match
    length rx1524_eos, rx1524_tgt
    gt rx1524_pos, rx1524_eos, rx1524_done
    set rx1524_off, 0
    lt rx1524_pos, 2, rx1524_start
    sub rx1524_off, rx1524_pos, 1
    substr rx1524_tgt, rx1524_tgt, rx1524_off
  rx1524_start:
    eq $I10, 1, rx1524_restart
    if_null rx1524_debug, debug_1187
    rx1524_cur."!cursor_debug"("START", "semilist")
  debug_1187:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1524_pos) = rx1524_cur."from"()
    inc rx1524_pos
    rx1524_cur."!cursor_from"(rx1524_pos)
    ge rx1524_pos, rx1524_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1524_cur."!mark_push"(0, rx1524_pos, $I10)
  rxscan1525_done:
.annotate 'line', 601
  # rx subrule "ws" subtype=method negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."ws"()
    unless $P10, rx1524_fail
    rx1524_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."statement"()
    unless $P10, rx1524_fail
    rx1524_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1524_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1524_cur."!cursor_pos"(rx1524_pos)
    $P10 = rx1524_cur."ws"()
    unless $P10, rx1524_fail
    rx1524_pos = $P10."pos"()
  # rx pass
    rx1524_cur."!cursor_pass"(rx1524_pos, "semilist")
    if_null rx1524_debug, debug_1188
    rx1524_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1524_pos)
  debug_1188:
    .return (rx1524_cur)
  rx1524_restart:
.annotate 'line', 10
    if_null rx1524_debug, debug_1189
    rx1524_cur."!cursor_debug"("NEXT", "semilist")
  debug_1189:
  rx1524_fail:
    (rx1524_rep, rx1524_pos, $I10, $P10) = rx1524_cur."!mark_fail"(0)
    lt rx1524_pos, -1, rx1524_done
    eq rx1524_pos, -1, rx1524_fail
    jump $I10
  rx1524_done:
    rx1524_cur."!cursor_fail"()
    if_null rx1524_debug, debug_1190
    rx1524_cur."!cursor_debug"("FAIL", "semilist")
  debug_1190:
    .return (rx1524_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :subid("274_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1529 = self."!PREFIX__!subrule"("ws", "")
    new $P1530, "ResizablePMCArray"
    push $P1530, $P1529
    .return ($P1530)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("275_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1532_tgt
    .local int rx1532_pos
    .local int rx1532_off
    .local int rx1532_eos
    .local int rx1532_rep
    .local pmc rx1532_cur
    .local pmc rx1532_debug
    (rx1532_cur, rx1532_pos, rx1532_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1532_cur
    .local pmc match
    .lex "$/", match
    length rx1532_eos, rx1532_tgt
    gt rx1532_pos, rx1532_eos, rx1532_done
    set rx1532_off, 0
    lt rx1532_pos, 2, rx1532_start
    sub rx1532_off, rx1532_pos, 1
    substr rx1532_tgt, rx1532_tgt, rx1532_off
  rx1532_start:
    eq $I10, 1, rx1532_restart
    if_null rx1532_debug, debug_1191
    rx1532_cur."!cursor_debug"("START", "infixish")
  debug_1191:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1533_done
    goto rxscan1533_scan
  rxscan1533_loop:
    (rx1532_pos) = rx1532_cur."from"()
    inc rx1532_pos
    rx1532_cur."!cursor_from"(rx1532_pos)
    ge rx1532_pos, rx1532_eos, rxscan1533_done
  rxscan1533_scan:
    set_addr $I10, rxscan1533_loop
    rx1532_cur."!mark_push"(0, rx1532_pos, $I10)
  rxscan1533_done:
.annotate 'line', 624
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1532_cur."!cursor_pos"(rx1532_pos)
    $P10 = rx1532_cur."infixstopper"()
    if $P10, rx1532_fail
  # rx subrule "infix" subtype=capture negate=
    rx1532_cur."!cursor_pos"(rx1532_pos)
    $P10 = rx1532_cur."infix"()
    unless $P10, rx1532_fail
    rx1532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1532_pos = $P10."pos"()
  # rx pass
    rx1532_cur."!cursor_pass"(rx1532_pos, "infixish")
    if_null rx1532_debug, debug_1192
    rx1532_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1532_pos)
  debug_1192:
    .return (rx1532_cur)
  rx1532_restart:
.annotate 'line', 10
    if_null rx1532_debug, debug_1193
    rx1532_cur."!cursor_debug"("NEXT", "infixish")
  debug_1193:
  rx1532_fail:
    (rx1532_rep, rx1532_pos, $I10, $P10) = rx1532_cur."!mark_fail"(0)
    lt rx1532_pos, -1, rx1532_done
    eq rx1532_pos, -1, rx1532_fail
    jump $I10
  rx1532_done:
    rx1532_cur."!cursor_fail"()
    if_null rx1532_debug, debug_1194
    rx1532_cur."!cursor_debug"("FAIL", "infixish")
  debug_1194:
    .return (rx1532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :subid("276_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1535, "ResizablePMCArray"
    push $P1535, ""
    .return ($P1535)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("277_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1537_tgt
    .local int rx1537_pos
    .local int rx1537_off
    .local int rx1537_eos
    .local int rx1537_rep
    .local pmc rx1537_cur
    .local pmc rx1537_debug
    (rx1537_cur, rx1537_pos, rx1537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1537_cur
    .local pmc match
    .lex "$/", match
    length rx1537_eos, rx1537_tgt
    gt rx1537_pos, rx1537_eos, rx1537_done
    set rx1537_off, 0
    lt rx1537_pos, 2, rx1537_start
    sub rx1537_off, rx1537_pos, 1
    substr rx1537_tgt, rx1537_tgt, rx1537_off
  rx1537_start:
    eq $I10, 1, rx1537_restart
    if_null rx1537_debug, debug_1195
    rx1537_cur."!cursor_debug"("START", "infixstopper")
  debug_1195:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1538_done
    goto rxscan1538_scan
  rxscan1538_loop:
    (rx1537_pos) = rx1537_cur."from"()
    inc rx1537_pos
    rx1537_cur."!cursor_from"(rx1537_pos)
    ge rx1537_pos, rx1537_eos, rxscan1538_done
  rxscan1538_scan:
    set_addr $I10, rxscan1538_loop
    rx1537_cur."!mark_push"(0, rx1537_pos, $I10)
  rxscan1538_done:
.annotate 'line', 625
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1537_cur."!cursor_pos"(rx1537_pos)
    $P10 = rx1537_cur."lambda"()
    unless $P10, rx1537_fail
  # rx pass
    rx1537_cur."!cursor_pass"(rx1537_pos, "infixstopper")
    if_null rx1537_debug, debug_1196
    rx1537_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1537_pos)
  debug_1196:
    .return (rx1537_cur)
  rx1537_restart:
.annotate 'line', 10
    if_null rx1537_debug, debug_1197
    rx1537_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1197:
  rx1537_fail:
    (rx1537_rep, rx1537_pos, $I10, $P10) = rx1537_cur."!mark_fail"(0)
    lt rx1537_pos, -1, rx1537_done
    eq rx1537_pos, -1, rx1537_fail
    jump $I10
  rx1537_done:
    rx1537_cur."!cursor_fail"()
    if_null rx1537_debug, debug_1198
    rx1537_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1198:
    .return (rx1537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :subid("278_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1540, "ResizablePMCArray"
    push $P1540, ""
    .return ($P1540)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("279_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1542_tgt
    .local int rx1542_pos
    .local int rx1542_off
    .local int rx1542_eos
    .local int rx1542_rep
    .local pmc rx1542_cur
    .local pmc rx1542_debug
    (rx1542_cur, rx1542_pos, rx1542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1542_cur
    .local pmc match
    .lex "$/", match
    length rx1542_eos, rx1542_tgt
    gt rx1542_pos, rx1542_eos, rx1542_done
    set rx1542_off, 0
    lt rx1542_pos, 2, rx1542_start
    sub rx1542_off, rx1542_pos, 1
    substr rx1542_tgt, rx1542_tgt, rx1542_off
  rx1542_start:
    eq $I10, 1, rx1542_restart
    if_null rx1542_debug, debug_1199
    rx1542_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1199:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1543_done
    goto rxscan1543_scan
  rxscan1543_loop:
    (rx1542_pos) = rx1542_cur."from"()
    inc rx1542_pos
    rx1542_cur."!cursor_from"(rx1542_pos)
    ge rx1542_pos, rx1542_eos, rxscan1543_done
  rxscan1543_scan:
    set_addr $I10, rxscan1543_loop
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  rxscan1543_done:
.annotate 'line', 628
  # rx literal  "["
    add $I11, rx1542_pos, 1
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    ord $I11, rx1542_tgt, $I11
    ne $I11, 91, rx1542_fail
    add rx1542_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."ws"()
    unless $P10, rx1542_fail
    rx1542_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."EXPR"()
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1542_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1542_pos, 1
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    ord $I11, rx1542_tgt, $I11
    ne $I11, 93, rx1542_fail
    add rx1542_pos, 1
.annotate 'line', 629
  # rx subrule "O" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."O"("%methodop")
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1542_pos = $P10."pos"()
.annotate 'line', 627
  # rx pass
    rx1542_cur."!cursor_pass"(rx1542_pos, "postcircumfix:sym<[ ]>")
    if_null rx1542_debug, debug_1200
    rx1542_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1542_pos)
  debug_1200:
    .return (rx1542_cur)
  rx1542_restart:
.annotate 'line', 10
    if_null rx1542_debug, debug_1201
    rx1542_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1201:
  rx1542_fail:
    (rx1542_rep, rx1542_pos, $I10, $P10) = rx1542_cur."!mark_fail"(0)
    lt rx1542_pos, -1, rx1542_done
    eq rx1542_pos, -1, rx1542_fail
    jump $I10
  rx1542_done:
    rx1542_cur."!cursor_fail"()
    if_null rx1542_debug, debug_1202
    rx1542_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1202:
    .return (rx1542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :subid("280_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1545 = self."!PREFIX__!subrule"("ws", "[")
    new $P1546, "ResizablePMCArray"
    push $P1546, $P1545
    .return ($P1546)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("281_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1548_tgt
    .local int rx1548_pos
    .local int rx1548_off
    .local int rx1548_eos
    .local int rx1548_rep
    .local pmc rx1548_cur
    .local pmc rx1548_debug
    (rx1548_cur, rx1548_pos, rx1548_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1548_cur
    .local pmc match
    .lex "$/", match
    length rx1548_eos, rx1548_tgt
    gt rx1548_pos, rx1548_eos, rx1548_done
    set rx1548_off, 0
    lt rx1548_pos, 2, rx1548_start
    sub rx1548_off, rx1548_pos, 1
    substr rx1548_tgt, rx1548_tgt, rx1548_off
  rx1548_start:
    eq $I10, 1, rx1548_restart
    if_null rx1548_debug, debug_1203
    rx1548_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1203:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1549_done
    goto rxscan1549_scan
  rxscan1549_loop:
    (rx1548_pos) = rx1548_cur."from"()
    inc rx1548_pos
    rx1548_cur."!cursor_from"(rx1548_pos)
    ge rx1548_pos, rx1548_eos, rxscan1549_done
  rxscan1549_scan:
    set_addr $I10, rxscan1549_loop
    rx1548_cur."!mark_push"(0, rx1548_pos, $I10)
  rxscan1549_done:
.annotate 'line', 633
  # rx literal  "{"
    add $I11, rx1548_pos, 1
    gt $I11, rx1548_eos, rx1548_fail
    sub $I11, rx1548_pos, rx1548_off
    ord $I11, rx1548_tgt, $I11
    ne $I11, 123, rx1548_fail
    add rx1548_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."ws"()
    unless $P10, rx1548_fail
    rx1548_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."EXPR"()
    unless $P10, rx1548_fail
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1548_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1548_pos, 1
    gt $I11, rx1548_eos, rx1548_fail
    sub $I11, rx1548_pos, rx1548_off
    ord $I11, rx1548_tgt, $I11
    ne $I11, 125, rx1548_fail
    add rx1548_pos, 1
.annotate 'line', 634
  # rx subrule "O" subtype=capture negate=
    rx1548_cur."!cursor_pos"(rx1548_pos)
    $P10 = rx1548_cur."O"("%methodop")
    unless $P10, rx1548_fail
    rx1548_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1548_pos = $P10."pos"()
.annotate 'line', 632
  # rx pass
    rx1548_cur."!cursor_pass"(rx1548_pos, "postcircumfix:sym<{ }>")
    if_null rx1548_debug, debug_1204
    rx1548_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1548_pos)
  debug_1204:
    .return (rx1548_cur)
  rx1548_restart:
.annotate 'line', 10
    if_null rx1548_debug, debug_1205
    rx1548_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1205:
  rx1548_fail:
    (rx1548_rep, rx1548_pos, $I10, $P10) = rx1548_cur."!mark_fail"(0)
    lt rx1548_pos, -1, rx1548_done
    eq rx1548_pos, -1, rx1548_fail
    jump $I10
  rx1548_done:
    rx1548_cur."!cursor_fail"()
    if_null rx1548_debug, debug_1206
    rx1548_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1206:
    .return (rx1548_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :subid("282_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1551 = self."!PREFIX__!subrule"("ws", "{")
    new $P1552, "ResizablePMCArray"
    push $P1552, $P1551
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("283_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1554_tgt
    .local int rx1554_pos
    .local int rx1554_off
    .local int rx1554_eos
    .local int rx1554_rep
    .local pmc rx1554_cur
    .local pmc rx1554_debug
    (rx1554_cur, rx1554_pos, rx1554_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1554_cur
    .local pmc match
    .lex "$/", match
    length rx1554_eos, rx1554_tgt
    gt rx1554_pos, rx1554_eos, rx1554_done
    set rx1554_off, 0
    lt rx1554_pos, 2, rx1554_start
    sub rx1554_off, rx1554_pos, 1
    substr rx1554_tgt, rx1554_tgt, rx1554_off
  rx1554_start:
    eq $I10, 1, rx1554_restart
    if_null rx1554_debug, debug_1207
    rx1554_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1207:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1555_done
    goto rxscan1555_scan
  rxscan1555_loop:
    (rx1554_pos) = rx1554_cur."from"()
    inc rx1554_pos
    rx1554_cur."!cursor_from"(rx1554_pos)
    ge rx1554_pos, rx1554_eos, rxscan1555_done
  rxscan1555_scan:
    set_addr $I10, rxscan1555_loop
    rx1554_cur."!mark_push"(0, rx1554_pos, $I10)
  rxscan1555_done:
.annotate 'line', 638
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1554_pos, rx1554_off
    substr $S10, rx1554_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1554_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."quote_EXPR"(":q")
    unless $P10, rx1554_fail
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1554_pos = $P10."pos"()
.annotate 'line', 639
  # rx subrule "O" subtype=capture negate=
    rx1554_cur."!cursor_pos"(rx1554_pos)
    $P10 = rx1554_cur."O"("%methodop")
    unless $P10, rx1554_fail
    rx1554_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1554_pos = $P10."pos"()
.annotate 'line', 637
  # rx pass
    rx1554_cur."!cursor_pass"(rx1554_pos, "postcircumfix:sym<ang>")
    if_null rx1554_debug, debug_1208
    rx1554_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1554_pos)
  debug_1208:
    .return (rx1554_cur)
  rx1554_restart:
.annotate 'line', 10
    if_null rx1554_debug, debug_1209
    rx1554_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1209:
  rx1554_fail:
    (rx1554_rep, rx1554_pos, $I10, $P10) = rx1554_cur."!mark_fail"(0)
    lt rx1554_pos, -1, rx1554_done
    eq rx1554_pos, -1, rx1554_fail
    jump $I10
  rx1554_done:
    rx1554_cur."!cursor_fail"()
    if_null rx1554_debug, debug_1210
    rx1554_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1210:
    .return (rx1554_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :subid("284_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1557, "ResizablePMCArray"
    push $P1557, "<"
    .return ($P1557)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("285_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1559_tgt
    .local int rx1559_pos
    .local int rx1559_off
    .local int rx1559_eos
    .local int rx1559_rep
    .local pmc rx1559_cur
    .local pmc rx1559_debug
    (rx1559_cur, rx1559_pos, rx1559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1559_cur
    .local pmc match
    .lex "$/", match
    length rx1559_eos, rx1559_tgt
    gt rx1559_pos, rx1559_eos, rx1559_done
    set rx1559_off, 0
    lt rx1559_pos, 2, rx1559_start
    sub rx1559_off, rx1559_pos, 1
    substr rx1559_tgt, rx1559_tgt, rx1559_off
  rx1559_start:
    eq $I10, 1, rx1559_restart
    if_null rx1559_debug, debug_1211
    rx1559_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1211:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1559_pos) = rx1559_cur."from"()
    inc rx1559_pos
    rx1559_cur."!cursor_from"(rx1559_pos)
    ge rx1559_pos, rx1559_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  rxscan1560_done:
.annotate 'line', 643
  # rx literal  "("
    add $I11, rx1559_pos, 1
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    ord $I11, rx1559_tgt, $I11
    ne $I11, 40, rx1559_fail
    add rx1559_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."ws"()
    unless $P10, rx1559_fail
    rx1559_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."arglist"()
    unless $P10, rx1559_fail
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1559_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1559_pos, 1
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    ord $I11, rx1559_tgt, $I11
    ne $I11, 41, rx1559_fail
    add rx1559_pos, 1
.annotate 'line', 644
  # rx subrule "O" subtype=capture negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."O"("%methodop")
    unless $P10, rx1559_fail
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1559_pos = $P10."pos"()
.annotate 'line', 642
  # rx pass
    rx1559_cur."!cursor_pass"(rx1559_pos, "postcircumfix:sym<( )>")
    if_null rx1559_debug, debug_1212
    rx1559_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1559_pos)
  debug_1212:
    .return (rx1559_cur)
  rx1559_restart:
.annotate 'line', 10
    if_null rx1559_debug, debug_1213
    rx1559_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1213:
  rx1559_fail:
    (rx1559_rep, rx1559_pos, $I10, $P10) = rx1559_cur."!mark_fail"(0)
    lt rx1559_pos, -1, rx1559_done
    eq rx1559_pos, -1, rx1559_fail
    jump $I10
  rx1559_done:
    rx1559_cur."!cursor_fail"()
    if_null rx1559_debug, debug_1214
    rx1559_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1214:
    .return (rx1559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :subid("286_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1562 = self."!PREFIX__!subrule"("ws", "(")
    new $P1563, "ResizablePMCArray"
    push $P1563, $P1562
    .return ($P1563)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("287_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1565_tgt
    .local int rx1565_pos
    .local int rx1565_off
    .local int rx1565_eos
    .local int rx1565_rep
    .local pmc rx1565_cur
    .local pmc rx1565_debug
    (rx1565_cur, rx1565_pos, rx1565_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1565_cur
    .local pmc match
    .lex "$/", match
    length rx1565_eos, rx1565_tgt
    gt rx1565_pos, rx1565_eos, rx1565_done
    set rx1565_off, 0
    lt rx1565_pos, 2, rx1565_start
    sub rx1565_off, rx1565_pos, 1
    substr rx1565_tgt, rx1565_tgt, rx1565_off
  rx1565_start:
    eq $I10, 1, rx1565_restart
    if_null rx1565_debug, debug_1215
    rx1565_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1215:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1566_done
    goto rxscan1566_scan
  rxscan1566_loop:
    (rx1565_pos) = rx1565_cur."from"()
    inc rx1565_pos
    rx1565_cur."!cursor_from"(rx1565_pos)
    ge rx1565_pos, rx1565_eos, rxscan1566_done
  rxscan1566_scan:
    set_addr $I10, rxscan1566_loop
    rx1565_cur."!mark_push"(0, rx1565_pos, $I10)
  rxscan1566_done:
.annotate 'line', 647
  # rx subrule "dotty" subtype=capture negate=
    rx1565_cur."!cursor_pos"(rx1565_pos)
    $P10 = rx1565_cur."dotty"()
    unless $P10, rx1565_fail
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1565_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1565_cur."!cursor_pos"(rx1565_pos)
    $P10 = rx1565_cur."O"("%methodop")
    unless $P10, rx1565_fail
    rx1565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1565_pos = $P10."pos"()
  # rx pass
    rx1565_cur."!cursor_pass"(rx1565_pos, "postfix:sym<.>")
    if_null rx1565_debug, debug_1216
    rx1565_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1565_pos)
  debug_1216:
    .return (rx1565_cur)
  rx1565_restart:
.annotate 'line', 10
    if_null rx1565_debug, debug_1217
    rx1565_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1217:
  rx1565_fail:
    (rx1565_rep, rx1565_pos, $I10, $P10) = rx1565_cur."!mark_fail"(0)
    lt rx1565_pos, -1, rx1565_done
    eq rx1565_pos, -1, rx1565_fail
    jump $I10
  rx1565_done:
    rx1565_cur."!cursor_fail"()
    if_null rx1565_debug, debug_1218
    rx1565_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1218:
    .return (rx1565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :subid("288_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1568 = self."!PREFIX__!subrule"("dotty", "")
    new $P1569, "ResizablePMCArray"
    push $P1569, $P1568
    .return ($P1569)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("289_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1571_tgt
    .local int rx1571_pos
    .local int rx1571_off
    .local int rx1571_eos
    .local int rx1571_rep
    .local pmc rx1571_cur
    .local pmc rx1571_debug
    (rx1571_cur, rx1571_pos, rx1571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1571_cur
    .local pmc match
    .lex "$/", match
    length rx1571_eos, rx1571_tgt
    gt rx1571_pos, rx1571_eos, rx1571_done
    set rx1571_off, 0
    lt rx1571_pos, 2, rx1571_start
    sub rx1571_off, rx1571_pos, 1
    substr rx1571_tgt, rx1571_tgt, rx1571_off
  rx1571_start:
    eq $I10, 1, rx1571_restart
    if_null rx1571_debug, debug_1219
    rx1571_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1219:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1572_done
    goto rxscan1572_scan
  rxscan1572_loop:
    (rx1571_pos) = rx1571_cur."from"()
    inc rx1571_pos
    rx1571_cur."!cursor_from"(rx1571_pos)
    ge rx1571_pos, rx1571_eos, rxscan1572_done
  rxscan1572_scan:
    set_addr $I10, rxscan1572_loop
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  rxscan1572_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1573_fail
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  # rx literal  "++"
    add $I11, rx1571_pos, 2
    gt $I11, rx1571_eos, rx1571_fail
    sub $I11, rx1571_pos, rx1571_off
    substr $S10, rx1571_tgt, $I11, 2
    ne $S10, "++", rx1571_fail
    add rx1571_pos, 2
    set_addr $I10, rxcap_1573_fail
    ($I12, $I11) = rx1571_cur."!mark_peek"($I10)
    rx1571_cur."!cursor_pos"($I11)
    ($P10) = rx1571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1571_pos, "")
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1573_done
  rxcap_1573_fail:
    goto rx1571_fail
  rxcap_1573_done:
  # rx subrule "O" subtype=capture negate=
    rx1571_cur."!cursor_pos"(rx1571_pos)
    $P10 = rx1571_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1571_fail
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1571_pos = $P10."pos"()
  # rx pass
    rx1571_cur."!cursor_pass"(rx1571_pos, "prefix:sym<++>")
    if_null rx1571_debug, debug_1220
    rx1571_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1571_pos)
  debug_1220:
    .return (rx1571_cur)
  rx1571_restart:
.annotate 'line', 10
    if_null rx1571_debug, debug_1221
    rx1571_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1221:
  rx1571_fail:
    (rx1571_rep, rx1571_pos, $I10, $P10) = rx1571_cur."!mark_fail"(0)
    lt rx1571_pos, -1, rx1571_done
    eq rx1571_pos, -1, rx1571_fail
    jump $I10
  rx1571_done:
    rx1571_cur."!cursor_fail"()
    if_null rx1571_debug, debug_1222
    rx1571_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1222:
    .return (rx1571_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :subid("290_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1575 = self."!PREFIX__!subrule"("O", "++")
    new $P1576, "ResizablePMCArray"
    push $P1576, $P1575
    .return ($P1576)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("291_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1578_tgt
    .local int rx1578_pos
    .local int rx1578_off
    .local int rx1578_eos
    .local int rx1578_rep
    .local pmc rx1578_cur
    .local pmc rx1578_debug
    (rx1578_cur, rx1578_pos, rx1578_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1578_cur
    .local pmc match
    .lex "$/", match
    length rx1578_eos, rx1578_tgt
    gt rx1578_pos, rx1578_eos, rx1578_done
    set rx1578_off, 0
    lt rx1578_pos, 2, rx1578_start
    sub rx1578_off, rx1578_pos, 1
    substr rx1578_tgt, rx1578_tgt, rx1578_off
  rx1578_start:
    eq $I10, 1, rx1578_restart
    if_null rx1578_debug, debug_1223
    rx1578_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1223:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1579_done
    goto rxscan1579_scan
  rxscan1579_loop:
    (rx1578_pos) = rx1578_cur."from"()
    inc rx1578_pos
    rx1578_cur."!cursor_from"(rx1578_pos)
    ge rx1578_pos, rx1578_eos, rxscan1579_done
  rxscan1579_scan:
    set_addr $I10, rxscan1579_loop
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  rxscan1579_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1580_fail
    rx1578_cur."!mark_push"(0, rx1578_pos, $I10)
  # rx literal  "--"
    add $I11, rx1578_pos, 2
    gt $I11, rx1578_eos, rx1578_fail
    sub $I11, rx1578_pos, rx1578_off
    substr $S10, rx1578_tgt, $I11, 2
    ne $S10, "--", rx1578_fail
    add rx1578_pos, 2
    set_addr $I10, rxcap_1580_fail
    ($I12, $I11) = rx1578_cur."!mark_peek"($I10)
    rx1578_cur."!cursor_pos"($I11)
    ($P10) = rx1578_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1578_pos, "")
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1580_done
  rxcap_1580_fail:
    goto rx1578_fail
  rxcap_1580_done:
  # rx subrule "O" subtype=capture negate=
    rx1578_cur."!cursor_pos"(rx1578_pos)
    $P10 = rx1578_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1578_fail
    rx1578_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1578_pos = $P10."pos"()
  # rx pass
    rx1578_cur."!cursor_pass"(rx1578_pos, "prefix:sym<-->")
    if_null rx1578_debug, debug_1224
    rx1578_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1578_pos)
  debug_1224:
    .return (rx1578_cur)
  rx1578_restart:
.annotate 'line', 10
    if_null rx1578_debug, debug_1225
    rx1578_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1225:
  rx1578_fail:
    (rx1578_rep, rx1578_pos, $I10, $P10) = rx1578_cur."!mark_fail"(0)
    lt rx1578_pos, -1, rx1578_done
    eq rx1578_pos, -1, rx1578_fail
    jump $I10
  rx1578_done:
    rx1578_cur."!cursor_fail"()
    if_null rx1578_debug, debug_1226
    rx1578_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1226:
    .return (rx1578_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :subid("292_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1582 = self."!PREFIX__!subrule"("O", "--")
    new $P1583, "ResizablePMCArray"
    push $P1583, $P1582
    .return ($P1583)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("293_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1585_tgt
    .local int rx1585_pos
    .local int rx1585_off
    .local int rx1585_eos
    .local int rx1585_rep
    .local pmc rx1585_cur
    .local pmc rx1585_debug
    (rx1585_cur, rx1585_pos, rx1585_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1585_cur
    .local pmc match
    .lex "$/", match
    length rx1585_eos, rx1585_tgt
    gt rx1585_pos, rx1585_eos, rx1585_done
    set rx1585_off, 0
    lt rx1585_pos, 2, rx1585_start
    sub rx1585_off, rx1585_pos, 1
    substr rx1585_tgt, rx1585_tgt, rx1585_off
  rx1585_start:
    eq $I10, 1, rx1585_restart
    if_null rx1585_debug, debug_1227
    rx1585_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1227:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1586_done
    goto rxscan1586_scan
  rxscan1586_loop:
    (rx1585_pos) = rx1585_cur."from"()
    inc rx1585_pos
    rx1585_cur."!cursor_from"(rx1585_pos)
    ge rx1585_pos, rx1585_eos, rxscan1586_done
  rxscan1586_scan:
    set_addr $I10, rxscan1586_loop
    rx1585_cur."!mark_push"(0, rx1585_pos, $I10)
  rxscan1586_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1587_fail
    rx1585_cur."!mark_push"(0, rx1585_pos, $I10)
  # rx literal  "++"
    add $I11, rx1585_pos, 2
    gt $I11, rx1585_eos, rx1585_fail
    sub $I11, rx1585_pos, rx1585_off
    substr $S10, rx1585_tgt, $I11, 2
    ne $S10, "++", rx1585_fail
    add rx1585_pos, 2
    set_addr $I10, rxcap_1587_fail
    ($I12, $I11) = rx1585_cur."!mark_peek"($I10)
    rx1585_cur."!cursor_pos"($I11)
    ($P10) = rx1585_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1585_pos, "")
    rx1585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1587_done
  rxcap_1587_fail:
    goto rx1585_fail
  rxcap_1587_done:
  # rx subrule "O" subtype=capture negate=
    rx1585_cur."!cursor_pos"(rx1585_pos)
    $P10 = rx1585_cur."O"("%autoincrement")
    unless $P10, rx1585_fail
    rx1585_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1585_pos = $P10."pos"()
  # rx pass
    rx1585_cur."!cursor_pass"(rx1585_pos, "postfix:sym<++>")
    if_null rx1585_debug, debug_1228
    rx1585_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1585_pos)
  debug_1228:
    .return (rx1585_cur)
  rx1585_restart:
.annotate 'line', 10
    if_null rx1585_debug, debug_1229
    rx1585_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1229:
  rx1585_fail:
    (rx1585_rep, rx1585_pos, $I10, $P10) = rx1585_cur."!mark_fail"(0)
    lt rx1585_pos, -1, rx1585_done
    eq rx1585_pos, -1, rx1585_fail
    jump $I10
  rx1585_done:
    rx1585_cur."!cursor_fail"()
    if_null rx1585_debug, debug_1230
    rx1585_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1230:
    .return (rx1585_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :subid("294_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1589 = self."!PREFIX__!subrule"("O", "++")
    new $P1590, "ResizablePMCArray"
    push $P1590, $P1589
    .return ($P1590)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("295_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1592_tgt
    .local int rx1592_pos
    .local int rx1592_off
    .local int rx1592_eos
    .local int rx1592_rep
    .local pmc rx1592_cur
    .local pmc rx1592_debug
    (rx1592_cur, rx1592_pos, rx1592_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1592_cur
    .local pmc match
    .lex "$/", match
    length rx1592_eos, rx1592_tgt
    gt rx1592_pos, rx1592_eos, rx1592_done
    set rx1592_off, 0
    lt rx1592_pos, 2, rx1592_start
    sub rx1592_off, rx1592_pos, 1
    substr rx1592_tgt, rx1592_tgt, rx1592_off
  rx1592_start:
    eq $I10, 1, rx1592_restart
    if_null rx1592_debug, debug_1231
    rx1592_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1231:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1593_done
    goto rxscan1593_scan
  rxscan1593_loop:
    (rx1592_pos) = rx1592_cur."from"()
    inc rx1592_pos
    rx1592_cur."!cursor_from"(rx1592_pos)
    ge rx1592_pos, rx1592_eos, rxscan1593_done
  rxscan1593_scan:
    set_addr $I10, rxscan1593_loop
    rx1592_cur."!mark_push"(0, rx1592_pos, $I10)
  rxscan1593_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1594_fail
    rx1592_cur."!mark_push"(0, rx1592_pos, $I10)
  # rx literal  "--"
    add $I11, rx1592_pos, 2
    gt $I11, rx1592_eos, rx1592_fail
    sub $I11, rx1592_pos, rx1592_off
    substr $S10, rx1592_tgt, $I11, 2
    ne $S10, "--", rx1592_fail
    add rx1592_pos, 2
    set_addr $I10, rxcap_1594_fail
    ($I12, $I11) = rx1592_cur."!mark_peek"($I10)
    rx1592_cur."!cursor_pos"($I11)
    ($P10) = rx1592_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1592_pos, "")
    rx1592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1594_done
  rxcap_1594_fail:
    goto rx1592_fail
  rxcap_1594_done:
  # rx subrule "O" subtype=capture negate=
    rx1592_cur."!cursor_pos"(rx1592_pos)
    $P10 = rx1592_cur."O"("%autoincrement")
    unless $P10, rx1592_fail
    rx1592_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1592_pos = $P10."pos"()
  # rx pass
    rx1592_cur."!cursor_pass"(rx1592_pos, "postfix:sym<-->")
    if_null rx1592_debug, debug_1232
    rx1592_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1592_pos)
  debug_1232:
    .return (rx1592_cur)
  rx1592_restart:
.annotate 'line', 10
    if_null rx1592_debug, debug_1233
    rx1592_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1233:
  rx1592_fail:
    (rx1592_rep, rx1592_pos, $I10, $P10) = rx1592_cur."!mark_fail"(0)
    lt rx1592_pos, -1, rx1592_done
    eq rx1592_pos, -1, rx1592_fail
    jump $I10
  rx1592_done:
    rx1592_cur."!cursor_fail"()
    if_null rx1592_debug, debug_1234
    rx1592_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1234:
    .return (rx1592_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :subid("296_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1596 = self."!PREFIX__!subrule"("O", "--")
    new $P1597, "ResizablePMCArray"
    push $P1597, $P1596
    .return ($P1597)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("297_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1599_tgt
    .local int rx1599_pos
    .local int rx1599_off
    .local int rx1599_eos
    .local int rx1599_rep
    .local pmc rx1599_cur
    .local pmc rx1599_debug
    (rx1599_cur, rx1599_pos, rx1599_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1599_cur
    .local pmc match
    .lex "$/", match
    length rx1599_eos, rx1599_tgt
    gt rx1599_pos, rx1599_eos, rx1599_done
    set rx1599_off, 0
    lt rx1599_pos, 2, rx1599_start
    sub rx1599_off, rx1599_pos, 1
    substr rx1599_tgt, rx1599_tgt, rx1599_off
  rx1599_start:
    eq $I10, 1, rx1599_restart
    if_null rx1599_debug, debug_1235
    rx1599_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1235:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1600_done
    goto rxscan1600_scan
  rxscan1600_loop:
    (rx1599_pos) = rx1599_cur."from"()
    inc rx1599_pos
    rx1599_cur."!cursor_from"(rx1599_pos)
    ge rx1599_pos, rx1599_eos, rxscan1600_done
  rxscan1600_scan:
    set_addr $I10, rxscan1600_loop
    rx1599_cur."!mark_push"(0, rx1599_pos, $I10)
  rxscan1600_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1601_fail
    rx1599_cur."!mark_push"(0, rx1599_pos, $I10)
  # rx literal  "**"
    add $I11, rx1599_pos, 2
    gt $I11, rx1599_eos, rx1599_fail
    sub $I11, rx1599_pos, rx1599_off
    substr $S10, rx1599_tgt, $I11, 2
    ne $S10, "**", rx1599_fail
    add rx1599_pos, 2
    set_addr $I10, rxcap_1601_fail
    ($I12, $I11) = rx1599_cur."!mark_peek"($I10)
    rx1599_cur."!cursor_pos"($I11)
    ($P10) = rx1599_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1599_pos, "")
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1601_done
  rxcap_1601_fail:
    goto rx1599_fail
  rxcap_1601_done:
  # rx subrule "O" subtype=capture negate=
    rx1599_cur."!cursor_pos"(rx1599_pos)
    $P10 = rx1599_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1599_fail
    rx1599_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1599_pos = $P10."pos"()
  # rx pass
    rx1599_cur."!cursor_pass"(rx1599_pos, "infix:sym<**>")
    if_null rx1599_debug, debug_1236
    rx1599_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1599_pos)
  debug_1236:
    .return (rx1599_cur)
  rx1599_restart:
.annotate 'line', 10
    if_null rx1599_debug, debug_1237
    rx1599_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1237:
  rx1599_fail:
    (rx1599_rep, rx1599_pos, $I10, $P10) = rx1599_cur."!mark_fail"(0)
    lt rx1599_pos, -1, rx1599_done
    eq rx1599_pos, -1, rx1599_fail
    jump $I10
  rx1599_done:
    rx1599_cur."!cursor_fail"()
    if_null rx1599_debug, debug_1238
    rx1599_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1238:
    .return (rx1599_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :subid("298_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1603 = self."!PREFIX__!subrule"("O", "**")
    new $P1604, "ResizablePMCArray"
    push $P1604, $P1603
    .return ($P1604)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("299_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1606_tgt
    .local int rx1606_pos
    .local int rx1606_off
    .local int rx1606_eos
    .local int rx1606_rep
    .local pmc rx1606_cur
    .local pmc rx1606_debug
    (rx1606_cur, rx1606_pos, rx1606_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1606_cur
    .local pmc match
    .lex "$/", match
    length rx1606_eos, rx1606_tgt
    gt rx1606_pos, rx1606_eos, rx1606_done
    set rx1606_off, 0
    lt rx1606_pos, 2, rx1606_start
    sub rx1606_off, rx1606_pos, 1
    substr rx1606_tgt, rx1606_tgt, rx1606_off
  rx1606_start:
    eq $I10, 1, rx1606_restart
    if_null rx1606_debug, debug_1239
    rx1606_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1239:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1607_done
    goto rxscan1607_scan
  rxscan1607_loop:
    (rx1606_pos) = rx1606_cur."from"()
    inc rx1606_pos
    rx1606_cur."!cursor_from"(rx1606_pos)
    ge rx1606_pos, rx1606_eos, rxscan1607_done
  rxscan1607_scan:
    set_addr $I10, rxscan1607_loop
    rx1606_cur."!mark_push"(0, rx1606_pos, $I10)
  rxscan1607_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1608_fail
    rx1606_cur."!mark_push"(0, rx1606_pos, $I10)
  # rx literal  "+"
    add $I11, rx1606_pos, 1
    gt $I11, rx1606_eos, rx1606_fail
    sub $I11, rx1606_pos, rx1606_off
    ord $I11, rx1606_tgt, $I11
    ne $I11, 43, rx1606_fail
    add rx1606_pos, 1
    set_addr $I10, rxcap_1608_fail
    ($I12, $I11) = rx1606_cur."!mark_peek"($I10)
    rx1606_cur."!cursor_pos"($I11)
    ($P10) = rx1606_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1606_pos, "")
    rx1606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1608_done
  rxcap_1608_fail:
    goto rx1606_fail
  rxcap_1608_done:
  # rx subrule "O" subtype=capture negate=
    rx1606_cur."!cursor_pos"(rx1606_pos)
    $P10 = rx1606_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1606_fail
    rx1606_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1606_pos = $P10."pos"()
  # rx pass
    rx1606_cur."!cursor_pass"(rx1606_pos, "prefix:sym<+>")
    if_null rx1606_debug, debug_1240
    rx1606_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1606_pos)
  debug_1240:
    .return (rx1606_cur)
  rx1606_restart:
.annotate 'line', 10
    if_null rx1606_debug, debug_1241
    rx1606_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1241:
  rx1606_fail:
    (rx1606_rep, rx1606_pos, $I10, $P10) = rx1606_cur."!mark_fail"(0)
    lt rx1606_pos, -1, rx1606_done
    eq rx1606_pos, -1, rx1606_fail
    jump $I10
  rx1606_done:
    rx1606_cur."!cursor_fail"()
    if_null rx1606_debug, debug_1242
    rx1606_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1242:
    .return (rx1606_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :subid("300_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1610 = self."!PREFIX__!subrule"("O", "+")
    new $P1611, "ResizablePMCArray"
    push $P1611, $P1610
    .return ($P1611)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("301_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1613_tgt
    .local int rx1613_pos
    .local int rx1613_off
    .local int rx1613_eos
    .local int rx1613_rep
    .local pmc rx1613_cur
    .local pmc rx1613_debug
    (rx1613_cur, rx1613_pos, rx1613_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1613_cur
    .local pmc match
    .lex "$/", match
    length rx1613_eos, rx1613_tgt
    gt rx1613_pos, rx1613_eos, rx1613_done
    set rx1613_off, 0
    lt rx1613_pos, 2, rx1613_start
    sub rx1613_off, rx1613_pos, 1
    substr rx1613_tgt, rx1613_tgt, rx1613_off
  rx1613_start:
    eq $I10, 1, rx1613_restart
    if_null rx1613_debug, debug_1243
    rx1613_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1243:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1614_done
    goto rxscan1614_scan
  rxscan1614_loop:
    (rx1613_pos) = rx1613_cur."from"()
    inc rx1613_pos
    rx1613_cur."!cursor_from"(rx1613_pos)
    ge rx1613_pos, rx1613_eos, rxscan1614_done
  rxscan1614_scan:
    set_addr $I10, rxscan1614_loop
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  rxscan1614_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1615_fail
    rx1613_cur."!mark_push"(0, rx1613_pos, $I10)
  # rx literal  "~"
    add $I11, rx1613_pos, 1
    gt $I11, rx1613_eos, rx1613_fail
    sub $I11, rx1613_pos, rx1613_off
    ord $I11, rx1613_tgt, $I11
    ne $I11, 126, rx1613_fail
    add rx1613_pos, 1
    set_addr $I10, rxcap_1615_fail
    ($I12, $I11) = rx1613_cur."!mark_peek"($I10)
    rx1613_cur."!cursor_pos"($I11)
    ($P10) = rx1613_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1613_pos, "")
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1615_done
  rxcap_1615_fail:
    goto rx1613_fail
  rxcap_1615_done:
  # rx subrule "O" subtype=capture negate=
    rx1613_cur."!cursor_pos"(rx1613_pos)
    $P10 = rx1613_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1613_fail
    rx1613_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1613_pos = $P10."pos"()
  # rx pass
    rx1613_cur."!cursor_pass"(rx1613_pos, "prefix:sym<~>")
    if_null rx1613_debug, debug_1244
    rx1613_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1613_pos)
  debug_1244:
    .return (rx1613_cur)
  rx1613_restart:
.annotate 'line', 10
    if_null rx1613_debug, debug_1245
    rx1613_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1245:
  rx1613_fail:
    (rx1613_rep, rx1613_pos, $I10, $P10) = rx1613_cur."!mark_fail"(0)
    lt rx1613_pos, -1, rx1613_done
    eq rx1613_pos, -1, rx1613_fail
    jump $I10
  rx1613_done:
    rx1613_cur."!cursor_fail"()
    if_null rx1613_debug, debug_1246
    rx1613_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1246:
    .return (rx1613_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :subid("302_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1617 = self."!PREFIX__!subrule"("O", "~")
    new $P1618, "ResizablePMCArray"
    push $P1618, $P1617
    .return ($P1618)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("303_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1620_tgt
    .local int rx1620_pos
    .local int rx1620_off
    .local int rx1620_eos
    .local int rx1620_rep
    .local pmc rx1620_cur
    .local pmc rx1620_debug
    (rx1620_cur, rx1620_pos, rx1620_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1620_cur
    .local pmc match
    .lex "$/", match
    length rx1620_eos, rx1620_tgt
    gt rx1620_pos, rx1620_eos, rx1620_done
    set rx1620_off, 0
    lt rx1620_pos, 2, rx1620_start
    sub rx1620_off, rx1620_pos, 1
    substr rx1620_tgt, rx1620_tgt, rx1620_off
  rx1620_start:
    eq $I10, 1, rx1620_restart
    if_null rx1620_debug, debug_1247
    rx1620_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1247:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1621_done
    goto rxscan1621_scan
  rxscan1621_loop:
    (rx1620_pos) = rx1620_cur."from"()
    inc rx1620_pos
    rx1620_cur."!cursor_from"(rx1620_pos)
    ge rx1620_pos, rx1620_eos, rxscan1621_done
  rxscan1621_scan:
    set_addr $I10, rxscan1621_loop
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  rxscan1621_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1622_fail
    rx1620_cur."!mark_push"(0, rx1620_pos, $I10)
  # rx literal  "-"
    add $I11, rx1620_pos, 1
    gt $I11, rx1620_eos, rx1620_fail
    sub $I11, rx1620_pos, rx1620_off
    ord $I11, rx1620_tgt, $I11
    ne $I11, 45, rx1620_fail
    add rx1620_pos, 1
    set_addr $I10, rxcap_1622_fail
    ($I12, $I11) = rx1620_cur."!mark_peek"($I10)
    rx1620_cur."!cursor_pos"($I11)
    ($P10) = rx1620_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1620_pos, "")
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1622_done
  rxcap_1622_fail:
    goto rx1620_fail
  rxcap_1622_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1620_pos, rx1620_off
    substr $S10, rx1620_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1620_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1620_cur."!cursor_pos"(rx1620_pos)
    $P10 = rx1620_cur."number"()
    if $P10, rx1620_fail
  # rx subrule "O" subtype=capture negate=
    rx1620_cur."!cursor_pos"(rx1620_pos)
    $P10 = rx1620_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1620_fail
    rx1620_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1620_pos = $P10."pos"()
  # rx pass
    rx1620_cur."!cursor_pass"(rx1620_pos, "prefix:sym<->")
    if_null rx1620_debug, debug_1248
    rx1620_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1620_pos)
  debug_1248:
    .return (rx1620_cur)
  rx1620_restart:
.annotate 'line', 10
    if_null rx1620_debug, debug_1249
    rx1620_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1249:
  rx1620_fail:
    (rx1620_rep, rx1620_pos, $I10, $P10) = rx1620_cur."!mark_fail"(0)
    lt rx1620_pos, -1, rx1620_done
    eq rx1620_pos, -1, rx1620_fail
    jump $I10
  rx1620_done:
    rx1620_cur."!cursor_fail"()
    if_null rx1620_debug, debug_1250
    rx1620_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1250:
    .return (rx1620_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :subid("304_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1624, "ResizablePMCArray"
    push $P1624, "-"
    .return ($P1624)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("305_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1626_tgt
    .local int rx1626_pos
    .local int rx1626_off
    .local int rx1626_eos
    .local int rx1626_rep
    .local pmc rx1626_cur
    .local pmc rx1626_debug
    (rx1626_cur, rx1626_pos, rx1626_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1626_cur
    .local pmc match
    .lex "$/", match
    length rx1626_eos, rx1626_tgt
    gt rx1626_pos, rx1626_eos, rx1626_done
    set rx1626_off, 0
    lt rx1626_pos, 2, rx1626_start
    sub rx1626_off, rx1626_pos, 1
    substr rx1626_tgt, rx1626_tgt, rx1626_off
  rx1626_start:
    eq $I10, 1, rx1626_restart
    if_null rx1626_debug, debug_1251
    rx1626_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1251:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1627_done
    goto rxscan1627_scan
  rxscan1627_loop:
    (rx1626_pos) = rx1626_cur."from"()
    inc rx1626_pos
    rx1626_cur."!cursor_from"(rx1626_pos)
    ge rx1626_pos, rx1626_eos, rxscan1627_done
  rxscan1627_scan:
    set_addr $I10, rxscan1627_loop
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  rxscan1627_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1628_fail
    rx1626_cur."!mark_push"(0, rx1626_pos, $I10)
  # rx literal  "?"
    add $I11, rx1626_pos, 1
    gt $I11, rx1626_eos, rx1626_fail
    sub $I11, rx1626_pos, rx1626_off
    ord $I11, rx1626_tgt, $I11
    ne $I11, 63, rx1626_fail
    add rx1626_pos, 1
    set_addr $I10, rxcap_1628_fail
    ($I12, $I11) = rx1626_cur."!mark_peek"($I10)
    rx1626_cur."!cursor_pos"($I11)
    ($P10) = rx1626_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1626_pos, "")
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1628_done
  rxcap_1628_fail:
    goto rx1626_fail
  rxcap_1628_done:
  # rx subrule "O" subtype=capture negate=
    rx1626_cur."!cursor_pos"(rx1626_pos)
    $P10 = rx1626_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1626_fail
    rx1626_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1626_pos = $P10."pos"()
  # rx pass
    rx1626_cur."!cursor_pass"(rx1626_pos, "prefix:sym<?>")
    if_null rx1626_debug, debug_1252
    rx1626_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1626_pos)
  debug_1252:
    .return (rx1626_cur)
  rx1626_restart:
.annotate 'line', 10
    if_null rx1626_debug, debug_1253
    rx1626_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1253:
  rx1626_fail:
    (rx1626_rep, rx1626_pos, $I10, $P10) = rx1626_cur."!mark_fail"(0)
    lt rx1626_pos, -1, rx1626_done
    eq rx1626_pos, -1, rx1626_fail
    jump $I10
  rx1626_done:
    rx1626_cur."!cursor_fail"()
    if_null rx1626_debug, debug_1254
    rx1626_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1254:
    .return (rx1626_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :subid("306_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1630 = self."!PREFIX__!subrule"("O", "?")
    new $P1631, "ResizablePMCArray"
    push $P1631, $P1630
    .return ($P1631)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("307_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1633_tgt
    .local int rx1633_pos
    .local int rx1633_off
    .local int rx1633_eos
    .local int rx1633_rep
    .local pmc rx1633_cur
    .local pmc rx1633_debug
    (rx1633_cur, rx1633_pos, rx1633_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1633_cur
    .local pmc match
    .lex "$/", match
    length rx1633_eos, rx1633_tgt
    gt rx1633_pos, rx1633_eos, rx1633_done
    set rx1633_off, 0
    lt rx1633_pos, 2, rx1633_start
    sub rx1633_off, rx1633_pos, 1
    substr rx1633_tgt, rx1633_tgt, rx1633_off
  rx1633_start:
    eq $I10, 1, rx1633_restart
    if_null rx1633_debug, debug_1255
    rx1633_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1255:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1634_done
    goto rxscan1634_scan
  rxscan1634_loop:
    (rx1633_pos) = rx1633_cur."from"()
    inc rx1633_pos
    rx1633_cur."!cursor_from"(rx1633_pos)
    ge rx1633_pos, rx1633_eos, rxscan1634_done
  rxscan1634_scan:
    set_addr $I10, rxscan1634_loop
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  rxscan1634_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1635_fail
    rx1633_cur."!mark_push"(0, rx1633_pos, $I10)
  # rx literal  "!"
    add $I11, rx1633_pos, 1
    gt $I11, rx1633_eos, rx1633_fail
    sub $I11, rx1633_pos, rx1633_off
    ord $I11, rx1633_tgt, $I11
    ne $I11, 33, rx1633_fail
    add rx1633_pos, 1
    set_addr $I10, rxcap_1635_fail
    ($I12, $I11) = rx1633_cur."!mark_peek"($I10)
    rx1633_cur."!cursor_pos"($I11)
    ($P10) = rx1633_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1633_pos, "")
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1635_done
  rxcap_1635_fail:
    goto rx1633_fail
  rxcap_1635_done:
  # rx subrule "O" subtype=capture negate=
    rx1633_cur."!cursor_pos"(rx1633_pos)
    $P10 = rx1633_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1633_fail
    rx1633_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1633_pos = $P10."pos"()
  # rx pass
    rx1633_cur."!cursor_pass"(rx1633_pos, "prefix:sym<!>")
    if_null rx1633_debug, debug_1256
    rx1633_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1633_pos)
  debug_1256:
    .return (rx1633_cur)
  rx1633_restart:
.annotate 'line', 10
    if_null rx1633_debug, debug_1257
    rx1633_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1257:
  rx1633_fail:
    (rx1633_rep, rx1633_pos, $I10, $P10) = rx1633_cur."!mark_fail"(0)
    lt rx1633_pos, -1, rx1633_done
    eq rx1633_pos, -1, rx1633_fail
    jump $I10
  rx1633_done:
    rx1633_cur."!cursor_fail"()
    if_null rx1633_debug, debug_1258
    rx1633_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1258:
    .return (rx1633_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :subid("308_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1637 = self."!PREFIX__!subrule"("O", "!")
    new $P1638, "ResizablePMCArray"
    push $P1638, $P1637
    .return ($P1638)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("309_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1640_tgt
    .local int rx1640_pos
    .local int rx1640_off
    .local int rx1640_eos
    .local int rx1640_rep
    .local pmc rx1640_cur
    .local pmc rx1640_debug
    (rx1640_cur, rx1640_pos, rx1640_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1640_cur
    .local pmc match
    .lex "$/", match
    length rx1640_eos, rx1640_tgt
    gt rx1640_pos, rx1640_eos, rx1640_done
    set rx1640_off, 0
    lt rx1640_pos, 2, rx1640_start
    sub rx1640_off, rx1640_pos, 1
    substr rx1640_tgt, rx1640_tgt, rx1640_off
  rx1640_start:
    eq $I10, 1, rx1640_restart
    if_null rx1640_debug, debug_1259
    rx1640_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1259:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1641_done
    goto rxscan1641_scan
  rxscan1641_loop:
    (rx1640_pos) = rx1640_cur."from"()
    inc rx1640_pos
    rx1640_cur."!cursor_from"(rx1640_pos)
    ge rx1640_pos, rx1640_eos, rxscan1641_done
  rxscan1641_scan:
    set_addr $I10, rxscan1641_loop
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  rxscan1641_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1642_fail
    rx1640_cur."!mark_push"(0, rx1640_pos, $I10)
  # rx literal  "|"
    add $I11, rx1640_pos, 1
    gt $I11, rx1640_eos, rx1640_fail
    sub $I11, rx1640_pos, rx1640_off
    ord $I11, rx1640_tgt, $I11
    ne $I11, 124, rx1640_fail
    add rx1640_pos, 1
    set_addr $I10, rxcap_1642_fail
    ($I12, $I11) = rx1640_cur."!mark_peek"($I10)
    rx1640_cur."!cursor_pos"($I11)
    ($P10) = rx1640_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1640_pos, "")
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1642_done
  rxcap_1642_fail:
    goto rx1640_fail
  rxcap_1642_done:
  # rx subrule "O" subtype=capture negate=
    rx1640_cur."!cursor_pos"(rx1640_pos)
    $P10 = rx1640_cur."O"("%symbolic_unary")
    unless $P10, rx1640_fail
    rx1640_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1640_pos = $P10."pos"()
  # rx pass
    rx1640_cur."!cursor_pass"(rx1640_pos, "prefix:sym<|>")
    if_null rx1640_debug, debug_1260
    rx1640_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1640_pos)
  debug_1260:
    .return (rx1640_cur)
  rx1640_restart:
.annotate 'line', 10
    if_null rx1640_debug, debug_1261
    rx1640_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1261:
  rx1640_fail:
    (rx1640_rep, rx1640_pos, $I10, $P10) = rx1640_cur."!mark_fail"(0)
    lt rx1640_pos, -1, rx1640_done
    eq rx1640_pos, -1, rx1640_fail
    jump $I10
  rx1640_done:
    rx1640_cur."!cursor_fail"()
    if_null rx1640_debug, debug_1262
    rx1640_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1262:
    .return (rx1640_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :subid("310_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1644 = self."!PREFIX__!subrule"("O", "|")
    new $P1645, "ResizablePMCArray"
    push $P1645, $P1644
    .return ($P1645)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("311_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1647_tgt
    .local int rx1647_pos
    .local int rx1647_off
    .local int rx1647_eos
    .local int rx1647_rep
    .local pmc rx1647_cur
    .local pmc rx1647_debug
    (rx1647_cur, rx1647_pos, rx1647_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1647_cur
    .local pmc match
    .lex "$/", match
    length rx1647_eos, rx1647_tgt
    gt rx1647_pos, rx1647_eos, rx1647_done
    set rx1647_off, 0
    lt rx1647_pos, 2, rx1647_start
    sub rx1647_off, rx1647_pos, 1
    substr rx1647_tgt, rx1647_tgt, rx1647_off
  rx1647_start:
    eq $I10, 1, rx1647_restart
    if_null rx1647_debug, debug_1263
    rx1647_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1263:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1648_done
    goto rxscan1648_scan
  rxscan1648_loop:
    (rx1647_pos) = rx1647_cur."from"()
    inc rx1647_pos
    rx1647_cur."!cursor_from"(rx1647_pos)
    ge rx1647_pos, rx1647_eos, rxscan1648_done
  rxscan1648_scan:
    set_addr $I10, rxscan1648_loop
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxscan1648_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1649_fail
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  # rx literal  "*"
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 42, rx1647_fail
    add rx1647_pos, 1
    set_addr $I10, rxcap_1649_fail
    ($I12, $I11) = rx1647_cur."!mark_peek"($I10)
    rx1647_cur."!cursor_pos"($I11)
    ($P10) = rx1647_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1647_pos, "")
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1649_done
  rxcap_1649_fail:
    goto rx1647_fail
  rxcap_1649_done:
  # rx subrule "O" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1647_pos = $P10."pos"()
  # rx pass
    rx1647_cur."!cursor_pass"(rx1647_pos, "infix:sym<*>")
    if_null rx1647_debug, debug_1264
    rx1647_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1647_pos)
  debug_1264:
    .return (rx1647_cur)
  rx1647_restart:
.annotate 'line', 10
    if_null rx1647_debug, debug_1265
    rx1647_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1265:
  rx1647_fail:
    (rx1647_rep, rx1647_pos, $I10, $P10) = rx1647_cur."!mark_fail"(0)
    lt rx1647_pos, -1, rx1647_done
    eq rx1647_pos, -1, rx1647_fail
    jump $I10
  rx1647_done:
    rx1647_cur."!cursor_fail"()
    if_null rx1647_debug, debug_1266
    rx1647_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1266:
    .return (rx1647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :subid("312_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1651 = self."!PREFIX__!subrule"("O", "*")
    new $P1652, "ResizablePMCArray"
    push $P1652, $P1651
    .return ($P1652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("313_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1654_tgt
    .local int rx1654_pos
    .local int rx1654_off
    .local int rx1654_eos
    .local int rx1654_rep
    .local pmc rx1654_cur
    .local pmc rx1654_debug
    (rx1654_cur, rx1654_pos, rx1654_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1654_cur
    .local pmc match
    .lex "$/", match
    length rx1654_eos, rx1654_tgt
    gt rx1654_pos, rx1654_eos, rx1654_done
    set rx1654_off, 0
    lt rx1654_pos, 2, rx1654_start
    sub rx1654_off, rx1654_pos, 1
    substr rx1654_tgt, rx1654_tgt, rx1654_off
  rx1654_start:
    eq $I10, 1, rx1654_restart
    if_null rx1654_debug, debug_1267
    rx1654_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1267:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1655_done
    goto rxscan1655_scan
  rxscan1655_loop:
    (rx1654_pos) = rx1654_cur."from"()
    inc rx1654_pos
    rx1654_cur."!cursor_from"(rx1654_pos)
    ge rx1654_pos, rx1654_eos, rxscan1655_done
  rxscan1655_scan:
    set_addr $I10, rxscan1655_loop
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  rxscan1655_done:
.annotate 'line', 666
  # rx subcapture "sym"
    set_addr $I10, rxcap_1656_fail
    rx1654_cur."!mark_push"(0, rx1654_pos, $I10)
  # rx literal  "/"
    add $I11, rx1654_pos, 1
    gt $I11, rx1654_eos, rx1654_fail
    sub $I11, rx1654_pos, rx1654_off
    ord $I11, rx1654_tgt, $I11
    ne $I11, 47, rx1654_fail
    add rx1654_pos, 1
    set_addr $I10, rxcap_1656_fail
    ($I12, $I11) = rx1654_cur."!mark_peek"($I10)
    rx1654_cur."!cursor_pos"($I11)
    ($P10) = rx1654_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1654_pos, "")
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1656_done
  rxcap_1656_fail:
    goto rx1654_fail
  rxcap_1656_done:
  # rx subrule "O" subtype=capture negate=
    rx1654_cur."!cursor_pos"(rx1654_pos)
    $P10 = rx1654_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1654_fail
    rx1654_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1654_pos = $P10."pos"()
  # rx pass
    rx1654_cur."!cursor_pass"(rx1654_pos, "infix:sym</>")
    if_null rx1654_debug, debug_1268
    rx1654_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1654_pos)
  debug_1268:
    .return (rx1654_cur)
  rx1654_restart:
.annotate 'line', 10
    if_null rx1654_debug, debug_1269
    rx1654_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1269:
  rx1654_fail:
    (rx1654_rep, rx1654_pos, $I10, $P10) = rx1654_cur."!mark_fail"(0)
    lt rx1654_pos, -1, rx1654_done
    eq rx1654_pos, -1, rx1654_fail
    jump $I10
  rx1654_done:
    rx1654_cur."!cursor_fail"()
    if_null rx1654_debug, debug_1270
    rx1654_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1270:
    .return (rx1654_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :subid("314_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1658 = self."!PREFIX__!subrule"("O", "/")
    new $P1659, "ResizablePMCArray"
    push $P1659, $P1658
    .return ($P1659)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("315_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1661_tgt
    .local int rx1661_pos
    .local int rx1661_off
    .local int rx1661_eos
    .local int rx1661_rep
    .local pmc rx1661_cur
    .local pmc rx1661_debug
    (rx1661_cur, rx1661_pos, rx1661_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1661_cur
    .local pmc match
    .lex "$/", match
    length rx1661_eos, rx1661_tgt
    gt rx1661_pos, rx1661_eos, rx1661_done
    set rx1661_off, 0
    lt rx1661_pos, 2, rx1661_start
    sub rx1661_off, rx1661_pos, 1
    substr rx1661_tgt, rx1661_tgt, rx1661_off
  rx1661_start:
    eq $I10, 1, rx1661_restart
    if_null rx1661_debug, debug_1271
    rx1661_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1271:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1662_done
    goto rxscan1662_scan
  rxscan1662_loop:
    (rx1661_pos) = rx1661_cur."from"()
    inc rx1661_pos
    rx1661_cur."!cursor_from"(rx1661_pos)
    ge rx1661_pos, rx1661_eos, rxscan1662_done
  rxscan1662_scan:
    set_addr $I10, rxscan1662_loop
    rx1661_cur."!mark_push"(0, rx1661_pos, $I10)
  rxscan1662_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1663_fail
    rx1661_cur."!mark_push"(0, rx1661_pos, $I10)
  # rx literal  "%"
    add $I11, rx1661_pos, 1
    gt $I11, rx1661_eos, rx1661_fail
    sub $I11, rx1661_pos, rx1661_off
    ord $I11, rx1661_tgt, $I11
    ne $I11, 37, rx1661_fail
    add rx1661_pos, 1
    set_addr $I10, rxcap_1663_fail
    ($I12, $I11) = rx1661_cur."!mark_peek"($I10)
    rx1661_cur."!cursor_pos"($I11)
    ($P10) = rx1661_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1661_pos, "")
    rx1661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1663_done
  rxcap_1663_fail:
    goto rx1661_fail
  rxcap_1663_done:
  # rx subrule "O" subtype=capture negate=
    rx1661_cur."!cursor_pos"(rx1661_pos)
    $P10 = rx1661_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1661_fail
    rx1661_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1661_pos = $P10."pos"()
  # rx pass
    rx1661_cur."!cursor_pass"(rx1661_pos, "infix:sym<%>")
    if_null rx1661_debug, debug_1272
    rx1661_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1661_pos)
  debug_1272:
    .return (rx1661_cur)
  rx1661_restart:
.annotate 'line', 10
    if_null rx1661_debug, debug_1273
    rx1661_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1273:
  rx1661_fail:
    (rx1661_rep, rx1661_pos, $I10, $P10) = rx1661_cur."!mark_fail"(0)
    lt rx1661_pos, -1, rx1661_done
    eq rx1661_pos, -1, rx1661_fail
    jump $I10
  rx1661_done:
    rx1661_cur."!cursor_fail"()
    if_null rx1661_debug, debug_1274
    rx1661_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1274:
    .return (rx1661_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :subid("316_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1665 = self."!PREFIX__!subrule"("O", "%")
    new $P1666, "ResizablePMCArray"
    push $P1666, $P1665
    .return ($P1666)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("317_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1668_tgt
    .local int rx1668_pos
    .local int rx1668_off
    .local int rx1668_eos
    .local int rx1668_rep
    .local pmc rx1668_cur
    .local pmc rx1668_debug
    (rx1668_cur, rx1668_pos, rx1668_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1668_cur
    .local pmc match
    .lex "$/", match
    length rx1668_eos, rx1668_tgt
    gt rx1668_pos, rx1668_eos, rx1668_done
    set rx1668_off, 0
    lt rx1668_pos, 2, rx1668_start
    sub rx1668_off, rx1668_pos, 1
    substr rx1668_tgt, rx1668_tgt, rx1668_off
  rx1668_start:
    eq $I10, 1, rx1668_restart
    if_null rx1668_debug, debug_1275
    rx1668_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1275:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1669_done
    goto rxscan1669_scan
  rxscan1669_loop:
    (rx1668_pos) = rx1668_cur."from"()
    inc rx1668_pos
    rx1668_cur."!cursor_from"(rx1668_pos)
    ge rx1668_pos, rx1668_eos, rxscan1669_done
  rxscan1669_scan:
    set_addr $I10, rxscan1669_loop
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  rxscan1669_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1670_fail
    rx1668_cur."!mark_push"(0, rx1668_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1668_pos, 2
    gt $I11, rx1668_eos, rx1668_fail
    sub $I11, rx1668_pos, rx1668_off
    substr $S10, rx1668_tgt, $I11, 2
    ne $S10, "+&", rx1668_fail
    add rx1668_pos, 2
    set_addr $I10, rxcap_1670_fail
    ($I12, $I11) = rx1668_cur."!mark_peek"($I10)
    rx1668_cur."!cursor_pos"($I11)
    ($P10) = rx1668_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1668_pos, "")
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1670_done
  rxcap_1670_fail:
    goto rx1668_fail
  rxcap_1670_done:
  # rx subrule "O" subtype=capture negate=
    rx1668_cur."!cursor_pos"(rx1668_pos)
    $P10 = rx1668_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1668_fail
    rx1668_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1668_pos = $P10."pos"()
  # rx pass
    rx1668_cur."!cursor_pass"(rx1668_pos, "infix:sym<+&>")
    if_null rx1668_debug, debug_1276
    rx1668_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1668_pos)
  debug_1276:
    .return (rx1668_cur)
  rx1668_restart:
.annotate 'line', 10
    if_null rx1668_debug, debug_1277
    rx1668_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1277:
  rx1668_fail:
    (rx1668_rep, rx1668_pos, $I10, $P10) = rx1668_cur."!mark_fail"(0)
    lt rx1668_pos, -1, rx1668_done
    eq rx1668_pos, -1, rx1668_fail
    jump $I10
  rx1668_done:
    rx1668_cur."!cursor_fail"()
    if_null rx1668_debug, debug_1278
    rx1668_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1278:
    .return (rx1668_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :subid("318_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1672 = self."!PREFIX__!subrule"("O", "+&")
    new $P1673, "ResizablePMCArray"
    push $P1673, $P1672
    .return ($P1673)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("319_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1675_tgt
    .local int rx1675_pos
    .local int rx1675_off
    .local int rx1675_eos
    .local int rx1675_rep
    .local pmc rx1675_cur
    .local pmc rx1675_debug
    (rx1675_cur, rx1675_pos, rx1675_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1675_cur
    .local pmc match
    .lex "$/", match
    length rx1675_eos, rx1675_tgt
    gt rx1675_pos, rx1675_eos, rx1675_done
    set rx1675_off, 0
    lt rx1675_pos, 2, rx1675_start
    sub rx1675_off, rx1675_pos, 1
    substr rx1675_tgt, rx1675_tgt, rx1675_off
  rx1675_start:
    eq $I10, 1, rx1675_restart
    if_null rx1675_debug, debug_1279
    rx1675_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1279:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1676_done
    goto rxscan1676_scan
  rxscan1676_loop:
    (rx1675_pos) = rx1675_cur."from"()
    inc rx1675_pos
    rx1675_cur."!cursor_from"(rx1675_pos)
    ge rx1675_pos, rx1675_eos, rxscan1676_done
  rxscan1676_scan:
    set_addr $I10, rxscan1676_loop
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  rxscan1676_done:
.annotate 'line', 670
  # rx subcapture "sym"
    set_addr $I10, rxcap_1677_fail
    rx1675_cur."!mark_push"(0, rx1675_pos, $I10)
  # rx literal  "+"
    add $I11, rx1675_pos, 1
    gt $I11, rx1675_eos, rx1675_fail
    sub $I11, rx1675_pos, rx1675_off
    ord $I11, rx1675_tgt, $I11
    ne $I11, 43, rx1675_fail
    add rx1675_pos, 1
    set_addr $I10, rxcap_1677_fail
    ($I12, $I11) = rx1675_cur."!mark_peek"($I10)
    rx1675_cur."!cursor_pos"($I11)
    ($P10) = rx1675_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1675_pos, "")
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1677_done
  rxcap_1677_fail:
    goto rx1675_fail
  rxcap_1677_done:
  # rx subrule "O" subtype=capture negate=
    rx1675_cur."!cursor_pos"(rx1675_pos)
    $P10 = rx1675_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1675_fail
    rx1675_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1675_pos = $P10."pos"()
  # rx pass
    rx1675_cur."!cursor_pass"(rx1675_pos, "infix:sym<+>")
    if_null rx1675_debug, debug_1280
    rx1675_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1675_pos)
  debug_1280:
    .return (rx1675_cur)
  rx1675_restart:
.annotate 'line', 10
    if_null rx1675_debug, debug_1281
    rx1675_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1281:
  rx1675_fail:
    (rx1675_rep, rx1675_pos, $I10, $P10) = rx1675_cur."!mark_fail"(0)
    lt rx1675_pos, -1, rx1675_done
    eq rx1675_pos, -1, rx1675_fail
    jump $I10
  rx1675_done:
    rx1675_cur."!cursor_fail"()
    if_null rx1675_debug, debug_1282
    rx1675_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1282:
    .return (rx1675_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :subid("320_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1679 = self."!PREFIX__!subrule"("O", "+")
    new $P1680, "ResizablePMCArray"
    push $P1680, $P1679
    .return ($P1680)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("321_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1682_tgt
    .local int rx1682_pos
    .local int rx1682_off
    .local int rx1682_eos
    .local int rx1682_rep
    .local pmc rx1682_cur
    .local pmc rx1682_debug
    (rx1682_cur, rx1682_pos, rx1682_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1682_cur
    .local pmc match
    .lex "$/", match
    length rx1682_eos, rx1682_tgt
    gt rx1682_pos, rx1682_eos, rx1682_done
    set rx1682_off, 0
    lt rx1682_pos, 2, rx1682_start
    sub rx1682_off, rx1682_pos, 1
    substr rx1682_tgt, rx1682_tgt, rx1682_off
  rx1682_start:
    eq $I10, 1, rx1682_restart
    if_null rx1682_debug, debug_1283
    rx1682_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1283:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1683_done
    goto rxscan1683_scan
  rxscan1683_loop:
    (rx1682_pos) = rx1682_cur."from"()
    inc rx1682_pos
    rx1682_cur."!cursor_from"(rx1682_pos)
    ge rx1682_pos, rx1682_eos, rxscan1683_done
  rxscan1683_scan:
    set_addr $I10, rxscan1683_loop
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  rxscan1683_done:
.annotate 'line', 671
  # rx subcapture "sym"
    set_addr $I10, rxcap_1684_fail
    rx1682_cur."!mark_push"(0, rx1682_pos, $I10)
  # rx literal  "-"
    add $I11, rx1682_pos, 1
    gt $I11, rx1682_eos, rx1682_fail
    sub $I11, rx1682_pos, rx1682_off
    ord $I11, rx1682_tgt, $I11
    ne $I11, 45, rx1682_fail
    add rx1682_pos, 1
    set_addr $I10, rxcap_1684_fail
    ($I12, $I11) = rx1682_cur."!mark_peek"($I10)
    rx1682_cur."!cursor_pos"($I11)
    ($P10) = rx1682_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1682_pos, "")
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1684_done
  rxcap_1684_fail:
    goto rx1682_fail
  rxcap_1684_done:
  # rx subrule "O" subtype=capture negate=
    rx1682_cur."!cursor_pos"(rx1682_pos)
    $P10 = rx1682_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1682_fail
    rx1682_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1682_pos = $P10."pos"()
  # rx pass
    rx1682_cur."!cursor_pass"(rx1682_pos, "infix:sym<->")
    if_null rx1682_debug, debug_1284
    rx1682_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1682_pos)
  debug_1284:
    .return (rx1682_cur)
  rx1682_restart:
.annotate 'line', 10
    if_null rx1682_debug, debug_1285
    rx1682_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1285:
  rx1682_fail:
    (rx1682_rep, rx1682_pos, $I10, $P10) = rx1682_cur."!mark_fail"(0)
    lt rx1682_pos, -1, rx1682_done
    eq rx1682_pos, -1, rx1682_fail
    jump $I10
  rx1682_done:
    rx1682_cur."!cursor_fail"()
    if_null rx1682_debug, debug_1286
    rx1682_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1286:
    .return (rx1682_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :subid("322_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1686 = self."!PREFIX__!subrule"("O", "-")
    new $P1687, "ResizablePMCArray"
    push $P1687, $P1686
    .return ($P1687)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("323_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1689_tgt
    .local int rx1689_pos
    .local int rx1689_off
    .local int rx1689_eos
    .local int rx1689_rep
    .local pmc rx1689_cur
    .local pmc rx1689_debug
    (rx1689_cur, rx1689_pos, rx1689_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1689_cur
    .local pmc match
    .lex "$/", match
    length rx1689_eos, rx1689_tgt
    gt rx1689_pos, rx1689_eos, rx1689_done
    set rx1689_off, 0
    lt rx1689_pos, 2, rx1689_start
    sub rx1689_off, rx1689_pos, 1
    substr rx1689_tgt, rx1689_tgt, rx1689_off
  rx1689_start:
    eq $I10, 1, rx1689_restart
    if_null rx1689_debug, debug_1287
    rx1689_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1287:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1690_done
    goto rxscan1690_scan
  rxscan1690_loop:
    (rx1689_pos) = rx1689_cur."from"()
    inc rx1689_pos
    rx1689_cur."!cursor_from"(rx1689_pos)
    ge rx1689_pos, rx1689_eos, rxscan1690_done
  rxscan1690_scan:
    set_addr $I10, rxscan1690_loop
    rx1689_cur."!mark_push"(0, rx1689_pos, $I10)
  rxscan1690_done:
.annotate 'line', 672
  # rx subcapture "sym"
    set_addr $I10, rxcap_1691_fail
    rx1689_cur."!mark_push"(0, rx1689_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1689_pos, 2
    gt $I11, rx1689_eos, rx1689_fail
    sub $I11, rx1689_pos, rx1689_off
    substr $S10, rx1689_tgt, $I11, 2
    ne $S10, "+|", rx1689_fail
    add rx1689_pos, 2
    set_addr $I10, rxcap_1691_fail
    ($I12, $I11) = rx1689_cur."!mark_peek"($I10)
    rx1689_cur."!cursor_pos"($I11)
    ($P10) = rx1689_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1689_pos, "")
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1691_done
  rxcap_1691_fail:
    goto rx1689_fail
  rxcap_1691_done:
  # rx subrule "O" subtype=capture negate=
    rx1689_cur."!cursor_pos"(rx1689_pos)
    $P10 = rx1689_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1689_fail
    rx1689_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1689_pos = $P10."pos"()
  # rx pass
    rx1689_cur."!cursor_pass"(rx1689_pos, "infix:sym<+|>")
    if_null rx1689_debug, debug_1288
    rx1689_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1689_pos)
  debug_1288:
    .return (rx1689_cur)
  rx1689_restart:
.annotate 'line', 10
    if_null rx1689_debug, debug_1289
    rx1689_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1289:
  rx1689_fail:
    (rx1689_rep, rx1689_pos, $I10, $P10) = rx1689_cur."!mark_fail"(0)
    lt rx1689_pos, -1, rx1689_done
    eq rx1689_pos, -1, rx1689_fail
    jump $I10
  rx1689_done:
    rx1689_cur."!cursor_fail"()
    if_null rx1689_debug, debug_1290
    rx1689_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1290:
    .return (rx1689_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :subid("324_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1693 = self."!PREFIX__!subrule"("O", "+|")
    new $P1694, "ResizablePMCArray"
    push $P1694, $P1693
    .return ($P1694)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("325_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1696_tgt
    .local int rx1696_pos
    .local int rx1696_off
    .local int rx1696_eos
    .local int rx1696_rep
    .local pmc rx1696_cur
    .local pmc rx1696_debug
    (rx1696_cur, rx1696_pos, rx1696_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1696_cur
    .local pmc match
    .lex "$/", match
    length rx1696_eos, rx1696_tgt
    gt rx1696_pos, rx1696_eos, rx1696_done
    set rx1696_off, 0
    lt rx1696_pos, 2, rx1696_start
    sub rx1696_off, rx1696_pos, 1
    substr rx1696_tgt, rx1696_tgt, rx1696_off
  rx1696_start:
    eq $I10, 1, rx1696_restart
    if_null rx1696_debug, debug_1291
    rx1696_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1291:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1697_done
    goto rxscan1697_scan
  rxscan1697_loop:
    (rx1696_pos) = rx1696_cur."from"()
    inc rx1696_pos
    rx1696_cur."!cursor_from"(rx1696_pos)
    ge rx1696_pos, rx1696_eos, rxscan1697_done
  rxscan1697_scan:
    set_addr $I10, rxscan1697_loop
    rx1696_cur."!mark_push"(0, rx1696_pos, $I10)
  rxscan1697_done:
.annotate 'line', 673
  # rx subcapture "sym"
    set_addr $I10, rxcap_1698_fail
    rx1696_cur."!mark_push"(0, rx1696_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1696_pos, 2
    gt $I11, rx1696_eos, rx1696_fail
    sub $I11, rx1696_pos, rx1696_off
    substr $S10, rx1696_tgt, $I11, 2
    ne $S10, "+^", rx1696_fail
    add rx1696_pos, 2
    set_addr $I10, rxcap_1698_fail
    ($I12, $I11) = rx1696_cur."!mark_peek"($I10)
    rx1696_cur."!cursor_pos"($I11)
    ($P10) = rx1696_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1696_pos, "")
    rx1696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1698_done
  rxcap_1698_fail:
    goto rx1696_fail
  rxcap_1698_done:
  # rx subrule "O" subtype=capture negate=
    rx1696_cur."!cursor_pos"(rx1696_pos)
    $P10 = rx1696_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1696_fail
    rx1696_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1696_pos = $P10."pos"()
  # rx pass
    rx1696_cur."!cursor_pass"(rx1696_pos, "infix:sym<+^>")
    if_null rx1696_debug, debug_1292
    rx1696_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1696_pos)
  debug_1292:
    .return (rx1696_cur)
  rx1696_restart:
.annotate 'line', 10
    if_null rx1696_debug, debug_1293
    rx1696_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1293:
  rx1696_fail:
    (rx1696_rep, rx1696_pos, $I10, $P10) = rx1696_cur."!mark_fail"(0)
    lt rx1696_pos, -1, rx1696_done
    eq rx1696_pos, -1, rx1696_fail
    jump $I10
  rx1696_done:
    rx1696_cur."!cursor_fail"()
    if_null rx1696_debug, debug_1294
    rx1696_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1294:
    .return (rx1696_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :subid("326_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1700 = self."!PREFIX__!subrule"("O", "+^")
    new $P1701, "ResizablePMCArray"
    push $P1701, $P1700
    .return ($P1701)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("327_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1703_tgt
    .local int rx1703_pos
    .local int rx1703_off
    .local int rx1703_eos
    .local int rx1703_rep
    .local pmc rx1703_cur
    .local pmc rx1703_debug
    (rx1703_cur, rx1703_pos, rx1703_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1703_cur
    .local pmc match
    .lex "$/", match
    length rx1703_eos, rx1703_tgt
    gt rx1703_pos, rx1703_eos, rx1703_done
    set rx1703_off, 0
    lt rx1703_pos, 2, rx1703_start
    sub rx1703_off, rx1703_pos, 1
    substr rx1703_tgt, rx1703_tgt, rx1703_off
  rx1703_start:
    eq $I10, 1, rx1703_restart
    if_null rx1703_debug, debug_1295
    rx1703_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1295:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1704_done
    goto rxscan1704_scan
  rxscan1704_loop:
    (rx1703_pos) = rx1703_cur."from"()
    inc rx1703_pos
    rx1703_cur."!cursor_from"(rx1703_pos)
    ge rx1703_pos, rx1703_eos, rxscan1704_done
  rxscan1704_scan:
    set_addr $I10, rxscan1704_loop
    rx1703_cur."!mark_push"(0, rx1703_pos, $I10)
  rxscan1704_done:
.annotate 'line', 675
  # rx subcapture "sym"
    set_addr $I10, rxcap_1705_fail
    rx1703_cur."!mark_push"(0, rx1703_pos, $I10)
  # rx literal  "~"
    add $I11, rx1703_pos, 1
    gt $I11, rx1703_eos, rx1703_fail
    sub $I11, rx1703_pos, rx1703_off
    ord $I11, rx1703_tgt, $I11
    ne $I11, 126, rx1703_fail
    add rx1703_pos, 1
    set_addr $I10, rxcap_1705_fail
    ($I12, $I11) = rx1703_cur."!mark_peek"($I10)
    rx1703_cur."!cursor_pos"($I11)
    ($P10) = rx1703_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1703_pos, "")
    rx1703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1705_done
  rxcap_1705_fail:
    goto rx1703_fail
  rxcap_1705_done:
  # rx subrule "O" subtype=capture negate=
    rx1703_cur."!cursor_pos"(rx1703_pos)
    $P10 = rx1703_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1703_fail
    rx1703_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1703_pos = $P10."pos"()
  # rx pass
    rx1703_cur."!cursor_pass"(rx1703_pos, "infix:sym<~>")
    if_null rx1703_debug, debug_1296
    rx1703_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1703_pos)
  debug_1296:
    .return (rx1703_cur)
  rx1703_restart:
.annotate 'line', 10
    if_null rx1703_debug, debug_1297
    rx1703_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1297:
  rx1703_fail:
    (rx1703_rep, rx1703_pos, $I10, $P10) = rx1703_cur."!mark_fail"(0)
    lt rx1703_pos, -1, rx1703_done
    eq rx1703_pos, -1, rx1703_fail
    jump $I10
  rx1703_done:
    rx1703_cur."!cursor_fail"()
    if_null rx1703_debug, debug_1298
    rx1703_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1298:
    .return (rx1703_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :subid("328_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1707 = self."!PREFIX__!subrule"("O", "~")
    new $P1708, "ResizablePMCArray"
    push $P1708, $P1707
    .return ($P1708)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("329_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1710_tgt
    .local int rx1710_pos
    .local int rx1710_off
    .local int rx1710_eos
    .local int rx1710_rep
    .local pmc rx1710_cur
    .local pmc rx1710_debug
    (rx1710_cur, rx1710_pos, rx1710_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1710_cur
    .local pmc match
    .lex "$/", match
    length rx1710_eos, rx1710_tgt
    gt rx1710_pos, rx1710_eos, rx1710_done
    set rx1710_off, 0
    lt rx1710_pos, 2, rx1710_start
    sub rx1710_off, rx1710_pos, 1
    substr rx1710_tgt, rx1710_tgt, rx1710_off
  rx1710_start:
    eq $I10, 1, rx1710_restart
    if_null rx1710_debug, debug_1299
    rx1710_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1299:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1711_done
    goto rxscan1711_scan
  rxscan1711_loop:
    (rx1710_pos) = rx1710_cur."from"()
    inc rx1710_pos
    rx1710_cur."!cursor_from"(rx1710_pos)
    ge rx1710_pos, rx1710_eos, rxscan1711_done
  rxscan1711_scan:
    set_addr $I10, rxscan1711_loop
    rx1710_cur."!mark_push"(0, rx1710_pos, $I10)
  rxscan1711_done:
.annotate 'line', 677
  # rx subcapture "sym"
    set_addr $I10, rxcap_1712_fail
    rx1710_cur."!mark_push"(0, rx1710_pos, $I10)
  # rx literal  "=="
    add $I11, rx1710_pos, 2
    gt $I11, rx1710_eos, rx1710_fail
    sub $I11, rx1710_pos, rx1710_off
    substr $S10, rx1710_tgt, $I11, 2
    ne $S10, "==", rx1710_fail
    add rx1710_pos, 2
    set_addr $I10, rxcap_1712_fail
    ($I12, $I11) = rx1710_cur."!mark_peek"($I10)
    rx1710_cur."!cursor_pos"($I11)
    ($P10) = rx1710_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1710_pos, "")
    rx1710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1712_done
  rxcap_1712_fail:
    goto rx1710_fail
  rxcap_1712_done:
  # rx subrule "O" subtype=capture negate=
    rx1710_cur."!cursor_pos"(rx1710_pos)
    $P10 = rx1710_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1710_fail
    rx1710_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1710_pos = $P10."pos"()
  # rx pass
    rx1710_cur."!cursor_pass"(rx1710_pos, "infix:sym<==>")
    if_null rx1710_debug, debug_1300
    rx1710_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1710_pos)
  debug_1300:
    .return (rx1710_cur)
  rx1710_restart:
.annotate 'line', 10
    if_null rx1710_debug, debug_1301
    rx1710_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1301:
  rx1710_fail:
    (rx1710_rep, rx1710_pos, $I10, $P10) = rx1710_cur."!mark_fail"(0)
    lt rx1710_pos, -1, rx1710_done
    eq rx1710_pos, -1, rx1710_fail
    jump $I10
  rx1710_done:
    rx1710_cur."!cursor_fail"()
    if_null rx1710_debug, debug_1302
    rx1710_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1302:
    .return (rx1710_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :subid("330_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1714 = self."!PREFIX__!subrule"("O", "==")
    new $P1715, "ResizablePMCArray"
    push $P1715, $P1714
    .return ($P1715)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("331_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1717_tgt
    .local int rx1717_pos
    .local int rx1717_off
    .local int rx1717_eos
    .local int rx1717_rep
    .local pmc rx1717_cur
    .local pmc rx1717_debug
    (rx1717_cur, rx1717_pos, rx1717_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1717_cur
    .local pmc match
    .lex "$/", match
    length rx1717_eos, rx1717_tgt
    gt rx1717_pos, rx1717_eos, rx1717_done
    set rx1717_off, 0
    lt rx1717_pos, 2, rx1717_start
    sub rx1717_off, rx1717_pos, 1
    substr rx1717_tgt, rx1717_tgt, rx1717_off
  rx1717_start:
    eq $I10, 1, rx1717_restart
    if_null rx1717_debug, debug_1303
    rx1717_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1303:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1718_done
    goto rxscan1718_scan
  rxscan1718_loop:
    (rx1717_pos) = rx1717_cur."from"()
    inc rx1717_pos
    rx1717_cur."!cursor_from"(rx1717_pos)
    ge rx1717_pos, rx1717_eos, rxscan1718_done
  rxscan1718_scan:
    set_addr $I10, rxscan1718_loop
    rx1717_cur."!mark_push"(0, rx1717_pos, $I10)
  rxscan1718_done:
.annotate 'line', 678
  # rx subcapture "sym"
    set_addr $I10, rxcap_1719_fail
    rx1717_cur."!mark_push"(0, rx1717_pos, $I10)
  # rx literal  "!="
    add $I11, rx1717_pos, 2
    gt $I11, rx1717_eos, rx1717_fail
    sub $I11, rx1717_pos, rx1717_off
    substr $S10, rx1717_tgt, $I11, 2
    ne $S10, "!=", rx1717_fail
    add rx1717_pos, 2
    set_addr $I10, rxcap_1719_fail
    ($I12, $I11) = rx1717_cur."!mark_peek"($I10)
    rx1717_cur."!cursor_pos"($I11)
    ($P10) = rx1717_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1717_pos, "")
    rx1717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1719_done
  rxcap_1719_fail:
    goto rx1717_fail
  rxcap_1719_done:
  # rx subrule "O" subtype=capture negate=
    rx1717_cur."!cursor_pos"(rx1717_pos)
    $P10 = rx1717_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1717_fail
    rx1717_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1717_pos = $P10."pos"()
  # rx pass
    rx1717_cur."!cursor_pass"(rx1717_pos, "infix:sym<!=>")
    if_null rx1717_debug, debug_1304
    rx1717_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1717_pos)
  debug_1304:
    .return (rx1717_cur)
  rx1717_restart:
.annotate 'line', 10
    if_null rx1717_debug, debug_1305
    rx1717_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1305:
  rx1717_fail:
    (rx1717_rep, rx1717_pos, $I10, $P10) = rx1717_cur."!mark_fail"(0)
    lt rx1717_pos, -1, rx1717_done
    eq rx1717_pos, -1, rx1717_fail
    jump $I10
  rx1717_done:
    rx1717_cur."!cursor_fail"()
    if_null rx1717_debug, debug_1306
    rx1717_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1306:
    .return (rx1717_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :subid("332_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1721 = self."!PREFIX__!subrule"("O", "!=")
    new $P1722, "ResizablePMCArray"
    push $P1722, $P1721
    .return ($P1722)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("333_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1724_tgt
    .local int rx1724_pos
    .local int rx1724_off
    .local int rx1724_eos
    .local int rx1724_rep
    .local pmc rx1724_cur
    .local pmc rx1724_debug
    (rx1724_cur, rx1724_pos, rx1724_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1724_cur
    .local pmc match
    .lex "$/", match
    length rx1724_eos, rx1724_tgt
    gt rx1724_pos, rx1724_eos, rx1724_done
    set rx1724_off, 0
    lt rx1724_pos, 2, rx1724_start
    sub rx1724_off, rx1724_pos, 1
    substr rx1724_tgt, rx1724_tgt, rx1724_off
  rx1724_start:
    eq $I10, 1, rx1724_restart
    if_null rx1724_debug, debug_1307
    rx1724_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1307:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1725_done
    goto rxscan1725_scan
  rxscan1725_loop:
    (rx1724_pos) = rx1724_cur."from"()
    inc rx1724_pos
    rx1724_cur."!cursor_from"(rx1724_pos)
    ge rx1724_pos, rx1724_eos, rxscan1725_done
  rxscan1725_scan:
    set_addr $I10, rxscan1725_loop
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
  rxscan1725_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1726_fail
    rx1724_cur."!mark_push"(0, rx1724_pos, $I10)
  # rx literal  "<="
    add $I11, rx1724_pos, 2
    gt $I11, rx1724_eos, rx1724_fail
    sub $I11, rx1724_pos, rx1724_off
    substr $S10, rx1724_tgt, $I11, 2
    ne $S10, "<=", rx1724_fail
    add rx1724_pos, 2
    set_addr $I10, rxcap_1726_fail
    ($I12, $I11) = rx1724_cur."!mark_peek"($I10)
    rx1724_cur."!cursor_pos"($I11)
    ($P10) = rx1724_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1724_pos, "")
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1726_done
  rxcap_1726_fail:
    goto rx1724_fail
  rxcap_1726_done:
  # rx subrule "O" subtype=capture negate=
    rx1724_cur."!cursor_pos"(rx1724_pos)
    $P10 = rx1724_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1724_fail
    rx1724_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1724_pos = $P10."pos"()
  # rx pass
    rx1724_cur."!cursor_pass"(rx1724_pos, "infix:sym<<=>")
    if_null rx1724_debug, debug_1308
    rx1724_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1724_pos)
  debug_1308:
    .return (rx1724_cur)
  rx1724_restart:
.annotate 'line', 10
    if_null rx1724_debug, debug_1309
    rx1724_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1309:
  rx1724_fail:
    (rx1724_rep, rx1724_pos, $I10, $P10) = rx1724_cur."!mark_fail"(0)
    lt rx1724_pos, -1, rx1724_done
    eq rx1724_pos, -1, rx1724_fail
    jump $I10
  rx1724_done:
    rx1724_cur."!cursor_fail"()
    if_null rx1724_debug, debug_1310
    rx1724_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1310:
    .return (rx1724_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :subid("334_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1728 = self."!PREFIX__!subrule"("O", "<=")
    new $P1729, "ResizablePMCArray"
    push $P1729, $P1728
    .return ($P1729)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("335_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1731_tgt
    .local int rx1731_pos
    .local int rx1731_off
    .local int rx1731_eos
    .local int rx1731_rep
    .local pmc rx1731_cur
    .local pmc rx1731_debug
    (rx1731_cur, rx1731_pos, rx1731_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1731_cur
    .local pmc match
    .lex "$/", match
    length rx1731_eos, rx1731_tgt
    gt rx1731_pos, rx1731_eos, rx1731_done
    set rx1731_off, 0
    lt rx1731_pos, 2, rx1731_start
    sub rx1731_off, rx1731_pos, 1
    substr rx1731_tgt, rx1731_tgt, rx1731_off
  rx1731_start:
    eq $I10, 1, rx1731_restart
    if_null rx1731_debug, debug_1311
    rx1731_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1311:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1732_done
    goto rxscan1732_scan
  rxscan1732_loop:
    (rx1731_pos) = rx1731_cur."from"()
    inc rx1731_pos
    rx1731_cur."!cursor_from"(rx1731_pos)
    ge rx1731_pos, rx1731_eos, rxscan1732_done
  rxscan1732_scan:
    set_addr $I10, rxscan1732_loop
    rx1731_cur."!mark_push"(0, rx1731_pos, $I10)
  rxscan1732_done:
.annotate 'line', 680
  # rx subcapture "sym"
    set_addr $I10, rxcap_1733_fail
    rx1731_cur."!mark_push"(0, rx1731_pos, $I10)
  # rx literal  ">="
    add $I11, rx1731_pos, 2
    gt $I11, rx1731_eos, rx1731_fail
    sub $I11, rx1731_pos, rx1731_off
    substr $S10, rx1731_tgt, $I11, 2
    ne $S10, ">=", rx1731_fail
    add rx1731_pos, 2
    set_addr $I10, rxcap_1733_fail
    ($I12, $I11) = rx1731_cur."!mark_peek"($I10)
    rx1731_cur."!cursor_pos"($I11)
    ($P10) = rx1731_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1731_pos, "")
    rx1731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1733_done
  rxcap_1733_fail:
    goto rx1731_fail
  rxcap_1733_done:
  # rx subrule "O" subtype=capture negate=
    rx1731_cur."!cursor_pos"(rx1731_pos)
    $P10 = rx1731_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1731_fail
    rx1731_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1731_pos = $P10."pos"()
  # rx pass
    rx1731_cur."!cursor_pass"(rx1731_pos, "infix:sym<>=>")
    if_null rx1731_debug, debug_1312
    rx1731_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1731_pos)
  debug_1312:
    .return (rx1731_cur)
  rx1731_restart:
.annotate 'line', 10
    if_null rx1731_debug, debug_1313
    rx1731_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1313:
  rx1731_fail:
    (rx1731_rep, rx1731_pos, $I10, $P10) = rx1731_cur."!mark_fail"(0)
    lt rx1731_pos, -1, rx1731_done
    eq rx1731_pos, -1, rx1731_fail
    jump $I10
  rx1731_done:
    rx1731_cur."!cursor_fail"()
    if_null rx1731_debug, debug_1314
    rx1731_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1314:
    .return (rx1731_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :subid("336_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1735 = self."!PREFIX__!subrule"("O", ">=")
    new $P1736, "ResizablePMCArray"
    push $P1736, $P1735
    .return ($P1736)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("337_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1738_tgt
    .local int rx1738_pos
    .local int rx1738_off
    .local int rx1738_eos
    .local int rx1738_rep
    .local pmc rx1738_cur
    .local pmc rx1738_debug
    (rx1738_cur, rx1738_pos, rx1738_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1738_cur
    .local pmc match
    .lex "$/", match
    length rx1738_eos, rx1738_tgt
    gt rx1738_pos, rx1738_eos, rx1738_done
    set rx1738_off, 0
    lt rx1738_pos, 2, rx1738_start
    sub rx1738_off, rx1738_pos, 1
    substr rx1738_tgt, rx1738_tgt, rx1738_off
  rx1738_start:
    eq $I10, 1, rx1738_restart
    if_null rx1738_debug, debug_1315
    rx1738_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1315:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1739_done
    goto rxscan1739_scan
  rxscan1739_loop:
    (rx1738_pos) = rx1738_cur."from"()
    inc rx1738_pos
    rx1738_cur."!cursor_from"(rx1738_pos)
    ge rx1738_pos, rx1738_eos, rxscan1739_done
  rxscan1739_scan:
    set_addr $I10, rxscan1739_loop
    rx1738_cur."!mark_push"(0, rx1738_pos, $I10)
  rxscan1739_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1740_fail
    rx1738_cur."!mark_push"(0, rx1738_pos, $I10)
  # rx literal  "<"
    add $I11, rx1738_pos, 1
    gt $I11, rx1738_eos, rx1738_fail
    sub $I11, rx1738_pos, rx1738_off
    ord $I11, rx1738_tgt, $I11
    ne $I11, 60, rx1738_fail
    add rx1738_pos, 1
    set_addr $I10, rxcap_1740_fail
    ($I12, $I11) = rx1738_cur."!mark_peek"($I10)
    rx1738_cur."!cursor_pos"($I11)
    ($P10) = rx1738_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1738_pos, "")
    rx1738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1740_done
  rxcap_1740_fail:
    goto rx1738_fail
  rxcap_1740_done:
  # rx subrule "O" subtype=capture negate=
    rx1738_cur."!cursor_pos"(rx1738_pos)
    $P10 = rx1738_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1738_fail
    rx1738_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1738_pos = $P10."pos"()
  # rx pass
    rx1738_cur."!cursor_pass"(rx1738_pos, "infix:sym<<>")
    if_null rx1738_debug, debug_1316
    rx1738_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1738_pos)
  debug_1316:
    .return (rx1738_cur)
  rx1738_restart:
.annotate 'line', 10
    if_null rx1738_debug, debug_1317
    rx1738_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1317:
  rx1738_fail:
    (rx1738_rep, rx1738_pos, $I10, $P10) = rx1738_cur."!mark_fail"(0)
    lt rx1738_pos, -1, rx1738_done
    eq rx1738_pos, -1, rx1738_fail
    jump $I10
  rx1738_done:
    rx1738_cur."!cursor_fail"()
    if_null rx1738_debug, debug_1318
    rx1738_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1318:
    .return (rx1738_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :subid("338_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1742 = self."!PREFIX__!subrule"("O", "<")
    new $P1743, "ResizablePMCArray"
    push $P1743, $P1742
    .return ($P1743)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("339_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1745_tgt
    .local int rx1745_pos
    .local int rx1745_off
    .local int rx1745_eos
    .local int rx1745_rep
    .local pmc rx1745_cur
    .local pmc rx1745_debug
    (rx1745_cur, rx1745_pos, rx1745_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1745_cur
    .local pmc match
    .lex "$/", match
    length rx1745_eos, rx1745_tgt
    gt rx1745_pos, rx1745_eos, rx1745_done
    set rx1745_off, 0
    lt rx1745_pos, 2, rx1745_start
    sub rx1745_off, rx1745_pos, 1
    substr rx1745_tgt, rx1745_tgt, rx1745_off
  rx1745_start:
    eq $I10, 1, rx1745_restart
    if_null rx1745_debug, debug_1319
    rx1745_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1319:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1746_done
    goto rxscan1746_scan
  rxscan1746_loop:
    (rx1745_pos) = rx1745_cur."from"()
    inc rx1745_pos
    rx1745_cur."!cursor_from"(rx1745_pos)
    ge rx1745_pos, rx1745_eos, rxscan1746_done
  rxscan1746_scan:
    set_addr $I10, rxscan1746_loop
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10)
  rxscan1746_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1747_fail
    rx1745_cur."!mark_push"(0, rx1745_pos, $I10)
  # rx literal  ">"
    add $I11, rx1745_pos, 1
    gt $I11, rx1745_eos, rx1745_fail
    sub $I11, rx1745_pos, rx1745_off
    ord $I11, rx1745_tgt, $I11
    ne $I11, 62, rx1745_fail
    add rx1745_pos, 1
    set_addr $I10, rxcap_1747_fail
    ($I12, $I11) = rx1745_cur."!mark_peek"($I10)
    rx1745_cur."!cursor_pos"($I11)
    ($P10) = rx1745_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1745_pos, "")
    rx1745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1747_done
  rxcap_1747_fail:
    goto rx1745_fail
  rxcap_1747_done:
  # rx subrule "O" subtype=capture negate=
    rx1745_cur."!cursor_pos"(rx1745_pos)
    $P10 = rx1745_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1745_fail
    rx1745_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1745_pos = $P10."pos"()
  # rx pass
    rx1745_cur."!cursor_pass"(rx1745_pos, "infix:sym<>>")
    if_null rx1745_debug, debug_1320
    rx1745_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1745_pos)
  debug_1320:
    .return (rx1745_cur)
  rx1745_restart:
.annotate 'line', 10
    if_null rx1745_debug, debug_1321
    rx1745_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1321:
  rx1745_fail:
    (rx1745_rep, rx1745_pos, $I10, $P10) = rx1745_cur."!mark_fail"(0)
    lt rx1745_pos, -1, rx1745_done
    eq rx1745_pos, -1, rx1745_fail
    jump $I10
  rx1745_done:
    rx1745_cur."!cursor_fail"()
    if_null rx1745_debug, debug_1322
    rx1745_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1322:
    .return (rx1745_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :subid("340_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1749 = self."!PREFIX__!subrule"("O", ">")
    new $P1750, "ResizablePMCArray"
    push $P1750, $P1749
    .return ($P1750)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("341_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1752_tgt
    .local int rx1752_pos
    .local int rx1752_off
    .local int rx1752_eos
    .local int rx1752_rep
    .local pmc rx1752_cur
    .local pmc rx1752_debug
    (rx1752_cur, rx1752_pos, rx1752_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1752_cur
    .local pmc match
    .lex "$/", match
    length rx1752_eos, rx1752_tgt
    gt rx1752_pos, rx1752_eos, rx1752_done
    set rx1752_off, 0
    lt rx1752_pos, 2, rx1752_start
    sub rx1752_off, rx1752_pos, 1
    substr rx1752_tgt, rx1752_tgt, rx1752_off
  rx1752_start:
    eq $I10, 1, rx1752_restart
    if_null rx1752_debug, debug_1323
    rx1752_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1323:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1753_done
    goto rxscan1753_scan
  rxscan1753_loop:
    (rx1752_pos) = rx1752_cur."from"()
    inc rx1752_pos
    rx1752_cur."!cursor_from"(rx1752_pos)
    ge rx1752_pos, rx1752_eos, rxscan1753_done
  rxscan1753_scan:
    set_addr $I10, rxscan1753_loop
    rx1752_cur."!mark_push"(0, rx1752_pos, $I10)
  rxscan1753_done:
.annotate 'line', 683
  # rx subcapture "sym"
    set_addr $I10, rxcap_1754_fail
    rx1752_cur."!mark_push"(0, rx1752_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1752_pos, 2
    gt $I11, rx1752_eos, rx1752_fail
    sub $I11, rx1752_pos, rx1752_off
    substr $S10, rx1752_tgt, $I11, 2
    ne $S10, "eq", rx1752_fail
    add rx1752_pos, 2
    set_addr $I10, rxcap_1754_fail
    ($I12, $I11) = rx1752_cur."!mark_peek"($I10)
    rx1752_cur."!cursor_pos"($I11)
    ($P10) = rx1752_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1752_pos, "")
    rx1752_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1754_done
  rxcap_1754_fail:
    goto rx1752_fail
  rxcap_1754_done:
  # rx subrule "O" subtype=capture negate=
    rx1752_cur."!cursor_pos"(rx1752_pos)
    $P10 = rx1752_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1752_fail
    rx1752_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1752_pos = $P10."pos"()
  # rx pass
    rx1752_cur."!cursor_pass"(rx1752_pos, "infix:sym<eq>")
    if_null rx1752_debug, debug_1324
    rx1752_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1752_pos)
  debug_1324:
    .return (rx1752_cur)
  rx1752_restart:
.annotate 'line', 10
    if_null rx1752_debug, debug_1325
    rx1752_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1325:
  rx1752_fail:
    (rx1752_rep, rx1752_pos, $I10, $P10) = rx1752_cur."!mark_fail"(0)
    lt rx1752_pos, -1, rx1752_done
    eq rx1752_pos, -1, rx1752_fail
    jump $I10
  rx1752_done:
    rx1752_cur."!cursor_fail"()
    if_null rx1752_debug, debug_1326
    rx1752_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1326:
    .return (rx1752_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :subid("342_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1756 = self."!PREFIX__!subrule"("O", "eq")
    new $P1757, "ResizablePMCArray"
    push $P1757, $P1756
    .return ($P1757)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("343_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1759_tgt
    .local int rx1759_pos
    .local int rx1759_off
    .local int rx1759_eos
    .local int rx1759_rep
    .local pmc rx1759_cur
    .local pmc rx1759_debug
    (rx1759_cur, rx1759_pos, rx1759_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1759_cur
    .local pmc match
    .lex "$/", match
    length rx1759_eos, rx1759_tgt
    gt rx1759_pos, rx1759_eos, rx1759_done
    set rx1759_off, 0
    lt rx1759_pos, 2, rx1759_start
    sub rx1759_off, rx1759_pos, 1
    substr rx1759_tgt, rx1759_tgt, rx1759_off
  rx1759_start:
    eq $I10, 1, rx1759_restart
    if_null rx1759_debug, debug_1327
    rx1759_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1327:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1760_done
    goto rxscan1760_scan
  rxscan1760_loop:
    (rx1759_pos) = rx1759_cur."from"()
    inc rx1759_pos
    rx1759_cur."!cursor_from"(rx1759_pos)
    ge rx1759_pos, rx1759_eos, rxscan1760_done
  rxscan1760_scan:
    set_addr $I10, rxscan1760_loop
    rx1759_cur."!mark_push"(0, rx1759_pos, $I10)
  rxscan1760_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1761_fail
    rx1759_cur."!mark_push"(0, rx1759_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1759_pos, 2
    gt $I11, rx1759_eos, rx1759_fail
    sub $I11, rx1759_pos, rx1759_off
    substr $S10, rx1759_tgt, $I11, 2
    ne $S10, "ne", rx1759_fail
    add rx1759_pos, 2
    set_addr $I10, rxcap_1761_fail
    ($I12, $I11) = rx1759_cur."!mark_peek"($I10)
    rx1759_cur."!cursor_pos"($I11)
    ($P10) = rx1759_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1759_pos, "")
    rx1759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1761_done
  rxcap_1761_fail:
    goto rx1759_fail
  rxcap_1761_done:
  # rx subrule "O" subtype=capture negate=
    rx1759_cur."!cursor_pos"(rx1759_pos)
    $P10 = rx1759_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1759_fail
    rx1759_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1759_pos = $P10."pos"()
  # rx pass
    rx1759_cur."!cursor_pass"(rx1759_pos, "infix:sym<ne>")
    if_null rx1759_debug, debug_1328
    rx1759_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1759_pos)
  debug_1328:
    .return (rx1759_cur)
  rx1759_restart:
.annotate 'line', 10
    if_null rx1759_debug, debug_1329
    rx1759_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1329:
  rx1759_fail:
    (rx1759_rep, rx1759_pos, $I10, $P10) = rx1759_cur."!mark_fail"(0)
    lt rx1759_pos, -1, rx1759_done
    eq rx1759_pos, -1, rx1759_fail
    jump $I10
  rx1759_done:
    rx1759_cur."!cursor_fail"()
    if_null rx1759_debug, debug_1330
    rx1759_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1330:
    .return (rx1759_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :subid("344_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1763 = self."!PREFIX__!subrule"("O", "ne")
    new $P1764, "ResizablePMCArray"
    push $P1764, $P1763
    .return ($P1764)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("345_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1766_tgt
    .local int rx1766_pos
    .local int rx1766_off
    .local int rx1766_eos
    .local int rx1766_rep
    .local pmc rx1766_cur
    .local pmc rx1766_debug
    (rx1766_cur, rx1766_pos, rx1766_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1766_cur
    .local pmc match
    .lex "$/", match
    length rx1766_eos, rx1766_tgt
    gt rx1766_pos, rx1766_eos, rx1766_done
    set rx1766_off, 0
    lt rx1766_pos, 2, rx1766_start
    sub rx1766_off, rx1766_pos, 1
    substr rx1766_tgt, rx1766_tgt, rx1766_off
  rx1766_start:
    eq $I10, 1, rx1766_restart
    if_null rx1766_debug, debug_1331
    rx1766_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1331:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1767_done
    goto rxscan1767_scan
  rxscan1767_loop:
    (rx1766_pos) = rx1766_cur."from"()
    inc rx1766_pos
    rx1766_cur."!cursor_from"(rx1766_pos)
    ge rx1766_pos, rx1766_eos, rxscan1767_done
  rxscan1767_scan:
    set_addr $I10, rxscan1767_loop
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  rxscan1767_done:
.annotate 'line', 685
  # rx subcapture "sym"
    set_addr $I10, rxcap_1768_fail
    rx1766_cur."!mark_push"(0, rx1766_pos, $I10)
  # rx literal  "le"
    add $I11, rx1766_pos, 2
    gt $I11, rx1766_eos, rx1766_fail
    sub $I11, rx1766_pos, rx1766_off
    substr $S10, rx1766_tgt, $I11, 2
    ne $S10, "le", rx1766_fail
    add rx1766_pos, 2
    set_addr $I10, rxcap_1768_fail
    ($I12, $I11) = rx1766_cur."!mark_peek"($I10)
    rx1766_cur."!cursor_pos"($I11)
    ($P10) = rx1766_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1766_pos, "")
    rx1766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1768_done
  rxcap_1768_fail:
    goto rx1766_fail
  rxcap_1768_done:
  # rx subrule "O" subtype=capture negate=
    rx1766_cur."!cursor_pos"(rx1766_pos)
    $P10 = rx1766_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1766_fail
    rx1766_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1766_pos = $P10."pos"()
  # rx pass
    rx1766_cur."!cursor_pass"(rx1766_pos, "infix:sym<le>")
    if_null rx1766_debug, debug_1332
    rx1766_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1766_pos)
  debug_1332:
    .return (rx1766_cur)
  rx1766_restart:
.annotate 'line', 10
    if_null rx1766_debug, debug_1333
    rx1766_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1333:
  rx1766_fail:
    (rx1766_rep, rx1766_pos, $I10, $P10) = rx1766_cur."!mark_fail"(0)
    lt rx1766_pos, -1, rx1766_done
    eq rx1766_pos, -1, rx1766_fail
    jump $I10
  rx1766_done:
    rx1766_cur."!cursor_fail"()
    if_null rx1766_debug, debug_1334
    rx1766_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1334:
    .return (rx1766_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :subid("346_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1770 = self."!PREFIX__!subrule"("O", "le")
    new $P1771, "ResizablePMCArray"
    push $P1771, $P1770
    .return ($P1771)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("347_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1773_tgt
    .local int rx1773_pos
    .local int rx1773_off
    .local int rx1773_eos
    .local int rx1773_rep
    .local pmc rx1773_cur
    .local pmc rx1773_debug
    (rx1773_cur, rx1773_pos, rx1773_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1773_cur
    .local pmc match
    .lex "$/", match
    length rx1773_eos, rx1773_tgt
    gt rx1773_pos, rx1773_eos, rx1773_done
    set rx1773_off, 0
    lt rx1773_pos, 2, rx1773_start
    sub rx1773_off, rx1773_pos, 1
    substr rx1773_tgt, rx1773_tgt, rx1773_off
  rx1773_start:
    eq $I10, 1, rx1773_restart
    if_null rx1773_debug, debug_1335
    rx1773_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1335:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1774_done
    goto rxscan1774_scan
  rxscan1774_loop:
    (rx1773_pos) = rx1773_cur."from"()
    inc rx1773_pos
    rx1773_cur."!cursor_from"(rx1773_pos)
    ge rx1773_pos, rx1773_eos, rxscan1774_done
  rxscan1774_scan:
    set_addr $I10, rxscan1774_loop
    rx1773_cur."!mark_push"(0, rx1773_pos, $I10)
  rxscan1774_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1775_fail
    rx1773_cur."!mark_push"(0, rx1773_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1773_pos, 2
    gt $I11, rx1773_eos, rx1773_fail
    sub $I11, rx1773_pos, rx1773_off
    substr $S10, rx1773_tgt, $I11, 2
    ne $S10, "ge", rx1773_fail
    add rx1773_pos, 2
    set_addr $I10, rxcap_1775_fail
    ($I12, $I11) = rx1773_cur."!mark_peek"($I10)
    rx1773_cur."!cursor_pos"($I11)
    ($P10) = rx1773_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1773_pos, "")
    rx1773_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1775_done
  rxcap_1775_fail:
    goto rx1773_fail
  rxcap_1775_done:
  # rx subrule "O" subtype=capture negate=
    rx1773_cur."!cursor_pos"(rx1773_pos)
    $P10 = rx1773_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1773_fail
    rx1773_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1773_pos = $P10."pos"()
  # rx pass
    rx1773_cur."!cursor_pass"(rx1773_pos, "infix:sym<ge>")
    if_null rx1773_debug, debug_1336
    rx1773_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1773_pos)
  debug_1336:
    .return (rx1773_cur)
  rx1773_restart:
.annotate 'line', 10
    if_null rx1773_debug, debug_1337
    rx1773_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1337:
  rx1773_fail:
    (rx1773_rep, rx1773_pos, $I10, $P10) = rx1773_cur."!mark_fail"(0)
    lt rx1773_pos, -1, rx1773_done
    eq rx1773_pos, -1, rx1773_fail
    jump $I10
  rx1773_done:
    rx1773_cur."!cursor_fail"()
    if_null rx1773_debug, debug_1338
    rx1773_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1338:
    .return (rx1773_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :subid("348_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1777 = self."!PREFIX__!subrule"("O", "ge")
    new $P1778, "ResizablePMCArray"
    push $P1778, $P1777
    .return ($P1778)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("349_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1780_tgt
    .local int rx1780_pos
    .local int rx1780_off
    .local int rx1780_eos
    .local int rx1780_rep
    .local pmc rx1780_cur
    .local pmc rx1780_debug
    (rx1780_cur, rx1780_pos, rx1780_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1780_cur
    .local pmc match
    .lex "$/", match
    length rx1780_eos, rx1780_tgt
    gt rx1780_pos, rx1780_eos, rx1780_done
    set rx1780_off, 0
    lt rx1780_pos, 2, rx1780_start
    sub rx1780_off, rx1780_pos, 1
    substr rx1780_tgt, rx1780_tgt, rx1780_off
  rx1780_start:
    eq $I10, 1, rx1780_restart
    if_null rx1780_debug, debug_1339
    rx1780_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1339:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1781_done
    goto rxscan1781_scan
  rxscan1781_loop:
    (rx1780_pos) = rx1780_cur."from"()
    inc rx1780_pos
    rx1780_cur."!cursor_from"(rx1780_pos)
    ge rx1780_pos, rx1780_eos, rxscan1781_done
  rxscan1781_scan:
    set_addr $I10, rxscan1781_loop
    rx1780_cur."!mark_push"(0, rx1780_pos, $I10)
  rxscan1781_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1782_fail
    rx1780_cur."!mark_push"(0, rx1780_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1780_pos, 2
    gt $I11, rx1780_eos, rx1780_fail
    sub $I11, rx1780_pos, rx1780_off
    substr $S10, rx1780_tgt, $I11, 2
    ne $S10, "lt", rx1780_fail
    add rx1780_pos, 2
    set_addr $I10, rxcap_1782_fail
    ($I12, $I11) = rx1780_cur."!mark_peek"($I10)
    rx1780_cur."!cursor_pos"($I11)
    ($P10) = rx1780_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1780_pos, "")
    rx1780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1782_done
  rxcap_1782_fail:
    goto rx1780_fail
  rxcap_1782_done:
  # rx subrule "O" subtype=capture negate=
    rx1780_cur."!cursor_pos"(rx1780_pos)
    $P10 = rx1780_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1780_fail
    rx1780_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1780_pos = $P10."pos"()
  # rx pass
    rx1780_cur."!cursor_pass"(rx1780_pos, "infix:sym<lt>")
    if_null rx1780_debug, debug_1340
    rx1780_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1780_pos)
  debug_1340:
    .return (rx1780_cur)
  rx1780_restart:
.annotate 'line', 10
    if_null rx1780_debug, debug_1341
    rx1780_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1341:
  rx1780_fail:
    (rx1780_rep, rx1780_pos, $I10, $P10) = rx1780_cur."!mark_fail"(0)
    lt rx1780_pos, -1, rx1780_done
    eq rx1780_pos, -1, rx1780_fail
    jump $I10
  rx1780_done:
    rx1780_cur."!cursor_fail"()
    if_null rx1780_debug, debug_1342
    rx1780_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1342:
    .return (rx1780_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :subid("350_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1784 = self."!PREFIX__!subrule"("O", "lt")
    new $P1785, "ResizablePMCArray"
    push $P1785, $P1784
    .return ($P1785)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("351_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1787_tgt
    .local int rx1787_pos
    .local int rx1787_off
    .local int rx1787_eos
    .local int rx1787_rep
    .local pmc rx1787_cur
    .local pmc rx1787_debug
    (rx1787_cur, rx1787_pos, rx1787_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1787_cur
    .local pmc match
    .lex "$/", match
    length rx1787_eos, rx1787_tgt
    gt rx1787_pos, rx1787_eos, rx1787_done
    set rx1787_off, 0
    lt rx1787_pos, 2, rx1787_start
    sub rx1787_off, rx1787_pos, 1
    substr rx1787_tgt, rx1787_tgt, rx1787_off
  rx1787_start:
    eq $I10, 1, rx1787_restart
    if_null rx1787_debug, debug_1343
    rx1787_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1343:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1788_done
    goto rxscan1788_scan
  rxscan1788_loop:
    (rx1787_pos) = rx1787_cur."from"()
    inc rx1787_pos
    rx1787_cur."!cursor_from"(rx1787_pos)
    ge rx1787_pos, rx1787_eos, rxscan1788_done
  rxscan1788_scan:
    set_addr $I10, rxscan1788_loop
    rx1787_cur."!mark_push"(0, rx1787_pos, $I10)
  rxscan1788_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1789_fail
    rx1787_cur."!mark_push"(0, rx1787_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1787_pos, 2
    gt $I11, rx1787_eos, rx1787_fail
    sub $I11, rx1787_pos, rx1787_off
    substr $S10, rx1787_tgt, $I11, 2
    ne $S10, "gt", rx1787_fail
    add rx1787_pos, 2
    set_addr $I10, rxcap_1789_fail
    ($I12, $I11) = rx1787_cur."!mark_peek"($I10)
    rx1787_cur."!cursor_pos"($I11)
    ($P10) = rx1787_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1787_pos, "")
    rx1787_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1789_done
  rxcap_1789_fail:
    goto rx1787_fail
  rxcap_1789_done:
  # rx subrule "O" subtype=capture negate=
    rx1787_cur."!cursor_pos"(rx1787_pos)
    $P10 = rx1787_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1787_fail
    rx1787_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1787_pos = $P10."pos"()
  # rx pass
    rx1787_cur."!cursor_pass"(rx1787_pos, "infix:sym<gt>")
    if_null rx1787_debug, debug_1344
    rx1787_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1787_pos)
  debug_1344:
    .return (rx1787_cur)
  rx1787_restart:
.annotate 'line', 10
    if_null rx1787_debug, debug_1345
    rx1787_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1345:
  rx1787_fail:
    (rx1787_rep, rx1787_pos, $I10, $P10) = rx1787_cur."!mark_fail"(0)
    lt rx1787_pos, -1, rx1787_done
    eq rx1787_pos, -1, rx1787_fail
    jump $I10
  rx1787_done:
    rx1787_cur."!cursor_fail"()
    if_null rx1787_debug, debug_1346
    rx1787_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1346:
    .return (rx1787_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :subid("352_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1791 = self."!PREFIX__!subrule"("O", "gt")
    new $P1792, "ResizablePMCArray"
    push $P1792, $P1791
    .return ($P1792)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("353_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1794_tgt
    .local int rx1794_pos
    .local int rx1794_off
    .local int rx1794_eos
    .local int rx1794_rep
    .local pmc rx1794_cur
    .local pmc rx1794_debug
    (rx1794_cur, rx1794_pos, rx1794_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1794_cur
    .local pmc match
    .lex "$/", match
    length rx1794_eos, rx1794_tgt
    gt rx1794_pos, rx1794_eos, rx1794_done
    set rx1794_off, 0
    lt rx1794_pos, 2, rx1794_start
    sub rx1794_off, rx1794_pos, 1
    substr rx1794_tgt, rx1794_tgt, rx1794_off
  rx1794_start:
    eq $I10, 1, rx1794_restart
    if_null rx1794_debug, debug_1347
    rx1794_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1347:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1795_done
    goto rxscan1795_scan
  rxscan1795_loop:
    (rx1794_pos) = rx1794_cur."from"()
    inc rx1794_pos
    rx1794_cur."!cursor_from"(rx1794_pos)
    ge rx1794_pos, rx1794_eos, rxscan1795_done
  rxscan1795_scan:
    set_addr $I10, rxscan1795_loop
    rx1794_cur."!mark_push"(0, rx1794_pos, $I10)
  rxscan1795_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1796_fail
    rx1794_cur."!mark_push"(0, rx1794_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1794_pos, 3
    gt $I11, rx1794_eos, rx1794_fail
    sub $I11, rx1794_pos, rx1794_off
    substr $S10, rx1794_tgt, $I11, 3
    ne $S10, "=:=", rx1794_fail
    add rx1794_pos, 3
    set_addr $I10, rxcap_1796_fail
    ($I12, $I11) = rx1794_cur."!mark_peek"($I10)
    rx1794_cur."!cursor_pos"($I11)
    ($P10) = rx1794_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1794_pos, "")
    rx1794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1796_done
  rxcap_1796_fail:
    goto rx1794_fail
  rxcap_1796_done:
  # rx subrule "O" subtype=capture negate=
    rx1794_cur."!cursor_pos"(rx1794_pos)
    $P10 = rx1794_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1794_fail
    rx1794_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1794_pos = $P10."pos"()
  # rx pass
    rx1794_cur."!cursor_pass"(rx1794_pos, "infix:sym<=:=>")
    if_null rx1794_debug, debug_1348
    rx1794_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1794_pos)
  debug_1348:
    .return (rx1794_cur)
  rx1794_restart:
.annotate 'line', 10
    if_null rx1794_debug, debug_1349
    rx1794_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1349:
  rx1794_fail:
    (rx1794_rep, rx1794_pos, $I10, $P10) = rx1794_cur."!mark_fail"(0)
    lt rx1794_pos, -1, rx1794_done
    eq rx1794_pos, -1, rx1794_fail
    jump $I10
  rx1794_done:
    rx1794_cur."!cursor_fail"()
    if_null rx1794_debug, debug_1350
    rx1794_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1350:
    .return (rx1794_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :subid("354_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1798 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1799, "ResizablePMCArray"
    push $P1799, $P1798
    .return ($P1799)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("355_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1801_tgt
    .local int rx1801_pos
    .local int rx1801_off
    .local int rx1801_eos
    .local int rx1801_rep
    .local pmc rx1801_cur
    .local pmc rx1801_debug
    (rx1801_cur, rx1801_pos, rx1801_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1801_cur
    .local pmc match
    .lex "$/", match
    length rx1801_eos, rx1801_tgt
    gt rx1801_pos, rx1801_eos, rx1801_done
    set rx1801_off, 0
    lt rx1801_pos, 2, rx1801_start
    sub rx1801_off, rx1801_pos, 1
    substr rx1801_tgt, rx1801_tgt, rx1801_off
  rx1801_start:
    eq $I10, 1, rx1801_restart
    if_null rx1801_debug, debug_1351
    rx1801_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1351:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1802_done
    goto rxscan1802_scan
  rxscan1802_loop:
    (rx1801_pos) = rx1801_cur."from"()
    inc rx1801_pos
    rx1801_cur."!cursor_from"(rx1801_pos)
    ge rx1801_pos, rx1801_eos, rxscan1802_done
  rxscan1802_scan:
    set_addr $I10, rxscan1802_loop
    rx1801_cur."!mark_push"(0, rx1801_pos, $I10)
  rxscan1802_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1803_fail
    rx1801_cur."!mark_push"(0, rx1801_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1801_pos, 2
    gt $I11, rx1801_eos, rx1801_fail
    sub $I11, rx1801_pos, rx1801_off
    substr $S10, rx1801_tgt, $I11, 2
    ne $S10, "~~", rx1801_fail
    add rx1801_pos, 2
    set_addr $I10, rxcap_1803_fail
    ($I12, $I11) = rx1801_cur."!mark_peek"($I10)
    rx1801_cur."!cursor_pos"($I11)
    ($P10) = rx1801_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1801_pos, "")
    rx1801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1803_done
  rxcap_1803_fail:
    goto rx1801_fail
  rxcap_1803_done:
  # rx subrule "O" subtype=capture negate=
    rx1801_cur."!cursor_pos"(rx1801_pos)
    $P10 = rx1801_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1801_fail
    rx1801_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1801_pos = $P10."pos"()
  # rx pass
    rx1801_cur."!cursor_pass"(rx1801_pos, "infix:sym<~~>")
    if_null rx1801_debug, debug_1352
    rx1801_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1801_pos)
  debug_1352:
    .return (rx1801_cur)
  rx1801_restart:
.annotate 'line', 10
    if_null rx1801_debug, debug_1353
    rx1801_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1353:
  rx1801_fail:
    (rx1801_rep, rx1801_pos, $I10, $P10) = rx1801_cur."!mark_fail"(0)
    lt rx1801_pos, -1, rx1801_done
    eq rx1801_pos, -1, rx1801_fail
    jump $I10
  rx1801_done:
    rx1801_cur."!cursor_fail"()
    if_null rx1801_debug, debug_1354
    rx1801_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1354:
    .return (rx1801_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :subid("356_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1805 = self."!PREFIX__!subrule"("O", "~~")
    new $P1806, "ResizablePMCArray"
    push $P1806, $P1805
    .return ($P1806)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("357_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1808_tgt
    .local int rx1808_pos
    .local int rx1808_off
    .local int rx1808_eos
    .local int rx1808_rep
    .local pmc rx1808_cur
    .local pmc rx1808_debug
    (rx1808_cur, rx1808_pos, rx1808_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1808_cur
    .local pmc match
    .lex "$/", match
    length rx1808_eos, rx1808_tgt
    gt rx1808_pos, rx1808_eos, rx1808_done
    set rx1808_off, 0
    lt rx1808_pos, 2, rx1808_start
    sub rx1808_off, rx1808_pos, 1
    substr rx1808_tgt, rx1808_tgt, rx1808_off
  rx1808_start:
    eq $I10, 1, rx1808_restart
    if_null rx1808_debug, debug_1355
    rx1808_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1355:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1809_done
    goto rxscan1809_scan
  rxscan1809_loop:
    (rx1808_pos) = rx1808_cur."from"()
    inc rx1808_pos
    rx1808_cur."!cursor_from"(rx1808_pos)
    ge rx1808_pos, rx1808_eos, rxscan1809_done
  rxscan1809_scan:
    set_addr $I10, rxscan1809_loop
    rx1808_cur."!mark_push"(0, rx1808_pos, $I10)
  rxscan1809_done:
.annotate 'line', 692
  # rx subcapture "sym"
    set_addr $I10, rxcap_1810_fail
    rx1808_cur."!mark_push"(0, rx1808_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1808_pos, 2
    gt $I11, rx1808_eos, rx1808_fail
    sub $I11, rx1808_pos, rx1808_off
    substr $S10, rx1808_tgt, $I11, 2
    ne $S10, "&&", rx1808_fail
    add rx1808_pos, 2
    set_addr $I10, rxcap_1810_fail
    ($I12, $I11) = rx1808_cur."!mark_peek"($I10)
    rx1808_cur."!cursor_pos"($I11)
    ($P10) = rx1808_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1808_pos, "")
    rx1808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1810_done
  rxcap_1810_fail:
    goto rx1808_fail
  rxcap_1810_done:
  # rx subrule "O" subtype=capture negate=
    rx1808_cur."!cursor_pos"(rx1808_pos)
    $P10 = rx1808_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1808_fail
    rx1808_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1808_pos = $P10."pos"()
  # rx pass
    rx1808_cur."!cursor_pass"(rx1808_pos, "infix:sym<&&>")
    if_null rx1808_debug, debug_1356
    rx1808_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1808_pos)
  debug_1356:
    .return (rx1808_cur)
  rx1808_restart:
.annotate 'line', 10
    if_null rx1808_debug, debug_1357
    rx1808_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1357:
  rx1808_fail:
    (rx1808_rep, rx1808_pos, $I10, $P10) = rx1808_cur."!mark_fail"(0)
    lt rx1808_pos, -1, rx1808_done
    eq rx1808_pos, -1, rx1808_fail
    jump $I10
  rx1808_done:
    rx1808_cur."!cursor_fail"()
    if_null rx1808_debug, debug_1358
    rx1808_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1358:
    .return (rx1808_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :subid("358_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1812 = self."!PREFIX__!subrule"("O", "&&")
    new $P1813, "ResizablePMCArray"
    push $P1813, $P1812
    .return ($P1813)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("359_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1815_tgt
    .local int rx1815_pos
    .local int rx1815_off
    .local int rx1815_eos
    .local int rx1815_rep
    .local pmc rx1815_cur
    .local pmc rx1815_debug
    (rx1815_cur, rx1815_pos, rx1815_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1815_cur
    .local pmc match
    .lex "$/", match
    length rx1815_eos, rx1815_tgt
    gt rx1815_pos, rx1815_eos, rx1815_done
    set rx1815_off, 0
    lt rx1815_pos, 2, rx1815_start
    sub rx1815_off, rx1815_pos, 1
    substr rx1815_tgt, rx1815_tgt, rx1815_off
  rx1815_start:
    eq $I10, 1, rx1815_restart
    if_null rx1815_debug, debug_1359
    rx1815_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1359:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1816_done
    goto rxscan1816_scan
  rxscan1816_loop:
    (rx1815_pos) = rx1815_cur."from"()
    inc rx1815_pos
    rx1815_cur."!cursor_from"(rx1815_pos)
    ge rx1815_pos, rx1815_eos, rxscan1816_done
  rxscan1816_scan:
    set_addr $I10, rxscan1816_loop
    rx1815_cur."!mark_push"(0, rx1815_pos, $I10)
  rxscan1816_done:
.annotate 'line', 694
  # rx subcapture "sym"
    set_addr $I10, rxcap_1817_fail
    rx1815_cur."!mark_push"(0, rx1815_pos, $I10)
  # rx literal  "||"
    add $I11, rx1815_pos, 2
    gt $I11, rx1815_eos, rx1815_fail
    sub $I11, rx1815_pos, rx1815_off
    substr $S10, rx1815_tgt, $I11, 2
    ne $S10, "||", rx1815_fail
    add rx1815_pos, 2
    set_addr $I10, rxcap_1817_fail
    ($I12, $I11) = rx1815_cur."!mark_peek"($I10)
    rx1815_cur."!cursor_pos"($I11)
    ($P10) = rx1815_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1815_pos, "")
    rx1815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1817_done
  rxcap_1817_fail:
    goto rx1815_fail
  rxcap_1817_done:
  # rx subrule "O" subtype=capture negate=
    rx1815_cur."!cursor_pos"(rx1815_pos)
    $P10 = rx1815_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1815_fail
    rx1815_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1815_pos = $P10."pos"()
  # rx pass
    rx1815_cur."!cursor_pass"(rx1815_pos, "infix:sym<||>")
    if_null rx1815_debug, debug_1360
    rx1815_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1815_pos)
  debug_1360:
    .return (rx1815_cur)
  rx1815_restart:
.annotate 'line', 10
    if_null rx1815_debug, debug_1361
    rx1815_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1361:
  rx1815_fail:
    (rx1815_rep, rx1815_pos, $I10, $P10) = rx1815_cur."!mark_fail"(0)
    lt rx1815_pos, -1, rx1815_done
    eq rx1815_pos, -1, rx1815_fail
    jump $I10
  rx1815_done:
    rx1815_cur."!cursor_fail"()
    if_null rx1815_debug, debug_1362
    rx1815_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1362:
    .return (rx1815_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :subid("360_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1819 = self."!PREFIX__!subrule"("O", "||")
    new $P1820, "ResizablePMCArray"
    push $P1820, $P1819
    .return ($P1820)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("361_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1822_tgt
    .local int rx1822_pos
    .local int rx1822_off
    .local int rx1822_eos
    .local int rx1822_rep
    .local pmc rx1822_cur
    .local pmc rx1822_debug
    (rx1822_cur, rx1822_pos, rx1822_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1822_cur
    .local pmc match
    .lex "$/", match
    length rx1822_eos, rx1822_tgt
    gt rx1822_pos, rx1822_eos, rx1822_done
    set rx1822_off, 0
    lt rx1822_pos, 2, rx1822_start
    sub rx1822_off, rx1822_pos, 1
    substr rx1822_tgt, rx1822_tgt, rx1822_off
  rx1822_start:
    eq $I10, 1, rx1822_restart
    if_null rx1822_debug, debug_1363
    rx1822_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1363:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1823_done
    goto rxscan1823_scan
  rxscan1823_loop:
    (rx1822_pos) = rx1822_cur."from"()
    inc rx1822_pos
    rx1822_cur."!cursor_from"(rx1822_pos)
    ge rx1822_pos, rx1822_eos, rxscan1823_done
  rxscan1823_scan:
    set_addr $I10, rxscan1823_loop
    rx1822_cur."!mark_push"(0, rx1822_pos, $I10)
  rxscan1823_done:
.annotate 'line', 695
  # rx subcapture "sym"
    set_addr $I10, rxcap_1824_fail
    rx1822_cur."!mark_push"(0, rx1822_pos, $I10)
  # rx literal  "//"
    add $I11, rx1822_pos, 2
    gt $I11, rx1822_eos, rx1822_fail
    sub $I11, rx1822_pos, rx1822_off
    substr $S10, rx1822_tgt, $I11, 2
    ne $S10, "//", rx1822_fail
    add rx1822_pos, 2
    set_addr $I10, rxcap_1824_fail
    ($I12, $I11) = rx1822_cur."!mark_peek"($I10)
    rx1822_cur."!cursor_pos"($I11)
    ($P10) = rx1822_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1822_pos, "")
    rx1822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1824_done
  rxcap_1824_fail:
    goto rx1822_fail
  rxcap_1824_done:
  # rx subrule "O" subtype=capture negate=
    rx1822_cur."!cursor_pos"(rx1822_pos)
    $P10 = rx1822_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1822_fail
    rx1822_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1822_pos = $P10."pos"()
  # rx pass
    rx1822_cur."!cursor_pass"(rx1822_pos, "infix:sym<//>")
    if_null rx1822_debug, debug_1364
    rx1822_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1822_pos)
  debug_1364:
    .return (rx1822_cur)
  rx1822_restart:
.annotate 'line', 10
    if_null rx1822_debug, debug_1365
    rx1822_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1365:
  rx1822_fail:
    (rx1822_rep, rx1822_pos, $I10, $P10) = rx1822_cur."!mark_fail"(0)
    lt rx1822_pos, -1, rx1822_done
    eq rx1822_pos, -1, rx1822_fail
    jump $I10
  rx1822_done:
    rx1822_cur."!cursor_fail"()
    if_null rx1822_debug, debug_1366
    rx1822_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1366:
    .return (rx1822_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :subid("362_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1826 = self."!PREFIX__!subrule"("O", "//")
    new $P1827, "ResizablePMCArray"
    push $P1827, $P1826
    .return ($P1827)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("363_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1829_tgt
    .local int rx1829_pos
    .local int rx1829_off
    .local int rx1829_eos
    .local int rx1829_rep
    .local pmc rx1829_cur
    .local pmc rx1829_debug
    (rx1829_cur, rx1829_pos, rx1829_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1829_cur
    .local pmc match
    .lex "$/", match
    length rx1829_eos, rx1829_tgt
    gt rx1829_pos, rx1829_eos, rx1829_done
    set rx1829_off, 0
    lt rx1829_pos, 2, rx1829_start
    sub rx1829_off, rx1829_pos, 1
    substr rx1829_tgt, rx1829_tgt, rx1829_off
  rx1829_start:
    eq $I10, 1, rx1829_restart
    if_null rx1829_debug, debug_1367
    rx1829_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1367:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1830_done
    goto rxscan1830_scan
  rxscan1830_loop:
    (rx1829_pos) = rx1829_cur."from"()
    inc rx1829_pos
    rx1829_cur."!cursor_from"(rx1829_pos)
    ge rx1829_pos, rx1829_eos, rxscan1830_done
  rxscan1830_scan:
    set_addr $I10, rxscan1830_loop
    rx1829_cur."!mark_push"(0, rx1829_pos, $I10)
  rxscan1830_done:
.annotate 'line', 698
  # rx literal  "??"
    add $I11, rx1829_pos, 2
    gt $I11, rx1829_eos, rx1829_fail
    sub $I11, rx1829_pos, rx1829_off
    substr $S10, rx1829_tgt, $I11, 2
    ne $S10, "??", rx1829_fail
    add rx1829_pos, 2
.annotate 'line', 699
  # rx subrule "ws" subtype=method negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."ws"()
    unless $P10, rx1829_fail
    rx1829_pos = $P10."pos"()
.annotate 'line', 700
  # rx subrule "EXPR" subtype=capture negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."EXPR"("i=")
    unless $P10, rx1829_fail
    rx1829_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1829_pos = $P10."pos"()
.annotate 'line', 701
  # rx literal  "!!"
    add $I11, rx1829_pos, 2
    gt $I11, rx1829_eos, rx1829_fail
    sub $I11, rx1829_pos, rx1829_off
    substr $S10, rx1829_tgt, $I11, 2
    ne $S10, "!!", rx1829_fail
    add rx1829_pos, 2
.annotate 'line', 702
  # rx subrule "O" subtype=capture negate=
    rx1829_cur."!cursor_pos"(rx1829_pos)
    $P10 = rx1829_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1829_fail
    rx1829_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1829_pos = $P10."pos"()
.annotate 'line', 697
  # rx pass
    rx1829_cur."!cursor_pass"(rx1829_pos, "infix:sym<?? !!>")
    if_null rx1829_debug, debug_1368
    rx1829_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1829_pos)
  debug_1368:
    .return (rx1829_cur)
  rx1829_restart:
.annotate 'line', 10
    if_null rx1829_debug, debug_1369
    rx1829_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1369:
  rx1829_fail:
    (rx1829_rep, rx1829_pos, $I10, $P10) = rx1829_cur."!mark_fail"(0)
    lt rx1829_pos, -1, rx1829_done
    eq rx1829_pos, -1, rx1829_fail
    jump $I10
  rx1829_done:
    rx1829_cur."!cursor_fail"()
    if_null rx1829_debug, debug_1370
    rx1829_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1370:
    .return (rx1829_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :subid("364_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1832 = self."!PREFIX__!subrule"("ws", "??")
    new $P1833, "ResizablePMCArray"
    push $P1833, $P1832
    .return ($P1833)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("365_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1835_tgt
    .local int rx1835_pos
    .local int rx1835_off
    .local int rx1835_eos
    .local int rx1835_rep
    .local pmc rx1835_cur
    .local pmc rx1835_debug
    (rx1835_cur, rx1835_pos, rx1835_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1835_cur
    .local pmc match
    .lex "$/", match
    length rx1835_eos, rx1835_tgt
    gt rx1835_pos, rx1835_eos, rx1835_done
    set rx1835_off, 0
    lt rx1835_pos, 2, rx1835_start
    sub rx1835_off, rx1835_pos, 1
    substr rx1835_tgt, rx1835_tgt, rx1835_off
  rx1835_start:
    eq $I10, 1, rx1835_restart
    if_null rx1835_debug, debug_1371
    rx1835_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1371:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1836_done
    goto rxscan1836_scan
  rxscan1836_loop:
    (rx1835_pos) = rx1835_cur."from"()
    inc rx1835_pos
    rx1835_cur."!cursor_from"(rx1835_pos)
    ge rx1835_pos, rx1835_eos, rxscan1836_done
  rxscan1836_scan:
    set_addr $I10, rxscan1836_loop
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  rxscan1836_done:
.annotate 'line', 706
  # rx subcapture "sym"
    set_addr $I10, rxcap_1837_fail
    rx1835_cur."!mark_push"(0, rx1835_pos, $I10)
  # rx literal  "="
    add $I11, rx1835_pos, 1
    gt $I11, rx1835_eos, rx1835_fail
    sub $I11, rx1835_pos, rx1835_off
    ord $I11, rx1835_tgt, $I11
    ne $I11, 61, rx1835_fail
    add rx1835_pos, 1
    set_addr $I10, rxcap_1837_fail
    ($I12, $I11) = rx1835_cur."!mark_peek"($I10)
    rx1835_cur."!cursor_pos"($I11)
    ($P10) = rx1835_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1835_pos, "")
    rx1835_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1837_done
  rxcap_1837_fail:
    goto rx1835_fail
  rxcap_1837_done:
  # rx subrule "panic" subtype=method negate=
    rx1835_cur."!cursor_pos"(rx1835_pos)
    $P10 = rx1835_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1835_fail
    rx1835_pos = $P10."pos"()
.annotate 'line', 705
  # rx pass
    rx1835_cur."!cursor_pass"(rx1835_pos, "infix:sym<=>")
    if_null rx1835_debug, debug_1372
    rx1835_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1835_pos)
  debug_1372:
    .return (rx1835_cur)
  rx1835_restart:
.annotate 'line', 10
    if_null rx1835_debug, debug_1373
    rx1835_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1373:
  rx1835_fail:
    (rx1835_rep, rx1835_pos, $I10, $P10) = rx1835_cur."!mark_fail"(0)
    lt rx1835_pos, -1, rx1835_done
    eq rx1835_pos, -1, rx1835_fail
    jump $I10
  rx1835_done:
    rx1835_cur."!cursor_fail"()
    if_null rx1835_debug, debug_1374
    rx1835_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1374:
    .return (rx1835_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :subid("366_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1839 = self."!PREFIX__!subrule"("panic", "=")
    new $P1840, "ResizablePMCArray"
    push $P1840, $P1839
    .return ($P1840)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("367_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1842_tgt
    .local int rx1842_pos
    .local int rx1842_off
    .local int rx1842_eos
    .local int rx1842_rep
    .local pmc rx1842_cur
    .local pmc rx1842_debug
    (rx1842_cur, rx1842_pos, rx1842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1842_cur
    .local pmc match
    .lex "$/", match
    length rx1842_eos, rx1842_tgt
    gt rx1842_pos, rx1842_eos, rx1842_done
    set rx1842_off, 0
    lt rx1842_pos, 2, rx1842_start
    sub rx1842_off, rx1842_pos, 1
    substr rx1842_tgt, rx1842_tgt, rx1842_off
  rx1842_start:
    eq $I10, 1, rx1842_restart
    if_null rx1842_debug, debug_1375
    rx1842_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1375:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1843_done
    goto rxscan1843_scan
  rxscan1843_loop:
    (rx1842_pos) = rx1842_cur."from"()
    inc rx1842_pos
    rx1842_cur."!cursor_from"(rx1842_pos)
    ge rx1842_pos, rx1842_eos, rxscan1843_done
  rxscan1843_scan:
    set_addr $I10, rxscan1843_loop
    rx1842_cur."!mark_push"(0, rx1842_pos, $I10)
  rxscan1843_done:
.annotate 'line', 708
  # rx subcapture "sym"
    set_addr $I10, rxcap_1844_fail
    rx1842_cur."!mark_push"(0, rx1842_pos, $I10)
  # rx literal  ":="
    add $I11, rx1842_pos, 2
    gt $I11, rx1842_eos, rx1842_fail
    sub $I11, rx1842_pos, rx1842_off
    substr $S10, rx1842_tgt, $I11, 2
    ne $S10, ":=", rx1842_fail
    add rx1842_pos, 2
    set_addr $I10, rxcap_1844_fail
    ($I12, $I11) = rx1842_cur."!mark_peek"($I10)
    rx1842_cur."!cursor_pos"($I11)
    ($P10) = rx1842_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1842_pos, "")
    rx1842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1844_done
  rxcap_1844_fail:
    goto rx1842_fail
  rxcap_1844_done:
  # rx subrule "O" subtype=capture negate=
    rx1842_cur."!cursor_pos"(rx1842_pos)
    $P10 = rx1842_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1842_fail
    rx1842_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1842_pos = $P10."pos"()
  # rx pass
    rx1842_cur."!cursor_pass"(rx1842_pos, "infix:sym<:=>")
    if_null rx1842_debug, debug_1376
    rx1842_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1842_pos)
  debug_1376:
    .return (rx1842_cur)
  rx1842_restart:
.annotate 'line', 10
    if_null rx1842_debug, debug_1377
    rx1842_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1377:
  rx1842_fail:
    (rx1842_rep, rx1842_pos, $I10, $P10) = rx1842_cur."!mark_fail"(0)
    lt rx1842_pos, -1, rx1842_done
    eq rx1842_pos, -1, rx1842_fail
    jump $I10
  rx1842_done:
    rx1842_cur."!cursor_fail"()
    if_null rx1842_debug, debug_1378
    rx1842_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1378:
    .return (rx1842_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :subid("368_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1846 = self."!PREFIX__!subrule"("O", ":=")
    new $P1847, "ResizablePMCArray"
    push $P1847, $P1846
    .return ($P1847)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("369_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1849_tgt
    .local int rx1849_pos
    .local int rx1849_off
    .local int rx1849_eos
    .local int rx1849_rep
    .local pmc rx1849_cur
    .local pmc rx1849_debug
    (rx1849_cur, rx1849_pos, rx1849_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1849_cur
    .local pmc match
    .lex "$/", match
    length rx1849_eos, rx1849_tgt
    gt rx1849_pos, rx1849_eos, rx1849_done
    set rx1849_off, 0
    lt rx1849_pos, 2, rx1849_start
    sub rx1849_off, rx1849_pos, 1
    substr rx1849_tgt, rx1849_tgt, rx1849_off
  rx1849_start:
    eq $I10, 1, rx1849_restart
    if_null rx1849_debug, debug_1379
    rx1849_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1379:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1850_done
    goto rxscan1850_scan
  rxscan1850_loop:
    (rx1849_pos) = rx1849_cur."from"()
    inc rx1849_pos
    rx1849_cur."!cursor_from"(rx1849_pos)
    ge rx1849_pos, rx1849_eos, rxscan1850_done
  rxscan1850_scan:
    set_addr $I10, rxscan1850_loop
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  rxscan1850_done:
.annotate 'line', 709
  # rx subcapture "sym"
    set_addr $I10, rxcap_1851_fail
    rx1849_cur."!mark_push"(0, rx1849_pos, $I10)
  # rx literal  "::="
    add $I11, rx1849_pos, 3
    gt $I11, rx1849_eos, rx1849_fail
    sub $I11, rx1849_pos, rx1849_off
    substr $S10, rx1849_tgt, $I11, 3
    ne $S10, "::=", rx1849_fail
    add rx1849_pos, 3
    set_addr $I10, rxcap_1851_fail
    ($I12, $I11) = rx1849_cur."!mark_peek"($I10)
    rx1849_cur."!cursor_pos"($I11)
    ($P10) = rx1849_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1849_pos, "")
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1851_done
  rxcap_1851_fail:
    goto rx1849_fail
  rxcap_1851_done:
  # rx subrule "O" subtype=capture negate=
    rx1849_cur."!cursor_pos"(rx1849_pos)
    $P10 = rx1849_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1849_fail
    rx1849_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1849_pos = $P10."pos"()
  # rx pass
    rx1849_cur."!cursor_pass"(rx1849_pos, "infix:sym<::=>")
    if_null rx1849_debug, debug_1380
    rx1849_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1849_pos)
  debug_1380:
    .return (rx1849_cur)
  rx1849_restart:
.annotate 'line', 10
    if_null rx1849_debug, debug_1381
    rx1849_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1381:
  rx1849_fail:
    (rx1849_rep, rx1849_pos, $I10, $P10) = rx1849_cur."!mark_fail"(0)
    lt rx1849_pos, -1, rx1849_done
    eq rx1849_pos, -1, rx1849_fail
    jump $I10
  rx1849_done:
    rx1849_cur."!cursor_fail"()
    if_null rx1849_debug, debug_1382
    rx1849_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1382:
    .return (rx1849_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :subid("370_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1853 = self."!PREFIX__!subrule"("O", "::=")
    new $P1854, "ResizablePMCArray"
    push $P1854, $P1853
    .return ($P1854)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("371_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1856_tgt
    .local int rx1856_pos
    .local int rx1856_off
    .local int rx1856_eos
    .local int rx1856_rep
    .local pmc rx1856_cur
    .local pmc rx1856_debug
    (rx1856_cur, rx1856_pos, rx1856_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1856_cur
    .local pmc match
    .lex "$/", match
    length rx1856_eos, rx1856_tgt
    gt rx1856_pos, rx1856_eos, rx1856_done
    set rx1856_off, 0
    lt rx1856_pos, 2, rx1856_start
    sub rx1856_off, rx1856_pos, 1
    substr rx1856_tgt, rx1856_tgt, rx1856_off
  rx1856_start:
    eq $I10, 1, rx1856_restart
    if_null rx1856_debug, debug_1383
    rx1856_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1383:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1857_done
    goto rxscan1857_scan
  rxscan1857_loop:
    (rx1856_pos) = rx1856_cur."from"()
    inc rx1856_pos
    rx1856_cur."!cursor_from"(rx1856_pos)
    ge rx1856_pos, rx1856_eos, rxscan1857_done
  rxscan1857_scan:
    set_addr $I10, rxscan1857_loop
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  rxscan1857_done:
.annotate 'line', 711
  # rx subcapture "sym"
    set_addr $I10, rxcap_1858_fail
    rx1856_cur."!mark_push"(0, rx1856_pos, $I10)
  # rx literal  ","
    add $I11, rx1856_pos, 1
    gt $I11, rx1856_eos, rx1856_fail
    sub $I11, rx1856_pos, rx1856_off
    ord $I11, rx1856_tgt, $I11
    ne $I11, 44, rx1856_fail
    add rx1856_pos, 1
    set_addr $I10, rxcap_1858_fail
    ($I12, $I11) = rx1856_cur."!mark_peek"($I10)
    rx1856_cur."!cursor_pos"($I11)
    ($P10) = rx1856_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1856_pos, "")
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1858_done
  rxcap_1858_fail:
    goto rx1856_fail
  rxcap_1858_done:
  # rx subrule "O" subtype=capture negate=
    rx1856_cur."!cursor_pos"(rx1856_pos)
    $P10 = rx1856_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1856_fail
    rx1856_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1856_pos = $P10."pos"()
  # rx pass
    rx1856_cur."!cursor_pass"(rx1856_pos, "infix:sym<,>")
    if_null rx1856_debug, debug_1384
    rx1856_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1856_pos)
  debug_1384:
    .return (rx1856_cur)
  rx1856_restart:
.annotate 'line', 10
    if_null rx1856_debug, debug_1385
    rx1856_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1385:
  rx1856_fail:
    (rx1856_rep, rx1856_pos, $I10, $P10) = rx1856_cur."!mark_fail"(0)
    lt rx1856_pos, -1, rx1856_done
    eq rx1856_pos, -1, rx1856_fail
    jump $I10
  rx1856_done:
    rx1856_cur."!cursor_fail"()
    if_null rx1856_debug, debug_1386
    rx1856_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1386:
    .return (rx1856_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :subid("372_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    $P1860 = self."!PREFIX__!subrule"("O", ",")
    new $P1861, "ResizablePMCArray"
    push $P1861, $P1860
    .return ($P1861)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("373_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .const 'Sub' $P1869 = "374_1304516047.681" 
    capture_lex $P1869
    .local string rx1863_tgt
    .local int rx1863_pos
    .local int rx1863_off
    .local int rx1863_eos
    .local int rx1863_rep
    .local pmc rx1863_cur
    .local pmc rx1863_debug
    (rx1863_cur, rx1863_pos, rx1863_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1863_cur
    .local pmc match
    .lex "$/", match
    length rx1863_eos, rx1863_tgt
    gt rx1863_pos, rx1863_eos, rx1863_done
    set rx1863_off, 0
    lt rx1863_pos, 2, rx1863_start
    sub rx1863_off, rx1863_pos, 1
    substr rx1863_tgt, rx1863_tgt, rx1863_off
  rx1863_start:
    eq $I10, 1, rx1863_restart
    if_null rx1863_debug, debug_1387
    rx1863_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1387:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1864_done
    goto rxscan1864_scan
  rxscan1864_loop:
    (rx1863_pos) = rx1863_cur."from"()
    inc rx1863_pos
    rx1863_cur."!cursor_from"(rx1863_pos)
    ge rx1863_pos, rx1863_eos, rxscan1864_done
  rxscan1864_scan:
    set_addr $I10, rxscan1864_loop
    rx1863_cur."!mark_push"(0, rx1863_pos, $I10)
  rxscan1864_done:
.annotate 'line', 713
  # rx subcapture "sym"
    set_addr $I10, rxcap_1865_fail
    rx1863_cur."!mark_push"(0, rx1863_pos, $I10)
  # rx literal  "return"
    add $I11, rx1863_pos, 6
    gt $I11, rx1863_eos, rx1863_fail
    sub $I11, rx1863_pos, rx1863_off
    substr $S10, rx1863_tgt, $I11, 6
    ne $S10, "return", rx1863_fail
    add rx1863_pos, 6
    set_addr $I10, rxcap_1865_fail
    ($I12, $I11) = rx1863_cur."!mark_peek"($I10)
    rx1863_cur."!cursor_pos"($I11)
    ($P10) = rx1863_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1863_pos, "")
    rx1863_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1865_done
  rxcap_1865_fail:
    goto rx1863_fail
  rxcap_1865_done:
  # rx charclass s
    ge rx1863_pos, rx1863_eos, rx1863_fail
    sub $I10, rx1863_pos, rx1863_off
    is_cclass $I11, 32, rx1863_tgt, $I10
    unless $I11, rx1863_fail
    inc rx1863_pos
  # rx subrule "O" subtype=capture negate=
    rx1863_cur."!cursor_pos"(rx1863_pos)
    $P10 = rx1863_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1863_fail
    rx1863_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1863_pos = $P10."pos"()
    rx1863_cur."!cursor_pos"(rx1863_pos)
    find_lex $P1866, unicode:"$\x{a2}"
    $P1867 = $P1866."MATCH"()
    store_lex "$/", $P1867
    .const 'Sub' $P1869 = "374_1304516047.681" 
    capture_lex $P1869
    $P1871 = $P1869()
  # rx pass
    rx1863_cur."!cursor_pass"(rx1863_pos, "prefix:sym<return>")
    if_null rx1863_debug, debug_1388
    rx1863_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1863_pos)
  debug_1388:
    .return (rx1863_cur)
  rx1863_restart:
.annotate 'line', 10
    if_null rx1863_debug, debug_1389
    rx1863_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1389:
  rx1863_fail:
    (rx1863_rep, rx1863_pos, $I10, $P10) = rx1863_cur."!mark_fail"(0)
    lt rx1863_pos, -1, rx1863_done
    eq rx1863_pos, -1, rx1863_fail
    jump $I10
  rx1863_done:
    rx1863_cur."!cursor_fail"()
    if_null rx1863_debug, debug_1390
    rx1863_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1390:
    .return (rx1863_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1868"  :anon :subid("374_1304516047.681") :outer("373_1304516047.681")
.annotate 'line', 713
    new $P1870, "Integer"
    assign $P1870, 1
    store_dynamic_lex "$*RETURN_USED", $P1870
    .return ($P1870)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :subid("375_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1873, "ResizablePMCArray"
    push $P1873, "return"
    .return ($P1873)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("376_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1875_tgt
    .local int rx1875_pos
    .local int rx1875_off
    .local int rx1875_eos
    .local int rx1875_rep
    .local pmc rx1875_cur
    .local pmc rx1875_debug
    (rx1875_cur, rx1875_pos, rx1875_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1875_cur
    .local pmc match
    .lex "$/", match
    length rx1875_eos, rx1875_tgt
    gt rx1875_pos, rx1875_eos, rx1875_done
    set rx1875_off, 0
    lt rx1875_pos, 2, rx1875_start
    sub rx1875_off, rx1875_pos, 1
    substr rx1875_tgt, rx1875_tgt, rx1875_off
  rx1875_start:
    eq $I10, 1, rx1875_restart
    if_null rx1875_debug, debug_1391
    rx1875_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1391:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1876_done
    goto rxscan1876_scan
  rxscan1876_loop:
    (rx1875_pos) = rx1875_cur."from"()
    inc rx1875_pos
    rx1875_cur."!cursor_from"(rx1875_pos)
    ge rx1875_pos, rx1875_eos, rxscan1876_done
  rxscan1876_scan:
    set_addr $I10, rxscan1876_loop
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  rxscan1876_done:
.annotate 'line', 714
  # rx subcapture "sym"
    set_addr $I10, rxcap_1877_fail
    rx1875_cur."!mark_push"(0, rx1875_pos, $I10)
  # rx literal  "make"
    add $I11, rx1875_pos, 4
    gt $I11, rx1875_eos, rx1875_fail
    sub $I11, rx1875_pos, rx1875_off
    substr $S10, rx1875_tgt, $I11, 4
    ne $S10, "make", rx1875_fail
    add rx1875_pos, 4
    set_addr $I10, rxcap_1877_fail
    ($I12, $I11) = rx1875_cur."!mark_peek"($I10)
    rx1875_cur."!cursor_pos"($I11)
    ($P10) = rx1875_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1875_pos, "")
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1877_done
  rxcap_1877_fail:
    goto rx1875_fail
  rxcap_1877_done:
  # rx charclass s
    ge rx1875_pos, rx1875_eos, rx1875_fail
    sub $I10, rx1875_pos, rx1875_off
    is_cclass $I11, 32, rx1875_tgt, $I10
    unless $I11, rx1875_fail
    inc rx1875_pos
  # rx subrule "O" subtype=capture negate=
    rx1875_cur."!cursor_pos"(rx1875_pos)
    $P10 = rx1875_cur."O"("%list_prefix")
    unless $P10, rx1875_fail
    rx1875_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1875_pos = $P10."pos"()
  # rx pass
    rx1875_cur."!cursor_pass"(rx1875_pos, "prefix:sym<make>")
    if_null rx1875_debug, debug_1392
    rx1875_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1875_pos)
  debug_1392:
    .return (rx1875_cur)
  rx1875_restart:
.annotate 'line', 10
    if_null rx1875_debug, debug_1393
    rx1875_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1393:
  rx1875_fail:
    (rx1875_rep, rx1875_pos, $I10, $P10) = rx1875_cur."!mark_fail"(0)
    lt rx1875_pos, -1, rx1875_done
    eq rx1875_pos, -1, rx1875_fail
    jump $I10
  rx1875_done:
    rx1875_cur."!cursor_fail"()
    if_null rx1875_debug, debug_1394
    rx1875_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1394:
    .return (rx1875_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :subid("377_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1879, "ResizablePMCArray"
    push $P1879, "make"
    .return ($P1879)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("378_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1881_tgt
    .local int rx1881_pos
    .local int rx1881_off
    .local int rx1881_eos
    .local int rx1881_rep
    .local pmc rx1881_cur
    .local pmc rx1881_debug
    (rx1881_cur, rx1881_pos, rx1881_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1881_cur
    .local pmc match
    .lex "$/", match
    length rx1881_eos, rx1881_tgt
    gt rx1881_pos, rx1881_eos, rx1881_done
    set rx1881_off, 0
    lt rx1881_pos, 2, rx1881_start
    sub rx1881_off, rx1881_pos, 1
    substr rx1881_tgt, rx1881_tgt, rx1881_off
  rx1881_start:
    eq $I10, 1, rx1881_restart
    if_null rx1881_debug, debug_1395
    rx1881_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1395:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1882_done
    goto rxscan1882_scan
  rxscan1882_loop:
    (rx1881_pos) = rx1881_cur."from"()
    inc rx1881_pos
    rx1881_cur."!cursor_from"(rx1881_pos)
    ge rx1881_pos, rx1881_eos, rxscan1882_done
  rxscan1882_scan:
    set_addr $I10, rxscan1882_loop
    rx1881_cur."!mark_push"(0, rx1881_pos, $I10)
  rxscan1882_done:
.annotate 'line', 715
  # rx subcapture "sym"
    set_addr $I10, rxcap_1883_fail
    rx1881_cur."!mark_push"(0, rx1881_pos, $I10)
  # rx literal  "last"
    add $I11, rx1881_pos, 4
    gt $I11, rx1881_eos, rx1881_fail
    sub $I11, rx1881_pos, rx1881_off
    substr $S10, rx1881_tgt, $I11, 4
    ne $S10, "last", rx1881_fail
    add rx1881_pos, 4
    set_addr $I10, rxcap_1883_fail
    ($I12, $I11) = rx1881_cur."!mark_peek"($I10)
    rx1881_cur."!cursor_pos"($I11)
    ($P10) = rx1881_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1881_pos, "")
    rx1881_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1883_done
  rxcap_1883_fail:
    goto rx1881_fail
  rxcap_1883_done:
  # rx pass
    rx1881_cur."!cursor_pass"(rx1881_pos, "term:sym<last>")
    if_null rx1881_debug, debug_1396
    rx1881_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1881_pos)
  debug_1396:
    .return (rx1881_cur)
  rx1881_restart:
.annotate 'line', 10
    if_null rx1881_debug, debug_1397
    rx1881_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1397:
  rx1881_fail:
    (rx1881_rep, rx1881_pos, $I10, $P10) = rx1881_cur."!mark_fail"(0)
    lt rx1881_pos, -1, rx1881_done
    eq rx1881_pos, -1, rx1881_fail
    jump $I10
  rx1881_done:
    rx1881_cur."!cursor_fail"()
    if_null rx1881_debug, debug_1398
    rx1881_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1398:
    .return (rx1881_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :subid("379_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1885, "ResizablePMCArray"
    push $P1885, "last"
    .return ($P1885)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("380_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1887_tgt
    .local int rx1887_pos
    .local int rx1887_off
    .local int rx1887_eos
    .local int rx1887_rep
    .local pmc rx1887_cur
    .local pmc rx1887_debug
    (rx1887_cur, rx1887_pos, rx1887_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1887_cur
    .local pmc match
    .lex "$/", match
    length rx1887_eos, rx1887_tgt
    gt rx1887_pos, rx1887_eos, rx1887_done
    set rx1887_off, 0
    lt rx1887_pos, 2, rx1887_start
    sub rx1887_off, rx1887_pos, 1
    substr rx1887_tgt, rx1887_tgt, rx1887_off
  rx1887_start:
    eq $I10, 1, rx1887_restart
    if_null rx1887_debug, debug_1399
    rx1887_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1399:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1888_done
    goto rxscan1888_scan
  rxscan1888_loop:
    (rx1887_pos) = rx1887_cur."from"()
    inc rx1887_pos
    rx1887_cur."!cursor_from"(rx1887_pos)
    ge rx1887_pos, rx1887_eos, rxscan1888_done
  rxscan1888_scan:
    set_addr $I10, rxscan1888_loop
    rx1887_cur."!mark_push"(0, rx1887_pos, $I10)
  rxscan1888_done:
.annotate 'line', 716
  # rx subcapture "sym"
    set_addr $I10, rxcap_1889_fail
    rx1887_cur."!mark_push"(0, rx1887_pos, $I10)
  # rx literal  "next"
    add $I11, rx1887_pos, 4
    gt $I11, rx1887_eos, rx1887_fail
    sub $I11, rx1887_pos, rx1887_off
    substr $S10, rx1887_tgt, $I11, 4
    ne $S10, "next", rx1887_fail
    add rx1887_pos, 4
    set_addr $I10, rxcap_1889_fail
    ($I12, $I11) = rx1887_cur."!mark_peek"($I10)
    rx1887_cur."!cursor_pos"($I11)
    ($P10) = rx1887_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1887_pos, "")
    rx1887_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1889_done
  rxcap_1889_fail:
    goto rx1887_fail
  rxcap_1889_done:
  # rx pass
    rx1887_cur."!cursor_pass"(rx1887_pos, "term:sym<next>")
    if_null rx1887_debug, debug_1400
    rx1887_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1887_pos)
  debug_1400:
    .return (rx1887_cur)
  rx1887_restart:
.annotate 'line', 10
    if_null rx1887_debug, debug_1401
    rx1887_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1401:
  rx1887_fail:
    (rx1887_rep, rx1887_pos, $I10, $P10) = rx1887_cur."!mark_fail"(0)
    lt rx1887_pos, -1, rx1887_done
    eq rx1887_pos, -1, rx1887_fail
    jump $I10
  rx1887_done:
    rx1887_cur."!cursor_fail"()
    if_null rx1887_debug, debug_1402
    rx1887_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1402:
    .return (rx1887_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :subid("381_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1891, "ResizablePMCArray"
    push $P1891, "next"
    .return ($P1891)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("382_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    .local string rx1893_tgt
    .local int rx1893_pos
    .local int rx1893_off
    .local int rx1893_eos
    .local int rx1893_rep
    .local pmc rx1893_cur
    .local pmc rx1893_debug
    (rx1893_cur, rx1893_pos, rx1893_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1893_cur
    .local pmc match
    .lex "$/", match
    length rx1893_eos, rx1893_tgt
    gt rx1893_pos, rx1893_eos, rx1893_done
    set rx1893_off, 0
    lt rx1893_pos, 2, rx1893_start
    sub rx1893_off, rx1893_pos, 1
    substr rx1893_tgt, rx1893_tgt, rx1893_off
  rx1893_start:
    eq $I10, 1, rx1893_restart
    if_null rx1893_debug, debug_1403
    rx1893_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1403:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1894_done
    goto rxscan1894_scan
  rxscan1894_loop:
    (rx1893_pos) = rx1893_cur."from"()
    inc rx1893_pos
    rx1893_cur."!cursor_from"(rx1893_pos)
    ge rx1893_pos, rx1893_eos, rxscan1894_done
  rxscan1894_scan:
    set_addr $I10, rxscan1894_loop
    rx1893_cur."!mark_push"(0, rx1893_pos, $I10)
  rxscan1894_done:
.annotate 'line', 717
  # rx subcapture "sym"
    set_addr $I10, rxcap_1895_fail
    rx1893_cur."!mark_push"(0, rx1893_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1893_pos, 4
    gt $I11, rx1893_eos, rx1893_fail
    sub $I11, rx1893_pos, rx1893_off
    substr $S10, rx1893_tgt, $I11, 4
    ne $S10, "redo", rx1893_fail
    add rx1893_pos, 4
    set_addr $I10, rxcap_1895_fail
    ($I12, $I11) = rx1893_cur."!mark_peek"($I10)
    rx1893_cur."!cursor_pos"($I11)
    ($P10) = rx1893_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1893_pos, "")
    rx1893_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1895_done
  rxcap_1895_fail:
    goto rx1893_fail
  rxcap_1895_done:
  # rx pass
    rx1893_cur."!cursor_pass"(rx1893_pos, "term:sym<redo>")
    if_null rx1893_debug, debug_1404
    rx1893_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1893_pos)
  debug_1404:
    .return (rx1893_cur)
  rx1893_restart:
.annotate 'line', 10
    if_null rx1893_debug, debug_1405
    rx1893_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1405:
  rx1893_fail:
    (rx1893_rep, rx1893_pos, $I10, $P10) = rx1893_cur."!mark_fail"(0)
    lt rx1893_pos, -1, rx1893_done
    eq rx1893_pos, -1, rx1893_fail
    jump $I10
  rx1893_done:
    rx1893_cur."!cursor_fail"()
    if_null rx1893_debug, debug_1406
    rx1893_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1406:
    .return (rx1893_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :subid("383_1304516047.681") :method :outer("12_1304516047.681")
.annotate 'line', 10
    new $P1897, "ResizablePMCArray"
    push $P1897, "redo"
    .return ($P1897)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("384_1304516047.681") :outer("12_1304516047.681")
    .param pmc param_1899
    .param pmc param_1900
.annotate 'line', 719
    .lex "self", param_1899
    .lex "$/", param_1900
.annotate 'line', 721
    new $P1901, "Undef"
    .lex "$t", $P1901
    find_lex $P1902, "$/"
    unless_null $P1902, vivify_1407
    $P1902 = root_new ['parrot';'ResizablePMCArray']
  vivify_1407:
    set $P1903, $P1902[0]
    unless_null $P1903, vivify_1408
    new $P1903, "Undef"
  vivify_1408:
    store_lex "$t", $P1903
    find_lex $P1904, "$/"
    unless_null $P1904, vivify_1409
    $P1904 = root_new ['parrot';'ResizablePMCArray']
  vivify_1409:
    set $P1905, $P1904[1]
    unless_null $P1905, vivify_1410
    new $P1905, "Undef"
  vivify_1410:
    find_lex $P1906, "$/"
    unless_null $P1906, vivify_1411
    $P1906 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1906
  vivify_1411:
    set $P1906[0], $P1905
    find_lex $P1907, "$t"
    unless_null $P1907, vivify_1412
    new $P1907, "Undef"
  vivify_1412:
    find_lex $P1908, "$/"
    unless_null $P1908, vivify_1413
    $P1908 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1908
  vivify_1413:
    set $P1908[1], $P1907
.annotate 'line', 719
    .return ($P1907)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1910"  :subid("385_1304516047.681") :outer("10_1304516047.681")
.annotate 'line', 725
    .const 'Sub' $P1972 = "405_1304516047.681" 
    capture_lex $P1972
    .const 'Sub' $P1969 = "404_1304516047.681" 
    capture_lex $P1969
    .const 'Sub' $P1967 = "403_1304516047.681" 
    capture_lex $P1967
    .const 'Sub' $P1964 = "402_1304516047.681" 
    capture_lex $P1964
    .const 'Sub' $P1961 = "401_1304516047.681" 
    capture_lex $P1961
    .const 'Sub' $P1952 = "399_1304516047.681" 
    capture_lex $P1952
    .const 'Sub' $P1950 = "398_1304516047.681" 
    capture_lex $P1950
    .const 'Sub' $P1942 = "396_1304516047.681" 
    capture_lex $P1942
    .const 'Sub' $P1940 = "395_1304516047.681" 
    capture_lex $P1940
    .const 'Sub' $P1937 = "394_1304516047.681" 
    capture_lex $P1937
    .const 'Sub' $P1935 = "393_1304516047.681" 
    capture_lex $P1935
    .const 'Sub' $P1928 = "391_1304516047.681" 
    capture_lex $P1928
    .const 'Sub' $P1926 = "390_1304516047.681" 
    capture_lex $P1926
    .const 'Sub' $P1923 = "389_1304516047.681" 
    capture_lex $P1923
    .const 'Sub' $P1921 = "388_1304516047.681" 
    capture_lex $P1921
    .const 'Sub' $P1914 = "386_1304516047.681" 
    capture_lex $P1914
    .lex "$?PACKAGE", $P1912
    .lex "$?CLASS", $P1913
    .const 'Sub' $P1972 = "405_1304516047.681" 
    capture_lex $P1972
    .return ($P1972)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("386_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    .const 'Sub' $P1918 = "387_1304516047.681" 
    capture_lex $P1918
    .local string rx1915_tgt
    .local int rx1915_pos
    .local int rx1915_off
    .local int rx1915_eos
    .local int rx1915_rep
    .local pmc rx1915_cur
    .local pmc rx1915_debug
    (rx1915_cur, rx1915_pos, rx1915_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1915_cur
    .local pmc match
    .lex "$/", match
    length rx1915_eos, rx1915_tgt
    gt rx1915_pos, rx1915_eos, rx1915_done
    set rx1915_off, 0
    lt rx1915_pos, 2, rx1915_start
    sub rx1915_off, rx1915_pos, 1
    substr rx1915_tgt, rx1915_tgt, rx1915_off
  rx1915_start:
    eq $I10, 1, rx1915_restart
    if_null rx1915_debug, debug_1414
    rx1915_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1414:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1916_done
    goto rxscan1916_scan
  rxscan1916_loop:
    (rx1915_pos) = rx1915_cur."from"()
    inc rx1915_pos
    rx1915_cur."!cursor_from"(rx1915_pos)
    ge rx1915_pos, rx1915_eos, rxscan1916_done
  rxscan1916_scan:
    set_addr $I10, rxscan1916_loop
    rx1915_cur."!mark_push"(0, rx1915_pos, $I10)
  rxscan1916_done:
.annotate 'line', 727
  # rx literal  ":"
    add $I11, rx1915_pos, 1
    gt $I11, rx1915_eos, rx1915_fail
    sub $I11, rx1915_pos, rx1915_off
    ord $I11, rx1915_tgt, $I11
    ne $I11, 58, rx1915_fail
    add rx1915_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1915_cur."!cursor_pos"(rx1915_pos)
    .const 'Sub' $P1918 = "387_1304516047.681" 
    capture_lex $P1918
    $P10 = rx1915_cur."before"($P1918)
    unless $P10, rx1915_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1915_cur."!cursor_pos"(rx1915_pos)
    $P10 = rx1915_cur."LANG"("MAIN", "statement")
    unless $P10, rx1915_fail
    rx1915_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1915_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1915_cur."!cursor_pos"(rx1915_pos)
    $P10 = rx1915_cur."ws"()
    unless $P10, rx1915_fail
    rx1915_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1915_pos, 1
    gt $I11, rx1915_eos, rx1915_fail
    sub $I11, rx1915_pos, rx1915_off
    ord $I11, rx1915_tgt, $I11
    ne $I11, 59, rx1915_fail
    add rx1915_pos, 1
.annotate 'line', 726
  # rx pass
    rx1915_cur."!cursor_pass"(rx1915_pos, "metachar:sym<:my>")
    if_null rx1915_debug, debug_1419
    rx1915_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1915_pos)
  debug_1419:
    .return (rx1915_cur)
  rx1915_restart:
.annotate 'line', 725
    if_null rx1915_debug, debug_1420
    rx1915_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1420:
  rx1915_fail:
    (rx1915_rep, rx1915_pos, $I10, $P10) = rx1915_cur."!mark_fail"(0)
    lt rx1915_pos, -1, rx1915_done
    eq rx1915_pos, -1, rx1915_fail
    jump $I10
  rx1915_done:
    rx1915_cur."!cursor_fail"()
    if_null rx1915_debug, debug_1421
    rx1915_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1421:
    .return (rx1915_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1917"  :anon :subid("387_1304516047.681") :method :outer("386_1304516047.681")
.annotate 'line', 727
    .local string rx1919_tgt
    .local int rx1919_pos
    .local int rx1919_off
    .local int rx1919_eos
    .local int rx1919_rep
    .local pmc rx1919_cur
    .local pmc rx1919_debug
    (rx1919_cur, rx1919_pos, rx1919_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1919_cur
    .local pmc match
    .lex "$/", match
    length rx1919_eos, rx1919_tgt
    gt rx1919_pos, rx1919_eos, rx1919_done
    set rx1919_off, 0
    lt rx1919_pos, 2, rx1919_start
    sub rx1919_off, rx1919_pos, 1
    substr rx1919_tgt, rx1919_tgt, rx1919_off
  rx1919_start:
    eq $I10, 1, rx1919_restart
    if_null rx1919_debug, debug_1415
    rx1919_cur."!cursor_debug"("START", "")
  debug_1415:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1920_done
    goto rxscan1920_scan
  rxscan1920_loop:
    (rx1919_pos) = rx1919_cur."from"()
    inc rx1919_pos
    rx1919_cur."!cursor_from"(rx1919_pos)
    ge rx1919_pos, rx1919_eos, rxscan1920_done
  rxscan1920_scan:
    set_addr $I10, rxscan1920_loop
    rx1919_cur."!mark_push"(0, rx1919_pos, $I10)
  rxscan1920_done:
  # rx literal  "my"
    add $I11, rx1919_pos, 2
    gt $I11, rx1919_eos, rx1919_fail
    sub $I11, rx1919_pos, rx1919_off
    substr $S10, rx1919_tgt, $I11, 2
    ne $S10, "my", rx1919_fail
    add rx1919_pos, 2
  # rx pass
    rx1919_cur."!cursor_pass"(rx1919_pos, "")
    if_null rx1919_debug, debug_1416
    rx1919_cur."!cursor_debug"("PASS", "", " at pos=", rx1919_pos)
  debug_1416:
    .return (rx1919_cur)
  rx1919_restart:
    if_null rx1919_debug, debug_1417
    rx1919_cur."!cursor_debug"("NEXT", "")
  debug_1417:
  rx1919_fail:
    (rx1919_rep, rx1919_pos, $I10, $P10) = rx1919_cur."!mark_fail"(0)
    lt rx1919_pos, -1, rx1919_done
    eq rx1919_pos, -1, rx1919_fail
    jump $I10
  rx1919_done:
    rx1919_cur."!cursor_fail"()
    if_null rx1919_debug, debug_1418
    rx1919_cur."!cursor_debug"("FAIL", "")
  debug_1418:
    .return (rx1919_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :subid("388_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    new $P1922, "ResizablePMCArray"
    push $P1922, ":"
    .return ($P1922)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("389_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    .local string rx1924_tgt
    .local int rx1924_pos
    .local int rx1924_off
    .local int rx1924_eos
    .local int rx1924_rep
    .local pmc rx1924_cur
    .local pmc rx1924_debug
    (rx1924_cur, rx1924_pos, rx1924_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1924_cur
    .local pmc match
    .lex "$/", match
    length rx1924_eos, rx1924_tgt
    gt rx1924_pos, rx1924_eos, rx1924_done
    set rx1924_off, 0
    lt rx1924_pos, 2, rx1924_start
    sub rx1924_off, rx1924_pos, 1
    substr rx1924_tgt, rx1924_tgt, rx1924_off
  rx1924_start:
    eq $I10, 1, rx1924_restart
    if_null rx1924_debug, debug_1422
    rx1924_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1422:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1925_done
    goto rxscan1925_scan
  rxscan1925_loop:
    (rx1924_pos) = rx1924_cur."from"()
    inc rx1924_pos
    rx1924_cur."!cursor_from"(rx1924_pos)
    ge rx1924_pos, rx1924_eos, rxscan1925_done
  rxscan1925_scan:
    set_addr $I10, rxscan1925_loop
    rx1924_cur."!mark_push"(0, rx1924_pos, $I10)
  rxscan1925_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1924_pos, rx1924_off
    substr $S10, rx1924_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1924_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1924_cur."!cursor_pos"(rx1924_pos)
    $P10 = rx1924_cur."codeblock"()
    unless $P10, rx1924_fail
    rx1924_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1924_pos = $P10."pos"()
.annotate 'line', 730
  # rx pass
    rx1924_cur."!cursor_pass"(rx1924_pos, "metachar:sym<{ }>")
    if_null rx1924_debug, debug_1423
    rx1924_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1924_pos)
  debug_1423:
    .return (rx1924_cur)
  rx1924_restart:
.annotate 'line', 725
    if_null rx1924_debug, debug_1424
    rx1924_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1424:
  rx1924_fail:
    (rx1924_rep, rx1924_pos, $I10, $P10) = rx1924_cur."!mark_fail"(0)
    lt rx1924_pos, -1, rx1924_done
    eq rx1924_pos, -1, rx1924_fail
    jump $I10
  rx1924_done:
    rx1924_cur."!cursor_fail"()
    if_null rx1924_debug, debug_1425
    rx1924_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1425:
    .return (rx1924_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :subid("390_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    new $P1927, "ResizablePMCArray"
    push $P1927, "{"
    .return ($P1927)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("391_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    .const 'Sub' $P1932 = "392_1304516047.681" 
    capture_lex $P1932
    .local string rx1929_tgt
    .local int rx1929_pos
    .local int rx1929_off
    .local int rx1929_eos
    .local int rx1929_rep
    .local pmc rx1929_cur
    .local pmc rx1929_debug
    (rx1929_cur, rx1929_pos, rx1929_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1929_cur
    .local pmc match
    .lex "$/", match
    length rx1929_eos, rx1929_tgt
    gt rx1929_pos, rx1929_eos, rx1929_done
    set rx1929_off, 0
    lt rx1929_pos, 2, rx1929_start
    sub rx1929_off, rx1929_pos, 1
    substr rx1929_tgt, rx1929_tgt, rx1929_off
  rx1929_start:
    eq $I10, 1, rx1929_restart
    if_null rx1929_debug, debug_1426
    rx1929_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1426:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1930_done
    goto rxscan1930_scan
  rxscan1930_loop:
    (rx1929_pos) = rx1929_cur."from"()
    inc rx1929_pos
    rx1929_cur."!cursor_from"(rx1929_pos)
    ge rx1929_pos, rx1929_eos, rxscan1930_done
  rxscan1930_scan:
    set_addr $I10, rxscan1930_loop
    rx1929_cur."!mark_push"(0, rx1929_pos, $I10)
  rxscan1930_done:
.annotate 'line', 735
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1929_pos, rx1929_off
    substr $S10, rx1929_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1929_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1929_cur."!cursor_pos"(rx1929_pos)
    .const 'Sub' $P1932 = "392_1304516047.681" 
    capture_lex $P1932
    $P10 = rx1929_cur."before"($P1932)
    unless $P10, rx1929_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1929_cur."!cursor_pos"(rx1929_pos)
    $P10 = rx1929_cur."LANG"("MAIN", "variable")
    unless $P10, rx1929_fail
    rx1929_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1929_pos = $P10."pos"()
.annotate 'line', 734
  # rx pass
    rx1929_cur."!cursor_pass"(rx1929_pos, "metachar:sym<nqpvar>")
    if_null rx1929_debug, debug_1431
    rx1929_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1929_pos)
  debug_1431:
    .return (rx1929_cur)
  rx1929_restart:
.annotate 'line', 725
    if_null rx1929_debug, debug_1432
    rx1929_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1432:
  rx1929_fail:
    (rx1929_rep, rx1929_pos, $I10, $P10) = rx1929_cur."!mark_fail"(0)
    lt rx1929_pos, -1, rx1929_done
    eq rx1929_pos, -1, rx1929_fail
    jump $I10
  rx1929_done:
    rx1929_cur."!cursor_fail"()
    if_null rx1929_debug, debug_1433
    rx1929_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1433:
    .return (rx1929_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1931"  :anon :subid("392_1304516047.681") :method :outer("391_1304516047.681")
.annotate 'line', 735
    .local string rx1933_tgt
    .local int rx1933_pos
    .local int rx1933_off
    .local int rx1933_eos
    .local int rx1933_rep
    .local pmc rx1933_cur
    .local pmc rx1933_debug
    (rx1933_cur, rx1933_pos, rx1933_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1933_cur
    .local pmc match
    .lex "$/", match
    length rx1933_eos, rx1933_tgt
    gt rx1933_pos, rx1933_eos, rx1933_done
    set rx1933_off, 0
    lt rx1933_pos, 2, rx1933_start
    sub rx1933_off, rx1933_pos, 1
    substr rx1933_tgt, rx1933_tgt, rx1933_off
  rx1933_start:
    eq $I10, 1, rx1933_restart
    if_null rx1933_debug, debug_1427
    rx1933_cur."!cursor_debug"("START", "")
  debug_1427:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1934_done
    goto rxscan1934_scan
  rxscan1934_loop:
    (rx1933_pos) = rx1933_cur."from"()
    inc rx1933_pos
    rx1933_cur."!cursor_from"(rx1933_pos)
    ge rx1933_pos, rx1933_eos, rxscan1934_done
  rxscan1934_scan:
    set_addr $I10, rxscan1934_loop
    rx1933_cur."!mark_push"(0, rx1933_pos, $I10)
  rxscan1934_done:
  # rx charclass .
    ge rx1933_pos, rx1933_eos, rx1933_fail
    inc rx1933_pos
  # rx charclass w
    ge rx1933_pos, rx1933_eos, rx1933_fail
    sub $I10, rx1933_pos, rx1933_off
    is_cclass $I11, 8192, rx1933_tgt, $I10
    unless $I11, rx1933_fail
    inc rx1933_pos
  # rx pass
    rx1933_cur."!cursor_pass"(rx1933_pos, "")
    if_null rx1933_debug, debug_1428
    rx1933_cur."!cursor_debug"("PASS", "", " at pos=", rx1933_pos)
  debug_1428:
    .return (rx1933_cur)
  rx1933_restart:
    if_null rx1933_debug, debug_1429
    rx1933_cur."!cursor_debug"("NEXT", "")
  debug_1429:
  rx1933_fail:
    (rx1933_rep, rx1933_pos, $I10, $P10) = rx1933_cur."!mark_fail"(0)
    lt rx1933_pos, -1, rx1933_done
    eq rx1933_pos, -1, rx1933_fail
    jump $I10
  rx1933_done:
    rx1933_cur."!cursor_fail"()
    if_null rx1933_debug, debug_1430
    rx1933_cur."!cursor_debug"("FAIL", "")
  debug_1430:
    .return (rx1933_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :subid("393_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    new $P1936, "ResizablePMCArray"
    push $P1936, "$"
    push $P1936, "@"
    .return ($P1936)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("394_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    .local string rx1938_tgt
    .local int rx1938_pos
    .local int rx1938_off
    .local int rx1938_eos
    .local int rx1938_rep
    .local pmc rx1938_cur
    .local pmc rx1938_debug
    (rx1938_cur, rx1938_pos, rx1938_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1938_cur
    .local pmc match
    .lex "$/", match
    length rx1938_eos, rx1938_tgt
    gt rx1938_pos, rx1938_eos, rx1938_done
    set rx1938_off, 0
    lt rx1938_pos, 2, rx1938_start
    sub rx1938_off, rx1938_pos, 1
    substr rx1938_tgt, rx1938_tgt, rx1938_off
  rx1938_start:
    eq $I10, 1, rx1938_restart
    if_null rx1938_debug, debug_1434
    rx1938_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1939_done
    goto rxscan1939_scan
  rxscan1939_loop:
    (rx1938_pos) = rx1938_cur."from"()
    inc rx1938_pos
    rx1938_cur."!cursor_from"(rx1938_pos)
    ge rx1938_pos, rx1938_eos, rxscan1939_done
  rxscan1939_scan:
    set_addr $I10, rxscan1939_loop
    rx1938_cur."!mark_push"(0, rx1938_pos, $I10)
  rxscan1939_done:
.annotate 'line', 739
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1938_pos, rx1938_off
    substr $S10, rx1938_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1938_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1938_cur."!cursor_pos"(rx1938_pos)
    $P10 = rx1938_cur."codeblock"()
    unless $P10, rx1938_fail
    rx1938_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1938_pos = $P10."pos"()
.annotate 'line', 738
  # rx pass
    rx1938_cur."!cursor_pass"(rx1938_pos, "assertion:sym<{ }>")
    if_null rx1938_debug, debug_1435
    rx1938_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1938_pos)
  debug_1435:
    .return (rx1938_cur)
  rx1938_restart:
.annotate 'line', 725
    if_null rx1938_debug, debug_1436
    rx1938_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1436:
  rx1938_fail:
    (rx1938_rep, rx1938_pos, $I10, $P10) = rx1938_cur."!mark_fail"(0)
    lt rx1938_pos, -1, rx1938_done
    eq rx1938_pos, -1, rx1938_fail
    jump $I10
  rx1938_done:
    rx1938_cur."!cursor_fail"()
    if_null rx1938_debug, debug_1437
    rx1938_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1437:
    .return (rx1938_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :subid("395_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    new $P1941, "ResizablePMCArray"
    push $P1941, "{"
    .return ($P1941)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("396_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    .const 'Sub' $P1946 = "397_1304516047.681" 
    capture_lex $P1946
    .local string rx1943_tgt
    .local int rx1943_pos
    .local int rx1943_off
    .local int rx1943_eos
    .local int rx1943_rep
    .local pmc rx1943_cur
    .local pmc rx1943_debug
    (rx1943_cur, rx1943_pos, rx1943_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1943_cur
    .local pmc match
    .lex "$/", match
    length rx1943_eos, rx1943_tgt
    gt rx1943_pos, rx1943_eos, rx1943_done
    set rx1943_off, 0
    lt rx1943_pos, 2, rx1943_start
    sub rx1943_off, rx1943_pos, 1
    substr rx1943_tgt, rx1943_tgt, rx1943_off
  rx1943_start:
    eq $I10, 1, rx1943_restart
    if_null rx1943_debug, debug_1438
    rx1943_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1944_done
    goto rxscan1944_scan
  rxscan1944_loop:
    (rx1943_pos) = rx1943_cur."from"()
    inc rx1943_pos
    rx1943_cur."!cursor_from"(rx1943_pos)
    ge rx1943_pos, rx1943_eos, rxscan1944_done
  rxscan1944_scan:
    set_addr $I10, rxscan1944_loop
    rx1943_cur."!mark_push"(0, rx1943_pos, $I10)
  rxscan1944_done:
.annotate 'line', 743
  # rx subcapture "zw"
    set_addr $I10, rxcap_1949_fail
    rx1943_cur."!mark_push"(0, rx1943_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1943_pos, rx1943_eos, rx1943_fail
    sub $I10, rx1943_pos, rx1943_off
    substr $S10, rx1943_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1943_fail
    inc rx1943_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1943_cur."!cursor_pos"(rx1943_pos)
    .const 'Sub' $P1946 = "397_1304516047.681" 
    capture_lex $P1946
    $P10 = rx1943_cur."before"($P1946)
    unless $P10, rx1943_fail
    set_addr $I10, rxcap_1949_fail
    ($I12, $I11) = rx1943_cur."!mark_peek"($I10)
    rx1943_cur."!cursor_pos"($I11)
    ($P10) = rx1943_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1943_pos, "")
    rx1943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1949_done
  rxcap_1949_fail:
    goto rx1943_fail
  rxcap_1949_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1943_cur."!cursor_pos"(rx1943_pos)
    $P10 = rx1943_cur."codeblock"()
    unless $P10, rx1943_fail
    rx1943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1943_pos = $P10."pos"()
.annotate 'line', 742
  # rx pass
    rx1943_cur."!cursor_pass"(rx1943_pos, "assertion:sym<?{ }>")
    if_null rx1943_debug, debug_1443
    rx1943_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1943_pos)
  debug_1443:
    .return (rx1943_cur)
  rx1943_restart:
.annotate 'line', 725
    if_null rx1943_debug, debug_1444
    rx1943_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1444:
  rx1943_fail:
    (rx1943_rep, rx1943_pos, $I10, $P10) = rx1943_cur."!mark_fail"(0)
    lt rx1943_pos, -1, rx1943_done
    eq rx1943_pos, -1, rx1943_fail
    jump $I10
  rx1943_done:
    rx1943_cur."!cursor_fail"()
    if_null rx1943_debug, debug_1445
    rx1943_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1445:
    .return (rx1943_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1945"  :anon :subid("397_1304516047.681") :method :outer("396_1304516047.681")
.annotate 'line', 743
    .local string rx1947_tgt
    .local int rx1947_pos
    .local int rx1947_off
    .local int rx1947_eos
    .local int rx1947_rep
    .local pmc rx1947_cur
    .local pmc rx1947_debug
    (rx1947_cur, rx1947_pos, rx1947_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1947_cur
    .local pmc match
    .lex "$/", match
    length rx1947_eos, rx1947_tgt
    gt rx1947_pos, rx1947_eos, rx1947_done
    set rx1947_off, 0
    lt rx1947_pos, 2, rx1947_start
    sub rx1947_off, rx1947_pos, 1
    substr rx1947_tgt, rx1947_tgt, rx1947_off
  rx1947_start:
    eq $I10, 1, rx1947_restart
    if_null rx1947_debug, debug_1439
    rx1947_cur."!cursor_debug"("START", "")
  debug_1439:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1948_done
    goto rxscan1948_scan
  rxscan1948_loop:
    (rx1947_pos) = rx1947_cur."from"()
    inc rx1947_pos
    rx1947_cur."!cursor_from"(rx1947_pos)
    ge rx1947_pos, rx1947_eos, rxscan1948_done
  rxscan1948_scan:
    set_addr $I10, rxscan1948_loop
    rx1947_cur."!mark_push"(0, rx1947_pos, $I10)
  rxscan1948_done:
  # rx literal  "{"
    add $I11, rx1947_pos, 1
    gt $I11, rx1947_eos, rx1947_fail
    sub $I11, rx1947_pos, rx1947_off
    ord $I11, rx1947_tgt, $I11
    ne $I11, 123, rx1947_fail
    add rx1947_pos, 1
  # rx pass
    rx1947_cur."!cursor_pass"(rx1947_pos, "")
    if_null rx1947_debug, debug_1440
    rx1947_cur."!cursor_debug"("PASS", "", " at pos=", rx1947_pos)
  debug_1440:
    .return (rx1947_cur)
  rx1947_restart:
    if_null rx1947_debug, debug_1441
    rx1947_cur."!cursor_debug"("NEXT", "")
  debug_1441:
  rx1947_fail:
    (rx1947_rep, rx1947_pos, $I10, $P10) = rx1947_cur."!mark_fail"(0)
    lt rx1947_pos, -1, rx1947_done
    eq rx1947_pos, -1, rx1947_fail
    jump $I10
  rx1947_done:
    rx1947_cur."!cursor_fail"()
    if_null rx1947_debug, debug_1442
    rx1947_cur."!cursor_debug"("FAIL", "")
  debug_1442:
    .return (rx1947_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :subid("398_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    new $P1951, "ResizablePMCArray"
    push $P1951, "!"
    push $P1951, "?"
    .return ($P1951)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("399_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    .const 'Sub' $P1958 = "400_1304516047.681" 
    capture_lex $P1958
    .local string rx1953_tgt
    .local int rx1953_pos
    .local int rx1953_off
    .local int rx1953_eos
    .local int rx1953_rep
    .local pmc rx1953_cur
    .local pmc rx1953_debug
    (rx1953_cur, rx1953_pos, rx1953_tgt, $I10) = self."!cursor_start"()
    rx1953_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1953_cur
    .local pmc match
    .lex "$/", match
    length rx1953_eos, rx1953_tgt
    gt rx1953_pos, rx1953_eos, rx1953_done
    set rx1953_off, 0
    lt rx1953_pos, 2, rx1953_start
    sub rx1953_off, rx1953_pos, 1
    substr rx1953_tgt, rx1953_tgt, rx1953_off
  rx1953_start:
    eq $I10, 1, rx1953_restart
    if_null rx1953_debug, debug_1446
    rx1953_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1954_done
    goto rxscan1954_scan
  rxscan1954_loop:
    (rx1953_pos) = rx1953_cur."from"()
    inc rx1953_pos
    rx1953_cur."!cursor_from"(rx1953_pos)
    ge rx1953_pos, rx1953_eos, rxscan1954_done
  rxscan1954_scan:
    set_addr $I10, rxscan1954_loop
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
  rxscan1954_done:
.annotate 'line', 747
  # rx subrule "identifier" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."identifier"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1953_pos = $P10."pos"()
.annotate 'line', 754
  # rx rxquantr1955 ** 0..1
    set_addr $I10, rxquantr1955_done
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
  rxquantr1955_loop:
  alt1956_0:
.annotate 'line', 748
    set_addr $I10, alt1956_1
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
.annotate 'line', 749
  # rx subrule "before" subtype=zerowidth negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    .const 'Sub' $P1958 = "400_1304516047.681" 
    capture_lex $P1958
    $P10 = rx1953_cur."before"($P1958)
    unless $P10, rx1953_fail
    goto alt1956_end
  alt1956_1:
    set_addr $I10, alt1956_2
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
.annotate 'line', 750
  # rx literal  "="
    add $I11, rx1953_pos, 1
    gt $I11, rx1953_eos, rx1953_fail
    sub $I11, rx1953_pos, rx1953_off
    ord $I11, rx1953_tgt, $I11
    ne $I11, 61, rx1953_fail
    add rx1953_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."assertion"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1953_pos = $P10."pos"()
    goto alt1956_end
  alt1956_2:
    set_addr $I10, alt1956_3
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
.annotate 'line', 751
  # rx literal  ":"
    add $I11, rx1953_pos, 1
    gt $I11, rx1953_eos, rx1953_fail
    sub $I11, rx1953_pos, rx1953_off
    ord $I11, rx1953_tgt, $I11
    ne $I11, 58, rx1953_fail
    add rx1953_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."arglist"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1953_pos = $P10."pos"()
    goto alt1956_end
  alt1956_3:
    set_addr $I10, alt1956_4
    rx1953_cur."!mark_push"(0, rx1953_pos, $I10)
.annotate 'line', 752
  # rx literal  "("
    add $I11, rx1953_pos, 1
    gt $I11, rx1953_eos, rx1953_fail
    sub $I11, rx1953_pos, rx1953_off
    ord $I11, rx1953_tgt, $I11
    ne $I11, 40, rx1953_fail
    add rx1953_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1953_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1953_pos, 1
    gt $I11, rx1953_eos, rx1953_fail
    sub $I11, rx1953_pos, rx1953_off
    ord $I11, rx1953_tgt, $I11
    ne $I11, 41, rx1953_fail
    add rx1953_pos, 1
    goto alt1956_end
  alt1956_4:
.annotate 'line', 753
  # rx subrule "normspace" subtype=method negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."normspace"()
    unless $P10, rx1953_fail
    rx1953_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1953_cur."!cursor_pos"(rx1953_pos)
    $P10 = rx1953_cur."nibbler"()
    unless $P10, rx1953_fail
    rx1953_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1953_pos = $P10."pos"()
  alt1956_end:
.annotate 'line', 754
    set_addr $I10, rxquantr1955_done
    (rx1953_rep) = rx1953_cur."!mark_commit"($I10)
  rxquantr1955_done:
.annotate 'line', 746
  # rx pass
    rx1953_cur."!cursor_pass"(rx1953_pos, "assertion:sym<name>")
    if_null rx1953_debug, debug_1451
    rx1953_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1953_pos)
  debug_1451:
    .return (rx1953_cur)
  rx1953_restart:
.annotate 'line', 725
    if_null rx1953_debug, debug_1452
    rx1953_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1452:
  rx1953_fail:
    (rx1953_rep, rx1953_pos, $I10, $P10) = rx1953_cur."!mark_fail"(0)
    lt rx1953_pos, -1, rx1953_done
    eq rx1953_pos, -1, rx1953_fail
    jump $I10
  rx1953_done:
    rx1953_cur."!cursor_fail"()
    if_null rx1953_debug, debug_1453
    rx1953_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1453:
    .return (rx1953_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1957"  :anon :subid("400_1304516047.681") :method :outer("399_1304516047.681")
.annotate 'line', 749
    .local string rx1959_tgt
    .local int rx1959_pos
    .local int rx1959_off
    .local int rx1959_eos
    .local int rx1959_rep
    .local pmc rx1959_cur
    .local pmc rx1959_debug
    (rx1959_cur, rx1959_pos, rx1959_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1959_cur
    .local pmc match
    .lex "$/", match
    length rx1959_eos, rx1959_tgt
    gt rx1959_pos, rx1959_eos, rx1959_done
    set rx1959_off, 0
    lt rx1959_pos, 2, rx1959_start
    sub rx1959_off, rx1959_pos, 1
    substr rx1959_tgt, rx1959_tgt, rx1959_off
  rx1959_start:
    eq $I10, 1, rx1959_restart
    if_null rx1959_debug, debug_1447
    rx1959_cur."!cursor_debug"("START", "")
  debug_1447:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1960_done
    goto rxscan1960_scan
  rxscan1960_loop:
    (rx1959_pos) = rx1959_cur."from"()
    inc rx1959_pos
    rx1959_cur."!cursor_from"(rx1959_pos)
    ge rx1959_pos, rx1959_eos, rxscan1960_done
  rxscan1960_scan:
    set_addr $I10, rxscan1960_loop
    rx1959_cur."!mark_push"(0, rx1959_pos, $I10)
  rxscan1960_done:
  # rx literal  ">"
    add $I11, rx1959_pos, 1
    gt $I11, rx1959_eos, rx1959_fail
    sub $I11, rx1959_pos, rx1959_off
    ord $I11, rx1959_tgt, $I11
    ne $I11, 62, rx1959_fail
    add rx1959_pos, 1
  # rx pass
    rx1959_cur."!cursor_pass"(rx1959_pos, "")
    if_null rx1959_debug, debug_1448
    rx1959_cur."!cursor_debug"("PASS", "", " at pos=", rx1959_pos)
  debug_1448:
    .return (rx1959_cur)
  rx1959_restart:
    if_null rx1959_debug, debug_1449
    rx1959_cur."!cursor_debug"("NEXT", "")
  debug_1449:
  rx1959_fail:
    (rx1959_rep, rx1959_pos, $I10, $P10) = rx1959_cur."!mark_fail"(0)
    lt rx1959_pos, -1, rx1959_done
    eq rx1959_pos, -1, rx1959_fail
    jump $I10
  rx1959_done:
    rx1959_cur."!cursor_fail"()
    if_null rx1959_debug, debug_1450
    rx1959_cur."!cursor_debug"("FAIL", "")
  debug_1450:
    .return (rx1959_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :subid("401_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    $P1962 = self."!PREFIX__!subrule"("identifier", "")
    new $P1963, "ResizablePMCArray"
    push $P1963, $P1962
    .return ($P1963)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("402_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    .local string rx1965_tgt
    .local int rx1965_pos
    .local int rx1965_off
    .local int rx1965_eos
    .local int rx1965_rep
    .local pmc rx1965_cur
    .local pmc rx1965_debug
    (rx1965_cur, rx1965_pos, rx1965_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1965_cur
    .local pmc match
    .lex "$/", match
    length rx1965_eos, rx1965_tgt
    gt rx1965_pos, rx1965_eos, rx1965_done
    set rx1965_off, 0
    lt rx1965_pos, 2, rx1965_start
    sub rx1965_off, rx1965_pos, 1
    substr rx1965_tgt, rx1965_tgt, rx1965_off
  rx1965_start:
    eq $I10, 1, rx1965_restart
    if_null rx1965_debug, debug_1454
    rx1965_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1966_done
    goto rxscan1966_scan
  rxscan1966_loop:
    (rx1965_pos) = rx1965_cur."from"()
    inc rx1965_pos
    rx1965_cur."!cursor_from"(rx1965_pos)
    ge rx1965_pos, rx1965_eos, rxscan1966_done
  rxscan1966_scan:
    set_addr $I10, rxscan1966_loop
    rx1965_cur."!mark_push"(0, rx1965_pos, $I10)
  rxscan1966_done:
.annotate 'line', 758
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1965_pos, rx1965_off
    substr $S10, rx1965_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1965_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1965_cur."!cursor_pos"(rx1965_pos)
    $P10 = rx1965_cur."LANG"("MAIN", "variable")
    unless $P10, rx1965_fail
    rx1965_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1965_pos = $P10."pos"()
.annotate 'line', 757
  # rx pass
    rx1965_cur."!cursor_pass"(rx1965_pos, "assertion:sym<var>")
    if_null rx1965_debug, debug_1455
    rx1965_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1965_pos)
  debug_1455:
    .return (rx1965_cur)
  rx1965_restart:
.annotate 'line', 725
    if_null rx1965_debug, debug_1456
    rx1965_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1456:
  rx1965_fail:
    (rx1965_rep, rx1965_pos, $I10, $P10) = rx1965_cur."!mark_fail"(0)
    lt rx1965_pos, -1, rx1965_done
    eq rx1965_pos, -1, rx1965_fail
    jump $I10
  rx1965_done:
    rx1965_cur."!cursor_fail"()
    if_null rx1965_debug, debug_1457
    rx1965_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1457:
    .return (rx1965_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :subid("403_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    new $P1968, "ResizablePMCArray"
    push $P1968, "$"
    push $P1968, "@"
    .return ($P1968)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("404_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    .local string rx1970_tgt
    .local int rx1970_pos
    .local int rx1970_off
    .local int rx1970_eos
    .local int rx1970_rep
    .local pmc rx1970_cur
    .local pmc rx1970_debug
    (rx1970_cur, rx1970_pos, rx1970_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1970_cur
    .local pmc match
    .lex "$/", match
    length rx1970_eos, rx1970_tgt
    gt rx1970_pos, rx1970_eos, rx1970_done
    set rx1970_off, 0
    lt rx1970_pos, 2, rx1970_start
    sub rx1970_off, rx1970_pos, 1
    substr rx1970_tgt, rx1970_tgt, rx1970_off
  rx1970_start:
    eq $I10, 1, rx1970_restart
    if_null rx1970_debug, debug_1458
    rx1970_cur."!cursor_debug"("START", "codeblock")
  debug_1458:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1971_done
    goto rxscan1971_scan
  rxscan1971_loop:
    (rx1970_pos) = rx1970_cur."from"()
    inc rx1970_pos
    rx1970_cur."!cursor_from"(rx1970_pos)
    ge rx1970_pos, rx1970_eos, rxscan1971_done
  rxscan1971_scan:
    set_addr $I10, rxscan1971_loop
    rx1970_cur."!mark_push"(0, rx1970_pos, $I10)
  rxscan1971_done:
.annotate 'line', 762
  # rx subrule "LANG" subtype=capture negate=
    rx1970_cur."!cursor_pos"(rx1970_pos)
    $P10 = rx1970_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1970_fail
    rx1970_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1970_pos = $P10."pos"()
.annotate 'line', 761
  # rx pass
    rx1970_cur."!cursor_pass"(rx1970_pos, "codeblock")
    if_null rx1970_debug, debug_1459
    rx1970_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1970_pos)
  debug_1459:
    .return (rx1970_cur)
  rx1970_restart:
.annotate 'line', 725
    if_null rx1970_debug, debug_1460
    rx1970_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1460:
  rx1970_fail:
    (rx1970_rep, rx1970_pos, $I10, $P10) = rx1970_cur."!mark_fail"(0)
    lt rx1970_pos, -1, rx1970_done
    eq rx1970_pos, -1, rx1970_fail
    jump $I10
  rx1970_done:
    rx1970_cur."!cursor_fail"()
    if_null rx1970_debug, debug_1461
    rx1970_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1461:
    .return (rx1970_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :subid("405_1304516047.681") :method :outer("385_1304516047.681")
.annotate 'line', 725
    $P1973 = self."!PREFIX__!subrule"("LANG", "")
    new $P1974, "ResizablePMCArray"
    push $P1974, $P1973
    .return ($P1974)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1975"  :subid("406_1304516047.681") :outer("10_1304516047.681")
.annotate 'line', 768
    .const 'Sub' $P6009 = "579_1304516047.681" 
    capture_lex $P6009
    .const 'Sub' $P5994 = "578_1304516047.681" 
    capture_lex $P5994
    .const 'Sub' $P5989 = "577_1304516047.681" 
    capture_lex $P5989
    .const 'Sub' $P5984 = "576_1304516047.681" 
    capture_lex $P5984
    .const 'Sub' $P5979 = "575_1304516047.681" 
    capture_lex $P5979
    .const 'Sub' $P5962 = "574_1304516047.681" 
    capture_lex $P5962
    .const 'Sub' $P5951 = "573_1304516047.681" 
    capture_lex $P5951
    .const 'Sub' $P5940 = "572_1304516047.681" 
    capture_lex $P5940
    .const 'Sub' $P5932 = "571_1304516047.681" 
    capture_lex $P5932
    .const 'Sub' $P5927 = "570_1304516047.681" 
    capture_lex $P5927
    .const 'Sub' $P5912 = "569_1304516047.681" 
    capture_lex $P5912
    .const 'Sub' $P5904 = "568_1304516047.681" 
    capture_lex $P5904
    .const 'Sub' $P5846 = "567_1304516047.681" 
    capture_lex $P5846
    .const 'Sub' $P5831 = "566_1304516047.681" 
    capture_lex $P5831
    .const 'Sub' $P5823 = "565_1304516047.681" 
    capture_lex $P5823
    .const 'Sub' $P5815 = "564_1304516047.681" 
    capture_lex $P5815
    .const 'Sub' $P5807 = "563_1304516047.681" 
    capture_lex $P5807
    .const 'Sub' $P5799 = "562_1304516047.681" 
    capture_lex $P5799
    .const 'Sub' $P5791 = "561_1304516047.681" 
    capture_lex $P5791
    .const 'Sub' $P5762 = "560_1304516047.681" 
    capture_lex $P5762
    .const 'Sub' $P5747 = "559_1304516047.681" 
    capture_lex $P5747
    .const 'Sub' $P5739 = "558_1304516047.681" 
    capture_lex $P5739
    .const 'Sub' $P5725 = "557_1304516047.681" 
    capture_lex $P5725
    .const 'Sub' $P5711 = "556_1304516047.681" 
    capture_lex $P5711
    .const 'Sub' $P5697 = "555_1304516047.681" 
    capture_lex $P5697
    .const 'Sub' $P5689 = "554_1304516047.681" 
    capture_lex $P5689
    .const 'Sub' $P5659 = "553_1304516047.681" 
    capture_lex $P5659
    .const 'Sub' $P5621 = "551_1304516047.681" 
    capture_lex $P5621
    .const 'Sub' $P5613 = "550_1304516047.681" 
    capture_lex $P5613
    .const 'Sub' $P5605 = "549_1304516047.681" 
    capture_lex $P5605
    .const 'Sub' $P5574 = "548_1304516047.681" 
    capture_lex $P5574
    .const 'Sub' $P5555 = "547_1304516047.681" 
    capture_lex $P5555
    .const 'Sub' $P5547 = "546_1304516047.681" 
    capture_lex $P5547
    .const 'Sub' $P5539 = "545_1304516047.681" 
    capture_lex $P5539
    .const 'Sub' $P5431 = "542_1304516047.681" 
    capture_lex $P5431
    .const 'Sub' $P5423 = "541_1304516047.681" 
    capture_lex $P5423
    .const 'Sub' $P5413 = "540_1304516047.681" 
    capture_lex $P5413
    .const 'Sub' $P5379 = "539_1304516047.681" 
    capture_lex $P5379
    .const 'Sub' $P5337 = "537_1304516047.681" 
    capture_lex $P5337
    .const 'Sub' $P5323 = "536_1304516047.681" 
    capture_lex $P5323
    .const 'Sub' $P5313 = "535_1304516047.681" 
    capture_lex $P5313
    .const 'Sub' $P5261 = "534_1304516047.681" 
    capture_lex $P5261
    .const 'Sub' $P5032 = "529_1304516047.681" 
    capture_lex $P5032
    .const 'Sub' $P4959 = "526_1304516047.681" 
    capture_lex $P4959
    .const 'Sub' $P4951 = "525_1304516047.681" 
    capture_lex $P4951
    .const 'Sub' $P4907 = "523_1304516047.681" 
    capture_lex $P4907
    .const 'Sub' $P4892 = "522_1304516047.681" 
    capture_lex $P4892
    .const 'Sub' $P4869 = "521_1304516047.681" 
    capture_lex $P4869
    .const 'Sub' $P4766 = "520_1304516047.681" 
    capture_lex $P4766
    .const 'Sub' $P4712 = "517_1304516047.681" 
    capture_lex $P4712
    .const 'Sub' $P4583 = "514_1304516047.681" 
    capture_lex $P4583
    .const 'Sub' $P4256 = "507_1304516047.681" 
    capture_lex $P4256
    .const 'Sub' $P4248 = "506_1304516047.681" 
    capture_lex $P4248
    .const 'Sub' $P4240 = "505_1304516047.681" 
    capture_lex $P4240
    .const 'Sub' $P4115 = "503_1304516047.681" 
    capture_lex $P4115
    .const 'Sub' $P4107 = "502_1304516047.681" 
    capture_lex $P4107
    .const 'Sub' $P4092 = "501_1304516047.681" 
    capture_lex $P4092
    .const 'Sub' $P4077 = "500_1304516047.681" 
    capture_lex $P4077
    .const 'Sub' $P4062 = "499_1304516047.681" 
    capture_lex $P4062
    .const 'Sub' $P4040 = "498_1304516047.681" 
    capture_lex $P4040
    .const 'Sub' $P4032 = "497_1304516047.681" 
    capture_lex $P4032
    .const 'Sub' $P4024 = "496_1304516047.681" 
    capture_lex $P4024
    .const 'Sub' $P4016 = "495_1304516047.681" 
    capture_lex $P4016
    .const 'Sub' $P3782 = "489_1304516047.681" 
    capture_lex $P3782
    .const 'Sub' $P3774 = "488_1304516047.681" 
    capture_lex $P3774
    .const 'Sub' $P3766 = "487_1304516047.681" 
    capture_lex $P3766
    .const 'Sub' $P3758 = "486_1304516047.681" 
    capture_lex $P3758
    .const 'Sub' $P3750 = "485_1304516047.681" 
    capture_lex $P3750
    .const 'Sub' $P3742 = "484_1304516047.681" 
    capture_lex $P3742
    .const 'Sub' $P3734 = "483_1304516047.681" 
    capture_lex $P3734
    .const 'Sub' $P3531 = "477_1304516047.681" 
    capture_lex $P3531
    .const 'Sub' $P3504 = "476_1304516047.681" 
    capture_lex $P3504
    .const 'Sub' $P3490 = "475_1304516047.681" 
    capture_lex $P3490
    .const 'Sub' $P3482 = "474_1304516047.681" 
    capture_lex $P3482
    .const 'Sub' $P3474 = "473_1304516047.681" 
    capture_lex $P3474
    .const 'Sub' $P3466 = "472_1304516047.681" 
    capture_lex $P3466
    .const 'Sub' $P3458 = "471_1304516047.681" 
    capture_lex $P3458
    .const 'Sub' $P3450 = "470_1304516047.681" 
    capture_lex $P3450
    .const 'Sub' $P3442 = "469_1304516047.681" 
    capture_lex $P3442
    .const 'Sub' $P3434 = "468_1304516047.681" 
    capture_lex $P3434
    .const 'Sub' $P3426 = "467_1304516047.681" 
    capture_lex $P3426
    .const 'Sub' $P3418 = "466_1304516047.681" 
    capture_lex $P3418
    .const 'Sub' $P3410 = "465_1304516047.681" 
    capture_lex $P3410
    .const 'Sub' $P3402 = "464_1304516047.681" 
    capture_lex $P3402
    .const 'Sub' $P3394 = "463_1304516047.681" 
    capture_lex $P3394
    .const 'Sub' $P3386 = "462_1304516047.681" 
    capture_lex $P3386
    .const 'Sub' $P3370 = "461_1304516047.681" 
    capture_lex $P3370
    .const 'Sub' $P3316 = "460_1304516047.681" 
    capture_lex $P3316
    .const 'Sub' $P3299 = "459_1304516047.681" 
    capture_lex $P3299
    .const 'Sub' $P3275 = "458_1304516047.681" 
    capture_lex $P3275
    .const 'Sub' $P3252 = "457_1304516047.681" 
    capture_lex $P3252
    .const 'Sub' $P3225 = "456_1304516047.681" 
    capture_lex $P3225
    .const 'Sub' $P3188 = "455_1304516047.681" 
    capture_lex $P3188
    .const 'Sub' $P3173 = "454_1304516047.681" 
    capture_lex $P3173
    .const 'Sub' $P3161 = "453_1304516047.681" 
    capture_lex $P3161
    .const 'Sub' $P3110 = "451_1304516047.681" 
    capture_lex $P3110
    .const 'Sub' $P3085 = "450_1304516047.681" 
    capture_lex $P3085
    .const 'Sub' $P3078 = "449_1304516047.681" 
    capture_lex $P3078
    .const 'Sub' $P3036 = "448_1304516047.681" 
    capture_lex $P3036
    .const 'Sub' $P2986 = "446_1304516047.681" 
    capture_lex $P2986
    .const 'Sub' $P2969 = "445_1304516047.681" 
    capture_lex $P2969
    .const 'Sub' $P2930 = "443_1304516047.681" 
    capture_lex $P2930
    .const 'Sub' $P2922 = "442_1304516047.681" 
    capture_lex $P2922
    .const 'Sub' $P2914 = "441_1304516047.681" 
    capture_lex $P2914
    .const 'Sub' $P2897 = "440_1304516047.681" 
    capture_lex $P2897
    .const 'Sub' $P2801 = "438_1304516047.681" 
    capture_lex $P2801
    .const 'Sub' $P2757 = "436_1304516047.681" 
    capture_lex $P2757
    .const 'Sub' $P2608 = "435_1304516047.681" 
    capture_lex $P2608
    .const 'Sub' $P2577 = "434_1304516047.681" 
    capture_lex $P2577
    .const 'Sub' $P2569 = "433_1304516047.681" 
    capture_lex $P2569
    .const 'Sub' $P2440 = "427_1304516047.681" 
    capture_lex $P2440
    .const 'Sub' $P2405 = "425_1304516047.681" 
    capture_lex $P2405
    .const 'Sub' $P2400 = "424_1304516047.681" 
    capture_lex $P2400
    .const 'Sub' $P2395 = "423_1304516047.681" 
    capture_lex $P2395
    .const 'Sub' $P2282 = "420_1304516047.681" 
    capture_lex $P2282
    .const 'Sub' $P2264 = "419_1304516047.681" 
    capture_lex $P2264
    .const 'Sub' $P2189 = "417_1304516047.681" 
    capture_lex $P2189
    .const 'Sub' $P2174 = "416_1304516047.681" 
    capture_lex $P2174
    .const 'Sub' $P2087 = "415_1304516047.681" 
    capture_lex $P2087
    .const 'Sub' $P2061 = "413_1304516047.681" 
    capture_lex $P2061
    .const 'Sub' $P2045 = "412_1304516047.681" 
    capture_lex $P2045
    .const 'Sub' $P2021 = "411_1304516047.681" 
    capture_lex $P2021
    .const 'Sub' $P1985 = "408_1304516047.681" 
    capture_lex $P1985
    .const 'Sub' $P1977 = "407_1304516047.681" 
    capture_lex $P1977
.annotate 'line', 772
    .const 'Sub' $P1977 = "407_1304516047.681" 
    newclosure $P1984, $P1977
    .lex "xblock_immediate", $P1984
.annotate 'line', 777
    .const 'Sub' $P1985 = "408_1304516047.681" 
    newclosure $P2020, $P1985
    .lex "block_immediate", $P2020
.annotate 'line', 787
    .const 'Sub' $P2021 = "411_1304516047.681" 
    newclosure $P2044, $P2021
    .lex "vivitype", $P2044
.annotate 'line', 806
    .const 'Sub' $P2045 = "412_1304516047.681" 
    newclosure $P2060, $P2045
    .lex "colonpair_str", $P2060
.annotate 'line', 979
    .const 'Sub' $P2061 = "413_1304516047.681" 
    newclosure $P2086, $P2061
    .lex "import_HOW_exports", $P2086
.annotate 'line', 1084
    .const 'Sub' $P2087 = "415_1304516047.681" 
    newclosure $P2173, $P2087
    .lex "push_block_handler", $P2173
.annotate 'line', 1590
    .const 'Sub' $P2174 = "416_1304516047.681" 
    newclosure $P2188, $P2174
    .lex "only_star_block", $P2188
.annotate 'line', 1599
    .const 'Sub' $P2189 = "417_1304516047.681" 
    newclosure $P2263, $P2189
    .lex "attach_multi_signature", $P2263
.annotate 'line', 2051
    .const 'Sub' $P2264 = "419_1304516047.681" 
    newclosure $P2281, $P2264
    .lex "control", $P2281
.annotate 'line', 2070
    .const 'Sub' $P2282 = "420_1304516047.681" 
    newclosure $P2394, $P2282
    .lex "lexical_package_lookup", $P2394
.annotate 'line', 2119
    .const 'Sub' $P2395 = "423_1304516047.681" 
    newclosure $P2399, $P2395
    .lex "is_lexical", $P2399
.annotate 'line', 2125
    .const 'Sub' $P2400 = "424_1304516047.681" 
    newclosure $P2404, $P2400
    .lex "is_package", $P2404
.annotate 'line', 2131
    .const 'Sub' $P2405 = "425_1304516047.681" 
    newclosure $P2439, $P2405
    .lex "is_scope", $P2439
.annotate 'line', 2154
    .const 'Sub' $P2440 = "427_1304516047.681" 
    newclosure $P2560, $P2440
    .lex "find_sym", $P2560
.annotate 'line', 768
    .lex "$?PACKAGE", $P2561
    .lex "$?CLASS", $P2562
.annotate 'line', 770
    new $P2563, "ResizablePMCArray"
    find_lex $P2564, "$?PACKAGE"
    get_who $P2565, $P2564
    set $P2565["@BLOCK"], $P2563
    find_lex $P2566, "xblock_immediate"
    find_lex $P2567, "block_immediate"
    find_lex $P2568, "vivitype"
.annotate 'line', 798
    find_lex $P2607, "colonpair_str"
.annotate 'line', 962
    find_lex $P3035, "import_HOW_exports"
.annotate 'line', 1077
    find_lex $P3298, "push_block_handler"
.annotate 'line', 1537
    find_lex $P4710, "only_star_block"
    find_lex $P4711, "attach_multi_signature"
.annotate 'line', 2042
    find_lex $P5978, "control"
.annotate 'line', 2064
    find_lex $P6005, "lexical_package_lookup"
    find_lex $P6006, "is_lexical"
    find_lex $P6007, "is_package"
    find_lex $P6008, "is_scope"
.annotate 'line', 2142
    find_lex $P6028, "find_sym"
.annotate 'line', 768
    .return ($P6028)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("407_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_1978
.annotate 'line', 772
    .lex "$xblock", param_1978
.annotate 'line', 773
    find_lex $P1979, "$xblock"
    unless_null $P1979, vivify_1462
    $P1979 = root_new ['parrot';'ResizablePMCArray']
  vivify_1462:
    set $P1980, $P1979[1]
    unless_null $P1980, vivify_1463
    new $P1980, "Undef"
  vivify_1463:
    $P1981 = "block_immediate"($P1980)
    find_lex $P1982, "$xblock"
    unless_null $P1982, vivify_1464
    $P1982 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P1982
  vivify_1464:
    set $P1982[1], $P1981
    find_lex $P1983, "$xblock"
    unless_null $P1983, vivify_1465
    new $P1983, "Undef"
  vivify_1465:
.annotate 'line', 772
    .return ($P1983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("408_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_1986
.annotate 'line', 777
    .const 'Sub' $P1996 = "409_1304516047.681" 
    capture_lex $P1996
    .lex "$block", param_1986
.annotate 'line', 778
    find_lex $P1987, "$block"
    unless_null $P1987, vivify_1466
    new $P1987, "Undef"
  vivify_1466:
    $P1987."blocktype"("immediate")
.annotate 'line', 779
    find_lex $P1991, "$block"
    unless_null $P1991, vivify_1467
    new $P1991, "Undef"
  vivify_1467:
    $P1992 = $P1991."symtable"()
    unless $P1992, unless_1990
    set $P1989, $P1992
    goto unless_1990_end
  unless_1990:
    find_lex $P1993, "$block"
    unless_null $P1993, vivify_1468
    new $P1993, "Undef"
  vivify_1468:
    $P1994 = $P1993."handlers"()
    set $P1989, $P1994
  unless_1990_end:
    if $P1989, unless_1988_end
    .const 'Sub' $P1996 = "409_1304516047.681" 
    capture_lex $P1996
    $P1996()
  unless_1988_end:
    find_lex $P2019, "$block"
    unless_null $P2019, vivify_1475
    new $P2019, "Undef"
  vivify_1475:
.annotate 'line', 777
    .return ($P2019)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1995"  :anon :subid("409_1304516047.681") :outer("408_1304516047.681")
.annotate 'line', 779
    .const 'Sub' $P2010 = "410_1304516047.681" 
    capture_lex $P2010
.annotate 'line', 780
    new $P1997, "Undef"
    .lex "$stmts", $P1997
    get_hll_global $P1998, "GLOBAL"
    nqp_get_package_through_who $P1999, $P1998, "PAST"
    get_who $P2000, $P1999
    set $P2001, $P2000["Stmts"]
    find_lex $P2002, "$block"
    unless_null $P2002, vivify_1469
    new $P2002, "Undef"
  vivify_1469:
    $P2003 = $P2001."new"($P2002 :named("node"))
    store_lex "$stmts", $P2003
.annotate 'line', 781
    find_lex $P2005, "$block"
    unless_null $P2005, vivify_1470
    new $P2005, "Undef"
  vivify_1470:
    $P2006 = $P2005."list"()
    defined $I2007, $P2006
    unless $I2007, for_undef_1471
    iter $P2004, $P2006
    new $P2016, 'ExceptionHandler'
    set_label $P2016, loop2015_handler
    $P2016."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2016
  loop2015_test:
    unless $P2004, loop2015_done
    shift $P2008, $P2004
  loop2015_redo:
    .const 'Sub' $P2010 = "410_1304516047.681" 
    capture_lex $P2010
    $P2010($P2008)
  loop2015_next:
    goto loop2015_test
  loop2015_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2017, exception, 'type'
    eq $P2017, .CONTROL_LOOP_NEXT, loop2015_next
    eq $P2017, .CONTROL_LOOP_REDO, loop2015_redo
  loop2015_done:
    pop_eh 
  for_undef_1471:
.annotate 'line', 782
    find_lex $P2018, "$stmts"
    unless_null $P2018, vivify_1474
    new $P2018, "Undef"
  vivify_1474:
    store_lex "$block", $P2018
.annotate 'line', 779
    .return ($P2018)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2009"  :anon :subid("410_1304516047.681") :outer("409_1304516047.681")
    .param pmc param_2011
.annotate 'line', 781
    .lex "$_", param_2011
    find_lex $P2012, "$stmts"
    unless_null $P2012, vivify_1472
    new $P2012, "Undef"
  vivify_1472:
    find_lex $P2013, "$_"
    unless_null $P2013, vivify_1473
    new $P2013, "Undef"
  vivify_1473:
    $P2014 = $P2012."push"($P2013)
    .return ($P2014)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("411_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2022
.annotate 'line', 787
    .lex "$sigil", param_2022
.annotate 'line', 788
    find_lex $P2025, "$sigil"
    unless_null $P2025, vivify_1476
    new $P2025, "Undef"
  vivify_1476:
    set $S2026, $P2025
    iseq $I2027, $S2026, "%"
    if $I2027, if_2024
.annotate 'line', 790
    find_lex $P2035, "$sigil"
    unless_null $P2035, vivify_1477
    new $P2035, "Undef"
  vivify_1477:
    set $S2036, $P2035
    iseq $I2037, $S2036, "@"
    if $I2037, if_2034
    new $P2043, "String"
    assign $P2043, "Undef"
    set $P2033, $P2043
    goto if_2034_end
  if_2034:
.annotate 'line', 791
    get_hll_global $P2038, "GLOBAL"
    nqp_get_package_through_who $P2039, $P2038, "PAST"
    get_who $P2040, $P2039
    set $P2041, $P2040["Op"]
    $P2042 = $P2041."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2033, $P2042
  if_2034_end:
    set $P2023, $P2033
.annotate 'line', 788
    goto if_2024_end
  if_2024:
.annotate 'line', 789
    get_hll_global $P2028, "GLOBAL"
    nqp_get_package_through_who $P2029, $P2028, "PAST"
    get_who $P2030, $P2029
    set $P2031, $P2030["Op"]
    $P2032 = $P2031."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2023, $P2032
  if_2024_end:
.annotate 'line', 787
    .return ($P2023)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("412_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2046
.annotate 'line', 806
    .lex "$ast", param_2046
.annotate 'line', 807
    get_hll_global $P2049, "GLOBAL"
    nqp_get_package_through_who $P2050, $P2049, "PAST"
    get_who $P2051, $P2050
    set $P2052, $P2051["Op"]
    find_lex $P2053, "$ast"
    unless_null $P2053, vivify_1478
    new $P2053, "Undef"
  vivify_1478:
    $P2054 = $P2052."ACCEPTS"($P2053)
    if $P2054, if_2048
.annotate 'line', 809
    find_lex $P2058, "$ast"
    unless_null $P2058, vivify_1479
    new $P2058, "Undef"
  vivify_1479:
    $P2059 = $P2058."value"()
    set $P2047, $P2059
.annotate 'line', 807
    goto if_2048_end
  if_2048:
.annotate 'line', 808
    find_lex $P2055, "$ast"
    unless_null $P2055, vivify_1480
    new $P2055, "Undef"
  vivify_1480:
    $P2056 = $P2055."list"()
    join $S2057, " ", $P2056
    new $P2047, 'String'
    set $P2047, $S2057
  if_2048_end:
.annotate 'line', 806
    .return ($P2047)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "import_HOW_exports"  :subid("413_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2062
.annotate 'line', 979
    .const 'Sub' $P2074 = "414_1304516047.681" 
    capture_lex $P2074
    .lex "$UNIT", param_2062
.annotate 'line', 981
    find_lex $P2065, "$UNIT"
    unless_null $P2065, vivify_1481
    new $P2065, "Undef"
  vivify_1481:
    exists $I2066, $P2065["EXPORTHOW"]
    if $I2066, if_2064
    new $P2063, 'Integer'
    set $P2063, $I2066
    goto if_2064_end
  if_2064:
.annotate 'line', 982
    find_lex $P2068, "$UNIT"
    unless_null $P2068, vivify_1482
    $P2068 = root_new ['parrot';'Hash']
  vivify_1482:
    set $P2069, $P2068["EXPORTHOW"]
    unless_null $P2069, vivify_1483
    new $P2069, "Undef"
  vivify_1483:
    get_who $P2070, $P2069
    defined $I2071, $P2070
    unless $I2071, for_undef_1484
    iter $P2067, $P2070
    new $P2084, 'ExceptionHandler'
    set_label $P2084, loop2083_handler
    $P2084."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2084
  loop2083_test:
    unless $P2067, loop2083_done
    shift $P2072, $P2067
  loop2083_redo:
    .const 'Sub' $P2074 = "414_1304516047.681" 
    capture_lex $P2074
    $P2074($P2072)
  loop2083_next:
    goto loop2083_test
  loop2083_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2085, exception, 'type'
    eq $P2085, .CONTROL_LOOP_NEXT, loop2083_next
    eq $P2085, .CONTROL_LOOP_REDO, loop2083_redo
  loop2083_done:
    pop_eh 
  for_undef_1484:
.annotate 'line', 981
    set $P2063, $P2067
  if_2064_end:
.annotate 'line', 979
    .return ($P2063)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2073"  :anon :subid("414_1304516047.681") :outer("413_1304516047.681")
    .param pmc param_2075
.annotate 'line', 982
    .lex "$_", param_2075
.annotate 'line', 983
    find_lex $P2076, "$_"
    unless_null $P2076, vivify_1485
    new $P2076, "Undef"
  vivify_1485:
    $P2077 = $P2076."value"()
    find_lex $P2078, "$_"
    unless_null $P2078, vivify_1486
    new $P2078, "Undef"
  vivify_1486:
    $P2079 = $P2078."key"()
    find_dynamic_lex $P2082, "%*HOW"
    unless_null $P2082, vivify_1487
    get_hll_global $P2080, "GLOBAL"
    get_who $P2081, $P2080
    set $P2082, $P2081["%HOW"]
    unless_null $P2082, vivify_1488
    die "Contextual %*HOW not found"
  vivify_1488:
    store_dynamic_lex "%*HOW", $P2082
  vivify_1487:
    set $P2082[$P2079], $P2077
.annotate 'line', 982
    .return ($P2077)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("415_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2088
    .param pmc param_2089
.annotate 'line', 1084
    .lex "$/", param_2088
    .lex "$block", param_2089
.annotate 'line', 1085
    find_lex $P2091, "$?PACKAGE"
    get_who $P2092, $P2091
    set $P2093, $P2092["@BLOCK"]
    unless_null $P2093, vivify_1489
    $P2093 = root_new ['parrot';'ResizablePMCArray']
  vivify_1489:
    set $P2094, $P2093[0]
    unless_null $P2094, vivify_1490
    new $P2094, "Undef"
  vivify_1490:
    $P2095 = $P2094."handlers"()
    if $P2095, unless_2090_end
.annotate 'line', 1086
    find_lex $P2096, "$?PACKAGE"
    get_who $P2097, $P2096
    set $P2098, $P2097["@BLOCK"]
    unless_null $P2098, vivify_1491
    $P2098 = root_new ['parrot';'ResizablePMCArray']
  vivify_1491:
    set $P2099, $P2098[0]
    unless_null $P2099, vivify_1492
    new $P2099, "Undef"
  vivify_1492:
    new $P2100, "ResizablePMCArray"
    $P2099."handlers"($P2100)
  unless_2090_end:
.annotate 'line', 1088
    find_lex $P2102, "$block"
    unless_null $P2102, vivify_1493
    new $P2102, "Undef"
  vivify_1493:
    $P2103 = $P2102."arity"()
    if $P2103, unless_2101_end
.annotate 'line', 1089
    find_lex $P2104, "$block"
    unless_null $P2104, vivify_1494
    new $P2104, "Undef"
  vivify_1494:
.annotate 'line', 1090
    get_hll_global $P2105, "GLOBAL"
    nqp_get_package_through_who $P2106, $P2105, "PAST"
    get_who $P2107, $P2106
    set $P2108, $P2107["Op"]
.annotate 'line', 1091
    get_hll_global $P2109, "GLOBAL"
    nqp_get_package_through_who $P2110, $P2109, "PAST"
    get_who $P2111, $P2110
    set $P2112, $P2111["Var"]
    $P2113 = $P2112."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1092
    get_hll_global $P2114, "GLOBAL"
    nqp_get_package_through_who $P2115, $P2114, "PAST"
    get_who $P2116, $P2115
    set $P2117, $P2116["Var"]
    $P2118 = $P2117."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2119 = $P2108."new"($P2113, $P2118, "bind" :named("pasttype"))
.annotate 'line', 1090
    $P2104."unshift"($P2119)
.annotate 'line', 1095
    find_lex $P2120, "$block"
    unless_null $P2120, vivify_1495
    new $P2120, "Undef"
  vivify_1495:
    get_hll_global $P2121, "GLOBAL"
    nqp_get_package_through_who $P2122, $P2121, "PAST"
    get_who $P2123, $P2122
    set $P2124, $P2123["Var"]
    $P2125 = $P2124."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2120."unshift"($P2125)
.annotate 'line', 1096
    find_lex $P2126, "$block"
    unless_null $P2126, vivify_1496
    new $P2126, "Undef"
  vivify_1496:
    $P2126."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1097
    find_lex $P2127, "$block"
    unless_null $P2127, vivify_1497
    new $P2127, "Undef"
  vivify_1497:
    $P2127."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1098
    find_lex $P2128, "$block"
    unless_null $P2128, vivify_1498
    new $P2128, "Undef"
  vivify_1498:
    $P2128."arity"(1)
  unless_2101_end:
.annotate 'line', 1100
    find_lex $P2129, "$block"
    unless_null $P2129, vivify_1499
    new $P2129, "Undef"
  vivify_1499:
    $P2129."blocktype"("declaration")
.annotate 'line', 1101
    find_lex $P2130, "$?PACKAGE"
    get_who $P2131, $P2130
    set $P2132, $P2131["@BLOCK"]
    unless_null $P2132, vivify_1500
    $P2132 = root_new ['parrot';'ResizablePMCArray']
  vivify_1500:
    set $P2133, $P2132[0]
    unless_null $P2133, vivify_1501
    new $P2133, "Undef"
  vivify_1501:
    $P2134 = $P2133."handlers"()
.annotate 'line', 1102
    get_hll_global $P2135, "GLOBAL"
    nqp_get_package_through_who $P2136, $P2135, "PAST"
    get_who $P2137, $P2136
    set $P2138, $P2137["Control"]
    find_lex $P2139, "$/"
    unless_null $P2139, vivify_1502
    new $P2139, "Undef"
  vivify_1502:
.annotate 'line', 1104
    get_hll_global $P2140, "GLOBAL"
    nqp_get_package_through_who $P2141, $P2140, "PAST"
    get_who $P2142, $P2141
    set $P2143, $P2142["Stmts"]
.annotate 'line', 1105
    get_hll_global $P2144, "GLOBAL"
    nqp_get_package_through_who $P2145, $P2144, "PAST"
    get_who $P2146, $P2145
    set $P2147, $P2146["Op"]
    find_lex $P2148, "$block"
    unless_null $P2148, vivify_1503
    new $P2148, "Undef"
  vivify_1503:
.annotate 'line', 1107
    get_hll_global $P2149, "GLOBAL"
    nqp_get_package_through_who $P2150, $P2149, "PAST"
    get_who $P2151, $P2150
    set $P2152, $P2151["Var"]
    $P2153 = $P2152."new"("register" :named("scope"), "exception" :named("name"))
    $P2154 = $P2147."new"($P2148, $P2153, "call" :named("pasttype"))
.annotate 'line', 1109
    get_hll_global $P2155, "GLOBAL"
    nqp_get_package_through_who $P2156, $P2155, "PAST"
    get_who $P2157, $P2156
    set $P2158, $P2157["Op"]
.annotate 'line', 1110
    get_hll_global $P2159, "GLOBAL"
    nqp_get_package_through_who $P2160, $P2159, "PAST"
    get_who $P2161, $P2160
    set $P2162, $P2161["Var"]
.annotate 'line', 1111
    get_hll_global $P2163, "GLOBAL"
    nqp_get_package_through_who $P2164, $P2163, "PAST"
    get_who $P2165, $P2164
    set $P2166, $P2165["Var"]
    $P2167 = $P2166."new"("register" :named("scope"), "exception" :named("name"))
    $P2168 = $P2162."new"($P2167, "handled", "keyed" :named("scope"))
.annotate 'line', 1110
    $P2169 = $P2158."new"($P2168, 1, "bind" :named("pasttype"))
.annotate 'line', 1109
    $P2170 = $P2143."new"($P2154, $P2169)
.annotate 'line', 1104
    $P2171 = $P2138."new"($P2170, $P2139 :named("node"))
.annotate 'line', 1102
    $P2172 = $P2134."unshift"($P2171)
.annotate 'line', 1084
    .return ($P2172)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("416_1304516047.681") :outer("406_1304516047.681")
.annotate 'line', 1591
    new $P2175, "Undef"
    .lex "$past", $P2175
    find_lex $P2176, "$?PACKAGE"
    get_who $P2177, $P2176
    set $P2178, $P2177["@BLOCK"]
    unless_null $P2178, vivify_1504
    $P2178 = root_new ['parrot';'ResizablePMCArray']
  vivify_1504:
    $P2179 = $P2178."shift"()
    store_lex "$past", $P2179
.annotate 'line', 1592
    find_lex $P2180, "$past"
    unless_null $P2180, vivify_1505
    new $P2180, "Undef"
  vivify_1505:
    $P2180."closure"(1)
.annotate 'line', 1593
    find_lex $P2181, "$past"
    unless_null $P2181, vivify_1506
    new $P2181, "Undef"
  vivify_1506:
    get_hll_global $P2182, "GLOBAL"
    nqp_get_package_through_who $P2183, $P2182, "PAST"
    get_who $P2184, $P2183
    set $P2185, $P2184["Op"]
    $P2186 = $P2185."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2181."push"($P2186)
    find_lex $P2187, "$past"
    unless_null $P2187, vivify_1507
    new $P2187, "Undef"
  vivify_1507:
.annotate 'line', 1590
    .return ($P2187)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("417_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2190
.annotate 'line', 1599
    .const 'Sub' $P2210 = "418_1304516047.681" 
    capture_lex $P2210
    .lex "$routine", param_2190
.annotate 'line', 1603
    new $P2191, "Undef"
    .lex "$types", $P2191
.annotate 'line', 1604
    new $P2192, "Undef"
    .lex "$definednesses", $P2192
.annotate 'line', 1603
    get_hll_global $P2193, "GLOBAL"
    nqp_get_package_through_who $P2194, $P2193, "PAST"
    get_who $P2195, $P2194
    set $P2196, $P2195["Op"]
    $P2197 = $P2196."new"("list" :named("pasttype"))
    store_lex "$types", $P2197
.annotate 'line', 1604
    get_hll_global $P2198, "GLOBAL"
    nqp_get_package_through_who $P2199, $P2198, "PAST"
    get_who $P2200, $P2199
    set $P2201, $P2200["Op"]
    $P2202 = $P2201."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2202
.annotate 'line', 1605
    find_lex $P2204, "$routine"
    unless_null $P2204, vivify_1508
    $P2204 = root_new ['parrot';'ResizablePMCArray']
  vivify_1508:
    set $P2205, $P2204[0]
    unless_null $P2205, vivify_1509
    new $P2205, "Undef"
  vivify_1509:
    $P2206 = $P2205."list"()
    defined $I2207, $P2206
    unless $I2207, for_undef_1510
    iter $P2203, $P2206
    new $P2254, 'ExceptionHandler'
    set_label $P2254, loop2253_handler
    $P2254."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2254
  loop2253_test:
    unless $P2203, loop2253_done
    shift $P2208, $P2203
  loop2253_redo:
    .const 'Sub' $P2210 = "418_1304516047.681" 
    capture_lex $P2210
    $P2210($P2208)
  loop2253_next:
    goto loop2253_test
  loop2253_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2255, exception, 'type'
    eq $P2255, .CONTROL_LOOP_NEXT, loop2253_next
    eq $P2255, .CONTROL_LOOP_REDO, loop2253_redo
  loop2253_done:
    pop_eh 
  for_undef_1510:
.annotate 'line', 1612
    find_dynamic_lex $P2258, "$*SC"
    unless_null $P2258, vivify_1520
    get_hll_global $P2256, "GLOBAL"
    get_who $P2257, $P2256
    set $P2258, $P2257["$SC"]
    unless_null $P2258, vivify_1521
    die "Contextual $*SC not found"
  vivify_1521:
  vivify_1520:
    find_lex $P2259, "$routine"
    unless_null $P2259, vivify_1522
    new $P2259, "Undef"
  vivify_1522:
    find_lex $P2260, "$types"
    unless_null $P2260, vivify_1523
    new $P2260, "Undef"
  vivify_1523:
    find_lex $P2261, "$definednesses"
    unless_null $P2261, vivify_1524
    new $P2261, "Undef"
  vivify_1524:
    $P2262 = $P2258."set_routine_signature"($P2259, $P2260, $P2261)
.annotate 'line', 1599
    .return ($P2262)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2209"  :anon :subid("418_1304516047.681") :outer("417_1304516047.681")
    .param pmc param_2211
.annotate 'line', 1605
    .lex "$_", param_2211
.annotate 'line', 1606
    get_hll_global $P2216, "GLOBAL"
    nqp_get_package_through_who $P2217, $P2216, "PAST"
    get_who $P2218, $P2217
    set $P2219, $P2218["Var"]
    find_lex $P2220, "$_"
    unless_null $P2220, vivify_1511
    new $P2220, "Undef"
  vivify_1511:
    $P2221 = $P2219."ACCEPTS"($P2220)
    if $P2221, if_2215
    set $P2214, $P2221
    goto if_2215_end
  if_2215:
    find_lex $P2222, "$_"
    unless_null $P2222, vivify_1512
    new $P2222, "Undef"
  vivify_1512:
    $S2223 = $P2222."scope"()
    iseq $I2224, $S2223, "parameter"
    new $P2214, 'Integer'
    set $P2214, $I2224
  if_2215_end:
    if $P2214, if_2213
    set $P2212, $P2214
    goto if_2213_end
  if_2213:
.annotate 'line', 1607
    find_lex $P2225, "$types"
    unless_null $P2225, vivify_1513
    new $P2225, "Undef"
  vivify_1513:
    find_lex $P2227, "$_"
    unless_null $P2227, vivify_1514
    new $P2227, "Undef"
  vivify_1514:
    $P2228 = $P2227."multitype"()
    set $P2226, $P2228
    defined $I2230, $P2226
    if $I2230, default_2229
    get_hll_global $P2231, "GLOBAL"
    nqp_get_package_through_who $P2232, $P2231, "PAST"
    get_who $P2233, $P2232
    set $P2234, $P2233["Op"]
    $P2235 = $P2234."new"("null P" :named("pirop"))
    set $P2226, $P2235
  default_2229:
    $P2225."push"($P2226)
.annotate 'line', 1608
    find_lex $P2236, "$definednesses"
    unless_null $P2236, vivify_1515
    new $P2236, "Undef"
  vivify_1515:
    find_lex $P2239, "$_"
    unless_null $P2239, vivify_1516
    $P2239 = root_new ['parrot';'Hash']
  vivify_1516:
    set $P2240, $P2239["definedness"]
    unless_null $P2240, vivify_1517
    new $P2240, "Undef"
  vivify_1517:
    set $S2241, $P2240
    iseq $I2242, $S2241, "D"
    if $I2242, if_2238
.annotate 'line', 1609
    find_lex $P2246, "$_"
    unless_null $P2246, vivify_1518
    $P2246 = root_new ['parrot';'Hash']
  vivify_1518:
    set $P2247, $P2246["definedness"]
    unless_null $P2247, vivify_1519
    new $P2247, "Undef"
  vivify_1519:
    set $S2248, $P2247
    iseq $I2249, $S2248, "U"
    if $I2249, if_2245
    new $P2251, "Integer"
    assign $P2251, 0
    set $P2244, $P2251
    goto if_2245_end
  if_2245:
    new $P2250, "Integer"
    assign $P2250, 2
    set $P2244, $P2250
  if_2245_end:
    set $P2237, $P2244
.annotate 'line', 1608
    goto if_2238_end
  if_2238:
    new $P2243, "Integer"
    assign $P2243, 1
    set $P2237, $P2243
  if_2238_end:
    $P2252 = $P2236."push"($P2237)
.annotate 'line', 1606
    set $P2212, $P2252
  if_2213_end:
.annotate 'line', 1605
    .return ($P2212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("419_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2265
    .param pmc param_2266
.annotate 'line', 2051
    .lex "$/", param_2265
    .lex "$type", param_2266
.annotate 'line', 2052
    find_lex $P2267, "$/"
    get_hll_global $P2268, "GLOBAL"
    nqp_get_package_through_who $P2269, $P2268, "PAST"
    get_who $P2270, $P2269
    set $P2271, $P2270["Op"]
    find_lex $P2272, "$/"
    unless_null $P2272, vivify_1525
    new $P2272, "Undef"
  vivify_1525:
.annotate 'line', 2056
    get_hll_global $P2273, "GLOBAL"
    nqp_get_package_through_who $P2274, $P2273, "PAST"
    get_who $P2275, $P2274
    set $P2276, $P2275["Val"]
    find_lex $P2277, "$type"
    unless_null $P2277, vivify_1526
    new $P2277, "Undef"
  vivify_1526:
    $P2278 = $P2276."new"($P2277 :named("value"), "!except_types" :named("returns"))
    $P2279 = $P2271."new"(0, $P2278, $P2272 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2052
    $P2280 = $P2267."!make"($P2279)
.annotate 'line', 2051
    .return ($P2280)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "lexical_package_lookup"  :subid("420_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2285
    .param pmc param_2286
.annotate 'line', 2070
    .const 'Sub' $P2339 = "421_1304516047.681" 
    capture_lex $P2339
    new $P2284, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2284, control_2283
    push_eh $P2284
    .lex "@name", param_2285
    .lex "$/", param_2286
.annotate 'line', 2076
    new $P2287, "Undef"
    .lex "$final_name", $P2287
.annotate 'line', 2077
    new $P2288, "Undef"
    .lex "$lookup", $P2288
.annotate 'line', 2072
    find_lex $P2290, "@name"
    unless_null $P2290, vivify_1527
    $P2290 = root_new ['parrot';'ResizablePMCArray']
  vivify_1527:
    set $N2291, $P2290
    iseq $I2292, $N2291, 0.0
    unless $I2292, if_2289_end
    find_lex $P2293, "$/"
    unless_null $P2293, vivify_1528
    new $P2293, "Undef"
  vivify_1528:
    $P2294 = $P2293."CURSOR"()
    $P2294."panic"("Cannot compile empty name")
  if_2289_end:
.annotate 'line', 2076
    find_lex $P2295, "@name"
    unless_null $P2295, vivify_1529
    $P2295 = root_new ['parrot';'ResizablePMCArray']
  vivify_1529:
    $P2296 = $P2295."pop"()
    store_lex "$final_name", $P2296
.annotate 'line', 2077
    get_hll_global $P2297, "GLOBAL"
    nqp_get_package_through_who $P2298, $P2297, "PAST"
    get_who $P2299, $P2298
    set $P2300, $P2299["Var"]
    find_lex $P2301, "$final_name"
    unless_null $P2301, vivify_1530
    new $P2301, "Undef"
  vivify_1530:
    set $S2302, $P2301
    $P2303 = $P2300."new"($S2302, "keyed" :named("scope"))
    store_lex "$lookup", $P2303
.annotate 'line', 2081
    find_lex $P2305, "@name"
    unless_null $P2305, vivify_1531
    $P2305 = root_new ['parrot';'ResizablePMCArray']
  vivify_1531:
    set $N2306, $P2305
    iseq $I2307, $N2306, 0.0
    if $I2307, if_2304
.annotate 'line', 2099
    .const 'Sub' $P2339 = "421_1304516047.681" 
    capture_lex $P2339
    $P2339()
    goto if_2304_end
  if_2304:
.annotate 'line', 2082
    find_lex $P2308, "$lookup"
    unless_null $P2308, vivify_1544
    new $P2308, "Undef"
  vivify_1544:
    get_hll_global $P2309, "GLOBAL"
    nqp_get_package_through_who $P2310, $P2309, "PAST"
    get_who $P2311, $P2310
    set $P2312, $P2311["Op"]
.annotate 'line', 2084
    get_hll_global $P2313, "GLOBAL"
    nqp_get_package_through_who $P2314, $P2313, "PAST"
    get_who $P2315, $P2314
    set $P2316, $P2315["Var"]
    $P2317 = $P2316."new"("$?PACKAGE" :named("name"), "lexical" :named("scope"))
    $P2318 = $P2312."new"($P2317, "get_who PP" :named("pirop"))
.annotate 'line', 2082
    $P2308."unshift"($P2318)
.annotate 'line', 2086
    find_lex $P2319, "$lookup"
    unless_null $P2319, vivify_1545
    new $P2319, "Undef"
  vivify_1545:
    get_hll_global $P2320, "GLOBAL"
    nqp_get_package_through_who $P2321, $P2320, "PAST"
    get_who $P2322, $P2321
    set $P2323, $P2322["Var"]
.annotate 'line', 2088
    get_hll_global $P2324, "GLOBAL"
    nqp_get_package_through_who $P2325, $P2324, "PAST"
    get_who $P2326, $P2325
    set $P2327, $P2326["Op"]
.annotate 'line', 2090
    get_hll_global $P2328, "GLOBAL"
    nqp_get_package_through_who $P2329, $P2328, "PAST"
    get_who $P2330, $P2329
    set $P2331, $P2330["Var"]
    new $P2332, "ResizablePMCArray"
    $P2333 = $P2331."new"("GLOBAL" :named("name"), $P2332 :named("namespace"), "package" :named("scope"))
    $P2334 = $P2327."new"($P2333, "get_who PP" :named("pirop"))
.annotate 'line', 2092
    find_lex $P2335, "$final_name"
    unless_null $P2335, vivify_1546
    new $P2335, "Undef"
  vivify_1546:
    set $S2336, $P2335
    $P2337 = $P2323."new"($P2334, $S2336, "keyed" :named("scope"))
.annotate 'line', 2086
    $P2319."viviself"($P2337)
  if_2304_end:
.annotate 'line', 2114
    new $P2391, "Exception"
    set $P2391['type'], .CONTROL_RETURN
    find_lex $P2392, "$lookup"
    unless_null $P2392, vivify_1547
    new $P2392, "Undef"
  vivify_1547:
    setattribute $P2391, 'payload', $P2392
    throw $P2391
.annotate 'line', 2070
    .return ()
  control_2283:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2393, exception, "payload"
    .return ($P2393)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2338"  :anon :subid("421_1304516047.681") :outer("420_1304516047.681")
.annotate 'line', 2099
    .const 'Sub' $P2370 = "422_1304516047.681" 
    capture_lex $P2370
.annotate 'line', 2100
    new $P2340, "Undef"
    .lex "$path", $P2340
    find_lex $P2343, "@name"
    unless_null $P2343, vivify_1532
    $P2343 = root_new ['parrot';'ResizablePMCArray']
  vivify_1532:
    set $P2344, $P2343[0]
    unless_null $P2344, vivify_1533
    new $P2344, "Undef"
  vivify_1533:
    $P2345 = "is_lexical"($P2344)
    if $P2345, if_2342
.annotate 'line', 2102
    get_hll_global $P2353, "GLOBAL"
    nqp_get_package_through_who $P2354, $P2353, "PAST"
    get_who $P2355, $P2354
    set $P2356, $P2355["Var"]
    new $P2357, "ResizablePMCArray"
    $P2358 = $P2356."new"("GLOBAL" :named("name"), $P2357 :named("namespace"), "package" :named("scope"))
    set $P2341, $P2358
.annotate 'line', 2100
    goto if_2342_end
  if_2342:
.annotate 'line', 2101
    get_hll_global $P2346, "GLOBAL"
    nqp_get_package_through_who $P2347, $P2346, "PAST"
    get_who $P2348, $P2347
    set $P2349, $P2348["Var"]
    find_lex $P2350, "@name"
    unless_null $P2350, vivify_1534
    $P2350 = root_new ['parrot';'ResizablePMCArray']
  vivify_1534:
    $P2351 = $P2350."shift"()
    $P2352 = $P2349."new"($P2351 :named("name"), "lexical" :named("scope"))
    set $P2341, $P2352
  if_2342_end:
.annotate 'line', 2100
    store_lex "$path", $P2341
.annotate 'line', 2103
    find_lex $P2360, "@name"
    unless_null $P2360, vivify_1535
    $P2360 = root_new ['parrot';'ResizablePMCArray']
  vivify_1535:
    set $P2361, $P2360[0]
    unless_null $P2361, vivify_1536
    new $P2361, "Undef"
  vivify_1536:
    set $S2362, $P2361
    iseq $I2363, $S2362, "GLOBAL"
    unless $I2363, if_2359_end
.annotate 'line', 2104
    find_lex $P2364, "@name"
    unless_null $P2364, vivify_1537
    $P2364 = root_new ['parrot';'ResizablePMCArray']
  vivify_1537:
    $P2364."shift"()
  if_2359_end:
.annotate 'line', 2106
    find_lex $P2366, "@name"
    unless_null $P2366, vivify_1538
    $P2366 = root_new ['parrot';'ResizablePMCArray']
  vivify_1538:
    defined $I2367, $P2366
    unless $I2367, for_undef_1539
    iter $P2365, $P2366
    new $P2381, 'ExceptionHandler'
    set_label $P2381, loop2380_handler
    $P2381."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2381
  loop2380_test:
    unless $P2365, loop2380_done
    shift $P2368, $P2365
  loop2380_redo:
    .const 'Sub' $P2370 = "422_1304516047.681" 
    capture_lex $P2370
    $P2370($P2368)
  loop2380_next:
    goto loop2380_test
  loop2380_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2382, exception, 'type'
    eq $P2382, .CONTROL_LOOP_NEXT, loop2380_next
    eq $P2382, .CONTROL_LOOP_REDO, loop2380_redo
  loop2380_done:
    pop_eh 
  for_undef_1539:
.annotate 'line', 2111
    find_lex $P2383, "$lookup"
    unless_null $P2383, vivify_1542
    new $P2383, "Undef"
  vivify_1542:
    get_hll_global $P2384, "GLOBAL"
    nqp_get_package_through_who $P2385, $P2384, "PAST"
    get_who $P2386, $P2385
    set $P2387, $P2386["Op"]
    find_lex $P2388, "$path"
    unless_null $P2388, vivify_1543
    new $P2388, "Undef"
  vivify_1543:
    $P2389 = $P2387."new"($P2388, "get_who PP" :named("pirop"))
    $P2390 = $P2383."unshift"($P2389)
.annotate 'line', 2099
    .return ($P2390)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2369"  :anon :subid("422_1304516047.681") :outer("421_1304516047.681")
    .param pmc param_2371
.annotate 'line', 2106
    .lex "$_", param_2371
.annotate 'line', 2107
    get_hll_global $P2372, "GLOBAL"
    nqp_get_package_through_who $P2373, $P2372, "PAST"
    get_who $P2374, $P2373
    set $P2375, $P2374["Op"]
    find_lex $P2376, "$path"
    unless_null $P2376, vivify_1540
    new $P2376, "Undef"
  vivify_1540:
.annotate 'line', 2109
    find_lex $P2377, "$_"
    unless_null $P2377, vivify_1541
    new $P2377, "Undef"
  vivify_1541:
    set $S2378, $P2377
    $P2379 = $P2375."new"($P2376, $S2378, "nqp_get_package_through_who PPs" :named("pirop"))
.annotate 'line', 2107
    store_lex "$path", $P2379
.annotate 'line', 2106
    .return ($P2379)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_lexical"  :subid("423_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2396
.annotate 'line', 2119
    .lex "$name", param_2396
.annotate 'line', 2120
    find_lex $P2397, "$name"
    unless_null $P2397, vivify_1548
    new $P2397, "Undef"
  vivify_1548:
    $P2398 = "is_scope"($P2397, "lexical")
.annotate 'line', 2119
    .return ($P2398)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "is_package"  :subid("424_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2401
.annotate 'line', 2125
    .lex "$name", param_2401
.annotate 'line', 2126
    find_lex $P2402, "$name"
    unless_null $P2402, vivify_1549
    new $P2402, "Undef"
  vivify_1549:
    $P2403 = "is_scope"($P2402, "package")
.annotate 'line', 2125
    .return ($P2403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_scope"  :subid("425_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2408
    .param pmc param_2409
.annotate 'line', 2131
    .const 'Sub' $P2417 = "426_1304516047.681" 
    capture_lex $P2417
    new $P2407, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2407, control_2406
    push_eh $P2407
    .lex "$name", param_2408
    .lex "$wanted_scope", param_2409
.annotate 'line', 2132
    find_lex $P2411, "$?PACKAGE"
    get_who $P2412, $P2411
    set $P2413, $P2412["@BLOCK"]
    unless_null $P2413, vivify_1550
    $P2413 = root_new ['parrot';'ResizablePMCArray']
  vivify_1550:
    defined $I2414, $P2413
    unless $I2414, for_undef_1551
    iter $P2410, $P2413
    new $P2436, 'ExceptionHandler'
    set_label $P2436, loop2435_handler
    $P2436."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2436
  loop2435_test:
    unless $P2410, loop2435_done
    shift $P2415, $P2410
  loop2435_redo:
    .const 'Sub' $P2417 = "426_1304516047.681" 
    capture_lex $P2417
    $P2417($P2415)
  loop2435_next:
    goto loop2435_test
  loop2435_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2437, exception, 'type'
    eq $P2437, .CONTROL_LOOP_NEXT, loop2435_next
    eq $P2437, .CONTROL_LOOP_REDO, loop2435_redo
  loop2435_done:
    pop_eh 
  for_undef_1551:
.annotate 'line', 2131
    .return (0)
  control_2406:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2438, exception, "payload"
    .return ($P2438)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2416"  :anon :subid("426_1304516047.681") :outer("425_1304516047.681")
    .param pmc param_2419
.annotate 'line', 2133
    $P2418 = root_new ['parrot';'Hash']
    .lex "%sym", $P2418
    .lex "$_", param_2419
    find_lex $P2420, "$_"
    unless_null $P2420, vivify_1552
    new $P2420, "Undef"
  vivify_1552:
    find_lex $P2421, "$name"
    unless_null $P2421, vivify_1553
    new $P2421, "Undef"
  vivify_1553:
    $P2422 = $P2420."symbol"($P2421)
    store_lex "%sym", $P2422
.annotate 'line', 2134
    find_lex $P2425, "%sym"
    unless_null $P2425, vivify_1554
    $P2425 = root_new ['parrot';'Hash']
  vivify_1554:
    set $N2426, $P2425
    if $N2426, if_2424
    new $P2423, 'Float'
    set $P2423, $N2426
    goto if_2424_end
  if_2424:
.annotate 'line', 2135
    new $P2427, "Exception"
    set $P2427['type'], .CONTROL_RETURN
    find_lex $P2428, "%sym"
    unless_null $P2428, vivify_1555
    $P2428 = root_new ['parrot';'Hash']
  vivify_1555:
    set $P2429, $P2428["scope"]
    unless_null $P2429, vivify_1556
    new $P2429, "Undef"
  vivify_1556:
    set $S2430, $P2429
    find_lex $P2431, "$wanted_scope"
    unless_null $P2431, vivify_1557
    new $P2431, "Undef"
  vivify_1557:
    set $S2432, $P2431
    iseq $I2433, $S2430, $S2432
    new $P2434, 'Integer'
    set $P2434, $I2433
    setattribute $P2427, 'payload', $P2434
    throw $P2427
  if_2424_end:
.annotate 'line', 2132
    .return ($P2423)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "find_sym"  :subid("427_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2443
    .param pmc param_2444
.annotate 'line', 2154
    .const 'Sub' $P2538 = "432_1304516047.681" 
    capture_lex $P2538
    .const 'Sub' $P2498 = "430_1304516047.681" 
    capture_lex $P2498
    .const 'Sub' $P2456 = "428_1304516047.681" 
    capture_lex $P2456
    new $P2442, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2442, control_2441
    push_eh $P2442
    .lex "@name", param_2443
    .lex "$/", param_2444
.annotate 'line', 2178
    new $P2445, "Undef"
    .lex "$result", $P2445
.annotate 'line', 2156
    find_lex $P2447, "@name"
    unless_null $P2447, vivify_1558
    $P2447 = root_new ['parrot';'ResizablePMCArray']
  vivify_1558:
    set $N2448, $P2447
    if $N2448, unless_2446_end
    find_lex $P2449, "$/"
    unless_null $P2449, vivify_1559
    new $P2449, "Undef"
  vivify_1559:
    $P2450 = $P2449."CURSOR"()
    $P2450."panic"("Cannot look up empty name")
  unless_2446_end:
.annotate 'line', 2160
    find_lex $P2452, "@name"
    unless_null $P2452, vivify_1560
    $P2452 = root_new ['parrot';'ResizablePMCArray']
  vivify_1560:
    set $N2453, $P2452
    iseq $I2454, $N2453, 1.0
    unless $I2454, if_2451_end
    .const 'Sub' $P2456 = "428_1304516047.681" 
    capture_lex $P2456
    $P2456()
  if_2451_end:
.annotate 'line', 2178
    find_dynamic_lex $P2492, "$*GLOBALish"
    unless_null $P2492, vivify_1572
    get_hll_global $P2490, "GLOBAL"
    get_who $P2491, $P2490
    set $P2492, $P2491["$GLOBALish"]
    unless_null $P2492, vivify_1573
    die "Contextual $*GLOBALish not found"
  vivify_1573:
  vivify_1572:
    store_lex "$result", $P2492
.annotate 'line', 2179
    find_lex $P2494, "@name"
    unless_null $P2494, vivify_1574
    $P2494 = root_new ['parrot';'ResizablePMCArray']
  vivify_1574:
    set $N2495, $P2494
    isge $I2496, $N2495, 2.0
    unless $I2496, if_2493_end
    .const 'Sub' $P2498 = "430_1304516047.681" 
    capture_lex $P2498
    $P2498()
  if_2493_end:
.annotate 'line', 2197
    find_lex $P2534, "@name"
    unless_null $P2534, vivify_1587
    $P2534 = root_new ['parrot';'ResizablePMCArray']
  vivify_1587:
    defined $I2535, $P2534
    unless $I2535, for_undef_1588
    iter $P2533, $P2534
    new $P2556, 'ExceptionHandler'
    set_label $P2556, loop2555_handler
    $P2556."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2556
  loop2555_test:
    unless $P2533, loop2555_done
    shift $P2536, $P2533
  loop2555_redo:
    .const 'Sub' $P2538 = "432_1304516047.681" 
    capture_lex $P2538
    $P2538($P2536)
  loop2555_next:
    goto loop2555_test
  loop2555_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2557, exception, 'type'
    eq $P2557, .CONTROL_LOOP_NEXT, loop2555_next
    eq $P2557, .CONTROL_LOOP_REDO, loop2555_redo
  loop2555_done:
    pop_eh 
  for_undef_1588:
    find_lex $P2558, "$result"
    unless_null $P2558, vivify_1595
    new $P2558, "Undef"
  vivify_1595:
.annotate 'line', 2154
    .return ($P2558)
  control_2441:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2559, exception, "payload"
    .return ($P2559)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2455"  :anon :subid("428_1304516047.681") :outer("427_1304516047.681")
.annotate 'line', 2160
    .const 'Sub' $P2467 = "429_1304516047.681" 
    capture_lex $P2467
.annotate 'line', 2161
    new $P2457, "Undef"
    .lex "$final_name", $P2457
    find_lex $P2458, "@name"
    unless_null $P2458, vivify_1561
    $P2458 = root_new ['parrot';'ResizablePMCArray']
  vivify_1561:
    set $P2459, $P2458[0]
    unless_null $P2459, vivify_1562
    new $P2459, "Undef"
  vivify_1562:
    store_lex "$final_name", $P2459
.annotate 'line', 2162
    find_lex $P2461, "$?PACKAGE"
    get_who $P2462, $P2461
    set $P2463, $P2462["@BLOCK"]
    unless_null $P2463, vivify_1563
    $P2463 = root_new ['parrot';'ResizablePMCArray']
  vivify_1563:
    defined $I2464, $P2463
    unless $I2464, for_undef_1564
    iter $P2460, $P2463
    new $P2488, 'ExceptionHandler'
    set_label $P2488, loop2487_handler
    $P2488."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2488
  loop2487_test:
    unless $P2460, loop2487_done
    shift $P2465, $P2460
  loop2487_redo:
    .const 'Sub' $P2467 = "429_1304516047.681" 
    capture_lex $P2467
    $P2467($P2465)
  loop2487_next:
    goto loop2487_test
  loop2487_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2489, exception, 'type'
    eq $P2489, .CONTROL_LOOP_NEXT, loop2487_next
    eq $P2489, .CONTROL_LOOP_REDO, loop2487_redo
  loop2487_done:
    pop_eh 
  for_undef_1564:
.annotate 'line', 2160
    .return ($P2460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2466"  :anon :subid("429_1304516047.681") :outer("428_1304516047.681")
    .param pmc param_2469
.annotate 'line', 2163
    $P2468 = root_new ['parrot';'Hash']
    .lex "%sym", $P2468
    .lex "$_", param_2469
    find_lex $P2470, "$_"
    unless_null $P2470, vivify_1565
    new $P2470, "Undef"
  vivify_1565:
    find_lex $P2471, "$final_name"
    unless_null $P2471, vivify_1566
    new $P2471, "Undef"
  vivify_1566:
    $P2472 = $P2470."symbol"($P2471)
    store_lex "%sym", $P2472
.annotate 'line', 2164
    find_lex $P2475, "%sym"
    unless_null $P2475, vivify_1567
    $P2475 = root_new ['parrot';'Hash']
  vivify_1567:
    set $N2476, $P2475
    if $N2476, if_2474
    new $P2473, 'Float'
    set $P2473, $N2476
    goto if_2474_end
  if_2474:
.annotate 'line', 2165
    find_lex $P2479, "%sym"
    unless_null $P2479, vivify_1568
    $P2479 = root_new ['parrot';'Hash']
  vivify_1568:
    exists $I2480, $P2479["value"]
    if $I2480, if_2478
.annotate 'line', 2169
    new $P2484, 'String'
    set $P2484, "No compile-time value for "
    find_lex $P2485, "$final_name"
    unless_null $P2485, vivify_1569
    new $P2485, "Undef"
  vivify_1569:
    concat $P2486, $P2484, $P2485
    die $P2486
.annotate 'line', 2168
    goto if_2478_end
  if_2478:
.annotate 'line', 2166
    new $P2481, "Exception"
    set $P2481['type'], .CONTROL_RETURN
    find_lex $P2482, "%sym"
    unless_null $P2482, vivify_1570
    $P2482 = root_new ['parrot';'Hash']
  vivify_1570:
    set $P2483, $P2482["value"]
    unless_null $P2483, vivify_1571
    new $P2483, "Undef"
  vivify_1571:
    setattribute $P2481, 'payload', $P2483
    throw $P2481
  if_2478_end:
.annotate 'line', 2164
    set $P2473, $P2477
  if_2474_end:
.annotate 'line', 2162
    .return ($P2473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2497"  :anon :subid("430_1304516047.681") :outer("427_1304516047.681")
.annotate 'line', 2179
    .const 'Sub' $P2509 = "431_1304516047.681" 
    capture_lex $P2509
.annotate 'line', 2180
    new $P2499, "Undef"
    .lex "$first", $P2499
    find_lex $P2500, "@name"
    unless_null $P2500, vivify_1575
    $P2500 = root_new ['parrot';'ResizablePMCArray']
  vivify_1575:
    set $P2501, $P2500[0]
    unless_null $P2501, vivify_1576
    new $P2501, "Undef"
  vivify_1576:
    store_lex "$first", $P2501
.annotate 'line', 2181
    find_lex $P2503, "$?PACKAGE"
    get_who $P2504, $P2503
    set $P2505, $P2504["@BLOCK"]
    unless_null $P2505, vivify_1577
    $P2505 = root_new ['parrot';'ResizablePMCArray']
  vivify_1577:
    defined $I2506, $P2505
    unless $I2506, for_undef_1578
    iter $P2502, $P2505
    new $P2531, 'ExceptionHandler'
    set_label $P2531, loop2530_handler
    $P2531."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2531
  loop2530_test:
    unless $P2502, loop2530_done
    shift $P2507, $P2502
  loop2530_redo:
    .const 'Sub' $P2509 = "431_1304516047.681" 
    capture_lex $P2509
    $P2509($P2507)
  loop2530_next:
    goto loop2530_test
  loop2530_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2532, exception, 'type'
    eq $P2532, .CONTROL_LOOP_NEXT, loop2530_next
    eq $P2532, .CONTROL_LOOP_REDO, loop2530_redo
  loop2530_done:
    pop_eh 
  for_undef_1578:
.annotate 'line', 2179
    .return ($P2502)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2508"  :anon :subid("431_1304516047.681") :outer("430_1304516047.681")
    .param pmc param_2511
.annotate 'line', 2182
    $P2510 = root_new ['parrot';'Hash']
    .lex "%sym", $P2510
    .lex "$_", param_2511
    find_lex $P2512, "$_"
    unless_null $P2512, vivify_1579
    new $P2512, "Undef"
  vivify_1579:
    find_lex $P2513, "$first"
    unless_null $P2513, vivify_1580
    new $P2513, "Undef"
  vivify_1580:
    $P2514 = $P2512."symbol"($P2513)
    store_lex "%sym", $P2514
.annotate 'line', 2183
    find_lex $P2517, "%sym"
    unless_null $P2517, vivify_1581
    $P2517 = root_new ['parrot';'Hash']
  vivify_1581:
    set $N2518, $P2517
    if $N2518, if_2516
    new $P2515, 'Float'
    set $P2515, $N2518
    goto if_2516_end
  if_2516:
.annotate 'line', 2184
    find_lex $P2521, "%sym"
    unless_null $P2521, vivify_1582
    $P2521 = root_new ['parrot';'Hash']
  vivify_1582:
    exists $I2522, $P2521["value"]
    if $I2522, if_2520
.annotate 'line', 2190
    new $P2527, 'String'
    set $P2527, "No compile-time value for "
    find_lex $P2528, "$first"
    unless_null $P2528, vivify_1583
    new $P2528, "Undef"
  vivify_1583:
    concat $P2529, $P2527, $P2528
    die $P2529
.annotate 'line', 2189
    goto if_2520_end
  if_2520:
.annotate 'line', 2185
    find_lex $P2523, "%sym"
    unless_null $P2523, vivify_1584
    $P2523 = root_new ['parrot';'Hash']
  vivify_1584:
    set $P2524, $P2523["value"]
    unless_null $P2524, vivify_1585
    new $P2524, "Undef"
  vivify_1585:
    store_lex "$result", $P2524
.annotate 'line', 2186
    find_lex $P2525, "@name"
    unless_null $P2525, vivify_1586
    $P2525 = root_new ['parrot';'ResizablePMCArray']
  vivify_1586:
    $P2525."shift"()
.annotate 'line', 2187
    set $I2526, .CONTROL_LOOP_LAST
    die 0, $I2526
  if_2520_end:
.annotate 'line', 2183
    set $P2515, $P2519
  if_2516_end:
.annotate 'line', 2181
    .return ($P2515)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2537"  :anon :subid("432_1304516047.681") :outer("427_1304516047.681")
    .param pmc param_2539
.annotate 'line', 2197
    .lex "$_", param_2539
.annotate 'line', 2198
    find_lex $P2544, "$_"
    unless_null $P2544, vivify_1589
    new $P2544, "Undef"
  vivify_1589:
    set $S2545, $P2544
    find_lex $P2542, "$result"
    unless_null $P2542, vivify_1590
    new $P2542, "Undef"
  vivify_1590:
    get_who $P2543, $P2542
    exists $I2546, $P2543[$S2545]
    if $I2546, if_2541
.annotate 'line', 2202
    new $P2551, "String"
    assign $P2551, "Could not locate compile-time value for symbol "
.annotate 'line', 2203
    find_lex $P2552, "@name"
    unless_null $P2552, vivify_1591
    $P2552 = root_new ['parrot';'ResizablePMCArray']
  vivify_1591:
    join $S2553, "::", $P2552
    concat $P2554, $P2551, $S2553
.annotate 'line', 2202
    die $P2554
.annotate 'line', 2201
    goto if_2541_end
  if_2541:
.annotate 'line', 2199
    find_lex $P2547, "$_"
    unless_null $P2547, vivify_1592
    new $P2547, "Undef"
  vivify_1592:
    find_lex $P2548, "$result"
    unless_null $P2548, vivify_1593
    new $P2548, "Undef"
  vivify_1593:
    get_who $P2549, $P2548
    set $P2550, $P2549[$P2547]
    unless_null $P2550, vivify_1594
    new $P2550, "Undef"
  vivify_1594:
    store_lex "$result", $P2550
.annotate 'line', 2198
    set $P2540, $P2550
  if_2541_end:
.annotate 'line', 2197
    .return ($P2540)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("433_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2570
    .param pmc param_2571
.annotate 'line', 796
    .lex "self", param_2570
    .lex "$/", param_2571
    find_lex $P2572, "$/"
    find_lex $P2573, "$/"
    unless_null $P2573, vivify_1596
    $P2573 = root_new ['parrot';'Hash']
  vivify_1596:
    set $P2574, $P2573["comp_unit"]
    unless_null $P2574, vivify_1597
    new $P2574, "Undef"
  vivify_1597:
    $P2575 = $P2574."ast"()
    $P2576 = $P2572."!make"($P2575)
    .return ($P2576)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("434_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2578
    .param pmc param_2579
.annotate 'line', 798
    .lex "self", param_2578
    .lex "$/", param_2579
.annotate 'line', 799
    find_lex $P2580, "$/"
.annotate 'line', 800
    find_lex $P2583, "$/"
    unless_null $P2583, vivify_1598
    $P2583 = root_new ['parrot';'Hash']
  vivify_1598:
    set $P2584, $P2583["colonpair"]
    unless_null $P2584, vivify_1599
    new $P2584, "Undef"
  vivify_1599:
    if $P2584, if_2582
.annotate 'line', 802
    find_lex $P2604, "$/"
    unless_null $P2604, vivify_1600
    new $P2604, "Undef"
  vivify_1600:
    set $S2605, $P2604
    new $P2581, 'String'
    set $P2581, $S2605
.annotate 'line', 800
    goto if_2582_end
  if_2582:
    find_lex $P2585, "$/"
    unless_null $P2585, vivify_1601
    $P2585 = root_new ['parrot';'Hash']
  vivify_1601:
    set $P2586, $P2585["identifier"]
    unless_null $P2586, vivify_1602
    new $P2586, "Undef"
  vivify_1602:
    set $S2587, $P2586
    new $P2588, 'String'
    set $P2588, $S2587
    concat $P2589, $P2588, ":"
    find_lex $P2590, "$/"
    unless_null $P2590, vivify_1603
    $P2590 = root_new ['parrot';'Hash']
  vivify_1603:
    set $P2591, $P2590["colonpair"]
    unless_null $P2591, vivify_1604
    $P2591 = root_new ['parrot';'ResizablePMCArray']
  vivify_1604:
    set $P2592, $P2591[0]
    unless_null $P2592, vivify_1605
    new $P2592, "Undef"
  vivify_1605:
    $P2593 = $P2592."ast"()
    $S2594 = $P2593."named"()
    concat $P2595, $P2589, $S2594
    concat $P2596, $P2595, "<"
.annotate 'line', 801
    find_lex $P2597, "$/"
    unless_null $P2597, vivify_1606
    $P2597 = root_new ['parrot';'Hash']
  vivify_1606:
    set $P2598, $P2597["colonpair"]
    unless_null $P2598, vivify_1607
    $P2598 = root_new ['parrot';'ResizablePMCArray']
  vivify_1607:
    set $P2599, $P2598[0]
    unless_null $P2599, vivify_1608
    new $P2599, "Undef"
  vivify_1608:
    $P2600 = $P2599."ast"()
    $S2601 = "colonpair_str"($P2600)
    concat $P2602, $P2596, $S2601
    concat $P2603, $P2602, ">"
    set $P2581, $P2603
  if_2582_end:
.annotate 'line', 800
    $P2606 = $P2580."!make"($P2581)
.annotate 'line', 798
    .return ($P2606)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("435_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2609
    .param pmc param_2610
.annotate 'line', 812
    .lex "self", param_2609
    .lex "$/", param_2610
.annotate 'line', 813
    new $P2611, "Undef"
    .lex "$mainline", $P2611
.annotate 'line', 814
    new $P2612, "Undef"
    .lex "$unit", $P2612
.annotate 'line', 844
    new $P2613, "Undef"
    .lex "$main_tasks", $P2613
.annotate 'line', 813
    find_lex $P2614, "$/"
    unless_null $P2614, vivify_1609
    $P2614 = root_new ['parrot';'Hash']
  vivify_1609:
    set $P2615, $P2614["statementlist"]
    unless_null $P2615, vivify_1610
    new $P2615, "Undef"
  vivify_1610:
    $P2616 = $P2615."ast"()
    store_lex "$mainline", $P2616
.annotate 'line', 814
    find_lex $P2617, "$?PACKAGE"
    get_who $P2618, $P2617
    set $P2619, $P2618["@BLOCK"]
    unless_null $P2619, vivify_1611
    $P2619 = root_new ['parrot';'ResizablePMCArray']
  vivify_1611:
    $P2620 = $P2619."shift"()
    store_lex "$unit", $P2620
.annotate 'line', 818
    find_lex $P2621, "$unit"
    unless_null $P2621, vivify_1612
    new $P2621, "Undef"
  vivify_1612:
    $P2622 = $P2621."loadinit"()
    find_dynamic_lex $P2625, "$*SC"
    unless_null $P2625, vivify_1613
    get_hll_global $P2623, "GLOBAL"
    get_who $P2624, $P2623
    set $P2625, $P2624["$SC"]
    unless_null $P2625, vivify_1614
    die "Contextual $*SC not found"
  vivify_1614:
  vivify_1613:
    $P2626 = $P2625."to_past"()
    $P2622."push"($P2626)
.annotate 'line', 823
    find_lex $P2627, "$unit"
    unless_null $P2627, vivify_1615
    new $P2627, "Undef"
  vivify_1615:
    $P2628 = $P2627."loadinit"()
    get_hll_global $P2629, "GLOBAL"
    nqp_get_package_through_who $P2630, $P2629, "PAST"
    get_who $P2631, $P2630
    set $P2632, $P2631["Op"]
.annotate 'line', 825
    get_hll_global $P2633, "GLOBAL"
    nqp_get_package_through_who $P2634, $P2633, "PAST"
    get_who $P2635, $P2634
    set $P2636, $P2635["Var"]
    new $P2637, "ResizablePMCArray"
    $P2638 = $P2636."new"("GLOBAL" :named("name"), $P2637 :named("namespace"), "package" :named("scope"))
.annotate 'line', 826
    find_dynamic_lex $P2641, "$*SC"
    unless_null $P2641, vivify_1616
    get_hll_global $P2639, "GLOBAL"
    get_who $P2640, $P2639
    set $P2641, $P2640["$SC"]
    unless_null $P2641, vivify_1617
    die "Contextual $*SC not found"
  vivify_1617:
  vivify_1616:
    find_dynamic_lex $P2644, "$*PACKAGE"
    unless_null $P2644, vivify_1618
    get_hll_global $P2642, "GLOBAL"
    get_who $P2643, $P2642
    set $P2644, $P2643["$PACKAGE"]
    unless_null $P2644, vivify_1619
    die "Contextual $*PACKAGE not found"
  vivify_1619:
  vivify_1618:
    $P2645 = $P2641."get_slot_past_for_object"($P2644)
    $P2646 = $P2632."new"($P2638, $P2645, "bind" :named("pasttype"))
.annotate 'line', 823
    $P2628."push"($P2646)
.annotate 'line', 832
    find_dynamic_lex $P2650, "$*HAS_YOU_ARE_HERE"
    unless_null $P2650, vivify_1620
    get_hll_global $P2648, "GLOBAL"
    get_who $P2649, $P2648
    set $P2650, $P2649["$HAS_YOU_ARE_HERE"]
    unless_null $P2650, vivify_1621
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1621:
  vivify_1620:
    if $P2650, unless_2647_end
.annotate 'line', 833
    find_lex $P2651, "$unit"
    unless_null $P2651, vivify_1622
    new $P2651, "Undef"
  vivify_1622:
    find_lex $P2652, "self"
    $P2653 = $P2652."CTXSAVE"()
    $P2651."push"($P2653)
  unless_2647_end:
.annotate 'line', 837
    find_lex $P2654, "$unit"
    unless_null $P2654, vivify_1623
    new $P2654, "Undef"
  vivify_1623:
    $P2654."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 843
    find_lex $P2655, "$unit"
    unless_null $P2655, vivify_1624
    new $P2655, "Undef"
  vivify_1624:
    get_hll_global $P2656, "GLOBAL"
    nqp_get_package_through_who $P2657, $P2656, "PAST"
    get_who $P2658, $P2657
    set $P2659, $P2658["Var"]
    $P2660 = $P2659."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P2655."unshift"($P2660)
.annotate 'line', 844
    get_hll_global $P2661, "GLOBAL"
    nqp_get_package_through_who $P2662, $P2661, "PAST"
    get_who $P2663, $P2662
    set $P2664, $P2663["Stmts"]
.annotate 'line', 845
    get_hll_global $P2665, "GLOBAL"
    nqp_get_package_through_who $P2666, $P2665, "PAST"
    get_who $P2667, $P2666
    set $P2668, $P2667["Op"]
    $P2669 = $P2668."new"("ModuleLoader.pbc", "load_bytecode vs" :named("pirop"))
.annotate 'line', 846
    get_hll_global $P2670, "GLOBAL"
    nqp_get_package_through_who $P2671, $P2670, "PAST"
    get_who $P2672, $P2671
    set $P2673, $P2672["Op"]
.annotate 'line', 848
    get_hll_global $P2674, "GLOBAL"
    nqp_get_package_through_who $P2675, $P2674, "PAST"
    get_who $P2676, $P2675
    set $P2677, $P2676["Var"]
    new $P2678, "ResizablePMCArray"
    $P2679 = $P2677."new"("ModuleLoader" :named("name"), $P2678 :named("namespace"), "package" :named("scope"))
.annotate 'line', 849
    get_hll_global $P2680, "GLOBAL"
    nqp_get_package_through_who $P2681, $P2680, "PAST"
    get_who $P2682, $P2681
    set $P2683, $P2682["Var"]
    get_hll_global $P2684, "GLOBAL"
    nqp_get_package_through_who $P2685, $P2684, "PAST"
    get_who $P2686, $P2685
    set $P2687, $P2686["Op"]
    $P2688 = $P2687."new"("getinterp P" :named("pirop"))
    $P2689 = $P2683."new"($P2688, "context", "keyed" :named("scope"))
    $P2690 = $P2673."new"($P2679, $P2689, "callmethod" :named("pasttype"), "set_mainline_module" :named("name"))
.annotate 'line', 846
    $P2691 = $P2664."new"($P2669, $P2690)
.annotate 'line', 844
    store_lex "$main_tasks", $P2691
.annotate 'line', 852
    find_dynamic_lex $P2695, "$*MAIN_SUB"
    unless_null $P2695, vivify_1625
    get_hll_global $P2693, "GLOBAL"
    get_who $P2694, $P2693
    set $P2695, $P2694["$MAIN_SUB"]
    unless_null $P2695, vivify_1626
    die "Contextual $*MAIN_SUB not found"
  vivify_1626:
  vivify_1625:
    unless $P2695, if_2692_end
.annotate 'line', 853
    find_lex $P2696, "$main_tasks"
    unless_null $P2696, vivify_1627
    new $P2696, "Undef"
  vivify_1627:
    get_hll_global $P2697, "GLOBAL"
    nqp_get_package_through_who $P2698, $P2697, "PAST"
    get_who $P2699, $P2698
    set $P2700, $P2699["Op"]
.annotate 'line', 854
    get_hll_global $P2701, "GLOBAL"
    nqp_get_package_through_who $P2702, $P2701, "PAST"
    get_who $P2703, $P2702
    set $P2704, $P2703["Val"]
    find_dynamic_lex $P2707, "$*MAIN_SUB"
    unless_null $P2707, vivify_1628
    get_hll_global $P2705, "GLOBAL"
    get_who $P2706, $P2705
    set $P2707, $P2706["$MAIN_SUB"]
    unless_null $P2707, vivify_1629
    die "Contextual $*MAIN_SUB not found"
  vivify_1629:
  vivify_1628:
    $P2708 = $P2704."new"($P2707 :named("value"))
.annotate 'line', 855
    get_hll_global $P2709, "GLOBAL"
    nqp_get_package_through_who $P2710, $P2709, "PAST"
    get_who $P2711, $P2710
    set $P2712, $P2711["Var"]
    $P2713 = $P2712."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P2714 = $P2700."new"($P2708, $P2713, "call" :named("pasttype"))
.annotate 'line', 853
    $P2696."push"($P2714)
  if_2692_end:
.annotate 'line', 858
    find_lex $P2715, "$mainline"
    unless_null $P2715, vivify_1630
    new $P2715, "Undef"
  vivify_1630:
    get_hll_global $P2716, "GLOBAL"
    nqp_get_package_through_who $P2717, $P2716, "PAST"
    get_who $P2718, $P2717
    set $P2719, $P2718["Op"]
.annotate 'line', 860
    get_hll_global $P2720, "GLOBAL"
    nqp_get_package_through_who $P2721, $P2720, "PAST"
    get_who $P2722, $P2721
    set $P2723, $P2722["Var"]
    $P2724 = $P2723."new"("lexical" :named("scope"), "@ARGS" :named("name"))
    find_lex $P2725, "$main_tasks"
    unless_null $P2725, vivify_1631
    new $P2725, "Undef"
  vivify_1631:
    $P2726 = $P2719."new"($P2724, $P2725, "if" :named("pasttype"))
.annotate 'line', 858
    $P2715."push"($P2726)
.annotate 'line', 867
    find_lex $P2727, "$unit"
    unless_null $P2727, vivify_1632
    new $P2727, "Undef"
  vivify_1632:
.annotate 'line', 868
    get_hll_global $P2728, "GLOBAL"
    nqp_get_package_through_who $P2729, $P2728, "PAST"
    get_who $P2730, $P2729
    set $P2731, $P2730["Op"]
    find_lex $P2732, "$mainline"
    unless_null $P2732, vivify_1633
    new $P2732, "Undef"
  vivify_1633:
    $P2733 = $P2731."new"($P2732, "return" :named("pirop"))
    $P2727."push"($P2733)
.annotate 'line', 873
    find_lex $P2734, "$unit"
    unless_null $P2734, vivify_1634
    new $P2734, "Undef"
  vivify_1634:
.annotate 'line', 874
    get_hll_global $P2735, "GLOBAL"
    nqp_get_package_through_who $P2736, $P2735, "PAST"
    get_who $P2737, $P2736
    set $P2738, $P2737["Block"]
.annotate 'line', 876
    get_hll_global $P2739, "GLOBAL"
    nqp_get_package_through_who $P2740, $P2739, "PAST"
    get_who $P2741, $P2740
    set $P2742, $P2741["Op"]
    get_hll_global $P2743, "GLOBAL"
    nqp_get_package_through_who $P2744, $P2743, "PAST"
    get_who $P2745, $P2744
    set $P2746, $P2745["Val"]
    find_lex $P2747, "$unit"
    unless_null $P2747, vivify_1635
    new $P2747, "Undef"
  vivify_1635:
    $P2748 = $P2746."new"($P2747 :named("value"))
    $P2749 = $P2742."new"($P2748, "call" :named("pasttype"))
    $P2750 = $P2738."new"($P2749, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 874
    $P2734."push"($P2750)
.annotate 'line', 879
    find_lex $P2751, "$unit"
    unless_null $P2751, vivify_1636
    new $P2751, "Undef"
  vivify_1636:
    find_lex $P2752, "$/"
    unless_null $P2752, vivify_1637
    new $P2752, "Undef"
  vivify_1637:
    $P2751."node"($P2752)
.annotate 'line', 882
    find_lex $P2753, "$unit"
    unless_null $P2753, vivify_1638
    new $P2753, "Undef"
  vivify_1638:
    $P2753."hll"("nqp")
.annotate 'line', 884
    find_lex $P2754, "$/"
    find_lex $P2755, "$unit"
    unless_null $P2755, vivify_1639
    new $P2755, "Undef"
  vivify_1639:
    $P2756 = $P2754."!make"($P2755)
.annotate 'line', 812
    .return ($P2756)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("436_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2758
    .param pmc param_2759
.annotate 'line', 887
    .const 'Sub' $P2776 = "437_1304516047.681" 
    capture_lex $P2776
    .lex "self", param_2758
    .lex "$/", param_2759
.annotate 'line', 888
    new $P2760, "Undef"
    .lex "$past", $P2760
    get_hll_global $P2761, "GLOBAL"
    nqp_get_package_through_who $P2762, $P2761, "PAST"
    get_who $P2763, $P2762
    set $P2764, $P2763["Stmts"]
    find_lex $P2765, "$/"
    unless_null $P2765, vivify_1640
    new $P2765, "Undef"
  vivify_1640:
    $P2766 = $P2764."new"($P2765 :named("node"))
    store_lex "$past", $P2766
.annotate 'line', 889
    find_lex $P2768, "$/"
    unless_null $P2768, vivify_1641
    $P2768 = root_new ['parrot';'Hash']
  vivify_1641:
    set $P2769, $P2768["statement"]
    unless_null $P2769, vivify_1642
    new $P2769, "Undef"
  vivify_1642:
    unless $P2769, if_2767_end
.annotate 'line', 890
    find_lex $P2771, "$/"
    unless_null $P2771, vivify_1643
    $P2771 = root_new ['parrot';'Hash']
  vivify_1643:
    set $P2772, $P2771["statement"]
    unless_null $P2772, vivify_1644
    new $P2772, "Undef"
  vivify_1644:
    defined $I2773, $P2772
    unless $I2773, for_undef_1645
    iter $P2770, $P2772
    new $P2796, 'ExceptionHandler'
    set_label $P2796, loop2795_handler
    $P2796."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2796
  loop2795_test:
    unless $P2770, loop2795_done
    shift $P2774, $P2770
  loop2795_redo:
    .const 'Sub' $P2776 = "437_1304516047.681" 
    capture_lex $P2776
    $P2776($P2774)
  loop2795_next:
    goto loop2795_test
  loop2795_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2797, exception, 'type'
    eq $P2797, .CONTROL_LOOP_NEXT, loop2795_next
    eq $P2797, .CONTROL_LOOP_REDO, loop2795_redo
  loop2795_done:
    pop_eh 
  for_undef_1645:
  if_2767_end:
.annotate 'line', 897
    find_lex $P2798, "$/"
    find_lex $P2799, "$past"
    unless_null $P2799, vivify_1656
    new $P2799, "Undef"
  vivify_1656:
    $P2800 = $P2798."!make"($P2799)
.annotate 'line', 887
    .return ($P2800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2775"  :anon :subid("437_1304516047.681") :outer("436_1304516047.681")
    .param pmc param_2778
.annotate 'line', 891
    new $P2777, "Undef"
    .lex "$ast", $P2777
    .lex "$_", param_2778
    find_lex $P2779, "$_"
    unless_null $P2779, vivify_1646
    new $P2779, "Undef"
  vivify_1646:
    $P2780 = $P2779."ast"()
    store_lex "$ast", $P2780
.annotate 'line', 892
    find_lex $P2782, "$ast"
    unless_null $P2782, vivify_1647
    $P2782 = root_new ['parrot';'Hash']
  vivify_1647:
    set $P2783, $P2782["sink"]
    unless_null $P2783, vivify_1648
    new $P2783, "Undef"
  vivify_1648:
    defined $I2784, $P2783
    unless $I2784, if_2781_end
    find_lex $P2785, "$ast"
    unless_null $P2785, vivify_1649
    $P2785 = root_new ['parrot';'Hash']
  vivify_1649:
    set $P2786, $P2785["sink"]
    unless_null $P2786, vivify_1650
    new $P2786, "Undef"
  vivify_1650:
    store_lex "$ast", $P2786
  if_2781_end:
.annotate 'line', 893
    find_lex $P2788, "$ast"
    unless_null $P2788, vivify_1651
    $P2788 = root_new ['parrot';'Hash']
  vivify_1651:
    set $P2789, $P2788["bareblock"]
    unless_null $P2789, vivify_1652
    new $P2789, "Undef"
  vivify_1652:
    unless $P2789, if_2787_end
    find_lex $P2790, "$ast"
    unless_null $P2790, vivify_1653
    new $P2790, "Undef"
  vivify_1653:
    $P2791 = "block_immediate"($P2790)
    store_lex "$ast", $P2791
  if_2787_end:
.annotate 'line', 894
    find_lex $P2792, "$past"
    unless_null $P2792, vivify_1654
    new $P2792, "Undef"
  vivify_1654:
    find_lex $P2793, "$ast"
    unless_null $P2793, vivify_1655
    new $P2793, "Undef"
  vivify_1655:
    $P2794 = $P2792."push"($P2793)
.annotate 'line', 890
    .return ($P2794)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("438_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2802
    .param pmc param_2803
    .param pmc param_2804 :optional
    .param int has_param_2804 :opt_flag
.annotate 'line', 900
    .const 'Sub' $P2812 = "439_1304516047.681" 
    capture_lex $P2812
    .lex "self", param_2802
    .lex "$/", param_2803
    if has_param_2804, optparam_1657
    new $P2805, "Undef"
    set param_2804, $P2805
  optparam_1657:
    .lex "$key", param_2804
.annotate 'line', 901
    new $P2806, "Undef"
    .lex "$past", $P2806
.annotate 'line', 900
    find_lex $P2807, "$past"
    unless_null $P2807, vivify_1658
    new $P2807, "Undef"
  vivify_1658:
.annotate 'line', 902
    find_lex $P2809, "$/"
    unless_null $P2809, vivify_1659
    $P2809 = root_new ['parrot';'Hash']
  vivify_1659:
    set $P2810, $P2809["EXPR"]
    unless_null $P2810, vivify_1660
    new $P2810, "Undef"
  vivify_1660:
    if $P2810, if_2808
.annotate 'line', 923
    find_lex $P2888, "$/"
    unless_null $P2888, vivify_1661
    $P2888 = root_new ['parrot';'Hash']
  vivify_1661:
    set $P2889, $P2888["statement_control"]
    unless_null $P2889, vivify_1662
    new $P2889, "Undef"
  vivify_1662:
    if $P2889, if_2887
.annotate 'line', 924
    new $P2893, "Integer"
    assign $P2893, 0
    store_lex "$past", $P2893
    goto if_2887_end
  if_2887:
.annotate 'line', 923
    find_lex $P2890, "$/"
    unless_null $P2890, vivify_1663
    $P2890 = root_new ['parrot';'Hash']
  vivify_1663:
    set $P2891, $P2890["statement_control"]
    unless_null $P2891, vivify_1664
    new $P2891, "Undef"
  vivify_1664:
    $P2892 = $P2891."ast"()
    store_lex "$past", $P2892
  if_2887_end:
    goto if_2808_end
  if_2808:
.annotate 'line', 902
    .const 'Sub' $P2812 = "439_1304516047.681" 
    capture_lex $P2812
    $P2812()
  if_2808_end:
.annotate 'line', 925
    find_lex $P2894, "$/"
    find_lex $P2895, "$past"
    unless_null $P2895, vivify_1698
    new $P2895, "Undef"
  vivify_1698:
    $P2896 = $P2894."!make"($P2895)
.annotate 'line', 900
    .return ($P2896)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2811"  :anon :subid("439_1304516047.681") :outer("438_1304516047.681")
.annotate 'line', 903
    new $P2813, "Undef"
    .lex "$mc", $P2813
.annotate 'line', 904
    new $P2814, "Undef"
    .lex "$ml", $P2814
.annotate 'line', 903
    find_lex $P2815, "$/"
    unless_null $P2815, vivify_1665
    $P2815 = root_new ['parrot';'Hash']
  vivify_1665:
    set $P2816, $P2815["statement_mod_cond"]
    unless_null $P2816, vivify_1666
    $P2816 = root_new ['parrot';'ResizablePMCArray']
  vivify_1666:
    set $P2817, $P2816[0]
    unless_null $P2817, vivify_1667
    new $P2817, "Undef"
  vivify_1667:
    store_lex "$mc", $P2817
.annotate 'line', 904
    find_lex $P2818, "$/"
    unless_null $P2818, vivify_1668
    $P2818 = root_new ['parrot';'Hash']
  vivify_1668:
    set $P2819, $P2818["statement_mod_loop"]
    unless_null $P2819, vivify_1669
    $P2819 = root_new ['parrot';'ResizablePMCArray']
  vivify_1669:
    set $P2820, $P2819[0]
    unless_null $P2820, vivify_1670
    new $P2820, "Undef"
  vivify_1670:
    store_lex "$ml", $P2820
.annotate 'line', 905
    find_lex $P2821, "$/"
    unless_null $P2821, vivify_1671
    $P2821 = root_new ['parrot';'Hash']
  vivify_1671:
    set $P2822, $P2821["EXPR"]
    unless_null $P2822, vivify_1672
    new $P2822, "Undef"
  vivify_1672:
    $P2823 = $P2822."ast"()
    store_lex "$past", $P2823
.annotate 'line', 906
    find_lex $P2825, "$mc"
    unless_null $P2825, vivify_1673
    new $P2825, "Undef"
  vivify_1673:
    unless $P2825, if_2824_end
.annotate 'line', 907
    get_hll_global $P2826, "GLOBAL"
    nqp_get_package_through_who $P2827, $P2826, "PAST"
    get_who $P2828, $P2827
    set $P2829, $P2828["Op"]
    find_lex $P2830, "$mc"
    unless_null $P2830, vivify_1674
    $P2830 = root_new ['parrot';'Hash']
  vivify_1674:
    set $P2831, $P2830["cond"]
    unless_null $P2831, vivify_1675
    new $P2831, "Undef"
  vivify_1675:
    $P2832 = $P2831."ast"()
    find_lex $P2833, "$past"
    unless_null $P2833, vivify_1676
    new $P2833, "Undef"
  vivify_1676:
    find_lex $P2834, "$mc"
    unless_null $P2834, vivify_1677
    $P2834 = root_new ['parrot';'Hash']
  vivify_1677:
    set $P2835, $P2834["sym"]
    unless_null $P2835, vivify_1678
    new $P2835, "Undef"
  vivify_1678:
    set $S2836, $P2835
    find_lex $P2837, "$/"
    unless_null $P2837, vivify_1679
    new $P2837, "Undef"
  vivify_1679:
    $P2838 = $P2829."new"($P2832, $P2833, $S2836 :named("pasttype"), $P2837 :named("node"))
    store_lex "$past", $P2838
  if_2824_end:
.annotate 'line', 909
    find_lex $P2841, "$ml"
    unless_null $P2841, vivify_1680
    new $P2841, "Undef"
  vivify_1680:
    if $P2841, if_2840
    set $P2839, $P2841
    goto if_2840_end
  if_2840:
.annotate 'line', 910
    find_lex $P2844, "$ml"
    unless_null $P2844, vivify_1681
    $P2844 = root_new ['parrot';'Hash']
  vivify_1681:
    set $P2845, $P2844["sym"]
    unless_null $P2845, vivify_1682
    new $P2845, "Undef"
  vivify_1682:
    set $S2846, $P2845
    iseq $I2847, $S2846, "for"
    if $I2847, if_2843
.annotate 'line', 919
    get_hll_global $P2874, "GLOBAL"
    nqp_get_package_through_who $P2875, $P2874, "PAST"
    get_who $P2876, $P2875
    set $P2877, $P2876["Op"]
    find_lex $P2878, "$ml"
    unless_null $P2878, vivify_1683
    $P2878 = root_new ['parrot';'Hash']
  vivify_1683:
    set $P2879, $P2878["cond"]
    unless_null $P2879, vivify_1684
    new $P2879, "Undef"
  vivify_1684:
    $P2880 = $P2879."ast"()
    find_lex $P2881, "$past"
    unless_null $P2881, vivify_1685
    new $P2881, "Undef"
  vivify_1685:
    find_lex $P2882, "$ml"
    unless_null $P2882, vivify_1686
    $P2882 = root_new ['parrot';'Hash']
  vivify_1686:
    set $P2883, $P2882["sym"]
    unless_null $P2883, vivify_1687
    new $P2883, "Undef"
  vivify_1687:
    set $S2884, $P2883
    find_lex $P2885, "$/"
    unless_null $P2885, vivify_1688
    new $P2885, "Undef"
  vivify_1688:
    $P2886 = $P2877."new"($P2880, $P2881, $S2884 :named("pasttype"), $P2885 :named("node"))
    store_lex "$past", $P2886
.annotate 'line', 918
    set $P2842, $P2886
.annotate 'line', 910
    goto if_2843_end
  if_2843:
.annotate 'line', 911
    get_hll_global $P2848, "GLOBAL"
    nqp_get_package_through_who $P2849, $P2848, "PAST"
    get_who $P2850, $P2849
    set $P2851, $P2850["Block"]
.annotate 'line', 912
    get_hll_global $P2852, "GLOBAL"
    nqp_get_package_through_who $P2853, $P2852, "PAST"
    get_who $P2854, $P2853
    set $P2855, $P2854["Var"]
    $P2856 = $P2855."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P2857, "$past"
    unless_null $P2857, vivify_1689
    new $P2857, "Undef"
  vivify_1689:
    $P2858 = $P2851."new"($P2856, $P2857, "immediate" :named("blocktype"))
.annotate 'line', 911
    store_lex "$past", $P2858
.annotate 'line', 914
    find_lex $P2859, "$past"
    unless_null $P2859, vivify_1690
    new $P2859, "Undef"
  vivify_1690:
    $P2859."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 915
    find_lex $P2860, "$past"
    unless_null $P2860, vivify_1691
    new $P2860, "Undef"
  vivify_1691:
    $P2860."arity"(1)
.annotate 'line', 916
    get_hll_global $P2861, "GLOBAL"
    nqp_get_package_through_who $P2862, $P2861, "PAST"
    get_who $P2863, $P2862
    set $P2864, $P2863["Op"]
    find_lex $P2865, "$ml"
    unless_null $P2865, vivify_1692
    $P2865 = root_new ['parrot';'Hash']
  vivify_1692:
    set $P2866, $P2865["cond"]
    unless_null $P2866, vivify_1693
    new $P2866, "Undef"
  vivify_1693:
    $P2867 = $P2866."ast"()
    find_lex $P2868, "$past"
    unless_null $P2868, vivify_1694
    new $P2868, "Undef"
  vivify_1694:
    find_lex $P2869, "$ml"
    unless_null $P2869, vivify_1695
    $P2869 = root_new ['parrot';'Hash']
  vivify_1695:
    set $P2870, $P2869["sym"]
    unless_null $P2870, vivify_1696
    new $P2870, "Undef"
  vivify_1696:
    set $S2871, $P2870
    find_lex $P2872, "$/"
    unless_null $P2872, vivify_1697
    new $P2872, "Undef"
  vivify_1697:
    $P2873 = $P2864."new"($P2867, $P2868, $S2871 :named("pasttype"), $P2872 :named("node"))
    store_lex "$past", $P2873
.annotate 'line', 910
    set $P2842, $P2873
  if_2843_end:
.annotate 'line', 909
    set $P2839, $P2842
  if_2840_end:
.annotate 'line', 902
    .return ($P2839)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("440_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2898
    .param pmc param_2899
.annotate 'line', 928
    .lex "self", param_2898
    .lex "$/", param_2899
.annotate 'line', 929
    find_lex $P2900, "$/"
    get_hll_global $P2901, "GLOBAL"
    nqp_get_package_through_who $P2902, $P2901, "PAST"
    get_who $P2903, $P2902
    set $P2904, $P2903["Op"]
    find_lex $P2905, "$/"
    unless_null $P2905, vivify_1699
    $P2905 = root_new ['parrot';'Hash']
  vivify_1699:
    set $P2906, $P2905["EXPR"]
    unless_null $P2906, vivify_1700
    new $P2906, "Undef"
  vivify_1700:
    $P2907 = $P2906."ast"()
    find_lex $P2908, "$/"
    unless_null $P2908, vivify_1701
    $P2908 = root_new ['parrot';'Hash']
  vivify_1701:
    set $P2909, $P2908["pblock"]
    unless_null $P2909, vivify_1702
    new $P2909, "Undef"
  vivify_1702:
    $P2910 = $P2909."ast"()
    find_lex $P2911, "$/"
    unless_null $P2911, vivify_1703
    new $P2911, "Undef"
  vivify_1703:
    $P2912 = $P2904."new"($P2907, $P2910, "if" :named("pasttype"), $P2911 :named("node"))
    $P2913 = $P2900."!make"($P2912)
.annotate 'line', 928
    .return ($P2913)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("441_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2915
    .param pmc param_2916
.annotate 'line', 932
    .lex "self", param_2915
    .lex "$/", param_2916
.annotate 'line', 933
    find_lex $P2917, "$/"
    find_lex $P2918, "$/"
    unless_null $P2918, vivify_1704
    $P2918 = root_new ['parrot';'Hash']
  vivify_1704:
    set $P2919, $P2918["blockoid"]
    unless_null $P2919, vivify_1705
    new $P2919, "Undef"
  vivify_1705:
    $P2920 = $P2919."ast"()
    $P2921 = $P2917."!make"($P2920)
.annotate 'line', 932
    .return ($P2921)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("442_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2923
    .param pmc param_2924
.annotate 'line', 936
    .lex "self", param_2923
    .lex "$/", param_2924
.annotate 'line', 937
    find_lex $P2925, "$/"
    find_lex $P2926, "$/"
    unless_null $P2926, vivify_1706
    $P2926 = root_new ['parrot';'Hash']
  vivify_1706:
    set $P2927, $P2926["blockoid"]
    unless_null $P2927, vivify_1707
    new $P2927, "Undef"
  vivify_1707:
    $P2928 = $P2927."ast"()
    $P2929 = $P2925."!make"($P2928)
.annotate 'line', 936
    .return ($P2929)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("443_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2931
    .param pmc param_2932
.annotate 'line', 940
    .const 'Sub' $P2943 = "444_1304516047.681" 
    capture_lex $P2943
    .lex "self", param_2931
    .lex "$/", param_2932
.annotate 'line', 941
    new $P2933, "Undef"
    .lex "$BLOCK", $P2933
    find_lex $P2934, "$?PACKAGE"
    get_who $P2935, $P2934
    set $P2936, $P2935["@BLOCK"]
    unless_null $P2936, vivify_1708
    $P2936 = root_new ['parrot';'ResizablePMCArray']
  vivify_1708:
    $P2937 = $P2936."shift"()
    store_lex "$BLOCK", $P2937
.annotate 'line', 942
    find_lex $P2940, "$/"
    unless_null $P2940, vivify_1709
    $P2940 = root_new ['parrot';'Hash']
  vivify_1709:
    set $P2941, $P2940["statementlist"]
    unless_null $P2941, vivify_1710
    new $P2941, "Undef"
  vivify_1710:
    if $P2941, if_2939
.annotate 'line', 950
    find_dynamic_lex $P2960, "$*HAS_YOU_ARE_HERE"
    unless_null $P2960, vivify_1711
    get_hll_global $P2958, "GLOBAL"
    get_who $P2959, $P2958
    set $P2960, $P2959["$HAS_YOU_ARE_HERE"]
    unless_null $P2960, vivify_1712
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1712:
  vivify_1711:
    unless $P2960, if_2957_end
.annotate 'line', 951
    find_lex $P2961, "$/"
    unless_null $P2961, vivify_1713
    new $P2961, "Undef"
  vivify_1713:
    $P2962 = $P2961."CURSOR"()
    $P2962."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_2957_end:
.annotate 'line', 953
    new $P2963, "Integer"
    assign $P2963, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P2963
.annotate 'line', 954
    find_lex $P2964, "$/"
    find_lex $P2965, "$/"
    unless_null $P2965, vivify_1714
    $P2965 = root_new ['parrot';'Hash']
  vivify_1714:
    set $P2966, $P2965["you_are_here"]
    unless_null $P2966, vivify_1715
    new $P2966, "Undef"
  vivify_1715:
    $P2967 = $P2966."ast"()
    $P2968 = $P2964."!make"($P2967)
.annotate 'line', 949
    set $P2938, $P2968
.annotate 'line', 942
    goto if_2939_end
  if_2939:
    .const 'Sub' $P2943 = "444_1304516047.681" 
    capture_lex $P2943
    $P2956 = $P2943()
    set $P2938, $P2956
  if_2939_end:
.annotate 'line', 940
    .return ($P2938)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2942"  :anon :subid("444_1304516047.681") :outer("443_1304516047.681")
.annotate 'line', 943
    new $P2944, "Undef"
    .lex "$past", $P2944
    find_lex $P2945, "$/"
    unless_null $P2945, vivify_1716
    $P2945 = root_new ['parrot';'Hash']
  vivify_1716:
    set $P2946, $P2945["statementlist"]
    unless_null $P2946, vivify_1717
    new $P2946, "Undef"
  vivify_1717:
    $P2947 = $P2946."ast"()
    store_lex "$past", $P2947
.annotate 'line', 944
    find_lex $P2948, "$BLOCK"
    unless_null $P2948, vivify_1718
    new $P2948, "Undef"
  vivify_1718:
    find_lex $P2949, "$past"
    unless_null $P2949, vivify_1719
    new $P2949, "Undef"
  vivify_1719:
    $P2948."push"($P2949)
.annotate 'line', 945
    find_lex $P2950, "$BLOCK"
    unless_null $P2950, vivify_1720
    new $P2950, "Undef"
  vivify_1720:
    find_lex $P2951, "$/"
    unless_null $P2951, vivify_1721
    new $P2951, "Undef"
  vivify_1721:
    $P2950."node"($P2951)
.annotate 'line', 946
    find_lex $P2952, "$BLOCK"
    unless_null $P2952, vivify_1722
    new $P2952, "Undef"
  vivify_1722:
    $P2952."closure"(1)
.annotate 'line', 947
    find_dynamic_lex $P2953, "$/"
    find_lex $P2954, "$BLOCK"
    unless_null $P2954, vivify_1723
    new $P2954, "Undef"
  vivify_1723:
    $P2955 = $P2953."!make"($P2954)
.annotate 'line', 942
    .return ($P2955)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("445_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2970
    .param pmc param_2971
.annotate 'line', 958
    .lex "self", param_2970
    .lex "$/", param_2971
.annotate 'line', 959
    find_lex $P2972, "$?PACKAGE"
    get_who $P2973, $P2972
    set $P2974, $P2973["@BLOCK"]
    unless_null $P2974, vivify_1724
    $P2974 = root_new ['parrot';'ResizablePMCArray']
  vivify_1724:
    get_hll_global $P2975, "GLOBAL"
    nqp_get_package_through_who $P2976, $P2975, "PAST"
    get_who $P2977, $P2976
    set $P2978, $P2977["Block"]
    get_hll_global $P2979, "GLOBAL"
    nqp_get_package_through_who $P2980, $P2979, "PAST"
    get_who $P2981, $P2980
    set $P2982, $P2981["Stmts"]
    $P2983 = $P2982."new"()
    $P2984 = $P2978."new"($P2983)
    $P2985 = $P2974."unshift"($P2984)
.annotate 'line', 958
    .return ($P2985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("446_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_2987
    .param pmc param_2988
.annotate 'line', 962
    .const 'Sub' $P2997 = "447_1304516047.681" 
    capture_lex $P2997
    .lex "self", param_2987
    .lex "$/", param_2988
.annotate 'line', 963
    find_dynamic_lex $P2992, "%*COMPILING"
    unless_null $P2992, vivify_1725
    get_hll_global $P2990, "GLOBAL"
    get_who $P2991, $P2990
    set $P2992, $P2991["%COMPILING"]
    unless_null $P2992, vivify_1726
    die "Contextual %*COMPILING not found"
  vivify_1726:
  vivify_1725:
    set $P2993, $P2992["%?OPTIONS"]
    unless_null $P2993, vivify_1727
    $P2993 = root_new ['parrot';'Hash']
  vivify_1727:
    set $P2994, $P2993["outer_ctx"]
    unless_null $P2994, vivify_1728
    new $P2994, "Undef"
  vivify_1728:
    defined $I2995, $P2994
    if $I2995, unless_2989_end
    .const 'Sub' $P2997 = "447_1304516047.681" 
    capture_lex $P2997
    $P2997()
  unless_2989_end:
.annotate 'line', 976
    find_lex $P3029, "self"
    find_lex $P3030, "$?PACKAGE"
    get_who $P3031, $P3030
    set $P3032, $P3031["@BLOCK"]
    unless_null $P3032, vivify_1744
    $P3032 = root_new ['parrot';'ResizablePMCArray']
  vivify_1744:
    set $P3033, $P3032[0]
    unless_null $P3033, vivify_1745
    new $P3033, "Undef"
  vivify_1745:
    $P3034 = $P3029."SET_BLOCK_OUTER_CTX"($P3033)
.annotate 'line', 962
    .return ($P3034)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2996"  :anon :subid("447_1304516047.681") :outer("446_1304516047.681")
.annotate 'line', 966
    new $P2998, "Undef"
    .lex "$SETTING", $P2998
    find_dynamic_lex $P3001, "$*SC"
    unless_null $P3001, vivify_1729
    get_hll_global $P2999, "GLOBAL"
    get_who $P3000, $P2999
    set $P3001, $P3000["$SC"]
    unless_null $P3001, vivify_1730
    die "Contextual $*SC not found"
  vivify_1730:
  vivify_1729:
    find_dynamic_lex $P3005, "%*COMPILING"
    unless_null $P3005, vivify_1731
    get_hll_global $P3003, "GLOBAL"
    get_who $P3004, $P3003
    set $P3005, $P3004["%COMPILING"]
    unless_null $P3005, vivify_1732
    die "Contextual %*COMPILING not found"
  vivify_1732:
  vivify_1731:
    set $P3006, $P3005["%?OPTIONS"]
    unless_null $P3006, vivify_1733
    $P3006 = root_new ['parrot';'Hash']
  vivify_1733:
    set $P3007, $P3006["setting"]
    unless_null $P3007, vivify_1734
    new $P3007, "Undef"
  vivify_1734:
    set $P3002, $P3007
    defined $I3009, $P3002
    if $I3009, default_3008
    new $P3010, "String"
    assign $P3010, "NQPCORE"
    set $P3002, $P3010
  default_3008:
    $P3011 = $P3001."load_setting"($P3002)
    store_lex "$SETTING", $P3011
.annotate 'line', 971
    find_dynamic_lex $P3016, "%*COMPILING"
    unless_null $P3016, vivify_1735
    get_hll_global $P3014, "GLOBAL"
    get_who $P3015, $P3014
    set $P3016, $P3015["%COMPILING"]
    unless_null $P3016, vivify_1736
    die "Contextual %*COMPILING not found"
  vivify_1736:
  vivify_1735:
    set $P3017, $P3016["%?OPTIONS"]
    unless_null $P3017, vivify_1737
    $P3017 = root_new ['parrot';'Hash']
  vivify_1737:
    set $P3018, $P3017["setting"]
    unless_null $P3018, vivify_1738
    new $P3018, "Undef"
  vivify_1738:
    set $S3019, $P3018
    iseq $I3020, $S3019, "NULL"
    unless $I3020, unless_3013
    new $P3012, 'Integer'
    set $P3012, $I3020
    goto unless_3013_end
  unless_3013:
.annotate 'line', 972
    find_lex $P3021, "$SETTING"
    unless_null $P3021, vivify_1739
    new $P3021, "Undef"
  vivify_1739:
    "import_HOW_exports"($P3021)
.annotate 'line', 973
    find_dynamic_lex $P3024, "$*SC"
    unless_null $P3024, vivify_1740
    get_hll_global $P3022, "GLOBAL"
    get_who $P3023, $P3022
    set $P3024, $P3023["$SC"]
    unless_null $P3024, vivify_1741
    die "Contextual $*SC not found"
  vivify_1741:
  vivify_1740:
    find_dynamic_lex $P3027, "$*GLOBALish"
    unless_null $P3027, vivify_1742
    get_hll_global $P3025, "GLOBAL"
    get_who $P3026, $P3025
    set $P3027, $P3026["$GLOBALish"]
    unless_null $P3027, vivify_1743
    die "Contextual $*GLOBALish not found"
  vivify_1743:
  vivify_1742:
    $P3028 = $P3024."load_module"("NQPRegex", $P3027)
.annotate 'line', 971
    set $P3012, $P3028
  unless_3013_end:
.annotate 'line', 963
    .return ($P3012)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "GLOBALish"  :subid("448_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3037
    .param pmc param_3038
.annotate 'line', 988
    .lex "self", param_3037
    .lex "$/", param_3038
.annotate 'line', 992
    find_dynamic_lex $P3041, "$*SC"
    unless_null $P3041, vivify_1746
    get_hll_global $P3039, "GLOBAL"
    get_who $P3040, $P3039
    set $P3041, $P3040["$SC"]
    unless_null $P3041, vivify_1747
    die "Contextual $*SC not found"
  vivify_1747:
  vivify_1746:
    find_dynamic_lex $P3044, "%*HOW"
    unless_null $P3044, vivify_1748
    get_hll_global $P3042, "GLOBAL"
    get_who $P3043, $P3042
    set $P3044, $P3043["%HOW"]
    unless_null $P3044, vivify_1749
    die "Contextual %*HOW not found"
  vivify_1749:
  vivify_1748:
    set $P3045, $P3044["knowhow"]
    unless_null $P3045, vivify_1750
    new $P3045, "Undef"
  vivify_1750:
    $P3046 = $P3041."pkg_create_mo"($P3045, "GLOBALish" :named("name"))
    store_dynamic_lex "$*GLOBALish", $P3046
.annotate 'line', 993
    find_dynamic_lex $P3049, "$*GLOBALish"
    unless_null $P3049, vivify_1751
    get_hll_global $P3047, "GLOBAL"
    get_who $P3048, $P3047
    set $P3049, $P3048["$GLOBALish"]
    unless_null $P3049, vivify_1752
    die "Contextual $*GLOBALish not found"
  vivify_1752:
  vivify_1751:
    get_how $P3050, $P3049
    find_dynamic_lex $P3053, "$*GLOBALish"
    unless_null $P3053, vivify_1753
    get_hll_global $P3051, "GLOBAL"
    get_who $P3052, $P3051
    set $P3053, $P3052["$GLOBALish"]
    unless_null $P3053, vivify_1754
    die "Contextual $*GLOBALish not found"
  vivify_1754:
  vivify_1753:
    $P3050."compose"($P3053)
.annotate 'line', 994
    find_dynamic_lex $P3056, "$*SC"
    unless_null $P3056, vivify_1755
    get_hll_global $P3054, "GLOBAL"
    get_who $P3055, $P3054
    set $P3056, $P3055["$SC"]
    unless_null $P3056, vivify_1756
    die "Contextual $*SC not found"
  vivify_1756:
  vivify_1755:
    find_lex $P3057, "$?PACKAGE"
    get_who $P3058, $P3057
    set $P3059, $P3058["@BLOCK"]
    unless_null $P3059, vivify_1757
    $P3059 = root_new ['parrot';'ResizablePMCArray']
  vivify_1757:
    set $P3060, $P3059[0]
    unless_null $P3060, vivify_1758
    new $P3060, "Undef"
  vivify_1758:
    find_dynamic_lex $P3063, "$*GLOBALish"
    unless_null $P3063, vivify_1759
    get_hll_global $P3061, "GLOBAL"
    get_who $P3062, $P3061
    set $P3063, $P3062["$GLOBALish"]
    unless_null $P3063, vivify_1760
    die "Contextual $*GLOBALish not found"
  vivify_1760:
  vivify_1759:
    $P3056."install_lexical_symbol"($P3060, "GLOBALish", $P3063)
.annotate 'line', 997
    find_dynamic_lex $P3066, "$*GLOBALish"
    unless_null $P3066, vivify_1761
    get_hll_global $P3064, "GLOBAL"
    get_who $P3065, $P3064
    set $P3066, $P3065["$GLOBALish"]
    unless_null $P3066, vivify_1762
    die "Contextual $*GLOBALish not found"
  vivify_1762:
  vivify_1761:
    store_dynamic_lex "$*PACKAGE", $P3066
.annotate 'line', 998
    find_dynamic_lex $P3069, "$*SC"
    unless_null $P3069, vivify_1763
    get_hll_global $P3067, "GLOBAL"
    get_who $P3068, $P3067
    set $P3069, $P3068["$SC"]
    unless_null $P3069, vivify_1764
    die "Contextual $*SC not found"
  vivify_1764:
  vivify_1763:
    find_lex $P3070, "$?PACKAGE"
    get_who $P3071, $P3070
    set $P3072, $P3071["@BLOCK"]
    unless_null $P3072, vivify_1765
    $P3072 = root_new ['parrot';'ResizablePMCArray']
  vivify_1765:
    set $P3073, $P3072[0]
    unless_null $P3073, vivify_1766
    new $P3073, "Undef"
  vivify_1766:
    find_dynamic_lex $P3076, "$*PACKAGE"
    unless_null $P3076, vivify_1767
    get_hll_global $P3074, "GLOBAL"
    get_who $P3075, $P3074
    set $P3076, $P3075["$PACKAGE"]
    unless_null $P3076, vivify_1768
    die "Contextual $*PACKAGE not found"
  vivify_1768:
  vivify_1767:
    $P3077 = $P3069."install_lexical_symbol"($P3073, "$?PACKAGE", $P3076)
.annotate 'line', 988
    .return ($P3077)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("449_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3079
    .param pmc param_3080
.annotate 'line', 1001
    .lex "self", param_3079
    .lex "$/", param_3080
.annotate 'line', 1002
    find_lex $P3081, "$/"
    find_lex $P3082, "self"
    $P3083 = $P3082."CTXSAVE"()
    $P3084 = $P3081."!make"($P3083)
.annotate 'line', 1001
    .return ($P3084)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("450_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3086
    .param pmc param_3087
.annotate 'line', 1007
    .lex "self", param_3086
    .lex "$/", param_3087
.annotate 'line', 1008
    new $P3088, "Undef"
    .lex "$module", $P3088
    find_dynamic_lex $P3091, "$*SC"
    unless_null $P3091, vivify_1769
    get_hll_global $P3089, "GLOBAL"
    get_who $P3090, $P3089
    set $P3091, $P3090["$SC"]
    unless_null $P3091, vivify_1770
    die "Contextual $*SC not found"
  vivify_1770:
  vivify_1769:
    find_lex $P3092, "$/"
    unless_null $P3092, vivify_1771
    $P3092 = root_new ['parrot';'Hash']
  vivify_1771:
    set $P3093, $P3092["name"]
    unless_null $P3093, vivify_1772
    new $P3093, "Undef"
  vivify_1772:
    set $S3094, $P3093
    find_dynamic_lex $P3097, "$*GLOBALish"
    unless_null $P3097, vivify_1773
    get_hll_global $P3095, "GLOBAL"
    get_who $P3096, $P3095
    set $P3097, $P3096["$GLOBALish"]
    unless_null $P3097, vivify_1774
    die "Contextual $*GLOBALish not found"
  vivify_1774:
  vivify_1773:
    $P3098 = $P3091."load_module"($S3094, $P3097)
    store_lex "$module", $P3098
.annotate 'line', 1009
    find_lex $P3100, "$module"
    unless_null $P3100, vivify_1775
    new $P3100, "Undef"
  vivify_1775:
    defined $I3101, $P3100
    unless $I3101, if_3099_end
.annotate 'line', 1010
    find_lex $P3102, "$module"
    unless_null $P3102, vivify_1776
    new $P3102, "Undef"
  vivify_1776:
    "import_HOW_exports"($P3102)
  if_3099_end:
.annotate 'line', 1012
    find_lex $P3103, "$/"
    get_hll_global $P3104, "GLOBAL"
    nqp_get_package_through_who $P3105, $P3104, "PAST"
    get_who $P3106, $P3105
    set $P3107, $P3106["Stmts"]
    $P3108 = $P3107."new"()
    $P3109 = $P3103."!make"($P3108)
.annotate 'line', 1007
    .return ($P3109)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("451_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3111
    .param pmc param_3112
.annotate 'line', 1015
    .const 'Sub' $P3140 = "452_1304516047.681" 
    capture_lex $P3140
    .lex "self", param_3111
    .lex "$/", param_3112
.annotate 'line', 1016
    new $P3113, "Undef"
    .lex "$count", $P3113
.annotate 'line', 1017
    new $P3114, "Undef"
    .lex "$past", $P3114
.annotate 'line', 1016
    find_lex $P3115, "$/"
    unless_null $P3115, vivify_1777
    $P3115 = root_new ['parrot';'Hash']
  vivify_1777:
    set $P3116, $P3115["xblock"]
    unless_null $P3116, vivify_1778
    new $P3116, "Undef"
  vivify_1778:
    set $N3117, $P3116
    new $P3118, 'Float'
    set $P3118, $N3117
    sub $P3119, $P3118, 1
    store_lex "$count", $P3119
.annotate 'line', 1017
    find_lex $P3120, "$count"
    unless_null $P3120, vivify_1779
    new $P3120, "Undef"
  vivify_1779:
    set $I3121, $P3120
    find_lex $P3122, "$/"
    unless_null $P3122, vivify_1780
    $P3122 = root_new ['parrot';'Hash']
  vivify_1780:
    set $P3123, $P3122["xblock"]
    unless_null $P3123, vivify_1781
    $P3123 = root_new ['parrot';'ResizablePMCArray']
  vivify_1781:
    set $P3124, $P3123[$I3121]
    unless_null $P3124, vivify_1782
    new $P3124, "Undef"
  vivify_1782:
    $P3125 = $P3124."ast"()
    $P3126 = "xblock_immediate"($P3125)
    store_lex "$past", $P3126
.annotate 'line', 1018
    find_lex $P3128, "$/"
    unless_null $P3128, vivify_1783
    $P3128 = root_new ['parrot';'Hash']
  vivify_1783:
    set $P3129, $P3128["else"]
    unless_null $P3129, vivify_1784
    new $P3129, "Undef"
  vivify_1784:
    unless $P3129, if_3127_end
.annotate 'line', 1019
    find_lex $P3130, "$past"
    unless_null $P3130, vivify_1785
    new $P3130, "Undef"
  vivify_1785:
    find_lex $P3131, "$/"
    unless_null $P3131, vivify_1786
    $P3131 = root_new ['parrot';'Hash']
  vivify_1786:
    set $P3132, $P3131["else"]
    unless_null $P3132, vivify_1787
    $P3132 = root_new ['parrot';'ResizablePMCArray']
  vivify_1787:
    set $P3133, $P3132[0]
    unless_null $P3133, vivify_1788
    new $P3133, "Undef"
  vivify_1788:
    $P3134 = $P3133."ast"()
    $P3135 = "block_immediate"($P3134)
    $P3130."push"($P3135)
  if_3127_end:
.annotate 'line', 1022
    new $P3156, 'ExceptionHandler'
    set_label $P3156, loop3155_handler
    $P3156."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3156
  loop3155_test:
    find_lex $P3136, "$count"
    unless_null $P3136, vivify_1789
    new $P3136, "Undef"
  vivify_1789:
    set $N3137, $P3136
    isgt $I3138, $N3137, 0.0
    unless $I3138, loop3155_done
  loop3155_redo:
    .const 'Sub' $P3140 = "452_1304516047.681" 
    capture_lex $P3140
    $P3140()
  loop3155_next:
    goto loop3155_test
  loop3155_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3157, exception, 'type'
    eq $P3157, .CONTROL_LOOP_NEXT, loop3155_next
    eq $P3157, .CONTROL_LOOP_REDO, loop3155_redo
  loop3155_done:
    pop_eh 
.annotate 'line', 1028
    find_lex $P3158, "$/"
    find_lex $P3159, "$past"
    unless_null $P3159, vivify_1798
    new $P3159, "Undef"
  vivify_1798:
    $P3160 = $P3158."!make"($P3159)
.annotate 'line', 1015
    .return ($P3160)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3139"  :anon :subid("452_1304516047.681") :outer("451_1304516047.681")
.annotate 'line', 1024
    new $P3141, "Undef"
    .lex "$else", $P3141
.annotate 'line', 1022
    find_lex $P3142, "$count"
    unless_null $P3142, vivify_1790
    new $P3142, "Undef"
  vivify_1790:
    clone $P3143, $P3142
    dec $P3142
.annotate 'line', 1024
    find_lex $P3144, "$past"
    unless_null $P3144, vivify_1791
    new $P3144, "Undef"
  vivify_1791:
    store_lex "$else", $P3144
.annotate 'line', 1025
    find_lex $P3145, "$count"
    unless_null $P3145, vivify_1792
    new $P3145, "Undef"
  vivify_1792:
    set $I3146, $P3145
    find_lex $P3147, "$/"
    unless_null $P3147, vivify_1793
    $P3147 = root_new ['parrot';'Hash']
  vivify_1793:
    set $P3148, $P3147["xblock"]
    unless_null $P3148, vivify_1794
    $P3148 = root_new ['parrot';'ResizablePMCArray']
  vivify_1794:
    set $P3149, $P3148[$I3146]
    unless_null $P3149, vivify_1795
    new $P3149, "Undef"
  vivify_1795:
    $P3150 = $P3149."ast"()
    $P3151 = "xblock_immediate"($P3150)
    store_lex "$past", $P3151
.annotate 'line', 1026
    find_lex $P3152, "$past"
    unless_null $P3152, vivify_1796
    new $P3152, "Undef"
  vivify_1796:
    find_lex $P3153, "$else"
    unless_null $P3153, vivify_1797
    new $P3153, "Undef"
  vivify_1797:
    $P3154 = $P3152."push"($P3153)
.annotate 'line', 1022
    .return ($P3154)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("453_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3162
    .param pmc param_3163
.annotate 'line', 1031
    .lex "self", param_3162
    .lex "$/", param_3163
.annotate 'line', 1032
    new $P3164, "Undef"
    .lex "$past", $P3164
    find_lex $P3165, "$/"
    unless_null $P3165, vivify_1799
    $P3165 = root_new ['parrot';'Hash']
  vivify_1799:
    set $P3166, $P3165["xblock"]
    unless_null $P3166, vivify_1800
    new $P3166, "Undef"
  vivify_1800:
    $P3167 = $P3166."ast"()
    $P3168 = "xblock_immediate"($P3167)
    store_lex "$past", $P3168
.annotate 'line', 1033
    find_lex $P3169, "$past"
    unless_null $P3169, vivify_1801
    new $P3169, "Undef"
  vivify_1801:
    $P3169."pasttype"("unless")
.annotate 'line', 1034
    find_lex $P3170, "$/"
    find_lex $P3171, "$past"
    unless_null $P3171, vivify_1802
    new $P3171, "Undef"
  vivify_1802:
    $P3172 = $P3170."!make"($P3171)
.annotate 'line', 1031
    .return ($P3172)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("454_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3174
    .param pmc param_3175
.annotate 'line', 1037
    .lex "self", param_3174
    .lex "$/", param_3175
.annotate 'line', 1038
    new $P3176, "Undef"
    .lex "$past", $P3176
    find_lex $P3177, "$/"
    unless_null $P3177, vivify_1803
    $P3177 = root_new ['parrot';'Hash']
  vivify_1803:
    set $P3178, $P3177["xblock"]
    unless_null $P3178, vivify_1804
    new $P3178, "Undef"
  vivify_1804:
    $P3179 = $P3178."ast"()
    $P3180 = "xblock_immediate"($P3179)
    store_lex "$past", $P3180
.annotate 'line', 1039
    find_lex $P3181, "$past"
    unless_null $P3181, vivify_1805
    new $P3181, "Undef"
  vivify_1805:
    find_lex $P3182, "$/"
    unless_null $P3182, vivify_1806
    $P3182 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P3183, $P3182["sym"]
    unless_null $P3183, vivify_1807
    new $P3183, "Undef"
  vivify_1807:
    set $S3184, $P3183
    $P3181."pasttype"($S3184)
.annotate 'line', 1040
    find_lex $P3185, "$/"
    find_lex $P3186, "$past"
    unless_null $P3186, vivify_1808
    new $P3186, "Undef"
  vivify_1808:
    $P3187 = $P3185."!make"($P3186)
.annotate 'line', 1037
    .return ($P3187)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("455_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3189
    .param pmc param_3190
.annotate 'line', 1043
    .lex "self", param_3189
    .lex "$/", param_3190
.annotate 'line', 1044
    new $P3191, "Undef"
    .lex "$pasttype", $P3191
.annotate 'line', 1045
    new $P3192, "Undef"
    .lex "$past", $P3192
.annotate 'line', 1044
    new $P3193, "String"
    assign $P3193, "repeat_"
    find_lex $P3194, "$/"
    unless_null $P3194, vivify_1809
    $P3194 = root_new ['parrot';'Hash']
  vivify_1809:
    set $P3195, $P3194["wu"]
    unless_null $P3195, vivify_1810
    new $P3195, "Undef"
  vivify_1810:
    set $S3196, $P3195
    concat $P3197, $P3193, $S3196
    store_lex "$pasttype", $P3197
    find_lex $P3198, "$past"
    unless_null $P3198, vivify_1811
    new $P3198, "Undef"
  vivify_1811:
.annotate 'line', 1046
    find_lex $P3200, "$/"
    unless_null $P3200, vivify_1812
    $P3200 = root_new ['parrot';'Hash']
  vivify_1812:
    set $P3201, $P3200["xblock"]
    unless_null $P3201, vivify_1813
    new $P3201, "Undef"
  vivify_1813:
    if $P3201, if_3199
.annotate 'line', 1051
    get_hll_global $P3208, "GLOBAL"
    nqp_get_package_through_who $P3209, $P3208, "PAST"
    get_who $P3210, $P3209
    set $P3211, $P3210["Op"]
    find_lex $P3212, "$/"
    unless_null $P3212, vivify_1814
    $P3212 = root_new ['parrot';'Hash']
  vivify_1814:
    set $P3213, $P3212["EXPR"]
    unless_null $P3213, vivify_1815
    new $P3213, "Undef"
  vivify_1815:
    $P3214 = $P3213."ast"()
    find_lex $P3215, "$/"
    unless_null $P3215, vivify_1816
    $P3215 = root_new ['parrot';'Hash']
  vivify_1816:
    set $P3216, $P3215["pblock"]
    unless_null $P3216, vivify_1817
    new $P3216, "Undef"
  vivify_1817:
    $P3217 = $P3216."ast"()
    $P3218 = "block_immediate"($P3217)
    find_lex $P3219, "$pasttype"
    unless_null $P3219, vivify_1818
    new $P3219, "Undef"
  vivify_1818:
    find_lex $P3220, "$/"
    unless_null $P3220, vivify_1819
    new $P3220, "Undef"
  vivify_1819:
    $P3221 = $P3211."new"($P3214, $P3218, $P3219 :named("pasttype"), $P3220 :named("node"))
    store_lex "$past", $P3221
.annotate 'line', 1050
    goto if_3199_end
  if_3199:
.annotate 'line', 1047
    find_lex $P3202, "$/"
    unless_null $P3202, vivify_1820
    $P3202 = root_new ['parrot';'Hash']
  vivify_1820:
    set $P3203, $P3202["xblock"]
    unless_null $P3203, vivify_1821
    new $P3203, "Undef"
  vivify_1821:
    $P3204 = $P3203."ast"()
    $P3205 = "xblock_immediate"($P3204)
    store_lex "$past", $P3205
.annotate 'line', 1048
    find_lex $P3206, "$past"
    unless_null $P3206, vivify_1822
    new $P3206, "Undef"
  vivify_1822:
    find_lex $P3207, "$pasttype"
    unless_null $P3207, vivify_1823
    new $P3207, "Undef"
  vivify_1823:
    $P3206."pasttype"($P3207)
  if_3199_end:
.annotate 'line', 1054
    find_lex $P3222, "$/"
    find_lex $P3223, "$past"
    unless_null $P3223, vivify_1824
    new $P3223, "Undef"
  vivify_1824:
    $P3224 = $P3222."!make"($P3223)
.annotate 'line', 1043
    .return ($P3224)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("456_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3226
    .param pmc param_3227
.annotate 'line', 1057
    .lex "self", param_3226
    .lex "$/", param_3227
.annotate 'line', 1058
    new $P3228, "Undef"
    .lex "$past", $P3228
.annotate 'line', 1060
    new $P3229, "Undef"
    .lex "$block", $P3229
.annotate 'line', 1058
    find_lex $P3230, "$/"
    unless_null $P3230, vivify_1825
    $P3230 = root_new ['parrot';'Hash']
  vivify_1825:
    set $P3231, $P3230["xblock"]
    unless_null $P3231, vivify_1826
    new $P3231, "Undef"
  vivify_1826:
    $P3232 = $P3231."ast"()
    store_lex "$past", $P3232
.annotate 'line', 1059
    find_lex $P3233, "$past"
    unless_null $P3233, vivify_1827
    new $P3233, "Undef"
  vivify_1827:
    $P3233."pasttype"("for")
.annotate 'line', 1060
    find_lex $P3234, "$past"
    unless_null $P3234, vivify_1828
    $P3234 = root_new ['parrot';'ResizablePMCArray']
  vivify_1828:
    set $P3235, $P3234[1]
    unless_null $P3235, vivify_1829
    new $P3235, "Undef"
  vivify_1829:
    store_lex "$block", $P3235
.annotate 'line', 1061
    find_lex $P3237, "$block"
    unless_null $P3237, vivify_1830
    new $P3237, "Undef"
  vivify_1830:
    $P3238 = $P3237."arity"()
    if $P3238, unless_3236_end
.annotate 'line', 1062
    find_lex $P3239, "$block"
    unless_null $P3239, vivify_1831
    $P3239 = root_new ['parrot';'ResizablePMCArray']
  vivify_1831:
    set $P3240, $P3239[0]
    unless_null $P3240, vivify_1832
    new $P3240, "Undef"
  vivify_1832:
    get_hll_global $P3241, "GLOBAL"
    nqp_get_package_through_who $P3242, $P3241, "PAST"
    get_who $P3243, $P3242
    set $P3244, $P3243["Var"]
    $P3245 = $P3244."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3240."push"($P3245)
.annotate 'line', 1063
    find_lex $P3246, "$block"
    unless_null $P3246, vivify_1833
    new $P3246, "Undef"
  vivify_1833:
    $P3246."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1064
    find_lex $P3247, "$block"
    unless_null $P3247, vivify_1834
    new $P3247, "Undef"
  vivify_1834:
    $P3247."arity"(1)
  unless_3236_end:
.annotate 'line', 1066
    find_lex $P3248, "$block"
    unless_null $P3248, vivify_1835
    new $P3248, "Undef"
  vivify_1835:
    $P3248."blocktype"("immediate")
.annotate 'line', 1067
    find_lex $P3249, "$/"
    find_lex $P3250, "$past"
    unless_null $P3250, vivify_1836
    new $P3250, "Undef"
  vivify_1836:
    $P3251 = $P3249."!make"($P3250)
.annotate 'line', 1057
    .return ($P3251)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("457_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3253
    .param pmc param_3254
.annotate 'line', 1070
    .lex "self", param_3253
    .lex "$/", param_3254
.annotate 'line', 1071
    new $P3255, "Undef"
    .lex "$block", $P3255
    find_lex $P3256, "$/"
    unless_null $P3256, vivify_1837
    $P3256 = root_new ['parrot';'Hash']
  vivify_1837:
    set $P3257, $P3256["block"]
    unless_null $P3257, vivify_1838
    new $P3257, "Undef"
  vivify_1838:
    $P3258 = $P3257."ast"()
    store_lex "$block", $P3258
.annotate 'line', 1072
    find_lex $P3259, "$/"
    unless_null $P3259, vivify_1839
    new $P3259, "Undef"
  vivify_1839:
    find_lex $P3260, "$block"
    unless_null $P3260, vivify_1840
    new $P3260, "Undef"
  vivify_1840:
    "push_block_handler"($P3259, $P3260)
.annotate 'line', 1073
    find_lex $P3261, "$?PACKAGE"
    get_who $P3262, $P3261
    set $P3263, $P3262["@BLOCK"]
    unless_null $P3263, vivify_1841
    $P3263 = root_new ['parrot';'ResizablePMCArray']
  vivify_1841:
    set $P3264, $P3263[0]
    unless_null $P3264, vivify_1842
    new $P3264, "Undef"
  vivify_1842:
    $P3265 = $P3264."handlers"()
    set $P3266, $P3265[0]
    unless_null $P3266, vivify_1843
    new $P3266, "Undef"
  vivify_1843:
    $P3266."handle_types_except"("CONTROL")
.annotate 'line', 1074
    find_lex $P3267, "$/"
    get_hll_global $P3268, "GLOBAL"
    nqp_get_package_through_who $P3269, $P3268, "PAST"
    get_who $P3270, $P3269
    set $P3271, $P3270["Stmts"]
    find_lex $P3272, "$/"
    unless_null $P3272, vivify_1844
    new $P3272, "Undef"
  vivify_1844:
    $P3273 = $P3271."new"($P3272 :named("node"))
    $P3274 = $P3267."!make"($P3273)
.annotate 'line', 1070
    .return ($P3274)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("458_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3276
    .param pmc param_3277
.annotate 'line', 1077
    .lex "self", param_3276
    .lex "$/", param_3277
.annotate 'line', 1078
    new $P3278, "Undef"
    .lex "$block", $P3278
    find_lex $P3279, "$/"
    unless_null $P3279, vivify_1845
    $P3279 = root_new ['parrot';'Hash']
  vivify_1845:
    set $P3280, $P3279["block"]
    unless_null $P3280, vivify_1846
    new $P3280, "Undef"
  vivify_1846:
    $P3281 = $P3280."ast"()
    store_lex "$block", $P3281
.annotate 'line', 1079
    find_lex $P3282, "$/"
    unless_null $P3282, vivify_1847
    new $P3282, "Undef"
  vivify_1847:
    find_lex $P3283, "$block"
    unless_null $P3283, vivify_1848
    new $P3283, "Undef"
  vivify_1848:
    "push_block_handler"($P3282, $P3283)
.annotate 'line', 1080
    find_lex $P3284, "$?PACKAGE"
    get_who $P3285, $P3284
    set $P3286, $P3285["@BLOCK"]
    unless_null $P3286, vivify_1849
    $P3286 = root_new ['parrot';'ResizablePMCArray']
  vivify_1849:
    set $P3287, $P3286[0]
    unless_null $P3287, vivify_1850
    new $P3287, "Undef"
  vivify_1850:
    $P3288 = $P3287."handlers"()
    set $P3289, $P3288[0]
    unless_null $P3289, vivify_1851
    new $P3289, "Undef"
  vivify_1851:
    $P3289."handle_types"("CONTROL")
.annotate 'line', 1081
    find_lex $P3290, "$/"
    get_hll_global $P3291, "GLOBAL"
    nqp_get_package_through_who $P3292, $P3291, "PAST"
    get_who $P3293, $P3292
    set $P3294, $P3293["Stmts"]
    find_lex $P3295, "$/"
    unless_null $P3295, vivify_1852
    new $P3295, "Undef"
  vivify_1852:
    $P3296 = $P3294."new"($P3295 :named("node"))
    $P3297 = $P3290."!make"($P3296)
.annotate 'line', 1077
    .return ($P3297)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("459_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3300
    .param pmc param_3301
.annotate 'line', 1121
    .lex "self", param_3300
    .lex "$/", param_3301
.annotate 'line', 1122
    find_lex $P3302, "$?PACKAGE"
    get_who $P3303, $P3302
    set $P3304, $P3303["@BLOCK"]
    unless_null $P3304, vivify_1853
    $P3304 = root_new ['parrot';'ResizablePMCArray']
  vivify_1853:
    set $P3305, $P3304[0]
    unless_null $P3305, vivify_1854
    new $P3305, "Undef"
  vivify_1854:
    find_lex $P3306, "$/"
    unless_null $P3306, vivify_1855
    $P3306 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P3307, $P3306["blorst"]
    unless_null $P3307, vivify_1856
    new $P3307, "Undef"
  vivify_1856:
    $P3308 = $P3307."ast"()
    $P3305."push"($P3308)
.annotate 'line', 1123
    find_lex $P3309, "$/"
    get_hll_global $P3310, "GLOBAL"
    nqp_get_package_through_who $P3311, $P3310, "PAST"
    get_who $P3312, $P3311
    set $P3313, $P3312["Stmts"]
    $P3314 = $P3313."new"()
    $P3315 = $P3309."!make"($P3314)
.annotate 'line', 1121
    .return ($P3315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("460_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3317
    .param pmc param_3318
.annotate 'line', 1126
    .lex "self", param_3317
    .lex "$/", param_3318
.annotate 'line', 1127
    new $P3319, "Undef"
    .lex "$past", $P3319
    find_lex $P3320, "$/"
    unless_null $P3320, vivify_1857
    $P3320 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P3321, $P3320["blorst"]
    unless_null $P3321, vivify_1858
    new $P3321, "Undef"
  vivify_1858:
    $P3322 = $P3321."ast"()
    store_lex "$past", $P3322
.annotate 'line', 1128
    get_hll_global $P3324, "GLOBAL"
    nqp_get_package_through_who $P3325, $P3324, "PAST"
    get_who $P3326, $P3325
    set $P3327, $P3326["Block"]
    find_lex $P3328, "$past"
    unless_null $P3328, vivify_1859
    new $P3328, "Undef"
  vivify_1859:
    $P3329 = $P3327."ACCEPTS"($P3328)
    if $P3329, unless_3323_end
.annotate 'line', 1129
    get_hll_global $P3330, "GLOBAL"
    nqp_get_package_through_who $P3331, $P3330, "PAST"
    get_who $P3332, $P3331
    set $P3333, $P3332["Block"]
    find_lex $P3334, "$past"
    unless_null $P3334, vivify_1860
    new $P3334, "Undef"
  vivify_1860:
    find_lex $P3335, "$/"
    unless_null $P3335, vivify_1861
    new $P3335, "Undef"
  vivify_1861:
    $P3336 = $P3333."new"($P3334, "immediate" :named("blocktype"), $P3335 :named("node"))
    store_lex "$past", $P3336
  unless_3323_end:
.annotate 'line', 1131
    find_lex $P3338, "$past"
    unless_null $P3338, vivify_1862
    new $P3338, "Undef"
  vivify_1862:
    $P3339 = $P3338."handlers"()
    if $P3339, unless_3337_end
.annotate 'line', 1132
    find_lex $P3340, "$past"
    unless_null $P3340, vivify_1863
    new $P3340, "Undef"
  vivify_1863:
    get_hll_global $P3341, "GLOBAL"
    nqp_get_package_through_who $P3342, $P3341, "PAST"
    get_who $P3343, $P3342
    set $P3344, $P3343["Control"]
.annotate 'line', 1134
    get_hll_global $P3345, "GLOBAL"
    nqp_get_package_through_who $P3346, $P3345, "PAST"
    get_who $P3347, $P3346
    set $P3348, $P3347["Stmts"]
.annotate 'line', 1135
    get_hll_global $P3349, "GLOBAL"
    nqp_get_package_through_who $P3350, $P3349, "PAST"
    get_who $P3351, $P3350
    set $P3352, $P3351["Op"]
.annotate 'line', 1136
    get_hll_global $P3353, "GLOBAL"
    nqp_get_package_through_who $P3354, $P3353, "PAST"
    get_who $P3355, $P3354
    set $P3356, $P3355["Var"]
.annotate 'line', 1137
    get_hll_global $P3357, "GLOBAL"
    nqp_get_package_through_who $P3358, $P3357, "PAST"
    get_who $P3359, $P3358
    set $P3360, $P3359["Var"]
    $P3361 = $P3360."new"("register" :named("scope"), "exception" :named("name"))
    $P3362 = $P3356."new"($P3361, "handled", "keyed" :named("scope"))
.annotate 'line', 1136
    $P3363 = $P3352."new"($P3362, 1, "bind" :named("pasttype"))
.annotate 'line', 1135
    $P3364 = $P3348."new"($P3363)
.annotate 'line', 1134
    $P3365 = $P3344."new"($P3364, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1132
    new $P3366, "ResizablePMCArray"
    push $P3366, $P3365
    $P3340."handlers"($P3366)
  unless_3337_end:
.annotate 'line', 1146
    find_lex $P3367, "$/"
    find_lex $P3368, "$past"
    unless_null $P3368, vivify_1864
    new $P3368, "Undef"
  vivify_1864:
    $P3369 = $P3367."!make"($P3368)
.annotate 'line', 1126
    .return ($P3369)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("461_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3371
    .param pmc param_3372
.annotate 'line', 1149
    .lex "self", param_3371
    .lex "$/", param_3372
.annotate 'line', 1150
    find_lex $P3373, "$/"
.annotate 'line', 1151
    find_lex $P3376, "$/"
    unless_null $P3376, vivify_1865
    $P3376 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P3377, $P3376["block"]
    unless_null $P3377, vivify_1866
    new $P3377, "Undef"
  vivify_1866:
    if $P3377, if_3375
.annotate 'line', 1152
    find_lex $P3382, "$/"
    unless_null $P3382, vivify_1867
    $P3382 = root_new ['parrot';'Hash']
  vivify_1867:
    set $P3383, $P3382["statement"]
    unless_null $P3383, vivify_1868
    new $P3383, "Undef"
  vivify_1868:
    $P3384 = $P3383."ast"()
    set $P3374, $P3384
.annotate 'line', 1151
    goto if_3375_end
  if_3375:
    find_lex $P3378, "$/"
    unless_null $P3378, vivify_1869
    $P3378 = root_new ['parrot';'Hash']
  vivify_1869:
    set $P3379, $P3378["block"]
    unless_null $P3379, vivify_1870
    new $P3379, "Undef"
  vivify_1870:
    $P3380 = $P3379."ast"()
    $P3381 = "block_immediate"($P3380)
    set $P3374, $P3381
  if_3375_end:
    $P3385 = $P3373."!make"($P3374)
.annotate 'line', 1149
    .return ($P3385)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("462_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3387
    .param pmc param_3388
.annotate 'line', 1157
    .lex "self", param_3387
    .lex "$/", param_3388
    find_lex $P3389, "$/"
    find_lex $P3390, "$/"
    unless_null $P3390, vivify_1871
    $P3390 = root_new ['parrot';'Hash']
  vivify_1871:
    set $P3391, $P3390["cond"]
    unless_null $P3391, vivify_1872
    new $P3391, "Undef"
  vivify_1872:
    $P3392 = $P3391."ast"()
    $P3393 = $P3389."!make"($P3392)
    .return ($P3393)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("463_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3395
    .param pmc param_3396
.annotate 'line', 1158
    .lex "self", param_3395
    .lex "$/", param_3396
    find_lex $P3397, "$/"
    find_lex $P3398, "$/"
    unless_null $P3398, vivify_1873
    $P3398 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P3399, $P3398["cond"]
    unless_null $P3399, vivify_1874
    new $P3399, "Undef"
  vivify_1874:
    $P3400 = $P3399."ast"()
    $P3401 = $P3397."!make"($P3400)
    .return ($P3401)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("464_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3403
    .param pmc param_3404
.annotate 'line', 1160
    .lex "self", param_3403
    .lex "$/", param_3404
    find_lex $P3405, "$/"
    find_lex $P3406, "$/"
    unless_null $P3406, vivify_1875
    $P3406 = root_new ['parrot';'Hash']
  vivify_1875:
    set $P3407, $P3406["cond"]
    unless_null $P3407, vivify_1876
    new $P3407, "Undef"
  vivify_1876:
    $P3408 = $P3407."ast"()
    $P3409 = $P3405."!make"($P3408)
    .return ($P3409)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("465_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3411
    .param pmc param_3412
.annotate 'line', 1161
    .lex "self", param_3411
    .lex "$/", param_3412
    find_lex $P3413, "$/"
    find_lex $P3414, "$/"
    unless_null $P3414, vivify_1877
    $P3414 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P3415, $P3414["cond"]
    unless_null $P3415, vivify_1878
    new $P3415, "Undef"
  vivify_1878:
    $P3416 = $P3415."ast"()
    $P3417 = $P3413."!make"($P3416)
    .return ($P3417)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("466_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3419
    .param pmc param_3420
.annotate 'line', 1165
    .lex "self", param_3419
    .lex "$/", param_3420
    find_lex $P3421, "$/"
    find_lex $P3422, "$/"
    unless_null $P3422, vivify_1879
    $P3422 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P3423, $P3422["fatarrow"]
    unless_null $P3423, vivify_1880
    new $P3423, "Undef"
  vivify_1880:
    $P3424 = $P3423."ast"()
    $P3425 = $P3421."!make"($P3424)
    .return ($P3425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("467_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3427
    .param pmc param_3428
.annotate 'line', 1166
    .lex "self", param_3427
    .lex "$/", param_3428
    find_lex $P3429, "$/"
    find_lex $P3430, "$/"
    unless_null $P3430, vivify_1881
    $P3430 = root_new ['parrot';'Hash']
  vivify_1881:
    set $P3431, $P3430["colonpair"]
    unless_null $P3431, vivify_1882
    new $P3431, "Undef"
  vivify_1882:
    $P3432 = $P3431."ast"()
    $P3433 = $P3429."!make"($P3432)
    .return ($P3433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("468_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3435
    .param pmc param_3436
.annotate 'line', 1167
    .lex "self", param_3435
    .lex "$/", param_3436
    find_lex $P3437, "$/"
    find_lex $P3438, "$/"
    unless_null $P3438, vivify_1883
    $P3438 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P3439, $P3438["variable"]
    unless_null $P3439, vivify_1884
    new $P3439, "Undef"
  vivify_1884:
    $P3440 = $P3439."ast"()
    $P3441 = $P3437."!make"($P3440)
    .return ($P3441)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("469_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3443
    .param pmc param_3444
.annotate 'line', 1168
    .lex "self", param_3443
    .lex "$/", param_3444
    find_lex $P3445, "$/"
    find_lex $P3446, "$/"
    unless_null $P3446, vivify_1885
    $P3446 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P3447, $P3446["package_declarator"]
    unless_null $P3447, vivify_1886
    new $P3447, "Undef"
  vivify_1886:
    $P3448 = $P3447."ast"()
    $P3449 = $P3445."!make"($P3448)
    .return ($P3449)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("470_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3451
    .param pmc param_3452
.annotate 'line', 1169
    .lex "self", param_3451
    .lex "$/", param_3452
    find_lex $P3453, "$/"
    find_lex $P3454, "$/"
    unless_null $P3454, vivify_1887
    $P3454 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P3455, $P3454["scope_declarator"]
    unless_null $P3455, vivify_1888
    new $P3455, "Undef"
  vivify_1888:
    $P3456 = $P3455."ast"()
    $P3457 = $P3453."!make"($P3456)
    .return ($P3457)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("471_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3459
    .param pmc param_3460
.annotate 'line', 1170
    .lex "self", param_3459
    .lex "$/", param_3460
    find_lex $P3461, "$/"
    find_lex $P3462, "$/"
    unless_null $P3462, vivify_1889
    $P3462 = root_new ['parrot';'Hash']
  vivify_1889:
    set $P3463, $P3462["routine_declarator"]
    unless_null $P3463, vivify_1890
    new $P3463, "Undef"
  vivify_1890:
    $P3464 = $P3463."ast"()
    $P3465 = $P3461."!make"($P3464)
    .return ($P3465)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("472_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3467
    .param pmc param_3468
.annotate 'line', 1171
    .lex "self", param_3467
    .lex "$/", param_3468
    find_lex $P3469, "$/"
    find_lex $P3470, "$/"
    unless_null $P3470, vivify_1891
    $P3470 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P3471, $P3470["regex_declarator"]
    unless_null $P3471, vivify_1892
    new $P3471, "Undef"
  vivify_1892:
    $P3472 = $P3471."ast"()
    $P3473 = $P3469."!make"($P3472)
    .return ($P3473)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("473_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3475
    .param pmc param_3476
.annotate 'line', 1172
    .lex "self", param_3475
    .lex "$/", param_3476
    find_lex $P3477, "$/"
    find_lex $P3478, "$/"
    unless_null $P3478, vivify_1893
    $P3478 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P3479, $P3478["statement_prefix"]
    unless_null $P3479, vivify_1894
    new $P3479, "Undef"
  vivify_1894:
    $P3480 = $P3479."ast"()
    $P3481 = $P3477."!make"($P3480)
    .return ($P3481)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("474_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3483
    .param pmc param_3484
.annotate 'line', 1173
    .lex "self", param_3483
    .lex "$/", param_3484
    find_lex $P3485, "$/"
    find_lex $P3486, "$/"
    unless_null $P3486, vivify_1895
    $P3486 = root_new ['parrot';'Hash']
  vivify_1895:
    set $P3487, $P3486["pblock"]
    unless_null $P3487, vivify_1896
    new $P3487, "Undef"
  vivify_1896:
    $P3488 = $P3487."ast"()
    $P3489 = $P3485."!make"($P3488)
    .return ($P3489)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("475_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3491
    .param pmc param_3492
.annotate 'line', 1175
    .lex "self", param_3491
    .lex "$/", param_3492
.annotate 'line', 1176
    new $P3493, "Undef"
    .lex "$past", $P3493
    find_lex $P3494, "$/"
    unless_null $P3494, vivify_1897
    $P3494 = root_new ['parrot';'Hash']
  vivify_1897:
    set $P3495, $P3494["val"]
    unless_null $P3495, vivify_1898
    new $P3495, "Undef"
  vivify_1898:
    $P3496 = $P3495."ast"()
    store_lex "$past", $P3496
.annotate 'line', 1177
    find_lex $P3497, "$past"
    unless_null $P3497, vivify_1899
    new $P3497, "Undef"
  vivify_1899:
    find_lex $P3498, "$/"
    unless_null $P3498, vivify_1900
    $P3498 = root_new ['parrot';'Hash']
  vivify_1900:
    set $P3499, $P3498["key"]
    unless_null $P3499, vivify_1901
    new $P3499, "Undef"
  vivify_1901:
    $P3500 = $P3499."Str"()
    $P3497."named"($P3500)
.annotate 'line', 1178
    find_lex $P3501, "$/"
    find_lex $P3502, "$past"
    unless_null $P3502, vivify_1902
    new $P3502, "Undef"
  vivify_1902:
    $P3503 = $P3501."!make"($P3502)
.annotate 'line', 1175
    .return ($P3503)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("476_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3505
    .param pmc param_3506
.annotate 'line', 1181
    .lex "self", param_3505
    .lex "$/", param_3506
.annotate 'line', 1182
    new $P3507, "Undef"
    .lex "$past", $P3507
.annotate 'line', 1183
    find_lex $P3510, "$/"
    unless_null $P3510, vivify_1903
    $P3510 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P3511, $P3510["circumfix"]
    unless_null $P3511, vivify_1904
    new $P3511, "Undef"
  vivify_1904:
    if $P3511, if_3509
.annotate 'line', 1184
    get_hll_global $P3516, "GLOBAL"
    nqp_get_package_through_who $P3517, $P3516, "PAST"
    get_who $P3518, $P3517
    set $P3519, $P3518["Val"]
    find_lex $P3520, "$/"
    unless_null $P3520, vivify_1905
    $P3520 = root_new ['parrot';'Hash']
  vivify_1905:
    set $P3521, $P3520["not"]
    unless_null $P3521, vivify_1906
    new $P3521, "Undef"
  vivify_1906:
    isfalse $I3522, $P3521
    $P3523 = $P3519."new"($I3522 :named("value"))
    set $P3508, $P3523
.annotate 'line', 1183
    goto if_3509_end
  if_3509:
    find_lex $P3512, "$/"
    unless_null $P3512, vivify_1907
    $P3512 = root_new ['parrot';'Hash']
  vivify_1907:
    set $P3513, $P3512["circumfix"]
    unless_null $P3513, vivify_1908
    $P3513 = root_new ['parrot';'ResizablePMCArray']
  vivify_1908:
    set $P3514, $P3513[0]
    unless_null $P3514, vivify_1909
    new $P3514, "Undef"
  vivify_1909:
    $P3515 = $P3514."ast"()
    set $P3508, $P3515
  if_3509_end:
    store_lex "$past", $P3508
.annotate 'line', 1185
    find_lex $P3524, "$past"
    unless_null $P3524, vivify_1910
    new $P3524, "Undef"
  vivify_1910:
    find_lex $P3525, "$/"
    unless_null $P3525, vivify_1911
    $P3525 = root_new ['parrot';'Hash']
  vivify_1911:
    set $P3526, $P3525["identifier"]
    unless_null $P3526, vivify_1912
    new $P3526, "Undef"
  vivify_1912:
    set $S3527, $P3526
    $P3524."named"($S3527)
.annotate 'line', 1186
    find_lex $P3528, "$/"
    find_lex $P3529, "$past"
    unless_null $P3529, vivify_1913
    new $P3529, "Undef"
  vivify_1913:
    $P3530 = $P3528."!make"($P3529)
.annotate 'line', 1181
    .return ($P3530)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("477_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3532
    .param pmc param_3533
.annotate 'line', 1189
    .const 'Sub' $P3549 = "478_1304516047.681" 
    capture_lex $P3549
    .lex "self", param_3532
    .lex "$/", param_3533
.annotate 'line', 1190
    new $P3534, "Undef"
    .lex "$past", $P3534
.annotate 'line', 1189
    find_lex $P3535, "$past"
    unless_null $P3535, vivify_1914
    new $P3535, "Undef"
  vivify_1914:
.annotate 'line', 1191
    find_lex $P3537, "$/"
    unless_null $P3537, vivify_1915
    $P3537 = root_new ['parrot';'Hash']
  vivify_1915:
    set $P3538, $P3537["postcircumfix"]
    unless_null $P3538, vivify_1916
    new $P3538, "Undef"
  vivify_1916:
    if $P3538, if_3536
.annotate 'line', 1195
    .const 'Sub' $P3549 = "478_1304516047.681" 
    capture_lex $P3549
    $P3549()
    goto if_3536_end
  if_3536:
.annotate 'line', 1192
    find_lex $P3539, "$/"
    unless_null $P3539, vivify_1973
    $P3539 = root_new ['parrot';'Hash']
  vivify_1973:
    set $P3540, $P3539["postcircumfix"]
    unless_null $P3540, vivify_1974
    new $P3540, "Undef"
  vivify_1974:
    $P3541 = $P3540."ast"()
    store_lex "$past", $P3541
.annotate 'line', 1193
    find_lex $P3542, "$past"
    unless_null $P3542, vivify_1975
    new $P3542, "Undef"
  vivify_1975:
    get_hll_global $P3543, "GLOBAL"
    nqp_get_package_through_who $P3544, $P3543, "PAST"
    get_who $P3545, $P3544
    set $P3546, $P3545["Var"]
    $P3547 = $P3546."new"("$/" :named("name"))
    $P3542."unshift"($P3547)
  if_3536_end:
.annotate 'line', 1254
    find_lex $P3731, "$/"
    find_lex $P3732, "$past"
    unless_null $P3732, vivify_1976
    new $P3732, "Undef"
  vivify_1976:
    $P3733 = $P3731."!make"($P3732)
.annotate 'line', 1189
    .return ($P3733)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3548"  :anon :subid("478_1304516047.681") :outer("477_1304516047.681")
.annotate 'line', 1195
    .const 'Sub' $P3625 = "480_1304516047.681" 
    capture_lex $P3625
    .const 'Sub' $P3584 = "479_1304516047.681" 
    capture_lex $P3584
.annotate 'line', 1196
    $P3550 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3550
    get_hll_global $P3551, "GLOBAL"
    nqp_get_package_through_who $P3552, $P3551, "NQP"
    get_who $P3553, $P3552
    set $P3554, $P3553["Compiler"]
    find_lex $P3555, "$/"
    unless_null $P3555, vivify_1917
    new $P3555, "Undef"
  vivify_1917:
    set $S3556, $P3555
    $P3557 = $P3554."parse_name"($S3556)
    store_lex "@name", $P3557
.annotate 'line', 1197
    find_lex $P3560, "@name"
    unless_null $P3560, vivify_1918
    $P3560 = root_new ['parrot';'ResizablePMCArray']
  vivify_1918:
    set $N3561, $P3560
    isgt $I3562, $N3561, 1.0
    if $I3562, if_3559
.annotate 'line', 1204
    find_lex $P3578, "$/"
    unless_null $P3578, vivify_1919
    $P3578 = root_new ['parrot';'Hash']
  vivify_1919:
    set $P3579, $P3578["twigil"]
    unless_null $P3579, vivify_1920
    $P3579 = root_new ['parrot';'ResizablePMCArray']
  vivify_1920:
    set $P3580, $P3579[0]
    unless_null $P3580, vivify_1921
    new $P3580, "Undef"
  vivify_1921:
    set $S3581, $P3580
    iseq $I3582, $S3581, "*"
    if $I3582, if_3577
.annotate 'line', 1215
    find_lex $P3619, "$/"
    unless_null $P3619, vivify_1922
    $P3619 = root_new ['parrot';'Hash']
  vivify_1922:
    set $P3620, $P3619["twigil"]
    unless_null $P3620, vivify_1923
    $P3620 = root_new ['parrot';'ResizablePMCArray']
  vivify_1923:
    set $P3621, $P3620[0]
    unless_null $P3621, vivify_1924
    new $P3621, "Undef"
  vivify_1924:
    set $S3622, $P3621
    iseq $I3623, $S3622, "!"
    if $I3623, if_3618
.annotate 'line', 1244
    find_lex $P3708, "@name"
    unless_null $P3708, vivify_1925
    $P3708 = root_new ['parrot';'ResizablePMCArray']
  vivify_1925:
    set $P3709, $P3708[0]
    unless_null $P3709, vivify_1926
    new $P3709, "Undef"
  vivify_1926:
    set $S3710, $P3709
    $P3711 = "is_package"($S3710)
    if $P3711, if_3707
.annotate 'line', 1249
    get_hll_global $P3720, "GLOBAL"
    nqp_get_package_through_who $P3721, $P3720, "PAST"
    get_who $P3722, $P3721
    set $P3723, $P3722["Var"]
.annotate 'line', 1250
    find_lex $P3724, "@name"
    unless_null $P3724, vivify_1927
    $P3724 = root_new ['parrot';'ResizablePMCArray']
  vivify_1927:
    $P3725 = $P3724."pop"()
    set $S3726, $P3725
    find_lex $P3727, "$/"
    unless_null $P3727, vivify_1928
    $P3727 = root_new ['parrot';'Hash']
  vivify_1928:
    set $P3728, $P3727["sigil"]
    unless_null $P3728, vivify_1929
    new $P3728, "Undef"
  vivify_1929:
    $P3729 = "vivitype"($P3728)
    $P3730 = $P3723."new"($S3726 :named("name"), $P3729 :named("viviself"))
.annotate 'line', 1249
    store_lex "$past", $P3730
.annotate 'line', 1248
    set $P3706, $P3730
.annotate 'line', 1244
    goto if_3707_end
  if_3707:
.annotate 'line', 1245
    find_lex $P3712, "@name"
    unless_null $P3712, vivify_1930
    $P3712 = root_new ['parrot';'ResizablePMCArray']
  vivify_1930:
    find_lex $P3713, "$/"
    unless_null $P3713, vivify_1931
    new $P3713, "Undef"
  vivify_1931:
    $P3714 = "lexical_package_lookup"($P3712, $P3713)
    store_lex "$past", $P3714
.annotate 'line', 1246
    find_lex $P3715, "$past"
    unless_null $P3715, vivify_1932
    new $P3715, "Undef"
  vivify_1932:
    find_lex $P3716, "$/"
    unless_null $P3716, vivify_1933
    $P3716 = root_new ['parrot';'Hash']
  vivify_1933:
    set $P3717, $P3716["sigil"]
    unless_null $P3717, vivify_1934
    new $P3717, "Undef"
  vivify_1934:
    $P3718 = "vivitype"($P3717)
    $P3719 = $P3715."viviself"($P3718)
.annotate 'line', 1244
    set $P3706, $P3719
  if_3707_end:
    set $P3617, $P3706
.annotate 'line', 1215
    goto if_3618_end
  if_3618:
    .const 'Sub' $P3625 = "480_1304516047.681" 
    capture_lex $P3625
    $P3705 = $P3625()
    set $P3617, $P3705
  if_3618_end:
    set $P3576, $P3617
.annotate 'line', 1204
    goto if_3577_end
  if_3577:
    .const 'Sub' $P3584 = "479_1304516047.681" 
    capture_lex $P3584
    $P3616 = $P3584()
    set $P3576, $P3616
  if_3577_end:
    set $P3558, $P3576
.annotate 'line', 1197
    goto if_3559_end
  if_3559:
.annotate 'line', 1198
    find_lex $P3564, "$/"
    unless_null $P3564, vivify_1965
    $P3564 = root_new ['parrot';'Hash']
  vivify_1965:
    set $P3565, $P3564["twigil"]
    unless_null $P3565, vivify_1966
    new $P3565, "Undef"
  vivify_1966:
    unless $P3565, if_3563_end
.annotate 'line', 1199
    find_lex $P3566, "$/"
    unless_null $P3566, vivify_1967
    new $P3566, "Undef"
  vivify_1967:
    $P3567 = $P3566."CURSOR"()
    $P3567."panic"("Twigil not allowed on multi-part name")
  if_3563_end:
.annotate 'line', 1201
    find_lex $P3568, "@name"
    unless_null $P3568, vivify_1968
    $P3568 = root_new ['parrot';'ResizablePMCArray']
  vivify_1968:
    find_lex $P3569, "$/"
    unless_null $P3569, vivify_1969
    new $P3569, "Undef"
  vivify_1969:
    $P3570 = "lexical_package_lookup"($P3568, $P3569)
    store_lex "$past", $P3570
.annotate 'line', 1202
    find_lex $P3571, "$past"
    unless_null $P3571, vivify_1970
    new $P3571, "Undef"
  vivify_1970:
    find_lex $P3572, "$/"
    unless_null $P3572, vivify_1971
    $P3572 = root_new ['parrot';'Hash']
  vivify_1971:
    set $P3573, $P3572["sigil"]
    unless_null $P3573, vivify_1972
    new $P3573, "Undef"
  vivify_1972:
    $P3574 = "vivitype"($P3573)
    $P3575 = $P3571."viviself"($P3574)
.annotate 'line', 1197
    set $P3558, $P3575
  if_3559_end:
.annotate 'line', 1195
    .return ($P3558)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3624"  :anon :subid("480_1304516047.681") :outer("478_1304516047.681")
.annotate 'line', 1215
    .const 'Sub' $P3656 = "481_1304516047.681" 
    capture_lex $P3656
.annotate 'line', 1217
    new $P3626, "Undef"
    .lex "$name", $P3626
    find_lex $P3627, "@name"
    unless_null $P3627, vivify_1935
    $P3627 = root_new ['parrot';'ResizablePMCArray']
  vivify_1935:
    $P3628 = $P3627."pop"()
    set $S3629, $P3628
    new $P3630, 'String'
    set $P3630, $S3629
    store_lex "$name", $P3630
.annotate 'line', 1218
    get_hll_global $P3631, "GLOBAL"
    nqp_get_package_through_who $P3632, $P3631, "PAST"
    get_who $P3633, $P3632
    set $P3634, $P3633["Var"]
    find_lex $P3635, "$name"
    unless_null $P3635, vivify_1936
    new $P3635, "Undef"
  vivify_1936:
.annotate 'line', 1220
    find_lex $P3636, "$/"
    unless_null $P3636, vivify_1937
    $P3636 = root_new ['parrot';'Hash']
  vivify_1937:
    set $P3637, $P3636["sigil"]
    unless_null $P3637, vivify_1938
    new $P3637, "Undef"
  vivify_1938:
    $P3638 = "vivitype"($P3637)
.annotate 'line', 1221
    get_hll_global $P3639, "GLOBAL"
    nqp_get_package_through_who $P3640, $P3639, "PAST"
    get_who $P3641, $P3640
    set $P3642, $P3641["Var"]
    $P3643 = $P3642."new"("self" :named("name"))
.annotate 'line', 1222
    get_hll_global $P3644, "GLOBAL"
    nqp_get_package_through_who $P3645, $P3644, "PAST"
    get_who $P3646, $P3645
    set $P3647, $P3646["Var"]
    $P3648 = $P3647."new"("$?CLASS" :named("name"))
    $P3649 = $P3634."new"($P3643, $P3648, $P3635 :named("name"), "attribute_6model" :named("scope"), $P3638 :named("viviself"))
.annotate 'line', 1218
    store_lex "$past", $P3649
.annotate 'line', 1226
    find_dynamic_lex $P3654, "$*IN_DECL"
    unless_null $P3654, vivify_1939
    get_hll_global $P3652, "GLOBAL"
    get_who $P3653, $P3652
    set $P3654, $P3653["$IN_DECL"]
    unless_null $P3654, vivify_1940
    die "Contextual $*IN_DECL not found"
  vivify_1940:
  vivify_1939:
    unless $P3654, unless_3651
    set $P3650, $P3654
    goto unless_3651_end
  unless_3651:
    .const 'Sub' $P3656 = "481_1304516047.681" 
    capture_lex $P3656
    $P3704 = $P3656()
    set $P3650, $P3704
  unless_3651_end:
.annotate 'line', 1215
    .return ($P3650)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3655"  :anon :subid("481_1304516047.681") :outer("480_1304516047.681")
.annotate 'line', 1226
    .const 'Sub' $P3671 = "482_1304516047.681" 
    capture_lex $P3671
.annotate 'line', 1227
    new $P3657, "Undef"
    .lex "$attr", $P3657
.annotate 'line', 1226
    find_lex $P3658, "$attr"
    unless_null $P3658, vivify_1941
    new $P3658, "Undef"
  vivify_1941:
.annotate 'line', 1228
    find_dynamic_lex $P3662, "$*PACKAGE"
    unless_null $P3662, vivify_1942
    get_hll_global $P3660, "GLOBAL"
    get_who $P3661, $P3660
    set $P3662, $P3661["$PACKAGE"]
    unless_null $P3662, vivify_1943
    die "Contextual $*PACKAGE not found"
  vivify_1943:
  vivify_1942:
    get_how $P3663, $P3662
    find_dynamic_lex $P3666, "$*PACKAGE"
    unless_null $P3666, vivify_1944
    get_hll_global $P3664, "GLOBAL"
    get_who $P3665, $P3664
    set $P3666, $P3665["$PACKAGE"]
    unless_null $P3666, vivify_1945
    die "Contextual $*PACKAGE not found"
  vivify_1945:
  vivify_1944:
    $P3667 = $P3663."attributes"($P3666, 1 :named("local"))
    defined $I3668, $P3667
    unless $I3668, for_undef_1946
    iter $P3659, $P3667
    new $P3683, 'ExceptionHandler'
    set_label $P3683, loop3682_handler
    $P3683."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3683
  loop3682_test:
    unless $P3659, loop3682_done
    shift $P3669, $P3659
  loop3682_redo:
    .const 'Sub' $P3671 = "482_1304516047.681" 
    capture_lex $P3671
    $P3671($P3669)
  loop3682_next:
    goto loop3682_test
  loop3682_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3684, exception, 'type'
    eq $P3684, .CONTROL_LOOP_NEXT, loop3682_next
    eq $P3684, .CONTROL_LOOP_REDO, loop3682_redo
  loop3682_done:
    pop_eh 
  for_undef_1946:
.annotate 'line', 1234
    find_lex $P3687, "$attr"
    unless_null $P3687, vivify_1950
    new $P3687, "Undef"
  vivify_1950:
    defined $I3688, $P3687
    if $I3688, if_3686
.annotate 'line', 1240
    find_lex $P3697, "$/"
    unless_null $P3697, vivify_1951
    new $P3697, "Undef"
  vivify_1951:
    $P3698 = $P3697."CURSOR"()
    new $P3699, 'String'
    set $P3699, "Attribute '"
    find_lex $P3700, "$name"
    unless_null $P3700, vivify_1952
    new $P3700, "Undef"
  vivify_1952:
    concat $P3701, $P3699, $P3700
    concat $P3702, $P3701, "' not declared"
    $P3703 = $P3698."panic"($P3702)
.annotate 'line', 1239
    set $P3685, $P3703
.annotate 'line', 1234
    goto if_3686_end
  if_3686:
.annotate 'line', 1235
    find_lex $P3691, "$attr"
    unless_null $P3691, vivify_1953
    new $P3691, "Undef"
  vivify_1953:
    can $I3692, $P3691, "type"
    if $I3692, if_3690
    new $P3689, 'Integer'
    set $P3689, $I3692
    goto if_3690_end
  if_3690:
.annotate 'line', 1236
    find_lex $P3693, "$past"
    unless_null $P3693, vivify_1954
    new $P3693, "Undef"
  vivify_1954:
    find_lex $P3694, "$attr"
    unless_null $P3694, vivify_1955
    new $P3694, "Undef"
  vivify_1955:
    $P3695 = $P3694."type"()
    $P3696 = $P3693."type"($P3695)
.annotate 'line', 1235
    set $P3689, $P3696
  if_3690_end:
.annotate 'line', 1234
    set $P3685, $P3689
  if_3686_end:
.annotate 'line', 1226
    .return ($P3685)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3670"  :anon :subid("482_1304516047.681") :outer("481_1304516047.681")
    .param pmc param_3672
.annotate 'line', 1228
    .lex "$_", param_3672
.annotate 'line', 1229
    find_lex $P3675, "$_"
    unless_null $P3675, vivify_1947
    new $P3675, "Undef"
  vivify_1947:
    $S3676 = $P3675."name"()
    find_lex $P3677, "$name"
    unless_null $P3677, vivify_1948
    new $P3677, "Undef"
  vivify_1948:
    set $S3678, $P3677
    iseq $I3679, $S3676, $S3678
    if $I3679, if_3674
    new $P3673, 'Integer'
    set $P3673, $I3679
    goto if_3674_end
  if_3674:
.annotate 'line', 1230
    find_lex $P3680, "$_"
    unless_null $P3680, vivify_1949
    new $P3680, "Undef"
  vivify_1949:
    store_lex "$attr", $P3680
.annotate 'line', 1231
    set $I3681, .CONTROL_LOOP_LAST
    die 0, $I3681
  if_3674_end:
.annotate 'line', 1228
    .return ($P3673)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3583"  :anon :subid("479_1304516047.681") :outer("478_1304516047.681")
.annotate 'line', 1205
    new $P3585, "Undef"
    .lex "$global_fallback", $P3585
    find_lex $P3586, "$/"
    unless_null $P3586, vivify_1956
    $P3586 = root_new ['parrot';'Hash']
  vivify_1956:
    set $P3587, $P3586["sigil"]
    unless_null $P3587, vivify_1957
    new $P3587, "Undef"
  vivify_1957:
    set $S3588, $P3587
    new $P3589, 'String'
    set $P3589, $S3588
    find_lex $P3590, "$/"
    unless_null $P3590, vivify_1958
    $P3590 = root_new ['parrot';'Hash']
  vivify_1958:
    set $P3591, $P3590["desigilname"]
    unless_null $P3591, vivify_1959
    new $P3591, "Undef"
  vivify_1959:
    concat $P3592, $P3589, $P3591
    new $P3593, "ResizablePMCArray"
    push $P3593, "GLOBAL"
    push $P3593, $P3592
    find_lex $P3594, "$/"
    unless_null $P3594, vivify_1960
    new $P3594, "Undef"
  vivify_1960:
    $P3595 = "lexical_package_lookup"($P3593, $P3594)
    store_lex "$global_fallback", $P3595
.annotate 'line', 1206
    find_lex $P3596, "$global_fallback"
    unless_null $P3596, vivify_1961
    new $P3596, "Undef"
  vivify_1961:
    get_hll_global $P3597, "GLOBAL"
    nqp_get_package_through_who $P3598, $P3597, "PAST"
    get_who $P3599, $P3598
    set $P3600, $P3599["Op"]
.annotate 'line', 1207
    new $P3601, "String"
    assign $P3601, "Contextual "
    find_lex $P3602, "$/"
    unless_null $P3602, vivify_1962
    new $P3602, "Undef"
  vivify_1962:
    set $S3603, $P3602
    concat $P3604, $P3601, $S3603
    concat $P3605, $P3604, " not found"
    $P3606 = $P3600."new"($P3605, "die" :named("pirop"))
.annotate 'line', 1206
    $P3596."viviself"($P3606)
.annotate 'line', 1210
    get_hll_global $P3607, "GLOBAL"
    nqp_get_package_through_who $P3608, $P3607, "PAST"
    get_who $P3609, $P3608
    set $P3610, $P3609["Var"]
.annotate 'line', 1211
    find_lex $P3611, "@name"
    unless_null $P3611, vivify_1963
    $P3611 = root_new ['parrot';'ResizablePMCArray']
  vivify_1963:
    $P3612 = $P3611."pop"()
    set $S3613, $P3612
    find_lex $P3614, "$global_fallback"
    unless_null $P3614, vivify_1964
    new $P3614, "Undef"
  vivify_1964:
    $P3615 = $P3610."new"($S3613 :named("name"), "contextual" :named("scope"), $P3614 :named("viviself"))
.annotate 'line', 1210
    store_lex "$past", $P3615
.annotate 'line', 1204
    .return ($P3615)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("483_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3735
    .param pmc param_3736
.annotate 'line', 1257
    .lex "self", param_3735
    .lex "$/", param_3736
    find_lex $P3737, "$/"
    find_lex $P3738, "$/"
    unless_null $P3738, vivify_1977
    $P3738 = root_new ['parrot';'Hash']
  vivify_1977:
    set $P3739, $P3738["package_def"]
    unless_null $P3739, vivify_1978
    new $P3739, "Undef"
  vivify_1978:
    $P3740 = $P3739."ast"()
    $P3741 = $P3737."!make"($P3740)
    .return ($P3741)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("484_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3743
    .param pmc param_3744
.annotate 'line', 1258
    .lex "self", param_3743
    .lex "$/", param_3744
    find_lex $P3745, "$/"
    find_lex $P3746, "$/"
    unless_null $P3746, vivify_1979
    $P3746 = root_new ['parrot';'Hash']
  vivify_1979:
    set $P3747, $P3746["package_def"]
    unless_null $P3747, vivify_1980
    new $P3747, "Undef"
  vivify_1980:
    $P3748 = $P3747."ast"()
    $P3749 = $P3745."!make"($P3748)
    .return ($P3749)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("485_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3751
    .param pmc param_3752
.annotate 'line', 1259
    .lex "self", param_3751
    .lex "$/", param_3752
    find_lex $P3753, "$/"
    find_lex $P3754, "$/"
    unless_null $P3754, vivify_1981
    $P3754 = root_new ['parrot';'Hash']
  vivify_1981:
    set $P3755, $P3754["package_def"]
    unless_null $P3755, vivify_1982
    new $P3755, "Undef"
  vivify_1982:
    $P3756 = $P3755."ast"()
    $P3757 = $P3753."!make"($P3756)
    .return ($P3757)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("486_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3759
    .param pmc param_3760
.annotate 'line', 1260
    .lex "self", param_3759
    .lex "$/", param_3760
    find_lex $P3761, "$/"
    find_lex $P3762, "$/"
    unless_null $P3762, vivify_1983
    $P3762 = root_new ['parrot';'Hash']
  vivify_1983:
    set $P3763, $P3762["package_def"]
    unless_null $P3763, vivify_1984
    new $P3763, "Undef"
  vivify_1984:
    $P3764 = $P3763."ast"()
    $P3765 = $P3761."!make"($P3764)
    .return ($P3765)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("487_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3767
    .param pmc param_3768
.annotate 'line', 1261
    .lex "self", param_3767
    .lex "$/", param_3768
    find_lex $P3769, "$/"
    find_lex $P3770, "$/"
    unless_null $P3770, vivify_1985
    $P3770 = root_new ['parrot';'Hash']
  vivify_1985:
    set $P3771, $P3770["package_def"]
    unless_null $P3771, vivify_1986
    new $P3771, "Undef"
  vivify_1986:
    $P3772 = $P3771."ast"()
    $P3773 = $P3769."!make"($P3772)
    .return ($P3773)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("488_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3775
    .param pmc param_3776
.annotate 'line', 1262
    .lex "self", param_3775
    .lex "$/", param_3776
    find_lex $P3777, "$/"
    find_lex $P3778, "$/"
    unless_null $P3778, vivify_1987
    $P3778 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P3779, $P3778["package_def"]
    unless_null $P3779, vivify_1988
    new $P3779, "Undef"
  vivify_1988:
    $P3780 = $P3779."ast"()
    $P3781 = $P3777."!make"($P3780)
    .return ($P3781)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("489_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_3783
    .param pmc param_3784
.annotate 'line', 1264
    .const 'Sub' $P3964 = "493_1304516047.681" 
    capture_lex $P3964
    .const 'Sub' $P3934 = "492_1304516047.681" 
    capture_lex $P3934
    .const 'Sub' $P3887 = "490_1304516047.681" 
    capture_lex $P3887
    .lex "self", param_3783
    .lex "$/", param_3784
.annotate 'line', 1266
    $P3785 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3785
.annotate 'line', 1267
    new $P3786, "Undef"
    .lex "$name", $P3786
.annotate 'line', 1268
    new $P3787, "Undef"
    .lex "$how", $P3787
.annotate 'line', 1271
    new $P3788, "Undef"
    .lex "$past", $P3788
.annotate 'line', 1266
    find_lex $P3789, "$/"
    unless_null $P3789, vivify_1989
    $P3789 = root_new ['parrot';'Hash']
  vivify_1989:
    set $P3790, $P3789["name"]
    unless_null $P3790, vivify_1990
    $P3790 = root_new ['parrot';'Hash']
  vivify_1990:
    set $P3791, $P3790["identifier"]
    unless_null $P3791, vivify_1991
    new $P3791, "Undef"
  vivify_1991:
    clone $P3792, $P3791
    store_lex "@ns", $P3792
.annotate 'line', 1267
    find_lex $P3793, "@ns"
    unless_null $P3793, vivify_1992
    $P3793 = root_new ['parrot';'ResizablePMCArray']
  vivify_1992:
    $P3794 = $P3793."pop"()
    set $S3795, $P3794
    new $P3796, 'String'
    set $P3796, $S3795
    store_lex "$name", $P3796
.annotate 'line', 1268
    find_dynamic_lex $P3799, "$*PKGDECL"
    unless_null $P3799, vivify_1993
    get_hll_global $P3797, "GLOBAL"
    get_who $P3798, $P3797
    set $P3799, $P3798["$PKGDECL"]
    unless_null $P3799, vivify_1994
    die "Contextual $*PKGDECL not found"
  vivify_1994:
  vivify_1993:
    find_dynamic_lex $P3802, "%*HOW"
    unless_null $P3802, vivify_1995
    get_hll_global $P3800, "GLOBAL"
    get_who $P3801, $P3800
    set $P3802, $P3801["%HOW"]
    unless_null $P3802, vivify_1996
    die "Contextual %*HOW not found"
  vivify_1996:
  vivify_1995:
    set $P3803, $P3802[$P3799]
    unless_null $P3803, vivify_1997
    new $P3803, "Undef"
  vivify_1997:
    store_lex "$how", $P3803
.annotate 'line', 1271
    find_lex $P3806, "$/"
    unless_null $P3806, vivify_1998
    $P3806 = root_new ['parrot';'Hash']
  vivify_1998:
    set $P3807, $P3806["block"]
    unless_null $P3807, vivify_1999
    new $P3807, "Undef"
  vivify_1999:
    if $P3807, if_3805
    find_lex $P3811, "$/"
    unless_null $P3811, vivify_2000
    $P3811 = root_new ['parrot';'Hash']
  vivify_2000:
    set $P3812, $P3811["comp_unit"]
    unless_null $P3812, vivify_2001
    new $P3812, "Undef"
  vivify_2001:
    $P3813 = $P3812."ast"()
    set $P3804, $P3813
    goto if_3805_end
  if_3805:
    find_lex $P3808, "$/"
    unless_null $P3808, vivify_2002
    $P3808 = root_new ['parrot';'Hash']
  vivify_2002:
    set $P3809, $P3808["block"]
    unless_null $P3809, vivify_2003
    new $P3809, "Undef"
  vivify_2003:
    $P3810 = $P3809."ast"()
    set $P3804, $P3810
  if_3805_end:
    store_lex "$past", $P3804
.annotate 'line', 1272
    find_dynamic_lex $P3819, "$*SCOPE"
    unless_null $P3819, vivify_2004
    get_hll_global $P3817, "GLOBAL"
    get_who $P3818, $P3817
    set $P3819, $P3818["$SCOPE"]
    unless_null $P3819, vivify_2005
    die "Contextual $*SCOPE not found"
  vivify_2005:
  vivify_2004:
    set $S3820, $P3819
    iseq $I3821, $S3820, "our"
    unless $I3821, unless_3816
    new $P3815, 'Integer'
    set $P3815, $I3821
    goto unless_3816_end
  unless_3816:
    find_dynamic_lex $P3824, "$*SCOPE"
    unless_null $P3824, vivify_2006
    get_hll_global $P3822, "GLOBAL"
    get_who $P3823, $P3822
    set $P3824, $P3823["$SCOPE"]
    unless_null $P3824, vivify_2007
    die "Contextual $*SCOPE not found"
  vivify_2007:
  vivify_2006:
    set $S3825, $P3824
    iseq $I3826, $S3825, ""
    new $P3815, 'Integer'
    set $P3815, $I3826
  unless_3816_end:
    unless $P3815, if_3814_end
.annotate 'line', 1273
    find_lex $P3827, "$past"
    unless_null $P3827, vivify_2008
    new $P3827, "Undef"
  vivify_2008:
    find_lex $P3828, "$/"
    unless_null $P3828, vivify_2009
    $P3828 = root_new ['parrot';'Hash']
  vivify_2009:
    set $P3829, $P3828["name"]
    unless_null $P3829, vivify_2010
    $P3829 = root_new ['parrot';'Hash']
  vivify_2010:
    set $P3830, $P3829["identifier"]
    unless_null $P3830, vivify_2011
    new $P3830, "Undef"
  vivify_2011:
    $P3827."namespace"($P3830)
  if_3814_end:
.annotate 'line', 1280
    find_lex $P3834, "$how"
    unless_null $P3834, vivify_2012
    new $P3834, "Undef"
  vivify_2012:
    can $I3835, $P3834, "parametric"
    if $I3835, if_3833
    new $P3832, 'Integer'
    set $P3832, $I3835
    goto if_3833_end
  if_3833:
    find_lex $P3836, "$how"
    unless_null $P3836, vivify_2013
    new $P3836, "Undef"
  vivify_2013:
    find_lex $P3837, "$how"
    unless_null $P3837, vivify_2014
    new $P3837, "Undef"
  vivify_2014:
    $P3838 = $P3836."parametric"($P3837)
    set $P3832, $P3838
  if_3833_end:
    if $P3832, if_3831
.annotate 'line', 1289
    find_lex $P3868, "$past"
    unless_null $P3868, vivify_2015
    new $P3868, "Undef"
  vivify_2015:
    $P3868."blocktype"("immediate")
.annotate 'line', 1290
    find_dynamic_lex $P3871, "$*SC"
    unless_null $P3871, vivify_2016
    get_hll_global $P3869, "GLOBAL"
    get_who $P3870, $P3869
    set $P3871, $P3870["$SC"]
    unless_null $P3871, vivify_2017
    die "Contextual $*SC not found"
  vivify_2017:
  vivify_2016:
    find_lex $P3872, "$past"
    unless_null $P3872, vivify_2018
    new $P3872, "Undef"
  vivify_2018:
    find_dynamic_lex $P3875, "$*PACKAGE"
    unless_null $P3875, vivify_2019
    get_hll_global $P3873, "GLOBAL"
    get_who $P3874, $P3873
    set $P3875, $P3874["$PACKAGE"]
    unless_null $P3875, vivify_2020
    die "Contextual $*PACKAGE not found"
  vivify_2020:
  vivify_2019:
    $P3871."install_lexical_symbol"($P3872, "$?PACKAGE", $P3875)
.annotate 'line', 1291
    find_dynamic_lex $P3878, "$*SC"
    unless_null $P3878, vivify_2021
    get_hll_global $P3876, "GLOBAL"
    get_who $P3877, $P3876
    set $P3878, $P3877["$SC"]
    unless_null $P3878, vivify_2022
    die "Contextual $*SC not found"
  vivify_2022:
  vivify_2021:
    find_lex $P3879, "$past"
    unless_null $P3879, vivify_2023
    new $P3879, "Undef"
  vivify_2023:
    find_dynamic_lex $P3882, "$*PACKAGE"
    unless_null $P3882, vivify_2024
    get_hll_global $P3880, "GLOBAL"
    get_who $P3881, $P3880
    set $P3882, $P3881["$PACKAGE"]
    unless_null $P3882, vivify_2025
    die "Contextual $*PACKAGE not found"
  vivify_2025:
  vivify_2024:
    $P3878."install_lexical_symbol"($P3879, "$?CLASS", $P3882)
.annotate 'line', 1288
    goto if_3831_end
  if_3831:
.annotate 'line', 1281
    find_lex $P3839, "$past"
    unless_null $P3839, vivify_2026
    new $P3839, "Undef"
  vivify_2026:
    $P3839."blocktype"("declaration")
.annotate 'line', 1282
    find_lex $P3840, "$past"
    unless_null $P3840, vivify_2027
    new $P3840, "Undef"
  vivify_2027:
    get_hll_global $P3841, "GLOBAL"
    nqp_get_package_through_who $P3842, $P3841, "PAST"
    get_who $P3843, $P3842
    set $P3844, $P3843["Var"]
    $P3845 = $P3844."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3840."unshift"($P3845)
.annotate 'line', 1283
    find_lex $P3846, "$past"
    unless_null $P3846, vivify_2028
    new $P3846, "Undef"
  vivify_2028:
    $P3846."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1284
    find_dynamic_lex $P3849, "$*SC"
    unless_null $P3849, vivify_2029
    get_hll_global $P3847, "GLOBAL"
    get_who $P3848, $P3847
    set $P3849, $P3848["$SC"]
    unless_null $P3849, vivify_2030
    die "Contextual $*SC not found"
  vivify_2030:
  vivify_2029:
    find_dynamic_lex $P3852, "$*PACKAGE"
    unless_null $P3852, vivify_2031
    get_hll_global $P3850, "GLOBAL"
    get_who $P3851, $P3850
    set $P3852, $P3851["$PACKAGE"]
    unless_null $P3852, vivify_2032
    die "Contextual $*PACKAGE not found"
  vivify_2032:
  vivify_2031:
    find_lex $P3853, "$past"
    unless_null $P3853, vivify_2033
    new $P3853, "Undef"
  vivify_2033:
    $P3849."pkg_set_body_block"($P3852, $P3853)
.annotate 'line', 1285
    find_dynamic_lex $P3856, "$*SC"
    unless_null $P3856, vivify_2034
    get_hll_global $P3854, "GLOBAL"
    get_who $P3855, $P3854
    set $P3856, $P3855["$SC"]
    unless_null $P3856, vivify_2035
    die "Contextual $*SC not found"
  vivify_2035:
  vivify_2034:
    find_lex $P3857, "$past"
    unless_null $P3857, vivify_2036
    new $P3857, "Undef"
  vivify_2036:
    find_dynamic_lex $P3860, "$*PACKAGE"
    unless_null $P3860, vivify_2037
    get_hll_global $P3858, "GLOBAL"
    get_who $P3859, $P3858
    set $P3860, $P3859["$PACKAGE"]
    unless_null $P3860, vivify_2038
    die "Contextual $*PACKAGE not found"
  vivify_2038:
  vivify_2037:
    $P3856."install_lexical_symbol"($P3857, "$?PACKAGE", $P3860)
.annotate 'line', 1286
    find_dynamic_lex $P3863, "$*SC"
    unless_null $P3863, vivify_2039
    get_hll_global $P3861, "GLOBAL"
    get_who $P3862, $P3861
    set $P3863, $P3862["$SC"]
    unless_null $P3863, vivify_2040
    die "Contextual $*SC not found"
  vivify_2040:
  vivify_2039:
    find_lex $P3864, "$past"
    unless_null $P3864, vivify_2041
    new $P3864, "Undef"
  vivify_2041:
    find_dynamic_lex $P3867, "$*PACKAGE"
    unless_null $P3867, vivify_2042
    get_hll_global $P3865, "GLOBAL"
    get_who $P3866, $P3865
    set $P3867, $P3866["$PACKAGE"]
    unless_null $P3867, vivify_2043
    die "Contextual $*PACKAGE not found"
  vivify_2043:
  vivify_2042:
    $P3863."install_lexical_symbol"($P3864, "$?ROLE", $P3867)
  if_3831_end:
.annotate 'line', 1295
    find_lex $P3884, "$/"
    unless_null $P3884, vivify_2044
    $P3884 = root_new ['parrot';'Hash']
  vivify_2044:
    set $P3885, $P3884["parent"]
    unless_null $P3885, vivify_2045
    new $P3885, "Undef"
  vivify_2045:
    if $P3885, if_3883
.annotate 'line', 1309
    find_lex $P3931, "$how"
    unless_null $P3931, vivify_2046
    new $P3931, "Undef"
  vivify_2046:
    can $I3932, $P3931, "set_default_parent"
    unless $I3932, if_3930_end
    .const 'Sub' $P3934 = "492_1304516047.681" 
    capture_lex $P3934
    $P3934()
  if_3930_end:
    goto if_3883_end
  if_3883:
.annotate 'line', 1295
    .const 'Sub' $P3887 = "490_1304516047.681" 
    capture_lex $P3887
    $P3887()
  if_3883_end:
.annotate 'line', 1316
    find_lex $P3956, "$/"
    unless_null $P3956, vivify_2072
    $P3956 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P3957, $P3956["role"]
    unless_null $P3957, vivify_2073
    new $P3957, "Undef"
  vivify_2073:
    unless $P3957, if_3955_end
.annotate 'line', 1317
    find_lex $P3959, "$/"
    unless_null $P3959, vivify_2074
    $P3959 = root_new ['parrot';'Hash']
  vivify_2074:
    set $P3960, $P3959["role"]
    unless_null $P3960, vivify_2075
    new $P3960, "Undef"
  vivify_2075:
    defined $I3961, $P3960
    unless $I3961, for_undef_2076
    iter $P3958, $P3960
    new $P4005, 'ExceptionHandler'
    set_label $P4005, loop4004_handler
    $P4005."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4005
  loop4004_test:
    unless $P3958, loop4004_done
    shift $P3962, $P3958
  loop4004_redo:
    .const 'Sub' $P3964 = "493_1304516047.681" 
    capture_lex $P3964
    $P3964($P3962)
  loop4004_next:
    goto loop4004_test
  loop4004_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4006, exception, 'type'
    eq $P4006, .CONTROL_LOOP_NEXT, loop4004_next
    eq $P4006, .CONTROL_LOOP_REDO, loop4004_redo
  loop4004_done:
    pop_eh 
  for_undef_2076:
  if_3955_end:
.annotate 'line', 1334
    find_dynamic_lex $P4009, "$*SC"
    unless_null $P4009, vivify_2090
    get_hll_global $P4007, "GLOBAL"
    get_who $P4008, $P4007
    set $P4009, $P4008["$SC"]
    unless_null $P4009, vivify_2091
    die "Contextual $*SC not found"
  vivify_2091:
  vivify_2090:
    find_dynamic_lex $P4012, "$*PACKAGE"
    unless_null $P4012, vivify_2092
    get_hll_global $P4010, "GLOBAL"
    get_who $P4011, $P4010
    set $P4012, $P4011["$PACKAGE"]
    unless_null $P4012, vivify_2093
    die "Contextual $*PACKAGE not found"
  vivify_2093:
  vivify_2092:
    $P4009."pkg_compose"($P4012)
.annotate 'line', 1336
    find_lex $P4013, "$/"
    find_lex $P4014, "$past"
    unless_null $P4014, vivify_2094
    new $P4014, "Undef"
  vivify_2094:
    $P4015 = $P4013."!make"($P4014)
.annotate 'line', 1264
    .return ($P4015)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3933"  :anon :subid("492_1304516047.681") :outer("489_1304516047.681")
.annotate 'line', 1310
    new $P3935, "Undef"
    .lex "$default", $P3935
    find_dynamic_lex $P3940, "$*PKGDECL"
    unless_null $P3940, vivify_2047
    get_hll_global $P3938, "GLOBAL"
    get_who $P3939, $P3938
    set $P3940, $P3939["$PKGDECL"]
    unless_null $P3940, vivify_2048
    die "Contextual $*PKGDECL not found"
  vivify_2048:
  vivify_2047:
    set $S3941, $P3940
    iseq $I3942, $S3941, "grammar"
    if $I3942, if_3937
    new $P3944, "ResizablePMCArray"
    push $P3944, "NQPMu"
    set $P3936, $P3944
    goto if_3937_end
  if_3937:
    new $P3943, "ResizablePMCArray"
    push $P3943, "Regex"
    push $P3943, "Cursor"
    set $P3936, $P3943
  if_3937_end:
    store_lex "$default", $P3936
.annotate 'line', 1311
    find_dynamic_lex $P3947, "$*SC"
    unless_null $P3947, vivify_2049
    get_hll_global $P3945, "GLOBAL"
    get_who $P3946, $P3945
    set $P3947, $P3946["$SC"]
    unless_null $P3947, vivify_2050
    die "Contextual $*SC not found"
  vivify_2050:
  vivify_2049:
    find_dynamic_lex $P3950, "$*PACKAGE"
    unless_null $P3950, vivify_2051
    get_hll_global $P3948, "GLOBAL"
    get_who $P3949, $P3948
    set $P3950, $P3949["$PACKAGE"]
    unless_null $P3950, vivify_2052
    die "Contextual $*PACKAGE not found"
  vivify_2052:
  vivify_2051:
.annotate 'line', 1312
    find_lex $P3951, "$default"
    unless_null $P3951, vivify_2053
    new $P3951, "Undef"
  vivify_2053:
    find_lex $P3952, "$/"
    unless_null $P3952, vivify_2054
    new $P3952, "Undef"
  vivify_2054:
    $P3953 = "find_sym"($P3951, $P3952)
    $P3954 = $P3947."pkg_add_parent_or_role"($P3950, "set_default_parent", $P3953)
.annotate 'line', 1309
    .return ($P3954)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3886"  :anon :subid("490_1304516047.681") :outer("489_1304516047.681")
.annotate 'line', 1295
    .const 'Sub' $P3893 = "491_1304516047.681" 
    capture_lex $P3893
.annotate 'line', 1296
    new $P3888, "Undef"
    .lex "$parent", $P3888
.annotate 'line', 1297
    new $P3889, "Undef"
    .lex "$parent_found", $P3889
.annotate 'line', 1295
    find_lex $P3890, "$parent"
    unless_null $P3890, vivify_2055
    new $P3890, "Undef"
  vivify_2055:
    find_lex $P3891, "$parent_found"
    unless_null $P3891, vivify_2056
    new $P3891, "Undef"
  vivify_2056:
.annotate 'line', 1298
    .const 'Sub' $P3893 = "491_1304516047.681" 
    capture_lex $P3893
    $P3893()
.annotate 'line', 1302
    find_lex $P3911, "$parent_found"
    unless_null $P3911, vivify_2062
    new $P3911, "Undef"
  vivify_2062:
    if $P3911, if_3910
.annotate 'line', 1306
    find_lex $P3920, "$/"
    unless_null $P3920, vivify_2063
    new $P3920, "Undef"
  vivify_2063:
    $P3921 = $P3920."CURSOR"()
    new $P3922, "String"
    assign $P3922, "Could not find parent class '"
    find_lex $P3923, "$/"
    unless_null $P3923, vivify_2064
    $P3923 = root_new ['parrot';'Hash']
  vivify_2064:
    set $P3924, $P3923["parent"]
    unless_null $P3924, vivify_2065
    $P3924 = root_new ['parrot';'ResizablePMCArray']
  vivify_2065:
    set $P3925, $P3924[0]
    unless_null $P3925, vivify_2066
    new $P3925, "Undef"
  vivify_2066:
    set $S3926, $P3925
    concat $P3927, $P3922, $S3926
    concat $P3928, $P3927, "'"
    $P3929 = $P3921."panic"($P3928)
.annotate 'line', 1305
    set $P3909, $P3929
.annotate 'line', 1302
    goto if_3910_end
  if_3910:
.annotate 'line', 1303
    find_dynamic_lex $P3914, "$*SC"
    unless_null $P3914, vivify_2067
    get_hll_global $P3912, "GLOBAL"
    get_who $P3913, $P3912
    set $P3914, $P3913["$SC"]
    unless_null $P3914, vivify_2068
    die "Contextual $*SC not found"
  vivify_2068:
  vivify_2067:
    find_dynamic_lex $P3917, "$*PACKAGE"
    unless_null $P3917, vivify_2069
    get_hll_global $P3915, "GLOBAL"
    get_who $P3916, $P3915
    set $P3917, $P3916["$PACKAGE"]
    unless_null $P3917, vivify_2070
    die "Contextual $*PACKAGE not found"
  vivify_2070:
  vivify_2069:
    find_lex $P3918, "$parent"
    unless_null $P3918, vivify_2071
    new $P3918, "Undef"
  vivify_2071:
    $P3919 = $P3914."pkg_add_parent_or_role"($P3917, "add_parent", $P3918)
.annotate 'line', 1302
    set $P3909, $P3919
  if_3910_end:
.annotate 'line', 1295
    .return ($P3909)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3892"  :anon :subid("491_1304516047.681") :outer("490_1304516047.681")
.annotate 'line', 1298
    new $P3904, 'ExceptionHandler'
    set_label $P3904, control_3903
    $P3904."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3904
.annotate 'line', 1299
    find_lex $P3894, "$/"
    unless_null $P3894, vivify_2057
    $P3894 = root_new ['parrot';'Hash']
  vivify_2057:
    set $P3895, $P3894["parent"]
    unless_null $P3895, vivify_2058
    $P3895 = root_new ['parrot';'ResizablePMCArray']
  vivify_2058:
    set $P3896, $P3895[0]
    unless_null $P3896, vivify_2059
    $P3896 = root_new ['parrot';'Hash']
  vivify_2059:
    set $P3897, $P3896["identifier"]
    unless_null $P3897, vivify_2060
    new $P3897, "Undef"
  vivify_2060:
    clone $P3898, $P3897
    find_lex $P3899, "$/"
    unless_null $P3899, vivify_2061
    new $P3899, "Undef"
  vivify_2061:
    $P3900 = "find_sym"($P3898, $P3899)
    store_lex "$parent", $P3900
.annotate 'line', 1300
    new $P3901, "Integer"
    assign $P3901, 1
    store_lex "$parent_found", $P3901
.annotate 'line', 1298
    pop_eh 
    goto skip_handler_3902
  control_3903:
    .local pmc exception 
    .get_results (exception) 
    new $P3907, 'Integer'
    set $P3907, 1
    set exception["handled"], $P3907
    set $I3908, exception["handled"]
    ne $I3908, 1, nothandled_3906
  handled_3905:
    .return (exception)
  nothandled_3906:
    rethrow exception
  skip_handler_3902:
    .return ($P3901)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3963"  :anon :subid("493_1304516047.681") :outer("489_1304516047.681")
    .param pmc param_3967
.annotate 'line', 1317
    .const 'Sub' $P3971 = "494_1304516047.681" 
    capture_lex $P3971
.annotate 'line', 1318
    new $P3965, "Undef"
    .lex "$role", $P3965
.annotate 'line', 1319
    new $P3966, "Undef"
    .lex "$role_found", $P3966
    .lex "$_", param_3967
.annotate 'line', 1317
    find_lex $P3968, "$role"
    unless_null $P3968, vivify_2077
    new $P3968, "Undef"
  vivify_2077:
    find_lex $P3969, "$role_found"
    unless_null $P3969, vivify_2078
    new $P3969, "Undef"
  vivify_2078:
.annotate 'line', 1320
    .const 'Sub' $P3971 = "494_1304516047.681" 
    capture_lex $P3971
    $P3971()
.annotate 'line', 1324
    find_lex $P3987, "$role_found"
    unless_null $P3987, vivify_2082
    new $P3987, "Undef"
  vivify_2082:
    if $P3987, if_3986
.annotate 'line', 1328
    find_lex $P3996, "$/"
    unless_null $P3996, vivify_2083
    new $P3996, "Undef"
  vivify_2083:
    $P3997 = $P3996."CURSOR"()
    new $P3998, "String"
    assign $P3998, "Could not find role '"
    find_lex $P3999, "$_"
    unless_null $P3999, vivify_2084
    new $P3999, "Undef"
  vivify_2084:
    set $S4000, $P3999
    concat $P4001, $P3998, $S4000
    concat $P4002, $P4001, "'"
    $P4003 = $P3997."panic"($P4002)
.annotate 'line', 1327
    set $P3985, $P4003
.annotate 'line', 1324
    goto if_3986_end
  if_3986:
.annotate 'line', 1325
    find_dynamic_lex $P3990, "$*SC"
    unless_null $P3990, vivify_2085
    get_hll_global $P3988, "GLOBAL"
    get_who $P3989, $P3988
    set $P3990, $P3989["$SC"]
    unless_null $P3990, vivify_2086
    die "Contextual $*SC not found"
  vivify_2086:
  vivify_2085:
    find_dynamic_lex $P3993, "$*PACKAGE"
    unless_null $P3993, vivify_2087
    get_hll_global $P3991, "GLOBAL"
    get_who $P3992, $P3991
    set $P3993, $P3992["$PACKAGE"]
    unless_null $P3993, vivify_2088
    die "Contextual $*PACKAGE not found"
  vivify_2088:
  vivify_2087:
    find_lex $P3994, "$role"
    unless_null $P3994, vivify_2089
    new $P3994, "Undef"
  vivify_2089:
    $P3995 = $P3990."pkg_add_parent_or_role"($P3993, "add_role", $P3994)
.annotate 'line', 1324
    set $P3985, $P3995
  if_3986_end:
.annotate 'line', 1317
    .return ($P3985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block3970"  :anon :subid("494_1304516047.681") :outer("493_1304516047.681")
.annotate 'line', 1320
    new $P3980, 'ExceptionHandler'
    set_label $P3980, control_3979
    $P3980."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P3980
.annotate 'line', 1321
    find_lex $P3972, "$_"
    unless_null $P3972, vivify_2079
    $P3972 = root_new ['parrot';'Hash']
  vivify_2079:
    set $P3973, $P3972["identifier"]
    unless_null $P3973, vivify_2080
    new $P3973, "Undef"
  vivify_2080:
    clone $P3974, $P3973
    find_lex $P3975, "$/"
    unless_null $P3975, vivify_2081
    new $P3975, "Undef"
  vivify_2081:
    $P3976 = "find_sym"($P3974, $P3975)
    store_lex "$role", $P3976
.annotate 'line', 1322
    new $P3977, "Integer"
    assign $P3977, 1
    store_lex "$role_found", $P3977
.annotate 'line', 1320
    pop_eh 
    goto skip_handler_3978
  control_3979:
    .local pmc exception 
    .get_results (exception) 
    new $P3983, 'Integer'
    set $P3983, 1
    set exception["handled"], $P3983
    set $I3984, exception["handled"]
    ne $I3984, 1, nothandled_3982
  handled_3981:
    .return (exception)
  nothandled_3982:
    rethrow exception
  skip_handler_3978:
    .return ($P3977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("495_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4017
    .param pmc param_4018
.annotate 'line', 1339
    .lex "self", param_4017
    .lex "$/", param_4018
    find_lex $P4019, "$/"
    find_lex $P4020, "$/"
    unless_null $P4020, vivify_2095
    $P4020 = root_new ['parrot';'Hash']
  vivify_2095:
    set $P4021, $P4020["scoped"]
    unless_null $P4021, vivify_2096
    new $P4021, "Undef"
  vivify_2096:
    $P4022 = $P4021."ast"()
    $P4023 = $P4019."!make"($P4022)
    .return ($P4023)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("496_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4025
    .param pmc param_4026
.annotate 'line', 1340
    .lex "self", param_4025
    .lex "$/", param_4026
    find_lex $P4027, "$/"
    find_lex $P4028, "$/"
    unless_null $P4028, vivify_2097
    $P4028 = root_new ['parrot';'Hash']
  vivify_2097:
    set $P4029, $P4028["scoped"]
    unless_null $P4029, vivify_2098
    new $P4029, "Undef"
  vivify_2098:
    $P4030 = $P4029."ast"()
    $P4031 = $P4027."!make"($P4030)
    .return ($P4031)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("497_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4033
    .param pmc param_4034
.annotate 'line', 1341
    .lex "self", param_4033
    .lex "$/", param_4034
    find_lex $P4035, "$/"
    find_lex $P4036, "$/"
    unless_null $P4036, vivify_2099
    $P4036 = root_new ['parrot';'Hash']
  vivify_2099:
    set $P4037, $P4036["scoped"]
    unless_null $P4037, vivify_2100
    new $P4037, "Undef"
  vivify_2100:
    $P4038 = $P4037."ast"()
    $P4039 = $P4035."!make"($P4038)
    .return ($P4039)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("498_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4041
    .param pmc param_4042
.annotate 'line', 1343
    .lex "self", param_4041
    .lex "$/", param_4042
.annotate 'line', 1344
    find_lex $P4043, "$/"
    find_lex $P4046, "$/"
    unless_null $P4046, vivify_2101
    $P4046 = root_new ['parrot';'Hash']
  vivify_2101:
    set $P4047, $P4046["declarator"]
    unless_null $P4047, vivify_2102
    new $P4047, "Undef"
  vivify_2102:
    if $P4047, if_4045
.annotate 'line', 1345
    find_lex $P4053, "$/"
    unless_null $P4053, vivify_2103
    $P4053 = root_new ['parrot';'Hash']
  vivify_2103:
    set $P4054, $P4053["multi_declarator"]
    unless_null $P4054, vivify_2104
    new $P4054, "Undef"
  vivify_2104:
    if $P4054, if_4052
.annotate 'line', 1346
    find_lex $P4058, "$/"
    unless_null $P4058, vivify_2105
    $P4058 = root_new ['parrot';'Hash']
  vivify_2105:
    set $P4059, $P4058["package_declarator"]
    unless_null $P4059, vivify_2106
    new $P4059, "Undef"
  vivify_2106:
    $P4060 = $P4059."ast"()
    set $P4051, $P4060
.annotate 'line', 1345
    goto if_4052_end
  if_4052:
    find_lex $P4055, "$/"
    unless_null $P4055, vivify_2107
    $P4055 = root_new ['parrot';'Hash']
  vivify_2107:
    set $P4056, $P4055["multi_declarator"]
    unless_null $P4056, vivify_2108
    new $P4056, "Undef"
  vivify_2108:
    $P4057 = $P4056."ast"()
    set $P4051, $P4057
  if_4052_end:
    set $P4044, $P4051
.annotate 'line', 1344
    goto if_4045_end
  if_4045:
    find_lex $P4048, "$/"
    unless_null $P4048, vivify_2109
    $P4048 = root_new ['parrot';'Hash']
  vivify_2109:
    set $P4049, $P4048["declarator"]
    unless_null $P4049, vivify_2110
    new $P4049, "Undef"
  vivify_2110:
    $P4050 = $P4049."ast"()
    set $P4044, $P4050
  if_4045_end:
    $P4061 = $P4043."!make"($P4044)
.annotate 'line', 1343
    .return ($P4061)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("499_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4063
    .param pmc param_4064
.annotate 'line', 1349
    .lex "self", param_4063
    .lex "$/", param_4064
.annotate 'line', 1350
    find_lex $P4065, "$/"
.annotate 'line', 1351
    find_lex $P4068, "$/"
    unless_null $P4068, vivify_2111
    $P4068 = root_new ['parrot';'Hash']
  vivify_2111:
    set $P4069, $P4068["routine_declarator"]
    unless_null $P4069, vivify_2112
    new $P4069, "Undef"
  vivify_2112:
    if $P4069, if_4067
.annotate 'line', 1352
    find_lex $P4073, "$/"
    unless_null $P4073, vivify_2113
    $P4073 = root_new ['parrot';'Hash']
  vivify_2113:
    set $P4074, $P4073["variable_declarator"]
    unless_null $P4074, vivify_2114
    new $P4074, "Undef"
  vivify_2114:
    $P4075 = $P4074."ast"()
    set $P4066, $P4075
.annotate 'line', 1351
    goto if_4067_end
  if_4067:
    find_lex $P4070, "$/"
    unless_null $P4070, vivify_2115
    $P4070 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P4071, $P4070["routine_declarator"]
    unless_null $P4071, vivify_2116
    new $P4071, "Undef"
  vivify_2116:
    $P4072 = $P4071."ast"()
    set $P4066, $P4072
  if_4067_end:
    $P4076 = $P4065."!make"($P4066)
.annotate 'line', 1349
    .return ($P4076)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("500_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4078
    .param pmc param_4079
.annotate 'line', 1355
    .lex "self", param_4078
    .lex "$/", param_4079
    find_lex $P4080, "$/"
    find_lex $P4083, "$/"
    unless_null $P4083, vivify_2117
    $P4083 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P4084, $P4083["declarator"]
    unless_null $P4084, vivify_2118
    new $P4084, "Undef"
  vivify_2118:
    if $P4084, if_4082
    find_lex $P4088, "$/"
    unless_null $P4088, vivify_2119
    $P4088 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P4089, $P4088["routine_def"]
    unless_null $P4089, vivify_2120
    new $P4089, "Undef"
  vivify_2120:
    $P4090 = $P4089."ast"()
    set $P4081, $P4090
    goto if_4082_end
  if_4082:
    find_lex $P4085, "$/"
    unless_null $P4085, vivify_2121
    $P4085 = root_new ['parrot';'Hash']
  vivify_2121:
    set $P4086, $P4085["declarator"]
    unless_null $P4086, vivify_2122
    new $P4086, "Undef"
  vivify_2122:
    $P4087 = $P4086."ast"()
    set $P4081, $P4087
  if_4082_end:
    $P4091 = $P4080."!make"($P4081)
    .return ($P4091)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("501_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4093
    .param pmc param_4094
.annotate 'line', 1356
    .lex "self", param_4093
    .lex "$/", param_4094
    find_lex $P4095, "$/"
    find_lex $P4098, "$/"
    unless_null $P4098, vivify_2123
    $P4098 = root_new ['parrot';'Hash']
  vivify_2123:
    set $P4099, $P4098["declarator"]
    unless_null $P4099, vivify_2124
    new $P4099, "Undef"
  vivify_2124:
    if $P4099, if_4097
    find_lex $P4103, "$/"
    unless_null $P4103, vivify_2125
    $P4103 = root_new ['parrot';'Hash']
  vivify_2125:
    set $P4104, $P4103["routine_def"]
    unless_null $P4104, vivify_2126
    new $P4104, "Undef"
  vivify_2126:
    $P4105 = $P4104."ast"()
    set $P4096, $P4105
    goto if_4097_end
  if_4097:
    find_lex $P4100, "$/"
    unless_null $P4100, vivify_2127
    $P4100 = root_new ['parrot';'Hash']
  vivify_2127:
    set $P4101, $P4100["declarator"]
    unless_null $P4101, vivify_2128
    new $P4101, "Undef"
  vivify_2128:
    $P4102 = $P4101."ast"()
    set $P4096, $P4102
  if_4097_end:
    $P4106 = $P4095."!make"($P4096)
    .return ($P4106)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("502_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4108
    .param pmc param_4109
.annotate 'line', 1357
    .lex "self", param_4108
    .lex "$/", param_4109
    find_lex $P4110, "$/"
    find_lex $P4111, "$/"
    unless_null $P4111, vivify_2129
    $P4111 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P4112, $P4111["declarator"]
    unless_null $P4112, vivify_2130
    new $P4112, "Undef"
  vivify_2130:
    $P4113 = $P4112."ast"()
    $P4114 = $P4110."!make"($P4113)
    .return ($P4114)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("503_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4116
    .param pmc param_4117
.annotate 'line', 1360
    .const 'Sub' $P4151 = "504_1304516047.681" 
    capture_lex $P4151
    .lex "self", param_4116
    .lex "$/", param_4117
.annotate 'line', 1361
    new $P4118, "Undef"
    .lex "$past", $P4118
.annotate 'line', 1362
    new $P4119, "Undef"
    .lex "$sigil", $P4119
.annotate 'line', 1363
    new $P4120, "Undef"
    .lex "$name", $P4120
.annotate 'line', 1364
    new $P4121, "Undef"
    .lex "$BLOCK", $P4121
.annotate 'line', 1361
    find_lex $P4122, "$/"
    unless_null $P4122, vivify_2131
    $P4122 = root_new ['parrot';'Hash']
  vivify_2131:
    set $P4123, $P4122["variable"]
    unless_null $P4123, vivify_2132
    new $P4123, "Undef"
  vivify_2132:
    $P4124 = $P4123."ast"()
    store_lex "$past", $P4124
.annotate 'line', 1362
    find_lex $P4125, "$/"
    unless_null $P4125, vivify_2133
    $P4125 = root_new ['parrot';'Hash']
  vivify_2133:
    set $P4126, $P4125["variable"]
    unless_null $P4126, vivify_2134
    $P4126 = root_new ['parrot';'Hash']
  vivify_2134:
    set $P4127, $P4126["sigil"]
    unless_null $P4127, vivify_2135
    new $P4127, "Undef"
  vivify_2135:
    store_lex "$sigil", $P4127
.annotate 'line', 1363
    find_lex $P4128, "$past"
    unless_null $P4128, vivify_2136
    new $P4128, "Undef"
  vivify_2136:
    $P4129 = $P4128."name"()
    store_lex "$name", $P4129
.annotate 'line', 1364
    find_lex $P4130, "$?PACKAGE"
    get_who $P4131, $P4130
    set $P4132, $P4131["@BLOCK"]
    unless_null $P4132, vivify_2137
    $P4132 = root_new ['parrot';'ResizablePMCArray']
  vivify_2137:
    set $P4133, $P4132[0]
    unless_null $P4133, vivify_2138
    new $P4133, "Undef"
  vivify_2138:
    store_lex "$BLOCK", $P4133
.annotate 'line', 1365
    find_lex $P4137, "$name"
    unless_null $P4137, vivify_2139
    new $P4137, "Undef"
  vivify_2139:
    if $P4137, if_4136
    set $P4135, $P4137
    goto if_4136_end
  if_4136:
    find_lex $P4138, "$BLOCK"
    unless_null $P4138, vivify_2140
    new $P4138, "Undef"
  vivify_2140:
    find_lex $P4139, "$name"
    unless_null $P4139, vivify_2141
    new $P4139, "Undef"
  vivify_2141:
    $P4140 = $P4138."symbol"($P4139)
    set $P4135, $P4140
  if_4136_end:
    unless $P4135, if_4134_end
.annotate 'line', 1366
    find_lex $P4141, "$/"
    unless_null $P4141, vivify_2142
    new $P4141, "Undef"
  vivify_2142:
    $P4142 = $P4141."CURSOR"()
    find_lex $P4143, "$name"
    unless_null $P4143, vivify_2143
    new $P4143, "Undef"
  vivify_2143:
    $P4142."panic"("Redeclaration of symbol ", $P4143)
  if_4134_end:
.annotate 'line', 1368
    find_dynamic_lex $P4147, "$*SCOPE"
    unless_null $P4147, vivify_2144
    get_hll_global $P4145, "GLOBAL"
    get_who $P4146, $P4145
    set $P4147, $P4146["$SCOPE"]
    unless_null $P4147, vivify_2145
    die "Contextual $*SCOPE not found"
  vivify_2145:
  vivify_2144:
    set $S4148, $P4147
    iseq $I4149, $S4148, "has"
    if $I4149, if_4144
.annotate 'line', 1388
    find_dynamic_lex $P4208, "$*SCOPE"
    unless_null $P4208, vivify_2146
    get_hll_global $P4206, "GLOBAL"
    get_who $P4207, $P4206
    set $P4208, $P4207["$SCOPE"]
    unless_null $P4208, vivify_2147
    die "Contextual $*SCOPE not found"
  vivify_2147:
  vivify_2146:
    set $S4209, $P4208
    iseq $I4210, $S4209, "our"
    if $I4210, if_4205
.annotate 'line', 1398
    find_lex $P4224, "$BLOCK"
    unless_null $P4224, vivify_2148
    $P4224 = root_new ['parrot';'ResizablePMCArray']
  vivify_2148:
    set $P4225, $P4224[0]
    unless_null $P4225, vivify_2149
    new $P4225, "Undef"
  vivify_2149:
    get_hll_global $P4226, "GLOBAL"
    nqp_get_package_through_who $P4227, $P4226, "PAST"
    get_who $P4228, $P4227
    set $P4229, $P4228["Var"]
    find_lex $P4230, "$name"
    unless_null $P4230, vivify_2150
    new $P4230, "Undef"
  vivify_2150:
.annotate 'line', 1400
    find_lex $P4231, "$sigil"
    unless_null $P4231, vivify_2151
    new $P4231, "Undef"
  vivify_2151:
    $P4232 = "vivitype"($P4231)
    find_lex $P4233, "$/"
    unless_null $P4233, vivify_2152
    new $P4233, "Undef"
  vivify_2152:
    $P4234 = $P4229."new"($P4230 :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P4232 :named("viviself"), $P4233 :named("node"))
.annotate 'line', 1398
    $P4225."push"($P4234)
.annotate 'line', 1403
    find_lex $P4235, "$BLOCK"
    unless_null $P4235, vivify_2153
    new $P4235, "Undef"
  vivify_2153:
    find_lex $P4236, "$name"
    unless_null $P4236, vivify_2154
    new $P4236, "Undef"
  vivify_2154:
    $P4235."symbol"($P4236, "lexical" :named("scope"))
.annotate 'line', 1397
    goto if_4205_end
  if_4205:
.annotate 'line', 1392
    find_lex $P4211, "$/"
    unless_null $P4211, vivify_2155
    $P4211 = root_new ['parrot';'Hash']
  vivify_2155:
    set $P4212, $P4211["variable"]
    unless_null $P4212, vivify_2156
    new $P4212, "Undef"
  vivify_2156:
    set $S4213, $P4212
    new $P4214, 'String'
    set $P4214, $S4213
    store_lex "$name", $P4214
.annotate 'line', 1393
    find_lex $P4215, "$name"
    unless_null $P4215, vivify_2157
    new $P4215, "Undef"
  vivify_2157:
    new $P4216, "ResizablePMCArray"
    push $P4216, $P4215
    find_lex $P4217, "$/"
    unless_null $P4217, vivify_2158
    new $P4217, "Undef"
  vivify_2158:
    $P4218 = "lexical_package_lookup"($P4216, $P4217)
    store_lex "$past", $P4218
.annotate 'line', 1394
    find_lex $P4219, "$past"
    unless_null $P4219, vivify_2159
    new $P4219, "Undef"
  vivify_2159:
    find_lex $P4220, "$sigil"
    unless_null $P4220, vivify_2160
    new $P4220, "Undef"
  vivify_2160:
    $P4221 = "vivitype"($P4220)
    $P4219."viviself"($P4221)
.annotate 'line', 1395
    find_lex $P4222, "$BLOCK"
    unless_null $P4222, vivify_2161
    new $P4222, "Undef"
  vivify_2161:
    find_lex $P4223, "$name"
    unless_null $P4223, vivify_2162
    new $P4223, "Undef"
  vivify_2162:
    $P4222."symbol"($P4223, "package" :named("scope"))
  if_4205_end:
.annotate 'line', 1388
    goto if_4144_end
  if_4144:
.annotate 'line', 1368
    .const 'Sub' $P4151 = "504_1304516047.681" 
    capture_lex $P4151
    $P4151()
  if_4144_end:
.annotate 'line', 1405
    find_lex $P4237, "$/"
    find_lex $P4238, "$past"
    unless_null $P4238, vivify_2192
    new $P4238, "Undef"
  vivify_2192:
    $P4239 = $P4237."!make"($P4238)
.annotate 'line', 1360
    .return ($P4239)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4150"  :anon :subid("504_1304516047.681") :outer("503_1304516047.681")
.annotate 'line', 1375
    $P4152 = root_new ['parrot';'Hash']
    .lex "%lit_args", $P4152
.annotate 'line', 1376
    $P4153 = root_new ['parrot';'Hash']
    .lex "%obj_args", $P4153
.annotate 'line', 1370
    find_dynamic_lex $P4160, "$*PKGDECL"
    unless_null $P4160, vivify_2163
    get_hll_global $P4158, "GLOBAL"
    get_who $P4159, $P4158
    set $P4160, $P4159["$PKGDECL"]
    unless_null $P4160, vivify_2164
    die "Contextual $*PKGDECL not found"
  vivify_2164:
  vivify_2163:
    concat $P4161, $P4160, "-attr"
    find_dynamic_lex $P4157, "%*HOW"
    unless_null $P4157, vivify_2165
    get_hll_global $P4155, "GLOBAL"
    get_who $P4156, $P4155
    set $P4157, $P4156["%HOW"]
    unless_null $P4157, vivify_2166
    die "Contextual %*HOW not found"
  vivify_2166:
  vivify_2165:
    exists $I4162, $P4157[$P4161]
    if $I4162, unless_4154_end
.annotate 'line', 1371
    find_lex $P4163, "$/"
    unless_null $P4163, vivify_2167
    new $P4163, "Undef"
  vivify_2167:
    $P4164 = $P4163."CURSOR"()
    find_dynamic_lex $P4167, "$*PKGDECL"
    unless_null $P4167, vivify_2168
    get_hll_global $P4165, "GLOBAL"
    get_who $P4166, $P4165
    set $P4167, $P4166["$PKGDECL"]
    unless_null $P4167, vivify_2169
    die "Contextual $*PKGDECL not found"
  vivify_2169:
  vivify_2168:
    concat $P4168, $P4167, " packages do not support attributes"
    $P4164."panic"($P4168)
  unless_4154_end:
.annotate 'line', 1370
    find_lex $P4169, "%lit_args"
    unless_null $P4169, vivify_2170
    $P4169 = root_new ['parrot';'Hash']
  vivify_2170:
    find_lex $P4170, "%obj_args"
    unless_null $P4170, vivify_2171
    $P4170 = root_new ['parrot';'Hash']
  vivify_2171:
.annotate 'line', 1377
    find_lex $P4171, "$name"
    unless_null $P4171, vivify_2172
    new $P4171, "Undef"
  vivify_2172:
    find_lex $P4172, "%lit_args"
    unless_null $P4172, vivify_2173
    $P4172 = root_new ['parrot';'Hash']
    store_lex "%lit_args", $P4172
  vivify_2173:
    set $P4172["name"], $P4171
.annotate 'line', 1378
    find_lex $P4174, "$/"
    unless_null $P4174, vivify_2174
    $P4174 = root_new ['parrot';'Hash']
  vivify_2174:
    set $P4175, $P4174["typename"]
    unless_null $P4175, vivify_2175
    new $P4175, "Undef"
  vivify_2175:
    unless $P4175, if_4173_end
.annotate 'line', 1379
    find_lex $P4176, "$/"
    unless_null $P4176, vivify_2176
    $P4176 = root_new ['parrot';'Hash']
  vivify_2176:
    set $P4177, $P4176["typename"]
    unless_null $P4177, vivify_2177
    $P4177 = root_new ['parrot';'ResizablePMCArray']
  vivify_2177:
    set $P4178, $P4177[0]
    unless_null $P4178, vivify_2178
    new $P4178, "Undef"
  vivify_2178:
    set $S4179, $P4178
    new $P4180, "ResizablePMCArray"
    push $P4180, $S4179
    find_lex $P4181, "$/"
    unless_null $P4181, vivify_2179
    new $P4181, "Undef"
  vivify_2179:
    $P4182 = "find_sym"($P4180, $P4181)
    find_lex $P4183, "%obj_args"
    unless_null $P4183, vivify_2180
    $P4183 = root_new ['parrot';'Hash']
    store_lex "%obj_args", $P4183
  vivify_2180:
    set $P4183["type"], $P4182
  if_4173_end:
.annotate 'line', 1383
    find_dynamic_lex $P4186, "$*SC"
    unless_null $P4186, vivify_2181
    get_hll_global $P4184, "GLOBAL"
    get_who $P4185, $P4184
    set $P4186, $P4185["$SC"]
    unless_null $P4186, vivify_2182
    die "Contextual $*SC not found"
  vivify_2182:
  vivify_2181:
    find_dynamic_lex $P4189, "$*PACKAGE"
    unless_null $P4189, vivify_2183
    get_hll_global $P4187, "GLOBAL"
    get_who $P4188, $P4187
    set $P4189, $P4188["$PACKAGE"]
    unless_null $P4189, vivify_2184
    die "Contextual $*PACKAGE not found"
  vivify_2184:
  vivify_2183:
    find_dynamic_lex $P4192, "$*PKGDECL"
    unless_null $P4192, vivify_2185
    get_hll_global $P4190, "GLOBAL"
    get_who $P4191, $P4190
    set $P4192, $P4191["$PKGDECL"]
    unless_null $P4192, vivify_2186
    die "Contextual $*PKGDECL not found"
  vivify_2186:
  vivify_2185:
    concat $P4193, $P4192, "-attr"
    find_dynamic_lex $P4196, "%*HOW"
    unless_null $P4196, vivify_2187
    get_hll_global $P4194, "GLOBAL"
    get_who $P4195, $P4194
    set $P4196, $P4195["%HOW"]
    unless_null $P4196, vivify_2188
    die "Contextual %*HOW not found"
  vivify_2188:
  vivify_2187:
    set $P4197, $P4196[$P4193]
    unless_null $P4197, vivify_2189
    new $P4197, "Undef"
  vivify_2189:
    find_lex $P4198, "%lit_args"
    unless_null $P4198, vivify_2190
    $P4198 = root_new ['parrot';'Hash']
  vivify_2190:
    find_lex $P4199, "%obj_args"
    unless_null $P4199, vivify_2191
    $P4199 = root_new ['parrot';'Hash']
  vivify_2191:
    $P4186."pkg_add_attribute"($P4189, $P4197, $P4198, $P4199)
.annotate 'line', 1386
    get_hll_global $P4200, "GLOBAL"
    nqp_get_package_through_who $P4201, $P4200, "PAST"
    get_who $P4202, $P4201
    set $P4203, $P4202["Stmts"]
    $P4204 = $P4203."new"()
    store_lex "$past", $P4204
.annotate 'line', 1368
    .return ($P4204)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("505_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4241
    .param pmc param_4242
.annotate 'line', 1408
    .lex "self", param_4241
    .lex "$/", param_4242
    find_lex $P4243, "$/"
    find_lex $P4244, "$/"
    unless_null $P4244, vivify_2193
    $P4244 = root_new ['parrot';'Hash']
  vivify_2193:
    set $P4245, $P4244["routine_def"]
    unless_null $P4245, vivify_2194
    new $P4245, "Undef"
  vivify_2194:
    $P4246 = $P4245."ast"()
    $P4247 = $P4243."!make"($P4246)
    .return ($P4247)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("506_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4249
    .param pmc param_4250
.annotate 'line', 1409
    .lex "self", param_4249
    .lex "$/", param_4250
    find_lex $P4251, "$/"
    find_lex $P4252, "$/"
    unless_null $P4252, vivify_2195
    $P4252 = root_new ['parrot';'Hash']
  vivify_2195:
    set $P4253, $P4252["method_def"]
    unless_null $P4253, vivify_2196
    new $P4253, "Undef"
  vivify_2196:
    $P4254 = $P4253."ast"()
    $P4255 = $P4251."!make"($P4254)
    .return ($P4255)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("507_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4257
    .param pmc param_4258
.annotate 'line', 1411
    .const 'Sub' $P4571 = "513_1304516047.681" 
    capture_lex $P4571
    .const 'Sub' $P4280 = "508_1304516047.681" 
    capture_lex $P4280
    .lex "self", param_4257
    .lex "$/", param_4258
.annotate 'line', 1414
    new $P4259, "Undef"
    .lex "$past", $P4259
.annotate 'line', 1425
    new $P4260, "Undef"
    .lex "$block", $P4260
.annotate 'line', 1411
    find_lex $P4261, "$past"
    unless_null $P4261, vivify_2197
    new $P4261, "Undef"
  vivify_2197:
.annotate 'line', 1415
    find_lex $P4263, "$/"
    unless_null $P4263, vivify_2198
    $P4263 = root_new ['parrot';'Hash']
  vivify_2198:
    set $P4264, $P4263["onlystar"]
    unless_null $P4264, vivify_2199
    new $P4264, "Undef"
  vivify_2199:
    if $P4264, if_4262
.annotate 'line', 1419
    find_lex $P4266, "$/"
    unless_null $P4266, vivify_2200
    $P4266 = root_new ['parrot';'Hash']
  vivify_2200:
    set $P4267, $P4266["blockoid"]
    unless_null $P4267, vivify_2201
    new $P4267, "Undef"
  vivify_2201:
    $P4268 = $P4267."ast"()
    store_lex "$past", $P4268
.annotate 'line', 1420
    find_lex $P4269, "$past"
    unless_null $P4269, vivify_2202
    new $P4269, "Undef"
  vivify_2202:
    $P4269."blocktype"("declaration")
.annotate 'line', 1421
    find_dynamic_lex $P4273, "$*RETURN_USED"
    unless_null $P4273, vivify_2203
    get_hll_global $P4271, "GLOBAL"
    get_who $P4272, $P4271
    set $P4273, $P4272["$RETURN_USED"]
    unless_null $P4273, vivify_2204
    die "Contextual $*RETURN_USED not found"
  vivify_2204:
  vivify_2203:
    unless $P4273, if_4270_end
.annotate 'line', 1422
    find_lex $P4274, "$past"
    unless_null $P4274, vivify_2205
    new $P4274, "Undef"
  vivify_2205:
    $P4274."control"("return_pir")
  if_4270_end:
.annotate 'line', 1418
    goto if_4262_end
  if_4262:
.annotate 'line', 1416
    $P4265 = "only_star_block"()
    store_lex "$past", $P4265
  if_4262_end:
.annotate 'line', 1425
    find_lex $P4275, "$past"
    unless_null $P4275, vivify_2206
    new $P4275, "Undef"
  vivify_2206:
    store_lex "$block", $P4275
.annotate 'line', 1427
    find_lex $P4277, "$/"
    unless_null $P4277, vivify_2207
    $P4277 = root_new ['parrot';'Hash']
  vivify_2207:
    set $P4278, $P4277["deflongname"]
    unless_null $P4278, vivify_2208
    new $P4278, "Undef"
  vivify_2208:
    unless $P4278, if_4276_end
    .const 'Sub' $P4280 = "508_1304516047.681" 
    capture_lex $P4280
    $P4280()
  if_4276_end:
.annotate 'line', 1528
    find_lex $P4560, "$block"
    unless_null $P4560, vivify_2314
    new $P4560, "Undef"
  vivify_2314:
    find_lex $P4561, "$past"
    unless_null $P4561, vivify_2315
    $P4561 = root_new ['parrot';'Hash']
    store_lex "$past", $P4561
  vivify_2315:
    set $P4561["block_past"], $P4560
.annotate 'line', 1529
    find_lex $P4563, "$/"
    unless_null $P4563, vivify_2316
    $P4563 = root_new ['parrot';'Hash']
  vivify_2316:
    set $P4564, $P4563["trait"]
    unless_null $P4564, vivify_2317
    new $P4564, "Undef"
  vivify_2317:
    unless $P4564, if_4562_end
.annotate 'line', 1530
    find_lex $P4566, "$/"
    unless_null $P4566, vivify_2318
    $P4566 = root_new ['parrot';'Hash']
  vivify_2318:
    set $P4567, $P4566["trait"]
    unless_null $P4567, vivify_2319
    new $P4567, "Undef"
  vivify_2319:
    defined $I4568, $P4567
    unless $I4568, for_undef_2320
    iter $P4565, $P4567
    new $P4578, 'ExceptionHandler'
    set_label $P4578, loop4577_handler
    $P4578."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4578
  loop4577_test:
    unless $P4565, loop4577_done
    shift $P4569, $P4565
  loop4577_redo:
    .const 'Sub' $P4571 = "513_1304516047.681" 
    capture_lex $P4571
    $P4571($P4569)
  loop4577_next:
    goto loop4577_test
  loop4577_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4579, exception, 'type'
    eq $P4579, .CONTROL_LOOP_NEXT, loop4577_next
    eq $P4579, .CONTROL_LOOP_REDO, loop4577_redo
  loop4577_done:
    pop_eh 
  for_undef_2320:
  if_4562_end:
.annotate 'line', 1533
    find_lex $P4580, "$/"
    find_lex $P4581, "$past"
    unless_null $P4581, vivify_2323
    new $P4581, "Undef"
  vivify_2323:
    $P4582 = $P4580."!make"($P4581)
.annotate 'line', 1411
    .return ($P4582)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4279"  :anon :subid("508_1304516047.681") :outer("507_1304516047.681")
.annotate 'line', 1427
    .const 'Sub' $P4434 = "512_1304516047.681" 
    capture_lex $P4434
    .const 'Sub' $P4321 = "509_1304516047.681" 
    capture_lex $P4321
.annotate 'line', 1428
    new $P4281, "Undef"
    .lex "$name", $P4281
    find_lex $P4282, "$/"
    unless_null $P4282, vivify_2209
    $P4282 = root_new ['parrot';'Hash']
  vivify_2209:
    set $P4283, $P4282["sigil"]
    unless_null $P4283, vivify_2210
    $P4283 = root_new ['parrot';'ResizablePMCArray']
  vivify_2210:
    set $P4284, $P4283[0]
    unless_null $P4284, vivify_2211
    new $P4284, "Undef"
  vivify_2211:
    set $S4285, $P4284
    new $P4286, 'String'
    set $P4286, $S4285
    find_lex $P4287, "$/"
    unless_null $P4287, vivify_2212
    $P4287 = root_new ['parrot';'Hash']
  vivify_2212:
    set $P4288, $P4287["deflongname"]
    unless_null $P4288, vivify_2213
    $P4288 = root_new ['parrot';'ResizablePMCArray']
  vivify_2213:
    set $P4289, $P4288[0]
    unless_null $P4289, vivify_2214
    new $P4289, "Undef"
  vivify_2214:
    $S4290 = $P4289."ast"()
    concat $P4291, $P4286, $S4290
    store_lex "$name", $P4291
.annotate 'line', 1429
    find_lex $P4292, "$past"
    unless_null $P4292, vivify_2215
    new $P4292, "Undef"
  vivify_2215:
    find_lex $P4293, "$name"
    unless_null $P4293, vivify_2216
    new $P4293, "Undef"
  vivify_2216:
    $P4292."name"($P4293)
.annotate 'line', 1430
    find_dynamic_lex $P4301, "$*SCOPE"
    unless_null $P4301, vivify_2217
    get_hll_global $P4299, "GLOBAL"
    get_who $P4300, $P4299
    set $P4301, $P4300["$SCOPE"]
    unless_null $P4301, vivify_2218
    die "Contextual $*SCOPE not found"
  vivify_2218:
  vivify_2217:
    set $S4302, $P4301
    iseq $I4303, $S4302, ""
    unless $I4303, unless_4298
    new $P4297, 'Integer'
    set $P4297, $I4303
    goto unless_4298_end
  unless_4298:
    find_dynamic_lex $P4306, "$*SCOPE"
    unless_null $P4306, vivify_2219
    get_hll_global $P4304, "GLOBAL"
    get_who $P4305, $P4304
    set $P4306, $P4305["$SCOPE"]
    unless_null $P4306, vivify_2220
    die "Contextual $*SCOPE not found"
  vivify_2220:
  vivify_2219:
    set $S4307, $P4306
    iseq $I4308, $S4307, "my"
    new $P4297, 'Integer'
    set $P4297, $I4308
  unless_4298_end:
    unless $P4297, unless_4296
    set $P4295, $P4297
    goto unless_4296_end
  unless_4296:
    find_dynamic_lex $P4311, "$*SCOPE"
    unless_null $P4311, vivify_2221
    get_hll_global $P4309, "GLOBAL"
    get_who $P4310, $P4309
    set $P4311, $P4310["$SCOPE"]
    unless_null $P4311, vivify_2222
    die "Contextual $*SCOPE not found"
  vivify_2222:
  vivify_2221:
    set $S4312, $P4311
    iseq $I4313, $S4312, "our"
    new $P4295, 'Integer'
    set $P4295, $I4313
  unless_4296_end:
    if $P4295, if_4294
.annotate 'line', 1518
    find_lex $P4541, "$/"
    unless_null $P4541, vivify_2223
    new $P4541, "Undef"
  vivify_2223:
    $P4542 = $P4541."CURSOR"()
    find_dynamic_lex $P4545, "$*SCOPE"
    unless_null $P4545, vivify_2224
    get_hll_global $P4543, "GLOBAL"
    get_who $P4544, $P4543
    set $P4545, $P4544["$SCOPE"]
    unless_null $P4545, vivify_2225
    die "Contextual $*SCOPE not found"
  vivify_2225:
  vivify_2224:
    concat $P4546, $P4545, " scoped routines are not supported yet"
    $P4542."panic"($P4546)
.annotate 'line', 1517
    goto if_4294_end
  if_4294:
.annotate 'line', 1431
    find_dynamic_lex $P4317, "$*MULTINESS"
    unless_null $P4317, vivify_2226
    get_hll_global $P4315, "GLOBAL"
    get_who $P4316, $P4315
    set $P4317, $P4316["$MULTINESS"]
    unless_null $P4317, vivify_2227
    die "Contextual $*MULTINESS not found"
  vivify_2227:
  vivify_2226:
    set $S4318, $P4317
    iseq $I4319, $S4318, "multi"
    if $I4319, if_4314
.annotate 'line', 1482
    find_dynamic_lex $P4430, "$*MULTINESS"
    unless_null $P4430, vivify_2228
    get_hll_global $P4428, "GLOBAL"
    get_who $P4429, $P4428
    set $P4430, $P4429["$MULTINESS"]
    unless_null $P4430, vivify_2229
    die "Contextual $*MULTINESS not found"
  vivify_2229:
  vivify_2228:
    set $S4431, $P4430
    iseq $I4432, $S4431, "proto"
    if $I4432, if_4427
.annotate 'line', 1501
    find_lex $P4484, "$?PACKAGE"
    get_who $P4485, $P4484
    set $P4486, $P4485["@BLOCK"]
    unless_null $P4486, vivify_2230
    $P4486 = root_new ['parrot';'ResizablePMCArray']
  vivify_2230:
    set $P4487, $P4486[0]
    unless_null $P4487, vivify_2231
    $P4487 = root_new ['parrot';'ResizablePMCArray']
  vivify_2231:
    set $P4488, $P4487[0]
    unless_null $P4488, vivify_2232
    new $P4488, "Undef"
  vivify_2232:
    get_hll_global $P4489, "GLOBAL"
    nqp_get_package_through_who $P4490, $P4489, "PAST"
    get_who $P4491, $P4490
    set $P4492, $P4491["Var"]
    find_lex $P4493, "$name"
    unless_null $P4493, vivify_2233
    new $P4493, "Undef"
  vivify_2233:
    find_lex $P4494, "$past"
    unless_null $P4494, vivify_2234
    new $P4494, "Undef"
  vivify_2234:
    $P4495 = $P4492."new"($P4493 :named("name"), 1 :named("isdecl"), $P4494 :named("viviself"), "lexical" :named("scope"))
    $P4488."push"($P4495)
.annotate 'line', 1503
    find_lex $P4496, "$?PACKAGE"
    get_who $P4497, $P4496
    set $P4498, $P4497["@BLOCK"]
    unless_null $P4498, vivify_2235
    $P4498 = root_new ['parrot';'ResizablePMCArray']
  vivify_2235:
    set $P4499, $P4498[0]
    unless_null $P4499, vivify_2236
    new $P4499, "Undef"
  vivify_2236:
    find_lex $P4500, "$name"
    unless_null $P4500, vivify_2237
    new $P4500, "Undef"
  vivify_2237:
    $P4499."symbol"($P4500, "lexical" :named("scope"))
.annotate 'line', 1504
    find_dynamic_lex $P4504, "$*SCOPE"
    unless_null $P4504, vivify_2238
    get_hll_global $P4502, "GLOBAL"
    get_who $P4503, $P4502
    set $P4504, $P4503["$SCOPE"]
    unless_null $P4504, vivify_2239
    die "Contextual $*SCOPE not found"
  vivify_2239:
  vivify_2238:
    set $S4505, $P4504
    iseq $I4506, $S4505, "our"
    unless $I4506, if_4501_end
.annotate 'line', 1507
    find_dynamic_lex $P4509, "$*SC"
    unless_null $P4509, vivify_2240
    get_hll_global $P4507, "GLOBAL"
    get_who $P4508, $P4507
    set $P4509, $P4508["$SC"]
    unless_null $P4509, vivify_2241
    die "Contextual $*SC not found"
  vivify_2241:
  vivify_2240:
    find_dynamic_lex $P4512, "$*PACKAGE"
    unless_null $P4512, vivify_2242
    get_hll_global $P4510, "GLOBAL"
    get_who $P4511, $P4510
    set $P4512, $P4511["$PACKAGE"]
    unless_null $P4512, vivify_2243
    die "Contextual $*PACKAGE not found"
  vivify_2243:
  vivify_2242:
    find_lex $P4513, "$name"
    unless_null $P4513, vivify_2244
    new $P4513, "Undef"
  vivify_2244:
    find_lex $P4514, "$past"
    unless_null $P4514, vivify_2245
    new $P4514, "Undef"
  vivify_2245:
    $P4509."install_package_routine"($P4512, $P4513, $P4514)
.annotate 'line', 1508
    find_lex $P4515, "$?PACKAGE"
    get_who $P4516, $P4515
    set $P4517, $P4516["@BLOCK"]
    unless_null $P4517, vivify_2246
    $P4517 = root_new ['parrot';'ResizablePMCArray']
  vivify_2246:
    set $P4518, $P4517[0]
    unless_null $P4518, vivify_2247
    $P4518 = root_new ['parrot';'ResizablePMCArray']
  vivify_2247:
    set $P4519, $P4518[0]
    unless_null $P4519, vivify_2248
    new $P4519, "Undef"
  vivify_2248:
    get_hll_global $P4520, "GLOBAL"
    nqp_get_package_through_who $P4521, $P4520, "PAST"
    get_who $P4522, $P4521
    set $P4523, $P4522["Op"]
.annotate 'line', 1510
    find_lex $P4524, "$name"
    unless_null $P4524, vivify_2249
    new $P4524, "Undef"
  vivify_2249:
    new $P4525, "ResizablePMCArray"
    push $P4525, $P4524
    find_lex $P4526, "$/"
    unless_null $P4526, vivify_2250
    new $P4526, "Undef"
  vivify_2250:
    $P4527 = "lexical_package_lookup"($P4525, $P4526)
.annotate 'line', 1511
    get_hll_global $P4528, "GLOBAL"
    nqp_get_package_through_who $P4529, $P4528, "PAST"
    get_who $P4530, $P4529
    set $P4531, $P4530["Var"]
    find_lex $P4532, "$name"
    unless_null $P4532, vivify_2251
    new $P4532, "Undef"
  vivify_2251:
    $P4533 = $P4531."new"($P4532 :named("name"), "lexical" :named("scope"))
    $P4534 = $P4523."new"($P4527, $P4533, "bind" :named("pasttype"))
.annotate 'line', 1508
    $P4519."push"($P4534)
  if_4501_end:
.annotate 'line', 1500
    goto if_4427_end
  if_4427:
.annotate 'line', 1482
    .const 'Sub' $P4434 = "512_1304516047.681" 
    capture_lex $P4434
    $P4434()
  if_4427_end:
    goto if_4314_end
  if_4314:
.annotate 'line', 1431
    .const 'Sub' $P4321 = "509_1304516047.681" 
    capture_lex $P4321
    $P4321()
  if_4314_end:
.annotate 'line', 1515
    get_hll_global $P4535, "GLOBAL"
    nqp_get_package_through_who $P4536, $P4535, "PAST"
    get_who $P4537, $P4536
    set $P4538, $P4537["Var"]
    find_lex $P4539, "$name"
    unless_null $P4539, vivify_2309
    new $P4539, "Undef"
  vivify_2309:
    $P4540 = $P4538."new"($P4539 :named("name"))
    store_lex "$past", $P4540
  if_4294_end:
.annotate 'line', 1522
    find_lex $P4551, "$name"
    unless_null $P4551, vivify_2310
    new $P4551, "Undef"
  vivify_2310:
    set $S4552, $P4551
    iseq $I4553, $S4552, "MAIN"
    if $I4553, if_4550
    new $P4549, 'Integer'
    set $P4549, $I4553
    goto if_4550_end
  if_4550:
    find_dynamic_lex $P4556, "$*MULTINESS"
    unless_null $P4556, vivify_2311
    get_hll_global $P4554, "GLOBAL"
    get_who $P4555, $P4554
    set $P4556, $P4555["$MULTINESS"]
    unless_null $P4556, vivify_2312
    die "Contextual $*MULTINESS not found"
  vivify_2312:
  vivify_2311:
    set $S4557, $P4556
    isne $I4558, $S4557, "multi"
    new $P4549, 'Integer'
    set $P4549, $I4558
  if_4550_end:
    if $P4549, if_4548
    set $P4547, $P4549
    goto if_4548_end
  if_4548:
.annotate 'line', 1523
    find_lex $P4559, "$block"
    unless_null $P4559, vivify_2313
    new $P4559, "Undef"
  vivify_2313:
    store_dynamic_lex "$*MAIN_SUB", $P4559
.annotate 'line', 1522
    set $P4547, $P4559
  if_4548_end:
.annotate 'line', 1427
    .return ($P4547)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4433"  :anon :subid("512_1304516047.681") :outer("508_1304516047.681")
.annotate 'line', 1487
    new $P4435, "Undef"
    .lex "$cholder", $P4435
.annotate 'line', 1486
    find_dynamic_lex $P4439, "$*SCOPE"
    unless_null $P4439, vivify_2252
    get_hll_global $P4437, "GLOBAL"
    get_who $P4438, $P4437
    set $P4439, $P4438["$SCOPE"]
    unless_null $P4439, vivify_2253
    die "Contextual $*SCOPE not found"
  vivify_2253:
  vivify_2252:
    set $S4440, $P4439
    iseq $I4441, $S4440, "our"
    unless $I4441, if_4436_end
    die "our-scoped protos not yet implemented"
  if_4436_end:
.annotate 'line', 1487
    get_hll_global $P4442, "GLOBAL"
    nqp_get_package_through_who $P4443, $P4442, "PAST"
    get_who $P4444, $P4443
    set $P4445, $P4444["Op"]
    $P4446 = $P4445."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4446
.annotate 'line', 1488
    find_lex $P4447, "$?PACKAGE"
    get_who $P4448, $P4447
    set $P4449, $P4448["@BLOCK"]
    unless_null $P4449, vivify_2254
    $P4449 = root_new ['parrot';'ResizablePMCArray']
  vivify_2254:
    set $P4450, $P4449[0]
    unless_null $P4450, vivify_2255
    $P4450 = root_new ['parrot';'ResizablePMCArray']
  vivify_2255:
    set $P4451, $P4450[0]
    unless_null $P4451, vivify_2256
    new $P4451, "Undef"
  vivify_2256:
    get_hll_global $P4452, "GLOBAL"
    nqp_get_package_through_who $P4453, $P4452, "PAST"
    get_who $P4454, $P4453
    set $P4455, $P4454["Var"]
    find_lex $P4456, "$name"
    unless_null $P4456, vivify_2257
    new $P4456, "Undef"
  vivify_2257:
    find_lex $P4457, "$past"
    unless_null $P4457, vivify_2258
    new $P4457, "Undef"
  vivify_2258:
    $P4458 = $P4455."new"($P4456 :named("name"), 1 :named("isdecl"), $P4457 :named("viviself"), "lexical" :named("scope"))
    $P4451."push"($P4458)
.annotate 'line', 1490
    find_lex $P4459, "$?PACKAGE"
    get_who $P4460, $P4459
    set $P4461, $P4460["@BLOCK"]
    unless_null $P4461, vivify_2259
    $P4461 = root_new ['parrot';'ResizablePMCArray']
  vivify_2259:
    set $P4462, $P4461[0]
    unless_null $P4462, vivify_2260
    $P4462 = root_new ['parrot';'ResizablePMCArray']
  vivify_2260:
    set $P4463, $P4462[0]
    unless_null $P4463, vivify_2261
    new $P4463, "Undef"
  vivify_2261:
    get_hll_global $P4464, "GLOBAL"
    nqp_get_package_through_who $P4465, $P4464, "PAST"
    get_who $P4466, $P4465
    set $P4467, $P4466["Op"]
.annotate 'line', 1492
    get_hll_global $P4468, "GLOBAL"
    nqp_get_package_through_who $P4469, $P4468, "PAST"
    get_who $P4470, $P4469
    set $P4471, $P4470["Var"]
    find_lex $P4472, "$name"
    unless_null $P4472, vivify_2262
    new $P4472, "Undef"
  vivify_2262:
    $P4473 = $P4471."new"($P4472 :named("name"))
    find_lex $P4474, "$cholder"
    unless_null $P4474, vivify_2263
    new $P4474, "Undef"
  vivify_2263:
    $P4475 = $P4467."new"($P4473, $P4474, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1490
    $P4463."push"($P4475)
.annotate 'line', 1495
    find_lex $P4476, "$?PACKAGE"
    get_who $P4477, $P4476
    set $P4478, $P4477["@BLOCK"]
    unless_null $P4478, vivify_2264
    $P4478 = root_new ['parrot';'ResizablePMCArray']
  vivify_2264:
    set $P4479, $P4478[0]
    unless_null $P4479, vivify_2265
    new $P4479, "Undef"
  vivify_2265:
    find_lex $P4480, "$name"
    unless_null $P4480, vivify_2266
    new $P4480, "Undef"
  vivify_2266:
    find_lex $P4481, "$cholder"
    unless_null $P4481, vivify_2267
    new $P4481, "Undef"
  vivify_2267:
    $P4479."symbol"($P4480, "lexical" :named("scope"), 1 :named("proto"), $P4481 :named("cholder"))
.annotate 'line', 1498
    find_lex $P4482, "$past"
    unless_null $P4482, vivify_2268
    new $P4482, "Undef"
  vivify_2268:
    $P4483 = $P4482."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1482
    .return ($P4483)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4320"  :anon :subid("509_1304516047.681") :outer("508_1304516047.681")
.annotate 'line', 1431
    .const 'Sub' $P4343 = "510_1304516047.681" 
    capture_lex $P4343
.annotate 'line', 1434
    new $P4322, "Undef"
    .lex "$cholder", $P4322
.annotate 'line', 1435
    $P4323 = root_new ['parrot';'Hash']
    .lex "%sym", $P4323
.annotate 'line', 1433
    find_dynamic_lex $P4327, "$*SCOPE"
    unless_null $P4327, vivify_2269
    get_hll_global $P4325, "GLOBAL"
    get_who $P4326, $P4325
    set $P4327, $P4326["$SCOPE"]
    unless_null $P4327, vivify_2270
    die "Contextual $*SCOPE not found"
  vivify_2270:
  vivify_2269:
    set $S4328, $P4327
    iseq $I4329, $S4328, "our"
    unless $I4329, if_4324_end
    die "our-scoped multis not yet implemented"
  if_4324_end:
    find_lex $P4330, "$cholder"
    unless_null $P4330, vivify_2271
    new $P4330, "Undef"
  vivify_2271:
.annotate 'line', 1435
    find_lex $P4331, "$?PACKAGE"
    get_who $P4332, $P4331
    set $P4333, $P4332["@BLOCK"]
    unless_null $P4333, vivify_2272
    $P4333 = root_new ['parrot';'ResizablePMCArray']
  vivify_2272:
    set $P4334, $P4333[0]
    unless_null $P4334, vivify_2273
    new $P4334, "Undef"
  vivify_2273:
    find_lex $P4335, "$name"
    unless_null $P4335, vivify_2274
    new $P4335, "Undef"
  vivify_2274:
    $P4336 = $P4334."symbol"($P4335)
    store_lex "%sym", $P4336
.annotate 'line', 1436
    find_lex $P4338, "%sym"
    unless_null $P4338, vivify_2275
    $P4338 = root_new ['parrot';'Hash']
  vivify_2275:
    set $P4339, $P4338["cholder"]
    unless_null $P4339, vivify_2276
    new $P4339, "Undef"
  vivify_2276:
    if $P4339, if_4337
.annotate 'line', 1441
    .const 'Sub' $P4343 = "510_1304516047.681" 
    capture_lex $P4343
    $P4343()
    goto if_4337_end
  if_4337:
.annotate 'line', 1437
    find_lex $P4340, "%sym"
    unless_null $P4340, vivify_2304
    $P4340 = root_new ['parrot';'Hash']
  vivify_2304:
    set $P4341, $P4340["cholder"]
    unless_null $P4341, vivify_2305
    new $P4341, "Undef"
  vivify_2305:
    store_lex "$cholder", $P4341
  if_4337_end:
.annotate 'line', 1477
    find_lex $P4423, "$cholder"
    unless_null $P4423, vivify_2306
    new $P4423, "Undef"
  vivify_2306:
    find_lex $P4424, "$past"
    unless_null $P4424, vivify_2307
    new $P4424, "Undef"
  vivify_2307:
    $P4423."push"($P4424)
.annotate 'line', 1480
    find_lex $P4425, "$past"
    unless_null $P4425, vivify_2308
    new $P4425, "Undef"
  vivify_2308:
    $P4426 = "attach_multi_signature"($P4425)
.annotate 'line', 1431
    .return ($P4426)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4342"  :anon :subid("510_1304516047.681") :outer("509_1304516047.681")
.annotate 'line', 1441
    .const 'Sub' $P4359 = "511_1304516047.681" 
    capture_lex $P4359
.annotate 'line', 1448
    new $P4344, "Undef"
    .lex "$found_proto", $P4344
.annotate 'line', 1466
    new $P4345, "Undef"
    .lex "$dispatch_setup", $P4345
.annotate 'line', 1443
    find_lex $P4347, "%sym"
    unless_null $P4347, vivify_2277
    $P4347 = root_new ['parrot';'Hash']
  vivify_2277:
    set $P4348, $P4347["proto"]
    unless_null $P4348, vivify_2278
    new $P4348, "Undef"
  vivify_2278:
    unless $P4348, if_4346_end
.annotate 'line', 1446
    find_lex $P4349, "$/"
    unless_null $P4349, vivify_2279
    new $P4349, "Undef"
  vivify_2279:
    $P4350 = $P4349."CURSOR"()
    $P4350."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4346_end:
.annotate 'line', 1443
    find_lex $P4351, "$found_proto"
    unless_null $P4351, vivify_2280
    new $P4351, "Undef"
  vivify_2280:
.annotate 'line', 1449
    find_lex $P4353, "$?PACKAGE"
    get_who $P4354, $P4353
    set $P4355, $P4354["@BLOCK"]
    unless_null $P4355, vivify_2281
    $P4355 = root_new ['parrot';'ResizablePMCArray']
  vivify_2281:
    defined $I4356, $P4355
    unless $I4356, for_undef_2282
    iter $P4352, $P4355
    new $P4381, 'ExceptionHandler'
    set_label $P4381, loop4380_handler
    $P4381."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4381
  loop4380_test:
    unless $P4352, loop4380_done
    shift $P4357, $P4352
  loop4380_redo:
    .const 'Sub' $P4359 = "511_1304516047.681" 
    capture_lex $P4359
    $P4359($P4357)
  loop4380_next:
    goto loop4380_test
  loop4380_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4382, exception, 'type'
    eq $P4382, .CONTROL_LOOP_NEXT, loop4380_next
    eq $P4382, .CONTROL_LOOP_REDO, loop4380_redo
  loop4380_done:
    pop_eh 
  for_undef_2282:
.annotate 'line', 1460
    find_lex $P4384, "$found_proto"
    unless_null $P4384, vivify_2291
    new $P4384, "Undef"
  vivify_2291:
    if $P4384, unless_4383_end
.annotate 'line', 1461
    find_lex $P4385, "$/"
    unless_null $P4385, vivify_2292
    new $P4385, "Undef"
  vivify_2292:
    $P4386 = $P4385."CURSOR"()
    $P4386."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4383_end:
.annotate 'line', 1465
    get_hll_global $P4387, "GLOBAL"
    nqp_get_package_through_who $P4388, $P4387, "PAST"
    get_who $P4389, $P4388
    set $P4390, $P4389["Op"]
    $P4391 = $P4390."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4391
.annotate 'line', 1466
    get_hll_global $P4392, "GLOBAL"
    nqp_get_package_through_who $P4393, $P4392, "PAST"
    get_who $P4394, $P4393
    set $P4395, $P4394["Op"]
.annotate 'line', 1468
    get_hll_global $P4396, "GLOBAL"
    nqp_get_package_through_who $P4397, $P4396, "PAST"
    get_who $P4398, $P4397
    set $P4399, $P4398["Var"]
    find_lex $P4400, "$name"
    unless_null $P4400, vivify_2293
    new $P4400, "Undef"
  vivify_2293:
    $P4401 = $P4399."new"($P4400 :named("name"), "outer" :named("scope"))
    find_lex $P4402, "$cholder"
    unless_null $P4402, vivify_2294
    new $P4402, "Undef"
  vivify_2294:
    $P4403 = $P4395."new"($P4401, $P4402, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1466
    store_lex "$dispatch_setup", $P4403
.annotate 'line', 1471
    find_lex $P4404, "$?PACKAGE"
    get_who $P4405, $P4404
    set $P4406, $P4405["@BLOCK"]
    unless_null $P4406, vivify_2295
    $P4406 = root_new ['parrot';'ResizablePMCArray']
  vivify_2295:
    set $P4407, $P4406[0]
    unless_null $P4407, vivify_2296
    $P4407 = root_new ['parrot';'ResizablePMCArray']
  vivify_2296:
    set $P4408, $P4407[0]
    unless_null $P4408, vivify_2297
    new $P4408, "Undef"
  vivify_2297:
    get_hll_global $P4409, "GLOBAL"
    nqp_get_package_through_who $P4410, $P4409, "PAST"
    get_who $P4411, $P4410
    set $P4412, $P4411["Var"]
    find_lex $P4413, "$name"
    unless_null $P4413, vivify_2298
    new $P4413, "Undef"
  vivify_2298:
    find_lex $P4414, "$dispatch_setup"
    unless_null $P4414, vivify_2299
    new $P4414, "Undef"
  vivify_2299:
    $P4415 = $P4412."new"($P4413 :named("name"), 1 :named("isdecl"), $P4414 :named("viviself"), "lexical" :named("scope"))
    $P4408."push"($P4415)
.annotate 'line', 1473
    find_lex $P4416, "$?PACKAGE"
    get_who $P4417, $P4416
    set $P4418, $P4417["@BLOCK"]
    unless_null $P4418, vivify_2300
    $P4418 = root_new ['parrot';'ResizablePMCArray']
  vivify_2300:
    set $P4419, $P4418[0]
    unless_null $P4419, vivify_2301
    new $P4419, "Undef"
  vivify_2301:
    find_lex $P4420, "$name"
    unless_null $P4420, vivify_2302
    new $P4420, "Undef"
  vivify_2302:
    find_lex $P4421, "$cholder"
    unless_null $P4421, vivify_2303
    new $P4421, "Undef"
  vivify_2303:
    $P4422 = $P4419."symbol"($P4420, "lexical" :named("scope"), $P4421 :named("cholder"))
.annotate 'line', 1441
    .return ($P4422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4358"  :anon :subid("511_1304516047.681") :outer("510_1304516047.681")
    .param pmc param_4361
.annotate 'line', 1450
    $P4360 = root_new ['parrot';'Hash']
    .lex "%sym", $P4360
    .lex "$_", param_4361
    find_lex $P4362, "$_"
    unless_null $P4362, vivify_2283
    new $P4362, "Undef"
  vivify_2283:
    find_lex $P4363, "$name"
    unless_null $P4363, vivify_2284
    new $P4363, "Undef"
  vivify_2284:
    $P4364 = $P4362."symbol"($P4363)
    store_lex "%sym", $P4364
.annotate 'line', 1451
    find_lex $P4369, "%sym"
    unless_null $P4369, vivify_2285
    $P4369 = root_new ['parrot';'Hash']
  vivify_2285:
    set $P4370, $P4369["proto"]
    unless_null $P4370, vivify_2286
    new $P4370, "Undef"
  vivify_2286:
    unless $P4370, unless_4368
    set $P4367, $P4370
    goto unless_4368_end
  unless_4368:
    find_lex $P4371, "%sym"
    unless_null $P4371, vivify_2287
    $P4371 = root_new ['parrot';'Hash']
  vivify_2287:
    set $P4372, $P4371["cholder"]
    unless_null $P4372, vivify_2288
    new $P4372, "Undef"
  vivify_2288:
    set $P4367, $P4372
  unless_4368_end:
    if $P4367, if_4366
.annotate 'line', 1454
    find_lex $P4376, "%sym"
    unless_null $P4376, vivify_2289
    $P4376 = root_new ['parrot';'Hash']
  vivify_2289:
    if $P4376, if_4375
    set $P4374, $P4376
    goto if_4375_end
  if_4375:
.annotate 'line', 1455
    find_lex $P4377, "$/"
    unless_null $P4377, vivify_2290
    new $P4377, "Undef"
  vivify_2290:
    $P4378 = $P4377."CURSOR"()
    $P4379 = $P4378."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1454
    set $P4374, $P4379
  if_4375_end:
    set $P4365, $P4374
.annotate 'line', 1451
    goto if_4366_end
  if_4366:
.annotate 'line', 1452
    new $P4373, "Integer"
    assign $P4373, 1
    store_lex "$found_proto", $P4373
.annotate 'line', 1451
    set $P4365, $P4373
  if_4366_end:
.annotate 'line', 1449
    .return ($P4365)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4570"  :anon :subid("513_1304516047.681") :outer("507_1304516047.681")
    .param pmc param_4572
.annotate 'line', 1530
    .lex "$_", param_4572
    find_lex $P4573, "$_"
    unless_null $P4573, vivify_2321
    new $P4573, "Undef"
  vivify_2321:
    $P4574 = $P4573."ast"()
    find_lex $P4575, "$/"
    unless_null $P4575, vivify_2322
    new $P4575, "Undef"
  vivify_2322:
    $P4576 = $P4574($P4575)
    .return ($P4576)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("514_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4584
    .param pmc param_4585
.annotate 'line', 1537
    .const 'Sub' $P4701 = "516_1304516047.681" 
    capture_lex $P4701
    .const 'Sub' $P4623 = "515_1304516047.681" 
    capture_lex $P4623
    .lex "self", param_4584
    .lex "$/", param_4585
.annotate 'line', 1540
    new $P4586, "Undef"
    .lex "$past", $P4586
.annotate 'line', 1537
    find_lex $P4587, "$past"
    unless_null $P4587, vivify_2324
    new $P4587, "Undef"
  vivify_2324:
.annotate 'line', 1541
    find_lex $P4589, "$/"
    unless_null $P4589, vivify_2325
    $P4589 = root_new ['parrot';'Hash']
  vivify_2325:
    set $P4590, $P4589["onlystar"]
    unless_null $P4590, vivify_2326
    new $P4590, "Undef"
  vivify_2326:
    if $P4590, if_4588
.annotate 'line', 1545
    find_lex $P4592, "$/"
    unless_null $P4592, vivify_2327
    $P4592 = root_new ['parrot';'Hash']
  vivify_2327:
    set $P4593, $P4592["blockoid"]
    unless_null $P4593, vivify_2328
    new $P4593, "Undef"
  vivify_2328:
    $P4594 = $P4593."ast"()
    store_lex "$past", $P4594
.annotate 'line', 1546
    find_lex $P4595, "$past"
    unless_null $P4595, vivify_2329
    new $P4595, "Undef"
  vivify_2329:
    $P4595."blocktype"("declaration")
.annotate 'line', 1547
    find_dynamic_lex $P4599, "$*RETURN_USED"
    unless_null $P4599, vivify_2330
    get_hll_global $P4597, "GLOBAL"
    get_who $P4598, $P4597
    set $P4599, $P4598["$RETURN_USED"]
    unless_null $P4599, vivify_2331
    die "Contextual $*RETURN_USED not found"
  vivify_2331:
  vivify_2330:
    unless $P4599, if_4596_end
.annotate 'line', 1548
    find_lex $P4600, "$past"
    unless_null $P4600, vivify_2332
    new $P4600, "Undef"
  vivify_2332:
    $P4600."control"("return_pir")
  if_4596_end:
.annotate 'line', 1544
    goto if_4588_end
  if_4588:
.annotate 'line', 1542
    $P4591 = "only_star_block"()
    store_lex "$past", $P4591
  if_4588_end:
.annotate 'line', 1553
    find_lex $P4602, "$past"
    unless_null $P4602, vivify_2333
    $P4602 = root_new ['parrot';'Hash']
  vivify_2333:
    set $P4603, $P4602["signature_has_invocant"]
    unless_null $P4603, vivify_2334
    new $P4603, "Undef"
  vivify_2334:
    if $P4603, unless_4601_end
.annotate 'line', 1554
    find_lex $P4604, "$past"
    unless_null $P4604, vivify_2335
    $P4604 = root_new ['parrot';'ResizablePMCArray']
  vivify_2335:
    set $P4605, $P4604[0]
    unless_null $P4605, vivify_2336
    new $P4605, "Undef"
  vivify_2336:
    get_hll_global $P4606, "GLOBAL"
    nqp_get_package_through_who $P4607, $P4606, "PAST"
    get_who $P4608, $P4607
    set $P4609, $P4608["Var"]
.annotate 'line', 1556
    find_dynamic_lex $P4612, "$*SC"
    unless_null $P4612, vivify_2337
    get_hll_global $P4610, "GLOBAL"
    get_who $P4611, $P4610
    set $P4612, $P4611["$SC"]
    unless_null $P4612, vivify_2338
    die "Contextual $*SC not found"
  vivify_2338:
  vivify_2337:
    find_dynamic_lex $P4615, "$*PACKAGE"
    unless_null $P4615, vivify_2339
    get_hll_global $P4613, "GLOBAL"
    get_who $P4614, $P4613
    set $P4615, $P4614["$PACKAGE"]
    unless_null $P4615, vivify_2340
    die "Contextual $*PACKAGE not found"
  vivify_2340:
  vivify_2339:
    $P4616 = $P4612."get_object_sc_ref_past"($P4615)
    $P4617 = $P4609."new"("self" :named("name"), "parameter" :named("scope"), $P4616 :named("multitype"))
.annotate 'line', 1554
    $P4605."unshift"($P4617)
  unless_4601_end:
.annotate 'line', 1559
    find_lex $P4618, "$past"
    unless_null $P4618, vivify_2341
    new $P4618, "Undef"
  vivify_2341:
    $P4618."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1562
    find_lex $P4620, "$/"
    unless_null $P4620, vivify_2342
    $P4620 = root_new ['parrot';'Hash']
  vivify_2342:
    set $P4621, $P4620["deflongname"]
    unless_null $P4621, vivify_2343
    new $P4621, "Undef"
  vivify_2343:
    unless $P4621, if_4619_end
    .const 'Sub' $P4623 = "515_1304516047.681" 
    capture_lex $P4623
    $P4623()
  if_4619_end:
.annotate 'line', 1583
    find_lex $P4687, "$/"
    find_lex $P4688, "$past"
    unless_null $P4688, vivify_2374
    new $P4688, "Undef"
  vivify_2374:
    $P4687."!make"($P4688)
.annotate 'line', 1584
    find_lex $P4689, "$past"
    unless_null $P4689, vivify_2375
    new $P4689, "Undef"
  vivify_2375:
    find_lex $P4690, "$past"
    unless_null $P4690, vivify_2376
    $P4690 = root_new ['parrot';'Hash']
    store_lex "$past", $P4690
  vivify_2376:
    set $P4690["block_past"], $P4689
.annotate 'line', 1585
    find_lex $P4693, "$/"
    unless_null $P4693, vivify_2377
    $P4693 = root_new ['parrot';'Hash']
  vivify_2377:
    set $P4694, $P4693["trait"]
    unless_null $P4694, vivify_2378
    new $P4694, "Undef"
  vivify_2378:
    if $P4694, if_4692
    set $P4691, $P4694
    goto if_4692_end
  if_4692:
.annotate 'line', 1586
    find_lex $P4696, "$/"
    unless_null $P4696, vivify_2379
    $P4696 = root_new ['parrot';'Hash']
  vivify_2379:
    set $P4697, $P4696["trait"]
    unless_null $P4697, vivify_2380
    new $P4697, "Undef"
  vivify_2380:
    defined $I4698, $P4697
    unless $I4698, for_undef_2381
    iter $P4695, $P4697
    new $P4708, 'ExceptionHandler'
    set_label $P4708, loop4707_handler
    $P4708."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4708
  loop4707_test:
    unless $P4695, loop4707_done
    shift $P4699, $P4695
  loop4707_redo:
    .const 'Sub' $P4701 = "516_1304516047.681" 
    capture_lex $P4701
    $P4701($P4699)
  loop4707_next:
    goto loop4707_test
  loop4707_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4709, exception, 'type'
    eq $P4709, .CONTROL_LOOP_NEXT, loop4707_next
    eq $P4709, .CONTROL_LOOP_REDO, loop4707_redo
  loop4707_done:
    pop_eh 
  for_undef_2381:
.annotate 'line', 1585
    set $P4691, $P4695
  if_4692_end:
.annotate 'line', 1537
    .return ($P4691)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4622"  :anon :subid("515_1304516047.681") :outer("514_1304516047.681")
.annotate 'line', 1564
    new $P4624, "Undef"
    .lex "$name", $P4624
.annotate 'line', 1572
    new $P4625, "Undef"
    .lex "$meta_meth", $P4625
.annotate 'line', 1573
    new $P4626, "Undef"
    .lex "$is_dispatcher", $P4626
.annotate 'line', 1564
    find_lex $P4627, "$/"
    unless_null $P4627, vivify_2344
    $P4627 = root_new ['parrot';'Hash']
  vivify_2344:
    set $P4628, $P4627["private"]
    unless_null $P4628, vivify_2345
    new $P4628, "Undef"
  vivify_2345:
    set $S4629, $P4628
    new $P4630, 'String'
    set $P4630, $S4629
    find_lex $P4631, "$/"
    unless_null $P4631, vivify_2346
    $P4631 = root_new ['parrot';'Hash']
  vivify_2346:
    set $P4632, $P4631["deflongname"]
    unless_null $P4632, vivify_2347
    $P4632 = root_new ['parrot';'ResizablePMCArray']
  vivify_2347:
    set $P4633, $P4632[0]
    unless_null $P4633, vivify_2348
    new $P4633, "Undef"
  vivify_2348:
    $P4634 = $P4633."ast"()
    set $S4635, $P4634
    concat $P4636, $P4630, $S4635
    store_lex "$name", $P4636
.annotate 'line', 1565
    find_lex $P4637, "$past"
    unless_null $P4637, vivify_2349
    new $P4637, "Undef"
  vivify_2349:
    find_lex $P4638, "$name"
    unless_null $P4638, vivify_2350
    new $P4638, "Undef"
  vivify_2350:
    $P4637."name"($P4638)
.annotate 'line', 1569
    find_dynamic_lex $P4642, "$*MULTINESS"
    unless_null $P4642, vivify_2351
    get_hll_global $P4640, "GLOBAL"
    get_who $P4641, $P4640
    set $P4642, $P4641["$MULTINESS"]
    unless_null $P4642, vivify_2352
    die "Contextual $*MULTINESS not found"
  vivify_2352:
  vivify_2351:
    set $S4643, $P4642
    iseq $I4644, $S4643, "multi"
    unless $I4644, if_4639_end
    find_lex $P4645, "$past"
    unless_null $P4645, vivify_2353
    new $P4645, "Undef"
  vivify_2353:
    "attach_multi_signature"($P4645)
  if_4639_end:
.annotate 'line', 1572
    find_dynamic_lex $P4650, "$*MULTINESS"
    unless_null $P4650, vivify_2354
    get_hll_global $P4648, "GLOBAL"
    get_who $P4649, $P4648
    set $P4650, $P4649["$MULTINESS"]
    unless_null $P4650, vivify_2355
    die "Contextual $*MULTINESS not found"
  vivify_2355:
  vivify_2354:
    set $S4651, $P4650
    iseq $I4652, $S4651, "multi"
    if $I4652, if_4647
    new $P4654, "String"
    assign $P4654, "add_method"
    set $P4646, $P4654
    goto if_4647_end
  if_4647:
    new $P4653, "String"
    assign $P4653, "add_multi_method"
    set $P4646, $P4653
  if_4647_end:
    store_lex "$meta_meth", $P4646
.annotate 'line', 1573
    find_dynamic_lex $P4657, "$*MULTINESS"
    unless_null $P4657, vivify_2356
    get_hll_global $P4655, "GLOBAL"
    get_who $P4656, $P4655
    set $P4657, $P4656["$MULTINESS"]
    unless_null $P4657, vivify_2357
    die "Contextual $*MULTINESS not found"
  vivify_2357:
  vivify_2356:
    set $S4658, $P4657
    iseq $I4659, $S4658, "proto"
    new $P4660, 'Integer'
    set $P4660, $I4659
    store_lex "$is_dispatcher", $P4660
.annotate 'line', 1574
    find_dynamic_lex $P4663, "$*SC"
    unless_null $P4663, vivify_2358
    get_hll_global $P4661, "GLOBAL"
    get_who $P4662, $P4661
    set $P4663, $P4662["$SC"]
    unless_null $P4663, vivify_2359
    die "Contextual $*SC not found"
  vivify_2359:
  vivify_2358:
    find_dynamic_lex $P4666, "$*PACKAGE"
    unless_null $P4666, vivify_2360
    get_hll_global $P4664, "GLOBAL"
    get_who $P4665, $P4664
    set $P4666, $P4665["$PACKAGE"]
    unless_null $P4666, vivify_2361
    die "Contextual $*PACKAGE not found"
  vivify_2361:
  vivify_2360:
    find_lex $P4667, "$meta_meth"
    unless_null $P4667, vivify_2362
    new $P4667, "Undef"
  vivify_2362:
    find_lex $P4668, "$name"
    unless_null $P4668, vivify_2363
    new $P4668, "Undef"
  vivify_2363:
    find_lex $P4669, "$past"
    unless_null $P4669, vivify_2364
    new $P4669, "Undef"
  vivify_2364:
    find_lex $P4670, "$is_dispatcher"
    unless_null $P4670, vivify_2365
    new $P4670, "Undef"
  vivify_2365:
    $P4663."pkg_add_method"($P4666, $P4667, $P4668, $P4669, $P4670)
.annotate 'line', 1577
    find_dynamic_lex $P4675, "$*SCOPE"
    unless_null $P4675, vivify_2366
    get_hll_global $P4673, "GLOBAL"
    get_who $P4674, $P4673
    set $P4675, $P4674["$SCOPE"]
    unless_null $P4675, vivify_2367
    die "Contextual $*SCOPE not found"
  vivify_2367:
  vivify_2366:
    set $S4676, $P4675
    iseq $I4677, $S4676, "our"
    if $I4677, if_4672
    new $P4671, 'Integer'
    set $P4671, $I4677
    goto if_4672_end
  if_4672:
.annotate 'line', 1578
    find_dynamic_lex $P4680, "$*SC"
    unless_null $P4680, vivify_2368
    get_hll_global $P4678, "GLOBAL"
    get_who $P4679, $P4678
    set $P4680, $P4679["$SC"]
    unless_null $P4680, vivify_2369
    die "Contextual $*SC not found"
  vivify_2369:
  vivify_2368:
    find_dynamic_lex $P4683, "$*PACKAGE"
    unless_null $P4683, vivify_2370
    get_hll_global $P4681, "GLOBAL"
    get_who $P4682, $P4681
    set $P4683, $P4682["$PACKAGE"]
    unless_null $P4683, vivify_2371
    die "Contextual $*PACKAGE not found"
  vivify_2371:
  vivify_2370:
    find_lex $P4684, "$name"
    unless_null $P4684, vivify_2372
    new $P4684, "Undef"
  vivify_2372:
    find_lex $P4685, "$past"
    unless_null $P4685, vivify_2373
    new $P4685, "Undef"
  vivify_2373:
    $P4686 = $P4680."install_package_routine"($P4683, $P4684, $P4685)
.annotate 'line', 1577
    set $P4671, $P4686
  if_4672_end:
.annotate 'line', 1562
    .return ($P4671)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4700"  :anon :subid("516_1304516047.681") :outer("514_1304516047.681")
    .param pmc param_4702
.annotate 'line', 1586
    .lex "$_", param_4702
    find_lex $P4703, "$_"
    unless_null $P4703, vivify_2382
    new $P4703, "Undef"
  vivify_2382:
    $P4704 = $P4703."ast"()
    find_lex $P4705, "$/"
    unless_null $P4705, vivify_2383
    new $P4705, "Undef"
  vivify_2383:
    $P4706 = $P4704($P4705)
    .return ($P4706)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("517_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4713
    .param pmc param_4714
.annotate 'line', 1615
    .const 'Sub' $P4757 = "519_1304516047.681" 
    capture_lex $P4757
    .const 'Sub' $P4725 = "518_1304516047.681" 
    capture_lex $P4725
    .lex "self", param_4713
    .lex "$/", param_4714
.annotate 'line', 1616
    new $P4715, "Undef"
    .lex "$BLOCKINIT", $P4715
    find_lex $P4716, "$?PACKAGE"
    get_who $P4717, $P4716
    set $P4718, $P4717["@BLOCK"]
    unless_null $P4718, vivify_2384
    $P4718 = root_new ['parrot';'ResizablePMCArray']
  vivify_2384:
    set $P4719, $P4718[0]
    unless_null $P4719, vivify_2385
    $P4719 = root_new ['parrot';'ResizablePMCArray']
  vivify_2385:
    set $P4720, $P4719[0]
    unless_null $P4720, vivify_2386
    new $P4720, "Undef"
  vivify_2386:
    store_lex "$BLOCKINIT", $P4720
.annotate 'line', 1617
    find_lex $P4722, "$/"
    unless_null $P4722, vivify_2387
    $P4722 = root_new ['parrot';'Hash']
  vivify_2387:
    set $P4723, $P4722["invocant"]
    unless_null $P4723, vivify_2388
    new $P4723, "Undef"
  vivify_2388:
    unless $P4723, if_4721_end
    .const 'Sub' $P4725 = "518_1304516047.681" 
    capture_lex $P4725
    $P4725()
  if_4721_end:
.annotate 'line', 1626
    find_lex $P4752, "$/"
    unless_null $P4752, vivify_2398
    $P4752 = root_new ['parrot';'Hash']
  vivify_2398:
    set $P4753, $P4752["parameter"]
    unless_null $P4753, vivify_2399
    new $P4753, "Undef"
  vivify_2399:
    defined $I4754, $P4753
    unless $I4754, for_undef_2400
    iter $P4751, $P4753
    new $P4764, 'ExceptionHandler'
    set_label $P4764, loop4763_handler
    $P4764."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4764
  loop4763_test:
    unless $P4751, loop4763_done
    shift $P4755, $P4751
  loop4763_redo:
    .const 'Sub' $P4757 = "519_1304516047.681" 
    capture_lex $P4757
    $P4757($P4755)
  loop4763_next:
    goto loop4763_test
  loop4763_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4765, exception, 'type'
    eq $P4765, .CONTROL_LOOP_NEXT, loop4763_next
    eq $P4765, .CONTROL_LOOP_REDO, loop4763_redo
  loop4763_done:
    pop_eh 
  for_undef_2400:
.annotate 'line', 1615
    .return ($P4751)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4724"  :anon :subid("518_1304516047.681") :outer("517_1304516047.681")
.annotate 'line', 1618
    new $P4726, "Undef"
    .lex "$inv", $P4726
    find_lex $P4727, "$/"
    unless_null $P4727, vivify_2389
    $P4727 = root_new ['parrot';'Hash']
  vivify_2389:
    set $P4728, $P4727["invocant"]
    unless_null $P4728, vivify_2390
    $P4728 = root_new ['parrot';'ResizablePMCArray']
  vivify_2390:
    set $P4729, $P4728[0]
    unless_null $P4729, vivify_2391
    new $P4729, "Undef"
  vivify_2391:
    $P4730 = $P4729."ast"()
    store_lex "$inv", $P4730
.annotate 'line', 1619
    find_lex $P4731, "$BLOCKINIT"
    unless_null $P4731, vivify_2392
    new $P4731, "Undef"
  vivify_2392:
    find_lex $P4732, "$inv"
    unless_null $P4732, vivify_2393
    new $P4732, "Undef"
  vivify_2393:
    $P4731."push"($P4732)
.annotate 'line', 1620
    find_lex $P4733, "$BLOCKINIT"
    unless_null $P4733, vivify_2394
    new $P4733, "Undef"
  vivify_2394:
    get_hll_global $P4734, "GLOBAL"
    nqp_get_package_through_who $P4735, $P4734, "PAST"
    get_who $P4736, $P4735
    set $P4737, $P4736["Var"]
.annotate 'line', 1622
    get_hll_global $P4738, "GLOBAL"
    nqp_get_package_through_who $P4739, $P4738, "PAST"
    get_who $P4740, $P4739
    set $P4741, $P4740["Var"]
    find_lex $P4742, "$inv"
    unless_null $P4742, vivify_2395
    new $P4742, "Undef"
  vivify_2395:
    $P4743 = $P4742."name"()
    $P4744 = $P4741."new"("lexical" :named("scope"), $P4743 :named("name"))
    $P4745 = $P4737."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4744 :named("viviself"))
.annotate 'line', 1620
    $P4733."push"($P4745)
.annotate 'line', 1624
    new $P4746, "Integer"
    assign $P4746, 1
    find_lex $P4747, "$?PACKAGE"
    get_who $P4748, $P4747
    set $P4749, $P4748["@BLOCK"]
    unless_null $P4749, vivify_2396
    $P4749 = root_new ['parrot';'ResizablePMCArray']
    set $P4748["@BLOCK"], $P4749
  vivify_2396:
    set $P4750, $P4749[0]
    unless_null $P4750, vivify_2397
    $P4750 = root_new ['parrot';'Hash']
    set $P4749[0], $P4750
  vivify_2397:
    set $P4750["signature_has_invocant"], $P4746
.annotate 'line', 1617
    .return ($P4746)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4756"  :anon :subid("519_1304516047.681") :outer("517_1304516047.681")
    .param pmc param_4758
.annotate 'line', 1626
    .lex "$_", param_4758
    find_lex $P4759, "$BLOCKINIT"
    unless_null $P4759, vivify_2401
    new $P4759, "Undef"
  vivify_2401:
    find_lex $P4760, "$_"
    unless_null $P4760, vivify_2402
    new $P4760, "Undef"
  vivify_2402:
    $P4761 = $P4760."ast"()
    $P4762 = $P4759."push"($P4761)
    .return ($P4762)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("520_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4767
    .param pmc param_4768
.annotate 'line', 1629
    .lex "self", param_4767
    .lex "$/", param_4768
.annotate 'line', 1630
    new $P4769, "Undef"
    .lex "$quant", $P4769
.annotate 'line', 1631
    new $P4770, "Undef"
    .lex "$past", $P4770
.annotate 'line', 1630
    find_lex $P4771, "$/"
    unless_null $P4771, vivify_2403
    $P4771 = root_new ['parrot';'Hash']
  vivify_2403:
    set $P4772, $P4771["quant"]
    unless_null $P4772, vivify_2404
    new $P4772, "Undef"
  vivify_2404:
    store_lex "$quant", $P4772
    find_lex $P4773, "$past"
    unless_null $P4773, vivify_2405
    new $P4773, "Undef"
  vivify_2405:
.annotate 'line', 1632
    find_lex $P4775, "$/"
    unless_null $P4775, vivify_2406
    $P4775 = root_new ['parrot';'Hash']
  vivify_2406:
    set $P4776, $P4775["named_param"]
    unless_null $P4776, vivify_2407
    new $P4776, "Undef"
  vivify_2407:
    if $P4776, if_4774
.annotate 'line', 1639
    find_lex $P4790, "$/"
    unless_null $P4790, vivify_2408
    $P4790 = root_new ['parrot';'Hash']
  vivify_2408:
    set $P4791, $P4790["param_var"]
    unless_null $P4791, vivify_2409
    new $P4791, "Undef"
  vivify_2409:
    $P4792 = $P4791."ast"()
    store_lex "$past", $P4792
.annotate 'line', 1640
    find_lex $P4794, "$quant"
    unless_null $P4794, vivify_2410
    new $P4794, "Undef"
  vivify_2410:
    set $S4795, $P4794
    iseq $I4796, $S4795, "*"
    if $I4796, if_4793
.annotate 'line', 1644
    find_lex $P4805, "$quant"
    unless_null $P4805, vivify_2411
    new $P4805, "Undef"
  vivify_2411:
    set $S4806, $P4805
    iseq $I4807, $S4806, "?"
    unless $I4807, if_4804_end
.annotate 'line', 1645
    find_lex $P4808, "$past"
    unless_null $P4808, vivify_2412
    new $P4808, "Undef"
  vivify_2412:
    find_lex $P4809, "$/"
    unless_null $P4809, vivify_2413
    $P4809 = root_new ['parrot';'Hash']
  vivify_2413:
    set $P4810, $P4809["param_var"]
    unless_null $P4810, vivify_2414
    $P4810 = root_new ['parrot';'Hash']
  vivify_2414:
    set $P4811, $P4810["sigil"]
    unless_null $P4811, vivify_2415
    new $P4811, "Undef"
  vivify_2415:
    $P4812 = "vivitype"($P4811)
    $P4808."viviself"($P4812)
  if_4804_end:
.annotate 'line', 1644
    goto if_4793_end
  if_4793:
.annotate 'line', 1641
    find_lex $P4797, "$past"
    unless_null $P4797, vivify_2416
    new $P4797, "Undef"
  vivify_2416:
    $P4797."slurpy"(1)
.annotate 'line', 1642
    find_lex $P4798, "$past"
    unless_null $P4798, vivify_2417
    new $P4798, "Undef"
  vivify_2417:
    find_lex $P4799, "$/"
    unless_null $P4799, vivify_2418
    $P4799 = root_new ['parrot';'Hash']
  vivify_2418:
    set $P4800, $P4799["param_var"]
    unless_null $P4800, vivify_2419
    $P4800 = root_new ['parrot';'Hash']
  vivify_2419:
    set $P4801, $P4800["sigil"]
    unless_null $P4801, vivify_2420
    new $P4801, "Undef"
  vivify_2420:
    set $S4802, $P4801
    iseq $I4803, $S4802, "%"
    $P4798."named"($I4803)
  if_4793_end:
.annotate 'line', 1638
    goto if_4774_end
  if_4774:
.annotate 'line', 1633
    find_lex $P4777, "$/"
    unless_null $P4777, vivify_2421
    $P4777 = root_new ['parrot';'Hash']
  vivify_2421:
    set $P4778, $P4777["named_param"]
    unless_null $P4778, vivify_2422
    new $P4778, "Undef"
  vivify_2422:
    $P4779 = $P4778."ast"()
    store_lex "$past", $P4779
.annotate 'line', 1634
    find_lex $P4781, "$quant"
    unless_null $P4781, vivify_2423
    new $P4781, "Undef"
  vivify_2423:
    set $S4782, $P4781
    isne $I4783, $S4782, "!"
    unless $I4783, if_4780_end
.annotate 'line', 1635
    find_lex $P4784, "$past"
    unless_null $P4784, vivify_2424
    new $P4784, "Undef"
  vivify_2424:
    find_lex $P4785, "$/"
    unless_null $P4785, vivify_2425
    $P4785 = root_new ['parrot';'Hash']
  vivify_2425:
    set $P4786, $P4785["named_param"]
    unless_null $P4786, vivify_2426
    $P4786 = root_new ['parrot';'Hash']
  vivify_2426:
    set $P4787, $P4786["param_var"]
    unless_null $P4787, vivify_2427
    $P4787 = root_new ['parrot';'Hash']
  vivify_2427:
    set $P4788, $P4787["sigil"]
    unless_null $P4788, vivify_2428
    new $P4788, "Undef"
  vivify_2428:
    $P4789 = "vivitype"($P4788)
    $P4784."viviself"($P4789)
  if_4780_end:
  if_4774_end:
.annotate 'line', 1648
    find_lex $P4814, "$/"
    unless_null $P4814, vivify_2429
    $P4814 = root_new ['parrot';'Hash']
  vivify_2429:
    set $P4815, $P4814["default_value"]
    unless_null $P4815, vivify_2430
    new $P4815, "Undef"
  vivify_2430:
    unless $P4815, if_4813_end
.annotate 'line', 1649
    find_lex $P4817, "$quant"
    unless_null $P4817, vivify_2431
    new $P4817, "Undef"
  vivify_2431:
    set $S4818, $P4817
    iseq $I4819, $S4818, "*"
    unless $I4819, if_4816_end
.annotate 'line', 1650
    find_lex $P4820, "$/"
    unless_null $P4820, vivify_2432
    new $P4820, "Undef"
  vivify_2432:
    $P4821 = $P4820."CURSOR"()
    $P4821."panic"("Can't put default on slurpy parameter")
  if_4816_end:
.annotate 'line', 1652
    find_lex $P4823, "$quant"
    unless_null $P4823, vivify_2433
    new $P4823, "Undef"
  vivify_2433:
    set $S4824, $P4823
    iseq $I4825, $S4824, "!"
    unless $I4825, if_4822_end
.annotate 'line', 1653
    find_lex $P4826, "$/"
    unless_null $P4826, vivify_2434
    new $P4826, "Undef"
  vivify_2434:
    $P4827 = $P4826."CURSOR"()
    $P4827."panic"("Can't put default on required parameter")
  if_4822_end:
.annotate 'line', 1655
    find_lex $P4828, "$past"
    unless_null $P4828, vivify_2435
    new $P4828, "Undef"
  vivify_2435:
    find_lex $P4829, "$/"
    unless_null $P4829, vivify_2436
    $P4829 = root_new ['parrot';'Hash']
  vivify_2436:
    set $P4830, $P4829["default_value"]
    unless_null $P4830, vivify_2437
    $P4830 = root_new ['parrot';'ResizablePMCArray']
  vivify_2437:
    set $P4831, $P4830[0]
    unless_null $P4831, vivify_2438
    $P4831 = root_new ['parrot';'Hash']
  vivify_2438:
    set $P4832, $P4831["EXPR"]
    unless_null $P4832, vivify_2439
    new $P4832, "Undef"
  vivify_2439:
    $P4833 = $P4832."ast"()
    $P4828."viviself"($P4833)
  if_4813_end:
.annotate 'line', 1657
    find_lex $P4835, "$past"
    unless_null $P4835, vivify_2440
    new $P4835, "Undef"
  vivify_2440:
    $P4836 = $P4835."viviself"()
    if $P4836, unless_4834_end
    find_lex $P4837, "$?PACKAGE"
    get_who $P4838, $P4837
    set $P4839, $P4838["@BLOCK"]
    unless_null $P4839, vivify_2441
    $P4839 = root_new ['parrot';'ResizablePMCArray']
  vivify_2441:
    set $P4840, $P4839[0]
    unless_null $P4840, vivify_2442
    new $P4840, "Undef"
  vivify_2442:
    find_lex $P4841, "$?PACKAGE"
    get_who $P4842, $P4841
    set $P4843, $P4842["@BLOCK"]
    unless_null $P4843, vivify_2443
    $P4843 = root_new ['parrot';'ResizablePMCArray']
  vivify_2443:
    set $P4844, $P4843[0]
    unless_null $P4844, vivify_2444
    new $P4844, "Undef"
  vivify_2444:
    $P4845 = $P4844."arity"()
    set $N4846, $P4845
    new $P4847, 'Float'
    set $P4847, $N4846
    add $P4848, $P4847, 1
    $P4840."arity"($P4848)
  unless_4834_end:
.annotate 'line', 1661
    find_lex $P4850, "$/"
    unless_null $P4850, vivify_2445
    $P4850 = root_new ['parrot';'Hash']
  vivify_2445:
    set $P4851, $P4850["typename"]
    unless_null $P4851, vivify_2446
    new $P4851, "Undef"
  vivify_2446:
    unless $P4851, if_4849_end
.annotate 'line', 1662
    find_lex $P4852, "$past"
    unless_null $P4852, vivify_2447
    new $P4852, "Undef"
  vivify_2447:
    find_lex $P4853, "$/"
    unless_null $P4853, vivify_2448
    $P4853 = root_new ['parrot';'Hash']
  vivify_2448:
    set $P4854, $P4853["typename"]
    unless_null $P4854, vivify_2449
    $P4854 = root_new ['parrot';'ResizablePMCArray']
  vivify_2449:
    set $P4855, $P4854[0]
    unless_null $P4855, vivify_2450
    new $P4855, "Undef"
  vivify_2450:
    $P4856 = $P4855."ast"()
    $P4852."multitype"($P4856)
  if_4849_end:
.annotate 'line', 1666
    find_lex $P4858, "$/"
    unless_null $P4858, vivify_2451
    $P4858 = root_new ['parrot';'Hash']
  vivify_2451:
    set $P4859, $P4858["definedness"]
    unless_null $P4859, vivify_2452
    new $P4859, "Undef"
  vivify_2452:
    unless $P4859, if_4857_end
.annotate 'line', 1667
    find_lex $P4860, "$/"
    unless_null $P4860, vivify_2453
    $P4860 = root_new ['parrot';'Hash']
  vivify_2453:
    set $P4861, $P4860["definedness"]
    unless_null $P4861, vivify_2454
    $P4861 = root_new ['parrot';'ResizablePMCArray']
  vivify_2454:
    set $P4862, $P4861[0]
    unless_null $P4862, vivify_2455
    new $P4862, "Undef"
  vivify_2455:
    set $S4863, $P4862
    new $P4864, 'String'
    set $P4864, $S4863
    find_lex $P4865, "$past"
    unless_null $P4865, vivify_2456
    $P4865 = root_new ['parrot';'Hash']
    store_lex "$past", $P4865
  vivify_2456:
    set $P4865["definedness"], $P4864
  if_4857_end:
.annotate 'line', 1670
    find_lex $P4866, "$/"
    find_lex $P4867, "$past"
    unless_null $P4867, vivify_2457
    new $P4867, "Undef"
  vivify_2457:
    $P4868 = $P4866."!make"($P4867)
.annotate 'line', 1629
    .return ($P4868)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("521_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4870
    .param pmc param_4871
.annotate 'line', 1673
    .lex "self", param_4870
    .lex "$/", param_4871
.annotate 'line', 1674
    new $P4872, "Undef"
    .lex "$name", $P4872
.annotate 'line', 1675
    new $P4873, "Undef"
    .lex "$past", $P4873
.annotate 'line', 1674
    find_lex $P4874, "$/"
    unless_null $P4874, vivify_2458
    new $P4874, "Undef"
  vivify_2458:
    set $S4875, $P4874
    new $P4876, 'String'
    set $P4876, $S4875
    store_lex "$name", $P4876
.annotate 'line', 1675
    get_hll_global $P4877, "GLOBAL"
    nqp_get_package_through_who $P4878, $P4877, "PAST"
    get_who $P4879, $P4878
    set $P4880, $P4879["Var"]
    find_lex $P4881, "$name"
    unless_null $P4881, vivify_2459
    new $P4881, "Undef"
  vivify_2459:
    find_lex $P4882, "$/"
    unless_null $P4882, vivify_2460
    new $P4882, "Undef"
  vivify_2460:
    $P4883 = $P4880."new"($P4881 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4882 :named("node"))
    store_lex "$past", $P4883
.annotate 'line', 1677
    find_lex $P4884, "$?PACKAGE"
    get_who $P4885, $P4884
    set $P4886, $P4885["@BLOCK"]
    unless_null $P4886, vivify_2461
    $P4886 = root_new ['parrot';'ResizablePMCArray']
  vivify_2461:
    set $P4887, $P4886[0]
    unless_null $P4887, vivify_2462
    new $P4887, "Undef"
  vivify_2462:
    find_lex $P4888, "$name"
    unless_null $P4888, vivify_2463
    new $P4888, "Undef"
  vivify_2463:
    $P4887."symbol"($P4888, "lexical" :named("scope"))
.annotate 'line', 1678
    find_lex $P4889, "$/"
    find_lex $P4890, "$past"
    unless_null $P4890, vivify_2464
    new $P4890, "Undef"
  vivify_2464:
    $P4891 = $P4889."!make"($P4890)
.annotate 'line', 1673
    .return ($P4891)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("522_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4893
    .param pmc param_4894
.annotate 'line', 1681
    .lex "self", param_4893
    .lex "$/", param_4894
.annotate 'line', 1682
    new $P4895, "Undef"
    .lex "$past", $P4895
    find_lex $P4896, "$/"
    unless_null $P4896, vivify_2465
    $P4896 = root_new ['parrot';'Hash']
  vivify_2465:
    set $P4897, $P4896["param_var"]
    unless_null $P4897, vivify_2466
    new $P4897, "Undef"
  vivify_2466:
    $P4898 = $P4897."ast"()
    store_lex "$past", $P4898
.annotate 'line', 1683
    find_lex $P4899, "$past"
    unless_null $P4899, vivify_2467
    new $P4899, "Undef"
  vivify_2467:
    find_lex $P4900, "$/"
    unless_null $P4900, vivify_2468
    $P4900 = root_new ['parrot';'Hash']
  vivify_2468:
    set $P4901, $P4900["param_var"]
    unless_null $P4901, vivify_2469
    $P4901 = root_new ['parrot';'Hash']
  vivify_2469:
    set $P4902, $P4901["name"]
    unless_null $P4902, vivify_2470
    new $P4902, "Undef"
  vivify_2470:
    set $S4903, $P4902
    $P4899."named"($S4903)
.annotate 'line', 1684
    find_lex $P4904, "$/"
    find_lex $P4905, "$past"
    unless_null $P4905, vivify_2471
    new $P4905, "Undef"
  vivify_2471:
    $P4906 = $P4904."!make"($P4905)
.annotate 'line', 1681
    .return ($P4906)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("523_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4908
    .param pmc param_4909
.annotate 'line', 1687
    .const 'Sub' $P4921 = "524_1304516047.681" 
    capture_lex $P4921
    .lex "self", param_4908
    .lex "$/", param_4909
.annotate 'line', 1691
    $P4910 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4910
.annotate 'line', 1692
    new $P4911, "Undef"
    .lex "$found", $P4911
.annotate 'line', 1691
    get_hll_global $P4912, "GLOBAL"
    nqp_get_package_through_who $P4913, $P4912, "HLL"
    get_who $P4914, $P4913
    set $P4915, $P4914["Compiler"]
    find_lex $P4916, "$/"
    unless_null $P4916, vivify_2472
    new $P4916, "Undef"
  vivify_2472:
    set $S4917, $P4916
    $P4918 = $P4915."parse_name"($S4917)
    store_lex "@name", $P4918
.annotate 'line', 1692
    new $P4919, "Integer"
    assign $P4919, 0
    store_lex "$found", $P4919
.annotate 'line', 1693
    .const 'Sub' $P4921 = "524_1304516047.681" 
    capture_lex $P4921
    $P4921()
.annotate 'line', 1698
    find_lex $P4942, "$found"
    unless_null $P4942, vivify_2478
    new $P4942, "Undef"
  vivify_2478:
    unless $P4942, unless_4941
    set $P4940, $P4942
    goto unless_4941_end
  unless_4941:
.annotate 'line', 1699
    find_lex $P4943, "$/"
    unless_null $P4943, vivify_2479
    new $P4943, "Undef"
  vivify_2479:
    $P4944 = $P4943."CURSOR"()
    new $P4945, "String"
    assign $P4945, "Use of undeclared type '"
    find_lex $P4946, "$/"
    unless_null $P4946, vivify_2480
    new $P4946, "Undef"
  vivify_2480:
    set $S4947, $P4946
    concat $P4948, $P4945, $S4947
    concat $P4949, $P4948, "'"
    $P4950 = $P4944."panic"($P4949)
.annotate 'line', 1698
    set $P4940, $P4950
  unless_4941_end:
.annotate 'line', 1687
    .return ($P4940)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4920"  :anon :subid("524_1304516047.681") :outer("523_1304516047.681")
.annotate 'line', 1693
    new $P4935, 'ExceptionHandler'
    set_label $P4935, control_4934
    $P4935."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P4935
.annotate 'line', 1694
    new $P4922, "Undef"
    .lex "$sym", $P4922
    find_lex $P4923, "@name"
    unless_null $P4923, vivify_2473
    $P4923 = root_new ['parrot';'ResizablePMCArray']
  vivify_2473:
    find_lex $P4924, "$/"
    unless_null $P4924, vivify_2474
    new $P4924, "Undef"
  vivify_2474:
    $P4925 = "find_sym"($P4923, $P4924)
    store_lex "$sym", $P4925
.annotate 'line', 1695
    find_dynamic_lex $P4926, "$/"
    find_dynamic_lex $P4929, "$*SC"
    unless_null $P4929, vivify_2475
    get_hll_global $P4927, "GLOBAL"
    get_who $P4928, $P4927
    set $P4929, $P4928["$SC"]
    unless_null $P4929, vivify_2476
    die "Contextual $*SC not found"
  vivify_2476:
  vivify_2475:
    find_lex $P4930, "$sym"
    unless_null $P4930, vivify_2477
    new $P4930, "Undef"
  vivify_2477:
    $P4931 = $P4929."get_object_sc_ref_past"($P4930)
    $P4926."!make"($P4931)
.annotate 'line', 1696
    new $P4932, "Integer"
    assign $P4932, 1
    store_lex "$found", $P4932
.annotate 'line', 1693
    pop_eh 
    goto skip_handler_4933
  control_4934:
    .local pmc exception 
    .get_results (exception) 
    new $P4938, 'Integer'
    set $P4938, 1
    set exception["handled"], $P4938
    set $I4939, exception["handled"]
    ne $I4939, 1, nothandled_4937
  handled_4936:
    .return (exception)
  nothandled_4937:
    rethrow exception
  skip_handler_4933:
    .return ($P4932)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("525_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4952
    .param pmc param_4953
.annotate 'line', 1703
    .lex "self", param_4952
    .lex "$/", param_4953
.annotate 'line', 1704
    find_lex $P4954, "$/"
    find_lex $P4955, "$/"
    unless_null $P4955, vivify_2481
    $P4955 = root_new ['parrot';'Hash']
  vivify_2481:
    set $P4956, $P4955["trait_mod"]
    unless_null $P4956, vivify_2482
    new $P4956, "Undef"
  vivify_2482:
    $P4957 = $P4956."ast"()
    $P4958 = $P4954."!make"($P4957)
.annotate 'line', 1703
    .return ($P4958)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("526_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_4960
    .param pmc param_4961
.annotate 'line', 1707
    .const 'Sub' $P4969 = "527_1304516047.681" 
    capture_lex $P4969
    .lex "self", param_4960
    .lex "$/", param_4961
.annotate 'line', 1708
    find_lex $P4964, "$/"
    unless_null $P4964, vivify_2483
    $P4964 = root_new ['parrot';'Hash']
  vivify_2483:
    set $P4965, $P4964["longname"]
    unless_null $P4965, vivify_2484
    new $P4965, "Undef"
  vivify_2484:
    set $S4966, $P4965
    iseq $I4967, $S4966, "parrot_vtable"
    if $I4967, if_4963
.annotate 'line', 1721
    find_lex $P5017, "$/"
    unless_null $P5017, vivify_2485
    $P5017 = root_new ['parrot';'Hash']
  vivify_2485:
    set $P5018, $P5017["longname"]
    unless_null $P5018, vivify_2486
    new $P5018, "Undef"
  vivify_2486:
    set $S5019, $P5018
    iseq $I5020, $S5019, "pirflags"
    if $I5020, if_5016
.annotate 'line', 1725
    find_lex $P5024, "$/"
    unless_null $P5024, vivify_2487
    new $P5024, "Undef"
  vivify_2487:
    $P5025 = $P5024."CURSOR"()
    new $P5026, 'String'
    set $P5026, "Trait '"
    find_lex $P5027, "$/"
    unless_null $P5027, vivify_2488
    $P5027 = root_new ['parrot';'Hash']
  vivify_2488:
    set $P5028, $P5027["longname"]
    unless_null $P5028, vivify_2489
    new $P5028, "Undef"
  vivify_2489:
    concat $P5029, $P5026, $P5028
    concat $P5030, $P5029, "' not implemented"
    $P5031 = $P5025."panic"($P5030)
.annotate 'line', 1724
    set $P5015, $P5031
.annotate 'line', 1721
    goto if_5016_end
  if_5016:
.annotate 'line', 1722
    find_lex $P5021, "$/"
    unless_null $P5021, vivify_2490
    new $P5021, "Undef"
  vivify_2490:
    $P5022 = $P5021."CURSOR"()
    $P5023 = $P5022."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1721
    set $P5015, $P5023
  if_5016_end:
    set $P4962, $P5015
.annotate 'line', 1708
    goto if_4963_end
  if_4963:
    .const 'Sub' $P4969 = "527_1304516047.681" 
    capture_lex $P4969
    $P5014 = $P4969()
    set $P4962, $P5014
  if_4963_end:
.annotate 'line', 1707
    .return ($P4962)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4968"  :anon :subid("527_1304516047.681") :outer("526_1304516047.681")
.annotate 'line', 1708
    .const 'Sub' $P5000 = "528_1304516047.681" 
    capture_lex $P5000
.annotate 'line', 1710
    new $P4970, "Undef"
    .lex "$cpast", $P4970
.annotate 'line', 1713
    new $P4971, "Undef"
    .lex "$name", $P4971
.annotate 'line', 1714
    new $P4972, "Undef"
    .lex "$package", $P4972
.annotate 'line', 1715
    new $P4973, "Undef"
    .lex "$is_dispatcher", $P4973
.annotate 'line', 1710
    find_lex $P4974, "$/"
    unless_null $P4974, vivify_2491
    $P4974 = root_new ['parrot';'Hash']
  vivify_2491:
    set $P4975, $P4974["circumfix"]
    unless_null $P4975, vivify_2492
    $P4975 = root_new ['parrot';'ResizablePMCArray']
  vivify_2492:
    set $P4976, $P4975[0]
    unless_null $P4976, vivify_2493
    new $P4976, "Undef"
  vivify_2493:
    $P4977 = $P4976."ast"()
    store_lex "$cpast", $P4977
.annotate 'line', 1712
    get_hll_global $P4979, "GLOBAL"
    nqp_get_package_through_who $P4980, $P4979, "PAST"
    get_who $P4981, $P4980
    set $P4982, $P4981["Val"]
    find_lex $P4983, "$cpast"
    unless_null $P4983, vivify_2494
    new $P4983, "Undef"
  vivify_2494:
    $P4984 = $P4982."ACCEPTS"($P4983)
    if $P4984, unless_4978_end
.annotate 'line', 1711
    find_lex $P4985, "$/"
    unless_null $P4985, vivify_2495
    new $P4985, "Undef"
  vivify_2495:
    $P4986 = $P4985."CURSOR"()
    $P4986."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4978_end:
.annotate 'line', 1713
    find_lex $P4987, "$cpast"
    unless_null $P4987, vivify_2496
    new $P4987, "Undef"
  vivify_2496:
    $P4988 = $P4987."value"()
    store_lex "$name", $P4988
.annotate 'line', 1714
    find_dynamic_lex $P4991, "$*PACKAGE"
    unless_null $P4991, vivify_2497
    get_hll_global $P4989, "GLOBAL"
    get_who $P4990, $P4989
    set $P4991, $P4990["$PACKAGE"]
    unless_null $P4991, vivify_2498
    die "Contextual $*PACKAGE not found"
  vivify_2498:
  vivify_2497:
    store_lex "$package", $P4991
.annotate 'line', 1715
    find_dynamic_lex $P4994, "$*SCOPE"
    unless_null $P4994, vivify_2499
    get_hll_global $P4992, "GLOBAL"
    get_who $P4993, $P4992
    set $P4994, $P4993["$SCOPE"]
    unless_null $P4994, vivify_2500
    die "Contextual $*SCOPE not found"
  vivify_2500:
  vivify_2499:
    set $S4995, $P4994
    iseq $I4996, $S4995, "proto"
    new $P4997, 'Integer'
    set $P4997, $I4996
    store_lex "$is_dispatcher", $P4997
.annotate 'line', 1716
    find_dynamic_lex $P4998, "$/"
    .const 'Sub' $P5000 = "528_1304516047.681" 
    newclosure $P5012, $P5000
    $P5013 = $P4998."!make"($P5012)
.annotate 'line', 1708
    .return ($P5013)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4999"  :anon :subid("528_1304516047.681") :outer("527_1304516047.681")
    .param pmc param_5001
.annotate 'line', 1716
    .lex "$match", param_5001
.annotate 'line', 1717
    find_dynamic_lex $P5004, "$*SC"
    unless_null $P5004, vivify_2501
    get_hll_global $P5002, "GLOBAL"
    get_who $P5003, $P5002
    set $P5004, $P5003["$SC"]
    unless_null $P5004, vivify_2502
    die "Contextual $*SC not found"
  vivify_2502:
  vivify_2501:
    find_lex $P5005, "$package"
    unless_null $P5005, vivify_2503
    new $P5005, "Undef"
  vivify_2503:
    find_lex $P5006, "$name"
    unless_null $P5006, vivify_2504
    new $P5006, "Undef"
  vivify_2504:
.annotate 'line', 1718
    find_lex $P5007, "$match"
    unless_null $P5007, vivify_2505
    new $P5007, "Undef"
  vivify_2505:
    $P5008 = $P5007."ast"()
    set $P5009, $P5008["block_past"]
    unless_null $P5009, vivify_2506
    new $P5009, "Undef"
  vivify_2506:
.annotate 'line', 1717
    find_lex $P5010, "$is_dispatcher"
    unless_null $P5010, vivify_2507
    new $P5010, "Undef"
  vivify_2507:
    $P5011 = $P5004."pkg_add_method"($P5005, "add_parrot_vtable_mapping", $P5006, $P5009, $P5010)
.annotate 'line', 1716
    .return ($P5011)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("529_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5035
    .param pmc param_5036
    .param pmc param_5037 :optional
    .param int has_param_5037 :opt_flag
.annotate 'line', 1729
    .const 'Sub' $P5164 = "532_1304516047.681" 
    capture_lex $P5164
    .const 'Sub' $P5126 = "531_1304516047.681" 
    capture_lex $P5126
    .const 'Sub' $P5106 = "530_1304516047.681" 
    capture_lex $P5106
    new $P5034, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5034, control_5033
    push_eh $P5034
    .lex "self", param_5035
    .lex "$/", param_5036
    if has_param_5037, optparam_2508
    new $P5038, "Undef"
    set param_5037, $P5038
  optparam_2508:
    .lex "$key", param_5037
.annotate 'line', 1730
    $P5039 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P5039
.annotate 'line', 1731
    new $P5040, "Undef"
    .lex "$name", $P5040
.annotate 'line', 1732
    new $P5041, "Undef"
    .lex "$past", $P5041
.annotate 'line', 1730
    get_hll_global $P5042, "GLOBAL"
    nqp_get_package_through_who $P5043, $P5042, "Regex"
    nqp_get_package_through_who $P5044, $P5043, "P6Regex"
    nqp_get_package_through_who $P5045, $P5044, "Actions"
    get_who $P5046, $P5045
    set $P5047, $P5046["@MODIFIERS"]
    unless_null $P5047, vivify_2509
    $P5047 = root_new ['parrot';'ResizablePMCArray']
  vivify_2509:
    store_lex "@MODIFIERS", $P5047
.annotate 'line', 1731
    find_lex $P5048, "$/"
    unless_null $P5048, vivify_2510
    $P5048 = root_new ['parrot';'Hash']
  vivify_2510:
    set $P5049, $P5048["deflongname"]
    unless_null $P5049, vivify_2511
    new $P5049, "Undef"
  vivify_2511:
    $P5050 = $P5049."ast"()
    set $S5051, $P5050
    new $P5052, 'String'
    set $P5052, $S5051
    store_lex "$name", $P5052
    find_lex $P5053, "$past"
    unless_null $P5053, vivify_2512
    new $P5053, "Undef"
  vivify_2512:
.annotate 'line', 1733
    find_lex $P5055, "$/"
    unless_null $P5055, vivify_2513
    $P5055 = root_new ['parrot';'Hash']
  vivify_2513:
    set $P5056, $P5055["proto"]
    unless_null $P5056, vivify_2514
    new $P5056, "Undef"
  vivify_2514:
    if $P5056, if_5054
.annotate 'line', 1763
    find_lex $P5122, "$key"
    unless_null $P5122, vivify_2515
    new $P5122, "Undef"
  vivify_2515:
    set $S5123, $P5122
    iseq $I5124, $S5123, "open"
    if $I5124, if_5121
.annotate 'line', 1773
    .const 'Sub' $P5164 = "532_1304516047.681" 
    capture_lex $P5164
    $P5164()
    goto if_5121_end
  if_5121:
.annotate 'line', 1763
    .const 'Sub' $P5126 = "531_1304516047.681" 
    capture_lex $P5126
    $P5126()
  if_5121_end:
    goto if_5054_end
  if_5054:
.annotate 'line', 1735
    get_hll_global $P5057, "GLOBAL"
    nqp_get_package_through_who $P5058, $P5057, "PAST"
    get_who $P5059, $P5058
    set $P5060, $P5059["Stmts"]
.annotate 'line', 1736
    get_hll_global $P5061, "GLOBAL"
    nqp_get_package_through_who $P5062, $P5061, "PAST"
    get_who $P5063, $P5062
    set $P5064, $P5063["Block"]
    find_lex $P5065, "$name"
    unless_null $P5065, vivify_2565
    new $P5065, "Undef"
  vivify_2565:
.annotate 'line', 1737
    get_hll_global $P5066, "GLOBAL"
    nqp_get_package_through_who $P5067, $P5066, "PAST"
    get_who $P5068, $P5067
    set $P5069, $P5068["Op"]
.annotate 'line', 1738
    get_hll_global $P5070, "GLOBAL"
    nqp_get_package_through_who $P5071, $P5070, "PAST"
    get_who $P5072, $P5071
    set $P5073, $P5072["Var"]
    $P5074 = $P5073."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5075, "$name"
    unless_null $P5075, vivify_2566
    new $P5075, "Undef"
  vivify_2566:
    $P5076 = $P5069."new"($P5074, $P5075, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1737
    find_lex $P5077, "$/"
    unless_null $P5077, vivify_2567
    new $P5077, "Undef"
  vivify_2567:
    $P5078 = $P5064."new"($P5076, $P5065 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5077 :named("node"))
.annotate 'line', 1747
    get_hll_global $P5079, "GLOBAL"
    nqp_get_package_through_who $P5080, $P5079, "PAST"
    get_who $P5081, $P5080
    set $P5082, $P5081["Block"]
    new $P5083, "String"
    assign $P5083, "!PREFIX__"
    find_lex $P5084, "$name"
    unless_null $P5084, vivify_2568
    new $P5084, "Undef"
  vivify_2568:
    concat $P5085, $P5083, $P5084
.annotate 'line', 1748
    get_hll_global $P5086, "GLOBAL"
    nqp_get_package_through_who $P5087, $P5086, "PAST"
    get_who $P5088, $P5087
    set $P5089, $P5088["Op"]
.annotate 'line', 1749
    get_hll_global $P5090, "GLOBAL"
    nqp_get_package_through_who $P5091, $P5090, "PAST"
    get_who $P5092, $P5091
    set $P5093, $P5092["Var"]
    $P5094 = $P5093."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P5095, "$name"
    unless_null $P5095, vivify_2569
    new $P5095, "Undef"
  vivify_2569:
    $P5096 = $P5089."new"($P5094, $P5095, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1748
    find_lex $P5097, "$/"
    unless_null $P5097, vivify_2570
    new $P5097, "Undef"
  vivify_2570:
    $P5098 = $P5082."new"($P5096, $P5085 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P5097 :named("node"))
.annotate 'line', 1747
    $P5099 = $P5060."new"($P5078, $P5098)
.annotate 'line', 1735
    store_lex "$past", $P5099
.annotate 'line', 1759
    find_lex $P5101, "$past"
    unless_null $P5101, vivify_2571
    new $P5101, "Undef"
  vivify_2571:
    $P5102 = $P5101."list"()
    defined $I5103, $P5102
    unless $I5103, for_undef_2572
    iter $P5100, $P5102
    new $P5119, 'ExceptionHandler'
    set_label $P5119, loop5118_handler
    $P5119."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5119
  loop5118_test:
    unless $P5100, loop5118_done
    shift $P5104, $P5100
  loop5118_redo:
    .const 'Sub' $P5106 = "530_1304516047.681" 
    capture_lex $P5106
    $P5106($P5104)
  loop5118_next:
    goto loop5118_test
  loop5118_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5120, exception, 'type'
    eq $P5120, .CONTROL_LOOP_NEXT, loop5118_next
    eq $P5120, .CONTROL_LOOP_REDO, loop5118_redo
  loop5118_done:
    pop_eh 
  for_undef_2572:
  if_5054_end:
.annotate 'line', 1804
    find_lex $P5257, "$/"
    find_lex $P5258, "$past"
    unless_null $P5258, vivify_2579
    new $P5258, "Undef"
  vivify_2579:
    $P5259 = $P5257."!make"($P5258)
.annotate 'line', 1729
    .return ($P5259)
  control_5033:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5260, exception, "payload"
    .return ($P5260)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5163"  :anon :subid("532_1304516047.681") :outer("529_1304516047.681")
.annotate 'line', 1773
    .const 'Sub' $P5196 = "533_1304516047.681" 
    capture_lex $P5196
.annotate 'line', 1774
    new $P5165, "Undef"
    .lex "$regex", $P5165
.annotate 'line', 1777
    new $P5166, "Undef"
    .lex "$prefix_meth", $P5166
.annotate 'line', 1775
    get_hll_global $P5167, "GLOBAL"
    nqp_get_package_through_who $P5168, $P5167, "Regex"
    nqp_get_package_through_who $P5169, $P5168, "P6Regex"
    nqp_get_package_through_who $P5170, $P5169, "Actions"
    get_who $P5171, $P5170
    set $P5172, $P5171["buildsub"]
    find_lex $P5173, "$/"
    unless_null $P5173, vivify_2516
    $P5173 = root_new ['parrot';'Hash']
  vivify_2516:
    set $P5174, $P5173["p6regex"]
    unless_null $P5174, vivify_2517
    new $P5174, "Undef"
  vivify_2517:
    $P5175 = $P5174."ast"()
    find_lex $P5176, "$?PACKAGE"
    get_who $P5177, $P5176
    set $P5178, $P5177["@BLOCK"]
    unless_null $P5178, vivify_2518
    $P5178 = root_new ['parrot';'ResizablePMCArray']
  vivify_2518:
    $P5179 = $P5178."shift"()
    $P5180 = $P5172($P5175, $P5179)
    store_lex "$regex", $P5180
.annotate 'line', 1776
    find_lex $P5181, "$regex"
    unless_null $P5181, vivify_2519
    new $P5181, "Undef"
  vivify_2519:
    find_lex $P5182, "$name"
    unless_null $P5182, vivify_2520
    new $P5182, "Undef"
  vivify_2520:
    $P5181."name"($P5182)
    find_lex $P5183, "$prefix_meth"
    unless_null $P5183, vivify_2521
    new $P5183, "Undef"
  vivify_2521:
.annotate 'line', 1779
    find_dynamic_lex $P5189, "$*PKGDECL"
    unless_null $P5189, vivify_2522
    get_hll_global $P5187, "GLOBAL"
    get_who $P5188, $P5187
    set $P5189, $P5188["$PKGDECL"]
    unless_null $P5189, vivify_2523
    die "Contextual $*PKGDECL not found"
  vivify_2523:
  vivify_2522:
    if $P5189, if_5186
    set $P5185, $P5189
    goto if_5186_end
  if_5186:
    find_dynamic_lex $P5192, "$*PACKAGE"
    unless_null $P5192, vivify_2524
    get_hll_global $P5190, "GLOBAL"
    get_who $P5191, $P5190
    set $P5192, $P5191["$PACKAGE"]
    unless_null $P5192, vivify_2525
    die "Contextual $*PACKAGE not found"
  vivify_2525:
  vivify_2524:
    get_how $P5193, $P5192
    can $I5194, $P5193, "add_method"
    new $P5185, 'Integer'
    set $P5185, $I5194
  if_5186_end:
    unless $P5185, if_5184_end
    .const 'Sub' $P5196 = "533_1304516047.681" 
    capture_lex $P5196
    $P5196()
  if_5184_end:
.annotate 'line', 1794
    get_hll_global $P5234, "GLOBAL"
    nqp_get_package_through_who $P5235, $P5234, "PAST"
    get_who $P5236, $P5235
    set $P5237, $P5236["Op"]
.annotate 'line', 1796
    new $P5238, "ResizablePMCArray"
    push $P5238, "Regex"
    push $P5238, "Method"
    find_lex $P5239, "$/"
    unless_null $P5239, vivify_2542
    new $P5239, "Undef"
  vivify_2542:
    $P5240 = "lexical_package_lookup"($P5238, $P5239)
    find_lex $P5241, "$regex"
    unless_null $P5241, vivify_2543
    new $P5241, "Undef"
  vivify_2543:
    $P5242 = $P5237."new"($P5240, $P5241, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1794
    store_lex "$past", $P5242
.annotate 'line', 1799
    find_lex $P5245, "$prefix_meth"
    unless_null $P5245, vivify_2544
    new $P5245, "Undef"
  vivify_2544:
    if $P5245, if_5244
    find_lex $P5253, "$regex"
    unless_null $P5253, vivify_2545
    new $P5253, "Undef"
  vivify_2545:
    set $P5243, $P5253
    goto if_5244_end
  if_5244:
.annotate 'line', 1800
    get_hll_global $P5246, "GLOBAL"
    nqp_get_package_through_who $P5247, $P5246, "PAST"
    get_who $P5248, $P5247
    set $P5249, $P5248["Stmts"]
    find_lex $P5250, "$regex"
    unless_null $P5250, vivify_2546
    new $P5250, "Undef"
  vivify_2546:
    find_lex $P5251, "$prefix_meth"
    unless_null $P5251, vivify_2547
    new $P5251, "Undef"
  vivify_2547:
    $P5252 = $P5249."new"($P5250, $P5251)
    set $P5243, $P5252
  if_5244_end:
.annotate 'line', 1799
    find_lex $P5254, "$past"
    unless_null $P5254, vivify_2548
    $P5254 = root_new ['parrot';'Hash']
    store_lex "$past", $P5254
  vivify_2548:
    set $P5254["sink"], $P5243
.annotate 'line', 1802
    find_lex $P5255, "@MODIFIERS"
    unless_null $P5255, vivify_2549
    $P5255 = root_new ['parrot';'ResizablePMCArray']
  vivify_2549:
    $P5256 = $P5255."shift"()
.annotate 'line', 1773
    .return ($P5256)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5195"  :anon :subid("533_1304516047.681") :outer("532_1304516047.681")
.annotate 'line', 1784
    $P5197 = root_new ['parrot';'ResizablePMCArray']
    .lex "@prefixes", $P5197
.annotate 'line', 1781
    find_dynamic_lex $P5200, "$*SC"
    unless_null $P5200, vivify_2526
    get_hll_global $P5198, "GLOBAL"
    get_who $P5199, $P5198
    set $P5200, $P5199["$SC"]
    unless_null $P5200, vivify_2527
    die "Contextual $*SC not found"
  vivify_2527:
  vivify_2526:
    find_dynamic_lex $P5203, "$*PACKAGE"
    unless_null $P5203, vivify_2528
    get_hll_global $P5201, "GLOBAL"
    get_who $P5202, $P5201
    set $P5203, $P5202["$PACKAGE"]
    unless_null $P5203, vivify_2529
    die "Contextual $*PACKAGE not found"
  vivify_2529:
  vivify_2528:
    find_lex $P5204, "$name"
    unless_null $P5204, vivify_2530
    new $P5204, "Undef"
  vivify_2530:
    find_lex $P5205, "$regex"
    unless_null $P5205, vivify_2531
    new $P5205, "Undef"
  vivify_2531:
    $P5200."pkg_add_method"($P5203, "add_method", $P5204, $P5205, 0)
.annotate 'line', 1784
    find_lex $P5206, "$/"
    unless_null $P5206, vivify_2532
    $P5206 = root_new ['parrot';'Hash']
  vivify_2532:
    set $P5207, $P5206["p6regex"]
    unless_null $P5207, vivify_2533
    new $P5207, "Undef"
  vivify_2533:
    $P5208 = $P5207."ast"()
    $P5209 = $P5208."prefix_list"()
    store_lex "@prefixes", $P5209
.annotate 'line', 1785
    get_hll_global $P5210, "GLOBAL"
    nqp_get_package_through_who $P5211, $P5210, "PAST"
    get_who $P5212, $P5211
    set $P5213, $P5212["Block"]
.annotate 'line', 1786
    new $P5214, "String"
    assign $P5214, "!PREFIX__"
    find_lex $P5215, "$name"
    unless_null $P5215, vivify_2534
    new $P5215, "Undef"
  vivify_2534:
    concat $P5216, $P5214, $P5215
.annotate 'line', 1787
    get_hll_global $P5217, "GLOBAL"
    nqp_get_package_through_who $P5218, $P5217, "PAST"
    get_who $P5219, $P5218
    set $P5220, $P5219["Op"]
    find_lex $P5221, "@prefixes"
    unless_null $P5221, vivify_2535
    $P5221 = root_new ['parrot';'ResizablePMCArray']
  vivify_2535:
    $P5222 = $P5220."new"($P5221 :flat, "list" :named("pasttype"))
    $P5223 = $P5213."new"($P5222, $P5216 :named("name"), "method" :named("blocktype"))
.annotate 'line', 1785
    store_lex "$prefix_meth", $P5223
.annotate 'line', 1789
    find_dynamic_lex $P5226, "$*SC"
    unless_null $P5226, vivify_2536
    get_hll_global $P5224, "GLOBAL"
    get_who $P5225, $P5224
    set $P5226, $P5225["$SC"]
    unless_null $P5226, vivify_2537
    die "Contextual $*SC not found"
  vivify_2537:
  vivify_2536:
    find_dynamic_lex $P5229, "$*PACKAGE"
    unless_null $P5229, vivify_2538
    get_hll_global $P5227, "GLOBAL"
    get_who $P5228, $P5227
    set $P5229, $P5228["$PACKAGE"]
    unless_null $P5229, vivify_2539
    die "Contextual $*PACKAGE not found"
  vivify_2539:
  vivify_2538:
    find_lex $P5230, "$prefix_meth"
    unless_null $P5230, vivify_2540
    new $P5230, "Undef"
  vivify_2540:
    $P5231 = $P5230."name"()
    find_lex $P5232, "$prefix_meth"
    unless_null $P5232, vivify_2541
    new $P5232, "Undef"
  vivify_2541:
    $P5233 = $P5226."pkg_add_method"($P5229, "add_method", $P5231, $P5232, 0)
.annotate 'line', 1779
    .return ($P5233)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5125"  :anon :subid("531_1304516047.681") :outer("529_1304516047.681")
.annotate 'line', 1764
    $P5127 = root_new ['parrot';'Hash']
    .lex "%h", $P5127
.annotate 'line', 1763
    find_lex $P5128, "%h"
    unless_null $P5128, vivify_2550
    $P5128 = root_new ['parrot';'Hash']
  vivify_2550:
.annotate 'line', 1765
    find_lex $P5130, "$/"
    unless_null $P5130, vivify_2551
    $P5130 = root_new ['parrot';'Hash']
  vivify_2551:
    set $P5131, $P5130["sym"]
    unless_null $P5131, vivify_2552
    new $P5131, "Undef"
  vivify_2552:
    set $S5132, $P5131
    iseq $I5133, $S5132, "token"
    unless $I5133, if_5129_end
    new $P5134, "Integer"
    assign $P5134, 1
    find_lex $P5135, "%h"
    unless_null $P5135, vivify_2553
    $P5135 = root_new ['parrot';'Hash']
    store_lex "%h", $P5135
  vivify_2553:
    set $P5135["r"], $P5134
  if_5129_end:
.annotate 'line', 1766
    find_lex $P5137, "$/"
    unless_null $P5137, vivify_2554
    $P5137 = root_new ['parrot';'Hash']
  vivify_2554:
    set $P5138, $P5137["sym"]
    unless_null $P5138, vivify_2555
    new $P5138, "Undef"
  vivify_2555:
    set $S5139, $P5138
    iseq $I5140, $S5139, "rule"
    unless $I5140, if_5136_end
    new $P5141, "Integer"
    assign $P5141, 1
    find_lex $P5142, "%h"
    unless_null $P5142, vivify_2556
    $P5142 = root_new ['parrot';'Hash']
    store_lex "%h", $P5142
  vivify_2556:
    set $P5142["r"], $P5141
    new $P5143, "Integer"
    assign $P5143, 1
    find_lex $P5144, "%h"
    unless_null $P5144, vivify_2557
    $P5144 = root_new ['parrot';'Hash']
    store_lex "%h", $P5144
  vivify_2557:
    set $P5144["s"], $P5143
  if_5136_end:
.annotate 'line', 1767
    find_lex $P5145, "@MODIFIERS"
    unless_null $P5145, vivify_2558
    $P5145 = root_new ['parrot';'ResizablePMCArray']
  vivify_2558:
    find_lex $P5146, "%h"
    unless_null $P5146, vivify_2559
    $P5146 = root_new ['parrot';'Hash']
  vivify_2559:
    $P5145."unshift"($P5146)
.annotate 'line', 1768
    find_lex $P5147, "$name"
    unless_null $P5147, vivify_2560
    new $P5147, "Undef"
  vivify_2560:
    get_hll_global $P5148, "GLOBAL"
    nqp_get_package_through_who $P5149, $P5148, "Regex"
    nqp_get_package_through_who $P5150, $P5149, "P6Regex"
    nqp_get_package_through_who $P5151, $P5150, "Actions"
    get_who $P5152, $P5151
    set $P5152["$REGEXNAME"], $P5147
.annotate 'line', 1769
    find_lex $P5153, "$?PACKAGE"
    get_who $P5154, $P5153
    set $P5155, $P5154["@BLOCK"]
    unless_null $P5155, vivify_2561
    $P5155 = root_new ['parrot';'ResizablePMCArray']
  vivify_2561:
    set $P5156, $P5155[0]
    unless_null $P5156, vivify_2562
    new $P5156, "Undef"
  vivify_2562:
    $P5156."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1770
    find_lex $P5157, "$?PACKAGE"
    get_who $P5158, $P5157
    set $P5159, $P5158["@BLOCK"]
    unless_null $P5159, vivify_2563
    $P5159 = root_new ['parrot';'ResizablePMCArray']
  vivify_2563:
    set $P5160, $P5159[0]
    unless_null $P5160, vivify_2564
    new $P5160, "Undef"
  vivify_2564:
    $P5160."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1771
    new $P5161, "Exception"
    set $P5161['type'], .CONTROL_RETURN
    new $P5162, "Integer"
    assign $P5162, 0
    setattribute $P5161, 'payload', $P5162
    throw $P5161
.annotate 'line', 1763
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5105"  :anon :subid("530_1304516047.681") :outer("529_1304516047.681")
    .param pmc param_5107
.annotate 'line', 1759
    .lex "$_", param_5107
.annotate 'line', 1760
    find_dynamic_lex $P5110, "$*SC"
    unless_null $P5110, vivify_2573
    get_hll_global $P5108, "GLOBAL"
    get_who $P5109, $P5108
    set $P5110, $P5109["$SC"]
    unless_null $P5110, vivify_2574
    die "Contextual $*SC not found"
  vivify_2574:
  vivify_2573:
    find_dynamic_lex $P5113, "$*PACKAGE"
    unless_null $P5113, vivify_2575
    get_hll_global $P5111, "GLOBAL"
    get_who $P5112, $P5111
    set $P5113, $P5112["$PACKAGE"]
    unless_null $P5113, vivify_2576
    die "Contextual $*PACKAGE not found"
  vivify_2576:
  vivify_2575:
    find_lex $P5114, "$_"
    unless_null $P5114, vivify_2577
    new $P5114, "Undef"
  vivify_2577:
    $P5115 = $P5114."name"()
    find_lex $P5116, "$_"
    unless_null $P5116, vivify_2578
    new $P5116, "Undef"
  vivify_2578:
    $P5117 = $P5110."pkg_add_method"($P5113, "add_method", $P5115, $P5116, 0)
.annotate 'line', 1759
    .return ($P5117)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("534_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5262
    .param pmc param_5263
.annotate 'line', 1808
    .lex "self", param_5262
    .lex "$/", param_5263
.annotate 'line', 1809
    new $P5264, "Undef"
    .lex "$past", $P5264
    find_lex $P5267, "$/"
    unless_null $P5267, vivify_2580
    $P5267 = root_new ['parrot';'Hash']
  vivify_2580:
    set $P5268, $P5267["args"]
    unless_null $P5268, vivify_2581
    new $P5268, "Undef"
  vivify_2581:
    if $P5268, if_5266
    get_hll_global $P5273, "GLOBAL"
    nqp_get_package_through_who $P5274, $P5273, "PAST"
    get_who $P5275, $P5274
    set $P5276, $P5275["Op"]
    find_lex $P5277, "$/"
    unless_null $P5277, vivify_2582
    new $P5277, "Undef"
  vivify_2582:
    $P5278 = $P5276."new"($P5277 :named("node"))
    set $P5265, $P5278
    goto if_5266_end
  if_5266:
    find_lex $P5269, "$/"
    unless_null $P5269, vivify_2583
    $P5269 = root_new ['parrot';'Hash']
  vivify_2583:
    set $P5270, $P5269["args"]
    unless_null $P5270, vivify_2584
    $P5270 = root_new ['parrot';'ResizablePMCArray']
  vivify_2584:
    set $P5271, $P5270[0]
    unless_null $P5271, vivify_2585
    new $P5271, "Undef"
  vivify_2585:
    $P5272 = $P5271."ast"()
    set $P5265, $P5272
  if_5266_end:
    store_lex "$past", $P5265
.annotate 'line', 1810
    find_lex $P5280, "$/"
    unless_null $P5280, vivify_2586
    $P5280 = root_new ['parrot';'Hash']
  vivify_2586:
    set $P5281, $P5280["quote"]
    unless_null $P5281, vivify_2587
    new $P5281, "Undef"
  vivify_2587:
    if $P5281, if_5279
.annotate 'line', 1814
    find_lex $P5288, "$/"
    unless_null $P5288, vivify_2588
    $P5288 = root_new ['parrot';'Hash']
  vivify_2588:
    set $P5289, $P5288["longname"]
    unless_null $P5289, vivify_2589
    new $P5289, "Undef"
  vivify_2589:
    set $S5290, $P5289
    iseq $I5291, $S5290, "HOW"
    if $I5291, if_5287
.annotate 'line', 1817
    find_lex $P5294, "$/"
    unless_null $P5294, vivify_2590
    $P5294 = root_new ['parrot';'Hash']
  vivify_2590:
    set $P5295, $P5294["longname"]
    unless_null $P5295, vivify_2591
    new $P5295, "Undef"
  vivify_2591:
    set $S5296, $P5295
    iseq $I5297, $S5296, "WHAT"
    if $I5297, if_5293
.annotate 'line', 1820
    find_lex $P5300, "$/"
    unless_null $P5300, vivify_2592
    $P5300 = root_new ['parrot';'Hash']
  vivify_2592:
    set $P5301, $P5300["longname"]
    unless_null $P5301, vivify_2593
    new $P5301, "Undef"
  vivify_2593:
    set $S5302, $P5301
    iseq $I5303, $S5302, "WHO"
    if $I5303, if_5299
.annotate 'line', 1824
    find_lex $P5305, "$past"
    unless_null $P5305, vivify_2594
    new $P5305, "Undef"
  vivify_2594:
    find_lex $P5306, "$/"
    unless_null $P5306, vivify_2595
    $P5306 = root_new ['parrot';'Hash']
  vivify_2595:
    set $P5307, $P5306["longname"]
    unless_null $P5307, vivify_2596
    new $P5307, "Undef"
  vivify_2596:
    set $S5308, $P5307
    $P5305."name"($S5308)
.annotate 'line', 1825
    find_lex $P5309, "$past"
    unless_null $P5309, vivify_2597
    new $P5309, "Undef"
  vivify_2597:
    $P5309."pasttype"("callmethod")
.annotate 'line', 1823
    goto if_5299_end
  if_5299:
.annotate 'line', 1821
    find_lex $P5304, "$past"
    unless_null $P5304, vivify_2598
    new $P5304, "Undef"
  vivify_2598:
    $P5304."pirop"("get_who PP")
  if_5299_end:
.annotate 'line', 1820
    goto if_5293_end
  if_5293:
.annotate 'line', 1818
    find_lex $P5298, "$past"
    unless_null $P5298, vivify_2599
    new $P5298, "Undef"
  vivify_2599:
    $P5298."pirop"("get_what PP")
  if_5293_end:
.annotate 'line', 1817
    goto if_5287_end
  if_5287:
.annotate 'line', 1815
    find_lex $P5292, "$past"
    unless_null $P5292, vivify_2600
    new $P5292, "Undef"
  vivify_2600:
    $P5292."pirop"("get_how PP")
  if_5287_end:
.annotate 'line', 1814
    goto if_5279_end
  if_5279:
.annotate 'line', 1811
    find_lex $P5282, "$past"
    unless_null $P5282, vivify_2601
    new $P5282, "Undef"
  vivify_2601:
    find_lex $P5283, "$/"
    unless_null $P5283, vivify_2602
    $P5283 = root_new ['parrot';'Hash']
  vivify_2602:
    set $P5284, $P5283["quote"]
    unless_null $P5284, vivify_2603
    new $P5284, "Undef"
  vivify_2603:
    $P5285 = $P5284."ast"()
    $P5282."name"($P5285)
.annotate 'line', 1812
    find_lex $P5286, "$past"
    unless_null $P5286, vivify_2604
    new $P5286, "Undef"
  vivify_2604:
    $P5286."pasttype"("callmethod")
  if_5279_end:
.annotate 'line', 1827
    find_lex $P5310, "$/"
    find_lex $P5311, "$past"
    unless_null $P5311, vivify_2605
    new $P5311, "Undef"
  vivify_2605:
    $P5312 = $P5310."!make"($P5311)
.annotate 'line', 1808
    .return ($P5312)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("535_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5314
    .param pmc param_5315
.annotate 'line', 1832
    .lex "self", param_5314
    .lex "$/", param_5315
.annotate 'line', 1833
    find_lex $P5316, "$/"
    get_hll_global $P5317, "GLOBAL"
    nqp_get_package_through_who $P5318, $P5317, "PAST"
    get_who $P5319, $P5318
    set $P5320, $P5319["Var"]
    $P5321 = $P5320."new"("self" :named("name"))
    $P5322 = $P5316."!make"($P5321)
.annotate 'line', 1832
    .return ($P5322)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("536_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5324
    .param pmc param_5325
.annotate 'line', 1836
    .lex "self", param_5324
    .lex "$/", param_5325
.annotate 'line', 1837
    new $P5326, "Undef"
    .lex "$past", $P5326
    find_lex $P5327, "$/"
    unless_null $P5327, vivify_2606
    $P5327 = root_new ['parrot';'Hash']
  vivify_2606:
    set $P5328, $P5327["args"]
    unless_null $P5328, vivify_2607
    new $P5328, "Undef"
  vivify_2607:
    $P5329 = $P5328."ast"()
    store_lex "$past", $P5329
.annotate 'line', 1838
    find_lex $P5330, "$past"
    unless_null $P5330, vivify_2608
    new $P5330, "Undef"
  vivify_2608:
    find_lex $P5331, "$/"
    unless_null $P5331, vivify_2609
    $P5331 = root_new ['parrot';'Hash']
  vivify_2609:
    set $P5332, $P5331["deflongname"]
    unless_null $P5332, vivify_2610
    new $P5332, "Undef"
  vivify_2610:
    set $S5333, $P5332
    $P5330."name"($S5333)
.annotate 'line', 1839
    find_lex $P5334, "$/"
    find_lex $P5335, "$past"
    unless_null $P5335, vivify_2611
    new $P5335, "Undef"
  vivify_2611:
    $P5336 = $P5334."!make"($P5335)
.annotate 'line', 1836
    .return ($P5336)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("537_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5338
    .param pmc param_5339
.annotate 'line', 1842
    .const 'Sub' $P5357 = "538_1304516047.681" 
    capture_lex $P5357
    .lex "self", param_5338
    .lex "$/", param_5339
.annotate 'line', 1844
    new $P5340, "Undef"
    .lex "$var", $P5340
.annotate 'line', 1854
    new $P5341, "Undef"
    .lex "$past", $P5341
.annotate 'line', 1842
    find_lex $P5342, "$var"
    unless_null $P5342, vivify_2612
    new $P5342, "Undef"
  vivify_2612:
.annotate 'line', 1845
    find_lex $P5344, "$/"
    unless_null $P5344, vivify_2613
    $P5344 = root_new ['parrot';'Hash']
  vivify_2613:
    set $P5345, $P5344["name"]
    unless_null $P5345, vivify_2614
    new $P5345, "Undef"
  vivify_2614:
    set $S5346, $P5345
    $P5347 = "is_lexical"($S5346)
    if $P5347, if_5343
.annotate 'line', 1848
    .const 'Sub' $P5357 = "538_1304516047.681" 
    capture_lex $P5357
    $P5357()
    goto if_5343_end
  if_5343:
.annotate 'line', 1846
    get_hll_global $P5348, "GLOBAL"
    nqp_get_package_through_who $P5349, $P5348, "PAST"
    get_who $P5350, $P5349
    set $P5351, $P5350["Var"]
    find_lex $P5352, "$/"
    unless_null $P5352, vivify_2620
    $P5352 = root_new ['parrot';'Hash']
  vivify_2620:
    set $P5353, $P5352["name"]
    unless_null $P5353, vivify_2621
    new $P5353, "Undef"
  vivify_2621:
    set $S5354, $P5353
    $P5355 = $P5351."new"($S5354 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P5355
  if_5343_end:
.annotate 'line', 1854
    find_lex $P5366, "$var"
    unless_null $P5366, vivify_2622
    new $P5366, "Undef"
  vivify_2622:
    store_lex "$past", $P5366
.annotate 'line', 1855
    find_lex $P5368, "$/"
    unless_null $P5368, vivify_2623
    $P5368 = root_new ['parrot';'Hash']
  vivify_2623:
    set $P5369, $P5368["args"]
    unless_null $P5369, vivify_2624
    new $P5369, "Undef"
  vivify_2624:
    unless $P5369, if_5367_end
.annotate 'line', 1856
    find_lex $P5370, "$/"
    unless_null $P5370, vivify_2625
    $P5370 = root_new ['parrot';'Hash']
  vivify_2625:
    set $P5371, $P5370["args"]
    unless_null $P5371, vivify_2626
    $P5371 = root_new ['parrot';'ResizablePMCArray']
  vivify_2626:
    set $P5372, $P5371[0]
    unless_null $P5372, vivify_2627
    new $P5372, "Undef"
  vivify_2627:
    $P5373 = $P5372."ast"()
    store_lex "$past", $P5373
.annotate 'line', 1857
    find_lex $P5374, "$past"
    unless_null $P5374, vivify_2628
    new $P5374, "Undef"
  vivify_2628:
    find_lex $P5375, "$var"
    unless_null $P5375, vivify_2629
    new $P5375, "Undef"
  vivify_2629:
    $P5374."unshift"($P5375)
  if_5367_end:
.annotate 'line', 1859
    find_lex $P5376, "$/"
    find_lex $P5377, "$past"
    unless_null $P5377, vivify_2630
    new $P5377, "Undef"
  vivify_2630:
    $P5378 = $P5376."!make"($P5377)
.annotate 'line', 1842
    .return ($P5378)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5356"  :anon :subid("538_1304516047.681") :outer("537_1304516047.681")
.annotate 'line', 1849
    $P5358 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P5358
    find_lex $P5359, "$/"
    unless_null $P5359, vivify_2615
    $P5359 = root_new ['parrot';'Hash']
  vivify_2615:
    set $P5360, $P5359["name"]
    unless_null $P5360, vivify_2616
    $P5360 = root_new ['parrot';'Hash']
  vivify_2616:
    set $P5361, $P5360["identifier"]
    unless_null $P5361, vivify_2617
    new $P5361, "Undef"
  vivify_2617:
    clone $P5362, $P5361
    store_lex "@ns", $P5362
.annotate 'line', 1850
    find_lex $P5363, "@ns"
    unless_null $P5363, vivify_2618
    $P5363 = root_new ['parrot';'ResizablePMCArray']
  vivify_2618:
    find_lex $P5364, "$/"
    unless_null $P5364, vivify_2619
    new $P5364, "Undef"
  vivify_2619:
    $P5365 = "lexical_package_lookup"($P5363, $P5364)
    store_lex "$var", $P5365
.annotate 'line', 1848
    .return ($P5365)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("539_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5380
    .param pmc param_5381
.annotate 'line', 1862
    .lex "self", param_5380
    .lex "$/", param_5381
.annotate 'line', 1863
    new $P5382, "Undef"
    .lex "$past", $P5382
.annotate 'line', 1864
    new $P5383, "Undef"
    .lex "$pirop", $P5383
.annotate 'line', 1863
    find_lex $P5386, "$/"
    unless_null $P5386, vivify_2631
    $P5386 = root_new ['parrot';'Hash']
  vivify_2631:
    set $P5387, $P5386["args"]
    unless_null $P5387, vivify_2632
    new $P5387, "Undef"
  vivify_2632:
    if $P5387, if_5385
    get_hll_global $P5392, "GLOBAL"
    nqp_get_package_through_who $P5393, $P5392, "PAST"
    get_who $P5394, $P5393
    set $P5395, $P5394["Op"]
    find_lex $P5396, "$/"
    unless_null $P5396, vivify_2633
    new $P5396, "Undef"
  vivify_2633:
    $P5397 = $P5395."new"($P5396 :named("node"))
    set $P5384, $P5397
    goto if_5385_end
  if_5385:
    find_lex $P5388, "$/"
    unless_null $P5388, vivify_2634
    $P5388 = root_new ['parrot';'Hash']
  vivify_2634:
    set $P5389, $P5388["args"]
    unless_null $P5389, vivify_2635
    $P5389 = root_new ['parrot';'ResizablePMCArray']
  vivify_2635:
    set $P5390, $P5389[0]
    unless_null $P5390, vivify_2636
    new $P5390, "Undef"
  vivify_2636:
    $P5391 = $P5390."ast"()
    set $P5384, $P5391
  if_5385_end:
    store_lex "$past", $P5384
.annotate 'line', 1864
    find_lex $P5398, "$/"
    unless_null $P5398, vivify_2637
    $P5398 = root_new ['parrot';'Hash']
  vivify_2637:
    set $P5399, $P5398["op"]
    unless_null $P5399, vivify_2638
    new $P5399, "Undef"
  vivify_2638:
    set $S5400, $P5399
    new $P5401, 'String'
    set $P5401, $S5400
    store_lex "$pirop", $P5401
.annotate 'line', 1865
    find_lex $P5402, "$pirop"
    unless_null $P5402, vivify_2639
    new $P5402, "Undef"
  vivify_2639:
    set $S5403, $P5402
    split $P5404, "__", $S5403
    join $S5405, " ", $P5404
    new $P5406, 'String'
    set $P5406, $S5405
    store_lex "$pirop", $P5406
.annotate 'line', 1866
    find_lex $P5407, "$past"
    unless_null $P5407, vivify_2640
    new $P5407, "Undef"
  vivify_2640:
    find_lex $P5408, "$pirop"
    unless_null $P5408, vivify_2641
    new $P5408, "Undef"
  vivify_2641:
    $P5407."pirop"($P5408)
.annotate 'line', 1867
    find_lex $P5409, "$past"
    unless_null $P5409, vivify_2642
    new $P5409, "Undef"
  vivify_2642:
    $P5409."pasttype"("pirop")
.annotate 'line', 1868
    find_lex $P5410, "$/"
    find_lex $P5411, "$past"
    unless_null $P5411, vivify_2643
    new $P5411, "Undef"
  vivify_2643:
    $P5412 = $P5410."!make"($P5411)
.annotate 'line', 1862
    .return ($P5412)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("540_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5414
    .param pmc param_5415
.annotate 'line', 1871
    .lex "self", param_5414
    .lex "$/", param_5415
.annotate 'line', 1872
    find_lex $P5416, "$/"
    get_hll_global $P5417, "GLOBAL"
    nqp_get_package_through_who $P5418, $P5417, "PAST"
    get_who $P5419, $P5418
    set $P5420, $P5419["Op"]
    $P5421 = $P5420."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P5422 = $P5416."!make"($P5421)
.annotate 'line', 1871
    .return ($P5422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("541_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5424
    .param pmc param_5425
.annotate 'line', 1877
    .lex "self", param_5424
    .lex "$/", param_5425
    find_lex $P5426, "$/"
    find_lex $P5427, "$/"
    unless_null $P5427, vivify_2644
    $P5427 = root_new ['parrot';'Hash']
  vivify_2644:
    set $P5428, $P5427["arglist"]
    unless_null $P5428, vivify_2645
    new $P5428, "Undef"
  vivify_2645:
    $P5429 = $P5428."ast"()
    $P5430 = $P5426."!make"($P5429)
    .return ($P5430)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("542_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5432
    .param pmc param_5433
.annotate 'line', 1879
    .const 'Sub' $P5447 = "543_1304516047.681" 
    capture_lex $P5447
    .lex "self", param_5432
    .lex "$/", param_5433
.annotate 'line', 1880
    new $P5434, "Undef"
    .lex "$past", $P5434
.annotate 'line', 1888
    new $P5435, "Undef"
    .lex "$i", $P5435
.annotate 'line', 1889
    new $P5436, "Undef"
    .lex "$n", $P5436
.annotate 'line', 1880
    get_hll_global $P5437, "GLOBAL"
    nqp_get_package_through_who $P5438, $P5437, "PAST"
    get_who $P5439, $P5438
    set $P5440, $P5439["Op"]
    find_lex $P5441, "$/"
    unless_null $P5441, vivify_2646
    new $P5441, "Undef"
  vivify_2646:
    $P5442 = $P5440."new"("call" :named("pasttype"), $P5441 :named("node"))
    store_lex "$past", $P5442
.annotate 'line', 1881
    find_lex $P5444, "$/"
    unless_null $P5444, vivify_2647
    $P5444 = root_new ['parrot';'Hash']
  vivify_2647:
    set $P5445, $P5444["EXPR"]
    unless_null $P5445, vivify_2648
    new $P5445, "Undef"
  vivify_2648:
    unless $P5445, if_5443_end
    .const 'Sub' $P5447 = "543_1304516047.681" 
    capture_lex $P5447
    $P5447()
  if_5443_end:
.annotate 'line', 1888
    new $P5479, "Integer"
    assign $P5479, 0
    store_lex "$i", $P5479
.annotate 'line', 1889
    find_lex $P5480, "$past"
    unless_null $P5480, vivify_2659
    new $P5480, "Undef"
  vivify_2659:
    $P5481 = $P5480."list"()
    set $N5482, $P5481
    new $P5483, 'Float'
    set $P5483, $N5482
    store_lex "$n", $P5483
.annotate 'line', 1890
    new $P5534, 'ExceptionHandler'
    set_label $P5534, loop5533_handler
    $P5534."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5534
  loop5533_test:
    find_lex $P5484, "$i"
    unless_null $P5484, vivify_2660
    new $P5484, "Undef"
  vivify_2660:
    set $N5485, $P5484
    find_lex $P5486, "$n"
    unless_null $P5486, vivify_2661
    new $P5486, "Undef"
  vivify_2661:
    set $N5487, $P5486
    islt $I5488, $N5485, $N5487
    unless $I5488, loop5533_done
  loop5533_redo:
.annotate 'line', 1891
    find_lex $P5490, "$i"
    unless_null $P5490, vivify_2662
    new $P5490, "Undef"
  vivify_2662:
    set $I5491, $P5490
    find_lex $P5492, "$past"
    unless_null $P5492, vivify_2663
    $P5492 = root_new ['parrot';'ResizablePMCArray']
  vivify_2663:
    set $P5493, $P5492[$I5491]
    unless_null $P5493, vivify_2664
    new $P5493, "Undef"
  vivify_2664:
    $S5494 = $P5493."name"()
    iseq $I5495, $S5494, "&prefix:<|>"
    unless $I5495, if_5489_end
.annotate 'line', 1892
    find_lex $P5496, "$i"
    unless_null $P5496, vivify_2665
    new $P5496, "Undef"
  vivify_2665:
    set $I5497, $P5496
    find_lex $P5498, "$past"
    unless_null $P5498, vivify_2666
    $P5498 = root_new ['parrot';'ResizablePMCArray']
  vivify_2666:
    set $P5499, $P5498[$I5497]
    unless_null $P5499, vivify_2667
    $P5499 = root_new ['parrot';'ResizablePMCArray']
  vivify_2667:
    set $P5500, $P5499[0]
    unless_null $P5500, vivify_2668
    new $P5500, "Undef"
  vivify_2668:
    find_lex $P5501, "$i"
    unless_null $P5501, vivify_2669
    new $P5501, "Undef"
  vivify_2669:
    set $I5502, $P5501
    find_lex $P5503, "$past"
    unless_null $P5503, vivify_2670
    $P5503 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5503
  vivify_2670:
    set $P5503[$I5502], $P5500
.annotate 'line', 1893
    find_lex $P5504, "$i"
    unless_null $P5504, vivify_2671
    new $P5504, "Undef"
  vivify_2671:
    set $I5505, $P5504
    find_lex $P5506, "$past"
    unless_null $P5506, vivify_2672
    $P5506 = root_new ['parrot';'ResizablePMCArray']
  vivify_2672:
    set $P5507, $P5506[$I5505]
    unless_null $P5507, vivify_2673
    new $P5507, "Undef"
  vivify_2673:
    $P5507."flat"(1)
.annotate 'line', 1894
    find_lex $P5511, "$i"
    unless_null $P5511, vivify_2674
    new $P5511, "Undef"
  vivify_2674:
    set $I5512, $P5511
    find_lex $P5513, "$past"
    unless_null $P5513, vivify_2675
    $P5513 = root_new ['parrot';'ResizablePMCArray']
  vivify_2675:
    set $P5514, $P5513[$I5512]
    unless_null $P5514, vivify_2676
    new $P5514, "Undef"
  vivify_2676:
    get_hll_global $P5515, "GLOBAL"
    nqp_get_package_through_who $P5516, $P5515, "PAST"
    get_who $P5517, $P5516
    set $P5518, $P5517["Val"]
    $P5519 = $P5514."isa"($P5518)
    if $P5519, if_5510
    set $P5509, $P5519
    goto if_5510_end
  if_5510:
.annotate 'line', 1895
    find_lex $P5520, "$i"
    unless_null $P5520, vivify_2677
    new $P5520, "Undef"
  vivify_2677:
    set $I5521, $P5520
    find_lex $P5522, "$past"
    unless_null $P5522, vivify_2678
    $P5522 = root_new ['parrot';'ResizablePMCArray']
  vivify_2678:
    set $P5523, $P5522[$I5521]
    unless_null $P5523, vivify_2679
    new $P5523, "Undef"
  vivify_2679:
    $S5524 = $P5523."name"()
    substr $S5525, $S5524, 0, 1
    iseq $I5526, $S5525, "%"
    new $P5509, 'Integer'
    set $P5509, $I5526
  if_5510_end:
    unless $P5509, if_5508_end
.annotate 'line', 1896
    find_lex $P5527, "$i"
    unless_null $P5527, vivify_2680
    new $P5527, "Undef"
  vivify_2680:
    set $I5528, $P5527
    find_lex $P5529, "$past"
    unless_null $P5529, vivify_2681
    $P5529 = root_new ['parrot';'ResizablePMCArray']
  vivify_2681:
    set $P5530, $P5529[$I5528]
    unless_null $P5530, vivify_2682
    new $P5530, "Undef"
  vivify_2682:
    $P5530."named"(1)
  if_5508_end:
  if_5489_end:
.annotate 'line', 1891
    find_lex $P5531, "$i"
    unless_null $P5531, vivify_2683
    new $P5531, "Undef"
  vivify_2683:
    clone $P5532, $P5531
    inc $P5531
  loop5533_next:
.annotate 'line', 1890
    goto loop5533_test
  loop5533_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5535, exception, 'type'
    eq $P5535, .CONTROL_LOOP_NEXT, loop5533_next
    eq $P5535, .CONTROL_LOOP_REDO, loop5533_redo
  loop5533_done:
    pop_eh 
.annotate 'line', 1901
    find_lex $P5536, "$/"
    find_lex $P5537, "$past"
    unless_null $P5537, vivify_2684
    new $P5537, "Undef"
  vivify_2684:
    $P5538 = $P5536."!make"($P5537)
.annotate 'line', 1879
    .return ($P5538)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block5446"  :anon :subid("543_1304516047.681") :outer("542_1304516047.681")
.annotate 'line', 1881
    .const 'Sub' $P5468 = "544_1304516047.681" 
    capture_lex $P5468
.annotate 'line', 1882
    new $P5448, "Undef"
    .lex "$expr", $P5448
    find_lex $P5449, "$/"
    unless_null $P5449, vivify_2649
    $P5449 = root_new ['parrot';'Hash']
  vivify_2649:
    set $P5450, $P5449["EXPR"]
    unless_null $P5450, vivify_2650
    new $P5450, "Undef"
  vivify_2650:
    $P5451 = $P5450."ast"()
    store_lex "$expr", $P5451
.annotate 'line', 1883
    find_lex $P5456, "$expr"
    unless_null $P5456, vivify_2651
    new $P5456, "Undef"
  vivify_2651:
    $S5457 = $P5456."name"()
    iseq $I5458, $S5457, "&infix:<,>"
    if $I5458, if_5455
    new $P5454, 'Integer'
    set $P5454, $I5458
    goto if_5455_end
  if_5455:
    find_lex $P5459, "$expr"
    unless_null $P5459, vivify_2652
    new $P5459, "Undef"
  vivify_2652:
    $P5460 = $P5459."named"()
    isfalse $I5461, $P5460
    new $P5454, 'Integer'
    set $P5454, $I5461
  if_5455_end:
    if $P5454, if_5453
.annotate 'line', 1886
    find_lex $P5476, "$past"
    unless_null $P5476, vivify_2653
    new $P5476, "Undef"
  vivify_2653:
    find_lex $P5477, "$expr"
    unless_null $P5477, vivify_2654
    new $P5477, "Undef"
  vivify_2654:
    $P5478 = $P5476."push"($P5477)
    set $P5452, $P5478
.annotate 'line', 1883
    goto if_5453_end
  if_5453:
.annotate 'line', 1884
    find_lex $P5463, "$expr"
    unless_null $P5463, vivify_2655
    new $P5463, "Undef"
  vivify_2655:
    $P5464 = $P5463."list"()
    defined $I5465, $P5464
    unless $I5465, for_undef_2656
    iter $P5462, $P5464
    new $P5474, 'ExceptionHandler'
    set_label $P5474, loop5473_handler
    $P5474."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5474
  loop5473_test:
    unless $P5462, loop5473_done
    shift $P5466, $P5462
  loop5473_redo:
    .const 'Sub' $P5468 = "544_1304516047.681" 
    capture_lex $P5468
    $P5468($P5466)
  loop5473_next:
    goto loop5473_test
  loop5473_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5475, exception, 'type'
    eq $P5475, .CONTROL_LOOP_NEXT, loop5473_next
    eq $P5475, .CONTROL_LOOP_REDO, loop5473_redo
  loop5473_done:
    pop_eh 
  for_undef_2656:
.annotate 'line', 1883
    set $P5452, $P5462
  if_5453_end:
.annotate 'line', 1881
    .return ($P5452)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5467"  :anon :subid("544_1304516047.681") :outer("543_1304516047.681")
    .param pmc param_5469
.annotate 'line', 1884
    .lex "$_", param_5469
    find_lex $P5470, "$past"
    unless_null $P5470, vivify_2657
    new $P5470, "Undef"
  vivify_2657:
    find_lex $P5471, "$_"
    unless_null $P5471, vivify_2658
    new $P5471, "Undef"
  vivify_2658:
    $P5472 = $P5470."push"($P5471)
    .return ($P5472)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("545_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5540
    .param pmc param_5541
.annotate 'line', 1904
    .lex "self", param_5540
    .lex "$/", param_5541
    find_lex $P5542, "$/"
    find_lex $P5543, "$/"
    unless_null $P5543, vivify_2685
    $P5543 = root_new ['parrot';'Hash']
  vivify_2685:
    set $P5544, $P5543["multi_declarator"]
    unless_null $P5544, vivify_2686
    new $P5544, "Undef"
  vivify_2686:
    $P5545 = $P5544."ast"()
    $P5546 = $P5542."!make"($P5545)
    .return ($P5546)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("546_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5548
    .param pmc param_5549
.annotate 'line', 1906
    .lex "self", param_5548
    .lex "$/", param_5549
    find_lex $P5550, "$/"
    find_lex $P5551, "$/"
    unless_null $P5551, vivify_2687
    $P5551 = root_new ['parrot';'Hash']
  vivify_2687:
    set $P5552, $P5551["value"]
    unless_null $P5552, vivify_2688
    new $P5552, "Undef"
  vivify_2688:
    $P5553 = $P5552."ast"()
    $P5554 = $P5550."!make"($P5553)
    .return ($P5554)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("547_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5556
    .param pmc param_5557
.annotate 'line', 1908
    .lex "self", param_5556
    .lex "$/", param_5557
.annotate 'line', 1909
    find_lex $P5558, "$/"
.annotate 'line', 1910
    find_lex $P5561, "$/"
    unless_null $P5561, vivify_2689
    $P5561 = root_new ['parrot';'Hash']
  vivify_2689:
    set $P5562, $P5561["EXPR"]
    unless_null $P5562, vivify_2690
    new $P5562, "Undef"
  vivify_2690:
    if $P5562, if_5560
.annotate 'line', 1911
    get_hll_global $P5567, "GLOBAL"
    nqp_get_package_through_who $P5568, $P5567, "PAST"
    get_who $P5569, $P5568
    set $P5570, $P5569["Op"]
    find_lex $P5571, "$/"
    unless_null $P5571, vivify_2691
    new $P5571, "Undef"
  vivify_2691:
    $P5572 = $P5570."new"("list" :named("pasttype"), $P5571 :named("node"))
    set $P5559, $P5572
.annotate 'line', 1910
    goto if_5560_end
  if_5560:
    find_lex $P5563, "$/"
    unless_null $P5563, vivify_2692
    $P5563 = root_new ['parrot';'Hash']
  vivify_2692:
    set $P5564, $P5563["EXPR"]
    unless_null $P5564, vivify_2693
    $P5564 = root_new ['parrot';'ResizablePMCArray']
  vivify_2693:
    set $P5565, $P5564[0]
    unless_null $P5565, vivify_2694
    new $P5565, "Undef"
  vivify_2694:
    $P5566 = $P5565."ast"()
    set $P5559, $P5566
  if_5560_end:
    $P5573 = $P5558."!make"($P5559)
.annotate 'line', 1908
    .return ($P5573)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("548_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5575
    .param pmc param_5576
.annotate 'line', 1914
    .lex "self", param_5575
    .lex "$/", param_5576
.annotate 'line', 1915
    new $P5577, "Undef"
    .lex "$past", $P5577
.annotate 'line', 1914
    find_lex $P5578, "$past"
    unless_null $P5578, vivify_2695
    new $P5578, "Undef"
  vivify_2695:
.annotate 'line', 1916
    find_lex $P5580, "$/"
    unless_null $P5580, vivify_2696
    $P5580 = root_new ['parrot';'Hash']
  vivify_2696:
    set $P5581, $P5580["EXPR"]
    unless_null $P5581, vivify_2697
    new $P5581, "Undef"
  vivify_2697:
    if $P5581, if_5579
.annotate 'line', 1923
    get_hll_global $P5596, "GLOBAL"
    nqp_get_package_through_who $P5597, $P5596, "PAST"
    get_who $P5598, $P5597
    set $P5599, $P5598["Op"]
    $P5600 = $P5599."new"("list" :named("pasttype"))
    store_lex "$past", $P5600
.annotate 'line', 1922
    goto if_5579_end
  if_5579:
.annotate 'line', 1917
    find_lex $P5582, "$/"
    unless_null $P5582, vivify_2698
    $P5582 = root_new ['parrot';'Hash']
  vivify_2698:
    set $P5583, $P5582["EXPR"]
    unless_null $P5583, vivify_2699
    $P5583 = root_new ['parrot';'ResizablePMCArray']
  vivify_2699:
    set $P5584, $P5583[0]
    unless_null $P5584, vivify_2700
    new $P5584, "Undef"
  vivify_2700:
    $P5585 = $P5584."ast"()
    store_lex "$past", $P5585
.annotate 'line', 1918
    find_lex $P5587, "$past"
    unless_null $P5587, vivify_2701
    new $P5587, "Undef"
  vivify_2701:
    $S5588 = $P5587."name"()
    isne $I5589, $S5588, "&infix:<,>"
    unless $I5589, if_5586_end
.annotate 'line', 1919
    get_hll_global $P5590, "GLOBAL"
    nqp_get_package_through_who $P5591, $P5590, "PAST"
    get_who $P5592, $P5591
    set $P5593, $P5592["Op"]
    find_lex $P5594, "$past"
    unless_null $P5594, vivify_2702
    new $P5594, "Undef"
  vivify_2702:
    $P5595 = $P5593."new"($P5594, "list" :named("pasttype"))
    store_lex "$past", $P5595
  if_5586_end:
  if_5579_end:
.annotate 'line', 1925
    find_lex $P5601, "$past"
    unless_null $P5601, vivify_2703
    new $P5601, "Undef"
  vivify_2703:
    $P5601."name"("&circumfix:<[ ]>")
.annotate 'line', 1926
    find_lex $P5602, "$/"
    find_lex $P5603, "$past"
    unless_null $P5603, vivify_2704
    new $P5603, "Undef"
  vivify_2704:
    $P5604 = $P5602."!make"($P5603)
.annotate 'line', 1914
    .return ($P5604)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("549_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5606
    .param pmc param_5607
.annotate 'line', 1929
    .lex "self", param_5606
    .lex "$/", param_5607
    find_lex $P5608, "$/"
    find_lex $P5609, "$/"
    unless_null $P5609, vivify_2705
    $P5609 = root_new ['parrot';'Hash']
  vivify_2705:
    set $P5610, $P5609["quote_EXPR"]
    unless_null $P5610, vivify_2706
    new $P5610, "Undef"
  vivify_2706:
    $P5611 = $P5610."ast"()
    $P5612 = $P5608."!make"($P5611)
    .return ($P5612)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("550_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5614
    .param pmc param_5615
.annotate 'line', 1930
    .lex "self", param_5614
    .lex "$/", param_5615
    find_lex $P5616, "$/"
    find_lex $P5617, "$/"
    unless_null $P5617, vivify_2707
    $P5617 = root_new ['parrot';'Hash']
  vivify_2707:
    set $P5618, $P5617["quote_EXPR"]
    unless_null $P5618, vivify_2708
    new $P5618, "Undef"
  vivify_2708:
    $P5619 = $P5618."ast"()
    $P5620 = $P5616."!make"($P5619)
    .return ($P5620)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("551_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5622
    .param pmc param_5623
.annotate 'line', 1932
    .const 'Sub' $P5634 = "552_1304516047.681" 
    capture_lex $P5634
    .lex "self", param_5622
    .lex "$/", param_5623
.annotate 'line', 1933
    find_lex $P5626, "$/"
    unless_null $P5626, vivify_2709
    $P5626 = root_new ['parrot';'Hash']
  vivify_2709:
    set $P5627, $P5626["pblock"]
    unless_null $P5627, vivify_2710
    $P5627 = root_new ['parrot';'Hash']
  vivify_2710:
    set $P5628, $P5627["blockoid"]
    unless_null $P5628, vivify_2711
    $P5628 = root_new ['parrot';'Hash']
  vivify_2711:
    set $P5629, $P5628["statementlist"]
    unless_null $P5629, vivify_2712
    $P5629 = root_new ['parrot';'Hash']
  vivify_2712:
    set $P5630, $P5629["statement"]
    unless_null $P5630, vivify_2713
    new $P5630, "Undef"
  vivify_2713:
    set $N5631, $P5630
    isgt $I5632, $N5631, 0.0
    if $I5632, if_5625
.annotate 'line', 1938
    find_lex $P5647, "$/"
    unless_null $P5647, vivify_2714
    $P5647 = root_new ['parrot';'Hash']
  vivify_2714:
    set $P5648, $P5647["pblock"]
    unless_null $P5648, vivify_2715
    $P5648 = root_new ['parrot';'Hash']
  vivify_2715:
    set $P5649, $P5648["blockoid"]
    unless_null $P5649, vivify_2716
    $P5649 = root_new ['parrot';'Hash']
  vivify_2716:
    set $P5650, $P5649["you_are_here"]
    unless_null $P5650, vivify_2717
    new $P5650, "Undef"
  vivify_2717:
    if $P5650, if_5646
.annotate 'line', 1942
    find_lex $P5656, "$/"
    $P5657 = "vivitype"("%")
    $P5658 = $P5656."!make"($P5657)
.annotate 'line', 1941
    set $P5645, $P5658
.annotate 'line', 1938
    goto if_5646_end
  if_5646:
.annotate 'line', 1939
    find_lex $P5651, "$/"
    find_lex $P5652, "$/"
    unless_null $P5652, vivify_2718
    $P5652 = root_new ['parrot';'Hash']
  vivify_2718:
    set $P5653, $P5652["pblock"]
    unless_null $P5653, vivify_2719
    new $P5653, "Undef"
  vivify_2719:
    $P5654 = $P5653."ast"()
    $P5655 = $P5651."!make"($P5654)
.annotate 'line', 1938
    set $P5645, $P5655
  if_5646_end:
    set $P5624, $P5645
.annotate 'line', 1933
    goto if_5625_end
  if_5625:
    .const 'Sub' $P5634 = "552_1304516047.681" 
    capture_lex $P5634
    $P5644 = $P5634()
    set $P5624, $P5644
  if_5625_end:
.annotate 'line', 1932
    .return ($P5624)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5633"  :anon :subid("552_1304516047.681") :outer("551_1304516047.681")
.annotate 'line', 1934
    new $P5635, "Undef"
    .lex "$past", $P5635
    find_lex $P5636, "$/"
    unless_null $P5636, vivify_2720
    $P5636 = root_new ['parrot';'Hash']
  vivify_2720:
    set $P5637, $P5636["pblock"]
    unless_null $P5637, vivify_2721
    new $P5637, "Undef"
  vivify_2721:
    $P5638 = $P5637."ast"()
    store_lex "$past", $P5638
.annotate 'line', 1935
    new $P5639, "Integer"
    assign $P5639, 1
    find_lex $P5640, "$past"
    unless_null $P5640, vivify_2722
    $P5640 = root_new ['parrot';'Hash']
    store_lex "$past", $P5640
  vivify_2722:
    set $P5640["bareblock"], $P5639
.annotate 'line', 1936
    find_dynamic_lex $P5641, "$/"
    find_lex $P5642, "$past"
    unless_null $P5642, vivify_2723
    new $P5642, "Undef"
  vivify_2723:
    $P5643 = $P5641."!make"($P5642)
.annotate 'line', 1933
    .return ($P5643)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("553_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5660
    .param pmc param_5661
.annotate 'line', 1946
    .lex "self", param_5660
    .lex "$/", param_5661
.annotate 'line', 1947
    new $P5662, "Undef"
    .lex "$name", $P5662
    find_lex $P5665, "$/"
    unless_null $P5665, vivify_2724
    $P5665 = root_new ['parrot';'Hash']
  vivify_2724:
    set $P5666, $P5665["sigil"]
    unless_null $P5666, vivify_2725
    new $P5666, "Undef"
  vivify_2725:
    set $S5667, $P5666
    iseq $I5668, $S5667, "@"
    if $I5668, if_5664
.annotate 'line', 1948
    find_lex $P5672, "$/"
    unless_null $P5672, vivify_2726
    $P5672 = root_new ['parrot';'Hash']
  vivify_2726:
    set $P5673, $P5672["sigil"]
    unless_null $P5673, vivify_2727
    new $P5673, "Undef"
  vivify_2727:
    set $S5674, $P5673
    iseq $I5675, $S5674, "%"
    if $I5675, if_5671
    new $P5677, "String"
    assign $P5677, "item"
    set $P5670, $P5677
    goto if_5671_end
  if_5671:
    new $P5676, "String"
    assign $P5676, "hash"
    set $P5670, $P5676
  if_5671_end:
    set $P5663, $P5670
.annotate 'line', 1947
    goto if_5664_end
  if_5664:
    new $P5669, "String"
    assign $P5669, "list"
    set $P5663, $P5669
  if_5664_end:
    store_lex "$name", $P5663
.annotate 'line', 1950
    find_lex $P5678, "$/"
    get_hll_global $P5679, "GLOBAL"
    nqp_get_package_through_who $P5680, $P5679, "PAST"
    get_who $P5681, $P5680
    set $P5682, $P5681["Op"]
    find_lex $P5683, "$name"
    unless_null $P5683, vivify_2728
    new $P5683, "Undef"
  vivify_2728:
    find_lex $P5684, "$/"
    unless_null $P5684, vivify_2729
    $P5684 = root_new ['parrot';'Hash']
  vivify_2729:
    set $P5685, $P5684["semilist"]
    unless_null $P5685, vivify_2730
    new $P5685, "Undef"
  vivify_2730:
    $P5686 = $P5685."ast"()
    $P5687 = $P5682."new"($P5686, "callmethod" :named("pasttype"), $P5683 :named("name"))
    $P5688 = $P5678."!make"($P5687)
.annotate 'line', 1946
    .return ($P5688)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("554_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5690
    .param pmc param_5691
.annotate 'line', 1953
    .lex "self", param_5690
    .lex "$/", param_5691
    find_lex $P5692, "$/"
    find_lex $P5693, "$/"
    unless_null $P5693, vivify_2731
    $P5693 = root_new ['parrot';'Hash']
  vivify_2731:
    set $P5694, $P5693["statement"]
    unless_null $P5694, vivify_2732
    new $P5694, "Undef"
  vivify_2732:
    $P5695 = $P5694."ast"()
    $P5696 = $P5692."!make"($P5695)
    .return ($P5696)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("555_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5698
    .param pmc param_5699
.annotate 'line', 1955
    .lex "self", param_5698
    .lex "$/", param_5699
.annotate 'line', 1956
    find_lex $P5700, "$/"
    get_hll_global $P5701, "GLOBAL"
    nqp_get_package_through_who $P5702, $P5701, "PAST"
    get_who $P5703, $P5702
    set $P5704, $P5703["Var"]
    find_lex $P5705, "$/"
    unless_null $P5705, vivify_2733
    $P5705 = root_new ['parrot';'Hash']
  vivify_2733:
    set $P5706, $P5705["EXPR"]
    unless_null $P5706, vivify_2734
    new $P5706, "Undef"
  vivify_2734:
    $P5707 = $P5706."ast"()
.annotate 'line', 1958
    $P5708 = "vivitype"("@")
    $P5709 = $P5704."new"($P5707, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5708 :named("vivibase"))
.annotate 'line', 1956
    $P5710 = $P5700."!make"($P5709)
.annotate 'line', 1955
    .return ($P5710)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("556_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5712
    .param pmc param_5713
.annotate 'line', 1961
    .lex "self", param_5712
    .lex "$/", param_5713
.annotate 'line', 1962
    find_lex $P5714, "$/"
    get_hll_global $P5715, "GLOBAL"
    nqp_get_package_through_who $P5716, $P5715, "PAST"
    get_who $P5717, $P5716
    set $P5718, $P5717["Var"]
    find_lex $P5719, "$/"
    unless_null $P5719, vivify_2735
    $P5719 = root_new ['parrot';'Hash']
  vivify_2735:
    set $P5720, $P5719["EXPR"]
    unless_null $P5720, vivify_2736
    new $P5720, "Undef"
  vivify_2736:
    $P5721 = $P5720."ast"()
.annotate 'line', 1964
    $P5722 = "vivitype"("%")
    $P5723 = $P5718."new"($P5721, "keyed" :named("scope"), "Undef" :named("viviself"), $P5722 :named("vivibase"))
.annotate 'line', 1962
    $P5724 = $P5714."!make"($P5723)
.annotate 'line', 1961
    .return ($P5724)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("557_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5726
    .param pmc param_5727
.annotate 'line', 1967
    .lex "self", param_5726
    .lex "$/", param_5727
.annotate 'line', 1968
    find_lex $P5728, "$/"
    get_hll_global $P5729, "GLOBAL"
    nqp_get_package_through_who $P5730, $P5729, "PAST"
    get_who $P5731, $P5730
    set $P5732, $P5731["Var"]
    find_lex $P5733, "$/"
    unless_null $P5733, vivify_2737
    $P5733 = root_new ['parrot';'Hash']
  vivify_2737:
    set $P5734, $P5733["quote_EXPR"]
    unless_null $P5734, vivify_2738
    new $P5734, "Undef"
  vivify_2738:
    $P5735 = $P5734."ast"()
.annotate 'line', 1970
    $P5736 = "vivitype"("%")
    $P5737 = $P5732."new"($P5735, "keyed" :named("scope"), "Undef" :named("viviself"), $P5736 :named("vivibase"))
.annotate 'line', 1968
    $P5738 = $P5728."!make"($P5737)
.annotate 'line', 1967
    .return ($P5738)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("558_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5740
    .param pmc param_5741
.annotate 'line', 1973
    .lex "self", param_5740
    .lex "$/", param_5741
.annotate 'line', 1974
    find_lex $P5742, "$/"
    find_lex $P5743, "$/"
    unless_null $P5743, vivify_2739
    $P5743 = root_new ['parrot';'Hash']
  vivify_2739:
    set $P5744, $P5743["arglist"]
    unless_null $P5744, vivify_2740
    new $P5744, "Undef"
  vivify_2740:
    $P5745 = $P5744."ast"()
    $P5746 = $P5742."!make"($P5745)
.annotate 'line', 1973
    .return ($P5746)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("559_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5748
    .param pmc param_5749
.annotate 'line', 1977
    .lex "self", param_5748
    .lex "$/", param_5749
.annotate 'line', 1978
    find_lex $P5750, "$/"
    find_lex $P5753, "$/"
    unless_null $P5753, vivify_2741
    $P5753 = root_new ['parrot';'Hash']
  vivify_2741:
    set $P5754, $P5753["quote"]
    unless_null $P5754, vivify_2742
    new $P5754, "Undef"
  vivify_2742:
    if $P5754, if_5752
    find_lex $P5758, "$/"
    unless_null $P5758, vivify_2743
    $P5758 = root_new ['parrot';'Hash']
  vivify_2743:
    set $P5759, $P5758["number"]
    unless_null $P5759, vivify_2744
    new $P5759, "Undef"
  vivify_2744:
    $P5760 = $P5759."ast"()
    set $P5751, $P5760
    goto if_5752_end
  if_5752:
    find_lex $P5755, "$/"
    unless_null $P5755, vivify_2745
    $P5755 = root_new ['parrot';'Hash']
  vivify_2745:
    set $P5756, $P5755["quote"]
    unless_null $P5756, vivify_2746
    new $P5756, "Undef"
  vivify_2746:
    $P5757 = $P5756."ast"()
    set $P5751, $P5757
  if_5752_end:
    $P5761 = $P5750."!make"($P5751)
.annotate 'line', 1977
    .return ($P5761)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("560_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5763
    .param pmc param_5764
.annotate 'line', 1981
    .lex "self", param_5763
    .lex "$/", param_5764
.annotate 'line', 1982
    new $P5765, "Undef"
    .lex "$value", $P5765
    find_lex $P5768, "$/"
    unless_null $P5768, vivify_2747
    $P5768 = root_new ['parrot';'Hash']
  vivify_2747:
    set $P5769, $P5768["dec_number"]
    unless_null $P5769, vivify_2748
    new $P5769, "Undef"
  vivify_2748:
    if $P5769, if_5767
    find_lex $P5773, "$/"
    unless_null $P5773, vivify_2749
    $P5773 = root_new ['parrot';'Hash']
  vivify_2749:
    set $P5774, $P5773["integer"]
    unless_null $P5774, vivify_2750
    new $P5774, "Undef"
  vivify_2750:
    $P5775 = $P5774."ast"()
    set $P5766, $P5775
    goto if_5767_end
  if_5767:
    find_lex $P5770, "$/"
    unless_null $P5770, vivify_2751
    $P5770 = root_new ['parrot';'Hash']
  vivify_2751:
    set $P5771, $P5770["dec_number"]
    unless_null $P5771, vivify_2752
    new $P5771, "Undef"
  vivify_2752:
    $P5772 = $P5771."ast"()
    set $P5766, $P5772
  if_5767_end:
    store_lex "$value", $P5766
.annotate 'line', 1983
    find_lex $P5777, "$/"
    unless_null $P5777, vivify_2753
    $P5777 = root_new ['parrot';'Hash']
  vivify_2753:
    set $P5778, $P5777["sign"]
    unless_null $P5778, vivify_2754
    new $P5778, "Undef"
  vivify_2754:
    set $S5779, $P5778
    iseq $I5780, $S5779, "-"
    unless $I5780, if_5776_end
    find_lex $P5781, "$value"
    unless_null $P5781, vivify_2755
    new $P5781, "Undef"
  vivify_2755:
    neg $P5782, $P5781
    store_lex "$value", $P5782
  if_5776_end:
.annotate 'line', 1984
    find_lex $P5783, "$/"
    get_hll_global $P5784, "GLOBAL"
    nqp_get_package_through_who $P5785, $P5784, "PAST"
    get_who $P5786, $P5785
    set $P5787, $P5786["Val"]
    find_lex $P5788, "$value"
    unless_null $P5788, vivify_2756
    new $P5788, "Undef"
  vivify_2756:
    $P5789 = $P5787."new"($P5788 :named("value"))
    $P5790 = $P5783."!make"($P5789)
.annotate 'line', 1981
    .return ($P5790)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("561_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5792
    .param pmc param_5793
.annotate 'line', 1987
    .lex "self", param_5792
    .lex "$/", param_5793
    find_lex $P5794, "$/"
    find_lex $P5795, "$/"
    unless_null $P5795, vivify_2757
    $P5795 = root_new ['parrot';'Hash']
  vivify_2757:
    set $P5796, $P5795["quote_EXPR"]
    unless_null $P5796, vivify_2758
    new $P5796, "Undef"
  vivify_2758:
    $P5797 = $P5796."ast"()
    $P5798 = $P5794."!make"($P5797)
    .return ($P5798)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("562_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5800
    .param pmc param_5801
.annotate 'line', 1988
    .lex "self", param_5800
    .lex "$/", param_5801
    find_lex $P5802, "$/"
    find_lex $P5803, "$/"
    unless_null $P5803, vivify_2759
    $P5803 = root_new ['parrot';'Hash']
  vivify_2759:
    set $P5804, $P5803["quote_EXPR"]
    unless_null $P5804, vivify_2760
    new $P5804, "Undef"
  vivify_2760:
    $P5805 = $P5804."ast"()
    $P5806 = $P5802."!make"($P5805)
    .return ($P5806)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("563_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5808
    .param pmc param_5809
.annotate 'line', 1989
    .lex "self", param_5808
    .lex "$/", param_5809
    find_lex $P5810, "$/"
    find_lex $P5811, "$/"
    unless_null $P5811, vivify_2761
    $P5811 = root_new ['parrot';'Hash']
  vivify_2761:
    set $P5812, $P5811["quote_EXPR"]
    unless_null $P5812, vivify_2762
    new $P5812, "Undef"
  vivify_2762:
    $P5813 = $P5812."ast"()
    $P5814 = $P5810."!make"($P5813)
    .return ($P5814)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("564_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5816
    .param pmc param_5817
.annotate 'line', 1990
    .lex "self", param_5816
    .lex "$/", param_5817
    find_lex $P5818, "$/"
    find_lex $P5819, "$/"
    unless_null $P5819, vivify_2763
    $P5819 = root_new ['parrot';'Hash']
  vivify_2763:
    set $P5820, $P5819["quote_EXPR"]
    unless_null $P5820, vivify_2764
    new $P5820, "Undef"
  vivify_2764:
    $P5821 = $P5820."ast"()
    $P5822 = $P5818."!make"($P5821)
    .return ($P5822)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("565_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5824
    .param pmc param_5825
.annotate 'line', 1991
    .lex "self", param_5824
    .lex "$/", param_5825
    find_lex $P5826, "$/"
    find_lex $P5827, "$/"
    unless_null $P5827, vivify_2765
    $P5827 = root_new ['parrot';'Hash']
  vivify_2765:
    set $P5828, $P5827["quote_EXPR"]
    unless_null $P5828, vivify_2766
    new $P5828, "Undef"
  vivify_2766:
    $P5829 = $P5828."ast"()
    $P5830 = $P5826."!make"($P5829)
    .return ($P5830)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("566_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5832
    .param pmc param_5833
.annotate 'line', 1992
    .lex "self", param_5832
    .lex "$/", param_5833
.annotate 'line', 1993
    find_lex $P5834, "$/"
    get_hll_global $P5835, "GLOBAL"
    nqp_get_package_through_who $P5836, $P5835, "PAST"
    get_who $P5837, $P5836
    set $P5838, $P5837["Op"]
    find_lex $P5839, "$/"
    unless_null $P5839, vivify_2767
    $P5839 = root_new ['parrot';'Hash']
  vivify_2767:
    set $P5840, $P5839["quote_EXPR"]
    unless_null $P5840, vivify_2768
    new $P5840, "Undef"
  vivify_2768:
    $P5841 = $P5840."ast"()
    $P5842 = $P5841."value"()
    find_lex $P5843, "$/"
    unless_null $P5843, vivify_2769
    new $P5843, "Undef"
  vivify_2769:
    $P5844 = $P5838."new"($P5842 :named("inline"), "inline" :named("pasttype"), $P5843 :named("node"))
    $P5845 = $P5834."!make"($P5844)
.annotate 'line', 1992
    .return ($P5845)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("567_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5849
    .param pmc param_5850
    .param pmc param_5851 :optional
    .param int has_param_5851 :opt_flag
.annotate 'line', 1998
    new $P5848, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5848, control_5847
    push_eh $P5848
    .lex "self", param_5849
    .lex "$/", param_5850
    if has_param_5851, optparam_2770
    new $P5852, "Undef"
    set param_5851, $P5852
  optparam_2770:
    .lex "$key", param_5851
.annotate 'line', 2005
    new $P5853, "Undef"
    .lex "$regex", $P5853
.annotate 'line', 2007
    new $P5854, "Undef"
    .lex "$past", $P5854
.annotate 'line', 1999
    find_lex $P5856, "$key"
    unless_null $P5856, vivify_2771
    new $P5856, "Undef"
  vivify_2771:
    set $S5857, $P5856
    iseq $I5858, $S5857, "open"
    unless $I5858, if_5855_end
.annotate 'line', 2000
    null $P5859
    get_hll_global $P5860, "GLOBAL"
    nqp_get_package_through_who $P5861, $P5860, "Regex"
    nqp_get_package_through_who $P5862, $P5861, "P6Regex"
    nqp_get_package_through_who $P5863, $P5862, "Actions"
    get_who $P5864, $P5863
    set $P5864["$REGEXNAME"], $P5859
.annotate 'line', 2001
    find_lex $P5865, "$?PACKAGE"
    get_who $P5866, $P5865
    set $P5867, $P5866["@BLOCK"]
    unless_null $P5867, vivify_2772
    $P5867 = root_new ['parrot';'ResizablePMCArray']
  vivify_2772:
    set $P5868, $P5867[0]
    unless_null $P5868, vivify_2773
    new $P5868, "Undef"
  vivify_2773:
    $P5868."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2002
    find_lex $P5869, "$?PACKAGE"
    get_who $P5870, $P5869
    set $P5871, $P5870["@BLOCK"]
    unless_null $P5871, vivify_2774
    $P5871 = root_new ['parrot';'ResizablePMCArray']
  vivify_2774:
    set $P5872, $P5871[0]
    unless_null $P5872, vivify_2775
    new $P5872, "Undef"
  vivify_2775:
    $P5872."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2003
    new $P5873, "Exception"
    set $P5873['type'], .CONTROL_RETURN
    new $P5874, "Integer"
    assign $P5874, 0
    setattribute $P5873, 'payload', $P5874
    throw $P5873
  if_5855_end:
.annotate 'line', 2006
    get_hll_global $P5875, "GLOBAL"
    nqp_get_package_through_who $P5876, $P5875, "Regex"
    nqp_get_package_through_who $P5877, $P5876, "P6Regex"
    nqp_get_package_through_who $P5878, $P5877, "Actions"
    get_who $P5879, $P5878
    set $P5880, $P5879["buildsub"]
    find_lex $P5881, "$/"
    unless_null $P5881, vivify_2776
    $P5881 = root_new ['parrot';'Hash']
  vivify_2776:
    set $P5882, $P5881["p6regex"]
    unless_null $P5882, vivify_2777
    new $P5882, "Undef"
  vivify_2777:
    $P5883 = $P5882."ast"()
    find_lex $P5884, "$?PACKAGE"
    get_who $P5885, $P5884
    set $P5886, $P5885["@BLOCK"]
    unless_null $P5886, vivify_2778
    $P5886 = root_new ['parrot';'ResizablePMCArray']
  vivify_2778:
    $P5887 = $P5886."shift"()
    $P5888 = $P5880($P5883, $P5887)
    store_lex "$regex", $P5888
.annotate 'line', 2008
    get_hll_global $P5889, "GLOBAL"
    nqp_get_package_through_who $P5890, $P5889, "PAST"
    get_who $P5891, $P5890
    set $P5892, $P5891["Op"]
.annotate 'line', 2010
    new $P5893, "ResizablePMCArray"
    push $P5893, "Regex"
    push $P5893, "Regex"
    find_lex $P5894, "$/"
    unless_null $P5894, vivify_2779
    new $P5894, "Undef"
  vivify_2779:
    $P5895 = "lexical_package_lookup"($P5893, $P5894)
    find_lex $P5896, "$regex"
    unless_null $P5896, vivify_2780
    new $P5896, "Undef"
  vivify_2780:
    $P5897 = $P5892."new"($P5895, $P5896, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2008
    store_lex "$past", $P5897
.annotate 'line', 2014
    find_lex $P5898, "$regex"
    unless_null $P5898, vivify_2781
    new $P5898, "Undef"
  vivify_2781:
    find_lex $P5899, "$past"
    unless_null $P5899, vivify_2782
    $P5899 = root_new ['parrot';'Hash']
    store_lex "$past", $P5899
  vivify_2782:
    set $P5899["sink"], $P5898
.annotate 'line', 2015
    find_lex $P5900, "$/"
    find_lex $P5901, "$past"
    unless_null $P5901, vivify_2783
    new $P5901, "Undef"
  vivify_2783:
    $P5902 = $P5900."!make"($P5901)
.annotate 'line', 1998
    .return ($P5902)
  control_5847:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5903, exception, "payload"
    .return ($P5903)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("568_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5905
    .param pmc param_5906
.annotate 'line', 2018
    .lex "self", param_5905
    .lex "$/", param_5906
    find_lex $P5907, "$/"
    find_lex $P5908, "$/"
    unless_null $P5908, vivify_2784
    $P5908 = root_new ['parrot';'Hash']
  vivify_2784:
    set $P5909, $P5908["variable"]
    unless_null $P5909, vivify_2785
    new $P5909, "Undef"
  vivify_2785:
    $P5910 = $P5909."ast"()
    $P5911 = $P5907."!make"($P5910)
    .return ($P5911)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("569_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5913
    .param pmc param_5914
.annotate 'line', 2019
    .lex "self", param_5913
    .lex "$/", param_5914
.annotate 'line', 2020
    find_lex $P5915, "$/"
    get_hll_global $P5916, "GLOBAL"
    nqp_get_package_through_who $P5917, $P5916, "PAST"
    get_who $P5918, $P5917
    set $P5919, $P5918["Op"]
.annotate 'line', 2021
    find_lex $P5920, "$/"
    unless_null $P5920, vivify_2786
    $P5920 = root_new ['parrot';'Hash']
  vivify_2786:
    set $P5921, $P5920["block"]
    unless_null $P5921, vivify_2787
    new $P5921, "Undef"
  vivify_2787:
    $P5922 = $P5921."ast"()
    $P5923 = "block_immediate"($P5922)
    find_lex $P5924, "$/"
    unless_null $P5924, vivify_2788
    new $P5924, "Undef"
  vivify_2788:
    $P5925 = $P5919."new"($P5923, "set S*" :named("pirop"), $P5924 :named("node"))
.annotate 'line', 2020
    $P5926 = $P5915."!make"($P5925)
.annotate 'line', 2019
    .return ($P5926)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("570_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5928
    .param pmc param_5929
.annotate 'line', 2024
    .lex "self", param_5928
    .lex "$/", param_5929
    find_lex $P5930, "$/"
    $P5931 = $P5930."!make"("\e")
    .return ($P5931)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("571_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5933
    .param pmc param_5934
.annotate 'line', 2028
    .lex "self", param_5933
    .lex "$/", param_5934
    find_lex $P5935, "$/"
    find_lex $P5936, "$/"
    unless_null $P5936, vivify_2789
    $P5936 = root_new ['parrot';'Hash']
  vivify_2789:
    set $P5937, $P5936["dotty"]
    unless_null $P5937, vivify_2790
    new $P5937, "Undef"
  vivify_2790:
    $P5938 = $P5937."ast"()
    $P5939 = $P5935."!make"($P5938)
    .return ($P5939)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("572_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5941
    .param pmc param_5942
.annotate 'line', 2030
    .lex "self", param_5941
    .lex "$/", param_5942
.annotate 'line', 2031
    find_lex $P5943, "$/"
    get_hll_global $P5944, "GLOBAL"
    nqp_get_package_through_who $P5945, $P5944, "PAST"
    get_who $P5946, $P5945
    set $P5947, $P5946["Op"]
.annotate 'line', 2032
    new $P5948, "ResizablePMCArray"
    push $P5948, "    clone %r, %0"
    push $P5948, "    inc %0"
    $P5949 = $P5947."new"("postfix:<++>" :named("name"), $P5948 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2031
    $P5950 = $P5943."!make"($P5949)
.annotate 'line', 2030
    .return ($P5950)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("573_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5952
    .param pmc param_5953
.annotate 'line', 2036
    .lex "self", param_5952
    .lex "$/", param_5953
.annotate 'line', 2037
    find_lex $P5954, "$/"
    get_hll_global $P5955, "GLOBAL"
    nqp_get_package_through_who $P5956, $P5955, "PAST"
    get_who $P5957, $P5956
    set $P5958, $P5957["Op"]
.annotate 'line', 2038
    new $P5959, "ResizablePMCArray"
    push $P5959, "    clone %r, %0"
    push $P5959, "    dec %0"
    $P5960 = $P5958."new"("postfix:<-->" :named("name"), $P5959 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2037
    $P5961 = $P5954."!make"($P5960)
.annotate 'line', 2036
    .return ($P5961)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("574_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5963
    .param pmc param_5964
.annotate 'line', 2042
    .lex "self", param_5963
    .lex "$/", param_5964
.annotate 'line', 2043
    find_lex $P5965, "$/"
    get_hll_global $P5966, "GLOBAL"
    nqp_get_package_through_who $P5967, $P5966, "PAST"
    get_who $P5968, $P5967
    set $P5969, $P5968["Op"]
.annotate 'line', 2044
    get_hll_global $P5970, "GLOBAL"
    nqp_get_package_through_who $P5971, $P5970, "PAST"
    get_who $P5972, $P5971
    set $P5973, $P5972["Var"]
    $P5974 = $P5973."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5975, "$/"
    unless_null $P5975, vivify_2791
    new $P5975, "Undef"
  vivify_2791:
    $P5976 = $P5969."new"($P5974, "callmethod" :named("pasttype"), "!make" :named("name"), $P5975 :named("node"))
.annotate 'line', 2043
    $P5977 = $P5965."!make"($P5976)
.annotate 'line', 2042
    .return ($P5977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("575_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5980
    .param pmc param_5981
.annotate 'line', 2060
    .lex "self", param_5980
    .lex "$/", param_5981
    find_lex $P5982, "$/"
    unless_null $P5982, vivify_2792
    new $P5982, "Undef"
  vivify_2792:
    $P5983 = "control"($P5982, "CONTROL_LOOP_NEXT")
    .return ($P5983)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("576_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5985
    .param pmc param_5986
.annotate 'line', 2061
    .lex "self", param_5985
    .lex "$/", param_5986
    find_lex $P5987, "$/"
    unless_null $P5987, vivify_2793
    new $P5987, "Undef"
  vivify_2793:
    $P5988 = "control"($P5987, "CONTROL_LOOP_LAST")
    .return ($P5988)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("577_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5990
    .param pmc param_5991
.annotate 'line', 2062
    .lex "self", param_5990
    .lex "$/", param_5991
    find_lex $P5992, "$/"
    unless_null $P5992, vivify_2794
    new $P5992, "Undef"
  vivify_2794:
    $P5993 = "control"($P5992, "CONTROL_LOOP_REDO")
    .return ($P5993)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("578_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_5995
    .param pmc param_5996
.annotate 'line', 2064
    .lex "self", param_5995
    .lex "$/", param_5996
.annotate 'line', 2065
    find_lex $P5997, "$/"
    get_hll_global $P5998, "GLOBAL"
    nqp_get_package_through_who $P5999, $P5998, "PAST"
    get_who $P6000, $P5999
    set $P6001, $P6000["Op"]
    find_lex $P6002, "$/"
    unless_null $P6002, vivify_2795
    new $P6002, "Undef"
  vivify_2795:
    $P6003 = $P6001."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P6002 :named("node"))
    $P6004 = $P5997."!make"($P6003)
.annotate 'line', 2064
    .return ($P6004)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "known_sym"  :subid("579_1304516047.681") :outer("406_1304516047.681")
    .param pmc param_6010
    .param pmc param_6011
    .param pmc param_6012
.annotate 'line', 2142
    .const 'Sub' $P6016 = "580_1304516047.681" 
    capture_lex $P6016
    .lex "self", param_6010
    .lex "$/", param_6011
    .lex "@name", param_6012
.annotate 'line', 2143
    new $P6013, "Undef"
    .lex "$known", $P6013
    new $P6014, "Integer"
    assign $P6014, 0
    store_lex "$known", $P6014
.annotate 'line', 2144
    .const 'Sub' $P6016 = "580_1304516047.681" 
    capture_lex $P6016
    $P6016()
    find_lex $P6027, "$known"
    unless_null $P6027, vivify_2798
    new $P6027, "Undef"
  vivify_2798:
.annotate 'line', 2142
    .return ($P6027)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block6015"  :anon :subid("580_1304516047.681") :outer("579_1304516047.681")
.annotate 'line', 2144
    new $P6022, 'ExceptionHandler'
    set_label $P6022, control_6021
    $P6022."handle_types_except"(.CONTROL_RETURN,  .CONTROL_OK,  .CONTROL_BREAK,  .CONTROL_CONTINUE,  .CONTROL_TAKE,  .CONTROL_LEAVE,  .CONTROL_EXIT,  .CONTROL_LOOP_NEXT,  .CONTROL_LOOP_LAST,  .CONTROL_LOOP_REDO)
    push_eh $P6022
.annotate 'line', 2145
    find_lex $P6017, "@name"
    unless_null $P6017, vivify_2796
    $P6017 = root_new ['parrot';'ResizablePMCArray']
  vivify_2796:
    find_lex $P6018, "$/"
    unless_null $P6018, vivify_2797
    new $P6018, "Undef"
  vivify_2797:
    "find_sym"($P6017, $P6018)
.annotate 'line', 2146
    new $P6019, "Integer"
    assign $P6019, 1
    store_lex "$known", $P6019
.annotate 'line', 2144
    pop_eh 
    goto skip_handler_6020
  control_6021:
    .local pmc exception 
    .get_results (exception) 
    new $P6025, 'Integer'
    set $P6025, 1
    set exception["handled"], $P6025
    set $I6026, exception["handled"]
    ne $I6026, 1, nothandled_6024
  handled_6023:
    .return (exception)
  nothandled_6024:
    rethrow exception
  skip_handler_6020:
    .return ($P6019)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block6029"  :subid("581_1304516047.681") :outer("10_1304516047.681")
.annotate 'line', 2211
    .const 'Sub' $P6123 = "588_1304516047.681" 
    capture_lex $P6123
    .const 'Sub' $P6109 = "587_1304516047.681" 
    capture_lex $P6109
    .const 'Sub' $P6091 = "586_1304516047.681" 
    capture_lex $P6091
    .const 'Sub' $P6077 = "585_1304516047.681" 
    capture_lex $P6077
    .const 'Sub' $P6063 = "584_1304516047.681" 
    capture_lex $P6063
    .const 'Sub' $P6049 = "583_1304516047.681" 
    capture_lex $P6049
    .const 'Sub' $P6033 = "582_1304516047.681" 
    capture_lex $P6033
    .lex "$?PACKAGE", $P6031
    .lex "$?CLASS", $P6032
.annotate 'line', 2245
    .const 'Sub' $P6123 = "588_1304516047.681" 
    newclosure $P6161, $P6123
.annotate 'line', 2211
    .return ($P6161)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("582_1304516047.681") :outer("581_1304516047.681")
    .param pmc param_6034
    .param pmc param_6035
.annotate 'line', 2213
    .lex "self", param_6034
    .lex "$/", param_6035
.annotate 'line', 2214
    new $P6036, "Undef"
    .lex "$past", $P6036
    find_lex $P6037, "$/"
    unless_null $P6037, vivify_2799
    $P6037 = root_new ['parrot';'Hash']
  vivify_2799:
    set $P6038, $P6037["statement"]
    unless_null $P6038, vivify_2800
    new $P6038, "Undef"
  vivify_2800:
    $P6039 = $P6038."ast"()
    store_lex "$past", $P6039
.annotate 'line', 2215
    find_lex $P6040, "$/"
    get_hll_global $P6041, "GLOBAL"
    nqp_get_package_through_who $P6042, $P6041, "PAST"
    get_who $P6043, $P6042
    set $P6044, $P6043["Regex"]
    find_lex $P6045, "$past"
    unless_null $P6045, vivify_2801
    new $P6045, "Undef"
  vivify_2801:
    find_lex $P6046, "$/"
    unless_null $P6046, vivify_2802
    new $P6046, "Undef"
  vivify_2802:
    $P6047 = $P6044."new"($P6045, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P6046 :named("node"))
    $P6048 = $P6040."!make"($P6047)
.annotate 'line', 2213
    .return ($P6048)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("583_1304516047.681") :outer("581_1304516047.681")
    .param pmc param_6050
    .param pmc param_6051
.annotate 'line', 2219
    .lex "self", param_6050
    .lex "$/", param_6051
.annotate 'line', 2220
    find_lex $P6052, "$/"
    get_hll_global $P6053, "GLOBAL"
    nqp_get_package_through_who $P6054, $P6053, "PAST"
    get_who $P6055, $P6054
    set $P6056, $P6055["Regex"]
    find_lex $P6057, "$/"
    unless_null $P6057, vivify_2803
    $P6057 = root_new ['parrot';'Hash']
  vivify_2803:
    set $P6058, $P6057["codeblock"]
    unless_null $P6058, vivify_2804
    new $P6058, "Undef"
  vivify_2804:
    $P6059 = $P6058."ast"()
    find_lex $P6060, "$/"
    unless_null $P6060, vivify_2805
    new $P6060, "Undef"
  vivify_2805:
    $P6061 = $P6056."new"($P6059, "pastnode" :named("pasttype"), $P6060 :named("node"))
    $P6062 = $P6052."!make"($P6061)
.annotate 'line', 2219
    .return ($P6062)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("584_1304516047.681") :outer("581_1304516047.681")
    .param pmc param_6064
    .param pmc param_6065
.annotate 'line', 2224
    .lex "self", param_6064
    .lex "$/", param_6065
.annotate 'line', 2225
    find_lex $P6066, "$/"
    get_hll_global $P6067, "GLOBAL"
    nqp_get_package_through_who $P6068, $P6067, "PAST"
    get_who $P6069, $P6068
    set $P6070, $P6069["Regex"]
    find_lex $P6071, "$/"
    unless_null $P6071, vivify_2806
    $P6071 = root_new ['parrot';'Hash']
  vivify_2806:
    set $P6072, $P6071["var"]
    unless_null $P6072, vivify_2807
    new $P6072, "Undef"
  vivify_2807:
    $P6073 = $P6072."ast"()
    find_lex $P6074, "$/"
    unless_null $P6074, vivify_2808
    new $P6074, "Undef"
  vivify_2808:
    $P6075 = $P6070."new"("!INTERPOLATE", $P6073, "subrule" :named("pasttype"), "method" :named("subtype"), $P6074 :named("node"))
    $P6076 = $P6066."!make"($P6075)
.annotate 'line', 2224
    .return ($P6076)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("585_1304516047.681") :outer("581_1304516047.681")
    .param pmc param_6078
    .param pmc param_6079
.annotate 'line', 2229
    .lex "self", param_6078
    .lex "$/", param_6079
.annotate 'line', 2230
    find_lex $P6080, "$/"
    get_hll_global $P6081, "GLOBAL"
    nqp_get_package_through_who $P6082, $P6081, "PAST"
    get_who $P6083, $P6082
    set $P6084, $P6083["Regex"]
    find_lex $P6085, "$/"
    unless_null $P6085, vivify_2809
    $P6085 = root_new ['parrot';'Hash']
  vivify_2809:
    set $P6086, $P6085["codeblock"]
    unless_null $P6086, vivify_2810
    new $P6086, "Undef"
  vivify_2810:
    $P6087 = $P6086."ast"()
    find_lex $P6088, "$/"
    unless_null $P6088, vivify_2811
    new $P6088, "Undef"
  vivify_2811:
    $P6089 = $P6084."new"("!INTERPOLATE_REGEX", $P6087, "subrule" :named("pasttype"), "method" :named("subtype"), $P6088 :named("node"))
    $P6090 = $P6080."!make"($P6089)
.annotate 'line', 2229
    .return ($P6090)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("586_1304516047.681") :outer("581_1304516047.681")
    .param pmc param_6092
    .param pmc param_6093
.annotate 'line', 2234
    .lex "self", param_6092
    .lex "$/", param_6093
.annotate 'line', 2235
    find_lex $P6094, "$/"
    get_hll_global $P6095, "GLOBAL"
    nqp_get_package_through_who $P6096, $P6095, "PAST"
    get_who $P6097, $P6096
    set $P6098, $P6097["Regex"]
    find_lex $P6099, "$/"
    unless_null $P6099, vivify_2812
    $P6099 = root_new ['parrot';'Hash']
  vivify_2812:
    set $P6100, $P6099["codeblock"]
    unless_null $P6100, vivify_2813
    new $P6100, "Undef"
  vivify_2813:
    $P6101 = $P6100."ast"()
.annotate 'line', 2236
    find_lex $P6102, "$/"
    unless_null $P6102, vivify_2814
    $P6102 = root_new ['parrot';'Hash']
  vivify_2814:
    set $P6103, $P6102["zw"]
    unless_null $P6103, vivify_2815
    new $P6103, "Undef"
  vivify_2815:
    set $S6104, $P6103
    iseq $I6105, $S6104, "!"
    find_lex $P6106, "$/"
    unless_null $P6106, vivify_2816
    new $P6106, "Undef"
  vivify_2816:
    $P6107 = $P6098."new"($P6101, "zerowidth" :named("subtype"), $I6105 :named("negate"), "pastnode" :named("pasttype"), $P6106 :named("node"))
.annotate 'line', 2235
    $P6108 = $P6094."!make"($P6107)
.annotate 'line', 2234
    .return ($P6108)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("587_1304516047.681") :outer("581_1304516047.681")
    .param pmc param_6110
    .param pmc param_6111
.annotate 'line', 2240
    .lex "self", param_6110
    .lex "$/", param_6111
.annotate 'line', 2241
    find_lex $P6112, "$/"
    get_hll_global $P6113, "GLOBAL"
    nqp_get_package_through_who $P6114, $P6113, "PAST"
    get_who $P6115, $P6114
    set $P6116, $P6115["Regex"]
    find_lex $P6117, "$/"
    unless_null $P6117, vivify_2817
    $P6117 = root_new ['parrot';'Hash']
  vivify_2817:
    set $P6118, $P6117["var"]
    unless_null $P6118, vivify_2818
    new $P6118, "Undef"
  vivify_2818:
    $P6119 = $P6118."ast"()
    find_lex $P6120, "$/"
    unless_null $P6120, vivify_2819
    new $P6120, "Undef"
  vivify_2819:
    $P6121 = $P6116."new"("!INTERPOLATE_REGEX", $P6119, "subrule" :named("pasttype"), "method" :named("subtype"), $P6120 :named("node"))
    $P6122 = $P6112."!make"($P6121)
.annotate 'line', 2240
    .return ($P6122)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("588_1304516047.681") :outer("581_1304516047.681")
    .param pmc param_6124
    .param pmc param_6125
.annotate 'line', 2245
    .lex "self", param_6124
    .lex "$/", param_6125
.annotate 'line', 2246
    new $P6126, "Undef"
    .lex "$block", $P6126
.annotate 'line', 2248
    new $P6127, "Undef"
    .lex "$past", $P6127
.annotate 'line', 2246
    find_lex $P6128, "$/"
    unless_null $P6128, vivify_2820
    $P6128 = root_new ['parrot';'Hash']
  vivify_2820:
    set $P6129, $P6128["block"]
    unless_null $P6129, vivify_2821
    new $P6129, "Undef"
  vivify_2821:
    $P6130 = $P6129."ast"()
    store_lex "$block", $P6130
.annotate 'line', 2247
    find_lex $P6131, "$block"
    unless_null $P6131, vivify_2822
    new $P6131, "Undef"
  vivify_2822:
    $P6131."blocktype"("immediate")
.annotate 'line', 2249
    get_hll_global $P6132, "GLOBAL"
    nqp_get_package_through_who $P6133, $P6132, "PAST"
    get_who $P6134, $P6133
    set $P6135, $P6134["Stmts"]
.annotate 'line', 2250
    get_hll_global $P6136, "GLOBAL"
    nqp_get_package_through_who $P6137, $P6136, "PAST"
    get_who $P6138, $P6137
    set $P6139, $P6138["Op"]
.annotate 'line', 2251
    get_hll_global $P6140, "GLOBAL"
    nqp_get_package_through_who $P6141, $P6140, "PAST"
    get_who $P6142, $P6141
    set $P6143, $P6142["Var"]
    $P6144 = $P6143."new"("$/" :named("name"))
.annotate 'line', 2252
    get_hll_global $P6145, "GLOBAL"
    nqp_get_package_through_who $P6146, $P6145, "PAST"
    get_who $P6147, $P6146
    set $P6148, $P6147["Op"]
.annotate 'line', 2253
    get_hll_global $P6149, "GLOBAL"
    nqp_get_package_through_who $P6150, $P6149, "PAST"
    get_who $P6151, $P6150
    set $P6152, $P6151["Var"]
    $P6153 = $P6152."new"(unicode:"$\x{a2}" :named("name"))
    $P6154 = $P6148."new"($P6153, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2252
    $P6155 = $P6139."new"($P6144, $P6154, "bind" :named("pasttype"))
.annotate 'line', 2250
    find_lex $P6156, "$block"
    unless_null $P6156, vivify_2823
    new $P6156, "Undef"
  vivify_2823:
    $P6157 = $P6135."new"($P6155, $P6156)
.annotate 'line', 2249
    store_lex "$past", $P6157
.annotate 'line', 2261
    find_lex $P6158, "$/"
    find_lex $P6159, "$past"
    unless_null $P6159, vivify_2824
    new $P6159, "Undef"
  vivify_2824:
    $P6160 = $P6158."!make"($P6159)
.annotate 'line', 2245
    .return ($P6160)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block6162"  :subid("589_1304516047.681") :outer("10_1304516047.681")
.annotate 'line', 2266
    .lex "$?PACKAGE", $P6164
    .lex "$?CLASS", $P6165
    .return ()
.end


.HLL "nqp"

.namespace []
.sub "_block6176" :load :anon :subid("590_1304516047.681")
.annotate 'line', 1
    .const 'Sub' $P6178 = "10_1304516047.681" 
    $P6179 = $P6178()
    .return ($P6179)
.end

