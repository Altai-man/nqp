# Copyright (C) 2009, The Perl Foundation.

=head1 NAME

NQP::Compiler - NQP compiler

=head1 DESCRIPTION

=cut

.HLL 'nqp'

# Initialize meta-model.
.loadlib "nqp_group"
.loadlib "nqp_ops"
.sub '' :anon :load :init
    nqp_dynop_setup

    .local pmc interp, lexpad, nqplexpad
    interp = getinterp
    lexpad = get_class 'LexPad'
    nqplexpad = get_class 'NQPLexPad'
    interp.'hll_map'(lexpad, nqplexpad)
.end
### .include 'gen/nqp-how.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299450582.447")
.annotate 'line', 0
    get_hll_global $P2796, ["str"], "_block2795" 
    capture_lex $P2796
    get_hll_global $P2787, ["num"], "_block2786" 
    capture_lex $P2787
    get_hll_global $P2778, ["int"], "_block2777" 
    capture_lex $P2778
    get_hll_global $P2624, ["NQPMu"], "_block2623" 
    capture_lex $P2624
    get_hll_global $P2535, ["NQPModuleHOW"], "_block2534" 
    capture_lex $P2535
    get_hll_global $P2305, ["RoleToRoleApplier"], "_block2304" 
    capture_lex $P2305
    get_hll_global $P2089, ["RoleToClassApplier"], "_block2088" 
    capture_lex $P2089
    get_hll_global $P1733, ["NQPParametricRoleHOW"], "_block1732" 
    capture_lex $P1733
    get_hll_global $P1411, ["NQPConcreteRoleHOW"], "_block1410" 
    capture_lex $P1411
    get_hll_global $P1199, ["NQPAttribute"], "_block1198" 
    capture_lex $P1199
    get_hll_global $P1111, ["NQPNativeHOW"], "_block1110" 
    capture_lex $P1111
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, "str"
    get_hll_global $P14, "num"
    get_hll_global $P15, "int"
    get_hll_global $P16, "NQPMu"
    get_hll_global $P17, "NQPModuleHOW"
    get_hll_global $P18, "RoleToRoleApplier"
    get_hll_global $P19, "RoleToClassApplier"
    get_hll_global $P20, "NQPParametricRoleHOW"
    get_hll_global $P21, "NQPConcreteRoleHOW"
    get_hll_global $P22, "NQPAttribute"
    get_hll_global $P23, "NQPNativeHOW"
    get_hll_global $P24, "NQPClassHOW"
    get_hll_global $P25, "KnowHOWAttribute"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    capture_lex $P27
    $P27()
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    capture_lex $P53
    $P53()
.annotate 'line', 454
    get_hll_global $P1111, ["NQPNativeHOW"], "_block1110" 
    capture_lex $P1111
    $P1111()
.annotate 'line', 498
    get_hll_global $P1199, ["NQPAttribute"], "_block1198" 
    capture_lex $P1199
    $P1199()
.annotate 'line', 571
    get_hll_global $P1411, ["NQPConcreteRoleHOW"], "_block1410" 
    capture_lex $P1411
    $P1411()
.annotate 'line', 720
    get_hll_global $P1733, ["NQPParametricRoleHOW"], "_block1732" 
    capture_lex $P1733
    $P1733()
.annotate 'line', 886
    get_hll_global $P2089, ["RoleToClassApplier"], "_block2088" 
    capture_lex $P2089
    $P2089()
.annotate 'line', 958
    get_hll_global $P2305, ["RoleToRoleApplier"], "_block2304" 
    capture_lex $P2305
    $P2305()
.annotate 'line', 1048
    get_hll_global $P2535, ["NQPModuleHOW"], "_block2534" 
    capture_lex $P2535
    $P2535()
.annotate 'line', 1093
    get_hll_global $P2624, ["NQPMu"], "_block2623" 
    capture_lex $P2624
    $P2624()
.annotate 'line', 1142
    get_hll_global $P2778, ["int"], "_block2777" 
    capture_lex $P2778
    $P2778()
.annotate 'line', 1144
    get_hll_global $P2787, ["num"], "_block2786" 
    capture_lex $P2787
    $P2787()
.annotate 'line', 1146
    get_hll_global $P2796, ["str"], "_block2795" 
    capture_lex $P2796
    $P2804 = $P2796()
.annotate 'line', 1
    .return ($P2804)
    .const 'Sub' $P2806 = "194_1299450582.447" 
    .return ($P2806)
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "_block26"  :subid("11_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 10
    .const 'Sub' $P43 = "14_1299450582.447" 
    capture_lex $P43
    .const 'Sub' $P37 = "13_1299450582.447" 
    capture_lex $P37
    .const 'Sub' $P29 = "12_1299450582.447" 
    capture_lex $P29
    get_global $P28, "$?CLASS"
.annotate 'line', 14
    .const 'Sub' $P37 = "13_1299450582.447" 
    newclosure $P41, $P37
.annotate 'line', 10
    .return ($P41)
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "" :load :init :subid("post195") :outer("11_1299450582.447")
.annotate 'line', 10
    get_hll_global $P27, ["KnowHOWAttribute"], "_block26" 
    .local pmc block
    set block, $P27
    .const 'Sub' $P43 = "14_1299450582.447" 
    capture_lex $P43
    $P43()
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "_block42"  :anon :subid("14_1299450582.447") :outer("11_1299450582.447")
.annotate 'line', 10
    get_hll_global $P44, "KnowHOW"
    $P45 = $P44."new_type"("KnowHOWAttribute" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P45
    set_hll_global "KnowHOWAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P46, type_obj
    .const 'Sub' $P47 = "12_1299450582.447" 
    $P46."add_method"(type_obj, "new", $P47)
    get_how $P48, type_obj
    .const 'Sub' $P49 = "13_1299450582.447" 
    $P48."add_method"(type_obj, "name", $P49)
    get_how $P50, type_obj
    $P51 = $P50."compose"(type_obj)
    .return ($P51)
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "new"  :subid("12_1299450582.447") :outer("11_1299450582.447")
    .param pmc param_30
    .param pmc param_31 :optional :named("name")
    .param int has_param_31 :opt_flag
.annotate 'line', 11
    .lex "self", param_30
    if has_param_31, optparam_196
    new $P32, "Undef"
    set param_31, $P32
  optparam_196:
    .lex "$name", param_31
.annotate 'line', 12
    find_lex $P33, "$name"
    set $S34, $P33
    get_hll_global $P35, "KnowHOWAttribute"
    repr_box_str $P36, $S34, $P35
.annotate 'line', 11
    .return ($P36)
.end


.HLL "nqp"

.namespace ["KnowHOWAttribute"]
.sub "name"  :subid("13_1299450582.447") :outer("11_1299450582.447")
    .param pmc param_38
.annotate 'line', 14
    .lex "self", param_38
.annotate 'line', 15
    find_lex $P39, "self"
    repr_unbox_str $S40, $P39
.annotate 'line', 14
    .return ($S40)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block52"  :subid("15_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 26
    .const 'Sub' $P1019 = "70_1299450582.447" 
    capture_lex $P1019
    .const 'Sub' $P982 = "68_1299450582.447" 
    capture_lex $P982
    .const 'Sub' $P946 = "66_1299450582.447" 
    capture_lex $P946
    .const 'Sub' $P912 = "65_1299450582.447" 
    capture_lex $P912
    .const 'Sub' $P875 = "64_1299450582.447" 
    capture_lex $P875
    .const 'Sub' $P868 = "63_1299450582.447" 
    capture_lex $P868
    .const 'Sub' $P845 = "61_1299450582.447" 
    capture_lex $P845
    .const 'Sub' $P839 = "60_1299450582.447" 
    capture_lex $P839
    .const 'Sub' $P833 = "59_1299450582.447" 
    capture_lex $P833
    .const 'Sub' $P810 = "57_1299450582.447" 
    capture_lex $P810
    .const 'Sub' $P803 = "56_1299450582.447" 
    capture_lex $P803
    .const 'Sub' $P789 = "55_1299450582.447" 
    capture_lex $P789
    .const 'Sub' $P740 = "52_1299450582.447" 
    capture_lex $P740
    .const 'Sub' $P695 = "49_1299450582.447" 
    capture_lex $P695
    .const 'Sub' $P658 = "46_1299450582.447" 
    capture_lex $P658
    .const 'Sub' $P528 = "41_1299450582.447" 
    capture_lex $P528
    .const 'Sub' $P424 = "37_1299450582.447" 
    capture_lex $P424
    .const 'Sub' $P398 = "36_1299450582.447" 
    capture_lex $P398
    .const 'Sub' $P364 = "34_1299450582.447" 
    capture_lex $P364
    .const 'Sub' $P326 = "32_1299450582.447" 
    capture_lex $P326
    .const 'Sub' $P305 = "31_1299450582.447" 
    capture_lex $P305
    .const 'Sub' $P284 = "30_1299450582.447" 
    capture_lex $P284
    .const 'Sub' $P265 = "29_1299450582.447" 
    capture_lex $P265
    .const 'Sub' $P251 = "28_1299450582.447" 
    capture_lex $P251
    .const 'Sub' $P244 = "27_1299450582.447" 
    capture_lex $P244
    .const 'Sub' $P234 = "26_1299450582.447" 
    capture_lex $P234
    .const 'Sub' $P97 = "19_1299450582.447" 
    capture_lex $P97
    .const 'Sub' $P55 = "16_1299450582.447" 
    capture_lex $P55
    get_global $P54, "$?CLASS"
.annotate 'line', 235
    .const 'Sub' $P55 = "16_1299450582.447" 
    newclosure $P96, $P55
    .lex "compute_c3_mro", $P96
.annotate 'line', 257
    .const 'Sub' $P97 = "19_1299450582.447" 
    newclosure $P233, $P97
    .lex "c3_merge", $P233
.annotate 'line', 181
    find_lex $P656, "compute_c3_mro"
    find_lex $P657, "c3_merge"
.annotate 'line', 441
    .const 'Sub' $P982 = "68_1299450582.447" 
    newclosure $P1017, $P982
.annotate 'line', 26
    .return ($P1017)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "" :load :init :subid("post197") :outer("15_1299450582.447")
.annotate 'line', 26
    get_hll_global $P53, ["NQPClassHOW"], "_block52" 
    .local pmc block
    set block, $P53
    .const 'Sub' $P1019 = "70_1299450582.447" 
    capture_lex $P1019
    $P1019()
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block1018"  :anon :subid("70_1299450582.447") :outer("15_1299450582.447")
.annotate 'line', 26
    get_hll_global $P1020, "KnowHOW"
    $P1021 = $P1020."new_type"("NQPClassHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1021
    set_hll_global "NQPClassHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1022, type_obj
    get_hll_global $P1023, "KnowHOWAttribute"
    $P1024 = $P1023."new"("$!name" :named("name"))
    $P1022."add_attribute"(type_obj, $P1024)
    get_how $P1025, type_obj
    get_hll_global $P1026, "KnowHOWAttribute"
    $P1027 = $P1026."new"("%!attributes" :named("name"))
    $P1025."add_attribute"(type_obj, $P1027)
    get_how $P1028, type_obj
    get_hll_global $P1029, "KnowHOWAttribute"
    $P1030 = $P1029."new"("%!methods" :named("name"))
    $P1028."add_attribute"(type_obj, $P1030)
    get_how $P1031, type_obj
    get_hll_global $P1032, "KnowHOWAttribute"
    $P1033 = $P1032."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1031."add_attribute"(type_obj, $P1033)
    get_how $P1034, type_obj
    get_hll_global $P1035, "KnowHOWAttribute"
    $P1036 = $P1035."new"("@!parents" :named("name"))
    $P1034."add_attribute"(type_obj, $P1036)
    get_how $P1037, type_obj
    get_hll_global $P1038, "KnowHOWAttribute"
    $P1039 = $P1038."new"("@!roles" :named("name"))
    $P1037."add_attribute"(type_obj, $P1039)
    get_how $P1040, type_obj
    get_hll_global $P1041, "KnowHOWAttribute"
    $P1042 = $P1041."new"("@!vtable" :named("name"))
    $P1040."add_attribute"(type_obj, $P1042)
    get_how $P1043, type_obj
    get_hll_global $P1044, "KnowHOWAttribute"
    $P1045 = $P1044."new"("%!method-vtable-slots" :named("name"))
    $P1043."add_attribute"(type_obj, $P1045)
    get_how $P1046, type_obj
    get_hll_global $P1047, "KnowHOWAttribute"
    $P1048 = $P1047."new"("$!composed" :named("name"))
    $P1046."add_attribute"(type_obj, $P1048)
    get_how $P1049, type_obj
    get_hll_global $P1050, "KnowHOWAttribute"
    $P1051 = $P1050."new"("@!mro" :named("name"))
    $P1049."add_attribute"(type_obj, $P1051)
    get_how $P1052, type_obj
    get_hll_global $P1053, "KnowHOWAttribute"
    $P1054 = $P1053."new"("@!done" :named("name"))
    $P1052."add_attribute"(type_obj, $P1054)
    get_how $P1055, type_obj
    get_hll_global $P1056, "KnowHOWAttribute"
    $P1057 = $P1056."new"("%!parrot_vtable_mapping" :named("name"))
    $P1055."add_attribute"(type_obj, $P1057)
    get_how $P1058, type_obj
    .const 'Sub' $P1059 = "26_1299450582.447" 
    $P1058."add_method"(type_obj, "new", $P1059)
    get_how $P1060, type_obj
    .const 'Sub' $P1061 = "27_1299450582.447" 
    $P1060."add_method"(type_obj, "BUILD", $P1061)
    get_how $P1062, type_obj
    .const 'Sub' $P1063 = "28_1299450582.447" 
    $P1062."add_method"(type_obj, "new_type", $P1063)
    get_how $P1064, type_obj
    .const 'Sub' $P1065 = "29_1299450582.447" 
    $P1064."add_method"(type_obj, "add_method", $P1065)
    get_how $P1066, type_obj
    .const 'Sub' $P1067 = "30_1299450582.447" 
    $P1066."add_method"(type_obj, "add_multi_method", $P1067)
    get_how $P1068, type_obj
    .const 'Sub' $P1069 = "31_1299450582.447" 
    $P1068."add_method"(type_obj, "add_attribute", $P1069)
    get_how $P1070, type_obj
    .const 'Sub' $P1071 = "32_1299450582.447" 
    $P1070."add_method"(type_obj, "add_parent", $P1071)
    get_how $P1072, type_obj
    .const 'Sub' $P1073 = "34_1299450582.447" 
    $P1072."add_method"(type_obj, "add_role", $P1073)
    get_how $P1074, type_obj
    .const 'Sub' $P1075 = "36_1299450582.447" 
    $P1074."add_method"(type_obj, "add_parrot_vtable_mapping", $P1075)
    get_how $P1076, type_obj
    .const 'Sub' $P1077 = "37_1299450582.447" 
    $P1076."add_method"(type_obj, "compose", $P1077)
    get_how $P1078, type_obj
    .const 'Sub' $P1079 = "41_1299450582.447" 
    $P1078."add_method"(type_obj, "incorporate_multi_candidates", $P1079)
    get_how $P1080, type_obj
    .const 'Sub' $P1081 = "46_1299450582.447" 
    $P1080."add_method"(type_obj, "publish_type_cache", $P1081)
    get_how $P1082, type_obj
    .const 'Sub' $P1083 = "49_1299450582.447" 
    $P1082."add_method"(type_obj, "publish_method_cache", $P1083)
    get_how $P1084, type_obj
    .const 'Sub' $P1085 = "52_1299450582.447" 
    $P1084."add_method"(type_obj, "publish_parrot_vtable_mapping", $P1085)
    get_how $P1086, type_obj
    .const 'Sub' $P1087 = "55_1299450582.447" 
    $P1086."add_method"(type_obj, "parents", $P1087)
    get_how $P1088, type_obj
    .const 'Sub' $P1089 = "56_1299450582.447" 
    $P1088."add_method"(type_obj, "roles", $P1089)
    get_how $P1090, type_obj
    .const 'Sub' $P1091 = "57_1299450582.447" 
    $P1090."add_method"(type_obj, "methods", $P1091)
    get_how $P1092, type_obj
    .const 'Sub' $P1093 = "59_1299450582.447" 
    $P1092."add_method"(type_obj, "method_table", $P1093)
    get_how $P1094, type_obj
    .const 'Sub' $P1095 = "60_1299450582.447" 
    $P1094."add_method"(type_obj, "name", $P1095)
    get_how $P1096, type_obj
    .const 'Sub' $P1097 = "61_1299450582.447" 
    $P1096."add_method"(type_obj, "attributes", $P1097)
    get_how $P1098, type_obj
    .const 'Sub' $P1099 = "63_1299450582.447" 
    $P1098."add_method"(type_obj, "parrot_vtable_mappings", $P1099)
    get_how $P1100, type_obj
    .const 'Sub' $P1101 = "64_1299450582.447" 
    $P1100."add_method"(type_obj, "isa", $P1101)
    get_how $P1102, type_obj
    .const 'Sub' $P1103 = "65_1299450582.447" 
    $P1102."add_method"(type_obj, "does", $P1103)
    get_how $P1104, type_obj
    .const 'Sub' $P1105 = "66_1299450582.447" 
    $P1104."add_method"(type_obj, "can", $P1105)
    get_how $P1106, type_obj
    .const 'Sub' $P1107 = "68_1299450582.447" 
    $P1106."add_method"(type_obj, "find_method", $P1107)
    get_how $P1108, type_obj
    $P1109 = $P1108."compose"(type_obj)
    .return ($P1109)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compute_c3_mro"  :subid("16_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_58
.annotate 'line', 235
    .const 'Sub' $P70 = "17_1299450582.447" 
    capture_lex $P70
    new $P57, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P57, control_56
    push_eh $P57
    .lex "$class", param_58
.annotate 'line', 236
    $P59 = root_new ['parrot';'ResizablePMCArray']
    .lex "@immediate_parents", $P59
.annotate 'line', 239
    $P60 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P60
.annotate 'line', 236
    find_lex $P61, "$class"
    get_how $P62, $P61
    find_lex $P63, "$class"
    $P64 = $P62."parents"($P63, 1 :named("local"))
    store_lex "@immediate_parents", $P64
    find_lex $P65, "@result"
.annotate 'line', 240
    find_lex $P67, "@immediate_parents"
    set $N68, $P67
    unless $N68, if_66_end
    .const 'Sub' $P70 = "17_1299450582.447" 
    capture_lex $P70
    $P70()
  if_66_end:
.annotate 'line', 252
    find_lex $P91, "@result"
    find_lex $P92, "$class"
    $P91."unshift"($P92)
.annotate 'line', 253
    new $P93, "Exception"
    set $P93['type'], .CONTROL_RETURN
    find_lex $P94, "@result"
    setattribute $P93, 'payload', $P94
    throw $P93
.annotate 'line', 235
    .return ()
  control_56:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P95, exception, "payload"
    .return ($P95)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block69"  :anon :subid("17_1299450582.447") :outer("16_1299450582.447")
.annotate 'line', 240
    .const 'Sub' $P78 = "18_1299450582.447" 
    capture_lex $P78
.annotate 'line', 243
    $P71 = root_new ['parrot';'ResizablePMCArray']
    .lex "@merge_list", $P71
.annotate 'line', 240
    find_lex $P72, "@merge_list"
.annotate 'line', 244
    find_lex $P74, "@immediate_parents"
    defined $I75, $P74
    unless $I75, for_undef_198
    iter $P73, $P74
    new $P85, 'ExceptionHandler'
    set_label $P85, loop84_handler
    $P85."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P85
  loop84_test:
    unless $P73, loop84_done
    shift $P76, $P73
  loop84_redo:
    .const 'Sub' $P78 = "18_1299450582.447" 
    capture_lex $P78
    $P78($P76)
  loop84_next:
    goto loop84_test
  loop84_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P86, exception, 'type'
    eq $P86, .CONTROL_LOOP_NEXT, loop84_next
    eq $P86, .CONTROL_LOOP_REDO, loop84_redo
  loop84_done:
    pop_eh 
  for_undef_198:
.annotate 'line', 247
    find_lex $P87, "@merge_list"
    find_lex $P88, "@immediate_parents"
    $P87."push"($P88)
.annotate 'line', 248
    find_lex $P89, "@merge_list"
    $P90 = "c3_merge"($P89)
    store_lex "@result", $P90
.annotate 'line', 240
    .return ($P90)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block77"  :anon :subid("18_1299450582.447") :outer("17_1299450582.447")
    .param pmc param_79
.annotate 'line', 244
    .lex "$_", param_79
.annotate 'line', 245
    find_lex $P80, "@merge_list"
    find_lex $P81, "$_"
    $P82 = "compute_c3_mro"($P81)
    $P83 = $P80."push"($P82)
.annotate 'line', 244
    .return ($P83)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "c3_merge"  :subid("19_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_100
.annotate 'line', 257
    .const 'Sub' $P193 = "24_1299450582.447" 
    capture_lex $P193
    .const 'Sub' $P115 = "20_1299450582.447" 
    capture_lex $P115
    new $P99, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P99, control_98
    push_eh $P99
    .lex "@merge_list", param_100
.annotate 'line', 258
    $P101 = root_new ['parrot';'ResizablePMCArray']
    .lex "@result", $P101
.annotate 'line', 259
    new $P102, "Undef"
    .lex "$accepted", $P102
.annotate 'line', 260
    new $P103, "Undef"
    .lex "$something_accepted", $P103
.annotate 'line', 261
    new $P104, "Undef"
    .lex "$cand_count", $P104
.annotate 'line', 304
    new $P105, "Undef"
    .lex "$i", $P105
.annotate 'line', 257
    find_lex $P106, "@result"
    find_lex $P107, "$accepted"
.annotate 'line', 260
    new $P108, "Integer"
    assign $P108, 0
    store_lex "$something_accepted", $P108
.annotate 'line', 261
    new $P109, "Integer"
    assign $P109, 0
    store_lex "$cand_count", $P109
.annotate 'line', 264
    find_lex $P111, "@merge_list"
    defined $I112, $P111
    unless $I112, for_undef_199
    iter $P110, $P111
    new $P176, 'ExceptionHandler'
    set_label $P176, loop175_handler
    $P176."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P176
  loop175_test:
    unless $P110, loop175_done
    shift $P113, $P110
  loop175_redo:
    .const 'Sub' $P115 = "20_1299450582.447" 
    capture_lex $P115
    $P115($P113)
  loop175_next:
    goto loop175_test
  loop175_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P177, exception, 'type'
    eq $P177, .CONTROL_LOOP_NEXT, loop175_next
    eq $P177, .CONTROL_LOOP_REDO, loop175_redo
  loop175_done:
    pop_eh 
  for_undef_199:
.annotate 'line', 294
    find_lex $P179, "$cand_count"
    set $N180, $P179
    iseq $I181, $N180, 0.0
    unless $I181, if_178_end
.annotate 'line', 295
    new $P182, "Exception"
    set $P182['type'], .CONTROL_RETURN
    find_lex $P183, "@result"
    setattribute $P182, 'payload', $P183
    throw $P182
  if_178_end:
.annotate 'line', 299
    find_lex $P185, "$something_accepted"
    if $P185, unless_184_end
.annotate 'line', 300
    die "Could not build C3 linearization: ambiguous hierarchy"
  unless_184_end:
.annotate 'line', 304
    new $P186, "Integer"
    assign $P186, 0
    store_lex "$i", $P186
.annotate 'line', 305
    new $P224, 'ExceptionHandler'
    set_label $P224, loop223_handler
    $P224."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P224
  loop223_test:
    find_lex $P187, "$i"
    set $N188, $P187
    find_lex $P189, "@merge_list"
    set $N190, $P189
    islt $I191, $N188, $N190
    unless $I191, loop223_done
  loop223_redo:
    .const 'Sub' $P193 = "24_1299450582.447" 
    capture_lex $P193
    $P193()
  loop223_next:
    goto loop223_test
  loop223_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P225, exception, 'type'
    eq $P225, .CONTROL_LOOP_NEXT, loop223_next
    eq $P225, .CONTROL_LOOP_REDO, loop223_redo
  loop223_done:
    pop_eh 
.annotate 'line', 318
    find_lex $P226, "@merge_list"
    $P227 = "c3_merge"($P226)
    store_lex "@result", $P227
.annotate 'line', 319
    find_lex $P228, "@result"
    find_lex $P229, "$accepted"
    $P228."unshift"($P229)
.annotate 'line', 320
    new $P230, "Exception"
    set $P230['type'], .CONTROL_RETURN
    find_lex $P231, "@result"
    setattribute $P230, 'payload', $P231
    throw $P230
.annotate 'line', 257
    .return ()
  control_98:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P232, exception, "payload"
    .return ($P232)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block114"  :anon :subid("20_1299450582.447") :outer("19_1299450582.447")
    .param pmc param_117
.annotate 'line', 264
    .const 'Sub' $P124 = "21_1299450582.447" 
    capture_lex $P124
.annotate 'line', 265
    $P116 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cand_list", $P116
    .lex "$_", param_117
    find_lex $P118, "$_"
    store_lex "@cand_list", $P118
.annotate 'line', 266
    find_lex $P121, "@cand_list"
    set $N122, $P121
    if $N122, if_120
    new $P119, 'Float'
    set $P119, $N122
    goto if_120_end
  if_120:
    .const 'Sub' $P124 = "21_1299450582.447" 
    capture_lex $P124
    $P174 = $P124()
    set $P119, $P174
  if_120_end:
.annotate 'line', 264
    .return ($P119)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block123"  :anon :subid("21_1299450582.447") :outer("20_1299450582.447")
.annotate 'line', 266
    .const 'Sub' $P137 = "22_1299450582.447" 
    capture_lex $P137
.annotate 'line', 267
    new $P125, "Undef"
    .lex "$rejected", $P125
.annotate 'line', 268
    new $P126, "Undef"
    .lex "$cand_class", $P126
.annotate 'line', 267
    new $P127, "Integer"
    assign $P127, 0
    store_lex "$rejected", $P127
.annotate 'line', 268
    find_lex $P128, "@cand_list"
    unless_null $P128, vivify_200
    $P128 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P129, $P128[0]
    unless_null $P129, vivify_201
    new $P129, "Undef"
  vivify_201:
    store_lex "$cand_class", $P129
.annotate 'line', 269
    find_lex $P130, "$cand_count"
    add $P131, $P130, 1
    store_lex "$cand_count", $P131
.annotate 'line', 270
    find_lex $P133, "@merge_list"
    defined $I134, $P133
    unless $I134, for_undef_202
    iter $P132, $P133
    new $P172, 'ExceptionHandler'
    set_label $P172, loop171_handler
    $P172."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P172
  loop171_test:
    unless $P132, loop171_done
    shift $P135, $P132
  loop171_redo:
    .const 'Sub' $P137 = "22_1299450582.447" 
    capture_lex $P137
    $P137($P135)
  loop171_next:
    goto loop171_test
  loop171_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P173, exception, 'type'
    eq $P173, .CONTROL_LOOP_NEXT, loop171_next
    eq $P173, .CONTROL_LOOP_REDO, loop171_redo
  loop171_done:
    pop_eh 
  for_undef_202:
.annotate 'line', 266
    .return ($P132)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block136"  :anon :subid("22_1299450582.447") :outer("21_1299450582.447")
    .param pmc param_138
.annotate 'line', 270
    .const 'Sub' $P144 = "23_1299450582.447" 
    capture_lex $P144
    .lex "$_", param_138
.annotate 'line', 272
    find_lex $P140, "$_"
    find_lex $P141, "@cand_list"
    issame $I142, $P140, $P141
    if $I142, unless_139_end
    .const 'Sub' $P144 = "23_1299450582.447" 
    capture_lex $P144
    $P144()
  unless_139_end:
.annotate 'line', 284
    find_lex $P167, "$rejected"
    unless $P167, unless_166
    set $P165, $P167
    goto unless_166_end
  unless_166:
.annotate 'line', 285
    find_lex $P168, "$cand_class"
    store_lex "$accepted", $P168
.annotate 'line', 286
    new $P169, "Integer"
    assign $P169, 1
    store_lex "$something_accepted", $P169
.annotate 'line', 287
    set $I170, .CONTROL_LOOP_LAST
    die 0, $I170
  unless_166_end:
.annotate 'line', 270
    .return ($P165)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block143"  :anon :subid("23_1299450582.447") :outer("22_1299450582.447")
.annotate 'line', 274
    new $P145, "Undef"
    .lex "$cur_pos", $P145
    new $P146, "Integer"
    assign $P146, 1
    store_lex "$cur_pos", $P146
.annotate 'line', 275
    new $P163, 'ExceptionHandler'
    set_label $P163, loop162_handler
    $P163."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P163
  loop162_test:
    find_lex $P147, "$cur_pos"
    set $N148, $P147
    find_lex $P149, "$_"
    set $N150, $P149
    isle $I151, $N148, $N150
    unless $I151, loop162_done
  loop162_redo:
.annotate 'line', 276
    find_lex $P153, "$cur_pos"
    set $I154, $P153
    find_lex $P155, "$_"
    unless_null $P155, vivify_203
    $P155 = root_new ['parrot';'ResizablePMCArray']
  vivify_203:
    set $P156, $P155[$I154]
    unless_null $P156, vivify_204
    new $P156, "Undef"
  vivify_204:
    find_lex $P157, "$cand_class"
    issame $I158, $P156, $P157
    unless $I158, if_152_end
.annotate 'line', 277
    new $P159, "Integer"
    assign $P159, 1
    store_lex "$rejected", $P159
  if_152_end:
.annotate 'line', 279
    find_lex $P160, "$cur_pos"
    add $P161, $P160, 1
    store_lex "$cur_pos", $P161
  loop162_next:
.annotate 'line', 275
    goto loop162_test
  loop162_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P164, exception, 'type'
    eq $P164, .CONTROL_LOOP_NEXT, loop162_next
    eq $P164, .CONTROL_LOOP_REDO, loop162_redo
  loop162_done:
    pop_eh 
.annotate 'line', 272
    .return ($I151)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block192"  :anon :subid("24_1299450582.447") :outer("19_1299450582.447")
.annotate 'line', 305
    .const 'Sub' $P204 = "25_1299450582.447" 
    capture_lex $P204
.annotate 'line', 306
    $P194 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_list", $P194
.annotate 'line', 305
    find_lex $P195, "@new_list"
.annotate 'line', 307
    find_lex $P197, "$i"
    set $I198, $P197
    find_lex $P199, "@merge_list"
    unless_null $P199, vivify_205
    $P199 = root_new ['parrot';'ResizablePMCArray']
  vivify_205:
    set $P200, $P199[$I198]
    unless_null $P200, vivify_206
    new $P200, "Undef"
  vivify_206:
    defined $I201, $P200
    unless $I201, for_undef_207
    iter $P196, $P200
    new $P215, 'ExceptionHandler'
    set_label $P215, loop214_handler
    $P215."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P215
  loop214_test:
    unless $P196, loop214_done
    shift $P202, $P196
  loop214_redo:
    .const 'Sub' $P204 = "25_1299450582.447" 
    capture_lex $P204
    $P204($P202)
  loop214_next:
    goto loop214_test
  loop214_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P216, exception, 'type'
    eq $P216, .CONTROL_LOOP_NEXT, loop214_next
    eq $P216, .CONTROL_LOOP_REDO, loop214_redo
  loop214_done:
    pop_eh 
  for_undef_207:
.annotate 'line', 312
    find_lex $P217, "@new_list"
    find_lex $P218, "$i"
    set $I219, $P218
    find_lex $P220, "@merge_list"
    unless_null $P220, vivify_208
    $P220 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@merge_list", $P220
  vivify_208:
    set $P220[$I219], $P217
.annotate 'line', 313
    find_lex $P221, "$i"
    add $P222, $P221, 1
    store_lex "$i", $P222
.annotate 'line', 305
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block203"  :anon :subid("25_1299450582.447") :outer("24_1299450582.447")
    .param pmc param_205
.annotate 'line', 307
    .lex "$_", param_205
.annotate 'line', 308
    find_lex $P208, "$_"
    find_lex $P209, "$accepted"
    issame $I210, $P208, $P209
    unless $I210, unless_207
    new $P206, 'Integer'
    set $P206, $I210
    goto unless_207_end
  unless_207:
.annotate 'line', 309
    find_lex $P211, "@new_list"
    find_lex $P212, "$_"
    $P213 = $P211."push"($P212)
.annotate 'line', 308
    set $P206, $P213
  unless_207_end:
.annotate 'line', 307
    .return ($P206)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "new"  :subid("26_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_235
    .param pmc param_236 :optional :named("name")
    .param int has_param_236 :opt_flag
.annotate 'line', 62
    .lex "self", param_235
    if has_param_236, optparam_209
    new $P237, "Undef"
    set param_236, $P237
  optparam_209:
    .lex "$name", param_236
.annotate 'line', 63
    new $P238, "Undef"
    .lex "$obj", $P238
    find_lex $P239, "self"
    repr_instance_of $P240, $P239
    store_lex "$obj", $P240
.annotate 'line', 64
    find_lex $P241, "$obj"
    find_lex $P242, "$name"
    $P241."BUILD"($P242 :named("name"))
    find_lex $P243, "$obj"
.annotate 'line', 62
    .return ($P243)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "BUILD"  :subid("27_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_245
    .param pmc param_246 :optional :named("name")
    .param int has_param_246 :opt_flag
.annotate 'line', 68
    .lex "self", param_245
    if has_param_246, optparam_210
    new $P247, "Undef"
    set param_246, $P247
  optparam_210:
    .lex "$name", param_246
.annotate 'line', 69
    find_lex $P248, "$name"
    find_lex $P249, "self"
    get_global $P250, "$?CLASS"
    setattribute $P249, $P250, "$!name", $P248
.annotate 'line', 68
    .return ($P248)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "new_type"  :subid("28_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_252
    .param pmc param_253 :optional :named("name")
    .param int has_param_253 :opt_flag
    .param pmc param_255 :optional :named("repr")
    .param int has_param_255 :opt_flag
.annotate 'line', 74
    .lex "self", param_252
    if has_param_253, optparam_211
    new $P254, "String"
    assign $P254, "<anon>"
    set param_253, $P254
  optparam_211:
    .lex "$name", param_253
    if has_param_255, optparam_212
    new $P256, "String"
    assign $P256, "P6opaque"
    set param_255, $P256
  optparam_212:
    .lex "$repr", param_255
.annotate 'line', 75
    new $P257, "Undef"
    .lex "$metaclass", $P257
    find_lex $P258, "self"
    find_lex $P259, "$name"
    $P260 = $P258."new"($P259 :named("name"))
    store_lex "$metaclass", $P260
.annotate 'line', 76
    find_lex $P261, "$metaclass"
    find_lex $P262, "$repr"
    set $S263, $P262
    repr_type_object_for $P264, $P261, $S263
.annotate 'line', 74
    .return ($P264)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "add_method"  :subid("29_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_266
    .param pmc param_267
    .param pmc param_268
    .param pmc param_269
.annotate 'line', 79
    .lex "self", param_266
    .lex "$obj", param_267
    .lex "$name", param_268
    .lex "$code_obj", param_269
.annotate 'line', 80
    find_lex $P271, "$name"
    find_lex $P272, "self"
    get_global $P273, "$?CLASS"
    getattribute $P274, $P272, $P273, "%!methods"
    unless_null $P274, vivify_213
    $P274 = root_new ['parrot';'Hash']
  vivify_213:
    set $P275, $P274[$P271]
    unless_null $P275, vivify_214
    new $P275, "Undef"
  vivify_214:
    unless $P275, if_270_end
.annotate 'line', 81
    new $P276, "String"
    assign $P276, "This class already has a method named "
    find_lex $P277, "$name"
    concat $P278, $P276, $P277
    die $P278
  if_270_end:
.annotate 'line', 83
    find_lex $P279, "$code_obj"
    find_lex $P280, "$name"
    find_lex $P281, "self"
    get_global $P282, "$?CLASS"
    getattribute $P283, $P281, $P282, "%!methods"
    unless_null $P283, vivify_215
    $P283 = root_new ['parrot';'Hash']
    setattribute $P281, $P282, "%!methods", $P283
  vivify_215:
    set $P283[$P280], $P279
.annotate 'line', 79
    .return ($P279)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "add_multi_method"  :subid("30_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_285
    .param pmc param_286
    .param pmc param_287
    .param pmc param_288
.annotate 'line', 86
    .lex "self", param_285
    .lex "$obj", param_286
    .lex "$name", param_287
    .lex "$code_obj", param_288
.annotate 'line', 92
    $P289 = root_new ['parrot';'Hash']
    .lex "%todo", $P289
.annotate 'line', 86
    find_lex $P290, "%todo"
.annotate 'line', 93
    find_lex $P291, "$name"
    find_lex $P292, "%todo"
    unless_null $P292, vivify_216
    $P292 = root_new ['parrot';'Hash']
    store_lex "%todo", $P292
  vivify_216:
    set $P292["name"], $P291
.annotate 'line', 94
    find_lex $P293, "$code_obj"
    find_lex $P294, "%todo"
    unless_null $P294, vivify_217
    $P294 = root_new ['parrot';'Hash']
    store_lex "%todo", $P294
  vivify_217:
    set $P294["code"], $P293
.annotate 'line', 95
    find_lex $P295, "%todo"
    find_lex $P296, "self"
    get_global $P297, "$?CLASS"
    getattribute $P298, $P296, $P297, "@!multi_methods_to_incorporate"
    unless_null $P298, vivify_218
    $P298 = root_new ['parrot';'ResizablePMCArray']
  vivify_218:
    set $N299, $P298
    set $I300, $N299
    find_lex $P301, "self"
    get_global $P302, "$?CLASS"
    getattribute $P303, $P301, $P302, "@!multi_methods_to_incorporate"
    unless_null $P303, vivify_219
    $P303 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P301, $P302, "@!multi_methods_to_incorporate", $P303
  vivify_219:
    set $P303[$I300], $P295
    find_lex $P304, "$code_obj"
.annotate 'line', 86
    .return ($P304)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "add_attribute"  :subid("31_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_306
    .param pmc param_307
    .param pmc param_308
.annotate 'line', 99
    .lex "self", param_306
    .lex "$obj", param_307
    .lex "$meta_attr", param_308
.annotate 'line', 100
    new $P309, "Undef"
    .lex "$name", $P309
    find_lex $P310, "$meta_attr"
    $P311 = $P310."name"()
    store_lex "$name", $P311
.annotate 'line', 101
    find_lex $P313, "$name"
    find_lex $P314, "self"
    get_global $P315, "$?CLASS"
    getattribute $P316, $P314, $P315, "%!attributes"
    unless_null $P316, vivify_220
    $P316 = root_new ['parrot';'Hash']
  vivify_220:
    set $P317, $P316[$P313]
    unless_null $P317, vivify_221
    new $P317, "Undef"
  vivify_221:
    unless $P317, if_312_end
.annotate 'line', 102
    new $P318, "String"
    assign $P318, "This class already has an attribute named "
    find_lex $P319, "$name"
    concat $P320, $P318, $P319
    die $P320
  if_312_end:
.annotate 'line', 104
    find_lex $P321, "$meta_attr"
    find_lex $P322, "$name"
    find_lex $P323, "self"
    get_global $P324, "$?CLASS"
    getattribute $P325, $P323, $P324, "%!attributes"
    unless_null $P325, vivify_222
    $P325 = root_new ['parrot';'Hash']
    setattribute $P323, $P324, "%!attributes", $P325
  vivify_222:
    set $P325[$P322], $P321
.annotate 'line', 99
    .return ($P321)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_parent"  :subid("32_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_327
    .param pmc param_328
    .param pmc param_329
.annotate 'line', 107
    .const 'Sub' $P341 = "33_1299450582.447" 
    capture_lex $P341
    .lex "self", param_327
    .lex "$obj", param_328
    .lex "$parent", param_329
.annotate 'line', 108
    find_lex $P331, "self"
    get_global $P332, "$?CLASS"
    getattribute $P333, $P331, $P332, "$!composed"
    unless_null $P333, vivify_223
    new $P333, "Undef"
  vivify_223:
    unless $P333, if_330_end
.annotate 'line', 109
    die "NQPClassHOW does not support adding parents after being composed."
  if_330_end:
.annotate 'line', 111
    find_lex $P335, "self"
    get_global $P336, "$?CLASS"
    getattribute $P337, $P335, $P336, "@!parents"
    unless_null $P337, vivify_224
    $P337 = root_new ['parrot';'ResizablePMCArray']
  vivify_224:
    defined $I338, $P337
    unless $I338, for_undef_225
    iter $P334, $P337
    new $P353, 'ExceptionHandler'
    set_label $P353, loop352_handler
    $P353."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P353
  loop352_test:
    unless $P334, loop352_done
    shift $P339, $P334
  loop352_redo:
    .const 'Sub' $P341 = "33_1299450582.447" 
    capture_lex $P341
    $P341($P339)
  loop352_next:
    goto loop352_test
  loop352_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P354, exception, 'type'
    eq $P354, .CONTROL_LOOP_NEXT, loop352_next
    eq $P354, .CONTROL_LOOP_REDO, loop352_redo
  loop352_done:
    pop_eh 
  for_undef_225:
.annotate 'line', 116
    find_lex $P355, "$parent"
    find_lex $P356, "self"
    get_global $P357, "$?CLASS"
    getattribute $P358, $P356, $P357, "@!parents"
    unless_null $P358, vivify_226
    $P358 = root_new ['parrot';'ResizablePMCArray']
  vivify_226:
    set $N359, $P358
    set $I360, $N359
    find_lex $P361, "self"
    get_global $P362, "$?CLASS"
    getattribute $P363, $P361, $P362, "@!parents"
    unless_null $P363, vivify_227
    $P363 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P361, $P362, "@!parents", $P363
  vivify_227:
    set $P363[$I360], $P355
.annotate 'line', 107
    .return ($P355)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block340"  :anon :subid("33_1299450582.447") :outer("32_1299450582.447")
    .param pmc param_342
.annotate 'line', 111
    .lex "$_", param_342
.annotate 'line', 112
    find_lex $P345, "$_"
    find_lex $P346, "$parent"
    issame $I347, $P345, $P346
    if $I347, if_344
    new $P343, 'Integer'
    set $P343, $I347
    goto if_344_end
  if_344:
.annotate 'line', 113
    new $P348, "String"
    assign $P348, "Already have "
    find_lex $P349, "$parent"
    concat $P350, $P348, $P349
    concat $P351, $P350, " as a parent class."
    die $P351
  if_344_end:
.annotate 'line', 111
    .return ($P343)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "add_role"  :subid("34_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_365
    .param pmc param_366
    .param pmc param_367
.annotate 'line', 119
    .const 'Sub' $P375 = "35_1299450582.447" 
    capture_lex $P375
    .lex "self", param_365
    .lex "$obj", param_366
    .lex "$role", param_367
.annotate 'line', 120
    find_lex $P369, "self"
    get_global $P370, "$?CLASS"
    getattribute $P371, $P369, $P370, "@!roles"
    unless_null $P371, vivify_228
    $P371 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    defined $I372, $P371
    unless $I372, for_undef_229
    iter $P368, $P371
    new $P387, 'ExceptionHandler'
    set_label $P387, loop386_handler
    $P387."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P387
  loop386_test:
    unless $P368, loop386_done
    shift $P373, $P368
  loop386_redo:
    .const 'Sub' $P375 = "35_1299450582.447" 
    capture_lex $P375
    $P375($P373)
  loop386_next:
    goto loop386_test
  loop386_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P388, exception, 'type'
    eq $P388, .CONTROL_LOOP_NEXT, loop386_next
    eq $P388, .CONTROL_LOOP_REDO, loop386_redo
  loop386_done:
    pop_eh 
  for_undef_229:
.annotate 'line', 125
    find_lex $P389, "$role"
    find_lex $P390, "self"
    get_global $P391, "$?CLASS"
    getattribute $P392, $P390, $P391, "@!roles"
    unless_null $P392, vivify_230
    $P392 = root_new ['parrot';'ResizablePMCArray']
  vivify_230:
    set $N393, $P392
    set $I394, $N393
    find_lex $P395, "self"
    get_global $P396, "$?CLASS"
    getattribute $P397, $P395, $P396, "@!roles"
    unless_null $P397, vivify_231
    $P397 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P395, $P396, "@!roles", $P397
  vivify_231:
    set $P397[$I394], $P389
.annotate 'line', 119
    .return ($P389)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block374"  :anon :subid("35_1299450582.447") :outer("34_1299450582.447")
    .param pmc param_376
.annotate 'line', 120
    .lex "$_", param_376
.annotate 'line', 121
    find_lex $P379, "$_"
    find_lex $P380, "$role"
    issame $I381, $P379, $P380
    if $I381, if_378
    new $P377, 'Integer'
    set $P377, $I381
    goto if_378_end
  if_378:
.annotate 'line', 122
    new $P382, "String"
    assign $P382, "The role "
    find_lex $P383, "$role"
    concat $P384, $P382, $P383
    concat $P385, $P384, " has already been added."
    die $P385
  if_378_end:
.annotate 'line', 120
    .return ($P377)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "add_parrot_vtable_mapping"  :subid("36_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_399
    .param pmc param_400
    .param pmc param_401
    .param pmc param_402
.annotate 'line', 128
    .lex "self", param_399
    .lex "$obj", param_400
    .lex "$name", param_401
    .lex "$meth", param_402
.annotate 'line', 129
    find_lex $P404, "$name"
    find_lex $P405, "self"
    get_global $P406, "$?CLASS"
    getattribute $P407, $P405, $P406, "%!parrot_vtable_mapping"
    unless_null $P407, vivify_232
    $P407 = root_new ['parrot';'Hash']
  vivify_232:
    set $P408, $P407[$P404]
    unless_null $P408, vivify_233
    new $P408, "Undef"
  vivify_233:
    defined $I409, $P408
    unless $I409, if_403_end
.annotate 'line', 130
    new $P410, "String"
    assign $P410, "Class '"
    find_lex $P411, "self"
    get_global $P412, "$?CLASS"
    getattribute $P413, $P411, $P412, "$!name"
    unless_null $P413, vivify_234
    new $P413, "Undef"
  vivify_234:
    concat $P414, $P410, $P413
    concat $P415, $P414, "' already has a Parrot v-table override for '"
    find_lex $P416, "$name"
    concat $P417, $P415, $P416
.annotate 'line', 131
    concat $P418, $P417, "'"
.annotate 'line', 132
    die $P418
  if_403_end:
.annotate 'line', 134
    find_lex $P419, "$meth"
    find_lex $P420, "$name"
    find_lex $P421, "self"
    get_global $P422, "$?CLASS"
    getattribute $P423, $P421, $P422, "%!parrot_vtable_mapping"
    unless_null $P423, vivify_235
    $P423 = root_new ['parrot';'Hash']
    setattribute $P421, $P422, "%!parrot_vtable_mapping", $P423
  vivify_235:
    set $P423[$P420], $P419
.annotate 'line', 128
    .return ($P419)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("37_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_425
    .param pmc param_426
.annotate 'line', 137
    .const 'Sub' $P513 = "40_1299450582.447" 
    capture_lex $P513
    .const 'Sub' $P432 = "38_1299450582.447" 
    capture_lex $P432
    .lex "self", param_425
    .lex "$obj", param_426
.annotate 'line', 141
    find_lex $P428, "self"
    get_global $P429, "$?CLASS"
    getattribute $P430, $P428, $P429, "@!roles"
    unless_null $P430, vivify_236
    $P430 = root_new ['parrot';'ResizablePMCArray']
  vivify_236:
    unless $P430, if_427_end
    .const 'Sub' $P432 = "38_1299450582.447" 
    capture_lex $P432
    $P432()
  if_427_end:
.annotate 'line', 154
    find_lex $P480, "self"
    get_global $P481, "$?CLASS"
    getattribute $P482, $P480, $P481, "@!parents"
    unless_null $P482, vivify_243
    $P482 = root_new ['parrot';'ResizablePMCArray']
  vivify_243:
    set $N483, $P482
    iseq $I484, $N483, 0.0
    if $I484, if_479
    new $P478, 'Integer'
    set $P478, $I484
    goto if_479_end
  if_479:
    find_lex $P485, "self"
    get_global $P486, "$?CLASS"
    getattribute $P487, $P485, $P486, "$!name"
    unless_null $P487, vivify_244
    new $P487, "Undef"
  vivify_244:
    set $S488, $P487
    isne $I489, $S488, "NQPMu"
    new $P478, 'Integer'
    set $P478, $I489
  if_479_end:
    unless $P478, if_477_end
.annotate 'line', 155
    find_lex $P490, "self"
    find_lex $P491, "$obj"
    get_hll_global $P492, "NQPMu"
    $P490."add_parent"($P491, $P492)
  if_477_end:
.annotate 'line', 160
    find_lex $P494, "self"
    get_global $P495, "$?CLASS"
    getattribute $P496, $P494, $P495, "$!composed"
    unless_null $P496, vivify_245
    new $P496, "Undef"
  vivify_245:
    if $P496, unless_493_end
.annotate 'line', 161
    find_lex $P497, "$obj"
    $P498 = "compute_c3_mro"($P497)
    find_lex $P499, "self"
    get_global $P500, "$?CLASS"
    setattribute $P499, $P500, "@!mro", $P498
.annotate 'line', 162
    new $P501, "Integer"
    assign $P501, 1
    find_lex $P502, "self"
    get_global $P503, "$?CLASS"
    setattribute $P502, $P503, "$!composed", $P501
  unless_493_end:
.annotate 'line', 166
    find_lex $P504, "self"
    find_lex $P505, "$obj"
    $P504."incorporate_multi_candidates"($P505)
.annotate 'line', 169
    find_lex $P507, "self"
    find_lex $P508, "$obj"
    $P509 = $P507."attributes"($P508, "0" :named("local"))
    defined $I510, $P509
    unless $I510, for_undef_246
    iter $P506, $P509
    new $P519, 'ExceptionHandler'
    set_label $P519, loop518_handler
    $P519."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P519
  loop518_test:
    unless $P506, loop518_done
    shift $P511, $P506
  loop518_redo:
    .const 'Sub' $P513 = "40_1299450582.447" 
    capture_lex $P513
    $P513($P511)
  loop518_next:
    goto loop518_test
  loop518_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P520, exception, 'type'
    eq $P520, .CONTROL_LOOP_NEXT, loop518_next
    eq $P520, .CONTROL_LOOP_REDO, loop518_redo
  loop518_done:
    pop_eh 
  for_undef_246:
.annotate 'line', 172
    find_lex $P521, "self"
    find_lex $P522, "$obj"
    $P521."publish_type_cache"($P522)
.annotate 'line', 173
    find_lex $P523, "self"
    find_lex $P524, "$obj"
    $P523."publish_method_cache"($P524)
.annotate 'line', 176
    find_lex $P525, "self"
    find_lex $P526, "$obj"
    $P525."publish_parrot_vtable_mapping"($P526)
    find_lex $P527, "$obj"
.annotate 'line', 137
    .return ($P527)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block431"  :anon :subid("38_1299450582.447") :outer("37_1299450582.447")
.annotate 'line', 141
    .const 'Sub' $P442 = "39_1299450582.447" 
    capture_lex $P442
.annotate 'line', 142
    $P433 = root_new ['parrot';'ResizablePMCArray']
    .lex "@instantiated_roles", $P433
.annotate 'line', 141
    find_lex $P434, "@instantiated_roles"
.annotate 'line', 143
    find_lex $P436, "self"
    get_global $P437, "$?CLASS"
    getattribute $P438, $P436, $P437, "@!roles"
    unless_null $P438, vivify_237
    $P438 = root_new ['parrot';'ResizablePMCArray']
  vivify_237:
    defined $I439, $P438
    unless $I439, for_undef_238
    iter $P435, $P438
    new $P471, 'ExceptionHandler'
    set_label $P471, loop470_handler
    $P471."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P471
  loop470_test:
    unless $P435, loop470_done
    shift $P440, $P435
  loop470_redo:
    .const 'Sub' $P442 = "39_1299450582.447" 
    capture_lex $P442
    $P442($P440)
  loop470_next:
    goto loop470_test
  loop470_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P472, exception, 'type'
    eq $P472, .CONTROL_LOOP_NEXT, loop470_next
    eq $P472, .CONTROL_LOOP_REDO, loop470_redo
  loop470_done:
    pop_eh 
  for_undef_238:
.annotate 'line', 149
    get_hll_global $P473, "RoleToClassApplier"
    find_lex $P474, "$obj"
    find_lex $P475, "@instantiated_roles"
    $P476 = $P473."apply"($P474, $P475)
.annotate 'line', 141
    .return ($P476)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block441"  :anon :subid("39_1299450582.447") :outer("38_1299450582.447")
    .param pmc param_444
.annotate 'line', 144
    new $P443, "Undef"
    .lex "$ins", $P443
    .lex "$_", param_444
    find_lex $P445, "$_"
    get_how $P446, $P445
    find_lex $P447, "$_"
    find_lex $P448, "$obj"
    $P449 = $P446."instantiate"($P447, $P448)
    store_lex "$ins", $P449
.annotate 'line', 145
    find_lex $P450, "@instantiated_roles"
    find_lex $P451, "$ins"
    $P450."push"($P451)
.annotate 'line', 146
    find_lex $P452, "$_"
    find_lex $P453, "self"
    get_global $P454, "$?CLASS"
    getattribute $P455, $P453, $P454, "@!done"
    unless_null $P455, vivify_239
    $P455 = root_new ['parrot';'ResizablePMCArray']
  vivify_239:
    set $N456, $P455
    set $I457, $N456
    find_lex $P458, "self"
    get_global $P459, "$?CLASS"
    getattribute $P460, $P458, $P459, "@!done"
    unless_null $P460, vivify_240
    $P460 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P458, $P459, "@!done", $P460
  vivify_240:
    set $P460[$I457], $P452
.annotate 'line', 147
    find_lex $P461, "$ins"
    find_lex $P462, "self"
    get_global $P463, "$?CLASS"
    getattribute $P464, $P462, $P463, "@!done"
    unless_null $P464, vivify_241
    $P464 = root_new ['parrot';'ResizablePMCArray']
  vivify_241:
    set $N465, $P464
    set $I466, $N465
    find_lex $P467, "self"
    get_global $P468, "$?CLASS"
    getattribute $P469, $P467, $P468, "@!done"
    unless_null $P469, vivify_242
    $P469 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P467, $P468, "@!done", $P469
  vivify_242:
    set $P469[$I466], $P461
.annotate 'line', 143
    .return ($P461)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block512"  :anon :subid("40_1299450582.447") :outer("37_1299450582.447")
    .param pmc param_514
.annotate 'line', 169
    .lex "$_", param_514
    find_lex $P515, "$_"
    find_lex $P516, "$obj"
    $P517 = $P515."compose"($P516)
    .return ($P517)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "incorporate_multi_candidates"  :subid("41_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_529
    .param pmc param_530
.annotate 'line', 181
    .const 'Sub' $P545 = "42_1299450582.447" 
    capture_lex $P545
    .lex "self", param_529
    .lex "$obj", param_530
.annotate 'line', 182
    new $P531, "Undef"
    .lex "$num_todo", $P531
.annotate 'line', 183
    new $P532, "Undef"
    .lex "$i", $P532
.annotate 'line', 182
    find_lex $P533, "self"
    get_global $P534, "$?CLASS"
    getattribute $P535, $P533, $P534, "@!multi_methods_to_incorporate"
    unless_null $P535, vivify_247
    $P535 = root_new ['parrot';'ResizablePMCArray']
  vivify_247:
    set $N536, $P535
    new $P537, 'Float'
    set $P537, $N536
    store_lex "$num_todo", $P537
.annotate 'line', 183
    new $P538, "Integer"
    assign $P538, 0
    store_lex "$i", $P538
.annotate 'line', 184
    new $P654, 'ExceptionHandler'
    set_label $P654, loop653_handler
    $P654."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P654
  loop653_test:
    find_lex $P539, "$i"
    set $N540, $P539
    find_lex $P541, "$num_todo"
    set $N542, $P541
    isne $I543, $N540, $N542
    unless $I543, loop653_done
  loop653_redo:
    .const 'Sub' $P545 = "42_1299450582.447" 
    capture_lex $P545
    $P545()
  loop653_next:
    goto loop653_test
  loop653_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P655, exception, 'type'
    eq $P655, .CONTROL_LOOP_NEXT, loop653_next
    eq $P655, .CONTROL_LOOP_REDO, loop653_redo
  loop653_done:
    pop_eh 
.annotate 'line', 181
    .return ($I543)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block544"  :anon :subid("42_1299450582.447") :outer("41_1299450582.447")
.annotate 'line', 184
    .const 'Sub' $P581 = "43_1299450582.447" 
    capture_lex $P581
.annotate 'line', 186
    new $P546, "Undef"
    .lex "$name", $P546
.annotate 'line', 187
    new $P547, "Undef"
    .lex "$code", $P547
.annotate 'line', 191
    new $P548, "Undef"
    .lex "$dispatcher", $P548
.annotate 'line', 186
    find_lex $P549, "$i"
    set $I550, $P549
    find_lex $P551, "self"
    get_global $P552, "$?CLASS"
    getattribute $P553, $P551, $P552, "@!multi_methods_to_incorporate"
    unless_null $P553, vivify_248
    $P553 = root_new ['parrot';'ResizablePMCArray']
  vivify_248:
    set $P554, $P553[$I550]
    unless_null $P554, vivify_249
    $P554 = root_new ['parrot';'Hash']
  vivify_249:
    set $P555, $P554["name"]
    unless_null $P555, vivify_250
    new $P555, "Undef"
  vivify_250:
    store_lex "$name", $P555
.annotate 'line', 187
    find_lex $P556, "$i"
    set $I557, $P556
    find_lex $P558, "self"
    get_global $P559, "$?CLASS"
    getattribute $P560, $P558, $P559, "@!multi_methods_to_incorporate"
    unless_null $P560, vivify_251
    $P560 = root_new ['parrot';'ResizablePMCArray']
  vivify_251:
    set $P561, $P560[$I557]
    unless_null $P561, vivify_252
    $P561 = root_new ['parrot';'Hash']
  vivify_252:
    set $P562, $P561["code"]
    unless_null $P562, vivify_253
    new $P562, "Undef"
  vivify_253:
    store_lex "$code", $P562
.annotate 'line', 191
    find_lex $P563, "$name"
    find_lex $P564, "self"
    get_global $P565, "$?CLASS"
    getattribute $P566, $P564, $P565, "%!methods"
    unless_null $P566, vivify_254
    $P566 = root_new ['parrot';'Hash']
  vivify_254:
    set $P567, $P566[$P563]
    unless_null $P567, vivify_255
    new $P567, "Undef"
  vivify_255:
    store_lex "$dispatcher", $P567
.annotate 'line', 192
    find_lex $P569, "$dispatcher"
    defined $I570, $P569
    if $I570, if_568
.annotate 'line', 202
    .const 'Sub' $P581 = "43_1299450582.447" 
    capture_lex $P581
    $P581()
    goto if_568_end
  if_568:
.annotate 'line', 195
    find_lex $P572, "$dispatcher"
    is_dispatcher $I573, $P572
    if $I573, if_571
.annotate 'line', 199
    new $P576, 'String'
    set $P576, "Cannot have a multi candidate for "
    find_lex $P577, "$name"
    concat $P578, $P576, $P577
    concat $P579, $P578, " when an only method is also in the class"
    die $P579
.annotate 'line', 198
    goto if_571_end
  if_571:
.annotate 'line', 196
    find_lex $P574, "$dispatcher"
    find_lex $P575, "$code"
    push_dispatchee $P574, $P575
  if_571_end:
  if_568_end:
.annotate 'line', 230
    find_lex $P651, "$i"
    add $P652, $P651, 1
    store_lex "$i", $P652
.annotate 'line', 184
    .return ($P652)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block580"  :anon :subid("43_1299450582.447") :outer("42_1299450582.447")
.annotate 'line', 202
    .const 'Sub' $P598 = "44_1299450582.447" 
    capture_lex $P598
.annotate 'line', 204
    new $P582, "Undef"
    .lex "$j", $P582
.annotate 'line', 205
    new $P583, "Undef"
    .lex "$found", $P583
.annotate 'line', 204
    new $P584, "Integer"
    assign $P584, 1
    store_lex "$j", $P584
.annotate 'line', 205
    new $P585, "Integer"
    assign $P585, 0
    store_lex "$found", $P585
.annotate 'line', 206
    new $P642, 'ExceptionHandler'
    set_label $P642, loop641_handler
    $P642."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P642
  loop641_test:
    find_lex $P588, "$j"
    set $N589, $P588
    find_lex $P590, "self"
    get_global $P591, "$?CLASS"
    getattribute $P592, $P590, $P591, "@!mro"
    unless_null $P592, vivify_256
    $P592 = root_new ['parrot';'ResizablePMCArray']
  vivify_256:
    set $N593, $P592
    isne $I594, $N589, $N593
    if $I594, if_587
    new $P586, 'Integer'
    set $P586, $I594
    goto if_587_end
  if_587:
    find_lex $P595, "$found"
    isfalse $I596, $P595
    new $P586, 'Integer'
    set $P586, $I596
  if_587_end:
    unless $P586, loop641_done
  loop641_redo:
    .const 'Sub' $P598 = "44_1299450582.447" 
    capture_lex $P598
    $P598()
  loop641_next:
    goto loop641_test
  loop641_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P643, exception, 'type'
    eq $P643, .CONTROL_LOOP_NEXT, loop641_next
    eq $P643, .CONTROL_LOOP_REDO, loop641_redo
  loop641_done:
    pop_eh 
.annotate 'line', 226
    find_lex $P646, "$found"
    unless $P646, unless_645
    set $P644, $P646
    goto unless_645_end
  unless_645:
.annotate 'line', 227
    new $P647, 'String'
    set $P647, "Could not find a proto for multi "
    find_lex $P648, "$name"
    concat $P649, $P647, $P648
    concat $P650, $P649, ", and proto generation is NYI"
    die $P650
  unless_645_end:
.annotate 'line', 202
    .return ($P644)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block597"  :anon :subid("44_1299450582.447") :outer("43_1299450582.447")
.annotate 'line', 206
    .const 'Sub' $P622 = "45_1299450582.447" 
    capture_lex $P622
.annotate 'line', 207
    new $P599, "Undef"
    .lex "$parent", $P599
.annotate 'line', 208
    $P600 = root_new ['parrot';'Hash']
    .lex "%meths", $P600
.annotate 'line', 209
    new $P601, "Undef"
    .lex "$dispatcher", $P601
.annotate 'line', 207
    find_lex $P602, "$j"
    set $I603, $P602
    find_lex $P604, "self"
    get_global $P605, "$?CLASS"
    getattribute $P606, $P604, $P605, "@!mro"
    unless_null $P606, vivify_257
    $P606 = root_new ['parrot';'ResizablePMCArray']
  vivify_257:
    set $P607, $P606[$I603]
    unless_null $P607, vivify_258
    new $P607, "Undef"
  vivify_258:
    store_lex "$parent", $P607
.annotate 'line', 208
    find_lex $P608, "$parent"
    get_how $P609, $P608
    find_lex $P610, "$parent"
    $P611 = $P609."method_table"($P610)
    store_lex "%meths", $P611
.annotate 'line', 209
    find_lex $P612, "$name"
    find_lex $P613, "%meths"
    unless_null $P613, vivify_259
    $P613 = root_new ['parrot';'Hash']
  vivify_259:
    set $P614, $P613[$P612]
    unless_null $P614, vivify_260
    new $P614, "Undef"
  vivify_260:
    store_lex "$dispatcher", $P614
.annotate 'line', 210
    find_lex $P616, "$dispatcher"
    defined $I617, $P616
    unless $I617, if_615_end
.annotate 'line', 213
    find_lex $P619, "$dispatcher"
    is_dispatcher $I620, $P619
    if $I620, if_618
.annotate 'line', 221
    new $P635, 'String'
    set $P635, "Could not find a proto for multi "
    find_lex $P636, "$name"
    concat $P637, $P635, $P636
    concat $P638, $P637, " (it may exist, but an only is hiding it if so)"
    die $P638
.annotate 'line', 220
    goto if_618_end
  if_618:
.annotate 'line', 213
    .const 'Sub' $P622 = "45_1299450582.447" 
    capture_lex $P622
    $P622()
  if_618_end:
  if_615_end:
.annotate 'line', 224
    find_lex $P639, "$j"
    add $P640, $P639, 1
    store_lex "$j", $P640
.annotate 'line', 206
    .return ($P640)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block621"  :anon :subid("45_1299450582.447") :outer("44_1299450582.447")
.annotate 'line', 215
    $P623 = root_new ['parrot';'ResizablePMCArray']
    .lex "@new_dispatchees", $P623
.annotate 'line', 213
    find_lex $P624, "@new_dispatchees"
.annotate 'line', 216
    find_lex $P625, "$code"
    find_lex $P626, "@new_dispatchees"
    unless_null $P626, vivify_261
    $P626 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@new_dispatchees", $P626
  vivify_261:
    set $P626[0], $P625
.annotate 'line', 217
    find_lex $P627, "$dispatcher"
    find_lex $P628, "@new_dispatchees"
    create_dispatch_and_add_candidates $P629, $P627, $P628
    find_lex $P630, "$name"
    find_lex $P631, "self"
    get_global $P632, "$?CLASS"
    getattribute $P633, $P631, $P632, "%!methods"
    unless_null $P633, vivify_262
    $P633 = root_new ['parrot';'Hash']
    setattribute $P631, $P632, "%!methods", $P633
  vivify_262:
    set $P633[$P630], $P629
.annotate 'line', 218
    new $P634, "Integer"
    assign $P634, 1
    store_lex "$found", $P634
.annotate 'line', 213
    .return ($P634)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_type_cache"  :subid("46_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_659
    .param pmc param_660
.annotate 'line', 323
    .const 'Sub' $P685 = "48_1299450582.447" 
    capture_lex $P685
    .const 'Sub' $P670 = "47_1299450582.447" 
    capture_lex $P670
    .lex "self", param_659
    .lex "$obj", param_660
.annotate 'line', 324
    $P661 = root_new ['parrot';'ResizablePMCArray']
    .lex "@tc", $P661
.annotate 'line', 323
    find_lex $P662, "@tc"
.annotate 'line', 325
    find_lex $P664, "self"
    get_global $P665, "$?CLASS"
    getattribute $P666, $P664, $P665, "@!mro"
    unless_null $P666, vivify_263
    $P666 = root_new ['parrot';'ResizablePMCArray']
  vivify_263:
    defined $I667, $P666
    unless $I667, for_undef_264
    iter $P663, $P666
    new $P676, 'ExceptionHandler'
    set_label $P676, loop675_handler
    $P676."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P676
  loop675_test:
    unless $P663, loop675_done
    shift $P668, $P663
  loop675_redo:
    .const 'Sub' $P670 = "47_1299450582.447" 
    capture_lex $P670
    $P670($P668)
  loop675_next:
    goto loop675_test
  loop675_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P677, exception, 'type'
    eq $P677, .CONTROL_LOOP_NEXT, loop675_next
    eq $P677, .CONTROL_LOOP_REDO, loop675_redo
  loop675_done:
    pop_eh 
  for_undef_264:
.annotate 'line', 326
    find_lex $P679, "self"
    get_global $P680, "$?CLASS"
    getattribute $P681, $P679, $P680, "@!done"
    unless_null $P681, vivify_265
    $P681 = root_new ['parrot';'ResizablePMCArray']
  vivify_265:
    defined $I682, $P681
    unless $I682, for_undef_266
    iter $P678, $P681
    new $P691, 'ExceptionHandler'
    set_label $P691, loop690_handler
    $P691."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P691
  loop690_test:
    unless $P678, loop690_done
    shift $P683, $P678
  loop690_redo:
    .const 'Sub' $P685 = "48_1299450582.447" 
    capture_lex $P685
    $P685($P683)
  loop690_next:
    goto loop690_test
  loop690_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P692, exception, 'type'
    eq $P692, .CONTROL_LOOP_NEXT, loop690_next
    eq $P692, .CONTROL_LOOP_REDO, loop690_redo
  loop690_done:
    pop_eh 
  for_undef_266:
.annotate 'line', 327
    find_lex $P693, "$obj"
    find_lex $P694, "@tc"
    publish_type_check_cache $P693, $P694
.annotate 'line', 323
    .return ()
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block669"  :anon :subid("47_1299450582.447") :outer("46_1299450582.447")
    .param pmc param_671
.annotate 'line', 325
    .lex "$_", param_671
    find_lex $P672, "@tc"
    find_lex $P673, "$_"
    $P674 = $P672."push"($P673)
    .return ($P674)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block684"  :anon :subid("48_1299450582.447") :outer("46_1299450582.447")
    .param pmc param_686
.annotate 'line', 326
    .lex "$_", param_686
    find_lex $P687, "@tc"
    find_lex $P688, "$_"
    $P689 = $P687."push"($P688)
    .return ($P689)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_method_cache"  :subid("49_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_696
    .param pmc param_697
.annotate 'line', 330
    .const 'Sub' $P707 = "50_1299450582.447" 
    capture_lex $P707
    .lex "self", param_696
    .lex "$obj", param_697
.annotate 'line', 333
    $P698 = root_new ['parrot';'Hash']
    .lex "%cache", $P698
.annotate 'line', 330
    find_lex $P699, "%cache"
.annotate 'line', 334
    find_lex $P701, "self"
    get_global $P702, "$?CLASS"
    getattribute $P703, $P701, $P702, "@!mro"
    unless_null $P703, vivify_267
    $P703 = root_new ['parrot';'ResizablePMCArray']
  vivify_267:
    defined $I704, $P703
    unless $I704, for_undef_268
    iter $P700, $P703
    new $P736, 'ExceptionHandler'
    set_label $P736, loop735_handler
    $P736."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P736
  loop735_test:
    unless $P700, loop735_done
    shift $P705, $P700
  loop735_redo:
    .const 'Sub' $P707 = "50_1299450582.447" 
    capture_lex $P707
    $P707($P705)
  loop735_next:
    goto loop735_test
  loop735_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P737, exception, 'type'
    eq $P737, .CONTROL_LOOP_NEXT, loop735_next
    eq $P737, .CONTROL_LOOP_REDO, loop735_redo
  loop735_done:
    pop_eh 
  for_undef_268:
.annotate 'line', 342
    find_lex $P738, "$obj"
    find_lex $P739, "%cache"
    publish_method_cache $P738, $P739
.annotate 'line', 330
    .return ()
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block706"  :anon :subid("50_1299450582.447") :outer("49_1299450582.447")
    .param pmc param_709
.annotate 'line', 334
    .const 'Sub' $P719 = "51_1299450582.447" 
    capture_lex $P719
.annotate 'line', 335
    $P708 = root_new ['parrot';'Hash']
    .lex "%methods", $P708
    .lex "$_", param_709
    find_lex $P710, "$_"
    get_how $P711, $P710
    find_lex $P712, "$_"
    $P713 = $P711."method_table"($P712)
    store_lex "%methods", $P713
.annotate 'line', 336
    find_lex $P715, "%methods"
    defined $I716, $P715
    unless $I716, for_undef_269
    iter $P714, $P715
    new $P733, 'ExceptionHandler'
    set_label $P733, loop732_handler
    $P733."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P733
  loop732_test:
    unless $P714, loop732_done
    shift $P717, $P714
  loop732_redo:
    .const 'Sub' $P719 = "51_1299450582.447" 
    capture_lex $P719
    $P719($P717)
  loop732_next:
    goto loop732_test
  loop732_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P734, exception, 'type'
    eq $P734, .CONTROL_LOOP_NEXT, loop732_next
    eq $P734, .CONTROL_LOOP_REDO, loop732_redo
  loop732_done:
    pop_eh 
  for_undef_269:
.annotate 'line', 334
    .return ($P714)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block718"  :anon :subid("51_1299450582.447") :outer("50_1299450582.447")
    .param pmc param_720
.annotate 'line', 336
    .lex "$_", param_720
.annotate 'line', 337
    find_lex $P723, "$_"
    $P724 = $P723."key"()
    find_lex $P725, "%cache"
    unless_null $P725, vivify_270
    $P725 = root_new ['parrot';'Hash']
  vivify_270:
    set $P726, $P725[$P724]
    unless_null $P726, vivify_271
    new $P726, "Undef"
  vivify_271:
    unless $P726, unless_722
    set $P721, $P726
    goto unless_722_end
  unless_722:
.annotate 'line', 338
    find_lex $P727, "$_"
    $P728 = $P727."value"()
    find_lex $P729, "$_"
    $P730 = $P729."key"()
    find_lex $P731, "%cache"
    unless_null $P731, vivify_272
    $P731 = root_new ['parrot';'Hash']
    store_lex "%cache", $P731
  vivify_272:
    set $P731[$P730], $P728
.annotate 'line', 337
    set $P721, $P728
  unless_722_end:
.annotate 'line', 336
    .return ($P721)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "publish_parrot_vtable_mapping"  :subid("52_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_741
    .param pmc param_742
.annotate 'line', 345
    .const 'Sub' $P752 = "53_1299450582.447" 
    capture_lex $P752
    .lex "self", param_741
    .lex "$obj", param_742
.annotate 'line', 346
    $P743 = root_new ['parrot';'Hash']
    .lex "%mapping", $P743
.annotate 'line', 345
    find_lex $P744, "%mapping"
.annotate 'line', 347
    find_lex $P746, "self"
    get_global $P747, "$?CLASS"
    getattribute $P748, $P746, $P747, "@!mro"
    unless_null $P748, vivify_273
    $P748 = root_new ['parrot';'ResizablePMCArray']
  vivify_273:
    defined $I749, $P748
    unless $I749, for_undef_274
    iter $P745, $P748
    new $P781, 'ExceptionHandler'
    set_label $P781, loop780_handler
    $P781."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P781
  loop780_test:
    unless $P745, loop780_done
    shift $P750, $P745
  loop780_redo:
    .const 'Sub' $P752 = "53_1299450582.447" 
    capture_lex $P752
    $P752($P750)
  loop780_next:
    goto loop780_test
  loop780_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P782, exception, 'type'
    eq $P782, .CONTROL_LOOP_NEXT, loop780_next
    eq $P782, .CONTROL_LOOP_REDO, loop780_redo
  loop780_done:
    pop_eh 
  for_undef_274:
.annotate 'line', 355
    find_lex $P785, "%mapping"
    set $N786, $P785
    if $N786, if_784
    new $P783, 'Float'
    set $P783, $N786
    goto if_784_end
  if_784:
.annotate 'line', 356
    find_lex $P787, "$obj"
    find_lex $P788, "%mapping"
    stable_publish_vtable_mapping $P787, $P788
  if_784_end:
.annotate 'line', 345
    .return ($P783)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block751"  :anon :subid("53_1299450582.447") :outer("52_1299450582.447")
    .param pmc param_754
.annotate 'line', 347
    .const 'Sub' $P764 = "54_1299450582.447" 
    capture_lex $P764
.annotate 'line', 348
    $P753 = root_new ['parrot';'Hash']
    .lex "%map", $P753
    .lex "$_", param_754
    find_lex $P755, "$_"
    get_how $P756, $P755
    find_lex $P757, "$_"
    $P758 = $P756."parrot_vtable_mappings"($P757, 1 :named("local"))
    store_lex "%map", $P758
.annotate 'line', 349
    find_lex $P760, "%map"
    defined $I761, $P760
    unless $I761, for_undef_275
    iter $P759, $P760
    new $P778, 'ExceptionHandler'
    set_label $P778, loop777_handler
    $P778."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P778
  loop777_test:
    unless $P759, loop777_done
    shift $P762, $P759
  loop777_redo:
    .const 'Sub' $P764 = "54_1299450582.447" 
    capture_lex $P764
    $P764($P762)
  loop777_next:
    goto loop777_test
  loop777_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P779, exception, 'type'
    eq $P779, .CONTROL_LOOP_NEXT, loop777_next
    eq $P779, .CONTROL_LOOP_REDO, loop777_redo
  loop777_done:
    pop_eh 
  for_undef_275:
.annotate 'line', 347
    .return ($P759)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block763"  :anon :subid("54_1299450582.447") :outer("53_1299450582.447")
    .param pmc param_765
.annotate 'line', 349
    .lex "$_", param_765
.annotate 'line', 350
    find_lex $P768, "$_"
    $P769 = $P768."key"()
    find_lex $P770, "%mapping"
    unless_null $P770, vivify_276
    $P770 = root_new ['parrot';'Hash']
  vivify_276:
    set $P771, $P770[$P769]
    unless_null $P771, vivify_277
    new $P771, "Undef"
  vivify_277:
    unless $P771, unless_767
    set $P766, $P771
    goto unless_767_end
  unless_767:
.annotate 'line', 351
    find_lex $P772, "$_"
    $P773 = $P772."value"()
    find_lex $P774, "$_"
    $P775 = $P774."key"()
    find_lex $P776, "%mapping"
    unless_null $P776, vivify_278
    $P776 = root_new ['parrot';'Hash']
    store_lex "%mapping", $P776
  vivify_278:
    set $P776[$P775], $P773
.annotate 'line', 350
    set $P766, $P773
  unless_767_end:
.annotate 'line', 349
    .return ($P766)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "parents"  :subid("55_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_790
    .param pmc param_791
    .param pmc param_792 :optional :named("local")
    .param int has_param_792 :opt_flag
.annotate 'line', 364
    .lex "self", param_790
    .lex "$obj", param_791
    if has_param_792, optparam_279
    new $P793, "Undef"
    set param_792, $P793
  optparam_279:
    .lex "$local", param_792
.annotate 'line', 365
    find_lex $P796, "$local"
    if $P796, if_795
    find_lex $P800, "self"
    get_global $P801, "$?CLASS"
    getattribute $P802, $P800, $P801, "@!mro"
    unless_null $P802, vivify_280
    $P802 = root_new ['parrot';'ResizablePMCArray']
  vivify_280:
    set $P794, $P802
    goto if_795_end
  if_795:
    find_lex $P797, "self"
    get_global $P798, "$?CLASS"
    getattribute $P799, $P797, $P798, "@!parents"
    unless_null $P799, vivify_281
    $P799 = root_new ['parrot';'ResizablePMCArray']
  vivify_281:
    set $P794, $P799
  if_795_end:
.annotate 'line', 364
    .return ($P794)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "roles"  :subid("56_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_804
    .param pmc param_805
    .param pmc param_806 :named("local")
.annotate 'line', 368
    .lex "self", param_804
    .lex "$obj", param_805
    .lex "$local", param_806
    find_lex $P807, "self"
    get_global $P808, "$?CLASS"
    getattribute $P809, $P807, $P808, "@!roles"
    unless_null $P809, vivify_282
    $P809 = root_new ['parrot';'ResizablePMCArray']
  vivify_282:
    .return ($P809)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("57_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_811
    .param pmc param_812
    .param pmc param_813 :named("local")
.annotate 'line', 372
    .const 'Sub' $P823 = "58_1299450582.447" 
    capture_lex $P823
    .lex "self", param_811
    .lex "$obj", param_812
    .lex "$local", param_813
.annotate 'line', 373
    $P814 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P814
.annotate 'line', 372
    find_lex $P815, "@meths"
.annotate 'line', 374
    find_lex $P817, "self"
    get_global $P818, "$?CLASS"
    getattribute $P819, $P817, $P818, "%!methods"
    unless_null $P819, vivify_283
    $P819 = root_new ['parrot';'Hash']
  vivify_283:
    defined $I820, $P819
    unless $I820, for_undef_284
    iter $P816, $P819
    new $P830, 'ExceptionHandler'
    set_label $P830, loop829_handler
    $P830."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P830
  loop829_test:
    unless $P816, loop829_done
    shift $P821, $P816
  loop829_redo:
    .const 'Sub' $P823 = "58_1299450582.447" 
    capture_lex $P823
    $P823($P821)
  loop829_next:
    goto loop829_test
  loop829_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P831, exception, 'type'
    eq $P831, .CONTROL_LOOP_NEXT, loop829_next
    eq $P831, .CONTROL_LOOP_REDO, loop829_redo
  loop829_done:
    pop_eh 
  for_undef_284:
    find_lex $P832, "@meths"
.annotate 'line', 372
    .return ($P832)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block822"  :anon :subid("58_1299450582.447") :outer("57_1299450582.447")
    .param pmc param_824
.annotate 'line', 374
    .lex "$_", param_824
.annotate 'line', 375
    find_lex $P825, "@meths"
    find_lex $P826, "$_"
    $P827 = $P826."value"()
    $P828 = $P825."push"($P827)
.annotate 'line', 374
    .return ($P828)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "method_table"  :subid("59_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_834
    .param pmc param_835
.annotate 'line', 380
    .lex "self", param_834
    .lex "$obj", param_835
    find_lex $P836, "self"
    get_global $P837, "$?CLASS"
    getattribute $P838, $P836, $P837, "%!methods"
    unless_null $P838, vivify_285
    $P838 = root_new ['parrot';'Hash']
  vivify_285:
    .return ($P838)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "name"  :subid("60_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_840
    .param pmc param_841
.annotate 'line', 384
    .lex "self", param_840
    .lex "$obj", param_841
    find_lex $P842, "self"
    get_global $P843, "$?CLASS"
    getattribute $P844, $P842, $P843, "$!name"
    unless_null $P844, vivify_286
    new $P844, "Undef"
  vivify_286:
    .return ($P844)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("61_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_846
    .param pmc param_847
    .param pmc param_848 :named("local")
.annotate 'line', 388
    .const 'Sub' $P858 = "62_1299450582.447" 
    capture_lex $P858
    .lex "self", param_846
    .lex "$obj", param_847
    .lex "$local", param_848
.annotate 'line', 389
    $P849 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P849
.annotate 'line', 388
    find_lex $P850, "@attrs"
.annotate 'line', 390
    find_lex $P852, "self"
    get_global $P853, "$?CLASS"
    getattribute $P854, $P852, $P853, "%!attributes"
    unless_null $P854, vivify_287
    $P854 = root_new ['parrot';'Hash']
  vivify_287:
    defined $I855, $P854
    unless $I855, for_undef_288
    iter $P851, $P854
    new $P865, 'ExceptionHandler'
    set_label $P865, loop864_handler
    $P865."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P865
  loop864_test:
    unless $P851, loop864_done
    shift $P856, $P851
  loop864_redo:
    .const 'Sub' $P858 = "62_1299450582.447" 
    capture_lex $P858
    $P858($P856)
  loop864_next:
    goto loop864_test
  loop864_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P866, exception, 'type'
    eq $P866, .CONTROL_LOOP_NEXT, loop864_next
    eq $P866, .CONTROL_LOOP_REDO, loop864_redo
  loop864_done:
    pop_eh 
  for_undef_288:
    find_lex $P867, "@attrs"
.annotate 'line', 388
    .return ($P867)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "_block857"  :anon :subid("62_1299450582.447") :outer("61_1299450582.447")
    .param pmc param_859
.annotate 'line', 390
    .lex "$_", param_859
.annotate 'line', 391
    find_lex $P860, "@attrs"
    find_lex $P861, "$_"
    $P862 = $P861."value"()
    $P863 = $P860."push"($P862)
.annotate 'line', 390
    .return ($P863)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.sub "parrot_vtable_mappings"  :subid("63_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_869
    .param pmc param_870
    .param pmc param_871 :named("local")
.annotate 'line', 396
    .lex "self", param_869
    .lex "$obj", param_870
    .lex "$local", param_871
    find_lex $P872, "self"
    get_global $P873, "$?CLASS"
    getattribute $P874, $P872, $P873, "%!parrot_vtable_mapping"
    unless_null $P874, vivify_289
    $P874 = root_new ['parrot';'Hash']
  vivify_289:
    .return ($P874)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "isa"  :subid("64_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_878
    .param pmc param_879
    .param pmc param_880
.annotate 'line', 404
    new $P877, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P877, control_876
    push_eh $P877
    .lex "self", param_878
    .lex "$obj", param_879
    .lex "$check", param_880
.annotate 'line', 405
    new $P881, "Undef"
    .lex "$check-class", $P881
.annotate 'line', 406
    new $P882, "Undef"
    .lex "$i", $P882
.annotate 'line', 405
    find_lex $P883, "$check"
    get_what $P884, $P883
    store_lex "$check-class", $P884
.annotate 'line', 406
    find_lex $P885, "self"
    get_global $P886, "$?CLASS"
    getattribute $P887, $P885, $P886, "@!mro"
    unless_null $P887, vivify_290
    $P887 = root_new ['parrot';'ResizablePMCArray']
  vivify_290:
    set $N888, $P887
    new $P889, 'Float'
    set $P889, $N888
    store_lex "$i", $P889
.annotate 'line', 407
    new $P907, 'ExceptionHandler'
    set_label $P907, loop906_handler
    $P907."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P907
  loop906_test:
    find_lex $P890, "$i"
    set $N891, $P890
    isgt $I892, $N891, 0.0
    unless $I892, loop906_done
  loop906_redo:
.annotate 'line', 408
    find_lex $P893, "$i"
    sub $P894, $P893, 1
    store_lex "$i", $P894
.annotate 'line', 409
    find_lex $P896, "$i"
    set $I897, $P896
    find_lex $P898, "self"
    get_global $P899, "$?CLASS"
    getattribute $P900, $P898, $P899, "@!mro"
    unless_null $P900, vivify_291
    $P900 = root_new ['parrot';'ResizablePMCArray']
  vivify_291:
    set $P901, $P900[$I897]
    unless_null $P901, vivify_292
    new $P901, "Undef"
  vivify_292:
    find_lex $P902, "$check-class"
    issame $I903, $P901, $P902
    unless $I903, if_895_end
.annotate 'line', 410
    new $P904, "Exception"
    set $P904['type'], .CONTROL_RETURN
    new $P905, "Integer"
    assign $P905, 1
    setattribute $P904, 'payload', $P905
    throw $P904
  if_895_end:
  loop906_next:
.annotate 'line', 407
    goto loop906_test
  loop906_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P908, exception, 'type'
    eq $P908, .CONTROL_LOOP_NEXT, loop906_next
    eq $P908, .CONTROL_LOOP_REDO, loop906_redo
  loop906_done:
    pop_eh 
.annotate 'line', 413
    new $P909, "Exception"
    set $P909['type'], .CONTROL_RETURN
    new $P910, "Integer"
    assign $P910, 0
    setattribute $P909, 'payload', $P910
    throw $P909
.annotate 'line', 404
    .return ()
  control_876:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P911, exception, "payload"
    .return ($P911)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "does"  :subid("65_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_915
    .param pmc param_916
    .param pmc param_917
.annotate 'line', 416
    new $P914, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P914, control_913
    push_eh $P914
    .lex "self", param_915
    .lex "$obj", param_916
    .lex "$check", param_917
.annotate 'line', 417
    new $P918, "Undef"
    .lex "$i", $P918
    find_lex $P919, "self"
    get_global $P920, "$?CLASS"
    getattribute $P921, $P919, $P920, "@!done"
    unless_null $P921, vivify_293
    $P921 = root_new ['parrot';'ResizablePMCArray']
  vivify_293:
    set $N922, $P921
    new $P923, 'Float'
    set $P923, $N922
    store_lex "$i", $P923
.annotate 'line', 418
    new $P941, 'ExceptionHandler'
    set_label $P941, loop940_handler
    $P941."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P941
  loop940_test:
    find_lex $P924, "$i"
    set $N925, $P924
    isgt $I926, $N925, 0.0
    unless $I926, loop940_done
  loop940_redo:
.annotate 'line', 419
    find_lex $P927, "$i"
    sub $P928, $P927, 1
    store_lex "$i", $P928
.annotate 'line', 420
    find_lex $P930, "$i"
    set $I931, $P930
    find_lex $P932, "self"
    get_global $P933, "$?CLASS"
    getattribute $P934, $P932, $P933, "@!done"
    unless_null $P934, vivify_294
    $P934 = root_new ['parrot';'ResizablePMCArray']
  vivify_294:
    set $P935, $P934[$I931]
    unless_null $P935, vivify_295
    new $P935, "Undef"
  vivify_295:
    find_lex $P936, "$check"
    issame $I937, $P935, $P936
    unless $I937, if_929_end
.annotate 'line', 421
    new $P938, "Exception"
    set $P938['type'], .CONTROL_RETURN
    new $P939, "Integer"
    assign $P939, 1
    setattribute $P938, 'payload', $P939
    throw $P938
  if_929_end:
  loop940_next:
.annotate 'line', 418
    goto loop940_test
  loop940_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P942, exception, 'type'
    eq $P942, .CONTROL_LOOP_NEXT, loop940_next
    eq $P942, .CONTROL_LOOP_REDO, loop940_redo
  loop940_done:
    pop_eh 
.annotate 'line', 424
    new $P943, "Exception"
    set $P943['type'], .CONTROL_RETURN
    new $P944, "Integer"
    assign $P944, 0
    setattribute $P943, 'payload', $P944
    throw $P943
.annotate 'line', 416
    .return ()
  control_913:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P945, exception, "payload"
    .return ($P945)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "can"  :subid("66_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_949
    .param pmc param_950
    .param pmc param_951
.annotate 'line', 427
    .const 'Sub' $P959 = "67_1299450582.447" 
    capture_lex $P959
    new $P948, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P948, control_947
    push_eh $P948
    .lex "self", param_949
    .lex "$obj", param_950
    .lex "$name", param_951
.annotate 'line', 428
    find_lex $P953, "self"
    get_global $P954, "$?CLASS"
    getattribute $P955, $P953, $P954, "@!mro"
    unless_null $P955, vivify_296
    $P955 = root_new ['parrot';'ResizablePMCArray']
  vivify_296:
    defined $I956, $P955
    unless $I956, for_undef_297
    iter $P952, $P955
    new $P977, 'ExceptionHandler'
    set_label $P977, loop976_handler
    $P977."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P977
  loop976_test:
    unless $P952, loop976_done
    shift $P957, $P952
  loop976_redo:
    .const 'Sub' $P959 = "67_1299450582.447" 
    capture_lex $P959
    $P959($P957)
  loop976_next:
    goto loop976_test
  loop976_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P978, exception, 'type'
    eq $P978, .CONTROL_LOOP_NEXT, loop976_next
    eq $P978, .CONTROL_LOOP_REDO, loop976_redo
  loop976_done:
    pop_eh 
  for_undef_297:
.annotate 'line', 435
    new $P979, "Exception"
    set $P979['type'], .CONTROL_RETURN
    new $P980, "Integer"
    assign $P980, 0
    setattribute $P979, 'payload', $P980
    throw $P979
.annotate 'line', 427
    .return ()
  control_947:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P981, exception, "payload"
    .return ($P981)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block958"  :anon :subid("67_1299450582.447") :outer("66_1299450582.447")
    .param pmc param_962
.annotate 'line', 429
    $P960 = root_new ['parrot';'Hash']
    .lex "%meths", $P960
.annotate 'line', 430
    new $P961, "Undef"
    .lex "$can", $P961
    .lex "$_", param_962
.annotate 'line', 429
    find_lex $P963, "$_"
    get_how $P964, $P963
    find_lex $P965, "$obj"
    $P966 = $P964."method_table"($P965)
    store_lex "%meths", $P966
.annotate 'line', 430
    find_lex $P967, "$name"
    find_lex $P968, "%meths"
    unless_null $P968, vivify_298
    $P968 = root_new ['parrot';'Hash']
  vivify_298:
    set $P969, $P968[$P967]
    unless_null $P969, vivify_299
    new $P969, "Undef"
  vivify_299:
    store_lex "$can", $P969
.annotate 'line', 431
    find_lex $P972, "$can"
    defined $I973, $P972
    if $I973, if_971
    new $P970, 'Integer'
    set $P970, $I973
    goto if_971_end
  if_971:
.annotate 'line', 432
    new $P974, "Exception"
    set $P974['type'], .CONTROL_RETURN
    find_lex $P975, "$can"
    setattribute $P974, 'payload', $P975
    throw $P974
  if_971_end:
.annotate 'line', 428
    .return ($P970)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "find_method"  :subid("68_1299450582.447") :outer("15_1299450582.447")
    .param pmc param_985
    .param pmc param_986
    .param pmc param_987
.annotate 'line', 441
    .const 'Sub' $P995 = "69_1299450582.447" 
    capture_lex $P995
    new $P984, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P984, control_983
    push_eh $P984
    .lex "self", param_985
    .lex "$obj", param_986
    .lex "$name", param_987
.annotate 'line', 442
    find_lex $P989, "self"
    get_global $P990, "$?CLASS"
    getattribute $P991, $P989, $P990, "@!mro"
    unless_null $P991, vivify_300
    $P991 = root_new ['parrot';'ResizablePMCArray']
  vivify_300:
    defined $I992, $P991
    unless $I992, for_undef_301
    iter $P988, $P991
    new $P1013, 'ExceptionHandler'
    set_label $P1013, loop1012_handler
    $P1013."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1013
  loop1012_test:
    unless $P988, loop1012_done
    shift $P993, $P988
  loop1012_redo:
    .const 'Sub' $P995 = "69_1299450582.447" 
    capture_lex $P995
    $P995($P993)
  loop1012_next:
    goto loop1012_test
  loop1012_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1014, exception, 'type'
    eq $P1014, .CONTROL_LOOP_NEXT, loop1012_next
    eq $P1014, .CONTROL_LOOP_REDO, loop1012_redo
  loop1012_done:
    pop_eh 
  for_undef_301:
.annotate 'line', 449
    null $P1015
.annotate 'line', 441
    .return ($P1015)
  control_983:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1016, exception, "payload"
    .return ($P1016)
.end


.HLL "nqp"

.namespace ["NQPClassHOW"]
.include "except_types.pasm"
.sub "_block994"  :anon :subid("69_1299450582.447") :outer("68_1299450582.447")
    .param pmc param_998
.annotate 'line', 443
    $P996 = root_new ['parrot';'Hash']
    .lex "%meths", $P996
.annotate 'line', 444
    new $P997, "Undef"
    .lex "$found", $P997
    .lex "$_", param_998
.annotate 'line', 443
    find_lex $P999, "$_"
    get_how $P1000, $P999
    find_lex $P1001, "$obj"
    $P1002 = $P1000."method_table"($P1001)
    store_lex "%meths", $P1002
.annotate 'line', 444
    find_lex $P1003, "$name"
    find_lex $P1004, "%meths"
    unless_null $P1004, vivify_302
    $P1004 = root_new ['parrot';'Hash']
  vivify_302:
    set $P1005, $P1004[$P1003]
    unless_null $P1005, vivify_303
    new $P1005, "Undef"
  vivify_303:
    store_lex "$found", $P1005
.annotate 'line', 445
    find_lex $P1008, "$found"
    defined $I1009, $P1008
    if $I1009, if_1007
    new $P1006, 'Integer'
    set $P1006, $I1009
    goto if_1007_end
  if_1007:
.annotate 'line', 446
    new $P1010, "Exception"
    set $P1010['type'], .CONTROL_RETURN
    find_lex $P1011, "$found"
    setattribute $P1010, 'payload', $P1011
    throw $P1010
  if_1007_end:
.annotate 'line', 442
    .return ($P1006)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "_block1110"  :subid("71_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 454
    .const 'Sub' $P1171 = "80_1299450582.447" 
    capture_lex $P1171
    .const 'Sub' $P1163 = "79_1299450582.447" 
    capture_lex $P1163
    .const 'Sub' $P1157 = "78_1299450582.447" 
    capture_lex $P1157
    .const 'Sub' $P1153 = "77_1299450582.447" 
    capture_lex $P1153
    .const 'Sub' $P1148 = "76_1299450582.447" 
    capture_lex $P1148
    .const 'Sub' $P1143 = "75_1299450582.447" 
    capture_lex $P1143
    .const 'Sub' $P1130 = "74_1299450582.447" 
    capture_lex $P1130
    .const 'Sub' $P1123 = "73_1299450582.447" 
    capture_lex $P1123
    .const 'Sub' $P1113 = "72_1299450582.447" 
    capture_lex $P1113
    get_global $P1112, "$?CLASS"
.annotate 'line', 492
    .const 'Sub' $P1163 = "79_1299450582.447" 
    newclosure $P1169, $P1163
.annotate 'line', 454
    .return ($P1169)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "" :load :init :subid("post304") :outer("71_1299450582.447")
.annotate 'line', 454
    get_hll_global $P1111, ["NQPNativeHOW"], "_block1110" 
    .local pmc block
    set block, $P1111
    .const 'Sub' $P1171 = "80_1299450582.447" 
    capture_lex $P1171
    $P1171()
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "_block1170"  :anon :subid("80_1299450582.447") :outer("71_1299450582.447")
.annotate 'line', 454
    get_hll_global $P1172, "KnowHOW"
    $P1173 = $P1172."new_type"("NQPNativeHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1173
    set_hll_global "NQPNativeHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1174, type_obj
    get_hll_global $P1175, "KnowHOWAttribute"
    $P1176 = $P1175."new"("$!name" :named("name"))
    $P1174."add_attribute"(type_obj, $P1176)
    get_how $P1177, type_obj
    get_hll_global $P1178, "KnowHOWAttribute"
    $P1179 = $P1178."new"("$!composed" :named("name"))
    $P1177."add_attribute"(type_obj, $P1179)
    get_how $P1180, type_obj
    .const 'Sub' $P1181 = "72_1299450582.447" 
    $P1180."add_method"(type_obj, "new", $P1181)
    get_how $P1182, type_obj
    .const 'Sub' $P1183 = "73_1299450582.447" 
    $P1182."add_method"(type_obj, "BUILD", $P1183)
    get_how $P1184, type_obj
    .const 'Sub' $P1185 = "74_1299450582.447" 
    $P1184."add_method"(type_obj, "new_type", $P1185)
    get_how $P1186, type_obj
    .const 'Sub' $P1187 = "75_1299450582.447" 
    $P1186."add_method"(type_obj, "add_method", $P1187)
    get_how $P1188, type_obj
    .const 'Sub' $P1189 = "76_1299450582.447" 
    $P1188."add_method"(type_obj, "add_multi_method", $P1189)
    get_how $P1190, type_obj
    .const 'Sub' $P1191 = "77_1299450582.447" 
    $P1190."add_method"(type_obj, "add_attribute", $P1191)
    get_how $P1192, type_obj
    .const 'Sub' $P1193 = "78_1299450582.447" 
    $P1192."add_method"(type_obj, "compose", $P1193)
    get_how $P1194, type_obj
    .const 'Sub' $P1195 = "79_1299450582.447" 
    $P1194."add_method"(type_obj, "name", $P1195)
    get_how $P1196, type_obj
    $P1197 = $P1196."compose"(type_obj)
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "new"  :subid("72_1299450582.447") :outer("71_1299450582.447")
    .param pmc param_1114
    .param pmc param_1115 :optional :named("name")
    .param int has_param_1115 :opt_flag
.annotate 'line', 458
    .lex "self", param_1114
    if has_param_1115, optparam_305
    new $P1116, "Undef"
    set param_1115, $P1116
  optparam_305:
    .lex "$name", param_1115
.annotate 'line', 459
    new $P1117, "Undef"
    .lex "$obj", $P1117
    find_lex $P1118, "self"
    repr_instance_of $P1119, $P1118
    store_lex "$obj", $P1119
.annotate 'line', 460
    find_lex $P1120, "$obj"
    find_lex $P1121, "$name"
    $P1120."BUILD"($P1121 :named("name"))
    find_lex $P1122, "$obj"
.annotate 'line', 458
    .return ($P1122)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "BUILD"  :subid("73_1299450582.447") :outer("71_1299450582.447")
    .param pmc param_1124
    .param pmc param_1125 :optional :named("name")
    .param int has_param_1125 :opt_flag
.annotate 'line', 464
    .lex "self", param_1124
    if has_param_1125, optparam_306
    new $P1126, "Undef"
    set param_1125, $P1126
  optparam_306:
    .lex "$name", param_1125
.annotate 'line', 465
    find_lex $P1127, "$name"
    find_lex $P1128, "self"
    get_global $P1129, "$?CLASS"
    setattribute $P1128, $P1129, "$!name", $P1127
.annotate 'line', 464
    .return ($P1127)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "new_type"  :subid("74_1299450582.447") :outer("71_1299450582.447")
    .param pmc param_1131
    .param pmc param_1134 :named("repr")
    .param pmc param_1132 :optional :named("name")
    .param int has_param_1132 :opt_flag
.annotate 'line', 471
    .lex "self", param_1131
    if has_param_1132, optparam_307
    new $P1133, "String"
    assign $P1133, "<anon>"
    set param_1132, $P1133
  optparam_307:
    .lex "$name", param_1132
    .lex "$repr", param_1134
.annotate 'line', 472
    new $P1135, "Undef"
    .lex "$metaclass", $P1135
    find_lex $P1136, "self"
    find_lex $P1137, "$name"
    $P1138 = $P1136."new"($P1137 :named("name"))
    store_lex "$metaclass", $P1138
.annotate 'line', 473
    find_lex $P1139, "$metaclass"
    find_lex $P1140, "$repr"
    set $S1141, $P1140
    repr_type_object_for $P1142, $P1139, $S1141
.annotate 'line', 471
    .return ($P1142)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "add_method"  :subid("75_1299450582.447") :outer("71_1299450582.447")
    .param pmc param_1144
    .param pmc param_1145
    .param pmc param_1146
    .param pmc param_1147
.annotate 'line', 476
    .lex "self", param_1144
    .lex "$obj", param_1145
    .lex "$name", param_1146
    .lex "$code_obj", param_1147
.annotate 'line', 477
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 476
    .return ()
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "add_multi_method"  :subid("76_1299450582.447") :outer("71_1299450582.447")
    .param pmc param_1149
    .param pmc param_1150
    .param pmc param_1151
    .param pmc param_1152
.annotate 'line', 480
    .lex "self", param_1149
    .lex "$obj", param_1150
    .lex "$name", param_1151
    .lex "$code_obj", param_1152
.annotate 'line', 481
    die "Native types may not have methods (must be boxed to call method)"
.annotate 'line', 480
    .return ()
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "add_attribute"  :subid("77_1299450582.447") :outer("71_1299450582.447")
    .param pmc param_1154
    .param pmc param_1155
    .param pmc param_1156
.annotate 'line', 484
    .lex "self", param_1154
    .lex "$obj", param_1155
    .lex "$meta_attr", param_1156
.annotate 'line', 485
    die "Native types may not have attributes"
.annotate 'line', 484
    .return ()
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "compose"  :subid("78_1299450582.447") :outer("71_1299450582.447")
    .param pmc param_1158
    .param pmc param_1159
.annotate 'line', 488
    .lex "self", param_1158
    .lex "$obj", param_1159
.annotate 'line', 489
    new $P1160, "Integer"
    assign $P1160, 1
    find_lex $P1161, "self"
    get_global $P1162, "$?CLASS"
    setattribute $P1161, $P1162, "$!composed", $P1160
.annotate 'line', 488
    .return ($P1160)
.end


.HLL "nqp"

.namespace ["NQPNativeHOW"]
.sub "name"  :subid("79_1299450582.447") :outer("71_1299450582.447")
    .param pmc param_1164
    .param pmc param_1165
.annotate 'line', 492
    .lex "self", param_1164
    .lex "$obj", param_1165
    find_lex $P1166, "self"
    get_global $P1167, "$?CLASS"
    getattribute $P1168, $P1166, $P1167, "$!name"
    unless_null $P1168, vivify_308
    new $P1168, "Undef"
  vivify_308:
    .return ($P1168)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1198"  :subid("81_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 498
    .const 'Sub' $P1382 = "95_1299450582.447" 
    capture_lex $P1382
    .const 'Sub' $P1372 = "94_1299450582.447" 
    capture_lex $P1372
    .const 'Sub' $P1291 = "89_1299450582.447" 
    capture_lex $P1291
    .const 'Sub' $P1282 = "88_1299450582.447" 
    capture_lex $P1282
    .const 'Sub' $P1273 = "87_1299450582.447" 
    capture_lex $P1273
    .const 'Sub' $P1268 = "86_1299450582.447" 
    capture_lex $P1268
    .const 'Sub' $P1251 = "85_1299450582.447" 
    capture_lex $P1251
    .const 'Sub' $P1236 = "84_1299450582.447" 
    capture_lex $P1236
    .const 'Sub' $P1201 = "82_1299450582.447" 
    capture_lex $P1201
    get_global $P1200, "$?CLASS"
.annotate 'line', 558
    .const 'Sub' $P1201 = "82_1299450582.447" 
    newclosure $P1235, $P1201
    .lex "has_method", $P1235
.annotate 'line', 554
    find_lex $P1380, "has_method"
.annotate 'line', 498
    .return ($P1380)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "" :load :init :subid("post309") :outer("81_1299450582.447")
.annotate 'line', 498
    get_hll_global $P1199, ["NQPAttribute"], "_block1198" 
    .local pmc block
    set block, $P1199
    .const 'Sub' $P1382 = "95_1299450582.447" 
    capture_lex $P1382
    $P1382()
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1381"  :anon :subid("95_1299450582.447") :outer("81_1299450582.447")
.annotate 'line', 498
    get_hll_global $P1383, "KnowHOW"
    $P1384 = $P1383."new_type"("NQPAttribute" :named("name"))
    .local pmc type_obj
    set type_obj, $P1384
    set_hll_global "NQPAttribute", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1385, type_obj
    get_hll_global $P1386, "KnowHOWAttribute"
    $P1387 = $P1386."new"("$!name" :named("name"))
    $P1385."add_attribute"(type_obj, $P1387)
    get_how $P1388, type_obj
    get_hll_global $P1389, "KnowHOWAttribute"
    $P1390 = $P1389."new"("$!type" :named("name"))
    $P1388."add_attribute"(type_obj, $P1390)
    get_how $P1391, type_obj
    get_hll_global $P1392, "KnowHOWAttribute"
    $P1393 = $P1392."new"("$!box_target" :named("name"))
    $P1391."add_attribute"(type_obj, $P1393)
    get_how $P1394, type_obj
    .const 'Sub' $P1395 = "84_1299450582.447" 
    $P1394."add_method"(type_obj, "new", $P1395)
    get_how $P1396, type_obj
    .const 'Sub' $P1397 = "85_1299450582.447" 
    $P1396."add_method"(type_obj, "BUILD", $P1397)
    get_how $P1398, type_obj
    .const 'Sub' $P1399 = "86_1299450582.447" 
    $P1398."add_method"(type_obj, "name", $P1399)
    get_how $P1400, type_obj
    .const 'Sub' $P1401 = "87_1299450582.447" 
    $P1400."add_method"(type_obj, "type", $P1401)
    get_how $P1402, type_obj
    .const 'Sub' $P1403 = "88_1299450582.447" 
    $P1402."add_method"(type_obj, "box_target", $P1403)
    get_how $P1404, type_obj
    .const 'Sub' $P1405 = "89_1299450582.447" 
    $P1404."add_method"(type_obj, "compose", $P1405)
    get_how $P1406, type_obj
    .const 'Sub' $P1407 = "94_1299450582.447" 
    $P1406."add_method"(type_obj, "has_mutator", $P1407)
    get_how $P1408, type_obj
    $P1409 = $P1408."compose"(type_obj)
    .return ($P1409)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "has_method"  :subid("82_1299450582.447") :outer("81_1299450582.447")
    .param pmc param_1204
    .param pmc param_1205
    .param pmc param_1206
.annotate 'line', 558
    .const 'Sub' $P1218 = "83_1299450582.447" 
    capture_lex $P1218
    new $P1203, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1203, control_1202
    push_eh $P1203
    .lex "$target", param_1204
    .lex "$name", param_1205
    .lex "$local", param_1206
.annotate 'line', 559
    $P1207 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P1207
    find_lex $P1208, "$target"
    get_how $P1209, $P1208
    find_lex $P1210, "$target"
    find_lex $P1211, "$local"
    $P1212 = $P1209."methods"($P1210, $P1211 :named("local"))
    store_lex "@methods", $P1212
.annotate 'line', 560
    find_lex $P1214, "@methods"
    defined $I1215, $P1214
    unless $I1215, for_undef_310
    iter $P1213, $P1214
    new $P1230, 'ExceptionHandler'
    set_label $P1230, loop1229_handler
    $P1230."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1230
  loop1229_test:
    unless $P1213, loop1229_done
    shift $P1216, $P1213
  loop1229_redo:
    .const 'Sub' $P1218 = "83_1299450582.447" 
    capture_lex $P1218
    $P1218($P1216)
  loop1229_next:
    goto loop1229_test
  loop1229_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1231, exception, 'type'
    eq $P1231, .CONTROL_LOOP_NEXT, loop1229_next
    eq $P1231, .CONTROL_LOOP_REDO, loop1229_redo
  loop1229_done:
    pop_eh 
  for_undef_310:
.annotate 'line', 563
    new $P1232, "Exception"
    set $P1232['type'], .CONTROL_RETURN
    new $P1233, "Integer"
    assign $P1233, 0
    setattribute $P1232, 'payload', $P1233
    throw $P1232
.annotate 'line', 558
    .return ()
  control_1202:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1234, exception, "payload"
    .return ($P1234)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.include "except_types.pasm"
.sub "_block1217"  :anon :subid("83_1299450582.447") :outer("82_1299450582.447")
    .param pmc param_1219
.annotate 'line', 560
    .lex "$_", param_1219
.annotate 'line', 561
    find_lex $P1222, "$_"
    set $S1223, $P1222
    find_lex $P1224, "$name"
    set $S1225, $P1224
    iseq $I1226, $S1223, $S1225
    if $I1226, if_1221
    new $P1220, 'Integer'
    set $P1220, $I1226
    goto if_1221_end
  if_1221:
    new $P1227, "Exception"
    set $P1227['type'], .CONTROL_RETURN
    new $P1228, "Integer"
    assign $P1228, 1
    setattribute $P1227, 'payload', $P1228
    throw $P1227
  if_1221_end:
.annotate 'line', 560
    .return ($P1220)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "new"  :subid("84_1299450582.447") :outer("81_1299450582.447")
    .param pmc param_1237
    .param pmc param_1238 :named("name")
    .param pmc param_1239 :optional :named("type")
    .param int has_param_1239 :opt_flag
    .param pmc param_1241 :optional :named("box_target")
    .param int has_param_1241 :opt_flag
.annotate 'line', 503
    .lex "self", param_1237
    .lex "$name", param_1238
    if has_param_1239, optparam_311
    new $P1240, "Undef"
    set param_1239, $P1240
  optparam_311:
    .lex "$type", param_1239
    if has_param_1241, optparam_312
    new $P1242, "Undef"
    set param_1241, $P1242
  optparam_312:
    .lex "$box_target", param_1241
.annotate 'line', 504
    new $P1243, "Undef"
    .lex "$attr", $P1243
    find_lex $P1244, "self"
    repr_instance_of $P1245, $P1244
    store_lex "$attr", $P1245
.annotate 'line', 505
    find_lex $P1246, "$attr"
    find_lex $P1247, "$name"
    find_lex $P1248, "$type"
    find_lex $P1249, "$box_target"
    $P1246."BUILD"($P1247 :named("name"), $P1248 :named("type"), $P1249 :named("box_target"))
    find_lex $P1250, "$attr"
.annotate 'line', 503
    .return ($P1250)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "BUILD"  :subid("85_1299450582.447") :outer("81_1299450582.447")
    .param pmc param_1252
    .param pmc param_1253 :optional :named("name")
    .param int has_param_1253 :opt_flag
    .param pmc param_1255 :optional :named("type")
    .param int has_param_1255 :opt_flag
    .param pmc param_1257 :optional :named("box_target")
    .param int has_param_1257 :opt_flag
.annotate 'line', 509
    .lex "self", param_1252
    if has_param_1253, optparam_313
    new $P1254, "Undef"
    set param_1253, $P1254
  optparam_313:
    .lex "$name", param_1253
    if has_param_1255, optparam_314
    new $P1256, "Undef"
    set param_1255, $P1256
  optparam_314:
    .lex "$type", param_1255
    if has_param_1257, optparam_315
    new $P1258, "Undef"
    set param_1257, $P1258
  optparam_315:
    .lex "$box_target", param_1257
.annotate 'line', 510
    find_lex $P1259, "$name"
    find_lex $P1260, "self"
    get_global $P1261, "$?CLASS"
    setattribute $P1260, $P1261, "$!name", $P1259
.annotate 'line', 511
    find_lex $P1262, "$type"
    find_lex $P1263, "self"
    get_global $P1264, "$?CLASS"
    setattribute $P1263, $P1264, "$!type", $P1262
.annotate 'line', 512
    find_lex $P1265, "$box_target"
    find_lex $P1266, "self"
    get_global $P1267, "$?CLASS"
    setattribute $P1266, $P1267, "$!box_target", $P1265
.annotate 'line', 509
    .return ($P1265)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "name"  :subid("86_1299450582.447") :outer("81_1299450582.447")
    .param pmc param_1269
.annotate 'line', 515
    .lex "self", param_1269
    find_lex $P1270, "self"
    get_global $P1271, "$?CLASS"
    getattribute $P1272, $P1270, $P1271, "$!name"
    unless_null $P1272, vivify_316
    new $P1272, "Undef"
  vivify_316:
    .return ($P1272)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "type"  :subid("87_1299450582.447") :outer("81_1299450582.447")
    .param pmc param_1274
.annotate 'line', 519
    .lex "self", param_1274
.annotate 'line', 520
    find_lex $P1276, "self"
    get_global $P1277, "$?CLASS"
    getattribute $P1278, $P1276, $P1277, "$!type"
    unless_null $P1278, vivify_317
    new $P1278, "Undef"
  vivify_317:
    set $P1275, $P1278
    defined $I1280, $P1275
    if $I1280, default_1279
    null $P1281
    set $P1275, $P1281
  default_1279:
.annotate 'line', 519
    .return ($P1275)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "box_target"  :subid("88_1299450582.447") :outer("81_1299450582.447")
    .param pmc param_1283
.annotate 'line', 523
    .lex "self", param_1283
.annotate 'line', 524
    find_lex $P1286, "self"
    get_global $P1287, "$?CLASS"
    getattribute $P1288, $P1286, $P1287, "$!box_target"
    unless_null $P1288, vivify_318
    new $P1288, "Undef"
  vivify_318:
    if $P1288, if_1285
    new $P1290, "Integer"
    assign $P1290, 0
    set $P1284, $P1290
    goto if_1285_end
  if_1285:
    new $P1289, "Integer"
    assign $P1289, 1
    set $P1284, $P1289
  if_1285_end:
.annotate 'line', 523
    .return ($P1284)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "compose"  :subid("89_1299450582.447") :outer("81_1299450582.447")
    .param pmc param_1292
    .param pmc param_1293
.annotate 'line', 527
    .const 'Sub' $P1345 = "92_1299450582.447" 
    capture_lex $P1345
    .const 'Sub' $P1305 = "90_1299450582.447" 
    capture_lex $P1305
    .lex "self", param_1292
    .lex "$obj", param_1293
.annotate 'line', 528
    new $P1294, "Undef"
    .lex "$long_name", $P1294
    find_lex $P1295, "self"
    get_global $P1296, "$?CLASS"
    getattribute $P1297, $P1295, $P1296, "$!name"
    unless_null $P1297, vivify_319
    new $P1297, "Undef"
  vivify_319:
    set $S1298, $P1297
    new $P1299, 'String'
    set $P1299, $S1298
    store_lex "$long_name", $P1299
.annotate 'line', 529
    find_lex $P1302, "self"
    $P1303 = $P1302."has_mutator"()
    if $P1303, if_1301
.annotate 'line', 541
    .const 'Sub' $P1345 = "92_1299450582.447" 
    capture_lex $P1345
    $P1371 = $P1345()
    set $P1300, $P1371
.annotate 'line', 529
    goto if_1301_end
  if_1301:
    .const 'Sub' $P1305 = "90_1299450582.447" 
    capture_lex $P1305
    $P1343 = $P1305()
    set $P1300, $P1343
  if_1301_end:
.annotate 'line', 527
    .return ($P1300)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1344"  :anon :subid("92_1299450582.447") :outer("89_1299450582.447")
.annotate 'line', 541
    .const 'Sub' $P1361 = "93_1299450582.447" 
    capture_lex $P1361
.annotate 'line', 542
    new $P1346, "Undef"
    .lex "$method", $P1346
    find_lex $P1347, "$long_name"
    set $S1348, $P1347
    substr $S1349, $S1348, 2
    new $P1350, 'String'
    set $P1350, $S1349
    store_lex "$method", $P1350
.annotate 'line', 543
    find_lex $P1353, "$obj"
    find_lex $P1354, "$method"
    $P1355 = "has_method"($P1353, $P1354, 0)
    unless $P1355, unless_1352
    set $P1351, $P1355
    goto unless_1352_end
  unless_1352:
.annotate 'line', 544
    find_lex $P1356, "$obj"
    get_how $P1357, $P1356
    find_lex $P1358, "$obj"
    find_lex $P1359, "$method"
.annotate 'line', 545
    .const 'Sub' $P1361 = "93_1299450582.447" 
    newclosure $P1369, $P1361
    $P1370 = $P1357."add_method"($P1358, $P1359, $P1369)
.annotate 'line', 543
    set $P1351, $P1370
  unless_1352_end:
.annotate 'line', 541
    .return ($P1351)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1360"  :anon :subid("93_1299450582.447") :outer("92_1299450582.447")
    .param pmc param_1362
.annotate 'line', 545
    .lex "self", param_1362
.annotate 'line', 546
    find_lex $P1363, "self"
    find_lex $P1364, "$obj"
    get_what $P1365, $P1364
    find_lex $P1366, "$long_name"
    set $S1367, $P1366
    getattribute $P1368, $P1363, $P1365, $S1367
.annotate 'line', 545
    .return ($P1368)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1304"  :anon :subid("90_1299450582.447") :outer("89_1299450582.447")
.annotate 'line', 529
    .const 'Sub' $P1322 = "91_1299450582.447" 
    capture_lex $P1322
.annotate 'line', 530
    new $P1306, "Undef"
    .lex "$method", $P1306
    find_lex $P1307, "$long_name"
    set $S1308, $P1307
    substr $S1309, $S1308, 1
    new $P1310, 'String'
    set $P1310, $S1309
    store_lex "$method", $P1310
.annotate 'line', 531
    find_lex $P1313, "$obj"
    find_lex $P1314, "$method"
    $P1315 = "has_method"($P1313, $P1314, 0)
    unless $P1315, unless_1312
    set $P1311, $P1315
    goto unless_1312_end
  unless_1312:
.annotate 'line', 532
    find_lex $P1316, "$obj"
    get_how $P1317, $P1316
    find_lex $P1318, "$obj"
    get_what $P1319, $P1318
    find_lex $P1320, "$method"
    .const 'Sub' $P1322 = "91_1299450582.447" 
    newclosure $P1341, $P1322
    $P1342 = $P1317."add_method"($P1319, $P1320, $P1341)
.annotate 'line', 531
    set $P1311, $P1342
  unless_1312_end:
.annotate 'line', 529
    .return ($P1311)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "_block1321"  :anon :subid("91_1299450582.447") :outer("90_1299450582.447")
    .param pmc param_1323
    .param pmc param_1324 :optional
    .param int has_param_1324 :opt_flag
.annotate 'line', 532
    .lex "self", param_1323
    if has_param_1324, optparam_320
    new $P1325, "Undef"
    set param_1324, $P1325
  optparam_320:
    .lex "$value", param_1324
.annotate 'line', 534
    find_lex $P1327, "$value"
    defined $I1328, $P1327
    unless $I1328, if_1326_end
.annotate 'line', 533
    find_lex $P1329, "self"
    find_lex $P1330, "$obj"
    get_what $P1331, $P1330
    find_lex $P1332, "$long_name"
    set $S1333, $P1332
    find_lex $P1334, "$value"
    setattribute $P1329, $P1331, $S1333, $P1334
  if_1326_end:
.annotate 'line', 536
    find_lex $P1335, "self"
    find_lex $P1336, "$obj"
    get_what $P1337, $P1336
    find_lex $P1338, "$long_name"
    set $S1339, $P1338
    getattribute $P1340, $P1335, $P1337, $S1339
.annotate 'line', 532
    .return ($P1340)
.end


.HLL "nqp"

.namespace ["NQPAttribute"]
.sub "has_mutator"  :subid("94_1299450582.447") :outer("81_1299450582.447")
    .param pmc param_1373
.annotate 'line', 554
    .lex "self", param_1373
.annotate 'line', 555
    find_lex $P1374, "self"
    get_global $P1375, "$?CLASS"
    getattribute $P1376, $P1374, $P1375, "$!name"
    unless_null $P1376, vivify_321
    new $P1376, "Undef"
  vivify_321:
    set $S1377, $P1376
    substr $S1378, $S1377, 1, 1
    isne $I1379, $S1378, "!"
.annotate 'line', 554
    .return ($I1379)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1410"  :subid("96_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 571
    .const 'Sub' $P1666 = "117_1299450582.447" 
    capture_lex $P1666
    .const 'Sub' $P1658 = "116_1299450582.447" 
    capture_lex $P1658
    .const 'Sub' $P1652 = "115_1299450582.447" 
    capture_lex $P1652
    .const 'Sub' $P1630 = "113_1299450582.447" 
    capture_lex $P1630
    .const 'Sub' $P1624 = "112_1299450582.447" 
    capture_lex $P1624
    .const 'Sub' $P1618 = "111_1299450582.447" 
    capture_lex $P1618
    .const 'Sub' $P1612 = "110_1299450582.447" 
    capture_lex $P1612
    .const 'Sub' $P1590 = "108_1299450582.447" 
    capture_lex $P1590
    .const 'Sub' $P1541 = "106_1299450582.447" 
    capture_lex $P1541
    .const 'Sub' $P1528 = "105_1299450582.447" 
    capture_lex $P1528
    .const 'Sub' $P1515 = "104_1299450582.447" 
    capture_lex $P1515
    .const 'Sub' $P1511 = "103_1299450582.447" 
    capture_lex $P1511
    .const 'Sub' $P1490 = "102_1299450582.447" 
    capture_lex $P1490
    .const 'Sub' $P1469 = "101_1299450582.447" 
    capture_lex $P1469
    .const 'Sub' $P1450 = "100_1299450582.447" 
    capture_lex $P1450
    .const 'Sub' $P1434 = "99_1299450582.447" 
    capture_lex $P1434
    .const 'Sub' $P1424 = "98_1299450582.447" 
    capture_lex $P1424
    .const 'Sub' $P1413 = "97_1299450582.447" 
    capture_lex $P1413
    get_global $P1412, "$?CLASS"
.annotate 'line', 710
    .const 'Sub' $P1658 = "116_1299450582.447" 
    newclosure $P1664, $P1658
.annotate 'line', 571
    .return ($P1664)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "" :load :init :subid("post322") :outer("96_1299450582.447")
.annotate 'line', 571
    get_hll_global $P1411, ["NQPConcreteRoleHOW"], "_block1410" 
    .local pmc block
    set block, $P1411
    .const 'Sub' $P1666 = "117_1299450582.447" 
    capture_lex $P1666
    $P1666()
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1665"  :anon :subid("117_1299450582.447") :outer("96_1299450582.447")
.annotate 'line', 571
    get_hll_global $P1667, "KnowHOW"
    $P1668 = $P1667."new_type"("NQPConcreteRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P1668
    set_hll_global "NQPConcreteRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1669, type_obj
    get_hll_global $P1670, "KnowHOWAttribute"
    $P1671 = $P1670."new"("$!name" :named("name"))
    $P1669."add_attribute"(type_obj, $P1671)
    get_how $P1672, type_obj
    get_hll_global $P1673, "KnowHOWAttribute"
    $P1674 = $P1673."new"("$!instance_of" :named("name"))
    $P1672."add_attribute"(type_obj, $P1674)
    get_how $P1675, type_obj
    get_hll_global $P1676, "KnowHOWAttribute"
    $P1677 = $P1676."new"("%!attributes" :named("name"))
    $P1675."add_attribute"(type_obj, $P1677)
    get_how $P1678, type_obj
    get_hll_global $P1679, "KnowHOWAttribute"
    $P1680 = $P1679."new"("%!methods" :named("name"))
    $P1678."add_attribute"(type_obj, $P1680)
    get_how $P1681, type_obj
    get_hll_global $P1682, "KnowHOWAttribute"
    $P1683 = $P1682."new"("@!multi_methods_to_incorporate" :named("name"))
    $P1681."add_attribute"(type_obj, $P1683)
    get_how $P1684, type_obj
    get_hll_global $P1685, "KnowHOWAttribute"
    $P1686 = $P1685."new"("@!collisions" :named("name"))
    $P1684."add_attribute"(type_obj, $P1686)
    get_how $P1687, type_obj
    get_hll_global $P1688, "KnowHOWAttribute"
    $P1689 = $P1688."new"("@!roles" :named("name"))
    $P1687."add_attribute"(type_obj, $P1689)
    get_how $P1690, type_obj
    get_hll_global $P1691, "KnowHOWAttribute"
    $P1692 = $P1691."new"("@!done" :named("name"))
    $P1690."add_attribute"(type_obj, $P1692)
    get_how $P1693, type_obj
    get_hll_global $P1694, "KnowHOWAttribute"
    $P1695 = $P1694."new"("$!composed" :named("name"))
    $P1693."add_attribute"(type_obj, $P1695)
    get_how $P1696, type_obj
    .const 'Sub' $P1697 = "97_1299450582.447" 
    $P1696."add_method"(type_obj, "new", $P1697)
    get_how $P1698, type_obj
    .const 'Sub' $P1699 = "98_1299450582.447" 
    $P1698."add_method"(type_obj, "BUILD", $P1699)
    get_how $P1700, type_obj
    .const 'Sub' $P1701 = "99_1299450582.447" 
    $P1700."add_method"(type_obj, "new_type", $P1701)
    get_how $P1702, type_obj
    .const 'Sub' $P1703 = "100_1299450582.447" 
    $P1702."add_method"(type_obj, "add_method", $P1703)
    get_how $P1704, type_obj
    .const 'Sub' $P1705 = "101_1299450582.447" 
    $P1704."add_method"(type_obj, "add_multi_method", $P1705)
    get_how $P1706, type_obj
    .const 'Sub' $P1707 = "102_1299450582.447" 
    $P1706."add_method"(type_obj, "add_attribute", $P1707)
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "103_1299450582.447" 
    $P1708."add_method"(type_obj, "add_parent", $P1709)
    get_how $P1710, type_obj
    .const 'Sub' $P1711 = "104_1299450582.447" 
    $P1710."add_method"(type_obj, "add_role", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "105_1299450582.447" 
    $P1712."add_method"(type_obj, "add_collision", $P1713)
    get_how $P1714, type_obj
    .const 'Sub' $P1715 = "106_1299450582.447" 
    $P1714."add_method"(type_obj, "compose", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "108_1299450582.447" 
    $P1716."add_method"(type_obj, "methods", $P1717)
    get_how $P1718, type_obj
    .const 'Sub' $P1719 = "110_1299450582.447" 
    $P1718."add_method"(type_obj, "method_table", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "111_1299450582.447" 
    $P1720."add_method"(type_obj, "collisions", $P1721)
    get_how $P1722, type_obj
    .const 'Sub' $P1723 = "112_1299450582.447" 
    $P1722."add_method"(type_obj, "name", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "113_1299450582.447" 
    $P1724."add_method"(type_obj, "attributes", $P1725)
    get_how $P1726, type_obj
    .const 'Sub' $P1727 = "115_1299450582.447" 
    $P1726."add_method"(type_obj, "roles", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "116_1299450582.447" 
    $P1728."add_method"(type_obj, "instance_of", $P1729)
    get_how $P1730, type_obj
    $P1731 = $P1730."compose"(type_obj)
    .return ($P1731)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "new"  :subid("97_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1414
    .param pmc param_1415 :named("name")
    .param pmc param_1416 :named("instance_of")
.annotate 'line', 603
    .lex "self", param_1414
    .lex "$name", param_1415
    .lex "$instance_of", param_1416
.annotate 'line', 604
    new $P1417, "Undef"
    .lex "$obj", $P1417
    find_lex $P1418, "self"
    repr_instance_of $P1419, $P1418
    store_lex "$obj", $P1419
.annotate 'line', 605
    find_lex $P1420, "$obj"
    find_lex $P1421, "$name"
    find_lex $P1422, "$instance_of"
    $P1420."BUILD"($P1421 :named("name"), $P1422 :named("instance_of"))
    find_lex $P1423, "$obj"
.annotate 'line', 603
    .return ($P1423)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "BUILD"  :subid("98_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1425
    .param pmc param_1426 :named("name")
    .param pmc param_1427 :named("instance_of")
.annotate 'line', 609
    .lex "self", param_1425
    .lex "$name", param_1426
    .lex "$instance_of", param_1427
.annotate 'line', 610
    find_lex $P1428, "$name"
    find_lex $P1429, "self"
    get_global $P1430, "$?CLASS"
    setattribute $P1429, $P1430, "$!name", $P1428
.annotate 'line', 611
    find_lex $P1431, "$instance_of"
    find_lex $P1432, "self"
    get_global $P1433, "$?CLASS"
    setattribute $P1432, $P1433, "$!instance_of", $P1431
.annotate 'line', 609
    .return ($P1431)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "new_type"  :subid("99_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1435
    .param pmc param_1440 :named("instance_of")
    .param pmc param_1436 :optional :named("name")
    .param int has_param_1436 :opt_flag
    .param pmc param_1438 :optional :named("repr")
    .param int has_param_1438 :opt_flag
.annotate 'line', 616
    .lex "self", param_1435
    if has_param_1436, optparam_323
    new $P1437, "String"
    assign $P1437, "<anon>"
    set param_1436, $P1437
  optparam_323:
    .lex "$name", param_1436
    if has_param_1438, optparam_324
    new $P1439, "String"
    assign $P1439, "P6opaque"
    set param_1438, $P1439
  optparam_324:
    .lex "$repr", param_1438
    .lex "$instance_of", param_1440
.annotate 'line', 617
    new $P1441, "Undef"
    .lex "$metarole", $P1441
    find_lex $P1442, "self"
    find_lex $P1443, "$name"
    find_lex $P1444, "$instance_of"
    $P1445 = $P1442."new"($P1443 :named("name"), $P1444 :named("instance_of"))
    store_lex "$metarole", $P1445
.annotate 'line', 618
    find_lex $P1446, "$metarole"
    find_lex $P1447, "$repr"
    set $S1448, $P1447
    repr_type_object_for $P1449, $P1446, $S1448
.annotate 'line', 616
    .return ($P1449)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_method"  :subid("100_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1451
    .param pmc param_1452
    .param pmc param_1453
    .param pmc param_1454
.annotate 'line', 621
    .lex "self", param_1451
    .lex "$obj", param_1452
    .lex "$name", param_1453
    .lex "$code_obj", param_1454
.annotate 'line', 622
    find_lex $P1456, "$name"
    find_lex $P1457, "self"
    get_global $P1458, "$?CLASS"
    getattribute $P1459, $P1457, $P1458, "%!methods"
    unless_null $P1459, vivify_325
    $P1459 = root_new ['parrot';'Hash']
  vivify_325:
    set $P1460, $P1459[$P1456]
    unless_null $P1460, vivify_326
    new $P1460, "Undef"
  vivify_326:
    unless $P1460, if_1455_end
.annotate 'line', 623
    new $P1461, "String"
    assign $P1461, "This role already has a method named "
    find_lex $P1462, "$name"
    concat $P1463, $P1461, $P1462
    die $P1463
  if_1455_end:
.annotate 'line', 625
    find_lex $P1464, "$code_obj"
    find_lex $P1465, "$name"
    find_lex $P1466, "self"
    get_global $P1467, "$?CLASS"
    getattribute $P1468, $P1466, $P1467, "%!methods"
    unless_null $P1468, vivify_327
    $P1468 = root_new ['parrot';'Hash']
    setattribute $P1466, $P1467, "%!methods", $P1468
  vivify_327:
    set $P1468[$P1465], $P1464
.annotate 'line', 621
    .return ($P1464)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_multi_method"  :subid("101_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1470
    .param pmc param_1471
    .param pmc param_1472
    .param pmc param_1473
.annotate 'line', 628
    .lex "self", param_1470
    .lex "$obj", param_1471
    .lex "$name", param_1472
    .lex "$code_obj", param_1473
.annotate 'line', 629
    $P1474 = root_new ['parrot';'Hash']
    .lex "%todo", $P1474
.annotate 'line', 628
    find_lex $P1475, "%todo"
.annotate 'line', 630
    find_lex $P1476, "$name"
    find_lex $P1477, "%todo"
    unless_null $P1477, vivify_328
    $P1477 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1477
  vivify_328:
    set $P1477["name"], $P1476
.annotate 'line', 631
    find_lex $P1478, "$code_obj"
    find_lex $P1479, "%todo"
    unless_null $P1479, vivify_329
    $P1479 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1479
  vivify_329:
    set $P1479["code"], $P1478
.annotate 'line', 632
    find_lex $P1480, "%todo"
    find_lex $P1481, "self"
    get_global $P1482, "$?CLASS"
    getattribute $P1483, $P1481, $P1482, "@!multi_methods_to_incorporate"
    unless_null $P1483, vivify_330
    $P1483 = root_new ['parrot';'ResizablePMCArray']
  vivify_330:
    set $N1484, $P1483
    set $I1485, $N1484
    find_lex $P1486, "self"
    get_global $P1487, "$?CLASS"
    getattribute $P1488, $P1486, $P1487, "@!multi_methods_to_incorporate"
    unless_null $P1488, vivify_331
    $P1488 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1486, $P1487, "@!multi_methods_to_incorporate", $P1488
  vivify_331:
    set $P1488[$I1485], $P1480
    find_lex $P1489, "$code_obj"
.annotate 'line', 628
    .return ($P1489)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_attribute"  :subid("102_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1491
    .param pmc param_1492
    .param pmc param_1493
.annotate 'line', 636
    .lex "self", param_1491
    .lex "$obj", param_1492
    .lex "$meta_attr", param_1493
.annotate 'line', 637
    new $P1494, "Undef"
    .lex "$name", $P1494
    find_lex $P1495, "$meta_attr"
    $P1496 = $P1495."name"()
    store_lex "$name", $P1496
.annotate 'line', 638
    find_lex $P1498, "$name"
    find_lex $P1499, "self"
    get_global $P1500, "$?CLASS"
    getattribute $P1501, $P1499, $P1500, "%!attributes"
    unless_null $P1501, vivify_332
    $P1501 = root_new ['parrot';'Hash']
  vivify_332:
    set $P1502, $P1501[$P1498]
    unless_null $P1502, vivify_333
    new $P1502, "Undef"
  vivify_333:
    unless $P1502, if_1497_end
.annotate 'line', 639
    new $P1503, "String"
    assign $P1503, "This role already has an attribute named "
    find_lex $P1504, "$name"
    concat $P1505, $P1503, $P1504
    die $P1505
  if_1497_end:
.annotate 'line', 641
    find_lex $P1506, "$meta_attr"
    find_lex $P1507, "$name"
    find_lex $P1508, "self"
    get_global $P1509, "$?CLASS"
    getattribute $P1510, $P1508, $P1509, "%!attributes"
    unless_null $P1510, vivify_334
    $P1510 = root_new ['parrot';'Hash']
    setattribute $P1508, $P1509, "%!attributes", $P1510
  vivify_334:
    set $P1510[$P1507], $P1506
.annotate 'line', 636
    .return ($P1506)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_parent"  :subid("103_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1512
    .param pmc param_1513
    .param pmc param_1514
.annotate 'line', 644
    .lex "self", param_1512
    .lex "$obj", param_1513
    .lex "$parent", param_1514
.annotate 'line', 645
    die "A role cannot inherit from a class in NQP"
.annotate 'line', 644
    .return ()
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_role"  :subid("104_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1516
    .param pmc param_1517
    .param pmc param_1518
.annotate 'line', 648
    .lex "self", param_1516
    .lex "$obj", param_1517
    .lex "$role", param_1518
.annotate 'line', 649
    find_lex $P1519, "$role"
    find_lex $P1520, "self"
    get_global $P1521, "$?CLASS"
    getattribute $P1522, $P1520, $P1521, "@!roles"
    unless_null $P1522, vivify_335
    $P1522 = root_new ['parrot';'ResizablePMCArray']
  vivify_335:
    set $N1523, $P1522
    set $I1524, $N1523
    find_lex $P1525, "self"
    get_global $P1526, "$?CLASS"
    getattribute $P1527, $P1525, $P1526, "@!roles"
    unless_null $P1527, vivify_336
    $P1527 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1525, $P1526, "@!roles", $P1527
  vivify_336:
    set $P1527[$I1524], $P1519
.annotate 'line', 648
    .return ($P1519)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "add_collision"  :subid("105_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1529
    .param pmc param_1530
    .param pmc param_1531
.annotate 'line', 652
    .lex "self", param_1529
    .lex "$obj", param_1530
    .lex "$colliding_name", param_1531
.annotate 'line', 653
    find_lex $P1532, "$colliding_name"
    find_lex $P1533, "self"
    get_global $P1534, "$?CLASS"
    getattribute $P1535, $P1533, $P1534, "@!collisions"
    unless_null $P1535, vivify_337
    $P1535 = root_new ['parrot';'ResizablePMCArray']
  vivify_337:
    set $N1536, $P1535
    set $I1537, $N1536
    find_lex $P1538, "self"
    get_global $P1539, "$?CLASS"
    getattribute $P1540, $P1538, $P1539, "@!collisions"
    unless_null $P1540, vivify_338
    $P1540 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1538, $P1539, "@!collisions", $P1540
  vivify_338:
    set $P1540[$I1537], $P1532
.annotate 'line', 652
    .return ($P1532)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "compose"  :subid("106_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1542
    .param pmc param_1543
.annotate 'line', 657
    .const 'Sub' $P1555 = "107_1299450582.447" 
    capture_lex $P1555
    .lex "self", param_1542
    .lex "$obj", param_1543
.annotate 'line', 660
    find_lex $P1545, "self"
    get_global $P1546, "$?CLASS"
    getattribute $P1547, $P1545, $P1546, "@!roles"
    unless_null $P1547, vivify_339
    $P1547 = root_new ['parrot';'ResizablePMCArray']
  vivify_339:
    unless $P1547, if_1544_end
.annotate 'line', 661
    find_lex $P1549, "self"
    get_global $P1550, "$?CLASS"
    getattribute $P1551, $P1549, $P1550, "@!roles"
    unless_null $P1551, vivify_340
    $P1551 = root_new ['parrot';'ResizablePMCArray']
  vivify_340:
    defined $I1552, $P1551
    unless $I1552, for_undef_341
    iter $P1548, $P1551
    new $P1579, 'ExceptionHandler'
    set_label $P1579, loop1578_handler
    $P1579."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1579
  loop1578_test:
    unless $P1548, loop1578_done
    shift $P1553, $P1548
  loop1578_redo:
    .const 'Sub' $P1555 = "107_1299450582.447" 
    capture_lex $P1555
    $P1555($P1553)
  loop1578_next:
    goto loop1578_test
  loop1578_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1580, exception, 'type'
    eq $P1580, .CONTROL_LOOP_NEXT, loop1578_next
    eq $P1580, .CONTROL_LOOP_REDO, loop1578_redo
  loop1578_done:
    pop_eh 
  for_undef_341:
.annotate 'line', 665
    get_hll_global $P1581, "RoleToRoleApplier"
    find_lex $P1582, "$obj"
    find_lex $P1583, "self"
    get_global $P1584, "$?CLASS"
    getattribute $P1585, $P1583, $P1584, "@!roles"
    unless_null $P1585, vivify_346
    $P1585 = root_new ['parrot';'ResizablePMCArray']
  vivify_346:
    $P1581."apply"($P1582, $P1585)
  if_1544_end:
.annotate 'line', 669
    new $P1586, "Integer"
    assign $P1586, 1
    find_lex $P1587, "self"
    get_global $P1588, "$?CLASS"
    setattribute $P1587, $P1588, "$!composed", $P1586
    find_lex $P1589, "$obj"
.annotate 'line', 657
    .return ($P1589)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1554"  :anon :subid("107_1299450582.447") :outer("106_1299450582.447")
    .param pmc param_1556
.annotate 'line', 661
    .lex "$_", param_1556
.annotate 'line', 662
    find_lex $P1557, "$_"
    find_lex $P1558, "self"
    get_global $P1559, "$?CLASS"
    getattribute $P1560, $P1558, $P1559, "@!done"
    unless_null $P1560, vivify_342
    $P1560 = root_new ['parrot';'ResizablePMCArray']
  vivify_342:
    set $N1561, $P1560
    set $I1562, $N1561
    find_lex $P1563, "self"
    get_global $P1564, "$?CLASS"
    getattribute $P1565, $P1563, $P1564, "@!done"
    unless_null $P1565, vivify_343
    $P1565 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1563, $P1564, "@!done", $P1565
  vivify_343:
    set $P1565[$I1562], $P1557
.annotate 'line', 663
    find_lex $P1566, "$_"
    get_how $P1567, $P1566
    find_lex $P1568, "$_"
    $P1569 = $P1567."instance_of"($P1568)
    find_lex $P1570, "self"
    get_global $P1571, "$?CLASS"
    getattribute $P1572, $P1570, $P1571, "@!done"
    unless_null $P1572, vivify_344
    $P1572 = root_new ['parrot';'ResizablePMCArray']
  vivify_344:
    set $N1573, $P1572
    set $I1574, $N1573
    find_lex $P1575, "self"
    get_global $P1576, "$?CLASS"
    getattribute $P1577, $P1575, $P1576, "@!done"
    unless_null $P1577, vivify_345
    $P1577 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1575, $P1576, "@!done", $P1577
  vivify_345:
    set $P1577[$I1574], $P1569
.annotate 'line', 661
    .return ($P1569)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("108_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1591
    .param pmc param_1592
.annotate 'line', 678
    .const 'Sub' $P1602 = "109_1299450582.447" 
    capture_lex $P1602
    .lex "self", param_1591
    .lex "$obj", param_1592
.annotate 'line', 679
    $P1593 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1593
.annotate 'line', 678
    find_lex $P1594, "@meths"
.annotate 'line', 680
    find_lex $P1596, "self"
    get_global $P1597, "$?CLASS"
    getattribute $P1598, $P1596, $P1597, "%!methods"
    unless_null $P1598, vivify_347
    $P1598 = root_new ['parrot';'Hash']
  vivify_347:
    defined $I1599, $P1598
    unless $I1599, for_undef_348
    iter $P1595, $P1598
    new $P1609, 'ExceptionHandler'
    set_label $P1609, loop1608_handler
    $P1609."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1609
  loop1608_test:
    unless $P1595, loop1608_done
    shift $P1600, $P1595
  loop1608_redo:
    .const 'Sub' $P1602 = "109_1299450582.447" 
    capture_lex $P1602
    $P1602($P1600)
  loop1608_next:
    goto loop1608_test
  loop1608_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1610, exception, 'type'
    eq $P1610, .CONTROL_LOOP_NEXT, loop1608_next
    eq $P1610, .CONTROL_LOOP_REDO, loop1608_redo
  loop1608_done:
    pop_eh 
  for_undef_348:
    find_lex $P1611, "@meths"
.annotate 'line', 678
    .return ($P1611)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1601"  :anon :subid("109_1299450582.447") :outer("108_1299450582.447")
    .param pmc param_1603
.annotate 'line', 680
    .lex "$_", param_1603
.annotate 'line', 681
    find_lex $P1604, "@meths"
    find_lex $P1605, "$_"
    $P1606 = $P1605."value"()
    $P1607 = $P1604."push"($P1606)
.annotate 'line', 680
    .return ($P1607)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "method_table"  :subid("110_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1613
    .param pmc param_1614
.annotate 'line', 686
    .lex "self", param_1613
    .lex "$obj", param_1614
    find_lex $P1615, "self"
    get_global $P1616, "$?CLASS"
    getattribute $P1617, $P1615, $P1616, "%!methods"
    unless_null $P1617, vivify_349
    $P1617 = root_new ['parrot';'Hash']
  vivify_349:
    .return ($P1617)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "collisions"  :subid("111_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1619
    .param pmc param_1620
.annotate 'line', 690
    .lex "self", param_1619
    .lex "$obj", param_1620
    find_lex $P1621, "self"
    get_global $P1622, "$?CLASS"
    getattribute $P1623, $P1621, $P1622, "@!collisions"
    unless_null $P1623, vivify_350
    $P1623 = root_new ['parrot';'ResizablePMCArray']
  vivify_350:
    .return ($P1623)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "name"  :subid("112_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1625
    .param pmc param_1626
.annotate 'line', 694
    .lex "self", param_1625
    .lex "$obj", param_1626
    find_lex $P1627, "self"
    get_global $P1628, "$?CLASS"
    getattribute $P1629, $P1627, $P1628, "$!name"
    unless_null $P1629, vivify_351
    new $P1629, "Undef"
  vivify_351:
    .return ($P1629)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("113_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1631
    .param pmc param_1632
.annotate 'line', 698
    .const 'Sub' $P1642 = "114_1299450582.447" 
    capture_lex $P1642
    .lex "self", param_1631
    .lex "$obj", param_1632
.annotate 'line', 699
    $P1633 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P1633
.annotate 'line', 698
    find_lex $P1634, "@attrs"
.annotate 'line', 700
    find_lex $P1636, "self"
    get_global $P1637, "$?CLASS"
    getattribute $P1638, $P1636, $P1637, "%!attributes"
    unless_null $P1638, vivify_352
    $P1638 = root_new ['parrot';'Hash']
  vivify_352:
    defined $I1639, $P1638
    unless $I1639, for_undef_353
    iter $P1635, $P1638
    new $P1649, 'ExceptionHandler'
    set_label $P1649, loop1648_handler
    $P1649."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1649
  loop1648_test:
    unless $P1635, loop1648_done
    shift $P1640, $P1635
  loop1648_redo:
    .const 'Sub' $P1642 = "114_1299450582.447" 
    capture_lex $P1642
    $P1642($P1640)
  loop1648_next:
    goto loop1648_test
  loop1648_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1650, exception, 'type'
    eq $P1650, .CONTROL_LOOP_NEXT, loop1648_next
    eq $P1650, .CONTROL_LOOP_REDO, loop1648_redo
  loop1648_done:
    pop_eh 
  for_undef_353:
    find_lex $P1651, "@attrs"
.annotate 'line', 698
    .return ($P1651)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "_block1641"  :anon :subid("114_1299450582.447") :outer("113_1299450582.447")
    .param pmc param_1643
.annotate 'line', 700
    .lex "$_", param_1643
.annotate 'line', 701
    find_lex $P1644, "@attrs"
    find_lex $P1645, "$_"
    $P1646 = $P1645."value"()
    $P1647 = $P1644."push"($P1646)
.annotate 'line', 700
    .return ($P1647)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "roles"  :subid("115_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1653
    .param pmc param_1654
.annotate 'line', 706
    .lex "self", param_1653
    .lex "$obj", param_1654
    find_lex $P1655, "self"
    get_global $P1656, "$?CLASS"
    getattribute $P1657, $P1655, $P1656, "@!roles"
    unless_null $P1657, vivify_354
    $P1657 = root_new ['parrot';'ResizablePMCArray']
  vivify_354:
    .return ($P1657)
.end


.HLL "nqp"

.namespace ["NQPConcreteRoleHOW"]
.sub "instance_of"  :subid("116_1299450582.447") :outer("96_1299450582.447")
    .param pmc param_1659
    .param pmc param_1660
.annotate 'line', 710
    .lex "self", param_1659
    .lex "$obj", param_1660
    find_lex $P1661, "self"
    get_global $P1662, "$?CLASS"
    getattribute $P1663, $P1661, $P1662, "$!instance_of"
    unless_null $P1663, vivify_355
    new $P1663, "Undef"
  vivify_355:
    .return ($P1663)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1732"  :subid("118_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 720
    .const 'Sub' $P2030 = "141_1299450582.447" 
    capture_lex $P2030
    .const 'Sub' $P2022 = "140_1299450582.447" 
    capture_lex $P2022
    .const 'Sub' $P2000 = "138_1299450582.447" 
    capture_lex $P2000
    .const 'Sub' $P1994 = "137_1299450582.447" 
    capture_lex $P1994
    .const 'Sub' $P1988 = "136_1299450582.447" 
    capture_lex $P1988
    .const 'Sub' $P1966 = "134_1299450582.447" 
    capture_lex $P1966
    .const 'Sub' $P1860 = "129_1299450582.447" 
    capture_lex $P1860
    .const 'Sub' $P1857 = "128_1299450582.447" 
    capture_lex $P1857
    .const 'Sub' $P1850 = "127_1299450582.447" 
    capture_lex $P1850
    .const 'Sub' $P1837 = "126_1299450582.447" 
    capture_lex $P1837
    .const 'Sub' $P1833 = "125_1299450582.447" 
    capture_lex $P1833
    .const 'Sub' $P1812 = "124_1299450582.447" 
    capture_lex $P1812
    .const 'Sub' $P1791 = "123_1299450582.447" 
    capture_lex $P1791
    .const 'Sub' $P1772 = "122_1299450582.447" 
    capture_lex $P1772
    .const 'Sub' $P1756 = "121_1299450582.447" 
    capture_lex $P1756
    .const 'Sub' $P1746 = "120_1299450582.447" 
    capture_lex $P1746
    .const 'Sub' $P1735 = "119_1299450582.447" 
    capture_lex $P1735
    get_global $P1734, "$?CLASS"
.annotate 'line', 880
    .const 'Sub' $P2022 = "140_1299450582.447" 
    newclosure $P2028, $P2022
.annotate 'line', 720
    .return ($P2028)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "" :load :init :subid("post356") :outer("118_1299450582.447")
.annotate 'line', 720
    get_hll_global $P1733, ["NQPParametricRoleHOW"], "_block1732" 
    .local pmc block
    set block, $P1733
    .const 'Sub' $P2030 = "141_1299450582.447" 
    capture_lex $P2030
    $P2030()
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block2029"  :anon :subid("141_1299450582.447") :outer("118_1299450582.447")
.annotate 'line', 720
    get_hll_global $P2031, "KnowHOW"
    $P2032 = $P2031."new_type"("NQPParametricRoleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2032
    set_hll_global "NQPParametricRoleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2033, type_obj
    get_hll_global $P2034, "KnowHOWAttribute"
    $P2035 = $P2034."new"("$!name" :named("name"))
    $P2033."add_attribute"(type_obj, $P2035)
    get_how $P2036, type_obj
    get_hll_global $P2037, "KnowHOWAttribute"
    $P2038 = $P2037."new"("%!attributes" :named("name"))
    $P2036."add_attribute"(type_obj, $P2038)
    get_how $P2039, type_obj
    get_hll_global $P2040, "KnowHOWAttribute"
    $P2041 = $P2040."new"("%!methods" :named("name"))
    $P2039."add_attribute"(type_obj, $P2041)
    get_how $P2042, type_obj
    get_hll_global $P2043, "KnowHOWAttribute"
    $P2044 = $P2043."new"("@!multi_methods_to_incorporate" :named("name"))
    $P2042."add_attribute"(type_obj, $P2044)
    get_how $P2045, type_obj
    get_hll_global $P2046, "KnowHOWAttribute"
    $P2047 = $P2046."new"("@!roles" :named("name"))
    $P2045."add_attribute"(type_obj, $P2047)
    get_how $P2048, type_obj
    get_hll_global $P2049, "KnowHOWAttribute"
    $P2050 = $P2049."new"("$!composed" :named("name"))
    $P2048."add_attribute"(type_obj, $P2050)
    get_how $P2051, type_obj
    get_hll_global $P2052, "KnowHOWAttribute"
    $P2053 = $P2052."new"("$!body_block" :named("name"))
    $P2051."add_attribute"(type_obj, $P2053)
    get_how $P2054, type_obj
    .const 'Sub' $P2055 = "119_1299450582.447" 
    $P2054."add_method"(type_obj, "new", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "120_1299450582.447" 
    $P2056."add_method"(type_obj, "BUILD", $P2057)
    get_how $P2058, type_obj
    .const 'Sub' $P2059 = "121_1299450582.447" 
    $P2058."add_method"(type_obj, "new_type", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "122_1299450582.447" 
    $P2060."add_method"(type_obj, "add_method", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "123_1299450582.447" 
    $P2062."add_method"(type_obj, "add_multi_method", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "124_1299450582.447" 
    $P2064."add_method"(type_obj, "add_attribute", $P2065)
    get_how $P2066, type_obj
    .const 'Sub' $P2067 = "125_1299450582.447" 
    $P2066."add_method"(type_obj, "add_parent", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "126_1299450582.447" 
    $P2068."add_method"(type_obj, "add_role", $P2069)
    get_how $P2070, type_obj
    .const 'Sub' $P2071 = "127_1299450582.447" 
    $P2070."add_method"(type_obj, "compose", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "128_1299450582.447" 
    $P2072."add_method"(type_obj, "parametric", $P2073)
    get_how $P2074, type_obj
    .const 'Sub' $P2075 = "129_1299450582.447" 
    $P2074."add_method"(type_obj, "instantiate", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "134_1299450582.447" 
    $P2076."add_method"(type_obj, "methods", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "136_1299450582.447" 
    $P2078."add_method"(type_obj, "method_table", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "137_1299450582.447" 
    $P2080."add_method"(type_obj, "name", $P2081)
    get_how $P2082, type_obj
    .const 'Sub' $P2083 = "138_1299450582.447" 
    $P2082."add_method"(type_obj, "attributes", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "140_1299450582.447" 
    $P2084."add_method"(type_obj, "roles", $P2085)
    get_how $P2086, type_obj
    $P2087 = $P2086."compose"(type_obj)
    .return ($P2087)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "new"  :subid("119_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1736
    .param pmc param_1737 :named("name")
    .param pmc param_1738 :named("body_block")
.annotate 'line', 750
    .lex "self", param_1736
    .lex "$name", param_1737
    .lex "$body_block", param_1738
.annotate 'line', 751
    new $P1739, "Undef"
    .lex "$obj", $P1739
    find_lex $P1740, "self"
    repr_instance_of $P1741, $P1740
    store_lex "$obj", $P1741
.annotate 'line', 752
    find_lex $P1742, "$obj"
    find_lex $P1743, "$name"
    find_lex $P1744, "$body_block"
    $P1742."BUILD"($P1743 :named("name"), $P1744 :named("body_block"))
    find_lex $P1745, "$obj"
.annotate 'line', 750
    .return ($P1745)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "BUILD"  :subid("120_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1747
    .param pmc param_1748 :named("name")
    .param pmc param_1749 :named("body_block")
.annotate 'line', 756
    .lex "self", param_1747
    .lex "$name", param_1748
    .lex "$body_block", param_1749
.annotate 'line', 757
    find_lex $P1750, "$name"
    find_lex $P1751, "self"
    get_global $P1752, "$?CLASS"
    setattribute $P1751, $P1752, "$!name", $P1750
.annotate 'line', 758
    find_lex $P1753, "$body_block"
    find_lex $P1754, "self"
    get_global $P1755, "$?CLASS"
    setattribute $P1754, $P1755, "$!body_block", $P1753
.annotate 'line', 756
    .return ($P1753)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "new_type"  :subid("121_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1757
    .param pmc param_1758 :named("body_block")
    .param pmc param_1759 :optional :named("name")
    .param int has_param_1759 :opt_flag
    .param pmc param_1761 :optional :named("repr")
    .param int has_param_1761 :opt_flag
.annotate 'line', 763
    .lex "self", param_1757
    .lex "$body_block", param_1758
    if has_param_1759, optparam_357
    new $P1760, "String"
    assign $P1760, "<anon>"
    set param_1759, $P1760
  optparam_357:
    .lex "$name", param_1759
    if has_param_1761, optparam_358
    new $P1762, "String"
    assign $P1762, "P6opaque"
    set param_1761, $P1762
  optparam_358:
    .lex "$repr", param_1761
.annotate 'line', 764
    new $P1763, "Undef"
    .lex "$metarole", $P1763
    find_lex $P1764, "self"
    find_lex $P1765, "$name"
    find_lex $P1766, "$body_block"
    $P1767 = $P1764."new"($P1765 :named("name"), $P1766 :named("body_block"))
    store_lex "$metarole", $P1767
.annotate 'line', 765
    find_lex $P1768, "$metarole"
    find_lex $P1769, "$repr"
    set $S1770, $P1769
    repr_type_object_for $P1771, $P1768, $S1770
.annotate 'line', 763
    .return ($P1771)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_method"  :subid("122_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1773
    .param pmc param_1774
    .param pmc param_1775
    .param pmc param_1776
.annotate 'line', 768
    .lex "self", param_1773
    .lex "$obj", param_1774
    .lex "$name", param_1775
    .lex "$code_obj", param_1776
.annotate 'line', 769
    find_lex $P1778, "$name"
    find_lex $P1779, "self"
    get_global $P1780, "$?CLASS"
    getattribute $P1781, $P1779, $P1780, "%!methods"
    unless_null $P1781, vivify_359
    $P1781 = root_new ['parrot';'Hash']
  vivify_359:
    set $P1782, $P1781[$P1778]
    unless_null $P1782, vivify_360
    new $P1782, "Undef"
  vivify_360:
    unless $P1782, if_1777_end
.annotate 'line', 770
    new $P1783, "String"
    assign $P1783, "This role already has a method named "
    find_lex $P1784, "$name"
    concat $P1785, $P1783, $P1784
    die $P1785
  if_1777_end:
.annotate 'line', 772
    find_lex $P1786, "$code_obj"
    find_lex $P1787, "$name"
    find_lex $P1788, "self"
    get_global $P1789, "$?CLASS"
    getattribute $P1790, $P1788, $P1789, "%!methods"
    unless_null $P1790, vivify_361
    $P1790 = root_new ['parrot';'Hash']
    setattribute $P1788, $P1789, "%!methods", $P1790
  vivify_361:
    set $P1790[$P1787], $P1786
.annotate 'line', 768
    .return ($P1786)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_multi_method"  :subid("123_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1792
    .param pmc param_1793
    .param pmc param_1794
    .param pmc param_1795
.annotate 'line', 775
    .lex "self", param_1792
    .lex "$obj", param_1793
    .lex "$name", param_1794
    .lex "$code_obj", param_1795
.annotate 'line', 776
    $P1796 = root_new ['parrot';'Hash']
    .lex "%todo", $P1796
.annotate 'line', 775
    find_lex $P1797, "%todo"
.annotate 'line', 777
    find_lex $P1798, "$name"
    find_lex $P1799, "%todo"
    unless_null $P1799, vivify_362
    $P1799 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1799
  vivify_362:
    set $P1799["name"], $P1798
.annotate 'line', 778
    find_lex $P1800, "$code_obj"
    find_lex $P1801, "%todo"
    unless_null $P1801, vivify_363
    $P1801 = root_new ['parrot';'Hash']
    store_lex "%todo", $P1801
  vivify_363:
    set $P1801["code"], $P1800
.annotate 'line', 779
    find_lex $P1802, "%todo"
    find_lex $P1803, "self"
    get_global $P1804, "$?CLASS"
    getattribute $P1805, $P1803, $P1804, "@!multi_methods_to_incorporate"
    unless_null $P1805, vivify_364
    $P1805 = root_new ['parrot';'ResizablePMCArray']
  vivify_364:
    set $N1806, $P1805
    set $I1807, $N1806
    find_lex $P1808, "self"
    get_global $P1809, "$?CLASS"
    getattribute $P1810, $P1808, $P1809, "@!multi_methods_to_incorporate"
    unless_null $P1810, vivify_365
    $P1810 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1808, $P1809, "@!multi_methods_to_incorporate", $P1810
  vivify_365:
    set $P1810[$I1807], $P1802
    find_lex $P1811, "$code_obj"
.annotate 'line', 775
    .return ($P1811)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_attribute"  :subid("124_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1813
    .param pmc param_1814
    .param pmc param_1815
.annotate 'line', 783
    .lex "self", param_1813
    .lex "$obj", param_1814
    .lex "$meta_attr", param_1815
.annotate 'line', 784
    new $P1816, "Undef"
    .lex "$name", $P1816
    find_lex $P1817, "$meta_attr"
    $P1818 = $P1817."name"()
    store_lex "$name", $P1818
.annotate 'line', 785
    find_lex $P1820, "$name"
    find_lex $P1821, "self"
    get_global $P1822, "$?CLASS"
    getattribute $P1823, $P1821, $P1822, "%!attributes"
    unless_null $P1823, vivify_366
    $P1823 = root_new ['parrot';'Hash']
  vivify_366:
    set $P1824, $P1823[$P1820]
    unless_null $P1824, vivify_367
    new $P1824, "Undef"
  vivify_367:
    unless $P1824, if_1819_end
.annotate 'line', 786
    new $P1825, "String"
    assign $P1825, "This role already has an attribute named "
    find_lex $P1826, "$name"
    concat $P1827, $P1825, $P1826
    die $P1827
  if_1819_end:
.annotate 'line', 788
    find_lex $P1828, "$meta_attr"
    find_lex $P1829, "$name"
    find_lex $P1830, "self"
    get_global $P1831, "$?CLASS"
    getattribute $P1832, $P1830, $P1831, "%!attributes"
    unless_null $P1832, vivify_368
    $P1832 = root_new ['parrot';'Hash']
    setattribute $P1830, $P1831, "%!attributes", $P1832
  vivify_368:
    set $P1832[$P1829], $P1828
.annotate 'line', 783
    .return ($P1828)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_parent"  :subid("125_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1834
    .param pmc param_1835
    .param pmc param_1836
.annotate 'line', 791
    .lex "self", param_1834
    .lex "$obj", param_1835
    .lex "$parent", param_1836
.annotate 'line', 792
    die "A role cannot inherit from a class"
.annotate 'line', 791
    .return ()
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "add_role"  :subid("126_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1838
    .param pmc param_1839
    .param pmc param_1840
.annotate 'line', 795
    .lex "self", param_1838
    .lex "$obj", param_1839
    .lex "$role", param_1840
.annotate 'line', 796
    find_lex $P1841, "$role"
    find_lex $P1842, "self"
    get_global $P1843, "$?CLASS"
    getattribute $P1844, $P1842, $P1843, "@!roles"
    unless_null $P1844, vivify_369
    $P1844 = root_new ['parrot';'ResizablePMCArray']
  vivify_369:
    set $N1845, $P1844
    set $I1846, $N1845
    find_lex $P1847, "self"
    get_global $P1848, "$?CLASS"
    getattribute $P1849, $P1847, $P1848, "@!roles"
    unless_null $P1849, vivify_370
    $P1849 = root_new ['parrot';'ResizablePMCArray']
    setattribute $P1847, $P1848, "@!roles", $P1849
  vivify_370:
    set $P1849[$I1846], $P1841
.annotate 'line', 795
    .return ($P1841)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "compose"  :subid("127_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1851
    .param pmc param_1852
.annotate 'line', 800
    .lex "self", param_1851
    .lex "$obj", param_1852
.annotate 'line', 801
    new $P1853, "Integer"
    assign $P1853, 1
    find_lex $P1854, "self"
    get_global $P1855, "$?CLASS"
    setattribute $P1854, $P1855, "$!composed", $P1853
    find_lex $P1856, "$obj"
.annotate 'line', 800
    .return ($P1856)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "parametric"  :subid("128_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1858
    .param pmc param_1859
.annotate 'line', 811
    .lex "self", param_1858
    .lex "$obj", param_1859
    .return (1)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "instantiate"  :subid("129_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1863
    .param pmc param_1864
    .param pmc param_1865
.annotate 'line', 817
    .const 'Sub' $P1944 = "133_1299450582.447" 
    capture_lex $P1944
    .const 'Sub' $P1923 = "132_1299450582.447" 
    capture_lex $P1923
    .const 'Sub' $P1902 = "131_1299450582.447" 
    capture_lex $P1902
    .const 'Sub' $P1884 = "130_1299450582.447" 
    capture_lex $P1884
    new $P1862, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P1862, control_1861
    push_eh $P1862
    .lex "self", param_1863
    .lex "$obj", param_1864
    .lex "$class_arg", param_1865
.annotate 'line', 823
    new $P1866, "Undef"
    .lex "$irole", $P1866
.annotate 'line', 820
    find_lex $P1867, "self"
    get_global $P1868, "$?CLASS"
    getattribute $P1869, $P1867, $P1868, "$!body_block"
    unless_null $P1869, vivify_371
    new $P1869, "Undef"
  vivify_371:
    find_lex $P1870, "$class_arg"
    $P1869($P1870)
.annotate 'line', 823
    get_hll_global $P1871, "NQPConcreteRoleHOW"
    find_lex $P1872, "self"
    get_global $P1873, "$?CLASS"
    getattribute $P1874, $P1872, $P1873, "$!name"
    unless_null $P1874, vivify_372
    new $P1874, "Undef"
  vivify_372:
    find_lex $P1875, "$obj"
    $P1876 = $P1871."new_type"($P1874 :named("name"), $P1875 :named("instance_of"))
    store_lex "$irole", $P1876
.annotate 'line', 827
    find_lex $P1878, "self"
    get_global $P1879, "$?CLASS"
    getattribute $P1880, $P1878, $P1879, "%!attributes"
    unless_null $P1880, vivify_373
    $P1880 = root_new ['parrot';'Hash']
  vivify_373:
    defined $I1881, $P1880
    unless $I1881, for_undef_374
    iter $P1877, $P1880
    new $P1893, 'ExceptionHandler'
    set_label $P1893, loop1892_handler
    $P1893."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1893
  loop1892_test:
    unless $P1877, loop1892_done
    shift $P1882, $P1877
  loop1892_redo:
    .const 'Sub' $P1884 = "130_1299450582.447" 
    capture_lex $P1884
    $P1884($P1882)
  loop1892_next:
    goto loop1892_test
  loop1892_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1894, exception, 'type'
    eq $P1894, .CONTROL_LOOP_NEXT, loop1892_next
    eq $P1894, .CONTROL_LOOP_REDO, loop1892_redo
  loop1892_done:
    pop_eh 
  for_undef_374:
.annotate 'line', 833
    find_lex $P1896, "self"
    get_global $P1897, "$?CLASS"
    getattribute $P1898, $P1896, $P1897, "%!methods"
    unless_null $P1898, vivify_375
    $P1898 = root_new ['parrot';'Hash']
  vivify_375:
    defined $I1899, $P1898
    unless $I1899, for_undef_376
    iter $P1895, $P1898
    new $P1914, 'ExceptionHandler'
    set_label $P1914, loop1913_handler
    $P1914."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1914
  loop1913_test:
    unless $P1895, loop1913_done
    shift $P1900, $P1895
  loop1913_redo:
    .const 'Sub' $P1902 = "131_1299450582.447" 
    capture_lex $P1902
    $P1902($P1900)
  loop1913_next:
    goto loop1913_test
  loop1913_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1915, exception, 'type'
    eq $P1915, .CONTROL_LOOP_NEXT, loop1913_next
    eq $P1915, .CONTROL_LOOP_REDO, loop1913_redo
  loop1913_done:
    pop_eh 
  for_undef_376:
.annotate 'line', 836
    find_lex $P1917, "self"
    get_global $P1918, "$?CLASS"
    getattribute $P1919, $P1917, $P1918, "@!multi_methods_to_incorporate"
    unless_null $P1919, vivify_377
    $P1919 = root_new ['parrot';'ResizablePMCArray']
  vivify_377:
    defined $I1920, $P1919
    unless $I1920, for_undef_378
    iter $P1916, $P1919
    new $P1935, 'ExceptionHandler'
    set_label $P1935, loop1934_handler
    $P1935."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1935
  loop1934_test:
    unless $P1916, loop1934_done
    shift $P1921, $P1916
  loop1934_redo:
    .const 'Sub' $P1923 = "132_1299450582.447" 
    capture_lex $P1923
    $P1923($P1921)
  loop1934_next:
    goto loop1934_test
  loop1934_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1936, exception, 'type'
    eq $P1936, .CONTROL_LOOP_NEXT, loop1934_next
    eq $P1936, .CONTROL_LOOP_REDO, loop1934_redo
  loop1934_done:
    pop_eh 
  for_undef_378:
.annotate 'line', 841
    find_lex $P1938, "self"
    get_global $P1939, "$?CLASS"
    getattribute $P1940, $P1938, $P1939, "@!roles"
    unless_null $P1940, vivify_383
    $P1940 = root_new ['parrot';'ResizablePMCArray']
  vivify_383:
    defined $I1941, $P1940
    unless $I1941, for_undef_384
    iter $P1937, $P1940
    new $P1958, 'ExceptionHandler'
    set_label $P1958, loop1957_handler
    $P1958."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1958
  loop1957_test:
    unless $P1937, loop1957_done
    shift $P1942, $P1937
  loop1957_redo:
    .const 'Sub' $P1944 = "133_1299450582.447" 
    capture_lex $P1944
    $P1944($P1942)
  loop1957_next:
    goto loop1957_test
  loop1957_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1959, exception, 'type'
    eq $P1959, .CONTROL_LOOP_NEXT, loop1957_next
    eq $P1959, .CONTROL_LOOP_REDO, loop1957_redo
  loop1957_done:
    pop_eh 
  for_undef_384:
.annotate 'line', 847
    find_lex $P1960, "$irole"
    get_how $P1961, $P1960
    find_lex $P1962, "$irole"
    $P1961."compose"($P1962)
.annotate 'line', 848
    new $P1963, "Exception"
    set $P1963['type'], .CONTROL_RETURN
    find_lex $P1964, "$irole"
    setattribute $P1963, 'payload', $P1964
    throw $P1963
.annotate 'line', 817
    .return ()
  control_1861:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1965, exception, "payload"
    .return ($P1965)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1883"  :anon :subid("130_1299450582.447") :outer("129_1299450582.447")
    .param pmc param_1885
.annotate 'line', 827
    .lex "$_", param_1885
.annotate 'line', 828
    find_lex $P1886, "$irole"
    get_how $P1887, $P1886
    find_lex $P1888, "$irole"
    find_lex $P1889, "$_"
    $P1890 = $P1889."value"()
    $P1891 = $P1887."add_attribute"($P1888, $P1890)
.annotate 'line', 827
    .return ($P1891)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1901"  :anon :subid("131_1299450582.447") :outer("129_1299450582.447")
    .param pmc param_1903
.annotate 'line', 833
    .lex "$_", param_1903
.annotate 'line', 834
    find_lex $P1904, "$irole"
    get_how $P1905, $P1904
    find_lex $P1906, "$irole"
    find_lex $P1907, "$_"
    $P1908 = $P1907."key"()
    find_lex $P1909, "$_"
    $P1910 = $P1909."value"()
    clone $P1911, $P1910
    $P1912 = $P1905."add_method"($P1906, $P1908, $P1911)
.annotate 'line', 833
    .return ($P1912)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1922"  :anon :subid("132_1299450582.447") :outer("129_1299450582.447")
    .param pmc param_1924
.annotate 'line', 836
    .lex "$_", param_1924
.annotate 'line', 837
    find_lex $P1925, "$irole"
    get_how $P1926, $P1925
    find_lex $P1927, "$irole"
    find_lex $P1928, "$_"
    unless_null $P1928, vivify_379
    $P1928 = root_new ['parrot';'Hash']
  vivify_379:
    set $P1929, $P1928["name"]
    unless_null $P1929, vivify_380
    new $P1929, "Undef"
  vivify_380:
    find_lex $P1930, "$_"
    unless_null $P1930, vivify_381
    $P1930 = root_new ['parrot';'Hash']
  vivify_381:
    set $P1931, $P1930["code"]
    unless_null $P1931, vivify_382
    new $P1931, "Undef"
  vivify_382:
    clone $P1932, $P1931
    $P1933 = $P1926."add_multi_method"($P1927, $P1929, $P1932)
.annotate 'line', 836
    .return ($P1933)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1943"  :anon :subid("133_1299450582.447") :outer("129_1299450582.447")
    .param pmc param_1946
.annotate 'line', 842
    new $P1945, "Undef"
    .lex "$instantiated", $P1945
    .lex "$_", param_1946
    find_lex $P1947, "$irole"
    get_how $P1948, $P1947
    find_lex $P1949, "$irole"
    find_lex $P1950, "$class_arg"
    $P1951 = $P1948."instantiate"($P1949, $P1950)
    store_lex "$instantiated", $P1951
.annotate 'line', 843
    find_lex $P1952, "$irole"
    get_how $P1953, $P1952
    find_lex $P1954, "$irole"
    find_lex $P1955, "$instantiated"
    $P1956 = $P1953."add_role"($P1954, $P1955)
.annotate 'line', 841
    .return ($P1956)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "methods"  :subid("134_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1967
    .param pmc param_1968
.annotate 'line', 856
    .const 'Sub' $P1978 = "135_1299450582.447" 
    capture_lex $P1978
    .lex "self", param_1967
    .lex "$obj", param_1968
.annotate 'line', 857
    $P1969 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meths", $P1969
.annotate 'line', 856
    find_lex $P1970, "@meths"
.annotate 'line', 858
    find_lex $P1972, "self"
    get_global $P1973, "$?CLASS"
    getattribute $P1974, $P1972, $P1973, "%!methods"
    unless_null $P1974, vivify_385
    $P1974 = root_new ['parrot';'Hash']
  vivify_385:
    defined $I1975, $P1974
    unless $I1975, for_undef_386
    iter $P1971, $P1974
    new $P1985, 'ExceptionHandler'
    set_label $P1985, loop1984_handler
    $P1985."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1985
  loop1984_test:
    unless $P1971, loop1984_done
    shift $P1976, $P1971
  loop1984_redo:
    .const 'Sub' $P1978 = "135_1299450582.447" 
    capture_lex $P1978
    $P1978($P1976)
  loop1984_next:
    goto loop1984_test
  loop1984_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1986, exception, 'type'
    eq $P1986, .CONTROL_LOOP_NEXT, loop1984_next
    eq $P1986, .CONTROL_LOOP_REDO, loop1984_redo
  loop1984_done:
    pop_eh 
  for_undef_386:
    find_lex $P1987, "@meths"
.annotate 'line', 856
    .return ($P1987)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block1977"  :anon :subid("135_1299450582.447") :outer("134_1299450582.447")
    .param pmc param_1979
.annotate 'line', 858
    .lex "$_", param_1979
.annotate 'line', 859
    find_lex $P1980, "@meths"
    find_lex $P1981, "$_"
    $P1982 = $P1981."value"()
    $P1983 = $P1980."push"($P1982)
.annotate 'line', 858
    .return ($P1983)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "method_table"  :subid("136_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1989
    .param pmc param_1990
.annotate 'line', 864
    .lex "self", param_1989
    .lex "$obj", param_1990
    find_lex $P1991, "self"
    get_global $P1992, "$?CLASS"
    getattribute $P1993, $P1991, $P1992, "%!methods"
    unless_null $P1993, vivify_387
    $P1993 = root_new ['parrot';'Hash']
  vivify_387:
    .return ($P1993)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "name"  :subid("137_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_1995
    .param pmc param_1996
.annotate 'line', 868
    .lex "self", param_1995
    .lex "$obj", param_1996
    find_lex $P1997, "self"
    get_global $P1998, "$?CLASS"
    getattribute $P1999, $P1997, $P1998, "$!name"
    unless_null $P1999, vivify_388
    new $P1999, "Undef"
  vivify_388:
    .return ($P1999)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.include "except_types.pasm"
.sub "attributes"  :subid("138_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_2001
    .param pmc param_2002
.annotate 'line', 872
    .const 'Sub' $P2012 = "139_1299450582.447" 
    capture_lex $P2012
    .lex "self", param_2001
    .lex "$obj", param_2002
.annotate 'line', 873
    $P2003 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attrs", $P2003
.annotate 'line', 872
    find_lex $P2004, "@attrs"
.annotate 'line', 874
    find_lex $P2006, "self"
    get_global $P2007, "$?CLASS"
    getattribute $P2008, $P2006, $P2007, "%!attributes"
    unless_null $P2008, vivify_389
    $P2008 = root_new ['parrot';'Hash']
  vivify_389:
    defined $I2009, $P2008
    unless $I2009, for_undef_390
    iter $P2005, $P2008
    new $P2019, 'ExceptionHandler'
    set_label $P2019, loop2018_handler
    $P2019."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2019
  loop2018_test:
    unless $P2005, loop2018_done
    shift $P2010, $P2005
  loop2018_redo:
    .const 'Sub' $P2012 = "139_1299450582.447" 
    capture_lex $P2012
    $P2012($P2010)
  loop2018_next:
    goto loop2018_test
  loop2018_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2020, exception, 'type'
    eq $P2020, .CONTROL_LOOP_NEXT, loop2018_next
    eq $P2020, .CONTROL_LOOP_REDO, loop2018_redo
  loop2018_done:
    pop_eh 
  for_undef_390:
    find_lex $P2021, "@attrs"
.annotate 'line', 872
    .return ($P2021)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "_block2011"  :anon :subid("139_1299450582.447") :outer("138_1299450582.447")
    .param pmc param_2013
.annotate 'line', 874
    .lex "$_", param_2013
.annotate 'line', 875
    find_lex $P2014, "@attrs"
    find_lex $P2015, "$_"
    $P2016 = $P2015."value"()
    $P2017 = $P2014."push"($P2016)
.annotate 'line', 874
    .return ($P2017)
.end


.HLL "nqp"

.namespace ["NQPParametricRoleHOW"]
.sub "roles"  :subid("140_1299450582.447") :outer("118_1299450582.447")
    .param pmc param_2023
    .param pmc param_2024
.annotate 'line', 880
    .lex "self", param_2023
    .lex "$obj", param_2024
    find_lex $P2025, "self"
    get_global $P2026, "$?CLASS"
    getattribute $P2027, $P2025, $P2026, "@!roles"
    unless_null $P2027, vivify_391
    $P2027 = root_new ['parrot';'ResizablePMCArray']
  vivify_391:
    .return ($P2027)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2088"  :subid("142_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 886
    .const 'Sub' $P2297 = "152_1299450582.447" 
    capture_lex $P2297
    .const 'Sub' $P2161 = "147_1299450582.447" 
    capture_lex $P2161
    .const 'Sub' $P2126 = "145_1299450582.447" 
    capture_lex $P2126
    .const 'Sub' $P2091 = "143_1299450582.447" 
    capture_lex $P2091
    get_global $P2090, "$?CLASS"
.annotate 'line', 888
    .const 'Sub' $P2091 = "143_1299450582.447" 
    newclosure $P2125, $P2091
    .lex "has_method", $P2125
.annotate 'line', 896
    .const 'Sub' $P2126 = "145_1299450582.447" 
    newclosure $P2158, $P2126
    .lex "has_attribute", $P2158
.annotate 'line', 886
    find_lex $P2159, "has_method"
    find_lex $P2160, "has_attribute"
.annotate 'line', 904
    .const 'Sub' $P2161 = "147_1299450582.447" 
    newclosure $P2295, $P2161
.annotate 'line', 886
    .return ($P2295)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "" :load :init :subid("post392") :outer("142_1299450582.447")
.annotate 'line', 886
    get_hll_global $P2089, ["RoleToClassApplier"], "_block2088" 
    .local pmc block
    set block, $P2089
    .const 'Sub' $P2297 = "152_1299450582.447" 
    capture_lex $P2297
    $P2297()
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2296"  :anon :subid("152_1299450582.447") :outer("142_1299450582.447")
.annotate 'line', 886
    get_hll_global $P2298, "KnowHOW"
    $P2299 = $P2298."new_type"("RoleToClassApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2299
    set_hll_global "RoleToClassApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "147_1299450582.447" 
    $P2300."add_method"(type_obj, "apply", $P2301)
    get_how $P2302, type_obj
    $P2303 = $P2302."compose"(type_obj)
    .return ($P2303)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_method"  :subid("143_1299450582.447") :outer("142_1299450582.447")
    .param pmc param_2094
    .param pmc param_2095
    .param pmc param_2096
.annotate 'line', 888
    .const 'Sub' $P2108 = "144_1299450582.447" 
    capture_lex $P2108
    new $P2093, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2093, control_2092
    push_eh $P2093
    .lex "$target", param_2094
    .lex "$name", param_2095
    .lex "$local", param_2096
.annotate 'line', 889
    $P2097 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2097
    find_lex $P2098, "$target"
    get_how $P2099, $P2098
    find_lex $P2100, "$target"
    find_lex $P2101, "$local"
    $P2102 = $P2099."methods"($P2100, $P2101 :named("local"))
    store_lex "@methods", $P2102
.annotate 'line', 890
    find_lex $P2104, "@methods"
    defined $I2105, $P2104
    unless $I2105, for_undef_393
    iter $P2103, $P2104
    new $P2120, 'ExceptionHandler'
    set_label $P2120, loop2119_handler
    $P2120."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2120
  loop2119_test:
    unless $P2103, loop2119_done
    shift $P2106, $P2103
  loop2119_redo:
    .const 'Sub' $P2108 = "144_1299450582.447" 
    capture_lex $P2108
    $P2108($P2106)
  loop2119_next:
    goto loop2119_test
  loop2119_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2121, exception, 'type'
    eq $P2121, .CONTROL_LOOP_NEXT, loop2119_next
    eq $P2121, .CONTROL_LOOP_REDO, loop2119_redo
  loop2119_done:
    pop_eh 
  for_undef_393:
.annotate 'line', 893
    new $P2122, "Exception"
    set $P2122['type'], .CONTROL_RETURN
    new $P2123, "Integer"
    assign $P2123, 0
    setattribute $P2122, 'payload', $P2123
    throw $P2122
.annotate 'line', 888
    .return ()
  control_2092:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2124, exception, "payload"
    .return ($P2124)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block2107"  :anon :subid("144_1299450582.447") :outer("143_1299450582.447")
    .param pmc param_2109
.annotate 'line', 890
    .lex "$_", param_2109
.annotate 'line', 891
    find_lex $P2112, "$_"
    set $S2113, $P2112
    find_lex $P2114, "$name"
    set $S2115, $P2114
    iseq $I2116, $S2113, $S2115
    if $I2116, if_2111
    new $P2110, 'Integer'
    set $P2110, $I2116
    goto if_2111_end
  if_2111:
    new $P2117, "Exception"
    set $P2117['type'], .CONTROL_RETURN
    new $P2118, "Integer"
    assign $P2118, 1
    setattribute $P2117, 'payload', $P2118
    throw $P2117
  if_2111_end:
.annotate 'line', 890
    .return ($P2110)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "has_attribute"  :subid("145_1299450582.447") :outer("142_1299450582.447")
    .param pmc param_2129
    .param pmc param_2130
.annotate 'line', 896
    .const 'Sub' $P2141 = "146_1299450582.447" 
    capture_lex $P2141
    new $P2128, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2128, control_2127
    push_eh $P2128
    .lex "$target", param_2129
    .lex "$name", param_2130
.annotate 'line', 897
    $P2131 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2131
    find_lex $P2132, "$target"
    get_how $P2133, $P2132
    find_lex $P2134, "$target"
    $P2135 = $P2133."attributes"($P2134, 1 :named("local"))
    store_lex "@attributes", $P2135
.annotate 'line', 898
    find_lex $P2137, "@attributes"
    defined $I2138, $P2137
    unless $I2138, for_undef_394
    iter $P2136, $P2137
    new $P2153, 'ExceptionHandler'
    set_label $P2153, loop2152_handler
    $P2153."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2153
  loop2152_test:
    unless $P2136, loop2152_done
    shift $P2139, $P2136
  loop2152_redo:
    .const 'Sub' $P2141 = "146_1299450582.447" 
    capture_lex $P2141
    $P2141($P2139)
  loop2152_next:
    goto loop2152_test
  loop2152_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2154, exception, 'type'
    eq $P2154, .CONTROL_LOOP_NEXT, loop2152_next
    eq $P2154, .CONTROL_LOOP_REDO, loop2152_redo
  loop2152_done:
    pop_eh 
  for_undef_394:
.annotate 'line', 901
    new $P2155, "Exception"
    set $P2155['type'], .CONTROL_RETURN
    new $P2156, "Integer"
    assign $P2156, 0
    setattribute $P2155, 'payload', $P2156
    throw $P2155
.annotate 'line', 896
    .return ()
  control_2127:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2157, exception, "payload"
    .return ($P2157)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "_block2140"  :anon :subid("146_1299450582.447") :outer("145_1299450582.447")
    .param pmc param_2142
.annotate 'line', 898
    .lex "$_", param_2142
.annotate 'line', 899
    find_lex $P2145, "$_"
    $S2146 = $P2145."name"()
    find_lex $P2147, "$name"
    set $S2148, $P2147
    iseq $I2149, $S2146, $S2148
    if $I2149, if_2144
    new $P2143, 'Integer'
    set $P2143, $I2149
    goto if_2144_end
  if_2144:
    new $P2150, "Exception"
    set $P2150['type'], .CONTROL_RETURN
    new $P2151, "Integer"
    assign $P2151, 1
    setattribute $P2150, 'payload', $P2151
    throw $P2150
  if_2144_end:
.annotate 'line', 898
    .return ($P2143)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("147_1299450582.447") :outer("142_1299450582.447")
    .param pmc param_2162
    .param pmc param_2163
    .param pmc param_2164
.annotate 'line', 904
    .const 'Sub' $P2266 = "151_1299450582.447" 
    capture_lex $P2266
    .const 'Sub' $P2240 = "150_1299450582.447" 
    capture_lex $P2240
    .const 'Sub' $P2211 = "149_1299450582.447" 
    capture_lex $P2211
    .const 'Sub' $P2191 = "148_1299450582.447" 
    capture_lex $P2191
    .lex "self", param_2162
    .lex "$target", param_2163
    .lex "@roles", param_2164
.annotate 'line', 907
    new $P2165, "Undef"
    .lex "$to_compose", $P2165
.annotate 'line', 908
    new $P2166, "Undef"
    .lex "$to_compose_meta", $P2166
.annotate 'line', 923
    $P2167 = root_new ['parrot';'ResizablePMCArray']
    .lex "@collisions", $P2167
.annotate 'line', 932
    $P2168 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2168
.annotate 'line', 940
    $P2169 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2169
.annotate 'line', 952
    $P2170 = root_new ['parrot';'ResizablePMCArray']
    .lex "@done", $P2170
.annotate 'line', 904
    find_lex $P2171, "$to_compose"
    find_lex $P2172, "$to_compose_meta"
.annotate 'line', 909
    find_lex $P2174, "@roles"
    set $N2175, $P2174
    iseq $I2176, $N2175, 1.0
    if $I2176, if_2173
.annotate 'line', 914
    get_hll_global $P2181, "NQPConcreteRoleHOW"
    get_hll_global $P2182, "NQPMu"
    $P2183 = $P2181."new_type"($P2182 :named("instance_of"))
    store_lex "$to_compose", $P2183
.annotate 'line', 915
    find_lex $P2184, "$to_compose"
    get_how $P2185, $P2184
    store_lex "$to_compose_meta", $P2185
.annotate 'line', 916
    find_lex $P2187, "@roles"
    defined $I2188, $P2187
    unless $I2188, for_undef_395
    iter $P2186, $P2187
    new $P2198, 'ExceptionHandler'
    set_label $P2198, loop2197_handler
    $P2198."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2198
  loop2197_test:
    unless $P2186, loop2197_done
    shift $P2189, $P2186
  loop2197_redo:
    .const 'Sub' $P2191 = "148_1299450582.447" 
    capture_lex $P2191
    $P2191($P2189)
  loop2197_next:
    goto loop2197_test
  loop2197_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2199, exception, 'type'
    eq $P2199, .CONTROL_LOOP_NEXT, loop2197_next
    eq $P2199, .CONTROL_LOOP_REDO, loop2197_redo
  loop2197_done:
    pop_eh 
  for_undef_395:
.annotate 'line', 919
    find_lex $P2200, "$to_compose_meta"
    find_lex $P2201, "$to_compose"
    $P2202 = $P2200."compose"($P2201)
    store_lex "$to_compose", $P2202
.annotate 'line', 913
    goto if_2173_end
  if_2173:
.annotate 'line', 910
    find_lex $P2177, "@roles"
    unless_null $P2177, vivify_396
    $P2177 = root_new ['parrot';'ResizablePMCArray']
  vivify_396:
    set $P2178, $P2177[0]
    unless_null $P2178, vivify_397
    new $P2178, "Undef"
  vivify_397:
    store_lex "$to_compose", $P2178
.annotate 'line', 911
    find_lex $P2179, "$to_compose"
    get_how $P2180, $P2179
    store_lex "$to_compose_meta", $P2180
  if_2173_end:
.annotate 'line', 923
    find_lex $P2203, "$to_compose_meta"
    find_lex $P2204, "$to_compose"
    $P2205 = $P2203."collisions"($P2204)
    store_lex "@collisions", $P2205
.annotate 'line', 924
    find_lex $P2207, "@collisions"
    defined $I2208, $P2207
    unless $I2208, for_undef_398
    iter $P2206, $P2207
    new $P2230, 'ExceptionHandler'
    set_label $P2230, loop2229_handler
    $P2230."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2230
  loop2229_test:
    unless $P2206, loop2229_done
    shift $P2209, $P2206
  loop2229_redo:
    .const 'Sub' $P2211 = "149_1299450582.447" 
    capture_lex $P2211
    $P2211($P2209)
  loop2229_next:
    goto loop2229_test
  loop2229_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2231, exception, 'type'
    eq $P2231, .CONTROL_LOOP_NEXT, loop2229_next
    eq $P2231, .CONTROL_LOOP_REDO, loop2229_redo
  loop2229_done:
    pop_eh 
  for_undef_398:
.annotate 'line', 932
    find_lex $P2232, "$to_compose_meta"
    find_lex $P2233, "$to_compose"
    $P2234 = $P2232."methods"($P2233)
    store_lex "@methods", $P2234
.annotate 'line', 933
    find_lex $P2236, "@methods"
    defined $I2237, $P2236
    unless $I2237, for_undef_399
    iter $P2235, $P2236
    new $P2256, 'ExceptionHandler'
    set_label $P2256, loop2255_handler
    $P2256."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2256
  loop2255_test:
    unless $P2235, loop2255_done
    shift $P2238, $P2235
  loop2255_redo:
    .const 'Sub' $P2240 = "150_1299450582.447" 
    capture_lex $P2240
    $P2240($P2238)
  loop2255_next:
    goto loop2255_test
  loop2255_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2257, exception, 'type'
    eq $P2257, .CONTROL_LOOP_NEXT, loop2255_next
    eq $P2257, .CONTROL_LOOP_REDO, loop2255_redo
  loop2255_done:
    pop_eh 
  for_undef_399:
.annotate 'line', 940
    find_lex $P2258, "$to_compose_meta"
    find_lex $P2259, "$to_compose"
    $P2260 = $P2258."attributes"($P2259)
    store_lex "@attributes", $P2260
.annotate 'line', 941
    find_lex $P2262, "@attributes"
    defined $I2263, $P2262
    unless $I2263, for_undef_400
    iter $P2261, $P2262
    new $P2290, 'ExceptionHandler'
    set_label $P2290, loop2289_handler
    $P2290."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2290
  loop2289_test:
    unless $P2261, loop2289_done
    shift $P2264, $P2261
  loop2289_redo:
    .const 'Sub' $P2266 = "151_1299450582.447" 
    capture_lex $P2266
    $P2266($P2264)
  loop2289_next:
    goto loop2289_test
  loop2289_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2291, exception, 'type'
    eq $P2291, .CONTROL_LOOP_NEXT, loop2289_next
    eq $P2291, .CONTROL_LOOP_REDO, loop2289_redo
  loop2289_done:
    pop_eh 
  for_undef_400:
    find_lex $P2292, "@done"
.annotate 'line', 953
    find_lex $P2293, "$to_compose"
    find_lex $P2294, "@done"
    unless_null $P2294, vivify_401
    $P2294 = root_new ['parrot';'ResizablePMCArray']
    store_lex "@done", $P2294
  vivify_401:
    set $P2294[0], $P2293
.annotate 'line', 904
    .return ($P2293)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2190"  :anon :subid("148_1299450582.447") :outer("147_1299450582.447")
    .param pmc param_2192
.annotate 'line', 916
    .lex "$_", param_2192
.annotate 'line', 917
    find_lex $P2193, "$to_compose_meta"
    find_lex $P2194, "$to_compose"
    find_lex $P2195, "$_"
    $P2196 = $P2193."add_role"($P2194, $P2195)
.annotate 'line', 916
    .return ($P2196)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2210"  :anon :subid("149_1299450582.447") :outer("147_1299450582.447")
    .param pmc param_2212
.annotate 'line', 924
    .lex "$_", param_2212
.annotate 'line', 925
    find_lex $P2215, "$target"
    find_lex $P2216, "$_"
    set $S2217, $P2216
    $P2218 = "has_method"($P2215, $S2217, 1)
    unless $P2218, unless_2214
    set $P2213, $P2218
    goto unless_2214_end
  unless_2214:
.annotate 'line', 926
    new $P2219, 'String'
    set $P2219, "Method '"
    find_lex $P2220, "$_"
    concat $P2221, $P2219, $P2220
    concat $P2222, $P2221, "' collides and a resolution must be provided by the class '"
.annotate 'line', 927
    find_lex $P2223, "$target"
    get_how $P2224, $P2223
    find_lex $P2225, "$target"
    $S2226 = $P2224."name"($P2225)
    concat $P2227, $P2222, $S2226
.annotate 'line', 926
    concat $P2228, $P2227, "'"
.annotate 'line', 927
    die $P2228
  unless_2214_end:
.annotate 'line', 924
    .return ($P2213)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2239"  :anon :subid("150_1299450582.447") :outer("147_1299450582.447")
    .param pmc param_2241
.annotate 'line', 933
    .lex "$_", param_2241
.annotate 'line', 934
    find_lex $P2244, "$target"
    find_lex $P2245, "$_"
    set $S2246, $P2245
    $P2247 = "has_method"($P2244, $S2246, 0)
    unless $P2247, unless_2243
    set $P2242, $P2247
    goto unless_2243_end
  unless_2243:
.annotate 'line', 935
    find_lex $P2248, "$target"
    get_how $P2249, $P2248
    find_lex $P2250, "$target"
    find_lex $P2251, "$_"
    set $S2252, $P2251
    find_lex $P2253, "$_"
    $P2254 = $P2249."add_method"($P2250, $S2252, $P2253)
.annotate 'line', 934
    set $P2242, $P2254
  unless_2243_end:
.annotate 'line', 933
    .return ($P2242)
.end


.HLL "nqp"

.namespace ["RoleToClassApplier"]
.sub "_block2265"  :anon :subid("151_1299450582.447") :outer("147_1299450582.447")
    .param pmc param_2267
.annotate 'line', 941
    .lex "$_", param_2267
.annotate 'line', 942
    find_lex $P2269, "$target"
    find_lex $P2270, "$_"
    $P2271 = $P2270."name"()
    $P2272 = "has_attribute"($P2269, $P2271)
    unless $P2272, if_2268_end
.annotate 'line', 943
    new $P2273, "String"
    assign $P2273, "Attribute '"
    find_lex $P2274, "$_"
    $S2275 = $P2274."name"()
    concat $P2276, $P2273, $S2275
    concat $P2277, $P2276, "' already exists in the class '"
.annotate 'line', 944
    find_lex $P2278, "$target"
    get_how $P2279, $P2278
    find_lex $P2280, "$target"
    $S2281 = $P2279."name"($P2280)
    concat $P2282, $P2277, $S2281
.annotate 'line', 943
    concat $P2283, $P2282, "', but a role also wishes to compose it"
.annotate 'line', 944
    die $P2283
  if_2268_end:
.annotate 'line', 946
    find_lex $P2284, "$target"
    get_how $P2285, $P2284
    find_lex $P2286, "$target"
    find_lex $P2287, "$_"
    $P2288 = $P2285."add_attribute"($P2286, $P2287)
.annotate 'line', 941
    .return ($P2288)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2304"  :subid("153_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 958
    .const 'Sub' $P2527 = "163_1299450582.447" 
    capture_lex $P2527
    .const 'Sub' $P2307 = "154_1299450582.447" 
    capture_lex $P2307
    get_global $P2306, "$?CLASS"
.annotate 'line', 959
    .const 'Sub' $P2307 = "154_1299450582.447" 
    newclosure $P2525, $P2307
.annotate 'line', 958
    .return ($P2525)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "" :load :init :subid("post402") :outer("153_1299450582.447")
.annotate 'line', 958
    get_hll_global $P2305, ["RoleToRoleApplier"], "_block2304" 
    .local pmc block
    set block, $P2305
    .const 'Sub' $P2527 = "163_1299450582.447" 
    capture_lex $P2527
    $P2527()
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2526"  :anon :subid("163_1299450582.447") :outer("153_1299450582.447")
.annotate 'line', 958
    get_hll_global $P2528, "KnowHOW"
    $P2529 = $P2528."new_type"("RoleToRoleApplier" :named("name"))
    .local pmc type_obj
    set type_obj, $P2529
    set_hll_global "RoleToRoleApplier", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2530, type_obj
    .const 'Sub' $P2531 = "154_1299450582.447" 
    $P2530."add_method"(type_obj, "apply", $P2531)
    get_how $P2532, type_obj
    $P2533 = $P2532."compose"(type_obj)
    .return ($P2533)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "apply"  :subid("154_1299450582.447") :outer("153_1299450582.447")
    .param pmc param_2310
    .param pmc param_2311
    .param pmc param_2312
.annotate 'line', 959
    .const 'Sub' $P2452 = "160_1299450582.447" 
    capture_lex $P2452
    .const 'Sub' $P2410 = "159_1299450582.447" 
    capture_lex $P2410
    .const 'Sub' $P2396 = "158_1299450582.447" 
    capture_lex $P2396
    .const 'Sub' $P2323 = "155_1299450582.447" 
    capture_lex $P2323
    new $P2309, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2309, control_2308
    push_eh $P2309
    .lex "self", param_2310
    .lex "$target", param_2311
    .lex "@roles", param_2312
.annotate 'line', 961
    $P2313 = root_new ['parrot';'Hash']
    .lex "%meth_info", $P2313
.annotate 'line', 987
    $P2314 = root_new ['parrot';'Hash']
    .lex "%target_meth_info", $P2314
.annotate 'line', 988
    $P2315 = root_new ['parrot';'ResizablePMCArray']
    .lex "@target_meths", $P2315
.annotate 'line', 1013
    $P2316 = root_new ['parrot';'ResizablePMCArray']
    .lex "@all_roles", $P2316
.annotate 'line', 959
    find_lex $P2317, "%meth_info"
.annotate 'line', 962
    find_lex $P2319, "@roles"
    defined $I2320, $P2319
    unless $I2320, for_undef_403
    iter $P2318, $P2319
    new $P2384, 'ExceptionHandler'
    set_label $P2384, loop2383_handler
    $P2384."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2384
  loop2383_test:
    unless $P2318, loop2383_done
    shift $P2321, $P2318
  loop2383_redo:
    .const 'Sub' $P2323 = "155_1299450582.447" 
    capture_lex $P2323
    $P2323($P2321)
  loop2383_next:
    goto loop2383_test
  loop2383_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2385, exception, 'type'
    eq $P2385, .CONTROL_LOOP_NEXT, loop2383_next
    eq $P2385, .CONTROL_LOOP_REDO, loop2383_redo
  loop2383_done:
    pop_eh 
  for_undef_403:
    find_lex $P2386, "%target_meth_info"
.annotate 'line', 988
    find_lex $P2387, "$target"
    get_how $P2388, $P2387
    find_lex $P2389, "$target"
    $P2390 = $P2388."methods"($P2389)
    store_lex "@target_meths", $P2390
.annotate 'line', 989
    find_lex $P2392, "@target_meths"
    defined $I2393, $P2392
    unless $I2393, for_undef_411
    iter $P2391, $P2392
    new $P2403, 'ExceptionHandler'
    set_label $P2403, loop2402_handler
    $P2403."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2403
  loop2402_test:
    unless $P2391, loop2402_done
    shift $P2394, $P2391
  loop2402_redo:
    .const 'Sub' $P2396 = "158_1299450582.447" 
    capture_lex $P2396
    $P2396($P2394)
  loop2402_next:
    goto loop2402_test
  loop2402_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2404, exception, 'type'
    eq $P2404, .CONTROL_LOOP_NEXT, loop2402_next
    eq $P2404, .CONTROL_LOOP_REDO, loop2402_redo
  loop2402_done:
    pop_eh 
  for_undef_411:
.annotate 'line', 994
    find_lex $P2406, "%meth_info"
    defined $I2407, $P2406
    unless $I2407, for_undef_413
    iter $P2405, $P2406
    new $P2444, 'ExceptionHandler'
    set_label $P2444, loop2443_handler
    $P2444."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2444
  loop2443_test:
    unless $P2405, loop2443_done
    shift $P2408, $P2405
  loop2443_redo:
    .const 'Sub' $P2410 = "159_1299450582.447" 
    capture_lex $P2410
    $P2410($P2408)
  loop2443_next:
    goto loop2443_test
  loop2443_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2445, exception, 'type'
    eq $P2445, .CONTROL_LOOP_NEXT, loop2443_next
    eq $P2445, .CONTROL_LOOP_REDO, loop2443_redo
  loop2443_done:
    pop_eh 
  for_undef_413:
    find_lex $P2446, "@all_roles"
.annotate 'line', 1014
    find_lex $P2448, "@roles"
    defined $I2449, $P2448
    unless $I2449, for_undef_420
    iter $P2447, $P2448
    new $P2520, 'ExceptionHandler'
    set_label $P2520, loop2519_handler
    $P2520."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2520
  loop2519_test:
    unless $P2447, loop2519_done
    shift $P2450, $P2447
  loop2519_redo:
    .const 'Sub' $P2452 = "160_1299450582.447" 
    capture_lex $P2452
    $P2452($P2450)
  loop2519_next:
    goto loop2519_test
  loop2519_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2521, exception, 'type'
    eq $P2521, .CONTROL_LOOP_NEXT, loop2519_next
    eq $P2521, .CONTROL_LOOP_REDO, loop2519_redo
  loop2519_done:
    pop_eh 
  for_undef_420:
.annotate 'line', 1043
    new $P2522, "Exception"
    set $P2522['type'], .CONTROL_RETURN
    find_lex $P2523, "@all_roles"
    setattribute $P2522, 'payload', $P2523
    throw $P2522
.annotate 'line', 959
    .return ()
  control_2308:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2524, exception, "payload"
    .return ($P2524)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2322"  :anon :subid("155_1299450582.447") :outer("154_1299450582.447")
    .param pmc param_2325
.annotate 'line', 962
    .const 'Sub' $P2335 = "156_1299450582.447" 
    capture_lex $P2335
.annotate 'line', 963
    $P2324 = root_new ['parrot';'ResizablePMCArray']
    .lex "@methods", $P2324
    .lex "$_", param_2325
    find_lex $P2326, "$_"
    get_how $P2327, $P2326
    find_lex $P2328, "$_"
    $P2329 = $P2327."methods"($P2328)
    store_lex "@methods", $P2329
.annotate 'line', 964
    find_lex $P2331, "@methods"
    defined $I2332, $P2331
    unless $I2332, for_undef_404
    iter $P2330, $P2331
    new $P2381, 'ExceptionHandler'
    set_label $P2381, loop2380_handler
    $P2381."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2381
  loop2380_test:
    unless $P2330, loop2380_done
    shift $P2333, $P2330
  loop2380_redo:
    .const 'Sub' $P2335 = "156_1299450582.447" 
    capture_lex $P2335
    $P2335($P2333)
  loop2380_next:
    goto loop2380_test
  loop2380_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2382, exception, 'type'
    eq $P2382, .CONTROL_LOOP_NEXT, loop2380_next
    eq $P2382, .CONTROL_LOOP_REDO, loop2380_redo
  loop2380_done:
    pop_eh 
  for_undef_404:
.annotate 'line', 962
    .return ($P2330)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2334"  :anon :subid("156_1299450582.447") :outer("155_1299450582.447")
    .param pmc param_2340
.annotate 'line', 964
    .const 'Sub' $P2363 = "157_1299450582.447" 
    capture_lex $P2363
.annotate 'line', 965
    new $P2336, "Undef"
    .lex "$name", $P2336
.annotate 'line', 966
    new $P2337, "Undef"
    .lex "$meth", $P2337
.annotate 'line', 967
    $P2338 = root_new ['parrot';'ResizablePMCArray']
    .lex "@meth_list", $P2338
.annotate 'line', 974
    new $P2339, "Undef"
    .lex "$found", $P2339
    .lex "$_", param_2340
.annotate 'line', 965
    find_lex $P2341, "$_"
    set $S2342, $P2341
    new $P2343, 'String'
    set $P2343, $S2342
    store_lex "$name", $P2343
.annotate 'line', 966
    find_lex $P2344, "$_"
    store_lex "$meth", $P2344
    find_lex $P2345, "@meth_list"
.annotate 'line', 968
    find_lex $P2347, "$name"
    find_lex $P2348, "%meth_info"
    unless_null $P2348, vivify_405
    $P2348 = root_new ['parrot';'Hash']
  vivify_405:
    set $P2349, $P2348[$P2347]
    unless_null $P2349, vivify_406
    new $P2349, "Undef"
  vivify_406:
    defined $I2350, $P2349
    if $I2350, if_2346
.annotate 'line', 972
    find_lex $P2354, "@meth_list"
    find_lex $P2355, "$name"
    find_lex $P2356, "%meth_info"
    unless_null $P2356, vivify_407
    $P2356 = root_new ['parrot';'Hash']
    store_lex "%meth_info", $P2356
  vivify_407:
    set $P2356[$P2355], $P2354
.annotate 'line', 971
    goto if_2346_end
  if_2346:
.annotate 'line', 969
    find_lex $P2351, "$name"
    find_lex $P2352, "%meth_info"
    unless_null $P2352, vivify_408
    $P2352 = root_new ['parrot';'Hash']
  vivify_408:
    set $P2353, $P2352[$P2351]
    unless_null $P2353, vivify_409
    new $P2353, "Undef"
  vivify_409:
    store_lex "@meth_list", $P2353
  if_2346_end:
.annotate 'line', 974
    new $P2357, "Integer"
    assign $P2357, 0
    store_lex "$found", $P2357
.annotate 'line', 975
    find_lex $P2359, "@meth_list"
    defined $I2360, $P2359
    unless $I2360, for_undef_410
    iter $P2358, $P2359
    new $P2372, 'ExceptionHandler'
    set_label $P2372, loop2371_handler
    $P2372."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2372
  loop2371_test:
    unless $P2358, loop2371_done
    shift $P2361, $P2358
  loop2371_redo:
    .const 'Sub' $P2363 = "157_1299450582.447" 
    capture_lex $P2363
    $P2363($P2361)
  loop2371_next:
    goto loop2371_test
  loop2371_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2373, exception, 'type'
    eq $P2373, .CONTROL_LOOP_NEXT, loop2371_next
    eq $P2373, .CONTROL_LOOP_REDO, loop2371_redo
  loop2371_done:
    pop_eh 
  for_undef_410:
.annotate 'line', 980
    find_lex $P2376, "$found"
    unless $P2376, unless_2375
    set $P2374, $P2376
    goto unless_2375_end
  unless_2375:
.annotate 'line', 981
    find_lex $P2377, "@meth_list"
    find_lex $P2378, "$meth"
    $P2379 = $P2377."push"($P2378)
.annotate 'line', 980
    set $P2374, $P2379
  unless_2375_end:
.annotate 'line', 964
    .return ($P2374)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2362"  :anon :subid("157_1299450582.447") :outer("156_1299450582.447")
    .param pmc param_2364
.annotate 'line', 975
    .lex "$_", param_2364
.annotate 'line', 976
    find_lex $P2367, "$meth"
    find_lex $P2368, "$_"
    issame $I2369, $P2367, $P2368
    if $I2369, if_2366
    new $P2365, 'Integer'
    set $P2365, $I2369
    goto if_2366_end
  if_2366:
.annotate 'line', 977
    new $P2370, "Integer"
    assign $P2370, 1
    store_lex "$found", $P2370
.annotate 'line', 976
    set $P2365, $P2370
  if_2366_end:
.annotate 'line', 975
    .return ($P2365)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2395"  :anon :subid("158_1299450582.447") :outer("154_1299450582.447")
    .param pmc param_2397
.annotate 'line', 989
    .lex "$_", param_2397
.annotate 'line', 990
    find_lex $P2398, "$_"
    find_lex $P2399, "$_"
    set $S2400, $P2399
    find_lex $P2401, "%target_meth_info"
    unless_null $P2401, vivify_412
    $P2401 = root_new ['parrot';'Hash']
    store_lex "%target_meth_info", $P2401
  vivify_412:
    set $P2401[$S2400], $P2398
.annotate 'line', 989
    .return ($P2398)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2409"  :anon :subid("159_1299450582.447") :outer("154_1299450582.447")
    .param pmc param_2413
.annotate 'line', 995
    new $P2411, "Undef"
    .lex "$name", $P2411
.annotate 'line', 996
    $P2412 = root_new ['parrot';'ResizablePMCArray']
    .lex "@add_meths", $P2412
    .lex "$_", param_2413
.annotate 'line', 995
    find_lex $P2414, "$_"
    set $S2415, $P2414
    new $P2416, 'String'
    set $P2416, $S2415
    store_lex "$name", $P2416
.annotate 'line', 996
    find_lex $P2417, "$name"
    find_lex $P2418, "%meth_info"
    unless_null $P2418, vivify_414
    $P2418 = root_new ['parrot';'Hash']
  vivify_414:
    set $P2419, $P2418[$P2417]
    unless_null $P2419, vivify_415
    new $P2419, "Undef"
  vivify_415:
    store_lex "@add_meths", $P2419
.annotate 'line', 1000
    find_lex $P2422, "$name"
    find_lex $P2423, "%target_meth_info"
    unless_null $P2423, vivify_416
    $P2423 = root_new ['parrot';'Hash']
  vivify_416:
    set $P2424, $P2423[$P2422]
    unless_null $P2424, vivify_417
    new $P2424, "Undef"
  vivify_417:
    defined $I2425, $P2424
    unless $I2425, unless_2421
    new $P2420, 'Integer'
    set $P2420, $I2425
    goto unless_2421_end
  unless_2421:
.annotate 'line', 1002
    find_lex $P2428, "@add_meths"
    set $N2429, $P2428
    iseq $I2430, $N2429, 1.0
    if $I2430, if_2427
.annotate 'line', 1007
    find_lex $P2438, "$target"
    get_how $P2439, $P2438
    find_lex $P2440, "$target"
    find_lex $P2441, "$name"
    $P2442 = $P2439."add_collision"($P2440, $P2441)
.annotate 'line', 1005
    set $P2426, $P2442
.annotate 'line', 1002
    goto if_2427_end
  if_2427:
.annotate 'line', 1003
    find_lex $P2431, "$target"
    get_how $P2432, $P2431
    find_lex $P2433, "$target"
    find_lex $P2434, "$name"
    find_lex $P2435, "@add_meths"
    unless_null $P2435, vivify_418
    $P2435 = root_new ['parrot';'ResizablePMCArray']
  vivify_418:
    set $P2436, $P2435[0]
    unless_null $P2436, vivify_419
    new $P2436, "Undef"
  vivify_419:
    $P2437 = $P2432."add_method"($P2433, $P2434, $P2436)
.annotate 'line', 1002
    set $P2426, $P2437
  if_2427_end:
.annotate 'line', 1000
    set $P2420, $P2426
  unless_2421_end:
.annotate 'line', 994
    .return ($P2420)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2451"  :anon :subid("160_1299450582.447") :outer("154_1299450582.447")
    .param pmc param_2455
.annotate 'line', 1014
    .const 'Sub' $P2466 = "161_1299450582.447" 
    capture_lex $P2466
.annotate 'line', 1015
    new $P2453, "Undef"
    .lex "$how", $P2453
.annotate 'line', 1018
    $P2454 = root_new ['parrot';'ResizablePMCArray']
    .lex "@attributes", $P2454
    .lex "$_", param_2455
.annotate 'line', 1015
    find_lex $P2456, "$_"
    get_how $P2457, $P2456
    store_lex "$how", $P2457
.annotate 'line', 1018
    find_lex $P2458, "$how"
    find_lex $P2459, "$_"
    $P2460 = $P2458."attributes"($P2459)
    store_lex "@attributes", $P2460
.annotate 'line', 1019
    find_lex $P2462, "@attributes"
    defined $I2463, $P2462
    unless $I2463, for_undef_421
    iter $P2461, $P2462
    new $P2514, 'ExceptionHandler'
    set_label $P2514, loop2513_handler
    $P2514."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2514
  loop2513_test:
    unless $P2461, loop2513_done
    shift $P2464, $P2461
  loop2513_redo:
    .const 'Sub' $P2466 = "161_1299450582.447" 
    capture_lex $P2466
    $P2466($P2464)
  loop2513_next:
    goto loop2513_test
  loop2513_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2515, exception, 'type'
    eq $P2515, .CONTROL_LOOP_NEXT, loop2513_next
    eq $P2515, .CONTROL_LOOP_REDO, loop2513_redo
  loop2513_done:
    pop_eh 
  for_undef_421:
.annotate 'line', 1040
    find_lex $P2516, "@all_roles"
    find_lex $P2517, "$_"
    $P2518 = $P2516."push"($P2517)
.annotate 'line', 1014
    .return ($P2518)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.include "except_types.pasm"
.sub "_block2465"  :anon :subid("161_1299450582.447") :outer("160_1299450582.447")
    .param pmc param_2470
.annotate 'line', 1019
    .const 'Sub' $P2482 = "162_1299450582.447" 
    capture_lex $P2482
.annotate 'line', 1020
    new $P2467, "Undef"
    .lex "$add_attr", $P2467
.annotate 'line', 1021
    new $P2468, "Undef"
    .lex "$skip", $P2468
.annotate 'line', 1022
    $P2469 = root_new ['parrot';'ResizablePMCArray']
    .lex "@cur_attrs", $P2469
    .lex "$_", param_2470
.annotate 'line', 1020
    find_lex $P2471, "$_"
    store_lex "$add_attr", $P2471
.annotate 'line', 1021
    new $P2472, "Integer"
    assign $P2472, 0
    store_lex "$skip", $P2472
.annotate 'line', 1022
    find_lex $P2473, "$target"
    get_how $P2474, $P2473
    find_lex $P2475, "$target"
    $P2476 = $P2474."attributes"($P2475)
    store_lex "@cur_attrs", $P2476
.annotate 'line', 1023
    find_lex $P2478, "@cur_attrs"
    defined $I2479, $P2478
    unless $I2479, for_undef_422
    iter $P2477, $P2478
    new $P2503, 'ExceptionHandler'
    set_label $P2503, loop2502_handler
    $P2503."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2503
  loop2502_test:
    unless $P2477, loop2502_done
    shift $P2480, $P2477
  loop2502_redo:
    .const 'Sub' $P2482 = "162_1299450582.447" 
    capture_lex $P2482
    $P2482($P2480)
  loop2502_next:
    goto loop2502_test
  loop2502_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2504, exception, 'type'
    eq $P2504, .CONTROL_LOOP_NEXT, loop2502_next
    eq $P2504, .CONTROL_LOOP_REDO, loop2502_redo
  loop2502_done:
    pop_eh 
  for_undef_422:
.annotate 'line', 1033
    find_lex $P2507, "$skip"
    unless $P2507, unless_2506
    set $P2505, $P2507
    goto unless_2506_end
  unless_2506:
.annotate 'line', 1034
    find_lex $P2508, "$target"
    get_how $P2509, $P2508
    find_lex $P2510, "$target"
    find_lex $P2511, "$add_attr"
    $P2512 = $P2509."add_attribute"($P2510, $P2511)
.annotate 'line', 1033
    set $P2505, $P2512
  unless_2506_end:
.annotate 'line', 1019
    .return ($P2505)
.end


.HLL "nqp"

.namespace ["RoleToRoleApplier"]
.sub "_block2481"  :anon :subid("162_1299450582.447") :outer("161_1299450582.447")
    .param pmc param_2483
.annotate 'line', 1023
    .lex "$_", param_2483
.annotate 'line', 1024
    find_lex $P2486, "$_"
    find_lex $P2487, "$add_attr"
    issame $I2488, $P2486, $P2487
    if $I2488, if_2485
.annotate 'line', 1028
    find_lex $P2492, "$_"
    $S2493 = $P2492."name"()
    find_lex $P2494, "$add_attr"
    $S2495 = $P2494."name"()
    iseq $I2496, $S2493, $S2495
    if $I2496, if_2491
    new $P2490, 'Integer'
    set $P2490, $I2496
    goto if_2491_end
  if_2491:
.annotate 'line', 1029
    new $P2497, "String"
    assign $P2497, "Attribute '"
    find_lex $P2498, "$_"
    $S2499 = $P2498."name"()
    concat $P2500, $P2497, $S2499
    concat $P2501, $P2500, "' conflicts in role composition"
    die $P2501
  if_2491_end:
.annotate 'line', 1027
    set $P2484, $P2490
.annotate 'line', 1024
    goto if_2485_end
  if_2485:
.annotate 'line', 1025
    new $P2489, "Integer"
    assign $P2489, 1
    store_lex "$skip", $P2489
.annotate 'line', 1024
    set $P2484, $P2489
  if_2485_end:
.annotate 'line', 1023
    .return ($P2484)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "_block2534"  :subid("164_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 1048
    .const 'Sub' $P2596 = "173_1299450582.447" 
    capture_lex $P2596
    .const 'Sub' $P2588 = "172_1299450582.447" 
    capture_lex $P2588
    .const 'Sub' $P2582 = "171_1299450582.447" 
    capture_lex $P2582
    .const 'Sub' $P2578 = "170_1299450582.447" 
    capture_lex $P2578
    .const 'Sub' $P2573 = "169_1299450582.447" 
    capture_lex $P2573
    .const 'Sub' $P2568 = "168_1299450582.447" 
    capture_lex $P2568
    .const 'Sub' $P2554 = "167_1299450582.447" 
    capture_lex $P2554
    .const 'Sub' $P2547 = "166_1299450582.447" 
    capture_lex $P2547
    .const 'Sub' $P2537 = "165_1299450582.447" 
    capture_lex $P2537
    get_global $P2536, "$?CLASS"
.annotate 'line', 1087
    .const 'Sub' $P2588 = "172_1299450582.447" 
    newclosure $P2594, $P2588
.annotate 'line', 1048
    .return ($P2594)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "" :load :init :subid("post423") :outer("164_1299450582.447")
.annotate 'line', 1048
    get_hll_global $P2535, ["NQPModuleHOW"], "_block2534" 
    .local pmc block
    set block, $P2535
    .const 'Sub' $P2596 = "173_1299450582.447" 
    capture_lex $P2596
    $P2596()
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "_block2595"  :anon :subid("173_1299450582.447") :outer("164_1299450582.447")
.annotate 'line', 1048
    get_hll_global $P2597, "KnowHOW"
    $P2598 = $P2597."new_type"("NQPModuleHOW" :named("name"))
    .local pmc type_obj
    set type_obj, $P2598
    set_hll_global "NQPModuleHOW", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2599, type_obj
    get_hll_global $P2600, "KnowHOWAttribute"
    $P2601 = $P2600."new"("$!name" :named("name"))
    $P2599."add_attribute"(type_obj, $P2601)
    get_how $P2602, type_obj
    get_hll_global $P2603, "KnowHOWAttribute"
    $P2604 = $P2603."new"("$!composed" :named("name"))
    $P2602."add_attribute"(type_obj, $P2604)
    get_how $P2605, type_obj
    .const 'Sub' $P2606 = "165_1299450582.447" 
    $P2605."add_method"(type_obj, "new", $P2606)
    get_how $P2607, type_obj
    .const 'Sub' $P2608 = "166_1299450582.447" 
    $P2607."add_method"(type_obj, "BUILD", $P2608)
    get_how $P2609, type_obj
    .const 'Sub' $P2610 = "167_1299450582.447" 
    $P2609."add_method"(type_obj, "new_type", $P2610)
    get_how $P2611, type_obj
    .const 'Sub' $P2612 = "168_1299450582.447" 
    $P2611."add_method"(type_obj, "add_method", $P2612)
    get_how $P2613, type_obj
    .const 'Sub' $P2614 = "169_1299450582.447" 
    $P2613."add_method"(type_obj, "add_multi_method", $P2614)
    get_how $P2615, type_obj
    .const 'Sub' $P2616 = "170_1299450582.447" 
    $P2615."add_method"(type_obj, "add_attribute", $P2616)
    get_how $P2617, type_obj
    .const 'Sub' $P2618 = "171_1299450582.447" 
    $P2617."add_method"(type_obj, "compose", $P2618)
    get_how $P2619, type_obj
    .const 'Sub' $P2620 = "172_1299450582.447" 
    $P2619."add_method"(type_obj, "name", $P2620)
    get_how $P2621, type_obj
    $P2622 = $P2621."compose"(type_obj)
    .return ($P2622)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "new"  :subid("165_1299450582.447") :outer("164_1299450582.447")
    .param pmc param_2538
    .param pmc param_2539 :optional :named("name")
    .param int has_param_2539 :opt_flag
.annotate 'line', 1052
    .lex "self", param_2538
    if has_param_2539, optparam_424
    new $P2540, "Undef"
    set param_2539, $P2540
  optparam_424:
    .lex "$name", param_2539
.annotate 'line', 1053
    new $P2541, "Undef"
    .lex "$obj", $P2541
    find_lex $P2542, "self"
    repr_instance_of $P2543, $P2542
    store_lex "$obj", $P2543
.annotate 'line', 1054
    find_lex $P2544, "$obj"
    find_lex $P2545, "$name"
    $P2544."BUILD"($P2545 :named("name"))
    find_lex $P2546, "$obj"
.annotate 'line', 1052
    .return ($P2546)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "BUILD"  :subid("166_1299450582.447") :outer("164_1299450582.447")
    .param pmc param_2548
    .param pmc param_2549 :optional :named("name")
    .param int has_param_2549 :opt_flag
.annotate 'line', 1058
    .lex "self", param_2548
    if has_param_2549, optparam_425
    new $P2550, "Undef"
    set param_2549, $P2550
  optparam_425:
    .lex "$name", param_2549
.annotate 'line', 1059
    find_lex $P2551, "$name"
    find_lex $P2552, "self"
    get_global $P2553, "$?CLASS"
    setattribute $P2552, $P2553, "$!name", $P2551
.annotate 'line', 1058
    .return ($P2551)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "new_type"  :subid("167_1299450582.447") :outer("164_1299450582.447")
    .param pmc param_2555
    .param pmc param_2556 :optional :named("name")
    .param int has_param_2556 :opt_flag
    .param pmc param_2558 :optional :named("repr")
    .param int has_param_2558 :opt_flag
.annotate 'line', 1064
    .lex "self", param_2555
    if has_param_2556, optparam_426
    new $P2557, "String"
    assign $P2557, "<anon>"
    set param_2556, $P2557
  optparam_426:
    .lex "$name", param_2556
    if has_param_2558, optparam_427
    new $P2559, "String"
    assign $P2559, "P6opaque"
    set param_2558, $P2559
  optparam_427:
    .lex "$repr", param_2558
.annotate 'line', 1065
    new $P2560, "Undef"
    .lex "$metaclass", $P2560
    find_lex $P2561, "self"
    find_lex $P2562, "$name"
    $P2563 = $P2561."new"($P2562 :named("name"))
    store_lex "$metaclass", $P2563
.annotate 'line', 1066
    find_lex $P2564, "$metaclass"
    find_lex $P2565, "$repr"
    set $S2566, $P2565
    repr_type_object_for $P2567, $P2564, $S2566
.annotate 'line', 1064
    .return ($P2567)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "add_method"  :subid("168_1299450582.447") :outer("164_1299450582.447")
    .param pmc param_2569
    .param pmc param_2570
    .param pmc param_2571
    .param pmc param_2572
.annotate 'line', 1069
    .lex "self", param_2569
    .lex "$obj", param_2570
    .lex "$name", param_2571
    .lex "$code_obj", param_2572
    .return ()
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "add_multi_method"  :subid("169_1299450582.447") :outer("164_1299450582.447")
    .param pmc param_2574
    .param pmc param_2575
    .param pmc param_2576
    .param pmc param_2577
.annotate 'line', 1075
    .lex "self", param_2574
    .lex "$obj", param_2575
    .lex "$name", param_2576
    .lex "$code_obj", param_2577
.annotate 'line', 1076
    die "Modules may not have methods"
.annotate 'line', 1075
    .return ()
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "add_attribute"  :subid("170_1299450582.447") :outer("164_1299450582.447")
    .param pmc param_2579
    .param pmc param_2580
    .param pmc param_2581
.annotate 'line', 1079
    .lex "self", param_2579
    .lex "$obj", param_2580
    .lex "$meta_attr", param_2581
.annotate 'line', 1080
    die "Modules may not have attributes"
.annotate 'line', 1079
    .return ()
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "compose"  :subid("171_1299450582.447") :outer("164_1299450582.447")
    .param pmc param_2583
    .param pmc param_2584
.annotate 'line', 1083
    .lex "self", param_2583
    .lex "$obj", param_2584
.annotate 'line', 1084
    new $P2585, "Integer"
    assign $P2585, 1
    find_lex $P2586, "self"
    get_global $P2587, "$?CLASS"
    setattribute $P2586, $P2587, "$!composed", $P2585
.annotate 'line', 1083
    .return ($P2585)
.end


.HLL "nqp"

.namespace ["NQPModuleHOW"]
.sub "name"  :subid("172_1299450582.447") :outer("164_1299450582.447")
    .param pmc param_2589
    .param pmc param_2590
.annotate 'line', 1087
    .lex "self", param_2589
    .lex "$obj", param_2590
    find_lex $P2591, "self"
    get_global $P2592, "$?CLASS"
    getattribute $P2593, $P2591, $P2592, "$!name"
    unless_null $P2593, vivify_428
    new $P2593, "Undef"
  vivify_428:
    .return ($P2593)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "_block2623"  :subid("174_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 1093
    .const 'Sub' $P2745 = "187_1299450582.447" 
    capture_lex $P2745
    .const 'Sub' $P2735 = "186_1299450582.447" 
    capture_lex $P2735
    .const 'Sub' $P2723 = "185_1299450582.447" 
    capture_lex $P2723
    .const 'Sub' $P2719 = "184_1299450582.447" 
    capture_lex $P2719
    .const 'Sub' $P2708 = "183_1299450582.447" 
    capture_lex $P2708
    .const 'Sub' $P2705 = "182_1299450582.447" 
    capture_lex $P2705
    .const 'Sub' $P2699 = "181_1299450582.447" 
    capture_lex $P2699
    .const 'Sub' $P2661 = "179_1299450582.447" 
    capture_lex $P2661
    .const 'Sub' $P2640 = "177_1299450582.447" 
    capture_lex $P2640
    .const 'Sub' $P2630 = "176_1299450582.447" 
    capture_lex $P2630
    .const 'Sub' $P2626 = "175_1299450582.447" 
    capture_lex $P2626
    get_global $P2625, "$?CLASS"
.annotate 'line', 1135
    .const 'Sub' $P2735 = "186_1299450582.447" 
    newclosure $P2743, $P2735
.annotate 'line', 1093
    .return ($P2743)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "" :load :init :subid("post429") :outer("174_1299450582.447")
.annotate 'line', 1093
    get_hll_global $P2624, ["NQPMu"], "_block2623" 
    .local pmc block
    set block, $P2624
    .const 'Sub' $P2745 = "187_1299450582.447" 
    capture_lex $P2745
    $P2745()
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "_block2744"  :anon :subid("187_1299450582.447") :outer("174_1299450582.447")
.annotate 'line', 1093
    .const 'Sub' $P2762 = "182_1299450582.447" 
    capture_lex $P2762
    get_hll_global $P2746, "NQPClassHOW"
    $P2747 = $P2746."new_type"("NQPMu" :named("name"))
    .local pmc type_obj
    set type_obj, $P2747
    set_hll_global "NQPMu", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2748, type_obj
    .const 'Sub' $P2749 = "175_1299450582.447" 
    $P2748."add_method"(type_obj, "CREATE", $P2749)
    get_how $P2750, type_obj
    .const 'Sub' $P2751 = "176_1299450582.447" 
    $P2750."add_method"(type_obj, "bless", $P2751)
    get_how $P2752, type_obj
    .const 'Sub' $P2753 = "177_1299450582.447" 
    $P2752."add_method"(type_obj, "BUILDALL", $P2753)
    get_how $P2754, type_obj
    .const 'Sub' $P2755 = "179_1299450582.447" 
    $P2754."add_method"(type_obj, "BUILD_MAGIC", $P2755)
    get_how $P2756, type_obj
    .const 'Sub' $P2757 = "181_1299450582.447" 
    $P2756."add_method"(type_obj, "new", $P2757)
    get_how $P2758, type_obj
    .const 'Sub' $P2759 = "182_1299450582.447" 
    new $P2760, "ResizablePMCArray"
    set_dispatchees $P2759, $P2760
    $P2758."add_method"(type_obj, "Str", $P2759)
    get_how $P2761, type_obj
    .const 'Sub' $P2762 = "182_1299450582.447" 
    newclosure $P2765, $P2762
    $P2761."add_parrot_vtable_mapping"(type_obj, "get_string", $P2765)
    get_how $P2766, type_obj
    .const 'Sub' $P2767 = "183_1299450582.447" 
    $P2766."add_multi_method"(type_obj, "Str", $P2767)
    get_how $P2768, type_obj
    .const 'Sub' $P2769 = "184_1299450582.447" 
    new $P2770, "ResizablePMCArray"
    set_dispatchees $P2769, $P2770
    $P2768."add_method"(type_obj, "ACCEPTS", $P2769)
    get_how $P2771, type_obj
    .const 'Sub' $P2772 = "185_1299450582.447" 
    $P2771."add_multi_method"(type_obj, "ACCEPTS", $P2772)
    get_how $P2773, type_obj
    .const 'Sub' $P2774 = "186_1299450582.447" 
    $P2773."add_method"(type_obj, "isa", $P2774)
    get_how $P2775, type_obj
    $P2776 = $P2775."compose"(type_obj)
    .return ($P2776)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("182_1299450582.447") :outer("187_1299450582.447")
    .param pmc param_2763
.annotate 'line', 1093
    .lex "self", param_2763
    multi_dispatch_over_lexical_candidates $P2764
    .return ($P2764)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "CREATE"  :subid("175_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2627
.annotate 'line', 1094
    .lex "self", param_2627
.annotate 'line', 1095
    find_lex $P2628, "self"
    repr_instance_of $P2629, $P2628
.annotate 'line', 1094
    .return ($P2629)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "bless"  :subid("176_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2631
    .param pmc param_2633 :slurpy :named
.annotate 'line', 1099
    .lex "$self", param_2631
    find_lex $P2632, "$self"
    .lex "self", $P2632
    .lex "%attributes", param_2633
.annotate 'line', 1100
    new $P2634, "Undef"
    .lex "$instance", $P2634
    find_lex $P2635, "self"
    $P2636 = $P2635."CREATE"()
    store_lex "$instance", $P2636
.annotate 'line', 1101
    find_lex $P2637, "$instance"
    find_lex $P2638, "%attributes"
    $P2637."BUILDALL"($P2638 :flat)
    find_lex $P2639, "$instance"
.annotate 'line', 1099
    .return ($P2639)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILDALL"  :subid("177_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2641
    .param pmc param_2643 :slurpy :named
.annotate 'line', 1105
    .const 'Sub' $P2652 = "178_1299450582.447" 
    capture_lex $P2652
    .lex "$self", param_2641
    find_lex $P2642, "$self"
    .lex "self", $P2642
    .lex "%attributes", param_2643
.annotate 'line', 1106
    find_lex $P2645, "$self"
    get_how $P2646, $P2645
    find_lex $P2647, "$self"
    $P2648 = $P2646."parents"($P2647)
    defined $I2649, $P2648
    unless $I2649, for_undef_430
    iter $P2644, $P2648
    new $P2659, 'ExceptionHandler'
    set_label $P2659, loop2658_handler
    $P2659."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2659
  loop2658_test:
    unless $P2644, loop2658_done
    shift $P2650, $P2644
  loop2658_redo:
    .const 'Sub' $P2652 = "178_1299450582.447" 
    capture_lex $P2652
    $P2652($P2650)
  loop2658_next:
    goto loop2658_test
  loop2658_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2660, exception, 'type'
    eq $P2660, .CONTROL_LOOP_NEXT, loop2658_next
    eq $P2660, .CONTROL_LOOP_REDO, loop2658_redo
  loop2658_done:
    pop_eh 
  for_undef_430:
.annotate 'line', 1105
    .return ($P2644)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "_block2651"  :anon :subid("178_1299450582.447") :outer("177_1299450582.447")
    .param pmc param_2653
.annotate 'line', 1106
    .lex "$class", param_2653
.annotate 'line', 1107
    find_lex $P2654, "$self"
    find_lex $P2655, "$class"
    find_lex $P2656, "%attributes"
    $P2657 = $P2654."BUILD_MAGIC"($P2655, $P2656 :flat)
.annotate 'line', 1106
    .return ($P2657)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.include "except_types.pasm"
.sub "BUILD_MAGIC"  :subid("179_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2662
    .param pmc param_2664
    .param pmc param_2665 :slurpy :named
.annotate 'line', 1111
    .const 'Sub' $P2674 = "180_1299450582.447" 
    capture_lex $P2674
    .lex "$self", param_2662
    find_lex $P2663, "$self"
    .lex "self", $P2663
    .lex "$type", param_2664
    .lex "%attributes", param_2665
.annotate 'line', 1112
    find_lex $P2667, "$type"
    get_how $P2668, $P2667
    find_lex $P2669, "$type"
    $P2670 = $P2668."attributes"($P2669, 1 :named("local"))
    defined $I2671, $P2670
    unless $I2671, for_undef_431
    iter $P2666, $P2670
    new $P2697, 'ExceptionHandler'
    set_label $P2697, loop2696_handler
    $P2697."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2697
  loop2696_test:
    unless $P2666, loop2696_done
    shift $P2672, $P2666
  loop2696_redo:
    .const 'Sub' $P2674 = "180_1299450582.447" 
    capture_lex $P2674
    $P2674($P2672)
  loop2696_next:
    goto loop2696_test
  loop2696_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2698, exception, 'type'
    eq $P2698, .CONTROL_LOOP_NEXT, loop2696_next
    eq $P2698, .CONTROL_LOOP_REDO, loop2696_redo
  loop2696_done:
    pop_eh 
  for_undef_431:
.annotate 'line', 1111
    .return ($P2666)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "_block2673"  :anon :subid("180_1299450582.447") :outer("179_1299450582.447")
    .param pmc param_2677
.annotate 'line', 1113
    new $P2675, "Undef"
    .lex "$name", $P2675
.annotate 'line', 1114
    new $P2676, "Undef"
    .lex "$shortname", $P2676
    .lex "$_", param_2677
.annotate 'line', 1113
    find_lex $P2678, "$_"
    $P2679 = $P2678."name"()
    store_lex "$name", $P2679
.annotate 'line', 1114
    find_lex $P2680, "$name"
    set $S2681, $P2680
    substr $S2682, $S2681, 2
    new $P2683, 'String'
    set $P2683, $S2682
    store_lex "$shortname", $P2683
.annotate 'line', 1115
    find_lex $P2687, "$shortname"
    find_lex $P2686, "%attributes"
    exists $I2688, $P2686[$P2687]
    if $I2688, if_2685
    new $P2684, 'Integer'
    set $P2684, $I2688
    goto if_2685_end
  if_2685:
.annotate 'line', 1116
    find_lex $P2689, "$self"
    find_lex $P2690, "$type"
    find_lex $P2691, "$name"
    set $S2692, $P2691
    find_lex $P2693, "$shortname"
    find_lex $P2694, "%attributes"
    unless_null $P2694, vivify_432
    $P2694 = root_new ['parrot';'Hash']
  vivify_432:
    set $P2695, $P2694[$P2693]
    unless_null $P2695, vivify_433
    new $P2695, "Undef"
  vivify_433:
    setattribute $P2689, $P2690, $S2692, $P2695
  if_2685_end:
.annotate 'line', 1112
    .return ($P2684)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "new"  :subid("181_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2700
    .param pmc param_2701 :slurpy :named
.annotate 'line', 1121
    .lex "self", param_2700
    .lex "%attributes", param_2701
.annotate 'line', 1122
    find_lex $P2702, "self"
    find_lex $P2703, "%attributes"
    $P2704 = $P2702."bless"($P2703 :flat)
.annotate 'line', 1121
    .return ($P2704)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "Str" :instanceof("DispatcherSub") :subid("182_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2706
.annotate 'line', 1121
    .lex "self", param_2706
    multi_dispatch_over_lexical_candidates $P2707
    .return ($P2707)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "Str"  :subid("183_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2709
.annotate 'line', 1126
    .lex "$self", param_2709
    find_lex $P2710, "$self"
    .lex "self", $P2710
.annotate 'line', 1127
    find_lex $P2711, "self"
    get_how $P2712, $P2711
    find_lex $P2713, "self"
    $P2714 = $P2712."name"($P2713)
    concat $P2715, $P2714, "()"
.annotate 'line', 1126
    .return ($P2715)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "" :load :init :subid("post434") :outer("183_1299450582.447")
.annotate 'line', 1126
    .const 'Sub' $P2708 = "183_1299450582.447" 
    .local pmc block
    set block, $P2708
    get_hll_global $P2716, "Mu"
    new $P2717, "ResizablePMCArray"
    push $P2717, $P2716
    new $P2718, "ResizablePMCArray"
    push $P2718, 2
    set_sub_multisig block, $P2717, $P2718
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "ACCEPTS" :instanceof("DispatcherSub") :subid("184_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2720
    .param pmc param_2721
.annotate 'line', 1126
    .lex "self", param_2720
.annotate 'line', 1130
    .lex "$topic", param_2721
.annotate 'line', 1126
    multi_dispatch_over_lexical_candidates $P2722
    .return ($P2722)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "ACCEPTS"  :subid("185_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2724
    .param pmc param_2726
.annotate 'line', 1131
    .lex "$self", param_2724
    find_lex $P2725, "$self"
    .lex "self", $P2725
    .lex "$topic", param_2726
.annotate 'line', 1132
    find_lex $P2727, "$topic"
    find_lex $P2728, "self"
    get_what $P2729, $P2728
    type_check $I2730, $P2727, $P2729
.annotate 'line', 1131
    .return ($I2730)
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "" :load :init :subid("post435") :outer("185_1299450582.447")
.annotate 'line', 1131
    .const 'Sub' $P2723 = "185_1299450582.447" 
    .local pmc block
    set block, $P2723
    get_hll_global $P2731, "NQPMu"
    null $P2732
    new $P2733, "ResizablePMCArray"
    push $P2733, $P2731
    push $P2733, $P2732
    new $P2734, "ResizablePMCArray"
    push $P2734, 2
    push $P2734, 0
    set_sub_multisig block, $P2733, $P2734
.end


.HLL "nqp"

.namespace ["NQPMu"]
.sub "isa"  :subid("186_1299450582.447") :outer("174_1299450582.447")
    .param pmc param_2736
    .param pmc param_2737
.annotate 'line', 1135
    .lex "self", param_2736
    .lex "$type", param_2737
.annotate 'line', 1136
    find_lex $P2738, "self"
    get_how $P2739, $P2738
    find_lex $P2740, "self"
    find_lex $P2741, "$type"
    $P2742 = $P2739."isa"($P2740, $P2741)
.annotate 'line', 1135
    .return ($P2742)
.end


.HLL "nqp"

.namespace ["int"]
.sub "_block2777"  :subid("188_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 1142
    .const 'Sub' $P2781 = "189_1299450582.447" 
    capture_lex $P2781
    get_global $P2779, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["int"]
.sub "" :load :init :subid("post436") :outer("188_1299450582.447")
.annotate 'line', 1142
    get_hll_global $P2778, ["int"], "_block2777" 
    .local pmc block
    set block, $P2778
    .const 'Sub' $P2781 = "189_1299450582.447" 
    capture_lex $P2781
    $P2781()
.end


.HLL "nqp"

.namespace ["int"]
.sub "_block2780"  :anon :subid("189_1299450582.447") :outer("188_1299450582.447")
.annotate 'line', 1142
    get_hll_global $P2782, "NQPNativeHOW"
    $P2783 = $P2782."new_type"("int" :named("name"), "P6int" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2783
    set_hll_global "int", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2784, type_obj
    $P2785 = $P2784."compose"(type_obj)
    .return ($P2785)
.end


.HLL "nqp"

.namespace ["num"]
.sub "_block2786"  :subid("190_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 1144
    .const 'Sub' $P2790 = "191_1299450582.447" 
    capture_lex $P2790
    get_global $P2788, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["num"]
.sub "" :load :init :subid("post437") :outer("190_1299450582.447")
.annotate 'line', 1144
    get_hll_global $P2787, ["num"], "_block2786" 
    .local pmc block
    set block, $P2787
    .const 'Sub' $P2790 = "191_1299450582.447" 
    capture_lex $P2790
    $P2790()
.end


.HLL "nqp"

.namespace ["num"]
.sub "_block2789"  :anon :subid("191_1299450582.447") :outer("190_1299450582.447")
.annotate 'line', 1144
    get_hll_global $P2791, "NQPNativeHOW"
    $P2792 = $P2791."new_type"("num" :named("name"), "P6num" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2792
    set_hll_global "num", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2793, type_obj
    $P2794 = $P2793."compose"(type_obj)
    .return ($P2794)
.end


.HLL "nqp"

.namespace ["str"]
.sub "_block2795"  :subid("192_1299450582.447") :outer("10_1299450582.447")
.annotate 'line', 1146
    .const 'Sub' $P2799 = "193_1299450582.447" 
    capture_lex $P2799
    get_global $P2797, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["str"]
.sub "" :load :init :subid("post438") :outer("192_1299450582.447")
.annotate 'line', 1146
    get_hll_global $P2796, ["str"], "_block2795" 
    .local pmc block
    set block, $P2796
    .const 'Sub' $P2799 = "193_1299450582.447" 
    capture_lex $P2799
    $P2799()
.end


.HLL "nqp"

.namespace ["str"]
.sub "_block2798"  :anon :subid("193_1299450582.447") :outer("192_1299450582.447")
.annotate 'line', 1146
    get_hll_global $P2800, "NQPNativeHOW"
    $P2801 = $P2800."new_type"("str" :named("name"), "P6str" :named("repr"))
    .local pmc type_obj
    set type_obj, $P2801
    set_hll_global "str", type_obj
    set_global "$?CLASS", type_obj
    get_how $P2802, type_obj
    $P2803 = $P2802."compose"(type_obj)
    .return ($P2803)
.end


.HLL "nqp"

.namespace []
.sub "_block2805" :load :anon :subid("194_1299450582.447")
.annotate 'line', 1
    .const 'Sub' $P2807 = "10_1299450582.447" 
    $P2808 = $P2807()
    .return ($P2808)
.end


.sub '' :anon :load :init
    load_bytecode 'P6Regex.pbc'
    
    ## Bring in PAST and PCT
    .local pmc hllns, parrotns, imports
    hllns = get_hll_namespace
    parrotns = get_root_namespace ['parrot']
    imports = split ' ', 'PAST PCT'
    parrotns.'export_to'(hllns, imports)
.end

### .include 'gen/nqp-grammar.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299450589.65")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Grammar"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    capture_lex $P15
    $P2430 = $P15()
.annotate 'line', 1
    .return ($P2430)
    .const 'Sub' $P2432 = "402_1299450589.65" 
    .return ($P2432)
.end


.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Grammar"]
.sub "_block14"  :subid("11_1299450589.65") :outer("10_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P1715 = "401_1299450589.65" 
    capture_lex $P1715
    get_hll_global $P1606, ["NQP";"Regex"], "_block1605" 
    capture_lex $P1606
    .const 'Sub' $P1594 = "377_1299450589.65" 
    capture_lex $P1594
    .const 'Sub' $P1588 = "375_1299450589.65" 
    capture_lex $P1588
    .const 'Sub' $P1582 = "373_1299450589.65" 
    capture_lex $P1582
    .const 'Sub' $P1576 = "371_1299450589.65" 
    capture_lex $P1576
    .const 'Sub' $P1570 = "369_1299450589.65" 
    capture_lex $P1570
    .const 'Sub' $P1558 = "366_1299450589.65" 
    capture_lex $P1558
    .const 'Sub' $P1551 = "364_1299450589.65" 
    capture_lex $P1551
    .const 'Sub' $P1544 = "362_1299450589.65" 
    capture_lex $P1544
    .const 'Sub' $P1537 = "360_1299450589.65" 
    capture_lex $P1537
    .const 'Sub' $P1530 = "358_1299450589.65" 
    capture_lex $P1530
    .const 'Sub' $P1524 = "356_1299450589.65" 
    capture_lex $P1524
    .const 'Sub' $P1517 = "354_1299450589.65" 
    capture_lex $P1517
    .const 'Sub' $P1510 = "352_1299450589.65" 
    capture_lex $P1510
    .const 'Sub' $P1503 = "350_1299450589.65" 
    capture_lex $P1503
    .const 'Sub' $P1496 = "348_1299450589.65" 
    capture_lex $P1496
    .const 'Sub' $P1489 = "346_1299450589.65" 
    capture_lex $P1489
    .const 'Sub' $P1482 = "344_1299450589.65" 
    capture_lex $P1482
    .const 'Sub' $P1475 = "342_1299450589.65" 
    capture_lex $P1475
    .const 'Sub' $P1468 = "340_1299450589.65" 
    capture_lex $P1468
    .const 'Sub' $P1461 = "338_1299450589.65" 
    capture_lex $P1461
    .const 'Sub' $P1454 = "336_1299450589.65" 
    capture_lex $P1454
    .const 'Sub' $P1447 = "334_1299450589.65" 
    capture_lex $P1447
    .const 'Sub' $P1440 = "332_1299450589.65" 
    capture_lex $P1440
    .const 'Sub' $P1433 = "330_1299450589.65" 
    capture_lex $P1433
    .const 'Sub' $P1426 = "328_1299450589.65" 
    capture_lex $P1426
    .const 'Sub' $P1419 = "326_1299450589.65" 
    capture_lex $P1419
    .const 'Sub' $P1412 = "324_1299450589.65" 
    capture_lex $P1412
    .const 'Sub' $P1405 = "322_1299450589.65" 
    capture_lex $P1405
    .const 'Sub' $P1398 = "320_1299450589.65" 
    capture_lex $P1398
    .const 'Sub' $P1391 = "318_1299450589.65" 
    capture_lex $P1391
    .const 'Sub' $P1384 = "316_1299450589.65" 
    capture_lex $P1384
    .const 'Sub' $P1377 = "314_1299450589.65" 
    capture_lex $P1377
    .const 'Sub' $P1370 = "312_1299450589.65" 
    capture_lex $P1370
    .const 'Sub' $P1363 = "310_1299450589.65" 
    capture_lex $P1363
    .const 'Sub' $P1356 = "308_1299450589.65" 
    capture_lex $P1356
    .const 'Sub' $P1349 = "306_1299450589.65" 
    capture_lex $P1349
    .const 'Sub' $P1342 = "304_1299450589.65" 
    capture_lex $P1342
    .const 'Sub' $P1335 = "302_1299450589.65" 
    capture_lex $P1335
    .const 'Sub' $P1328 = "300_1299450589.65" 
    capture_lex $P1328
    .const 'Sub' $P1321 = "298_1299450589.65" 
    capture_lex $P1321
    .const 'Sub' $P1315 = "296_1299450589.65" 
    capture_lex $P1315
    .const 'Sub' $P1308 = "294_1299450589.65" 
    capture_lex $P1308
    .const 'Sub' $P1301 = "292_1299450589.65" 
    capture_lex $P1301
    .const 'Sub' $P1294 = "290_1299450589.65" 
    capture_lex $P1294
    .const 'Sub' $P1287 = "288_1299450589.65" 
    capture_lex $P1287
    .const 'Sub' $P1280 = "286_1299450589.65" 
    capture_lex $P1280
    .const 'Sub' $P1273 = "284_1299450589.65" 
    capture_lex $P1273
    .const 'Sub' $P1266 = "282_1299450589.65" 
    capture_lex $P1266
    .const 'Sub' $P1260 = "280_1299450589.65" 
    capture_lex $P1260
    .const 'Sub' $P1254 = "278_1299450589.65" 
    capture_lex $P1254
    .const 'Sub' $P1249 = "276_1299450589.65" 
    capture_lex $P1249
    .const 'Sub' $P1243 = "274_1299450589.65" 
    capture_lex $P1243
    .const 'Sub' $P1237 = "272_1299450589.65" 
    capture_lex $P1237
    .const 'Sub' $P1232 = "270_1299450589.65" 
    capture_lex $P1232
    .const 'Sub' $P1227 = "268_1299450589.65" 
    capture_lex $P1227
    .const 'Sub' $P1211 = "267_1299450589.65" 
    capture_lex $P1211
    .const 'Sub' $P1202 = "265_1299450589.65" 
    capture_lex $P1202
    .const 'Sub' $P1193 = "263_1299450589.65" 
    capture_lex $P1193
    .const 'Sub' $P1188 = "261_1299450589.65" 
    capture_lex $P1188
    .const 'Sub' $P1183 = "259_1299450589.65" 
    capture_lex $P1183
    .const 'Sub' $P1178 = "257_1299450589.65" 
    capture_lex $P1178
    .const 'Sub' $P1170 = "255_1299450589.65" 
    capture_lex $P1170
    .const 'Sub' $P1162 = "253_1299450589.65" 
    capture_lex $P1162
    .const 'Sub' $P1157 = "251_1299450589.65" 
    capture_lex $P1157
    .const 'Sub' $P1152 = "249_1299450589.65" 
    capture_lex $P1152
    .const 'Sub' $P1147 = "247_1299450589.65" 
    capture_lex $P1147
    .const 'Sub' $P1141 = "245_1299450589.65" 
    capture_lex $P1141
    .const 'Sub' $P1135 = "243_1299450589.65" 
    capture_lex $P1135
    .const 'Sub' $P1129 = "241_1299450589.65" 
    capture_lex $P1129
    .const 'Sub' $P1123 = "239_1299450589.65" 
    capture_lex $P1123
    .const 'Sub' $P1117 = "237_1299450589.65" 
    capture_lex $P1117
    .const 'Sub' $P1112 = "235_1299450589.65" 
    capture_lex $P1112
    .const 'Sub' $P1107 = "233_1299450589.65" 
    capture_lex $P1107
    .const 'Sub' $P1093 = "229_1299450589.65" 
    capture_lex $P1093
    .const 'Sub' $P1085 = "227_1299450589.65" 
    capture_lex $P1085
    .const 'Sub' $P1079 = "225_1299450589.65" 
    capture_lex $P1079
    .const 'Sub' $P1072 = "223_1299450589.65" 
    capture_lex $P1072
    .const 'Sub' $P1066 = "221_1299450589.65" 
    capture_lex $P1066
    .const 'Sub' $P1052 = "218_1299450589.65" 
    capture_lex $P1052
    .const 'Sub' $P1044 = "216_1299450589.65" 
    capture_lex $P1044
    .const 'Sub' $P1036 = "214_1299450589.65" 
    capture_lex $P1036
    .const 'Sub' $P1030 = "212_1299450589.65" 
    capture_lex $P1030
    .const 'Sub' $P1024 = "210_1299450589.65" 
    capture_lex $P1024
    .const 'Sub' $P1008 = "206_1299450589.65" 
    capture_lex $P1008
    .const 'Sub' $P967 = "204_1299450589.65" 
    capture_lex $P967
    .const 'Sub' $P956 = "202_1299450589.65" 
    capture_lex $P956
    .const 'Sub' $P942 = "198_1299450589.65" 
    capture_lex $P942
    .const 'Sub' $P933 = "196_1299450589.65" 
    capture_lex $P933
    .const 'Sub' $P927 = "194_1299450589.65" 
    capture_lex $P927
    .const 'Sub' $P917 = "192_1299450589.65" 
    capture_lex $P917
    .const 'Sub' $P902 = "190_1299450589.65" 
    capture_lex $P902
    .const 'Sub' $P888 = "187_1299450589.65" 
    capture_lex $P888
    .const 'Sub' $P880 = "185_1299450589.65" 
    capture_lex $P880
    .const 'Sub' $P870 = "183_1299450589.65" 
    capture_lex $P870
    .const 'Sub' $P860 = "181_1299450589.65" 
    capture_lex $P860
    .const 'Sub' $P841 = "176_1299450589.65" 
    capture_lex $P841
    .const 'Sub' $P797 = "173_1299450589.65" 
    capture_lex $P797
    .const 'Sub' $P763 = "171_1299450589.65" 
    capture_lex $P763
    .const 'Sub' $P756 = "169_1299450589.65" 
    capture_lex $P756
    .const 'Sub' $P749 = "167_1299450589.65" 
    capture_lex $P749
    .const 'Sub' $P732 = "163_1299450589.65" 
    capture_lex $P732
    .const 'Sub' $P724 = "161_1299450589.65" 
    capture_lex $P724
    .const 'Sub' $P718 = "159_1299450589.65" 
    capture_lex $P718
    .const 'Sub' $P705 = "157_1299450589.65" 
    capture_lex $P705
    .const 'Sub' $P698 = "155_1299450589.65" 
    capture_lex $P698
    .const 'Sub' $P691 = "153_1299450589.65" 
    capture_lex $P691
    .const 'Sub' $P684 = "151_1299450589.65" 
    capture_lex $P684
    .const 'Sub' $P643 = "147_1299450589.65" 
    capture_lex $P643
    .const 'Sub' $P631 = "145_1299450589.65" 
    capture_lex $P631
    .const 'Sub' $P619 = "143_1299450589.65" 
    capture_lex $P619
    .const 'Sub' $P607 = "141_1299450589.65" 
    capture_lex $P607
    .const 'Sub' $P595 = "139_1299450589.65" 
    capture_lex $P595
    .const 'Sub' $P583 = "137_1299450589.65" 
    capture_lex $P583
    .const 'Sub' $P571 = "135_1299450589.65" 
    capture_lex $P571
    .const 'Sub' $P560 = "131_1299450589.65" 
    capture_lex $P560
    .const 'Sub' $P555 = "129_1299450589.65" 
    capture_lex $P555
    .const 'Sub' $P543 = "127_1299450589.65" 
    capture_lex $P543
    .const 'Sub' $P531 = "125_1299450589.65" 
    capture_lex $P531
    .const 'Sub' $P524 = "123_1299450589.65" 
    capture_lex $P524
    .const 'Sub' $P519 = "121_1299450589.65" 
    capture_lex $P519
    .const 'Sub' $P513 = "119_1299450589.65" 
    capture_lex $P513
    .const 'Sub' $P507 = "117_1299450589.65" 
    capture_lex $P507
    .const 'Sub' $P492 = "113_1299450589.65" 
    capture_lex $P492
    .const 'Sub' $P486 = "111_1299450589.65" 
    capture_lex $P486
    .const 'Sub' $P480 = "109_1299450589.65" 
    capture_lex $P480
    .const 'Sub' $P474 = "107_1299450589.65" 
    capture_lex $P474
    .const 'Sub' $P468 = "105_1299450589.65" 
    capture_lex $P468
    .const 'Sub' $P462 = "103_1299450589.65" 
    capture_lex $P462
    .const 'Sub' $P456 = "101_1299450589.65" 
    capture_lex $P456
    .const 'Sub' $P447 = "99_1299450589.65" 
    capture_lex $P447
    .const 'Sub' $P438 = "97_1299450589.65" 
    capture_lex $P438
    .const 'Sub' $P429 = "95_1299450589.65" 
    capture_lex $P429
    .const 'Sub' $P414 = "91_1299450589.65" 
    capture_lex $P414
    .const 'Sub' $P405 = "89_1299450589.65" 
    capture_lex $P405
    .const 'Sub' $P393 = "85_1299450589.65" 
    capture_lex $P393
    .const 'Sub' $P386 = "83_1299450589.65" 
    capture_lex $P386
    .const 'Sub' $P379 = "81_1299450589.65" 
    capture_lex $P379
    .const 'Sub' $P365 = "77_1299450589.65" 
    capture_lex $P365
    .const 'Sub' $P357 = "75_1299450589.65" 
    capture_lex $P357
    .const 'Sub' $P349 = "73_1299450589.65" 
    capture_lex $P349
    .const 'Sub' $P329 = "71_1299450589.65" 
    capture_lex $P329
    .const 'Sub' $P320 = "69_1299450589.65" 
    capture_lex $P320
    .const 'Sub' $P302 = "66_1299450589.65" 
    capture_lex $P302
    .const 'Sub' $P284 = "64_1299450589.65" 
    capture_lex $P284
    .const 'Sub' $P273 = "60_1299450589.65" 
    capture_lex $P273
    .const 'Sub' $P268 = "58_1299450589.65" 
    capture_lex $P268
    .const 'Sub' $P257 = "54_1299450589.65" 
    capture_lex $P257
    .const 'Sub' $P252 = "52_1299450589.65" 
    capture_lex $P252
    .const 'Sub' $P247 = "50_1299450589.65" 
    capture_lex $P247
    .const 'Sub' $P242 = "48_1299450589.65" 
    capture_lex $P242
    .const 'Sub' $P232 = "46_1299450589.65" 
    capture_lex $P232
    .const 'Sub' $P225 = "44_1299450589.65" 
    capture_lex $P225
    .const 'Sub' $P219 = "42_1299450589.65" 
    capture_lex $P219
    .const 'Sub' $P211 = "40_1299450589.65" 
    capture_lex $P211
    .const 'Sub' $P205 = "38_1299450589.65" 
    capture_lex $P205
    .const 'Sub' $P199 = "36_1299450589.65" 
    capture_lex $P199
    .const 'Sub' $P184 = "33_1299450589.65" 
    capture_lex $P184
    .const 'Sub' $P170 = "31_1299450589.65" 
    capture_lex $P170
    .const 'Sub' $P161 = "29_1299450589.65" 
    capture_lex $P161
    .const 'Sub' $P122 = "26_1299450589.65" 
    capture_lex $P122
    .const 'Sub' $P107 = "23_1299450589.65" 
    capture_lex $P107
    .const 'Sub' $P96 = "21_1299450589.65" 
    capture_lex $P96
    .const 'Sub' $P84 = "19_1299450589.65" 
    capture_lex $P84
    .const 'Sub' $P76 = "17_1299450589.65" 
    capture_lex $P76
    .const 'Sub' $P69 = "15_1299450589.65" 
    capture_lex $P69
    .const 'Sub' $P62 = "13_1299450589.65" 
    capture_lex $P62
    .const 'Sub' $P18 = "12_1299450589.65" 
    capture_lex $P18
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "Regex"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    .const 'Sub' $P1211 = "267_1299450589.65" 
    capture_lex $P1211
    $P1211()
.annotate 'line', 663
    get_hll_global $P1606, ["NQP";"Regex"], "_block1605" 
    capture_lex $P1606
    $P1709 = $P1606()
.annotate 'line', 4
    .return ($P1709)
    .const 'Sub' $P1711 = "400_1299450589.65" 
    .return ($P1711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post403") :outer("11_1299450589.65")
.annotate 'line', 4
    get_hll_global $P15, ["NQP";"Grammar"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P1715 = "401_1299450589.65" 
    capture_lex $P1715
    $P1715()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1714"  :anon :subid("401_1299450589.65") :outer("11_1299450589.65")
.annotate 'line', 4
    get_hll_global $P1716, "NQPClassHOW"
    $P1717 = $P1716."new_type"("Grammar" :named("name"))
    .local pmc type_obj
    set type_obj, $P1717
    set_hll_global ["NQP"], "Grammar", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1718, type_obj
    .const 'Sub' $P1719 = "12_1299450589.65" 
    $P1718."add_method"(type_obj, "TOP", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "13_1299450589.65" 
    $P1720."add_method"(type_obj, "identifier", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__identifier"
    $P1722."add_method"(type_obj, "!PREFIX__identifier", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "15_1299450589.65" 
    $P1724."add_method"(type_obj, "name", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__name"
    $P1726."add_method"(type_obj, "!PREFIX__name", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "17_1299450589.65" 
    $P1728."add_method"(type_obj, "deflongname", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__deflongname"
    $P1730."add_method"(type_obj, "!PREFIX__deflongname", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "19_1299450589.65" 
    $P1732."add_method"(type_obj, "ENDSTMT", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__ENDSTMT"
    $P1734."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "21_1299450589.65" 
    $P1736."add_method"(type_obj, "ws", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__ws"
    $P1738."add_method"(type_obj, "!PREFIX__ws", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "23_1299450589.65" 
    $P1740."add_method"(type_obj, "unv", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__unv"
    $P1742."add_method"(type_obj, "!PREFIX__unv", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "26_1299450589.65" 
    $P1744."add_method"(type_obj, "pod_comment", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__pod_comment"
    $P1746."add_method"(type_obj, "!PREFIX__pod_comment", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "29_1299450589.65" 
    $P1748."add_method"(type_obj, "comp_unit", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__comp_unit"
    $P1750."add_method"(type_obj, "!PREFIX__comp_unit", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "31_1299450589.65" 
    $P1752."add_method"(type_obj, "statementlist", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__statementlist"
    $P1754."add_method"(type_obj, "!PREFIX__statementlist", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "33_1299450589.65" 
    $P1756."add_method"(type_obj, "statement", $P1757)
    get_how $P1758, type_obj
    get_global $P1759, "!PREFIX__statement"
    $P1758."add_method"(type_obj, "!PREFIX__statement", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "36_1299450589.65" 
    $P1760."add_method"(type_obj, "eat_terminator", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__eat_terminator"
    $P1762."add_method"(type_obj, "!PREFIX__eat_terminator", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "38_1299450589.65" 
    $P1764."add_method"(type_obj, "xblock", $P1765)
    get_how $P1766, type_obj
    get_global $P1767, "!PREFIX__xblock"
    $P1766."add_method"(type_obj, "!PREFIX__xblock", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "40_1299450589.65" 
    $P1768."add_method"(type_obj, "pblock", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__pblock"
    $P1770."add_method"(type_obj, "!PREFIX__pblock", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "42_1299450589.65" 
    $P1772."add_method"(type_obj, "lambda", $P1773)
    get_how $P1774, type_obj
    get_global $P1775, "!PREFIX__lambda"
    $P1774."add_method"(type_obj, "!PREFIX__lambda", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "44_1299450589.65" 
    $P1776."add_method"(type_obj, "block", $P1777)
    get_how $P1778, type_obj
    get_global $P1779, "!PREFIX__block"
    $P1778."add_method"(type_obj, "!PREFIX__block", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "46_1299450589.65" 
    $P1780."add_method"(type_obj, "blockoid", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__blockoid"
    $P1782."add_method"(type_obj, "!PREFIX__blockoid", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "48_1299450589.65" 
    $P1784."add_method"(type_obj, "newpad", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__newpad"
    $P1786."add_method"(type_obj, "!PREFIX__newpad", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "50_1299450589.65" 
    $P1788."add_method"(type_obj, "outerctx", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__outerctx"
    $P1790."add_method"(type_obj, "!PREFIX__outerctx", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "52_1299450589.65" 
    $P1792."add_method"(type_obj, "finishpad", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__finishpad"
    $P1794."add_method"(type_obj, "!PREFIX__finishpad", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "54_1299450589.65" 
    $P1796."add_method"(type_obj, "you_are_here", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__you_are_here"
    $P1798."add_method"(type_obj, "!PREFIX__you_are_here", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "56_1299450589.65" 
    $P1800."add_method"(type_obj, "terminator", $P1801)
    get_how $P1802, type_obj
    .const 'Sub' $P1803 = "57_1299450589.65" 
    $P1802."add_method"(type_obj, "!PREFIX__terminator", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "58_1299450589.65" 
    $P1804."add_method"(type_obj, "terminator:sym<;>", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__terminator:sym<;>"
    $P1806."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "60_1299450589.65" 
    $P1808."add_method"(type_obj, "terminator:sym<}>", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__terminator:sym<}>"
    $P1810."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "62_1299450589.65" 
    $P1812."add_method"(type_obj, "statement_control", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "63_1299450589.65" 
    $P1814."add_method"(type_obj, "!PREFIX__statement_control", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "64_1299450589.65" 
    $P1816."add_method"(type_obj, "statement_control:sym<if>", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__statement_control:sym<if>"
    $P1818."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "66_1299450589.65" 
    $P1820."add_method"(type_obj, "statement_control:sym<unless>", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__statement_control:sym<unless>"
    $P1822."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "69_1299450589.65" 
    $P1824."add_method"(type_obj, "statement_control:sym<while>", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__statement_control:sym<while>"
    $P1826."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "71_1299450589.65" 
    $P1828."add_method"(type_obj, "statement_control:sym<repeat>", $P1829)
    get_how $P1830, type_obj
    get_global $P1831, "!PREFIX__statement_control:sym<repeat>"
    $P1830."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "73_1299450589.65" 
    $P1832."add_method"(type_obj, "statement_control:sym<for>", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__statement_control:sym<for>"
    $P1834."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "75_1299450589.65" 
    $P1836."add_method"(type_obj, "statement_control:sym<CATCH>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__statement_control:sym<CATCH>"
    $P1838."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "77_1299450589.65" 
    $P1840."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1841)
    get_how $P1842, type_obj
    get_global $P1843, "!PREFIX__statement_control:sym<CONTROL>"
    $P1842."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "79_1299450589.65" 
    $P1844."add_method"(type_obj, "statement_prefix", $P1845)
    get_how $P1846, type_obj
    .const 'Sub' $P1847 = "80_1299450589.65" 
    $P1846."add_method"(type_obj, "!PREFIX__statement_prefix", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "81_1299450589.65" 
    $P1848."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__statement_prefix:sym<INIT>"
    $P1850."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "83_1299450589.65" 
    $P1852."add_method"(type_obj, "statement_prefix:sym<try>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__statement_prefix:sym<try>"
    $P1854."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "85_1299450589.65" 
    $P1856."add_method"(type_obj, "blorst", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__blorst"
    $P1858."add_method"(type_obj, "!PREFIX__blorst", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "87_1299450589.65" 
    $P1860."add_method"(type_obj, "statement_mod_cond", $P1861)
    get_how $P1862, type_obj
    .const 'Sub' $P1863 = "88_1299450589.65" 
    $P1862."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "89_1299450589.65" 
    $P1864."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__statement_mod_cond:sym<if>"
    $P1866."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "91_1299450589.65" 
    $P1868."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1870."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "93_1299450589.65" 
    $P1872."add_method"(type_obj, "statement_mod_loop", $P1873)
    get_how $P1874, type_obj
    .const 'Sub' $P1875 = "94_1299450589.65" 
    $P1874."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "95_1299450589.65" 
    $P1876."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__statement_mod_loop:sym<while>"
    $P1878."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "97_1299450589.65" 
    $P1880."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__statement_mod_loop:sym<until>"
    $P1882."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "99_1299450589.65" 
    $P1884."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__statement_mod_loop:sym<for>"
    $P1886."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "101_1299450589.65" 
    $P1888."add_method"(type_obj, "term:sym<fatarrow>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__term:sym<fatarrow>"
    $P1890."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "103_1299450589.65" 
    $P1892."add_method"(type_obj, "term:sym<colonpair>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__term:sym<colonpair>"
    $P1894."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "105_1299450589.65" 
    $P1896."add_method"(type_obj, "term:sym<variable>", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__term:sym<variable>"
    $P1898."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "107_1299450589.65" 
    $P1900."add_method"(type_obj, "term:sym<package_declarator>", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__term:sym<package_declarator>"
    $P1902."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "109_1299450589.65" 
    $P1904."add_method"(type_obj, "term:sym<scope_declarator>", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__term:sym<scope_declarator>"
    $P1906."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "111_1299450589.65" 
    $P1908."add_method"(type_obj, "term:sym<routine_declarator>", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__term:sym<routine_declarator>"
    $P1910."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "113_1299450589.65" 
    $P1912."add_method"(type_obj, "term:sym<multi_declarator>", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__term:sym<multi_declarator>"
    $P1914."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "117_1299450589.65" 
    $P1916."add_method"(type_obj, "term:sym<regex_declarator>", $P1917)
    get_how $P1918, type_obj
    get_global $P1919, "!PREFIX__term:sym<regex_declarator>"
    $P1918."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "119_1299450589.65" 
    $P1920."add_method"(type_obj, "term:sym<statement_prefix>", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__term:sym<statement_prefix>"
    $P1922."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "121_1299450589.65" 
    $P1924."add_method"(type_obj, "term:sym<lambda>", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__term:sym<lambda>"
    $P1926."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "123_1299450589.65" 
    $P1928."add_method"(type_obj, "fatarrow", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__fatarrow"
    $P1930."add_method"(type_obj, "!PREFIX__fatarrow", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "125_1299450589.65" 
    $P1932."add_method"(type_obj, "colonpair", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__colonpair"
    $P1934."add_method"(type_obj, "!PREFIX__colonpair", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "127_1299450589.65" 
    $P1936."add_method"(type_obj, "variable", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__variable"
    $P1938."add_method"(type_obj, "!PREFIX__variable", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "129_1299450589.65" 
    $P1940."add_method"(type_obj, "sigil", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__sigil"
    $P1942."add_method"(type_obj, "!PREFIX__sigil", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "131_1299450589.65" 
    $P1944."add_method"(type_obj, "twigil", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__twigil"
    $P1946."add_method"(type_obj, "!PREFIX__twigil", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "133_1299450589.65" 
    $P1948."add_method"(type_obj, "package_declarator", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "134_1299450589.65" 
    $P1950."add_method"(type_obj, "!PREFIX__package_declarator", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "135_1299450589.65" 
    $P1952."add_method"(type_obj, "package_declarator:sym<module>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__package_declarator:sym<module>"
    $P1954."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "137_1299450589.65" 
    $P1956."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__package_declarator:sym<knowhow>"
    $P1958."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "139_1299450589.65" 
    $P1960."add_method"(type_obj, "package_declarator:sym<class>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__package_declarator:sym<class>"
    $P1962."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "141_1299450589.65" 
    $P1964."add_method"(type_obj, "package_declarator:sym<grammar>", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__package_declarator:sym<grammar>"
    $P1966."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "143_1299450589.65" 
    $P1968."add_method"(type_obj, "package_declarator:sym<role>", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__package_declarator:sym<role>"
    $P1970."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "145_1299450589.65" 
    $P1972."add_method"(type_obj, "package_declarator:sym<native>", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__package_declarator:sym<native>"
    $P1974."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "147_1299450589.65" 
    $P1976."add_method"(type_obj, "package_def", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__package_def"
    $P1978."add_method"(type_obj, "!PREFIX__package_def", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "149_1299450589.65" 
    $P1980."add_method"(type_obj, "scope_declarator", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "150_1299450589.65" 
    $P1982."add_method"(type_obj, "!PREFIX__scope_declarator", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "151_1299450589.65" 
    $P1984."add_method"(type_obj, "scope_declarator:sym<my>", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__scope_declarator:sym<my>"
    $P1986."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "153_1299450589.65" 
    $P1988."add_method"(type_obj, "scope_declarator:sym<our>", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__scope_declarator:sym<our>"
    $P1990."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "155_1299450589.65" 
    $P1992."add_method"(type_obj, "scope_declarator:sym<has>", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__scope_declarator:sym<has>"
    $P1994."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "157_1299450589.65" 
    $P1996."add_method"(type_obj, "scoped", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__scoped"
    $P1998."add_method"(type_obj, "!PREFIX__scoped", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "159_1299450589.65" 
    $P2000."add_method"(type_obj, "typename", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__typename"
    $P2002."add_method"(type_obj, "!PREFIX__typename", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "161_1299450589.65" 
    $P2004."add_method"(type_obj, "declarator", $P2005)
    get_how $P2006, type_obj
    get_global $P2007, "!PREFIX__declarator"
    $P2006."add_method"(type_obj, "!PREFIX__declarator", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "163_1299450589.65" 
    $P2008."add_method"(type_obj, "variable_declarator", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__variable_declarator"
    $P2010."add_method"(type_obj, "!PREFIX__variable_declarator", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "165_1299450589.65" 
    $P2012."add_method"(type_obj, "routine_declarator", $P2013)
    get_how $P2014, type_obj
    .const 'Sub' $P2015 = "166_1299450589.65" 
    $P2014."add_method"(type_obj, "!PREFIX__routine_declarator", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "167_1299450589.65" 
    $P2016."add_method"(type_obj, "routine_declarator:sym<sub>", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__routine_declarator:sym<sub>"
    $P2018."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "169_1299450589.65" 
    $P2020."add_method"(type_obj, "routine_declarator:sym<method>", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__routine_declarator:sym<method>"
    $P2022."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "171_1299450589.65" 
    $P2024."add_method"(type_obj, "routine_def", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__routine_def"
    $P2026."add_method"(type_obj, "!PREFIX__routine_def", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "173_1299450589.65" 
    $P2028."add_method"(type_obj, "method_def", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__method_def"
    $P2030."add_method"(type_obj, "!PREFIX__method_def", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "176_1299450589.65" 
    $P2032."add_method"(type_obj, "onlystar", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__onlystar"
    $P2034."add_method"(type_obj, "!PREFIX__onlystar", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "179_1299450589.65" 
    $P2036."add_method"(type_obj, "multi_declarator", $P2037)
    get_how $P2038, type_obj
    .const 'Sub' $P2039 = "180_1299450589.65" 
    $P2038."add_method"(type_obj, "!PREFIX__multi_declarator", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "181_1299450589.65" 
    $P2040."add_method"(type_obj, "multi_declarator:sym<multi>", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__multi_declarator:sym<multi>"
    $P2042."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "183_1299450589.65" 
    $P2044."add_method"(type_obj, "multi_declarator:sym<proto>", $P2045)
    get_how $P2046, type_obj
    get_global $P2047, "!PREFIX__multi_declarator:sym<proto>"
    $P2046."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "185_1299450589.65" 
    $P2048."add_method"(type_obj, "multi_declarator:sym<null>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__multi_declarator:sym<null>"
    $P2050."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "187_1299450589.65" 
    $P2052."add_method"(type_obj, "signature", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__signature"
    $P2054."add_method"(type_obj, "!PREFIX__signature", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "190_1299450589.65" 
    $P2056."add_method"(type_obj, "parameter", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__parameter"
    $P2058."add_method"(type_obj, "!PREFIX__parameter", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "192_1299450589.65" 
    $P2060."add_method"(type_obj, "param_var", $P2061)
    get_how $P2062, type_obj
    get_global $P2063, "!PREFIX__param_var"
    $P2062."add_method"(type_obj, "!PREFIX__param_var", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "194_1299450589.65" 
    $P2064."add_method"(type_obj, "named_param", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__named_param"
    $P2066."add_method"(type_obj, "!PREFIX__named_param", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "196_1299450589.65" 
    $P2068."add_method"(type_obj, "default_value", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__default_value"
    $P2070."add_method"(type_obj, "!PREFIX__default_value", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "198_1299450589.65" 
    $P2072."add_method"(type_obj, "trait", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__trait"
    $P2074."add_method"(type_obj, "!PREFIX__trait", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "200_1299450589.65" 
    $P2076."add_method"(type_obj, "trait_mod", $P2077)
    get_how $P2078, type_obj
    .const 'Sub' $P2079 = "201_1299450589.65" 
    $P2078."add_method"(type_obj, "!PREFIX__trait_mod", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "202_1299450589.65" 
    $P2080."add_method"(type_obj, "trait_mod:sym<is>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__trait_mod:sym<is>"
    $P2082."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "204_1299450589.65" 
    $P2084."add_method"(type_obj, "regex_declarator", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__regex_declarator"
    $P2086."add_method"(type_obj, "!PREFIX__regex_declarator", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "206_1299450589.65" 
    $P2088."add_method"(type_obj, "dotty", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__dotty"
    $P2090."add_method"(type_obj, "!PREFIX__dotty", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "208_1299450589.65" 
    $P2092."add_method"(type_obj, "term", $P2093)
    get_how $P2094, type_obj
    .const 'Sub' $P2095 = "209_1299450589.65" 
    $P2094."add_method"(type_obj, "!PREFIX__term", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "210_1299450589.65" 
    $P2096."add_method"(type_obj, "term:sym<self>", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__term:sym<self>"
    $P2098."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "212_1299450589.65" 
    $P2100."add_method"(type_obj, "term:sym<identifier>", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__term:sym<identifier>"
    $P2102."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "214_1299450589.65" 
    $P2104."add_method"(type_obj, "term:sym<name>", $P2105)
    get_how $P2106, type_obj
    get_global $P2107, "!PREFIX__term:sym<name>"
    $P2106."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "216_1299450589.65" 
    $P2108."add_method"(type_obj, "term:sym<pir::op>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__term:sym<pir::op>"
    $P2110."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "218_1299450589.65" 
    $P2112."add_method"(type_obj, "term:sym<onlystar>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__term:sym<onlystar>"
    $P2114."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "221_1299450589.65" 
    $P2116."add_method"(type_obj, "args", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__args"
    $P2118."add_method"(type_obj, "!PREFIX__args", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "223_1299450589.65" 
    $P2120."add_method"(type_obj, "arglist", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__arglist"
    $P2122."add_method"(type_obj, "!PREFIX__arglist", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "225_1299450589.65" 
    $P2124."add_method"(type_obj, "term:sym<value>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__term:sym<value>"
    $P2126."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "227_1299450589.65" 
    $P2128."add_method"(type_obj, "value", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__value"
    $P2130."add_method"(type_obj, "!PREFIX__value", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "229_1299450589.65" 
    $P2132."add_method"(type_obj, "number", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__number"
    $P2134."add_method"(type_obj, "!PREFIX__number", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "231_1299450589.65" 
    $P2136."add_method"(type_obj, "quote", $P2137)
    get_how $P2138, type_obj
    .const 'Sub' $P2139 = "232_1299450589.65" 
    $P2138."add_method"(type_obj, "!PREFIX__quote", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "233_1299450589.65" 
    $P2140."add_method"(type_obj, "quote:sym<apos>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__quote:sym<apos>"
    $P2142."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "235_1299450589.65" 
    $P2144."add_method"(type_obj, "quote:sym<dblq>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__quote:sym<dblq>"
    $P2146."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "237_1299450589.65" 
    $P2148."add_method"(type_obj, "quote:sym<q>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__quote:sym<q>"
    $P2150."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "239_1299450589.65" 
    $P2152."add_method"(type_obj, "quote:sym<qq>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__quote:sym<qq>"
    $P2154."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "241_1299450589.65" 
    $P2156."add_method"(type_obj, "quote:sym<Q>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__quote:sym<Q>"
    $P2158."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "243_1299450589.65" 
    $P2160."add_method"(type_obj, "quote:sym<Q:PIR>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, "!PREFIX__quote:sym<Q:PIR>"
    $P2162."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "245_1299450589.65" 
    $P2164."add_method"(type_obj, "quote:sym</ />", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__quote:sym</ />"
    $P2166."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "247_1299450589.65" 
    $P2168."add_method"(type_obj, "quote_escape:sym<$>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__quote_escape:sym<$>"
    $P2170."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "249_1299450589.65" 
    $P2172."add_method"(type_obj, "quote_escape:sym<{ }>", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__quote_escape:sym<{ }>"
    $P2174."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "251_1299450589.65" 
    $P2176."add_method"(type_obj, "quote_escape:sym<esc>", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__quote_escape:sym<esc>"
    $P2178."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "253_1299450589.65" 
    $P2180."add_method"(type_obj, "circumfix:sym<( )>", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__circumfix:sym<( )>"
    $P2182."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "255_1299450589.65" 
    $P2184."add_method"(type_obj, "circumfix:sym<[ ]>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__circumfix:sym<[ ]>"
    $P2186."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "257_1299450589.65" 
    $P2188."add_method"(type_obj, "circumfix:sym<ang>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__circumfix:sym<ang>"
    $P2190."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "259_1299450589.65" 
    $P2192."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2194."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "261_1299450589.65" 
    $P2196."add_method"(type_obj, "circumfix:sym<{ }>", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__circumfix:sym<{ }>"
    $P2198."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "263_1299450589.65" 
    $P2200."add_method"(type_obj, "circumfix:sym<sigil>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__circumfix:sym<sigil>"
    $P2202."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "265_1299450589.65" 
    $P2204."add_method"(type_obj, "semilist", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__semilist"
    $P2206."add_method"(type_obj, "!PREFIX__semilist", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "268_1299450589.65" 
    $P2208."add_method"(type_obj, "infixish", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__infixish"
    $P2210."add_method"(type_obj, "!PREFIX__infixish", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "270_1299450589.65" 
    $P2212."add_method"(type_obj, "infixstopper", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__infixstopper"
    $P2214."add_method"(type_obj, "!PREFIX__infixstopper", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "272_1299450589.65" 
    $P2216."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2218."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "274_1299450589.65" 
    $P2220."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__postcircumfix:sym<{ }>"
    $P2222."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "276_1299450589.65" 
    $P2224."add_method"(type_obj, "postcircumfix:sym<ang>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__postcircumfix:sym<ang>"
    $P2226."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "278_1299450589.65" 
    $P2228."add_method"(type_obj, "postcircumfix:sym<( )>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__postcircumfix:sym<( )>"
    $P2230."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "280_1299450589.65" 
    $P2232."add_method"(type_obj, "postfix:sym<.>", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__postfix:sym<.>"
    $P2234."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "282_1299450589.65" 
    $P2236."add_method"(type_obj, "prefix:sym<++>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__prefix:sym<++>"
    $P2238."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "284_1299450589.65" 
    $P2240."add_method"(type_obj, "prefix:sym<-->", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__prefix:sym<-->"
    $P2242."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "286_1299450589.65" 
    $P2244."add_method"(type_obj, "postfix:sym<++>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__postfix:sym<++>"
    $P2246."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "288_1299450589.65" 
    $P2248."add_method"(type_obj, "postfix:sym<-->", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__postfix:sym<-->"
    $P2250."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "290_1299450589.65" 
    $P2252."add_method"(type_obj, "infix:sym<**>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__infix:sym<**>"
    $P2254."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "292_1299450589.65" 
    $P2256."add_method"(type_obj, "prefix:sym<+>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__prefix:sym<+>"
    $P2258."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "294_1299450589.65" 
    $P2260."add_method"(type_obj, "prefix:sym<~>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__prefix:sym<~>"
    $P2262."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "296_1299450589.65" 
    $P2264."add_method"(type_obj, "prefix:sym<->", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__prefix:sym<->"
    $P2266."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "298_1299450589.65" 
    $P2268."add_method"(type_obj, "prefix:sym<?>", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__prefix:sym<?>"
    $P2270."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "300_1299450589.65" 
    $P2272."add_method"(type_obj, "prefix:sym<!>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__prefix:sym<!>"
    $P2274."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "302_1299450589.65" 
    $P2276."add_method"(type_obj, "prefix:sym<|>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__prefix:sym<|>"
    $P2278."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "304_1299450589.65" 
    $P2280."add_method"(type_obj, "infix:sym<*>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<*>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "306_1299450589.65" 
    $P2284."add_method"(type_obj, "infix:sym</>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym</>"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "308_1299450589.65" 
    $P2288."add_method"(type_obj, "infix:sym<%>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<%>"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "310_1299450589.65" 
    $P2292."add_method"(type_obj, "infix:sym<+&>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<+&>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "312_1299450589.65" 
    $P2296."add_method"(type_obj, "infix:sym<+>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<+>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "314_1299450589.65" 
    $P2300."add_method"(type_obj, "infix:sym<->", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<->"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "316_1299450589.65" 
    $P2304."add_method"(type_obj, "infix:sym<+|>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<+|>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "318_1299450589.65" 
    $P2308."add_method"(type_obj, "infix:sym<+^>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<+^>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "320_1299450589.65" 
    $P2312."add_method"(type_obj, "infix:sym<~>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<~>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "322_1299450589.65" 
    $P2316."add_method"(type_obj, "infix:sym<==>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<==>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "324_1299450589.65" 
    $P2320."add_method"(type_obj, "infix:sym<!=>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<!=>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "326_1299450589.65" 
    $P2324."add_method"(type_obj, "infix:sym<<=>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<<=>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "328_1299450589.65" 
    $P2328."add_method"(type_obj, "infix:sym<>=>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<>=>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "330_1299450589.65" 
    $P2332."add_method"(type_obj, "infix:sym<<>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<<>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "332_1299450589.65" 
    $P2336."add_method"(type_obj, "infix:sym<>>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<>>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "334_1299450589.65" 
    $P2340."add_method"(type_obj, "infix:sym<eq>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<eq>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "336_1299450589.65" 
    $P2344."add_method"(type_obj, "infix:sym<ne>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<ne>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "338_1299450589.65" 
    $P2348."add_method"(type_obj, "infix:sym<le>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<le>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "340_1299450589.65" 
    $P2352."add_method"(type_obj, "infix:sym<ge>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<ge>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "342_1299450589.65" 
    $P2356."add_method"(type_obj, "infix:sym<lt>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<lt>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "344_1299450589.65" 
    $P2360."add_method"(type_obj, "infix:sym<gt>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<gt>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "346_1299450589.65" 
    $P2364."add_method"(type_obj, "infix:sym<=:=>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<=:=>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "348_1299450589.65" 
    $P2368."add_method"(type_obj, "infix:sym<~~>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<~~>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "350_1299450589.65" 
    $P2372."add_method"(type_obj, "infix:sym<&&>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__infix:sym<&&>"
    $P2374."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "352_1299450589.65" 
    $P2376."add_method"(type_obj, "infix:sym<||>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__infix:sym<||>"
    $P2378."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "354_1299450589.65" 
    $P2380."add_method"(type_obj, "infix:sym<//>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__infix:sym<//>"
    $P2382."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "356_1299450589.65" 
    $P2384."add_method"(type_obj, "infix:sym<?? !!>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__infix:sym<?? !!>"
    $P2386."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "358_1299450589.65" 
    $P2388."add_method"(type_obj, "infix:sym<=>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__infix:sym<=>"
    $P2390."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "360_1299450589.65" 
    $P2392."add_method"(type_obj, "infix:sym<:=>", $P2393)
    get_how $P2394, type_obj
    get_global $P2395, "!PREFIX__infix:sym<:=>"
    $P2394."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2395)
    get_how $P2396, type_obj
    .const 'Sub' $P2397 = "362_1299450589.65" 
    $P2396."add_method"(type_obj, "infix:sym<::=>", $P2397)
    get_how $P2398, type_obj
    get_global $P2399, "!PREFIX__infix:sym<::=>"
    $P2398."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2399)
    get_how $P2400, type_obj
    .const 'Sub' $P2401 = "364_1299450589.65" 
    $P2400."add_method"(type_obj, "infix:sym<,>", $P2401)
    get_how $P2402, type_obj
    get_global $P2403, "!PREFIX__infix:sym<,>"
    $P2402."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2403)
    get_how $P2404, type_obj
    .const 'Sub' $P2405 = "366_1299450589.65" 
    $P2404."add_method"(type_obj, "prefix:sym<return>", $P2405)
    get_how $P2406, type_obj
    get_global $P2407, "!PREFIX__prefix:sym<return>"
    $P2406."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2407)
    get_how $P2408, type_obj
    .const 'Sub' $P2409 = "369_1299450589.65" 
    $P2408."add_method"(type_obj, "prefix:sym<make>", $P2409)
    get_how $P2410, type_obj
    get_global $P2411, "!PREFIX__prefix:sym<make>"
    $P2410."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2411)
    get_how $P2412, type_obj
    .const 'Sub' $P2413 = "371_1299450589.65" 
    $P2412."add_method"(type_obj, "term:sym<last>", $P2413)
    get_how $P2414, type_obj
    get_global $P2415, "!PREFIX__term:sym<last>"
    $P2414."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2415)
    get_how $P2416, type_obj
    .const 'Sub' $P2417 = "373_1299450589.65" 
    $P2416."add_method"(type_obj, "term:sym<next>", $P2417)
    get_how $P2418, type_obj
    get_global $P2419, "!PREFIX__term:sym<next>"
    $P2418."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2419)
    get_how $P2420, type_obj
    .const 'Sub' $P2421 = "375_1299450589.65" 
    $P2420."add_method"(type_obj, "term:sym<redo>", $P2421)
    get_how $P2422, type_obj
    get_global $P2423, "!PREFIX__term:sym<redo>"
    $P2422."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2423)
    get_how $P2424, type_obj
    .const 'Sub' $P2425 = "377_1299450589.65" 
    $P2424."add_method"(type_obj, "smartmatch", $P2425)
    get_how $P2426, type_obj
    get_hll_global $P2427, ["HLL"], "Grammar"
    $P2426."add_parent"(type_obj, $P2427)
    get_how $P2428, type_obj
    $P2429 = $P2428."compose"(type_obj)
    .return ($P2429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("12_1299450589.65") :outer("11_1299450589.65")
    .param pmc param_19
.annotate 'line', 4
    .lex "self", param_19
.annotate 'line', 5
    $P20 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P20
.annotate 'line', 12
    $P21 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P21
.annotate 'line', 21
    new $P22, "Undef"
    .lex "$*DEFAULT-METAATTR", $P22
.annotate 'line', 22
    $P23 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P23
.annotate 'line', 25
    new $P24, "Undef"
    .lex "$*SCOPE", $P24
.annotate 'line', 26
    new $P25, "Undef"
    .lex "$*MULTINESS", $P25
.annotate 'line', 27
    new $P26, "Undef"
    .lex "$*INVOCANT_OK", $P26
.annotate 'line', 28
    new $P27, "Undef"
    .lex "$*RETURN_USED", $P27
.annotate 'line', 29
    new $P28, "Undef"
    .lex "$*PACKAGE-SETUP", $P28
.annotate 'line', 4
    find_lex $P29, "%*LANG"
    unless_null $P29, vivify_404
    get_hll_global $P29, "%LANG"
    unless_null $P29, vivify_405
    die "Contextual %*LANG not found"
  vivify_405:
  vivify_404:
.annotate 'line', 6
    get_hll_global $P30, ["NQP"], "Regex"
    find_lex $P31, "%*LANG"
    unless_null $P31, vivify_406
    get_hll_global $P31, "%LANG"
    unless_null $P31, vivify_407
    die "Contextual %*LANG not found"
  vivify_407:
    store_lex "%*LANG", $P31
  vivify_406:
    set $P31["Regex"], $P30
.annotate 'line', 7
    get_hll_global $P32, ["NQP"], "RegexActions"
    find_lex $P33, "%*LANG"
    unless_null $P33, vivify_408
    get_hll_global $P33, "%LANG"
    unless_null $P33, vivify_409
    die "Contextual %*LANG not found"
  vivify_409:
    store_lex "%*LANG", $P33
  vivify_408:
    set $P33["Regex-actions"], $P32
.annotate 'line', 8
    get_hll_global $P34, ["NQP"], "Grammar"
    find_lex $P35, "%*LANG"
    unless_null $P35, vivify_410
    get_hll_global $P35, "%LANG"
    unless_null $P35, vivify_411
    die "Contextual %*LANG not found"
  vivify_411:
    store_lex "%*LANG", $P35
  vivify_410:
    set $P35["MAIN"], $P34
.annotate 'line', 9
    get_hll_global $P36, ["NQP"], "Actions"
    find_lex $P37, "%*LANG"
    unless_null $P37, vivify_412
    get_hll_global $P37, "%LANG"
    unless_null $P37, vivify_413
    die "Contextual %*LANG not found"
  vivify_413:
    store_lex "%*LANG", $P37
  vivify_412:
    set $P37["MAIN-actions"], $P36
    find_lex $P38, "%*HOW"
    unless_null $P38, vivify_414
    get_hll_global $P38, "%HOW"
    unless_null $P38, vivify_415
    die "Contextual %*HOW not found"
  vivify_415:
  vivify_414:
.annotate 'line', 13
    get_hll_global $P39, "KnowHOW"
    find_lex $P40, "%*HOW"
    unless_null $P40, vivify_416
    get_hll_global $P40, "%HOW"
    unless_null $P40, vivify_417
    die "Contextual %*HOW not found"
  vivify_417:
    store_lex "%*HOW", $P40
  vivify_416:
    set $P40["knowhow"], $P39
.annotate 'line', 14
    get_hll_global $P41, "NQPModuleHOW"
    find_lex $P42, "%*HOW"
    unless_null $P42, vivify_418
    get_hll_global $P42, "%HOW"
    unless_null $P42, vivify_419
    die "Contextual %*HOW not found"
  vivify_419:
    store_lex "%*HOW", $P42
  vivify_418:
    set $P42["module"], $P41
.annotate 'line', 15
    get_hll_global $P43, "NQPClassHOW"
    find_lex $P44, "%*HOW"
    unless_null $P44, vivify_420
    get_hll_global $P44, "%HOW"
    unless_null $P44, vivify_421
    die "Contextual %*HOW not found"
  vivify_421:
    store_lex "%*HOW", $P44
  vivify_420:
    set $P44["class"], $P43
.annotate 'line', 16
    get_hll_global $P45, "NQPClassHOW"
    find_lex $P46, "%*HOW"
    unless_null $P46, vivify_422
    get_hll_global $P46, "%HOW"
    unless_null $P46, vivify_423
    die "Contextual %*HOW not found"
  vivify_423:
    store_lex "%*HOW", $P46
  vivify_422:
    set $P46["grammar"], $P45
.annotate 'line', 17
    get_hll_global $P47, "NQPParametricRoleHOW"
    find_lex $P48, "%*HOW"
    unless_null $P48, vivify_424
    get_hll_global $P48, "%HOW"
    unless_null $P48, vivify_425
    die "Contextual %*HOW not found"
  vivify_425:
    store_lex "%*HOW", $P48
  vivify_424:
    set $P48["role"], $P47
.annotate 'line', 18
    get_hll_global $P49, "NQPNativeHOW"
    find_lex $P50, "%*HOW"
    unless_null $P50, vivify_426
    get_hll_global $P50, "%HOW"
    unless_null $P50, vivify_427
    die "Contextual %*HOW not found"
  vivify_427:
    store_lex "%*HOW", $P50
  vivify_426:
    set $P50["native"], $P49
.annotate 'line', 21
    new $P51, "String"
    assign $P51, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P51
    find_lex $P52, "%*HOW-METAATTR"
    unless_null $P52, vivify_428
    get_hll_global $P52, "%HOW-METAATTR"
    unless_null $P52, vivify_429
    die "Contextual %*HOW-METAATTR not found"
  vivify_429:
  vivify_428:
.annotate 'line', 23
    new $P53, "String"
    assign $P53, "KnowHOWAttribute"
    find_lex $P54, "%*HOW-METAATTR"
    unless_null $P54, vivify_430
    get_hll_global $P54, "%HOW-METAATTR"
    unless_null $P54, vivify_431
    die "Contextual %*HOW-METAATTR not found"
  vivify_431:
    store_lex "%*HOW-METAATTR", $P54
  vivify_430:
    set $P54["knowhow"], $P53
.annotate 'line', 25
    new $P55, "String"
    assign $P55, ""
    store_lex "$*SCOPE", $P55
.annotate 'line', 26
    new $P56, "String"
    assign $P56, ""
    store_lex "$*MULTINESS", $P56
.annotate 'line', 27
    new $P57, "Integer"
    assign $P57, 0
    store_lex "$*INVOCANT_OK", $P57
.annotate 'line', 28
    new $P58, "Integer"
    assign $P58, 0
    store_lex "$*RETURN_USED", $P58
    find_lex $P59, "$*PACKAGE-SETUP"
    unless_null $P59, vivify_432
    get_hll_global $P59, "$PACKAGE-SETUP"
    unless_null $P59, vivify_433
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_433:
  vivify_432:
.annotate 'line', 30
    find_lex $P60, "self"
    $P61 = $P60."comp_unit"()
.annotate 'line', 4
    .return ($P61)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("13_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx63_tgt
    .local int rx63_pos
    .local int rx63_off
    .local int rx63_eos
    .local int rx63_rep
    .local pmc rx63_cur
    .local pmc rx63_debug
    (rx63_cur, rx63_pos, rx63_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx63_cur
    .local pmc match
    .lex "$/", match
    length rx63_eos, rx63_tgt
    gt rx63_pos, rx63_eos, rx63_done
    set rx63_off, 0
    lt rx63_pos, 2, rx63_start
    sub rx63_off, rx63_pos, 1
    substr rx63_tgt, rx63_tgt, rx63_off
  rx63_start:
    eq $I10, 1, rx63_restart
    if_null rx63_debug, debug_434
    rx63_cur."!cursor_debug"("START", "identifier")
  debug_434:
    $I10 = self.'from'()
    ne $I10, -1, rxscan67_done
    goto rxscan67_scan
  rxscan67_loop:
    (rx63_pos) = rx63_cur."from"()
    inc rx63_pos
    rx63_cur."!cursor_from"(rx63_pos)
    ge rx63_pos, rx63_eos, rxscan67_done
  rxscan67_scan:
    set_addr $I10, rxscan67_loop
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxscan67_done:
.annotate 'line', 35
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
  # rx rxquantr68 ** 0..*
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(0, rx63_pos, $I10)
  rxquantr68_loop:
  # rx enumcharlist negate=0 
    ge rx63_pos, rx63_eos, rx63_fail
    sub $I10, rx63_pos, rx63_off
    substr $S10, rx63_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx63_fail
    inc rx63_pos
  # rx subrule "ident" subtype=method negate=
    rx63_cur."!cursor_pos"(rx63_pos)
    $P10 = rx63_cur."ident"()
    unless $P10, rx63_fail
    rx63_pos = $P10."pos"()
    set_addr $I10, rxquantr68_done
    (rx63_rep) = rx63_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr68_done
    rx63_cur."!mark_push"(rx63_rep, rx63_pos, $I10)
    goto rxquantr68_loop
  rxquantr68_done:
  # rx pass
    rx63_cur."!cursor_pass"(rx63_pos, "identifier")
    if_null rx63_debug, debug_435
    rx63_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx63_pos)
  debug_435:
    .return (rx63_cur)
  rx63_restart:
.annotate 'line', 4
    if_null rx63_debug, debug_436
    rx63_cur."!cursor_debug"("NEXT", "identifier")
  debug_436:
  rx63_fail:
    (rx63_rep, rx63_pos, $I10, $P10) = rx63_cur."!mark_fail"(0)
    lt rx63_pos, -1, rx63_done
    eq rx63_pos, -1, rx63_fail
    jump $I10
  rx63_done:
    rx63_cur."!cursor_fail"()
    if_null rx63_debug, debug_437
    rx63_cur."!cursor_debug"("FAIL", "identifier")
  debug_437:
    .return (rx63_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("14_1299450589.65") :method
.annotate 'line', 4
    $P65 = self."!PREFIX__!subrule"("ident", "")
    new $P66, "ResizablePMCArray"
    push $P66, $P65
    .return ($P66)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("15_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx70_tgt
    .local int rx70_pos
    .local int rx70_off
    .local int rx70_eos
    .local int rx70_rep
    .local pmc rx70_cur
    .local pmc rx70_debug
    (rx70_cur, rx70_pos, rx70_tgt, $I10) = self."!cursor_start"()
    rx70_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx70_cur
    .local pmc match
    .lex "$/", match
    length rx70_eos, rx70_tgt
    gt rx70_pos, rx70_eos, rx70_done
    set rx70_off, 0
    lt rx70_pos, 2, rx70_start
    sub rx70_off, rx70_pos, 1
    substr rx70_tgt, rx70_tgt, rx70_off
  rx70_start:
    eq $I10, 1, rx70_restart
    if_null rx70_debug, debug_438
    rx70_cur."!cursor_debug"("START", "name")
  debug_438:
    $I10 = self.'from'()
    ne $I10, -1, rxscan73_done
    goto rxscan73_scan
  rxscan73_loop:
    (rx70_pos) = rx70_cur."from"()
    inc rx70_pos
    rx70_cur."!cursor_from"(rx70_pos)
    ge rx70_pos, rx70_eos, rxscan73_done
  rxscan73_scan:
    set_addr $I10, rxscan73_loop
    rx70_cur."!mark_push"(0, rx70_pos, $I10)
  rxscan73_done:
.annotate 'line', 37
  # rx rxquantr74 ** 1..*
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(0, -1, $I10)
  rxquantr74_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx70_cur."!cursor_pos"(rx70_pos)
    $P10 = rx70_cur."identifier"()
    unless $P10, rx70_fail
    goto rxsubrule75_pass
  rxsubrule75_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx70_fail
  rxsubrule75_pass:
    set_addr $I10, rxsubrule75_back
    rx70_cur."!mark_push"(0, rx70_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx70_pos = $P10."pos"()
    set_addr $I10, rxquantr74_done
    (rx70_rep) = rx70_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr74_done
    rx70_cur."!mark_push"(rx70_rep, rx70_pos, $I10)
  # rx literal  "::"
    add $I11, rx70_pos, 2
    gt $I11, rx70_eos, rx70_fail
    sub $I11, rx70_pos, rx70_off
    substr $S10, rx70_tgt, $I11, 2
    ne $S10, "::", rx70_fail
    add rx70_pos, 2
    goto rxquantr74_loop
  rxquantr74_done:
  # rx pass
    rx70_cur."!cursor_pass"(rx70_pos, "name")
    if_null rx70_debug, debug_439
    rx70_cur."!cursor_debug"("PASS", "name", " at pos=", rx70_pos)
  debug_439:
    .return (rx70_cur)
  rx70_restart:
.annotate 'line', 4
    if_null rx70_debug, debug_440
    rx70_cur."!cursor_debug"("NEXT", "name")
  debug_440:
  rx70_fail:
    (rx70_rep, rx70_pos, $I10, $P10) = rx70_cur."!mark_fail"(0)
    lt rx70_pos, -1, rx70_done
    eq rx70_pos, -1, rx70_fail
    jump $I10
  rx70_done:
    rx70_cur."!cursor_fail"()
    if_null rx70_debug, debug_441
    rx70_cur."!cursor_debug"("FAIL", "name")
  debug_441:
    .return (rx70_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("16_1299450589.65") :method
.annotate 'line', 4
    new $P72, "ResizablePMCArray"
    push $P72, ""
    .return ($P72)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("17_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx77_tgt
    .local int rx77_pos
    .local int rx77_off
    .local int rx77_eos
    .local int rx77_rep
    .local pmc rx77_cur
    .local pmc rx77_debug
    (rx77_cur, rx77_pos, rx77_tgt, $I10) = self."!cursor_start"()
    rx77_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx77_cur
    .local pmc match
    .lex "$/", match
    length rx77_eos, rx77_tgt
    gt rx77_pos, rx77_eos, rx77_done
    set rx77_off, 0
    lt rx77_pos, 2, rx77_start
    sub rx77_off, rx77_pos, 1
    substr rx77_tgt, rx77_tgt, rx77_off
  rx77_start:
    eq $I10, 1, rx77_restart
    if_null rx77_debug, debug_442
    rx77_cur."!cursor_debug"("START", "deflongname")
  debug_442:
    $I10 = self.'from'()
    ne $I10, -1, rxscan81_done
    goto rxscan81_scan
  rxscan81_loop:
    (rx77_pos) = rx77_cur."from"()
    inc rx77_pos
    rx77_cur."!cursor_from"(rx77_pos)
    ge rx77_pos, rx77_eos, rxscan81_done
  rxscan81_scan:
    set_addr $I10, rxscan81_loop
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxscan81_done:
.annotate 'line', 40
  # rx subrule "identifier" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."identifier"()
    unless $P10, rx77_fail
    rx77_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx77_pos = $P10."pos"()
  # rx rxquantr82 ** 0..1
    set_addr $I10, rxquantr82_done
    rx77_cur."!mark_push"(0, rx77_pos, $I10)
  rxquantr82_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx77_cur."!cursor_pos"(rx77_pos)
    $P10 = rx77_cur."colonpair"()
    unless $P10, rx77_fail
    goto rxsubrule83_pass
  rxsubrule83_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx77_fail
  rxsubrule83_pass:
    set_addr $I10, rxsubrule83_back
    rx77_cur."!mark_push"(0, rx77_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx77_pos = $P10."pos"()
    set_addr $I10, rxquantr82_done
    (rx77_rep) = rx77_cur."!mark_commit"($I10)
  rxquantr82_done:
.annotate 'line', 39
  # rx pass
    rx77_cur."!cursor_pass"(rx77_pos, "deflongname")
    if_null rx77_debug, debug_443
    rx77_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx77_pos)
  debug_443:
    .return (rx77_cur)
  rx77_restart:
.annotate 'line', 4
    if_null rx77_debug, debug_444
    rx77_cur."!cursor_debug"("NEXT", "deflongname")
  debug_444:
  rx77_fail:
    (rx77_rep, rx77_pos, $I10, $P10) = rx77_cur."!mark_fail"(0)
    lt rx77_pos, -1, rx77_done
    eq rx77_pos, -1, rx77_fail
    jump $I10
  rx77_done:
    rx77_cur."!cursor_fail"()
    if_null rx77_debug, debug_445
    rx77_cur."!cursor_debug"("FAIL", "deflongname")
  debug_445:
    .return (rx77_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("18_1299450589.65") :method
.annotate 'line', 4
    $P79 = self."!PREFIX__!subrule"("identifier", "")
    new $P80, "ResizablePMCArray"
    push $P80, $P79
    .return ($P80)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("19_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx85_tgt
    .local int rx85_pos
    .local int rx85_off
    .local int rx85_eos
    .local int rx85_rep
    .local pmc rx85_cur
    .local pmc rx85_debug
    (rx85_cur, rx85_pos, rx85_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx85_cur
    .local pmc match
    .lex "$/", match
    length rx85_eos, rx85_tgt
    gt rx85_pos, rx85_eos, rx85_done
    set rx85_off, 0
    lt rx85_pos, 2, rx85_start
    sub rx85_off, rx85_pos, 1
    substr rx85_tgt, rx85_tgt, rx85_off
  rx85_start:
    eq $I10, 1, rx85_restart
    if_null rx85_debug, debug_446
    rx85_cur."!cursor_debug"("START", "ENDSTMT")
  debug_446:
    $I10 = self.'from'()
    ne $I10, -1, rxscan88_done
    goto rxscan88_scan
  rxscan88_loop:
    (rx85_pos) = rx85_cur."from"()
    inc rx85_pos
    rx85_cur."!cursor_from"(rx85_pos)
    ge rx85_pos, rx85_eos, rxscan88_done
  rxscan88_scan:
    set_addr $I10, rxscan88_loop
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxscan88_done:
.annotate 'line', 47
  # rx rxquantr89 ** 0..1
    set_addr $I10, rxquantr89_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr89_loop:
  alt90_0:
.annotate 'line', 44
    set_addr $I10, alt90_1
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
.annotate 'line', 45
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx85_pos, rx85_off
    set rx85_rep, 0
    sub $I12, rx85_eos, rx85_pos
  rxenumcharlistq91_loop:
    le $I12, 0, rxenumcharlistq91_done
    substr $S10, rx85_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq91_done
    inc rx85_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq91_loop
  rxenumcharlistq91_done:
    add rx85_pos, rx85_pos, rx85_rep
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor92_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor92_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor92_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
    goto alt90_end
  alt90_1:
.annotate 'line', 46
  # rx rxquantr93 ** 0..1
    set_addr $I10, rxquantr93_done
    rx85_cur."!mark_push"(0, rx85_pos, $I10)
  rxquantr93_loop:
  # rx subrule "unv" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."unv"()
    unless $P10, rx85_fail
    goto rxsubrule94_pass
  rxsubrule94_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx85_fail
  rxsubrule94_pass:
    set_addr $I10, rxsubrule94_back
    rx85_cur."!mark_push"(0, rx85_pos, $I10, $P10)
    rx85_pos = $P10."pos"()
    set_addr $I10, rxquantr93_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr93_done:
  # rxanchor eol
    sub $I10, rx85_pos, rx85_off
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rxanchor95_done
    ne rx85_pos, rx85_eos, rx85_fail
    eq rx85_pos, 0, rxanchor95_done
    dec $I10
    is_cclass $I11, 4096, rx85_tgt, $I10
    if $I11, rx85_fail
  rxanchor95_done:
  # rx subrule "ws" subtype=method negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."ws"()
    unless $P10, rx85_fail
    rx85_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx85_cur."!cursor_pos"(rx85_pos)
    $P10 = rx85_cur."MARKER"("endstmt")
    unless $P10, rx85_fail
  alt90_end:
.annotate 'line', 47
    set_addr $I10, rxquantr89_done
    (rx85_rep) = rx85_cur."!mark_commit"($I10)
  rxquantr89_done:
.annotate 'line', 43
  # rx pass
    rx85_cur."!cursor_pass"(rx85_pos, "ENDSTMT")
    if_null rx85_debug, debug_447
    rx85_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx85_pos)
  debug_447:
    .return (rx85_cur)
  rx85_restart:
.annotate 'line', 4
    if_null rx85_debug, debug_448
    rx85_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_448:
  rx85_fail:
    (rx85_rep, rx85_pos, $I10, $P10) = rx85_cur."!mark_fail"(0)
    lt rx85_pos, -1, rx85_done
    eq rx85_pos, -1, rx85_fail
    jump $I10
  rx85_done:
    rx85_cur."!cursor_fail"()
    if_null rx85_debug, debug_449
    rx85_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_449:
    .return (rx85_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("20_1299450589.65") :method
.annotate 'line', 4
    new $P87, "ResizablePMCArray"
    push $P87, ""
    .return ($P87)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("21_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx97_tgt
    .local int rx97_pos
    .local int rx97_off
    .local int rx97_eos
    .local int rx97_rep
    .local pmc rx97_cur
    .local pmc rx97_debug
    (rx97_cur, rx97_pos, rx97_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx97_cur
    .local pmc match
    .lex "$/", match
    length rx97_eos, rx97_tgt
    gt rx97_pos, rx97_eos, rx97_done
    set rx97_off, 0
    lt rx97_pos, 2, rx97_start
    sub rx97_off, rx97_pos, 1
    substr rx97_tgt, rx97_tgt, rx97_off
  rx97_start:
    eq $I10, 1, rx97_restart
    if_null rx97_debug, debug_450
    rx97_cur."!cursor_debug"("START", "ws")
  debug_450:
    $I10 = self.'from'()
    ne $I10, -1, rxscan100_done
    goto rxscan100_scan
  rxscan100_loop:
    (rx97_pos) = rx97_cur."from"()
    inc rx97_pos
    rx97_cur."!cursor_from"(rx97_pos)
    ge rx97_pos, rx97_eos, rxscan100_done
  rxscan100_scan:
    set_addr $I10, rxscan100_loop
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxscan100_done:
  alt101_0:
.annotate 'line', 50
    set_addr $I10, alt101_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 51
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKED"("ws")
    unless $P10, rx97_fail
    goto alt101_end
  alt101_1:
.annotate 'line', 52
  # rx subrule "ww" subtype=zerowidth negate=1
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."ww"()
    if $P10, rx97_fail
.annotate 'line', 57
  # rx rxquantr102 ** 0..*
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  rxquantr102_loop:
  alt103_0:
.annotate 'line', 53
    set_addr $I10, alt103_1
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq104_loop:
    le $I12, 0, rxenumcharlistq104_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq104_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq104_loop
  rxenumcharlistq104_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
    goto alt103_end
  alt103_1:
    set_addr $I10, alt103_2
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 54
  # rx literal  "#"
    add $I11, rx97_pos, 1
    gt $I11, rx97_eos, rx97_fail
    sub $I11, rx97_pos, rx97_off
    ord $I11, rx97_tgt, $I11
    ne $I11, 35, rx97_fail
    add rx97_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx97_pos, rx97_off
    find_cclass $I11, 4096, rx97_tgt, $I10, rx97_eos
    add rx97_pos, rx97_off, $I11
    goto alt103_end
  alt103_2:
    set_addr $I10, alt103_3
    rx97_cur."!mark_push"(0, rx97_pos, $I10)
.annotate 'line', 55
  # rxanchor bol
    eq rx97_pos, 0, rxanchor105_done
    ge rx97_pos, rx97_eos, rx97_fail
    sub $I10, rx97_pos, rx97_off
    dec $I10
    is_cclass $I11, 4096, rx97_tgt, $I10
    unless $I11, rx97_fail
  rxanchor105_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."pod_comment"()
    unless $P10, rx97_fail
    rx97_pos = $P10."pos"()
    goto alt103_end
  alt103_3:
.annotate 'line', 56
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx97_pos, rx97_off
    set rx97_rep, 0
    sub $I12, rx97_eos, rx97_pos
  rxenumcharlistq106_loop:
    le $I12, 0, rxenumcharlistq106_done
    substr $S10, rx97_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq106_done
    inc rx97_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq106_loop
  rxenumcharlistq106_done:
    lt rx97_rep, 1, rx97_fail
    add rx97_pos, rx97_pos, rx97_rep
  alt103_end:
.annotate 'line', 57
    set_addr $I10, rxquantr102_done
    (rx97_rep) = rx97_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr102_done
    rx97_cur."!mark_push"(rx97_rep, rx97_pos, $I10)
    goto rxquantr102_loop
  rxquantr102_done:
.annotate 'line', 58
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx97_cur."!cursor_pos"(rx97_pos)
    $P10 = rx97_cur."MARKER"("ws")
    unless $P10, rx97_fail
  alt101_end:
.annotate 'line', 50
  # rx pass
    rx97_cur."!cursor_pass"(rx97_pos, "ws")
    if_null rx97_debug, debug_451
    rx97_cur."!cursor_debug"("PASS", "ws", " at pos=", rx97_pos)
  debug_451:
    .return (rx97_cur)
  rx97_restart:
.annotate 'line', 4
    if_null rx97_debug, debug_452
    rx97_cur."!cursor_debug"("NEXT", "ws")
  debug_452:
  rx97_fail:
    (rx97_rep, rx97_pos, $I10, $P10) = rx97_cur."!mark_fail"(0)
    lt rx97_pos, -1, rx97_done
    eq rx97_pos, -1, rx97_fail
    jump $I10
  rx97_done:
    rx97_cur."!cursor_fail"()
    if_null rx97_debug, debug_453
    rx97_cur."!cursor_debug"("FAIL", "ws")
  debug_453:
    .return (rx97_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("22_1299450589.65") :method
.annotate 'line', 4
    new $P99, "ResizablePMCArray"
    push $P99, ""
    push $P99, ""
    .return ($P99)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("23_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P115 = "25_1299450589.65" 
    capture_lex $P115
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_454
    rx108_cur."!cursor_debug"("START", "unv")
  debug_454:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
  alt112_0:
.annotate 'line', 63
    set_addr $I10, alt112_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 64
  # rxanchor bol
    eq rx108_pos, 0, rxanchor113_done
    ge rx108_pos, rx108_eos, rx108_fail
    sub $I10, rx108_pos, rx108_off
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    unless $I11, rx108_fail
  rxanchor113_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    .const 'Sub' $P115 = "25_1299450589.65" 
    capture_lex $P115
    $P10 = rx108_cur."before"($P115)
    unless $P10, rx108_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."pod_comment"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
    goto alt112_end
  alt112_1:
    set_addr $I10, alt112_2
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 65
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq120_loop:
    le $I12, 0, rxenumcharlistq120_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq120_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq120_loop
  rxenumcharlistq120_done:
    add rx108_pos, rx108_pos, rx108_rep
  # rx literal  "#"
    add $I11, rx108_pos, 1
    gt $I11, rx108_eos, rx108_fail
    sub $I11, rx108_pos, rx108_off
    ord $I11, rx108_tgt, $I11
    ne $I11, 35, rx108_fail
    add rx108_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx108_pos, rx108_off
    find_cclass $I11, 4096, rx108_tgt, $I10, rx108_eos
    add rx108_pos, rx108_off, $I11
    goto alt112_end
  alt112_2:
.annotate 'line', 66
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq121_loop:
    le $I12, 0, rxenumcharlistq121_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq121_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq121_loop
  rxenumcharlistq121_done:
    lt rx108_rep, 1, rx108_fail
    add rx108_pos, rx108_pos, rx108_rep
  alt112_end:
.annotate 'line', 61
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "unv")
    if_null rx108_debug, debug_459
    rx108_cur."!cursor_debug"("PASS", "unv", " at pos=", rx108_pos)
  debug_459:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 4
    if_null rx108_debug, debug_460
    rx108_cur."!cursor_debug"("NEXT", "unv")
  debug_460:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_461
    rx108_cur."!cursor_debug"("FAIL", "unv")
  debug_461:
    .return (rx108_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("24_1299450589.65") :method
.annotate 'line', 4
    new $P110, "ResizablePMCArray"
    push $P110, ""
    push $P110, ""
    push $P110, ""
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block114"  :anon :subid("25_1299450589.65") :method :outer("23_1299450589.65")
.annotate 'line', 64
    .local string rx116_tgt
    .local int rx116_pos
    .local int rx116_off
    .local int rx116_eos
    .local int rx116_rep
    .local pmc rx116_cur
    .local pmc rx116_debug
    (rx116_cur, rx116_pos, rx116_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx116_cur
    .local pmc match
    .lex "$/", match
    length rx116_eos, rx116_tgt
    gt rx116_pos, rx116_eos, rx116_done
    set rx116_off, 0
    lt rx116_pos, 2, rx116_start
    sub rx116_off, rx116_pos, 1
    substr rx116_tgt, rx116_tgt, rx116_off
  rx116_start:
    eq $I10, 1, rx116_restart
    if_null rx116_debug, debug_455
    rx116_cur."!cursor_debug"("START", "")
  debug_455:
    $I10 = self.'from'()
    ne $I10, -1, rxscan117_done
    goto rxscan117_scan
  rxscan117_loop:
    (rx116_pos) = rx116_cur."from"()
    inc rx116_pos
    rx116_cur."!cursor_from"(rx116_pos)
    ge rx116_pos, rx116_eos, rxscan117_done
  rxscan117_scan:
    set_addr $I10, rxscan117_loop
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  rxscan117_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx116_pos, rx116_off
    set rx116_rep, 0
    sub $I12, rx116_eos, rx116_pos
  rxenumcharlistq118_loop:
    le $I12, 0, rxenumcharlistq118_done
    substr $S10, rx116_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq118_done
    inc rx116_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq118_loop
  rxenumcharlistq118_done:
    add rx116_pos, rx116_pos, rx116_rep
  # rx literal  "="
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 61, rx116_fail
    add rx116_pos, 1
  alt119_0:
    set_addr $I10, alt119_1
    rx116_cur."!mark_push"(0, rx116_pos, $I10)
  # rx charclass w
    ge rx116_pos, rx116_eos, rx116_fail
    sub $I10, rx116_pos, rx116_off
    is_cclass $I11, 8192, rx116_tgt, $I10
    unless $I11, rx116_fail
    inc rx116_pos
    goto alt119_end
  alt119_1:
  # rx literal  "\\"
    add $I11, rx116_pos, 1
    gt $I11, rx116_eos, rx116_fail
    sub $I11, rx116_pos, rx116_off
    ord $I11, rx116_tgt, $I11
    ne $I11, 92, rx116_fail
    add rx116_pos, 1
  alt119_end:
  # rx pass
    rx116_cur."!cursor_pass"(rx116_pos, "")
    if_null rx116_debug, debug_456
    rx116_cur."!cursor_debug"("PASS", "", " at pos=", rx116_pos)
  debug_456:
    .return (rx116_cur)
  rx116_restart:
    if_null rx116_debug, debug_457
    rx116_cur."!cursor_debug"("NEXT", "")
  debug_457:
  rx116_fail:
    (rx116_rep, rx116_pos, $I10, $P10) = rx116_cur."!mark_fail"(0)
    lt rx116_pos, -1, rx116_done
    eq rx116_pos, -1, rx116_fail
    jump $I10
  rx116_done:
    rx116_cur."!cursor_fail"()
    if_null rx116_debug, debug_458
    rx116_cur."!cursor_debug"("FAIL", "")
  debug_458:
    .return (rx116_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("26_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P154 = "28_1299450589.65" 
    capture_lex $P154
    .local string rx123_tgt
    .local int rx123_pos
    .local int rx123_off
    .local int rx123_eos
    .local int rx123_rep
    .local pmc rx123_cur
    .local pmc rx123_debug
    (rx123_cur, rx123_pos, rx123_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx123_cur
    .local pmc match
    .lex "$/", match
    length rx123_eos, rx123_tgt
    gt rx123_pos, rx123_eos, rx123_done
    set rx123_off, 0
    lt rx123_pos, 2, rx123_start
    sub rx123_off, rx123_pos, 1
    substr rx123_tgt, rx123_tgt, rx123_off
  rx123_start:
    eq $I10, 1, rx123_restart
    if_null rx123_debug, debug_462
    rx123_cur."!cursor_debug"("START", "pod_comment")
  debug_462:
    $I10 = self.'from'()
    ne $I10, -1, rxscan126_done
    goto rxscan126_scan
  rxscan126_loop:
    (rx123_pos) = rx123_cur."from"()
    inc rx123_pos
    rx123_cur."!cursor_from"(rx123_pos)
    ge rx123_pos, rx123_eos, rxscan126_done
  rxscan126_scan:
    set_addr $I10, rxscan126_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  rxscan126_done:
.annotate 'line', 71
  # rxanchor bol
    eq rx123_pos, 0, rxanchor127_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor127_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq128_loop:
    le $I12, 0, rxenumcharlistq128_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq128_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq128_loop
  rxenumcharlistq128_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "="
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 61, rx123_fail
    add rx123_pos, 1
  alt129_0:
.annotate 'line', 72
    set_addr $I10, alt129_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 73
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq130_loop:
    le $I12, 0, rxenumcharlistq130_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq130_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq130_loop
  rxenumcharlistq130_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  alt131_0:
.annotate 'line', 74
    set_addr $I10, alt131_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx rxquantf132 ** 0..*
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf132_done
  rxquantf132_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf132_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf132_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq134_loop:
    le $I12, 0, rxenumcharlistq134_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq134_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq134_loop
  rxenumcharlistq134_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq135_loop:
    le $I12, 0, rxenumcharlistq135_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq135_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq135_loop
  rxenumcharlistq135_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "END"
    add $I11, rx123_pos, 3
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 3
    ne $S10, "END", rx123_fail
    add rx123_pos, 3
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt131_end
  alt131_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_not_cclass $I11, 65535, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt131_end:
.annotate 'line', 73
    goto alt129_end
  alt129_1:
    set_addr $I10, alt129_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 75
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq136_loop:
    le $I12, 0, rxenumcharlistq136_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq136_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq136_loop
  rxenumcharlistq136_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
  alt137_0:
.annotate 'line', 76
    set_addr $I10, alt137_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 77
  # rx rxquantf138 ** 0..*
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf138_done
  rxquantf138_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf138_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf138_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq140_loop:
    le $I12, 0, rxenumcharlistq140_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq140_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq140_loop
  rxenumcharlistq140_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    lt rx123_rep, 1, rx123_fail
    add rx123_pos, rx123_pos, rx123_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."!BACKREF"("identifier")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt137_end
  alt137_1:
.annotate 'line', 78
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt137_end:
.annotate 'line', 75
    goto alt129_end
  alt129_2:
    set_addr $I10, alt129_3
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 80
  # rx literal  "begin"
    add $I11, rx123_pos, 5
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 5
    ne $S10, "begin", rx123_fail
    add rx123_pos, 5
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx123_pos, rx123_pos, rx123_rep
  alt144_0:
.annotate 'line', 81
    set_addr $I10, alt144_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rxanchor eol
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rxanchor145_done
    ne rx123_pos, rx123_eos, rx123_fail
    eq rx123_pos, 0, rxanchor145_done
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    if $I11, rx123_fail
  rxanchor145_done:
    goto alt144_end
  alt144_1:
    set_addr $I10, alt144_2
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx literal  "#"
    add $I11, rx123_pos, 1
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    ord $I11, rx123_tgt, $I11
    ne $I11, 35, rx123_fail
    add rx123_pos, 1
    goto alt144_end
  alt144_2:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt144_end:
  alt146_0:
.annotate 'line', 82
    set_addr $I10, alt146_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 83
  # rx rxquantf147 ** 0..*
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf147_done
  rxquantf147_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf147_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf147_done:
  # rx charclass nl
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
    substr $S10, rx123_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx123_pos, $I11
    inc rx123_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx123_pos, rx123_off
    set rx123_rep, 0
    sub $I12, rx123_eos, rx123_pos
  rxenumcharlistq149_loop:
    le $I12, 0, rxenumcharlistq149_done
    substr $S10, rx123_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq149_done
    inc rx123_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq149_loop
  rxenumcharlistq149_done:
    add rx123_pos, rx123_pos, rx123_rep
  # rx literal  "=end"
    add $I11, rx123_pos, 4
    gt $I11, rx123_eos, rx123_fail
    sub $I11, rx123_pos, rx123_off
    substr $S10, rx123_tgt, $I11, 4
    ne $S10, "=end", rx123_fail
    add rx123_pos, 4
  # rxanchor rwb
    le rx123_pos, 0, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 8192, rx123_tgt, $I10
    if $I11, rx123_fail
    dec $I10
    is_cclass $I11, 8192, rx123_tgt, $I10
    unless $I11, rx123_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
    goto alt146_end
  alt146_1:
.annotate 'line', 84
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("=begin without matching =end")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt146_end:
.annotate 'line', 80
    goto alt129_end
  alt129_3:
    set_addr $I10, alt129_4
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
.annotate 'line', 86
  # rx subrule "identifier" subtype=capture negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."identifier"()
    unless $P10, rx123_fail
    rx123_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx123_pos = $P10."pos"()
.annotate 'line', 87
  # rx rxquantf150 ** 0..*
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
    goto rxquantf150_done
  rxquantf150_loop:
  # rx charclass .
    ge rx123_pos, rx123_eos, rx123_fail
    inc rx123_pos
    set_addr $I10, rxquantf150_loop
    rx123_cur."!mark_push"(rx123_rep, rx123_pos, $I10)
  rxquantf150_done:
  # rxanchor bol
    eq rx123_pos, 0, rxanchor152_done
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    dec $I10
    is_cclass $I11, 4096, rx123_tgt, $I10
    unless $I11, rx123_fail
  rxanchor152_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    .const 'Sub' $P154 = "28_1299450589.65" 
    capture_lex $P154
    $P10 = rx123_cur."before"($P154)
    unless $P10, rx123_fail
.annotate 'line', 86
    goto alt129_end
  alt129_4:
  alt160_0:
.annotate 'line', 93
    set_addr $I10, alt160_1
    rx123_cur."!mark_push"(0, rx123_pos, $I10)
  # rx charclass s
    ge rx123_pos, rx123_eos, rx123_fail
    sub $I10, rx123_pos, rx123_off
    is_cclass $I11, 32, rx123_tgt, $I10
    unless $I11, rx123_fail
    inc rx123_pos
    goto alt160_end
  alt160_1:
  # rx subrule "panic" subtype=method negate=
    rx123_cur."!cursor_pos"(rx123_pos)
    $P10 = rx123_cur."panic"("Illegal pod directive")
    unless $P10, rx123_fail
    rx123_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 94
  # rx charclass_q N r 0..-1
    sub $I10, rx123_pos, rx123_off
    find_cclass $I11, 4096, rx123_tgt, $I10, rx123_eos
    add rx123_pos, rx123_off, $I11
  alt129_end:
.annotate 'line', 70
  # rx pass
    rx123_cur."!cursor_pass"(rx123_pos, "pod_comment")
    if_null rx123_debug, debug_467
    rx123_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx123_pos)
  debug_467:
    .return (rx123_cur)
  rx123_restart:
.annotate 'line', 4
    if_null rx123_debug, debug_468
    rx123_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_468:
  rx123_fail:
    (rx123_rep, rx123_pos, $I10, $P10) = rx123_cur."!mark_fail"(0)
    lt rx123_pos, -1, rx123_done
    eq rx123_pos, -1, rx123_fail
    jump $I10
  rx123_done:
    rx123_cur."!cursor_fail"()
    if_null rx123_debug, debug_469
    rx123_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_469:
    .return (rx123_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("27_1299450589.65") :method
.annotate 'line', 4
    new $P125, "ResizablePMCArray"
    push $P125, ""
    .return ($P125)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block153"  :anon :subid("28_1299450589.65") :method :outer("26_1299450589.65")
.annotate 'line', 87
    .local string rx155_tgt
    .local int rx155_pos
    .local int rx155_off
    .local int rx155_eos
    .local int rx155_rep
    .local pmc rx155_cur
    .local pmc rx155_debug
    (rx155_cur, rx155_pos, rx155_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx155_cur
    .local pmc match
    .lex "$/", match
    length rx155_eos, rx155_tgt
    gt rx155_pos, rx155_eos, rx155_done
    set rx155_off, 0
    lt rx155_pos, 2, rx155_start
    sub rx155_off, rx155_pos, 1
    substr rx155_tgt, rx155_tgt, rx155_off
  rx155_start:
    eq $I10, 1, rx155_restart
    if_null rx155_debug, debug_463
    rx155_cur."!cursor_debug"("START", "")
  debug_463:
    $I10 = self.'from'()
    ne $I10, -1, rxscan156_done
    goto rxscan156_scan
  rxscan156_loop:
    (rx155_pos) = rx155_cur."from"()
    inc rx155_pos
    rx155_cur."!cursor_from"(rx155_pos)
    ge rx155_pos, rx155_eos, rxscan156_done
  rxscan156_scan:
    set_addr $I10, rxscan156_loop
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxscan156_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx155_pos, rx155_off
    set rx155_rep, 0
    sub $I12, rx155_eos, rx155_pos
  rxenumcharlistq157_loop:
    le $I12, 0, rxenumcharlistq157_done
    substr $S10, rx155_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq157_done
    inc rx155_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq157_loop
  rxenumcharlistq157_done:
    add rx155_pos, rx155_pos, rx155_rep
  alt158_0:
    set_addr $I10, alt158_1
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
.annotate 'line', 88
  # rx literal  "="
    add $I11, rx155_pos, 1
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    ord $I11, rx155_tgt, $I11
    ne $I11, 61, rx155_fail
    add rx155_pos, 1
.annotate 'line', 90
  # rx rxquantr159 ** 0..1
    set_addr $I10, rxquantr159_done
    rx155_cur."!mark_push"(0, rx155_pos, $I10)
  rxquantr159_loop:
.annotate 'line', 89
  # rx literal  "cut"
    add $I11, rx155_pos, 3
    gt $I11, rx155_eos, rx155_fail
    sub $I11, rx155_pos, rx155_off
    substr $S10, rx155_tgt, $I11, 3
    ne $S10, "cut", rx155_fail
    add rx155_pos, 3
  # rxanchor rwb
    le rx155_pos, 0, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 8192, rx155_tgt, $I10
    if $I11, rx155_fail
    dec $I10
    is_cclass $I11, 8192, rx155_tgt, $I10
    unless $I11, rx155_fail
.annotate 'line', 90
  # rx subrule "panic" subtype=method negate=
    rx155_cur."!cursor_pos"(rx155_pos)
    $P10 = rx155_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx155_fail
    rx155_pos = $P10."pos"()
    set_addr $I10, rxquantr159_done
    (rx155_rep) = rx155_cur."!mark_commit"($I10)
  rxquantr159_done:
.annotate 'line', 87
    goto alt158_end
  alt158_1:
.annotate 'line', 91
  # rx charclass nl
    ge rx155_pos, rx155_eos, rx155_fail
    sub $I10, rx155_pos, rx155_off
    is_cclass $I11, 4096, rx155_tgt, $I10
    unless $I11, rx155_fail
    substr $S10, rx155_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx155_pos, $I11
    inc rx155_pos
  alt158_end:
.annotate 'line', 87
  # rx pass
    rx155_cur."!cursor_pass"(rx155_pos, "")
    if_null rx155_debug, debug_464
    rx155_cur."!cursor_debug"("PASS", "", " at pos=", rx155_pos)
  debug_464:
    .return (rx155_cur)
  rx155_restart:
    if_null rx155_debug, debug_465
    rx155_cur."!cursor_debug"("NEXT", "")
  debug_465:
  rx155_fail:
    (rx155_rep, rx155_pos, $I10, $P10) = rx155_cur."!mark_fail"(0)
    lt rx155_pos, -1, rx155_done
    eq rx155_pos, -1, rx155_fail
    jump $I10
  rx155_done:
    rx155_cur."!cursor_fail"()
    if_null rx155_debug, debug_466
    rx155_cur."!cursor_debug"("FAIL", "")
  debug_466:
    .return (rx155_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("29_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 102
    new $P162, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P162
.annotate 'line', 4
    .local string rx163_tgt
    .local int rx163_pos
    .local int rx163_off
    .local int rx163_eos
    .local int rx163_rep
    .local pmc rx163_cur
    .local pmc rx163_debug
    (rx163_cur, rx163_pos, rx163_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx163_cur
    .local pmc match
    .lex "$/", match
    length rx163_eos, rx163_tgt
    gt rx163_pos, rx163_eos, rx163_done
    set rx163_off, 0
    lt rx163_pos, 2, rx163_start
    sub rx163_off, rx163_pos, 1
    substr rx163_tgt, rx163_tgt, rx163_off
  rx163_start:
    eq $I10, 1, rx163_restart
    if_null rx163_debug, debug_470
    rx163_cur."!cursor_debug"("START", "comp_unit")
  debug_470:
    $I10 = self.'from'()
    ne $I10, -1, rxscan167_done
    goto rxscan167_scan
  rxscan167_loop:
    (rx163_pos) = rx163_cur."from"()
    inc rx163_pos
    rx163_cur."!cursor_from"(rx163_pos)
    ge rx163_pos, rx163_eos, rxscan167_done
  rxscan167_scan:
    set_addr $I10, rxscan167_loop
    rx163_cur."!mark_push"(0, rx163_pos, $I10)
  rxscan167_done:
.annotate 'line', 102
    rx163_cur."!cursor_pos"(rx163_pos)
    new $P168, "Integer"
    assign $P168, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P168
.annotate 'line', 103
  # rx subrule "newpad" subtype=method negate=
    rx163_cur."!cursor_pos"(rx163_pos)
    $P10 = rx163_cur."newpad"()
    unless $P10, rx163_fail
    rx163_pos = $P10."pos"()
.annotate 'line', 104
  # rx subrule "outerctx" subtype=method negate=
    rx163_cur."!cursor_pos"(rx163_pos)
    $P10 = rx163_cur."outerctx"()
    unless $P10, rx163_fail
    rx163_pos = $P10."pos"()
.annotate 'line', 105
  # rx subrule "statementlist" subtype=capture negate=
    rx163_cur."!cursor_pos"(rx163_pos)
    $P10 = rx163_cur."statementlist"()
    unless $P10, rx163_fail
    rx163_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx163_pos = $P10."pos"()
  alt169_0:
.annotate 'line', 106
    set_addr $I10, alt169_1
    rx163_cur."!mark_push"(0, rx163_pos, $I10)
  # rxanchor eos
    ne rx163_pos, rx163_eos, rx163_fail
    goto alt169_end
  alt169_1:
  # rx subrule "panic" subtype=method negate=
    rx163_cur."!cursor_pos"(rx163_pos)
    $P10 = rx163_cur."panic"("Confused")
    unless $P10, rx163_fail
    rx163_pos = $P10."pos"()
  alt169_end:
.annotate 'line', 101
  # rx pass
    rx163_cur."!cursor_pass"(rx163_pos, "comp_unit")
    if_null rx163_debug, debug_471
    rx163_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx163_pos)
  debug_471:
    .return (rx163_cur)
  rx163_restart:
.annotate 'line', 4
    if_null rx163_debug, debug_472
    rx163_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_472:
  rx163_fail:
    (rx163_rep, rx163_pos, $I10, $P10) = rx163_cur."!mark_fail"(0)
    lt rx163_pos, -1, rx163_done
    eq rx163_pos, -1, rx163_fail
    jump $I10
  rx163_done:
    rx163_cur."!cursor_fail"()
    if_null rx163_debug, debug_473
    rx163_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_473:
    .return (rx163_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("30_1299450589.65") :method
.annotate 'line', 4
    $P165 = self."!PREFIX__!subrule"("newpad", "")
    new $P166, "ResizablePMCArray"
    push $P166, $P165
    .return ($P166)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("31_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx171_tgt
    .local int rx171_pos
    .local int rx171_off
    .local int rx171_eos
    .local int rx171_rep
    .local pmc rx171_cur
    .local pmc rx171_debug
    (rx171_cur, rx171_pos, rx171_tgt, $I10) = self."!cursor_start"()
    rx171_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx171_cur
    .local pmc match
    .lex "$/", match
    length rx171_eos, rx171_tgt
    gt rx171_pos, rx171_eos, rx171_done
    set rx171_off, 0
    lt rx171_pos, 2, rx171_start
    sub rx171_off, rx171_pos, 1
    substr rx171_tgt, rx171_tgt, rx171_off
  rx171_start:
    eq $I10, 1, rx171_restart
    if_null rx171_debug, debug_474
    rx171_cur."!cursor_debug"("START", "statementlist")
  debug_474:
    $I10 = self.'from'()
    ne $I10, -1, rxscan176_done
    goto rxscan176_scan
  rxscan176_loop:
    (rx171_pos) = rx171_cur."from"()
    inc rx171_pos
    rx171_cur."!cursor_from"(rx171_pos)
    ge rx171_pos, rx171_eos, rxscan176_done
  rxscan176_scan:
    set_addr $I10, rxscan176_loop
    rx171_cur."!mark_push"(0, rx171_pos, $I10)
  rxscan176_done:
  alt177_0:
.annotate 'line', 109
    set_addr $I10, alt177_1
    rx171_cur."!mark_push"(0, rx171_pos, $I10)
.annotate 'line', 110
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
  # rxanchor eos
    ne rx171_pos, rx171_eos, rx171_fail
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
    goto alt177_end
  alt177_1:
.annotate 'line', 111
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
  # rx rxquantr181 ** 0..*
    set_addr $I10, rxquantr181_done
    rx171_cur."!mark_push"(0, rx171_pos, $I10)
  rxquantr181_loop:
  # rx subrule "statement" subtype=capture negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."statement"()
    unless $P10, rx171_fail
    rx171_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx171_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."eat_terminator"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
    set_addr $I10, rxquantr181_done
    (rx171_rep) = rx171_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr181_done
    rx171_cur."!mark_push"(rx171_rep, rx171_pos, $I10)
    goto rxquantr181_loop
  rxquantr181_done:
  # rx subrule "ws" subtype=method negate=
    rx171_cur."!cursor_pos"(rx171_pos)
    $P10 = rx171_cur."ws"()
    unless $P10, rx171_fail
    rx171_pos = $P10."pos"()
  alt177_end:
.annotate 'line', 109
  # rx pass
    rx171_cur."!cursor_pass"(rx171_pos, "statementlist")
    if_null rx171_debug, debug_475
    rx171_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx171_pos)
  debug_475:
    .return (rx171_cur)
  rx171_restart:
.annotate 'line', 4
    if_null rx171_debug, debug_476
    rx171_cur."!cursor_debug"("NEXT", "statementlist")
  debug_476:
  rx171_fail:
    (rx171_rep, rx171_pos, $I10, $P10) = rx171_cur."!mark_fail"(0)
    lt rx171_pos, -1, rx171_done
    eq rx171_pos, -1, rx171_fail
    jump $I10
  rx171_done:
    rx171_cur."!cursor_fail"()
    if_null rx171_debug, debug_477
    rx171_cur."!cursor_debug"("FAIL", "statementlist")
  debug_477:
    .return (rx171_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("32_1299450589.65") :method
.annotate 'line', 4
    $P173 = self."!PREFIX__!subrule"("ws", "")
    $P174 = self."!PREFIX__!subrule"("ws", "")
    new $P175, "ResizablePMCArray"
    push $P175, $P173
    push $P175, $P174
    .return ($P175)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("33_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P190 = "35_1299450589.65" 
    capture_lex $P190
    .local string rx185_tgt
    .local int rx185_pos
    .local int rx185_off
    .local int rx185_eos
    .local int rx185_rep
    .local pmc rx185_cur
    .local pmc rx185_debug
    (rx185_cur, rx185_pos, rx185_tgt, $I10) = self."!cursor_start"()
    rx185_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx185_cur
    .local pmc match
    .lex "$/", match
    length rx185_eos, rx185_tgt
    gt rx185_pos, rx185_eos, rx185_done
    set rx185_off, 0
    lt rx185_pos, 2, rx185_start
    sub rx185_off, rx185_pos, 1
    substr rx185_tgt, rx185_tgt, rx185_off
  rx185_start:
    eq $I10, 1, rx185_restart
    if_null rx185_debug, debug_478
    rx185_cur."!cursor_debug"("START", "statement")
  debug_478:
    $I10 = self.'from'()
    ne $I10, -1, rxscan188_done
    goto rxscan188_scan
  rxscan188_loop:
    (rx185_pos) = rx185_cur."from"()
    inc rx185_pos
    rx185_cur."!cursor_from"(rx185_pos)
    ge rx185_pos, rx185_eos, rxscan188_done
  rxscan188_scan:
    set_addr $I10, rxscan188_loop
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxscan188_done:
.annotate 'line', 115
  # rx subrule "before" subtype=zerowidth negate=1
    rx185_cur."!cursor_pos"(rx185_pos)
    .const 'Sub' $P190 = "35_1299450589.65" 
    capture_lex $P190
    $P10 = rx185_cur."before"($P190)
    if $P10, rx185_fail
  alt194_0:
.annotate 'line', 116
    set_addr $I10, alt194_1
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
.annotate 'line', 117
  # rx subrule "statement_control" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."statement_control"()
    unless $P10, rx185_fail
    rx185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx185_pos = $P10."pos"()
    goto alt194_end
  alt194_1:
.annotate 'line', 118
  # rx subrule "EXPR" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."EXPR"()
    unless $P10, rx185_fail
    rx185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx185_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."ws"()
    unless $P10, rx185_fail
    rx185_pos = $P10."pos"()
.annotate 'line', 123
  # rx rxquantr195 ** 0..1
    set_addr $I10, rxquantr195_done
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxquantr195_loop:
  alt196_0:
.annotate 'line', 119
    set_addr $I10, alt196_1
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
.annotate 'line', 120
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."MARKED"("endstmt")
    unless $P10, rx185_fail
    goto alt196_end
  alt196_1:
    set_addr $I10, alt196_2
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
.annotate 'line', 121
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."statement_mod_cond"()
    unless $P10, rx185_fail
    rx185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx185_pos = $P10."pos"()
  # rx rxquantr197 ** 0..1
    set_addr $I10, rxquantr197_done
    rx185_cur."!mark_push"(0, rx185_pos, $I10)
  rxquantr197_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."statement_mod_loop"()
    unless $P10, rx185_fail
    goto rxsubrule198_pass
  rxsubrule198_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx185_fail
  rxsubrule198_pass:
    set_addr $I10, rxsubrule198_back
    rx185_cur."!mark_push"(0, rx185_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx185_pos = $P10."pos"()
    set_addr $I10, rxquantr197_done
    (rx185_rep) = rx185_cur."!mark_commit"($I10)
  rxquantr197_done:
    goto alt196_end
  alt196_2:
.annotate 'line', 122
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx185_cur."!cursor_pos"(rx185_pos)
    $P10 = rx185_cur."statement_mod_loop"()
    unless $P10, rx185_fail
    rx185_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx185_pos = $P10."pos"()
  alt196_end:
.annotate 'line', 123
    set_addr $I10, rxquantr195_done
    (rx185_rep) = rx185_cur."!mark_commit"($I10)
  rxquantr195_done:
  alt194_end:
.annotate 'line', 114
  # rx pass
    rx185_cur."!cursor_pass"(rx185_pos, "statement")
    if_null rx185_debug, debug_483
    rx185_cur."!cursor_debug"("PASS", "statement", " at pos=", rx185_pos)
  debug_483:
    .return (rx185_cur)
  rx185_restart:
.annotate 'line', 4
    if_null rx185_debug, debug_484
    rx185_cur."!cursor_debug"("NEXT", "statement")
  debug_484:
  rx185_fail:
    (rx185_rep, rx185_pos, $I10, $P10) = rx185_cur."!mark_fail"(0)
    lt rx185_pos, -1, rx185_done
    eq rx185_pos, -1, rx185_fail
    jump $I10
  rx185_done:
    rx185_cur."!cursor_fail"()
    if_null rx185_debug, debug_485
    rx185_cur."!cursor_debug"("FAIL", "statement")
  debug_485:
    .return (rx185_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("34_1299450589.65") :method
.annotate 'line', 4
    new $P187, "ResizablePMCArray"
    push $P187, ""
    .return ($P187)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block189"  :anon :subid("35_1299450589.65") :method :outer("33_1299450589.65")
.annotate 'line', 115
    .local string rx191_tgt
    .local int rx191_pos
    .local int rx191_off
    .local int rx191_eos
    .local int rx191_rep
    .local pmc rx191_cur
    .local pmc rx191_debug
    (rx191_cur, rx191_pos, rx191_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx191_cur
    .local pmc match
    .lex "$/", match
    length rx191_eos, rx191_tgt
    gt rx191_pos, rx191_eos, rx191_done
    set rx191_off, 0
    lt rx191_pos, 2, rx191_start
    sub rx191_off, rx191_pos, 1
    substr rx191_tgt, rx191_tgt, rx191_off
  rx191_start:
    eq $I10, 1, rx191_restart
    if_null rx191_debug, debug_479
    rx191_cur."!cursor_debug"("START", "")
  debug_479:
    $I10 = self.'from'()
    ne $I10, -1, rxscan192_done
    goto rxscan192_scan
  rxscan192_loop:
    (rx191_pos) = rx191_cur."from"()
    inc rx191_pos
    rx191_cur."!cursor_from"(rx191_pos)
    ge rx191_pos, rx191_eos, rxscan192_done
  rxscan192_scan:
    set_addr $I10, rxscan192_loop
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
  rxscan192_done:
  alt193_0:
    set_addr $I10, alt193_1
    rx191_cur."!mark_push"(0, rx191_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx191_pos, rx191_eos, rx191_fail
    sub $I10, rx191_pos, rx191_off
    substr $S10, rx191_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx191_fail
    inc rx191_pos
    goto alt193_end
  alt193_1:
  # rxanchor eos
    ne rx191_pos, rx191_eos, rx191_fail
  alt193_end:
  # rx pass
    rx191_cur."!cursor_pass"(rx191_pos, "")
    if_null rx191_debug, debug_480
    rx191_cur."!cursor_debug"("PASS", "", " at pos=", rx191_pos)
  debug_480:
    .return (rx191_cur)
  rx191_restart:
    if_null rx191_debug, debug_481
    rx191_cur."!cursor_debug"("NEXT", "")
  debug_481:
  rx191_fail:
    (rx191_rep, rx191_pos, $I10, $P10) = rx191_cur."!mark_fail"(0)
    lt rx191_pos, -1, rx191_done
    eq rx191_pos, -1, rx191_fail
    jump $I10
  rx191_done:
    rx191_cur."!cursor_fail"()
    if_null rx191_debug, debug_482
    rx191_cur."!cursor_debug"("FAIL", "")
  debug_482:
    .return (rx191_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("36_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx200_tgt
    .local int rx200_pos
    .local int rx200_off
    .local int rx200_eos
    .local int rx200_rep
    .local pmc rx200_cur
    .local pmc rx200_debug
    (rx200_cur, rx200_pos, rx200_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx200_cur
    .local pmc match
    .lex "$/", match
    length rx200_eos, rx200_tgt
    gt rx200_pos, rx200_eos, rx200_done
    set rx200_off, 0
    lt rx200_pos, 2, rx200_start
    sub rx200_off, rx200_pos, 1
    substr rx200_tgt, rx200_tgt, rx200_off
  rx200_start:
    eq $I10, 1, rx200_restart
    if_null rx200_debug, debug_486
    rx200_cur."!cursor_debug"("START", "eat_terminator")
  debug_486:
    $I10 = self.'from'()
    ne $I10, -1, rxscan203_done
    goto rxscan203_scan
  rxscan203_loop:
    (rx200_pos) = rx200_cur."from"()
    inc rx200_pos
    rx200_cur."!cursor_from"(rx200_pos)
    ge rx200_pos, rx200_eos, rxscan203_done
  rxscan203_scan:
    set_addr $I10, rxscan203_loop
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
  rxscan203_done:
  alt204_0:
.annotate 'line', 127
    set_addr $I10, alt204_1
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 128
  # rx literal  ";"
    add $I11, rx200_pos, 1
    gt $I11, rx200_eos, rx200_fail
    sub $I11, rx200_pos, rx200_off
    ord $I11, rx200_tgt, $I11
    ne $I11, 59, rx200_fail
    add rx200_pos, 1
    goto alt204_end
  alt204_1:
    set_addr $I10, alt204_2
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 129
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."MARKED"("endstmt")
    unless $P10, rx200_fail
    goto alt204_end
  alt204_2:
    set_addr $I10, alt204_3
    rx200_cur."!mark_push"(0, rx200_pos, $I10)
.annotate 'line', 130
  # rx subrule "terminator" subtype=zerowidth negate=
    rx200_cur."!cursor_pos"(rx200_pos)
    $P10 = rx200_cur."terminator"()
    unless $P10, rx200_fail
    goto alt204_end
  alt204_3:
.annotate 'line', 131
  # rxanchor eos
    ne rx200_pos, rx200_eos, rx200_fail
  alt204_end:
.annotate 'line', 127
  # rx pass
    rx200_cur."!cursor_pass"(rx200_pos, "eat_terminator")
    if_null rx200_debug, debug_487
    rx200_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx200_pos)
  debug_487:
    .return (rx200_cur)
  rx200_restart:
.annotate 'line', 4
    if_null rx200_debug, debug_488
    rx200_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_488:
  rx200_fail:
    (rx200_rep, rx200_pos, $I10, $P10) = rx200_cur."!mark_fail"(0)
    lt rx200_pos, -1, rx200_done
    eq rx200_pos, -1, rx200_fail
    jump $I10
  rx200_done:
    rx200_cur."!cursor_fail"()
    if_null rx200_debug, debug_489
    rx200_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_489:
    .return (rx200_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("37_1299450589.65") :method
.annotate 'line', 4
    new $P202, "ResizablePMCArray"
    push $P202, ""
    push $P202, ""
    push $P202, ""
    push $P202, ";"
    .return ($P202)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("38_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx206_tgt
    .local int rx206_pos
    .local int rx206_off
    .local int rx206_eos
    .local int rx206_rep
    .local pmc rx206_cur
    .local pmc rx206_debug
    (rx206_cur, rx206_pos, rx206_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx206_cur
    .local pmc match
    .lex "$/", match
    length rx206_eos, rx206_tgt
    gt rx206_pos, rx206_eos, rx206_done
    set rx206_off, 0
    lt rx206_pos, 2, rx206_start
    sub rx206_off, rx206_pos, 1
    substr rx206_tgt, rx206_tgt, rx206_off
  rx206_start:
    eq $I10, 1, rx206_restart
    if_null rx206_debug, debug_490
    rx206_cur."!cursor_debug"("START", "xblock")
  debug_490:
    $I10 = self.'from'()
    ne $I10, -1, rxscan210_done
    goto rxscan210_scan
  rxscan210_loop:
    (rx206_pos) = rx206_cur."from"()
    inc rx206_pos
    rx206_cur."!cursor_from"(rx206_pos)
    ge rx206_pos, rx206_eos, rxscan210_done
  rxscan210_scan:
    set_addr $I10, rxscan210_loop
    rx206_cur."!mark_push"(0, rx206_pos, $I10)
  rxscan210_done:
.annotate 'line', 135
  # rx subrule "EXPR" subtype=capture negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."EXPR"()
    unless $P10, rx206_fail
    rx206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx206_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."ws"()
    unless $P10, rx206_fail
    rx206_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx206_cur."!cursor_pos"(rx206_pos)
    $P10 = rx206_cur."pblock"()
    unless $P10, rx206_fail
    rx206_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx206_pos = $P10."pos"()
.annotate 'line', 134
  # rx pass
    rx206_cur."!cursor_pass"(rx206_pos, "xblock")
    if_null rx206_debug, debug_491
    rx206_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx206_pos)
  debug_491:
    .return (rx206_cur)
  rx206_restart:
.annotate 'line', 4
    if_null rx206_debug, debug_492
    rx206_cur."!cursor_debug"("NEXT", "xblock")
  debug_492:
  rx206_fail:
    (rx206_rep, rx206_pos, $I10, $P10) = rx206_cur."!mark_fail"(0)
    lt rx206_pos, -1, rx206_done
    eq rx206_pos, -1, rx206_fail
    jump $I10
  rx206_done:
    rx206_cur."!cursor_fail"()
    if_null rx206_debug, debug_493
    rx206_cur."!cursor_debug"("FAIL", "xblock")
  debug_493:
    .return (rx206_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("39_1299450589.65") :method
.annotate 'line', 4
    $P208 = self."!PREFIX__!subrule"("EXPR", "")
    new $P209, "ResizablePMCArray"
    push $P209, $P208
    .return ($P209)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("40_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx212_tgt
    .local int rx212_pos
    .local int rx212_off
    .local int rx212_eos
    .local int rx212_rep
    .local pmc rx212_cur
    .local pmc rx212_debug
    (rx212_cur, rx212_pos, rx212_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx212_cur
    .local pmc match
    .lex "$/", match
    length rx212_eos, rx212_tgt
    gt rx212_pos, rx212_eos, rx212_done
    set rx212_off, 0
    lt rx212_pos, 2, rx212_start
    sub rx212_off, rx212_pos, 1
    substr rx212_tgt, rx212_tgt, rx212_off
  rx212_start:
    eq $I10, 1, rx212_restart
    if_null rx212_debug, debug_494
    rx212_cur."!cursor_debug"("START", "pblock")
  debug_494:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    (rx212_pos) = rx212_cur."from"()
    inc rx212_pos
    rx212_cur."!cursor_from"(rx212_pos)
    ge rx212_pos, rx212_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
  rxscan217_done:
  alt218_0:
.annotate 'line', 138
    set_addr $I10, alt218_1
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 139
  # rx subrule "lambda" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."lambda"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
.annotate 'line', 140
  # rx subrule "newpad" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."newpad"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
.annotate 'line', 141
  # rx subrule "signature" subtype=capture negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."signature"()
    unless $P10, rx212_fail
    rx212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx212_pos = $P10."pos"()
.annotate 'line', 142
  # rx subrule "blockoid" subtype=capture negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."blockoid"()
    unless $P10, rx212_fail
    rx212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx212_pos = $P10."pos"()
.annotate 'line', 139
    goto alt218_end
  alt218_1:
    set_addr $I10, alt218_2
    rx212_cur."!mark_push"(0, rx212_pos, $I10)
.annotate 'line', 143
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx212_pos, rx212_off
    substr $S10, rx212_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx212_fail
.annotate 'line', 144
  # rx subrule "newpad" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."newpad"()
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
.annotate 'line', 145
  # rx subrule "blockoid" subtype=capture negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."blockoid"()
    unless $P10, rx212_fail
    rx212_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx212_pos = $P10."pos"()
.annotate 'line', 143
    goto alt218_end
  alt218_2:
.annotate 'line', 146
  # rx subrule "panic" subtype=method negate=
    rx212_cur."!cursor_pos"(rx212_pos)
    $P10 = rx212_cur."panic"("Missing block")
    unless $P10, rx212_fail
    rx212_pos = $P10."pos"()
  alt218_end:
.annotate 'line', 138
  # rx pass
    rx212_cur."!cursor_pass"(rx212_pos, "pblock")
    if_null rx212_debug, debug_495
    rx212_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx212_pos)
  debug_495:
    .return (rx212_cur)
  rx212_restart:
.annotate 'line', 4
    if_null rx212_debug, debug_496
    rx212_cur."!cursor_debug"("NEXT", "pblock")
  debug_496:
  rx212_fail:
    (rx212_rep, rx212_pos, $I10, $P10) = rx212_cur."!mark_fail"(0)
    lt rx212_pos, -1, rx212_done
    eq rx212_pos, -1, rx212_fail
    jump $I10
  rx212_done:
    rx212_cur."!cursor_fail"()
    if_null rx212_debug, debug_497
    rx212_cur."!cursor_debug"("FAIL", "pblock")
  debug_497:
    .return (rx212_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("41_1299450589.65") :method
.annotate 'line', 4
    $P214 = self."!PREFIX__!subrule"("panic", "")
    $P215 = self."!PREFIX__!subrule"("lambda", "")
    new $P216, "ResizablePMCArray"
    push $P216, $P214
    push $P216, "{"
    push $P216, $P215
    .return ($P216)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("42_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx220_tgt
    .local int rx220_pos
    .local int rx220_off
    .local int rx220_eos
    .local int rx220_rep
    .local pmc rx220_cur
    .local pmc rx220_debug
    (rx220_cur, rx220_pos, rx220_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx220_cur
    .local pmc match
    .lex "$/", match
    length rx220_eos, rx220_tgt
    gt rx220_pos, rx220_eos, rx220_done
    set rx220_off, 0
    lt rx220_pos, 2, rx220_start
    sub rx220_off, rx220_pos, 1
    substr rx220_tgt, rx220_tgt, rx220_off
  rx220_start:
    eq $I10, 1, rx220_restart
    if_null rx220_debug, debug_498
    rx220_cur."!cursor_debug"("START", "lambda")
  debug_498:
    $I10 = self.'from'()
    ne $I10, -1, rxscan223_done
    goto rxscan223_scan
  rxscan223_loop:
    (rx220_pos) = rx220_cur."from"()
    inc rx220_pos
    rx220_cur."!cursor_from"(rx220_pos)
    ge rx220_pos, rx220_eos, rxscan223_done
  rxscan223_scan:
    set_addr $I10, rxscan223_loop
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  rxscan223_done:
  alt224_0:
.annotate 'line', 149
    set_addr $I10, alt224_1
    rx220_cur."!mark_push"(0, rx220_pos, $I10)
  # rx literal  "->"
    add $I11, rx220_pos, 2
    gt $I11, rx220_eos, rx220_fail
    sub $I11, rx220_pos, rx220_off
    substr $S10, rx220_tgt, $I11, 2
    ne $S10, "->", rx220_fail
    add rx220_pos, 2
    goto alt224_end
  alt224_1:
  # rx literal  "<->"
    add $I11, rx220_pos, 3
    gt $I11, rx220_eos, rx220_fail
    sub $I11, rx220_pos, rx220_off
    substr $S10, rx220_tgt, $I11, 3
    ne $S10, "<->", rx220_fail
    add rx220_pos, 3
  alt224_end:
  # rx pass
    rx220_cur."!cursor_pass"(rx220_pos, "lambda")
    if_null rx220_debug, debug_499
    rx220_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx220_pos)
  debug_499:
    .return (rx220_cur)
  rx220_restart:
.annotate 'line', 4
    if_null rx220_debug, debug_500
    rx220_cur."!cursor_debug"("NEXT", "lambda")
  debug_500:
  rx220_fail:
    (rx220_rep, rx220_pos, $I10, $P10) = rx220_cur."!mark_fail"(0)
    lt rx220_pos, -1, rx220_done
    eq rx220_pos, -1, rx220_fail
    jump $I10
  rx220_done:
    rx220_cur."!cursor_fail"()
    if_null rx220_debug, debug_501
    rx220_cur."!cursor_debug"("FAIL", "lambda")
  debug_501:
    .return (rx220_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("43_1299450589.65") :method
.annotate 'line', 4
    new $P222, "ResizablePMCArray"
    push $P222, "<->"
    push $P222, "->"
    .return ($P222)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("44_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx226_tgt
    .local int rx226_pos
    .local int rx226_off
    .local int rx226_eos
    .local int rx226_rep
    .local pmc rx226_cur
    .local pmc rx226_debug
    (rx226_cur, rx226_pos, rx226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx226_cur
    .local pmc match
    .lex "$/", match
    length rx226_eos, rx226_tgt
    gt rx226_pos, rx226_eos, rx226_done
    set rx226_off, 0
    lt rx226_pos, 2, rx226_start
    sub rx226_off, rx226_pos, 1
    substr rx226_tgt, rx226_tgt, rx226_off
  rx226_start:
    eq $I10, 1, rx226_restart
    if_null rx226_debug, debug_502
    rx226_cur."!cursor_debug"("START", "block")
  debug_502:
    $I10 = self.'from'()
    ne $I10, -1, rxscan230_done
    goto rxscan230_scan
  rxscan230_loop:
    (rx226_pos) = rx226_cur."from"()
    inc rx226_pos
    rx226_cur."!cursor_from"(rx226_pos)
    ge rx226_pos, rx226_eos, rxscan230_done
  rxscan230_scan:
    set_addr $I10, rxscan230_loop
    rx226_cur."!mark_push"(0, rx226_pos, $I10)
  rxscan230_done:
  alt231_0:
.annotate 'line', 152
    set_addr $I10, alt231_1
    rx226_cur."!mark_push"(0, rx226_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx226_pos, rx226_off
    substr $S10, rx226_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx226_fail
    goto alt231_end
  alt231_1:
  # rx subrule "panic" subtype=method negate=
    rx226_cur."!cursor_pos"(rx226_pos)
    $P10 = rx226_cur."panic"("Missing block")
    unless $P10, rx226_fail
    rx226_pos = $P10."pos"()
  alt231_end:
.annotate 'line', 153
  # rx subrule "newpad" subtype=method negate=
    rx226_cur."!cursor_pos"(rx226_pos)
    $P10 = rx226_cur."newpad"()
    unless $P10, rx226_fail
    rx226_pos = $P10."pos"()
.annotate 'line', 154
  # rx subrule "blockoid" subtype=capture negate=
    rx226_cur."!cursor_pos"(rx226_pos)
    $P10 = rx226_cur."blockoid"()
    unless $P10, rx226_fail
    rx226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx226_pos = $P10."pos"()
.annotate 'line', 151
  # rx pass
    rx226_cur."!cursor_pass"(rx226_pos, "block")
    if_null rx226_debug, debug_503
    rx226_cur."!cursor_debug"("PASS", "block", " at pos=", rx226_pos)
  debug_503:
    .return (rx226_cur)
  rx226_restart:
.annotate 'line', 4
    if_null rx226_debug, debug_504
    rx226_cur."!cursor_debug"("NEXT", "block")
  debug_504:
  rx226_fail:
    (rx226_rep, rx226_pos, $I10, $P10) = rx226_cur."!mark_fail"(0)
    lt rx226_pos, -1, rx226_done
    eq rx226_pos, -1, rx226_fail
    jump $I10
  rx226_done:
    rx226_cur."!cursor_fail"()
    if_null rx226_debug, debug_505
    rx226_cur."!cursor_debug"("FAIL", "block")
  debug_505:
    .return (rx226_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("45_1299450589.65") :method
.annotate 'line', 4
    $P228 = self."!PREFIX__!subrule"("panic", "")
    new $P229, "ResizablePMCArray"
    push $P229, $P228
    push $P229, "{"
    .return ($P229)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("46_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx233_tgt
    .local int rx233_pos
    .local int rx233_off
    .local int rx233_eos
    .local int rx233_rep
    .local pmc rx233_cur
    .local pmc rx233_debug
    (rx233_cur, rx233_pos, rx233_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx233_cur
    .local pmc match
    .lex "$/", match
    length rx233_eos, rx233_tgt
    gt rx233_pos, rx233_eos, rx233_done
    set rx233_off, 0
    lt rx233_pos, 2, rx233_start
    sub rx233_off, rx233_pos, 1
    substr rx233_tgt, rx233_tgt, rx233_off
  rx233_start:
    eq $I10, 1, rx233_restart
    if_null rx233_debug, debug_506
    rx233_cur."!cursor_debug"("START", "blockoid")
  debug_506:
    $I10 = self.'from'()
    ne $I10, -1, rxscan237_done
    goto rxscan237_scan
  rxscan237_loop:
    (rx233_pos) = rx233_cur."from"()
    inc rx233_pos
    rx233_cur."!cursor_from"(rx233_pos)
    ge rx233_pos, rx233_eos, rxscan237_done
  rxscan237_scan:
    set_addr $I10, rxscan237_loop
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  rxscan237_done:
.annotate 'line', 158
  # rx subrule "finishpad" subtype=method negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."finishpad"()
    unless $P10, rx233_fail
    rx233_pos = $P10."pos"()
  alt238_0:
.annotate 'line', 159
    set_addr $I10, alt238_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
.annotate 'line', 160
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx233_pos, 14
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    substr $S10, rx233_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx233_fail
    add rx233_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."you_are_here"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx233_pos = $P10."pos"()
    goto alt238_end
  alt238_1:
.annotate 'line', 161
  # rx literal  "{"
    add $I11, rx233_pos, 1
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    ord $I11, rx233_tgt, $I11
    ne $I11, 123, rx233_fail
    add rx233_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."statementlist"()
    unless $P10, rx233_fail
    rx233_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx233_pos = $P10."pos"()
  alt239_0:
    set_addr $I10, alt239_1
    rx233_cur."!mark_push"(0, rx233_pos, $I10)
  # rx literal  "}"
    add $I11, rx233_pos, 1
    gt $I11, rx233_eos, rx233_fail
    sub $I11, rx233_pos, rx233_off
    ord $I11, rx233_tgt, $I11
    ne $I11, 125, rx233_fail
    add rx233_pos, 1
    goto alt239_end
  alt239_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."FAILGOAL"("'}'")
    unless $P10, rx233_fail
    goto rxsubrule241_pass
  rxsubrule241_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx233_fail
  rxsubrule241_pass:
    set_addr $I10, rxsubrule241_back
    rx233_cur."!mark_push"(0, rx233_pos, $I10, $P10)
    rx233_pos = $P10."pos"()
  alt239_end:
  alt238_end:
.annotate 'line', 163
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx233_cur."!cursor_pos"(rx233_pos)
    $P10 = rx233_cur."ENDSTMT"()
    unless $P10, rx233_fail
.annotate 'line', 157
  # rx pass
    rx233_cur."!cursor_pass"(rx233_pos, "blockoid")
    if_null rx233_debug, debug_507
    rx233_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx233_pos)
  debug_507:
    .return (rx233_cur)
  rx233_restart:
.annotate 'line', 4
    if_null rx233_debug, debug_508
    rx233_cur."!cursor_debug"("NEXT", "blockoid")
  debug_508:
  rx233_fail:
    (rx233_rep, rx233_pos, $I10, $P10) = rx233_cur."!mark_fail"(0)
    lt rx233_pos, -1, rx233_done
    eq rx233_pos, -1, rx233_fail
    jump $I10
  rx233_done:
    rx233_cur."!cursor_fail"()
    if_null rx233_debug, debug_509
    rx233_cur."!cursor_debug"("FAIL", "blockoid")
  debug_509:
    .return (rx233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("47_1299450589.65") :method
.annotate 'line', 4
    $P235 = self."!PREFIX__!subrule"("finishpad", "")
    new $P236, "ResizablePMCArray"
    push $P236, $P235
    .return ($P236)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("48_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx243_tgt
    .local int rx243_pos
    .local int rx243_off
    .local int rx243_eos
    .local int rx243_rep
    .local pmc rx243_cur
    .local pmc rx243_debug
    (rx243_cur, rx243_pos, rx243_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx243_cur
    .local pmc match
    .lex "$/", match
    length rx243_eos, rx243_tgt
    gt rx243_pos, rx243_eos, rx243_done
    set rx243_off, 0
    lt rx243_pos, 2, rx243_start
    sub rx243_off, rx243_pos, 1
    substr rx243_tgt, rx243_tgt, rx243_off
  rx243_start:
    eq $I10, 1, rx243_restart
    if_null rx243_debug, debug_510
    rx243_cur."!cursor_debug"("START", "newpad")
  debug_510:
    $I10 = self.'from'()
    ne $I10, -1, rxscan246_done
    goto rxscan246_scan
  rxscan246_loop:
    (rx243_pos) = rx243_cur."from"()
    inc rx243_pos
    rx243_cur."!cursor_from"(rx243_pos)
    ge rx243_pos, rx243_eos, rxscan246_done
  rxscan246_scan:
    set_addr $I10, rxscan246_loop
    rx243_cur."!mark_push"(0, rx243_pos, $I10)
  rxscan246_done:
.annotate 'line', 166
  # rx pass
    rx243_cur."!cursor_pass"(rx243_pos, "newpad")
    if_null rx243_debug, debug_511
    rx243_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx243_pos)
  debug_511:
    .return (rx243_cur)
  rx243_restart:
.annotate 'line', 4
    if_null rx243_debug, debug_512
    rx243_cur."!cursor_debug"("NEXT", "newpad")
  debug_512:
  rx243_fail:
    (rx243_rep, rx243_pos, $I10, $P10) = rx243_cur."!mark_fail"(0)
    lt rx243_pos, -1, rx243_done
    eq rx243_pos, -1, rx243_fail
    jump $I10
  rx243_done:
    rx243_cur."!cursor_fail"()
    if_null rx243_debug, debug_513
    rx243_cur."!cursor_debug"("FAIL", "newpad")
  debug_513:
    .return (rx243_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("49_1299450589.65") :method
.annotate 'line', 4
    new $P245, "ResizablePMCArray"
    push $P245, ""
    .return ($P245)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("50_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx248_tgt
    .local int rx248_pos
    .local int rx248_off
    .local int rx248_eos
    .local int rx248_rep
    .local pmc rx248_cur
    .local pmc rx248_debug
    (rx248_cur, rx248_pos, rx248_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx248_cur
    .local pmc match
    .lex "$/", match
    length rx248_eos, rx248_tgt
    gt rx248_pos, rx248_eos, rx248_done
    set rx248_off, 0
    lt rx248_pos, 2, rx248_start
    sub rx248_off, rx248_pos, 1
    substr rx248_tgt, rx248_tgt, rx248_off
  rx248_start:
    eq $I10, 1, rx248_restart
    if_null rx248_debug, debug_514
    rx248_cur."!cursor_debug"("START", "outerctx")
  debug_514:
    $I10 = self.'from'()
    ne $I10, -1, rxscan251_done
    goto rxscan251_scan
  rxscan251_loop:
    (rx248_pos) = rx248_cur."from"()
    inc rx248_pos
    rx248_cur."!cursor_from"(rx248_pos)
    ge rx248_pos, rx248_eos, rxscan251_done
  rxscan251_scan:
    set_addr $I10, rxscan251_loop
    rx248_cur."!mark_push"(0, rx248_pos, $I10)
  rxscan251_done:
.annotate 'line', 167
  # rx pass
    rx248_cur."!cursor_pass"(rx248_pos, "outerctx")
    if_null rx248_debug, debug_515
    rx248_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx248_pos)
  debug_515:
    .return (rx248_cur)
  rx248_restart:
.annotate 'line', 4
    if_null rx248_debug, debug_516
    rx248_cur."!cursor_debug"("NEXT", "outerctx")
  debug_516:
  rx248_fail:
    (rx248_rep, rx248_pos, $I10, $P10) = rx248_cur."!mark_fail"(0)
    lt rx248_pos, -1, rx248_done
    eq rx248_pos, -1, rx248_fail
    jump $I10
  rx248_done:
    rx248_cur."!cursor_fail"()
    if_null rx248_debug, debug_517
    rx248_cur."!cursor_debug"("FAIL", "outerctx")
  debug_517:
    .return (rx248_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("51_1299450589.65") :method
.annotate 'line', 4
    new $P250, "ResizablePMCArray"
    push $P250, ""
    .return ($P250)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("52_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx253_tgt
    .local int rx253_pos
    .local int rx253_off
    .local int rx253_eos
    .local int rx253_rep
    .local pmc rx253_cur
    .local pmc rx253_debug
    (rx253_cur, rx253_pos, rx253_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx253_cur
    .local pmc match
    .lex "$/", match
    length rx253_eos, rx253_tgt
    gt rx253_pos, rx253_eos, rx253_done
    set rx253_off, 0
    lt rx253_pos, 2, rx253_start
    sub rx253_off, rx253_pos, 1
    substr rx253_tgt, rx253_tgt, rx253_off
  rx253_start:
    eq $I10, 1, rx253_restart
    if_null rx253_debug, debug_518
    rx253_cur."!cursor_debug"("START", "finishpad")
  debug_518:
    $I10 = self.'from'()
    ne $I10, -1, rxscan256_done
    goto rxscan256_scan
  rxscan256_loop:
    (rx253_pos) = rx253_cur."from"()
    inc rx253_pos
    rx253_cur."!cursor_from"(rx253_pos)
    ge rx253_pos, rx253_eos, rxscan256_done
  rxscan256_scan:
    set_addr $I10, rxscan256_loop
    rx253_cur."!mark_push"(0, rx253_pos, $I10)
  rxscan256_done:
.annotate 'line', 168
  # rx pass
    rx253_cur."!cursor_pass"(rx253_pos, "finishpad")
    if_null rx253_debug, debug_519
    rx253_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx253_pos)
  debug_519:
    .return (rx253_cur)
  rx253_restart:
.annotate 'line', 4
    if_null rx253_debug, debug_520
    rx253_cur."!cursor_debug"("NEXT", "finishpad")
  debug_520:
  rx253_fail:
    (rx253_rep, rx253_pos, $I10, $P10) = rx253_cur."!mark_fail"(0)
    lt rx253_pos, -1, rx253_done
    eq rx253_pos, -1, rx253_fail
    jump $I10
  rx253_done:
    rx253_cur."!cursor_fail"()
    if_null rx253_debug, debug_521
    rx253_cur."!cursor_debug"("FAIL", "finishpad")
  debug_521:
    .return (rx253_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("53_1299450589.65") :method
.annotate 'line', 4
    new $P255, "ResizablePMCArray"
    push $P255, ""
    .return ($P255)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("54_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx258_tgt
    .local int rx258_pos
    .local int rx258_off
    .local int rx258_eos
    .local int rx258_rep
    .local pmc rx258_cur
    .local pmc rx258_debug
    (rx258_cur, rx258_pos, rx258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx258_cur
    .local pmc match
    .lex "$/", match
    length rx258_eos, rx258_tgt
    gt rx258_pos, rx258_eos, rx258_done
    set rx258_off, 0
    lt rx258_pos, 2, rx258_start
    sub rx258_off, rx258_pos, 1
    substr rx258_tgt, rx258_tgt, rx258_off
  rx258_start:
    eq $I10, 1, rx258_restart
    if_null rx258_debug, debug_522
    rx258_cur."!cursor_debug"("START", "you_are_here")
  debug_522:
    $I10 = self.'from'()
    ne $I10, -1, rxscan261_done
    goto rxscan261_scan
  rxscan261_loop:
    (rx258_pos) = rx258_cur."from"()
    inc rx258_pos
    rx258_cur."!cursor_from"(rx258_pos)
    ge rx258_pos, rx258_eos, rxscan261_done
  rxscan261_scan:
    set_addr $I10, rxscan261_loop
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  rxscan261_done:
.annotate 'line', 169
  # rx pass
    rx258_cur."!cursor_pass"(rx258_pos, "you_are_here")
    if_null rx258_debug, debug_523
    rx258_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx258_pos)
  debug_523:
    .return (rx258_cur)
  rx258_restart:
.annotate 'line', 4
    if_null rx258_debug, debug_524
    rx258_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_524:
  rx258_fail:
    (rx258_rep, rx258_pos, $I10, $P10) = rx258_cur."!mark_fail"(0)
    lt rx258_pos, -1, rx258_done
    eq rx258_pos, -1, rx258_fail
    jump $I10
  rx258_done:
    rx258_cur."!cursor_fail"()
    if_null rx258_debug, debug_525
    rx258_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_525:
    .return (rx258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("55_1299450589.65") :method
.annotate 'line', 4
    new $P260, "ResizablePMCArray"
    push $P260, ""
    .return ($P260)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("56_1299450589.65")
    .param pmc param_263
.annotate 'line', 171
    .lex "self", param_263
    $P264 = param_263."!protoregex"("terminator")
    .return ($P264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("57_1299450589.65")
    .param pmc param_266
.annotate 'line', 171
    .lex "self", param_266
    $P267 = param_266."!PREFIX__!protoregex"("terminator")
    .return ($P267)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("58_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx269_tgt
    .local int rx269_pos
    .local int rx269_off
    .local int rx269_eos
    .local int rx269_rep
    .local pmc rx269_cur
    .local pmc rx269_debug
    (rx269_cur, rx269_pos, rx269_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx269_cur
    .local pmc match
    .lex "$/", match
    length rx269_eos, rx269_tgt
    gt rx269_pos, rx269_eos, rx269_done
    set rx269_off, 0
    lt rx269_pos, 2, rx269_start
    sub rx269_off, rx269_pos, 1
    substr rx269_tgt, rx269_tgt, rx269_off
  rx269_start:
    eq $I10, 1, rx269_restart
    if_null rx269_debug, debug_526
    rx269_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_526:
    $I10 = self.'from'()
    ne $I10, -1, rxscan272_done
    goto rxscan272_scan
  rxscan272_loop:
    (rx269_pos) = rx269_cur."from"()
    inc rx269_pos
    rx269_cur."!cursor_from"(rx269_pos)
    ge rx269_pos, rx269_eos, rxscan272_done
  rxscan272_scan:
    set_addr $I10, rxscan272_loop
    rx269_cur."!mark_push"(0, rx269_pos, $I10)
  rxscan272_done:
.annotate 'line', 173
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx269_pos, rx269_off
    substr $S10, rx269_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx269_fail
  # rx pass
    rx269_cur."!cursor_pass"(rx269_pos, "terminator:sym<;>")
    if_null rx269_debug, debug_527
    rx269_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx269_pos)
  debug_527:
    .return (rx269_cur)
  rx269_restart:
.annotate 'line', 4
    if_null rx269_debug, debug_528
    rx269_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_528:
  rx269_fail:
    (rx269_rep, rx269_pos, $I10, $P10) = rx269_cur."!mark_fail"(0)
    lt rx269_pos, -1, rx269_done
    eq rx269_pos, -1, rx269_fail
    jump $I10
  rx269_done:
    rx269_cur."!cursor_fail"()
    if_null rx269_debug, debug_529
    rx269_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_529:
    .return (rx269_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("59_1299450589.65") :method
.annotate 'line', 4
    new $P271, "ResizablePMCArray"
    push $P271, ";"
    .return ($P271)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("60_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx274_tgt
    .local int rx274_pos
    .local int rx274_off
    .local int rx274_eos
    .local int rx274_rep
    .local pmc rx274_cur
    .local pmc rx274_debug
    (rx274_cur, rx274_pos, rx274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx274_cur
    .local pmc match
    .lex "$/", match
    length rx274_eos, rx274_tgt
    gt rx274_pos, rx274_eos, rx274_done
    set rx274_off, 0
    lt rx274_pos, 2, rx274_start
    sub rx274_off, rx274_pos, 1
    substr rx274_tgt, rx274_tgt, rx274_off
  rx274_start:
    eq $I10, 1, rx274_restart
    if_null rx274_debug, debug_530
    rx274_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_530:
    $I10 = self.'from'()
    ne $I10, -1, rxscan277_done
    goto rxscan277_scan
  rxscan277_loop:
    (rx274_pos) = rx274_cur."from"()
    inc rx274_pos
    rx274_cur."!cursor_from"(rx274_pos)
    ge rx274_pos, rx274_eos, rxscan277_done
  rxscan277_scan:
    set_addr $I10, rxscan277_loop
    rx274_cur."!mark_push"(0, rx274_pos, $I10)
  rxscan277_done:
.annotate 'line', 174
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx274_pos, rx274_off
    substr $S10, rx274_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx274_fail
  # rx pass
    rx274_cur."!cursor_pass"(rx274_pos, "terminator:sym<}>")
    if_null rx274_debug, debug_531
    rx274_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx274_pos)
  debug_531:
    .return (rx274_cur)
  rx274_restart:
.annotate 'line', 4
    if_null rx274_debug, debug_532
    rx274_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_532:
  rx274_fail:
    (rx274_rep, rx274_pos, $I10, $P10) = rx274_cur."!mark_fail"(0)
    lt rx274_pos, -1, rx274_done
    eq rx274_pos, -1, rx274_fail
    jump $I10
  rx274_done:
    rx274_cur."!cursor_fail"()
    if_null rx274_debug, debug_533
    rx274_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_533:
    .return (rx274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("61_1299450589.65") :method
.annotate 'line', 4
    new $P276, "ResizablePMCArray"
    push $P276, "}"
    .return ($P276)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("62_1299450589.65")
    .param pmc param_279
.annotate 'line', 178
    .lex "self", param_279
    $P280 = param_279."!protoregex"("statement_control")
    .return ($P280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("63_1299450589.65")
    .param pmc param_282
.annotate 'line', 178
    .lex "self", param_282
    $P283 = param_282."!PREFIX__!protoregex"("statement_control")
    .return ($P283)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("64_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx285_tgt
    .local int rx285_pos
    .local int rx285_off
    .local int rx285_eos
    .local int rx285_rep
    .local pmc rx285_cur
    .local pmc rx285_debug
    (rx285_cur, rx285_pos, rx285_tgt, $I10) = self."!cursor_start"()
    rx285_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx285_cur
    .local pmc match
    .lex "$/", match
    length rx285_eos, rx285_tgt
    gt rx285_pos, rx285_eos, rx285_done
    set rx285_off, 0
    lt rx285_pos, 2, rx285_start
    sub rx285_off, rx285_pos, 1
    substr rx285_tgt, rx285_tgt, rx285_off
  rx285_start:
    eq $I10, 1, rx285_restart
    if_null rx285_debug, debug_534
    rx285_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_534:
    $I10 = self.'from'()
    ne $I10, -1, rxscan288_done
    goto rxscan288_scan
  rxscan288_loop:
    (rx285_pos) = rx285_cur."from"()
    inc rx285_pos
    rx285_cur."!cursor_from"(rx285_pos)
    ge rx285_pos, rx285_eos, rxscan288_done
  rxscan288_scan:
    set_addr $I10, rxscan288_loop
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  rxscan288_done:
.annotate 'line', 181
  # rx subcapture "sym"
    set_addr $I10, rxcap_289_fail
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  # rx literal  "if"
    add $I11, rx285_pos, 2
    gt $I11, rx285_eos, rx285_fail
    sub $I11, rx285_pos, rx285_off
    substr $S10, rx285_tgt, $I11, 2
    ne $S10, "if", rx285_fail
    add rx285_pos, 2
    set_addr $I10, rxcap_289_fail
    ($I12, $I11) = rx285_cur."!mark_peek"($I10)
    rx285_cur."!cursor_pos"($I11)
    ($P10) = rx285_cur."!cursor_start"()
    $P10."!cursor_pass"(rx285_pos, "")
    rx285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_289_done
  rxcap_289_fail:
    goto rx285_fail
  rxcap_289_done:
  # rx charclass s
    ge rx285_pos, rx285_eos, rx285_fail
    sub $I10, rx285_pos, rx285_off
    is_cclass $I11, 32, rx285_tgt, $I10
    unless $I11, rx285_fail
    inc rx285_pos
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
.annotate 'line', 182
  # rx subrule "xblock" subtype=capture negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."xblock"()
    unless $P10, rx285_fail
    rx285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx285_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
.annotate 'line', 183
  # rx rxquantr292 ** 0..*
    set_addr $I10, rxquantr292_done
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  rxquantr292_loop:
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx285_pos, 5
    gt $I11, rx285_eos, rx285_fail
    sub $I11, rx285_pos, rx285_off
    substr $S10, rx285_tgt, $I11, 5
    ne $S10, "elsif", rx285_fail
    add rx285_pos, 5
  # rx charclass s
    ge rx285_pos, rx285_eos, rx285_fail
    sub $I10, rx285_pos, rx285_off
    is_cclass $I11, 32, rx285_tgt, $I10
    unless $I11, rx285_fail
    inc rx285_pos
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."xblock"()
    unless $P10, rx285_fail
    rx285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx285_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
    set_addr $I10, rxquantr292_done
    (rx285_rep) = rx285_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr292_done
    rx285_cur."!mark_push"(rx285_rep, rx285_pos, $I10)
    goto rxquantr292_loop
  rxquantr292_done:
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
.annotate 'line', 184
  # rx rxquantr297 ** 0..1
    set_addr $I10, rxquantr297_done
    rx285_cur."!mark_push"(0, rx285_pos, $I10)
  rxquantr297_loop:
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx285_pos, 4
    gt $I11, rx285_eos, rx285_fail
    sub $I11, rx285_pos, rx285_off
    substr $S10, rx285_tgt, $I11, 4
    ne $S10, "else", rx285_fail
    add rx285_pos, 4
  # rx charclass s
    ge rx285_pos, rx285_eos, rx285_fail
    sub $I10, rx285_pos, rx285_off
    is_cclass $I11, 32, rx285_tgt, $I10
    unless $I11, rx285_fail
    inc rx285_pos
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."pblock"()
    unless $P10, rx285_fail
    rx285_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx285_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
    set_addr $I10, rxquantr297_done
    (rx285_rep) = rx285_cur."!mark_commit"($I10)
  rxquantr297_done:
  # rx subrule "ws" subtype=method negate=
    rx285_cur."!cursor_pos"(rx285_pos)
    $P10 = rx285_cur."ws"()
    unless $P10, rx285_fail
    rx285_pos = $P10."pos"()
.annotate 'line', 180
  # rx pass
    rx285_cur."!cursor_pass"(rx285_pos, "statement_control:sym<if>")
    if_null rx285_debug, debug_535
    rx285_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx285_pos)
  debug_535:
    .return (rx285_cur)
  rx285_restart:
.annotate 'line', 4
    if_null rx285_debug, debug_536
    rx285_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_536:
  rx285_fail:
    (rx285_rep, rx285_pos, $I10, $P10) = rx285_cur."!mark_fail"(0)
    lt rx285_pos, -1, rx285_done
    eq rx285_pos, -1, rx285_fail
    jump $I10
  rx285_done:
    rx285_cur."!cursor_fail"()
    if_null rx285_debug, debug_537
    rx285_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_537:
    .return (rx285_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("65_1299450589.65") :method
.annotate 'line', 4
    new $P287, "ResizablePMCArray"
    push $P287, "if"
    .return ($P287)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("66_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P313 = "68_1299450589.65" 
    capture_lex $P313
    .local string rx303_tgt
    .local int rx303_pos
    .local int rx303_off
    .local int rx303_eos
    .local int rx303_rep
    .local pmc rx303_cur
    .local pmc rx303_debug
    (rx303_cur, rx303_pos, rx303_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx303_cur
    .local pmc match
    .lex "$/", match
    length rx303_eos, rx303_tgt
    gt rx303_pos, rx303_eos, rx303_done
    set rx303_off, 0
    lt rx303_pos, 2, rx303_start
    sub rx303_off, rx303_pos, 1
    substr rx303_tgt, rx303_tgt, rx303_off
  rx303_start:
    eq $I10, 1, rx303_restart
    if_null rx303_debug, debug_538
    rx303_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_538:
    $I10 = self.'from'()
    ne $I10, -1, rxscan306_done
    goto rxscan306_scan
  rxscan306_loop:
    (rx303_pos) = rx303_cur."from"()
    inc rx303_pos
    rx303_cur."!cursor_from"(rx303_pos)
    ge rx303_pos, rx303_eos, rxscan306_done
  rxscan306_scan:
    set_addr $I10, rxscan306_loop
    rx303_cur."!mark_push"(0, rx303_pos, $I10)
  rxscan306_done:
.annotate 'line', 188
  # rx subcapture "sym"
    set_addr $I10, rxcap_307_fail
    rx303_cur."!mark_push"(0, rx303_pos, $I10)
  # rx literal  "unless"
    add $I11, rx303_pos, 6
    gt $I11, rx303_eos, rx303_fail
    sub $I11, rx303_pos, rx303_off
    substr $S10, rx303_tgt, $I11, 6
    ne $S10, "unless", rx303_fail
    add rx303_pos, 6
    set_addr $I10, rxcap_307_fail
    ($I12, $I11) = rx303_cur."!mark_peek"($I10)
    rx303_cur."!cursor_pos"($I11)
    ($P10) = rx303_cur."!cursor_start"()
    $P10."!cursor_pass"(rx303_pos, "")
    rx303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_307_done
  rxcap_307_fail:
    goto rx303_fail
  rxcap_307_done:
  # rx charclass s
    ge rx303_pos, rx303_eos, rx303_fail
    sub $I10, rx303_pos, rx303_off
    is_cclass $I11, 32, rx303_tgt, $I10
    unless $I11, rx303_fail
    inc rx303_pos
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
.annotate 'line', 189
  # rx subrule "xblock" subtype=capture negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."xblock"()
    unless $P10, rx303_fail
    rx303_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx303_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  alt310_0:
.annotate 'line', 190
    set_addr $I10, alt310_1
    rx303_cur."!mark_push"(0, rx303_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx303_cur."!cursor_pos"(rx303_pos)
    .const 'Sub' $P313 = "68_1299450589.65" 
    capture_lex $P313
    $P10 = rx303_cur."before"($P313)
    if $P10, rx303_fail
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
    goto alt310_end
  alt310_1:
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
  alt310_end:
  # rx subrule "ws" subtype=method negate=
    rx303_cur."!cursor_pos"(rx303_pos)
    $P10 = rx303_cur."ws"()
    unless $P10, rx303_fail
    rx303_pos = $P10."pos"()
.annotate 'line', 187
  # rx pass
    rx303_cur."!cursor_pass"(rx303_pos, "statement_control:sym<unless>")
    if_null rx303_debug, debug_543
    rx303_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx303_pos)
  debug_543:
    .return (rx303_cur)
  rx303_restart:
.annotate 'line', 4
    if_null rx303_debug, debug_544
    rx303_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_544:
  rx303_fail:
    (rx303_rep, rx303_pos, $I10, $P10) = rx303_cur."!mark_fail"(0)
    lt rx303_pos, -1, rx303_done
    eq rx303_pos, -1, rx303_fail
    jump $I10
  rx303_done:
    rx303_cur."!cursor_fail"()
    if_null rx303_debug, debug_545
    rx303_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_545:
    .return (rx303_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("67_1299450589.65") :method
.annotate 'line', 4
    new $P305, "ResizablePMCArray"
    push $P305, "unless"
    .return ($P305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block312"  :anon :subid("68_1299450589.65") :method :outer("66_1299450589.65")
.annotate 'line', 190
    .local string rx314_tgt
    .local int rx314_pos
    .local int rx314_off
    .local int rx314_eos
    .local int rx314_rep
    .local pmc rx314_cur
    .local pmc rx314_debug
    (rx314_cur, rx314_pos, rx314_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx314_cur
    .local pmc match
    .lex "$/", match
    length rx314_eos, rx314_tgt
    gt rx314_pos, rx314_eos, rx314_done
    set rx314_off, 0
    lt rx314_pos, 2, rx314_start
    sub rx314_off, rx314_pos, 1
    substr rx314_tgt, rx314_tgt, rx314_off
  rx314_start:
    eq $I10, 1, rx314_restart
    if_null rx314_debug, debug_539
    rx314_cur."!cursor_debug"("START", "")
  debug_539:
    $I10 = self.'from'()
    ne $I10, -1, rxscan315_done
    goto rxscan315_scan
  rxscan315_loop:
    (rx314_pos) = rx314_cur."from"()
    inc rx314_pos
    rx314_cur."!cursor_from"(rx314_pos)
    ge rx314_pos, rx314_eos, rxscan315_done
  rxscan315_scan:
    set_addr $I10, rxscan315_loop
    rx314_cur."!mark_push"(0, rx314_pos, $I10)
  rxscan315_done:
  # rx literal  "else"
    add $I11, rx314_pos, 4
    gt $I11, rx314_eos, rx314_fail
    sub $I11, rx314_pos, rx314_off
    substr $S10, rx314_tgt, $I11, 4
    ne $S10, "else", rx314_fail
    add rx314_pos, 4
  # rx pass
    rx314_cur."!cursor_pass"(rx314_pos, "")
    if_null rx314_debug, debug_540
    rx314_cur."!cursor_debug"("PASS", "", " at pos=", rx314_pos)
  debug_540:
    .return (rx314_cur)
  rx314_restart:
    if_null rx314_debug, debug_541
    rx314_cur."!cursor_debug"("NEXT", "")
  debug_541:
  rx314_fail:
    (rx314_rep, rx314_pos, $I10, $P10) = rx314_cur."!mark_fail"(0)
    lt rx314_pos, -1, rx314_done
    eq rx314_pos, -1, rx314_fail
    jump $I10
  rx314_done:
    rx314_cur."!cursor_fail"()
    if_null rx314_debug, debug_542
    rx314_cur."!cursor_debug"("FAIL", "")
  debug_542:
    .return (rx314_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("69_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx321_tgt
    .local int rx321_pos
    .local int rx321_off
    .local int rx321_eos
    .local int rx321_rep
    .local pmc rx321_cur
    .local pmc rx321_debug
    (rx321_cur, rx321_pos, rx321_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx321_cur
    .local pmc match
    .lex "$/", match
    length rx321_eos, rx321_tgt
    gt rx321_pos, rx321_eos, rx321_done
    set rx321_off, 0
    lt rx321_pos, 2, rx321_start
    sub rx321_off, rx321_pos, 1
    substr rx321_tgt, rx321_tgt, rx321_off
  rx321_start:
    eq $I10, 1, rx321_restart
    if_null rx321_debug, debug_546
    rx321_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_546:
    $I10 = self.'from'()
    ne $I10, -1, rxscan324_done
    goto rxscan324_scan
  rxscan324_loop:
    (rx321_pos) = rx321_cur."from"()
    inc rx321_pos
    rx321_cur."!cursor_from"(rx321_pos)
    ge rx321_pos, rx321_eos, rxscan324_done
  rxscan324_scan:
    set_addr $I10, rxscan324_loop
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  rxscan324_done:
.annotate 'line', 194
  # rx subcapture "sym"
    set_addr $I10, rxcap_326_fail
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  alt325_0:
    set_addr $I10, alt325_1
    rx321_cur."!mark_push"(0, rx321_pos, $I10)
  # rx literal  "while"
    add $I11, rx321_pos, 5
    gt $I11, rx321_eos, rx321_fail
    sub $I11, rx321_pos, rx321_off
    substr $S10, rx321_tgt, $I11, 5
    ne $S10, "while", rx321_fail
    add rx321_pos, 5
    goto alt325_end
  alt325_1:
  # rx literal  "until"
    add $I11, rx321_pos, 5
    gt $I11, rx321_eos, rx321_fail
    sub $I11, rx321_pos, rx321_off
    substr $S10, rx321_tgt, $I11, 5
    ne $S10, "until", rx321_fail
    add rx321_pos, 5
  alt325_end:
    set_addr $I10, rxcap_326_fail
    ($I12, $I11) = rx321_cur."!mark_peek"($I10)
    rx321_cur."!cursor_pos"($I11)
    ($P10) = rx321_cur."!cursor_start"()
    $P10."!cursor_pass"(rx321_pos, "")
    rx321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_326_done
  rxcap_326_fail:
    goto rx321_fail
  rxcap_326_done:
  # rx charclass s
    ge rx321_pos, rx321_eos, rx321_fail
    sub $I10, rx321_pos, rx321_off
    is_cclass $I11, 32, rx321_tgt, $I10
    unless $I11, rx321_fail
    inc rx321_pos
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
.annotate 'line', 195
  # rx subrule "xblock" subtype=capture negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."xblock"()
    unless $P10, rx321_fail
    rx321_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx321_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx321_cur."!cursor_pos"(rx321_pos)
    $P10 = rx321_cur."ws"()
    unless $P10, rx321_fail
    rx321_pos = $P10."pos"()
.annotate 'line', 193
  # rx pass
    rx321_cur."!cursor_pass"(rx321_pos, "statement_control:sym<while>")
    if_null rx321_debug, debug_547
    rx321_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx321_pos)
  debug_547:
    .return (rx321_cur)
  rx321_restart:
.annotate 'line', 4
    if_null rx321_debug, debug_548
    rx321_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_548:
  rx321_fail:
    (rx321_rep, rx321_pos, $I10, $P10) = rx321_cur."!mark_fail"(0)
    lt rx321_pos, -1, rx321_done
    eq rx321_pos, -1, rx321_fail
    jump $I10
  rx321_done:
    rx321_cur."!cursor_fail"()
    if_null rx321_debug, debug_549
    rx321_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_549:
    .return (rx321_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("70_1299450589.65") :method
.annotate 'line', 4
    new $P323, "ResizablePMCArray"
    push $P323, "until"
    push $P323, "while"
    .return ($P323)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("71_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx330_tgt
    .local int rx330_pos
    .local int rx330_off
    .local int rx330_eos
    .local int rx330_rep
    .local pmc rx330_cur
    .local pmc rx330_debug
    (rx330_cur, rx330_pos, rx330_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx330_cur
    .local pmc match
    .lex "$/", match
    length rx330_eos, rx330_tgt
    gt rx330_pos, rx330_eos, rx330_done
    set rx330_off, 0
    lt rx330_pos, 2, rx330_start
    sub rx330_off, rx330_pos, 1
    substr rx330_tgt, rx330_tgt, rx330_off
  rx330_start:
    eq $I10, 1, rx330_restart
    if_null rx330_debug, debug_550
    rx330_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_550:
    $I10 = self.'from'()
    ne $I10, -1, rxscan333_done
    goto rxscan333_scan
  rxscan333_loop:
    (rx330_pos) = rx330_cur."from"()
    inc rx330_pos
    rx330_cur."!cursor_from"(rx330_pos)
    ge rx330_pos, rx330_eos, rxscan333_done
  rxscan333_scan:
    set_addr $I10, rxscan333_loop
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  rxscan333_done:
.annotate 'line', 199
  # rx subcapture "sym"
    set_addr $I10, rxcap_334_fail
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx330_pos, 6
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 6
    ne $S10, "repeat", rx330_fail
    add rx330_pos, 6
    set_addr $I10, rxcap_334_fail
    ($I12, $I11) = rx330_cur."!mark_peek"($I10)
    rx330_cur."!cursor_pos"($I11)
    ($P10) = rx330_cur."!cursor_start"()
    $P10."!cursor_pass"(rx330_pos, "")
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_334_done
  rxcap_334_fail:
    goto rx330_fail
  rxcap_334_done:
  # rx charclass s
    ge rx330_pos, rx330_eos, rx330_fail
    sub $I10, rx330_pos, rx330_off
    is_cclass $I11, 32, rx330_tgt, $I10
    unless $I11, rx330_fail
    inc rx330_pos
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  alt336_0:
.annotate 'line', 200
    set_addr $I10, alt336_1
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
.annotate 'line', 201
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_339_fail
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  alt338_0:
    set_addr $I10, alt338_1
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  # rx literal  "while"
    add $I11, rx330_pos, 5
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 5
    ne $S10, "while", rx330_fail
    add rx330_pos, 5
    goto alt338_end
  alt338_1:
  # rx literal  "until"
    add $I11, rx330_pos, 5
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 5
    ne $S10, "until", rx330_fail
    add rx330_pos, 5
  alt338_end:
    set_addr $I10, rxcap_339_fail
    ($I12, $I11) = rx330_cur."!mark_peek"($I10)
    rx330_cur."!cursor_pos"($I11)
    ($P10) = rx330_cur."!cursor_start"()
    $P10."!cursor_pass"(rx330_pos, "")
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_339_done
  rxcap_339_fail:
    goto rx330_fail
  rxcap_339_done:
  # rx charclass s
    ge rx330_pos, rx330_eos, rx330_fail
    sub $I10, rx330_pos, rx330_off
    is_cclass $I11, 32, rx330_tgt, $I10
    unless $I11, rx330_fail
    inc rx330_pos
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."xblock"()
    unless $P10, rx330_fail
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx330_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
    goto alt336_end
  alt336_1:
.annotate 'line', 202
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."pblock"()
    unless $P10, rx330_fail
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx330_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_345_fail
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  alt344_0:
    set_addr $I10, alt344_1
    rx330_cur."!mark_push"(0, rx330_pos, $I10)
  # rx literal  "while"
    add $I11, rx330_pos, 5
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 5
    ne $S10, "while", rx330_fail
    add rx330_pos, 5
    goto alt344_end
  alt344_1:
  # rx literal  "until"
    add $I11, rx330_pos, 5
    gt $I11, rx330_eos, rx330_fail
    sub $I11, rx330_pos, rx330_off
    substr $S10, rx330_tgt, $I11, 5
    ne $S10, "until", rx330_fail
    add rx330_pos, 5
  alt344_end:
    set_addr $I10, rxcap_345_fail
    ($I12, $I11) = rx330_cur."!mark_peek"($I10)
    rx330_cur."!cursor_pos"($I11)
    ($P10) = rx330_cur."!cursor_start"()
    $P10."!cursor_pass"(rx330_pos, "")
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_345_done
  rxcap_345_fail:
    goto rx330_fail
  rxcap_345_done:
  # rx charclass s
    ge rx330_pos, rx330_eos, rx330_fail
    sub $I10, rx330_pos, rx330_off
    is_cclass $I11, 32, rx330_tgt, $I10
    unless $I11, rx330_fail
    inc rx330_pos
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."EXPR"()
    unless $P10, rx330_fail
    rx330_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx330_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
  alt336_end:
.annotate 'line', 203
  # rx subrule "ws" subtype=method negate=
    rx330_cur."!cursor_pos"(rx330_pos)
    $P10 = rx330_cur."ws"()
    unless $P10, rx330_fail
    rx330_pos = $P10."pos"()
.annotate 'line', 198
  # rx pass
    rx330_cur."!cursor_pass"(rx330_pos, "statement_control:sym<repeat>")
    if_null rx330_debug, debug_551
    rx330_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx330_pos)
  debug_551:
    .return (rx330_cur)
  rx330_restart:
.annotate 'line', 4
    if_null rx330_debug, debug_552
    rx330_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_552:
  rx330_fail:
    (rx330_rep, rx330_pos, $I10, $P10) = rx330_cur."!mark_fail"(0)
    lt rx330_pos, -1, rx330_done
    eq rx330_pos, -1, rx330_fail
    jump $I10
  rx330_done:
    rx330_cur."!cursor_fail"()
    if_null rx330_debug, debug_553
    rx330_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_553:
    .return (rx330_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("72_1299450589.65") :method
.annotate 'line', 4
    new $P332, "ResizablePMCArray"
    push $P332, "repeat"
    .return ($P332)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("73_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx350_tgt
    .local int rx350_pos
    .local int rx350_off
    .local int rx350_eos
    .local int rx350_rep
    .local pmc rx350_cur
    .local pmc rx350_debug
    (rx350_cur, rx350_pos, rx350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx350_cur
    .local pmc match
    .lex "$/", match
    length rx350_eos, rx350_tgt
    gt rx350_pos, rx350_eos, rx350_done
    set rx350_off, 0
    lt rx350_pos, 2, rx350_start
    sub rx350_off, rx350_pos, 1
    substr rx350_tgt, rx350_tgt, rx350_off
  rx350_start:
    eq $I10, 1, rx350_restart
    if_null rx350_debug, debug_554
    rx350_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_554:
    $I10 = self.'from'()
    ne $I10, -1, rxscan353_done
    goto rxscan353_scan
  rxscan353_loop:
    (rx350_pos) = rx350_cur."from"()
    inc rx350_pos
    rx350_cur."!cursor_from"(rx350_pos)
    ge rx350_pos, rx350_eos, rxscan353_done
  rxscan353_scan:
    set_addr $I10, rxscan353_loop
    rx350_cur."!mark_push"(0, rx350_pos, $I10)
  rxscan353_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_354_fail
    rx350_cur."!mark_push"(0, rx350_pos, $I10)
  # rx literal  "for"
    add $I11, rx350_pos, 3
    gt $I11, rx350_eos, rx350_fail
    sub $I11, rx350_pos, rx350_off
    substr $S10, rx350_tgt, $I11, 3
    ne $S10, "for", rx350_fail
    add rx350_pos, 3
    set_addr $I10, rxcap_354_fail
    ($I12, $I11) = rx350_cur."!mark_peek"($I10)
    rx350_cur."!cursor_pos"($I11)
    ($P10) = rx350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx350_pos, "")
    rx350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_354_done
  rxcap_354_fail:
    goto rx350_fail
  rxcap_354_done:
  # rx charclass s
    ge rx350_pos, rx350_eos, rx350_fail
    sub $I10, rx350_pos, rx350_off
    is_cclass $I11, 32, rx350_tgt, $I10
    unless $I11, rx350_fail
    inc rx350_pos
  # rx subrule "ws" subtype=method negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."ws"()
    unless $P10, rx350_fail
    rx350_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "xblock" subtype=capture negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."xblock"()
    unless $P10, rx350_fail
    rx350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx350_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx350_cur."!cursor_pos"(rx350_pos)
    $P10 = rx350_cur."ws"()
    unless $P10, rx350_fail
    rx350_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx350_cur."!cursor_pass"(rx350_pos, "statement_control:sym<for>")
    if_null rx350_debug, debug_555
    rx350_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx350_pos)
  debug_555:
    .return (rx350_cur)
  rx350_restart:
.annotate 'line', 4
    if_null rx350_debug, debug_556
    rx350_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_556:
  rx350_fail:
    (rx350_rep, rx350_pos, $I10, $P10) = rx350_cur."!mark_fail"(0)
    lt rx350_pos, -1, rx350_done
    eq rx350_pos, -1, rx350_fail
    jump $I10
  rx350_done:
    rx350_cur."!cursor_fail"()
    if_null rx350_debug, debug_557
    rx350_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_557:
    .return (rx350_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("74_1299450589.65") :method
.annotate 'line', 4
    new $P352, "ResizablePMCArray"
    push $P352, "for"
    .return ($P352)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("75_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx358_tgt
    .local int rx358_pos
    .local int rx358_off
    .local int rx358_eos
    .local int rx358_rep
    .local pmc rx358_cur
    .local pmc rx358_debug
    (rx358_cur, rx358_pos, rx358_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx358_cur
    .local pmc match
    .lex "$/", match
    length rx358_eos, rx358_tgt
    gt rx358_pos, rx358_eos, rx358_done
    set rx358_off, 0
    lt rx358_pos, 2, rx358_start
    sub rx358_off, rx358_pos, 1
    substr rx358_tgt, rx358_tgt, rx358_off
  rx358_start:
    eq $I10, 1, rx358_restart
    if_null rx358_debug, debug_558
    rx358_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_558:
    $I10 = self.'from'()
    ne $I10, -1, rxscan361_done
    goto rxscan361_scan
  rxscan361_loop:
    (rx358_pos) = rx358_cur."from"()
    inc rx358_pos
    rx358_cur."!cursor_from"(rx358_pos)
    ge rx358_pos, rx358_eos, rxscan361_done
  rxscan361_scan:
    set_addr $I10, rxscan361_loop
    rx358_cur."!mark_push"(0, rx358_pos, $I10)
  rxscan361_done:
.annotate 'line', 212
  # rx subcapture "sym"
    set_addr $I10, rxcap_362_fail
    rx358_cur."!mark_push"(0, rx358_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx358_pos, 5
    gt $I11, rx358_eos, rx358_fail
    sub $I11, rx358_pos, rx358_off
    substr $S10, rx358_tgt, $I11, 5
    ne $S10, "CATCH", rx358_fail
    add rx358_pos, 5
    set_addr $I10, rxcap_362_fail
    ($I12, $I11) = rx358_cur."!mark_peek"($I10)
    rx358_cur."!cursor_pos"($I11)
    ($P10) = rx358_cur."!cursor_start"()
    $P10."!cursor_pass"(rx358_pos, "")
    rx358_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_362_done
  rxcap_362_fail:
    goto rx358_fail
  rxcap_362_done:
  # rx charclass s
    ge rx358_pos, rx358_eos, rx358_fail
    sub $I10, rx358_pos, rx358_off
    is_cclass $I11, 32, rx358_tgt, $I10
    unless $I11, rx358_fail
    inc rx358_pos
  # rx subrule "ws" subtype=method negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."ws"()
    unless $P10, rx358_fail
    rx358_pos = $P10."pos"()
.annotate 'line', 213
  # rx subrule "block" subtype=capture negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."block"()
    unless $P10, rx358_fail
    rx358_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx358_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx358_cur."!cursor_pos"(rx358_pos)
    $P10 = rx358_cur."ws"()
    unless $P10, rx358_fail
    rx358_pos = $P10."pos"()
.annotate 'line', 211
  # rx pass
    rx358_cur."!cursor_pass"(rx358_pos, "statement_control:sym<CATCH>")
    if_null rx358_debug, debug_559
    rx358_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx358_pos)
  debug_559:
    .return (rx358_cur)
  rx358_restart:
.annotate 'line', 4
    if_null rx358_debug, debug_560
    rx358_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_560:
  rx358_fail:
    (rx358_rep, rx358_pos, $I10, $P10) = rx358_cur."!mark_fail"(0)
    lt rx358_pos, -1, rx358_done
    eq rx358_pos, -1, rx358_fail
    jump $I10
  rx358_done:
    rx358_cur."!cursor_fail"()
    if_null rx358_debug, debug_561
    rx358_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_561:
    .return (rx358_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("76_1299450589.65") :method
.annotate 'line', 4
    new $P360, "ResizablePMCArray"
    push $P360, "CATCH"
    .return ($P360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("77_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx366_tgt
    .local int rx366_pos
    .local int rx366_off
    .local int rx366_eos
    .local int rx366_rep
    .local pmc rx366_cur
    .local pmc rx366_debug
    (rx366_cur, rx366_pos, rx366_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx366_cur
    .local pmc match
    .lex "$/", match
    length rx366_eos, rx366_tgt
    gt rx366_pos, rx366_eos, rx366_done
    set rx366_off, 0
    lt rx366_pos, 2, rx366_start
    sub rx366_off, rx366_pos, 1
    substr rx366_tgt, rx366_tgt, rx366_off
  rx366_start:
    eq $I10, 1, rx366_restart
    if_null rx366_debug, debug_562
    rx366_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_562:
    $I10 = self.'from'()
    ne $I10, -1, rxscan369_done
    goto rxscan369_scan
  rxscan369_loop:
    (rx366_pos) = rx366_cur."from"()
    inc rx366_pos
    rx366_cur."!cursor_from"(rx366_pos)
    ge rx366_pos, rx366_eos, rxscan369_done
  rxscan369_scan:
    set_addr $I10, rxscan369_loop
    rx366_cur."!mark_push"(0, rx366_pos, $I10)
  rxscan369_done:
.annotate 'line', 217
  # rx subcapture "sym"
    set_addr $I10, rxcap_370_fail
    rx366_cur."!mark_push"(0, rx366_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx366_pos, 7
    gt $I11, rx366_eos, rx366_fail
    sub $I11, rx366_pos, rx366_off
    substr $S10, rx366_tgt, $I11, 7
    ne $S10, "CONTROL", rx366_fail
    add rx366_pos, 7
    set_addr $I10, rxcap_370_fail
    ($I12, $I11) = rx366_cur."!mark_peek"($I10)
    rx366_cur."!cursor_pos"($I11)
    ($P10) = rx366_cur."!cursor_start"()
    $P10."!cursor_pass"(rx366_pos, "")
    rx366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_370_done
  rxcap_370_fail:
    goto rx366_fail
  rxcap_370_done:
  # rx charclass s
    ge rx366_pos, rx366_eos, rx366_fail
    sub $I10, rx366_pos, rx366_off
    is_cclass $I11, 32, rx366_tgt, $I10
    unless $I11, rx366_fail
    inc rx366_pos
  # rx subrule "ws" subtype=method negate=
    rx366_cur."!cursor_pos"(rx366_pos)
    $P10 = rx366_cur."ws"()
    unless $P10, rx366_fail
    rx366_pos = $P10."pos"()
.annotate 'line', 218
  # rx subrule "block" subtype=capture negate=
    rx366_cur."!cursor_pos"(rx366_pos)
    $P10 = rx366_cur."block"()
    unless $P10, rx366_fail
    rx366_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx366_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx366_cur."!cursor_pos"(rx366_pos)
    $P10 = rx366_cur."ws"()
    unless $P10, rx366_fail
    rx366_pos = $P10."pos"()
.annotate 'line', 216
  # rx pass
    rx366_cur."!cursor_pass"(rx366_pos, "statement_control:sym<CONTROL>")
    if_null rx366_debug, debug_563
    rx366_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx366_pos)
  debug_563:
    .return (rx366_cur)
  rx366_restart:
.annotate 'line', 4
    if_null rx366_debug, debug_564
    rx366_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_564:
  rx366_fail:
    (rx366_rep, rx366_pos, $I10, $P10) = rx366_cur."!mark_fail"(0)
    lt rx366_pos, -1, rx366_done
    eq rx366_pos, -1, rx366_fail
    jump $I10
  rx366_done:
    rx366_cur."!cursor_fail"()
    if_null rx366_debug, debug_565
    rx366_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_565:
    .return (rx366_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("78_1299450589.65") :method
.annotate 'line', 4
    new $P368, "ResizablePMCArray"
    push $P368, "CONTROL"
    .return ($P368)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("79_1299450589.65")
    .param pmc param_374
.annotate 'line', 221
    .lex "self", param_374
    $P375 = param_374."!protoregex"("statement_prefix")
    .return ($P375)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("80_1299450589.65")
    .param pmc param_377
.annotate 'line', 221
    .lex "self", param_377
    $P378 = param_377."!PREFIX__!protoregex"("statement_prefix")
    .return ($P378)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("81_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx380_tgt
    .local int rx380_pos
    .local int rx380_off
    .local int rx380_eos
    .local int rx380_rep
    .local pmc rx380_cur
    .local pmc rx380_debug
    (rx380_cur, rx380_pos, rx380_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx380_cur
    .local pmc match
    .lex "$/", match
    length rx380_eos, rx380_tgt
    gt rx380_pos, rx380_eos, rx380_done
    set rx380_off, 0
    lt rx380_pos, 2, rx380_start
    sub rx380_off, rx380_pos, 1
    substr rx380_tgt, rx380_tgt, rx380_off
  rx380_start:
    eq $I10, 1, rx380_restart
    if_null rx380_debug, debug_566
    rx380_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_566:
    $I10 = self.'from'()
    ne $I10, -1, rxscan384_done
    goto rxscan384_scan
  rxscan384_loop:
    (rx380_pos) = rx380_cur."from"()
    inc rx380_pos
    rx380_cur."!cursor_from"(rx380_pos)
    ge rx380_pos, rx380_eos, rxscan384_done
  rxscan384_scan:
    set_addr $I10, rxscan384_loop
    rx380_cur."!mark_push"(0, rx380_pos, $I10)
  rxscan384_done:
.annotate 'line', 222
  # rx subcapture "sym"
    set_addr $I10, rxcap_385_fail
    rx380_cur."!mark_push"(0, rx380_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx380_pos, 4
    gt $I11, rx380_eos, rx380_fail
    sub $I11, rx380_pos, rx380_off
    substr $S10, rx380_tgt, $I11, 4
    ne $S10, "INIT", rx380_fail
    add rx380_pos, 4
    set_addr $I10, rxcap_385_fail
    ($I12, $I11) = rx380_cur."!mark_peek"($I10)
    rx380_cur."!cursor_pos"($I11)
    ($P10) = rx380_cur."!cursor_start"()
    $P10."!cursor_pass"(rx380_pos, "")
    rx380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_385_done
  rxcap_385_fail:
    goto rx380_fail
  rxcap_385_done:
  # rx subrule "blorst" subtype=capture negate=
    rx380_cur."!cursor_pos"(rx380_pos)
    $P10 = rx380_cur."blorst"()
    unless $P10, rx380_fail
    rx380_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx380_pos = $P10."pos"()
  # rx pass
    rx380_cur."!cursor_pass"(rx380_pos, "statement_prefix:sym<INIT>")
    if_null rx380_debug, debug_567
    rx380_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx380_pos)
  debug_567:
    .return (rx380_cur)
  rx380_restart:
.annotate 'line', 4
    if_null rx380_debug, debug_568
    rx380_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_568:
  rx380_fail:
    (rx380_rep, rx380_pos, $I10, $P10) = rx380_cur."!mark_fail"(0)
    lt rx380_pos, -1, rx380_done
    eq rx380_pos, -1, rx380_fail
    jump $I10
  rx380_done:
    rx380_cur."!cursor_fail"()
    if_null rx380_debug, debug_569
    rx380_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_569:
    .return (rx380_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("82_1299450589.65") :method
.annotate 'line', 4
    $P382 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P383, "ResizablePMCArray"
    push $P383, $P382
    .return ($P383)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("83_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx387_tgt
    .local int rx387_pos
    .local int rx387_off
    .local int rx387_eos
    .local int rx387_rep
    .local pmc rx387_cur
    .local pmc rx387_debug
    (rx387_cur, rx387_pos, rx387_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx387_cur
    .local pmc match
    .lex "$/", match
    length rx387_eos, rx387_tgt
    gt rx387_pos, rx387_eos, rx387_done
    set rx387_off, 0
    lt rx387_pos, 2, rx387_start
    sub rx387_off, rx387_pos, 1
    substr rx387_tgt, rx387_tgt, rx387_off
  rx387_start:
    eq $I10, 1, rx387_restart
    if_null rx387_debug, debug_570
    rx387_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_570:
    $I10 = self.'from'()
    ne $I10, -1, rxscan391_done
    goto rxscan391_scan
  rxscan391_loop:
    (rx387_pos) = rx387_cur."from"()
    inc rx387_pos
    rx387_cur."!cursor_from"(rx387_pos)
    ge rx387_pos, rx387_eos, rxscan391_done
  rxscan391_scan:
    set_addr $I10, rxscan391_loop
    rx387_cur."!mark_push"(0, rx387_pos, $I10)
  rxscan391_done:
.annotate 'line', 225
  # rx subcapture "sym"
    set_addr $I10, rxcap_392_fail
    rx387_cur."!mark_push"(0, rx387_pos, $I10)
  # rx literal  "try"
    add $I11, rx387_pos, 3
    gt $I11, rx387_eos, rx387_fail
    sub $I11, rx387_pos, rx387_off
    substr $S10, rx387_tgt, $I11, 3
    ne $S10, "try", rx387_fail
    add rx387_pos, 3
    set_addr $I10, rxcap_392_fail
    ($I12, $I11) = rx387_cur."!mark_peek"($I10)
    rx387_cur."!cursor_pos"($I11)
    ($P10) = rx387_cur."!cursor_start"()
    $P10."!cursor_pass"(rx387_pos, "")
    rx387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_392_done
  rxcap_392_fail:
    goto rx387_fail
  rxcap_392_done:
.annotate 'line', 226
  # rx subrule "blorst" subtype=capture negate=
    rx387_cur."!cursor_pos"(rx387_pos)
    $P10 = rx387_cur."blorst"()
    unless $P10, rx387_fail
    rx387_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx387_pos = $P10."pos"()
.annotate 'line', 224
  # rx pass
    rx387_cur."!cursor_pass"(rx387_pos, "statement_prefix:sym<try>")
    if_null rx387_debug, debug_571
    rx387_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx387_pos)
  debug_571:
    .return (rx387_cur)
  rx387_restart:
.annotate 'line', 4
    if_null rx387_debug, debug_572
    rx387_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_572:
  rx387_fail:
    (rx387_rep, rx387_pos, $I10, $P10) = rx387_cur."!mark_fail"(0)
    lt rx387_pos, -1, rx387_done
    eq rx387_pos, -1, rx387_fail
    jump $I10
  rx387_done:
    rx387_cur."!cursor_fail"()
    if_null rx387_debug, debug_573
    rx387_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_573:
    .return (rx387_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("84_1299450589.65") :method
.annotate 'line', 4
    $P389 = self."!PREFIX__!subrule"("blorst", "try")
    new $P390, "ResizablePMCArray"
    push $P390, $P389
    .return ($P390)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("85_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx394_tgt
    .local int rx394_pos
    .local int rx394_off
    .local int rx394_eos
    .local int rx394_rep
    .local pmc rx394_cur
    .local pmc rx394_debug
    (rx394_cur, rx394_pos, rx394_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx394_cur
    .local pmc match
    .lex "$/", match
    length rx394_eos, rx394_tgt
    gt rx394_pos, rx394_eos, rx394_done
    set rx394_off, 0
    lt rx394_pos, 2, rx394_start
    sub rx394_off, rx394_pos, 1
    substr rx394_tgt, rx394_tgt, rx394_off
  rx394_start:
    eq $I10, 1, rx394_restart
    if_null rx394_debug, debug_574
    rx394_cur."!cursor_debug"("START", "blorst")
  debug_574:
    $I10 = self.'from'()
    ne $I10, -1, rxscan397_done
    goto rxscan397_scan
  rxscan397_loop:
    (rx394_pos) = rx394_cur."from"()
    inc rx394_pos
    rx394_cur."!cursor_from"(rx394_pos)
    ge rx394_pos, rx394_eos, rxscan397_done
  rxscan397_scan:
    set_addr $I10, rxscan397_loop
    rx394_cur."!mark_push"(0, rx394_pos, $I10)
  rxscan397_done:
.annotate 'line', 230
  # rx charclass s
    ge rx394_pos, rx394_eos, rx394_fail
    sub $I10, rx394_pos, rx394_off
    is_cclass $I11, 32, rx394_tgt, $I10
    unless $I11, rx394_fail
    inc rx394_pos
  # rx subrule "ws" subtype=method negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."ws"()
    unless $P10, rx394_fail
    rx394_pos = $P10."pos"()
  alt398_0:
    set_addr $I10, alt398_1
    rx394_cur."!mark_push"(0, rx394_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx394_pos, rx394_off
    substr $S10, rx394_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx394_fail
  # rx subrule "block" subtype=capture negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."block"()
    unless $P10, rx394_fail
    rx394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx394_pos = $P10."pos"()
    goto alt398_end
  alt398_1:
  # rx subrule "statement" subtype=capture negate=
    rx394_cur."!cursor_pos"(rx394_pos)
    $P10 = rx394_cur."statement"()
    unless $P10, rx394_fail
    rx394_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx394_pos = $P10."pos"()
  alt398_end:
.annotate 'line', 229
  # rx pass
    rx394_cur."!cursor_pass"(rx394_pos, "blorst")
    if_null rx394_debug, debug_575
    rx394_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx394_pos)
  debug_575:
    .return (rx394_cur)
  rx394_restart:
.annotate 'line', 4
    if_null rx394_debug, debug_576
    rx394_cur."!cursor_debug"("NEXT", "blorst")
  debug_576:
  rx394_fail:
    (rx394_rep, rx394_pos, $I10, $P10) = rx394_cur."!mark_fail"(0)
    lt rx394_pos, -1, rx394_done
    eq rx394_pos, -1, rx394_fail
    jump $I10
  rx394_done:
    rx394_cur."!cursor_fail"()
    if_null rx394_debug, debug_577
    rx394_cur."!cursor_debug"("FAIL", "blorst")
  debug_577:
    .return (rx394_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("86_1299450589.65") :method
.annotate 'line', 4
    new $P396, "ResizablePMCArray"
    push $P396, ""
    .return ($P396)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("87_1299450589.65")
    .param pmc param_400
.annotate 'line', 235
    .lex "self", param_400
    $P401 = param_400."!protoregex"("statement_mod_cond")
    .return ($P401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("88_1299450589.65")
    .param pmc param_403
.annotate 'line', 235
    .lex "self", param_403
    $P404 = param_403."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P404)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("89_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx406_tgt
    .local int rx406_pos
    .local int rx406_off
    .local int rx406_eos
    .local int rx406_rep
    .local pmc rx406_cur
    .local pmc rx406_debug
    (rx406_cur, rx406_pos, rx406_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx406_cur
    .local pmc match
    .lex "$/", match
    length rx406_eos, rx406_tgt
    gt rx406_pos, rx406_eos, rx406_done
    set rx406_off, 0
    lt rx406_pos, 2, rx406_start
    sub rx406_off, rx406_pos, 1
    substr rx406_tgt, rx406_tgt, rx406_off
  rx406_start:
    eq $I10, 1, rx406_restart
    if_null rx406_debug, debug_578
    rx406_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_578:
    $I10 = self.'from'()
    ne $I10, -1, rxscan410_done
    goto rxscan410_scan
  rxscan410_loop:
    (rx406_pos) = rx406_cur."from"()
    inc rx406_pos
    rx406_cur."!cursor_from"(rx406_pos)
    ge rx406_pos, rx406_eos, rxscan410_done
  rxscan410_scan:
    set_addr $I10, rxscan410_loop
    rx406_cur."!mark_push"(0, rx406_pos, $I10)
  rxscan410_done:
.annotate 'line', 237
  # rx subcapture "sym"
    set_addr $I10, rxcap_411_fail
    rx406_cur."!mark_push"(0, rx406_pos, $I10)
  # rx literal  "if"
    add $I11, rx406_pos, 2
    gt $I11, rx406_eos, rx406_fail
    sub $I11, rx406_pos, rx406_off
    substr $S10, rx406_tgt, $I11, 2
    ne $S10, "if", rx406_fail
    add rx406_pos, 2
    set_addr $I10, rxcap_411_fail
    ($I12, $I11) = rx406_cur."!mark_peek"($I10)
    rx406_cur."!cursor_pos"($I11)
    ($P10) = rx406_cur."!cursor_start"()
    $P10."!cursor_pass"(rx406_pos, "")
    rx406_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_411_done
  rxcap_411_fail:
    goto rx406_fail
  rxcap_411_done:
  # rx subrule "ws" subtype=method negate=
    rx406_cur."!cursor_pos"(rx406_pos)
    $P10 = rx406_cur."ws"()
    unless $P10, rx406_fail
    rx406_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx406_cur."!cursor_pos"(rx406_pos)
    $P10 = rx406_cur."EXPR"()
    unless $P10, rx406_fail
    rx406_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx406_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx406_cur."!cursor_pos"(rx406_pos)
    $P10 = rx406_cur."ws"()
    unless $P10, rx406_fail
    rx406_pos = $P10."pos"()
  # rx pass
    rx406_cur."!cursor_pass"(rx406_pos, "statement_mod_cond:sym<if>")
    if_null rx406_debug, debug_579
    rx406_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx406_pos)
  debug_579:
    .return (rx406_cur)
  rx406_restart:
.annotate 'line', 4
    if_null rx406_debug, debug_580
    rx406_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_580:
  rx406_fail:
    (rx406_rep, rx406_pos, $I10, $P10) = rx406_cur."!mark_fail"(0)
    lt rx406_pos, -1, rx406_done
    eq rx406_pos, -1, rx406_fail
    jump $I10
  rx406_done:
    rx406_cur."!cursor_fail"()
    if_null rx406_debug, debug_581
    rx406_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_581:
    .return (rx406_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("90_1299450589.65") :method
.annotate 'line', 4
    $P408 = self."!PREFIX__!subrule"("ws", "if")
    new $P409, "ResizablePMCArray"
    push $P409, $P408
    .return ($P409)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("91_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx415_tgt
    .local int rx415_pos
    .local int rx415_off
    .local int rx415_eos
    .local int rx415_rep
    .local pmc rx415_cur
    .local pmc rx415_debug
    (rx415_cur, rx415_pos, rx415_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx415_cur
    .local pmc match
    .lex "$/", match
    length rx415_eos, rx415_tgt
    gt rx415_pos, rx415_eos, rx415_done
    set rx415_off, 0
    lt rx415_pos, 2, rx415_start
    sub rx415_off, rx415_pos, 1
    substr rx415_tgt, rx415_tgt, rx415_off
  rx415_start:
    eq $I10, 1, rx415_restart
    if_null rx415_debug, debug_582
    rx415_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_582:
    $I10 = self.'from'()
    ne $I10, -1, rxscan419_done
    goto rxscan419_scan
  rxscan419_loop:
    (rx415_pos) = rx415_cur."from"()
    inc rx415_pos
    rx415_cur."!cursor_from"(rx415_pos)
    ge rx415_pos, rx415_eos, rxscan419_done
  rxscan419_scan:
    set_addr $I10, rxscan419_loop
    rx415_cur."!mark_push"(0, rx415_pos, $I10)
  rxscan419_done:
.annotate 'line', 238
  # rx subcapture "sym"
    set_addr $I10, rxcap_420_fail
    rx415_cur."!mark_push"(0, rx415_pos, $I10)
  # rx literal  "unless"
    add $I11, rx415_pos, 6
    gt $I11, rx415_eos, rx415_fail
    sub $I11, rx415_pos, rx415_off
    substr $S10, rx415_tgt, $I11, 6
    ne $S10, "unless", rx415_fail
    add rx415_pos, 6
    set_addr $I10, rxcap_420_fail
    ($I12, $I11) = rx415_cur."!mark_peek"($I10)
    rx415_cur."!cursor_pos"($I11)
    ($P10) = rx415_cur."!cursor_start"()
    $P10."!cursor_pass"(rx415_pos, "")
    rx415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_420_done
  rxcap_420_fail:
    goto rx415_fail
  rxcap_420_done:
  # rx subrule "ws" subtype=method negate=
    rx415_cur."!cursor_pos"(rx415_pos)
    $P10 = rx415_cur."ws"()
    unless $P10, rx415_fail
    rx415_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx415_cur."!cursor_pos"(rx415_pos)
    $P10 = rx415_cur."EXPR"()
    unless $P10, rx415_fail
    rx415_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx415_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx415_cur."!cursor_pos"(rx415_pos)
    $P10 = rx415_cur."ws"()
    unless $P10, rx415_fail
    rx415_pos = $P10."pos"()
  # rx pass
    rx415_cur."!cursor_pass"(rx415_pos, "statement_mod_cond:sym<unless>")
    if_null rx415_debug, debug_583
    rx415_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx415_pos)
  debug_583:
    .return (rx415_cur)
  rx415_restart:
.annotate 'line', 4
    if_null rx415_debug, debug_584
    rx415_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_584:
  rx415_fail:
    (rx415_rep, rx415_pos, $I10, $P10) = rx415_cur."!mark_fail"(0)
    lt rx415_pos, -1, rx415_done
    eq rx415_pos, -1, rx415_fail
    jump $I10
  rx415_done:
    rx415_cur."!cursor_fail"()
    if_null rx415_debug, debug_585
    rx415_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_585:
    .return (rx415_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("92_1299450589.65") :method
.annotate 'line', 4
    $P417 = self."!PREFIX__!subrule"("ws", "unless")
    new $P418, "ResizablePMCArray"
    push $P418, $P417
    .return ($P418)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("93_1299450589.65")
    .param pmc param_424
.annotate 'line', 240
    .lex "self", param_424
    $P425 = param_424."!protoregex"("statement_mod_loop")
    .return ($P425)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("94_1299450589.65")
    .param pmc param_427
.annotate 'line', 240
    .lex "self", param_427
    $P428 = param_427."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P428)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("95_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx430_tgt
    .local int rx430_pos
    .local int rx430_off
    .local int rx430_eos
    .local int rx430_rep
    .local pmc rx430_cur
    .local pmc rx430_debug
    (rx430_cur, rx430_pos, rx430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx430_cur
    .local pmc match
    .lex "$/", match
    length rx430_eos, rx430_tgt
    gt rx430_pos, rx430_eos, rx430_done
    set rx430_off, 0
    lt rx430_pos, 2, rx430_start
    sub rx430_off, rx430_pos, 1
    substr rx430_tgt, rx430_tgt, rx430_off
  rx430_start:
    eq $I10, 1, rx430_restart
    if_null rx430_debug, debug_586
    rx430_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_586:
    $I10 = self.'from'()
    ne $I10, -1, rxscan434_done
    goto rxscan434_scan
  rxscan434_loop:
    (rx430_pos) = rx430_cur."from"()
    inc rx430_pos
    rx430_cur."!cursor_from"(rx430_pos)
    ge rx430_pos, rx430_eos, rxscan434_done
  rxscan434_scan:
    set_addr $I10, rxscan434_loop
    rx430_cur."!mark_push"(0, rx430_pos, $I10)
  rxscan434_done:
.annotate 'line', 242
  # rx subcapture "sym"
    set_addr $I10, rxcap_435_fail
    rx430_cur."!mark_push"(0, rx430_pos, $I10)
  # rx literal  "while"
    add $I11, rx430_pos, 5
    gt $I11, rx430_eos, rx430_fail
    sub $I11, rx430_pos, rx430_off
    substr $S10, rx430_tgt, $I11, 5
    ne $S10, "while", rx430_fail
    add rx430_pos, 5
    set_addr $I10, rxcap_435_fail
    ($I12, $I11) = rx430_cur."!mark_peek"($I10)
    rx430_cur."!cursor_pos"($I11)
    ($P10) = rx430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx430_pos, "")
    rx430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_435_done
  rxcap_435_fail:
    goto rx430_fail
  rxcap_435_done:
  # rx subrule "ws" subtype=method negate=
    rx430_cur."!cursor_pos"(rx430_pos)
    $P10 = rx430_cur."ws"()
    unless $P10, rx430_fail
    rx430_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx430_cur."!cursor_pos"(rx430_pos)
    $P10 = rx430_cur."EXPR"()
    unless $P10, rx430_fail
    rx430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx430_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx430_cur."!cursor_pos"(rx430_pos)
    $P10 = rx430_cur."ws"()
    unless $P10, rx430_fail
    rx430_pos = $P10."pos"()
  # rx pass
    rx430_cur."!cursor_pass"(rx430_pos, "statement_mod_loop:sym<while>")
    if_null rx430_debug, debug_587
    rx430_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx430_pos)
  debug_587:
    .return (rx430_cur)
  rx430_restart:
.annotate 'line', 4
    if_null rx430_debug, debug_588
    rx430_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_588:
  rx430_fail:
    (rx430_rep, rx430_pos, $I10, $P10) = rx430_cur."!mark_fail"(0)
    lt rx430_pos, -1, rx430_done
    eq rx430_pos, -1, rx430_fail
    jump $I10
  rx430_done:
    rx430_cur."!cursor_fail"()
    if_null rx430_debug, debug_589
    rx430_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_589:
    .return (rx430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("96_1299450589.65") :method
.annotate 'line', 4
    $P432 = self."!PREFIX__!subrule"("ws", "while")
    new $P433, "ResizablePMCArray"
    push $P433, $P432
    .return ($P433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("97_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx439_tgt
    .local int rx439_pos
    .local int rx439_off
    .local int rx439_eos
    .local int rx439_rep
    .local pmc rx439_cur
    .local pmc rx439_debug
    (rx439_cur, rx439_pos, rx439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx439_cur
    .local pmc match
    .lex "$/", match
    length rx439_eos, rx439_tgt
    gt rx439_pos, rx439_eos, rx439_done
    set rx439_off, 0
    lt rx439_pos, 2, rx439_start
    sub rx439_off, rx439_pos, 1
    substr rx439_tgt, rx439_tgt, rx439_off
  rx439_start:
    eq $I10, 1, rx439_restart
    if_null rx439_debug, debug_590
    rx439_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_590:
    $I10 = self.'from'()
    ne $I10, -1, rxscan443_done
    goto rxscan443_scan
  rxscan443_loop:
    (rx439_pos) = rx439_cur."from"()
    inc rx439_pos
    rx439_cur."!cursor_from"(rx439_pos)
    ge rx439_pos, rx439_eos, rxscan443_done
  rxscan443_scan:
    set_addr $I10, rxscan443_loop
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  rxscan443_done:
.annotate 'line', 243
  # rx subcapture "sym"
    set_addr $I10, rxcap_444_fail
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  # rx literal  "until"
    add $I11, rx439_pos, 5
    gt $I11, rx439_eos, rx439_fail
    sub $I11, rx439_pos, rx439_off
    substr $S10, rx439_tgt, $I11, 5
    ne $S10, "until", rx439_fail
    add rx439_pos, 5
    set_addr $I10, rxcap_444_fail
    ($I12, $I11) = rx439_cur."!mark_peek"($I10)
    rx439_cur."!cursor_pos"($I11)
    ($P10) = rx439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx439_pos, "")
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_444_done
  rxcap_444_fail:
    goto rx439_fail
  rxcap_444_done:
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."EXPR"()
    unless $P10, rx439_fail
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx439_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx pass
    rx439_cur."!cursor_pass"(rx439_pos, "statement_mod_loop:sym<until>")
    if_null rx439_debug, debug_591
    rx439_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx439_pos)
  debug_591:
    .return (rx439_cur)
  rx439_restart:
.annotate 'line', 4
    if_null rx439_debug, debug_592
    rx439_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_592:
  rx439_fail:
    (rx439_rep, rx439_pos, $I10, $P10) = rx439_cur."!mark_fail"(0)
    lt rx439_pos, -1, rx439_done
    eq rx439_pos, -1, rx439_fail
    jump $I10
  rx439_done:
    rx439_cur."!cursor_fail"()
    if_null rx439_debug, debug_593
    rx439_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_593:
    .return (rx439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("98_1299450589.65") :method
.annotate 'line', 4
    $P441 = self."!PREFIX__!subrule"("ws", "until")
    new $P442, "ResizablePMCArray"
    push $P442, $P441
    .return ($P442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("99_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx448_tgt
    .local int rx448_pos
    .local int rx448_off
    .local int rx448_eos
    .local int rx448_rep
    .local pmc rx448_cur
    .local pmc rx448_debug
    (rx448_cur, rx448_pos, rx448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx448_cur
    .local pmc match
    .lex "$/", match
    length rx448_eos, rx448_tgt
    gt rx448_pos, rx448_eos, rx448_done
    set rx448_off, 0
    lt rx448_pos, 2, rx448_start
    sub rx448_off, rx448_pos, 1
    substr rx448_tgt, rx448_tgt, rx448_off
  rx448_start:
    eq $I10, 1, rx448_restart
    if_null rx448_debug, debug_594
    rx448_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_594:
    $I10 = self.'from'()
    ne $I10, -1, rxscan452_done
    goto rxscan452_scan
  rxscan452_loop:
    (rx448_pos) = rx448_cur."from"()
    inc rx448_pos
    rx448_cur."!cursor_from"(rx448_pos)
    ge rx448_pos, rx448_eos, rxscan452_done
  rxscan452_scan:
    set_addr $I10, rxscan452_loop
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  rxscan452_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_453_fail
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  # rx literal  "for"
    add $I11, rx448_pos, 3
    gt $I11, rx448_eos, rx448_fail
    sub $I11, rx448_pos, rx448_off
    substr $S10, rx448_tgt, $I11, 3
    ne $S10, "for", rx448_fail
    add rx448_pos, 3
    set_addr $I10, rxcap_453_fail
    ($I12, $I11) = rx448_cur."!mark_peek"($I10)
    rx448_cur."!cursor_pos"($I11)
    ($P10) = rx448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx448_pos, "")
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_453_done
  rxcap_453_fail:
    goto rx448_fail
  rxcap_453_done:
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."EXPR"()
    unless $P10, rx448_fail
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx pass
    rx448_cur."!cursor_pass"(rx448_pos, "statement_mod_loop:sym<for>")
    if_null rx448_debug, debug_595
    rx448_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx448_pos)
  debug_595:
    .return (rx448_cur)
  rx448_restart:
.annotate 'line', 4
    if_null rx448_debug, debug_596
    rx448_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_596:
  rx448_fail:
    (rx448_rep, rx448_pos, $I10, $P10) = rx448_cur."!mark_fail"(0)
    lt rx448_pos, -1, rx448_done
    eq rx448_pos, -1, rx448_fail
    jump $I10
  rx448_done:
    rx448_cur."!cursor_fail"()
    if_null rx448_debug, debug_597
    rx448_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_597:
    .return (rx448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("100_1299450589.65") :method
.annotate 'line', 4
    $P450 = self."!PREFIX__!subrule"("ws", "for")
    new $P451, "ResizablePMCArray"
    push $P451, $P450
    .return ($P451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("101_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx457_tgt
    .local int rx457_pos
    .local int rx457_off
    .local int rx457_eos
    .local int rx457_rep
    .local pmc rx457_cur
    .local pmc rx457_debug
    (rx457_cur, rx457_pos, rx457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx457_cur
    .local pmc match
    .lex "$/", match
    length rx457_eos, rx457_tgt
    gt rx457_pos, rx457_eos, rx457_done
    set rx457_off, 0
    lt rx457_pos, 2, rx457_start
    sub rx457_off, rx457_pos, 1
    substr rx457_tgt, rx457_tgt, rx457_off
  rx457_start:
    eq $I10, 1, rx457_restart
    if_null rx457_debug, debug_598
    rx457_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_598:
    $I10 = self.'from'()
    ne $I10, -1, rxscan461_done
    goto rxscan461_scan
  rxscan461_loop:
    (rx457_pos) = rx457_cur."from"()
    inc rx457_pos
    rx457_cur."!cursor_from"(rx457_pos)
    ge rx457_pos, rx457_eos, rxscan461_done
  rxscan461_scan:
    set_addr $I10, rxscan461_loop
    rx457_cur."!mark_push"(0, rx457_pos, $I10)
  rxscan461_done:
.annotate 'line', 248
  # rx subrule "fatarrow" subtype=capture negate=
    rx457_cur."!cursor_pos"(rx457_pos)
    $P10 = rx457_cur."fatarrow"()
    unless $P10, rx457_fail
    rx457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx457_pos = $P10."pos"()
  # rx pass
    rx457_cur."!cursor_pass"(rx457_pos, "term:sym<fatarrow>")
    if_null rx457_debug, debug_599
    rx457_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx457_pos)
  debug_599:
    .return (rx457_cur)
  rx457_restart:
.annotate 'line', 4
    if_null rx457_debug, debug_600
    rx457_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_600:
  rx457_fail:
    (rx457_rep, rx457_pos, $I10, $P10) = rx457_cur."!mark_fail"(0)
    lt rx457_pos, -1, rx457_done
    eq rx457_pos, -1, rx457_fail
    jump $I10
  rx457_done:
    rx457_cur."!cursor_fail"()
    if_null rx457_debug, debug_601
    rx457_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_601:
    .return (rx457_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("102_1299450589.65") :method
.annotate 'line', 4
    $P459 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P460, "ResizablePMCArray"
    push $P460, $P459
    .return ($P460)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("103_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_602
    rx463_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan467_done
    goto rxscan467_scan
  rxscan467_loop:
    (rx463_pos) = rx463_cur."from"()
    inc rx463_pos
    rx463_cur."!cursor_from"(rx463_pos)
    ge rx463_pos, rx463_eos, rxscan467_done
  rxscan467_scan:
    set_addr $I10, rxscan467_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan467_done:
.annotate 'line', 249
  # rx subrule "colonpair" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."colonpair"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx463_pos = $P10."pos"()
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "term:sym<colonpair>")
    if_null rx463_debug, debug_603
    rx463_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx463_pos)
  debug_603:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 4
    if_null rx463_debug, debug_604
    rx463_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_604:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_605
    rx463_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_605:
    .return (rx463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("104_1299450589.65") :method
.annotate 'line', 4
    $P465 = self."!PREFIX__!subrule"("colonpair", "")
    new $P466, "ResizablePMCArray"
    push $P466, $P465
    .return ($P466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("105_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx469_tgt
    .local int rx469_pos
    .local int rx469_off
    .local int rx469_eos
    .local int rx469_rep
    .local pmc rx469_cur
    .local pmc rx469_debug
    (rx469_cur, rx469_pos, rx469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx469_cur
    .local pmc match
    .lex "$/", match
    length rx469_eos, rx469_tgt
    gt rx469_pos, rx469_eos, rx469_done
    set rx469_off, 0
    lt rx469_pos, 2, rx469_start
    sub rx469_off, rx469_pos, 1
    substr rx469_tgt, rx469_tgt, rx469_off
  rx469_start:
    eq $I10, 1, rx469_restart
    if_null rx469_debug, debug_606
    rx469_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan473_done
    goto rxscan473_scan
  rxscan473_loop:
    (rx469_pos) = rx469_cur."from"()
    inc rx469_pos
    rx469_cur."!cursor_from"(rx469_pos)
    ge rx469_pos, rx469_eos, rxscan473_done
  rxscan473_scan:
    set_addr $I10, rxscan473_loop
    rx469_cur."!mark_push"(0, rx469_pos, $I10)
  rxscan473_done:
.annotate 'line', 250
  # rx subrule "variable" subtype=capture negate=
    rx469_cur."!cursor_pos"(rx469_pos)
    $P10 = rx469_cur."variable"()
    unless $P10, rx469_fail
    rx469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx469_pos = $P10."pos"()
  # rx pass
    rx469_cur."!cursor_pass"(rx469_pos, "term:sym<variable>")
    if_null rx469_debug, debug_607
    rx469_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx469_pos)
  debug_607:
    .return (rx469_cur)
  rx469_restart:
.annotate 'line', 4
    if_null rx469_debug, debug_608
    rx469_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_608:
  rx469_fail:
    (rx469_rep, rx469_pos, $I10, $P10) = rx469_cur."!mark_fail"(0)
    lt rx469_pos, -1, rx469_done
    eq rx469_pos, -1, rx469_fail
    jump $I10
  rx469_done:
    rx469_cur."!cursor_fail"()
    if_null rx469_debug, debug_609
    rx469_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_609:
    .return (rx469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("106_1299450589.65") :method
.annotate 'line', 4
    $P471 = self."!PREFIX__!subrule"("variable", "")
    new $P472, "ResizablePMCArray"
    push $P472, $P471
    .return ($P472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("107_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx475_tgt
    .local int rx475_pos
    .local int rx475_off
    .local int rx475_eos
    .local int rx475_rep
    .local pmc rx475_cur
    .local pmc rx475_debug
    (rx475_cur, rx475_pos, rx475_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx475_cur
    .local pmc match
    .lex "$/", match
    length rx475_eos, rx475_tgt
    gt rx475_pos, rx475_eos, rx475_done
    set rx475_off, 0
    lt rx475_pos, 2, rx475_start
    sub rx475_off, rx475_pos, 1
    substr rx475_tgt, rx475_tgt, rx475_off
  rx475_start:
    eq $I10, 1, rx475_restart
    if_null rx475_debug, debug_610
    rx475_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan479_done
    goto rxscan479_scan
  rxscan479_loop:
    (rx475_pos) = rx475_cur."from"()
    inc rx475_pos
    rx475_cur."!cursor_from"(rx475_pos)
    ge rx475_pos, rx475_eos, rxscan479_done
  rxscan479_scan:
    set_addr $I10, rxscan479_loop
    rx475_cur."!mark_push"(0, rx475_pos, $I10)
  rxscan479_done:
.annotate 'line', 251
  # rx subrule "package_declarator" subtype=capture negate=
    rx475_cur."!cursor_pos"(rx475_pos)
    $P10 = rx475_cur."package_declarator"()
    unless $P10, rx475_fail
    rx475_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx475_pos = $P10."pos"()
  # rx pass
    rx475_cur."!cursor_pass"(rx475_pos, "term:sym<package_declarator>")
    if_null rx475_debug, debug_611
    rx475_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx475_pos)
  debug_611:
    .return (rx475_cur)
  rx475_restart:
.annotate 'line', 4
    if_null rx475_debug, debug_612
    rx475_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_612:
  rx475_fail:
    (rx475_rep, rx475_pos, $I10, $P10) = rx475_cur."!mark_fail"(0)
    lt rx475_pos, -1, rx475_done
    eq rx475_pos, -1, rx475_fail
    jump $I10
  rx475_done:
    rx475_cur."!cursor_fail"()
    if_null rx475_debug, debug_613
    rx475_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_613:
    .return (rx475_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("108_1299450589.65") :method
.annotate 'line', 4
    $P477 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P478, "ResizablePMCArray"
    push $P478, $P477
    .return ($P478)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("109_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx481_tgt
    .local int rx481_pos
    .local int rx481_off
    .local int rx481_eos
    .local int rx481_rep
    .local pmc rx481_cur
    .local pmc rx481_debug
    (rx481_cur, rx481_pos, rx481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx481_cur
    .local pmc match
    .lex "$/", match
    length rx481_eos, rx481_tgt
    gt rx481_pos, rx481_eos, rx481_done
    set rx481_off, 0
    lt rx481_pos, 2, rx481_start
    sub rx481_off, rx481_pos, 1
    substr rx481_tgt, rx481_tgt, rx481_off
  rx481_start:
    eq $I10, 1, rx481_restart
    if_null rx481_debug, debug_614
    rx481_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan485_done
    goto rxscan485_scan
  rxscan485_loop:
    (rx481_pos) = rx481_cur."from"()
    inc rx481_pos
    rx481_cur."!cursor_from"(rx481_pos)
    ge rx481_pos, rx481_eos, rxscan485_done
  rxscan485_scan:
    set_addr $I10, rxscan485_loop
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  rxscan485_done:
.annotate 'line', 252
  # rx subrule "scope_declarator" subtype=capture negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."scope_declarator"()
    unless $P10, rx481_fail
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx481_pos = $P10."pos"()
  # rx pass
    rx481_cur."!cursor_pass"(rx481_pos, "term:sym<scope_declarator>")
    if_null rx481_debug, debug_615
    rx481_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx481_pos)
  debug_615:
    .return (rx481_cur)
  rx481_restart:
.annotate 'line', 4
    if_null rx481_debug, debug_616
    rx481_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_616:
  rx481_fail:
    (rx481_rep, rx481_pos, $I10, $P10) = rx481_cur."!mark_fail"(0)
    lt rx481_pos, -1, rx481_done
    eq rx481_pos, -1, rx481_fail
    jump $I10
  rx481_done:
    rx481_cur."!cursor_fail"()
    if_null rx481_debug, debug_617
    rx481_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_617:
    .return (rx481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("110_1299450589.65") :method
.annotate 'line', 4
    $P483 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P484, "ResizablePMCArray"
    push $P484, $P483
    .return ($P484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("111_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx487_tgt
    .local int rx487_pos
    .local int rx487_off
    .local int rx487_eos
    .local int rx487_rep
    .local pmc rx487_cur
    .local pmc rx487_debug
    (rx487_cur, rx487_pos, rx487_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx487_cur
    .local pmc match
    .lex "$/", match
    length rx487_eos, rx487_tgt
    gt rx487_pos, rx487_eos, rx487_done
    set rx487_off, 0
    lt rx487_pos, 2, rx487_start
    sub rx487_off, rx487_pos, 1
    substr rx487_tgt, rx487_tgt, rx487_off
  rx487_start:
    eq $I10, 1, rx487_restart
    if_null rx487_debug, debug_618
    rx487_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan491_done
    goto rxscan491_scan
  rxscan491_loop:
    (rx487_pos) = rx487_cur."from"()
    inc rx487_pos
    rx487_cur."!cursor_from"(rx487_pos)
    ge rx487_pos, rx487_eos, rxscan491_done
  rxscan491_scan:
    set_addr $I10, rxscan491_loop
    rx487_cur."!mark_push"(0, rx487_pos, $I10)
  rxscan491_done:
.annotate 'line', 253
  # rx subrule "routine_declarator" subtype=capture negate=
    rx487_cur."!cursor_pos"(rx487_pos)
    $P10 = rx487_cur."routine_declarator"()
    unless $P10, rx487_fail
    rx487_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx487_pos = $P10."pos"()
  # rx pass
    rx487_cur."!cursor_pass"(rx487_pos, "term:sym<routine_declarator>")
    if_null rx487_debug, debug_619
    rx487_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx487_pos)
  debug_619:
    .return (rx487_cur)
  rx487_restart:
.annotate 'line', 4
    if_null rx487_debug, debug_620
    rx487_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_620:
  rx487_fail:
    (rx487_rep, rx487_pos, $I10, $P10) = rx487_cur."!mark_fail"(0)
    lt rx487_pos, -1, rx487_done
    eq rx487_pos, -1, rx487_fail
    jump $I10
  rx487_done:
    rx487_cur."!cursor_fail"()
    if_null rx487_debug, debug_621
    rx487_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_621:
    .return (rx487_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("112_1299450589.65") :method
.annotate 'line', 4
    $P489 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P490, "ResizablePMCArray"
    push $P490, $P489
    .return ($P490)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("113_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P503 = "116_1299450589.65" 
    capture_lex $P503
    .const 'Sub' $P498 = "115_1299450589.65" 
    capture_lex $P498
    .local string rx493_tgt
    .local int rx493_pos
    .local int rx493_off
    .local int rx493_eos
    .local int rx493_rep
    .local pmc rx493_cur
    .local pmc rx493_debug
    (rx493_cur, rx493_pos, rx493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx493_cur
    .local pmc match
    .lex "$/", match
    length rx493_eos, rx493_tgt
    gt rx493_pos, rx493_eos, rx493_done
    set rx493_off, 0
    lt rx493_pos, 2, rx493_start
    sub rx493_off, rx493_pos, 1
    substr rx493_tgt, rx493_tgt, rx493_off
  rx493_start:
    eq $I10, 1, rx493_restart
    if_null rx493_debug, debug_622
    rx493_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan496_done
    goto rxscan496_scan
  rxscan496_loop:
    (rx493_pos) = rx493_cur."from"()
    inc rx493_pos
    rx493_cur."!cursor_from"(rx493_pos)
    ge rx493_pos, rx493_eos, rxscan496_done
  rxscan496_scan:
    set_addr $I10, rxscan496_loop
    rx493_cur."!mark_push"(0, rx493_pos, $I10)
  rxscan496_done:
.annotate 'line', 255
  # rx subrule "before" subtype=zerowidth negate=
    rx493_cur."!cursor_pos"(rx493_pos)
    .const 'Sub' $P498 = "115_1299450589.65" 
    capture_lex $P498
    $P10 = rx493_cur."before"($P498)
    unless $P10, rx493_fail
.annotate 'line', 256
  # rx subrule "before" subtype=zerowidth negate=1
    rx493_cur."!cursor_pos"(rx493_pos)
    .const 'Sub' $P503 = "116_1299450589.65" 
    capture_lex $P503
    $P10 = rx493_cur."before"($P503)
    if $P10, rx493_fail
.annotate 'line', 257
  # rx subrule "multi_declarator" subtype=capture negate=
    rx493_cur."!cursor_pos"(rx493_pos)
    $P10 = rx493_cur."multi_declarator"()
    unless $P10, rx493_fail
    rx493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx493_pos = $P10."pos"()
.annotate 'line', 254
  # rx pass
    rx493_cur."!cursor_pass"(rx493_pos, "term:sym<multi_declarator>")
    if_null rx493_debug, debug_631
    rx493_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx493_pos)
  debug_631:
    .return (rx493_cur)
  rx493_restart:
.annotate 'line', 4
    if_null rx493_debug, debug_632
    rx493_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_632:
  rx493_fail:
    (rx493_rep, rx493_pos, $I10, $P10) = rx493_cur."!mark_fail"(0)
    lt rx493_pos, -1, rx493_done
    eq rx493_pos, -1, rx493_fail
    jump $I10
  rx493_done:
    rx493_cur."!cursor_fail"()
    if_null rx493_debug, debug_633
    rx493_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_633:
    .return (rx493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("114_1299450589.65") :method
.annotate 'line', 4
    new $P495, "ResizablePMCArray"
    push $P495, ""
    .return ($P495)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block497"  :anon :subid("115_1299450589.65") :method :outer("113_1299450589.65")
.annotate 'line', 255
    .local string rx499_tgt
    .local int rx499_pos
    .local int rx499_off
    .local int rx499_eos
    .local int rx499_rep
    .local pmc rx499_cur
    .local pmc rx499_debug
    (rx499_cur, rx499_pos, rx499_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx499_cur
    .local pmc match
    .lex "$/", match
    length rx499_eos, rx499_tgt
    gt rx499_pos, rx499_eos, rx499_done
    set rx499_off, 0
    lt rx499_pos, 2, rx499_start
    sub rx499_off, rx499_pos, 1
    substr rx499_tgt, rx499_tgt, rx499_off
  rx499_start:
    eq $I10, 1, rx499_restart
    if_null rx499_debug, debug_623
    rx499_cur."!cursor_debug"("START", "")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan500_done
    goto rxscan500_scan
  rxscan500_loop:
    (rx499_pos) = rx499_cur."from"()
    inc rx499_pos
    rx499_cur."!cursor_from"(rx499_pos)
    ge rx499_pos, rx499_eos, rxscan500_done
  rxscan500_scan:
    set_addr $I10, rxscan500_loop
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  rxscan500_done:
  alt501_0:
    set_addr $I10, alt501_1
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  # rx literal  "multi"
    add $I11, rx499_pos, 5
    gt $I11, rx499_eos, rx499_fail
    sub $I11, rx499_pos, rx499_off
    substr $S10, rx499_tgt, $I11, 5
    ne $S10, "multi", rx499_fail
    add rx499_pos, 5
    goto alt501_end
  alt501_1:
    set_addr $I10, alt501_2
    rx499_cur."!mark_push"(0, rx499_pos, $I10)
  # rx literal  "proto"
    add $I11, rx499_pos, 5
    gt $I11, rx499_eos, rx499_fail
    sub $I11, rx499_pos, rx499_off
    substr $S10, rx499_tgt, $I11, 5
    ne $S10, "proto", rx499_fail
    add rx499_pos, 5
    goto alt501_end
  alt501_2:
  # rx literal  "only"
    add $I11, rx499_pos, 4
    gt $I11, rx499_eos, rx499_fail
    sub $I11, rx499_pos, rx499_off
    substr $S10, rx499_tgt, $I11, 4
    ne $S10, "only", rx499_fail
    add rx499_pos, 4
  alt501_end:
  # rx pass
    rx499_cur."!cursor_pass"(rx499_pos, "")
    if_null rx499_debug, debug_624
    rx499_cur."!cursor_debug"("PASS", "", " at pos=", rx499_pos)
  debug_624:
    .return (rx499_cur)
  rx499_restart:
    if_null rx499_debug, debug_625
    rx499_cur."!cursor_debug"("NEXT", "")
  debug_625:
  rx499_fail:
    (rx499_rep, rx499_pos, $I10, $P10) = rx499_cur."!mark_fail"(0)
    lt rx499_pos, -1, rx499_done
    eq rx499_pos, -1, rx499_fail
    jump $I10
  rx499_done:
    rx499_cur."!cursor_fail"()
    if_null rx499_debug, debug_626
    rx499_cur."!cursor_debug"("FAIL", "")
  debug_626:
    .return (rx499_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block502"  :anon :subid("116_1299450589.65") :method :outer("113_1299450589.65")
.annotate 'line', 256
    .local string rx504_tgt
    .local int rx504_pos
    .local int rx504_off
    .local int rx504_eos
    .local int rx504_rep
    .local pmc rx504_cur
    .local pmc rx504_debug
    (rx504_cur, rx504_pos, rx504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx504_cur
    .local pmc match
    .lex "$/", match
    length rx504_eos, rx504_tgt
    gt rx504_pos, rx504_eos, rx504_done
    set rx504_off, 0
    lt rx504_pos, 2, rx504_start
    sub rx504_off, rx504_pos, 1
    substr rx504_tgt, rx504_tgt, rx504_off
  rx504_start:
    eq $I10, 1, rx504_restart
    if_null rx504_debug, debug_627
    rx504_cur."!cursor_debug"("START", "")
  debug_627:
    $I10 = self.'from'()
    ne $I10, -1, rxscan505_done
    goto rxscan505_scan
  rxscan505_loop:
    (rx504_pos) = rx504_cur."from"()
    inc rx504_pos
    rx504_cur."!cursor_from"(rx504_pos)
    ge rx504_pos, rx504_eos, rxscan505_done
  rxscan505_scan:
    set_addr $I10, rxscan505_loop
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  rxscan505_done:
  # rx literal  "proto"
    add $I11, rx504_pos, 5
    gt $I11, rx504_eos, rx504_fail
    sub $I11, rx504_pos, rx504_off
    substr $S10, rx504_tgt, $I11, 5
    ne $S10, "proto", rx504_fail
    add rx504_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx504_cur."!cursor_pos"(rx504_pos)
    $P10 = rx504_cur."ws"()
    unless $P10, rx504_fail
    rx504_pos = $P10."pos"()
  alt506_0:
    set_addr $I10, alt506_1
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  # rx literal  "regex"
    add $I11, rx504_pos, 5
    gt $I11, rx504_eos, rx504_fail
    sub $I11, rx504_pos, rx504_off
    substr $S10, rx504_tgt, $I11, 5
    ne $S10, "regex", rx504_fail
    add rx504_pos, 5
    goto alt506_end
  alt506_1:
    set_addr $I10, alt506_2
    rx504_cur."!mark_push"(0, rx504_pos, $I10)
  # rx literal  "token"
    add $I11, rx504_pos, 5
    gt $I11, rx504_eos, rx504_fail
    sub $I11, rx504_pos, rx504_off
    substr $S10, rx504_tgt, $I11, 5
    ne $S10, "token", rx504_fail
    add rx504_pos, 5
    goto alt506_end
  alt506_2:
  # rx literal  "rule"
    add $I11, rx504_pos, 4
    gt $I11, rx504_eos, rx504_fail
    sub $I11, rx504_pos, rx504_off
    substr $S10, rx504_tgt, $I11, 4
    ne $S10, "rule", rx504_fail
    add rx504_pos, 4
  alt506_end:
  # rx pass
    rx504_cur."!cursor_pass"(rx504_pos, "")
    if_null rx504_debug, debug_628
    rx504_cur."!cursor_debug"("PASS", "", " at pos=", rx504_pos)
  debug_628:
    .return (rx504_cur)
  rx504_restart:
    if_null rx504_debug, debug_629
    rx504_cur."!cursor_debug"("NEXT", "")
  debug_629:
  rx504_fail:
    (rx504_rep, rx504_pos, $I10, $P10) = rx504_cur."!mark_fail"(0)
    lt rx504_pos, -1, rx504_done
    eq rx504_pos, -1, rx504_fail
    jump $I10
  rx504_done:
    rx504_cur."!cursor_fail"()
    if_null rx504_debug, debug_630
    rx504_cur."!cursor_debug"("FAIL", "")
  debug_630:
    .return (rx504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("117_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_634
    rx508_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_634:
    $I10 = self.'from'()
    ne $I10, -1, rxscan512_done
    goto rxscan512_scan
  rxscan512_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan512_done
  rxscan512_scan:
    set_addr $I10, rxscan512_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan512_done:
.annotate 'line', 259
  # rx subrule "regex_declarator" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."regex_declarator"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx508_pos = $P10."pos"()
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "term:sym<regex_declarator>")
    if_null rx508_debug, debug_635
    rx508_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx508_pos)
  debug_635:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 4
    if_null rx508_debug, debug_636
    rx508_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_636:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_637
    rx508_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_637:
    .return (rx508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("118_1299450589.65") :method
.annotate 'line', 4
    $P510 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P511, "ResizablePMCArray"
    push $P511, $P510
    .return ($P511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("119_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_638
    rx514_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan518_done
    goto rxscan518_scan
  rxscan518_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan518_done
  rxscan518_scan:
    set_addr $I10, rxscan518_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan518_done:
.annotate 'line', 260
  # rx subrule "statement_prefix" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."statement_prefix"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx514_pos = $P10."pos"()
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "term:sym<statement_prefix>")
    if_null rx514_debug, debug_639
    rx514_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx514_pos)
  debug_639:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 4
    if_null rx514_debug, debug_640
    rx514_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_640:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_641
    rx514_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_641:
    .return (rx514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("120_1299450589.65") :method
.annotate 'line', 4
    $P516 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P517, "ResizablePMCArray"
    push $P517, $P516
    .return ($P517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("121_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx520_tgt
    .local int rx520_pos
    .local int rx520_off
    .local int rx520_eos
    .local int rx520_rep
    .local pmc rx520_cur
    .local pmc rx520_debug
    (rx520_cur, rx520_pos, rx520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx520_cur
    .local pmc match
    .lex "$/", match
    length rx520_eos, rx520_tgt
    gt rx520_pos, rx520_eos, rx520_done
    set rx520_off, 0
    lt rx520_pos, 2, rx520_start
    sub rx520_off, rx520_pos, 1
    substr rx520_tgt, rx520_tgt, rx520_off
  rx520_start:
    eq $I10, 1, rx520_restart
    if_null rx520_debug, debug_642
    rx520_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_642:
    $I10 = self.'from'()
    ne $I10, -1, rxscan523_done
    goto rxscan523_scan
  rxscan523_loop:
    (rx520_pos) = rx520_cur."from"()
    inc rx520_pos
    rx520_cur."!cursor_from"(rx520_pos)
    ge rx520_pos, rx520_eos, rxscan523_done
  rxscan523_scan:
    set_addr $I10, rxscan523_loop
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  rxscan523_done:
.annotate 'line', 261
  # rx subrule "lambda" subtype=zerowidth negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."lambda"()
    unless $P10, rx520_fail
  # rx subrule "pblock" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."pblock"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx520_pos = $P10."pos"()
  # rx pass
    rx520_cur."!cursor_pass"(rx520_pos, "term:sym<lambda>")
    if_null rx520_debug, debug_643
    rx520_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx520_pos)
  debug_643:
    .return (rx520_cur)
  rx520_restart:
.annotate 'line', 4
    if_null rx520_debug, debug_644
    rx520_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_644:
  rx520_fail:
    (rx520_rep, rx520_pos, $I10, $P10) = rx520_cur."!mark_fail"(0)
    lt rx520_pos, -1, rx520_done
    eq rx520_pos, -1, rx520_fail
    jump $I10
  rx520_done:
    rx520_cur."!cursor_fail"()
    if_null rx520_debug, debug_645
    rx520_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_645:
    .return (rx520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("122_1299450589.65") :method
.annotate 'line', 4
    new $P522, "ResizablePMCArray"
    push $P522, ""
    .return ($P522)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("123_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx525_tgt
    .local int rx525_pos
    .local int rx525_off
    .local int rx525_eos
    .local int rx525_rep
    .local pmc rx525_cur
    .local pmc rx525_debug
    (rx525_cur, rx525_pos, rx525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx525_cur
    .local pmc match
    .lex "$/", match
    length rx525_eos, rx525_tgt
    gt rx525_pos, rx525_eos, rx525_done
    set rx525_off, 0
    lt rx525_pos, 2, rx525_start
    sub rx525_off, rx525_pos, 1
    substr rx525_tgt, rx525_tgt, rx525_off
  rx525_start:
    eq $I10, 1, rx525_restart
    if_null rx525_debug, debug_646
    rx525_cur."!cursor_debug"("START", "fatarrow")
  debug_646:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx525_pos) = rx525_cur."from"()
    inc rx525_pos
    rx525_cur."!cursor_from"(rx525_pos)
    ge rx525_pos, rx525_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx525_cur."!mark_push"(0, rx525_pos, $I10)
  rxscan529_done:
.annotate 'line', 264
  # rx subrule "identifier" subtype=capture negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."identifier"()
    unless $P10, rx525_fail
    rx525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx525_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx525_pos, rx525_off
    set rx525_rep, 0
    sub $I12, rx525_eos, rx525_pos
  rxenumcharlistq530_loop:
    le $I12, 0, rxenumcharlistq530_done
    substr $S10, rx525_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq530_done
    inc rx525_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq530_loop
  rxenumcharlistq530_done:
    add rx525_pos, rx525_pos, rx525_rep
  # rx literal  "=>"
    add $I11, rx525_pos, 2
    gt $I11, rx525_eos, rx525_fail
    sub $I11, rx525_pos, rx525_off
    substr $S10, rx525_tgt, $I11, 2
    ne $S10, "=>", rx525_fail
    add rx525_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."ws"()
    unless $P10, rx525_fail
    rx525_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx525_cur."!cursor_pos"(rx525_pos)
    $P10 = rx525_cur."EXPR"("i=")
    unless $P10, rx525_fail
    rx525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx525_pos = $P10."pos"()
.annotate 'line', 263
  # rx pass
    rx525_cur."!cursor_pass"(rx525_pos, "fatarrow")
    if_null rx525_debug, debug_647
    rx525_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx525_pos)
  debug_647:
    .return (rx525_cur)
  rx525_restart:
.annotate 'line', 4
    if_null rx525_debug, debug_648
    rx525_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_648:
  rx525_fail:
    (rx525_rep, rx525_pos, $I10, $P10) = rx525_cur."!mark_fail"(0)
    lt rx525_pos, -1, rx525_done
    eq rx525_pos, -1, rx525_fail
    jump $I10
  rx525_done:
    rx525_cur."!cursor_fail"()
    if_null rx525_debug, debug_649
    rx525_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_649:
    .return (rx525_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("124_1299450589.65") :method
.annotate 'line', 4
    $P527 = self."!PREFIX__!subrule"("identifier", "")
    new $P528, "ResizablePMCArray"
    push $P528, $P527
    .return ($P528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("125_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx532_tgt
    .local int rx532_pos
    .local int rx532_off
    .local int rx532_eos
    .local int rx532_rep
    .local pmc rx532_cur
    .local pmc rx532_debug
    (rx532_cur, rx532_pos, rx532_tgt, $I10) = self."!cursor_start"()
    rx532_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx532_cur
    .local pmc match
    .lex "$/", match
    length rx532_eos, rx532_tgt
    gt rx532_pos, rx532_eos, rx532_done
    set rx532_off, 0
    lt rx532_pos, 2, rx532_start
    sub rx532_off, rx532_pos, 1
    substr rx532_tgt, rx532_tgt, rx532_off
  rx532_start:
    eq $I10, 1, rx532_restart
    if_null rx532_debug, debug_650
    rx532_cur."!cursor_debug"("START", "colonpair")
  debug_650:
    $I10 = self.'from'()
    ne $I10, -1, rxscan538_done
    goto rxscan538_scan
  rxscan538_loop:
    (rx532_pos) = rx532_cur."from"()
    inc rx532_pos
    rx532_cur."!cursor_from"(rx532_pos)
    ge rx532_pos, rx532_eos, rxscan538_done
  rxscan538_scan:
    set_addr $I10, rxscan538_loop
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxscan538_done:
.annotate 'line', 268
  # rx literal  ":"
    add $I11, rx532_pos, 1
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    ord $I11, rx532_tgt, $I11
    ne $I11, 58, rx532_fail
    add rx532_pos, 1
  alt539_0:
.annotate 'line', 269
    set_addr $I10, alt539_1
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
.annotate 'line', 270
  # rx subcapture "not"
    set_addr $I10, rxcap_540_fail
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "!"
    add $I11, rx532_pos, 1
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    ord $I11, rx532_tgt, $I11
    ne $I11, 33, rx532_fail
    add rx532_pos, 1
    set_addr $I10, rxcap_540_fail
    ($I12, $I11) = rx532_cur."!mark_peek"($I10)
    rx532_cur."!cursor_pos"($I11)
    ($P10) = rx532_cur."!cursor_start"()
    $P10."!cursor_pass"(rx532_pos, "")
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_540_done
  rxcap_540_fail:
    goto rx532_fail
  rxcap_540_done:
  # rx subrule "identifier" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."identifier"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx532_pos = $P10."pos"()
    goto alt539_end
  alt539_1:
    set_addr $I10, alt539_2
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
.annotate 'line', 271
  # rx subrule "identifier" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."identifier"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx532_pos = $P10."pos"()
  # rx rxquantr541 ** 0..1
    set_addr $I10, rxquantr541_done
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxquantr541_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."circumfix"()
    unless $P10, rx532_fail
    goto rxsubrule542_pass
  rxsubrule542_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx532_fail
  rxsubrule542_pass:
    set_addr $I10, rxsubrule542_back
    rx532_cur."!mark_push"(0, rx532_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx532_pos = $P10."pos"()
    set_addr $I10, rxquantr541_done
    (rx532_rep) = rx532_cur."!mark_commit"($I10)
  rxquantr541_done:
    goto alt539_end
  alt539_2:
.annotate 'line', 272
  # rx subrule "circumfix" subtype=capture negate=
    rx532_cur."!cursor_pos"(rx532_pos)
    $P10 = rx532_cur."circumfix"()
    unless $P10, rx532_fail
    rx532_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx532_pos = $P10."pos"()
  alt539_end:
.annotate 'line', 267
  # rx pass
    rx532_cur."!cursor_pass"(rx532_pos, "colonpair")
    if_null rx532_debug, debug_651
    rx532_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx532_pos)
  debug_651:
    .return (rx532_cur)
  rx532_restart:
.annotate 'line', 4
    if_null rx532_debug, debug_652
    rx532_cur."!cursor_debug"("NEXT", "colonpair")
  debug_652:
  rx532_fail:
    (rx532_rep, rx532_pos, $I10, $P10) = rx532_cur."!mark_fail"(0)
    lt rx532_pos, -1, rx532_done
    eq rx532_pos, -1, rx532_fail
    jump $I10
  rx532_done:
    rx532_cur."!cursor_fail"()
    if_null rx532_debug, debug_653
    rx532_cur."!cursor_debug"("FAIL", "colonpair")
  debug_653:
    .return (rx532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("126_1299450589.65") :method
.annotate 'line', 4
    $P534 = self."!PREFIX__!subrule"("circumfix", ":")
    $P535 = self."!PREFIX__!subrule"("identifier", ":")
    $P536 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P537, "ResizablePMCArray"
    push $P537, $P534
    push $P537, $P535
    push $P537, $P536
    .return ($P537)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("127_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx544_tgt
    .local int rx544_pos
    .local int rx544_off
    .local int rx544_eos
    .local int rx544_rep
    .local pmc rx544_cur
    .local pmc rx544_debug
    (rx544_cur, rx544_pos, rx544_tgt, $I10) = self."!cursor_start"()
    rx544_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx544_cur
    .local pmc match
    .lex "$/", match
    length rx544_eos, rx544_tgt
    gt rx544_pos, rx544_eos, rx544_done
    set rx544_off, 0
    lt rx544_pos, 2, rx544_start
    sub rx544_off, rx544_pos, 1
    substr rx544_tgt, rx544_tgt, rx544_off
  rx544_start:
    eq $I10, 1, rx544_restart
    if_null rx544_debug, debug_654
    rx544_cur."!cursor_debug"("START", "variable")
  debug_654:
    $I10 = self.'from'()
    ne $I10, -1, rxscan549_done
    goto rxscan549_scan
  rxscan549_loop:
    (rx544_pos) = rx544_cur."from"()
    inc rx544_pos
    rx544_cur."!cursor_from"(rx544_pos)
    ge rx544_pos, rx544_eos, rxscan549_done
  rxscan549_scan:
    set_addr $I10, rxscan549_loop
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  rxscan549_done:
  alt550_0:
.annotate 'line', 276
    set_addr $I10, alt550_1
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
.annotate 'line', 277
  # rx subrule "sigil" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."sigil"()
    unless $P10, rx544_fail
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx544_pos = $P10."pos"()
  # rx rxquantr551 ** 0..1
    set_addr $I10, rxquantr551_done
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  rxquantr551_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."twigil"()
    unless $P10, rx544_fail
    goto rxsubrule552_pass
  rxsubrule552_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx544_fail
  rxsubrule552_pass:
    set_addr $I10, rxsubrule552_back
    rx544_cur."!mark_push"(0, rx544_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx544_pos = $P10."pos"()
    set_addr $I10, rxquantr551_done
    (rx544_rep) = rx544_cur."!mark_commit"($I10)
  rxquantr551_done:
  # rx subrule "name" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."name"()
    unless $P10, rx544_fail
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx544_pos = $P10."pos"()
    goto alt550_end
  alt550_1:
    set_addr $I10, alt550_2
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
.annotate 'line', 278
  # rx subrule "sigil" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."sigil"()
    unless $P10, rx544_fail
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx544_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx544_pos, rx544_off
    substr $S10, rx544_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx544_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx544_cur."!cursor_pos"(rx544_pos)
    $P10 = rx544_cur."postcircumfix"()
    unless $P10, rx544_fail
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx544_pos = $P10."pos"()
    goto alt550_end
  alt550_2:
.annotate 'line', 279
  # rx subcapture "sigil"
    set_addr $I10, rxcap_553_fail
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  # rx literal  "$"
    add $I11, rx544_pos, 1
    gt $I11, rx544_eos, rx544_fail
    sub $I11, rx544_pos, rx544_off
    ord $I11, rx544_tgt, $I11
    ne $I11, 36, rx544_fail
    add rx544_pos, 1
    set_addr $I10, rxcap_553_fail
    ($I12, $I11) = rx544_cur."!mark_peek"($I10)
    rx544_cur."!cursor_pos"($I11)
    ($P10) = rx544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx544_pos, "")
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_553_done
  rxcap_553_fail:
    goto rx544_fail
  rxcap_553_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_554_fail
    rx544_cur."!mark_push"(0, rx544_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx544_pos, rx544_eos, rx544_fail
    sub $I10, rx544_pos, rx544_off
    substr $S10, rx544_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx544_fail
    inc rx544_pos
    set_addr $I10, rxcap_554_fail
    ($I12, $I11) = rx544_cur."!mark_peek"($I10)
    rx544_cur."!cursor_pos"($I11)
    ($P10) = rx544_cur."!cursor_start"()
    $P10."!cursor_pass"(rx544_pos, "")
    rx544_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_554_done
  rxcap_554_fail:
    goto rx544_fail
  rxcap_554_done:
  alt550_end:
.annotate 'line', 276
  # rx pass
    rx544_cur."!cursor_pass"(rx544_pos, "variable")
    if_null rx544_debug, debug_655
    rx544_cur."!cursor_debug"("PASS", "variable", " at pos=", rx544_pos)
  debug_655:
    .return (rx544_cur)
  rx544_restart:
.annotate 'line', 4
    if_null rx544_debug, debug_656
    rx544_cur."!cursor_debug"("NEXT", "variable")
  debug_656:
  rx544_fail:
    (rx544_rep, rx544_pos, $I10, $P10) = rx544_cur."!mark_fail"(0)
    lt rx544_pos, -1, rx544_done
    eq rx544_pos, -1, rx544_fail
    jump $I10
  rx544_done:
    rx544_cur."!cursor_fail"()
    if_null rx544_debug, debug_657
    rx544_cur."!cursor_debug"("FAIL", "variable")
  debug_657:
    .return (rx544_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("128_1299450589.65") :method
.annotate 'line', 4
    $P546 = self."!PREFIX__!subrule"("sigil", "")
    $P547 = self."!PREFIX__!subrule"("sigil", "")
    new $P548, "ResizablePMCArray"
    push $P548, "$!"
    push $P548, "$_"
    push $P548, "$/"
    push $P548, $P546
    push $P548, $P547
    .return ($P548)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("129_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx556_tgt
    .local int rx556_pos
    .local int rx556_off
    .local int rx556_eos
    .local int rx556_rep
    .local pmc rx556_cur
    .local pmc rx556_debug
    (rx556_cur, rx556_pos, rx556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx556_cur
    .local pmc match
    .lex "$/", match
    length rx556_eos, rx556_tgt
    gt rx556_pos, rx556_eos, rx556_done
    set rx556_off, 0
    lt rx556_pos, 2, rx556_start
    sub rx556_off, rx556_pos, 1
    substr rx556_tgt, rx556_tgt, rx556_off
  rx556_start:
    eq $I10, 1, rx556_restart
    if_null rx556_debug, debug_658
    rx556_cur."!cursor_debug"("START", "sigil")
  debug_658:
    $I10 = self.'from'()
    ne $I10, -1, rxscan559_done
    goto rxscan559_scan
  rxscan559_loop:
    (rx556_pos) = rx556_cur."from"()
    inc rx556_pos
    rx556_cur."!cursor_from"(rx556_pos)
    ge rx556_pos, rx556_eos, rxscan559_done
  rxscan559_scan:
    set_addr $I10, rxscan559_loop
    rx556_cur."!mark_push"(0, rx556_pos, $I10)
  rxscan559_done:
.annotate 'line', 282
  # rx enumcharlist negate=0 
    ge rx556_pos, rx556_eos, rx556_fail
    sub $I10, rx556_pos, rx556_off
    substr $S10, rx556_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx556_fail
    inc rx556_pos
  # rx pass
    rx556_cur."!cursor_pass"(rx556_pos, "sigil")
    if_null rx556_debug, debug_659
    rx556_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx556_pos)
  debug_659:
    .return (rx556_cur)
  rx556_restart:
.annotate 'line', 4
    if_null rx556_debug, debug_660
    rx556_cur."!cursor_debug"("NEXT", "sigil")
  debug_660:
  rx556_fail:
    (rx556_rep, rx556_pos, $I10, $P10) = rx556_cur."!mark_fail"(0)
    lt rx556_pos, -1, rx556_done
    eq rx556_pos, -1, rx556_fail
    jump $I10
  rx556_done:
    rx556_cur."!cursor_fail"()
    if_null rx556_debug, debug_661
    rx556_cur."!cursor_debug"("FAIL", "sigil")
  debug_661:
    .return (rx556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("130_1299450589.65") :method
.annotate 'line', 4
    new $P558, "ResizablePMCArray"
    push $P558, "&"
    push $P558, "%"
    push $P558, "@"
    push $P558, "$"
    .return ($P558)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("131_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx561_tgt
    .local int rx561_pos
    .local int rx561_off
    .local int rx561_eos
    .local int rx561_rep
    .local pmc rx561_cur
    .local pmc rx561_debug
    (rx561_cur, rx561_pos, rx561_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx561_cur
    .local pmc match
    .lex "$/", match
    length rx561_eos, rx561_tgt
    gt rx561_pos, rx561_eos, rx561_done
    set rx561_off, 0
    lt rx561_pos, 2, rx561_start
    sub rx561_off, rx561_pos, 1
    substr rx561_tgt, rx561_tgt, rx561_off
  rx561_start:
    eq $I10, 1, rx561_restart
    if_null rx561_debug, debug_662
    rx561_cur."!cursor_debug"("START", "twigil")
  debug_662:
    $I10 = self.'from'()
    ne $I10, -1, rxscan564_done
    goto rxscan564_scan
  rxscan564_loop:
    (rx561_pos) = rx561_cur."from"()
    inc rx561_pos
    rx561_cur."!cursor_from"(rx561_pos)
    ge rx561_pos, rx561_eos, rxscan564_done
  rxscan564_scan:
    set_addr $I10, rxscan564_loop
    rx561_cur."!mark_push"(0, rx561_pos, $I10)
  rxscan564_done:
.annotate 'line', 284
  # rx enumcharlist negate=0 
    ge rx561_pos, rx561_eos, rx561_fail
    sub $I10, rx561_pos, rx561_off
    substr $S10, rx561_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx561_fail
    inc rx561_pos
  # rx pass
    rx561_cur."!cursor_pass"(rx561_pos, "twigil")
    if_null rx561_debug, debug_663
    rx561_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx561_pos)
  debug_663:
    .return (rx561_cur)
  rx561_restart:
.annotate 'line', 4
    if_null rx561_debug, debug_664
    rx561_cur."!cursor_debug"("NEXT", "twigil")
  debug_664:
  rx561_fail:
    (rx561_rep, rx561_pos, $I10, $P10) = rx561_cur."!mark_fail"(0)
    lt rx561_pos, -1, rx561_done
    eq rx561_pos, -1, rx561_fail
    jump $I10
  rx561_done:
    rx561_cur."!cursor_fail"()
    if_null rx561_debug, debug_665
    rx561_cur."!cursor_debug"("FAIL", "twigil")
  debug_665:
    .return (rx561_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("132_1299450589.65") :method
.annotate 'line', 4
    new $P563, "ResizablePMCArray"
    push $P563, "?"
    push $P563, "!"
    push $P563, "*"
    .return ($P563)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("133_1299450589.65")
    .param pmc param_566
.annotate 'line', 286
    .lex "self", param_566
    $P567 = param_566."!protoregex"("package_declarator")
    .return ($P567)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("134_1299450589.65")
    .param pmc param_569
.annotate 'line', 286
    .lex "self", param_569
    $P570 = param_569."!PREFIX__!protoregex"("package_declarator")
    .return ($P570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("135_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 288
    new $P572, "Undef"
    .lex "$*PACKAGE-SETUP", $P572
.annotate 'line', 289
    new $P573, "Undef"
    .lex "$*PKGDECL", $P573
.annotate 'line', 4
    .local string rx574_tgt
    .local int rx574_pos
    .local int rx574_off
    .local int rx574_eos
    .local int rx574_rep
    .local pmc rx574_cur
    .local pmc rx574_debug
    (rx574_cur, rx574_pos, rx574_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx574_cur
    .local pmc match
    .lex "$/", match
    length rx574_eos, rx574_tgt
    gt rx574_pos, rx574_eos, rx574_done
    set rx574_off, 0
    lt rx574_pos, 2, rx574_start
    sub rx574_off, rx574_pos, 1
    substr rx574_tgt, rx574_tgt, rx574_off
  rx574_start:
    eq $I10, 1, rx574_restart
    if_null rx574_debug, debug_666
    rx574_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_666:
    $I10 = self.'from'()
    ne $I10, -1, rxscan578_done
    goto rxscan578_scan
  rxscan578_loop:
    (rx574_pos) = rx574_cur."from"()
    inc rx574_pos
    rx574_cur."!cursor_from"(rx574_pos)
    ge rx574_pos, rx574_eos, rxscan578_done
  rxscan578_scan:
    set_addr $I10, rxscan578_loop
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  rxscan578_done:
.annotate 'line', 288
    rx574_cur."!cursor_pos"(rx574_pos)
    get_hll_global $P579, ["PAST"], "Stmts"
    $P580 = $P579."new"()
    store_lex "$*PACKAGE-SETUP", $P580
.annotate 'line', 289
    rx574_cur."!cursor_pos"(rx574_pos)
    new $P581, "String"
    assign $P581, "module"
    store_lex "$*PKGDECL", $P581
.annotate 'line', 290
  # rx subcapture "sym"
    set_addr $I10, rxcap_582_fail
    rx574_cur."!mark_push"(0, rx574_pos, $I10)
  # rx literal  "module"
    add $I11, rx574_pos, 6
    gt $I11, rx574_eos, rx574_fail
    sub $I11, rx574_pos, rx574_off
    substr $S10, rx574_tgt, $I11, 6
    ne $S10, "module", rx574_fail
    add rx574_pos, 6
    set_addr $I10, rxcap_582_fail
    ($I12, $I11) = rx574_cur."!mark_peek"($I10)
    rx574_cur."!cursor_pos"($I11)
    ($P10) = rx574_cur."!cursor_start"()
    $P10."!cursor_pass"(rx574_pos, "")
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_582_done
  rxcap_582_fail:
    goto rx574_fail
  rxcap_582_done:
  # rx subrule "package_def" subtype=capture negate=
    rx574_cur."!cursor_pos"(rx574_pos)
    $P10 = rx574_cur."package_def"()
    unless $P10, rx574_fail
    rx574_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx574_pos = $P10."pos"()
.annotate 'line', 287
  # rx pass
    rx574_cur."!cursor_pass"(rx574_pos, "package_declarator:sym<module>")
    if_null rx574_debug, debug_667
    rx574_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx574_pos)
  debug_667:
    .return (rx574_cur)
  rx574_restart:
.annotate 'line', 4
    if_null rx574_debug, debug_668
    rx574_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_668:
  rx574_fail:
    (rx574_rep, rx574_pos, $I10, $P10) = rx574_cur."!mark_fail"(0)
    lt rx574_pos, -1, rx574_done
    eq rx574_pos, -1, rx574_fail
    jump $I10
  rx574_done:
    rx574_cur."!cursor_fail"()
    if_null rx574_debug, debug_669
    rx574_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_669:
    .return (rx574_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("136_1299450589.65") :method
.annotate 'line', 4
    $P576 = self."!PREFIX__!subrule"("package_def", "module")
    new $P577, "ResizablePMCArray"
    push $P577, $P576
    .return ($P577)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("137_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 293
    new $P584, "Undef"
    .lex "$*PACKAGE-SETUP", $P584
.annotate 'line', 294
    new $P585, "Undef"
    .lex "$*PKGDECL", $P585
.annotate 'line', 4
    .local string rx586_tgt
    .local int rx586_pos
    .local int rx586_off
    .local int rx586_eos
    .local int rx586_rep
    .local pmc rx586_cur
    .local pmc rx586_debug
    (rx586_cur, rx586_pos, rx586_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx586_cur
    .local pmc match
    .lex "$/", match
    length rx586_eos, rx586_tgt
    gt rx586_pos, rx586_eos, rx586_done
    set rx586_off, 0
    lt rx586_pos, 2, rx586_start
    sub rx586_off, rx586_pos, 1
    substr rx586_tgt, rx586_tgt, rx586_off
  rx586_start:
    eq $I10, 1, rx586_restart
    if_null rx586_debug, debug_670
    rx586_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_670:
    $I10 = self.'from'()
    ne $I10, -1, rxscan590_done
    goto rxscan590_scan
  rxscan590_loop:
    (rx586_pos) = rx586_cur."from"()
    inc rx586_pos
    rx586_cur."!cursor_from"(rx586_pos)
    ge rx586_pos, rx586_eos, rxscan590_done
  rxscan590_scan:
    set_addr $I10, rxscan590_loop
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  rxscan590_done:
.annotate 'line', 293
    rx586_cur."!cursor_pos"(rx586_pos)
    get_hll_global $P591, ["PAST"], "Stmts"
    $P592 = $P591."new"()
    store_lex "$*PACKAGE-SETUP", $P592
.annotate 'line', 294
    rx586_cur."!cursor_pos"(rx586_pos)
    new $P593, "String"
    assign $P593, "knowhow"
    store_lex "$*PKGDECL", $P593
.annotate 'line', 295
  # rx subcapture "sym"
    set_addr $I10, rxcap_594_fail
    rx586_cur."!mark_push"(0, rx586_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx586_pos, 7
    gt $I11, rx586_eos, rx586_fail
    sub $I11, rx586_pos, rx586_off
    substr $S10, rx586_tgt, $I11, 7
    ne $S10, "knowhow", rx586_fail
    add rx586_pos, 7
    set_addr $I10, rxcap_594_fail
    ($I12, $I11) = rx586_cur."!mark_peek"($I10)
    rx586_cur."!cursor_pos"($I11)
    ($P10) = rx586_cur."!cursor_start"()
    $P10."!cursor_pass"(rx586_pos, "")
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_594_done
  rxcap_594_fail:
    goto rx586_fail
  rxcap_594_done:
  # rx subrule "package_def" subtype=capture negate=
    rx586_cur."!cursor_pos"(rx586_pos)
    $P10 = rx586_cur."package_def"()
    unless $P10, rx586_fail
    rx586_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx586_pos = $P10."pos"()
.annotate 'line', 292
  # rx pass
    rx586_cur."!cursor_pass"(rx586_pos, "package_declarator:sym<knowhow>")
    if_null rx586_debug, debug_671
    rx586_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx586_pos)
  debug_671:
    .return (rx586_cur)
  rx586_restart:
.annotate 'line', 4
    if_null rx586_debug, debug_672
    rx586_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_672:
  rx586_fail:
    (rx586_rep, rx586_pos, $I10, $P10) = rx586_cur."!mark_fail"(0)
    lt rx586_pos, -1, rx586_done
    eq rx586_pos, -1, rx586_fail
    jump $I10
  rx586_done:
    rx586_cur."!cursor_fail"()
    if_null rx586_debug, debug_673
    rx586_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_673:
    .return (rx586_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("138_1299450589.65") :method
.annotate 'line', 4
    $P588 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P589, "ResizablePMCArray"
    push $P589, $P588
    .return ($P589)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("139_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 298
    new $P596, "Undef"
    .lex "$*PACKAGE-SETUP", $P596
.annotate 'line', 299
    new $P597, "Undef"
    .lex "$*PKGDECL", $P597
.annotate 'line', 4
    .local string rx598_tgt
    .local int rx598_pos
    .local int rx598_off
    .local int rx598_eos
    .local int rx598_rep
    .local pmc rx598_cur
    .local pmc rx598_debug
    (rx598_cur, rx598_pos, rx598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx598_cur
    .local pmc match
    .lex "$/", match
    length rx598_eos, rx598_tgt
    gt rx598_pos, rx598_eos, rx598_done
    set rx598_off, 0
    lt rx598_pos, 2, rx598_start
    sub rx598_off, rx598_pos, 1
    substr rx598_tgt, rx598_tgt, rx598_off
  rx598_start:
    eq $I10, 1, rx598_restart
    if_null rx598_debug, debug_674
    rx598_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_674:
    $I10 = self.'from'()
    ne $I10, -1, rxscan602_done
    goto rxscan602_scan
  rxscan602_loop:
    (rx598_pos) = rx598_cur."from"()
    inc rx598_pos
    rx598_cur."!cursor_from"(rx598_pos)
    ge rx598_pos, rx598_eos, rxscan602_done
  rxscan602_scan:
    set_addr $I10, rxscan602_loop
    rx598_cur."!mark_push"(0, rx598_pos, $I10)
  rxscan602_done:
.annotate 'line', 298
    rx598_cur."!cursor_pos"(rx598_pos)
    get_hll_global $P603, ["PAST"], "Stmts"
    $P604 = $P603."new"()
    store_lex "$*PACKAGE-SETUP", $P604
.annotate 'line', 299
    rx598_cur."!cursor_pos"(rx598_pos)
    new $P605, "String"
    assign $P605, "class"
    store_lex "$*PKGDECL", $P605
.annotate 'line', 300
  # rx subcapture "sym"
    set_addr $I10, rxcap_606_fail
    rx598_cur."!mark_push"(0, rx598_pos, $I10)
  # rx literal  "class"
    add $I11, rx598_pos, 5
    gt $I11, rx598_eos, rx598_fail
    sub $I11, rx598_pos, rx598_off
    substr $S10, rx598_tgt, $I11, 5
    ne $S10, "class", rx598_fail
    add rx598_pos, 5
    set_addr $I10, rxcap_606_fail
    ($I12, $I11) = rx598_cur."!mark_peek"($I10)
    rx598_cur."!cursor_pos"($I11)
    ($P10) = rx598_cur."!cursor_start"()
    $P10."!cursor_pass"(rx598_pos, "")
    rx598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_606_done
  rxcap_606_fail:
    goto rx598_fail
  rxcap_606_done:
  # rx subrule "package_def" subtype=capture negate=
    rx598_cur."!cursor_pos"(rx598_pos)
    $P10 = rx598_cur."package_def"()
    unless $P10, rx598_fail
    rx598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx598_pos = $P10."pos"()
.annotate 'line', 297
  # rx pass
    rx598_cur."!cursor_pass"(rx598_pos, "package_declarator:sym<class>")
    if_null rx598_debug, debug_675
    rx598_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx598_pos)
  debug_675:
    .return (rx598_cur)
  rx598_restart:
.annotate 'line', 4
    if_null rx598_debug, debug_676
    rx598_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_676:
  rx598_fail:
    (rx598_rep, rx598_pos, $I10, $P10) = rx598_cur."!mark_fail"(0)
    lt rx598_pos, -1, rx598_done
    eq rx598_pos, -1, rx598_fail
    jump $I10
  rx598_done:
    rx598_cur."!cursor_fail"()
    if_null rx598_debug, debug_677
    rx598_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_677:
    .return (rx598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("140_1299450589.65") :method
.annotate 'line', 4
    $P600 = self."!PREFIX__!subrule"("package_def", "class")
    new $P601, "ResizablePMCArray"
    push $P601, $P600
    .return ($P601)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("141_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 303
    new $P608, "Undef"
    .lex "$*PACKAGE-SETUP", $P608
.annotate 'line', 304
    new $P609, "Undef"
    .lex "$*PKGDECL", $P609
.annotate 'line', 4
    .local string rx610_tgt
    .local int rx610_pos
    .local int rx610_off
    .local int rx610_eos
    .local int rx610_rep
    .local pmc rx610_cur
    .local pmc rx610_debug
    (rx610_cur, rx610_pos, rx610_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx610_cur
    .local pmc match
    .lex "$/", match
    length rx610_eos, rx610_tgt
    gt rx610_pos, rx610_eos, rx610_done
    set rx610_off, 0
    lt rx610_pos, 2, rx610_start
    sub rx610_off, rx610_pos, 1
    substr rx610_tgt, rx610_tgt, rx610_off
  rx610_start:
    eq $I10, 1, rx610_restart
    if_null rx610_debug, debug_678
    rx610_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_678:
    $I10 = self.'from'()
    ne $I10, -1, rxscan614_done
    goto rxscan614_scan
  rxscan614_loop:
    (rx610_pos) = rx610_cur."from"()
    inc rx610_pos
    rx610_cur."!cursor_from"(rx610_pos)
    ge rx610_pos, rx610_eos, rxscan614_done
  rxscan614_scan:
    set_addr $I10, rxscan614_loop
    rx610_cur."!mark_push"(0, rx610_pos, $I10)
  rxscan614_done:
.annotate 'line', 303
    rx610_cur."!cursor_pos"(rx610_pos)
    get_hll_global $P615, ["PAST"], "Stmts"
    $P616 = $P615."new"()
    store_lex "$*PACKAGE-SETUP", $P616
.annotate 'line', 304
    rx610_cur."!cursor_pos"(rx610_pos)
    new $P617, "String"
    assign $P617, "grammar"
    store_lex "$*PKGDECL", $P617
.annotate 'line', 305
  # rx subcapture "sym"
    set_addr $I10, rxcap_618_fail
    rx610_cur."!mark_push"(0, rx610_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx610_pos, 7
    gt $I11, rx610_eos, rx610_fail
    sub $I11, rx610_pos, rx610_off
    substr $S10, rx610_tgt, $I11, 7
    ne $S10, "grammar", rx610_fail
    add rx610_pos, 7
    set_addr $I10, rxcap_618_fail
    ($I12, $I11) = rx610_cur."!mark_peek"($I10)
    rx610_cur."!cursor_pos"($I11)
    ($P10) = rx610_cur."!cursor_start"()
    $P10."!cursor_pass"(rx610_pos, "")
    rx610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_618_done
  rxcap_618_fail:
    goto rx610_fail
  rxcap_618_done:
  # rx subrule "package_def" subtype=capture negate=
    rx610_cur."!cursor_pos"(rx610_pos)
    $P10 = rx610_cur."package_def"()
    unless $P10, rx610_fail
    rx610_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx610_pos = $P10."pos"()
.annotate 'line', 302
  # rx pass
    rx610_cur."!cursor_pass"(rx610_pos, "package_declarator:sym<grammar>")
    if_null rx610_debug, debug_679
    rx610_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx610_pos)
  debug_679:
    .return (rx610_cur)
  rx610_restart:
.annotate 'line', 4
    if_null rx610_debug, debug_680
    rx610_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_680:
  rx610_fail:
    (rx610_rep, rx610_pos, $I10, $P10) = rx610_cur."!mark_fail"(0)
    lt rx610_pos, -1, rx610_done
    eq rx610_pos, -1, rx610_fail
    jump $I10
  rx610_done:
    rx610_cur."!cursor_fail"()
    if_null rx610_debug, debug_681
    rx610_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_681:
    .return (rx610_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("142_1299450589.65") :method
.annotate 'line', 4
    $P612 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P613, "ResizablePMCArray"
    push $P613, $P612
    .return ($P613)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("143_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 308
    new $P620, "Undef"
    .lex "$*PACKAGE-SETUP", $P620
.annotate 'line', 309
    new $P621, "Undef"
    .lex "$*PKGDECL", $P621
.annotate 'line', 4
    .local string rx622_tgt
    .local int rx622_pos
    .local int rx622_off
    .local int rx622_eos
    .local int rx622_rep
    .local pmc rx622_cur
    .local pmc rx622_debug
    (rx622_cur, rx622_pos, rx622_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx622_cur
    .local pmc match
    .lex "$/", match
    length rx622_eos, rx622_tgt
    gt rx622_pos, rx622_eos, rx622_done
    set rx622_off, 0
    lt rx622_pos, 2, rx622_start
    sub rx622_off, rx622_pos, 1
    substr rx622_tgt, rx622_tgt, rx622_off
  rx622_start:
    eq $I10, 1, rx622_restart
    if_null rx622_debug, debug_682
    rx622_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_682:
    $I10 = self.'from'()
    ne $I10, -1, rxscan626_done
    goto rxscan626_scan
  rxscan626_loop:
    (rx622_pos) = rx622_cur."from"()
    inc rx622_pos
    rx622_cur."!cursor_from"(rx622_pos)
    ge rx622_pos, rx622_eos, rxscan626_done
  rxscan626_scan:
    set_addr $I10, rxscan626_loop
    rx622_cur."!mark_push"(0, rx622_pos, $I10)
  rxscan626_done:
.annotate 'line', 308
    rx622_cur."!cursor_pos"(rx622_pos)
    get_hll_global $P627, ["PAST"], "Stmts"
    $P628 = $P627."new"()
    store_lex "$*PACKAGE-SETUP", $P628
.annotate 'line', 309
    rx622_cur."!cursor_pos"(rx622_pos)
    new $P629, "String"
    assign $P629, "role"
    store_lex "$*PKGDECL", $P629
.annotate 'line', 310
  # rx subcapture "sym"
    set_addr $I10, rxcap_630_fail
    rx622_cur."!mark_push"(0, rx622_pos, $I10)
  # rx literal  "role"
    add $I11, rx622_pos, 4
    gt $I11, rx622_eos, rx622_fail
    sub $I11, rx622_pos, rx622_off
    substr $S10, rx622_tgt, $I11, 4
    ne $S10, "role", rx622_fail
    add rx622_pos, 4
    set_addr $I10, rxcap_630_fail
    ($I12, $I11) = rx622_cur."!mark_peek"($I10)
    rx622_cur."!cursor_pos"($I11)
    ($P10) = rx622_cur."!cursor_start"()
    $P10."!cursor_pass"(rx622_pos, "")
    rx622_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_630_done
  rxcap_630_fail:
    goto rx622_fail
  rxcap_630_done:
  # rx subrule "package_def" subtype=capture negate=
    rx622_cur."!cursor_pos"(rx622_pos)
    $P10 = rx622_cur."package_def"()
    unless $P10, rx622_fail
    rx622_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx622_pos = $P10."pos"()
.annotate 'line', 307
  # rx pass
    rx622_cur."!cursor_pass"(rx622_pos, "package_declarator:sym<role>")
    if_null rx622_debug, debug_683
    rx622_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx622_pos)
  debug_683:
    .return (rx622_cur)
  rx622_restart:
.annotate 'line', 4
    if_null rx622_debug, debug_684
    rx622_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_684:
  rx622_fail:
    (rx622_rep, rx622_pos, $I10, $P10) = rx622_cur."!mark_fail"(0)
    lt rx622_pos, -1, rx622_done
    eq rx622_pos, -1, rx622_fail
    jump $I10
  rx622_done:
    rx622_cur."!cursor_fail"()
    if_null rx622_debug, debug_685
    rx622_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_685:
    .return (rx622_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("144_1299450589.65") :method
.annotate 'line', 4
    $P624 = self."!PREFIX__!subrule"("package_def", "role")
    new $P625, "ResizablePMCArray"
    push $P625, $P624
    .return ($P625)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("145_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 313
    new $P632, "Undef"
    .lex "$*PACKAGE-SETUP", $P632
.annotate 'line', 314
    new $P633, "Undef"
    .lex "$*PKGDECL", $P633
.annotate 'line', 4
    .local string rx634_tgt
    .local int rx634_pos
    .local int rx634_off
    .local int rx634_eos
    .local int rx634_rep
    .local pmc rx634_cur
    .local pmc rx634_debug
    (rx634_cur, rx634_pos, rx634_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx634_cur
    .local pmc match
    .lex "$/", match
    length rx634_eos, rx634_tgt
    gt rx634_pos, rx634_eos, rx634_done
    set rx634_off, 0
    lt rx634_pos, 2, rx634_start
    sub rx634_off, rx634_pos, 1
    substr rx634_tgt, rx634_tgt, rx634_off
  rx634_start:
    eq $I10, 1, rx634_restart
    if_null rx634_debug, debug_686
    rx634_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_686:
    $I10 = self.'from'()
    ne $I10, -1, rxscan638_done
    goto rxscan638_scan
  rxscan638_loop:
    (rx634_pos) = rx634_cur."from"()
    inc rx634_pos
    rx634_cur."!cursor_from"(rx634_pos)
    ge rx634_pos, rx634_eos, rxscan638_done
  rxscan638_scan:
    set_addr $I10, rxscan638_loop
    rx634_cur."!mark_push"(0, rx634_pos, $I10)
  rxscan638_done:
.annotate 'line', 313
    rx634_cur."!cursor_pos"(rx634_pos)
    get_hll_global $P639, ["PAST"], "Stmts"
    $P640 = $P639."new"()
    store_lex "$*PACKAGE-SETUP", $P640
.annotate 'line', 314
    rx634_cur."!cursor_pos"(rx634_pos)
    new $P641, "String"
    assign $P641, "native"
    store_lex "$*PKGDECL", $P641
.annotate 'line', 315
  # rx subcapture "sym"
    set_addr $I10, rxcap_642_fail
    rx634_cur."!mark_push"(0, rx634_pos, $I10)
  # rx literal  "native"
    add $I11, rx634_pos, 6
    gt $I11, rx634_eos, rx634_fail
    sub $I11, rx634_pos, rx634_off
    substr $S10, rx634_tgt, $I11, 6
    ne $S10, "native", rx634_fail
    add rx634_pos, 6
    set_addr $I10, rxcap_642_fail
    ($I12, $I11) = rx634_cur."!mark_peek"($I10)
    rx634_cur."!cursor_pos"($I11)
    ($P10) = rx634_cur."!cursor_start"()
    $P10."!cursor_pass"(rx634_pos, "")
    rx634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_642_done
  rxcap_642_fail:
    goto rx634_fail
  rxcap_642_done:
  # rx subrule "package_def" subtype=capture negate=
    rx634_cur."!cursor_pos"(rx634_pos)
    $P10 = rx634_cur."package_def"()
    unless $P10, rx634_fail
    rx634_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx634_pos = $P10."pos"()
.annotate 'line', 312
  # rx pass
    rx634_cur."!cursor_pass"(rx634_pos, "package_declarator:sym<native>")
    if_null rx634_debug, debug_687
    rx634_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx634_pos)
  debug_687:
    .return (rx634_cur)
  rx634_restart:
.annotate 'line', 4
    if_null rx634_debug, debug_688
    rx634_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_688:
  rx634_fail:
    (rx634_rep, rx634_pos, $I10, $P10) = rx634_cur."!mark_fail"(0)
    lt rx634_pos, -1, rx634_done
    eq rx634_pos, -1, rx634_fail
    jump $I10
  rx634_done:
    rx634_cur."!cursor_fail"()
    if_null rx634_debug, debug_689
    rx634_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_689:
    .return (rx634_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("146_1299450589.65") :method
.annotate 'line', 4
    $P636 = self."!PREFIX__!subrule"("package_def", "native")
    new $P637, "ResizablePMCArray"
    push $P637, $P636
    .return ($P637)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("147_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx644_tgt
    .local int rx644_pos
    .local int rx644_off
    .local int rx644_eos
    .local int rx644_rep
    .local pmc rx644_cur
    .local pmc rx644_debug
    (rx644_cur, rx644_pos, rx644_tgt, $I10) = self."!cursor_start"()
    rx644_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx644_cur
    .local pmc match
    .lex "$/", match
    length rx644_eos, rx644_tgt
    gt rx644_pos, rx644_eos, rx644_done
    set rx644_off, 0
    lt rx644_pos, 2, rx644_start
    sub rx644_off, rx644_pos, 1
    substr rx644_tgt, rx644_tgt, rx644_off
  rx644_start:
    eq $I10, 1, rx644_restart
    if_null rx644_debug, debug_690
    rx644_cur."!cursor_debug"("START", "package_def")
  debug_690:
    $I10 = self.'from'()
    ne $I10, -1, rxscan648_done
    goto rxscan648_scan
  rxscan648_loop:
    (rx644_pos) = rx644_cur."from"()
    inc rx644_pos
    rx644_cur."!cursor_from"(rx644_pos)
    ge rx644_pos, rx644_eos, rxscan648_done
  rxscan648_scan:
    set_addr $I10, rxscan648_loop
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxscan648_done:
.annotate 'line', 318
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 319
  # rx subrule "name" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."name"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 320
  # rx rxquantr651 ** 0..1
    set_addr $I10, rxquantr651_done
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxquantr651_loop:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx644_pos, 2
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 2
    ne $S10, "is", rx644_fail
    add rx644_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx644_pos, 5
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 5
    ne $S10, "repr(", rx644_fail
    add rx644_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."quote_EXPR"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx644_pos, 1
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    ord $I11, rx644_tgt, $I11
    ne $I11, 41, rx644_fail
    add rx644_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    set_addr $I10, rxquantr651_done
    (rx644_rep) = rx644_cur."!mark_commit"($I10)
  rxquantr651_done:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 321
  # rx rxquantr658 ** 0..1
    set_addr $I10, rxquantr658_done
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxquantr658_loop:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx644_pos, 2
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 2
    ne $S10, "is", rx644_fail
    add rx644_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."name"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    set_addr $I10, rxquantr658_done
    (rx644_rep) = rx644_cur."!mark_commit"($I10)
  rxquantr658_done:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 322
  # rx rxquantr663 ** 0..*
    set_addr $I10, rxquantr663_done
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
  rxquantr663_loop:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx644_pos, 4
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I11, 4
    ne $S10, "does", rx644_fail
    add rx644_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."name"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    set_addr $I10, rxquantr663_done
    (rx644_rep) = rx644_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr663_done
    rx644_cur."!mark_push"(rx644_rep, rx644_pos, $I10)
    goto rxquantr663_loop
  rxquantr663_done:
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  alt668_0:
.annotate 'line', 323
    set_addr $I10, alt668_1
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
.annotate 'line', 324
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx644_pos, 1
    gt $I11, rx644_eos, rx644_fail
    sub $I11, rx644_pos, rx644_off
    ord $I11, rx644_tgt, $I11
    ne $I11, 59, rx644_fail
    add rx644_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."comp_unit"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    goto alt668_end
  alt668_1:
    set_addr $I10, alt668_2
    rx644_cur."!mark_push"(0, rx644_pos, $I10)
.annotate 'line', 325
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx644_pos, rx644_off
    substr $S10, rx644_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx644_fail
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."block"()
    unless $P10, rx644_fail
    rx644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
    goto alt668_end
  alt668_2:
.annotate 'line', 326
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."panic"("Malformed package declaration")
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
  alt668_end:
.annotate 'line', 327
  # rx subrule "ws" subtype=method negate=
    rx644_cur."!cursor_pos"(rx644_pos)
    $P10 = rx644_cur."ws"()
    unless $P10, rx644_fail
    rx644_pos = $P10."pos"()
.annotate 'line', 318
  # rx pass
    rx644_cur."!cursor_pass"(rx644_pos, "package_def")
    if_null rx644_debug, debug_691
    rx644_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx644_pos)
  debug_691:
    .return (rx644_cur)
  rx644_restart:
.annotate 'line', 4
    if_null rx644_debug, debug_692
    rx644_cur."!cursor_debug"("NEXT", "package_def")
  debug_692:
  rx644_fail:
    (rx644_rep, rx644_pos, $I10, $P10) = rx644_cur."!mark_fail"(0)
    lt rx644_pos, -1, rx644_done
    eq rx644_pos, -1, rx644_fail
    jump $I10
  rx644_done:
    rx644_cur."!cursor_fail"()
    if_null rx644_debug, debug_693
    rx644_cur."!cursor_debug"("FAIL", "package_def")
  debug_693:
    .return (rx644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("148_1299450589.65") :method
.annotate 'line', 4
    $P646 = self."!PREFIX__!subrule"("ws", "")
    new $P647, "ResizablePMCArray"
    push $P647, $P646
    .return ($P647)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("149_1299450589.65")
    .param pmc param_679
.annotate 'line', 330
    .lex "self", param_679
    $P680 = param_679."!protoregex"("scope_declarator")
    .return ($P680)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("150_1299450589.65")
    .param pmc param_682
.annotate 'line', 330
    .lex "self", param_682
    $P683 = param_682."!PREFIX__!protoregex"("scope_declarator")
    .return ($P683)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("151_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx685_tgt
    .local int rx685_pos
    .local int rx685_off
    .local int rx685_eos
    .local int rx685_rep
    .local pmc rx685_cur
    .local pmc rx685_debug
    (rx685_cur, rx685_pos, rx685_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx685_cur
    .local pmc match
    .lex "$/", match
    length rx685_eos, rx685_tgt
    gt rx685_pos, rx685_eos, rx685_done
    set rx685_off, 0
    lt rx685_pos, 2, rx685_start
    sub rx685_off, rx685_pos, 1
    substr rx685_tgt, rx685_tgt, rx685_off
  rx685_start:
    eq $I10, 1, rx685_restart
    if_null rx685_debug, debug_694
    rx685_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_694:
    $I10 = self.'from'()
    ne $I10, -1, rxscan689_done
    goto rxscan689_scan
  rxscan689_loop:
    (rx685_pos) = rx685_cur."from"()
    inc rx685_pos
    rx685_cur."!cursor_from"(rx685_pos)
    ge rx685_pos, rx685_eos, rxscan689_done
  rxscan689_scan:
    set_addr $I10, rxscan689_loop
    rx685_cur."!mark_push"(0, rx685_pos, $I10)
  rxscan689_done:
.annotate 'line', 331
  # rx subcapture "sym"
    set_addr $I10, rxcap_690_fail
    rx685_cur."!mark_push"(0, rx685_pos, $I10)
  # rx literal  "my"
    add $I11, rx685_pos, 2
    gt $I11, rx685_eos, rx685_fail
    sub $I11, rx685_pos, rx685_off
    substr $S10, rx685_tgt, $I11, 2
    ne $S10, "my", rx685_fail
    add rx685_pos, 2
    set_addr $I10, rxcap_690_fail
    ($I12, $I11) = rx685_cur."!mark_peek"($I10)
    rx685_cur."!cursor_pos"($I11)
    ($P10) = rx685_cur."!cursor_start"()
    $P10."!cursor_pass"(rx685_pos, "")
    rx685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_690_done
  rxcap_690_fail:
    goto rx685_fail
  rxcap_690_done:
  # rx subrule "scoped" subtype=capture negate=
    rx685_cur."!cursor_pos"(rx685_pos)
    $P10 = rx685_cur."scoped"("my")
    unless $P10, rx685_fail
    rx685_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx685_pos = $P10."pos"()
  # rx pass
    rx685_cur."!cursor_pass"(rx685_pos, "scope_declarator:sym<my>")
    if_null rx685_debug, debug_695
    rx685_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx685_pos)
  debug_695:
    .return (rx685_cur)
  rx685_restart:
.annotate 'line', 4
    if_null rx685_debug, debug_696
    rx685_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_696:
  rx685_fail:
    (rx685_rep, rx685_pos, $I10, $P10) = rx685_cur."!mark_fail"(0)
    lt rx685_pos, -1, rx685_done
    eq rx685_pos, -1, rx685_fail
    jump $I10
  rx685_done:
    rx685_cur."!cursor_fail"()
    if_null rx685_debug, debug_697
    rx685_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_697:
    .return (rx685_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("152_1299450589.65") :method
.annotate 'line', 4
    $P687 = self."!PREFIX__!subrule"("scoped", "my")
    new $P688, "ResizablePMCArray"
    push $P688, $P687
    .return ($P688)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("153_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx692_tgt
    .local int rx692_pos
    .local int rx692_off
    .local int rx692_eos
    .local int rx692_rep
    .local pmc rx692_cur
    .local pmc rx692_debug
    (rx692_cur, rx692_pos, rx692_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx692_cur
    .local pmc match
    .lex "$/", match
    length rx692_eos, rx692_tgt
    gt rx692_pos, rx692_eos, rx692_done
    set rx692_off, 0
    lt rx692_pos, 2, rx692_start
    sub rx692_off, rx692_pos, 1
    substr rx692_tgt, rx692_tgt, rx692_off
  rx692_start:
    eq $I10, 1, rx692_restart
    if_null rx692_debug, debug_698
    rx692_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_698:
    $I10 = self.'from'()
    ne $I10, -1, rxscan696_done
    goto rxscan696_scan
  rxscan696_loop:
    (rx692_pos) = rx692_cur."from"()
    inc rx692_pos
    rx692_cur."!cursor_from"(rx692_pos)
    ge rx692_pos, rx692_eos, rxscan696_done
  rxscan696_scan:
    set_addr $I10, rxscan696_loop
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  rxscan696_done:
.annotate 'line', 332
  # rx subcapture "sym"
    set_addr $I10, rxcap_697_fail
    rx692_cur."!mark_push"(0, rx692_pos, $I10)
  # rx literal  "our"
    add $I11, rx692_pos, 3
    gt $I11, rx692_eos, rx692_fail
    sub $I11, rx692_pos, rx692_off
    substr $S10, rx692_tgt, $I11, 3
    ne $S10, "our", rx692_fail
    add rx692_pos, 3
    set_addr $I10, rxcap_697_fail
    ($I12, $I11) = rx692_cur."!mark_peek"($I10)
    rx692_cur."!cursor_pos"($I11)
    ($P10) = rx692_cur."!cursor_start"()
    $P10."!cursor_pass"(rx692_pos, "")
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_697_done
  rxcap_697_fail:
    goto rx692_fail
  rxcap_697_done:
  # rx subrule "scoped" subtype=capture negate=
    rx692_cur."!cursor_pos"(rx692_pos)
    $P10 = rx692_cur."scoped"("our")
    unless $P10, rx692_fail
    rx692_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx692_pos = $P10."pos"()
  # rx pass
    rx692_cur."!cursor_pass"(rx692_pos, "scope_declarator:sym<our>")
    if_null rx692_debug, debug_699
    rx692_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx692_pos)
  debug_699:
    .return (rx692_cur)
  rx692_restart:
.annotate 'line', 4
    if_null rx692_debug, debug_700
    rx692_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_700:
  rx692_fail:
    (rx692_rep, rx692_pos, $I10, $P10) = rx692_cur."!mark_fail"(0)
    lt rx692_pos, -1, rx692_done
    eq rx692_pos, -1, rx692_fail
    jump $I10
  rx692_done:
    rx692_cur."!cursor_fail"()
    if_null rx692_debug, debug_701
    rx692_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_701:
    .return (rx692_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("154_1299450589.65") :method
.annotate 'line', 4
    $P694 = self."!PREFIX__!subrule"("scoped", "our")
    new $P695, "ResizablePMCArray"
    push $P695, $P694
    .return ($P695)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("155_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx699_tgt
    .local int rx699_pos
    .local int rx699_off
    .local int rx699_eos
    .local int rx699_rep
    .local pmc rx699_cur
    .local pmc rx699_debug
    (rx699_cur, rx699_pos, rx699_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx699_cur
    .local pmc match
    .lex "$/", match
    length rx699_eos, rx699_tgt
    gt rx699_pos, rx699_eos, rx699_done
    set rx699_off, 0
    lt rx699_pos, 2, rx699_start
    sub rx699_off, rx699_pos, 1
    substr rx699_tgt, rx699_tgt, rx699_off
  rx699_start:
    eq $I10, 1, rx699_restart
    if_null rx699_debug, debug_702
    rx699_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_702:
    $I10 = self.'from'()
    ne $I10, -1, rxscan703_done
    goto rxscan703_scan
  rxscan703_loop:
    (rx699_pos) = rx699_cur."from"()
    inc rx699_pos
    rx699_cur."!cursor_from"(rx699_pos)
    ge rx699_pos, rx699_eos, rxscan703_done
  rxscan703_scan:
    set_addr $I10, rxscan703_loop
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
  rxscan703_done:
.annotate 'line', 333
  # rx subcapture "sym"
    set_addr $I10, rxcap_704_fail
    rx699_cur."!mark_push"(0, rx699_pos, $I10)
  # rx literal  "has"
    add $I11, rx699_pos, 3
    gt $I11, rx699_eos, rx699_fail
    sub $I11, rx699_pos, rx699_off
    substr $S10, rx699_tgt, $I11, 3
    ne $S10, "has", rx699_fail
    add rx699_pos, 3
    set_addr $I10, rxcap_704_fail
    ($I12, $I11) = rx699_cur."!mark_peek"($I10)
    rx699_cur."!cursor_pos"($I11)
    ($P10) = rx699_cur."!cursor_start"()
    $P10."!cursor_pass"(rx699_pos, "")
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_704_done
  rxcap_704_fail:
    goto rx699_fail
  rxcap_704_done:
  # rx subrule "scoped" subtype=capture negate=
    rx699_cur."!cursor_pos"(rx699_pos)
    $P10 = rx699_cur."scoped"("has")
    unless $P10, rx699_fail
    rx699_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx699_pos = $P10."pos"()
  # rx pass
    rx699_cur."!cursor_pass"(rx699_pos, "scope_declarator:sym<has>")
    if_null rx699_debug, debug_703
    rx699_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx699_pos)
  debug_703:
    .return (rx699_cur)
  rx699_restart:
.annotate 'line', 4
    if_null rx699_debug, debug_704
    rx699_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_704:
  rx699_fail:
    (rx699_rep, rx699_pos, $I10, $P10) = rx699_cur."!mark_fail"(0)
    lt rx699_pos, -1, rx699_done
    eq rx699_pos, -1, rx699_fail
    jump $I10
  rx699_done:
    rx699_cur."!cursor_fail"()
    if_null rx699_debug, debug_705
    rx699_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_705:
    .return (rx699_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("156_1299450589.65") :method
.annotate 'line', 4
    $P701 = self."!PREFIX__!subrule"("scoped", "has")
    new $P702, "ResizablePMCArray"
    push $P702, $P701
    .return ($P702)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("157_1299450589.65") :method :outer("11_1299450589.65")
    .param pmc param_706
.annotate 'line', 335
    .lex "$*SCOPE", param_706
.annotate 'line', 4
    .local string rx707_tgt
    .local int rx707_pos
    .local int rx707_off
    .local int rx707_eos
    .local int rx707_rep
    .local pmc rx707_cur
    .local pmc rx707_debug
    (rx707_cur, rx707_pos, rx707_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx707_cur
    .local pmc match
    .lex "$/", match
    length rx707_eos, rx707_tgt
    gt rx707_pos, rx707_eos, rx707_done
    set rx707_off, 0
    lt rx707_pos, 2, rx707_start
    sub rx707_off, rx707_pos, 1
    substr rx707_tgt, rx707_tgt, rx707_off
  rx707_start:
    eq $I10, 1, rx707_restart
    if_null rx707_debug, debug_706
    rx707_cur."!cursor_debug"("START", "scoped")
  debug_706:
    $I10 = self.'from'()
    ne $I10, -1, rxscan712_done
    goto rxscan712_scan
  rxscan712_loop:
    (rx707_pos) = rx707_cur."from"()
    inc rx707_pos
    rx707_cur."!cursor_from"(rx707_pos)
    ge rx707_pos, rx707_eos, rxscan712_done
  rxscan712_scan:
    set_addr $I10, rxscan712_loop
    rx707_cur."!mark_push"(0, rx707_pos, $I10)
  rxscan712_done:
  alt713_0:
.annotate 'line', 335
    set_addr $I10, alt713_1
    rx707_cur."!mark_push"(0, rx707_pos, $I10)
.annotate 'line', 336
  # rx subrule "ws" subtype=method negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."ws"()
    unless $P10, rx707_fail
    rx707_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."declarator"()
    unless $P10, rx707_fail
    rx707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx707_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."ws"()
    unless $P10, rx707_fail
    rx707_pos = $P10."pos"()
    goto alt713_end
  alt713_1:
.annotate 'line', 337
  # rx subrule "ws" subtype=method negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."ws"()
    unless $P10, rx707_fail
    rx707_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."multi_declarator"()
    unless $P10, rx707_fail
    rx707_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx707_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx707_cur."!cursor_pos"(rx707_pos)
    $P10 = rx707_cur."ws"()
    unless $P10, rx707_fail
    rx707_pos = $P10."pos"()
  alt713_end:
.annotate 'line', 335
  # rx pass
    rx707_cur."!cursor_pass"(rx707_pos, "scoped")
    if_null rx707_debug, debug_707
    rx707_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx707_pos)
  debug_707:
    .return (rx707_cur)
  rx707_restart:
.annotate 'line', 4
    if_null rx707_debug, debug_708
    rx707_cur."!cursor_debug"("NEXT", "scoped")
  debug_708:
  rx707_fail:
    (rx707_rep, rx707_pos, $I10, $P10) = rx707_cur."!mark_fail"(0)
    lt rx707_pos, -1, rx707_done
    eq rx707_pos, -1, rx707_fail
    jump $I10
  rx707_done:
    rx707_cur."!cursor_fail"()
    if_null rx707_debug, debug_709
    rx707_cur."!cursor_debug"("FAIL", "scoped")
  debug_709:
    .return (rx707_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("158_1299450589.65") :method
.annotate 'line', 4
    $P709 = self."!PREFIX__!subrule"("ws", "")
    $P710 = self."!PREFIX__!subrule"("ws", "")
    new $P711, "ResizablePMCArray"
    push $P711, $P709
    push $P711, $P710
    .return ($P711)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("159_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx719_tgt
    .local int rx719_pos
    .local int rx719_off
    .local int rx719_eos
    .local int rx719_rep
    .local pmc rx719_cur
    .local pmc rx719_debug
    (rx719_cur, rx719_pos, rx719_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx719_cur
    .local pmc match
    .lex "$/", match
    length rx719_eos, rx719_tgt
    gt rx719_pos, rx719_eos, rx719_done
    set rx719_off, 0
    lt rx719_pos, 2, rx719_start
    sub rx719_off, rx719_pos, 1
    substr rx719_tgt, rx719_tgt, rx719_off
  rx719_start:
    eq $I10, 1, rx719_restart
    if_null rx719_debug, debug_710
    rx719_cur."!cursor_debug"("START", "typename")
  debug_710:
    $I10 = self.'from'()
    ne $I10, -1, rxscan723_done
    goto rxscan723_scan
  rxscan723_loop:
    (rx719_pos) = rx719_cur."from"()
    inc rx719_pos
    rx719_cur."!cursor_from"(rx719_pos)
    ge rx719_pos, rx719_eos, rxscan723_done
  rxscan723_scan:
    set_addr $I10, rxscan723_loop
    rx719_cur."!mark_push"(0, rx719_pos, $I10)
  rxscan723_done:
.annotate 'line', 340
  # rx subrule "name" subtype=capture negate=
    rx719_cur."!cursor_pos"(rx719_pos)
    $P10 = rx719_cur."name"()
    unless $P10, rx719_fail
    rx719_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx719_pos = $P10."pos"()
  # rx pass
    rx719_cur."!cursor_pass"(rx719_pos, "typename")
    if_null rx719_debug, debug_711
    rx719_cur."!cursor_debug"("PASS", "typename", " at pos=", rx719_pos)
  debug_711:
    .return (rx719_cur)
  rx719_restart:
.annotate 'line', 4
    if_null rx719_debug, debug_712
    rx719_cur."!cursor_debug"("NEXT", "typename")
  debug_712:
  rx719_fail:
    (rx719_rep, rx719_pos, $I10, $P10) = rx719_cur."!mark_fail"(0)
    lt rx719_pos, -1, rx719_done
    eq rx719_pos, -1, rx719_fail
    jump $I10
  rx719_done:
    rx719_cur."!cursor_fail"()
    if_null rx719_debug, debug_713
    rx719_cur."!cursor_debug"("FAIL", "typename")
  debug_713:
    .return (rx719_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("160_1299450589.65") :method
.annotate 'line', 4
    $P721 = self."!PREFIX__!subrule"("name", "")
    new $P722, "ResizablePMCArray"
    push $P722, $P721
    .return ($P722)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("161_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx725_tgt
    .local int rx725_pos
    .local int rx725_off
    .local int rx725_eos
    .local int rx725_rep
    .local pmc rx725_cur
    .local pmc rx725_debug
    (rx725_cur, rx725_pos, rx725_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx725_cur
    .local pmc match
    .lex "$/", match
    length rx725_eos, rx725_tgt
    gt rx725_pos, rx725_eos, rx725_done
    set rx725_off, 0
    lt rx725_pos, 2, rx725_start
    sub rx725_off, rx725_pos, 1
    substr rx725_tgt, rx725_tgt, rx725_off
  rx725_start:
    eq $I10, 1, rx725_restart
    if_null rx725_debug, debug_714
    rx725_cur."!cursor_debug"("START", "declarator")
  debug_714:
    $I10 = self.'from'()
    ne $I10, -1, rxscan730_done
    goto rxscan730_scan
  rxscan730_loop:
    (rx725_pos) = rx725_cur."from"()
    inc rx725_pos
    rx725_cur."!cursor_from"(rx725_pos)
    ge rx725_pos, rx725_eos, rxscan730_done
  rxscan730_scan:
    set_addr $I10, rxscan730_loop
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
  rxscan730_done:
  alt731_0:
.annotate 'line', 342
    set_addr $I10, alt731_1
    rx725_cur."!mark_push"(0, rx725_pos, $I10)
.annotate 'line', 343
  # rx subrule "variable_declarator" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."variable_declarator"()
    unless $P10, rx725_fail
    rx725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx725_pos = $P10."pos"()
    goto alt731_end
  alt731_1:
.annotate 'line', 344
  # rx subrule "routine_declarator" subtype=capture negate=
    rx725_cur."!cursor_pos"(rx725_pos)
    $P10 = rx725_cur."routine_declarator"()
    unless $P10, rx725_fail
    rx725_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx725_pos = $P10."pos"()
  alt731_end:
.annotate 'line', 342
  # rx pass
    rx725_cur."!cursor_pass"(rx725_pos, "declarator")
    if_null rx725_debug, debug_715
    rx725_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx725_pos)
  debug_715:
    .return (rx725_cur)
  rx725_restart:
.annotate 'line', 4
    if_null rx725_debug, debug_716
    rx725_cur."!cursor_debug"("NEXT", "declarator")
  debug_716:
  rx725_fail:
    (rx725_rep, rx725_pos, $I10, $P10) = rx725_cur."!mark_fail"(0)
    lt rx725_pos, -1, rx725_done
    eq rx725_pos, -1, rx725_fail
    jump $I10
  rx725_done:
    rx725_cur."!cursor_fail"()
    if_null rx725_debug, debug_717
    rx725_cur."!cursor_debug"("FAIL", "declarator")
  debug_717:
    .return (rx725_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("162_1299450589.65") :method
.annotate 'line', 4
    $P727 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P728 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P729, "ResizablePMCArray"
    push $P729, $P727
    push $P729, $P728
    .return ($P729)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("163_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx733_tgt
    .local int rx733_pos
    .local int rx733_off
    .local int rx733_eos
    .local int rx733_rep
    .local pmc rx733_cur
    .local pmc rx733_debug
    (rx733_cur, rx733_pos, rx733_tgt, $I10) = self."!cursor_start"()
    rx733_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx733_cur
    .local pmc match
    .lex "$/", match
    length rx733_eos, rx733_tgt
    gt rx733_pos, rx733_eos, rx733_done
    set rx733_off, 0
    lt rx733_pos, 2, rx733_start
    sub rx733_off, rx733_pos, 1
    substr rx733_tgt, rx733_tgt, rx733_off
  rx733_start:
    eq $I10, 1, rx733_restart
    if_null rx733_debug, debug_718
    rx733_cur."!cursor_debug"("START", "variable_declarator")
  debug_718:
    $I10 = self.'from'()
    ne $I10, -1, rxscan737_done
    goto rxscan737_scan
  rxscan737_loop:
    (rx733_pos) = rx733_cur."from"()
    inc rx733_pos
    rx733_cur."!cursor_from"(rx733_pos)
    ge rx733_pos, rx733_eos, rxscan737_done
  rxscan737_scan:
    set_addr $I10, rxscan737_loop
    rx733_cur."!mark_push"(0, rx733_pos, $I10)
  rxscan737_done:
.annotate 'line', 347
  # rx subrule "ws" subtype=method negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."ws"()
    unless $P10, rx733_fail
    rx733_pos = $P10."pos"()
  # rx rxquantr739 ** 0..1
    set_addr $I10, rxquantr739_done
    rx733_cur."!mark_push"(0, rx733_pos, $I10)
  rxquantr739_loop:
  # rx subrule "typename" subtype=capture negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."typename"()
    unless $P10, rx733_fail
    goto rxsubrule740_pass
  rxsubrule740_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx733_fail
  rxsubrule740_pass:
    set_addr $I10, rxsubrule740_back
    rx733_cur."!mark_push"(0, rx733_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx733_pos = $P10."pos"()
    set_addr $I10, rxquantr739_done
    (rx733_rep) = rx733_cur."!mark_commit"($I10)
  rxquantr739_done:
  # rx subrule "ws" subtype=method negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."ws"()
    unless $P10, rx733_fail
    rx733_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."variable"()
    unless $P10, rx733_fail
    rx733_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx733_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx733_cur."!cursor_pos"(rx733_pos)
    $P10 = rx733_cur."ws"()
    unless $P10, rx733_fail
    rx733_pos = $P10."pos"()
  # rx pass
    rx733_cur."!cursor_pass"(rx733_pos, "variable_declarator")
    if_null rx733_debug, debug_719
    rx733_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx733_pos)
  debug_719:
    .return (rx733_cur)
  rx733_restart:
.annotate 'line', 4
    if_null rx733_debug, debug_720
    rx733_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_720:
  rx733_fail:
    (rx733_rep, rx733_pos, $I10, $P10) = rx733_cur."!mark_fail"(0)
    lt rx733_pos, -1, rx733_done
    eq rx733_pos, -1, rx733_fail
    jump $I10
  rx733_done:
    rx733_cur."!cursor_fail"()
    if_null rx733_debug, debug_721
    rx733_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_721:
    .return (rx733_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("164_1299450589.65") :method
.annotate 'line', 4
    $P735 = self."!PREFIX__!subrule"("ws", "")
    new $P736, "ResizablePMCArray"
    push $P736, $P735
    .return ($P736)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("165_1299450589.65")
    .param pmc param_744
.annotate 'line', 349
    .lex "self", param_744
    $P745 = param_744."!protoregex"("routine_declarator")
    .return ($P745)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("166_1299450589.65")
    .param pmc param_747
.annotate 'line', 349
    .lex "self", param_747
    $P748 = param_747."!PREFIX__!protoregex"("routine_declarator")
    .return ($P748)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("167_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx750_tgt
    .local int rx750_pos
    .local int rx750_off
    .local int rx750_eos
    .local int rx750_rep
    .local pmc rx750_cur
    .local pmc rx750_debug
    (rx750_cur, rx750_pos, rx750_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx750_cur
    .local pmc match
    .lex "$/", match
    length rx750_eos, rx750_tgt
    gt rx750_pos, rx750_eos, rx750_done
    set rx750_off, 0
    lt rx750_pos, 2, rx750_start
    sub rx750_off, rx750_pos, 1
    substr rx750_tgt, rx750_tgt, rx750_off
  rx750_start:
    eq $I10, 1, rx750_restart
    if_null rx750_debug, debug_722
    rx750_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_722:
    $I10 = self.'from'()
    ne $I10, -1, rxscan754_done
    goto rxscan754_scan
  rxscan754_loop:
    (rx750_pos) = rx750_cur."from"()
    inc rx750_pos
    rx750_cur."!cursor_from"(rx750_pos)
    ge rx750_pos, rx750_eos, rxscan754_done
  rxscan754_scan:
    set_addr $I10, rxscan754_loop
    rx750_cur."!mark_push"(0, rx750_pos, $I10)
  rxscan754_done:
.annotate 'line', 350
  # rx subcapture "sym"
    set_addr $I10, rxcap_755_fail
    rx750_cur."!mark_push"(0, rx750_pos, $I10)
  # rx literal  "sub"
    add $I11, rx750_pos, 3
    gt $I11, rx750_eos, rx750_fail
    sub $I11, rx750_pos, rx750_off
    substr $S10, rx750_tgt, $I11, 3
    ne $S10, "sub", rx750_fail
    add rx750_pos, 3
    set_addr $I10, rxcap_755_fail
    ($I12, $I11) = rx750_cur."!mark_peek"($I10)
    rx750_cur."!cursor_pos"($I11)
    ($P10) = rx750_cur."!cursor_start"()
    $P10."!cursor_pass"(rx750_pos, "")
    rx750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_755_done
  rxcap_755_fail:
    goto rx750_fail
  rxcap_755_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx750_cur."!cursor_pos"(rx750_pos)
    $P10 = rx750_cur."routine_def"()
    unless $P10, rx750_fail
    rx750_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx750_pos = $P10."pos"()
  # rx pass
    rx750_cur."!cursor_pass"(rx750_pos, "routine_declarator:sym<sub>")
    if_null rx750_debug, debug_723
    rx750_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx750_pos)
  debug_723:
    .return (rx750_cur)
  rx750_restart:
.annotate 'line', 4
    if_null rx750_debug, debug_724
    rx750_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_724:
  rx750_fail:
    (rx750_rep, rx750_pos, $I10, $P10) = rx750_cur."!mark_fail"(0)
    lt rx750_pos, -1, rx750_done
    eq rx750_pos, -1, rx750_fail
    jump $I10
  rx750_done:
    rx750_cur."!cursor_fail"()
    if_null rx750_debug, debug_725
    rx750_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_725:
    .return (rx750_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("168_1299450589.65") :method
.annotate 'line', 4
    $P752 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P753, "ResizablePMCArray"
    push $P753, $P752
    .return ($P753)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("169_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx757_tgt
    .local int rx757_pos
    .local int rx757_off
    .local int rx757_eos
    .local int rx757_rep
    .local pmc rx757_cur
    .local pmc rx757_debug
    (rx757_cur, rx757_pos, rx757_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx757_cur
    .local pmc match
    .lex "$/", match
    length rx757_eos, rx757_tgt
    gt rx757_pos, rx757_eos, rx757_done
    set rx757_off, 0
    lt rx757_pos, 2, rx757_start
    sub rx757_off, rx757_pos, 1
    substr rx757_tgt, rx757_tgt, rx757_off
  rx757_start:
    eq $I10, 1, rx757_restart
    if_null rx757_debug, debug_726
    rx757_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_726:
    $I10 = self.'from'()
    ne $I10, -1, rxscan761_done
    goto rxscan761_scan
  rxscan761_loop:
    (rx757_pos) = rx757_cur."from"()
    inc rx757_pos
    rx757_cur."!cursor_from"(rx757_pos)
    ge rx757_pos, rx757_eos, rxscan761_done
  rxscan761_scan:
    set_addr $I10, rxscan761_loop
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  rxscan761_done:
.annotate 'line', 351
  # rx subcapture "sym"
    set_addr $I10, rxcap_762_fail
    rx757_cur."!mark_push"(0, rx757_pos, $I10)
  # rx literal  "method"
    add $I11, rx757_pos, 6
    gt $I11, rx757_eos, rx757_fail
    sub $I11, rx757_pos, rx757_off
    substr $S10, rx757_tgt, $I11, 6
    ne $S10, "method", rx757_fail
    add rx757_pos, 6
    set_addr $I10, rxcap_762_fail
    ($I12, $I11) = rx757_cur."!mark_peek"($I10)
    rx757_cur."!cursor_pos"($I11)
    ($P10) = rx757_cur."!cursor_start"()
    $P10."!cursor_pass"(rx757_pos, "")
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_762_done
  rxcap_762_fail:
    goto rx757_fail
  rxcap_762_done:
  # rx subrule "method_def" subtype=capture negate=
    rx757_cur."!cursor_pos"(rx757_pos)
    $P10 = rx757_cur."method_def"()
    unless $P10, rx757_fail
    rx757_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx757_pos = $P10."pos"()
  # rx pass
    rx757_cur."!cursor_pass"(rx757_pos, "routine_declarator:sym<method>")
    if_null rx757_debug, debug_727
    rx757_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx757_pos)
  debug_727:
    .return (rx757_cur)
  rx757_restart:
.annotate 'line', 4
    if_null rx757_debug, debug_728
    rx757_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_728:
  rx757_fail:
    (rx757_rep, rx757_pos, $I10, $P10) = rx757_cur."!mark_fail"(0)
    lt rx757_pos, -1, rx757_done
    eq rx757_pos, -1, rx757_fail
    jump $I10
  rx757_done:
    rx757_cur."!cursor_fail"()
    if_null rx757_debug, debug_729
    rx757_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_729:
    .return (rx757_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("170_1299450589.65") :method
.annotate 'line', 4
    $P759 = self."!PREFIX__!subrule"("method_def", "method")
    new $P760, "ResizablePMCArray"
    push $P760, $P759
    .return ($P760)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("171_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 354
    new $P764, "Undef"
    .lex "$*RETURN_USED", $P764
.annotate 'line', 4
    .local string rx765_tgt
    .local int rx765_pos
    .local int rx765_off
    .local int rx765_eos
    .local int rx765_rep
    .local pmc rx765_cur
    .local pmc rx765_debug
    (rx765_cur, rx765_pos, rx765_tgt, $I10) = self."!cursor_start"()
    rx765_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx765_cur
    .local pmc match
    .lex "$/", match
    length rx765_eos, rx765_tgt
    gt rx765_pos, rx765_eos, rx765_done
    set rx765_off, 0
    lt rx765_pos, 2, rx765_start
    sub rx765_off, rx765_pos, 1
    substr rx765_tgt, rx765_tgt, rx765_off
  rx765_start:
    eq $I10, 1, rx765_restart
    if_null rx765_debug, debug_730
    rx765_cur."!cursor_debug"("START", "routine_def")
  debug_730:
    $I10 = self.'from'()
    ne $I10, -1, rxscan769_done
    goto rxscan769_scan
  rxscan769_loop:
    (rx765_pos) = rx765_cur."from"()
    inc rx765_pos
    rx765_cur."!cursor_from"(rx765_pos)
    ge rx765_pos, rx765_eos, rxscan769_done
  rxscan769_scan:
    set_addr $I10, rxscan769_loop
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  rxscan769_done:
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 354
    rx765_cur."!cursor_pos"(rx765_pos)
    new $P771, "Integer"
    assign $P771, 0
    store_lex "$*RETURN_USED", $P771
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 355
  # rx rxquantr773 ** 0..1
    set_addr $I10, rxquantr773_done
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  rxquantr773_loop:
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_776_fail
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  # rx rxquantr775 ** 0..1
    set_addr $I10, rxquantr775_done
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  rxquantr775_loop:
  # rx literal  "&"
    add $I11, rx765_pos, 1
    gt $I11, rx765_eos, rx765_fail
    sub $I11, rx765_pos, rx765_off
    ord $I11, rx765_tgt, $I11
    ne $I11, 38, rx765_fail
    add rx765_pos, 1
    set_addr $I10, rxquantr775_done
    (rx765_rep) = rx765_cur."!mark_commit"($I10)
  rxquantr775_done:
    set_addr $I10, rxcap_776_fail
    ($I12, $I11) = rx765_cur."!mark_peek"($I10)
    rx765_cur."!cursor_pos"($I11)
    ($P10) = rx765_cur."!cursor_start"()
    $P10."!cursor_pass"(rx765_pos, "")
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_776_done
  rxcap_776_fail:
    goto rx765_fail
  rxcap_776_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."deflongname"()
    unless $P10, rx765_fail
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
    set_addr $I10, rxquantr773_done
    (rx765_rep) = rx765_cur."!mark_commit"($I10)
  rxquantr773_done:
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 356
  # rx subrule "newpad" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."newpad"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  alt780_0:
.annotate 'line', 357
    set_addr $I10, alt780_1
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx765_pos, 1
    gt $I11, rx765_eos, rx765_fail
    sub $I11, rx765_pos, rx765_off
    ord $I11, rx765_tgt, $I11
    ne $I11, 40, rx765_fail
    add rx765_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."signature"()
    unless $P10, rx765_fail
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx765_pos, 1
    gt $I11, rx765_eos, rx765_fail
    sub $I11, rx765_pos, rx765_off
    ord $I11, rx765_tgt, $I11
    ne $I11, 41, rx765_fail
    add rx765_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
    goto alt780_end
  alt780_1:
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  alt780_end:
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 359
  # rx rxquantr788 ** 0..*
    set_addr $I10, rxquantr788_done
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
  rxquantr788_loop:
  # rx subrule "trait" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."trait"()
    unless $P10, rx765_fail
    goto rxsubrule789_pass
  rxsubrule789_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx765_fail
  rxsubrule789_pass:
    set_addr $I10, rxsubrule789_back
    rx765_cur."!mark_push"(0, rx765_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx765_pos = $P10."pos"()
    set_addr $I10, rxquantr788_done
    (rx765_rep) = rx765_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr788_done
    rx765_cur."!mark_push"(rx765_rep, rx765_pos, $I10)
    goto rxquantr788_loop
  rxquantr788_done:
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  alt791_0:
.annotate 'line', 360
    set_addr $I10, alt791_1
    rx765_cur."!mark_push"(0, rx765_pos, $I10)
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."onlystar"()
    unless $P10, rx765_fail
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
    goto alt791_end
  alt791_1:
.annotate 'line', 362
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."blockoid"()
    unless $P10, rx765_fail
    rx765_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx765_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
  alt791_end:
.annotate 'line', 363
  # rx subrule "ws" subtype=method negate=
    rx765_cur."!cursor_pos"(rx765_pos)
    $P10 = rx765_cur."ws"()
    unless $P10, rx765_fail
    rx765_pos = $P10."pos"()
.annotate 'line', 353
  # rx pass
    rx765_cur."!cursor_pass"(rx765_pos, "routine_def")
    if_null rx765_debug, debug_731
    rx765_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx765_pos)
  debug_731:
    .return (rx765_cur)
  rx765_restart:
.annotate 'line', 4
    if_null rx765_debug, debug_732
    rx765_cur."!cursor_debug"("NEXT", "routine_def")
  debug_732:
  rx765_fail:
    (rx765_rep, rx765_pos, $I10, $P10) = rx765_cur."!mark_fail"(0)
    lt rx765_pos, -1, rx765_done
    eq rx765_pos, -1, rx765_fail
    jump $I10
  rx765_done:
    rx765_cur."!cursor_fail"()
    if_null rx765_debug, debug_733
    rx765_cur."!cursor_debug"("FAIL", "routine_def")
  debug_733:
    .return (rx765_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("172_1299450589.65") :method
.annotate 'line', 4
    $P767 = self."!PREFIX__!subrule"("ws", "")
    new $P768, "ResizablePMCArray"
    push $P768, $P767
    .return ($P768)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("173_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P828 = "175_1299450589.65" 
    capture_lex $P828
.annotate 'line', 367
    new $P798, "Undef"
    .lex "$*RETURN_USED", $P798
.annotate 'line', 368
    new $P799, "Undef"
    .lex "$*INVOCANT_OK", $P799
.annotate 'line', 4
    .local string rx800_tgt
    .local int rx800_pos
    .local int rx800_off
    .local int rx800_eos
    .local int rx800_rep
    .local pmc rx800_cur
    .local pmc rx800_debug
    (rx800_cur, rx800_pos, rx800_tgt, $I10) = self."!cursor_start"()
    rx800_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx800_cur
    .local pmc match
    .lex "$/", match
    length rx800_eos, rx800_tgt
    gt rx800_pos, rx800_eos, rx800_done
    set rx800_off, 0
    lt rx800_pos, 2, rx800_start
    sub rx800_off, rx800_pos, 1
    substr rx800_tgt, rx800_tgt, rx800_off
  rx800_start:
    eq $I10, 1, rx800_restart
    if_null rx800_debug, debug_734
    rx800_cur."!cursor_debug"("START", "method_def")
  debug_734:
    $I10 = self.'from'()
    ne $I10, -1, rxscan804_done
    goto rxscan804_scan
  rxscan804_loop:
    (rx800_pos) = rx800_cur."from"()
    inc rx800_pos
    rx800_cur."!cursor_from"(rx800_pos)
    ge rx800_pos, rx800_eos, rxscan804_done
  rxscan804_scan:
    set_addr $I10, rxscan804_loop
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxscan804_done:
.annotate 'line', 366
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 367
    rx800_cur."!cursor_pos"(rx800_pos)
    new $P806, "Integer"
    assign $P806, 0
    store_lex "$*RETURN_USED", $P806
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 368
    rx800_cur."!cursor_pos"(rx800_pos)
    new $P808, "Integer"
    assign $P808, 1
    store_lex "$*INVOCANT_OK", $P808
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 369
  # rx subcapture "private"
    set_addr $I10, rxcap_811_fail
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  # rx rxquantr810 ** 0..1
    set_addr $I10, rxquantr810_done
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxquantr810_loop:
  # rx literal  "!"
    add $I11, rx800_pos, 1
    gt $I11, rx800_eos, rx800_fail
    sub $I11, rx800_pos, rx800_off
    ord $I11, rx800_tgt, $I11
    ne $I11, 33, rx800_fail
    add rx800_pos, 1
    set_addr $I10, rxquantr810_done
    (rx800_rep) = rx800_cur."!mark_commit"($I10)
  rxquantr810_done:
    set_addr $I10, rxcap_811_fail
    ($I12, $I11) = rx800_cur."!mark_peek"($I10)
    rx800_cur."!cursor_pos"($I11)
    ($P10) = rx800_cur."!cursor_start"()
    $P10."!cursor_pass"(rx800_pos, "")
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_811_done
  rxcap_811_fail:
    goto rx800_fail
  rxcap_811_done:
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 370
  # rx rxquantr813 ** 0..1
    set_addr $I10, rxquantr813_done
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxquantr813_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."deflongname"()
    unless $P10, rx800_fail
    goto rxsubrule814_pass
  rxsubrule814_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx800_fail
  rxsubrule814_pass:
    set_addr $I10, rxsubrule814_back
    rx800_cur."!mark_push"(0, rx800_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx800_pos = $P10."pos"()
    set_addr $I10, rxquantr813_done
    (rx800_rep) = rx800_cur."!mark_commit"($I10)
  rxquantr813_done:
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 371
  # rx subrule "newpad" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."newpad"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt817_0:
.annotate 'line', 372
    set_addr $I10, alt817_1
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx800_pos, 1
    gt $I11, rx800_eos, rx800_fail
    sub $I11, rx800_pos, rx800_off
    ord $I11, rx800_tgt, $I11
    ne $I11, 40, rx800_fail
    add rx800_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."signature"()
    unless $P10, rx800_fail
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx800_pos, 1
    gt $I11, rx800_eos, rx800_fail
    sub $I11, rx800_pos, rx800_off
    ord $I11, rx800_tgt, $I11
    ne $I11, 41, rx800_fail
    add rx800_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
    goto alt817_end
  alt817_1:
.annotate 'line', 373
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt817_end:
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 374
    rx800_cur."!cursor_pos"(rx800_pos)
    find_lex $P825, unicode:"$\x{a2}"
    $P826 = $P825."MATCH"()
    store_lex "$/", $P826
    .const 'Sub' $P828 = "175_1299450589.65" 
    capture_lex $P828
    $P830 = $P828()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 375
  # rx rxquantr832 ** 0..*
    set_addr $I10, rxquantr832_done
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
  rxquantr832_loop:
  # rx subrule "trait" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."trait"()
    unless $P10, rx800_fail
    goto rxsubrule833_pass
  rxsubrule833_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx800_fail
  rxsubrule833_pass:
    set_addr $I10, rxsubrule833_back
    rx800_cur."!mark_push"(0, rx800_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx800_pos = $P10."pos"()
    set_addr $I10, rxquantr832_done
    (rx800_rep) = rx800_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr832_done
    rx800_cur."!mark_push"(rx800_rep, rx800_pos, $I10)
    goto rxquantr832_loop
  rxquantr832_done:
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt835_0:
.annotate 'line', 376
    set_addr $I10, alt835_1
    rx800_cur."!mark_push"(0, rx800_pos, $I10)
.annotate 'line', 377
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."onlystar"()
    unless $P10, rx800_fail
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
    goto alt835_end
  alt835_1:
.annotate 'line', 378
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."blockoid"()
    unless $P10, rx800_fail
    rx800_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx800_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
  alt835_end:
.annotate 'line', 379
  # rx subrule "ws" subtype=method negate=
    rx800_cur."!cursor_pos"(rx800_pos)
    $P10 = rx800_cur."ws"()
    unless $P10, rx800_fail
    rx800_pos = $P10."pos"()
.annotate 'line', 366
  # rx pass
    rx800_cur."!cursor_pass"(rx800_pos, "method_def")
    if_null rx800_debug, debug_735
    rx800_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx800_pos)
  debug_735:
    .return (rx800_cur)
  rx800_restart:
.annotate 'line', 4
    if_null rx800_debug, debug_736
    rx800_cur."!cursor_debug"("NEXT", "method_def")
  debug_736:
  rx800_fail:
    (rx800_rep, rx800_pos, $I10, $P10) = rx800_cur."!mark_fail"(0)
    lt rx800_pos, -1, rx800_done
    eq rx800_pos, -1, rx800_fail
    jump $I10
  rx800_done:
    rx800_cur."!cursor_fail"()
    if_null rx800_debug, debug_737
    rx800_cur."!cursor_debug"("FAIL", "method_def")
  debug_737:
    .return (rx800_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("174_1299450589.65") :method
.annotate 'line', 4
    $P802 = self."!PREFIX__!subrule"("ws", "")
    new $P803, "ResizablePMCArray"
    push $P803, $P802
    .return ($P803)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block827"  :anon :subid("175_1299450589.65") :outer("173_1299450589.65")
.annotate 'line', 374
    new $P829, "Integer"
    assign $P829, 0
    store_dynamic_lex "$*INVOCANT_OK", $P829
    .return ($P829)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("176_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P849 = "178_1299450589.65" 
    capture_lex $P849
    .local string rx842_tgt
    .local int rx842_pos
    .local int rx842_off
    .local int rx842_eos
    .local int rx842_rep
    .local pmc rx842_cur
    .local pmc rx842_debug
    (rx842_cur, rx842_pos, rx842_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx842_cur
    .local pmc match
    .lex "$/", match
    length rx842_eos, rx842_tgt
    gt rx842_pos, rx842_eos, rx842_done
    set rx842_off, 0
    lt rx842_pos, 2, rx842_start
    sub rx842_off, rx842_pos, 1
    substr rx842_tgt, rx842_tgt, rx842_off
  rx842_start:
    eq $I10, 1, rx842_restart
    if_null rx842_debug, debug_738
    rx842_cur."!cursor_debug"("START", "onlystar")
  debug_738:
    $I10 = self.'from'()
    ne $I10, -1, rxscan845_done
    goto rxscan845_scan
  rxscan845_loop:
    (rx842_pos) = rx842_cur."from"()
    inc rx842_pos
    rx842_cur."!cursor_from"(rx842_pos)
    ge rx842_pos, rx842_eos, rxscan845_done
  rxscan845_scan:
    set_addr $I10, rxscan845_loop
    rx842_cur."!mark_push"(0, rx842_pos, $I10)
  rxscan845_done:
.annotate 'line', 383
    rx842_cur."!cursor_pos"(rx842_pos)
    find_lex $P846, unicode:"$\x{a2}"
    $P847 = $P846."MATCH"()
    store_lex "$/", $P847
    .const 'Sub' $P849 = "178_1299450589.65" 
    capture_lex $P849
    $P853 = $P849()
    unless $P853, rx842_fail
.annotate 'line', 384
  # rx literal  "{"
    add $I11, rx842_pos, 1
    gt $I11, rx842_eos, rx842_fail
    sub $I11, rx842_pos, rx842_off
    ord $I11, rx842_tgt, $I11
    ne $I11, 123, rx842_fail
    add rx842_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."ws"()
    unless $P10, rx842_fail
    rx842_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx842_pos, 1
    gt $I11, rx842_eos, rx842_fail
    sub $I11, rx842_pos, rx842_off
    ord $I11, rx842_tgt, $I11
    ne $I11, 42, rx842_fail
    add rx842_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."ws"()
    unless $P10, rx842_fail
    rx842_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx842_pos, 1
    gt $I11, rx842_eos, rx842_fail
    sub $I11, rx842_pos, rx842_off
    ord $I11, rx842_tgt, $I11
    ne $I11, 125, rx842_fail
    add rx842_pos, 1
.annotate 'line', 385
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."ENDSTMT"()
    unless $P10, rx842_fail
.annotate 'line', 386
  # rx subrule "finishpad" subtype=method negate=
    rx842_cur."!cursor_pos"(rx842_pos)
    $P10 = rx842_cur."finishpad"()
    unless $P10, rx842_fail
    rx842_pos = $P10."pos"()
.annotate 'line', 382
  # rx pass
    rx842_cur."!cursor_pass"(rx842_pos, "onlystar")
    if_null rx842_debug, debug_741
    rx842_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx842_pos)
  debug_741:
    .return (rx842_cur)
  rx842_restart:
.annotate 'line', 4
    if_null rx842_debug, debug_742
    rx842_cur."!cursor_debug"("NEXT", "onlystar")
  debug_742:
  rx842_fail:
    (rx842_rep, rx842_pos, $I10, $P10) = rx842_cur."!mark_fail"(0)
    lt rx842_pos, -1, rx842_done
    eq rx842_pos, -1, rx842_fail
    jump $I10
  rx842_done:
    rx842_cur."!cursor_fail"()
    if_null rx842_debug, debug_743
    rx842_cur."!cursor_debug"("FAIL", "onlystar")
  debug_743:
    .return (rx842_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("177_1299450589.65") :method
.annotate 'line', 4
    new $P844, "ResizablePMCArray"
    push $P844, ""
    .return ($P844)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block848"  :anon :subid("178_1299450589.65") :outer("176_1299450589.65")
.annotate 'line', 383
    find_dynamic_lex $P850, "$*MULTINESS"
    unless_null $P850, vivify_739
    get_hll_global $P850, "$MULTINESS"
    unless_null $P850, vivify_740
    die "Contextual $*MULTINESS not found"
  vivify_740:
  vivify_739:
    set $S851, $P850
    iseq $I852, $S851, "proto"
    .return ($I852)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("179_1299450589.65")
    .param pmc param_855
.annotate 'line', 389
    .lex "self", param_855
    $P856 = param_855."!protoregex"("multi_declarator")
    .return ($P856)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("180_1299450589.65")
    .param pmc param_858
.annotate 'line', 389
    .lex "self", param_858
    $P859 = param_858."!PREFIX__!protoregex"("multi_declarator")
    .return ($P859)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("181_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 391
    new $P861, "Undef"
    .lex "$*MULTINESS", $P861
.annotate 'line', 4
    .local string rx862_tgt
    .local int rx862_pos
    .local int rx862_off
    .local int rx862_eos
    .local int rx862_rep
    .local pmc rx862_cur
    .local pmc rx862_debug
    (rx862_cur, rx862_pos, rx862_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx862_cur
    .local pmc match
    .lex "$/", match
    length rx862_eos, rx862_tgt
    gt rx862_pos, rx862_eos, rx862_done
    set rx862_off, 0
    lt rx862_pos, 2, rx862_start
    sub rx862_off, rx862_pos, 1
    substr rx862_tgt, rx862_tgt, rx862_off
  rx862_start:
    eq $I10, 1, rx862_restart
    if_null rx862_debug, debug_744
    rx862_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan866_done
    goto rxscan866_scan
  rxscan866_loop:
    (rx862_pos) = rx862_cur."from"()
    inc rx862_pos
    rx862_cur."!cursor_from"(rx862_pos)
    ge rx862_pos, rx862_eos, rxscan866_done
  rxscan866_scan:
    set_addr $I10, rxscan866_loop
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  rxscan866_done:
.annotate 'line', 391
    rx862_cur."!cursor_pos"(rx862_pos)
    new $P867, "String"
    assign $P867, "multi"
    store_lex "$*MULTINESS", $P867
.annotate 'line', 392
  # rx subcapture "sym"
    set_addr $I10, rxcap_868_fail
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  # rx literal  "multi"
    add $I11, rx862_pos, 5
    gt $I11, rx862_eos, rx862_fail
    sub $I11, rx862_pos, rx862_off
    substr $S10, rx862_tgt, $I11, 5
    ne $S10, "multi", rx862_fail
    add rx862_pos, 5
    set_addr $I10, rxcap_868_fail
    ($I12, $I11) = rx862_cur."!mark_peek"($I10)
    rx862_cur."!cursor_pos"($I11)
    ($P10) = rx862_cur."!cursor_start"()
    $P10."!cursor_pass"(rx862_pos, "")
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_868_done
  rxcap_868_fail:
    goto rx862_fail
  rxcap_868_done:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."ws"()
    unless $P10, rx862_fail
    rx862_pos = $P10."pos"()
  alt869_0:
    set_addr $I10, alt869_1
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."declarator"()
    unless $P10, rx862_fail
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx862_pos = $P10."pos"()
    goto alt869_end
  alt869_1:
    set_addr $I10, alt869_2
    rx862_cur."!mark_push"(0, rx862_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."routine_def"()
    unless $P10, rx862_fail
    rx862_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx862_pos = $P10."pos"()
    goto alt869_end
  alt869_2:
  # rx subrule "panic" subtype=method negate=
    rx862_cur."!cursor_pos"(rx862_pos)
    $P10 = rx862_cur."panic"("Malformed multi")
    unless $P10, rx862_fail
    rx862_pos = $P10."pos"()
  alt869_end:
.annotate 'line', 390
  # rx pass
    rx862_cur."!cursor_pass"(rx862_pos, "multi_declarator:sym<multi>")
    if_null rx862_debug, debug_745
    rx862_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx862_pos)
  debug_745:
    .return (rx862_cur)
  rx862_restart:
.annotate 'line', 4
    if_null rx862_debug, debug_746
    rx862_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_746:
  rx862_fail:
    (rx862_rep, rx862_pos, $I10, $P10) = rx862_cur."!mark_fail"(0)
    lt rx862_pos, -1, rx862_done
    eq rx862_pos, -1, rx862_fail
    jump $I10
  rx862_done:
    rx862_cur."!cursor_fail"()
    if_null rx862_debug, debug_747
    rx862_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_747:
    .return (rx862_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("182_1299450589.65") :method
.annotate 'line', 4
    $P864 = self."!PREFIX__!subrule"("ws", "multi")
    new $P865, "ResizablePMCArray"
    push $P865, $P864
    .return ($P865)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("183_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 396
    new $P871, "Undef"
    .lex "$*MULTINESS", $P871
.annotate 'line', 4
    .local string rx872_tgt
    .local int rx872_pos
    .local int rx872_off
    .local int rx872_eos
    .local int rx872_rep
    .local pmc rx872_cur
    .local pmc rx872_debug
    (rx872_cur, rx872_pos, rx872_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx872_cur
    .local pmc match
    .lex "$/", match
    length rx872_eos, rx872_tgt
    gt rx872_pos, rx872_eos, rx872_done
    set rx872_off, 0
    lt rx872_pos, 2, rx872_start
    sub rx872_off, rx872_pos, 1
    substr rx872_tgt, rx872_tgt, rx872_off
  rx872_start:
    eq $I10, 1, rx872_restart
    if_null rx872_debug, debug_748
    rx872_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan876_done
    goto rxscan876_scan
  rxscan876_loop:
    (rx872_pos) = rx872_cur."from"()
    inc rx872_pos
    rx872_cur."!cursor_from"(rx872_pos)
    ge rx872_pos, rx872_eos, rxscan876_done
  rxscan876_scan:
    set_addr $I10, rxscan876_loop
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  rxscan876_done:
.annotate 'line', 396
    rx872_cur."!cursor_pos"(rx872_pos)
    new $P877, "String"
    assign $P877, "proto"
    store_lex "$*MULTINESS", $P877
.annotate 'line', 397
  # rx subcapture "sym"
    set_addr $I10, rxcap_878_fail
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  # rx literal  "proto"
    add $I11, rx872_pos, 5
    gt $I11, rx872_eos, rx872_fail
    sub $I11, rx872_pos, rx872_off
    substr $S10, rx872_tgt, $I11, 5
    ne $S10, "proto", rx872_fail
    add rx872_pos, 5
    set_addr $I10, rxcap_878_fail
    ($I12, $I11) = rx872_cur."!mark_peek"($I10)
    rx872_cur."!cursor_pos"($I11)
    ($P10) = rx872_cur."!cursor_start"()
    $P10."!cursor_pass"(rx872_pos, "")
    rx872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_878_done
  rxcap_878_fail:
    goto rx872_fail
  rxcap_878_done:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."ws"()
    unless $P10, rx872_fail
    rx872_pos = $P10."pos"()
  alt879_0:
    set_addr $I10, alt879_1
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."declarator"()
    unless $P10, rx872_fail
    rx872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx872_pos = $P10."pos"()
    goto alt879_end
  alt879_1:
    set_addr $I10, alt879_2
    rx872_cur."!mark_push"(0, rx872_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."routine_def"()
    unless $P10, rx872_fail
    rx872_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx872_pos = $P10."pos"()
    goto alt879_end
  alt879_2:
  # rx subrule "panic" subtype=method negate=
    rx872_cur."!cursor_pos"(rx872_pos)
    $P10 = rx872_cur."panic"("Malformed proto")
    unless $P10, rx872_fail
    rx872_pos = $P10."pos"()
  alt879_end:
.annotate 'line', 395
  # rx pass
    rx872_cur."!cursor_pass"(rx872_pos, "multi_declarator:sym<proto>")
    if_null rx872_debug, debug_749
    rx872_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx872_pos)
  debug_749:
    .return (rx872_cur)
  rx872_restart:
.annotate 'line', 4
    if_null rx872_debug, debug_750
    rx872_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_750:
  rx872_fail:
    (rx872_rep, rx872_pos, $I10, $P10) = rx872_cur."!mark_fail"(0)
    lt rx872_pos, -1, rx872_done
    eq rx872_pos, -1, rx872_fail
    jump $I10
  rx872_done:
    rx872_cur."!cursor_fail"()
    if_null rx872_debug, debug_751
    rx872_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_751:
    .return (rx872_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("184_1299450589.65") :method
.annotate 'line', 4
    $P874 = self."!PREFIX__!subrule"("ws", "proto")
    new $P875, "ResizablePMCArray"
    push $P875, $P874
    .return ($P875)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("185_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 401
    new $P881, "Undef"
    .lex "$*MULTINESS", $P881
.annotate 'line', 4
    .local string rx882_tgt
    .local int rx882_pos
    .local int rx882_off
    .local int rx882_eos
    .local int rx882_rep
    .local pmc rx882_cur
    .local pmc rx882_debug
    (rx882_cur, rx882_pos, rx882_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx882_cur
    .local pmc match
    .lex "$/", match
    length rx882_eos, rx882_tgt
    gt rx882_pos, rx882_eos, rx882_done
    set rx882_off, 0
    lt rx882_pos, 2, rx882_start
    sub rx882_off, rx882_pos, 1
    substr rx882_tgt, rx882_tgt, rx882_off
  rx882_start:
    eq $I10, 1, rx882_restart
    if_null rx882_debug, debug_752
    rx882_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan886_done
    goto rxscan886_scan
  rxscan886_loop:
    (rx882_pos) = rx882_cur."from"()
    inc rx882_pos
    rx882_cur."!cursor_from"(rx882_pos)
    ge rx882_pos, rx882_eos, rxscan886_done
  rxscan886_scan:
    set_addr $I10, rxscan886_loop
    rx882_cur."!mark_push"(0, rx882_pos, $I10)
  rxscan886_done:
.annotate 'line', 401
    rx882_cur."!cursor_pos"(rx882_pos)
    new $P887, "String"
    assign $P887, ""
    store_lex "$*MULTINESS", $P887
.annotate 'line', 402
  # rx subrule "declarator" subtype=capture negate=
    rx882_cur."!cursor_pos"(rx882_pos)
    $P10 = rx882_cur."declarator"()
    unless $P10, rx882_fail
    rx882_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx882_pos = $P10."pos"()
.annotate 'line', 400
  # rx pass
    rx882_cur."!cursor_pass"(rx882_pos, "multi_declarator:sym<null>")
    if_null rx882_debug, debug_753
    rx882_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx882_pos)
  debug_753:
    .return (rx882_cur)
  rx882_restart:
.annotate 'line', 4
    if_null rx882_debug, debug_754
    rx882_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_754:
  rx882_fail:
    (rx882_rep, rx882_pos, $I10, $P10) = rx882_cur."!mark_fail"(0)
    lt rx882_pos, -1, rx882_done
    eq rx882_pos, -1, rx882_fail
    jump $I10
  rx882_done:
    rx882_cur."!cursor_fail"()
    if_null rx882_debug, debug_755
    rx882_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_755:
    .return (rx882_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("186_1299450589.65") :method
.annotate 'line', 4
    $P884 = self."!PREFIX__!subrule"("declarator", "")
    new $P885, "ResizablePMCArray"
    push $P885, $P884
    .return ($P885)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("187_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P897 = "189_1299450589.65" 
    capture_lex $P897
    .local string rx889_tgt
    .local int rx889_pos
    .local int rx889_off
    .local int rx889_eos
    .local int rx889_rep
    .local pmc rx889_cur
    .local pmc rx889_debug
    (rx889_cur, rx889_pos, rx889_tgt, $I10) = self."!cursor_start"()
    rx889_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx889_cur
    .local pmc match
    .lex "$/", match
    length rx889_eos, rx889_tgt
    gt rx889_pos, rx889_eos, rx889_done
    set rx889_off, 0
    lt rx889_pos, 2, rx889_start
    sub rx889_off, rx889_pos, 1
    substr rx889_tgt, rx889_tgt, rx889_off
  rx889_start:
    eq $I10, 1, rx889_restart
    if_null rx889_debug, debug_756
    rx889_cur."!cursor_debug"("START", "signature")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan892_done
    goto rxscan892_scan
  rxscan892_loop:
    (rx889_pos) = rx889_cur."from"()
    inc rx889_pos
    rx889_cur."!cursor_from"(rx889_pos)
    ge rx889_pos, rx889_eos, rxscan892_done
  rxscan892_scan:
    set_addr $I10, rxscan892_loop
    rx889_cur."!mark_push"(0, rx889_pos, $I10)
  rxscan892_done:
.annotate 'line', 406
  # rx rxquantr893 ** 0..1
    set_addr $I10, rxquantr893_done
    rx889_cur."!mark_push"(0, rx889_pos, $I10)
  rxquantr893_loop:
    rx889_cur."!cursor_pos"(rx889_pos)
    find_lex $P894, unicode:"$\x{a2}"
    $P895 = $P894."MATCH"()
    store_lex "$/", $P895
    .const 'Sub' $P897 = "189_1299450589.65" 
    capture_lex $P897
    $P899 = $P897()
    unless $P899, rx889_fail
  # rx subrule "ws" subtype=method negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."ws"()
    unless $P10, rx889_fail
    rx889_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."parameter"()
    unless $P10, rx889_fail
    rx889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx889_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."ws"()
    unless $P10, rx889_fail
    rx889_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx889_pos, 1
    gt $I11, rx889_eos, rx889_fail
    sub $I11, rx889_pos, rx889_off
    ord $I11, rx889_tgt, $I11
    ne $I11, 58, rx889_fail
    add rx889_pos, 1
    set_addr $I10, rxquantr893_done
    (rx889_rep) = rx889_cur."!mark_commit"($I10)
  rxquantr893_done:
.annotate 'line', 407
  # rx rxquantr900 ** 0..1
    set_addr $I10, rxquantr900_done
    rx889_cur."!mark_push"(0, rx889_pos, $I10)
  rxquantr900_loop:
  # rx rxquantr901 ** 1..*
    set_addr $I10, rxquantr901_done
    rx889_cur."!mark_push"(0, -1, $I10)
  rxquantr901_loop:
  # rx subrule "ws" subtype=method negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."ws"()
    unless $P10, rx889_fail
    rx889_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."parameter"()
    unless $P10, rx889_fail
    rx889_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx889_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx889_cur."!cursor_pos"(rx889_pos)
    $P10 = rx889_cur."ws"()
    unless $P10, rx889_fail
    rx889_pos = $P10."pos"()
    set_addr $I10, rxquantr901_done
    (rx889_rep) = rx889_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr901_done
    rx889_cur."!mark_push"(rx889_rep, rx889_pos, $I10)
  # rx literal  ","
    add $I11, rx889_pos, 1
    gt $I11, rx889_eos, rx889_fail
    sub $I11, rx889_pos, rx889_off
    ord $I11, rx889_tgt, $I11
    ne $I11, 44, rx889_fail
    add rx889_pos, 1
    goto rxquantr901_loop
  rxquantr901_done:
    set_addr $I10, rxquantr900_done
    (rx889_rep) = rx889_cur."!mark_commit"($I10)
  rxquantr900_done:
.annotate 'line', 405
  # rx pass
    rx889_cur."!cursor_pass"(rx889_pos, "signature")
    if_null rx889_debug, debug_759
    rx889_cur."!cursor_debug"("PASS", "signature", " at pos=", rx889_pos)
  debug_759:
    .return (rx889_cur)
  rx889_restart:
.annotate 'line', 4
    if_null rx889_debug, debug_760
    rx889_cur."!cursor_debug"("NEXT", "signature")
  debug_760:
  rx889_fail:
    (rx889_rep, rx889_pos, $I10, $P10) = rx889_cur."!mark_fail"(0)
    lt rx889_pos, -1, rx889_done
    eq rx889_pos, -1, rx889_fail
    jump $I10
  rx889_done:
    rx889_cur."!cursor_fail"()
    if_null rx889_debug, debug_761
    rx889_cur."!cursor_debug"("FAIL", "signature")
  debug_761:
    .return (rx889_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("188_1299450589.65") :method
.annotate 'line', 4
    new $P891, "ResizablePMCArray"
    push $P891, ""
    .return ($P891)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block896"  :anon :subid("189_1299450589.65") :outer("187_1299450589.65")
.annotate 'line', 406
    find_dynamic_lex $P898, "$*INVOCANT_OK"
    unless_null $P898, vivify_757
    get_hll_global $P898, "$INVOCANT_OK"
    unless_null $P898, vivify_758
    die "Contextual $*INVOCANT_OK not found"
  vivify_758:
  vivify_757:
    .return ($P898)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("190_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx903_tgt
    .local int rx903_pos
    .local int rx903_off
    .local int rx903_eos
    .local int rx903_rep
    .local pmc rx903_cur
    .local pmc rx903_debug
    (rx903_cur, rx903_pos, rx903_tgt, $I10) = self."!cursor_start"()
    rx903_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx903_cur
    .local pmc match
    .lex "$/", match
    length rx903_eos, rx903_tgt
    gt rx903_pos, rx903_eos, rx903_done
    set rx903_off, 0
    lt rx903_pos, 2, rx903_start
    sub rx903_off, rx903_pos, 1
    substr rx903_tgt, rx903_tgt, rx903_off
  rx903_start:
    eq $I10, 1, rx903_restart
    if_null rx903_debug, debug_762
    rx903_cur."!cursor_debug"("START", "parameter")
  debug_762:
    $I10 = self.'from'()
    ne $I10, -1, rxscan906_done
    goto rxscan906_scan
  rxscan906_loop:
    (rx903_pos) = rx903_cur."from"()
    inc rx903_pos
    rx903_cur."!cursor_from"(rx903_pos)
    ge rx903_pos, rx903_eos, rxscan906_done
  rxscan906_scan:
    set_addr $I10, rxscan906_loop
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxscan906_done:
.annotate 'line', 411
  # rx rxquantr907 ** 0..*
    set_addr $I10, rxquantr907_done
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxquantr907_loop:
  # rx subrule "typename" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."typename"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx903_pos = $P10."pos"()
  # rx rxquantr908 ** 0..1
    set_addr $I10, rxquantr908_done
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxquantr908_loop:
  # rx literal  ":"
    add $I11, rx903_pos, 1
    gt $I11, rx903_eos, rx903_fail
    sub $I11, rx903_pos, rx903_off
    ord $I11, rx903_tgt, $I11
    ne $I11, 58, rx903_fail
    add rx903_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_909_fail
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx903_pos, rx903_eos, rx903_fail
    sub $I10, rx903_pos, rx903_off
    substr $S10, rx903_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx903_fail
    inc rx903_pos
    set_addr $I10, rxcap_909_fail
    ($I12, $I11) = rx903_cur."!mark_peek"($I10)
    rx903_cur."!cursor_pos"($I11)
    ($P10) = rx903_cur."!cursor_start"()
    $P10."!cursor_pass"(rx903_pos, "")
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_909_done
  rxcap_909_fail:
    goto rx903_fail
  rxcap_909_done:
    set_addr $I10, rxquantr908_done
    (rx903_rep) = rx903_cur."!mark_commit"($I10)
  rxquantr908_done:
  # rx subrule "ws" subtype=method negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."ws"()
    unless $P10, rx903_fail
    rx903_pos = $P10."pos"()
    set_addr $I10, rxquantr907_done
    (rx903_rep) = rx903_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr907_done
    rx903_cur."!mark_push"(rx903_rep, rx903_pos, $I10)
    goto rxquantr907_loop
  rxquantr907_done:
  alt910_0:
.annotate 'line', 412
    set_addr $I10, alt910_1
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
.annotate 'line', 413
  # rx subcapture "quant"
    set_addr $I10, rxcap_911_fail
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx literal  "*"
    add $I11, rx903_pos, 1
    gt $I11, rx903_eos, rx903_fail
    sub $I11, rx903_pos, rx903_off
    ord $I11, rx903_tgt, $I11
    ne $I11, 42, rx903_fail
    add rx903_pos, 1
    set_addr $I10, rxcap_911_fail
    ($I12, $I11) = rx903_cur."!mark_peek"($I10)
    rx903_cur."!cursor_pos"($I11)
    ($P10) = rx903_cur."!cursor_start"()
    $P10."!cursor_pass"(rx903_pos, "")
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_911_done
  rxcap_911_fail:
    goto rx903_fail
  rxcap_911_done:
  # rx subrule "param_var" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."param_var"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx903_pos = $P10."pos"()
    goto alt910_end
  alt910_1:
  alt912_0:
.annotate 'line', 414
    set_addr $I10, alt912_1
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."param_var"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx903_pos = $P10."pos"()
    goto alt912_end
  alt912_1:
  # rx subrule "named_param" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."named_param"()
    unless $P10, rx903_fail
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx903_pos = $P10."pos"()
  alt912_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_914_fail
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  alt913_0:
    set_addr $I10, alt913_1
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx literal  "?"
    add $I11, rx903_pos, 1
    gt $I11, rx903_eos, rx903_fail
    sub $I11, rx903_pos, rx903_off
    ord $I11, rx903_tgt, $I11
    ne $I11, 63, rx903_fail
    add rx903_pos, 1
    goto alt913_end
  alt913_1:
    set_addr $I10, alt913_2
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  # rx literal  "!"
    add $I11, rx903_pos, 1
    gt $I11, rx903_eos, rx903_fail
    sub $I11, rx903_pos, rx903_off
    ord $I11, rx903_tgt, $I11
    ne $I11, 33, rx903_fail
    add rx903_pos, 1
    goto alt913_end
  alt913_2:
  alt913_end:
    set_addr $I10, rxcap_914_fail
    ($I12, $I11) = rx903_cur."!mark_peek"($I10)
    rx903_cur."!cursor_pos"($I11)
    ($P10) = rx903_cur."!cursor_start"()
    $P10."!cursor_pass"(rx903_pos, "")
    rx903_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_914_done
  rxcap_914_fail:
    goto rx903_fail
  rxcap_914_done:
  alt910_end:
.annotate 'line', 416
  # rx rxquantr915 ** 0..1
    set_addr $I10, rxquantr915_done
    rx903_cur."!mark_push"(0, rx903_pos, $I10)
  rxquantr915_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx903_cur."!cursor_pos"(rx903_pos)
    $P10 = rx903_cur."default_value"()
    unless $P10, rx903_fail
    goto rxsubrule916_pass
  rxsubrule916_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx903_fail
  rxsubrule916_pass:
    set_addr $I10, rxsubrule916_back
    rx903_cur."!mark_push"(0, rx903_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx903_pos = $P10."pos"()
    set_addr $I10, rxquantr915_done
    (rx903_rep) = rx903_cur."!mark_commit"($I10)
  rxquantr915_done:
.annotate 'line', 410
  # rx pass
    rx903_cur."!cursor_pass"(rx903_pos, "parameter")
    if_null rx903_debug, debug_763
    rx903_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx903_pos)
  debug_763:
    .return (rx903_cur)
  rx903_restart:
.annotate 'line', 4
    if_null rx903_debug, debug_764
    rx903_cur."!cursor_debug"("NEXT", "parameter")
  debug_764:
  rx903_fail:
    (rx903_rep, rx903_pos, $I10, $P10) = rx903_cur."!mark_fail"(0)
    lt rx903_pos, -1, rx903_done
    eq rx903_pos, -1, rx903_fail
    jump $I10
  rx903_done:
    rx903_cur."!cursor_fail"()
    if_null rx903_debug, debug_765
    rx903_cur."!cursor_debug"("FAIL", "parameter")
  debug_765:
    .return (rx903_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("191_1299450589.65") :method
.annotate 'line', 4
    new $P905, "ResizablePMCArray"
    push $P905, ""
    .return ($P905)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("192_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx918_tgt
    .local int rx918_pos
    .local int rx918_off
    .local int rx918_eos
    .local int rx918_rep
    .local pmc rx918_cur
    .local pmc rx918_debug
    (rx918_cur, rx918_pos, rx918_tgt, $I10) = self."!cursor_start"()
    rx918_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx918_cur
    .local pmc match
    .lex "$/", match
    length rx918_eos, rx918_tgt
    gt rx918_pos, rx918_eos, rx918_done
    set rx918_off, 0
    lt rx918_pos, 2, rx918_start
    sub rx918_off, rx918_pos, 1
    substr rx918_tgt, rx918_tgt, rx918_off
  rx918_start:
    eq $I10, 1, rx918_restart
    if_null rx918_debug, debug_766
    rx918_cur."!cursor_debug"("START", "param_var")
  debug_766:
    $I10 = self.'from'()
    ne $I10, -1, rxscan922_done
    goto rxscan922_scan
  rxscan922_loop:
    (rx918_pos) = rx918_cur."from"()
    inc rx918_pos
    rx918_cur."!cursor_from"(rx918_pos)
    ge rx918_pos, rx918_eos, rxscan922_done
  rxscan922_scan:
    set_addr $I10, rxscan922_loop
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  rxscan922_done:
.annotate 'line', 420
  # rx subrule "sigil" subtype=capture negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."sigil"()
    unless $P10, rx918_fail
    rx918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx918_pos = $P10."pos"()
  # rx rxquantr923 ** 0..1
    set_addr $I10, rxquantr923_done
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  rxquantr923_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."twigil"()
    unless $P10, rx918_fail
    goto rxsubrule924_pass
  rxsubrule924_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx918_fail
  rxsubrule924_pass:
    set_addr $I10, rxsubrule924_back
    rx918_cur."!mark_push"(0, rx918_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx918_pos = $P10."pos"()
    set_addr $I10, rxquantr923_done
    (rx918_rep) = rx918_cur."!mark_commit"($I10)
  rxquantr923_done:
  alt925_0:
.annotate 'line', 421
    set_addr $I10, alt925_1
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx918_cur."!cursor_pos"(rx918_pos)
    $P10 = rx918_cur."ident"()
    unless $P10, rx918_fail
    rx918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx918_pos = $P10."pos"()
    goto alt925_end
  alt925_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_926_fail
    rx918_cur."!mark_push"(0, rx918_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx918_pos, rx918_eos, rx918_fail
    sub $I10, rx918_pos, rx918_off
    substr $S10, rx918_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx918_fail
    inc rx918_pos
    set_addr $I10, rxcap_926_fail
    ($I12, $I11) = rx918_cur."!mark_peek"($I10)
    rx918_cur."!cursor_pos"($I11)
    ($P10) = rx918_cur."!cursor_start"()
    $P10."!cursor_pass"(rx918_pos, "")
    rx918_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_926_done
  rxcap_926_fail:
    goto rx918_fail
  rxcap_926_done:
  alt925_end:
.annotate 'line', 419
  # rx pass
    rx918_cur."!cursor_pass"(rx918_pos, "param_var")
    if_null rx918_debug, debug_767
    rx918_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx918_pos)
  debug_767:
    .return (rx918_cur)
  rx918_restart:
.annotate 'line', 4
    if_null rx918_debug, debug_768
    rx918_cur."!cursor_debug"("NEXT", "param_var")
  debug_768:
  rx918_fail:
    (rx918_rep, rx918_pos, $I10, $P10) = rx918_cur."!mark_fail"(0)
    lt rx918_pos, -1, rx918_done
    eq rx918_pos, -1, rx918_fail
    jump $I10
  rx918_done:
    rx918_cur."!cursor_fail"()
    if_null rx918_debug, debug_769
    rx918_cur."!cursor_debug"("FAIL", "param_var")
  debug_769:
    .return (rx918_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("193_1299450589.65") :method
.annotate 'line', 4
    $P920 = self."!PREFIX__!subrule"("sigil", "")
    new $P921, "ResizablePMCArray"
    push $P921, $P920
    .return ($P921)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("194_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx928_tgt
    .local int rx928_pos
    .local int rx928_off
    .local int rx928_eos
    .local int rx928_rep
    .local pmc rx928_cur
    .local pmc rx928_debug
    (rx928_cur, rx928_pos, rx928_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx928_cur
    .local pmc match
    .lex "$/", match
    length rx928_eos, rx928_tgt
    gt rx928_pos, rx928_eos, rx928_done
    set rx928_off, 0
    lt rx928_pos, 2, rx928_start
    sub rx928_off, rx928_pos, 1
    substr rx928_tgt, rx928_tgt, rx928_off
  rx928_start:
    eq $I10, 1, rx928_restart
    if_null rx928_debug, debug_770
    rx928_cur."!cursor_debug"("START", "named_param")
  debug_770:
    $I10 = self.'from'()
    ne $I10, -1, rxscan932_done
    goto rxscan932_scan
  rxscan932_loop:
    (rx928_pos) = rx928_cur."from"()
    inc rx928_pos
    rx928_cur."!cursor_from"(rx928_pos)
    ge rx928_pos, rx928_eos, rxscan932_done
  rxscan932_scan:
    set_addr $I10, rxscan932_loop
    rx928_cur."!mark_push"(0, rx928_pos, $I10)
  rxscan932_done:
.annotate 'line', 425
  # rx literal  ":"
    add $I11, rx928_pos, 1
    gt $I11, rx928_eos, rx928_fail
    sub $I11, rx928_pos, rx928_off
    ord $I11, rx928_tgt, $I11
    ne $I11, 58, rx928_fail
    add rx928_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx928_cur."!cursor_pos"(rx928_pos)
    $P10 = rx928_cur."param_var"()
    unless $P10, rx928_fail
    rx928_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx928_pos = $P10."pos"()
.annotate 'line', 424
  # rx pass
    rx928_cur."!cursor_pass"(rx928_pos, "named_param")
    if_null rx928_debug, debug_771
    rx928_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx928_pos)
  debug_771:
    .return (rx928_cur)
  rx928_restart:
.annotate 'line', 4
    if_null rx928_debug, debug_772
    rx928_cur."!cursor_debug"("NEXT", "named_param")
  debug_772:
  rx928_fail:
    (rx928_rep, rx928_pos, $I10, $P10) = rx928_cur."!mark_fail"(0)
    lt rx928_pos, -1, rx928_done
    eq rx928_pos, -1, rx928_fail
    jump $I10
  rx928_done:
    rx928_cur."!cursor_fail"()
    if_null rx928_debug, debug_773
    rx928_cur."!cursor_debug"("FAIL", "named_param")
  debug_773:
    .return (rx928_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("195_1299450589.65") :method
.annotate 'line', 4
    $P930 = self."!PREFIX__!subrule"("param_var", ":")
    new $P931, "ResizablePMCArray"
    push $P931, $P930
    .return ($P931)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("196_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx934_tgt
    .local int rx934_pos
    .local int rx934_off
    .local int rx934_eos
    .local int rx934_rep
    .local pmc rx934_cur
    .local pmc rx934_debug
    (rx934_cur, rx934_pos, rx934_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx934_cur
    .local pmc match
    .lex "$/", match
    length rx934_eos, rx934_tgt
    gt rx934_pos, rx934_eos, rx934_done
    set rx934_off, 0
    lt rx934_pos, 2, rx934_start
    sub rx934_off, rx934_pos, 1
    substr rx934_tgt, rx934_tgt, rx934_off
  rx934_start:
    eq $I10, 1, rx934_restart
    if_null rx934_debug, debug_774
    rx934_cur."!cursor_debug"("START", "default_value")
  debug_774:
    $I10 = self.'from'()
    ne $I10, -1, rxscan938_done
    goto rxscan938_scan
  rxscan938_loop:
    (rx934_pos) = rx934_cur."from"()
    inc rx934_pos
    rx934_cur."!cursor_from"(rx934_pos)
    ge rx934_pos, rx934_eos, rxscan938_done
  rxscan938_scan:
    set_addr $I10, rxscan938_loop
    rx934_cur."!mark_push"(0, rx934_pos, $I10)
  rxscan938_done:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."ws"()
    unless $P10, rx934_fail
    rx934_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx934_pos, 1
    gt $I11, rx934_eos, rx934_fail
    sub $I11, rx934_pos, rx934_off
    ord $I11, rx934_tgt, $I11
    ne $I11, 61, rx934_fail
    add rx934_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."ws"()
    unless $P10, rx934_fail
    rx934_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."EXPR"("i=")
    unless $P10, rx934_fail
    rx934_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx934_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx934_cur."!cursor_pos"(rx934_pos)
    $P10 = rx934_cur."ws"()
    unless $P10, rx934_fail
    rx934_pos = $P10."pos"()
  # rx pass
    rx934_cur."!cursor_pass"(rx934_pos, "default_value")
    if_null rx934_debug, debug_775
    rx934_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx934_pos)
  debug_775:
    .return (rx934_cur)
  rx934_restart:
.annotate 'line', 4
    if_null rx934_debug, debug_776
    rx934_cur."!cursor_debug"("NEXT", "default_value")
  debug_776:
  rx934_fail:
    (rx934_rep, rx934_pos, $I10, $P10) = rx934_cur."!mark_fail"(0)
    lt rx934_pos, -1, rx934_done
    eq rx934_pos, -1, rx934_fail
    jump $I10
  rx934_done:
    rx934_cur."!cursor_fail"()
    if_null rx934_debug, debug_777
    rx934_cur."!cursor_debug"("FAIL", "default_value")
  debug_777:
    .return (rx934_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("197_1299450589.65") :method
.annotate 'line', 4
    $P936 = self."!PREFIX__!subrule"("ws", "")
    new $P937, "ResizablePMCArray"
    push $P937, $P936
    .return ($P937)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("198_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx943_tgt
    .local int rx943_pos
    .local int rx943_off
    .local int rx943_eos
    .local int rx943_rep
    .local pmc rx943_cur
    .local pmc rx943_debug
    (rx943_cur, rx943_pos, rx943_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx943_cur
    .local pmc match
    .lex "$/", match
    length rx943_eos, rx943_tgt
    gt rx943_pos, rx943_eos, rx943_done
    set rx943_off, 0
    lt rx943_pos, 2, rx943_start
    sub rx943_off, rx943_pos, 1
    substr rx943_tgt, rx943_tgt, rx943_off
  rx943_start:
    eq $I10, 1, rx943_restart
    if_null rx943_debug, debug_778
    rx943_cur."!cursor_debug"("START", "trait")
  debug_778:
    $I10 = self.'from'()
    ne $I10, -1, rxscan947_done
    goto rxscan947_scan
  rxscan947_loop:
    (rx943_pos) = rx943_cur."from"()
    inc rx943_pos
    rx943_cur."!cursor_from"(rx943_pos)
    ge rx943_pos, rx943_eos, rxscan947_done
  rxscan947_scan:
    set_addr $I10, rxscan947_loop
    rx943_cur."!mark_push"(0, rx943_pos, $I10)
  rxscan947_done:
.annotate 'line', 430
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."trait_mod"()
    unless $P10, rx943_fail
    rx943_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx943_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx943_cur."!cursor_pos"(rx943_pos)
    $P10 = rx943_cur."ws"()
    unless $P10, rx943_fail
    rx943_pos = $P10."pos"()
  # rx pass
    rx943_cur."!cursor_pass"(rx943_pos, "trait")
    if_null rx943_debug, debug_779
    rx943_cur."!cursor_debug"("PASS", "trait", " at pos=", rx943_pos)
  debug_779:
    .return (rx943_cur)
  rx943_restart:
.annotate 'line', 4
    if_null rx943_debug, debug_780
    rx943_cur."!cursor_debug"("NEXT", "trait")
  debug_780:
  rx943_fail:
    (rx943_rep, rx943_pos, $I10, $P10) = rx943_cur."!mark_fail"(0)
    lt rx943_pos, -1, rx943_done
    eq rx943_pos, -1, rx943_fail
    jump $I10
  rx943_done:
    rx943_cur."!cursor_fail"()
    if_null rx943_debug, debug_781
    rx943_cur."!cursor_debug"("FAIL", "trait")
  debug_781:
    .return (rx943_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("199_1299450589.65") :method
.annotate 'line', 4
    $P945 = self."!PREFIX__!subrule"("ws", "")
    new $P946, "ResizablePMCArray"
    push $P946, $P945
    .return ($P946)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("200_1299450589.65")
    .param pmc param_951
.annotate 'line', 432
    .lex "self", param_951
    $P952 = param_951."!protoregex"("trait_mod")
    .return ($P952)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("201_1299450589.65")
    .param pmc param_954
.annotate 'line', 432
    .lex "self", param_954
    $P955 = param_954."!PREFIX__!protoregex"("trait_mod")
    .return ($P955)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("202_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx957_tgt
    .local int rx957_pos
    .local int rx957_off
    .local int rx957_eos
    .local int rx957_rep
    .local pmc rx957_cur
    .local pmc rx957_debug
    (rx957_cur, rx957_pos, rx957_tgt, $I10) = self."!cursor_start"()
    rx957_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx957_cur
    .local pmc match
    .lex "$/", match
    length rx957_eos, rx957_tgt
    gt rx957_pos, rx957_eos, rx957_done
    set rx957_off, 0
    lt rx957_pos, 2, rx957_start
    sub rx957_off, rx957_pos, 1
    substr rx957_tgt, rx957_tgt, rx957_off
  rx957_start:
    eq $I10, 1, rx957_restart
    if_null rx957_debug, debug_782
    rx957_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_782:
    $I10 = self.'from'()
    ne $I10, -1, rxscan961_done
    goto rxscan961_scan
  rxscan961_loop:
    (rx957_pos) = rx957_cur."from"()
    inc rx957_pos
    rx957_cur."!cursor_from"(rx957_pos)
    ge rx957_pos, rx957_eos, rxscan961_done
  rxscan961_scan:
    set_addr $I10, rxscan961_loop
    rx957_cur."!mark_push"(0, rx957_pos, $I10)
  rxscan961_done:
.annotate 'line', 433
  # rx subcapture "sym"
    set_addr $I10, rxcap_962_fail
    rx957_cur."!mark_push"(0, rx957_pos, $I10)
  # rx literal  "is"
    add $I11, rx957_pos, 2
    gt $I11, rx957_eos, rx957_fail
    sub $I11, rx957_pos, rx957_off
    substr $S10, rx957_tgt, $I11, 2
    ne $S10, "is", rx957_fail
    add rx957_pos, 2
    set_addr $I10, rxcap_962_fail
    ($I12, $I11) = rx957_cur."!mark_peek"($I10)
    rx957_cur."!cursor_pos"($I11)
    ($P10) = rx957_cur."!cursor_start"()
    $P10."!cursor_pass"(rx957_pos, "")
    rx957_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_962_done
  rxcap_962_fail:
    goto rx957_fail
  rxcap_962_done:
  # rx subrule "ws" subtype=method negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."ws"()
    unless $P10, rx957_fail
    rx957_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."deflongname"()
    unless $P10, rx957_fail
    rx957_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx957_pos = $P10."pos"()
  # rx rxquantr964 ** 0..1
    set_addr $I10, rxquantr964_done
    rx957_cur."!mark_push"(0, rx957_pos, $I10)
  rxquantr964_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."circumfix"()
    unless $P10, rx957_fail
    goto rxsubrule965_pass
  rxsubrule965_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx957_fail
  rxsubrule965_pass:
    set_addr $I10, rxsubrule965_back
    rx957_cur."!mark_push"(0, rx957_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx957_pos = $P10."pos"()
    set_addr $I10, rxquantr964_done
    (rx957_rep) = rx957_cur."!mark_commit"($I10)
  rxquantr964_done:
  # rx subrule "ws" subtype=method negate=
    rx957_cur."!cursor_pos"(rx957_pos)
    $P10 = rx957_cur."ws"()
    unless $P10, rx957_fail
    rx957_pos = $P10."pos"()
  # rx pass
    rx957_cur."!cursor_pass"(rx957_pos, "trait_mod:sym<is>")
    if_null rx957_debug, debug_783
    rx957_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx957_pos)
  debug_783:
    .return (rx957_cur)
  rx957_restart:
.annotate 'line', 4
    if_null rx957_debug, debug_784
    rx957_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_784:
  rx957_fail:
    (rx957_rep, rx957_pos, $I10, $P10) = rx957_cur."!mark_fail"(0)
    lt rx957_pos, -1, rx957_done
    eq rx957_pos, -1, rx957_fail
    jump $I10
  rx957_done:
    rx957_cur."!cursor_fail"()
    if_null rx957_debug, debug_785
    rx957_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_785:
    .return (rx957_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("203_1299450589.65") :method
.annotate 'line', 4
    $P959 = self."!PREFIX__!subrule"("ws", "is")
    new $P960, "ResizablePMCArray"
    push $P960, $P959
    .return ($P960)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("204_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx968_tgt
    .local int rx968_pos
    .local int rx968_off
    .local int rx968_eos
    .local int rx968_rep
    .local pmc rx968_cur
    .local pmc rx968_debug
    (rx968_cur, rx968_pos, rx968_tgt, $I10) = self."!cursor_start"()
    rx968_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx968_cur
    .local pmc match
    .lex "$/", match
    length rx968_eos, rx968_tgt
    gt rx968_pos, rx968_eos, rx968_done
    set rx968_off, 0
    lt rx968_pos, 2, rx968_start
    sub rx968_off, rx968_pos, 1
    substr rx968_tgt, rx968_tgt, rx968_off
  rx968_start:
    eq $I10, 1, rx968_restart
    if_null rx968_debug, debug_786
    rx968_cur."!cursor_debug"("START", "regex_declarator")
  debug_786:
    $I10 = self.'from'()
    ne $I10, -1, rxscan972_done
    goto rxscan972_scan
  rxscan972_loop:
    (rx968_pos) = rx968_cur."from"()
    inc rx968_pos
    rx968_cur."!cursor_from"(rx968_pos)
    ge rx968_pos, rx968_eos, rxscan972_done
  rxscan972_scan:
    set_addr $I10, rxscan972_loop
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  rxscan972_done:
.annotate 'line', 435
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt974_0:
.annotate 'line', 436
    set_addr $I10, alt974_1
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
.annotate 'line', 437
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_976_fail
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "proto"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "proto", rx968_fail
    add rx968_pos, 5
    set_addr $I10, rxcap_976_fail
    ($I12, $I11) = rx968_cur."!mark_peek"($I10)
    rx968_cur."!cursor_pos"($I11)
    ($P10) = rx968_cur."!cursor_start"()
    $P10."!cursor_pass"(rx968_pos, "")
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_976_done
  rxcap_976_fail:
    goto rx968_fail
  rxcap_976_done:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt978_0:
    set_addr $I10, alt978_1
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "regex"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "regex", rx968_fail
    add rx968_pos, 5
    goto alt978_end
  alt978_1:
    set_addr $I10, alt978_2
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "token"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "token", rx968_fail
    add rx968_pos, 5
    goto alt978_end
  alt978_2:
  # rx literal  "rule"
    add $I11, rx968_pos, 4
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 4
    ne $S10, "rule", rx968_fail
    add rx968_pos, 4
  alt978_end:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 438
  # rx subrule "deflongname" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."deflongname"()
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt981_0:
.annotate 'line', 439
    set_addr $I10, alt981_1
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
.annotate 'line', 440
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 123, rx968_fail
    add rx968_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "<...>", rx968_fail
    add rx968_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 125, rx968_fail
    add rx968_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ENDSTMT"()
    unless $P10, rx968_fail
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
    goto alt981_end
  alt981_1:
    set_addr $I10, alt981_2
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
.annotate 'line', 441
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 123, rx968_fail
    add rx968_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx968_pos, 3
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 3
    ne $S10, "<*>", rx968_fail
    add rx968_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 125, rx968_fail
    add rx968_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ENDSTMT"()
    unless $P10, rx968_fail
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
    goto alt981_end
  alt981_2:
.annotate 'line', 442
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt981_end:
.annotate 'line', 443
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 437
    goto alt974_end
  alt974_1:
.annotate 'line', 444
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_995_fail
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  alt994_0:
    set_addr $I10, alt994_1
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "regex"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "regex", rx968_fail
    add rx968_pos, 5
    goto alt994_end
  alt994_1:
    set_addr $I10, alt994_2
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  # rx literal  "token"
    add $I11, rx968_pos, 5
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 5
    ne $S10, "token", rx968_fail
    add rx968_pos, 5
    goto alt994_end
  alt994_2:
  # rx literal  "rule"
    add $I11, rx968_pos, 4
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    substr $S10, rx968_tgt, $I11, 4
    ne $S10, "rule", rx968_fail
    add rx968_pos, 4
  alt994_end:
    set_addr $I10, rxcap_995_fail
    ($I12, $I11) = rx968_cur."!mark_peek"($I10)
    rx968_cur."!cursor_pos"($I11)
    ($P10) = rx968_cur."!cursor_start"()
    $P10."!cursor_pass"(rx968_pos, "")
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_995_done
  rxcap_995_fail:
    goto rx968_fail
  rxcap_995_done:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 445
  # rx subrule "deflongname" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."deflongname"()
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 446
  # rx subrule "newpad" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."newpad"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 447
  # rx rxquantr999 ** 0..1
    set_addr $I10, rxquantr999_done
    rx968_cur."!mark_push"(0, rx968_pos, $I10)
  rxquantr999_loop:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 40, rx968_fail
    add rx968_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."signature"()
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx968_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 41, rx968_fail
    add rx968_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
    set_addr $I10, rxquantr999_done
    (rx968_rep) = rx968_cur."!mark_commit"($I10)
  rxquantr999_done:
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 448
  # rx reduce name="regex_declarator" key="open"
    rx968_cur."!cursor_pos"(rx968_pos)
    rx968_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 449
  # rx literal  "{"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 123, rx968_fail
    add rx968_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."LANG"("Regex", "nibbler")
    unless $P10, rx968_fail
    rx968_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx968_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx968_pos, 1
    gt $I11, rx968_eos, rx968_fail
    sub $I11, rx968_pos, rx968_off
    ord $I11, rx968_tgt, $I11
    ne $I11, 125, rx968_fail
    add rx968_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ENDSTMT"()
    unless $P10, rx968_fail
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
  alt974_end:
.annotate 'line', 450
  # rx subrule "ws" subtype=method negate=
    rx968_cur."!cursor_pos"(rx968_pos)
    $P10 = rx968_cur."ws"()
    unless $P10, rx968_fail
    rx968_pos = $P10."pos"()
.annotate 'line', 435
  # rx pass
    rx968_cur."!cursor_pass"(rx968_pos, "regex_declarator")
    if_null rx968_debug, debug_787
    rx968_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx968_pos)
  debug_787:
    .return (rx968_cur)
  rx968_restart:
.annotate 'line', 4
    if_null rx968_debug, debug_788
    rx968_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_788:
  rx968_fail:
    (rx968_rep, rx968_pos, $I10, $P10) = rx968_cur."!mark_fail"(0)
    lt rx968_pos, -1, rx968_done
    eq rx968_pos, -1, rx968_fail
    jump $I10
  rx968_done:
    rx968_cur."!cursor_fail"()
    if_null rx968_debug, debug_789
    rx968_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_789:
    .return (rx968_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("205_1299450589.65") :method
.annotate 'line', 4
    $P970 = self."!PREFIX__!subrule"("ws", "")
    new $P971, "ResizablePMCArray"
    push $P971, $P970
    .return ($P971)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("206_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1009_tgt
    .local int rx1009_pos
    .local int rx1009_off
    .local int rx1009_eos
    .local int rx1009_rep
    .local pmc rx1009_cur
    .local pmc rx1009_debug
    (rx1009_cur, rx1009_pos, rx1009_tgt, $I10) = self."!cursor_start"()
    rx1009_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1009_cur
    .local pmc match
    .lex "$/", match
    length rx1009_eos, rx1009_tgt
    gt rx1009_pos, rx1009_eos, rx1009_done
    set rx1009_off, 0
    lt rx1009_pos, 2, rx1009_start
    sub rx1009_off, rx1009_pos, 1
    substr rx1009_tgt, rx1009_tgt, rx1009_off
  rx1009_start:
    eq $I10, 1, rx1009_restart
    if_null rx1009_debug, debug_790
    rx1009_cur."!cursor_debug"("START", "dotty")
  debug_790:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1013_done
    goto rxscan1013_scan
  rxscan1013_loop:
    (rx1009_pos) = rx1009_cur."from"()
    inc rx1009_pos
    rx1009_cur."!cursor_from"(rx1009_pos)
    ge rx1009_pos, rx1009_eos, rxscan1013_done
  rxscan1013_scan:
    set_addr $I10, rxscan1013_loop
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
  rxscan1013_done:
.annotate 'line', 454
  # rx literal  "."
    add $I11, rx1009_pos, 1
    gt $I11, rx1009_eos, rx1009_fail
    sub $I11, rx1009_pos, rx1009_off
    ord $I11, rx1009_tgt, $I11
    ne $I11, 46, rx1009_fail
    add rx1009_pos, 1
  alt1014_0:
.annotate 'line', 455
    set_addr $I10, alt1014_1
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."deflongname"()
    unless $P10, rx1009_fail
    rx1009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1009_pos = $P10."pos"()
    goto alt1014_end
  alt1014_1:
.annotate 'line', 456
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1009_pos, rx1009_off
    substr $S10, rx1009_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1009_fail
  # rx subrule "quote" subtype=capture negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."quote"()
    unless $P10, rx1009_fail
    rx1009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1009_pos = $P10."pos"()
  alt1015_0:
.annotate 'line', 457
    set_addr $I10, alt1015_1
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1009_pos, rx1009_off
    substr $S10, rx1009_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1009_fail
    goto alt1015_end
  alt1015_1:
  # rx subrule "panic" subtype=method negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1009_fail
    rx1009_pos = $P10."pos"()
  alt1015_end:
  alt1014_end:
.annotate 'line', 463
  # rx rxquantr1016 ** 0..1
    set_addr $I10, rxquantr1016_done
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
  rxquantr1016_loop:
  alt1017_0:
.annotate 'line', 460
    set_addr $I10, alt1017_1
    rx1009_cur."!mark_push"(0, rx1009_pos, $I10)
.annotate 'line', 461
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1009_pos, rx1009_off
    substr $S10, rx1009_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1009_fail
  # rx subrule "args" subtype=capture negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."args"()
    unless $P10, rx1009_fail
    rx1009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1009_pos = $P10."pos"()
    goto alt1017_end
  alt1017_1:
.annotate 'line', 462
  # rx literal  ":"
    add $I11, rx1009_pos, 1
    gt $I11, rx1009_eos, rx1009_fail
    sub $I11, rx1009_pos, rx1009_off
    ord $I11, rx1009_tgt, $I11
    ne $I11, 58, rx1009_fail
    add rx1009_pos, 1
  # rx charclass s
    ge rx1009_pos, rx1009_eos, rx1009_fail
    sub $I10, rx1009_pos, rx1009_off
    is_cclass $I11, 32, rx1009_tgt, $I10
    unless $I11, rx1009_fail
    inc rx1009_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1009_cur."!cursor_pos"(rx1009_pos)
    $P10 = rx1009_cur."arglist"()
    unless $P10, rx1009_fail
    rx1009_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1009_pos = $P10."pos"()
  alt1017_end:
.annotate 'line', 463
    set_addr $I10, rxquantr1016_done
    (rx1009_rep) = rx1009_cur."!mark_commit"($I10)
  rxquantr1016_done:
.annotate 'line', 453
  # rx pass
    rx1009_cur."!cursor_pass"(rx1009_pos, "dotty")
    if_null rx1009_debug, debug_791
    rx1009_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1009_pos)
  debug_791:
    .return (rx1009_cur)
  rx1009_restart:
.annotate 'line', 4
    if_null rx1009_debug, debug_792
    rx1009_cur."!cursor_debug"("NEXT", "dotty")
  debug_792:
  rx1009_fail:
    (rx1009_rep, rx1009_pos, $I10, $P10) = rx1009_cur."!mark_fail"(0)
    lt rx1009_pos, -1, rx1009_done
    eq rx1009_pos, -1, rx1009_fail
    jump $I10
  rx1009_done:
    rx1009_cur."!cursor_fail"()
    if_null rx1009_debug, debug_793
    rx1009_cur."!cursor_debug"("FAIL", "dotty")
  debug_793:
    .return (rx1009_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("207_1299450589.65") :method
.annotate 'line', 4
    $P1011 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1012, "ResizablePMCArray"
    push $P1012, "'"
    push $P1012, "\""
    push $P1012, $P1011
    .return ($P1012)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("208_1299450589.65")
    .param pmc param_1019
.annotate 'line', 467
    .lex "self", param_1019
    $P1020 = param_1019."!protoregex"("term")
    .return ($P1020)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("209_1299450589.65")
    .param pmc param_1022
.annotate 'line', 467
    .lex "self", param_1022
    $P1023 = param_1022."!PREFIX__!protoregex"("term")
    .return ($P1023)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("210_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1025_tgt
    .local int rx1025_pos
    .local int rx1025_off
    .local int rx1025_eos
    .local int rx1025_rep
    .local pmc rx1025_cur
    .local pmc rx1025_debug
    (rx1025_cur, rx1025_pos, rx1025_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1025_cur
    .local pmc match
    .lex "$/", match
    length rx1025_eos, rx1025_tgt
    gt rx1025_pos, rx1025_eos, rx1025_done
    set rx1025_off, 0
    lt rx1025_pos, 2, rx1025_start
    sub rx1025_off, rx1025_pos, 1
    substr rx1025_tgt, rx1025_tgt, rx1025_off
  rx1025_start:
    eq $I10, 1, rx1025_restart
    if_null rx1025_debug, debug_794
    rx1025_cur."!cursor_debug"("START", "term:sym<self>")
  debug_794:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1028_done
    goto rxscan1028_scan
  rxscan1028_loop:
    (rx1025_pos) = rx1025_cur."from"()
    inc rx1025_pos
    rx1025_cur."!cursor_from"(rx1025_pos)
    ge rx1025_pos, rx1025_eos, rxscan1028_done
  rxscan1028_scan:
    set_addr $I10, rxscan1028_loop
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  rxscan1028_done:
.annotate 'line', 469
  # rx subcapture "sym"
    set_addr $I10, rxcap_1029_fail
    rx1025_cur."!mark_push"(0, rx1025_pos, $I10)
  # rx literal  "self"
    add $I11, rx1025_pos, 4
    gt $I11, rx1025_eos, rx1025_fail
    sub $I11, rx1025_pos, rx1025_off
    substr $S10, rx1025_tgt, $I11, 4
    ne $S10, "self", rx1025_fail
    add rx1025_pos, 4
    set_addr $I10, rxcap_1029_fail
    ($I12, $I11) = rx1025_cur."!mark_peek"($I10)
    rx1025_cur."!cursor_pos"($I11)
    ($P10) = rx1025_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1025_pos, "")
    rx1025_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1029_done
  rxcap_1029_fail:
    goto rx1025_fail
  rxcap_1029_done:
  # rxanchor rwb
    le rx1025_pos, 0, rx1025_fail
    sub $I10, rx1025_pos, rx1025_off
    is_cclass $I11, 8192, rx1025_tgt, $I10
    if $I11, rx1025_fail
    dec $I10
    is_cclass $I11, 8192, rx1025_tgt, $I10
    unless $I11, rx1025_fail
  # rx pass
    rx1025_cur."!cursor_pass"(rx1025_pos, "term:sym<self>")
    if_null rx1025_debug, debug_795
    rx1025_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1025_pos)
  debug_795:
    .return (rx1025_cur)
  rx1025_restart:
.annotate 'line', 4
    if_null rx1025_debug, debug_796
    rx1025_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_796:
  rx1025_fail:
    (rx1025_rep, rx1025_pos, $I10, $P10) = rx1025_cur."!mark_fail"(0)
    lt rx1025_pos, -1, rx1025_done
    eq rx1025_pos, -1, rx1025_fail
    jump $I10
  rx1025_done:
    rx1025_cur."!cursor_fail"()
    if_null rx1025_debug, debug_797
    rx1025_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_797:
    .return (rx1025_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("211_1299450589.65") :method
.annotate 'line', 4
    new $P1027, "ResizablePMCArray"
    push $P1027, "self"
    .return ($P1027)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("212_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1031_tgt
    .local int rx1031_pos
    .local int rx1031_off
    .local int rx1031_eos
    .local int rx1031_rep
    .local pmc rx1031_cur
    .local pmc rx1031_debug
    (rx1031_cur, rx1031_pos, rx1031_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1031_cur
    .local pmc match
    .lex "$/", match
    length rx1031_eos, rx1031_tgt
    gt rx1031_pos, rx1031_eos, rx1031_done
    set rx1031_off, 0
    lt rx1031_pos, 2, rx1031_start
    sub rx1031_off, rx1031_pos, 1
    substr rx1031_tgt, rx1031_tgt, rx1031_off
  rx1031_start:
    eq $I10, 1, rx1031_restart
    if_null rx1031_debug, debug_798
    rx1031_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_798:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1035_done
    goto rxscan1035_scan
  rxscan1035_loop:
    (rx1031_pos) = rx1031_cur."from"()
    inc rx1031_pos
    rx1031_cur."!cursor_from"(rx1031_pos)
    ge rx1031_pos, rx1031_eos, rxscan1035_done
  rxscan1035_scan:
    set_addr $I10, rxscan1035_loop
    rx1031_cur."!mark_push"(0, rx1031_pos, $I10)
  rxscan1035_done:
.annotate 'line', 472
  # rx subrule "deflongname" subtype=capture negate=
    rx1031_cur."!cursor_pos"(rx1031_pos)
    $P10 = rx1031_cur."deflongname"()
    unless $P10, rx1031_fail
    rx1031_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1031_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1031_pos, rx1031_off
    substr $S10, rx1031_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1031_fail
  # rx subrule "args" subtype=capture negate=
    rx1031_cur."!cursor_pos"(rx1031_pos)
    $P10 = rx1031_cur."args"()
    unless $P10, rx1031_fail
    rx1031_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1031_pos = $P10."pos"()
.annotate 'line', 471
  # rx pass
    rx1031_cur."!cursor_pass"(rx1031_pos, "term:sym<identifier>")
    if_null rx1031_debug, debug_799
    rx1031_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1031_pos)
  debug_799:
    .return (rx1031_cur)
  rx1031_restart:
.annotate 'line', 4
    if_null rx1031_debug, debug_800
    rx1031_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_800:
  rx1031_fail:
    (rx1031_rep, rx1031_pos, $I10, $P10) = rx1031_cur."!mark_fail"(0)
    lt rx1031_pos, -1, rx1031_done
    eq rx1031_pos, -1, rx1031_fail
    jump $I10
  rx1031_done:
    rx1031_cur."!cursor_fail"()
    if_null rx1031_debug, debug_801
    rx1031_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_801:
    .return (rx1031_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("213_1299450589.65") :method
.annotate 'line', 4
    $P1033 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1034, "ResizablePMCArray"
    push $P1034, $P1033
    .return ($P1034)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("214_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1037_tgt
    .local int rx1037_pos
    .local int rx1037_off
    .local int rx1037_eos
    .local int rx1037_rep
    .local pmc rx1037_cur
    .local pmc rx1037_debug
    (rx1037_cur, rx1037_pos, rx1037_tgt, $I10) = self."!cursor_start"()
    rx1037_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1037_cur
    .local pmc match
    .lex "$/", match
    length rx1037_eos, rx1037_tgt
    gt rx1037_pos, rx1037_eos, rx1037_done
    set rx1037_off, 0
    lt rx1037_pos, 2, rx1037_start
    sub rx1037_off, rx1037_pos, 1
    substr rx1037_tgt, rx1037_tgt, rx1037_off
  rx1037_start:
    eq $I10, 1, rx1037_restart
    if_null rx1037_debug, debug_802
    rx1037_cur."!cursor_debug"("START", "term:sym<name>")
  debug_802:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1041_done
    goto rxscan1041_scan
  rxscan1041_loop:
    (rx1037_pos) = rx1037_cur."from"()
    inc rx1037_pos
    rx1037_cur."!cursor_from"(rx1037_pos)
    ge rx1037_pos, rx1037_eos, rxscan1041_done
  rxscan1041_scan:
    set_addr $I10, rxscan1041_loop
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  rxscan1041_done:
.annotate 'line', 476
  # rx subrule "name" subtype=capture negate=
    rx1037_cur."!cursor_pos"(rx1037_pos)
    $P10 = rx1037_cur."name"()
    unless $P10, rx1037_fail
    rx1037_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1037_pos = $P10."pos"()
  # rx rxquantr1042 ** 0..1
    set_addr $I10, rxquantr1042_done
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10)
  rxquantr1042_loop:
  # rx subrule "args" subtype=capture negate=
    rx1037_cur."!cursor_pos"(rx1037_pos)
    $P10 = rx1037_cur."args"()
    unless $P10, rx1037_fail
    goto rxsubrule1043_pass
  rxsubrule1043_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1037_fail
  rxsubrule1043_pass:
    set_addr $I10, rxsubrule1043_back
    rx1037_cur."!mark_push"(0, rx1037_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1037_pos = $P10."pos"()
    set_addr $I10, rxquantr1042_done
    (rx1037_rep) = rx1037_cur."!mark_commit"($I10)
  rxquantr1042_done:
.annotate 'line', 475
  # rx pass
    rx1037_cur."!cursor_pass"(rx1037_pos, "term:sym<name>")
    if_null rx1037_debug, debug_803
    rx1037_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1037_pos)
  debug_803:
    .return (rx1037_cur)
  rx1037_restart:
.annotate 'line', 4
    if_null rx1037_debug, debug_804
    rx1037_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_804:
  rx1037_fail:
    (rx1037_rep, rx1037_pos, $I10, $P10) = rx1037_cur."!mark_fail"(0)
    lt rx1037_pos, -1, rx1037_done
    eq rx1037_pos, -1, rx1037_fail
    jump $I10
  rx1037_done:
    rx1037_cur."!cursor_fail"()
    if_null rx1037_debug, debug_805
    rx1037_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_805:
    .return (rx1037_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("215_1299450589.65") :method
.annotate 'line', 4
    $P1039 = self."!PREFIX__!subrule"("name", "")
    new $P1040, "ResizablePMCArray"
    push $P1040, $P1039
    .return ($P1040)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("216_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1045_tgt
    .local int rx1045_pos
    .local int rx1045_off
    .local int rx1045_eos
    .local int rx1045_rep
    .local pmc rx1045_cur
    .local pmc rx1045_debug
    (rx1045_cur, rx1045_pos, rx1045_tgt, $I10) = self."!cursor_start"()
    rx1045_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1045_cur
    .local pmc match
    .lex "$/", match
    length rx1045_eos, rx1045_tgt
    gt rx1045_pos, rx1045_eos, rx1045_done
    set rx1045_off, 0
    lt rx1045_pos, 2, rx1045_start
    sub rx1045_off, rx1045_pos, 1
    substr rx1045_tgt, rx1045_tgt, rx1045_off
  rx1045_start:
    eq $I10, 1, rx1045_restart
    if_null rx1045_debug, debug_806
    rx1045_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_806:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1048_done
    goto rxscan1048_scan
  rxscan1048_loop:
    (rx1045_pos) = rx1045_cur."from"()
    inc rx1045_pos
    rx1045_cur."!cursor_from"(rx1045_pos)
    ge rx1045_pos, rx1045_eos, rxscan1048_done
  rxscan1048_scan:
    set_addr $I10, rxscan1048_loop
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  rxscan1048_done:
.annotate 'line', 480
  # rx literal  "pir::"
    add $I11, rx1045_pos, 5
    gt $I11, rx1045_eos, rx1045_fail
    sub $I11, rx1045_pos, rx1045_off
    substr $S10, rx1045_tgt, $I11, 5
    ne $S10, "pir::", rx1045_fail
    add rx1045_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1049_fail
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1045_pos, rx1045_off
    find_not_cclass $I11, 8192, rx1045_tgt, $I10, rx1045_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1045_fail
    add rx1045_pos, rx1045_off, $I11
    set_addr $I10, rxcap_1049_fail
    ($I12, $I11) = rx1045_cur."!mark_peek"($I10)
    rx1045_cur."!cursor_pos"($I11)
    ($P10) = rx1045_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1045_pos, "")
    rx1045_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1049_done
  rxcap_1049_fail:
    goto rx1045_fail
  rxcap_1049_done:
  # rx rxquantr1050 ** 0..1
    set_addr $I10, rxquantr1050_done
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10)
  rxquantr1050_loop:
  # rx subrule "args" subtype=capture negate=
    rx1045_cur."!cursor_pos"(rx1045_pos)
    $P10 = rx1045_cur."args"()
    unless $P10, rx1045_fail
    goto rxsubrule1051_pass
  rxsubrule1051_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1045_fail
  rxsubrule1051_pass:
    set_addr $I10, rxsubrule1051_back
    rx1045_cur."!mark_push"(0, rx1045_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1045_pos = $P10."pos"()
    set_addr $I10, rxquantr1050_done
    (rx1045_rep) = rx1045_cur."!mark_commit"($I10)
  rxquantr1050_done:
.annotate 'line', 479
  # rx pass
    rx1045_cur."!cursor_pass"(rx1045_pos, "term:sym<pir::op>")
    if_null rx1045_debug, debug_807
    rx1045_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1045_pos)
  debug_807:
    .return (rx1045_cur)
  rx1045_restart:
.annotate 'line', 4
    if_null rx1045_debug, debug_808
    rx1045_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_808:
  rx1045_fail:
    (rx1045_rep, rx1045_pos, $I10, $P10) = rx1045_cur."!mark_fail"(0)
    lt rx1045_pos, -1, rx1045_done
    eq rx1045_pos, -1, rx1045_fail
    jump $I10
  rx1045_done:
    rx1045_cur."!cursor_fail"()
    if_null rx1045_debug, debug_809
    rx1045_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_809:
    .return (rx1045_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("217_1299450589.65") :method
.annotate 'line', 4
    new $P1047, "ResizablePMCArray"
    push $P1047, "pir::"
    .return ($P1047)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("218_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P1061 = "220_1299450589.65" 
    capture_lex $P1061
    .local string rx1053_tgt
    .local int rx1053_pos
    .local int rx1053_off
    .local int rx1053_eos
    .local int rx1053_rep
    .local pmc rx1053_cur
    .local pmc rx1053_debug
    (rx1053_cur, rx1053_pos, rx1053_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1053_cur
    .local pmc match
    .lex "$/", match
    length rx1053_eos, rx1053_tgt
    gt rx1053_pos, rx1053_eos, rx1053_done
    set rx1053_off, 0
    lt rx1053_pos, 2, rx1053_start
    sub rx1053_off, rx1053_pos, 1
    substr rx1053_tgt, rx1053_tgt, rx1053_off
  rx1053_start:
    eq $I10, 1, rx1053_restart
    if_null rx1053_debug, debug_810
    rx1053_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_810:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1056_done
    goto rxscan1056_scan
  rxscan1056_loop:
    (rx1053_pos) = rx1053_cur."from"()
    inc rx1053_pos
    rx1053_cur."!cursor_from"(rx1053_pos)
    ge rx1053_pos, rx1053_eos, rxscan1056_done
  rxscan1056_scan:
    set_addr $I10, rxscan1056_loop
    rx1053_cur."!mark_push"(0, rx1053_pos, $I10)
  rxscan1056_done:
.annotate 'line', 484
  # rx literal  "{*}"
    add $I11, rx1053_pos, 3
    gt $I11, rx1053_eos, rx1053_fail
    sub $I11, rx1053_pos, rx1053_off
    substr $S10, rx1053_tgt, $I11, 3
    ne $S10, "{*}", rx1053_fail
    add rx1053_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1053_cur."!cursor_pos"(rx1053_pos)
    $P10 = rx1053_cur."ENDSTMT"()
    unless $P10, rx1053_fail
  alt1057_0:
.annotate 'line', 485
    set_addr $I10, alt1057_1
    rx1053_cur."!mark_push"(0, rx1053_pos, $I10)
    rx1053_cur."!cursor_pos"(rx1053_pos)
    find_lex $P1058, unicode:"$\x{a2}"
    $P1059 = $P1058."MATCH"()
    store_lex "$/", $P1059
    .const 'Sub' $P1061 = "220_1299450589.65" 
    capture_lex $P1061
    $P1065 = $P1061()
    unless $P1065, rx1053_fail
    goto alt1057_end
  alt1057_1:
  # rx subrule "panic" subtype=method negate=
    rx1053_cur."!cursor_pos"(rx1053_pos)
    $P10 = rx1053_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1053_fail
    rx1053_pos = $P10."pos"()
  alt1057_end:
.annotate 'line', 483
  # rx pass
    rx1053_cur."!cursor_pass"(rx1053_pos, "term:sym<onlystar>")
    if_null rx1053_debug, debug_813
    rx1053_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1053_pos)
  debug_813:
    .return (rx1053_cur)
  rx1053_restart:
.annotate 'line', 4
    if_null rx1053_debug, debug_814
    rx1053_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_814:
  rx1053_fail:
    (rx1053_rep, rx1053_pos, $I10, $P10) = rx1053_cur."!mark_fail"(0)
    lt rx1053_pos, -1, rx1053_done
    eq rx1053_pos, -1, rx1053_fail
    jump $I10
  rx1053_done:
    rx1053_cur."!cursor_fail"()
    if_null rx1053_debug, debug_815
    rx1053_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_815:
    .return (rx1053_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("219_1299450589.65") :method
.annotate 'line', 4
    new $P1055, "ResizablePMCArray"
    push $P1055, "{*}"
    .return ($P1055)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1060"  :anon :subid("220_1299450589.65") :outer("218_1299450589.65")
.annotate 'line', 485
    find_dynamic_lex $P1062, "$*MULTINESS"
    unless_null $P1062, vivify_811
    get_hll_global $P1062, "$MULTINESS"
    unless_null $P1062, vivify_812
    die "Contextual $*MULTINESS not found"
  vivify_812:
  vivify_811:
    set $S1063, $P1062
    iseq $I1064, $S1063, "proto"
    .return ($I1064)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("221_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1067_tgt
    .local int rx1067_pos
    .local int rx1067_off
    .local int rx1067_eos
    .local int rx1067_rep
    .local pmc rx1067_cur
    .local pmc rx1067_debug
    (rx1067_cur, rx1067_pos, rx1067_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1067_cur
    .local pmc match
    .lex "$/", match
    length rx1067_eos, rx1067_tgt
    gt rx1067_pos, rx1067_eos, rx1067_done
    set rx1067_off, 0
    lt rx1067_pos, 2, rx1067_start
    sub rx1067_off, rx1067_pos, 1
    substr rx1067_tgt, rx1067_tgt, rx1067_off
  rx1067_start:
    eq $I10, 1, rx1067_restart
    if_null rx1067_debug, debug_816
    rx1067_cur."!cursor_debug"("START", "args")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1071_done
    goto rxscan1071_scan
  rxscan1071_loop:
    (rx1067_pos) = rx1067_cur."from"()
    inc rx1067_pos
    rx1067_cur."!cursor_from"(rx1067_pos)
    ge rx1067_pos, rx1067_eos, rxscan1071_done
  rxscan1071_scan:
    set_addr $I10, rxscan1071_loop
    rx1067_cur."!mark_push"(0, rx1067_pos, $I10)
  rxscan1071_done:
.annotate 'line', 489
  # rx literal  "("
    add $I11, rx1067_pos, 1
    gt $I11, rx1067_eos, rx1067_fail
    sub $I11, rx1067_pos, rx1067_off
    ord $I11, rx1067_tgt, $I11
    ne $I11, 40, rx1067_fail
    add rx1067_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1067_cur."!cursor_pos"(rx1067_pos)
    $P10 = rx1067_cur."arglist"()
    unless $P10, rx1067_fail
    rx1067_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1067_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1067_pos, 1
    gt $I11, rx1067_eos, rx1067_fail
    sub $I11, rx1067_pos, rx1067_off
    ord $I11, rx1067_tgt, $I11
    ne $I11, 41, rx1067_fail
    add rx1067_pos, 1
  # rx pass
    rx1067_cur."!cursor_pass"(rx1067_pos, "args")
    if_null rx1067_debug, debug_817
    rx1067_cur."!cursor_debug"("PASS", "args", " at pos=", rx1067_pos)
  debug_817:
    .return (rx1067_cur)
  rx1067_restart:
.annotate 'line', 4
    if_null rx1067_debug, debug_818
    rx1067_cur."!cursor_debug"("NEXT", "args")
  debug_818:
  rx1067_fail:
    (rx1067_rep, rx1067_pos, $I10, $P10) = rx1067_cur."!mark_fail"(0)
    lt rx1067_pos, -1, rx1067_done
    eq rx1067_pos, -1, rx1067_fail
    jump $I10
  rx1067_done:
    rx1067_cur."!cursor_fail"()
    if_null rx1067_debug, debug_819
    rx1067_cur."!cursor_debug"("FAIL", "args")
  debug_819:
    .return (rx1067_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("222_1299450589.65") :method
.annotate 'line', 4
    $P1069 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1070, "ResizablePMCArray"
    push $P1070, $P1069
    .return ($P1070)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("223_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1073_tgt
    .local int rx1073_pos
    .local int rx1073_off
    .local int rx1073_eos
    .local int rx1073_rep
    .local pmc rx1073_cur
    .local pmc rx1073_debug
    (rx1073_cur, rx1073_pos, rx1073_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1073_cur
    .local pmc match
    .lex "$/", match
    length rx1073_eos, rx1073_tgt
    gt rx1073_pos, rx1073_eos, rx1073_done
    set rx1073_off, 0
    lt rx1073_pos, 2, rx1073_start
    sub rx1073_off, rx1073_pos, 1
    substr rx1073_tgt, rx1073_tgt, rx1073_off
  rx1073_start:
    eq $I10, 1, rx1073_restart
    if_null rx1073_debug, debug_820
    rx1073_cur."!cursor_debug"("START", "arglist")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1077_done
    goto rxscan1077_scan
  rxscan1077_loop:
    (rx1073_pos) = rx1073_cur."from"()
    inc rx1073_pos
    rx1073_cur."!cursor_from"(rx1073_pos)
    ge rx1073_pos, rx1073_eos, rxscan1077_done
  rxscan1077_scan:
    set_addr $I10, rxscan1077_loop
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
  rxscan1077_done:
.annotate 'line', 493
  # rx subrule "ws" subtype=method negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."ws"()
    unless $P10, rx1073_fail
    rx1073_pos = $P10."pos"()
  alt1078_0:
.annotate 'line', 494
    set_addr $I10, alt1078_1
    rx1073_cur."!mark_push"(0, rx1073_pos, $I10)
.annotate 'line', 495
  # rx subrule "EXPR" subtype=capture negate=
    rx1073_cur."!cursor_pos"(rx1073_pos)
    $P10 = rx1073_cur."EXPR"("f=")
    unless $P10, rx1073_fail
    rx1073_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1073_pos = $P10."pos"()
    goto alt1078_end
  alt1078_1:
  alt1078_end:
.annotate 'line', 492
  # rx pass
    rx1073_cur."!cursor_pass"(rx1073_pos, "arglist")
    if_null rx1073_debug, debug_821
    rx1073_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1073_pos)
  debug_821:
    .return (rx1073_cur)
  rx1073_restart:
.annotate 'line', 4
    if_null rx1073_debug, debug_822
    rx1073_cur."!cursor_debug"("NEXT", "arglist")
  debug_822:
  rx1073_fail:
    (rx1073_rep, rx1073_pos, $I10, $P10) = rx1073_cur."!mark_fail"(0)
    lt rx1073_pos, -1, rx1073_done
    eq rx1073_pos, -1, rx1073_fail
    jump $I10
  rx1073_done:
    rx1073_cur."!cursor_fail"()
    if_null rx1073_debug, debug_823
    rx1073_cur."!cursor_debug"("FAIL", "arglist")
  debug_823:
    .return (rx1073_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("224_1299450589.65") :method
.annotate 'line', 4
    $P1075 = self."!PREFIX__!subrule"("ws", "")
    new $P1076, "ResizablePMCArray"
    push $P1076, $P1075
    .return ($P1076)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("225_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1080_tgt
    .local int rx1080_pos
    .local int rx1080_off
    .local int rx1080_eos
    .local int rx1080_rep
    .local pmc rx1080_cur
    .local pmc rx1080_debug
    (rx1080_cur, rx1080_pos, rx1080_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1080_cur
    .local pmc match
    .lex "$/", match
    length rx1080_eos, rx1080_tgt
    gt rx1080_pos, rx1080_eos, rx1080_done
    set rx1080_off, 0
    lt rx1080_pos, 2, rx1080_start
    sub rx1080_off, rx1080_pos, 1
    substr rx1080_tgt, rx1080_tgt, rx1080_off
  rx1080_start:
    eq $I10, 1, rx1080_restart
    if_null rx1080_debug, debug_824
    rx1080_cur."!cursor_debug"("START", "term:sym<value>")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1084_done
    goto rxscan1084_scan
  rxscan1084_loop:
    (rx1080_pos) = rx1080_cur."from"()
    inc rx1080_pos
    rx1080_cur."!cursor_from"(rx1080_pos)
    ge rx1080_pos, rx1080_eos, rxscan1084_done
  rxscan1084_scan:
    set_addr $I10, rxscan1084_loop
    rx1080_cur."!mark_push"(0, rx1080_pos, $I10)
  rxscan1084_done:
.annotate 'line', 501
  # rx subrule "value" subtype=capture negate=
    rx1080_cur."!cursor_pos"(rx1080_pos)
    $P10 = rx1080_cur."value"()
    unless $P10, rx1080_fail
    rx1080_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1080_pos = $P10."pos"()
  # rx pass
    rx1080_cur."!cursor_pass"(rx1080_pos, "term:sym<value>")
    if_null rx1080_debug, debug_825
    rx1080_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1080_pos)
  debug_825:
    .return (rx1080_cur)
  rx1080_restart:
.annotate 'line', 4
    if_null rx1080_debug, debug_826
    rx1080_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_826:
  rx1080_fail:
    (rx1080_rep, rx1080_pos, $I10, $P10) = rx1080_cur."!mark_fail"(0)
    lt rx1080_pos, -1, rx1080_done
    eq rx1080_pos, -1, rx1080_fail
    jump $I10
  rx1080_done:
    rx1080_cur."!cursor_fail"()
    if_null rx1080_debug, debug_827
    rx1080_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_827:
    .return (rx1080_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("226_1299450589.65") :method
.annotate 'line', 4
    $P1082 = self."!PREFIX__!subrule"("value", "")
    new $P1083, "ResizablePMCArray"
    push $P1083, $P1082
    .return ($P1083)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("227_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1086_tgt
    .local int rx1086_pos
    .local int rx1086_off
    .local int rx1086_eos
    .local int rx1086_rep
    .local pmc rx1086_cur
    .local pmc rx1086_debug
    (rx1086_cur, rx1086_pos, rx1086_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1086_cur
    .local pmc match
    .lex "$/", match
    length rx1086_eos, rx1086_tgt
    gt rx1086_pos, rx1086_eos, rx1086_done
    set rx1086_off, 0
    lt rx1086_pos, 2, rx1086_start
    sub rx1086_off, rx1086_pos, 1
    substr rx1086_tgt, rx1086_tgt, rx1086_off
  rx1086_start:
    eq $I10, 1, rx1086_restart
    if_null rx1086_debug, debug_828
    rx1086_cur."!cursor_debug"("START", "value")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1091_done
    goto rxscan1091_scan
  rxscan1091_loop:
    (rx1086_pos) = rx1086_cur."from"()
    inc rx1086_pos
    rx1086_cur."!cursor_from"(rx1086_pos)
    ge rx1086_pos, rx1086_eos, rxscan1091_done
  rxscan1091_scan:
    set_addr $I10, rxscan1091_loop
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
  rxscan1091_done:
  alt1092_0:
.annotate 'line', 503
    set_addr $I10, alt1092_1
    rx1086_cur."!mark_push"(0, rx1086_pos, $I10)
.annotate 'line', 504
  # rx subrule "quote" subtype=capture negate=
    rx1086_cur."!cursor_pos"(rx1086_pos)
    $P10 = rx1086_cur."quote"()
    unless $P10, rx1086_fail
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1086_pos = $P10."pos"()
    goto alt1092_end
  alt1092_1:
.annotate 'line', 505
  # rx subrule "number" subtype=capture negate=
    rx1086_cur."!cursor_pos"(rx1086_pos)
    $P10 = rx1086_cur."number"()
    unless $P10, rx1086_fail
    rx1086_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1086_pos = $P10."pos"()
  alt1092_end:
.annotate 'line', 503
  # rx pass
    rx1086_cur."!cursor_pass"(rx1086_pos, "value")
    if_null rx1086_debug, debug_829
    rx1086_cur."!cursor_debug"("PASS", "value", " at pos=", rx1086_pos)
  debug_829:
    .return (rx1086_cur)
  rx1086_restart:
.annotate 'line', 4
    if_null rx1086_debug, debug_830
    rx1086_cur."!cursor_debug"("NEXT", "value")
  debug_830:
  rx1086_fail:
    (rx1086_rep, rx1086_pos, $I10, $P10) = rx1086_cur."!mark_fail"(0)
    lt rx1086_pos, -1, rx1086_done
    eq rx1086_pos, -1, rx1086_fail
    jump $I10
  rx1086_done:
    rx1086_cur."!cursor_fail"()
    if_null rx1086_debug, debug_831
    rx1086_cur."!cursor_debug"("FAIL", "value")
  debug_831:
    .return (rx1086_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("228_1299450589.65") :method
.annotate 'line', 4
    $P1088 = self."!PREFIX__!subrule"("number", "")
    $P1089 = self."!PREFIX__!subrule"("quote", "")
    new $P1090, "ResizablePMCArray"
    push $P1090, $P1088
    push $P1090, $P1089
    .return ($P1090)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("229_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1094_tgt
    .local int rx1094_pos
    .local int rx1094_off
    .local int rx1094_eos
    .local int rx1094_rep
    .local pmc rx1094_cur
    .local pmc rx1094_debug
    (rx1094_cur, rx1094_pos, rx1094_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1094_cur
    .local pmc match
    .lex "$/", match
    length rx1094_eos, rx1094_tgt
    gt rx1094_pos, rx1094_eos, rx1094_done
    set rx1094_off, 0
    lt rx1094_pos, 2, rx1094_start
    sub rx1094_off, rx1094_pos, 1
    substr rx1094_tgt, rx1094_tgt, rx1094_off
  rx1094_start:
    eq $I10, 1, rx1094_restart
    if_null rx1094_debug, debug_832
    rx1094_cur."!cursor_debug"("START", "number")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1097_done
    goto rxscan1097_scan
  rxscan1097_loop:
    (rx1094_pos) = rx1094_cur."from"()
    inc rx1094_pos
    rx1094_cur."!cursor_from"(rx1094_pos)
    ge rx1094_pos, rx1094_eos, rxscan1097_done
  rxscan1097_scan:
    set_addr $I10, rxscan1097_loop
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  rxscan1097_done:
.annotate 'line', 509
  # rx subcapture "sign"
    set_addr $I10, rxcap_1099_fail
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1094_pos, rx1094_off
    set rx1094_rep, 0
    sub $I12, rx1094_eos, rx1094_pos
    le $I12, 1, rxenumcharlistq1098_loop
    set $I12, 1
  rxenumcharlistq1098_loop:
    le $I12, 0, rxenumcharlistq1098_done
    substr $S10, rx1094_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1098_done
    inc rx1094_rep
  rxenumcharlistq1098_done:
    add rx1094_pos, rx1094_pos, rx1094_rep
    set_addr $I10, rxcap_1099_fail
    ($I12, $I11) = rx1094_cur."!mark_peek"($I10)
    rx1094_cur."!cursor_pos"($I11)
    ($P10) = rx1094_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1094_pos, "")
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1099_done
  rxcap_1099_fail:
    goto rx1094_fail
  rxcap_1099_done:
  alt1100_0:
.annotate 'line', 510
    set_addr $I10, alt1100_1
    rx1094_cur."!mark_push"(0, rx1094_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."dec_number"()
    unless $P10, rx1094_fail
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1094_pos = $P10."pos"()
    goto alt1100_end
  alt1100_1:
  # rx subrule "integer" subtype=capture negate=
    rx1094_cur."!cursor_pos"(rx1094_pos)
    $P10 = rx1094_cur."integer"()
    unless $P10, rx1094_fail
    rx1094_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1094_pos = $P10."pos"()
  alt1100_end:
.annotate 'line', 508
  # rx pass
    rx1094_cur."!cursor_pass"(rx1094_pos, "number")
    if_null rx1094_debug, debug_833
    rx1094_cur."!cursor_debug"("PASS", "number", " at pos=", rx1094_pos)
  debug_833:
    .return (rx1094_cur)
  rx1094_restart:
.annotate 'line', 4
    if_null rx1094_debug, debug_834
    rx1094_cur."!cursor_debug"("NEXT", "number")
  debug_834:
  rx1094_fail:
    (rx1094_rep, rx1094_pos, $I10, $P10) = rx1094_cur."!mark_fail"(0)
    lt rx1094_pos, -1, rx1094_done
    eq rx1094_pos, -1, rx1094_fail
    jump $I10
  rx1094_done:
    rx1094_cur."!cursor_fail"()
    if_null rx1094_debug, debug_835
    rx1094_cur."!cursor_debug"("FAIL", "number")
  debug_835:
    .return (rx1094_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("230_1299450589.65") :method
.annotate 'line', 4
    new $P1096, "ResizablePMCArray"
    push $P1096, ""
    .return ($P1096)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("231_1299450589.65")
    .param pmc param_1102
.annotate 'line', 513
    .lex "self", param_1102
    $P1103 = param_1102."!protoregex"("quote")
    .return ($P1103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("232_1299450589.65")
    .param pmc param_1105
.annotate 'line', 513
    .lex "self", param_1105
    $P1106 = param_1105."!PREFIX__!protoregex"("quote")
    .return ($P1106)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("233_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1108_tgt
    .local int rx1108_pos
    .local int rx1108_off
    .local int rx1108_eos
    .local int rx1108_rep
    .local pmc rx1108_cur
    .local pmc rx1108_debug
    (rx1108_cur, rx1108_pos, rx1108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1108_cur
    .local pmc match
    .lex "$/", match
    length rx1108_eos, rx1108_tgt
    gt rx1108_pos, rx1108_eos, rx1108_done
    set rx1108_off, 0
    lt rx1108_pos, 2, rx1108_start
    sub rx1108_off, rx1108_pos, 1
    substr rx1108_tgt, rx1108_tgt, rx1108_off
  rx1108_start:
    eq $I10, 1, rx1108_restart
    if_null rx1108_debug, debug_836
    rx1108_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1111_done
    goto rxscan1111_scan
  rxscan1111_loop:
    (rx1108_pos) = rx1108_cur."from"()
    inc rx1108_pos
    rx1108_cur."!cursor_from"(rx1108_pos)
    ge rx1108_pos, rx1108_eos, rxscan1111_done
  rxscan1111_scan:
    set_addr $I10, rxscan1111_loop
    rx1108_cur."!mark_push"(0, rx1108_pos, $I10)
  rxscan1111_done:
.annotate 'line', 514
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1108_pos, rx1108_off
    substr $S10, rx1108_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1108_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1108_cur."!cursor_pos"(rx1108_pos)
    $P10 = rx1108_cur."quote_EXPR"(":q")
    unless $P10, rx1108_fail
    rx1108_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1108_pos = $P10."pos"()
  # rx pass
    rx1108_cur."!cursor_pass"(rx1108_pos, "quote:sym<apos>")
    if_null rx1108_debug, debug_837
    rx1108_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1108_pos)
  debug_837:
    .return (rx1108_cur)
  rx1108_restart:
.annotate 'line', 4
    if_null rx1108_debug, debug_838
    rx1108_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_838:
  rx1108_fail:
    (rx1108_rep, rx1108_pos, $I10, $P10) = rx1108_cur."!mark_fail"(0)
    lt rx1108_pos, -1, rx1108_done
    eq rx1108_pos, -1, rx1108_fail
    jump $I10
  rx1108_done:
    rx1108_cur."!cursor_fail"()
    if_null rx1108_debug, debug_839
    rx1108_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_839:
    .return (rx1108_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("234_1299450589.65") :method
.annotate 'line', 4
    new $P1110, "ResizablePMCArray"
    push $P1110, "'"
    .return ($P1110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("235_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1113_tgt
    .local int rx1113_pos
    .local int rx1113_off
    .local int rx1113_eos
    .local int rx1113_rep
    .local pmc rx1113_cur
    .local pmc rx1113_debug
    (rx1113_cur, rx1113_pos, rx1113_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1113_cur
    .local pmc match
    .lex "$/", match
    length rx1113_eos, rx1113_tgt
    gt rx1113_pos, rx1113_eos, rx1113_done
    set rx1113_off, 0
    lt rx1113_pos, 2, rx1113_start
    sub rx1113_off, rx1113_pos, 1
    substr rx1113_tgt, rx1113_tgt, rx1113_off
  rx1113_start:
    eq $I10, 1, rx1113_restart
    if_null rx1113_debug, debug_840
    rx1113_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1116_done
    goto rxscan1116_scan
  rxscan1116_loop:
    (rx1113_pos) = rx1113_cur."from"()
    inc rx1113_pos
    rx1113_cur."!cursor_from"(rx1113_pos)
    ge rx1113_pos, rx1113_eos, rxscan1116_done
  rxscan1116_scan:
    set_addr $I10, rxscan1116_loop
    rx1113_cur."!mark_push"(0, rx1113_pos, $I10)
  rxscan1116_done:
.annotate 'line', 515
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1113_pos, rx1113_off
    substr $S10, rx1113_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1113_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1113_cur."!cursor_pos"(rx1113_pos)
    $P10 = rx1113_cur."quote_EXPR"(":qq")
    unless $P10, rx1113_fail
    rx1113_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1113_pos = $P10."pos"()
  # rx pass
    rx1113_cur."!cursor_pass"(rx1113_pos, "quote:sym<dblq>")
    if_null rx1113_debug, debug_841
    rx1113_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1113_pos)
  debug_841:
    .return (rx1113_cur)
  rx1113_restart:
.annotate 'line', 4
    if_null rx1113_debug, debug_842
    rx1113_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_842:
  rx1113_fail:
    (rx1113_rep, rx1113_pos, $I10, $P10) = rx1113_cur."!mark_fail"(0)
    lt rx1113_pos, -1, rx1113_done
    eq rx1113_pos, -1, rx1113_fail
    jump $I10
  rx1113_done:
    rx1113_cur."!cursor_fail"()
    if_null rx1113_debug, debug_843
    rx1113_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_843:
    .return (rx1113_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("236_1299450589.65") :method
.annotate 'line', 4
    new $P1115, "ResizablePMCArray"
    push $P1115, "\""
    .return ($P1115)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("237_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1118_tgt
    .local int rx1118_pos
    .local int rx1118_off
    .local int rx1118_eos
    .local int rx1118_rep
    .local pmc rx1118_cur
    .local pmc rx1118_debug
    (rx1118_cur, rx1118_pos, rx1118_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1118_cur
    .local pmc match
    .lex "$/", match
    length rx1118_eos, rx1118_tgt
    gt rx1118_pos, rx1118_eos, rx1118_done
    set rx1118_off, 0
    lt rx1118_pos, 2, rx1118_start
    sub rx1118_off, rx1118_pos, 1
    substr rx1118_tgt, rx1118_tgt, rx1118_off
  rx1118_start:
    eq $I10, 1, rx1118_restart
    if_null rx1118_debug, debug_844
    rx1118_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1122_done
    goto rxscan1122_scan
  rxscan1122_loop:
    (rx1118_pos) = rx1118_cur."from"()
    inc rx1118_pos
    rx1118_cur."!cursor_from"(rx1118_pos)
    ge rx1118_pos, rx1118_eos, rxscan1122_done
  rxscan1122_scan:
    set_addr $I10, rxscan1122_loop
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxscan1122_done:
.annotate 'line', 516
  # rx literal  "q"
    add $I11, rx1118_pos, 1
    gt $I11, rx1118_eos, rx1118_fail
    sub $I11, rx1118_pos, rx1118_off
    ord $I11, rx1118_tgt, $I11
    ne $I11, 113, rx1118_fail
    add rx1118_pos, 1
  # rxanchor rwb
    le rx1118_pos, 0, rx1118_fail
    sub $I10, rx1118_pos, rx1118_off
    is_cclass $I11, 8192, rx1118_tgt, $I10
    if $I11, rx1118_fail
    dec $I10
    is_cclass $I11, 8192, rx1118_tgt, $I10
    unless $I11, rx1118_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1118_pos, rx1118_off
    substr $S10, rx1118_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1118_fail
  # rx subrule "ws" subtype=method negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."ws"()
    unless $P10, rx1118_fail
    rx1118_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."quote_EXPR"(":q")
    unless $P10, rx1118_fail
    rx1118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1118_pos = $P10."pos"()
  # rx pass
    rx1118_cur."!cursor_pass"(rx1118_pos, "quote:sym<q>")
    if_null rx1118_debug, debug_845
    rx1118_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1118_pos)
  debug_845:
    .return (rx1118_cur)
  rx1118_restart:
.annotate 'line', 4
    if_null rx1118_debug, debug_846
    rx1118_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_846:
  rx1118_fail:
    (rx1118_rep, rx1118_pos, $I10, $P10) = rx1118_cur."!mark_fail"(0)
    lt rx1118_pos, -1, rx1118_done
    eq rx1118_pos, -1, rx1118_fail
    jump $I10
  rx1118_done:
    rx1118_cur."!cursor_fail"()
    if_null rx1118_debug, debug_847
    rx1118_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_847:
    .return (rx1118_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("238_1299450589.65") :method
.annotate 'line', 4
    $P1120 = self."!PREFIX__!subrule"("ws", "q")
    new $P1121, "ResizablePMCArray"
    push $P1121, $P1120
    .return ($P1121)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("239_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1124_tgt
    .local int rx1124_pos
    .local int rx1124_off
    .local int rx1124_eos
    .local int rx1124_rep
    .local pmc rx1124_cur
    .local pmc rx1124_debug
    (rx1124_cur, rx1124_pos, rx1124_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1124_cur
    .local pmc match
    .lex "$/", match
    length rx1124_eos, rx1124_tgt
    gt rx1124_pos, rx1124_eos, rx1124_done
    set rx1124_off, 0
    lt rx1124_pos, 2, rx1124_start
    sub rx1124_off, rx1124_pos, 1
    substr rx1124_tgt, rx1124_tgt, rx1124_off
  rx1124_start:
    eq $I10, 1, rx1124_restart
    if_null rx1124_debug, debug_848
    rx1124_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1128_done
    goto rxscan1128_scan
  rxscan1128_loop:
    (rx1124_pos) = rx1124_cur."from"()
    inc rx1124_pos
    rx1124_cur."!cursor_from"(rx1124_pos)
    ge rx1124_pos, rx1124_eos, rxscan1128_done
  rxscan1128_scan:
    set_addr $I10, rxscan1128_loop
    rx1124_cur."!mark_push"(0, rx1124_pos, $I10)
  rxscan1128_done:
.annotate 'line', 517
  # rx literal  "qq"
    add $I11, rx1124_pos, 2
    gt $I11, rx1124_eos, rx1124_fail
    sub $I11, rx1124_pos, rx1124_off
    substr $S10, rx1124_tgt, $I11, 2
    ne $S10, "qq", rx1124_fail
    add rx1124_pos, 2
  # rxanchor rwb
    le rx1124_pos, 0, rx1124_fail
    sub $I10, rx1124_pos, rx1124_off
    is_cclass $I11, 8192, rx1124_tgt, $I10
    if $I11, rx1124_fail
    dec $I10
    is_cclass $I11, 8192, rx1124_tgt, $I10
    unless $I11, rx1124_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1124_pos, rx1124_off
    substr $S10, rx1124_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1124_fail
  # rx subrule "ws" subtype=method negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."ws"()
    unless $P10, rx1124_fail
    rx1124_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1124_cur."!cursor_pos"(rx1124_pos)
    $P10 = rx1124_cur."quote_EXPR"(":qq")
    unless $P10, rx1124_fail
    rx1124_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1124_pos = $P10."pos"()
  # rx pass
    rx1124_cur."!cursor_pass"(rx1124_pos, "quote:sym<qq>")
    if_null rx1124_debug, debug_849
    rx1124_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1124_pos)
  debug_849:
    .return (rx1124_cur)
  rx1124_restart:
.annotate 'line', 4
    if_null rx1124_debug, debug_850
    rx1124_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_850:
  rx1124_fail:
    (rx1124_rep, rx1124_pos, $I10, $P10) = rx1124_cur."!mark_fail"(0)
    lt rx1124_pos, -1, rx1124_done
    eq rx1124_pos, -1, rx1124_fail
    jump $I10
  rx1124_done:
    rx1124_cur."!cursor_fail"()
    if_null rx1124_debug, debug_851
    rx1124_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_851:
    .return (rx1124_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("240_1299450589.65") :method
.annotate 'line', 4
    $P1126 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1127, "ResizablePMCArray"
    push $P1127, $P1126
    .return ($P1127)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("241_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1130_tgt
    .local int rx1130_pos
    .local int rx1130_off
    .local int rx1130_eos
    .local int rx1130_rep
    .local pmc rx1130_cur
    .local pmc rx1130_debug
    (rx1130_cur, rx1130_pos, rx1130_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1130_cur
    .local pmc match
    .lex "$/", match
    length rx1130_eos, rx1130_tgt
    gt rx1130_pos, rx1130_eos, rx1130_done
    set rx1130_off, 0
    lt rx1130_pos, 2, rx1130_start
    sub rx1130_off, rx1130_pos, 1
    substr rx1130_tgt, rx1130_tgt, rx1130_off
  rx1130_start:
    eq $I10, 1, rx1130_restart
    if_null rx1130_debug, debug_852
    rx1130_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1134_done
    goto rxscan1134_scan
  rxscan1134_loop:
    (rx1130_pos) = rx1130_cur."from"()
    inc rx1130_pos
    rx1130_cur."!cursor_from"(rx1130_pos)
    ge rx1130_pos, rx1130_eos, rxscan1134_done
  rxscan1134_scan:
    set_addr $I10, rxscan1134_loop
    rx1130_cur."!mark_push"(0, rx1130_pos, $I10)
  rxscan1134_done:
.annotate 'line', 518
  # rx literal  "Q"
    add $I11, rx1130_pos, 1
    gt $I11, rx1130_eos, rx1130_fail
    sub $I11, rx1130_pos, rx1130_off
    ord $I11, rx1130_tgt, $I11
    ne $I11, 81, rx1130_fail
    add rx1130_pos, 1
  # rxanchor rwb
    le rx1130_pos, 0, rx1130_fail
    sub $I10, rx1130_pos, rx1130_off
    is_cclass $I11, 8192, rx1130_tgt, $I10
    if $I11, rx1130_fail
    dec $I10
    is_cclass $I11, 8192, rx1130_tgt, $I10
    unless $I11, rx1130_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1130_pos, rx1130_off
    substr $S10, rx1130_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1130_fail
  # rx subrule "ws" subtype=method negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."ws"()
    unless $P10, rx1130_fail
    rx1130_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1130_cur."!cursor_pos"(rx1130_pos)
    $P10 = rx1130_cur."quote_EXPR"()
    unless $P10, rx1130_fail
    rx1130_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1130_pos = $P10."pos"()
  # rx pass
    rx1130_cur."!cursor_pass"(rx1130_pos, "quote:sym<Q>")
    if_null rx1130_debug, debug_853
    rx1130_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1130_pos)
  debug_853:
    .return (rx1130_cur)
  rx1130_restart:
.annotate 'line', 4
    if_null rx1130_debug, debug_854
    rx1130_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_854:
  rx1130_fail:
    (rx1130_rep, rx1130_pos, $I10, $P10) = rx1130_cur."!mark_fail"(0)
    lt rx1130_pos, -1, rx1130_done
    eq rx1130_pos, -1, rx1130_fail
    jump $I10
  rx1130_done:
    rx1130_cur."!cursor_fail"()
    if_null rx1130_debug, debug_855
    rx1130_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_855:
    .return (rx1130_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("242_1299450589.65") :method
.annotate 'line', 4
    $P1132 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1133, "ResizablePMCArray"
    push $P1133, $P1132
    .return ($P1133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("243_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1136_tgt
    .local int rx1136_pos
    .local int rx1136_off
    .local int rx1136_eos
    .local int rx1136_rep
    .local pmc rx1136_cur
    .local pmc rx1136_debug
    (rx1136_cur, rx1136_pos, rx1136_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1136_cur
    .local pmc match
    .lex "$/", match
    length rx1136_eos, rx1136_tgt
    gt rx1136_pos, rx1136_eos, rx1136_done
    set rx1136_off, 0
    lt rx1136_pos, 2, rx1136_start
    sub rx1136_off, rx1136_pos, 1
    substr rx1136_tgt, rx1136_tgt, rx1136_off
  rx1136_start:
    eq $I10, 1, rx1136_restart
    if_null rx1136_debug, debug_856
    rx1136_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1140_done
    goto rxscan1140_scan
  rxscan1140_loop:
    (rx1136_pos) = rx1136_cur."from"()
    inc rx1136_pos
    rx1136_cur."!cursor_from"(rx1136_pos)
    ge rx1136_pos, rx1136_eos, rxscan1140_done
  rxscan1140_scan:
    set_addr $I10, rxscan1140_loop
    rx1136_cur."!mark_push"(0, rx1136_pos, $I10)
  rxscan1140_done:
.annotate 'line', 519
  # rx literal  "Q:PIR"
    add $I11, rx1136_pos, 5
    gt $I11, rx1136_eos, rx1136_fail
    sub $I11, rx1136_pos, rx1136_off
    substr $S10, rx1136_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1136_fail
    add rx1136_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."ws"()
    unless $P10, rx1136_fail
    rx1136_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1136_cur."!cursor_pos"(rx1136_pos)
    $P10 = rx1136_cur."quote_EXPR"()
    unless $P10, rx1136_fail
    rx1136_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1136_pos = $P10."pos"()
  # rx pass
    rx1136_cur."!cursor_pass"(rx1136_pos, "quote:sym<Q:PIR>")
    if_null rx1136_debug, debug_857
    rx1136_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1136_pos)
  debug_857:
    .return (rx1136_cur)
  rx1136_restart:
.annotate 'line', 4
    if_null rx1136_debug, debug_858
    rx1136_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_858:
  rx1136_fail:
    (rx1136_rep, rx1136_pos, $I10, $P10) = rx1136_cur."!mark_fail"(0)
    lt rx1136_pos, -1, rx1136_done
    eq rx1136_pos, -1, rx1136_fail
    jump $I10
  rx1136_done:
    rx1136_cur."!cursor_fail"()
    if_null rx1136_debug, debug_859
    rx1136_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_859:
    .return (rx1136_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("244_1299450589.65") :method
.annotate 'line', 4
    $P1138 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1139, "ResizablePMCArray"
    push $P1139, $P1138
    .return ($P1139)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("245_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1142_tgt
    .local int rx1142_pos
    .local int rx1142_off
    .local int rx1142_eos
    .local int rx1142_rep
    .local pmc rx1142_cur
    .local pmc rx1142_debug
    (rx1142_cur, rx1142_pos, rx1142_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1142_cur
    .local pmc match
    .lex "$/", match
    length rx1142_eos, rx1142_tgt
    gt rx1142_pos, rx1142_eos, rx1142_done
    set rx1142_off, 0
    lt rx1142_pos, 2, rx1142_start
    sub rx1142_off, rx1142_pos, 1
    substr rx1142_tgt, rx1142_tgt, rx1142_off
  rx1142_start:
    eq $I10, 1, rx1142_restart
    if_null rx1142_debug, debug_860
    rx1142_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1146_done
    goto rxscan1146_scan
  rxscan1146_loop:
    (rx1142_pos) = rx1142_cur."from"()
    inc rx1142_pos
    rx1142_cur."!cursor_from"(rx1142_pos)
    ge rx1142_pos, rx1142_eos, rxscan1146_done
  rxscan1146_scan:
    set_addr $I10, rxscan1146_loop
    rx1142_cur."!mark_push"(0, rx1142_pos, $I10)
  rxscan1146_done:
.annotate 'line', 521
  # rx literal  "/"
    add $I11, rx1142_pos, 1
    gt $I11, rx1142_eos, rx1142_fail
    sub $I11, rx1142_pos, rx1142_off
    ord $I11, rx1142_tgt, $I11
    ne $I11, 47, rx1142_fail
    add rx1142_pos, 1
.annotate 'line', 522
  # rx subrule "newpad" subtype=method negate=
    rx1142_cur."!cursor_pos"(rx1142_pos)
    $P10 = rx1142_cur."newpad"()
    unless $P10, rx1142_fail
    rx1142_pos = $P10."pos"()
.annotate 'line', 523
  # rx reduce name="quote:sym</ />" key="open"
    rx1142_cur."!cursor_pos"(rx1142_pos)
    rx1142_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 524
  # rx subrule "LANG" subtype=capture negate=
    rx1142_cur."!cursor_pos"(rx1142_pos)
    $P10 = rx1142_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1142_fail
    rx1142_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1142_pos = $P10."pos"()
.annotate 'line', 525
  # rx literal  "/"
    add $I11, rx1142_pos, 1
    gt $I11, rx1142_eos, rx1142_fail
    sub $I11, rx1142_pos, rx1142_off
    ord $I11, rx1142_tgt, $I11
    ne $I11, 47, rx1142_fail
    add rx1142_pos, 1
.annotate 'line', 520
  # rx pass
    rx1142_cur."!cursor_pass"(rx1142_pos, "quote:sym</ />")
    if_null rx1142_debug, debug_861
    rx1142_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1142_pos)
  debug_861:
    .return (rx1142_cur)
  rx1142_restart:
.annotate 'line', 4
    if_null rx1142_debug, debug_862
    rx1142_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_862:
  rx1142_fail:
    (rx1142_rep, rx1142_pos, $I10, $P10) = rx1142_cur."!mark_fail"(0)
    lt rx1142_pos, -1, rx1142_done
    eq rx1142_pos, -1, rx1142_fail
    jump $I10
  rx1142_done:
    rx1142_cur."!cursor_fail"()
    if_null rx1142_debug, debug_863
    rx1142_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_863:
    .return (rx1142_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("246_1299450589.65") :method
.annotate 'line', 4
    $P1144 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1145, "ResizablePMCArray"
    push $P1145, $P1144
    .return ($P1145)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("247_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1148_tgt
    .local int rx1148_pos
    .local int rx1148_off
    .local int rx1148_eos
    .local int rx1148_rep
    .local pmc rx1148_cur
    .local pmc rx1148_debug
    (rx1148_cur, rx1148_pos, rx1148_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1148_cur
    .local pmc match
    .lex "$/", match
    length rx1148_eos, rx1148_tgt
    gt rx1148_pos, rx1148_eos, rx1148_done
    set rx1148_off, 0
    lt rx1148_pos, 2, rx1148_start
    sub rx1148_off, rx1148_pos, 1
    substr rx1148_tgt, rx1148_tgt, rx1148_off
  rx1148_start:
    eq $I10, 1, rx1148_restart
    if_null rx1148_debug, debug_864
    rx1148_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1151_done
    goto rxscan1151_scan
  rxscan1151_loop:
    (rx1148_pos) = rx1148_cur."from"()
    inc rx1148_pos
    rx1148_cur."!cursor_from"(rx1148_pos)
    ge rx1148_pos, rx1148_eos, rxscan1151_done
  rxscan1151_scan:
    set_addr $I10, rxscan1151_loop
    rx1148_cur."!mark_push"(0, rx1148_pos, $I10)
  rxscan1151_done:
.annotate 'line', 528
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1148_pos, rx1148_off
    substr $S10, rx1148_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1148_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1148_cur."!cursor_pos"(rx1148_pos)
    $P10 = rx1148_cur."quotemod_check"("s")
    unless $P10, rx1148_fail
  # rx subrule "variable" subtype=capture negate=
    rx1148_cur."!cursor_pos"(rx1148_pos)
    $P10 = rx1148_cur."variable"()
    unless $P10, rx1148_fail
    rx1148_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1148_pos = $P10."pos"()
  # rx pass
    rx1148_cur."!cursor_pass"(rx1148_pos, "quote_escape:sym<$>")
    if_null rx1148_debug, debug_865
    rx1148_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1148_pos)
  debug_865:
    .return (rx1148_cur)
  rx1148_restart:
.annotate 'line', 4
    if_null rx1148_debug, debug_866
    rx1148_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_866:
  rx1148_fail:
    (rx1148_rep, rx1148_pos, $I10, $P10) = rx1148_cur."!mark_fail"(0)
    lt rx1148_pos, -1, rx1148_done
    eq rx1148_pos, -1, rx1148_fail
    jump $I10
  rx1148_done:
    rx1148_cur."!cursor_fail"()
    if_null rx1148_debug, debug_867
    rx1148_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_867:
    .return (rx1148_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("248_1299450589.65") :method
.annotate 'line', 4
    new $P1150, "ResizablePMCArray"
    push $P1150, "$"
    .return ($P1150)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("249_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1153_tgt
    .local int rx1153_pos
    .local int rx1153_off
    .local int rx1153_eos
    .local int rx1153_rep
    .local pmc rx1153_cur
    .local pmc rx1153_debug
    (rx1153_cur, rx1153_pos, rx1153_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1153_cur
    .local pmc match
    .lex "$/", match
    length rx1153_eos, rx1153_tgt
    gt rx1153_pos, rx1153_eos, rx1153_done
    set rx1153_off, 0
    lt rx1153_pos, 2, rx1153_start
    sub rx1153_off, rx1153_pos, 1
    substr rx1153_tgt, rx1153_tgt, rx1153_off
  rx1153_start:
    eq $I10, 1, rx1153_restart
    if_null rx1153_debug, debug_868
    rx1153_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_868:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1156_done
    goto rxscan1156_scan
  rxscan1156_loop:
    (rx1153_pos) = rx1153_cur."from"()
    inc rx1153_pos
    rx1153_cur."!cursor_from"(rx1153_pos)
    ge rx1153_pos, rx1153_eos, rxscan1156_done
  rxscan1156_scan:
    set_addr $I10, rxscan1156_loop
    rx1153_cur."!mark_push"(0, rx1153_pos, $I10)
  rxscan1156_done:
.annotate 'line', 529
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1153_pos, rx1153_off
    substr $S10, rx1153_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1153_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."quotemod_check"("c")
    unless $P10, rx1153_fail
  # rx subrule "block" subtype=capture negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."block"()
    unless $P10, rx1153_fail
    rx1153_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1153_pos = $P10."pos"()
  # rx pass
    rx1153_cur."!cursor_pass"(rx1153_pos, "quote_escape:sym<{ }>")
    if_null rx1153_debug, debug_869
    rx1153_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1153_pos)
  debug_869:
    .return (rx1153_cur)
  rx1153_restart:
.annotate 'line', 4
    if_null rx1153_debug, debug_870
    rx1153_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_870:
  rx1153_fail:
    (rx1153_rep, rx1153_pos, $I10, $P10) = rx1153_cur."!mark_fail"(0)
    lt rx1153_pos, -1, rx1153_done
    eq rx1153_pos, -1, rx1153_fail
    jump $I10
  rx1153_done:
    rx1153_cur."!cursor_fail"()
    if_null rx1153_debug, debug_871
    rx1153_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_871:
    .return (rx1153_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("250_1299450589.65") :method
.annotate 'line', 4
    new $P1155, "ResizablePMCArray"
    push $P1155, "{"
    .return ($P1155)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("251_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1158_tgt
    .local int rx1158_pos
    .local int rx1158_off
    .local int rx1158_eos
    .local int rx1158_rep
    .local pmc rx1158_cur
    .local pmc rx1158_debug
    (rx1158_cur, rx1158_pos, rx1158_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1158_cur
    .local pmc match
    .lex "$/", match
    length rx1158_eos, rx1158_tgt
    gt rx1158_pos, rx1158_eos, rx1158_done
    set rx1158_off, 0
    lt rx1158_pos, 2, rx1158_start
    sub rx1158_off, rx1158_pos, 1
    substr rx1158_tgt, rx1158_tgt, rx1158_off
  rx1158_start:
    eq $I10, 1, rx1158_restart
    if_null rx1158_debug, debug_872
    rx1158_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_872:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1161_done
    goto rxscan1161_scan
  rxscan1161_loop:
    (rx1158_pos) = rx1158_cur."from"()
    inc rx1158_pos
    rx1158_cur."!cursor_from"(rx1158_pos)
    ge rx1158_pos, rx1158_eos, rxscan1161_done
  rxscan1161_scan:
    set_addr $I10, rxscan1161_loop
    rx1158_cur."!mark_push"(0, rx1158_pos, $I10)
  rxscan1161_done:
.annotate 'line', 530
  # rx literal  "\\e"
    add $I11, rx1158_pos, 2
    gt $I11, rx1158_eos, rx1158_fail
    sub $I11, rx1158_pos, rx1158_off
    substr $S10, rx1158_tgt, $I11, 2
    ne $S10, "\\e", rx1158_fail
    add rx1158_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1158_cur."!cursor_pos"(rx1158_pos)
    $P10 = rx1158_cur."quotemod_check"("b")
    unless $P10, rx1158_fail
  # rx pass
    rx1158_cur."!cursor_pass"(rx1158_pos, "quote_escape:sym<esc>")
    if_null rx1158_debug, debug_873
    rx1158_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1158_pos)
  debug_873:
    .return (rx1158_cur)
  rx1158_restart:
.annotate 'line', 4
    if_null rx1158_debug, debug_874
    rx1158_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_874:
  rx1158_fail:
    (rx1158_rep, rx1158_pos, $I10, $P10) = rx1158_cur."!mark_fail"(0)
    lt rx1158_pos, -1, rx1158_done
    eq rx1158_pos, -1, rx1158_fail
    jump $I10
  rx1158_done:
    rx1158_cur."!cursor_fail"()
    if_null rx1158_debug, debug_875
    rx1158_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_875:
    .return (rx1158_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("252_1299450589.65") :method
.annotate 'line', 4
    new $P1160, "ResizablePMCArray"
    push $P1160, "\\e"
    .return ($P1160)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("253_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1163_tgt
    .local int rx1163_pos
    .local int rx1163_off
    .local int rx1163_eos
    .local int rx1163_rep
    .local pmc rx1163_cur
    .local pmc rx1163_debug
    (rx1163_cur, rx1163_pos, rx1163_tgt, $I10) = self."!cursor_start"()
    rx1163_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1163_cur
    .local pmc match
    .lex "$/", match
    length rx1163_eos, rx1163_tgt
    gt rx1163_pos, rx1163_eos, rx1163_done
    set rx1163_off, 0
    lt rx1163_pos, 2, rx1163_start
    sub rx1163_off, rx1163_pos, 1
    substr rx1163_tgt, rx1163_tgt, rx1163_off
  rx1163_start:
    eq $I10, 1, rx1163_restart
    if_null rx1163_debug, debug_876
    rx1163_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_876:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1167_done
    goto rxscan1167_scan
  rxscan1167_loop:
    (rx1163_pos) = rx1163_cur."from"()
    inc rx1163_pos
    rx1163_cur."!cursor_from"(rx1163_pos)
    ge rx1163_pos, rx1163_eos, rxscan1167_done
  rxscan1167_scan:
    set_addr $I10, rxscan1167_loop
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10)
  rxscan1167_done:
.annotate 'line', 532
  # rx literal  "("
    add $I11, rx1163_pos, 1
    gt $I11, rx1163_eos, rx1163_fail
    sub $I11, rx1163_pos, rx1163_off
    ord $I11, rx1163_tgt, $I11
    ne $I11, 40, rx1163_fail
    add rx1163_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1163_cur."!cursor_pos"(rx1163_pos)
    $P10 = rx1163_cur."ws"()
    unless $P10, rx1163_fail
    rx1163_pos = $P10."pos"()
  # rx rxquantr1168 ** 0..1
    set_addr $I10, rxquantr1168_done
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10)
  rxquantr1168_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1163_cur."!cursor_pos"(rx1163_pos)
    $P10 = rx1163_cur."EXPR"()
    unless $P10, rx1163_fail
    goto rxsubrule1169_pass
  rxsubrule1169_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1163_fail
  rxsubrule1169_pass:
    set_addr $I10, rxsubrule1169_back
    rx1163_cur."!mark_push"(0, rx1163_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1163_pos = $P10."pos"()
    set_addr $I10, rxquantr1168_done
    (rx1163_rep) = rx1163_cur."!mark_commit"($I10)
  rxquantr1168_done:
  # rx literal  ")"
    add $I11, rx1163_pos, 1
    gt $I11, rx1163_eos, rx1163_fail
    sub $I11, rx1163_pos, rx1163_off
    ord $I11, rx1163_tgt, $I11
    ne $I11, 41, rx1163_fail
    add rx1163_pos, 1
  # rx pass
    rx1163_cur."!cursor_pass"(rx1163_pos, "circumfix:sym<( )>")
    if_null rx1163_debug, debug_877
    rx1163_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1163_pos)
  debug_877:
    .return (rx1163_cur)
  rx1163_restart:
.annotate 'line', 4
    if_null rx1163_debug, debug_878
    rx1163_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_878:
  rx1163_fail:
    (rx1163_rep, rx1163_pos, $I10, $P10) = rx1163_cur."!mark_fail"(0)
    lt rx1163_pos, -1, rx1163_done
    eq rx1163_pos, -1, rx1163_fail
    jump $I10
  rx1163_done:
    rx1163_cur."!cursor_fail"()
    if_null rx1163_debug, debug_879
    rx1163_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_879:
    .return (rx1163_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("254_1299450589.65") :method
.annotate 'line', 4
    $P1165 = self."!PREFIX__!subrule"("ws", "(")
    new $P1166, "ResizablePMCArray"
    push $P1166, $P1165
    .return ($P1166)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("255_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1171_tgt
    .local int rx1171_pos
    .local int rx1171_off
    .local int rx1171_eos
    .local int rx1171_rep
    .local pmc rx1171_cur
    .local pmc rx1171_debug
    (rx1171_cur, rx1171_pos, rx1171_tgt, $I10) = self."!cursor_start"()
    rx1171_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1171_cur
    .local pmc match
    .lex "$/", match
    length rx1171_eos, rx1171_tgt
    gt rx1171_pos, rx1171_eos, rx1171_done
    set rx1171_off, 0
    lt rx1171_pos, 2, rx1171_start
    sub rx1171_off, rx1171_pos, 1
    substr rx1171_tgt, rx1171_tgt, rx1171_off
  rx1171_start:
    eq $I10, 1, rx1171_restart
    if_null rx1171_debug, debug_880
    rx1171_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_880:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1175_done
    goto rxscan1175_scan
  rxscan1175_loop:
    (rx1171_pos) = rx1171_cur."from"()
    inc rx1171_pos
    rx1171_cur."!cursor_from"(rx1171_pos)
    ge rx1171_pos, rx1171_eos, rxscan1175_done
  rxscan1175_scan:
    set_addr $I10, rxscan1175_loop
    rx1171_cur."!mark_push"(0, rx1171_pos, $I10)
  rxscan1175_done:
.annotate 'line', 533
  # rx literal  "["
    add $I11, rx1171_pos, 1
    gt $I11, rx1171_eos, rx1171_fail
    sub $I11, rx1171_pos, rx1171_off
    ord $I11, rx1171_tgt, $I11
    ne $I11, 91, rx1171_fail
    add rx1171_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1171_cur."!cursor_pos"(rx1171_pos)
    $P10 = rx1171_cur."ws"()
    unless $P10, rx1171_fail
    rx1171_pos = $P10."pos"()
  # rx rxquantr1176 ** 0..1
    set_addr $I10, rxquantr1176_done
    rx1171_cur."!mark_push"(0, rx1171_pos, $I10)
  rxquantr1176_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1171_cur."!cursor_pos"(rx1171_pos)
    $P10 = rx1171_cur."EXPR"()
    unless $P10, rx1171_fail
    goto rxsubrule1177_pass
  rxsubrule1177_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1171_fail
  rxsubrule1177_pass:
    set_addr $I10, rxsubrule1177_back
    rx1171_cur."!mark_push"(0, rx1171_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1171_pos = $P10."pos"()
    set_addr $I10, rxquantr1176_done
    (rx1171_rep) = rx1171_cur."!mark_commit"($I10)
  rxquantr1176_done:
  # rx literal  "]"
    add $I11, rx1171_pos, 1
    gt $I11, rx1171_eos, rx1171_fail
    sub $I11, rx1171_pos, rx1171_off
    ord $I11, rx1171_tgt, $I11
    ne $I11, 93, rx1171_fail
    add rx1171_pos, 1
  # rx pass
    rx1171_cur."!cursor_pass"(rx1171_pos, "circumfix:sym<[ ]>")
    if_null rx1171_debug, debug_881
    rx1171_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1171_pos)
  debug_881:
    .return (rx1171_cur)
  rx1171_restart:
.annotate 'line', 4
    if_null rx1171_debug, debug_882
    rx1171_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_882:
  rx1171_fail:
    (rx1171_rep, rx1171_pos, $I10, $P10) = rx1171_cur."!mark_fail"(0)
    lt rx1171_pos, -1, rx1171_done
    eq rx1171_pos, -1, rx1171_fail
    jump $I10
  rx1171_done:
    rx1171_cur."!cursor_fail"()
    if_null rx1171_debug, debug_883
    rx1171_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_883:
    .return (rx1171_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("256_1299450589.65") :method
.annotate 'line', 4
    $P1173 = self."!PREFIX__!subrule"("ws", "[")
    new $P1174, "ResizablePMCArray"
    push $P1174, $P1173
    .return ($P1174)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("257_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1179_tgt
    .local int rx1179_pos
    .local int rx1179_off
    .local int rx1179_eos
    .local int rx1179_rep
    .local pmc rx1179_cur
    .local pmc rx1179_debug
    (rx1179_cur, rx1179_pos, rx1179_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1179_cur
    .local pmc match
    .lex "$/", match
    length rx1179_eos, rx1179_tgt
    gt rx1179_pos, rx1179_eos, rx1179_done
    set rx1179_off, 0
    lt rx1179_pos, 2, rx1179_start
    sub rx1179_off, rx1179_pos, 1
    substr rx1179_tgt, rx1179_tgt, rx1179_off
  rx1179_start:
    eq $I10, 1, rx1179_restart
    if_null rx1179_debug, debug_884
    rx1179_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_884:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1182_done
    goto rxscan1182_scan
  rxscan1182_loop:
    (rx1179_pos) = rx1179_cur."from"()
    inc rx1179_pos
    rx1179_cur."!cursor_from"(rx1179_pos)
    ge rx1179_pos, rx1179_eos, rxscan1182_done
  rxscan1182_scan:
    set_addr $I10, rxscan1182_loop
    rx1179_cur."!mark_push"(0, rx1179_pos, $I10)
  rxscan1182_done:
.annotate 'line', 534
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1179_pos, rx1179_off
    substr $S10, rx1179_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1179_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1179_cur."!cursor_pos"(rx1179_pos)
    $P10 = rx1179_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1179_fail
    rx1179_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1179_pos = $P10."pos"()
  # rx pass
    rx1179_cur."!cursor_pass"(rx1179_pos, "circumfix:sym<ang>")
    if_null rx1179_debug, debug_885
    rx1179_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1179_pos)
  debug_885:
    .return (rx1179_cur)
  rx1179_restart:
.annotate 'line', 4
    if_null rx1179_debug, debug_886
    rx1179_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_886:
  rx1179_fail:
    (rx1179_rep, rx1179_pos, $I10, $P10) = rx1179_cur."!mark_fail"(0)
    lt rx1179_pos, -1, rx1179_done
    eq rx1179_pos, -1, rx1179_fail
    jump $I10
  rx1179_done:
    rx1179_cur."!cursor_fail"()
    if_null rx1179_debug, debug_887
    rx1179_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_887:
    .return (rx1179_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("258_1299450589.65") :method
.annotate 'line', 4
    new $P1181, "ResizablePMCArray"
    push $P1181, "<"
    .return ($P1181)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("259_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1184_tgt
    .local int rx1184_pos
    .local int rx1184_off
    .local int rx1184_eos
    .local int rx1184_rep
    .local pmc rx1184_cur
    .local pmc rx1184_debug
    (rx1184_cur, rx1184_pos, rx1184_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1184_cur
    .local pmc match
    .lex "$/", match
    length rx1184_eos, rx1184_tgt
    gt rx1184_pos, rx1184_eos, rx1184_done
    set rx1184_off, 0
    lt rx1184_pos, 2, rx1184_start
    sub rx1184_off, rx1184_pos, 1
    substr rx1184_tgt, rx1184_tgt, rx1184_off
  rx1184_start:
    eq $I10, 1, rx1184_restart
    if_null rx1184_debug, debug_888
    rx1184_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_888:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1187_done
    goto rxscan1187_scan
  rxscan1187_loop:
    (rx1184_pos) = rx1184_cur."from"()
    inc rx1184_pos
    rx1184_cur."!cursor_from"(rx1184_pos)
    ge rx1184_pos, rx1184_eos, rxscan1187_done
  rxscan1187_scan:
    set_addr $I10, rxscan1187_loop
    rx1184_cur."!mark_push"(0, rx1184_pos, $I10)
  rxscan1187_done:
.annotate 'line', 535
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1184_pos, rx1184_off
    substr $S10, rx1184_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1184_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1184_cur."!cursor_pos"(rx1184_pos)
    $P10 = rx1184_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1184_fail
    rx1184_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1184_pos = $P10."pos"()
  # rx pass
    rx1184_cur."!cursor_pass"(rx1184_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1184_debug, debug_889
    rx1184_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1184_pos)
  debug_889:
    .return (rx1184_cur)
  rx1184_restart:
.annotate 'line', 4
    if_null rx1184_debug, debug_890
    rx1184_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_890:
  rx1184_fail:
    (rx1184_rep, rx1184_pos, $I10, $P10) = rx1184_cur."!mark_fail"(0)
    lt rx1184_pos, -1, rx1184_done
    eq rx1184_pos, -1, rx1184_fail
    jump $I10
  rx1184_done:
    rx1184_cur."!cursor_fail"()
    if_null rx1184_debug, debug_891
    rx1184_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_891:
    .return (rx1184_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("260_1299450589.65") :method
.annotate 'line', 4
    new $P1186, "ResizablePMCArray"
    push $P1186, unicode:"\x{ab}"
    .return ($P1186)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("261_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1189_tgt
    .local int rx1189_pos
    .local int rx1189_off
    .local int rx1189_eos
    .local int rx1189_rep
    .local pmc rx1189_cur
    .local pmc rx1189_debug
    (rx1189_cur, rx1189_pos, rx1189_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1189_cur
    .local pmc match
    .lex "$/", match
    length rx1189_eos, rx1189_tgt
    gt rx1189_pos, rx1189_eos, rx1189_done
    set rx1189_off, 0
    lt rx1189_pos, 2, rx1189_start
    sub rx1189_off, rx1189_pos, 1
    substr rx1189_tgt, rx1189_tgt, rx1189_off
  rx1189_start:
    eq $I10, 1, rx1189_restart
    if_null rx1189_debug, debug_892
    rx1189_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_892:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1192_done
    goto rxscan1192_scan
  rxscan1192_loop:
    (rx1189_pos) = rx1189_cur."from"()
    inc rx1189_pos
    rx1189_cur."!cursor_from"(rx1189_pos)
    ge rx1189_pos, rx1189_eos, rxscan1192_done
  rxscan1192_scan:
    set_addr $I10, rxscan1192_loop
    rx1189_cur."!mark_push"(0, rx1189_pos, $I10)
  rxscan1192_done:
.annotate 'line', 536
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1189_pos, rx1189_off
    substr $S10, rx1189_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1189_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1189_cur."!cursor_pos"(rx1189_pos)
    $P10 = rx1189_cur."pblock"()
    unless $P10, rx1189_fail
    rx1189_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1189_pos = $P10."pos"()
  # rx pass
    rx1189_cur."!cursor_pass"(rx1189_pos, "circumfix:sym<{ }>")
    if_null rx1189_debug, debug_893
    rx1189_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1189_pos)
  debug_893:
    .return (rx1189_cur)
  rx1189_restart:
.annotate 'line', 4
    if_null rx1189_debug, debug_894
    rx1189_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_894:
  rx1189_fail:
    (rx1189_rep, rx1189_pos, $I10, $P10) = rx1189_cur."!mark_fail"(0)
    lt rx1189_pos, -1, rx1189_done
    eq rx1189_pos, -1, rx1189_fail
    jump $I10
  rx1189_done:
    rx1189_cur."!cursor_fail"()
    if_null rx1189_debug, debug_895
    rx1189_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_895:
    .return (rx1189_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("262_1299450589.65") :method
.annotate 'line', 4
    new $P1191, "ResizablePMCArray"
    push $P1191, "{"
    .return ($P1191)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("263_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1194_tgt
    .local int rx1194_pos
    .local int rx1194_off
    .local int rx1194_eos
    .local int rx1194_rep
    .local pmc rx1194_cur
    .local pmc rx1194_debug
    (rx1194_cur, rx1194_pos, rx1194_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1194_cur
    .local pmc match
    .lex "$/", match
    length rx1194_eos, rx1194_tgt
    gt rx1194_pos, rx1194_eos, rx1194_done
    set rx1194_off, 0
    lt rx1194_pos, 2, rx1194_start
    sub rx1194_off, rx1194_pos, 1
    substr rx1194_tgt, rx1194_tgt, rx1194_off
  rx1194_start:
    eq $I10, 1, rx1194_restart
    if_null rx1194_debug, debug_896
    rx1194_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_896:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1198_done
    goto rxscan1198_scan
  rxscan1198_loop:
    (rx1194_pos) = rx1194_cur."from"()
    inc rx1194_pos
    rx1194_cur."!cursor_from"(rx1194_pos)
    ge rx1194_pos, rx1194_eos, rxscan1198_done
  rxscan1198_scan:
    set_addr $I10, rxscan1198_loop
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  rxscan1198_done:
.annotate 'line', 537
  # rx subrule "sigil" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."sigil"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1194_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1194_pos, 1
    gt $I11, rx1194_eos, rx1194_fail
    sub $I11, rx1194_pos, rx1194_off
    ord $I11, rx1194_tgt, $I11
    ne $I11, 40, rx1194_fail
    add rx1194_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."semilist"()
    unless $P10, rx1194_fail
    rx1194_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1194_pos = $P10."pos"()
  alt1199_0:
    set_addr $I10, alt1199_1
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10)
  # rx literal  ")"
    add $I11, rx1194_pos, 1
    gt $I11, rx1194_eos, rx1194_fail
    sub $I11, rx1194_pos, rx1194_off
    ord $I11, rx1194_tgt, $I11
    ne $I11, 41, rx1194_fail
    add rx1194_pos, 1
    goto alt1199_end
  alt1199_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1194_cur."!cursor_pos"(rx1194_pos)
    $P10 = rx1194_cur."FAILGOAL"("')'")
    unless $P10, rx1194_fail
    goto rxsubrule1201_pass
  rxsubrule1201_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1194_fail
  rxsubrule1201_pass:
    set_addr $I10, rxsubrule1201_back
    rx1194_cur."!mark_push"(0, rx1194_pos, $I10, $P10)
    rx1194_pos = $P10."pos"()
  alt1199_end:
  # rx pass
    rx1194_cur."!cursor_pass"(rx1194_pos, "circumfix:sym<sigil>")
    if_null rx1194_debug, debug_897
    rx1194_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1194_pos)
  debug_897:
    .return (rx1194_cur)
  rx1194_restart:
.annotate 'line', 4
    if_null rx1194_debug, debug_898
    rx1194_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_898:
  rx1194_fail:
    (rx1194_rep, rx1194_pos, $I10, $P10) = rx1194_cur."!mark_fail"(0)
    lt rx1194_pos, -1, rx1194_done
    eq rx1194_pos, -1, rx1194_fail
    jump $I10
  rx1194_done:
    rx1194_cur."!cursor_fail"()
    if_null rx1194_debug, debug_899
    rx1194_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_899:
    .return (rx1194_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("264_1299450589.65") :method
.annotate 'line', 4
    $P1196 = self."!PREFIX__!subrule"("sigil", "")
    new $P1197, "ResizablePMCArray"
    push $P1197, $P1196
    .return ($P1197)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("265_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1203_tgt
    .local int rx1203_pos
    .local int rx1203_off
    .local int rx1203_eos
    .local int rx1203_rep
    .local pmc rx1203_cur
    .local pmc rx1203_debug
    (rx1203_cur, rx1203_pos, rx1203_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1203_cur
    .local pmc match
    .lex "$/", match
    length rx1203_eos, rx1203_tgt
    gt rx1203_pos, rx1203_eos, rx1203_done
    set rx1203_off, 0
    lt rx1203_pos, 2, rx1203_start
    sub rx1203_off, rx1203_pos, 1
    substr rx1203_tgt, rx1203_tgt, rx1203_off
  rx1203_start:
    eq $I10, 1, rx1203_restart
    if_null rx1203_debug, debug_900
    rx1203_cur."!cursor_debug"("START", "semilist")
  debug_900:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    (rx1203_pos) = rx1203_cur."from"()
    inc rx1203_pos
    rx1203_cur."!cursor_from"(rx1203_pos)
    ge rx1203_pos, rx1203_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  rxscan1207_done:
.annotate 'line', 539
  # rx subrule "ws" subtype=method negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."ws"()
    unless $P10, rx1203_fail
    rx1203_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."statement"()
    unless $P10, rx1203_fail
    rx1203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1203_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."ws"()
    unless $P10, rx1203_fail
    rx1203_pos = $P10."pos"()
  # rx pass
    rx1203_cur."!cursor_pass"(rx1203_pos, "semilist")
    if_null rx1203_debug, debug_901
    rx1203_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1203_pos)
  debug_901:
    .return (rx1203_cur)
  rx1203_restart:
.annotate 'line', 4
    if_null rx1203_debug, debug_902
    rx1203_cur."!cursor_debug"("NEXT", "semilist")
  debug_902:
  rx1203_fail:
    (rx1203_rep, rx1203_pos, $I10, $P10) = rx1203_cur."!mark_fail"(0)
    lt rx1203_pos, -1, rx1203_done
    eq rx1203_pos, -1, rx1203_fail
    jump $I10
  rx1203_done:
    rx1203_cur."!cursor_fail"()
    if_null rx1203_debug, debug_903
    rx1203_cur."!cursor_debug"("FAIL", "semilist")
  debug_903:
    .return (rx1203_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("266_1299450589.65") :method
.annotate 'line', 4
    $P1205 = self."!PREFIX__!subrule"("ws", "")
    new $P1206, "ResizablePMCArray"
    push $P1206, $P1205
    .return ($P1206)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1210"  :anon :subid("267_1299450589.65") :outer("11_1299450589.65")
.annotate 'line', 4
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post904") :outer("267_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P1211 = "267_1299450589.65" 
    .local pmc block
    set block, $P1211
.annotate 'line', 544
    get_hll_global $P1212, ["NQP"], "Grammar"
    $P1212."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 545
    get_hll_global $P1213, ["NQP"], "Grammar"
    $P1213."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 546
    get_hll_global $P1214, ["NQP"], "Grammar"
    $P1214."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 547
    get_hll_global $P1215, ["NQP"], "Grammar"
    $P1215."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 548
    get_hll_global $P1216, ["NQP"], "Grammar"
    $P1216."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 549
    get_hll_global $P1217, ["NQP"], "Grammar"
    $P1217."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 550
    get_hll_global $P1218, ["NQP"], "Grammar"
    $P1218."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 551
    get_hll_global $P1219, ["NQP"], "Grammar"
    $P1219."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 552
    get_hll_global $P1220, ["NQP"], "Grammar"
    $P1220."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 553
    get_hll_global $P1221, ["NQP"], "Grammar"
    $P1221."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 554
    get_hll_global $P1222, ["NQP"], "Grammar"
    $P1222."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 555
    get_hll_global $P1223, ["NQP"], "Grammar"
    $P1223."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 556
    get_hll_global $P1224, ["NQP"], "Grammar"
    $P1224."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 557
    get_hll_global $P1225, ["NQP"], "Grammar"
    $P1225."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 558
    get_hll_global $P1226, ["NQP"], "Grammar"
    $P1226."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("268_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1228_tgt
    .local int rx1228_pos
    .local int rx1228_off
    .local int rx1228_eos
    .local int rx1228_rep
    .local pmc rx1228_cur
    .local pmc rx1228_debug
    (rx1228_cur, rx1228_pos, rx1228_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1228_cur
    .local pmc match
    .lex "$/", match
    length rx1228_eos, rx1228_tgt
    gt rx1228_pos, rx1228_eos, rx1228_done
    set rx1228_off, 0
    lt rx1228_pos, 2, rx1228_start
    sub rx1228_off, rx1228_pos, 1
    substr rx1228_tgt, rx1228_tgt, rx1228_off
  rx1228_start:
    eq $I10, 1, rx1228_restart
    if_null rx1228_debug, debug_905
    rx1228_cur."!cursor_debug"("START", "infixish")
  debug_905:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1231_done
    goto rxscan1231_scan
  rxscan1231_loop:
    (rx1228_pos) = rx1228_cur."from"()
    inc rx1228_pos
    rx1228_cur."!cursor_from"(rx1228_pos)
    ge rx1228_pos, rx1228_eos, rxscan1231_done
  rxscan1231_scan:
    set_addr $I10, rxscan1231_loop
    rx1228_cur."!mark_push"(0, rx1228_pos, $I10)
  rxscan1231_done:
.annotate 'line', 562
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."infixstopper"()
    if $P10, rx1228_fail
  # rx subrule "infix" subtype=capture negate=
    rx1228_cur."!cursor_pos"(rx1228_pos)
    $P10 = rx1228_cur."infix"()
    unless $P10, rx1228_fail
    rx1228_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1228_pos = $P10."pos"()
  # rx pass
    rx1228_cur."!cursor_pass"(rx1228_pos, "infixish")
    if_null rx1228_debug, debug_906
    rx1228_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1228_pos)
  debug_906:
    .return (rx1228_cur)
  rx1228_restart:
.annotate 'line', 4
    if_null rx1228_debug, debug_907
    rx1228_cur."!cursor_debug"("NEXT", "infixish")
  debug_907:
  rx1228_fail:
    (rx1228_rep, rx1228_pos, $I10, $P10) = rx1228_cur."!mark_fail"(0)
    lt rx1228_pos, -1, rx1228_done
    eq rx1228_pos, -1, rx1228_fail
    jump $I10
  rx1228_done:
    rx1228_cur."!cursor_fail"()
    if_null rx1228_debug, debug_908
    rx1228_cur."!cursor_debug"("FAIL", "infixish")
  debug_908:
    .return (rx1228_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("269_1299450589.65") :method
.annotate 'line', 4
    new $P1230, "ResizablePMCArray"
    push $P1230, ""
    .return ($P1230)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("270_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1233_tgt
    .local int rx1233_pos
    .local int rx1233_off
    .local int rx1233_eos
    .local int rx1233_rep
    .local pmc rx1233_cur
    .local pmc rx1233_debug
    (rx1233_cur, rx1233_pos, rx1233_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1233_cur
    .local pmc match
    .lex "$/", match
    length rx1233_eos, rx1233_tgt
    gt rx1233_pos, rx1233_eos, rx1233_done
    set rx1233_off, 0
    lt rx1233_pos, 2, rx1233_start
    sub rx1233_off, rx1233_pos, 1
    substr rx1233_tgt, rx1233_tgt, rx1233_off
  rx1233_start:
    eq $I10, 1, rx1233_restart
    if_null rx1233_debug, debug_909
    rx1233_cur."!cursor_debug"("START", "infixstopper")
  debug_909:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1236_done
    goto rxscan1236_scan
  rxscan1236_loop:
    (rx1233_pos) = rx1233_cur."from"()
    inc rx1233_pos
    rx1233_cur."!cursor_from"(rx1233_pos)
    ge rx1233_pos, rx1233_eos, rxscan1236_done
  rxscan1236_scan:
    set_addr $I10, rxscan1236_loop
    rx1233_cur."!mark_push"(0, rx1233_pos, $I10)
  rxscan1236_done:
.annotate 'line', 563
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1233_cur."!cursor_pos"(rx1233_pos)
    $P10 = rx1233_cur."lambda"()
    unless $P10, rx1233_fail
  # rx pass
    rx1233_cur."!cursor_pass"(rx1233_pos, "infixstopper")
    if_null rx1233_debug, debug_910
    rx1233_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1233_pos)
  debug_910:
    .return (rx1233_cur)
  rx1233_restart:
.annotate 'line', 4
    if_null rx1233_debug, debug_911
    rx1233_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_911:
  rx1233_fail:
    (rx1233_rep, rx1233_pos, $I10, $P10) = rx1233_cur."!mark_fail"(0)
    lt rx1233_pos, -1, rx1233_done
    eq rx1233_pos, -1, rx1233_fail
    jump $I10
  rx1233_done:
    rx1233_cur."!cursor_fail"()
    if_null rx1233_debug, debug_912
    rx1233_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_912:
    .return (rx1233_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("271_1299450589.65") :method
.annotate 'line', 4
    new $P1235, "ResizablePMCArray"
    push $P1235, ""
    .return ($P1235)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("272_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1238_tgt
    .local int rx1238_pos
    .local int rx1238_off
    .local int rx1238_eos
    .local int rx1238_rep
    .local pmc rx1238_cur
    .local pmc rx1238_debug
    (rx1238_cur, rx1238_pos, rx1238_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1238_cur
    .local pmc match
    .lex "$/", match
    length rx1238_eos, rx1238_tgt
    gt rx1238_pos, rx1238_eos, rx1238_done
    set rx1238_off, 0
    lt rx1238_pos, 2, rx1238_start
    sub rx1238_off, rx1238_pos, 1
    substr rx1238_tgt, rx1238_tgt, rx1238_off
  rx1238_start:
    eq $I10, 1, rx1238_restart
    if_null rx1238_debug, debug_913
    rx1238_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_913:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1242_done
    goto rxscan1242_scan
  rxscan1242_loop:
    (rx1238_pos) = rx1238_cur."from"()
    inc rx1238_pos
    rx1238_cur."!cursor_from"(rx1238_pos)
    ge rx1238_pos, rx1238_eos, rxscan1242_done
  rxscan1242_scan:
    set_addr $I10, rxscan1242_loop
    rx1238_cur."!mark_push"(0, rx1238_pos, $I10)
  rxscan1242_done:
.annotate 'line', 566
  # rx literal  "["
    add $I11, rx1238_pos, 1
    gt $I11, rx1238_eos, rx1238_fail
    sub $I11, rx1238_pos, rx1238_off
    ord $I11, rx1238_tgt, $I11
    ne $I11, 91, rx1238_fail
    add rx1238_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."ws"()
    unless $P10, rx1238_fail
    rx1238_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."EXPR"()
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1238_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1238_pos, 1
    gt $I11, rx1238_eos, rx1238_fail
    sub $I11, rx1238_pos, rx1238_off
    ord $I11, rx1238_tgt, $I11
    ne $I11, 93, rx1238_fail
    add rx1238_pos, 1
.annotate 'line', 567
  # rx subrule "O" subtype=capture negate=
    rx1238_cur."!cursor_pos"(rx1238_pos)
    $P10 = rx1238_cur."O"("%methodop")
    unless $P10, rx1238_fail
    rx1238_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1238_pos = $P10."pos"()
.annotate 'line', 565
  # rx pass
    rx1238_cur."!cursor_pass"(rx1238_pos, "postcircumfix:sym<[ ]>")
    if_null rx1238_debug, debug_914
    rx1238_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1238_pos)
  debug_914:
    .return (rx1238_cur)
  rx1238_restart:
.annotate 'line', 4
    if_null rx1238_debug, debug_915
    rx1238_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_915:
  rx1238_fail:
    (rx1238_rep, rx1238_pos, $I10, $P10) = rx1238_cur."!mark_fail"(0)
    lt rx1238_pos, -1, rx1238_done
    eq rx1238_pos, -1, rx1238_fail
    jump $I10
  rx1238_done:
    rx1238_cur."!cursor_fail"()
    if_null rx1238_debug, debug_916
    rx1238_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_916:
    .return (rx1238_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("273_1299450589.65") :method
.annotate 'line', 4
    $P1240 = self."!PREFIX__!subrule"("ws", "[")
    new $P1241, "ResizablePMCArray"
    push $P1241, $P1240
    .return ($P1241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("274_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_917
    rx1244_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_917:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 571
  # rx literal  "{"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 123, rx1244_fail
    add rx1244_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."ws"()
    unless $P10, rx1244_fail
    rx1244_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."EXPR"()
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1244_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 125, rx1244_fail
    add rx1244_pos, 1
.annotate 'line', 572
  # rx subrule "O" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."O"("%methodop")
    unless $P10, rx1244_fail
    rx1244_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1244_pos = $P10."pos"()
.annotate 'line', 570
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "postcircumfix:sym<{ }>")
    if_null rx1244_debug, debug_918
    rx1244_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1244_pos)
  debug_918:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 4
    if_null rx1244_debug, debug_919
    rx1244_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_919:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_920
    rx1244_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_920:
    .return (rx1244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("275_1299450589.65") :method
.annotate 'line', 4
    $P1246 = self."!PREFIX__!subrule"("ws", "{")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("276_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1250_tgt
    .local int rx1250_pos
    .local int rx1250_off
    .local int rx1250_eos
    .local int rx1250_rep
    .local pmc rx1250_cur
    .local pmc rx1250_debug
    (rx1250_cur, rx1250_pos, rx1250_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1250_cur
    .local pmc match
    .lex "$/", match
    length rx1250_eos, rx1250_tgt
    gt rx1250_pos, rx1250_eos, rx1250_done
    set rx1250_off, 0
    lt rx1250_pos, 2, rx1250_start
    sub rx1250_off, rx1250_pos, 1
    substr rx1250_tgt, rx1250_tgt, rx1250_off
  rx1250_start:
    eq $I10, 1, rx1250_restart
    if_null rx1250_debug, debug_921
    rx1250_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_921:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1253_done
    goto rxscan1253_scan
  rxscan1253_loop:
    (rx1250_pos) = rx1250_cur."from"()
    inc rx1250_pos
    rx1250_cur."!cursor_from"(rx1250_pos)
    ge rx1250_pos, rx1250_eos, rxscan1253_done
  rxscan1253_scan:
    set_addr $I10, rxscan1253_loop
    rx1250_cur."!mark_push"(0, rx1250_pos, $I10)
  rxscan1253_done:
.annotate 'line', 576
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1250_pos, rx1250_off
    substr $S10, rx1250_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1250_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."quote_EXPR"(":q")
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1250_pos = $P10."pos"()
.annotate 'line', 577
  # rx subrule "O" subtype=capture negate=
    rx1250_cur."!cursor_pos"(rx1250_pos)
    $P10 = rx1250_cur."O"("%methodop")
    unless $P10, rx1250_fail
    rx1250_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1250_pos = $P10."pos"()
.annotate 'line', 575
  # rx pass
    rx1250_cur."!cursor_pass"(rx1250_pos, "postcircumfix:sym<ang>")
    if_null rx1250_debug, debug_922
    rx1250_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1250_pos)
  debug_922:
    .return (rx1250_cur)
  rx1250_restart:
.annotate 'line', 4
    if_null rx1250_debug, debug_923
    rx1250_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_923:
  rx1250_fail:
    (rx1250_rep, rx1250_pos, $I10, $P10) = rx1250_cur."!mark_fail"(0)
    lt rx1250_pos, -1, rx1250_done
    eq rx1250_pos, -1, rx1250_fail
    jump $I10
  rx1250_done:
    rx1250_cur."!cursor_fail"()
    if_null rx1250_debug, debug_924
    rx1250_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_924:
    .return (rx1250_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("277_1299450589.65") :method
.annotate 'line', 4
    new $P1252, "ResizablePMCArray"
    push $P1252, "<"
    .return ($P1252)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("278_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1255_tgt
    .local int rx1255_pos
    .local int rx1255_off
    .local int rx1255_eos
    .local int rx1255_rep
    .local pmc rx1255_cur
    .local pmc rx1255_debug
    (rx1255_cur, rx1255_pos, rx1255_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1255_cur
    .local pmc match
    .lex "$/", match
    length rx1255_eos, rx1255_tgt
    gt rx1255_pos, rx1255_eos, rx1255_done
    set rx1255_off, 0
    lt rx1255_pos, 2, rx1255_start
    sub rx1255_off, rx1255_pos, 1
    substr rx1255_tgt, rx1255_tgt, rx1255_off
  rx1255_start:
    eq $I10, 1, rx1255_restart
    if_null rx1255_debug, debug_925
    rx1255_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_925:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1259_done
    goto rxscan1259_scan
  rxscan1259_loop:
    (rx1255_pos) = rx1255_cur."from"()
    inc rx1255_pos
    rx1255_cur."!cursor_from"(rx1255_pos)
    ge rx1255_pos, rx1255_eos, rxscan1259_done
  rxscan1259_scan:
    set_addr $I10, rxscan1259_loop
    rx1255_cur."!mark_push"(0, rx1255_pos, $I10)
  rxscan1259_done:
.annotate 'line', 581
  # rx literal  "("
    add $I11, rx1255_pos, 1
    gt $I11, rx1255_eos, rx1255_fail
    sub $I11, rx1255_pos, rx1255_off
    ord $I11, rx1255_tgt, $I11
    ne $I11, 40, rx1255_fail
    add rx1255_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1255_cur."!cursor_pos"(rx1255_pos)
    $P10 = rx1255_cur."ws"()
    unless $P10, rx1255_fail
    rx1255_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1255_cur."!cursor_pos"(rx1255_pos)
    $P10 = rx1255_cur."arglist"()
    unless $P10, rx1255_fail
    rx1255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1255_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1255_pos, 1
    gt $I11, rx1255_eos, rx1255_fail
    sub $I11, rx1255_pos, rx1255_off
    ord $I11, rx1255_tgt, $I11
    ne $I11, 41, rx1255_fail
    add rx1255_pos, 1
.annotate 'line', 582
  # rx subrule "O" subtype=capture negate=
    rx1255_cur."!cursor_pos"(rx1255_pos)
    $P10 = rx1255_cur."O"("%methodop")
    unless $P10, rx1255_fail
    rx1255_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1255_pos = $P10."pos"()
.annotate 'line', 580
  # rx pass
    rx1255_cur."!cursor_pass"(rx1255_pos, "postcircumfix:sym<( )>")
    if_null rx1255_debug, debug_926
    rx1255_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1255_pos)
  debug_926:
    .return (rx1255_cur)
  rx1255_restart:
.annotate 'line', 4
    if_null rx1255_debug, debug_927
    rx1255_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_927:
  rx1255_fail:
    (rx1255_rep, rx1255_pos, $I10, $P10) = rx1255_cur."!mark_fail"(0)
    lt rx1255_pos, -1, rx1255_done
    eq rx1255_pos, -1, rx1255_fail
    jump $I10
  rx1255_done:
    rx1255_cur."!cursor_fail"()
    if_null rx1255_debug, debug_928
    rx1255_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_928:
    .return (rx1255_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("279_1299450589.65") :method
.annotate 'line', 4
    $P1257 = self."!PREFIX__!subrule"("ws", "(")
    new $P1258, "ResizablePMCArray"
    push $P1258, $P1257
    .return ($P1258)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("280_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1261_tgt
    .local int rx1261_pos
    .local int rx1261_off
    .local int rx1261_eos
    .local int rx1261_rep
    .local pmc rx1261_cur
    .local pmc rx1261_debug
    (rx1261_cur, rx1261_pos, rx1261_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1261_cur
    .local pmc match
    .lex "$/", match
    length rx1261_eos, rx1261_tgt
    gt rx1261_pos, rx1261_eos, rx1261_done
    set rx1261_off, 0
    lt rx1261_pos, 2, rx1261_start
    sub rx1261_off, rx1261_pos, 1
    substr rx1261_tgt, rx1261_tgt, rx1261_off
  rx1261_start:
    eq $I10, 1, rx1261_restart
    if_null rx1261_debug, debug_929
    rx1261_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_929:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1265_done
    goto rxscan1265_scan
  rxscan1265_loop:
    (rx1261_pos) = rx1261_cur."from"()
    inc rx1261_pos
    rx1261_cur."!cursor_from"(rx1261_pos)
    ge rx1261_pos, rx1261_eos, rxscan1265_done
  rxscan1265_scan:
    set_addr $I10, rxscan1265_loop
    rx1261_cur."!mark_push"(0, rx1261_pos, $I10)
  rxscan1265_done:
.annotate 'line', 585
  # rx subrule "dotty" subtype=capture negate=
    rx1261_cur."!cursor_pos"(rx1261_pos)
    $P10 = rx1261_cur."dotty"()
    unless $P10, rx1261_fail
    rx1261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1261_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1261_cur."!cursor_pos"(rx1261_pos)
    $P10 = rx1261_cur."O"("%methodop")
    unless $P10, rx1261_fail
    rx1261_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1261_pos = $P10."pos"()
  # rx pass
    rx1261_cur."!cursor_pass"(rx1261_pos, "postfix:sym<.>")
    if_null rx1261_debug, debug_930
    rx1261_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1261_pos)
  debug_930:
    .return (rx1261_cur)
  rx1261_restart:
.annotate 'line', 4
    if_null rx1261_debug, debug_931
    rx1261_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_931:
  rx1261_fail:
    (rx1261_rep, rx1261_pos, $I10, $P10) = rx1261_cur."!mark_fail"(0)
    lt rx1261_pos, -1, rx1261_done
    eq rx1261_pos, -1, rx1261_fail
    jump $I10
  rx1261_done:
    rx1261_cur."!cursor_fail"()
    if_null rx1261_debug, debug_932
    rx1261_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_932:
    .return (rx1261_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("281_1299450589.65") :method
.annotate 'line', 4
    $P1263 = self."!PREFIX__!subrule"("dotty", "")
    new $P1264, "ResizablePMCArray"
    push $P1264, $P1263
    .return ($P1264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("282_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1267_tgt
    .local int rx1267_pos
    .local int rx1267_off
    .local int rx1267_eos
    .local int rx1267_rep
    .local pmc rx1267_cur
    .local pmc rx1267_debug
    (rx1267_cur, rx1267_pos, rx1267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1267_cur
    .local pmc match
    .lex "$/", match
    length rx1267_eos, rx1267_tgt
    gt rx1267_pos, rx1267_eos, rx1267_done
    set rx1267_off, 0
    lt rx1267_pos, 2, rx1267_start
    sub rx1267_off, rx1267_pos, 1
    substr rx1267_tgt, rx1267_tgt, rx1267_off
  rx1267_start:
    eq $I10, 1, rx1267_restart
    if_null rx1267_debug, debug_933
    rx1267_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_933:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1271_done
    goto rxscan1271_scan
  rxscan1271_loop:
    (rx1267_pos) = rx1267_cur."from"()
    inc rx1267_pos
    rx1267_cur."!cursor_from"(rx1267_pos)
    ge rx1267_pos, rx1267_eos, rxscan1271_done
  rxscan1271_scan:
    set_addr $I10, rxscan1271_loop
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  rxscan1271_done:
.annotate 'line', 587
  # rx subcapture "sym"
    set_addr $I10, rxcap_1272_fail
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  # rx literal  "++"
    add $I11, rx1267_pos, 2
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    substr $S10, rx1267_tgt, $I11, 2
    ne $S10, "++", rx1267_fail
    add rx1267_pos, 2
    set_addr $I10, rxcap_1272_fail
    ($I12, $I11) = rx1267_cur."!mark_peek"($I10)
    rx1267_cur."!cursor_pos"($I11)
    ($P10) = rx1267_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1267_pos, "")
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1272_done
  rxcap_1272_fail:
    goto rx1267_fail
  rxcap_1272_done:
  # rx subrule "O" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1267_pos = $P10."pos"()
  # rx pass
    rx1267_cur."!cursor_pass"(rx1267_pos, "prefix:sym<++>")
    if_null rx1267_debug, debug_934
    rx1267_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1267_pos)
  debug_934:
    .return (rx1267_cur)
  rx1267_restart:
.annotate 'line', 4
    if_null rx1267_debug, debug_935
    rx1267_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_935:
  rx1267_fail:
    (rx1267_rep, rx1267_pos, $I10, $P10) = rx1267_cur."!mark_fail"(0)
    lt rx1267_pos, -1, rx1267_done
    eq rx1267_pos, -1, rx1267_fail
    jump $I10
  rx1267_done:
    rx1267_cur."!cursor_fail"()
    if_null rx1267_debug, debug_936
    rx1267_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_936:
    .return (rx1267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("283_1299450589.65") :method
.annotate 'line', 4
    $P1269 = self."!PREFIX__!subrule"("O", "++")
    new $P1270, "ResizablePMCArray"
    push $P1270, $P1269
    .return ($P1270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("284_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1274_tgt
    .local int rx1274_pos
    .local int rx1274_off
    .local int rx1274_eos
    .local int rx1274_rep
    .local pmc rx1274_cur
    .local pmc rx1274_debug
    (rx1274_cur, rx1274_pos, rx1274_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1274_cur
    .local pmc match
    .lex "$/", match
    length rx1274_eos, rx1274_tgt
    gt rx1274_pos, rx1274_eos, rx1274_done
    set rx1274_off, 0
    lt rx1274_pos, 2, rx1274_start
    sub rx1274_off, rx1274_pos, 1
    substr rx1274_tgt, rx1274_tgt, rx1274_off
  rx1274_start:
    eq $I10, 1, rx1274_restart
    if_null rx1274_debug, debug_937
    rx1274_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_937:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1278_done
    goto rxscan1278_scan
  rxscan1278_loop:
    (rx1274_pos) = rx1274_cur."from"()
    inc rx1274_pos
    rx1274_cur."!cursor_from"(rx1274_pos)
    ge rx1274_pos, rx1274_eos, rxscan1278_done
  rxscan1278_scan:
    set_addr $I10, rxscan1278_loop
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  rxscan1278_done:
.annotate 'line', 588
  # rx subcapture "sym"
    set_addr $I10, rxcap_1279_fail
    rx1274_cur."!mark_push"(0, rx1274_pos, $I10)
  # rx literal  "--"
    add $I11, rx1274_pos, 2
    gt $I11, rx1274_eos, rx1274_fail
    sub $I11, rx1274_pos, rx1274_off
    substr $S10, rx1274_tgt, $I11, 2
    ne $S10, "--", rx1274_fail
    add rx1274_pos, 2
    set_addr $I10, rxcap_1279_fail
    ($I12, $I11) = rx1274_cur."!mark_peek"($I10)
    rx1274_cur."!cursor_pos"($I11)
    ($P10) = rx1274_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1274_pos, "")
    rx1274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1279_done
  rxcap_1279_fail:
    goto rx1274_fail
  rxcap_1279_done:
  # rx subrule "O" subtype=capture negate=
    rx1274_cur."!cursor_pos"(rx1274_pos)
    $P10 = rx1274_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1274_fail
    rx1274_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1274_pos = $P10."pos"()
  # rx pass
    rx1274_cur."!cursor_pass"(rx1274_pos, "prefix:sym<-->")
    if_null rx1274_debug, debug_938
    rx1274_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1274_pos)
  debug_938:
    .return (rx1274_cur)
  rx1274_restart:
.annotate 'line', 4
    if_null rx1274_debug, debug_939
    rx1274_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_939:
  rx1274_fail:
    (rx1274_rep, rx1274_pos, $I10, $P10) = rx1274_cur."!mark_fail"(0)
    lt rx1274_pos, -1, rx1274_done
    eq rx1274_pos, -1, rx1274_fail
    jump $I10
  rx1274_done:
    rx1274_cur."!cursor_fail"()
    if_null rx1274_debug, debug_940
    rx1274_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_940:
    .return (rx1274_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("285_1299450589.65") :method
.annotate 'line', 4
    $P1276 = self."!PREFIX__!subrule"("O", "--")
    new $P1277, "ResizablePMCArray"
    push $P1277, $P1276
    .return ($P1277)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("286_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1281_tgt
    .local int rx1281_pos
    .local int rx1281_off
    .local int rx1281_eos
    .local int rx1281_rep
    .local pmc rx1281_cur
    .local pmc rx1281_debug
    (rx1281_cur, rx1281_pos, rx1281_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1281_cur
    .local pmc match
    .lex "$/", match
    length rx1281_eos, rx1281_tgt
    gt rx1281_pos, rx1281_eos, rx1281_done
    set rx1281_off, 0
    lt rx1281_pos, 2, rx1281_start
    sub rx1281_off, rx1281_pos, 1
    substr rx1281_tgt, rx1281_tgt, rx1281_off
  rx1281_start:
    eq $I10, 1, rx1281_restart
    if_null rx1281_debug, debug_941
    rx1281_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1285_done
    goto rxscan1285_scan
  rxscan1285_loop:
    (rx1281_pos) = rx1281_cur."from"()
    inc rx1281_pos
    rx1281_cur."!cursor_from"(rx1281_pos)
    ge rx1281_pos, rx1281_eos, rxscan1285_done
  rxscan1285_scan:
    set_addr $I10, rxscan1285_loop
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  rxscan1285_done:
.annotate 'line', 591
  # rx subcapture "sym"
    set_addr $I10, rxcap_1286_fail
    rx1281_cur."!mark_push"(0, rx1281_pos, $I10)
  # rx literal  "++"
    add $I11, rx1281_pos, 2
    gt $I11, rx1281_eos, rx1281_fail
    sub $I11, rx1281_pos, rx1281_off
    substr $S10, rx1281_tgt, $I11, 2
    ne $S10, "++", rx1281_fail
    add rx1281_pos, 2
    set_addr $I10, rxcap_1286_fail
    ($I12, $I11) = rx1281_cur."!mark_peek"($I10)
    rx1281_cur."!cursor_pos"($I11)
    ($P10) = rx1281_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1281_pos, "")
    rx1281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1286_done
  rxcap_1286_fail:
    goto rx1281_fail
  rxcap_1286_done:
  # rx subrule "O" subtype=capture negate=
    rx1281_cur."!cursor_pos"(rx1281_pos)
    $P10 = rx1281_cur."O"("%autoincrement")
    unless $P10, rx1281_fail
    rx1281_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1281_pos = $P10."pos"()
  # rx pass
    rx1281_cur."!cursor_pass"(rx1281_pos, "postfix:sym<++>")
    if_null rx1281_debug, debug_942
    rx1281_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1281_pos)
  debug_942:
    .return (rx1281_cur)
  rx1281_restart:
.annotate 'line', 4
    if_null rx1281_debug, debug_943
    rx1281_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_943:
  rx1281_fail:
    (rx1281_rep, rx1281_pos, $I10, $P10) = rx1281_cur."!mark_fail"(0)
    lt rx1281_pos, -1, rx1281_done
    eq rx1281_pos, -1, rx1281_fail
    jump $I10
  rx1281_done:
    rx1281_cur."!cursor_fail"()
    if_null rx1281_debug, debug_944
    rx1281_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_944:
    .return (rx1281_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("287_1299450589.65") :method
.annotate 'line', 4
    $P1283 = self."!PREFIX__!subrule"("O", "++")
    new $P1284, "ResizablePMCArray"
    push $P1284, $P1283
    .return ($P1284)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("288_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1288_tgt
    .local int rx1288_pos
    .local int rx1288_off
    .local int rx1288_eos
    .local int rx1288_rep
    .local pmc rx1288_cur
    .local pmc rx1288_debug
    (rx1288_cur, rx1288_pos, rx1288_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1288_cur
    .local pmc match
    .lex "$/", match
    length rx1288_eos, rx1288_tgt
    gt rx1288_pos, rx1288_eos, rx1288_done
    set rx1288_off, 0
    lt rx1288_pos, 2, rx1288_start
    sub rx1288_off, rx1288_pos, 1
    substr rx1288_tgt, rx1288_tgt, rx1288_off
  rx1288_start:
    eq $I10, 1, rx1288_restart
    if_null rx1288_debug, debug_945
    rx1288_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1292_done
    goto rxscan1292_scan
  rxscan1292_loop:
    (rx1288_pos) = rx1288_cur."from"()
    inc rx1288_pos
    rx1288_cur."!cursor_from"(rx1288_pos)
    ge rx1288_pos, rx1288_eos, rxscan1292_done
  rxscan1292_scan:
    set_addr $I10, rxscan1292_loop
    rx1288_cur."!mark_push"(0, rx1288_pos, $I10)
  rxscan1292_done:
.annotate 'line', 592
  # rx subcapture "sym"
    set_addr $I10, rxcap_1293_fail
    rx1288_cur."!mark_push"(0, rx1288_pos, $I10)
  # rx literal  "--"
    add $I11, rx1288_pos, 2
    gt $I11, rx1288_eos, rx1288_fail
    sub $I11, rx1288_pos, rx1288_off
    substr $S10, rx1288_tgt, $I11, 2
    ne $S10, "--", rx1288_fail
    add rx1288_pos, 2
    set_addr $I10, rxcap_1293_fail
    ($I12, $I11) = rx1288_cur."!mark_peek"($I10)
    rx1288_cur."!cursor_pos"($I11)
    ($P10) = rx1288_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1288_pos, "")
    rx1288_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1293_done
  rxcap_1293_fail:
    goto rx1288_fail
  rxcap_1293_done:
  # rx subrule "O" subtype=capture negate=
    rx1288_cur."!cursor_pos"(rx1288_pos)
    $P10 = rx1288_cur."O"("%autoincrement")
    unless $P10, rx1288_fail
    rx1288_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1288_pos = $P10."pos"()
  # rx pass
    rx1288_cur."!cursor_pass"(rx1288_pos, "postfix:sym<-->")
    if_null rx1288_debug, debug_946
    rx1288_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1288_pos)
  debug_946:
    .return (rx1288_cur)
  rx1288_restart:
.annotate 'line', 4
    if_null rx1288_debug, debug_947
    rx1288_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_947:
  rx1288_fail:
    (rx1288_rep, rx1288_pos, $I10, $P10) = rx1288_cur."!mark_fail"(0)
    lt rx1288_pos, -1, rx1288_done
    eq rx1288_pos, -1, rx1288_fail
    jump $I10
  rx1288_done:
    rx1288_cur."!cursor_fail"()
    if_null rx1288_debug, debug_948
    rx1288_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_948:
    .return (rx1288_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("289_1299450589.65") :method
.annotate 'line', 4
    $P1290 = self."!PREFIX__!subrule"("O", "--")
    new $P1291, "ResizablePMCArray"
    push $P1291, $P1290
    .return ($P1291)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("290_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1295_tgt
    .local int rx1295_pos
    .local int rx1295_off
    .local int rx1295_eos
    .local int rx1295_rep
    .local pmc rx1295_cur
    .local pmc rx1295_debug
    (rx1295_cur, rx1295_pos, rx1295_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1295_cur
    .local pmc match
    .lex "$/", match
    length rx1295_eos, rx1295_tgt
    gt rx1295_pos, rx1295_eos, rx1295_done
    set rx1295_off, 0
    lt rx1295_pos, 2, rx1295_start
    sub rx1295_off, rx1295_pos, 1
    substr rx1295_tgt, rx1295_tgt, rx1295_off
  rx1295_start:
    eq $I10, 1, rx1295_restart
    if_null rx1295_debug, debug_949
    rx1295_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1299_done
    goto rxscan1299_scan
  rxscan1299_loop:
    (rx1295_pos) = rx1295_cur."from"()
    inc rx1295_pos
    rx1295_cur."!cursor_from"(rx1295_pos)
    ge rx1295_pos, rx1295_eos, rxscan1299_done
  rxscan1299_scan:
    set_addr $I10, rxscan1299_loop
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  rxscan1299_done:
.annotate 'line', 594
  # rx subcapture "sym"
    set_addr $I10, rxcap_1300_fail
    rx1295_cur."!mark_push"(0, rx1295_pos, $I10)
  # rx literal  "**"
    add $I11, rx1295_pos, 2
    gt $I11, rx1295_eos, rx1295_fail
    sub $I11, rx1295_pos, rx1295_off
    substr $S10, rx1295_tgt, $I11, 2
    ne $S10, "**", rx1295_fail
    add rx1295_pos, 2
    set_addr $I10, rxcap_1300_fail
    ($I12, $I11) = rx1295_cur."!mark_peek"($I10)
    rx1295_cur."!cursor_pos"($I11)
    ($P10) = rx1295_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1295_pos, "")
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1300_done
  rxcap_1300_fail:
    goto rx1295_fail
  rxcap_1300_done:
  # rx subrule "O" subtype=capture negate=
    rx1295_cur."!cursor_pos"(rx1295_pos)
    $P10 = rx1295_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1295_fail
    rx1295_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1295_pos = $P10."pos"()
  # rx pass
    rx1295_cur."!cursor_pass"(rx1295_pos, "infix:sym<**>")
    if_null rx1295_debug, debug_950
    rx1295_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1295_pos)
  debug_950:
    .return (rx1295_cur)
  rx1295_restart:
.annotate 'line', 4
    if_null rx1295_debug, debug_951
    rx1295_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_951:
  rx1295_fail:
    (rx1295_rep, rx1295_pos, $I10, $P10) = rx1295_cur."!mark_fail"(0)
    lt rx1295_pos, -1, rx1295_done
    eq rx1295_pos, -1, rx1295_fail
    jump $I10
  rx1295_done:
    rx1295_cur."!cursor_fail"()
    if_null rx1295_debug, debug_952
    rx1295_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_952:
    .return (rx1295_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("291_1299450589.65") :method
.annotate 'line', 4
    $P1297 = self."!PREFIX__!subrule"("O", "**")
    new $P1298, "ResizablePMCArray"
    push $P1298, $P1297
    .return ($P1298)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("292_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1302_tgt
    .local int rx1302_pos
    .local int rx1302_off
    .local int rx1302_eos
    .local int rx1302_rep
    .local pmc rx1302_cur
    .local pmc rx1302_debug
    (rx1302_cur, rx1302_pos, rx1302_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1302_cur
    .local pmc match
    .lex "$/", match
    length rx1302_eos, rx1302_tgt
    gt rx1302_pos, rx1302_eos, rx1302_done
    set rx1302_off, 0
    lt rx1302_pos, 2, rx1302_start
    sub rx1302_off, rx1302_pos, 1
    substr rx1302_tgt, rx1302_tgt, rx1302_off
  rx1302_start:
    eq $I10, 1, rx1302_restart
    if_null rx1302_debug, debug_953
    rx1302_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1306_done
    goto rxscan1306_scan
  rxscan1306_loop:
    (rx1302_pos) = rx1302_cur."from"()
    inc rx1302_pos
    rx1302_cur."!cursor_from"(rx1302_pos)
    ge rx1302_pos, rx1302_eos, rxscan1306_done
  rxscan1306_scan:
    set_addr $I10, rxscan1306_loop
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  rxscan1306_done:
.annotate 'line', 596
  # rx subcapture "sym"
    set_addr $I10, rxcap_1307_fail
    rx1302_cur."!mark_push"(0, rx1302_pos, $I10)
  # rx literal  "+"
    add $I11, rx1302_pos, 1
    gt $I11, rx1302_eos, rx1302_fail
    sub $I11, rx1302_pos, rx1302_off
    ord $I11, rx1302_tgt, $I11
    ne $I11, 43, rx1302_fail
    add rx1302_pos, 1
    set_addr $I10, rxcap_1307_fail
    ($I12, $I11) = rx1302_cur."!mark_peek"($I10)
    rx1302_cur."!cursor_pos"($I11)
    ($P10) = rx1302_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1302_pos, "")
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1307_done
  rxcap_1307_fail:
    goto rx1302_fail
  rxcap_1307_done:
  # rx subrule "O" subtype=capture negate=
    rx1302_cur."!cursor_pos"(rx1302_pos)
    $P10 = rx1302_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1302_fail
    rx1302_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1302_pos = $P10."pos"()
  # rx pass
    rx1302_cur."!cursor_pass"(rx1302_pos, "prefix:sym<+>")
    if_null rx1302_debug, debug_954
    rx1302_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1302_pos)
  debug_954:
    .return (rx1302_cur)
  rx1302_restart:
.annotate 'line', 4
    if_null rx1302_debug, debug_955
    rx1302_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_955:
  rx1302_fail:
    (rx1302_rep, rx1302_pos, $I10, $P10) = rx1302_cur."!mark_fail"(0)
    lt rx1302_pos, -1, rx1302_done
    eq rx1302_pos, -1, rx1302_fail
    jump $I10
  rx1302_done:
    rx1302_cur."!cursor_fail"()
    if_null rx1302_debug, debug_956
    rx1302_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_956:
    .return (rx1302_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("293_1299450589.65") :method
.annotate 'line', 4
    $P1304 = self."!PREFIX__!subrule"("O", "+")
    new $P1305, "ResizablePMCArray"
    push $P1305, $P1304
    .return ($P1305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("294_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1309_tgt
    .local int rx1309_pos
    .local int rx1309_off
    .local int rx1309_eos
    .local int rx1309_rep
    .local pmc rx1309_cur
    .local pmc rx1309_debug
    (rx1309_cur, rx1309_pos, rx1309_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1309_cur
    .local pmc match
    .lex "$/", match
    length rx1309_eos, rx1309_tgt
    gt rx1309_pos, rx1309_eos, rx1309_done
    set rx1309_off, 0
    lt rx1309_pos, 2, rx1309_start
    sub rx1309_off, rx1309_pos, 1
    substr rx1309_tgt, rx1309_tgt, rx1309_off
  rx1309_start:
    eq $I10, 1, rx1309_restart
    if_null rx1309_debug, debug_957
    rx1309_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_957:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1313_done
    goto rxscan1313_scan
  rxscan1313_loop:
    (rx1309_pos) = rx1309_cur."from"()
    inc rx1309_pos
    rx1309_cur."!cursor_from"(rx1309_pos)
    ge rx1309_pos, rx1309_eos, rxscan1313_done
  rxscan1313_scan:
    set_addr $I10, rxscan1313_loop
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  rxscan1313_done:
.annotate 'line', 597
  # rx subcapture "sym"
    set_addr $I10, rxcap_1314_fail
    rx1309_cur."!mark_push"(0, rx1309_pos, $I10)
  # rx literal  "~"
    add $I11, rx1309_pos, 1
    gt $I11, rx1309_eos, rx1309_fail
    sub $I11, rx1309_pos, rx1309_off
    ord $I11, rx1309_tgt, $I11
    ne $I11, 126, rx1309_fail
    add rx1309_pos, 1
    set_addr $I10, rxcap_1314_fail
    ($I12, $I11) = rx1309_cur."!mark_peek"($I10)
    rx1309_cur."!cursor_pos"($I11)
    ($P10) = rx1309_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1309_pos, "")
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1314_done
  rxcap_1314_fail:
    goto rx1309_fail
  rxcap_1314_done:
  # rx subrule "O" subtype=capture negate=
    rx1309_cur."!cursor_pos"(rx1309_pos)
    $P10 = rx1309_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1309_fail
    rx1309_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1309_pos = $P10."pos"()
  # rx pass
    rx1309_cur."!cursor_pass"(rx1309_pos, "prefix:sym<~>")
    if_null rx1309_debug, debug_958
    rx1309_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1309_pos)
  debug_958:
    .return (rx1309_cur)
  rx1309_restart:
.annotate 'line', 4
    if_null rx1309_debug, debug_959
    rx1309_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_959:
  rx1309_fail:
    (rx1309_rep, rx1309_pos, $I10, $P10) = rx1309_cur."!mark_fail"(0)
    lt rx1309_pos, -1, rx1309_done
    eq rx1309_pos, -1, rx1309_fail
    jump $I10
  rx1309_done:
    rx1309_cur."!cursor_fail"()
    if_null rx1309_debug, debug_960
    rx1309_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_960:
    .return (rx1309_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("295_1299450589.65") :method
.annotate 'line', 4
    $P1311 = self."!PREFIX__!subrule"("O", "~")
    new $P1312, "ResizablePMCArray"
    push $P1312, $P1311
    .return ($P1312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("296_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1316_tgt
    .local int rx1316_pos
    .local int rx1316_off
    .local int rx1316_eos
    .local int rx1316_rep
    .local pmc rx1316_cur
    .local pmc rx1316_debug
    (rx1316_cur, rx1316_pos, rx1316_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1316_cur
    .local pmc match
    .lex "$/", match
    length rx1316_eos, rx1316_tgt
    gt rx1316_pos, rx1316_eos, rx1316_done
    set rx1316_off, 0
    lt rx1316_pos, 2, rx1316_start
    sub rx1316_off, rx1316_pos, 1
    substr rx1316_tgt, rx1316_tgt, rx1316_off
  rx1316_start:
    eq $I10, 1, rx1316_restart
    if_null rx1316_debug, debug_961
    rx1316_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_961:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1319_done
    goto rxscan1319_scan
  rxscan1319_loop:
    (rx1316_pos) = rx1316_cur."from"()
    inc rx1316_pos
    rx1316_cur."!cursor_from"(rx1316_pos)
    ge rx1316_pos, rx1316_eos, rxscan1319_done
  rxscan1319_scan:
    set_addr $I10, rxscan1319_loop
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  rxscan1319_done:
.annotate 'line', 598
  # rx subcapture "sym"
    set_addr $I10, rxcap_1320_fail
    rx1316_cur."!mark_push"(0, rx1316_pos, $I10)
  # rx literal  "-"
    add $I11, rx1316_pos, 1
    gt $I11, rx1316_eos, rx1316_fail
    sub $I11, rx1316_pos, rx1316_off
    ord $I11, rx1316_tgt, $I11
    ne $I11, 45, rx1316_fail
    add rx1316_pos, 1
    set_addr $I10, rxcap_1320_fail
    ($I12, $I11) = rx1316_cur."!mark_peek"($I10)
    rx1316_cur."!cursor_pos"($I11)
    ($P10) = rx1316_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1316_pos, "")
    rx1316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1320_done
  rxcap_1320_fail:
    goto rx1316_fail
  rxcap_1320_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1316_pos, rx1316_off
    substr $S10, rx1316_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1316_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."number"()
    if $P10, rx1316_fail
  # rx subrule "O" subtype=capture negate=
    rx1316_cur."!cursor_pos"(rx1316_pos)
    $P10 = rx1316_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1316_fail
    rx1316_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1316_pos = $P10."pos"()
  # rx pass
    rx1316_cur."!cursor_pass"(rx1316_pos, "prefix:sym<->")
    if_null rx1316_debug, debug_962
    rx1316_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1316_pos)
  debug_962:
    .return (rx1316_cur)
  rx1316_restart:
.annotate 'line', 4
    if_null rx1316_debug, debug_963
    rx1316_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_963:
  rx1316_fail:
    (rx1316_rep, rx1316_pos, $I10, $P10) = rx1316_cur."!mark_fail"(0)
    lt rx1316_pos, -1, rx1316_done
    eq rx1316_pos, -1, rx1316_fail
    jump $I10
  rx1316_done:
    rx1316_cur."!cursor_fail"()
    if_null rx1316_debug, debug_964
    rx1316_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_964:
    .return (rx1316_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("297_1299450589.65") :method
.annotate 'line', 4
    new $P1318, "ResizablePMCArray"
    push $P1318, "-"
    .return ($P1318)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("298_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1322_tgt
    .local int rx1322_pos
    .local int rx1322_off
    .local int rx1322_eos
    .local int rx1322_rep
    .local pmc rx1322_cur
    .local pmc rx1322_debug
    (rx1322_cur, rx1322_pos, rx1322_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1322_cur
    .local pmc match
    .lex "$/", match
    length rx1322_eos, rx1322_tgt
    gt rx1322_pos, rx1322_eos, rx1322_done
    set rx1322_off, 0
    lt rx1322_pos, 2, rx1322_start
    sub rx1322_off, rx1322_pos, 1
    substr rx1322_tgt, rx1322_tgt, rx1322_off
  rx1322_start:
    eq $I10, 1, rx1322_restart
    if_null rx1322_debug, debug_965
    rx1322_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_965:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1322_pos) = rx1322_cur."from"()
    inc rx1322_pos
    rx1322_cur."!cursor_from"(rx1322_pos)
    ge rx1322_pos, rx1322_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  rxscan1326_done:
.annotate 'line', 599
  # rx subcapture "sym"
    set_addr $I10, rxcap_1327_fail
    rx1322_cur."!mark_push"(0, rx1322_pos, $I10)
  # rx literal  "?"
    add $I11, rx1322_pos, 1
    gt $I11, rx1322_eos, rx1322_fail
    sub $I11, rx1322_pos, rx1322_off
    ord $I11, rx1322_tgt, $I11
    ne $I11, 63, rx1322_fail
    add rx1322_pos, 1
    set_addr $I10, rxcap_1327_fail
    ($I12, $I11) = rx1322_cur."!mark_peek"($I10)
    rx1322_cur."!cursor_pos"($I11)
    ($P10) = rx1322_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1322_pos, "")
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1327_done
  rxcap_1327_fail:
    goto rx1322_fail
  rxcap_1327_done:
  # rx subrule "O" subtype=capture negate=
    rx1322_cur."!cursor_pos"(rx1322_pos)
    $P10 = rx1322_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1322_fail
    rx1322_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1322_pos = $P10."pos"()
  # rx pass
    rx1322_cur."!cursor_pass"(rx1322_pos, "prefix:sym<?>")
    if_null rx1322_debug, debug_966
    rx1322_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1322_pos)
  debug_966:
    .return (rx1322_cur)
  rx1322_restart:
.annotate 'line', 4
    if_null rx1322_debug, debug_967
    rx1322_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_967:
  rx1322_fail:
    (rx1322_rep, rx1322_pos, $I10, $P10) = rx1322_cur."!mark_fail"(0)
    lt rx1322_pos, -1, rx1322_done
    eq rx1322_pos, -1, rx1322_fail
    jump $I10
  rx1322_done:
    rx1322_cur."!cursor_fail"()
    if_null rx1322_debug, debug_968
    rx1322_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_968:
    .return (rx1322_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("299_1299450589.65") :method
.annotate 'line', 4
    $P1324 = self."!PREFIX__!subrule"("O", "?")
    new $P1325, "ResizablePMCArray"
    push $P1325, $P1324
    .return ($P1325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("300_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1329_tgt
    .local int rx1329_pos
    .local int rx1329_off
    .local int rx1329_eos
    .local int rx1329_rep
    .local pmc rx1329_cur
    .local pmc rx1329_debug
    (rx1329_cur, rx1329_pos, rx1329_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1329_cur
    .local pmc match
    .lex "$/", match
    length rx1329_eos, rx1329_tgt
    gt rx1329_pos, rx1329_eos, rx1329_done
    set rx1329_off, 0
    lt rx1329_pos, 2, rx1329_start
    sub rx1329_off, rx1329_pos, 1
    substr rx1329_tgt, rx1329_tgt, rx1329_off
  rx1329_start:
    eq $I10, 1, rx1329_restart
    if_null rx1329_debug, debug_969
    rx1329_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_969:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1333_done
    goto rxscan1333_scan
  rxscan1333_loop:
    (rx1329_pos) = rx1329_cur."from"()
    inc rx1329_pos
    rx1329_cur."!cursor_from"(rx1329_pos)
    ge rx1329_pos, rx1329_eos, rxscan1333_done
  rxscan1333_scan:
    set_addr $I10, rxscan1333_loop
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  rxscan1333_done:
.annotate 'line', 600
  # rx subcapture "sym"
    set_addr $I10, rxcap_1334_fail
    rx1329_cur."!mark_push"(0, rx1329_pos, $I10)
  # rx literal  "!"
    add $I11, rx1329_pos, 1
    gt $I11, rx1329_eos, rx1329_fail
    sub $I11, rx1329_pos, rx1329_off
    ord $I11, rx1329_tgt, $I11
    ne $I11, 33, rx1329_fail
    add rx1329_pos, 1
    set_addr $I10, rxcap_1334_fail
    ($I12, $I11) = rx1329_cur."!mark_peek"($I10)
    rx1329_cur."!cursor_pos"($I11)
    ($P10) = rx1329_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1329_pos, "")
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1334_done
  rxcap_1334_fail:
    goto rx1329_fail
  rxcap_1334_done:
  # rx subrule "O" subtype=capture negate=
    rx1329_cur."!cursor_pos"(rx1329_pos)
    $P10 = rx1329_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1329_fail
    rx1329_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1329_pos = $P10."pos"()
  # rx pass
    rx1329_cur."!cursor_pass"(rx1329_pos, "prefix:sym<!>")
    if_null rx1329_debug, debug_970
    rx1329_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1329_pos)
  debug_970:
    .return (rx1329_cur)
  rx1329_restart:
.annotate 'line', 4
    if_null rx1329_debug, debug_971
    rx1329_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_971:
  rx1329_fail:
    (rx1329_rep, rx1329_pos, $I10, $P10) = rx1329_cur."!mark_fail"(0)
    lt rx1329_pos, -1, rx1329_done
    eq rx1329_pos, -1, rx1329_fail
    jump $I10
  rx1329_done:
    rx1329_cur."!cursor_fail"()
    if_null rx1329_debug, debug_972
    rx1329_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_972:
    .return (rx1329_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("301_1299450589.65") :method
.annotate 'line', 4
    $P1331 = self."!PREFIX__!subrule"("O", "!")
    new $P1332, "ResizablePMCArray"
    push $P1332, $P1331
    .return ($P1332)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("302_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1336_tgt
    .local int rx1336_pos
    .local int rx1336_off
    .local int rx1336_eos
    .local int rx1336_rep
    .local pmc rx1336_cur
    .local pmc rx1336_debug
    (rx1336_cur, rx1336_pos, rx1336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1336_cur
    .local pmc match
    .lex "$/", match
    length rx1336_eos, rx1336_tgt
    gt rx1336_pos, rx1336_eos, rx1336_done
    set rx1336_off, 0
    lt rx1336_pos, 2, rx1336_start
    sub rx1336_off, rx1336_pos, 1
    substr rx1336_tgt, rx1336_tgt, rx1336_off
  rx1336_start:
    eq $I10, 1, rx1336_restart
    if_null rx1336_debug, debug_973
    rx1336_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_973:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1340_done
    goto rxscan1340_scan
  rxscan1340_loop:
    (rx1336_pos) = rx1336_cur."from"()
    inc rx1336_pos
    rx1336_cur."!cursor_from"(rx1336_pos)
    ge rx1336_pos, rx1336_eos, rxscan1340_done
  rxscan1340_scan:
    set_addr $I10, rxscan1340_loop
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  rxscan1340_done:
.annotate 'line', 601
  # rx subcapture "sym"
    set_addr $I10, rxcap_1341_fail
    rx1336_cur."!mark_push"(0, rx1336_pos, $I10)
  # rx literal  "|"
    add $I11, rx1336_pos, 1
    gt $I11, rx1336_eos, rx1336_fail
    sub $I11, rx1336_pos, rx1336_off
    ord $I11, rx1336_tgt, $I11
    ne $I11, 124, rx1336_fail
    add rx1336_pos, 1
    set_addr $I10, rxcap_1341_fail
    ($I12, $I11) = rx1336_cur."!mark_peek"($I10)
    rx1336_cur."!cursor_pos"($I11)
    ($P10) = rx1336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1336_pos, "")
    rx1336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1341_done
  rxcap_1341_fail:
    goto rx1336_fail
  rxcap_1341_done:
  # rx subrule "O" subtype=capture negate=
    rx1336_cur."!cursor_pos"(rx1336_pos)
    $P10 = rx1336_cur."O"("%symbolic_unary")
    unless $P10, rx1336_fail
    rx1336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1336_pos = $P10."pos"()
  # rx pass
    rx1336_cur."!cursor_pass"(rx1336_pos, "prefix:sym<|>")
    if_null rx1336_debug, debug_974
    rx1336_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1336_pos)
  debug_974:
    .return (rx1336_cur)
  rx1336_restart:
.annotate 'line', 4
    if_null rx1336_debug, debug_975
    rx1336_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_975:
  rx1336_fail:
    (rx1336_rep, rx1336_pos, $I10, $P10) = rx1336_cur."!mark_fail"(0)
    lt rx1336_pos, -1, rx1336_done
    eq rx1336_pos, -1, rx1336_fail
    jump $I10
  rx1336_done:
    rx1336_cur."!cursor_fail"()
    if_null rx1336_debug, debug_976
    rx1336_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_976:
    .return (rx1336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("303_1299450589.65") :method
.annotate 'line', 4
    $P1338 = self."!PREFIX__!subrule"("O", "|")
    new $P1339, "ResizablePMCArray"
    push $P1339, $P1338
    .return ($P1339)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("304_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1343_tgt
    .local int rx1343_pos
    .local int rx1343_off
    .local int rx1343_eos
    .local int rx1343_rep
    .local pmc rx1343_cur
    .local pmc rx1343_debug
    (rx1343_cur, rx1343_pos, rx1343_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1343_cur
    .local pmc match
    .lex "$/", match
    length rx1343_eos, rx1343_tgt
    gt rx1343_pos, rx1343_eos, rx1343_done
    set rx1343_off, 0
    lt rx1343_pos, 2, rx1343_start
    sub rx1343_off, rx1343_pos, 1
    substr rx1343_tgt, rx1343_tgt, rx1343_off
  rx1343_start:
    eq $I10, 1, rx1343_restart
    if_null rx1343_debug, debug_977
    rx1343_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_977:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1347_done
    goto rxscan1347_scan
  rxscan1347_loop:
    (rx1343_pos) = rx1343_cur."from"()
    inc rx1343_pos
    rx1343_cur."!cursor_from"(rx1343_pos)
    ge rx1343_pos, rx1343_eos, rxscan1347_done
  rxscan1347_scan:
    set_addr $I10, rxscan1347_loop
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  rxscan1347_done:
.annotate 'line', 603
  # rx subcapture "sym"
    set_addr $I10, rxcap_1348_fail
    rx1343_cur."!mark_push"(0, rx1343_pos, $I10)
  # rx literal  "*"
    add $I11, rx1343_pos, 1
    gt $I11, rx1343_eos, rx1343_fail
    sub $I11, rx1343_pos, rx1343_off
    ord $I11, rx1343_tgt, $I11
    ne $I11, 42, rx1343_fail
    add rx1343_pos, 1
    set_addr $I10, rxcap_1348_fail
    ($I12, $I11) = rx1343_cur."!mark_peek"($I10)
    rx1343_cur."!cursor_pos"($I11)
    ($P10) = rx1343_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1343_pos, "")
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1348_done
  rxcap_1348_fail:
    goto rx1343_fail
  rxcap_1348_done:
  # rx subrule "O" subtype=capture negate=
    rx1343_cur."!cursor_pos"(rx1343_pos)
    $P10 = rx1343_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1343_fail
    rx1343_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1343_pos = $P10."pos"()
  # rx pass
    rx1343_cur."!cursor_pass"(rx1343_pos, "infix:sym<*>")
    if_null rx1343_debug, debug_978
    rx1343_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1343_pos)
  debug_978:
    .return (rx1343_cur)
  rx1343_restart:
.annotate 'line', 4
    if_null rx1343_debug, debug_979
    rx1343_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_979:
  rx1343_fail:
    (rx1343_rep, rx1343_pos, $I10, $P10) = rx1343_cur."!mark_fail"(0)
    lt rx1343_pos, -1, rx1343_done
    eq rx1343_pos, -1, rx1343_fail
    jump $I10
  rx1343_done:
    rx1343_cur."!cursor_fail"()
    if_null rx1343_debug, debug_980
    rx1343_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_980:
    .return (rx1343_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("305_1299450589.65") :method
.annotate 'line', 4
    $P1345 = self."!PREFIX__!subrule"("O", "*")
    new $P1346, "ResizablePMCArray"
    push $P1346, $P1345
    .return ($P1346)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("306_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1350_tgt
    .local int rx1350_pos
    .local int rx1350_off
    .local int rx1350_eos
    .local int rx1350_rep
    .local pmc rx1350_cur
    .local pmc rx1350_debug
    (rx1350_cur, rx1350_pos, rx1350_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1350_cur
    .local pmc match
    .lex "$/", match
    length rx1350_eos, rx1350_tgt
    gt rx1350_pos, rx1350_eos, rx1350_done
    set rx1350_off, 0
    lt rx1350_pos, 2, rx1350_start
    sub rx1350_off, rx1350_pos, 1
    substr rx1350_tgt, rx1350_tgt, rx1350_off
  rx1350_start:
    eq $I10, 1, rx1350_restart
    if_null rx1350_debug, debug_981
    rx1350_cur."!cursor_debug"("START", "infix:sym</>")
  debug_981:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1354_done
    goto rxscan1354_scan
  rxscan1354_loop:
    (rx1350_pos) = rx1350_cur."from"()
    inc rx1350_pos
    rx1350_cur."!cursor_from"(rx1350_pos)
    ge rx1350_pos, rx1350_eos, rxscan1354_done
  rxscan1354_scan:
    set_addr $I10, rxscan1354_loop
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  rxscan1354_done:
.annotate 'line', 604
  # rx subcapture "sym"
    set_addr $I10, rxcap_1355_fail
    rx1350_cur."!mark_push"(0, rx1350_pos, $I10)
  # rx literal  "/"
    add $I11, rx1350_pos, 1
    gt $I11, rx1350_eos, rx1350_fail
    sub $I11, rx1350_pos, rx1350_off
    ord $I11, rx1350_tgt, $I11
    ne $I11, 47, rx1350_fail
    add rx1350_pos, 1
    set_addr $I10, rxcap_1355_fail
    ($I12, $I11) = rx1350_cur."!mark_peek"($I10)
    rx1350_cur."!cursor_pos"($I11)
    ($P10) = rx1350_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1350_pos, "")
    rx1350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1355_done
  rxcap_1355_fail:
    goto rx1350_fail
  rxcap_1355_done:
  # rx subrule "O" subtype=capture negate=
    rx1350_cur."!cursor_pos"(rx1350_pos)
    $P10 = rx1350_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1350_fail
    rx1350_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1350_pos = $P10."pos"()
  # rx pass
    rx1350_cur."!cursor_pass"(rx1350_pos, "infix:sym</>")
    if_null rx1350_debug, debug_982
    rx1350_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1350_pos)
  debug_982:
    .return (rx1350_cur)
  rx1350_restart:
.annotate 'line', 4
    if_null rx1350_debug, debug_983
    rx1350_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_983:
  rx1350_fail:
    (rx1350_rep, rx1350_pos, $I10, $P10) = rx1350_cur."!mark_fail"(0)
    lt rx1350_pos, -1, rx1350_done
    eq rx1350_pos, -1, rx1350_fail
    jump $I10
  rx1350_done:
    rx1350_cur."!cursor_fail"()
    if_null rx1350_debug, debug_984
    rx1350_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_984:
    .return (rx1350_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("307_1299450589.65") :method
.annotate 'line', 4
    $P1352 = self."!PREFIX__!subrule"("O", "/")
    new $P1353, "ResizablePMCArray"
    push $P1353, $P1352
    .return ($P1353)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("308_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1357_tgt
    .local int rx1357_pos
    .local int rx1357_off
    .local int rx1357_eos
    .local int rx1357_rep
    .local pmc rx1357_cur
    .local pmc rx1357_debug
    (rx1357_cur, rx1357_pos, rx1357_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1357_cur
    .local pmc match
    .lex "$/", match
    length rx1357_eos, rx1357_tgt
    gt rx1357_pos, rx1357_eos, rx1357_done
    set rx1357_off, 0
    lt rx1357_pos, 2, rx1357_start
    sub rx1357_off, rx1357_pos, 1
    substr rx1357_tgt, rx1357_tgt, rx1357_off
  rx1357_start:
    eq $I10, 1, rx1357_restart
    if_null rx1357_debug, debug_985
    rx1357_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_985:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1361_done
    goto rxscan1361_scan
  rxscan1361_loop:
    (rx1357_pos) = rx1357_cur."from"()
    inc rx1357_pos
    rx1357_cur."!cursor_from"(rx1357_pos)
    ge rx1357_pos, rx1357_eos, rxscan1361_done
  rxscan1361_scan:
    set_addr $I10, rxscan1361_loop
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  rxscan1361_done:
.annotate 'line', 605
  # rx subcapture "sym"
    set_addr $I10, rxcap_1362_fail
    rx1357_cur."!mark_push"(0, rx1357_pos, $I10)
  # rx literal  "%"
    add $I11, rx1357_pos, 1
    gt $I11, rx1357_eos, rx1357_fail
    sub $I11, rx1357_pos, rx1357_off
    ord $I11, rx1357_tgt, $I11
    ne $I11, 37, rx1357_fail
    add rx1357_pos, 1
    set_addr $I10, rxcap_1362_fail
    ($I12, $I11) = rx1357_cur."!mark_peek"($I10)
    rx1357_cur."!cursor_pos"($I11)
    ($P10) = rx1357_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1357_pos, "")
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1362_done
  rxcap_1362_fail:
    goto rx1357_fail
  rxcap_1362_done:
  # rx subrule "O" subtype=capture negate=
    rx1357_cur."!cursor_pos"(rx1357_pos)
    $P10 = rx1357_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1357_fail
    rx1357_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1357_pos = $P10."pos"()
  # rx pass
    rx1357_cur."!cursor_pass"(rx1357_pos, "infix:sym<%>")
    if_null rx1357_debug, debug_986
    rx1357_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1357_pos)
  debug_986:
    .return (rx1357_cur)
  rx1357_restart:
.annotate 'line', 4
    if_null rx1357_debug, debug_987
    rx1357_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_987:
  rx1357_fail:
    (rx1357_rep, rx1357_pos, $I10, $P10) = rx1357_cur."!mark_fail"(0)
    lt rx1357_pos, -1, rx1357_done
    eq rx1357_pos, -1, rx1357_fail
    jump $I10
  rx1357_done:
    rx1357_cur."!cursor_fail"()
    if_null rx1357_debug, debug_988
    rx1357_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_988:
    .return (rx1357_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("309_1299450589.65") :method
.annotate 'line', 4
    $P1359 = self."!PREFIX__!subrule"("O", "%")
    new $P1360, "ResizablePMCArray"
    push $P1360, $P1359
    .return ($P1360)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("310_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1364_tgt
    .local int rx1364_pos
    .local int rx1364_off
    .local int rx1364_eos
    .local int rx1364_rep
    .local pmc rx1364_cur
    .local pmc rx1364_debug
    (rx1364_cur, rx1364_pos, rx1364_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1364_cur
    .local pmc match
    .lex "$/", match
    length rx1364_eos, rx1364_tgt
    gt rx1364_pos, rx1364_eos, rx1364_done
    set rx1364_off, 0
    lt rx1364_pos, 2, rx1364_start
    sub rx1364_off, rx1364_pos, 1
    substr rx1364_tgt, rx1364_tgt, rx1364_off
  rx1364_start:
    eq $I10, 1, rx1364_restart
    if_null rx1364_debug, debug_989
    rx1364_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_989:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1368_done
    goto rxscan1368_scan
  rxscan1368_loop:
    (rx1364_pos) = rx1364_cur."from"()
    inc rx1364_pos
    rx1364_cur."!cursor_from"(rx1364_pos)
    ge rx1364_pos, rx1364_eos, rxscan1368_done
  rxscan1368_scan:
    set_addr $I10, rxscan1368_loop
    rx1364_cur."!mark_push"(0, rx1364_pos, $I10)
  rxscan1368_done:
.annotate 'line', 606
  # rx subcapture "sym"
    set_addr $I10, rxcap_1369_fail
    rx1364_cur."!mark_push"(0, rx1364_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1364_pos, 2
    gt $I11, rx1364_eos, rx1364_fail
    sub $I11, rx1364_pos, rx1364_off
    substr $S10, rx1364_tgt, $I11, 2
    ne $S10, "+&", rx1364_fail
    add rx1364_pos, 2
    set_addr $I10, rxcap_1369_fail
    ($I12, $I11) = rx1364_cur."!mark_peek"($I10)
    rx1364_cur."!cursor_pos"($I11)
    ($P10) = rx1364_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1364_pos, "")
    rx1364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1369_done
  rxcap_1369_fail:
    goto rx1364_fail
  rxcap_1369_done:
  # rx subrule "O" subtype=capture negate=
    rx1364_cur."!cursor_pos"(rx1364_pos)
    $P10 = rx1364_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1364_fail
    rx1364_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1364_pos = $P10."pos"()
  # rx pass
    rx1364_cur."!cursor_pass"(rx1364_pos, "infix:sym<+&>")
    if_null rx1364_debug, debug_990
    rx1364_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1364_pos)
  debug_990:
    .return (rx1364_cur)
  rx1364_restart:
.annotate 'line', 4
    if_null rx1364_debug, debug_991
    rx1364_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_991:
  rx1364_fail:
    (rx1364_rep, rx1364_pos, $I10, $P10) = rx1364_cur."!mark_fail"(0)
    lt rx1364_pos, -1, rx1364_done
    eq rx1364_pos, -1, rx1364_fail
    jump $I10
  rx1364_done:
    rx1364_cur."!cursor_fail"()
    if_null rx1364_debug, debug_992
    rx1364_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_992:
    .return (rx1364_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("311_1299450589.65") :method
.annotate 'line', 4
    $P1366 = self."!PREFIX__!subrule"("O", "+&")
    new $P1367, "ResizablePMCArray"
    push $P1367, $P1366
    .return ($P1367)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("312_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1371_tgt
    .local int rx1371_pos
    .local int rx1371_off
    .local int rx1371_eos
    .local int rx1371_rep
    .local pmc rx1371_cur
    .local pmc rx1371_debug
    (rx1371_cur, rx1371_pos, rx1371_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1371_cur
    .local pmc match
    .lex "$/", match
    length rx1371_eos, rx1371_tgt
    gt rx1371_pos, rx1371_eos, rx1371_done
    set rx1371_off, 0
    lt rx1371_pos, 2, rx1371_start
    sub rx1371_off, rx1371_pos, 1
    substr rx1371_tgt, rx1371_tgt, rx1371_off
  rx1371_start:
    eq $I10, 1, rx1371_restart
    if_null rx1371_debug, debug_993
    rx1371_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_993:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1375_done
    goto rxscan1375_scan
  rxscan1375_loop:
    (rx1371_pos) = rx1371_cur."from"()
    inc rx1371_pos
    rx1371_cur."!cursor_from"(rx1371_pos)
    ge rx1371_pos, rx1371_eos, rxscan1375_done
  rxscan1375_scan:
    set_addr $I10, rxscan1375_loop
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  rxscan1375_done:
.annotate 'line', 608
  # rx subcapture "sym"
    set_addr $I10, rxcap_1376_fail
    rx1371_cur."!mark_push"(0, rx1371_pos, $I10)
  # rx literal  "+"
    add $I11, rx1371_pos, 1
    gt $I11, rx1371_eos, rx1371_fail
    sub $I11, rx1371_pos, rx1371_off
    ord $I11, rx1371_tgt, $I11
    ne $I11, 43, rx1371_fail
    add rx1371_pos, 1
    set_addr $I10, rxcap_1376_fail
    ($I12, $I11) = rx1371_cur."!mark_peek"($I10)
    rx1371_cur."!cursor_pos"($I11)
    ($P10) = rx1371_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1371_pos, "")
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1376_done
  rxcap_1376_fail:
    goto rx1371_fail
  rxcap_1376_done:
  # rx subrule "O" subtype=capture negate=
    rx1371_cur."!cursor_pos"(rx1371_pos)
    $P10 = rx1371_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1371_fail
    rx1371_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1371_pos = $P10."pos"()
  # rx pass
    rx1371_cur."!cursor_pass"(rx1371_pos, "infix:sym<+>")
    if_null rx1371_debug, debug_994
    rx1371_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1371_pos)
  debug_994:
    .return (rx1371_cur)
  rx1371_restart:
.annotate 'line', 4
    if_null rx1371_debug, debug_995
    rx1371_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_995:
  rx1371_fail:
    (rx1371_rep, rx1371_pos, $I10, $P10) = rx1371_cur."!mark_fail"(0)
    lt rx1371_pos, -1, rx1371_done
    eq rx1371_pos, -1, rx1371_fail
    jump $I10
  rx1371_done:
    rx1371_cur."!cursor_fail"()
    if_null rx1371_debug, debug_996
    rx1371_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_996:
    .return (rx1371_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("313_1299450589.65") :method
.annotate 'line', 4
    $P1373 = self."!PREFIX__!subrule"("O", "+")
    new $P1374, "ResizablePMCArray"
    push $P1374, $P1373
    .return ($P1374)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("314_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1378_tgt
    .local int rx1378_pos
    .local int rx1378_off
    .local int rx1378_eos
    .local int rx1378_rep
    .local pmc rx1378_cur
    .local pmc rx1378_debug
    (rx1378_cur, rx1378_pos, rx1378_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1378_cur
    .local pmc match
    .lex "$/", match
    length rx1378_eos, rx1378_tgt
    gt rx1378_pos, rx1378_eos, rx1378_done
    set rx1378_off, 0
    lt rx1378_pos, 2, rx1378_start
    sub rx1378_off, rx1378_pos, 1
    substr rx1378_tgt, rx1378_tgt, rx1378_off
  rx1378_start:
    eq $I10, 1, rx1378_restart
    if_null rx1378_debug, debug_997
    rx1378_cur."!cursor_debug"("START", "infix:sym<->")
  debug_997:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1382_done
    goto rxscan1382_scan
  rxscan1382_loop:
    (rx1378_pos) = rx1378_cur."from"()
    inc rx1378_pos
    rx1378_cur."!cursor_from"(rx1378_pos)
    ge rx1378_pos, rx1378_eos, rxscan1382_done
  rxscan1382_scan:
    set_addr $I10, rxscan1382_loop
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
  rxscan1382_done:
.annotate 'line', 609
  # rx subcapture "sym"
    set_addr $I10, rxcap_1383_fail
    rx1378_cur."!mark_push"(0, rx1378_pos, $I10)
  # rx literal  "-"
    add $I11, rx1378_pos, 1
    gt $I11, rx1378_eos, rx1378_fail
    sub $I11, rx1378_pos, rx1378_off
    ord $I11, rx1378_tgt, $I11
    ne $I11, 45, rx1378_fail
    add rx1378_pos, 1
    set_addr $I10, rxcap_1383_fail
    ($I12, $I11) = rx1378_cur."!mark_peek"($I10)
    rx1378_cur."!cursor_pos"($I11)
    ($P10) = rx1378_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1378_pos, "")
    rx1378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1383_done
  rxcap_1383_fail:
    goto rx1378_fail
  rxcap_1383_done:
  # rx subrule "O" subtype=capture negate=
    rx1378_cur."!cursor_pos"(rx1378_pos)
    $P10 = rx1378_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1378_fail
    rx1378_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1378_pos = $P10."pos"()
  # rx pass
    rx1378_cur."!cursor_pass"(rx1378_pos, "infix:sym<->")
    if_null rx1378_debug, debug_998
    rx1378_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1378_pos)
  debug_998:
    .return (rx1378_cur)
  rx1378_restart:
.annotate 'line', 4
    if_null rx1378_debug, debug_999
    rx1378_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_999:
  rx1378_fail:
    (rx1378_rep, rx1378_pos, $I10, $P10) = rx1378_cur."!mark_fail"(0)
    lt rx1378_pos, -1, rx1378_done
    eq rx1378_pos, -1, rx1378_fail
    jump $I10
  rx1378_done:
    rx1378_cur."!cursor_fail"()
    if_null rx1378_debug, debug_1000
    rx1378_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1000:
    .return (rx1378_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("315_1299450589.65") :method
.annotate 'line', 4
    $P1380 = self."!PREFIX__!subrule"("O", "-")
    new $P1381, "ResizablePMCArray"
    push $P1381, $P1380
    .return ($P1381)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("316_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1385_tgt
    .local int rx1385_pos
    .local int rx1385_off
    .local int rx1385_eos
    .local int rx1385_rep
    .local pmc rx1385_cur
    .local pmc rx1385_debug
    (rx1385_cur, rx1385_pos, rx1385_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1385_cur
    .local pmc match
    .lex "$/", match
    length rx1385_eos, rx1385_tgt
    gt rx1385_pos, rx1385_eos, rx1385_done
    set rx1385_off, 0
    lt rx1385_pos, 2, rx1385_start
    sub rx1385_off, rx1385_pos, 1
    substr rx1385_tgt, rx1385_tgt, rx1385_off
  rx1385_start:
    eq $I10, 1, rx1385_restart
    if_null rx1385_debug, debug_1001
    rx1385_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1001:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1389_done
    goto rxscan1389_scan
  rxscan1389_loop:
    (rx1385_pos) = rx1385_cur."from"()
    inc rx1385_pos
    rx1385_cur."!cursor_from"(rx1385_pos)
    ge rx1385_pos, rx1385_eos, rxscan1389_done
  rxscan1389_scan:
    set_addr $I10, rxscan1389_loop
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  rxscan1389_done:
.annotate 'line', 610
  # rx subcapture "sym"
    set_addr $I10, rxcap_1390_fail
    rx1385_cur."!mark_push"(0, rx1385_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1385_pos, 2
    gt $I11, rx1385_eos, rx1385_fail
    sub $I11, rx1385_pos, rx1385_off
    substr $S10, rx1385_tgt, $I11, 2
    ne $S10, "+|", rx1385_fail
    add rx1385_pos, 2
    set_addr $I10, rxcap_1390_fail
    ($I12, $I11) = rx1385_cur."!mark_peek"($I10)
    rx1385_cur."!cursor_pos"($I11)
    ($P10) = rx1385_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1385_pos, "")
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1390_done
  rxcap_1390_fail:
    goto rx1385_fail
  rxcap_1390_done:
  # rx subrule "O" subtype=capture negate=
    rx1385_cur."!cursor_pos"(rx1385_pos)
    $P10 = rx1385_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1385_fail
    rx1385_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1385_pos = $P10."pos"()
  # rx pass
    rx1385_cur."!cursor_pass"(rx1385_pos, "infix:sym<+|>")
    if_null rx1385_debug, debug_1002
    rx1385_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1385_pos)
  debug_1002:
    .return (rx1385_cur)
  rx1385_restart:
.annotate 'line', 4
    if_null rx1385_debug, debug_1003
    rx1385_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1003:
  rx1385_fail:
    (rx1385_rep, rx1385_pos, $I10, $P10) = rx1385_cur."!mark_fail"(0)
    lt rx1385_pos, -1, rx1385_done
    eq rx1385_pos, -1, rx1385_fail
    jump $I10
  rx1385_done:
    rx1385_cur."!cursor_fail"()
    if_null rx1385_debug, debug_1004
    rx1385_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1004:
    .return (rx1385_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("317_1299450589.65") :method
.annotate 'line', 4
    $P1387 = self."!PREFIX__!subrule"("O", "+|")
    new $P1388, "ResizablePMCArray"
    push $P1388, $P1387
    .return ($P1388)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("318_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1392_tgt
    .local int rx1392_pos
    .local int rx1392_off
    .local int rx1392_eos
    .local int rx1392_rep
    .local pmc rx1392_cur
    .local pmc rx1392_debug
    (rx1392_cur, rx1392_pos, rx1392_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1392_cur
    .local pmc match
    .lex "$/", match
    length rx1392_eos, rx1392_tgt
    gt rx1392_pos, rx1392_eos, rx1392_done
    set rx1392_off, 0
    lt rx1392_pos, 2, rx1392_start
    sub rx1392_off, rx1392_pos, 1
    substr rx1392_tgt, rx1392_tgt, rx1392_off
  rx1392_start:
    eq $I10, 1, rx1392_restart
    if_null rx1392_debug, debug_1005
    rx1392_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1005:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1396_done
    goto rxscan1396_scan
  rxscan1396_loop:
    (rx1392_pos) = rx1392_cur."from"()
    inc rx1392_pos
    rx1392_cur."!cursor_from"(rx1392_pos)
    ge rx1392_pos, rx1392_eos, rxscan1396_done
  rxscan1396_scan:
    set_addr $I10, rxscan1396_loop
    rx1392_cur."!mark_push"(0, rx1392_pos, $I10)
  rxscan1396_done:
.annotate 'line', 611
  # rx subcapture "sym"
    set_addr $I10, rxcap_1397_fail
    rx1392_cur."!mark_push"(0, rx1392_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1392_pos, 2
    gt $I11, rx1392_eos, rx1392_fail
    sub $I11, rx1392_pos, rx1392_off
    substr $S10, rx1392_tgt, $I11, 2
    ne $S10, "+^", rx1392_fail
    add rx1392_pos, 2
    set_addr $I10, rxcap_1397_fail
    ($I12, $I11) = rx1392_cur."!mark_peek"($I10)
    rx1392_cur."!cursor_pos"($I11)
    ($P10) = rx1392_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1392_pos, "")
    rx1392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1397_done
  rxcap_1397_fail:
    goto rx1392_fail
  rxcap_1397_done:
  # rx subrule "O" subtype=capture negate=
    rx1392_cur."!cursor_pos"(rx1392_pos)
    $P10 = rx1392_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1392_fail
    rx1392_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1392_pos = $P10."pos"()
  # rx pass
    rx1392_cur."!cursor_pass"(rx1392_pos, "infix:sym<+^>")
    if_null rx1392_debug, debug_1006
    rx1392_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1392_pos)
  debug_1006:
    .return (rx1392_cur)
  rx1392_restart:
.annotate 'line', 4
    if_null rx1392_debug, debug_1007
    rx1392_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1007:
  rx1392_fail:
    (rx1392_rep, rx1392_pos, $I10, $P10) = rx1392_cur."!mark_fail"(0)
    lt rx1392_pos, -1, rx1392_done
    eq rx1392_pos, -1, rx1392_fail
    jump $I10
  rx1392_done:
    rx1392_cur."!cursor_fail"()
    if_null rx1392_debug, debug_1008
    rx1392_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1008:
    .return (rx1392_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("319_1299450589.65") :method
.annotate 'line', 4
    $P1394 = self."!PREFIX__!subrule"("O", "+^")
    new $P1395, "ResizablePMCArray"
    push $P1395, $P1394
    .return ($P1395)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("320_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1399_tgt
    .local int rx1399_pos
    .local int rx1399_off
    .local int rx1399_eos
    .local int rx1399_rep
    .local pmc rx1399_cur
    .local pmc rx1399_debug
    (rx1399_cur, rx1399_pos, rx1399_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1399_cur
    .local pmc match
    .lex "$/", match
    length rx1399_eos, rx1399_tgt
    gt rx1399_pos, rx1399_eos, rx1399_done
    set rx1399_off, 0
    lt rx1399_pos, 2, rx1399_start
    sub rx1399_off, rx1399_pos, 1
    substr rx1399_tgt, rx1399_tgt, rx1399_off
  rx1399_start:
    eq $I10, 1, rx1399_restart
    if_null rx1399_debug, debug_1009
    rx1399_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1009:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1403_done
    goto rxscan1403_scan
  rxscan1403_loop:
    (rx1399_pos) = rx1399_cur."from"()
    inc rx1399_pos
    rx1399_cur."!cursor_from"(rx1399_pos)
    ge rx1399_pos, rx1399_eos, rxscan1403_done
  rxscan1403_scan:
    set_addr $I10, rxscan1403_loop
    rx1399_cur."!mark_push"(0, rx1399_pos, $I10)
  rxscan1403_done:
.annotate 'line', 613
  # rx subcapture "sym"
    set_addr $I10, rxcap_1404_fail
    rx1399_cur."!mark_push"(0, rx1399_pos, $I10)
  # rx literal  "~"
    add $I11, rx1399_pos, 1
    gt $I11, rx1399_eos, rx1399_fail
    sub $I11, rx1399_pos, rx1399_off
    ord $I11, rx1399_tgt, $I11
    ne $I11, 126, rx1399_fail
    add rx1399_pos, 1
    set_addr $I10, rxcap_1404_fail
    ($I12, $I11) = rx1399_cur."!mark_peek"($I10)
    rx1399_cur."!cursor_pos"($I11)
    ($P10) = rx1399_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1399_pos, "")
    rx1399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1404_done
  rxcap_1404_fail:
    goto rx1399_fail
  rxcap_1404_done:
  # rx subrule "O" subtype=capture negate=
    rx1399_cur."!cursor_pos"(rx1399_pos)
    $P10 = rx1399_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1399_fail
    rx1399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1399_pos = $P10."pos"()
  # rx pass
    rx1399_cur."!cursor_pass"(rx1399_pos, "infix:sym<~>")
    if_null rx1399_debug, debug_1010
    rx1399_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1399_pos)
  debug_1010:
    .return (rx1399_cur)
  rx1399_restart:
.annotate 'line', 4
    if_null rx1399_debug, debug_1011
    rx1399_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1011:
  rx1399_fail:
    (rx1399_rep, rx1399_pos, $I10, $P10) = rx1399_cur."!mark_fail"(0)
    lt rx1399_pos, -1, rx1399_done
    eq rx1399_pos, -1, rx1399_fail
    jump $I10
  rx1399_done:
    rx1399_cur."!cursor_fail"()
    if_null rx1399_debug, debug_1012
    rx1399_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1012:
    .return (rx1399_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("321_1299450589.65") :method
.annotate 'line', 4
    $P1401 = self."!PREFIX__!subrule"("O", "~")
    new $P1402, "ResizablePMCArray"
    push $P1402, $P1401
    .return ($P1402)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("322_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1406_tgt
    .local int rx1406_pos
    .local int rx1406_off
    .local int rx1406_eos
    .local int rx1406_rep
    .local pmc rx1406_cur
    .local pmc rx1406_debug
    (rx1406_cur, rx1406_pos, rx1406_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1406_cur
    .local pmc match
    .lex "$/", match
    length rx1406_eos, rx1406_tgt
    gt rx1406_pos, rx1406_eos, rx1406_done
    set rx1406_off, 0
    lt rx1406_pos, 2, rx1406_start
    sub rx1406_off, rx1406_pos, 1
    substr rx1406_tgt, rx1406_tgt, rx1406_off
  rx1406_start:
    eq $I10, 1, rx1406_restart
    if_null rx1406_debug, debug_1013
    rx1406_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1410_done
    goto rxscan1410_scan
  rxscan1410_loop:
    (rx1406_pos) = rx1406_cur."from"()
    inc rx1406_pos
    rx1406_cur."!cursor_from"(rx1406_pos)
    ge rx1406_pos, rx1406_eos, rxscan1410_done
  rxscan1410_scan:
    set_addr $I10, rxscan1410_loop
    rx1406_cur."!mark_push"(0, rx1406_pos, $I10)
  rxscan1410_done:
.annotate 'line', 615
  # rx subcapture "sym"
    set_addr $I10, rxcap_1411_fail
    rx1406_cur."!mark_push"(0, rx1406_pos, $I10)
  # rx literal  "=="
    add $I11, rx1406_pos, 2
    gt $I11, rx1406_eos, rx1406_fail
    sub $I11, rx1406_pos, rx1406_off
    substr $S10, rx1406_tgt, $I11, 2
    ne $S10, "==", rx1406_fail
    add rx1406_pos, 2
    set_addr $I10, rxcap_1411_fail
    ($I12, $I11) = rx1406_cur."!mark_peek"($I10)
    rx1406_cur."!cursor_pos"($I11)
    ($P10) = rx1406_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1406_pos, "")
    rx1406_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1411_done
  rxcap_1411_fail:
    goto rx1406_fail
  rxcap_1411_done:
  # rx subrule "O" subtype=capture negate=
    rx1406_cur."!cursor_pos"(rx1406_pos)
    $P10 = rx1406_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1406_fail
    rx1406_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1406_pos = $P10."pos"()
  # rx pass
    rx1406_cur."!cursor_pass"(rx1406_pos, "infix:sym<==>")
    if_null rx1406_debug, debug_1014
    rx1406_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1406_pos)
  debug_1014:
    .return (rx1406_cur)
  rx1406_restart:
.annotate 'line', 4
    if_null rx1406_debug, debug_1015
    rx1406_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1015:
  rx1406_fail:
    (rx1406_rep, rx1406_pos, $I10, $P10) = rx1406_cur."!mark_fail"(0)
    lt rx1406_pos, -1, rx1406_done
    eq rx1406_pos, -1, rx1406_fail
    jump $I10
  rx1406_done:
    rx1406_cur."!cursor_fail"()
    if_null rx1406_debug, debug_1016
    rx1406_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1016:
    .return (rx1406_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("323_1299450589.65") :method
.annotate 'line', 4
    $P1408 = self."!PREFIX__!subrule"("O", "==")
    new $P1409, "ResizablePMCArray"
    push $P1409, $P1408
    .return ($P1409)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("324_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1413_tgt
    .local int rx1413_pos
    .local int rx1413_off
    .local int rx1413_eos
    .local int rx1413_rep
    .local pmc rx1413_cur
    .local pmc rx1413_debug
    (rx1413_cur, rx1413_pos, rx1413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1413_cur
    .local pmc match
    .lex "$/", match
    length rx1413_eos, rx1413_tgt
    gt rx1413_pos, rx1413_eos, rx1413_done
    set rx1413_off, 0
    lt rx1413_pos, 2, rx1413_start
    sub rx1413_off, rx1413_pos, 1
    substr rx1413_tgt, rx1413_tgt, rx1413_off
  rx1413_start:
    eq $I10, 1, rx1413_restart
    if_null rx1413_debug, debug_1017
    rx1413_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1417_done
    goto rxscan1417_scan
  rxscan1417_loop:
    (rx1413_pos) = rx1413_cur."from"()
    inc rx1413_pos
    rx1413_cur."!cursor_from"(rx1413_pos)
    ge rx1413_pos, rx1413_eos, rxscan1417_done
  rxscan1417_scan:
    set_addr $I10, rxscan1417_loop
    rx1413_cur."!mark_push"(0, rx1413_pos, $I10)
  rxscan1417_done:
.annotate 'line', 616
  # rx subcapture "sym"
    set_addr $I10, rxcap_1418_fail
    rx1413_cur."!mark_push"(0, rx1413_pos, $I10)
  # rx literal  "!="
    add $I11, rx1413_pos, 2
    gt $I11, rx1413_eos, rx1413_fail
    sub $I11, rx1413_pos, rx1413_off
    substr $S10, rx1413_tgt, $I11, 2
    ne $S10, "!=", rx1413_fail
    add rx1413_pos, 2
    set_addr $I10, rxcap_1418_fail
    ($I12, $I11) = rx1413_cur."!mark_peek"($I10)
    rx1413_cur."!cursor_pos"($I11)
    ($P10) = rx1413_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1413_pos, "")
    rx1413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1418_done
  rxcap_1418_fail:
    goto rx1413_fail
  rxcap_1418_done:
  # rx subrule "O" subtype=capture negate=
    rx1413_cur."!cursor_pos"(rx1413_pos)
    $P10 = rx1413_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1413_fail
    rx1413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1413_pos = $P10."pos"()
  # rx pass
    rx1413_cur."!cursor_pass"(rx1413_pos, "infix:sym<!=>")
    if_null rx1413_debug, debug_1018
    rx1413_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1413_pos)
  debug_1018:
    .return (rx1413_cur)
  rx1413_restart:
.annotate 'line', 4
    if_null rx1413_debug, debug_1019
    rx1413_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1019:
  rx1413_fail:
    (rx1413_rep, rx1413_pos, $I10, $P10) = rx1413_cur."!mark_fail"(0)
    lt rx1413_pos, -1, rx1413_done
    eq rx1413_pos, -1, rx1413_fail
    jump $I10
  rx1413_done:
    rx1413_cur."!cursor_fail"()
    if_null rx1413_debug, debug_1020
    rx1413_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1020:
    .return (rx1413_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("325_1299450589.65") :method
.annotate 'line', 4
    $P1415 = self."!PREFIX__!subrule"("O", "!=")
    new $P1416, "ResizablePMCArray"
    push $P1416, $P1415
    .return ($P1416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("326_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1420_tgt
    .local int rx1420_pos
    .local int rx1420_off
    .local int rx1420_eos
    .local int rx1420_rep
    .local pmc rx1420_cur
    .local pmc rx1420_debug
    (rx1420_cur, rx1420_pos, rx1420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1420_cur
    .local pmc match
    .lex "$/", match
    length rx1420_eos, rx1420_tgt
    gt rx1420_pos, rx1420_eos, rx1420_done
    set rx1420_off, 0
    lt rx1420_pos, 2, rx1420_start
    sub rx1420_off, rx1420_pos, 1
    substr rx1420_tgt, rx1420_tgt, rx1420_off
  rx1420_start:
    eq $I10, 1, rx1420_restart
    if_null rx1420_debug, debug_1021
    rx1420_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1424_done
    goto rxscan1424_scan
  rxscan1424_loop:
    (rx1420_pos) = rx1420_cur."from"()
    inc rx1420_pos
    rx1420_cur."!cursor_from"(rx1420_pos)
    ge rx1420_pos, rx1420_eos, rxscan1424_done
  rxscan1424_scan:
    set_addr $I10, rxscan1424_loop
    rx1420_cur."!mark_push"(0, rx1420_pos, $I10)
  rxscan1424_done:
.annotate 'line', 617
  # rx subcapture "sym"
    set_addr $I10, rxcap_1425_fail
    rx1420_cur."!mark_push"(0, rx1420_pos, $I10)
  # rx literal  "<="
    add $I11, rx1420_pos, 2
    gt $I11, rx1420_eos, rx1420_fail
    sub $I11, rx1420_pos, rx1420_off
    substr $S10, rx1420_tgt, $I11, 2
    ne $S10, "<=", rx1420_fail
    add rx1420_pos, 2
    set_addr $I10, rxcap_1425_fail
    ($I12, $I11) = rx1420_cur."!mark_peek"($I10)
    rx1420_cur."!cursor_pos"($I11)
    ($P10) = rx1420_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1420_pos, "")
    rx1420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1425_done
  rxcap_1425_fail:
    goto rx1420_fail
  rxcap_1425_done:
  # rx subrule "O" subtype=capture negate=
    rx1420_cur."!cursor_pos"(rx1420_pos)
    $P10 = rx1420_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1420_fail
    rx1420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1420_pos = $P10."pos"()
  # rx pass
    rx1420_cur."!cursor_pass"(rx1420_pos, "infix:sym<<=>")
    if_null rx1420_debug, debug_1022
    rx1420_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1420_pos)
  debug_1022:
    .return (rx1420_cur)
  rx1420_restart:
.annotate 'line', 4
    if_null rx1420_debug, debug_1023
    rx1420_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1023:
  rx1420_fail:
    (rx1420_rep, rx1420_pos, $I10, $P10) = rx1420_cur."!mark_fail"(0)
    lt rx1420_pos, -1, rx1420_done
    eq rx1420_pos, -1, rx1420_fail
    jump $I10
  rx1420_done:
    rx1420_cur."!cursor_fail"()
    if_null rx1420_debug, debug_1024
    rx1420_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1024:
    .return (rx1420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("327_1299450589.65") :method
.annotate 'line', 4
    $P1422 = self."!PREFIX__!subrule"("O", "<=")
    new $P1423, "ResizablePMCArray"
    push $P1423, $P1422
    .return ($P1423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("328_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1427_tgt
    .local int rx1427_pos
    .local int rx1427_off
    .local int rx1427_eos
    .local int rx1427_rep
    .local pmc rx1427_cur
    .local pmc rx1427_debug
    (rx1427_cur, rx1427_pos, rx1427_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1427_cur
    .local pmc match
    .lex "$/", match
    length rx1427_eos, rx1427_tgt
    gt rx1427_pos, rx1427_eos, rx1427_done
    set rx1427_off, 0
    lt rx1427_pos, 2, rx1427_start
    sub rx1427_off, rx1427_pos, 1
    substr rx1427_tgt, rx1427_tgt, rx1427_off
  rx1427_start:
    eq $I10, 1, rx1427_restart
    if_null rx1427_debug, debug_1025
    rx1427_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1431_done
    goto rxscan1431_scan
  rxscan1431_loop:
    (rx1427_pos) = rx1427_cur."from"()
    inc rx1427_pos
    rx1427_cur."!cursor_from"(rx1427_pos)
    ge rx1427_pos, rx1427_eos, rxscan1431_done
  rxscan1431_scan:
    set_addr $I10, rxscan1431_loop
    rx1427_cur."!mark_push"(0, rx1427_pos, $I10)
  rxscan1431_done:
.annotate 'line', 618
  # rx subcapture "sym"
    set_addr $I10, rxcap_1432_fail
    rx1427_cur."!mark_push"(0, rx1427_pos, $I10)
  # rx literal  ">="
    add $I11, rx1427_pos, 2
    gt $I11, rx1427_eos, rx1427_fail
    sub $I11, rx1427_pos, rx1427_off
    substr $S10, rx1427_tgt, $I11, 2
    ne $S10, ">=", rx1427_fail
    add rx1427_pos, 2
    set_addr $I10, rxcap_1432_fail
    ($I12, $I11) = rx1427_cur."!mark_peek"($I10)
    rx1427_cur."!cursor_pos"($I11)
    ($P10) = rx1427_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1427_pos, "")
    rx1427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1432_done
  rxcap_1432_fail:
    goto rx1427_fail
  rxcap_1432_done:
  # rx subrule "O" subtype=capture negate=
    rx1427_cur."!cursor_pos"(rx1427_pos)
    $P10 = rx1427_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1427_fail
    rx1427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1427_pos = $P10."pos"()
  # rx pass
    rx1427_cur."!cursor_pass"(rx1427_pos, "infix:sym<>=>")
    if_null rx1427_debug, debug_1026
    rx1427_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1427_pos)
  debug_1026:
    .return (rx1427_cur)
  rx1427_restart:
.annotate 'line', 4
    if_null rx1427_debug, debug_1027
    rx1427_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1027:
  rx1427_fail:
    (rx1427_rep, rx1427_pos, $I10, $P10) = rx1427_cur."!mark_fail"(0)
    lt rx1427_pos, -1, rx1427_done
    eq rx1427_pos, -1, rx1427_fail
    jump $I10
  rx1427_done:
    rx1427_cur."!cursor_fail"()
    if_null rx1427_debug, debug_1028
    rx1427_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1028:
    .return (rx1427_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("329_1299450589.65") :method
.annotate 'line', 4
    $P1429 = self."!PREFIX__!subrule"("O", ">=")
    new $P1430, "ResizablePMCArray"
    push $P1430, $P1429
    .return ($P1430)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("330_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1434_tgt
    .local int rx1434_pos
    .local int rx1434_off
    .local int rx1434_eos
    .local int rx1434_rep
    .local pmc rx1434_cur
    .local pmc rx1434_debug
    (rx1434_cur, rx1434_pos, rx1434_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1434_cur
    .local pmc match
    .lex "$/", match
    length rx1434_eos, rx1434_tgt
    gt rx1434_pos, rx1434_eos, rx1434_done
    set rx1434_off, 0
    lt rx1434_pos, 2, rx1434_start
    sub rx1434_off, rx1434_pos, 1
    substr rx1434_tgt, rx1434_tgt, rx1434_off
  rx1434_start:
    eq $I10, 1, rx1434_restart
    if_null rx1434_debug, debug_1029
    rx1434_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1438_done
    goto rxscan1438_scan
  rxscan1438_loop:
    (rx1434_pos) = rx1434_cur."from"()
    inc rx1434_pos
    rx1434_cur."!cursor_from"(rx1434_pos)
    ge rx1434_pos, rx1434_eos, rxscan1438_done
  rxscan1438_scan:
    set_addr $I10, rxscan1438_loop
    rx1434_cur."!mark_push"(0, rx1434_pos, $I10)
  rxscan1438_done:
.annotate 'line', 619
  # rx subcapture "sym"
    set_addr $I10, rxcap_1439_fail
    rx1434_cur."!mark_push"(0, rx1434_pos, $I10)
  # rx literal  "<"
    add $I11, rx1434_pos, 1
    gt $I11, rx1434_eos, rx1434_fail
    sub $I11, rx1434_pos, rx1434_off
    ord $I11, rx1434_tgt, $I11
    ne $I11, 60, rx1434_fail
    add rx1434_pos, 1
    set_addr $I10, rxcap_1439_fail
    ($I12, $I11) = rx1434_cur."!mark_peek"($I10)
    rx1434_cur."!cursor_pos"($I11)
    ($P10) = rx1434_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1434_pos, "")
    rx1434_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1439_done
  rxcap_1439_fail:
    goto rx1434_fail
  rxcap_1439_done:
  # rx subrule "O" subtype=capture negate=
    rx1434_cur."!cursor_pos"(rx1434_pos)
    $P10 = rx1434_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1434_fail
    rx1434_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1434_pos = $P10."pos"()
  # rx pass
    rx1434_cur."!cursor_pass"(rx1434_pos, "infix:sym<<>")
    if_null rx1434_debug, debug_1030
    rx1434_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1434_pos)
  debug_1030:
    .return (rx1434_cur)
  rx1434_restart:
.annotate 'line', 4
    if_null rx1434_debug, debug_1031
    rx1434_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1031:
  rx1434_fail:
    (rx1434_rep, rx1434_pos, $I10, $P10) = rx1434_cur."!mark_fail"(0)
    lt rx1434_pos, -1, rx1434_done
    eq rx1434_pos, -1, rx1434_fail
    jump $I10
  rx1434_done:
    rx1434_cur."!cursor_fail"()
    if_null rx1434_debug, debug_1032
    rx1434_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1032:
    .return (rx1434_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("331_1299450589.65") :method
.annotate 'line', 4
    $P1436 = self."!PREFIX__!subrule"("O", "<")
    new $P1437, "ResizablePMCArray"
    push $P1437, $P1436
    .return ($P1437)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("332_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1441_tgt
    .local int rx1441_pos
    .local int rx1441_off
    .local int rx1441_eos
    .local int rx1441_rep
    .local pmc rx1441_cur
    .local pmc rx1441_debug
    (rx1441_cur, rx1441_pos, rx1441_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1441_cur
    .local pmc match
    .lex "$/", match
    length rx1441_eos, rx1441_tgt
    gt rx1441_pos, rx1441_eos, rx1441_done
    set rx1441_off, 0
    lt rx1441_pos, 2, rx1441_start
    sub rx1441_off, rx1441_pos, 1
    substr rx1441_tgt, rx1441_tgt, rx1441_off
  rx1441_start:
    eq $I10, 1, rx1441_restart
    if_null rx1441_debug, debug_1033
    rx1441_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1445_done
    goto rxscan1445_scan
  rxscan1445_loop:
    (rx1441_pos) = rx1441_cur."from"()
    inc rx1441_pos
    rx1441_cur."!cursor_from"(rx1441_pos)
    ge rx1441_pos, rx1441_eos, rxscan1445_done
  rxscan1445_scan:
    set_addr $I10, rxscan1445_loop
    rx1441_cur."!mark_push"(0, rx1441_pos, $I10)
  rxscan1445_done:
.annotate 'line', 620
  # rx subcapture "sym"
    set_addr $I10, rxcap_1446_fail
    rx1441_cur."!mark_push"(0, rx1441_pos, $I10)
  # rx literal  ">"
    add $I11, rx1441_pos, 1
    gt $I11, rx1441_eos, rx1441_fail
    sub $I11, rx1441_pos, rx1441_off
    ord $I11, rx1441_tgt, $I11
    ne $I11, 62, rx1441_fail
    add rx1441_pos, 1
    set_addr $I10, rxcap_1446_fail
    ($I12, $I11) = rx1441_cur."!mark_peek"($I10)
    rx1441_cur."!cursor_pos"($I11)
    ($P10) = rx1441_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1441_pos, "")
    rx1441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1446_done
  rxcap_1446_fail:
    goto rx1441_fail
  rxcap_1446_done:
  # rx subrule "O" subtype=capture negate=
    rx1441_cur."!cursor_pos"(rx1441_pos)
    $P10 = rx1441_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1441_fail
    rx1441_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1441_pos = $P10."pos"()
  # rx pass
    rx1441_cur."!cursor_pass"(rx1441_pos, "infix:sym<>>")
    if_null rx1441_debug, debug_1034
    rx1441_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1441_pos)
  debug_1034:
    .return (rx1441_cur)
  rx1441_restart:
.annotate 'line', 4
    if_null rx1441_debug, debug_1035
    rx1441_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1035:
  rx1441_fail:
    (rx1441_rep, rx1441_pos, $I10, $P10) = rx1441_cur."!mark_fail"(0)
    lt rx1441_pos, -1, rx1441_done
    eq rx1441_pos, -1, rx1441_fail
    jump $I10
  rx1441_done:
    rx1441_cur."!cursor_fail"()
    if_null rx1441_debug, debug_1036
    rx1441_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1036:
    .return (rx1441_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("333_1299450589.65") :method
.annotate 'line', 4
    $P1443 = self."!PREFIX__!subrule"("O", ">")
    new $P1444, "ResizablePMCArray"
    push $P1444, $P1443
    .return ($P1444)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("334_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1448_tgt
    .local int rx1448_pos
    .local int rx1448_off
    .local int rx1448_eos
    .local int rx1448_rep
    .local pmc rx1448_cur
    .local pmc rx1448_debug
    (rx1448_cur, rx1448_pos, rx1448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1448_cur
    .local pmc match
    .lex "$/", match
    length rx1448_eos, rx1448_tgt
    gt rx1448_pos, rx1448_eos, rx1448_done
    set rx1448_off, 0
    lt rx1448_pos, 2, rx1448_start
    sub rx1448_off, rx1448_pos, 1
    substr rx1448_tgt, rx1448_tgt, rx1448_off
  rx1448_start:
    eq $I10, 1, rx1448_restart
    if_null rx1448_debug, debug_1037
    rx1448_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1452_done
    goto rxscan1452_scan
  rxscan1452_loop:
    (rx1448_pos) = rx1448_cur."from"()
    inc rx1448_pos
    rx1448_cur."!cursor_from"(rx1448_pos)
    ge rx1448_pos, rx1448_eos, rxscan1452_done
  rxscan1452_scan:
    set_addr $I10, rxscan1452_loop
    rx1448_cur."!mark_push"(0, rx1448_pos, $I10)
  rxscan1452_done:
.annotate 'line', 621
  # rx subcapture "sym"
    set_addr $I10, rxcap_1453_fail
    rx1448_cur."!mark_push"(0, rx1448_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1448_pos, 2
    gt $I11, rx1448_eos, rx1448_fail
    sub $I11, rx1448_pos, rx1448_off
    substr $S10, rx1448_tgt, $I11, 2
    ne $S10, "eq", rx1448_fail
    add rx1448_pos, 2
    set_addr $I10, rxcap_1453_fail
    ($I12, $I11) = rx1448_cur."!mark_peek"($I10)
    rx1448_cur."!cursor_pos"($I11)
    ($P10) = rx1448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1448_pos, "")
    rx1448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1453_done
  rxcap_1453_fail:
    goto rx1448_fail
  rxcap_1453_done:
  # rx subrule "O" subtype=capture negate=
    rx1448_cur."!cursor_pos"(rx1448_pos)
    $P10 = rx1448_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1448_fail
    rx1448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1448_pos = $P10."pos"()
  # rx pass
    rx1448_cur."!cursor_pass"(rx1448_pos, "infix:sym<eq>")
    if_null rx1448_debug, debug_1038
    rx1448_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1448_pos)
  debug_1038:
    .return (rx1448_cur)
  rx1448_restart:
.annotate 'line', 4
    if_null rx1448_debug, debug_1039
    rx1448_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1039:
  rx1448_fail:
    (rx1448_rep, rx1448_pos, $I10, $P10) = rx1448_cur."!mark_fail"(0)
    lt rx1448_pos, -1, rx1448_done
    eq rx1448_pos, -1, rx1448_fail
    jump $I10
  rx1448_done:
    rx1448_cur."!cursor_fail"()
    if_null rx1448_debug, debug_1040
    rx1448_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1040:
    .return (rx1448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("335_1299450589.65") :method
.annotate 'line', 4
    $P1450 = self."!PREFIX__!subrule"("O", "eq")
    new $P1451, "ResizablePMCArray"
    push $P1451, $P1450
    .return ($P1451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("336_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1455_tgt
    .local int rx1455_pos
    .local int rx1455_off
    .local int rx1455_eos
    .local int rx1455_rep
    .local pmc rx1455_cur
    .local pmc rx1455_debug
    (rx1455_cur, rx1455_pos, rx1455_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1455_cur
    .local pmc match
    .lex "$/", match
    length rx1455_eos, rx1455_tgt
    gt rx1455_pos, rx1455_eos, rx1455_done
    set rx1455_off, 0
    lt rx1455_pos, 2, rx1455_start
    sub rx1455_off, rx1455_pos, 1
    substr rx1455_tgt, rx1455_tgt, rx1455_off
  rx1455_start:
    eq $I10, 1, rx1455_restart
    if_null rx1455_debug, debug_1041
    rx1455_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1459_done
    goto rxscan1459_scan
  rxscan1459_loop:
    (rx1455_pos) = rx1455_cur."from"()
    inc rx1455_pos
    rx1455_cur."!cursor_from"(rx1455_pos)
    ge rx1455_pos, rx1455_eos, rxscan1459_done
  rxscan1459_scan:
    set_addr $I10, rxscan1459_loop
    rx1455_cur."!mark_push"(0, rx1455_pos, $I10)
  rxscan1459_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1460_fail
    rx1455_cur."!mark_push"(0, rx1455_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1455_pos, 2
    gt $I11, rx1455_eos, rx1455_fail
    sub $I11, rx1455_pos, rx1455_off
    substr $S10, rx1455_tgt, $I11, 2
    ne $S10, "ne", rx1455_fail
    add rx1455_pos, 2
    set_addr $I10, rxcap_1460_fail
    ($I12, $I11) = rx1455_cur."!mark_peek"($I10)
    rx1455_cur."!cursor_pos"($I11)
    ($P10) = rx1455_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1455_pos, "")
    rx1455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1460_done
  rxcap_1460_fail:
    goto rx1455_fail
  rxcap_1460_done:
  # rx subrule "O" subtype=capture negate=
    rx1455_cur."!cursor_pos"(rx1455_pos)
    $P10 = rx1455_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1455_fail
    rx1455_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1455_pos = $P10."pos"()
  # rx pass
    rx1455_cur."!cursor_pass"(rx1455_pos, "infix:sym<ne>")
    if_null rx1455_debug, debug_1042
    rx1455_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1455_pos)
  debug_1042:
    .return (rx1455_cur)
  rx1455_restart:
.annotate 'line', 4
    if_null rx1455_debug, debug_1043
    rx1455_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1043:
  rx1455_fail:
    (rx1455_rep, rx1455_pos, $I10, $P10) = rx1455_cur."!mark_fail"(0)
    lt rx1455_pos, -1, rx1455_done
    eq rx1455_pos, -1, rx1455_fail
    jump $I10
  rx1455_done:
    rx1455_cur."!cursor_fail"()
    if_null rx1455_debug, debug_1044
    rx1455_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1044:
    .return (rx1455_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("337_1299450589.65") :method
.annotate 'line', 4
    $P1457 = self."!PREFIX__!subrule"("O", "ne")
    new $P1458, "ResizablePMCArray"
    push $P1458, $P1457
    .return ($P1458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("338_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1462_tgt
    .local int rx1462_pos
    .local int rx1462_off
    .local int rx1462_eos
    .local int rx1462_rep
    .local pmc rx1462_cur
    .local pmc rx1462_debug
    (rx1462_cur, rx1462_pos, rx1462_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1462_cur
    .local pmc match
    .lex "$/", match
    length rx1462_eos, rx1462_tgt
    gt rx1462_pos, rx1462_eos, rx1462_done
    set rx1462_off, 0
    lt rx1462_pos, 2, rx1462_start
    sub rx1462_off, rx1462_pos, 1
    substr rx1462_tgt, rx1462_tgt, rx1462_off
  rx1462_start:
    eq $I10, 1, rx1462_restart
    if_null rx1462_debug, debug_1045
    rx1462_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1466_done
    goto rxscan1466_scan
  rxscan1466_loop:
    (rx1462_pos) = rx1462_cur."from"()
    inc rx1462_pos
    rx1462_cur."!cursor_from"(rx1462_pos)
    ge rx1462_pos, rx1462_eos, rxscan1466_done
  rxscan1466_scan:
    set_addr $I10, rxscan1466_loop
    rx1462_cur."!mark_push"(0, rx1462_pos, $I10)
  rxscan1466_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1467_fail
    rx1462_cur."!mark_push"(0, rx1462_pos, $I10)
  # rx literal  "le"
    add $I11, rx1462_pos, 2
    gt $I11, rx1462_eos, rx1462_fail
    sub $I11, rx1462_pos, rx1462_off
    substr $S10, rx1462_tgt, $I11, 2
    ne $S10, "le", rx1462_fail
    add rx1462_pos, 2
    set_addr $I10, rxcap_1467_fail
    ($I12, $I11) = rx1462_cur."!mark_peek"($I10)
    rx1462_cur."!cursor_pos"($I11)
    ($P10) = rx1462_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1462_pos, "")
    rx1462_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1467_done
  rxcap_1467_fail:
    goto rx1462_fail
  rxcap_1467_done:
  # rx subrule "O" subtype=capture negate=
    rx1462_cur."!cursor_pos"(rx1462_pos)
    $P10 = rx1462_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1462_fail
    rx1462_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1462_pos = $P10."pos"()
  # rx pass
    rx1462_cur."!cursor_pass"(rx1462_pos, "infix:sym<le>")
    if_null rx1462_debug, debug_1046
    rx1462_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1462_pos)
  debug_1046:
    .return (rx1462_cur)
  rx1462_restart:
.annotate 'line', 4
    if_null rx1462_debug, debug_1047
    rx1462_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1047:
  rx1462_fail:
    (rx1462_rep, rx1462_pos, $I10, $P10) = rx1462_cur."!mark_fail"(0)
    lt rx1462_pos, -1, rx1462_done
    eq rx1462_pos, -1, rx1462_fail
    jump $I10
  rx1462_done:
    rx1462_cur."!cursor_fail"()
    if_null rx1462_debug, debug_1048
    rx1462_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1048:
    .return (rx1462_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("339_1299450589.65") :method
.annotate 'line', 4
    $P1464 = self."!PREFIX__!subrule"("O", "le")
    new $P1465, "ResizablePMCArray"
    push $P1465, $P1464
    .return ($P1465)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("340_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1469_tgt
    .local int rx1469_pos
    .local int rx1469_off
    .local int rx1469_eos
    .local int rx1469_rep
    .local pmc rx1469_cur
    .local pmc rx1469_debug
    (rx1469_cur, rx1469_pos, rx1469_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1469_cur
    .local pmc match
    .lex "$/", match
    length rx1469_eos, rx1469_tgt
    gt rx1469_pos, rx1469_eos, rx1469_done
    set rx1469_off, 0
    lt rx1469_pos, 2, rx1469_start
    sub rx1469_off, rx1469_pos, 1
    substr rx1469_tgt, rx1469_tgt, rx1469_off
  rx1469_start:
    eq $I10, 1, rx1469_restart
    if_null rx1469_debug, debug_1049
    rx1469_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1473_done
    goto rxscan1473_scan
  rxscan1473_loop:
    (rx1469_pos) = rx1469_cur."from"()
    inc rx1469_pos
    rx1469_cur."!cursor_from"(rx1469_pos)
    ge rx1469_pos, rx1469_eos, rxscan1473_done
  rxscan1473_scan:
    set_addr $I10, rxscan1473_loop
    rx1469_cur."!mark_push"(0, rx1469_pos, $I10)
  rxscan1473_done:
.annotate 'line', 624
  # rx subcapture "sym"
    set_addr $I10, rxcap_1474_fail
    rx1469_cur."!mark_push"(0, rx1469_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1469_pos, 2
    gt $I11, rx1469_eos, rx1469_fail
    sub $I11, rx1469_pos, rx1469_off
    substr $S10, rx1469_tgt, $I11, 2
    ne $S10, "ge", rx1469_fail
    add rx1469_pos, 2
    set_addr $I10, rxcap_1474_fail
    ($I12, $I11) = rx1469_cur."!mark_peek"($I10)
    rx1469_cur."!cursor_pos"($I11)
    ($P10) = rx1469_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1469_pos, "")
    rx1469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1474_done
  rxcap_1474_fail:
    goto rx1469_fail
  rxcap_1474_done:
  # rx subrule "O" subtype=capture negate=
    rx1469_cur."!cursor_pos"(rx1469_pos)
    $P10 = rx1469_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1469_fail
    rx1469_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1469_pos = $P10."pos"()
  # rx pass
    rx1469_cur."!cursor_pass"(rx1469_pos, "infix:sym<ge>")
    if_null rx1469_debug, debug_1050
    rx1469_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1469_pos)
  debug_1050:
    .return (rx1469_cur)
  rx1469_restart:
.annotate 'line', 4
    if_null rx1469_debug, debug_1051
    rx1469_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1051:
  rx1469_fail:
    (rx1469_rep, rx1469_pos, $I10, $P10) = rx1469_cur."!mark_fail"(0)
    lt rx1469_pos, -1, rx1469_done
    eq rx1469_pos, -1, rx1469_fail
    jump $I10
  rx1469_done:
    rx1469_cur."!cursor_fail"()
    if_null rx1469_debug, debug_1052
    rx1469_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1052:
    .return (rx1469_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("341_1299450589.65") :method
.annotate 'line', 4
    $P1471 = self."!PREFIX__!subrule"("O", "ge")
    new $P1472, "ResizablePMCArray"
    push $P1472, $P1471
    .return ($P1472)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("342_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1476_tgt
    .local int rx1476_pos
    .local int rx1476_off
    .local int rx1476_eos
    .local int rx1476_rep
    .local pmc rx1476_cur
    .local pmc rx1476_debug
    (rx1476_cur, rx1476_pos, rx1476_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1476_cur
    .local pmc match
    .lex "$/", match
    length rx1476_eos, rx1476_tgt
    gt rx1476_pos, rx1476_eos, rx1476_done
    set rx1476_off, 0
    lt rx1476_pos, 2, rx1476_start
    sub rx1476_off, rx1476_pos, 1
    substr rx1476_tgt, rx1476_tgt, rx1476_off
  rx1476_start:
    eq $I10, 1, rx1476_restart
    if_null rx1476_debug, debug_1053
    rx1476_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1480_done
    goto rxscan1480_scan
  rxscan1480_loop:
    (rx1476_pos) = rx1476_cur."from"()
    inc rx1476_pos
    rx1476_cur."!cursor_from"(rx1476_pos)
    ge rx1476_pos, rx1476_eos, rxscan1480_done
  rxscan1480_scan:
    set_addr $I10, rxscan1480_loop
    rx1476_cur."!mark_push"(0, rx1476_pos, $I10)
  rxscan1480_done:
.annotate 'line', 625
  # rx subcapture "sym"
    set_addr $I10, rxcap_1481_fail
    rx1476_cur."!mark_push"(0, rx1476_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1476_pos, 2
    gt $I11, rx1476_eos, rx1476_fail
    sub $I11, rx1476_pos, rx1476_off
    substr $S10, rx1476_tgt, $I11, 2
    ne $S10, "lt", rx1476_fail
    add rx1476_pos, 2
    set_addr $I10, rxcap_1481_fail
    ($I12, $I11) = rx1476_cur."!mark_peek"($I10)
    rx1476_cur."!cursor_pos"($I11)
    ($P10) = rx1476_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1476_pos, "")
    rx1476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1481_done
  rxcap_1481_fail:
    goto rx1476_fail
  rxcap_1481_done:
  # rx subrule "O" subtype=capture negate=
    rx1476_cur."!cursor_pos"(rx1476_pos)
    $P10 = rx1476_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1476_fail
    rx1476_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1476_pos = $P10."pos"()
  # rx pass
    rx1476_cur."!cursor_pass"(rx1476_pos, "infix:sym<lt>")
    if_null rx1476_debug, debug_1054
    rx1476_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1476_pos)
  debug_1054:
    .return (rx1476_cur)
  rx1476_restart:
.annotate 'line', 4
    if_null rx1476_debug, debug_1055
    rx1476_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1055:
  rx1476_fail:
    (rx1476_rep, rx1476_pos, $I10, $P10) = rx1476_cur."!mark_fail"(0)
    lt rx1476_pos, -1, rx1476_done
    eq rx1476_pos, -1, rx1476_fail
    jump $I10
  rx1476_done:
    rx1476_cur."!cursor_fail"()
    if_null rx1476_debug, debug_1056
    rx1476_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1056:
    .return (rx1476_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("343_1299450589.65") :method
.annotate 'line', 4
    $P1478 = self."!PREFIX__!subrule"("O", "lt")
    new $P1479, "ResizablePMCArray"
    push $P1479, $P1478
    .return ($P1479)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("344_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1483_tgt
    .local int rx1483_pos
    .local int rx1483_off
    .local int rx1483_eos
    .local int rx1483_rep
    .local pmc rx1483_cur
    .local pmc rx1483_debug
    (rx1483_cur, rx1483_pos, rx1483_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1483_cur
    .local pmc match
    .lex "$/", match
    length rx1483_eos, rx1483_tgt
    gt rx1483_pos, rx1483_eos, rx1483_done
    set rx1483_off, 0
    lt rx1483_pos, 2, rx1483_start
    sub rx1483_off, rx1483_pos, 1
    substr rx1483_tgt, rx1483_tgt, rx1483_off
  rx1483_start:
    eq $I10, 1, rx1483_restart
    if_null rx1483_debug, debug_1057
    rx1483_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1487_done
    goto rxscan1487_scan
  rxscan1487_loop:
    (rx1483_pos) = rx1483_cur."from"()
    inc rx1483_pos
    rx1483_cur."!cursor_from"(rx1483_pos)
    ge rx1483_pos, rx1483_eos, rxscan1487_done
  rxscan1487_scan:
    set_addr $I10, rxscan1487_loop
    rx1483_cur."!mark_push"(0, rx1483_pos, $I10)
  rxscan1487_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1488_fail
    rx1483_cur."!mark_push"(0, rx1483_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1483_pos, 2
    gt $I11, rx1483_eos, rx1483_fail
    sub $I11, rx1483_pos, rx1483_off
    substr $S10, rx1483_tgt, $I11, 2
    ne $S10, "gt", rx1483_fail
    add rx1483_pos, 2
    set_addr $I10, rxcap_1488_fail
    ($I12, $I11) = rx1483_cur."!mark_peek"($I10)
    rx1483_cur."!cursor_pos"($I11)
    ($P10) = rx1483_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1483_pos, "")
    rx1483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1488_done
  rxcap_1488_fail:
    goto rx1483_fail
  rxcap_1488_done:
  # rx subrule "O" subtype=capture negate=
    rx1483_cur."!cursor_pos"(rx1483_pos)
    $P10 = rx1483_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1483_fail
    rx1483_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1483_pos = $P10."pos"()
  # rx pass
    rx1483_cur."!cursor_pass"(rx1483_pos, "infix:sym<gt>")
    if_null rx1483_debug, debug_1058
    rx1483_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1483_pos)
  debug_1058:
    .return (rx1483_cur)
  rx1483_restart:
.annotate 'line', 4
    if_null rx1483_debug, debug_1059
    rx1483_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1059:
  rx1483_fail:
    (rx1483_rep, rx1483_pos, $I10, $P10) = rx1483_cur."!mark_fail"(0)
    lt rx1483_pos, -1, rx1483_done
    eq rx1483_pos, -1, rx1483_fail
    jump $I10
  rx1483_done:
    rx1483_cur."!cursor_fail"()
    if_null rx1483_debug, debug_1060
    rx1483_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1060:
    .return (rx1483_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("345_1299450589.65") :method
.annotate 'line', 4
    $P1485 = self."!PREFIX__!subrule"("O", "gt")
    new $P1486, "ResizablePMCArray"
    push $P1486, $P1485
    .return ($P1486)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("346_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1490_tgt
    .local int rx1490_pos
    .local int rx1490_off
    .local int rx1490_eos
    .local int rx1490_rep
    .local pmc rx1490_cur
    .local pmc rx1490_debug
    (rx1490_cur, rx1490_pos, rx1490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1490_cur
    .local pmc match
    .lex "$/", match
    length rx1490_eos, rx1490_tgt
    gt rx1490_pos, rx1490_eos, rx1490_done
    set rx1490_off, 0
    lt rx1490_pos, 2, rx1490_start
    sub rx1490_off, rx1490_pos, 1
    substr rx1490_tgt, rx1490_tgt, rx1490_off
  rx1490_start:
    eq $I10, 1, rx1490_restart
    if_null rx1490_debug, debug_1061
    rx1490_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1494_done
    goto rxscan1494_scan
  rxscan1494_loop:
    (rx1490_pos) = rx1490_cur."from"()
    inc rx1490_pos
    rx1490_cur."!cursor_from"(rx1490_pos)
    ge rx1490_pos, rx1490_eos, rxscan1494_done
  rxscan1494_scan:
    set_addr $I10, rxscan1494_loop
    rx1490_cur."!mark_push"(0, rx1490_pos, $I10)
  rxscan1494_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1495_fail
    rx1490_cur."!mark_push"(0, rx1490_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1490_pos, 3
    gt $I11, rx1490_eos, rx1490_fail
    sub $I11, rx1490_pos, rx1490_off
    substr $S10, rx1490_tgt, $I11, 3
    ne $S10, "=:=", rx1490_fail
    add rx1490_pos, 3
    set_addr $I10, rxcap_1495_fail
    ($I12, $I11) = rx1490_cur."!mark_peek"($I10)
    rx1490_cur."!cursor_pos"($I11)
    ($P10) = rx1490_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1490_pos, "")
    rx1490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1495_done
  rxcap_1495_fail:
    goto rx1490_fail
  rxcap_1495_done:
  # rx subrule "O" subtype=capture negate=
    rx1490_cur."!cursor_pos"(rx1490_pos)
    $P10 = rx1490_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1490_fail
    rx1490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1490_pos = $P10."pos"()
  # rx pass
    rx1490_cur."!cursor_pass"(rx1490_pos, "infix:sym<=:=>")
    if_null rx1490_debug, debug_1062
    rx1490_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1490_pos)
  debug_1062:
    .return (rx1490_cur)
  rx1490_restart:
.annotate 'line', 4
    if_null rx1490_debug, debug_1063
    rx1490_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1063:
  rx1490_fail:
    (rx1490_rep, rx1490_pos, $I10, $P10) = rx1490_cur."!mark_fail"(0)
    lt rx1490_pos, -1, rx1490_done
    eq rx1490_pos, -1, rx1490_fail
    jump $I10
  rx1490_done:
    rx1490_cur."!cursor_fail"()
    if_null rx1490_debug, debug_1064
    rx1490_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1064:
    .return (rx1490_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("347_1299450589.65") :method
.annotate 'line', 4
    $P1492 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1493, "ResizablePMCArray"
    push $P1493, $P1492
    .return ($P1493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("348_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1497_tgt
    .local int rx1497_pos
    .local int rx1497_off
    .local int rx1497_eos
    .local int rx1497_rep
    .local pmc rx1497_cur
    .local pmc rx1497_debug
    (rx1497_cur, rx1497_pos, rx1497_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1497_cur
    .local pmc match
    .lex "$/", match
    length rx1497_eos, rx1497_tgt
    gt rx1497_pos, rx1497_eos, rx1497_done
    set rx1497_off, 0
    lt rx1497_pos, 2, rx1497_start
    sub rx1497_off, rx1497_pos, 1
    substr rx1497_tgt, rx1497_tgt, rx1497_off
  rx1497_start:
    eq $I10, 1, rx1497_restart
    if_null rx1497_debug, debug_1065
    rx1497_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1501_done
    goto rxscan1501_scan
  rxscan1501_loop:
    (rx1497_pos) = rx1497_cur."from"()
    inc rx1497_pos
    rx1497_cur."!cursor_from"(rx1497_pos)
    ge rx1497_pos, rx1497_eos, rxscan1501_done
  rxscan1501_scan:
    set_addr $I10, rxscan1501_loop
    rx1497_cur."!mark_push"(0, rx1497_pos, $I10)
  rxscan1501_done:
.annotate 'line', 628
  # rx subcapture "sym"
    set_addr $I10, rxcap_1502_fail
    rx1497_cur."!mark_push"(0, rx1497_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1497_pos, 2
    gt $I11, rx1497_eos, rx1497_fail
    sub $I11, rx1497_pos, rx1497_off
    substr $S10, rx1497_tgt, $I11, 2
    ne $S10, "~~", rx1497_fail
    add rx1497_pos, 2
    set_addr $I10, rxcap_1502_fail
    ($I12, $I11) = rx1497_cur."!mark_peek"($I10)
    rx1497_cur."!cursor_pos"($I11)
    ($P10) = rx1497_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1497_pos, "")
    rx1497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1502_done
  rxcap_1502_fail:
    goto rx1497_fail
  rxcap_1502_done:
  # rx subrule "O" subtype=capture negate=
    rx1497_cur."!cursor_pos"(rx1497_pos)
    $P10 = rx1497_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1497_fail
    rx1497_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1497_pos = $P10."pos"()
  # rx pass
    rx1497_cur."!cursor_pass"(rx1497_pos, "infix:sym<~~>")
    if_null rx1497_debug, debug_1066
    rx1497_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1497_pos)
  debug_1066:
    .return (rx1497_cur)
  rx1497_restart:
.annotate 'line', 4
    if_null rx1497_debug, debug_1067
    rx1497_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1067:
  rx1497_fail:
    (rx1497_rep, rx1497_pos, $I10, $P10) = rx1497_cur."!mark_fail"(0)
    lt rx1497_pos, -1, rx1497_done
    eq rx1497_pos, -1, rx1497_fail
    jump $I10
  rx1497_done:
    rx1497_cur."!cursor_fail"()
    if_null rx1497_debug, debug_1068
    rx1497_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1068:
    .return (rx1497_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("349_1299450589.65") :method
.annotate 'line', 4
    $P1499 = self."!PREFIX__!subrule"("O", "~~")
    new $P1500, "ResizablePMCArray"
    push $P1500, $P1499
    .return ($P1500)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("350_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1504_tgt
    .local int rx1504_pos
    .local int rx1504_off
    .local int rx1504_eos
    .local int rx1504_rep
    .local pmc rx1504_cur
    .local pmc rx1504_debug
    (rx1504_cur, rx1504_pos, rx1504_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1504_cur
    .local pmc match
    .lex "$/", match
    length rx1504_eos, rx1504_tgt
    gt rx1504_pos, rx1504_eos, rx1504_done
    set rx1504_off, 0
    lt rx1504_pos, 2, rx1504_start
    sub rx1504_off, rx1504_pos, 1
    substr rx1504_tgt, rx1504_tgt, rx1504_off
  rx1504_start:
    eq $I10, 1, rx1504_restart
    if_null rx1504_debug, debug_1069
    rx1504_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1508_done
    goto rxscan1508_scan
  rxscan1508_loop:
    (rx1504_pos) = rx1504_cur."from"()
    inc rx1504_pos
    rx1504_cur."!cursor_from"(rx1504_pos)
    ge rx1504_pos, rx1504_eos, rxscan1508_done
  rxscan1508_scan:
    set_addr $I10, rxscan1508_loop
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  rxscan1508_done:
.annotate 'line', 630
  # rx subcapture "sym"
    set_addr $I10, rxcap_1509_fail
    rx1504_cur."!mark_push"(0, rx1504_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1504_pos, 2
    gt $I11, rx1504_eos, rx1504_fail
    sub $I11, rx1504_pos, rx1504_off
    substr $S10, rx1504_tgt, $I11, 2
    ne $S10, "&&", rx1504_fail
    add rx1504_pos, 2
    set_addr $I10, rxcap_1509_fail
    ($I12, $I11) = rx1504_cur."!mark_peek"($I10)
    rx1504_cur."!cursor_pos"($I11)
    ($P10) = rx1504_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1504_pos, "")
    rx1504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1509_done
  rxcap_1509_fail:
    goto rx1504_fail
  rxcap_1509_done:
  # rx subrule "O" subtype=capture negate=
    rx1504_cur."!cursor_pos"(rx1504_pos)
    $P10 = rx1504_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1504_fail
    rx1504_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1504_pos = $P10."pos"()
  # rx pass
    rx1504_cur."!cursor_pass"(rx1504_pos, "infix:sym<&&>")
    if_null rx1504_debug, debug_1070
    rx1504_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1504_pos)
  debug_1070:
    .return (rx1504_cur)
  rx1504_restart:
.annotate 'line', 4
    if_null rx1504_debug, debug_1071
    rx1504_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1071:
  rx1504_fail:
    (rx1504_rep, rx1504_pos, $I10, $P10) = rx1504_cur."!mark_fail"(0)
    lt rx1504_pos, -1, rx1504_done
    eq rx1504_pos, -1, rx1504_fail
    jump $I10
  rx1504_done:
    rx1504_cur."!cursor_fail"()
    if_null rx1504_debug, debug_1072
    rx1504_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1072:
    .return (rx1504_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("351_1299450589.65") :method
.annotate 'line', 4
    $P1506 = self."!PREFIX__!subrule"("O", "&&")
    new $P1507, "ResizablePMCArray"
    push $P1507, $P1506
    .return ($P1507)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("352_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1511_tgt
    .local int rx1511_pos
    .local int rx1511_off
    .local int rx1511_eos
    .local int rx1511_rep
    .local pmc rx1511_cur
    .local pmc rx1511_debug
    (rx1511_cur, rx1511_pos, rx1511_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1511_cur
    .local pmc match
    .lex "$/", match
    length rx1511_eos, rx1511_tgt
    gt rx1511_pos, rx1511_eos, rx1511_done
    set rx1511_off, 0
    lt rx1511_pos, 2, rx1511_start
    sub rx1511_off, rx1511_pos, 1
    substr rx1511_tgt, rx1511_tgt, rx1511_off
  rx1511_start:
    eq $I10, 1, rx1511_restart
    if_null rx1511_debug, debug_1073
    rx1511_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1515_done
    goto rxscan1515_scan
  rxscan1515_loop:
    (rx1511_pos) = rx1511_cur."from"()
    inc rx1511_pos
    rx1511_cur."!cursor_from"(rx1511_pos)
    ge rx1511_pos, rx1511_eos, rxscan1515_done
  rxscan1515_scan:
    set_addr $I10, rxscan1515_loop
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  rxscan1515_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1516_fail
    rx1511_cur."!mark_push"(0, rx1511_pos, $I10)
  # rx literal  "||"
    add $I11, rx1511_pos, 2
    gt $I11, rx1511_eos, rx1511_fail
    sub $I11, rx1511_pos, rx1511_off
    substr $S10, rx1511_tgt, $I11, 2
    ne $S10, "||", rx1511_fail
    add rx1511_pos, 2
    set_addr $I10, rxcap_1516_fail
    ($I12, $I11) = rx1511_cur."!mark_peek"($I10)
    rx1511_cur."!cursor_pos"($I11)
    ($P10) = rx1511_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1511_pos, "")
    rx1511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1516_done
  rxcap_1516_fail:
    goto rx1511_fail
  rxcap_1516_done:
  # rx subrule "O" subtype=capture negate=
    rx1511_cur."!cursor_pos"(rx1511_pos)
    $P10 = rx1511_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1511_fail
    rx1511_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1511_pos = $P10."pos"()
  # rx pass
    rx1511_cur."!cursor_pass"(rx1511_pos, "infix:sym<||>")
    if_null rx1511_debug, debug_1074
    rx1511_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1511_pos)
  debug_1074:
    .return (rx1511_cur)
  rx1511_restart:
.annotate 'line', 4
    if_null rx1511_debug, debug_1075
    rx1511_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1075:
  rx1511_fail:
    (rx1511_rep, rx1511_pos, $I10, $P10) = rx1511_cur."!mark_fail"(0)
    lt rx1511_pos, -1, rx1511_done
    eq rx1511_pos, -1, rx1511_fail
    jump $I10
  rx1511_done:
    rx1511_cur."!cursor_fail"()
    if_null rx1511_debug, debug_1076
    rx1511_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1076:
    .return (rx1511_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("353_1299450589.65") :method
.annotate 'line', 4
    $P1513 = self."!PREFIX__!subrule"("O", "||")
    new $P1514, "ResizablePMCArray"
    push $P1514, $P1513
    .return ($P1514)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("354_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1518_tgt
    .local int rx1518_pos
    .local int rx1518_off
    .local int rx1518_eos
    .local int rx1518_rep
    .local pmc rx1518_cur
    .local pmc rx1518_debug
    (rx1518_cur, rx1518_pos, rx1518_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1518_cur
    .local pmc match
    .lex "$/", match
    length rx1518_eos, rx1518_tgt
    gt rx1518_pos, rx1518_eos, rx1518_done
    set rx1518_off, 0
    lt rx1518_pos, 2, rx1518_start
    sub rx1518_off, rx1518_pos, 1
    substr rx1518_tgt, rx1518_tgt, rx1518_off
  rx1518_start:
    eq $I10, 1, rx1518_restart
    if_null rx1518_debug, debug_1077
    rx1518_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1522_done
    goto rxscan1522_scan
  rxscan1522_loop:
    (rx1518_pos) = rx1518_cur."from"()
    inc rx1518_pos
    rx1518_cur."!cursor_from"(rx1518_pos)
    ge rx1518_pos, rx1518_eos, rxscan1522_done
  rxscan1522_scan:
    set_addr $I10, rxscan1522_loop
    rx1518_cur."!mark_push"(0, rx1518_pos, $I10)
  rxscan1522_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1523_fail
    rx1518_cur."!mark_push"(0, rx1518_pos, $I10)
  # rx literal  "//"
    add $I11, rx1518_pos, 2
    gt $I11, rx1518_eos, rx1518_fail
    sub $I11, rx1518_pos, rx1518_off
    substr $S10, rx1518_tgt, $I11, 2
    ne $S10, "//", rx1518_fail
    add rx1518_pos, 2
    set_addr $I10, rxcap_1523_fail
    ($I12, $I11) = rx1518_cur."!mark_peek"($I10)
    rx1518_cur."!cursor_pos"($I11)
    ($P10) = rx1518_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1518_pos, "")
    rx1518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1523_done
  rxcap_1523_fail:
    goto rx1518_fail
  rxcap_1523_done:
  # rx subrule "O" subtype=capture negate=
    rx1518_cur."!cursor_pos"(rx1518_pos)
    $P10 = rx1518_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1518_fail
    rx1518_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1518_pos = $P10."pos"()
  # rx pass
    rx1518_cur."!cursor_pass"(rx1518_pos, "infix:sym<//>")
    if_null rx1518_debug, debug_1078
    rx1518_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1518_pos)
  debug_1078:
    .return (rx1518_cur)
  rx1518_restart:
.annotate 'line', 4
    if_null rx1518_debug, debug_1079
    rx1518_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1079:
  rx1518_fail:
    (rx1518_rep, rx1518_pos, $I10, $P10) = rx1518_cur."!mark_fail"(0)
    lt rx1518_pos, -1, rx1518_done
    eq rx1518_pos, -1, rx1518_fail
    jump $I10
  rx1518_done:
    rx1518_cur."!cursor_fail"()
    if_null rx1518_debug, debug_1080
    rx1518_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1080:
    .return (rx1518_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("355_1299450589.65") :method
.annotate 'line', 4
    $P1520 = self."!PREFIX__!subrule"("O", "//")
    new $P1521, "ResizablePMCArray"
    push $P1521, $P1520
    .return ($P1521)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("356_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1525_tgt
    .local int rx1525_pos
    .local int rx1525_off
    .local int rx1525_eos
    .local int rx1525_rep
    .local pmc rx1525_cur
    .local pmc rx1525_debug
    (rx1525_cur, rx1525_pos, rx1525_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1525_cur
    .local pmc match
    .lex "$/", match
    length rx1525_eos, rx1525_tgt
    gt rx1525_pos, rx1525_eos, rx1525_done
    set rx1525_off, 0
    lt rx1525_pos, 2, rx1525_start
    sub rx1525_off, rx1525_pos, 1
    substr rx1525_tgt, rx1525_tgt, rx1525_off
  rx1525_start:
    eq $I10, 1, rx1525_restart
    if_null rx1525_debug, debug_1081
    rx1525_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1529_done
    goto rxscan1529_scan
  rxscan1529_loop:
    (rx1525_pos) = rx1525_cur."from"()
    inc rx1525_pos
    rx1525_cur."!cursor_from"(rx1525_pos)
    ge rx1525_pos, rx1525_eos, rxscan1529_done
  rxscan1529_scan:
    set_addr $I10, rxscan1529_loop
    rx1525_cur."!mark_push"(0, rx1525_pos, $I10)
  rxscan1529_done:
.annotate 'line', 636
  # rx literal  "??"
    add $I11, rx1525_pos, 2
    gt $I11, rx1525_eos, rx1525_fail
    sub $I11, rx1525_pos, rx1525_off
    substr $S10, rx1525_tgt, $I11, 2
    ne $S10, "??", rx1525_fail
    add rx1525_pos, 2
.annotate 'line', 637
  # rx subrule "ws" subtype=method negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."ws"()
    unless $P10, rx1525_fail
    rx1525_pos = $P10."pos"()
.annotate 'line', 638
  # rx subrule "EXPR" subtype=capture negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."EXPR"("i=")
    unless $P10, rx1525_fail
    rx1525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1525_pos = $P10."pos"()
.annotate 'line', 639
  # rx literal  "!!"
    add $I11, rx1525_pos, 2
    gt $I11, rx1525_eos, rx1525_fail
    sub $I11, rx1525_pos, rx1525_off
    substr $S10, rx1525_tgt, $I11, 2
    ne $S10, "!!", rx1525_fail
    add rx1525_pos, 2
.annotate 'line', 640
  # rx subrule "O" subtype=capture negate=
    rx1525_cur."!cursor_pos"(rx1525_pos)
    $P10 = rx1525_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1525_fail
    rx1525_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1525_pos = $P10."pos"()
.annotate 'line', 635
  # rx pass
    rx1525_cur."!cursor_pass"(rx1525_pos, "infix:sym<?? !!>")
    if_null rx1525_debug, debug_1082
    rx1525_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1525_pos)
  debug_1082:
    .return (rx1525_cur)
  rx1525_restart:
.annotate 'line', 4
    if_null rx1525_debug, debug_1083
    rx1525_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1083:
  rx1525_fail:
    (rx1525_rep, rx1525_pos, $I10, $P10) = rx1525_cur."!mark_fail"(0)
    lt rx1525_pos, -1, rx1525_done
    eq rx1525_pos, -1, rx1525_fail
    jump $I10
  rx1525_done:
    rx1525_cur."!cursor_fail"()
    if_null rx1525_debug, debug_1084
    rx1525_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1084:
    .return (rx1525_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("357_1299450589.65") :method
.annotate 'line', 4
    $P1527 = self."!PREFIX__!subrule"("ws", "??")
    new $P1528, "ResizablePMCArray"
    push $P1528, $P1527
    .return ($P1528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("358_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1531_tgt
    .local int rx1531_pos
    .local int rx1531_off
    .local int rx1531_eos
    .local int rx1531_rep
    .local pmc rx1531_cur
    .local pmc rx1531_debug
    (rx1531_cur, rx1531_pos, rx1531_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1531_cur
    .local pmc match
    .lex "$/", match
    length rx1531_eos, rx1531_tgt
    gt rx1531_pos, rx1531_eos, rx1531_done
    set rx1531_off, 0
    lt rx1531_pos, 2, rx1531_start
    sub rx1531_off, rx1531_pos, 1
    substr rx1531_tgt, rx1531_tgt, rx1531_off
  rx1531_start:
    eq $I10, 1, rx1531_restart
    if_null rx1531_debug, debug_1085
    rx1531_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1535_done
    goto rxscan1535_scan
  rxscan1535_loop:
    (rx1531_pos) = rx1531_cur."from"()
    inc rx1531_pos
    rx1531_cur."!cursor_from"(rx1531_pos)
    ge rx1531_pos, rx1531_eos, rxscan1535_done
  rxscan1535_scan:
    set_addr $I10, rxscan1535_loop
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  rxscan1535_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1536_fail
    rx1531_cur."!mark_push"(0, rx1531_pos, $I10)
  # rx literal  "="
    add $I11, rx1531_pos, 1
    gt $I11, rx1531_eos, rx1531_fail
    sub $I11, rx1531_pos, rx1531_off
    ord $I11, rx1531_tgt, $I11
    ne $I11, 61, rx1531_fail
    add rx1531_pos, 1
    set_addr $I10, rxcap_1536_fail
    ($I12, $I11) = rx1531_cur."!mark_peek"($I10)
    rx1531_cur."!cursor_pos"($I11)
    ($P10) = rx1531_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1531_pos, "")
    rx1531_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1536_done
  rxcap_1536_fail:
    goto rx1531_fail
  rxcap_1536_done:
  # rx subrule "panic" subtype=method negate=
    rx1531_cur."!cursor_pos"(rx1531_pos)
    $P10 = rx1531_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1531_fail
    rx1531_pos = $P10."pos"()
.annotate 'line', 643
  # rx pass
    rx1531_cur."!cursor_pass"(rx1531_pos, "infix:sym<=>")
    if_null rx1531_debug, debug_1086
    rx1531_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1531_pos)
  debug_1086:
    .return (rx1531_cur)
  rx1531_restart:
.annotate 'line', 4
    if_null rx1531_debug, debug_1087
    rx1531_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1087:
  rx1531_fail:
    (rx1531_rep, rx1531_pos, $I10, $P10) = rx1531_cur."!mark_fail"(0)
    lt rx1531_pos, -1, rx1531_done
    eq rx1531_pos, -1, rx1531_fail
    jump $I10
  rx1531_done:
    rx1531_cur."!cursor_fail"()
    if_null rx1531_debug, debug_1088
    rx1531_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1088:
    .return (rx1531_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("359_1299450589.65") :method
.annotate 'line', 4
    $P1533 = self."!PREFIX__!subrule"("panic", "=")
    new $P1534, "ResizablePMCArray"
    push $P1534, $P1533
    .return ($P1534)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("360_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1538_tgt
    .local int rx1538_pos
    .local int rx1538_off
    .local int rx1538_eos
    .local int rx1538_rep
    .local pmc rx1538_cur
    .local pmc rx1538_debug
    (rx1538_cur, rx1538_pos, rx1538_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1538_cur
    .local pmc match
    .lex "$/", match
    length rx1538_eos, rx1538_tgt
    gt rx1538_pos, rx1538_eos, rx1538_done
    set rx1538_off, 0
    lt rx1538_pos, 2, rx1538_start
    sub rx1538_off, rx1538_pos, 1
    substr rx1538_tgt, rx1538_tgt, rx1538_off
  rx1538_start:
    eq $I10, 1, rx1538_restart
    if_null rx1538_debug, debug_1089
    rx1538_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1542_done
    goto rxscan1542_scan
  rxscan1542_loop:
    (rx1538_pos) = rx1538_cur."from"()
    inc rx1538_pos
    rx1538_cur."!cursor_from"(rx1538_pos)
    ge rx1538_pos, rx1538_eos, rxscan1542_done
  rxscan1542_scan:
    set_addr $I10, rxscan1542_loop
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  rxscan1542_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1543_fail
    rx1538_cur."!mark_push"(0, rx1538_pos, $I10)
  # rx literal  ":="
    add $I11, rx1538_pos, 2
    gt $I11, rx1538_eos, rx1538_fail
    sub $I11, rx1538_pos, rx1538_off
    substr $S10, rx1538_tgt, $I11, 2
    ne $S10, ":=", rx1538_fail
    add rx1538_pos, 2
    set_addr $I10, rxcap_1543_fail
    ($I12, $I11) = rx1538_cur."!mark_peek"($I10)
    rx1538_cur."!cursor_pos"($I11)
    ($P10) = rx1538_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1538_pos, "")
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1543_done
  rxcap_1543_fail:
    goto rx1538_fail
  rxcap_1543_done:
  # rx subrule "O" subtype=capture negate=
    rx1538_cur."!cursor_pos"(rx1538_pos)
    $P10 = rx1538_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1538_fail
    rx1538_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1538_pos = $P10."pos"()
  # rx pass
    rx1538_cur."!cursor_pass"(rx1538_pos, "infix:sym<:=>")
    if_null rx1538_debug, debug_1090
    rx1538_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1538_pos)
  debug_1090:
    .return (rx1538_cur)
  rx1538_restart:
.annotate 'line', 4
    if_null rx1538_debug, debug_1091
    rx1538_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1091:
  rx1538_fail:
    (rx1538_rep, rx1538_pos, $I10, $P10) = rx1538_cur."!mark_fail"(0)
    lt rx1538_pos, -1, rx1538_done
    eq rx1538_pos, -1, rx1538_fail
    jump $I10
  rx1538_done:
    rx1538_cur."!cursor_fail"()
    if_null rx1538_debug, debug_1092
    rx1538_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1092:
    .return (rx1538_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("361_1299450589.65") :method
.annotate 'line', 4
    $P1540 = self."!PREFIX__!subrule"("O", ":=")
    new $P1541, "ResizablePMCArray"
    push $P1541, $P1540
    .return ($P1541)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("362_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1545_tgt
    .local int rx1545_pos
    .local int rx1545_off
    .local int rx1545_eos
    .local int rx1545_rep
    .local pmc rx1545_cur
    .local pmc rx1545_debug
    (rx1545_cur, rx1545_pos, rx1545_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1545_cur
    .local pmc match
    .lex "$/", match
    length rx1545_eos, rx1545_tgt
    gt rx1545_pos, rx1545_eos, rx1545_done
    set rx1545_off, 0
    lt rx1545_pos, 2, rx1545_start
    sub rx1545_off, rx1545_pos, 1
    substr rx1545_tgt, rx1545_tgt, rx1545_off
  rx1545_start:
    eq $I10, 1, rx1545_restart
    if_null rx1545_debug, debug_1093
    rx1545_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1549_done
    goto rxscan1549_scan
  rxscan1549_loop:
    (rx1545_pos) = rx1545_cur."from"()
    inc rx1545_pos
    rx1545_cur."!cursor_from"(rx1545_pos)
    ge rx1545_pos, rx1545_eos, rxscan1549_done
  rxscan1549_scan:
    set_addr $I10, rxscan1549_loop
    rx1545_cur."!mark_push"(0, rx1545_pos, $I10)
  rxscan1549_done:
.annotate 'line', 647
  # rx subcapture "sym"
    set_addr $I10, rxcap_1550_fail
    rx1545_cur."!mark_push"(0, rx1545_pos, $I10)
  # rx literal  "::="
    add $I11, rx1545_pos, 3
    gt $I11, rx1545_eos, rx1545_fail
    sub $I11, rx1545_pos, rx1545_off
    substr $S10, rx1545_tgt, $I11, 3
    ne $S10, "::=", rx1545_fail
    add rx1545_pos, 3
    set_addr $I10, rxcap_1550_fail
    ($I12, $I11) = rx1545_cur."!mark_peek"($I10)
    rx1545_cur."!cursor_pos"($I11)
    ($P10) = rx1545_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1545_pos, "")
    rx1545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1550_done
  rxcap_1550_fail:
    goto rx1545_fail
  rxcap_1550_done:
  # rx subrule "O" subtype=capture negate=
    rx1545_cur."!cursor_pos"(rx1545_pos)
    $P10 = rx1545_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1545_fail
    rx1545_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1545_pos = $P10."pos"()
  # rx pass
    rx1545_cur."!cursor_pass"(rx1545_pos, "infix:sym<::=>")
    if_null rx1545_debug, debug_1094
    rx1545_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1545_pos)
  debug_1094:
    .return (rx1545_cur)
  rx1545_restart:
.annotate 'line', 4
    if_null rx1545_debug, debug_1095
    rx1545_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1095:
  rx1545_fail:
    (rx1545_rep, rx1545_pos, $I10, $P10) = rx1545_cur."!mark_fail"(0)
    lt rx1545_pos, -1, rx1545_done
    eq rx1545_pos, -1, rx1545_fail
    jump $I10
  rx1545_done:
    rx1545_cur."!cursor_fail"()
    if_null rx1545_debug, debug_1096
    rx1545_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1096:
    .return (rx1545_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("363_1299450589.65") :method
.annotate 'line', 4
    $P1547 = self."!PREFIX__!subrule"("O", "::=")
    new $P1548, "ResizablePMCArray"
    push $P1548, $P1547
    .return ($P1548)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("364_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1552_tgt
    .local int rx1552_pos
    .local int rx1552_off
    .local int rx1552_eos
    .local int rx1552_rep
    .local pmc rx1552_cur
    .local pmc rx1552_debug
    (rx1552_cur, rx1552_pos, rx1552_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1552_cur
    .local pmc match
    .lex "$/", match
    length rx1552_eos, rx1552_tgt
    gt rx1552_pos, rx1552_eos, rx1552_done
    set rx1552_off, 0
    lt rx1552_pos, 2, rx1552_start
    sub rx1552_off, rx1552_pos, 1
    substr rx1552_tgt, rx1552_tgt, rx1552_off
  rx1552_start:
    eq $I10, 1, rx1552_restart
    if_null rx1552_debug, debug_1097
    rx1552_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1556_done
    goto rxscan1556_scan
  rxscan1556_loop:
    (rx1552_pos) = rx1552_cur."from"()
    inc rx1552_pos
    rx1552_cur."!cursor_from"(rx1552_pos)
    ge rx1552_pos, rx1552_eos, rxscan1556_done
  rxscan1556_scan:
    set_addr $I10, rxscan1556_loop
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  rxscan1556_done:
.annotate 'line', 649
  # rx subcapture "sym"
    set_addr $I10, rxcap_1557_fail
    rx1552_cur."!mark_push"(0, rx1552_pos, $I10)
  # rx literal  ","
    add $I11, rx1552_pos, 1
    gt $I11, rx1552_eos, rx1552_fail
    sub $I11, rx1552_pos, rx1552_off
    ord $I11, rx1552_tgt, $I11
    ne $I11, 44, rx1552_fail
    add rx1552_pos, 1
    set_addr $I10, rxcap_1557_fail
    ($I12, $I11) = rx1552_cur."!mark_peek"($I10)
    rx1552_cur."!cursor_pos"($I11)
    ($P10) = rx1552_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1552_pos, "")
    rx1552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1557_done
  rxcap_1557_fail:
    goto rx1552_fail
  rxcap_1557_done:
  # rx subrule "O" subtype=capture negate=
    rx1552_cur."!cursor_pos"(rx1552_pos)
    $P10 = rx1552_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1552_fail
    rx1552_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1552_pos = $P10."pos"()
  # rx pass
    rx1552_cur."!cursor_pass"(rx1552_pos, "infix:sym<,>")
    if_null rx1552_debug, debug_1098
    rx1552_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1552_pos)
  debug_1098:
    .return (rx1552_cur)
  rx1552_restart:
.annotate 'line', 4
    if_null rx1552_debug, debug_1099
    rx1552_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1099:
  rx1552_fail:
    (rx1552_rep, rx1552_pos, $I10, $P10) = rx1552_cur."!mark_fail"(0)
    lt rx1552_pos, -1, rx1552_done
    eq rx1552_pos, -1, rx1552_fail
    jump $I10
  rx1552_done:
    rx1552_cur."!cursor_fail"()
    if_null rx1552_debug, debug_1100
    rx1552_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1100:
    .return (rx1552_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("365_1299450589.65") :method
.annotate 'line', 4
    $P1554 = self."!PREFIX__!subrule"("O", ",")
    new $P1555, "ResizablePMCArray"
    push $P1555, $P1554
    .return ($P1555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("366_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P1567 = "368_1299450589.65" 
    capture_lex $P1567
    .local string rx1559_tgt
    .local int rx1559_pos
    .local int rx1559_off
    .local int rx1559_eos
    .local int rx1559_rep
    .local pmc rx1559_cur
    .local pmc rx1559_debug
    (rx1559_cur, rx1559_pos, rx1559_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1559_cur
    .local pmc match
    .lex "$/", match
    length rx1559_eos, rx1559_tgt
    gt rx1559_pos, rx1559_eos, rx1559_done
    set rx1559_off, 0
    lt rx1559_pos, 2, rx1559_start
    sub rx1559_off, rx1559_pos, 1
    substr rx1559_tgt, rx1559_tgt, rx1559_off
  rx1559_start:
    eq $I10, 1, rx1559_restart
    if_null rx1559_debug, debug_1101
    rx1559_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1101:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1562_done
    goto rxscan1562_scan
  rxscan1562_loop:
    (rx1559_pos) = rx1559_cur."from"()
    inc rx1559_pos
    rx1559_cur."!cursor_from"(rx1559_pos)
    ge rx1559_pos, rx1559_eos, rxscan1562_done
  rxscan1562_scan:
    set_addr $I10, rxscan1562_loop
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  rxscan1562_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1563_fail
    rx1559_cur."!mark_push"(0, rx1559_pos, $I10)
  # rx literal  "return"
    add $I11, rx1559_pos, 6
    gt $I11, rx1559_eos, rx1559_fail
    sub $I11, rx1559_pos, rx1559_off
    substr $S10, rx1559_tgt, $I11, 6
    ne $S10, "return", rx1559_fail
    add rx1559_pos, 6
    set_addr $I10, rxcap_1563_fail
    ($I12, $I11) = rx1559_cur."!mark_peek"($I10)
    rx1559_cur."!cursor_pos"($I11)
    ($P10) = rx1559_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1559_pos, "")
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1563_done
  rxcap_1563_fail:
    goto rx1559_fail
  rxcap_1563_done:
  # rx charclass s
    ge rx1559_pos, rx1559_eos, rx1559_fail
    sub $I10, rx1559_pos, rx1559_off
    is_cclass $I11, 32, rx1559_tgt, $I10
    unless $I11, rx1559_fail
    inc rx1559_pos
  # rx subrule "O" subtype=capture negate=
    rx1559_cur."!cursor_pos"(rx1559_pos)
    $P10 = rx1559_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1559_fail
    rx1559_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1559_pos = $P10."pos"()
    rx1559_cur."!cursor_pos"(rx1559_pos)
    find_lex $P1564, unicode:"$\x{a2}"
    $P1565 = $P1564."MATCH"()
    store_lex "$/", $P1565
    .const 'Sub' $P1567 = "368_1299450589.65" 
    capture_lex $P1567
    $P1569 = $P1567()
  # rx pass
    rx1559_cur."!cursor_pass"(rx1559_pos, "prefix:sym<return>")
    if_null rx1559_debug, debug_1102
    rx1559_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1559_pos)
  debug_1102:
    .return (rx1559_cur)
  rx1559_restart:
.annotate 'line', 4
    if_null rx1559_debug, debug_1103
    rx1559_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1103:
  rx1559_fail:
    (rx1559_rep, rx1559_pos, $I10, $P10) = rx1559_cur."!mark_fail"(0)
    lt rx1559_pos, -1, rx1559_done
    eq rx1559_pos, -1, rx1559_fail
    jump $I10
  rx1559_done:
    rx1559_cur."!cursor_fail"()
    if_null rx1559_debug, debug_1104
    rx1559_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1104:
    .return (rx1559_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("367_1299450589.65") :method
.annotate 'line', 4
    new $P1561, "ResizablePMCArray"
    push $P1561, "return"
    .return ($P1561)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1566"  :anon :subid("368_1299450589.65") :outer("366_1299450589.65")
.annotate 'line', 651
    new $P1568, "Integer"
    assign $P1568, 1
    store_dynamic_lex "$*RETURN_USED", $P1568
    .return ($P1568)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("369_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1571_tgt
    .local int rx1571_pos
    .local int rx1571_off
    .local int rx1571_eos
    .local int rx1571_rep
    .local pmc rx1571_cur
    .local pmc rx1571_debug
    (rx1571_cur, rx1571_pos, rx1571_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1571_cur
    .local pmc match
    .lex "$/", match
    length rx1571_eos, rx1571_tgt
    gt rx1571_pos, rx1571_eos, rx1571_done
    set rx1571_off, 0
    lt rx1571_pos, 2, rx1571_start
    sub rx1571_off, rx1571_pos, 1
    substr rx1571_tgt, rx1571_tgt, rx1571_off
  rx1571_start:
    eq $I10, 1, rx1571_restart
    if_null rx1571_debug, debug_1105
    rx1571_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1105:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1571_pos) = rx1571_cur."from"()
    inc rx1571_pos
    rx1571_cur."!cursor_from"(rx1571_pos)
    ge rx1571_pos, rx1571_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  rxscan1574_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1575_fail
    rx1571_cur."!mark_push"(0, rx1571_pos, $I10)
  # rx literal  "make"
    add $I11, rx1571_pos, 4
    gt $I11, rx1571_eos, rx1571_fail
    sub $I11, rx1571_pos, rx1571_off
    substr $S10, rx1571_tgt, $I11, 4
    ne $S10, "make", rx1571_fail
    add rx1571_pos, 4
    set_addr $I10, rxcap_1575_fail
    ($I12, $I11) = rx1571_cur."!mark_peek"($I10)
    rx1571_cur."!cursor_pos"($I11)
    ($P10) = rx1571_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1571_pos, "")
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1575_done
  rxcap_1575_fail:
    goto rx1571_fail
  rxcap_1575_done:
  # rx charclass s
    ge rx1571_pos, rx1571_eos, rx1571_fail
    sub $I10, rx1571_pos, rx1571_off
    is_cclass $I11, 32, rx1571_tgt, $I10
    unless $I11, rx1571_fail
    inc rx1571_pos
  # rx subrule "O" subtype=capture negate=
    rx1571_cur."!cursor_pos"(rx1571_pos)
    $P10 = rx1571_cur."O"("%list_prefix")
    unless $P10, rx1571_fail
    rx1571_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1571_pos = $P10."pos"()
  # rx pass
    rx1571_cur."!cursor_pass"(rx1571_pos, "prefix:sym<make>")
    if_null rx1571_debug, debug_1106
    rx1571_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1571_pos)
  debug_1106:
    .return (rx1571_cur)
  rx1571_restart:
.annotate 'line', 4
    if_null rx1571_debug, debug_1107
    rx1571_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1107:
  rx1571_fail:
    (rx1571_rep, rx1571_pos, $I10, $P10) = rx1571_cur."!mark_fail"(0)
    lt rx1571_pos, -1, rx1571_done
    eq rx1571_pos, -1, rx1571_fail
    jump $I10
  rx1571_done:
    rx1571_cur."!cursor_fail"()
    if_null rx1571_debug, debug_1108
    rx1571_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1108:
    .return (rx1571_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("370_1299450589.65") :method
.annotate 'line', 4
    new $P1573, "ResizablePMCArray"
    push $P1573, "make"
    .return ($P1573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("371_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1109
    rx1577_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1109:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1580_done
    goto rxscan1580_scan
  rxscan1580_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1580_done
  rxscan1580_scan:
    set_addr $I10, rxscan1580_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1580_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1581_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "last"
    add $I11, rx1577_pos, 4
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 4
    ne $S10, "last", rx1577_fail
    add rx1577_pos, 4
    set_addr $I10, rxcap_1581_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1581_done
  rxcap_1581_fail:
    goto rx1577_fail
  rxcap_1581_done:
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "term:sym<last>")
    if_null rx1577_debug, debug_1110
    rx1577_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1577_pos)
  debug_1110:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 4
    if_null rx1577_debug, debug_1111
    rx1577_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1111:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1112
    rx1577_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1112:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("372_1299450589.65") :method
.annotate 'line', 4
    new $P1579, "ResizablePMCArray"
    push $P1579, "last"
    .return ($P1579)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("373_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1583_tgt
    .local int rx1583_pos
    .local int rx1583_off
    .local int rx1583_eos
    .local int rx1583_rep
    .local pmc rx1583_cur
    .local pmc rx1583_debug
    (rx1583_cur, rx1583_pos, rx1583_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1583_cur
    .local pmc match
    .lex "$/", match
    length rx1583_eos, rx1583_tgt
    gt rx1583_pos, rx1583_eos, rx1583_done
    set rx1583_off, 0
    lt rx1583_pos, 2, rx1583_start
    sub rx1583_off, rx1583_pos, 1
    substr rx1583_tgt, rx1583_tgt, rx1583_off
  rx1583_start:
    eq $I10, 1, rx1583_restart
    if_null rx1583_debug, debug_1113
    rx1583_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1113:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1586_done
    goto rxscan1586_scan
  rxscan1586_loop:
    (rx1583_pos) = rx1583_cur."from"()
    inc rx1583_pos
    rx1583_cur."!cursor_from"(rx1583_pos)
    ge rx1583_pos, rx1583_eos, rxscan1586_done
  rxscan1586_scan:
    set_addr $I10, rxscan1586_loop
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  rxscan1586_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1587_fail
    rx1583_cur."!mark_push"(0, rx1583_pos, $I10)
  # rx literal  "next"
    add $I11, rx1583_pos, 4
    gt $I11, rx1583_eos, rx1583_fail
    sub $I11, rx1583_pos, rx1583_off
    substr $S10, rx1583_tgt, $I11, 4
    ne $S10, "next", rx1583_fail
    add rx1583_pos, 4
    set_addr $I10, rxcap_1587_fail
    ($I12, $I11) = rx1583_cur."!mark_peek"($I10)
    rx1583_cur."!cursor_pos"($I11)
    ($P10) = rx1583_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1583_pos, "")
    rx1583_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1587_done
  rxcap_1587_fail:
    goto rx1583_fail
  rxcap_1587_done:
  # rx pass
    rx1583_cur."!cursor_pass"(rx1583_pos, "term:sym<next>")
    if_null rx1583_debug, debug_1114
    rx1583_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1583_pos)
  debug_1114:
    .return (rx1583_cur)
  rx1583_restart:
.annotate 'line', 4
    if_null rx1583_debug, debug_1115
    rx1583_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1115:
  rx1583_fail:
    (rx1583_rep, rx1583_pos, $I10, $P10) = rx1583_cur."!mark_fail"(0)
    lt rx1583_pos, -1, rx1583_done
    eq rx1583_pos, -1, rx1583_fail
    jump $I10
  rx1583_done:
    rx1583_cur."!cursor_fail"()
    if_null rx1583_debug, debug_1116
    rx1583_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1116:
    .return (rx1583_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("374_1299450589.65") :method
.annotate 'line', 4
    new $P1585, "ResizablePMCArray"
    push $P1585, "next"
    .return ($P1585)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("375_1299450589.65") :method :outer("11_1299450589.65")
.annotate 'line', 4
    .local string rx1589_tgt
    .local int rx1589_pos
    .local int rx1589_off
    .local int rx1589_eos
    .local int rx1589_rep
    .local pmc rx1589_cur
    .local pmc rx1589_debug
    (rx1589_cur, rx1589_pos, rx1589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1589_cur
    .local pmc match
    .lex "$/", match
    length rx1589_eos, rx1589_tgt
    gt rx1589_pos, rx1589_eos, rx1589_done
    set rx1589_off, 0
    lt rx1589_pos, 2, rx1589_start
    sub rx1589_off, rx1589_pos, 1
    substr rx1589_tgt, rx1589_tgt, rx1589_off
  rx1589_start:
    eq $I10, 1, rx1589_restart
    if_null rx1589_debug, debug_1117
    rx1589_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1117:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1592_done
    goto rxscan1592_scan
  rxscan1592_loop:
    (rx1589_pos) = rx1589_cur."from"()
    inc rx1589_pos
    rx1589_cur."!cursor_from"(rx1589_pos)
    ge rx1589_pos, rx1589_eos, rxscan1592_done
  rxscan1592_scan:
    set_addr $I10, rxscan1592_loop
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  rxscan1592_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1593_fail
    rx1589_cur."!mark_push"(0, rx1589_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1589_pos, 4
    gt $I11, rx1589_eos, rx1589_fail
    sub $I11, rx1589_pos, rx1589_off
    substr $S10, rx1589_tgt, $I11, 4
    ne $S10, "redo", rx1589_fail
    add rx1589_pos, 4
    set_addr $I10, rxcap_1593_fail
    ($I12, $I11) = rx1589_cur."!mark_peek"($I10)
    rx1589_cur."!cursor_pos"($I11)
    ($P10) = rx1589_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1589_pos, "")
    rx1589_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1593_done
  rxcap_1593_fail:
    goto rx1589_fail
  rxcap_1593_done:
  # rx pass
    rx1589_cur."!cursor_pass"(rx1589_pos, "term:sym<redo>")
    if_null rx1589_debug, debug_1118
    rx1589_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1589_pos)
  debug_1118:
    .return (rx1589_cur)
  rx1589_restart:
.annotate 'line', 4
    if_null rx1589_debug, debug_1119
    rx1589_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1119:
  rx1589_fail:
    (rx1589_rep, rx1589_pos, $I10, $P10) = rx1589_cur."!mark_fail"(0)
    lt rx1589_pos, -1, rx1589_done
    eq rx1589_pos, -1, rx1589_fail
    jump $I10
  rx1589_done:
    rx1589_cur."!cursor_fail"()
    if_null rx1589_debug, debug_1120
    rx1589_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1120:
    .return (rx1589_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("376_1299450589.65") :method
.annotate 'line', 4
    new $P1591, "ResizablePMCArray"
    push $P1591, "redo"
    .return ($P1591)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("377_1299450589.65") :outer("11_1299450589.65")
    .param pmc param_1595
    .param pmc param_1596
.annotate 'line', 657
    .lex "self", param_1595
    .lex "$/", param_1596
.annotate 'line', 659
    new $P1597, "Undef"
    .lex "$t", $P1597
    find_lex $P1598, "$/"
    unless_null $P1598, vivify_1121
    $P1598 = root_new ['parrot';'ResizablePMCArray']
  vivify_1121:
    set $P1599, $P1598[0]
    unless_null $P1599, vivify_1122
    new $P1599, "Undef"
  vivify_1122:
    store_lex "$t", $P1599
    find_lex $P1600, "$/"
    unless_null $P1600, vivify_1123
    $P1600 = root_new ['parrot';'ResizablePMCArray']
  vivify_1123:
    set $P1601, $P1600[1]
    unless_null $P1601, vivify_1124
    new $P1601, "Undef"
  vivify_1124:
    find_lex $P1602, "$/"
    unless_null $P1602, vivify_1125
    $P1602 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1602
  vivify_1125:
    set $P1602[0], $P1601
    find_lex $P1603, "$t"
    find_lex $P1604, "$/"
    unless_null $P1604, vivify_1126
    $P1604 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1604
  vivify_1126:
    set $P1604[1], $P1603
.annotate 'line', 657
    .return ($P1603)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1605"  :subid("378_1299450589.65") :outer("11_1299450589.65")
.annotate 'line', 663
    .const 'Sub' $P1670 = "399_1299450589.65" 
    capture_lex $P1670
    .const 'Sub' $P1663 = "397_1299450589.65" 
    capture_lex $P1663
    .const 'Sub' $P1658 = "395_1299450589.65" 
    capture_lex $P1658
    .const 'Sub' $P1646 = "392_1299450589.65" 
    capture_lex $P1646
    .const 'Sub' $P1636 = "389_1299450589.65" 
    capture_lex $P1636
    .const 'Sub' $P1631 = "387_1299450589.65" 
    capture_lex $P1631
    .const 'Sub' $P1622 = "384_1299450589.65" 
    capture_lex $P1622
    .const 'Sub' $P1617 = "382_1299450589.65" 
    capture_lex $P1617
    .const 'Sub' $P1608 = "379_1299450589.65" 
    capture_lex $P1608
    get_global $P1607, "$?CLASS"
    .const 'Sub' $P1663 = "397_1299450589.65" 
    capture_lex $P1663
    .return ($P1663)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1127") :outer("378_1299450589.65")
.annotate 'line', 663
    get_hll_global $P1606, ["NQP";"Regex"], "_block1605" 
    .local pmc block
    set block, $P1606
    .const 'Sub' $P1670 = "399_1299450589.65" 
    capture_lex $P1670
    $P1670()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1669"  :anon :subid("399_1299450589.65") :outer("378_1299450589.65")
.annotate 'line', 663
    get_hll_global $P1671, "NQPClassHOW"
    $P1672 = $P1671."new_type"("Regex" :named("name"))
    .local pmc type_obj
    set type_obj, $P1672
    set_hll_global ["NQP"], "Regex", type_obj
    set_global "$?CLASS", type_obj
    get_how $P1673, type_obj
    .const 'Sub' $P1674 = "379_1299450589.65" 
    $P1673."add_method"(type_obj, "metachar:sym<:my>", $P1674)
    get_how $P1675, type_obj
    get_global $P1676, "!PREFIX__metachar:sym<:my>"
    $P1675."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P1676)
    get_how $P1677, type_obj
    .const 'Sub' $P1678 = "382_1299450589.65" 
    $P1677."add_method"(type_obj, "metachar:sym<{ }>", $P1678)
    get_how $P1679, type_obj
    get_global $P1680, "!PREFIX__metachar:sym<{ }>"
    $P1679."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P1680)
    get_how $P1681, type_obj
    .const 'Sub' $P1682 = "384_1299450589.65" 
    $P1681."add_method"(type_obj, "metachar:sym<nqpvar>", $P1682)
    get_how $P1683, type_obj
    get_global $P1684, "!PREFIX__metachar:sym<nqpvar>"
    $P1683."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P1684)
    get_how $P1685, type_obj
    .const 'Sub' $P1686 = "387_1299450589.65" 
    $P1685."add_method"(type_obj, "assertion:sym<{ }>", $P1686)
    get_how $P1687, type_obj
    get_global $P1688, "!PREFIX__assertion:sym<{ }>"
    $P1687."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P1688)
    get_how $P1689, type_obj
    .const 'Sub' $P1690 = "389_1299450589.65" 
    $P1689."add_method"(type_obj, "assertion:sym<?{ }>", $P1690)
    get_how $P1691, type_obj
    get_global $P1692, "!PREFIX__assertion:sym<?{ }>"
    $P1691."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P1692)
    get_how $P1693, type_obj
    .const 'Sub' $P1694 = "392_1299450589.65" 
    $P1693."add_method"(type_obj, "assertion:sym<name>", $P1694)
    get_how $P1695, type_obj
    get_global $P1696, "!PREFIX__assertion:sym<name>"
    $P1695."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P1696)
    get_how $P1697, type_obj
    .const 'Sub' $P1698 = "395_1299450589.65" 
    $P1697."add_method"(type_obj, "assertion:sym<var>", $P1698)
    get_how $P1699, type_obj
    get_global $P1700, "!PREFIX__assertion:sym<var>"
    $P1699."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P1700)
    get_how $P1701, type_obj
    .const 'Sub' $P1702 = "397_1299450589.65" 
    $P1701."add_method"(type_obj, "codeblock", $P1702)
    get_how $P1703, type_obj
    get_global $P1704, "!PREFIX__codeblock"
    $P1703."add_method"(type_obj, "!PREFIX__codeblock", $P1704)
    get_how $P1705, type_obj
    get_hll_global $P1706, ["Regex";"P6Regex"], "Grammar"
    $P1705."add_parent"(type_obj, $P1706)
    get_how $P1707, type_obj
    $P1708 = $P1707."compose"(type_obj)
    .return ($P1708)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("379_1299450589.65") :method :outer("378_1299450589.65")
.annotate 'line', 663
    .const 'Sub' $P1614 = "381_1299450589.65" 
    capture_lex $P1614
    .local string rx1609_tgt
    .local int rx1609_pos
    .local int rx1609_off
    .local int rx1609_eos
    .local int rx1609_rep
    .local pmc rx1609_cur
    .local pmc rx1609_debug
    (rx1609_cur, rx1609_pos, rx1609_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1609_cur
    .local pmc match
    .lex "$/", match
    length rx1609_eos, rx1609_tgt
    gt rx1609_pos, rx1609_eos, rx1609_done
    set rx1609_off, 0
    lt rx1609_pos, 2, rx1609_start
    sub rx1609_off, rx1609_pos, 1
    substr rx1609_tgt, rx1609_tgt, rx1609_off
  rx1609_start:
    eq $I10, 1, rx1609_restart
    if_null rx1609_debug, debug_1128
    rx1609_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1128:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1612_done
    goto rxscan1612_scan
  rxscan1612_loop:
    (rx1609_pos) = rx1609_cur."from"()
    inc rx1609_pos
    rx1609_cur."!cursor_from"(rx1609_pos)
    ge rx1609_pos, rx1609_eos, rxscan1612_done
  rxscan1612_scan:
    set_addr $I10, rxscan1612_loop
    rx1609_cur."!mark_push"(0, rx1609_pos, $I10)
  rxscan1612_done:
.annotate 'line', 665
  # rx literal  ":"
    add $I11, rx1609_pos, 1
    gt $I11, rx1609_eos, rx1609_fail
    sub $I11, rx1609_pos, rx1609_off
    ord $I11, rx1609_tgt, $I11
    ne $I11, 58, rx1609_fail
    add rx1609_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx1609_cur."!cursor_pos"(rx1609_pos)
    .const 'Sub' $P1614 = "381_1299450589.65" 
    capture_lex $P1614
    $P10 = rx1609_cur."before"($P1614)
    unless $P10, rx1609_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1609_cur."!cursor_pos"(rx1609_pos)
    $P10 = rx1609_cur."LANG"("MAIN", "statement")
    unless $P10, rx1609_fail
    rx1609_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1609_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1609_cur."!cursor_pos"(rx1609_pos)
    $P10 = rx1609_cur."ws"()
    unless $P10, rx1609_fail
    rx1609_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx1609_pos, 1
    gt $I11, rx1609_eos, rx1609_fail
    sub $I11, rx1609_pos, rx1609_off
    ord $I11, rx1609_tgt, $I11
    ne $I11, 59, rx1609_fail
    add rx1609_pos, 1
.annotate 'line', 664
  # rx pass
    rx1609_cur."!cursor_pass"(rx1609_pos, "metachar:sym<:my>")
    if_null rx1609_debug, debug_1133
    rx1609_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx1609_pos)
  debug_1133:
    .return (rx1609_cur)
  rx1609_restart:
.annotate 'line', 663
    if_null rx1609_debug, debug_1134
    rx1609_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1134:
  rx1609_fail:
    (rx1609_rep, rx1609_pos, $I10, $P10) = rx1609_cur."!mark_fail"(0)
    lt rx1609_pos, -1, rx1609_done
    eq rx1609_pos, -1, rx1609_fail
    jump $I10
  rx1609_done:
    rx1609_cur."!cursor_fail"()
    if_null rx1609_debug, debug_1135
    rx1609_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1135:
    .return (rx1609_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("380_1299450589.65") :method
.annotate 'line', 663
    new $P1611, "ResizablePMCArray"
    push $P1611, ":"
    .return ($P1611)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1613"  :anon :subid("381_1299450589.65") :method :outer("379_1299450589.65")
.annotate 'line', 665
    .local string rx1615_tgt
    .local int rx1615_pos
    .local int rx1615_off
    .local int rx1615_eos
    .local int rx1615_rep
    .local pmc rx1615_cur
    .local pmc rx1615_debug
    (rx1615_cur, rx1615_pos, rx1615_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1615_cur
    .local pmc match
    .lex "$/", match
    length rx1615_eos, rx1615_tgt
    gt rx1615_pos, rx1615_eos, rx1615_done
    set rx1615_off, 0
    lt rx1615_pos, 2, rx1615_start
    sub rx1615_off, rx1615_pos, 1
    substr rx1615_tgt, rx1615_tgt, rx1615_off
  rx1615_start:
    eq $I10, 1, rx1615_restart
    if_null rx1615_debug, debug_1129
    rx1615_cur."!cursor_debug"("START", "")
  debug_1129:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1616_done
    goto rxscan1616_scan
  rxscan1616_loop:
    (rx1615_pos) = rx1615_cur."from"()
    inc rx1615_pos
    rx1615_cur."!cursor_from"(rx1615_pos)
    ge rx1615_pos, rx1615_eos, rxscan1616_done
  rxscan1616_scan:
    set_addr $I10, rxscan1616_loop
    rx1615_cur."!mark_push"(0, rx1615_pos, $I10)
  rxscan1616_done:
  # rx literal  "my"
    add $I11, rx1615_pos, 2
    gt $I11, rx1615_eos, rx1615_fail
    sub $I11, rx1615_pos, rx1615_off
    substr $S10, rx1615_tgt, $I11, 2
    ne $S10, "my", rx1615_fail
    add rx1615_pos, 2
  # rx pass
    rx1615_cur."!cursor_pass"(rx1615_pos, "")
    if_null rx1615_debug, debug_1130
    rx1615_cur."!cursor_debug"("PASS", "", " at pos=", rx1615_pos)
  debug_1130:
    .return (rx1615_cur)
  rx1615_restart:
    if_null rx1615_debug, debug_1131
    rx1615_cur."!cursor_debug"("NEXT", "")
  debug_1131:
  rx1615_fail:
    (rx1615_rep, rx1615_pos, $I10, $P10) = rx1615_cur."!mark_fail"(0)
    lt rx1615_pos, -1, rx1615_done
    eq rx1615_pos, -1, rx1615_fail
    jump $I10
  rx1615_done:
    rx1615_cur."!cursor_fail"()
    if_null rx1615_debug, debug_1132
    rx1615_cur."!cursor_debug"("FAIL", "")
  debug_1132:
    .return (rx1615_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("382_1299450589.65") :method :outer("378_1299450589.65")
.annotate 'line', 663
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1136
    rx1618_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1136:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1621_done
    goto rxscan1621_scan
  rxscan1621_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1621_done
  rxscan1621_scan:
    set_addr $I10, rxscan1621_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1621_done:
.annotate 'line', 669
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1618_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."codeblock"()
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1618_pos = $P10."pos"()
.annotate 'line', 668
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "metachar:sym<{ }>")
    if_null rx1618_debug, debug_1137
    rx1618_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx1618_pos)
  debug_1137:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 663
    if_null rx1618_debug, debug_1138
    rx1618_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1138:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1139
    rx1618_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1139:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("383_1299450589.65") :method
.annotate 'line', 663
    new $P1620, "ResizablePMCArray"
    push $P1620, "{"
    .return ($P1620)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("384_1299450589.65") :method :outer("378_1299450589.65")
.annotate 'line', 663
    .const 'Sub' $P1628 = "386_1299450589.65" 
    capture_lex $P1628
    .local string rx1623_tgt
    .local int rx1623_pos
    .local int rx1623_off
    .local int rx1623_eos
    .local int rx1623_rep
    .local pmc rx1623_cur
    .local pmc rx1623_debug
    (rx1623_cur, rx1623_pos, rx1623_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1623_cur
    .local pmc match
    .lex "$/", match
    length rx1623_eos, rx1623_tgt
    gt rx1623_pos, rx1623_eos, rx1623_done
    set rx1623_off, 0
    lt rx1623_pos, 2, rx1623_start
    sub rx1623_off, rx1623_pos, 1
    substr rx1623_tgt, rx1623_tgt, rx1623_off
  rx1623_start:
    eq $I10, 1, rx1623_restart
    if_null rx1623_debug, debug_1140
    rx1623_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1140:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1626_done
    goto rxscan1626_scan
  rxscan1626_loop:
    (rx1623_pos) = rx1623_cur."from"()
    inc rx1623_pos
    rx1623_cur."!cursor_from"(rx1623_pos)
    ge rx1623_pos, rx1623_eos, rxscan1626_done
  rxscan1626_scan:
    set_addr $I10, rxscan1626_loop
    rx1623_cur."!mark_push"(0, rx1623_pos, $I10)
  rxscan1626_done:
.annotate 'line', 673
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1623_pos, rx1623_off
    substr $S10, rx1623_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1623_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    .const 'Sub' $P1628 = "386_1299450589.65" 
    capture_lex $P1628
    $P10 = rx1623_cur."before"($P1628)
    unless $P10, rx1623_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1623_cur."!cursor_pos"(rx1623_pos)
    $P10 = rx1623_cur."LANG"("MAIN", "variable")
    unless $P10, rx1623_fail
    rx1623_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1623_pos = $P10."pos"()
.annotate 'line', 672
  # rx pass
    rx1623_cur."!cursor_pass"(rx1623_pos, "metachar:sym<nqpvar>")
    if_null rx1623_debug, debug_1145
    rx1623_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx1623_pos)
  debug_1145:
    .return (rx1623_cur)
  rx1623_restart:
.annotate 'line', 663
    if_null rx1623_debug, debug_1146
    rx1623_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1146:
  rx1623_fail:
    (rx1623_rep, rx1623_pos, $I10, $P10) = rx1623_cur."!mark_fail"(0)
    lt rx1623_pos, -1, rx1623_done
    eq rx1623_pos, -1, rx1623_fail
    jump $I10
  rx1623_done:
    rx1623_cur."!cursor_fail"()
    if_null rx1623_debug, debug_1147
    rx1623_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1147:
    .return (rx1623_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("385_1299450589.65") :method
.annotate 'line', 663
    new $P1625, "ResizablePMCArray"
    push $P1625, "$"
    push $P1625, "@"
    .return ($P1625)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1627"  :anon :subid("386_1299450589.65") :method :outer("384_1299450589.65")
.annotate 'line', 673
    .local string rx1629_tgt
    .local int rx1629_pos
    .local int rx1629_off
    .local int rx1629_eos
    .local int rx1629_rep
    .local pmc rx1629_cur
    .local pmc rx1629_debug
    (rx1629_cur, rx1629_pos, rx1629_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1629_cur
    .local pmc match
    .lex "$/", match
    length rx1629_eos, rx1629_tgt
    gt rx1629_pos, rx1629_eos, rx1629_done
    set rx1629_off, 0
    lt rx1629_pos, 2, rx1629_start
    sub rx1629_off, rx1629_pos, 1
    substr rx1629_tgt, rx1629_tgt, rx1629_off
  rx1629_start:
    eq $I10, 1, rx1629_restart
    if_null rx1629_debug, debug_1141
    rx1629_cur."!cursor_debug"("START", "")
  debug_1141:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1630_done
    goto rxscan1630_scan
  rxscan1630_loop:
    (rx1629_pos) = rx1629_cur."from"()
    inc rx1629_pos
    rx1629_cur."!cursor_from"(rx1629_pos)
    ge rx1629_pos, rx1629_eos, rxscan1630_done
  rxscan1630_scan:
    set_addr $I10, rxscan1630_loop
    rx1629_cur."!mark_push"(0, rx1629_pos, $I10)
  rxscan1630_done:
  # rx charclass .
    ge rx1629_pos, rx1629_eos, rx1629_fail
    inc rx1629_pos
  # rx charclass w
    ge rx1629_pos, rx1629_eos, rx1629_fail
    sub $I10, rx1629_pos, rx1629_off
    is_cclass $I11, 8192, rx1629_tgt, $I10
    unless $I11, rx1629_fail
    inc rx1629_pos
  # rx pass
    rx1629_cur."!cursor_pass"(rx1629_pos, "")
    if_null rx1629_debug, debug_1142
    rx1629_cur."!cursor_debug"("PASS", "", " at pos=", rx1629_pos)
  debug_1142:
    .return (rx1629_cur)
  rx1629_restart:
    if_null rx1629_debug, debug_1143
    rx1629_cur."!cursor_debug"("NEXT", "")
  debug_1143:
  rx1629_fail:
    (rx1629_rep, rx1629_pos, $I10, $P10) = rx1629_cur."!mark_fail"(0)
    lt rx1629_pos, -1, rx1629_done
    eq rx1629_pos, -1, rx1629_fail
    jump $I10
  rx1629_done:
    rx1629_cur."!cursor_fail"()
    if_null rx1629_debug, debug_1144
    rx1629_cur."!cursor_debug"("FAIL", "")
  debug_1144:
    .return (rx1629_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("387_1299450589.65") :method :outer("378_1299450589.65")
.annotate 'line', 663
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1148
    rx1632_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1148:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1635_done
    goto rxscan1635_scan
  rxscan1635_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1635_done
  rxscan1635_scan:
    set_addr $I10, rxscan1635_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1635_done:
.annotate 'line', 677
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1632_pos, rx1632_off
    substr $S10, rx1632_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1632_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."codeblock"()
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1632_pos = $P10."pos"()
.annotate 'line', 676
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "assertion:sym<{ }>")
    if_null rx1632_debug, debug_1149
    rx1632_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx1632_pos)
  debug_1149:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 663
    if_null rx1632_debug, debug_1150
    rx1632_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1150:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1151
    rx1632_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1151:
    .return (rx1632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("388_1299450589.65") :method
.annotate 'line', 663
    new $P1634, "ResizablePMCArray"
    push $P1634, "{"
    .return ($P1634)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("389_1299450589.65") :method :outer("378_1299450589.65")
.annotate 'line', 663
    .const 'Sub' $P1642 = "391_1299450589.65" 
    capture_lex $P1642
    .local string rx1637_tgt
    .local int rx1637_pos
    .local int rx1637_off
    .local int rx1637_eos
    .local int rx1637_rep
    .local pmc rx1637_cur
    .local pmc rx1637_debug
    (rx1637_cur, rx1637_pos, rx1637_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1637_cur
    .local pmc match
    .lex "$/", match
    length rx1637_eos, rx1637_tgt
    gt rx1637_pos, rx1637_eos, rx1637_done
    set rx1637_off, 0
    lt rx1637_pos, 2, rx1637_start
    sub rx1637_off, rx1637_pos, 1
    substr rx1637_tgt, rx1637_tgt, rx1637_off
  rx1637_start:
    eq $I10, 1, rx1637_restart
    if_null rx1637_debug, debug_1152
    rx1637_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1152:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1640_done
    goto rxscan1640_scan
  rxscan1640_loop:
    (rx1637_pos) = rx1637_cur."from"()
    inc rx1637_pos
    rx1637_cur."!cursor_from"(rx1637_pos)
    ge rx1637_pos, rx1637_eos, rxscan1640_done
  rxscan1640_scan:
    set_addr $I10, rxscan1640_loop
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  rxscan1640_done:
.annotate 'line', 681
  # rx subcapture "zw"
    set_addr $I10, rxcap_1645_fail
    rx1637_cur."!mark_push"(0, rx1637_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx1637_pos, rx1637_eos, rx1637_fail
    sub $I10, rx1637_pos, rx1637_off
    substr $S10, rx1637_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx1637_fail
    inc rx1637_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx1637_cur."!cursor_pos"(rx1637_pos)
    .const 'Sub' $P1642 = "391_1299450589.65" 
    capture_lex $P1642
    $P10 = rx1637_cur."before"($P1642)
    unless $P10, rx1637_fail
    set_addr $I10, rxcap_1645_fail
    ($I12, $I11) = rx1637_cur."!mark_peek"($I10)
    rx1637_cur."!cursor_pos"($I11)
    ($P10) = rx1637_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1637_pos, "")
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_1645_done
  rxcap_1645_fail:
    goto rx1637_fail
  rxcap_1645_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx1637_cur."!cursor_pos"(rx1637_pos)
    $P10 = rx1637_cur."codeblock"()
    unless $P10, rx1637_fail
    rx1637_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx1637_pos = $P10."pos"()
.annotate 'line', 680
  # rx pass
    rx1637_cur."!cursor_pass"(rx1637_pos, "assertion:sym<?{ }>")
    if_null rx1637_debug, debug_1157
    rx1637_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx1637_pos)
  debug_1157:
    .return (rx1637_cur)
  rx1637_restart:
.annotate 'line', 663
    if_null rx1637_debug, debug_1158
    rx1637_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1158:
  rx1637_fail:
    (rx1637_rep, rx1637_pos, $I10, $P10) = rx1637_cur."!mark_fail"(0)
    lt rx1637_pos, -1, rx1637_done
    eq rx1637_pos, -1, rx1637_fail
    jump $I10
  rx1637_done:
    rx1637_cur."!cursor_fail"()
    if_null rx1637_debug, debug_1159
    rx1637_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1159:
    .return (rx1637_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("390_1299450589.65") :method
.annotate 'line', 663
    new $P1639, "ResizablePMCArray"
    push $P1639, "!"
    push $P1639, "?"
    .return ($P1639)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1641"  :anon :subid("391_1299450589.65") :method :outer("389_1299450589.65")
.annotate 'line', 681
    .local string rx1643_tgt
    .local int rx1643_pos
    .local int rx1643_off
    .local int rx1643_eos
    .local int rx1643_rep
    .local pmc rx1643_cur
    .local pmc rx1643_debug
    (rx1643_cur, rx1643_pos, rx1643_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1643_cur
    .local pmc match
    .lex "$/", match
    length rx1643_eos, rx1643_tgt
    gt rx1643_pos, rx1643_eos, rx1643_done
    set rx1643_off, 0
    lt rx1643_pos, 2, rx1643_start
    sub rx1643_off, rx1643_pos, 1
    substr rx1643_tgt, rx1643_tgt, rx1643_off
  rx1643_start:
    eq $I10, 1, rx1643_restart
    if_null rx1643_debug, debug_1153
    rx1643_cur."!cursor_debug"("START", "")
  debug_1153:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1644_done
    goto rxscan1644_scan
  rxscan1644_loop:
    (rx1643_pos) = rx1643_cur."from"()
    inc rx1643_pos
    rx1643_cur."!cursor_from"(rx1643_pos)
    ge rx1643_pos, rx1643_eos, rxscan1644_done
  rxscan1644_scan:
    set_addr $I10, rxscan1644_loop
    rx1643_cur."!mark_push"(0, rx1643_pos, $I10)
  rxscan1644_done:
  # rx literal  "{"
    add $I11, rx1643_pos, 1
    gt $I11, rx1643_eos, rx1643_fail
    sub $I11, rx1643_pos, rx1643_off
    ord $I11, rx1643_tgt, $I11
    ne $I11, 123, rx1643_fail
    add rx1643_pos, 1
  # rx pass
    rx1643_cur."!cursor_pass"(rx1643_pos, "")
    if_null rx1643_debug, debug_1154
    rx1643_cur."!cursor_debug"("PASS", "", " at pos=", rx1643_pos)
  debug_1154:
    .return (rx1643_cur)
  rx1643_restart:
    if_null rx1643_debug, debug_1155
    rx1643_cur."!cursor_debug"("NEXT", "")
  debug_1155:
  rx1643_fail:
    (rx1643_rep, rx1643_pos, $I10, $P10) = rx1643_cur."!mark_fail"(0)
    lt rx1643_pos, -1, rx1643_done
    eq rx1643_pos, -1, rx1643_fail
    jump $I10
  rx1643_done:
    rx1643_cur."!cursor_fail"()
    if_null rx1643_debug, debug_1156
    rx1643_cur."!cursor_debug"("FAIL", "")
  debug_1156:
    .return (rx1643_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("392_1299450589.65") :method :outer("378_1299450589.65")
.annotate 'line', 663
    .const 'Sub' $P1655 = "394_1299450589.65" 
    capture_lex $P1655
    .local string rx1647_tgt
    .local int rx1647_pos
    .local int rx1647_off
    .local int rx1647_eos
    .local int rx1647_rep
    .local pmc rx1647_cur
    .local pmc rx1647_debug
    (rx1647_cur, rx1647_pos, rx1647_tgt, $I10) = self."!cursor_start"()
    rx1647_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx1647_cur
    .local pmc match
    .lex "$/", match
    length rx1647_eos, rx1647_tgt
    gt rx1647_pos, rx1647_eos, rx1647_done
    set rx1647_off, 0
    lt rx1647_pos, 2, rx1647_start
    sub rx1647_off, rx1647_pos, 1
    substr rx1647_tgt, rx1647_tgt, rx1647_off
  rx1647_start:
    eq $I10, 1, rx1647_restart
    if_null rx1647_debug, debug_1160
    rx1647_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1160:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1651_done
    goto rxscan1651_scan
  rxscan1651_loop:
    (rx1647_pos) = rx1647_cur."from"()
    inc rx1647_pos
    rx1647_cur."!cursor_from"(rx1647_pos)
    ge rx1647_pos, rx1647_eos, rxscan1651_done
  rxscan1651_scan:
    set_addr $I10, rxscan1651_loop
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxscan1651_done:
.annotate 'line', 685
  # rx subrule "identifier" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."identifier"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1647_pos = $P10."pos"()
.annotate 'line', 692
  # rx rxquantr1652 ** 0..1
    set_addr $I10, rxquantr1652_done
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
  rxquantr1652_loop:
  alt1653_0:
.annotate 'line', 686
    set_addr $I10, alt1653_1
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
.annotate 'line', 687
  # rx subrule "before" subtype=zerowidth negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    .const 'Sub' $P1655 = "394_1299450589.65" 
    capture_lex $P1655
    $P10 = rx1647_cur."before"($P1655)
    unless $P10, rx1647_fail
    goto alt1653_end
  alt1653_1:
    set_addr $I10, alt1653_2
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
.annotate 'line', 688
  # rx literal  "="
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 61, rx1647_fail
    add rx1647_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."assertion"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx1647_pos = $P10."pos"()
    goto alt1653_end
  alt1653_2:
    set_addr $I10, alt1653_3
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
.annotate 'line', 689
  # rx literal  ":"
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 58, rx1647_fail
    add rx1647_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."arglist"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1647_pos = $P10."pos"()
    goto alt1653_end
  alt1653_3:
    set_addr $I10, alt1653_4
    rx1647_cur."!mark_push"(0, rx1647_pos, $I10)
.annotate 'line', 690
  # rx literal  "("
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 40, rx1647_fail
    add rx1647_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."LANG"("MAIN", "arglist")
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1647_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1647_pos, 1
    gt $I11, rx1647_eos, rx1647_fail
    sub $I11, rx1647_pos, rx1647_off
    ord $I11, rx1647_tgt, $I11
    ne $I11, 41, rx1647_fail
    add rx1647_pos, 1
    goto alt1653_end
  alt1653_4:
.annotate 'line', 691
  # rx subrule "normspace" subtype=method negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."normspace"()
    unless $P10, rx1647_fail
    rx1647_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx1647_cur."!cursor_pos"(rx1647_pos)
    $P10 = rx1647_cur."nibbler"()
    unless $P10, rx1647_fail
    rx1647_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx1647_pos = $P10."pos"()
  alt1653_end:
.annotate 'line', 692
    set_addr $I10, rxquantr1652_done
    (rx1647_rep) = rx1647_cur."!mark_commit"($I10)
  rxquantr1652_done:
.annotate 'line', 684
  # rx pass
    rx1647_cur."!cursor_pass"(rx1647_pos, "assertion:sym<name>")
    if_null rx1647_debug, debug_1165
    rx1647_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx1647_pos)
  debug_1165:
    .return (rx1647_cur)
  rx1647_restart:
.annotate 'line', 663
    if_null rx1647_debug, debug_1166
    rx1647_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1166:
  rx1647_fail:
    (rx1647_rep, rx1647_pos, $I10, $P10) = rx1647_cur."!mark_fail"(0)
    lt rx1647_pos, -1, rx1647_done
    eq rx1647_pos, -1, rx1647_fail
    jump $I10
  rx1647_done:
    rx1647_cur."!cursor_fail"()
    if_null rx1647_debug, debug_1167
    rx1647_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1167:
    .return (rx1647_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("393_1299450589.65") :method
.annotate 'line', 663
    $P1649 = self."!PREFIX__!subrule"("identifier", "")
    new $P1650, "ResizablePMCArray"
    push $P1650, $P1649
    .return ($P1650)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block1654"  :anon :subid("394_1299450589.65") :method :outer("392_1299450589.65")
.annotate 'line', 687
    .local string rx1656_tgt
    .local int rx1656_pos
    .local int rx1656_off
    .local int rx1656_eos
    .local int rx1656_rep
    .local pmc rx1656_cur
    .local pmc rx1656_debug
    (rx1656_cur, rx1656_pos, rx1656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1656_cur
    .local pmc match
    .lex "$/", match
    length rx1656_eos, rx1656_tgt
    gt rx1656_pos, rx1656_eos, rx1656_done
    set rx1656_off, 0
    lt rx1656_pos, 2, rx1656_start
    sub rx1656_off, rx1656_pos, 1
    substr rx1656_tgt, rx1656_tgt, rx1656_off
  rx1656_start:
    eq $I10, 1, rx1656_restart
    if_null rx1656_debug, debug_1161
    rx1656_cur."!cursor_debug"("START", "")
  debug_1161:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1657_done
    goto rxscan1657_scan
  rxscan1657_loop:
    (rx1656_pos) = rx1656_cur."from"()
    inc rx1656_pos
    rx1656_cur."!cursor_from"(rx1656_pos)
    ge rx1656_pos, rx1656_eos, rxscan1657_done
  rxscan1657_scan:
    set_addr $I10, rxscan1657_loop
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  rxscan1657_done:
  # rx literal  ">"
    add $I11, rx1656_pos, 1
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    ord $I11, rx1656_tgt, $I11
    ne $I11, 62, rx1656_fail
    add rx1656_pos, 1
  # rx pass
    rx1656_cur."!cursor_pass"(rx1656_pos, "")
    if_null rx1656_debug, debug_1162
    rx1656_cur."!cursor_debug"("PASS", "", " at pos=", rx1656_pos)
  debug_1162:
    .return (rx1656_cur)
  rx1656_restart:
    if_null rx1656_debug, debug_1163
    rx1656_cur."!cursor_debug"("NEXT", "")
  debug_1163:
  rx1656_fail:
    (rx1656_rep, rx1656_pos, $I10, $P10) = rx1656_cur."!mark_fail"(0)
    lt rx1656_pos, -1, rx1656_done
    eq rx1656_pos, -1, rx1656_fail
    jump $I10
  rx1656_done:
    rx1656_cur."!cursor_fail"()
    if_null rx1656_debug, debug_1164
    rx1656_cur."!cursor_debug"("FAIL", "")
  debug_1164:
    .return (rx1656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("395_1299450589.65") :method :outer("378_1299450589.65")
.annotate 'line', 663
    .local string rx1659_tgt
    .local int rx1659_pos
    .local int rx1659_off
    .local int rx1659_eos
    .local int rx1659_rep
    .local pmc rx1659_cur
    .local pmc rx1659_debug
    (rx1659_cur, rx1659_pos, rx1659_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1659_cur
    .local pmc match
    .lex "$/", match
    length rx1659_eos, rx1659_tgt
    gt rx1659_pos, rx1659_eos, rx1659_done
    set rx1659_off, 0
    lt rx1659_pos, 2, rx1659_start
    sub rx1659_off, rx1659_pos, 1
    substr rx1659_tgt, rx1659_tgt, rx1659_off
  rx1659_start:
    eq $I10, 1, rx1659_restart
    if_null rx1659_debug, debug_1168
    rx1659_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1168:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1662_done
    goto rxscan1662_scan
  rxscan1662_loop:
    (rx1659_pos) = rx1659_cur."from"()
    inc rx1659_pos
    rx1659_cur."!cursor_from"(rx1659_pos)
    ge rx1659_pos, rx1659_eos, rxscan1662_done
  rxscan1662_scan:
    set_addr $I10, rxscan1662_loop
    rx1659_cur."!mark_push"(0, rx1659_pos, $I10)
  rxscan1662_done:
.annotate 'line', 696
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1659_pos, rx1659_off
    substr $S10, rx1659_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx1659_fail
  # rx subrule "LANG" subtype=capture negate=
    rx1659_cur."!cursor_pos"(rx1659_pos)
    $P10 = rx1659_cur."LANG"("MAIN", "variable")
    unless $P10, rx1659_fail
    rx1659_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx1659_pos = $P10."pos"()
.annotate 'line', 695
  # rx pass
    rx1659_cur."!cursor_pass"(rx1659_pos, "assertion:sym<var>")
    if_null rx1659_debug, debug_1169
    rx1659_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx1659_pos)
  debug_1169:
    .return (rx1659_cur)
  rx1659_restart:
.annotate 'line', 663
    if_null rx1659_debug, debug_1170
    rx1659_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1170:
  rx1659_fail:
    (rx1659_rep, rx1659_pos, $I10, $P10) = rx1659_cur."!mark_fail"(0)
    lt rx1659_pos, -1, rx1659_done
    eq rx1659_pos, -1, rx1659_fail
    jump $I10
  rx1659_done:
    rx1659_cur."!cursor_fail"()
    if_null rx1659_debug, debug_1171
    rx1659_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1171:
    .return (rx1659_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("396_1299450589.65") :method
.annotate 'line', 663
    new $P1661, "ResizablePMCArray"
    push $P1661, "$"
    push $P1661, "@"
    .return ($P1661)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("397_1299450589.65") :method :outer("378_1299450589.65")
.annotate 'line', 663
    .local string rx1664_tgt
    .local int rx1664_pos
    .local int rx1664_off
    .local int rx1664_eos
    .local int rx1664_rep
    .local pmc rx1664_cur
    .local pmc rx1664_debug
    (rx1664_cur, rx1664_pos, rx1664_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1664_cur
    .local pmc match
    .lex "$/", match
    length rx1664_eos, rx1664_tgt
    gt rx1664_pos, rx1664_eos, rx1664_done
    set rx1664_off, 0
    lt rx1664_pos, 2, rx1664_start
    sub rx1664_off, rx1664_pos, 1
    substr rx1664_tgt, rx1664_tgt, rx1664_off
  rx1664_start:
    eq $I10, 1, rx1664_restart
    if_null rx1664_debug, debug_1172
    rx1664_cur."!cursor_debug"("START", "codeblock")
  debug_1172:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1668_done
    goto rxscan1668_scan
  rxscan1668_loop:
    (rx1664_pos) = rx1664_cur."from"()
    inc rx1664_pos
    rx1664_cur."!cursor_from"(rx1664_pos)
    ge rx1664_pos, rx1664_eos, rxscan1668_done
  rxscan1668_scan:
    set_addr $I10, rxscan1668_loop
    rx1664_cur."!mark_push"(0, rx1664_pos, $I10)
  rxscan1668_done:
.annotate 'line', 700
  # rx subrule "LANG" subtype=capture negate=
    rx1664_cur."!cursor_pos"(rx1664_pos)
    $P10 = rx1664_cur."LANG"("MAIN", "pblock")
    unless $P10, rx1664_fail
    rx1664_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1664_pos = $P10."pos"()
.annotate 'line', 699
  # rx pass
    rx1664_cur."!cursor_pass"(rx1664_pos, "codeblock")
    if_null rx1664_debug, debug_1173
    rx1664_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx1664_pos)
  debug_1173:
    .return (rx1664_cur)
  rx1664_restart:
.annotate 'line', 663
    if_null rx1664_debug, debug_1174
    rx1664_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1174:
  rx1664_fail:
    (rx1664_rep, rx1664_pos, $I10, $P10) = rx1664_cur."!mark_fail"(0)
    lt rx1664_pos, -1, rx1664_done
    eq rx1664_pos, -1, rx1664_fail
    jump $I10
  rx1664_done:
    rx1664_cur."!cursor_fail"()
    if_null rx1664_debug, debug_1175
    rx1664_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1175:
    .return (rx1664_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("398_1299450589.65") :method
.annotate 'line', 663
    $P1666 = self."!PREFIX__!subrule"("LANG", "")
    new $P1667, "ResizablePMCArray"
    push $P1667, $P1666
    .return ($P1667)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1710" :load :anon :subid("400_1299450589.65")
.annotate 'line', 4
    .const 'Sub' $P1712 = "11_1299450589.65" 
    $P1713 = $P1712()
    .return ($P1713)
.end


.HLL "nqp"

.namespace []
.sub "_block2431" :load :anon :subid("402_1299450589.65")
.annotate 'line', 1
    .const 'Sub' $P2433 = "10_1299450589.65" 
    $P2434 = $P2433()
    .return ($P2434)
.end

### .include 'gen/nqp-actions.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299450604.787")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Actions"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    capture_lex $P15
    $P3270 = $P15()
.annotate 'line', 1
    .return ($P3270)
    .const 'Sub' $P3272 = "171_1299450604.787" 
    .return ($P3272)
.end


.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace ["NQP";"Actions"]
.sub "_block14"  :subid("11_1299450604.787") :outer("10_1299450604.787")
.annotate 'line', 3
    .const 'Sub' $P3049 = "170_1299450604.787" 
    capture_lex $P3049
    get_hll_global $P2923, ["NQP";"RegexActions"], "_block2922" 
    capture_lex $P2923
    .const 'Sub' $P2914 = "159_1299450604.787" 
    capture_lex $P2914
    .const 'Sub' $P2909 = "158_1299450604.787" 
    capture_lex $P2909
    .const 'Sub' $P2904 = "157_1299450604.787" 
    capture_lex $P2904
    .const 'Sub' $P2899 = "156_1299450604.787" 
    capture_lex $P2899
    .const 'Sub' $P2888 = "155_1299450604.787" 
    capture_lex $P2888
    .const 'Sub' $P2880 = "154_1299450604.787" 
    capture_lex $P2880
    .const 'Sub' $P2872 = "153_1299450604.787" 
    capture_lex $P2872
    .const 'Sub' $P2864 = "152_1299450604.787" 
    capture_lex $P2864
    .const 'Sub' $P2859 = "151_1299450604.787" 
    capture_lex $P2859
    .const 'Sub' $P2847 = "150_1299450604.787" 
    capture_lex $P2847
    .const 'Sub' $P2839 = "149_1299450604.787" 
    capture_lex $P2839
    .const 'Sub' $P2801 = "148_1299450604.787" 
    capture_lex $P2801
    .const 'Sub' $P2789 = "147_1299450604.787" 
    capture_lex $P2789
    .const 'Sub' $P2781 = "146_1299450604.787" 
    capture_lex $P2781
    .const 'Sub' $P2773 = "145_1299450604.787" 
    capture_lex $P2773
    .const 'Sub' $P2765 = "144_1299450604.787" 
    capture_lex $P2765
    .const 'Sub' $P2757 = "143_1299450604.787" 
    capture_lex $P2757
    .const 'Sub' $P2749 = "142_1299450604.787" 
    capture_lex $P2749
    .const 'Sub' $P2723 = "141_1299450604.787" 
    capture_lex $P2723
    .const 'Sub' $P2708 = "140_1299450604.787" 
    capture_lex $P2708
    .const 'Sub' $P2700 = "139_1299450604.787" 
    capture_lex $P2700
    .const 'Sub' $P2689 = "138_1299450604.787" 
    capture_lex $P2689
    .const 'Sub' $P2678 = "137_1299450604.787" 
    capture_lex $P2678
    .const 'Sub' $P2667 = "136_1299450604.787" 
    capture_lex $P2667
    .const 'Sub' $P2659 = "135_1299450604.787" 
    capture_lex $P2659
    .const 'Sub' $P2632 = "134_1299450604.787" 
    capture_lex $P2632
    .const 'Sub' $P2594 = "132_1299450604.787" 
    capture_lex $P2594
    .const 'Sub' $P2586 = "131_1299450604.787" 
    capture_lex $P2586
    .const 'Sub' $P2578 = "130_1299450604.787" 
    capture_lex $P2578
    .const 'Sub' $P2553 = "129_1299450604.787" 
    capture_lex $P2553
    .const 'Sub' $P2537 = "128_1299450604.787" 
    capture_lex $P2537
    .const 'Sub' $P2529 = "127_1299450604.787" 
    capture_lex $P2529
    .const 'Sub' $P2521 = "126_1299450604.787" 
    capture_lex $P2521
    .const 'Sub' $P2419 = "123_1299450604.787" 
    capture_lex $P2419
    .const 'Sub' $P2411 = "122_1299450604.787" 
    capture_lex $P2411
    .const 'Sub' $P2404 = "121_1299450604.787" 
    capture_lex $P2404
    .const 'Sub' $P2377 = "120_1299450604.787" 
    capture_lex $P2377
    .const 'Sub' $P2337 = "119_1299450604.787" 
    capture_lex $P2337
    .const 'Sub' $P2323 = "118_1299450604.787" 
    capture_lex $P2323
    .const 'Sub' $P2316 = "117_1299450604.787" 
    capture_lex $P2316
    .const 'Sub' $P2272 = "116_1299450604.787" 
    capture_lex $P2272
    .const 'Sub' $P2107 = "112_1299450604.787" 
    capture_lex $P2107
    .const 'Sub' $P2044 = "110_1299450604.787" 
    capture_lex $P2044
    .const 'Sub' $P2036 = "109_1299450604.787" 
    capture_lex $P2036
    .const 'Sub' $P2021 = "108_1299450604.787" 
    capture_lex $P2021
    .const 'Sub' $P2006 = "107_1299450604.787" 
    capture_lex $P2006
    .const 'Sub' $P1988 = "106_1299450604.787" 
    capture_lex $P1988
    .const 'Sub' $P1889 = "105_1299450604.787" 
    capture_lex $P1889
    .const 'Sub' $P1845 = "102_1299450604.787" 
    capture_lex $P1845
    .const 'Sub' $P1720 = "99_1299450604.787" 
    capture_lex $P1720
    .const 'Sub' $P1478 = "92_1299450604.787" 
    capture_lex $P1478
    .const 'Sub' $P1470 = "91_1299450604.787" 
    capture_lex $P1470
    .const 'Sub' $P1462 = "90_1299450604.787" 
    capture_lex $P1462
    .const 'Sub' $P1361 = "86_1299450604.787" 
    capture_lex $P1361
    .const 'Sub' $P1353 = "85_1299450604.787" 
    capture_lex $P1353
    .const 'Sub' $P1338 = "84_1299450604.787" 
    capture_lex $P1338
    .const 'Sub' $P1323 = "83_1299450604.787" 
    capture_lex $P1323
    .const 'Sub' $P1308 = "82_1299450604.787" 
    capture_lex $P1308
    .const 'Sub' $P1293 = "81_1299450604.787" 
    capture_lex $P1293
    .const 'Sub' $P1285 = "80_1299450604.787" 
    capture_lex $P1285
    .const 'Sub' $P1277 = "79_1299450604.787" 
    capture_lex $P1277
    .const 'Sub' $P1269 = "78_1299450604.787" 
    capture_lex $P1269
    .const 'Sub' $P1055 = "74_1299450604.787" 
    capture_lex $P1055
    .const 'Sub' $P1047 = "73_1299450604.787" 
    capture_lex $P1047
    .const 'Sub' $P1039 = "72_1299450604.787" 
    capture_lex $P1039
    .const 'Sub' $P1031 = "71_1299450604.787" 
    capture_lex $P1031
    .const 'Sub' $P1023 = "70_1299450604.787" 
    capture_lex $P1023
    .const 'Sub' $P1015 = "69_1299450604.787" 
    capture_lex $P1015
    .const 'Sub' $P1007 = "68_1299450604.787" 
    capture_lex $P1007
    .const 'Sub' $P917 = "66_1299450604.787" 
    capture_lex $P917
    .const 'Sub' $P893 = "65_1299450604.787" 
    capture_lex $P893
    .const 'Sub' $P879 = "64_1299450604.787" 
    capture_lex $P879
    .const 'Sub' $P871 = "63_1299450604.787" 
    capture_lex $P871
    .const 'Sub' $P863 = "62_1299450604.787" 
    capture_lex $P863
    .const 'Sub' $P855 = "61_1299450604.787" 
    capture_lex $P855
    .const 'Sub' $P847 = "60_1299450604.787" 
    capture_lex $P847
    .const 'Sub' $P839 = "59_1299450604.787" 
    capture_lex $P839
    .const 'Sub' $P831 = "58_1299450604.787" 
    capture_lex $P831
    .const 'Sub' $P823 = "57_1299450604.787" 
    capture_lex $P823
    .const 'Sub' $P815 = "56_1299450604.787" 
    capture_lex $P815
    .const 'Sub' $P807 = "55_1299450604.787" 
    capture_lex $P807
    .const 'Sub' $P799 = "54_1299450604.787" 
    capture_lex $P799
    .const 'Sub' $P791 = "53_1299450604.787" 
    capture_lex $P791
    .const 'Sub' $P783 = "52_1299450604.787" 
    capture_lex $P783
    .const 'Sub' $P775 = "51_1299450604.787" 
    capture_lex $P775
    .const 'Sub' $P759 = "50_1299450604.787" 
    capture_lex $P759
    .const 'Sub' $P726 = "49_1299450604.787" 
    capture_lex $P726
    .const 'Sub' $P712 = "48_1299450604.787" 
    capture_lex $P712
    .const 'Sub' $P693 = "47_1299450604.787" 
    capture_lex $P693
    .const 'Sub' $P675 = "46_1299450604.787" 
    capture_lex $P675
    .const 'Sub' $P651 = "45_1299450604.787" 
    capture_lex $P651
    .const 'Sub' $P617 = "44_1299450604.787" 
    capture_lex $P617
    .const 'Sub' $P602 = "43_1299450604.787" 
    capture_lex $P602
    .const 'Sub' $P590 = "42_1299450604.787" 
    capture_lex $P590
    .const 'Sub' $P539 = "40_1299450604.787" 
    capture_lex $P539
    .const 'Sub' $P532 = "39_1299450604.787" 
    capture_lex $P532
    .const 'Sub' $P510 = "38_1299450604.787" 
    capture_lex $P510
    .const 'Sub' $P499 = "37_1299450604.787" 
    capture_lex $P499
    .const 'Sub' $P464 = "35_1299450604.787" 
    capture_lex $P464
    .const 'Sub' $P456 = "34_1299450604.787" 
    capture_lex $P456
    .const 'Sub' $P448 = "33_1299450604.787" 
    capture_lex $P448
    .const 'Sub' $P434 = "32_1299450604.787" 
    capture_lex $P434
    .const 'Sub' $P353 = "30_1299450604.787" 
    capture_lex $P353
    .const 'Sub' $P312 = "28_1299450604.787" 
    capture_lex $P312
    .const 'Sub' $P275 = "27_1299450604.787" 
    capture_lex $P275
    .const 'Sub' $P244 = "26_1299450604.787" 
    capture_lex $P244
    .const 'Sub' $P236 = "25_1299450604.787" 
    capture_lex $P236
    .const 'Sub' $P228 = "23_1299450604.787" 
    capture_lex $P228
    .const 'Sub' $P214 = "22_1299450604.787" 
    capture_lex $P214
    .const 'Sub' $P149 = "20_1299450604.787" 
    capture_lex $P149
    .const 'Sub' $P139 = "19_1299450604.787" 
    capture_lex $P139
    .const 'Sub' $P91 = "18_1299450604.787" 
    capture_lex $P91
    .const 'Sub' $P78 = "17_1299450604.787" 
    capture_lex $P78
    .const 'Sub' $P60 = "16_1299450604.787" 
    capture_lex $P60
    .const 'Sub' $P27 = "13_1299450604.787" 
    capture_lex $P27
    .const 'Sub' $P19 = "12_1299450604.787" 
    capture_lex $P19
    get_global $P16, "$?CLASS"
    nqp_dynop_setup 
    get_hll_global $P17, ["NQP"], "RegexActions"
    get_global $P18, "@BLOCK"
    unless_null $P18, vivify_173
    $P18 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P18
  vivify_173:
.annotate 'line', 9
    .const 'Sub' $P19 = "12_1299450604.787" 
    newclosure $P26, $P19
    .lex "xblock_immediate", $P26
.annotate 'line', 14
    .const 'Sub' $P27 = "13_1299450604.787" 
    newclosure $P59, $P27
    .lex "block_immediate", $P59
.annotate 'line', 24
    .const 'Sub' $P60 = "16_1299450604.787" 
    newclosure $P77, $P60
    .lex "vivitype", $P77
.annotate 'line', 43
    .const 'Sub' $P78 = "17_1299450604.787" 
    newclosure $P90, $P78
    .lex "colonpair_str", $P90
.annotate 'line', 248
    .const 'Sub' $P91 = "18_1299450604.787" 
    newclosure $P138, $P91
    .lex "push_block_handler", $P138
.annotate 'line', 787
    .const 'Sub' $P139 = "19_1299450604.787" 
    newclosure $P148, $P139
    .lex "only_star_block", $P148
.annotate 'line', 796
    .const 'Sub' $P149 = "20_1299450604.787" 
    newclosure $P213, $P149
    .lex "attach_multi_signature", $P213
.annotate 'line', 1272
    .const 'Sub' $P214 = "22_1299450604.787" 
    newclosure $P225, $P214
    .lex "control", $P225
.annotate 'line', 3
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_global $P226, "@BLOCK"
    .const 'Sub' $P228 = "23_1299450604.787" 
    capture_lex $P228
    $P228()
    find_lex $P233, "xblock_immediate"
    find_lex $P234, "block_immediate"
    find_lex $P235, "vivitype"
.annotate 'line', 35
    find_lex $P274, "colonpair_str"
.annotate 'line', 241
    find_lex $P711, "push_block_handler"
.annotate 'line', 715
    find_lex $P1843, "only_star_block"
    find_lex $P1844, "attach_multi_signature"
.annotate 'line', 1263
    find_lex $P2898, "control"
.annotate 'line', 1290
    get_hll_global $P2923, ["NQP";"RegexActions"], "_block2922" 
    capture_lex $P2923
    $P3043 = $P2923()
.annotate 'line', 3
    .return ($P3043)
    .const 'Sub' $P3045 = "169_1299450604.787" 
    .return ($P3045)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post172") :outer("11_1299450604.787")
.annotate 'line', 3
    get_hll_global $P15, ["NQP";"Actions"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P3049 = "170_1299450604.787" 
    capture_lex $P3049
    $P3049()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3048"  :anon :subid("170_1299450604.787") :outer("11_1299450604.787")
.annotate 'line', 3
    get_hll_global $P3050, "NQPClassHOW"
    $P3051 = $P3050."new_type"("Actions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3051
    set_hll_global ["NQP"], "Actions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3052, type_obj
    .const 'Sub' $P3053 = "25_1299450604.787" 
    $P3052."add_method"(type_obj, "TOP", $P3053)
    get_how $P3054, type_obj
    .const 'Sub' $P3055 = "26_1299450604.787" 
    $P3054."add_method"(type_obj, "deflongname", $P3055)
    get_how $P3056, type_obj
    .const 'Sub' $P3057 = "27_1299450604.787" 
    $P3056."add_method"(type_obj, "comp_unit", $P3057)
    get_how $P3058, type_obj
    .const 'Sub' $P3059 = "28_1299450604.787" 
    $P3058."add_method"(type_obj, "statementlist", $P3059)
    get_how $P3060, type_obj
    .const 'Sub' $P3061 = "30_1299450604.787" 
    $P3060."add_method"(type_obj, "statement", $P3061)
    get_how $P3062, type_obj
    .const 'Sub' $P3063 = "32_1299450604.787" 
    $P3062."add_method"(type_obj, "xblock", $P3063)
    get_how $P3064, type_obj
    .const 'Sub' $P3065 = "33_1299450604.787" 
    $P3064."add_method"(type_obj, "pblock", $P3065)
    get_how $P3066, type_obj
    .const 'Sub' $P3067 = "34_1299450604.787" 
    $P3066."add_method"(type_obj, "block", $P3067)
    get_how $P3068, type_obj
    .const 'Sub' $P3069 = "35_1299450604.787" 
    $P3068."add_method"(type_obj, "blockoid", $P3069)
    get_how $P3070, type_obj
    .const 'Sub' $P3071 = "37_1299450604.787" 
    $P3070."add_method"(type_obj, "newpad", $P3071)
    get_how $P3072, type_obj
    .const 'Sub' $P3073 = "38_1299450604.787" 
    $P3072."add_method"(type_obj, "outerctx", $P3073)
    get_how $P3074, type_obj
    .const 'Sub' $P3075 = "39_1299450604.787" 
    $P3074."add_method"(type_obj, "you_are_here", $P3075)
    get_how $P3076, type_obj
    .const 'Sub' $P3077 = "40_1299450604.787" 
    $P3076."add_method"(type_obj, "statement_control:sym<if>", $P3077)
    get_how $P3078, type_obj
    .const 'Sub' $P3079 = "42_1299450604.787" 
    $P3078."add_method"(type_obj, "statement_control:sym<unless>", $P3079)
    get_how $P3080, type_obj
    .const 'Sub' $P3081 = "43_1299450604.787" 
    $P3080."add_method"(type_obj, "statement_control:sym<while>", $P3081)
    get_how $P3082, type_obj
    .const 'Sub' $P3083 = "44_1299450604.787" 
    $P3082."add_method"(type_obj, "statement_control:sym<repeat>", $P3083)
    get_how $P3084, type_obj
    .const 'Sub' $P3085 = "45_1299450604.787" 
    $P3084."add_method"(type_obj, "statement_control:sym<for>", $P3085)
    get_how $P3086, type_obj
    .const 'Sub' $P3087 = "46_1299450604.787" 
    $P3086."add_method"(type_obj, "statement_control:sym<CATCH>", $P3087)
    get_how $P3088, type_obj
    .const 'Sub' $P3089 = "47_1299450604.787" 
    $P3088."add_method"(type_obj, "statement_control:sym<CONTROL>", $P3089)
    get_how $P3090, type_obj
    .const 'Sub' $P3091 = "48_1299450604.787" 
    $P3090."add_method"(type_obj, "statement_prefix:sym<INIT>", $P3091)
    get_how $P3092, type_obj
    .const 'Sub' $P3093 = "49_1299450604.787" 
    $P3092."add_method"(type_obj, "statement_prefix:sym<try>", $P3093)
    get_how $P3094, type_obj
    .const 'Sub' $P3095 = "50_1299450604.787" 
    $P3094."add_method"(type_obj, "blorst", $P3095)
    get_how $P3096, type_obj
    .const 'Sub' $P3097 = "51_1299450604.787" 
    $P3096."add_method"(type_obj, "statement_mod_cond:sym<if>", $P3097)
    get_how $P3098, type_obj
    .const 'Sub' $P3099 = "52_1299450604.787" 
    $P3098."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P3099)
    get_how $P3100, type_obj
    .const 'Sub' $P3101 = "53_1299450604.787" 
    $P3100."add_method"(type_obj, "statement_mod_loop:sym<while>", $P3101)
    get_how $P3102, type_obj
    .const 'Sub' $P3103 = "54_1299450604.787" 
    $P3102."add_method"(type_obj, "statement_mod_loop:sym<until>", $P3103)
    get_how $P3104, type_obj
    .const 'Sub' $P3105 = "55_1299450604.787" 
    $P3104."add_method"(type_obj, "term:sym<fatarrow>", $P3105)
    get_how $P3106, type_obj
    .const 'Sub' $P3107 = "56_1299450604.787" 
    $P3106."add_method"(type_obj, "term:sym<colonpair>", $P3107)
    get_how $P3108, type_obj
    .const 'Sub' $P3109 = "57_1299450604.787" 
    $P3108."add_method"(type_obj, "term:sym<variable>", $P3109)
    get_how $P3110, type_obj
    .const 'Sub' $P3111 = "58_1299450604.787" 
    $P3110."add_method"(type_obj, "term:sym<package_declarator>", $P3111)
    get_how $P3112, type_obj
    .const 'Sub' $P3113 = "59_1299450604.787" 
    $P3112."add_method"(type_obj, "term:sym<scope_declarator>", $P3113)
    get_how $P3114, type_obj
    .const 'Sub' $P3115 = "60_1299450604.787" 
    $P3114."add_method"(type_obj, "term:sym<routine_declarator>", $P3115)
    get_how $P3116, type_obj
    .const 'Sub' $P3117 = "61_1299450604.787" 
    $P3116."add_method"(type_obj, "term:sym<regex_declarator>", $P3117)
    get_how $P3118, type_obj
    .const 'Sub' $P3119 = "62_1299450604.787" 
    $P3118."add_method"(type_obj, "term:sym<statement_prefix>", $P3119)
    get_how $P3120, type_obj
    .const 'Sub' $P3121 = "63_1299450604.787" 
    $P3120."add_method"(type_obj, "term:sym<lambda>", $P3121)
    get_how $P3122, type_obj
    .const 'Sub' $P3123 = "64_1299450604.787" 
    $P3122."add_method"(type_obj, "fatarrow", $P3123)
    get_how $P3124, type_obj
    .const 'Sub' $P3125 = "65_1299450604.787" 
    $P3124."add_method"(type_obj, "colonpair", $P3125)
    get_how $P3126, type_obj
    .const 'Sub' $P3127 = "66_1299450604.787" 
    $P3126."add_method"(type_obj, "variable", $P3127)
    get_how $P3128, type_obj
    .const 'Sub' $P3129 = "68_1299450604.787" 
    $P3128."add_method"(type_obj, "package_declarator:sym<module>", $P3129)
    get_how $P3130, type_obj
    .const 'Sub' $P3131 = "69_1299450604.787" 
    $P3130."add_method"(type_obj, "package_declarator:sym<knowhow>", $P3131)
    get_how $P3132, type_obj
    .const 'Sub' $P3133 = "70_1299450604.787" 
    $P3132."add_method"(type_obj, "package_declarator:sym<class>", $P3133)
    get_how $P3134, type_obj
    .const 'Sub' $P3135 = "71_1299450604.787" 
    $P3134."add_method"(type_obj, "package_declarator:sym<grammar>", $P3135)
    get_how $P3136, type_obj
    .const 'Sub' $P3137 = "72_1299450604.787" 
    $P3136."add_method"(type_obj, "package_declarator:sym<role>", $P3137)
    get_how $P3138, type_obj
    .const 'Sub' $P3139 = "73_1299450604.787" 
    $P3138."add_method"(type_obj, "package_declarator:sym<native>", $P3139)
    get_how $P3140, type_obj
    .const 'Sub' $P3141 = "74_1299450604.787" 
    $P3140."add_method"(type_obj, "package_def", $P3141)
    get_how $P3142, type_obj
    .const 'Sub' $P3143 = "78_1299450604.787" 
    $P3142."add_method"(type_obj, "scope_declarator:sym<my>", $P3143)
    get_how $P3144, type_obj
    .const 'Sub' $P3145 = "79_1299450604.787" 
    $P3144."add_method"(type_obj, "scope_declarator:sym<our>", $P3145)
    get_how $P3146, type_obj
    .const 'Sub' $P3147 = "80_1299450604.787" 
    $P3146."add_method"(type_obj, "scope_declarator:sym<has>", $P3147)
    get_how $P3148, type_obj
    .const 'Sub' $P3149 = "81_1299450604.787" 
    $P3148."add_method"(type_obj, "scoped", $P3149)
    get_how $P3150, type_obj
    .const 'Sub' $P3151 = "82_1299450604.787" 
    $P3150."add_method"(type_obj, "declarator", $P3151)
    get_how $P3152, type_obj
    .const 'Sub' $P3153 = "83_1299450604.787" 
    $P3152."add_method"(type_obj, "multi_declarator:sym<multi>", $P3153)
    get_how $P3154, type_obj
    .const 'Sub' $P3155 = "84_1299450604.787" 
    $P3154."add_method"(type_obj, "multi_declarator:sym<proto>", $P3155)
    get_how $P3156, type_obj
    .const 'Sub' $P3157 = "85_1299450604.787" 
    $P3156."add_method"(type_obj, "multi_declarator:sym<null>", $P3157)
    get_how $P3158, type_obj
    .const 'Sub' $P3159 = "86_1299450604.787" 
    $P3158."add_method"(type_obj, "variable_declarator", $P3159)
    get_how $P3160, type_obj
    .const 'Sub' $P3161 = "90_1299450604.787" 
    $P3160."add_method"(type_obj, "routine_declarator:sym<sub>", $P3161)
    get_how $P3162, type_obj
    .const 'Sub' $P3163 = "91_1299450604.787" 
    $P3162."add_method"(type_obj, "routine_declarator:sym<method>", $P3163)
    get_how $P3164, type_obj
    .const 'Sub' $P3165 = "92_1299450604.787" 
    $P3164."add_method"(type_obj, "routine_def", $P3165)
    get_how $P3166, type_obj
    .const 'Sub' $P3167 = "99_1299450604.787" 
    $P3166."add_method"(type_obj, "method_def", $P3167)
    get_how $P3168, type_obj
    .const 'Sub' $P3169 = "102_1299450604.787" 
    $P3168."add_method"(type_obj, "signature", $P3169)
    get_how $P3170, type_obj
    .const 'Sub' $P3171 = "105_1299450604.787" 
    $P3170."add_method"(type_obj, "parameter", $P3171)
    get_how $P3172, type_obj
    .const 'Sub' $P3173 = "106_1299450604.787" 
    $P3172."add_method"(type_obj, "param_var", $P3173)
    get_how $P3174, type_obj
    .const 'Sub' $P3175 = "107_1299450604.787" 
    $P3174."add_method"(type_obj, "named_param", $P3175)
    get_how $P3176, type_obj
    .const 'Sub' $P3177 = "108_1299450604.787" 
    $P3176."add_method"(type_obj, "typename", $P3177)
    get_how $P3178, type_obj
    .const 'Sub' $P3179 = "109_1299450604.787" 
    $P3178."add_method"(type_obj, "trait", $P3179)
    get_how $P3180, type_obj
    .const 'Sub' $P3181 = "110_1299450604.787" 
    $P3180."add_method"(type_obj, "trait_mod:sym<is>", $P3181)
    get_how $P3182, type_obj
    .const 'Sub' $P3183 = "112_1299450604.787" 
    $P3182."add_method"(type_obj, "regex_declarator", $P3183)
    get_how $P3184, type_obj
    .const 'Sub' $P3185 = "116_1299450604.787" 
    $P3184."add_method"(type_obj, "dotty", $P3185)
    get_how $P3186, type_obj
    .const 'Sub' $P3187 = "117_1299450604.787" 
    $P3186."add_method"(type_obj, "term:sym<self>", $P3187)
    get_how $P3188, type_obj
    .const 'Sub' $P3189 = "118_1299450604.787" 
    $P3188."add_method"(type_obj, "term:sym<identifier>", $P3189)
    get_how $P3190, type_obj
    .const 'Sub' $P3191 = "119_1299450604.787" 
    $P3190."add_method"(type_obj, "term:sym<name>", $P3191)
    get_how $P3192, type_obj
    .const 'Sub' $P3193 = "120_1299450604.787" 
    $P3192."add_method"(type_obj, "term:sym<pir::op>", $P3193)
    get_how $P3194, type_obj
    .const 'Sub' $P3195 = "121_1299450604.787" 
    $P3194."add_method"(type_obj, "term:sym<onlystar>", $P3195)
    get_how $P3196, type_obj
    .const 'Sub' $P3197 = "122_1299450604.787" 
    $P3196."add_method"(type_obj, "args", $P3197)
    get_how $P3198, type_obj
    .const 'Sub' $P3199 = "123_1299450604.787" 
    $P3198."add_method"(type_obj, "arglist", $P3199)
    get_how $P3200, type_obj
    .const 'Sub' $P3201 = "126_1299450604.787" 
    $P3200."add_method"(type_obj, "term:sym<multi_declarator>", $P3201)
    get_how $P3202, type_obj
    .const 'Sub' $P3203 = "127_1299450604.787" 
    $P3202."add_method"(type_obj, "term:sym<value>", $P3203)
    get_how $P3204, type_obj
    .const 'Sub' $P3205 = "128_1299450604.787" 
    $P3204."add_method"(type_obj, "circumfix:sym<( )>", $P3205)
    get_how $P3206, type_obj
    .const 'Sub' $P3207 = "129_1299450604.787" 
    $P3206."add_method"(type_obj, "circumfix:sym<[ ]>", $P3207)
    get_how $P3208, type_obj
    .const 'Sub' $P3209 = "130_1299450604.787" 
    $P3208."add_method"(type_obj, "circumfix:sym<ang>", $P3209)
    get_how $P3210, type_obj
    .const 'Sub' $P3211 = "131_1299450604.787" 
    $P3210."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P3211)
    get_how $P3212, type_obj
    .const 'Sub' $P3213 = "132_1299450604.787" 
    $P3212."add_method"(type_obj, "circumfix:sym<{ }>", $P3213)
    get_how $P3214, type_obj
    .const 'Sub' $P3215 = "134_1299450604.787" 
    $P3214."add_method"(type_obj, "circumfix:sym<sigil>", $P3215)
    get_how $P3216, type_obj
    .const 'Sub' $P3217 = "135_1299450604.787" 
    $P3216."add_method"(type_obj, "semilist", $P3217)
    get_how $P3218, type_obj
    .const 'Sub' $P3219 = "136_1299450604.787" 
    $P3218."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P3219)
    get_how $P3220, type_obj
    .const 'Sub' $P3221 = "137_1299450604.787" 
    $P3220."add_method"(type_obj, "postcircumfix:sym<{ }>", $P3221)
    get_how $P3222, type_obj
    .const 'Sub' $P3223 = "138_1299450604.787" 
    $P3222."add_method"(type_obj, "postcircumfix:sym<ang>", $P3223)
    get_how $P3224, type_obj
    .const 'Sub' $P3225 = "139_1299450604.787" 
    $P3224."add_method"(type_obj, "postcircumfix:sym<( )>", $P3225)
    get_how $P3226, type_obj
    .const 'Sub' $P3227 = "140_1299450604.787" 
    $P3226."add_method"(type_obj, "value", $P3227)
    get_how $P3228, type_obj
    .const 'Sub' $P3229 = "141_1299450604.787" 
    $P3228."add_method"(type_obj, "number", $P3229)
    get_how $P3230, type_obj
    .const 'Sub' $P3231 = "142_1299450604.787" 
    $P3230."add_method"(type_obj, "quote:sym<apos>", $P3231)
    get_how $P3232, type_obj
    .const 'Sub' $P3233 = "143_1299450604.787" 
    $P3232."add_method"(type_obj, "quote:sym<dblq>", $P3233)
    get_how $P3234, type_obj
    .const 'Sub' $P3235 = "144_1299450604.787" 
    $P3234."add_method"(type_obj, "quote:sym<qq>", $P3235)
    get_how $P3236, type_obj
    .const 'Sub' $P3237 = "145_1299450604.787" 
    $P3236."add_method"(type_obj, "quote:sym<q>", $P3237)
    get_how $P3238, type_obj
    .const 'Sub' $P3239 = "146_1299450604.787" 
    $P3238."add_method"(type_obj, "quote:sym<Q>", $P3239)
    get_how $P3240, type_obj
    .const 'Sub' $P3241 = "147_1299450604.787" 
    $P3240."add_method"(type_obj, "quote:sym<Q:PIR>", $P3241)
    get_how $P3242, type_obj
    .const 'Sub' $P3243 = "148_1299450604.787" 
    $P3242."add_method"(type_obj, "quote:sym</ />", $P3243)
    get_how $P3244, type_obj
    .const 'Sub' $P3245 = "149_1299450604.787" 
    $P3244."add_method"(type_obj, "quote_escape:sym<$>", $P3245)
    get_how $P3246, type_obj
    .const 'Sub' $P3247 = "150_1299450604.787" 
    $P3246."add_method"(type_obj, "quote_escape:sym<{ }>", $P3247)
    get_how $P3248, type_obj
    .const 'Sub' $P3249 = "151_1299450604.787" 
    $P3248."add_method"(type_obj, "quote_escape:sym<esc>", $P3249)
    get_how $P3250, type_obj
    .const 'Sub' $P3251 = "152_1299450604.787" 
    $P3250."add_method"(type_obj, "postfix:sym<.>", $P3251)
    get_how $P3252, type_obj
    .const 'Sub' $P3253 = "153_1299450604.787" 
    $P3252."add_method"(type_obj, "postfix:sym<++>", $P3253)
    get_how $P3254, type_obj
    .const 'Sub' $P3255 = "154_1299450604.787" 
    $P3254."add_method"(type_obj, "postfix:sym<-->", $P3255)
    get_how $P3256, type_obj
    .const 'Sub' $P3257 = "155_1299450604.787" 
    $P3256."add_method"(type_obj, "prefix:sym<make>", $P3257)
    get_how $P3258, type_obj
    .const 'Sub' $P3259 = "156_1299450604.787" 
    $P3258."add_method"(type_obj, "term:sym<next>", $P3259)
    get_how $P3260, type_obj
    .const 'Sub' $P3261 = "157_1299450604.787" 
    $P3260."add_method"(type_obj, "term:sym<last>", $P3261)
    get_how $P3262, type_obj
    .const 'Sub' $P3263 = "158_1299450604.787" 
    $P3262."add_method"(type_obj, "term:sym<redo>", $P3263)
    get_how $P3264, type_obj
    .const 'Sub' $P3265 = "159_1299450604.787" 
    $P3264."add_method"(type_obj, "infix:sym<~~>", $P3265)
    get_how $P3266, type_obj
    get_hll_global $P3267, ["HLL"], "Actions"
    $P3266."add_parent"(type_obj, $P3267)
    get_how $P3268, type_obj
    $P3269 = $P3268."compose"(type_obj)
    .return ($P3269)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("12_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_20
.annotate 'line', 9
    .lex "$xblock", param_20
.annotate 'line', 10
    find_lex $P21, "$xblock"
    unless_null $P21, vivify_174
    $P21 = root_new ['parrot';'ResizablePMCArray']
  vivify_174:
    set $P22, $P21[1]
    unless_null $P22, vivify_175
    new $P22, "Undef"
  vivify_175:
    $P23 = "block_immediate"($P22)
    find_lex $P24, "$xblock"
    unless_null $P24, vivify_176
    $P24 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P24
  vivify_176:
    set $P24[1], $P23
    find_lex $P25, "$xblock"
.annotate 'line', 9
    .return ($P25)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("13_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_28
.annotate 'line', 14
    .const 'Sub' $P38 = "14_1299450604.787" 
    capture_lex $P38
    .lex "$block", param_28
.annotate 'line', 15
    find_lex $P29, "$block"
    $P29."blocktype"("immediate")
.annotate 'line', 16
    find_lex $P33, "$block"
    $P34 = $P33."symtable"()
    unless $P34, unless_32
    set $P31, $P34
    goto unless_32_end
  unless_32:
    find_lex $P35, "$block"
    $P36 = $P35."handlers"()
    set $P31, $P36
  unless_32_end:
    if $P31, unless_30_end
    .const 'Sub' $P38 = "14_1299450604.787" 
    capture_lex $P38
    $P38()
  unless_30_end:
    find_lex $P58, "$block"
.annotate 'line', 14
    .return ($P58)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block37"  :anon :subid("14_1299450604.787") :outer("13_1299450604.787")
.annotate 'line', 16
    .const 'Sub' $P49 = "15_1299450604.787" 
    capture_lex $P49
.annotate 'line', 17
    new $P39, "Undef"
    .lex "$stmts", $P39
    get_hll_global $P40, ["PAST"], "Stmts"
    find_lex $P41, "$block"
    $P42 = $P40."new"($P41 :named("node"))
    store_lex "$stmts", $P42
.annotate 'line', 18
    find_lex $P44, "$block"
    $P45 = $P44."list"()
    defined $I46, $P45
    unless $I46, for_undef_177
    iter $P43, $P45
    new $P55, 'ExceptionHandler'
    set_label $P55, loop54_handler
    $P55."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P55
  loop54_test:
    unless $P43, loop54_done
    shift $P47, $P43
  loop54_redo:
    .const 'Sub' $P49 = "15_1299450604.787" 
    capture_lex $P49
    $P49($P47)
  loop54_next:
    goto loop54_test
  loop54_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P56, exception, 'type'
    eq $P56, .CONTROL_LOOP_NEXT, loop54_next
    eq $P56, .CONTROL_LOOP_REDO, loop54_redo
  loop54_done:
    pop_eh 
  for_undef_177:
.annotate 'line', 19
    find_lex $P57, "$stmts"
    store_lex "$block", $P57
.annotate 'line', 16
    .return ($P57)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block48"  :anon :subid("15_1299450604.787") :outer("14_1299450604.787")
    .param pmc param_50
.annotate 'line', 18
    .lex "$_", param_50
    find_lex $P51, "$stmts"
    find_lex $P52, "$_"
    $P53 = $P51."push"($P52)
    .return ($P53)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("16_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_61
.annotate 'line', 24
    .lex "$sigil", param_61
.annotate 'line', 25
    find_lex $P64, "$sigil"
    set $S65, $P64
    iseq $I66, $S65, "%"
    if $I66, if_63
.annotate 'line', 27
    find_lex $P71, "$sigil"
    set $S72, $P71
    iseq $I73, $S72, "@"
    if $I73, if_70
    new $P76, "String"
    assign $P76, "Undef"
    set $P69, $P76
    goto if_70_end
  if_70:
.annotate 'line', 28
    get_hll_global $P74, ["PAST"], "Op"
    $P75 = $P74."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P69, $P75
  if_70_end:
    set $P62, $P69
.annotate 'line', 25
    goto if_63_end
  if_63:
.annotate 'line', 26
    get_hll_global $P67, ["PAST"], "Op"
    $P68 = $P67."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P62, $P68
  if_63_end:
.annotate 'line', 24
    .return ($P62)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("17_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_79
.annotate 'line', 43
    .lex "$ast", param_79
.annotate 'line', 44
    get_hll_global $P82, ["PAST"], "Op"
    find_lex $P83, "$ast"
    $P84 = $P82."ACCEPTS"($P83)
    if $P84, if_81
.annotate 'line', 46
    find_lex $P88, "$ast"
    $P89 = $P88."value"()
    set $P80, $P89
.annotate 'line', 44
    goto if_81_end
  if_81:
.annotate 'line', 45
    find_lex $P85, "$ast"
    $P86 = $P85."list"()
    join $S87, " ", $P86
    new $P80, 'String'
    set $P80, $S87
  if_81_end:
.annotate 'line', 43
    .return ($P80)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("18_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_92
    .param pmc param_93
.annotate 'line', 248
    .lex "$/", param_92
    .lex "$block", param_93
.annotate 'line', 249
    get_global $P95, "@BLOCK"
    unless_null $P95, vivify_178
    $P95 = root_new ['parrot';'ResizablePMCArray']
  vivify_178:
    set $P96, $P95[0]
    unless_null $P96, vivify_179
    new $P96, "Undef"
  vivify_179:
    $P97 = $P96."handlers"()
    if $P97, unless_94_end
.annotate 'line', 250
    get_global $P98, "@BLOCK"
    unless_null $P98, vivify_180
    $P98 = root_new ['parrot';'ResizablePMCArray']
  vivify_180:
    set $P99, $P98[0]
    unless_null $P99, vivify_181
    new $P99, "Undef"
  vivify_181:
    new $P100, "ResizablePMCArray"
    $P99."handlers"($P100)
  unless_94_end:
.annotate 'line', 252
    find_lex $P102, "$block"
    $P103 = $P102."arity"()
    if $P103, unless_101_end
.annotate 'line', 253
    find_lex $P104, "$block"
.annotate 'line', 254
    get_hll_global $P105, ["PAST"], "Op"
.annotate 'line', 255
    get_hll_global $P106, ["PAST"], "Var"
    $P107 = $P106."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 256
    get_hll_global $P108, ["PAST"], "Var"
    $P109 = $P108."new"("lexical" :named("scope"), "$_" :named("name"))
    $P110 = $P105."new"($P107, $P109, "bind" :named("pasttype"))
.annotate 'line', 254
    $P104."unshift"($P110)
.annotate 'line', 259
    find_lex $P111, "$block"
    get_hll_global $P112, ["PAST"], "Var"
    $P113 = $P112."new"("$_" :named("name"), "parameter" :named("scope"))
    $P111."unshift"($P113)
.annotate 'line', 260
    find_lex $P114, "$block"
    $P114."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 261
    find_lex $P115, "$block"
    $P115."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 262
    find_lex $P116, "$block"
    $P116."arity"(1)
  unless_101_end:
.annotate 'line', 264
    find_lex $P117, "$block"
    $P117."blocktype"("declaration")
.annotate 'line', 265
    get_global $P118, "@BLOCK"
    unless_null $P118, vivify_182
    $P118 = root_new ['parrot';'ResizablePMCArray']
  vivify_182:
    set $P119, $P118[0]
    unless_null $P119, vivify_183
    new $P119, "Undef"
  vivify_183:
    $P120 = $P119."handlers"()
.annotate 'line', 266
    get_hll_global $P121, ["PAST"], "Control"
    find_lex $P122, "$/"
.annotate 'line', 268
    get_hll_global $P123, ["PAST"], "Stmts"
.annotate 'line', 269
    get_hll_global $P124, ["PAST"], "Op"
    find_lex $P125, "$block"
.annotate 'line', 271
    get_hll_global $P126, ["PAST"], "Var"
    $P127 = $P126."new"("register" :named("scope"), "exception" :named("name"))
    $P128 = $P124."new"($P125, $P127, "call" :named("pasttype"))
.annotate 'line', 273
    get_hll_global $P129, ["PAST"], "Op"
.annotate 'line', 274
    get_hll_global $P130, ["PAST"], "Var"
.annotate 'line', 275
    get_hll_global $P131, ["PAST"], "Var"
    $P132 = $P131."new"("register" :named("scope"), "exception" :named("name"))
    $P133 = $P130."new"($P132, "handled", "keyed" :named("scope"))
.annotate 'line', 274
    $P134 = $P129."new"($P133, 1, "bind" :named("pasttype"))
.annotate 'line', 273
    $P135 = $P123."new"($P128, $P134)
.annotate 'line', 268
    $P136 = $P121."new"($P135, $P122 :named("node"))
.annotate 'line', 266
    $P137 = $P120."unshift"($P136)
.annotate 'line', 248
    .return ($P137)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("19_1299450604.787") :outer("11_1299450604.787")
.annotate 'line', 788
    new $P140, "Undef"
    .lex "$past", $P140
    get_global $P141, "@BLOCK"
    $P142 = $P141."shift"()
    store_lex "$past", $P142
.annotate 'line', 789
    find_lex $P143, "$past"
    $P143."closure"(1)
.annotate 'line', 790
    find_lex $P144, "$past"
    get_hll_global $P145, ["PAST"], "Op"
    $P146 = $P145."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P144."push"($P146)
    find_lex $P147, "$past"
.annotate 'line', 787
    .return ($P147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("20_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_150
.annotate 'line', 796
    .const 'Sub' $P164 = "21_1299450604.787" 
    capture_lex $P164
    .lex "$routine", param_150
.annotate 'line', 800
    new $P151, "Undef"
    .lex "$types", $P151
.annotate 'line', 801
    new $P152, "Undef"
    .lex "$definednesses", $P152
.annotate 'line', 800
    get_hll_global $P153, ["PAST"], "Op"
    $P154 = $P153."new"("list" :named("pasttype"))
    store_lex "$types", $P154
.annotate 'line', 801
    get_hll_global $P155, ["PAST"], "Op"
    $P156 = $P155."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P156
.annotate 'line', 802
    find_lex $P158, "$routine"
    unless_null $P158, vivify_184
    $P158 = root_new ['parrot';'ResizablePMCArray']
  vivify_184:
    set $P159, $P158[0]
    unless_null $P159, vivify_185
    new $P159, "Undef"
  vivify_185:
    $P160 = $P159."list"()
    defined $I161, $P160
    unless $I161, for_undef_186
    iter $P157, $P160
    new $P202, 'ExceptionHandler'
    set_label $P202, loop201_handler
    $P202."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P202
  loop201_test:
    unless $P157, loop201_done
    shift $P162, $P157
  loop201_redo:
    .const 'Sub' $P164 = "21_1299450604.787" 
    capture_lex $P164
    $P164($P162)
  loop201_next:
    goto loop201_test
  loop201_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P203, exception, 'type'
    eq $P203, .CONTROL_LOOP_NEXT, loop201_next
    eq $P203, .CONTROL_LOOP_REDO, loop201_redo
  loop201_done:
    pop_eh 
  for_undef_186:
.annotate 'line', 809
    find_lex $P204, "$routine"
    $P205 = $P204."loadinit"()
    get_hll_global $P206, ["PAST"], "Op"
.annotate 'line', 810
    get_hll_global $P207, ["PAST"], "Var"
    $P208 = $P207."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P209, "$types"
    find_lex $P210, "$definednesses"
    $P211 = $P206."new"($P208, $P209, $P210, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 809
    $P212 = $P205."push"($P211)
.annotate 'line', 796
    .return ($P212)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block163"  :anon :subid("21_1299450604.787") :outer("20_1299450604.787")
    .param pmc param_165
.annotate 'line', 802
    .lex "$_", param_165
.annotate 'line', 803
    get_hll_global $P170, ["PAST"], "Var"
    find_lex $P171, "$_"
    $P172 = $P170."ACCEPTS"($P171)
    if $P172, if_169
    set $P168, $P172
    goto if_169_end
  if_169:
    find_lex $P173, "$_"
    $S174 = $P173."scope"()
    iseq $I175, $S174, "parameter"
    new $P168, 'Integer'
    set $P168, $I175
  if_169_end:
    if $P168, if_167
    set $P166, $P168
    goto if_167_end
  if_167:
.annotate 'line', 804
    find_lex $P176, "$types"
    find_lex $P178, "$_"
    $P179 = $P178."multitype"()
    set $P177, $P179
    defined $I181, $P177
    if $I181, default_180
    get_hll_global $P182, ["PAST"], "Op"
    $P183 = $P182."new"("null P" :named("pirop"))
    set $P177, $P183
  default_180:
    $P176."push"($P177)
.annotate 'line', 805
    find_lex $P184, "$definednesses"
    find_lex $P187, "$_"
    unless_null $P187, vivify_187
    $P187 = root_new ['parrot';'Hash']
  vivify_187:
    set $P188, $P187["definedness"]
    unless_null $P188, vivify_188
    new $P188, "Undef"
  vivify_188:
    set $S189, $P188
    iseq $I190, $S189, "D"
    if $I190, if_186
.annotate 'line', 806
    find_lex $P194, "$_"
    unless_null $P194, vivify_189
    $P194 = root_new ['parrot';'Hash']
  vivify_189:
    set $P195, $P194["definedness"]
    unless_null $P195, vivify_190
    new $P195, "Undef"
  vivify_190:
    set $S196, $P195
    iseq $I197, $S196, "U"
    if $I197, if_193
    new $P199, "Integer"
    assign $P199, 0
    set $P192, $P199
    goto if_193_end
  if_193:
    new $P198, "Integer"
    assign $P198, 2
    set $P192, $P198
  if_193_end:
    set $P185, $P192
.annotate 'line', 805
    goto if_186_end
  if_186:
    new $P191, "Integer"
    assign $P191, 1
    set $P185, $P191
  if_186_end:
    $P200 = $P184."push"($P185)
.annotate 'line', 803
    set $P166, $P200
  if_167_end:
.annotate 'line', 802
    .return ($P166)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("22_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_215
    .param pmc param_216
.annotate 'line', 1272
    .lex "$/", param_215
    .lex "$type", param_216
.annotate 'line', 1273
    find_lex $P217, "$/"
    get_hll_global $P218, ["PAST"], "Op"
    find_lex $P219, "$/"
.annotate 'line', 1277
    get_hll_global $P220, ["PAST"], "Val"
    find_lex $P221, "$type"
    $P222 = $P220."new"($P221 :named("value"), "!except_types" :named("returns"))
    $P223 = $P218."new"(0, $P222, $P219 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 1273
    $P224 = $P217."!make"($P223)
.annotate 'line', 1272
    .return ($P224)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block227"  :anon :subid("23_1299450604.787") :outer("11_1299450604.787")
.annotate 'line', 3
    .const 'Sub' $P230 = "24_1299450604.787" 
    capture_lex $P230
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post191") :outer("23_1299450604.787")
.annotate 'line', 3
    .const 'Sub' $P228 = "23_1299450604.787" 
    .local pmc block
    set block, $P228
.annotate 'line', 5
    .const 'Sub' $P230 = "24_1299450604.787" 
    capture_lex $P230
    $P230()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block229"  :anon :subid("24_1299450604.787") :outer("23_1299450604.787")
.annotate 'line', 6
    get_global $P231, "@BLOCK"
    unless_null $P231, vivify_192
    $P231 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P231
  vivify_192:
 $P232 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P232
.annotate 'line', 5
    .return ($P232)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("25_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_237
    .param pmc param_238
.annotate 'line', 33
    .lex "self", param_237
    .lex "$/", param_238
    find_lex $P239, "$/"
    find_lex $P240, "$/"
    unless_null $P240, vivify_193
    $P240 = root_new ['parrot';'Hash']
  vivify_193:
    set $P241, $P240["comp_unit"]
    unless_null $P241, vivify_194
    new $P241, "Undef"
  vivify_194:
    $P242 = $P241."ast"()
    $P243 = $P239."!make"($P242)
    .return ($P243)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("26_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_245
    .param pmc param_246
.annotate 'line', 35
    .lex "self", param_245
    .lex "$/", param_246
.annotate 'line', 36
    find_lex $P247, "$/"
.annotate 'line', 37
    find_lex $P250, "$/"
    unless_null $P250, vivify_195
    $P250 = root_new ['parrot';'Hash']
  vivify_195:
    set $P251, $P250["colonpair"]
    unless_null $P251, vivify_196
    new $P251, "Undef"
  vivify_196:
    if $P251, if_249
.annotate 'line', 39
    find_lex $P271, "$/"
    set $S272, $P271
    new $P248, 'String'
    set $P248, $S272
.annotate 'line', 37
    goto if_249_end
  if_249:
    find_lex $P252, "$/"
    unless_null $P252, vivify_197
    $P252 = root_new ['parrot';'Hash']
  vivify_197:
    set $P253, $P252["identifier"]
    unless_null $P253, vivify_198
    new $P253, "Undef"
  vivify_198:
    set $S254, $P253
    new $P255, 'String'
    set $P255, $S254
    concat $P256, $P255, ":"
    find_lex $P257, "$/"
    unless_null $P257, vivify_199
    $P257 = root_new ['parrot';'Hash']
  vivify_199:
    set $P258, $P257["colonpair"]
    unless_null $P258, vivify_200
    $P258 = root_new ['parrot';'ResizablePMCArray']
  vivify_200:
    set $P259, $P258[0]
    unless_null $P259, vivify_201
    new $P259, "Undef"
  vivify_201:
    $P260 = $P259."ast"()
    $S261 = $P260."named"()
    concat $P262, $P256, $S261
    concat $P263, $P262, "<"
.annotate 'line', 38
    find_lex $P264, "$/"
    unless_null $P264, vivify_202
    $P264 = root_new ['parrot';'Hash']
  vivify_202:
    set $P265, $P264["colonpair"]
    unless_null $P265, vivify_203
    $P265 = root_new ['parrot';'ResizablePMCArray']
  vivify_203:
    set $P266, $P265[0]
    unless_null $P266, vivify_204
    new $P266, "Undef"
  vivify_204:
    $P267 = $P266."ast"()
    $S268 = "colonpair_str"($P267)
    concat $P269, $P263, $S268
    concat $P270, $P269, ">"
    set $P248, $P270
  if_249_end:
.annotate 'line', 37
    $P273 = $P247."!make"($P248)
.annotate 'line', 35
    .return ($P273)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("27_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_276
    .param pmc param_277
.annotate 'line', 49
    .lex "self", param_276
    .lex "$/", param_277
.annotate 'line', 50
    new $P278, "Undef"
    .lex "$mainline", $P278
.annotate 'line', 51
    new $P279, "Undef"
    .lex "$unit", $P279
.annotate 'line', 50
    find_lex $P280, "$/"
    unless_null $P280, vivify_205
    $P280 = root_new ['parrot';'Hash']
  vivify_205:
    set $P281, $P280["statementlist"]
    unless_null $P281, vivify_206
    new $P281, "Undef"
  vivify_206:
    $P282 = $P281."ast"()
    store_lex "$mainline", $P282
.annotate 'line', 51
    get_global $P283, "@BLOCK"
    $P284 = $P283."shift"()
    store_lex "$unit", $P284
.annotate 'line', 56
    find_dynamic_lex $P286, "$*HAS_YOU_ARE_HERE"
    unless_null $P286, vivify_207
    get_hll_global $P286, "$HAS_YOU_ARE_HERE"
    unless_null $P286, vivify_208
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_208:
  vivify_207:
    if $P286, unless_285_end
.annotate 'line', 57
    find_lex $P287, "$unit"
    find_lex $P288, "self"
    $P289 = $P288."CTXSAVE"()
    $P287."push"($P289)
  unless_285_end:
.annotate 'line', 61
    find_lex $P290, "$unit"
    $P290."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 62
    find_lex $P291, "$unit"
    get_hll_global $P292, ["PAST"], "Op"
    $P293 = $P292."new"("nqp_dynop_setup v" :named("pirop"))
    $P291."unshift"($P293)
.annotate 'line', 67
    find_lex $P294, "$unit"
.annotate 'line', 68
    get_hll_global $P295, ["PAST"], "Op"
    find_lex $P296, "$mainline"
    $P297 = $P295."new"($P296, "return" :named("pirop"))
    $P294."push"($P297)
.annotate 'line', 73
    find_lex $P298, "$unit"
.annotate 'line', 74
    get_hll_global $P299, ["PAST"], "Block"
.annotate 'line', 76
    get_hll_global $P300, ["PAST"], "Op"
    get_hll_global $P301, ["PAST"], "Val"
    find_lex $P302, "$unit"
    $P303 = $P301."new"($P302 :named("value"))
    $P304 = $P300."new"($P303, "call" :named("pasttype"))
    $P305 = $P299."new"($P304, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 74
    $P298."push"($P305)
.annotate 'line', 79
    find_lex $P306, "$unit"
    find_lex $P307, "$/"
    $P306."node"($P307)
.annotate 'line', 82
    find_lex $P308, "$unit"
    $P308."hll"("nqp")
.annotate 'line', 84
    find_lex $P309, "$/"
    find_lex $P310, "$unit"
    $P311 = $P309."!make"($P310)
.annotate 'line', 49
    .return ($P311)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("28_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_313
    .param pmc param_314
.annotate 'line', 87
    .const 'Sub' $P328 = "29_1299450604.787" 
    capture_lex $P328
    .lex "self", param_313
    .lex "$/", param_314
.annotate 'line', 88
    new $P315, "Undef"
    .lex "$past", $P315
    get_hll_global $P316, ["PAST"], "Stmts"
    find_lex $P317, "$/"
    $P318 = $P316."new"($P317 :named("node"))
    store_lex "$past", $P318
.annotate 'line', 89
    find_lex $P320, "$/"
    unless_null $P320, vivify_209
    $P320 = root_new ['parrot';'Hash']
  vivify_209:
    set $P321, $P320["statement"]
    unless_null $P321, vivify_210
    new $P321, "Undef"
  vivify_210:
    unless $P321, if_319_end
.annotate 'line', 90
    find_lex $P323, "$/"
    unless_null $P323, vivify_211
    $P323 = root_new ['parrot';'Hash']
  vivify_211:
    set $P324, $P323["statement"]
    unless_null $P324, vivify_212
    new $P324, "Undef"
  vivify_212:
    defined $I325, $P324
    unless $I325, for_undef_213
    iter $P322, $P324
    new $P348, 'ExceptionHandler'
    set_label $P348, loop347_handler
    $P348."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P348
  loop347_test:
    unless $P322, loop347_done
    shift $P326, $P322
  loop347_redo:
    .const 'Sub' $P328 = "29_1299450604.787" 
    capture_lex $P328
    $P328($P326)
  loop347_next:
    goto loop347_test
  loop347_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P349, exception, 'type'
    eq $P349, .CONTROL_LOOP_NEXT, loop347_next
    eq $P349, .CONTROL_LOOP_REDO, loop347_redo
  loop347_done:
    pop_eh 
  for_undef_213:
  if_319_end:
.annotate 'line', 97
    find_lex $P350, "$/"
    find_lex $P351, "$past"
    $P352 = $P350."!make"($P351)
.annotate 'line', 87
    .return ($P352)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block327"  :anon :subid("29_1299450604.787") :outer("28_1299450604.787")
    .param pmc param_330
.annotate 'line', 91
    new $P329, "Undef"
    .lex "$ast", $P329
    .lex "$_", param_330
    find_lex $P331, "$_"
    $P332 = $P331."ast"()
    store_lex "$ast", $P332
.annotate 'line', 92
    find_lex $P334, "$ast"
    unless_null $P334, vivify_214
    $P334 = root_new ['parrot';'Hash']
  vivify_214:
    set $P335, $P334["sink"]
    unless_null $P335, vivify_215
    new $P335, "Undef"
  vivify_215:
    defined $I336, $P335
    unless $I336, if_333_end
    find_lex $P337, "$ast"
    unless_null $P337, vivify_216
    $P337 = root_new ['parrot';'Hash']
  vivify_216:
    set $P338, $P337["sink"]
    unless_null $P338, vivify_217
    new $P338, "Undef"
  vivify_217:
    store_lex "$ast", $P338
  if_333_end:
.annotate 'line', 93
    find_lex $P340, "$ast"
    unless_null $P340, vivify_218
    $P340 = root_new ['parrot';'Hash']
  vivify_218:
    set $P341, $P340["bareblock"]
    unless_null $P341, vivify_219
    new $P341, "Undef"
  vivify_219:
    unless $P341, if_339_end
    find_lex $P342, "$ast"
    $P343 = "block_immediate"($P342)
    store_lex "$ast", $P343
  if_339_end:
.annotate 'line', 94
    find_lex $P344, "$past"
    find_lex $P345, "$ast"
    $P346 = $P344."push"($P345)
.annotate 'line', 90
    .return ($P346)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("30_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_354
    .param pmc param_355
    .param pmc param_356 :optional
    .param int has_param_356 :opt_flag
.annotate 'line', 100
    .const 'Sub' $P364 = "31_1299450604.787" 
    capture_lex $P364
    .lex "self", param_354
    .lex "$/", param_355
    if has_param_356, optparam_220
    new $P357, "Undef"
    set param_356, $P357
  optparam_220:
    .lex "$key", param_356
.annotate 'line', 101
    new $P358, "Undef"
    .lex "$past", $P358
.annotate 'line', 100
    find_lex $P359, "$past"
.annotate 'line', 102
    find_lex $P361, "$/"
    unless_null $P361, vivify_221
    $P361 = root_new ['parrot';'Hash']
  vivify_221:
    set $P362, $P361["EXPR"]
    unless_null $P362, vivify_222
    new $P362, "Undef"
  vivify_222:
    if $P362, if_360
.annotate 'line', 123
    find_lex $P425, "$/"
    unless_null $P425, vivify_223
    $P425 = root_new ['parrot';'Hash']
  vivify_223:
    set $P426, $P425["statement_control"]
    unless_null $P426, vivify_224
    new $P426, "Undef"
  vivify_224:
    if $P426, if_424
.annotate 'line', 124
    new $P430, "Integer"
    assign $P430, 0
    store_lex "$past", $P430
    goto if_424_end
  if_424:
.annotate 'line', 123
    find_lex $P427, "$/"
    unless_null $P427, vivify_225
    $P427 = root_new ['parrot';'Hash']
  vivify_225:
    set $P428, $P427["statement_control"]
    unless_null $P428, vivify_226
    new $P428, "Undef"
  vivify_226:
    $P429 = $P428."ast"()
    store_lex "$past", $P429
  if_424_end:
    goto if_360_end
  if_360:
.annotate 'line', 102
    .const 'Sub' $P364 = "31_1299450604.787" 
    capture_lex $P364
    $P364()
  if_360_end:
.annotate 'line', 125
    find_lex $P431, "$/"
    find_lex $P432, "$past"
    $P433 = $P431."!make"($P432)
.annotate 'line', 100
    .return ($P433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block363"  :anon :subid("31_1299450604.787") :outer("30_1299450604.787")
.annotate 'line', 103
    new $P365, "Undef"
    .lex "$mc", $P365
.annotate 'line', 104
    new $P366, "Undef"
    .lex "$ml", $P366
.annotate 'line', 103
    find_lex $P367, "$/"
    unless_null $P367, vivify_227
    $P367 = root_new ['parrot';'Hash']
  vivify_227:
    set $P368, $P367["statement_mod_cond"]
    unless_null $P368, vivify_228
    $P368 = root_new ['parrot';'ResizablePMCArray']
  vivify_228:
    set $P369, $P368[0]
    unless_null $P369, vivify_229
    new $P369, "Undef"
  vivify_229:
    store_lex "$mc", $P369
.annotate 'line', 104
    find_lex $P370, "$/"
    unless_null $P370, vivify_230
    $P370 = root_new ['parrot';'Hash']
  vivify_230:
    set $P371, $P370["statement_mod_loop"]
    unless_null $P371, vivify_231
    $P371 = root_new ['parrot';'ResizablePMCArray']
  vivify_231:
    set $P372, $P371[0]
    unless_null $P372, vivify_232
    new $P372, "Undef"
  vivify_232:
    store_lex "$ml", $P372
.annotate 'line', 105
    find_lex $P373, "$/"
    unless_null $P373, vivify_233
    $P373 = root_new ['parrot';'Hash']
  vivify_233:
    set $P374, $P373["EXPR"]
    unless_null $P374, vivify_234
    new $P374, "Undef"
  vivify_234:
    $P375 = $P374."ast"()
    store_lex "$past", $P375
.annotate 'line', 106
    find_lex $P377, "$mc"
    unless $P377, if_376_end
.annotate 'line', 107
    get_hll_global $P378, ["PAST"], "Op"
    find_lex $P379, "$mc"
    unless_null $P379, vivify_235
    $P379 = root_new ['parrot';'Hash']
  vivify_235:
    set $P380, $P379["cond"]
    unless_null $P380, vivify_236
    new $P380, "Undef"
  vivify_236:
    $P381 = $P380."ast"()
    find_lex $P382, "$past"
    find_lex $P383, "$mc"
    unless_null $P383, vivify_237
    $P383 = root_new ['parrot';'Hash']
  vivify_237:
    set $P384, $P383["sym"]
    unless_null $P384, vivify_238
    new $P384, "Undef"
  vivify_238:
    set $S385, $P384
    find_lex $P386, "$/"
    $P387 = $P378."new"($P381, $P382, $S385 :named("pasttype"), $P386 :named("node"))
    store_lex "$past", $P387
  if_376_end:
.annotate 'line', 109
    find_lex $P390, "$ml"
    if $P390, if_389
    set $P388, $P390
    goto if_389_end
  if_389:
.annotate 'line', 110
    find_lex $P393, "$ml"
    unless_null $P393, vivify_239
    $P393 = root_new ['parrot';'Hash']
  vivify_239:
    set $P394, $P393["sym"]
    unless_null $P394, vivify_240
    new $P394, "Undef"
  vivify_240:
    set $S395, $P394
    iseq $I396, $S395, "for"
    if $I396, if_392
.annotate 'line', 119
    get_hll_global $P414, ["PAST"], "Op"
    find_lex $P415, "$ml"
    unless_null $P415, vivify_241
    $P415 = root_new ['parrot';'Hash']
  vivify_241:
    set $P416, $P415["cond"]
    unless_null $P416, vivify_242
    new $P416, "Undef"
  vivify_242:
    $P417 = $P416."ast"()
    find_lex $P418, "$past"
    find_lex $P419, "$ml"
    unless_null $P419, vivify_243
    $P419 = root_new ['parrot';'Hash']
  vivify_243:
    set $P420, $P419["sym"]
    unless_null $P420, vivify_244
    new $P420, "Undef"
  vivify_244:
    set $S421, $P420
    find_lex $P422, "$/"
    $P423 = $P414."new"($P417, $P418, $S421 :named("pasttype"), $P422 :named("node"))
    store_lex "$past", $P423
.annotate 'line', 118
    set $P391, $P423
.annotate 'line', 110
    goto if_392_end
  if_392:
.annotate 'line', 111
    get_hll_global $P397, ["PAST"], "Block"
.annotate 'line', 112
    get_hll_global $P398, ["PAST"], "Var"
    $P399 = $P398."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P400, "$past"
    $P401 = $P397."new"($P399, $P400, "immediate" :named("blocktype"))
.annotate 'line', 111
    store_lex "$past", $P401
.annotate 'line', 114
    find_lex $P402, "$past"
    $P402."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 115
    find_lex $P403, "$past"
    $P403."arity"(1)
.annotate 'line', 116
    get_hll_global $P404, ["PAST"], "Op"
    find_lex $P405, "$ml"
    unless_null $P405, vivify_245
    $P405 = root_new ['parrot';'Hash']
  vivify_245:
    set $P406, $P405["cond"]
    unless_null $P406, vivify_246
    new $P406, "Undef"
  vivify_246:
    $P407 = $P406."ast"()
    find_lex $P408, "$past"
    find_lex $P409, "$ml"
    unless_null $P409, vivify_247
    $P409 = root_new ['parrot';'Hash']
  vivify_247:
    set $P410, $P409["sym"]
    unless_null $P410, vivify_248
    new $P410, "Undef"
  vivify_248:
    set $S411, $P410
    find_lex $P412, "$/"
    $P413 = $P404."new"($P407, $P408, $S411 :named("pasttype"), $P412 :named("node"))
    store_lex "$past", $P413
.annotate 'line', 110
    set $P391, $P413
  if_392_end:
.annotate 'line', 109
    set $P388, $P391
  if_389_end:
.annotate 'line', 102
    .return ($P388)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("32_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_435
    .param pmc param_436
.annotate 'line', 128
    .lex "self", param_435
    .lex "$/", param_436
.annotate 'line', 129
    find_lex $P437, "$/"
    get_hll_global $P438, ["PAST"], "Op"
    find_lex $P439, "$/"
    unless_null $P439, vivify_249
    $P439 = root_new ['parrot';'Hash']
  vivify_249:
    set $P440, $P439["EXPR"]
    unless_null $P440, vivify_250
    new $P440, "Undef"
  vivify_250:
    $P441 = $P440."ast"()
    find_lex $P442, "$/"
    unless_null $P442, vivify_251
    $P442 = root_new ['parrot';'Hash']
  vivify_251:
    set $P443, $P442["pblock"]
    unless_null $P443, vivify_252
    new $P443, "Undef"
  vivify_252:
    $P444 = $P443."ast"()
    find_lex $P445, "$/"
    $P446 = $P438."new"($P441, $P444, "if" :named("pasttype"), $P445 :named("node"))
    $P447 = $P437."!make"($P446)
.annotate 'line', 128
    .return ($P447)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("33_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_449
    .param pmc param_450
.annotate 'line', 132
    .lex "self", param_449
    .lex "$/", param_450
.annotate 'line', 133
    find_lex $P451, "$/"
    find_lex $P452, "$/"
    unless_null $P452, vivify_253
    $P452 = root_new ['parrot';'Hash']
  vivify_253:
    set $P453, $P452["blockoid"]
    unless_null $P453, vivify_254
    new $P453, "Undef"
  vivify_254:
    $P454 = $P453."ast"()
    $P455 = $P451."!make"($P454)
.annotate 'line', 132
    .return ($P455)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("34_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_457
    .param pmc param_458
.annotate 'line', 136
    .lex "self", param_457
    .lex "$/", param_458
.annotate 'line', 137
    find_lex $P459, "$/"
    find_lex $P460, "$/"
    unless_null $P460, vivify_255
    $P460 = root_new ['parrot';'Hash']
  vivify_255:
    set $P461, $P460["blockoid"]
    unless_null $P461, vivify_256
    new $P461, "Undef"
  vivify_256:
    $P462 = $P461."ast"()
    $P463 = $P459."!make"($P462)
.annotate 'line', 136
    .return ($P463)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("35_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_465
    .param pmc param_466
.annotate 'line', 140
    .const 'Sub' $P475 = "36_1299450604.787" 
    capture_lex $P475
    .lex "self", param_465
    .lex "$/", param_466
.annotate 'line', 141
    new $P467, "Undef"
    .lex "$BLOCK", $P467
    get_global $P468, "@BLOCK"
    $P469 = $P468."shift"()
    store_lex "$BLOCK", $P469
.annotate 'line', 142
    find_lex $P472, "$/"
    unless_null $P472, vivify_257
    $P472 = root_new ['parrot';'Hash']
  vivify_257:
    set $P473, $P472["statementlist"]
    unless_null $P473, vivify_258
    new $P473, "Undef"
  vivify_258:
    if $P473, if_471
.annotate 'line', 150
    find_dynamic_lex $P490, "$*HAS_YOU_ARE_HERE"
    unless_null $P490, vivify_259
    get_hll_global $P490, "$HAS_YOU_ARE_HERE"
    unless_null $P490, vivify_260
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_260:
  vivify_259:
    unless $P490, if_489_end
.annotate 'line', 151
    find_lex $P491, "$/"
    $P492 = $P491."CURSOR"()
    $P492."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_489_end:
.annotate 'line', 153
    new $P493, "Integer"
    assign $P493, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P493
.annotate 'line', 154
    find_lex $P494, "$/"
    find_lex $P495, "$/"
    unless_null $P495, vivify_261
    $P495 = root_new ['parrot';'Hash']
  vivify_261:
    set $P496, $P495["you_are_here"]
    unless_null $P496, vivify_262
    new $P496, "Undef"
  vivify_262:
    $P497 = $P496."ast"()
    $P498 = $P494."!make"($P497)
.annotate 'line', 149
    set $P470, $P498
.annotate 'line', 142
    goto if_471_end
  if_471:
    .const 'Sub' $P475 = "36_1299450604.787" 
    capture_lex $P475
    $P488 = $P475()
    set $P470, $P488
  if_471_end:
.annotate 'line', 140
    .return ($P470)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block474"  :anon :subid("36_1299450604.787") :outer("35_1299450604.787")
.annotate 'line', 143
    new $P476, "Undef"
    .lex "$past", $P476
    find_lex $P477, "$/"
    unless_null $P477, vivify_263
    $P477 = root_new ['parrot';'Hash']
  vivify_263:
    set $P478, $P477["statementlist"]
    unless_null $P478, vivify_264
    new $P478, "Undef"
  vivify_264:
    $P479 = $P478."ast"()
    store_lex "$past", $P479
.annotate 'line', 144
    find_lex $P480, "$BLOCK"
    find_lex $P481, "$past"
    $P480."push"($P481)
.annotate 'line', 145
    find_lex $P482, "$BLOCK"
    find_lex $P483, "$/"
    $P482."node"($P483)
.annotate 'line', 146
    find_lex $P484, "$BLOCK"
    $P484."closure"(1)
.annotate 'line', 147
    find_dynamic_lex $P485, "$/"
    find_lex $P486, "$BLOCK"
    $P487 = $P485."!make"($P486)
.annotate 'line', 142
    .return ($P487)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("37_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_500
    .param pmc param_501
.annotate 'line', 158
    .lex "self", param_500
    .lex "$/", param_501
.annotate 'line', 159
    get_global $P502, "@BLOCK"
    unless_null $P502, vivify_265
    $P502 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P502
  vivify_265:
.annotate 'line', 158
    get_global $P503, "@BLOCK"
.annotate 'line', 160
    get_global $P504, "@BLOCK"
    get_hll_global $P505, ["PAST"], "Block"
    get_hll_global $P506, ["PAST"], "Stmts"
    $P507 = $P506."new"()
    $P508 = $P505."new"($P507)
    $P509 = $P504."unshift"($P508)
.annotate 'line', 158
    .return ($P509)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("38_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_511
    .param pmc param_512
.annotate 'line', 163
    .lex "self", param_511
    .lex "$/", param_512
.annotate 'line', 164
    get_global $P513, "@BLOCK"
    unless_null $P513, vivify_266
    $P513 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P513
  vivify_266:
.annotate 'line', 163
    get_global $P514, "@BLOCK"
.annotate 'line', 165
    find_dynamic_lex $P516, "%*COMPILING"
    unless_null $P516, vivify_267
    get_hll_global $P516, "%COMPILING"
    unless_null $P516, vivify_268
    die "Contextual %*COMPILING not found"
  vivify_268:
  vivify_267:
    set $P517, $P516["%?OPTIONS"]
    unless_null $P517, vivify_269
    $P517 = root_new ['parrot';'Hash']
  vivify_269:
    set $P518, $P517["outer_ctx"]
    unless_null $P518, vivify_270
    new $P518, "Undef"
  vivify_270:
    defined $I519, $P518
    if $I519, unless_515_end
.annotate 'line', 168
    compreg $P520, "nqp"
    find_dynamic_lex $P522, "%*COMPILING"
    unless_null $P522, vivify_271
    get_hll_global $P522, "%COMPILING"
    unless_null $P522, vivify_272
    die "Contextual %*COMPILING not found"
  vivify_272:
  vivify_271:
    set $P523, $P522["%?OPTIONS"]
    unless_null $P523, vivify_273
    $P523 = root_new ['parrot';'Hash']
  vivify_273:
    set $P524, $P523["setting"]
    unless_null $P524, vivify_274
    new $P524, "Undef"
  vivify_274:
    set $P521, $P524
    defined $I526, $P521
    if $I526, default_525
    new $P527, "String"
    assign $P527, "NQPCORE"
    set $P521, $P527
  default_525:
    $P520."load_setting"($P521)
  unless_515_end:
.annotate 'line', 170
    find_lex $P528, "self"
    get_global $P529, "@BLOCK"
    unless_null $P529, vivify_275
    $P529 = root_new ['parrot';'ResizablePMCArray']
  vivify_275:
    set $P530, $P529[0]
    unless_null $P530, vivify_276
    new $P530, "Undef"
  vivify_276:
    $P531 = $P528."SET_BLOCK_OUTER_CTX"($P530)
.annotate 'line', 163
    .return ($P531)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("39_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_533
    .param pmc param_534
.annotate 'line', 173
    .lex "self", param_533
    .lex "$/", param_534
.annotate 'line', 174
    find_lex $P535, "$/"
    find_lex $P536, "self"
    $P537 = $P536."CTXSAVE"()
    $P538 = $P535."!make"($P537)
.annotate 'line', 173
    .return ($P538)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("40_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_540
    .param pmc param_541
.annotate 'line', 179
    .const 'Sub' $P569 = "41_1299450604.787" 
    capture_lex $P569
    .lex "self", param_540
    .lex "$/", param_541
.annotate 'line', 180
    new $P542, "Undef"
    .lex "$count", $P542
.annotate 'line', 181
    new $P543, "Undef"
    .lex "$past", $P543
.annotate 'line', 180
    find_lex $P544, "$/"
    unless_null $P544, vivify_277
    $P544 = root_new ['parrot';'Hash']
  vivify_277:
    set $P545, $P544["xblock"]
    unless_null $P545, vivify_278
    new $P545, "Undef"
  vivify_278:
    set $N546, $P545
    new $P547, 'Float'
    set $P547, $N546
    sub $P548, $P547, 1
    store_lex "$count", $P548
.annotate 'line', 181
    find_lex $P549, "$count"
    set $I550, $P549
    find_lex $P551, "$/"
    unless_null $P551, vivify_279
    $P551 = root_new ['parrot';'Hash']
  vivify_279:
    set $P552, $P551["xblock"]
    unless_null $P552, vivify_280
    $P552 = root_new ['parrot';'ResizablePMCArray']
  vivify_280:
    set $P553, $P552[$I550]
    unless_null $P553, vivify_281
    new $P553, "Undef"
  vivify_281:
    $P554 = $P553."ast"()
    $P555 = "xblock_immediate"($P554)
    store_lex "$past", $P555
.annotate 'line', 182
    find_lex $P557, "$/"
    unless_null $P557, vivify_282
    $P557 = root_new ['parrot';'Hash']
  vivify_282:
    set $P558, $P557["else"]
    unless_null $P558, vivify_283
    new $P558, "Undef"
  vivify_283:
    unless $P558, if_556_end
.annotate 'line', 183
    find_lex $P559, "$past"
    find_lex $P560, "$/"
    unless_null $P560, vivify_284
    $P560 = root_new ['parrot';'Hash']
  vivify_284:
    set $P561, $P560["else"]
    unless_null $P561, vivify_285
    $P561 = root_new ['parrot';'ResizablePMCArray']
  vivify_285:
    set $P562, $P561[0]
    unless_null $P562, vivify_286
    new $P562, "Undef"
  vivify_286:
    $P563 = $P562."ast"()
    $P564 = "block_immediate"($P563)
    $P559."push"($P564)
  if_556_end:
.annotate 'line', 186
    new $P585, 'ExceptionHandler'
    set_label $P585, loop584_handler
    $P585."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P585
  loop584_test:
    find_lex $P565, "$count"
    set $N566, $P565
    isgt $I567, $N566, 0.0
    unless $I567, loop584_done
  loop584_redo:
    .const 'Sub' $P569 = "41_1299450604.787" 
    capture_lex $P569
    $P569()
  loop584_next:
    goto loop584_test
  loop584_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P586, exception, 'type'
    eq $P586, .CONTROL_LOOP_NEXT, loop584_next
    eq $P586, .CONTROL_LOOP_REDO, loop584_redo
  loop584_done:
    pop_eh 
.annotate 'line', 192
    find_lex $P587, "$/"
    find_lex $P588, "$past"
    $P589 = $P587."!make"($P588)
.annotate 'line', 179
    .return ($P589)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block568"  :anon :subid("41_1299450604.787") :outer("40_1299450604.787")
.annotate 'line', 188
    new $P570, "Undef"
    .lex "$else", $P570
.annotate 'line', 186
    find_lex $P571, "$count"
    clone $P572, $P571
    dec $P571
.annotate 'line', 188
    find_lex $P573, "$past"
    store_lex "$else", $P573
.annotate 'line', 189
    find_lex $P574, "$count"
    set $I575, $P574
    find_lex $P576, "$/"
    unless_null $P576, vivify_287
    $P576 = root_new ['parrot';'Hash']
  vivify_287:
    set $P577, $P576["xblock"]
    unless_null $P577, vivify_288
    $P577 = root_new ['parrot';'ResizablePMCArray']
  vivify_288:
    set $P578, $P577[$I575]
    unless_null $P578, vivify_289
    new $P578, "Undef"
  vivify_289:
    $P579 = $P578."ast"()
    $P580 = "xblock_immediate"($P579)
    store_lex "$past", $P580
.annotate 'line', 190
    find_lex $P581, "$past"
    find_lex $P582, "$else"
    $P583 = $P581."push"($P582)
.annotate 'line', 186
    .return ($P583)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("42_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_591
    .param pmc param_592
.annotate 'line', 195
    .lex "self", param_591
    .lex "$/", param_592
.annotate 'line', 196
    new $P593, "Undef"
    .lex "$past", $P593
    find_lex $P594, "$/"
    unless_null $P594, vivify_290
    $P594 = root_new ['parrot';'Hash']
  vivify_290:
    set $P595, $P594["xblock"]
    unless_null $P595, vivify_291
    new $P595, "Undef"
  vivify_291:
    $P596 = $P595."ast"()
    $P597 = "xblock_immediate"($P596)
    store_lex "$past", $P597
.annotate 'line', 197
    find_lex $P598, "$past"
    $P598."pasttype"("unless")
.annotate 'line', 198
    find_lex $P599, "$/"
    find_lex $P600, "$past"
    $P601 = $P599."!make"($P600)
.annotate 'line', 195
    .return ($P601)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("43_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_603
    .param pmc param_604
.annotate 'line', 201
    .lex "self", param_603
    .lex "$/", param_604
.annotate 'line', 202
    new $P605, "Undef"
    .lex "$past", $P605
    find_lex $P606, "$/"
    unless_null $P606, vivify_292
    $P606 = root_new ['parrot';'Hash']
  vivify_292:
    set $P607, $P606["xblock"]
    unless_null $P607, vivify_293
    new $P607, "Undef"
  vivify_293:
    $P608 = $P607."ast"()
    $P609 = "xblock_immediate"($P608)
    store_lex "$past", $P609
.annotate 'line', 203
    find_lex $P610, "$past"
    find_lex $P611, "$/"
    unless_null $P611, vivify_294
    $P611 = root_new ['parrot';'Hash']
  vivify_294:
    set $P612, $P611["sym"]
    unless_null $P612, vivify_295
    new $P612, "Undef"
  vivify_295:
    set $S613, $P612
    $P610."pasttype"($S613)
.annotate 'line', 204
    find_lex $P614, "$/"
    find_lex $P615, "$past"
    $P616 = $P614."!make"($P615)
.annotate 'line', 201
    .return ($P616)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("44_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_618
    .param pmc param_619
.annotate 'line', 207
    .lex "self", param_618
    .lex "$/", param_619
.annotate 'line', 208
    new $P620, "Undef"
    .lex "$pasttype", $P620
.annotate 'line', 209
    new $P621, "Undef"
    .lex "$past", $P621
.annotate 'line', 208
    new $P622, "String"
    assign $P622, "repeat_"
    find_lex $P623, "$/"
    unless_null $P623, vivify_296
    $P623 = root_new ['parrot';'Hash']
  vivify_296:
    set $P624, $P623["wu"]
    unless_null $P624, vivify_297
    new $P624, "Undef"
  vivify_297:
    set $S625, $P624
    concat $P626, $P622, $S625
    store_lex "$pasttype", $P626
    find_lex $P627, "$past"
.annotate 'line', 210
    find_lex $P629, "$/"
    unless_null $P629, vivify_298
    $P629 = root_new ['parrot';'Hash']
  vivify_298:
    set $P630, $P629["xblock"]
    unless_null $P630, vivify_299
    new $P630, "Undef"
  vivify_299:
    if $P630, if_628
.annotate 'line', 215
    get_hll_global $P637, ["PAST"], "Op"
    find_lex $P638, "$/"
    unless_null $P638, vivify_300
    $P638 = root_new ['parrot';'Hash']
  vivify_300:
    set $P639, $P638["EXPR"]
    unless_null $P639, vivify_301
    new $P639, "Undef"
  vivify_301:
    $P640 = $P639."ast"()
    find_lex $P641, "$/"
    unless_null $P641, vivify_302
    $P641 = root_new ['parrot';'Hash']
  vivify_302:
    set $P642, $P641["pblock"]
    unless_null $P642, vivify_303
    new $P642, "Undef"
  vivify_303:
    $P643 = $P642."ast"()
    $P644 = "block_immediate"($P643)
    find_lex $P645, "$pasttype"
    find_lex $P646, "$/"
    $P647 = $P637."new"($P640, $P644, $P645 :named("pasttype"), $P646 :named("node"))
    store_lex "$past", $P647
.annotate 'line', 214
    goto if_628_end
  if_628:
.annotate 'line', 211
    find_lex $P631, "$/"
    unless_null $P631, vivify_304
    $P631 = root_new ['parrot';'Hash']
  vivify_304:
    set $P632, $P631["xblock"]
    unless_null $P632, vivify_305
    new $P632, "Undef"
  vivify_305:
    $P633 = $P632."ast"()
    $P634 = "xblock_immediate"($P633)
    store_lex "$past", $P634
.annotate 'line', 212
    find_lex $P635, "$past"
    find_lex $P636, "$pasttype"
    $P635."pasttype"($P636)
  if_628_end:
.annotate 'line', 218
    find_lex $P648, "$/"
    find_lex $P649, "$past"
    $P650 = $P648."!make"($P649)
.annotate 'line', 207
    .return ($P650)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("45_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_652
    .param pmc param_653
.annotate 'line', 221
    .lex "self", param_652
    .lex "$/", param_653
.annotate 'line', 222
    new $P654, "Undef"
    .lex "$past", $P654
.annotate 'line', 224
    new $P655, "Undef"
    .lex "$block", $P655
.annotate 'line', 222
    find_lex $P656, "$/"
    unless_null $P656, vivify_306
    $P656 = root_new ['parrot';'Hash']
  vivify_306:
    set $P657, $P656["xblock"]
    unless_null $P657, vivify_307
    new $P657, "Undef"
  vivify_307:
    $P658 = $P657."ast"()
    store_lex "$past", $P658
.annotate 'line', 223
    find_lex $P659, "$past"
    $P659."pasttype"("for")
.annotate 'line', 224
    find_lex $P660, "$past"
    unless_null $P660, vivify_308
    $P660 = root_new ['parrot';'ResizablePMCArray']
  vivify_308:
    set $P661, $P660[1]
    unless_null $P661, vivify_309
    new $P661, "Undef"
  vivify_309:
    store_lex "$block", $P661
.annotate 'line', 225
    find_lex $P663, "$block"
    $P664 = $P663."arity"()
    if $P664, unless_662_end
.annotate 'line', 226
    find_lex $P665, "$block"
    unless_null $P665, vivify_310
    $P665 = root_new ['parrot';'ResizablePMCArray']
  vivify_310:
    set $P666, $P665[0]
    unless_null $P666, vivify_311
    new $P666, "Undef"
  vivify_311:
    get_hll_global $P667, ["PAST"], "Var"
    $P668 = $P667."new"("$_" :named("name"), "parameter" :named("scope"))
    $P666."push"($P668)
.annotate 'line', 227
    find_lex $P669, "$block"
    $P669."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 228
    find_lex $P670, "$block"
    $P670."arity"(1)
  unless_662_end:
.annotate 'line', 230
    find_lex $P671, "$block"
    $P671."blocktype"("immediate")
.annotate 'line', 231
    find_lex $P672, "$/"
    find_lex $P673, "$past"
    $P674 = $P672."!make"($P673)
.annotate 'line', 221
    .return ($P674)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("46_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_676
    .param pmc param_677
.annotate 'line', 234
    .lex "self", param_676
    .lex "$/", param_677
.annotate 'line', 235
    new $P678, "Undef"
    .lex "$block", $P678
    find_lex $P679, "$/"
    unless_null $P679, vivify_312
    $P679 = root_new ['parrot';'Hash']
  vivify_312:
    set $P680, $P679["block"]
    unless_null $P680, vivify_313
    new $P680, "Undef"
  vivify_313:
    $P681 = $P680."ast"()
    store_lex "$block", $P681
.annotate 'line', 236
    find_lex $P682, "$/"
    find_lex $P683, "$block"
    "push_block_handler"($P682, $P683)
.annotate 'line', 237
    get_global $P684, "@BLOCK"
    unless_null $P684, vivify_314
    $P684 = root_new ['parrot';'ResizablePMCArray']
  vivify_314:
    set $P685, $P684[0]
    unless_null $P685, vivify_315
    new $P685, "Undef"
  vivify_315:
    $P686 = $P685."handlers"()
    set $P687, $P686[0]
    unless_null $P687, vivify_316
    new $P687, "Undef"
  vivify_316:
    $P687."handle_types_except"("CONTROL")
.annotate 'line', 238
    find_lex $P688, "$/"
    get_hll_global $P689, ["PAST"], "Stmts"
    find_lex $P690, "$/"
    $P691 = $P689."new"($P690 :named("node"))
    $P692 = $P688."!make"($P691)
.annotate 'line', 234
    .return ($P692)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("47_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_694
    .param pmc param_695
.annotate 'line', 241
    .lex "self", param_694
    .lex "$/", param_695
.annotate 'line', 242
    new $P696, "Undef"
    .lex "$block", $P696
    find_lex $P697, "$/"
    unless_null $P697, vivify_317
    $P697 = root_new ['parrot';'Hash']
  vivify_317:
    set $P698, $P697["block"]
    unless_null $P698, vivify_318
    new $P698, "Undef"
  vivify_318:
    $P699 = $P698."ast"()
    store_lex "$block", $P699
.annotate 'line', 243
    find_lex $P700, "$/"
    find_lex $P701, "$block"
    "push_block_handler"($P700, $P701)
.annotate 'line', 244
    get_global $P702, "@BLOCK"
    unless_null $P702, vivify_319
    $P702 = root_new ['parrot';'ResizablePMCArray']
  vivify_319:
    set $P703, $P702[0]
    unless_null $P703, vivify_320
    new $P703, "Undef"
  vivify_320:
    $P704 = $P703."handlers"()
    set $P705, $P704[0]
    unless_null $P705, vivify_321
    new $P705, "Undef"
  vivify_321:
    $P705."handle_types"("CONTROL")
.annotate 'line', 245
    find_lex $P706, "$/"
    get_hll_global $P707, ["PAST"], "Stmts"
    find_lex $P708, "$/"
    $P709 = $P707."new"($P708 :named("node"))
    $P710 = $P706."!make"($P709)
.annotate 'line', 241
    .return ($P710)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("48_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_713
    .param pmc param_714
.annotate 'line', 285
    .lex "self", param_713
    .lex "$/", param_714
.annotate 'line', 286
    new $P715, "Undef"
    .lex "$init_block", $P715
    get_hll_global $P716, ["PAST"], "Block"
    $P717 = $P716."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P717
.annotate 'line', 287
    find_lex $P718, "$init_block"
    $P719 = $P718."loadinit"()
    find_lex $P720, "$/"
    unless_null $P720, vivify_322
    $P720 = root_new ['parrot';'Hash']
  vivify_322:
    set $P721, $P720["blorst"]
    unless_null $P721, vivify_323
    new $P721, "Undef"
  vivify_323:
    $P722 = $P721."ast"()
    $P719."push"($P722)
.annotate 'line', 288
    find_lex $P723, "$/"
    find_lex $P724, "$init_block"
    $P725 = $P723."!make"($P724)
.annotate 'line', 285
    .return ($P725)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("49_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_727
    .param pmc param_728
.annotate 'line', 291
    .lex "self", param_727
    .lex "$/", param_728
.annotate 'line', 292
    new $P729, "Undef"
    .lex "$past", $P729
    find_lex $P730, "$/"
    unless_null $P730, vivify_324
    $P730 = root_new ['parrot';'Hash']
  vivify_324:
    set $P731, $P730["blorst"]
    unless_null $P731, vivify_325
    new $P731, "Undef"
  vivify_325:
    $P732 = $P731."ast"()
    store_lex "$past", $P732
.annotate 'line', 293
    get_hll_global $P734, ["PAST"], "Block"
    find_lex $P735, "$past"
    $P736 = $P734."ACCEPTS"($P735)
    if $P736, unless_733_end
.annotate 'line', 294
    get_hll_global $P737, ["PAST"], "Block"
    find_lex $P738, "$past"
    find_lex $P739, "$/"
    $P740 = $P737."new"($P738, "immediate" :named("blocktype"), $P739 :named("node"))
    store_lex "$past", $P740
  unless_733_end:
.annotate 'line', 296
    find_lex $P742, "$past"
    $P743 = $P742."handlers"()
    if $P743, unless_741_end
.annotate 'line', 297
    find_lex $P744, "$past"
    get_hll_global $P745, ["PAST"], "Control"
.annotate 'line', 299
    get_hll_global $P746, ["PAST"], "Stmts"
.annotate 'line', 300
    get_hll_global $P747, ["PAST"], "Op"
.annotate 'line', 301
    get_hll_global $P748, ["PAST"], "Var"
.annotate 'line', 302
    get_hll_global $P749, ["PAST"], "Var"
    $P750 = $P749."new"("register" :named("scope"), "exception" :named("name"))
    $P751 = $P748."new"($P750, "handled", "keyed" :named("scope"))
.annotate 'line', 301
    $P752 = $P747."new"($P751, 1, "bind" :named("pasttype"))
.annotate 'line', 300
    $P753 = $P746."new"($P752)
.annotate 'line', 299
    $P754 = $P745."new"($P753, "CONTROL" :named("handle_types_except"))
.annotate 'line', 297
    new $P755, "ResizablePMCArray"
    push $P755, $P754
    $P744."handlers"($P755)
  unless_741_end:
.annotate 'line', 311
    find_lex $P756, "$/"
    find_lex $P757, "$past"
    $P758 = $P756."!make"($P757)
.annotate 'line', 291
    .return ($P758)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("50_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_760
    .param pmc param_761
.annotate 'line', 314
    .lex "self", param_760
    .lex "$/", param_761
.annotate 'line', 315
    find_lex $P762, "$/"
.annotate 'line', 316
    find_lex $P765, "$/"
    unless_null $P765, vivify_326
    $P765 = root_new ['parrot';'Hash']
  vivify_326:
    set $P766, $P765["block"]
    unless_null $P766, vivify_327
    new $P766, "Undef"
  vivify_327:
    if $P766, if_764
.annotate 'line', 317
    find_lex $P771, "$/"
    unless_null $P771, vivify_328
    $P771 = root_new ['parrot';'Hash']
  vivify_328:
    set $P772, $P771["statement"]
    unless_null $P772, vivify_329
    new $P772, "Undef"
  vivify_329:
    $P773 = $P772."ast"()
    set $P763, $P773
.annotate 'line', 316
    goto if_764_end
  if_764:
    find_lex $P767, "$/"
    unless_null $P767, vivify_330
    $P767 = root_new ['parrot';'Hash']
  vivify_330:
    set $P768, $P767["block"]
    unless_null $P768, vivify_331
    new $P768, "Undef"
  vivify_331:
    $P769 = $P768."ast"()
    $P770 = "block_immediate"($P769)
    set $P763, $P770
  if_764_end:
    $P774 = $P762."!make"($P763)
.annotate 'line', 314
    .return ($P774)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("51_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_776
    .param pmc param_777
.annotate 'line', 322
    .lex "self", param_776
    .lex "$/", param_777
    find_lex $P778, "$/"
    find_lex $P779, "$/"
    unless_null $P779, vivify_332
    $P779 = root_new ['parrot';'Hash']
  vivify_332:
    set $P780, $P779["cond"]
    unless_null $P780, vivify_333
    new $P780, "Undef"
  vivify_333:
    $P781 = $P780."ast"()
    $P782 = $P778."!make"($P781)
    .return ($P782)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("52_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_784
    .param pmc param_785
.annotate 'line', 323
    .lex "self", param_784
    .lex "$/", param_785
    find_lex $P786, "$/"
    find_lex $P787, "$/"
    unless_null $P787, vivify_334
    $P787 = root_new ['parrot';'Hash']
  vivify_334:
    set $P788, $P787["cond"]
    unless_null $P788, vivify_335
    new $P788, "Undef"
  vivify_335:
    $P789 = $P788."ast"()
    $P790 = $P786."!make"($P789)
    .return ($P790)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("53_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_792
    .param pmc param_793
.annotate 'line', 325
    .lex "self", param_792
    .lex "$/", param_793
    find_lex $P794, "$/"
    find_lex $P795, "$/"
    unless_null $P795, vivify_336
    $P795 = root_new ['parrot';'Hash']
  vivify_336:
    set $P796, $P795["cond"]
    unless_null $P796, vivify_337
    new $P796, "Undef"
  vivify_337:
    $P797 = $P796."ast"()
    $P798 = $P794."!make"($P797)
    .return ($P798)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("54_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_800
    .param pmc param_801
.annotate 'line', 326
    .lex "self", param_800
    .lex "$/", param_801
    find_lex $P802, "$/"
    find_lex $P803, "$/"
    unless_null $P803, vivify_338
    $P803 = root_new ['parrot';'Hash']
  vivify_338:
    set $P804, $P803["cond"]
    unless_null $P804, vivify_339
    new $P804, "Undef"
  vivify_339:
    $P805 = $P804."ast"()
    $P806 = $P802."!make"($P805)
    .return ($P806)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("55_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_808
    .param pmc param_809
.annotate 'line', 330
    .lex "self", param_808
    .lex "$/", param_809
    find_lex $P810, "$/"
    find_lex $P811, "$/"
    unless_null $P811, vivify_340
    $P811 = root_new ['parrot';'Hash']
  vivify_340:
    set $P812, $P811["fatarrow"]
    unless_null $P812, vivify_341
    new $P812, "Undef"
  vivify_341:
    $P813 = $P812."ast"()
    $P814 = $P810."!make"($P813)
    .return ($P814)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("56_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_816
    .param pmc param_817
.annotate 'line', 331
    .lex "self", param_816
    .lex "$/", param_817
    find_lex $P818, "$/"
    find_lex $P819, "$/"
    unless_null $P819, vivify_342
    $P819 = root_new ['parrot';'Hash']
  vivify_342:
    set $P820, $P819["colonpair"]
    unless_null $P820, vivify_343
    new $P820, "Undef"
  vivify_343:
    $P821 = $P820."ast"()
    $P822 = $P818."!make"($P821)
    .return ($P822)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("57_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_824
    .param pmc param_825
.annotate 'line', 332
    .lex "self", param_824
    .lex "$/", param_825
    find_lex $P826, "$/"
    find_lex $P827, "$/"
    unless_null $P827, vivify_344
    $P827 = root_new ['parrot';'Hash']
  vivify_344:
    set $P828, $P827["variable"]
    unless_null $P828, vivify_345
    new $P828, "Undef"
  vivify_345:
    $P829 = $P828."ast"()
    $P830 = $P826."!make"($P829)
    .return ($P830)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("58_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_832
    .param pmc param_833
.annotate 'line', 333
    .lex "self", param_832
    .lex "$/", param_833
    find_lex $P834, "$/"
    find_lex $P835, "$/"
    unless_null $P835, vivify_346
    $P835 = root_new ['parrot';'Hash']
  vivify_346:
    set $P836, $P835["package_declarator"]
    unless_null $P836, vivify_347
    new $P836, "Undef"
  vivify_347:
    $P837 = $P836."ast"()
    $P838 = $P834."!make"($P837)
    .return ($P838)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("59_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_840
    .param pmc param_841
.annotate 'line', 334
    .lex "self", param_840
    .lex "$/", param_841
    find_lex $P842, "$/"
    find_lex $P843, "$/"
    unless_null $P843, vivify_348
    $P843 = root_new ['parrot';'Hash']
  vivify_348:
    set $P844, $P843["scope_declarator"]
    unless_null $P844, vivify_349
    new $P844, "Undef"
  vivify_349:
    $P845 = $P844."ast"()
    $P846 = $P842."!make"($P845)
    .return ($P846)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("60_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_848
    .param pmc param_849
.annotate 'line', 335
    .lex "self", param_848
    .lex "$/", param_849
    find_lex $P850, "$/"
    find_lex $P851, "$/"
    unless_null $P851, vivify_350
    $P851 = root_new ['parrot';'Hash']
  vivify_350:
    set $P852, $P851["routine_declarator"]
    unless_null $P852, vivify_351
    new $P852, "Undef"
  vivify_351:
    $P853 = $P852."ast"()
    $P854 = $P850."!make"($P853)
    .return ($P854)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("61_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_856
    .param pmc param_857
.annotate 'line', 336
    .lex "self", param_856
    .lex "$/", param_857
    find_lex $P858, "$/"
    find_lex $P859, "$/"
    unless_null $P859, vivify_352
    $P859 = root_new ['parrot';'Hash']
  vivify_352:
    set $P860, $P859["regex_declarator"]
    unless_null $P860, vivify_353
    new $P860, "Undef"
  vivify_353:
    $P861 = $P860."ast"()
    $P862 = $P858."!make"($P861)
    .return ($P862)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("62_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_864
    .param pmc param_865
.annotate 'line', 337
    .lex "self", param_864
    .lex "$/", param_865
    find_lex $P866, "$/"
    find_lex $P867, "$/"
    unless_null $P867, vivify_354
    $P867 = root_new ['parrot';'Hash']
  vivify_354:
    set $P868, $P867["statement_prefix"]
    unless_null $P868, vivify_355
    new $P868, "Undef"
  vivify_355:
    $P869 = $P868."ast"()
    $P870 = $P866."!make"($P869)
    .return ($P870)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("63_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_872
    .param pmc param_873
.annotate 'line', 338
    .lex "self", param_872
    .lex "$/", param_873
    find_lex $P874, "$/"
    find_lex $P875, "$/"
    unless_null $P875, vivify_356
    $P875 = root_new ['parrot';'Hash']
  vivify_356:
    set $P876, $P875["pblock"]
    unless_null $P876, vivify_357
    new $P876, "Undef"
  vivify_357:
    $P877 = $P876."ast"()
    $P878 = $P874."!make"($P877)
    .return ($P878)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("64_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_880
    .param pmc param_881
.annotate 'line', 340
    .lex "self", param_880
    .lex "$/", param_881
.annotate 'line', 341
    new $P882, "Undef"
    .lex "$past", $P882
    find_lex $P883, "$/"
    unless_null $P883, vivify_358
    $P883 = root_new ['parrot';'Hash']
  vivify_358:
    set $P884, $P883["val"]
    unless_null $P884, vivify_359
    new $P884, "Undef"
  vivify_359:
    $P885 = $P884."ast"()
    store_lex "$past", $P885
.annotate 'line', 342
    find_lex $P886, "$past"
    find_lex $P887, "$/"
    unless_null $P887, vivify_360
    $P887 = root_new ['parrot';'Hash']
  vivify_360:
    set $P888, $P887["key"]
    unless_null $P888, vivify_361
    new $P888, "Undef"
  vivify_361:
    $P889 = $P888."Str"()
    $P886."named"($P889)
.annotate 'line', 343
    find_lex $P890, "$/"
    find_lex $P891, "$past"
    $P892 = $P890."!make"($P891)
.annotate 'line', 340
    .return ($P892)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("65_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_894
    .param pmc param_895
.annotate 'line', 346
    .lex "self", param_894
    .lex "$/", param_895
.annotate 'line', 347
    new $P896, "Undef"
    .lex "$past", $P896
.annotate 'line', 348
    find_lex $P899, "$/"
    unless_null $P899, vivify_362
    $P899 = root_new ['parrot';'Hash']
  vivify_362:
    set $P900, $P899["circumfix"]
    unless_null $P900, vivify_363
    new $P900, "Undef"
  vivify_363:
    if $P900, if_898
.annotate 'line', 349
    get_hll_global $P905, ["PAST"], "Val"
    find_lex $P906, "$/"
    unless_null $P906, vivify_364
    $P906 = root_new ['parrot';'Hash']
  vivify_364:
    set $P907, $P906["not"]
    unless_null $P907, vivify_365
    new $P907, "Undef"
  vivify_365:
    isfalse $I908, $P907
    $P909 = $P905."new"($I908 :named("value"))
    set $P897, $P909
.annotate 'line', 348
    goto if_898_end
  if_898:
    find_lex $P901, "$/"
    unless_null $P901, vivify_366
    $P901 = root_new ['parrot';'Hash']
  vivify_366:
    set $P902, $P901["circumfix"]
    unless_null $P902, vivify_367
    $P902 = root_new ['parrot';'ResizablePMCArray']
  vivify_367:
    set $P903, $P902[0]
    unless_null $P903, vivify_368
    new $P903, "Undef"
  vivify_368:
    $P904 = $P903."ast"()
    set $P897, $P904
  if_898_end:
    store_lex "$past", $P897
.annotate 'line', 350
    find_lex $P910, "$past"
    find_lex $P911, "$/"
    unless_null $P911, vivify_369
    $P911 = root_new ['parrot';'Hash']
  vivify_369:
    set $P912, $P911["identifier"]
    unless_null $P912, vivify_370
    new $P912, "Undef"
  vivify_370:
    set $S913, $P912
    $P910."named"($S913)
.annotate 'line', 351
    find_lex $P914, "$/"
    find_lex $P915, "$past"
    $P916 = $P914."!make"($P915)
.annotate 'line', 346
    .return ($P916)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("66_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_918
    .param pmc param_919
.annotate 'line', 354
    .const 'Sub' $P932 = "67_1299450604.787" 
    capture_lex $P932
    .lex "self", param_918
    .lex "$/", param_919
.annotate 'line', 355
    new $P920, "Undef"
    .lex "$past", $P920
.annotate 'line', 354
    find_lex $P921, "$past"
.annotate 'line', 356
    find_lex $P923, "$/"
    unless_null $P923, vivify_371
    $P923 = root_new ['parrot';'Hash']
  vivify_371:
    set $P924, $P923["postcircumfix"]
    unless_null $P924, vivify_372
    new $P924, "Undef"
  vivify_372:
    if $P924, if_922
.annotate 'line', 360
    .const 'Sub' $P932 = "67_1299450604.787" 
    capture_lex $P932
    $P932()
    goto if_922_end
  if_922:
.annotate 'line', 357
    find_lex $P925, "$/"
    unless_null $P925, vivify_389
    $P925 = root_new ['parrot';'Hash']
  vivify_389:
    set $P926, $P925["postcircumfix"]
    unless_null $P926, vivify_390
    new $P926, "Undef"
  vivify_390:
    $P927 = $P926."ast"()
    store_lex "$past", $P927
.annotate 'line', 358
    find_lex $P928, "$past"
    get_hll_global $P929, ["PAST"], "Var"
    $P930 = $P929."new"("$/" :named("name"))
    $P928."unshift"($P930)
  if_922_end:
.annotate 'line', 390
    find_lex $P1004, "$/"
    find_lex $P1005, "$past"
    $P1006 = $P1004."!make"($P1005)
.annotate 'line', 354
    .return ($P1006)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block931"  :anon :subid("67_1299450604.787") :outer("66_1299450604.787")
.annotate 'line', 361
    $P933 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P933
    get_hll_global $P934, ["NQP"], "Compiler"
    find_lex $P935, "$/"
    set $S936, $P935
    $P937 = $P934."parse_name"($S936)
    store_lex "@name", $P937
.annotate 'line', 362
    get_hll_global $P938, ["PAST"], "Var"
    find_lex $P939, "@name"
    $P940 = $P939."pop"()
    set $S941, $P940
    $P942 = $P938."new"($S941 :named("name"))
    store_lex "$past", $P942
.annotate 'line', 363
    find_lex $P944, "@name"
    unless $P944, if_943_end
.annotate 'line', 364
    find_lex $P946, "@name"
    unless_null $P946, vivify_373
    $P946 = root_new ['parrot';'ResizablePMCArray']
  vivify_373:
    set $P947, $P946[0]
    unless_null $P947, vivify_374
    new $P947, "Undef"
  vivify_374:
    set $S948, $P947
    iseq $I949, $S948, "GLOBAL"
    unless $I949, if_945_end
    find_lex $P950, "@name"
    $P950."shift"()
  if_945_end:
.annotate 'line', 365
    find_lex $P951, "$past"
    find_lex $P952, "@name"
    $P951."namespace"($P952)
.annotate 'line', 366
    find_lex $P953, "$past"
    $P953."scope"("package")
.annotate 'line', 367
    find_lex $P954, "$past"
    find_lex $P955, "$/"
    unless_null $P955, vivify_375
    $P955 = root_new ['parrot';'Hash']
  vivify_375:
    set $P956, $P955["sigil"]
    unless_null $P956, vivify_376
    new $P956, "Undef"
  vivify_376:
    $P957 = "vivitype"($P956)
    $P954."viviself"($P957)
.annotate 'line', 368
    find_lex $P958, "$past"
    $P958."lvalue"(1)
  if_943_end:
.annotate 'line', 370
    find_lex $P961, "$/"
    unless_null $P961, vivify_377
    $P961 = root_new ['parrot';'Hash']
  vivify_377:
    set $P962, $P961["twigil"]
    unless_null $P962, vivify_378
    $P962 = root_new ['parrot';'ResizablePMCArray']
  vivify_378:
    set $P963, $P962[0]
    unless_null $P963, vivify_379
    new $P963, "Undef"
  vivify_379:
    set $S964, $P963
    iseq $I965, $S964, "*"
    if $I965, if_960
.annotate 'line', 383
    find_lex $P987, "$/"
    unless_null $P987, vivify_380
    $P987 = root_new ['parrot';'Hash']
  vivify_380:
    set $P988, $P987["twigil"]
    unless_null $P988, vivify_381
    $P988 = root_new ['parrot';'ResizablePMCArray']
  vivify_381:
    set $P989, $P988[0]
    unless_null $P989, vivify_382
    new $P989, "Undef"
  vivify_382:
    set $S990, $P989
    iseq $I991, $S990, "!"
    if $I991, if_986
    new $P985, 'Integer'
    set $P985, $I991
    goto if_986_end
  if_986:
.annotate 'line', 384
    find_lex $P992, "$past"
    get_hll_global $P993, ["PAST"], "Var"
    $P994 = $P993."new"("self" :named("name"))
    $P992."push"($P994)
.annotate 'line', 385
    find_lex $P995, "$past"
    $P995."scope"("attribute")
.annotate 'line', 386
    find_lex $P996, "$past"
    find_lex $P997, "$/"
    unless_null $P997, vivify_383
    $P997 = root_new ['parrot';'Hash']
  vivify_383:
    set $P998, $P997["sigil"]
    unless_null $P998, vivify_384
    new $P998, "Undef"
  vivify_384:
    $P999 = "vivitype"($P998)
    $P996."viviself"($P999)
.annotate 'line', 387
    find_lex $P1000, "$past"
    get_hll_global $P1001, ["PAST"], "Var"
    $P1002 = $P1001."new"("$?CLASS" :named("name"))
    $P1003 = $P1000."push"($P1002)
.annotate 'line', 383
    set $P985, $P1003
  if_986_end:
    set $P959, $P985
.annotate 'line', 370
    goto if_960_end
  if_960:
.annotate 'line', 371
    find_lex $P966, "$past"
    $P966."scope"("contextual")
.annotate 'line', 372
    find_lex $P967, "$past"
.annotate 'line', 373
    get_hll_global $P968, ["PAST"], "Var"
.annotate 'line', 375
    find_lex $P969, "$/"
    unless_null $P969, vivify_385
    $P969 = root_new ['parrot';'Hash']
  vivify_385:
    set $P970, $P969["sigil"]
    unless_null $P970, vivify_386
    new $P970, "Undef"
  vivify_386:
    set $S971, $P970
    new $P972, 'String'
    set $P972, $S971
    find_lex $P973, "$/"
    unless_null $P973, vivify_387
    $P973 = root_new ['parrot';'Hash']
  vivify_387:
    set $P974, $P973["desigilname"]
    unless_null $P974, vivify_388
    new $P974, "Undef"
  vivify_388:
    concat $P975, $P972, $P974
.annotate 'line', 377
    get_hll_global $P976, ["PAST"], "Op"
    new $P977, "String"
    assign $P977, "Contextual "
    find_lex $P978, "$/"
    set $S979, $P978
    concat $P980, $P977, $S979
    concat $P981, $P980, " not found"
    $P982 = $P976."new"($P981, "die" :named("pirop"))
    $P983 = $P968."new"("package" :named("scope"), "" :named("namespace"), $P975 :named("name"), $P982 :named("viviself"))
.annotate 'line', 373
    $P984 = $P967."viviself"($P983)
.annotate 'line', 370
    set $P959, $P984
  if_960_end:
.annotate 'line', 360
    .return ($P959)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("68_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1008
    .param pmc param_1009
.annotate 'line', 393
    .lex "self", param_1008
    .lex "$/", param_1009
    find_lex $P1010, "$/"
    find_lex $P1011, "$/"
    unless_null $P1011, vivify_391
    $P1011 = root_new ['parrot';'Hash']
  vivify_391:
    set $P1012, $P1011["package_def"]
    unless_null $P1012, vivify_392
    new $P1012, "Undef"
  vivify_392:
    $P1013 = $P1012."ast"()
    $P1014 = $P1010."!make"($P1013)
    .return ($P1014)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("69_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1016
    .param pmc param_1017
.annotate 'line', 394
    .lex "self", param_1016
    .lex "$/", param_1017
    find_lex $P1018, "$/"
    find_lex $P1019, "$/"
    unless_null $P1019, vivify_393
    $P1019 = root_new ['parrot';'Hash']
  vivify_393:
    set $P1020, $P1019["package_def"]
    unless_null $P1020, vivify_394
    new $P1020, "Undef"
  vivify_394:
    $P1021 = $P1020."ast"()
    $P1022 = $P1018."!make"($P1021)
    .return ($P1022)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("70_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1024
    .param pmc param_1025
.annotate 'line', 395
    .lex "self", param_1024
    .lex "$/", param_1025
    find_lex $P1026, "$/"
    find_lex $P1027, "$/"
    unless_null $P1027, vivify_395
    $P1027 = root_new ['parrot';'Hash']
  vivify_395:
    set $P1028, $P1027["package_def"]
    unless_null $P1028, vivify_396
    new $P1028, "Undef"
  vivify_396:
    $P1029 = $P1028."ast"()
    $P1030 = $P1026."!make"($P1029)
    .return ($P1030)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("71_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1032
    .param pmc param_1033
.annotate 'line', 396
    .lex "self", param_1032
    .lex "$/", param_1033
    find_lex $P1034, "$/"
    find_lex $P1035, "$/"
    unless_null $P1035, vivify_397
    $P1035 = root_new ['parrot';'Hash']
  vivify_397:
    set $P1036, $P1035["package_def"]
    unless_null $P1036, vivify_398
    new $P1036, "Undef"
  vivify_398:
    $P1037 = $P1036."ast"()
    $P1038 = $P1034."!make"($P1037)
    .return ($P1038)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("72_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1040
    .param pmc param_1041
.annotate 'line', 397
    .lex "self", param_1040
    .lex "$/", param_1041
    find_lex $P1042, "$/"
    find_lex $P1043, "$/"
    unless_null $P1043, vivify_399
    $P1043 = root_new ['parrot';'Hash']
  vivify_399:
    set $P1044, $P1043["package_def"]
    unless_null $P1044, vivify_400
    new $P1044, "Undef"
  vivify_400:
    $P1045 = $P1044."ast"()
    $P1046 = $P1042."!make"($P1045)
    .return ($P1046)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("73_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1048
    .param pmc param_1049
.annotate 'line', 398
    .lex "self", param_1048
    .lex "$/", param_1049
    find_lex $P1050, "$/"
    find_lex $P1051, "$/"
    unless_null $P1051, vivify_401
    $P1051 = root_new ['parrot';'Hash']
  vivify_401:
    set $P1052, $P1051["package_def"]
    unless_null $P1052, vivify_402
    new $P1052, "Undef"
  vivify_402:
    $P1053 = $P1052."ast"()
    $P1054 = $P1050."!make"($P1053)
    .return ($P1054)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("74_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1056
    .param pmc param_1057
.annotate 'line', 400
    .const 'Sub' $P1216 = "77_1299450604.787" 
    capture_lex $P1216
    .const 'Sub' $P1165 = "76_1299450604.787" 
    capture_lex $P1165
    .const 'Sub' $P1123 = "75_1299450604.787" 
    capture_lex $P1123
    .lex "self", param_1056
    .lex "$/", param_1057
.annotate 'line', 402
    $P1058 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1058
.annotate 'line', 403
    new $P1059, "Undef"
    .lex "$name", $P1059
.annotate 'line', 404
    new $P1060, "Undef"
    .lex "$how", $P1060
.annotate 'line', 407
    new $P1061, "Undef"
    .lex "$past", $P1061
.annotate 'line', 402
    find_lex $P1062, "$/"
    unless_null $P1062, vivify_403
    $P1062 = root_new ['parrot';'Hash']
  vivify_403:
    set $P1063, $P1062["name"]
    unless_null $P1063, vivify_404
    $P1063 = root_new ['parrot';'Hash']
  vivify_404:
    set $P1064, $P1063["identifier"]
    unless_null $P1064, vivify_405
    new $P1064, "Undef"
  vivify_405:
    clone $P1065, $P1064
    store_lex "@ns", $P1065
.annotate 'line', 403
    find_lex $P1066, "@ns"
    $P1067 = $P1066."pop"()
    set $S1068, $P1067
    new $P1069, 'String'
    set $P1069, $S1068
    store_lex "$name", $P1069
.annotate 'line', 404
    find_dynamic_lex $P1070, "$*PKGDECL"
    unless_null $P1070, vivify_406
    get_hll_global $P1070, "$PKGDECL"
    unless_null $P1070, vivify_407
    die "Contextual $*PKGDECL not found"
  vivify_407:
  vivify_406:
    find_dynamic_lex $P1071, "%*HOW"
    unless_null $P1071, vivify_408
    get_hll_global $P1071, "%HOW"
    unless_null $P1071, vivify_409
    die "Contextual %*HOW not found"
  vivify_409:
  vivify_408:
    set $P1072, $P1071[$P1070]
    unless_null $P1072, vivify_410
    new $P1072, "Undef"
  vivify_410:
    store_lex "$how", $P1072
.annotate 'line', 407
    find_lex $P1075, "$/"
    unless_null $P1075, vivify_411
    $P1075 = root_new ['parrot';'Hash']
  vivify_411:
    set $P1076, $P1075["block"]
    unless_null $P1076, vivify_412
    new $P1076, "Undef"
  vivify_412:
    if $P1076, if_1074
    find_lex $P1080, "$/"
    unless_null $P1080, vivify_413
    $P1080 = root_new ['parrot';'Hash']
  vivify_413:
    set $P1081, $P1080["comp_unit"]
    unless_null $P1081, vivify_414
    new $P1081, "Undef"
  vivify_414:
    $P1082 = $P1081."ast"()
    set $P1073, $P1082
    goto if_1074_end
  if_1074:
    find_lex $P1077, "$/"
    unless_null $P1077, vivify_415
    $P1077 = root_new ['parrot';'Hash']
  vivify_415:
    set $P1078, $P1077["block"]
    unless_null $P1078, vivify_416
    new $P1078, "Undef"
  vivify_416:
    $P1079 = $P1078."ast"()
    set $P1073, $P1079
  if_1074_end:
    store_lex "$past", $P1073
.annotate 'line', 408
    find_lex $P1083, "$past"
    find_lex $P1084, "$/"
    unless_null $P1084, vivify_417
    $P1084 = root_new ['parrot';'Hash']
  vivify_417:
    set $P1085, $P1084["name"]
    unless_null $P1085, vivify_418
    $P1085 = root_new ['parrot';'Hash']
  vivify_418:
    set $P1086, $P1085["identifier"]
    unless_null $P1086, vivify_419
    new $P1086, "Undef"
  vivify_419:
    $P1083."namespace"($P1086)
.annotate 'line', 412
    find_dynamic_lex $P1087, "$*PACKAGE-SETUP"
    unless_null $P1087, vivify_420
    get_hll_global $P1087, "$PACKAGE-SETUP"
    unless_null $P1087, vivify_421
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_421:
  vivify_420:
    get_hll_global $P1088, ["PAST"], "Stmts"
.annotate 'line', 413
    get_hll_global $P1089, ["PAST"], "Op"
.annotate 'line', 414
    get_hll_global $P1090, ["PAST"], "Var"
    $P1091 = $P1090."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 415
    get_hll_global $P1092, ["PAST"], "Op"
.annotate 'line', 417
    get_hll_global $P1093, ["PAST"], "Var"
    find_lex $P1094, "$how"
    get_how $P1095, $P1094
    find_lex $P1096, "$how"
    $P1097 = $P1095."name"($P1096)
    $P1098 = $P1093."new"($P1097 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 418
    get_hll_global $P1099, ["PAST"], "Val"
    find_lex $P1100, "$name"
    $P1101 = $P1099."new"($P1100 :named("value"), "name" :named("named"))
    $P1102 = $P1092."new"($P1098, $P1101, "callmethod" :named("pasttype"), "new_type" :named("name"))
.annotate 'line', 415
    $P1103 = $P1089."new"($P1091, $P1102, "bind" :named("pasttype"))
.annotate 'line', 421
    get_hll_global $P1104, ["PAST"], "Op"
.annotate 'line', 422
    get_hll_global $P1105, ["PAST"], "Var"
    find_lex $P1106, "$name"
    find_lex $P1107, "@ns"
    $P1108 = $P1105."new"($P1106 :named("name"), $P1107 :named("namespace"), "package" :named("scope"))
.annotate 'line', 423
    get_hll_global $P1109, ["PAST"], "Var"
    $P1110 = $P1109."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1111 = $P1104."new"($P1108, $P1110, "bind" :named("pasttype"))
.annotate 'line', 425
    get_hll_global $P1112, ["PAST"], "Op"
.annotate 'line', 426
    get_hll_global $P1113, ["PAST"], "Var"
    $P1114 = $P1113."new"("$?CLASS" :named("name"))
.annotate 'line', 427
    get_hll_global $P1115, ["PAST"], "Var"
    $P1116 = $P1115."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1117 = $P1112."new"($P1114, $P1116, "bind" :named("pasttype"))
.annotate 'line', 425
    $P1118 = $P1088."new"($P1103, $P1111, $P1117)
.annotate 'line', 412
    $P1087."unshift"($P1118)
.annotate 'line', 432
    find_lex $P1120, "$/"
    unless_null $P1120, vivify_422
    $P1120 = root_new ['parrot';'Hash']
  vivify_422:
    set $P1121, $P1120["repr"]
    unless_null $P1121, vivify_423
    new $P1121, "Undef"
  vivify_423:
    unless $P1121, if_1119_end
    .const 'Sub' $P1123 = "75_1299450604.787" 
    capture_lex $P1123
    $P1123()
  if_1119_end:
.annotate 'line', 443
    find_lex $P1139, "$how"
    can $I1140, $P1139, "parametric"
    if $I1140, if_1138
    new $P1137, 'Integer'
    set $P1137, $I1140
    goto if_1138_end
  if_1138:
    find_lex $P1141, "$how"
    find_lex $P1142, "$how"
    $P1143 = $P1141."parametric"($P1142)
    set $P1137, $P1143
  if_1138_end:
    if $P1137, if_1136
.annotate 'line', 450
    find_lex $P1156, "$past"
    $P1156."blocktype"("immediate")
.annotate 'line', 451
    find_lex $P1157, "$past"
    get_hll_global $P1158, ["PAST"], "Var"
    $P1159 = $P1158."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P1157."unshift"($P1159)
.annotate 'line', 452
    find_lex $P1160, "$past"
    $P1160."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 449
    goto if_1136_end
  if_1136:
.annotate 'line', 444
    find_lex $P1144, "$past"
    $P1144."blocktype"("declaration")
.annotate 'line', 445
    find_lex $P1145, "$past"
    get_hll_global $P1146, ["PAST"], "Var"
    $P1147 = $P1146."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P1145."unshift"($P1147)
.annotate 'line', 446
    find_lex $P1148, "$past"
    $P1148."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 447
    find_dynamic_lex $P1149, "$*PACKAGE-SETUP"
    unless_null $P1149, vivify_432
    get_hll_global $P1149, "$PACKAGE-SETUP"
    unless_null $P1149, vivify_433
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_433:
  vivify_432:
    set $P1150, $P1149[0]
    unless_null $P1150, vivify_434
    $P1150 = root_new ['parrot';'ResizablePMCArray']
  vivify_434:
    set $P1151, $P1150[0]
    unless_null $P1151, vivify_435
    $P1151 = root_new ['parrot';'ResizablePMCArray']
  vivify_435:
    set $P1152, $P1151[1]
    unless_null $P1152, vivify_436
    new $P1152, "Undef"
  vivify_436:
    get_hll_global $P1153, ["PAST"], "Val"
    find_lex $P1154, "$past"
    $P1155 = $P1153."new"($P1154 :named("value"), "body_block" :named("named"))
    $P1152."push"($P1155)
  if_1136_end:
.annotate 'line', 457
    find_lex $P1162, "$/"
    unless_null $P1162, vivify_437
    $P1162 = root_new ['parrot';'Hash']
  vivify_437:
    set $P1163, $P1162["parent"]
    unless_null $P1163, vivify_438
    new $P1163, "Undef"
  vivify_438:
    if $P1163, if_1161
.annotate 'line', 471
    find_dynamic_lex $P1193, "$*PKGDECL"
    unless_null $P1193, vivify_439
    get_hll_global $P1193, "$PKGDECL"
    unless_null $P1193, vivify_440
    die "Contextual $*PKGDECL not found"
  vivify_440:
  vivify_439:
    set $S1194, $P1193
    iseq $I1195, $S1194, "grammar"
    unless $I1195, if_1192_end
.annotate 'line', 472
    find_dynamic_lex $P1196, "$*PACKAGE-SETUP"
    unless_null $P1196, vivify_441
    get_hll_global $P1196, "$PACKAGE-SETUP"
    unless_null $P1196, vivify_442
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_442:
  vivify_441:
    get_hll_global $P1197, ["PAST"], "Op"
.annotate 'line', 474
    get_hll_global $P1198, ["PAST"], "Op"
.annotate 'line', 477
    get_hll_global $P1199, ["PAST"], "Var"
    $P1200 = $P1199."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1201 = $P1198."new"($P1200, "get_how PP" :named("pirop"))
.annotate 'line', 479
    get_hll_global $P1202, ["PAST"], "Var"
    $P1203 = $P1202."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 480
    get_hll_global $P1204, ["PAST"], "Var"
    $P1205 = $P1204."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P1206 = $P1197."new"($P1201, $P1203, $P1205, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 472
    $P1196."push"($P1206)
  if_1192_end:
.annotate 'line', 471
    goto if_1161_end
  if_1161:
.annotate 'line', 457
    .const 'Sub' $P1165 = "76_1299450604.787" 
    capture_lex $P1165
    $P1165()
  if_1161_end:
.annotate 'line', 485
    find_lex $P1208, "$/"
    unless_null $P1208, vivify_449
    $P1208 = root_new ['parrot';'Hash']
  vivify_449:
    set $P1209, $P1208["role"]
    unless_null $P1209, vivify_450
    new $P1209, "Undef"
  vivify_450:
    unless $P1209, if_1207_end
.annotate 'line', 486
    find_lex $P1211, "$/"
    unless_null $P1211, vivify_451
    $P1211 = root_new ['parrot';'Hash']
  vivify_451:
    set $P1212, $P1211["role"]
    unless_null $P1212, vivify_452
    new $P1212, "Undef"
  vivify_452:
    defined $I1213, $P1212
    unless $I1213, for_undef_453
    iter $P1210, $P1212
    new $P1243, 'ExceptionHandler'
    set_label $P1243, loop1242_handler
    $P1243."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1243
  loop1242_test:
    unless $P1210, loop1242_done
    shift $P1214, $P1210
  loop1242_redo:
    .const 'Sub' $P1216 = "77_1299450604.787" 
    capture_lex $P1216
    $P1216($P1214)
  loop1242_next:
    goto loop1242_test
  loop1242_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1244, exception, 'type'
    eq $P1244, .CONTROL_LOOP_NEXT, loop1242_next
    eq $P1244, .CONTROL_LOOP_REDO, loop1242_redo
  loop1242_done:
    pop_eh 
  for_undef_453:
  if_1207_end:
.annotate 'line', 503
    find_dynamic_lex $P1245, "$*PACKAGE-SETUP"
    unless_null $P1245, vivify_458
    get_hll_global $P1245, "$PACKAGE-SETUP"
    unless_null $P1245, vivify_459
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_459:
  vivify_458:
    get_hll_global $P1246, ["PAST"], "Op"
.annotate 'line', 505
    get_hll_global $P1247, ["PAST"], "Op"
.annotate 'line', 508
    get_hll_global $P1248, ["PAST"], "Var"
    $P1249 = $P1248."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1250 = $P1247."new"($P1249, "get_how PP" :named("pirop"))
.annotate 'line', 510
    get_hll_global $P1251, ["PAST"], "Var"
    $P1252 = $P1251."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1253 = $P1246."new"($P1250, $P1252, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 503
    $P1245."push"($P1253)
.annotate 'line', 514
    get_global $P1254, "@BLOCK"
    unless_null $P1254, vivify_460
    $P1254 = root_new ['parrot';'ResizablePMCArray']
  vivify_460:
    set $P1255, $P1254[0]
    unless_null $P1255, vivify_461
    $P1255 = root_new ['parrot';'ResizablePMCArray']
  vivify_461:
    set $P1256, $P1255[0]
    unless_null $P1256, vivify_462
    new $P1256, "Undef"
  vivify_462:
    get_hll_global $P1257, ["PAST"], "Var"
    find_lex $P1258, "$name"
    find_lex $P1259, "@ns"
    $P1260 = $P1257."new"($P1258 :named("name"), $P1259 :named("namespace"), "package" :named("scope"), 1 :named("isdecl"))
    $P1256."unshift"($P1260)
.annotate 'line', 517
    find_lex $P1261, "$past"
    $P1262 = $P1261."loadinit"()
    get_hll_global $P1263, ["PAST"], "Block"
    find_dynamic_lex $P1264, "$*PACKAGE-SETUP"
    unless_null $P1264, vivify_463
    get_hll_global $P1264, "$PACKAGE-SETUP"
    unless_null $P1264, vivify_464
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_464:
  vivify_463:
    $P1265 = $P1263."new"($P1264, "immediate" :named("blocktype"))
    $P1262."push"($P1265)
.annotate 'line', 519
    find_lex $P1266, "$/"
    find_lex $P1267, "$past"
    $P1268 = $P1266."!make"($P1267)
.annotate 'line', 400
    .return ($P1268)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1122"  :anon :subid("75_1299450604.787") :outer("74_1299450604.787")
.annotate 'line', 433
    new $P1124, "Undef"
    .lex "$repr_name", $P1124
    find_lex $P1125, "$/"
    unless_null $P1125, vivify_424
    $P1125 = root_new ['parrot';'Hash']
  vivify_424:
    set $P1126, $P1125["repr"]
    unless_null $P1126, vivify_425
    $P1126 = root_new ['parrot';'ResizablePMCArray']
  vivify_425:
    set $P1127, $P1126[0]
    unless_null $P1127, vivify_426
    new $P1127, "Undef"
  vivify_426:
    $P1128 = $P1127."ast"()
    store_lex "$repr_name", $P1128
.annotate 'line', 434
    find_lex $P1129, "$repr_name"
    $P1129."named"("repr")
.annotate 'line', 435
    find_dynamic_lex $P1130, "$*PACKAGE-SETUP"
    unless_null $P1130, vivify_427
    get_hll_global $P1130, "$PACKAGE-SETUP"
    unless_null $P1130, vivify_428
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_428:
  vivify_427:
    set $P1131, $P1130[0]
    unless_null $P1131, vivify_429
    $P1131 = root_new ['parrot';'ResizablePMCArray']
  vivify_429:
    set $P1132, $P1131[0]
    unless_null $P1132, vivify_430
    $P1132 = root_new ['parrot';'ResizablePMCArray']
  vivify_430:
    set $P1133, $P1132[1]
    unless_null $P1133, vivify_431
    new $P1133, "Undef"
  vivify_431:
    find_lex $P1134, "$repr_name"
    $P1135 = $P1133."push"($P1134)
.annotate 'line', 432
    .return ($P1135)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1164"  :anon :subid("76_1299450604.787") :outer("74_1299450604.787")
.annotate 'line', 458
    $P1166 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1166
.annotate 'line', 459
    new $P1167, "Undef"
    .lex "$name", $P1167
.annotate 'line', 458
    find_lex $P1168, "$/"
    unless_null $P1168, vivify_443
    $P1168 = root_new ['parrot';'Hash']
  vivify_443:
    set $P1169, $P1168["parent"]
    unless_null $P1169, vivify_444
    $P1169 = root_new ['parrot';'ResizablePMCArray']
  vivify_444:
    set $P1170, $P1169[0]
    unless_null $P1170, vivify_445
    $P1170 = root_new ['parrot';'Hash']
  vivify_445:
    set $P1171, $P1170["identifier"]
    unless_null $P1171, vivify_446
    new $P1171, "Undef"
  vivify_446:
    clone $P1172, $P1171
    store_lex "@ns", $P1172
.annotate 'line', 459
    find_lex $P1173, "@ns"
    $P1174 = $P1173."pop"()
    set $S1175, $P1174
    new $P1176, 'String'
    set $P1176, $S1175
    store_lex "$name", $P1176
.annotate 'line', 460
    find_dynamic_lex $P1177, "$*PACKAGE-SETUP"
    unless_null $P1177, vivify_447
    get_hll_global $P1177, "$PACKAGE-SETUP"
    unless_null $P1177, vivify_448
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_448:
  vivify_447:
    get_hll_global $P1178, ["PAST"], "Op"
.annotate 'line', 462
    get_hll_global $P1179, ["PAST"], "Op"
.annotate 'line', 465
    get_hll_global $P1180, ["PAST"], "Var"
    $P1181 = $P1180."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1182 = $P1179."new"($P1181, "get_how PP" :named("pirop"))
.annotate 'line', 467
    get_hll_global $P1183, ["PAST"], "Var"
    $P1184 = $P1183."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 468
    get_hll_global $P1185, ["PAST"], "Var"
    find_lex $P1186, "$name"
    set $S1187, $P1186
    find_lex $P1188, "@ns"
    $P1189 = $P1185."new"($S1187 :named("name"), $P1188 :named("namespace"), "package" :named("scope"))
    $P1190 = $P1178."new"($P1182, $P1184, $P1189, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 460
    $P1191 = $P1177."push"($P1190)
.annotate 'line', 457
    .return ($P1191)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1215"  :anon :subid("77_1299450604.787") :outer("74_1299450604.787")
    .param pmc param_1219
.annotate 'line', 487
    $P1217 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P1217
.annotate 'line', 488
    new $P1218, "Undef"
    .lex "$name", $P1218
    .lex "$_", param_1219
.annotate 'line', 487
    find_lex $P1220, "$_"
    unless_null $P1220, vivify_454
    $P1220 = root_new ['parrot';'Hash']
  vivify_454:
    set $P1221, $P1220["identifier"]
    unless_null $P1221, vivify_455
    new $P1221, "Undef"
  vivify_455:
    clone $P1222, $P1221
    store_lex "@ns", $P1222
.annotate 'line', 488
    find_lex $P1223, "@ns"
    $P1224 = $P1223."pop"()
    set $S1225, $P1224
    new $P1226, 'String'
    set $P1226, $S1225
    store_lex "$name", $P1226
.annotate 'line', 489
    find_dynamic_lex $P1227, "$*PACKAGE-SETUP"
    unless_null $P1227, vivify_456
    get_hll_global $P1227, "$PACKAGE-SETUP"
    unless_null $P1227, vivify_457
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_457:
  vivify_456:
    get_hll_global $P1228, ["PAST"], "Op"
.annotate 'line', 491
    get_hll_global $P1229, ["PAST"], "Op"
.annotate 'line', 494
    get_hll_global $P1230, ["PAST"], "Var"
    $P1231 = $P1230."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1232 = $P1229."new"($P1231, "get_how PP" :named("pirop"))
.annotate 'line', 496
    get_hll_global $P1233, ["PAST"], "Var"
    $P1234 = $P1233."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 497
    get_hll_global $P1235, ["PAST"], "Var"
    find_lex $P1236, "$name"
    set $S1237, $P1236
    find_lex $P1238, "@ns"
    $P1239 = $P1235."new"($S1237 :named("name"), $P1238 :named("namespace"), "package" :named("scope"))
    $P1240 = $P1228."new"($P1232, $P1234, $P1239, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 489
    $P1241 = $P1227."push"($P1240)
.annotate 'line', 486
    .return ($P1241)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("78_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1270
    .param pmc param_1271
.annotate 'line', 522
    .lex "self", param_1270
    .lex "$/", param_1271
    find_lex $P1272, "$/"
    find_lex $P1273, "$/"
    unless_null $P1273, vivify_465
    $P1273 = root_new ['parrot';'Hash']
  vivify_465:
    set $P1274, $P1273["scoped"]
    unless_null $P1274, vivify_466
    new $P1274, "Undef"
  vivify_466:
    $P1275 = $P1274."ast"()
    $P1276 = $P1272."!make"($P1275)
    .return ($P1276)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("79_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1278
    .param pmc param_1279
.annotate 'line', 523
    .lex "self", param_1278
    .lex "$/", param_1279
    find_lex $P1280, "$/"
    find_lex $P1281, "$/"
    unless_null $P1281, vivify_467
    $P1281 = root_new ['parrot';'Hash']
  vivify_467:
    set $P1282, $P1281["scoped"]
    unless_null $P1282, vivify_468
    new $P1282, "Undef"
  vivify_468:
    $P1283 = $P1282."ast"()
    $P1284 = $P1280."!make"($P1283)
    .return ($P1284)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("80_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1286
    .param pmc param_1287
.annotate 'line', 524
    .lex "self", param_1286
    .lex "$/", param_1287
    find_lex $P1288, "$/"
    find_lex $P1289, "$/"
    unless_null $P1289, vivify_469
    $P1289 = root_new ['parrot';'Hash']
  vivify_469:
    set $P1290, $P1289["scoped"]
    unless_null $P1290, vivify_470
    new $P1290, "Undef"
  vivify_470:
    $P1291 = $P1290."ast"()
    $P1292 = $P1288."!make"($P1291)
    .return ($P1292)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("81_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1294
    .param pmc param_1295
.annotate 'line', 526
    .lex "self", param_1294
    .lex "$/", param_1295
.annotate 'line', 527
    find_lex $P1296, "$/"
.annotate 'line', 528
    find_lex $P1299, "$/"
    unless_null $P1299, vivify_471
    $P1299 = root_new ['parrot';'Hash']
  vivify_471:
    set $P1300, $P1299["declarator"]
    unless_null $P1300, vivify_472
    new $P1300, "Undef"
  vivify_472:
    if $P1300, if_1298
.annotate 'line', 529
    find_lex $P1304, "$/"
    unless_null $P1304, vivify_473
    $P1304 = root_new ['parrot';'Hash']
  vivify_473:
    set $P1305, $P1304["multi_declarator"]
    unless_null $P1305, vivify_474
    new $P1305, "Undef"
  vivify_474:
    $P1306 = $P1305."ast"()
    set $P1297, $P1306
.annotate 'line', 528
    goto if_1298_end
  if_1298:
    find_lex $P1301, "$/"
    unless_null $P1301, vivify_475
    $P1301 = root_new ['parrot';'Hash']
  vivify_475:
    set $P1302, $P1301["declarator"]
    unless_null $P1302, vivify_476
    new $P1302, "Undef"
  vivify_476:
    $P1303 = $P1302."ast"()
    set $P1297, $P1303
  if_1298_end:
    $P1307 = $P1296."!make"($P1297)
.annotate 'line', 526
    .return ($P1307)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("82_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1309
    .param pmc param_1310
.annotate 'line', 532
    .lex "self", param_1309
    .lex "$/", param_1310
.annotate 'line', 533
    find_lex $P1311, "$/"
.annotate 'line', 534
    find_lex $P1314, "$/"
    unless_null $P1314, vivify_477
    $P1314 = root_new ['parrot';'Hash']
  vivify_477:
    set $P1315, $P1314["routine_declarator"]
    unless_null $P1315, vivify_478
    new $P1315, "Undef"
  vivify_478:
    if $P1315, if_1313
.annotate 'line', 535
    find_lex $P1319, "$/"
    unless_null $P1319, vivify_479
    $P1319 = root_new ['parrot';'Hash']
  vivify_479:
    set $P1320, $P1319["variable_declarator"]
    unless_null $P1320, vivify_480
    new $P1320, "Undef"
  vivify_480:
    $P1321 = $P1320."ast"()
    set $P1312, $P1321
.annotate 'line', 534
    goto if_1313_end
  if_1313:
    find_lex $P1316, "$/"
    unless_null $P1316, vivify_481
    $P1316 = root_new ['parrot';'Hash']
  vivify_481:
    set $P1317, $P1316["routine_declarator"]
    unless_null $P1317, vivify_482
    new $P1317, "Undef"
  vivify_482:
    $P1318 = $P1317."ast"()
    set $P1312, $P1318
  if_1313_end:
    $P1322 = $P1311."!make"($P1312)
.annotate 'line', 532
    .return ($P1322)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("83_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1324
    .param pmc param_1325
.annotate 'line', 538
    .lex "self", param_1324
    .lex "$/", param_1325
    find_lex $P1326, "$/"
    find_lex $P1329, "$/"
    unless_null $P1329, vivify_483
    $P1329 = root_new ['parrot';'Hash']
  vivify_483:
    set $P1330, $P1329["declarator"]
    unless_null $P1330, vivify_484
    new $P1330, "Undef"
  vivify_484:
    if $P1330, if_1328
    find_lex $P1334, "$/"
    unless_null $P1334, vivify_485
    $P1334 = root_new ['parrot';'Hash']
  vivify_485:
    set $P1335, $P1334["routine_def"]
    unless_null $P1335, vivify_486
    new $P1335, "Undef"
  vivify_486:
    $P1336 = $P1335."ast"()
    set $P1327, $P1336
    goto if_1328_end
  if_1328:
    find_lex $P1331, "$/"
    unless_null $P1331, vivify_487
    $P1331 = root_new ['parrot';'Hash']
  vivify_487:
    set $P1332, $P1331["declarator"]
    unless_null $P1332, vivify_488
    new $P1332, "Undef"
  vivify_488:
    $P1333 = $P1332."ast"()
    set $P1327, $P1333
  if_1328_end:
    $P1337 = $P1326."!make"($P1327)
    .return ($P1337)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("84_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1339
    .param pmc param_1340
.annotate 'line', 539
    .lex "self", param_1339
    .lex "$/", param_1340
    find_lex $P1341, "$/"
    find_lex $P1344, "$/"
    unless_null $P1344, vivify_489
    $P1344 = root_new ['parrot';'Hash']
  vivify_489:
    set $P1345, $P1344["declarator"]
    unless_null $P1345, vivify_490
    new $P1345, "Undef"
  vivify_490:
    if $P1345, if_1343
    find_lex $P1349, "$/"
    unless_null $P1349, vivify_491
    $P1349 = root_new ['parrot';'Hash']
  vivify_491:
    set $P1350, $P1349["routine_def"]
    unless_null $P1350, vivify_492
    new $P1350, "Undef"
  vivify_492:
    $P1351 = $P1350."ast"()
    set $P1342, $P1351
    goto if_1343_end
  if_1343:
    find_lex $P1346, "$/"
    unless_null $P1346, vivify_493
    $P1346 = root_new ['parrot';'Hash']
  vivify_493:
    set $P1347, $P1346["declarator"]
    unless_null $P1347, vivify_494
    new $P1347, "Undef"
  vivify_494:
    $P1348 = $P1347."ast"()
    set $P1342, $P1348
  if_1343_end:
    $P1352 = $P1341."!make"($P1342)
    .return ($P1352)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("85_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1354
    .param pmc param_1355
.annotate 'line', 540
    .lex "self", param_1354
    .lex "$/", param_1355
    find_lex $P1356, "$/"
    find_lex $P1357, "$/"
    unless_null $P1357, vivify_495
    $P1357 = root_new ['parrot';'Hash']
  vivify_495:
    set $P1358, $P1357["declarator"]
    unless_null $P1358, vivify_496
    new $P1358, "Undef"
  vivify_496:
    $P1359 = $P1358."ast"()
    $P1360 = $P1356."!make"($P1359)
    .return ($P1360)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("86_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1362
    .param pmc param_1363
.annotate 'line', 543
    .const 'Sub' $P1435 = "89_1299450604.787" 
    capture_lex $P1435
    .const 'Sub' $P1390 = "87_1299450604.787" 
    capture_lex $P1390
    .lex "self", param_1362
    .lex "$/", param_1363
.annotate 'line', 544
    new $P1364, "Undef"
    .lex "$past", $P1364
.annotate 'line', 545
    new $P1365, "Undef"
    .lex "$sigil", $P1365
.annotate 'line', 546
    new $P1366, "Undef"
    .lex "$name", $P1366
.annotate 'line', 547
    new $P1367, "Undef"
    .lex "$BLOCK", $P1367
.annotate 'line', 544
    find_lex $P1368, "$/"
    unless_null $P1368, vivify_497
    $P1368 = root_new ['parrot';'Hash']
  vivify_497:
    set $P1369, $P1368["variable"]
    unless_null $P1369, vivify_498
    new $P1369, "Undef"
  vivify_498:
    $P1370 = $P1369."ast"()
    store_lex "$past", $P1370
.annotate 'line', 545
    find_lex $P1371, "$/"
    unless_null $P1371, vivify_499
    $P1371 = root_new ['parrot';'Hash']
  vivify_499:
    set $P1372, $P1371["variable"]
    unless_null $P1372, vivify_500
    $P1372 = root_new ['parrot';'Hash']
  vivify_500:
    set $P1373, $P1372["sigil"]
    unless_null $P1373, vivify_501
    new $P1373, "Undef"
  vivify_501:
    store_lex "$sigil", $P1373
.annotate 'line', 546
    find_lex $P1374, "$past"
    $P1375 = $P1374."name"()
    store_lex "$name", $P1375
.annotate 'line', 547
    get_global $P1376, "@BLOCK"
    unless_null $P1376, vivify_502
    $P1376 = root_new ['parrot';'ResizablePMCArray']
  vivify_502:
    set $P1377, $P1376[0]
    unless_null $P1377, vivify_503
    new $P1377, "Undef"
  vivify_503:
    store_lex "$BLOCK", $P1377
.annotate 'line', 548
    find_lex $P1379, "$BLOCK"
    find_lex $P1380, "$name"
    $P1381 = $P1379."symbol"($P1380)
    unless $P1381, if_1378_end
.annotate 'line', 549
    find_lex $P1382, "$/"
    $P1383 = $P1382."CURSOR"()
    find_lex $P1384, "$name"
    $P1383."panic"("Redeclaration of symbol ", $P1384)
  if_1378_end:
.annotate 'line', 551
    find_dynamic_lex $P1386, "$*SCOPE"
    unless_null $P1386, vivify_504
    get_hll_global $P1386, "$SCOPE"
    unless_null $P1386, vivify_505
    die "Contextual $*SCOPE not found"
  vivify_505:
  vivify_504:
    set $S1387, $P1386
    iseq $I1388, $S1387, "has"
    if $I1388, if_1385
.annotate 'line', 576
    .const 'Sub' $P1435 = "89_1299450604.787" 
    capture_lex $P1435
    $P1435()
    goto if_1385_end
  if_1385:
.annotate 'line', 551
    .const 'Sub' $P1390 = "87_1299450604.787" 
    capture_lex $P1390
    $P1390()
  if_1385_end:
.annotate 'line', 584
    find_lex $P1459, "$/"
    find_lex $P1460, "$past"
    $P1461 = $P1459."!make"($P1460)
.annotate 'line', 543
    .return ($P1461)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1434"  :anon :subid("89_1299450604.787") :outer("86_1299450604.787")
.annotate 'line', 577
    new $P1436, "Undef"
    .lex "$scope", $P1436
.annotate 'line', 578
    new $P1437, "Undef"
    .lex "$decl", $P1437
.annotate 'line', 577
    find_dynamic_lex $P1440, "$*SCOPE"
    unless_null $P1440, vivify_506
    get_hll_global $P1440, "$SCOPE"
    unless_null $P1440, vivify_507
    die "Contextual $*SCOPE not found"
  vivify_507:
  vivify_506:
    set $S1441, $P1440
    iseq $I1442, $S1441, "our"
    if $I1442, if_1439
    new $P1444, "String"
    assign $P1444, "lexical"
    set $P1438, $P1444
    goto if_1439_end
  if_1439:
    new $P1443, "String"
    assign $P1443, "package"
    set $P1438, $P1443
  if_1439_end:
    store_lex "$scope", $P1438
.annotate 'line', 578
    get_hll_global $P1445, ["PAST"], "Var"
    find_lex $P1446, "$name"
    find_lex $P1447, "$scope"
.annotate 'line', 579
    find_lex $P1448, "$sigil"
    $P1449 = "vivitype"($P1448)
    find_lex $P1450, "$/"
    $P1451 = $P1445."new"($P1446 :named("name"), $P1447 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P1449 :named("viviself"), $P1450 :named("node"))
.annotate 'line', 578
    store_lex "$decl", $P1451
.annotate 'line', 581
    find_lex $P1452, "$BLOCK"
    find_lex $P1453, "$name"
    find_lex $P1454, "$scope"
    $P1452."symbol"($P1453, $P1454 :named("scope"))
.annotate 'line', 582
    find_lex $P1455, "$BLOCK"
    unless_null $P1455, vivify_508
    $P1455 = root_new ['parrot';'ResizablePMCArray']
  vivify_508:
    set $P1456, $P1455[0]
    unless_null $P1456, vivify_509
    new $P1456, "Undef"
  vivify_509:
    find_lex $P1457, "$decl"
    $P1458 = $P1456."push"($P1457)
.annotate 'line', 576
    .return ($P1458)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1389"  :anon :subid("87_1299450604.787") :outer("86_1299450604.787")
.annotate 'line', 551
    .const 'Sub' $P1420 = "88_1299450604.787" 
    capture_lex $P1420
.annotate 'line', 553
    new $P1391, "Undef"
    .lex "$meta-attr-type", $P1391
.annotate 'line', 561
    new $P1392, "Undef"
    .lex "$meta_args", $P1392
.annotate 'line', 553
    find_dynamic_lex $P1395, "$*PKGDECL"
    unless_null $P1395, vivify_510
    get_hll_global $P1395, "$PKGDECL"
    unless_null $P1395, vivify_511
    die "Contextual $*PKGDECL not found"
  vivify_511:
  vivify_510:
    find_dynamic_lex $P1396, "%*HOW-METAATTR"
    unless_null $P1396, vivify_512
    get_hll_global $P1396, "%HOW-METAATTR"
    unless_null $P1396, vivify_513
    die "Contextual %*HOW-METAATTR not found"
  vivify_513:
  vivify_512:
    set $P1397, $P1396[$P1395]
    unless_null $P1397, vivify_514
    new $P1397, "Undef"
  vivify_514:
    unless $P1397, unless_1394
    set $P1393, $P1397
    goto unless_1394_end
  unless_1394:
    find_dynamic_lex $P1398, "$*DEFAULT-METAATTR"
    unless_null $P1398, vivify_515
    get_hll_global $P1398, "$DEFAULT-METAATTR"
    unless_null $P1398, vivify_516
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_516:
  vivify_515:
    set $P1393, $P1398
  unless_1394_end:
    store_lex "$meta-attr-type", $P1393
.annotate 'line', 554
    find_dynamic_lex $P1399, "$*PACKAGE-SETUP"
    unless_null $P1399, vivify_517
    get_hll_global $P1399, "$PACKAGE-SETUP"
    unless_null $P1399, vivify_518
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_518:
  vivify_517:
    get_hll_global $P1400, ["PAST"], "Op"
.annotate 'line', 556
    get_hll_global $P1401, ["PAST"], "Op"
.annotate 'line', 558
    get_hll_global $P1402, ["PAST"], "Var"
    $P1403 = $P1402."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1404 = $P1401."new"($P1403, "get_how PP" :named("pirop"))
.annotate 'line', 560
    get_hll_global $P1405, ["PAST"], "Var"
    $P1406 = $P1405."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 561
    get_hll_global $P1407, ["PAST"], "Op"
.annotate 'line', 563
    get_hll_global $P1408, ["PAST"], "Var"
    find_lex $P1409, "$meta-attr-type"
    $P1410 = $P1408."new"($P1409 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 564
    get_hll_global $P1411, ["PAST"], "Val"
    find_lex $P1412, "$name"
    $P1413 = $P1411."new"($P1412 :named("value"), "name" :named("named"))
    $P1414 = $P1407."new"($P1410, $P1413, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 561
    store_lex "$meta_args", $P1414
    $P1415 = $P1400."new"($P1404, $P1406, $P1414, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 554
    $P1399."push"($P1415)
.annotate 'line', 567
    find_lex $P1417, "$/"
    unless_null $P1417, vivify_519
    $P1417 = root_new ['parrot';'Hash']
  vivify_519:
    set $P1418, $P1417["typename"]
    unless_null $P1418, vivify_520
    new $P1418, "Undef"
  vivify_520:
    unless $P1418, if_1416_end
    .const 'Sub' $P1420 = "88_1299450604.787" 
    capture_lex $P1420
    $P1420()
  if_1416_end:
.annotate 'line', 573
    find_lex $P1430, "$BLOCK"
    find_lex $P1431, "$name"
    $P1430."symbol"($P1431, "attribute" :named("scope"))
.annotate 'line', 574
    get_hll_global $P1432, ["PAST"], "Stmts"
    $P1433 = $P1432."new"()
    store_lex "$past", $P1433
.annotate 'line', 551
    .return ($P1433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1419"  :anon :subid("88_1299450604.787") :outer("87_1299450604.787")
.annotate 'line', 568
    new $P1421, "Undef"
    .lex "$type", $P1421
    find_lex $P1422, "$/"
    unless_null $P1422, vivify_521
    $P1422 = root_new ['parrot';'Hash']
  vivify_521:
    set $P1423, $P1422["typename"]
    unless_null $P1423, vivify_522
    $P1423 = root_new ['parrot';'ResizablePMCArray']
  vivify_522:
    set $P1424, $P1423[0]
    unless_null $P1424, vivify_523
    new $P1424, "Undef"
  vivify_523:
    $P1425 = $P1424."ast"()
    store_lex "$type", $P1425
.annotate 'line', 569
    find_lex $P1426, "$type"
    $P1426."named"("type")
.annotate 'line', 570
    find_lex $P1427, "$meta_args"
    find_lex $P1428, "$type"
    $P1429 = $P1427."push"($P1428)
.annotate 'line', 567
    .return ($P1429)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("90_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1463
    .param pmc param_1464
.annotate 'line', 587
    .lex "self", param_1463
    .lex "$/", param_1464
    find_lex $P1465, "$/"
    find_lex $P1466, "$/"
    unless_null $P1466, vivify_524
    $P1466 = root_new ['parrot';'Hash']
  vivify_524:
    set $P1467, $P1466["routine_def"]
    unless_null $P1467, vivify_525
    new $P1467, "Undef"
  vivify_525:
    $P1468 = $P1467."ast"()
    $P1469 = $P1465."!make"($P1468)
    .return ($P1469)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("91_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1471
    .param pmc param_1472
.annotate 'line', 588
    .lex "self", param_1471
    .lex "$/", param_1472
    find_lex $P1473, "$/"
    find_lex $P1474, "$/"
    unless_null $P1474, vivify_526
    $P1474 = root_new ['parrot';'Hash']
  vivify_526:
    set $P1475, $P1474["method_def"]
    unless_null $P1475, vivify_527
    new $P1475, "Undef"
  vivify_527:
    $P1476 = $P1475."ast"()
    $P1477 = $P1473."!make"($P1476)
    .return ($P1477)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("92_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1479
    .param pmc param_1480
.annotate 'line', 590
    .const 'Sub' $P1708 = "98_1299450604.787" 
    capture_lex $P1708
    .const 'Sub' $P1500 = "93_1299450604.787" 
    capture_lex $P1500
    .lex "self", param_1479
    .lex "$/", param_1480
.annotate 'line', 593
    new $P1481, "Undef"
    .lex "$past", $P1481
.annotate 'line', 604
    new $P1482, "Undef"
    .lex "$block", $P1482
.annotate 'line', 590
    find_lex $P1483, "$past"
.annotate 'line', 594
    find_lex $P1485, "$/"
    unless_null $P1485, vivify_528
    $P1485 = root_new ['parrot';'Hash']
  vivify_528:
    set $P1486, $P1485["onlystar"]
    unless_null $P1486, vivify_529
    new $P1486, "Undef"
  vivify_529:
    if $P1486, if_1484
.annotate 'line', 598
    find_lex $P1488, "$/"
    unless_null $P1488, vivify_530
    $P1488 = root_new ['parrot';'Hash']
  vivify_530:
    set $P1489, $P1488["blockoid"]
    unless_null $P1489, vivify_531
    new $P1489, "Undef"
  vivify_531:
    $P1490 = $P1489."ast"()
    store_lex "$past", $P1490
.annotate 'line', 599
    find_lex $P1491, "$past"
    $P1491."blocktype"("declaration")
.annotate 'line', 600
    find_dynamic_lex $P1493, "$*RETURN_USED"
    unless_null $P1493, vivify_532
    get_hll_global $P1493, "$RETURN_USED"
    unless_null $P1493, vivify_533
    die "Contextual $*RETURN_USED not found"
  vivify_533:
  vivify_532:
    unless $P1493, if_1492_end
.annotate 'line', 601
    find_lex $P1494, "$past"
    $P1494."control"("return_pir")
  if_1492_end:
.annotate 'line', 597
    goto if_1484_end
  if_1484:
.annotate 'line', 595
    $P1487 = "only_star_block"()
    store_lex "$past", $P1487
  if_1484_end:
.annotate 'line', 604
    find_lex $P1495, "$past"
    store_lex "$block", $P1495
.annotate 'line', 606
    find_lex $P1497, "$/"
    unless_null $P1497, vivify_534
    $P1497 = root_new ['parrot';'Hash']
  vivify_534:
    set $P1498, $P1497["deflongname"]
    unless_null $P1498, vivify_535
    new $P1498, "Undef"
  vivify_535:
    unless $P1498, if_1496_end
    .const 'Sub' $P1500 = "93_1299450604.787" 
    capture_lex $P1500
    $P1500()
  if_1496_end:
.annotate 'line', 706
    find_lex $P1697, "$block"
    find_lex $P1698, "$past"
    unless_null $P1698, vivify_596
    $P1698 = root_new ['parrot';'Hash']
    store_lex "$past", $P1698
  vivify_596:
    set $P1698["block_past"], $P1697
.annotate 'line', 707
    find_lex $P1700, "$/"
    unless_null $P1700, vivify_597
    $P1700 = root_new ['parrot';'Hash']
  vivify_597:
    set $P1701, $P1700["trait"]
    unless_null $P1701, vivify_598
    new $P1701, "Undef"
  vivify_598:
    unless $P1701, if_1699_end
.annotate 'line', 708
    find_lex $P1703, "$/"
    unless_null $P1703, vivify_599
    $P1703 = root_new ['parrot';'Hash']
  vivify_599:
    set $P1704, $P1703["trait"]
    unless_null $P1704, vivify_600
    new $P1704, "Undef"
  vivify_600:
    defined $I1705, $P1704
    unless $I1705, for_undef_601
    iter $P1702, $P1704
    new $P1715, 'ExceptionHandler'
    set_label $P1715, loop1714_handler
    $P1715."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1715
  loop1714_test:
    unless $P1702, loop1714_done
    shift $P1706, $P1702
  loop1714_redo:
    .const 'Sub' $P1708 = "98_1299450604.787" 
    capture_lex $P1708
    $P1708($P1706)
  loop1714_next:
    goto loop1714_test
  loop1714_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1716, exception, 'type'
    eq $P1716, .CONTROL_LOOP_NEXT, loop1714_next
    eq $P1716, .CONTROL_LOOP_REDO, loop1714_redo
  loop1714_done:
    pop_eh 
  for_undef_601:
  if_1699_end:
.annotate 'line', 711
    find_lex $P1717, "$/"
    find_lex $P1718, "$past"
    $P1719 = $P1717."!make"($P1718)
.annotate 'line', 590
    .return ($P1719)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1499"  :anon :subid("93_1299450604.787") :outer("92_1299450604.787")
.annotate 'line', 606
    .const 'Sub' $P1623 = "97_1299450604.787" 
    capture_lex $P1623
    .const 'Sub' $P1534 = "94_1299450604.787" 
    capture_lex $P1534
.annotate 'line', 607
    new $P1501, "Undef"
    .lex "$name", $P1501
    find_lex $P1502, "$/"
    unless_null $P1502, vivify_536
    $P1502 = root_new ['parrot';'Hash']
  vivify_536:
    set $P1503, $P1502["sigil"]
    unless_null $P1503, vivify_537
    $P1503 = root_new ['parrot';'ResizablePMCArray']
  vivify_537:
    set $P1504, $P1503[0]
    unless_null $P1504, vivify_538
    new $P1504, "Undef"
  vivify_538:
    set $S1505, $P1504
    new $P1506, 'String'
    set $P1506, $S1505
    find_lex $P1507, "$/"
    unless_null $P1507, vivify_539
    $P1507 = root_new ['parrot';'Hash']
  vivify_539:
    set $P1508, $P1507["deflongname"]
    unless_null $P1508, vivify_540
    $P1508 = root_new ['parrot';'ResizablePMCArray']
  vivify_540:
    set $P1509, $P1508[0]
    unless_null $P1509, vivify_541
    new $P1509, "Undef"
  vivify_541:
    $S1510 = $P1509."ast"()
    concat $P1511, $P1506, $S1510
    store_lex "$name", $P1511
.annotate 'line', 608
    find_lex $P1512, "$past"
    find_lex $P1513, "$name"
    $P1512."name"($P1513)
.annotate 'line', 609
    find_dynamic_lex $P1520, "$*SCOPE"
    unless_null $P1520, vivify_542
    get_hll_global $P1520, "$SCOPE"
    unless_null $P1520, vivify_543
    die "Contextual $*SCOPE not found"
  vivify_543:
  vivify_542:
    set $S1521, $P1520
    iseq $I1522, $S1521, ""
    unless $I1522, unless_1519
    new $P1518, 'Integer'
    set $P1518, $I1522
    goto unless_1519_end
  unless_1519:
    find_dynamic_lex $P1523, "$*SCOPE"
    unless_null $P1523, vivify_544
    get_hll_global $P1523, "$SCOPE"
    unless_null $P1523, vivify_545
    die "Contextual $*SCOPE not found"
  vivify_545:
  vivify_544:
    set $S1524, $P1523
    iseq $I1525, $S1524, "my"
    new $P1518, 'Integer'
    set $P1518, $I1525
  unless_1519_end:
    unless $P1518, unless_1517
    set $P1516, $P1518
    goto unless_1517_end
  unless_1517:
    find_dynamic_lex $P1526, "$*SCOPE"
    unless_null $P1526, vivify_546
    get_hll_global $P1526, "$SCOPE"
    unless_null $P1526, vivify_547
    die "Contextual $*SCOPE not found"
  vivify_547:
  vivify_546:
    set $S1527, $P1526
    iseq $I1528, $S1527, "our"
    new $P1516, 'Integer'
    set $P1516, $I1528
  unless_1517_end:
    if $P1516, if_1515
.annotate 'line', 701
    find_lex $P1692, "$/"
    $P1693 = $P1692."CURSOR"()
    find_dynamic_lex $P1694, "$*SCOPE"
    unless_null $P1694, vivify_548
    get_hll_global $P1694, "$SCOPE"
    unless_null $P1694, vivify_549
    die "Contextual $*SCOPE not found"
  vivify_549:
  vivify_548:
    concat $P1695, $P1694, " scoped routines are not supported yet"
    $P1696 = $P1693."panic"($P1695)
.annotate 'line', 700
    set $P1514, $P1696
.annotate 'line', 609
    goto if_1515_end
  if_1515:
.annotate 'line', 610
    find_dynamic_lex $P1530, "$*MULTINESS"
    unless_null $P1530, vivify_550
    get_hll_global $P1530, "$MULTINESS"
    unless_null $P1530, vivify_551
    die "Contextual $*MULTINESS not found"
  vivify_551:
  vivify_550:
    set $S1531, $P1530
    iseq $I1532, $S1531, "multi"
    if $I1532, if_1529
.annotate 'line', 661
    find_dynamic_lex $P1619, "$*MULTINESS"
    unless_null $P1619, vivify_552
    get_hll_global $P1619, "$MULTINESS"
    unless_null $P1619, vivify_553
    die "Contextual $*MULTINESS not found"
  vivify_553:
  vivify_552:
    set $S1620, $P1619
    iseq $I1621, $S1620, "proto"
    if $I1621, if_1618
.annotate 'line', 680
    get_global $P1653, "@BLOCK"
    unless_null $P1653, vivify_554
    $P1653 = root_new ['parrot';'ResizablePMCArray']
  vivify_554:
    set $P1654, $P1653[0]
    unless_null $P1654, vivify_555
    $P1654 = root_new ['parrot';'ResizablePMCArray']
  vivify_555:
    set $P1655, $P1654[0]
    unless_null $P1655, vivify_556
    new $P1655, "Undef"
  vivify_556:
    get_hll_global $P1656, ["PAST"], "Var"
    find_lex $P1657, "$name"
    find_lex $P1658, "$past"
    $P1659 = $P1656."new"($P1657 :named("name"), 1 :named("isdecl"), $P1658 :named("viviself"), "lexical" :named("scope"))
    $P1655."push"($P1659)
.annotate 'line', 682
    get_global $P1660, "@BLOCK"
    unless_null $P1660, vivify_557
    $P1660 = root_new ['parrot';'ResizablePMCArray']
  vivify_557:
    set $P1661, $P1660[0]
    unless_null $P1661, vivify_558
    new $P1661, "Undef"
  vivify_558:
    find_lex $P1662, "$name"
    $P1661."symbol"($P1662, "lexical" :named("scope"))
.annotate 'line', 683
    find_dynamic_lex $P1664, "$*SCOPE"
    unless_null $P1664, vivify_559
    get_hll_global $P1664, "$SCOPE"
    unless_null $P1664, vivify_560
    die "Contextual $*SCOPE not found"
  vivify_560:
  vivify_559:
    set $S1665, $P1664
    iseq $I1666, $S1665, "our"
    unless $I1666, if_1663_end
.annotate 'line', 686
    get_global $P1667, "@BLOCK"
    unless_null $P1667, vivify_561
    $P1667 = root_new ['parrot';'ResizablePMCArray']
  vivify_561:
    set $P1668, $P1667[0]
    unless_null $P1668, vivify_562
    $P1668 = root_new ['parrot';'ResizablePMCArray']
  vivify_562:
    set $P1669, $P1668[0]
    unless_null $P1669, vivify_563
    new $P1669, "Undef"
  vivify_563:
    get_hll_global $P1670, ["PAST"], "Op"
.annotate 'line', 688
    get_hll_global $P1671, ["PAST"], "Var"
    find_lex $P1672, "$name"
    $P1673 = $P1671."new"($P1672 :named("name"), "package" :named("scope"))
.annotate 'line', 689
    get_hll_global $P1674, ["PAST"], "Var"
    find_lex $P1675, "$name"
    $P1676 = $P1674."new"($P1675 :named("name"), "lexical" :named("scope"))
    $P1677 = $P1670."new"($P1673, $P1676, "bind" :named("pasttype"))
.annotate 'line', 686
    $P1669."push"($P1677)
.annotate 'line', 691
    get_global $P1678, "@BLOCK"
    unless_null $P1678, vivify_564
    $P1678 = root_new ['parrot';'ResizablePMCArray']
  vivify_564:
    set $P1679, $P1678[0]
    unless_null $P1679, vivify_565
    new $P1679, "Undef"
  vivify_565:
    $P1680 = $P1679."loadinit"()
    get_hll_global $P1681, ["PAST"], "Op"
.annotate 'line', 693
    get_hll_global $P1682, ["PAST"], "Var"
    find_lex $P1683, "$name"
    $P1684 = $P1682."new"($P1683 :named("name"), "package" :named("scope"))
.annotate 'line', 694
    get_hll_global $P1685, ["PAST"], "Val"
    find_lex $P1686, "$past"
    $P1687 = $P1685."new"($P1686 :named("value"))
    $P1688 = $P1681."new"($P1684, $P1687, "bind" :named("pasttype"))
.annotate 'line', 691
    $P1680."push"($P1688)
  if_1663_end:
.annotate 'line', 679
    goto if_1618_end
  if_1618:
.annotate 'line', 661
    .const 'Sub' $P1623 = "97_1299450604.787" 
    capture_lex $P1623
    $P1623()
  if_1618_end:
    goto if_1529_end
  if_1529:
.annotate 'line', 610
    .const 'Sub' $P1534 = "94_1299450604.787" 
    capture_lex $P1534
    $P1534()
  if_1529_end:
.annotate 'line', 698
    get_hll_global $P1689, ["PAST"], "Var"
    find_lex $P1690, "$name"
    $P1691 = $P1689."new"($P1690 :named("name"))
    store_lex "$past", $P1691
.annotate 'line', 609
    set $P1514, $P1691
  if_1515_end:
.annotate 'line', 606
    .return ($P1514)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1622"  :anon :subid("97_1299450604.787") :outer("93_1299450604.787")
.annotate 'line', 666
    new $P1624, "Undef"
    .lex "$cholder", $P1624
.annotate 'line', 665
    find_dynamic_lex $P1626, "$*SCOPE"
    unless_null $P1626, vivify_566
    get_hll_global $P1626, "$SCOPE"
    unless_null $P1626, vivify_567
    die "Contextual $*SCOPE not found"
  vivify_567:
  vivify_566:
    set $S1627, $P1626
    iseq $I1628, $S1627, "our"
    unless $I1628, if_1625_end
    die "our-scoped protos not yet implemented"
  if_1625_end:
.annotate 'line', 666
    get_hll_global $P1629, ["PAST"], "Op"
    $P1630 = $P1629."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1630
.annotate 'line', 667
    get_global $P1631, "@BLOCK"
    unless_null $P1631, vivify_568
    $P1631 = root_new ['parrot';'ResizablePMCArray']
  vivify_568:
    set $P1632, $P1631[0]
    unless_null $P1632, vivify_569
    $P1632 = root_new ['parrot';'ResizablePMCArray']
  vivify_569:
    set $P1633, $P1632[0]
    unless_null $P1633, vivify_570
    new $P1633, "Undef"
  vivify_570:
    get_hll_global $P1634, ["PAST"], "Var"
    find_lex $P1635, "$name"
    find_lex $P1636, "$past"
    $P1637 = $P1634."new"($P1635 :named("name"), 1 :named("isdecl"), $P1636 :named("viviself"), "lexical" :named("scope"))
    $P1633."push"($P1637)
.annotate 'line', 669
    get_global $P1638, "@BLOCK"
    unless_null $P1638, vivify_571
    $P1638 = root_new ['parrot';'ResizablePMCArray']
  vivify_571:
    set $P1639, $P1638[0]
    unless_null $P1639, vivify_572
    $P1639 = root_new ['parrot';'ResizablePMCArray']
  vivify_572:
    set $P1640, $P1639[0]
    unless_null $P1640, vivify_573
    new $P1640, "Undef"
  vivify_573:
    get_hll_global $P1641, ["PAST"], "Op"
.annotate 'line', 671
    get_hll_global $P1642, ["PAST"], "Var"
    find_lex $P1643, "$name"
    $P1644 = $P1642."new"($P1643 :named("name"))
    find_lex $P1645, "$cholder"
    $P1646 = $P1641."new"($P1644, $P1645, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 669
    $P1640."push"($P1646)
.annotate 'line', 674
    get_global $P1647, "@BLOCK"
    unless_null $P1647, vivify_574
    $P1647 = root_new ['parrot';'ResizablePMCArray']
  vivify_574:
    set $P1648, $P1647[0]
    unless_null $P1648, vivify_575
    new $P1648, "Undef"
  vivify_575:
    find_lex $P1649, "$name"
    find_lex $P1650, "$cholder"
    $P1648."symbol"($P1649, "lexical" :named("scope"), 1 :named("proto"), $P1650 :named("cholder"))
.annotate 'line', 677
    find_lex $P1651, "$past"
    $P1652 = $P1651."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 661
    .return ($P1652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1533"  :anon :subid("94_1299450604.787") :outer("93_1299450604.787")
.annotate 'line', 610
    .const 'Sub' $P1552 = "95_1299450604.787" 
    capture_lex $P1552
.annotate 'line', 613
    new $P1535, "Undef"
    .lex "$cholder", $P1535
.annotate 'line', 614
    $P1536 = root_new ['parrot';'Hash']
    .lex "%sym", $P1536
.annotate 'line', 612
    find_dynamic_lex $P1538, "$*SCOPE"
    unless_null $P1538, vivify_576
    get_hll_global $P1538, "$SCOPE"
    unless_null $P1538, vivify_577
    die "Contextual $*SCOPE not found"
  vivify_577:
  vivify_576:
    set $S1539, $P1538
    iseq $I1540, $S1539, "our"
    unless $I1540, if_1537_end
    die "our-scoped multis not yet implemented"
  if_1537_end:
    find_lex $P1541, "$cholder"
.annotate 'line', 614
    get_global $P1542, "@BLOCK"
    unless_null $P1542, vivify_578
    $P1542 = root_new ['parrot';'ResizablePMCArray']
  vivify_578:
    set $P1543, $P1542[0]
    unless_null $P1543, vivify_579
    new $P1543, "Undef"
  vivify_579:
    find_lex $P1544, "$name"
    $P1545 = $P1543."symbol"($P1544)
    store_lex "%sym", $P1545
.annotate 'line', 615
    find_lex $P1547, "%sym"
    unless_null $P1547, vivify_580
    $P1547 = root_new ['parrot';'Hash']
  vivify_580:
    set $P1548, $P1547["cholder"]
    unless_null $P1548, vivify_581
    new $P1548, "Undef"
  vivify_581:
    if $P1548, if_1546
.annotate 'line', 620
    .const 'Sub' $P1552 = "95_1299450604.787" 
    capture_lex $P1552
    $P1552()
    goto if_1546_end
  if_1546:
.annotate 'line', 616
    find_lex $P1549, "%sym"
    unless_null $P1549, vivify_594
    $P1549 = root_new ['parrot';'Hash']
  vivify_594:
    set $P1550, $P1549["cholder"]
    unless_null $P1550, vivify_595
    new $P1550, "Undef"
  vivify_595:
    store_lex "$cholder", $P1550
  if_1546_end:
.annotate 'line', 656
    find_lex $P1614, "$cholder"
    find_lex $P1615, "$past"
    $P1614."push"($P1615)
.annotate 'line', 659
    find_lex $P1616, "$past"
    $P1617 = "attach_multi_signature"($P1616)
.annotate 'line', 610
    .return ($P1617)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block1551"  :anon :subid("95_1299450604.787") :outer("94_1299450604.787")
.annotate 'line', 620
    .const 'Sub' $P1566 = "96_1299450604.787" 
    capture_lex $P1566
.annotate 'line', 627
    new $P1553, "Undef"
    .lex "$found_proto", $P1553
.annotate 'line', 645
    new $P1554, "Undef"
    .lex "$dispatch_setup", $P1554
.annotate 'line', 622
    find_lex $P1556, "%sym"
    unless_null $P1556, vivify_582
    $P1556 = root_new ['parrot';'Hash']
  vivify_582:
    set $P1557, $P1556["proto"]
    unless_null $P1557, vivify_583
    new $P1557, "Undef"
  vivify_583:
    unless $P1557, if_1555_end
.annotate 'line', 625
    find_lex $P1558, "$/"
    $P1559 = $P1558."CURSOR"()
    $P1559."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_1555_end:
.annotate 'line', 622
    find_lex $P1560, "$found_proto"
.annotate 'line', 628
    get_global $P1562, "@BLOCK"
    defined $I1563, $P1562
    unless $I1563, for_undef_584
    iter $P1561, $P1562
    new $P1588, 'ExceptionHandler'
    set_label $P1588, loop1587_handler
    $P1588."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1588
  loop1587_test:
    unless $P1561, loop1587_done
    shift $P1564, $P1561
  loop1587_redo:
    .const 'Sub' $P1566 = "96_1299450604.787" 
    capture_lex $P1566
    $P1566($P1564)
  loop1587_next:
    goto loop1587_test
  loop1587_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1589, exception, 'type'
    eq $P1589, .CONTROL_LOOP_NEXT, loop1587_next
    eq $P1589, .CONTROL_LOOP_REDO, loop1587_redo
  loop1587_done:
    pop_eh 
  for_undef_584:
.annotate 'line', 639
    find_lex $P1591, "$found_proto"
    if $P1591, unless_1590_end
.annotate 'line', 640
    find_lex $P1592, "$/"
    $P1593 = $P1592."CURSOR"()
    $P1593."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_1590_end:
.annotate 'line', 644
    get_hll_global $P1594, ["PAST"], "Op"
    $P1595 = $P1594."new"("list" :named("pasttype"))
    store_lex "$cholder", $P1595
.annotate 'line', 645
    get_hll_global $P1596, ["PAST"], "Op"
.annotate 'line', 647
    get_hll_global $P1597, ["PAST"], "Var"
    find_lex $P1598, "$name"
    $P1599 = $P1597."new"($P1598 :named("name"), "outer" :named("scope"))
    find_lex $P1600, "$cholder"
    $P1601 = $P1596."new"($P1599, $P1600, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 645
    store_lex "$dispatch_setup", $P1601
.annotate 'line', 650
    get_global $P1602, "@BLOCK"
    unless_null $P1602, vivify_589
    $P1602 = root_new ['parrot';'ResizablePMCArray']
  vivify_589:
    set $P1603, $P1602[0]
    unless_null $P1603, vivify_590
    $P1603 = root_new ['parrot';'ResizablePMCArray']
  vivify_590:
    set $P1604, $P1603[0]
    unless_null $P1604, vivify_591
    new $P1604, "Undef"
  vivify_591:
    get_hll_global $P1605, ["PAST"], "Var"
    find_lex $P1606, "$name"
    find_lex $P1607, "$dispatch_setup"
    $P1608 = $P1605."new"($P1606 :named("name"), 1 :named("isdecl"), $P1607 :named("viviself"), "lexical" :named("scope"))
    $P1604."push"($P1608)
.annotate 'line', 652
    get_global $P1609, "@BLOCK"
    unless_null $P1609, vivify_592
    $P1609 = root_new ['parrot';'ResizablePMCArray']
  vivify_592:
    set $P1610, $P1609[0]
    unless_null $P1610, vivify_593
    new $P1610, "Undef"
  vivify_593:
    find_lex $P1611, "$name"
    find_lex $P1612, "$cholder"
    $P1613 = $P1610."symbol"($P1611, "lexical" :named("scope"), $P1612 :named("cholder"))
.annotate 'line', 620
    .return ($P1613)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1565"  :anon :subid("96_1299450604.787") :outer("95_1299450604.787")
    .param pmc param_1568
.annotate 'line', 629
    $P1567 = root_new ['parrot';'Hash']
    .lex "%sym", $P1567
    .lex "$_", param_1568
    find_lex $P1569, "$_"
    find_lex $P1570, "$name"
    $P1571 = $P1569."symbol"($P1570)
    store_lex "%sym", $P1571
.annotate 'line', 630
    find_lex $P1576, "%sym"
    unless_null $P1576, vivify_585
    $P1576 = root_new ['parrot';'Hash']
  vivify_585:
    set $P1577, $P1576["proto"]
    unless_null $P1577, vivify_586
    new $P1577, "Undef"
  vivify_586:
    unless $P1577, unless_1575
    set $P1574, $P1577
    goto unless_1575_end
  unless_1575:
    find_lex $P1578, "%sym"
    unless_null $P1578, vivify_587
    $P1578 = root_new ['parrot';'Hash']
  vivify_587:
    set $P1579, $P1578["cholder"]
    unless_null $P1579, vivify_588
    new $P1579, "Undef"
  vivify_588:
    set $P1574, $P1579
  unless_1575_end:
    if $P1574, if_1573
.annotate 'line', 633
    find_lex $P1583, "%sym"
    if $P1583, if_1582
    set $P1581, $P1583
    goto if_1582_end
  if_1582:
.annotate 'line', 634
    find_lex $P1584, "$/"
    $P1585 = $P1584."CURSOR"()
    $P1586 = $P1585."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 633
    set $P1581, $P1586
  if_1582_end:
    set $P1572, $P1581
.annotate 'line', 630
    goto if_1573_end
  if_1573:
.annotate 'line', 631
    new $P1580, "Integer"
    assign $P1580, 1
    store_lex "$found_proto", $P1580
.annotate 'line', 630
    set $P1572, $P1580
  if_1573_end:
.annotate 'line', 628
    .return ($P1572)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1707"  :anon :subid("98_1299450604.787") :outer("92_1299450604.787")
    .param pmc param_1709
.annotate 'line', 708
    .lex "$_", param_1709
    find_lex $P1710, "$_"
    $P1711 = $P1710."ast"()
    find_lex $P1712, "$/"
    $P1713 = $P1711($P1712)
    .return ($P1713)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("99_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1721
    .param pmc param_1722
.annotate 'line', 715
    .const 'Sub' $P1834 = "101_1299450604.787" 
    capture_lex $P1834
    .const 'Sub' $P1750 = "100_1299450604.787" 
    capture_lex $P1750
    .lex "self", param_1721
    .lex "$/", param_1722
.annotate 'line', 718
    new $P1723, "Undef"
    .lex "$past", $P1723
.annotate 'line', 715
    find_lex $P1724, "$past"
.annotate 'line', 719
    find_lex $P1726, "$/"
    unless_null $P1726, vivify_602
    $P1726 = root_new ['parrot';'Hash']
  vivify_602:
    set $P1727, $P1726["onlystar"]
    unless_null $P1727, vivify_603
    new $P1727, "Undef"
  vivify_603:
    if $P1727, if_1725
.annotate 'line', 723
    find_lex $P1729, "$/"
    unless_null $P1729, vivify_604
    $P1729 = root_new ['parrot';'Hash']
  vivify_604:
    set $P1730, $P1729["blockoid"]
    unless_null $P1730, vivify_605
    new $P1730, "Undef"
  vivify_605:
    $P1731 = $P1730."ast"()
    store_lex "$past", $P1731
.annotate 'line', 724
    find_lex $P1732, "$past"
    $P1732."blocktype"("declaration")
.annotate 'line', 725
    find_dynamic_lex $P1734, "$*RETURN_USED"
    unless_null $P1734, vivify_606
    get_hll_global $P1734, "$RETURN_USED"
    unless_null $P1734, vivify_607
    die "Contextual $*RETURN_USED not found"
  vivify_607:
  vivify_606:
    unless $P1734, if_1733_end
.annotate 'line', 726
    find_lex $P1735, "$past"
    $P1735."control"("return_pir")
  if_1733_end:
.annotate 'line', 722
    goto if_1725_end
  if_1725:
.annotate 'line', 720
    $P1728 = "only_star_block"()
    store_lex "$past", $P1728
  if_1725_end:
.annotate 'line', 731
    find_lex $P1737, "$past"
    unless_null $P1737, vivify_608
    $P1737 = root_new ['parrot';'Hash']
  vivify_608:
    set $P1738, $P1737["signature_has_invocant"]
    unless_null $P1738, vivify_609
    new $P1738, "Undef"
  vivify_609:
    if $P1738, unless_1736_end
.annotate 'line', 732
    find_lex $P1739, "$past"
    unless_null $P1739, vivify_610
    $P1739 = root_new ['parrot';'ResizablePMCArray']
  vivify_610:
    set $P1740, $P1739[0]
    unless_null $P1740, vivify_611
    new $P1740, "Undef"
  vivify_611:
    get_hll_global $P1741, ["PAST"], "Var"
.annotate 'line', 734
    get_hll_global $P1742, ["PAST"], "Var"
    $P1743 = $P1742."new"("$?CLASS" :named("name"))
    $P1744 = $P1741."new"("self" :named("name"), "parameter" :named("scope"), $P1743 :named("multitype"))
.annotate 'line', 732
    $P1740."unshift"($P1744)
  unless_1736_end:
.annotate 'line', 737
    find_lex $P1745, "$past"
    $P1745."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 740
    find_lex $P1747, "$/"
    unless_null $P1747, vivify_612
    $P1747 = root_new ['parrot';'Hash']
  vivify_612:
    set $P1748, $P1747["deflongname"]
    unless_null $P1748, vivify_613
    new $P1748, "Undef"
  vivify_613:
    unless $P1748, if_1746_end
    .const 'Sub' $P1750 = "100_1299450604.787" 
    capture_lex $P1750
    $P1750()
  if_1746_end:
.annotate 'line', 775
    find_dynamic_lex $P1816, "$*SCOPE"
    unless_null $P1816, vivify_631
    get_hll_global $P1816, "$SCOPE"
    unless_null $P1816, vivify_632
    die "Contextual $*SCOPE not found"
  vivify_632:
  vivify_631:
    set $S1817, $P1816
    iseq $I1818, $S1817, "our"
    unless $I1818, if_1815_end
.annotate 'line', 776
    find_lex $P1819, "$past"
    $P1819."pirflags"(":nsentry")
  if_1815_end:
.annotate 'line', 780
    find_lex $P1820, "$/"
    find_lex $P1821, "$past"
    $P1820."!make"($P1821)
.annotate 'line', 781
    find_lex $P1822, "$past"
    find_lex $P1823, "$past"
    unless_null $P1823, vivify_633
    $P1823 = root_new ['parrot';'Hash']
    store_lex "$past", $P1823
  vivify_633:
    set $P1823["block_past"], $P1822
.annotate 'line', 782
    find_lex $P1826, "$/"
    unless_null $P1826, vivify_634
    $P1826 = root_new ['parrot';'Hash']
  vivify_634:
    set $P1827, $P1826["trait"]
    unless_null $P1827, vivify_635
    new $P1827, "Undef"
  vivify_635:
    if $P1827, if_1825
    set $P1824, $P1827
    goto if_1825_end
  if_1825:
.annotate 'line', 783
    find_lex $P1829, "$/"
    unless_null $P1829, vivify_636
    $P1829 = root_new ['parrot';'Hash']
  vivify_636:
    set $P1830, $P1829["trait"]
    unless_null $P1830, vivify_637
    new $P1830, "Undef"
  vivify_637:
    defined $I1831, $P1830
    unless $I1831, for_undef_638
    iter $P1828, $P1830
    new $P1841, 'ExceptionHandler'
    set_label $P1841, loop1840_handler
    $P1841."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1841
  loop1840_test:
    unless $P1828, loop1840_done
    shift $P1832, $P1828
  loop1840_redo:
    .const 'Sub' $P1834 = "101_1299450604.787" 
    capture_lex $P1834
    $P1834($P1832)
  loop1840_next:
    goto loop1840_test
  loop1840_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1842, exception, 'type'
    eq $P1842, .CONTROL_LOOP_NEXT, loop1840_next
    eq $P1842, .CONTROL_LOOP_REDO, loop1840_redo
  loop1840_done:
    pop_eh 
  for_undef_638:
.annotate 'line', 782
    set $P1824, $P1828
  if_1825_end:
.annotate 'line', 715
    .return ($P1824)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1749"  :anon :subid("100_1299450604.787") :outer("99_1299450604.787")
.annotate 'line', 742
    new $P1751, "Undef"
    .lex "$name", $P1751
.annotate 'line', 747
    new $P1752, "Undef"
    .lex "$to_add", $P1752
.annotate 'line', 742
    find_lex $P1753, "$/"
    unless_null $P1753, vivify_614
    $P1753 = root_new ['parrot';'Hash']
  vivify_614:
    set $P1754, $P1753["private"]
    unless_null $P1754, vivify_615
    new $P1754, "Undef"
  vivify_615:
    set $S1755, $P1754
    new $P1756, 'String'
    set $P1756, $S1755
    find_lex $P1757, "$/"
    unless_null $P1757, vivify_616
    $P1757 = root_new ['parrot';'Hash']
  vivify_616:
    set $P1758, $P1757["deflongname"]
    unless_null $P1758, vivify_617
    $P1758 = root_new ['parrot';'ResizablePMCArray']
  vivify_617:
    set $P1759, $P1758[0]
    unless_null $P1759, vivify_618
    new $P1759, "Undef"
  vivify_618:
    $P1760 = $P1759."ast"()
    set $S1761, $P1760
    concat $P1762, $P1756, $S1761
    store_lex "$name", $P1762
.annotate 'line', 743
    find_lex $P1763, "$past"
    find_lex $P1764, "$name"
    $P1763."name"($P1764)
.annotate 'line', 747
    find_dynamic_lex $P1767, "$*MULTINESS"
    unless_null $P1767, vivify_619
    get_hll_global $P1767, "$MULTINESS"
    unless_null $P1767, vivify_620
    die "Contextual $*MULTINESS not found"
  vivify_620:
  vivify_619:
    set $S1768, $P1767
    isne $I1769, $S1768, "proto"
    if $I1769, if_1766
.annotate 'line', 749
    get_hll_global $P1773, ["PAST"], "Op"
.annotate 'line', 751
    get_hll_global $P1774, ["PAST"], "Val"
    find_lex $P1775, "$past"
    $P1776 = $P1774."new"($P1775 :named("value"))
.annotate 'line', 752
    get_hll_global $P1777, ["PAST"], "Op"
    $P1778 = $P1777."new"("list" :named("pasttype"))
    $P1779 = $P1773."new"($P1776, $P1778, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 749
    set $P1765, $P1779
.annotate 'line', 747
    goto if_1766_end
  if_1766:
.annotate 'line', 748
    get_hll_global $P1770, ["PAST"], "Val"
    find_lex $P1771, "$past"
    $P1772 = $P1770."new"($P1771 :named("value"))
    set $P1765, $P1772
  if_1766_end:
.annotate 'line', 747
    store_lex "$to_add", $P1765
.annotate 'line', 754
    find_dynamic_lex $P1781, "$*MULTINESS"
    unless_null $P1781, vivify_621
    get_hll_global $P1781, "$MULTINESS"
    unless_null $P1781, vivify_622
    die "Contextual $*MULTINESS not found"
  vivify_622:
  vivify_621:
    set $S1782, $P1781
    iseq $I1783, $S1782, "proto"
    unless $I1783, if_1780_end
    find_lex $P1784, "$past"
    $P1784."pirflags"(":instanceof(\"DispatcherSub\")")
  if_1780_end:
.annotate 'line', 758
    find_dynamic_lex $P1786, "$*MULTINESS"
    unless_null $P1786, vivify_623
    get_hll_global $P1786, "$MULTINESS"
    unless_null $P1786, vivify_624
    die "Contextual $*MULTINESS not found"
  vivify_624:
  vivify_623:
    set $S1787, $P1786
    iseq $I1788, $S1787, "multi"
    unless $I1788, if_1785_end
    find_lex $P1789, "$past"
    "attach_multi_signature"($P1789)
  if_1785_end:
.annotate 'line', 761
    find_dynamic_lex $P1792, "$*PACKAGE-SETUP"
    unless_null $P1792, vivify_625
    get_hll_global $P1792, "$PACKAGE-SETUP"
    unless_null $P1792, vivify_626
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_626:
  vivify_625:
    defined $I1793, $P1792
    if $I1793, if_1791
    new $P1790, 'Integer'
    set $P1790, $I1793
    goto if_1791_end
  if_1791:
.annotate 'line', 762
    find_dynamic_lex $P1794, "$*PACKAGE-SETUP"
    unless_null $P1794, vivify_627
    get_hll_global $P1794, "$PACKAGE-SETUP"
    unless_null $P1794, vivify_628
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_628:
  vivify_627:
    get_hll_global $P1795, ["PAST"], "Op"
.annotate 'line', 763
    find_dynamic_lex $P1798, "$*MULTINESS"
    unless_null $P1798, vivify_629
    get_hll_global $P1798, "$MULTINESS"
    unless_null $P1798, vivify_630
    die "Contextual $*MULTINESS not found"
  vivify_630:
  vivify_629:
    set $S1799, $P1798
    iseq $I1800, $S1799, "multi"
    if $I1800, if_1797
    new $P1802, "String"
    assign $P1802, "add_method"
    set $P1796, $P1802
    goto if_1797_end
  if_1797:
    new $P1801, "String"
    assign $P1801, "add_multi_method"
    set $P1796, $P1801
  if_1797_end:
.annotate 'line', 764
    get_hll_global $P1803, ["PAST"], "Op"
.annotate 'line', 767
    get_hll_global $P1804, ["PAST"], "Var"
    $P1805 = $P1804."new"("type_obj" :named("name"), "register" :named("scope"))
    $P1806 = $P1803."new"($P1805, "get_how PP" :named("pirop"))
.annotate 'line', 769
    get_hll_global $P1807, ["PAST"], "Var"
    $P1808 = $P1807."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 770
    get_hll_global $P1809, ["PAST"], "Val"
    find_lex $P1810, "$name"
    $P1811 = $P1809."new"($P1810 :named("value"))
    find_lex $P1812, "$to_add"
    $P1813 = $P1795."new"($P1806, $P1808, $P1811, $P1812, "callmethod" :named("pasttype"), $P1796 :named("name"))
.annotate 'line', 762
    $P1814 = $P1794."push"($P1813)
.annotate 'line', 761
    set $P1790, $P1814
  if_1791_end:
.annotate 'line', 740
    .return ($P1790)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1833"  :anon :subid("101_1299450604.787") :outer("99_1299450604.787")
    .param pmc param_1835
.annotate 'line', 783
    .lex "$_", param_1835
    find_lex $P1836, "$_"
    $P1837 = $P1836."ast"()
    find_lex $P1838, "$/"
    $P1839 = $P1837($P1838)
    .return ($P1839)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("102_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1846
    .param pmc param_1847
.annotate 'line', 815
    .const 'Sub' $P1880 = "104_1299450604.787" 
    capture_lex $P1880
    .const 'Sub' $P1856 = "103_1299450604.787" 
    capture_lex $P1856
    .lex "self", param_1846
    .lex "$/", param_1847
.annotate 'line', 816
    new $P1848, "Undef"
    .lex "$BLOCKINIT", $P1848
    get_global $P1849, "@BLOCK"
    unless_null $P1849, vivify_639
    $P1849 = root_new ['parrot';'ResizablePMCArray']
  vivify_639:
    set $P1850, $P1849[0]
    unless_null $P1850, vivify_640
    $P1850 = root_new ['parrot';'ResizablePMCArray']
  vivify_640:
    set $P1851, $P1850[0]
    unless_null $P1851, vivify_641
    new $P1851, "Undef"
  vivify_641:
    store_lex "$BLOCKINIT", $P1851
.annotate 'line', 817
    find_lex $P1853, "$/"
    unless_null $P1853, vivify_642
    $P1853 = root_new ['parrot';'Hash']
  vivify_642:
    set $P1854, $P1853["invocant"]
    unless_null $P1854, vivify_643
    new $P1854, "Undef"
  vivify_643:
    unless $P1854, if_1852_end
    .const 'Sub' $P1856 = "103_1299450604.787" 
    capture_lex $P1856
    $P1856()
  if_1852_end:
.annotate 'line', 826
    find_lex $P1875, "$/"
    unless_null $P1875, vivify_649
    $P1875 = root_new ['parrot';'Hash']
  vivify_649:
    set $P1876, $P1875["parameter"]
    unless_null $P1876, vivify_650
    new $P1876, "Undef"
  vivify_650:
    defined $I1877, $P1876
    unless $I1877, for_undef_651
    iter $P1874, $P1876
    new $P1887, 'ExceptionHandler'
    set_label $P1887, loop1886_handler
    $P1887."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P1887
  loop1886_test:
    unless $P1874, loop1886_done
    shift $P1878, $P1874
  loop1886_redo:
    .const 'Sub' $P1880 = "104_1299450604.787" 
    capture_lex $P1880
    $P1880($P1878)
  loop1886_next:
    goto loop1886_test
  loop1886_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P1888, exception, 'type'
    eq $P1888, .CONTROL_LOOP_NEXT, loop1886_next
    eq $P1888, .CONTROL_LOOP_REDO, loop1886_redo
  loop1886_done:
    pop_eh 
  for_undef_651:
.annotate 'line', 815
    .return ($P1874)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1855"  :anon :subid("103_1299450604.787") :outer("102_1299450604.787")
.annotate 'line', 818
    new $P1857, "Undef"
    .lex "$inv", $P1857
    find_lex $P1858, "$/"
    unless_null $P1858, vivify_644
    $P1858 = root_new ['parrot';'Hash']
  vivify_644:
    set $P1859, $P1858["invocant"]
    unless_null $P1859, vivify_645
    $P1859 = root_new ['parrot';'ResizablePMCArray']
  vivify_645:
    set $P1860, $P1859[0]
    unless_null $P1860, vivify_646
    new $P1860, "Undef"
  vivify_646:
    $P1861 = $P1860."ast"()
    store_lex "$inv", $P1861
.annotate 'line', 819
    find_lex $P1862, "$BLOCKINIT"
    find_lex $P1863, "$inv"
    $P1862."push"($P1863)
.annotate 'line', 820
    find_lex $P1864, "$BLOCKINIT"
    get_hll_global $P1865, ["PAST"], "Var"
.annotate 'line', 822
    get_hll_global $P1866, ["PAST"], "Var"
    find_lex $P1867, "$inv"
    $P1868 = $P1867."name"()
    $P1869 = $P1866."new"("lexical" :named("scope"), $P1868 :named("name"))
    $P1870 = $P1865."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P1869 :named("viviself"))
.annotate 'line', 820
    $P1864."push"($P1870)
.annotate 'line', 824
    new $P1871, "Integer"
    assign $P1871, 1
    get_global $P1872, "@BLOCK"
    unless_null $P1872, vivify_647
    $P1872 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P1872
  vivify_647:
    set $P1873, $P1872[0]
    unless_null $P1873, vivify_648
    $P1873 = root_new ['parrot';'Hash']
    set $P1872[0], $P1873
  vivify_648:
    set $P1873["signature_has_invocant"], $P1871
.annotate 'line', 817
    .return ($P1871)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block1879"  :anon :subid("104_1299450604.787") :outer("102_1299450604.787")
    .param pmc param_1881
.annotate 'line', 826
    .lex "$_", param_1881
    find_lex $P1882, "$BLOCKINIT"
    find_lex $P1883, "$_"
    $P1884 = $P1883."ast"()
    $P1885 = $P1882."push"($P1884)
    .return ($P1885)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("105_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1890
    .param pmc param_1891
.annotate 'line', 829
    .lex "self", param_1890
    .lex "$/", param_1891
.annotate 'line', 830
    new $P1892, "Undef"
    .lex "$quant", $P1892
.annotate 'line', 831
    new $P1893, "Undef"
    .lex "$past", $P1893
.annotate 'line', 830
    find_lex $P1894, "$/"
    unless_null $P1894, vivify_652
    $P1894 = root_new ['parrot';'Hash']
  vivify_652:
    set $P1895, $P1894["quant"]
    unless_null $P1895, vivify_653
    new $P1895, "Undef"
  vivify_653:
    store_lex "$quant", $P1895
    find_lex $P1896, "$past"
.annotate 'line', 832
    find_lex $P1898, "$/"
    unless_null $P1898, vivify_654
    $P1898 = root_new ['parrot';'Hash']
  vivify_654:
    set $P1899, $P1898["named_param"]
    unless_null $P1899, vivify_655
    new $P1899, "Undef"
  vivify_655:
    if $P1899, if_1897
.annotate 'line', 839
    find_lex $P1913, "$/"
    unless_null $P1913, vivify_656
    $P1913 = root_new ['parrot';'Hash']
  vivify_656:
    set $P1914, $P1913["param_var"]
    unless_null $P1914, vivify_657
    new $P1914, "Undef"
  vivify_657:
    $P1915 = $P1914."ast"()
    store_lex "$past", $P1915
.annotate 'line', 840
    find_lex $P1917, "$quant"
    set $S1918, $P1917
    iseq $I1919, $S1918, "*"
    if $I1919, if_1916
.annotate 'line', 844
    find_lex $P1928, "$quant"
    set $S1929, $P1928
    iseq $I1930, $S1929, "?"
    unless $I1930, if_1927_end
.annotate 'line', 845
    find_lex $P1931, "$past"
    find_lex $P1932, "$/"
    unless_null $P1932, vivify_658
    $P1932 = root_new ['parrot';'Hash']
  vivify_658:
    set $P1933, $P1932["param_var"]
    unless_null $P1933, vivify_659
    $P1933 = root_new ['parrot';'Hash']
  vivify_659:
    set $P1934, $P1933["sigil"]
    unless_null $P1934, vivify_660
    new $P1934, "Undef"
  vivify_660:
    $P1935 = "vivitype"($P1934)
    $P1931."viviself"($P1935)
  if_1927_end:
.annotate 'line', 844
    goto if_1916_end
  if_1916:
.annotate 'line', 841
    find_lex $P1920, "$past"
    $P1920."slurpy"(1)
.annotate 'line', 842
    find_lex $P1921, "$past"
    find_lex $P1922, "$/"
    unless_null $P1922, vivify_661
    $P1922 = root_new ['parrot';'Hash']
  vivify_661:
    set $P1923, $P1922["param_var"]
    unless_null $P1923, vivify_662
    $P1923 = root_new ['parrot';'Hash']
  vivify_662:
    set $P1924, $P1923["sigil"]
    unless_null $P1924, vivify_663
    new $P1924, "Undef"
  vivify_663:
    set $S1925, $P1924
    iseq $I1926, $S1925, "%"
    $P1921."named"($I1926)
  if_1916_end:
.annotate 'line', 838
    goto if_1897_end
  if_1897:
.annotate 'line', 833
    find_lex $P1900, "$/"
    unless_null $P1900, vivify_664
    $P1900 = root_new ['parrot';'Hash']
  vivify_664:
    set $P1901, $P1900["named_param"]
    unless_null $P1901, vivify_665
    new $P1901, "Undef"
  vivify_665:
    $P1902 = $P1901."ast"()
    store_lex "$past", $P1902
.annotate 'line', 834
    find_lex $P1904, "$quant"
    set $S1905, $P1904
    isne $I1906, $S1905, "!"
    unless $I1906, if_1903_end
.annotate 'line', 835
    find_lex $P1907, "$past"
    find_lex $P1908, "$/"
    unless_null $P1908, vivify_666
    $P1908 = root_new ['parrot';'Hash']
  vivify_666:
    set $P1909, $P1908["named_param"]
    unless_null $P1909, vivify_667
    $P1909 = root_new ['parrot';'Hash']
  vivify_667:
    set $P1910, $P1909["param_var"]
    unless_null $P1910, vivify_668
    $P1910 = root_new ['parrot';'Hash']
  vivify_668:
    set $P1911, $P1910["sigil"]
    unless_null $P1911, vivify_669
    new $P1911, "Undef"
  vivify_669:
    $P1912 = "vivitype"($P1911)
    $P1907."viviself"($P1912)
  if_1903_end:
  if_1897_end:
.annotate 'line', 848
    find_lex $P1937, "$/"
    unless_null $P1937, vivify_670
    $P1937 = root_new ['parrot';'Hash']
  vivify_670:
    set $P1938, $P1937["default_value"]
    unless_null $P1938, vivify_671
    new $P1938, "Undef"
  vivify_671:
    unless $P1938, if_1936_end
.annotate 'line', 849
    find_lex $P1940, "$quant"
    set $S1941, $P1940
    iseq $I1942, $S1941, "*"
    unless $I1942, if_1939_end
.annotate 'line', 850
    find_lex $P1943, "$/"
    $P1944 = $P1943."CURSOR"()
    $P1944."panic"("Can't put default on slurpy parameter")
  if_1939_end:
.annotate 'line', 852
    find_lex $P1946, "$quant"
    set $S1947, $P1946
    iseq $I1948, $S1947, "!"
    unless $I1948, if_1945_end
.annotate 'line', 853
    find_lex $P1949, "$/"
    $P1950 = $P1949."CURSOR"()
    $P1950."panic"("Can't put default on required parameter")
  if_1945_end:
.annotate 'line', 855
    find_lex $P1951, "$past"
    find_lex $P1952, "$/"
    unless_null $P1952, vivify_672
    $P1952 = root_new ['parrot';'Hash']
  vivify_672:
    set $P1953, $P1952["default_value"]
    unless_null $P1953, vivify_673
    $P1953 = root_new ['parrot';'ResizablePMCArray']
  vivify_673:
    set $P1954, $P1953[0]
    unless_null $P1954, vivify_674
    $P1954 = root_new ['parrot';'Hash']
  vivify_674:
    set $P1955, $P1954["EXPR"]
    unless_null $P1955, vivify_675
    new $P1955, "Undef"
  vivify_675:
    $P1956 = $P1955."ast"()
    $P1951."viviself"($P1956)
  if_1936_end:
.annotate 'line', 857
    find_lex $P1958, "$past"
    $P1959 = $P1958."viviself"()
    if $P1959, unless_1957_end
    get_global $P1960, "@BLOCK"
    unless_null $P1960, vivify_676
    $P1960 = root_new ['parrot';'ResizablePMCArray']
  vivify_676:
    set $P1961, $P1960[0]
    unless_null $P1961, vivify_677
    new $P1961, "Undef"
  vivify_677:
    get_global $P1962, "@BLOCK"
    unless_null $P1962, vivify_678
    $P1962 = root_new ['parrot';'ResizablePMCArray']
  vivify_678:
    set $P1963, $P1962[0]
    unless_null $P1963, vivify_679
    new $P1963, "Undef"
  vivify_679:
    $P1964 = $P1963."arity"()
    set $N1965, $P1964
    new $P1966, 'Float'
    set $P1966, $N1965
    add $P1967, $P1966, 1
    $P1961."arity"($P1967)
  unless_1957_end:
.annotate 'line', 861
    find_lex $P1969, "$/"
    unless_null $P1969, vivify_680
    $P1969 = root_new ['parrot';'Hash']
  vivify_680:
    set $P1970, $P1969["typename"]
    unless_null $P1970, vivify_681
    new $P1970, "Undef"
  vivify_681:
    unless $P1970, if_1968_end
.annotate 'line', 862
    find_lex $P1971, "$past"
    find_lex $P1972, "$/"
    unless_null $P1972, vivify_682
    $P1972 = root_new ['parrot';'Hash']
  vivify_682:
    set $P1973, $P1972["typename"]
    unless_null $P1973, vivify_683
    $P1973 = root_new ['parrot';'ResizablePMCArray']
  vivify_683:
    set $P1974, $P1973[0]
    unless_null $P1974, vivify_684
    new $P1974, "Undef"
  vivify_684:
    $P1975 = $P1974."ast"()
    $P1971."multitype"($P1975)
  if_1968_end:
.annotate 'line', 866
    find_lex $P1977, "$/"
    unless_null $P1977, vivify_685
    $P1977 = root_new ['parrot';'Hash']
  vivify_685:
    set $P1978, $P1977["definedness"]
    unless_null $P1978, vivify_686
    new $P1978, "Undef"
  vivify_686:
    unless $P1978, if_1976_end
.annotate 'line', 867
    find_lex $P1979, "$/"
    unless_null $P1979, vivify_687
    $P1979 = root_new ['parrot';'Hash']
  vivify_687:
    set $P1980, $P1979["definedness"]
    unless_null $P1980, vivify_688
    $P1980 = root_new ['parrot';'ResizablePMCArray']
  vivify_688:
    set $P1981, $P1980[0]
    unless_null $P1981, vivify_689
    new $P1981, "Undef"
  vivify_689:
    set $S1982, $P1981
    new $P1983, 'String'
    set $P1983, $S1982
    find_lex $P1984, "$past"
    unless_null $P1984, vivify_690
    $P1984 = root_new ['parrot';'Hash']
    store_lex "$past", $P1984
  vivify_690:
    set $P1984["definedness"], $P1983
  if_1976_end:
.annotate 'line', 870
    find_lex $P1985, "$/"
    find_lex $P1986, "$past"
    $P1987 = $P1985."!make"($P1986)
.annotate 'line', 829
    .return ($P1987)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("106_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_1989
    .param pmc param_1990
.annotate 'line', 873
    .lex "self", param_1989
    .lex "$/", param_1990
.annotate 'line', 874
    new $P1991, "Undef"
    .lex "$name", $P1991
.annotate 'line', 875
    new $P1992, "Undef"
    .lex "$past", $P1992
.annotate 'line', 874
    find_lex $P1993, "$/"
    set $S1994, $P1993
    new $P1995, 'String'
    set $P1995, $S1994
    store_lex "$name", $P1995
.annotate 'line', 875
    get_hll_global $P1996, ["PAST"], "Var"
    find_lex $P1997, "$name"
    find_lex $P1998, "$/"
    $P1999 = $P1996."new"($P1997 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P1998 :named("node"))
    store_lex "$past", $P1999
.annotate 'line', 877
    get_global $P2000, "@BLOCK"
    unless_null $P2000, vivify_691
    $P2000 = root_new ['parrot';'ResizablePMCArray']
  vivify_691:
    set $P2001, $P2000[0]
    unless_null $P2001, vivify_692
    new $P2001, "Undef"
  vivify_692:
    find_lex $P2002, "$name"
    $P2001."symbol"($P2002, "lexical" :named("scope"))
.annotate 'line', 878
    find_lex $P2003, "$/"
    find_lex $P2004, "$past"
    $P2005 = $P2003."!make"($P2004)
.annotate 'line', 873
    .return ($P2005)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("107_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2007
    .param pmc param_2008
.annotate 'line', 881
    .lex "self", param_2007
    .lex "$/", param_2008
.annotate 'line', 882
    new $P2009, "Undef"
    .lex "$past", $P2009
    find_lex $P2010, "$/"
    unless_null $P2010, vivify_693
    $P2010 = root_new ['parrot';'Hash']
  vivify_693:
    set $P2011, $P2010["param_var"]
    unless_null $P2011, vivify_694
    new $P2011, "Undef"
  vivify_694:
    $P2012 = $P2011."ast"()
    store_lex "$past", $P2012
.annotate 'line', 883
    find_lex $P2013, "$past"
    find_lex $P2014, "$/"
    unless_null $P2014, vivify_695
    $P2014 = root_new ['parrot';'Hash']
  vivify_695:
    set $P2015, $P2014["param_var"]
    unless_null $P2015, vivify_696
    $P2015 = root_new ['parrot';'Hash']
  vivify_696:
    set $P2016, $P2015["name"]
    unless_null $P2016, vivify_697
    new $P2016, "Undef"
  vivify_697:
    set $S2017, $P2016
    $P2013."named"($S2017)
.annotate 'line', 884
    find_lex $P2018, "$/"
    find_lex $P2019, "$past"
    $P2020 = $P2018."!make"($P2019)
.annotate 'line', 881
    .return ($P2020)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("108_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2022
    .param pmc param_2023
.annotate 'line', 887
    .lex "self", param_2022
    .lex "$/", param_2023
.annotate 'line', 888
    $P2024 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P2024
    get_hll_global $P2025, ["HLL"], "Compiler"
    find_lex $P2026, "$/"
    set $S2027, $P2026
    $P2028 = $P2025."parse_name"($S2027)
    store_lex "@name", $P2028
.annotate 'line', 889
    find_lex $P2029, "$/"
    get_hll_global $P2030, ["PAST"], "Var"
.annotate 'line', 890
    find_lex $P2031, "@name"
    $P2032 = $P2031."pop"()
    find_lex $P2033, "@name"
    $P2034 = $P2030."new"($P2032 :named("name"), $P2033 :named("namespace"), "package" :named("scope"))
.annotate 'line', 889
    $P2035 = $P2029."!make"($P2034)
.annotate 'line', 887
    .return ($P2035)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("109_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2037
    .param pmc param_2038
.annotate 'line', 896
    .lex "self", param_2037
    .lex "$/", param_2038
.annotate 'line', 897
    find_lex $P2039, "$/"
    find_lex $P2040, "$/"
    unless_null $P2040, vivify_698
    $P2040 = root_new ['parrot';'Hash']
  vivify_698:
    set $P2041, $P2040["trait_mod"]
    unless_null $P2041, vivify_699
    new $P2041, "Undef"
  vivify_699:
    $P2042 = $P2041."ast"()
    $P2043 = $P2039."!make"($P2042)
.annotate 'line', 896
    .return ($P2043)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("110_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2045
    .param pmc param_2046
.annotate 'line', 900
    .const 'Sub' $P2066 = "111_1299450604.787" 
    capture_lex $P2066
    .lex "self", param_2045
    .lex "$/", param_2046
.annotate 'line', 901
    new $P2047, "Undef"
    .lex "$cpast", $P2047
    find_lex $P2048, "$/"
    unless_null $P2048, vivify_700
    $P2048 = root_new ['parrot';'Hash']
  vivify_700:
    set $P2049, $P2048["circumfix"]
    unless_null $P2049, vivify_701
    $P2049 = root_new ['parrot';'ResizablePMCArray']
  vivify_701:
    set $P2050, $P2049[0]
    unless_null $P2050, vivify_702
    new $P2050, "Undef"
  vivify_702:
    $P2051 = $P2050."ast"()
    store_lex "$cpast", $P2051
.annotate 'line', 902
    find_lex $P2054, "$/"
    unless_null $P2054, vivify_703
    $P2054 = root_new ['parrot';'Hash']
  vivify_703:
    set $P2055, $P2054["longname"]
    unless_null $P2055, vivify_704
    new $P2055, "Undef"
  vivify_704:
    set $S2056, $P2055
    iseq $I2057, $S2056, "parrot_vtable"
    if $I2057, if_2053
.annotate 'line', 922
    find_lex $P2092, "$/"
    unless_null $P2092, vivify_705
    $P2092 = root_new ['parrot';'Hash']
  vivify_705:
    set $P2093, $P2092["longname"]
    unless_null $P2093, vivify_706
    new $P2093, "Undef"
  vivify_706:
    set $S2094, $P2093
    iseq $I2095, $S2094, "pirflags"
    if $I2095, if_2091
.annotate 'line', 926
    find_lex $P2099, "$/"
    $P2100 = $P2099."CURSOR"()
    new $P2101, 'String'
    set $P2101, "Trait '"
    find_lex $P2102, "$/"
    unless_null $P2102, vivify_707
    $P2102 = root_new ['parrot';'Hash']
  vivify_707:
    set $P2103, $P2102["longname"]
    unless_null $P2103, vivify_708
    new $P2103, "Undef"
  vivify_708:
    concat $P2104, $P2101, $P2103
    concat $P2105, $P2104, "' not implemented"
    $P2106 = $P2100."panic"($P2105)
.annotate 'line', 925
    set $P2090, $P2106
.annotate 'line', 922
    goto if_2091_end
  if_2091:
.annotate 'line', 923
    find_lex $P2096, "$/"
    $P2097 = $P2096."CURSOR"()
    $P2098 = $P2097."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 922
    set $P2090, $P2098
  if_2091_end:
    set $P2052, $P2090
.annotate 'line', 902
    goto if_2053_end
  if_2053:
.annotate 'line', 905
    get_hll_global $P2059, ["PAST"], "Val"
    find_lex $P2060, "$cpast"
    $P2061 = $P2059."ACCEPTS"($P2060)
    if $P2061, unless_2058_end
.annotate 'line', 904
    find_lex $P2062, "$/"
    $P2063 = $P2062."CURSOR"()
    $P2063."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_2058_end:
.annotate 'line', 906
    find_lex $P2064, "$/"
    .const 'Sub' $P2066 = "111_1299450604.787" 
    newclosure $P2088, $P2066
    $P2089 = $P2064."!make"($P2088)
.annotate 'line', 902
    set $P2052, $P2089
  if_2053_end:
.annotate 'line', 900
    .return ($P2052)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2065"  :anon :subid("111_1299450604.787") :outer("110_1299450604.787")
    .param pmc param_2067
.annotate 'line', 906
    .lex "$match", param_2067
.annotate 'line', 907
    new $P2068, "Undef"
    .lex "$meth", $P2068
    find_lex $P2069, "$match"
    $P2070 = $P2069."ast"()
    set $P2071, $P2070["block_past"]
    unless_null $P2071, vivify_709
    new $P2071, "Undef"
  vivify_709:
    store_lex "$meth", $P2071
.annotate 'line', 908
    find_dynamic_lex $P2074, "$*PACKAGE-SETUP"
    unless_null $P2074, vivify_710
    get_hll_global $P2074, "$PACKAGE-SETUP"
    unless_null $P2074, vivify_711
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_711:
  vivify_710:
    defined $I2075, $P2074
    if $I2075, if_2073
    new $P2072, 'Integer'
    set $P2072, $I2075
    goto if_2073_end
  if_2073:
.annotate 'line', 909
    find_dynamic_lex $P2076, "$*PACKAGE-SETUP"
    unless_null $P2076, vivify_712
    get_hll_global $P2076, "$PACKAGE-SETUP"
    unless_null $P2076, vivify_713
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_713:
  vivify_712:
    get_hll_global $P2077, ["PAST"], "Op"
.annotate 'line', 911
    get_hll_global $P2078, ["PAST"], "Op"
.annotate 'line', 914
    get_hll_global $P2079, ["PAST"], "Var"
    $P2080 = $P2079."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2081 = $P2078."new"($P2080, "get_how PP" :named("pirop"))
.annotate 'line', 916
    get_hll_global $P2082, ["PAST"], "Var"
    $P2083 = $P2082."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P2084, "$cpast"
    find_lex $P2085, "$meth"
    $P2086 = $P2077."new"($P2081, $P2083, $P2084, $P2085, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 909
    $P2087 = $P2076."push"($P2086)
.annotate 'line', 908
    set $P2072, $P2087
  if_2073_end:
.annotate 'line', 906
    .return ($P2072)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("112_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2110
    .param pmc param_2111
    .param pmc param_2112 :optional
    .param int has_param_2112 :opt_flag
.annotate 'line', 930
    .const 'Sub' $P2210 = "115_1299450604.787" 
    capture_lex $P2210
    .const 'Sub' $P2182 = "114_1299450604.787" 
    capture_lex $P2182
    .const 'Sub' $P2155 = "113_1299450604.787" 
    capture_lex $P2155
    new $P2109, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2109, control_2108
    push_eh $P2109
    .lex "self", param_2110
    .lex "$/", param_2111
    if has_param_2112, optparam_714
    new $P2113, "Undef"
    set param_2112, $P2113
  optparam_714:
    .lex "$key", param_2112
.annotate 'line', 931
    $P2114 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P2114
.annotate 'line', 934
    new $P2115, "Undef"
    .lex "$name", $P2115
.annotate 'line', 935
    new $P2116, "Undef"
    .lex "$past", $P2116
.annotate 'line', 931

        $P2117 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
    
    store_lex "@MODIFIERS", $P2117
.annotate 'line', 934
    find_lex $P2118, "$/"
    unless_null $P2118, vivify_715
    $P2118 = root_new ['parrot';'Hash']
  vivify_715:
    set $P2119, $P2118["deflongname"]
    unless_null $P2119, vivify_716
    new $P2119, "Undef"
  vivify_716:
    $P2120 = $P2119."ast"()
    set $S2121, $P2120
    new $P2122, 'String'
    set $P2122, $S2121
    store_lex "$name", $P2122
    find_lex $P2123, "$past"
.annotate 'line', 936
    find_lex $P2125, "$/"
    unless_null $P2125, vivify_717
    $P2125 = root_new ['parrot';'Hash']
  vivify_717:
    set $P2126, $P2125["proto"]
    unless_null $P2126, vivify_718
    new $P2126, "Undef"
  vivify_718:
    if $P2126, if_2124
.annotate 'line', 975
    find_lex $P2178, "$key"
    set $S2179, $P2178
    iseq $I2180, $S2179, "open"
    if $I2180, if_2177
.annotate 'line', 988
    .const 'Sub' $P2210 = "115_1299450604.787" 
    capture_lex $P2210
    $P2210()
    goto if_2177_end
  if_2177:
.annotate 'line', 975
    .const 'Sub' $P2182 = "114_1299450604.787" 
    capture_lex $P2182
    $P2182()
  if_2177_end:
    goto if_2124_end
  if_2124:
.annotate 'line', 938
    get_hll_global $P2127, ["PAST"], "Stmts"
.annotate 'line', 939
    get_hll_global $P2128, ["PAST"], "Block"
    find_lex $P2129, "$name"
.annotate 'line', 940
    get_hll_global $P2130, ["PAST"], "Op"
.annotate 'line', 941
    get_hll_global $P2131, ["PAST"], "Var"
    $P2132 = $P2131."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2133, "$name"
    $P2134 = $P2130."new"($P2132, $P2133, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 940
    find_lex $P2135, "$/"
    $P2136 = $P2128."new"($P2134, $P2129 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2135 :named("node"))
.annotate 'line', 950
    get_hll_global $P2137, ["PAST"], "Block"
    new $P2138, "String"
    assign $P2138, "!PREFIX__"
    find_lex $P2139, "$name"
    concat $P2140, $P2138, $P2139
.annotate 'line', 951
    get_hll_global $P2141, ["PAST"], "Op"
.annotate 'line', 952
    get_hll_global $P2142, ["PAST"], "Var"
    $P2143 = $P2142."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P2144, "$name"
    $P2145 = $P2141."new"($P2143, $P2144, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 951
    find_lex $P2146, "$/"
    $P2147 = $P2137."new"($P2145, $P2140 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P2146 :named("node"))
.annotate 'line', 950
    $P2148 = $P2127."new"($P2136, $P2147)
.annotate 'line', 938
    store_lex "$past", $P2148
.annotate 'line', 962
    find_lex $P2150, "$past"
    $P2151 = $P2150."list"()
    defined $I2152, $P2151
    unless $I2152, for_undef_739
    iter $P2149, $P2151
    new $P2175, 'ExceptionHandler'
    set_label $P2175, loop2174_handler
    $P2175."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2175
  loop2174_test:
    unless $P2149, loop2174_done
    shift $P2153, $P2149
  loop2174_redo:
    .const 'Sub' $P2155 = "113_1299450604.787" 
    capture_lex $P2155
    $P2155($P2153)
  loop2174_next:
    goto loop2174_test
  loop2174_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2176, exception, 'type'
    eq $P2176, .CONTROL_LOOP_NEXT, loop2174_next
    eq $P2176, .CONTROL_LOOP_REDO, loop2174_redo
  loop2174_done:
    pop_eh 
  for_undef_739:
  if_2124_end:
.annotate 'line', 1024
    find_lex $P2268, "$/"
    find_lex $P2269, "$past"
    $P2270 = $P2268."!make"($P2269)
.annotate 'line', 930
    .return ($P2270)
  control_2108:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2271, exception, "payload"
    .return ($P2271)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2209"  :anon :subid("115_1299450604.787") :outer("112_1299450604.787")
.annotate 'line', 989
    new $P2211, "Undef"
    .lex "$regex", $P2211
.annotate 'line', 990
    get_hll_global $P2212, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2213, "$/"
    unless_null $P2213, vivify_719
    $P2213 = root_new ['parrot';'Hash']
  vivify_719:
    set $P2214, $P2213["p6regex"]
    unless_null $P2214, vivify_720
    new $P2214, "Undef"
  vivify_720:
    $P2215 = $P2214."ast"()
    get_global $P2216, "@BLOCK"
    $P2217 = $P2216."shift"()
    $P2218 = $P2212($P2215, $P2217)
    store_lex "$regex", $P2218
.annotate 'line', 991
    find_lex $P2219, "$regex"
    find_lex $P2220, "$name"
    $P2219."name"($P2220)
.annotate 'line', 993
    get_hll_global $P2221, ["PAST"], "Op"
.annotate 'line', 995
    get_hll_global $P2222, ["PAST"], "Var"
    new $P2223, "ResizablePMCArray"
    push $P2223, "Regex"
    $P2224 = $P2222."new"("Method" :named("name"), $P2223 :named("namespace"), "package" :named("scope"))
    find_lex $P2225, "$regex"
    $P2226 = $P2221."new"($P2224, $P2225, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 993
    store_lex "$past", $P2226
.annotate 'line', 998
    find_dynamic_lex $P2228, "$*PACKAGE-SETUP"
    unless_null $P2228, vivify_721
    get_hll_global $P2228, "$PACKAGE-SETUP"
    unless_null $P2228, vivify_722
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_722:
  vivify_721:
    defined $I2229, $P2228
    unless $I2229, if_2227_end
.annotate 'line', 999
    find_dynamic_lex $P2230, "$*PACKAGE-SETUP"
    unless_null $P2230, vivify_723
    get_hll_global $P2230, "$PACKAGE-SETUP"
    unless_null $P2230, vivify_724
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_724:
  vivify_723:
    get_hll_global $P2231, ["PAST"], "Op"
.annotate 'line', 1001
    get_hll_global $P2232, ["PAST"], "Op"
.annotate 'line', 1003
    get_hll_global $P2233, ["PAST"], "Var"
    $P2234 = $P2233."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2235 = $P2232."new"($P2234, "get_how PP" :named("pirop"))
.annotate 'line', 1005
    get_hll_global $P2236, ["PAST"], "Var"
    $P2237 = $P2236."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1006
    get_hll_global $P2238, ["PAST"], "Val"
    find_lex $P2239, "$name"
    $P2240 = $P2238."new"($P2239 :named("value"))
.annotate 'line', 1007
    get_hll_global $P2241, ["PAST"], "Val"
    find_lex $P2242, "$regex"
    $P2243 = $P2241."new"($P2242 :named("value"))
    $P2244 = $P2231."new"($P2235, $P2237, $P2240, $P2243, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 999
    $P2230."push"($P2244)
.annotate 'line', 1009
    find_dynamic_lex $P2245, "$*PACKAGE-SETUP"
    unless_null $P2245, vivify_725
    get_hll_global $P2245, "$PACKAGE-SETUP"
    unless_null $P2245, vivify_726
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_726:
  vivify_725:
    get_hll_global $P2246, ["PAST"], "Op"
.annotate 'line', 1011
    get_hll_global $P2247, ["PAST"], "Op"
.annotate 'line', 1013
    get_hll_global $P2248, ["PAST"], "Var"
    $P2249 = $P2248."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2250 = $P2247."new"($P2249, "get_how PP" :named("pirop"))
.annotate 'line', 1015
    get_hll_global $P2251, ["PAST"], "Var"
    $P2252 = $P2251."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1016
    get_hll_global $P2253, ["PAST"], "Val"
    new $P2254, "String"
    assign $P2254, "!PREFIX__"
    find_lex $P2255, "$name"
    concat $P2256, $P2254, $P2255
    $P2257 = $P2253."new"($P2256 :named("value"))
.annotate 'line', 1017
    get_hll_global $P2258, ["PAST"], "Var"
    new $P2259, "String"
    assign $P2259, "!PREFIX__"
    find_lex $P2260, "$name"
    concat $P2261, $P2259, $P2260
    $P2262 = $P2258."new"($P2261 :named("name"), "package" :named("scope"))
    $P2263 = $P2246."new"($P2250, $P2252, $P2257, $P2262, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1009
    $P2245."push"($P2263)
  if_2227_end:
.annotate 'line', 1021
    find_lex $P2264, "$regex"
    find_lex $P2265, "$past"
    unless_null $P2265, vivify_727
    $P2265 = root_new ['parrot';'Hash']
    store_lex "$past", $P2265
  vivify_727:
    set $P2265["sink"], $P2264
.annotate 'line', 1022
    find_lex $P2266, "@MODIFIERS"
    $P2267 = $P2266."shift"()
.annotate 'line', 988
    .return ($P2267)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2181"  :anon :subid("114_1299450604.787") :outer("112_1299450604.787")
.annotate 'line', 976
    $P2183 = root_new ['parrot';'Hash']
    .lex "%h", $P2183
.annotate 'line', 975
    find_lex $P2184, "%h"
.annotate 'line', 977
    find_lex $P2186, "$/"
    unless_null $P2186, vivify_728
    $P2186 = root_new ['parrot';'Hash']
  vivify_728:
    set $P2187, $P2186["sym"]
    unless_null $P2187, vivify_729
    new $P2187, "Undef"
  vivify_729:
    set $S2188, $P2187
    iseq $I2189, $S2188, "token"
    unless $I2189, if_2185_end
    new $P2190, "Integer"
    assign $P2190, 1
    find_lex $P2191, "%h"
    unless_null $P2191, vivify_730
    $P2191 = root_new ['parrot';'Hash']
    store_lex "%h", $P2191
  vivify_730:
    set $P2191["r"], $P2190
  if_2185_end:
.annotate 'line', 978
    find_lex $P2193, "$/"
    unless_null $P2193, vivify_731
    $P2193 = root_new ['parrot';'Hash']
  vivify_731:
    set $P2194, $P2193["sym"]
    unless_null $P2194, vivify_732
    new $P2194, "Undef"
  vivify_732:
    set $S2195, $P2194
    iseq $I2196, $S2195, "rule"
    unless $I2196, if_2192_end
    new $P2197, "Integer"
    assign $P2197, 1
    find_lex $P2198, "%h"
    unless_null $P2198, vivify_733
    $P2198 = root_new ['parrot';'Hash']
    store_lex "%h", $P2198
  vivify_733:
    set $P2198["r"], $P2197
    new $P2199, "Integer"
    assign $P2199, 1
    find_lex $P2200, "%h"
    unless_null $P2200, vivify_734
    $P2200 = root_new ['parrot';'Hash']
    store_lex "%h", $P2200
  vivify_734:
    set $P2200["s"], $P2199
  if_2192_end:
.annotate 'line', 979
    find_lex $P2201, "@MODIFIERS"
    find_lex $P2202, "%h"
    $P2201."unshift"($P2202)
.annotate 'line', 980

            $P0 = find_lex '$name'
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 984
    get_global $P2203, "@BLOCK"
    unless_null $P2203, vivify_735
    $P2203 = root_new ['parrot';'ResizablePMCArray']
  vivify_735:
    set $P2204, $P2203[0]
    unless_null $P2204, vivify_736
    new $P2204, "Undef"
  vivify_736:
    $P2204."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 985
    get_global $P2205, "@BLOCK"
    unless_null $P2205, vivify_737
    $P2205 = root_new ['parrot';'ResizablePMCArray']
  vivify_737:
    set $P2206, $P2205[0]
    unless_null $P2206, vivify_738
    new $P2206, "Undef"
  vivify_738:
    $P2206."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 986
    new $P2207, "Exception"
    set $P2207['type'], .CONTROL_RETURN
    new $P2208, "Integer"
    assign $P2208, 0
    setattribute $P2207, 'payload', $P2208
    throw $P2207
.annotate 'line', 975
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2154"  :anon :subid("113_1299450604.787") :outer("112_1299450604.787")
    .param pmc param_2156
.annotate 'line', 962
    .lex "$_", param_2156
.annotate 'line', 963
    find_dynamic_lex $P2157, "$*PACKAGE-SETUP"
    unless_null $P2157, vivify_740
    get_hll_global $P2157, "$PACKAGE-SETUP"
    unless_null $P2157, vivify_741
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_741:
  vivify_740:
    get_hll_global $P2158, ["PAST"], "Op"
.annotate 'line', 965
    get_hll_global $P2159, ["PAST"], "Op"
.annotate 'line', 967
    get_hll_global $P2160, ["PAST"], "Var"
    $P2161 = $P2160."new"("type_obj" :named("name"), "register" :named("scope"))
    $P2162 = $P2159."new"($P2161, "get_how PP" :named("pirop"))
.annotate 'line', 969
    get_hll_global $P2163, ["PAST"], "Var"
    $P2164 = $P2163."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 970
    get_hll_global $P2165, ["PAST"], "Val"
    find_lex $P2166, "$_"
    $P2167 = $P2166."name"()
    $P2168 = $P2165."new"($P2167 :named("value"))
.annotate 'line', 971
    get_hll_global $P2169, ["PAST"], "Val"
    find_lex $P2170, "$_"
    $P2171 = $P2169."new"($P2170 :named("value"))
    $P2172 = $P2158."new"($P2162, $P2164, $P2168, $P2171, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 963
    $P2173 = $P2157."push"($P2172)
.annotate 'line', 962
    .return ($P2173)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("116_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2273
    .param pmc param_2274
.annotate 'line', 1028
    .lex "self", param_2273
    .lex "$/", param_2274
.annotate 'line', 1029
    new $P2275, "Undef"
    .lex "$past", $P2275
    find_lex $P2278, "$/"
    unless_null $P2278, vivify_742
    $P2278 = root_new ['parrot';'Hash']
  vivify_742:
    set $P2279, $P2278["args"]
    unless_null $P2279, vivify_743
    new $P2279, "Undef"
  vivify_743:
    if $P2279, if_2277
    get_hll_global $P2284, ["PAST"], "Op"
    find_lex $P2285, "$/"
    $P2286 = $P2284."new"($P2285 :named("node"))
    set $P2276, $P2286
    goto if_2277_end
  if_2277:
    find_lex $P2280, "$/"
    unless_null $P2280, vivify_744
    $P2280 = root_new ['parrot';'Hash']
  vivify_744:
    set $P2281, $P2280["args"]
    unless_null $P2281, vivify_745
    $P2281 = root_new ['parrot';'ResizablePMCArray']
  vivify_745:
    set $P2282, $P2281[0]
    unless_null $P2282, vivify_746
    new $P2282, "Undef"
  vivify_746:
    $P2283 = $P2282."ast"()
    set $P2276, $P2283
  if_2277_end:
    store_lex "$past", $P2276
.annotate 'line', 1030
    find_lex $P2288, "$/"
    unless_null $P2288, vivify_747
    $P2288 = root_new ['parrot';'Hash']
  vivify_747:
    set $P2289, $P2288["quote"]
    unless_null $P2289, vivify_748
    new $P2289, "Undef"
  vivify_748:
    if $P2289, if_2287
.annotate 'line', 1034
    find_lex $P2296, "$/"
    unless_null $P2296, vivify_749
    $P2296 = root_new ['parrot';'Hash']
  vivify_749:
    set $P2297, $P2296["longname"]
    unless_null $P2297, vivify_750
    new $P2297, "Undef"
  vivify_750:
    set $S2298, $P2297
    iseq $I2299, $S2298, "HOW"
    if $I2299, if_2295
.annotate 'line', 1038
    find_lex $P2303, "$/"
    unless_null $P2303, vivify_751
    $P2303 = root_new ['parrot';'Hash']
  vivify_751:
    set $P2304, $P2303["longname"]
    unless_null $P2304, vivify_752
    new $P2304, "Undef"
  vivify_752:
    set $S2305, $P2304
    iseq $I2306, $S2305, "WHAT"
    if $I2306, if_2302
.annotate 'line', 1042
    find_lex $P2308, "$past"
    find_lex $P2309, "$/"
    unless_null $P2309, vivify_753
    $P2309 = root_new ['parrot';'Hash']
  vivify_753:
    set $P2310, $P2309["longname"]
    unless_null $P2310, vivify_754
    new $P2310, "Undef"
  vivify_754:
    set $S2311, $P2310
    $P2308."name"($S2311)
.annotate 'line', 1043
    find_lex $P2312, "$past"
    $P2312."pasttype"("callmethod")
.annotate 'line', 1041
    goto if_2302_end
  if_2302:
.annotate 'line', 1039
    find_lex $P2307, "$past"
    $P2307."pirop"("get_what PP")
  if_2302_end:
.annotate 'line', 1038
    goto if_2295_end
  if_2295:
.annotate 'line', 1035
    find_lex $P2300, "$past"
    $P2300."pirop"("get_how PP")
.annotate 'line', 1036
    find_lex $P2301, "$past"
    $P2301."pasttype"("pirop")
  if_2295_end:
.annotate 'line', 1034
    goto if_2287_end
  if_2287:
.annotate 'line', 1031
    find_lex $P2290, "$past"
    find_lex $P2291, "$/"
    unless_null $P2291, vivify_755
    $P2291 = root_new ['parrot';'Hash']
  vivify_755:
    set $P2292, $P2291["quote"]
    unless_null $P2292, vivify_756
    new $P2292, "Undef"
  vivify_756:
    $P2293 = $P2292."ast"()
    $P2290."name"($P2293)
.annotate 'line', 1032
    find_lex $P2294, "$past"
    $P2294."pasttype"("callmethod")
  if_2287_end:
.annotate 'line', 1045
    find_lex $P2313, "$/"
    find_lex $P2314, "$past"
    $P2315 = $P2313."!make"($P2314)
.annotate 'line', 1028
    .return ($P2315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("117_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2317
    .param pmc param_2318
.annotate 'line', 1050
    .lex "self", param_2317
    .lex "$/", param_2318
.annotate 'line', 1051
    find_lex $P2319, "$/"
    get_hll_global $P2320, ["PAST"], "Var"
    $P2321 = $P2320."new"("self" :named("name"))
    $P2322 = $P2319."!make"($P2321)
.annotate 'line', 1050
    .return ($P2322)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("118_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2324
    .param pmc param_2325
.annotate 'line', 1054
    .lex "self", param_2324
    .lex "$/", param_2325
.annotate 'line', 1055
    new $P2326, "Undef"
    .lex "$past", $P2326
    find_lex $P2327, "$/"
    unless_null $P2327, vivify_757
    $P2327 = root_new ['parrot';'Hash']
  vivify_757:
    set $P2328, $P2327["args"]
    unless_null $P2328, vivify_758
    new $P2328, "Undef"
  vivify_758:
    $P2329 = $P2328."ast"()
    store_lex "$past", $P2329
.annotate 'line', 1056
    find_lex $P2330, "$past"
    find_lex $P2331, "$/"
    unless_null $P2331, vivify_759
    $P2331 = root_new ['parrot';'Hash']
  vivify_759:
    set $P2332, $P2331["deflongname"]
    unless_null $P2332, vivify_760
    new $P2332, "Undef"
  vivify_760:
    set $S2333, $P2332
    $P2330."name"($S2333)
.annotate 'line', 1057
    find_lex $P2334, "$/"
    find_lex $P2335, "$past"
    $P2336 = $P2334."!make"($P2335)
.annotate 'line', 1054
    .return ($P2336)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("119_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2338
    .param pmc param_2339
.annotate 'line', 1060
    .lex "self", param_2338
    .lex "$/", param_2339
.annotate 'line', 1061
    $P2340 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P2340
.annotate 'line', 1062
    new $P2341, "Undef"
    .lex "$name", $P2341
.annotate 'line', 1064
    new $P2342, "Undef"
    .lex "$var", $P2342
.annotate 'line', 1066
    new $P2343, "Undef"
    .lex "$past", $P2343
.annotate 'line', 1061
    find_lex $P2344, "$/"
    unless_null $P2344, vivify_761
    $P2344 = root_new ['parrot';'Hash']
  vivify_761:
    set $P2345, $P2344["name"]
    unless_null $P2345, vivify_762
    $P2345 = root_new ['parrot';'Hash']
  vivify_762:
    set $P2346, $P2345["identifier"]
    unless_null $P2346, vivify_763
    new $P2346, "Undef"
  vivify_763:
    clone $P2347, $P2346
    store_lex "@ns", $P2347
.annotate 'line', 1062
    find_lex $P2348, "@ns"
    $P2349 = $P2348."pop"()
    store_lex "$name", $P2349
.annotate 'line', 1063
    find_lex $P2353, "@ns"
    if $P2353, if_2352
    set $P2351, $P2353
    goto if_2352_end
  if_2352:
    find_lex $P2354, "@ns"
    unless_null $P2354, vivify_764
    $P2354 = root_new ['parrot';'ResizablePMCArray']
  vivify_764:
    set $P2355, $P2354[0]
    unless_null $P2355, vivify_765
    new $P2355, "Undef"
  vivify_765:
    set $S2356, $P2355
    iseq $I2357, $S2356, "GLOBAL"
    new $P2351, 'Integer'
    set $P2351, $I2357
  if_2352_end:
    unless $P2351, if_2350_end
    find_lex $P2358, "@ns"
    $P2358."shift"()
  if_2350_end:
.annotate 'line', 1065
    get_hll_global $P2359, ["PAST"], "Var"
    find_lex $P2360, "$name"
    set $S2361, $P2360
    find_lex $P2362, "@ns"
    $P2363 = $P2359."new"($S2361 :named("name"), $P2362 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P2363
.annotate 'line', 1066
    find_lex $P2364, "$var"
    store_lex "$past", $P2364
.annotate 'line', 1067
    find_lex $P2366, "$/"
    unless_null $P2366, vivify_766
    $P2366 = root_new ['parrot';'Hash']
  vivify_766:
    set $P2367, $P2366["args"]
    unless_null $P2367, vivify_767
    new $P2367, "Undef"
  vivify_767:
    unless $P2367, if_2365_end
.annotate 'line', 1068
    find_lex $P2368, "$/"
    unless_null $P2368, vivify_768
    $P2368 = root_new ['parrot';'Hash']
  vivify_768:
    set $P2369, $P2368["args"]
    unless_null $P2369, vivify_769
    $P2369 = root_new ['parrot';'ResizablePMCArray']
  vivify_769:
    set $P2370, $P2369[0]
    unless_null $P2370, vivify_770
    new $P2370, "Undef"
  vivify_770:
    $P2371 = $P2370."ast"()
    store_lex "$past", $P2371
.annotate 'line', 1069
    find_lex $P2372, "$past"
    find_lex $P2373, "$var"
    $P2372."unshift"($P2373)
  if_2365_end:
.annotate 'line', 1071
    find_lex $P2374, "$/"
    find_lex $P2375, "$past"
    $P2376 = $P2374."!make"($P2375)
.annotate 'line', 1060
    .return ($P2376)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("120_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2378
    .param pmc param_2379
.annotate 'line', 1074
    .lex "self", param_2378
    .lex "$/", param_2379
.annotate 'line', 1075
    new $P2380, "Undef"
    .lex "$past", $P2380
.annotate 'line', 1076
    new $P2381, "Undef"
    .lex "$pirop", $P2381
.annotate 'line', 1075
    find_lex $P2384, "$/"
    unless_null $P2384, vivify_771
    $P2384 = root_new ['parrot';'Hash']
  vivify_771:
    set $P2385, $P2384["args"]
    unless_null $P2385, vivify_772
    new $P2385, "Undef"
  vivify_772:
    if $P2385, if_2383
    get_hll_global $P2390, ["PAST"], "Op"
    find_lex $P2391, "$/"
    $P2392 = $P2390."new"($P2391 :named("node"))
    set $P2382, $P2392
    goto if_2383_end
  if_2383:
    find_lex $P2386, "$/"
    unless_null $P2386, vivify_773
    $P2386 = root_new ['parrot';'Hash']
  vivify_773:
    set $P2387, $P2386["args"]
    unless_null $P2387, vivify_774
    $P2387 = root_new ['parrot';'ResizablePMCArray']
  vivify_774:
    set $P2388, $P2387[0]
    unless_null $P2388, vivify_775
    new $P2388, "Undef"
  vivify_775:
    $P2389 = $P2388."ast"()
    set $P2382, $P2389
  if_2383_end:
    store_lex "$past", $P2382
.annotate 'line', 1076
    find_lex $P2393, "$/"
    unless_null $P2393, vivify_776
    $P2393 = root_new ['parrot';'Hash']
  vivify_776:
    set $P2394, $P2393["op"]
    unless_null $P2394, vivify_777
    new $P2394, "Undef"
  vivify_777:
    set $S2395, $P2394
    new $P2396, 'String'
    set $P2396, $S2395
    store_lex "$pirop", $P2396
.annotate 'line', 1077

        $P0 = find_lex '$pirop'
        $S0 = $P0
        $P0 = split '__', $S0
        $S0 = join ' ', $P0
        $P2397 = box $S0
    
    store_lex "$pirop", $P2397
.annotate 'line', 1084
    find_lex $P2398, "$past"
    find_lex $P2399, "$pirop"
    $P2398."pirop"($P2399)
.annotate 'line', 1085
    find_lex $P2400, "$past"
    $P2400."pasttype"("pirop")
.annotate 'line', 1086
    find_lex $P2401, "$/"
    find_lex $P2402, "$past"
    $P2403 = $P2401."!make"($P2402)
.annotate 'line', 1074
    .return ($P2403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("121_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2405
    .param pmc param_2406
.annotate 'line', 1089
    .lex "self", param_2405
    .lex "$/", param_2406
.annotate 'line', 1090
    find_lex $P2407, "$/"
    get_hll_global $P2408, ["PAST"], "Op"
    $P2409 = $P2408."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2410 = $P2407."!make"($P2409)
.annotate 'line', 1089
    .return ($P2410)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("122_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2412
    .param pmc param_2413
.annotate 'line', 1095
    .lex "self", param_2412
    .lex "$/", param_2413
    find_lex $P2414, "$/"
    find_lex $P2415, "$/"
    unless_null $P2415, vivify_778
    $P2415 = root_new ['parrot';'Hash']
  vivify_778:
    set $P2416, $P2415["arglist"]
    unless_null $P2416, vivify_779
    new $P2416, "Undef"
  vivify_779:
    $P2417 = $P2416."ast"()
    $P2418 = $P2414."!make"($P2417)
    .return ($P2418)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("123_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2420
    .param pmc param_2421
.annotate 'line', 1097
    .const 'Sub' $P2432 = "124_1299450604.787" 
    capture_lex $P2432
    .lex "self", param_2420
    .lex "$/", param_2421
.annotate 'line', 1098
    new $P2422, "Undef"
    .lex "$past", $P2422
.annotate 'line', 1106
    new $P2423, "Undef"
    .lex "$i", $P2423
.annotate 'line', 1107
    new $P2424, "Undef"
    .lex "$n", $P2424
.annotate 'line', 1098
    get_hll_global $P2425, ["PAST"], "Op"
    find_lex $P2426, "$/"
    $P2427 = $P2425."new"("call" :named("pasttype"), $P2426 :named("node"))
    store_lex "$past", $P2427
.annotate 'line', 1099
    find_lex $P2429, "$/"
    unless_null $P2429, vivify_780
    $P2429 = root_new ['parrot';'Hash']
  vivify_780:
    set $P2430, $P2429["EXPR"]
    unless_null $P2430, vivify_781
    new $P2430, "Undef"
  vivify_781:
    unless $P2430, if_2428_end
    .const 'Sub' $P2432 = "124_1299450604.787" 
    capture_lex $P2432
    $P2432()
  if_2428_end:
.annotate 'line', 1106
    new $P2464, "Integer"
    assign $P2464, 0
    store_lex "$i", $P2464
.annotate 'line', 1107
    find_lex $P2465, "$past"
    $P2466 = $P2465."list"()
    set $N2467, $P2466
    new $P2468, 'Float'
    set $P2468, $N2467
    store_lex "$n", $P2468
.annotate 'line', 1108
    new $P2516, 'ExceptionHandler'
    set_label $P2516, loop2515_handler
    $P2516."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2516
  loop2515_test:
    find_lex $P2469, "$i"
    set $N2470, $P2469
    find_lex $P2471, "$n"
    set $N2472, $P2471
    islt $I2473, $N2470, $N2472
    unless $I2473, loop2515_done
  loop2515_redo:
.annotate 'line', 1109
    find_lex $P2475, "$i"
    set $I2476, $P2475
    find_lex $P2477, "$past"
    unless_null $P2477, vivify_785
    $P2477 = root_new ['parrot';'ResizablePMCArray']
  vivify_785:
    set $P2478, $P2477[$I2476]
    unless_null $P2478, vivify_786
    new $P2478, "Undef"
  vivify_786:
    $S2479 = $P2478."name"()
    iseq $I2480, $S2479, "&prefix:<|>"
    unless $I2480, if_2474_end
.annotate 'line', 1110
    find_lex $P2481, "$i"
    set $I2482, $P2481
    find_lex $P2483, "$past"
    unless_null $P2483, vivify_787
    $P2483 = root_new ['parrot';'ResizablePMCArray']
  vivify_787:
    set $P2484, $P2483[$I2482]
    unless_null $P2484, vivify_788
    $P2484 = root_new ['parrot';'ResizablePMCArray']
  vivify_788:
    set $P2485, $P2484[0]
    unless_null $P2485, vivify_789
    new $P2485, "Undef"
  vivify_789:
    find_lex $P2486, "$i"
    set $I2487, $P2486
    find_lex $P2488, "$past"
    unless_null $P2488, vivify_790
    $P2488 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P2488
  vivify_790:
    set $P2488[$I2487], $P2485
.annotate 'line', 1111
    find_lex $P2489, "$i"
    set $I2490, $P2489
    find_lex $P2491, "$past"
    unless_null $P2491, vivify_791
    $P2491 = root_new ['parrot';'ResizablePMCArray']
  vivify_791:
    set $P2492, $P2491[$I2490]
    unless_null $P2492, vivify_792
    new $P2492, "Undef"
  vivify_792:
    $P2492."flat"(1)
.annotate 'line', 1112
    find_lex $P2496, "$i"
    set $I2497, $P2496
    find_lex $P2498, "$past"
    unless_null $P2498, vivify_793
    $P2498 = root_new ['parrot';'ResizablePMCArray']
  vivify_793:
    set $P2499, $P2498[$I2497]
    unless_null $P2499, vivify_794
    new $P2499, "Undef"
  vivify_794:
    get_hll_global $P2500, ["PAST"], "Val"
    $P2501 = $P2499."isa"($P2500)
    if $P2501, if_2495
    set $P2494, $P2501
    goto if_2495_end
  if_2495:
.annotate 'line', 1113
    find_lex $P2502, "$i"
    set $I2503, $P2502
    find_lex $P2504, "$past"
    unless_null $P2504, vivify_795
    $P2504 = root_new ['parrot';'ResizablePMCArray']
  vivify_795:
    set $P2505, $P2504[$I2503]
    unless_null $P2505, vivify_796
    new $P2505, "Undef"
  vivify_796:
    $S2506 = $P2505."name"()
    substr $S2507, $S2506, 0, 1
    iseq $I2508, $S2507, "%"
    new $P2494, 'Integer'
    set $P2494, $I2508
  if_2495_end:
    unless $P2494, if_2493_end
.annotate 'line', 1114
    find_lex $P2509, "$i"
    set $I2510, $P2509
    find_lex $P2511, "$past"
    unless_null $P2511, vivify_797
    $P2511 = root_new ['parrot';'ResizablePMCArray']
  vivify_797:
    set $P2512, $P2511[$I2510]
    unless_null $P2512, vivify_798
    new $P2512, "Undef"
  vivify_798:
    $P2512."named"(1)
  if_2493_end:
  if_2474_end:
.annotate 'line', 1109
    find_lex $P2513, "$i"
    clone $P2514, $P2513
    inc $P2513
  loop2515_next:
.annotate 'line', 1108
    goto loop2515_test
  loop2515_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2517, exception, 'type'
    eq $P2517, .CONTROL_LOOP_NEXT, loop2515_next
    eq $P2517, .CONTROL_LOOP_REDO, loop2515_redo
  loop2515_done:
    pop_eh 
.annotate 'line', 1119
    find_lex $P2518, "$/"
    find_lex $P2519, "$past"
    $P2520 = $P2518."!make"($P2519)
.annotate 'line', 1097
    .return ($P2520)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2431"  :anon :subid("124_1299450604.787") :outer("123_1299450604.787")
.annotate 'line', 1099
    .const 'Sub' $P2453 = "125_1299450604.787" 
    capture_lex $P2453
.annotate 'line', 1100
    new $P2433, "Undef"
    .lex "$expr", $P2433
    find_lex $P2434, "$/"
    unless_null $P2434, vivify_782
    $P2434 = root_new ['parrot';'Hash']
  vivify_782:
    set $P2435, $P2434["EXPR"]
    unless_null $P2435, vivify_783
    new $P2435, "Undef"
  vivify_783:
    $P2436 = $P2435."ast"()
    store_lex "$expr", $P2436
.annotate 'line', 1101
    find_lex $P2441, "$expr"
    $S2442 = $P2441."name"()
    iseq $I2443, $S2442, "&infix:<,>"
    if $I2443, if_2440
    new $P2439, 'Integer'
    set $P2439, $I2443
    goto if_2440_end
  if_2440:
    find_lex $P2444, "$expr"
    $P2445 = $P2444."named"()
    isfalse $I2446, $P2445
    new $P2439, 'Integer'
    set $P2439, $I2446
  if_2440_end:
    if $P2439, if_2438
.annotate 'line', 1104
    find_lex $P2461, "$past"
    find_lex $P2462, "$expr"
    $P2463 = $P2461."push"($P2462)
    set $P2437, $P2463
.annotate 'line', 1101
    goto if_2438_end
  if_2438:
.annotate 'line', 1102
    find_lex $P2448, "$expr"
    $P2449 = $P2448."list"()
    defined $I2450, $P2449
    unless $I2450, for_undef_784
    iter $P2447, $P2449
    new $P2459, 'ExceptionHandler'
    set_label $P2459, loop2458_handler
    $P2459."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2459
  loop2458_test:
    unless $P2447, loop2458_done
    shift $P2451, $P2447
  loop2458_redo:
    .const 'Sub' $P2453 = "125_1299450604.787" 
    capture_lex $P2453
    $P2453($P2451)
  loop2458_next:
    goto loop2458_test
  loop2458_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2460, exception, 'type'
    eq $P2460, .CONTROL_LOOP_NEXT, loop2458_next
    eq $P2460, .CONTROL_LOOP_REDO, loop2458_redo
  loop2458_done:
    pop_eh 
  for_undef_784:
.annotate 'line', 1101
    set $P2437, $P2447
  if_2438_end:
.annotate 'line', 1099
    .return ($P2437)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2452"  :anon :subid("125_1299450604.787") :outer("124_1299450604.787")
    .param pmc param_2454
.annotate 'line', 1102
    .lex "$_", param_2454
    find_lex $P2455, "$past"
    find_lex $P2456, "$_"
    $P2457 = $P2455."push"($P2456)
    .return ($P2457)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("126_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2522
    .param pmc param_2523
.annotate 'line', 1122
    .lex "self", param_2522
    .lex "$/", param_2523
    find_lex $P2524, "$/"
    find_lex $P2525, "$/"
    unless_null $P2525, vivify_799
    $P2525 = root_new ['parrot';'Hash']
  vivify_799:
    set $P2526, $P2525["multi_declarator"]
    unless_null $P2526, vivify_800
    new $P2526, "Undef"
  vivify_800:
    $P2527 = $P2526."ast"()
    $P2528 = $P2524."!make"($P2527)
    .return ($P2528)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("127_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2530
    .param pmc param_2531
.annotate 'line', 1124
    .lex "self", param_2530
    .lex "$/", param_2531
    find_lex $P2532, "$/"
    find_lex $P2533, "$/"
    unless_null $P2533, vivify_801
    $P2533 = root_new ['parrot';'Hash']
  vivify_801:
    set $P2534, $P2533["value"]
    unless_null $P2534, vivify_802
    new $P2534, "Undef"
  vivify_802:
    $P2535 = $P2534."ast"()
    $P2536 = $P2532."!make"($P2535)
    .return ($P2536)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("128_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2538
    .param pmc param_2539
.annotate 'line', 1126
    .lex "self", param_2538
    .lex "$/", param_2539
.annotate 'line', 1127
    find_lex $P2540, "$/"
.annotate 'line', 1128
    find_lex $P2543, "$/"
    unless_null $P2543, vivify_803
    $P2543 = root_new ['parrot';'Hash']
  vivify_803:
    set $P2544, $P2543["EXPR"]
    unless_null $P2544, vivify_804
    new $P2544, "Undef"
  vivify_804:
    if $P2544, if_2542
.annotate 'line', 1129
    get_hll_global $P2549, ["PAST"], "Op"
    find_lex $P2550, "$/"
    $P2551 = $P2549."new"("list" :named("pasttype"), $P2550 :named("node"))
    set $P2541, $P2551
.annotate 'line', 1128
    goto if_2542_end
  if_2542:
    find_lex $P2545, "$/"
    unless_null $P2545, vivify_805
    $P2545 = root_new ['parrot';'Hash']
  vivify_805:
    set $P2546, $P2545["EXPR"]
    unless_null $P2546, vivify_806
    $P2546 = root_new ['parrot';'ResizablePMCArray']
  vivify_806:
    set $P2547, $P2546[0]
    unless_null $P2547, vivify_807
    new $P2547, "Undef"
  vivify_807:
    $P2548 = $P2547."ast"()
    set $P2541, $P2548
  if_2542_end:
    $P2552 = $P2540."!make"($P2541)
.annotate 'line', 1126
    .return ($P2552)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("129_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2554
    .param pmc param_2555
.annotate 'line', 1132
    .lex "self", param_2554
    .lex "$/", param_2555
.annotate 'line', 1133
    new $P2556, "Undef"
    .lex "$past", $P2556
.annotate 'line', 1132
    find_lex $P2557, "$past"
.annotate 'line', 1134
    find_lex $P2559, "$/"
    unless_null $P2559, vivify_808
    $P2559 = root_new ['parrot';'Hash']
  vivify_808:
    set $P2560, $P2559["EXPR"]
    unless_null $P2560, vivify_809
    new $P2560, "Undef"
  vivify_809:
    if $P2560, if_2558
.annotate 'line', 1141
    get_hll_global $P2572, ["PAST"], "Op"
    $P2573 = $P2572."new"("list" :named("pasttype"))
    store_lex "$past", $P2573
.annotate 'line', 1140
    goto if_2558_end
  if_2558:
.annotate 'line', 1135
    find_lex $P2561, "$/"
    unless_null $P2561, vivify_810
    $P2561 = root_new ['parrot';'Hash']
  vivify_810:
    set $P2562, $P2561["EXPR"]
    unless_null $P2562, vivify_811
    $P2562 = root_new ['parrot';'ResizablePMCArray']
  vivify_811:
    set $P2563, $P2562[0]
    unless_null $P2563, vivify_812
    new $P2563, "Undef"
  vivify_812:
    $P2564 = $P2563."ast"()
    store_lex "$past", $P2564
.annotate 'line', 1136
    find_lex $P2566, "$past"
    $S2567 = $P2566."name"()
    isne $I2568, $S2567, "&infix:<,>"
    unless $I2568, if_2565_end
.annotate 'line', 1137
    get_hll_global $P2569, ["PAST"], "Op"
    find_lex $P2570, "$past"
    $P2571 = $P2569."new"($P2570, "list" :named("pasttype"))
    store_lex "$past", $P2571
  if_2565_end:
  if_2558_end:
.annotate 'line', 1143
    find_lex $P2574, "$past"
    $P2574."name"("&circumfix:<[ ]>")
.annotate 'line', 1144
    find_lex $P2575, "$/"
    find_lex $P2576, "$past"
    $P2577 = $P2575."!make"($P2576)
.annotate 'line', 1132
    .return ($P2577)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("130_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2579
    .param pmc param_2580
.annotate 'line', 1147
    .lex "self", param_2579
    .lex "$/", param_2580
    find_lex $P2581, "$/"
    find_lex $P2582, "$/"
    unless_null $P2582, vivify_813
    $P2582 = root_new ['parrot';'Hash']
  vivify_813:
    set $P2583, $P2582["quote_EXPR"]
    unless_null $P2583, vivify_814
    new $P2583, "Undef"
  vivify_814:
    $P2584 = $P2583."ast"()
    $P2585 = $P2581."!make"($P2584)
    .return ($P2585)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("131_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2587
    .param pmc param_2588
.annotate 'line', 1148
    .lex "self", param_2587
    .lex "$/", param_2588
    find_lex $P2589, "$/"
    find_lex $P2590, "$/"
    unless_null $P2590, vivify_815
    $P2590 = root_new ['parrot';'Hash']
  vivify_815:
    set $P2591, $P2590["quote_EXPR"]
    unless_null $P2591, vivify_816
    new $P2591, "Undef"
  vivify_816:
    $P2592 = $P2591."ast"()
    $P2593 = $P2589."!make"($P2592)
    .return ($P2593)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("132_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2595
    .param pmc param_2596
.annotate 'line', 1150
    .const 'Sub' $P2607 = "133_1299450604.787" 
    capture_lex $P2607
    .lex "self", param_2595
    .lex "$/", param_2596
.annotate 'line', 1151
    find_lex $P2599, "$/"
    unless_null $P2599, vivify_817
    $P2599 = root_new ['parrot';'Hash']
  vivify_817:
    set $P2600, $P2599["pblock"]
    unless_null $P2600, vivify_818
    $P2600 = root_new ['parrot';'Hash']
  vivify_818:
    set $P2601, $P2600["blockoid"]
    unless_null $P2601, vivify_819
    $P2601 = root_new ['parrot';'Hash']
  vivify_819:
    set $P2602, $P2601["statementlist"]
    unless_null $P2602, vivify_820
    $P2602 = root_new ['parrot';'Hash']
  vivify_820:
    set $P2603, $P2602["statement"]
    unless_null $P2603, vivify_821
    new $P2603, "Undef"
  vivify_821:
    set $N2604, $P2603
    isgt $I2605, $N2604, 0.0
    if $I2605, if_2598
.annotate 'line', 1156
    find_lex $P2620, "$/"
    unless_null $P2620, vivify_822
    $P2620 = root_new ['parrot';'Hash']
  vivify_822:
    set $P2621, $P2620["pblock"]
    unless_null $P2621, vivify_823
    $P2621 = root_new ['parrot';'Hash']
  vivify_823:
    set $P2622, $P2621["blockoid"]
    unless_null $P2622, vivify_824
    $P2622 = root_new ['parrot';'Hash']
  vivify_824:
    set $P2623, $P2622["you_are_here"]
    unless_null $P2623, vivify_825
    new $P2623, "Undef"
  vivify_825:
    if $P2623, if_2619
.annotate 'line', 1160
    find_lex $P2629, "$/"
    $P2630 = "vivitype"("%")
    $P2631 = $P2629."!make"($P2630)
.annotate 'line', 1159
    set $P2618, $P2631
.annotate 'line', 1156
    goto if_2619_end
  if_2619:
.annotate 'line', 1157
    find_lex $P2624, "$/"
    find_lex $P2625, "$/"
    unless_null $P2625, vivify_826
    $P2625 = root_new ['parrot';'Hash']
  vivify_826:
    set $P2626, $P2625["pblock"]
    unless_null $P2626, vivify_827
    new $P2626, "Undef"
  vivify_827:
    $P2627 = $P2626."ast"()
    $P2628 = $P2624."!make"($P2627)
.annotate 'line', 1156
    set $P2618, $P2628
  if_2619_end:
    set $P2597, $P2618
.annotate 'line', 1151
    goto if_2598_end
  if_2598:
    .const 'Sub' $P2607 = "133_1299450604.787" 
    capture_lex $P2607
    $P2617 = $P2607()
    set $P2597, $P2617
  if_2598_end:
.annotate 'line', 1150
    .return ($P2597)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2606"  :anon :subid("133_1299450604.787") :outer("132_1299450604.787")
.annotate 'line', 1152
    new $P2608, "Undef"
    .lex "$past", $P2608
    find_lex $P2609, "$/"
    unless_null $P2609, vivify_828
    $P2609 = root_new ['parrot';'Hash']
  vivify_828:
    set $P2610, $P2609["pblock"]
    unless_null $P2610, vivify_829
    new $P2610, "Undef"
  vivify_829:
    $P2611 = $P2610."ast"()
    store_lex "$past", $P2611
.annotate 'line', 1153
    new $P2612, "Integer"
    assign $P2612, 1
    find_lex $P2613, "$past"
    unless_null $P2613, vivify_830
    $P2613 = root_new ['parrot';'Hash']
    store_lex "$past", $P2613
  vivify_830:
    set $P2613["bareblock"], $P2612
.annotate 'line', 1154
    find_dynamic_lex $P2614, "$/"
    find_lex $P2615, "$past"
    $P2616 = $P2614."!make"($P2615)
.annotate 'line', 1151
    .return ($P2616)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("134_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2633
    .param pmc param_2634
.annotate 'line', 1164
    .lex "self", param_2633
    .lex "$/", param_2634
.annotate 'line', 1165
    new $P2635, "Undef"
    .lex "$name", $P2635
    find_lex $P2638, "$/"
    unless_null $P2638, vivify_831
    $P2638 = root_new ['parrot';'Hash']
  vivify_831:
    set $P2639, $P2638["sigil"]
    unless_null $P2639, vivify_832
    new $P2639, "Undef"
  vivify_832:
    set $S2640, $P2639
    iseq $I2641, $S2640, "@"
    if $I2641, if_2637
.annotate 'line', 1166
    find_lex $P2645, "$/"
    unless_null $P2645, vivify_833
    $P2645 = root_new ['parrot';'Hash']
  vivify_833:
    set $P2646, $P2645["sigil"]
    unless_null $P2646, vivify_834
    new $P2646, "Undef"
  vivify_834:
    set $S2647, $P2646
    iseq $I2648, $S2647, "%"
    if $I2648, if_2644
    new $P2650, "String"
    assign $P2650, "item"
    set $P2643, $P2650
    goto if_2644_end
  if_2644:
    new $P2649, "String"
    assign $P2649, "hash"
    set $P2643, $P2649
  if_2644_end:
    set $P2636, $P2643
.annotate 'line', 1165
    goto if_2637_end
  if_2637:
    new $P2642, "String"
    assign $P2642, "list"
    set $P2636, $P2642
  if_2637_end:
    store_lex "$name", $P2636
.annotate 'line', 1168
    find_lex $P2651, "$/"
    get_hll_global $P2652, ["PAST"], "Op"
    find_lex $P2653, "$name"
    find_lex $P2654, "$/"
    unless_null $P2654, vivify_835
    $P2654 = root_new ['parrot';'Hash']
  vivify_835:
    set $P2655, $P2654["semilist"]
    unless_null $P2655, vivify_836
    new $P2655, "Undef"
  vivify_836:
    $P2656 = $P2655."ast"()
    $P2657 = $P2652."new"($P2656, "callmethod" :named("pasttype"), $P2653 :named("name"))
    $P2658 = $P2651."!make"($P2657)
.annotate 'line', 1164
    .return ($P2658)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("135_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2660
    .param pmc param_2661
.annotate 'line', 1171
    .lex "self", param_2660
    .lex "$/", param_2661
    find_lex $P2662, "$/"
    find_lex $P2663, "$/"
    unless_null $P2663, vivify_837
    $P2663 = root_new ['parrot';'Hash']
  vivify_837:
    set $P2664, $P2663["statement"]
    unless_null $P2664, vivify_838
    new $P2664, "Undef"
  vivify_838:
    $P2665 = $P2664."ast"()
    $P2666 = $P2662."!make"($P2665)
    .return ($P2666)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("136_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2668
    .param pmc param_2669
.annotate 'line', 1173
    .lex "self", param_2668
    .lex "$/", param_2669
.annotate 'line', 1174
    find_lex $P2670, "$/"
    get_hll_global $P2671, ["PAST"], "Var"
    find_lex $P2672, "$/"
    unless_null $P2672, vivify_839
    $P2672 = root_new ['parrot';'Hash']
  vivify_839:
    set $P2673, $P2672["EXPR"]
    unless_null $P2673, vivify_840
    new $P2673, "Undef"
  vivify_840:
    $P2674 = $P2673."ast"()
.annotate 'line', 1176
    $P2675 = "vivitype"("@")
    $P2676 = $P2671."new"($P2674, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P2675 :named("vivibase"))
.annotate 'line', 1174
    $P2677 = $P2670."!make"($P2676)
.annotate 'line', 1173
    .return ($P2677)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("137_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2679
    .param pmc param_2680
.annotate 'line', 1179
    .lex "self", param_2679
    .lex "$/", param_2680
.annotate 'line', 1180
    find_lex $P2681, "$/"
    get_hll_global $P2682, ["PAST"], "Var"
    find_lex $P2683, "$/"
    unless_null $P2683, vivify_841
    $P2683 = root_new ['parrot';'Hash']
  vivify_841:
    set $P2684, $P2683["EXPR"]
    unless_null $P2684, vivify_842
    new $P2684, "Undef"
  vivify_842:
    $P2685 = $P2684."ast"()
.annotate 'line', 1182
    $P2686 = "vivitype"("%")
    $P2687 = $P2682."new"($P2685, "keyed" :named("scope"), "Undef" :named("viviself"), $P2686 :named("vivibase"))
.annotate 'line', 1180
    $P2688 = $P2681."!make"($P2687)
.annotate 'line', 1179
    .return ($P2688)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("138_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2690
    .param pmc param_2691
.annotate 'line', 1185
    .lex "self", param_2690
    .lex "$/", param_2691
.annotate 'line', 1186
    find_lex $P2692, "$/"
    get_hll_global $P2693, ["PAST"], "Var"
    find_lex $P2694, "$/"
    unless_null $P2694, vivify_843
    $P2694 = root_new ['parrot';'Hash']
  vivify_843:
    set $P2695, $P2694["quote_EXPR"]
    unless_null $P2695, vivify_844
    new $P2695, "Undef"
  vivify_844:
    $P2696 = $P2695."ast"()
.annotate 'line', 1188
    $P2697 = "vivitype"("%")
    $P2698 = $P2693."new"($P2696, "keyed" :named("scope"), "Undef" :named("viviself"), $P2697 :named("vivibase"))
.annotate 'line', 1186
    $P2699 = $P2692."!make"($P2698)
.annotate 'line', 1185
    .return ($P2699)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("139_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2701
    .param pmc param_2702
.annotate 'line', 1191
    .lex "self", param_2701
    .lex "$/", param_2702
.annotate 'line', 1192
    find_lex $P2703, "$/"
    find_lex $P2704, "$/"
    unless_null $P2704, vivify_845
    $P2704 = root_new ['parrot';'Hash']
  vivify_845:
    set $P2705, $P2704["arglist"]
    unless_null $P2705, vivify_846
    new $P2705, "Undef"
  vivify_846:
    $P2706 = $P2705."ast"()
    $P2707 = $P2703."!make"($P2706)
.annotate 'line', 1191
    .return ($P2707)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("140_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2709
    .param pmc param_2710
.annotate 'line', 1195
    .lex "self", param_2709
    .lex "$/", param_2710
.annotate 'line', 1196
    find_lex $P2711, "$/"
    find_lex $P2714, "$/"
    unless_null $P2714, vivify_847
    $P2714 = root_new ['parrot';'Hash']
  vivify_847:
    set $P2715, $P2714["quote"]
    unless_null $P2715, vivify_848
    new $P2715, "Undef"
  vivify_848:
    if $P2715, if_2713
    find_lex $P2719, "$/"
    unless_null $P2719, vivify_849
    $P2719 = root_new ['parrot';'Hash']
  vivify_849:
    set $P2720, $P2719["number"]
    unless_null $P2720, vivify_850
    new $P2720, "Undef"
  vivify_850:
    $P2721 = $P2720."ast"()
    set $P2712, $P2721
    goto if_2713_end
  if_2713:
    find_lex $P2716, "$/"
    unless_null $P2716, vivify_851
    $P2716 = root_new ['parrot';'Hash']
  vivify_851:
    set $P2717, $P2716["quote"]
    unless_null $P2717, vivify_852
    new $P2717, "Undef"
  vivify_852:
    $P2718 = $P2717."ast"()
    set $P2712, $P2718
  if_2713_end:
    $P2722 = $P2711."!make"($P2712)
.annotate 'line', 1195
    .return ($P2722)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("141_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2724
    .param pmc param_2725
.annotate 'line', 1199
    .lex "self", param_2724
    .lex "$/", param_2725
.annotate 'line', 1200
    new $P2726, "Undef"
    .lex "$value", $P2726
    find_lex $P2729, "$/"
    unless_null $P2729, vivify_853
    $P2729 = root_new ['parrot';'Hash']
  vivify_853:
    set $P2730, $P2729["dec_number"]
    unless_null $P2730, vivify_854
    new $P2730, "Undef"
  vivify_854:
    if $P2730, if_2728
    find_lex $P2734, "$/"
    unless_null $P2734, vivify_855
    $P2734 = root_new ['parrot';'Hash']
  vivify_855:
    set $P2735, $P2734["integer"]
    unless_null $P2735, vivify_856
    new $P2735, "Undef"
  vivify_856:
    $P2736 = $P2735."ast"()
    set $P2727, $P2736
    goto if_2728_end
  if_2728:
    find_lex $P2731, "$/"
    unless_null $P2731, vivify_857
    $P2731 = root_new ['parrot';'Hash']
  vivify_857:
    set $P2732, $P2731["dec_number"]
    unless_null $P2732, vivify_858
    new $P2732, "Undef"
  vivify_858:
    $P2733 = $P2732."ast"()
    set $P2727, $P2733
  if_2728_end:
    store_lex "$value", $P2727
.annotate 'line', 1201
    find_lex $P2738, "$/"
    unless_null $P2738, vivify_859
    $P2738 = root_new ['parrot';'Hash']
  vivify_859:
    set $P2739, $P2738["sign"]
    unless_null $P2739, vivify_860
    new $P2739, "Undef"
  vivify_860:
    set $S2740, $P2739
    iseq $I2741, $S2740, "-"
    unless $I2741, if_2737_end
    find_lex $P2742, "$value"
    neg $P2743, $P2742
    store_lex "$value", $P2743
  if_2737_end:
.annotate 'line', 1202
    find_lex $P2744, "$/"
    get_hll_global $P2745, ["PAST"], "Val"
    find_lex $P2746, "$value"
    $P2747 = $P2745."new"($P2746 :named("value"))
    $P2748 = $P2744."!make"($P2747)
.annotate 'line', 1199
    .return ($P2748)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("142_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2750
    .param pmc param_2751
.annotate 'line', 1205
    .lex "self", param_2750
    .lex "$/", param_2751
    find_lex $P2752, "$/"
    find_lex $P2753, "$/"
    unless_null $P2753, vivify_861
    $P2753 = root_new ['parrot';'Hash']
  vivify_861:
    set $P2754, $P2753["quote_EXPR"]
    unless_null $P2754, vivify_862
    new $P2754, "Undef"
  vivify_862:
    $P2755 = $P2754."ast"()
    $P2756 = $P2752."!make"($P2755)
    .return ($P2756)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("143_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2758
    .param pmc param_2759
.annotate 'line', 1206
    .lex "self", param_2758
    .lex "$/", param_2759
    find_lex $P2760, "$/"
    find_lex $P2761, "$/"
    unless_null $P2761, vivify_863
    $P2761 = root_new ['parrot';'Hash']
  vivify_863:
    set $P2762, $P2761["quote_EXPR"]
    unless_null $P2762, vivify_864
    new $P2762, "Undef"
  vivify_864:
    $P2763 = $P2762."ast"()
    $P2764 = $P2760."!make"($P2763)
    .return ($P2764)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("144_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2766
    .param pmc param_2767
.annotate 'line', 1207
    .lex "self", param_2766
    .lex "$/", param_2767
    find_lex $P2768, "$/"
    find_lex $P2769, "$/"
    unless_null $P2769, vivify_865
    $P2769 = root_new ['parrot';'Hash']
  vivify_865:
    set $P2770, $P2769["quote_EXPR"]
    unless_null $P2770, vivify_866
    new $P2770, "Undef"
  vivify_866:
    $P2771 = $P2770."ast"()
    $P2772 = $P2768."!make"($P2771)
    .return ($P2772)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("145_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2774
    .param pmc param_2775
.annotate 'line', 1208
    .lex "self", param_2774
    .lex "$/", param_2775
    find_lex $P2776, "$/"
    find_lex $P2777, "$/"
    unless_null $P2777, vivify_867
    $P2777 = root_new ['parrot';'Hash']
  vivify_867:
    set $P2778, $P2777["quote_EXPR"]
    unless_null $P2778, vivify_868
    new $P2778, "Undef"
  vivify_868:
    $P2779 = $P2778."ast"()
    $P2780 = $P2776."!make"($P2779)
    .return ($P2780)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("146_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2782
    .param pmc param_2783
.annotate 'line', 1209
    .lex "self", param_2782
    .lex "$/", param_2783
    find_lex $P2784, "$/"
    find_lex $P2785, "$/"
    unless_null $P2785, vivify_869
    $P2785 = root_new ['parrot';'Hash']
  vivify_869:
    set $P2786, $P2785["quote_EXPR"]
    unless_null $P2786, vivify_870
    new $P2786, "Undef"
  vivify_870:
    $P2787 = $P2786."ast"()
    $P2788 = $P2784."!make"($P2787)
    .return ($P2788)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("147_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2790
    .param pmc param_2791
.annotate 'line', 1210
    .lex "self", param_2790
    .lex "$/", param_2791
.annotate 'line', 1211
    find_lex $P2792, "$/"
    get_hll_global $P2793, ["PAST"], "Op"
    find_lex $P2794, "$/"
    unless_null $P2794, vivify_871
    $P2794 = root_new ['parrot';'Hash']
  vivify_871:
    set $P2795, $P2794["quote_EXPR"]
    unless_null $P2795, vivify_872
    new $P2795, "Undef"
  vivify_872:
    $P2796 = $P2795."ast"()
    $P2797 = $P2796."value"()
    find_lex $P2798, "$/"
    $P2799 = $P2793."new"($P2797 :named("inline"), "inline" :named("pasttype"), $P2798 :named("node"))
    $P2800 = $P2792."!make"($P2799)
.annotate 'line', 1210
    .return ($P2800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("148_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2804
    .param pmc param_2805
    .param pmc param_2806 :optional
    .param int has_param_2806 :opt_flag
.annotate 'line', 1216
    new $P2803, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2803, control_2802
    push_eh $P2803
    .lex "self", param_2804
    .lex "$/", param_2805
    if has_param_2806, optparam_873
    new $P2807, "Undef"
    set param_2806, $P2807
  optparam_873:
    .lex "$key", param_2806
.annotate 'line', 1226
    new $P2808, "Undef"
    .lex "$regex", $P2808
.annotate 'line', 1228
    new $P2809, "Undef"
    .lex "$past", $P2809
.annotate 'line', 1217
    find_lex $P2811, "$key"
    set $S2812, $P2811
    iseq $I2813, $S2812, "open"
    unless $I2813, if_2810_end
.annotate 'line', 1218

            null $P0
            set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
        
.annotate 'line', 1222
    get_global $P2814, "@BLOCK"
    unless_null $P2814, vivify_874
    $P2814 = root_new ['parrot';'ResizablePMCArray']
  vivify_874:
    set $P2815, $P2814[0]
    unless_null $P2815, vivify_875
    new $P2815, "Undef"
  vivify_875:
    $P2815."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1223
    get_global $P2816, "@BLOCK"
    unless_null $P2816, vivify_876
    $P2816 = root_new ['parrot';'ResizablePMCArray']
  vivify_876:
    set $P2817, $P2816[0]
    unless_null $P2817, vivify_877
    new $P2817, "Undef"
  vivify_877:
    $P2817."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1224
    new $P2818, "Exception"
    set $P2818['type'], .CONTROL_RETURN
    new $P2819, "Integer"
    assign $P2819, 0
    setattribute $P2818, 'payload', $P2819
    throw $P2818
  if_2810_end:
.annotate 'line', 1227
    get_hll_global $P2820, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P2821, "$/"
    unless_null $P2821, vivify_878
    $P2821 = root_new ['parrot';'Hash']
  vivify_878:
    set $P2822, $P2821["p6regex"]
    unless_null $P2822, vivify_879
    new $P2822, "Undef"
  vivify_879:
    $P2823 = $P2822."ast"()
    get_global $P2824, "@BLOCK"
    $P2825 = $P2824."shift"()
    $P2826 = $P2820($P2823, $P2825)
    store_lex "$regex", $P2826
.annotate 'line', 1229
    get_hll_global $P2827, ["PAST"], "Op"
.annotate 'line', 1231
    get_hll_global $P2828, ["PAST"], "Var"
    new $P2829, "ResizablePMCArray"
    push $P2829, "Regex"
    $P2830 = $P2828."new"("Regex" :named("name"), $P2829 :named("namespace"), "package" :named("scope"))
    find_lex $P2831, "$regex"
    $P2832 = $P2827."new"($P2830, $P2831, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1229
    store_lex "$past", $P2832
.annotate 'line', 1235
    find_lex $P2833, "$regex"
    find_lex $P2834, "$past"
    unless_null $P2834, vivify_880
    $P2834 = root_new ['parrot';'Hash']
    store_lex "$past", $P2834
  vivify_880:
    set $P2834["sink"], $P2833
.annotate 'line', 1236
    find_lex $P2835, "$/"
    find_lex $P2836, "$past"
    $P2837 = $P2835."!make"($P2836)
.annotate 'line', 1216
    .return ($P2837)
  control_2802:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2838, exception, "payload"
    .return ($P2838)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("149_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2840
    .param pmc param_2841
.annotate 'line', 1239
    .lex "self", param_2840
    .lex "$/", param_2841
    find_lex $P2842, "$/"
    find_lex $P2843, "$/"
    unless_null $P2843, vivify_881
    $P2843 = root_new ['parrot';'Hash']
  vivify_881:
    set $P2844, $P2843["variable"]
    unless_null $P2844, vivify_882
    new $P2844, "Undef"
  vivify_882:
    $P2845 = $P2844."ast"()
    $P2846 = $P2842."!make"($P2845)
    .return ($P2846)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("150_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2848
    .param pmc param_2849
.annotate 'line', 1240
    .lex "self", param_2848
    .lex "$/", param_2849
.annotate 'line', 1241
    find_lex $P2850, "$/"
    get_hll_global $P2851, ["PAST"], "Op"
.annotate 'line', 1242
    find_lex $P2852, "$/"
    unless_null $P2852, vivify_883
    $P2852 = root_new ['parrot';'Hash']
  vivify_883:
    set $P2853, $P2852["block"]
    unless_null $P2853, vivify_884
    new $P2853, "Undef"
  vivify_884:
    $P2854 = $P2853."ast"()
    $P2855 = "block_immediate"($P2854)
    find_lex $P2856, "$/"
    $P2857 = $P2851."new"($P2855, "set S*" :named("pirop"), $P2856 :named("node"))
.annotate 'line', 1241
    $P2858 = $P2850."!make"($P2857)
.annotate 'line', 1240
    .return ($P2858)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("151_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2860
    .param pmc param_2861
.annotate 'line', 1245
    .lex "self", param_2860
    .lex "$/", param_2861
    find_lex $P2862, "$/"
    $P2863 = $P2862."!make"("\e")
    .return ($P2863)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("152_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2865
    .param pmc param_2866
.annotate 'line', 1249
    .lex "self", param_2865
    .lex "$/", param_2866
    find_lex $P2867, "$/"
    find_lex $P2868, "$/"
    unless_null $P2868, vivify_885
    $P2868 = root_new ['parrot';'Hash']
  vivify_885:
    set $P2869, $P2868["dotty"]
    unless_null $P2869, vivify_886
    new $P2869, "Undef"
  vivify_886:
    $P2870 = $P2869."ast"()
    $P2871 = $P2867."!make"($P2870)
    .return ($P2871)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("153_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2873
    .param pmc param_2874
.annotate 'line', 1251
    .lex "self", param_2873
    .lex "$/", param_2874
.annotate 'line', 1252
    find_lex $P2875, "$/"
    get_hll_global $P2876, ["PAST"], "Op"
.annotate 'line', 1253
    new $P2877, "ResizablePMCArray"
    push $P2877, "    clone %r, %0"
    push $P2877, "    inc %0"
    $P2878 = $P2876."new"("postfix:<++>" :named("name"), $P2877 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1252
    $P2879 = $P2875."!make"($P2878)
.annotate 'line', 1251
    .return ($P2879)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("154_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2881
    .param pmc param_2882
.annotate 'line', 1257
    .lex "self", param_2881
    .lex "$/", param_2882
.annotate 'line', 1258
    find_lex $P2883, "$/"
    get_hll_global $P2884, ["PAST"], "Op"
.annotate 'line', 1259
    new $P2885, "ResizablePMCArray"
    push $P2885, "    clone %r, %0"
    push $P2885, "    dec %0"
    $P2886 = $P2884."new"("postfix:<-->" :named("name"), $P2885 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 1258
    $P2887 = $P2883."!make"($P2886)
.annotate 'line', 1257
    .return ($P2887)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("155_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2889
    .param pmc param_2890
.annotate 'line', 1263
    .lex "self", param_2889
    .lex "$/", param_2890
.annotate 'line', 1264
    find_lex $P2891, "$/"
    get_hll_global $P2892, ["PAST"], "Op"
.annotate 'line', 1265
    get_hll_global $P2893, ["PAST"], "Var"
    $P2894 = $P2893."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P2895, "$/"
    $P2896 = $P2892."new"($P2894, "callmethod" :named("pasttype"), "!make" :named("name"), $P2895 :named("node"))
.annotate 'line', 1264
    $P2897 = $P2891."!make"($P2896)
.annotate 'line', 1263
    .return ($P2897)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("156_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2900
    .param pmc param_2901
.annotate 'line', 1281
    .lex "self", param_2900
    .lex "$/", param_2901
    find_lex $P2902, "$/"
    $P2903 = "control"($P2902, "CONTROL_LOOP_NEXT")
    .return ($P2903)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("157_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2905
    .param pmc param_2906
.annotate 'line', 1282
    .lex "self", param_2905
    .lex "$/", param_2906
    find_lex $P2907, "$/"
    $P2908 = "control"($P2907, "CONTROL_LOOP_LAST")
    .return ($P2908)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("158_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2910
    .param pmc param_2911
.annotate 'line', 1283
    .lex "self", param_2910
    .lex "$/", param_2911
    find_lex $P2912, "$/"
    $P2913 = "control"($P2912, "CONTROL_LOOP_REDO")
    .return ($P2913)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("159_1299450604.787") :outer("11_1299450604.787")
    .param pmc param_2915
    .param pmc param_2916
.annotate 'line', 1285
    .lex "self", param_2915
    .lex "$/", param_2916
.annotate 'line', 1286
    find_lex $P2917, "$/"
    get_hll_global $P2918, ["PAST"], "Op"
    find_lex $P2919, "$/"
    $P2920 = $P2918."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P2919 :named("node"))
    $P2921 = $P2917."!make"($P2920)
.annotate 'line', 1285
    .return ($P2921)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block2922"  :subid("160_1299450604.787") :outer("11_1299450604.787")
.annotate 'line', 1290
    .const 'Sub' $P3022 = "168_1299450604.787" 
    capture_lex $P3022
    .const 'Sub' $P2997 = "167_1299450604.787" 
    capture_lex $P2997
    .const 'Sub' $P2986 = "166_1299450604.787" 
    capture_lex $P2986
    .const 'Sub' $P2971 = "165_1299450604.787" 
    capture_lex $P2971
    .const 'Sub' $P2960 = "164_1299450604.787" 
    capture_lex $P2960
    .const 'Sub' $P2949 = "163_1299450604.787" 
    capture_lex $P2949
    .const 'Sub' $P2938 = "162_1299450604.787" 
    capture_lex $P2938
    .const 'Sub' $P2925 = "161_1299450604.787" 
    capture_lex $P2925
    get_global $P2924, "$?CLASS"
.annotate 'line', 1324
    .const 'Sub' $P2997 = "167_1299450604.787" 
    newclosure $P3020, $P2997
.annotate 'line', 1290
    .return ($P3020)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post887") :outer("160_1299450604.787")
.annotate 'line', 1290
    get_hll_global $P2923, ["NQP";"RegexActions"], "_block2922" 
    .local pmc block
    set block, $P2923
    .const 'Sub' $P3022 = "168_1299450604.787" 
    capture_lex $P3022
    $P3022()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block3021"  :anon :subid("168_1299450604.787") :outer("160_1299450604.787")
.annotate 'line', 1290
    get_hll_global $P3023, "NQPClassHOW"
    $P3024 = $P3023."new_type"("RegexActions" :named("name"))
    .local pmc type_obj
    set type_obj, $P3024
    set_hll_global ["NQP"], "RegexActions", type_obj
    set_global "$?CLASS", type_obj
    get_how $P3025, type_obj
    .const 'Sub' $P3026 = "161_1299450604.787" 
    $P3025."add_method"(type_obj, "metachar:sym<:my>", $P3026)
    get_how $P3027, type_obj
    .const 'Sub' $P3028 = "162_1299450604.787" 
    $P3027."add_method"(type_obj, "metachar:sym<{ }>", $P3028)
    get_how $P3029, type_obj
    .const 'Sub' $P3030 = "163_1299450604.787" 
    $P3029."add_method"(type_obj, "metachar:sym<nqpvar>", $P3030)
    get_how $P3031, type_obj
    .const 'Sub' $P3032 = "164_1299450604.787" 
    $P3031."add_method"(type_obj, "assertion:sym<{ }>", $P3032)
    get_how $P3033, type_obj
    .const 'Sub' $P3034 = "165_1299450604.787" 
    $P3033."add_method"(type_obj, "assertion:sym<?{ }>", $P3034)
    get_how $P3035, type_obj
    .const 'Sub' $P3036 = "166_1299450604.787" 
    $P3035."add_method"(type_obj, "assertion:sym<var>", $P3036)
    get_how $P3037, type_obj
    .const 'Sub' $P3038 = "167_1299450604.787" 
    $P3037."add_method"(type_obj, "codeblock", $P3038)
    get_how $P3039, type_obj
    get_hll_global $P3040, ["Regex";"P6Regex"], "Actions"
    $P3039."add_parent"(type_obj, $P3040)
    get_how $P3041, type_obj
    $P3042 = $P3041."compose"(type_obj)
    .return ($P3042)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("161_1299450604.787") :outer("160_1299450604.787")
    .param pmc param_2926
    .param pmc param_2927
.annotate 'line', 1292
    .lex "self", param_2926
    .lex "$/", param_2927
.annotate 'line', 1293
    new $P2928, "Undef"
    .lex "$past", $P2928
    find_lex $P2929, "$/"
    unless_null $P2929, vivify_888
    $P2929 = root_new ['parrot';'Hash']
  vivify_888:
    set $P2930, $P2929["statement"]
    unless_null $P2930, vivify_889
    new $P2930, "Undef"
  vivify_889:
    $P2931 = $P2930."ast"()
    store_lex "$past", $P2931
.annotate 'line', 1294
    find_lex $P2932, "$/"
    get_hll_global $P2933, ["PAST"], "Regex"
    find_lex $P2934, "$past"
    find_lex $P2935, "$/"
    $P2936 = $P2933."new"($P2934, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P2935 :named("node"))
    $P2937 = $P2932."!make"($P2936)
.annotate 'line', 1292
    .return ($P2937)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("162_1299450604.787") :outer("160_1299450604.787")
    .param pmc param_2939
    .param pmc param_2940
.annotate 'line', 1298
    .lex "self", param_2939
    .lex "$/", param_2940
.annotate 'line', 1299
    find_lex $P2941, "$/"
    get_hll_global $P2942, ["PAST"], "Regex"
    find_lex $P2943, "$/"
    unless_null $P2943, vivify_890
    $P2943 = root_new ['parrot';'Hash']
  vivify_890:
    set $P2944, $P2943["codeblock"]
    unless_null $P2944, vivify_891
    new $P2944, "Undef"
  vivify_891:
    $P2945 = $P2944."ast"()
    find_lex $P2946, "$/"
    $P2947 = $P2942."new"($P2945, "pastnode" :named("pasttype"), $P2946 :named("node"))
    $P2948 = $P2941."!make"($P2947)
.annotate 'line', 1298
    .return ($P2948)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("163_1299450604.787") :outer("160_1299450604.787")
    .param pmc param_2950
    .param pmc param_2951
.annotate 'line', 1303
    .lex "self", param_2950
    .lex "$/", param_2951
.annotate 'line', 1304
    find_lex $P2952, "$/"
    get_hll_global $P2953, ["PAST"], "Regex"
    find_lex $P2954, "$/"
    unless_null $P2954, vivify_892
    $P2954 = root_new ['parrot';'Hash']
  vivify_892:
    set $P2955, $P2954["var"]
    unless_null $P2955, vivify_893
    new $P2955, "Undef"
  vivify_893:
    $P2956 = $P2955."ast"()
    find_lex $P2957, "$/"
    $P2958 = $P2953."new"("!INTERPOLATE", $P2956, "subrule" :named("pasttype"), "method" :named("subtype"), $P2957 :named("node"))
    $P2959 = $P2952."!make"($P2958)
.annotate 'line', 1303
    .return ($P2959)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("164_1299450604.787") :outer("160_1299450604.787")
    .param pmc param_2961
    .param pmc param_2962
.annotate 'line', 1308
    .lex "self", param_2961
    .lex "$/", param_2962
.annotate 'line', 1309
    find_lex $P2963, "$/"
    get_hll_global $P2964, ["PAST"], "Regex"
    find_lex $P2965, "$/"
    unless_null $P2965, vivify_894
    $P2965 = root_new ['parrot';'Hash']
  vivify_894:
    set $P2966, $P2965["codeblock"]
    unless_null $P2966, vivify_895
    new $P2966, "Undef"
  vivify_895:
    $P2967 = $P2966."ast"()
    find_lex $P2968, "$/"
    $P2969 = $P2964."new"("!INTERPOLATE_REGEX", $P2967, "subrule" :named("pasttype"), "method" :named("subtype"), $P2968 :named("node"))
    $P2970 = $P2963."!make"($P2969)
.annotate 'line', 1308
    .return ($P2970)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("165_1299450604.787") :outer("160_1299450604.787")
    .param pmc param_2972
    .param pmc param_2973
.annotate 'line', 1313
    .lex "self", param_2972
    .lex "$/", param_2973
.annotate 'line', 1314
    find_lex $P2974, "$/"
    get_hll_global $P2975, ["PAST"], "Regex"
    find_lex $P2976, "$/"
    unless_null $P2976, vivify_896
    $P2976 = root_new ['parrot';'Hash']
  vivify_896:
    set $P2977, $P2976["codeblock"]
    unless_null $P2977, vivify_897
    new $P2977, "Undef"
  vivify_897:
    $P2978 = $P2977."ast"()
.annotate 'line', 1315
    find_lex $P2979, "$/"
    unless_null $P2979, vivify_898
    $P2979 = root_new ['parrot';'Hash']
  vivify_898:
    set $P2980, $P2979["zw"]
    unless_null $P2980, vivify_899
    new $P2980, "Undef"
  vivify_899:
    set $S2981, $P2980
    iseq $I2982, $S2981, "!"
    find_lex $P2983, "$/"
    $P2984 = $P2975."new"($P2978, "zerowidth" :named("subtype"), $I2982 :named("negate"), "pastnode" :named("pasttype"), $P2983 :named("node"))
.annotate 'line', 1314
    $P2985 = $P2974."!make"($P2984)
.annotate 'line', 1313
    .return ($P2985)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("166_1299450604.787") :outer("160_1299450604.787")
    .param pmc param_2987
    .param pmc param_2988
.annotate 'line', 1319
    .lex "self", param_2987
    .lex "$/", param_2988
.annotate 'line', 1320
    find_lex $P2989, "$/"
    get_hll_global $P2990, ["PAST"], "Regex"
    find_lex $P2991, "$/"
    unless_null $P2991, vivify_900
    $P2991 = root_new ['parrot';'Hash']
  vivify_900:
    set $P2992, $P2991["var"]
    unless_null $P2992, vivify_901
    new $P2992, "Undef"
  vivify_901:
    $P2993 = $P2992."ast"()
    find_lex $P2994, "$/"
    $P2995 = $P2990."new"("!INTERPOLATE_REGEX", $P2993, "subrule" :named("pasttype"), "method" :named("subtype"), $P2994 :named("node"))
    $P2996 = $P2989."!make"($P2995)
.annotate 'line', 1319
    .return ($P2996)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("167_1299450604.787") :outer("160_1299450604.787")
    .param pmc param_2998
    .param pmc param_2999
.annotate 'line', 1324
    .lex "self", param_2998
    .lex "$/", param_2999
.annotate 'line', 1325
    new $P3000, "Undef"
    .lex "$block", $P3000
.annotate 'line', 1327
    new $P3001, "Undef"
    .lex "$past", $P3001
.annotate 'line', 1325
    find_lex $P3002, "$/"
    unless_null $P3002, vivify_902
    $P3002 = root_new ['parrot';'Hash']
  vivify_902:
    set $P3003, $P3002["block"]
    unless_null $P3003, vivify_903
    new $P3003, "Undef"
  vivify_903:
    $P3004 = $P3003."ast"()
    store_lex "$block", $P3004
.annotate 'line', 1326
    find_lex $P3005, "$block"
    $P3005."blocktype"("immediate")
.annotate 'line', 1328
    get_hll_global $P3006, ["PAST"], "Stmts"
.annotate 'line', 1329
    get_hll_global $P3007, ["PAST"], "Op"
.annotate 'line', 1330
    get_hll_global $P3008, ["PAST"], "Var"
    $P3009 = $P3008."new"("$/" :named("name"))
.annotate 'line', 1331
    get_hll_global $P3010, ["PAST"], "Op"
.annotate 'line', 1332
    get_hll_global $P3011, ["PAST"], "Var"
    $P3012 = $P3011."new"(unicode:"$\x{a2}" :named("name"))
    $P3013 = $P3010."new"($P3012, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1331
    $P3014 = $P3007."new"($P3009, $P3013, "bind" :named("pasttype"))
.annotate 'line', 1329
    find_lex $P3015, "$block"
    $P3016 = $P3006."new"($P3014, $P3015)
.annotate 'line', 1328
    store_lex "$past", $P3016
.annotate 'line', 1340
    find_lex $P3017, "$/"
    find_lex $P3018, "$past"
    $P3019 = $P3017."!make"($P3018)
.annotate 'line', 1324
    .return ($P3019)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3044" :load :anon :subid("169_1299450604.787")
.annotate 'line', 3
    .const 'Sub' $P3046 = "11_1299450604.787" 
    $P3047 = $P3046()
    .return ($P3047)
.end


.HLL "nqp"

.namespace []
.sub "_block3271" :load :anon :subid("171_1299450604.787")
.annotate 'line', 1
    .const 'Sub' $P3273 = "10_1299450604.787" 
    $P3274 = $P3273()
    .return ($P3274)
.end

### .include 'gen/nqp-compiler.pir'

.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1299450607.324")
.annotate 'line', 0
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
.annotate 'line', 1
    nqp_dynop_setup 
    get_hll_global $P13, ["NQP"], "Compiler"
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    capture_lex $P15
    $P74 = $P15()
    .return ($P74)
    .const 'Sub' $P76 = "15_1299450607.324" 
    .return ($P76)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block14"  :subid("11_1299450607.324") :outer("10_1299450607.324")
.annotate 'line', 1
    .const 'Sub' $P62 = "14_1299450607.324" 
    capture_lex $P62
    .const 'Sub' $P17 = "12_1299450607.324" 
    capture_lex $P17
    get_global $P16, "$?CLASS"
.annotate 'line', 4
    .const 'Sub' $P17 = "12_1299450607.324" 
    newclosure $P60, $P17
.annotate 'line', 1
    .return ($P60)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post16") :outer("11_1299450607.324")
.annotate 'line', 1
    get_hll_global $P15, ["NQP";"Compiler"], "_block14" 
    .local pmc block
    set block, $P15
    .const 'Sub' $P62 = "14_1299450607.324" 
    capture_lex $P62
    $P62()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block61"  :anon :subid("14_1299450607.324") :outer("11_1299450607.324")
.annotate 'line', 1
    get_hll_global $P63, "NQPClassHOW"
    $P64 = $P63."new_type"("Compiler" :named("name"))
    .local pmc type_obj
    set type_obj, $P64
    set_hll_global ["NQP"], "Compiler", type_obj
    set_global "$?CLASS", type_obj
    get_how $P65, type_obj
    get_hll_global $P66, "NQPAttribute"
    $P67 = $P66."new"("%!settings_loaded" :named("name"))
    $P65."add_attribute"(type_obj, $P67)
    get_how $P68, type_obj
    .const 'Sub' $P69 = "12_1299450607.324" 
    $P68."add_method"(type_obj, "load_setting", $P69)
    get_how $P70, type_obj
    get_hll_global $P71, ["HLL"], "Compiler"
    $P70."add_parent"(type_obj, $P71)
    get_how $P72, type_obj
    $P73 = $P72."compose"(type_obj)
    .return ($P73)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "load_setting"  :subid("12_1299450607.324") :outer("11_1299450607.324")
    .param pmc param_18
    .param pmc param_19
.annotate 'line', 4
    .const 'Sub' $P33 = "13_1299450607.324" 
    capture_lex $P33
    .lex "self", param_18
    .lex "$setting_name", param_19
.annotate 'line', 5
    find_lex $P22, "$setting_name"
    set $S23, $P22
    isne $I24, $S23, "NULL"
    if $I24, if_21
    new $P20, 'Integer'
    set $P20, $I24
    goto if_21_end
  if_21:
.annotate 'line', 7
    find_lex $P26, "$setting_name"
    find_lex $P27, "self"
    get_global $P28, "$?CLASS"
    getattribute $P29, $P27, $P28, "%!settings_loaded"
    unless_null $P29, vivify_17
    $P29 = root_new ['parrot';'Hash']
  vivify_17:
    set $P30, $P29[$P26]
    unless_null $P30, vivify_18
    new $P30, "Undef"
  vivify_18:
    defined $I31, $P30
    if $I31, unless_25_end
    .const 'Sub' $P33 = "13_1299450607.324" 
    capture_lex $P33
    $P33()
  unless_25_end:
.annotate 'line', 19
    find_lex $P53, "$setting_name"
    find_lex $P54, "self"
    get_global $P55, "$?CLASS"
    getattribute $P56, $P54, $P55, "%!settings_loaded"
    unless_null $P56, vivify_26
    $P56 = root_new ['parrot';'Hash']
  vivify_26:
    set $P57, $P56[$P53]
    unless_null $P57, vivify_27
    new $P57, "Undef"
  vivify_27:
    find_dynamic_lex $P58, "%*COMPILING"
    unless_null $P58, vivify_28
    get_hll_global $P58, "%COMPILING"
    unless_null $P58, vivify_29
    die "Contextual %*COMPILING not found"
  vivify_29:
    store_dynamic_lex "%*COMPILING", $P58
  vivify_28:
    set $P59, $P58["%?OPTIONS"]
    unless_null $P59, vivify_30
    $P59 = root_new ['parrot';'Hash']
    set $P58["%?OPTIONS"], $P59
  vivify_30:
    set $P59["outer_ctx"], $P57
.annotate 'line', 5
    set $P20, $P57
  if_21_end:
.annotate 'line', 4
    .return ($P20)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block32"  :anon :subid("13_1299450607.324") :outer("12_1299450607.324")
.annotate 'line', 8
    new $P34, "Undef"
    .lex "$*CTXSAVE", $P34
.annotate 'line', 9
    new $P35, "Undef"
    .lex "$*MAIN_CTX", $P35
.annotate 'line', 8
    find_lex $P36, "self"
    store_lex "$*CTXSAVE", $P36
    find_lex $P37, "$*MAIN_CTX"
    unless_null $P37, vivify_19
    get_hll_global $P37, "$MAIN_CTX"
    unless_null $P37, vivify_20
    die "Contextual $*MAIN_CTX not found"
  vivify_20:
  vivify_19:
.annotate 'line', 10
    find_lex $P38, "$setting_name"
    concat $P39, $P38, ".setting.pbc"
    set $S40, $P39
    load_bytecode $S40
.annotate 'line', 11
    find_lex $P42, "$*MAIN_CTX"
    unless_null $P42, vivify_21
    get_hll_global $P42, "$MAIN_CTX"
    unless_null $P42, vivify_22
    die "Contextual $*MAIN_CTX not found"
  vivify_22:
  vivify_21:
    defined $I43, $P42
    if $I43, unless_41_end
.annotate 'line', 12
    new $P44, 'String'
    set $P44, "Unable to load setting "
    find_lex $P45, "$setting_name"
    concat $P46, $P44, $P45
    concat $P47, $P46, "; maybe it is missing a YOU_ARE_HERE?"
    die $P47
  unless_41_end:
.annotate 'line', 14
    find_lex $P48, "$*MAIN_CTX"
    unless_null $P48, vivify_23
    get_hll_global $P48, "$MAIN_CTX"
    unless_null $P48, vivify_24
    die "Contextual $*MAIN_CTX not found"
  vivify_24:
  vivify_23:
    find_lex $P49, "$setting_name"
    find_lex $P50, "self"
    get_global $P51, "$?CLASS"
    getattribute $P52, $P50, $P51, "%!settings_loaded"
    unless_null $P52, vivify_25
    $P52 = root_new ['parrot';'Hash']
    setattribute $P50, $P51, "%!settings_loaded", $P52
  vivify_25:
    set $P52[$P49], $P48
.annotate 'line', 7
    .return ($P48)
.end


.HLL "nqp"

.namespace []
.sub "_block75" :load :anon :subid("15_1299450607.324")
.annotate 'line', 1
    .const 'Sub' $P77 = "10_1299450607.324" 
    $P78 = $P77()
    .return ($P78)
.end

### .include 'src/cheats/nqp-builtins.pir'
.namespace []

.sub 'print'
    .param pmc list            :slurpy
    .local pmc list_it
    list_it = iter list
  list_loop:
    unless list_it goto list_done
    $P0 = shift list_it
    print $P0
    goto list_loop
  list_done:
    .return (1)
.end

.sub 'say'
    .param pmc list            :slurpy
    .tailcall 'print'(list :flat, "\n")
.end

.sub 'ok'
    .param pmc    condition
    .param string description :optional
    .param int    has_desc    :opt_flag
    if condition goto it_was_ok
        print "not "
  it_was_ok:
    print "ok "
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    unless has_desc goto no_description
        print " - "
        print description
  no_description:
    print "\n"

    unless condition goto not_ok
    .return (1)
  not_ok:
    .return (0)
.end

.sub 'skip'
    .param string desc

    print 'ok '
    $P0 = get_global "$test_counter"
    $P0 += 1
    print $P0
    print " # SKIP "
    print desc
    print "\n"
.end

.sub 'plan'
    .param int quantity
    print "1.."
    print quantity
    print "\n"
.end

.sub '' :anon :init :load
    $P0 = box 0
    set_global '$test_counter', $P0
.end



.namespace ['NQP';'Compiler']

.sub '' :anon :load :init
    .local pmc nqpproto, nqpcomp
    nqpproto = get_hll_global ['NQP'], 'Compiler'
    nqpcomp = nqpproto.'new'()
    nqpcomp.'language'('nqp')
    $P0 = get_hll_global ['NQP'], 'Grammar'
    nqpcomp.'parsegrammar'($P0)
    $P0 = get_hll_global ['NQP'], 'Actions'
    nqpcomp.'parseactions'($P0)
    $P0 = nqpcomp.'commandline_options'()
    push $P0, 'parsetrace'
    push $P0, 'setting=s'
.end

.sub 'main' :main
    .param pmc args_str

    $P0 = compreg 'nqp'
    $P1 = $P0.'command_line'(args_str, 'encoding'=>'utf8', 'transcode'=>'ascii iso-8859-1')
    exit 0
.end

# Local Variables:
#   mode: pir
#   fill-column: 100
# End:
# vim: expandtab shiftwidth=4 ft=pir:
