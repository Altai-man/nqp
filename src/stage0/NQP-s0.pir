
.HLL "nqp"

.loadlib "nqp_group"

.loadlib "nqp_ops"

.namespace []
.sub "_block11"  :anon :subid("10_1300146757.646")
    .param pmc param_13 :slurpy
.annotate 'line', 0
    get_hll_global $P5826, ["NQP";"Compiler"], "_block5825" 
    capture_lex $P5826
    get_hll_global $P5706, ["NQP";"RegexActions"], "_block5705" 
    capture_lex $P5706
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    capture_lex $P2502
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    capture_lex $P2399
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    capture_lex $P34
    .const 'Sub' $P14 = "11_1300146757.646" 
    capture_lex $P14
.annotate 'line', 1
    .lex "@ARGS", param_13
.annotate 'line', 2133
    .const 'Sub' $P14 = "11_1300146757.646" 
    newclosure $P32, $P14
    .lex "MAIN", $P32
.annotate 'line', 1
    $P0 = find_dynamic_lex "$*CTXSAVE"
    if null $P0 goto ctxsave_done
    $I0 = can $P0, "ctxsave"
    unless $I0 goto ctxsave_done
    $P0."ctxsave"()
  ctxsave_done:
.annotate 'line', 9
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    capture_lex $P34
    $P34()
.annotate 'line', 698
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    capture_lex $P2399
    $P2399()
.annotate 'line', 741
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    capture_lex $P2502
    $P2502()
.annotate 'line', 2075
    get_hll_global $P5706, ["NQP";"RegexActions"], "_block5705" 
    capture_lex $P5706
    $P5706()
.annotate 'line', 2130
    get_hll_global $P5826, ["NQP";"Compiler"], "_block5825" 
    capture_lex $P5826
    $P5826()
    find_lex $P5835, "MAIN"
    find_lex $P5838, "@ARGS"
    if $P5838, if_5837
    set $P5836, $P5838
    goto if_5837_end
  if_5837:
    .const 'Sub' $P5839 = "11_1300146757.646" 
    find_lex $P5840, "@ARGS"
    $P5841 = $P5839($P5840 :flat)
    set $P5836, $P5841
  if_5837_end:
.annotate 'line', 1
    .return ($P5836)
    .const 'Sub' $P5843 = "569_1300146757.646" 
    .return ($P5843)
.end


.HLL "nqp"

.namespace []
.sub "" :load :init :subid("post570") :outer("10_1300146757.646")
.annotate 'line', 0
    .const 'Sub' $P12 = "10_1300146757.646" 
    .local pmc block
    set block, $P12
    nqp_get_sc $P5847, "1300146737.899"
    isnull $I5848, $P5847
    if $I5848, if_5846
    nqp_get_sc_object $P5870, "1300146737.899", 0
    set_hll_global ["NQP"], "Grammar", $P5870
    nqp_get_sc_object $P5871, "1300146737.899", 1
    set_hll_global ["NQP"], "Regex", $P5871
    nqp_get_sc_object $P5872, "1300146737.899", 2
    set_hll_global ["NQP"], "Actions", $P5872
    nqp_get_sc_object $P5873, "1300146737.899", 3
    set_hll_global ["NQP"], "RegexActions", $P5873
    nqp_get_sc_object $P5874, "1300146737.899", 4
    set_hll_global ["NQP"], "Compiler", $P5874
    goto if_5846_end
  if_5846:
    nqp_dynop_setup 
    getinterp $P5849
    get_class $P5850, "LexPad"
    get_class $P5851, "NQPLexPad"
    $P5849."hll_map"($P5850, $P5851)
    load_bytecode "nqpmo.pbc"
    nqp_create_sc $P5852, "1300146737.899"
    .local pmc cur_sc
    set cur_sc, $P5852
    load_bytecode "SettingManager.pbc"
    get_hll_global $P5853, ["HLL"], "SettingManager"
    $P5854 = $P5853."load_setting"("NQPCORE")
    block."set_outer_ctx"($P5854)
    load_bytecode "P6Regex.pbc"
    get_hll_global $P5855, "NQPClassHOW"
    $P5856 = $P5855."new_type"("NQP::Grammar" :named("name"))
    nqp_set_sc_for_object $P5856, cur_sc
    nqp_set_sc_object "1300146737.899", 0, $P5856
    nqp_get_sc_object $P5857, "1300146737.899", 0
    set_hll_global ["NQP"], "Grammar", $P5857
    get_hll_global $P5858, "NQPClassHOW"
    $P5859 = $P5858."new_type"("NQP::Regex" :named("name"))
    nqp_set_sc_for_object $P5859, cur_sc
    nqp_set_sc_object "1300146737.899", 1, $P5859
    nqp_get_sc_object $P5860, "1300146737.899", 1
    set_hll_global ["NQP"], "Regex", $P5860
    get_hll_global $P5861, "NQPClassHOW"
    $P5862 = $P5861."new_type"("NQP::Actions" :named("name"))
    nqp_set_sc_for_object $P5862, cur_sc
    nqp_set_sc_object "1300146737.899", 2, $P5862
    nqp_get_sc_object $P5863, "1300146737.899", 2
    set_hll_global ["NQP"], "Actions", $P5863
    get_hll_global $P5864, "NQPClassHOW"
    $P5865 = $P5864."new_type"("NQP::RegexActions" :named("name"))
    nqp_set_sc_for_object $P5865, cur_sc
    nqp_set_sc_object "1300146737.899", 3, $P5865
    nqp_get_sc_object $P5866, "1300146737.899", 3
    set_hll_global ["NQP"], "RegexActions", $P5866
    get_hll_global $P5867, "NQPClassHOW"
    $P5868 = $P5867."new_type"("NQP::Compiler" :named("name"))
    nqp_set_sc_for_object $P5868, cur_sc
    nqp_set_sc_object "1300146737.899", 4, $P5868
    nqp_get_sc_object $P5869, "1300146737.899", 4
    set_hll_global ["NQP"], "Compiler", $P5869
  if_5846_end:
.end


.HLL "nqp"

.namespace []
.sub "MAIN"  :subid("11_1300146757.646") :outer("10_1300146757.646")
    .param pmc param_15
.annotate 'line', 2133
    .lex "@ARGS", param_15
.annotate 'line', 2135
    new $P16, "Undef"
    .lex "$nqpcomp", $P16
.annotate 'line', 2141
    $P17 = root_new ['parrot';'ResizablePMCArray']
    .lex "@clo", $P17
.annotate 'line', 2135
    get_hll_global $P18, ["NQP"], "Compiler"
    $P19 = $P18."new"()
    store_lex "$nqpcomp", $P19
.annotate 'line', 2136
    find_lex $P20, "$nqpcomp"
    $P20."language"("nqp")
.annotate 'line', 2137
    find_lex $P21, "$nqpcomp"
    get_hll_global $P22, ["NQP"], "Grammar"
    $P21."parsegrammar"($P22)
.annotate 'line', 2138
    find_lex $P23, "$nqpcomp"
    get_hll_global $P24, ["NQP"], "Actions"
    $P23."parseactions"($P24)
.annotate 'line', 2141
    find_lex $P25, "$nqpcomp"
    $P26 = $P25."commandline_options"()
    store_lex "@clo", $P26
.annotate 'line', 2142
    find_lex $P27, "@clo"
    $P27."push"("parsetrace")
.annotate 'line', 2143
    find_lex $P28, "@clo"
    $P28."push"("setting=s")
.annotate 'line', 2146
    find_lex $P29, "$nqpcomp"
    find_lex $P30, "@ARGS"
    $P31 = $P29."command_line"($P30, "utf8" :named("encoding"), "ascii iso-8859-1" :named("transcode"))
.annotate 'line', 2133
    .return ($P31)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block33"  :subid("12_1300146757.646") :outer("10_1300146757.646")
.annotate 'line', 9
    .const 'Sub' $P1680 = "382_1300146757.646" 
    capture_lex $P1680
    .const 'Sub' $P1667 = "381_1300146757.646" 
    capture_lex $P1667
    .const 'Sub' $P1661 = "379_1300146757.646" 
    capture_lex $P1661
    .const 'Sub' $P1655 = "377_1300146757.646" 
    capture_lex $P1655
    .const 'Sub' $P1649 = "375_1300146757.646" 
    capture_lex $P1649
    .const 'Sub' $P1643 = "373_1300146757.646" 
    capture_lex $P1643
    .const 'Sub' $P1631 = "370_1300146757.646" 
    capture_lex $P1631
    .const 'Sub' $P1624 = "368_1300146757.646" 
    capture_lex $P1624
    .const 'Sub' $P1617 = "366_1300146757.646" 
    capture_lex $P1617
    .const 'Sub' $P1610 = "364_1300146757.646" 
    capture_lex $P1610
    .const 'Sub' $P1603 = "362_1300146757.646" 
    capture_lex $P1603
    .const 'Sub' $P1597 = "360_1300146757.646" 
    capture_lex $P1597
    .const 'Sub' $P1590 = "358_1300146757.646" 
    capture_lex $P1590
    .const 'Sub' $P1583 = "356_1300146757.646" 
    capture_lex $P1583
    .const 'Sub' $P1576 = "354_1300146757.646" 
    capture_lex $P1576
    .const 'Sub' $P1569 = "352_1300146757.646" 
    capture_lex $P1569
    .const 'Sub' $P1562 = "350_1300146757.646" 
    capture_lex $P1562
    .const 'Sub' $P1555 = "348_1300146757.646" 
    capture_lex $P1555
    .const 'Sub' $P1548 = "346_1300146757.646" 
    capture_lex $P1548
    .const 'Sub' $P1541 = "344_1300146757.646" 
    capture_lex $P1541
    .const 'Sub' $P1534 = "342_1300146757.646" 
    capture_lex $P1534
    .const 'Sub' $P1527 = "340_1300146757.646" 
    capture_lex $P1527
    .const 'Sub' $P1520 = "338_1300146757.646" 
    capture_lex $P1520
    .const 'Sub' $P1513 = "336_1300146757.646" 
    capture_lex $P1513
    .const 'Sub' $P1506 = "334_1300146757.646" 
    capture_lex $P1506
    .const 'Sub' $P1499 = "332_1300146757.646" 
    capture_lex $P1499
    .const 'Sub' $P1492 = "330_1300146757.646" 
    capture_lex $P1492
    .const 'Sub' $P1485 = "328_1300146757.646" 
    capture_lex $P1485
    .const 'Sub' $P1478 = "326_1300146757.646" 
    capture_lex $P1478
    .const 'Sub' $P1471 = "324_1300146757.646" 
    capture_lex $P1471
    .const 'Sub' $P1464 = "322_1300146757.646" 
    capture_lex $P1464
    .const 'Sub' $P1457 = "320_1300146757.646" 
    capture_lex $P1457
    .const 'Sub' $P1450 = "318_1300146757.646" 
    capture_lex $P1450
    .const 'Sub' $P1443 = "316_1300146757.646" 
    capture_lex $P1443
    .const 'Sub' $P1436 = "314_1300146757.646" 
    capture_lex $P1436
    .const 'Sub' $P1429 = "312_1300146757.646" 
    capture_lex $P1429
    .const 'Sub' $P1422 = "310_1300146757.646" 
    capture_lex $P1422
    .const 'Sub' $P1415 = "308_1300146757.646" 
    capture_lex $P1415
    .const 'Sub' $P1408 = "306_1300146757.646" 
    capture_lex $P1408
    .const 'Sub' $P1401 = "304_1300146757.646" 
    capture_lex $P1401
    .const 'Sub' $P1394 = "302_1300146757.646" 
    capture_lex $P1394
    .const 'Sub' $P1388 = "300_1300146757.646" 
    capture_lex $P1388
    .const 'Sub' $P1381 = "298_1300146757.646" 
    capture_lex $P1381
    .const 'Sub' $P1374 = "296_1300146757.646" 
    capture_lex $P1374
    .const 'Sub' $P1367 = "294_1300146757.646" 
    capture_lex $P1367
    .const 'Sub' $P1360 = "292_1300146757.646" 
    capture_lex $P1360
    .const 'Sub' $P1353 = "290_1300146757.646" 
    capture_lex $P1353
    .const 'Sub' $P1346 = "288_1300146757.646" 
    capture_lex $P1346
    .const 'Sub' $P1339 = "286_1300146757.646" 
    capture_lex $P1339
    .const 'Sub' $P1333 = "284_1300146757.646" 
    capture_lex $P1333
    .const 'Sub' $P1327 = "282_1300146757.646" 
    capture_lex $P1327
    .const 'Sub' $P1322 = "280_1300146757.646" 
    capture_lex $P1322
    .const 'Sub' $P1316 = "278_1300146757.646" 
    capture_lex $P1316
    .const 'Sub' $P1310 = "276_1300146757.646" 
    capture_lex $P1310
    .const 'Sub' $P1305 = "274_1300146757.646" 
    capture_lex $P1305
    .const 'Sub' $P1300 = "272_1300146757.646" 
    capture_lex $P1300
    .const 'Sub' $P1284 = "271_1300146757.646" 
    capture_lex $P1284
    .const 'Sub' $P1275 = "269_1300146757.646" 
    capture_lex $P1275
    .const 'Sub' $P1266 = "267_1300146757.646" 
    capture_lex $P1266
    .const 'Sub' $P1261 = "265_1300146757.646" 
    capture_lex $P1261
    .const 'Sub' $P1256 = "263_1300146757.646" 
    capture_lex $P1256
    .const 'Sub' $P1251 = "261_1300146757.646" 
    capture_lex $P1251
    .const 'Sub' $P1243 = "259_1300146757.646" 
    capture_lex $P1243
    .const 'Sub' $P1235 = "257_1300146757.646" 
    capture_lex $P1235
    .const 'Sub' $P1230 = "255_1300146757.646" 
    capture_lex $P1230
    .const 'Sub' $P1225 = "253_1300146757.646" 
    capture_lex $P1225
    .const 'Sub' $P1220 = "251_1300146757.646" 
    capture_lex $P1220
    .const 'Sub' $P1214 = "249_1300146757.646" 
    capture_lex $P1214
    .const 'Sub' $P1208 = "247_1300146757.646" 
    capture_lex $P1208
    .const 'Sub' $P1202 = "245_1300146757.646" 
    capture_lex $P1202
    .const 'Sub' $P1196 = "243_1300146757.646" 
    capture_lex $P1196
    .const 'Sub' $P1190 = "241_1300146757.646" 
    capture_lex $P1190
    .const 'Sub' $P1185 = "239_1300146757.646" 
    capture_lex $P1185
    .const 'Sub' $P1180 = "237_1300146757.646" 
    capture_lex $P1180
    .const 'Sub' $P1166 = "233_1300146757.646" 
    capture_lex $P1166
    .const 'Sub' $P1158 = "231_1300146757.646" 
    capture_lex $P1158
    .const 'Sub' $P1152 = "229_1300146757.646" 
    capture_lex $P1152
    .const 'Sub' $P1145 = "227_1300146757.646" 
    capture_lex $P1145
    .const 'Sub' $P1139 = "225_1300146757.646" 
    capture_lex $P1139
    .const 'Sub' $P1125 = "222_1300146757.646" 
    capture_lex $P1125
    .const 'Sub' $P1117 = "220_1300146757.646" 
    capture_lex $P1117
    .const 'Sub' $P1109 = "218_1300146757.646" 
    capture_lex $P1109
    .const 'Sub' $P1103 = "216_1300146757.646" 
    capture_lex $P1103
    .const 'Sub' $P1097 = "214_1300146757.646" 
    capture_lex $P1097
    .const 'Sub' $P1081 = "210_1300146757.646" 
    capture_lex $P1081
    .const 'Sub' $P1040 = "208_1300146757.646" 
    capture_lex $P1040
    .const 'Sub' $P1029 = "206_1300146757.646" 
    capture_lex $P1029
    .const 'Sub' $P1015 = "202_1300146757.646" 
    capture_lex $P1015
    .const 'Sub' $P1006 = "200_1300146757.646" 
    capture_lex $P1006
    .const 'Sub' $P1000 = "198_1300146757.646" 
    capture_lex $P1000
    .const 'Sub' $P990 = "196_1300146757.646" 
    capture_lex $P990
    .const 'Sub' $P975 = "194_1300146757.646" 
    capture_lex $P975
    .const 'Sub' $P961 = "191_1300146757.646" 
    capture_lex $P961
    .const 'Sub' $P953 = "189_1300146757.646" 
    capture_lex $P953
    .const 'Sub' $P943 = "187_1300146757.646" 
    capture_lex $P943
    .const 'Sub' $P933 = "185_1300146757.646" 
    capture_lex $P933
    .const 'Sub' $P914 = "180_1300146757.646" 
    capture_lex $P914
    .const 'Sub' $P870 = "177_1300146757.646" 
    capture_lex $P870
    .const 'Sub' $P836 = "175_1300146757.646" 
    capture_lex $P836
    .const 'Sub' $P829 = "173_1300146757.646" 
    capture_lex $P829
    .const 'Sub' $P822 = "171_1300146757.646" 
    capture_lex $P822
    .const 'Sub' $P805 = "167_1300146757.646" 
    capture_lex $P805
    .const 'Sub' $P797 = "165_1300146757.646" 
    capture_lex $P797
    .const 'Sub' $P791 = "163_1300146757.646" 
    capture_lex $P791
    .const 'Sub' $P775 = "161_1300146757.646" 
    capture_lex $P775
    .const 'Sub' $P768 = "159_1300146757.646" 
    capture_lex $P768
    .const 'Sub' $P761 = "157_1300146757.646" 
    capture_lex $P761
    .const 'Sub' $P754 = "155_1300146757.646" 
    capture_lex $P754
    .const 'Sub' $P676 = "150_1300146757.646" 
    capture_lex $P676
    .const 'Sub' $P664 = "148_1300146757.646" 
    capture_lex $P664
    .const 'Sub' $P652 = "146_1300146757.646" 
    capture_lex $P652
    .const 'Sub' $P640 = "144_1300146757.646" 
    capture_lex $P640
    .const 'Sub' $P628 = "142_1300146757.646" 
    capture_lex $P628
    .const 'Sub' $P616 = "140_1300146757.646" 
    capture_lex $P616
    .const 'Sub' $P604 = "138_1300146757.646" 
    capture_lex $P604
    .const 'Sub' $P593 = "134_1300146757.646" 
    capture_lex $P593
    .const 'Sub' $P588 = "132_1300146757.646" 
    capture_lex $P588
    .const 'Sub' $P576 = "130_1300146757.646" 
    capture_lex $P576
    .const 'Sub' $P564 = "128_1300146757.646" 
    capture_lex $P564
    .const 'Sub' $P557 = "126_1300146757.646" 
    capture_lex $P557
    .const 'Sub' $P552 = "124_1300146757.646" 
    capture_lex $P552
    .const 'Sub' $P546 = "122_1300146757.646" 
    capture_lex $P546
    .const 'Sub' $P540 = "120_1300146757.646" 
    capture_lex $P540
    .const 'Sub' $P525 = "116_1300146757.646" 
    capture_lex $P525
    .const 'Sub' $P519 = "114_1300146757.646" 
    capture_lex $P519
    .const 'Sub' $P513 = "112_1300146757.646" 
    capture_lex $P513
    .const 'Sub' $P507 = "110_1300146757.646" 
    capture_lex $P507
    .const 'Sub' $P501 = "108_1300146757.646" 
    capture_lex $P501
    .const 'Sub' $P495 = "106_1300146757.646" 
    capture_lex $P495
    .const 'Sub' $P489 = "104_1300146757.646" 
    capture_lex $P489
    .const 'Sub' $P480 = "102_1300146757.646" 
    capture_lex $P480
    .const 'Sub' $P471 = "100_1300146757.646" 
    capture_lex $P471
    .const 'Sub' $P462 = "98_1300146757.646" 
    capture_lex $P462
    .const 'Sub' $P447 = "94_1300146757.646" 
    capture_lex $P447
    .const 'Sub' $P438 = "92_1300146757.646" 
    capture_lex $P438
    .const 'Sub' $P426 = "88_1300146757.646" 
    capture_lex $P426
    .const 'Sub' $P419 = "86_1300146757.646" 
    capture_lex $P419
    .const 'Sub' $P412 = "84_1300146757.646" 
    capture_lex $P412
    .const 'Sub' $P398 = "80_1300146757.646" 
    capture_lex $P398
    .const 'Sub' $P390 = "78_1300146757.646" 
    capture_lex $P390
    .const 'Sub' $P382 = "76_1300146757.646" 
    capture_lex $P382
    .const 'Sub' $P362 = "74_1300146757.646" 
    capture_lex $P362
    .const 'Sub' $P353 = "72_1300146757.646" 
    capture_lex $P353
    .const 'Sub' $P335 = "69_1300146757.646" 
    capture_lex $P335
    .const 'Sub' $P317 = "67_1300146757.646" 
    capture_lex $P317
    .const 'Sub' $P309 = "65_1300146757.646" 
    capture_lex $P309
    .const 'Sub' $P298 = "61_1300146757.646" 
    capture_lex $P298
    .const 'Sub' $P293 = "59_1300146757.646" 
    capture_lex $P293
    .const 'Sub' $P282 = "55_1300146757.646" 
    capture_lex $P282
    .const 'Sub' $P277 = "53_1300146757.646" 
    capture_lex $P277
    .const 'Sub' $P272 = "51_1300146757.646" 
    capture_lex $P272
    .const 'Sub' $P267 = "49_1300146757.646" 
    capture_lex $P267
    .const 'Sub' $P257 = "47_1300146757.646" 
    capture_lex $P257
    .const 'Sub' $P250 = "45_1300146757.646" 
    capture_lex $P250
    .const 'Sub' $P244 = "43_1300146757.646" 
    capture_lex $P244
    .const 'Sub' $P236 = "41_1300146757.646" 
    capture_lex $P236
    .const 'Sub' $P230 = "39_1300146757.646" 
    capture_lex $P230
    .const 'Sub' $P224 = "37_1300146757.646" 
    capture_lex $P224
    .const 'Sub' $P209 = "34_1300146757.646" 
    capture_lex $P209
    .const 'Sub' $P195 = "32_1300146757.646" 
    capture_lex $P195
    .const 'Sub' $P184 = "30_1300146757.646" 
    capture_lex $P184
    .const 'Sub' $P145 = "27_1300146757.646" 
    capture_lex $P145
    .const 'Sub' $P130 = "24_1300146757.646" 
    capture_lex $P130
    .const 'Sub' $P119 = "22_1300146757.646" 
    capture_lex $P119
    .const 'Sub' $P107 = "20_1300146757.646" 
    capture_lex $P107
    .const 'Sub' $P99 = "18_1300146757.646" 
    capture_lex $P99
    .const 'Sub' $P92 = "16_1300146757.646" 
    capture_lex $P92
    .const 'Sub' $P85 = "14_1300146757.646" 
    capture_lex $P85
    .const 'Sub' $P36 = "13_1300146757.646" 
    capture_lex $P36
    get_global $P35, "$?CLASS"
.annotate 'line', 10
    .const 'Sub' $P1284 = "271_1300146757.646" 
    capture_lex $P1284
    $P1284()
.annotate 'line', 692
    .const 'Sub' $P1667 = "381_1300146757.646" 
    newclosure $P1678, $P1667
.annotate 'line', 9
    .return ($P1678)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post571") :outer("12_1300146757.646")
.annotate 'line', 9
    get_hll_global $P34, ["NQP";"Grammar"], "_block33" 
    .local pmc block
    set block, $P34
    .const 'Sub' $P1680 = "382_1300146757.646" 
    capture_lex $P1680
    $P1680()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1679"  :anon :subid("382_1300146757.646") :outer("12_1300146757.646")
.annotate 'line', 9
    nqp_get_sc_object $P1681, "1300146737.899", 0
    .local pmc type_obj
    set type_obj, $P1681
    set_global "$?CLASS", type_obj
    get_how $P1682, type_obj
    .const 'Sub' $P1683 = "13_1300146757.646" 
    $P1682."add_method"(type_obj, "TOP", $P1683)
    get_how $P1684, type_obj
    .const 'Sub' $P1685 = "14_1300146757.646" 
    $P1684."add_method"(type_obj, "identifier", $P1685)
    get_how $P1686, type_obj
    get_global $P1687, "!PREFIX__identifier"
    $P1686."add_method"(type_obj, "!PREFIX__identifier", $P1687)
    get_how $P1688, type_obj
    .const 'Sub' $P1689 = "16_1300146757.646" 
    $P1688."add_method"(type_obj, "name", $P1689)
    get_how $P1690, type_obj
    get_global $P1691, "!PREFIX__name"
    $P1690."add_method"(type_obj, "!PREFIX__name", $P1691)
    get_how $P1692, type_obj
    .const 'Sub' $P1693 = "18_1300146757.646" 
    $P1692."add_method"(type_obj, "deflongname", $P1693)
    get_how $P1694, type_obj
    get_global $P1695, "!PREFIX__deflongname"
    $P1694."add_method"(type_obj, "!PREFIX__deflongname", $P1695)
    get_how $P1696, type_obj
    .const 'Sub' $P1697 = "20_1300146757.646" 
    $P1696."add_method"(type_obj, "ENDSTMT", $P1697)
    get_how $P1698, type_obj
    get_global $P1699, "!PREFIX__ENDSTMT"
    $P1698."add_method"(type_obj, "!PREFIX__ENDSTMT", $P1699)
    get_how $P1700, type_obj
    .const 'Sub' $P1701 = "22_1300146757.646" 
    $P1700."add_method"(type_obj, "ws", $P1701)
    get_how $P1702, type_obj
    get_global $P1703, "!PREFIX__ws"
    $P1702."add_method"(type_obj, "!PREFIX__ws", $P1703)
    get_how $P1704, type_obj
    .const 'Sub' $P1705 = "24_1300146757.646" 
    $P1704."add_method"(type_obj, "unv", $P1705)
    get_how $P1706, type_obj
    get_global $P1707, "!PREFIX__unv"
    $P1706."add_method"(type_obj, "!PREFIX__unv", $P1707)
    get_how $P1708, type_obj
    .const 'Sub' $P1709 = "27_1300146757.646" 
    $P1708."add_method"(type_obj, "pod_comment", $P1709)
    get_how $P1710, type_obj
    get_global $P1711, "!PREFIX__pod_comment"
    $P1710."add_method"(type_obj, "!PREFIX__pod_comment", $P1711)
    get_how $P1712, type_obj
    .const 'Sub' $P1713 = "30_1300146757.646" 
    $P1712."add_method"(type_obj, "comp_unit", $P1713)
    get_how $P1714, type_obj
    get_global $P1715, "!PREFIX__comp_unit"
    $P1714."add_method"(type_obj, "!PREFIX__comp_unit", $P1715)
    get_how $P1716, type_obj
    .const 'Sub' $P1717 = "32_1300146757.646" 
    $P1716."add_method"(type_obj, "statementlist", $P1717)
    get_how $P1718, type_obj
    get_global $P1719, "!PREFIX__statementlist"
    $P1718."add_method"(type_obj, "!PREFIX__statementlist", $P1719)
    get_how $P1720, type_obj
    .const 'Sub' $P1721 = "34_1300146757.646" 
    $P1720."add_method"(type_obj, "statement", $P1721)
    get_how $P1722, type_obj
    get_global $P1723, "!PREFIX__statement"
    $P1722."add_method"(type_obj, "!PREFIX__statement", $P1723)
    get_how $P1724, type_obj
    .const 'Sub' $P1725 = "37_1300146757.646" 
    $P1724."add_method"(type_obj, "eat_terminator", $P1725)
    get_how $P1726, type_obj
    get_global $P1727, "!PREFIX__eat_terminator"
    $P1726."add_method"(type_obj, "!PREFIX__eat_terminator", $P1727)
    get_how $P1728, type_obj
    .const 'Sub' $P1729 = "39_1300146757.646" 
    $P1728."add_method"(type_obj, "xblock", $P1729)
    get_how $P1730, type_obj
    get_global $P1731, "!PREFIX__xblock"
    $P1730."add_method"(type_obj, "!PREFIX__xblock", $P1731)
    get_how $P1732, type_obj
    .const 'Sub' $P1733 = "41_1300146757.646" 
    $P1732."add_method"(type_obj, "pblock", $P1733)
    get_how $P1734, type_obj
    get_global $P1735, "!PREFIX__pblock"
    $P1734."add_method"(type_obj, "!PREFIX__pblock", $P1735)
    get_how $P1736, type_obj
    .const 'Sub' $P1737 = "43_1300146757.646" 
    $P1736."add_method"(type_obj, "lambda", $P1737)
    get_how $P1738, type_obj
    get_global $P1739, "!PREFIX__lambda"
    $P1738."add_method"(type_obj, "!PREFIX__lambda", $P1739)
    get_how $P1740, type_obj
    .const 'Sub' $P1741 = "45_1300146757.646" 
    $P1740."add_method"(type_obj, "block", $P1741)
    get_how $P1742, type_obj
    get_global $P1743, "!PREFIX__block"
    $P1742."add_method"(type_obj, "!PREFIX__block", $P1743)
    get_how $P1744, type_obj
    .const 'Sub' $P1745 = "47_1300146757.646" 
    $P1744."add_method"(type_obj, "blockoid", $P1745)
    get_how $P1746, type_obj
    get_global $P1747, "!PREFIX__blockoid"
    $P1746."add_method"(type_obj, "!PREFIX__blockoid", $P1747)
    get_how $P1748, type_obj
    .const 'Sub' $P1749 = "49_1300146757.646" 
    $P1748."add_method"(type_obj, "newpad", $P1749)
    get_how $P1750, type_obj
    get_global $P1751, "!PREFIX__newpad"
    $P1750."add_method"(type_obj, "!PREFIX__newpad", $P1751)
    get_how $P1752, type_obj
    .const 'Sub' $P1753 = "51_1300146757.646" 
    $P1752."add_method"(type_obj, "outerctx", $P1753)
    get_how $P1754, type_obj
    get_global $P1755, "!PREFIX__outerctx"
    $P1754."add_method"(type_obj, "!PREFIX__outerctx", $P1755)
    get_how $P1756, type_obj
    .const 'Sub' $P1757 = "53_1300146757.646" 
    $P1756."add_method"(type_obj, "finishpad", $P1757)
    get_how $P1758, type_obj
    get_global $P1759, "!PREFIX__finishpad"
    $P1758."add_method"(type_obj, "!PREFIX__finishpad", $P1759)
    get_how $P1760, type_obj
    .const 'Sub' $P1761 = "55_1300146757.646" 
    $P1760."add_method"(type_obj, "you_are_here", $P1761)
    get_how $P1762, type_obj
    get_global $P1763, "!PREFIX__you_are_here"
    $P1762."add_method"(type_obj, "!PREFIX__you_are_here", $P1763)
    get_how $P1764, type_obj
    .const 'Sub' $P1765 = "57_1300146757.646" 
    $P1764."add_method"(type_obj, "terminator", $P1765)
    get_how $P1766, type_obj
    .const 'Sub' $P1767 = "58_1300146757.646" 
    $P1766."add_method"(type_obj, "!PREFIX__terminator", $P1767)
    get_how $P1768, type_obj
    .const 'Sub' $P1769 = "59_1300146757.646" 
    $P1768."add_method"(type_obj, "terminator:sym<;>", $P1769)
    get_how $P1770, type_obj
    get_global $P1771, "!PREFIX__terminator:sym<;>"
    $P1770."add_method"(type_obj, "!PREFIX__terminator:sym<;>", $P1771)
    get_how $P1772, type_obj
    .const 'Sub' $P1773 = "61_1300146757.646" 
    $P1772."add_method"(type_obj, "terminator:sym<}>", $P1773)
    get_how $P1774, type_obj
    get_global $P1775, "!PREFIX__terminator:sym<}>"
    $P1774."add_method"(type_obj, "!PREFIX__terminator:sym<}>", $P1775)
    get_how $P1776, type_obj
    .const 'Sub' $P1777 = "63_1300146757.646" 
    $P1776."add_method"(type_obj, "statement_control", $P1777)
    get_how $P1778, type_obj
    .const 'Sub' $P1779 = "64_1300146757.646" 
    $P1778."add_method"(type_obj, "!PREFIX__statement_control", $P1779)
    get_how $P1780, type_obj
    .const 'Sub' $P1781 = "65_1300146757.646" 
    $P1780."add_method"(type_obj, "statement_control:sym<use>", $P1781)
    get_how $P1782, type_obj
    get_global $P1783, "!PREFIX__statement_control:sym<use>"
    $P1782."add_method"(type_obj, "!PREFIX__statement_control:sym<use>", $P1783)
    get_how $P1784, type_obj
    .const 'Sub' $P1785 = "67_1300146757.646" 
    $P1784."add_method"(type_obj, "statement_control:sym<if>", $P1785)
    get_how $P1786, type_obj
    get_global $P1787, "!PREFIX__statement_control:sym<if>"
    $P1786."add_method"(type_obj, "!PREFIX__statement_control:sym<if>", $P1787)
    get_how $P1788, type_obj
    .const 'Sub' $P1789 = "69_1300146757.646" 
    $P1788."add_method"(type_obj, "statement_control:sym<unless>", $P1789)
    get_how $P1790, type_obj
    get_global $P1791, "!PREFIX__statement_control:sym<unless>"
    $P1790."add_method"(type_obj, "!PREFIX__statement_control:sym<unless>", $P1791)
    get_how $P1792, type_obj
    .const 'Sub' $P1793 = "72_1300146757.646" 
    $P1792."add_method"(type_obj, "statement_control:sym<while>", $P1793)
    get_how $P1794, type_obj
    get_global $P1795, "!PREFIX__statement_control:sym<while>"
    $P1794."add_method"(type_obj, "!PREFIX__statement_control:sym<while>", $P1795)
    get_how $P1796, type_obj
    .const 'Sub' $P1797 = "74_1300146757.646" 
    $P1796."add_method"(type_obj, "statement_control:sym<repeat>", $P1797)
    get_how $P1798, type_obj
    get_global $P1799, "!PREFIX__statement_control:sym<repeat>"
    $P1798."add_method"(type_obj, "!PREFIX__statement_control:sym<repeat>", $P1799)
    get_how $P1800, type_obj
    .const 'Sub' $P1801 = "76_1300146757.646" 
    $P1800."add_method"(type_obj, "statement_control:sym<for>", $P1801)
    get_how $P1802, type_obj
    get_global $P1803, "!PREFIX__statement_control:sym<for>"
    $P1802."add_method"(type_obj, "!PREFIX__statement_control:sym<for>", $P1803)
    get_how $P1804, type_obj
    .const 'Sub' $P1805 = "78_1300146757.646" 
    $P1804."add_method"(type_obj, "statement_control:sym<CATCH>", $P1805)
    get_how $P1806, type_obj
    get_global $P1807, "!PREFIX__statement_control:sym<CATCH>"
    $P1806."add_method"(type_obj, "!PREFIX__statement_control:sym<CATCH>", $P1807)
    get_how $P1808, type_obj
    .const 'Sub' $P1809 = "80_1300146757.646" 
    $P1808."add_method"(type_obj, "statement_control:sym<CONTROL>", $P1809)
    get_how $P1810, type_obj
    get_global $P1811, "!PREFIX__statement_control:sym<CONTROL>"
    $P1810."add_method"(type_obj, "!PREFIX__statement_control:sym<CONTROL>", $P1811)
    get_how $P1812, type_obj
    .const 'Sub' $P1813 = "82_1300146757.646" 
    $P1812."add_method"(type_obj, "statement_prefix", $P1813)
    get_how $P1814, type_obj
    .const 'Sub' $P1815 = "83_1300146757.646" 
    $P1814."add_method"(type_obj, "!PREFIX__statement_prefix", $P1815)
    get_how $P1816, type_obj
    .const 'Sub' $P1817 = "84_1300146757.646" 
    $P1816."add_method"(type_obj, "statement_prefix:sym<INIT>", $P1817)
    get_how $P1818, type_obj
    get_global $P1819, "!PREFIX__statement_prefix:sym<INIT>"
    $P1818."add_method"(type_obj, "!PREFIX__statement_prefix:sym<INIT>", $P1819)
    get_how $P1820, type_obj
    .const 'Sub' $P1821 = "86_1300146757.646" 
    $P1820."add_method"(type_obj, "statement_prefix:sym<try>", $P1821)
    get_how $P1822, type_obj
    get_global $P1823, "!PREFIX__statement_prefix:sym<try>"
    $P1822."add_method"(type_obj, "!PREFIX__statement_prefix:sym<try>", $P1823)
    get_how $P1824, type_obj
    .const 'Sub' $P1825 = "88_1300146757.646" 
    $P1824."add_method"(type_obj, "blorst", $P1825)
    get_how $P1826, type_obj
    get_global $P1827, "!PREFIX__blorst"
    $P1826."add_method"(type_obj, "!PREFIX__blorst", $P1827)
    get_how $P1828, type_obj
    .const 'Sub' $P1829 = "90_1300146757.646" 
    $P1828."add_method"(type_obj, "statement_mod_cond", $P1829)
    get_how $P1830, type_obj
    .const 'Sub' $P1831 = "91_1300146757.646" 
    $P1830."add_method"(type_obj, "!PREFIX__statement_mod_cond", $P1831)
    get_how $P1832, type_obj
    .const 'Sub' $P1833 = "92_1300146757.646" 
    $P1832."add_method"(type_obj, "statement_mod_cond:sym<if>", $P1833)
    get_how $P1834, type_obj
    get_global $P1835, "!PREFIX__statement_mod_cond:sym<if>"
    $P1834."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<if>", $P1835)
    get_how $P1836, type_obj
    .const 'Sub' $P1837 = "94_1300146757.646" 
    $P1836."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P1837)
    get_how $P1838, type_obj
    get_global $P1839, "!PREFIX__statement_mod_cond:sym<unless>"
    $P1838."add_method"(type_obj, "!PREFIX__statement_mod_cond:sym<unless>", $P1839)
    get_how $P1840, type_obj
    .const 'Sub' $P1841 = "96_1300146757.646" 
    $P1840."add_method"(type_obj, "statement_mod_loop", $P1841)
    get_how $P1842, type_obj
    .const 'Sub' $P1843 = "97_1300146757.646" 
    $P1842."add_method"(type_obj, "!PREFIX__statement_mod_loop", $P1843)
    get_how $P1844, type_obj
    .const 'Sub' $P1845 = "98_1300146757.646" 
    $P1844."add_method"(type_obj, "statement_mod_loop:sym<while>", $P1845)
    get_how $P1846, type_obj
    get_global $P1847, "!PREFIX__statement_mod_loop:sym<while>"
    $P1846."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<while>", $P1847)
    get_how $P1848, type_obj
    .const 'Sub' $P1849 = "100_1300146757.646" 
    $P1848."add_method"(type_obj, "statement_mod_loop:sym<until>", $P1849)
    get_how $P1850, type_obj
    get_global $P1851, "!PREFIX__statement_mod_loop:sym<until>"
    $P1850."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<until>", $P1851)
    get_how $P1852, type_obj
    .const 'Sub' $P1853 = "102_1300146757.646" 
    $P1852."add_method"(type_obj, "statement_mod_loop:sym<for>", $P1853)
    get_how $P1854, type_obj
    get_global $P1855, "!PREFIX__statement_mod_loop:sym<for>"
    $P1854."add_method"(type_obj, "!PREFIX__statement_mod_loop:sym<for>", $P1855)
    get_how $P1856, type_obj
    .const 'Sub' $P1857 = "104_1300146757.646" 
    $P1856."add_method"(type_obj, "term:sym<fatarrow>", $P1857)
    get_how $P1858, type_obj
    get_global $P1859, "!PREFIX__term:sym<fatarrow>"
    $P1858."add_method"(type_obj, "!PREFIX__term:sym<fatarrow>", $P1859)
    get_how $P1860, type_obj
    .const 'Sub' $P1861 = "106_1300146757.646" 
    $P1860."add_method"(type_obj, "term:sym<colonpair>", $P1861)
    get_how $P1862, type_obj
    get_global $P1863, "!PREFIX__term:sym<colonpair>"
    $P1862."add_method"(type_obj, "!PREFIX__term:sym<colonpair>", $P1863)
    get_how $P1864, type_obj
    .const 'Sub' $P1865 = "108_1300146757.646" 
    $P1864."add_method"(type_obj, "term:sym<variable>", $P1865)
    get_how $P1866, type_obj
    get_global $P1867, "!PREFIX__term:sym<variable>"
    $P1866."add_method"(type_obj, "!PREFIX__term:sym<variable>", $P1867)
    get_how $P1868, type_obj
    .const 'Sub' $P1869 = "110_1300146757.646" 
    $P1868."add_method"(type_obj, "term:sym<package_declarator>", $P1869)
    get_how $P1870, type_obj
    get_global $P1871, "!PREFIX__term:sym<package_declarator>"
    $P1870."add_method"(type_obj, "!PREFIX__term:sym<package_declarator>", $P1871)
    get_how $P1872, type_obj
    .const 'Sub' $P1873 = "112_1300146757.646" 
    $P1872."add_method"(type_obj, "term:sym<scope_declarator>", $P1873)
    get_how $P1874, type_obj
    get_global $P1875, "!PREFIX__term:sym<scope_declarator>"
    $P1874."add_method"(type_obj, "!PREFIX__term:sym<scope_declarator>", $P1875)
    get_how $P1876, type_obj
    .const 'Sub' $P1877 = "114_1300146757.646" 
    $P1876."add_method"(type_obj, "term:sym<routine_declarator>", $P1877)
    get_how $P1878, type_obj
    get_global $P1879, "!PREFIX__term:sym<routine_declarator>"
    $P1878."add_method"(type_obj, "!PREFIX__term:sym<routine_declarator>", $P1879)
    get_how $P1880, type_obj
    .const 'Sub' $P1881 = "116_1300146757.646" 
    $P1880."add_method"(type_obj, "term:sym<multi_declarator>", $P1881)
    get_how $P1882, type_obj
    get_global $P1883, "!PREFIX__term:sym<multi_declarator>"
    $P1882."add_method"(type_obj, "!PREFIX__term:sym<multi_declarator>", $P1883)
    get_how $P1884, type_obj
    .const 'Sub' $P1885 = "120_1300146757.646" 
    $P1884."add_method"(type_obj, "term:sym<regex_declarator>", $P1885)
    get_how $P1886, type_obj
    get_global $P1887, "!PREFIX__term:sym<regex_declarator>"
    $P1886."add_method"(type_obj, "!PREFIX__term:sym<regex_declarator>", $P1887)
    get_how $P1888, type_obj
    .const 'Sub' $P1889 = "122_1300146757.646" 
    $P1888."add_method"(type_obj, "term:sym<statement_prefix>", $P1889)
    get_how $P1890, type_obj
    get_global $P1891, "!PREFIX__term:sym<statement_prefix>"
    $P1890."add_method"(type_obj, "!PREFIX__term:sym<statement_prefix>", $P1891)
    get_how $P1892, type_obj
    .const 'Sub' $P1893 = "124_1300146757.646" 
    $P1892."add_method"(type_obj, "term:sym<lambda>", $P1893)
    get_how $P1894, type_obj
    get_global $P1895, "!PREFIX__term:sym<lambda>"
    $P1894."add_method"(type_obj, "!PREFIX__term:sym<lambda>", $P1895)
    get_how $P1896, type_obj
    .const 'Sub' $P1897 = "126_1300146757.646" 
    $P1896."add_method"(type_obj, "fatarrow", $P1897)
    get_how $P1898, type_obj
    get_global $P1899, "!PREFIX__fatarrow"
    $P1898."add_method"(type_obj, "!PREFIX__fatarrow", $P1899)
    get_how $P1900, type_obj
    .const 'Sub' $P1901 = "128_1300146757.646" 
    $P1900."add_method"(type_obj, "colonpair", $P1901)
    get_how $P1902, type_obj
    get_global $P1903, "!PREFIX__colonpair"
    $P1902."add_method"(type_obj, "!PREFIX__colonpair", $P1903)
    get_how $P1904, type_obj
    .const 'Sub' $P1905 = "130_1300146757.646" 
    $P1904."add_method"(type_obj, "variable", $P1905)
    get_how $P1906, type_obj
    get_global $P1907, "!PREFIX__variable"
    $P1906."add_method"(type_obj, "!PREFIX__variable", $P1907)
    get_how $P1908, type_obj
    .const 'Sub' $P1909 = "132_1300146757.646" 
    $P1908."add_method"(type_obj, "sigil", $P1909)
    get_how $P1910, type_obj
    get_global $P1911, "!PREFIX__sigil"
    $P1910."add_method"(type_obj, "!PREFIX__sigil", $P1911)
    get_how $P1912, type_obj
    .const 'Sub' $P1913 = "134_1300146757.646" 
    $P1912."add_method"(type_obj, "twigil", $P1913)
    get_how $P1914, type_obj
    get_global $P1915, "!PREFIX__twigil"
    $P1914."add_method"(type_obj, "!PREFIX__twigil", $P1915)
    get_how $P1916, type_obj
    .const 'Sub' $P1917 = "136_1300146757.646" 
    $P1916."add_method"(type_obj, "package_declarator", $P1917)
    get_how $P1918, type_obj
    .const 'Sub' $P1919 = "137_1300146757.646" 
    $P1918."add_method"(type_obj, "!PREFIX__package_declarator", $P1919)
    get_how $P1920, type_obj
    .const 'Sub' $P1921 = "138_1300146757.646" 
    $P1920."add_method"(type_obj, "package_declarator:sym<module>", $P1921)
    get_how $P1922, type_obj
    get_global $P1923, "!PREFIX__package_declarator:sym<module>"
    $P1922."add_method"(type_obj, "!PREFIX__package_declarator:sym<module>", $P1923)
    get_how $P1924, type_obj
    .const 'Sub' $P1925 = "140_1300146757.646" 
    $P1924."add_method"(type_obj, "package_declarator:sym<knowhow>", $P1925)
    get_how $P1926, type_obj
    get_global $P1927, "!PREFIX__package_declarator:sym<knowhow>"
    $P1926."add_method"(type_obj, "!PREFIX__package_declarator:sym<knowhow>", $P1927)
    get_how $P1928, type_obj
    .const 'Sub' $P1929 = "142_1300146757.646" 
    $P1928."add_method"(type_obj, "package_declarator:sym<class>", $P1929)
    get_how $P1930, type_obj
    get_global $P1931, "!PREFIX__package_declarator:sym<class>"
    $P1930."add_method"(type_obj, "!PREFIX__package_declarator:sym<class>", $P1931)
    get_how $P1932, type_obj
    .const 'Sub' $P1933 = "144_1300146757.646" 
    $P1932."add_method"(type_obj, "package_declarator:sym<grammar>", $P1933)
    get_how $P1934, type_obj
    get_global $P1935, "!PREFIX__package_declarator:sym<grammar>"
    $P1934."add_method"(type_obj, "!PREFIX__package_declarator:sym<grammar>", $P1935)
    get_how $P1936, type_obj
    .const 'Sub' $P1937 = "146_1300146757.646" 
    $P1936."add_method"(type_obj, "package_declarator:sym<role>", $P1937)
    get_how $P1938, type_obj
    get_global $P1939, "!PREFIX__package_declarator:sym<role>"
    $P1938."add_method"(type_obj, "!PREFIX__package_declarator:sym<role>", $P1939)
    get_how $P1940, type_obj
    .const 'Sub' $P1941 = "148_1300146757.646" 
    $P1940."add_method"(type_obj, "package_declarator:sym<native>", $P1941)
    get_how $P1942, type_obj
    get_global $P1943, "!PREFIX__package_declarator:sym<native>"
    $P1942."add_method"(type_obj, "!PREFIX__package_declarator:sym<native>", $P1943)
    get_how $P1944, type_obj
    .const 'Sub' $P1945 = "150_1300146757.646" 
    $P1944."add_method"(type_obj, "package_def", $P1945)
    get_how $P1946, type_obj
    get_global $P1947, "!PREFIX__package_def"
    $P1946."add_method"(type_obj, "!PREFIX__package_def", $P1947)
    get_how $P1948, type_obj
    .const 'Sub' $P1949 = "153_1300146757.646" 
    $P1948."add_method"(type_obj, "scope_declarator", $P1949)
    get_how $P1950, type_obj
    .const 'Sub' $P1951 = "154_1300146757.646" 
    $P1950."add_method"(type_obj, "!PREFIX__scope_declarator", $P1951)
    get_how $P1952, type_obj
    .const 'Sub' $P1953 = "155_1300146757.646" 
    $P1952."add_method"(type_obj, "scope_declarator:sym<my>", $P1953)
    get_how $P1954, type_obj
    get_global $P1955, "!PREFIX__scope_declarator:sym<my>"
    $P1954."add_method"(type_obj, "!PREFIX__scope_declarator:sym<my>", $P1955)
    get_how $P1956, type_obj
    .const 'Sub' $P1957 = "157_1300146757.646" 
    $P1956."add_method"(type_obj, "scope_declarator:sym<our>", $P1957)
    get_how $P1958, type_obj
    get_global $P1959, "!PREFIX__scope_declarator:sym<our>"
    $P1958."add_method"(type_obj, "!PREFIX__scope_declarator:sym<our>", $P1959)
    get_how $P1960, type_obj
    .const 'Sub' $P1961 = "159_1300146757.646" 
    $P1960."add_method"(type_obj, "scope_declarator:sym<has>", $P1961)
    get_how $P1962, type_obj
    get_global $P1963, "!PREFIX__scope_declarator:sym<has>"
    $P1962."add_method"(type_obj, "!PREFIX__scope_declarator:sym<has>", $P1963)
    get_how $P1964, type_obj
    .const 'Sub' $P1965 = "161_1300146757.646" 
    $P1964."add_method"(type_obj, "scoped", $P1965)
    get_how $P1966, type_obj
    get_global $P1967, "!PREFIX__scoped"
    $P1966."add_method"(type_obj, "!PREFIX__scoped", $P1967)
    get_how $P1968, type_obj
    .const 'Sub' $P1969 = "163_1300146757.646" 
    $P1968."add_method"(type_obj, "typename", $P1969)
    get_how $P1970, type_obj
    get_global $P1971, "!PREFIX__typename"
    $P1970."add_method"(type_obj, "!PREFIX__typename", $P1971)
    get_how $P1972, type_obj
    .const 'Sub' $P1973 = "165_1300146757.646" 
    $P1972."add_method"(type_obj, "declarator", $P1973)
    get_how $P1974, type_obj
    get_global $P1975, "!PREFIX__declarator"
    $P1974."add_method"(type_obj, "!PREFIX__declarator", $P1975)
    get_how $P1976, type_obj
    .const 'Sub' $P1977 = "167_1300146757.646" 
    $P1976."add_method"(type_obj, "variable_declarator", $P1977)
    get_how $P1978, type_obj
    get_global $P1979, "!PREFIX__variable_declarator"
    $P1978."add_method"(type_obj, "!PREFIX__variable_declarator", $P1979)
    get_how $P1980, type_obj
    .const 'Sub' $P1981 = "169_1300146757.646" 
    $P1980."add_method"(type_obj, "routine_declarator", $P1981)
    get_how $P1982, type_obj
    .const 'Sub' $P1983 = "170_1300146757.646" 
    $P1982."add_method"(type_obj, "!PREFIX__routine_declarator", $P1983)
    get_how $P1984, type_obj
    .const 'Sub' $P1985 = "171_1300146757.646" 
    $P1984."add_method"(type_obj, "routine_declarator:sym<sub>", $P1985)
    get_how $P1986, type_obj
    get_global $P1987, "!PREFIX__routine_declarator:sym<sub>"
    $P1986."add_method"(type_obj, "!PREFIX__routine_declarator:sym<sub>", $P1987)
    get_how $P1988, type_obj
    .const 'Sub' $P1989 = "173_1300146757.646" 
    $P1988."add_method"(type_obj, "routine_declarator:sym<method>", $P1989)
    get_how $P1990, type_obj
    get_global $P1991, "!PREFIX__routine_declarator:sym<method>"
    $P1990."add_method"(type_obj, "!PREFIX__routine_declarator:sym<method>", $P1991)
    get_how $P1992, type_obj
    .const 'Sub' $P1993 = "175_1300146757.646" 
    $P1992."add_method"(type_obj, "routine_def", $P1993)
    get_how $P1994, type_obj
    get_global $P1995, "!PREFIX__routine_def"
    $P1994."add_method"(type_obj, "!PREFIX__routine_def", $P1995)
    get_how $P1996, type_obj
    .const 'Sub' $P1997 = "177_1300146757.646" 
    $P1996."add_method"(type_obj, "method_def", $P1997)
    get_how $P1998, type_obj
    get_global $P1999, "!PREFIX__method_def"
    $P1998."add_method"(type_obj, "!PREFIX__method_def", $P1999)
    get_how $P2000, type_obj
    .const 'Sub' $P2001 = "180_1300146757.646" 
    $P2000."add_method"(type_obj, "onlystar", $P2001)
    get_how $P2002, type_obj
    get_global $P2003, "!PREFIX__onlystar"
    $P2002."add_method"(type_obj, "!PREFIX__onlystar", $P2003)
    get_how $P2004, type_obj
    .const 'Sub' $P2005 = "183_1300146757.646" 
    $P2004."add_method"(type_obj, "multi_declarator", $P2005)
    get_how $P2006, type_obj
    .const 'Sub' $P2007 = "184_1300146757.646" 
    $P2006."add_method"(type_obj, "!PREFIX__multi_declarator", $P2007)
    get_how $P2008, type_obj
    .const 'Sub' $P2009 = "185_1300146757.646" 
    $P2008."add_method"(type_obj, "multi_declarator:sym<multi>", $P2009)
    get_how $P2010, type_obj
    get_global $P2011, "!PREFIX__multi_declarator:sym<multi>"
    $P2010."add_method"(type_obj, "!PREFIX__multi_declarator:sym<multi>", $P2011)
    get_how $P2012, type_obj
    .const 'Sub' $P2013 = "187_1300146757.646" 
    $P2012."add_method"(type_obj, "multi_declarator:sym<proto>", $P2013)
    get_how $P2014, type_obj
    get_global $P2015, "!PREFIX__multi_declarator:sym<proto>"
    $P2014."add_method"(type_obj, "!PREFIX__multi_declarator:sym<proto>", $P2015)
    get_how $P2016, type_obj
    .const 'Sub' $P2017 = "189_1300146757.646" 
    $P2016."add_method"(type_obj, "multi_declarator:sym<null>", $P2017)
    get_how $P2018, type_obj
    get_global $P2019, "!PREFIX__multi_declarator:sym<null>"
    $P2018."add_method"(type_obj, "!PREFIX__multi_declarator:sym<null>", $P2019)
    get_how $P2020, type_obj
    .const 'Sub' $P2021 = "191_1300146757.646" 
    $P2020."add_method"(type_obj, "signature", $P2021)
    get_how $P2022, type_obj
    get_global $P2023, "!PREFIX__signature"
    $P2022."add_method"(type_obj, "!PREFIX__signature", $P2023)
    get_how $P2024, type_obj
    .const 'Sub' $P2025 = "194_1300146757.646" 
    $P2024."add_method"(type_obj, "parameter", $P2025)
    get_how $P2026, type_obj
    get_global $P2027, "!PREFIX__parameter"
    $P2026."add_method"(type_obj, "!PREFIX__parameter", $P2027)
    get_how $P2028, type_obj
    .const 'Sub' $P2029 = "196_1300146757.646" 
    $P2028."add_method"(type_obj, "param_var", $P2029)
    get_how $P2030, type_obj
    get_global $P2031, "!PREFIX__param_var"
    $P2030."add_method"(type_obj, "!PREFIX__param_var", $P2031)
    get_how $P2032, type_obj
    .const 'Sub' $P2033 = "198_1300146757.646" 
    $P2032."add_method"(type_obj, "named_param", $P2033)
    get_how $P2034, type_obj
    get_global $P2035, "!PREFIX__named_param"
    $P2034."add_method"(type_obj, "!PREFIX__named_param", $P2035)
    get_how $P2036, type_obj
    .const 'Sub' $P2037 = "200_1300146757.646" 
    $P2036."add_method"(type_obj, "default_value", $P2037)
    get_how $P2038, type_obj
    get_global $P2039, "!PREFIX__default_value"
    $P2038."add_method"(type_obj, "!PREFIX__default_value", $P2039)
    get_how $P2040, type_obj
    .const 'Sub' $P2041 = "202_1300146757.646" 
    $P2040."add_method"(type_obj, "trait", $P2041)
    get_how $P2042, type_obj
    get_global $P2043, "!PREFIX__trait"
    $P2042."add_method"(type_obj, "!PREFIX__trait", $P2043)
    get_how $P2044, type_obj
    .const 'Sub' $P2045 = "204_1300146757.646" 
    $P2044."add_method"(type_obj, "trait_mod", $P2045)
    get_how $P2046, type_obj
    .const 'Sub' $P2047 = "205_1300146757.646" 
    $P2046."add_method"(type_obj, "!PREFIX__trait_mod", $P2047)
    get_how $P2048, type_obj
    .const 'Sub' $P2049 = "206_1300146757.646" 
    $P2048."add_method"(type_obj, "trait_mod:sym<is>", $P2049)
    get_how $P2050, type_obj
    get_global $P2051, "!PREFIX__trait_mod:sym<is>"
    $P2050."add_method"(type_obj, "!PREFIX__trait_mod:sym<is>", $P2051)
    get_how $P2052, type_obj
    .const 'Sub' $P2053 = "208_1300146757.646" 
    $P2052."add_method"(type_obj, "regex_declarator", $P2053)
    get_how $P2054, type_obj
    get_global $P2055, "!PREFIX__regex_declarator"
    $P2054."add_method"(type_obj, "!PREFIX__regex_declarator", $P2055)
    get_how $P2056, type_obj
    .const 'Sub' $P2057 = "210_1300146757.646" 
    $P2056."add_method"(type_obj, "dotty", $P2057)
    get_how $P2058, type_obj
    get_global $P2059, "!PREFIX__dotty"
    $P2058."add_method"(type_obj, "!PREFIX__dotty", $P2059)
    get_how $P2060, type_obj
    .const 'Sub' $P2061 = "212_1300146757.646" 
    $P2060."add_method"(type_obj, "term", $P2061)
    get_how $P2062, type_obj
    .const 'Sub' $P2063 = "213_1300146757.646" 
    $P2062."add_method"(type_obj, "!PREFIX__term", $P2063)
    get_how $P2064, type_obj
    .const 'Sub' $P2065 = "214_1300146757.646" 
    $P2064."add_method"(type_obj, "term:sym<self>", $P2065)
    get_how $P2066, type_obj
    get_global $P2067, "!PREFIX__term:sym<self>"
    $P2066."add_method"(type_obj, "!PREFIX__term:sym<self>", $P2067)
    get_how $P2068, type_obj
    .const 'Sub' $P2069 = "216_1300146757.646" 
    $P2068."add_method"(type_obj, "term:sym<identifier>", $P2069)
    get_how $P2070, type_obj
    get_global $P2071, "!PREFIX__term:sym<identifier>"
    $P2070."add_method"(type_obj, "!PREFIX__term:sym<identifier>", $P2071)
    get_how $P2072, type_obj
    .const 'Sub' $P2073 = "218_1300146757.646" 
    $P2072."add_method"(type_obj, "term:sym<name>", $P2073)
    get_how $P2074, type_obj
    get_global $P2075, "!PREFIX__term:sym<name>"
    $P2074."add_method"(type_obj, "!PREFIX__term:sym<name>", $P2075)
    get_how $P2076, type_obj
    .const 'Sub' $P2077 = "220_1300146757.646" 
    $P2076."add_method"(type_obj, "term:sym<pir::op>", $P2077)
    get_how $P2078, type_obj
    get_global $P2079, "!PREFIX__term:sym<pir::op>"
    $P2078."add_method"(type_obj, "!PREFIX__term:sym<pir::op>", $P2079)
    get_how $P2080, type_obj
    .const 'Sub' $P2081 = "222_1300146757.646" 
    $P2080."add_method"(type_obj, "term:sym<onlystar>", $P2081)
    get_how $P2082, type_obj
    get_global $P2083, "!PREFIX__term:sym<onlystar>"
    $P2082."add_method"(type_obj, "!PREFIX__term:sym<onlystar>", $P2083)
    get_how $P2084, type_obj
    .const 'Sub' $P2085 = "225_1300146757.646" 
    $P2084."add_method"(type_obj, "args", $P2085)
    get_how $P2086, type_obj
    get_global $P2087, "!PREFIX__args"
    $P2086."add_method"(type_obj, "!PREFIX__args", $P2087)
    get_how $P2088, type_obj
    .const 'Sub' $P2089 = "227_1300146757.646" 
    $P2088."add_method"(type_obj, "arglist", $P2089)
    get_how $P2090, type_obj
    get_global $P2091, "!PREFIX__arglist"
    $P2090."add_method"(type_obj, "!PREFIX__arglist", $P2091)
    get_how $P2092, type_obj
    .const 'Sub' $P2093 = "229_1300146757.646" 
    $P2092."add_method"(type_obj, "term:sym<value>", $P2093)
    get_how $P2094, type_obj
    get_global $P2095, "!PREFIX__term:sym<value>"
    $P2094."add_method"(type_obj, "!PREFIX__term:sym<value>", $P2095)
    get_how $P2096, type_obj
    .const 'Sub' $P2097 = "231_1300146757.646" 
    $P2096."add_method"(type_obj, "value", $P2097)
    get_how $P2098, type_obj
    get_global $P2099, "!PREFIX__value"
    $P2098."add_method"(type_obj, "!PREFIX__value", $P2099)
    get_how $P2100, type_obj
    .const 'Sub' $P2101 = "233_1300146757.646" 
    $P2100."add_method"(type_obj, "number", $P2101)
    get_how $P2102, type_obj
    get_global $P2103, "!PREFIX__number"
    $P2102."add_method"(type_obj, "!PREFIX__number", $P2103)
    get_how $P2104, type_obj
    .const 'Sub' $P2105 = "235_1300146757.646" 
    $P2104."add_method"(type_obj, "quote", $P2105)
    get_how $P2106, type_obj
    .const 'Sub' $P2107 = "236_1300146757.646" 
    $P2106."add_method"(type_obj, "!PREFIX__quote", $P2107)
    get_how $P2108, type_obj
    .const 'Sub' $P2109 = "237_1300146757.646" 
    $P2108."add_method"(type_obj, "quote:sym<apos>", $P2109)
    get_how $P2110, type_obj
    get_global $P2111, "!PREFIX__quote:sym<apos>"
    $P2110."add_method"(type_obj, "!PREFIX__quote:sym<apos>", $P2111)
    get_how $P2112, type_obj
    .const 'Sub' $P2113 = "239_1300146757.646" 
    $P2112."add_method"(type_obj, "quote:sym<dblq>", $P2113)
    get_how $P2114, type_obj
    get_global $P2115, "!PREFIX__quote:sym<dblq>"
    $P2114."add_method"(type_obj, "!PREFIX__quote:sym<dblq>", $P2115)
    get_how $P2116, type_obj
    .const 'Sub' $P2117 = "241_1300146757.646" 
    $P2116."add_method"(type_obj, "quote:sym<q>", $P2117)
    get_how $P2118, type_obj
    get_global $P2119, "!PREFIX__quote:sym<q>"
    $P2118."add_method"(type_obj, "!PREFIX__quote:sym<q>", $P2119)
    get_how $P2120, type_obj
    .const 'Sub' $P2121 = "243_1300146757.646" 
    $P2120."add_method"(type_obj, "quote:sym<qq>", $P2121)
    get_how $P2122, type_obj
    get_global $P2123, "!PREFIX__quote:sym<qq>"
    $P2122."add_method"(type_obj, "!PREFIX__quote:sym<qq>", $P2123)
    get_how $P2124, type_obj
    .const 'Sub' $P2125 = "245_1300146757.646" 
    $P2124."add_method"(type_obj, "quote:sym<Q>", $P2125)
    get_how $P2126, type_obj
    get_global $P2127, "!PREFIX__quote:sym<Q>"
    $P2126."add_method"(type_obj, "!PREFIX__quote:sym<Q>", $P2127)
    get_how $P2128, type_obj
    .const 'Sub' $P2129 = "247_1300146757.646" 
    $P2128."add_method"(type_obj, "quote:sym<Q:PIR>", $P2129)
    get_how $P2130, type_obj
    get_global $P2131, "!PREFIX__quote:sym<Q:PIR>"
    $P2130."add_method"(type_obj, "!PREFIX__quote:sym<Q:PIR>", $P2131)
    get_how $P2132, type_obj
    .const 'Sub' $P2133 = "249_1300146757.646" 
    $P2132."add_method"(type_obj, "quote:sym</ />", $P2133)
    get_how $P2134, type_obj
    get_global $P2135, "!PREFIX__quote:sym</ />"
    $P2134."add_method"(type_obj, "!PREFIX__quote:sym</ />", $P2135)
    get_how $P2136, type_obj
    .const 'Sub' $P2137 = "251_1300146757.646" 
    $P2136."add_method"(type_obj, "quote_escape:sym<$>", $P2137)
    get_how $P2138, type_obj
    get_global $P2139, "!PREFIX__quote_escape:sym<$>"
    $P2138."add_method"(type_obj, "!PREFIX__quote_escape:sym<$>", $P2139)
    get_how $P2140, type_obj
    .const 'Sub' $P2141 = "253_1300146757.646" 
    $P2140."add_method"(type_obj, "quote_escape:sym<{ }>", $P2141)
    get_how $P2142, type_obj
    get_global $P2143, "!PREFIX__quote_escape:sym<{ }>"
    $P2142."add_method"(type_obj, "!PREFIX__quote_escape:sym<{ }>", $P2143)
    get_how $P2144, type_obj
    .const 'Sub' $P2145 = "255_1300146757.646" 
    $P2144."add_method"(type_obj, "quote_escape:sym<esc>", $P2145)
    get_how $P2146, type_obj
    get_global $P2147, "!PREFIX__quote_escape:sym<esc>"
    $P2146."add_method"(type_obj, "!PREFIX__quote_escape:sym<esc>", $P2147)
    get_how $P2148, type_obj
    .const 'Sub' $P2149 = "257_1300146757.646" 
    $P2148."add_method"(type_obj, "circumfix:sym<( )>", $P2149)
    get_how $P2150, type_obj
    get_global $P2151, "!PREFIX__circumfix:sym<( )>"
    $P2150."add_method"(type_obj, "!PREFIX__circumfix:sym<( )>", $P2151)
    get_how $P2152, type_obj
    .const 'Sub' $P2153 = "259_1300146757.646" 
    $P2152."add_method"(type_obj, "circumfix:sym<[ ]>", $P2153)
    get_how $P2154, type_obj
    get_global $P2155, "!PREFIX__circumfix:sym<[ ]>"
    $P2154."add_method"(type_obj, "!PREFIX__circumfix:sym<[ ]>", $P2155)
    get_how $P2156, type_obj
    .const 'Sub' $P2157 = "261_1300146757.646" 
    $P2156."add_method"(type_obj, "circumfix:sym<ang>", $P2157)
    get_how $P2158, type_obj
    get_global $P2159, "!PREFIX__circumfix:sym<ang>"
    $P2158."add_method"(type_obj, "!PREFIX__circumfix:sym<ang>", $P2159)
    get_how $P2160, type_obj
    .const 'Sub' $P2161 = "263_1300146757.646" 
    $P2160."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P2161)
    get_how $P2162, type_obj
    get_global $P2163, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"
    $P2162."add_method"(type_obj, unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>", $P2163)
    get_how $P2164, type_obj
    .const 'Sub' $P2165 = "265_1300146757.646" 
    $P2164."add_method"(type_obj, "circumfix:sym<{ }>", $P2165)
    get_how $P2166, type_obj
    get_global $P2167, "!PREFIX__circumfix:sym<{ }>"
    $P2166."add_method"(type_obj, "!PREFIX__circumfix:sym<{ }>", $P2167)
    get_how $P2168, type_obj
    .const 'Sub' $P2169 = "267_1300146757.646" 
    $P2168."add_method"(type_obj, "circumfix:sym<sigil>", $P2169)
    get_how $P2170, type_obj
    get_global $P2171, "!PREFIX__circumfix:sym<sigil>"
    $P2170."add_method"(type_obj, "!PREFIX__circumfix:sym<sigil>", $P2171)
    get_how $P2172, type_obj
    .const 'Sub' $P2173 = "269_1300146757.646" 
    $P2172."add_method"(type_obj, "semilist", $P2173)
    get_how $P2174, type_obj
    get_global $P2175, "!PREFIX__semilist"
    $P2174."add_method"(type_obj, "!PREFIX__semilist", $P2175)
    get_how $P2176, type_obj
    .const 'Sub' $P2177 = "272_1300146757.646" 
    $P2176."add_method"(type_obj, "infixish", $P2177)
    get_how $P2178, type_obj
    get_global $P2179, "!PREFIX__infixish"
    $P2178."add_method"(type_obj, "!PREFIX__infixish", $P2179)
    get_how $P2180, type_obj
    .const 'Sub' $P2181 = "274_1300146757.646" 
    $P2180."add_method"(type_obj, "infixstopper", $P2181)
    get_how $P2182, type_obj
    get_global $P2183, "!PREFIX__infixstopper"
    $P2182."add_method"(type_obj, "!PREFIX__infixstopper", $P2183)
    get_how $P2184, type_obj
    .const 'Sub' $P2185 = "276_1300146757.646" 
    $P2184."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P2185)
    get_how $P2186, type_obj
    get_global $P2187, "!PREFIX__postcircumfix:sym<[ ]>"
    $P2186."add_method"(type_obj, "!PREFIX__postcircumfix:sym<[ ]>", $P2187)
    get_how $P2188, type_obj
    .const 'Sub' $P2189 = "278_1300146757.646" 
    $P2188."add_method"(type_obj, "postcircumfix:sym<{ }>", $P2189)
    get_how $P2190, type_obj
    get_global $P2191, "!PREFIX__postcircumfix:sym<{ }>"
    $P2190."add_method"(type_obj, "!PREFIX__postcircumfix:sym<{ }>", $P2191)
    get_how $P2192, type_obj
    .const 'Sub' $P2193 = "280_1300146757.646" 
    $P2192."add_method"(type_obj, "postcircumfix:sym<ang>", $P2193)
    get_how $P2194, type_obj
    get_global $P2195, "!PREFIX__postcircumfix:sym<ang>"
    $P2194."add_method"(type_obj, "!PREFIX__postcircumfix:sym<ang>", $P2195)
    get_how $P2196, type_obj
    .const 'Sub' $P2197 = "282_1300146757.646" 
    $P2196."add_method"(type_obj, "postcircumfix:sym<( )>", $P2197)
    get_how $P2198, type_obj
    get_global $P2199, "!PREFIX__postcircumfix:sym<( )>"
    $P2198."add_method"(type_obj, "!PREFIX__postcircumfix:sym<( )>", $P2199)
    get_how $P2200, type_obj
    .const 'Sub' $P2201 = "284_1300146757.646" 
    $P2200."add_method"(type_obj, "postfix:sym<.>", $P2201)
    get_how $P2202, type_obj
    get_global $P2203, "!PREFIX__postfix:sym<.>"
    $P2202."add_method"(type_obj, "!PREFIX__postfix:sym<.>", $P2203)
    get_how $P2204, type_obj
    .const 'Sub' $P2205 = "286_1300146757.646" 
    $P2204."add_method"(type_obj, "prefix:sym<++>", $P2205)
    get_how $P2206, type_obj
    get_global $P2207, "!PREFIX__prefix:sym<++>"
    $P2206."add_method"(type_obj, "!PREFIX__prefix:sym<++>", $P2207)
    get_how $P2208, type_obj
    .const 'Sub' $P2209 = "288_1300146757.646" 
    $P2208."add_method"(type_obj, "prefix:sym<-->", $P2209)
    get_how $P2210, type_obj
    get_global $P2211, "!PREFIX__prefix:sym<-->"
    $P2210."add_method"(type_obj, "!PREFIX__prefix:sym<-->", $P2211)
    get_how $P2212, type_obj
    .const 'Sub' $P2213 = "290_1300146757.646" 
    $P2212."add_method"(type_obj, "postfix:sym<++>", $P2213)
    get_how $P2214, type_obj
    get_global $P2215, "!PREFIX__postfix:sym<++>"
    $P2214."add_method"(type_obj, "!PREFIX__postfix:sym<++>", $P2215)
    get_how $P2216, type_obj
    .const 'Sub' $P2217 = "292_1300146757.646" 
    $P2216."add_method"(type_obj, "postfix:sym<-->", $P2217)
    get_how $P2218, type_obj
    get_global $P2219, "!PREFIX__postfix:sym<-->"
    $P2218."add_method"(type_obj, "!PREFIX__postfix:sym<-->", $P2219)
    get_how $P2220, type_obj
    .const 'Sub' $P2221 = "294_1300146757.646" 
    $P2220."add_method"(type_obj, "infix:sym<**>", $P2221)
    get_how $P2222, type_obj
    get_global $P2223, "!PREFIX__infix:sym<**>"
    $P2222."add_method"(type_obj, "!PREFIX__infix:sym<**>", $P2223)
    get_how $P2224, type_obj
    .const 'Sub' $P2225 = "296_1300146757.646" 
    $P2224."add_method"(type_obj, "prefix:sym<+>", $P2225)
    get_how $P2226, type_obj
    get_global $P2227, "!PREFIX__prefix:sym<+>"
    $P2226."add_method"(type_obj, "!PREFIX__prefix:sym<+>", $P2227)
    get_how $P2228, type_obj
    .const 'Sub' $P2229 = "298_1300146757.646" 
    $P2228."add_method"(type_obj, "prefix:sym<~>", $P2229)
    get_how $P2230, type_obj
    get_global $P2231, "!PREFIX__prefix:sym<~>"
    $P2230."add_method"(type_obj, "!PREFIX__prefix:sym<~>", $P2231)
    get_how $P2232, type_obj
    .const 'Sub' $P2233 = "300_1300146757.646" 
    $P2232."add_method"(type_obj, "prefix:sym<->", $P2233)
    get_how $P2234, type_obj
    get_global $P2235, "!PREFIX__prefix:sym<->"
    $P2234."add_method"(type_obj, "!PREFIX__prefix:sym<->", $P2235)
    get_how $P2236, type_obj
    .const 'Sub' $P2237 = "302_1300146757.646" 
    $P2236."add_method"(type_obj, "prefix:sym<?>", $P2237)
    get_how $P2238, type_obj
    get_global $P2239, "!PREFIX__prefix:sym<?>"
    $P2238."add_method"(type_obj, "!PREFIX__prefix:sym<?>", $P2239)
    get_how $P2240, type_obj
    .const 'Sub' $P2241 = "304_1300146757.646" 
    $P2240."add_method"(type_obj, "prefix:sym<!>", $P2241)
    get_how $P2242, type_obj
    get_global $P2243, "!PREFIX__prefix:sym<!>"
    $P2242."add_method"(type_obj, "!PREFIX__prefix:sym<!>", $P2243)
    get_how $P2244, type_obj
    .const 'Sub' $P2245 = "306_1300146757.646" 
    $P2244."add_method"(type_obj, "prefix:sym<|>", $P2245)
    get_how $P2246, type_obj
    get_global $P2247, "!PREFIX__prefix:sym<|>"
    $P2246."add_method"(type_obj, "!PREFIX__prefix:sym<|>", $P2247)
    get_how $P2248, type_obj
    .const 'Sub' $P2249 = "308_1300146757.646" 
    $P2248."add_method"(type_obj, "infix:sym<*>", $P2249)
    get_how $P2250, type_obj
    get_global $P2251, "!PREFIX__infix:sym<*>"
    $P2250."add_method"(type_obj, "!PREFIX__infix:sym<*>", $P2251)
    get_how $P2252, type_obj
    .const 'Sub' $P2253 = "310_1300146757.646" 
    $P2252."add_method"(type_obj, "infix:sym</>", $P2253)
    get_how $P2254, type_obj
    get_global $P2255, "!PREFIX__infix:sym</>"
    $P2254."add_method"(type_obj, "!PREFIX__infix:sym</>", $P2255)
    get_how $P2256, type_obj
    .const 'Sub' $P2257 = "312_1300146757.646" 
    $P2256."add_method"(type_obj, "infix:sym<%>", $P2257)
    get_how $P2258, type_obj
    get_global $P2259, "!PREFIX__infix:sym<%>"
    $P2258."add_method"(type_obj, "!PREFIX__infix:sym<%>", $P2259)
    get_how $P2260, type_obj
    .const 'Sub' $P2261 = "314_1300146757.646" 
    $P2260."add_method"(type_obj, "infix:sym<+&>", $P2261)
    get_how $P2262, type_obj
    get_global $P2263, "!PREFIX__infix:sym<+&>"
    $P2262."add_method"(type_obj, "!PREFIX__infix:sym<+&>", $P2263)
    get_how $P2264, type_obj
    .const 'Sub' $P2265 = "316_1300146757.646" 
    $P2264."add_method"(type_obj, "infix:sym<+>", $P2265)
    get_how $P2266, type_obj
    get_global $P2267, "!PREFIX__infix:sym<+>"
    $P2266."add_method"(type_obj, "!PREFIX__infix:sym<+>", $P2267)
    get_how $P2268, type_obj
    .const 'Sub' $P2269 = "318_1300146757.646" 
    $P2268."add_method"(type_obj, "infix:sym<->", $P2269)
    get_how $P2270, type_obj
    get_global $P2271, "!PREFIX__infix:sym<->"
    $P2270."add_method"(type_obj, "!PREFIX__infix:sym<->", $P2271)
    get_how $P2272, type_obj
    .const 'Sub' $P2273 = "320_1300146757.646" 
    $P2272."add_method"(type_obj, "infix:sym<+|>", $P2273)
    get_how $P2274, type_obj
    get_global $P2275, "!PREFIX__infix:sym<+|>"
    $P2274."add_method"(type_obj, "!PREFIX__infix:sym<+|>", $P2275)
    get_how $P2276, type_obj
    .const 'Sub' $P2277 = "322_1300146757.646" 
    $P2276."add_method"(type_obj, "infix:sym<+^>", $P2277)
    get_how $P2278, type_obj
    get_global $P2279, "!PREFIX__infix:sym<+^>"
    $P2278."add_method"(type_obj, "!PREFIX__infix:sym<+^>", $P2279)
    get_how $P2280, type_obj
    .const 'Sub' $P2281 = "324_1300146757.646" 
    $P2280."add_method"(type_obj, "infix:sym<~>", $P2281)
    get_how $P2282, type_obj
    get_global $P2283, "!PREFIX__infix:sym<~>"
    $P2282."add_method"(type_obj, "!PREFIX__infix:sym<~>", $P2283)
    get_how $P2284, type_obj
    .const 'Sub' $P2285 = "326_1300146757.646" 
    $P2284."add_method"(type_obj, "infix:sym<==>", $P2285)
    get_how $P2286, type_obj
    get_global $P2287, "!PREFIX__infix:sym<==>"
    $P2286."add_method"(type_obj, "!PREFIX__infix:sym<==>", $P2287)
    get_how $P2288, type_obj
    .const 'Sub' $P2289 = "328_1300146757.646" 
    $P2288."add_method"(type_obj, "infix:sym<!=>", $P2289)
    get_how $P2290, type_obj
    get_global $P2291, "!PREFIX__infix:sym<!=>"
    $P2290."add_method"(type_obj, "!PREFIX__infix:sym<!=>", $P2291)
    get_how $P2292, type_obj
    .const 'Sub' $P2293 = "330_1300146757.646" 
    $P2292."add_method"(type_obj, "infix:sym<<=>", $P2293)
    get_how $P2294, type_obj
    get_global $P2295, "!PREFIX__infix:sym<<=>"
    $P2294."add_method"(type_obj, "!PREFIX__infix:sym<<=>", $P2295)
    get_how $P2296, type_obj
    .const 'Sub' $P2297 = "332_1300146757.646" 
    $P2296."add_method"(type_obj, "infix:sym<>=>", $P2297)
    get_how $P2298, type_obj
    get_global $P2299, "!PREFIX__infix:sym<>=>"
    $P2298."add_method"(type_obj, "!PREFIX__infix:sym<>=>", $P2299)
    get_how $P2300, type_obj
    .const 'Sub' $P2301 = "334_1300146757.646" 
    $P2300."add_method"(type_obj, "infix:sym<<>", $P2301)
    get_how $P2302, type_obj
    get_global $P2303, "!PREFIX__infix:sym<<>"
    $P2302."add_method"(type_obj, "!PREFIX__infix:sym<<>", $P2303)
    get_how $P2304, type_obj
    .const 'Sub' $P2305 = "336_1300146757.646" 
    $P2304."add_method"(type_obj, "infix:sym<>>", $P2305)
    get_how $P2306, type_obj
    get_global $P2307, "!PREFIX__infix:sym<>>"
    $P2306."add_method"(type_obj, "!PREFIX__infix:sym<>>", $P2307)
    get_how $P2308, type_obj
    .const 'Sub' $P2309 = "338_1300146757.646" 
    $P2308."add_method"(type_obj, "infix:sym<eq>", $P2309)
    get_how $P2310, type_obj
    get_global $P2311, "!PREFIX__infix:sym<eq>"
    $P2310."add_method"(type_obj, "!PREFIX__infix:sym<eq>", $P2311)
    get_how $P2312, type_obj
    .const 'Sub' $P2313 = "340_1300146757.646" 
    $P2312."add_method"(type_obj, "infix:sym<ne>", $P2313)
    get_how $P2314, type_obj
    get_global $P2315, "!PREFIX__infix:sym<ne>"
    $P2314."add_method"(type_obj, "!PREFIX__infix:sym<ne>", $P2315)
    get_how $P2316, type_obj
    .const 'Sub' $P2317 = "342_1300146757.646" 
    $P2316."add_method"(type_obj, "infix:sym<le>", $P2317)
    get_how $P2318, type_obj
    get_global $P2319, "!PREFIX__infix:sym<le>"
    $P2318."add_method"(type_obj, "!PREFIX__infix:sym<le>", $P2319)
    get_how $P2320, type_obj
    .const 'Sub' $P2321 = "344_1300146757.646" 
    $P2320."add_method"(type_obj, "infix:sym<ge>", $P2321)
    get_how $P2322, type_obj
    get_global $P2323, "!PREFIX__infix:sym<ge>"
    $P2322."add_method"(type_obj, "!PREFIX__infix:sym<ge>", $P2323)
    get_how $P2324, type_obj
    .const 'Sub' $P2325 = "346_1300146757.646" 
    $P2324."add_method"(type_obj, "infix:sym<lt>", $P2325)
    get_how $P2326, type_obj
    get_global $P2327, "!PREFIX__infix:sym<lt>"
    $P2326."add_method"(type_obj, "!PREFIX__infix:sym<lt>", $P2327)
    get_how $P2328, type_obj
    .const 'Sub' $P2329 = "348_1300146757.646" 
    $P2328."add_method"(type_obj, "infix:sym<gt>", $P2329)
    get_how $P2330, type_obj
    get_global $P2331, "!PREFIX__infix:sym<gt>"
    $P2330."add_method"(type_obj, "!PREFIX__infix:sym<gt>", $P2331)
    get_how $P2332, type_obj
    .const 'Sub' $P2333 = "350_1300146757.646" 
    $P2332."add_method"(type_obj, "infix:sym<=:=>", $P2333)
    get_how $P2334, type_obj
    get_global $P2335, "!PREFIX__infix:sym<=:=>"
    $P2334."add_method"(type_obj, "!PREFIX__infix:sym<=:=>", $P2335)
    get_how $P2336, type_obj
    .const 'Sub' $P2337 = "352_1300146757.646" 
    $P2336."add_method"(type_obj, "infix:sym<~~>", $P2337)
    get_how $P2338, type_obj
    get_global $P2339, "!PREFIX__infix:sym<~~>"
    $P2338."add_method"(type_obj, "!PREFIX__infix:sym<~~>", $P2339)
    get_how $P2340, type_obj
    .const 'Sub' $P2341 = "354_1300146757.646" 
    $P2340."add_method"(type_obj, "infix:sym<&&>", $P2341)
    get_how $P2342, type_obj
    get_global $P2343, "!PREFIX__infix:sym<&&>"
    $P2342."add_method"(type_obj, "!PREFIX__infix:sym<&&>", $P2343)
    get_how $P2344, type_obj
    .const 'Sub' $P2345 = "356_1300146757.646" 
    $P2344."add_method"(type_obj, "infix:sym<||>", $P2345)
    get_how $P2346, type_obj
    get_global $P2347, "!PREFIX__infix:sym<||>"
    $P2346."add_method"(type_obj, "!PREFIX__infix:sym<||>", $P2347)
    get_how $P2348, type_obj
    .const 'Sub' $P2349 = "358_1300146757.646" 
    $P2348."add_method"(type_obj, "infix:sym<//>", $P2349)
    get_how $P2350, type_obj
    get_global $P2351, "!PREFIX__infix:sym<//>"
    $P2350."add_method"(type_obj, "!PREFIX__infix:sym<//>", $P2351)
    get_how $P2352, type_obj
    .const 'Sub' $P2353 = "360_1300146757.646" 
    $P2352."add_method"(type_obj, "infix:sym<?? !!>", $P2353)
    get_how $P2354, type_obj
    get_global $P2355, "!PREFIX__infix:sym<?? !!>"
    $P2354."add_method"(type_obj, "!PREFIX__infix:sym<?? !!>", $P2355)
    get_how $P2356, type_obj
    .const 'Sub' $P2357 = "362_1300146757.646" 
    $P2356."add_method"(type_obj, "infix:sym<=>", $P2357)
    get_how $P2358, type_obj
    get_global $P2359, "!PREFIX__infix:sym<=>"
    $P2358."add_method"(type_obj, "!PREFIX__infix:sym<=>", $P2359)
    get_how $P2360, type_obj
    .const 'Sub' $P2361 = "364_1300146757.646" 
    $P2360."add_method"(type_obj, "infix:sym<:=>", $P2361)
    get_how $P2362, type_obj
    get_global $P2363, "!PREFIX__infix:sym<:=>"
    $P2362."add_method"(type_obj, "!PREFIX__infix:sym<:=>", $P2363)
    get_how $P2364, type_obj
    .const 'Sub' $P2365 = "366_1300146757.646" 
    $P2364."add_method"(type_obj, "infix:sym<::=>", $P2365)
    get_how $P2366, type_obj
    get_global $P2367, "!PREFIX__infix:sym<::=>"
    $P2366."add_method"(type_obj, "!PREFIX__infix:sym<::=>", $P2367)
    get_how $P2368, type_obj
    .const 'Sub' $P2369 = "368_1300146757.646" 
    $P2368."add_method"(type_obj, "infix:sym<,>", $P2369)
    get_how $P2370, type_obj
    get_global $P2371, "!PREFIX__infix:sym<,>"
    $P2370."add_method"(type_obj, "!PREFIX__infix:sym<,>", $P2371)
    get_how $P2372, type_obj
    .const 'Sub' $P2373 = "370_1300146757.646" 
    $P2372."add_method"(type_obj, "prefix:sym<return>", $P2373)
    get_how $P2374, type_obj
    get_global $P2375, "!PREFIX__prefix:sym<return>"
    $P2374."add_method"(type_obj, "!PREFIX__prefix:sym<return>", $P2375)
    get_how $P2376, type_obj
    .const 'Sub' $P2377 = "373_1300146757.646" 
    $P2376."add_method"(type_obj, "prefix:sym<make>", $P2377)
    get_how $P2378, type_obj
    get_global $P2379, "!PREFIX__prefix:sym<make>"
    $P2378."add_method"(type_obj, "!PREFIX__prefix:sym<make>", $P2379)
    get_how $P2380, type_obj
    .const 'Sub' $P2381 = "375_1300146757.646" 
    $P2380."add_method"(type_obj, "term:sym<last>", $P2381)
    get_how $P2382, type_obj
    get_global $P2383, "!PREFIX__term:sym<last>"
    $P2382."add_method"(type_obj, "!PREFIX__term:sym<last>", $P2383)
    get_how $P2384, type_obj
    .const 'Sub' $P2385 = "377_1300146757.646" 
    $P2384."add_method"(type_obj, "term:sym<next>", $P2385)
    get_how $P2386, type_obj
    get_global $P2387, "!PREFIX__term:sym<next>"
    $P2386."add_method"(type_obj, "!PREFIX__term:sym<next>", $P2387)
    get_how $P2388, type_obj
    .const 'Sub' $P2389 = "379_1300146757.646" 
    $P2388."add_method"(type_obj, "term:sym<redo>", $P2389)
    get_how $P2390, type_obj
    get_global $P2391, "!PREFIX__term:sym<redo>"
    $P2390."add_method"(type_obj, "!PREFIX__term:sym<redo>", $P2391)
    get_how $P2392, type_obj
    .const 'Sub' $P2393 = "381_1300146757.646" 
    $P2392."add_method"(type_obj, "smartmatch", $P2393)
    get_how $P2394, type_obj
    get_hll_global $P2395, ["HLL"], "Grammar"
    $P2394."add_parent"(type_obj, $P2395)
    get_how $P2396, type_obj
    $P2397 = $P2396."compose"(type_obj)
    .return ($P2397)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "TOP"  :subid("13_1300146757.646") :outer("12_1300146757.646")
    .param pmc param_37
.annotate 'line', 10
    .lex "self", param_37
.annotate 'line', 12
    $P38 = root_new ['parrot';'Hash']
    .lex "%*LANG", $P38
.annotate 'line', 19
    $P39 = root_new ['parrot';'Hash']
    .lex "%*HOW", $P39
.annotate 'line', 28
    new $P40, "Undef"
    .lex "$*DEFAULT-METAATTR", $P40
.annotate 'line', 29
    $P41 = root_new ['parrot';'Hash']
    .lex "%*HOW-METAATTR", $P41
.annotate 'line', 35
    new $P42, "Undef"
    .lex "$*SC", $P42
.annotate 'line', 39
    new $P43, "Undef"
    .lex "$*SCOPE", $P43
.annotate 'line', 40
    new $P44, "Undef"
    .lex "$*MULTINESS", $P44
.annotate 'line', 41
    new $P45, "Undef"
    .lex "$*INVOCANT_OK", $P45
.annotate 'line', 42
    new $P46, "Undef"
    .lex "$*RETURN_USED", $P46
.annotate 'line', 43
    new $P47, "Undef"
    .lex "$*PACKAGE-SETUP", $P47
.annotate 'line', 10
    find_lex $P48, "%*LANG"
    unless_null $P48, vivify_572
    get_hll_global $P48, "%LANG"
    unless_null $P48, vivify_573
    die "Contextual %*LANG not found"
  vivify_573:
  vivify_572:
.annotate 'line', 13
    get_hll_global $P49, ["NQP"], "Regex"
    find_lex $P50, "%*LANG"
    unless_null $P50, vivify_574
    get_hll_global $P50, "%LANG"
    unless_null $P50, vivify_575
    die "Contextual %*LANG not found"
  vivify_575:
    store_lex "%*LANG", $P50
  vivify_574:
    set $P50["Regex"], $P49
.annotate 'line', 14
    get_hll_global $P51, ["NQP"], "RegexActions"
    find_lex $P52, "%*LANG"
    unless_null $P52, vivify_576
    get_hll_global $P52, "%LANG"
    unless_null $P52, vivify_577
    die "Contextual %*LANG not found"
  vivify_577:
    store_lex "%*LANG", $P52
  vivify_576:
    set $P52["Regex-actions"], $P51
.annotate 'line', 15
    get_hll_global $P53, ["NQP"], "Grammar"
    find_lex $P54, "%*LANG"
    unless_null $P54, vivify_578
    get_hll_global $P54, "%LANG"
    unless_null $P54, vivify_579
    die "Contextual %*LANG not found"
  vivify_579:
    store_lex "%*LANG", $P54
  vivify_578:
    set $P54["MAIN"], $P53
.annotate 'line', 16
    get_hll_global $P55, ["NQP"], "Actions"
    find_lex $P56, "%*LANG"
    unless_null $P56, vivify_580
    get_hll_global $P56, "%LANG"
    unless_null $P56, vivify_581
    die "Contextual %*LANG not found"
  vivify_581:
    store_lex "%*LANG", $P56
  vivify_580:
    set $P56["MAIN-actions"], $P55
    find_lex $P57, "%*HOW"
    unless_null $P57, vivify_582
    get_hll_global $P57, "%HOW"
    unless_null $P57, vivify_583
    die "Contextual %*HOW not found"
  vivify_583:
  vivify_582:
.annotate 'line', 20
    get_hll_global $P58, "KnowHOW"
    find_lex $P59, "%*HOW"
    unless_null $P59, vivify_584
    get_hll_global $P59, "%HOW"
    unless_null $P59, vivify_585
    die "Contextual %*HOW not found"
  vivify_585:
    store_lex "%*HOW", $P59
  vivify_584:
    set $P59["knowhow"], $P58
.annotate 'line', 21
    get_hll_global $P60, "NQPModuleHOW"
    find_lex $P61, "%*HOW"
    unless_null $P61, vivify_586
    get_hll_global $P61, "%HOW"
    unless_null $P61, vivify_587
    die "Contextual %*HOW not found"
  vivify_587:
    store_lex "%*HOW", $P61
  vivify_586:
    set $P61["module"], $P60
.annotate 'line', 22
    get_hll_global $P62, "NQPClassHOW"
    find_lex $P63, "%*HOW"
    unless_null $P63, vivify_588
    get_hll_global $P63, "%HOW"
    unless_null $P63, vivify_589
    die "Contextual %*HOW not found"
  vivify_589:
    store_lex "%*HOW", $P63
  vivify_588:
    set $P63["class"], $P62
.annotate 'line', 23
    get_hll_global $P64, "NQPClassHOW"
    find_lex $P65, "%*HOW"
    unless_null $P65, vivify_590
    get_hll_global $P65, "%HOW"
    unless_null $P65, vivify_591
    die "Contextual %*HOW not found"
  vivify_591:
    store_lex "%*HOW", $P65
  vivify_590:
    set $P65["grammar"], $P64
.annotate 'line', 24
    get_hll_global $P66, "NQPParametricRoleHOW"
    find_lex $P67, "%*HOW"
    unless_null $P67, vivify_592
    get_hll_global $P67, "%HOW"
    unless_null $P67, vivify_593
    die "Contextual %*HOW not found"
  vivify_593:
    store_lex "%*HOW", $P67
  vivify_592:
    set $P67["role"], $P66
.annotate 'line', 25
    get_hll_global $P68, "NQPNativeHOW"
    find_lex $P69, "%*HOW"
    unless_null $P69, vivify_594
    get_hll_global $P69, "%HOW"
    unless_null $P69, vivify_595
    die "Contextual %*HOW not found"
  vivify_595:
    store_lex "%*HOW", $P69
  vivify_594:
    set $P69["native"], $P68
.annotate 'line', 28
    new $P70, "String"
    assign $P70, "NQPAttribute"
    store_lex "$*DEFAULT-METAATTR", $P70
    find_lex $P71, "%*HOW-METAATTR"
    unless_null $P71, vivify_596
    get_hll_global $P71, "%HOW-METAATTR"
    unless_null $P71, vivify_597
    die "Contextual %*HOW-METAATTR not found"
  vivify_597:
  vivify_596:
.annotate 'line', 30
    new $P72, "String"
    assign $P72, "KnowHOWAttribute"
    find_lex $P73, "%*HOW-METAATTR"
    unless_null $P73, vivify_598
    get_hll_global $P73, "%HOW-METAATTR"
    unless_null $P73, vivify_599
    die "Contextual %*HOW-METAATTR not found"
  vivify_599:
    store_lex "%*HOW-METAATTR", $P73
  vivify_598:
    set $P73["knowhow"], $P72
.annotate 'line', 35
    get_hll_global $P74, ["HLL";"Compiler"], "SerializationContextBuilder"
.annotate 'line', 37
    time $N75
    set $S76, $N75
    $P77 = $P74."new"($S76 :named("handle"))
.annotate 'line', 35
    store_lex "$*SC", $P77
.annotate 'line', 39
    new $P78, "String"
    assign $P78, ""
    store_lex "$*SCOPE", $P78
.annotate 'line', 40
    new $P79, "String"
    assign $P79, ""
    store_lex "$*MULTINESS", $P79
.annotate 'line', 41
    new $P80, "Integer"
    assign $P80, 0
    store_lex "$*INVOCANT_OK", $P80
.annotate 'line', 42
    new $P81, "Integer"
    assign $P81, 0
    store_lex "$*RETURN_USED", $P81
    find_lex $P82, "$*PACKAGE-SETUP"
    unless_null $P82, vivify_600
    get_hll_global $P82, "$PACKAGE-SETUP"
    unless_null $P82, vivify_601
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_601:
  vivify_600:
.annotate 'line', 44
    find_lex $P83, "self"
    $P84 = $P83."comp_unit"()
.annotate 'line', 10
    .return ($P84)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "identifier"  :subid("14_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx86_tgt
    .local int rx86_pos
    .local int rx86_off
    .local int rx86_eos
    .local int rx86_rep
    .local pmc rx86_cur
    .local pmc rx86_debug
    (rx86_cur, rx86_pos, rx86_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx86_cur
    .local pmc match
    .lex "$/", match
    length rx86_eos, rx86_tgt
    gt rx86_pos, rx86_eos, rx86_done
    set rx86_off, 0
    lt rx86_pos, 2, rx86_start
    sub rx86_off, rx86_pos, 1
    substr rx86_tgt, rx86_tgt, rx86_off
  rx86_start:
    eq $I10, 1, rx86_restart
    if_null rx86_debug, debug_602
    rx86_cur."!cursor_debug"("START", "identifier")
  debug_602:
    $I10 = self.'from'()
    ne $I10, -1, rxscan90_done
    goto rxscan90_scan
  rxscan90_loop:
    (rx86_pos) = rx86_cur."from"()
    inc rx86_pos
    rx86_cur."!cursor_from"(rx86_pos)
    ge rx86_pos, rx86_eos, rxscan90_done
  rxscan90_scan:
    set_addr $I10, rxscan90_loop
    rx86_cur."!mark_push"(0, rx86_pos, $I10)
  rxscan90_done:
.annotate 'line', 49
  # rx subrule "ident" subtype=method negate=
    rx86_cur."!cursor_pos"(rx86_pos)
    $P10 = rx86_cur."ident"()
    unless $P10, rx86_fail
    rx86_pos = $P10."pos"()
  # rx rxquantr91 ** 0..*
    set_addr $I10, rxquantr91_done
    rx86_cur."!mark_push"(0, rx86_pos, $I10)
  rxquantr91_loop:
  # rx enumcharlist negate=0 
    ge rx86_pos, rx86_eos, rx86_fail
    sub $I10, rx86_pos, rx86_off
    substr $S10, rx86_tgt, $I10, 1
    index $I11, "-'", $S10
    lt $I11, 0, rx86_fail
    inc rx86_pos
  # rx subrule "ident" subtype=method negate=
    rx86_cur."!cursor_pos"(rx86_pos)
    $P10 = rx86_cur."ident"()
    unless $P10, rx86_fail
    rx86_pos = $P10."pos"()
    set_addr $I10, rxquantr91_done
    (rx86_rep) = rx86_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr91_done
    rx86_cur."!mark_push"(rx86_rep, rx86_pos, $I10)
    goto rxquantr91_loop
  rxquantr91_done:
  # rx pass
    rx86_cur."!cursor_pass"(rx86_pos, "identifier")
    if_null rx86_debug, debug_603
    rx86_cur."!cursor_debug"("PASS", "identifier", " at pos=", rx86_pos)
  debug_603:
    .return (rx86_cur)
  rx86_restart:
.annotate 'line', 10
    if_null rx86_debug, debug_604
    rx86_cur."!cursor_debug"("NEXT", "identifier")
  debug_604:
  rx86_fail:
    (rx86_rep, rx86_pos, $I10, $P10) = rx86_cur."!mark_fail"(0)
    lt rx86_pos, -1, rx86_done
    eq rx86_pos, -1, rx86_fail
    jump $I10
  rx86_done:
    rx86_cur."!cursor_fail"()
    if_null rx86_debug, debug_605
    rx86_cur."!cursor_debug"("FAIL", "identifier")
  debug_605:
    .return (rx86_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__identifier"  :nsentry("!PREFIX__identifier") :subid("15_1300146757.646") :method
.annotate 'line', 10
    $P88 = self."!PREFIX__!subrule"("ident", "")
    new $P89, "ResizablePMCArray"
    push $P89, $P88
    .return ($P89)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "name"  :subid("16_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx93_tgt
    .local int rx93_pos
    .local int rx93_off
    .local int rx93_eos
    .local int rx93_rep
    .local pmc rx93_cur
    .local pmc rx93_debug
    (rx93_cur, rx93_pos, rx93_tgt, $I10) = self."!cursor_start"()
    rx93_cur."!cursor_caparray"("identifier")
    .lex unicode:"$\x{a2}", rx93_cur
    .local pmc match
    .lex "$/", match
    length rx93_eos, rx93_tgt
    gt rx93_pos, rx93_eos, rx93_done
    set rx93_off, 0
    lt rx93_pos, 2, rx93_start
    sub rx93_off, rx93_pos, 1
    substr rx93_tgt, rx93_tgt, rx93_off
  rx93_start:
    eq $I10, 1, rx93_restart
    if_null rx93_debug, debug_606
    rx93_cur."!cursor_debug"("START", "name")
  debug_606:
    $I10 = self.'from'()
    ne $I10, -1, rxscan96_done
    goto rxscan96_scan
  rxscan96_loop:
    (rx93_pos) = rx93_cur."from"()
    inc rx93_pos
    rx93_cur."!cursor_from"(rx93_pos)
    ge rx93_pos, rx93_eos, rxscan96_done
  rxscan96_scan:
    set_addr $I10, rxscan96_loop
    rx93_cur."!mark_push"(0, rx93_pos, $I10)
  rxscan96_done:
.annotate 'line', 51
  # rx rxquantr97 ** 1..*
    set_addr $I10, rxquantr97_done
    rx93_cur."!mark_push"(0, -1, $I10)
  rxquantr97_loop:
  # rx subrule "identifier" subtype=capture negate=
    rx93_cur."!cursor_pos"(rx93_pos)
    $P10 = rx93_cur."identifier"()
    unless $P10, rx93_fail
    goto rxsubrule98_pass
  rxsubrule98_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx93_fail
  rxsubrule98_pass:
    set_addr $I10, rxsubrule98_back
    rx93_cur."!mark_push"(0, rx93_pos, $I10, $P10)
    $P10."!cursor_names"("identifier")
    rx93_pos = $P10."pos"()
    set_addr $I10, rxquantr97_done
    (rx93_rep) = rx93_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr97_done
    rx93_cur."!mark_push"(rx93_rep, rx93_pos, $I10)
  # rx literal  "::"
    add $I11, rx93_pos, 2
    gt $I11, rx93_eos, rx93_fail
    sub $I11, rx93_pos, rx93_off
    substr $S10, rx93_tgt, $I11, 2
    ne $S10, "::", rx93_fail
    add rx93_pos, 2
    goto rxquantr97_loop
  rxquantr97_done:
  # rx pass
    rx93_cur."!cursor_pass"(rx93_pos, "name")
    if_null rx93_debug, debug_607
    rx93_cur."!cursor_debug"("PASS", "name", " at pos=", rx93_pos)
  debug_607:
    .return (rx93_cur)
  rx93_restart:
.annotate 'line', 10
    if_null rx93_debug, debug_608
    rx93_cur."!cursor_debug"("NEXT", "name")
  debug_608:
  rx93_fail:
    (rx93_rep, rx93_pos, $I10, $P10) = rx93_cur."!mark_fail"(0)
    lt rx93_pos, -1, rx93_done
    eq rx93_pos, -1, rx93_fail
    jump $I10
  rx93_done:
    rx93_cur."!cursor_fail"()
    if_null rx93_debug, debug_609
    rx93_cur."!cursor_debug"("FAIL", "name")
  debug_609:
    .return (rx93_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__name"  :nsentry("!PREFIX__name") :subid("17_1300146757.646") :method
.annotate 'line', 10
    new $P95, "ResizablePMCArray"
    push $P95, ""
    .return ($P95)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "deflongname"  :subid("18_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx100_tgt
    .local int rx100_pos
    .local int rx100_off
    .local int rx100_eos
    .local int rx100_rep
    .local pmc rx100_cur
    .local pmc rx100_debug
    (rx100_cur, rx100_pos, rx100_tgt, $I10) = self."!cursor_start"()
    rx100_cur."!cursor_caparray"("colonpair")
    .lex unicode:"$\x{a2}", rx100_cur
    .local pmc match
    .lex "$/", match
    length rx100_eos, rx100_tgt
    gt rx100_pos, rx100_eos, rx100_done
    set rx100_off, 0
    lt rx100_pos, 2, rx100_start
    sub rx100_off, rx100_pos, 1
    substr rx100_tgt, rx100_tgt, rx100_off
  rx100_start:
    eq $I10, 1, rx100_restart
    if_null rx100_debug, debug_610
    rx100_cur."!cursor_debug"("START", "deflongname")
  debug_610:
    $I10 = self.'from'()
    ne $I10, -1, rxscan104_done
    goto rxscan104_scan
  rxscan104_loop:
    (rx100_pos) = rx100_cur."from"()
    inc rx100_pos
    rx100_cur."!cursor_from"(rx100_pos)
    ge rx100_pos, rx100_eos, rxscan104_done
  rxscan104_scan:
    set_addr $I10, rxscan104_loop
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  rxscan104_done:
.annotate 'line', 54
  # rx subrule "identifier" subtype=capture negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."identifier"()
    unless $P10, rx100_fail
    rx100_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx100_pos = $P10."pos"()
  # rx rxquantr105 ** 0..1
    set_addr $I10, rxquantr105_done
    rx100_cur."!mark_push"(0, rx100_pos, $I10)
  rxquantr105_loop:
  # rx subrule "colonpair" subtype=capture negate=
    rx100_cur."!cursor_pos"(rx100_pos)
    $P10 = rx100_cur."colonpair"()
    unless $P10, rx100_fail
    goto rxsubrule106_pass
  rxsubrule106_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx100_fail
  rxsubrule106_pass:
    set_addr $I10, rxsubrule106_back
    rx100_cur."!mark_push"(0, rx100_pos, $I10, $P10)
    $P10."!cursor_names"("colonpair")
    rx100_pos = $P10."pos"()
    set_addr $I10, rxquantr105_done
    (rx100_rep) = rx100_cur."!mark_commit"($I10)
  rxquantr105_done:
.annotate 'line', 53
  # rx pass
    rx100_cur."!cursor_pass"(rx100_pos, "deflongname")
    if_null rx100_debug, debug_611
    rx100_cur."!cursor_debug"("PASS", "deflongname", " at pos=", rx100_pos)
  debug_611:
    .return (rx100_cur)
  rx100_restart:
.annotate 'line', 10
    if_null rx100_debug, debug_612
    rx100_cur."!cursor_debug"("NEXT", "deflongname")
  debug_612:
  rx100_fail:
    (rx100_rep, rx100_pos, $I10, $P10) = rx100_cur."!mark_fail"(0)
    lt rx100_pos, -1, rx100_done
    eq rx100_pos, -1, rx100_fail
    jump $I10
  rx100_done:
    rx100_cur."!cursor_fail"()
    if_null rx100_debug, debug_613
    rx100_cur."!cursor_debug"("FAIL", "deflongname")
  debug_613:
    .return (rx100_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__deflongname"  :nsentry("!PREFIX__deflongname") :subid("19_1300146757.646") :method
.annotate 'line', 10
    $P102 = self."!PREFIX__!subrule"("identifier", "")
    new $P103, "ResizablePMCArray"
    push $P103, $P102
    .return ($P103)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ENDSTMT"  :subid("20_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx108_tgt
    .local int rx108_pos
    .local int rx108_off
    .local int rx108_eos
    .local int rx108_rep
    .local pmc rx108_cur
    .local pmc rx108_debug
    (rx108_cur, rx108_pos, rx108_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx108_cur
    .local pmc match
    .lex "$/", match
    length rx108_eos, rx108_tgt
    gt rx108_pos, rx108_eos, rx108_done
    set rx108_off, 0
    lt rx108_pos, 2, rx108_start
    sub rx108_off, rx108_pos, 1
    substr rx108_tgt, rx108_tgt, rx108_off
  rx108_start:
    eq $I10, 1, rx108_restart
    if_null rx108_debug, debug_614
    rx108_cur."!cursor_debug"("START", "ENDSTMT")
  debug_614:
    $I10 = self.'from'()
    ne $I10, -1, rxscan111_done
    goto rxscan111_scan
  rxscan111_loop:
    (rx108_pos) = rx108_cur."from"()
    inc rx108_pos
    rx108_cur."!cursor_from"(rx108_pos)
    ge rx108_pos, rx108_eos, rxscan111_done
  rxscan111_scan:
    set_addr $I10, rxscan111_loop
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxscan111_done:
.annotate 'line', 61
  # rx rxquantr112 ** 0..1
    set_addr $I10, rxquantr112_done
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxquantr112_loop:
  alt113_0:
.annotate 'line', 58
    set_addr $I10, alt113_1
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
.annotate 'line', 59
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx108_pos, rx108_off
    set rx108_rep, 0
    sub $I12, rx108_eos, rx108_pos
  rxenumcharlistq114_loop:
    le $I12, 0, rxenumcharlistq114_done
    substr $S10, rx108_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq114_done
    inc rx108_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq114_loop
  rxenumcharlistq114_done:
    add rx108_pos, rx108_pos, rx108_rep
  # rxanchor eol
    sub $I10, rx108_pos, rx108_off
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rxanchor115_done
    ne rx108_pos, rx108_eos, rx108_fail
    eq rx108_pos, 0, rxanchor115_done
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rx108_fail
  rxanchor115_done:
  # rx subrule "ws" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."ws"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."MARKER"("endstmt")
    unless $P10, rx108_fail
    goto alt113_end
  alt113_1:
.annotate 'line', 60
  # rx rxquantr116 ** 0..1
    set_addr $I10, rxquantr116_done
    rx108_cur."!mark_push"(0, rx108_pos, $I10)
  rxquantr116_loop:
  # rx subrule "unv" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."unv"()
    unless $P10, rx108_fail
    goto rxsubrule117_pass
  rxsubrule117_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx108_fail
  rxsubrule117_pass:
    set_addr $I10, rxsubrule117_back
    rx108_cur."!mark_push"(0, rx108_pos, $I10, $P10)
    rx108_pos = $P10."pos"()
    set_addr $I10, rxquantr116_done
    (rx108_rep) = rx108_cur."!mark_commit"($I10)
  rxquantr116_done:
  # rxanchor eol
    sub $I10, rx108_pos, rx108_off
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rxanchor118_done
    ne rx108_pos, rx108_eos, rx108_fail
    eq rx108_pos, 0, rxanchor118_done
    dec $I10
    is_cclass $I11, 4096, rx108_tgt, $I10
    if $I11, rx108_fail
  rxanchor118_done:
  # rx subrule "ws" subtype=method negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."ws"()
    unless $P10, rx108_fail
    rx108_pos = $P10."pos"()
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx108_cur."!cursor_pos"(rx108_pos)
    $P10 = rx108_cur."MARKER"("endstmt")
    unless $P10, rx108_fail
  alt113_end:
.annotate 'line', 61
    set_addr $I10, rxquantr112_done
    (rx108_rep) = rx108_cur."!mark_commit"($I10)
  rxquantr112_done:
.annotate 'line', 57
  # rx pass
    rx108_cur."!cursor_pass"(rx108_pos, "ENDSTMT")
    if_null rx108_debug, debug_615
    rx108_cur."!cursor_debug"("PASS", "ENDSTMT", " at pos=", rx108_pos)
  debug_615:
    .return (rx108_cur)
  rx108_restart:
.annotate 'line', 10
    if_null rx108_debug, debug_616
    rx108_cur."!cursor_debug"("NEXT", "ENDSTMT")
  debug_616:
  rx108_fail:
    (rx108_rep, rx108_pos, $I10, $P10) = rx108_cur."!mark_fail"(0)
    lt rx108_pos, -1, rx108_done
    eq rx108_pos, -1, rx108_fail
    jump $I10
  rx108_done:
    rx108_cur."!cursor_fail"()
    if_null rx108_debug, debug_617
    rx108_cur."!cursor_debug"("FAIL", "ENDSTMT")
  debug_617:
    .return (rx108_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ENDSTMT"  :nsentry("!PREFIX__ENDSTMT") :subid("21_1300146757.646") :method
.annotate 'line', 10
    new $P110, "ResizablePMCArray"
    push $P110, ""
    .return ($P110)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "ws"  :subid("22_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx120_tgt
    .local int rx120_pos
    .local int rx120_off
    .local int rx120_eos
    .local int rx120_rep
    .local pmc rx120_cur
    .local pmc rx120_debug
    (rx120_cur, rx120_pos, rx120_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx120_cur
    .local pmc match
    .lex "$/", match
    length rx120_eos, rx120_tgt
    gt rx120_pos, rx120_eos, rx120_done
    set rx120_off, 0
    lt rx120_pos, 2, rx120_start
    sub rx120_off, rx120_pos, 1
    substr rx120_tgt, rx120_tgt, rx120_off
  rx120_start:
    eq $I10, 1, rx120_restart
    if_null rx120_debug, debug_618
    rx120_cur."!cursor_debug"("START", "ws")
  debug_618:
    $I10 = self.'from'()
    ne $I10, -1, rxscan123_done
    goto rxscan123_scan
  rxscan123_loop:
    (rx120_pos) = rx120_cur."from"()
    inc rx120_pos
    rx120_cur."!cursor_from"(rx120_pos)
    ge rx120_pos, rx120_eos, rxscan123_done
  rxscan123_scan:
    set_addr $I10, rxscan123_loop
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  rxscan123_done:
  alt124_0:
.annotate 'line', 64
    set_addr $I10, alt124_1
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 65
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."MARKED"("ws")
    unless $P10, rx120_fail
    goto alt124_end
  alt124_1:
.annotate 'line', 66
  # rx subrule "ww" subtype=zerowidth negate=1
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."ww"()
    if $P10, rx120_fail
.annotate 'line', 71
  # rx rxquantr125 ** 0..*
    set_addr $I10, rxquantr125_done
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  rxquantr125_loop:
  alt126_0:
.annotate 'line', 67
    set_addr $I10, alt126_1
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx120_pos, rx120_off
    set rx120_rep, 0
    sub $I12, rx120_eos, rx120_pos
  rxenumcharlistq127_loop:
    le $I12, 0, rxenumcharlistq127_done
    substr $S10, rx120_tgt, $I10, 1
    index $I11, unicode:"\n\x{b}\f\r\x{85}\u2028\u2029", $S10
    lt $I11, 0, rxenumcharlistq127_done
    inc rx120_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq127_loop
  rxenumcharlistq127_done:
    lt rx120_rep, 1, rx120_fail
    add rx120_pos, rx120_pos, rx120_rep
    goto alt126_end
  alt126_1:
    set_addr $I10, alt126_2
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 68
  # rx literal  "#"
    add $I11, rx120_pos, 1
    gt $I11, rx120_eos, rx120_fail
    sub $I11, rx120_pos, rx120_off
    ord $I11, rx120_tgt, $I11
    ne $I11, 35, rx120_fail
    add rx120_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx120_pos, rx120_off
    find_cclass $I11, 4096, rx120_tgt, $I10, rx120_eos
    add rx120_pos, rx120_off, $I11
    goto alt126_end
  alt126_2:
    set_addr $I10, alt126_3
    rx120_cur."!mark_push"(0, rx120_pos, $I10)
.annotate 'line', 69
  # rxanchor bol
    eq rx120_pos, 0, rxanchor128_done
    ge rx120_pos, rx120_eos, rx120_fail
    sub $I10, rx120_pos, rx120_off
    dec $I10
    is_cclass $I11, 4096, rx120_tgt, $I10
    unless $I11, rx120_fail
  rxanchor128_done:
  # rx subrule "pod_comment" subtype=method negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."pod_comment"()
    unless $P10, rx120_fail
    rx120_pos = $P10."pos"()
    goto alt126_end
  alt126_3:
.annotate 'line', 70
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx120_pos, rx120_off
    set rx120_rep, 0
    sub $I12, rx120_eos, rx120_pos
  rxenumcharlistq129_loop:
    le $I12, 0, rxenumcharlistq129_done
    substr $S10, rx120_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq129_done
    inc rx120_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq129_loop
  rxenumcharlistq129_done:
    lt rx120_rep, 1, rx120_fail
    add rx120_pos, rx120_pos, rx120_rep
  alt126_end:
.annotate 'line', 71
    set_addr $I10, rxquantr125_done
    (rx120_rep) = rx120_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr125_done
    rx120_cur."!mark_push"(rx120_rep, rx120_pos, $I10)
    goto rxquantr125_loop
  rxquantr125_done:
.annotate 'line', 72
  # rx subrule "MARKER" subtype=zerowidth negate=
    rx120_cur."!cursor_pos"(rx120_pos)
    $P10 = rx120_cur."MARKER"("ws")
    unless $P10, rx120_fail
  alt124_end:
.annotate 'line', 64
  # rx pass
    rx120_cur."!cursor_pass"(rx120_pos, "ws")
    if_null rx120_debug, debug_619
    rx120_cur."!cursor_debug"("PASS", "ws", " at pos=", rx120_pos)
  debug_619:
    .return (rx120_cur)
  rx120_restart:
.annotate 'line', 10
    if_null rx120_debug, debug_620
    rx120_cur."!cursor_debug"("NEXT", "ws")
  debug_620:
  rx120_fail:
    (rx120_rep, rx120_pos, $I10, $P10) = rx120_cur."!mark_fail"(0)
    lt rx120_pos, -1, rx120_done
    eq rx120_pos, -1, rx120_fail
    jump $I10
  rx120_done:
    rx120_cur."!cursor_fail"()
    if_null rx120_debug, debug_621
    rx120_cur."!cursor_debug"("FAIL", "ws")
  debug_621:
    .return (rx120_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__ws"  :nsentry("!PREFIX__ws") :subid("23_1300146757.646") :method
.annotate 'line', 10
    new $P122, "ResizablePMCArray"
    push $P122, ""
    push $P122, ""
    .return ($P122)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "unv"  :subid("24_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P138 = "26_1300146757.646" 
    capture_lex $P138
    .local string rx131_tgt
    .local int rx131_pos
    .local int rx131_off
    .local int rx131_eos
    .local int rx131_rep
    .local pmc rx131_cur
    .local pmc rx131_debug
    (rx131_cur, rx131_pos, rx131_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx131_cur
    .local pmc match
    .lex "$/", match
    length rx131_eos, rx131_tgt
    gt rx131_pos, rx131_eos, rx131_done
    set rx131_off, 0
    lt rx131_pos, 2, rx131_start
    sub rx131_off, rx131_pos, 1
    substr rx131_tgt, rx131_tgt, rx131_off
  rx131_start:
    eq $I10, 1, rx131_restart
    if_null rx131_debug, debug_622
    rx131_cur."!cursor_debug"("START", "unv")
  debug_622:
    $I10 = self.'from'()
    ne $I10, -1, rxscan134_done
    goto rxscan134_scan
  rxscan134_loop:
    (rx131_pos) = rx131_cur."from"()
    inc rx131_pos
    rx131_cur."!cursor_from"(rx131_pos)
    ge rx131_pos, rx131_eos, rxscan134_done
  rxscan134_scan:
    set_addr $I10, rxscan134_loop
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
  rxscan134_done:
  alt135_0:
.annotate 'line', 77
    set_addr $I10, alt135_1
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
.annotate 'line', 78
  # rxanchor bol
    eq rx131_pos, 0, rxanchor136_done
    ge rx131_pos, rx131_eos, rx131_fail
    sub $I10, rx131_pos, rx131_off
    dec $I10
    is_cclass $I11, 4096, rx131_tgt, $I10
    unless $I11, rx131_fail
  rxanchor136_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx131_cur."!cursor_pos"(rx131_pos)
    .const 'Sub' $P138 = "26_1300146757.646" 
    capture_lex $P138
    $P10 = rx131_cur."before"($P138)
    unless $P10, rx131_fail
  # rx subrule "pod_comment" subtype=method negate=
    rx131_cur."!cursor_pos"(rx131_pos)
    $P10 = rx131_cur."pod_comment"()
    unless $P10, rx131_fail
    rx131_pos = $P10."pos"()
    goto alt135_end
  alt135_1:
    set_addr $I10, alt135_2
    rx131_cur."!mark_push"(0, rx131_pos, $I10)
.annotate 'line', 79
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx131_pos, rx131_off
    set rx131_rep, 0
    sub $I12, rx131_eos, rx131_pos
  rxenumcharlistq143_loop:
    le $I12, 0, rxenumcharlistq143_done
    substr $S10, rx131_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq143_done
    inc rx131_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq143_loop
  rxenumcharlistq143_done:
    add rx131_pos, rx131_pos, rx131_rep
  # rx literal  "#"
    add $I11, rx131_pos, 1
    gt $I11, rx131_eos, rx131_fail
    sub $I11, rx131_pos, rx131_off
    ord $I11, rx131_tgt, $I11
    ne $I11, 35, rx131_fail
    add rx131_pos, 1
  # rx charclass_q N r 0..-1
    sub $I10, rx131_pos, rx131_off
    find_cclass $I11, 4096, rx131_tgt, $I10, rx131_eos
    add rx131_pos, rx131_off, $I11
    goto alt135_end
  alt135_2:
.annotate 'line', 80
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx131_pos, rx131_off
    set rx131_rep, 0
    sub $I12, rx131_eos, rx131_pos
  rxenumcharlistq144_loop:
    le $I12, 0, rxenumcharlistq144_done
    substr $S10, rx131_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq144_done
    inc rx131_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq144_loop
  rxenumcharlistq144_done:
    lt rx131_rep, 1, rx131_fail
    add rx131_pos, rx131_pos, rx131_rep
  alt135_end:
.annotate 'line', 75
  # rx pass
    rx131_cur."!cursor_pass"(rx131_pos, "unv")
    if_null rx131_debug, debug_627
    rx131_cur."!cursor_debug"("PASS", "unv", " at pos=", rx131_pos)
  debug_627:
    .return (rx131_cur)
  rx131_restart:
.annotate 'line', 10
    if_null rx131_debug, debug_628
    rx131_cur."!cursor_debug"("NEXT", "unv")
  debug_628:
  rx131_fail:
    (rx131_rep, rx131_pos, $I10, $P10) = rx131_cur."!mark_fail"(0)
    lt rx131_pos, -1, rx131_done
    eq rx131_pos, -1, rx131_fail
    jump $I10
  rx131_done:
    rx131_cur."!cursor_fail"()
    if_null rx131_debug, debug_629
    rx131_cur."!cursor_debug"("FAIL", "unv")
  debug_629:
    .return (rx131_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__unv"  :nsentry("!PREFIX__unv") :subid("25_1300146757.646") :method
.annotate 'line', 10
    new $P133, "ResizablePMCArray"
    push $P133, ""
    push $P133, ""
    push $P133, ""
    .return ($P133)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block137"  :anon :subid("26_1300146757.646") :method :outer("24_1300146757.646")
.annotate 'line', 78
    .local string rx139_tgt
    .local int rx139_pos
    .local int rx139_off
    .local int rx139_eos
    .local int rx139_rep
    .local pmc rx139_cur
    .local pmc rx139_debug
    (rx139_cur, rx139_pos, rx139_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx139_cur
    .local pmc match
    .lex "$/", match
    length rx139_eos, rx139_tgt
    gt rx139_pos, rx139_eos, rx139_done
    set rx139_off, 0
    lt rx139_pos, 2, rx139_start
    sub rx139_off, rx139_pos, 1
    substr rx139_tgt, rx139_tgt, rx139_off
  rx139_start:
    eq $I10, 1, rx139_restart
    if_null rx139_debug, debug_623
    rx139_cur."!cursor_debug"("START", "")
  debug_623:
    $I10 = self.'from'()
    ne $I10, -1, rxscan140_done
    goto rxscan140_scan
  rxscan140_loop:
    (rx139_pos) = rx139_cur."from"()
    inc rx139_pos
    rx139_cur."!cursor_from"(rx139_pos)
    ge rx139_pos, rx139_eos, rxscan140_done
  rxscan140_scan:
    set_addr $I10, rxscan140_loop
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  rxscan140_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx139_pos, rx139_off
    set rx139_rep, 0
    sub $I12, rx139_eos, rx139_pos
  rxenumcharlistq141_loop:
    le $I12, 0, rxenumcharlistq141_done
    substr $S10, rx139_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq141_done
    inc rx139_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq141_loop
  rxenumcharlistq141_done:
    add rx139_pos, rx139_pos, rx139_rep
  # rx literal  "="
    add $I11, rx139_pos, 1
    gt $I11, rx139_eos, rx139_fail
    sub $I11, rx139_pos, rx139_off
    ord $I11, rx139_tgt, $I11
    ne $I11, 61, rx139_fail
    add rx139_pos, 1
  alt142_0:
    set_addr $I10, alt142_1
    rx139_cur."!mark_push"(0, rx139_pos, $I10)
  # rx charclass w
    ge rx139_pos, rx139_eos, rx139_fail
    sub $I10, rx139_pos, rx139_off
    is_cclass $I11, 8192, rx139_tgt, $I10
    unless $I11, rx139_fail
    inc rx139_pos
    goto alt142_end
  alt142_1:
  # rx literal  "\\"
    add $I11, rx139_pos, 1
    gt $I11, rx139_eos, rx139_fail
    sub $I11, rx139_pos, rx139_off
    ord $I11, rx139_tgt, $I11
    ne $I11, 92, rx139_fail
    add rx139_pos, 1
  alt142_end:
  # rx pass
    rx139_cur."!cursor_pass"(rx139_pos, "")
    if_null rx139_debug, debug_624
    rx139_cur."!cursor_debug"("PASS", "", " at pos=", rx139_pos)
  debug_624:
    .return (rx139_cur)
  rx139_restart:
    if_null rx139_debug, debug_625
    rx139_cur."!cursor_debug"("NEXT", "")
  debug_625:
  rx139_fail:
    (rx139_rep, rx139_pos, $I10, $P10) = rx139_cur."!mark_fail"(0)
    lt rx139_pos, -1, rx139_done
    eq rx139_pos, -1, rx139_fail
    jump $I10
  rx139_done:
    rx139_cur."!cursor_fail"()
    if_null rx139_debug, debug_626
    rx139_cur."!cursor_debug"("FAIL", "")
  debug_626:
    .return (rx139_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pod_comment"  :subid("27_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P177 = "29_1300146757.646" 
    capture_lex $P177
    .local string rx146_tgt
    .local int rx146_pos
    .local int rx146_off
    .local int rx146_eos
    .local int rx146_rep
    .local pmc rx146_cur
    .local pmc rx146_debug
    (rx146_cur, rx146_pos, rx146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx146_cur
    .local pmc match
    .lex "$/", match
    length rx146_eos, rx146_tgt
    gt rx146_pos, rx146_eos, rx146_done
    set rx146_off, 0
    lt rx146_pos, 2, rx146_start
    sub rx146_off, rx146_pos, 1
    substr rx146_tgt, rx146_tgt, rx146_off
  rx146_start:
    eq $I10, 1, rx146_restart
    if_null rx146_debug, debug_630
    rx146_cur."!cursor_debug"("START", "pod_comment")
  debug_630:
    $I10 = self.'from'()
    ne $I10, -1, rxscan149_done
    goto rxscan149_scan
  rxscan149_loop:
    (rx146_pos) = rx146_cur."from"()
    inc rx146_pos
    rx146_cur."!cursor_from"(rx146_pos)
    ge rx146_pos, rx146_eos, rxscan149_done
  rxscan149_scan:
    set_addr $I10, rxscan149_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  rxscan149_done:
.annotate 'line', 85
  # rxanchor bol
    eq rx146_pos, 0, rxanchor150_done
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
  rxanchor150_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq151_loop:
    le $I12, 0, rxenumcharlistq151_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq151_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq151_loop
  rxenumcharlistq151_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "="
    add $I11, rx146_pos, 1
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    ord $I11, rx146_tgt, $I11
    ne $I11, 61, rx146_fail
    add rx146_pos, 1
  alt152_0:
.annotate 'line', 86
    set_addr $I10, alt152_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 87
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq153_loop:
    le $I12, 0, rxenumcharlistq153_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq153_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq153_loop
  rxenumcharlistq153_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "END"
    add $I11, rx146_pos, 3
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 3
    ne $S10, "END", rx146_fail
    add rx146_pos, 3
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  alt154_0:
.annotate 'line', 88
    set_addr $I10, alt154_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx rxquantf155 ** 0..*
    set_addr $I10, rxquantf155_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf155_done
  rxquantf155_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf155_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf155_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq157_loop:
    le $I12, 0, rxenumcharlistq157_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq157_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq157_loop
  rxenumcharlistq157_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq158_loop:
    le $I12, 0, rxenumcharlistq158_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq158_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq158_loop
  rxenumcharlistq158_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "END"
    add $I11, rx146_pos, 3
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 3
    ne $S10, "END", rx146_fail
    add rx146_pos, 3
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt154_end
  alt154_1:
  # rx charclass_q . r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_not_cclass $I11, 65535, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
  alt154_end:
.annotate 'line', 87
    goto alt152_end
  alt152_1:
    set_addr $I10, alt152_2
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 89
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq159_loop:
    le $I12, 0, rxenumcharlistq159_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq159_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq159_loop
  rxenumcharlistq159_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx subrule "identifier" subtype=capture negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."identifier"()
    unless $P10, rx146_fail
    rx146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx146_pos = $P10."pos"()
  alt160_0:
.annotate 'line', 90
    set_addr $I10, alt160_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 91
  # rx rxquantf161 ** 0..*
    set_addr $I10, rxquantf161_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf161_done
  rxquantf161_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf161_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf161_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq163_loop:
    le $I12, 0, rxenumcharlistq163_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq163_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq163_loop
  rxenumcharlistq163_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rx enumcharlist_q negate=0  r 1..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq164_loop:
    le $I12, 0, rxenumcharlistq164_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq164_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq164_loop
  rxenumcharlistq164_done:
    lt rx146_rep, 1, rx146_fail
    add rx146_pos, rx146_pos, rx146_rep
  # rx subrule "!BACKREF" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."!BACKREF"("identifier")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt160_end
  alt160_1:
.annotate 'line', 92
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("=begin without matching =end")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt160_end:
.annotate 'line', 89
    goto alt152_end
  alt152_2:
    set_addr $I10, alt152_3
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 94
  # rx literal  "begin"
    add $I11, rx146_pos, 5
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 5
    ne $S10, "begin", rx146_fail
    add rx146_pos, 5
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq166_loop:
    le $I12, 0, rxenumcharlistq166_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq166_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq166_loop
  rxenumcharlistq166_done:
    add rx146_pos, rx146_pos, rx146_rep
  alt167_0:
.annotate 'line', 95
    set_addr $I10, alt167_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rxanchor eol
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    if $I11, rxanchor168_done
    ne rx146_pos, rx146_eos, rx146_fail
    eq rx146_pos, 0, rxanchor168_done
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    if $I11, rx146_fail
  rxanchor168_done:
    goto alt167_end
  alt167_1:
    set_addr $I10, alt167_2
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx literal  "#"
    add $I11, rx146_pos, 1
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    ord $I11, rx146_tgt, $I11
    ne $I11, 35, rx146_fail
    add rx146_pos, 1
    goto alt167_end
  alt167_2:
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("Unrecognized token after =begin")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt167_end:
  alt169_0:
.annotate 'line', 96
    set_addr $I10, alt169_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 97
  # rx rxquantf170 ** 0..*
    set_addr $I10, rxquantf170_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf170_done
  rxquantf170_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf170_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf170_done:
  # rx charclass nl
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
    substr $S10, rx146_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx146_pos, $I11
    inc rx146_pos
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx146_pos, rx146_off
    set rx146_rep, 0
    sub $I12, rx146_eos, rx146_pos
  rxenumcharlistq172_loop:
    le $I12, 0, rxenumcharlistq172_done
    substr $S10, rx146_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq172_done
    inc rx146_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq172_loop
  rxenumcharlistq172_done:
    add rx146_pos, rx146_pos, rx146_rep
  # rx literal  "=end"
    add $I11, rx146_pos, 4
    gt $I11, rx146_eos, rx146_fail
    sub $I11, rx146_pos, rx146_off
    substr $S10, rx146_tgt, $I11, 4
    ne $S10, "=end", rx146_fail
    add rx146_pos, 4
  # rxanchor rwb
    le rx146_pos, 0, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 8192, rx146_tgt, $I10
    if $I11, rx146_fail
    dec $I10
    is_cclass $I11, 8192, rx146_tgt, $I10
    unless $I11, rx146_fail
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
    goto alt169_end
  alt169_1:
.annotate 'line', 98
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("=begin without matching =end")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt169_end:
.annotate 'line', 94
    goto alt152_end
  alt152_3:
    set_addr $I10, alt152_4
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
.annotate 'line', 100
  # rx subrule "identifier" subtype=capture negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."identifier"()
    unless $P10, rx146_fail
    rx146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx146_pos = $P10."pos"()
.annotate 'line', 101
  # rx rxquantf173 ** 0..*
    set_addr $I10, rxquantf173_loop
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
    goto rxquantf173_done
  rxquantf173_loop:
  # rx charclass .
    ge rx146_pos, rx146_eos, rx146_fail
    inc rx146_pos
    set_addr $I10, rxquantf173_loop
    rx146_cur."!mark_push"(rx146_rep, rx146_pos, $I10)
  rxquantf173_done:
  # rxanchor bol
    eq rx146_pos, 0, rxanchor175_done
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    dec $I10
    is_cclass $I11, 4096, rx146_tgt, $I10
    unless $I11, rx146_fail
  rxanchor175_done:
  # rx subrule "before" subtype=zerowidth negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    .const 'Sub' $P177 = "29_1300146757.646" 
    capture_lex $P177
    $P10 = rx146_cur."before"($P177)
    unless $P10, rx146_fail
.annotate 'line', 100
    goto alt152_end
  alt152_4:
  alt183_0:
.annotate 'line', 107
    set_addr $I10, alt183_1
    rx146_cur."!mark_push"(0, rx146_pos, $I10)
  # rx charclass s
    ge rx146_pos, rx146_eos, rx146_fail
    sub $I10, rx146_pos, rx146_off
    is_cclass $I11, 32, rx146_tgt, $I10
    unless $I11, rx146_fail
    inc rx146_pos
    goto alt183_end
  alt183_1:
  # rx subrule "panic" subtype=method negate=
    rx146_cur."!cursor_pos"(rx146_pos)
    $P10 = rx146_cur."panic"("Illegal pod directive")
    unless $P10, rx146_fail
    rx146_pos = $P10."pos"()
  alt183_end:
.annotate 'line', 108
  # rx charclass_q N r 0..-1
    sub $I10, rx146_pos, rx146_off
    find_cclass $I11, 4096, rx146_tgt, $I10, rx146_eos
    add rx146_pos, rx146_off, $I11
  alt152_end:
.annotate 'line', 84
  # rx pass
    rx146_cur."!cursor_pass"(rx146_pos, "pod_comment")
    if_null rx146_debug, debug_635
    rx146_cur."!cursor_debug"("PASS", "pod_comment", " at pos=", rx146_pos)
  debug_635:
    .return (rx146_cur)
  rx146_restart:
.annotate 'line', 10
    if_null rx146_debug, debug_636
    rx146_cur."!cursor_debug"("NEXT", "pod_comment")
  debug_636:
  rx146_fail:
    (rx146_rep, rx146_pos, $I10, $P10) = rx146_cur."!mark_fail"(0)
    lt rx146_pos, -1, rx146_done
    eq rx146_pos, -1, rx146_fail
    jump $I10
  rx146_done:
    rx146_cur."!cursor_fail"()
    if_null rx146_debug, debug_637
    rx146_cur."!cursor_debug"("FAIL", "pod_comment")
  debug_637:
    .return (rx146_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pod_comment"  :nsentry("!PREFIX__pod_comment") :subid("28_1300146757.646") :method
.annotate 'line', 10
    new $P148, "ResizablePMCArray"
    push $P148, ""
    .return ($P148)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block176"  :anon :subid("29_1300146757.646") :method :outer("27_1300146757.646")
.annotate 'line', 101
    .local string rx178_tgt
    .local int rx178_pos
    .local int rx178_off
    .local int rx178_eos
    .local int rx178_rep
    .local pmc rx178_cur
    .local pmc rx178_debug
    (rx178_cur, rx178_pos, rx178_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx178_cur
    .local pmc match
    .lex "$/", match
    length rx178_eos, rx178_tgt
    gt rx178_pos, rx178_eos, rx178_done
    set rx178_off, 0
    lt rx178_pos, 2, rx178_start
    sub rx178_off, rx178_pos, 1
    substr rx178_tgt, rx178_tgt, rx178_off
  rx178_start:
    eq $I10, 1, rx178_restart
    if_null rx178_debug, debug_631
    rx178_cur."!cursor_debug"("START", "")
  debug_631:
    $I10 = self.'from'()
    ne $I10, -1, rxscan179_done
    goto rxscan179_scan
  rxscan179_loop:
    (rx178_pos) = rx178_cur."from"()
    inc rx178_pos
    rx178_cur."!cursor_from"(rx178_pos)
    ge rx178_pos, rx178_eos, rxscan179_done
  rxscan179_scan:
    set_addr $I10, rxscan179_loop
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxscan179_done:
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx178_pos, rx178_off
    set rx178_rep, 0
    sub $I12, rx178_eos, rx178_pos
  rxenumcharlistq180_loop:
    le $I12, 0, rxenumcharlistq180_done
    substr $S10, rx178_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq180_done
    inc rx178_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq180_loop
  rxenumcharlistq180_done:
    add rx178_pos, rx178_pos, rx178_rep
  alt181_0:
    set_addr $I10, alt181_1
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
.annotate 'line', 102
  # rx literal  "="
    add $I11, rx178_pos, 1
    gt $I11, rx178_eos, rx178_fail
    sub $I11, rx178_pos, rx178_off
    ord $I11, rx178_tgt, $I11
    ne $I11, 61, rx178_fail
    add rx178_pos, 1
.annotate 'line', 104
  # rx rxquantr182 ** 0..1
    set_addr $I10, rxquantr182_done
    rx178_cur."!mark_push"(0, rx178_pos, $I10)
  rxquantr182_loop:
.annotate 'line', 103
  # rx literal  "cut"
    add $I11, rx178_pos, 3
    gt $I11, rx178_eos, rx178_fail
    sub $I11, rx178_pos, rx178_off
    substr $S10, rx178_tgt, $I11, 3
    ne $S10, "cut", rx178_fail
    add rx178_pos, 3
  # rxanchor rwb
    le rx178_pos, 0, rx178_fail
    sub $I10, rx178_pos, rx178_off
    is_cclass $I11, 8192, rx178_tgt, $I10
    if $I11, rx178_fail
    dec $I10
    is_cclass $I11, 8192, rx178_tgt, $I10
    unless $I11, rx178_fail
.annotate 'line', 104
  # rx subrule "panic" subtype=method negate=
    rx178_cur."!cursor_pos"(rx178_pos)
    $P10 = rx178_cur."panic"("Obsolete pod format, please use =begin/=end instead")
    unless $P10, rx178_fail
    rx178_pos = $P10."pos"()
    set_addr $I10, rxquantr182_done
    (rx178_rep) = rx178_cur."!mark_commit"($I10)
  rxquantr182_done:
.annotate 'line', 101
    goto alt181_end
  alt181_1:
.annotate 'line', 105
  # rx charclass nl
    ge rx178_pos, rx178_eos, rx178_fail
    sub $I10, rx178_pos, rx178_off
    is_cclass $I11, 4096, rx178_tgt, $I10
    unless $I11, rx178_fail
    substr $S10, rx178_tgt, $I10, 2
    iseq $I11, $S10, "\r\n"
    add rx178_pos, $I11
    inc rx178_pos
  alt181_end:
.annotate 'line', 101
  # rx pass
    rx178_cur."!cursor_pass"(rx178_pos, "")
    if_null rx178_debug, debug_632
    rx178_cur."!cursor_debug"("PASS", "", " at pos=", rx178_pos)
  debug_632:
    .return (rx178_cur)
  rx178_restart:
    if_null rx178_debug, debug_633
    rx178_cur."!cursor_debug"("NEXT", "")
  debug_633:
  rx178_fail:
    (rx178_rep, rx178_pos, $I10, $P10) = rx178_cur."!mark_fail"(0)
    lt rx178_pos, -1, rx178_done
    eq rx178_pos, -1, rx178_fail
    jump $I10
  rx178_done:
    rx178_cur."!cursor_fail"()
    if_null rx178_debug, debug_634
    rx178_cur."!cursor_debug"("FAIL", "")
  debug_634:
    .return (rx178_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "comp_unit"  :subid("30_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 116
    new $P185, "Undef"
    .lex "$*HAS_YOU_ARE_HERE", $P185
.annotate 'line', 117
    new $P186, "Undef"
    .lex "$*MAIN_SUB", $P186
.annotate 'line', 10
    .local string rx187_tgt
    .local int rx187_pos
    .local int rx187_off
    .local int rx187_eos
    .local int rx187_rep
    .local pmc rx187_cur
    .local pmc rx187_debug
    (rx187_cur, rx187_pos, rx187_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx187_cur
    .local pmc match
    .lex "$/", match
    length rx187_eos, rx187_tgt
    gt rx187_pos, rx187_eos, rx187_done
    set rx187_off, 0
    lt rx187_pos, 2, rx187_start
    sub rx187_off, rx187_pos, 1
    substr rx187_tgt, rx187_tgt, rx187_off
  rx187_start:
    eq $I10, 1, rx187_restart
    if_null rx187_debug, debug_638
    rx187_cur."!cursor_debug"("START", "comp_unit")
  debug_638:
    $I10 = self.'from'()
    ne $I10, -1, rxscan191_done
    goto rxscan191_scan
  rxscan191_loop:
    (rx187_pos) = rx187_cur."from"()
    inc rx187_pos
    rx187_cur."!cursor_from"(rx187_pos)
    ge rx187_pos, rx187_eos, rxscan191_done
  rxscan191_scan:
    set_addr $I10, rxscan191_loop
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  rxscan191_done:
.annotate 'line', 116
    rx187_cur."!cursor_pos"(rx187_pos)
    new $P192, "Integer"
    assign $P192, 0
    store_lex "$*HAS_YOU_ARE_HERE", $P192
.annotate 'line', 117
    rx187_cur."!cursor_pos"(rx187_pos)
    find_lex $P193, "$*MAIN_SUB"
    unless_null $P193, vivify_639
    get_hll_global $P193, "$MAIN_SUB"
    unless_null $P193, vivify_640
    die "Contextual $*MAIN_SUB not found"
  vivify_640:
  vivify_639:
.annotate 'line', 118
  # rx subrule "newpad" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."newpad"()
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
.annotate 'line', 119
  # rx subrule "outerctx" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."outerctx"()
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
.annotate 'line', 120
  # rx subrule "statementlist" subtype=capture negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."statementlist"()
    unless $P10, rx187_fail
    rx187_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx187_pos = $P10."pos"()
  alt194_0:
.annotate 'line', 121
    set_addr $I10, alt194_1
    rx187_cur."!mark_push"(0, rx187_pos, $I10)
  # rxanchor eos
    ne rx187_pos, rx187_eos, rx187_fail
    goto alt194_end
  alt194_1:
  # rx subrule "panic" subtype=method negate=
    rx187_cur."!cursor_pos"(rx187_pos)
    $P10 = rx187_cur."panic"("Confused")
    unless $P10, rx187_fail
    rx187_pos = $P10."pos"()
  alt194_end:
.annotate 'line', 115
  # rx pass
    rx187_cur."!cursor_pass"(rx187_pos, "comp_unit")
    if_null rx187_debug, debug_641
    rx187_cur."!cursor_debug"("PASS", "comp_unit", " at pos=", rx187_pos)
  debug_641:
    .return (rx187_cur)
  rx187_restart:
.annotate 'line', 10
    if_null rx187_debug, debug_642
    rx187_cur."!cursor_debug"("NEXT", "comp_unit")
  debug_642:
  rx187_fail:
    (rx187_rep, rx187_pos, $I10, $P10) = rx187_cur."!mark_fail"(0)
    lt rx187_pos, -1, rx187_done
    eq rx187_pos, -1, rx187_fail
    jump $I10
  rx187_done:
    rx187_cur."!cursor_fail"()
    if_null rx187_debug, debug_643
    rx187_cur."!cursor_debug"("FAIL", "comp_unit")
  debug_643:
    .return (rx187_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__comp_unit"  :nsentry("!PREFIX__comp_unit") :subid("31_1300146757.646") :method
.annotate 'line', 10
    $P189 = self."!PREFIX__!subrule"("newpad", "")
    new $P190, "ResizablePMCArray"
    push $P190, $P189
    .return ($P190)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statementlist"  :subid("32_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx196_tgt
    .local int rx196_pos
    .local int rx196_off
    .local int rx196_eos
    .local int rx196_rep
    .local pmc rx196_cur
    .local pmc rx196_debug
    (rx196_cur, rx196_pos, rx196_tgt, $I10) = self."!cursor_start"()
    rx196_cur."!cursor_caparray"("statement")
    .lex unicode:"$\x{a2}", rx196_cur
    .local pmc match
    .lex "$/", match
    length rx196_eos, rx196_tgt
    gt rx196_pos, rx196_eos, rx196_done
    set rx196_off, 0
    lt rx196_pos, 2, rx196_start
    sub rx196_off, rx196_pos, 1
    substr rx196_tgt, rx196_tgt, rx196_off
  rx196_start:
    eq $I10, 1, rx196_restart
    if_null rx196_debug, debug_644
    rx196_cur."!cursor_debug"("START", "statementlist")
  debug_644:
    $I10 = self.'from'()
    ne $I10, -1, rxscan201_done
    goto rxscan201_scan
  rxscan201_loop:
    (rx196_pos) = rx196_cur."from"()
    inc rx196_pos
    rx196_cur."!cursor_from"(rx196_pos)
    ge rx196_pos, rx196_eos, rxscan201_done
  rxscan201_scan:
    set_addr $I10, rxscan201_loop
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxscan201_done:
  alt202_0:
.annotate 'line', 124
    set_addr $I10, alt202_1
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
.annotate 'line', 125
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rxanchor eos
    ne rx196_pos, rx196_eos, rx196_fail
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
    goto alt202_end
  alt202_1:
.annotate 'line', 126
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rx rxquantr206 ** 0..*
    set_addr $I10, rxquantr206_done
    rx196_cur."!mark_push"(0, rx196_pos, $I10)
  rxquantr206_loop:
  # rx subrule "statement" subtype=capture negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."statement"()
    unless $P10, rx196_fail
    rx196_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx196_pos = $P10."pos"()
  # rx subrule "eat_terminator" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."eat_terminator"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
    set_addr $I10, rxquantr206_done
    (rx196_rep) = rx196_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr206_done
    rx196_cur."!mark_push"(rx196_rep, rx196_pos, $I10)
    goto rxquantr206_loop
  rxquantr206_done:
  # rx subrule "ws" subtype=method negate=
    rx196_cur."!cursor_pos"(rx196_pos)
    $P10 = rx196_cur."ws"()
    unless $P10, rx196_fail
    rx196_pos = $P10."pos"()
  alt202_end:
.annotate 'line', 124
  # rx pass
    rx196_cur."!cursor_pass"(rx196_pos, "statementlist")
    if_null rx196_debug, debug_645
    rx196_cur."!cursor_debug"("PASS", "statementlist", " at pos=", rx196_pos)
  debug_645:
    .return (rx196_cur)
  rx196_restart:
.annotate 'line', 10
    if_null rx196_debug, debug_646
    rx196_cur."!cursor_debug"("NEXT", "statementlist")
  debug_646:
  rx196_fail:
    (rx196_rep, rx196_pos, $I10, $P10) = rx196_cur."!mark_fail"(0)
    lt rx196_pos, -1, rx196_done
    eq rx196_pos, -1, rx196_fail
    jump $I10
  rx196_done:
    rx196_cur."!cursor_fail"()
    if_null rx196_debug, debug_647
    rx196_cur."!cursor_debug"("FAIL", "statementlist")
  debug_647:
    .return (rx196_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statementlist"  :nsentry("!PREFIX__statementlist") :subid("33_1300146757.646") :method
.annotate 'line', 10
    $P198 = self."!PREFIX__!subrule"("ws", "")
    $P199 = self."!PREFIX__!subrule"("ws", "")
    new $P200, "ResizablePMCArray"
    push $P200, $P198
    push $P200, $P199
    .return ($P200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement"  :subid("34_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P215 = "36_1300146757.646" 
    capture_lex $P215
    .local string rx210_tgt
    .local int rx210_pos
    .local int rx210_off
    .local int rx210_eos
    .local int rx210_rep
    .local pmc rx210_cur
    .local pmc rx210_debug
    (rx210_cur, rx210_pos, rx210_tgt, $I10) = self."!cursor_start"()
    rx210_cur."!cursor_caparray"("statement_mod_cond", "statement_mod_loop")
    .lex unicode:"$\x{a2}", rx210_cur
    .local pmc match
    .lex "$/", match
    length rx210_eos, rx210_tgt
    gt rx210_pos, rx210_eos, rx210_done
    set rx210_off, 0
    lt rx210_pos, 2, rx210_start
    sub rx210_off, rx210_pos, 1
    substr rx210_tgt, rx210_tgt, rx210_off
  rx210_start:
    eq $I10, 1, rx210_restart
    if_null rx210_debug, debug_648
    rx210_cur."!cursor_debug"("START", "statement")
  debug_648:
    $I10 = self.'from'()
    ne $I10, -1, rxscan213_done
    goto rxscan213_scan
  rxscan213_loop:
    (rx210_pos) = rx210_cur."from"()
    inc rx210_pos
    rx210_cur."!cursor_from"(rx210_pos)
    ge rx210_pos, rx210_eos, rxscan213_done
  rxscan213_scan:
    set_addr $I10, rxscan213_loop
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxscan213_done:
.annotate 'line', 130
  # rx subrule "before" subtype=zerowidth negate=1
    rx210_cur."!cursor_pos"(rx210_pos)
    .const 'Sub' $P215 = "36_1300146757.646" 
    capture_lex $P215
    $P10 = rx210_cur."before"($P215)
    if $P10, rx210_fail
  alt219_0:
.annotate 'line', 131
    set_addr $I10, alt219_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 132
  # rx subrule "statement_control" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_control"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_control")
    rx210_pos = $P10."pos"()
    goto alt219_end
  alt219_1:
.annotate 'line', 133
  # rx subrule "EXPR" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."EXPR"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx210_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."ws"()
    unless $P10, rx210_fail
    rx210_pos = $P10."pos"()
.annotate 'line', 138
  # rx rxquantr220 ** 0..1
    set_addr $I10, rxquantr220_done
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxquantr220_loop:
  alt221_0:
.annotate 'line', 134
    set_addr $I10, alt221_1
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 135
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."MARKED"("endstmt")
    unless $P10, rx210_fail
    goto alt221_end
  alt221_1:
    set_addr $I10, alt221_2
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
.annotate 'line', 136
  # rx subrule "statement_mod_cond" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_cond"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_cond")
    rx210_pos = $P10."pos"()
  # rx rxquantr222 ** 0..1
    set_addr $I10, rxquantr222_done
    rx210_cur."!mark_push"(0, rx210_pos, $I10)
  rxquantr222_loop:
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_loop"()
    unless $P10, rx210_fail
    goto rxsubrule223_pass
  rxsubrule223_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx210_fail
  rxsubrule223_pass:
    set_addr $I10, rxsubrule223_back
    rx210_cur."!mark_push"(0, rx210_pos, $I10, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx210_pos = $P10."pos"()
    set_addr $I10, rxquantr222_done
    (rx210_rep) = rx210_cur."!mark_commit"($I10)
  rxquantr222_done:
    goto alt221_end
  alt221_2:
.annotate 'line', 137
  # rx subrule "statement_mod_loop" subtype=capture negate=
    rx210_cur."!cursor_pos"(rx210_pos)
    $P10 = rx210_cur."statement_mod_loop"()
    unless $P10, rx210_fail
    rx210_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_mod_loop")
    rx210_pos = $P10."pos"()
  alt221_end:
.annotate 'line', 138
    set_addr $I10, rxquantr220_done
    (rx210_rep) = rx210_cur."!mark_commit"($I10)
  rxquantr220_done:
  alt219_end:
.annotate 'line', 129
  # rx pass
    rx210_cur."!cursor_pass"(rx210_pos, "statement")
    if_null rx210_debug, debug_653
    rx210_cur."!cursor_debug"("PASS", "statement", " at pos=", rx210_pos)
  debug_653:
    .return (rx210_cur)
  rx210_restart:
.annotate 'line', 10
    if_null rx210_debug, debug_654
    rx210_cur."!cursor_debug"("NEXT", "statement")
  debug_654:
  rx210_fail:
    (rx210_rep, rx210_pos, $I10, $P10) = rx210_cur."!mark_fail"(0)
    lt rx210_pos, -1, rx210_done
    eq rx210_pos, -1, rx210_fail
    jump $I10
  rx210_done:
    rx210_cur."!cursor_fail"()
    if_null rx210_debug, debug_655
    rx210_cur."!cursor_debug"("FAIL", "statement")
  debug_655:
    .return (rx210_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement"  :nsentry("!PREFIX__statement") :subid("35_1300146757.646") :method
.annotate 'line', 10
    new $P212, "ResizablePMCArray"
    push $P212, ""
    .return ($P212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block214"  :anon :subid("36_1300146757.646") :method :outer("34_1300146757.646")
.annotate 'line', 130
    .local string rx216_tgt
    .local int rx216_pos
    .local int rx216_off
    .local int rx216_eos
    .local int rx216_rep
    .local pmc rx216_cur
    .local pmc rx216_debug
    (rx216_cur, rx216_pos, rx216_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx216_cur
    .local pmc match
    .lex "$/", match
    length rx216_eos, rx216_tgt
    gt rx216_pos, rx216_eos, rx216_done
    set rx216_off, 0
    lt rx216_pos, 2, rx216_start
    sub rx216_off, rx216_pos, 1
    substr rx216_tgt, rx216_tgt, rx216_off
  rx216_start:
    eq $I10, 1, rx216_restart
    if_null rx216_debug, debug_649
    rx216_cur."!cursor_debug"("START", "")
  debug_649:
    $I10 = self.'from'()
    ne $I10, -1, rxscan217_done
    goto rxscan217_scan
  rxscan217_loop:
    (rx216_pos) = rx216_cur."from"()
    inc rx216_pos
    rx216_cur."!cursor_from"(rx216_pos)
    ge rx216_pos, rx216_eos, rxscan217_done
  rxscan217_scan:
    set_addr $I10, rxscan217_loop
    rx216_cur."!mark_push"(0, rx216_pos, $I10)
  rxscan217_done:
  alt218_0:
    set_addr $I10, alt218_1
    rx216_cur."!mark_push"(0, rx216_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx216_pos, rx216_eos, rx216_fail
    sub $I10, rx216_pos, rx216_off
    substr $S10, rx216_tgt, $I10, 1
    index $I11, "])}", $S10
    lt $I11, 0, rx216_fail
    inc rx216_pos
    goto alt218_end
  alt218_1:
  # rxanchor eos
    ne rx216_pos, rx216_eos, rx216_fail
  alt218_end:
  # rx pass
    rx216_cur."!cursor_pass"(rx216_pos, "")
    if_null rx216_debug, debug_650
    rx216_cur."!cursor_debug"("PASS", "", " at pos=", rx216_pos)
  debug_650:
    .return (rx216_cur)
  rx216_restart:
    if_null rx216_debug, debug_651
    rx216_cur."!cursor_debug"("NEXT", "")
  debug_651:
  rx216_fail:
    (rx216_rep, rx216_pos, $I10, $P10) = rx216_cur."!mark_fail"(0)
    lt rx216_pos, -1, rx216_done
    eq rx216_pos, -1, rx216_fail
    jump $I10
  rx216_done:
    rx216_cur."!cursor_fail"()
    if_null rx216_debug, debug_652
    rx216_cur."!cursor_debug"("FAIL", "")
  debug_652:
    .return (rx216_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "eat_terminator"  :subid("37_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx225_tgt
    .local int rx225_pos
    .local int rx225_off
    .local int rx225_eos
    .local int rx225_rep
    .local pmc rx225_cur
    .local pmc rx225_debug
    (rx225_cur, rx225_pos, rx225_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx225_cur
    .local pmc match
    .lex "$/", match
    length rx225_eos, rx225_tgt
    gt rx225_pos, rx225_eos, rx225_done
    set rx225_off, 0
    lt rx225_pos, 2, rx225_start
    sub rx225_off, rx225_pos, 1
    substr rx225_tgt, rx225_tgt, rx225_off
  rx225_start:
    eq $I10, 1, rx225_restart
    if_null rx225_debug, debug_656
    rx225_cur."!cursor_debug"("START", "eat_terminator")
  debug_656:
    $I10 = self.'from'()
    ne $I10, -1, rxscan228_done
    goto rxscan228_scan
  rxscan228_loop:
    (rx225_pos) = rx225_cur."from"()
    inc rx225_pos
    rx225_cur."!cursor_from"(rx225_pos)
    ge rx225_pos, rx225_eos, rxscan228_done
  rxscan228_scan:
    set_addr $I10, rxscan228_loop
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
  rxscan228_done:
  alt229_0:
.annotate 'line', 142
    set_addr $I10, alt229_1
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 143
  # rx literal  ";"
    add $I11, rx225_pos, 1
    gt $I11, rx225_eos, rx225_fail
    sub $I11, rx225_pos, rx225_off
    ord $I11, rx225_tgt, $I11
    ne $I11, 59, rx225_fail
    add rx225_pos, 1
    goto alt229_end
  alt229_1:
    set_addr $I10, alt229_2
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 144
  # rx subrule "MARKED" subtype=zerowidth negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    $P10 = rx225_cur."MARKED"("endstmt")
    unless $P10, rx225_fail
    goto alt229_end
  alt229_2:
    set_addr $I10, alt229_3
    rx225_cur."!mark_push"(0, rx225_pos, $I10)
.annotate 'line', 145
  # rx subrule "terminator" subtype=zerowidth negate=
    rx225_cur."!cursor_pos"(rx225_pos)
    $P10 = rx225_cur."terminator"()
    unless $P10, rx225_fail
    goto alt229_end
  alt229_3:
.annotate 'line', 146
  # rxanchor eos
    ne rx225_pos, rx225_eos, rx225_fail
  alt229_end:
.annotate 'line', 142
  # rx pass
    rx225_cur."!cursor_pass"(rx225_pos, "eat_terminator")
    if_null rx225_debug, debug_657
    rx225_cur."!cursor_debug"("PASS", "eat_terminator", " at pos=", rx225_pos)
  debug_657:
    .return (rx225_cur)
  rx225_restart:
.annotate 'line', 10
    if_null rx225_debug, debug_658
    rx225_cur."!cursor_debug"("NEXT", "eat_terminator")
  debug_658:
  rx225_fail:
    (rx225_rep, rx225_pos, $I10, $P10) = rx225_cur."!mark_fail"(0)
    lt rx225_pos, -1, rx225_done
    eq rx225_pos, -1, rx225_fail
    jump $I10
  rx225_done:
    rx225_cur."!cursor_fail"()
    if_null rx225_debug, debug_659
    rx225_cur."!cursor_debug"("FAIL", "eat_terminator")
  debug_659:
    .return (rx225_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__eat_terminator"  :nsentry("!PREFIX__eat_terminator") :subid("38_1300146757.646") :method
.annotate 'line', 10
    new $P227, "ResizablePMCArray"
    push $P227, ""
    push $P227, ""
    push $P227, ""
    push $P227, ";"
    .return ($P227)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "xblock"  :subid("39_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx231_tgt
    .local int rx231_pos
    .local int rx231_off
    .local int rx231_eos
    .local int rx231_rep
    .local pmc rx231_cur
    .local pmc rx231_debug
    (rx231_cur, rx231_pos, rx231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx231_cur
    .local pmc match
    .lex "$/", match
    length rx231_eos, rx231_tgt
    gt rx231_pos, rx231_eos, rx231_done
    set rx231_off, 0
    lt rx231_pos, 2, rx231_start
    sub rx231_off, rx231_pos, 1
    substr rx231_tgt, rx231_tgt, rx231_off
  rx231_start:
    eq $I10, 1, rx231_restart
    if_null rx231_debug, debug_660
    rx231_cur."!cursor_debug"("START", "xblock")
  debug_660:
    $I10 = self.'from'()
    ne $I10, -1, rxscan235_done
    goto rxscan235_scan
  rxscan235_loop:
    (rx231_pos) = rx231_cur."from"()
    inc rx231_pos
    rx231_cur."!cursor_from"(rx231_pos)
    ge rx231_pos, rx231_eos, rxscan235_done
  rxscan235_scan:
    set_addr $I10, rxscan235_loop
    rx231_cur."!mark_push"(0, rx231_pos, $I10)
  rxscan235_done:
.annotate 'line', 150
  # rx subrule "EXPR" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."EXPR"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx231_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."ws"()
    unless $P10, rx231_fail
    rx231_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx231_cur."!cursor_pos"(rx231_pos)
    $P10 = rx231_cur."pblock"()
    unless $P10, rx231_fail
    rx231_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx231_pos = $P10."pos"()
.annotate 'line', 149
  # rx pass
    rx231_cur."!cursor_pass"(rx231_pos, "xblock")
    if_null rx231_debug, debug_661
    rx231_cur."!cursor_debug"("PASS", "xblock", " at pos=", rx231_pos)
  debug_661:
    .return (rx231_cur)
  rx231_restart:
.annotate 'line', 10
    if_null rx231_debug, debug_662
    rx231_cur."!cursor_debug"("NEXT", "xblock")
  debug_662:
  rx231_fail:
    (rx231_rep, rx231_pos, $I10, $P10) = rx231_cur."!mark_fail"(0)
    lt rx231_pos, -1, rx231_done
    eq rx231_pos, -1, rx231_fail
    jump $I10
  rx231_done:
    rx231_cur."!cursor_fail"()
    if_null rx231_debug, debug_663
    rx231_cur."!cursor_debug"("FAIL", "xblock")
  debug_663:
    .return (rx231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__xblock"  :nsentry("!PREFIX__xblock") :subid("40_1300146757.646") :method
.annotate 'line', 10
    $P233 = self."!PREFIX__!subrule"("EXPR", "")
    new $P234, "ResizablePMCArray"
    push $P234, $P233
    .return ($P234)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "pblock"  :subid("41_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx237_tgt
    .local int rx237_pos
    .local int rx237_off
    .local int rx237_eos
    .local int rx237_rep
    .local pmc rx237_cur
    .local pmc rx237_debug
    (rx237_cur, rx237_pos, rx237_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx237_cur
    .local pmc match
    .lex "$/", match
    length rx237_eos, rx237_tgt
    gt rx237_pos, rx237_eos, rx237_done
    set rx237_off, 0
    lt rx237_pos, 2, rx237_start
    sub rx237_off, rx237_pos, 1
    substr rx237_tgt, rx237_tgt, rx237_off
  rx237_start:
    eq $I10, 1, rx237_restart
    if_null rx237_debug, debug_664
    rx237_cur."!cursor_debug"("START", "pblock")
  debug_664:
    $I10 = self.'from'()
    ne $I10, -1, rxscan242_done
    goto rxscan242_scan
  rxscan242_loop:
    (rx237_pos) = rx237_cur."from"()
    inc rx237_pos
    rx237_cur."!cursor_from"(rx237_pos)
    ge rx237_pos, rx237_eos, rxscan242_done
  rxscan242_scan:
    set_addr $I10, rxscan242_loop
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
  rxscan242_done:
  alt243_0:
.annotate 'line', 153
    set_addr $I10, alt243_1
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
.annotate 'line', 154
  # rx subrule "lambda" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."lambda"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 155
  # rx subrule "newpad" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."newpad"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 156
  # rx subrule "signature" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."signature"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx237_pos = $P10."pos"()
.annotate 'line', 157
  # rx subrule "blockoid" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."blockoid"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx237_pos = $P10."pos"()
.annotate 'line', 154
    goto alt243_end
  alt243_1:
    set_addr $I10, alt243_2
    rx237_cur."!mark_push"(0, rx237_pos, $I10)
.annotate 'line', 158
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx237_pos, rx237_off
    substr $S10, rx237_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx237_fail
.annotate 'line', 159
  # rx subrule "newpad" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."newpad"()
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
.annotate 'line', 160
  # rx subrule "blockoid" subtype=capture negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."blockoid"()
    unless $P10, rx237_fail
    rx237_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx237_pos = $P10."pos"()
.annotate 'line', 158
    goto alt243_end
  alt243_2:
.annotate 'line', 161
  # rx subrule "panic" subtype=method negate=
    rx237_cur."!cursor_pos"(rx237_pos)
    $P10 = rx237_cur."panic"("Missing block")
    unless $P10, rx237_fail
    rx237_pos = $P10."pos"()
  alt243_end:
.annotate 'line', 153
  # rx pass
    rx237_cur."!cursor_pass"(rx237_pos, "pblock")
    if_null rx237_debug, debug_665
    rx237_cur."!cursor_debug"("PASS", "pblock", " at pos=", rx237_pos)
  debug_665:
    .return (rx237_cur)
  rx237_restart:
.annotate 'line', 10
    if_null rx237_debug, debug_666
    rx237_cur."!cursor_debug"("NEXT", "pblock")
  debug_666:
  rx237_fail:
    (rx237_rep, rx237_pos, $I10, $P10) = rx237_cur."!mark_fail"(0)
    lt rx237_pos, -1, rx237_done
    eq rx237_pos, -1, rx237_fail
    jump $I10
  rx237_done:
    rx237_cur."!cursor_fail"()
    if_null rx237_debug, debug_667
    rx237_cur."!cursor_debug"("FAIL", "pblock")
  debug_667:
    .return (rx237_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__pblock"  :nsentry("!PREFIX__pblock") :subid("42_1300146757.646") :method
.annotate 'line', 10
    $P239 = self."!PREFIX__!subrule"("panic", "")
    $P240 = self."!PREFIX__!subrule"("lambda", "")
    new $P241, "ResizablePMCArray"
    push $P241, $P239
    push $P241, "{"
    push $P241, $P240
    .return ($P241)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "lambda"  :subid("43_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx245_tgt
    .local int rx245_pos
    .local int rx245_off
    .local int rx245_eos
    .local int rx245_rep
    .local pmc rx245_cur
    .local pmc rx245_debug
    (rx245_cur, rx245_pos, rx245_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx245_cur
    .local pmc match
    .lex "$/", match
    length rx245_eos, rx245_tgt
    gt rx245_pos, rx245_eos, rx245_done
    set rx245_off, 0
    lt rx245_pos, 2, rx245_start
    sub rx245_off, rx245_pos, 1
    substr rx245_tgt, rx245_tgt, rx245_off
  rx245_start:
    eq $I10, 1, rx245_restart
    if_null rx245_debug, debug_668
    rx245_cur."!cursor_debug"("START", "lambda")
  debug_668:
    $I10 = self.'from'()
    ne $I10, -1, rxscan248_done
    goto rxscan248_scan
  rxscan248_loop:
    (rx245_pos) = rx245_cur."from"()
    inc rx245_pos
    rx245_cur."!cursor_from"(rx245_pos)
    ge rx245_pos, rx245_eos, rxscan248_done
  rxscan248_scan:
    set_addr $I10, rxscan248_loop
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  rxscan248_done:
  alt249_0:
.annotate 'line', 164
    set_addr $I10, alt249_1
    rx245_cur."!mark_push"(0, rx245_pos, $I10)
  # rx literal  "->"
    add $I11, rx245_pos, 2
    gt $I11, rx245_eos, rx245_fail
    sub $I11, rx245_pos, rx245_off
    substr $S10, rx245_tgt, $I11, 2
    ne $S10, "->", rx245_fail
    add rx245_pos, 2
    goto alt249_end
  alt249_1:
  # rx literal  "<->"
    add $I11, rx245_pos, 3
    gt $I11, rx245_eos, rx245_fail
    sub $I11, rx245_pos, rx245_off
    substr $S10, rx245_tgt, $I11, 3
    ne $S10, "<->", rx245_fail
    add rx245_pos, 3
  alt249_end:
  # rx pass
    rx245_cur."!cursor_pass"(rx245_pos, "lambda")
    if_null rx245_debug, debug_669
    rx245_cur."!cursor_debug"("PASS", "lambda", " at pos=", rx245_pos)
  debug_669:
    .return (rx245_cur)
  rx245_restart:
.annotate 'line', 10
    if_null rx245_debug, debug_670
    rx245_cur."!cursor_debug"("NEXT", "lambda")
  debug_670:
  rx245_fail:
    (rx245_rep, rx245_pos, $I10, $P10) = rx245_cur."!mark_fail"(0)
    lt rx245_pos, -1, rx245_done
    eq rx245_pos, -1, rx245_fail
    jump $I10
  rx245_done:
    rx245_cur."!cursor_fail"()
    if_null rx245_debug, debug_671
    rx245_cur."!cursor_debug"("FAIL", "lambda")
  debug_671:
    .return (rx245_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__lambda"  :nsentry("!PREFIX__lambda") :subid("44_1300146757.646") :method
.annotate 'line', 10
    new $P247, "ResizablePMCArray"
    push $P247, "<->"
    push $P247, "->"
    .return ($P247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "block"  :subid("45_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx251_tgt
    .local int rx251_pos
    .local int rx251_off
    .local int rx251_eos
    .local int rx251_rep
    .local pmc rx251_cur
    .local pmc rx251_debug
    (rx251_cur, rx251_pos, rx251_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx251_cur
    .local pmc match
    .lex "$/", match
    length rx251_eos, rx251_tgt
    gt rx251_pos, rx251_eos, rx251_done
    set rx251_off, 0
    lt rx251_pos, 2, rx251_start
    sub rx251_off, rx251_pos, 1
    substr rx251_tgt, rx251_tgt, rx251_off
  rx251_start:
    eq $I10, 1, rx251_restart
    if_null rx251_debug, debug_672
    rx251_cur."!cursor_debug"("START", "block")
  debug_672:
    $I10 = self.'from'()
    ne $I10, -1, rxscan255_done
    goto rxscan255_scan
  rxscan255_loop:
    (rx251_pos) = rx251_cur."from"()
    inc rx251_pos
    rx251_cur."!cursor_from"(rx251_pos)
    ge rx251_pos, rx251_eos, rxscan255_done
  rxscan255_scan:
    set_addr $I10, rxscan255_loop
    rx251_cur."!mark_push"(0, rx251_pos, $I10)
  rxscan255_done:
  alt256_0:
.annotate 'line', 167
    set_addr $I10, alt256_1
    rx251_cur."!mark_push"(0, rx251_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx251_pos, rx251_off
    substr $S10, rx251_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx251_fail
    goto alt256_end
  alt256_1:
  # rx subrule "panic" subtype=method negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."panic"("Missing block")
    unless $P10, rx251_fail
    rx251_pos = $P10."pos"()
  alt256_end:
.annotate 'line', 168
  # rx subrule "newpad" subtype=method negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."newpad"()
    unless $P10, rx251_fail
    rx251_pos = $P10."pos"()
.annotate 'line', 169
  # rx subrule "blockoid" subtype=capture negate=
    rx251_cur."!cursor_pos"(rx251_pos)
    $P10 = rx251_cur."blockoid"()
    unless $P10, rx251_fail
    rx251_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx251_pos = $P10."pos"()
.annotate 'line', 166
  # rx pass
    rx251_cur."!cursor_pass"(rx251_pos, "block")
    if_null rx251_debug, debug_673
    rx251_cur."!cursor_debug"("PASS", "block", " at pos=", rx251_pos)
  debug_673:
    .return (rx251_cur)
  rx251_restart:
.annotate 'line', 10
    if_null rx251_debug, debug_674
    rx251_cur."!cursor_debug"("NEXT", "block")
  debug_674:
  rx251_fail:
    (rx251_rep, rx251_pos, $I10, $P10) = rx251_cur."!mark_fail"(0)
    lt rx251_pos, -1, rx251_done
    eq rx251_pos, -1, rx251_fail
    jump $I10
  rx251_done:
    rx251_cur."!cursor_fail"()
    if_null rx251_debug, debug_675
    rx251_cur."!cursor_debug"("FAIL", "block")
  debug_675:
    .return (rx251_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__block"  :nsentry("!PREFIX__block") :subid("46_1300146757.646") :method
.annotate 'line', 10
    $P253 = self."!PREFIX__!subrule"("panic", "")
    new $P254, "ResizablePMCArray"
    push $P254, $P253
    push $P254, "{"
    .return ($P254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blockoid"  :subid("47_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx258_tgt
    .local int rx258_pos
    .local int rx258_off
    .local int rx258_eos
    .local int rx258_rep
    .local pmc rx258_cur
    .local pmc rx258_debug
    (rx258_cur, rx258_pos, rx258_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx258_cur
    .local pmc match
    .lex "$/", match
    length rx258_eos, rx258_tgt
    gt rx258_pos, rx258_eos, rx258_done
    set rx258_off, 0
    lt rx258_pos, 2, rx258_start
    sub rx258_off, rx258_pos, 1
    substr rx258_tgt, rx258_tgt, rx258_off
  rx258_start:
    eq $I10, 1, rx258_restart
    if_null rx258_debug, debug_676
    rx258_cur."!cursor_debug"("START", "blockoid")
  debug_676:
    $I10 = self.'from'()
    ne $I10, -1, rxscan262_done
    goto rxscan262_scan
  rxscan262_loop:
    (rx258_pos) = rx258_cur."from"()
    inc rx258_pos
    rx258_cur."!cursor_from"(rx258_pos)
    ge rx258_pos, rx258_eos, rxscan262_done
  rxscan262_scan:
    set_addr $I10, rxscan262_loop
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  rxscan262_done:
.annotate 'line', 173
  # rx subrule "finishpad" subtype=method negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."finishpad"()
    unless $P10, rx258_fail
    rx258_pos = $P10."pos"()
  alt263_0:
.annotate 'line', 174
    set_addr $I10, alt263_1
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
.annotate 'line', 175
  # rx literal  "{YOU_ARE_HERE}"
    add $I11, rx258_pos, 14
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    substr $S10, rx258_tgt, $I11, 14
    ne $S10, "{YOU_ARE_HERE}", rx258_fail
    add rx258_pos, 14
  # rx subrule "you_are_here" subtype=capture negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."you_are_here"()
    unless $P10, rx258_fail
    rx258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("you_are_here")
    rx258_pos = $P10."pos"()
    goto alt263_end
  alt263_1:
.annotate 'line', 176
  # rx literal  "{"
    add $I11, rx258_pos, 1
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    ord $I11, rx258_tgt, $I11
    ne $I11, 123, rx258_fail
    add rx258_pos, 1
  # rx subrule "statementlist" subtype=capture negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."statementlist"()
    unless $P10, rx258_fail
    rx258_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statementlist")
    rx258_pos = $P10."pos"()
  alt264_0:
    set_addr $I10, alt264_1
    rx258_cur."!mark_push"(0, rx258_pos, $I10)
  # rx literal  "}"
    add $I11, rx258_pos, 1
    gt $I11, rx258_eos, rx258_fail
    sub $I11, rx258_pos, rx258_off
    ord $I11, rx258_tgt, $I11
    ne $I11, 125, rx258_fail
    add rx258_pos, 1
    goto alt264_end
  alt264_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."FAILGOAL"("'}'")
    unless $P10, rx258_fail
    goto rxsubrule266_pass
  rxsubrule266_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx258_fail
  rxsubrule266_pass:
    set_addr $I10, rxsubrule266_back
    rx258_cur."!mark_push"(0, rx258_pos, $I10, $P10)
    rx258_pos = $P10."pos"()
  alt264_end:
  alt263_end:
.annotate 'line', 178
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx258_cur."!cursor_pos"(rx258_pos)
    $P10 = rx258_cur."ENDSTMT"()
    unless $P10, rx258_fail
.annotate 'line', 172
  # rx pass
    rx258_cur."!cursor_pass"(rx258_pos, "blockoid")
    if_null rx258_debug, debug_677
    rx258_cur."!cursor_debug"("PASS", "blockoid", " at pos=", rx258_pos)
  debug_677:
    .return (rx258_cur)
  rx258_restart:
.annotate 'line', 10
    if_null rx258_debug, debug_678
    rx258_cur."!cursor_debug"("NEXT", "blockoid")
  debug_678:
  rx258_fail:
    (rx258_rep, rx258_pos, $I10, $P10) = rx258_cur."!mark_fail"(0)
    lt rx258_pos, -1, rx258_done
    eq rx258_pos, -1, rx258_fail
    jump $I10
  rx258_done:
    rx258_cur."!cursor_fail"()
    if_null rx258_debug, debug_679
    rx258_cur."!cursor_debug"("FAIL", "blockoid")
  debug_679:
    .return (rx258_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blockoid"  :nsentry("!PREFIX__blockoid") :subid("48_1300146757.646") :method
.annotate 'line', 10
    $P260 = self."!PREFIX__!subrule"("finishpad", "")
    new $P261, "ResizablePMCArray"
    push $P261, $P260
    .return ($P261)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "newpad"  :subid("49_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx268_tgt
    .local int rx268_pos
    .local int rx268_off
    .local int rx268_eos
    .local int rx268_rep
    .local pmc rx268_cur
    .local pmc rx268_debug
    (rx268_cur, rx268_pos, rx268_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx268_cur
    .local pmc match
    .lex "$/", match
    length rx268_eos, rx268_tgt
    gt rx268_pos, rx268_eos, rx268_done
    set rx268_off, 0
    lt rx268_pos, 2, rx268_start
    sub rx268_off, rx268_pos, 1
    substr rx268_tgt, rx268_tgt, rx268_off
  rx268_start:
    eq $I10, 1, rx268_restart
    if_null rx268_debug, debug_680
    rx268_cur."!cursor_debug"("START", "newpad")
  debug_680:
    $I10 = self.'from'()
    ne $I10, -1, rxscan271_done
    goto rxscan271_scan
  rxscan271_loop:
    (rx268_pos) = rx268_cur."from"()
    inc rx268_pos
    rx268_cur."!cursor_from"(rx268_pos)
    ge rx268_pos, rx268_eos, rxscan271_done
  rxscan271_scan:
    set_addr $I10, rxscan271_loop
    rx268_cur."!mark_push"(0, rx268_pos, $I10)
  rxscan271_done:
.annotate 'line', 181
  # rx pass
    rx268_cur."!cursor_pass"(rx268_pos, "newpad")
    if_null rx268_debug, debug_681
    rx268_cur."!cursor_debug"("PASS", "newpad", " at pos=", rx268_pos)
  debug_681:
    .return (rx268_cur)
  rx268_restart:
.annotate 'line', 10
    if_null rx268_debug, debug_682
    rx268_cur."!cursor_debug"("NEXT", "newpad")
  debug_682:
  rx268_fail:
    (rx268_rep, rx268_pos, $I10, $P10) = rx268_cur."!mark_fail"(0)
    lt rx268_pos, -1, rx268_done
    eq rx268_pos, -1, rx268_fail
    jump $I10
  rx268_done:
    rx268_cur."!cursor_fail"()
    if_null rx268_debug, debug_683
    rx268_cur."!cursor_debug"("FAIL", "newpad")
  debug_683:
    .return (rx268_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__newpad"  :nsentry("!PREFIX__newpad") :subid("50_1300146757.646") :method
.annotate 'line', 10
    new $P270, "ResizablePMCArray"
    push $P270, ""
    .return ($P270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "outerctx"  :subid("51_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx273_tgt
    .local int rx273_pos
    .local int rx273_off
    .local int rx273_eos
    .local int rx273_rep
    .local pmc rx273_cur
    .local pmc rx273_debug
    (rx273_cur, rx273_pos, rx273_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx273_cur
    .local pmc match
    .lex "$/", match
    length rx273_eos, rx273_tgt
    gt rx273_pos, rx273_eos, rx273_done
    set rx273_off, 0
    lt rx273_pos, 2, rx273_start
    sub rx273_off, rx273_pos, 1
    substr rx273_tgt, rx273_tgt, rx273_off
  rx273_start:
    eq $I10, 1, rx273_restart
    if_null rx273_debug, debug_684
    rx273_cur."!cursor_debug"("START", "outerctx")
  debug_684:
    $I10 = self.'from'()
    ne $I10, -1, rxscan276_done
    goto rxscan276_scan
  rxscan276_loop:
    (rx273_pos) = rx273_cur."from"()
    inc rx273_pos
    rx273_cur."!cursor_from"(rx273_pos)
    ge rx273_pos, rx273_eos, rxscan276_done
  rxscan276_scan:
    set_addr $I10, rxscan276_loop
    rx273_cur."!mark_push"(0, rx273_pos, $I10)
  rxscan276_done:
.annotate 'line', 182
  # rx pass
    rx273_cur."!cursor_pass"(rx273_pos, "outerctx")
    if_null rx273_debug, debug_685
    rx273_cur."!cursor_debug"("PASS", "outerctx", " at pos=", rx273_pos)
  debug_685:
    .return (rx273_cur)
  rx273_restart:
.annotate 'line', 10
    if_null rx273_debug, debug_686
    rx273_cur."!cursor_debug"("NEXT", "outerctx")
  debug_686:
  rx273_fail:
    (rx273_rep, rx273_pos, $I10, $P10) = rx273_cur."!mark_fail"(0)
    lt rx273_pos, -1, rx273_done
    eq rx273_pos, -1, rx273_fail
    jump $I10
  rx273_done:
    rx273_cur."!cursor_fail"()
    if_null rx273_debug, debug_687
    rx273_cur."!cursor_debug"("FAIL", "outerctx")
  debug_687:
    .return (rx273_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__outerctx"  :nsentry("!PREFIX__outerctx") :subid("52_1300146757.646") :method
.annotate 'line', 10
    new $P275, "ResizablePMCArray"
    push $P275, ""
    .return ($P275)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "finishpad"  :subid("53_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx278_tgt
    .local int rx278_pos
    .local int rx278_off
    .local int rx278_eos
    .local int rx278_rep
    .local pmc rx278_cur
    .local pmc rx278_debug
    (rx278_cur, rx278_pos, rx278_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx278_cur
    .local pmc match
    .lex "$/", match
    length rx278_eos, rx278_tgt
    gt rx278_pos, rx278_eos, rx278_done
    set rx278_off, 0
    lt rx278_pos, 2, rx278_start
    sub rx278_off, rx278_pos, 1
    substr rx278_tgt, rx278_tgt, rx278_off
  rx278_start:
    eq $I10, 1, rx278_restart
    if_null rx278_debug, debug_688
    rx278_cur."!cursor_debug"("START", "finishpad")
  debug_688:
    $I10 = self.'from'()
    ne $I10, -1, rxscan281_done
    goto rxscan281_scan
  rxscan281_loop:
    (rx278_pos) = rx278_cur."from"()
    inc rx278_pos
    rx278_cur."!cursor_from"(rx278_pos)
    ge rx278_pos, rx278_eos, rxscan281_done
  rxscan281_scan:
    set_addr $I10, rxscan281_loop
    rx278_cur."!mark_push"(0, rx278_pos, $I10)
  rxscan281_done:
.annotate 'line', 183
  # rx pass
    rx278_cur."!cursor_pass"(rx278_pos, "finishpad")
    if_null rx278_debug, debug_689
    rx278_cur."!cursor_debug"("PASS", "finishpad", " at pos=", rx278_pos)
  debug_689:
    .return (rx278_cur)
  rx278_restart:
.annotate 'line', 10
    if_null rx278_debug, debug_690
    rx278_cur."!cursor_debug"("NEXT", "finishpad")
  debug_690:
  rx278_fail:
    (rx278_rep, rx278_pos, $I10, $P10) = rx278_cur."!mark_fail"(0)
    lt rx278_pos, -1, rx278_done
    eq rx278_pos, -1, rx278_fail
    jump $I10
  rx278_done:
    rx278_cur."!cursor_fail"()
    if_null rx278_debug, debug_691
    rx278_cur."!cursor_debug"("FAIL", "finishpad")
  debug_691:
    .return (rx278_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__finishpad"  :nsentry("!PREFIX__finishpad") :subid("54_1300146757.646") :method
.annotate 'line', 10
    new $P280, "ResizablePMCArray"
    push $P280, ""
    .return ($P280)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "you_are_here"  :subid("55_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx283_tgt
    .local int rx283_pos
    .local int rx283_off
    .local int rx283_eos
    .local int rx283_rep
    .local pmc rx283_cur
    .local pmc rx283_debug
    (rx283_cur, rx283_pos, rx283_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx283_cur
    .local pmc match
    .lex "$/", match
    length rx283_eos, rx283_tgt
    gt rx283_pos, rx283_eos, rx283_done
    set rx283_off, 0
    lt rx283_pos, 2, rx283_start
    sub rx283_off, rx283_pos, 1
    substr rx283_tgt, rx283_tgt, rx283_off
  rx283_start:
    eq $I10, 1, rx283_restart
    if_null rx283_debug, debug_692
    rx283_cur."!cursor_debug"("START", "you_are_here")
  debug_692:
    $I10 = self.'from'()
    ne $I10, -1, rxscan286_done
    goto rxscan286_scan
  rxscan286_loop:
    (rx283_pos) = rx283_cur."from"()
    inc rx283_pos
    rx283_cur."!cursor_from"(rx283_pos)
    ge rx283_pos, rx283_eos, rxscan286_done
  rxscan286_scan:
    set_addr $I10, rxscan286_loop
    rx283_cur."!mark_push"(0, rx283_pos, $I10)
  rxscan286_done:
.annotate 'line', 184
  # rx pass
    rx283_cur."!cursor_pass"(rx283_pos, "you_are_here")
    if_null rx283_debug, debug_693
    rx283_cur."!cursor_debug"("PASS", "you_are_here", " at pos=", rx283_pos)
  debug_693:
    .return (rx283_cur)
  rx283_restart:
.annotate 'line', 10
    if_null rx283_debug, debug_694
    rx283_cur."!cursor_debug"("NEXT", "you_are_here")
  debug_694:
  rx283_fail:
    (rx283_rep, rx283_pos, $I10, $P10) = rx283_cur."!mark_fail"(0)
    lt rx283_pos, -1, rx283_done
    eq rx283_pos, -1, rx283_fail
    jump $I10
  rx283_done:
    rx283_cur."!cursor_fail"()
    if_null rx283_debug, debug_695
    rx283_cur."!cursor_debug"("FAIL", "you_are_here")
  debug_695:
    .return (rx283_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__you_are_here"  :nsentry("!PREFIX__you_are_here") :subid("56_1300146757.646") :method
.annotate 'line', 10
    new $P285, "ResizablePMCArray"
    push $P285, ""
    .return ($P285)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator"  :subid("57_1300146757.646")
    .param pmc param_288
.annotate 'line', 186
    .lex "self", param_288
    $P289 = param_288."!protoregex"("terminator")
    .return ($P289)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator"  :subid("58_1300146757.646")
    .param pmc param_291
.annotate 'line', 186
    .lex "self", param_291
    $P292 = param_291."!PREFIX__!protoregex"("terminator")
    .return ($P292)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<;>"  :subid("59_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx294_tgt
    .local int rx294_pos
    .local int rx294_off
    .local int rx294_eos
    .local int rx294_rep
    .local pmc rx294_cur
    .local pmc rx294_debug
    (rx294_cur, rx294_pos, rx294_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx294_cur
    .local pmc match
    .lex "$/", match
    length rx294_eos, rx294_tgt
    gt rx294_pos, rx294_eos, rx294_done
    set rx294_off, 0
    lt rx294_pos, 2, rx294_start
    sub rx294_off, rx294_pos, 1
    substr rx294_tgt, rx294_tgt, rx294_off
  rx294_start:
    eq $I10, 1, rx294_restart
    if_null rx294_debug, debug_696
    rx294_cur."!cursor_debug"("START", "terminator:sym<;>")
  debug_696:
    $I10 = self.'from'()
    ne $I10, -1, rxscan297_done
    goto rxscan297_scan
  rxscan297_loop:
    (rx294_pos) = rx294_cur."from"()
    inc rx294_pos
    rx294_cur."!cursor_from"(rx294_pos)
    ge rx294_pos, rx294_eos, rxscan297_done
  rxscan297_scan:
    set_addr $I10, rxscan297_loop
    rx294_cur."!mark_push"(0, rx294_pos, $I10)
  rxscan297_done:
.annotate 'line', 188
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx294_pos, rx294_off
    substr $S10, rx294_tgt, $I10, 1
    index $I11, ";", $S10
    lt $I11, 0, rx294_fail
  # rx pass
    rx294_cur."!cursor_pass"(rx294_pos, "terminator:sym<;>")
    if_null rx294_debug, debug_697
    rx294_cur."!cursor_debug"("PASS", "terminator:sym<;>", " at pos=", rx294_pos)
  debug_697:
    .return (rx294_cur)
  rx294_restart:
.annotate 'line', 10
    if_null rx294_debug, debug_698
    rx294_cur."!cursor_debug"("NEXT", "terminator:sym<;>")
  debug_698:
  rx294_fail:
    (rx294_rep, rx294_pos, $I10, $P10) = rx294_cur."!mark_fail"(0)
    lt rx294_pos, -1, rx294_done
    eq rx294_pos, -1, rx294_fail
    jump $I10
  rx294_done:
    rx294_cur."!cursor_fail"()
    if_null rx294_debug, debug_699
    rx294_cur."!cursor_debug"("FAIL", "terminator:sym<;>")
  debug_699:
    .return (rx294_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<;>"  :nsentry("!PREFIX__terminator:sym<;>") :subid("60_1300146757.646") :method
.annotate 'line', 10
    new $P296, "ResizablePMCArray"
    push $P296, ";"
    .return ($P296)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "terminator:sym<}>"  :subid("61_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx299_tgt
    .local int rx299_pos
    .local int rx299_off
    .local int rx299_eos
    .local int rx299_rep
    .local pmc rx299_cur
    .local pmc rx299_debug
    (rx299_cur, rx299_pos, rx299_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx299_cur
    .local pmc match
    .lex "$/", match
    length rx299_eos, rx299_tgt
    gt rx299_pos, rx299_eos, rx299_done
    set rx299_off, 0
    lt rx299_pos, 2, rx299_start
    sub rx299_off, rx299_pos, 1
    substr rx299_tgt, rx299_tgt, rx299_off
  rx299_start:
    eq $I10, 1, rx299_restart
    if_null rx299_debug, debug_700
    rx299_cur."!cursor_debug"("START", "terminator:sym<}>")
  debug_700:
    $I10 = self.'from'()
    ne $I10, -1, rxscan302_done
    goto rxscan302_scan
  rxscan302_loop:
    (rx299_pos) = rx299_cur."from"()
    inc rx299_pos
    rx299_cur."!cursor_from"(rx299_pos)
    ge rx299_pos, rx299_eos, rxscan302_done
  rxscan302_scan:
    set_addr $I10, rxscan302_loop
    rx299_cur."!mark_push"(0, rx299_pos, $I10)
  rxscan302_done:
.annotate 'line', 189
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx299_pos, rx299_off
    substr $S10, rx299_tgt, $I10, 1
    index $I11, "}", $S10
    lt $I11, 0, rx299_fail
  # rx pass
    rx299_cur."!cursor_pass"(rx299_pos, "terminator:sym<}>")
    if_null rx299_debug, debug_701
    rx299_cur."!cursor_debug"("PASS", "terminator:sym<}>", " at pos=", rx299_pos)
  debug_701:
    .return (rx299_cur)
  rx299_restart:
.annotate 'line', 10
    if_null rx299_debug, debug_702
    rx299_cur."!cursor_debug"("NEXT", "terminator:sym<}>")
  debug_702:
  rx299_fail:
    (rx299_rep, rx299_pos, $I10, $P10) = rx299_cur."!mark_fail"(0)
    lt rx299_pos, -1, rx299_done
    eq rx299_pos, -1, rx299_fail
    jump $I10
  rx299_done:
    rx299_cur."!cursor_fail"()
    if_null rx299_debug, debug_703
    rx299_cur."!cursor_debug"("FAIL", "terminator:sym<}>")
  debug_703:
    .return (rx299_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__terminator:sym<}>"  :nsentry("!PREFIX__terminator:sym<}>") :subid("62_1300146757.646") :method
.annotate 'line', 10
    new $P301, "ResizablePMCArray"
    push $P301, "}"
    .return ($P301)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control"  :subid("63_1300146757.646")
    .param pmc param_304
.annotate 'line', 193
    .lex "self", param_304
    $P305 = param_304."!protoregex"("statement_control")
    .return ($P305)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control"  :subid("64_1300146757.646")
    .param pmc param_307
.annotate 'line', 193
    .lex "self", param_307
    $P308 = param_307."!PREFIX__!protoregex"("statement_control")
    .return ($P308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<use>"  :subid("65_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx310_tgt
    .local int rx310_pos
    .local int rx310_off
    .local int rx310_eos
    .local int rx310_rep
    .local pmc rx310_cur
    .local pmc rx310_debug
    (rx310_cur, rx310_pos, rx310_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx310_cur
    .local pmc match
    .lex "$/", match
    length rx310_eos, rx310_tgt
    gt rx310_pos, rx310_eos, rx310_done
    set rx310_off, 0
    lt rx310_pos, 2, rx310_start
    sub rx310_off, rx310_pos, 1
    substr rx310_tgt, rx310_tgt, rx310_off
  rx310_start:
    eq $I10, 1, rx310_restart
    if_null rx310_debug, debug_704
    rx310_cur."!cursor_debug"("START", "statement_control:sym<use>")
  debug_704:
    $I10 = self.'from'()
    ne $I10, -1, rxscan313_done
    goto rxscan313_scan
  rxscan313_loop:
    (rx310_pos) = rx310_cur."from"()
    inc rx310_pos
    rx310_cur."!cursor_from"(rx310_pos)
    ge rx310_pos, rx310_eos, rxscan313_done
  rxscan313_scan:
    set_addr $I10, rxscan313_loop
    rx310_cur."!mark_push"(0, rx310_pos, $I10)
  rxscan313_done:
.annotate 'line', 196
  # rx subcapture "sym"
    set_addr $I10, rxcap_314_fail
    rx310_cur."!mark_push"(0, rx310_pos, $I10)
  # rx literal  "use"
    add $I11, rx310_pos, 3
    gt $I11, rx310_eos, rx310_fail
    sub $I11, rx310_pos, rx310_off
    substr $S10, rx310_tgt, $I11, 3
    ne $S10, "use", rx310_fail
    add rx310_pos, 3
    set_addr $I10, rxcap_314_fail
    ($I12, $I11) = rx310_cur."!mark_peek"($I10)
    rx310_cur."!cursor_pos"($I11)
    ($P10) = rx310_cur."!cursor_start"()
    $P10."!cursor_pass"(rx310_pos, "")
    rx310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_314_done
  rxcap_314_fail:
    goto rx310_fail
  rxcap_314_done:
  # rx charclass s
    ge rx310_pos, rx310_eos, rx310_fail
    sub $I10, rx310_pos, rx310_off
    is_cclass $I11, 32, rx310_tgt, $I10
    unless $I11, rx310_fail
    inc rx310_pos
  # rx subrule "ws" subtype=method negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."ws"()
    unless $P10, rx310_fail
    rx310_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."name"()
    unless $P10, rx310_fail
    rx310_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx310_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx310_cur."!cursor_pos"(rx310_pos)
    $P10 = rx310_cur."ws"()
    unless $P10, rx310_fail
    rx310_pos = $P10."pos"()
.annotate 'line', 195
  # rx pass
    rx310_cur."!cursor_pass"(rx310_pos, "statement_control:sym<use>")
    if_null rx310_debug, debug_705
    rx310_cur."!cursor_debug"("PASS", "statement_control:sym<use>", " at pos=", rx310_pos)
  debug_705:
    .return (rx310_cur)
  rx310_restart:
.annotate 'line', 10
    if_null rx310_debug, debug_706
    rx310_cur."!cursor_debug"("NEXT", "statement_control:sym<use>")
  debug_706:
  rx310_fail:
    (rx310_rep, rx310_pos, $I10, $P10) = rx310_cur."!mark_fail"(0)
    lt rx310_pos, -1, rx310_done
    eq rx310_pos, -1, rx310_fail
    jump $I10
  rx310_done:
    rx310_cur."!cursor_fail"()
    if_null rx310_debug, debug_707
    rx310_cur."!cursor_debug"("FAIL", "statement_control:sym<use>")
  debug_707:
    .return (rx310_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<use>"  :nsentry("!PREFIX__statement_control:sym<use>") :subid("66_1300146757.646") :method
.annotate 'line', 10
    new $P312, "ResizablePMCArray"
    push $P312, "use"
    .return ($P312)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<if>"  :subid("67_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx318_tgt
    .local int rx318_pos
    .local int rx318_off
    .local int rx318_eos
    .local int rx318_rep
    .local pmc rx318_cur
    .local pmc rx318_debug
    (rx318_cur, rx318_pos, rx318_tgt, $I10) = self."!cursor_start"()
    rx318_cur."!cursor_caparray"("xblock", "else")
    .lex unicode:"$\x{a2}", rx318_cur
    .local pmc match
    .lex "$/", match
    length rx318_eos, rx318_tgt
    gt rx318_pos, rx318_eos, rx318_done
    set rx318_off, 0
    lt rx318_pos, 2, rx318_start
    sub rx318_off, rx318_pos, 1
    substr rx318_tgt, rx318_tgt, rx318_off
  rx318_start:
    eq $I10, 1, rx318_restart
    if_null rx318_debug, debug_708
    rx318_cur."!cursor_debug"("START", "statement_control:sym<if>")
  debug_708:
    $I10 = self.'from'()
    ne $I10, -1, rxscan321_done
    goto rxscan321_scan
  rxscan321_loop:
    (rx318_pos) = rx318_cur."from"()
    inc rx318_pos
    rx318_cur."!cursor_from"(rx318_pos)
    ge rx318_pos, rx318_eos, rxscan321_done
  rxscan321_scan:
    set_addr $I10, rxscan321_loop
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxscan321_done:
.annotate 'line', 200
  # rx subcapture "sym"
    set_addr $I10, rxcap_322_fail
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  # rx literal  "if"
    add $I11, rx318_pos, 2
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 2
    ne $S10, "if", rx318_fail
    add rx318_pos, 2
    set_addr $I10, rxcap_322_fail
    ($I12, $I11) = rx318_cur."!mark_peek"($I10)
    rx318_cur."!cursor_pos"($I11)
    ($P10) = rx318_cur."!cursor_start"()
    $P10."!cursor_pass"(rx318_pos, "")
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_322_done
  rxcap_322_fail:
    goto rx318_fail
  rxcap_322_done:
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 201
  # rx subrule "xblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."xblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 202
  # rx rxquantr325 ** 0..*
    set_addr $I10, rxquantr325_done
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxquantr325_loop:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx literal  "elsif"
    add $I11, rx318_pos, 5
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 5
    ne $S10, "elsif", rx318_fail
    add rx318_pos, 5
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."xblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
    set_addr $I10, rxquantr325_done
    (rx318_rep) = rx318_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr325_done
    rx318_cur."!mark_push"(rx318_rep, rx318_pos, $I10)
    goto rxquantr325_loop
  rxquantr325_done:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 203
  # rx rxquantr330 ** 0..1
    set_addr $I10, rxquantr330_done
    rx318_cur."!mark_push"(0, rx318_pos, $I10)
  rxquantr330_loop:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx literal  "else"
    add $I11, rx318_pos, 4
    gt $I11, rx318_eos, rx318_fail
    sub $I11, rx318_pos, rx318_off
    substr $S10, rx318_tgt, $I11, 4
    ne $S10, "else", rx318_fail
    add rx318_pos, 4
  # rx charclass s
    ge rx318_pos, rx318_eos, rx318_fail
    sub $I10, rx318_pos, rx318_off
    is_cclass $I11, 32, rx318_tgt, $I10
    unless $I11, rx318_fail
    inc rx318_pos
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."pblock"()
    unless $P10, rx318_fail
    rx318_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("else")
    rx318_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
    set_addr $I10, rxquantr330_done
    (rx318_rep) = rx318_cur."!mark_commit"($I10)
  rxquantr330_done:
  # rx subrule "ws" subtype=method negate=
    rx318_cur."!cursor_pos"(rx318_pos)
    $P10 = rx318_cur."ws"()
    unless $P10, rx318_fail
    rx318_pos = $P10."pos"()
.annotate 'line', 199
  # rx pass
    rx318_cur."!cursor_pass"(rx318_pos, "statement_control:sym<if>")
    if_null rx318_debug, debug_709
    rx318_cur."!cursor_debug"("PASS", "statement_control:sym<if>", " at pos=", rx318_pos)
  debug_709:
    .return (rx318_cur)
  rx318_restart:
.annotate 'line', 10
    if_null rx318_debug, debug_710
    rx318_cur."!cursor_debug"("NEXT", "statement_control:sym<if>")
  debug_710:
  rx318_fail:
    (rx318_rep, rx318_pos, $I10, $P10) = rx318_cur."!mark_fail"(0)
    lt rx318_pos, -1, rx318_done
    eq rx318_pos, -1, rx318_fail
    jump $I10
  rx318_done:
    rx318_cur."!cursor_fail"()
    if_null rx318_debug, debug_711
    rx318_cur."!cursor_debug"("FAIL", "statement_control:sym<if>")
  debug_711:
    .return (rx318_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<if>"  :nsentry("!PREFIX__statement_control:sym<if>") :subid("68_1300146757.646") :method
.annotate 'line', 10
    new $P320, "ResizablePMCArray"
    push $P320, "if"
    .return ($P320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<unless>"  :subid("69_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P346 = "71_1300146757.646" 
    capture_lex $P346
    .local string rx336_tgt
    .local int rx336_pos
    .local int rx336_off
    .local int rx336_eos
    .local int rx336_rep
    .local pmc rx336_cur
    .local pmc rx336_debug
    (rx336_cur, rx336_pos, rx336_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx336_cur
    .local pmc match
    .lex "$/", match
    length rx336_eos, rx336_tgt
    gt rx336_pos, rx336_eos, rx336_done
    set rx336_off, 0
    lt rx336_pos, 2, rx336_start
    sub rx336_off, rx336_pos, 1
    substr rx336_tgt, rx336_tgt, rx336_off
  rx336_start:
    eq $I10, 1, rx336_restart
    if_null rx336_debug, debug_712
    rx336_cur."!cursor_debug"("START", "statement_control:sym<unless>")
  debug_712:
    $I10 = self.'from'()
    ne $I10, -1, rxscan339_done
    goto rxscan339_scan
  rxscan339_loop:
    (rx336_pos) = rx336_cur."from"()
    inc rx336_pos
    rx336_cur."!cursor_from"(rx336_pos)
    ge rx336_pos, rx336_eos, rxscan339_done
  rxscan339_scan:
    set_addr $I10, rxscan339_loop
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  rxscan339_done:
.annotate 'line', 207
  # rx subcapture "sym"
    set_addr $I10, rxcap_340_fail
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx literal  "unless"
    add $I11, rx336_pos, 6
    gt $I11, rx336_eos, rx336_fail
    sub $I11, rx336_pos, rx336_off
    substr $S10, rx336_tgt, $I11, 6
    ne $S10, "unless", rx336_fail
    add rx336_pos, 6
    set_addr $I10, rxcap_340_fail
    ($I12, $I11) = rx336_cur."!mark_peek"($I10)
    rx336_cur."!cursor_pos"($I11)
    ($P10) = rx336_cur."!cursor_start"()
    $P10."!cursor_pass"(rx336_pos, "")
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_340_done
  rxcap_340_fail:
    goto rx336_fail
  rxcap_340_done:
  # rx charclass s
    ge rx336_pos, rx336_eos, rx336_fail
    sub $I10, rx336_pos, rx336_off
    is_cclass $I11, 32, rx336_tgt, $I10
    unless $I11, rx336_fail
    inc rx336_pos
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
.annotate 'line', 208
  # rx subrule "xblock" subtype=capture negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."xblock"()
    unless $P10, rx336_fail
    rx336_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  alt343_0:
.annotate 'line', 209
    set_addr $I10, alt343_1
    rx336_cur."!mark_push"(0, rx336_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "before" subtype=zerowidth negate=1
    rx336_cur."!cursor_pos"(rx336_pos)
    .const 'Sub' $P346 = "71_1300146757.646" 
    capture_lex $P346
    $P10 = rx336_cur."before"($P346)
    if $P10, rx336_fail
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
    goto alt343_end
  alt343_1:
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."panic"("unless does not take \"else\", please rewrite using \"if\"")
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
  alt343_end:
  # rx subrule "ws" subtype=method negate=
    rx336_cur."!cursor_pos"(rx336_pos)
    $P10 = rx336_cur."ws"()
    unless $P10, rx336_fail
    rx336_pos = $P10."pos"()
.annotate 'line', 206
  # rx pass
    rx336_cur."!cursor_pass"(rx336_pos, "statement_control:sym<unless>")
    if_null rx336_debug, debug_717
    rx336_cur."!cursor_debug"("PASS", "statement_control:sym<unless>", " at pos=", rx336_pos)
  debug_717:
    .return (rx336_cur)
  rx336_restart:
.annotate 'line', 10
    if_null rx336_debug, debug_718
    rx336_cur."!cursor_debug"("NEXT", "statement_control:sym<unless>")
  debug_718:
  rx336_fail:
    (rx336_rep, rx336_pos, $I10, $P10) = rx336_cur."!mark_fail"(0)
    lt rx336_pos, -1, rx336_done
    eq rx336_pos, -1, rx336_fail
    jump $I10
  rx336_done:
    rx336_cur."!cursor_fail"()
    if_null rx336_debug, debug_719
    rx336_cur."!cursor_debug"("FAIL", "statement_control:sym<unless>")
  debug_719:
    .return (rx336_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<unless>"  :nsentry("!PREFIX__statement_control:sym<unless>") :subid("70_1300146757.646") :method
.annotate 'line', 10
    new $P338, "ResizablePMCArray"
    push $P338, "unless"
    .return ($P338)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block345"  :anon :subid("71_1300146757.646") :method :outer("69_1300146757.646")
.annotate 'line', 209
    .local string rx347_tgt
    .local int rx347_pos
    .local int rx347_off
    .local int rx347_eos
    .local int rx347_rep
    .local pmc rx347_cur
    .local pmc rx347_debug
    (rx347_cur, rx347_pos, rx347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx347_cur
    .local pmc match
    .lex "$/", match
    length rx347_eos, rx347_tgt
    gt rx347_pos, rx347_eos, rx347_done
    set rx347_off, 0
    lt rx347_pos, 2, rx347_start
    sub rx347_off, rx347_pos, 1
    substr rx347_tgt, rx347_tgt, rx347_off
  rx347_start:
    eq $I10, 1, rx347_restart
    if_null rx347_debug, debug_713
    rx347_cur."!cursor_debug"("START", "")
  debug_713:
    $I10 = self.'from'()
    ne $I10, -1, rxscan348_done
    goto rxscan348_scan
  rxscan348_loop:
    (rx347_pos) = rx347_cur."from"()
    inc rx347_pos
    rx347_cur."!cursor_from"(rx347_pos)
    ge rx347_pos, rx347_eos, rxscan348_done
  rxscan348_scan:
    set_addr $I10, rxscan348_loop
    rx347_cur."!mark_push"(0, rx347_pos, $I10)
  rxscan348_done:
  # rx literal  "else"
    add $I11, rx347_pos, 4
    gt $I11, rx347_eos, rx347_fail
    sub $I11, rx347_pos, rx347_off
    substr $S10, rx347_tgt, $I11, 4
    ne $S10, "else", rx347_fail
    add rx347_pos, 4
  # rx pass
    rx347_cur."!cursor_pass"(rx347_pos, "")
    if_null rx347_debug, debug_714
    rx347_cur."!cursor_debug"("PASS", "", " at pos=", rx347_pos)
  debug_714:
    .return (rx347_cur)
  rx347_restart:
    if_null rx347_debug, debug_715
    rx347_cur."!cursor_debug"("NEXT", "")
  debug_715:
  rx347_fail:
    (rx347_rep, rx347_pos, $I10, $P10) = rx347_cur."!mark_fail"(0)
    lt rx347_pos, -1, rx347_done
    eq rx347_pos, -1, rx347_fail
    jump $I10
  rx347_done:
    rx347_cur."!cursor_fail"()
    if_null rx347_debug, debug_716
    rx347_cur."!cursor_debug"("FAIL", "")
  debug_716:
    .return (rx347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<while>"  :subid("72_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx354_tgt
    .local int rx354_pos
    .local int rx354_off
    .local int rx354_eos
    .local int rx354_rep
    .local pmc rx354_cur
    .local pmc rx354_debug
    (rx354_cur, rx354_pos, rx354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx354_cur
    .local pmc match
    .lex "$/", match
    length rx354_eos, rx354_tgt
    gt rx354_pos, rx354_eos, rx354_done
    set rx354_off, 0
    lt rx354_pos, 2, rx354_start
    sub rx354_off, rx354_pos, 1
    substr rx354_tgt, rx354_tgt, rx354_off
  rx354_start:
    eq $I10, 1, rx354_restart
    if_null rx354_debug, debug_720
    rx354_cur."!cursor_debug"("START", "statement_control:sym<while>")
  debug_720:
    $I10 = self.'from'()
    ne $I10, -1, rxscan357_done
    goto rxscan357_scan
  rxscan357_loop:
    (rx354_pos) = rx354_cur."from"()
    inc rx354_pos
    rx354_cur."!cursor_from"(rx354_pos)
    ge rx354_pos, rx354_eos, rxscan357_done
  rxscan357_scan:
    set_addr $I10, rxscan357_loop
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  rxscan357_done:
.annotate 'line', 213
  # rx subcapture "sym"
    set_addr $I10, rxcap_359_fail
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  alt358_0:
    set_addr $I10, alt358_1
    rx354_cur."!mark_push"(0, rx354_pos, $I10)
  # rx literal  "while"
    add $I11, rx354_pos, 5
    gt $I11, rx354_eos, rx354_fail
    sub $I11, rx354_pos, rx354_off
    substr $S10, rx354_tgt, $I11, 5
    ne $S10, "while", rx354_fail
    add rx354_pos, 5
    goto alt358_end
  alt358_1:
  # rx literal  "until"
    add $I11, rx354_pos, 5
    gt $I11, rx354_eos, rx354_fail
    sub $I11, rx354_pos, rx354_off
    substr $S10, rx354_tgt, $I11, 5
    ne $S10, "until", rx354_fail
    add rx354_pos, 5
  alt358_end:
    set_addr $I10, rxcap_359_fail
    ($I12, $I11) = rx354_cur."!mark_peek"($I10)
    rx354_cur."!cursor_pos"($I11)
    ($P10) = rx354_cur."!cursor_start"()
    $P10."!cursor_pass"(rx354_pos, "")
    rx354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_359_done
  rxcap_359_fail:
    goto rx354_fail
  rxcap_359_done:
  # rx charclass s
    ge rx354_pos, rx354_eos, rx354_fail
    sub $I10, rx354_pos, rx354_off
    is_cclass $I11, 32, rx354_tgt, $I10
    unless $I11, rx354_fail
    inc rx354_pos
  # rx subrule "ws" subtype=method negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."ws"()
    unless $P10, rx354_fail
    rx354_pos = $P10."pos"()
.annotate 'line', 214
  # rx subrule "xblock" subtype=capture negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."xblock"()
    unless $P10, rx354_fail
    rx354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx354_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx354_cur."!cursor_pos"(rx354_pos)
    $P10 = rx354_cur."ws"()
    unless $P10, rx354_fail
    rx354_pos = $P10."pos"()
.annotate 'line', 212
  # rx pass
    rx354_cur."!cursor_pass"(rx354_pos, "statement_control:sym<while>")
    if_null rx354_debug, debug_721
    rx354_cur."!cursor_debug"("PASS", "statement_control:sym<while>", " at pos=", rx354_pos)
  debug_721:
    .return (rx354_cur)
  rx354_restart:
.annotate 'line', 10
    if_null rx354_debug, debug_722
    rx354_cur."!cursor_debug"("NEXT", "statement_control:sym<while>")
  debug_722:
  rx354_fail:
    (rx354_rep, rx354_pos, $I10, $P10) = rx354_cur."!mark_fail"(0)
    lt rx354_pos, -1, rx354_done
    eq rx354_pos, -1, rx354_fail
    jump $I10
  rx354_done:
    rx354_cur."!cursor_fail"()
    if_null rx354_debug, debug_723
    rx354_cur."!cursor_debug"("FAIL", "statement_control:sym<while>")
  debug_723:
    .return (rx354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<while>"  :nsentry("!PREFIX__statement_control:sym<while>") :subid("73_1300146757.646") :method
.annotate 'line', 10
    new $P356, "ResizablePMCArray"
    push $P356, "until"
    push $P356, "while"
    .return ($P356)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<repeat>"  :subid("74_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx363_tgt
    .local int rx363_pos
    .local int rx363_off
    .local int rx363_eos
    .local int rx363_rep
    .local pmc rx363_cur
    .local pmc rx363_debug
    (rx363_cur, rx363_pos, rx363_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx363_cur
    .local pmc match
    .lex "$/", match
    length rx363_eos, rx363_tgt
    gt rx363_pos, rx363_eos, rx363_done
    set rx363_off, 0
    lt rx363_pos, 2, rx363_start
    sub rx363_off, rx363_pos, 1
    substr rx363_tgt, rx363_tgt, rx363_off
  rx363_start:
    eq $I10, 1, rx363_restart
    if_null rx363_debug, debug_724
    rx363_cur."!cursor_debug"("START", "statement_control:sym<repeat>")
  debug_724:
    $I10 = self.'from'()
    ne $I10, -1, rxscan366_done
    goto rxscan366_scan
  rxscan366_loop:
    (rx363_pos) = rx363_cur."from"()
    inc rx363_pos
    rx363_cur."!cursor_from"(rx363_pos)
    ge rx363_pos, rx363_eos, rxscan366_done
  rxscan366_scan:
    set_addr $I10, rxscan366_loop
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  rxscan366_done:
.annotate 'line', 218
  # rx subcapture "sym"
    set_addr $I10, rxcap_367_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "repeat"
    add $I11, rx363_pos, 6
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 6
    ne $S10, "repeat", rx363_fail
    add rx363_pos, 6
    set_addr $I10, rxcap_367_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_367_done
  rxcap_367_fail:
    goto rx363_fail
  rxcap_367_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt369_0:
.annotate 'line', 219
    set_addr $I10, alt369_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
.annotate 'line', 220
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_372_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  alt371_0:
    set_addr $I10, alt371_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "while"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "while", rx363_fail
    add rx363_pos, 5
    goto alt371_end
  alt371_1:
  # rx literal  "until"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "until", rx363_fail
    add rx363_pos, 5
  alt371_end:
    set_addr $I10, rxcap_372_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_372_done
  rxcap_372_fail:
    goto rx363_fail
  rxcap_372_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "xblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."xblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
    goto alt369_end
  alt369_1:
.annotate 'line', 221
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "pblock" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."pblock"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subcapture "wu"
    set_addr $I10, rxcap_378_fail
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  alt377_0:
    set_addr $I10, alt377_1
    rx363_cur."!mark_push"(0, rx363_pos, $I10)
  # rx literal  "while"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "while", rx363_fail
    add rx363_pos, 5
    goto alt377_end
  alt377_1:
  # rx literal  "until"
    add $I11, rx363_pos, 5
    gt $I11, rx363_eos, rx363_fail
    sub $I11, rx363_pos, rx363_off
    substr $S10, rx363_tgt, $I11, 5
    ne $S10, "until", rx363_fail
    add rx363_pos, 5
  alt377_end:
    set_addr $I10, rxcap_378_fail
    ($I12, $I11) = rx363_cur."!mark_peek"($I10)
    rx363_cur."!cursor_pos"($I11)
    ($P10) = rx363_cur."!cursor_start"()
    $P10."!cursor_pass"(rx363_pos, "")
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("wu")
    goto rxcap_378_done
  rxcap_378_fail:
    goto rx363_fail
  rxcap_378_done:
  # rx charclass s
    ge rx363_pos, rx363_eos, rx363_fail
    sub $I10, rx363_pos, rx363_off
    is_cclass $I11, 32, rx363_tgt, $I10
    unless $I11, rx363_fail
    inc rx363_pos
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."EXPR"()
    unless $P10, rx363_fail
    rx363_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx363_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
  alt369_end:
.annotate 'line', 222
  # rx subrule "ws" subtype=method negate=
    rx363_cur."!cursor_pos"(rx363_pos)
    $P10 = rx363_cur."ws"()
    unless $P10, rx363_fail
    rx363_pos = $P10."pos"()
.annotate 'line', 217
  # rx pass
    rx363_cur."!cursor_pass"(rx363_pos, "statement_control:sym<repeat>")
    if_null rx363_debug, debug_725
    rx363_cur."!cursor_debug"("PASS", "statement_control:sym<repeat>", " at pos=", rx363_pos)
  debug_725:
    .return (rx363_cur)
  rx363_restart:
.annotate 'line', 10
    if_null rx363_debug, debug_726
    rx363_cur."!cursor_debug"("NEXT", "statement_control:sym<repeat>")
  debug_726:
  rx363_fail:
    (rx363_rep, rx363_pos, $I10, $P10) = rx363_cur."!mark_fail"(0)
    lt rx363_pos, -1, rx363_done
    eq rx363_pos, -1, rx363_fail
    jump $I10
  rx363_done:
    rx363_cur."!cursor_fail"()
    if_null rx363_debug, debug_727
    rx363_cur."!cursor_debug"("FAIL", "statement_control:sym<repeat>")
  debug_727:
    .return (rx363_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<repeat>"  :nsentry("!PREFIX__statement_control:sym<repeat>") :subid("75_1300146757.646") :method
.annotate 'line', 10
    new $P365, "ResizablePMCArray"
    push $P365, "repeat"
    .return ($P365)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<for>"  :subid("76_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx383_tgt
    .local int rx383_pos
    .local int rx383_off
    .local int rx383_eos
    .local int rx383_rep
    .local pmc rx383_cur
    .local pmc rx383_debug
    (rx383_cur, rx383_pos, rx383_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx383_cur
    .local pmc match
    .lex "$/", match
    length rx383_eos, rx383_tgt
    gt rx383_pos, rx383_eos, rx383_done
    set rx383_off, 0
    lt rx383_pos, 2, rx383_start
    sub rx383_off, rx383_pos, 1
    substr rx383_tgt, rx383_tgt, rx383_off
  rx383_start:
    eq $I10, 1, rx383_restart
    if_null rx383_debug, debug_728
    rx383_cur."!cursor_debug"("START", "statement_control:sym<for>")
  debug_728:
    $I10 = self.'from'()
    ne $I10, -1, rxscan386_done
    goto rxscan386_scan
  rxscan386_loop:
    (rx383_pos) = rx383_cur."from"()
    inc rx383_pos
    rx383_cur."!cursor_from"(rx383_pos)
    ge rx383_pos, rx383_eos, rxscan386_done
  rxscan386_scan:
    set_addr $I10, rxscan386_loop
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  rxscan386_done:
.annotate 'line', 226
  # rx subcapture "sym"
    set_addr $I10, rxcap_387_fail
    rx383_cur."!mark_push"(0, rx383_pos, $I10)
  # rx literal  "for"
    add $I11, rx383_pos, 3
    gt $I11, rx383_eos, rx383_fail
    sub $I11, rx383_pos, rx383_off
    substr $S10, rx383_tgt, $I11, 3
    ne $S10, "for", rx383_fail
    add rx383_pos, 3
    set_addr $I10, rxcap_387_fail
    ($I12, $I11) = rx383_cur."!mark_peek"($I10)
    rx383_cur."!cursor_pos"($I11)
    ($P10) = rx383_cur."!cursor_start"()
    $P10."!cursor_pass"(rx383_pos, "")
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_387_done
  rxcap_387_fail:
    goto rx383_fail
  rxcap_387_done:
  # rx charclass s
    ge rx383_pos, rx383_eos, rx383_fail
    sub $I10, rx383_pos, rx383_off
    is_cclass $I11, 32, rx383_tgt, $I10
    unless $I11, rx383_fail
    inc rx383_pos
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 227
  # rx subrule "xblock" subtype=capture negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."xblock"()
    unless $P10, rx383_fail
    rx383_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("xblock")
    rx383_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx383_cur."!cursor_pos"(rx383_pos)
    $P10 = rx383_cur."ws"()
    unless $P10, rx383_fail
    rx383_pos = $P10."pos"()
.annotate 'line', 225
  # rx pass
    rx383_cur."!cursor_pass"(rx383_pos, "statement_control:sym<for>")
    if_null rx383_debug, debug_729
    rx383_cur."!cursor_debug"("PASS", "statement_control:sym<for>", " at pos=", rx383_pos)
  debug_729:
    .return (rx383_cur)
  rx383_restart:
.annotate 'line', 10
    if_null rx383_debug, debug_730
    rx383_cur."!cursor_debug"("NEXT", "statement_control:sym<for>")
  debug_730:
  rx383_fail:
    (rx383_rep, rx383_pos, $I10, $P10) = rx383_cur."!mark_fail"(0)
    lt rx383_pos, -1, rx383_done
    eq rx383_pos, -1, rx383_fail
    jump $I10
  rx383_done:
    rx383_cur."!cursor_fail"()
    if_null rx383_debug, debug_731
    rx383_cur."!cursor_debug"("FAIL", "statement_control:sym<for>")
  debug_731:
    .return (rx383_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<for>"  :nsentry("!PREFIX__statement_control:sym<for>") :subid("77_1300146757.646") :method
.annotate 'line', 10
    new $P385, "ResizablePMCArray"
    push $P385, "for"
    .return ($P385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CATCH>"  :subid("78_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx391_tgt
    .local int rx391_pos
    .local int rx391_off
    .local int rx391_eos
    .local int rx391_rep
    .local pmc rx391_cur
    .local pmc rx391_debug
    (rx391_cur, rx391_pos, rx391_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx391_cur
    .local pmc match
    .lex "$/", match
    length rx391_eos, rx391_tgt
    gt rx391_pos, rx391_eos, rx391_done
    set rx391_off, 0
    lt rx391_pos, 2, rx391_start
    sub rx391_off, rx391_pos, 1
    substr rx391_tgt, rx391_tgt, rx391_off
  rx391_start:
    eq $I10, 1, rx391_restart
    if_null rx391_debug, debug_732
    rx391_cur."!cursor_debug"("START", "statement_control:sym<CATCH>")
  debug_732:
    $I10 = self.'from'()
    ne $I10, -1, rxscan394_done
    goto rxscan394_scan
  rxscan394_loop:
    (rx391_pos) = rx391_cur."from"()
    inc rx391_pos
    rx391_cur."!cursor_from"(rx391_pos)
    ge rx391_pos, rx391_eos, rxscan394_done
  rxscan394_scan:
    set_addr $I10, rxscan394_loop
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  rxscan394_done:
.annotate 'line', 231
  # rx subcapture "sym"
    set_addr $I10, rxcap_395_fail
    rx391_cur."!mark_push"(0, rx391_pos, $I10)
  # rx literal  "CATCH"
    add $I11, rx391_pos, 5
    gt $I11, rx391_eos, rx391_fail
    sub $I11, rx391_pos, rx391_off
    substr $S10, rx391_tgt, $I11, 5
    ne $S10, "CATCH", rx391_fail
    add rx391_pos, 5
    set_addr $I10, rxcap_395_fail
    ($I12, $I11) = rx391_cur."!mark_peek"($I10)
    rx391_cur."!cursor_pos"($I11)
    ($P10) = rx391_cur."!cursor_start"()
    $P10."!cursor_pass"(rx391_pos, "")
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_395_done
  rxcap_395_fail:
    goto rx391_fail
  rxcap_395_done:
  # rx charclass s
    ge rx391_pos, rx391_eos, rx391_fail
    sub $I10, rx391_pos, rx391_off
    is_cclass $I11, 32, rx391_tgt, $I10
    unless $I11, rx391_fail
    inc rx391_pos
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
.annotate 'line', 232
  # rx subrule "block" subtype=capture negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."block"()
    unless $P10, rx391_fail
    rx391_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx391_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx391_cur."!cursor_pos"(rx391_pos)
    $P10 = rx391_cur."ws"()
    unless $P10, rx391_fail
    rx391_pos = $P10."pos"()
.annotate 'line', 230
  # rx pass
    rx391_cur."!cursor_pass"(rx391_pos, "statement_control:sym<CATCH>")
    if_null rx391_debug, debug_733
    rx391_cur."!cursor_debug"("PASS", "statement_control:sym<CATCH>", " at pos=", rx391_pos)
  debug_733:
    .return (rx391_cur)
  rx391_restart:
.annotate 'line', 10
    if_null rx391_debug, debug_734
    rx391_cur."!cursor_debug"("NEXT", "statement_control:sym<CATCH>")
  debug_734:
  rx391_fail:
    (rx391_rep, rx391_pos, $I10, $P10) = rx391_cur."!mark_fail"(0)
    lt rx391_pos, -1, rx391_done
    eq rx391_pos, -1, rx391_fail
    jump $I10
  rx391_done:
    rx391_cur."!cursor_fail"()
    if_null rx391_debug, debug_735
    rx391_cur."!cursor_debug"("FAIL", "statement_control:sym<CATCH>")
  debug_735:
    .return (rx391_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CATCH>"  :nsentry("!PREFIX__statement_control:sym<CATCH>") :subid("79_1300146757.646") :method
.annotate 'line', 10
    new $P393, "ResizablePMCArray"
    push $P393, "CATCH"
    .return ($P393)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_control:sym<CONTROL>"  :subid("80_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx399_tgt
    .local int rx399_pos
    .local int rx399_off
    .local int rx399_eos
    .local int rx399_rep
    .local pmc rx399_cur
    .local pmc rx399_debug
    (rx399_cur, rx399_pos, rx399_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx399_cur
    .local pmc match
    .lex "$/", match
    length rx399_eos, rx399_tgt
    gt rx399_pos, rx399_eos, rx399_done
    set rx399_off, 0
    lt rx399_pos, 2, rx399_start
    sub rx399_off, rx399_pos, 1
    substr rx399_tgt, rx399_tgt, rx399_off
  rx399_start:
    eq $I10, 1, rx399_restart
    if_null rx399_debug, debug_736
    rx399_cur."!cursor_debug"("START", "statement_control:sym<CONTROL>")
  debug_736:
    $I10 = self.'from'()
    ne $I10, -1, rxscan402_done
    goto rxscan402_scan
  rxscan402_loop:
    (rx399_pos) = rx399_cur."from"()
    inc rx399_pos
    rx399_cur."!cursor_from"(rx399_pos)
    ge rx399_pos, rx399_eos, rxscan402_done
  rxscan402_scan:
    set_addr $I10, rxscan402_loop
    rx399_cur."!mark_push"(0, rx399_pos, $I10)
  rxscan402_done:
.annotate 'line', 236
  # rx subcapture "sym"
    set_addr $I10, rxcap_403_fail
    rx399_cur."!mark_push"(0, rx399_pos, $I10)
  # rx literal  "CONTROL"
    add $I11, rx399_pos, 7
    gt $I11, rx399_eos, rx399_fail
    sub $I11, rx399_pos, rx399_off
    substr $S10, rx399_tgt, $I11, 7
    ne $S10, "CONTROL", rx399_fail
    add rx399_pos, 7
    set_addr $I10, rxcap_403_fail
    ($I12, $I11) = rx399_cur."!mark_peek"($I10)
    rx399_cur."!cursor_pos"($I11)
    ($P10) = rx399_cur."!cursor_start"()
    $P10."!cursor_pass"(rx399_pos, "")
    rx399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_403_done
  rxcap_403_fail:
    goto rx399_fail
  rxcap_403_done:
  # rx charclass s
    ge rx399_pos, rx399_eos, rx399_fail
    sub $I10, rx399_pos, rx399_off
    is_cclass $I11, 32, rx399_tgt, $I10
    unless $I11, rx399_fail
    inc rx399_pos
  # rx subrule "ws" subtype=method negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."ws"()
    unless $P10, rx399_fail
    rx399_pos = $P10."pos"()
.annotate 'line', 237
  # rx subrule "block" subtype=capture negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."block"()
    unless $P10, rx399_fail
    rx399_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx399_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx399_cur."!cursor_pos"(rx399_pos)
    $P10 = rx399_cur."ws"()
    unless $P10, rx399_fail
    rx399_pos = $P10."pos"()
.annotate 'line', 235
  # rx pass
    rx399_cur."!cursor_pass"(rx399_pos, "statement_control:sym<CONTROL>")
    if_null rx399_debug, debug_737
    rx399_cur."!cursor_debug"("PASS", "statement_control:sym<CONTROL>", " at pos=", rx399_pos)
  debug_737:
    .return (rx399_cur)
  rx399_restart:
.annotate 'line', 10
    if_null rx399_debug, debug_738
    rx399_cur."!cursor_debug"("NEXT", "statement_control:sym<CONTROL>")
  debug_738:
  rx399_fail:
    (rx399_rep, rx399_pos, $I10, $P10) = rx399_cur."!mark_fail"(0)
    lt rx399_pos, -1, rx399_done
    eq rx399_pos, -1, rx399_fail
    jump $I10
  rx399_done:
    rx399_cur."!cursor_fail"()
    if_null rx399_debug, debug_739
    rx399_cur."!cursor_debug"("FAIL", "statement_control:sym<CONTROL>")
  debug_739:
    .return (rx399_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_control:sym<CONTROL>"  :nsentry("!PREFIX__statement_control:sym<CONTROL>") :subid("81_1300146757.646") :method
.annotate 'line', 10
    new $P401, "ResizablePMCArray"
    push $P401, "CONTROL"
    .return ($P401)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix"  :subid("82_1300146757.646")
    .param pmc param_407
.annotate 'line', 240
    .lex "self", param_407
    $P408 = param_407."!protoregex"("statement_prefix")
    .return ($P408)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix"  :subid("83_1300146757.646")
    .param pmc param_410
.annotate 'line', 240
    .lex "self", param_410
    $P411 = param_410."!PREFIX__!protoregex"("statement_prefix")
    .return ($P411)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<INIT>"  :subid("84_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx413_tgt
    .local int rx413_pos
    .local int rx413_off
    .local int rx413_eos
    .local int rx413_rep
    .local pmc rx413_cur
    .local pmc rx413_debug
    (rx413_cur, rx413_pos, rx413_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx413_cur
    .local pmc match
    .lex "$/", match
    length rx413_eos, rx413_tgt
    gt rx413_pos, rx413_eos, rx413_done
    set rx413_off, 0
    lt rx413_pos, 2, rx413_start
    sub rx413_off, rx413_pos, 1
    substr rx413_tgt, rx413_tgt, rx413_off
  rx413_start:
    eq $I10, 1, rx413_restart
    if_null rx413_debug, debug_740
    rx413_cur."!cursor_debug"("START", "statement_prefix:sym<INIT>")
  debug_740:
    $I10 = self.'from'()
    ne $I10, -1, rxscan417_done
    goto rxscan417_scan
  rxscan417_loop:
    (rx413_pos) = rx413_cur."from"()
    inc rx413_pos
    rx413_cur."!cursor_from"(rx413_pos)
    ge rx413_pos, rx413_eos, rxscan417_done
  rxscan417_scan:
    set_addr $I10, rxscan417_loop
    rx413_cur."!mark_push"(0, rx413_pos, $I10)
  rxscan417_done:
.annotate 'line', 241
  # rx subcapture "sym"
    set_addr $I10, rxcap_418_fail
    rx413_cur."!mark_push"(0, rx413_pos, $I10)
  # rx literal  "INIT"
    add $I11, rx413_pos, 4
    gt $I11, rx413_eos, rx413_fail
    sub $I11, rx413_pos, rx413_off
    substr $S10, rx413_tgt, $I11, 4
    ne $S10, "INIT", rx413_fail
    add rx413_pos, 4
    set_addr $I10, rxcap_418_fail
    ($I12, $I11) = rx413_cur."!mark_peek"($I10)
    rx413_cur."!cursor_pos"($I11)
    ($P10) = rx413_cur."!cursor_start"()
    $P10."!cursor_pass"(rx413_pos, "")
    rx413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_418_done
  rxcap_418_fail:
    goto rx413_fail
  rxcap_418_done:
  # rx subrule "blorst" subtype=capture negate=
    rx413_cur."!cursor_pos"(rx413_pos)
    $P10 = rx413_cur."blorst"()
    unless $P10, rx413_fail
    rx413_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx413_pos = $P10."pos"()
  # rx pass
    rx413_cur."!cursor_pass"(rx413_pos, "statement_prefix:sym<INIT>")
    if_null rx413_debug, debug_741
    rx413_cur."!cursor_debug"("PASS", "statement_prefix:sym<INIT>", " at pos=", rx413_pos)
  debug_741:
    .return (rx413_cur)
  rx413_restart:
.annotate 'line', 10
    if_null rx413_debug, debug_742
    rx413_cur."!cursor_debug"("NEXT", "statement_prefix:sym<INIT>")
  debug_742:
  rx413_fail:
    (rx413_rep, rx413_pos, $I10, $P10) = rx413_cur."!mark_fail"(0)
    lt rx413_pos, -1, rx413_done
    eq rx413_pos, -1, rx413_fail
    jump $I10
  rx413_done:
    rx413_cur."!cursor_fail"()
    if_null rx413_debug, debug_743
    rx413_cur."!cursor_debug"("FAIL", "statement_prefix:sym<INIT>")
  debug_743:
    .return (rx413_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<INIT>"  :nsentry("!PREFIX__statement_prefix:sym<INIT>") :subid("85_1300146757.646") :method
.annotate 'line', 10
    $P415 = self."!PREFIX__!subrule"("blorst", "INIT")
    new $P416, "ResizablePMCArray"
    push $P416, $P415
    .return ($P416)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_prefix:sym<try>"  :subid("86_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx420_tgt
    .local int rx420_pos
    .local int rx420_off
    .local int rx420_eos
    .local int rx420_rep
    .local pmc rx420_cur
    .local pmc rx420_debug
    (rx420_cur, rx420_pos, rx420_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx420_cur
    .local pmc match
    .lex "$/", match
    length rx420_eos, rx420_tgt
    gt rx420_pos, rx420_eos, rx420_done
    set rx420_off, 0
    lt rx420_pos, 2, rx420_start
    sub rx420_off, rx420_pos, 1
    substr rx420_tgt, rx420_tgt, rx420_off
  rx420_start:
    eq $I10, 1, rx420_restart
    if_null rx420_debug, debug_744
    rx420_cur."!cursor_debug"("START", "statement_prefix:sym<try>")
  debug_744:
    $I10 = self.'from'()
    ne $I10, -1, rxscan424_done
    goto rxscan424_scan
  rxscan424_loop:
    (rx420_pos) = rx420_cur."from"()
    inc rx420_pos
    rx420_cur."!cursor_from"(rx420_pos)
    ge rx420_pos, rx420_eos, rxscan424_done
  rxscan424_scan:
    set_addr $I10, rxscan424_loop
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  rxscan424_done:
.annotate 'line', 244
  # rx subcapture "sym"
    set_addr $I10, rxcap_425_fail
    rx420_cur."!mark_push"(0, rx420_pos, $I10)
  # rx literal  "try"
    add $I11, rx420_pos, 3
    gt $I11, rx420_eos, rx420_fail
    sub $I11, rx420_pos, rx420_off
    substr $S10, rx420_tgt, $I11, 3
    ne $S10, "try", rx420_fail
    add rx420_pos, 3
    set_addr $I10, rxcap_425_fail
    ($I12, $I11) = rx420_cur."!mark_peek"($I10)
    rx420_cur."!cursor_pos"($I11)
    ($P10) = rx420_cur."!cursor_start"()
    $P10."!cursor_pass"(rx420_pos, "")
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_425_done
  rxcap_425_fail:
    goto rx420_fail
  rxcap_425_done:
.annotate 'line', 245
  # rx subrule "blorst" subtype=capture negate=
    rx420_cur."!cursor_pos"(rx420_pos)
    $P10 = rx420_cur."blorst"()
    unless $P10, rx420_fail
    rx420_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blorst")
    rx420_pos = $P10."pos"()
.annotate 'line', 243
  # rx pass
    rx420_cur."!cursor_pass"(rx420_pos, "statement_prefix:sym<try>")
    if_null rx420_debug, debug_745
    rx420_cur."!cursor_debug"("PASS", "statement_prefix:sym<try>", " at pos=", rx420_pos)
  debug_745:
    .return (rx420_cur)
  rx420_restart:
.annotate 'line', 10
    if_null rx420_debug, debug_746
    rx420_cur."!cursor_debug"("NEXT", "statement_prefix:sym<try>")
  debug_746:
  rx420_fail:
    (rx420_rep, rx420_pos, $I10, $P10) = rx420_cur."!mark_fail"(0)
    lt rx420_pos, -1, rx420_done
    eq rx420_pos, -1, rx420_fail
    jump $I10
  rx420_done:
    rx420_cur."!cursor_fail"()
    if_null rx420_debug, debug_747
    rx420_cur."!cursor_debug"("FAIL", "statement_prefix:sym<try>")
  debug_747:
    .return (rx420_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_prefix:sym<try>"  :nsentry("!PREFIX__statement_prefix:sym<try>") :subid("87_1300146757.646") :method
.annotate 'line', 10
    $P422 = self."!PREFIX__!subrule"("blorst", "try")
    new $P423, "ResizablePMCArray"
    push $P423, $P422
    .return ($P423)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "blorst"  :subid("88_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx427_tgt
    .local int rx427_pos
    .local int rx427_off
    .local int rx427_eos
    .local int rx427_rep
    .local pmc rx427_cur
    .local pmc rx427_debug
    (rx427_cur, rx427_pos, rx427_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx427_cur
    .local pmc match
    .lex "$/", match
    length rx427_eos, rx427_tgt
    gt rx427_pos, rx427_eos, rx427_done
    set rx427_off, 0
    lt rx427_pos, 2, rx427_start
    sub rx427_off, rx427_pos, 1
    substr rx427_tgt, rx427_tgt, rx427_off
  rx427_start:
    eq $I10, 1, rx427_restart
    if_null rx427_debug, debug_748
    rx427_cur."!cursor_debug"("START", "blorst")
  debug_748:
    $I10 = self.'from'()
    ne $I10, -1, rxscan430_done
    goto rxscan430_scan
  rxscan430_loop:
    (rx427_pos) = rx427_cur."from"()
    inc rx427_pos
    rx427_cur."!cursor_from"(rx427_pos)
    ge rx427_pos, rx427_eos, rxscan430_done
  rxscan430_scan:
    set_addr $I10, rxscan430_loop
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  rxscan430_done:
.annotate 'line', 249
  # rx charclass s
    ge rx427_pos, rx427_eos, rx427_fail
    sub $I10, rx427_pos, rx427_off
    is_cclass $I11, 32, rx427_tgt, $I10
    unless $I11, rx427_fail
    inc rx427_pos
  # rx subrule "ws" subtype=method negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."ws"()
    unless $P10, rx427_fail
    rx427_pos = $P10."pos"()
  alt431_0:
    set_addr $I10, alt431_1
    rx427_cur."!mark_push"(0, rx427_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx427_pos, rx427_off
    substr $S10, rx427_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx427_fail
  # rx subrule "block" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."block"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx427_pos = $P10."pos"()
    goto alt431_end
  alt431_1:
  # rx subrule "statement" subtype=capture negate=
    rx427_cur."!cursor_pos"(rx427_pos)
    $P10 = rx427_cur."statement"()
    unless $P10, rx427_fail
    rx427_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx427_pos = $P10."pos"()
  alt431_end:
.annotate 'line', 248
  # rx pass
    rx427_cur."!cursor_pass"(rx427_pos, "blorst")
    if_null rx427_debug, debug_749
    rx427_cur."!cursor_debug"("PASS", "blorst", " at pos=", rx427_pos)
  debug_749:
    .return (rx427_cur)
  rx427_restart:
.annotate 'line', 10
    if_null rx427_debug, debug_750
    rx427_cur."!cursor_debug"("NEXT", "blorst")
  debug_750:
  rx427_fail:
    (rx427_rep, rx427_pos, $I10, $P10) = rx427_cur."!mark_fail"(0)
    lt rx427_pos, -1, rx427_done
    eq rx427_pos, -1, rx427_fail
    jump $I10
  rx427_done:
    rx427_cur."!cursor_fail"()
    if_null rx427_debug, debug_751
    rx427_cur."!cursor_debug"("FAIL", "blorst")
  debug_751:
    .return (rx427_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__blorst"  :nsentry("!PREFIX__blorst") :subid("89_1300146757.646") :method
.annotate 'line', 10
    new $P429, "ResizablePMCArray"
    push $P429, ""
    .return ($P429)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond"  :subid("90_1300146757.646")
    .param pmc param_433
.annotate 'line', 254
    .lex "self", param_433
    $P434 = param_433."!protoregex"("statement_mod_cond")
    .return ($P434)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond"  :subid("91_1300146757.646")
    .param pmc param_436
.annotate 'line', 254
    .lex "self", param_436
    $P437 = param_436."!PREFIX__!protoregex"("statement_mod_cond")
    .return ($P437)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<if>"  :subid("92_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx439_tgt
    .local int rx439_pos
    .local int rx439_off
    .local int rx439_eos
    .local int rx439_rep
    .local pmc rx439_cur
    .local pmc rx439_debug
    (rx439_cur, rx439_pos, rx439_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx439_cur
    .local pmc match
    .lex "$/", match
    length rx439_eos, rx439_tgt
    gt rx439_pos, rx439_eos, rx439_done
    set rx439_off, 0
    lt rx439_pos, 2, rx439_start
    sub rx439_off, rx439_pos, 1
    substr rx439_tgt, rx439_tgt, rx439_off
  rx439_start:
    eq $I10, 1, rx439_restart
    if_null rx439_debug, debug_752
    rx439_cur."!cursor_debug"("START", "statement_mod_cond:sym<if>")
  debug_752:
    $I10 = self.'from'()
    ne $I10, -1, rxscan443_done
    goto rxscan443_scan
  rxscan443_loop:
    (rx439_pos) = rx439_cur."from"()
    inc rx439_pos
    rx439_cur."!cursor_from"(rx439_pos)
    ge rx439_pos, rx439_eos, rxscan443_done
  rxscan443_scan:
    set_addr $I10, rxscan443_loop
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  rxscan443_done:
.annotate 'line', 256
  # rx subcapture "sym"
    set_addr $I10, rxcap_444_fail
    rx439_cur."!mark_push"(0, rx439_pos, $I10)
  # rx literal  "if"
    add $I11, rx439_pos, 2
    gt $I11, rx439_eos, rx439_fail
    sub $I11, rx439_pos, rx439_off
    substr $S10, rx439_tgt, $I11, 2
    ne $S10, "if", rx439_fail
    add rx439_pos, 2
    set_addr $I10, rxcap_444_fail
    ($I12, $I11) = rx439_cur."!mark_peek"($I10)
    rx439_cur."!cursor_pos"($I11)
    ($P10) = rx439_cur."!cursor_start"()
    $P10."!cursor_pass"(rx439_pos, "")
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_444_done
  rxcap_444_fail:
    goto rx439_fail
  rxcap_444_done:
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."EXPR"()
    unless $P10, rx439_fail
    rx439_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx439_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx439_cur."!cursor_pos"(rx439_pos)
    $P10 = rx439_cur."ws"()
    unless $P10, rx439_fail
    rx439_pos = $P10."pos"()
  # rx pass
    rx439_cur."!cursor_pass"(rx439_pos, "statement_mod_cond:sym<if>")
    if_null rx439_debug, debug_753
    rx439_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<if>", " at pos=", rx439_pos)
  debug_753:
    .return (rx439_cur)
  rx439_restart:
.annotate 'line', 10
    if_null rx439_debug, debug_754
    rx439_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<if>")
  debug_754:
  rx439_fail:
    (rx439_rep, rx439_pos, $I10, $P10) = rx439_cur."!mark_fail"(0)
    lt rx439_pos, -1, rx439_done
    eq rx439_pos, -1, rx439_fail
    jump $I10
  rx439_done:
    rx439_cur."!cursor_fail"()
    if_null rx439_debug, debug_755
    rx439_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<if>")
  debug_755:
    .return (rx439_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<if>"  :nsentry("!PREFIX__statement_mod_cond:sym<if>") :subid("93_1300146757.646") :method
.annotate 'line', 10
    $P441 = self."!PREFIX__!subrule"("ws", "if")
    new $P442, "ResizablePMCArray"
    push $P442, $P441
    .return ($P442)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_cond:sym<unless>"  :subid("94_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx448_tgt
    .local int rx448_pos
    .local int rx448_off
    .local int rx448_eos
    .local int rx448_rep
    .local pmc rx448_cur
    .local pmc rx448_debug
    (rx448_cur, rx448_pos, rx448_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx448_cur
    .local pmc match
    .lex "$/", match
    length rx448_eos, rx448_tgt
    gt rx448_pos, rx448_eos, rx448_done
    set rx448_off, 0
    lt rx448_pos, 2, rx448_start
    sub rx448_off, rx448_pos, 1
    substr rx448_tgt, rx448_tgt, rx448_off
  rx448_start:
    eq $I10, 1, rx448_restart
    if_null rx448_debug, debug_756
    rx448_cur."!cursor_debug"("START", "statement_mod_cond:sym<unless>")
  debug_756:
    $I10 = self.'from'()
    ne $I10, -1, rxscan452_done
    goto rxscan452_scan
  rxscan452_loop:
    (rx448_pos) = rx448_cur."from"()
    inc rx448_pos
    rx448_cur."!cursor_from"(rx448_pos)
    ge rx448_pos, rx448_eos, rxscan452_done
  rxscan452_scan:
    set_addr $I10, rxscan452_loop
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  rxscan452_done:
.annotate 'line', 257
  # rx subcapture "sym"
    set_addr $I10, rxcap_453_fail
    rx448_cur."!mark_push"(0, rx448_pos, $I10)
  # rx literal  "unless"
    add $I11, rx448_pos, 6
    gt $I11, rx448_eos, rx448_fail
    sub $I11, rx448_pos, rx448_off
    substr $S10, rx448_tgt, $I11, 6
    ne $S10, "unless", rx448_fail
    add rx448_pos, 6
    set_addr $I10, rxcap_453_fail
    ($I12, $I11) = rx448_cur."!mark_peek"($I10)
    rx448_cur."!cursor_pos"($I11)
    ($P10) = rx448_cur."!cursor_start"()
    $P10."!cursor_pass"(rx448_pos, "")
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_453_done
  rxcap_453_fail:
    goto rx448_fail
  rxcap_453_done:
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."EXPR"()
    unless $P10, rx448_fail
    rx448_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx448_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx448_cur."!cursor_pos"(rx448_pos)
    $P10 = rx448_cur."ws"()
    unless $P10, rx448_fail
    rx448_pos = $P10."pos"()
  # rx pass
    rx448_cur."!cursor_pass"(rx448_pos, "statement_mod_cond:sym<unless>")
    if_null rx448_debug, debug_757
    rx448_cur."!cursor_debug"("PASS", "statement_mod_cond:sym<unless>", " at pos=", rx448_pos)
  debug_757:
    .return (rx448_cur)
  rx448_restart:
.annotate 'line', 10
    if_null rx448_debug, debug_758
    rx448_cur."!cursor_debug"("NEXT", "statement_mod_cond:sym<unless>")
  debug_758:
  rx448_fail:
    (rx448_rep, rx448_pos, $I10, $P10) = rx448_cur."!mark_fail"(0)
    lt rx448_pos, -1, rx448_done
    eq rx448_pos, -1, rx448_fail
    jump $I10
  rx448_done:
    rx448_cur."!cursor_fail"()
    if_null rx448_debug, debug_759
    rx448_cur."!cursor_debug"("FAIL", "statement_mod_cond:sym<unless>")
  debug_759:
    .return (rx448_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_cond:sym<unless>"  :nsentry("!PREFIX__statement_mod_cond:sym<unless>") :subid("95_1300146757.646") :method
.annotate 'line', 10
    $P450 = self."!PREFIX__!subrule"("ws", "unless")
    new $P451, "ResizablePMCArray"
    push $P451, $P450
    .return ($P451)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop"  :subid("96_1300146757.646")
    .param pmc param_457
.annotate 'line', 259
    .lex "self", param_457
    $P458 = param_457."!protoregex"("statement_mod_loop")
    .return ($P458)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop"  :subid("97_1300146757.646")
    .param pmc param_460
.annotate 'line', 259
    .lex "self", param_460
    $P461 = param_460."!PREFIX__!protoregex"("statement_mod_loop")
    .return ($P461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<while>"  :subid("98_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx463_tgt
    .local int rx463_pos
    .local int rx463_off
    .local int rx463_eos
    .local int rx463_rep
    .local pmc rx463_cur
    .local pmc rx463_debug
    (rx463_cur, rx463_pos, rx463_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx463_cur
    .local pmc match
    .lex "$/", match
    length rx463_eos, rx463_tgt
    gt rx463_pos, rx463_eos, rx463_done
    set rx463_off, 0
    lt rx463_pos, 2, rx463_start
    sub rx463_off, rx463_pos, 1
    substr rx463_tgt, rx463_tgt, rx463_off
  rx463_start:
    eq $I10, 1, rx463_restart
    if_null rx463_debug, debug_760
    rx463_cur."!cursor_debug"("START", "statement_mod_loop:sym<while>")
  debug_760:
    $I10 = self.'from'()
    ne $I10, -1, rxscan467_done
    goto rxscan467_scan
  rxscan467_loop:
    (rx463_pos) = rx463_cur."from"()
    inc rx463_pos
    rx463_cur."!cursor_from"(rx463_pos)
    ge rx463_pos, rx463_eos, rxscan467_done
  rxscan467_scan:
    set_addr $I10, rxscan467_loop
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  rxscan467_done:
.annotate 'line', 261
  # rx subcapture "sym"
    set_addr $I10, rxcap_468_fail
    rx463_cur."!mark_push"(0, rx463_pos, $I10)
  # rx literal  "while"
    add $I11, rx463_pos, 5
    gt $I11, rx463_eos, rx463_fail
    sub $I11, rx463_pos, rx463_off
    substr $S10, rx463_tgt, $I11, 5
    ne $S10, "while", rx463_fail
    add rx463_pos, 5
    set_addr $I10, rxcap_468_fail
    ($I12, $I11) = rx463_cur."!mark_peek"($I10)
    rx463_cur."!cursor_pos"($I11)
    ($P10) = rx463_cur."!cursor_start"()
    $P10."!cursor_pass"(rx463_pos, "")
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_468_done
  rxcap_468_fail:
    goto rx463_fail
  rxcap_468_done:
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."EXPR"()
    unless $P10, rx463_fail
    rx463_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx463_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx463_cur."!cursor_pos"(rx463_pos)
    $P10 = rx463_cur."ws"()
    unless $P10, rx463_fail
    rx463_pos = $P10."pos"()
  # rx pass
    rx463_cur."!cursor_pass"(rx463_pos, "statement_mod_loop:sym<while>")
    if_null rx463_debug, debug_761
    rx463_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<while>", " at pos=", rx463_pos)
  debug_761:
    .return (rx463_cur)
  rx463_restart:
.annotate 'line', 10
    if_null rx463_debug, debug_762
    rx463_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<while>")
  debug_762:
  rx463_fail:
    (rx463_rep, rx463_pos, $I10, $P10) = rx463_cur."!mark_fail"(0)
    lt rx463_pos, -1, rx463_done
    eq rx463_pos, -1, rx463_fail
    jump $I10
  rx463_done:
    rx463_cur."!cursor_fail"()
    if_null rx463_debug, debug_763
    rx463_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<while>")
  debug_763:
    .return (rx463_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<while>"  :nsentry("!PREFIX__statement_mod_loop:sym<while>") :subid("99_1300146757.646") :method
.annotate 'line', 10
    $P465 = self."!PREFIX__!subrule"("ws", "while")
    new $P466, "ResizablePMCArray"
    push $P466, $P465
    .return ($P466)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<until>"  :subid("100_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx472_tgt
    .local int rx472_pos
    .local int rx472_off
    .local int rx472_eos
    .local int rx472_rep
    .local pmc rx472_cur
    .local pmc rx472_debug
    (rx472_cur, rx472_pos, rx472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx472_cur
    .local pmc match
    .lex "$/", match
    length rx472_eos, rx472_tgt
    gt rx472_pos, rx472_eos, rx472_done
    set rx472_off, 0
    lt rx472_pos, 2, rx472_start
    sub rx472_off, rx472_pos, 1
    substr rx472_tgt, rx472_tgt, rx472_off
  rx472_start:
    eq $I10, 1, rx472_restart
    if_null rx472_debug, debug_764
    rx472_cur."!cursor_debug"("START", "statement_mod_loop:sym<until>")
  debug_764:
    $I10 = self.'from'()
    ne $I10, -1, rxscan476_done
    goto rxscan476_scan
  rxscan476_loop:
    (rx472_pos) = rx472_cur."from"()
    inc rx472_pos
    rx472_cur."!cursor_from"(rx472_pos)
    ge rx472_pos, rx472_eos, rxscan476_done
  rxscan476_scan:
    set_addr $I10, rxscan476_loop
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  rxscan476_done:
.annotate 'line', 262
  # rx subcapture "sym"
    set_addr $I10, rxcap_477_fail
    rx472_cur."!mark_push"(0, rx472_pos, $I10)
  # rx literal  "until"
    add $I11, rx472_pos, 5
    gt $I11, rx472_eos, rx472_fail
    sub $I11, rx472_pos, rx472_off
    substr $S10, rx472_tgt, $I11, 5
    ne $S10, "until", rx472_fail
    add rx472_pos, 5
    set_addr $I10, rxcap_477_fail
    ($I12, $I11) = rx472_cur."!mark_peek"($I10)
    rx472_cur."!cursor_pos"($I11)
    ($P10) = rx472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx472_pos, "")
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_477_done
  rxcap_477_fail:
    goto rx472_fail
  rxcap_477_done:
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."EXPR"()
    unless $P10, rx472_fail
    rx472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx472_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx472_cur."!cursor_pos"(rx472_pos)
    $P10 = rx472_cur."ws"()
    unless $P10, rx472_fail
    rx472_pos = $P10."pos"()
  # rx pass
    rx472_cur."!cursor_pass"(rx472_pos, "statement_mod_loop:sym<until>")
    if_null rx472_debug, debug_765
    rx472_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<until>", " at pos=", rx472_pos)
  debug_765:
    .return (rx472_cur)
  rx472_restart:
.annotate 'line', 10
    if_null rx472_debug, debug_766
    rx472_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<until>")
  debug_766:
  rx472_fail:
    (rx472_rep, rx472_pos, $I10, $P10) = rx472_cur."!mark_fail"(0)
    lt rx472_pos, -1, rx472_done
    eq rx472_pos, -1, rx472_fail
    jump $I10
  rx472_done:
    rx472_cur."!cursor_fail"()
    if_null rx472_debug, debug_767
    rx472_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<until>")
  debug_767:
    .return (rx472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<until>"  :nsentry("!PREFIX__statement_mod_loop:sym<until>") :subid("101_1300146757.646") :method
.annotate 'line', 10
    $P474 = self."!PREFIX__!subrule"("ws", "until")
    new $P475, "ResizablePMCArray"
    push $P475, $P474
    .return ($P475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "statement_mod_loop:sym<for>"  :subid("102_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx481_tgt
    .local int rx481_pos
    .local int rx481_off
    .local int rx481_eos
    .local int rx481_rep
    .local pmc rx481_cur
    .local pmc rx481_debug
    (rx481_cur, rx481_pos, rx481_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx481_cur
    .local pmc match
    .lex "$/", match
    length rx481_eos, rx481_tgt
    gt rx481_pos, rx481_eos, rx481_done
    set rx481_off, 0
    lt rx481_pos, 2, rx481_start
    sub rx481_off, rx481_pos, 1
    substr rx481_tgt, rx481_tgt, rx481_off
  rx481_start:
    eq $I10, 1, rx481_restart
    if_null rx481_debug, debug_768
    rx481_cur."!cursor_debug"("START", "statement_mod_loop:sym<for>")
  debug_768:
    $I10 = self.'from'()
    ne $I10, -1, rxscan485_done
    goto rxscan485_scan
  rxscan485_loop:
    (rx481_pos) = rx481_cur."from"()
    inc rx481_pos
    rx481_cur."!cursor_from"(rx481_pos)
    ge rx481_pos, rx481_eos, rxscan485_done
  rxscan485_scan:
    set_addr $I10, rxscan485_loop
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  rxscan485_done:
.annotate 'line', 263
  # rx subcapture "sym"
    set_addr $I10, rxcap_486_fail
    rx481_cur."!mark_push"(0, rx481_pos, $I10)
  # rx literal  "for"
    add $I11, rx481_pos, 3
    gt $I11, rx481_eos, rx481_fail
    sub $I11, rx481_pos, rx481_off
    substr $S10, rx481_tgt, $I11, 3
    ne $S10, "for", rx481_fail
    add rx481_pos, 3
    set_addr $I10, rxcap_486_fail
    ($I12, $I11) = rx481_cur."!mark_peek"($I10)
    rx481_cur."!cursor_pos"($I11)
    ($P10) = rx481_cur."!cursor_start"()
    $P10."!cursor_pass"(rx481_pos, "")
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_486_done
  rxcap_486_fail:
    goto rx481_fail
  rxcap_486_done:
  # rx subrule "ws" subtype=method negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."ws"()
    unless $P10, rx481_fail
    rx481_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."EXPR"()
    unless $P10, rx481_fail
    rx481_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("cond")
    rx481_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx481_cur."!cursor_pos"(rx481_pos)
    $P10 = rx481_cur."ws"()
    unless $P10, rx481_fail
    rx481_pos = $P10."pos"()
  # rx pass
    rx481_cur."!cursor_pass"(rx481_pos, "statement_mod_loop:sym<for>")
    if_null rx481_debug, debug_769
    rx481_cur."!cursor_debug"("PASS", "statement_mod_loop:sym<for>", " at pos=", rx481_pos)
  debug_769:
    .return (rx481_cur)
  rx481_restart:
.annotate 'line', 10
    if_null rx481_debug, debug_770
    rx481_cur."!cursor_debug"("NEXT", "statement_mod_loop:sym<for>")
  debug_770:
  rx481_fail:
    (rx481_rep, rx481_pos, $I10, $P10) = rx481_cur."!mark_fail"(0)
    lt rx481_pos, -1, rx481_done
    eq rx481_pos, -1, rx481_fail
    jump $I10
  rx481_done:
    rx481_cur."!cursor_fail"()
    if_null rx481_debug, debug_771
    rx481_cur."!cursor_debug"("FAIL", "statement_mod_loop:sym<for>")
  debug_771:
    .return (rx481_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__statement_mod_loop:sym<for>"  :nsentry("!PREFIX__statement_mod_loop:sym<for>") :subid("103_1300146757.646") :method
.annotate 'line', 10
    $P483 = self."!PREFIX__!subrule"("ws", "for")
    new $P484, "ResizablePMCArray"
    push $P484, $P483
    .return ($P484)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<fatarrow>"  :subid("104_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx490_tgt
    .local int rx490_pos
    .local int rx490_off
    .local int rx490_eos
    .local int rx490_rep
    .local pmc rx490_cur
    .local pmc rx490_debug
    (rx490_cur, rx490_pos, rx490_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx490_cur
    .local pmc match
    .lex "$/", match
    length rx490_eos, rx490_tgt
    gt rx490_pos, rx490_eos, rx490_done
    set rx490_off, 0
    lt rx490_pos, 2, rx490_start
    sub rx490_off, rx490_pos, 1
    substr rx490_tgt, rx490_tgt, rx490_off
  rx490_start:
    eq $I10, 1, rx490_restart
    if_null rx490_debug, debug_772
    rx490_cur."!cursor_debug"("START", "term:sym<fatarrow>")
  debug_772:
    $I10 = self.'from'()
    ne $I10, -1, rxscan494_done
    goto rxscan494_scan
  rxscan494_loop:
    (rx490_pos) = rx490_cur."from"()
    inc rx490_pos
    rx490_cur."!cursor_from"(rx490_pos)
    ge rx490_pos, rx490_eos, rxscan494_done
  rxscan494_scan:
    set_addr $I10, rxscan494_loop
    rx490_cur."!mark_push"(0, rx490_pos, $I10)
  rxscan494_done:
.annotate 'line', 267
  # rx subrule "fatarrow" subtype=capture negate=
    rx490_cur."!cursor_pos"(rx490_pos)
    $P10 = rx490_cur."fatarrow"()
    unless $P10, rx490_fail
    rx490_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("fatarrow")
    rx490_pos = $P10."pos"()
  # rx pass
    rx490_cur."!cursor_pass"(rx490_pos, "term:sym<fatarrow>")
    if_null rx490_debug, debug_773
    rx490_cur."!cursor_debug"("PASS", "term:sym<fatarrow>", " at pos=", rx490_pos)
  debug_773:
    .return (rx490_cur)
  rx490_restart:
.annotate 'line', 10
    if_null rx490_debug, debug_774
    rx490_cur."!cursor_debug"("NEXT", "term:sym<fatarrow>")
  debug_774:
  rx490_fail:
    (rx490_rep, rx490_pos, $I10, $P10) = rx490_cur."!mark_fail"(0)
    lt rx490_pos, -1, rx490_done
    eq rx490_pos, -1, rx490_fail
    jump $I10
  rx490_done:
    rx490_cur."!cursor_fail"()
    if_null rx490_debug, debug_775
    rx490_cur."!cursor_debug"("FAIL", "term:sym<fatarrow>")
  debug_775:
    .return (rx490_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<fatarrow>"  :nsentry("!PREFIX__term:sym<fatarrow>") :subid("105_1300146757.646") :method
.annotate 'line', 10
    $P492 = self."!PREFIX__!subrule"("fatarrow", "")
    new $P493, "ResizablePMCArray"
    push $P493, $P492
    .return ($P493)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<colonpair>"  :subid("106_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx496_tgt
    .local int rx496_pos
    .local int rx496_off
    .local int rx496_eos
    .local int rx496_rep
    .local pmc rx496_cur
    .local pmc rx496_debug
    (rx496_cur, rx496_pos, rx496_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx496_cur
    .local pmc match
    .lex "$/", match
    length rx496_eos, rx496_tgt
    gt rx496_pos, rx496_eos, rx496_done
    set rx496_off, 0
    lt rx496_pos, 2, rx496_start
    sub rx496_off, rx496_pos, 1
    substr rx496_tgt, rx496_tgt, rx496_off
  rx496_start:
    eq $I10, 1, rx496_restart
    if_null rx496_debug, debug_776
    rx496_cur."!cursor_debug"("START", "term:sym<colonpair>")
  debug_776:
    $I10 = self.'from'()
    ne $I10, -1, rxscan500_done
    goto rxscan500_scan
  rxscan500_loop:
    (rx496_pos) = rx496_cur."from"()
    inc rx496_pos
    rx496_cur."!cursor_from"(rx496_pos)
    ge rx496_pos, rx496_eos, rxscan500_done
  rxscan500_scan:
    set_addr $I10, rxscan500_loop
    rx496_cur."!mark_push"(0, rx496_pos, $I10)
  rxscan500_done:
.annotate 'line', 268
  # rx subrule "colonpair" subtype=capture negate=
    rx496_cur."!cursor_pos"(rx496_pos)
    $P10 = rx496_cur."colonpair"()
    unless $P10, rx496_fail
    rx496_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("colonpair")
    rx496_pos = $P10."pos"()
  # rx pass
    rx496_cur."!cursor_pass"(rx496_pos, "term:sym<colonpair>")
    if_null rx496_debug, debug_777
    rx496_cur."!cursor_debug"("PASS", "term:sym<colonpair>", " at pos=", rx496_pos)
  debug_777:
    .return (rx496_cur)
  rx496_restart:
.annotate 'line', 10
    if_null rx496_debug, debug_778
    rx496_cur."!cursor_debug"("NEXT", "term:sym<colonpair>")
  debug_778:
  rx496_fail:
    (rx496_rep, rx496_pos, $I10, $P10) = rx496_cur."!mark_fail"(0)
    lt rx496_pos, -1, rx496_done
    eq rx496_pos, -1, rx496_fail
    jump $I10
  rx496_done:
    rx496_cur."!cursor_fail"()
    if_null rx496_debug, debug_779
    rx496_cur."!cursor_debug"("FAIL", "term:sym<colonpair>")
  debug_779:
    .return (rx496_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<colonpair>"  :nsentry("!PREFIX__term:sym<colonpair>") :subid("107_1300146757.646") :method
.annotate 'line', 10
    $P498 = self."!PREFIX__!subrule"("colonpair", "")
    new $P499, "ResizablePMCArray"
    push $P499, $P498
    .return ($P499)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<variable>"  :subid("108_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx502_tgt
    .local int rx502_pos
    .local int rx502_off
    .local int rx502_eos
    .local int rx502_rep
    .local pmc rx502_cur
    .local pmc rx502_debug
    (rx502_cur, rx502_pos, rx502_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx502_cur
    .local pmc match
    .lex "$/", match
    length rx502_eos, rx502_tgt
    gt rx502_pos, rx502_eos, rx502_done
    set rx502_off, 0
    lt rx502_pos, 2, rx502_start
    sub rx502_off, rx502_pos, 1
    substr rx502_tgt, rx502_tgt, rx502_off
  rx502_start:
    eq $I10, 1, rx502_restart
    if_null rx502_debug, debug_780
    rx502_cur."!cursor_debug"("START", "term:sym<variable>")
  debug_780:
    $I10 = self.'from'()
    ne $I10, -1, rxscan506_done
    goto rxscan506_scan
  rxscan506_loop:
    (rx502_pos) = rx502_cur."from"()
    inc rx502_pos
    rx502_cur."!cursor_from"(rx502_pos)
    ge rx502_pos, rx502_eos, rxscan506_done
  rxscan506_scan:
    set_addr $I10, rxscan506_loop
    rx502_cur."!mark_push"(0, rx502_pos, $I10)
  rxscan506_done:
.annotate 'line', 269
  # rx subrule "variable" subtype=capture negate=
    rx502_cur."!cursor_pos"(rx502_pos)
    $P10 = rx502_cur."variable"()
    unless $P10, rx502_fail
    rx502_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx502_pos = $P10."pos"()
  # rx pass
    rx502_cur."!cursor_pass"(rx502_pos, "term:sym<variable>")
    if_null rx502_debug, debug_781
    rx502_cur."!cursor_debug"("PASS", "term:sym<variable>", " at pos=", rx502_pos)
  debug_781:
    .return (rx502_cur)
  rx502_restart:
.annotate 'line', 10
    if_null rx502_debug, debug_782
    rx502_cur."!cursor_debug"("NEXT", "term:sym<variable>")
  debug_782:
  rx502_fail:
    (rx502_rep, rx502_pos, $I10, $P10) = rx502_cur."!mark_fail"(0)
    lt rx502_pos, -1, rx502_done
    eq rx502_pos, -1, rx502_fail
    jump $I10
  rx502_done:
    rx502_cur."!cursor_fail"()
    if_null rx502_debug, debug_783
    rx502_cur."!cursor_debug"("FAIL", "term:sym<variable>")
  debug_783:
    .return (rx502_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<variable>"  :nsentry("!PREFIX__term:sym<variable>") :subid("109_1300146757.646") :method
.annotate 'line', 10
    $P504 = self."!PREFIX__!subrule"("variable", "")
    new $P505, "ResizablePMCArray"
    push $P505, $P504
    .return ($P505)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<package_declarator>"  :subid("110_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx508_tgt
    .local int rx508_pos
    .local int rx508_off
    .local int rx508_eos
    .local int rx508_rep
    .local pmc rx508_cur
    .local pmc rx508_debug
    (rx508_cur, rx508_pos, rx508_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx508_cur
    .local pmc match
    .lex "$/", match
    length rx508_eos, rx508_tgt
    gt rx508_pos, rx508_eos, rx508_done
    set rx508_off, 0
    lt rx508_pos, 2, rx508_start
    sub rx508_off, rx508_pos, 1
    substr rx508_tgt, rx508_tgt, rx508_off
  rx508_start:
    eq $I10, 1, rx508_restart
    if_null rx508_debug, debug_784
    rx508_cur."!cursor_debug"("START", "term:sym<package_declarator>")
  debug_784:
    $I10 = self.'from'()
    ne $I10, -1, rxscan512_done
    goto rxscan512_scan
  rxscan512_loop:
    (rx508_pos) = rx508_cur."from"()
    inc rx508_pos
    rx508_cur."!cursor_from"(rx508_pos)
    ge rx508_pos, rx508_eos, rxscan512_done
  rxscan512_scan:
    set_addr $I10, rxscan512_loop
    rx508_cur."!mark_push"(0, rx508_pos, $I10)
  rxscan512_done:
.annotate 'line', 270
  # rx subrule "package_declarator" subtype=capture negate=
    rx508_cur."!cursor_pos"(rx508_pos)
    $P10 = rx508_cur."package_declarator"()
    unless $P10, rx508_fail
    rx508_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx508_pos = $P10."pos"()
  # rx pass
    rx508_cur."!cursor_pass"(rx508_pos, "term:sym<package_declarator>")
    if_null rx508_debug, debug_785
    rx508_cur."!cursor_debug"("PASS", "term:sym<package_declarator>", " at pos=", rx508_pos)
  debug_785:
    .return (rx508_cur)
  rx508_restart:
.annotate 'line', 10
    if_null rx508_debug, debug_786
    rx508_cur."!cursor_debug"("NEXT", "term:sym<package_declarator>")
  debug_786:
  rx508_fail:
    (rx508_rep, rx508_pos, $I10, $P10) = rx508_cur."!mark_fail"(0)
    lt rx508_pos, -1, rx508_done
    eq rx508_pos, -1, rx508_fail
    jump $I10
  rx508_done:
    rx508_cur."!cursor_fail"()
    if_null rx508_debug, debug_787
    rx508_cur."!cursor_debug"("FAIL", "term:sym<package_declarator>")
  debug_787:
    .return (rx508_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<package_declarator>"  :nsentry("!PREFIX__term:sym<package_declarator>") :subid("111_1300146757.646") :method
.annotate 'line', 10
    $P510 = self."!PREFIX__!subrule"("package_declarator", "")
    new $P511, "ResizablePMCArray"
    push $P511, $P510
    .return ($P511)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<scope_declarator>"  :subid("112_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx514_tgt
    .local int rx514_pos
    .local int rx514_off
    .local int rx514_eos
    .local int rx514_rep
    .local pmc rx514_cur
    .local pmc rx514_debug
    (rx514_cur, rx514_pos, rx514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx514_cur
    .local pmc match
    .lex "$/", match
    length rx514_eos, rx514_tgt
    gt rx514_pos, rx514_eos, rx514_done
    set rx514_off, 0
    lt rx514_pos, 2, rx514_start
    sub rx514_off, rx514_pos, 1
    substr rx514_tgt, rx514_tgt, rx514_off
  rx514_start:
    eq $I10, 1, rx514_restart
    if_null rx514_debug, debug_788
    rx514_cur."!cursor_debug"("START", "term:sym<scope_declarator>")
  debug_788:
    $I10 = self.'from'()
    ne $I10, -1, rxscan518_done
    goto rxscan518_scan
  rxscan518_loop:
    (rx514_pos) = rx514_cur."from"()
    inc rx514_pos
    rx514_cur."!cursor_from"(rx514_pos)
    ge rx514_pos, rx514_eos, rxscan518_done
  rxscan518_scan:
    set_addr $I10, rxscan518_loop
    rx514_cur."!mark_push"(0, rx514_pos, $I10)
  rxscan518_done:
.annotate 'line', 271
  # rx subrule "scope_declarator" subtype=capture negate=
    rx514_cur."!cursor_pos"(rx514_pos)
    $P10 = rx514_cur."scope_declarator"()
    unless $P10, rx514_fail
    rx514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scope_declarator")
    rx514_pos = $P10."pos"()
  # rx pass
    rx514_cur."!cursor_pass"(rx514_pos, "term:sym<scope_declarator>")
    if_null rx514_debug, debug_789
    rx514_cur."!cursor_debug"("PASS", "term:sym<scope_declarator>", " at pos=", rx514_pos)
  debug_789:
    .return (rx514_cur)
  rx514_restart:
.annotate 'line', 10
    if_null rx514_debug, debug_790
    rx514_cur."!cursor_debug"("NEXT", "term:sym<scope_declarator>")
  debug_790:
  rx514_fail:
    (rx514_rep, rx514_pos, $I10, $P10) = rx514_cur."!mark_fail"(0)
    lt rx514_pos, -1, rx514_done
    eq rx514_pos, -1, rx514_fail
    jump $I10
  rx514_done:
    rx514_cur."!cursor_fail"()
    if_null rx514_debug, debug_791
    rx514_cur."!cursor_debug"("FAIL", "term:sym<scope_declarator>")
  debug_791:
    .return (rx514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<scope_declarator>"  :nsentry("!PREFIX__term:sym<scope_declarator>") :subid("113_1300146757.646") :method
.annotate 'line', 10
    $P516 = self."!PREFIX__!subrule"("scope_declarator", "")
    new $P517, "ResizablePMCArray"
    push $P517, $P516
    .return ($P517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<routine_declarator>"  :subid("114_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx520_tgt
    .local int rx520_pos
    .local int rx520_off
    .local int rx520_eos
    .local int rx520_rep
    .local pmc rx520_cur
    .local pmc rx520_debug
    (rx520_cur, rx520_pos, rx520_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx520_cur
    .local pmc match
    .lex "$/", match
    length rx520_eos, rx520_tgt
    gt rx520_pos, rx520_eos, rx520_done
    set rx520_off, 0
    lt rx520_pos, 2, rx520_start
    sub rx520_off, rx520_pos, 1
    substr rx520_tgt, rx520_tgt, rx520_off
  rx520_start:
    eq $I10, 1, rx520_restart
    if_null rx520_debug, debug_792
    rx520_cur."!cursor_debug"("START", "term:sym<routine_declarator>")
  debug_792:
    $I10 = self.'from'()
    ne $I10, -1, rxscan524_done
    goto rxscan524_scan
  rxscan524_loop:
    (rx520_pos) = rx520_cur."from"()
    inc rx520_pos
    rx520_cur."!cursor_from"(rx520_pos)
    ge rx520_pos, rx520_eos, rxscan524_done
  rxscan524_scan:
    set_addr $I10, rxscan524_loop
    rx520_cur."!mark_push"(0, rx520_pos, $I10)
  rxscan524_done:
.annotate 'line', 272
  # rx subrule "routine_declarator" subtype=capture negate=
    rx520_cur."!cursor_pos"(rx520_pos)
    $P10 = rx520_cur."routine_declarator"()
    unless $P10, rx520_fail
    rx520_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx520_pos = $P10."pos"()
  # rx pass
    rx520_cur."!cursor_pass"(rx520_pos, "term:sym<routine_declarator>")
    if_null rx520_debug, debug_793
    rx520_cur."!cursor_debug"("PASS", "term:sym<routine_declarator>", " at pos=", rx520_pos)
  debug_793:
    .return (rx520_cur)
  rx520_restart:
.annotate 'line', 10
    if_null rx520_debug, debug_794
    rx520_cur."!cursor_debug"("NEXT", "term:sym<routine_declarator>")
  debug_794:
  rx520_fail:
    (rx520_rep, rx520_pos, $I10, $P10) = rx520_cur."!mark_fail"(0)
    lt rx520_pos, -1, rx520_done
    eq rx520_pos, -1, rx520_fail
    jump $I10
  rx520_done:
    rx520_cur."!cursor_fail"()
    if_null rx520_debug, debug_795
    rx520_cur."!cursor_debug"("FAIL", "term:sym<routine_declarator>")
  debug_795:
    .return (rx520_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<routine_declarator>"  :nsentry("!PREFIX__term:sym<routine_declarator>") :subid("115_1300146757.646") :method
.annotate 'line', 10
    $P522 = self."!PREFIX__!subrule"("routine_declarator", "")
    new $P523, "ResizablePMCArray"
    push $P523, $P522
    .return ($P523)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<multi_declarator>"  :subid("116_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P536 = "119_1300146757.646" 
    capture_lex $P536
    .const 'Sub' $P531 = "118_1300146757.646" 
    capture_lex $P531
    .local string rx526_tgt
    .local int rx526_pos
    .local int rx526_off
    .local int rx526_eos
    .local int rx526_rep
    .local pmc rx526_cur
    .local pmc rx526_debug
    (rx526_cur, rx526_pos, rx526_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx526_cur
    .local pmc match
    .lex "$/", match
    length rx526_eos, rx526_tgt
    gt rx526_pos, rx526_eos, rx526_done
    set rx526_off, 0
    lt rx526_pos, 2, rx526_start
    sub rx526_off, rx526_pos, 1
    substr rx526_tgt, rx526_tgt, rx526_off
  rx526_start:
    eq $I10, 1, rx526_restart
    if_null rx526_debug, debug_796
    rx526_cur."!cursor_debug"("START", "term:sym<multi_declarator>")
  debug_796:
    $I10 = self.'from'()
    ne $I10, -1, rxscan529_done
    goto rxscan529_scan
  rxscan529_loop:
    (rx526_pos) = rx526_cur."from"()
    inc rx526_pos
    rx526_cur."!cursor_from"(rx526_pos)
    ge rx526_pos, rx526_eos, rxscan529_done
  rxscan529_scan:
    set_addr $I10, rxscan529_loop
    rx526_cur."!mark_push"(0, rx526_pos, $I10)
  rxscan529_done:
.annotate 'line', 274
  # rx subrule "before" subtype=zerowidth negate=
    rx526_cur."!cursor_pos"(rx526_pos)
    .const 'Sub' $P531 = "118_1300146757.646" 
    capture_lex $P531
    $P10 = rx526_cur."before"($P531)
    unless $P10, rx526_fail
.annotate 'line', 275
  # rx subrule "before" subtype=zerowidth negate=1
    rx526_cur."!cursor_pos"(rx526_pos)
    .const 'Sub' $P536 = "119_1300146757.646" 
    capture_lex $P536
    $P10 = rx526_cur."before"($P536)
    if $P10, rx526_fail
.annotate 'line', 276
  # rx subrule "multi_declarator" subtype=capture negate=
    rx526_cur."!cursor_pos"(rx526_pos)
    $P10 = rx526_cur."multi_declarator"()
    unless $P10, rx526_fail
    rx526_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx526_pos = $P10."pos"()
.annotate 'line', 273
  # rx pass
    rx526_cur."!cursor_pass"(rx526_pos, "term:sym<multi_declarator>")
    if_null rx526_debug, debug_805
    rx526_cur."!cursor_debug"("PASS", "term:sym<multi_declarator>", " at pos=", rx526_pos)
  debug_805:
    .return (rx526_cur)
  rx526_restart:
.annotate 'line', 10
    if_null rx526_debug, debug_806
    rx526_cur."!cursor_debug"("NEXT", "term:sym<multi_declarator>")
  debug_806:
  rx526_fail:
    (rx526_rep, rx526_pos, $I10, $P10) = rx526_cur."!mark_fail"(0)
    lt rx526_pos, -1, rx526_done
    eq rx526_pos, -1, rx526_fail
    jump $I10
  rx526_done:
    rx526_cur."!cursor_fail"()
    if_null rx526_debug, debug_807
    rx526_cur."!cursor_debug"("FAIL", "term:sym<multi_declarator>")
  debug_807:
    .return (rx526_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<multi_declarator>"  :nsentry("!PREFIX__term:sym<multi_declarator>") :subid("117_1300146757.646") :method
.annotate 'line', 10
    new $P528, "ResizablePMCArray"
    push $P528, ""
    .return ($P528)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block530"  :anon :subid("118_1300146757.646") :method :outer("116_1300146757.646")
.annotate 'line', 274
    .local string rx532_tgt
    .local int rx532_pos
    .local int rx532_off
    .local int rx532_eos
    .local int rx532_rep
    .local pmc rx532_cur
    .local pmc rx532_debug
    (rx532_cur, rx532_pos, rx532_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx532_cur
    .local pmc match
    .lex "$/", match
    length rx532_eos, rx532_tgt
    gt rx532_pos, rx532_eos, rx532_done
    set rx532_off, 0
    lt rx532_pos, 2, rx532_start
    sub rx532_off, rx532_pos, 1
    substr rx532_tgt, rx532_tgt, rx532_off
  rx532_start:
    eq $I10, 1, rx532_restart
    if_null rx532_debug, debug_797
    rx532_cur."!cursor_debug"("START", "")
  debug_797:
    $I10 = self.'from'()
    ne $I10, -1, rxscan533_done
    goto rxscan533_scan
  rxscan533_loop:
    (rx532_pos) = rx532_cur."from"()
    inc rx532_pos
    rx532_cur."!cursor_from"(rx532_pos)
    ge rx532_pos, rx532_eos, rxscan533_done
  rxscan533_scan:
    set_addr $I10, rxscan533_loop
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  rxscan533_done:
  alt534_0:
    set_addr $I10, alt534_1
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "multi"
    add $I11, rx532_pos, 5
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 5
    ne $S10, "multi", rx532_fail
    add rx532_pos, 5
    goto alt534_end
  alt534_1:
    set_addr $I10, alt534_2
    rx532_cur."!mark_push"(0, rx532_pos, $I10)
  # rx literal  "proto"
    add $I11, rx532_pos, 5
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 5
    ne $S10, "proto", rx532_fail
    add rx532_pos, 5
    goto alt534_end
  alt534_2:
  # rx literal  "only"
    add $I11, rx532_pos, 4
    gt $I11, rx532_eos, rx532_fail
    sub $I11, rx532_pos, rx532_off
    substr $S10, rx532_tgt, $I11, 4
    ne $S10, "only", rx532_fail
    add rx532_pos, 4
  alt534_end:
  # rx pass
    rx532_cur."!cursor_pass"(rx532_pos, "")
    if_null rx532_debug, debug_798
    rx532_cur."!cursor_debug"("PASS", "", " at pos=", rx532_pos)
  debug_798:
    .return (rx532_cur)
  rx532_restart:
    if_null rx532_debug, debug_799
    rx532_cur."!cursor_debug"("NEXT", "")
  debug_799:
  rx532_fail:
    (rx532_rep, rx532_pos, $I10, $P10) = rx532_cur."!mark_fail"(0)
    lt rx532_pos, -1, rx532_done
    eq rx532_pos, -1, rx532_fail
    jump $I10
  rx532_done:
    rx532_cur."!cursor_fail"()
    if_null rx532_debug, debug_800
    rx532_cur."!cursor_debug"("FAIL", "")
  debug_800:
    .return (rx532_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block535"  :anon :subid("119_1300146757.646") :method :outer("116_1300146757.646")
.annotate 'line', 275
    .local string rx537_tgt
    .local int rx537_pos
    .local int rx537_off
    .local int rx537_eos
    .local int rx537_rep
    .local pmc rx537_cur
    .local pmc rx537_debug
    (rx537_cur, rx537_pos, rx537_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx537_cur
    .local pmc match
    .lex "$/", match
    length rx537_eos, rx537_tgt
    gt rx537_pos, rx537_eos, rx537_done
    set rx537_off, 0
    lt rx537_pos, 2, rx537_start
    sub rx537_off, rx537_pos, 1
    substr rx537_tgt, rx537_tgt, rx537_off
  rx537_start:
    eq $I10, 1, rx537_restart
    if_null rx537_debug, debug_801
    rx537_cur."!cursor_debug"("START", "")
  debug_801:
    $I10 = self.'from'()
    ne $I10, -1, rxscan538_done
    goto rxscan538_scan
  rxscan538_loop:
    (rx537_pos) = rx537_cur."from"()
    inc rx537_pos
    rx537_cur."!cursor_from"(rx537_pos)
    ge rx537_pos, rx537_eos, rxscan538_done
  rxscan538_scan:
    set_addr $I10, rxscan538_loop
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  rxscan538_done:
  # rx literal  "proto"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "proto", rx537_fail
    add rx537_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx537_cur."!cursor_pos"(rx537_pos)
    $P10 = rx537_cur."ws"()
    unless $P10, rx537_fail
    rx537_pos = $P10."pos"()
  alt539_0:
    set_addr $I10, alt539_1
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  # rx literal  "regex"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "regex", rx537_fail
    add rx537_pos, 5
    goto alt539_end
  alt539_1:
    set_addr $I10, alt539_2
    rx537_cur."!mark_push"(0, rx537_pos, $I10)
  # rx literal  "token"
    add $I11, rx537_pos, 5
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 5
    ne $S10, "token", rx537_fail
    add rx537_pos, 5
    goto alt539_end
  alt539_2:
  # rx literal  "rule"
    add $I11, rx537_pos, 4
    gt $I11, rx537_eos, rx537_fail
    sub $I11, rx537_pos, rx537_off
    substr $S10, rx537_tgt, $I11, 4
    ne $S10, "rule", rx537_fail
    add rx537_pos, 4
  alt539_end:
  # rx pass
    rx537_cur."!cursor_pass"(rx537_pos, "")
    if_null rx537_debug, debug_802
    rx537_cur."!cursor_debug"("PASS", "", " at pos=", rx537_pos)
  debug_802:
    .return (rx537_cur)
  rx537_restart:
    if_null rx537_debug, debug_803
    rx537_cur."!cursor_debug"("NEXT", "")
  debug_803:
  rx537_fail:
    (rx537_rep, rx537_pos, $I10, $P10) = rx537_cur."!mark_fail"(0)
    lt rx537_pos, -1, rx537_done
    eq rx537_pos, -1, rx537_fail
    jump $I10
  rx537_done:
    rx537_cur."!cursor_fail"()
    if_null rx537_debug, debug_804
    rx537_cur."!cursor_debug"("FAIL", "")
  debug_804:
    .return (rx537_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<regex_declarator>"  :subid("120_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx541_tgt
    .local int rx541_pos
    .local int rx541_off
    .local int rx541_eos
    .local int rx541_rep
    .local pmc rx541_cur
    .local pmc rx541_debug
    (rx541_cur, rx541_pos, rx541_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx541_cur
    .local pmc match
    .lex "$/", match
    length rx541_eos, rx541_tgt
    gt rx541_pos, rx541_eos, rx541_done
    set rx541_off, 0
    lt rx541_pos, 2, rx541_start
    sub rx541_off, rx541_pos, 1
    substr rx541_tgt, rx541_tgt, rx541_off
  rx541_start:
    eq $I10, 1, rx541_restart
    if_null rx541_debug, debug_808
    rx541_cur."!cursor_debug"("START", "term:sym<regex_declarator>")
  debug_808:
    $I10 = self.'from'()
    ne $I10, -1, rxscan545_done
    goto rxscan545_scan
  rxscan545_loop:
    (rx541_pos) = rx541_cur."from"()
    inc rx541_pos
    rx541_cur."!cursor_from"(rx541_pos)
    ge rx541_pos, rx541_eos, rxscan545_done
  rxscan545_scan:
    set_addr $I10, rxscan545_loop
    rx541_cur."!mark_push"(0, rx541_pos, $I10)
  rxscan545_done:
.annotate 'line', 278
  # rx subrule "regex_declarator" subtype=capture negate=
    rx541_cur."!cursor_pos"(rx541_pos)
    $P10 = rx541_cur."regex_declarator"()
    unless $P10, rx541_fail
    rx541_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("regex_declarator")
    rx541_pos = $P10."pos"()
  # rx pass
    rx541_cur."!cursor_pass"(rx541_pos, "term:sym<regex_declarator>")
    if_null rx541_debug, debug_809
    rx541_cur."!cursor_debug"("PASS", "term:sym<regex_declarator>", " at pos=", rx541_pos)
  debug_809:
    .return (rx541_cur)
  rx541_restart:
.annotate 'line', 10
    if_null rx541_debug, debug_810
    rx541_cur."!cursor_debug"("NEXT", "term:sym<regex_declarator>")
  debug_810:
  rx541_fail:
    (rx541_rep, rx541_pos, $I10, $P10) = rx541_cur."!mark_fail"(0)
    lt rx541_pos, -1, rx541_done
    eq rx541_pos, -1, rx541_fail
    jump $I10
  rx541_done:
    rx541_cur."!cursor_fail"()
    if_null rx541_debug, debug_811
    rx541_cur."!cursor_debug"("FAIL", "term:sym<regex_declarator>")
  debug_811:
    .return (rx541_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<regex_declarator>"  :nsentry("!PREFIX__term:sym<regex_declarator>") :subid("121_1300146757.646") :method
.annotate 'line', 10
    $P543 = self."!PREFIX__!subrule"("regex_declarator", "")
    new $P544, "ResizablePMCArray"
    push $P544, $P543
    .return ($P544)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<statement_prefix>"  :subid("122_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx547_tgt
    .local int rx547_pos
    .local int rx547_off
    .local int rx547_eos
    .local int rx547_rep
    .local pmc rx547_cur
    .local pmc rx547_debug
    (rx547_cur, rx547_pos, rx547_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx547_cur
    .local pmc match
    .lex "$/", match
    length rx547_eos, rx547_tgt
    gt rx547_pos, rx547_eos, rx547_done
    set rx547_off, 0
    lt rx547_pos, 2, rx547_start
    sub rx547_off, rx547_pos, 1
    substr rx547_tgt, rx547_tgt, rx547_off
  rx547_start:
    eq $I10, 1, rx547_restart
    if_null rx547_debug, debug_812
    rx547_cur."!cursor_debug"("START", "term:sym<statement_prefix>")
  debug_812:
    $I10 = self.'from'()
    ne $I10, -1, rxscan551_done
    goto rxscan551_scan
  rxscan551_loop:
    (rx547_pos) = rx547_cur."from"()
    inc rx547_pos
    rx547_cur."!cursor_from"(rx547_pos)
    ge rx547_pos, rx547_eos, rxscan551_done
  rxscan551_scan:
    set_addr $I10, rxscan551_loop
    rx547_cur."!mark_push"(0, rx547_pos, $I10)
  rxscan551_done:
.annotate 'line', 279
  # rx subrule "statement_prefix" subtype=capture negate=
    rx547_cur."!cursor_pos"(rx547_pos)
    $P10 = rx547_cur."statement_prefix"()
    unless $P10, rx547_fail
    rx547_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement_prefix")
    rx547_pos = $P10."pos"()
  # rx pass
    rx547_cur."!cursor_pass"(rx547_pos, "term:sym<statement_prefix>")
    if_null rx547_debug, debug_813
    rx547_cur."!cursor_debug"("PASS", "term:sym<statement_prefix>", " at pos=", rx547_pos)
  debug_813:
    .return (rx547_cur)
  rx547_restart:
.annotate 'line', 10
    if_null rx547_debug, debug_814
    rx547_cur."!cursor_debug"("NEXT", "term:sym<statement_prefix>")
  debug_814:
  rx547_fail:
    (rx547_rep, rx547_pos, $I10, $P10) = rx547_cur."!mark_fail"(0)
    lt rx547_pos, -1, rx547_done
    eq rx547_pos, -1, rx547_fail
    jump $I10
  rx547_done:
    rx547_cur."!cursor_fail"()
    if_null rx547_debug, debug_815
    rx547_cur."!cursor_debug"("FAIL", "term:sym<statement_prefix>")
  debug_815:
    .return (rx547_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<statement_prefix>"  :nsentry("!PREFIX__term:sym<statement_prefix>") :subid("123_1300146757.646") :method
.annotate 'line', 10
    $P549 = self."!PREFIX__!subrule"("statement_prefix", "")
    new $P550, "ResizablePMCArray"
    push $P550, $P549
    .return ($P550)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<lambda>"  :subid("124_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx553_tgt
    .local int rx553_pos
    .local int rx553_off
    .local int rx553_eos
    .local int rx553_rep
    .local pmc rx553_cur
    .local pmc rx553_debug
    (rx553_cur, rx553_pos, rx553_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx553_cur
    .local pmc match
    .lex "$/", match
    length rx553_eos, rx553_tgt
    gt rx553_pos, rx553_eos, rx553_done
    set rx553_off, 0
    lt rx553_pos, 2, rx553_start
    sub rx553_off, rx553_pos, 1
    substr rx553_tgt, rx553_tgt, rx553_off
  rx553_start:
    eq $I10, 1, rx553_restart
    if_null rx553_debug, debug_816
    rx553_cur."!cursor_debug"("START", "term:sym<lambda>")
  debug_816:
    $I10 = self.'from'()
    ne $I10, -1, rxscan556_done
    goto rxscan556_scan
  rxscan556_loop:
    (rx553_pos) = rx553_cur."from"()
    inc rx553_pos
    rx553_cur."!cursor_from"(rx553_pos)
    ge rx553_pos, rx553_eos, rxscan556_done
  rxscan556_scan:
    set_addr $I10, rxscan556_loop
    rx553_cur."!mark_push"(0, rx553_pos, $I10)
  rxscan556_done:
.annotate 'line', 280
  # rx subrule "lambda" subtype=zerowidth negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    $P10 = rx553_cur."lambda"()
    unless $P10, rx553_fail
  # rx subrule "pblock" subtype=capture negate=
    rx553_cur."!cursor_pos"(rx553_pos)
    $P10 = rx553_cur."pblock"()
    unless $P10, rx553_fail
    rx553_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx553_pos = $P10."pos"()
  # rx pass
    rx553_cur."!cursor_pass"(rx553_pos, "term:sym<lambda>")
    if_null rx553_debug, debug_817
    rx553_cur."!cursor_debug"("PASS", "term:sym<lambda>", " at pos=", rx553_pos)
  debug_817:
    .return (rx553_cur)
  rx553_restart:
.annotate 'line', 10
    if_null rx553_debug, debug_818
    rx553_cur."!cursor_debug"("NEXT", "term:sym<lambda>")
  debug_818:
  rx553_fail:
    (rx553_rep, rx553_pos, $I10, $P10) = rx553_cur."!mark_fail"(0)
    lt rx553_pos, -1, rx553_done
    eq rx553_pos, -1, rx553_fail
    jump $I10
  rx553_done:
    rx553_cur."!cursor_fail"()
    if_null rx553_debug, debug_819
    rx553_cur."!cursor_debug"("FAIL", "term:sym<lambda>")
  debug_819:
    .return (rx553_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<lambda>"  :nsentry("!PREFIX__term:sym<lambda>") :subid("125_1300146757.646") :method
.annotate 'line', 10
    new $P555, "ResizablePMCArray"
    push $P555, ""
    .return ($P555)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "fatarrow"  :subid("126_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx558_tgt
    .local int rx558_pos
    .local int rx558_off
    .local int rx558_eos
    .local int rx558_rep
    .local pmc rx558_cur
    .local pmc rx558_debug
    (rx558_cur, rx558_pos, rx558_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx558_cur
    .local pmc match
    .lex "$/", match
    length rx558_eos, rx558_tgt
    gt rx558_pos, rx558_eos, rx558_done
    set rx558_off, 0
    lt rx558_pos, 2, rx558_start
    sub rx558_off, rx558_pos, 1
    substr rx558_tgt, rx558_tgt, rx558_off
  rx558_start:
    eq $I10, 1, rx558_restart
    if_null rx558_debug, debug_820
    rx558_cur."!cursor_debug"("START", "fatarrow")
  debug_820:
    $I10 = self.'from'()
    ne $I10, -1, rxscan562_done
    goto rxscan562_scan
  rxscan562_loop:
    (rx558_pos) = rx558_cur."from"()
    inc rx558_pos
    rx558_cur."!cursor_from"(rx558_pos)
    ge rx558_pos, rx558_eos, rxscan562_done
  rxscan562_scan:
    set_addr $I10, rxscan562_loop
    rx558_cur."!mark_push"(0, rx558_pos, $I10)
  rxscan562_done:
.annotate 'line', 283
  # rx subrule "identifier" subtype=capture negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."identifier"()
    unless $P10, rx558_fail
    rx558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("key")
    rx558_pos = $P10."pos"()
  # rx enumcharlist_q negate=0  r 0..-1
    sub $I10, rx558_pos, rx558_off
    set rx558_rep, 0
    sub $I12, rx558_eos, rx558_pos
  rxenumcharlistq563_loop:
    le $I12, 0, rxenumcharlistq563_done
    substr $S10, rx558_tgt, $I10, 1
    index $I11, unicode:"\t \x{a0}\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000", $S10
    lt $I11, 0, rxenumcharlistq563_done
    inc rx558_rep
    inc $I10
    dec $I12
    goto rxenumcharlistq563_loop
  rxenumcharlistq563_done:
    add rx558_pos, rx558_pos, rx558_rep
  # rx literal  "=>"
    add $I11, rx558_pos, 2
    gt $I11, rx558_eos, rx558_fail
    sub $I11, rx558_pos, rx558_off
    substr $S10, rx558_tgt, $I11, 2
    ne $S10, "=>", rx558_fail
    add rx558_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."ws"()
    unless $P10, rx558_fail
    rx558_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx558_cur."!cursor_pos"(rx558_pos)
    $P10 = rx558_cur."EXPR"("i=")
    unless $P10, rx558_fail
    rx558_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("val")
    rx558_pos = $P10."pos"()
.annotate 'line', 282
  # rx pass
    rx558_cur."!cursor_pass"(rx558_pos, "fatarrow")
    if_null rx558_debug, debug_821
    rx558_cur."!cursor_debug"("PASS", "fatarrow", " at pos=", rx558_pos)
  debug_821:
    .return (rx558_cur)
  rx558_restart:
.annotate 'line', 10
    if_null rx558_debug, debug_822
    rx558_cur."!cursor_debug"("NEXT", "fatarrow")
  debug_822:
  rx558_fail:
    (rx558_rep, rx558_pos, $I10, $P10) = rx558_cur."!mark_fail"(0)
    lt rx558_pos, -1, rx558_done
    eq rx558_pos, -1, rx558_fail
    jump $I10
  rx558_done:
    rx558_cur."!cursor_fail"()
    if_null rx558_debug, debug_823
    rx558_cur."!cursor_debug"("FAIL", "fatarrow")
  debug_823:
    .return (rx558_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__fatarrow"  :nsentry("!PREFIX__fatarrow") :subid("127_1300146757.646") :method
.annotate 'line', 10
    $P560 = self."!PREFIX__!subrule"("identifier", "")
    new $P561, "ResizablePMCArray"
    push $P561, $P560
    .return ($P561)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "colonpair"  :subid("128_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx565_tgt
    .local int rx565_pos
    .local int rx565_off
    .local int rx565_eos
    .local int rx565_rep
    .local pmc rx565_cur
    .local pmc rx565_debug
    (rx565_cur, rx565_pos, rx565_tgt, $I10) = self."!cursor_start"()
    rx565_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx565_cur
    .local pmc match
    .lex "$/", match
    length rx565_eos, rx565_tgt
    gt rx565_pos, rx565_eos, rx565_done
    set rx565_off, 0
    lt rx565_pos, 2, rx565_start
    sub rx565_off, rx565_pos, 1
    substr rx565_tgt, rx565_tgt, rx565_off
  rx565_start:
    eq $I10, 1, rx565_restart
    if_null rx565_debug, debug_824
    rx565_cur."!cursor_debug"("START", "colonpair")
  debug_824:
    $I10 = self.'from'()
    ne $I10, -1, rxscan571_done
    goto rxscan571_scan
  rxscan571_loop:
    (rx565_pos) = rx565_cur."from"()
    inc rx565_pos
    rx565_cur."!cursor_from"(rx565_pos)
    ge rx565_pos, rx565_eos, rxscan571_done
  rxscan571_scan:
    set_addr $I10, rxscan571_loop
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  rxscan571_done:
.annotate 'line', 287
  # rx literal  ":"
    add $I11, rx565_pos, 1
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    ord $I11, rx565_tgt, $I11
    ne $I11, 58, rx565_fail
    add rx565_pos, 1
  alt572_0:
.annotate 'line', 288
    set_addr $I10, alt572_1
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
.annotate 'line', 289
  # rx subcapture "not"
    set_addr $I10, rxcap_573_fail
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  # rx literal  "!"
    add $I11, rx565_pos, 1
    gt $I11, rx565_eos, rx565_fail
    sub $I11, rx565_pos, rx565_off
    ord $I11, rx565_tgt, $I11
    ne $I11, 33, rx565_fail
    add rx565_pos, 1
    set_addr $I10, rxcap_573_fail
    ($I12, $I11) = rx565_cur."!mark_peek"($I10)
    rx565_cur."!cursor_pos"($I11)
    ($P10) = rx565_cur."!cursor_start"()
    $P10."!cursor_pass"(rx565_pos, "")
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("not")
    goto rxcap_573_done
  rxcap_573_fail:
    goto rx565_fail
  rxcap_573_done:
  # rx subrule "identifier" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."identifier"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx565_pos = $P10."pos"()
    goto alt572_end
  alt572_1:
    set_addr $I10, alt572_2
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
.annotate 'line', 290
  # rx subrule "identifier" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."identifier"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("identifier")
    rx565_pos = $P10."pos"()
  # rx rxquantr574 ** 0..1
    set_addr $I10, rxquantr574_done
    rx565_cur."!mark_push"(0, rx565_pos, $I10)
  rxquantr574_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."circumfix"()
    unless $P10, rx565_fail
    goto rxsubrule575_pass
  rxsubrule575_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx565_fail
  rxsubrule575_pass:
    set_addr $I10, rxsubrule575_back
    rx565_cur."!mark_push"(0, rx565_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx565_pos = $P10."pos"()
    set_addr $I10, rxquantr574_done
    (rx565_rep) = rx565_cur."!mark_commit"($I10)
  rxquantr574_done:
    goto alt572_end
  alt572_2:
.annotate 'line', 291
  # rx subrule "circumfix" subtype=capture negate=
    rx565_cur."!cursor_pos"(rx565_pos)
    $P10 = rx565_cur."circumfix"()
    unless $P10, rx565_fail
    rx565_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("circumfix")
    rx565_pos = $P10."pos"()
  alt572_end:
.annotate 'line', 286
  # rx pass
    rx565_cur."!cursor_pass"(rx565_pos, "colonpair")
    if_null rx565_debug, debug_825
    rx565_cur."!cursor_debug"("PASS", "colonpair", " at pos=", rx565_pos)
  debug_825:
    .return (rx565_cur)
  rx565_restart:
.annotate 'line', 10
    if_null rx565_debug, debug_826
    rx565_cur."!cursor_debug"("NEXT", "colonpair")
  debug_826:
  rx565_fail:
    (rx565_rep, rx565_pos, $I10, $P10) = rx565_cur."!mark_fail"(0)
    lt rx565_pos, -1, rx565_done
    eq rx565_pos, -1, rx565_fail
    jump $I10
  rx565_done:
    rx565_cur."!cursor_fail"()
    if_null rx565_debug, debug_827
    rx565_cur."!cursor_debug"("FAIL", "colonpair")
  debug_827:
    .return (rx565_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__colonpair"  :nsentry("!PREFIX__colonpair") :subid("129_1300146757.646") :method
.annotate 'line', 10
    $P567 = self."!PREFIX__!subrule"("circumfix", ":")
    $P568 = self."!PREFIX__!subrule"("identifier", ":")
    $P569 = self."!PREFIX__!subrule"("identifier", ":!")
    new $P570, "ResizablePMCArray"
    push $P570, $P567
    push $P570, $P568
    push $P570, $P569
    .return ($P570)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable"  :subid("130_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx577_tgt
    .local int rx577_pos
    .local int rx577_off
    .local int rx577_eos
    .local int rx577_rep
    .local pmc rx577_cur
    .local pmc rx577_debug
    (rx577_cur, rx577_pos, rx577_tgt, $I10) = self."!cursor_start"()
    rx577_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx577_cur
    .local pmc match
    .lex "$/", match
    length rx577_eos, rx577_tgt
    gt rx577_pos, rx577_eos, rx577_done
    set rx577_off, 0
    lt rx577_pos, 2, rx577_start
    sub rx577_off, rx577_pos, 1
    substr rx577_tgt, rx577_tgt, rx577_off
  rx577_start:
    eq $I10, 1, rx577_restart
    if_null rx577_debug, debug_828
    rx577_cur."!cursor_debug"("START", "variable")
  debug_828:
    $I10 = self.'from'()
    ne $I10, -1, rxscan582_done
    goto rxscan582_scan
  rxscan582_loop:
    (rx577_pos) = rx577_cur."from"()
    inc rx577_pos
    rx577_cur."!cursor_from"(rx577_pos)
    ge rx577_pos, rx577_eos, rxscan582_done
  rxscan582_scan:
    set_addr $I10, rxscan582_loop
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  rxscan582_done:
  alt583_0:
.annotate 'line', 295
    set_addr $I10, alt583_1
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
.annotate 'line', 296
  # rx subrule "sigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."sigil"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx577_pos = $P10."pos"()
  # rx rxquantr584 ** 0..1
    set_addr $I10, rxquantr584_done
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  rxquantr584_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."twigil"()
    unless $P10, rx577_fail
    goto rxsubrule585_pass
  rxsubrule585_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx577_fail
  rxsubrule585_pass:
    set_addr $I10, rxsubrule585_back
    rx577_cur."!mark_push"(0, rx577_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx577_pos = $P10."pos"()
    set_addr $I10, rxquantr584_done
    (rx577_rep) = rx577_cur."!mark_commit"($I10)
  rxquantr584_done:
  # rx subrule "name" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."name"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    rx577_pos = $P10."pos"()
    goto alt583_end
  alt583_1:
    set_addr $I10, alt583_2
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
.annotate 'line', 297
  # rx subrule "sigil" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."sigil"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx577_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx577_pos, rx577_off
    substr $S10, rx577_tgt, $I10, 1
    index $I11, "<[", $S10
    lt $I11, 0, rx577_fail
  # rx subrule "postcircumfix" subtype=capture negate=
    rx577_cur."!cursor_pos"(rx577_pos)
    $P10 = rx577_cur."postcircumfix"()
    unless $P10, rx577_fail
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("postcircumfix")
    rx577_pos = $P10."pos"()
    goto alt583_end
  alt583_2:
.annotate 'line', 298
  # rx subcapture "sigil"
    set_addr $I10, rxcap_586_fail
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  # rx literal  "$"
    add $I11, rx577_pos, 1
    gt $I11, rx577_eos, rx577_fail
    sub $I11, rx577_pos, rx577_off
    ord $I11, rx577_tgt, $I11
    ne $I11, 36, rx577_fail
    add rx577_pos, 1
    set_addr $I10, rxcap_586_fail
    ($I12, $I11) = rx577_cur."!mark_peek"($I10)
    rx577_cur."!cursor_pos"($I11)
    ($P10) = rx577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx577_pos, "")
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_586_done
  rxcap_586_fail:
    goto rx577_fail
  rxcap_586_done:
  # rx subcapture "desigilname"
    set_addr $I10, rxcap_587_fail
    rx577_cur."!mark_push"(0, rx577_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx577_pos, rx577_eos, rx577_fail
    sub $I10, rx577_pos, rx577_off
    substr $S10, rx577_tgt, $I10, 1
    index $I11, "/_!", $S10
    lt $I11, 0, rx577_fail
    inc rx577_pos
    set_addr $I10, rxcap_587_fail
    ($I12, $I11) = rx577_cur."!mark_peek"($I10)
    rx577_cur."!cursor_pos"($I11)
    ($P10) = rx577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx577_pos, "")
    rx577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("desigilname")
    goto rxcap_587_done
  rxcap_587_fail:
    goto rx577_fail
  rxcap_587_done:
  alt583_end:
.annotate 'line', 295
  # rx pass
    rx577_cur."!cursor_pass"(rx577_pos, "variable")
    if_null rx577_debug, debug_829
    rx577_cur."!cursor_debug"("PASS", "variable", " at pos=", rx577_pos)
  debug_829:
    .return (rx577_cur)
  rx577_restart:
.annotate 'line', 10
    if_null rx577_debug, debug_830
    rx577_cur."!cursor_debug"("NEXT", "variable")
  debug_830:
  rx577_fail:
    (rx577_rep, rx577_pos, $I10, $P10) = rx577_cur."!mark_fail"(0)
    lt rx577_pos, -1, rx577_done
    eq rx577_pos, -1, rx577_fail
    jump $I10
  rx577_done:
    rx577_cur."!cursor_fail"()
    if_null rx577_debug, debug_831
    rx577_cur."!cursor_debug"("FAIL", "variable")
  debug_831:
    .return (rx577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable"  :nsentry("!PREFIX__variable") :subid("131_1300146757.646") :method
.annotate 'line', 10
    $P579 = self."!PREFIX__!subrule"("sigil", "")
    $P580 = self."!PREFIX__!subrule"("sigil", "")
    new $P581, "ResizablePMCArray"
    push $P581, "$!"
    push $P581, "$_"
    push $P581, "$/"
    push $P581, $P579
    push $P581, $P580
    .return ($P581)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "sigil"  :subid("132_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx589_tgt
    .local int rx589_pos
    .local int rx589_off
    .local int rx589_eos
    .local int rx589_rep
    .local pmc rx589_cur
    .local pmc rx589_debug
    (rx589_cur, rx589_pos, rx589_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx589_cur
    .local pmc match
    .lex "$/", match
    length rx589_eos, rx589_tgt
    gt rx589_pos, rx589_eos, rx589_done
    set rx589_off, 0
    lt rx589_pos, 2, rx589_start
    sub rx589_off, rx589_pos, 1
    substr rx589_tgt, rx589_tgt, rx589_off
  rx589_start:
    eq $I10, 1, rx589_restart
    if_null rx589_debug, debug_832
    rx589_cur."!cursor_debug"("START", "sigil")
  debug_832:
    $I10 = self.'from'()
    ne $I10, -1, rxscan592_done
    goto rxscan592_scan
  rxscan592_loop:
    (rx589_pos) = rx589_cur."from"()
    inc rx589_pos
    rx589_cur."!cursor_from"(rx589_pos)
    ge rx589_pos, rx589_eos, rxscan592_done
  rxscan592_scan:
    set_addr $I10, rxscan592_loop
    rx589_cur."!mark_push"(0, rx589_pos, $I10)
  rxscan592_done:
.annotate 'line', 301
  # rx enumcharlist negate=0 
    ge rx589_pos, rx589_eos, rx589_fail
    sub $I10, rx589_pos, rx589_off
    substr $S10, rx589_tgt, $I10, 1
    index $I11, "$@%&", $S10
    lt $I11, 0, rx589_fail
    inc rx589_pos
  # rx pass
    rx589_cur."!cursor_pass"(rx589_pos, "sigil")
    if_null rx589_debug, debug_833
    rx589_cur."!cursor_debug"("PASS", "sigil", " at pos=", rx589_pos)
  debug_833:
    .return (rx589_cur)
  rx589_restart:
.annotate 'line', 10
    if_null rx589_debug, debug_834
    rx589_cur."!cursor_debug"("NEXT", "sigil")
  debug_834:
  rx589_fail:
    (rx589_rep, rx589_pos, $I10, $P10) = rx589_cur."!mark_fail"(0)
    lt rx589_pos, -1, rx589_done
    eq rx589_pos, -1, rx589_fail
    jump $I10
  rx589_done:
    rx589_cur."!cursor_fail"()
    if_null rx589_debug, debug_835
    rx589_cur."!cursor_debug"("FAIL", "sigil")
  debug_835:
    .return (rx589_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__sigil"  :nsentry("!PREFIX__sigil") :subid("133_1300146757.646") :method
.annotate 'line', 10
    new $P591, "ResizablePMCArray"
    push $P591, "&"
    push $P591, "%"
    push $P591, "@"
    push $P591, "$"
    .return ($P591)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "twigil"  :subid("134_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx594_tgt
    .local int rx594_pos
    .local int rx594_off
    .local int rx594_eos
    .local int rx594_rep
    .local pmc rx594_cur
    .local pmc rx594_debug
    (rx594_cur, rx594_pos, rx594_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx594_cur
    .local pmc match
    .lex "$/", match
    length rx594_eos, rx594_tgt
    gt rx594_pos, rx594_eos, rx594_done
    set rx594_off, 0
    lt rx594_pos, 2, rx594_start
    sub rx594_off, rx594_pos, 1
    substr rx594_tgt, rx594_tgt, rx594_off
  rx594_start:
    eq $I10, 1, rx594_restart
    if_null rx594_debug, debug_836
    rx594_cur."!cursor_debug"("START", "twigil")
  debug_836:
    $I10 = self.'from'()
    ne $I10, -1, rxscan597_done
    goto rxscan597_scan
  rxscan597_loop:
    (rx594_pos) = rx594_cur."from"()
    inc rx594_pos
    rx594_cur."!cursor_from"(rx594_pos)
    ge rx594_pos, rx594_eos, rxscan597_done
  rxscan597_scan:
    set_addr $I10, rxscan597_loop
    rx594_cur."!mark_push"(0, rx594_pos, $I10)
  rxscan597_done:
.annotate 'line', 303
  # rx enumcharlist negate=0 
    ge rx594_pos, rx594_eos, rx594_fail
    sub $I10, rx594_pos, rx594_off
    substr $S10, rx594_tgt, $I10, 1
    index $I11, "*!?", $S10
    lt $I11, 0, rx594_fail
    inc rx594_pos
  # rx pass
    rx594_cur."!cursor_pass"(rx594_pos, "twigil")
    if_null rx594_debug, debug_837
    rx594_cur."!cursor_debug"("PASS", "twigil", " at pos=", rx594_pos)
  debug_837:
    .return (rx594_cur)
  rx594_restart:
.annotate 'line', 10
    if_null rx594_debug, debug_838
    rx594_cur."!cursor_debug"("NEXT", "twigil")
  debug_838:
  rx594_fail:
    (rx594_rep, rx594_pos, $I10, $P10) = rx594_cur."!mark_fail"(0)
    lt rx594_pos, -1, rx594_done
    eq rx594_pos, -1, rx594_fail
    jump $I10
  rx594_done:
    rx594_cur."!cursor_fail"()
    if_null rx594_debug, debug_839
    rx594_cur."!cursor_debug"("FAIL", "twigil")
  debug_839:
    .return (rx594_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__twigil"  :nsentry("!PREFIX__twigil") :subid("135_1300146757.646") :method
.annotate 'line', 10
    new $P596, "ResizablePMCArray"
    push $P596, "?"
    push $P596, "!"
    push $P596, "*"
    .return ($P596)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator"  :subid("136_1300146757.646")
    .param pmc param_599
.annotate 'line', 305
    .lex "self", param_599
    $P600 = param_599."!protoregex"("package_declarator")
    .return ($P600)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator"  :subid("137_1300146757.646")
    .param pmc param_602
.annotate 'line', 305
    .lex "self", param_602
    $P603 = param_602."!PREFIX__!protoregex"("package_declarator")
    .return ($P603)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<module>"  :subid("138_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 307
    new $P605, "Undef"
    .lex "$*PACKAGE-SETUP", $P605
.annotate 'line', 308
    new $P606, "Undef"
    .lex "$*PKGDECL", $P606
.annotate 'line', 10
    .local string rx607_tgt
    .local int rx607_pos
    .local int rx607_off
    .local int rx607_eos
    .local int rx607_rep
    .local pmc rx607_cur
    .local pmc rx607_debug
    (rx607_cur, rx607_pos, rx607_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx607_cur
    .local pmc match
    .lex "$/", match
    length rx607_eos, rx607_tgt
    gt rx607_pos, rx607_eos, rx607_done
    set rx607_off, 0
    lt rx607_pos, 2, rx607_start
    sub rx607_off, rx607_pos, 1
    substr rx607_tgt, rx607_tgt, rx607_off
  rx607_start:
    eq $I10, 1, rx607_restart
    if_null rx607_debug, debug_840
    rx607_cur."!cursor_debug"("START", "package_declarator:sym<module>")
  debug_840:
    $I10 = self.'from'()
    ne $I10, -1, rxscan611_done
    goto rxscan611_scan
  rxscan611_loop:
    (rx607_pos) = rx607_cur."from"()
    inc rx607_pos
    rx607_cur."!cursor_from"(rx607_pos)
    ge rx607_pos, rx607_eos, rxscan611_done
  rxscan611_scan:
    set_addr $I10, rxscan611_loop
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  rxscan611_done:
.annotate 'line', 307
    rx607_cur."!cursor_pos"(rx607_pos)
    get_hll_global $P612, ["PAST"], "Stmts"
    $P613 = $P612."new"()
    store_lex "$*PACKAGE-SETUP", $P613
.annotate 'line', 308
    rx607_cur."!cursor_pos"(rx607_pos)
    new $P614, "String"
    assign $P614, "module"
    store_lex "$*PKGDECL", $P614
.annotate 'line', 309
  # rx subcapture "sym"
    set_addr $I10, rxcap_615_fail
    rx607_cur."!mark_push"(0, rx607_pos, $I10)
  # rx literal  "module"
    add $I11, rx607_pos, 6
    gt $I11, rx607_eos, rx607_fail
    sub $I11, rx607_pos, rx607_off
    substr $S10, rx607_tgt, $I11, 6
    ne $S10, "module", rx607_fail
    add rx607_pos, 6
    set_addr $I10, rxcap_615_fail
    ($I12, $I11) = rx607_cur."!mark_peek"($I10)
    rx607_cur."!cursor_pos"($I11)
    ($P10) = rx607_cur."!cursor_start"()
    $P10."!cursor_pass"(rx607_pos, "")
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_615_done
  rxcap_615_fail:
    goto rx607_fail
  rxcap_615_done:
  # rx subrule "package_def" subtype=capture negate=
    rx607_cur."!cursor_pos"(rx607_pos)
    $P10 = rx607_cur."package_def"()
    unless $P10, rx607_fail
    rx607_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx607_pos = $P10."pos"()
.annotate 'line', 306
  # rx pass
    rx607_cur."!cursor_pass"(rx607_pos, "package_declarator:sym<module>")
    if_null rx607_debug, debug_841
    rx607_cur."!cursor_debug"("PASS", "package_declarator:sym<module>", " at pos=", rx607_pos)
  debug_841:
    .return (rx607_cur)
  rx607_restart:
.annotate 'line', 10
    if_null rx607_debug, debug_842
    rx607_cur."!cursor_debug"("NEXT", "package_declarator:sym<module>")
  debug_842:
  rx607_fail:
    (rx607_rep, rx607_pos, $I10, $P10) = rx607_cur."!mark_fail"(0)
    lt rx607_pos, -1, rx607_done
    eq rx607_pos, -1, rx607_fail
    jump $I10
  rx607_done:
    rx607_cur."!cursor_fail"()
    if_null rx607_debug, debug_843
    rx607_cur."!cursor_debug"("FAIL", "package_declarator:sym<module>")
  debug_843:
    .return (rx607_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<module>"  :nsentry("!PREFIX__package_declarator:sym<module>") :subid("139_1300146757.646") :method
.annotate 'line', 10
    $P609 = self."!PREFIX__!subrule"("package_def", "module")
    new $P610, "ResizablePMCArray"
    push $P610, $P609
    .return ($P610)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<knowhow>"  :subid("140_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 312
    new $P617, "Undef"
    .lex "$*PACKAGE-SETUP", $P617
.annotate 'line', 313
    new $P618, "Undef"
    .lex "$*PKGDECL", $P618
.annotate 'line', 10
    .local string rx619_tgt
    .local int rx619_pos
    .local int rx619_off
    .local int rx619_eos
    .local int rx619_rep
    .local pmc rx619_cur
    .local pmc rx619_debug
    (rx619_cur, rx619_pos, rx619_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx619_cur
    .local pmc match
    .lex "$/", match
    length rx619_eos, rx619_tgt
    gt rx619_pos, rx619_eos, rx619_done
    set rx619_off, 0
    lt rx619_pos, 2, rx619_start
    sub rx619_off, rx619_pos, 1
    substr rx619_tgt, rx619_tgt, rx619_off
  rx619_start:
    eq $I10, 1, rx619_restart
    if_null rx619_debug, debug_844
    rx619_cur."!cursor_debug"("START", "package_declarator:sym<knowhow>")
  debug_844:
    $I10 = self.'from'()
    ne $I10, -1, rxscan623_done
    goto rxscan623_scan
  rxscan623_loop:
    (rx619_pos) = rx619_cur."from"()
    inc rx619_pos
    rx619_cur."!cursor_from"(rx619_pos)
    ge rx619_pos, rx619_eos, rxscan623_done
  rxscan623_scan:
    set_addr $I10, rxscan623_loop
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  rxscan623_done:
.annotate 'line', 312
    rx619_cur."!cursor_pos"(rx619_pos)
    get_hll_global $P624, ["PAST"], "Stmts"
    $P625 = $P624."new"()
    store_lex "$*PACKAGE-SETUP", $P625
.annotate 'line', 313
    rx619_cur."!cursor_pos"(rx619_pos)
    new $P626, "String"
    assign $P626, "knowhow"
    store_lex "$*PKGDECL", $P626
.annotate 'line', 314
  # rx subcapture "sym"
    set_addr $I10, rxcap_627_fail
    rx619_cur."!mark_push"(0, rx619_pos, $I10)
  # rx literal  "knowhow"
    add $I11, rx619_pos, 7
    gt $I11, rx619_eos, rx619_fail
    sub $I11, rx619_pos, rx619_off
    substr $S10, rx619_tgt, $I11, 7
    ne $S10, "knowhow", rx619_fail
    add rx619_pos, 7
    set_addr $I10, rxcap_627_fail
    ($I12, $I11) = rx619_cur."!mark_peek"($I10)
    rx619_cur."!cursor_pos"($I11)
    ($P10) = rx619_cur."!cursor_start"()
    $P10."!cursor_pass"(rx619_pos, "")
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_627_done
  rxcap_627_fail:
    goto rx619_fail
  rxcap_627_done:
  # rx subrule "package_def" subtype=capture negate=
    rx619_cur."!cursor_pos"(rx619_pos)
    $P10 = rx619_cur."package_def"()
    unless $P10, rx619_fail
    rx619_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx619_pos = $P10."pos"()
.annotate 'line', 311
  # rx pass
    rx619_cur."!cursor_pass"(rx619_pos, "package_declarator:sym<knowhow>")
    if_null rx619_debug, debug_845
    rx619_cur."!cursor_debug"("PASS", "package_declarator:sym<knowhow>", " at pos=", rx619_pos)
  debug_845:
    .return (rx619_cur)
  rx619_restart:
.annotate 'line', 10
    if_null rx619_debug, debug_846
    rx619_cur."!cursor_debug"("NEXT", "package_declarator:sym<knowhow>")
  debug_846:
  rx619_fail:
    (rx619_rep, rx619_pos, $I10, $P10) = rx619_cur."!mark_fail"(0)
    lt rx619_pos, -1, rx619_done
    eq rx619_pos, -1, rx619_fail
    jump $I10
  rx619_done:
    rx619_cur."!cursor_fail"()
    if_null rx619_debug, debug_847
    rx619_cur."!cursor_debug"("FAIL", "package_declarator:sym<knowhow>")
  debug_847:
    .return (rx619_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<knowhow>"  :nsentry("!PREFIX__package_declarator:sym<knowhow>") :subid("141_1300146757.646") :method
.annotate 'line', 10
    $P621 = self."!PREFIX__!subrule"("package_def", "knowhow")
    new $P622, "ResizablePMCArray"
    push $P622, $P621
    .return ($P622)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<class>"  :subid("142_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 317
    new $P629, "Undef"
    .lex "$*PACKAGE-SETUP", $P629
.annotate 'line', 318
    new $P630, "Undef"
    .lex "$*PKGDECL", $P630
.annotate 'line', 10
    .local string rx631_tgt
    .local int rx631_pos
    .local int rx631_off
    .local int rx631_eos
    .local int rx631_rep
    .local pmc rx631_cur
    .local pmc rx631_debug
    (rx631_cur, rx631_pos, rx631_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx631_cur
    .local pmc match
    .lex "$/", match
    length rx631_eos, rx631_tgt
    gt rx631_pos, rx631_eos, rx631_done
    set rx631_off, 0
    lt rx631_pos, 2, rx631_start
    sub rx631_off, rx631_pos, 1
    substr rx631_tgt, rx631_tgt, rx631_off
  rx631_start:
    eq $I10, 1, rx631_restart
    if_null rx631_debug, debug_848
    rx631_cur."!cursor_debug"("START", "package_declarator:sym<class>")
  debug_848:
    $I10 = self.'from'()
    ne $I10, -1, rxscan635_done
    goto rxscan635_scan
  rxscan635_loop:
    (rx631_pos) = rx631_cur."from"()
    inc rx631_pos
    rx631_cur."!cursor_from"(rx631_pos)
    ge rx631_pos, rx631_eos, rxscan635_done
  rxscan635_scan:
    set_addr $I10, rxscan635_loop
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  rxscan635_done:
.annotate 'line', 317
    rx631_cur."!cursor_pos"(rx631_pos)
    get_hll_global $P636, ["PAST"], "Stmts"
    $P637 = $P636."new"()
    store_lex "$*PACKAGE-SETUP", $P637
.annotate 'line', 318
    rx631_cur."!cursor_pos"(rx631_pos)
    new $P638, "String"
    assign $P638, "class"
    store_lex "$*PKGDECL", $P638
.annotate 'line', 319
  # rx subcapture "sym"
    set_addr $I10, rxcap_639_fail
    rx631_cur."!mark_push"(0, rx631_pos, $I10)
  # rx literal  "class"
    add $I11, rx631_pos, 5
    gt $I11, rx631_eos, rx631_fail
    sub $I11, rx631_pos, rx631_off
    substr $S10, rx631_tgt, $I11, 5
    ne $S10, "class", rx631_fail
    add rx631_pos, 5
    set_addr $I10, rxcap_639_fail
    ($I12, $I11) = rx631_cur."!mark_peek"($I10)
    rx631_cur."!cursor_pos"($I11)
    ($P10) = rx631_cur."!cursor_start"()
    $P10."!cursor_pass"(rx631_pos, "")
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_639_done
  rxcap_639_fail:
    goto rx631_fail
  rxcap_639_done:
  # rx subrule "package_def" subtype=capture negate=
    rx631_cur."!cursor_pos"(rx631_pos)
    $P10 = rx631_cur."package_def"()
    unless $P10, rx631_fail
    rx631_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx631_pos = $P10."pos"()
.annotate 'line', 316
  # rx pass
    rx631_cur."!cursor_pass"(rx631_pos, "package_declarator:sym<class>")
    if_null rx631_debug, debug_849
    rx631_cur."!cursor_debug"("PASS", "package_declarator:sym<class>", " at pos=", rx631_pos)
  debug_849:
    .return (rx631_cur)
  rx631_restart:
.annotate 'line', 10
    if_null rx631_debug, debug_850
    rx631_cur."!cursor_debug"("NEXT", "package_declarator:sym<class>")
  debug_850:
  rx631_fail:
    (rx631_rep, rx631_pos, $I10, $P10) = rx631_cur."!mark_fail"(0)
    lt rx631_pos, -1, rx631_done
    eq rx631_pos, -1, rx631_fail
    jump $I10
  rx631_done:
    rx631_cur."!cursor_fail"()
    if_null rx631_debug, debug_851
    rx631_cur."!cursor_debug"("FAIL", "package_declarator:sym<class>")
  debug_851:
    .return (rx631_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<class>"  :nsentry("!PREFIX__package_declarator:sym<class>") :subid("143_1300146757.646") :method
.annotate 'line', 10
    $P633 = self."!PREFIX__!subrule"("package_def", "class")
    new $P634, "ResizablePMCArray"
    push $P634, $P633
    .return ($P634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<grammar>"  :subid("144_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 322
    new $P641, "Undef"
    .lex "$*PACKAGE-SETUP", $P641
.annotate 'line', 323
    new $P642, "Undef"
    .lex "$*PKGDECL", $P642
.annotate 'line', 10
    .local string rx643_tgt
    .local int rx643_pos
    .local int rx643_off
    .local int rx643_eos
    .local int rx643_rep
    .local pmc rx643_cur
    .local pmc rx643_debug
    (rx643_cur, rx643_pos, rx643_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx643_cur
    .local pmc match
    .lex "$/", match
    length rx643_eos, rx643_tgt
    gt rx643_pos, rx643_eos, rx643_done
    set rx643_off, 0
    lt rx643_pos, 2, rx643_start
    sub rx643_off, rx643_pos, 1
    substr rx643_tgt, rx643_tgt, rx643_off
  rx643_start:
    eq $I10, 1, rx643_restart
    if_null rx643_debug, debug_852
    rx643_cur."!cursor_debug"("START", "package_declarator:sym<grammar>")
  debug_852:
    $I10 = self.'from'()
    ne $I10, -1, rxscan647_done
    goto rxscan647_scan
  rxscan647_loop:
    (rx643_pos) = rx643_cur."from"()
    inc rx643_pos
    rx643_cur."!cursor_from"(rx643_pos)
    ge rx643_pos, rx643_eos, rxscan647_done
  rxscan647_scan:
    set_addr $I10, rxscan647_loop
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  rxscan647_done:
.annotate 'line', 322
    rx643_cur."!cursor_pos"(rx643_pos)
    get_hll_global $P648, ["PAST"], "Stmts"
    $P649 = $P648."new"()
    store_lex "$*PACKAGE-SETUP", $P649
.annotate 'line', 323
    rx643_cur."!cursor_pos"(rx643_pos)
    new $P650, "String"
    assign $P650, "grammar"
    store_lex "$*PKGDECL", $P650
.annotate 'line', 324
  # rx subcapture "sym"
    set_addr $I10, rxcap_651_fail
    rx643_cur."!mark_push"(0, rx643_pos, $I10)
  # rx literal  "grammar"
    add $I11, rx643_pos, 7
    gt $I11, rx643_eos, rx643_fail
    sub $I11, rx643_pos, rx643_off
    substr $S10, rx643_tgt, $I11, 7
    ne $S10, "grammar", rx643_fail
    add rx643_pos, 7
    set_addr $I10, rxcap_651_fail
    ($I12, $I11) = rx643_cur."!mark_peek"($I10)
    rx643_cur."!cursor_pos"($I11)
    ($P10) = rx643_cur."!cursor_start"()
    $P10."!cursor_pass"(rx643_pos, "")
    rx643_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_651_done
  rxcap_651_fail:
    goto rx643_fail
  rxcap_651_done:
  # rx subrule "package_def" subtype=capture negate=
    rx643_cur."!cursor_pos"(rx643_pos)
    $P10 = rx643_cur."package_def"()
    unless $P10, rx643_fail
    rx643_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx643_pos = $P10."pos"()
.annotate 'line', 321
  # rx pass
    rx643_cur."!cursor_pass"(rx643_pos, "package_declarator:sym<grammar>")
    if_null rx643_debug, debug_853
    rx643_cur."!cursor_debug"("PASS", "package_declarator:sym<grammar>", " at pos=", rx643_pos)
  debug_853:
    .return (rx643_cur)
  rx643_restart:
.annotate 'line', 10
    if_null rx643_debug, debug_854
    rx643_cur."!cursor_debug"("NEXT", "package_declarator:sym<grammar>")
  debug_854:
  rx643_fail:
    (rx643_rep, rx643_pos, $I10, $P10) = rx643_cur."!mark_fail"(0)
    lt rx643_pos, -1, rx643_done
    eq rx643_pos, -1, rx643_fail
    jump $I10
  rx643_done:
    rx643_cur."!cursor_fail"()
    if_null rx643_debug, debug_855
    rx643_cur."!cursor_debug"("FAIL", "package_declarator:sym<grammar>")
  debug_855:
    .return (rx643_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<grammar>"  :nsentry("!PREFIX__package_declarator:sym<grammar>") :subid("145_1300146757.646") :method
.annotate 'line', 10
    $P645 = self."!PREFIX__!subrule"("package_def", "grammar")
    new $P646, "ResizablePMCArray"
    push $P646, $P645
    .return ($P646)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<role>"  :subid("146_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 327
    new $P653, "Undef"
    .lex "$*PACKAGE-SETUP", $P653
.annotate 'line', 328
    new $P654, "Undef"
    .lex "$*PKGDECL", $P654
.annotate 'line', 10
    .local string rx655_tgt
    .local int rx655_pos
    .local int rx655_off
    .local int rx655_eos
    .local int rx655_rep
    .local pmc rx655_cur
    .local pmc rx655_debug
    (rx655_cur, rx655_pos, rx655_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx655_cur
    .local pmc match
    .lex "$/", match
    length rx655_eos, rx655_tgt
    gt rx655_pos, rx655_eos, rx655_done
    set rx655_off, 0
    lt rx655_pos, 2, rx655_start
    sub rx655_off, rx655_pos, 1
    substr rx655_tgt, rx655_tgt, rx655_off
  rx655_start:
    eq $I10, 1, rx655_restart
    if_null rx655_debug, debug_856
    rx655_cur."!cursor_debug"("START", "package_declarator:sym<role>")
  debug_856:
    $I10 = self.'from'()
    ne $I10, -1, rxscan659_done
    goto rxscan659_scan
  rxscan659_loop:
    (rx655_pos) = rx655_cur."from"()
    inc rx655_pos
    rx655_cur."!cursor_from"(rx655_pos)
    ge rx655_pos, rx655_eos, rxscan659_done
  rxscan659_scan:
    set_addr $I10, rxscan659_loop
    rx655_cur."!mark_push"(0, rx655_pos, $I10)
  rxscan659_done:
.annotate 'line', 327
    rx655_cur."!cursor_pos"(rx655_pos)
    get_hll_global $P660, ["PAST"], "Stmts"
    $P661 = $P660."new"()
    store_lex "$*PACKAGE-SETUP", $P661
.annotate 'line', 328
    rx655_cur."!cursor_pos"(rx655_pos)
    new $P662, "String"
    assign $P662, "role"
    store_lex "$*PKGDECL", $P662
.annotate 'line', 329
  # rx subcapture "sym"
    set_addr $I10, rxcap_663_fail
    rx655_cur."!mark_push"(0, rx655_pos, $I10)
  # rx literal  "role"
    add $I11, rx655_pos, 4
    gt $I11, rx655_eos, rx655_fail
    sub $I11, rx655_pos, rx655_off
    substr $S10, rx655_tgt, $I11, 4
    ne $S10, "role", rx655_fail
    add rx655_pos, 4
    set_addr $I10, rxcap_663_fail
    ($I12, $I11) = rx655_cur."!mark_peek"($I10)
    rx655_cur."!cursor_pos"($I11)
    ($P10) = rx655_cur."!cursor_start"()
    $P10."!cursor_pass"(rx655_pos, "")
    rx655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_663_done
  rxcap_663_fail:
    goto rx655_fail
  rxcap_663_done:
  # rx subrule "package_def" subtype=capture negate=
    rx655_cur."!cursor_pos"(rx655_pos)
    $P10 = rx655_cur."package_def"()
    unless $P10, rx655_fail
    rx655_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx655_pos = $P10."pos"()
.annotate 'line', 326
  # rx pass
    rx655_cur."!cursor_pass"(rx655_pos, "package_declarator:sym<role>")
    if_null rx655_debug, debug_857
    rx655_cur."!cursor_debug"("PASS", "package_declarator:sym<role>", " at pos=", rx655_pos)
  debug_857:
    .return (rx655_cur)
  rx655_restart:
.annotate 'line', 10
    if_null rx655_debug, debug_858
    rx655_cur."!cursor_debug"("NEXT", "package_declarator:sym<role>")
  debug_858:
  rx655_fail:
    (rx655_rep, rx655_pos, $I10, $P10) = rx655_cur."!mark_fail"(0)
    lt rx655_pos, -1, rx655_done
    eq rx655_pos, -1, rx655_fail
    jump $I10
  rx655_done:
    rx655_cur."!cursor_fail"()
    if_null rx655_debug, debug_859
    rx655_cur."!cursor_debug"("FAIL", "package_declarator:sym<role>")
  debug_859:
    .return (rx655_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<role>"  :nsentry("!PREFIX__package_declarator:sym<role>") :subid("147_1300146757.646") :method
.annotate 'line', 10
    $P657 = self."!PREFIX__!subrule"("package_def", "role")
    new $P658, "ResizablePMCArray"
    push $P658, $P657
    .return ($P658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_declarator:sym<native>"  :subid("148_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 332
    new $P665, "Undef"
    .lex "$*PACKAGE-SETUP", $P665
.annotate 'line', 333
    new $P666, "Undef"
    .lex "$*PKGDECL", $P666
.annotate 'line', 10
    .local string rx667_tgt
    .local int rx667_pos
    .local int rx667_off
    .local int rx667_eos
    .local int rx667_rep
    .local pmc rx667_cur
    .local pmc rx667_debug
    (rx667_cur, rx667_pos, rx667_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx667_cur
    .local pmc match
    .lex "$/", match
    length rx667_eos, rx667_tgt
    gt rx667_pos, rx667_eos, rx667_done
    set rx667_off, 0
    lt rx667_pos, 2, rx667_start
    sub rx667_off, rx667_pos, 1
    substr rx667_tgt, rx667_tgt, rx667_off
  rx667_start:
    eq $I10, 1, rx667_restart
    if_null rx667_debug, debug_860
    rx667_cur."!cursor_debug"("START", "package_declarator:sym<native>")
  debug_860:
    $I10 = self.'from'()
    ne $I10, -1, rxscan671_done
    goto rxscan671_scan
  rxscan671_loop:
    (rx667_pos) = rx667_cur."from"()
    inc rx667_pos
    rx667_cur."!cursor_from"(rx667_pos)
    ge rx667_pos, rx667_eos, rxscan671_done
  rxscan671_scan:
    set_addr $I10, rxscan671_loop
    rx667_cur."!mark_push"(0, rx667_pos, $I10)
  rxscan671_done:
.annotate 'line', 332
    rx667_cur."!cursor_pos"(rx667_pos)
    get_hll_global $P672, ["PAST"], "Stmts"
    $P673 = $P672."new"()
    store_lex "$*PACKAGE-SETUP", $P673
.annotate 'line', 333
    rx667_cur."!cursor_pos"(rx667_pos)
    new $P674, "String"
    assign $P674, "native"
    store_lex "$*PKGDECL", $P674
.annotate 'line', 334
  # rx subcapture "sym"
    set_addr $I10, rxcap_675_fail
    rx667_cur."!mark_push"(0, rx667_pos, $I10)
  # rx literal  "native"
    add $I11, rx667_pos, 6
    gt $I11, rx667_eos, rx667_fail
    sub $I11, rx667_pos, rx667_off
    substr $S10, rx667_tgt, $I11, 6
    ne $S10, "native", rx667_fail
    add rx667_pos, 6
    set_addr $I10, rxcap_675_fail
    ($I12, $I11) = rx667_cur."!mark_peek"($I10)
    rx667_cur."!cursor_pos"($I11)
    ($P10) = rx667_cur."!cursor_start"()
    $P10."!cursor_pass"(rx667_pos, "")
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_675_done
  rxcap_675_fail:
    goto rx667_fail
  rxcap_675_done:
  # rx subrule "package_def" subtype=capture negate=
    rx667_cur."!cursor_pos"(rx667_pos)
    $P10 = rx667_cur."package_def"()
    unless $P10, rx667_fail
    rx667_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_def")
    rx667_pos = $P10."pos"()
.annotate 'line', 331
  # rx pass
    rx667_cur."!cursor_pass"(rx667_pos, "package_declarator:sym<native>")
    if_null rx667_debug, debug_861
    rx667_cur."!cursor_debug"("PASS", "package_declarator:sym<native>", " at pos=", rx667_pos)
  debug_861:
    .return (rx667_cur)
  rx667_restart:
.annotate 'line', 10
    if_null rx667_debug, debug_862
    rx667_cur."!cursor_debug"("NEXT", "package_declarator:sym<native>")
  debug_862:
  rx667_fail:
    (rx667_rep, rx667_pos, $I10, $P10) = rx667_cur."!mark_fail"(0)
    lt rx667_pos, -1, rx667_done
    eq rx667_pos, -1, rx667_fail
    jump $I10
  rx667_done:
    rx667_cur."!cursor_fail"()
    if_null rx667_debug, debug_863
    rx667_cur."!cursor_debug"("FAIL", "package_declarator:sym<native>")
  debug_863:
    .return (rx667_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_declarator:sym<native>"  :nsentry("!PREFIX__package_declarator:sym<native>") :subid("149_1300146757.646") :method
.annotate 'line', 10
    $P669 = self."!PREFIX__!subrule"("package_def", "native")
    new $P670, "ResizablePMCArray"
    push $P670, $P669
    .return ($P670)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "package_def"  :subid("150_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P700 = "152_1300146757.646" 
    capture_lex $P700
.annotate 'line', 338
    new $P677, "Undef"
    .lex "$*PKGMETA", $P677
.annotate 'line', 339
    $P678 = root_new ['parrot';'Hash']
    .lex "%*ATTR-CHECK", $P678
.annotate 'line', 10
    .local string rx679_tgt
    .local int rx679_pos
    .local int rx679_off
    .local int rx679_eos
    .local int rx679_rep
    .local pmc rx679_cur
    .local pmc rx679_debug
    (rx679_cur, rx679_pos, rx679_tgt, $I10) = self."!cursor_start"()
    rx679_cur."!cursor_caparray"("repr", "parent", "role")
    .lex unicode:"$\x{a2}", rx679_cur
    .local pmc match
    .lex "$/", match
    length rx679_eos, rx679_tgt
    gt rx679_pos, rx679_eos, rx679_done
    set rx679_off, 0
    lt rx679_pos, 2, rx679_start
    sub rx679_off, rx679_pos, 1
    substr rx679_tgt, rx679_tgt, rx679_off
  rx679_start:
    eq $I10, 1, rx679_restart
    if_null rx679_debug, debug_864
    rx679_cur."!cursor_debug"("START", "package_def")
  debug_864:
    $I10 = self.'from'()
    ne $I10, -1, rxscan683_done
    goto rxscan683_scan
  rxscan683_loop:
    (rx679_pos) = rx679_cur."from"()
    inc rx679_pos
    rx679_cur."!cursor_from"(rx679_pos)
    ge rx679_pos, rx679_eos, rxscan683_done
  rxscan683_scan:
    set_addr $I10, rxscan683_loop
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxscan683_done:
.annotate 'line', 337
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 338
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P685, "$*PKGMETA"
    unless_null $P685, vivify_865
    get_hll_global $P685, "$PKGMETA"
    unless_null $P685, vivify_866
    die "Contextual $*PKGMETA not found"
  vivify_866:
  vivify_865:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 339
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P687, "%*ATTR-CHECK"
    unless_null $P687, vivify_867
    get_hll_global $P687, "%ATTR-CHECK"
    unless_null $P687, vivify_868
    die "Contextual %*ATTR-CHECK not found"
  vivify_868:
  vivify_867:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 341
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 342
  # rx rxquantr690 ** 0..1
    set_addr $I10, rxquantr690_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr690_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx679_pos, 2
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 2
    ne $S10, "is", rx679_fail
    add rx679_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "repr("
    add $I11, rx679_pos, 5
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 5
    ne $S10, "repr(", rx679_fail
    add rx679_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."quote_EXPR"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("repr")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx679_pos, 1
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    ord $I11, rx679_tgt, $I11
    ne $I11, 41, rx679_fail
    add rx679_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr690_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
  rxquantr690_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 344
    rx679_cur."!cursor_pos"(rx679_pos)
    find_lex $P697, unicode:"$\x{a2}"
    $P698 = $P697."MATCH"()
    store_lex "$/", $P698
    .const 'Sub' $P700 = "152_1300146757.646" 
    capture_lex $P700
    $P726 = $P700()
.annotate 'line', 353
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 355
  # rx rxquantr728 ** 0..1
    set_addr $I10, rxquantr728_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr728_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "is"
    add $I11, rx679_pos, 2
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 2
    ne $S10, "is", rx679_fail
    add rx679_pos, 2
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parent")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr728_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
  rxquantr728_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 356
  # rx rxquantr733 ** 0..*
    set_addr $I10, rxquantr733_done
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
  rxquantr733_loop:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  "does"
    add $I11, rx679_pos, 4
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I11, 4
    ne $S10, "does", rx679_fail
    add rx679_pos, 4
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "name" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."name"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("role")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    set_addr $I10, rxquantr733_done
    (rx679_rep) = rx679_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr733_done
    rx679_cur."!mark_push"(rx679_rep, rx679_pos, $I10)
    goto rxquantr733_loop
  rxquantr733_done:
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  alt738_0:
.annotate 'line', 357
    set_addr $I10, alt738_1
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
.annotate 'line', 358
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx679_pos, 1
    gt $I11, rx679_eos, rx679_fail
    sub $I11, rx679_pos, rx679_off
    ord $I11, rx679_tgt, $I11
    ne $I11, 59, rx679_fail
    add rx679_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "comp_unit" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."comp_unit"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("comp_unit")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    goto alt738_end
  alt738_1:
    set_addr $I10, alt738_2
    rx679_cur."!mark_push"(0, rx679_pos, $I10)
.annotate 'line', 359
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx679_pos, rx679_off
    substr $S10, rx679_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx679_fail
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "block" subtype=capture negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."block"()
    unless $P10, rx679_fail
    rx679_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
    goto alt738_end
  alt738_2:
.annotate 'line', 360
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."panic"("Malformed package declaration")
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
  alt738_end:
.annotate 'line', 361
  # rx subrule "ws" subtype=method negate=
    rx679_cur."!cursor_pos"(rx679_pos)
    $P10 = rx679_cur."ws"()
    unless $P10, rx679_fail
    rx679_pos = $P10."pos"()
.annotate 'line', 337
  # rx pass
    rx679_cur."!cursor_pass"(rx679_pos, "package_def")
    if_null rx679_debug, debug_888
    rx679_cur."!cursor_debug"("PASS", "package_def", " at pos=", rx679_pos)
  debug_888:
    .return (rx679_cur)
  rx679_restart:
.annotate 'line', 10
    if_null rx679_debug, debug_889
    rx679_cur."!cursor_debug"("NEXT", "package_def")
  debug_889:
  rx679_fail:
    (rx679_rep, rx679_pos, $I10, $P10) = rx679_cur."!mark_fail"(0)
    lt rx679_pos, -1, rx679_done
    eq rx679_pos, -1, rx679_fail
    jump $I10
  rx679_done:
    rx679_cur."!cursor_fail"()
    if_null rx679_debug, debug_890
    rx679_cur."!cursor_debug"("FAIL", "package_def")
  debug_890:
    .return (rx679_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__package_def"  :nsentry("!PREFIX__package_def") :subid("151_1300146757.646") :method
.annotate 'line', 10
    $P681 = self."!PREFIX__!subrule"("ws", "")
    new $P682, "ResizablePMCArray"
    push $P682, $P681
    .return ($P682)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block699"  :anon :subid("152_1300146757.646") :outer("150_1300146757.646")
.annotate 'line', 347
    $P701 = root_new ['parrot';'Hash']
    .lex "%args", $P701
.annotate 'line', 344
    find_lex $P702, "%args"
.annotate 'line', 348
    find_lex $P703, "$/"
    unless_null $P703, vivify_869
    $P703 = root_new ['parrot';'Hash']
  vivify_869:
    set $P704, $P703["name"]
    unless_null $P704, vivify_870
    new $P704, "Undef"
  vivify_870:
    set $S705, $P704
    new $P706, 'String'
    set $P706, $S705
    find_lex $P707, "%args"
    unless_null $P707, vivify_871
    $P707 = root_new ['parrot';'Hash']
    store_lex "%args", $P707
  vivify_871:
    set $P707["name"], $P706
.annotate 'line', 349
    find_lex $P709, "$/"
    unless_null $P709, vivify_872
    $P709 = root_new ['parrot';'Hash']
  vivify_872:
    set $P710, $P709["repr"]
    unless_null $P710, vivify_873
    new $P710, "Undef"
  vivify_873:
    unless $P710, if_708_end
.annotate 'line', 350
    find_lex $P711, "$/"
    unless_null $P711, vivify_874
    $P711 = root_new ['parrot';'Hash']
  vivify_874:
    set $P712, $P711["repr"]
    unless_null $P712, vivify_875
    $P712 = root_new ['parrot';'ResizablePMCArray']
  vivify_875:
    set $P713, $P712[0]
    unless_null $P713, vivify_876
    $P713 = root_new ['parrot';'Hash']
  vivify_876:
    set $P714, $P713["quote_delimited"]
    unless_null $P714, vivify_877
    $P714 = root_new ['parrot';'Hash']
  vivify_877:
    set $P715, $P714["quote_atom"]
    unless_null $P715, vivify_878
    $P715 = root_new ['parrot';'ResizablePMCArray']
  vivify_878:
    set $P716, $P715[0]
    unless_null $P716, vivify_879
    new $P716, "Undef"
  vivify_879:
    set $S717, $P716
    new $P718, 'String'
    set $P718, $S717
    find_lex $P719, "%args"
    unless_null $P719, vivify_880
    $P719 = root_new ['parrot';'Hash']
    store_lex "%args", $P719
  vivify_880:
    set $P719["repr"], $P718
  if_708_end:
.annotate 'line', 352
    find_dynamic_lex $P720, "$*SC"
    unless_null $P720, vivify_881
    get_hll_global $P720, "$SC"
    unless_null $P720, vivify_882
    die "Contextual $*SC not found"
  vivify_882:
  vivify_881:
    find_dynamic_lex $P721, "$*PKGDECL"
    unless_null $P721, vivify_883
    get_hll_global $P721, "$PKGDECL"
    unless_null $P721, vivify_884
    die "Contextual $*PKGDECL not found"
  vivify_884:
  vivify_883:
    find_dynamic_lex $P722, "%*HOW"
    unless_null $P722, vivify_885
    get_hll_global $P722, "%HOW"
    unless_null $P722, vivify_886
    die "Contextual %*HOW not found"
  vivify_886:
  vivify_885:
    set $P723, $P722[$P721]
    unless_null $P723, vivify_887
    new $P723, "Undef"
  vivify_887:
    find_lex $P724, "%args"
    $P725 = $P720."pkg_create_mo"($P723, $P724 :flat)
    store_dynamic_lex "$*PKGMETA", $P725
.annotate 'line', 344
    .return ($P725)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator"  :subid("153_1300146757.646")
    .param pmc param_749
.annotate 'line', 364
    .lex "self", param_749
    $P750 = param_749."!protoregex"("scope_declarator")
    .return ($P750)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator"  :subid("154_1300146757.646")
    .param pmc param_752
.annotate 'line', 364
    .lex "self", param_752
    $P753 = param_752."!PREFIX__!protoregex"("scope_declarator")
    .return ($P753)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<my>"  :subid("155_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx755_tgt
    .local int rx755_pos
    .local int rx755_off
    .local int rx755_eos
    .local int rx755_rep
    .local pmc rx755_cur
    .local pmc rx755_debug
    (rx755_cur, rx755_pos, rx755_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx755_cur
    .local pmc match
    .lex "$/", match
    length rx755_eos, rx755_tgt
    gt rx755_pos, rx755_eos, rx755_done
    set rx755_off, 0
    lt rx755_pos, 2, rx755_start
    sub rx755_off, rx755_pos, 1
    substr rx755_tgt, rx755_tgt, rx755_off
  rx755_start:
    eq $I10, 1, rx755_restart
    if_null rx755_debug, debug_891
    rx755_cur."!cursor_debug"("START", "scope_declarator:sym<my>")
  debug_891:
    $I10 = self.'from'()
    ne $I10, -1, rxscan759_done
    goto rxscan759_scan
  rxscan759_loop:
    (rx755_pos) = rx755_cur."from"()
    inc rx755_pos
    rx755_cur."!cursor_from"(rx755_pos)
    ge rx755_pos, rx755_eos, rxscan759_done
  rxscan759_scan:
    set_addr $I10, rxscan759_loop
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  rxscan759_done:
.annotate 'line', 365
  # rx subcapture "sym"
    set_addr $I10, rxcap_760_fail
    rx755_cur."!mark_push"(0, rx755_pos, $I10)
  # rx literal  "my"
    add $I11, rx755_pos, 2
    gt $I11, rx755_eos, rx755_fail
    sub $I11, rx755_pos, rx755_off
    substr $S10, rx755_tgt, $I11, 2
    ne $S10, "my", rx755_fail
    add rx755_pos, 2
    set_addr $I10, rxcap_760_fail
    ($I12, $I11) = rx755_cur."!mark_peek"($I10)
    rx755_cur."!cursor_pos"($I11)
    ($P10) = rx755_cur."!cursor_start"()
    $P10."!cursor_pass"(rx755_pos, "")
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_760_done
  rxcap_760_fail:
    goto rx755_fail
  rxcap_760_done:
  # rx subrule "scoped" subtype=capture negate=
    rx755_cur."!cursor_pos"(rx755_pos)
    $P10 = rx755_cur."scoped"("my")
    unless $P10, rx755_fail
    rx755_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx755_pos = $P10."pos"()
  # rx pass
    rx755_cur."!cursor_pass"(rx755_pos, "scope_declarator:sym<my>")
    if_null rx755_debug, debug_892
    rx755_cur."!cursor_debug"("PASS", "scope_declarator:sym<my>", " at pos=", rx755_pos)
  debug_892:
    .return (rx755_cur)
  rx755_restart:
.annotate 'line', 10
    if_null rx755_debug, debug_893
    rx755_cur."!cursor_debug"("NEXT", "scope_declarator:sym<my>")
  debug_893:
  rx755_fail:
    (rx755_rep, rx755_pos, $I10, $P10) = rx755_cur."!mark_fail"(0)
    lt rx755_pos, -1, rx755_done
    eq rx755_pos, -1, rx755_fail
    jump $I10
  rx755_done:
    rx755_cur."!cursor_fail"()
    if_null rx755_debug, debug_894
    rx755_cur."!cursor_debug"("FAIL", "scope_declarator:sym<my>")
  debug_894:
    .return (rx755_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<my>"  :nsentry("!PREFIX__scope_declarator:sym<my>") :subid("156_1300146757.646") :method
.annotate 'line', 10
    $P757 = self."!PREFIX__!subrule"("scoped", "my")
    new $P758, "ResizablePMCArray"
    push $P758, $P757
    .return ($P758)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<our>"  :subid("157_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx762_tgt
    .local int rx762_pos
    .local int rx762_off
    .local int rx762_eos
    .local int rx762_rep
    .local pmc rx762_cur
    .local pmc rx762_debug
    (rx762_cur, rx762_pos, rx762_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx762_cur
    .local pmc match
    .lex "$/", match
    length rx762_eos, rx762_tgt
    gt rx762_pos, rx762_eos, rx762_done
    set rx762_off, 0
    lt rx762_pos, 2, rx762_start
    sub rx762_off, rx762_pos, 1
    substr rx762_tgt, rx762_tgt, rx762_off
  rx762_start:
    eq $I10, 1, rx762_restart
    if_null rx762_debug, debug_895
    rx762_cur."!cursor_debug"("START", "scope_declarator:sym<our>")
  debug_895:
    $I10 = self.'from'()
    ne $I10, -1, rxscan766_done
    goto rxscan766_scan
  rxscan766_loop:
    (rx762_pos) = rx762_cur."from"()
    inc rx762_pos
    rx762_cur."!cursor_from"(rx762_pos)
    ge rx762_pos, rx762_eos, rxscan766_done
  rxscan766_scan:
    set_addr $I10, rxscan766_loop
    rx762_cur."!mark_push"(0, rx762_pos, $I10)
  rxscan766_done:
.annotate 'line', 366
  # rx subcapture "sym"
    set_addr $I10, rxcap_767_fail
    rx762_cur."!mark_push"(0, rx762_pos, $I10)
  # rx literal  "our"
    add $I11, rx762_pos, 3
    gt $I11, rx762_eos, rx762_fail
    sub $I11, rx762_pos, rx762_off
    substr $S10, rx762_tgt, $I11, 3
    ne $S10, "our", rx762_fail
    add rx762_pos, 3
    set_addr $I10, rxcap_767_fail
    ($I12, $I11) = rx762_cur."!mark_peek"($I10)
    rx762_cur."!cursor_pos"($I11)
    ($P10) = rx762_cur."!cursor_start"()
    $P10."!cursor_pass"(rx762_pos, "")
    rx762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_767_done
  rxcap_767_fail:
    goto rx762_fail
  rxcap_767_done:
  # rx subrule "scoped" subtype=capture negate=
    rx762_cur."!cursor_pos"(rx762_pos)
    $P10 = rx762_cur."scoped"("our")
    unless $P10, rx762_fail
    rx762_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx762_pos = $P10."pos"()
  # rx pass
    rx762_cur."!cursor_pass"(rx762_pos, "scope_declarator:sym<our>")
    if_null rx762_debug, debug_896
    rx762_cur."!cursor_debug"("PASS", "scope_declarator:sym<our>", " at pos=", rx762_pos)
  debug_896:
    .return (rx762_cur)
  rx762_restart:
.annotate 'line', 10
    if_null rx762_debug, debug_897
    rx762_cur."!cursor_debug"("NEXT", "scope_declarator:sym<our>")
  debug_897:
  rx762_fail:
    (rx762_rep, rx762_pos, $I10, $P10) = rx762_cur."!mark_fail"(0)
    lt rx762_pos, -1, rx762_done
    eq rx762_pos, -1, rx762_fail
    jump $I10
  rx762_done:
    rx762_cur."!cursor_fail"()
    if_null rx762_debug, debug_898
    rx762_cur."!cursor_debug"("FAIL", "scope_declarator:sym<our>")
  debug_898:
    .return (rx762_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<our>"  :nsentry("!PREFIX__scope_declarator:sym<our>") :subid("158_1300146757.646") :method
.annotate 'line', 10
    $P764 = self."!PREFIX__!subrule"("scoped", "our")
    new $P765, "ResizablePMCArray"
    push $P765, $P764
    .return ($P765)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scope_declarator:sym<has>"  :subid("159_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx769_tgt
    .local int rx769_pos
    .local int rx769_off
    .local int rx769_eos
    .local int rx769_rep
    .local pmc rx769_cur
    .local pmc rx769_debug
    (rx769_cur, rx769_pos, rx769_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx769_cur
    .local pmc match
    .lex "$/", match
    length rx769_eos, rx769_tgt
    gt rx769_pos, rx769_eos, rx769_done
    set rx769_off, 0
    lt rx769_pos, 2, rx769_start
    sub rx769_off, rx769_pos, 1
    substr rx769_tgt, rx769_tgt, rx769_off
  rx769_start:
    eq $I10, 1, rx769_restart
    if_null rx769_debug, debug_899
    rx769_cur."!cursor_debug"("START", "scope_declarator:sym<has>")
  debug_899:
    $I10 = self.'from'()
    ne $I10, -1, rxscan773_done
    goto rxscan773_scan
  rxscan773_loop:
    (rx769_pos) = rx769_cur."from"()
    inc rx769_pos
    rx769_cur."!cursor_from"(rx769_pos)
    ge rx769_pos, rx769_eos, rxscan773_done
  rxscan773_scan:
    set_addr $I10, rxscan773_loop
    rx769_cur."!mark_push"(0, rx769_pos, $I10)
  rxscan773_done:
.annotate 'line', 367
  # rx subcapture "sym"
    set_addr $I10, rxcap_774_fail
    rx769_cur."!mark_push"(0, rx769_pos, $I10)
  # rx literal  "has"
    add $I11, rx769_pos, 3
    gt $I11, rx769_eos, rx769_fail
    sub $I11, rx769_pos, rx769_off
    substr $S10, rx769_tgt, $I11, 3
    ne $S10, "has", rx769_fail
    add rx769_pos, 3
    set_addr $I10, rxcap_774_fail
    ($I12, $I11) = rx769_cur."!mark_peek"($I10)
    rx769_cur."!cursor_pos"($I11)
    ($P10) = rx769_cur."!cursor_start"()
    $P10."!cursor_pass"(rx769_pos, "")
    rx769_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_774_done
  rxcap_774_fail:
    goto rx769_fail
  rxcap_774_done:
  # rx subrule "scoped" subtype=capture negate=
    rx769_cur."!cursor_pos"(rx769_pos)
    $P10 = rx769_cur."scoped"("has")
    unless $P10, rx769_fail
    rx769_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("scoped")
    rx769_pos = $P10."pos"()
  # rx pass
    rx769_cur."!cursor_pass"(rx769_pos, "scope_declarator:sym<has>")
    if_null rx769_debug, debug_900
    rx769_cur."!cursor_debug"("PASS", "scope_declarator:sym<has>", " at pos=", rx769_pos)
  debug_900:
    .return (rx769_cur)
  rx769_restart:
.annotate 'line', 10
    if_null rx769_debug, debug_901
    rx769_cur."!cursor_debug"("NEXT", "scope_declarator:sym<has>")
  debug_901:
  rx769_fail:
    (rx769_rep, rx769_pos, $I10, $P10) = rx769_cur."!mark_fail"(0)
    lt rx769_pos, -1, rx769_done
    eq rx769_pos, -1, rx769_fail
    jump $I10
  rx769_done:
    rx769_cur."!cursor_fail"()
    if_null rx769_debug, debug_902
    rx769_cur."!cursor_debug"("FAIL", "scope_declarator:sym<has>")
  debug_902:
    .return (rx769_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scope_declarator:sym<has>"  :nsentry("!PREFIX__scope_declarator:sym<has>") :subid("160_1300146757.646") :method
.annotate 'line', 10
    $P771 = self."!PREFIX__!subrule"("scoped", "has")
    new $P772, "ResizablePMCArray"
    push $P772, $P771
    .return ($P772)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "scoped"  :subid("161_1300146757.646") :method :outer("12_1300146757.646")
    .param pmc param_776
.annotate 'line', 369
    .lex "$*SCOPE", param_776
.annotate 'line', 10
    .local string rx777_tgt
    .local int rx777_pos
    .local int rx777_off
    .local int rx777_eos
    .local int rx777_rep
    .local pmc rx777_cur
    .local pmc rx777_debug
    (rx777_cur, rx777_pos, rx777_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx777_cur
    .local pmc match
    .lex "$/", match
    length rx777_eos, rx777_tgt
    gt rx777_pos, rx777_eos, rx777_done
    set rx777_off, 0
    lt rx777_pos, 2, rx777_start
    sub rx777_off, rx777_pos, 1
    substr rx777_tgt, rx777_tgt, rx777_off
  rx777_start:
    eq $I10, 1, rx777_restart
    if_null rx777_debug, debug_903
    rx777_cur."!cursor_debug"("START", "scoped")
  debug_903:
    $I10 = self.'from'()
    ne $I10, -1, rxscan783_done
    goto rxscan783_scan
  rxscan783_loop:
    (rx777_pos) = rx777_cur."from"()
    inc rx777_pos
    rx777_cur."!cursor_from"(rx777_pos)
    ge rx777_pos, rx777_eos, rxscan783_done
  rxscan783_scan:
    set_addr $I10, rxscan783_loop
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
  rxscan783_done:
  alt784_0:
.annotate 'line', 369
    set_addr $I10, alt784_1
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
.annotate 'line', 370
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
    goto alt784_end
  alt784_1:
    set_addr $I10, alt784_2
    rx777_cur."!mark_push"(0, rx777_pos, $I10)
.annotate 'line', 371
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "multi_declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."multi_declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("multi_declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
    goto alt784_end
  alt784_2:
.annotate 'line', 372
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  # rx subrule "package_declarator" subtype=capture negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."package_declarator"()
    unless $P10, rx777_fail
    rx777_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("package_declarator")
    rx777_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx777_cur."!cursor_pos"(rx777_pos)
    $P10 = rx777_cur."ws"()
    unless $P10, rx777_fail
    rx777_pos = $P10."pos"()
  alt784_end:
.annotate 'line', 369
  # rx pass
    rx777_cur."!cursor_pass"(rx777_pos, "scoped")
    if_null rx777_debug, debug_904
    rx777_cur."!cursor_debug"("PASS", "scoped", " at pos=", rx777_pos)
  debug_904:
    .return (rx777_cur)
  rx777_restart:
.annotate 'line', 10
    if_null rx777_debug, debug_905
    rx777_cur."!cursor_debug"("NEXT", "scoped")
  debug_905:
  rx777_fail:
    (rx777_rep, rx777_pos, $I10, $P10) = rx777_cur."!mark_fail"(0)
    lt rx777_pos, -1, rx777_done
    eq rx777_pos, -1, rx777_fail
    jump $I10
  rx777_done:
    rx777_cur."!cursor_fail"()
    if_null rx777_debug, debug_906
    rx777_cur."!cursor_debug"("FAIL", "scoped")
  debug_906:
    .return (rx777_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__scoped"  :nsentry("!PREFIX__scoped") :subid("162_1300146757.646") :method
.annotate 'line', 10
    $P779 = self."!PREFIX__!subrule"("ws", "")
    $P780 = self."!PREFIX__!subrule"("ws", "")
    $P781 = self."!PREFIX__!subrule"("ws", "")
    new $P782, "ResizablePMCArray"
    push $P782, $P779
    push $P782, $P780
    push $P782, $P781
    .return ($P782)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "typename"  :subid("163_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx792_tgt
    .local int rx792_pos
    .local int rx792_off
    .local int rx792_eos
    .local int rx792_rep
    .local pmc rx792_cur
    .local pmc rx792_debug
    (rx792_cur, rx792_pos, rx792_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx792_cur
    .local pmc match
    .lex "$/", match
    length rx792_eos, rx792_tgt
    gt rx792_pos, rx792_eos, rx792_done
    set rx792_off, 0
    lt rx792_pos, 2, rx792_start
    sub rx792_off, rx792_pos, 1
    substr rx792_tgt, rx792_tgt, rx792_off
  rx792_start:
    eq $I10, 1, rx792_restart
    if_null rx792_debug, debug_907
    rx792_cur."!cursor_debug"("START", "typename")
  debug_907:
    $I10 = self.'from'()
    ne $I10, -1, rxscan796_done
    goto rxscan796_scan
  rxscan796_loop:
    (rx792_pos) = rx792_cur."from"()
    inc rx792_pos
    rx792_cur."!cursor_from"(rx792_pos)
    ge rx792_pos, rx792_eos, rxscan796_done
  rxscan796_scan:
    set_addr $I10, rxscan796_loop
    rx792_cur."!mark_push"(0, rx792_pos, $I10)
  rxscan796_done:
.annotate 'line', 375
  # rx subrule "name" subtype=capture negate=
    rx792_cur."!cursor_pos"(rx792_pos)
    $P10 = rx792_cur."name"()
    unless $P10, rx792_fail
    rx792_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx792_pos = $P10."pos"()
  # rx pass
    rx792_cur."!cursor_pass"(rx792_pos, "typename")
    if_null rx792_debug, debug_908
    rx792_cur."!cursor_debug"("PASS", "typename", " at pos=", rx792_pos)
  debug_908:
    .return (rx792_cur)
  rx792_restart:
.annotate 'line', 10
    if_null rx792_debug, debug_909
    rx792_cur."!cursor_debug"("NEXT", "typename")
  debug_909:
  rx792_fail:
    (rx792_rep, rx792_pos, $I10, $P10) = rx792_cur."!mark_fail"(0)
    lt rx792_pos, -1, rx792_done
    eq rx792_pos, -1, rx792_fail
    jump $I10
  rx792_done:
    rx792_cur."!cursor_fail"()
    if_null rx792_debug, debug_910
    rx792_cur."!cursor_debug"("FAIL", "typename")
  debug_910:
    .return (rx792_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__typename"  :nsentry("!PREFIX__typename") :subid("164_1300146757.646") :method
.annotate 'line', 10
    $P794 = self."!PREFIX__!subrule"("name", "")
    new $P795, "ResizablePMCArray"
    push $P795, $P794
    .return ($P795)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "declarator"  :subid("165_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx798_tgt
    .local int rx798_pos
    .local int rx798_off
    .local int rx798_eos
    .local int rx798_rep
    .local pmc rx798_cur
    .local pmc rx798_debug
    (rx798_cur, rx798_pos, rx798_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx798_cur
    .local pmc match
    .lex "$/", match
    length rx798_eos, rx798_tgt
    gt rx798_pos, rx798_eos, rx798_done
    set rx798_off, 0
    lt rx798_pos, 2, rx798_start
    sub rx798_off, rx798_pos, 1
    substr rx798_tgt, rx798_tgt, rx798_off
  rx798_start:
    eq $I10, 1, rx798_restart
    if_null rx798_debug, debug_911
    rx798_cur."!cursor_debug"("START", "declarator")
  debug_911:
    $I10 = self.'from'()
    ne $I10, -1, rxscan803_done
    goto rxscan803_scan
  rxscan803_loop:
    (rx798_pos) = rx798_cur."from"()
    inc rx798_pos
    rx798_cur."!cursor_from"(rx798_pos)
    ge rx798_pos, rx798_eos, rxscan803_done
  rxscan803_scan:
    set_addr $I10, rxscan803_loop
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
  rxscan803_done:
  alt804_0:
.annotate 'line', 377
    set_addr $I10, alt804_1
    rx798_cur."!mark_push"(0, rx798_pos, $I10)
.annotate 'line', 378
  # rx subrule "variable_declarator" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."variable_declarator"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable_declarator")
    rx798_pos = $P10."pos"()
    goto alt804_end
  alt804_1:
.annotate 'line', 379
  # rx subrule "routine_declarator" subtype=capture negate=
    rx798_cur."!cursor_pos"(rx798_pos)
    $P10 = rx798_cur."routine_declarator"()
    unless $P10, rx798_fail
    rx798_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_declarator")
    rx798_pos = $P10."pos"()
  alt804_end:
.annotate 'line', 377
  # rx pass
    rx798_cur."!cursor_pass"(rx798_pos, "declarator")
    if_null rx798_debug, debug_912
    rx798_cur."!cursor_debug"("PASS", "declarator", " at pos=", rx798_pos)
  debug_912:
    .return (rx798_cur)
  rx798_restart:
.annotate 'line', 10
    if_null rx798_debug, debug_913
    rx798_cur."!cursor_debug"("NEXT", "declarator")
  debug_913:
  rx798_fail:
    (rx798_rep, rx798_pos, $I10, $P10) = rx798_cur."!mark_fail"(0)
    lt rx798_pos, -1, rx798_done
    eq rx798_pos, -1, rx798_fail
    jump $I10
  rx798_done:
    rx798_cur."!cursor_fail"()
    if_null rx798_debug, debug_914
    rx798_cur."!cursor_debug"("FAIL", "declarator")
  debug_914:
    .return (rx798_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__declarator"  :nsentry("!PREFIX__declarator") :subid("166_1300146757.646") :method
.annotate 'line', 10
    $P800 = self."!PREFIX__!subrule"("routine_declarator", "")
    $P801 = self."!PREFIX__!subrule"("variable_declarator", "")
    new $P802, "ResizablePMCArray"
    push $P802, $P800
    push $P802, $P801
    .return ($P802)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "variable_declarator"  :subid("167_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx806_tgt
    .local int rx806_pos
    .local int rx806_off
    .local int rx806_eos
    .local int rx806_rep
    .local pmc rx806_cur
    .local pmc rx806_debug
    (rx806_cur, rx806_pos, rx806_tgt, $I10) = self."!cursor_start"()
    rx806_cur."!cursor_caparray"("typename")
    .lex unicode:"$\x{a2}", rx806_cur
    .local pmc match
    .lex "$/", match
    length rx806_eos, rx806_tgt
    gt rx806_pos, rx806_eos, rx806_done
    set rx806_off, 0
    lt rx806_pos, 2, rx806_start
    sub rx806_off, rx806_pos, 1
    substr rx806_tgt, rx806_tgt, rx806_off
  rx806_start:
    eq $I10, 1, rx806_restart
    if_null rx806_debug, debug_915
    rx806_cur."!cursor_debug"("START", "variable_declarator")
  debug_915:
    $I10 = self.'from'()
    ne $I10, -1, rxscan810_done
    goto rxscan810_scan
  rxscan810_loop:
    (rx806_pos) = rx806_cur."from"()
    inc rx806_pos
    rx806_cur."!cursor_from"(rx806_pos)
    ge rx806_pos, rx806_eos, rxscan810_done
  rxscan810_scan:
    set_addr $I10, rxscan810_loop
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxscan810_done:
.annotate 'line', 382
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx rxquantr812 ** 0..1
    set_addr $I10, rxquantr812_done
    rx806_cur."!mark_push"(0, rx806_pos, $I10)
  rxquantr812_loop:
  # rx subrule "typename" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."typename"()
    unless $P10, rx806_fail
    goto rxsubrule813_pass
  rxsubrule813_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx806_fail
  rxsubrule813_pass:
    set_addr $I10, rxsubrule813_back
    rx806_cur."!mark_push"(0, rx806_pos, $I10, $P10)
    $P10."!cursor_names"("typename")
    rx806_pos = $P10."pos"()
    set_addr $I10, rxquantr812_done
    (rx806_rep) = rx806_cur."!mark_commit"($I10)
  rxquantr812_done:
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx subrule "variable" subtype=capture negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."variable"()
    unless $P10, rx806_fail
    rx806_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx806_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx806_cur."!cursor_pos"(rx806_pos)
    $P10 = rx806_cur."ws"()
    unless $P10, rx806_fail
    rx806_pos = $P10."pos"()
  # rx pass
    rx806_cur."!cursor_pass"(rx806_pos, "variable_declarator")
    if_null rx806_debug, debug_916
    rx806_cur."!cursor_debug"("PASS", "variable_declarator", " at pos=", rx806_pos)
  debug_916:
    .return (rx806_cur)
  rx806_restart:
.annotate 'line', 10
    if_null rx806_debug, debug_917
    rx806_cur."!cursor_debug"("NEXT", "variable_declarator")
  debug_917:
  rx806_fail:
    (rx806_rep, rx806_pos, $I10, $P10) = rx806_cur."!mark_fail"(0)
    lt rx806_pos, -1, rx806_done
    eq rx806_pos, -1, rx806_fail
    jump $I10
  rx806_done:
    rx806_cur."!cursor_fail"()
    if_null rx806_debug, debug_918
    rx806_cur."!cursor_debug"("FAIL", "variable_declarator")
  debug_918:
    .return (rx806_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__variable_declarator"  :nsentry("!PREFIX__variable_declarator") :subid("168_1300146757.646") :method
.annotate 'line', 10
    $P808 = self."!PREFIX__!subrule"("ws", "")
    new $P809, "ResizablePMCArray"
    push $P809, $P808
    .return ($P809)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator"  :subid("169_1300146757.646")
    .param pmc param_817
.annotate 'line', 384
    .lex "self", param_817
    $P818 = param_817."!protoregex"("routine_declarator")
    .return ($P818)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator"  :subid("170_1300146757.646")
    .param pmc param_820
.annotate 'line', 384
    .lex "self", param_820
    $P821 = param_820."!PREFIX__!protoregex"("routine_declarator")
    .return ($P821)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<sub>"  :subid("171_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx823_tgt
    .local int rx823_pos
    .local int rx823_off
    .local int rx823_eos
    .local int rx823_rep
    .local pmc rx823_cur
    .local pmc rx823_debug
    (rx823_cur, rx823_pos, rx823_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx823_cur
    .local pmc match
    .lex "$/", match
    length rx823_eos, rx823_tgt
    gt rx823_pos, rx823_eos, rx823_done
    set rx823_off, 0
    lt rx823_pos, 2, rx823_start
    sub rx823_off, rx823_pos, 1
    substr rx823_tgt, rx823_tgt, rx823_off
  rx823_start:
    eq $I10, 1, rx823_restart
    if_null rx823_debug, debug_919
    rx823_cur."!cursor_debug"("START", "routine_declarator:sym<sub>")
  debug_919:
    $I10 = self.'from'()
    ne $I10, -1, rxscan827_done
    goto rxscan827_scan
  rxscan827_loop:
    (rx823_pos) = rx823_cur."from"()
    inc rx823_pos
    rx823_cur."!cursor_from"(rx823_pos)
    ge rx823_pos, rx823_eos, rxscan827_done
  rxscan827_scan:
    set_addr $I10, rxscan827_loop
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  rxscan827_done:
.annotate 'line', 385
  # rx subcapture "sym"
    set_addr $I10, rxcap_828_fail
    rx823_cur."!mark_push"(0, rx823_pos, $I10)
  # rx literal  "sub"
    add $I11, rx823_pos, 3
    gt $I11, rx823_eos, rx823_fail
    sub $I11, rx823_pos, rx823_off
    substr $S10, rx823_tgt, $I11, 3
    ne $S10, "sub", rx823_fail
    add rx823_pos, 3
    set_addr $I10, rxcap_828_fail
    ($I12, $I11) = rx823_cur."!mark_peek"($I10)
    rx823_cur."!cursor_pos"($I11)
    ($P10) = rx823_cur."!cursor_start"()
    $P10."!cursor_pass"(rx823_pos, "")
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_828_done
  rxcap_828_fail:
    goto rx823_fail
  rxcap_828_done:
  # rx subrule "routine_def" subtype=capture negate=
    rx823_cur."!cursor_pos"(rx823_pos)
    $P10 = rx823_cur."routine_def"()
    unless $P10, rx823_fail
    rx823_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx823_pos = $P10."pos"()
  # rx pass
    rx823_cur."!cursor_pass"(rx823_pos, "routine_declarator:sym<sub>")
    if_null rx823_debug, debug_920
    rx823_cur."!cursor_debug"("PASS", "routine_declarator:sym<sub>", " at pos=", rx823_pos)
  debug_920:
    .return (rx823_cur)
  rx823_restart:
.annotate 'line', 10
    if_null rx823_debug, debug_921
    rx823_cur."!cursor_debug"("NEXT", "routine_declarator:sym<sub>")
  debug_921:
  rx823_fail:
    (rx823_rep, rx823_pos, $I10, $P10) = rx823_cur."!mark_fail"(0)
    lt rx823_pos, -1, rx823_done
    eq rx823_pos, -1, rx823_fail
    jump $I10
  rx823_done:
    rx823_cur."!cursor_fail"()
    if_null rx823_debug, debug_922
    rx823_cur."!cursor_debug"("FAIL", "routine_declarator:sym<sub>")
  debug_922:
    .return (rx823_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<sub>"  :nsentry("!PREFIX__routine_declarator:sym<sub>") :subid("172_1300146757.646") :method
.annotate 'line', 10
    $P825 = self."!PREFIX__!subrule"("routine_def", "sub")
    new $P826, "ResizablePMCArray"
    push $P826, $P825
    .return ($P826)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_declarator:sym<method>"  :subid("173_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx830_tgt
    .local int rx830_pos
    .local int rx830_off
    .local int rx830_eos
    .local int rx830_rep
    .local pmc rx830_cur
    .local pmc rx830_debug
    (rx830_cur, rx830_pos, rx830_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx830_cur
    .local pmc match
    .lex "$/", match
    length rx830_eos, rx830_tgt
    gt rx830_pos, rx830_eos, rx830_done
    set rx830_off, 0
    lt rx830_pos, 2, rx830_start
    sub rx830_off, rx830_pos, 1
    substr rx830_tgt, rx830_tgt, rx830_off
  rx830_start:
    eq $I10, 1, rx830_restart
    if_null rx830_debug, debug_923
    rx830_cur."!cursor_debug"("START", "routine_declarator:sym<method>")
  debug_923:
    $I10 = self.'from'()
    ne $I10, -1, rxscan834_done
    goto rxscan834_scan
  rxscan834_loop:
    (rx830_pos) = rx830_cur."from"()
    inc rx830_pos
    rx830_cur."!cursor_from"(rx830_pos)
    ge rx830_pos, rx830_eos, rxscan834_done
  rxscan834_scan:
    set_addr $I10, rxscan834_loop
    rx830_cur."!mark_push"(0, rx830_pos, $I10)
  rxscan834_done:
.annotate 'line', 386
  # rx subcapture "sym"
    set_addr $I10, rxcap_835_fail
    rx830_cur."!mark_push"(0, rx830_pos, $I10)
  # rx literal  "method"
    add $I11, rx830_pos, 6
    gt $I11, rx830_eos, rx830_fail
    sub $I11, rx830_pos, rx830_off
    substr $S10, rx830_tgt, $I11, 6
    ne $S10, "method", rx830_fail
    add rx830_pos, 6
    set_addr $I10, rxcap_835_fail
    ($I12, $I11) = rx830_cur."!mark_peek"($I10)
    rx830_cur."!cursor_pos"($I11)
    ($P10) = rx830_cur."!cursor_start"()
    $P10."!cursor_pass"(rx830_pos, "")
    rx830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_835_done
  rxcap_835_fail:
    goto rx830_fail
  rxcap_835_done:
  # rx subrule "method_def" subtype=capture negate=
    rx830_cur."!cursor_pos"(rx830_pos)
    $P10 = rx830_cur."method_def"()
    unless $P10, rx830_fail
    rx830_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("method_def")
    rx830_pos = $P10."pos"()
  # rx pass
    rx830_cur."!cursor_pass"(rx830_pos, "routine_declarator:sym<method>")
    if_null rx830_debug, debug_924
    rx830_cur."!cursor_debug"("PASS", "routine_declarator:sym<method>", " at pos=", rx830_pos)
  debug_924:
    .return (rx830_cur)
  rx830_restart:
.annotate 'line', 10
    if_null rx830_debug, debug_925
    rx830_cur."!cursor_debug"("NEXT", "routine_declarator:sym<method>")
  debug_925:
  rx830_fail:
    (rx830_rep, rx830_pos, $I10, $P10) = rx830_cur."!mark_fail"(0)
    lt rx830_pos, -1, rx830_done
    eq rx830_pos, -1, rx830_fail
    jump $I10
  rx830_done:
    rx830_cur."!cursor_fail"()
    if_null rx830_debug, debug_926
    rx830_cur."!cursor_debug"("FAIL", "routine_declarator:sym<method>")
  debug_926:
    .return (rx830_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_declarator:sym<method>"  :nsentry("!PREFIX__routine_declarator:sym<method>") :subid("174_1300146757.646") :method
.annotate 'line', 10
    $P832 = self."!PREFIX__!subrule"("method_def", "method")
    new $P833, "ResizablePMCArray"
    push $P833, $P832
    .return ($P833)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "routine_def"  :subid("175_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 389
    new $P837, "Undef"
    .lex "$*RETURN_USED", $P837
.annotate 'line', 10
    .local string rx838_tgt
    .local int rx838_pos
    .local int rx838_off
    .local int rx838_eos
    .local int rx838_rep
    .local pmc rx838_cur
    .local pmc rx838_debug
    (rx838_cur, rx838_pos, rx838_tgt, $I10) = self."!cursor_start"()
    rx838_cur."!cursor_caparray"("sigil", "deflongname", "trait")
    .lex unicode:"$\x{a2}", rx838_cur
    .local pmc match
    .lex "$/", match
    length rx838_eos, rx838_tgt
    gt rx838_pos, rx838_eos, rx838_done
    set rx838_off, 0
    lt rx838_pos, 2, rx838_start
    sub rx838_off, rx838_pos, 1
    substr rx838_tgt, rx838_tgt, rx838_off
  rx838_start:
    eq $I10, 1, rx838_restart
    if_null rx838_debug, debug_927
    rx838_cur."!cursor_debug"("START", "routine_def")
  debug_927:
    $I10 = self.'from'()
    ne $I10, -1, rxscan842_done
    goto rxscan842_scan
  rxscan842_loop:
    (rx838_pos) = rx838_cur."from"()
    inc rx838_pos
    rx838_cur."!cursor_from"(rx838_pos)
    ge rx838_pos, rx838_eos, rxscan842_done
  rxscan842_scan:
    set_addr $I10, rxscan842_loop
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxscan842_done:
.annotate 'line', 388
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 389
    rx838_cur."!cursor_pos"(rx838_pos)
    new $P844, "Integer"
    assign $P844, 0
    store_lex "$*RETURN_USED", $P844
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 390
  # rx rxquantr846 ** 0..1
    set_addr $I10, rxquantr846_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr846_loop:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subcapture "sigil"
    set_addr $I10, rxcap_849_fail
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  # rx rxquantr848 ** 0..1
    set_addr $I10, rxquantr848_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr848_loop:
  # rx literal  "&"
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 38, rx838_fail
    add rx838_pos, 1
    set_addr $I10, rxquantr848_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
  rxquantr848_done:
    set_addr $I10, rxcap_849_fail
    ($I12, $I11) = rx838_cur."!mark_peek"($I10)
    rx838_cur."!cursor_pos"($I11)
    ($P10) = rx838_cur."!cursor_start"()
    $P10."!cursor_pass"(rx838_pos, "")
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    goto rxcap_849_done
  rxcap_849_fail:
    goto rx838_fail
  rxcap_849_done:
  # rx subrule "deflongname" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."deflongname"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    set_addr $I10, rxquantr846_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
  rxquantr846_done:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 391
  # rx subrule "newpad" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."newpad"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt853_0:
.annotate 'line', 392
    set_addr $I10, alt853_1
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 40, rx838_fail
    add rx838_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."signature"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx838_pos, 1
    gt $I11, rx838_eos, rx838_fail
    sub $I11, rx838_pos, rx838_off
    ord $I11, rx838_tgt, $I11
    ne $I11, 41, rx838_fail
    add rx838_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    goto alt853_end
  alt853_1:
.annotate 'line', 393
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt853_end:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 394
  # rx rxquantr861 ** 0..*
    set_addr $I10, rxquantr861_done
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
  rxquantr861_loop:
  # rx subrule "trait" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."trait"()
    unless $P10, rx838_fail
    goto rxsubrule862_pass
  rxsubrule862_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx838_fail
  rxsubrule862_pass:
    set_addr $I10, rxsubrule862_back
    rx838_cur."!mark_push"(0, rx838_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx838_pos = $P10."pos"()
    set_addr $I10, rxquantr861_done
    (rx838_rep) = rx838_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr861_done
    rx838_cur."!mark_push"(rx838_rep, rx838_pos, $I10)
    goto rxquantr861_loop
  rxquantr861_done:
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt864_0:
.annotate 'line', 395
    set_addr $I10, alt864_1
    rx838_cur."!mark_push"(0, rx838_pos, $I10)
.annotate 'line', 396
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."onlystar"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
    goto alt864_end
  alt864_1:
.annotate 'line', 397
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."blockoid"()
    unless $P10, rx838_fail
    rx838_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx838_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
  alt864_end:
.annotate 'line', 398
  # rx subrule "ws" subtype=method negate=
    rx838_cur."!cursor_pos"(rx838_pos)
    $P10 = rx838_cur."ws"()
    unless $P10, rx838_fail
    rx838_pos = $P10."pos"()
.annotate 'line', 388
  # rx pass
    rx838_cur."!cursor_pass"(rx838_pos, "routine_def")
    if_null rx838_debug, debug_928
    rx838_cur."!cursor_debug"("PASS", "routine_def", " at pos=", rx838_pos)
  debug_928:
    .return (rx838_cur)
  rx838_restart:
.annotate 'line', 10
    if_null rx838_debug, debug_929
    rx838_cur."!cursor_debug"("NEXT", "routine_def")
  debug_929:
  rx838_fail:
    (rx838_rep, rx838_pos, $I10, $P10) = rx838_cur."!mark_fail"(0)
    lt rx838_pos, -1, rx838_done
    eq rx838_pos, -1, rx838_fail
    jump $I10
  rx838_done:
    rx838_cur."!cursor_fail"()
    if_null rx838_debug, debug_930
    rx838_cur."!cursor_debug"("FAIL", "routine_def")
  debug_930:
    .return (rx838_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__routine_def"  :nsentry("!PREFIX__routine_def") :subid("176_1300146757.646") :method
.annotate 'line', 10
    $P840 = self."!PREFIX__!subrule"("ws", "")
    new $P841, "ResizablePMCArray"
    push $P841, $P840
    .return ($P841)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "method_def"  :subid("177_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P901 = "179_1300146757.646" 
    capture_lex $P901
.annotate 'line', 402
    new $P871, "Undef"
    .lex "$*RETURN_USED", $P871
.annotate 'line', 403
    new $P872, "Undef"
    .lex "$*INVOCANT_OK", $P872
.annotate 'line', 10
    .local string rx873_tgt
    .local int rx873_pos
    .local int rx873_off
    .local int rx873_eos
    .local int rx873_rep
    .local pmc rx873_cur
    .local pmc rx873_debug
    (rx873_cur, rx873_pos, rx873_tgt, $I10) = self."!cursor_start"()
    rx873_cur."!cursor_caparray"("deflongname", "trait")
    .lex unicode:"$\x{a2}", rx873_cur
    .local pmc match
    .lex "$/", match
    length rx873_eos, rx873_tgt
    gt rx873_pos, rx873_eos, rx873_done
    set rx873_off, 0
    lt rx873_pos, 2, rx873_start
    sub rx873_off, rx873_pos, 1
    substr rx873_tgt, rx873_tgt, rx873_off
  rx873_start:
    eq $I10, 1, rx873_restart
    if_null rx873_debug, debug_931
    rx873_cur."!cursor_debug"("START", "method_def")
  debug_931:
    $I10 = self.'from'()
    ne $I10, -1, rxscan877_done
    goto rxscan877_scan
  rxscan877_loop:
    (rx873_pos) = rx873_cur."from"()
    inc rx873_pos
    rx873_cur."!cursor_from"(rx873_pos)
    ge rx873_pos, rx873_eos, rxscan877_done
  rxscan877_scan:
    set_addr $I10, rxscan877_loop
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxscan877_done:
.annotate 'line', 401
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 402
    rx873_cur."!cursor_pos"(rx873_pos)
    new $P879, "Integer"
    assign $P879, 0
    store_lex "$*RETURN_USED", $P879
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 403
    rx873_cur."!cursor_pos"(rx873_pos)
    new $P881, "Integer"
    assign $P881, 1
    store_lex "$*INVOCANT_OK", $P881
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 404
  # rx subcapture "private"
    set_addr $I10, rxcap_884_fail
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  # rx rxquantr883 ** 0..1
    set_addr $I10, rxquantr883_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr883_loop:
  # rx literal  "!"
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 33, rx873_fail
    add rx873_pos, 1
    set_addr $I10, rxquantr883_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
  rxquantr883_done:
    set_addr $I10, rxcap_884_fail
    ($I12, $I11) = rx873_cur."!mark_peek"($I10)
    rx873_cur."!cursor_pos"($I11)
    ($P10) = rx873_cur."!cursor_start"()
    $P10."!cursor_pass"(rx873_pos, "")
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("private")
    goto rxcap_884_done
  rxcap_884_fail:
    goto rx873_fail
  rxcap_884_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 405
  # rx rxquantr886 ** 0..1
    set_addr $I10, rxquantr886_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr886_loop:
  # rx subrule "deflongname" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."deflongname"()
    unless $P10, rx873_fail
    goto rxsubrule887_pass
  rxsubrule887_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx873_fail
  rxsubrule887_pass:
    set_addr $I10, rxsubrule887_back
    rx873_cur."!mark_push"(0, rx873_pos, $I10, $P10)
    $P10."!cursor_names"("deflongname")
    rx873_pos = $P10."pos"()
    set_addr $I10, rxquantr886_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
  rxquantr886_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 406
  # rx subrule "newpad" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."newpad"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt890_0:
.annotate 'line', 407
    set_addr $I10, alt890_1
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 40, rx873_fail
    add rx873_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."signature"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx873_pos, 1
    gt $I11, rx873_eos, rx873_fail
    sub $I11, rx873_pos, rx873_off
    ord $I11, rx873_tgt, $I11
    ne $I11, 41, rx873_fail
    add rx873_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
    goto alt890_end
  alt890_1:
.annotate 'line', 408
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."panic"("Routine declaration requires a signature")
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt890_end:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 409
    rx873_cur."!cursor_pos"(rx873_pos)
    find_lex $P898, unicode:"$\x{a2}"
    $P899 = $P898."MATCH"()
    store_lex "$/", $P899
    .const 'Sub' $P901 = "179_1300146757.646" 
    capture_lex $P901
    $P903 = $P901()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 410
  # rx rxquantr905 ** 0..*
    set_addr $I10, rxquantr905_done
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
  rxquantr905_loop:
  # rx subrule "trait" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."trait"()
    unless $P10, rx873_fail
    goto rxsubrule906_pass
  rxsubrule906_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx873_fail
  rxsubrule906_pass:
    set_addr $I10, rxsubrule906_back
    rx873_cur."!mark_push"(0, rx873_pos, $I10, $P10)
    $P10."!cursor_names"("trait")
    rx873_pos = $P10."pos"()
    set_addr $I10, rxquantr905_done
    (rx873_rep) = rx873_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr905_done
    rx873_cur."!mark_push"(rx873_rep, rx873_pos, $I10)
    goto rxquantr905_loop
  rxquantr905_done:
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt908_0:
.annotate 'line', 411
    set_addr $I10, alt908_1
    rx873_cur."!mark_push"(0, rx873_pos, $I10)
.annotate 'line', 412
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "onlystar" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."onlystar"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("onlystar")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
    goto alt908_end
  alt908_1:
.annotate 'line', 413
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  # rx subrule "blockoid" subtype=capture negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."blockoid"()
    unless $P10, rx873_fail
    rx873_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("blockoid")
    rx873_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
  alt908_end:
.annotate 'line', 414
  # rx subrule "ws" subtype=method negate=
    rx873_cur."!cursor_pos"(rx873_pos)
    $P10 = rx873_cur."ws"()
    unless $P10, rx873_fail
    rx873_pos = $P10."pos"()
.annotate 'line', 401
  # rx pass
    rx873_cur."!cursor_pass"(rx873_pos, "method_def")
    if_null rx873_debug, debug_932
    rx873_cur."!cursor_debug"("PASS", "method_def", " at pos=", rx873_pos)
  debug_932:
    .return (rx873_cur)
  rx873_restart:
.annotate 'line', 10
    if_null rx873_debug, debug_933
    rx873_cur."!cursor_debug"("NEXT", "method_def")
  debug_933:
  rx873_fail:
    (rx873_rep, rx873_pos, $I10, $P10) = rx873_cur."!mark_fail"(0)
    lt rx873_pos, -1, rx873_done
    eq rx873_pos, -1, rx873_fail
    jump $I10
  rx873_done:
    rx873_cur."!cursor_fail"()
    if_null rx873_debug, debug_934
    rx873_cur."!cursor_debug"("FAIL", "method_def")
  debug_934:
    .return (rx873_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__method_def"  :nsentry("!PREFIX__method_def") :subid("178_1300146757.646") :method
.annotate 'line', 10
    $P875 = self."!PREFIX__!subrule"("ws", "")
    new $P876, "ResizablePMCArray"
    push $P876, $P875
    .return ($P876)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block900"  :anon :subid("179_1300146757.646") :outer("177_1300146757.646")
.annotate 'line', 409
    new $P902, "Integer"
    assign $P902, 0
    store_dynamic_lex "$*INVOCANT_OK", $P902
    .return ($P902)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "onlystar"  :subid("180_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P922 = "182_1300146757.646" 
    capture_lex $P922
    .local string rx915_tgt
    .local int rx915_pos
    .local int rx915_off
    .local int rx915_eos
    .local int rx915_rep
    .local pmc rx915_cur
    .local pmc rx915_debug
    (rx915_cur, rx915_pos, rx915_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx915_cur
    .local pmc match
    .lex "$/", match
    length rx915_eos, rx915_tgt
    gt rx915_pos, rx915_eos, rx915_done
    set rx915_off, 0
    lt rx915_pos, 2, rx915_start
    sub rx915_off, rx915_pos, 1
    substr rx915_tgt, rx915_tgt, rx915_off
  rx915_start:
    eq $I10, 1, rx915_restart
    if_null rx915_debug, debug_935
    rx915_cur."!cursor_debug"("START", "onlystar")
  debug_935:
    $I10 = self.'from'()
    ne $I10, -1, rxscan918_done
    goto rxscan918_scan
  rxscan918_loop:
    (rx915_pos) = rx915_cur."from"()
    inc rx915_pos
    rx915_cur."!cursor_from"(rx915_pos)
    ge rx915_pos, rx915_eos, rxscan918_done
  rxscan918_scan:
    set_addr $I10, rxscan918_loop
    rx915_cur."!mark_push"(0, rx915_pos, $I10)
  rxscan918_done:
.annotate 'line', 418
    rx915_cur."!cursor_pos"(rx915_pos)
    find_lex $P919, unicode:"$\x{a2}"
    $P920 = $P919."MATCH"()
    store_lex "$/", $P920
    .const 'Sub' $P922 = "182_1300146757.646" 
    capture_lex $P922
    $P926 = $P922()
    unless $P926, rx915_fail
.annotate 'line', 419
  # rx literal  "{"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 123, rx915_fail
    add rx915_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ws"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
  # rx literal  "*"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 42, rx915_fail
    add rx915_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ws"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx915_pos, 1
    gt $I11, rx915_eos, rx915_fail
    sub $I11, rx915_pos, rx915_off
    ord $I11, rx915_tgt, $I11
    ne $I11, 125, rx915_fail
    add rx915_pos, 1
.annotate 'line', 420
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."ENDSTMT"()
    unless $P10, rx915_fail
.annotate 'line', 421
  # rx subrule "finishpad" subtype=method negate=
    rx915_cur."!cursor_pos"(rx915_pos)
    $P10 = rx915_cur."finishpad"()
    unless $P10, rx915_fail
    rx915_pos = $P10."pos"()
.annotate 'line', 417
  # rx pass
    rx915_cur."!cursor_pass"(rx915_pos, "onlystar")
    if_null rx915_debug, debug_938
    rx915_cur."!cursor_debug"("PASS", "onlystar", " at pos=", rx915_pos)
  debug_938:
    .return (rx915_cur)
  rx915_restart:
.annotate 'line', 10
    if_null rx915_debug, debug_939
    rx915_cur."!cursor_debug"("NEXT", "onlystar")
  debug_939:
  rx915_fail:
    (rx915_rep, rx915_pos, $I10, $P10) = rx915_cur."!mark_fail"(0)
    lt rx915_pos, -1, rx915_done
    eq rx915_pos, -1, rx915_fail
    jump $I10
  rx915_done:
    rx915_cur."!cursor_fail"()
    if_null rx915_debug, debug_940
    rx915_cur."!cursor_debug"("FAIL", "onlystar")
  debug_940:
    .return (rx915_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__onlystar"  :nsentry("!PREFIX__onlystar") :subid("181_1300146757.646") :method
.annotate 'line', 10
    new $P917, "ResizablePMCArray"
    push $P917, ""
    .return ($P917)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block921"  :anon :subid("182_1300146757.646") :outer("180_1300146757.646")
.annotate 'line', 418
    find_dynamic_lex $P923, "$*MULTINESS"
    unless_null $P923, vivify_936
    get_hll_global $P923, "$MULTINESS"
    unless_null $P923, vivify_937
    die "Contextual $*MULTINESS not found"
  vivify_937:
  vivify_936:
    set $S924, $P923
    iseq $I925, $S924, "proto"
    .return ($I925)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator"  :subid("183_1300146757.646")
    .param pmc param_928
.annotate 'line', 424
    .lex "self", param_928
    $P929 = param_928."!protoregex"("multi_declarator")
    .return ($P929)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator"  :subid("184_1300146757.646")
    .param pmc param_931
.annotate 'line', 424
    .lex "self", param_931
    $P932 = param_931."!PREFIX__!protoregex"("multi_declarator")
    .return ($P932)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<multi>"  :subid("185_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 426
    new $P934, "Undef"
    .lex "$*MULTINESS", $P934
.annotate 'line', 10
    .local string rx935_tgt
    .local int rx935_pos
    .local int rx935_off
    .local int rx935_eos
    .local int rx935_rep
    .local pmc rx935_cur
    .local pmc rx935_debug
    (rx935_cur, rx935_pos, rx935_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx935_cur
    .local pmc match
    .lex "$/", match
    length rx935_eos, rx935_tgt
    gt rx935_pos, rx935_eos, rx935_done
    set rx935_off, 0
    lt rx935_pos, 2, rx935_start
    sub rx935_off, rx935_pos, 1
    substr rx935_tgt, rx935_tgt, rx935_off
  rx935_start:
    eq $I10, 1, rx935_restart
    if_null rx935_debug, debug_941
    rx935_cur."!cursor_debug"("START", "multi_declarator:sym<multi>")
  debug_941:
    $I10 = self.'from'()
    ne $I10, -1, rxscan939_done
    goto rxscan939_scan
  rxscan939_loop:
    (rx935_pos) = rx935_cur."from"()
    inc rx935_pos
    rx935_cur."!cursor_from"(rx935_pos)
    ge rx935_pos, rx935_eos, rxscan939_done
  rxscan939_scan:
    set_addr $I10, rxscan939_loop
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  rxscan939_done:
.annotate 'line', 426
    rx935_cur."!cursor_pos"(rx935_pos)
    new $P940, "String"
    assign $P940, "multi"
    store_lex "$*MULTINESS", $P940
.annotate 'line', 427
  # rx subcapture "sym"
    set_addr $I10, rxcap_941_fail
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx literal  "multi"
    add $I11, rx935_pos, 5
    gt $I11, rx935_eos, rx935_fail
    sub $I11, rx935_pos, rx935_off
    substr $S10, rx935_tgt, $I11, 5
    ne $S10, "multi", rx935_fail
    add rx935_pos, 5
    set_addr $I10, rxcap_941_fail
    ($I12, $I11) = rx935_cur."!mark_peek"($I10)
    rx935_cur."!cursor_pos"($I11)
    ($P10) = rx935_cur."!cursor_start"()
    $P10."!cursor_pass"(rx935_pos, "")
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_941_done
  rxcap_941_fail:
    goto rx935_fail
  rxcap_941_done:
.annotate 'line', 428
  # rx subrule "ws" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."ws"()
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  alt942_0:
    set_addr $I10, alt942_1
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."declarator"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx935_pos = $P10."pos"()
    goto alt942_end
  alt942_1:
    set_addr $I10, alt942_2
    rx935_cur."!mark_push"(0, rx935_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."routine_def"()
    unless $P10, rx935_fail
    rx935_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx935_pos = $P10."pos"()
    goto alt942_end
  alt942_2:
  # rx subrule "panic" subtype=method negate=
    rx935_cur."!cursor_pos"(rx935_pos)
    $P10 = rx935_cur."panic"("Malformed multi")
    unless $P10, rx935_fail
    rx935_pos = $P10."pos"()
  alt942_end:
.annotate 'line', 425
  # rx pass
    rx935_cur."!cursor_pass"(rx935_pos, "multi_declarator:sym<multi>")
    if_null rx935_debug, debug_942
    rx935_cur."!cursor_debug"("PASS", "multi_declarator:sym<multi>", " at pos=", rx935_pos)
  debug_942:
    .return (rx935_cur)
  rx935_restart:
.annotate 'line', 10
    if_null rx935_debug, debug_943
    rx935_cur."!cursor_debug"("NEXT", "multi_declarator:sym<multi>")
  debug_943:
  rx935_fail:
    (rx935_rep, rx935_pos, $I10, $P10) = rx935_cur."!mark_fail"(0)
    lt rx935_pos, -1, rx935_done
    eq rx935_pos, -1, rx935_fail
    jump $I10
  rx935_done:
    rx935_cur."!cursor_fail"()
    if_null rx935_debug, debug_944
    rx935_cur."!cursor_debug"("FAIL", "multi_declarator:sym<multi>")
  debug_944:
    .return (rx935_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<multi>"  :nsentry("!PREFIX__multi_declarator:sym<multi>") :subid("186_1300146757.646") :method
.annotate 'line', 10
    $P937 = self."!PREFIX__!subrule"("ws", "multi")
    new $P938, "ResizablePMCArray"
    push $P938, $P937
    .return ($P938)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<proto>"  :subid("187_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 431
    new $P944, "Undef"
    .lex "$*MULTINESS", $P944
.annotate 'line', 10
    .local string rx945_tgt
    .local int rx945_pos
    .local int rx945_off
    .local int rx945_eos
    .local int rx945_rep
    .local pmc rx945_cur
    .local pmc rx945_debug
    (rx945_cur, rx945_pos, rx945_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx945_cur
    .local pmc match
    .lex "$/", match
    length rx945_eos, rx945_tgt
    gt rx945_pos, rx945_eos, rx945_done
    set rx945_off, 0
    lt rx945_pos, 2, rx945_start
    sub rx945_off, rx945_pos, 1
    substr rx945_tgt, rx945_tgt, rx945_off
  rx945_start:
    eq $I10, 1, rx945_restart
    if_null rx945_debug, debug_945
    rx945_cur."!cursor_debug"("START", "multi_declarator:sym<proto>")
  debug_945:
    $I10 = self.'from'()
    ne $I10, -1, rxscan949_done
    goto rxscan949_scan
  rxscan949_loop:
    (rx945_pos) = rx945_cur."from"()
    inc rx945_pos
    rx945_cur."!cursor_from"(rx945_pos)
    ge rx945_pos, rx945_eos, rxscan949_done
  rxscan949_scan:
    set_addr $I10, rxscan949_loop
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  rxscan949_done:
.annotate 'line', 431
    rx945_cur."!cursor_pos"(rx945_pos)
    new $P950, "String"
    assign $P950, "proto"
    store_lex "$*MULTINESS", $P950
.annotate 'line', 432
  # rx subcapture "sym"
    set_addr $I10, rxcap_951_fail
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx literal  "proto"
    add $I11, rx945_pos, 5
    gt $I11, rx945_eos, rx945_fail
    sub $I11, rx945_pos, rx945_off
    substr $S10, rx945_tgt, $I11, 5
    ne $S10, "proto", rx945_fail
    add rx945_pos, 5
    set_addr $I10, rxcap_951_fail
    ($I12, $I11) = rx945_cur."!mark_peek"($I10)
    rx945_cur."!cursor_pos"($I11)
    ($P10) = rx945_cur."!cursor_start"()
    $P10."!cursor_pass"(rx945_pos, "")
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_951_done
  rxcap_951_fail:
    goto rx945_fail
  rxcap_951_done:
.annotate 'line', 433
  # rx subrule "ws" subtype=method negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."ws"()
    unless $P10, rx945_fail
    rx945_pos = $P10."pos"()
  alt952_0:
    set_addr $I10, alt952_1
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx subrule "declarator" subtype=capture negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."declarator"()
    unless $P10, rx945_fail
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx945_pos = $P10."pos"()
    goto alt952_end
  alt952_1:
    set_addr $I10, alt952_2
    rx945_cur."!mark_push"(0, rx945_pos, $I10)
  # rx subrule "routine_def" subtype=capture negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."routine_def"()
    unless $P10, rx945_fail
    rx945_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("routine_def")
    rx945_pos = $P10."pos"()
    goto alt952_end
  alt952_2:
  # rx subrule "panic" subtype=method negate=
    rx945_cur."!cursor_pos"(rx945_pos)
    $P10 = rx945_cur."panic"("Malformed proto")
    unless $P10, rx945_fail
    rx945_pos = $P10."pos"()
  alt952_end:
.annotate 'line', 430
  # rx pass
    rx945_cur."!cursor_pass"(rx945_pos, "multi_declarator:sym<proto>")
    if_null rx945_debug, debug_946
    rx945_cur."!cursor_debug"("PASS", "multi_declarator:sym<proto>", " at pos=", rx945_pos)
  debug_946:
    .return (rx945_cur)
  rx945_restart:
.annotate 'line', 10
    if_null rx945_debug, debug_947
    rx945_cur."!cursor_debug"("NEXT", "multi_declarator:sym<proto>")
  debug_947:
  rx945_fail:
    (rx945_rep, rx945_pos, $I10, $P10) = rx945_cur."!mark_fail"(0)
    lt rx945_pos, -1, rx945_done
    eq rx945_pos, -1, rx945_fail
    jump $I10
  rx945_done:
    rx945_cur."!cursor_fail"()
    if_null rx945_debug, debug_948
    rx945_cur."!cursor_debug"("FAIL", "multi_declarator:sym<proto>")
  debug_948:
    .return (rx945_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<proto>"  :nsentry("!PREFIX__multi_declarator:sym<proto>") :subid("188_1300146757.646") :method
.annotate 'line', 10
    $P947 = self."!PREFIX__!subrule"("ws", "proto")
    new $P948, "ResizablePMCArray"
    push $P948, $P947
    .return ($P948)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "multi_declarator:sym<null>"  :subid("189_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 436
    new $P954, "Undef"
    .lex "$*MULTINESS", $P954
.annotate 'line', 10
    .local string rx955_tgt
    .local int rx955_pos
    .local int rx955_off
    .local int rx955_eos
    .local int rx955_rep
    .local pmc rx955_cur
    .local pmc rx955_debug
    (rx955_cur, rx955_pos, rx955_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx955_cur
    .local pmc match
    .lex "$/", match
    length rx955_eos, rx955_tgt
    gt rx955_pos, rx955_eos, rx955_done
    set rx955_off, 0
    lt rx955_pos, 2, rx955_start
    sub rx955_off, rx955_pos, 1
    substr rx955_tgt, rx955_tgt, rx955_off
  rx955_start:
    eq $I10, 1, rx955_restart
    if_null rx955_debug, debug_949
    rx955_cur."!cursor_debug"("START", "multi_declarator:sym<null>")
  debug_949:
    $I10 = self.'from'()
    ne $I10, -1, rxscan959_done
    goto rxscan959_scan
  rxscan959_loop:
    (rx955_pos) = rx955_cur."from"()
    inc rx955_pos
    rx955_cur."!cursor_from"(rx955_pos)
    ge rx955_pos, rx955_eos, rxscan959_done
  rxscan959_scan:
    set_addr $I10, rxscan959_loop
    rx955_cur."!mark_push"(0, rx955_pos, $I10)
  rxscan959_done:
.annotate 'line', 436
    rx955_cur."!cursor_pos"(rx955_pos)
    new $P960, "String"
    assign $P960, ""
    store_lex "$*MULTINESS", $P960
.annotate 'line', 437
  # rx subrule "declarator" subtype=capture negate=
    rx955_cur."!cursor_pos"(rx955_pos)
    $P10 = rx955_cur."declarator"()
    unless $P10, rx955_fail
    rx955_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("declarator")
    rx955_pos = $P10."pos"()
.annotate 'line', 435
  # rx pass
    rx955_cur."!cursor_pass"(rx955_pos, "multi_declarator:sym<null>")
    if_null rx955_debug, debug_950
    rx955_cur."!cursor_debug"("PASS", "multi_declarator:sym<null>", " at pos=", rx955_pos)
  debug_950:
    .return (rx955_cur)
  rx955_restart:
.annotate 'line', 10
    if_null rx955_debug, debug_951
    rx955_cur."!cursor_debug"("NEXT", "multi_declarator:sym<null>")
  debug_951:
  rx955_fail:
    (rx955_rep, rx955_pos, $I10, $P10) = rx955_cur."!mark_fail"(0)
    lt rx955_pos, -1, rx955_done
    eq rx955_pos, -1, rx955_fail
    jump $I10
  rx955_done:
    rx955_cur."!cursor_fail"()
    if_null rx955_debug, debug_952
    rx955_cur."!cursor_debug"("FAIL", "multi_declarator:sym<null>")
  debug_952:
    .return (rx955_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__multi_declarator:sym<null>"  :nsentry("!PREFIX__multi_declarator:sym<null>") :subid("190_1300146757.646") :method
.annotate 'line', 10
    $P957 = self."!PREFIX__!subrule"("declarator", "")
    new $P958, "ResizablePMCArray"
    push $P958, $P957
    .return ($P958)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "signature"  :subid("191_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P970 = "193_1300146757.646" 
    capture_lex $P970
    .local string rx962_tgt
    .local int rx962_pos
    .local int rx962_off
    .local int rx962_eos
    .local int rx962_rep
    .local pmc rx962_cur
    .local pmc rx962_debug
    (rx962_cur, rx962_pos, rx962_tgt, $I10) = self."!cursor_start"()
    rx962_cur."!cursor_caparray"("invocant", "parameter")
    .lex unicode:"$\x{a2}", rx962_cur
    .local pmc match
    .lex "$/", match
    length rx962_eos, rx962_tgt
    gt rx962_pos, rx962_eos, rx962_done
    set rx962_off, 0
    lt rx962_pos, 2, rx962_start
    sub rx962_off, rx962_pos, 1
    substr rx962_tgt, rx962_tgt, rx962_off
  rx962_start:
    eq $I10, 1, rx962_restart
    if_null rx962_debug, debug_953
    rx962_cur."!cursor_debug"("START", "signature")
  debug_953:
    $I10 = self.'from'()
    ne $I10, -1, rxscan965_done
    goto rxscan965_scan
  rxscan965_loop:
    (rx962_pos) = rx962_cur."from"()
    inc rx962_pos
    rx962_cur."!cursor_from"(rx962_pos)
    ge rx962_pos, rx962_eos, rxscan965_done
  rxscan965_scan:
    set_addr $I10, rxscan965_loop
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxscan965_done:
.annotate 'line', 441
  # rx rxquantr966 ** 0..1
    set_addr $I10, rxquantr966_done
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxquantr966_loop:
    rx962_cur."!cursor_pos"(rx962_pos)
    find_lex $P967, unicode:"$\x{a2}"
    $P968 = $P967."MATCH"()
    store_lex "$/", $P968
    .const 'Sub' $P970 = "193_1300146757.646" 
    capture_lex $P970
    $P972 = $P970()
    unless $P972, rx962_fail
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."parameter"()
    unless $P10, rx962_fail
    rx962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("invocant")
    rx962_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx literal  ":"
    add $I11, rx962_pos, 1
    gt $I11, rx962_eos, rx962_fail
    sub $I11, rx962_pos, rx962_off
    ord $I11, rx962_tgt, $I11
    ne $I11, 58, rx962_fail
    add rx962_pos, 1
    set_addr $I10, rxquantr966_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
  rxquantr966_done:
.annotate 'line', 442
  # rx rxquantr973 ** 0..1
    set_addr $I10, rxquantr973_done
    rx962_cur."!mark_push"(0, rx962_pos, $I10)
  rxquantr973_loop:
  # rx rxquantr974 ** 1..*
    set_addr $I10, rxquantr974_done
    rx962_cur."!mark_push"(0, -1, $I10)
  rxquantr974_loop:
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
  # rx subrule "parameter" subtype=capture negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."parameter"()
    unless $P10, rx962_fail
    rx962_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("parameter")
    rx962_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx962_cur."!cursor_pos"(rx962_pos)
    $P10 = rx962_cur."ws"()
    unless $P10, rx962_fail
    rx962_pos = $P10."pos"()
    set_addr $I10, rxquantr974_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr974_done
    rx962_cur."!mark_push"(rx962_rep, rx962_pos, $I10)
  # rx literal  ","
    add $I11, rx962_pos, 1
    gt $I11, rx962_eos, rx962_fail
    sub $I11, rx962_pos, rx962_off
    ord $I11, rx962_tgt, $I11
    ne $I11, 44, rx962_fail
    add rx962_pos, 1
    goto rxquantr974_loop
  rxquantr974_done:
    set_addr $I10, rxquantr973_done
    (rx962_rep) = rx962_cur."!mark_commit"($I10)
  rxquantr973_done:
.annotate 'line', 440
  # rx pass
    rx962_cur."!cursor_pass"(rx962_pos, "signature")
    if_null rx962_debug, debug_956
    rx962_cur."!cursor_debug"("PASS", "signature", " at pos=", rx962_pos)
  debug_956:
    .return (rx962_cur)
  rx962_restart:
.annotate 'line', 10
    if_null rx962_debug, debug_957
    rx962_cur."!cursor_debug"("NEXT", "signature")
  debug_957:
  rx962_fail:
    (rx962_rep, rx962_pos, $I10, $P10) = rx962_cur."!mark_fail"(0)
    lt rx962_pos, -1, rx962_done
    eq rx962_pos, -1, rx962_fail
    jump $I10
  rx962_done:
    rx962_cur."!cursor_fail"()
    if_null rx962_debug, debug_958
    rx962_cur."!cursor_debug"("FAIL", "signature")
  debug_958:
    .return (rx962_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__signature"  :nsentry("!PREFIX__signature") :subid("192_1300146757.646") :method
.annotate 'line', 10
    new $P964, "ResizablePMCArray"
    push $P964, ""
    .return ($P964)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block969"  :anon :subid("193_1300146757.646") :outer("191_1300146757.646")
.annotate 'line', 441
    find_dynamic_lex $P971, "$*INVOCANT_OK"
    unless_null $P971, vivify_954
    get_hll_global $P971, "$INVOCANT_OK"
    unless_null $P971, vivify_955
    die "Contextual $*INVOCANT_OK not found"
  vivify_955:
  vivify_954:
    .return ($P971)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "parameter"  :subid("194_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx976_tgt
    .local int rx976_pos
    .local int rx976_off
    .local int rx976_eos
    .local int rx976_rep
    .local pmc rx976_cur
    .local pmc rx976_debug
    (rx976_cur, rx976_pos, rx976_tgt, $I10) = self."!cursor_start"()
    rx976_cur."!cursor_caparray"("typename", "definedness", "default_value")
    .lex unicode:"$\x{a2}", rx976_cur
    .local pmc match
    .lex "$/", match
    length rx976_eos, rx976_tgt
    gt rx976_pos, rx976_eos, rx976_done
    set rx976_off, 0
    lt rx976_pos, 2, rx976_start
    sub rx976_off, rx976_pos, 1
    substr rx976_tgt, rx976_tgt, rx976_off
  rx976_start:
    eq $I10, 1, rx976_restart
    if_null rx976_debug, debug_959
    rx976_cur."!cursor_debug"("START", "parameter")
  debug_959:
    $I10 = self.'from'()
    ne $I10, -1, rxscan979_done
    goto rxscan979_scan
  rxscan979_loop:
    (rx976_pos) = rx976_cur."from"()
    inc rx976_pos
    rx976_cur."!cursor_from"(rx976_pos)
    ge rx976_pos, rx976_eos, rxscan979_done
  rxscan979_scan:
    set_addr $I10, rxscan979_loop
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxscan979_done:
.annotate 'line', 446
  # rx rxquantr980 ** 0..*
    set_addr $I10, rxquantr980_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr980_loop:
  # rx subrule "typename" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."typename"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("typename")
    rx976_pos = $P10."pos"()
  # rx rxquantr981 ** 0..1
    set_addr $I10, rxquantr981_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr981_loop:
  # rx literal  ":"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 58, rx976_fail
    add rx976_pos, 1
  # rx subcapture "definedness"
    set_addr $I10, rxcap_982_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx976_pos, rx976_eos, rx976_fail
    sub $I10, rx976_pos, rx976_off
    substr $S10, rx976_tgt, $I10, 1
    index $I11, "_DU", $S10
    lt $I11, 0, rx976_fail
    inc rx976_pos
    set_addr $I10, rxcap_982_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("definedness")
    goto rxcap_982_done
  rxcap_982_fail:
    goto rx976_fail
  rxcap_982_done:
    set_addr $I10, rxquantr981_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
  rxquantr981_done:
  # rx subrule "ws" subtype=method negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."ws"()
    unless $P10, rx976_fail
    rx976_pos = $P10."pos"()
    set_addr $I10, rxquantr980_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
    set_addr $I10, rxquantr980_done
    rx976_cur."!mark_push"(rx976_rep, rx976_pos, $I10)
    goto rxquantr980_loop
  rxquantr980_done:
  alt983_0:
.annotate 'line', 447
    set_addr $I10, alt983_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
.annotate 'line', 448
  # rx subcapture "quant"
    set_addr $I10, rxcap_984_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "*"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 42, rx976_fail
    add rx976_pos, 1
    set_addr $I10, rxcap_984_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_984_done
  rxcap_984_fail:
    goto rx976_fail
  rxcap_984_done:
  # rx subrule "param_var" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."param_var"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx976_pos = $P10."pos"()
    goto alt983_end
  alt983_1:
  alt985_0:
.annotate 'line', 449
    set_addr $I10, alt985_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx subrule "param_var" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."param_var"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx976_pos = $P10."pos"()
    goto alt985_end
  alt985_1:
  # rx subrule "named_param" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."named_param"()
    unless $P10, rx976_fail
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("named_param")
    rx976_pos = $P10."pos"()
  alt985_end:
  # rx subcapture "quant"
    set_addr $I10, rxcap_987_fail
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  alt986_0:
    set_addr $I10, alt986_1
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "?"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 63, rx976_fail
    add rx976_pos, 1
    goto alt986_end
  alt986_1:
    set_addr $I10, alt986_2
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  # rx literal  "!"
    add $I11, rx976_pos, 1
    gt $I11, rx976_eos, rx976_fail
    sub $I11, rx976_pos, rx976_off
    ord $I11, rx976_tgt, $I11
    ne $I11, 33, rx976_fail
    add rx976_pos, 1
    goto alt986_end
  alt986_2:
  alt986_end:
    set_addr $I10, rxcap_987_fail
    ($I12, $I11) = rx976_cur."!mark_peek"($I10)
    rx976_cur."!cursor_pos"($I11)
    ($P10) = rx976_cur."!cursor_start"()
    $P10."!cursor_pass"(rx976_pos, "")
    rx976_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quant")
    goto rxcap_987_done
  rxcap_987_fail:
    goto rx976_fail
  rxcap_987_done:
  alt983_end:
.annotate 'line', 451
  # rx rxquantr988 ** 0..1
    set_addr $I10, rxquantr988_done
    rx976_cur."!mark_push"(0, rx976_pos, $I10)
  rxquantr988_loop:
  # rx subrule "default_value" subtype=capture negate=
    rx976_cur."!cursor_pos"(rx976_pos)
    $P10 = rx976_cur."default_value"()
    unless $P10, rx976_fail
    goto rxsubrule989_pass
  rxsubrule989_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx976_fail
  rxsubrule989_pass:
    set_addr $I10, rxsubrule989_back
    rx976_cur."!mark_push"(0, rx976_pos, $I10, $P10)
    $P10."!cursor_names"("default_value")
    rx976_pos = $P10."pos"()
    set_addr $I10, rxquantr988_done
    (rx976_rep) = rx976_cur."!mark_commit"($I10)
  rxquantr988_done:
.annotate 'line', 445
  # rx pass
    rx976_cur."!cursor_pass"(rx976_pos, "parameter")
    if_null rx976_debug, debug_960
    rx976_cur."!cursor_debug"("PASS", "parameter", " at pos=", rx976_pos)
  debug_960:
    .return (rx976_cur)
  rx976_restart:
.annotate 'line', 10
    if_null rx976_debug, debug_961
    rx976_cur."!cursor_debug"("NEXT", "parameter")
  debug_961:
  rx976_fail:
    (rx976_rep, rx976_pos, $I10, $P10) = rx976_cur."!mark_fail"(0)
    lt rx976_pos, -1, rx976_done
    eq rx976_pos, -1, rx976_fail
    jump $I10
  rx976_done:
    rx976_cur."!cursor_fail"()
    if_null rx976_debug, debug_962
    rx976_cur."!cursor_debug"("FAIL", "parameter")
  debug_962:
    .return (rx976_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__parameter"  :nsentry("!PREFIX__parameter") :subid("195_1300146757.646") :method
.annotate 'line', 10
    new $P978, "ResizablePMCArray"
    push $P978, ""
    .return ($P978)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "param_var"  :subid("196_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx991_tgt
    .local int rx991_pos
    .local int rx991_off
    .local int rx991_eos
    .local int rx991_rep
    .local pmc rx991_cur
    .local pmc rx991_debug
    (rx991_cur, rx991_pos, rx991_tgt, $I10) = self."!cursor_start"()
    rx991_cur."!cursor_caparray"("twigil")
    .lex unicode:"$\x{a2}", rx991_cur
    .local pmc match
    .lex "$/", match
    length rx991_eos, rx991_tgt
    gt rx991_pos, rx991_eos, rx991_done
    set rx991_off, 0
    lt rx991_pos, 2, rx991_start
    sub rx991_off, rx991_pos, 1
    substr rx991_tgt, rx991_tgt, rx991_off
  rx991_start:
    eq $I10, 1, rx991_restart
    if_null rx991_debug, debug_963
    rx991_cur."!cursor_debug"("START", "param_var")
  debug_963:
    $I10 = self.'from'()
    ne $I10, -1, rxscan995_done
    goto rxscan995_scan
  rxscan995_loop:
    (rx991_pos) = rx991_cur."from"()
    inc rx991_pos
    rx991_cur."!cursor_from"(rx991_pos)
    ge rx991_pos, rx991_eos, rxscan995_done
  rxscan995_scan:
    set_addr $I10, rxscan995_loop
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  rxscan995_done:
.annotate 'line', 455
  # rx subrule "sigil" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."sigil"()
    unless $P10, rx991_fail
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx991_pos = $P10."pos"()
  # rx rxquantr996 ** 0..1
    set_addr $I10, rxquantr996_done
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  rxquantr996_loop:
  # rx subrule "twigil" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."twigil"()
    unless $P10, rx991_fail
    goto rxsubrule997_pass
  rxsubrule997_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx991_fail
  rxsubrule997_pass:
    set_addr $I10, rxsubrule997_back
    rx991_cur."!mark_push"(0, rx991_pos, $I10, $P10)
    $P10."!cursor_names"("twigil")
    rx991_pos = $P10."pos"()
    set_addr $I10, rxquantr996_done
    (rx991_rep) = rx991_cur."!mark_commit"($I10)
  rxquantr996_done:
  alt998_0:
.annotate 'line', 456
    set_addr $I10, alt998_1
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  # rx subrule "ident" subtype=capture negate=
    rx991_cur."!cursor_pos"(rx991_pos)
    $P10 = rx991_cur."ident"()
    unless $P10, rx991_fail
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx991_pos = $P10."pos"()
    goto alt998_end
  alt998_1:
  # rx subcapture "name"
    set_addr $I10, rxcap_999_fail
    rx991_cur."!mark_push"(0, rx991_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx991_pos, rx991_eos, rx991_fail
    sub $I10, rx991_pos, rx991_off
    substr $S10, rx991_tgt, $I10, 1
    index $I11, "/!", $S10
    lt $I11, 0, rx991_fail
    inc rx991_pos
    set_addr $I10, rxcap_999_fail
    ($I12, $I11) = rx991_cur."!mark_peek"($I10)
    rx991_cur."!cursor_pos"($I11)
    ($P10) = rx991_cur."!cursor_start"()
    $P10."!cursor_pass"(rx991_pos, "")
    rx991_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    goto rxcap_999_done
  rxcap_999_fail:
    goto rx991_fail
  rxcap_999_done:
  alt998_end:
.annotate 'line', 454
  # rx pass
    rx991_cur."!cursor_pass"(rx991_pos, "param_var")
    if_null rx991_debug, debug_964
    rx991_cur."!cursor_debug"("PASS", "param_var", " at pos=", rx991_pos)
  debug_964:
    .return (rx991_cur)
  rx991_restart:
.annotate 'line', 10
    if_null rx991_debug, debug_965
    rx991_cur."!cursor_debug"("NEXT", "param_var")
  debug_965:
  rx991_fail:
    (rx991_rep, rx991_pos, $I10, $P10) = rx991_cur."!mark_fail"(0)
    lt rx991_pos, -1, rx991_done
    eq rx991_pos, -1, rx991_fail
    jump $I10
  rx991_done:
    rx991_cur."!cursor_fail"()
    if_null rx991_debug, debug_966
    rx991_cur."!cursor_debug"("FAIL", "param_var")
  debug_966:
    .return (rx991_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__param_var"  :nsentry("!PREFIX__param_var") :subid("197_1300146757.646") :method
.annotate 'line', 10
    $P993 = self."!PREFIX__!subrule"("sigil", "")
    new $P994, "ResizablePMCArray"
    push $P994, $P993
    .return ($P994)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "named_param"  :subid("198_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1001_tgt
    .local int rx1001_pos
    .local int rx1001_off
    .local int rx1001_eos
    .local int rx1001_rep
    .local pmc rx1001_cur
    .local pmc rx1001_debug
    (rx1001_cur, rx1001_pos, rx1001_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1001_cur
    .local pmc match
    .lex "$/", match
    length rx1001_eos, rx1001_tgt
    gt rx1001_pos, rx1001_eos, rx1001_done
    set rx1001_off, 0
    lt rx1001_pos, 2, rx1001_start
    sub rx1001_off, rx1001_pos, 1
    substr rx1001_tgt, rx1001_tgt, rx1001_off
  rx1001_start:
    eq $I10, 1, rx1001_restart
    if_null rx1001_debug, debug_967
    rx1001_cur."!cursor_debug"("START", "named_param")
  debug_967:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1005_done
    goto rxscan1005_scan
  rxscan1005_loop:
    (rx1001_pos) = rx1001_cur."from"()
    inc rx1001_pos
    rx1001_cur."!cursor_from"(rx1001_pos)
    ge rx1001_pos, rx1001_eos, rxscan1005_done
  rxscan1005_scan:
    set_addr $I10, rxscan1005_loop
    rx1001_cur."!mark_push"(0, rx1001_pos, $I10)
  rxscan1005_done:
.annotate 'line', 460
  # rx literal  ":"
    add $I11, rx1001_pos, 1
    gt $I11, rx1001_eos, rx1001_fail
    sub $I11, rx1001_pos, rx1001_off
    ord $I11, rx1001_tgt, $I11
    ne $I11, 58, rx1001_fail
    add rx1001_pos, 1
  # rx subrule "param_var" subtype=capture negate=
    rx1001_cur."!cursor_pos"(rx1001_pos)
    $P10 = rx1001_cur."param_var"()
    unless $P10, rx1001_fail
    rx1001_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("param_var")
    rx1001_pos = $P10."pos"()
.annotate 'line', 459
  # rx pass
    rx1001_cur."!cursor_pass"(rx1001_pos, "named_param")
    if_null rx1001_debug, debug_968
    rx1001_cur."!cursor_debug"("PASS", "named_param", " at pos=", rx1001_pos)
  debug_968:
    .return (rx1001_cur)
  rx1001_restart:
.annotate 'line', 10
    if_null rx1001_debug, debug_969
    rx1001_cur."!cursor_debug"("NEXT", "named_param")
  debug_969:
  rx1001_fail:
    (rx1001_rep, rx1001_pos, $I10, $P10) = rx1001_cur."!mark_fail"(0)
    lt rx1001_pos, -1, rx1001_done
    eq rx1001_pos, -1, rx1001_fail
    jump $I10
  rx1001_done:
    rx1001_cur."!cursor_fail"()
    if_null rx1001_debug, debug_970
    rx1001_cur."!cursor_debug"("FAIL", "named_param")
  debug_970:
    .return (rx1001_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__named_param"  :nsentry("!PREFIX__named_param") :subid("199_1300146757.646") :method
.annotate 'line', 10
    $P1003 = self."!PREFIX__!subrule"("param_var", ":")
    new $P1004, "ResizablePMCArray"
    push $P1004, $P1003
    .return ($P1004)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "default_value"  :subid("200_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1007_tgt
    .local int rx1007_pos
    .local int rx1007_off
    .local int rx1007_eos
    .local int rx1007_rep
    .local pmc rx1007_cur
    .local pmc rx1007_debug
    (rx1007_cur, rx1007_pos, rx1007_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1007_cur
    .local pmc match
    .lex "$/", match
    length rx1007_eos, rx1007_tgt
    gt rx1007_pos, rx1007_eos, rx1007_done
    set rx1007_off, 0
    lt rx1007_pos, 2, rx1007_start
    sub rx1007_off, rx1007_pos, 1
    substr rx1007_tgt, rx1007_tgt, rx1007_off
  rx1007_start:
    eq $I10, 1, rx1007_restart
    if_null rx1007_debug, debug_971
    rx1007_cur."!cursor_debug"("START", "default_value")
  debug_971:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1011_done
    goto rxscan1011_scan
  rxscan1011_loop:
    (rx1007_pos) = rx1007_cur."from"()
    inc rx1007_pos
    rx1007_cur."!cursor_from"(rx1007_pos)
    ge rx1007_pos, rx1007_eos, rxscan1011_done
  rxscan1011_scan:
    set_addr $I10, rxscan1011_loop
    rx1007_cur."!mark_push"(0, rx1007_pos, $I10)
  rxscan1011_done:
.annotate 'line', 463
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx literal  "="
    add $I11, rx1007_pos, 1
    gt $I11, rx1007_eos, rx1007_fail
    sub $I11, rx1007_pos, rx1007_off
    ord $I11, rx1007_tgt, $I11
    ne $I11, 61, rx1007_fail
    add rx1007_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."EXPR"("i=")
    unless $P10, rx1007_fail
    rx1007_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1007_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1007_cur."!cursor_pos"(rx1007_pos)
    $P10 = rx1007_cur."ws"()
    unless $P10, rx1007_fail
    rx1007_pos = $P10."pos"()
  # rx pass
    rx1007_cur."!cursor_pass"(rx1007_pos, "default_value")
    if_null rx1007_debug, debug_972
    rx1007_cur."!cursor_debug"("PASS", "default_value", " at pos=", rx1007_pos)
  debug_972:
    .return (rx1007_cur)
  rx1007_restart:
.annotate 'line', 10
    if_null rx1007_debug, debug_973
    rx1007_cur."!cursor_debug"("NEXT", "default_value")
  debug_973:
  rx1007_fail:
    (rx1007_rep, rx1007_pos, $I10, $P10) = rx1007_cur."!mark_fail"(0)
    lt rx1007_pos, -1, rx1007_done
    eq rx1007_pos, -1, rx1007_fail
    jump $I10
  rx1007_done:
    rx1007_cur."!cursor_fail"()
    if_null rx1007_debug, debug_974
    rx1007_cur."!cursor_debug"("FAIL", "default_value")
  debug_974:
    .return (rx1007_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__default_value"  :nsentry("!PREFIX__default_value") :subid("201_1300146757.646") :method
.annotate 'line', 10
    $P1009 = self."!PREFIX__!subrule"("ws", "")
    new $P1010, "ResizablePMCArray"
    push $P1010, $P1009
    .return ($P1010)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait"  :subid("202_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1016_tgt
    .local int rx1016_pos
    .local int rx1016_off
    .local int rx1016_eos
    .local int rx1016_rep
    .local pmc rx1016_cur
    .local pmc rx1016_debug
    (rx1016_cur, rx1016_pos, rx1016_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1016_cur
    .local pmc match
    .lex "$/", match
    length rx1016_eos, rx1016_tgt
    gt rx1016_pos, rx1016_eos, rx1016_done
    set rx1016_off, 0
    lt rx1016_pos, 2, rx1016_start
    sub rx1016_off, rx1016_pos, 1
    substr rx1016_tgt, rx1016_tgt, rx1016_off
  rx1016_start:
    eq $I10, 1, rx1016_restart
    if_null rx1016_debug, debug_975
    rx1016_cur."!cursor_debug"("START", "trait")
  debug_975:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1020_done
    goto rxscan1020_scan
  rxscan1020_loop:
    (rx1016_pos) = rx1016_cur."from"()
    inc rx1016_pos
    rx1016_cur."!cursor_from"(rx1016_pos)
    ge rx1016_pos, rx1016_eos, rxscan1020_done
  rxscan1020_scan:
    set_addr $I10, rxscan1020_loop
    rx1016_cur."!mark_push"(0, rx1016_pos, $I10)
  rxscan1020_done:
.annotate 'line', 465
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx subrule "trait_mod" subtype=capture negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."trait_mod"()
    unless $P10, rx1016_fail
    rx1016_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("trait_mod")
    rx1016_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1016_cur."!cursor_pos"(rx1016_pos)
    $P10 = rx1016_cur."ws"()
    unless $P10, rx1016_fail
    rx1016_pos = $P10."pos"()
  # rx pass
    rx1016_cur."!cursor_pass"(rx1016_pos, "trait")
    if_null rx1016_debug, debug_976
    rx1016_cur."!cursor_debug"("PASS", "trait", " at pos=", rx1016_pos)
  debug_976:
    .return (rx1016_cur)
  rx1016_restart:
.annotate 'line', 10
    if_null rx1016_debug, debug_977
    rx1016_cur."!cursor_debug"("NEXT", "trait")
  debug_977:
  rx1016_fail:
    (rx1016_rep, rx1016_pos, $I10, $P10) = rx1016_cur."!mark_fail"(0)
    lt rx1016_pos, -1, rx1016_done
    eq rx1016_pos, -1, rx1016_fail
    jump $I10
  rx1016_done:
    rx1016_cur."!cursor_fail"()
    if_null rx1016_debug, debug_978
    rx1016_cur."!cursor_debug"("FAIL", "trait")
  debug_978:
    .return (rx1016_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait"  :nsentry("!PREFIX__trait") :subid("203_1300146757.646") :method
.annotate 'line', 10
    $P1018 = self."!PREFIX__!subrule"("ws", "")
    new $P1019, "ResizablePMCArray"
    push $P1019, $P1018
    .return ($P1019)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod"  :subid("204_1300146757.646")
    .param pmc param_1024
.annotate 'line', 467
    .lex "self", param_1024
    $P1025 = param_1024."!protoregex"("trait_mod")
    .return ($P1025)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod"  :subid("205_1300146757.646")
    .param pmc param_1027
.annotate 'line', 467
    .lex "self", param_1027
    $P1028 = param_1027."!PREFIX__!protoregex"("trait_mod")
    .return ($P1028)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "trait_mod:sym<is>"  :subid("206_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1030_tgt
    .local int rx1030_pos
    .local int rx1030_off
    .local int rx1030_eos
    .local int rx1030_rep
    .local pmc rx1030_cur
    .local pmc rx1030_debug
    (rx1030_cur, rx1030_pos, rx1030_tgt, $I10) = self."!cursor_start"()
    rx1030_cur."!cursor_caparray"("circumfix")
    .lex unicode:"$\x{a2}", rx1030_cur
    .local pmc match
    .lex "$/", match
    length rx1030_eos, rx1030_tgt
    gt rx1030_pos, rx1030_eos, rx1030_done
    set rx1030_off, 0
    lt rx1030_pos, 2, rx1030_start
    sub rx1030_off, rx1030_pos, 1
    substr rx1030_tgt, rx1030_tgt, rx1030_off
  rx1030_start:
    eq $I10, 1, rx1030_restart
    if_null rx1030_debug, debug_979
    rx1030_cur."!cursor_debug"("START", "trait_mod:sym<is>")
  debug_979:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1034_done
    goto rxscan1034_scan
  rxscan1034_loop:
    (rx1030_pos) = rx1030_cur."from"()
    inc rx1030_pos
    rx1030_cur."!cursor_from"(rx1030_pos)
    ge rx1030_pos, rx1030_eos, rxscan1034_done
  rxscan1034_scan:
    set_addr $I10, rxscan1034_loop
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxscan1034_done:
.annotate 'line', 468
  # rx subcapture "sym"
    set_addr $I10, rxcap_1035_fail
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  # rx literal  "is"
    add $I11, rx1030_pos, 2
    gt $I11, rx1030_eos, rx1030_fail
    sub $I11, rx1030_pos, rx1030_off
    substr $S10, rx1030_tgt, $I11, 2
    ne $S10, "is", rx1030_fail
    add rx1030_pos, 2
    set_addr $I10, rxcap_1035_fail
    ($I12, $I11) = rx1030_cur."!mark_peek"($I10)
    rx1030_cur."!cursor_pos"($I11)
    ($P10) = rx1030_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1030_pos, "")
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1035_done
  rxcap_1035_fail:
    goto rx1030_fail
  rxcap_1035_done:
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx subrule "deflongname" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."deflongname"()
    unless $P10, rx1030_fail
    rx1030_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx1030_pos = $P10."pos"()
  # rx rxquantr1037 ** 0..1
    set_addr $I10, rxquantr1037_done
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10)
  rxquantr1037_loop:
  # rx subrule "circumfix" subtype=capture negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."circumfix"()
    unless $P10, rx1030_fail
    goto rxsubrule1038_pass
  rxsubrule1038_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1030_fail
  rxsubrule1038_pass:
    set_addr $I10, rxsubrule1038_back
    rx1030_cur."!mark_push"(0, rx1030_pos, $I10, $P10)
    $P10."!cursor_names"("circumfix")
    rx1030_pos = $P10."pos"()
    set_addr $I10, rxquantr1037_done
    (rx1030_rep) = rx1030_cur."!mark_commit"($I10)
  rxquantr1037_done:
  # rx subrule "ws" subtype=method negate=
    rx1030_cur."!cursor_pos"(rx1030_pos)
    $P10 = rx1030_cur."ws"()
    unless $P10, rx1030_fail
    rx1030_pos = $P10."pos"()
  # rx pass
    rx1030_cur."!cursor_pass"(rx1030_pos, "trait_mod:sym<is>")
    if_null rx1030_debug, debug_980
    rx1030_cur."!cursor_debug"("PASS", "trait_mod:sym<is>", " at pos=", rx1030_pos)
  debug_980:
    .return (rx1030_cur)
  rx1030_restart:
.annotate 'line', 10
    if_null rx1030_debug, debug_981
    rx1030_cur."!cursor_debug"("NEXT", "trait_mod:sym<is>")
  debug_981:
  rx1030_fail:
    (rx1030_rep, rx1030_pos, $I10, $P10) = rx1030_cur."!mark_fail"(0)
    lt rx1030_pos, -1, rx1030_done
    eq rx1030_pos, -1, rx1030_fail
    jump $I10
  rx1030_done:
    rx1030_cur."!cursor_fail"()
    if_null rx1030_debug, debug_982
    rx1030_cur."!cursor_debug"("FAIL", "trait_mod:sym<is>")
  debug_982:
    .return (rx1030_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__trait_mod:sym<is>"  :nsentry("!PREFIX__trait_mod:sym<is>") :subid("207_1300146757.646") :method
.annotate 'line', 10
    $P1032 = self."!PREFIX__!subrule"("ws", "is")
    new $P1033, "ResizablePMCArray"
    push $P1033, $P1032
    .return ($P1033)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "regex_declarator"  :subid("208_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1041_tgt
    .local int rx1041_pos
    .local int rx1041_off
    .local int rx1041_eos
    .local int rx1041_rep
    .local pmc rx1041_cur
    .local pmc rx1041_debug
    (rx1041_cur, rx1041_pos, rx1041_tgt, $I10) = self."!cursor_start"()
    rx1041_cur."!cursor_caparray"("signature")
    .lex unicode:"$\x{a2}", rx1041_cur
    .local pmc match
    .lex "$/", match
    length rx1041_eos, rx1041_tgt
    gt rx1041_pos, rx1041_eos, rx1041_done
    set rx1041_off, 0
    lt rx1041_pos, 2, rx1041_start
    sub rx1041_off, rx1041_pos, 1
    substr rx1041_tgt, rx1041_tgt, rx1041_off
  rx1041_start:
    eq $I10, 1, rx1041_restart
    if_null rx1041_debug, debug_983
    rx1041_cur."!cursor_debug"("START", "regex_declarator")
  debug_983:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1045_done
    goto rxscan1045_scan
  rxscan1045_loop:
    (rx1041_pos) = rx1041_cur."from"()
    inc rx1041_pos
    rx1041_cur."!cursor_from"(rx1041_pos)
    ge rx1041_pos, rx1041_eos, rxscan1045_done
  rxscan1045_scan:
    set_addr $I10, rxscan1045_loop
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  rxscan1045_done:
.annotate 'line', 470
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1047_0:
.annotate 'line', 471
    set_addr $I10, alt1047_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 472
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subcapture "proto"
    set_addr $I10, rxcap_1049_fail
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "proto"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "proto", rx1041_fail
    add rx1041_pos, 5
    set_addr $I10, rxcap_1049_fail
    ($I12, $I11) = rx1041_cur."!mark_peek"($I10)
    rx1041_cur."!cursor_pos"($I11)
    ($P10) = rx1041_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1041_pos, "")
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("proto")
    goto rxcap_1049_done
  rxcap_1049_fail:
    goto rx1041_fail
  rxcap_1049_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1051_0:
    set_addr $I10, alt1051_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "regex", rx1041_fail
    add rx1041_pos, 5
    goto alt1051_end
  alt1051_1:
    set_addr $I10, alt1051_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "token"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "token", rx1041_fail
    add rx1041_pos, 5
    goto alt1051_end
  alt1051_2:
  # rx literal  "rule"
    add $I11, rx1041_pos, 4
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 4
    ne $S10, "rule", rx1041_fail
    add rx1041_pos, 4
  alt1051_end:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 473
  # rx subrule "deflongname" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."deflongname"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1054_0:
.annotate 'line', 474
    set_addr $I10, alt1054_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 475
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "<...>"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "<...>", rx1041_fail
    add rx1041_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    goto alt1054_end
  alt1054_1:
    set_addr $I10, alt1054_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
.annotate 'line', 476
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "<*>"
    add $I11, rx1041_pos, 3
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 3
    ne $S10, "<*>", rx1041_fail
    add rx1041_pos, 3
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    goto alt1054_end
  alt1054_2:
.annotate 'line', 477
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "panic" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."panic"("Proto regex body must be <*> (or <...>, which is deprecated)")
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1054_end:
.annotate 'line', 478
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 472
    goto alt1047_end
  alt1047_1:
.annotate 'line', 479
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subcapture "sym"
    set_addr $I10, rxcap_1068_fail
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  alt1067_0:
    set_addr $I10, alt1067_1
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "regex"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "regex", rx1041_fail
    add rx1041_pos, 5
    goto alt1067_end
  alt1067_1:
    set_addr $I10, alt1067_2
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  # rx literal  "token"
    add $I11, rx1041_pos, 5
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 5
    ne $S10, "token", rx1041_fail
    add rx1041_pos, 5
    goto alt1067_end
  alt1067_2:
  # rx literal  "rule"
    add $I11, rx1041_pos, 4
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    substr $S10, rx1041_tgt, $I11, 4
    ne $S10, "rule", rx1041_fail
    add rx1041_pos, 4
  alt1067_end:
    set_addr $I10, rxcap_1068_fail
    ($I12, $I11) = rx1041_cur."!mark_peek"($I10)
    rx1041_cur."!cursor_pos"($I11)
    ($P10) = rx1041_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1041_pos, "")
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1068_done
  rxcap_1068_fail:
    goto rx1041_fail
  rxcap_1068_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 480
  # rx subrule "deflongname" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."deflongname"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 481
  # rx subrule "newpad" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."newpad"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 482
  # rx rxquantr1072 ** 0..1
    set_addr $I10, rxquantr1072_done
    rx1041_cur."!mark_push"(0, rx1041_pos, $I10)
  rxquantr1072_loop:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 40, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx subrule "signature" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."signature"()
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("signature")
    rx1041_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 41, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
    set_addr $I10, rxquantr1072_done
    (rx1041_rep) = rx1041_cur."!mark_commit"($I10)
  rxquantr1072_done:
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 483
  # rx reduce name="regex_declarator" key="open"
    rx1041_cur."!cursor_pos"(rx1041_pos)
    rx1041_cur."!reduce"("regex_declarator", "open")
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 484
  # rx literal  "{"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 123, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1041_fail
    rx1041_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1041_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1041_pos, 1
    gt $I11, rx1041_eos, rx1041_fail
    sub $I11, rx1041_pos, rx1041_off
    ord $I11, rx1041_tgt, $I11
    ne $I11, 125, rx1041_fail
    add rx1041_pos, 1
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ENDSTMT"()
    unless $P10, rx1041_fail
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
  alt1047_end:
.annotate 'line', 485
  # rx subrule "ws" subtype=method negate=
    rx1041_cur."!cursor_pos"(rx1041_pos)
    $P10 = rx1041_cur."ws"()
    unless $P10, rx1041_fail
    rx1041_pos = $P10."pos"()
.annotate 'line', 470
  # rx pass
    rx1041_cur."!cursor_pass"(rx1041_pos, "regex_declarator")
    if_null rx1041_debug, debug_984
    rx1041_cur."!cursor_debug"("PASS", "regex_declarator", " at pos=", rx1041_pos)
  debug_984:
    .return (rx1041_cur)
  rx1041_restart:
.annotate 'line', 10
    if_null rx1041_debug, debug_985
    rx1041_cur."!cursor_debug"("NEXT", "regex_declarator")
  debug_985:
  rx1041_fail:
    (rx1041_rep, rx1041_pos, $I10, $P10) = rx1041_cur."!mark_fail"(0)
    lt rx1041_pos, -1, rx1041_done
    eq rx1041_pos, -1, rx1041_fail
    jump $I10
  rx1041_done:
    rx1041_cur."!cursor_fail"()
    if_null rx1041_debug, debug_986
    rx1041_cur."!cursor_debug"("FAIL", "regex_declarator")
  debug_986:
    .return (rx1041_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__regex_declarator"  :nsentry("!PREFIX__regex_declarator") :subid("209_1300146757.646") :method
.annotate 'line', 10
    $P1043 = self."!PREFIX__!subrule"("ws", "")
    new $P1044, "ResizablePMCArray"
    push $P1044, $P1043
    .return ($P1044)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "dotty"  :subid("210_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1082_tgt
    .local int rx1082_pos
    .local int rx1082_off
    .local int rx1082_eos
    .local int rx1082_rep
    .local pmc rx1082_cur
    .local pmc rx1082_debug
    (rx1082_cur, rx1082_pos, rx1082_tgt, $I10) = self."!cursor_start"()
    rx1082_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1082_cur
    .local pmc match
    .lex "$/", match
    length rx1082_eos, rx1082_tgt
    gt rx1082_pos, rx1082_eos, rx1082_done
    set rx1082_off, 0
    lt rx1082_pos, 2, rx1082_start
    sub rx1082_off, rx1082_pos, 1
    substr rx1082_tgt, rx1082_tgt, rx1082_off
  rx1082_start:
    eq $I10, 1, rx1082_restart
    if_null rx1082_debug, debug_987
    rx1082_cur."!cursor_debug"("START", "dotty")
  debug_987:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1086_done
    goto rxscan1086_scan
  rxscan1086_loop:
    (rx1082_pos) = rx1082_cur."from"()
    inc rx1082_pos
    rx1082_cur."!cursor_from"(rx1082_pos)
    ge rx1082_pos, rx1082_eos, rxscan1086_done
  rxscan1086_scan:
    set_addr $I10, rxscan1086_loop
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  rxscan1086_done:
.annotate 'line', 489
  # rx literal  "."
    add $I11, rx1082_pos, 1
    gt $I11, rx1082_eos, rx1082_fail
    sub $I11, rx1082_pos, rx1082_off
    ord $I11, rx1082_tgt, $I11
    ne $I11, 46, rx1082_fail
    add rx1082_pos, 1
  alt1087_0:
.annotate 'line', 490
    set_addr $I10, alt1087_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx subrule "deflongname" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."deflongname"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname=deflongname")
    rx1082_pos = $P10."pos"()
    goto alt1087_end
  alt1087_1:
.annotate 'line', 491
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "'\"", $S10
    lt $I11, 0, rx1082_fail
  # rx subrule "quote" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."quote"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1082_pos = $P10."pos"()
  alt1088_0:
.annotate 'line', 492
    set_addr $I10, alt1088_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1082_fail
    goto alt1088_end
  alt1088_1:
  # rx subrule "panic" subtype=method negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."panic"("Quoted method name requires parenthesized arguments")
    unless $P10, rx1082_fail
    rx1082_pos = $P10."pos"()
  alt1088_end:
  alt1087_end:
.annotate 'line', 498
  # rx rxquantr1089 ** 0..1
    set_addr $I10, rxquantr1089_done
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
  rxquantr1089_loop:
  alt1090_0:
.annotate 'line', 495
    set_addr $I10, alt1090_1
    rx1082_cur."!mark_push"(0, rx1082_pos, $I10)
.annotate 'line', 496
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1082_pos, rx1082_off
    substr $S10, rx1082_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1082_fail
  # rx subrule "args" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."args"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1082_pos = $P10."pos"()
    goto alt1090_end
  alt1090_1:
.annotate 'line', 497
  # rx literal  ":"
    add $I11, rx1082_pos, 1
    gt $I11, rx1082_eos, rx1082_fail
    sub $I11, rx1082_pos, rx1082_off
    ord $I11, rx1082_tgt, $I11
    ne $I11, 58, rx1082_fail
    add rx1082_pos, 1
  # rx charclass s
    ge rx1082_pos, rx1082_eos, rx1082_fail
    sub $I10, rx1082_pos, rx1082_off
    is_cclass $I11, 32, rx1082_tgt, $I10
    unless $I11, rx1082_fail
    inc rx1082_pos
  # rx subrule "arglist" subtype=capture negate=
    rx1082_cur."!cursor_pos"(rx1082_pos)
    $P10 = rx1082_cur."arglist"()
    unless $P10, rx1082_fail
    rx1082_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1082_pos = $P10."pos"()
  alt1090_end:
.annotate 'line', 498
    set_addr $I10, rxquantr1089_done
    (rx1082_rep) = rx1082_cur."!mark_commit"($I10)
  rxquantr1089_done:
.annotate 'line', 488
  # rx pass
    rx1082_cur."!cursor_pass"(rx1082_pos, "dotty")
    if_null rx1082_debug, debug_988
    rx1082_cur."!cursor_debug"("PASS", "dotty", " at pos=", rx1082_pos)
  debug_988:
    .return (rx1082_cur)
  rx1082_restart:
.annotate 'line', 10
    if_null rx1082_debug, debug_989
    rx1082_cur."!cursor_debug"("NEXT", "dotty")
  debug_989:
  rx1082_fail:
    (rx1082_rep, rx1082_pos, $I10, $P10) = rx1082_cur."!mark_fail"(0)
    lt rx1082_pos, -1, rx1082_done
    eq rx1082_pos, -1, rx1082_fail
    jump $I10
  rx1082_done:
    rx1082_cur."!cursor_fail"()
    if_null rx1082_debug, debug_990
    rx1082_cur."!cursor_debug"("FAIL", "dotty")
  debug_990:
    .return (rx1082_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__dotty"  :nsentry("!PREFIX__dotty") :subid("211_1300146757.646") :method
.annotate 'line', 10
    $P1084 = self."!PREFIX__!subrule"("deflongname", ".")
    new $P1085, "ResizablePMCArray"
    push $P1085, "'"
    push $P1085, "\""
    push $P1085, $P1084
    .return ($P1085)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term"  :subid("212_1300146757.646")
    .param pmc param_1092
.annotate 'line', 502
    .lex "self", param_1092
    $P1093 = param_1092."!protoregex"("term")
    .return ($P1093)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term"  :subid("213_1300146757.646")
    .param pmc param_1095
.annotate 'line', 502
    .lex "self", param_1095
    $P1096 = param_1095."!PREFIX__!protoregex"("term")
    .return ($P1096)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<self>"  :subid("214_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1098_tgt
    .local int rx1098_pos
    .local int rx1098_off
    .local int rx1098_eos
    .local int rx1098_rep
    .local pmc rx1098_cur
    .local pmc rx1098_debug
    (rx1098_cur, rx1098_pos, rx1098_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1098_cur
    .local pmc match
    .lex "$/", match
    length rx1098_eos, rx1098_tgt
    gt rx1098_pos, rx1098_eos, rx1098_done
    set rx1098_off, 0
    lt rx1098_pos, 2, rx1098_start
    sub rx1098_off, rx1098_pos, 1
    substr rx1098_tgt, rx1098_tgt, rx1098_off
  rx1098_start:
    eq $I10, 1, rx1098_restart
    if_null rx1098_debug, debug_991
    rx1098_cur."!cursor_debug"("START", "term:sym<self>")
  debug_991:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1101_done
    goto rxscan1101_scan
  rxscan1101_loop:
    (rx1098_pos) = rx1098_cur."from"()
    inc rx1098_pos
    rx1098_cur."!cursor_from"(rx1098_pos)
    ge rx1098_pos, rx1098_eos, rxscan1101_done
  rxscan1101_scan:
    set_addr $I10, rxscan1101_loop
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  rxscan1101_done:
.annotate 'line', 504
  # rx subcapture "sym"
    set_addr $I10, rxcap_1102_fail
    rx1098_cur."!mark_push"(0, rx1098_pos, $I10)
  # rx literal  "self"
    add $I11, rx1098_pos, 4
    gt $I11, rx1098_eos, rx1098_fail
    sub $I11, rx1098_pos, rx1098_off
    substr $S10, rx1098_tgt, $I11, 4
    ne $S10, "self", rx1098_fail
    add rx1098_pos, 4
    set_addr $I10, rxcap_1102_fail
    ($I12, $I11) = rx1098_cur."!mark_peek"($I10)
    rx1098_cur."!cursor_pos"($I11)
    ($P10) = rx1098_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1098_pos, "")
    rx1098_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1102_done
  rxcap_1102_fail:
    goto rx1098_fail
  rxcap_1102_done:
  # rxanchor rwb
    le rx1098_pos, 0, rx1098_fail
    sub $I10, rx1098_pos, rx1098_off
    is_cclass $I11, 8192, rx1098_tgt, $I10
    if $I11, rx1098_fail
    dec $I10
    is_cclass $I11, 8192, rx1098_tgt, $I10
    unless $I11, rx1098_fail
  # rx pass
    rx1098_cur."!cursor_pass"(rx1098_pos, "term:sym<self>")
    if_null rx1098_debug, debug_992
    rx1098_cur."!cursor_debug"("PASS", "term:sym<self>", " at pos=", rx1098_pos)
  debug_992:
    .return (rx1098_cur)
  rx1098_restart:
.annotate 'line', 10
    if_null rx1098_debug, debug_993
    rx1098_cur."!cursor_debug"("NEXT", "term:sym<self>")
  debug_993:
  rx1098_fail:
    (rx1098_rep, rx1098_pos, $I10, $P10) = rx1098_cur."!mark_fail"(0)
    lt rx1098_pos, -1, rx1098_done
    eq rx1098_pos, -1, rx1098_fail
    jump $I10
  rx1098_done:
    rx1098_cur."!cursor_fail"()
    if_null rx1098_debug, debug_994
    rx1098_cur."!cursor_debug"("FAIL", "term:sym<self>")
  debug_994:
    .return (rx1098_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<self>"  :nsentry("!PREFIX__term:sym<self>") :subid("215_1300146757.646") :method
.annotate 'line', 10
    new $P1100, "ResizablePMCArray"
    push $P1100, "self"
    .return ($P1100)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<identifier>"  :subid("216_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1104_tgt
    .local int rx1104_pos
    .local int rx1104_off
    .local int rx1104_eos
    .local int rx1104_rep
    .local pmc rx1104_cur
    .local pmc rx1104_debug
    (rx1104_cur, rx1104_pos, rx1104_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1104_cur
    .local pmc match
    .lex "$/", match
    length rx1104_eos, rx1104_tgt
    gt rx1104_pos, rx1104_eos, rx1104_done
    set rx1104_off, 0
    lt rx1104_pos, 2, rx1104_start
    sub rx1104_off, rx1104_pos, 1
    substr rx1104_tgt, rx1104_tgt, rx1104_off
  rx1104_start:
    eq $I10, 1, rx1104_restart
    if_null rx1104_debug, debug_995
    rx1104_cur."!cursor_debug"("START", "term:sym<identifier>")
  debug_995:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1108_done
    goto rxscan1108_scan
  rxscan1108_loop:
    (rx1104_pos) = rx1104_cur."from"()
    inc rx1104_pos
    rx1104_cur."!cursor_from"(rx1104_pos)
    ge rx1104_pos, rx1104_eos, rxscan1108_done
  rxscan1108_scan:
    set_addr $I10, rxscan1108_loop
    rx1104_cur."!mark_push"(0, rx1104_pos, $I10)
  rxscan1108_done:
.annotate 'line', 507
  # rx subrule "deflongname" subtype=capture negate=
    rx1104_cur."!cursor_pos"(rx1104_pos)
    $P10 = rx1104_cur."deflongname"()
    unless $P10, rx1104_fail
    rx1104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("deflongname")
    rx1104_pos = $P10."pos"()
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1104_pos, rx1104_off
    substr $S10, rx1104_tgt, $I10, 1
    index $I11, "(", $S10
    lt $I11, 0, rx1104_fail
  # rx subrule "args" subtype=capture negate=
    rx1104_cur."!cursor_pos"(rx1104_pos)
    $P10 = rx1104_cur."args"()
    unless $P10, rx1104_fail
    rx1104_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("args")
    rx1104_pos = $P10."pos"()
.annotate 'line', 506
  # rx pass
    rx1104_cur."!cursor_pass"(rx1104_pos, "term:sym<identifier>")
    if_null rx1104_debug, debug_996
    rx1104_cur."!cursor_debug"("PASS", "term:sym<identifier>", " at pos=", rx1104_pos)
  debug_996:
    .return (rx1104_cur)
  rx1104_restart:
.annotate 'line', 10
    if_null rx1104_debug, debug_997
    rx1104_cur."!cursor_debug"("NEXT", "term:sym<identifier>")
  debug_997:
  rx1104_fail:
    (rx1104_rep, rx1104_pos, $I10, $P10) = rx1104_cur."!mark_fail"(0)
    lt rx1104_pos, -1, rx1104_done
    eq rx1104_pos, -1, rx1104_fail
    jump $I10
  rx1104_done:
    rx1104_cur."!cursor_fail"()
    if_null rx1104_debug, debug_998
    rx1104_cur."!cursor_debug"("FAIL", "term:sym<identifier>")
  debug_998:
    .return (rx1104_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<identifier>"  :nsentry("!PREFIX__term:sym<identifier>") :subid("217_1300146757.646") :method
.annotate 'line', 10
    $P1106 = self."!PREFIX__!subrule"("deflongname", "")
    new $P1107, "ResizablePMCArray"
    push $P1107, $P1106
    .return ($P1107)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<name>"  :subid("218_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1110_tgt
    .local int rx1110_pos
    .local int rx1110_off
    .local int rx1110_eos
    .local int rx1110_rep
    .local pmc rx1110_cur
    .local pmc rx1110_debug
    (rx1110_cur, rx1110_pos, rx1110_tgt, $I10) = self."!cursor_start"()
    rx1110_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1110_cur
    .local pmc match
    .lex "$/", match
    length rx1110_eos, rx1110_tgt
    gt rx1110_pos, rx1110_eos, rx1110_done
    set rx1110_off, 0
    lt rx1110_pos, 2, rx1110_start
    sub rx1110_off, rx1110_pos, 1
    substr rx1110_tgt, rx1110_tgt, rx1110_off
  rx1110_start:
    eq $I10, 1, rx1110_restart
    if_null rx1110_debug, debug_999
    rx1110_cur."!cursor_debug"("START", "term:sym<name>")
  debug_999:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1114_done
    goto rxscan1114_scan
  rxscan1114_loop:
    (rx1110_pos) = rx1110_cur."from"()
    inc rx1110_pos
    rx1110_cur."!cursor_from"(rx1110_pos)
    ge rx1110_pos, rx1110_eos, rxscan1114_done
  rxscan1114_scan:
    set_addr $I10, rxscan1114_loop
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxscan1114_done:
.annotate 'line', 511
  # rx subrule "name" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."name"()
    unless $P10, rx1110_fail
    rx1110_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("name")
    rx1110_pos = $P10."pos"()
  # rx rxquantr1115 ** 0..1
    set_addr $I10, rxquantr1115_done
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10)
  rxquantr1115_loop:
  # rx subrule "args" subtype=capture negate=
    rx1110_cur."!cursor_pos"(rx1110_pos)
    $P10 = rx1110_cur."args"()
    unless $P10, rx1110_fail
    goto rxsubrule1116_pass
  rxsubrule1116_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1110_fail
  rxsubrule1116_pass:
    set_addr $I10, rxsubrule1116_back
    rx1110_cur."!mark_push"(0, rx1110_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1110_pos = $P10."pos"()
    set_addr $I10, rxquantr1115_done
    (rx1110_rep) = rx1110_cur."!mark_commit"($I10)
  rxquantr1115_done:
.annotate 'line', 510
  # rx pass
    rx1110_cur."!cursor_pass"(rx1110_pos, "term:sym<name>")
    if_null rx1110_debug, debug_1000
    rx1110_cur."!cursor_debug"("PASS", "term:sym<name>", " at pos=", rx1110_pos)
  debug_1000:
    .return (rx1110_cur)
  rx1110_restart:
.annotate 'line', 10
    if_null rx1110_debug, debug_1001
    rx1110_cur."!cursor_debug"("NEXT", "term:sym<name>")
  debug_1001:
  rx1110_fail:
    (rx1110_rep, rx1110_pos, $I10, $P10) = rx1110_cur."!mark_fail"(0)
    lt rx1110_pos, -1, rx1110_done
    eq rx1110_pos, -1, rx1110_fail
    jump $I10
  rx1110_done:
    rx1110_cur."!cursor_fail"()
    if_null rx1110_debug, debug_1002
    rx1110_cur."!cursor_debug"("FAIL", "term:sym<name>")
  debug_1002:
    .return (rx1110_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<name>"  :nsentry("!PREFIX__term:sym<name>") :subid("219_1300146757.646") :method
.annotate 'line', 10
    $P1112 = self."!PREFIX__!subrule"("name", "")
    new $P1113, "ResizablePMCArray"
    push $P1113, $P1112
    .return ($P1113)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<pir::op>"  :subid("220_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1118_tgt
    .local int rx1118_pos
    .local int rx1118_off
    .local int rx1118_eos
    .local int rx1118_rep
    .local pmc rx1118_cur
    .local pmc rx1118_debug
    (rx1118_cur, rx1118_pos, rx1118_tgt, $I10) = self."!cursor_start"()
    rx1118_cur."!cursor_caparray"("args")
    .lex unicode:"$\x{a2}", rx1118_cur
    .local pmc match
    .lex "$/", match
    length rx1118_eos, rx1118_tgt
    gt rx1118_pos, rx1118_eos, rx1118_done
    set rx1118_off, 0
    lt rx1118_pos, 2, rx1118_start
    sub rx1118_off, rx1118_pos, 1
    substr rx1118_tgt, rx1118_tgt, rx1118_off
  rx1118_start:
    eq $I10, 1, rx1118_restart
    if_null rx1118_debug, debug_1003
    rx1118_cur."!cursor_debug"("START", "term:sym<pir::op>")
  debug_1003:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1121_done
    goto rxscan1121_scan
  rxscan1121_loop:
    (rx1118_pos) = rx1118_cur."from"()
    inc rx1118_pos
    rx1118_cur."!cursor_from"(rx1118_pos)
    ge rx1118_pos, rx1118_eos, rxscan1121_done
  rxscan1121_scan:
    set_addr $I10, rxscan1121_loop
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxscan1121_done:
.annotate 'line', 515
  # rx literal  "pir::"
    add $I11, rx1118_pos, 5
    gt $I11, rx1118_eos, rx1118_fail
    sub $I11, rx1118_pos, rx1118_off
    substr $S10, rx1118_tgt, $I11, 5
    ne $S10, "pir::", rx1118_fail
    add rx1118_pos, 5
  # rx subcapture "op"
    set_addr $I10, rxcap_1122_fail
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  # rx charclass_q w r 1..-1
    sub $I10, rx1118_pos, rx1118_off
    find_not_cclass $I11, 8192, rx1118_tgt, $I10, rx1118_eos
    add $I12, $I10, 1
    lt $I11, $I12, rx1118_fail
    add rx1118_pos, rx1118_off, $I11
    set_addr $I10, rxcap_1122_fail
    ($I12, $I11) = rx1118_cur."!mark_peek"($I10)
    rx1118_cur."!cursor_pos"($I11)
    ($P10) = rx1118_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1118_pos, "")
    rx1118_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("op")
    goto rxcap_1122_done
  rxcap_1122_fail:
    goto rx1118_fail
  rxcap_1122_done:
  # rx rxquantr1123 ** 0..1
    set_addr $I10, rxquantr1123_done
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10)
  rxquantr1123_loop:
  # rx subrule "args" subtype=capture negate=
    rx1118_cur."!cursor_pos"(rx1118_pos)
    $P10 = rx1118_cur."args"()
    unless $P10, rx1118_fail
    goto rxsubrule1124_pass
  rxsubrule1124_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1118_fail
  rxsubrule1124_pass:
    set_addr $I10, rxsubrule1124_back
    rx1118_cur."!mark_push"(0, rx1118_pos, $I10, $P10)
    $P10."!cursor_names"("args")
    rx1118_pos = $P10."pos"()
    set_addr $I10, rxquantr1123_done
    (rx1118_rep) = rx1118_cur."!mark_commit"($I10)
  rxquantr1123_done:
.annotate 'line', 514
  # rx pass
    rx1118_cur."!cursor_pass"(rx1118_pos, "term:sym<pir::op>")
    if_null rx1118_debug, debug_1004
    rx1118_cur."!cursor_debug"("PASS", "term:sym<pir::op>", " at pos=", rx1118_pos)
  debug_1004:
    .return (rx1118_cur)
  rx1118_restart:
.annotate 'line', 10
    if_null rx1118_debug, debug_1005
    rx1118_cur."!cursor_debug"("NEXT", "term:sym<pir::op>")
  debug_1005:
  rx1118_fail:
    (rx1118_rep, rx1118_pos, $I10, $P10) = rx1118_cur."!mark_fail"(0)
    lt rx1118_pos, -1, rx1118_done
    eq rx1118_pos, -1, rx1118_fail
    jump $I10
  rx1118_done:
    rx1118_cur."!cursor_fail"()
    if_null rx1118_debug, debug_1006
    rx1118_cur."!cursor_debug"("FAIL", "term:sym<pir::op>")
  debug_1006:
    .return (rx1118_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<pir::op>"  :nsentry("!PREFIX__term:sym<pir::op>") :subid("221_1300146757.646") :method
.annotate 'line', 10
    new $P1120, "ResizablePMCArray"
    push $P1120, "pir::"
    .return ($P1120)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<onlystar>"  :subid("222_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P1134 = "224_1300146757.646" 
    capture_lex $P1134
    .local string rx1126_tgt
    .local int rx1126_pos
    .local int rx1126_off
    .local int rx1126_eos
    .local int rx1126_rep
    .local pmc rx1126_cur
    .local pmc rx1126_debug
    (rx1126_cur, rx1126_pos, rx1126_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1126_cur
    .local pmc match
    .lex "$/", match
    length rx1126_eos, rx1126_tgt
    gt rx1126_pos, rx1126_eos, rx1126_done
    set rx1126_off, 0
    lt rx1126_pos, 2, rx1126_start
    sub rx1126_off, rx1126_pos, 1
    substr rx1126_tgt, rx1126_tgt, rx1126_off
  rx1126_start:
    eq $I10, 1, rx1126_restart
    if_null rx1126_debug, debug_1007
    rx1126_cur."!cursor_debug"("START", "term:sym<onlystar>")
  debug_1007:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1129_done
    goto rxscan1129_scan
  rxscan1129_loop:
    (rx1126_pos) = rx1126_cur."from"()
    inc rx1126_pos
    rx1126_cur."!cursor_from"(rx1126_pos)
    ge rx1126_pos, rx1126_eos, rxscan1129_done
  rxscan1129_scan:
    set_addr $I10, rxscan1129_loop
    rx1126_cur."!mark_push"(0, rx1126_pos, $I10)
  rxscan1129_done:
.annotate 'line', 519
  # rx literal  "{*}"
    add $I11, rx1126_pos, 3
    gt $I11, rx1126_eos, rx1126_fail
    sub $I11, rx1126_pos, rx1126_off
    substr $S10, rx1126_tgt, $I11, 3
    ne $S10, "{*}", rx1126_fail
    add rx1126_pos, 3
  # rx subrule "ENDSTMT" subtype=zerowidth negate=
    rx1126_cur."!cursor_pos"(rx1126_pos)
    $P10 = rx1126_cur."ENDSTMT"()
    unless $P10, rx1126_fail
  alt1130_0:
.annotate 'line', 520
    set_addr $I10, alt1130_1
    rx1126_cur."!mark_push"(0, rx1126_pos, $I10)
    rx1126_cur."!cursor_pos"(rx1126_pos)
    find_lex $P1131, unicode:"$\x{a2}"
    $P1132 = $P1131."MATCH"()
    store_lex "$/", $P1132
    .const 'Sub' $P1134 = "224_1300146757.646" 
    capture_lex $P1134
    $P1138 = $P1134()
    unless $P1138, rx1126_fail
    goto alt1130_end
  alt1130_1:
  # rx subrule "panic" subtype=method negate=
    rx1126_cur."!cursor_pos"(rx1126_pos)
    $P10 = rx1126_cur."panic"("{*} may only appear in proto")
    unless $P10, rx1126_fail
    rx1126_pos = $P10."pos"()
  alt1130_end:
.annotate 'line', 518
  # rx pass
    rx1126_cur."!cursor_pass"(rx1126_pos, "term:sym<onlystar>")
    if_null rx1126_debug, debug_1010
    rx1126_cur."!cursor_debug"("PASS", "term:sym<onlystar>", " at pos=", rx1126_pos)
  debug_1010:
    .return (rx1126_cur)
  rx1126_restart:
.annotate 'line', 10
    if_null rx1126_debug, debug_1011
    rx1126_cur."!cursor_debug"("NEXT", "term:sym<onlystar>")
  debug_1011:
  rx1126_fail:
    (rx1126_rep, rx1126_pos, $I10, $P10) = rx1126_cur."!mark_fail"(0)
    lt rx1126_pos, -1, rx1126_done
    eq rx1126_pos, -1, rx1126_fail
    jump $I10
  rx1126_done:
    rx1126_cur."!cursor_fail"()
    if_null rx1126_debug, debug_1012
    rx1126_cur."!cursor_debug"("FAIL", "term:sym<onlystar>")
  debug_1012:
    .return (rx1126_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<onlystar>"  :nsentry("!PREFIX__term:sym<onlystar>") :subid("223_1300146757.646") :method
.annotate 'line', 10
    new $P1128, "ResizablePMCArray"
    push $P1128, "{*}"
    .return ($P1128)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1133"  :anon :subid("224_1300146757.646") :outer("222_1300146757.646")
.annotate 'line', 520
    find_dynamic_lex $P1135, "$*MULTINESS"
    unless_null $P1135, vivify_1008
    get_hll_global $P1135, "$MULTINESS"
    unless_null $P1135, vivify_1009
    die "Contextual $*MULTINESS not found"
  vivify_1009:
  vivify_1008:
    set $S1136, $P1135
    iseq $I1137, $S1136, "proto"
    .return ($I1137)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "args"  :subid("225_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1140_tgt
    .local int rx1140_pos
    .local int rx1140_off
    .local int rx1140_eos
    .local int rx1140_rep
    .local pmc rx1140_cur
    .local pmc rx1140_debug
    (rx1140_cur, rx1140_pos, rx1140_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1140_cur
    .local pmc match
    .lex "$/", match
    length rx1140_eos, rx1140_tgt
    gt rx1140_pos, rx1140_eos, rx1140_done
    set rx1140_off, 0
    lt rx1140_pos, 2, rx1140_start
    sub rx1140_off, rx1140_pos, 1
    substr rx1140_tgt, rx1140_tgt, rx1140_off
  rx1140_start:
    eq $I10, 1, rx1140_restart
    if_null rx1140_debug, debug_1013
    rx1140_cur."!cursor_debug"("START", "args")
  debug_1013:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1144_done
    goto rxscan1144_scan
  rxscan1144_loop:
    (rx1140_pos) = rx1140_cur."from"()
    inc rx1140_pos
    rx1140_cur."!cursor_from"(rx1140_pos)
    ge rx1140_pos, rx1140_eos, rxscan1144_done
  rxscan1144_scan:
    set_addr $I10, rxscan1144_loop
    rx1140_cur."!mark_push"(0, rx1140_pos, $I10)
  rxscan1144_done:
.annotate 'line', 524
  # rx literal  "("
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 40, rx1140_fail
    add rx1140_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx1140_cur."!cursor_pos"(rx1140_pos)
    $P10 = rx1140_cur."arglist"()
    unless $P10, rx1140_fail
    rx1140_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1140_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1140_pos, 1
    gt $I11, rx1140_eos, rx1140_fail
    sub $I11, rx1140_pos, rx1140_off
    ord $I11, rx1140_tgt, $I11
    ne $I11, 41, rx1140_fail
    add rx1140_pos, 1
  # rx pass
    rx1140_cur."!cursor_pass"(rx1140_pos, "args")
    if_null rx1140_debug, debug_1014
    rx1140_cur."!cursor_debug"("PASS", "args", " at pos=", rx1140_pos)
  debug_1014:
    .return (rx1140_cur)
  rx1140_restart:
.annotate 'line', 10
    if_null rx1140_debug, debug_1015
    rx1140_cur."!cursor_debug"("NEXT", "args")
  debug_1015:
  rx1140_fail:
    (rx1140_rep, rx1140_pos, $I10, $P10) = rx1140_cur."!mark_fail"(0)
    lt rx1140_pos, -1, rx1140_done
    eq rx1140_pos, -1, rx1140_fail
    jump $I10
  rx1140_done:
    rx1140_cur."!cursor_fail"()
    if_null rx1140_debug, debug_1016
    rx1140_cur."!cursor_debug"("FAIL", "args")
  debug_1016:
    .return (rx1140_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__args"  :nsentry("!PREFIX__args") :subid("226_1300146757.646") :method
.annotate 'line', 10
    $P1142 = self."!PREFIX__!subrule"("arglist", "(")
    new $P1143, "ResizablePMCArray"
    push $P1143, $P1142
    .return ($P1143)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "arglist"  :subid("227_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1146_tgt
    .local int rx1146_pos
    .local int rx1146_off
    .local int rx1146_eos
    .local int rx1146_rep
    .local pmc rx1146_cur
    .local pmc rx1146_debug
    (rx1146_cur, rx1146_pos, rx1146_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1146_cur
    .local pmc match
    .lex "$/", match
    length rx1146_eos, rx1146_tgt
    gt rx1146_pos, rx1146_eos, rx1146_done
    set rx1146_off, 0
    lt rx1146_pos, 2, rx1146_start
    sub rx1146_off, rx1146_pos, 1
    substr rx1146_tgt, rx1146_tgt, rx1146_off
  rx1146_start:
    eq $I10, 1, rx1146_restart
    if_null rx1146_debug, debug_1017
    rx1146_cur."!cursor_debug"("START", "arglist")
  debug_1017:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1150_done
    goto rxscan1150_scan
  rxscan1150_loop:
    (rx1146_pos) = rx1146_cur."from"()
    inc rx1146_pos
    rx1146_cur."!cursor_from"(rx1146_pos)
    ge rx1146_pos, rx1146_eos, rxscan1150_done
  rxscan1150_scan:
    set_addr $I10, rxscan1150_loop
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
  rxscan1150_done:
.annotate 'line', 528
  # rx subrule "ws" subtype=method negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."ws"()
    unless $P10, rx1146_fail
    rx1146_pos = $P10."pos"()
  alt1151_0:
.annotate 'line', 529
    set_addr $I10, alt1151_1
    rx1146_cur."!mark_push"(0, rx1146_pos, $I10)
.annotate 'line', 530
  # rx subrule "EXPR" subtype=capture negate=
    rx1146_cur."!cursor_pos"(rx1146_pos)
    $P10 = rx1146_cur."EXPR"("f=")
    unless $P10, rx1146_fail
    rx1146_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1146_pos = $P10."pos"()
    goto alt1151_end
  alt1151_1:
  alt1151_end:
.annotate 'line', 527
  # rx pass
    rx1146_cur."!cursor_pass"(rx1146_pos, "arglist")
    if_null rx1146_debug, debug_1018
    rx1146_cur."!cursor_debug"("PASS", "arglist", " at pos=", rx1146_pos)
  debug_1018:
    .return (rx1146_cur)
  rx1146_restart:
.annotate 'line', 10
    if_null rx1146_debug, debug_1019
    rx1146_cur."!cursor_debug"("NEXT", "arglist")
  debug_1019:
  rx1146_fail:
    (rx1146_rep, rx1146_pos, $I10, $P10) = rx1146_cur."!mark_fail"(0)
    lt rx1146_pos, -1, rx1146_done
    eq rx1146_pos, -1, rx1146_fail
    jump $I10
  rx1146_done:
    rx1146_cur."!cursor_fail"()
    if_null rx1146_debug, debug_1020
    rx1146_cur."!cursor_debug"("FAIL", "arglist")
  debug_1020:
    .return (rx1146_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__arglist"  :nsentry("!PREFIX__arglist") :subid("228_1300146757.646") :method
.annotate 'line', 10
    $P1148 = self."!PREFIX__!subrule"("ws", "")
    new $P1149, "ResizablePMCArray"
    push $P1149, $P1148
    .return ($P1149)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<value>"  :subid("229_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1153_tgt
    .local int rx1153_pos
    .local int rx1153_off
    .local int rx1153_eos
    .local int rx1153_rep
    .local pmc rx1153_cur
    .local pmc rx1153_debug
    (rx1153_cur, rx1153_pos, rx1153_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1153_cur
    .local pmc match
    .lex "$/", match
    length rx1153_eos, rx1153_tgt
    gt rx1153_pos, rx1153_eos, rx1153_done
    set rx1153_off, 0
    lt rx1153_pos, 2, rx1153_start
    sub rx1153_off, rx1153_pos, 1
    substr rx1153_tgt, rx1153_tgt, rx1153_off
  rx1153_start:
    eq $I10, 1, rx1153_restart
    if_null rx1153_debug, debug_1021
    rx1153_cur."!cursor_debug"("START", "term:sym<value>")
  debug_1021:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1157_done
    goto rxscan1157_scan
  rxscan1157_loop:
    (rx1153_pos) = rx1153_cur."from"()
    inc rx1153_pos
    rx1153_cur."!cursor_from"(rx1153_pos)
    ge rx1153_pos, rx1153_eos, rxscan1157_done
  rxscan1157_scan:
    set_addr $I10, rxscan1157_loop
    rx1153_cur."!mark_push"(0, rx1153_pos, $I10)
  rxscan1157_done:
.annotate 'line', 536
  # rx subrule "value" subtype=capture negate=
    rx1153_cur."!cursor_pos"(rx1153_pos)
    $P10 = rx1153_cur."value"()
    unless $P10, rx1153_fail
    rx1153_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("value")
    rx1153_pos = $P10."pos"()
  # rx pass
    rx1153_cur."!cursor_pass"(rx1153_pos, "term:sym<value>")
    if_null rx1153_debug, debug_1022
    rx1153_cur."!cursor_debug"("PASS", "term:sym<value>", " at pos=", rx1153_pos)
  debug_1022:
    .return (rx1153_cur)
  rx1153_restart:
.annotate 'line', 10
    if_null rx1153_debug, debug_1023
    rx1153_cur."!cursor_debug"("NEXT", "term:sym<value>")
  debug_1023:
  rx1153_fail:
    (rx1153_rep, rx1153_pos, $I10, $P10) = rx1153_cur."!mark_fail"(0)
    lt rx1153_pos, -1, rx1153_done
    eq rx1153_pos, -1, rx1153_fail
    jump $I10
  rx1153_done:
    rx1153_cur."!cursor_fail"()
    if_null rx1153_debug, debug_1024
    rx1153_cur."!cursor_debug"("FAIL", "term:sym<value>")
  debug_1024:
    .return (rx1153_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<value>"  :nsentry("!PREFIX__term:sym<value>") :subid("230_1300146757.646") :method
.annotate 'line', 10
    $P1155 = self."!PREFIX__!subrule"("value", "")
    new $P1156, "ResizablePMCArray"
    push $P1156, $P1155
    .return ($P1156)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "value"  :subid("231_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1159_tgt
    .local int rx1159_pos
    .local int rx1159_off
    .local int rx1159_eos
    .local int rx1159_rep
    .local pmc rx1159_cur
    .local pmc rx1159_debug
    (rx1159_cur, rx1159_pos, rx1159_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1159_cur
    .local pmc match
    .lex "$/", match
    length rx1159_eos, rx1159_tgt
    gt rx1159_pos, rx1159_eos, rx1159_done
    set rx1159_off, 0
    lt rx1159_pos, 2, rx1159_start
    sub rx1159_off, rx1159_pos, 1
    substr rx1159_tgt, rx1159_tgt, rx1159_off
  rx1159_start:
    eq $I10, 1, rx1159_restart
    if_null rx1159_debug, debug_1025
    rx1159_cur."!cursor_debug"("START", "value")
  debug_1025:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1164_done
    goto rxscan1164_scan
  rxscan1164_loop:
    (rx1159_pos) = rx1159_cur."from"()
    inc rx1159_pos
    rx1159_cur."!cursor_from"(rx1159_pos)
    ge rx1159_pos, rx1159_eos, rxscan1164_done
  rxscan1164_scan:
    set_addr $I10, rxscan1164_loop
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
  rxscan1164_done:
  alt1165_0:
.annotate 'line', 538
    set_addr $I10, alt1165_1
    rx1159_cur."!mark_push"(0, rx1159_pos, $I10)
.annotate 'line', 539
  # rx subrule "quote" subtype=capture negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."quote"()
    unless $P10, rx1159_fail
    rx1159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote")
    rx1159_pos = $P10."pos"()
    goto alt1165_end
  alt1165_1:
.annotate 'line', 540
  # rx subrule "number" subtype=capture negate=
    rx1159_cur."!cursor_pos"(rx1159_pos)
    $P10 = rx1159_cur."number"()
    unless $P10, rx1159_fail
    rx1159_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("number")
    rx1159_pos = $P10."pos"()
  alt1165_end:
.annotate 'line', 538
  # rx pass
    rx1159_cur."!cursor_pass"(rx1159_pos, "value")
    if_null rx1159_debug, debug_1026
    rx1159_cur."!cursor_debug"("PASS", "value", " at pos=", rx1159_pos)
  debug_1026:
    .return (rx1159_cur)
  rx1159_restart:
.annotate 'line', 10
    if_null rx1159_debug, debug_1027
    rx1159_cur."!cursor_debug"("NEXT", "value")
  debug_1027:
  rx1159_fail:
    (rx1159_rep, rx1159_pos, $I10, $P10) = rx1159_cur."!mark_fail"(0)
    lt rx1159_pos, -1, rx1159_done
    eq rx1159_pos, -1, rx1159_fail
    jump $I10
  rx1159_done:
    rx1159_cur."!cursor_fail"()
    if_null rx1159_debug, debug_1028
    rx1159_cur."!cursor_debug"("FAIL", "value")
  debug_1028:
    .return (rx1159_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__value"  :nsentry("!PREFIX__value") :subid("232_1300146757.646") :method
.annotate 'line', 10
    $P1161 = self."!PREFIX__!subrule"("number", "")
    $P1162 = self."!PREFIX__!subrule"("quote", "")
    new $P1163, "ResizablePMCArray"
    push $P1163, $P1161
    push $P1163, $P1162
    .return ($P1163)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "number"  :subid("233_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1167_tgt
    .local int rx1167_pos
    .local int rx1167_off
    .local int rx1167_eos
    .local int rx1167_rep
    .local pmc rx1167_cur
    .local pmc rx1167_debug
    (rx1167_cur, rx1167_pos, rx1167_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1167_cur
    .local pmc match
    .lex "$/", match
    length rx1167_eos, rx1167_tgt
    gt rx1167_pos, rx1167_eos, rx1167_done
    set rx1167_off, 0
    lt rx1167_pos, 2, rx1167_start
    sub rx1167_off, rx1167_pos, 1
    substr rx1167_tgt, rx1167_tgt, rx1167_off
  rx1167_start:
    eq $I10, 1, rx1167_restart
    if_null rx1167_debug, debug_1029
    rx1167_cur."!cursor_debug"("START", "number")
  debug_1029:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1170_done
    goto rxscan1170_scan
  rxscan1170_loop:
    (rx1167_pos) = rx1167_cur."from"()
    inc rx1167_pos
    rx1167_cur."!cursor_from"(rx1167_pos)
    ge rx1167_pos, rx1167_eos, rxscan1170_done
  rxscan1170_scan:
    set_addr $I10, rxscan1170_loop
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  rxscan1170_done:
.annotate 'line', 544
  # rx subcapture "sign"
    set_addr $I10, rxcap_1172_fail
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  # rx enumcharlist_q negate=0  r 0..1
    sub $I10, rx1167_pos, rx1167_off
    set rx1167_rep, 0
    sub $I12, rx1167_eos, rx1167_pos
    le $I12, 1, rxenumcharlistq1171_loop
    set $I12, 1
  rxenumcharlistq1171_loop:
    le $I12, 0, rxenumcharlistq1171_done
    substr $S10, rx1167_tgt, $I10, 1
    index $I11, "+-", $S10
    lt $I11, 0, rxenumcharlistq1171_done
    inc rx1167_rep
  rxenumcharlistq1171_done:
    add rx1167_pos, rx1167_pos, rx1167_rep
    set_addr $I10, rxcap_1172_fail
    ($I12, $I11) = rx1167_cur."!mark_peek"($I10)
    rx1167_cur."!cursor_pos"($I11)
    ($P10) = rx1167_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1167_pos, "")
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sign")
    goto rxcap_1172_done
  rxcap_1172_fail:
    goto rx1167_fail
  rxcap_1172_done:
  alt1173_0:
.annotate 'line', 545
    set_addr $I10, alt1173_1
    rx1167_cur."!mark_push"(0, rx1167_pos, $I10)
  # rx subrule "dec_number" subtype=capture negate=
    rx1167_cur."!cursor_pos"(rx1167_pos)
    $P10 = rx1167_cur."dec_number"()
    unless $P10, rx1167_fail
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dec_number")
    rx1167_pos = $P10."pos"()
    goto alt1173_end
  alt1173_1:
  # rx subrule "integer" subtype=capture negate=
    rx1167_cur."!cursor_pos"(rx1167_pos)
    $P10 = rx1167_cur."integer"()
    unless $P10, rx1167_fail
    rx1167_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("integer")
    rx1167_pos = $P10."pos"()
  alt1173_end:
.annotate 'line', 543
  # rx pass
    rx1167_cur."!cursor_pass"(rx1167_pos, "number")
    if_null rx1167_debug, debug_1030
    rx1167_cur."!cursor_debug"("PASS", "number", " at pos=", rx1167_pos)
  debug_1030:
    .return (rx1167_cur)
  rx1167_restart:
.annotate 'line', 10
    if_null rx1167_debug, debug_1031
    rx1167_cur."!cursor_debug"("NEXT", "number")
  debug_1031:
  rx1167_fail:
    (rx1167_rep, rx1167_pos, $I10, $P10) = rx1167_cur."!mark_fail"(0)
    lt rx1167_pos, -1, rx1167_done
    eq rx1167_pos, -1, rx1167_fail
    jump $I10
  rx1167_done:
    rx1167_cur."!cursor_fail"()
    if_null rx1167_debug, debug_1032
    rx1167_cur."!cursor_debug"("FAIL", "number")
  debug_1032:
    .return (rx1167_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__number"  :nsentry("!PREFIX__number") :subid("234_1300146757.646") :method
.annotate 'line', 10
    new $P1169, "ResizablePMCArray"
    push $P1169, ""
    .return ($P1169)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote"  :subid("235_1300146757.646")
    .param pmc param_1175
.annotate 'line', 548
    .lex "self", param_1175
    $P1176 = param_1175."!protoregex"("quote")
    .return ($P1176)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote"  :subid("236_1300146757.646")
    .param pmc param_1178
.annotate 'line', 548
    .lex "self", param_1178
    $P1179 = param_1178."!PREFIX__!protoregex"("quote")
    .return ($P1179)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<apos>"  :subid("237_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1181_tgt
    .local int rx1181_pos
    .local int rx1181_off
    .local int rx1181_eos
    .local int rx1181_rep
    .local pmc rx1181_cur
    .local pmc rx1181_debug
    (rx1181_cur, rx1181_pos, rx1181_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1181_cur
    .local pmc match
    .lex "$/", match
    length rx1181_eos, rx1181_tgt
    gt rx1181_pos, rx1181_eos, rx1181_done
    set rx1181_off, 0
    lt rx1181_pos, 2, rx1181_start
    sub rx1181_off, rx1181_pos, 1
    substr rx1181_tgt, rx1181_tgt, rx1181_off
  rx1181_start:
    eq $I10, 1, rx1181_restart
    if_null rx1181_debug, debug_1033
    rx1181_cur."!cursor_debug"("START", "quote:sym<apos>")
  debug_1033:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1184_done
    goto rxscan1184_scan
  rxscan1184_loop:
    (rx1181_pos) = rx1181_cur."from"()
    inc rx1181_pos
    rx1181_cur."!cursor_from"(rx1181_pos)
    ge rx1181_pos, rx1181_eos, rxscan1184_done
  rxscan1184_scan:
    set_addr $I10, rxscan1184_loop
    rx1181_cur."!mark_push"(0, rx1181_pos, $I10)
  rxscan1184_done:
.annotate 'line', 549
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1181_pos, rx1181_off
    substr $S10, rx1181_tgt, $I10, 1
    index $I11, "'", $S10
    lt $I11, 0, rx1181_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1181_cur."!cursor_pos"(rx1181_pos)
    $P10 = rx1181_cur."quote_EXPR"(":q")
    unless $P10, rx1181_fail
    rx1181_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1181_pos = $P10."pos"()
  # rx pass
    rx1181_cur."!cursor_pass"(rx1181_pos, "quote:sym<apos>")
    if_null rx1181_debug, debug_1034
    rx1181_cur."!cursor_debug"("PASS", "quote:sym<apos>", " at pos=", rx1181_pos)
  debug_1034:
    .return (rx1181_cur)
  rx1181_restart:
.annotate 'line', 10
    if_null rx1181_debug, debug_1035
    rx1181_cur."!cursor_debug"("NEXT", "quote:sym<apos>")
  debug_1035:
  rx1181_fail:
    (rx1181_rep, rx1181_pos, $I10, $P10) = rx1181_cur."!mark_fail"(0)
    lt rx1181_pos, -1, rx1181_done
    eq rx1181_pos, -1, rx1181_fail
    jump $I10
  rx1181_done:
    rx1181_cur."!cursor_fail"()
    if_null rx1181_debug, debug_1036
    rx1181_cur."!cursor_debug"("FAIL", "quote:sym<apos>")
  debug_1036:
    .return (rx1181_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<apos>"  :nsentry("!PREFIX__quote:sym<apos>") :subid("238_1300146757.646") :method
.annotate 'line', 10
    new $P1183, "ResizablePMCArray"
    push $P1183, "'"
    .return ($P1183)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<dblq>"  :subid("239_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1186_tgt
    .local int rx1186_pos
    .local int rx1186_off
    .local int rx1186_eos
    .local int rx1186_rep
    .local pmc rx1186_cur
    .local pmc rx1186_debug
    (rx1186_cur, rx1186_pos, rx1186_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1186_cur
    .local pmc match
    .lex "$/", match
    length rx1186_eos, rx1186_tgt
    gt rx1186_pos, rx1186_eos, rx1186_done
    set rx1186_off, 0
    lt rx1186_pos, 2, rx1186_start
    sub rx1186_off, rx1186_pos, 1
    substr rx1186_tgt, rx1186_tgt, rx1186_off
  rx1186_start:
    eq $I10, 1, rx1186_restart
    if_null rx1186_debug, debug_1037
    rx1186_cur."!cursor_debug"("START", "quote:sym<dblq>")
  debug_1037:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1189_done
    goto rxscan1189_scan
  rxscan1189_loop:
    (rx1186_pos) = rx1186_cur."from"()
    inc rx1186_pos
    rx1186_cur."!cursor_from"(rx1186_pos)
    ge rx1186_pos, rx1186_eos, rxscan1189_done
  rxscan1189_scan:
    set_addr $I10, rxscan1189_loop
    rx1186_cur."!mark_push"(0, rx1186_pos, $I10)
  rxscan1189_done:
.annotate 'line', 550
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1186_pos, rx1186_off
    substr $S10, rx1186_tgt, $I10, 1
    index $I11, "\"", $S10
    lt $I11, 0, rx1186_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1186_cur."!cursor_pos"(rx1186_pos)
    $P10 = rx1186_cur."quote_EXPR"(":qq")
    unless $P10, rx1186_fail
    rx1186_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1186_pos = $P10."pos"()
  # rx pass
    rx1186_cur."!cursor_pass"(rx1186_pos, "quote:sym<dblq>")
    if_null rx1186_debug, debug_1038
    rx1186_cur."!cursor_debug"("PASS", "quote:sym<dblq>", " at pos=", rx1186_pos)
  debug_1038:
    .return (rx1186_cur)
  rx1186_restart:
.annotate 'line', 10
    if_null rx1186_debug, debug_1039
    rx1186_cur."!cursor_debug"("NEXT", "quote:sym<dblq>")
  debug_1039:
  rx1186_fail:
    (rx1186_rep, rx1186_pos, $I10, $P10) = rx1186_cur."!mark_fail"(0)
    lt rx1186_pos, -1, rx1186_done
    eq rx1186_pos, -1, rx1186_fail
    jump $I10
  rx1186_done:
    rx1186_cur."!cursor_fail"()
    if_null rx1186_debug, debug_1040
    rx1186_cur."!cursor_debug"("FAIL", "quote:sym<dblq>")
  debug_1040:
    .return (rx1186_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<dblq>"  :nsentry("!PREFIX__quote:sym<dblq>") :subid("240_1300146757.646") :method
.annotate 'line', 10
    new $P1188, "ResizablePMCArray"
    push $P1188, "\""
    .return ($P1188)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<q>"  :subid("241_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1191_tgt
    .local int rx1191_pos
    .local int rx1191_off
    .local int rx1191_eos
    .local int rx1191_rep
    .local pmc rx1191_cur
    .local pmc rx1191_debug
    (rx1191_cur, rx1191_pos, rx1191_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1191_cur
    .local pmc match
    .lex "$/", match
    length rx1191_eos, rx1191_tgt
    gt rx1191_pos, rx1191_eos, rx1191_done
    set rx1191_off, 0
    lt rx1191_pos, 2, rx1191_start
    sub rx1191_off, rx1191_pos, 1
    substr rx1191_tgt, rx1191_tgt, rx1191_off
  rx1191_start:
    eq $I10, 1, rx1191_restart
    if_null rx1191_debug, debug_1041
    rx1191_cur."!cursor_debug"("START", "quote:sym<q>")
  debug_1041:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1195_done
    goto rxscan1195_scan
  rxscan1195_loop:
    (rx1191_pos) = rx1191_cur."from"()
    inc rx1191_pos
    rx1191_cur."!cursor_from"(rx1191_pos)
    ge rx1191_pos, rx1191_eos, rxscan1195_done
  rxscan1195_scan:
    set_addr $I10, rxscan1195_loop
    rx1191_cur."!mark_push"(0, rx1191_pos, $I10)
  rxscan1195_done:
.annotate 'line', 551
  # rx literal  "q"
    add $I11, rx1191_pos, 1
    gt $I11, rx1191_eos, rx1191_fail
    sub $I11, rx1191_pos, rx1191_off
    ord $I11, rx1191_tgt, $I11
    ne $I11, 113, rx1191_fail
    add rx1191_pos, 1
  # rxanchor rwb
    le rx1191_pos, 0, rx1191_fail
    sub $I10, rx1191_pos, rx1191_off
    is_cclass $I11, 8192, rx1191_tgt, $I10
    if $I11, rx1191_fail
    dec $I10
    is_cclass $I11, 8192, rx1191_tgt, $I10
    unless $I11, rx1191_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1191_pos, rx1191_off
    substr $S10, rx1191_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1191_fail
  # rx subrule "ws" subtype=method negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."ws"()
    unless $P10, rx1191_fail
    rx1191_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1191_cur."!cursor_pos"(rx1191_pos)
    $P10 = rx1191_cur."quote_EXPR"(":q")
    unless $P10, rx1191_fail
    rx1191_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1191_pos = $P10."pos"()
  # rx pass
    rx1191_cur."!cursor_pass"(rx1191_pos, "quote:sym<q>")
    if_null rx1191_debug, debug_1042
    rx1191_cur."!cursor_debug"("PASS", "quote:sym<q>", " at pos=", rx1191_pos)
  debug_1042:
    .return (rx1191_cur)
  rx1191_restart:
.annotate 'line', 10
    if_null rx1191_debug, debug_1043
    rx1191_cur."!cursor_debug"("NEXT", "quote:sym<q>")
  debug_1043:
  rx1191_fail:
    (rx1191_rep, rx1191_pos, $I10, $P10) = rx1191_cur."!mark_fail"(0)
    lt rx1191_pos, -1, rx1191_done
    eq rx1191_pos, -1, rx1191_fail
    jump $I10
  rx1191_done:
    rx1191_cur."!cursor_fail"()
    if_null rx1191_debug, debug_1044
    rx1191_cur."!cursor_debug"("FAIL", "quote:sym<q>")
  debug_1044:
    .return (rx1191_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<q>"  :nsentry("!PREFIX__quote:sym<q>") :subid("242_1300146757.646") :method
.annotate 'line', 10
    $P1193 = self."!PREFIX__!subrule"("ws", "q")
    new $P1194, "ResizablePMCArray"
    push $P1194, $P1193
    .return ($P1194)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<qq>"  :subid("243_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1197_tgt
    .local int rx1197_pos
    .local int rx1197_off
    .local int rx1197_eos
    .local int rx1197_rep
    .local pmc rx1197_cur
    .local pmc rx1197_debug
    (rx1197_cur, rx1197_pos, rx1197_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1197_cur
    .local pmc match
    .lex "$/", match
    length rx1197_eos, rx1197_tgt
    gt rx1197_pos, rx1197_eos, rx1197_done
    set rx1197_off, 0
    lt rx1197_pos, 2, rx1197_start
    sub rx1197_off, rx1197_pos, 1
    substr rx1197_tgt, rx1197_tgt, rx1197_off
  rx1197_start:
    eq $I10, 1, rx1197_restart
    if_null rx1197_debug, debug_1045
    rx1197_cur."!cursor_debug"("START", "quote:sym<qq>")
  debug_1045:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1201_done
    goto rxscan1201_scan
  rxscan1201_loop:
    (rx1197_pos) = rx1197_cur."from"()
    inc rx1197_pos
    rx1197_cur."!cursor_from"(rx1197_pos)
    ge rx1197_pos, rx1197_eos, rxscan1201_done
  rxscan1201_scan:
    set_addr $I10, rxscan1201_loop
    rx1197_cur."!mark_push"(0, rx1197_pos, $I10)
  rxscan1201_done:
.annotate 'line', 552
  # rx literal  "qq"
    add $I11, rx1197_pos, 2
    gt $I11, rx1197_eos, rx1197_fail
    sub $I11, rx1197_pos, rx1197_off
    substr $S10, rx1197_tgt, $I11, 2
    ne $S10, "qq", rx1197_fail
    add rx1197_pos, 2
  # rxanchor rwb
    le rx1197_pos, 0, rx1197_fail
    sub $I10, rx1197_pos, rx1197_off
    is_cclass $I11, 8192, rx1197_tgt, $I10
    if $I11, rx1197_fail
    dec $I10
    is_cclass $I11, 8192, rx1197_tgt, $I10
    unless $I11, rx1197_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1197_pos, rx1197_off
    substr $S10, rx1197_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1197_fail
  # rx subrule "ws" subtype=method negate=
    rx1197_cur."!cursor_pos"(rx1197_pos)
    $P10 = rx1197_cur."ws"()
    unless $P10, rx1197_fail
    rx1197_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1197_cur."!cursor_pos"(rx1197_pos)
    $P10 = rx1197_cur."quote_EXPR"(":qq")
    unless $P10, rx1197_fail
    rx1197_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1197_pos = $P10."pos"()
  # rx pass
    rx1197_cur."!cursor_pass"(rx1197_pos, "quote:sym<qq>")
    if_null rx1197_debug, debug_1046
    rx1197_cur."!cursor_debug"("PASS", "quote:sym<qq>", " at pos=", rx1197_pos)
  debug_1046:
    .return (rx1197_cur)
  rx1197_restart:
.annotate 'line', 10
    if_null rx1197_debug, debug_1047
    rx1197_cur."!cursor_debug"("NEXT", "quote:sym<qq>")
  debug_1047:
  rx1197_fail:
    (rx1197_rep, rx1197_pos, $I10, $P10) = rx1197_cur."!mark_fail"(0)
    lt rx1197_pos, -1, rx1197_done
    eq rx1197_pos, -1, rx1197_fail
    jump $I10
  rx1197_done:
    rx1197_cur."!cursor_fail"()
    if_null rx1197_debug, debug_1048
    rx1197_cur."!cursor_debug"("FAIL", "quote:sym<qq>")
  debug_1048:
    .return (rx1197_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<qq>"  :nsentry("!PREFIX__quote:sym<qq>") :subid("244_1300146757.646") :method
.annotate 'line', 10
    $P1199 = self."!PREFIX__!subrule"("ws", "qq")
    new $P1200, "ResizablePMCArray"
    push $P1200, $P1199
    .return ($P1200)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q>"  :subid("245_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1203_tgt
    .local int rx1203_pos
    .local int rx1203_off
    .local int rx1203_eos
    .local int rx1203_rep
    .local pmc rx1203_cur
    .local pmc rx1203_debug
    (rx1203_cur, rx1203_pos, rx1203_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1203_cur
    .local pmc match
    .lex "$/", match
    length rx1203_eos, rx1203_tgt
    gt rx1203_pos, rx1203_eos, rx1203_done
    set rx1203_off, 0
    lt rx1203_pos, 2, rx1203_start
    sub rx1203_off, rx1203_pos, 1
    substr rx1203_tgt, rx1203_tgt, rx1203_off
  rx1203_start:
    eq $I10, 1, rx1203_restart
    if_null rx1203_debug, debug_1049
    rx1203_cur."!cursor_debug"("START", "quote:sym<Q>")
  debug_1049:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1207_done
    goto rxscan1207_scan
  rxscan1207_loop:
    (rx1203_pos) = rx1203_cur."from"()
    inc rx1203_pos
    rx1203_cur."!cursor_from"(rx1203_pos)
    ge rx1203_pos, rx1203_eos, rxscan1207_done
  rxscan1207_scan:
    set_addr $I10, rxscan1207_loop
    rx1203_cur."!mark_push"(0, rx1203_pos, $I10)
  rxscan1207_done:
.annotate 'line', 553
  # rx literal  "Q"
    add $I11, rx1203_pos, 1
    gt $I11, rx1203_eos, rx1203_fail
    sub $I11, rx1203_pos, rx1203_off
    ord $I11, rx1203_tgt, $I11
    ne $I11, 81, rx1203_fail
    add rx1203_pos, 1
  # rxanchor rwb
    le rx1203_pos, 0, rx1203_fail
    sub $I10, rx1203_pos, rx1203_off
    is_cclass $I11, 8192, rx1203_tgt, $I10
    if $I11, rx1203_fail
    dec $I10
    is_cclass $I11, 8192, rx1203_tgt, $I10
    unless $I11, rx1203_fail
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1203_pos, rx1203_off
    substr $S10, rx1203_tgt, $I10, 1
    index $I11, "(", $S10
    ge $I11, 0, rx1203_fail
  # rx subrule "ws" subtype=method negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."ws"()
    unless $P10, rx1203_fail
    rx1203_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1203_cur."!cursor_pos"(rx1203_pos)
    $P10 = rx1203_cur."quote_EXPR"()
    unless $P10, rx1203_fail
    rx1203_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1203_pos = $P10."pos"()
  # rx pass
    rx1203_cur."!cursor_pass"(rx1203_pos, "quote:sym<Q>")
    if_null rx1203_debug, debug_1050
    rx1203_cur."!cursor_debug"("PASS", "quote:sym<Q>", " at pos=", rx1203_pos)
  debug_1050:
    .return (rx1203_cur)
  rx1203_restart:
.annotate 'line', 10
    if_null rx1203_debug, debug_1051
    rx1203_cur."!cursor_debug"("NEXT", "quote:sym<Q>")
  debug_1051:
  rx1203_fail:
    (rx1203_rep, rx1203_pos, $I10, $P10) = rx1203_cur."!mark_fail"(0)
    lt rx1203_pos, -1, rx1203_done
    eq rx1203_pos, -1, rx1203_fail
    jump $I10
  rx1203_done:
    rx1203_cur."!cursor_fail"()
    if_null rx1203_debug, debug_1052
    rx1203_cur."!cursor_debug"("FAIL", "quote:sym<Q>")
  debug_1052:
    .return (rx1203_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q>"  :nsentry("!PREFIX__quote:sym<Q>") :subid("246_1300146757.646") :method
.annotate 'line', 10
    $P1205 = self."!PREFIX__!subrule"("ws", "Q")
    new $P1206, "ResizablePMCArray"
    push $P1206, $P1205
    .return ($P1206)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym<Q:PIR>"  :subid("247_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1209_tgt
    .local int rx1209_pos
    .local int rx1209_off
    .local int rx1209_eos
    .local int rx1209_rep
    .local pmc rx1209_cur
    .local pmc rx1209_debug
    (rx1209_cur, rx1209_pos, rx1209_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1209_cur
    .local pmc match
    .lex "$/", match
    length rx1209_eos, rx1209_tgt
    gt rx1209_pos, rx1209_eos, rx1209_done
    set rx1209_off, 0
    lt rx1209_pos, 2, rx1209_start
    sub rx1209_off, rx1209_pos, 1
    substr rx1209_tgt, rx1209_tgt, rx1209_off
  rx1209_start:
    eq $I10, 1, rx1209_restart
    if_null rx1209_debug, debug_1053
    rx1209_cur."!cursor_debug"("START", "quote:sym<Q:PIR>")
  debug_1053:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1213_done
    goto rxscan1213_scan
  rxscan1213_loop:
    (rx1209_pos) = rx1209_cur."from"()
    inc rx1209_pos
    rx1209_cur."!cursor_from"(rx1209_pos)
    ge rx1209_pos, rx1209_eos, rxscan1213_done
  rxscan1213_scan:
    set_addr $I10, rxscan1213_loop
    rx1209_cur."!mark_push"(0, rx1209_pos, $I10)
  rxscan1213_done:
.annotate 'line', 554
  # rx literal  "Q:PIR"
    add $I11, rx1209_pos, 5
    gt $I11, rx1209_eos, rx1209_fail
    sub $I11, rx1209_pos, rx1209_off
    substr $S10, rx1209_tgt, $I11, 5
    ne $S10, "Q:PIR", rx1209_fail
    add rx1209_pos, 5
  # rx subrule "ws" subtype=method negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."ws"()
    unless $P10, rx1209_fail
    rx1209_pos = $P10."pos"()
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1209_cur."!cursor_pos"(rx1209_pos)
    $P10 = rx1209_cur."quote_EXPR"()
    unless $P10, rx1209_fail
    rx1209_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1209_pos = $P10."pos"()
  # rx pass
    rx1209_cur."!cursor_pass"(rx1209_pos, "quote:sym<Q:PIR>")
    if_null rx1209_debug, debug_1054
    rx1209_cur."!cursor_debug"("PASS", "quote:sym<Q:PIR>", " at pos=", rx1209_pos)
  debug_1054:
    .return (rx1209_cur)
  rx1209_restart:
.annotate 'line', 10
    if_null rx1209_debug, debug_1055
    rx1209_cur."!cursor_debug"("NEXT", "quote:sym<Q:PIR>")
  debug_1055:
  rx1209_fail:
    (rx1209_rep, rx1209_pos, $I10, $P10) = rx1209_cur."!mark_fail"(0)
    lt rx1209_pos, -1, rx1209_done
    eq rx1209_pos, -1, rx1209_fail
    jump $I10
  rx1209_done:
    rx1209_cur."!cursor_fail"()
    if_null rx1209_debug, debug_1056
    rx1209_cur."!cursor_debug"("FAIL", "quote:sym<Q:PIR>")
  debug_1056:
    .return (rx1209_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym<Q:PIR>"  :nsentry("!PREFIX__quote:sym<Q:PIR>") :subid("248_1300146757.646") :method
.annotate 'line', 10
    $P1211 = self."!PREFIX__!subrule"("ws", "Q:PIR")
    new $P1212, "ResizablePMCArray"
    push $P1212, $P1211
    .return ($P1212)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote:sym</ />"  :subid("249_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1215_tgt
    .local int rx1215_pos
    .local int rx1215_off
    .local int rx1215_eos
    .local int rx1215_rep
    .local pmc rx1215_cur
    .local pmc rx1215_debug
    (rx1215_cur, rx1215_pos, rx1215_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1215_cur
    .local pmc match
    .lex "$/", match
    length rx1215_eos, rx1215_tgt
    gt rx1215_pos, rx1215_eos, rx1215_done
    set rx1215_off, 0
    lt rx1215_pos, 2, rx1215_start
    sub rx1215_off, rx1215_pos, 1
    substr rx1215_tgt, rx1215_tgt, rx1215_off
  rx1215_start:
    eq $I10, 1, rx1215_restart
    if_null rx1215_debug, debug_1057
    rx1215_cur."!cursor_debug"("START", "quote:sym</ />")
  debug_1057:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1219_done
    goto rxscan1219_scan
  rxscan1219_loop:
    (rx1215_pos) = rx1215_cur."from"()
    inc rx1215_pos
    rx1215_cur."!cursor_from"(rx1215_pos)
    ge rx1215_pos, rx1215_eos, rxscan1219_done
  rxscan1219_scan:
    set_addr $I10, rxscan1219_loop
    rx1215_cur."!mark_push"(0, rx1215_pos, $I10)
  rxscan1219_done:
.annotate 'line', 556
  # rx literal  "/"
    add $I11, rx1215_pos, 1
    gt $I11, rx1215_eos, rx1215_fail
    sub $I11, rx1215_pos, rx1215_off
    ord $I11, rx1215_tgt, $I11
    ne $I11, 47, rx1215_fail
    add rx1215_pos, 1
.annotate 'line', 557
  # rx subrule "newpad" subtype=method negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."newpad"()
    unless $P10, rx1215_fail
    rx1215_pos = $P10."pos"()
.annotate 'line', 558
  # rx reduce name="quote:sym</ />" key="open"
    rx1215_cur."!cursor_pos"(rx1215_pos)
    rx1215_cur."!reduce"("quote:sym</ />", "open")
.annotate 'line', 559
  # rx subrule "LANG" subtype=capture negate=
    rx1215_cur."!cursor_pos"(rx1215_pos)
    $P10 = rx1215_cur."LANG"("Regex", "nibbler")
    unless $P10, rx1215_fail
    rx1215_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("p6regex")
    rx1215_pos = $P10."pos"()
.annotate 'line', 560
  # rx literal  "/"
    add $I11, rx1215_pos, 1
    gt $I11, rx1215_eos, rx1215_fail
    sub $I11, rx1215_pos, rx1215_off
    ord $I11, rx1215_tgt, $I11
    ne $I11, 47, rx1215_fail
    add rx1215_pos, 1
.annotate 'line', 555
  # rx pass
    rx1215_cur."!cursor_pass"(rx1215_pos, "quote:sym</ />")
    if_null rx1215_debug, debug_1058
    rx1215_cur."!cursor_debug"("PASS", "quote:sym</ />", " at pos=", rx1215_pos)
  debug_1058:
    .return (rx1215_cur)
  rx1215_restart:
.annotate 'line', 10
    if_null rx1215_debug, debug_1059
    rx1215_cur."!cursor_debug"("NEXT", "quote:sym</ />")
  debug_1059:
  rx1215_fail:
    (rx1215_rep, rx1215_pos, $I10, $P10) = rx1215_cur."!mark_fail"(0)
    lt rx1215_pos, -1, rx1215_done
    eq rx1215_pos, -1, rx1215_fail
    jump $I10
  rx1215_done:
    rx1215_cur."!cursor_fail"()
    if_null rx1215_debug, debug_1060
    rx1215_cur."!cursor_debug"("FAIL", "quote:sym</ />")
  debug_1060:
    .return (rx1215_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote:sym</ />"  :nsentry("!PREFIX__quote:sym</ />") :subid("250_1300146757.646") :method
.annotate 'line', 10
    $P1217 = self."!PREFIX__!subrule"("newpad", "/")
    new $P1218, "ResizablePMCArray"
    push $P1218, $P1217
    .return ($P1218)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<$>"  :subid("251_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1221_tgt
    .local int rx1221_pos
    .local int rx1221_off
    .local int rx1221_eos
    .local int rx1221_rep
    .local pmc rx1221_cur
    .local pmc rx1221_debug
    (rx1221_cur, rx1221_pos, rx1221_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1221_cur
    .local pmc match
    .lex "$/", match
    length rx1221_eos, rx1221_tgt
    gt rx1221_pos, rx1221_eos, rx1221_done
    set rx1221_off, 0
    lt rx1221_pos, 2, rx1221_start
    sub rx1221_off, rx1221_pos, 1
    substr rx1221_tgt, rx1221_tgt, rx1221_off
  rx1221_start:
    eq $I10, 1, rx1221_restart
    if_null rx1221_debug, debug_1061
    rx1221_cur."!cursor_debug"("START", "quote_escape:sym<$>")
  debug_1061:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1224_done
    goto rxscan1224_scan
  rxscan1224_loop:
    (rx1221_pos) = rx1221_cur."from"()
    inc rx1221_pos
    rx1221_cur."!cursor_from"(rx1221_pos)
    ge rx1221_pos, rx1221_eos, rxscan1224_done
  rxscan1224_scan:
    set_addr $I10, rxscan1224_loop
    rx1221_cur."!mark_push"(0, rx1221_pos, $I10)
  rxscan1224_done:
.annotate 'line', 563
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1221_pos, rx1221_off
    substr $S10, rx1221_tgt, $I10, 1
    index $I11, "$", $S10
    lt $I11, 0, rx1221_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."quotemod_check"("s")
    unless $P10, rx1221_fail
  # rx subrule "variable" subtype=capture negate=
    rx1221_cur."!cursor_pos"(rx1221_pos)
    $P10 = rx1221_cur."variable"()
    unless $P10, rx1221_fail
    rx1221_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("variable")
    rx1221_pos = $P10."pos"()
  # rx pass
    rx1221_cur."!cursor_pass"(rx1221_pos, "quote_escape:sym<$>")
    if_null rx1221_debug, debug_1062
    rx1221_cur."!cursor_debug"("PASS", "quote_escape:sym<$>", " at pos=", rx1221_pos)
  debug_1062:
    .return (rx1221_cur)
  rx1221_restart:
.annotate 'line', 10
    if_null rx1221_debug, debug_1063
    rx1221_cur."!cursor_debug"("NEXT", "quote_escape:sym<$>")
  debug_1063:
  rx1221_fail:
    (rx1221_rep, rx1221_pos, $I10, $P10) = rx1221_cur."!mark_fail"(0)
    lt rx1221_pos, -1, rx1221_done
    eq rx1221_pos, -1, rx1221_fail
    jump $I10
  rx1221_done:
    rx1221_cur."!cursor_fail"()
    if_null rx1221_debug, debug_1064
    rx1221_cur."!cursor_debug"("FAIL", "quote_escape:sym<$>")
  debug_1064:
    .return (rx1221_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<$>"  :nsentry("!PREFIX__quote_escape:sym<$>") :subid("252_1300146757.646") :method
.annotate 'line', 10
    new $P1223, "ResizablePMCArray"
    push $P1223, "$"
    .return ($P1223)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<{ }>"  :subid("253_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1226_tgt
    .local int rx1226_pos
    .local int rx1226_off
    .local int rx1226_eos
    .local int rx1226_rep
    .local pmc rx1226_cur
    .local pmc rx1226_debug
    (rx1226_cur, rx1226_pos, rx1226_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1226_cur
    .local pmc match
    .lex "$/", match
    length rx1226_eos, rx1226_tgt
    gt rx1226_pos, rx1226_eos, rx1226_done
    set rx1226_off, 0
    lt rx1226_pos, 2, rx1226_start
    sub rx1226_off, rx1226_pos, 1
    substr rx1226_tgt, rx1226_tgt, rx1226_off
  rx1226_start:
    eq $I10, 1, rx1226_restart
    if_null rx1226_debug, debug_1065
    rx1226_cur."!cursor_debug"("START", "quote_escape:sym<{ }>")
  debug_1065:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1229_done
    goto rxscan1229_scan
  rxscan1229_loop:
    (rx1226_pos) = rx1226_cur."from"()
    inc rx1226_pos
    rx1226_cur."!cursor_from"(rx1226_pos)
    ge rx1226_pos, rx1226_eos, rxscan1229_done
  rxscan1229_scan:
    set_addr $I10, rxscan1229_loop
    rx1226_cur."!mark_push"(0, rx1226_pos, $I10)
  rxscan1229_done:
.annotate 'line', 564
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1226_pos, rx1226_off
    substr $S10, rx1226_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1226_fail
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."quotemod_check"("c")
    unless $P10, rx1226_fail
  # rx subrule "block" subtype=capture negate=
    rx1226_cur."!cursor_pos"(rx1226_pos)
    $P10 = rx1226_cur."block"()
    unless $P10, rx1226_fail
    rx1226_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx1226_pos = $P10."pos"()
  # rx pass
    rx1226_cur."!cursor_pass"(rx1226_pos, "quote_escape:sym<{ }>")
    if_null rx1226_debug, debug_1066
    rx1226_cur."!cursor_debug"("PASS", "quote_escape:sym<{ }>", " at pos=", rx1226_pos)
  debug_1066:
    .return (rx1226_cur)
  rx1226_restart:
.annotate 'line', 10
    if_null rx1226_debug, debug_1067
    rx1226_cur."!cursor_debug"("NEXT", "quote_escape:sym<{ }>")
  debug_1067:
  rx1226_fail:
    (rx1226_rep, rx1226_pos, $I10, $P10) = rx1226_cur."!mark_fail"(0)
    lt rx1226_pos, -1, rx1226_done
    eq rx1226_pos, -1, rx1226_fail
    jump $I10
  rx1226_done:
    rx1226_cur."!cursor_fail"()
    if_null rx1226_debug, debug_1068
    rx1226_cur."!cursor_debug"("FAIL", "quote_escape:sym<{ }>")
  debug_1068:
    .return (rx1226_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<{ }>"  :nsentry("!PREFIX__quote_escape:sym<{ }>") :subid("254_1300146757.646") :method
.annotate 'line', 10
    new $P1228, "ResizablePMCArray"
    push $P1228, "{"
    .return ($P1228)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "quote_escape:sym<esc>"  :subid("255_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1231_tgt
    .local int rx1231_pos
    .local int rx1231_off
    .local int rx1231_eos
    .local int rx1231_rep
    .local pmc rx1231_cur
    .local pmc rx1231_debug
    (rx1231_cur, rx1231_pos, rx1231_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1231_cur
    .local pmc match
    .lex "$/", match
    length rx1231_eos, rx1231_tgt
    gt rx1231_pos, rx1231_eos, rx1231_done
    set rx1231_off, 0
    lt rx1231_pos, 2, rx1231_start
    sub rx1231_off, rx1231_pos, 1
    substr rx1231_tgt, rx1231_tgt, rx1231_off
  rx1231_start:
    eq $I10, 1, rx1231_restart
    if_null rx1231_debug, debug_1069
    rx1231_cur."!cursor_debug"("START", "quote_escape:sym<esc>")
  debug_1069:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1234_done
    goto rxscan1234_scan
  rxscan1234_loop:
    (rx1231_pos) = rx1231_cur."from"()
    inc rx1231_pos
    rx1231_cur."!cursor_from"(rx1231_pos)
    ge rx1231_pos, rx1231_eos, rxscan1234_done
  rxscan1234_scan:
    set_addr $I10, rxscan1234_loop
    rx1231_cur."!mark_push"(0, rx1231_pos, $I10)
  rxscan1234_done:
.annotate 'line', 565
  # rx literal  "\\e"
    add $I11, rx1231_pos, 2
    gt $I11, rx1231_eos, rx1231_fail
    sub $I11, rx1231_pos, rx1231_off
    substr $S10, rx1231_tgt, $I11, 2
    ne $S10, "\\e", rx1231_fail
    add rx1231_pos, 2
  # rx subrule "quotemod_check" subtype=zerowidth negate=
    rx1231_cur."!cursor_pos"(rx1231_pos)
    $P10 = rx1231_cur."quotemod_check"("b")
    unless $P10, rx1231_fail
  # rx pass
    rx1231_cur."!cursor_pass"(rx1231_pos, "quote_escape:sym<esc>")
    if_null rx1231_debug, debug_1070
    rx1231_cur."!cursor_debug"("PASS", "quote_escape:sym<esc>", " at pos=", rx1231_pos)
  debug_1070:
    .return (rx1231_cur)
  rx1231_restart:
.annotate 'line', 10
    if_null rx1231_debug, debug_1071
    rx1231_cur."!cursor_debug"("NEXT", "quote_escape:sym<esc>")
  debug_1071:
  rx1231_fail:
    (rx1231_rep, rx1231_pos, $I10, $P10) = rx1231_cur."!mark_fail"(0)
    lt rx1231_pos, -1, rx1231_done
    eq rx1231_pos, -1, rx1231_fail
    jump $I10
  rx1231_done:
    rx1231_cur."!cursor_fail"()
    if_null rx1231_debug, debug_1072
    rx1231_cur."!cursor_debug"("FAIL", "quote_escape:sym<esc>")
  debug_1072:
    .return (rx1231_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__quote_escape:sym<esc>"  :nsentry("!PREFIX__quote_escape:sym<esc>") :subid("256_1300146757.646") :method
.annotate 'line', 10
    new $P1233, "ResizablePMCArray"
    push $P1233, "\\e"
    .return ($P1233)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<( )>"  :subid("257_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1236_tgt
    .local int rx1236_pos
    .local int rx1236_off
    .local int rx1236_eos
    .local int rx1236_rep
    .local pmc rx1236_cur
    .local pmc rx1236_debug
    (rx1236_cur, rx1236_pos, rx1236_tgt, $I10) = self."!cursor_start"()
    rx1236_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1236_cur
    .local pmc match
    .lex "$/", match
    length rx1236_eos, rx1236_tgt
    gt rx1236_pos, rx1236_eos, rx1236_done
    set rx1236_off, 0
    lt rx1236_pos, 2, rx1236_start
    sub rx1236_off, rx1236_pos, 1
    substr rx1236_tgt, rx1236_tgt, rx1236_off
  rx1236_start:
    eq $I10, 1, rx1236_restart
    if_null rx1236_debug, debug_1073
    rx1236_cur."!cursor_debug"("START", "circumfix:sym<( )>")
  debug_1073:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1240_done
    goto rxscan1240_scan
  rxscan1240_loop:
    (rx1236_pos) = rx1236_cur."from"()
    inc rx1236_pos
    rx1236_cur."!cursor_from"(rx1236_pos)
    ge rx1236_pos, rx1236_eos, rxscan1240_done
  rxscan1240_scan:
    set_addr $I10, rxscan1240_loop
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxscan1240_done:
.annotate 'line', 567
  # rx literal  "("
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 40, rx1236_fail
    add rx1236_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."ws"()
    unless $P10, rx1236_fail
    rx1236_pos = $P10."pos"()
  # rx rxquantr1241 ** 0..1
    set_addr $I10, rxquantr1241_done
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10)
  rxquantr1241_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1236_cur."!cursor_pos"(rx1236_pos)
    $P10 = rx1236_cur."EXPR"()
    unless $P10, rx1236_fail
    goto rxsubrule1242_pass
  rxsubrule1242_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1236_fail
  rxsubrule1242_pass:
    set_addr $I10, rxsubrule1242_back
    rx1236_cur."!mark_push"(0, rx1236_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1236_pos = $P10."pos"()
    set_addr $I10, rxquantr1241_done
    (rx1236_rep) = rx1236_cur."!mark_commit"($I10)
  rxquantr1241_done:
  # rx literal  ")"
    add $I11, rx1236_pos, 1
    gt $I11, rx1236_eos, rx1236_fail
    sub $I11, rx1236_pos, rx1236_off
    ord $I11, rx1236_tgt, $I11
    ne $I11, 41, rx1236_fail
    add rx1236_pos, 1
  # rx pass
    rx1236_cur."!cursor_pass"(rx1236_pos, "circumfix:sym<( )>")
    if_null rx1236_debug, debug_1074
    rx1236_cur."!cursor_debug"("PASS", "circumfix:sym<( )>", " at pos=", rx1236_pos)
  debug_1074:
    .return (rx1236_cur)
  rx1236_restart:
.annotate 'line', 10
    if_null rx1236_debug, debug_1075
    rx1236_cur."!cursor_debug"("NEXT", "circumfix:sym<( )>")
  debug_1075:
  rx1236_fail:
    (rx1236_rep, rx1236_pos, $I10, $P10) = rx1236_cur."!mark_fail"(0)
    lt rx1236_pos, -1, rx1236_done
    eq rx1236_pos, -1, rx1236_fail
    jump $I10
  rx1236_done:
    rx1236_cur."!cursor_fail"()
    if_null rx1236_debug, debug_1076
    rx1236_cur."!cursor_debug"("FAIL", "circumfix:sym<( )>")
  debug_1076:
    .return (rx1236_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<( )>"  :nsentry("!PREFIX__circumfix:sym<( )>") :subid("258_1300146757.646") :method
.annotate 'line', 10
    $P1238 = self."!PREFIX__!subrule"("ws", "(")
    new $P1239, "ResizablePMCArray"
    push $P1239, $P1238
    .return ($P1239)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<[ ]>"  :subid("259_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1244_tgt
    .local int rx1244_pos
    .local int rx1244_off
    .local int rx1244_eos
    .local int rx1244_rep
    .local pmc rx1244_cur
    .local pmc rx1244_debug
    (rx1244_cur, rx1244_pos, rx1244_tgt, $I10) = self."!cursor_start"()
    rx1244_cur."!cursor_caparray"("EXPR")
    .lex unicode:"$\x{a2}", rx1244_cur
    .local pmc match
    .lex "$/", match
    length rx1244_eos, rx1244_tgt
    gt rx1244_pos, rx1244_eos, rx1244_done
    set rx1244_off, 0
    lt rx1244_pos, 2, rx1244_start
    sub rx1244_off, rx1244_pos, 1
    substr rx1244_tgt, rx1244_tgt, rx1244_off
  rx1244_start:
    eq $I10, 1, rx1244_restart
    if_null rx1244_debug, debug_1077
    rx1244_cur."!cursor_debug"("START", "circumfix:sym<[ ]>")
  debug_1077:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1248_done
    goto rxscan1248_scan
  rxscan1248_loop:
    (rx1244_pos) = rx1244_cur."from"()
    inc rx1244_pos
    rx1244_cur."!cursor_from"(rx1244_pos)
    ge rx1244_pos, rx1244_eos, rxscan1248_done
  rxscan1248_scan:
    set_addr $I10, rxscan1248_loop
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxscan1248_done:
.annotate 'line', 568
  # rx literal  "["
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 91, rx1244_fail
    add rx1244_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."ws"()
    unless $P10, rx1244_fail
    rx1244_pos = $P10."pos"()
  # rx rxquantr1249 ** 0..1
    set_addr $I10, rxquantr1249_done
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10)
  rxquantr1249_loop:
  # rx subrule "EXPR" subtype=capture negate=
    rx1244_cur."!cursor_pos"(rx1244_pos)
    $P10 = rx1244_cur."EXPR"()
    unless $P10, rx1244_fail
    goto rxsubrule1250_pass
  rxsubrule1250_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1244_fail
  rxsubrule1250_pass:
    set_addr $I10, rxsubrule1250_back
    rx1244_cur."!mark_push"(0, rx1244_pos, $I10, $P10)
    $P10."!cursor_names"("EXPR")
    rx1244_pos = $P10."pos"()
    set_addr $I10, rxquantr1249_done
    (rx1244_rep) = rx1244_cur."!mark_commit"($I10)
  rxquantr1249_done:
  # rx literal  "]"
    add $I11, rx1244_pos, 1
    gt $I11, rx1244_eos, rx1244_fail
    sub $I11, rx1244_pos, rx1244_off
    ord $I11, rx1244_tgt, $I11
    ne $I11, 93, rx1244_fail
    add rx1244_pos, 1
  # rx pass
    rx1244_cur."!cursor_pass"(rx1244_pos, "circumfix:sym<[ ]>")
    if_null rx1244_debug, debug_1078
    rx1244_cur."!cursor_debug"("PASS", "circumfix:sym<[ ]>", " at pos=", rx1244_pos)
  debug_1078:
    .return (rx1244_cur)
  rx1244_restart:
.annotate 'line', 10
    if_null rx1244_debug, debug_1079
    rx1244_cur."!cursor_debug"("NEXT", "circumfix:sym<[ ]>")
  debug_1079:
  rx1244_fail:
    (rx1244_rep, rx1244_pos, $I10, $P10) = rx1244_cur."!mark_fail"(0)
    lt rx1244_pos, -1, rx1244_done
    eq rx1244_pos, -1, rx1244_fail
    jump $I10
  rx1244_done:
    rx1244_cur."!cursor_fail"()
    if_null rx1244_debug, debug_1080
    rx1244_cur."!cursor_debug"("FAIL", "circumfix:sym<[ ]>")
  debug_1080:
    .return (rx1244_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<[ ]>"  :nsentry("!PREFIX__circumfix:sym<[ ]>") :subid("260_1300146757.646") :method
.annotate 'line', 10
    $P1246 = self."!PREFIX__!subrule"("ws", "[")
    new $P1247, "ResizablePMCArray"
    push $P1247, $P1246
    .return ($P1247)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<ang>"  :subid("261_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1252_tgt
    .local int rx1252_pos
    .local int rx1252_off
    .local int rx1252_eos
    .local int rx1252_rep
    .local pmc rx1252_cur
    .local pmc rx1252_debug
    (rx1252_cur, rx1252_pos, rx1252_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1252_cur
    .local pmc match
    .lex "$/", match
    length rx1252_eos, rx1252_tgt
    gt rx1252_pos, rx1252_eos, rx1252_done
    set rx1252_off, 0
    lt rx1252_pos, 2, rx1252_start
    sub rx1252_off, rx1252_pos, 1
    substr rx1252_tgt, rx1252_tgt, rx1252_off
  rx1252_start:
    eq $I10, 1, rx1252_restart
    if_null rx1252_debug, debug_1081
    rx1252_cur."!cursor_debug"("START", "circumfix:sym<ang>")
  debug_1081:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1255_done
    goto rxscan1255_scan
  rxscan1255_loop:
    (rx1252_pos) = rx1252_cur."from"()
    inc rx1252_pos
    rx1252_cur."!cursor_from"(rx1252_pos)
    ge rx1252_pos, rx1252_eos, rxscan1255_done
  rxscan1255_scan:
    set_addr $I10, rxscan1255_loop
    rx1252_cur."!mark_push"(0, rx1252_pos, $I10)
  rxscan1255_done:
.annotate 'line', 569
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1252_pos, rx1252_off
    substr $S10, rx1252_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1252_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1252_cur."!cursor_pos"(rx1252_pos)
    $P10 = rx1252_cur."quote_EXPR"(":q", ":w")
    unless $P10, rx1252_fail
    rx1252_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1252_pos = $P10."pos"()
  # rx pass
    rx1252_cur."!cursor_pass"(rx1252_pos, "circumfix:sym<ang>")
    if_null rx1252_debug, debug_1082
    rx1252_cur."!cursor_debug"("PASS", "circumfix:sym<ang>", " at pos=", rx1252_pos)
  debug_1082:
    .return (rx1252_cur)
  rx1252_restart:
.annotate 'line', 10
    if_null rx1252_debug, debug_1083
    rx1252_cur."!cursor_debug"("NEXT", "circumfix:sym<ang>")
  debug_1083:
  rx1252_fail:
    (rx1252_rep, rx1252_pos, $I10, $P10) = rx1252_cur."!mark_fail"(0)
    lt rx1252_pos, -1, rx1252_done
    eq rx1252_pos, -1, rx1252_fail
    jump $I10
  rx1252_done:
    rx1252_cur."!cursor_fail"()
    if_null rx1252_debug, debug_1084
    rx1252_cur."!cursor_debug"("FAIL", "circumfix:sym<ang>")
  debug_1084:
    .return (rx1252_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<ang>"  :nsentry("!PREFIX__circumfix:sym<ang>") :subid("262_1300146757.646") :method
.annotate 'line', 10
    new $P1254, "ResizablePMCArray"
    push $P1254, "<"
    .return ($P1254)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("263_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1257_tgt
    .local int rx1257_pos
    .local int rx1257_off
    .local int rx1257_eos
    .local int rx1257_rep
    .local pmc rx1257_cur
    .local pmc rx1257_debug
    (rx1257_cur, rx1257_pos, rx1257_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1257_cur
    .local pmc match
    .lex "$/", match
    length rx1257_eos, rx1257_tgt
    gt rx1257_pos, rx1257_eos, rx1257_done
    set rx1257_off, 0
    lt rx1257_pos, 2, rx1257_start
    sub rx1257_off, rx1257_pos, 1
    substr rx1257_tgt, rx1257_tgt, rx1257_off
  rx1257_start:
    eq $I10, 1, rx1257_restart
    if_null rx1257_debug, debug_1085
    rx1257_cur."!cursor_debug"("START", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1085:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1260_done
    goto rxscan1260_scan
  rxscan1260_loop:
    (rx1257_pos) = rx1257_cur."from"()
    inc rx1257_pos
    rx1257_cur."!cursor_from"(rx1257_pos)
    ge rx1257_pos, rx1257_eos, rxscan1260_done
  rxscan1260_scan:
    set_addr $I10, rxscan1260_loop
    rx1257_cur."!mark_push"(0, rx1257_pos, $I10)
  rxscan1260_done:
.annotate 'line', 570
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1257_pos, rx1257_off
    substr $S10, rx1257_tgt, $I10, 1
    index $I11, unicode:"\x{ab}", $S10
    lt $I11, 0, rx1257_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1257_cur."!cursor_pos"(rx1257_pos)
    $P10 = rx1257_cur."quote_EXPR"(":qq", ":w")
    unless $P10, rx1257_fail
    rx1257_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1257_pos = $P10."pos"()
  # rx pass
    rx1257_cur."!cursor_pass"(rx1257_pos, unicode:"circumfix:sym<\x{ab} \x{bb}>")
    if_null rx1257_debug, debug_1086
    rx1257_cur."!cursor_debug"("PASS", unicode:"circumfix:sym<\x{ab} \x{bb}>", " at pos=", rx1257_pos)
  debug_1086:
    .return (rx1257_cur)
  rx1257_restart:
.annotate 'line', 10
    if_null rx1257_debug, debug_1087
    rx1257_cur."!cursor_debug"("NEXT", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1087:
  rx1257_fail:
    (rx1257_rep, rx1257_pos, $I10, $P10) = rx1257_cur."!mark_fail"(0)
    lt rx1257_pos, -1, rx1257_done
    eq rx1257_pos, -1, rx1257_fail
    jump $I10
  rx1257_done:
    rx1257_cur."!cursor_fail"()
    if_null rx1257_debug, debug_1088
    rx1257_cur."!cursor_debug"("FAIL", unicode:"circumfix:sym<\x{ab} \x{bb}>")
  debug_1088:
    .return (rx1257_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub unicode:"!PREFIX__circumfix:sym<\x{ab} \x{bb}>"  :nsentry(unicode:"!PREFIX__circumfix:sym<\\x{ab} \\x{bb}>") :subid("264_1300146757.646") :method
.annotate 'line', 10
    new $P1259, "ResizablePMCArray"
    push $P1259, unicode:"\x{ab}"
    .return ($P1259)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<{ }>"  :subid("265_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1262_tgt
    .local int rx1262_pos
    .local int rx1262_off
    .local int rx1262_eos
    .local int rx1262_rep
    .local pmc rx1262_cur
    .local pmc rx1262_debug
    (rx1262_cur, rx1262_pos, rx1262_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1262_cur
    .local pmc match
    .lex "$/", match
    length rx1262_eos, rx1262_tgt
    gt rx1262_pos, rx1262_eos, rx1262_done
    set rx1262_off, 0
    lt rx1262_pos, 2, rx1262_start
    sub rx1262_off, rx1262_pos, 1
    substr rx1262_tgt, rx1262_tgt, rx1262_off
  rx1262_start:
    eq $I10, 1, rx1262_restart
    if_null rx1262_debug, debug_1089
    rx1262_cur."!cursor_debug"("START", "circumfix:sym<{ }>")
  debug_1089:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1265_done
    goto rxscan1265_scan
  rxscan1265_loop:
    (rx1262_pos) = rx1262_cur."from"()
    inc rx1262_pos
    rx1262_cur."!cursor_from"(rx1262_pos)
    ge rx1262_pos, rx1262_eos, rxscan1265_done
  rxscan1265_scan:
    set_addr $I10, rxscan1265_loop
    rx1262_cur."!mark_push"(0, rx1262_pos, $I10)
  rxscan1265_done:
.annotate 'line', 571
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1262_pos, rx1262_off
    substr $S10, rx1262_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx1262_fail
  # rx subrule "pblock" subtype=capture negate=
    rx1262_cur."!cursor_pos"(rx1262_pos)
    $P10 = rx1262_cur."pblock"()
    unless $P10, rx1262_fail
    rx1262_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("pblock")
    rx1262_pos = $P10."pos"()
  # rx pass
    rx1262_cur."!cursor_pass"(rx1262_pos, "circumfix:sym<{ }>")
    if_null rx1262_debug, debug_1090
    rx1262_cur."!cursor_debug"("PASS", "circumfix:sym<{ }>", " at pos=", rx1262_pos)
  debug_1090:
    .return (rx1262_cur)
  rx1262_restart:
.annotate 'line', 10
    if_null rx1262_debug, debug_1091
    rx1262_cur."!cursor_debug"("NEXT", "circumfix:sym<{ }>")
  debug_1091:
  rx1262_fail:
    (rx1262_rep, rx1262_pos, $I10, $P10) = rx1262_cur."!mark_fail"(0)
    lt rx1262_pos, -1, rx1262_done
    eq rx1262_pos, -1, rx1262_fail
    jump $I10
  rx1262_done:
    rx1262_cur."!cursor_fail"()
    if_null rx1262_debug, debug_1092
    rx1262_cur."!cursor_debug"("FAIL", "circumfix:sym<{ }>")
  debug_1092:
    .return (rx1262_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<{ }>"  :nsentry("!PREFIX__circumfix:sym<{ }>") :subid("266_1300146757.646") :method
.annotate 'line', 10
    new $P1264, "ResizablePMCArray"
    push $P1264, "{"
    .return ($P1264)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "circumfix:sym<sigil>"  :subid("267_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1267_tgt
    .local int rx1267_pos
    .local int rx1267_off
    .local int rx1267_eos
    .local int rx1267_rep
    .local pmc rx1267_cur
    .local pmc rx1267_debug
    (rx1267_cur, rx1267_pos, rx1267_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1267_cur
    .local pmc match
    .lex "$/", match
    length rx1267_eos, rx1267_tgt
    gt rx1267_pos, rx1267_eos, rx1267_done
    set rx1267_off, 0
    lt rx1267_pos, 2, rx1267_start
    sub rx1267_off, rx1267_pos, 1
    substr rx1267_tgt, rx1267_tgt, rx1267_off
  rx1267_start:
    eq $I10, 1, rx1267_restart
    if_null rx1267_debug, debug_1093
    rx1267_cur."!cursor_debug"("START", "circumfix:sym<sigil>")
  debug_1093:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1271_done
    goto rxscan1271_scan
  rxscan1271_loop:
    (rx1267_pos) = rx1267_cur."from"()
    inc rx1267_pos
    rx1267_cur."!cursor_from"(rx1267_pos)
    ge rx1267_pos, rx1267_eos, rxscan1271_done
  rxscan1271_scan:
    set_addr $I10, rxscan1271_loop
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  rxscan1271_done:
.annotate 'line', 572
  # rx subrule "sigil" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."sigil"()
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sigil")
    rx1267_pos = $P10."pos"()
  # rx literal  "("
    add $I11, rx1267_pos, 1
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    ord $I11, rx1267_tgt, $I11
    ne $I11, 40, rx1267_fail
    add rx1267_pos, 1
  # rx subrule "semilist" subtype=capture negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."semilist"()
    unless $P10, rx1267_fail
    rx1267_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("semilist")
    rx1267_pos = $P10."pos"()
  alt1272_0:
    set_addr $I10, alt1272_1
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10)
  # rx literal  ")"
    add $I11, rx1267_pos, 1
    gt $I11, rx1267_eos, rx1267_fail
    sub $I11, rx1267_pos, rx1267_off
    ord $I11, rx1267_tgt, $I11
    ne $I11, 41, rx1267_fail
    add rx1267_pos, 1
    goto alt1272_end
  alt1272_1:
  # rx subrule "FAILGOAL" subtype=method negate=
    rx1267_cur."!cursor_pos"(rx1267_pos)
    $P10 = rx1267_cur."FAILGOAL"("')'")
    unless $P10, rx1267_fail
    goto rxsubrule1274_pass
  rxsubrule1274_back:
    $P10 = $P10."!cursor_next"()
    unless $P10, rx1267_fail
  rxsubrule1274_pass:
    set_addr $I10, rxsubrule1274_back
    rx1267_cur."!mark_push"(0, rx1267_pos, $I10, $P10)
    rx1267_pos = $P10."pos"()
  alt1272_end:
  # rx pass
    rx1267_cur."!cursor_pass"(rx1267_pos, "circumfix:sym<sigil>")
    if_null rx1267_debug, debug_1094
    rx1267_cur."!cursor_debug"("PASS", "circumfix:sym<sigil>", " at pos=", rx1267_pos)
  debug_1094:
    .return (rx1267_cur)
  rx1267_restart:
.annotate 'line', 10
    if_null rx1267_debug, debug_1095
    rx1267_cur."!cursor_debug"("NEXT", "circumfix:sym<sigil>")
  debug_1095:
  rx1267_fail:
    (rx1267_rep, rx1267_pos, $I10, $P10) = rx1267_cur."!mark_fail"(0)
    lt rx1267_pos, -1, rx1267_done
    eq rx1267_pos, -1, rx1267_fail
    jump $I10
  rx1267_done:
    rx1267_cur."!cursor_fail"()
    if_null rx1267_debug, debug_1096
    rx1267_cur."!cursor_debug"("FAIL", "circumfix:sym<sigil>")
  debug_1096:
    .return (rx1267_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__circumfix:sym<sigil>"  :nsentry("!PREFIX__circumfix:sym<sigil>") :subid("268_1300146757.646") :method
.annotate 'line', 10
    $P1269 = self."!PREFIX__!subrule"("sigil", "")
    new $P1270, "ResizablePMCArray"
    push $P1270, $P1269
    .return ($P1270)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "semilist"  :subid("269_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1276_tgt
    .local int rx1276_pos
    .local int rx1276_off
    .local int rx1276_eos
    .local int rx1276_rep
    .local pmc rx1276_cur
    .local pmc rx1276_debug
    (rx1276_cur, rx1276_pos, rx1276_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1276_cur
    .local pmc match
    .lex "$/", match
    length rx1276_eos, rx1276_tgt
    gt rx1276_pos, rx1276_eos, rx1276_done
    set rx1276_off, 0
    lt rx1276_pos, 2, rx1276_start
    sub rx1276_off, rx1276_pos, 1
    substr rx1276_tgt, rx1276_tgt, rx1276_off
  rx1276_start:
    eq $I10, 1, rx1276_restart
    if_null rx1276_debug, debug_1097
    rx1276_cur."!cursor_debug"("START", "semilist")
  debug_1097:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1280_done
    goto rxscan1280_scan
  rxscan1280_loop:
    (rx1276_pos) = rx1276_cur."from"()
    inc rx1276_pos
    rx1276_cur."!cursor_from"(rx1276_pos)
    ge rx1276_pos, rx1276_eos, rxscan1280_done
  rxscan1280_scan:
    set_addr $I10, rxscan1280_loop
    rx1276_cur."!mark_push"(0, rx1276_pos, $I10)
  rxscan1280_done:
.annotate 'line', 574
  # rx subrule "ws" subtype=method negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."ws"()
    unless $P10, rx1276_fail
    rx1276_pos = $P10."pos"()
  # rx subrule "statement" subtype=capture negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."statement"()
    unless $P10, rx1276_fail
    rx1276_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx1276_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx1276_cur."!cursor_pos"(rx1276_pos)
    $P10 = rx1276_cur."ws"()
    unless $P10, rx1276_fail
    rx1276_pos = $P10."pos"()
  # rx pass
    rx1276_cur."!cursor_pass"(rx1276_pos, "semilist")
    if_null rx1276_debug, debug_1098
    rx1276_cur."!cursor_debug"("PASS", "semilist", " at pos=", rx1276_pos)
  debug_1098:
    .return (rx1276_cur)
  rx1276_restart:
.annotate 'line', 10
    if_null rx1276_debug, debug_1099
    rx1276_cur."!cursor_debug"("NEXT", "semilist")
  debug_1099:
  rx1276_fail:
    (rx1276_rep, rx1276_pos, $I10, $P10) = rx1276_cur."!mark_fail"(0)
    lt rx1276_pos, -1, rx1276_done
    eq rx1276_pos, -1, rx1276_fail
    jump $I10
  rx1276_done:
    rx1276_cur."!cursor_fail"()
    if_null rx1276_debug, debug_1100
    rx1276_cur."!cursor_debug"("FAIL", "semilist")
  debug_1100:
    .return (rx1276_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__semilist"  :nsentry("!PREFIX__semilist") :subid("270_1300146757.646") :method
.annotate 'line', 10
    $P1278 = self."!PREFIX__!subrule"("ws", "")
    new $P1279, "ResizablePMCArray"
    push $P1279, $P1278
    .return ($P1279)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1283"  :anon :subid("271_1300146757.646") :outer("12_1300146757.646")
.annotate 'line', 10
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "" :load :init :subid("post1101") :outer("271_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P1284 = "271_1300146757.646" 
    .local pmc block
    set block, $P1284
.annotate 'line', 579
    get_hll_global $P1285, ["NQP"], "Grammar"
    $P1285."O"(":prec<y=>, :assoc<unary>", "%methodop")
.annotate 'line', 580
    get_hll_global $P1286, ["NQP"], "Grammar"
    $P1286."O"(":prec<x=>, :assoc<unary>", "%autoincrement")
.annotate 'line', 581
    get_hll_global $P1287, ["NQP"], "Grammar"
    $P1287."O"(":prec<w=>, :assoc<left>", "%exponentiation")
.annotate 'line', 582
    get_hll_global $P1288, ["NQP"], "Grammar"
    $P1288."O"(":prec<v=>, :assoc<unary>", "%symbolic_unary")
.annotate 'line', 583
    get_hll_global $P1289, ["NQP"], "Grammar"
    $P1289."O"(":prec<u=>, :assoc<left>", "%multiplicative")
.annotate 'line', 584
    get_hll_global $P1290, ["NQP"], "Grammar"
    $P1290."O"(":prec<t=>, :assoc<left>", "%additive")
.annotate 'line', 585
    get_hll_global $P1291, ["NQP"], "Grammar"
    $P1291."O"(":prec<r=>, :assoc<left>", "%concatenation")
.annotate 'line', 586
    get_hll_global $P1292, ["NQP"], "Grammar"
    $P1292."O"(":prec<m=>, :assoc<left>", "%relational")
.annotate 'line', 587
    get_hll_global $P1293, ["NQP"], "Grammar"
    $P1293."O"(":prec<l=>, :assoc<left>", "%tight_and")
.annotate 'line', 588
    get_hll_global $P1294, ["NQP"], "Grammar"
    $P1294."O"(":prec<k=>, :assoc<left>", "%tight_or")
.annotate 'line', 589
    get_hll_global $P1295, ["NQP"], "Grammar"
    $P1295."O"(":prec<j=>, :assoc<right>", "%conditional")
.annotate 'line', 590
    get_hll_global $P1296, ["NQP"], "Grammar"
    $P1296."O"(":prec<i=>, :assoc<right>", "%assignment")
.annotate 'line', 591
    get_hll_global $P1297, ["NQP"], "Grammar"
    $P1297."O"(":prec<g=>, :assoc<list>, :nextterm<nulltermish>", "%comma")
.annotate 'line', 592
    get_hll_global $P1298, ["NQP"], "Grammar"
    $P1298."O"(":prec<f=>, :assoc<list>", "%list_infix")
.annotate 'line', 593
    get_hll_global $P1299, ["NQP"], "Grammar"
    $P1299."O"(":prec<e=>, :assoc<unary>", "%list_prefix")
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixish"  :subid("272_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1301_tgt
    .local int rx1301_pos
    .local int rx1301_off
    .local int rx1301_eos
    .local int rx1301_rep
    .local pmc rx1301_cur
    .local pmc rx1301_debug
    (rx1301_cur, rx1301_pos, rx1301_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1301_cur
    .local pmc match
    .lex "$/", match
    length rx1301_eos, rx1301_tgt
    gt rx1301_pos, rx1301_eos, rx1301_done
    set rx1301_off, 0
    lt rx1301_pos, 2, rx1301_start
    sub rx1301_off, rx1301_pos, 1
    substr rx1301_tgt, rx1301_tgt, rx1301_off
  rx1301_start:
    eq $I10, 1, rx1301_restart
    if_null rx1301_debug, debug_1102
    rx1301_cur."!cursor_debug"("START", "infixish")
  debug_1102:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1304_done
    goto rxscan1304_scan
  rxscan1304_loop:
    (rx1301_pos) = rx1301_cur."from"()
    inc rx1301_pos
    rx1301_cur."!cursor_from"(rx1301_pos)
    ge rx1301_pos, rx1301_eos, rxscan1304_done
  rxscan1304_scan:
    set_addr $I10, rxscan1304_loop
    rx1301_cur."!mark_push"(0, rx1301_pos, $I10)
  rxscan1304_done:
.annotate 'line', 597
  # rx subrule "infixstopper" subtype=zerowidth negate=1
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."infixstopper"()
    if $P10, rx1301_fail
  # rx subrule "infix" subtype=capture negate=
    rx1301_cur."!cursor_pos"(rx1301_pos)
    $P10 = rx1301_cur."infix"()
    unless $P10, rx1301_fail
    rx1301_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("OPER=infix")
    rx1301_pos = $P10."pos"()
  # rx pass
    rx1301_cur."!cursor_pass"(rx1301_pos, "infixish")
    if_null rx1301_debug, debug_1103
    rx1301_cur."!cursor_debug"("PASS", "infixish", " at pos=", rx1301_pos)
  debug_1103:
    .return (rx1301_cur)
  rx1301_restart:
.annotate 'line', 10
    if_null rx1301_debug, debug_1104
    rx1301_cur."!cursor_debug"("NEXT", "infixish")
  debug_1104:
  rx1301_fail:
    (rx1301_rep, rx1301_pos, $I10, $P10) = rx1301_cur."!mark_fail"(0)
    lt rx1301_pos, -1, rx1301_done
    eq rx1301_pos, -1, rx1301_fail
    jump $I10
  rx1301_done:
    rx1301_cur."!cursor_fail"()
    if_null rx1301_debug, debug_1105
    rx1301_cur."!cursor_debug"("FAIL", "infixish")
  debug_1105:
    .return (rx1301_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixish"  :nsentry("!PREFIX__infixish") :subid("273_1300146757.646") :method
.annotate 'line', 10
    new $P1303, "ResizablePMCArray"
    push $P1303, ""
    .return ($P1303)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infixstopper"  :subid("274_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1306_tgt
    .local int rx1306_pos
    .local int rx1306_off
    .local int rx1306_eos
    .local int rx1306_rep
    .local pmc rx1306_cur
    .local pmc rx1306_debug
    (rx1306_cur, rx1306_pos, rx1306_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1306_cur
    .local pmc match
    .lex "$/", match
    length rx1306_eos, rx1306_tgt
    gt rx1306_pos, rx1306_eos, rx1306_done
    set rx1306_off, 0
    lt rx1306_pos, 2, rx1306_start
    sub rx1306_off, rx1306_pos, 1
    substr rx1306_tgt, rx1306_tgt, rx1306_off
  rx1306_start:
    eq $I10, 1, rx1306_restart
    if_null rx1306_debug, debug_1106
    rx1306_cur."!cursor_debug"("START", "infixstopper")
  debug_1106:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1309_done
    goto rxscan1309_scan
  rxscan1309_loop:
    (rx1306_pos) = rx1306_cur."from"()
    inc rx1306_pos
    rx1306_cur."!cursor_from"(rx1306_pos)
    ge rx1306_pos, rx1306_eos, rxscan1309_done
  rxscan1309_scan:
    set_addr $I10, rxscan1309_loop
    rx1306_cur."!mark_push"(0, rx1306_pos, $I10)
  rxscan1309_done:
.annotate 'line', 598
  # rx subrule "lambda" subtype=zerowidth negate=
    rx1306_cur."!cursor_pos"(rx1306_pos)
    $P10 = rx1306_cur."lambda"()
    unless $P10, rx1306_fail
  # rx pass
    rx1306_cur."!cursor_pass"(rx1306_pos, "infixstopper")
    if_null rx1306_debug, debug_1107
    rx1306_cur."!cursor_debug"("PASS", "infixstopper", " at pos=", rx1306_pos)
  debug_1107:
    .return (rx1306_cur)
  rx1306_restart:
.annotate 'line', 10
    if_null rx1306_debug, debug_1108
    rx1306_cur."!cursor_debug"("NEXT", "infixstopper")
  debug_1108:
  rx1306_fail:
    (rx1306_rep, rx1306_pos, $I10, $P10) = rx1306_cur."!mark_fail"(0)
    lt rx1306_pos, -1, rx1306_done
    eq rx1306_pos, -1, rx1306_fail
    jump $I10
  rx1306_done:
    rx1306_cur."!cursor_fail"()
    if_null rx1306_debug, debug_1109
    rx1306_cur."!cursor_debug"("FAIL", "infixstopper")
  debug_1109:
    .return (rx1306_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infixstopper"  :nsentry("!PREFIX__infixstopper") :subid("275_1300146757.646") :method
.annotate 'line', 10
    new $P1308, "ResizablePMCArray"
    push $P1308, ""
    .return ($P1308)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<[ ]>"  :subid("276_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1311_tgt
    .local int rx1311_pos
    .local int rx1311_off
    .local int rx1311_eos
    .local int rx1311_rep
    .local pmc rx1311_cur
    .local pmc rx1311_debug
    (rx1311_cur, rx1311_pos, rx1311_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1311_cur
    .local pmc match
    .lex "$/", match
    length rx1311_eos, rx1311_tgt
    gt rx1311_pos, rx1311_eos, rx1311_done
    set rx1311_off, 0
    lt rx1311_pos, 2, rx1311_start
    sub rx1311_off, rx1311_pos, 1
    substr rx1311_tgt, rx1311_tgt, rx1311_off
  rx1311_start:
    eq $I10, 1, rx1311_restart
    if_null rx1311_debug, debug_1110
    rx1311_cur."!cursor_debug"("START", "postcircumfix:sym<[ ]>")
  debug_1110:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1315_done
    goto rxscan1315_scan
  rxscan1315_loop:
    (rx1311_pos) = rx1311_cur."from"()
    inc rx1311_pos
    rx1311_cur."!cursor_from"(rx1311_pos)
    ge rx1311_pos, rx1311_eos, rxscan1315_done
  rxscan1315_scan:
    set_addr $I10, rxscan1315_loop
    rx1311_cur."!mark_push"(0, rx1311_pos, $I10)
  rxscan1315_done:
.annotate 'line', 601
  # rx literal  "["
    add $I11, rx1311_pos, 1
    gt $I11, rx1311_eos, rx1311_fail
    sub $I11, rx1311_pos, rx1311_off
    ord $I11, rx1311_tgt, $I11
    ne $I11, 91, rx1311_fail
    add rx1311_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."ws"()
    unless $P10, rx1311_fail
    rx1311_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."EXPR"()
    unless $P10, rx1311_fail
    rx1311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1311_pos = $P10."pos"()
  # rx literal  "]"
    add $I11, rx1311_pos, 1
    gt $I11, rx1311_eos, rx1311_fail
    sub $I11, rx1311_pos, rx1311_off
    ord $I11, rx1311_tgt, $I11
    ne $I11, 93, rx1311_fail
    add rx1311_pos, 1
.annotate 'line', 602
  # rx subrule "O" subtype=capture negate=
    rx1311_cur."!cursor_pos"(rx1311_pos)
    $P10 = rx1311_cur."O"("%methodop")
    unless $P10, rx1311_fail
    rx1311_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1311_pos = $P10."pos"()
.annotate 'line', 600
  # rx pass
    rx1311_cur."!cursor_pass"(rx1311_pos, "postcircumfix:sym<[ ]>")
    if_null rx1311_debug, debug_1111
    rx1311_cur."!cursor_debug"("PASS", "postcircumfix:sym<[ ]>", " at pos=", rx1311_pos)
  debug_1111:
    .return (rx1311_cur)
  rx1311_restart:
.annotate 'line', 10
    if_null rx1311_debug, debug_1112
    rx1311_cur."!cursor_debug"("NEXT", "postcircumfix:sym<[ ]>")
  debug_1112:
  rx1311_fail:
    (rx1311_rep, rx1311_pos, $I10, $P10) = rx1311_cur."!mark_fail"(0)
    lt rx1311_pos, -1, rx1311_done
    eq rx1311_pos, -1, rx1311_fail
    jump $I10
  rx1311_done:
    rx1311_cur."!cursor_fail"()
    if_null rx1311_debug, debug_1113
    rx1311_cur."!cursor_debug"("FAIL", "postcircumfix:sym<[ ]>")
  debug_1113:
    .return (rx1311_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<[ ]>"  :nsentry("!PREFIX__postcircumfix:sym<[ ]>") :subid("277_1300146757.646") :method
.annotate 'line', 10
    $P1313 = self."!PREFIX__!subrule"("ws", "[")
    new $P1314, "ResizablePMCArray"
    push $P1314, $P1313
    .return ($P1314)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<{ }>"  :subid("278_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1317_tgt
    .local int rx1317_pos
    .local int rx1317_off
    .local int rx1317_eos
    .local int rx1317_rep
    .local pmc rx1317_cur
    .local pmc rx1317_debug
    (rx1317_cur, rx1317_pos, rx1317_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1317_cur
    .local pmc match
    .lex "$/", match
    length rx1317_eos, rx1317_tgt
    gt rx1317_pos, rx1317_eos, rx1317_done
    set rx1317_off, 0
    lt rx1317_pos, 2, rx1317_start
    sub rx1317_off, rx1317_pos, 1
    substr rx1317_tgt, rx1317_tgt, rx1317_off
  rx1317_start:
    eq $I10, 1, rx1317_restart
    if_null rx1317_debug, debug_1114
    rx1317_cur."!cursor_debug"("START", "postcircumfix:sym<{ }>")
  debug_1114:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1321_done
    goto rxscan1321_scan
  rxscan1321_loop:
    (rx1317_pos) = rx1317_cur."from"()
    inc rx1317_pos
    rx1317_cur."!cursor_from"(rx1317_pos)
    ge rx1317_pos, rx1317_eos, rxscan1321_done
  rxscan1321_scan:
    set_addr $I10, rxscan1321_loop
    rx1317_cur."!mark_push"(0, rx1317_pos, $I10)
  rxscan1321_done:
.annotate 'line', 606
  # rx literal  "{"
    add $I11, rx1317_pos, 1
    gt $I11, rx1317_eos, rx1317_fail
    sub $I11, rx1317_pos, rx1317_off
    ord $I11, rx1317_tgt, $I11
    ne $I11, 123, rx1317_fail
    add rx1317_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."ws"()
    unless $P10, rx1317_fail
    rx1317_pos = $P10."pos"()
  # rx subrule "EXPR" subtype=capture negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."EXPR"()
    unless $P10, rx1317_fail
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1317_pos = $P10."pos"()
  # rx literal  "}"
    add $I11, rx1317_pos, 1
    gt $I11, rx1317_eos, rx1317_fail
    sub $I11, rx1317_pos, rx1317_off
    ord $I11, rx1317_tgt, $I11
    ne $I11, 125, rx1317_fail
    add rx1317_pos, 1
.annotate 'line', 607
  # rx subrule "O" subtype=capture negate=
    rx1317_cur."!cursor_pos"(rx1317_pos)
    $P10 = rx1317_cur."O"("%methodop")
    unless $P10, rx1317_fail
    rx1317_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1317_pos = $P10."pos"()
.annotate 'line', 605
  # rx pass
    rx1317_cur."!cursor_pass"(rx1317_pos, "postcircumfix:sym<{ }>")
    if_null rx1317_debug, debug_1115
    rx1317_cur."!cursor_debug"("PASS", "postcircumfix:sym<{ }>", " at pos=", rx1317_pos)
  debug_1115:
    .return (rx1317_cur)
  rx1317_restart:
.annotate 'line', 10
    if_null rx1317_debug, debug_1116
    rx1317_cur."!cursor_debug"("NEXT", "postcircumfix:sym<{ }>")
  debug_1116:
  rx1317_fail:
    (rx1317_rep, rx1317_pos, $I10, $P10) = rx1317_cur."!mark_fail"(0)
    lt rx1317_pos, -1, rx1317_done
    eq rx1317_pos, -1, rx1317_fail
    jump $I10
  rx1317_done:
    rx1317_cur."!cursor_fail"()
    if_null rx1317_debug, debug_1117
    rx1317_cur."!cursor_debug"("FAIL", "postcircumfix:sym<{ }>")
  debug_1117:
    .return (rx1317_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<{ }>"  :nsentry("!PREFIX__postcircumfix:sym<{ }>") :subid("279_1300146757.646") :method
.annotate 'line', 10
    $P1319 = self."!PREFIX__!subrule"("ws", "{")
    new $P1320, "ResizablePMCArray"
    push $P1320, $P1319
    .return ($P1320)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<ang>"  :subid("280_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1323_tgt
    .local int rx1323_pos
    .local int rx1323_off
    .local int rx1323_eos
    .local int rx1323_rep
    .local pmc rx1323_cur
    .local pmc rx1323_debug
    (rx1323_cur, rx1323_pos, rx1323_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1323_cur
    .local pmc match
    .lex "$/", match
    length rx1323_eos, rx1323_tgt
    gt rx1323_pos, rx1323_eos, rx1323_done
    set rx1323_off, 0
    lt rx1323_pos, 2, rx1323_start
    sub rx1323_off, rx1323_pos, 1
    substr rx1323_tgt, rx1323_tgt, rx1323_off
  rx1323_start:
    eq $I10, 1, rx1323_restart
    if_null rx1323_debug, debug_1118
    rx1323_cur."!cursor_debug"("START", "postcircumfix:sym<ang>")
  debug_1118:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1326_done
    goto rxscan1326_scan
  rxscan1326_loop:
    (rx1323_pos) = rx1323_cur."from"()
    inc rx1323_pos
    rx1323_cur."!cursor_from"(rx1323_pos)
    ge rx1323_pos, rx1323_eos, rxscan1326_done
  rxscan1326_scan:
    set_addr $I10, rxscan1326_loop
    rx1323_cur."!mark_push"(0, rx1323_pos, $I10)
  rxscan1326_done:
.annotate 'line', 611
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx1323_pos, rx1323_off
    substr $S10, rx1323_tgt, $I10, 1
    index $I11, "<", $S10
    lt $I11, 0, rx1323_fail
  # rx subrule "quote_EXPR" subtype=capture negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."quote_EXPR"(":q")
    unless $P10, rx1323_fail
    rx1323_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("quote_EXPR")
    rx1323_pos = $P10."pos"()
.annotate 'line', 612
  # rx subrule "O" subtype=capture negate=
    rx1323_cur."!cursor_pos"(rx1323_pos)
    $P10 = rx1323_cur."O"("%methodop")
    unless $P10, rx1323_fail
    rx1323_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1323_pos = $P10."pos"()
.annotate 'line', 610
  # rx pass
    rx1323_cur."!cursor_pass"(rx1323_pos, "postcircumfix:sym<ang>")
    if_null rx1323_debug, debug_1119
    rx1323_cur."!cursor_debug"("PASS", "postcircumfix:sym<ang>", " at pos=", rx1323_pos)
  debug_1119:
    .return (rx1323_cur)
  rx1323_restart:
.annotate 'line', 10
    if_null rx1323_debug, debug_1120
    rx1323_cur."!cursor_debug"("NEXT", "postcircumfix:sym<ang>")
  debug_1120:
  rx1323_fail:
    (rx1323_rep, rx1323_pos, $I10, $P10) = rx1323_cur."!mark_fail"(0)
    lt rx1323_pos, -1, rx1323_done
    eq rx1323_pos, -1, rx1323_fail
    jump $I10
  rx1323_done:
    rx1323_cur."!cursor_fail"()
    if_null rx1323_debug, debug_1121
    rx1323_cur."!cursor_debug"("FAIL", "postcircumfix:sym<ang>")
  debug_1121:
    .return (rx1323_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<ang>"  :nsentry("!PREFIX__postcircumfix:sym<ang>") :subid("281_1300146757.646") :method
.annotate 'line', 10
    new $P1325, "ResizablePMCArray"
    push $P1325, "<"
    .return ($P1325)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postcircumfix:sym<( )>"  :subid("282_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1328_tgt
    .local int rx1328_pos
    .local int rx1328_off
    .local int rx1328_eos
    .local int rx1328_rep
    .local pmc rx1328_cur
    .local pmc rx1328_debug
    (rx1328_cur, rx1328_pos, rx1328_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1328_cur
    .local pmc match
    .lex "$/", match
    length rx1328_eos, rx1328_tgt
    gt rx1328_pos, rx1328_eos, rx1328_done
    set rx1328_off, 0
    lt rx1328_pos, 2, rx1328_start
    sub rx1328_off, rx1328_pos, 1
    substr rx1328_tgt, rx1328_tgt, rx1328_off
  rx1328_start:
    eq $I10, 1, rx1328_restart
    if_null rx1328_debug, debug_1122
    rx1328_cur."!cursor_debug"("START", "postcircumfix:sym<( )>")
  debug_1122:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1332_done
    goto rxscan1332_scan
  rxscan1332_loop:
    (rx1328_pos) = rx1328_cur."from"()
    inc rx1328_pos
    rx1328_cur."!cursor_from"(rx1328_pos)
    ge rx1328_pos, rx1328_eos, rxscan1332_done
  rxscan1332_scan:
    set_addr $I10, rxscan1332_loop
    rx1328_cur."!mark_push"(0, rx1328_pos, $I10)
  rxscan1332_done:
.annotate 'line', 616
  # rx literal  "("
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 40, rx1328_fail
    add rx1328_pos, 1
  # rx subrule "ws" subtype=method negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."ws"()
    unless $P10, rx1328_fail
    rx1328_pos = $P10."pos"()
  # rx subrule "arglist" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."arglist"()
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx1328_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx1328_pos, 1
    gt $I11, rx1328_eos, rx1328_fail
    sub $I11, rx1328_pos, rx1328_off
    ord $I11, rx1328_tgt, $I11
    ne $I11, 41, rx1328_fail
    add rx1328_pos, 1
.annotate 'line', 617
  # rx subrule "O" subtype=capture negate=
    rx1328_cur."!cursor_pos"(rx1328_pos)
    $P10 = rx1328_cur."O"("%methodop")
    unless $P10, rx1328_fail
    rx1328_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1328_pos = $P10."pos"()
.annotate 'line', 615
  # rx pass
    rx1328_cur."!cursor_pass"(rx1328_pos, "postcircumfix:sym<( )>")
    if_null rx1328_debug, debug_1123
    rx1328_cur."!cursor_debug"("PASS", "postcircumfix:sym<( )>", " at pos=", rx1328_pos)
  debug_1123:
    .return (rx1328_cur)
  rx1328_restart:
.annotate 'line', 10
    if_null rx1328_debug, debug_1124
    rx1328_cur."!cursor_debug"("NEXT", "postcircumfix:sym<( )>")
  debug_1124:
  rx1328_fail:
    (rx1328_rep, rx1328_pos, $I10, $P10) = rx1328_cur."!mark_fail"(0)
    lt rx1328_pos, -1, rx1328_done
    eq rx1328_pos, -1, rx1328_fail
    jump $I10
  rx1328_done:
    rx1328_cur."!cursor_fail"()
    if_null rx1328_debug, debug_1125
    rx1328_cur."!cursor_debug"("FAIL", "postcircumfix:sym<( )>")
  debug_1125:
    .return (rx1328_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postcircumfix:sym<( )>"  :nsentry("!PREFIX__postcircumfix:sym<( )>") :subid("283_1300146757.646") :method
.annotate 'line', 10
    $P1330 = self."!PREFIX__!subrule"("ws", "(")
    new $P1331, "ResizablePMCArray"
    push $P1331, $P1330
    .return ($P1331)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<.>"  :subid("284_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1334_tgt
    .local int rx1334_pos
    .local int rx1334_off
    .local int rx1334_eos
    .local int rx1334_rep
    .local pmc rx1334_cur
    .local pmc rx1334_debug
    (rx1334_cur, rx1334_pos, rx1334_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1334_cur
    .local pmc match
    .lex "$/", match
    length rx1334_eos, rx1334_tgt
    gt rx1334_pos, rx1334_eos, rx1334_done
    set rx1334_off, 0
    lt rx1334_pos, 2, rx1334_start
    sub rx1334_off, rx1334_pos, 1
    substr rx1334_tgt, rx1334_tgt, rx1334_off
  rx1334_start:
    eq $I10, 1, rx1334_restart
    if_null rx1334_debug, debug_1126
    rx1334_cur."!cursor_debug"("START", "postfix:sym<.>")
  debug_1126:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1338_done
    goto rxscan1338_scan
  rxscan1338_loop:
    (rx1334_pos) = rx1334_cur."from"()
    inc rx1334_pos
    rx1334_cur."!cursor_from"(rx1334_pos)
    ge rx1334_pos, rx1334_eos, rxscan1338_done
  rxscan1338_scan:
    set_addr $I10, rxscan1338_loop
    rx1334_cur."!mark_push"(0, rx1334_pos, $I10)
  rxscan1338_done:
.annotate 'line', 620
  # rx subrule "dotty" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."dotty"()
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("dotty")
    rx1334_pos = $P10."pos"()
  # rx subrule "O" subtype=capture negate=
    rx1334_cur."!cursor_pos"(rx1334_pos)
    $P10 = rx1334_cur."O"("%methodop")
    unless $P10, rx1334_fail
    rx1334_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1334_pos = $P10."pos"()
  # rx pass
    rx1334_cur."!cursor_pass"(rx1334_pos, "postfix:sym<.>")
    if_null rx1334_debug, debug_1127
    rx1334_cur."!cursor_debug"("PASS", "postfix:sym<.>", " at pos=", rx1334_pos)
  debug_1127:
    .return (rx1334_cur)
  rx1334_restart:
.annotate 'line', 10
    if_null rx1334_debug, debug_1128
    rx1334_cur."!cursor_debug"("NEXT", "postfix:sym<.>")
  debug_1128:
  rx1334_fail:
    (rx1334_rep, rx1334_pos, $I10, $P10) = rx1334_cur."!mark_fail"(0)
    lt rx1334_pos, -1, rx1334_done
    eq rx1334_pos, -1, rx1334_fail
    jump $I10
  rx1334_done:
    rx1334_cur."!cursor_fail"()
    if_null rx1334_debug, debug_1129
    rx1334_cur."!cursor_debug"("FAIL", "postfix:sym<.>")
  debug_1129:
    .return (rx1334_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<.>"  :nsentry("!PREFIX__postfix:sym<.>") :subid("285_1300146757.646") :method
.annotate 'line', 10
    $P1336 = self."!PREFIX__!subrule"("dotty", "")
    new $P1337, "ResizablePMCArray"
    push $P1337, $P1336
    .return ($P1337)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<++>"  :subid("286_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1340_tgt
    .local int rx1340_pos
    .local int rx1340_off
    .local int rx1340_eos
    .local int rx1340_rep
    .local pmc rx1340_cur
    .local pmc rx1340_debug
    (rx1340_cur, rx1340_pos, rx1340_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1340_cur
    .local pmc match
    .lex "$/", match
    length rx1340_eos, rx1340_tgt
    gt rx1340_pos, rx1340_eos, rx1340_done
    set rx1340_off, 0
    lt rx1340_pos, 2, rx1340_start
    sub rx1340_off, rx1340_pos, 1
    substr rx1340_tgt, rx1340_tgt, rx1340_off
  rx1340_start:
    eq $I10, 1, rx1340_restart
    if_null rx1340_debug, debug_1130
    rx1340_cur."!cursor_debug"("START", "prefix:sym<++>")
  debug_1130:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1344_done
    goto rxscan1344_scan
  rxscan1344_loop:
    (rx1340_pos) = rx1340_cur."from"()
    inc rx1340_pos
    rx1340_cur."!cursor_from"(rx1340_pos)
    ge rx1340_pos, rx1340_eos, rxscan1344_done
  rxscan1344_scan:
    set_addr $I10, rxscan1344_loop
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  rxscan1344_done:
.annotate 'line', 622
  # rx subcapture "sym"
    set_addr $I10, rxcap_1345_fail
    rx1340_cur."!mark_push"(0, rx1340_pos, $I10)
  # rx literal  "++"
    add $I11, rx1340_pos, 2
    gt $I11, rx1340_eos, rx1340_fail
    sub $I11, rx1340_pos, rx1340_off
    substr $S10, rx1340_tgt, $I11, 2
    ne $S10, "++", rx1340_fail
    add rx1340_pos, 2
    set_addr $I10, rxcap_1345_fail
    ($I12, $I11) = rx1340_cur."!mark_peek"($I10)
    rx1340_cur."!cursor_pos"($I11)
    ($P10) = rx1340_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1340_pos, "")
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1345_done
  rxcap_1345_fail:
    goto rx1340_fail
  rxcap_1345_done:
  # rx subrule "O" subtype=capture negate=
    rx1340_cur."!cursor_pos"(rx1340_pos)
    $P10 = rx1340_cur."O"("%autoincrement, :pirop<inc>")
    unless $P10, rx1340_fail
    rx1340_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1340_pos = $P10."pos"()
  # rx pass
    rx1340_cur."!cursor_pass"(rx1340_pos, "prefix:sym<++>")
    if_null rx1340_debug, debug_1131
    rx1340_cur."!cursor_debug"("PASS", "prefix:sym<++>", " at pos=", rx1340_pos)
  debug_1131:
    .return (rx1340_cur)
  rx1340_restart:
.annotate 'line', 10
    if_null rx1340_debug, debug_1132
    rx1340_cur."!cursor_debug"("NEXT", "prefix:sym<++>")
  debug_1132:
  rx1340_fail:
    (rx1340_rep, rx1340_pos, $I10, $P10) = rx1340_cur."!mark_fail"(0)
    lt rx1340_pos, -1, rx1340_done
    eq rx1340_pos, -1, rx1340_fail
    jump $I10
  rx1340_done:
    rx1340_cur."!cursor_fail"()
    if_null rx1340_debug, debug_1133
    rx1340_cur."!cursor_debug"("FAIL", "prefix:sym<++>")
  debug_1133:
    .return (rx1340_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<++>"  :nsentry("!PREFIX__prefix:sym<++>") :subid("287_1300146757.646") :method
.annotate 'line', 10
    $P1342 = self."!PREFIX__!subrule"("O", "++")
    new $P1343, "ResizablePMCArray"
    push $P1343, $P1342
    .return ($P1343)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<-->"  :subid("288_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1347_tgt
    .local int rx1347_pos
    .local int rx1347_off
    .local int rx1347_eos
    .local int rx1347_rep
    .local pmc rx1347_cur
    .local pmc rx1347_debug
    (rx1347_cur, rx1347_pos, rx1347_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1347_cur
    .local pmc match
    .lex "$/", match
    length rx1347_eos, rx1347_tgt
    gt rx1347_pos, rx1347_eos, rx1347_done
    set rx1347_off, 0
    lt rx1347_pos, 2, rx1347_start
    sub rx1347_off, rx1347_pos, 1
    substr rx1347_tgt, rx1347_tgt, rx1347_off
  rx1347_start:
    eq $I10, 1, rx1347_restart
    if_null rx1347_debug, debug_1134
    rx1347_cur."!cursor_debug"("START", "prefix:sym<-->")
  debug_1134:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1351_done
    goto rxscan1351_scan
  rxscan1351_loop:
    (rx1347_pos) = rx1347_cur."from"()
    inc rx1347_pos
    rx1347_cur."!cursor_from"(rx1347_pos)
    ge rx1347_pos, rx1347_eos, rxscan1351_done
  rxscan1351_scan:
    set_addr $I10, rxscan1351_loop
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  rxscan1351_done:
.annotate 'line', 623
  # rx subcapture "sym"
    set_addr $I10, rxcap_1352_fail
    rx1347_cur."!mark_push"(0, rx1347_pos, $I10)
  # rx literal  "--"
    add $I11, rx1347_pos, 2
    gt $I11, rx1347_eos, rx1347_fail
    sub $I11, rx1347_pos, rx1347_off
    substr $S10, rx1347_tgt, $I11, 2
    ne $S10, "--", rx1347_fail
    add rx1347_pos, 2
    set_addr $I10, rxcap_1352_fail
    ($I12, $I11) = rx1347_cur."!mark_peek"($I10)
    rx1347_cur."!cursor_pos"($I11)
    ($P10) = rx1347_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1347_pos, "")
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1352_done
  rxcap_1352_fail:
    goto rx1347_fail
  rxcap_1352_done:
  # rx subrule "O" subtype=capture negate=
    rx1347_cur."!cursor_pos"(rx1347_pos)
    $P10 = rx1347_cur."O"("%autoincrement, :pirop<dec>")
    unless $P10, rx1347_fail
    rx1347_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1347_pos = $P10."pos"()
  # rx pass
    rx1347_cur."!cursor_pass"(rx1347_pos, "prefix:sym<-->")
    if_null rx1347_debug, debug_1135
    rx1347_cur."!cursor_debug"("PASS", "prefix:sym<-->", " at pos=", rx1347_pos)
  debug_1135:
    .return (rx1347_cur)
  rx1347_restart:
.annotate 'line', 10
    if_null rx1347_debug, debug_1136
    rx1347_cur."!cursor_debug"("NEXT", "prefix:sym<-->")
  debug_1136:
  rx1347_fail:
    (rx1347_rep, rx1347_pos, $I10, $P10) = rx1347_cur."!mark_fail"(0)
    lt rx1347_pos, -1, rx1347_done
    eq rx1347_pos, -1, rx1347_fail
    jump $I10
  rx1347_done:
    rx1347_cur."!cursor_fail"()
    if_null rx1347_debug, debug_1137
    rx1347_cur."!cursor_debug"("FAIL", "prefix:sym<-->")
  debug_1137:
    .return (rx1347_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<-->"  :nsentry("!PREFIX__prefix:sym<-->") :subid("289_1300146757.646") :method
.annotate 'line', 10
    $P1349 = self."!PREFIX__!subrule"("O", "--")
    new $P1350, "ResizablePMCArray"
    push $P1350, $P1349
    .return ($P1350)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<++>"  :subid("290_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1354_tgt
    .local int rx1354_pos
    .local int rx1354_off
    .local int rx1354_eos
    .local int rx1354_rep
    .local pmc rx1354_cur
    .local pmc rx1354_debug
    (rx1354_cur, rx1354_pos, rx1354_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1354_cur
    .local pmc match
    .lex "$/", match
    length rx1354_eos, rx1354_tgt
    gt rx1354_pos, rx1354_eos, rx1354_done
    set rx1354_off, 0
    lt rx1354_pos, 2, rx1354_start
    sub rx1354_off, rx1354_pos, 1
    substr rx1354_tgt, rx1354_tgt, rx1354_off
  rx1354_start:
    eq $I10, 1, rx1354_restart
    if_null rx1354_debug, debug_1138
    rx1354_cur."!cursor_debug"("START", "postfix:sym<++>")
  debug_1138:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1358_done
    goto rxscan1358_scan
  rxscan1358_loop:
    (rx1354_pos) = rx1354_cur."from"()
    inc rx1354_pos
    rx1354_cur."!cursor_from"(rx1354_pos)
    ge rx1354_pos, rx1354_eos, rxscan1358_done
  rxscan1358_scan:
    set_addr $I10, rxscan1358_loop
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  rxscan1358_done:
.annotate 'line', 626
  # rx subcapture "sym"
    set_addr $I10, rxcap_1359_fail
    rx1354_cur."!mark_push"(0, rx1354_pos, $I10)
  # rx literal  "++"
    add $I11, rx1354_pos, 2
    gt $I11, rx1354_eos, rx1354_fail
    sub $I11, rx1354_pos, rx1354_off
    substr $S10, rx1354_tgt, $I11, 2
    ne $S10, "++", rx1354_fail
    add rx1354_pos, 2
    set_addr $I10, rxcap_1359_fail
    ($I12, $I11) = rx1354_cur."!mark_peek"($I10)
    rx1354_cur."!cursor_pos"($I11)
    ($P10) = rx1354_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1354_pos, "")
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1359_done
  rxcap_1359_fail:
    goto rx1354_fail
  rxcap_1359_done:
  # rx subrule "O" subtype=capture negate=
    rx1354_cur."!cursor_pos"(rx1354_pos)
    $P10 = rx1354_cur."O"("%autoincrement")
    unless $P10, rx1354_fail
    rx1354_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1354_pos = $P10."pos"()
  # rx pass
    rx1354_cur."!cursor_pass"(rx1354_pos, "postfix:sym<++>")
    if_null rx1354_debug, debug_1139
    rx1354_cur."!cursor_debug"("PASS", "postfix:sym<++>", " at pos=", rx1354_pos)
  debug_1139:
    .return (rx1354_cur)
  rx1354_restart:
.annotate 'line', 10
    if_null rx1354_debug, debug_1140
    rx1354_cur."!cursor_debug"("NEXT", "postfix:sym<++>")
  debug_1140:
  rx1354_fail:
    (rx1354_rep, rx1354_pos, $I10, $P10) = rx1354_cur."!mark_fail"(0)
    lt rx1354_pos, -1, rx1354_done
    eq rx1354_pos, -1, rx1354_fail
    jump $I10
  rx1354_done:
    rx1354_cur."!cursor_fail"()
    if_null rx1354_debug, debug_1141
    rx1354_cur."!cursor_debug"("FAIL", "postfix:sym<++>")
  debug_1141:
    .return (rx1354_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<++>"  :nsentry("!PREFIX__postfix:sym<++>") :subid("291_1300146757.646") :method
.annotate 'line', 10
    $P1356 = self."!PREFIX__!subrule"("O", "++")
    new $P1357, "ResizablePMCArray"
    push $P1357, $P1356
    .return ($P1357)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "postfix:sym<-->"  :subid("292_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1361_tgt
    .local int rx1361_pos
    .local int rx1361_off
    .local int rx1361_eos
    .local int rx1361_rep
    .local pmc rx1361_cur
    .local pmc rx1361_debug
    (rx1361_cur, rx1361_pos, rx1361_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1361_cur
    .local pmc match
    .lex "$/", match
    length rx1361_eos, rx1361_tgt
    gt rx1361_pos, rx1361_eos, rx1361_done
    set rx1361_off, 0
    lt rx1361_pos, 2, rx1361_start
    sub rx1361_off, rx1361_pos, 1
    substr rx1361_tgt, rx1361_tgt, rx1361_off
  rx1361_start:
    eq $I10, 1, rx1361_restart
    if_null rx1361_debug, debug_1142
    rx1361_cur."!cursor_debug"("START", "postfix:sym<-->")
  debug_1142:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1365_done
    goto rxscan1365_scan
  rxscan1365_loop:
    (rx1361_pos) = rx1361_cur."from"()
    inc rx1361_pos
    rx1361_cur."!cursor_from"(rx1361_pos)
    ge rx1361_pos, rx1361_eos, rxscan1365_done
  rxscan1365_scan:
    set_addr $I10, rxscan1365_loop
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  rxscan1365_done:
.annotate 'line', 627
  # rx subcapture "sym"
    set_addr $I10, rxcap_1366_fail
    rx1361_cur."!mark_push"(0, rx1361_pos, $I10)
  # rx literal  "--"
    add $I11, rx1361_pos, 2
    gt $I11, rx1361_eos, rx1361_fail
    sub $I11, rx1361_pos, rx1361_off
    substr $S10, rx1361_tgt, $I11, 2
    ne $S10, "--", rx1361_fail
    add rx1361_pos, 2
    set_addr $I10, rxcap_1366_fail
    ($I12, $I11) = rx1361_cur."!mark_peek"($I10)
    rx1361_cur."!cursor_pos"($I11)
    ($P10) = rx1361_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1361_pos, "")
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1366_done
  rxcap_1366_fail:
    goto rx1361_fail
  rxcap_1366_done:
  # rx subrule "O" subtype=capture negate=
    rx1361_cur."!cursor_pos"(rx1361_pos)
    $P10 = rx1361_cur."O"("%autoincrement")
    unless $P10, rx1361_fail
    rx1361_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1361_pos = $P10."pos"()
  # rx pass
    rx1361_cur."!cursor_pass"(rx1361_pos, "postfix:sym<-->")
    if_null rx1361_debug, debug_1143
    rx1361_cur."!cursor_debug"("PASS", "postfix:sym<-->", " at pos=", rx1361_pos)
  debug_1143:
    .return (rx1361_cur)
  rx1361_restart:
.annotate 'line', 10
    if_null rx1361_debug, debug_1144
    rx1361_cur."!cursor_debug"("NEXT", "postfix:sym<-->")
  debug_1144:
  rx1361_fail:
    (rx1361_rep, rx1361_pos, $I10, $P10) = rx1361_cur."!mark_fail"(0)
    lt rx1361_pos, -1, rx1361_done
    eq rx1361_pos, -1, rx1361_fail
    jump $I10
  rx1361_done:
    rx1361_cur."!cursor_fail"()
    if_null rx1361_debug, debug_1145
    rx1361_cur."!cursor_debug"("FAIL", "postfix:sym<-->")
  debug_1145:
    .return (rx1361_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__postfix:sym<-->"  :nsentry("!PREFIX__postfix:sym<-->") :subid("293_1300146757.646") :method
.annotate 'line', 10
    $P1363 = self."!PREFIX__!subrule"("O", "--")
    new $P1364, "ResizablePMCArray"
    push $P1364, $P1363
    .return ($P1364)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<**>"  :subid("294_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1368_tgt
    .local int rx1368_pos
    .local int rx1368_off
    .local int rx1368_eos
    .local int rx1368_rep
    .local pmc rx1368_cur
    .local pmc rx1368_debug
    (rx1368_cur, rx1368_pos, rx1368_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1368_cur
    .local pmc match
    .lex "$/", match
    length rx1368_eos, rx1368_tgt
    gt rx1368_pos, rx1368_eos, rx1368_done
    set rx1368_off, 0
    lt rx1368_pos, 2, rx1368_start
    sub rx1368_off, rx1368_pos, 1
    substr rx1368_tgt, rx1368_tgt, rx1368_off
  rx1368_start:
    eq $I10, 1, rx1368_restart
    if_null rx1368_debug, debug_1146
    rx1368_cur."!cursor_debug"("START", "infix:sym<**>")
  debug_1146:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1372_done
    goto rxscan1372_scan
  rxscan1372_loop:
    (rx1368_pos) = rx1368_cur."from"()
    inc rx1368_pos
    rx1368_cur."!cursor_from"(rx1368_pos)
    ge rx1368_pos, rx1368_eos, rxscan1372_done
  rxscan1372_scan:
    set_addr $I10, rxscan1372_loop
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  rxscan1372_done:
.annotate 'line', 629
  # rx subcapture "sym"
    set_addr $I10, rxcap_1373_fail
    rx1368_cur."!mark_push"(0, rx1368_pos, $I10)
  # rx literal  "**"
    add $I11, rx1368_pos, 2
    gt $I11, rx1368_eos, rx1368_fail
    sub $I11, rx1368_pos, rx1368_off
    substr $S10, rx1368_tgt, $I11, 2
    ne $S10, "**", rx1368_fail
    add rx1368_pos, 2
    set_addr $I10, rxcap_1373_fail
    ($I12, $I11) = rx1368_cur."!mark_peek"($I10)
    rx1368_cur."!cursor_pos"($I11)
    ($P10) = rx1368_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1368_pos, "")
    rx1368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1373_done
  rxcap_1373_fail:
    goto rx1368_fail
  rxcap_1373_done:
  # rx subrule "O" subtype=capture negate=
    rx1368_cur."!cursor_pos"(rx1368_pos)
    $P10 = rx1368_cur."O"("%exponentiation, :pirop<pow>")
    unless $P10, rx1368_fail
    rx1368_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1368_pos = $P10."pos"()
  # rx pass
    rx1368_cur."!cursor_pass"(rx1368_pos, "infix:sym<**>")
    if_null rx1368_debug, debug_1147
    rx1368_cur."!cursor_debug"("PASS", "infix:sym<**>", " at pos=", rx1368_pos)
  debug_1147:
    .return (rx1368_cur)
  rx1368_restart:
.annotate 'line', 10
    if_null rx1368_debug, debug_1148
    rx1368_cur."!cursor_debug"("NEXT", "infix:sym<**>")
  debug_1148:
  rx1368_fail:
    (rx1368_rep, rx1368_pos, $I10, $P10) = rx1368_cur."!mark_fail"(0)
    lt rx1368_pos, -1, rx1368_done
    eq rx1368_pos, -1, rx1368_fail
    jump $I10
  rx1368_done:
    rx1368_cur."!cursor_fail"()
    if_null rx1368_debug, debug_1149
    rx1368_cur."!cursor_debug"("FAIL", "infix:sym<**>")
  debug_1149:
    .return (rx1368_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<**>"  :nsentry("!PREFIX__infix:sym<**>") :subid("295_1300146757.646") :method
.annotate 'line', 10
    $P1370 = self."!PREFIX__!subrule"("O", "**")
    new $P1371, "ResizablePMCArray"
    push $P1371, $P1370
    .return ($P1371)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<+>"  :subid("296_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1375_tgt
    .local int rx1375_pos
    .local int rx1375_off
    .local int rx1375_eos
    .local int rx1375_rep
    .local pmc rx1375_cur
    .local pmc rx1375_debug
    (rx1375_cur, rx1375_pos, rx1375_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1375_cur
    .local pmc match
    .lex "$/", match
    length rx1375_eos, rx1375_tgt
    gt rx1375_pos, rx1375_eos, rx1375_done
    set rx1375_off, 0
    lt rx1375_pos, 2, rx1375_start
    sub rx1375_off, rx1375_pos, 1
    substr rx1375_tgt, rx1375_tgt, rx1375_off
  rx1375_start:
    eq $I10, 1, rx1375_restart
    if_null rx1375_debug, debug_1150
    rx1375_cur."!cursor_debug"("START", "prefix:sym<+>")
  debug_1150:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1379_done
    goto rxscan1379_scan
  rxscan1379_loop:
    (rx1375_pos) = rx1375_cur."from"()
    inc rx1375_pos
    rx1375_cur."!cursor_from"(rx1375_pos)
    ge rx1375_pos, rx1375_eos, rxscan1379_done
  rxscan1379_scan:
    set_addr $I10, rxscan1379_loop
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  rxscan1379_done:
.annotate 'line', 631
  # rx subcapture "sym"
    set_addr $I10, rxcap_1380_fail
    rx1375_cur."!mark_push"(0, rx1375_pos, $I10)
  # rx literal  "+"
    add $I11, rx1375_pos, 1
    gt $I11, rx1375_eos, rx1375_fail
    sub $I11, rx1375_pos, rx1375_off
    ord $I11, rx1375_tgt, $I11
    ne $I11, 43, rx1375_fail
    add rx1375_pos, 1
    set_addr $I10, rxcap_1380_fail
    ($I12, $I11) = rx1375_cur."!mark_peek"($I10)
    rx1375_cur."!cursor_pos"($I11)
    ($P10) = rx1375_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1375_pos, "")
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1380_done
  rxcap_1380_fail:
    goto rx1375_fail
  rxcap_1380_done:
  # rx subrule "O" subtype=capture negate=
    rx1375_cur."!cursor_pos"(rx1375_pos)
    $P10 = rx1375_cur."O"("%symbolic_unary, :pirop<set N*>")
    unless $P10, rx1375_fail
    rx1375_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1375_pos = $P10."pos"()
  # rx pass
    rx1375_cur."!cursor_pass"(rx1375_pos, "prefix:sym<+>")
    if_null rx1375_debug, debug_1151
    rx1375_cur."!cursor_debug"("PASS", "prefix:sym<+>", " at pos=", rx1375_pos)
  debug_1151:
    .return (rx1375_cur)
  rx1375_restart:
.annotate 'line', 10
    if_null rx1375_debug, debug_1152
    rx1375_cur."!cursor_debug"("NEXT", "prefix:sym<+>")
  debug_1152:
  rx1375_fail:
    (rx1375_rep, rx1375_pos, $I10, $P10) = rx1375_cur."!mark_fail"(0)
    lt rx1375_pos, -1, rx1375_done
    eq rx1375_pos, -1, rx1375_fail
    jump $I10
  rx1375_done:
    rx1375_cur."!cursor_fail"()
    if_null rx1375_debug, debug_1153
    rx1375_cur."!cursor_debug"("FAIL", "prefix:sym<+>")
  debug_1153:
    .return (rx1375_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<+>"  :nsentry("!PREFIX__prefix:sym<+>") :subid("297_1300146757.646") :method
.annotate 'line', 10
    $P1377 = self."!PREFIX__!subrule"("O", "+")
    new $P1378, "ResizablePMCArray"
    push $P1378, $P1377
    .return ($P1378)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<~>"  :subid("298_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1382_tgt
    .local int rx1382_pos
    .local int rx1382_off
    .local int rx1382_eos
    .local int rx1382_rep
    .local pmc rx1382_cur
    .local pmc rx1382_debug
    (rx1382_cur, rx1382_pos, rx1382_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1382_cur
    .local pmc match
    .lex "$/", match
    length rx1382_eos, rx1382_tgt
    gt rx1382_pos, rx1382_eos, rx1382_done
    set rx1382_off, 0
    lt rx1382_pos, 2, rx1382_start
    sub rx1382_off, rx1382_pos, 1
    substr rx1382_tgt, rx1382_tgt, rx1382_off
  rx1382_start:
    eq $I10, 1, rx1382_restart
    if_null rx1382_debug, debug_1154
    rx1382_cur."!cursor_debug"("START", "prefix:sym<~>")
  debug_1154:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1386_done
    goto rxscan1386_scan
  rxscan1386_loop:
    (rx1382_pos) = rx1382_cur."from"()
    inc rx1382_pos
    rx1382_cur."!cursor_from"(rx1382_pos)
    ge rx1382_pos, rx1382_eos, rxscan1386_done
  rxscan1386_scan:
    set_addr $I10, rxscan1386_loop
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  rxscan1386_done:
.annotate 'line', 632
  # rx subcapture "sym"
    set_addr $I10, rxcap_1387_fail
    rx1382_cur."!mark_push"(0, rx1382_pos, $I10)
  # rx literal  "~"
    add $I11, rx1382_pos, 1
    gt $I11, rx1382_eos, rx1382_fail
    sub $I11, rx1382_pos, rx1382_off
    ord $I11, rx1382_tgt, $I11
    ne $I11, 126, rx1382_fail
    add rx1382_pos, 1
    set_addr $I10, rxcap_1387_fail
    ($I12, $I11) = rx1382_cur."!mark_peek"($I10)
    rx1382_cur."!cursor_pos"($I11)
    ($P10) = rx1382_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1382_pos, "")
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1387_done
  rxcap_1387_fail:
    goto rx1382_fail
  rxcap_1387_done:
  # rx subrule "O" subtype=capture negate=
    rx1382_cur."!cursor_pos"(rx1382_pos)
    $P10 = rx1382_cur."O"("%symbolic_unary, :pirop<set S*>")
    unless $P10, rx1382_fail
    rx1382_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1382_pos = $P10."pos"()
  # rx pass
    rx1382_cur."!cursor_pass"(rx1382_pos, "prefix:sym<~>")
    if_null rx1382_debug, debug_1155
    rx1382_cur."!cursor_debug"("PASS", "prefix:sym<~>", " at pos=", rx1382_pos)
  debug_1155:
    .return (rx1382_cur)
  rx1382_restart:
.annotate 'line', 10
    if_null rx1382_debug, debug_1156
    rx1382_cur."!cursor_debug"("NEXT", "prefix:sym<~>")
  debug_1156:
  rx1382_fail:
    (rx1382_rep, rx1382_pos, $I10, $P10) = rx1382_cur."!mark_fail"(0)
    lt rx1382_pos, -1, rx1382_done
    eq rx1382_pos, -1, rx1382_fail
    jump $I10
  rx1382_done:
    rx1382_cur."!cursor_fail"()
    if_null rx1382_debug, debug_1157
    rx1382_cur."!cursor_debug"("FAIL", "prefix:sym<~>")
  debug_1157:
    .return (rx1382_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<~>"  :nsentry("!PREFIX__prefix:sym<~>") :subid("299_1300146757.646") :method
.annotate 'line', 10
    $P1384 = self."!PREFIX__!subrule"("O", "~")
    new $P1385, "ResizablePMCArray"
    push $P1385, $P1384
    .return ($P1385)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<->"  :subid("300_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1389_tgt
    .local int rx1389_pos
    .local int rx1389_off
    .local int rx1389_eos
    .local int rx1389_rep
    .local pmc rx1389_cur
    .local pmc rx1389_debug
    (rx1389_cur, rx1389_pos, rx1389_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1389_cur
    .local pmc match
    .lex "$/", match
    length rx1389_eos, rx1389_tgt
    gt rx1389_pos, rx1389_eos, rx1389_done
    set rx1389_off, 0
    lt rx1389_pos, 2, rx1389_start
    sub rx1389_off, rx1389_pos, 1
    substr rx1389_tgt, rx1389_tgt, rx1389_off
  rx1389_start:
    eq $I10, 1, rx1389_restart
    if_null rx1389_debug, debug_1158
    rx1389_cur."!cursor_debug"("START", "prefix:sym<->")
  debug_1158:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1392_done
    goto rxscan1392_scan
  rxscan1392_loop:
    (rx1389_pos) = rx1389_cur."from"()
    inc rx1389_pos
    rx1389_cur."!cursor_from"(rx1389_pos)
    ge rx1389_pos, rx1389_eos, rxscan1392_done
  rxscan1392_scan:
    set_addr $I10, rxscan1392_loop
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  rxscan1392_done:
.annotate 'line', 633
  # rx subcapture "sym"
    set_addr $I10, rxcap_1393_fail
    rx1389_cur."!mark_push"(0, rx1389_pos, $I10)
  # rx literal  "-"
    add $I11, rx1389_pos, 1
    gt $I11, rx1389_eos, rx1389_fail
    sub $I11, rx1389_pos, rx1389_off
    ord $I11, rx1389_tgt, $I11
    ne $I11, 45, rx1389_fail
    add rx1389_pos, 1
    set_addr $I10, rxcap_1393_fail
    ($I12, $I11) = rx1389_cur."!mark_peek"($I10)
    rx1389_cur."!cursor_pos"($I11)
    ($P10) = rx1389_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1389_pos, "")
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1393_done
  rxcap_1393_fail:
    goto rx1389_fail
  rxcap_1393_done:
  # rx enumcharlist negate=1 zerowidth
    sub $I10, rx1389_pos, rx1389_off
    substr $S10, rx1389_tgt, $I10, 1
    index $I11, ">", $S10
    ge $I11, 0, rx1389_fail
  # rx subrule "number" subtype=zerowidth negate=1
    rx1389_cur."!cursor_pos"(rx1389_pos)
    $P10 = rx1389_cur."number"()
    if $P10, rx1389_fail
  # rx subrule "O" subtype=capture negate=
    rx1389_cur."!cursor_pos"(rx1389_pos)
    $P10 = rx1389_cur."O"("%symbolic_unary, :pirop<neg>")
    unless $P10, rx1389_fail
    rx1389_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1389_pos = $P10."pos"()
  # rx pass
    rx1389_cur."!cursor_pass"(rx1389_pos, "prefix:sym<->")
    if_null rx1389_debug, debug_1159
    rx1389_cur."!cursor_debug"("PASS", "prefix:sym<->", " at pos=", rx1389_pos)
  debug_1159:
    .return (rx1389_cur)
  rx1389_restart:
.annotate 'line', 10
    if_null rx1389_debug, debug_1160
    rx1389_cur."!cursor_debug"("NEXT", "prefix:sym<->")
  debug_1160:
  rx1389_fail:
    (rx1389_rep, rx1389_pos, $I10, $P10) = rx1389_cur."!mark_fail"(0)
    lt rx1389_pos, -1, rx1389_done
    eq rx1389_pos, -1, rx1389_fail
    jump $I10
  rx1389_done:
    rx1389_cur."!cursor_fail"()
    if_null rx1389_debug, debug_1161
    rx1389_cur."!cursor_debug"("FAIL", "prefix:sym<->")
  debug_1161:
    .return (rx1389_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<->"  :nsentry("!PREFIX__prefix:sym<->") :subid("301_1300146757.646") :method
.annotate 'line', 10
    new $P1391, "ResizablePMCArray"
    push $P1391, "-"
    .return ($P1391)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<?>"  :subid("302_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1395_tgt
    .local int rx1395_pos
    .local int rx1395_off
    .local int rx1395_eos
    .local int rx1395_rep
    .local pmc rx1395_cur
    .local pmc rx1395_debug
    (rx1395_cur, rx1395_pos, rx1395_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1395_cur
    .local pmc match
    .lex "$/", match
    length rx1395_eos, rx1395_tgt
    gt rx1395_pos, rx1395_eos, rx1395_done
    set rx1395_off, 0
    lt rx1395_pos, 2, rx1395_start
    sub rx1395_off, rx1395_pos, 1
    substr rx1395_tgt, rx1395_tgt, rx1395_off
  rx1395_start:
    eq $I10, 1, rx1395_restart
    if_null rx1395_debug, debug_1162
    rx1395_cur."!cursor_debug"("START", "prefix:sym<?>")
  debug_1162:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1399_done
    goto rxscan1399_scan
  rxscan1399_loop:
    (rx1395_pos) = rx1395_cur."from"()
    inc rx1395_pos
    rx1395_cur."!cursor_from"(rx1395_pos)
    ge rx1395_pos, rx1395_eos, rxscan1399_done
  rxscan1399_scan:
    set_addr $I10, rxscan1399_loop
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  rxscan1399_done:
.annotate 'line', 634
  # rx subcapture "sym"
    set_addr $I10, rxcap_1400_fail
    rx1395_cur."!mark_push"(0, rx1395_pos, $I10)
  # rx literal  "?"
    add $I11, rx1395_pos, 1
    gt $I11, rx1395_eos, rx1395_fail
    sub $I11, rx1395_pos, rx1395_off
    ord $I11, rx1395_tgt, $I11
    ne $I11, 63, rx1395_fail
    add rx1395_pos, 1
    set_addr $I10, rxcap_1400_fail
    ($I12, $I11) = rx1395_cur."!mark_peek"($I10)
    rx1395_cur."!cursor_pos"($I11)
    ($P10) = rx1395_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1395_pos, "")
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1400_done
  rxcap_1400_fail:
    goto rx1395_fail
  rxcap_1400_done:
  # rx subrule "O" subtype=capture negate=
    rx1395_cur."!cursor_pos"(rx1395_pos)
    $P10 = rx1395_cur."O"("%symbolic_unary, :pirop<istrue>")
    unless $P10, rx1395_fail
    rx1395_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1395_pos = $P10."pos"()
  # rx pass
    rx1395_cur."!cursor_pass"(rx1395_pos, "prefix:sym<?>")
    if_null rx1395_debug, debug_1163
    rx1395_cur."!cursor_debug"("PASS", "prefix:sym<?>", " at pos=", rx1395_pos)
  debug_1163:
    .return (rx1395_cur)
  rx1395_restart:
.annotate 'line', 10
    if_null rx1395_debug, debug_1164
    rx1395_cur."!cursor_debug"("NEXT", "prefix:sym<?>")
  debug_1164:
  rx1395_fail:
    (rx1395_rep, rx1395_pos, $I10, $P10) = rx1395_cur."!mark_fail"(0)
    lt rx1395_pos, -1, rx1395_done
    eq rx1395_pos, -1, rx1395_fail
    jump $I10
  rx1395_done:
    rx1395_cur."!cursor_fail"()
    if_null rx1395_debug, debug_1165
    rx1395_cur."!cursor_debug"("FAIL", "prefix:sym<?>")
  debug_1165:
    .return (rx1395_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<?>"  :nsentry("!PREFIX__prefix:sym<?>") :subid("303_1300146757.646") :method
.annotate 'line', 10
    $P1397 = self."!PREFIX__!subrule"("O", "?")
    new $P1398, "ResizablePMCArray"
    push $P1398, $P1397
    .return ($P1398)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<!>"  :subid("304_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1402_tgt
    .local int rx1402_pos
    .local int rx1402_off
    .local int rx1402_eos
    .local int rx1402_rep
    .local pmc rx1402_cur
    .local pmc rx1402_debug
    (rx1402_cur, rx1402_pos, rx1402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1402_cur
    .local pmc match
    .lex "$/", match
    length rx1402_eos, rx1402_tgt
    gt rx1402_pos, rx1402_eos, rx1402_done
    set rx1402_off, 0
    lt rx1402_pos, 2, rx1402_start
    sub rx1402_off, rx1402_pos, 1
    substr rx1402_tgt, rx1402_tgt, rx1402_off
  rx1402_start:
    eq $I10, 1, rx1402_restart
    if_null rx1402_debug, debug_1166
    rx1402_cur."!cursor_debug"("START", "prefix:sym<!>")
  debug_1166:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1406_done
    goto rxscan1406_scan
  rxscan1406_loop:
    (rx1402_pos) = rx1402_cur."from"()
    inc rx1402_pos
    rx1402_cur."!cursor_from"(rx1402_pos)
    ge rx1402_pos, rx1402_eos, rxscan1406_done
  rxscan1406_scan:
    set_addr $I10, rxscan1406_loop
    rx1402_cur."!mark_push"(0, rx1402_pos, $I10)
  rxscan1406_done:
.annotate 'line', 635
  # rx subcapture "sym"
    set_addr $I10, rxcap_1407_fail
    rx1402_cur."!mark_push"(0, rx1402_pos, $I10)
  # rx literal  "!"
    add $I11, rx1402_pos, 1
    gt $I11, rx1402_eos, rx1402_fail
    sub $I11, rx1402_pos, rx1402_off
    ord $I11, rx1402_tgt, $I11
    ne $I11, 33, rx1402_fail
    add rx1402_pos, 1
    set_addr $I10, rxcap_1407_fail
    ($I12, $I11) = rx1402_cur."!mark_peek"($I10)
    rx1402_cur."!cursor_pos"($I11)
    ($P10) = rx1402_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1402_pos, "")
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1407_done
  rxcap_1407_fail:
    goto rx1402_fail
  rxcap_1407_done:
  # rx subrule "O" subtype=capture negate=
    rx1402_cur."!cursor_pos"(rx1402_pos)
    $P10 = rx1402_cur."O"("%symbolic_unary, :pirop<isfalse>")
    unless $P10, rx1402_fail
    rx1402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1402_pos = $P10."pos"()
  # rx pass
    rx1402_cur."!cursor_pass"(rx1402_pos, "prefix:sym<!>")
    if_null rx1402_debug, debug_1167
    rx1402_cur."!cursor_debug"("PASS", "prefix:sym<!>", " at pos=", rx1402_pos)
  debug_1167:
    .return (rx1402_cur)
  rx1402_restart:
.annotate 'line', 10
    if_null rx1402_debug, debug_1168
    rx1402_cur."!cursor_debug"("NEXT", "prefix:sym<!>")
  debug_1168:
  rx1402_fail:
    (rx1402_rep, rx1402_pos, $I10, $P10) = rx1402_cur."!mark_fail"(0)
    lt rx1402_pos, -1, rx1402_done
    eq rx1402_pos, -1, rx1402_fail
    jump $I10
  rx1402_done:
    rx1402_cur."!cursor_fail"()
    if_null rx1402_debug, debug_1169
    rx1402_cur."!cursor_debug"("FAIL", "prefix:sym<!>")
  debug_1169:
    .return (rx1402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<!>"  :nsentry("!PREFIX__prefix:sym<!>") :subid("305_1300146757.646") :method
.annotate 'line', 10
    $P1404 = self."!PREFIX__!subrule"("O", "!")
    new $P1405, "ResizablePMCArray"
    push $P1405, $P1404
    .return ($P1405)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<|>"  :subid("306_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1409_tgt
    .local int rx1409_pos
    .local int rx1409_off
    .local int rx1409_eos
    .local int rx1409_rep
    .local pmc rx1409_cur
    .local pmc rx1409_debug
    (rx1409_cur, rx1409_pos, rx1409_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1409_cur
    .local pmc match
    .lex "$/", match
    length rx1409_eos, rx1409_tgt
    gt rx1409_pos, rx1409_eos, rx1409_done
    set rx1409_off, 0
    lt rx1409_pos, 2, rx1409_start
    sub rx1409_off, rx1409_pos, 1
    substr rx1409_tgt, rx1409_tgt, rx1409_off
  rx1409_start:
    eq $I10, 1, rx1409_restart
    if_null rx1409_debug, debug_1170
    rx1409_cur."!cursor_debug"("START", "prefix:sym<|>")
  debug_1170:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1413_done
    goto rxscan1413_scan
  rxscan1413_loop:
    (rx1409_pos) = rx1409_cur."from"()
    inc rx1409_pos
    rx1409_cur."!cursor_from"(rx1409_pos)
    ge rx1409_pos, rx1409_eos, rxscan1413_done
  rxscan1413_scan:
    set_addr $I10, rxscan1413_loop
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  rxscan1413_done:
.annotate 'line', 636
  # rx subcapture "sym"
    set_addr $I10, rxcap_1414_fail
    rx1409_cur."!mark_push"(0, rx1409_pos, $I10)
  # rx literal  "|"
    add $I11, rx1409_pos, 1
    gt $I11, rx1409_eos, rx1409_fail
    sub $I11, rx1409_pos, rx1409_off
    ord $I11, rx1409_tgt, $I11
    ne $I11, 124, rx1409_fail
    add rx1409_pos, 1
    set_addr $I10, rxcap_1414_fail
    ($I12, $I11) = rx1409_cur."!mark_peek"($I10)
    rx1409_cur."!cursor_pos"($I11)
    ($P10) = rx1409_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1409_pos, "")
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1414_done
  rxcap_1414_fail:
    goto rx1409_fail
  rxcap_1414_done:
  # rx subrule "O" subtype=capture negate=
    rx1409_cur."!cursor_pos"(rx1409_pos)
    $P10 = rx1409_cur."O"("%symbolic_unary")
    unless $P10, rx1409_fail
    rx1409_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1409_pos = $P10."pos"()
  # rx pass
    rx1409_cur."!cursor_pass"(rx1409_pos, "prefix:sym<|>")
    if_null rx1409_debug, debug_1171
    rx1409_cur."!cursor_debug"("PASS", "prefix:sym<|>", " at pos=", rx1409_pos)
  debug_1171:
    .return (rx1409_cur)
  rx1409_restart:
.annotate 'line', 10
    if_null rx1409_debug, debug_1172
    rx1409_cur."!cursor_debug"("NEXT", "prefix:sym<|>")
  debug_1172:
  rx1409_fail:
    (rx1409_rep, rx1409_pos, $I10, $P10) = rx1409_cur."!mark_fail"(0)
    lt rx1409_pos, -1, rx1409_done
    eq rx1409_pos, -1, rx1409_fail
    jump $I10
  rx1409_done:
    rx1409_cur."!cursor_fail"()
    if_null rx1409_debug, debug_1173
    rx1409_cur."!cursor_debug"("FAIL", "prefix:sym<|>")
  debug_1173:
    .return (rx1409_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<|>"  :nsentry("!PREFIX__prefix:sym<|>") :subid("307_1300146757.646") :method
.annotate 'line', 10
    $P1411 = self."!PREFIX__!subrule"("O", "|")
    new $P1412, "ResizablePMCArray"
    push $P1412, $P1411
    .return ($P1412)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<*>"  :subid("308_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1416_tgt
    .local int rx1416_pos
    .local int rx1416_off
    .local int rx1416_eos
    .local int rx1416_rep
    .local pmc rx1416_cur
    .local pmc rx1416_debug
    (rx1416_cur, rx1416_pos, rx1416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1416_cur
    .local pmc match
    .lex "$/", match
    length rx1416_eos, rx1416_tgt
    gt rx1416_pos, rx1416_eos, rx1416_done
    set rx1416_off, 0
    lt rx1416_pos, 2, rx1416_start
    sub rx1416_off, rx1416_pos, 1
    substr rx1416_tgt, rx1416_tgt, rx1416_off
  rx1416_start:
    eq $I10, 1, rx1416_restart
    if_null rx1416_debug, debug_1174
    rx1416_cur."!cursor_debug"("START", "infix:sym<*>")
  debug_1174:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1420_done
    goto rxscan1420_scan
  rxscan1420_loop:
    (rx1416_pos) = rx1416_cur."from"()
    inc rx1416_pos
    rx1416_cur."!cursor_from"(rx1416_pos)
    ge rx1416_pos, rx1416_eos, rxscan1420_done
  rxscan1420_scan:
    set_addr $I10, rxscan1420_loop
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  rxscan1420_done:
.annotate 'line', 638
  # rx subcapture "sym"
    set_addr $I10, rxcap_1421_fail
    rx1416_cur."!mark_push"(0, rx1416_pos, $I10)
  # rx literal  "*"
    add $I11, rx1416_pos, 1
    gt $I11, rx1416_eos, rx1416_fail
    sub $I11, rx1416_pos, rx1416_off
    ord $I11, rx1416_tgt, $I11
    ne $I11, 42, rx1416_fail
    add rx1416_pos, 1
    set_addr $I10, rxcap_1421_fail
    ($I12, $I11) = rx1416_cur."!mark_peek"($I10)
    rx1416_cur."!cursor_pos"($I11)
    ($P10) = rx1416_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1416_pos, "")
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1421_done
  rxcap_1421_fail:
    goto rx1416_fail
  rxcap_1421_done:
  # rx subrule "O" subtype=capture negate=
    rx1416_cur."!cursor_pos"(rx1416_pos)
    $P10 = rx1416_cur."O"("%multiplicative, :pirop<mul>")
    unless $P10, rx1416_fail
    rx1416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1416_pos = $P10."pos"()
  # rx pass
    rx1416_cur."!cursor_pass"(rx1416_pos, "infix:sym<*>")
    if_null rx1416_debug, debug_1175
    rx1416_cur."!cursor_debug"("PASS", "infix:sym<*>", " at pos=", rx1416_pos)
  debug_1175:
    .return (rx1416_cur)
  rx1416_restart:
.annotate 'line', 10
    if_null rx1416_debug, debug_1176
    rx1416_cur."!cursor_debug"("NEXT", "infix:sym<*>")
  debug_1176:
  rx1416_fail:
    (rx1416_rep, rx1416_pos, $I10, $P10) = rx1416_cur."!mark_fail"(0)
    lt rx1416_pos, -1, rx1416_done
    eq rx1416_pos, -1, rx1416_fail
    jump $I10
  rx1416_done:
    rx1416_cur."!cursor_fail"()
    if_null rx1416_debug, debug_1177
    rx1416_cur."!cursor_debug"("FAIL", "infix:sym<*>")
  debug_1177:
    .return (rx1416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<*>"  :nsentry("!PREFIX__infix:sym<*>") :subid("309_1300146757.646") :method
.annotate 'line', 10
    $P1418 = self."!PREFIX__!subrule"("O", "*")
    new $P1419, "ResizablePMCArray"
    push $P1419, $P1418
    .return ($P1419)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym</>"  :subid("310_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1423_tgt
    .local int rx1423_pos
    .local int rx1423_off
    .local int rx1423_eos
    .local int rx1423_rep
    .local pmc rx1423_cur
    .local pmc rx1423_debug
    (rx1423_cur, rx1423_pos, rx1423_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1423_cur
    .local pmc match
    .lex "$/", match
    length rx1423_eos, rx1423_tgt
    gt rx1423_pos, rx1423_eos, rx1423_done
    set rx1423_off, 0
    lt rx1423_pos, 2, rx1423_start
    sub rx1423_off, rx1423_pos, 1
    substr rx1423_tgt, rx1423_tgt, rx1423_off
  rx1423_start:
    eq $I10, 1, rx1423_restart
    if_null rx1423_debug, debug_1178
    rx1423_cur."!cursor_debug"("START", "infix:sym</>")
  debug_1178:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1427_done
    goto rxscan1427_scan
  rxscan1427_loop:
    (rx1423_pos) = rx1423_cur."from"()
    inc rx1423_pos
    rx1423_cur."!cursor_from"(rx1423_pos)
    ge rx1423_pos, rx1423_eos, rxscan1427_done
  rxscan1427_scan:
    set_addr $I10, rxscan1427_loop
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  rxscan1427_done:
.annotate 'line', 639
  # rx subcapture "sym"
    set_addr $I10, rxcap_1428_fail
    rx1423_cur."!mark_push"(0, rx1423_pos, $I10)
  # rx literal  "/"
    add $I11, rx1423_pos, 1
    gt $I11, rx1423_eos, rx1423_fail
    sub $I11, rx1423_pos, rx1423_off
    ord $I11, rx1423_tgt, $I11
    ne $I11, 47, rx1423_fail
    add rx1423_pos, 1
    set_addr $I10, rxcap_1428_fail
    ($I12, $I11) = rx1423_cur."!mark_peek"($I10)
    rx1423_cur."!cursor_pos"($I11)
    ($P10) = rx1423_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1423_pos, "")
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1428_done
  rxcap_1428_fail:
    goto rx1423_fail
  rxcap_1428_done:
  # rx subrule "O" subtype=capture negate=
    rx1423_cur."!cursor_pos"(rx1423_pos)
    $P10 = rx1423_cur."O"("%multiplicative, :pirop<div>")
    unless $P10, rx1423_fail
    rx1423_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1423_pos = $P10."pos"()
  # rx pass
    rx1423_cur."!cursor_pass"(rx1423_pos, "infix:sym</>")
    if_null rx1423_debug, debug_1179
    rx1423_cur."!cursor_debug"("PASS", "infix:sym</>", " at pos=", rx1423_pos)
  debug_1179:
    .return (rx1423_cur)
  rx1423_restart:
.annotate 'line', 10
    if_null rx1423_debug, debug_1180
    rx1423_cur."!cursor_debug"("NEXT", "infix:sym</>")
  debug_1180:
  rx1423_fail:
    (rx1423_rep, rx1423_pos, $I10, $P10) = rx1423_cur."!mark_fail"(0)
    lt rx1423_pos, -1, rx1423_done
    eq rx1423_pos, -1, rx1423_fail
    jump $I10
  rx1423_done:
    rx1423_cur."!cursor_fail"()
    if_null rx1423_debug, debug_1181
    rx1423_cur."!cursor_debug"("FAIL", "infix:sym</>")
  debug_1181:
    .return (rx1423_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym</>"  :nsentry("!PREFIX__infix:sym</>") :subid("311_1300146757.646") :method
.annotate 'line', 10
    $P1425 = self."!PREFIX__!subrule"("O", "/")
    new $P1426, "ResizablePMCArray"
    push $P1426, $P1425
    .return ($P1426)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<%>"  :subid("312_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1430_tgt
    .local int rx1430_pos
    .local int rx1430_off
    .local int rx1430_eos
    .local int rx1430_rep
    .local pmc rx1430_cur
    .local pmc rx1430_debug
    (rx1430_cur, rx1430_pos, rx1430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1430_cur
    .local pmc match
    .lex "$/", match
    length rx1430_eos, rx1430_tgt
    gt rx1430_pos, rx1430_eos, rx1430_done
    set rx1430_off, 0
    lt rx1430_pos, 2, rx1430_start
    sub rx1430_off, rx1430_pos, 1
    substr rx1430_tgt, rx1430_tgt, rx1430_off
  rx1430_start:
    eq $I10, 1, rx1430_restart
    if_null rx1430_debug, debug_1182
    rx1430_cur."!cursor_debug"("START", "infix:sym<%>")
  debug_1182:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1434_done
    goto rxscan1434_scan
  rxscan1434_loop:
    (rx1430_pos) = rx1430_cur."from"()
    inc rx1430_pos
    rx1430_cur."!cursor_from"(rx1430_pos)
    ge rx1430_pos, rx1430_eos, rxscan1434_done
  rxscan1434_scan:
    set_addr $I10, rxscan1434_loop
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  rxscan1434_done:
.annotate 'line', 640
  # rx subcapture "sym"
    set_addr $I10, rxcap_1435_fail
    rx1430_cur."!mark_push"(0, rx1430_pos, $I10)
  # rx literal  "%"
    add $I11, rx1430_pos, 1
    gt $I11, rx1430_eos, rx1430_fail
    sub $I11, rx1430_pos, rx1430_off
    ord $I11, rx1430_tgt, $I11
    ne $I11, 37, rx1430_fail
    add rx1430_pos, 1
    set_addr $I10, rxcap_1435_fail
    ($I12, $I11) = rx1430_cur."!mark_peek"($I10)
    rx1430_cur."!cursor_pos"($I11)
    ($P10) = rx1430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1430_pos, "")
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1435_done
  rxcap_1435_fail:
    goto rx1430_fail
  rxcap_1435_done:
  # rx subrule "O" subtype=capture negate=
    rx1430_cur."!cursor_pos"(rx1430_pos)
    $P10 = rx1430_cur."O"("%multiplicative, :pirop<mod>")
    unless $P10, rx1430_fail
    rx1430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1430_pos = $P10."pos"()
  # rx pass
    rx1430_cur."!cursor_pass"(rx1430_pos, "infix:sym<%>")
    if_null rx1430_debug, debug_1183
    rx1430_cur."!cursor_debug"("PASS", "infix:sym<%>", " at pos=", rx1430_pos)
  debug_1183:
    .return (rx1430_cur)
  rx1430_restart:
.annotate 'line', 10
    if_null rx1430_debug, debug_1184
    rx1430_cur."!cursor_debug"("NEXT", "infix:sym<%>")
  debug_1184:
  rx1430_fail:
    (rx1430_rep, rx1430_pos, $I10, $P10) = rx1430_cur."!mark_fail"(0)
    lt rx1430_pos, -1, rx1430_done
    eq rx1430_pos, -1, rx1430_fail
    jump $I10
  rx1430_done:
    rx1430_cur."!cursor_fail"()
    if_null rx1430_debug, debug_1185
    rx1430_cur."!cursor_debug"("FAIL", "infix:sym<%>")
  debug_1185:
    .return (rx1430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<%>"  :nsentry("!PREFIX__infix:sym<%>") :subid("313_1300146757.646") :method
.annotate 'line', 10
    $P1432 = self."!PREFIX__!subrule"("O", "%")
    new $P1433, "ResizablePMCArray"
    push $P1433, $P1432
    .return ($P1433)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+&>"  :subid("314_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1437_tgt
    .local int rx1437_pos
    .local int rx1437_off
    .local int rx1437_eos
    .local int rx1437_rep
    .local pmc rx1437_cur
    .local pmc rx1437_debug
    (rx1437_cur, rx1437_pos, rx1437_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1437_cur
    .local pmc match
    .lex "$/", match
    length rx1437_eos, rx1437_tgt
    gt rx1437_pos, rx1437_eos, rx1437_done
    set rx1437_off, 0
    lt rx1437_pos, 2, rx1437_start
    sub rx1437_off, rx1437_pos, 1
    substr rx1437_tgt, rx1437_tgt, rx1437_off
  rx1437_start:
    eq $I10, 1, rx1437_restart
    if_null rx1437_debug, debug_1186
    rx1437_cur."!cursor_debug"("START", "infix:sym<+&>")
  debug_1186:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1441_done
    goto rxscan1441_scan
  rxscan1441_loop:
    (rx1437_pos) = rx1437_cur."from"()
    inc rx1437_pos
    rx1437_cur."!cursor_from"(rx1437_pos)
    ge rx1437_pos, rx1437_eos, rxscan1441_done
  rxscan1441_scan:
    set_addr $I10, rxscan1441_loop
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  rxscan1441_done:
.annotate 'line', 641
  # rx subcapture "sym"
    set_addr $I10, rxcap_1442_fail
    rx1437_cur."!mark_push"(0, rx1437_pos, $I10)
  # rx literal  "+&"
    add $I11, rx1437_pos, 2
    gt $I11, rx1437_eos, rx1437_fail
    sub $I11, rx1437_pos, rx1437_off
    substr $S10, rx1437_tgt, $I11, 2
    ne $S10, "+&", rx1437_fail
    add rx1437_pos, 2
    set_addr $I10, rxcap_1442_fail
    ($I12, $I11) = rx1437_cur."!mark_peek"($I10)
    rx1437_cur."!cursor_pos"($I11)
    ($P10) = rx1437_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1437_pos, "")
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1442_done
  rxcap_1442_fail:
    goto rx1437_fail
  rxcap_1442_done:
  # rx subrule "O" subtype=capture negate=
    rx1437_cur."!cursor_pos"(rx1437_pos)
    $P10 = rx1437_cur."O"("%multiplicative, :pirop<band III>")
    unless $P10, rx1437_fail
    rx1437_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1437_pos = $P10."pos"()
  # rx pass
    rx1437_cur."!cursor_pass"(rx1437_pos, "infix:sym<+&>")
    if_null rx1437_debug, debug_1187
    rx1437_cur."!cursor_debug"("PASS", "infix:sym<+&>", " at pos=", rx1437_pos)
  debug_1187:
    .return (rx1437_cur)
  rx1437_restart:
.annotate 'line', 10
    if_null rx1437_debug, debug_1188
    rx1437_cur."!cursor_debug"("NEXT", "infix:sym<+&>")
  debug_1188:
  rx1437_fail:
    (rx1437_rep, rx1437_pos, $I10, $P10) = rx1437_cur."!mark_fail"(0)
    lt rx1437_pos, -1, rx1437_done
    eq rx1437_pos, -1, rx1437_fail
    jump $I10
  rx1437_done:
    rx1437_cur."!cursor_fail"()
    if_null rx1437_debug, debug_1189
    rx1437_cur."!cursor_debug"("FAIL", "infix:sym<+&>")
  debug_1189:
    .return (rx1437_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+&>"  :nsentry("!PREFIX__infix:sym<+&>") :subid("315_1300146757.646") :method
.annotate 'line', 10
    $P1439 = self."!PREFIX__!subrule"("O", "+&")
    new $P1440, "ResizablePMCArray"
    push $P1440, $P1439
    .return ($P1440)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+>"  :subid("316_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1444_tgt
    .local int rx1444_pos
    .local int rx1444_off
    .local int rx1444_eos
    .local int rx1444_rep
    .local pmc rx1444_cur
    .local pmc rx1444_debug
    (rx1444_cur, rx1444_pos, rx1444_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1444_cur
    .local pmc match
    .lex "$/", match
    length rx1444_eos, rx1444_tgt
    gt rx1444_pos, rx1444_eos, rx1444_done
    set rx1444_off, 0
    lt rx1444_pos, 2, rx1444_start
    sub rx1444_off, rx1444_pos, 1
    substr rx1444_tgt, rx1444_tgt, rx1444_off
  rx1444_start:
    eq $I10, 1, rx1444_restart
    if_null rx1444_debug, debug_1190
    rx1444_cur."!cursor_debug"("START", "infix:sym<+>")
  debug_1190:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1448_done
    goto rxscan1448_scan
  rxscan1448_loop:
    (rx1444_pos) = rx1444_cur."from"()
    inc rx1444_pos
    rx1444_cur."!cursor_from"(rx1444_pos)
    ge rx1444_pos, rx1444_eos, rxscan1448_done
  rxscan1448_scan:
    set_addr $I10, rxscan1448_loop
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  rxscan1448_done:
.annotate 'line', 643
  # rx subcapture "sym"
    set_addr $I10, rxcap_1449_fail
    rx1444_cur."!mark_push"(0, rx1444_pos, $I10)
  # rx literal  "+"
    add $I11, rx1444_pos, 1
    gt $I11, rx1444_eos, rx1444_fail
    sub $I11, rx1444_pos, rx1444_off
    ord $I11, rx1444_tgt, $I11
    ne $I11, 43, rx1444_fail
    add rx1444_pos, 1
    set_addr $I10, rxcap_1449_fail
    ($I12, $I11) = rx1444_cur."!mark_peek"($I10)
    rx1444_cur."!cursor_pos"($I11)
    ($P10) = rx1444_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1444_pos, "")
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1449_done
  rxcap_1449_fail:
    goto rx1444_fail
  rxcap_1449_done:
  # rx subrule "O" subtype=capture negate=
    rx1444_cur."!cursor_pos"(rx1444_pos)
    $P10 = rx1444_cur."O"("%additive, :pirop<add>")
    unless $P10, rx1444_fail
    rx1444_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1444_pos = $P10."pos"()
  # rx pass
    rx1444_cur."!cursor_pass"(rx1444_pos, "infix:sym<+>")
    if_null rx1444_debug, debug_1191
    rx1444_cur."!cursor_debug"("PASS", "infix:sym<+>", " at pos=", rx1444_pos)
  debug_1191:
    .return (rx1444_cur)
  rx1444_restart:
.annotate 'line', 10
    if_null rx1444_debug, debug_1192
    rx1444_cur."!cursor_debug"("NEXT", "infix:sym<+>")
  debug_1192:
  rx1444_fail:
    (rx1444_rep, rx1444_pos, $I10, $P10) = rx1444_cur."!mark_fail"(0)
    lt rx1444_pos, -1, rx1444_done
    eq rx1444_pos, -1, rx1444_fail
    jump $I10
  rx1444_done:
    rx1444_cur."!cursor_fail"()
    if_null rx1444_debug, debug_1193
    rx1444_cur."!cursor_debug"("FAIL", "infix:sym<+>")
  debug_1193:
    .return (rx1444_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+>"  :nsentry("!PREFIX__infix:sym<+>") :subid("317_1300146757.646") :method
.annotate 'line', 10
    $P1446 = self."!PREFIX__!subrule"("O", "+")
    new $P1447, "ResizablePMCArray"
    push $P1447, $P1446
    .return ($P1447)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<->"  :subid("318_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1451_tgt
    .local int rx1451_pos
    .local int rx1451_off
    .local int rx1451_eos
    .local int rx1451_rep
    .local pmc rx1451_cur
    .local pmc rx1451_debug
    (rx1451_cur, rx1451_pos, rx1451_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1451_cur
    .local pmc match
    .lex "$/", match
    length rx1451_eos, rx1451_tgt
    gt rx1451_pos, rx1451_eos, rx1451_done
    set rx1451_off, 0
    lt rx1451_pos, 2, rx1451_start
    sub rx1451_off, rx1451_pos, 1
    substr rx1451_tgt, rx1451_tgt, rx1451_off
  rx1451_start:
    eq $I10, 1, rx1451_restart
    if_null rx1451_debug, debug_1194
    rx1451_cur."!cursor_debug"("START", "infix:sym<->")
  debug_1194:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1455_done
    goto rxscan1455_scan
  rxscan1455_loop:
    (rx1451_pos) = rx1451_cur."from"()
    inc rx1451_pos
    rx1451_cur."!cursor_from"(rx1451_pos)
    ge rx1451_pos, rx1451_eos, rxscan1455_done
  rxscan1455_scan:
    set_addr $I10, rxscan1455_loop
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  rxscan1455_done:
.annotate 'line', 644
  # rx subcapture "sym"
    set_addr $I10, rxcap_1456_fail
    rx1451_cur."!mark_push"(0, rx1451_pos, $I10)
  # rx literal  "-"
    add $I11, rx1451_pos, 1
    gt $I11, rx1451_eos, rx1451_fail
    sub $I11, rx1451_pos, rx1451_off
    ord $I11, rx1451_tgt, $I11
    ne $I11, 45, rx1451_fail
    add rx1451_pos, 1
    set_addr $I10, rxcap_1456_fail
    ($I12, $I11) = rx1451_cur."!mark_peek"($I10)
    rx1451_cur."!cursor_pos"($I11)
    ($P10) = rx1451_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1451_pos, "")
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1456_done
  rxcap_1456_fail:
    goto rx1451_fail
  rxcap_1456_done:
  # rx subrule "O" subtype=capture negate=
    rx1451_cur."!cursor_pos"(rx1451_pos)
    $P10 = rx1451_cur."O"("%additive, :pirop<sub>")
    unless $P10, rx1451_fail
    rx1451_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1451_pos = $P10."pos"()
  # rx pass
    rx1451_cur."!cursor_pass"(rx1451_pos, "infix:sym<->")
    if_null rx1451_debug, debug_1195
    rx1451_cur."!cursor_debug"("PASS", "infix:sym<->", " at pos=", rx1451_pos)
  debug_1195:
    .return (rx1451_cur)
  rx1451_restart:
.annotate 'line', 10
    if_null rx1451_debug, debug_1196
    rx1451_cur."!cursor_debug"("NEXT", "infix:sym<->")
  debug_1196:
  rx1451_fail:
    (rx1451_rep, rx1451_pos, $I10, $P10) = rx1451_cur."!mark_fail"(0)
    lt rx1451_pos, -1, rx1451_done
    eq rx1451_pos, -1, rx1451_fail
    jump $I10
  rx1451_done:
    rx1451_cur."!cursor_fail"()
    if_null rx1451_debug, debug_1197
    rx1451_cur."!cursor_debug"("FAIL", "infix:sym<->")
  debug_1197:
    .return (rx1451_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<->"  :nsentry("!PREFIX__infix:sym<->") :subid("319_1300146757.646") :method
.annotate 'line', 10
    $P1453 = self."!PREFIX__!subrule"("O", "-")
    new $P1454, "ResizablePMCArray"
    push $P1454, $P1453
    .return ($P1454)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+|>"  :subid("320_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1458_tgt
    .local int rx1458_pos
    .local int rx1458_off
    .local int rx1458_eos
    .local int rx1458_rep
    .local pmc rx1458_cur
    .local pmc rx1458_debug
    (rx1458_cur, rx1458_pos, rx1458_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1458_cur
    .local pmc match
    .lex "$/", match
    length rx1458_eos, rx1458_tgt
    gt rx1458_pos, rx1458_eos, rx1458_done
    set rx1458_off, 0
    lt rx1458_pos, 2, rx1458_start
    sub rx1458_off, rx1458_pos, 1
    substr rx1458_tgt, rx1458_tgt, rx1458_off
  rx1458_start:
    eq $I10, 1, rx1458_restart
    if_null rx1458_debug, debug_1198
    rx1458_cur."!cursor_debug"("START", "infix:sym<+|>")
  debug_1198:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1462_done
    goto rxscan1462_scan
  rxscan1462_loop:
    (rx1458_pos) = rx1458_cur."from"()
    inc rx1458_pos
    rx1458_cur."!cursor_from"(rx1458_pos)
    ge rx1458_pos, rx1458_eos, rxscan1462_done
  rxscan1462_scan:
    set_addr $I10, rxscan1462_loop
    rx1458_cur."!mark_push"(0, rx1458_pos, $I10)
  rxscan1462_done:
.annotate 'line', 645
  # rx subcapture "sym"
    set_addr $I10, rxcap_1463_fail
    rx1458_cur."!mark_push"(0, rx1458_pos, $I10)
  # rx literal  "+|"
    add $I11, rx1458_pos, 2
    gt $I11, rx1458_eos, rx1458_fail
    sub $I11, rx1458_pos, rx1458_off
    substr $S10, rx1458_tgt, $I11, 2
    ne $S10, "+|", rx1458_fail
    add rx1458_pos, 2
    set_addr $I10, rxcap_1463_fail
    ($I12, $I11) = rx1458_cur."!mark_peek"($I10)
    rx1458_cur."!cursor_pos"($I11)
    ($P10) = rx1458_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1458_pos, "")
    rx1458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1463_done
  rxcap_1463_fail:
    goto rx1458_fail
  rxcap_1463_done:
  # rx subrule "O" subtype=capture negate=
    rx1458_cur."!cursor_pos"(rx1458_pos)
    $P10 = rx1458_cur."O"("%additive, :pirop<bor III>")
    unless $P10, rx1458_fail
    rx1458_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1458_pos = $P10."pos"()
  # rx pass
    rx1458_cur."!cursor_pass"(rx1458_pos, "infix:sym<+|>")
    if_null rx1458_debug, debug_1199
    rx1458_cur."!cursor_debug"("PASS", "infix:sym<+|>", " at pos=", rx1458_pos)
  debug_1199:
    .return (rx1458_cur)
  rx1458_restart:
.annotate 'line', 10
    if_null rx1458_debug, debug_1200
    rx1458_cur."!cursor_debug"("NEXT", "infix:sym<+|>")
  debug_1200:
  rx1458_fail:
    (rx1458_rep, rx1458_pos, $I10, $P10) = rx1458_cur."!mark_fail"(0)
    lt rx1458_pos, -1, rx1458_done
    eq rx1458_pos, -1, rx1458_fail
    jump $I10
  rx1458_done:
    rx1458_cur."!cursor_fail"()
    if_null rx1458_debug, debug_1201
    rx1458_cur."!cursor_debug"("FAIL", "infix:sym<+|>")
  debug_1201:
    .return (rx1458_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+|>"  :nsentry("!PREFIX__infix:sym<+|>") :subid("321_1300146757.646") :method
.annotate 'line', 10
    $P1460 = self."!PREFIX__!subrule"("O", "+|")
    new $P1461, "ResizablePMCArray"
    push $P1461, $P1460
    .return ($P1461)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<+^>"  :subid("322_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1465_tgt
    .local int rx1465_pos
    .local int rx1465_off
    .local int rx1465_eos
    .local int rx1465_rep
    .local pmc rx1465_cur
    .local pmc rx1465_debug
    (rx1465_cur, rx1465_pos, rx1465_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1465_cur
    .local pmc match
    .lex "$/", match
    length rx1465_eos, rx1465_tgt
    gt rx1465_pos, rx1465_eos, rx1465_done
    set rx1465_off, 0
    lt rx1465_pos, 2, rx1465_start
    sub rx1465_off, rx1465_pos, 1
    substr rx1465_tgt, rx1465_tgt, rx1465_off
  rx1465_start:
    eq $I10, 1, rx1465_restart
    if_null rx1465_debug, debug_1202
    rx1465_cur."!cursor_debug"("START", "infix:sym<+^>")
  debug_1202:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1469_done
    goto rxscan1469_scan
  rxscan1469_loop:
    (rx1465_pos) = rx1465_cur."from"()
    inc rx1465_pos
    rx1465_cur."!cursor_from"(rx1465_pos)
    ge rx1465_pos, rx1465_eos, rxscan1469_done
  rxscan1469_scan:
    set_addr $I10, rxscan1469_loop
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  rxscan1469_done:
.annotate 'line', 646
  # rx subcapture "sym"
    set_addr $I10, rxcap_1470_fail
    rx1465_cur."!mark_push"(0, rx1465_pos, $I10)
  # rx literal  "+^"
    add $I11, rx1465_pos, 2
    gt $I11, rx1465_eos, rx1465_fail
    sub $I11, rx1465_pos, rx1465_off
    substr $S10, rx1465_tgt, $I11, 2
    ne $S10, "+^", rx1465_fail
    add rx1465_pos, 2
    set_addr $I10, rxcap_1470_fail
    ($I12, $I11) = rx1465_cur."!mark_peek"($I10)
    rx1465_cur."!cursor_pos"($I11)
    ($P10) = rx1465_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1465_pos, "")
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1470_done
  rxcap_1470_fail:
    goto rx1465_fail
  rxcap_1470_done:
  # rx subrule "O" subtype=capture negate=
    rx1465_cur."!cursor_pos"(rx1465_pos)
    $P10 = rx1465_cur."O"("%additive, :pirop<bxor III>")
    unless $P10, rx1465_fail
    rx1465_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1465_pos = $P10."pos"()
  # rx pass
    rx1465_cur."!cursor_pass"(rx1465_pos, "infix:sym<+^>")
    if_null rx1465_debug, debug_1203
    rx1465_cur."!cursor_debug"("PASS", "infix:sym<+^>", " at pos=", rx1465_pos)
  debug_1203:
    .return (rx1465_cur)
  rx1465_restart:
.annotate 'line', 10
    if_null rx1465_debug, debug_1204
    rx1465_cur."!cursor_debug"("NEXT", "infix:sym<+^>")
  debug_1204:
  rx1465_fail:
    (rx1465_rep, rx1465_pos, $I10, $P10) = rx1465_cur."!mark_fail"(0)
    lt rx1465_pos, -1, rx1465_done
    eq rx1465_pos, -1, rx1465_fail
    jump $I10
  rx1465_done:
    rx1465_cur."!cursor_fail"()
    if_null rx1465_debug, debug_1205
    rx1465_cur."!cursor_debug"("FAIL", "infix:sym<+^>")
  debug_1205:
    .return (rx1465_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<+^>"  :nsentry("!PREFIX__infix:sym<+^>") :subid("323_1300146757.646") :method
.annotate 'line', 10
    $P1467 = self."!PREFIX__!subrule"("O", "+^")
    new $P1468, "ResizablePMCArray"
    push $P1468, $P1467
    .return ($P1468)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~>"  :subid("324_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1472_tgt
    .local int rx1472_pos
    .local int rx1472_off
    .local int rx1472_eos
    .local int rx1472_rep
    .local pmc rx1472_cur
    .local pmc rx1472_debug
    (rx1472_cur, rx1472_pos, rx1472_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1472_cur
    .local pmc match
    .lex "$/", match
    length rx1472_eos, rx1472_tgt
    gt rx1472_pos, rx1472_eos, rx1472_done
    set rx1472_off, 0
    lt rx1472_pos, 2, rx1472_start
    sub rx1472_off, rx1472_pos, 1
    substr rx1472_tgt, rx1472_tgt, rx1472_off
  rx1472_start:
    eq $I10, 1, rx1472_restart
    if_null rx1472_debug, debug_1206
    rx1472_cur."!cursor_debug"("START", "infix:sym<~>")
  debug_1206:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1476_done
    goto rxscan1476_scan
  rxscan1476_loop:
    (rx1472_pos) = rx1472_cur."from"()
    inc rx1472_pos
    rx1472_cur."!cursor_from"(rx1472_pos)
    ge rx1472_pos, rx1472_eos, rxscan1476_done
  rxscan1476_scan:
    set_addr $I10, rxscan1476_loop
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  rxscan1476_done:
.annotate 'line', 648
  # rx subcapture "sym"
    set_addr $I10, rxcap_1477_fail
    rx1472_cur."!mark_push"(0, rx1472_pos, $I10)
  # rx literal  "~"
    add $I11, rx1472_pos, 1
    gt $I11, rx1472_eos, rx1472_fail
    sub $I11, rx1472_pos, rx1472_off
    ord $I11, rx1472_tgt, $I11
    ne $I11, 126, rx1472_fail
    add rx1472_pos, 1
    set_addr $I10, rxcap_1477_fail
    ($I12, $I11) = rx1472_cur."!mark_peek"($I10)
    rx1472_cur."!cursor_pos"($I11)
    ($P10) = rx1472_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1472_pos, "")
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1477_done
  rxcap_1477_fail:
    goto rx1472_fail
  rxcap_1477_done:
  # rx subrule "O" subtype=capture negate=
    rx1472_cur."!cursor_pos"(rx1472_pos)
    $P10 = rx1472_cur."O"("%concatenation , :pirop<concat>")
    unless $P10, rx1472_fail
    rx1472_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1472_pos = $P10."pos"()
  # rx pass
    rx1472_cur."!cursor_pass"(rx1472_pos, "infix:sym<~>")
    if_null rx1472_debug, debug_1207
    rx1472_cur."!cursor_debug"("PASS", "infix:sym<~>", " at pos=", rx1472_pos)
  debug_1207:
    .return (rx1472_cur)
  rx1472_restart:
.annotate 'line', 10
    if_null rx1472_debug, debug_1208
    rx1472_cur."!cursor_debug"("NEXT", "infix:sym<~>")
  debug_1208:
  rx1472_fail:
    (rx1472_rep, rx1472_pos, $I10, $P10) = rx1472_cur."!mark_fail"(0)
    lt rx1472_pos, -1, rx1472_done
    eq rx1472_pos, -1, rx1472_fail
    jump $I10
  rx1472_done:
    rx1472_cur."!cursor_fail"()
    if_null rx1472_debug, debug_1209
    rx1472_cur."!cursor_debug"("FAIL", "infix:sym<~>")
  debug_1209:
    .return (rx1472_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~>"  :nsentry("!PREFIX__infix:sym<~>") :subid("325_1300146757.646") :method
.annotate 'line', 10
    $P1474 = self."!PREFIX__!subrule"("O", "~")
    new $P1475, "ResizablePMCArray"
    push $P1475, $P1474
    .return ($P1475)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<==>"  :subid("326_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1479_tgt
    .local int rx1479_pos
    .local int rx1479_off
    .local int rx1479_eos
    .local int rx1479_rep
    .local pmc rx1479_cur
    .local pmc rx1479_debug
    (rx1479_cur, rx1479_pos, rx1479_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1479_cur
    .local pmc match
    .lex "$/", match
    length rx1479_eos, rx1479_tgt
    gt rx1479_pos, rx1479_eos, rx1479_done
    set rx1479_off, 0
    lt rx1479_pos, 2, rx1479_start
    sub rx1479_off, rx1479_pos, 1
    substr rx1479_tgt, rx1479_tgt, rx1479_off
  rx1479_start:
    eq $I10, 1, rx1479_restart
    if_null rx1479_debug, debug_1210
    rx1479_cur."!cursor_debug"("START", "infix:sym<==>")
  debug_1210:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1483_done
    goto rxscan1483_scan
  rxscan1483_loop:
    (rx1479_pos) = rx1479_cur."from"()
    inc rx1479_pos
    rx1479_cur."!cursor_from"(rx1479_pos)
    ge rx1479_pos, rx1479_eos, rxscan1483_done
  rxscan1483_scan:
    set_addr $I10, rxscan1483_loop
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  rxscan1483_done:
.annotate 'line', 650
  # rx subcapture "sym"
    set_addr $I10, rxcap_1484_fail
    rx1479_cur."!mark_push"(0, rx1479_pos, $I10)
  # rx literal  "=="
    add $I11, rx1479_pos, 2
    gt $I11, rx1479_eos, rx1479_fail
    sub $I11, rx1479_pos, rx1479_off
    substr $S10, rx1479_tgt, $I11, 2
    ne $S10, "==", rx1479_fail
    add rx1479_pos, 2
    set_addr $I10, rxcap_1484_fail
    ($I12, $I11) = rx1479_cur."!mark_peek"($I10)
    rx1479_cur."!cursor_pos"($I11)
    ($P10) = rx1479_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1479_pos, "")
    rx1479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1484_done
  rxcap_1484_fail:
    goto rx1479_fail
  rxcap_1484_done:
  # rx subrule "O" subtype=capture negate=
    rx1479_cur."!cursor_pos"(rx1479_pos)
    $P10 = rx1479_cur."O"("%relational, :pirop<iseq INn>")
    unless $P10, rx1479_fail
    rx1479_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1479_pos = $P10."pos"()
  # rx pass
    rx1479_cur."!cursor_pass"(rx1479_pos, "infix:sym<==>")
    if_null rx1479_debug, debug_1211
    rx1479_cur."!cursor_debug"("PASS", "infix:sym<==>", " at pos=", rx1479_pos)
  debug_1211:
    .return (rx1479_cur)
  rx1479_restart:
.annotate 'line', 10
    if_null rx1479_debug, debug_1212
    rx1479_cur."!cursor_debug"("NEXT", "infix:sym<==>")
  debug_1212:
  rx1479_fail:
    (rx1479_rep, rx1479_pos, $I10, $P10) = rx1479_cur."!mark_fail"(0)
    lt rx1479_pos, -1, rx1479_done
    eq rx1479_pos, -1, rx1479_fail
    jump $I10
  rx1479_done:
    rx1479_cur."!cursor_fail"()
    if_null rx1479_debug, debug_1213
    rx1479_cur."!cursor_debug"("FAIL", "infix:sym<==>")
  debug_1213:
    .return (rx1479_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<==>"  :nsentry("!PREFIX__infix:sym<==>") :subid("327_1300146757.646") :method
.annotate 'line', 10
    $P1481 = self."!PREFIX__!subrule"("O", "==")
    new $P1482, "ResizablePMCArray"
    push $P1482, $P1481
    .return ($P1482)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<!=>"  :subid("328_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1486_tgt
    .local int rx1486_pos
    .local int rx1486_off
    .local int rx1486_eos
    .local int rx1486_rep
    .local pmc rx1486_cur
    .local pmc rx1486_debug
    (rx1486_cur, rx1486_pos, rx1486_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1486_cur
    .local pmc match
    .lex "$/", match
    length rx1486_eos, rx1486_tgt
    gt rx1486_pos, rx1486_eos, rx1486_done
    set rx1486_off, 0
    lt rx1486_pos, 2, rx1486_start
    sub rx1486_off, rx1486_pos, 1
    substr rx1486_tgt, rx1486_tgt, rx1486_off
  rx1486_start:
    eq $I10, 1, rx1486_restart
    if_null rx1486_debug, debug_1214
    rx1486_cur."!cursor_debug"("START", "infix:sym<!=>")
  debug_1214:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1490_done
    goto rxscan1490_scan
  rxscan1490_loop:
    (rx1486_pos) = rx1486_cur."from"()
    inc rx1486_pos
    rx1486_cur."!cursor_from"(rx1486_pos)
    ge rx1486_pos, rx1486_eos, rxscan1490_done
  rxscan1490_scan:
    set_addr $I10, rxscan1490_loop
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  rxscan1490_done:
.annotate 'line', 651
  # rx subcapture "sym"
    set_addr $I10, rxcap_1491_fail
    rx1486_cur."!mark_push"(0, rx1486_pos, $I10)
  # rx literal  "!="
    add $I11, rx1486_pos, 2
    gt $I11, rx1486_eos, rx1486_fail
    sub $I11, rx1486_pos, rx1486_off
    substr $S10, rx1486_tgt, $I11, 2
    ne $S10, "!=", rx1486_fail
    add rx1486_pos, 2
    set_addr $I10, rxcap_1491_fail
    ($I12, $I11) = rx1486_cur."!mark_peek"($I10)
    rx1486_cur."!cursor_pos"($I11)
    ($P10) = rx1486_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1486_pos, "")
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1491_done
  rxcap_1491_fail:
    goto rx1486_fail
  rxcap_1491_done:
  # rx subrule "O" subtype=capture negate=
    rx1486_cur."!cursor_pos"(rx1486_pos)
    $P10 = rx1486_cur."O"("%relational, :pirop<isne INn>")
    unless $P10, rx1486_fail
    rx1486_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1486_pos = $P10."pos"()
  # rx pass
    rx1486_cur."!cursor_pass"(rx1486_pos, "infix:sym<!=>")
    if_null rx1486_debug, debug_1215
    rx1486_cur."!cursor_debug"("PASS", "infix:sym<!=>", " at pos=", rx1486_pos)
  debug_1215:
    .return (rx1486_cur)
  rx1486_restart:
.annotate 'line', 10
    if_null rx1486_debug, debug_1216
    rx1486_cur."!cursor_debug"("NEXT", "infix:sym<!=>")
  debug_1216:
  rx1486_fail:
    (rx1486_rep, rx1486_pos, $I10, $P10) = rx1486_cur."!mark_fail"(0)
    lt rx1486_pos, -1, rx1486_done
    eq rx1486_pos, -1, rx1486_fail
    jump $I10
  rx1486_done:
    rx1486_cur."!cursor_fail"()
    if_null rx1486_debug, debug_1217
    rx1486_cur."!cursor_debug"("FAIL", "infix:sym<!=>")
  debug_1217:
    .return (rx1486_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<!=>"  :nsentry("!PREFIX__infix:sym<!=>") :subid("329_1300146757.646") :method
.annotate 'line', 10
    $P1488 = self."!PREFIX__!subrule"("O", "!=")
    new $P1489, "ResizablePMCArray"
    push $P1489, $P1488
    .return ($P1489)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<=>"  :subid("330_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1493_tgt
    .local int rx1493_pos
    .local int rx1493_off
    .local int rx1493_eos
    .local int rx1493_rep
    .local pmc rx1493_cur
    .local pmc rx1493_debug
    (rx1493_cur, rx1493_pos, rx1493_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1493_cur
    .local pmc match
    .lex "$/", match
    length rx1493_eos, rx1493_tgt
    gt rx1493_pos, rx1493_eos, rx1493_done
    set rx1493_off, 0
    lt rx1493_pos, 2, rx1493_start
    sub rx1493_off, rx1493_pos, 1
    substr rx1493_tgt, rx1493_tgt, rx1493_off
  rx1493_start:
    eq $I10, 1, rx1493_restart
    if_null rx1493_debug, debug_1218
    rx1493_cur."!cursor_debug"("START", "infix:sym<<=>")
  debug_1218:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1497_done
    goto rxscan1497_scan
  rxscan1497_loop:
    (rx1493_pos) = rx1493_cur."from"()
    inc rx1493_pos
    rx1493_cur."!cursor_from"(rx1493_pos)
    ge rx1493_pos, rx1493_eos, rxscan1497_done
  rxscan1497_scan:
    set_addr $I10, rxscan1497_loop
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  rxscan1497_done:
.annotate 'line', 652
  # rx subcapture "sym"
    set_addr $I10, rxcap_1498_fail
    rx1493_cur."!mark_push"(0, rx1493_pos, $I10)
  # rx literal  "<="
    add $I11, rx1493_pos, 2
    gt $I11, rx1493_eos, rx1493_fail
    sub $I11, rx1493_pos, rx1493_off
    substr $S10, rx1493_tgt, $I11, 2
    ne $S10, "<=", rx1493_fail
    add rx1493_pos, 2
    set_addr $I10, rxcap_1498_fail
    ($I12, $I11) = rx1493_cur."!mark_peek"($I10)
    rx1493_cur."!cursor_pos"($I11)
    ($P10) = rx1493_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1493_pos, "")
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1498_done
  rxcap_1498_fail:
    goto rx1493_fail
  rxcap_1498_done:
  # rx subrule "O" subtype=capture negate=
    rx1493_cur."!cursor_pos"(rx1493_pos)
    $P10 = rx1493_cur."O"("%relational, :pirop<isle INn>")
    unless $P10, rx1493_fail
    rx1493_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1493_pos = $P10."pos"()
  # rx pass
    rx1493_cur."!cursor_pass"(rx1493_pos, "infix:sym<<=>")
    if_null rx1493_debug, debug_1219
    rx1493_cur."!cursor_debug"("PASS", "infix:sym<<=>", " at pos=", rx1493_pos)
  debug_1219:
    .return (rx1493_cur)
  rx1493_restart:
.annotate 'line', 10
    if_null rx1493_debug, debug_1220
    rx1493_cur."!cursor_debug"("NEXT", "infix:sym<<=>")
  debug_1220:
  rx1493_fail:
    (rx1493_rep, rx1493_pos, $I10, $P10) = rx1493_cur."!mark_fail"(0)
    lt rx1493_pos, -1, rx1493_done
    eq rx1493_pos, -1, rx1493_fail
    jump $I10
  rx1493_done:
    rx1493_cur."!cursor_fail"()
    if_null rx1493_debug, debug_1221
    rx1493_cur."!cursor_debug"("FAIL", "infix:sym<<=>")
  debug_1221:
    .return (rx1493_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<=>"  :nsentry("!PREFIX__infix:sym<<=>") :subid("331_1300146757.646") :method
.annotate 'line', 10
    $P1495 = self."!PREFIX__!subrule"("O", "<=")
    new $P1496, "ResizablePMCArray"
    push $P1496, $P1495
    .return ($P1496)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>=>"  :subid("332_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1500_tgt
    .local int rx1500_pos
    .local int rx1500_off
    .local int rx1500_eos
    .local int rx1500_rep
    .local pmc rx1500_cur
    .local pmc rx1500_debug
    (rx1500_cur, rx1500_pos, rx1500_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1500_cur
    .local pmc match
    .lex "$/", match
    length rx1500_eos, rx1500_tgt
    gt rx1500_pos, rx1500_eos, rx1500_done
    set rx1500_off, 0
    lt rx1500_pos, 2, rx1500_start
    sub rx1500_off, rx1500_pos, 1
    substr rx1500_tgt, rx1500_tgt, rx1500_off
  rx1500_start:
    eq $I10, 1, rx1500_restart
    if_null rx1500_debug, debug_1222
    rx1500_cur."!cursor_debug"("START", "infix:sym<>=>")
  debug_1222:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1504_done
    goto rxscan1504_scan
  rxscan1504_loop:
    (rx1500_pos) = rx1500_cur."from"()
    inc rx1500_pos
    rx1500_cur."!cursor_from"(rx1500_pos)
    ge rx1500_pos, rx1500_eos, rxscan1504_done
  rxscan1504_scan:
    set_addr $I10, rxscan1504_loop
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  rxscan1504_done:
.annotate 'line', 653
  # rx subcapture "sym"
    set_addr $I10, rxcap_1505_fail
    rx1500_cur."!mark_push"(0, rx1500_pos, $I10)
  # rx literal  ">="
    add $I11, rx1500_pos, 2
    gt $I11, rx1500_eos, rx1500_fail
    sub $I11, rx1500_pos, rx1500_off
    substr $S10, rx1500_tgt, $I11, 2
    ne $S10, ">=", rx1500_fail
    add rx1500_pos, 2
    set_addr $I10, rxcap_1505_fail
    ($I12, $I11) = rx1500_cur."!mark_peek"($I10)
    rx1500_cur."!cursor_pos"($I11)
    ($P10) = rx1500_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1500_pos, "")
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1505_done
  rxcap_1505_fail:
    goto rx1500_fail
  rxcap_1505_done:
  # rx subrule "O" subtype=capture negate=
    rx1500_cur."!cursor_pos"(rx1500_pos)
    $P10 = rx1500_cur."O"("%relational, :pirop<isge INn>")
    unless $P10, rx1500_fail
    rx1500_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1500_pos = $P10."pos"()
  # rx pass
    rx1500_cur."!cursor_pass"(rx1500_pos, "infix:sym<>=>")
    if_null rx1500_debug, debug_1223
    rx1500_cur."!cursor_debug"("PASS", "infix:sym<>=>", " at pos=", rx1500_pos)
  debug_1223:
    .return (rx1500_cur)
  rx1500_restart:
.annotate 'line', 10
    if_null rx1500_debug, debug_1224
    rx1500_cur."!cursor_debug"("NEXT", "infix:sym<>=>")
  debug_1224:
  rx1500_fail:
    (rx1500_rep, rx1500_pos, $I10, $P10) = rx1500_cur."!mark_fail"(0)
    lt rx1500_pos, -1, rx1500_done
    eq rx1500_pos, -1, rx1500_fail
    jump $I10
  rx1500_done:
    rx1500_cur."!cursor_fail"()
    if_null rx1500_debug, debug_1225
    rx1500_cur."!cursor_debug"("FAIL", "infix:sym<>=>")
  debug_1225:
    .return (rx1500_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>=>"  :nsentry("!PREFIX__infix:sym<>=>") :subid("333_1300146757.646") :method
.annotate 'line', 10
    $P1502 = self."!PREFIX__!subrule"("O", ">=")
    new $P1503, "ResizablePMCArray"
    push $P1503, $P1502
    .return ($P1503)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<<>"  :subid("334_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1507_tgt
    .local int rx1507_pos
    .local int rx1507_off
    .local int rx1507_eos
    .local int rx1507_rep
    .local pmc rx1507_cur
    .local pmc rx1507_debug
    (rx1507_cur, rx1507_pos, rx1507_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1507_cur
    .local pmc match
    .lex "$/", match
    length rx1507_eos, rx1507_tgt
    gt rx1507_pos, rx1507_eos, rx1507_done
    set rx1507_off, 0
    lt rx1507_pos, 2, rx1507_start
    sub rx1507_off, rx1507_pos, 1
    substr rx1507_tgt, rx1507_tgt, rx1507_off
  rx1507_start:
    eq $I10, 1, rx1507_restart
    if_null rx1507_debug, debug_1226
    rx1507_cur."!cursor_debug"("START", "infix:sym<<>")
  debug_1226:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1511_done
    goto rxscan1511_scan
  rxscan1511_loop:
    (rx1507_pos) = rx1507_cur."from"()
    inc rx1507_pos
    rx1507_cur."!cursor_from"(rx1507_pos)
    ge rx1507_pos, rx1507_eos, rxscan1511_done
  rxscan1511_scan:
    set_addr $I10, rxscan1511_loop
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  rxscan1511_done:
.annotate 'line', 654
  # rx subcapture "sym"
    set_addr $I10, rxcap_1512_fail
    rx1507_cur."!mark_push"(0, rx1507_pos, $I10)
  # rx literal  "<"
    add $I11, rx1507_pos, 1
    gt $I11, rx1507_eos, rx1507_fail
    sub $I11, rx1507_pos, rx1507_off
    ord $I11, rx1507_tgt, $I11
    ne $I11, 60, rx1507_fail
    add rx1507_pos, 1
    set_addr $I10, rxcap_1512_fail
    ($I12, $I11) = rx1507_cur."!mark_peek"($I10)
    rx1507_cur."!cursor_pos"($I11)
    ($P10) = rx1507_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1507_pos, "")
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1512_done
  rxcap_1512_fail:
    goto rx1507_fail
  rxcap_1512_done:
  # rx subrule "O" subtype=capture negate=
    rx1507_cur."!cursor_pos"(rx1507_pos)
    $P10 = rx1507_cur."O"("%relational, :pirop<islt INn>")
    unless $P10, rx1507_fail
    rx1507_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1507_pos = $P10."pos"()
  # rx pass
    rx1507_cur."!cursor_pass"(rx1507_pos, "infix:sym<<>")
    if_null rx1507_debug, debug_1227
    rx1507_cur."!cursor_debug"("PASS", "infix:sym<<>", " at pos=", rx1507_pos)
  debug_1227:
    .return (rx1507_cur)
  rx1507_restart:
.annotate 'line', 10
    if_null rx1507_debug, debug_1228
    rx1507_cur."!cursor_debug"("NEXT", "infix:sym<<>")
  debug_1228:
  rx1507_fail:
    (rx1507_rep, rx1507_pos, $I10, $P10) = rx1507_cur."!mark_fail"(0)
    lt rx1507_pos, -1, rx1507_done
    eq rx1507_pos, -1, rx1507_fail
    jump $I10
  rx1507_done:
    rx1507_cur."!cursor_fail"()
    if_null rx1507_debug, debug_1229
    rx1507_cur."!cursor_debug"("FAIL", "infix:sym<<>")
  debug_1229:
    .return (rx1507_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<<>"  :nsentry("!PREFIX__infix:sym<<>") :subid("335_1300146757.646") :method
.annotate 'line', 10
    $P1509 = self."!PREFIX__!subrule"("O", "<")
    new $P1510, "ResizablePMCArray"
    push $P1510, $P1509
    .return ($P1510)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<>>"  :subid("336_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1514_tgt
    .local int rx1514_pos
    .local int rx1514_off
    .local int rx1514_eos
    .local int rx1514_rep
    .local pmc rx1514_cur
    .local pmc rx1514_debug
    (rx1514_cur, rx1514_pos, rx1514_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1514_cur
    .local pmc match
    .lex "$/", match
    length rx1514_eos, rx1514_tgt
    gt rx1514_pos, rx1514_eos, rx1514_done
    set rx1514_off, 0
    lt rx1514_pos, 2, rx1514_start
    sub rx1514_off, rx1514_pos, 1
    substr rx1514_tgt, rx1514_tgt, rx1514_off
  rx1514_start:
    eq $I10, 1, rx1514_restart
    if_null rx1514_debug, debug_1230
    rx1514_cur."!cursor_debug"("START", "infix:sym<>>")
  debug_1230:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1518_done
    goto rxscan1518_scan
  rxscan1518_loop:
    (rx1514_pos) = rx1514_cur."from"()
    inc rx1514_pos
    rx1514_cur."!cursor_from"(rx1514_pos)
    ge rx1514_pos, rx1514_eos, rxscan1518_done
  rxscan1518_scan:
    set_addr $I10, rxscan1518_loop
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  rxscan1518_done:
.annotate 'line', 655
  # rx subcapture "sym"
    set_addr $I10, rxcap_1519_fail
    rx1514_cur."!mark_push"(0, rx1514_pos, $I10)
  # rx literal  ">"
    add $I11, rx1514_pos, 1
    gt $I11, rx1514_eos, rx1514_fail
    sub $I11, rx1514_pos, rx1514_off
    ord $I11, rx1514_tgt, $I11
    ne $I11, 62, rx1514_fail
    add rx1514_pos, 1
    set_addr $I10, rxcap_1519_fail
    ($I12, $I11) = rx1514_cur."!mark_peek"($I10)
    rx1514_cur."!cursor_pos"($I11)
    ($P10) = rx1514_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1514_pos, "")
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1519_done
  rxcap_1519_fail:
    goto rx1514_fail
  rxcap_1519_done:
  # rx subrule "O" subtype=capture negate=
    rx1514_cur."!cursor_pos"(rx1514_pos)
    $P10 = rx1514_cur."O"("%relational, :pirop<isgt INn>")
    unless $P10, rx1514_fail
    rx1514_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1514_pos = $P10."pos"()
  # rx pass
    rx1514_cur."!cursor_pass"(rx1514_pos, "infix:sym<>>")
    if_null rx1514_debug, debug_1231
    rx1514_cur."!cursor_debug"("PASS", "infix:sym<>>", " at pos=", rx1514_pos)
  debug_1231:
    .return (rx1514_cur)
  rx1514_restart:
.annotate 'line', 10
    if_null rx1514_debug, debug_1232
    rx1514_cur."!cursor_debug"("NEXT", "infix:sym<>>")
  debug_1232:
  rx1514_fail:
    (rx1514_rep, rx1514_pos, $I10, $P10) = rx1514_cur."!mark_fail"(0)
    lt rx1514_pos, -1, rx1514_done
    eq rx1514_pos, -1, rx1514_fail
    jump $I10
  rx1514_done:
    rx1514_cur."!cursor_fail"()
    if_null rx1514_debug, debug_1233
    rx1514_cur."!cursor_debug"("FAIL", "infix:sym<>>")
  debug_1233:
    .return (rx1514_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<>>"  :nsentry("!PREFIX__infix:sym<>>") :subid("337_1300146757.646") :method
.annotate 'line', 10
    $P1516 = self."!PREFIX__!subrule"("O", ">")
    new $P1517, "ResizablePMCArray"
    push $P1517, $P1516
    .return ($P1517)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<eq>"  :subid("338_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1521_tgt
    .local int rx1521_pos
    .local int rx1521_off
    .local int rx1521_eos
    .local int rx1521_rep
    .local pmc rx1521_cur
    .local pmc rx1521_debug
    (rx1521_cur, rx1521_pos, rx1521_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1521_cur
    .local pmc match
    .lex "$/", match
    length rx1521_eos, rx1521_tgt
    gt rx1521_pos, rx1521_eos, rx1521_done
    set rx1521_off, 0
    lt rx1521_pos, 2, rx1521_start
    sub rx1521_off, rx1521_pos, 1
    substr rx1521_tgt, rx1521_tgt, rx1521_off
  rx1521_start:
    eq $I10, 1, rx1521_restart
    if_null rx1521_debug, debug_1234
    rx1521_cur."!cursor_debug"("START", "infix:sym<eq>")
  debug_1234:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1525_done
    goto rxscan1525_scan
  rxscan1525_loop:
    (rx1521_pos) = rx1521_cur."from"()
    inc rx1521_pos
    rx1521_cur."!cursor_from"(rx1521_pos)
    ge rx1521_pos, rx1521_eos, rxscan1525_done
  rxscan1525_scan:
    set_addr $I10, rxscan1525_loop
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  rxscan1525_done:
.annotate 'line', 656
  # rx subcapture "sym"
    set_addr $I10, rxcap_1526_fail
    rx1521_cur."!mark_push"(0, rx1521_pos, $I10)
  # rx literal  "eq"
    add $I11, rx1521_pos, 2
    gt $I11, rx1521_eos, rx1521_fail
    sub $I11, rx1521_pos, rx1521_off
    substr $S10, rx1521_tgt, $I11, 2
    ne $S10, "eq", rx1521_fail
    add rx1521_pos, 2
    set_addr $I10, rxcap_1526_fail
    ($I12, $I11) = rx1521_cur."!mark_peek"($I10)
    rx1521_cur."!cursor_pos"($I11)
    ($P10) = rx1521_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1521_pos, "")
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1526_done
  rxcap_1526_fail:
    goto rx1521_fail
  rxcap_1526_done:
  # rx subrule "O" subtype=capture negate=
    rx1521_cur."!cursor_pos"(rx1521_pos)
    $P10 = rx1521_cur."O"("%relational, :pirop<iseq ISs>")
    unless $P10, rx1521_fail
    rx1521_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1521_pos = $P10."pos"()
  # rx pass
    rx1521_cur."!cursor_pass"(rx1521_pos, "infix:sym<eq>")
    if_null rx1521_debug, debug_1235
    rx1521_cur."!cursor_debug"("PASS", "infix:sym<eq>", " at pos=", rx1521_pos)
  debug_1235:
    .return (rx1521_cur)
  rx1521_restart:
.annotate 'line', 10
    if_null rx1521_debug, debug_1236
    rx1521_cur."!cursor_debug"("NEXT", "infix:sym<eq>")
  debug_1236:
  rx1521_fail:
    (rx1521_rep, rx1521_pos, $I10, $P10) = rx1521_cur."!mark_fail"(0)
    lt rx1521_pos, -1, rx1521_done
    eq rx1521_pos, -1, rx1521_fail
    jump $I10
  rx1521_done:
    rx1521_cur."!cursor_fail"()
    if_null rx1521_debug, debug_1237
    rx1521_cur."!cursor_debug"("FAIL", "infix:sym<eq>")
  debug_1237:
    .return (rx1521_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<eq>"  :nsentry("!PREFIX__infix:sym<eq>") :subid("339_1300146757.646") :method
.annotate 'line', 10
    $P1523 = self."!PREFIX__!subrule"("O", "eq")
    new $P1524, "ResizablePMCArray"
    push $P1524, $P1523
    .return ($P1524)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ne>"  :subid("340_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1528_tgt
    .local int rx1528_pos
    .local int rx1528_off
    .local int rx1528_eos
    .local int rx1528_rep
    .local pmc rx1528_cur
    .local pmc rx1528_debug
    (rx1528_cur, rx1528_pos, rx1528_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1528_cur
    .local pmc match
    .lex "$/", match
    length rx1528_eos, rx1528_tgt
    gt rx1528_pos, rx1528_eos, rx1528_done
    set rx1528_off, 0
    lt rx1528_pos, 2, rx1528_start
    sub rx1528_off, rx1528_pos, 1
    substr rx1528_tgt, rx1528_tgt, rx1528_off
  rx1528_start:
    eq $I10, 1, rx1528_restart
    if_null rx1528_debug, debug_1238
    rx1528_cur."!cursor_debug"("START", "infix:sym<ne>")
  debug_1238:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1532_done
    goto rxscan1532_scan
  rxscan1532_loop:
    (rx1528_pos) = rx1528_cur."from"()
    inc rx1528_pos
    rx1528_cur."!cursor_from"(rx1528_pos)
    ge rx1528_pos, rx1528_eos, rxscan1532_done
  rxscan1532_scan:
    set_addr $I10, rxscan1532_loop
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  rxscan1532_done:
.annotate 'line', 657
  # rx subcapture "sym"
    set_addr $I10, rxcap_1533_fail
    rx1528_cur."!mark_push"(0, rx1528_pos, $I10)
  # rx literal  "ne"
    add $I11, rx1528_pos, 2
    gt $I11, rx1528_eos, rx1528_fail
    sub $I11, rx1528_pos, rx1528_off
    substr $S10, rx1528_tgt, $I11, 2
    ne $S10, "ne", rx1528_fail
    add rx1528_pos, 2
    set_addr $I10, rxcap_1533_fail
    ($I12, $I11) = rx1528_cur."!mark_peek"($I10)
    rx1528_cur."!cursor_pos"($I11)
    ($P10) = rx1528_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1528_pos, "")
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1533_done
  rxcap_1533_fail:
    goto rx1528_fail
  rxcap_1533_done:
  # rx subrule "O" subtype=capture negate=
    rx1528_cur."!cursor_pos"(rx1528_pos)
    $P10 = rx1528_cur."O"("%relational, :pirop<isne ISs>")
    unless $P10, rx1528_fail
    rx1528_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1528_pos = $P10."pos"()
  # rx pass
    rx1528_cur."!cursor_pass"(rx1528_pos, "infix:sym<ne>")
    if_null rx1528_debug, debug_1239
    rx1528_cur."!cursor_debug"("PASS", "infix:sym<ne>", " at pos=", rx1528_pos)
  debug_1239:
    .return (rx1528_cur)
  rx1528_restart:
.annotate 'line', 10
    if_null rx1528_debug, debug_1240
    rx1528_cur."!cursor_debug"("NEXT", "infix:sym<ne>")
  debug_1240:
  rx1528_fail:
    (rx1528_rep, rx1528_pos, $I10, $P10) = rx1528_cur."!mark_fail"(0)
    lt rx1528_pos, -1, rx1528_done
    eq rx1528_pos, -1, rx1528_fail
    jump $I10
  rx1528_done:
    rx1528_cur."!cursor_fail"()
    if_null rx1528_debug, debug_1241
    rx1528_cur."!cursor_debug"("FAIL", "infix:sym<ne>")
  debug_1241:
    .return (rx1528_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ne>"  :nsentry("!PREFIX__infix:sym<ne>") :subid("341_1300146757.646") :method
.annotate 'line', 10
    $P1530 = self."!PREFIX__!subrule"("O", "ne")
    new $P1531, "ResizablePMCArray"
    push $P1531, $P1530
    .return ($P1531)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<le>"  :subid("342_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1535_tgt
    .local int rx1535_pos
    .local int rx1535_off
    .local int rx1535_eos
    .local int rx1535_rep
    .local pmc rx1535_cur
    .local pmc rx1535_debug
    (rx1535_cur, rx1535_pos, rx1535_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1535_cur
    .local pmc match
    .lex "$/", match
    length rx1535_eos, rx1535_tgt
    gt rx1535_pos, rx1535_eos, rx1535_done
    set rx1535_off, 0
    lt rx1535_pos, 2, rx1535_start
    sub rx1535_off, rx1535_pos, 1
    substr rx1535_tgt, rx1535_tgt, rx1535_off
  rx1535_start:
    eq $I10, 1, rx1535_restart
    if_null rx1535_debug, debug_1242
    rx1535_cur."!cursor_debug"("START", "infix:sym<le>")
  debug_1242:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1539_done
    goto rxscan1539_scan
  rxscan1539_loop:
    (rx1535_pos) = rx1535_cur."from"()
    inc rx1535_pos
    rx1535_cur."!cursor_from"(rx1535_pos)
    ge rx1535_pos, rx1535_eos, rxscan1539_done
  rxscan1539_scan:
    set_addr $I10, rxscan1539_loop
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  rxscan1539_done:
.annotate 'line', 658
  # rx subcapture "sym"
    set_addr $I10, rxcap_1540_fail
    rx1535_cur."!mark_push"(0, rx1535_pos, $I10)
  # rx literal  "le"
    add $I11, rx1535_pos, 2
    gt $I11, rx1535_eos, rx1535_fail
    sub $I11, rx1535_pos, rx1535_off
    substr $S10, rx1535_tgt, $I11, 2
    ne $S10, "le", rx1535_fail
    add rx1535_pos, 2
    set_addr $I10, rxcap_1540_fail
    ($I12, $I11) = rx1535_cur."!mark_peek"($I10)
    rx1535_cur."!cursor_pos"($I11)
    ($P10) = rx1535_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1535_pos, "")
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1540_done
  rxcap_1540_fail:
    goto rx1535_fail
  rxcap_1540_done:
  # rx subrule "O" subtype=capture negate=
    rx1535_cur."!cursor_pos"(rx1535_pos)
    $P10 = rx1535_cur."O"("%relational, :pirop<isle ISs>")
    unless $P10, rx1535_fail
    rx1535_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1535_pos = $P10."pos"()
  # rx pass
    rx1535_cur."!cursor_pass"(rx1535_pos, "infix:sym<le>")
    if_null rx1535_debug, debug_1243
    rx1535_cur."!cursor_debug"("PASS", "infix:sym<le>", " at pos=", rx1535_pos)
  debug_1243:
    .return (rx1535_cur)
  rx1535_restart:
.annotate 'line', 10
    if_null rx1535_debug, debug_1244
    rx1535_cur."!cursor_debug"("NEXT", "infix:sym<le>")
  debug_1244:
  rx1535_fail:
    (rx1535_rep, rx1535_pos, $I10, $P10) = rx1535_cur."!mark_fail"(0)
    lt rx1535_pos, -1, rx1535_done
    eq rx1535_pos, -1, rx1535_fail
    jump $I10
  rx1535_done:
    rx1535_cur."!cursor_fail"()
    if_null rx1535_debug, debug_1245
    rx1535_cur."!cursor_debug"("FAIL", "infix:sym<le>")
  debug_1245:
    .return (rx1535_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<le>"  :nsentry("!PREFIX__infix:sym<le>") :subid("343_1300146757.646") :method
.annotate 'line', 10
    $P1537 = self."!PREFIX__!subrule"("O", "le")
    new $P1538, "ResizablePMCArray"
    push $P1538, $P1537
    .return ($P1538)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<ge>"  :subid("344_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1542_tgt
    .local int rx1542_pos
    .local int rx1542_off
    .local int rx1542_eos
    .local int rx1542_rep
    .local pmc rx1542_cur
    .local pmc rx1542_debug
    (rx1542_cur, rx1542_pos, rx1542_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1542_cur
    .local pmc match
    .lex "$/", match
    length rx1542_eos, rx1542_tgt
    gt rx1542_pos, rx1542_eos, rx1542_done
    set rx1542_off, 0
    lt rx1542_pos, 2, rx1542_start
    sub rx1542_off, rx1542_pos, 1
    substr rx1542_tgt, rx1542_tgt, rx1542_off
  rx1542_start:
    eq $I10, 1, rx1542_restart
    if_null rx1542_debug, debug_1246
    rx1542_cur."!cursor_debug"("START", "infix:sym<ge>")
  debug_1246:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1546_done
    goto rxscan1546_scan
  rxscan1546_loop:
    (rx1542_pos) = rx1542_cur."from"()
    inc rx1542_pos
    rx1542_cur."!cursor_from"(rx1542_pos)
    ge rx1542_pos, rx1542_eos, rxscan1546_done
  rxscan1546_scan:
    set_addr $I10, rxscan1546_loop
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  rxscan1546_done:
.annotate 'line', 659
  # rx subcapture "sym"
    set_addr $I10, rxcap_1547_fail
    rx1542_cur."!mark_push"(0, rx1542_pos, $I10)
  # rx literal  "ge"
    add $I11, rx1542_pos, 2
    gt $I11, rx1542_eos, rx1542_fail
    sub $I11, rx1542_pos, rx1542_off
    substr $S10, rx1542_tgt, $I11, 2
    ne $S10, "ge", rx1542_fail
    add rx1542_pos, 2
    set_addr $I10, rxcap_1547_fail
    ($I12, $I11) = rx1542_cur."!mark_peek"($I10)
    rx1542_cur."!cursor_pos"($I11)
    ($P10) = rx1542_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1542_pos, "")
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1547_done
  rxcap_1547_fail:
    goto rx1542_fail
  rxcap_1547_done:
  # rx subrule "O" subtype=capture negate=
    rx1542_cur."!cursor_pos"(rx1542_pos)
    $P10 = rx1542_cur."O"("%relational, :pirop<isge ISs>")
    unless $P10, rx1542_fail
    rx1542_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1542_pos = $P10."pos"()
  # rx pass
    rx1542_cur."!cursor_pass"(rx1542_pos, "infix:sym<ge>")
    if_null rx1542_debug, debug_1247
    rx1542_cur."!cursor_debug"("PASS", "infix:sym<ge>", " at pos=", rx1542_pos)
  debug_1247:
    .return (rx1542_cur)
  rx1542_restart:
.annotate 'line', 10
    if_null rx1542_debug, debug_1248
    rx1542_cur."!cursor_debug"("NEXT", "infix:sym<ge>")
  debug_1248:
  rx1542_fail:
    (rx1542_rep, rx1542_pos, $I10, $P10) = rx1542_cur."!mark_fail"(0)
    lt rx1542_pos, -1, rx1542_done
    eq rx1542_pos, -1, rx1542_fail
    jump $I10
  rx1542_done:
    rx1542_cur."!cursor_fail"()
    if_null rx1542_debug, debug_1249
    rx1542_cur."!cursor_debug"("FAIL", "infix:sym<ge>")
  debug_1249:
    .return (rx1542_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<ge>"  :nsentry("!PREFIX__infix:sym<ge>") :subid("345_1300146757.646") :method
.annotate 'line', 10
    $P1544 = self."!PREFIX__!subrule"("O", "ge")
    new $P1545, "ResizablePMCArray"
    push $P1545, $P1544
    .return ($P1545)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<lt>"  :subid("346_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1549_tgt
    .local int rx1549_pos
    .local int rx1549_off
    .local int rx1549_eos
    .local int rx1549_rep
    .local pmc rx1549_cur
    .local pmc rx1549_debug
    (rx1549_cur, rx1549_pos, rx1549_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1549_cur
    .local pmc match
    .lex "$/", match
    length rx1549_eos, rx1549_tgt
    gt rx1549_pos, rx1549_eos, rx1549_done
    set rx1549_off, 0
    lt rx1549_pos, 2, rx1549_start
    sub rx1549_off, rx1549_pos, 1
    substr rx1549_tgt, rx1549_tgt, rx1549_off
  rx1549_start:
    eq $I10, 1, rx1549_restart
    if_null rx1549_debug, debug_1250
    rx1549_cur."!cursor_debug"("START", "infix:sym<lt>")
  debug_1250:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1553_done
    goto rxscan1553_scan
  rxscan1553_loop:
    (rx1549_pos) = rx1549_cur."from"()
    inc rx1549_pos
    rx1549_cur."!cursor_from"(rx1549_pos)
    ge rx1549_pos, rx1549_eos, rxscan1553_done
  rxscan1553_scan:
    set_addr $I10, rxscan1553_loop
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  rxscan1553_done:
.annotate 'line', 660
  # rx subcapture "sym"
    set_addr $I10, rxcap_1554_fail
    rx1549_cur."!mark_push"(0, rx1549_pos, $I10)
  # rx literal  "lt"
    add $I11, rx1549_pos, 2
    gt $I11, rx1549_eos, rx1549_fail
    sub $I11, rx1549_pos, rx1549_off
    substr $S10, rx1549_tgt, $I11, 2
    ne $S10, "lt", rx1549_fail
    add rx1549_pos, 2
    set_addr $I10, rxcap_1554_fail
    ($I12, $I11) = rx1549_cur."!mark_peek"($I10)
    rx1549_cur."!cursor_pos"($I11)
    ($P10) = rx1549_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1549_pos, "")
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1554_done
  rxcap_1554_fail:
    goto rx1549_fail
  rxcap_1554_done:
  # rx subrule "O" subtype=capture negate=
    rx1549_cur."!cursor_pos"(rx1549_pos)
    $P10 = rx1549_cur."O"("%relational, :pirop<islt ISs>")
    unless $P10, rx1549_fail
    rx1549_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1549_pos = $P10."pos"()
  # rx pass
    rx1549_cur."!cursor_pass"(rx1549_pos, "infix:sym<lt>")
    if_null rx1549_debug, debug_1251
    rx1549_cur."!cursor_debug"("PASS", "infix:sym<lt>", " at pos=", rx1549_pos)
  debug_1251:
    .return (rx1549_cur)
  rx1549_restart:
.annotate 'line', 10
    if_null rx1549_debug, debug_1252
    rx1549_cur."!cursor_debug"("NEXT", "infix:sym<lt>")
  debug_1252:
  rx1549_fail:
    (rx1549_rep, rx1549_pos, $I10, $P10) = rx1549_cur."!mark_fail"(0)
    lt rx1549_pos, -1, rx1549_done
    eq rx1549_pos, -1, rx1549_fail
    jump $I10
  rx1549_done:
    rx1549_cur."!cursor_fail"()
    if_null rx1549_debug, debug_1253
    rx1549_cur."!cursor_debug"("FAIL", "infix:sym<lt>")
  debug_1253:
    .return (rx1549_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<lt>"  :nsentry("!PREFIX__infix:sym<lt>") :subid("347_1300146757.646") :method
.annotate 'line', 10
    $P1551 = self."!PREFIX__!subrule"("O", "lt")
    new $P1552, "ResizablePMCArray"
    push $P1552, $P1551
    .return ($P1552)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<gt>"  :subid("348_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1556_tgt
    .local int rx1556_pos
    .local int rx1556_off
    .local int rx1556_eos
    .local int rx1556_rep
    .local pmc rx1556_cur
    .local pmc rx1556_debug
    (rx1556_cur, rx1556_pos, rx1556_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1556_cur
    .local pmc match
    .lex "$/", match
    length rx1556_eos, rx1556_tgt
    gt rx1556_pos, rx1556_eos, rx1556_done
    set rx1556_off, 0
    lt rx1556_pos, 2, rx1556_start
    sub rx1556_off, rx1556_pos, 1
    substr rx1556_tgt, rx1556_tgt, rx1556_off
  rx1556_start:
    eq $I10, 1, rx1556_restart
    if_null rx1556_debug, debug_1254
    rx1556_cur."!cursor_debug"("START", "infix:sym<gt>")
  debug_1254:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1560_done
    goto rxscan1560_scan
  rxscan1560_loop:
    (rx1556_pos) = rx1556_cur."from"()
    inc rx1556_pos
    rx1556_cur."!cursor_from"(rx1556_pos)
    ge rx1556_pos, rx1556_eos, rxscan1560_done
  rxscan1560_scan:
    set_addr $I10, rxscan1560_loop
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  rxscan1560_done:
.annotate 'line', 661
  # rx subcapture "sym"
    set_addr $I10, rxcap_1561_fail
    rx1556_cur."!mark_push"(0, rx1556_pos, $I10)
  # rx literal  "gt"
    add $I11, rx1556_pos, 2
    gt $I11, rx1556_eos, rx1556_fail
    sub $I11, rx1556_pos, rx1556_off
    substr $S10, rx1556_tgt, $I11, 2
    ne $S10, "gt", rx1556_fail
    add rx1556_pos, 2
    set_addr $I10, rxcap_1561_fail
    ($I12, $I11) = rx1556_cur."!mark_peek"($I10)
    rx1556_cur."!cursor_pos"($I11)
    ($P10) = rx1556_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1556_pos, "")
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1561_done
  rxcap_1561_fail:
    goto rx1556_fail
  rxcap_1561_done:
  # rx subrule "O" subtype=capture negate=
    rx1556_cur."!cursor_pos"(rx1556_pos)
    $P10 = rx1556_cur."O"("%relational, :pirop<isgt ISs>")
    unless $P10, rx1556_fail
    rx1556_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1556_pos = $P10."pos"()
  # rx pass
    rx1556_cur."!cursor_pass"(rx1556_pos, "infix:sym<gt>")
    if_null rx1556_debug, debug_1255
    rx1556_cur."!cursor_debug"("PASS", "infix:sym<gt>", " at pos=", rx1556_pos)
  debug_1255:
    .return (rx1556_cur)
  rx1556_restart:
.annotate 'line', 10
    if_null rx1556_debug, debug_1256
    rx1556_cur."!cursor_debug"("NEXT", "infix:sym<gt>")
  debug_1256:
  rx1556_fail:
    (rx1556_rep, rx1556_pos, $I10, $P10) = rx1556_cur."!mark_fail"(0)
    lt rx1556_pos, -1, rx1556_done
    eq rx1556_pos, -1, rx1556_fail
    jump $I10
  rx1556_done:
    rx1556_cur."!cursor_fail"()
    if_null rx1556_debug, debug_1257
    rx1556_cur."!cursor_debug"("FAIL", "infix:sym<gt>")
  debug_1257:
    .return (rx1556_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<gt>"  :nsentry("!PREFIX__infix:sym<gt>") :subid("349_1300146757.646") :method
.annotate 'line', 10
    $P1558 = self."!PREFIX__!subrule"("O", "gt")
    new $P1559, "ResizablePMCArray"
    push $P1559, $P1558
    .return ($P1559)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=:=>"  :subid("350_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1563_tgt
    .local int rx1563_pos
    .local int rx1563_off
    .local int rx1563_eos
    .local int rx1563_rep
    .local pmc rx1563_cur
    .local pmc rx1563_debug
    (rx1563_cur, rx1563_pos, rx1563_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1563_cur
    .local pmc match
    .lex "$/", match
    length rx1563_eos, rx1563_tgt
    gt rx1563_pos, rx1563_eos, rx1563_done
    set rx1563_off, 0
    lt rx1563_pos, 2, rx1563_start
    sub rx1563_off, rx1563_pos, 1
    substr rx1563_tgt, rx1563_tgt, rx1563_off
  rx1563_start:
    eq $I10, 1, rx1563_restart
    if_null rx1563_debug, debug_1258
    rx1563_cur."!cursor_debug"("START", "infix:sym<=:=>")
  debug_1258:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1567_done
    goto rxscan1567_scan
  rxscan1567_loop:
    (rx1563_pos) = rx1563_cur."from"()
    inc rx1563_pos
    rx1563_cur."!cursor_from"(rx1563_pos)
    ge rx1563_pos, rx1563_eos, rxscan1567_done
  rxscan1567_scan:
    set_addr $I10, rxscan1567_loop
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  rxscan1567_done:
.annotate 'line', 662
  # rx subcapture "sym"
    set_addr $I10, rxcap_1568_fail
    rx1563_cur."!mark_push"(0, rx1563_pos, $I10)
  # rx literal  "=:="
    add $I11, rx1563_pos, 3
    gt $I11, rx1563_eos, rx1563_fail
    sub $I11, rx1563_pos, rx1563_off
    substr $S10, rx1563_tgt, $I11, 3
    ne $S10, "=:=", rx1563_fail
    add rx1563_pos, 3
    set_addr $I10, rxcap_1568_fail
    ($I12, $I11) = rx1563_cur."!mark_peek"($I10)
    rx1563_cur."!cursor_pos"($I11)
    ($P10) = rx1563_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1563_pos, "")
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1568_done
  rxcap_1568_fail:
    goto rx1563_fail
  rxcap_1568_done:
  # rx subrule "O" subtype=capture negate=
    rx1563_cur."!cursor_pos"(rx1563_pos)
    $P10 = rx1563_cur."O"("%relational, :pirop<issame>")
    unless $P10, rx1563_fail
    rx1563_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1563_pos = $P10."pos"()
  # rx pass
    rx1563_cur."!cursor_pass"(rx1563_pos, "infix:sym<=:=>")
    if_null rx1563_debug, debug_1259
    rx1563_cur."!cursor_debug"("PASS", "infix:sym<=:=>", " at pos=", rx1563_pos)
  debug_1259:
    .return (rx1563_cur)
  rx1563_restart:
.annotate 'line', 10
    if_null rx1563_debug, debug_1260
    rx1563_cur."!cursor_debug"("NEXT", "infix:sym<=:=>")
  debug_1260:
  rx1563_fail:
    (rx1563_rep, rx1563_pos, $I10, $P10) = rx1563_cur."!mark_fail"(0)
    lt rx1563_pos, -1, rx1563_done
    eq rx1563_pos, -1, rx1563_fail
    jump $I10
  rx1563_done:
    rx1563_cur."!cursor_fail"()
    if_null rx1563_debug, debug_1261
    rx1563_cur."!cursor_debug"("FAIL", "infix:sym<=:=>")
  debug_1261:
    .return (rx1563_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=:=>"  :nsentry("!PREFIX__infix:sym<=:=>") :subid("351_1300146757.646") :method
.annotate 'line', 10
    $P1565 = self."!PREFIX__!subrule"("O", "=:=")
    new $P1566, "ResizablePMCArray"
    push $P1566, $P1565
    .return ($P1566)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<~~>"  :subid("352_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1570_tgt
    .local int rx1570_pos
    .local int rx1570_off
    .local int rx1570_eos
    .local int rx1570_rep
    .local pmc rx1570_cur
    .local pmc rx1570_debug
    (rx1570_cur, rx1570_pos, rx1570_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1570_cur
    .local pmc match
    .lex "$/", match
    length rx1570_eos, rx1570_tgt
    gt rx1570_pos, rx1570_eos, rx1570_done
    set rx1570_off, 0
    lt rx1570_pos, 2, rx1570_start
    sub rx1570_off, rx1570_pos, 1
    substr rx1570_tgt, rx1570_tgt, rx1570_off
  rx1570_start:
    eq $I10, 1, rx1570_restart
    if_null rx1570_debug, debug_1262
    rx1570_cur."!cursor_debug"("START", "infix:sym<~~>")
  debug_1262:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1574_done
    goto rxscan1574_scan
  rxscan1574_loop:
    (rx1570_pos) = rx1570_cur."from"()
    inc rx1570_pos
    rx1570_cur."!cursor_from"(rx1570_pos)
    ge rx1570_pos, rx1570_eos, rxscan1574_done
  rxscan1574_scan:
    set_addr $I10, rxscan1574_loop
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  rxscan1574_done:
.annotate 'line', 663
  # rx subcapture "sym"
    set_addr $I10, rxcap_1575_fail
    rx1570_cur."!mark_push"(0, rx1570_pos, $I10)
  # rx literal  "~~"
    add $I11, rx1570_pos, 2
    gt $I11, rx1570_eos, rx1570_fail
    sub $I11, rx1570_pos, rx1570_off
    substr $S10, rx1570_tgt, $I11, 2
    ne $S10, "~~", rx1570_fail
    add rx1570_pos, 2
    set_addr $I10, rxcap_1575_fail
    ($I12, $I11) = rx1570_cur."!mark_peek"($I10)
    rx1570_cur."!cursor_pos"($I11)
    ($P10) = rx1570_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1570_pos, "")
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1575_done
  rxcap_1575_fail:
    goto rx1570_fail
  rxcap_1575_done:
  # rx subrule "O" subtype=capture negate=
    rx1570_cur."!cursor_pos"(rx1570_pos)
    $P10 = rx1570_cur."O"("%relational, :reducecheck<smartmatch>")
    unless $P10, rx1570_fail
    rx1570_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1570_pos = $P10."pos"()
  # rx pass
    rx1570_cur."!cursor_pass"(rx1570_pos, "infix:sym<~~>")
    if_null rx1570_debug, debug_1263
    rx1570_cur."!cursor_debug"("PASS", "infix:sym<~~>", " at pos=", rx1570_pos)
  debug_1263:
    .return (rx1570_cur)
  rx1570_restart:
.annotate 'line', 10
    if_null rx1570_debug, debug_1264
    rx1570_cur."!cursor_debug"("NEXT", "infix:sym<~~>")
  debug_1264:
  rx1570_fail:
    (rx1570_rep, rx1570_pos, $I10, $P10) = rx1570_cur."!mark_fail"(0)
    lt rx1570_pos, -1, rx1570_done
    eq rx1570_pos, -1, rx1570_fail
    jump $I10
  rx1570_done:
    rx1570_cur."!cursor_fail"()
    if_null rx1570_debug, debug_1265
    rx1570_cur."!cursor_debug"("FAIL", "infix:sym<~~>")
  debug_1265:
    .return (rx1570_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<~~>"  :nsentry("!PREFIX__infix:sym<~~>") :subid("353_1300146757.646") :method
.annotate 'line', 10
    $P1572 = self."!PREFIX__!subrule"("O", "~~")
    new $P1573, "ResizablePMCArray"
    push $P1573, $P1572
    .return ($P1573)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<&&>"  :subid("354_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1577_tgt
    .local int rx1577_pos
    .local int rx1577_off
    .local int rx1577_eos
    .local int rx1577_rep
    .local pmc rx1577_cur
    .local pmc rx1577_debug
    (rx1577_cur, rx1577_pos, rx1577_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1577_cur
    .local pmc match
    .lex "$/", match
    length rx1577_eos, rx1577_tgt
    gt rx1577_pos, rx1577_eos, rx1577_done
    set rx1577_off, 0
    lt rx1577_pos, 2, rx1577_start
    sub rx1577_off, rx1577_pos, 1
    substr rx1577_tgt, rx1577_tgt, rx1577_off
  rx1577_start:
    eq $I10, 1, rx1577_restart
    if_null rx1577_debug, debug_1266
    rx1577_cur."!cursor_debug"("START", "infix:sym<&&>")
  debug_1266:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1581_done
    goto rxscan1581_scan
  rxscan1581_loop:
    (rx1577_pos) = rx1577_cur."from"()
    inc rx1577_pos
    rx1577_cur."!cursor_from"(rx1577_pos)
    ge rx1577_pos, rx1577_eos, rxscan1581_done
  rxscan1581_scan:
    set_addr $I10, rxscan1581_loop
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  rxscan1581_done:
.annotate 'line', 665
  # rx subcapture "sym"
    set_addr $I10, rxcap_1582_fail
    rx1577_cur."!mark_push"(0, rx1577_pos, $I10)
  # rx literal  "&&"
    add $I11, rx1577_pos, 2
    gt $I11, rx1577_eos, rx1577_fail
    sub $I11, rx1577_pos, rx1577_off
    substr $S10, rx1577_tgt, $I11, 2
    ne $S10, "&&", rx1577_fail
    add rx1577_pos, 2
    set_addr $I10, rxcap_1582_fail
    ($I12, $I11) = rx1577_cur."!mark_peek"($I10)
    rx1577_cur."!cursor_pos"($I11)
    ($P10) = rx1577_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1577_pos, "")
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1582_done
  rxcap_1582_fail:
    goto rx1577_fail
  rxcap_1582_done:
  # rx subrule "O" subtype=capture negate=
    rx1577_cur."!cursor_pos"(rx1577_pos)
    $P10 = rx1577_cur."O"("%tight_and, :pasttype<if>")
    unless $P10, rx1577_fail
    rx1577_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1577_pos = $P10."pos"()
  # rx pass
    rx1577_cur."!cursor_pass"(rx1577_pos, "infix:sym<&&>")
    if_null rx1577_debug, debug_1267
    rx1577_cur."!cursor_debug"("PASS", "infix:sym<&&>", " at pos=", rx1577_pos)
  debug_1267:
    .return (rx1577_cur)
  rx1577_restart:
.annotate 'line', 10
    if_null rx1577_debug, debug_1268
    rx1577_cur."!cursor_debug"("NEXT", "infix:sym<&&>")
  debug_1268:
  rx1577_fail:
    (rx1577_rep, rx1577_pos, $I10, $P10) = rx1577_cur."!mark_fail"(0)
    lt rx1577_pos, -1, rx1577_done
    eq rx1577_pos, -1, rx1577_fail
    jump $I10
  rx1577_done:
    rx1577_cur."!cursor_fail"()
    if_null rx1577_debug, debug_1269
    rx1577_cur."!cursor_debug"("FAIL", "infix:sym<&&>")
  debug_1269:
    .return (rx1577_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<&&>"  :nsentry("!PREFIX__infix:sym<&&>") :subid("355_1300146757.646") :method
.annotate 'line', 10
    $P1579 = self."!PREFIX__!subrule"("O", "&&")
    new $P1580, "ResizablePMCArray"
    push $P1580, $P1579
    .return ($P1580)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<||>"  :subid("356_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1584_tgt
    .local int rx1584_pos
    .local int rx1584_off
    .local int rx1584_eos
    .local int rx1584_rep
    .local pmc rx1584_cur
    .local pmc rx1584_debug
    (rx1584_cur, rx1584_pos, rx1584_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1584_cur
    .local pmc match
    .lex "$/", match
    length rx1584_eos, rx1584_tgt
    gt rx1584_pos, rx1584_eos, rx1584_done
    set rx1584_off, 0
    lt rx1584_pos, 2, rx1584_start
    sub rx1584_off, rx1584_pos, 1
    substr rx1584_tgt, rx1584_tgt, rx1584_off
  rx1584_start:
    eq $I10, 1, rx1584_restart
    if_null rx1584_debug, debug_1270
    rx1584_cur."!cursor_debug"("START", "infix:sym<||>")
  debug_1270:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1588_done
    goto rxscan1588_scan
  rxscan1588_loop:
    (rx1584_pos) = rx1584_cur."from"()
    inc rx1584_pos
    rx1584_cur."!cursor_from"(rx1584_pos)
    ge rx1584_pos, rx1584_eos, rxscan1588_done
  rxscan1588_scan:
    set_addr $I10, rxscan1588_loop
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  rxscan1588_done:
.annotate 'line', 667
  # rx subcapture "sym"
    set_addr $I10, rxcap_1589_fail
    rx1584_cur."!mark_push"(0, rx1584_pos, $I10)
  # rx literal  "||"
    add $I11, rx1584_pos, 2
    gt $I11, rx1584_eos, rx1584_fail
    sub $I11, rx1584_pos, rx1584_off
    substr $S10, rx1584_tgt, $I11, 2
    ne $S10, "||", rx1584_fail
    add rx1584_pos, 2
    set_addr $I10, rxcap_1589_fail
    ($I12, $I11) = rx1584_cur."!mark_peek"($I10)
    rx1584_cur."!cursor_pos"($I11)
    ($P10) = rx1584_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1584_pos, "")
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1589_done
  rxcap_1589_fail:
    goto rx1584_fail
  rxcap_1589_done:
  # rx subrule "O" subtype=capture negate=
    rx1584_cur."!cursor_pos"(rx1584_pos)
    $P10 = rx1584_cur."O"("%tight_or, :pasttype<unless>")
    unless $P10, rx1584_fail
    rx1584_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1584_pos = $P10."pos"()
  # rx pass
    rx1584_cur."!cursor_pass"(rx1584_pos, "infix:sym<||>")
    if_null rx1584_debug, debug_1271
    rx1584_cur."!cursor_debug"("PASS", "infix:sym<||>", " at pos=", rx1584_pos)
  debug_1271:
    .return (rx1584_cur)
  rx1584_restart:
.annotate 'line', 10
    if_null rx1584_debug, debug_1272
    rx1584_cur."!cursor_debug"("NEXT", "infix:sym<||>")
  debug_1272:
  rx1584_fail:
    (rx1584_rep, rx1584_pos, $I10, $P10) = rx1584_cur."!mark_fail"(0)
    lt rx1584_pos, -1, rx1584_done
    eq rx1584_pos, -1, rx1584_fail
    jump $I10
  rx1584_done:
    rx1584_cur."!cursor_fail"()
    if_null rx1584_debug, debug_1273
    rx1584_cur."!cursor_debug"("FAIL", "infix:sym<||>")
  debug_1273:
    .return (rx1584_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<||>"  :nsentry("!PREFIX__infix:sym<||>") :subid("357_1300146757.646") :method
.annotate 'line', 10
    $P1586 = self."!PREFIX__!subrule"("O", "||")
    new $P1587, "ResizablePMCArray"
    push $P1587, $P1586
    .return ($P1587)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<//>"  :subid("358_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1591_tgt
    .local int rx1591_pos
    .local int rx1591_off
    .local int rx1591_eos
    .local int rx1591_rep
    .local pmc rx1591_cur
    .local pmc rx1591_debug
    (rx1591_cur, rx1591_pos, rx1591_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1591_cur
    .local pmc match
    .lex "$/", match
    length rx1591_eos, rx1591_tgt
    gt rx1591_pos, rx1591_eos, rx1591_done
    set rx1591_off, 0
    lt rx1591_pos, 2, rx1591_start
    sub rx1591_off, rx1591_pos, 1
    substr rx1591_tgt, rx1591_tgt, rx1591_off
  rx1591_start:
    eq $I10, 1, rx1591_restart
    if_null rx1591_debug, debug_1274
    rx1591_cur."!cursor_debug"("START", "infix:sym<//>")
  debug_1274:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1595_done
    goto rxscan1595_scan
  rxscan1595_loop:
    (rx1591_pos) = rx1591_cur."from"()
    inc rx1591_pos
    rx1591_cur."!cursor_from"(rx1591_pos)
    ge rx1591_pos, rx1591_eos, rxscan1595_done
  rxscan1595_scan:
    set_addr $I10, rxscan1595_loop
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  rxscan1595_done:
.annotate 'line', 668
  # rx subcapture "sym"
    set_addr $I10, rxcap_1596_fail
    rx1591_cur."!mark_push"(0, rx1591_pos, $I10)
  # rx literal  "//"
    add $I11, rx1591_pos, 2
    gt $I11, rx1591_eos, rx1591_fail
    sub $I11, rx1591_pos, rx1591_off
    substr $S10, rx1591_tgt, $I11, 2
    ne $S10, "//", rx1591_fail
    add rx1591_pos, 2
    set_addr $I10, rxcap_1596_fail
    ($I12, $I11) = rx1591_cur."!mark_peek"($I10)
    rx1591_cur."!cursor_pos"($I11)
    ($P10) = rx1591_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1591_pos, "")
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1596_done
  rxcap_1596_fail:
    goto rx1591_fail
  rxcap_1596_done:
  # rx subrule "O" subtype=capture negate=
    rx1591_cur."!cursor_pos"(rx1591_pos)
    $P10 = rx1591_cur."O"("%tight_or, :pasttype<def_or>")
    unless $P10, rx1591_fail
    rx1591_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1591_pos = $P10."pos"()
  # rx pass
    rx1591_cur."!cursor_pass"(rx1591_pos, "infix:sym<//>")
    if_null rx1591_debug, debug_1275
    rx1591_cur."!cursor_debug"("PASS", "infix:sym<//>", " at pos=", rx1591_pos)
  debug_1275:
    .return (rx1591_cur)
  rx1591_restart:
.annotate 'line', 10
    if_null rx1591_debug, debug_1276
    rx1591_cur."!cursor_debug"("NEXT", "infix:sym<//>")
  debug_1276:
  rx1591_fail:
    (rx1591_rep, rx1591_pos, $I10, $P10) = rx1591_cur."!mark_fail"(0)
    lt rx1591_pos, -1, rx1591_done
    eq rx1591_pos, -1, rx1591_fail
    jump $I10
  rx1591_done:
    rx1591_cur."!cursor_fail"()
    if_null rx1591_debug, debug_1277
    rx1591_cur."!cursor_debug"("FAIL", "infix:sym<//>")
  debug_1277:
    .return (rx1591_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<//>"  :nsentry("!PREFIX__infix:sym<//>") :subid("359_1300146757.646") :method
.annotate 'line', 10
    $P1593 = self."!PREFIX__!subrule"("O", "//")
    new $P1594, "ResizablePMCArray"
    push $P1594, $P1593
    .return ($P1594)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<?? !!>"  :subid("360_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1598_tgt
    .local int rx1598_pos
    .local int rx1598_off
    .local int rx1598_eos
    .local int rx1598_rep
    .local pmc rx1598_cur
    .local pmc rx1598_debug
    (rx1598_cur, rx1598_pos, rx1598_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1598_cur
    .local pmc match
    .lex "$/", match
    length rx1598_eos, rx1598_tgt
    gt rx1598_pos, rx1598_eos, rx1598_done
    set rx1598_off, 0
    lt rx1598_pos, 2, rx1598_start
    sub rx1598_off, rx1598_pos, 1
    substr rx1598_tgt, rx1598_tgt, rx1598_off
  rx1598_start:
    eq $I10, 1, rx1598_restart
    if_null rx1598_debug, debug_1278
    rx1598_cur."!cursor_debug"("START", "infix:sym<?? !!>")
  debug_1278:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1602_done
    goto rxscan1602_scan
  rxscan1602_loop:
    (rx1598_pos) = rx1598_cur."from"()
    inc rx1598_pos
    rx1598_cur."!cursor_from"(rx1598_pos)
    ge rx1598_pos, rx1598_eos, rxscan1602_done
  rxscan1602_scan:
    set_addr $I10, rxscan1602_loop
    rx1598_cur."!mark_push"(0, rx1598_pos, $I10)
  rxscan1602_done:
.annotate 'line', 671
  # rx literal  "??"
    add $I11, rx1598_pos, 2
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I11, 2
    ne $S10, "??", rx1598_fail
    add rx1598_pos, 2
.annotate 'line', 672
  # rx subrule "ws" subtype=method negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."ws"()
    unless $P10, rx1598_fail
    rx1598_pos = $P10."pos"()
.annotate 'line', 673
  # rx subrule "EXPR" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."EXPR"("i=")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("EXPR")
    rx1598_pos = $P10."pos"()
.annotate 'line', 674
  # rx literal  "!!"
    add $I11, rx1598_pos, 2
    gt $I11, rx1598_eos, rx1598_fail
    sub $I11, rx1598_pos, rx1598_off
    substr $S10, rx1598_tgt, $I11, 2
    ne $S10, "!!", rx1598_fail
    add rx1598_pos, 2
.annotate 'line', 675
  # rx subrule "O" subtype=capture negate=
    rx1598_cur."!cursor_pos"(rx1598_pos)
    $P10 = rx1598_cur."O"("%conditional, :reducecheck<ternary>, :pasttype<if>")
    unless $P10, rx1598_fail
    rx1598_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1598_pos = $P10."pos"()
.annotate 'line', 670
  # rx pass
    rx1598_cur."!cursor_pass"(rx1598_pos, "infix:sym<?? !!>")
    if_null rx1598_debug, debug_1279
    rx1598_cur."!cursor_debug"("PASS", "infix:sym<?? !!>", " at pos=", rx1598_pos)
  debug_1279:
    .return (rx1598_cur)
  rx1598_restart:
.annotate 'line', 10
    if_null rx1598_debug, debug_1280
    rx1598_cur."!cursor_debug"("NEXT", "infix:sym<?? !!>")
  debug_1280:
  rx1598_fail:
    (rx1598_rep, rx1598_pos, $I10, $P10) = rx1598_cur."!mark_fail"(0)
    lt rx1598_pos, -1, rx1598_done
    eq rx1598_pos, -1, rx1598_fail
    jump $I10
  rx1598_done:
    rx1598_cur."!cursor_fail"()
    if_null rx1598_debug, debug_1281
    rx1598_cur."!cursor_debug"("FAIL", "infix:sym<?? !!>")
  debug_1281:
    .return (rx1598_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<?? !!>"  :nsentry("!PREFIX__infix:sym<?? !!>") :subid("361_1300146757.646") :method
.annotate 'line', 10
    $P1600 = self."!PREFIX__!subrule"("ws", "??")
    new $P1601, "ResizablePMCArray"
    push $P1601, $P1600
    .return ($P1601)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<=>"  :subid("362_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1604_tgt
    .local int rx1604_pos
    .local int rx1604_off
    .local int rx1604_eos
    .local int rx1604_rep
    .local pmc rx1604_cur
    .local pmc rx1604_debug
    (rx1604_cur, rx1604_pos, rx1604_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1604_cur
    .local pmc match
    .lex "$/", match
    length rx1604_eos, rx1604_tgt
    gt rx1604_pos, rx1604_eos, rx1604_done
    set rx1604_off, 0
    lt rx1604_pos, 2, rx1604_start
    sub rx1604_off, rx1604_pos, 1
    substr rx1604_tgt, rx1604_tgt, rx1604_off
  rx1604_start:
    eq $I10, 1, rx1604_restart
    if_null rx1604_debug, debug_1282
    rx1604_cur."!cursor_debug"("START", "infix:sym<=>")
  debug_1282:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1608_done
    goto rxscan1608_scan
  rxscan1608_loop:
    (rx1604_pos) = rx1604_cur."from"()
    inc rx1604_pos
    rx1604_cur."!cursor_from"(rx1604_pos)
    ge rx1604_pos, rx1604_eos, rxscan1608_done
  rxscan1608_scan:
    set_addr $I10, rxscan1608_loop
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  rxscan1608_done:
.annotate 'line', 679
  # rx subcapture "sym"
    set_addr $I10, rxcap_1609_fail
    rx1604_cur."!mark_push"(0, rx1604_pos, $I10)
  # rx literal  "="
    add $I11, rx1604_pos, 1
    gt $I11, rx1604_eos, rx1604_fail
    sub $I11, rx1604_pos, rx1604_off
    ord $I11, rx1604_tgt, $I11
    ne $I11, 61, rx1604_fail
    add rx1604_pos, 1
    set_addr $I10, rxcap_1609_fail
    ($I12, $I11) = rx1604_cur."!mark_peek"($I10)
    rx1604_cur."!cursor_pos"($I11)
    ($P10) = rx1604_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1604_pos, "")
    rx1604_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1609_done
  rxcap_1609_fail:
    goto rx1604_fail
  rxcap_1609_done:
  # rx subrule "panic" subtype=method negate=
    rx1604_cur."!cursor_pos"(rx1604_pos)
    $P10 = rx1604_cur."panic"("Assignment (\"=\") not supported in NQP, use \":=\" instead")
    unless $P10, rx1604_fail
    rx1604_pos = $P10."pos"()
.annotate 'line', 678
  # rx pass
    rx1604_cur."!cursor_pass"(rx1604_pos, "infix:sym<=>")
    if_null rx1604_debug, debug_1283
    rx1604_cur."!cursor_debug"("PASS", "infix:sym<=>", " at pos=", rx1604_pos)
  debug_1283:
    .return (rx1604_cur)
  rx1604_restart:
.annotate 'line', 10
    if_null rx1604_debug, debug_1284
    rx1604_cur."!cursor_debug"("NEXT", "infix:sym<=>")
  debug_1284:
  rx1604_fail:
    (rx1604_rep, rx1604_pos, $I10, $P10) = rx1604_cur."!mark_fail"(0)
    lt rx1604_pos, -1, rx1604_done
    eq rx1604_pos, -1, rx1604_fail
    jump $I10
  rx1604_done:
    rx1604_cur."!cursor_fail"()
    if_null rx1604_debug, debug_1285
    rx1604_cur."!cursor_debug"("FAIL", "infix:sym<=>")
  debug_1285:
    .return (rx1604_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<=>"  :nsentry("!PREFIX__infix:sym<=>") :subid("363_1300146757.646") :method
.annotate 'line', 10
    $P1606 = self."!PREFIX__!subrule"("panic", "=")
    new $P1607, "ResizablePMCArray"
    push $P1607, $P1606
    .return ($P1607)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<:=>"  :subid("364_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1611_tgt
    .local int rx1611_pos
    .local int rx1611_off
    .local int rx1611_eos
    .local int rx1611_rep
    .local pmc rx1611_cur
    .local pmc rx1611_debug
    (rx1611_cur, rx1611_pos, rx1611_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1611_cur
    .local pmc match
    .lex "$/", match
    length rx1611_eos, rx1611_tgt
    gt rx1611_pos, rx1611_eos, rx1611_done
    set rx1611_off, 0
    lt rx1611_pos, 2, rx1611_start
    sub rx1611_off, rx1611_pos, 1
    substr rx1611_tgt, rx1611_tgt, rx1611_off
  rx1611_start:
    eq $I10, 1, rx1611_restart
    if_null rx1611_debug, debug_1286
    rx1611_cur."!cursor_debug"("START", "infix:sym<:=>")
  debug_1286:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1615_done
    goto rxscan1615_scan
  rxscan1615_loop:
    (rx1611_pos) = rx1611_cur."from"()
    inc rx1611_pos
    rx1611_cur."!cursor_from"(rx1611_pos)
    ge rx1611_pos, rx1611_eos, rxscan1615_done
  rxscan1615_scan:
    set_addr $I10, rxscan1615_loop
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  rxscan1615_done:
.annotate 'line', 681
  # rx subcapture "sym"
    set_addr $I10, rxcap_1616_fail
    rx1611_cur."!mark_push"(0, rx1611_pos, $I10)
  # rx literal  ":="
    add $I11, rx1611_pos, 2
    gt $I11, rx1611_eos, rx1611_fail
    sub $I11, rx1611_pos, rx1611_off
    substr $S10, rx1611_tgt, $I11, 2
    ne $S10, ":=", rx1611_fail
    add rx1611_pos, 2
    set_addr $I10, rxcap_1616_fail
    ($I12, $I11) = rx1611_cur."!mark_peek"($I10)
    rx1611_cur."!cursor_pos"($I11)
    ($P10) = rx1611_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1611_pos, "")
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1616_done
  rxcap_1616_fail:
    goto rx1611_fail
  rxcap_1616_done:
  # rx subrule "O" subtype=capture negate=
    rx1611_cur."!cursor_pos"(rx1611_pos)
    $P10 = rx1611_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1611_fail
    rx1611_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1611_pos = $P10."pos"()
  # rx pass
    rx1611_cur."!cursor_pass"(rx1611_pos, "infix:sym<:=>")
    if_null rx1611_debug, debug_1287
    rx1611_cur."!cursor_debug"("PASS", "infix:sym<:=>", " at pos=", rx1611_pos)
  debug_1287:
    .return (rx1611_cur)
  rx1611_restart:
.annotate 'line', 10
    if_null rx1611_debug, debug_1288
    rx1611_cur."!cursor_debug"("NEXT", "infix:sym<:=>")
  debug_1288:
  rx1611_fail:
    (rx1611_rep, rx1611_pos, $I10, $P10) = rx1611_cur."!mark_fail"(0)
    lt rx1611_pos, -1, rx1611_done
    eq rx1611_pos, -1, rx1611_fail
    jump $I10
  rx1611_done:
    rx1611_cur."!cursor_fail"()
    if_null rx1611_debug, debug_1289
    rx1611_cur."!cursor_debug"("FAIL", "infix:sym<:=>")
  debug_1289:
    .return (rx1611_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<:=>"  :nsentry("!PREFIX__infix:sym<:=>") :subid("365_1300146757.646") :method
.annotate 'line', 10
    $P1613 = self."!PREFIX__!subrule"("O", ":=")
    new $P1614, "ResizablePMCArray"
    push $P1614, $P1613
    .return ($P1614)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<::=>"  :subid("366_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1618_tgt
    .local int rx1618_pos
    .local int rx1618_off
    .local int rx1618_eos
    .local int rx1618_rep
    .local pmc rx1618_cur
    .local pmc rx1618_debug
    (rx1618_cur, rx1618_pos, rx1618_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1618_cur
    .local pmc match
    .lex "$/", match
    length rx1618_eos, rx1618_tgt
    gt rx1618_pos, rx1618_eos, rx1618_done
    set rx1618_off, 0
    lt rx1618_pos, 2, rx1618_start
    sub rx1618_off, rx1618_pos, 1
    substr rx1618_tgt, rx1618_tgt, rx1618_off
  rx1618_start:
    eq $I10, 1, rx1618_restart
    if_null rx1618_debug, debug_1290
    rx1618_cur."!cursor_debug"("START", "infix:sym<::=>")
  debug_1290:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1622_done
    goto rxscan1622_scan
  rxscan1622_loop:
    (rx1618_pos) = rx1618_cur."from"()
    inc rx1618_pos
    rx1618_cur."!cursor_from"(rx1618_pos)
    ge rx1618_pos, rx1618_eos, rxscan1622_done
  rxscan1622_scan:
    set_addr $I10, rxscan1622_loop
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  rxscan1622_done:
.annotate 'line', 682
  # rx subcapture "sym"
    set_addr $I10, rxcap_1623_fail
    rx1618_cur."!mark_push"(0, rx1618_pos, $I10)
  # rx literal  "::="
    add $I11, rx1618_pos, 3
    gt $I11, rx1618_eos, rx1618_fail
    sub $I11, rx1618_pos, rx1618_off
    substr $S10, rx1618_tgt, $I11, 3
    ne $S10, "::=", rx1618_fail
    add rx1618_pos, 3
    set_addr $I10, rxcap_1623_fail
    ($I12, $I11) = rx1618_cur."!mark_peek"($I10)
    rx1618_cur."!cursor_pos"($I11)
    ($P10) = rx1618_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1618_pos, "")
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1623_done
  rxcap_1623_fail:
    goto rx1618_fail
  rxcap_1623_done:
  # rx subrule "O" subtype=capture negate=
    rx1618_cur."!cursor_pos"(rx1618_pos)
    $P10 = rx1618_cur."O"("%assignment, :pasttype<bind>")
    unless $P10, rx1618_fail
    rx1618_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1618_pos = $P10."pos"()
  # rx pass
    rx1618_cur."!cursor_pass"(rx1618_pos, "infix:sym<::=>")
    if_null rx1618_debug, debug_1291
    rx1618_cur."!cursor_debug"("PASS", "infix:sym<::=>", " at pos=", rx1618_pos)
  debug_1291:
    .return (rx1618_cur)
  rx1618_restart:
.annotate 'line', 10
    if_null rx1618_debug, debug_1292
    rx1618_cur."!cursor_debug"("NEXT", "infix:sym<::=>")
  debug_1292:
  rx1618_fail:
    (rx1618_rep, rx1618_pos, $I10, $P10) = rx1618_cur."!mark_fail"(0)
    lt rx1618_pos, -1, rx1618_done
    eq rx1618_pos, -1, rx1618_fail
    jump $I10
  rx1618_done:
    rx1618_cur."!cursor_fail"()
    if_null rx1618_debug, debug_1293
    rx1618_cur."!cursor_debug"("FAIL", "infix:sym<::=>")
  debug_1293:
    .return (rx1618_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<::=>"  :nsentry("!PREFIX__infix:sym<::=>") :subid("367_1300146757.646") :method
.annotate 'line', 10
    $P1620 = self."!PREFIX__!subrule"("O", "::=")
    new $P1621, "ResizablePMCArray"
    push $P1621, $P1620
    .return ($P1621)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "infix:sym<,>"  :subid("368_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1625_tgt
    .local int rx1625_pos
    .local int rx1625_off
    .local int rx1625_eos
    .local int rx1625_rep
    .local pmc rx1625_cur
    .local pmc rx1625_debug
    (rx1625_cur, rx1625_pos, rx1625_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1625_cur
    .local pmc match
    .lex "$/", match
    length rx1625_eos, rx1625_tgt
    gt rx1625_pos, rx1625_eos, rx1625_done
    set rx1625_off, 0
    lt rx1625_pos, 2, rx1625_start
    sub rx1625_off, rx1625_pos, 1
    substr rx1625_tgt, rx1625_tgt, rx1625_off
  rx1625_start:
    eq $I10, 1, rx1625_restart
    if_null rx1625_debug, debug_1294
    rx1625_cur."!cursor_debug"("START", "infix:sym<,>")
  debug_1294:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1629_done
    goto rxscan1629_scan
  rxscan1629_loop:
    (rx1625_pos) = rx1625_cur."from"()
    inc rx1625_pos
    rx1625_cur."!cursor_from"(rx1625_pos)
    ge rx1625_pos, rx1625_eos, rxscan1629_done
  rxscan1629_scan:
    set_addr $I10, rxscan1629_loop
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  rxscan1629_done:
.annotate 'line', 684
  # rx subcapture "sym"
    set_addr $I10, rxcap_1630_fail
    rx1625_cur."!mark_push"(0, rx1625_pos, $I10)
  # rx literal  ","
    add $I11, rx1625_pos, 1
    gt $I11, rx1625_eos, rx1625_fail
    sub $I11, rx1625_pos, rx1625_off
    ord $I11, rx1625_tgt, $I11
    ne $I11, 44, rx1625_fail
    add rx1625_pos, 1
    set_addr $I10, rxcap_1630_fail
    ($I12, $I11) = rx1625_cur."!mark_peek"($I10)
    rx1625_cur."!cursor_pos"($I11)
    ($P10) = rx1625_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1625_pos, "")
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1630_done
  rxcap_1630_fail:
    goto rx1625_fail
  rxcap_1630_done:
  # rx subrule "O" subtype=capture negate=
    rx1625_cur."!cursor_pos"(rx1625_pos)
    $P10 = rx1625_cur."O"("%comma, :pasttype<list>")
    unless $P10, rx1625_fail
    rx1625_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1625_pos = $P10."pos"()
  # rx pass
    rx1625_cur."!cursor_pass"(rx1625_pos, "infix:sym<,>")
    if_null rx1625_debug, debug_1295
    rx1625_cur."!cursor_debug"("PASS", "infix:sym<,>", " at pos=", rx1625_pos)
  debug_1295:
    .return (rx1625_cur)
  rx1625_restart:
.annotate 'line', 10
    if_null rx1625_debug, debug_1296
    rx1625_cur."!cursor_debug"("NEXT", "infix:sym<,>")
  debug_1296:
  rx1625_fail:
    (rx1625_rep, rx1625_pos, $I10, $P10) = rx1625_cur."!mark_fail"(0)
    lt rx1625_pos, -1, rx1625_done
    eq rx1625_pos, -1, rx1625_fail
    jump $I10
  rx1625_done:
    rx1625_cur."!cursor_fail"()
    if_null rx1625_debug, debug_1297
    rx1625_cur."!cursor_debug"("FAIL", "infix:sym<,>")
  debug_1297:
    .return (rx1625_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__infix:sym<,>"  :nsentry("!PREFIX__infix:sym<,>") :subid("369_1300146757.646") :method
.annotate 'line', 10
    $P1627 = self."!PREFIX__!subrule"("O", ",")
    new $P1628, "ResizablePMCArray"
    push $P1628, $P1627
    .return ($P1628)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<return>"  :subid("370_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .const 'Sub' $P1640 = "372_1300146757.646" 
    capture_lex $P1640
    .local string rx1632_tgt
    .local int rx1632_pos
    .local int rx1632_off
    .local int rx1632_eos
    .local int rx1632_rep
    .local pmc rx1632_cur
    .local pmc rx1632_debug
    (rx1632_cur, rx1632_pos, rx1632_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1632_cur
    .local pmc match
    .lex "$/", match
    length rx1632_eos, rx1632_tgt
    gt rx1632_pos, rx1632_eos, rx1632_done
    set rx1632_off, 0
    lt rx1632_pos, 2, rx1632_start
    sub rx1632_off, rx1632_pos, 1
    substr rx1632_tgt, rx1632_tgt, rx1632_off
  rx1632_start:
    eq $I10, 1, rx1632_restart
    if_null rx1632_debug, debug_1298
    rx1632_cur."!cursor_debug"("START", "prefix:sym<return>")
  debug_1298:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1635_done
    goto rxscan1635_scan
  rxscan1635_loop:
    (rx1632_pos) = rx1632_cur."from"()
    inc rx1632_pos
    rx1632_cur."!cursor_from"(rx1632_pos)
    ge rx1632_pos, rx1632_eos, rxscan1635_done
  rxscan1635_scan:
    set_addr $I10, rxscan1635_loop
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  rxscan1635_done:
.annotate 'line', 686
  # rx subcapture "sym"
    set_addr $I10, rxcap_1636_fail
    rx1632_cur."!mark_push"(0, rx1632_pos, $I10)
  # rx literal  "return"
    add $I11, rx1632_pos, 6
    gt $I11, rx1632_eos, rx1632_fail
    sub $I11, rx1632_pos, rx1632_off
    substr $S10, rx1632_tgt, $I11, 6
    ne $S10, "return", rx1632_fail
    add rx1632_pos, 6
    set_addr $I10, rxcap_1636_fail
    ($I12, $I11) = rx1632_cur."!mark_peek"($I10)
    rx1632_cur."!cursor_pos"($I11)
    ($P10) = rx1632_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1632_pos, "")
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1636_done
  rxcap_1636_fail:
    goto rx1632_fail
  rxcap_1636_done:
  # rx charclass s
    ge rx1632_pos, rx1632_eos, rx1632_fail
    sub $I10, rx1632_pos, rx1632_off
    is_cclass $I11, 32, rx1632_tgt, $I10
    unless $I11, rx1632_fail
    inc rx1632_pos
  # rx subrule "O" subtype=capture negate=
    rx1632_cur."!cursor_pos"(rx1632_pos)
    $P10 = rx1632_cur."O"("%list_prefix, :pasttype<return>")
    unless $P10, rx1632_fail
    rx1632_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1632_pos = $P10."pos"()
    rx1632_cur."!cursor_pos"(rx1632_pos)
    find_lex $P1637, unicode:"$\x{a2}"
    $P1638 = $P1637."MATCH"()
    store_lex "$/", $P1638
    .const 'Sub' $P1640 = "372_1300146757.646" 
    capture_lex $P1640
    $P1642 = $P1640()
  # rx pass
    rx1632_cur."!cursor_pass"(rx1632_pos, "prefix:sym<return>")
    if_null rx1632_debug, debug_1299
    rx1632_cur."!cursor_debug"("PASS", "prefix:sym<return>", " at pos=", rx1632_pos)
  debug_1299:
    .return (rx1632_cur)
  rx1632_restart:
.annotate 'line', 10
    if_null rx1632_debug, debug_1300
    rx1632_cur."!cursor_debug"("NEXT", "prefix:sym<return>")
  debug_1300:
  rx1632_fail:
    (rx1632_rep, rx1632_pos, $I10, $P10) = rx1632_cur."!mark_fail"(0)
    lt rx1632_pos, -1, rx1632_done
    eq rx1632_pos, -1, rx1632_fail
    jump $I10
  rx1632_done:
    rx1632_cur."!cursor_fail"()
    if_null rx1632_debug, debug_1301
    rx1632_cur."!cursor_debug"("FAIL", "prefix:sym<return>")
  debug_1301:
    .return (rx1632_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<return>"  :nsentry("!PREFIX__prefix:sym<return>") :subid("371_1300146757.646") :method
.annotate 'line', 10
    new $P1634, "ResizablePMCArray"
    push $P1634, "return"
    .return ($P1634)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "_block1639"  :anon :subid("372_1300146757.646") :outer("370_1300146757.646")
.annotate 'line', 686
    new $P1641, "Integer"
    assign $P1641, 1
    store_dynamic_lex "$*RETURN_USED", $P1641
    .return ($P1641)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "prefix:sym<make>"  :subid("373_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1644_tgt
    .local int rx1644_pos
    .local int rx1644_off
    .local int rx1644_eos
    .local int rx1644_rep
    .local pmc rx1644_cur
    .local pmc rx1644_debug
    (rx1644_cur, rx1644_pos, rx1644_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1644_cur
    .local pmc match
    .lex "$/", match
    length rx1644_eos, rx1644_tgt
    gt rx1644_pos, rx1644_eos, rx1644_done
    set rx1644_off, 0
    lt rx1644_pos, 2, rx1644_start
    sub rx1644_off, rx1644_pos, 1
    substr rx1644_tgt, rx1644_tgt, rx1644_off
  rx1644_start:
    eq $I10, 1, rx1644_restart
    if_null rx1644_debug, debug_1302
    rx1644_cur."!cursor_debug"("START", "prefix:sym<make>")
  debug_1302:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1647_done
    goto rxscan1647_scan
  rxscan1647_loop:
    (rx1644_pos) = rx1644_cur."from"()
    inc rx1644_pos
    rx1644_cur."!cursor_from"(rx1644_pos)
    ge rx1644_pos, rx1644_eos, rxscan1647_done
  rxscan1647_scan:
    set_addr $I10, rxscan1647_loop
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  rxscan1647_done:
.annotate 'line', 687
  # rx subcapture "sym"
    set_addr $I10, rxcap_1648_fail
    rx1644_cur."!mark_push"(0, rx1644_pos, $I10)
  # rx literal  "make"
    add $I11, rx1644_pos, 4
    gt $I11, rx1644_eos, rx1644_fail
    sub $I11, rx1644_pos, rx1644_off
    substr $S10, rx1644_tgt, $I11, 4
    ne $S10, "make", rx1644_fail
    add rx1644_pos, 4
    set_addr $I10, rxcap_1648_fail
    ($I12, $I11) = rx1644_cur."!mark_peek"($I10)
    rx1644_cur."!cursor_pos"($I11)
    ($P10) = rx1644_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1644_pos, "")
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1648_done
  rxcap_1648_fail:
    goto rx1644_fail
  rxcap_1648_done:
  # rx charclass s
    ge rx1644_pos, rx1644_eos, rx1644_fail
    sub $I10, rx1644_pos, rx1644_off
    is_cclass $I11, 32, rx1644_tgt, $I10
    unless $I11, rx1644_fail
    inc rx1644_pos
  # rx subrule "O" subtype=capture negate=
    rx1644_cur."!cursor_pos"(rx1644_pos)
    $P10 = rx1644_cur."O"("%list_prefix")
    unless $P10, rx1644_fail
    rx1644_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("O")
    rx1644_pos = $P10."pos"()
  # rx pass
    rx1644_cur."!cursor_pass"(rx1644_pos, "prefix:sym<make>")
    if_null rx1644_debug, debug_1303
    rx1644_cur."!cursor_debug"("PASS", "prefix:sym<make>", " at pos=", rx1644_pos)
  debug_1303:
    .return (rx1644_cur)
  rx1644_restart:
.annotate 'line', 10
    if_null rx1644_debug, debug_1304
    rx1644_cur."!cursor_debug"("NEXT", "prefix:sym<make>")
  debug_1304:
  rx1644_fail:
    (rx1644_rep, rx1644_pos, $I10, $P10) = rx1644_cur."!mark_fail"(0)
    lt rx1644_pos, -1, rx1644_done
    eq rx1644_pos, -1, rx1644_fail
    jump $I10
  rx1644_done:
    rx1644_cur."!cursor_fail"()
    if_null rx1644_debug, debug_1305
    rx1644_cur."!cursor_debug"("FAIL", "prefix:sym<make>")
  debug_1305:
    .return (rx1644_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__prefix:sym<make>"  :nsentry("!PREFIX__prefix:sym<make>") :subid("374_1300146757.646") :method
.annotate 'line', 10
    new $P1646, "ResizablePMCArray"
    push $P1646, "make"
    .return ($P1646)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<last>"  :subid("375_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1650_tgt
    .local int rx1650_pos
    .local int rx1650_off
    .local int rx1650_eos
    .local int rx1650_rep
    .local pmc rx1650_cur
    .local pmc rx1650_debug
    (rx1650_cur, rx1650_pos, rx1650_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1650_cur
    .local pmc match
    .lex "$/", match
    length rx1650_eos, rx1650_tgt
    gt rx1650_pos, rx1650_eos, rx1650_done
    set rx1650_off, 0
    lt rx1650_pos, 2, rx1650_start
    sub rx1650_off, rx1650_pos, 1
    substr rx1650_tgt, rx1650_tgt, rx1650_off
  rx1650_start:
    eq $I10, 1, rx1650_restart
    if_null rx1650_debug, debug_1306
    rx1650_cur."!cursor_debug"("START", "term:sym<last>")
  debug_1306:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1653_done
    goto rxscan1653_scan
  rxscan1653_loop:
    (rx1650_pos) = rx1650_cur."from"()
    inc rx1650_pos
    rx1650_cur."!cursor_from"(rx1650_pos)
    ge rx1650_pos, rx1650_eos, rxscan1653_done
  rxscan1653_scan:
    set_addr $I10, rxscan1653_loop
    rx1650_cur."!mark_push"(0, rx1650_pos, $I10)
  rxscan1653_done:
.annotate 'line', 688
  # rx subcapture "sym"
    set_addr $I10, rxcap_1654_fail
    rx1650_cur."!mark_push"(0, rx1650_pos, $I10)
  # rx literal  "last"
    add $I11, rx1650_pos, 4
    gt $I11, rx1650_eos, rx1650_fail
    sub $I11, rx1650_pos, rx1650_off
    substr $S10, rx1650_tgt, $I11, 4
    ne $S10, "last", rx1650_fail
    add rx1650_pos, 4
    set_addr $I10, rxcap_1654_fail
    ($I12, $I11) = rx1650_cur."!mark_peek"($I10)
    rx1650_cur."!cursor_pos"($I11)
    ($P10) = rx1650_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1650_pos, "")
    rx1650_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1654_done
  rxcap_1654_fail:
    goto rx1650_fail
  rxcap_1654_done:
  # rx pass
    rx1650_cur."!cursor_pass"(rx1650_pos, "term:sym<last>")
    if_null rx1650_debug, debug_1307
    rx1650_cur."!cursor_debug"("PASS", "term:sym<last>", " at pos=", rx1650_pos)
  debug_1307:
    .return (rx1650_cur)
  rx1650_restart:
.annotate 'line', 10
    if_null rx1650_debug, debug_1308
    rx1650_cur."!cursor_debug"("NEXT", "term:sym<last>")
  debug_1308:
  rx1650_fail:
    (rx1650_rep, rx1650_pos, $I10, $P10) = rx1650_cur."!mark_fail"(0)
    lt rx1650_pos, -1, rx1650_done
    eq rx1650_pos, -1, rx1650_fail
    jump $I10
  rx1650_done:
    rx1650_cur."!cursor_fail"()
    if_null rx1650_debug, debug_1309
    rx1650_cur."!cursor_debug"("FAIL", "term:sym<last>")
  debug_1309:
    .return (rx1650_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<last>"  :nsentry("!PREFIX__term:sym<last>") :subid("376_1300146757.646") :method
.annotate 'line', 10
    new $P1652, "ResizablePMCArray"
    push $P1652, "last"
    .return ($P1652)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<next>"  :subid("377_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1656_tgt
    .local int rx1656_pos
    .local int rx1656_off
    .local int rx1656_eos
    .local int rx1656_rep
    .local pmc rx1656_cur
    .local pmc rx1656_debug
    (rx1656_cur, rx1656_pos, rx1656_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1656_cur
    .local pmc match
    .lex "$/", match
    length rx1656_eos, rx1656_tgt
    gt rx1656_pos, rx1656_eos, rx1656_done
    set rx1656_off, 0
    lt rx1656_pos, 2, rx1656_start
    sub rx1656_off, rx1656_pos, 1
    substr rx1656_tgt, rx1656_tgt, rx1656_off
  rx1656_start:
    eq $I10, 1, rx1656_restart
    if_null rx1656_debug, debug_1310
    rx1656_cur."!cursor_debug"("START", "term:sym<next>")
  debug_1310:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1659_done
    goto rxscan1659_scan
  rxscan1659_loop:
    (rx1656_pos) = rx1656_cur."from"()
    inc rx1656_pos
    rx1656_cur."!cursor_from"(rx1656_pos)
    ge rx1656_pos, rx1656_eos, rxscan1659_done
  rxscan1659_scan:
    set_addr $I10, rxscan1659_loop
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  rxscan1659_done:
.annotate 'line', 689
  # rx subcapture "sym"
    set_addr $I10, rxcap_1660_fail
    rx1656_cur."!mark_push"(0, rx1656_pos, $I10)
  # rx literal  "next"
    add $I11, rx1656_pos, 4
    gt $I11, rx1656_eos, rx1656_fail
    sub $I11, rx1656_pos, rx1656_off
    substr $S10, rx1656_tgt, $I11, 4
    ne $S10, "next", rx1656_fail
    add rx1656_pos, 4
    set_addr $I10, rxcap_1660_fail
    ($I12, $I11) = rx1656_cur."!mark_peek"($I10)
    rx1656_cur."!cursor_pos"($I11)
    ($P10) = rx1656_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1656_pos, "")
    rx1656_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1660_done
  rxcap_1660_fail:
    goto rx1656_fail
  rxcap_1660_done:
  # rx pass
    rx1656_cur."!cursor_pass"(rx1656_pos, "term:sym<next>")
    if_null rx1656_debug, debug_1311
    rx1656_cur."!cursor_debug"("PASS", "term:sym<next>", " at pos=", rx1656_pos)
  debug_1311:
    .return (rx1656_cur)
  rx1656_restart:
.annotate 'line', 10
    if_null rx1656_debug, debug_1312
    rx1656_cur."!cursor_debug"("NEXT", "term:sym<next>")
  debug_1312:
  rx1656_fail:
    (rx1656_rep, rx1656_pos, $I10, $P10) = rx1656_cur."!mark_fail"(0)
    lt rx1656_pos, -1, rx1656_done
    eq rx1656_pos, -1, rx1656_fail
    jump $I10
  rx1656_done:
    rx1656_cur."!cursor_fail"()
    if_null rx1656_debug, debug_1313
    rx1656_cur."!cursor_debug"("FAIL", "term:sym<next>")
  debug_1313:
    .return (rx1656_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<next>"  :nsentry("!PREFIX__term:sym<next>") :subid("378_1300146757.646") :method
.annotate 'line', 10
    new $P1658, "ResizablePMCArray"
    push $P1658, "next"
    .return ($P1658)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "term:sym<redo>"  :subid("379_1300146757.646") :method :outer("12_1300146757.646")
.annotate 'line', 10
    .local string rx1662_tgt
    .local int rx1662_pos
    .local int rx1662_off
    .local int rx1662_eos
    .local int rx1662_rep
    .local pmc rx1662_cur
    .local pmc rx1662_debug
    (rx1662_cur, rx1662_pos, rx1662_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx1662_cur
    .local pmc match
    .lex "$/", match
    length rx1662_eos, rx1662_tgt
    gt rx1662_pos, rx1662_eos, rx1662_done
    set rx1662_off, 0
    lt rx1662_pos, 2, rx1662_start
    sub rx1662_off, rx1662_pos, 1
    substr rx1662_tgt, rx1662_tgt, rx1662_off
  rx1662_start:
    eq $I10, 1, rx1662_restart
    if_null rx1662_debug, debug_1314
    rx1662_cur."!cursor_debug"("START", "term:sym<redo>")
  debug_1314:
    $I10 = self.'from'()
    ne $I10, -1, rxscan1665_done
    goto rxscan1665_scan
  rxscan1665_loop:
    (rx1662_pos) = rx1662_cur."from"()
    inc rx1662_pos
    rx1662_cur."!cursor_from"(rx1662_pos)
    ge rx1662_pos, rx1662_eos, rxscan1665_done
  rxscan1665_scan:
    set_addr $I10, rxscan1665_loop
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  rxscan1665_done:
.annotate 'line', 690
  # rx subcapture "sym"
    set_addr $I10, rxcap_1666_fail
    rx1662_cur."!mark_push"(0, rx1662_pos, $I10)
  # rx literal  "redo"
    add $I11, rx1662_pos, 4
    gt $I11, rx1662_eos, rx1662_fail
    sub $I11, rx1662_pos, rx1662_off
    substr $S10, rx1662_tgt, $I11, 4
    ne $S10, "redo", rx1662_fail
    add rx1662_pos, 4
    set_addr $I10, rxcap_1666_fail
    ($I12, $I11) = rx1662_cur."!mark_peek"($I10)
    rx1662_cur."!cursor_pos"($I11)
    ($P10) = rx1662_cur."!cursor_start"()
    $P10."!cursor_pass"(rx1662_pos, "")
    rx1662_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("sym")
    goto rxcap_1666_done
  rxcap_1666_fail:
    goto rx1662_fail
  rxcap_1666_done:
  # rx pass
    rx1662_cur."!cursor_pass"(rx1662_pos, "term:sym<redo>")
    if_null rx1662_debug, debug_1315
    rx1662_cur."!cursor_debug"("PASS", "term:sym<redo>", " at pos=", rx1662_pos)
  debug_1315:
    .return (rx1662_cur)
  rx1662_restart:
.annotate 'line', 10
    if_null rx1662_debug, debug_1316
    rx1662_cur."!cursor_debug"("NEXT", "term:sym<redo>")
  debug_1316:
  rx1662_fail:
    (rx1662_rep, rx1662_pos, $I10, $P10) = rx1662_cur."!mark_fail"(0)
    lt rx1662_pos, -1, rx1662_done
    eq rx1662_pos, -1, rx1662_fail
    jump $I10
  rx1662_done:
    rx1662_cur."!cursor_fail"()
    if_null rx1662_debug, debug_1317
    rx1662_cur."!cursor_debug"("FAIL", "term:sym<redo>")
  debug_1317:
    .return (rx1662_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "!PREFIX__term:sym<redo>"  :nsentry("!PREFIX__term:sym<redo>") :subid("380_1300146757.646") :method
.annotate 'line', 10
    new $P1664, "ResizablePMCArray"
    push $P1664, "redo"
    .return ($P1664)
.end


.HLL "nqp"

.namespace ["NQP";"Grammar"]
.sub "smartmatch"  :subid("381_1300146757.646") :outer("12_1300146757.646")
    .param pmc param_1668
    .param pmc param_1669
.annotate 'line', 692
    .lex "self", param_1668
    .lex "$/", param_1669
.annotate 'line', 694
    new $P1670, "Undef"
    .lex "$t", $P1670
    find_lex $P1671, "$/"
    unless_null $P1671, vivify_1318
    $P1671 = root_new ['parrot';'ResizablePMCArray']
  vivify_1318:
    set $P1672, $P1671[0]
    unless_null $P1672, vivify_1319
    new $P1672, "Undef"
  vivify_1319:
    store_lex "$t", $P1672
    find_lex $P1673, "$/"
    unless_null $P1673, vivify_1320
    $P1673 = root_new ['parrot';'ResizablePMCArray']
  vivify_1320:
    set $P1674, $P1673[1]
    unless_null $P1674, vivify_1321
    new $P1674, "Undef"
  vivify_1321:
    find_lex $P1675, "$/"
    unless_null $P1675, vivify_1322
    $P1675 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1675
  vivify_1322:
    set $P1675[0], $P1674
    find_lex $P1676, "$t"
    find_lex $P1677, "$/"
    unless_null $P1677, vivify_1323
    $P1677 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$/", $P1677
  vivify_1323:
    set $P1677[1], $P1676
.annotate 'line', 692
    .return ($P1676)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2398"  :subid("383_1300146757.646") :outer("10_1300146757.646")
.annotate 'line', 698
    .const 'Sub' $P2463 = "404_1300146757.646" 
    capture_lex $P2463
    .const 'Sub' $P2456 = "402_1300146757.646" 
    capture_lex $P2456
    .const 'Sub' $P2451 = "400_1300146757.646" 
    capture_lex $P2451
    .const 'Sub' $P2439 = "397_1300146757.646" 
    capture_lex $P2439
    .const 'Sub' $P2429 = "394_1300146757.646" 
    capture_lex $P2429
    .const 'Sub' $P2424 = "392_1300146757.646" 
    capture_lex $P2424
    .const 'Sub' $P2415 = "389_1300146757.646" 
    capture_lex $P2415
    .const 'Sub' $P2410 = "387_1300146757.646" 
    capture_lex $P2410
    .const 'Sub' $P2401 = "384_1300146757.646" 
    capture_lex $P2401
    get_global $P2400, "$?CLASS"
    .const 'Sub' $P2456 = "402_1300146757.646" 
    capture_lex $P2456
    .return ($P2456)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "" :load :init :subid("post1324") :outer("383_1300146757.646")
.annotate 'line', 698
    get_hll_global $P2399, ["NQP";"Regex"], "_block2398" 
    .local pmc block
    set block, $P2399
    .const 'Sub' $P2463 = "404_1300146757.646" 
    capture_lex $P2463
    $P2463()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2462"  :anon :subid("404_1300146757.646") :outer("383_1300146757.646")
.annotate 'line', 698
    nqp_get_sc_object $P2464, "1300146737.899", 1
    .local pmc type_obj
    set type_obj, $P2464
    set_global "$?CLASS", type_obj
    get_how $P2465, type_obj
    .const 'Sub' $P2466 = "384_1300146757.646" 
    $P2465."add_method"(type_obj, "metachar:sym<:my>", $P2466)
    get_how $P2467, type_obj
    get_global $P2468, "!PREFIX__metachar:sym<:my>"
    $P2467."add_method"(type_obj, "!PREFIX__metachar:sym<:my>", $P2468)
    get_how $P2469, type_obj
    .const 'Sub' $P2470 = "387_1300146757.646" 
    $P2469."add_method"(type_obj, "metachar:sym<{ }>", $P2470)
    get_how $P2471, type_obj
    get_global $P2472, "!PREFIX__metachar:sym<{ }>"
    $P2471."add_method"(type_obj, "!PREFIX__metachar:sym<{ }>", $P2472)
    get_how $P2473, type_obj
    .const 'Sub' $P2474 = "389_1300146757.646" 
    $P2473."add_method"(type_obj, "metachar:sym<nqpvar>", $P2474)
    get_how $P2475, type_obj
    get_global $P2476, "!PREFIX__metachar:sym<nqpvar>"
    $P2475."add_method"(type_obj, "!PREFIX__metachar:sym<nqpvar>", $P2476)
    get_how $P2477, type_obj
    .const 'Sub' $P2478 = "392_1300146757.646" 
    $P2477."add_method"(type_obj, "assertion:sym<{ }>", $P2478)
    get_how $P2479, type_obj
    get_global $P2480, "!PREFIX__assertion:sym<{ }>"
    $P2479."add_method"(type_obj, "!PREFIX__assertion:sym<{ }>", $P2480)
    get_how $P2481, type_obj
    .const 'Sub' $P2482 = "394_1300146757.646" 
    $P2481."add_method"(type_obj, "assertion:sym<?{ }>", $P2482)
    get_how $P2483, type_obj
    get_global $P2484, "!PREFIX__assertion:sym<?{ }>"
    $P2483."add_method"(type_obj, "!PREFIX__assertion:sym<?{ }>", $P2484)
    get_how $P2485, type_obj
    .const 'Sub' $P2486 = "397_1300146757.646" 
    $P2485."add_method"(type_obj, "assertion:sym<name>", $P2486)
    get_how $P2487, type_obj
    get_global $P2488, "!PREFIX__assertion:sym<name>"
    $P2487."add_method"(type_obj, "!PREFIX__assertion:sym<name>", $P2488)
    get_how $P2489, type_obj
    .const 'Sub' $P2490 = "400_1300146757.646" 
    $P2489."add_method"(type_obj, "assertion:sym<var>", $P2490)
    get_how $P2491, type_obj
    get_global $P2492, "!PREFIX__assertion:sym<var>"
    $P2491."add_method"(type_obj, "!PREFIX__assertion:sym<var>", $P2492)
    get_how $P2493, type_obj
    .const 'Sub' $P2494 = "402_1300146757.646" 
    $P2493."add_method"(type_obj, "codeblock", $P2494)
    get_how $P2495, type_obj
    get_global $P2496, "!PREFIX__codeblock"
    $P2495."add_method"(type_obj, "!PREFIX__codeblock", $P2496)
    get_how $P2497, type_obj
    get_hll_global $P2498, ["Regex";"P6Regex"], "Grammar"
    $P2497."add_parent"(type_obj, $P2498)
    get_how $P2499, type_obj
    $P2500 = $P2499."compose"(type_obj)
    .return ($P2500)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<:my>"  :subid("384_1300146757.646") :method :outer("383_1300146757.646")
.annotate 'line', 698
    .const 'Sub' $P2407 = "386_1300146757.646" 
    capture_lex $P2407
    .local string rx2402_tgt
    .local int rx2402_pos
    .local int rx2402_off
    .local int rx2402_eos
    .local int rx2402_rep
    .local pmc rx2402_cur
    .local pmc rx2402_debug
    (rx2402_cur, rx2402_pos, rx2402_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2402_cur
    .local pmc match
    .lex "$/", match
    length rx2402_eos, rx2402_tgt
    gt rx2402_pos, rx2402_eos, rx2402_done
    set rx2402_off, 0
    lt rx2402_pos, 2, rx2402_start
    sub rx2402_off, rx2402_pos, 1
    substr rx2402_tgt, rx2402_tgt, rx2402_off
  rx2402_start:
    eq $I10, 1, rx2402_restart
    if_null rx2402_debug, debug_1325
    rx2402_cur."!cursor_debug"("START", "metachar:sym<:my>")
  debug_1325:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2405_done
    goto rxscan2405_scan
  rxscan2405_loop:
    (rx2402_pos) = rx2402_cur."from"()
    inc rx2402_pos
    rx2402_cur."!cursor_from"(rx2402_pos)
    ge rx2402_pos, rx2402_eos, rxscan2405_done
  rxscan2405_scan:
    set_addr $I10, rxscan2405_loop
    rx2402_cur."!mark_push"(0, rx2402_pos, $I10)
  rxscan2405_done:
.annotate 'line', 700
  # rx literal  ":"
    add $I11, rx2402_pos, 1
    gt $I11, rx2402_eos, rx2402_fail
    sub $I11, rx2402_pos, rx2402_off
    ord $I11, rx2402_tgt, $I11
    ne $I11, 58, rx2402_fail
    add rx2402_pos, 1
  # rx subrule "before" subtype=zerowidth negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    .const 'Sub' $P2407 = "386_1300146757.646" 
    capture_lex $P2407
    $P10 = rx2402_cur."before"($P2407)
    unless $P10, rx2402_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."LANG"("MAIN", "statement")
    unless $P10, rx2402_fail
    rx2402_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("statement")
    rx2402_pos = $P10."pos"()
  # rx subrule "ws" subtype=method negate=
    rx2402_cur."!cursor_pos"(rx2402_pos)
    $P10 = rx2402_cur."ws"()
    unless $P10, rx2402_fail
    rx2402_pos = $P10."pos"()
  # rx literal  ";"
    add $I11, rx2402_pos, 1
    gt $I11, rx2402_eos, rx2402_fail
    sub $I11, rx2402_pos, rx2402_off
    ord $I11, rx2402_tgt, $I11
    ne $I11, 59, rx2402_fail
    add rx2402_pos, 1
.annotate 'line', 699
  # rx pass
    rx2402_cur."!cursor_pass"(rx2402_pos, "metachar:sym<:my>")
    if_null rx2402_debug, debug_1330
    rx2402_cur."!cursor_debug"("PASS", "metachar:sym<:my>", " at pos=", rx2402_pos)
  debug_1330:
    .return (rx2402_cur)
  rx2402_restart:
.annotate 'line', 698
    if_null rx2402_debug, debug_1331
    rx2402_cur."!cursor_debug"("NEXT", "metachar:sym<:my>")
  debug_1331:
  rx2402_fail:
    (rx2402_rep, rx2402_pos, $I10, $P10) = rx2402_cur."!mark_fail"(0)
    lt rx2402_pos, -1, rx2402_done
    eq rx2402_pos, -1, rx2402_fail
    jump $I10
  rx2402_done:
    rx2402_cur."!cursor_fail"()
    if_null rx2402_debug, debug_1332
    rx2402_cur."!cursor_debug"("FAIL", "metachar:sym<:my>")
  debug_1332:
    .return (rx2402_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<:my>"  :nsentry("!PREFIX__metachar:sym<:my>") :subid("385_1300146757.646") :method
.annotate 'line', 698
    new $P2404, "ResizablePMCArray"
    push $P2404, ":"
    .return ($P2404)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2406"  :anon :subid("386_1300146757.646") :method :outer("384_1300146757.646")
.annotate 'line', 700
    .local string rx2408_tgt
    .local int rx2408_pos
    .local int rx2408_off
    .local int rx2408_eos
    .local int rx2408_rep
    .local pmc rx2408_cur
    .local pmc rx2408_debug
    (rx2408_cur, rx2408_pos, rx2408_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2408_cur
    .local pmc match
    .lex "$/", match
    length rx2408_eos, rx2408_tgt
    gt rx2408_pos, rx2408_eos, rx2408_done
    set rx2408_off, 0
    lt rx2408_pos, 2, rx2408_start
    sub rx2408_off, rx2408_pos, 1
    substr rx2408_tgt, rx2408_tgt, rx2408_off
  rx2408_start:
    eq $I10, 1, rx2408_restart
    if_null rx2408_debug, debug_1326
    rx2408_cur."!cursor_debug"("START", "")
  debug_1326:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2409_done
    goto rxscan2409_scan
  rxscan2409_loop:
    (rx2408_pos) = rx2408_cur."from"()
    inc rx2408_pos
    rx2408_cur."!cursor_from"(rx2408_pos)
    ge rx2408_pos, rx2408_eos, rxscan2409_done
  rxscan2409_scan:
    set_addr $I10, rxscan2409_loop
    rx2408_cur."!mark_push"(0, rx2408_pos, $I10)
  rxscan2409_done:
  # rx literal  "my"
    add $I11, rx2408_pos, 2
    gt $I11, rx2408_eos, rx2408_fail
    sub $I11, rx2408_pos, rx2408_off
    substr $S10, rx2408_tgt, $I11, 2
    ne $S10, "my", rx2408_fail
    add rx2408_pos, 2
  # rx pass
    rx2408_cur."!cursor_pass"(rx2408_pos, "")
    if_null rx2408_debug, debug_1327
    rx2408_cur."!cursor_debug"("PASS", "", " at pos=", rx2408_pos)
  debug_1327:
    .return (rx2408_cur)
  rx2408_restart:
    if_null rx2408_debug, debug_1328
    rx2408_cur."!cursor_debug"("NEXT", "")
  debug_1328:
  rx2408_fail:
    (rx2408_rep, rx2408_pos, $I10, $P10) = rx2408_cur."!mark_fail"(0)
    lt rx2408_pos, -1, rx2408_done
    eq rx2408_pos, -1, rx2408_fail
    jump $I10
  rx2408_done:
    rx2408_cur."!cursor_fail"()
    if_null rx2408_debug, debug_1329
    rx2408_cur."!cursor_debug"("FAIL", "")
  debug_1329:
    .return (rx2408_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<{ }>"  :subid("387_1300146757.646") :method :outer("383_1300146757.646")
.annotate 'line', 698
    .local string rx2411_tgt
    .local int rx2411_pos
    .local int rx2411_off
    .local int rx2411_eos
    .local int rx2411_rep
    .local pmc rx2411_cur
    .local pmc rx2411_debug
    (rx2411_cur, rx2411_pos, rx2411_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2411_cur
    .local pmc match
    .lex "$/", match
    length rx2411_eos, rx2411_tgt
    gt rx2411_pos, rx2411_eos, rx2411_done
    set rx2411_off, 0
    lt rx2411_pos, 2, rx2411_start
    sub rx2411_off, rx2411_pos, 1
    substr rx2411_tgt, rx2411_tgt, rx2411_off
  rx2411_start:
    eq $I10, 1, rx2411_restart
    if_null rx2411_debug, debug_1333
    rx2411_cur."!cursor_debug"("START", "metachar:sym<{ }>")
  debug_1333:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2414_done
    goto rxscan2414_scan
  rxscan2414_loop:
    (rx2411_pos) = rx2411_cur."from"()
    inc rx2411_pos
    rx2411_cur."!cursor_from"(rx2411_pos)
    ge rx2411_pos, rx2411_eos, rxscan2414_done
  rxscan2414_scan:
    set_addr $I10, rxscan2414_loop
    rx2411_cur."!mark_push"(0, rx2411_pos, $I10)
  rxscan2414_done:
.annotate 'line', 704
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2411_pos, rx2411_off
    substr $S10, rx2411_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2411_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2411_cur."!cursor_pos"(rx2411_pos)
    $P10 = rx2411_cur."codeblock"()
    unless $P10, rx2411_fail
    rx2411_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2411_pos = $P10."pos"()
.annotate 'line', 703
  # rx pass
    rx2411_cur."!cursor_pass"(rx2411_pos, "metachar:sym<{ }>")
    if_null rx2411_debug, debug_1334
    rx2411_cur."!cursor_debug"("PASS", "metachar:sym<{ }>", " at pos=", rx2411_pos)
  debug_1334:
    .return (rx2411_cur)
  rx2411_restart:
.annotate 'line', 698
    if_null rx2411_debug, debug_1335
    rx2411_cur."!cursor_debug"("NEXT", "metachar:sym<{ }>")
  debug_1335:
  rx2411_fail:
    (rx2411_rep, rx2411_pos, $I10, $P10) = rx2411_cur."!mark_fail"(0)
    lt rx2411_pos, -1, rx2411_done
    eq rx2411_pos, -1, rx2411_fail
    jump $I10
  rx2411_done:
    rx2411_cur."!cursor_fail"()
    if_null rx2411_debug, debug_1336
    rx2411_cur."!cursor_debug"("FAIL", "metachar:sym<{ }>")
  debug_1336:
    .return (rx2411_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<{ }>"  :nsentry("!PREFIX__metachar:sym<{ }>") :subid("388_1300146757.646") :method
.annotate 'line', 698
    new $P2413, "ResizablePMCArray"
    push $P2413, "{"
    .return ($P2413)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "metachar:sym<nqpvar>"  :subid("389_1300146757.646") :method :outer("383_1300146757.646")
.annotate 'line', 698
    .const 'Sub' $P2421 = "391_1300146757.646" 
    capture_lex $P2421
    .local string rx2416_tgt
    .local int rx2416_pos
    .local int rx2416_off
    .local int rx2416_eos
    .local int rx2416_rep
    .local pmc rx2416_cur
    .local pmc rx2416_debug
    (rx2416_cur, rx2416_pos, rx2416_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2416_cur
    .local pmc match
    .lex "$/", match
    length rx2416_eos, rx2416_tgt
    gt rx2416_pos, rx2416_eos, rx2416_done
    set rx2416_off, 0
    lt rx2416_pos, 2, rx2416_start
    sub rx2416_off, rx2416_pos, 1
    substr rx2416_tgt, rx2416_tgt, rx2416_off
  rx2416_start:
    eq $I10, 1, rx2416_restart
    if_null rx2416_debug, debug_1337
    rx2416_cur."!cursor_debug"("START", "metachar:sym<nqpvar>")
  debug_1337:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2419_done
    goto rxscan2419_scan
  rxscan2419_loop:
    (rx2416_pos) = rx2416_cur."from"()
    inc rx2416_pos
    rx2416_cur."!cursor_from"(rx2416_pos)
    ge rx2416_pos, rx2416_eos, rxscan2419_done
  rxscan2419_scan:
    set_addr $I10, rxscan2419_loop
    rx2416_cur."!mark_push"(0, rx2416_pos, $I10)
  rxscan2419_done:
.annotate 'line', 708
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2416_pos, rx2416_off
    substr $S10, rx2416_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2416_fail
  # rx subrule "before" subtype=zerowidth negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    .const 'Sub' $P2421 = "391_1300146757.646" 
    capture_lex $P2421
    $P10 = rx2416_cur."before"($P2421)
    unless $P10, rx2416_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2416_cur."!cursor_pos"(rx2416_pos)
    $P10 = rx2416_cur."LANG"("MAIN", "variable")
    unless $P10, rx2416_fail
    rx2416_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2416_pos = $P10."pos"()
.annotate 'line', 707
  # rx pass
    rx2416_cur."!cursor_pass"(rx2416_pos, "metachar:sym<nqpvar>")
    if_null rx2416_debug, debug_1342
    rx2416_cur."!cursor_debug"("PASS", "metachar:sym<nqpvar>", " at pos=", rx2416_pos)
  debug_1342:
    .return (rx2416_cur)
  rx2416_restart:
.annotate 'line', 698
    if_null rx2416_debug, debug_1343
    rx2416_cur."!cursor_debug"("NEXT", "metachar:sym<nqpvar>")
  debug_1343:
  rx2416_fail:
    (rx2416_rep, rx2416_pos, $I10, $P10) = rx2416_cur."!mark_fail"(0)
    lt rx2416_pos, -1, rx2416_done
    eq rx2416_pos, -1, rx2416_fail
    jump $I10
  rx2416_done:
    rx2416_cur."!cursor_fail"()
    if_null rx2416_debug, debug_1344
    rx2416_cur."!cursor_debug"("FAIL", "metachar:sym<nqpvar>")
  debug_1344:
    .return (rx2416_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__metachar:sym<nqpvar>"  :nsentry("!PREFIX__metachar:sym<nqpvar>") :subid("390_1300146757.646") :method
.annotate 'line', 698
    new $P2418, "ResizablePMCArray"
    push $P2418, "$"
    push $P2418, "@"
    .return ($P2418)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2420"  :anon :subid("391_1300146757.646") :method :outer("389_1300146757.646")
.annotate 'line', 708
    .local string rx2422_tgt
    .local int rx2422_pos
    .local int rx2422_off
    .local int rx2422_eos
    .local int rx2422_rep
    .local pmc rx2422_cur
    .local pmc rx2422_debug
    (rx2422_cur, rx2422_pos, rx2422_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2422_cur
    .local pmc match
    .lex "$/", match
    length rx2422_eos, rx2422_tgt
    gt rx2422_pos, rx2422_eos, rx2422_done
    set rx2422_off, 0
    lt rx2422_pos, 2, rx2422_start
    sub rx2422_off, rx2422_pos, 1
    substr rx2422_tgt, rx2422_tgt, rx2422_off
  rx2422_start:
    eq $I10, 1, rx2422_restart
    if_null rx2422_debug, debug_1338
    rx2422_cur."!cursor_debug"("START", "")
  debug_1338:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2423_done
    goto rxscan2423_scan
  rxscan2423_loop:
    (rx2422_pos) = rx2422_cur."from"()
    inc rx2422_pos
    rx2422_cur."!cursor_from"(rx2422_pos)
    ge rx2422_pos, rx2422_eos, rxscan2423_done
  rxscan2423_scan:
    set_addr $I10, rxscan2423_loop
    rx2422_cur."!mark_push"(0, rx2422_pos, $I10)
  rxscan2423_done:
  # rx charclass .
    ge rx2422_pos, rx2422_eos, rx2422_fail
    inc rx2422_pos
  # rx charclass w
    ge rx2422_pos, rx2422_eos, rx2422_fail
    sub $I10, rx2422_pos, rx2422_off
    is_cclass $I11, 8192, rx2422_tgt, $I10
    unless $I11, rx2422_fail
    inc rx2422_pos
  # rx pass
    rx2422_cur."!cursor_pass"(rx2422_pos, "")
    if_null rx2422_debug, debug_1339
    rx2422_cur."!cursor_debug"("PASS", "", " at pos=", rx2422_pos)
  debug_1339:
    .return (rx2422_cur)
  rx2422_restart:
    if_null rx2422_debug, debug_1340
    rx2422_cur."!cursor_debug"("NEXT", "")
  debug_1340:
  rx2422_fail:
    (rx2422_rep, rx2422_pos, $I10, $P10) = rx2422_cur."!mark_fail"(0)
    lt rx2422_pos, -1, rx2422_done
    eq rx2422_pos, -1, rx2422_fail
    jump $I10
  rx2422_done:
    rx2422_cur."!cursor_fail"()
    if_null rx2422_debug, debug_1341
    rx2422_cur."!cursor_debug"("FAIL", "")
  debug_1341:
    .return (rx2422_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<{ }>"  :subid("392_1300146757.646") :method :outer("383_1300146757.646")
.annotate 'line', 698
    .local string rx2425_tgt
    .local int rx2425_pos
    .local int rx2425_off
    .local int rx2425_eos
    .local int rx2425_rep
    .local pmc rx2425_cur
    .local pmc rx2425_debug
    (rx2425_cur, rx2425_pos, rx2425_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2425_cur
    .local pmc match
    .lex "$/", match
    length rx2425_eos, rx2425_tgt
    gt rx2425_pos, rx2425_eos, rx2425_done
    set rx2425_off, 0
    lt rx2425_pos, 2, rx2425_start
    sub rx2425_off, rx2425_pos, 1
    substr rx2425_tgt, rx2425_tgt, rx2425_off
  rx2425_start:
    eq $I10, 1, rx2425_restart
    if_null rx2425_debug, debug_1345
    rx2425_cur."!cursor_debug"("START", "assertion:sym<{ }>")
  debug_1345:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2428_done
    goto rxscan2428_scan
  rxscan2428_loop:
    (rx2425_pos) = rx2425_cur."from"()
    inc rx2425_pos
    rx2425_cur."!cursor_from"(rx2425_pos)
    ge rx2425_pos, rx2425_eos, rxscan2428_done
  rxscan2428_scan:
    set_addr $I10, rxscan2428_loop
    rx2425_cur."!mark_push"(0, rx2425_pos, $I10)
  rxscan2428_done:
.annotate 'line', 712
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2425_pos, rx2425_off
    substr $S10, rx2425_tgt, $I10, 1
    index $I11, "{", $S10
    lt $I11, 0, rx2425_fail
  # rx subrule "codeblock" subtype=capture negate=
    rx2425_cur."!cursor_pos"(rx2425_pos)
    $P10 = rx2425_cur."codeblock"()
    unless $P10, rx2425_fail
    rx2425_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2425_pos = $P10."pos"()
.annotate 'line', 711
  # rx pass
    rx2425_cur."!cursor_pass"(rx2425_pos, "assertion:sym<{ }>")
    if_null rx2425_debug, debug_1346
    rx2425_cur."!cursor_debug"("PASS", "assertion:sym<{ }>", " at pos=", rx2425_pos)
  debug_1346:
    .return (rx2425_cur)
  rx2425_restart:
.annotate 'line', 698
    if_null rx2425_debug, debug_1347
    rx2425_cur."!cursor_debug"("NEXT", "assertion:sym<{ }>")
  debug_1347:
  rx2425_fail:
    (rx2425_rep, rx2425_pos, $I10, $P10) = rx2425_cur."!mark_fail"(0)
    lt rx2425_pos, -1, rx2425_done
    eq rx2425_pos, -1, rx2425_fail
    jump $I10
  rx2425_done:
    rx2425_cur."!cursor_fail"()
    if_null rx2425_debug, debug_1348
    rx2425_cur."!cursor_debug"("FAIL", "assertion:sym<{ }>")
  debug_1348:
    .return (rx2425_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<{ }>"  :nsentry("!PREFIX__assertion:sym<{ }>") :subid("393_1300146757.646") :method
.annotate 'line', 698
    new $P2427, "ResizablePMCArray"
    push $P2427, "{"
    .return ($P2427)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<?{ }>"  :subid("394_1300146757.646") :method :outer("383_1300146757.646")
.annotate 'line', 698
    .const 'Sub' $P2435 = "396_1300146757.646" 
    capture_lex $P2435
    .local string rx2430_tgt
    .local int rx2430_pos
    .local int rx2430_off
    .local int rx2430_eos
    .local int rx2430_rep
    .local pmc rx2430_cur
    .local pmc rx2430_debug
    (rx2430_cur, rx2430_pos, rx2430_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2430_cur
    .local pmc match
    .lex "$/", match
    length rx2430_eos, rx2430_tgt
    gt rx2430_pos, rx2430_eos, rx2430_done
    set rx2430_off, 0
    lt rx2430_pos, 2, rx2430_start
    sub rx2430_off, rx2430_pos, 1
    substr rx2430_tgt, rx2430_tgt, rx2430_off
  rx2430_start:
    eq $I10, 1, rx2430_restart
    if_null rx2430_debug, debug_1349
    rx2430_cur."!cursor_debug"("START", "assertion:sym<?{ }>")
  debug_1349:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2433_done
    goto rxscan2433_scan
  rxscan2433_loop:
    (rx2430_pos) = rx2430_cur."from"()
    inc rx2430_pos
    rx2430_cur."!cursor_from"(rx2430_pos)
    ge rx2430_pos, rx2430_eos, rxscan2433_done
  rxscan2433_scan:
    set_addr $I10, rxscan2433_loop
    rx2430_cur."!mark_push"(0, rx2430_pos, $I10)
  rxscan2433_done:
.annotate 'line', 716
  # rx subcapture "zw"
    set_addr $I10, rxcap_2438_fail
    rx2430_cur."!mark_push"(0, rx2430_pos, $I10)
  # rx enumcharlist negate=0 
    ge rx2430_pos, rx2430_eos, rx2430_fail
    sub $I10, rx2430_pos, rx2430_off
    substr $S10, rx2430_tgt, $I10, 1
    index $I11, "?!", $S10
    lt $I11, 0, rx2430_fail
    inc rx2430_pos
  # rx subrule "before" subtype=zerowidth negate=
    rx2430_cur."!cursor_pos"(rx2430_pos)
    .const 'Sub' $P2435 = "396_1300146757.646" 
    capture_lex $P2435
    $P10 = rx2430_cur."before"($P2435)
    unless $P10, rx2430_fail
    set_addr $I10, rxcap_2438_fail
    ($I12, $I11) = rx2430_cur."!mark_peek"($I10)
    rx2430_cur."!cursor_pos"($I11)
    ($P10) = rx2430_cur."!cursor_start"()
    $P10."!cursor_pass"(rx2430_pos, "")
    rx2430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("zw")
    goto rxcap_2438_done
  rxcap_2438_fail:
    goto rx2430_fail
  rxcap_2438_done:
  # rx subrule "codeblock" subtype=capture negate=
    rx2430_cur."!cursor_pos"(rx2430_pos)
    $P10 = rx2430_cur."codeblock"()
    unless $P10, rx2430_fail
    rx2430_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("codeblock")
    rx2430_pos = $P10."pos"()
.annotate 'line', 715
  # rx pass
    rx2430_cur."!cursor_pass"(rx2430_pos, "assertion:sym<?{ }>")
    if_null rx2430_debug, debug_1354
    rx2430_cur."!cursor_debug"("PASS", "assertion:sym<?{ }>", " at pos=", rx2430_pos)
  debug_1354:
    .return (rx2430_cur)
  rx2430_restart:
.annotate 'line', 698
    if_null rx2430_debug, debug_1355
    rx2430_cur."!cursor_debug"("NEXT", "assertion:sym<?{ }>")
  debug_1355:
  rx2430_fail:
    (rx2430_rep, rx2430_pos, $I10, $P10) = rx2430_cur."!mark_fail"(0)
    lt rx2430_pos, -1, rx2430_done
    eq rx2430_pos, -1, rx2430_fail
    jump $I10
  rx2430_done:
    rx2430_cur."!cursor_fail"()
    if_null rx2430_debug, debug_1356
    rx2430_cur."!cursor_debug"("FAIL", "assertion:sym<?{ }>")
  debug_1356:
    .return (rx2430_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<?{ }>"  :nsentry("!PREFIX__assertion:sym<?{ }>") :subid("395_1300146757.646") :method
.annotate 'line', 698
    new $P2432, "ResizablePMCArray"
    push $P2432, "!"
    push $P2432, "?"
    .return ($P2432)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2434"  :anon :subid("396_1300146757.646") :method :outer("394_1300146757.646")
.annotate 'line', 716
    .local string rx2436_tgt
    .local int rx2436_pos
    .local int rx2436_off
    .local int rx2436_eos
    .local int rx2436_rep
    .local pmc rx2436_cur
    .local pmc rx2436_debug
    (rx2436_cur, rx2436_pos, rx2436_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2436_cur
    .local pmc match
    .lex "$/", match
    length rx2436_eos, rx2436_tgt
    gt rx2436_pos, rx2436_eos, rx2436_done
    set rx2436_off, 0
    lt rx2436_pos, 2, rx2436_start
    sub rx2436_off, rx2436_pos, 1
    substr rx2436_tgt, rx2436_tgt, rx2436_off
  rx2436_start:
    eq $I10, 1, rx2436_restart
    if_null rx2436_debug, debug_1350
    rx2436_cur."!cursor_debug"("START", "")
  debug_1350:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2437_done
    goto rxscan2437_scan
  rxscan2437_loop:
    (rx2436_pos) = rx2436_cur."from"()
    inc rx2436_pos
    rx2436_cur."!cursor_from"(rx2436_pos)
    ge rx2436_pos, rx2436_eos, rxscan2437_done
  rxscan2437_scan:
    set_addr $I10, rxscan2437_loop
    rx2436_cur."!mark_push"(0, rx2436_pos, $I10)
  rxscan2437_done:
  # rx literal  "{"
    add $I11, rx2436_pos, 1
    gt $I11, rx2436_eos, rx2436_fail
    sub $I11, rx2436_pos, rx2436_off
    ord $I11, rx2436_tgt, $I11
    ne $I11, 123, rx2436_fail
    add rx2436_pos, 1
  # rx pass
    rx2436_cur."!cursor_pass"(rx2436_pos, "")
    if_null rx2436_debug, debug_1351
    rx2436_cur."!cursor_debug"("PASS", "", " at pos=", rx2436_pos)
  debug_1351:
    .return (rx2436_cur)
  rx2436_restart:
    if_null rx2436_debug, debug_1352
    rx2436_cur."!cursor_debug"("NEXT", "")
  debug_1352:
  rx2436_fail:
    (rx2436_rep, rx2436_pos, $I10, $P10) = rx2436_cur."!mark_fail"(0)
    lt rx2436_pos, -1, rx2436_done
    eq rx2436_pos, -1, rx2436_fail
    jump $I10
  rx2436_done:
    rx2436_cur."!cursor_fail"()
    if_null rx2436_debug, debug_1353
    rx2436_cur."!cursor_debug"("FAIL", "")
  debug_1353:
    .return (rx2436_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<name>"  :subid("397_1300146757.646") :method :outer("383_1300146757.646")
.annotate 'line', 698
    .const 'Sub' $P2448 = "399_1300146757.646" 
    capture_lex $P2448
    .local string rx2440_tgt
    .local int rx2440_pos
    .local int rx2440_off
    .local int rx2440_eos
    .local int rx2440_rep
    .local pmc rx2440_cur
    .local pmc rx2440_debug
    (rx2440_cur, rx2440_pos, rx2440_tgt, $I10) = self."!cursor_start"()
    rx2440_cur."!cursor_caparray"("assertion", "arglist", "nibbler")
    .lex unicode:"$\x{a2}", rx2440_cur
    .local pmc match
    .lex "$/", match
    length rx2440_eos, rx2440_tgt
    gt rx2440_pos, rx2440_eos, rx2440_done
    set rx2440_off, 0
    lt rx2440_pos, 2, rx2440_start
    sub rx2440_off, rx2440_pos, 1
    substr rx2440_tgt, rx2440_tgt, rx2440_off
  rx2440_start:
    eq $I10, 1, rx2440_restart
    if_null rx2440_debug, debug_1357
    rx2440_cur."!cursor_debug"("START", "assertion:sym<name>")
  debug_1357:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2444_done
    goto rxscan2444_scan
  rxscan2444_loop:
    (rx2440_pos) = rx2440_cur."from"()
    inc rx2440_pos
    rx2440_cur."!cursor_from"(rx2440_pos)
    ge rx2440_pos, rx2440_eos, rxscan2444_done
  rxscan2444_scan:
    set_addr $I10, rxscan2444_loop
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
  rxscan2444_done:
.annotate 'line', 720
  # rx subrule "identifier" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."identifier"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("longname")
    rx2440_pos = $P10."pos"()
.annotate 'line', 727
  # rx rxquantr2445 ** 0..1
    set_addr $I10, rxquantr2445_done
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
  rxquantr2445_loop:
  alt2446_0:
.annotate 'line', 721
    set_addr $I10, alt2446_1
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 722
  # rx subrule "before" subtype=zerowidth negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    .const 'Sub' $P2448 = "399_1300146757.646" 
    capture_lex $P2448
    $P10 = rx2440_cur."before"($P2448)
    unless $P10, rx2440_fail
    goto alt2446_end
  alt2446_1:
    set_addr $I10, alt2446_2
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 723
  # rx literal  "="
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 61, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "assertion" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."assertion"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("assertion")
    rx2440_pos = $P10."pos"()
    goto alt2446_end
  alt2446_2:
    set_addr $I10, alt2446_3
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 724
  # rx literal  ":"
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 58, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "arglist" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."arglist"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2440_pos = $P10."pos"()
    goto alt2446_end
  alt2446_3:
    set_addr $I10, alt2446_4
    rx2440_cur."!mark_push"(0, rx2440_pos, $I10)
.annotate 'line', 725
  # rx literal  "("
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 40, rx2440_fail
    add rx2440_pos, 1
  # rx subrule "LANG" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."LANG"("MAIN", "arglist")
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("arglist")
    rx2440_pos = $P10."pos"()
  # rx literal  ")"
    add $I11, rx2440_pos, 1
    gt $I11, rx2440_eos, rx2440_fail
    sub $I11, rx2440_pos, rx2440_off
    ord $I11, rx2440_tgt, $I11
    ne $I11, 41, rx2440_fail
    add rx2440_pos, 1
    goto alt2446_end
  alt2446_4:
.annotate 'line', 726
  # rx subrule "normspace" subtype=method negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."normspace"()
    unless $P10, rx2440_fail
    rx2440_pos = $P10."pos"()
  # rx subrule "nibbler" subtype=capture negate=
    rx2440_cur."!cursor_pos"(rx2440_pos)
    $P10 = rx2440_cur."nibbler"()
    unless $P10, rx2440_fail
    rx2440_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("nibbler")
    rx2440_pos = $P10."pos"()
  alt2446_end:
.annotate 'line', 727
    set_addr $I10, rxquantr2445_done
    (rx2440_rep) = rx2440_cur."!mark_commit"($I10)
  rxquantr2445_done:
.annotate 'line', 719
  # rx pass
    rx2440_cur."!cursor_pass"(rx2440_pos, "assertion:sym<name>")
    if_null rx2440_debug, debug_1362
    rx2440_cur."!cursor_debug"("PASS", "assertion:sym<name>", " at pos=", rx2440_pos)
  debug_1362:
    .return (rx2440_cur)
  rx2440_restart:
.annotate 'line', 698
    if_null rx2440_debug, debug_1363
    rx2440_cur."!cursor_debug"("NEXT", "assertion:sym<name>")
  debug_1363:
  rx2440_fail:
    (rx2440_rep, rx2440_pos, $I10, $P10) = rx2440_cur."!mark_fail"(0)
    lt rx2440_pos, -1, rx2440_done
    eq rx2440_pos, -1, rx2440_fail
    jump $I10
  rx2440_done:
    rx2440_cur."!cursor_fail"()
    if_null rx2440_debug, debug_1364
    rx2440_cur."!cursor_debug"("FAIL", "assertion:sym<name>")
  debug_1364:
    .return (rx2440_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<name>"  :nsentry("!PREFIX__assertion:sym<name>") :subid("398_1300146757.646") :method
.annotate 'line', 698
    $P2442 = self."!PREFIX__!subrule"("identifier", "")
    new $P2443, "ResizablePMCArray"
    push $P2443, $P2442
    .return ($P2443)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "_block2447"  :anon :subid("399_1300146757.646") :method :outer("397_1300146757.646")
.annotate 'line', 722
    .local string rx2449_tgt
    .local int rx2449_pos
    .local int rx2449_off
    .local int rx2449_eos
    .local int rx2449_rep
    .local pmc rx2449_cur
    .local pmc rx2449_debug
    (rx2449_cur, rx2449_pos, rx2449_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2449_cur
    .local pmc match
    .lex "$/", match
    length rx2449_eos, rx2449_tgt
    gt rx2449_pos, rx2449_eos, rx2449_done
    set rx2449_off, 0
    lt rx2449_pos, 2, rx2449_start
    sub rx2449_off, rx2449_pos, 1
    substr rx2449_tgt, rx2449_tgt, rx2449_off
  rx2449_start:
    eq $I10, 1, rx2449_restart
    if_null rx2449_debug, debug_1358
    rx2449_cur."!cursor_debug"("START", "")
  debug_1358:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2450_done
    goto rxscan2450_scan
  rxscan2450_loop:
    (rx2449_pos) = rx2449_cur."from"()
    inc rx2449_pos
    rx2449_cur."!cursor_from"(rx2449_pos)
    ge rx2449_pos, rx2449_eos, rxscan2450_done
  rxscan2450_scan:
    set_addr $I10, rxscan2450_loop
    rx2449_cur."!mark_push"(0, rx2449_pos, $I10)
  rxscan2450_done:
  # rx literal  ">"
    add $I11, rx2449_pos, 1
    gt $I11, rx2449_eos, rx2449_fail
    sub $I11, rx2449_pos, rx2449_off
    ord $I11, rx2449_tgt, $I11
    ne $I11, 62, rx2449_fail
    add rx2449_pos, 1
  # rx pass
    rx2449_cur."!cursor_pass"(rx2449_pos, "")
    if_null rx2449_debug, debug_1359
    rx2449_cur."!cursor_debug"("PASS", "", " at pos=", rx2449_pos)
  debug_1359:
    .return (rx2449_cur)
  rx2449_restart:
    if_null rx2449_debug, debug_1360
    rx2449_cur."!cursor_debug"("NEXT", "")
  debug_1360:
  rx2449_fail:
    (rx2449_rep, rx2449_pos, $I10, $P10) = rx2449_cur."!mark_fail"(0)
    lt rx2449_pos, -1, rx2449_done
    eq rx2449_pos, -1, rx2449_fail
    jump $I10
  rx2449_done:
    rx2449_cur."!cursor_fail"()
    if_null rx2449_debug, debug_1361
    rx2449_cur."!cursor_debug"("FAIL", "")
  debug_1361:
    .return (rx2449_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "assertion:sym<var>"  :subid("400_1300146757.646") :method :outer("383_1300146757.646")
.annotate 'line', 698
    .local string rx2452_tgt
    .local int rx2452_pos
    .local int rx2452_off
    .local int rx2452_eos
    .local int rx2452_rep
    .local pmc rx2452_cur
    .local pmc rx2452_debug
    (rx2452_cur, rx2452_pos, rx2452_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2452_cur
    .local pmc match
    .lex "$/", match
    length rx2452_eos, rx2452_tgt
    gt rx2452_pos, rx2452_eos, rx2452_done
    set rx2452_off, 0
    lt rx2452_pos, 2, rx2452_start
    sub rx2452_off, rx2452_pos, 1
    substr rx2452_tgt, rx2452_tgt, rx2452_off
  rx2452_start:
    eq $I10, 1, rx2452_restart
    if_null rx2452_debug, debug_1365
    rx2452_cur."!cursor_debug"("START", "assertion:sym<var>")
  debug_1365:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2455_done
    goto rxscan2455_scan
  rxscan2455_loop:
    (rx2452_pos) = rx2452_cur."from"()
    inc rx2452_pos
    rx2452_cur."!cursor_from"(rx2452_pos)
    ge rx2452_pos, rx2452_eos, rxscan2455_done
  rxscan2455_scan:
    set_addr $I10, rxscan2455_loop
    rx2452_cur."!mark_push"(0, rx2452_pos, $I10)
  rxscan2455_done:
.annotate 'line', 731
  # rx enumcharlist negate=0 zerowidth
    sub $I10, rx2452_pos, rx2452_off
    substr $S10, rx2452_tgt, $I10, 1
    index $I11, "$@", $S10
    lt $I11, 0, rx2452_fail
  # rx subrule "LANG" subtype=capture negate=
    rx2452_cur."!cursor_pos"(rx2452_pos)
    $P10 = rx2452_cur."LANG"("MAIN", "variable")
    unless $P10, rx2452_fail
    rx2452_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("var")
    rx2452_pos = $P10."pos"()
.annotate 'line', 730
  # rx pass
    rx2452_cur."!cursor_pass"(rx2452_pos, "assertion:sym<var>")
    if_null rx2452_debug, debug_1366
    rx2452_cur."!cursor_debug"("PASS", "assertion:sym<var>", " at pos=", rx2452_pos)
  debug_1366:
    .return (rx2452_cur)
  rx2452_restart:
.annotate 'line', 698
    if_null rx2452_debug, debug_1367
    rx2452_cur."!cursor_debug"("NEXT", "assertion:sym<var>")
  debug_1367:
  rx2452_fail:
    (rx2452_rep, rx2452_pos, $I10, $P10) = rx2452_cur."!mark_fail"(0)
    lt rx2452_pos, -1, rx2452_done
    eq rx2452_pos, -1, rx2452_fail
    jump $I10
  rx2452_done:
    rx2452_cur."!cursor_fail"()
    if_null rx2452_debug, debug_1368
    rx2452_cur."!cursor_debug"("FAIL", "assertion:sym<var>")
  debug_1368:
    .return (rx2452_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__assertion:sym<var>"  :nsentry("!PREFIX__assertion:sym<var>") :subid("401_1300146757.646") :method
.annotate 'line', 698
    new $P2454, "ResizablePMCArray"
    push $P2454, "$"
    push $P2454, "@"
    .return ($P2454)
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "codeblock"  :subid("402_1300146757.646") :method :outer("383_1300146757.646")
.annotate 'line', 698
    .local string rx2457_tgt
    .local int rx2457_pos
    .local int rx2457_off
    .local int rx2457_eos
    .local int rx2457_rep
    .local pmc rx2457_cur
    .local pmc rx2457_debug
    (rx2457_cur, rx2457_pos, rx2457_tgt, $I10) = self."!cursor_start"()
    .lex unicode:"$\x{a2}", rx2457_cur
    .local pmc match
    .lex "$/", match
    length rx2457_eos, rx2457_tgt
    gt rx2457_pos, rx2457_eos, rx2457_done
    set rx2457_off, 0
    lt rx2457_pos, 2, rx2457_start
    sub rx2457_off, rx2457_pos, 1
    substr rx2457_tgt, rx2457_tgt, rx2457_off
  rx2457_start:
    eq $I10, 1, rx2457_restart
    if_null rx2457_debug, debug_1369
    rx2457_cur."!cursor_debug"("START", "codeblock")
  debug_1369:
    $I10 = self.'from'()
    ne $I10, -1, rxscan2461_done
    goto rxscan2461_scan
  rxscan2461_loop:
    (rx2457_pos) = rx2457_cur."from"()
    inc rx2457_pos
    rx2457_cur."!cursor_from"(rx2457_pos)
    ge rx2457_pos, rx2457_eos, rxscan2461_done
  rxscan2461_scan:
    set_addr $I10, rxscan2461_loop
    rx2457_cur."!mark_push"(0, rx2457_pos, $I10)
  rxscan2461_done:
.annotate 'line', 735
  # rx subrule "LANG" subtype=capture negate=
    rx2457_cur."!cursor_pos"(rx2457_pos)
    $P10 = rx2457_cur."LANG"("MAIN", "pblock")
    unless $P10, rx2457_fail
    rx2457_cur."!mark_push"(0, -1, 0, $P10)
    $P10."!cursor_names"("block")
    rx2457_pos = $P10."pos"()
.annotate 'line', 734
  # rx pass
    rx2457_cur."!cursor_pass"(rx2457_pos, "codeblock")
    if_null rx2457_debug, debug_1370
    rx2457_cur."!cursor_debug"("PASS", "codeblock", " at pos=", rx2457_pos)
  debug_1370:
    .return (rx2457_cur)
  rx2457_restart:
.annotate 'line', 698
    if_null rx2457_debug, debug_1371
    rx2457_cur."!cursor_debug"("NEXT", "codeblock")
  debug_1371:
  rx2457_fail:
    (rx2457_rep, rx2457_pos, $I10, $P10) = rx2457_cur."!mark_fail"(0)
    lt rx2457_pos, -1, rx2457_done
    eq rx2457_pos, -1, rx2457_fail
    jump $I10
  rx2457_done:
    rx2457_cur."!cursor_fail"()
    if_null rx2457_debug, debug_1372
    rx2457_cur."!cursor_debug"("FAIL", "codeblock")
  debug_1372:
    .return (rx2457_cur)
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Regex"]
.sub "!PREFIX__codeblock"  :nsentry("!PREFIX__codeblock") :subid("403_1300146757.646") :method
.annotate 'line', 698
    $P2459 = self."!PREFIX__!subrule"("LANG", "")
    new $P2460, "ResizablePMCArray"
    push $P2460, $P2459
    .return ($P2460)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2501"  :subid("405_1300146757.646") :outer("10_1300146757.646")
.annotate 'line', 741
    .const 'Sub' $P5483 = "557_1300146757.646" 
    capture_lex $P5483
    .const 'Sub' $P5473 = "556_1300146757.646" 
    capture_lex $P5473
    .const 'Sub' $P5468 = "555_1300146757.646" 
    capture_lex $P5468
    .const 'Sub' $P5463 = "554_1300146757.646" 
    capture_lex $P5463
    .const 'Sub' $P5458 = "553_1300146757.646" 
    capture_lex $P5458
    .const 'Sub' $P5447 = "552_1300146757.646" 
    capture_lex $P5447
    .const 'Sub' $P5439 = "551_1300146757.646" 
    capture_lex $P5439
    .const 'Sub' $P5431 = "550_1300146757.646" 
    capture_lex $P5431
    .const 'Sub' $P5423 = "549_1300146757.646" 
    capture_lex $P5423
    .const 'Sub' $P5418 = "548_1300146757.646" 
    capture_lex $P5418
    .const 'Sub' $P5406 = "547_1300146757.646" 
    capture_lex $P5406
    .const 'Sub' $P5398 = "546_1300146757.646" 
    capture_lex $P5398
    .const 'Sub' $P5360 = "545_1300146757.646" 
    capture_lex $P5360
    .const 'Sub' $P5348 = "544_1300146757.646" 
    capture_lex $P5348
    .const 'Sub' $P5340 = "543_1300146757.646" 
    capture_lex $P5340
    .const 'Sub' $P5332 = "542_1300146757.646" 
    capture_lex $P5332
    .const 'Sub' $P5324 = "541_1300146757.646" 
    capture_lex $P5324
    .const 'Sub' $P5316 = "540_1300146757.646" 
    capture_lex $P5316
    .const 'Sub' $P5308 = "539_1300146757.646" 
    capture_lex $P5308
    .const 'Sub' $P5282 = "538_1300146757.646" 
    capture_lex $P5282
    .const 'Sub' $P5267 = "537_1300146757.646" 
    capture_lex $P5267
    .const 'Sub' $P5259 = "536_1300146757.646" 
    capture_lex $P5259
    .const 'Sub' $P5248 = "535_1300146757.646" 
    capture_lex $P5248
    .const 'Sub' $P5237 = "534_1300146757.646" 
    capture_lex $P5237
    .const 'Sub' $P5226 = "533_1300146757.646" 
    capture_lex $P5226
    .const 'Sub' $P5218 = "532_1300146757.646" 
    capture_lex $P5218
    .const 'Sub' $P5191 = "531_1300146757.646" 
    capture_lex $P5191
    .const 'Sub' $P5153 = "529_1300146757.646" 
    capture_lex $P5153
    .const 'Sub' $P5145 = "528_1300146757.646" 
    capture_lex $P5145
    .const 'Sub' $P5137 = "527_1300146757.646" 
    capture_lex $P5137
    .const 'Sub' $P5112 = "526_1300146757.646" 
    capture_lex $P5112
    .const 'Sub' $P5096 = "525_1300146757.646" 
    capture_lex $P5096
    .const 'Sub' $P5088 = "524_1300146757.646" 
    capture_lex $P5088
    .const 'Sub' $P5080 = "523_1300146757.646" 
    capture_lex $P5080
    .const 'Sub' $P4978 = "520_1300146757.646" 
    capture_lex $P4978
    .const 'Sub' $P4970 = "519_1300146757.646" 
    capture_lex $P4970
    .const 'Sub' $P4963 = "518_1300146757.646" 
    capture_lex $P4963
    .const 'Sub' $P4936 = "517_1300146757.646" 
    capture_lex $P4936
    .const 'Sub' $P4882 = "515_1300146757.646" 
    capture_lex $P4882
    .const 'Sub' $P4868 = "514_1300146757.646" 
    capture_lex $P4868
    .const 'Sub' $P4861 = "513_1300146757.646" 
    capture_lex $P4861
    .const 'Sub' $P4812 = "512_1300146757.646" 
    capture_lex $P4812
    .const 'Sub' $P4647 = "508_1300146757.646" 
    capture_lex $P4647
    .const 'Sub' $P4584 = "506_1300146757.646" 
    capture_lex $P4584
    .const 'Sub' $P4576 = "505_1300146757.646" 
    capture_lex $P4576
    .const 'Sub' $P4561 = "504_1300146757.646" 
    capture_lex $P4561
    .const 'Sub' $P4546 = "503_1300146757.646" 
    capture_lex $P4546
    .const 'Sub' $P4528 = "502_1300146757.646" 
    capture_lex $P4528
    .const 'Sub' $P4429 = "501_1300146757.646" 
    capture_lex $P4429
    .const 'Sub' $P4385 = "498_1300146757.646" 
    capture_lex $P4385
    .const 'Sub' $P4260 = "495_1300146757.646" 
    capture_lex $P4260
    .const 'Sub' $P4009 = "488_1300146757.646" 
    capture_lex $P4009
    .const 'Sub' $P4001 = "487_1300146757.646" 
    capture_lex $P4001
    .const 'Sub' $P3993 = "486_1300146757.646" 
    capture_lex $P3993
    .const 'Sub' $P3892 = "482_1300146757.646" 
    capture_lex $P3892
    .const 'Sub' $P3884 = "481_1300146757.646" 
    capture_lex $P3884
    .const 'Sub' $P3869 = "480_1300146757.646" 
    capture_lex $P3869
    .const 'Sub' $P3854 = "479_1300146757.646" 
    capture_lex $P3854
    .const 'Sub' $P3839 = "478_1300146757.646" 
    capture_lex $P3839
    .const 'Sub' $P3817 = "477_1300146757.646" 
    capture_lex $P3817
    .const 'Sub' $P3809 = "476_1300146757.646" 
    capture_lex $P3809
    .const 'Sub' $P3801 = "475_1300146757.646" 
    capture_lex $P3801
    .const 'Sub' $P3793 = "474_1300146757.646" 
    capture_lex $P3793
    .const 'Sub' $P3596 = "471_1300146757.646" 
    capture_lex $P3596
    .const 'Sub' $P3588 = "470_1300146757.646" 
    capture_lex $P3588
    .const 'Sub' $P3580 = "469_1300146757.646" 
    capture_lex $P3580
    .const 'Sub' $P3572 = "468_1300146757.646" 
    capture_lex $P3572
    .const 'Sub' $P3564 = "467_1300146757.646" 
    capture_lex $P3564
    .const 'Sub' $P3556 = "466_1300146757.646" 
    capture_lex $P3556
    .const 'Sub' $P3548 = "465_1300146757.646" 
    capture_lex $P3548
    .const 'Sub' $P3458 = "463_1300146757.646" 
    capture_lex $P3458
    .const 'Sub' $P3434 = "462_1300146757.646" 
    capture_lex $P3434
    .const 'Sub' $P3420 = "461_1300146757.646" 
    capture_lex $P3420
    .const 'Sub' $P3412 = "460_1300146757.646" 
    capture_lex $P3412
    .const 'Sub' $P3404 = "459_1300146757.646" 
    capture_lex $P3404
    .const 'Sub' $P3396 = "458_1300146757.646" 
    capture_lex $P3396
    .const 'Sub' $P3388 = "457_1300146757.646" 
    capture_lex $P3388
    .const 'Sub' $P3380 = "456_1300146757.646" 
    capture_lex $P3380
    .const 'Sub' $P3372 = "455_1300146757.646" 
    capture_lex $P3372
    .const 'Sub' $P3364 = "454_1300146757.646" 
    capture_lex $P3364
    .const 'Sub' $P3356 = "453_1300146757.646" 
    capture_lex $P3356
    .const 'Sub' $P3348 = "452_1300146757.646" 
    capture_lex $P3348
    .const 'Sub' $P3340 = "451_1300146757.646" 
    capture_lex $P3340
    .const 'Sub' $P3332 = "450_1300146757.646" 
    capture_lex $P3332
    .const 'Sub' $P3324 = "449_1300146757.646" 
    capture_lex $P3324
    .const 'Sub' $P3316 = "448_1300146757.646" 
    capture_lex $P3316
    .const 'Sub' $P3300 = "447_1300146757.646" 
    capture_lex $P3300
    .const 'Sub' $P3267 = "446_1300146757.646" 
    capture_lex $P3267
    .const 'Sub' $P3253 = "445_1300146757.646" 
    capture_lex $P3253
    .const 'Sub' $P3234 = "444_1300146757.646" 
    capture_lex $P3234
    .const 'Sub' $P3216 = "443_1300146757.646" 
    capture_lex $P3216
    .const 'Sub' $P3192 = "442_1300146757.646" 
    capture_lex $P3192
    .const 'Sub' $P3158 = "441_1300146757.646" 
    capture_lex $P3158
    .const 'Sub' $P3143 = "440_1300146757.646" 
    capture_lex $P3143
    .const 'Sub' $P3131 = "439_1300146757.646" 
    capture_lex $P3131
    .const 'Sub' $P3080 = "437_1300146757.646" 
    capture_lex $P3080
    .const 'Sub' $P3069 = "436_1300146757.646" 
    capture_lex $P3069
    .const 'Sub' $P3062 = "435_1300146757.646" 
    capture_lex $P3062
    .const 'Sub' $P3040 = "434_1300146757.646" 
    capture_lex $P3040
    .const 'Sub' $P3029 = "433_1300146757.646" 
    capture_lex $P3029
    .const 'Sub' $P2994 = "431_1300146757.646" 
    capture_lex $P2994
    .const 'Sub' $P2986 = "430_1300146757.646" 
    capture_lex $P2986
    .const 'Sub' $P2978 = "429_1300146757.646" 
    capture_lex $P2978
    .const 'Sub' $P2964 = "428_1300146757.646" 
    capture_lex $P2964
    .const 'Sub' $P2883 = "426_1300146757.646" 
    capture_lex $P2883
    .const 'Sub' $P2842 = "424_1300146757.646" 
    capture_lex $P2842
    .const 'Sub' $P2787 = "423_1300146757.646" 
    capture_lex $P2787
    .const 'Sub' $P2756 = "422_1300146757.646" 
    capture_lex $P2756
    .const 'Sub' $P2748 = "421_1300146757.646" 
    capture_lex $P2748
    .const 'Sub' $P2740 = "419_1300146757.646" 
    capture_lex $P2740
    .const 'Sub' $P2726 = "418_1300146757.646" 
    capture_lex $P2726
    .const 'Sub' $P2700 = "416_1300146757.646" 
    capture_lex $P2700
    .const 'Sub' $P2635 = "414_1300146757.646" 
    capture_lex $P2635
    .const 'Sub' $P2625 = "413_1300146757.646" 
    capture_lex $P2625
    .const 'Sub' $P2577 = "412_1300146757.646" 
    capture_lex $P2577
    .const 'Sub' $P2564 = "411_1300146757.646" 
    capture_lex $P2564
    .const 'Sub' $P2546 = "410_1300146757.646" 
    capture_lex $P2546
    .const 'Sub' $P2513 = "407_1300146757.646" 
    capture_lex $P2513
    .const 'Sub' $P2505 = "406_1300146757.646" 
    capture_lex $P2505
    get_global $P2503, "$?CLASS"
.annotate 'line', 743
    get_global $P2504, "@BLOCK"
    unless_null $P2504, vivify_1374
    $P2504 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P2504
  vivify_1374:
.annotate 'line', 749
    .const 'Sub' $P2505 = "406_1300146757.646" 
    newclosure $P2512, $P2505
    .lex "xblock_immediate", $P2512
.annotate 'line', 754
    .const 'Sub' $P2513 = "407_1300146757.646" 
    newclosure $P2545, $P2513
    .lex "block_immediate", $P2545
.annotate 'line', 764
    .const 'Sub' $P2546 = "410_1300146757.646" 
    newclosure $P2563, $P2546
    .lex "vivitype", $P2563
.annotate 'line', 783
    .const 'Sub' $P2564 = "411_1300146757.646" 
    newclosure $P2576, $P2564
    .lex "colonpair_str", $P2576
.annotate 'line', 1010
    .const 'Sub' $P2577 = "412_1300146757.646" 
    newclosure $P2624, $P2577
    .lex "push_block_handler", $P2624
.annotate 'line', 1552
    .const 'Sub' $P2625 = "413_1300146757.646" 
    newclosure $P2634, $P2625
    .lex "only_star_block", $P2634
.annotate 'line', 1561
    .const 'Sub' $P2635 = "414_1300146757.646" 
    newclosure $P2699, $P2635
    .lex "attach_multi_signature", $P2699
.annotate 'line', 1849
    .const 'Sub' $P2700 = "416_1300146757.646" 
    newclosure $P2725, $P2700
    .lex "is_lexical", $P2725
.annotate 'line', 2057
    .const 'Sub' $P2726 = "418_1300146757.646" 
    newclosure $P2737, $P2726
    .lex "control", $P2737
.annotate 'line', 741
    get_global $P2738, "@BLOCK"
    .const 'Sub' $P2740 = "419_1300146757.646" 
    capture_lex $P2740
    $P2740()
    find_lex $P2745, "xblock_immediate"
    find_lex $P2746, "block_immediate"
    find_lex $P2747, "vivitype"
.annotate 'line', 775
    find_lex $P2786, "colonpair_str"
.annotate 'line', 1003
    find_lex $P3252, "push_block_handler"
.annotate 'line', 1480
    find_lex $P4383, "only_star_block"
    find_lex $P4384, "attach_multi_signature"
.annotate 'line', 1827
    find_lex $P4935, "is_lexical"
.annotate 'line', 2048
    find_lex $P5457, "control"
.annotate 'line', 2070
    .const 'Sub' $P5473 = "556_1300146757.646" 
    newclosure $P5481, $P5473
.annotate 'line', 741
    .return ($P5481)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1373") :outer("405_1300146757.646")
.annotate 'line', 741
    get_hll_global $P2502, ["NQP";"Actions"], "_block2501" 
    .local pmc block
    set block, $P2502
    .const 'Sub' $P5483 = "557_1300146757.646" 
    capture_lex $P5483
    $P5483()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5482"  :anon :subid("557_1300146757.646") :outer("405_1300146757.646")
.annotate 'line', 741
    nqp_get_sc_object $P5484, "1300146737.899", 2
    .local pmc type_obj
    set type_obj, $P5484
    set_global "$?CLASS", type_obj
    get_how $P5485, type_obj
    .const 'Sub' $P5486 = "421_1300146757.646" 
    $P5485."add_method"(type_obj, "TOP", $P5486)
    get_how $P5487, type_obj
    .const 'Sub' $P5488 = "422_1300146757.646" 
    $P5487."add_method"(type_obj, "deflongname", $P5488)
    get_how $P5489, type_obj
    .const 'Sub' $P5490 = "423_1300146757.646" 
    $P5489."add_method"(type_obj, "comp_unit", $P5490)
    get_how $P5491, type_obj
    .const 'Sub' $P5492 = "424_1300146757.646" 
    $P5491."add_method"(type_obj, "statementlist", $P5492)
    get_how $P5493, type_obj
    .const 'Sub' $P5494 = "426_1300146757.646" 
    $P5493."add_method"(type_obj, "statement", $P5494)
    get_how $P5495, type_obj
    .const 'Sub' $P5496 = "428_1300146757.646" 
    $P5495."add_method"(type_obj, "xblock", $P5496)
    get_how $P5497, type_obj
    .const 'Sub' $P5498 = "429_1300146757.646" 
    $P5497."add_method"(type_obj, "pblock", $P5498)
    get_how $P5499, type_obj
    .const 'Sub' $P5500 = "430_1300146757.646" 
    $P5499."add_method"(type_obj, "block", $P5500)
    get_how $P5501, type_obj
    .const 'Sub' $P5502 = "431_1300146757.646" 
    $P5501."add_method"(type_obj, "blockoid", $P5502)
    get_how $P5503, type_obj
    .const 'Sub' $P5504 = "433_1300146757.646" 
    $P5503."add_method"(type_obj, "newpad", $P5504)
    get_how $P5505, type_obj
    .const 'Sub' $P5506 = "434_1300146757.646" 
    $P5505."add_method"(type_obj, "outerctx", $P5506)
    get_how $P5507, type_obj
    .const 'Sub' $P5508 = "435_1300146757.646" 
    $P5507."add_method"(type_obj, "you_are_here", $P5508)
    get_how $P5509, type_obj
    .const 'Sub' $P5510 = "436_1300146757.646" 
    $P5509."add_method"(type_obj, "statement_control:sym<use>", $P5510)
    get_how $P5511, type_obj
    .const 'Sub' $P5512 = "437_1300146757.646" 
    $P5511."add_method"(type_obj, "statement_control:sym<if>", $P5512)
    get_how $P5513, type_obj
    .const 'Sub' $P5514 = "439_1300146757.646" 
    $P5513."add_method"(type_obj, "statement_control:sym<unless>", $P5514)
    get_how $P5515, type_obj
    .const 'Sub' $P5516 = "440_1300146757.646" 
    $P5515."add_method"(type_obj, "statement_control:sym<while>", $P5516)
    get_how $P5517, type_obj
    .const 'Sub' $P5518 = "441_1300146757.646" 
    $P5517."add_method"(type_obj, "statement_control:sym<repeat>", $P5518)
    get_how $P5519, type_obj
    .const 'Sub' $P5520 = "442_1300146757.646" 
    $P5519."add_method"(type_obj, "statement_control:sym<for>", $P5520)
    get_how $P5521, type_obj
    .const 'Sub' $P5522 = "443_1300146757.646" 
    $P5521."add_method"(type_obj, "statement_control:sym<CATCH>", $P5522)
    get_how $P5523, type_obj
    .const 'Sub' $P5524 = "444_1300146757.646" 
    $P5523."add_method"(type_obj, "statement_control:sym<CONTROL>", $P5524)
    get_how $P5525, type_obj
    .const 'Sub' $P5526 = "445_1300146757.646" 
    $P5525."add_method"(type_obj, "statement_prefix:sym<INIT>", $P5526)
    get_how $P5527, type_obj
    .const 'Sub' $P5528 = "446_1300146757.646" 
    $P5527."add_method"(type_obj, "statement_prefix:sym<try>", $P5528)
    get_how $P5529, type_obj
    .const 'Sub' $P5530 = "447_1300146757.646" 
    $P5529."add_method"(type_obj, "blorst", $P5530)
    get_how $P5531, type_obj
    .const 'Sub' $P5532 = "448_1300146757.646" 
    $P5531."add_method"(type_obj, "statement_mod_cond:sym<if>", $P5532)
    get_how $P5533, type_obj
    .const 'Sub' $P5534 = "449_1300146757.646" 
    $P5533."add_method"(type_obj, "statement_mod_cond:sym<unless>", $P5534)
    get_how $P5535, type_obj
    .const 'Sub' $P5536 = "450_1300146757.646" 
    $P5535."add_method"(type_obj, "statement_mod_loop:sym<while>", $P5536)
    get_how $P5537, type_obj
    .const 'Sub' $P5538 = "451_1300146757.646" 
    $P5537."add_method"(type_obj, "statement_mod_loop:sym<until>", $P5538)
    get_how $P5539, type_obj
    .const 'Sub' $P5540 = "452_1300146757.646" 
    $P5539."add_method"(type_obj, "term:sym<fatarrow>", $P5540)
    get_how $P5541, type_obj
    .const 'Sub' $P5542 = "453_1300146757.646" 
    $P5541."add_method"(type_obj, "term:sym<colonpair>", $P5542)
    get_how $P5543, type_obj
    .const 'Sub' $P5544 = "454_1300146757.646" 
    $P5543."add_method"(type_obj, "term:sym<variable>", $P5544)
    get_how $P5545, type_obj
    .const 'Sub' $P5546 = "455_1300146757.646" 
    $P5545."add_method"(type_obj, "term:sym<package_declarator>", $P5546)
    get_how $P5547, type_obj
    .const 'Sub' $P5548 = "456_1300146757.646" 
    $P5547."add_method"(type_obj, "term:sym<scope_declarator>", $P5548)
    get_how $P5549, type_obj
    .const 'Sub' $P5550 = "457_1300146757.646" 
    $P5549."add_method"(type_obj, "term:sym<routine_declarator>", $P5550)
    get_how $P5551, type_obj
    .const 'Sub' $P5552 = "458_1300146757.646" 
    $P5551."add_method"(type_obj, "term:sym<regex_declarator>", $P5552)
    get_how $P5553, type_obj
    .const 'Sub' $P5554 = "459_1300146757.646" 
    $P5553."add_method"(type_obj, "term:sym<statement_prefix>", $P5554)
    get_how $P5555, type_obj
    .const 'Sub' $P5556 = "460_1300146757.646" 
    $P5555."add_method"(type_obj, "term:sym<lambda>", $P5556)
    get_how $P5557, type_obj
    .const 'Sub' $P5558 = "461_1300146757.646" 
    $P5557."add_method"(type_obj, "fatarrow", $P5558)
    get_how $P5559, type_obj
    .const 'Sub' $P5560 = "462_1300146757.646" 
    $P5559."add_method"(type_obj, "colonpair", $P5560)
    get_how $P5561, type_obj
    .const 'Sub' $P5562 = "463_1300146757.646" 
    $P5561."add_method"(type_obj, "variable", $P5562)
    get_how $P5563, type_obj
    .const 'Sub' $P5564 = "465_1300146757.646" 
    $P5563."add_method"(type_obj, "package_declarator:sym<module>", $P5564)
    get_how $P5565, type_obj
    .const 'Sub' $P5566 = "466_1300146757.646" 
    $P5565."add_method"(type_obj, "package_declarator:sym<knowhow>", $P5566)
    get_how $P5567, type_obj
    .const 'Sub' $P5568 = "467_1300146757.646" 
    $P5567."add_method"(type_obj, "package_declarator:sym<class>", $P5568)
    get_how $P5569, type_obj
    .const 'Sub' $P5570 = "468_1300146757.646" 
    $P5569."add_method"(type_obj, "package_declarator:sym<grammar>", $P5570)
    get_how $P5571, type_obj
    .const 'Sub' $P5572 = "469_1300146757.646" 
    $P5571."add_method"(type_obj, "package_declarator:sym<role>", $P5572)
    get_how $P5573, type_obj
    .const 'Sub' $P5574 = "470_1300146757.646" 
    $P5573."add_method"(type_obj, "package_declarator:sym<native>", $P5574)
    get_how $P5575, type_obj
    .const 'Sub' $P5576 = "471_1300146757.646" 
    $P5575."add_method"(type_obj, "package_def", $P5576)
    get_how $P5577, type_obj
    .const 'Sub' $P5578 = "474_1300146757.646" 
    $P5577."add_method"(type_obj, "scope_declarator:sym<my>", $P5578)
    get_how $P5579, type_obj
    .const 'Sub' $P5580 = "475_1300146757.646" 
    $P5579."add_method"(type_obj, "scope_declarator:sym<our>", $P5580)
    get_how $P5581, type_obj
    .const 'Sub' $P5582 = "476_1300146757.646" 
    $P5581."add_method"(type_obj, "scope_declarator:sym<has>", $P5582)
    get_how $P5583, type_obj
    .const 'Sub' $P5584 = "477_1300146757.646" 
    $P5583."add_method"(type_obj, "scoped", $P5584)
    get_how $P5585, type_obj
    .const 'Sub' $P5586 = "478_1300146757.646" 
    $P5585."add_method"(type_obj, "declarator", $P5586)
    get_how $P5587, type_obj
    .const 'Sub' $P5588 = "479_1300146757.646" 
    $P5587."add_method"(type_obj, "multi_declarator:sym<multi>", $P5588)
    get_how $P5589, type_obj
    .const 'Sub' $P5590 = "480_1300146757.646" 
    $P5589."add_method"(type_obj, "multi_declarator:sym<proto>", $P5590)
    get_how $P5591, type_obj
    .const 'Sub' $P5592 = "481_1300146757.646" 
    $P5591."add_method"(type_obj, "multi_declarator:sym<null>", $P5592)
    get_how $P5593, type_obj
    .const 'Sub' $P5594 = "482_1300146757.646" 
    $P5593."add_method"(type_obj, "variable_declarator", $P5594)
    get_how $P5595, type_obj
    .const 'Sub' $P5596 = "486_1300146757.646" 
    $P5595."add_method"(type_obj, "routine_declarator:sym<sub>", $P5596)
    get_how $P5597, type_obj
    .const 'Sub' $P5598 = "487_1300146757.646" 
    $P5597."add_method"(type_obj, "routine_declarator:sym<method>", $P5598)
    get_how $P5599, type_obj
    .const 'Sub' $P5600 = "488_1300146757.646" 
    $P5599."add_method"(type_obj, "routine_def", $P5600)
    get_how $P5601, type_obj
    .const 'Sub' $P5602 = "495_1300146757.646" 
    $P5601."add_method"(type_obj, "method_def", $P5602)
    get_how $P5603, type_obj
    .const 'Sub' $P5604 = "498_1300146757.646" 
    $P5603."add_method"(type_obj, "signature", $P5604)
    get_how $P5605, type_obj
    .const 'Sub' $P5606 = "501_1300146757.646" 
    $P5605."add_method"(type_obj, "parameter", $P5606)
    get_how $P5607, type_obj
    .const 'Sub' $P5608 = "502_1300146757.646" 
    $P5607."add_method"(type_obj, "param_var", $P5608)
    get_how $P5609, type_obj
    .const 'Sub' $P5610 = "503_1300146757.646" 
    $P5609."add_method"(type_obj, "named_param", $P5610)
    get_how $P5611, type_obj
    .const 'Sub' $P5612 = "504_1300146757.646" 
    $P5611."add_method"(type_obj, "typename", $P5612)
    get_how $P5613, type_obj
    .const 'Sub' $P5614 = "505_1300146757.646" 
    $P5613."add_method"(type_obj, "trait", $P5614)
    get_how $P5615, type_obj
    .const 'Sub' $P5616 = "506_1300146757.646" 
    $P5615."add_method"(type_obj, "trait_mod:sym<is>", $P5616)
    get_how $P5617, type_obj
    .const 'Sub' $P5618 = "508_1300146757.646" 
    $P5617."add_method"(type_obj, "regex_declarator", $P5618)
    get_how $P5619, type_obj
    .const 'Sub' $P5620 = "512_1300146757.646" 
    $P5619."add_method"(type_obj, "dotty", $P5620)
    get_how $P5621, type_obj
    .const 'Sub' $P5622 = "513_1300146757.646" 
    $P5621."add_method"(type_obj, "term:sym<self>", $P5622)
    get_how $P5623, type_obj
    .const 'Sub' $P5624 = "514_1300146757.646" 
    $P5623."add_method"(type_obj, "term:sym<identifier>", $P5624)
    get_how $P5625, type_obj
    .const 'Sub' $P5626 = "515_1300146757.646" 
    $P5625."add_method"(type_obj, "term:sym<name>", $P5626)
    get_how $P5627, type_obj
    .const 'Sub' $P5628 = "517_1300146757.646" 
    $P5627."add_method"(type_obj, "term:sym<pir::op>", $P5628)
    get_how $P5629, type_obj
    .const 'Sub' $P5630 = "518_1300146757.646" 
    $P5629."add_method"(type_obj, "term:sym<onlystar>", $P5630)
    get_how $P5631, type_obj
    .const 'Sub' $P5632 = "519_1300146757.646" 
    $P5631."add_method"(type_obj, "args", $P5632)
    get_how $P5633, type_obj
    .const 'Sub' $P5634 = "520_1300146757.646" 
    $P5633."add_method"(type_obj, "arglist", $P5634)
    get_how $P5635, type_obj
    .const 'Sub' $P5636 = "523_1300146757.646" 
    $P5635."add_method"(type_obj, "term:sym<multi_declarator>", $P5636)
    get_how $P5637, type_obj
    .const 'Sub' $P5638 = "524_1300146757.646" 
    $P5637."add_method"(type_obj, "term:sym<value>", $P5638)
    get_how $P5639, type_obj
    .const 'Sub' $P5640 = "525_1300146757.646" 
    $P5639."add_method"(type_obj, "circumfix:sym<( )>", $P5640)
    get_how $P5641, type_obj
    .const 'Sub' $P5642 = "526_1300146757.646" 
    $P5641."add_method"(type_obj, "circumfix:sym<[ ]>", $P5642)
    get_how $P5643, type_obj
    .const 'Sub' $P5644 = "527_1300146757.646" 
    $P5643."add_method"(type_obj, "circumfix:sym<ang>", $P5644)
    get_how $P5645, type_obj
    .const 'Sub' $P5646 = "528_1300146757.646" 
    $P5645."add_method"(type_obj, unicode:"circumfix:sym<\x{ab} \x{bb}>", $P5646)
    get_how $P5647, type_obj
    .const 'Sub' $P5648 = "529_1300146757.646" 
    $P5647."add_method"(type_obj, "circumfix:sym<{ }>", $P5648)
    get_how $P5649, type_obj
    .const 'Sub' $P5650 = "531_1300146757.646" 
    $P5649."add_method"(type_obj, "circumfix:sym<sigil>", $P5650)
    get_how $P5651, type_obj
    .const 'Sub' $P5652 = "532_1300146757.646" 
    $P5651."add_method"(type_obj, "semilist", $P5652)
    get_how $P5653, type_obj
    .const 'Sub' $P5654 = "533_1300146757.646" 
    $P5653."add_method"(type_obj, "postcircumfix:sym<[ ]>", $P5654)
    get_how $P5655, type_obj
    .const 'Sub' $P5656 = "534_1300146757.646" 
    $P5655."add_method"(type_obj, "postcircumfix:sym<{ }>", $P5656)
    get_how $P5657, type_obj
    .const 'Sub' $P5658 = "535_1300146757.646" 
    $P5657."add_method"(type_obj, "postcircumfix:sym<ang>", $P5658)
    get_how $P5659, type_obj
    .const 'Sub' $P5660 = "536_1300146757.646" 
    $P5659."add_method"(type_obj, "postcircumfix:sym<( )>", $P5660)
    get_how $P5661, type_obj
    .const 'Sub' $P5662 = "537_1300146757.646" 
    $P5661."add_method"(type_obj, "value", $P5662)
    get_how $P5663, type_obj
    .const 'Sub' $P5664 = "538_1300146757.646" 
    $P5663."add_method"(type_obj, "number", $P5664)
    get_how $P5665, type_obj
    .const 'Sub' $P5666 = "539_1300146757.646" 
    $P5665."add_method"(type_obj, "quote:sym<apos>", $P5666)
    get_how $P5667, type_obj
    .const 'Sub' $P5668 = "540_1300146757.646" 
    $P5667."add_method"(type_obj, "quote:sym<dblq>", $P5668)
    get_how $P5669, type_obj
    .const 'Sub' $P5670 = "541_1300146757.646" 
    $P5669."add_method"(type_obj, "quote:sym<qq>", $P5670)
    get_how $P5671, type_obj
    .const 'Sub' $P5672 = "542_1300146757.646" 
    $P5671."add_method"(type_obj, "quote:sym<q>", $P5672)
    get_how $P5673, type_obj
    .const 'Sub' $P5674 = "543_1300146757.646" 
    $P5673."add_method"(type_obj, "quote:sym<Q>", $P5674)
    get_how $P5675, type_obj
    .const 'Sub' $P5676 = "544_1300146757.646" 
    $P5675."add_method"(type_obj, "quote:sym<Q:PIR>", $P5676)
    get_how $P5677, type_obj
    .const 'Sub' $P5678 = "545_1300146757.646" 
    $P5677."add_method"(type_obj, "quote:sym</ />", $P5678)
    get_how $P5679, type_obj
    .const 'Sub' $P5680 = "546_1300146757.646" 
    $P5679."add_method"(type_obj, "quote_escape:sym<$>", $P5680)
    get_how $P5681, type_obj
    .const 'Sub' $P5682 = "547_1300146757.646" 
    $P5681."add_method"(type_obj, "quote_escape:sym<{ }>", $P5682)
    get_how $P5683, type_obj
    .const 'Sub' $P5684 = "548_1300146757.646" 
    $P5683."add_method"(type_obj, "quote_escape:sym<esc>", $P5684)
    get_how $P5685, type_obj
    .const 'Sub' $P5686 = "549_1300146757.646" 
    $P5685."add_method"(type_obj, "postfix:sym<.>", $P5686)
    get_how $P5687, type_obj
    .const 'Sub' $P5688 = "550_1300146757.646" 
    $P5687."add_method"(type_obj, "postfix:sym<++>", $P5688)
    get_how $P5689, type_obj
    .const 'Sub' $P5690 = "551_1300146757.646" 
    $P5689."add_method"(type_obj, "postfix:sym<-->", $P5690)
    get_how $P5691, type_obj
    .const 'Sub' $P5692 = "552_1300146757.646" 
    $P5691."add_method"(type_obj, "prefix:sym<make>", $P5692)
    get_how $P5693, type_obj
    .const 'Sub' $P5694 = "553_1300146757.646" 
    $P5693."add_method"(type_obj, "term:sym<next>", $P5694)
    get_how $P5695, type_obj
    .const 'Sub' $P5696 = "554_1300146757.646" 
    $P5695."add_method"(type_obj, "term:sym<last>", $P5696)
    get_how $P5697, type_obj
    .const 'Sub' $P5698 = "555_1300146757.646" 
    $P5697."add_method"(type_obj, "term:sym<redo>", $P5698)
    get_how $P5699, type_obj
    .const 'Sub' $P5700 = "556_1300146757.646" 
    $P5699."add_method"(type_obj, "infix:sym<~~>", $P5700)
    get_how $P5701, type_obj
    get_hll_global $P5702, ["HLL"], "Actions"
    $P5701."add_parent"(type_obj, $P5702)
    get_how $P5703, type_obj
    $P5704 = $P5703."compose"(type_obj)
    .return ($P5704)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock_immediate"  :subid("406_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2506
.annotate 'line', 749
    .lex "$xblock", param_2506
.annotate 'line', 750
    find_lex $P2507, "$xblock"
    unless_null $P2507, vivify_1375
    $P2507 = root_new ['parrot';'ResizablePMCArray']
  vivify_1375:
    set $P2508, $P2507[1]
    unless_null $P2508, vivify_1376
    new $P2508, "Undef"
  vivify_1376:
    $P2509 = "block_immediate"($P2508)
    find_lex $P2510, "$xblock"
    unless_null $P2510, vivify_1377
    $P2510 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$xblock", $P2510
  vivify_1377:
    set $P2510[1], $P2509
    find_lex $P2511, "$xblock"
.annotate 'line', 749
    .return ($P2511)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block_immediate"  :subid("407_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2514
.annotate 'line', 754
    .const 'Sub' $P2524 = "408_1300146757.646" 
    capture_lex $P2524
    .lex "$block", param_2514
.annotate 'line', 755
    find_lex $P2515, "$block"
    $P2515."blocktype"("immediate")
.annotate 'line', 756
    find_lex $P2519, "$block"
    $P2520 = $P2519."symtable"()
    unless $P2520, unless_2518
    set $P2517, $P2520
    goto unless_2518_end
  unless_2518:
    find_lex $P2521, "$block"
    $P2522 = $P2521."handlers"()
    set $P2517, $P2522
  unless_2518_end:
    if $P2517, unless_2516_end
    .const 'Sub' $P2524 = "408_1300146757.646" 
    capture_lex $P2524
    $P2524()
  unless_2516_end:
    find_lex $P2544, "$block"
.annotate 'line', 754
    .return ($P2544)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2523"  :anon :subid("408_1300146757.646") :outer("407_1300146757.646")
.annotate 'line', 756
    .const 'Sub' $P2535 = "409_1300146757.646" 
    capture_lex $P2535
.annotate 'line', 757
    new $P2525, "Undef"
    .lex "$stmts", $P2525
    get_hll_global $P2526, ["PAST"], "Stmts"
    find_lex $P2527, "$block"
    $P2528 = $P2526."new"($P2527 :named("node"))
    store_lex "$stmts", $P2528
.annotate 'line', 758
    find_lex $P2530, "$block"
    $P2531 = $P2530."list"()
    defined $I2532, $P2531
    unless $I2532, for_undef_1378
    iter $P2529, $P2531
    new $P2541, 'ExceptionHandler'
    set_label $P2541, loop2540_handler
    $P2541."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2541
  loop2540_test:
    unless $P2529, loop2540_done
    shift $P2533, $P2529
  loop2540_redo:
    .const 'Sub' $P2535 = "409_1300146757.646" 
    capture_lex $P2535
    $P2535($P2533)
  loop2540_next:
    goto loop2540_test
  loop2540_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2542, exception, 'type'
    eq $P2542, .CONTROL_LOOP_NEXT, loop2540_next
    eq $P2542, .CONTROL_LOOP_REDO, loop2540_redo
  loop2540_done:
    pop_eh 
  for_undef_1378:
.annotate 'line', 759
    find_lex $P2543, "$stmts"
    store_lex "$block", $P2543
.annotate 'line', 756
    .return ($P2543)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2534"  :anon :subid("409_1300146757.646") :outer("408_1300146757.646")
    .param pmc param_2536
.annotate 'line', 758
    .lex "$_", param_2536
    find_lex $P2537, "$stmts"
    find_lex $P2538, "$_"
    $P2539 = $P2537."push"($P2538)
    .return ($P2539)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "vivitype"  :subid("410_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2547
.annotate 'line', 764
    .lex "$sigil", param_2547
.annotate 'line', 765
    find_lex $P2550, "$sigil"
    set $S2551, $P2550
    iseq $I2552, $S2551, "%"
    if $I2552, if_2549
.annotate 'line', 767
    find_lex $P2557, "$sigil"
    set $S2558, $P2557
    iseq $I2559, $S2558, "@"
    if $I2559, if_2556
    new $P2562, "String"
    assign $P2562, "Undef"
    set $P2555, $P2562
    goto if_2556_end
  if_2556:
.annotate 'line', 768
    get_hll_global $P2560, ["PAST"], "Op"
    $P2561 = $P2560."new"("    %r = root_new ['parrot';'ResizablePMCArray']" :named("inline"))
    set $P2555, $P2561
  if_2556_end:
    set $P2548, $P2555
.annotate 'line', 765
    goto if_2549_end
  if_2549:
.annotate 'line', 766
    get_hll_global $P2553, ["PAST"], "Op"
    $P2554 = $P2553."new"("    %r = root_new ['parrot';'Hash']" :named("inline"))
    set $P2548, $P2554
  if_2549_end:
.annotate 'line', 764
    .return ($P2548)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair_str"  :subid("411_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2565
.annotate 'line', 783
    .lex "$ast", param_2565
.annotate 'line', 784
    get_hll_global $P2568, ["PAST"], "Op"
    find_lex $P2569, "$ast"
    $P2570 = $P2568."ACCEPTS"($P2569)
    if $P2570, if_2567
.annotate 'line', 786
    find_lex $P2574, "$ast"
    $P2575 = $P2574."value"()
    set $P2566, $P2575
.annotate 'line', 784
    goto if_2567_end
  if_2567:
.annotate 'line', 785
    find_lex $P2571, "$ast"
    $P2572 = $P2571."list"()
    join $S2573, " ", $P2572
    new $P2566, 'String'
    set $P2566, $S2573
  if_2567_end:
.annotate 'line', 783
    .return ($P2566)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "push_block_handler"  :subid("412_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2578
    .param pmc param_2579
.annotate 'line', 1010
    .lex "$/", param_2578
    .lex "$block", param_2579
.annotate 'line', 1011
    get_global $P2581, "@BLOCK"
    unless_null $P2581, vivify_1379
    $P2581 = root_new ['parrot';'ResizablePMCArray']
  vivify_1379:
    set $P2582, $P2581[0]
    unless_null $P2582, vivify_1380
    new $P2582, "Undef"
  vivify_1380:
    $P2583 = $P2582."handlers"()
    if $P2583, unless_2580_end
.annotate 'line', 1012
    get_global $P2584, "@BLOCK"
    unless_null $P2584, vivify_1381
    $P2584 = root_new ['parrot';'ResizablePMCArray']
  vivify_1381:
    set $P2585, $P2584[0]
    unless_null $P2585, vivify_1382
    new $P2585, "Undef"
  vivify_1382:
    new $P2586, "ResizablePMCArray"
    $P2585."handlers"($P2586)
  unless_2580_end:
.annotate 'line', 1014
    find_lex $P2588, "$block"
    $P2589 = $P2588."arity"()
    if $P2589, unless_2587_end
.annotate 'line', 1015
    find_lex $P2590, "$block"
.annotate 'line', 1016
    get_hll_global $P2591, ["PAST"], "Op"
.annotate 'line', 1017
    get_hll_global $P2592, ["PAST"], "Var"
    $P2593 = $P2592."new"("lexical" :named("scope"), "$!" :named("name"), 1 :named("isdecl"))
.annotate 'line', 1018
    get_hll_global $P2594, ["PAST"], "Var"
    $P2595 = $P2594."new"("lexical" :named("scope"), "$_" :named("name"))
    $P2596 = $P2591."new"($P2593, $P2595, "bind" :named("pasttype"))
.annotate 'line', 1016
    $P2590."unshift"($P2596)
.annotate 'line', 1021
    find_lex $P2597, "$block"
    get_hll_global $P2598, ["PAST"], "Var"
    $P2599 = $P2598."new"("$_" :named("name"), "parameter" :named("scope"))
    $P2597."unshift"($P2599)
.annotate 'line', 1022
    find_lex $P2600, "$block"
    $P2600."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 1023
    find_lex $P2601, "$block"
    $P2601."symbol"("$!", "lexical" :named("scope"))
.annotate 'line', 1024
    find_lex $P2602, "$block"
    $P2602."arity"(1)
  unless_2587_end:
.annotate 'line', 1026
    find_lex $P2603, "$block"
    $P2603."blocktype"("declaration")
.annotate 'line', 1027
    get_global $P2604, "@BLOCK"
    unless_null $P2604, vivify_1383
    $P2604 = root_new ['parrot';'ResizablePMCArray']
  vivify_1383:
    set $P2605, $P2604[0]
    unless_null $P2605, vivify_1384
    new $P2605, "Undef"
  vivify_1384:
    $P2606 = $P2605."handlers"()
.annotate 'line', 1028
    get_hll_global $P2607, ["PAST"], "Control"
    find_lex $P2608, "$/"
.annotate 'line', 1030
    get_hll_global $P2609, ["PAST"], "Stmts"
.annotate 'line', 1031
    get_hll_global $P2610, ["PAST"], "Op"
    find_lex $P2611, "$block"
.annotate 'line', 1033
    get_hll_global $P2612, ["PAST"], "Var"
    $P2613 = $P2612."new"("register" :named("scope"), "exception" :named("name"))
    $P2614 = $P2610."new"($P2611, $P2613, "call" :named("pasttype"))
.annotate 'line', 1035
    get_hll_global $P2615, ["PAST"], "Op"
.annotate 'line', 1036
    get_hll_global $P2616, ["PAST"], "Var"
.annotate 'line', 1037
    get_hll_global $P2617, ["PAST"], "Var"
    $P2618 = $P2617."new"("register" :named("scope"), "exception" :named("name"))
    $P2619 = $P2616."new"($P2618, "handled", "keyed" :named("scope"))
.annotate 'line', 1036
    $P2620 = $P2615."new"($P2619, 1, "bind" :named("pasttype"))
.annotate 'line', 1035
    $P2621 = $P2609."new"($P2614, $P2620)
.annotate 'line', 1030
    $P2622 = $P2607."new"($P2621, $P2608 :named("node"))
.annotate 'line', 1028
    $P2623 = $P2606."unshift"($P2622)
.annotate 'line', 1010
    .return ($P2623)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "only_star_block"  :subid("413_1300146757.646") :outer("405_1300146757.646")
.annotate 'line', 1553
    new $P2626, "Undef"
    .lex "$past", $P2626
    get_global $P2627, "@BLOCK"
    $P2628 = $P2627."shift"()
    store_lex "$past", $P2628
.annotate 'line', 1554
    find_lex $P2629, "$past"
    $P2629."closure"(1)
.annotate 'line', 1555
    find_lex $P2630, "$past"
    get_hll_global $P2631, ["PAST"], "Op"
    $P2632 = $P2631."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P2630."push"($P2632)
    find_lex $P2633, "$past"
.annotate 'line', 1552
    .return ($P2633)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "attach_multi_signature"  :subid("414_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2636
.annotate 'line', 1561
    .const 'Sub' $P2650 = "415_1300146757.646" 
    capture_lex $P2650
    .lex "$routine", param_2636
.annotate 'line', 1565
    new $P2637, "Undef"
    .lex "$types", $P2637
.annotate 'line', 1566
    new $P2638, "Undef"
    .lex "$definednesses", $P2638
.annotate 'line', 1565
    get_hll_global $P2639, ["PAST"], "Op"
    $P2640 = $P2639."new"("list" :named("pasttype"))
    store_lex "$types", $P2640
.annotate 'line', 1566
    get_hll_global $P2641, ["PAST"], "Op"
    $P2642 = $P2641."new"("list" :named("pasttype"))
    store_lex "$definednesses", $P2642
.annotate 'line', 1567
    find_lex $P2644, "$routine"
    unless_null $P2644, vivify_1385
    $P2644 = root_new ['parrot';'ResizablePMCArray']
  vivify_1385:
    set $P2645, $P2644[0]
    unless_null $P2645, vivify_1386
    new $P2645, "Undef"
  vivify_1386:
    $P2646 = $P2645."list"()
    defined $I2647, $P2646
    unless $I2647, for_undef_1387
    iter $P2643, $P2646
    new $P2688, 'ExceptionHandler'
    set_label $P2688, loop2687_handler
    $P2688."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2688
  loop2687_test:
    unless $P2643, loop2687_done
    shift $P2648, $P2643
  loop2687_redo:
    .const 'Sub' $P2650 = "415_1300146757.646" 
    capture_lex $P2650
    $P2650($P2648)
  loop2687_next:
    goto loop2687_test
  loop2687_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2689, exception, 'type'
    eq $P2689, .CONTROL_LOOP_NEXT, loop2687_next
    eq $P2689, .CONTROL_LOOP_REDO, loop2687_redo
  loop2687_done:
    pop_eh 
  for_undef_1387:
.annotate 'line', 1574
    find_lex $P2690, "$routine"
    $P2691 = $P2690."loadinit"()
    get_hll_global $P2692, ["PAST"], "Op"
.annotate 'line', 1575
    get_hll_global $P2693, ["PAST"], "Var"
    $P2694 = $P2693."new"("block" :named("name"), "register" :named("scope"))
    find_lex $P2695, "$types"
    find_lex $P2696, "$definednesses"
    $P2697 = $P2692."new"($P2694, $P2695, $P2696, "set_sub_multisig vPPP" :named("pirop"))
.annotate 'line', 1574
    $P2698 = $P2691."push"($P2697)
.annotate 'line', 1561
    .return ($P2698)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2649"  :anon :subid("415_1300146757.646") :outer("414_1300146757.646")
    .param pmc param_2651
.annotate 'line', 1567
    .lex "$_", param_2651
.annotate 'line', 1568
    get_hll_global $P2656, ["PAST"], "Var"
    find_lex $P2657, "$_"
    $P2658 = $P2656."ACCEPTS"($P2657)
    if $P2658, if_2655
    set $P2654, $P2658
    goto if_2655_end
  if_2655:
    find_lex $P2659, "$_"
    $S2660 = $P2659."scope"()
    iseq $I2661, $S2660, "parameter"
    new $P2654, 'Integer'
    set $P2654, $I2661
  if_2655_end:
    if $P2654, if_2653
    set $P2652, $P2654
    goto if_2653_end
  if_2653:
.annotate 'line', 1569
    find_lex $P2662, "$types"
    find_lex $P2664, "$_"
    $P2665 = $P2664."multitype"()
    set $P2663, $P2665
    defined $I2667, $P2663
    if $I2667, default_2666
    get_hll_global $P2668, ["PAST"], "Op"
    $P2669 = $P2668."new"("null P" :named("pirop"))
    set $P2663, $P2669
  default_2666:
    $P2662."push"($P2663)
.annotate 'line', 1570
    find_lex $P2670, "$definednesses"
    find_lex $P2673, "$_"
    unless_null $P2673, vivify_1388
    $P2673 = root_new ['parrot';'Hash']
  vivify_1388:
    set $P2674, $P2673["definedness"]
    unless_null $P2674, vivify_1389
    new $P2674, "Undef"
  vivify_1389:
    set $S2675, $P2674
    iseq $I2676, $S2675, "D"
    if $I2676, if_2672
.annotate 'line', 1571
    find_lex $P2680, "$_"
    unless_null $P2680, vivify_1390
    $P2680 = root_new ['parrot';'Hash']
  vivify_1390:
    set $P2681, $P2680["definedness"]
    unless_null $P2681, vivify_1391
    new $P2681, "Undef"
  vivify_1391:
    set $S2682, $P2681
    iseq $I2683, $S2682, "U"
    if $I2683, if_2679
    new $P2685, "Integer"
    assign $P2685, 0
    set $P2678, $P2685
    goto if_2679_end
  if_2679:
    new $P2684, "Integer"
    assign $P2684, 2
    set $P2678, $P2684
  if_2679_end:
    set $P2671, $P2678
.annotate 'line', 1570
    goto if_2672_end
  if_2672:
    new $P2677, "Integer"
    assign $P2677, 1
    set $P2671, $P2677
  if_2672_end:
    $P2686 = $P2670."push"($P2671)
.annotate 'line', 1568
    set $P2652, $P2686
  if_2653_end:
.annotate 'line', 1567
    .return ($P2652)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "is_lexical"  :subid("416_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2703
.annotate 'line', 1849
    .const 'Sub' $P2709 = "417_1300146757.646" 
    capture_lex $P2709
    new $P2702, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P2702, control_2701
    push_eh $P2702
    .lex "$name", param_2703
.annotate 'line', 1850
    get_global $P2705, "@BLOCK"
    defined $I2706, $P2705
    unless $I2706, for_undef_1392
    iter $P2704, $P2705
    new $P2722, 'ExceptionHandler'
    set_label $P2722, loop2721_handler
    $P2722."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2722
  loop2721_test:
    unless $P2704, loop2721_done
    shift $P2707, $P2704
  loop2721_redo:
    .const 'Sub' $P2709 = "417_1300146757.646" 
    capture_lex $P2709
    $P2709($P2707)
  loop2721_next:
    goto loop2721_test
  loop2721_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2723, exception, 'type'
    eq $P2723, .CONTROL_LOOP_NEXT, loop2721_next
    eq $P2723, .CONTROL_LOOP_REDO, loop2721_redo
  loop2721_done:
    pop_eh 
  for_undef_1392:
.annotate 'line', 1849
    .return (0)
  control_2701:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2724, exception, "payload"
    .return ($P2724)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block2708"  :anon :subid("417_1300146757.646") :outer("416_1300146757.646")
    .param pmc param_2711
.annotate 'line', 1851
    $P2710 = root_new ['parrot';'Hash']
    .lex "%sym", $P2710
    .lex "$_", param_2711
    find_lex $P2712, "$_"
    find_lex $P2713, "$name"
    $P2714 = $P2712."symbol"($P2713)
    store_lex "%sym", $P2714
.annotate 'line', 1852
    find_lex $P2717, "%sym"
    set $N2718, $P2717
    if $N2718, if_2716
    new $P2715, 'Float'
    set $P2715, $N2718
    goto if_2716_end
  if_2716:
.annotate 'line', 1853
    new $P2719, "Exception"
    set $P2719['type'], .CONTROL_RETURN
    new $P2720, "Integer"
    assign $P2720, 1
    setattribute $P2719, 'payload', $P2720
    throw $P2719
  if_2716_end:
.annotate 'line', 1850
    .return ($P2715)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "control"  :subid("418_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2727
    .param pmc param_2728
.annotate 'line', 2057
    .lex "$/", param_2727
    .lex "$type", param_2728
.annotate 'line', 2058
    find_lex $P2729, "$/"
    get_hll_global $P2730, ["PAST"], "Op"
    find_lex $P2731, "$/"
.annotate 'line', 2062
    get_hll_global $P2732, ["PAST"], "Val"
    find_lex $P2733, "$type"
    $P2734 = $P2732."new"($P2733 :named("value"), "!except_types" :named("returns"))
    $P2735 = $P2730."new"(0, $P2734, $P2731 :named("node"), "die__vii" :named("pirop"))
.annotate 'line', 2058
    $P2736 = $P2729."!make"($P2735)
.annotate 'line', 2057
    .return ($P2736)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2739"  :anon :subid("419_1300146757.646") :outer("405_1300146757.646")
.annotate 'line', 741
    .const 'Sub' $P2742 = "420_1300146757.646" 
    capture_lex $P2742
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "" :load :init :subid("post1393") :outer("419_1300146757.646")
.annotate 'line', 741
    .const 'Sub' $P2740 = "419_1300146757.646" 
    .local pmc block
    set block, $P2740
.annotate 'line', 745
    .const 'Sub' $P2742 = "420_1300146757.646" 
    capture_lex $P2742
    $P2742()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2741"  :anon :subid("420_1300146757.646") :outer("419_1300146757.646")
.annotate 'line', 746
    get_global $P2743, "@BLOCK"
    unless_null $P2743, vivify_1394
    $P2743 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P2743
  vivify_1394:
 $P2744 = new ['ResizablePMCArray'] 
    set_global "@BLOCK", $P2744
.annotate 'line', 745
    .return ($P2744)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "TOP"  :subid("421_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2749
    .param pmc param_2750
.annotate 'line', 773
    .lex "self", param_2749
    .lex "$/", param_2750
    find_lex $P2751, "$/"
    find_lex $P2752, "$/"
    unless_null $P2752, vivify_1395
    $P2752 = root_new ['parrot';'Hash']
  vivify_1395:
    set $P2753, $P2752["comp_unit"]
    unless_null $P2753, vivify_1396
    new $P2753, "Undef"
  vivify_1396:
    $P2754 = $P2753."ast"()
    $P2755 = $P2751."!make"($P2754)
    .return ($P2755)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "deflongname"  :subid("422_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2757
    .param pmc param_2758
.annotate 'line', 775
    .lex "self", param_2757
    .lex "$/", param_2758
.annotate 'line', 776
    find_lex $P2759, "$/"
.annotate 'line', 777
    find_lex $P2762, "$/"
    unless_null $P2762, vivify_1397
    $P2762 = root_new ['parrot';'Hash']
  vivify_1397:
    set $P2763, $P2762["colonpair"]
    unless_null $P2763, vivify_1398
    new $P2763, "Undef"
  vivify_1398:
    if $P2763, if_2761
.annotate 'line', 779
    find_lex $P2783, "$/"
    set $S2784, $P2783
    new $P2760, 'String'
    set $P2760, $S2784
.annotate 'line', 777
    goto if_2761_end
  if_2761:
    find_lex $P2764, "$/"
    unless_null $P2764, vivify_1399
    $P2764 = root_new ['parrot';'Hash']
  vivify_1399:
    set $P2765, $P2764["identifier"]
    unless_null $P2765, vivify_1400
    new $P2765, "Undef"
  vivify_1400:
    set $S2766, $P2765
    new $P2767, 'String'
    set $P2767, $S2766
    concat $P2768, $P2767, ":"
    find_lex $P2769, "$/"
    unless_null $P2769, vivify_1401
    $P2769 = root_new ['parrot';'Hash']
  vivify_1401:
    set $P2770, $P2769["colonpair"]
    unless_null $P2770, vivify_1402
    $P2770 = root_new ['parrot';'ResizablePMCArray']
  vivify_1402:
    set $P2771, $P2770[0]
    unless_null $P2771, vivify_1403
    new $P2771, "Undef"
  vivify_1403:
    $P2772 = $P2771."ast"()
    $S2773 = $P2772."named"()
    concat $P2774, $P2768, $S2773
    concat $P2775, $P2774, "<"
.annotate 'line', 778
    find_lex $P2776, "$/"
    unless_null $P2776, vivify_1404
    $P2776 = root_new ['parrot';'Hash']
  vivify_1404:
    set $P2777, $P2776["colonpair"]
    unless_null $P2777, vivify_1405
    $P2777 = root_new ['parrot';'ResizablePMCArray']
  vivify_1405:
    set $P2778, $P2777[0]
    unless_null $P2778, vivify_1406
    new $P2778, "Undef"
  vivify_1406:
    $P2779 = $P2778."ast"()
    $S2780 = "colonpair_str"($P2779)
    concat $P2781, $P2775, $S2780
    concat $P2782, $P2781, ">"
    set $P2760, $P2782
  if_2761_end:
.annotate 'line', 777
    $P2785 = $P2759."!make"($P2760)
.annotate 'line', 775
    .return ($P2785)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "comp_unit"  :subid("423_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2788
    .param pmc param_2789
.annotate 'line', 789
    .lex "self", param_2788
    .lex "$/", param_2789
.annotate 'line', 790
    new $P2790, "Undef"
    .lex "$mainline", $P2790
.annotate 'line', 791
    new $P2791, "Undef"
    .lex "$unit", $P2791
.annotate 'line', 790
    find_lex $P2792, "$/"
    unless_null $P2792, vivify_1407
    $P2792 = root_new ['parrot';'Hash']
  vivify_1407:
    set $P2793, $P2792["statementlist"]
    unless_null $P2793, vivify_1408
    new $P2793, "Undef"
  vivify_1408:
    $P2794 = $P2793."ast"()
    store_lex "$mainline", $P2794
.annotate 'line', 791
    get_global $P2795, "@BLOCK"
    $P2796 = $P2795."shift"()
    store_lex "$unit", $P2796
.annotate 'line', 795
    find_lex $P2797, "$unit"
    $P2798 = $P2797."loadinit"()
    find_dynamic_lex $P2799, "$*SC"
    unless_null $P2799, vivify_1409
    get_hll_global $P2799, "$SC"
    unless_null $P2799, vivify_1410
    die "Contextual $*SC not found"
  vivify_1410:
  vivify_1409:
    $P2800 = $P2799."to_past"()
    $P2798."push"($P2800)
.annotate 'line', 800
    find_dynamic_lex $P2802, "$*HAS_YOU_ARE_HERE"
    unless_null $P2802, vivify_1411
    get_hll_global $P2802, "$HAS_YOU_ARE_HERE"
    unless_null $P2802, vivify_1412
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1412:
  vivify_1411:
    if $P2802, unless_2801_end
.annotate 'line', 801
    find_lex $P2803, "$unit"
    find_lex $P2804, "self"
    $P2805 = $P2804."CTXSAVE"()
    $P2803."push"($P2805)
  unless_2801_end:
.annotate 'line', 805
    find_lex $P2806, "$unit"
    $P2806."loadlibs"("nqp_group", "nqp_ops")
.annotate 'line', 809
    find_dynamic_lex $P2808, "$*MAIN_SUB"
    unless_null $P2808, vivify_1413
    get_hll_global $P2808, "$MAIN_SUB"
    unless_null $P2808, vivify_1414
    die "Contextual $*MAIN_SUB not found"
  vivify_1414:
  vivify_1413:
    unless $P2808, if_2807_end
.annotate 'line', 810
    find_lex $P2809, "$unit"
    get_hll_global $P2810, ["PAST"], "Var"
    $P2811 = $P2810."new"("parameter" :named("scope"), "@ARGS" :named("name"), 1 :named("slurpy"))
    $P2809."unshift"($P2811)
.annotate 'line', 811
    find_lex $P2812, "$mainline"
    get_hll_global $P2813, ["PAST"], "Op"
.annotate 'line', 813
    get_hll_global $P2814, ["PAST"], "Var"
    $P2815 = $P2814."new"("lexical" :named("scope"), "@ARGS" :named("name"))
.annotate 'line', 814
    get_hll_global $P2816, ["PAST"], "Op"
.annotate 'line', 815
    get_hll_global $P2817, ["PAST"], "Val"
    find_dynamic_lex $P2818, "$*MAIN_SUB"
    unless_null $P2818, vivify_1415
    get_hll_global $P2818, "$MAIN_SUB"
    unless_null $P2818, vivify_1416
    die "Contextual $*MAIN_SUB not found"
  vivify_1416:
  vivify_1415:
    $P2819 = $P2817."new"($P2818 :named("value"))
.annotate 'line', 816
    get_hll_global $P2820, ["PAST"], "Var"
    $P2821 = $P2820."new"("lexical" :named("scope"), "@ARGS" :named("name"), 1 :named("flat"))
    $P2822 = $P2816."new"($P2819, $P2821, "call" :named("pasttype"))
.annotate 'line', 814
    $P2823 = $P2813."new"($P2815, $P2822, "if" :named("pasttype"))
.annotate 'line', 811
    $P2812."push"($P2823)
  if_2807_end:
.annotate 'line', 824
    find_lex $P2824, "$unit"
.annotate 'line', 825
    get_hll_global $P2825, ["PAST"], "Op"
    find_lex $P2826, "$mainline"
    $P2827 = $P2825."new"($P2826, "return" :named("pirop"))
    $P2824."push"($P2827)
.annotate 'line', 830
    find_lex $P2828, "$unit"
.annotate 'line', 831
    get_hll_global $P2829, ["PAST"], "Block"
.annotate 'line', 833
    get_hll_global $P2830, ["PAST"], "Op"
    get_hll_global $P2831, ["PAST"], "Val"
    find_lex $P2832, "$unit"
    $P2833 = $P2831."new"($P2832 :named("value"))
    $P2834 = $P2830."new"($P2833, "call" :named("pasttype"))
    $P2835 = $P2829."new"($P2834, ":load" :named("pirflags"), 0 :named("lexical"), "" :named("namespace"))
.annotate 'line', 831
    $P2828."push"($P2835)
.annotate 'line', 836
    find_lex $P2836, "$unit"
    find_lex $P2837, "$/"
    $P2836."node"($P2837)
.annotate 'line', 839
    find_lex $P2838, "$unit"
    $P2838."hll"("nqp")
.annotate 'line', 841
    find_lex $P2839, "$/"
    find_lex $P2840, "$unit"
    $P2841 = $P2839."!make"($P2840)
.annotate 'line', 789
    .return ($P2841)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statementlist"  :subid("424_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2843
    .param pmc param_2844
.annotate 'line', 844
    .const 'Sub' $P2858 = "425_1300146757.646" 
    capture_lex $P2858
    .lex "self", param_2843
    .lex "$/", param_2844
.annotate 'line', 845
    new $P2845, "Undef"
    .lex "$past", $P2845
    get_hll_global $P2846, ["PAST"], "Stmts"
    find_lex $P2847, "$/"
    $P2848 = $P2846."new"($P2847 :named("node"))
    store_lex "$past", $P2848
.annotate 'line', 846
    find_lex $P2850, "$/"
    unless_null $P2850, vivify_1417
    $P2850 = root_new ['parrot';'Hash']
  vivify_1417:
    set $P2851, $P2850["statement"]
    unless_null $P2851, vivify_1418
    new $P2851, "Undef"
  vivify_1418:
    unless $P2851, if_2849_end
.annotate 'line', 847
    find_lex $P2853, "$/"
    unless_null $P2853, vivify_1419
    $P2853 = root_new ['parrot';'Hash']
  vivify_1419:
    set $P2854, $P2853["statement"]
    unless_null $P2854, vivify_1420
    new $P2854, "Undef"
  vivify_1420:
    defined $I2855, $P2854
    unless $I2855, for_undef_1421
    iter $P2852, $P2854
    new $P2878, 'ExceptionHandler'
    set_label $P2878, loop2877_handler
    $P2878."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P2878
  loop2877_test:
    unless $P2852, loop2877_done
    shift $P2856, $P2852
  loop2877_redo:
    .const 'Sub' $P2858 = "425_1300146757.646" 
    capture_lex $P2858
    $P2858($P2856)
  loop2877_next:
    goto loop2877_test
  loop2877_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P2879, exception, 'type'
    eq $P2879, .CONTROL_LOOP_NEXT, loop2877_next
    eq $P2879, .CONTROL_LOOP_REDO, loop2877_redo
  loop2877_done:
    pop_eh 
  for_undef_1421:
  if_2849_end:
.annotate 'line', 854
    find_lex $P2880, "$/"
    find_lex $P2881, "$past"
    $P2882 = $P2880."!make"($P2881)
.annotate 'line', 844
    .return ($P2882)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2857"  :anon :subid("425_1300146757.646") :outer("424_1300146757.646")
    .param pmc param_2860
.annotate 'line', 848
    new $P2859, "Undef"
    .lex "$ast", $P2859
    .lex "$_", param_2860
    find_lex $P2861, "$_"
    $P2862 = $P2861."ast"()
    store_lex "$ast", $P2862
.annotate 'line', 849
    find_lex $P2864, "$ast"
    unless_null $P2864, vivify_1422
    $P2864 = root_new ['parrot';'Hash']
  vivify_1422:
    set $P2865, $P2864["sink"]
    unless_null $P2865, vivify_1423
    new $P2865, "Undef"
  vivify_1423:
    defined $I2866, $P2865
    unless $I2866, if_2863_end
    find_lex $P2867, "$ast"
    unless_null $P2867, vivify_1424
    $P2867 = root_new ['parrot';'Hash']
  vivify_1424:
    set $P2868, $P2867["sink"]
    unless_null $P2868, vivify_1425
    new $P2868, "Undef"
  vivify_1425:
    store_lex "$ast", $P2868
  if_2863_end:
.annotate 'line', 850
    find_lex $P2870, "$ast"
    unless_null $P2870, vivify_1426
    $P2870 = root_new ['parrot';'Hash']
  vivify_1426:
    set $P2871, $P2870["bareblock"]
    unless_null $P2871, vivify_1427
    new $P2871, "Undef"
  vivify_1427:
    unless $P2871, if_2869_end
    find_lex $P2872, "$ast"
    $P2873 = "block_immediate"($P2872)
    store_lex "$ast", $P2873
  if_2869_end:
.annotate 'line', 851
    find_lex $P2874, "$past"
    find_lex $P2875, "$ast"
    $P2876 = $P2874."push"($P2875)
.annotate 'line', 847
    .return ($P2876)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement"  :subid("426_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2884
    .param pmc param_2885
    .param pmc param_2886 :optional
    .param int has_param_2886 :opt_flag
.annotate 'line', 857
    .const 'Sub' $P2894 = "427_1300146757.646" 
    capture_lex $P2894
    .lex "self", param_2884
    .lex "$/", param_2885
    if has_param_2886, optparam_1428
    new $P2887, "Undef"
    set param_2886, $P2887
  optparam_1428:
    .lex "$key", param_2886
.annotate 'line', 858
    new $P2888, "Undef"
    .lex "$past", $P2888
.annotate 'line', 857
    find_lex $P2889, "$past"
.annotate 'line', 859
    find_lex $P2891, "$/"
    unless_null $P2891, vivify_1429
    $P2891 = root_new ['parrot';'Hash']
  vivify_1429:
    set $P2892, $P2891["EXPR"]
    unless_null $P2892, vivify_1430
    new $P2892, "Undef"
  vivify_1430:
    if $P2892, if_2890
.annotate 'line', 880
    find_lex $P2955, "$/"
    unless_null $P2955, vivify_1431
    $P2955 = root_new ['parrot';'Hash']
  vivify_1431:
    set $P2956, $P2955["statement_control"]
    unless_null $P2956, vivify_1432
    new $P2956, "Undef"
  vivify_1432:
    if $P2956, if_2954
.annotate 'line', 881
    new $P2960, "Integer"
    assign $P2960, 0
    store_lex "$past", $P2960
    goto if_2954_end
  if_2954:
.annotate 'line', 880
    find_lex $P2957, "$/"
    unless_null $P2957, vivify_1433
    $P2957 = root_new ['parrot';'Hash']
  vivify_1433:
    set $P2958, $P2957["statement_control"]
    unless_null $P2958, vivify_1434
    new $P2958, "Undef"
  vivify_1434:
    $P2959 = $P2958."ast"()
    store_lex "$past", $P2959
  if_2954_end:
    goto if_2890_end
  if_2890:
.annotate 'line', 859
    .const 'Sub' $P2894 = "427_1300146757.646" 
    capture_lex $P2894
    $P2894()
  if_2890_end:
.annotate 'line', 882
    find_lex $P2961, "$/"
    find_lex $P2962, "$past"
    $P2963 = $P2961."!make"($P2962)
.annotate 'line', 857
    .return ($P2963)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block2893"  :anon :subid("427_1300146757.646") :outer("426_1300146757.646")
.annotate 'line', 860
    new $P2895, "Undef"
    .lex "$mc", $P2895
.annotate 'line', 861
    new $P2896, "Undef"
    .lex "$ml", $P2896
.annotate 'line', 860
    find_lex $P2897, "$/"
    unless_null $P2897, vivify_1435
    $P2897 = root_new ['parrot';'Hash']
  vivify_1435:
    set $P2898, $P2897["statement_mod_cond"]
    unless_null $P2898, vivify_1436
    $P2898 = root_new ['parrot';'ResizablePMCArray']
  vivify_1436:
    set $P2899, $P2898[0]
    unless_null $P2899, vivify_1437
    new $P2899, "Undef"
  vivify_1437:
    store_lex "$mc", $P2899
.annotate 'line', 861
    find_lex $P2900, "$/"
    unless_null $P2900, vivify_1438
    $P2900 = root_new ['parrot';'Hash']
  vivify_1438:
    set $P2901, $P2900["statement_mod_loop"]
    unless_null $P2901, vivify_1439
    $P2901 = root_new ['parrot';'ResizablePMCArray']
  vivify_1439:
    set $P2902, $P2901[0]
    unless_null $P2902, vivify_1440
    new $P2902, "Undef"
  vivify_1440:
    store_lex "$ml", $P2902
.annotate 'line', 862
    find_lex $P2903, "$/"
    unless_null $P2903, vivify_1441
    $P2903 = root_new ['parrot';'Hash']
  vivify_1441:
    set $P2904, $P2903["EXPR"]
    unless_null $P2904, vivify_1442
    new $P2904, "Undef"
  vivify_1442:
    $P2905 = $P2904."ast"()
    store_lex "$past", $P2905
.annotate 'line', 863
    find_lex $P2907, "$mc"
    unless $P2907, if_2906_end
.annotate 'line', 864
    get_hll_global $P2908, ["PAST"], "Op"
    find_lex $P2909, "$mc"
    unless_null $P2909, vivify_1443
    $P2909 = root_new ['parrot';'Hash']
  vivify_1443:
    set $P2910, $P2909["cond"]
    unless_null $P2910, vivify_1444
    new $P2910, "Undef"
  vivify_1444:
    $P2911 = $P2910."ast"()
    find_lex $P2912, "$past"
    find_lex $P2913, "$mc"
    unless_null $P2913, vivify_1445
    $P2913 = root_new ['parrot';'Hash']
  vivify_1445:
    set $P2914, $P2913["sym"]
    unless_null $P2914, vivify_1446
    new $P2914, "Undef"
  vivify_1446:
    set $S2915, $P2914
    find_lex $P2916, "$/"
    $P2917 = $P2908."new"($P2911, $P2912, $S2915 :named("pasttype"), $P2916 :named("node"))
    store_lex "$past", $P2917
  if_2906_end:
.annotate 'line', 866
    find_lex $P2920, "$ml"
    if $P2920, if_2919
    set $P2918, $P2920
    goto if_2919_end
  if_2919:
.annotate 'line', 867
    find_lex $P2923, "$ml"
    unless_null $P2923, vivify_1447
    $P2923 = root_new ['parrot';'Hash']
  vivify_1447:
    set $P2924, $P2923["sym"]
    unless_null $P2924, vivify_1448
    new $P2924, "Undef"
  vivify_1448:
    set $S2925, $P2924
    iseq $I2926, $S2925, "for"
    if $I2926, if_2922
.annotate 'line', 876
    get_hll_global $P2944, ["PAST"], "Op"
    find_lex $P2945, "$ml"
    unless_null $P2945, vivify_1449
    $P2945 = root_new ['parrot';'Hash']
  vivify_1449:
    set $P2946, $P2945["cond"]
    unless_null $P2946, vivify_1450
    new $P2946, "Undef"
  vivify_1450:
    $P2947 = $P2946."ast"()
    find_lex $P2948, "$past"
    find_lex $P2949, "$ml"
    unless_null $P2949, vivify_1451
    $P2949 = root_new ['parrot';'Hash']
  vivify_1451:
    set $P2950, $P2949["sym"]
    unless_null $P2950, vivify_1452
    new $P2950, "Undef"
  vivify_1452:
    set $S2951, $P2950
    find_lex $P2952, "$/"
    $P2953 = $P2944."new"($P2947, $P2948, $S2951 :named("pasttype"), $P2952 :named("node"))
    store_lex "$past", $P2953
.annotate 'line', 875
    set $P2921, $P2953
.annotate 'line', 867
    goto if_2922_end
  if_2922:
.annotate 'line', 868
    get_hll_global $P2927, ["PAST"], "Block"
.annotate 'line', 869
    get_hll_global $P2928, ["PAST"], "Var"
    $P2929 = $P2928."new"("$_" :named("name"), "parameter" :named("scope"), 1 :named("isdecl"))
    find_lex $P2930, "$past"
    $P2931 = $P2927."new"($P2929, $P2930, "immediate" :named("blocktype"))
.annotate 'line', 868
    store_lex "$past", $P2931
.annotate 'line', 871
    find_lex $P2932, "$past"
    $P2932."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 872
    find_lex $P2933, "$past"
    $P2933."arity"(1)
.annotate 'line', 873
    get_hll_global $P2934, ["PAST"], "Op"
    find_lex $P2935, "$ml"
    unless_null $P2935, vivify_1453
    $P2935 = root_new ['parrot';'Hash']
  vivify_1453:
    set $P2936, $P2935["cond"]
    unless_null $P2936, vivify_1454
    new $P2936, "Undef"
  vivify_1454:
    $P2937 = $P2936."ast"()
    find_lex $P2938, "$past"
    find_lex $P2939, "$ml"
    unless_null $P2939, vivify_1455
    $P2939 = root_new ['parrot';'Hash']
  vivify_1455:
    set $P2940, $P2939["sym"]
    unless_null $P2940, vivify_1456
    new $P2940, "Undef"
  vivify_1456:
    set $S2941, $P2940
    find_lex $P2942, "$/"
    $P2943 = $P2934."new"($P2937, $P2938, $S2941 :named("pasttype"), $P2942 :named("node"))
    store_lex "$past", $P2943
.annotate 'line', 867
    set $P2921, $P2943
  if_2922_end:
.annotate 'line', 866
    set $P2918, $P2921
  if_2919_end:
.annotate 'line', 859
    .return ($P2918)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "xblock"  :subid("428_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2965
    .param pmc param_2966
.annotate 'line', 885
    .lex "self", param_2965
    .lex "$/", param_2966
.annotate 'line', 886
    find_lex $P2967, "$/"
    get_hll_global $P2968, ["PAST"], "Op"
    find_lex $P2969, "$/"
    unless_null $P2969, vivify_1457
    $P2969 = root_new ['parrot';'Hash']
  vivify_1457:
    set $P2970, $P2969["EXPR"]
    unless_null $P2970, vivify_1458
    new $P2970, "Undef"
  vivify_1458:
    $P2971 = $P2970."ast"()
    find_lex $P2972, "$/"
    unless_null $P2972, vivify_1459
    $P2972 = root_new ['parrot';'Hash']
  vivify_1459:
    set $P2973, $P2972["pblock"]
    unless_null $P2973, vivify_1460
    new $P2973, "Undef"
  vivify_1460:
    $P2974 = $P2973."ast"()
    find_lex $P2975, "$/"
    $P2976 = $P2968."new"($P2971, $P2974, "if" :named("pasttype"), $P2975 :named("node"))
    $P2977 = $P2967."!make"($P2976)
.annotate 'line', 885
    .return ($P2977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "pblock"  :subid("429_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2979
    .param pmc param_2980
.annotate 'line', 889
    .lex "self", param_2979
    .lex "$/", param_2980
.annotate 'line', 890
    find_lex $P2981, "$/"
    find_lex $P2982, "$/"
    unless_null $P2982, vivify_1461
    $P2982 = root_new ['parrot';'Hash']
  vivify_1461:
    set $P2983, $P2982["blockoid"]
    unless_null $P2983, vivify_1462
    new $P2983, "Undef"
  vivify_1462:
    $P2984 = $P2983."ast"()
    $P2985 = $P2981."!make"($P2984)
.annotate 'line', 889
    .return ($P2985)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "block"  :subid("430_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2987
    .param pmc param_2988
.annotate 'line', 893
    .lex "self", param_2987
    .lex "$/", param_2988
.annotate 'line', 894
    find_lex $P2989, "$/"
    find_lex $P2990, "$/"
    unless_null $P2990, vivify_1463
    $P2990 = root_new ['parrot';'Hash']
  vivify_1463:
    set $P2991, $P2990["blockoid"]
    unless_null $P2991, vivify_1464
    new $P2991, "Undef"
  vivify_1464:
    $P2992 = $P2991."ast"()
    $P2993 = $P2989."!make"($P2992)
.annotate 'line', 893
    .return ($P2993)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blockoid"  :subid("431_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_2995
    .param pmc param_2996
.annotate 'line', 897
    .const 'Sub' $P3005 = "432_1300146757.646" 
    capture_lex $P3005
    .lex "self", param_2995
    .lex "$/", param_2996
.annotate 'line', 898
    new $P2997, "Undef"
    .lex "$BLOCK", $P2997
    get_global $P2998, "@BLOCK"
    $P2999 = $P2998."shift"()
    store_lex "$BLOCK", $P2999
.annotate 'line', 899
    find_lex $P3002, "$/"
    unless_null $P3002, vivify_1465
    $P3002 = root_new ['parrot';'Hash']
  vivify_1465:
    set $P3003, $P3002["statementlist"]
    unless_null $P3003, vivify_1466
    new $P3003, "Undef"
  vivify_1466:
    if $P3003, if_3001
.annotate 'line', 907
    find_dynamic_lex $P3020, "$*HAS_YOU_ARE_HERE"
    unless_null $P3020, vivify_1467
    get_hll_global $P3020, "$HAS_YOU_ARE_HERE"
    unless_null $P3020, vivify_1468
    die "Contextual $*HAS_YOU_ARE_HERE not found"
  vivify_1468:
  vivify_1467:
    unless $P3020, if_3019_end
.annotate 'line', 908
    find_lex $P3021, "$/"
    $P3022 = $P3021."CURSOR"()
    $P3022."panic"("{YOU_ARE_HERE} may only appear once in a setting")
  if_3019_end:
.annotate 'line', 910
    new $P3023, "Integer"
    assign $P3023, 1
    store_dynamic_lex "$*HAS_YOU_ARE_HERE", $P3023
.annotate 'line', 911
    find_lex $P3024, "$/"
    find_lex $P3025, "$/"
    unless_null $P3025, vivify_1469
    $P3025 = root_new ['parrot';'Hash']
  vivify_1469:
    set $P3026, $P3025["you_are_here"]
    unless_null $P3026, vivify_1470
    new $P3026, "Undef"
  vivify_1470:
    $P3027 = $P3026."ast"()
    $P3028 = $P3024."!make"($P3027)
.annotate 'line', 906
    set $P3000, $P3028
.annotate 'line', 899
    goto if_3001_end
  if_3001:
    .const 'Sub' $P3005 = "432_1300146757.646" 
    capture_lex $P3005
    $P3018 = $P3005()
    set $P3000, $P3018
  if_3001_end:
.annotate 'line', 897
    .return ($P3000)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3004"  :anon :subid("432_1300146757.646") :outer("431_1300146757.646")
.annotate 'line', 900
    new $P3006, "Undef"
    .lex "$past", $P3006
    find_lex $P3007, "$/"
    unless_null $P3007, vivify_1471
    $P3007 = root_new ['parrot';'Hash']
  vivify_1471:
    set $P3008, $P3007["statementlist"]
    unless_null $P3008, vivify_1472
    new $P3008, "Undef"
  vivify_1472:
    $P3009 = $P3008."ast"()
    store_lex "$past", $P3009
.annotate 'line', 901
    find_lex $P3010, "$BLOCK"
    find_lex $P3011, "$past"
    $P3010."push"($P3011)
.annotate 'line', 902
    find_lex $P3012, "$BLOCK"
    find_lex $P3013, "$/"
    $P3012."node"($P3013)
.annotate 'line', 903
    find_lex $P3014, "$BLOCK"
    $P3014."closure"(1)
.annotate 'line', 904
    find_dynamic_lex $P3015, "$/"
    find_lex $P3016, "$BLOCK"
    $P3017 = $P3015."!make"($P3016)
.annotate 'line', 899
    .return ($P3017)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "newpad"  :subid("433_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3030
    .param pmc param_3031
.annotate 'line', 915
    .lex "self", param_3030
    .lex "$/", param_3031
.annotate 'line', 916
    get_global $P3032, "@BLOCK"
    unless_null $P3032, vivify_1473
    $P3032 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P3032
  vivify_1473:
.annotate 'line', 915
    get_global $P3033, "@BLOCK"
.annotate 'line', 917
    get_global $P3034, "@BLOCK"
    get_hll_global $P3035, ["PAST"], "Block"
    get_hll_global $P3036, ["PAST"], "Stmts"
    $P3037 = $P3036."new"()
    $P3038 = $P3035."new"($P3037)
    $P3039 = $P3034."unshift"($P3038)
.annotate 'line', 915
    .return ($P3039)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "outerctx"  :subid("434_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3041
    .param pmc param_3042
.annotate 'line', 920
    .lex "self", param_3041
    .lex "$/", param_3042
.annotate 'line', 921
    get_global $P3043, "@BLOCK"
    unless_null $P3043, vivify_1474
    $P3043 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P3043
  vivify_1474:
.annotate 'line', 920
    get_global $P3044, "@BLOCK"
.annotate 'line', 922
    find_dynamic_lex $P3046, "%*COMPILING"
    unless_null $P3046, vivify_1475
    get_hll_global $P3046, "%COMPILING"
    unless_null $P3046, vivify_1476
    die "Contextual %*COMPILING not found"
  vivify_1476:
  vivify_1475:
    set $P3047, $P3046["%?OPTIONS"]
    unless_null $P3047, vivify_1477
    $P3047 = root_new ['parrot';'Hash']
  vivify_1477:
    set $P3048, $P3047["outer_ctx"]
    unless_null $P3048, vivify_1478
    new $P3048, "Undef"
  vivify_1478:
    defined $I3049, $P3048
    if $I3049, unless_3045_end
.annotate 'line', 925
    find_dynamic_lex $P3050, "$*SC"
    unless_null $P3050, vivify_1479
    get_hll_global $P3050, "$SC"
    unless_null $P3050, vivify_1480
    die "Contextual $*SC not found"
  vivify_1480:
  vivify_1479:
    find_dynamic_lex $P3052, "%*COMPILING"
    unless_null $P3052, vivify_1481
    get_hll_global $P3052, "%COMPILING"
    unless_null $P3052, vivify_1482
    die "Contextual %*COMPILING not found"
  vivify_1482:
  vivify_1481:
    set $P3053, $P3052["%?OPTIONS"]
    unless_null $P3053, vivify_1483
    $P3053 = root_new ['parrot';'Hash']
  vivify_1483:
    set $P3054, $P3053["setting"]
    unless_null $P3054, vivify_1484
    new $P3054, "Undef"
  vivify_1484:
    set $P3051, $P3054
    defined $I3056, $P3051
    if $I3056, default_3055
    new $P3057, "String"
    assign $P3057, "NQPCORE"
    set $P3051, $P3057
  default_3055:
    $P3050."load_setting"($P3051)
  unless_3045_end:
.annotate 'line', 927
    find_lex $P3058, "self"
    get_global $P3059, "@BLOCK"
    unless_null $P3059, vivify_1485
    $P3059 = root_new ['parrot';'ResizablePMCArray']
  vivify_1485:
    set $P3060, $P3059[0]
    unless_null $P3060, vivify_1486
    new $P3060, "Undef"
  vivify_1486:
    $P3061 = $P3058."SET_BLOCK_OUTER_CTX"($P3060)
.annotate 'line', 920
    .return ($P3061)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "you_are_here"  :subid("435_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3063
    .param pmc param_3064
.annotate 'line', 930
    .lex "self", param_3063
    .lex "$/", param_3064
.annotate 'line', 931
    find_lex $P3065, "$/"
    find_lex $P3066, "self"
    $P3067 = $P3066."CTXSAVE"()
    $P3068 = $P3065."!make"($P3067)
.annotate 'line', 930
    .return ($P3068)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<use>"  :subid("436_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3070
    .param pmc param_3071
.annotate 'line', 936
    .lex "self", param_3070
    .lex "$/", param_3071
.annotate 'line', 937
    find_dynamic_lex $P3072, "$*SC"
    unless_null $P3072, vivify_1487
    get_hll_global $P3072, "$SC"
    unless_null $P3072, vivify_1488
    die "Contextual $*SC not found"
  vivify_1488:
  vivify_1487:
    find_lex $P3073, "$/"
    unless_null $P3073, vivify_1489
    $P3073 = root_new ['parrot';'Hash']
  vivify_1489:
    set $P3074, $P3073["name"]
    unless_null $P3074, vivify_1490
    new $P3074, "Undef"
  vivify_1490:
    set $S3075, $P3074
    $P3072."load_module"($S3075)
.annotate 'line', 938
    find_lex $P3076, "$/"
    get_hll_global $P3077, ["PAST"], "Stmts"
    $P3078 = $P3077."new"()
    $P3079 = $P3076."!make"($P3078)
.annotate 'line', 936
    .return ($P3079)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "statement_control:sym<if>"  :subid("437_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3081
    .param pmc param_3082
.annotate 'line', 941
    .const 'Sub' $P3110 = "438_1300146757.646" 
    capture_lex $P3110
    .lex "self", param_3081
    .lex "$/", param_3082
.annotate 'line', 942
    new $P3083, "Undef"
    .lex "$count", $P3083
.annotate 'line', 943
    new $P3084, "Undef"
    .lex "$past", $P3084
.annotate 'line', 942
    find_lex $P3085, "$/"
    unless_null $P3085, vivify_1491
    $P3085 = root_new ['parrot';'Hash']
  vivify_1491:
    set $P3086, $P3085["xblock"]
    unless_null $P3086, vivify_1492
    new $P3086, "Undef"
  vivify_1492:
    set $N3087, $P3086
    new $P3088, 'Float'
    set $P3088, $N3087
    sub $P3089, $P3088, 1
    store_lex "$count", $P3089
.annotate 'line', 943
    find_lex $P3090, "$count"
    set $I3091, $P3090
    find_lex $P3092, "$/"
    unless_null $P3092, vivify_1493
    $P3092 = root_new ['parrot';'Hash']
  vivify_1493:
    set $P3093, $P3092["xblock"]
    unless_null $P3093, vivify_1494
    $P3093 = root_new ['parrot';'ResizablePMCArray']
  vivify_1494:
    set $P3094, $P3093[$I3091]
    unless_null $P3094, vivify_1495
    new $P3094, "Undef"
  vivify_1495:
    $P3095 = $P3094."ast"()
    $P3096 = "xblock_immediate"($P3095)
    store_lex "$past", $P3096
.annotate 'line', 944
    find_lex $P3098, "$/"
    unless_null $P3098, vivify_1496
    $P3098 = root_new ['parrot';'Hash']
  vivify_1496:
    set $P3099, $P3098["else"]
    unless_null $P3099, vivify_1497
    new $P3099, "Undef"
  vivify_1497:
    unless $P3099, if_3097_end
.annotate 'line', 945
    find_lex $P3100, "$past"
    find_lex $P3101, "$/"
    unless_null $P3101, vivify_1498
    $P3101 = root_new ['parrot';'Hash']
  vivify_1498:
    set $P3102, $P3101["else"]
    unless_null $P3102, vivify_1499
    $P3102 = root_new ['parrot';'ResizablePMCArray']
  vivify_1499:
    set $P3103, $P3102[0]
    unless_null $P3103, vivify_1500
    new $P3103, "Undef"
  vivify_1500:
    $P3104 = $P3103."ast"()
    $P3105 = "block_immediate"($P3104)
    $P3100."push"($P3105)
  if_3097_end:
.annotate 'line', 948
    new $P3126, 'ExceptionHandler'
    set_label $P3126, loop3125_handler
    $P3126."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3126
  loop3125_test:
    find_lex $P3106, "$count"
    set $N3107, $P3106
    isgt $I3108, $N3107, 0.0
    unless $I3108, loop3125_done
  loop3125_redo:
    .const 'Sub' $P3110 = "438_1300146757.646" 
    capture_lex $P3110
    $P3110()
  loop3125_next:
    goto loop3125_test
  loop3125_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3127, exception, 'type'
    eq $P3127, .CONTROL_LOOP_NEXT, loop3125_next
    eq $P3127, .CONTROL_LOOP_REDO, loop3125_redo
  loop3125_done:
    pop_eh 
.annotate 'line', 954
    find_lex $P3128, "$/"
    find_lex $P3129, "$past"
    $P3130 = $P3128."!make"($P3129)
.annotate 'line', 941
    .return ($P3130)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3109"  :anon :subid("438_1300146757.646") :outer("437_1300146757.646")
.annotate 'line', 950
    new $P3111, "Undef"
    .lex "$else", $P3111
.annotate 'line', 948
    find_lex $P3112, "$count"
    clone $P3113, $P3112
    dec $P3112
.annotate 'line', 950
    find_lex $P3114, "$past"
    store_lex "$else", $P3114
.annotate 'line', 951
    find_lex $P3115, "$count"
    set $I3116, $P3115
    find_lex $P3117, "$/"
    unless_null $P3117, vivify_1501
    $P3117 = root_new ['parrot';'Hash']
  vivify_1501:
    set $P3118, $P3117["xblock"]
    unless_null $P3118, vivify_1502
    $P3118 = root_new ['parrot';'ResizablePMCArray']
  vivify_1502:
    set $P3119, $P3118[$I3116]
    unless_null $P3119, vivify_1503
    new $P3119, "Undef"
  vivify_1503:
    $P3120 = $P3119."ast"()
    $P3121 = "xblock_immediate"($P3120)
    store_lex "$past", $P3121
.annotate 'line', 952
    find_lex $P3122, "$past"
    find_lex $P3123, "$else"
    $P3124 = $P3122."push"($P3123)
.annotate 'line', 948
    .return ($P3124)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<unless>"  :subid("439_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3132
    .param pmc param_3133
.annotate 'line', 957
    .lex "self", param_3132
    .lex "$/", param_3133
.annotate 'line', 958
    new $P3134, "Undef"
    .lex "$past", $P3134
    find_lex $P3135, "$/"
    unless_null $P3135, vivify_1504
    $P3135 = root_new ['parrot';'Hash']
  vivify_1504:
    set $P3136, $P3135["xblock"]
    unless_null $P3136, vivify_1505
    new $P3136, "Undef"
  vivify_1505:
    $P3137 = $P3136."ast"()
    $P3138 = "xblock_immediate"($P3137)
    store_lex "$past", $P3138
.annotate 'line', 959
    find_lex $P3139, "$past"
    $P3139."pasttype"("unless")
.annotate 'line', 960
    find_lex $P3140, "$/"
    find_lex $P3141, "$past"
    $P3142 = $P3140."!make"($P3141)
.annotate 'line', 957
    .return ($P3142)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<while>"  :subid("440_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3144
    .param pmc param_3145
.annotate 'line', 963
    .lex "self", param_3144
    .lex "$/", param_3145
.annotate 'line', 964
    new $P3146, "Undef"
    .lex "$past", $P3146
    find_lex $P3147, "$/"
    unless_null $P3147, vivify_1506
    $P3147 = root_new ['parrot';'Hash']
  vivify_1506:
    set $P3148, $P3147["xblock"]
    unless_null $P3148, vivify_1507
    new $P3148, "Undef"
  vivify_1507:
    $P3149 = $P3148."ast"()
    $P3150 = "xblock_immediate"($P3149)
    store_lex "$past", $P3150
.annotate 'line', 965
    find_lex $P3151, "$past"
    find_lex $P3152, "$/"
    unless_null $P3152, vivify_1508
    $P3152 = root_new ['parrot';'Hash']
  vivify_1508:
    set $P3153, $P3152["sym"]
    unless_null $P3153, vivify_1509
    new $P3153, "Undef"
  vivify_1509:
    set $S3154, $P3153
    $P3151."pasttype"($S3154)
.annotate 'line', 966
    find_lex $P3155, "$/"
    find_lex $P3156, "$past"
    $P3157 = $P3155."!make"($P3156)
.annotate 'line', 963
    .return ($P3157)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<repeat>"  :subid("441_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3159
    .param pmc param_3160
.annotate 'line', 969
    .lex "self", param_3159
    .lex "$/", param_3160
.annotate 'line', 970
    new $P3161, "Undef"
    .lex "$pasttype", $P3161
.annotate 'line', 971
    new $P3162, "Undef"
    .lex "$past", $P3162
.annotate 'line', 970
    new $P3163, "String"
    assign $P3163, "repeat_"
    find_lex $P3164, "$/"
    unless_null $P3164, vivify_1510
    $P3164 = root_new ['parrot';'Hash']
  vivify_1510:
    set $P3165, $P3164["wu"]
    unless_null $P3165, vivify_1511
    new $P3165, "Undef"
  vivify_1511:
    set $S3166, $P3165
    concat $P3167, $P3163, $S3166
    store_lex "$pasttype", $P3167
    find_lex $P3168, "$past"
.annotate 'line', 972
    find_lex $P3170, "$/"
    unless_null $P3170, vivify_1512
    $P3170 = root_new ['parrot';'Hash']
  vivify_1512:
    set $P3171, $P3170["xblock"]
    unless_null $P3171, vivify_1513
    new $P3171, "Undef"
  vivify_1513:
    if $P3171, if_3169
.annotate 'line', 977
    get_hll_global $P3178, ["PAST"], "Op"
    find_lex $P3179, "$/"
    unless_null $P3179, vivify_1514
    $P3179 = root_new ['parrot';'Hash']
  vivify_1514:
    set $P3180, $P3179["EXPR"]
    unless_null $P3180, vivify_1515
    new $P3180, "Undef"
  vivify_1515:
    $P3181 = $P3180."ast"()
    find_lex $P3182, "$/"
    unless_null $P3182, vivify_1516
    $P3182 = root_new ['parrot';'Hash']
  vivify_1516:
    set $P3183, $P3182["pblock"]
    unless_null $P3183, vivify_1517
    new $P3183, "Undef"
  vivify_1517:
    $P3184 = $P3183."ast"()
    $P3185 = "block_immediate"($P3184)
    find_lex $P3186, "$pasttype"
    find_lex $P3187, "$/"
    $P3188 = $P3178."new"($P3181, $P3185, $P3186 :named("pasttype"), $P3187 :named("node"))
    store_lex "$past", $P3188
.annotate 'line', 976
    goto if_3169_end
  if_3169:
.annotate 'line', 973
    find_lex $P3172, "$/"
    unless_null $P3172, vivify_1518
    $P3172 = root_new ['parrot';'Hash']
  vivify_1518:
    set $P3173, $P3172["xblock"]
    unless_null $P3173, vivify_1519
    new $P3173, "Undef"
  vivify_1519:
    $P3174 = $P3173."ast"()
    $P3175 = "xblock_immediate"($P3174)
    store_lex "$past", $P3175
.annotate 'line', 974
    find_lex $P3176, "$past"
    find_lex $P3177, "$pasttype"
    $P3176."pasttype"($P3177)
  if_3169_end:
.annotate 'line', 980
    find_lex $P3189, "$/"
    find_lex $P3190, "$past"
    $P3191 = $P3189."!make"($P3190)
.annotate 'line', 969
    .return ($P3191)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<for>"  :subid("442_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3193
    .param pmc param_3194
.annotate 'line', 983
    .lex "self", param_3193
    .lex "$/", param_3194
.annotate 'line', 984
    new $P3195, "Undef"
    .lex "$past", $P3195
.annotate 'line', 986
    new $P3196, "Undef"
    .lex "$block", $P3196
.annotate 'line', 984
    find_lex $P3197, "$/"
    unless_null $P3197, vivify_1520
    $P3197 = root_new ['parrot';'Hash']
  vivify_1520:
    set $P3198, $P3197["xblock"]
    unless_null $P3198, vivify_1521
    new $P3198, "Undef"
  vivify_1521:
    $P3199 = $P3198."ast"()
    store_lex "$past", $P3199
.annotate 'line', 985
    find_lex $P3200, "$past"
    $P3200."pasttype"("for")
.annotate 'line', 986
    find_lex $P3201, "$past"
    unless_null $P3201, vivify_1522
    $P3201 = root_new ['parrot';'ResizablePMCArray']
  vivify_1522:
    set $P3202, $P3201[1]
    unless_null $P3202, vivify_1523
    new $P3202, "Undef"
  vivify_1523:
    store_lex "$block", $P3202
.annotate 'line', 987
    find_lex $P3204, "$block"
    $P3205 = $P3204."arity"()
    if $P3205, unless_3203_end
.annotate 'line', 988
    find_lex $P3206, "$block"
    unless_null $P3206, vivify_1524
    $P3206 = root_new ['parrot';'ResizablePMCArray']
  vivify_1524:
    set $P3207, $P3206[0]
    unless_null $P3207, vivify_1525
    new $P3207, "Undef"
  vivify_1525:
    get_hll_global $P3208, ["PAST"], "Var"
    $P3209 = $P3208."new"("$_" :named("name"), "parameter" :named("scope"))
    $P3207."push"($P3209)
.annotate 'line', 989
    find_lex $P3210, "$block"
    $P3210."symbol"("$_", "lexical" :named("scope"))
.annotate 'line', 990
    find_lex $P3211, "$block"
    $P3211."arity"(1)
  unless_3203_end:
.annotate 'line', 992
    find_lex $P3212, "$block"
    $P3212."blocktype"("immediate")
.annotate 'line', 993
    find_lex $P3213, "$/"
    find_lex $P3214, "$past"
    $P3215 = $P3213."!make"($P3214)
.annotate 'line', 983
    .return ($P3215)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CATCH>"  :subid("443_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3217
    .param pmc param_3218
.annotate 'line', 996
    .lex "self", param_3217
    .lex "$/", param_3218
.annotate 'line', 997
    new $P3219, "Undef"
    .lex "$block", $P3219
    find_lex $P3220, "$/"
    unless_null $P3220, vivify_1526
    $P3220 = root_new ['parrot';'Hash']
  vivify_1526:
    set $P3221, $P3220["block"]
    unless_null $P3221, vivify_1527
    new $P3221, "Undef"
  vivify_1527:
    $P3222 = $P3221."ast"()
    store_lex "$block", $P3222
.annotate 'line', 998
    find_lex $P3223, "$/"
    find_lex $P3224, "$block"
    "push_block_handler"($P3223, $P3224)
.annotate 'line', 999
    get_global $P3225, "@BLOCK"
    unless_null $P3225, vivify_1528
    $P3225 = root_new ['parrot';'ResizablePMCArray']
  vivify_1528:
    set $P3226, $P3225[0]
    unless_null $P3226, vivify_1529
    new $P3226, "Undef"
  vivify_1529:
    $P3227 = $P3226."handlers"()
    set $P3228, $P3227[0]
    unless_null $P3228, vivify_1530
    new $P3228, "Undef"
  vivify_1530:
    $P3228."handle_types_except"("CONTROL")
.annotate 'line', 1000
    find_lex $P3229, "$/"
    get_hll_global $P3230, ["PAST"], "Stmts"
    find_lex $P3231, "$/"
    $P3232 = $P3230."new"($P3231 :named("node"))
    $P3233 = $P3229."!make"($P3232)
.annotate 'line', 996
    .return ($P3233)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_control:sym<CONTROL>"  :subid("444_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3235
    .param pmc param_3236
.annotate 'line', 1003
    .lex "self", param_3235
    .lex "$/", param_3236
.annotate 'line', 1004
    new $P3237, "Undef"
    .lex "$block", $P3237
    find_lex $P3238, "$/"
    unless_null $P3238, vivify_1531
    $P3238 = root_new ['parrot';'Hash']
  vivify_1531:
    set $P3239, $P3238["block"]
    unless_null $P3239, vivify_1532
    new $P3239, "Undef"
  vivify_1532:
    $P3240 = $P3239."ast"()
    store_lex "$block", $P3240
.annotate 'line', 1005
    find_lex $P3241, "$/"
    find_lex $P3242, "$block"
    "push_block_handler"($P3241, $P3242)
.annotate 'line', 1006
    get_global $P3243, "@BLOCK"
    unless_null $P3243, vivify_1533
    $P3243 = root_new ['parrot';'ResizablePMCArray']
  vivify_1533:
    set $P3244, $P3243[0]
    unless_null $P3244, vivify_1534
    new $P3244, "Undef"
  vivify_1534:
    $P3245 = $P3244."handlers"()
    set $P3246, $P3245[0]
    unless_null $P3246, vivify_1535
    new $P3246, "Undef"
  vivify_1535:
    $P3246."handle_types"("CONTROL")
.annotate 'line', 1007
    find_lex $P3247, "$/"
    get_hll_global $P3248, ["PAST"], "Stmts"
    find_lex $P3249, "$/"
    $P3250 = $P3248."new"($P3249 :named("node"))
    $P3251 = $P3247."!make"($P3250)
.annotate 'line', 1003
    .return ($P3251)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<INIT>"  :subid("445_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3254
    .param pmc param_3255
.annotate 'line', 1047
    .lex "self", param_3254
    .lex "$/", param_3255
.annotate 'line', 1048
    new $P3256, "Undef"
    .lex "$init_block", $P3256
    get_hll_global $P3257, ["PAST"], "Block"
    $P3258 = $P3257."new"("immediate" :named("blocktype"))
    store_lex "$init_block", $P3258
.annotate 'line', 1049
    find_lex $P3259, "$init_block"
    $P3260 = $P3259."loadinit"()
    find_lex $P3261, "$/"
    unless_null $P3261, vivify_1536
    $P3261 = root_new ['parrot';'Hash']
  vivify_1536:
    set $P3262, $P3261["blorst"]
    unless_null $P3262, vivify_1537
    new $P3262, "Undef"
  vivify_1537:
    $P3263 = $P3262."ast"()
    $P3260."push"($P3263)
.annotate 'line', 1050
    find_lex $P3264, "$/"
    find_lex $P3265, "$init_block"
    $P3266 = $P3264."!make"($P3265)
.annotate 'line', 1047
    .return ($P3266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_prefix:sym<try>"  :subid("446_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3268
    .param pmc param_3269
.annotate 'line', 1053
    .lex "self", param_3268
    .lex "$/", param_3269
.annotate 'line', 1054
    new $P3270, "Undef"
    .lex "$past", $P3270
    find_lex $P3271, "$/"
    unless_null $P3271, vivify_1538
    $P3271 = root_new ['parrot';'Hash']
  vivify_1538:
    set $P3272, $P3271["blorst"]
    unless_null $P3272, vivify_1539
    new $P3272, "Undef"
  vivify_1539:
    $P3273 = $P3272."ast"()
    store_lex "$past", $P3273
.annotate 'line', 1055
    get_hll_global $P3275, ["PAST"], "Block"
    find_lex $P3276, "$past"
    $P3277 = $P3275."ACCEPTS"($P3276)
    if $P3277, unless_3274_end
.annotate 'line', 1056
    get_hll_global $P3278, ["PAST"], "Block"
    find_lex $P3279, "$past"
    find_lex $P3280, "$/"
    $P3281 = $P3278."new"($P3279, "immediate" :named("blocktype"), $P3280 :named("node"))
    store_lex "$past", $P3281
  unless_3274_end:
.annotate 'line', 1058
    find_lex $P3283, "$past"
    $P3284 = $P3283."handlers"()
    if $P3284, unless_3282_end
.annotate 'line', 1059
    find_lex $P3285, "$past"
    get_hll_global $P3286, ["PAST"], "Control"
.annotate 'line', 1061
    get_hll_global $P3287, ["PAST"], "Stmts"
.annotate 'line', 1062
    get_hll_global $P3288, ["PAST"], "Op"
.annotate 'line', 1063
    get_hll_global $P3289, ["PAST"], "Var"
.annotate 'line', 1064
    get_hll_global $P3290, ["PAST"], "Var"
    $P3291 = $P3290."new"("register" :named("scope"), "exception" :named("name"))
    $P3292 = $P3289."new"($P3291, "handled", "keyed" :named("scope"))
.annotate 'line', 1063
    $P3293 = $P3288."new"($P3292, 1, "bind" :named("pasttype"))
.annotate 'line', 1062
    $P3294 = $P3287."new"($P3293)
.annotate 'line', 1061
    $P3295 = $P3286."new"($P3294, "CONTROL" :named("handle_types_except"))
.annotate 'line', 1059
    new $P3296, "ResizablePMCArray"
    push $P3296, $P3295
    $P3285."handlers"($P3296)
  unless_3282_end:
.annotate 'line', 1073
    find_lex $P3297, "$/"
    find_lex $P3298, "$past"
    $P3299 = $P3297."!make"($P3298)
.annotate 'line', 1053
    .return ($P3299)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "blorst"  :subid("447_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3301
    .param pmc param_3302
.annotate 'line', 1076
    .lex "self", param_3301
    .lex "$/", param_3302
.annotate 'line', 1077
    find_lex $P3303, "$/"
.annotate 'line', 1078
    find_lex $P3306, "$/"
    unless_null $P3306, vivify_1540
    $P3306 = root_new ['parrot';'Hash']
  vivify_1540:
    set $P3307, $P3306["block"]
    unless_null $P3307, vivify_1541
    new $P3307, "Undef"
  vivify_1541:
    if $P3307, if_3305
.annotate 'line', 1079
    find_lex $P3312, "$/"
    unless_null $P3312, vivify_1542
    $P3312 = root_new ['parrot';'Hash']
  vivify_1542:
    set $P3313, $P3312["statement"]
    unless_null $P3313, vivify_1543
    new $P3313, "Undef"
  vivify_1543:
    $P3314 = $P3313."ast"()
    set $P3304, $P3314
.annotate 'line', 1078
    goto if_3305_end
  if_3305:
    find_lex $P3308, "$/"
    unless_null $P3308, vivify_1544
    $P3308 = root_new ['parrot';'Hash']
  vivify_1544:
    set $P3309, $P3308["block"]
    unless_null $P3309, vivify_1545
    new $P3309, "Undef"
  vivify_1545:
    $P3310 = $P3309."ast"()
    $P3311 = "block_immediate"($P3310)
    set $P3304, $P3311
  if_3305_end:
    $P3315 = $P3303."!make"($P3304)
.annotate 'line', 1076
    .return ($P3315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<if>"  :subid("448_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3317
    .param pmc param_3318
.annotate 'line', 1084
    .lex "self", param_3317
    .lex "$/", param_3318
    find_lex $P3319, "$/"
    find_lex $P3320, "$/"
    unless_null $P3320, vivify_1546
    $P3320 = root_new ['parrot';'Hash']
  vivify_1546:
    set $P3321, $P3320["cond"]
    unless_null $P3321, vivify_1547
    new $P3321, "Undef"
  vivify_1547:
    $P3322 = $P3321."ast"()
    $P3323 = $P3319."!make"($P3322)
    .return ($P3323)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_cond:sym<unless>"  :subid("449_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3325
    .param pmc param_3326
.annotate 'line', 1085
    .lex "self", param_3325
    .lex "$/", param_3326
    find_lex $P3327, "$/"
    find_lex $P3328, "$/"
    unless_null $P3328, vivify_1548
    $P3328 = root_new ['parrot';'Hash']
  vivify_1548:
    set $P3329, $P3328["cond"]
    unless_null $P3329, vivify_1549
    new $P3329, "Undef"
  vivify_1549:
    $P3330 = $P3329."ast"()
    $P3331 = $P3327."!make"($P3330)
    .return ($P3331)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<while>"  :subid("450_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3333
    .param pmc param_3334
.annotate 'line', 1087
    .lex "self", param_3333
    .lex "$/", param_3334
    find_lex $P3335, "$/"
    find_lex $P3336, "$/"
    unless_null $P3336, vivify_1550
    $P3336 = root_new ['parrot';'Hash']
  vivify_1550:
    set $P3337, $P3336["cond"]
    unless_null $P3337, vivify_1551
    new $P3337, "Undef"
  vivify_1551:
    $P3338 = $P3337."ast"()
    $P3339 = $P3335."!make"($P3338)
    .return ($P3339)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "statement_mod_loop:sym<until>"  :subid("451_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3341
    .param pmc param_3342
.annotate 'line', 1088
    .lex "self", param_3341
    .lex "$/", param_3342
    find_lex $P3343, "$/"
    find_lex $P3344, "$/"
    unless_null $P3344, vivify_1552
    $P3344 = root_new ['parrot';'Hash']
  vivify_1552:
    set $P3345, $P3344["cond"]
    unless_null $P3345, vivify_1553
    new $P3345, "Undef"
  vivify_1553:
    $P3346 = $P3345."ast"()
    $P3347 = $P3343."!make"($P3346)
    .return ($P3347)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<fatarrow>"  :subid("452_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3349
    .param pmc param_3350
.annotate 'line', 1092
    .lex "self", param_3349
    .lex "$/", param_3350
    find_lex $P3351, "$/"
    find_lex $P3352, "$/"
    unless_null $P3352, vivify_1554
    $P3352 = root_new ['parrot';'Hash']
  vivify_1554:
    set $P3353, $P3352["fatarrow"]
    unless_null $P3353, vivify_1555
    new $P3353, "Undef"
  vivify_1555:
    $P3354 = $P3353."ast"()
    $P3355 = $P3351."!make"($P3354)
    .return ($P3355)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<colonpair>"  :subid("453_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3357
    .param pmc param_3358
.annotate 'line', 1093
    .lex "self", param_3357
    .lex "$/", param_3358
    find_lex $P3359, "$/"
    find_lex $P3360, "$/"
    unless_null $P3360, vivify_1556
    $P3360 = root_new ['parrot';'Hash']
  vivify_1556:
    set $P3361, $P3360["colonpair"]
    unless_null $P3361, vivify_1557
    new $P3361, "Undef"
  vivify_1557:
    $P3362 = $P3361."ast"()
    $P3363 = $P3359."!make"($P3362)
    .return ($P3363)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<variable>"  :subid("454_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3365
    .param pmc param_3366
.annotate 'line', 1094
    .lex "self", param_3365
    .lex "$/", param_3366
    find_lex $P3367, "$/"
    find_lex $P3368, "$/"
    unless_null $P3368, vivify_1558
    $P3368 = root_new ['parrot';'Hash']
  vivify_1558:
    set $P3369, $P3368["variable"]
    unless_null $P3369, vivify_1559
    new $P3369, "Undef"
  vivify_1559:
    $P3370 = $P3369."ast"()
    $P3371 = $P3367."!make"($P3370)
    .return ($P3371)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<package_declarator>"  :subid("455_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3373
    .param pmc param_3374
.annotate 'line', 1095
    .lex "self", param_3373
    .lex "$/", param_3374
    find_lex $P3375, "$/"
    find_lex $P3376, "$/"
    unless_null $P3376, vivify_1560
    $P3376 = root_new ['parrot';'Hash']
  vivify_1560:
    set $P3377, $P3376["package_declarator"]
    unless_null $P3377, vivify_1561
    new $P3377, "Undef"
  vivify_1561:
    $P3378 = $P3377."ast"()
    $P3379 = $P3375."!make"($P3378)
    .return ($P3379)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<scope_declarator>"  :subid("456_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3381
    .param pmc param_3382
.annotate 'line', 1096
    .lex "self", param_3381
    .lex "$/", param_3382
    find_lex $P3383, "$/"
    find_lex $P3384, "$/"
    unless_null $P3384, vivify_1562
    $P3384 = root_new ['parrot';'Hash']
  vivify_1562:
    set $P3385, $P3384["scope_declarator"]
    unless_null $P3385, vivify_1563
    new $P3385, "Undef"
  vivify_1563:
    $P3386 = $P3385."ast"()
    $P3387 = $P3383."!make"($P3386)
    .return ($P3387)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<routine_declarator>"  :subid("457_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3389
    .param pmc param_3390
.annotate 'line', 1097
    .lex "self", param_3389
    .lex "$/", param_3390
    find_lex $P3391, "$/"
    find_lex $P3392, "$/"
    unless_null $P3392, vivify_1564
    $P3392 = root_new ['parrot';'Hash']
  vivify_1564:
    set $P3393, $P3392["routine_declarator"]
    unless_null $P3393, vivify_1565
    new $P3393, "Undef"
  vivify_1565:
    $P3394 = $P3393."ast"()
    $P3395 = $P3391."!make"($P3394)
    .return ($P3395)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<regex_declarator>"  :subid("458_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3397
    .param pmc param_3398
.annotate 'line', 1098
    .lex "self", param_3397
    .lex "$/", param_3398
    find_lex $P3399, "$/"
    find_lex $P3400, "$/"
    unless_null $P3400, vivify_1566
    $P3400 = root_new ['parrot';'Hash']
  vivify_1566:
    set $P3401, $P3400["regex_declarator"]
    unless_null $P3401, vivify_1567
    new $P3401, "Undef"
  vivify_1567:
    $P3402 = $P3401."ast"()
    $P3403 = $P3399."!make"($P3402)
    .return ($P3403)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<statement_prefix>"  :subid("459_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3405
    .param pmc param_3406
.annotate 'line', 1099
    .lex "self", param_3405
    .lex "$/", param_3406
    find_lex $P3407, "$/"
    find_lex $P3408, "$/"
    unless_null $P3408, vivify_1568
    $P3408 = root_new ['parrot';'Hash']
  vivify_1568:
    set $P3409, $P3408["statement_prefix"]
    unless_null $P3409, vivify_1569
    new $P3409, "Undef"
  vivify_1569:
    $P3410 = $P3409."ast"()
    $P3411 = $P3407."!make"($P3410)
    .return ($P3411)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<lambda>"  :subid("460_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3413
    .param pmc param_3414
.annotate 'line', 1100
    .lex "self", param_3413
    .lex "$/", param_3414
    find_lex $P3415, "$/"
    find_lex $P3416, "$/"
    unless_null $P3416, vivify_1570
    $P3416 = root_new ['parrot';'Hash']
  vivify_1570:
    set $P3417, $P3416["pblock"]
    unless_null $P3417, vivify_1571
    new $P3417, "Undef"
  vivify_1571:
    $P3418 = $P3417."ast"()
    $P3419 = $P3415."!make"($P3418)
    .return ($P3419)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "fatarrow"  :subid("461_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3421
    .param pmc param_3422
.annotate 'line', 1102
    .lex "self", param_3421
    .lex "$/", param_3422
.annotate 'line', 1103
    new $P3423, "Undef"
    .lex "$past", $P3423
    find_lex $P3424, "$/"
    unless_null $P3424, vivify_1572
    $P3424 = root_new ['parrot';'Hash']
  vivify_1572:
    set $P3425, $P3424["val"]
    unless_null $P3425, vivify_1573
    new $P3425, "Undef"
  vivify_1573:
    $P3426 = $P3425."ast"()
    store_lex "$past", $P3426
.annotate 'line', 1104
    find_lex $P3427, "$past"
    find_lex $P3428, "$/"
    unless_null $P3428, vivify_1574
    $P3428 = root_new ['parrot';'Hash']
  vivify_1574:
    set $P3429, $P3428["key"]
    unless_null $P3429, vivify_1575
    new $P3429, "Undef"
  vivify_1575:
    $P3430 = $P3429."Str"()
    $P3427."named"($P3430)
.annotate 'line', 1105
    find_lex $P3431, "$/"
    find_lex $P3432, "$past"
    $P3433 = $P3431."!make"($P3432)
.annotate 'line', 1102
    .return ($P3433)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "colonpair"  :subid("462_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3435
    .param pmc param_3436
.annotate 'line', 1108
    .lex "self", param_3435
    .lex "$/", param_3436
.annotate 'line', 1109
    new $P3437, "Undef"
    .lex "$past", $P3437
.annotate 'line', 1110
    find_lex $P3440, "$/"
    unless_null $P3440, vivify_1576
    $P3440 = root_new ['parrot';'Hash']
  vivify_1576:
    set $P3441, $P3440["circumfix"]
    unless_null $P3441, vivify_1577
    new $P3441, "Undef"
  vivify_1577:
    if $P3441, if_3439
.annotate 'line', 1111
    get_hll_global $P3446, ["PAST"], "Val"
    find_lex $P3447, "$/"
    unless_null $P3447, vivify_1578
    $P3447 = root_new ['parrot';'Hash']
  vivify_1578:
    set $P3448, $P3447["not"]
    unless_null $P3448, vivify_1579
    new $P3448, "Undef"
  vivify_1579:
    isfalse $I3449, $P3448
    $P3450 = $P3446."new"($I3449 :named("value"))
    set $P3438, $P3450
.annotate 'line', 1110
    goto if_3439_end
  if_3439:
    find_lex $P3442, "$/"
    unless_null $P3442, vivify_1580
    $P3442 = root_new ['parrot';'Hash']
  vivify_1580:
    set $P3443, $P3442["circumfix"]
    unless_null $P3443, vivify_1581
    $P3443 = root_new ['parrot';'ResizablePMCArray']
  vivify_1581:
    set $P3444, $P3443[0]
    unless_null $P3444, vivify_1582
    new $P3444, "Undef"
  vivify_1582:
    $P3445 = $P3444."ast"()
    set $P3438, $P3445
  if_3439_end:
    store_lex "$past", $P3438
.annotate 'line', 1112
    find_lex $P3451, "$past"
    find_lex $P3452, "$/"
    unless_null $P3452, vivify_1583
    $P3452 = root_new ['parrot';'Hash']
  vivify_1583:
    set $P3453, $P3452["identifier"]
    unless_null $P3453, vivify_1584
    new $P3453, "Undef"
  vivify_1584:
    set $S3454, $P3453
    $P3451."named"($S3454)
.annotate 'line', 1113
    find_lex $P3455, "$/"
    find_lex $P3456, "$past"
    $P3457 = $P3455."!make"($P3456)
.annotate 'line', 1108
    .return ($P3457)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable"  :subid("463_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3459
    .param pmc param_3460
.annotate 'line', 1116
    .const 'Sub' $P3473 = "464_1300146757.646" 
    capture_lex $P3473
    .lex "self", param_3459
    .lex "$/", param_3460
.annotate 'line', 1117
    new $P3461, "Undef"
    .lex "$past", $P3461
.annotate 'line', 1116
    find_lex $P3462, "$past"
.annotate 'line', 1118
    find_lex $P3464, "$/"
    unless_null $P3464, vivify_1585
    $P3464 = root_new ['parrot';'Hash']
  vivify_1585:
    set $P3465, $P3464["postcircumfix"]
    unless_null $P3465, vivify_1586
    new $P3465, "Undef"
  vivify_1586:
    if $P3465, if_3463
.annotate 'line', 1122
    .const 'Sub' $P3473 = "464_1300146757.646" 
    capture_lex $P3473
    $P3473()
    goto if_3463_end
  if_3463:
.annotate 'line', 1119
    find_lex $P3466, "$/"
    unless_null $P3466, vivify_1603
    $P3466 = root_new ['parrot';'Hash']
  vivify_1603:
    set $P3467, $P3466["postcircumfix"]
    unless_null $P3467, vivify_1604
    new $P3467, "Undef"
  vivify_1604:
    $P3468 = $P3467."ast"()
    store_lex "$past", $P3468
.annotate 'line', 1120
    find_lex $P3469, "$past"
    get_hll_global $P3470, ["PAST"], "Var"
    $P3471 = $P3470."new"("$/" :named("name"))
    $P3469."unshift"($P3471)
  if_3463_end:
.annotate 'line', 1152
    find_lex $P3545, "$/"
    find_lex $P3546, "$past"
    $P3547 = $P3545."!make"($P3546)
.annotate 'line', 1116
    .return ($P3547)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3472"  :anon :subid("464_1300146757.646") :outer("463_1300146757.646")
.annotate 'line', 1123
    $P3474 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P3474
    get_hll_global $P3475, ["NQP"], "Compiler"
    find_lex $P3476, "$/"
    set $S3477, $P3476
    $P3478 = $P3475."parse_name"($S3477)
    store_lex "@name", $P3478
.annotate 'line', 1124
    get_hll_global $P3479, ["PAST"], "Var"
    find_lex $P3480, "@name"
    $P3481 = $P3480."pop"()
    set $S3482, $P3481
    $P3483 = $P3479."new"($S3482 :named("name"))
    store_lex "$past", $P3483
.annotate 'line', 1125
    find_lex $P3485, "@name"
    unless $P3485, if_3484_end
.annotate 'line', 1126
    find_lex $P3487, "@name"
    unless_null $P3487, vivify_1587
    $P3487 = root_new ['parrot';'ResizablePMCArray']
  vivify_1587:
    set $P3488, $P3487[0]
    unless_null $P3488, vivify_1588
    new $P3488, "Undef"
  vivify_1588:
    set $S3489, $P3488
    iseq $I3490, $S3489, "GLOBAL"
    unless $I3490, if_3486_end
    find_lex $P3491, "@name"
    $P3491."shift"()
  if_3486_end:
.annotate 'line', 1127
    find_lex $P3492, "$past"
    find_lex $P3493, "@name"
    $P3492."namespace"($P3493)
.annotate 'line', 1128
    find_lex $P3494, "$past"
    $P3494."scope"("package")
.annotate 'line', 1129
    find_lex $P3495, "$past"
    find_lex $P3496, "$/"
    unless_null $P3496, vivify_1589
    $P3496 = root_new ['parrot';'Hash']
  vivify_1589:
    set $P3497, $P3496["sigil"]
    unless_null $P3497, vivify_1590
    new $P3497, "Undef"
  vivify_1590:
    $P3498 = "vivitype"($P3497)
    $P3495."viviself"($P3498)
.annotate 'line', 1130
    find_lex $P3499, "$past"
    $P3499."lvalue"(1)
  if_3484_end:
.annotate 'line', 1132
    find_lex $P3502, "$/"
    unless_null $P3502, vivify_1591
    $P3502 = root_new ['parrot';'Hash']
  vivify_1591:
    set $P3503, $P3502["twigil"]
    unless_null $P3503, vivify_1592
    $P3503 = root_new ['parrot';'ResizablePMCArray']
  vivify_1592:
    set $P3504, $P3503[0]
    unless_null $P3504, vivify_1593
    new $P3504, "Undef"
  vivify_1593:
    set $S3505, $P3504
    iseq $I3506, $S3505, "*"
    if $I3506, if_3501
.annotate 'line', 1145
    find_lex $P3528, "$/"
    unless_null $P3528, vivify_1594
    $P3528 = root_new ['parrot';'Hash']
  vivify_1594:
    set $P3529, $P3528["twigil"]
    unless_null $P3529, vivify_1595
    $P3529 = root_new ['parrot';'ResizablePMCArray']
  vivify_1595:
    set $P3530, $P3529[0]
    unless_null $P3530, vivify_1596
    new $P3530, "Undef"
  vivify_1596:
    set $S3531, $P3530
    iseq $I3532, $S3531, "!"
    if $I3532, if_3527
    new $P3526, 'Integer'
    set $P3526, $I3532
    goto if_3527_end
  if_3527:
.annotate 'line', 1146
    find_lex $P3533, "$past"
    get_hll_global $P3534, ["PAST"], "Var"
    $P3535 = $P3534."new"("self" :named("name"))
    $P3533."push"($P3535)
.annotate 'line', 1147
    find_lex $P3536, "$past"
    $P3536."scope"("attribute")
.annotate 'line', 1148
    find_lex $P3537, "$past"
    find_lex $P3538, "$/"
    unless_null $P3538, vivify_1597
    $P3538 = root_new ['parrot';'Hash']
  vivify_1597:
    set $P3539, $P3538["sigil"]
    unless_null $P3539, vivify_1598
    new $P3539, "Undef"
  vivify_1598:
    $P3540 = "vivitype"($P3539)
    $P3537."viviself"($P3540)
.annotate 'line', 1149
    find_lex $P3541, "$past"
    get_hll_global $P3542, ["PAST"], "Var"
    $P3543 = $P3542."new"("$?CLASS" :named("name"))
    $P3544 = $P3541."push"($P3543)
.annotate 'line', 1145
    set $P3526, $P3544
  if_3527_end:
    set $P3500, $P3526
.annotate 'line', 1132
    goto if_3501_end
  if_3501:
.annotate 'line', 1133
    find_lex $P3507, "$past"
    $P3507."scope"("contextual")
.annotate 'line', 1134
    find_lex $P3508, "$past"
.annotate 'line', 1135
    get_hll_global $P3509, ["PAST"], "Var"
.annotate 'line', 1137
    find_lex $P3510, "$/"
    unless_null $P3510, vivify_1599
    $P3510 = root_new ['parrot';'Hash']
  vivify_1599:
    set $P3511, $P3510["sigil"]
    unless_null $P3511, vivify_1600
    new $P3511, "Undef"
  vivify_1600:
    set $S3512, $P3511
    new $P3513, 'String'
    set $P3513, $S3512
    find_lex $P3514, "$/"
    unless_null $P3514, vivify_1601
    $P3514 = root_new ['parrot';'Hash']
  vivify_1601:
    set $P3515, $P3514["desigilname"]
    unless_null $P3515, vivify_1602
    new $P3515, "Undef"
  vivify_1602:
    concat $P3516, $P3513, $P3515
.annotate 'line', 1139
    get_hll_global $P3517, ["PAST"], "Op"
    new $P3518, "String"
    assign $P3518, "Contextual "
    find_lex $P3519, "$/"
    set $S3520, $P3519
    concat $P3521, $P3518, $S3520
    concat $P3522, $P3521, " not found"
    $P3523 = $P3517."new"($P3522, "die" :named("pirop"))
    $P3524 = $P3509."new"("package" :named("scope"), "" :named("namespace"), $P3516 :named("name"), $P3523 :named("viviself"))
.annotate 'line', 1135
    $P3525 = $P3508."viviself"($P3524)
.annotate 'line', 1132
    set $P3500, $P3525
  if_3501_end:
.annotate 'line', 1122
    .return ($P3500)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<module>"  :subid("465_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3549
    .param pmc param_3550
.annotate 'line', 1155
    .lex "self", param_3549
    .lex "$/", param_3550
    find_lex $P3551, "$/"
    find_lex $P3552, "$/"
    unless_null $P3552, vivify_1605
    $P3552 = root_new ['parrot';'Hash']
  vivify_1605:
    set $P3553, $P3552["package_def"]
    unless_null $P3553, vivify_1606
    new $P3553, "Undef"
  vivify_1606:
    $P3554 = $P3553."ast"()
    $P3555 = $P3551."!make"($P3554)
    .return ($P3555)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<knowhow>"  :subid("466_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3557
    .param pmc param_3558
.annotate 'line', 1156
    .lex "self", param_3557
    .lex "$/", param_3558
    find_lex $P3559, "$/"
    find_lex $P3560, "$/"
    unless_null $P3560, vivify_1607
    $P3560 = root_new ['parrot';'Hash']
  vivify_1607:
    set $P3561, $P3560["package_def"]
    unless_null $P3561, vivify_1608
    new $P3561, "Undef"
  vivify_1608:
    $P3562 = $P3561."ast"()
    $P3563 = $P3559."!make"($P3562)
    .return ($P3563)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<class>"  :subid("467_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3565
    .param pmc param_3566
.annotate 'line', 1157
    .lex "self", param_3565
    .lex "$/", param_3566
    find_lex $P3567, "$/"
    find_lex $P3568, "$/"
    unless_null $P3568, vivify_1609
    $P3568 = root_new ['parrot';'Hash']
  vivify_1609:
    set $P3569, $P3568["package_def"]
    unless_null $P3569, vivify_1610
    new $P3569, "Undef"
  vivify_1610:
    $P3570 = $P3569."ast"()
    $P3571 = $P3567."!make"($P3570)
    .return ($P3571)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<grammar>"  :subid("468_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3573
    .param pmc param_3574
.annotate 'line', 1158
    .lex "self", param_3573
    .lex "$/", param_3574
    find_lex $P3575, "$/"
    find_lex $P3576, "$/"
    unless_null $P3576, vivify_1611
    $P3576 = root_new ['parrot';'Hash']
  vivify_1611:
    set $P3577, $P3576["package_def"]
    unless_null $P3577, vivify_1612
    new $P3577, "Undef"
  vivify_1612:
    $P3578 = $P3577."ast"()
    $P3579 = $P3575."!make"($P3578)
    .return ($P3579)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<role>"  :subid("469_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3581
    .param pmc param_3582
.annotate 'line', 1159
    .lex "self", param_3581
    .lex "$/", param_3582
    find_lex $P3583, "$/"
    find_lex $P3584, "$/"
    unless_null $P3584, vivify_1613
    $P3584 = root_new ['parrot';'Hash']
  vivify_1613:
    set $P3585, $P3584["package_def"]
    unless_null $P3585, vivify_1614
    new $P3585, "Undef"
  vivify_1614:
    $P3586 = $P3585."ast"()
    $P3587 = $P3583."!make"($P3586)
    .return ($P3587)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "package_declarator:sym<native>"  :subid("470_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3589
    .param pmc param_3590
.annotate 'line', 1160
    .lex "self", param_3589
    .lex "$/", param_3590
    find_lex $P3591, "$/"
    find_lex $P3592, "$/"
    unless_null $P3592, vivify_1615
    $P3592 = root_new ['parrot';'Hash']
  vivify_1615:
    set $P3593, $P3592["package_def"]
    unless_null $P3593, vivify_1616
    new $P3593, "Undef"
  vivify_1616:
    $P3594 = $P3593."ast"()
    $P3595 = $P3591."!make"($P3594)
    .return ($P3595)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "package_def"  :subid("471_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3597
    .param pmc param_3598
.annotate 'line', 1162
    .const 'Sub' $P3747 = "473_1300146757.646" 
    capture_lex $P3747
    .const 'Sub' $P3696 = "472_1300146757.646" 
    capture_lex $P3696
    .lex "self", param_3597
    .lex "$/", param_3598
.annotate 'line', 1164
    $P3599 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3599
.annotate 'line', 1165
    new $P3600, "Undef"
    .lex "$name", $P3600
.annotate 'line', 1166
    new $P3601, "Undef"
    .lex "$how", $P3601
.annotate 'line', 1169
    new $P3602, "Undef"
    .lex "$past", $P3602
.annotate 'line', 1164
    find_lex $P3603, "$/"
    unless_null $P3603, vivify_1617
    $P3603 = root_new ['parrot';'Hash']
  vivify_1617:
    set $P3604, $P3603["name"]
    unless_null $P3604, vivify_1618
    $P3604 = root_new ['parrot';'Hash']
  vivify_1618:
    set $P3605, $P3604["identifier"]
    unless_null $P3605, vivify_1619
    new $P3605, "Undef"
  vivify_1619:
    clone $P3606, $P3605
    store_lex "@ns", $P3606
.annotate 'line', 1165
    find_lex $P3607, "@ns"
    $P3608 = $P3607."pop"()
    set $S3609, $P3608
    new $P3610, 'String'
    set $P3610, $S3609
    store_lex "$name", $P3610
.annotate 'line', 1166
    find_dynamic_lex $P3611, "$*PKGDECL"
    unless_null $P3611, vivify_1620
    get_hll_global $P3611, "$PKGDECL"
    unless_null $P3611, vivify_1621
    die "Contextual $*PKGDECL not found"
  vivify_1621:
  vivify_1620:
    find_dynamic_lex $P3612, "%*HOW"
    unless_null $P3612, vivify_1622
    get_hll_global $P3612, "%HOW"
    unless_null $P3612, vivify_1623
    die "Contextual %*HOW not found"
  vivify_1623:
  vivify_1622:
    set $P3613, $P3612[$P3611]
    unless_null $P3613, vivify_1624
    new $P3613, "Undef"
  vivify_1624:
    store_lex "$how", $P3613
.annotate 'line', 1169
    find_lex $P3616, "$/"
    unless_null $P3616, vivify_1625
    $P3616 = root_new ['parrot';'Hash']
  vivify_1625:
    set $P3617, $P3616["block"]
    unless_null $P3617, vivify_1626
    new $P3617, "Undef"
  vivify_1626:
    if $P3617, if_3615
    find_lex $P3621, "$/"
    unless_null $P3621, vivify_1627
    $P3621 = root_new ['parrot';'Hash']
  vivify_1627:
    set $P3622, $P3621["comp_unit"]
    unless_null $P3622, vivify_1628
    new $P3622, "Undef"
  vivify_1628:
    $P3623 = $P3622."ast"()
    set $P3614, $P3623
    goto if_3615_end
  if_3615:
    find_lex $P3618, "$/"
    unless_null $P3618, vivify_1629
    $P3618 = root_new ['parrot';'Hash']
  vivify_1629:
    set $P3619, $P3618["block"]
    unless_null $P3619, vivify_1630
    new $P3619, "Undef"
  vivify_1630:
    $P3620 = $P3619."ast"()
    set $P3614, $P3620
  if_3615_end:
    store_lex "$past", $P3614
.annotate 'line', 1172
    find_dynamic_lex $P3627, "$*SCOPE"
    unless_null $P3627, vivify_1631
    get_hll_global $P3627, "$SCOPE"
    unless_null $P3627, vivify_1632
    die "Contextual $*SCOPE not found"
  vivify_1632:
  vivify_1631:
    set $S3628, $P3627
    iseq $I3629, $S3628, "our"
    unless $I3629, unless_3626
    new $P3625, 'Integer'
    set $P3625, $I3629
    goto unless_3626_end
  unless_3626:
    find_dynamic_lex $P3630, "$*SCOPE"
    unless_null $P3630, vivify_1633
    get_hll_global $P3630, "$SCOPE"
    unless_null $P3630, vivify_1634
    die "Contextual $*SCOPE not found"
  vivify_1634:
  vivify_1633:
    set $S3631, $P3630
    iseq $I3632, $S3631, ""
    new $P3625, 'Integer'
    set $P3625, $I3632
  unless_3626_end:
    if $P3625, if_3624
.annotate 'line', 1177
    find_lex $P3642, "$/"
    $P3643 = $P3642."CURSOR"()
    find_dynamic_lex $P3644, "$*SCOPE"
    unless_null $P3644, vivify_1635
    get_hll_global $P3644, "$SCOPE"
    unless_null $P3644, vivify_1636
    die "Contextual $*SCOPE not found"
  vivify_1636:
  vivify_1635:
    concat $P3645, $P3644, " scoped packages are not supported"
    $P3643."panic"($P3645)
.annotate 'line', 1176
    goto if_3624_end
  if_3624:
.annotate 'line', 1173
    find_lex $P3633, "$past"
    find_lex $P3634, "$/"
    unless_null $P3634, vivify_1637
    $P3634 = root_new ['parrot';'Hash']
  vivify_1637:
    set $P3635, $P3634["name"]
    unless_null $P3635, vivify_1638
    $P3635 = root_new ['parrot';'Hash']
  vivify_1638:
    set $P3636, $P3635["identifier"]
    unless_null $P3636, vivify_1639
    new $P3636, "Undef"
  vivify_1639:
    $P3633."namespace"($P3636)
.annotate 'line', 1174
    find_dynamic_lex $P3637, "$*SC"
    unless_null $P3637, vivify_1640
    get_hll_global $P3637, "$SC"
    unless_null $P3637, vivify_1641
    die "Contextual $*SC not found"
  vivify_1641:
  vivify_1640:
    find_lex $P3638, "$/"
    unless_null $P3638, vivify_1642
    $P3638 = root_new ['parrot';'Hash']
  vivify_1642:
    set $P3639, $P3638["name"]
    unless_null $P3639, vivify_1643
    $P3639 = root_new ['parrot';'Hash']
  vivify_1643:
    set $P3640, $P3639["identifier"]
    unless_null $P3640, vivify_1644
    new $P3640, "Undef"
  vivify_1644:
    find_dynamic_lex $P3641, "$*PKGMETA"
    unless_null $P3641, vivify_1645
    get_hll_global $P3641, "$PKGMETA"
    unless_null $P3641, vivify_1646
    die "Contextual $*PKGMETA not found"
  vivify_1646:
  vivify_1645:
    $P3637."install_package_symbol"($P3640, $P3641)
  if_3624_end:
.annotate 'line', 1181
    find_dynamic_lex $P3646, "$*PACKAGE-SETUP"
    unless_null $P3646, vivify_1647
    get_hll_global $P3646, "$PACKAGE-SETUP"
    unless_null $P3646, vivify_1648
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1648:
  vivify_1647:
    get_hll_global $P3647, ["PAST"], "Stmts"
.annotate 'line', 1182
    get_hll_global $P3648, ["PAST"], "Op"
.annotate 'line', 1183
    get_hll_global $P3649, ["PAST"], "Var"
    $P3650 = $P3649."new"("type_obj" :named("name"), "register" :named("scope"), 1 :named("isdecl"))
.annotate 'line', 1184
    find_dynamic_lex $P3651, "$*SC"
    unless_null $P3651, vivify_1649
    get_hll_global $P3651, "$SC"
    unless_null $P3651, vivify_1650
    die "Contextual $*SC not found"
  vivify_1650:
  vivify_1649:
    find_dynamic_lex $P3652, "$*PKGMETA"
    unless_null $P3652, vivify_1651
    get_hll_global $P3652, "$PKGMETA"
    unless_null $P3652, vivify_1652
    die "Contextual $*PKGMETA not found"
  vivify_1652:
  vivify_1651:
    $P3653 = $P3651."get_slot_past_for_object"($P3652)
    $P3654 = $P3648."new"($P3650, $P3653, "bind" :named("pasttype"))
.annotate 'line', 1186
    get_hll_global $P3655, ["PAST"], "Op"
.annotate 'line', 1187
    get_hll_global $P3656, ["PAST"], "Var"
    $P3657 = $P3656."new"("$?CLASS" :named("name"))
.annotate 'line', 1188
    get_hll_global $P3658, ["PAST"], "Var"
    $P3659 = $P3658."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3660 = $P3655."new"($P3657, $P3659, "bind" :named("pasttype"))
.annotate 'line', 1186
    $P3661 = $P3647."new"($P3654, $P3660)
.annotate 'line', 1181
    $P3646."unshift"($P3661)
.annotate 'line', 1197
    find_lex $P3665, "$how"
    can $I3666, $P3665, "parametric"
    if $I3666, if_3664
    new $P3663, 'Integer'
    set $P3663, $I3666
    goto if_3664_end
  if_3664:
    find_lex $P3667, "$how"
    find_lex $P3668, "$how"
    $P3669 = $P3667."parametric"($P3668)
    set $P3663, $P3669
  if_3664_end:
    if $P3663, if_3662
.annotate 'line', 1213
    find_lex $P3687, "$past"
    $P3687."blocktype"("immediate")
.annotate 'line', 1214
    find_lex $P3688, "$past"
    get_hll_global $P3689, ["PAST"], "Var"
    $P3690 = $P3689."new"("$?CLASS" :named("name"), "package" :named("scope"), 1 :named("isdecl"))
    $P3688."unshift"($P3690)
.annotate 'line', 1215
    find_lex $P3691, "$past"
    $P3691."symbol"("$?CLASS", "package" :named("scope"))
.annotate 'line', 1212
    goto if_3662_end
  if_3662:
.annotate 'line', 1198
    find_lex $P3670, "$past"
    $P3670."blocktype"("declaration")
.annotate 'line', 1199
    find_lex $P3671, "$past"
    get_hll_global $P3672, ["PAST"], "Var"
    $P3673 = $P3672."new"("$?CLASS" :named("name"), "parameter" :named("scope"))
    $P3671."unshift"($P3673)
.annotate 'line', 1200
    find_lex $P3674, "$past"
    $P3674."symbol"("$?CLASS", "lexical" :named("scope"))
.annotate 'line', 1201
    find_dynamic_lex $P3675, "$*PACKAGE-SETUP"
    unless_null $P3675, vivify_1653
    get_hll_global $P3675, "$PACKAGE-SETUP"
    unless_null $P3675, vivify_1654
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1654:
  vivify_1653:
    get_hll_global $P3676, ["PAST"], "Op"
.annotate 'line', 1203
    get_hll_global $P3677, ["PAST"], "Op"
.annotate 'line', 1206
    get_hll_global $P3678, ["PAST"], "Var"
    $P3679 = $P3678."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3680 = $P3677."new"($P3679, "get_how PP" :named("pirop"))
.annotate 'line', 1208
    get_hll_global $P3681, ["PAST"], "Var"
    $P3682 = $P3681."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1209
    get_hll_global $P3683, ["PAST"], "Val"
    find_lex $P3684, "$past"
    $P3685 = $P3683."new"($P3684 :named("value"))
    $P3686 = $P3676."new"($P3680, $P3682, $P3685, "callmethod" :named("pasttype"), "set_body_block" :named("name"))
.annotate 'line', 1201
    $P3675."push"($P3686)
  if_3662_end:
.annotate 'line', 1220
    find_lex $P3693, "$/"
    unless_null $P3693, vivify_1655
    $P3693 = root_new ['parrot';'Hash']
  vivify_1655:
    set $P3694, $P3693["parent"]
    unless_null $P3694, vivify_1656
    new $P3694, "Undef"
  vivify_1656:
    if $P3694, if_3692
.annotate 'line', 1234
    find_dynamic_lex $P3724, "$*PKGDECL"
    unless_null $P3724, vivify_1657
    get_hll_global $P3724, "$PKGDECL"
    unless_null $P3724, vivify_1658
    die "Contextual $*PKGDECL not found"
  vivify_1658:
  vivify_1657:
    set $S3725, $P3724
    iseq $I3726, $S3725, "grammar"
    unless $I3726, if_3723_end
.annotate 'line', 1235
    find_dynamic_lex $P3727, "$*PACKAGE-SETUP"
    unless_null $P3727, vivify_1659
    get_hll_global $P3727, "$PACKAGE-SETUP"
    unless_null $P3727, vivify_1660
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1660:
  vivify_1659:
    get_hll_global $P3728, ["PAST"], "Op"
.annotate 'line', 1237
    get_hll_global $P3729, ["PAST"], "Op"
.annotate 'line', 1240
    get_hll_global $P3730, ["PAST"], "Var"
    $P3731 = $P3730."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3732 = $P3729."new"($P3731, "get_how PP" :named("pirop"))
.annotate 'line', 1242
    get_hll_global $P3733, ["PAST"], "Var"
    $P3734 = $P3733."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1243
    get_hll_global $P3735, ["PAST"], "Var"
    $P3736 = $P3735."new"("Cursor" :named("name"), "Regex" :named("namespace"), "package" :named("scope"))
    $P3737 = $P3728."new"($P3732, $P3734, $P3736, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1235
    $P3727."push"($P3737)
  if_3723_end:
.annotate 'line', 1234
    goto if_3692_end
  if_3692:
.annotate 'line', 1220
    .const 'Sub' $P3696 = "472_1300146757.646" 
    capture_lex $P3696
    $P3696()
  if_3692_end:
.annotate 'line', 1248
    find_lex $P3739, "$/"
    unless_null $P3739, vivify_1667
    $P3739 = root_new ['parrot';'Hash']
  vivify_1667:
    set $P3740, $P3739["role"]
    unless_null $P3740, vivify_1668
    new $P3740, "Undef"
  vivify_1668:
    unless $P3740, if_3738_end
.annotate 'line', 1249
    find_lex $P3742, "$/"
    unless_null $P3742, vivify_1669
    $P3742 = root_new ['parrot';'Hash']
  vivify_1669:
    set $P3743, $P3742["role"]
    unless_null $P3743, vivify_1670
    new $P3743, "Undef"
  vivify_1670:
    defined $I3744, $P3743
    unless $I3744, for_undef_1671
    iter $P3741, $P3743
    new $P3774, 'ExceptionHandler'
    set_label $P3774, loop3773_handler
    $P3774."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P3774
  loop3773_test:
    unless $P3741, loop3773_done
    shift $P3745, $P3741
  loop3773_redo:
    .const 'Sub' $P3747 = "473_1300146757.646" 
    capture_lex $P3747
    $P3747($P3745)
  loop3773_next:
    goto loop3773_test
  loop3773_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P3775, exception, 'type'
    eq $P3775, .CONTROL_LOOP_NEXT, loop3773_next
    eq $P3775, .CONTROL_LOOP_REDO, loop3773_redo
  loop3773_done:
    pop_eh 
  for_undef_1671:
  if_3738_end:
.annotate 'line', 1266
    find_dynamic_lex $P3776, "$*PACKAGE-SETUP"
    unless_null $P3776, vivify_1676
    get_hll_global $P3776, "$PACKAGE-SETUP"
    unless_null $P3776, vivify_1677
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1677:
  vivify_1676:
    get_hll_global $P3777, ["PAST"], "Op"
.annotate 'line', 1268
    get_hll_global $P3778, ["PAST"], "Op"
.annotate 'line', 1271
    get_hll_global $P3779, ["PAST"], "Var"
    $P3780 = $P3779."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3781 = $P3778."new"($P3780, "get_how PP" :named("pirop"))
.annotate 'line', 1273
    get_hll_global $P3782, ["PAST"], "Var"
    $P3783 = $P3782."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3784 = $P3777."new"($P3781, $P3783, "callmethod" :named("pasttype"), "compose" :named("name"))
.annotate 'line', 1266
    $P3776."push"($P3784)
.annotate 'line', 1277
    find_lex $P3785, "$past"
    $P3786 = $P3785."loadinit"()
    get_hll_global $P3787, ["PAST"], "Block"
    find_dynamic_lex $P3788, "$*PACKAGE-SETUP"
    unless_null $P3788, vivify_1678
    get_hll_global $P3788, "$PACKAGE-SETUP"
    unless_null $P3788, vivify_1679
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1679:
  vivify_1678:
    $P3789 = $P3787."new"($P3788, "immediate" :named("blocktype"))
    $P3786."push"($P3789)
.annotate 'line', 1279
    find_lex $P3790, "$/"
    find_lex $P3791, "$past"
    $P3792 = $P3790."!make"($P3791)
.annotate 'line', 1162
    .return ($P3792)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3695"  :anon :subid("472_1300146757.646") :outer("471_1300146757.646")
.annotate 'line', 1221
    $P3697 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3697
.annotate 'line', 1222
    new $P3698, "Undef"
    .lex "$name", $P3698
.annotate 'line', 1221
    find_lex $P3699, "$/"
    unless_null $P3699, vivify_1661
    $P3699 = root_new ['parrot';'Hash']
  vivify_1661:
    set $P3700, $P3699["parent"]
    unless_null $P3700, vivify_1662
    $P3700 = root_new ['parrot';'ResizablePMCArray']
  vivify_1662:
    set $P3701, $P3700[0]
    unless_null $P3701, vivify_1663
    $P3701 = root_new ['parrot';'Hash']
  vivify_1663:
    set $P3702, $P3701["identifier"]
    unless_null $P3702, vivify_1664
    new $P3702, "Undef"
  vivify_1664:
    clone $P3703, $P3702
    store_lex "@ns", $P3703
.annotate 'line', 1222
    find_lex $P3704, "@ns"
    $P3705 = $P3704."pop"()
    set $S3706, $P3705
    new $P3707, 'String'
    set $P3707, $S3706
    store_lex "$name", $P3707
.annotate 'line', 1223
    find_dynamic_lex $P3708, "$*PACKAGE-SETUP"
    unless_null $P3708, vivify_1665
    get_hll_global $P3708, "$PACKAGE-SETUP"
    unless_null $P3708, vivify_1666
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1666:
  vivify_1665:
    get_hll_global $P3709, ["PAST"], "Op"
.annotate 'line', 1225
    get_hll_global $P3710, ["PAST"], "Op"
.annotate 'line', 1228
    get_hll_global $P3711, ["PAST"], "Var"
    $P3712 = $P3711."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3713 = $P3710."new"($P3712, "get_how PP" :named("pirop"))
.annotate 'line', 1230
    get_hll_global $P3714, ["PAST"], "Var"
    $P3715 = $P3714."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1231
    get_hll_global $P3716, ["PAST"], "Var"
    find_lex $P3717, "$name"
    set $S3718, $P3717
    find_lex $P3719, "@ns"
    $P3720 = $P3716."new"($S3718 :named("name"), $P3719 :named("namespace"), "package" :named("scope"))
    $P3721 = $P3709."new"($P3713, $P3715, $P3720, "callmethod" :named("pasttype"), "add_parent" :named("name"))
.annotate 'line', 1223
    $P3722 = $P3708."push"($P3721)
.annotate 'line', 1220
    .return ($P3722)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3746"  :anon :subid("473_1300146757.646") :outer("471_1300146757.646")
    .param pmc param_3750
.annotate 'line', 1250
    $P3748 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P3748
.annotate 'line', 1251
    new $P3749, "Undef"
    .lex "$name", $P3749
    .lex "$_", param_3750
.annotate 'line', 1250
    find_lex $P3751, "$_"
    unless_null $P3751, vivify_1672
    $P3751 = root_new ['parrot';'Hash']
  vivify_1672:
    set $P3752, $P3751["identifier"]
    unless_null $P3752, vivify_1673
    new $P3752, "Undef"
  vivify_1673:
    clone $P3753, $P3752
    store_lex "@ns", $P3753
.annotate 'line', 1251
    find_lex $P3754, "@ns"
    $P3755 = $P3754."pop"()
    set $S3756, $P3755
    new $P3757, 'String'
    set $P3757, $S3756
    store_lex "$name", $P3757
.annotate 'line', 1252
    find_dynamic_lex $P3758, "$*PACKAGE-SETUP"
    unless_null $P3758, vivify_1674
    get_hll_global $P3758, "$PACKAGE-SETUP"
    unless_null $P3758, vivify_1675
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1675:
  vivify_1674:
    get_hll_global $P3759, ["PAST"], "Op"
.annotate 'line', 1254
    get_hll_global $P3760, ["PAST"], "Op"
.annotate 'line', 1257
    get_hll_global $P3761, ["PAST"], "Var"
    $P3762 = $P3761."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3763 = $P3760."new"($P3762, "get_how PP" :named("pirop"))
.annotate 'line', 1259
    get_hll_global $P3764, ["PAST"], "Var"
    $P3765 = $P3764."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1260
    get_hll_global $P3766, ["PAST"], "Var"
    find_lex $P3767, "$name"
    set $S3768, $P3767
    find_lex $P3769, "@ns"
    $P3770 = $P3766."new"($S3768 :named("name"), $P3769 :named("namespace"), "package" :named("scope"))
    $P3771 = $P3759."new"($P3763, $P3765, $P3770, "callmethod" :named("pasttype"), "add_role" :named("name"))
.annotate 'line', 1252
    $P3772 = $P3758."push"($P3771)
.annotate 'line', 1249
    .return ($P3772)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<my>"  :subid("474_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3794
    .param pmc param_3795
.annotate 'line', 1282
    .lex "self", param_3794
    .lex "$/", param_3795
    find_lex $P3796, "$/"
    find_lex $P3797, "$/"
    unless_null $P3797, vivify_1680
    $P3797 = root_new ['parrot';'Hash']
  vivify_1680:
    set $P3798, $P3797["scoped"]
    unless_null $P3798, vivify_1681
    new $P3798, "Undef"
  vivify_1681:
    $P3799 = $P3798."ast"()
    $P3800 = $P3796."!make"($P3799)
    .return ($P3800)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<our>"  :subid("475_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3802
    .param pmc param_3803
.annotate 'line', 1283
    .lex "self", param_3802
    .lex "$/", param_3803
    find_lex $P3804, "$/"
    find_lex $P3805, "$/"
    unless_null $P3805, vivify_1682
    $P3805 = root_new ['parrot';'Hash']
  vivify_1682:
    set $P3806, $P3805["scoped"]
    unless_null $P3806, vivify_1683
    new $P3806, "Undef"
  vivify_1683:
    $P3807 = $P3806."ast"()
    $P3808 = $P3804."!make"($P3807)
    .return ($P3808)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scope_declarator:sym<has>"  :subid("476_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3810
    .param pmc param_3811
.annotate 'line', 1284
    .lex "self", param_3810
    .lex "$/", param_3811
    find_lex $P3812, "$/"
    find_lex $P3813, "$/"
    unless_null $P3813, vivify_1684
    $P3813 = root_new ['parrot';'Hash']
  vivify_1684:
    set $P3814, $P3813["scoped"]
    unless_null $P3814, vivify_1685
    new $P3814, "Undef"
  vivify_1685:
    $P3815 = $P3814."ast"()
    $P3816 = $P3812."!make"($P3815)
    .return ($P3816)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "scoped"  :subid("477_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3818
    .param pmc param_3819
.annotate 'line', 1286
    .lex "self", param_3818
    .lex "$/", param_3819
.annotate 'line', 1287
    find_lex $P3820, "$/"
    find_lex $P3823, "$/"
    unless_null $P3823, vivify_1686
    $P3823 = root_new ['parrot';'Hash']
  vivify_1686:
    set $P3824, $P3823["declarator"]
    unless_null $P3824, vivify_1687
    new $P3824, "Undef"
  vivify_1687:
    if $P3824, if_3822
.annotate 'line', 1288
    find_lex $P3830, "$/"
    unless_null $P3830, vivify_1688
    $P3830 = root_new ['parrot';'Hash']
  vivify_1688:
    set $P3831, $P3830["multi_declarator"]
    unless_null $P3831, vivify_1689
    new $P3831, "Undef"
  vivify_1689:
    if $P3831, if_3829
.annotate 'line', 1289
    find_lex $P3835, "$/"
    unless_null $P3835, vivify_1690
    $P3835 = root_new ['parrot';'Hash']
  vivify_1690:
    set $P3836, $P3835["package_declarator"]
    unless_null $P3836, vivify_1691
    new $P3836, "Undef"
  vivify_1691:
    $P3837 = $P3836."ast"()
    set $P3828, $P3837
.annotate 'line', 1288
    goto if_3829_end
  if_3829:
    find_lex $P3832, "$/"
    unless_null $P3832, vivify_1692
    $P3832 = root_new ['parrot';'Hash']
  vivify_1692:
    set $P3833, $P3832["multi_declarator"]
    unless_null $P3833, vivify_1693
    new $P3833, "Undef"
  vivify_1693:
    $P3834 = $P3833."ast"()
    set $P3828, $P3834
  if_3829_end:
    set $P3821, $P3828
.annotate 'line', 1287
    goto if_3822_end
  if_3822:
    find_lex $P3825, "$/"
    unless_null $P3825, vivify_1694
    $P3825 = root_new ['parrot';'Hash']
  vivify_1694:
    set $P3826, $P3825["declarator"]
    unless_null $P3826, vivify_1695
    new $P3826, "Undef"
  vivify_1695:
    $P3827 = $P3826."ast"()
    set $P3821, $P3827
  if_3822_end:
    $P3838 = $P3820."!make"($P3821)
.annotate 'line', 1286
    .return ($P3838)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "declarator"  :subid("478_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3840
    .param pmc param_3841
.annotate 'line', 1292
    .lex "self", param_3840
    .lex "$/", param_3841
.annotate 'line', 1293
    find_lex $P3842, "$/"
.annotate 'line', 1294
    find_lex $P3845, "$/"
    unless_null $P3845, vivify_1696
    $P3845 = root_new ['parrot';'Hash']
  vivify_1696:
    set $P3846, $P3845["routine_declarator"]
    unless_null $P3846, vivify_1697
    new $P3846, "Undef"
  vivify_1697:
    if $P3846, if_3844
.annotate 'line', 1295
    find_lex $P3850, "$/"
    unless_null $P3850, vivify_1698
    $P3850 = root_new ['parrot';'Hash']
  vivify_1698:
    set $P3851, $P3850["variable_declarator"]
    unless_null $P3851, vivify_1699
    new $P3851, "Undef"
  vivify_1699:
    $P3852 = $P3851."ast"()
    set $P3843, $P3852
.annotate 'line', 1294
    goto if_3844_end
  if_3844:
    find_lex $P3847, "$/"
    unless_null $P3847, vivify_1700
    $P3847 = root_new ['parrot';'Hash']
  vivify_1700:
    set $P3848, $P3847["routine_declarator"]
    unless_null $P3848, vivify_1701
    new $P3848, "Undef"
  vivify_1701:
    $P3849 = $P3848."ast"()
    set $P3843, $P3849
  if_3844_end:
    $P3853 = $P3842."!make"($P3843)
.annotate 'line', 1292
    .return ($P3853)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<multi>"  :subid("479_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3855
    .param pmc param_3856
.annotate 'line', 1298
    .lex "self", param_3855
    .lex "$/", param_3856
    find_lex $P3857, "$/"
    find_lex $P3860, "$/"
    unless_null $P3860, vivify_1702
    $P3860 = root_new ['parrot';'Hash']
  vivify_1702:
    set $P3861, $P3860["declarator"]
    unless_null $P3861, vivify_1703
    new $P3861, "Undef"
  vivify_1703:
    if $P3861, if_3859
    find_lex $P3865, "$/"
    unless_null $P3865, vivify_1704
    $P3865 = root_new ['parrot';'Hash']
  vivify_1704:
    set $P3866, $P3865["routine_def"]
    unless_null $P3866, vivify_1705
    new $P3866, "Undef"
  vivify_1705:
    $P3867 = $P3866."ast"()
    set $P3858, $P3867
    goto if_3859_end
  if_3859:
    find_lex $P3862, "$/"
    unless_null $P3862, vivify_1706
    $P3862 = root_new ['parrot';'Hash']
  vivify_1706:
    set $P3863, $P3862["declarator"]
    unless_null $P3863, vivify_1707
    new $P3863, "Undef"
  vivify_1707:
    $P3864 = $P3863."ast"()
    set $P3858, $P3864
  if_3859_end:
    $P3868 = $P3857."!make"($P3858)
    .return ($P3868)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<proto>"  :subid("480_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3870
    .param pmc param_3871
.annotate 'line', 1299
    .lex "self", param_3870
    .lex "$/", param_3871
    find_lex $P3872, "$/"
    find_lex $P3875, "$/"
    unless_null $P3875, vivify_1708
    $P3875 = root_new ['parrot';'Hash']
  vivify_1708:
    set $P3876, $P3875["declarator"]
    unless_null $P3876, vivify_1709
    new $P3876, "Undef"
  vivify_1709:
    if $P3876, if_3874
    find_lex $P3880, "$/"
    unless_null $P3880, vivify_1710
    $P3880 = root_new ['parrot';'Hash']
  vivify_1710:
    set $P3881, $P3880["routine_def"]
    unless_null $P3881, vivify_1711
    new $P3881, "Undef"
  vivify_1711:
    $P3882 = $P3881."ast"()
    set $P3873, $P3882
    goto if_3874_end
  if_3874:
    find_lex $P3877, "$/"
    unless_null $P3877, vivify_1712
    $P3877 = root_new ['parrot';'Hash']
  vivify_1712:
    set $P3878, $P3877["declarator"]
    unless_null $P3878, vivify_1713
    new $P3878, "Undef"
  vivify_1713:
    $P3879 = $P3878."ast"()
    set $P3873, $P3879
  if_3874_end:
    $P3883 = $P3872."!make"($P3873)
    .return ($P3883)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "multi_declarator:sym<null>"  :subid("481_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3885
    .param pmc param_3886
.annotate 'line', 1300
    .lex "self", param_3885
    .lex "$/", param_3886
    find_lex $P3887, "$/"
    find_lex $P3888, "$/"
    unless_null $P3888, vivify_1714
    $P3888 = root_new ['parrot';'Hash']
  vivify_1714:
    set $P3889, $P3888["declarator"]
    unless_null $P3889, vivify_1715
    new $P3889, "Undef"
  vivify_1715:
    $P3890 = $P3889."ast"()
    $P3891 = $P3887."!make"($P3890)
    .return ($P3891)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "variable_declarator"  :subid("482_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3893
    .param pmc param_3894
.annotate 'line', 1303
    .const 'Sub' $P3966 = "485_1300146757.646" 
    capture_lex $P3966
    .const 'Sub' $P3921 = "483_1300146757.646" 
    capture_lex $P3921
    .lex "self", param_3893
    .lex "$/", param_3894
.annotate 'line', 1304
    new $P3895, "Undef"
    .lex "$past", $P3895
.annotate 'line', 1305
    new $P3896, "Undef"
    .lex "$sigil", $P3896
.annotate 'line', 1306
    new $P3897, "Undef"
    .lex "$name", $P3897
.annotate 'line', 1307
    new $P3898, "Undef"
    .lex "$BLOCK", $P3898
.annotate 'line', 1304
    find_lex $P3899, "$/"
    unless_null $P3899, vivify_1716
    $P3899 = root_new ['parrot';'Hash']
  vivify_1716:
    set $P3900, $P3899["variable"]
    unless_null $P3900, vivify_1717
    new $P3900, "Undef"
  vivify_1717:
    $P3901 = $P3900."ast"()
    store_lex "$past", $P3901
.annotate 'line', 1305
    find_lex $P3902, "$/"
    unless_null $P3902, vivify_1718
    $P3902 = root_new ['parrot';'Hash']
  vivify_1718:
    set $P3903, $P3902["variable"]
    unless_null $P3903, vivify_1719
    $P3903 = root_new ['parrot';'Hash']
  vivify_1719:
    set $P3904, $P3903["sigil"]
    unless_null $P3904, vivify_1720
    new $P3904, "Undef"
  vivify_1720:
    store_lex "$sigil", $P3904
.annotate 'line', 1306
    find_lex $P3905, "$past"
    $P3906 = $P3905."name"()
    store_lex "$name", $P3906
.annotate 'line', 1307
    get_global $P3907, "@BLOCK"
    unless_null $P3907, vivify_1721
    $P3907 = root_new ['parrot';'ResizablePMCArray']
  vivify_1721:
    set $P3908, $P3907[0]
    unless_null $P3908, vivify_1722
    new $P3908, "Undef"
  vivify_1722:
    store_lex "$BLOCK", $P3908
.annotate 'line', 1308
    find_lex $P3910, "$BLOCK"
    find_lex $P3911, "$name"
    $P3912 = $P3910."symbol"($P3911)
    unless $P3912, if_3909_end
.annotate 'line', 1309
    find_lex $P3913, "$/"
    $P3914 = $P3913."CURSOR"()
    find_lex $P3915, "$name"
    $P3914."panic"("Redeclaration of symbol ", $P3915)
  if_3909_end:
.annotate 'line', 1311
    find_dynamic_lex $P3917, "$*SCOPE"
    unless_null $P3917, vivify_1723
    get_hll_global $P3917, "$SCOPE"
    unless_null $P3917, vivify_1724
    die "Contextual $*SCOPE not found"
  vivify_1724:
  vivify_1723:
    set $S3918, $P3917
    iseq $I3919, $S3918, "has"
    if $I3919, if_3916
.annotate 'line', 1336
    .const 'Sub' $P3966 = "485_1300146757.646" 
    capture_lex $P3966
    $P3966()
    goto if_3916_end
  if_3916:
.annotate 'line', 1311
    .const 'Sub' $P3921 = "483_1300146757.646" 
    capture_lex $P3921
    $P3921()
  if_3916_end:
.annotate 'line', 1344
    find_lex $P3990, "$/"
    find_lex $P3991, "$past"
    $P3992 = $P3990."!make"($P3991)
.annotate 'line', 1303
    .return ($P3992)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3965"  :anon :subid("485_1300146757.646") :outer("482_1300146757.646")
.annotate 'line', 1337
    new $P3967, "Undef"
    .lex "$scope", $P3967
.annotate 'line', 1338
    new $P3968, "Undef"
    .lex "$decl", $P3968
.annotate 'line', 1337
    find_dynamic_lex $P3971, "$*SCOPE"
    unless_null $P3971, vivify_1725
    get_hll_global $P3971, "$SCOPE"
    unless_null $P3971, vivify_1726
    die "Contextual $*SCOPE not found"
  vivify_1726:
  vivify_1725:
    set $S3972, $P3971
    iseq $I3973, $S3972, "our"
    if $I3973, if_3970
    new $P3975, "String"
    assign $P3975, "lexical"
    set $P3969, $P3975
    goto if_3970_end
  if_3970:
    new $P3974, "String"
    assign $P3974, "package"
    set $P3969, $P3974
  if_3970_end:
    store_lex "$scope", $P3969
.annotate 'line', 1338
    get_hll_global $P3976, ["PAST"], "Var"
    find_lex $P3977, "$name"
    find_lex $P3978, "$scope"
.annotate 'line', 1339
    find_lex $P3979, "$sigil"
    $P3980 = "vivitype"($P3979)
    find_lex $P3981, "$/"
    $P3982 = $P3976."new"($P3977 :named("name"), $P3978 :named("scope"), 1 :named("isdecl"), 1 :named("lvalue"), $P3980 :named("viviself"), $P3981 :named("node"))
.annotate 'line', 1338
    store_lex "$decl", $P3982
.annotate 'line', 1341
    find_lex $P3983, "$BLOCK"
    find_lex $P3984, "$name"
    find_lex $P3985, "$scope"
    $P3983."symbol"($P3984, $P3985 :named("scope"))
.annotate 'line', 1342
    find_lex $P3986, "$BLOCK"
    unless_null $P3986, vivify_1727
    $P3986 = root_new ['parrot';'ResizablePMCArray']
  vivify_1727:
    set $P3987, $P3986[0]
    unless_null $P3987, vivify_1728
    new $P3987, "Undef"
  vivify_1728:
    find_lex $P3988, "$decl"
    $P3989 = $P3987."push"($P3988)
.annotate 'line', 1336
    .return ($P3989)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3920"  :anon :subid("483_1300146757.646") :outer("482_1300146757.646")
.annotate 'line', 1311
    .const 'Sub' $P3951 = "484_1300146757.646" 
    capture_lex $P3951
.annotate 'line', 1313
    new $P3922, "Undef"
    .lex "$meta-attr-type", $P3922
.annotate 'line', 1321
    new $P3923, "Undef"
    .lex "$meta_args", $P3923
.annotate 'line', 1313
    find_dynamic_lex $P3926, "$*PKGDECL"
    unless_null $P3926, vivify_1729
    get_hll_global $P3926, "$PKGDECL"
    unless_null $P3926, vivify_1730
    die "Contextual $*PKGDECL not found"
  vivify_1730:
  vivify_1729:
    find_dynamic_lex $P3927, "%*HOW-METAATTR"
    unless_null $P3927, vivify_1731
    get_hll_global $P3927, "%HOW-METAATTR"
    unless_null $P3927, vivify_1732
    die "Contextual %*HOW-METAATTR not found"
  vivify_1732:
  vivify_1731:
    set $P3928, $P3927[$P3926]
    unless_null $P3928, vivify_1733
    new $P3928, "Undef"
  vivify_1733:
    unless $P3928, unless_3925
    set $P3924, $P3928
    goto unless_3925_end
  unless_3925:
    find_dynamic_lex $P3929, "$*DEFAULT-METAATTR"
    unless_null $P3929, vivify_1734
    get_hll_global $P3929, "$DEFAULT-METAATTR"
    unless_null $P3929, vivify_1735
    die "Contextual $*DEFAULT-METAATTR not found"
  vivify_1735:
  vivify_1734:
    set $P3924, $P3929
  unless_3925_end:
    store_lex "$meta-attr-type", $P3924
.annotate 'line', 1314
    find_dynamic_lex $P3930, "$*PACKAGE-SETUP"
    unless_null $P3930, vivify_1736
    get_hll_global $P3930, "$PACKAGE-SETUP"
    unless_null $P3930, vivify_1737
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1737:
  vivify_1736:
    get_hll_global $P3931, ["PAST"], "Op"
.annotate 'line', 1316
    get_hll_global $P3932, ["PAST"], "Op"
.annotate 'line', 1318
    get_hll_global $P3933, ["PAST"], "Var"
    $P3934 = $P3933."new"("type_obj" :named("name"), "register" :named("scope"))
    $P3935 = $P3932."new"($P3934, "get_how PP" :named("pirop"))
.annotate 'line', 1320
    get_hll_global $P3936, ["PAST"], "Var"
    $P3937 = $P3936."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1321
    get_hll_global $P3938, ["PAST"], "Op"
.annotate 'line', 1323
    get_hll_global $P3939, ["PAST"], "Var"
    find_lex $P3940, "$meta-attr-type"
    $P3941 = $P3939."new"($P3940 :named("name"), "" :named("namespace"), "package" :named("scope"))
.annotate 'line', 1324
    get_hll_global $P3942, ["PAST"], "Val"
    find_lex $P3943, "$name"
    $P3944 = $P3942."new"($P3943 :named("value"), "name" :named("named"))
    $P3945 = $P3938."new"($P3941, $P3944, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1321
    store_lex "$meta_args", $P3945
    $P3946 = $P3931."new"($P3935, $P3937, $P3945, "callmethod" :named("pasttype"), "add_attribute" :named("name"))
.annotate 'line', 1314
    $P3930."push"($P3946)
.annotate 'line', 1327
    find_lex $P3948, "$/"
    unless_null $P3948, vivify_1738
    $P3948 = root_new ['parrot';'Hash']
  vivify_1738:
    set $P3949, $P3948["typename"]
    unless_null $P3949, vivify_1739
    new $P3949, "Undef"
  vivify_1739:
    unless $P3949, if_3947_end
    .const 'Sub' $P3951 = "484_1300146757.646" 
    capture_lex $P3951
    $P3951()
  if_3947_end:
.annotate 'line', 1333
    find_lex $P3961, "$BLOCK"
    find_lex $P3962, "$name"
    $P3961."symbol"($P3962, "attribute" :named("scope"))
.annotate 'line', 1334
    get_hll_global $P3963, ["PAST"], "Stmts"
    $P3964 = $P3963."new"()
    store_lex "$past", $P3964
.annotate 'line', 1311
    .return ($P3964)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block3950"  :anon :subid("484_1300146757.646") :outer("483_1300146757.646")
.annotate 'line', 1328
    new $P3952, "Undef"
    .lex "$type", $P3952
    find_lex $P3953, "$/"
    unless_null $P3953, vivify_1740
    $P3953 = root_new ['parrot';'Hash']
  vivify_1740:
    set $P3954, $P3953["typename"]
    unless_null $P3954, vivify_1741
    $P3954 = root_new ['parrot';'ResizablePMCArray']
  vivify_1741:
    set $P3955, $P3954[0]
    unless_null $P3955, vivify_1742
    new $P3955, "Undef"
  vivify_1742:
    $P3956 = $P3955."ast"()
    store_lex "$type", $P3956
.annotate 'line', 1329
    find_lex $P3957, "$type"
    $P3957."named"("type")
.annotate 'line', 1330
    find_lex $P3958, "$meta_args"
    find_lex $P3959, "$type"
    $P3960 = $P3958."push"($P3959)
.annotate 'line', 1327
    .return ($P3960)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<sub>"  :subid("486_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_3994
    .param pmc param_3995
.annotate 'line', 1347
    .lex "self", param_3994
    .lex "$/", param_3995
    find_lex $P3996, "$/"
    find_lex $P3997, "$/"
    unless_null $P3997, vivify_1743
    $P3997 = root_new ['parrot';'Hash']
  vivify_1743:
    set $P3998, $P3997["routine_def"]
    unless_null $P3998, vivify_1744
    new $P3998, "Undef"
  vivify_1744:
    $P3999 = $P3998."ast"()
    $P4000 = $P3996."!make"($P3999)
    .return ($P4000)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "routine_declarator:sym<method>"  :subid("487_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4002
    .param pmc param_4003
.annotate 'line', 1348
    .lex "self", param_4002
    .lex "$/", param_4003
    find_lex $P4004, "$/"
    find_lex $P4005, "$/"
    unless_null $P4005, vivify_1745
    $P4005 = root_new ['parrot';'Hash']
  vivify_1745:
    set $P4006, $P4005["method_def"]
    unless_null $P4006, vivify_1746
    new $P4006, "Undef"
  vivify_1746:
    $P4007 = $P4006."ast"()
    $P4008 = $P4004."!make"($P4007)
    .return ($P4008)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "routine_def"  :subid("488_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4010
    .param pmc param_4011
.annotate 'line', 1350
    .const 'Sub' $P4248 = "494_1300146757.646" 
    capture_lex $P4248
    .const 'Sub' $P4031 = "489_1300146757.646" 
    capture_lex $P4031
    .lex "self", param_4010
    .lex "$/", param_4011
.annotate 'line', 1353
    new $P4012, "Undef"
    .lex "$past", $P4012
.annotate 'line', 1364
    new $P4013, "Undef"
    .lex "$block", $P4013
.annotate 'line', 1350
    find_lex $P4014, "$past"
.annotate 'line', 1354
    find_lex $P4016, "$/"
    unless_null $P4016, vivify_1747
    $P4016 = root_new ['parrot';'Hash']
  vivify_1747:
    set $P4017, $P4016["onlystar"]
    unless_null $P4017, vivify_1748
    new $P4017, "Undef"
  vivify_1748:
    if $P4017, if_4015
.annotate 'line', 1358
    find_lex $P4019, "$/"
    unless_null $P4019, vivify_1749
    $P4019 = root_new ['parrot';'Hash']
  vivify_1749:
    set $P4020, $P4019["blockoid"]
    unless_null $P4020, vivify_1750
    new $P4020, "Undef"
  vivify_1750:
    $P4021 = $P4020."ast"()
    store_lex "$past", $P4021
.annotate 'line', 1359
    find_lex $P4022, "$past"
    $P4022."blocktype"("declaration")
.annotate 'line', 1360
    find_dynamic_lex $P4024, "$*RETURN_USED"
    unless_null $P4024, vivify_1751
    get_hll_global $P4024, "$RETURN_USED"
    unless_null $P4024, vivify_1752
    die "Contextual $*RETURN_USED not found"
  vivify_1752:
  vivify_1751:
    unless $P4024, if_4023_end
.annotate 'line', 1361
    find_lex $P4025, "$past"
    $P4025."control"("return_pir")
  if_4023_end:
.annotate 'line', 1357
    goto if_4015_end
  if_4015:
.annotate 'line', 1355
    $P4018 = "only_star_block"()
    store_lex "$past", $P4018
  if_4015_end:
.annotate 'line', 1364
    find_lex $P4026, "$past"
    store_lex "$block", $P4026
.annotate 'line', 1366
    find_lex $P4028, "$/"
    unless_null $P4028, vivify_1753
    $P4028 = root_new ['parrot';'Hash']
  vivify_1753:
    set $P4029, $P4028["deflongname"]
    unless_null $P4029, vivify_1754
    new $P4029, "Undef"
  vivify_1754:
    unless $P4029, if_4027_end
    .const 'Sub' $P4031 = "489_1300146757.646" 
    capture_lex $P4031
    $P4031()
  if_4027_end:
.annotate 'line', 1471
    find_lex $P4237, "$block"
    find_lex $P4238, "$past"
    unless_null $P4238, vivify_1817
    $P4238 = root_new ['parrot';'Hash']
    store_lex "$past", $P4238
  vivify_1817:
    set $P4238["block_past"], $P4237
.annotate 'line', 1472
    find_lex $P4240, "$/"
    unless_null $P4240, vivify_1818
    $P4240 = root_new ['parrot';'Hash']
  vivify_1818:
    set $P4241, $P4240["trait"]
    unless_null $P4241, vivify_1819
    new $P4241, "Undef"
  vivify_1819:
    unless $P4241, if_4239_end
.annotate 'line', 1473
    find_lex $P4243, "$/"
    unless_null $P4243, vivify_1820
    $P4243 = root_new ['parrot';'Hash']
  vivify_1820:
    set $P4244, $P4243["trait"]
    unless_null $P4244, vivify_1821
    new $P4244, "Undef"
  vivify_1821:
    defined $I4245, $P4244
    unless $I4245, for_undef_1822
    iter $P4242, $P4244
    new $P4255, 'ExceptionHandler'
    set_label $P4255, loop4254_handler
    $P4255."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4255
  loop4254_test:
    unless $P4242, loop4254_done
    shift $P4246, $P4242
  loop4254_redo:
    .const 'Sub' $P4248 = "494_1300146757.646" 
    capture_lex $P4248
    $P4248($P4246)
  loop4254_next:
    goto loop4254_test
  loop4254_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4256, exception, 'type'
    eq $P4256, .CONTROL_LOOP_NEXT, loop4254_next
    eq $P4256, .CONTROL_LOOP_REDO, loop4254_redo
  loop4254_done:
    pop_eh 
  for_undef_1822:
  if_4239_end:
.annotate 'line', 1476
    find_lex $P4257, "$/"
    find_lex $P4258, "$past"
    $P4259 = $P4257."!make"($P4258)
.annotate 'line', 1350
    .return ($P4259)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4030"  :anon :subid("489_1300146757.646") :outer("488_1300146757.646")
.annotate 'line', 1366
    .const 'Sub' $P4153 = "493_1300146757.646" 
    capture_lex $P4153
    .const 'Sub' $P4064 = "490_1300146757.646" 
    capture_lex $P4064
.annotate 'line', 1367
    new $P4032, "Undef"
    .lex "$name", $P4032
    find_lex $P4033, "$/"
    unless_null $P4033, vivify_1755
    $P4033 = root_new ['parrot';'Hash']
  vivify_1755:
    set $P4034, $P4033["sigil"]
    unless_null $P4034, vivify_1756
    $P4034 = root_new ['parrot';'ResizablePMCArray']
  vivify_1756:
    set $P4035, $P4034[0]
    unless_null $P4035, vivify_1757
    new $P4035, "Undef"
  vivify_1757:
    set $S4036, $P4035
    new $P4037, 'String'
    set $P4037, $S4036
    find_lex $P4038, "$/"
    unless_null $P4038, vivify_1758
    $P4038 = root_new ['parrot';'Hash']
  vivify_1758:
    set $P4039, $P4038["deflongname"]
    unless_null $P4039, vivify_1759
    $P4039 = root_new ['parrot';'ResizablePMCArray']
  vivify_1759:
    set $P4040, $P4039[0]
    unless_null $P4040, vivify_1760
    new $P4040, "Undef"
  vivify_1760:
    $S4041 = $P4040."ast"()
    concat $P4042, $P4037, $S4041
    store_lex "$name", $P4042
.annotate 'line', 1368
    find_lex $P4043, "$past"
    find_lex $P4044, "$name"
    $P4043."name"($P4044)
.annotate 'line', 1369
    find_dynamic_lex $P4050, "$*SCOPE"
    unless_null $P4050, vivify_1761
    get_hll_global $P4050, "$SCOPE"
    unless_null $P4050, vivify_1762
    die "Contextual $*SCOPE not found"
  vivify_1762:
  vivify_1761:
    set $S4051, $P4050
    iseq $I4052, $S4051, ""
    unless $I4052, unless_4049
    new $P4048, 'Integer'
    set $P4048, $I4052
    goto unless_4049_end
  unless_4049:
    find_dynamic_lex $P4053, "$*SCOPE"
    unless_null $P4053, vivify_1763
    get_hll_global $P4053, "$SCOPE"
    unless_null $P4053, vivify_1764
    die "Contextual $*SCOPE not found"
  vivify_1764:
  vivify_1763:
    set $S4054, $P4053
    iseq $I4055, $S4054, "my"
    new $P4048, 'Integer'
    set $P4048, $I4055
  unless_4049_end:
    unless $P4048, unless_4047
    set $P4046, $P4048
    goto unless_4047_end
  unless_4047:
    find_dynamic_lex $P4056, "$*SCOPE"
    unless_null $P4056, vivify_1765
    get_hll_global $P4056, "$SCOPE"
    unless_null $P4056, vivify_1766
    die "Contextual $*SCOPE not found"
  vivify_1766:
  vivify_1765:
    set $S4057, $P4056
    iseq $I4058, $S4057, "our"
    new $P4046, 'Integer'
    set $P4046, $I4058
  unless_4047_end:
    if $P4046, if_4045
.annotate 'line', 1461
    find_lex $P4222, "$/"
    $P4223 = $P4222."CURSOR"()
    find_dynamic_lex $P4224, "$*SCOPE"
    unless_null $P4224, vivify_1767
    get_hll_global $P4224, "$SCOPE"
    unless_null $P4224, vivify_1768
    die "Contextual $*SCOPE not found"
  vivify_1768:
  vivify_1767:
    concat $P4225, $P4224, " scoped routines are not supported yet"
    $P4223."panic"($P4225)
.annotate 'line', 1460
    goto if_4045_end
  if_4045:
.annotate 'line', 1370
    find_dynamic_lex $P4060, "$*MULTINESS"
    unless_null $P4060, vivify_1769
    get_hll_global $P4060, "$MULTINESS"
    unless_null $P4060, vivify_1770
    die "Contextual $*MULTINESS not found"
  vivify_1770:
  vivify_1769:
    set $S4061, $P4060
    iseq $I4062, $S4061, "multi"
    if $I4062, if_4059
.annotate 'line', 1421
    find_dynamic_lex $P4149, "$*MULTINESS"
    unless_null $P4149, vivify_1771
    get_hll_global $P4149, "$MULTINESS"
    unless_null $P4149, vivify_1772
    die "Contextual $*MULTINESS not found"
  vivify_1772:
  vivify_1771:
    set $S4150, $P4149
    iseq $I4151, $S4150, "proto"
    if $I4151, if_4148
.annotate 'line', 1440
    get_global $P4183, "@BLOCK"
    unless_null $P4183, vivify_1773
    $P4183 = root_new ['parrot';'ResizablePMCArray']
  vivify_1773:
    set $P4184, $P4183[0]
    unless_null $P4184, vivify_1774
    $P4184 = root_new ['parrot';'ResizablePMCArray']
  vivify_1774:
    set $P4185, $P4184[0]
    unless_null $P4185, vivify_1775
    new $P4185, "Undef"
  vivify_1775:
    get_hll_global $P4186, ["PAST"], "Var"
    find_lex $P4187, "$name"
    find_lex $P4188, "$past"
    $P4189 = $P4186."new"($P4187 :named("name"), 1 :named("isdecl"), $P4188 :named("viviself"), "lexical" :named("scope"))
    $P4185."push"($P4189)
.annotate 'line', 1442
    get_global $P4190, "@BLOCK"
    unless_null $P4190, vivify_1776
    $P4190 = root_new ['parrot';'ResizablePMCArray']
  vivify_1776:
    set $P4191, $P4190[0]
    unless_null $P4191, vivify_1777
    new $P4191, "Undef"
  vivify_1777:
    find_lex $P4192, "$name"
    $P4191."symbol"($P4192, "lexical" :named("scope"))
.annotate 'line', 1443
    find_dynamic_lex $P4194, "$*SCOPE"
    unless_null $P4194, vivify_1778
    get_hll_global $P4194, "$SCOPE"
    unless_null $P4194, vivify_1779
    die "Contextual $*SCOPE not found"
  vivify_1779:
  vivify_1778:
    set $S4195, $P4194
    iseq $I4196, $S4195, "our"
    unless $I4196, if_4193_end
.annotate 'line', 1446
    get_global $P4197, "@BLOCK"
    unless_null $P4197, vivify_1780
    $P4197 = root_new ['parrot';'ResizablePMCArray']
  vivify_1780:
    set $P4198, $P4197[0]
    unless_null $P4198, vivify_1781
    $P4198 = root_new ['parrot';'ResizablePMCArray']
  vivify_1781:
    set $P4199, $P4198[0]
    unless_null $P4199, vivify_1782
    new $P4199, "Undef"
  vivify_1782:
    get_hll_global $P4200, ["PAST"], "Op"
.annotate 'line', 1448
    get_hll_global $P4201, ["PAST"], "Var"
    find_lex $P4202, "$name"
    $P4203 = $P4201."new"($P4202 :named("name"), "package" :named("scope"))
.annotate 'line', 1449
    get_hll_global $P4204, ["PAST"], "Var"
    find_lex $P4205, "$name"
    $P4206 = $P4204."new"($P4205 :named("name"), "lexical" :named("scope"))
    $P4207 = $P4200."new"($P4203, $P4206, "bind" :named("pasttype"))
.annotate 'line', 1446
    $P4199."push"($P4207)
.annotate 'line', 1451
    get_global $P4208, "@BLOCK"
    unless_null $P4208, vivify_1783
    $P4208 = root_new ['parrot';'ResizablePMCArray']
  vivify_1783:
    set $P4209, $P4208[0]
    unless_null $P4209, vivify_1784
    new $P4209, "Undef"
  vivify_1784:
    $P4210 = $P4209."loadinit"()
    get_hll_global $P4211, ["PAST"], "Op"
.annotate 'line', 1453
    get_hll_global $P4212, ["PAST"], "Var"
    find_lex $P4213, "$name"
    $P4214 = $P4212."new"($P4213 :named("name"), "package" :named("scope"))
.annotate 'line', 1454
    get_hll_global $P4215, ["PAST"], "Val"
    find_lex $P4216, "$past"
    $P4217 = $P4215."new"($P4216 :named("value"))
    $P4218 = $P4211."new"($P4214, $P4217, "bind" :named("pasttype"))
.annotate 'line', 1451
    $P4210."push"($P4218)
  if_4193_end:
.annotate 'line', 1439
    goto if_4148_end
  if_4148:
.annotate 'line', 1421
    .const 'Sub' $P4153 = "493_1300146757.646" 
    capture_lex $P4153
    $P4153()
  if_4148_end:
    goto if_4059_end
  if_4059:
.annotate 'line', 1370
    .const 'Sub' $P4064 = "490_1300146757.646" 
    capture_lex $P4064
    $P4064()
  if_4059_end:
.annotate 'line', 1458
    get_hll_global $P4219, ["PAST"], "Var"
    find_lex $P4220, "$name"
    $P4221 = $P4219."new"($P4220 :named("name"))
    store_lex "$past", $P4221
  if_4045_end:
.annotate 'line', 1465
    find_lex $P4230, "$name"
    set $S4231, $P4230
    iseq $I4232, $S4231, "MAIN"
    if $I4232, if_4229
    new $P4228, 'Integer'
    set $P4228, $I4232
    goto if_4229_end
  if_4229:
    find_dynamic_lex $P4233, "$*MULTINESS"
    unless_null $P4233, vivify_1815
    get_hll_global $P4233, "$MULTINESS"
    unless_null $P4233, vivify_1816
    die "Contextual $*MULTINESS not found"
  vivify_1816:
  vivify_1815:
    set $S4234, $P4233
    isne $I4235, $S4234, "multi"
    new $P4228, 'Integer'
    set $P4228, $I4235
  if_4229_end:
    if $P4228, if_4227
    set $P4226, $P4228
    goto if_4227_end
  if_4227:
.annotate 'line', 1466
    find_lex $P4236, "$block"
    store_dynamic_lex "$*MAIN_SUB", $P4236
.annotate 'line', 1465
    set $P4226, $P4236
  if_4227_end:
.annotate 'line', 1366
    .return ($P4226)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4152"  :anon :subid("493_1300146757.646") :outer("489_1300146757.646")
.annotate 'line', 1426
    new $P4154, "Undef"
    .lex "$cholder", $P4154
.annotate 'line', 1425
    find_dynamic_lex $P4156, "$*SCOPE"
    unless_null $P4156, vivify_1785
    get_hll_global $P4156, "$SCOPE"
    unless_null $P4156, vivify_1786
    die "Contextual $*SCOPE not found"
  vivify_1786:
  vivify_1785:
    set $S4157, $P4156
    iseq $I4158, $S4157, "our"
    unless $I4158, if_4155_end
    die "our-scoped protos not yet implemented"
  if_4155_end:
.annotate 'line', 1426
    get_hll_global $P4159, ["PAST"], "Op"
    $P4160 = $P4159."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4160
.annotate 'line', 1427
    get_global $P4161, "@BLOCK"
    unless_null $P4161, vivify_1787
    $P4161 = root_new ['parrot';'ResizablePMCArray']
  vivify_1787:
    set $P4162, $P4161[0]
    unless_null $P4162, vivify_1788
    $P4162 = root_new ['parrot';'ResizablePMCArray']
  vivify_1788:
    set $P4163, $P4162[0]
    unless_null $P4163, vivify_1789
    new $P4163, "Undef"
  vivify_1789:
    get_hll_global $P4164, ["PAST"], "Var"
    find_lex $P4165, "$name"
    find_lex $P4166, "$past"
    $P4167 = $P4164."new"($P4165 :named("name"), 1 :named("isdecl"), $P4166 :named("viviself"), "lexical" :named("scope"))
    $P4163."push"($P4167)
.annotate 'line', 1429
    get_global $P4168, "@BLOCK"
    unless_null $P4168, vivify_1790
    $P4168 = root_new ['parrot';'ResizablePMCArray']
  vivify_1790:
    set $P4169, $P4168[0]
    unless_null $P4169, vivify_1791
    $P4169 = root_new ['parrot';'ResizablePMCArray']
  vivify_1791:
    set $P4170, $P4169[0]
    unless_null $P4170, vivify_1792
    new $P4170, "Undef"
  vivify_1792:
    get_hll_global $P4171, ["PAST"], "Op"
.annotate 'line', 1431
    get_hll_global $P4172, ["PAST"], "Var"
    find_lex $P4173, "$name"
    $P4174 = $P4172."new"($P4173 :named("name"))
    find_lex $P4175, "$cholder"
    $P4176 = $P4171."new"($P4174, $P4175, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1429
    $P4170."push"($P4176)
.annotate 'line', 1434
    get_global $P4177, "@BLOCK"
    unless_null $P4177, vivify_1793
    $P4177 = root_new ['parrot';'ResizablePMCArray']
  vivify_1793:
    set $P4178, $P4177[0]
    unless_null $P4178, vivify_1794
    new $P4178, "Undef"
  vivify_1794:
    find_lex $P4179, "$name"
    find_lex $P4180, "$cholder"
    $P4178."symbol"($P4179, "lexical" :named("scope"), 1 :named("proto"), $P4180 :named("cholder"))
.annotate 'line', 1437
    find_lex $P4181, "$past"
    $P4182 = $P4181."pirflags"(":instanceof(\"DispatcherSub\")")
.annotate 'line', 1421
    .return ($P4182)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4063"  :anon :subid("490_1300146757.646") :outer("489_1300146757.646")
.annotate 'line', 1370
    .const 'Sub' $P4082 = "491_1300146757.646" 
    capture_lex $P4082
.annotate 'line', 1373
    new $P4065, "Undef"
    .lex "$cholder", $P4065
.annotate 'line', 1374
    $P4066 = root_new ['parrot';'Hash']
    .lex "%sym", $P4066
.annotate 'line', 1372
    find_dynamic_lex $P4068, "$*SCOPE"
    unless_null $P4068, vivify_1795
    get_hll_global $P4068, "$SCOPE"
    unless_null $P4068, vivify_1796
    die "Contextual $*SCOPE not found"
  vivify_1796:
  vivify_1795:
    set $S4069, $P4068
    iseq $I4070, $S4069, "our"
    unless $I4070, if_4067_end
    die "our-scoped multis not yet implemented"
  if_4067_end:
    find_lex $P4071, "$cholder"
.annotate 'line', 1374
    get_global $P4072, "@BLOCK"
    unless_null $P4072, vivify_1797
    $P4072 = root_new ['parrot';'ResizablePMCArray']
  vivify_1797:
    set $P4073, $P4072[0]
    unless_null $P4073, vivify_1798
    new $P4073, "Undef"
  vivify_1798:
    find_lex $P4074, "$name"
    $P4075 = $P4073."symbol"($P4074)
    store_lex "%sym", $P4075
.annotate 'line', 1375
    find_lex $P4077, "%sym"
    unless_null $P4077, vivify_1799
    $P4077 = root_new ['parrot';'Hash']
  vivify_1799:
    set $P4078, $P4077["cholder"]
    unless_null $P4078, vivify_1800
    new $P4078, "Undef"
  vivify_1800:
    if $P4078, if_4076
.annotate 'line', 1380
    .const 'Sub' $P4082 = "491_1300146757.646" 
    capture_lex $P4082
    $P4082()
    goto if_4076_end
  if_4076:
.annotate 'line', 1376
    find_lex $P4079, "%sym"
    unless_null $P4079, vivify_1813
    $P4079 = root_new ['parrot';'Hash']
  vivify_1813:
    set $P4080, $P4079["cholder"]
    unless_null $P4080, vivify_1814
    new $P4080, "Undef"
  vivify_1814:
    store_lex "$cholder", $P4080
  if_4076_end:
.annotate 'line', 1416
    find_lex $P4144, "$cholder"
    find_lex $P4145, "$past"
    $P4144."push"($P4145)
.annotate 'line', 1419
    find_lex $P4146, "$past"
    $P4147 = "attach_multi_signature"($P4146)
.annotate 'line', 1370
    .return ($P4147)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4081"  :anon :subid("491_1300146757.646") :outer("490_1300146757.646")
.annotate 'line', 1380
    .const 'Sub' $P4096 = "492_1300146757.646" 
    capture_lex $P4096
.annotate 'line', 1387
    new $P4083, "Undef"
    .lex "$found_proto", $P4083
.annotate 'line', 1405
    new $P4084, "Undef"
    .lex "$dispatch_setup", $P4084
.annotate 'line', 1382
    find_lex $P4086, "%sym"
    unless_null $P4086, vivify_1801
    $P4086 = root_new ['parrot';'Hash']
  vivify_1801:
    set $P4087, $P4086["proto"]
    unless_null $P4087, vivify_1802
    new $P4087, "Undef"
  vivify_1802:
    unless $P4087, if_4085_end
.annotate 'line', 1385
    find_lex $P4088, "$/"
    $P4089 = $P4088."CURSOR"()
    $P4089."panic"("Internal Error: Current scope has a proto, but no candidate list holder was set up. (This should never happen.)")
  if_4085_end:
.annotate 'line', 1382
    find_lex $P4090, "$found_proto"
.annotate 'line', 1388
    get_global $P4092, "@BLOCK"
    defined $I4093, $P4092
    unless $I4093, for_undef_1803
    iter $P4091, $P4092
    new $P4118, 'ExceptionHandler'
    set_label $P4118, loop4117_handler
    $P4118."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4118
  loop4117_test:
    unless $P4091, loop4117_done
    shift $P4094, $P4091
  loop4117_redo:
    .const 'Sub' $P4096 = "492_1300146757.646" 
    capture_lex $P4096
    $P4096($P4094)
  loop4117_next:
    goto loop4117_test
  loop4117_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4119, exception, 'type'
    eq $P4119, .CONTROL_LOOP_NEXT, loop4117_next
    eq $P4119, .CONTROL_LOOP_REDO, loop4117_redo
  loop4117_done:
    pop_eh 
  for_undef_1803:
.annotate 'line', 1399
    find_lex $P4121, "$found_proto"
    if $P4121, unless_4120_end
.annotate 'line', 1400
    find_lex $P4122, "$/"
    $P4123 = $P4122."CURSOR"()
    $P4123."panic"("Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented.")
  unless_4120_end:
.annotate 'line', 1404
    get_hll_global $P4124, ["PAST"], "Op"
    $P4125 = $P4124."new"("list" :named("pasttype"))
    store_lex "$cholder", $P4125
.annotate 'line', 1405
    get_hll_global $P4126, ["PAST"], "Op"
.annotate 'line', 1407
    get_hll_global $P4127, ["PAST"], "Var"
    find_lex $P4128, "$name"
    $P4129 = $P4127."new"($P4128 :named("name"), "outer" :named("scope"))
    find_lex $P4130, "$cholder"
    $P4131 = $P4126."new"($P4129, $P4130, "create_dispatch_and_add_candidates PPP" :named("pirop"))
.annotate 'line', 1405
    store_lex "$dispatch_setup", $P4131
.annotate 'line', 1410
    get_global $P4132, "@BLOCK"
    unless_null $P4132, vivify_1808
    $P4132 = root_new ['parrot';'ResizablePMCArray']
  vivify_1808:
    set $P4133, $P4132[0]
    unless_null $P4133, vivify_1809
    $P4133 = root_new ['parrot';'ResizablePMCArray']
  vivify_1809:
    set $P4134, $P4133[0]
    unless_null $P4134, vivify_1810
    new $P4134, "Undef"
  vivify_1810:
    get_hll_global $P4135, ["PAST"], "Var"
    find_lex $P4136, "$name"
    find_lex $P4137, "$dispatch_setup"
    $P4138 = $P4135."new"($P4136 :named("name"), 1 :named("isdecl"), $P4137 :named("viviself"), "lexical" :named("scope"))
    $P4134."push"($P4138)
.annotate 'line', 1412
    get_global $P4139, "@BLOCK"
    unless_null $P4139, vivify_1811
    $P4139 = root_new ['parrot';'ResizablePMCArray']
  vivify_1811:
    set $P4140, $P4139[0]
    unless_null $P4140, vivify_1812
    new $P4140, "Undef"
  vivify_1812:
    find_lex $P4141, "$name"
    find_lex $P4142, "$cholder"
    $P4143 = $P4140."symbol"($P4141, "lexical" :named("scope"), $P4142 :named("cholder"))
.annotate 'line', 1380
    .return ($P4143)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4095"  :anon :subid("492_1300146757.646") :outer("491_1300146757.646")
    .param pmc param_4098
.annotate 'line', 1389
    $P4097 = root_new ['parrot';'Hash']
    .lex "%sym", $P4097
    .lex "$_", param_4098
    find_lex $P4099, "$_"
    find_lex $P4100, "$name"
    $P4101 = $P4099."symbol"($P4100)
    store_lex "%sym", $P4101
.annotate 'line', 1390
    find_lex $P4106, "%sym"
    unless_null $P4106, vivify_1804
    $P4106 = root_new ['parrot';'Hash']
  vivify_1804:
    set $P4107, $P4106["proto"]
    unless_null $P4107, vivify_1805
    new $P4107, "Undef"
  vivify_1805:
    unless $P4107, unless_4105
    set $P4104, $P4107
    goto unless_4105_end
  unless_4105:
    find_lex $P4108, "%sym"
    unless_null $P4108, vivify_1806
    $P4108 = root_new ['parrot';'Hash']
  vivify_1806:
    set $P4109, $P4108["cholder"]
    unless_null $P4109, vivify_1807
    new $P4109, "Undef"
  vivify_1807:
    set $P4104, $P4109
  unless_4105_end:
    if $P4104, if_4103
.annotate 'line', 1393
    find_lex $P4113, "%sym"
    if $P4113, if_4112
    set $P4111, $P4113
    goto if_4112_end
  if_4112:
.annotate 'line', 1394
    find_lex $P4114, "$/"
    $P4115 = $P4114."CURSOR"()
    $P4116 = $P4115."panic"("Cannot declare a multi when an only is already in scope.")
.annotate 'line', 1393
    set $P4111, $P4116
  if_4112_end:
    set $P4102, $P4111
.annotate 'line', 1390
    goto if_4103_end
  if_4103:
.annotate 'line', 1391
    new $P4110, "Integer"
    assign $P4110, 1
    store_lex "$found_proto", $P4110
.annotate 'line', 1390
    set $P4102, $P4110
  if_4103_end:
.annotate 'line', 1388
    .return ($P4102)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4247"  :anon :subid("494_1300146757.646") :outer("488_1300146757.646")
    .param pmc param_4249
.annotate 'line', 1473
    .lex "$_", param_4249
    find_lex $P4250, "$_"
    $P4251 = $P4250."ast"()
    find_lex $P4252, "$/"
    $P4253 = $P4251($P4252)
    .return ($P4253)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "method_def"  :subid("495_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4261
    .param pmc param_4262
.annotate 'line', 1480
    .const 'Sub' $P4374 = "497_1300146757.646" 
    capture_lex $P4374
    .const 'Sub' $P4290 = "496_1300146757.646" 
    capture_lex $P4290
    .lex "self", param_4261
    .lex "$/", param_4262
.annotate 'line', 1483
    new $P4263, "Undef"
    .lex "$past", $P4263
.annotate 'line', 1480
    find_lex $P4264, "$past"
.annotate 'line', 1484
    find_lex $P4266, "$/"
    unless_null $P4266, vivify_1823
    $P4266 = root_new ['parrot';'Hash']
  vivify_1823:
    set $P4267, $P4266["onlystar"]
    unless_null $P4267, vivify_1824
    new $P4267, "Undef"
  vivify_1824:
    if $P4267, if_4265
.annotate 'line', 1488
    find_lex $P4269, "$/"
    unless_null $P4269, vivify_1825
    $P4269 = root_new ['parrot';'Hash']
  vivify_1825:
    set $P4270, $P4269["blockoid"]
    unless_null $P4270, vivify_1826
    new $P4270, "Undef"
  vivify_1826:
    $P4271 = $P4270."ast"()
    store_lex "$past", $P4271
.annotate 'line', 1489
    find_lex $P4272, "$past"
    $P4272."blocktype"("declaration")
.annotate 'line', 1490
    find_dynamic_lex $P4274, "$*RETURN_USED"
    unless_null $P4274, vivify_1827
    get_hll_global $P4274, "$RETURN_USED"
    unless_null $P4274, vivify_1828
    die "Contextual $*RETURN_USED not found"
  vivify_1828:
  vivify_1827:
    unless $P4274, if_4273_end
.annotate 'line', 1491
    find_lex $P4275, "$past"
    $P4275."control"("return_pir")
  if_4273_end:
.annotate 'line', 1487
    goto if_4265_end
  if_4265:
.annotate 'line', 1485
    $P4268 = "only_star_block"()
    store_lex "$past", $P4268
  if_4265_end:
.annotate 'line', 1496
    find_lex $P4277, "$past"
    unless_null $P4277, vivify_1829
    $P4277 = root_new ['parrot';'Hash']
  vivify_1829:
    set $P4278, $P4277["signature_has_invocant"]
    unless_null $P4278, vivify_1830
    new $P4278, "Undef"
  vivify_1830:
    if $P4278, unless_4276_end
.annotate 'line', 1497
    find_lex $P4279, "$past"
    unless_null $P4279, vivify_1831
    $P4279 = root_new ['parrot';'ResizablePMCArray']
  vivify_1831:
    set $P4280, $P4279[0]
    unless_null $P4280, vivify_1832
    new $P4280, "Undef"
  vivify_1832:
    get_hll_global $P4281, ["PAST"], "Var"
.annotate 'line', 1499
    get_hll_global $P4282, ["PAST"], "Var"
    $P4283 = $P4282."new"("$?CLASS" :named("name"))
    $P4284 = $P4281."new"("self" :named("name"), "parameter" :named("scope"), $P4283 :named("multitype"))
.annotate 'line', 1497
    $P4280."unshift"($P4284)
  unless_4276_end:
.annotate 'line', 1502
    find_lex $P4285, "$past"
    $P4285."symbol"("self", "lexical" :named("scope"))
.annotate 'line', 1505
    find_lex $P4287, "$/"
    unless_null $P4287, vivify_1833
    $P4287 = root_new ['parrot';'Hash']
  vivify_1833:
    set $P4288, $P4287["deflongname"]
    unless_null $P4288, vivify_1834
    new $P4288, "Undef"
  vivify_1834:
    unless $P4288, if_4286_end
    .const 'Sub' $P4290 = "496_1300146757.646" 
    capture_lex $P4290
    $P4290()
  if_4286_end:
.annotate 'line', 1540
    find_dynamic_lex $P4356, "$*SCOPE"
    unless_null $P4356, vivify_1852
    get_hll_global $P4356, "$SCOPE"
    unless_null $P4356, vivify_1853
    die "Contextual $*SCOPE not found"
  vivify_1853:
  vivify_1852:
    set $S4357, $P4356
    iseq $I4358, $S4357, "our"
    unless $I4358, if_4355_end
.annotate 'line', 1541
    find_lex $P4359, "$past"
    $P4359."pirflags"(":nsentry")
  if_4355_end:
.annotate 'line', 1545
    find_lex $P4360, "$/"
    find_lex $P4361, "$past"
    $P4360."!make"($P4361)
.annotate 'line', 1546
    find_lex $P4362, "$past"
    find_lex $P4363, "$past"
    unless_null $P4363, vivify_1854
    $P4363 = root_new ['parrot';'Hash']
    store_lex "$past", $P4363
  vivify_1854:
    set $P4363["block_past"], $P4362
.annotate 'line', 1547
    find_lex $P4366, "$/"
    unless_null $P4366, vivify_1855
    $P4366 = root_new ['parrot';'Hash']
  vivify_1855:
    set $P4367, $P4366["trait"]
    unless_null $P4367, vivify_1856
    new $P4367, "Undef"
  vivify_1856:
    if $P4367, if_4365
    set $P4364, $P4367
    goto if_4365_end
  if_4365:
.annotate 'line', 1548
    find_lex $P4369, "$/"
    unless_null $P4369, vivify_1857
    $P4369 = root_new ['parrot';'Hash']
  vivify_1857:
    set $P4370, $P4369["trait"]
    unless_null $P4370, vivify_1858
    new $P4370, "Undef"
  vivify_1858:
    defined $I4371, $P4370
    unless $I4371, for_undef_1859
    iter $P4368, $P4370
    new $P4381, 'ExceptionHandler'
    set_label $P4381, loop4380_handler
    $P4381."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4381
  loop4380_test:
    unless $P4368, loop4380_done
    shift $P4372, $P4368
  loop4380_redo:
    .const 'Sub' $P4374 = "497_1300146757.646" 
    capture_lex $P4374
    $P4374($P4372)
  loop4380_next:
    goto loop4380_test
  loop4380_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4382, exception, 'type'
    eq $P4382, .CONTROL_LOOP_NEXT, loop4380_next
    eq $P4382, .CONTROL_LOOP_REDO, loop4380_redo
  loop4380_done:
    pop_eh 
  for_undef_1859:
.annotate 'line', 1547
    set $P4364, $P4368
  if_4365_end:
.annotate 'line', 1480
    .return ($P4364)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4289"  :anon :subid("496_1300146757.646") :outer("495_1300146757.646")
.annotate 'line', 1507
    new $P4291, "Undef"
    .lex "$name", $P4291
.annotate 'line', 1512
    new $P4292, "Undef"
    .lex "$to_add", $P4292
.annotate 'line', 1507
    find_lex $P4293, "$/"
    unless_null $P4293, vivify_1835
    $P4293 = root_new ['parrot';'Hash']
  vivify_1835:
    set $P4294, $P4293["private"]
    unless_null $P4294, vivify_1836
    new $P4294, "Undef"
  vivify_1836:
    set $S4295, $P4294
    new $P4296, 'String'
    set $P4296, $S4295
    find_lex $P4297, "$/"
    unless_null $P4297, vivify_1837
    $P4297 = root_new ['parrot';'Hash']
  vivify_1837:
    set $P4298, $P4297["deflongname"]
    unless_null $P4298, vivify_1838
    $P4298 = root_new ['parrot';'ResizablePMCArray']
  vivify_1838:
    set $P4299, $P4298[0]
    unless_null $P4299, vivify_1839
    new $P4299, "Undef"
  vivify_1839:
    $P4300 = $P4299."ast"()
    set $S4301, $P4300
    concat $P4302, $P4296, $S4301
    store_lex "$name", $P4302
.annotate 'line', 1508
    find_lex $P4303, "$past"
    find_lex $P4304, "$name"
    $P4303."name"($P4304)
.annotate 'line', 1512
    find_dynamic_lex $P4307, "$*MULTINESS"
    unless_null $P4307, vivify_1840
    get_hll_global $P4307, "$MULTINESS"
    unless_null $P4307, vivify_1841
    die "Contextual $*MULTINESS not found"
  vivify_1841:
  vivify_1840:
    set $S4308, $P4307
    isne $I4309, $S4308, "proto"
    if $I4309, if_4306
.annotate 'line', 1514
    get_hll_global $P4313, ["PAST"], "Op"
.annotate 'line', 1516
    get_hll_global $P4314, ["PAST"], "Val"
    find_lex $P4315, "$past"
    $P4316 = $P4314."new"($P4315 :named("value"))
.annotate 'line', 1517
    get_hll_global $P4317, ["PAST"], "Op"
    $P4318 = $P4317."new"("list" :named("pasttype"))
    $P4319 = $P4313."new"($P4316, $P4318, "set_dispatchees 0PP" :named("pirop"))
.annotate 'line', 1514
    set $P4305, $P4319
.annotate 'line', 1512
    goto if_4306_end
  if_4306:
.annotate 'line', 1513
    get_hll_global $P4310, ["PAST"], "Val"
    find_lex $P4311, "$past"
    $P4312 = $P4310."new"($P4311 :named("value"))
    set $P4305, $P4312
  if_4306_end:
.annotate 'line', 1512
    store_lex "$to_add", $P4305
.annotate 'line', 1519
    find_dynamic_lex $P4321, "$*MULTINESS"
    unless_null $P4321, vivify_1842
    get_hll_global $P4321, "$MULTINESS"
    unless_null $P4321, vivify_1843
    die "Contextual $*MULTINESS not found"
  vivify_1843:
  vivify_1842:
    set $S4322, $P4321
    iseq $I4323, $S4322, "proto"
    unless $I4323, if_4320_end
    find_lex $P4324, "$past"
    $P4324."pirflags"(":instanceof(\"DispatcherSub\")")
  if_4320_end:
.annotate 'line', 1523
    find_dynamic_lex $P4326, "$*MULTINESS"
    unless_null $P4326, vivify_1844
    get_hll_global $P4326, "$MULTINESS"
    unless_null $P4326, vivify_1845
    die "Contextual $*MULTINESS not found"
  vivify_1845:
  vivify_1844:
    set $S4327, $P4326
    iseq $I4328, $S4327, "multi"
    unless $I4328, if_4325_end
    find_lex $P4329, "$past"
    "attach_multi_signature"($P4329)
  if_4325_end:
.annotate 'line', 1526
    find_dynamic_lex $P4332, "$*PACKAGE-SETUP"
    unless_null $P4332, vivify_1846
    get_hll_global $P4332, "$PACKAGE-SETUP"
    unless_null $P4332, vivify_1847
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1847:
  vivify_1846:
    defined $I4333, $P4332
    if $I4333, if_4331
    new $P4330, 'Integer'
    set $P4330, $I4333
    goto if_4331_end
  if_4331:
.annotate 'line', 1527
    find_dynamic_lex $P4334, "$*PACKAGE-SETUP"
    unless_null $P4334, vivify_1848
    get_hll_global $P4334, "$PACKAGE-SETUP"
    unless_null $P4334, vivify_1849
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1849:
  vivify_1848:
    get_hll_global $P4335, ["PAST"], "Op"
.annotate 'line', 1528
    find_dynamic_lex $P4338, "$*MULTINESS"
    unless_null $P4338, vivify_1850
    get_hll_global $P4338, "$MULTINESS"
    unless_null $P4338, vivify_1851
    die "Contextual $*MULTINESS not found"
  vivify_1851:
  vivify_1850:
    set $S4339, $P4338
    iseq $I4340, $S4339, "multi"
    if $I4340, if_4337
    new $P4342, "String"
    assign $P4342, "add_method"
    set $P4336, $P4342
    goto if_4337_end
  if_4337:
    new $P4341, "String"
    assign $P4341, "add_multi_method"
    set $P4336, $P4341
  if_4337_end:
.annotate 'line', 1529
    get_hll_global $P4343, ["PAST"], "Op"
.annotate 'line', 1532
    get_hll_global $P4344, ["PAST"], "Var"
    $P4345 = $P4344."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4346 = $P4343."new"($P4345, "get_how PP" :named("pirop"))
.annotate 'line', 1534
    get_hll_global $P4347, ["PAST"], "Var"
    $P4348 = $P4347."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1535
    get_hll_global $P4349, ["PAST"], "Val"
    find_lex $P4350, "$name"
    $P4351 = $P4349."new"($P4350 :named("value"))
    find_lex $P4352, "$to_add"
    $P4353 = $P4335."new"($P4346, $P4348, $P4351, $P4352, "callmethod" :named("pasttype"), $P4336 :named("name"))
.annotate 'line', 1527
    $P4354 = $P4334."push"($P4353)
.annotate 'line', 1526
    set $P4330, $P4354
  if_4331_end:
.annotate 'line', 1505
    .return ($P4330)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4373"  :anon :subid("497_1300146757.646") :outer("495_1300146757.646")
    .param pmc param_4375
.annotate 'line', 1548
    .lex "$_", param_4375
    find_lex $P4376, "$_"
    $P4377 = $P4376."ast"()
    find_lex $P4378, "$/"
    $P4379 = $P4377($P4378)
    .return ($P4379)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "signature"  :subid("498_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4386
    .param pmc param_4387
.annotate 'line', 1580
    .const 'Sub' $P4420 = "500_1300146757.646" 
    capture_lex $P4420
    .const 'Sub' $P4396 = "499_1300146757.646" 
    capture_lex $P4396
    .lex "self", param_4386
    .lex "$/", param_4387
.annotate 'line', 1581
    new $P4388, "Undef"
    .lex "$BLOCKINIT", $P4388
    get_global $P4389, "@BLOCK"
    unless_null $P4389, vivify_1860
    $P4389 = root_new ['parrot';'ResizablePMCArray']
  vivify_1860:
    set $P4390, $P4389[0]
    unless_null $P4390, vivify_1861
    $P4390 = root_new ['parrot';'ResizablePMCArray']
  vivify_1861:
    set $P4391, $P4390[0]
    unless_null $P4391, vivify_1862
    new $P4391, "Undef"
  vivify_1862:
    store_lex "$BLOCKINIT", $P4391
.annotate 'line', 1582
    find_lex $P4393, "$/"
    unless_null $P4393, vivify_1863
    $P4393 = root_new ['parrot';'Hash']
  vivify_1863:
    set $P4394, $P4393["invocant"]
    unless_null $P4394, vivify_1864
    new $P4394, "Undef"
  vivify_1864:
    unless $P4394, if_4392_end
    .const 'Sub' $P4396 = "499_1300146757.646" 
    capture_lex $P4396
    $P4396()
  if_4392_end:
.annotate 'line', 1591
    find_lex $P4415, "$/"
    unless_null $P4415, vivify_1870
    $P4415 = root_new ['parrot';'Hash']
  vivify_1870:
    set $P4416, $P4415["parameter"]
    unless_null $P4416, vivify_1871
    new $P4416, "Undef"
  vivify_1871:
    defined $I4417, $P4416
    unless $I4417, for_undef_1872
    iter $P4414, $P4416
    new $P4427, 'ExceptionHandler'
    set_label $P4427, loop4426_handler
    $P4427."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4427
  loop4426_test:
    unless $P4414, loop4426_done
    shift $P4418, $P4414
  loop4426_redo:
    .const 'Sub' $P4420 = "500_1300146757.646" 
    capture_lex $P4420
    $P4420($P4418)
  loop4426_next:
    goto loop4426_test
  loop4426_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4428, exception, 'type'
    eq $P4428, .CONTROL_LOOP_NEXT, loop4426_next
    eq $P4428, .CONTROL_LOOP_REDO, loop4426_redo
  loop4426_done:
    pop_eh 
  for_undef_1872:
.annotate 'line', 1580
    .return ($P4414)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4395"  :anon :subid("499_1300146757.646") :outer("498_1300146757.646")
.annotate 'line', 1583
    new $P4397, "Undef"
    .lex "$inv", $P4397
    find_lex $P4398, "$/"
    unless_null $P4398, vivify_1865
    $P4398 = root_new ['parrot';'Hash']
  vivify_1865:
    set $P4399, $P4398["invocant"]
    unless_null $P4399, vivify_1866
    $P4399 = root_new ['parrot';'ResizablePMCArray']
  vivify_1866:
    set $P4400, $P4399[0]
    unless_null $P4400, vivify_1867
    new $P4400, "Undef"
  vivify_1867:
    $P4401 = $P4400."ast"()
    store_lex "$inv", $P4401
.annotate 'line', 1584
    find_lex $P4402, "$BLOCKINIT"
    find_lex $P4403, "$inv"
    $P4402."push"($P4403)
.annotate 'line', 1585
    find_lex $P4404, "$BLOCKINIT"
    get_hll_global $P4405, ["PAST"], "Var"
.annotate 'line', 1587
    get_hll_global $P4406, ["PAST"], "Var"
    find_lex $P4407, "$inv"
    $P4408 = $P4407."name"()
    $P4409 = $P4406."new"("lexical" :named("scope"), $P4408 :named("name"))
    $P4410 = $P4405."new"("self" :named("name"), "lexical" :named("scope"), 1 :named("isdecl"), $P4409 :named("viviself"))
.annotate 'line', 1585
    $P4404."push"($P4410)
.annotate 'line', 1589
    new $P4411, "Integer"
    assign $P4411, 1
    get_global $P4412, "@BLOCK"
    unless_null $P4412, vivify_1868
    $P4412 = root_new ['parrot';'ResizablePMCArray']
    set_global "@BLOCK", $P4412
  vivify_1868:
    set $P4413, $P4412[0]
    unless_null $P4413, vivify_1869
    $P4413 = root_new ['parrot';'Hash']
    set $P4412[0], $P4413
  vivify_1869:
    set $P4413["signature_has_invocant"], $P4411
.annotate 'line', 1582
    .return ($P4411)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4419"  :anon :subid("500_1300146757.646") :outer("498_1300146757.646")
    .param pmc param_4421
.annotate 'line', 1591
    .lex "$_", param_4421
    find_lex $P4422, "$BLOCKINIT"
    find_lex $P4423, "$_"
    $P4424 = $P4423."ast"()
    $P4425 = $P4422."push"($P4424)
    .return ($P4425)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "parameter"  :subid("501_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4430
    .param pmc param_4431
.annotate 'line', 1594
    .lex "self", param_4430
    .lex "$/", param_4431
.annotate 'line', 1595
    new $P4432, "Undef"
    .lex "$quant", $P4432
.annotate 'line', 1596
    new $P4433, "Undef"
    .lex "$past", $P4433
.annotate 'line', 1595
    find_lex $P4434, "$/"
    unless_null $P4434, vivify_1873
    $P4434 = root_new ['parrot';'Hash']
  vivify_1873:
    set $P4435, $P4434["quant"]
    unless_null $P4435, vivify_1874
    new $P4435, "Undef"
  vivify_1874:
    store_lex "$quant", $P4435
    find_lex $P4436, "$past"
.annotate 'line', 1597
    find_lex $P4438, "$/"
    unless_null $P4438, vivify_1875
    $P4438 = root_new ['parrot';'Hash']
  vivify_1875:
    set $P4439, $P4438["named_param"]
    unless_null $P4439, vivify_1876
    new $P4439, "Undef"
  vivify_1876:
    if $P4439, if_4437
.annotate 'line', 1604
    find_lex $P4453, "$/"
    unless_null $P4453, vivify_1877
    $P4453 = root_new ['parrot';'Hash']
  vivify_1877:
    set $P4454, $P4453["param_var"]
    unless_null $P4454, vivify_1878
    new $P4454, "Undef"
  vivify_1878:
    $P4455 = $P4454."ast"()
    store_lex "$past", $P4455
.annotate 'line', 1605
    find_lex $P4457, "$quant"
    set $S4458, $P4457
    iseq $I4459, $S4458, "*"
    if $I4459, if_4456
.annotate 'line', 1609
    find_lex $P4468, "$quant"
    set $S4469, $P4468
    iseq $I4470, $S4469, "?"
    unless $I4470, if_4467_end
.annotate 'line', 1610
    find_lex $P4471, "$past"
    find_lex $P4472, "$/"
    unless_null $P4472, vivify_1879
    $P4472 = root_new ['parrot';'Hash']
  vivify_1879:
    set $P4473, $P4472["param_var"]
    unless_null $P4473, vivify_1880
    $P4473 = root_new ['parrot';'Hash']
  vivify_1880:
    set $P4474, $P4473["sigil"]
    unless_null $P4474, vivify_1881
    new $P4474, "Undef"
  vivify_1881:
    $P4475 = "vivitype"($P4474)
    $P4471."viviself"($P4475)
  if_4467_end:
.annotate 'line', 1609
    goto if_4456_end
  if_4456:
.annotate 'line', 1606
    find_lex $P4460, "$past"
    $P4460."slurpy"(1)
.annotate 'line', 1607
    find_lex $P4461, "$past"
    find_lex $P4462, "$/"
    unless_null $P4462, vivify_1882
    $P4462 = root_new ['parrot';'Hash']
  vivify_1882:
    set $P4463, $P4462["param_var"]
    unless_null $P4463, vivify_1883
    $P4463 = root_new ['parrot';'Hash']
  vivify_1883:
    set $P4464, $P4463["sigil"]
    unless_null $P4464, vivify_1884
    new $P4464, "Undef"
  vivify_1884:
    set $S4465, $P4464
    iseq $I4466, $S4465, "%"
    $P4461."named"($I4466)
  if_4456_end:
.annotate 'line', 1603
    goto if_4437_end
  if_4437:
.annotate 'line', 1598
    find_lex $P4440, "$/"
    unless_null $P4440, vivify_1885
    $P4440 = root_new ['parrot';'Hash']
  vivify_1885:
    set $P4441, $P4440["named_param"]
    unless_null $P4441, vivify_1886
    new $P4441, "Undef"
  vivify_1886:
    $P4442 = $P4441."ast"()
    store_lex "$past", $P4442
.annotate 'line', 1599
    find_lex $P4444, "$quant"
    set $S4445, $P4444
    isne $I4446, $S4445, "!"
    unless $I4446, if_4443_end
.annotate 'line', 1600
    find_lex $P4447, "$past"
    find_lex $P4448, "$/"
    unless_null $P4448, vivify_1887
    $P4448 = root_new ['parrot';'Hash']
  vivify_1887:
    set $P4449, $P4448["named_param"]
    unless_null $P4449, vivify_1888
    $P4449 = root_new ['parrot';'Hash']
  vivify_1888:
    set $P4450, $P4449["param_var"]
    unless_null $P4450, vivify_1889
    $P4450 = root_new ['parrot';'Hash']
  vivify_1889:
    set $P4451, $P4450["sigil"]
    unless_null $P4451, vivify_1890
    new $P4451, "Undef"
  vivify_1890:
    $P4452 = "vivitype"($P4451)
    $P4447."viviself"($P4452)
  if_4443_end:
  if_4437_end:
.annotate 'line', 1613
    find_lex $P4477, "$/"
    unless_null $P4477, vivify_1891
    $P4477 = root_new ['parrot';'Hash']
  vivify_1891:
    set $P4478, $P4477["default_value"]
    unless_null $P4478, vivify_1892
    new $P4478, "Undef"
  vivify_1892:
    unless $P4478, if_4476_end
.annotate 'line', 1614
    find_lex $P4480, "$quant"
    set $S4481, $P4480
    iseq $I4482, $S4481, "*"
    unless $I4482, if_4479_end
.annotate 'line', 1615
    find_lex $P4483, "$/"
    $P4484 = $P4483."CURSOR"()
    $P4484."panic"("Can't put default on slurpy parameter")
  if_4479_end:
.annotate 'line', 1617
    find_lex $P4486, "$quant"
    set $S4487, $P4486
    iseq $I4488, $S4487, "!"
    unless $I4488, if_4485_end
.annotate 'line', 1618
    find_lex $P4489, "$/"
    $P4490 = $P4489."CURSOR"()
    $P4490."panic"("Can't put default on required parameter")
  if_4485_end:
.annotate 'line', 1620
    find_lex $P4491, "$past"
    find_lex $P4492, "$/"
    unless_null $P4492, vivify_1893
    $P4492 = root_new ['parrot';'Hash']
  vivify_1893:
    set $P4493, $P4492["default_value"]
    unless_null $P4493, vivify_1894
    $P4493 = root_new ['parrot';'ResizablePMCArray']
  vivify_1894:
    set $P4494, $P4493[0]
    unless_null $P4494, vivify_1895
    $P4494 = root_new ['parrot';'Hash']
  vivify_1895:
    set $P4495, $P4494["EXPR"]
    unless_null $P4495, vivify_1896
    new $P4495, "Undef"
  vivify_1896:
    $P4496 = $P4495."ast"()
    $P4491."viviself"($P4496)
  if_4476_end:
.annotate 'line', 1622
    find_lex $P4498, "$past"
    $P4499 = $P4498."viviself"()
    if $P4499, unless_4497_end
    get_global $P4500, "@BLOCK"
    unless_null $P4500, vivify_1897
    $P4500 = root_new ['parrot';'ResizablePMCArray']
  vivify_1897:
    set $P4501, $P4500[0]
    unless_null $P4501, vivify_1898
    new $P4501, "Undef"
  vivify_1898:
    get_global $P4502, "@BLOCK"
    unless_null $P4502, vivify_1899
    $P4502 = root_new ['parrot';'ResizablePMCArray']
  vivify_1899:
    set $P4503, $P4502[0]
    unless_null $P4503, vivify_1900
    new $P4503, "Undef"
  vivify_1900:
    $P4504 = $P4503."arity"()
    set $N4505, $P4504
    new $P4506, 'Float'
    set $P4506, $N4505
    add $P4507, $P4506, 1
    $P4501."arity"($P4507)
  unless_4497_end:
.annotate 'line', 1626
    find_lex $P4509, "$/"
    unless_null $P4509, vivify_1901
    $P4509 = root_new ['parrot';'Hash']
  vivify_1901:
    set $P4510, $P4509["typename"]
    unless_null $P4510, vivify_1902
    new $P4510, "Undef"
  vivify_1902:
    unless $P4510, if_4508_end
.annotate 'line', 1627
    find_lex $P4511, "$past"
    find_lex $P4512, "$/"
    unless_null $P4512, vivify_1903
    $P4512 = root_new ['parrot';'Hash']
  vivify_1903:
    set $P4513, $P4512["typename"]
    unless_null $P4513, vivify_1904
    $P4513 = root_new ['parrot';'ResizablePMCArray']
  vivify_1904:
    set $P4514, $P4513[0]
    unless_null $P4514, vivify_1905
    new $P4514, "Undef"
  vivify_1905:
    $P4515 = $P4514."ast"()
    $P4511."multitype"($P4515)
  if_4508_end:
.annotate 'line', 1631
    find_lex $P4517, "$/"
    unless_null $P4517, vivify_1906
    $P4517 = root_new ['parrot';'Hash']
  vivify_1906:
    set $P4518, $P4517["definedness"]
    unless_null $P4518, vivify_1907
    new $P4518, "Undef"
  vivify_1907:
    unless $P4518, if_4516_end
.annotate 'line', 1632
    find_lex $P4519, "$/"
    unless_null $P4519, vivify_1908
    $P4519 = root_new ['parrot';'Hash']
  vivify_1908:
    set $P4520, $P4519["definedness"]
    unless_null $P4520, vivify_1909
    $P4520 = root_new ['parrot';'ResizablePMCArray']
  vivify_1909:
    set $P4521, $P4520[0]
    unless_null $P4521, vivify_1910
    new $P4521, "Undef"
  vivify_1910:
    set $S4522, $P4521
    new $P4523, 'String'
    set $P4523, $S4522
    find_lex $P4524, "$past"
    unless_null $P4524, vivify_1911
    $P4524 = root_new ['parrot';'Hash']
    store_lex "$past", $P4524
  vivify_1911:
    set $P4524["definedness"], $P4523
  if_4516_end:
.annotate 'line', 1635
    find_lex $P4525, "$/"
    find_lex $P4526, "$past"
    $P4527 = $P4525."!make"($P4526)
.annotate 'line', 1594
    .return ($P4527)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "param_var"  :subid("502_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4529
    .param pmc param_4530
.annotate 'line', 1638
    .lex "self", param_4529
    .lex "$/", param_4530
.annotate 'line', 1639
    new $P4531, "Undef"
    .lex "$name", $P4531
.annotate 'line', 1640
    new $P4532, "Undef"
    .lex "$past", $P4532
.annotate 'line', 1639
    find_lex $P4533, "$/"
    set $S4534, $P4533
    new $P4535, 'String'
    set $P4535, $S4534
    store_lex "$name", $P4535
.annotate 'line', 1640
    get_hll_global $P4536, ["PAST"], "Var"
    find_lex $P4537, "$name"
    find_lex $P4538, "$/"
    $P4539 = $P4536."new"($P4537 :named("name"), "parameter" :named("scope"), 1 :named("isdecl"), $P4538 :named("node"))
    store_lex "$past", $P4539
.annotate 'line', 1642
    get_global $P4540, "@BLOCK"
    unless_null $P4540, vivify_1912
    $P4540 = root_new ['parrot';'ResizablePMCArray']
  vivify_1912:
    set $P4541, $P4540[0]
    unless_null $P4541, vivify_1913
    new $P4541, "Undef"
  vivify_1913:
    find_lex $P4542, "$name"
    $P4541."symbol"($P4542, "lexical" :named("scope"))
.annotate 'line', 1643
    find_lex $P4543, "$/"
    find_lex $P4544, "$past"
    $P4545 = $P4543."!make"($P4544)
.annotate 'line', 1638
    .return ($P4545)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "named_param"  :subid("503_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4547
    .param pmc param_4548
.annotate 'line', 1646
    .lex "self", param_4547
    .lex "$/", param_4548
.annotate 'line', 1647
    new $P4549, "Undef"
    .lex "$past", $P4549
    find_lex $P4550, "$/"
    unless_null $P4550, vivify_1914
    $P4550 = root_new ['parrot';'Hash']
  vivify_1914:
    set $P4551, $P4550["param_var"]
    unless_null $P4551, vivify_1915
    new $P4551, "Undef"
  vivify_1915:
    $P4552 = $P4551."ast"()
    store_lex "$past", $P4552
.annotate 'line', 1648
    find_lex $P4553, "$past"
    find_lex $P4554, "$/"
    unless_null $P4554, vivify_1916
    $P4554 = root_new ['parrot';'Hash']
  vivify_1916:
    set $P4555, $P4554["param_var"]
    unless_null $P4555, vivify_1917
    $P4555 = root_new ['parrot';'Hash']
  vivify_1917:
    set $P4556, $P4555["name"]
    unless_null $P4556, vivify_1918
    new $P4556, "Undef"
  vivify_1918:
    set $S4557, $P4556
    $P4553."named"($S4557)
.annotate 'line', 1649
    find_lex $P4558, "$/"
    find_lex $P4559, "$past"
    $P4560 = $P4558."!make"($P4559)
.annotate 'line', 1646
    .return ($P4560)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "typename"  :subid("504_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4562
    .param pmc param_4563
.annotate 'line', 1652
    .lex "self", param_4562
    .lex "$/", param_4563
.annotate 'line', 1653
    $P4564 = root_new ['parrot';'ResizablePMCArray']
    .lex "@name", $P4564
    get_hll_global $P4565, ["HLL"], "Compiler"
    find_lex $P4566, "$/"
    set $S4567, $P4566
    $P4568 = $P4565."parse_name"($S4567)
    store_lex "@name", $P4568
.annotate 'line', 1654
    find_lex $P4569, "$/"
    get_hll_global $P4570, ["PAST"], "Var"
.annotate 'line', 1655
    find_lex $P4571, "@name"
    $P4572 = $P4571."pop"()
    find_lex $P4573, "@name"
    $P4574 = $P4570."new"($P4572 :named("name"), $P4573 :named("namespace"), "package" :named("scope"))
.annotate 'line', 1654
    $P4575 = $P4569."!make"($P4574)
.annotate 'line', 1652
    .return ($P4575)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait"  :subid("505_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4577
    .param pmc param_4578
.annotate 'line', 1661
    .lex "self", param_4577
    .lex "$/", param_4578
.annotate 'line', 1662
    find_lex $P4579, "$/"
    find_lex $P4580, "$/"
    unless_null $P4580, vivify_1919
    $P4580 = root_new ['parrot';'Hash']
  vivify_1919:
    set $P4581, $P4580["trait_mod"]
    unless_null $P4581, vivify_1920
    new $P4581, "Undef"
  vivify_1920:
    $P4582 = $P4581."ast"()
    $P4583 = $P4579."!make"($P4582)
.annotate 'line', 1661
    .return ($P4583)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "trait_mod:sym<is>"  :subid("506_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4585
    .param pmc param_4586
.annotate 'line', 1665
    .const 'Sub' $P4606 = "507_1300146757.646" 
    capture_lex $P4606
    .lex "self", param_4585
    .lex "$/", param_4586
.annotate 'line', 1666
    new $P4587, "Undef"
    .lex "$cpast", $P4587
    find_lex $P4588, "$/"
    unless_null $P4588, vivify_1921
    $P4588 = root_new ['parrot';'Hash']
  vivify_1921:
    set $P4589, $P4588["circumfix"]
    unless_null $P4589, vivify_1922
    $P4589 = root_new ['parrot';'ResizablePMCArray']
  vivify_1922:
    set $P4590, $P4589[0]
    unless_null $P4590, vivify_1923
    new $P4590, "Undef"
  vivify_1923:
    $P4591 = $P4590."ast"()
    store_lex "$cpast", $P4591
.annotate 'line', 1667
    find_lex $P4594, "$/"
    unless_null $P4594, vivify_1924
    $P4594 = root_new ['parrot';'Hash']
  vivify_1924:
    set $P4595, $P4594["longname"]
    unless_null $P4595, vivify_1925
    new $P4595, "Undef"
  vivify_1925:
    set $S4596, $P4595
    iseq $I4597, $S4596, "parrot_vtable"
    if $I4597, if_4593
.annotate 'line', 1687
    find_lex $P4632, "$/"
    unless_null $P4632, vivify_1926
    $P4632 = root_new ['parrot';'Hash']
  vivify_1926:
    set $P4633, $P4632["longname"]
    unless_null $P4633, vivify_1927
    new $P4633, "Undef"
  vivify_1927:
    set $S4634, $P4633
    iseq $I4635, $S4634, "pirflags"
    if $I4635, if_4631
.annotate 'line', 1691
    find_lex $P4639, "$/"
    $P4640 = $P4639."CURSOR"()
    new $P4641, 'String'
    set $P4641, "Trait '"
    find_lex $P4642, "$/"
    unless_null $P4642, vivify_1928
    $P4642 = root_new ['parrot';'Hash']
  vivify_1928:
    set $P4643, $P4642["longname"]
    unless_null $P4643, vivify_1929
    new $P4643, "Undef"
  vivify_1929:
    concat $P4644, $P4641, $P4643
    concat $P4645, $P4644, "' not implemented"
    $P4646 = $P4640."panic"($P4645)
.annotate 'line', 1690
    set $P4630, $P4646
.annotate 'line', 1687
    goto if_4631_end
  if_4631:
.annotate 'line', 1688
    find_lex $P4636, "$/"
    $P4637 = $P4636."CURSOR"()
    $P4638 = $P4637."panic"("Trait 'pirflags' no longer supported; use 'is vtable'")
.annotate 'line', 1687
    set $P4630, $P4638
  if_4631_end:
    set $P4592, $P4630
.annotate 'line', 1667
    goto if_4593_end
  if_4593:
.annotate 'line', 1670
    get_hll_global $P4599, ["PAST"], "Val"
    find_lex $P4600, "$cpast"
    $P4601 = $P4599."ACCEPTS"($P4600)
    if $P4601, unless_4598_end
.annotate 'line', 1669
    find_lex $P4602, "$/"
    $P4603 = $P4602."CURSOR"()
    $P4603."panic"("Trait 'parrot_vtable' requires constant scalar argument")
  unless_4598_end:
.annotate 'line', 1671
    find_lex $P4604, "$/"
    .const 'Sub' $P4606 = "507_1300146757.646" 
    newclosure $P4628, $P4606
    $P4629 = $P4604."!make"($P4628)
.annotate 'line', 1667
    set $P4592, $P4629
  if_4593_end:
.annotate 'line', 1665
    .return ($P4592)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4605"  :anon :subid("507_1300146757.646") :outer("506_1300146757.646")
    .param pmc param_4607
.annotate 'line', 1671
    .lex "$match", param_4607
.annotate 'line', 1672
    new $P4608, "Undef"
    .lex "$meth", $P4608
    find_lex $P4609, "$match"
    $P4610 = $P4609."ast"()
    set $P4611, $P4610["block_past"]
    unless_null $P4611, vivify_1930
    new $P4611, "Undef"
  vivify_1930:
    store_lex "$meth", $P4611
.annotate 'line', 1673
    find_dynamic_lex $P4614, "$*PACKAGE-SETUP"
    unless_null $P4614, vivify_1931
    get_hll_global $P4614, "$PACKAGE-SETUP"
    unless_null $P4614, vivify_1932
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1932:
  vivify_1931:
    defined $I4615, $P4614
    if $I4615, if_4613
    new $P4612, 'Integer'
    set $P4612, $I4615
    goto if_4613_end
  if_4613:
.annotate 'line', 1674
    find_dynamic_lex $P4616, "$*PACKAGE-SETUP"
    unless_null $P4616, vivify_1933
    get_hll_global $P4616, "$PACKAGE-SETUP"
    unless_null $P4616, vivify_1934
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1934:
  vivify_1933:
    get_hll_global $P4617, ["PAST"], "Op"
.annotate 'line', 1676
    get_hll_global $P4618, ["PAST"], "Op"
.annotate 'line', 1679
    get_hll_global $P4619, ["PAST"], "Var"
    $P4620 = $P4619."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4621 = $P4618."new"($P4620, "get_how PP" :named("pirop"))
.annotate 'line', 1681
    get_hll_global $P4622, ["PAST"], "Var"
    $P4623 = $P4622."new"("type_obj" :named("name"), "register" :named("scope"))
    find_lex $P4624, "$cpast"
    find_lex $P4625, "$meth"
    $P4626 = $P4617."new"($P4621, $P4623, $P4624, $P4625, "callmethod" :named("pasttype"), "add_parrot_vtable_mapping" :named("name"))
.annotate 'line', 1674
    $P4627 = $P4616."push"($P4626)
.annotate 'line', 1673
    set $P4612, $P4627
  if_4613_end:
.annotate 'line', 1671
    .return ($P4612)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "regex_declarator"  :subid("508_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4650
    .param pmc param_4651
    .param pmc param_4652 :optional
    .param int has_param_4652 :opt_flag
.annotate 'line', 1695
    .const 'Sub' $P4750 = "511_1300146757.646" 
    capture_lex $P4750
    .const 'Sub' $P4722 = "510_1300146757.646" 
    capture_lex $P4722
    .const 'Sub' $P4695 = "509_1300146757.646" 
    capture_lex $P4695
    new $P4649, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P4649, control_4648
    push_eh $P4649
    .lex "self", param_4650
    .lex "$/", param_4651
    if has_param_4652, optparam_1935
    new $P4653, "Undef"
    set param_4652, $P4653
  optparam_1935:
    .lex "$key", param_4652
.annotate 'line', 1696
    $P4654 = root_new ['parrot';'ResizablePMCArray']
    .lex "@MODIFIERS", $P4654
.annotate 'line', 1699
    new $P4655, "Undef"
    .lex "$name", $P4655
.annotate 'line', 1700
    new $P4656, "Undef"
    .lex "$past", $P4656
.annotate 'line', 1696

            $P4657 = get_hll_global ['Regex';'P6Regex';'Actions'], '@MODIFIERS'
        
    store_lex "@MODIFIERS", $P4657
.annotate 'line', 1699
    find_lex $P4658, "$/"
    unless_null $P4658, vivify_1936
    $P4658 = root_new ['parrot';'Hash']
  vivify_1936:
    set $P4659, $P4658["deflongname"]
    unless_null $P4659, vivify_1937
    new $P4659, "Undef"
  vivify_1937:
    $P4660 = $P4659."ast"()
    set $S4661, $P4660
    new $P4662, 'String'
    set $P4662, $S4661
    store_lex "$name", $P4662
    find_lex $P4663, "$past"
.annotate 'line', 1701
    find_lex $P4665, "$/"
    unless_null $P4665, vivify_1938
    $P4665 = root_new ['parrot';'Hash']
  vivify_1938:
    set $P4666, $P4665["proto"]
    unless_null $P4666, vivify_1939
    new $P4666, "Undef"
  vivify_1939:
    if $P4666, if_4664
.annotate 'line', 1740
    find_lex $P4718, "$key"
    set $S4719, $P4718
    iseq $I4720, $S4719, "open"
    if $I4720, if_4717
.annotate 'line', 1753
    .const 'Sub' $P4750 = "511_1300146757.646" 
    capture_lex $P4750
    $P4750()
    goto if_4717_end
  if_4717:
.annotate 'line', 1740
    .const 'Sub' $P4722 = "510_1300146757.646" 
    capture_lex $P4722
    $P4722()
  if_4717_end:
    goto if_4664_end
  if_4664:
.annotate 'line', 1703
    get_hll_global $P4667, ["PAST"], "Stmts"
.annotate 'line', 1704
    get_hll_global $P4668, ["PAST"], "Block"
    find_lex $P4669, "$name"
.annotate 'line', 1705
    get_hll_global $P4670, ["PAST"], "Op"
.annotate 'line', 1706
    get_hll_global $P4671, ["PAST"], "Var"
    $P4672 = $P4671."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4673, "$name"
    $P4674 = $P4670."new"($P4672, $P4673, "!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1705
    find_lex $P4675, "$/"
    $P4676 = $P4668."new"($P4674, $P4669 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4675 :named("node"))
.annotate 'line', 1715
    get_hll_global $P4677, ["PAST"], "Block"
    new $P4678, "String"
    assign $P4678, "!PREFIX__"
    find_lex $P4679, "$name"
    concat $P4680, $P4678, $P4679
.annotate 'line', 1716
    get_hll_global $P4681, ["PAST"], "Op"
.annotate 'line', 1717
    get_hll_global $P4682, ["PAST"], "Var"
    $P4683 = $P4682."new"("self" :named("name"), "parameter" :named("scope"))
    find_lex $P4684, "$name"
    $P4685 = $P4681."new"($P4683, $P4684, "!PREFIX__!protoregex" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 1716
    find_lex $P4686, "$/"
    $P4687 = $P4677."new"($P4685, $P4680 :named("name"), "declaration" :named("blocktype"), 0 :named("lexical"), $P4686 :named("node"))
.annotate 'line', 1715
    $P4688 = $P4667."new"($P4676, $P4687)
.annotate 'line', 1703
    store_lex "$past", $P4688
.annotate 'line', 1727
    find_lex $P4690, "$past"
    $P4691 = $P4690."list"()
    defined $I4692, $P4691
    unless $I4692, for_undef_1960
    iter $P4689, $P4691
    new $P4715, 'ExceptionHandler'
    set_label $P4715, loop4714_handler
    $P4715."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P4715
  loop4714_test:
    unless $P4689, loop4714_done
    shift $P4693, $P4689
  loop4714_redo:
    .const 'Sub' $P4695 = "509_1300146757.646" 
    capture_lex $P4695
    $P4695($P4693)
  loop4714_next:
    goto loop4714_test
  loop4714_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4716, exception, 'type'
    eq $P4716, .CONTROL_LOOP_NEXT, loop4714_next
    eq $P4716, .CONTROL_LOOP_REDO, loop4714_redo
  loop4714_done:
    pop_eh 
  for_undef_1960:
  if_4664_end:
.annotate 'line', 1789
    find_lex $P4808, "$/"
    find_lex $P4809, "$past"
    $P4810 = $P4808."!make"($P4809)
.annotate 'line', 1695
    .return ($P4810)
  control_4648:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P4811, exception, "payload"
    .return ($P4811)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4749"  :anon :subid("511_1300146757.646") :outer("508_1300146757.646")
.annotate 'line', 1754
    new $P4751, "Undef"
    .lex "$regex", $P4751
.annotate 'line', 1755
    get_hll_global $P4752, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P4753, "$/"
    unless_null $P4753, vivify_1940
    $P4753 = root_new ['parrot';'Hash']
  vivify_1940:
    set $P4754, $P4753["p6regex"]
    unless_null $P4754, vivify_1941
    new $P4754, "Undef"
  vivify_1941:
    $P4755 = $P4754."ast"()
    get_global $P4756, "@BLOCK"
    $P4757 = $P4756."shift"()
    $P4758 = $P4752($P4755, $P4757)
    store_lex "$regex", $P4758
.annotate 'line', 1756
    find_lex $P4759, "$regex"
    find_lex $P4760, "$name"
    $P4759."name"($P4760)
.annotate 'line', 1758
    get_hll_global $P4761, ["PAST"], "Op"
.annotate 'line', 1760
    get_hll_global $P4762, ["PAST"], "Var"
    new $P4763, "ResizablePMCArray"
    push $P4763, "Regex"
    $P4764 = $P4762."new"("Method" :named("name"), $P4763 :named("namespace"), "package" :named("scope"))
    find_lex $P4765, "$regex"
    $P4766 = $P4761."new"($P4764, $P4765, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 1758
    store_lex "$past", $P4766
.annotate 'line', 1763
    find_dynamic_lex $P4768, "$*PACKAGE-SETUP"
    unless_null $P4768, vivify_1942
    get_hll_global $P4768, "$PACKAGE-SETUP"
    unless_null $P4768, vivify_1943
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1943:
  vivify_1942:
    defined $I4769, $P4768
    unless $I4769, if_4767_end
.annotate 'line', 1764
    find_dynamic_lex $P4770, "$*PACKAGE-SETUP"
    unless_null $P4770, vivify_1944
    get_hll_global $P4770, "$PACKAGE-SETUP"
    unless_null $P4770, vivify_1945
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1945:
  vivify_1944:
    get_hll_global $P4771, ["PAST"], "Op"
.annotate 'line', 1766
    get_hll_global $P4772, ["PAST"], "Op"
.annotate 'line', 1768
    get_hll_global $P4773, ["PAST"], "Var"
    $P4774 = $P4773."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4775 = $P4772."new"($P4774, "get_how PP" :named("pirop"))
.annotate 'line', 1770
    get_hll_global $P4776, ["PAST"], "Var"
    $P4777 = $P4776."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1771
    get_hll_global $P4778, ["PAST"], "Val"
    find_lex $P4779, "$name"
    $P4780 = $P4778."new"($P4779 :named("value"))
.annotate 'line', 1772
    get_hll_global $P4781, ["PAST"], "Val"
    find_lex $P4782, "$regex"
    $P4783 = $P4781."new"($P4782 :named("value"))
    $P4784 = $P4771."new"($P4775, $P4777, $P4780, $P4783, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1764
    $P4770."push"($P4784)
.annotate 'line', 1774
    find_dynamic_lex $P4785, "$*PACKAGE-SETUP"
    unless_null $P4785, vivify_1946
    get_hll_global $P4785, "$PACKAGE-SETUP"
    unless_null $P4785, vivify_1947
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1947:
  vivify_1946:
    get_hll_global $P4786, ["PAST"], "Op"
.annotate 'line', 1776
    get_hll_global $P4787, ["PAST"], "Op"
.annotate 'line', 1778
    get_hll_global $P4788, ["PAST"], "Var"
    $P4789 = $P4788."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4790 = $P4787."new"($P4789, "get_how PP" :named("pirop"))
.annotate 'line', 1780
    get_hll_global $P4791, ["PAST"], "Var"
    $P4792 = $P4791."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1781
    get_hll_global $P4793, ["PAST"], "Val"
    new $P4794, "String"
    assign $P4794, "!PREFIX__"
    find_lex $P4795, "$name"
    concat $P4796, $P4794, $P4795
    $P4797 = $P4793."new"($P4796 :named("value"))
.annotate 'line', 1782
    get_hll_global $P4798, ["PAST"], "Var"
    new $P4799, "String"
    assign $P4799, "!PREFIX__"
    find_lex $P4800, "$name"
    concat $P4801, $P4799, $P4800
    $P4802 = $P4798."new"($P4801 :named("name"), "package" :named("scope"))
    $P4803 = $P4786."new"($P4790, $P4792, $P4797, $P4802, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1774
    $P4785."push"($P4803)
  if_4767_end:
.annotate 'line', 1786
    find_lex $P4804, "$regex"
    find_lex $P4805, "$past"
    unless_null $P4805, vivify_1948
    $P4805 = root_new ['parrot';'Hash']
    store_lex "$past", $P4805
  vivify_1948:
    set $P4805["sink"], $P4804
.annotate 'line', 1787
    find_lex $P4806, "@MODIFIERS"
    $P4807 = $P4806."shift"()
.annotate 'line', 1753
    .return ($P4807)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4721"  :anon :subid("510_1300146757.646") :outer("508_1300146757.646")
.annotate 'line', 1741
    $P4723 = root_new ['parrot';'Hash']
    .lex "%h", $P4723
.annotate 'line', 1740
    find_lex $P4724, "%h"
.annotate 'line', 1742
    find_lex $P4726, "$/"
    unless_null $P4726, vivify_1949
    $P4726 = root_new ['parrot';'Hash']
  vivify_1949:
    set $P4727, $P4726["sym"]
    unless_null $P4727, vivify_1950
    new $P4727, "Undef"
  vivify_1950:
    set $S4728, $P4727
    iseq $I4729, $S4728, "token"
    unless $I4729, if_4725_end
    new $P4730, "Integer"
    assign $P4730, 1
    find_lex $P4731, "%h"
    unless_null $P4731, vivify_1951
    $P4731 = root_new ['parrot';'Hash']
    store_lex "%h", $P4731
  vivify_1951:
    set $P4731["r"], $P4730
  if_4725_end:
.annotate 'line', 1743
    find_lex $P4733, "$/"
    unless_null $P4733, vivify_1952
    $P4733 = root_new ['parrot';'Hash']
  vivify_1952:
    set $P4734, $P4733["sym"]
    unless_null $P4734, vivify_1953
    new $P4734, "Undef"
  vivify_1953:
    set $S4735, $P4734
    iseq $I4736, $S4735, "rule"
    unless $I4736, if_4732_end
    new $P4737, "Integer"
    assign $P4737, 1
    find_lex $P4738, "%h"
    unless_null $P4738, vivify_1954
    $P4738 = root_new ['parrot';'Hash']
    store_lex "%h", $P4738
  vivify_1954:
    set $P4738["r"], $P4737
    new $P4739, "Integer"
    assign $P4739, 1
    find_lex $P4740, "%h"
    unless_null $P4740, vivify_1955
    $P4740 = root_new ['parrot';'Hash']
    store_lex "%h", $P4740
  vivify_1955:
    set $P4740["s"], $P4739
  if_4732_end:
.annotate 'line', 1744
    find_lex $P4741, "@MODIFIERS"
    find_lex $P4742, "%h"
    $P4741."unshift"($P4742)
.annotate 'line', 1745

                $P0 = find_lex '$name'
                set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
            
.annotate 'line', 1749
    get_global $P4743, "@BLOCK"
    unless_null $P4743, vivify_1956
    $P4743 = root_new ['parrot';'ResizablePMCArray']
  vivify_1956:
    set $P4744, $P4743[0]
    unless_null $P4744, vivify_1957
    new $P4744, "Undef"
  vivify_1957:
    $P4744."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 1750
    get_global $P4745, "@BLOCK"
    unless_null $P4745, vivify_1958
    $P4745 = root_new ['parrot';'ResizablePMCArray']
  vivify_1958:
    set $P4746, $P4745[0]
    unless_null $P4746, vivify_1959
    new $P4746, "Undef"
  vivify_1959:
    $P4746."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 1751
    new $P4747, "Exception"
    set $P4747['type'], .CONTROL_RETURN
    new $P4748, "Integer"
    assign $P4748, 0
    setattribute $P4747, 'payload', $P4748
    throw $P4747
.annotate 'line', 1740
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4694"  :anon :subid("509_1300146757.646") :outer("508_1300146757.646")
    .param pmc param_4696
.annotate 'line', 1727
    .lex "$_", param_4696
.annotate 'line', 1728
    find_dynamic_lex $P4697, "$*PACKAGE-SETUP"
    unless_null $P4697, vivify_1961
    get_hll_global $P4697, "$PACKAGE-SETUP"
    unless_null $P4697, vivify_1962
    die "Contextual $*PACKAGE-SETUP not found"
  vivify_1962:
  vivify_1961:
    get_hll_global $P4698, ["PAST"], "Op"
.annotate 'line', 1730
    get_hll_global $P4699, ["PAST"], "Op"
.annotate 'line', 1732
    get_hll_global $P4700, ["PAST"], "Var"
    $P4701 = $P4700."new"("type_obj" :named("name"), "register" :named("scope"))
    $P4702 = $P4699."new"($P4701, "get_how PP" :named("pirop"))
.annotate 'line', 1734
    get_hll_global $P4703, ["PAST"], "Var"
    $P4704 = $P4703."new"("type_obj" :named("name"), "register" :named("scope"))
.annotate 'line', 1735
    get_hll_global $P4705, ["PAST"], "Val"
    find_lex $P4706, "$_"
    $P4707 = $P4706."name"()
    $P4708 = $P4705."new"($P4707 :named("value"))
.annotate 'line', 1736
    get_hll_global $P4709, ["PAST"], "Val"
    find_lex $P4710, "$_"
    $P4711 = $P4709."new"($P4710 :named("value"))
    $P4712 = $P4698."new"($P4702, $P4704, $P4708, $P4711, "callmethod" :named("pasttype"), "add_method" :named("name"))
.annotate 'line', 1728
    $P4713 = $P4697."push"($P4712)
.annotate 'line', 1727
    .return ($P4713)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "dotty"  :subid("512_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4813
    .param pmc param_4814
.annotate 'line', 1793
    .lex "self", param_4813
    .lex "$/", param_4814
.annotate 'line', 1794
    new $P4815, "Undef"
    .lex "$past", $P4815
    find_lex $P4818, "$/"
    unless_null $P4818, vivify_1963
    $P4818 = root_new ['parrot';'Hash']
  vivify_1963:
    set $P4819, $P4818["args"]
    unless_null $P4819, vivify_1964
    new $P4819, "Undef"
  vivify_1964:
    if $P4819, if_4817
    get_hll_global $P4824, ["PAST"], "Op"
    find_lex $P4825, "$/"
    $P4826 = $P4824."new"($P4825 :named("node"))
    set $P4816, $P4826
    goto if_4817_end
  if_4817:
    find_lex $P4820, "$/"
    unless_null $P4820, vivify_1965
    $P4820 = root_new ['parrot';'Hash']
  vivify_1965:
    set $P4821, $P4820["args"]
    unless_null $P4821, vivify_1966
    $P4821 = root_new ['parrot';'ResizablePMCArray']
  vivify_1966:
    set $P4822, $P4821[0]
    unless_null $P4822, vivify_1967
    new $P4822, "Undef"
  vivify_1967:
    $P4823 = $P4822."ast"()
    set $P4816, $P4823
  if_4817_end:
    store_lex "$past", $P4816
.annotate 'line', 1795
    find_lex $P4828, "$/"
    unless_null $P4828, vivify_1968
    $P4828 = root_new ['parrot';'Hash']
  vivify_1968:
    set $P4829, $P4828["quote"]
    unless_null $P4829, vivify_1969
    new $P4829, "Undef"
  vivify_1969:
    if $P4829, if_4827
.annotate 'line', 1799
    find_lex $P4836, "$/"
    unless_null $P4836, vivify_1970
    $P4836 = root_new ['parrot';'Hash']
  vivify_1970:
    set $P4837, $P4836["longname"]
    unless_null $P4837, vivify_1971
    new $P4837, "Undef"
  vivify_1971:
    set $S4838, $P4837
    iseq $I4839, $S4838, "HOW"
    if $I4839, if_4835
.annotate 'line', 1802
    find_lex $P4842, "$/"
    unless_null $P4842, vivify_1972
    $P4842 = root_new ['parrot';'Hash']
  vivify_1972:
    set $P4843, $P4842["longname"]
    unless_null $P4843, vivify_1973
    new $P4843, "Undef"
  vivify_1973:
    set $S4844, $P4843
    iseq $I4845, $S4844, "WHAT"
    if $I4845, if_4841
.annotate 'line', 1805
    find_lex $P4848, "$/"
    unless_null $P4848, vivify_1974
    $P4848 = root_new ['parrot';'Hash']
  vivify_1974:
    set $P4849, $P4848["longname"]
    unless_null $P4849, vivify_1975
    new $P4849, "Undef"
  vivify_1975:
    set $S4850, $P4849
    iseq $I4851, $S4850, "WHO"
    if $I4851, if_4847
.annotate 'line', 1809
    find_lex $P4853, "$past"
    find_lex $P4854, "$/"
    unless_null $P4854, vivify_1976
    $P4854 = root_new ['parrot';'Hash']
  vivify_1976:
    set $P4855, $P4854["longname"]
    unless_null $P4855, vivify_1977
    new $P4855, "Undef"
  vivify_1977:
    set $S4856, $P4855
    $P4853."name"($S4856)
.annotate 'line', 1810
    find_lex $P4857, "$past"
    $P4857."pasttype"("callmethod")
.annotate 'line', 1808
    goto if_4847_end
  if_4847:
.annotate 'line', 1806
    find_lex $P4852, "$past"
    $P4852."pirop"("get_who PP")
  if_4847_end:
.annotate 'line', 1805
    goto if_4841_end
  if_4841:
.annotate 'line', 1803
    find_lex $P4846, "$past"
    $P4846."pirop"("get_what PP")
  if_4841_end:
.annotate 'line', 1802
    goto if_4835_end
  if_4835:
.annotate 'line', 1800
    find_lex $P4840, "$past"
    $P4840."pirop"("get_how PP")
  if_4835_end:
.annotate 'line', 1799
    goto if_4827_end
  if_4827:
.annotate 'line', 1796
    find_lex $P4830, "$past"
    find_lex $P4831, "$/"
    unless_null $P4831, vivify_1978
    $P4831 = root_new ['parrot';'Hash']
  vivify_1978:
    set $P4832, $P4831["quote"]
    unless_null $P4832, vivify_1979
    new $P4832, "Undef"
  vivify_1979:
    $P4833 = $P4832."ast"()
    $P4830."name"($P4833)
.annotate 'line', 1797
    find_lex $P4834, "$past"
    $P4834."pasttype"("callmethod")
  if_4827_end:
.annotate 'line', 1812
    find_lex $P4858, "$/"
    find_lex $P4859, "$past"
    $P4860 = $P4858."!make"($P4859)
.annotate 'line', 1793
    .return ($P4860)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<self>"  :subid("513_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4862
    .param pmc param_4863
.annotate 'line', 1817
    .lex "self", param_4862
    .lex "$/", param_4863
.annotate 'line', 1818
    find_lex $P4864, "$/"
    get_hll_global $P4865, ["PAST"], "Var"
    $P4866 = $P4865."new"("self" :named("name"))
    $P4867 = $P4864."!make"($P4866)
.annotate 'line', 1817
    .return ($P4867)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<identifier>"  :subid("514_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4869
    .param pmc param_4870
.annotate 'line', 1821
    .lex "self", param_4869
    .lex "$/", param_4870
.annotate 'line', 1822
    new $P4871, "Undef"
    .lex "$past", $P4871
    find_lex $P4872, "$/"
    unless_null $P4872, vivify_1980
    $P4872 = root_new ['parrot';'Hash']
  vivify_1980:
    set $P4873, $P4872["args"]
    unless_null $P4873, vivify_1981
    new $P4873, "Undef"
  vivify_1981:
    $P4874 = $P4873."ast"()
    store_lex "$past", $P4874
.annotate 'line', 1823
    find_lex $P4875, "$past"
    find_lex $P4876, "$/"
    unless_null $P4876, vivify_1982
    $P4876 = root_new ['parrot';'Hash']
  vivify_1982:
    set $P4877, $P4876["deflongname"]
    unless_null $P4877, vivify_1983
    new $P4877, "Undef"
  vivify_1983:
    set $S4878, $P4877
    $P4875."name"($S4878)
.annotate 'line', 1824
    find_lex $P4879, "$/"
    find_lex $P4880, "$past"
    $P4881 = $P4879."!make"($P4880)
.annotate 'line', 1821
    .return ($P4881)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<name>"  :subid("515_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4883
    .param pmc param_4884
.annotate 'line', 1827
    .const 'Sub' $P4899 = "516_1300146757.646" 
    capture_lex $P4899
    .lex "self", param_4883
    .lex "$/", param_4884
.annotate 'line', 1829
    new $P4885, "Undef"
    .lex "$var", $P4885
.annotate 'line', 1841
    new $P4886, "Undef"
    .lex "$past", $P4886
.annotate 'line', 1827
    find_lex $P4887, "$var"
.annotate 'line', 1830
    find_lex $P4889, "$/"
    unless_null $P4889, vivify_1984
    $P4889 = root_new ['parrot';'Hash']
  vivify_1984:
    set $P4890, $P4889["name"]
    unless_null $P4890, vivify_1985
    new $P4890, "Undef"
  vivify_1985:
    set $S4891, $P4890
    $P4892 = "is_lexical"($S4891)
    if $P4892, if_4888
.annotate 'line', 1833
    .const 'Sub' $P4899 = "516_1300146757.646" 
    capture_lex $P4899
    $P4899()
    goto if_4888_end
  if_4888:
.annotate 'line', 1831
    get_hll_global $P4893, ["PAST"], "Var"
    find_lex $P4894, "$/"
    unless_null $P4894, vivify_1991
    $P4894 = root_new ['parrot';'Hash']
  vivify_1991:
    set $P4895, $P4894["name"]
    unless_null $P4895, vivify_1992
    new $P4895, "Undef"
  vivify_1992:
    set $S4896, $P4895
    $P4897 = $P4893."new"($S4896 :named("name"), "lexical" :named("scope"))
    store_lex "$var", $P4897
  if_4888_end:
.annotate 'line', 1841
    find_lex $P4922, "$var"
    store_lex "$past", $P4922
.annotate 'line', 1842
    find_lex $P4924, "$/"
    unless_null $P4924, vivify_1993
    $P4924 = root_new ['parrot';'Hash']
  vivify_1993:
    set $P4925, $P4924["args"]
    unless_null $P4925, vivify_1994
    new $P4925, "Undef"
  vivify_1994:
    unless $P4925, if_4923_end
.annotate 'line', 1843
    find_lex $P4926, "$/"
    unless_null $P4926, vivify_1995
    $P4926 = root_new ['parrot';'Hash']
  vivify_1995:
    set $P4927, $P4926["args"]
    unless_null $P4927, vivify_1996
    $P4927 = root_new ['parrot';'ResizablePMCArray']
  vivify_1996:
    set $P4928, $P4927[0]
    unless_null $P4928, vivify_1997
    new $P4928, "Undef"
  vivify_1997:
    $P4929 = $P4928."ast"()
    store_lex "$past", $P4929
.annotate 'line', 1844
    find_lex $P4930, "$past"
    find_lex $P4931, "$var"
    $P4930."unshift"($P4931)
  if_4923_end:
.annotate 'line', 1846
    find_lex $P4932, "$/"
    find_lex $P4933, "$past"
    $P4934 = $P4932."!make"($P4933)
.annotate 'line', 1827
    .return ($P4934)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block4898"  :anon :subid("516_1300146757.646") :outer("515_1300146757.646")
.annotate 'line', 1834
    $P4900 = root_new ['parrot';'ResizablePMCArray']
    .lex "@ns", $P4900
.annotate 'line', 1835
    new $P4901, "Undef"
    .lex "$name", $P4901
.annotate 'line', 1834
    find_lex $P4902, "$/"
    unless_null $P4902, vivify_1986
    $P4902 = root_new ['parrot';'Hash']
  vivify_1986:
    set $P4903, $P4902["name"]
    unless_null $P4903, vivify_1987
    $P4903 = root_new ['parrot';'Hash']
  vivify_1987:
    set $P4904, $P4903["identifier"]
    unless_null $P4904, vivify_1988
    new $P4904, "Undef"
  vivify_1988:
    clone $P4905, $P4904
    store_lex "@ns", $P4905
.annotate 'line', 1835
    find_lex $P4906, "@ns"
    $P4907 = $P4906."pop"()
    store_lex "$name", $P4907
.annotate 'line', 1836
    find_lex $P4911, "@ns"
    if $P4911, if_4910
    set $P4909, $P4911
    goto if_4910_end
  if_4910:
    find_lex $P4912, "@ns"
    unless_null $P4912, vivify_1989
    $P4912 = root_new ['parrot';'ResizablePMCArray']
  vivify_1989:
    set $P4913, $P4912[0]
    unless_null $P4913, vivify_1990
    new $P4913, "Undef"
  vivify_1990:
    set $S4914, $P4913
    iseq $I4915, $S4914, "GLOBAL"
    new $P4909, 'Integer'
    set $P4909, $I4915
  if_4910_end:
    unless $P4909, if_4908_end
    find_lex $P4916, "@ns"
    $P4916."shift"()
  if_4908_end:
.annotate 'line', 1837
    get_hll_global $P4917, ["PAST"], "Var"
    find_lex $P4918, "$name"
    set $S4919, $P4918
    find_lex $P4920, "@ns"
    $P4921 = $P4917."new"($S4919 :named("name"), $P4920 :named("namespace"), "package" :named("scope"))
    store_lex "$var", $P4921
.annotate 'line', 1833
    .return ($P4921)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<pir::op>"  :subid("517_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4937
    .param pmc param_4938
.annotate 'line', 1859
    .lex "self", param_4937
    .lex "$/", param_4938
.annotate 'line', 1860
    new $P4939, "Undef"
    .lex "$past", $P4939
.annotate 'line', 1861
    new $P4940, "Undef"
    .lex "$pirop", $P4940
.annotate 'line', 1860
    find_lex $P4943, "$/"
    unless_null $P4943, vivify_1998
    $P4943 = root_new ['parrot';'Hash']
  vivify_1998:
    set $P4944, $P4943["args"]
    unless_null $P4944, vivify_1999
    new $P4944, "Undef"
  vivify_1999:
    if $P4944, if_4942
    get_hll_global $P4949, ["PAST"], "Op"
    find_lex $P4950, "$/"
    $P4951 = $P4949."new"($P4950 :named("node"))
    set $P4941, $P4951
    goto if_4942_end
  if_4942:
    find_lex $P4945, "$/"
    unless_null $P4945, vivify_2000
    $P4945 = root_new ['parrot';'Hash']
  vivify_2000:
    set $P4946, $P4945["args"]
    unless_null $P4946, vivify_2001
    $P4946 = root_new ['parrot';'ResizablePMCArray']
  vivify_2001:
    set $P4947, $P4946[0]
    unless_null $P4947, vivify_2002
    new $P4947, "Undef"
  vivify_2002:
    $P4948 = $P4947."ast"()
    set $P4941, $P4948
  if_4942_end:
    store_lex "$past", $P4941
.annotate 'line', 1861
    find_lex $P4952, "$/"
    unless_null $P4952, vivify_2003
    $P4952 = root_new ['parrot';'Hash']
  vivify_2003:
    set $P4953, $P4952["op"]
    unless_null $P4953, vivify_2004
    new $P4953, "Undef"
  vivify_2004:
    set $S4954, $P4953
    new $P4955, 'String'
    set $P4955, $S4954
    store_lex "$pirop", $P4955
.annotate 'line', 1862

            $P0 = find_lex '$pirop'
            $S0 = $P0
            $P0 = split '__', $S0
            $S0 = join ' ', $P0
            $P4956 = box $S0
        
    store_lex "$pirop", $P4956
.annotate 'line', 1869
    find_lex $P4957, "$past"
    find_lex $P4958, "$pirop"
    $P4957."pirop"($P4958)
.annotate 'line', 1870
    find_lex $P4959, "$past"
    $P4959."pasttype"("pirop")
.annotate 'line', 1871
    find_lex $P4960, "$/"
    find_lex $P4961, "$past"
    $P4962 = $P4960."!make"($P4961)
.annotate 'line', 1859
    .return ($P4962)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<onlystar>"  :subid("518_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4964
    .param pmc param_4965
.annotate 'line', 1874
    .lex "self", param_4964
    .lex "$/", param_4965
.annotate 'line', 1875
    find_lex $P4966, "$/"
    get_hll_global $P4967, ["PAST"], "Op"
    $P4968 = $P4967."new"("multi_dispatch_over_lexical_candidates P" :named("pirop"))
    $P4969 = $P4966."!make"($P4968)
.annotate 'line', 1874
    .return ($P4969)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "args"  :subid("519_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4971
    .param pmc param_4972
.annotate 'line', 1880
    .lex "self", param_4971
    .lex "$/", param_4972
    find_lex $P4973, "$/"
    find_lex $P4974, "$/"
    unless_null $P4974, vivify_2005
    $P4974 = root_new ['parrot';'Hash']
  vivify_2005:
    set $P4975, $P4974["arglist"]
    unless_null $P4975, vivify_2006
    new $P4975, "Undef"
  vivify_2006:
    $P4976 = $P4975."ast"()
    $P4977 = $P4973."!make"($P4976)
    .return ($P4977)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "arglist"  :subid("520_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_4979
    .param pmc param_4980
.annotate 'line', 1882
    .const 'Sub' $P4991 = "521_1300146757.646" 
    capture_lex $P4991
    .lex "self", param_4979
    .lex "$/", param_4980
.annotate 'line', 1883
    new $P4981, "Undef"
    .lex "$past", $P4981
.annotate 'line', 1891
    new $P4982, "Undef"
    .lex "$i", $P4982
.annotate 'line', 1892
    new $P4983, "Undef"
    .lex "$n", $P4983
.annotate 'line', 1883
    get_hll_global $P4984, ["PAST"], "Op"
    find_lex $P4985, "$/"
    $P4986 = $P4984."new"("call" :named("pasttype"), $P4985 :named("node"))
    store_lex "$past", $P4986
.annotate 'line', 1884
    find_lex $P4988, "$/"
    unless_null $P4988, vivify_2007
    $P4988 = root_new ['parrot';'Hash']
  vivify_2007:
    set $P4989, $P4988["EXPR"]
    unless_null $P4989, vivify_2008
    new $P4989, "Undef"
  vivify_2008:
    unless $P4989, if_4987_end
    .const 'Sub' $P4991 = "521_1300146757.646" 
    capture_lex $P4991
    $P4991()
  if_4987_end:
.annotate 'line', 1891
    new $P5023, "Integer"
    assign $P5023, 0
    store_lex "$i", $P5023
.annotate 'line', 1892
    find_lex $P5024, "$past"
    $P5025 = $P5024."list"()
    set $N5026, $P5025
    new $P5027, 'Float'
    set $P5027, $N5026
    store_lex "$n", $P5027
.annotate 'line', 1893
    new $P5075, 'ExceptionHandler'
    set_label $P5075, loop5074_handler
    $P5075."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5075
  loop5074_test:
    find_lex $P5028, "$i"
    set $N5029, $P5028
    find_lex $P5030, "$n"
    set $N5031, $P5030
    islt $I5032, $N5029, $N5031
    unless $I5032, loop5074_done
  loop5074_redo:
.annotate 'line', 1894
    find_lex $P5034, "$i"
    set $I5035, $P5034
    find_lex $P5036, "$past"
    unless_null $P5036, vivify_2012
    $P5036 = root_new ['parrot';'ResizablePMCArray']
  vivify_2012:
    set $P5037, $P5036[$I5035]
    unless_null $P5037, vivify_2013
    new $P5037, "Undef"
  vivify_2013:
    $S5038 = $P5037."name"()
    iseq $I5039, $S5038, "&prefix:<|>"
    unless $I5039, if_5033_end
.annotate 'line', 1895
    find_lex $P5040, "$i"
    set $I5041, $P5040
    find_lex $P5042, "$past"
    unless_null $P5042, vivify_2014
    $P5042 = root_new ['parrot';'ResizablePMCArray']
  vivify_2014:
    set $P5043, $P5042[$I5041]
    unless_null $P5043, vivify_2015
    $P5043 = root_new ['parrot';'ResizablePMCArray']
  vivify_2015:
    set $P5044, $P5043[0]
    unless_null $P5044, vivify_2016
    new $P5044, "Undef"
  vivify_2016:
    find_lex $P5045, "$i"
    set $I5046, $P5045
    find_lex $P5047, "$past"
    unless_null $P5047, vivify_2017
    $P5047 = root_new ['parrot';'ResizablePMCArray']
    store_lex "$past", $P5047
  vivify_2017:
    set $P5047[$I5046], $P5044
.annotate 'line', 1896
    find_lex $P5048, "$i"
    set $I5049, $P5048
    find_lex $P5050, "$past"
    unless_null $P5050, vivify_2018
    $P5050 = root_new ['parrot';'ResizablePMCArray']
  vivify_2018:
    set $P5051, $P5050[$I5049]
    unless_null $P5051, vivify_2019
    new $P5051, "Undef"
  vivify_2019:
    $P5051."flat"(1)
.annotate 'line', 1897
    find_lex $P5055, "$i"
    set $I5056, $P5055
    find_lex $P5057, "$past"
    unless_null $P5057, vivify_2020
    $P5057 = root_new ['parrot';'ResizablePMCArray']
  vivify_2020:
    set $P5058, $P5057[$I5056]
    unless_null $P5058, vivify_2021
    new $P5058, "Undef"
  vivify_2021:
    get_hll_global $P5059, ["PAST"], "Val"
    $P5060 = $P5058."isa"($P5059)
    if $P5060, if_5054
    set $P5053, $P5060
    goto if_5054_end
  if_5054:
.annotate 'line', 1898
    find_lex $P5061, "$i"
    set $I5062, $P5061
    find_lex $P5063, "$past"
    unless_null $P5063, vivify_2022
    $P5063 = root_new ['parrot';'ResizablePMCArray']
  vivify_2022:
    set $P5064, $P5063[$I5062]
    unless_null $P5064, vivify_2023
    new $P5064, "Undef"
  vivify_2023:
    $S5065 = $P5064."name"()
    substr $S5066, $S5065, 0, 1
    iseq $I5067, $S5066, "%"
    new $P5053, 'Integer'
    set $P5053, $I5067
  if_5054_end:
    unless $P5053, if_5052_end
.annotate 'line', 1899
    find_lex $P5068, "$i"
    set $I5069, $P5068
    find_lex $P5070, "$past"
    unless_null $P5070, vivify_2024
    $P5070 = root_new ['parrot';'ResizablePMCArray']
  vivify_2024:
    set $P5071, $P5070[$I5069]
    unless_null $P5071, vivify_2025
    new $P5071, "Undef"
  vivify_2025:
    $P5071."named"(1)
  if_5052_end:
  if_5033_end:
.annotate 'line', 1894
    find_lex $P5072, "$i"
    clone $P5073, $P5072
    inc $P5072
  loop5074_next:
.annotate 'line', 1893
    goto loop5074_test
  loop5074_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5076, exception, 'type'
    eq $P5076, .CONTROL_LOOP_NEXT, loop5074_next
    eq $P5076, .CONTROL_LOOP_REDO, loop5074_redo
  loop5074_done:
    pop_eh 
.annotate 'line', 1904
    find_lex $P5077, "$/"
    find_lex $P5078, "$past"
    $P5079 = $P5077."!make"($P5078)
.annotate 'line', 1882
    .return ($P5079)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "_block4990"  :anon :subid("521_1300146757.646") :outer("520_1300146757.646")
.annotate 'line', 1884
    .const 'Sub' $P5012 = "522_1300146757.646" 
    capture_lex $P5012
.annotate 'line', 1885
    new $P4992, "Undef"
    .lex "$expr", $P4992
    find_lex $P4993, "$/"
    unless_null $P4993, vivify_2009
    $P4993 = root_new ['parrot';'Hash']
  vivify_2009:
    set $P4994, $P4993["EXPR"]
    unless_null $P4994, vivify_2010
    new $P4994, "Undef"
  vivify_2010:
    $P4995 = $P4994."ast"()
    store_lex "$expr", $P4995
.annotate 'line', 1886
    find_lex $P5000, "$expr"
    $S5001 = $P5000."name"()
    iseq $I5002, $S5001, "&infix:<,>"
    if $I5002, if_4999
    new $P4998, 'Integer'
    set $P4998, $I5002
    goto if_4999_end
  if_4999:
    find_lex $P5003, "$expr"
    $P5004 = $P5003."named"()
    isfalse $I5005, $P5004
    new $P4998, 'Integer'
    set $P4998, $I5005
  if_4999_end:
    if $P4998, if_4997
.annotate 'line', 1889
    find_lex $P5020, "$past"
    find_lex $P5021, "$expr"
    $P5022 = $P5020."push"($P5021)
    set $P4996, $P5022
.annotate 'line', 1886
    goto if_4997_end
  if_4997:
.annotate 'line', 1887
    find_lex $P5007, "$expr"
    $P5008 = $P5007."list"()
    defined $I5009, $P5008
    unless $I5009, for_undef_2011
    iter $P5006, $P5008
    new $P5018, 'ExceptionHandler'
    set_label $P5018, loop5017_handler
    $P5018."handle_types"(.CONTROL_LOOP_NEXT, .CONTROL_LOOP_REDO, .CONTROL_LOOP_LAST)
    push_eh $P5018
  loop5017_test:
    unless $P5006, loop5017_done
    shift $P5010, $P5006
  loop5017_redo:
    .const 'Sub' $P5012 = "522_1300146757.646" 
    capture_lex $P5012
    $P5012($P5010)
  loop5017_next:
    goto loop5017_test
  loop5017_handler:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5019, exception, 'type'
    eq $P5019, .CONTROL_LOOP_NEXT, loop5017_next
    eq $P5019, .CONTROL_LOOP_REDO, loop5017_redo
  loop5017_done:
    pop_eh 
  for_undef_2011:
.annotate 'line', 1886
    set $P4996, $P5006
  if_4997_end:
.annotate 'line', 1884
    .return ($P4996)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5011"  :anon :subid("522_1300146757.646") :outer("521_1300146757.646")
    .param pmc param_5013
.annotate 'line', 1887
    .lex "$_", param_5013
    find_lex $P5014, "$past"
    find_lex $P5015, "$_"
    $P5016 = $P5014."push"($P5015)
    .return ($P5016)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<multi_declarator>"  :subid("523_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5081
    .param pmc param_5082
.annotate 'line', 1907
    .lex "self", param_5081
    .lex "$/", param_5082
    find_lex $P5083, "$/"
    find_lex $P5084, "$/"
    unless_null $P5084, vivify_2026
    $P5084 = root_new ['parrot';'Hash']
  vivify_2026:
    set $P5085, $P5084["multi_declarator"]
    unless_null $P5085, vivify_2027
    new $P5085, "Undef"
  vivify_2027:
    $P5086 = $P5085."ast"()
    $P5087 = $P5083."!make"($P5086)
    .return ($P5087)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<value>"  :subid("524_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5089
    .param pmc param_5090
.annotate 'line', 1909
    .lex "self", param_5089
    .lex "$/", param_5090
    find_lex $P5091, "$/"
    find_lex $P5092, "$/"
    unless_null $P5092, vivify_2028
    $P5092 = root_new ['parrot';'Hash']
  vivify_2028:
    set $P5093, $P5092["value"]
    unless_null $P5093, vivify_2029
    new $P5093, "Undef"
  vivify_2029:
    $P5094 = $P5093."ast"()
    $P5095 = $P5091."!make"($P5094)
    .return ($P5095)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<( )>"  :subid("525_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5097
    .param pmc param_5098
.annotate 'line', 1911
    .lex "self", param_5097
    .lex "$/", param_5098
.annotate 'line', 1912
    find_lex $P5099, "$/"
.annotate 'line', 1913
    find_lex $P5102, "$/"
    unless_null $P5102, vivify_2030
    $P5102 = root_new ['parrot';'Hash']
  vivify_2030:
    set $P5103, $P5102["EXPR"]
    unless_null $P5103, vivify_2031
    new $P5103, "Undef"
  vivify_2031:
    if $P5103, if_5101
.annotate 'line', 1914
    get_hll_global $P5108, ["PAST"], "Op"
    find_lex $P5109, "$/"
    $P5110 = $P5108."new"("list" :named("pasttype"), $P5109 :named("node"))
    set $P5100, $P5110
.annotate 'line', 1913
    goto if_5101_end
  if_5101:
    find_lex $P5104, "$/"
    unless_null $P5104, vivify_2032
    $P5104 = root_new ['parrot';'Hash']
  vivify_2032:
    set $P5105, $P5104["EXPR"]
    unless_null $P5105, vivify_2033
    $P5105 = root_new ['parrot';'ResizablePMCArray']
  vivify_2033:
    set $P5106, $P5105[0]
    unless_null $P5106, vivify_2034
    new $P5106, "Undef"
  vivify_2034:
    $P5107 = $P5106."ast"()
    set $P5100, $P5107
  if_5101_end:
    $P5111 = $P5099."!make"($P5100)
.annotate 'line', 1911
    .return ($P5111)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<[ ]>"  :subid("526_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5113
    .param pmc param_5114
.annotate 'line', 1917
    .lex "self", param_5113
    .lex "$/", param_5114
.annotate 'line', 1918
    new $P5115, "Undef"
    .lex "$past", $P5115
.annotate 'line', 1917
    find_lex $P5116, "$past"
.annotate 'line', 1919
    find_lex $P5118, "$/"
    unless_null $P5118, vivify_2035
    $P5118 = root_new ['parrot';'Hash']
  vivify_2035:
    set $P5119, $P5118["EXPR"]
    unless_null $P5119, vivify_2036
    new $P5119, "Undef"
  vivify_2036:
    if $P5119, if_5117
.annotate 'line', 1926
    get_hll_global $P5131, ["PAST"], "Op"
    $P5132 = $P5131."new"("list" :named("pasttype"))
    store_lex "$past", $P5132
.annotate 'line', 1925
    goto if_5117_end
  if_5117:
.annotate 'line', 1920
    find_lex $P5120, "$/"
    unless_null $P5120, vivify_2037
    $P5120 = root_new ['parrot';'Hash']
  vivify_2037:
    set $P5121, $P5120["EXPR"]
    unless_null $P5121, vivify_2038
    $P5121 = root_new ['parrot';'ResizablePMCArray']
  vivify_2038:
    set $P5122, $P5121[0]
    unless_null $P5122, vivify_2039
    new $P5122, "Undef"
  vivify_2039:
    $P5123 = $P5122."ast"()
    store_lex "$past", $P5123
.annotate 'line', 1921
    find_lex $P5125, "$past"
    $S5126 = $P5125."name"()
    isne $I5127, $S5126, "&infix:<,>"
    unless $I5127, if_5124_end
.annotate 'line', 1922
    get_hll_global $P5128, ["PAST"], "Op"
    find_lex $P5129, "$past"
    $P5130 = $P5128."new"($P5129, "list" :named("pasttype"))
    store_lex "$past", $P5130
  if_5124_end:
  if_5117_end:
.annotate 'line', 1928
    find_lex $P5133, "$past"
    $P5133."name"("&circumfix:<[ ]>")
.annotate 'line', 1929
    find_lex $P5134, "$/"
    find_lex $P5135, "$past"
    $P5136 = $P5134."!make"($P5135)
.annotate 'line', 1917
    .return ($P5136)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<ang>"  :subid("527_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5138
    .param pmc param_5139
.annotate 'line', 1932
    .lex "self", param_5138
    .lex "$/", param_5139
    find_lex $P5140, "$/"
    find_lex $P5141, "$/"
    unless_null $P5141, vivify_2040
    $P5141 = root_new ['parrot';'Hash']
  vivify_2040:
    set $P5142, $P5141["quote_EXPR"]
    unless_null $P5142, vivify_2041
    new $P5142, "Undef"
  vivify_2041:
    $P5143 = $P5142."ast"()
    $P5144 = $P5140."!make"($P5143)
    .return ($P5144)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub unicode:"circumfix:sym<\x{ab} \x{bb}>"  :subid("528_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5146
    .param pmc param_5147
.annotate 'line', 1933
    .lex "self", param_5146
    .lex "$/", param_5147
    find_lex $P5148, "$/"
    find_lex $P5149, "$/"
    unless_null $P5149, vivify_2042
    $P5149 = root_new ['parrot';'Hash']
  vivify_2042:
    set $P5150, $P5149["quote_EXPR"]
    unless_null $P5150, vivify_2043
    new $P5150, "Undef"
  vivify_2043:
    $P5151 = $P5150."ast"()
    $P5152 = $P5148."!make"($P5151)
    .return ($P5152)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<{ }>"  :subid("529_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5154
    .param pmc param_5155
.annotate 'line', 1935
    .const 'Sub' $P5166 = "530_1300146757.646" 
    capture_lex $P5166
    .lex "self", param_5154
    .lex "$/", param_5155
.annotate 'line', 1936
    find_lex $P5158, "$/"
    unless_null $P5158, vivify_2044
    $P5158 = root_new ['parrot';'Hash']
  vivify_2044:
    set $P5159, $P5158["pblock"]
    unless_null $P5159, vivify_2045
    $P5159 = root_new ['parrot';'Hash']
  vivify_2045:
    set $P5160, $P5159["blockoid"]
    unless_null $P5160, vivify_2046
    $P5160 = root_new ['parrot';'Hash']
  vivify_2046:
    set $P5161, $P5160["statementlist"]
    unless_null $P5161, vivify_2047
    $P5161 = root_new ['parrot';'Hash']
  vivify_2047:
    set $P5162, $P5161["statement"]
    unless_null $P5162, vivify_2048
    new $P5162, "Undef"
  vivify_2048:
    set $N5163, $P5162
    isgt $I5164, $N5163, 0.0
    if $I5164, if_5157
.annotate 'line', 1941
    find_lex $P5179, "$/"
    unless_null $P5179, vivify_2049
    $P5179 = root_new ['parrot';'Hash']
  vivify_2049:
    set $P5180, $P5179["pblock"]
    unless_null $P5180, vivify_2050
    $P5180 = root_new ['parrot';'Hash']
  vivify_2050:
    set $P5181, $P5180["blockoid"]
    unless_null $P5181, vivify_2051
    $P5181 = root_new ['parrot';'Hash']
  vivify_2051:
    set $P5182, $P5181["you_are_here"]
    unless_null $P5182, vivify_2052
    new $P5182, "Undef"
  vivify_2052:
    if $P5182, if_5178
.annotate 'line', 1945
    find_lex $P5188, "$/"
    $P5189 = "vivitype"("%")
    $P5190 = $P5188."!make"($P5189)
.annotate 'line', 1944
    set $P5177, $P5190
.annotate 'line', 1941
    goto if_5178_end
  if_5178:
.annotate 'line', 1942
    find_lex $P5183, "$/"
    find_lex $P5184, "$/"
    unless_null $P5184, vivify_2053
    $P5184 = root_new ['parrot';'Hash']
  vivify_2053:
    set $P5185, $P5184["pblock"]
    unless_null $P5185, vivify_2054
    new $P5185, "Undef"
  vivify_2054:
    $P5186 = $P5185."ast"()
    $P5187 = $P5183."!make"($P5186)
.annotate 'line', 1941
    set $P5177, $P5187
  if_5178_end:
    set $P5156, $P5177
.annotate 'line', 1936
    goto if_5157_end
  if_5157:
    .const 'Sub' $P5166 = "530_1300146757.646" 
    capture_lex $P5166
    $P5176 = $P5166()
    set $P5156, $P5176
  if_5157_end:
.annotate 'line', 1935
    .return ($P5156)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "_block5165"  :anon :subid("530_1300146757.646") :outer("529_1300146757.646")
.annotate 'line', 1937
    new $P5167, "Undef"
    .lex "$past", $P5167
    find_lex $P5168, "$/"
    unless_null $P5168, vivify_2055
    $P5168 = root_new ['parrot';'Hash']
  vivify_2055:
    set $P5169, $P5168["pblock"]
    unless_null $P5169, vivify_2056
    new $P5169, "Undef"
  vivify_2056:
    $P5170 = $P5169."ast"()
    store_lex "$past", $P5170
.annotate 'line', 1938
    new $P5171, "Integer"
    assign $P5171, 1
    find_lex $P5172, "$past"
    unless_null $P5172, vivify_2057
    $P5172 = root_new ['parrot';'Hash']
    store_lex "$past", $P5172
  vivify_2057:
    set $P5172["bareblock"], $P5171
.annotate 'line', 1939
    find_dynamic_lex $P5173, "$/"
    find_lex $P5174, "$past"
    $P5175 = $P5173."!make"($P5174)
.annotate 'line', 1936
    .return ($P5175)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "circumfix:sym<sigil>"  :subid("531_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5192
    .param pmc param_5193
.annotate 'line', 1949
    .lex "self", param_5192
    .lex "$/", param_5193
.annotate 'line', 1950
    new $P5194, "Undef"
    .lex "$name", $P5194
    find_lex $P5197, "$/"
    unless_null $P5197, vivify_2058
    $P5197 = root_new ['parrot';'Hash']
  vivify_2058:
    set $P5198, $P5197["sigil"]
    unless_null $P5198, vivify_2059
    new $P5198, "Undef"
  vivify_2059:
    set $S5199, $P5198
    iseq $I5200, $S5199, "@"
    if $I5200, if_5196
.annotate 'line', 1951
    find_lex $P5204, "$/"
    unless_null $P5204, vivify_2060
    $P5204 = root_new ['parrot';'Hash']
  vivify_2060:
    set $P5205, $P5204["sigil"]
    unless_null $P5205, vivify_2061
    new $P5205, "Undef"
  vivify_2061:
    set $S5206, $P5205
    iseq $I5207, $S5206, "%"
    if $I5207, if_5203
    new $P5209, "String"
    assign $P5209, "item"
    set $P5202, $P5209
    goto if_5203_end
  if_5203:
    new $P5208, "String"
    assign $P5208, "hash"
    set $P5202, $P5208
  if_5203_end:
    set $P5195, $P5202
.annotate 'line', 1950
    goto if_5196_end
  if_5196:
    new $P5201, "String"
    assign $P5201, "list"
    set $P5195, $P5201
  if_5196_end:
    store_lex "$name", $P5195
.annotate 'line', 1953
    find_lex $P5210, "$/"
    get_hll_global $P5211, ["PAST"], "Op"
    find_lex $P5212, "$name"
    find_lex $P5213, "$/"
    unless_null $P5213, vivify_2062
    $P5213 = root_new ['parrot';'Hash']
  vivify_2062:
    set $P5214, $P5213["semilist"]
    unless_null $P5214, vivify_2063
    new $P5214, "Undef"
  vivify_2063:
    $P5215 = $P5214."ast"()
    $P5216 = $P5211."new"($P5215, "callmethod" :named("pasttype"), $P5212 :named("name"))
    $P5217 = $P5210."!make"($P5216)
.annotate 'line', 1949
    .return ($P5217)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "semilist"  :subid("532_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5219
    .param pmc param_5220
.annotate 'line', 1956
    .lex "self", param_5219
    .lex "$/", param_5220
    find_lex $P5221, "$/"
    find_lex $P5222, "$/"
    unless_null $P5222, vivify_2064
    $P5222 = root_new ['parrot';'Hash']
  vivify_2064:
    set $P5223, $P5222["statement"]
    unless_null $P5223, vivify_2065
    new $P5223, "Undef"
  vivify_2065:
    $P5224 = $P5223."ast"()
    $P5225 = $P5221."!make"($P5224)
    .return ($P5225)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<[ ]>"  :subid("533_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5227
    .param pmc param_5228
.annotate 'line', 1958
    .lex "self", param_5227
    .lex "$/", param_5228
.annotate 'line', 1959
    find_lex $P5229, "$/"
    get_hll_global $P5230, ["PAST"], "Var"
    find_lex $P5231, "$/"
    unless_null $P5231, vivify_2066
    $P5231 = root_new ['parrot';'Hash']
  vivify_2066:
    set $P5232, $P5231["EXPR"]
    unless_null $P5232, vivify_2067
    new $P5232, "Undef"
  vivify_2067:
    $P5233 = $P5232."ast"()
.annotate 'line', 1961
    $P5234 = "vivitype"("@")
    $P5235 = $P5230."new"($P5233, "keyed_int" :named("scope"), "Undef" :named("viviself"), $P5234 :named("vivibase"))
.annotate 'line', 1959
    $P5236 = $P5229."!make"($P5235)
.annotate 'line', 1958
    .return ($P5236)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<{ }>"  :subid("534_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5238
    .param pmc param_5239
.annotate 'line', 1964
    .lex "self", param_5238
    .lex "$/", param_5239
.annotate 'line', 1965
    find_lex $P5240, "$/"
    get_hll_global $P5241, ["PAST"], "Var"
    find_lex $P5242, "$/"
    unless_null $P5242, vivify_2068
    $P5242 = root_new ['parrot';'Hash']
  vivify_2068:
    set $P5243, $P5242["EXPR"]
    unless_null $P5243, vivify_2069
    new $P5243, "Undef"
  vivify_2069:
    $P5244 = $P5243."ast"()
.annotate 'line', 1967
    $P5245 = "vivitype"("%")
    $P5246 = $P5241."new"($P5244, "keyed" :named("scope"), "Undef" :named("viviself"), $P5245 :named("vivibase"))
.annotate 'line', 1965
    $P5247 = $P5240."!make"($P5246)
.annotate 'line', 1964
    .return ($P5247)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<ang>"  :subid("535_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5249
    .param pmc param_5250
.annotate 'line', 1970
    .lex "self", param_5249
    .lex "$/", param_5250
.annotate 'line', 1971
    find_lex $P5251, "$/"
    get_hll_global $P5252, ["PAST"], "Var"
    find_lex $P5253, "$/"
    unless_null $P5253, vivify_2070
    $P5253 = root_new ['parrot';'Hash']
  vivify_2070:
    set $P5254, $P5253["quote_EXPR"]
    unless_null $P5254, vivify_2071
    new $P5254, "Undef"
  vivify_2071:
    $P5255 = $P5254."ast"()
.annotate 'line', 1973
    $P5256 = "vivitype"("%")
    $P5257 = $P5252."new"($P5255, "keyed" :named("scope"), "Undef" :named("viviself"), $P5256 :named("vivibase"))
.annotate 'line', 1971
    $P5258 = $P5251."!make"($P5257)
.annotate 'line', 1970
    .return ($P5258)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postcircumfix:sym<( )>"  :subid("536_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5260
    .param pmc param_5261
.annotate 'line', 1976
    .lex "self", param_5260
    .lex "$/", param_5261
.annotate 'line', 1977
    find_lex $P5262, "$/"
    find_lex $P5263, "$/"
    unless_null $P5263, vivify_2072
    $P5263 = root_new ['parrot';'Hash']
  vivify_2072:
    set $P5264, $P5263["arglist"]
    unless_null $P5264, vivify_2073
    new $P5264, "Undef"
  vivify_2073:
    $P5265 = $P5264."ast"()
    $P5266 = $P5262."!make"($P5265)
.annotate 'line', 1976
    .return ($P5266)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "value"  :subid("537_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5268
    .param pmc param_5269
.annotate 'line', 1980
    .lex "self", param_5268
    .lex "$/", param_5269
.annotate 'line', 1981
    find_lex $P5270, "$/"
    find_lex $P5273, "$/"
    unless_null $P5273, vivify_2074
    $P5273 = root_new ['parrot';'Hash']
  vivify_2074:
    set $P5274, $P5273["quote"]
    unless_null $P5274, vivify_2075
    new $P5274, "Undef"
  vivify_2075:
    if $P5274, if_5272
    find_lex $P5278, "$/"
    unless_null $P5278, vivify_2076
    $P5278 = root_new ['parrot';'Hash']
  vivify_2076:
    set $P5279, $P5278["number"]
    unless_null $P5279, vivify_2077
    new $P5279, "Undef"
  vivify_2077:
    $P5280 = $P5279."ast"()
    set $P5271, $P5280
    goto if_5272_end
  if_5272:
    find_lex $P5275, "$/"
    unless_null $P5275, vivify_2078
    $P5275 = root_new ['parrot';'Hash']
  vivify_2078:
    set $P5276, $P5275["quote"]
    unless_null $P5276, vivify_2079
    new $P5276, "Undef"
  vivify_2079:
    $P5277 = $P5276."ast"()
    set $P5271, $P5277
  if_5272_end:
    $P5281 = $P5270."!make"($P5271)
.annotate 'line', 1980
    .return ($P5281)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "number"  :subid("538_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5283
    .param pmc param_5284
.annotate 'line', 1984
    .lex "self", param_5283
    .lex "$/", param_5284
.annotate 'line', 1985
    new $P5285, "Undef"
    .lex "$value", $P5285
    find_lex $P5288, "$/"
    unless_null $P5288, vivify_2080
    $P5288 = root_new ['parrot';'Hash']
  vivify_2080:
    set $P5289, $P5288["dec_number"]
    unless_null $P5289, vivify_2081
    new $P5289, "Undef"
  vivify_2081:
    if $P5289, if_5287
    find_lex $P5293, "$/"
    unless_null $P5293, vivify_2082
    $P5293 = root_new ['parrot';'Hash']
  vivify_2082:
    set $P5294, $P5293["integer"]
    unless_null $P5294, vivify_2083
    new $P5294, "Undef"
  vivify_2083:
    $P5295 = $P5294."ast"()
    set $P5286, $P5295
    goto if_5287_end
  if_5287:
    find_lex $P5290, "$/"
    unless_null $P5290, vivify_2084
    $P5290 = root_new ['parrot';'Hash']
  vivify_2084:
    set $P5291, $P5290["dec_number"]
    unless_null $P5291, vivify_2085
    new $P5291, "Undef"
  vivify_2085:
    $P5292 = $P5291."ast"()
    set $P5286, $P5292
  if_5287_end:
    store_lex "$value", $P5286
.annotate 'line', 1986
    find_lex $P5297, "$/"
    unless_null $P5297, vivify_2086
    $P5297 = root_new ['parrot';'Hash']
  vivify_2086:
    set $P5298, $P5297["sign"]
    unless_null $P5298, vivify_2087
    new $P5298, "Undef"
  vivify_2087:
    set $S5299, $P5298
    iseq $I5300, $S5299, "-"
    unless $I5300, if_5296_end
    find_lex $P5301, "$value"
    neg $P5302, $P5301
    store_lex "$value", $P5302
  if_5296_end:
.annotate 'line', 1987
    find_lex $P5303, "$/"
    get_hll_global $P5304, ["PAST"], "Val"
    find_lex $P5305, "$value"
    $P5306 = $P5304."new"($P5305 :named("value"))
    $P5307 = $P5303."!make"($P5306)
.annotate 'line', 1984
    .return ($P5307)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<apos>"  :subid("539_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5309
    .param pmc param_5310
.annotate 'line', 1990
    .lex "self", param_5309
    .lex "$/", param_5310
    find_lex $P5311, "$/"
    find_lex $P5312, "$/"
    unless_null $P5312, vivify_2088
    $P5312 = root_new ['parrot';'Hash']
  vivify_2088:
    set $P5313, $P5312["quote_EXPR"]
    unless_null $P5313, vivify_2089
    new $P5313, "Undef"
  vivify_2089:
    $P5314 = $P5313."ast"()
    $P5315 = $P5311."!make"($P5314)
    .return ($P5315)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<dblq>"  :subid("540_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5317
    .param pmc param_5318
.annotate 'line', 1991
    .lex "self", param_5317
    .lex "$/", param_5318
    find_lex $P5319, "$/"
    find_lex $P5320, "$/"
    unless_null $P5320, vivify_2090
    $P5320 = root_new ['parrot';'Hash']
  vivify_2090:
    set $P5321, $P5320["quote_EXPR"]
    unless_null $P5321, vivify_2091
    new $P5321, "Undef"
  vivify_2091:
    $P5322 = $P5321."ast"()
    $P5323 = $P5319."!make"($P5322)
    .return ($P5323)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<qq>"  :subid("541_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5325
    .param pmc param_5326
.annotate 'line', 1992
    .lex "self", param_5325
    .lex "$/", param_5326
    find_lex $P5327, "$/"
    find_lex $P5328, "$/"
    unless_null $P5328, vivify_2092
    $P5328 = root_new ['parrot';'Hash']
  vivify_2092:
    set $P5329, $P5328["quote_EXPR"]
    unless_null $P5329, vivify_2093
    new $P5329, "Undef"
  vivify_2093:
    $P5330 = $P5329."ast"()
    $P5331 = $P5327."!make"($P5330)
    .return ($P5331)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<q>"  :subid("542_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5333
    .param pmc param_5334
.annotate 'line', 1993
    .lex "self", param_5333
    .lex "$/", param_5334
    find_lex $P5335, "$/"
    find_lex $P5336, "$/"
    unless_null $P5336, vivify_2094
    $P5336 = root_new ['parrot';'Hash']
  vivify_2094:
    set $P5337, $P5336["quote_EXPR"]
    unless_null $P5337, vivify_2095
    new $P5337, "Undef"
  vivify_2095:
    $P5338 = $P5337."ast"()
    $P5339 = $P5335."!make"($P5338)
    .return ($P5339)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q>"  :subid("543_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5341
    .param pmc param_5342
.annotate 'line', 1994
    .lex "self", param_5341
    .lex "$/", param_5342
    find_lex $P5343, "$/"
    find_lex $P5344, "$/"
    unless_null $P5344, vivify_2096
    $P5344 = root_new ['parrot';'Hash']
  vivify_2096:
    set $P5345, $P5344["quote_EXPR"]
    unless_null $P5345, vivify_2097
    new $P5345, "Undef"
  vivify_2097:
    $P5346 = $P5345."ast"()
    $P5347 = $P5343."!make"($P5346)
    .return ($P5347)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote:sym<Q:PIR>"  :subid("544_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5349
    .param pmc param_5350
.annotate 'line', 1995
    .lex "self", param_5349
    .lex "$/", param_5350
.annotate 'line', 1996
    find_lex $P5351, "$/"
    get_hll_global $P5352, ["PAST"], "Op"
    find_lex $P5353, "$/"
    unless_null $P5353, vivify_2098
    $P5353 = root_new ['parrot';'Hash']
  vivify_2098:
    set $P5354, $P5353["quote_EXPR"]
    unless_null $P5354, vivify_2099
    new $P5354, "Undef"
  vivify_2099:
    $P5355 = $P5354."ast"()
    $P5356 = $P5355."value"()
    find_lex $P5357, "$/"
    $P5358 = $P5352."new"($P5356 :named("inline"), "inline" :named("pasttype"), $P5357 :named("node"))
    $P5359 = $P5351."!make"($P5358)
.annotate 'line', 1995
    .return ($P5359)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.include "except_types.pasm"
.sub "quote:sym</ />"  :subid("545_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5363
    .param pmc param_5364
    .param pmc param_5365 :optional
    .param int has_param_5365 :opt_flag
.annotate 'line', 2001
    new $P5362, ['ExceptionHandler'], .CONTROL_RETURN
    set_label $P5362, control_5361
    push_eh $P5362
    .lex "self", param_5363
    .lex "$/", param_5364
    if has_param_5365, optparam_2100
    new $P5366, "Undef"
    set param_5365, $P5366
  optparam_2100:
    .lex "$key", param_5365
.annotate 'line', 2011
    new $P5367, "Undef"
    .lex "$regex", $P5367
.annotate 'line', 2013
    new $P5368, "Undef"
    .lex "$past", $P5368
.annotate 'line', 2002
    find_lex $P5370, "$key"
    set $S5371, $P5370
    iseq $I5372, $S5371, "open"
    unless $I5372, if_5369_end
.annotate 'line', 2003

                null $P0
                set_hll_global ['Regex';'P6Regex';'Actions'], '$REGEXNAME', $P0
            
.annotate 'line', 2007
    get_global $P5373, "@BLOCK"
    unless_null $P5373, vivify_2101
    $P5373 = root_new ['parrot';'ResizablePMCArray']
  vivify_2101:
    set $P5374, $P5373[0]
    unless_null $P5374, vivify_2102
    new $P5374, "Undef"
  vivify_2102:
    $P5374."symbol"(unicode:"$\x{a2}", "lexical" :named("scope"))
.annotate 'line', 2008
    get_global $P5375, "@BLOCK"
    unless_null $P5375, vivify_2103
    $P5375 = root_new ['parrot';'ResizablePMCArray']
  vivify_2103:
    set $P5376, $P5375[0]
    unless_null $P5376, vivify_2104
    new $P5376, "Undef"
  vivify_2104:
    $P5376."symbol"("$/", "lexical" :named("scope"))
.annotate 'line', 2009
    new $P5377, "Exception"
    set $P5377['type'], .CONTROL_RETURN
    new $P5378, "Integer"
    assign $P5378, 0
    setattribute $P5377, 'payload', $P5378
    throw $P5377
  if_5369_end:
.annotate 'line', 2012
    get_hll_global $P5379, ["Regex";"P6Regex";"Actions"], "buildsub"
    find_lex $P5380, "$/"
    unless_null $P5380, vivify_2105
    $P5380 = root_new ['parrot';'Hash']
  vivify_2105:
    set $P5381, $P5380["p6regex"]
    unless_null $P5381, vivify_2106
    new $P5381, "Undef"
  vivify_2106:
    $P5382 = $P5381."ast"()
    get_global $P5383, "@BLOCK"
    $P5384 = $P5383."shift"()
    $P5385 = $P5379($P5382, $P5384)
    store_lex "$regex", $P5385
.annotate 'line', 2014
    get_hll_global $P5386, ["PAST"], "Op"
.annotate 'line', 2016
    get_hll_global $P5387, ["PAST"], "Var"
    new $P5388, "ResizablePMCArray"
    push $P5388, "Regex"
    $P5389 = $P5387."new"("Regex" :named("name"), $P5388 :named("namespace"), "package" :named("scope"))
    find_lex $P5390, "$regex"
    $P5391 = $P5386."new"($P5389, $P5390, "callmethod" :named("pasttype"), "new" :named("name"))
.annotate 'line', 2014
    store_lex "$past", $P5391
.annotate 'line', 2020
    find_lex $P5392, "$regex"
    find_lex $P5393, "$past"
    unless_null $P5393, vivify_2107
    $P5393 = root_new ['parrot';'Hash']
    store_lex "$past", $P5393
  vivify_2107:
    set $P5393["sink"], $P5392
.annotate 'line', 2021
    find_lex $P5394, "$/"
    find_lex $P5395, "$past"
    $P5396 = $P5394."!make"($P5395)
.annotate 'line', 2001
    .return ($P5396)
  control_5361:
    .local pmc exception 
    .get_results (exception) 
    getattribute $P5397, exception, "payload"
    .return ($P5397)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<$>"  :subid("546_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5399
    .param pmc param_5400
.annotate 'line', 2024
    .lex "self", param_5399
    .lex "$/", param_5400
    find_lex $P5401, "$/"
    find_lex $P5402, "$/"
    unless_null $P5402, vivify_2108
    $P5402 = root_new ['parrot';'Hash']
  vivify_2108:
    set $P5403, $P5402["variable"]
    unless_null $P5403, vivify_2109
    new $P5403, "Undef"
  vivify_2109:
    $P5404 = $P5403."ast"()
    $P5405 = $P5401."!make"($P5404)
    .return ($P5405)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<{ }>"  :subid("547_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5407
    .param pmc param_5408
.annotate 'line', 2025
    .lex "self", param_5407
    .lex "$/", param_5408
.annotate 'line', 2026
    find_lex $P5409, "$/"
    get_hll_global $P5410, ["PAST"], "Op"
.annotate 'line', 2027
    find_lex $P5411, "$/"
    unless_null $P5411, vivify_2110
    $P5411 = root_new ['parrot';'Hash']
  vivify_2110:
    set $P5412, $P5411["block"]
    unless_null $P5412, vivify_2111
    new $P5412, "Undef"
  vivify_2111:
    $P5413 = $P5412."ast"()
    $P5414 = "block_immediate"($P5413)
    find_lex $P5415, "$/"
    $P5416 = $P5410."new"($P5414, "set S*" :named("pirop"), $P5415 :named("node"))
.annotate 'line', 2026
    $P5417 = $P5409."!make"($P5416)
.annotate 'line', 2025
    .return ($P5417)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "quote_escape:sym<esc>"  :subid("548_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5419
    .param pmc param_5420
.annotate 'line', 2030
    .lex "self", param_5419
    .lex "$/", param_5420
    find_lex $P5421, "$/"
    $P5422 = $P5421."!make"("\e")
    .return ($P5422)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<.>"  :subid("549_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5424
    .param pmc param_5425
.annotate 'line', 2034
    .lex "self", param_5424
    .lex "$/", param_5425
    find_lex $P5426, "$/"
    find_lex $P5427, "$/"
    unless_null $P5427, vivify_2112
    $P5427 = root_new ['parrot';'Hash']
  vivify_2112:
    set $P5428, $P5427["dotty"]
    unless_null $P5428, vivify_2113
    new $P5428, "Undef"
  vivify_2113:
    $P5429 = $P5428."ast"()
    $P5430 = $P5426."!make"($P5429)
    .return ($P5430)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<++>"  :subid("550_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5432
    .param pmc param_5433
.annotate 'line', 2036
    .lex "self", param_5432
    .lex "$/", param_5433
.annotate 'line', 2037
    find_lex $P5434, "$/"
    get_hll_global $P5435, ["PAST"], "Op"
.annotate 'line', 2038
    new $P5436, "ResizablePMCArray"
    push $P5436, "    clone %r, %0"
    push $P5436, "    inc %0"
    $P5437 = $P5435."new"("postfix:<++>" :named("name"), $P5436 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2037
    $P5438 = $P5434."!make"($P5437)
.annotate 'line', 2036
    .return ($P5438)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "postfix:sym<-->"  :subid("551_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5440
    .param pmc param_5441
.annotate 'line', 2042
    .lex "self", param_5440
    .lex "$/", param_5441
.annotate 'line', 2043
    find_lex $P5442, "$/"
    get_hll_global $P5443, ["PAST"], "Op"
.annotate 'line', 2044
    new $P5444, "ResizablePMCArray"
    push $P5444, "    clone %r, %0"
    push $P5444, "    dec %0"
    $P5445 = $P5443."new"("postfix:<-->" :named("name"), $P5444 :named("inline"), "inline" :named("pasttype"))
.annotate 'line', 2043
    $P5446 = $P5442."!make"($P5445)
.annotate 'line', 2042
    .return ($P5446)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "prefix:sym<make>"  :subid("552_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5448
    .param pmc param_5449
.annotate 'line', 2048
    .lex "self", param_5448
    .lex "$/", param_5449
.annotate 'line', 2049
    find_lex $P5450, "$/"
    get_hll_global $P5451, ["PAST"], "Op"
.annotate 'line', 2050
    get_hll_global $P5452, ["PAST"], "Var"
    $P5453 = $P5452."new"("$/" :named("name"), "contextual" :named("scope"))
    find_lex $P5454, "$/"
    $P5455 = $P5451."new"($P5453, "callmethod" :named("pasttype"), "!make" :named("name"), $P5454 :named("node"))
.annotate 'line', 2049
    $P5456 = $P5450."!make"($P5455)
.annotate 'line', 2048
    .return ($P5456)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<next>"  :subid("553_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5459
    .param pmc param_5460
.annotate 'line', 2066
    .lex "self", param_5459
    .lex "$/", param_5460
    find_lex $P5461, "$/"
    $P5462 = "control"($P5461, "CONTROL_LOOP_NEXT")
    .return ($P5462)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<last>"  :subid("554_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5464
    .param pmc param_5465
.annotate 'line', 2067
    .lex "self", param_5464
    .lex "$/", param_5465
    find_lex $P5466, "$/"
    $P5467 = "control"($P5466, "CONTROL_LOOP_LAST")
    .return ($P5467)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "term:sym<redo>"  :subid("555_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5469
    .param pmc param_5470
.annotate 'line', 2068
    .lex "self", param_5469
    .lex "$/", param_5470
    find_lex $P5471, "$/"
    $P5472 = "control"($P5471, "CONTROL_LOOP_REDO")
    .return ($P5472)
.end


.HLL "nqp"

.namespace ["NQP";"Actions"]
.sub "infix:sym<~~>"  :subid("556_1300146757.646") :outer("405_1300146757.646")
    .param pmc param_5474
    .param pmc param_5475
.annotate 'line', 2070
    .lex "self", param_5474
    .lex "$/", param_5475
.annotate 'line', 2071
    find_lex $P5476, "$/"
    get_hll_global $P5477, ["PAST"], "Op"
    find_lex $P5478, "$/"
    $P5479 = $P5477."new"("callmethod" :named("pasttype"), "ACCEPTS" :named("name"), $P5478 :named("node"))
    $P5480 = $P5476."!make"($P5479)
.annotate 'line', 2070
    .return ($P5480)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5705"  :subid("558_1300146757.646") :outer("10_1300146757.646")
.annotate 'line', 2075
    .const 'Sub' $P5805 = "566_1300146757.646" 
    capture_lex $P5805
    .const 'Sub' $P5780 = "565_1300146757.646" 
    capture_lex $P5780
    .const 'Sub' $P5769 = "564_1300146757.646" 
    capture_lex $P5769
    .const 'Sub' $P5754 = "563_1300146757.646" 
    capture_lex $P5754
    .const 'Sub' $P5743 = "562_1300146757.646" 
    capture_lex $P5743
    .const 'Sub' $P5732 = "561_1300146757.646" 
    capture_lex $P5732
    .const 'Sub' $P5721 = "560_1300146757.646" 
    capture_lex $P5721
    .const 'Sub' $P5708 = "559_1300146757.646" 
    capture_lex $P5708
    get_global $P5707, "$?CLASS"
.annotate 'line', 2109
    .const 'Sub' $P5780 = "565_1300146757.646" 
    newclosure $P5803, $P5780
.annotate 'line', 2075
    .return ($P5803)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "" :load :init :subid("post2114") :outer("558_1300146757.646")
.annotate 'line', 2075
    get_hll_global $P5706, ["NQP";"RegexActions"], "_block5705" 
    .local pmc block
    set block, $P5706
    .const 'Sub' $P5805 = "566_1300146757.646" 
    capture_lex $P5805
    $P5805()
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "_block5804"  :anon :subid("566_1300146757.646") :outer("558_1300146757.646")
.annotate 'line', 2075
    nqp_get_sc_object $P5806, "1300146737.899", 3
    .local pmc type_obj
    set type_obj, $P5806
    set_global "$?CLASS", type_obj
    get_how $P5807, type_obj
    .const 'Sub' $P5808 = "559_1300146757.646" 
    $P5807."add_method"(type_obj, "metachar:sym<:my>", $P5808)
    get_how $P5809, type_obj
    .const 'Sub' $P5810 = "560_1300146757.646" 
    $P5809."add_method"(type_obj, "metachar:sym<{ }>", $P5810)
    get_how $P5811, type_obj
    .const 'Sub' $P5812 = "561_1300146757.646" 
    $P5811."add_method"(type_obj, "metachar:sym<nqpvar>", $P5812)
    get_how $P5813, type_obj
    .const 'Sub' $P5814 = "562_1300146757.646" 
    $P5813."add_method"(type_obj, "assertion:sym<{ }>", $P5814)
    get_how $P5815, type_obj
    .const 'Sub' $P5816 = "563_1300146757.646" 
    $P5815."add_method"(type_obj, "assertion:sym<?{ }>", $P5816)
    get_how $P5817, type_obj
    .const 'Sub' $P5818 = "564_1300146757.646" 
    $P5817."add_method"(type_obj, "assertion:sym<var>", $P5818)
    get_how $P5819, type_obj
    .const 'Sub' $P5820 = "565_1300146757.646" 
    $P5819."add_method"(type_obj, "codeblock", $P5820)
    get_how $P5821, type_obj
    get_hll_global $P5822, ["Regex";"P6Regex"], "Actions"
    $P5821."add_parent"(type_obj, $P5822)
    get_how $P5823, type_obj
    $P5824 = $P5823."compose"(type_obj)
    .return ($P5824)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<:my>"  :subid("559_1300146757.646") :outer("558_1300146757.646")
    .param pmc param_5709
    .param pmc param_5710
.annotate 'line', 2077
    .lex "self", param_5709
    .lex "$/", param_5710
.annotate 'line', 2078
    new $P5711, "Undef"
    .lex "$past", $P5711
    find_lex $P5712, "$/"
    unless_null $P5712, vivify_2115
    $P5712 = root_new ['parrot';'Hash']
  vivify_2115:
    set $P5713, $P5712["statement"]
    unless_null $P5713, vivify_2116
    new $P5713, "Undef"
  vivify_2116:
    $P5714 = $P5713."ast"()
    store_lex "$past", $P5714
.annotate 'line', 2079
    find_lex $P5715, "$/"
    get_hll_global $P5716, ["PAST"], "Regex"
    find_lex $P5717, "$past"
    find_lex $P5718, "$/"
    $P5719 = $P5716."new"($P5717, "pastnode" :named("pasttype"), "declarative" :named("subtype"), $P5718 :named("node"))
    $P5720 = $P5715."!make"($P5719)
.annotate 'line', 2077
    .return ($P5720)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<{ }>"  :subid("560_1300146757.646") :outer("558_1300146757.646")
    .param pmc param_5722
    .param pmc param_5723
.annotate 'line', 2083
    .lex "self", param_5722
    .lex "$/", param_5723
.annotate 'line', 2084
    find_lex $P5724, "$/"
    get_hll_global $P5725, ["PAST"], "Regex"
    find_lex $P5726, "$/"
    unless_null $P5726, vivify_2117
    $P5726 = root_new ['parrot';'Hash']
  vivify_2117:
    set $P5727, $P5726["codeblock"]
    unless_null $P5727, vivify_2118
    new $P5727, "Undef"
  vivify_2118:
    $P5728 = $P5727."ast"()
    find_lex $P5729, "$/"
    $P5730 = $P5725."new"($P5728, "pastnode" :named("pasttype"), $P5729 :named("node"))
    $P5731 = $P5724."!make"($P5730)
.annotate 'line', 2083
    .return ($P5731)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "metachar:sym<nqpvar>"  :subid("561_1300146757.646") :outer("558_1300146757.646")
    .param pmc param_5733
    .param pmc param_5734
.annotate 'line', 2088
    .lex "self", param_5733
    .lex "$/", param_5734
.annotate 'line', 2089
    find_lex $P5735, "$/"
    get_hll_global $P5736, ["PAST"], "Regex"
    find_lex $P5737, "$/"
    unless_null $P5737, vivify_2119
    $P5737 = root_new ['parrot';'Hash']
  vivify_2119:
    set $P5738, $P5737["var"]
    unless_null $P5738, vivify_2120
    new $P5738, "Undef"
  vivify_2120:
    $P5739 = $P5738."ast"()
    find_lex $P5740, "$/"
    $P5741 = $P5736."new"("!INTERPOLATE", $P5739, "subrule" :named("pasttype"), "method" :named("subtype"), $P5740 :named("node"))
    $P5742 = $P5735."!make"($P5741)
.annotate 'line', 2088
    .return ($P5742)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<{ }>"  :subid("562_1300146757.646") :outer("558_1300146757.646")
    .param pmc param_5744
    .param pmc param_5745
.annotate 'line', 2093
    .lex "self", param_5744
    .lex "$/", param_5745
.annotate 'line', 2094
    find_lex $P5746, "$/"
    get_hll_global $P5747, ["PAST"], "Regex"
    find_lex $P5748, "$/"
    unless_null $P5748, vivify_2121
    $P5748 = root_new ['parrot';'Hash']
  vivify_2121:
    set $P5749, $P5748["codeblock"]
    unless_null $P5749, vivify_2122
    new $P5749, "Undef"
  vivify_2122:
    $P5750 = $P5749."ast"()
    find_lex $P5751, "$/"
    $P5752 = $P5747."new"("!INTERPOLATE_REGEX", $P5750, "subrule" :named("pasttype"), "method" :named("subtype"), $P5751 :named("node"))
    $P5753 = $P5746."!make"($P5752)
.annotate 'line', 2093
    .return ($P5753)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<?{ }>"  :subid("563_1300146757.646") :outer("558_1300146757.646")
    .param pmc param_5755
    .param pmc param_5756
.annotate 'line', 2098
    .lex "self", param_5755
    .lex "$/", param_5756
.annotate 'line', 2099
    find_lex $P5757, "$/"
    get_hll_global $P5758, ["PAST"], "Regex"
    find_lex $P5759, "$/"
    unless_null $P5759, vivify_2123
    $P5759 = root_new ['parrot';'Hash']
  vivify_2123:
    set $P5760, $P5759["codeblock"]
    unless_null $P5760, vivify_2124
    new $P5760, "Undef"
  vivify_2124:
    $P5761 = $P5760."ast"()
.annotate 'line', 2100
    find_lex $P5762, "$/"
    unless_null $P5762, vivify_2125
    $P5762 = root_new ['parrot';'Hash']
  vivify_2125:
    set $P5763, $P5762["zw"]
    unless_null $P5763, vivify_2126
    new $P5763, "Undef"
  vivify_2126:
    set $S5764, $P5763
    iseq $I5765, $S5764, "!"
    find_lex $P5766, "$/"
    $P5767 = $P5758."new"($P5761, "zerowidth" :named("subtype"), $I5765 :named("negate"), "pastnode" :named("pasttype"), $P5766 :named("node"))
.annotate 'line', 2099
    $P5768 = $P5757."!make"($P5767)
.annotate 'line', 2098
    .return ($P5768)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "assertion:sym<var>"  :subid("564_1300146757.646") :outer("558_1300146757.646")
    .param pmc param_5770
    .param pmc param_5771
.annotate 'line', 2104
    .lex "self", param_5770
    .lex "$/", param_5771
.annotate 'line', 2105
    find_lex $P5772, "$/"
    get_hll_global $P5773, ["PAST"], "Regex"
    find_lex $P5774, "$/"
    unless_null $P5774, vivify_2127
    $P5774 = root_new ['parrot';'Hash']
  vivify_2127:
    set $P5775, $P5774["var"]
    unless_null $P5775, vivify_2128
    new $P5775, "Undef"
  vivify_2128:
    $P5776 = $P5775."ast"()
    find_lex $P5777, "$/"
    $P5778 = $P5773."new"("!INTERPOLATE_REGEX", $P5776, "subrule" :named("pasttype"), "method" :named("subtype"), $P5777 :named("node"))
    $P5779 = $P5772."!make"($P5778)
.annotate 'line', 2104
    .return ($P5779)
.end


.HLL "nqp"

.namespace ["NQP";"RegexActions"]
.sub "codeblock"  :subid("565_1300146757.646") :outer("558_1300146757.646")
    .param pmc param_5781
    .param pmc param_5782
.annotate 'line', 2109
    .lex "self", param_5781
    .lex "$/", param_5782
.annotate 'line', 2110
    new $P5783, "Undef"
    .lex "$block", $P5783
.annotate 'line', 2112
    new $P5784, "Undef"
    .lex "$past", $P5784
.annotate 'line', 2110
    find_lex $P5785, "$/"
    unless_null $P5785, vivify_2129
    $P5785 = root_new ['parrot';'Hash']
  vivify_2129:
    set $P5786, $P5785["block"]
    unless_null $P5786, vivify_2130
    new $P5786, "Undef"
  vivify_2130:
    $P5787 = $P5786."ast"()
    store_lex "$block", $P5787
.annotate 'line', 2111
    find_lex $P5788, "$block"
    $P5788."blocktype"("immediate")
.annotate 'line', 2113
    get_hll_global $P5789, ["PAST"], "Stmts"
.annotate 'line', 2114
    get_hll_global $P5790, ["PAST"], "Op"
.annotate 'line', 2115
    get_hll_global $P5791, ["PAST"], "Var"
    $P5792 = $P5791."new"("$/" :named("name"))
.annotate 'line', 2116
    get_hll_global $P5793, ["PAST"], "Op"
.annotate 'line', 2117
    get_hll_global $P5794, ["PAST"], "Var"
    $P5795 = $P5794."new"(unicode:"$\x{a2}" :named("name"))
    $P5796 = $P5793."new"($P5795, "MATCH" :named("name"), "callmethod" :named("pasttype"))
.annotate 'line', 2116
    $P5797 = $P5790."new"($P5792, $P5796, "bind" :named("pasttype"))
.annotate 'line', 2114
    find_lex $P5798, "$block"
    $P5799 = $P5789."new"($P5797, $P5798)
.annotate 'line', 2113
    store_lex "$past", $P5799
.annotate 'line', 2125
    find_lex $P5800, "$/"
    find_lex $P5801, "$past"
    $P5802 = $P5800."!make"($P5801)
.annotate 'line', 2109
    .return ($P5802)
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block5825"  :subid("567_1300146757.646") :outer("10_1300146757.646")
.annotate 'line', 2130
    .const 'Sub' $P5829 = "568_1300146757.646" 
    capture_lex $P5829
    get_global $P5827, "$?CLASS"
    .return ()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "" :load :init :subid("post2131") :outer("567_1300146757.646")
.annotate 'line', 2130
    get_hll_global $P5826, ["NQP";"Compiler"], "_block5825" 
    .local pmc block
    set block, $P5826
    .const 'Sub' $P5829 = "568_1300146757.646" 
    capture_lex $P5829
    $P5829()
.end


.HLL "nqp"

.namespace ["NQP";"Compiler"]
.sub "_block5828"  :anon :subid("568_1300146757.646") :outer("567_1300146757.646")
.annotate 'line', 2130
    nqp_get_sc_object $P5830, "1300146737.899", 4
    .local pmc type_obj
    set type_obj, $P5830
    set_global "$?CLASS", type_obj
    get_how $P5831, type_obj
    get_hll_global $P5832, ["HLL"], "Compiler"
    $P5831."add_parent"(type_obj, $P5832)
    get_how $P5833, type_obj
    $P5834 = $P5833."compose"(type_obj)
    .return ($P5834)
.end


.HLL "nqp"

.namespace []
.sub "_block5842" :load :anon :subid("569_1300146757.646")
.annotate 'line', 1
    .const 'Sub' $P5844 = "10_1300146757.646" 
    $P5845 = $P5844()
    .return ($P5845)
.end

